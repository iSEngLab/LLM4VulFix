,source,target
0,"CWE-295 NOEXPORT void transfer ( CLI * c ) { int timeout ; int pending ; # if OPENSSL_VERSION_NUMBER >= 0x10100000L int has_pending = 0 , prev_has_pending ; # endif <S2SV_StartBug> int watchdog = 0 ; <S2SV_EndBug> ssize_t num ; int err ; int sock_open_rd = 1 , sock_open_wr = 1 ; int shutdown_wants_read = 0 , shutdown_wants_write = 0 ; int read_wants_read = 0 , read_wants_write = 0 ; int write_wants_read = 0 , write_wants_write = 0 ; int sock_can_rd , sock_can_wr , ssl_can_rd , ssl_can_wr ; # ifdef USE_WIN32 unsigned long bytes ; # else int bytes ; # endif c -> sock_ptr = c -> ssl_ptr = 0 ; do { read_wants_read |= ! ( SSL_get_shutdown ( c -> ssl ) & SSL_RECEIVED_SHUTDOWN ) && c -> ssl_ptr < BUFFSIZE && ! read_wants_write ; write_wants_write |= ! ( SSL_get_shutdown ( c -> ssl ) & SSL_SENT_SHUTDOWN ) && c -> sock_ptr && ! write_wants_read ; s_poll_init ( c -> fds , 0 ) ; if ( sock_open_rd ) s_poll_add ( c -> fds , c -> sock_rfd -> fd , c -> sock_ptr < BUFFSIZE , 0 ) ; if ( sock_open_wr ) s_poll_add ( c -> fds , c -> sock_wfd -> fd , 0 , c -> ssl_ptr > 0 ) ; if ( SSL_get_shutdown ( c -> ssl ) != ( SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN ) ) { s_poll_add ( c -> fds , c -> ssl_rfd -> fd , read_wants_read || write_wants_read || shutdown_wants_read , 0 ) ; s_poll_add ( c -> fds , c -> ssl_wfd -> fd , 0 , read_wants_write || write_wants_write || shutdown_wants_write ) ; } pending = SSL_pending ( c -> ssl ) ; # if OPENSSL_VERSION_NUMBER >= 0x10100000L prev_has_pending = has_pending ; has_pending = SSL_has_pending ( c -> ssl ) ; pending = pending || ( has_pending && ! prev_has_pending ) ; # endif if ( read_wants_read && pending ) { timeout = 0 ; } else if ( ( sock_open_rd && ! ( SSL_get_shutdown ( c -> ssl ) & SSL_RECEIVED_SHUTDOWN ) ) || c -> ssl_ptr || c -> sock_ptr ) { timeout = c -> opt -> timeout_idle ; } else { timeout = c -> opt -> timeout_close ; } err = s_poll_wait ( c -> fds , timeout , 0 ) ; switch ( err ) { case - 1 : sockerror ( ""transfer:<S2SV_blank>s_poll_wait"" ) ; throw_exception ( c , 1 ) ; case 0 : if ( read_wants_read && pending ) break ; if ( ( sock_open_rd && ! ( SSL_get_shutdown ( c -> ssl ) & SSL_RECEIVED_SHUTDOWN ) ) || c -> ssl_ptr || c -> sock_ptr ) { s_log ( LOG_INFO , ""transfer:<S2SV_blank>s_poll_wait:"" ""<S2SV_blank>TIMEOUTidle<S2SV_blank>exceeded:<S2SV_blank>sending<S2SV_blank>reset"" ) ; s_poll_dump ( c -> fds , LOG_DEBUG ) ; throw_exception ( c , 1 ) ; } s_log ( LOG_ERR , ""transfer:<S2SV_blank>s_poll_wait:"" ""<S2SV_blank>TIMEOUTclose<S2SV_blank>exceeded:<S2SV_blank>closing"" ) ; s_poll_dump ( c -> fds , LOG_DEBUG ) ; return ; } sock_can_rd = s_poll_canread ( c -> fds , c -> sock_rfd -> fd ) ; sock_can_wr = s_poll_canwrite ( c -> fds , c -> sock_wfd -> fd ) ; ssl_can_rd = s_poll_canread ( c -> fds , c -> ssl_rfd -> fd ) ; ssl_can_wr = s_poll_canwrite ( c -> fds , c -> ssl_wfd -> fd ) ; if ( c -> sock_rfd -> fd == c -> sock_wfd -> fd ) { if ( ( sock_can_rd || sock_can_wr ) && s_poll_err ( c -> fds , c -> sock_rfd -> fd ) ) { err = get_socket_error ( c -> sock_rfd -> fd ) ; if ( err ) log_error ( LOG_INFO , err , ""socket<S2SV_blank>fd"" ) ; } } else { if ( sock_can_rd && s_poll_err ( c -> fds , c -> sock_rfd -> fd ) ) { err = get_socket_error ( c -> sock_rfd -> fd ) ; if ( err ) log_error ( LOG_INFO , err , ""socket<S2SV_blank>rfd"" ) ; } if ( sock_can_wr && s_poll_err ( c -> fds , c -> sock_wfd -> fd ) ) { err = get_socket_error ( c -> sock_wfd -> fd ) ; if ( err ) log_error ( LOG_INFO , err , ""socket<S2SV_blank>wfd"" ) ; } } if ( c -> ssl_rfd -> fd == c -> ssl_wfd -> fd ) { if ( ( ssl_can_rd || ssl_can_wr ) && s_poll_err ( c -> fds , c -> ssl_rfd -> fd ) ) { err = get_socket_error ( c -> ssl_rfd -> fd ) ; if ( err ) log_error ( LOG_INFO , err , ""TLS<S2SV_blank>fd"" ) ; } } else { if ( ssl_can_rd && s_poll_err ( c -> fds , c -> ssl_rfd -> fd ) ) { err = get_socket_error ( c -> ssl_rfd -> fd ) ; if ( err ) log_error ( LOG_INFO , err , ""TLS<S2SV_blank>rfd"" ) ; } if ( c -> ssl_rfd -> fd != c -> ssl_wfd -> fd && ssl_can_wr && s_poll_err ( c -> fds , c -> ssl_wfd -> fd ) ) { err = get_socket_error ( c -> ssl_wfd -> fd ) ; if ( err ) log_error ( LOG_INFO , err , ""TLS<S2SV_blank>wfd"" ) ; } } if ( ! ( sock_can_rd || sock_can_wr || ssl_can_rd || ssl_can_wr ) ) { if ( s_poll_hup ( c -> fds , c -> sock_rfd -> fd ) || s_poll_hup ( c -> fds , c -> sock_wfd -> fd ) ) { if ( c -> ssl_ptr ) { s_log ( LOG_ERR , ""Socket<S2SV_blank>closed<S2SV_blank>(HUP)<S2SV_blank>with<S2SV_blank>%ld<S2SV_blank>unsent<S2SV_blank>byte(s)"" , ( long ) c -> ssl_ptr ) ; throw_exception ( c , 1 ) ; } s_log ( LOG_INFO , ""Socket<S2SV_blank>closed<S2SV_blank>(HUP)"" ) ; sock_open_rd = sock_open_wr = 0 ; } else if ( s_poll_hup ( c -> fds , c -> ssl_rfd -> fd ) || s_poll_hup ( c -> fds , c -> ssl_wfd -> fd ) ) { if ( c -> sock_ptr ) { s_log ( LOG_ERR , ""TLS<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(HUP)<S2SV_blank>with<S2SV_blank>%ld<S2SV_blank>unsent<S2SV_blank>byte(s)"" , ( long ) c -> sock_ptr ) ; throw_exception ( c , 1 ) ; } s_log ( LOG_INFO , ""TLS<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(HUP)"" ) ; SSL_set_shutdown ( c -> ssl , SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN ) ; } } if ( c -> reneg_state == RENEG_DETECTED && ! c -> opt -> option . renegotiation ) { s_log ( LOG_ERR , ""Aborting<S2SV_blank>due<S2SV_blank>to<S2SV_blank>renegotiation<S2SV_blank>request"" ) ; throw_exception ( c , 1 ) ; } if ( shutdown_wants_read || shutdown_wants_write ) { <S2SV_StartBug> num = SSL_shutdown ( c -> ssl ) ; <S2SV_EndBug> if ( num < 0 ) <S2SV_StartBug> err = SSL_get_error ( c -> ssl , ( int ) num ) ; <S2SV_EndBug> else err = SSL_ERROR_NONE ; switch ( err ) { case SSL_ERROR_NONE : s_log ( LOG_INFO , ""SSL_shutdown<S2SV_blank>successfully<S2SV_blank>sent<S2SV_blank>close_notify<S2SV_blank>alert"" ) ; shutdown_wants_read = shutdown_wants_write = 0 ; break ; <S2SV_StartBug> case SSL_ERROR_SYSCALL : <S2SV_EndBug> if ( parse_socket_error ( c , ""SSL_shutdown"" ) ) break ; SSL_set_shutdown ( c -> ssl , SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN ) ; shutdown_wants_read = shutdown_wants_write = 0 ; break ; <S2SV_StartBug> case SSL_ERROR_ZERO_RETURN : <S2SV_EndBug> SSL_set_shutdown ( c -> ssl , SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN ) ; shutdown_wants_read = shutdown_wants_write = 0 ; break ; <S2SV_StartBug> case SSL_ERROR_WANT_WRITE : <S2SV_EndBug> s_log ( LOG_DEBUG , ""SSL_shutdown<S2SV_blank>returned<S2SV_blank>WANT_WRITE:<S2SV_blank>retrying"" ) ; shutdown_wants_read = 0 ; shutdown_wants_write = 1 ; break ; case SSL_ERROR_WANT_READ : s_log ( LOG_DEBUG , ""SSL_shutdown<S2SV_blank>returned<S2SV_blank>WANT_READ:<S2SV_blank>retrying"" ) ; shutdown_wants_read = 1 ; shutdown_wants_write = 0 ; break ; case SSL_ERROR_SSL : sslerror ( ""SSL_shutdown"" ) ; throw_exception ( c , 1 ) ; default : s_log ( LOG_ERR , ""SSL_shutdown/SSL_get_error<S2SV_blank>returned<S2SV_blank>%d"" , err ) ; throw_exception ( c , 1 ) ; } } if ( sock_open_wr && sock_can_wr ) { <S2SV_StartBug> num = writesocket ( c -> sock_wfd -> fd , c -> ssl_buff , c -> ssl_ptr ) ; <S2SV_EndBug> switch ( num ) { case - 1 : if ( parse_socket_error ( c , ""writesocket"" ) ) break ; sock_open_rd = sock_open_wr = 0 ; break ; case 0 : s_log ( LOG_DEBUG , ""writesocket<S2SV_blank>returned<S2SV_blank>0"" ) ; break ; default : memmove ( c -> ssl_buff , c -> ssl_buff + num , c -> ssl_ptr - ( size_t ) num ) ; c -> ssl_ptr -= ( size_t ) num ; memset ( c -> ssl_buff + c -> ssl_ptr , 0 , ( size_t ) num ) ; c -> sock_bytes += ( size_t ) num ; watchdog = 0 ; } } if ( sock_open_rd && sock_can_rd ) { <S2SV_StartBug> num = readsocket ( c -> sock_rfd -> fd , <S2SV_EndBug> c -> sock_buff + c -> sock_ptr , BUFFSIZE - c -> sock_ptr ) ; switch ( num ) { case - 1 : if ( parse_socket_error ( c , ""readsocket"" ) ) break ; sock_open_rd = sock_open_wr = 0 ; break ; case 0 : s_log ( LOG_INFO , ""Read<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(readsocket)"" ) ; sock_open_rd = 0 ; break ; default : c -> sock_ptr += ( size_t ) num ; watchdog = 0 ; } } read_wants_read |= ! ( SSL_get_shutdown ( c -> ssl ) & SSL_RECEIVED_SHUTDOWN ) && c -> ssl_ptr < BUFFSIZE && ! read_wants_write ; write_wants_write |= ! ( SSL_get_shutdown ( c -> ssl ) & SSL_SENT_SHUTDOWN ) && c -> sock_ptr && ! write_wants_read ; if ( ( write_wants_read && ssl_can_rd ) || ( write_wants_write && ssl_can_wr ) ) { <S2SV_StartBug> write_wants_read = 0 ; <S2SV_EndBug> write_wants_write = 0 ; <S2SV_StartBug> num = SSL_write ( c -> ssl , c -> sock_buff , ( int ) ( c -> sock_ptr ) ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( err = SSL_get_error ( c -> ssl , ( int ) num ) ) { <S2SV_EndBug> case SSL_ERROR_NONE : if ( num == 0 ) { s_log ( LOG_DEBUG , ""SSL_write<S2SV_blank>returned<S2SV_blank>0"" ) ; break ; } memmove ( c -> sock_buff , c -> sock_buff + num , c -> sock_ptr - ( size_t ) num ) ; c -> sock_ptr -= ( size_t ) num ; memset ( c -> sock_buff + c -> sock_ptr , 0 , ( size_t ) num ) ; c -> ssl_bytes += ( size_t ) num ; watchdog = 0 ; break ; case SSL_ERROR_WANT_WRITE : s_log ( LOG_DEBUG , ""SSL_write<S2SV_blank>returned<S2SV_blank>WANT_WRITE:<S2SV_blank>retrying"" ) ; write_wants_write = 1 ; break ; case SSL_ERROR_WANT_READ : s_log ( LOG_DEBUG , ""SSL_write<S2SV_blank>returned<S2SV_blank>WANT_READ:<S2SV_blank>retrying"" ) ; write_wants_read = 1 ; break ; case SSL_ERROR_WANT_X509_LOOKUP : s_log ( LOG_DEBUG , ""SSL_write<S2SV_blank>returned<S2SV_blank>WANT_X509_LOOKUP:<S2SV_blank>retrying"" ) ; break ; <S2SV_StartBug> case SSL_ERROR_SYSCALL : <S2SV_EndBug> <S2SV_StartBug> if ( num && parse_socket_error ( c , ""SSL_write"" ) ) <S2SV_EndBug> break ; if ( c -> sock_ptr ) { s_log ( LOG_ERR , ""TLS<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(SSL_write)<S2SV_blank>with<S2SV_blank>%ld<S2SV_blank>unsent<S2SV_blank>byte(s)"" , ( long ) c -> sock_ptr ) ; throw_exception ( c , 1 ) ; } s_log ( LOG_INFO , ""TLS<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(SSL_write)"" ) ; SSL_set_shutdown ( c -> ssl , SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN ) ; break ; <S2SV_StartBug> case SSL_ERROR_ZERO_RETURN : <S2SV_EndBug> <S2SV_StartBug> s_log ( LOG_INFO , ""TLS<S2SV_blank>closed<S2SV_blank>(SSL_write)"" ) ; <S2SV_EndBug> if ( SSL_version ( c -> ssl ) == SSL2_VERSION ) SSL_set_shutdown ( c -> ssl , SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN ) ; break ; <S2SV_StartBug> case SSL_ERROR_SSL : <S2SV_EndBug> sslerror ( ""SSL_write"" ) ; throw_exception ( c , 1 ) ; default : s_log ( LOG_ERR , ""SSL_write/SSL_get_error<S2SV_blank>returned<S2SV_blank>%d"" , err ) ; throw_exception ( c , 1 ) ; } } if ( ( read_wants_read && ( ssl_can_rd || pending ) ) || ( read_wants_write && ssl_can_wr ) ) { read_wants_read = 0 ; read_wants_write = 0 ; num = SSL_read ( c -> ssl , c -> ssl_buff + c -> ssl_ptr , ( int ) ( BUFFSIZE - c -> ssl_ptr ) ) ; switch ( err = SSL_get_error ( c -> ssl , ( int ) num ) ) { case SSL_ERROR_NONE : if ( num == 0 ) { s_log ( LOG_DEBUG , ""SSL_read<S2SV_blank>returned<S2SV_blank>0"" ) ; break ; } c -> ssl_ptr += ( size_t ) num ; watchdog = 0 ; break ; case SSL_ERROR_WANT_WRITE : s_log ( LOG_DEBUG , ""SSL_read<S2SV_blank>returned<S2SV_blank>WANT_WRITE:<S2SV_blank>retrying"" ) ; read_wants_write = 1 ; break ; case SSL_ERROR_WANT_READ : # if 0 s_log ( LOG_DEBUG , ""SSL_read<S2SV_blank>returned<S2SV_blank>WANT_READ:<S2SV_blank>retrying"" ) ; # endif read_wants_read = 1 ; break ; case SSL_ERROR_WANT_X509_LOOKUP : s_log ( LOG_DEBUG , ""SSL_read<S2SV_blank>returned<S2SV_blank>WANT_X509_LOOKUP:<S2SV_blank>retrying"" ) ; break ; case SSL_ERROR_SYSCALL : if ( num && parse_socket_error ( c , ""SSL_read"" ) ) break ; if ( c -> sock_ptr || write_wants_write ) { s_log ( LOG_ERR , ""TLS<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(SSL_read)<S2SV_blank>with<S2SV_blank>%ld<S2SV_blank>unsent<S2SV_blank>byte(s)"" , ( long ) c -> sock_ptr ) ; throw_exception ( c , 1 ) ; } s_log ( LOG_INFO , ""TLS<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(SSL_read)"" ) ; SSL_set_shutdown ( c -> ssl , SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case SSL_ERROR_ZERO_RETURN : s_log ( LOG_INFO , ""TLS<S2SV_blank>closed<S2SV_blank>(SSL_read)"" ) ; if ( SSL_version ( c -> ssl ) == SSL2_VERSION ) SSL_set_shutdown ( c -> ssl , SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN ) ; break ; case SSL_ERROR_SSL : sslerror ( ""SSL_read"" ) ; throw_exception ( c , 1 ) ; default : s_log ( LOG_ERR , ""SSL_read/SSL_get_error<S2SV_blank>returned<S2SV_blank>%d"" , err ) ; throw_exception ( c , 1 ) ; } } if ( sock_open_rd && s_poll_rdhup ( c -> fds , c -> sock_rfd -> fd ) && ( ioctlsocket ( c -> sock_rfd -> fd , FIONREAD , & bytes ) || ! bytes ) ) { s_log ( LOG_INFO , ""Read<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(read<S2SV_blank>hangup)"" ) ; sock_open_rd = 0 ; } if ( sock_open_wr && s_poll_hup ( c -> fds , c -> sock_wfd -> fd ) ) { if ( c -> ssl_ptr ) { s_log ( LOG_ERR , ""Write<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(write<S2SV_blank>hangup)<S2SV_blank>with<S2SV_blank>%ld<S2SV_blank>unsent<S2SV_blank>byte(s)"" , ( long ) c -> ssl_ptr ) ; throw_exception ( c , 1 ) ; } s_log ( LOG_INFO , ""Write<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(write<S2SV_blank>hangup)"" ) ; sock_open_wr = 0 ; } if ( ! ( SSL_get_shutdown ( c -> ssl ) & SSL_RECEIVED_SHUTDOWN ) && s_poll_rdhup ( c -> fds , c -> ssl_rfd -> fd ) && ( ioctlsocket ( c -> ssl_rfd -> fd , FIONREAD , & bytes ) || ! bytes ) ) { s_log ( LOG_INFO , ""TLS<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(read<S2SV_blank>hangup)"" ) ; SSL_set_shutdown ( c -> ssl , SSL_get_shutdown ( c -> ssl ) | SSL_RECEIVED_SHUTDOWN ) ; } if ( ! ( SSL_get_shutdown ( c -> ssl ) & SSL_SENT_SHUTDOWN ) && s_poll_hup ( c -> fds , c -> ssl_wfd -> fd ) ) { if ( c -> sock_ptr || write_wants_write ) { s_log ( LOG_ERR , ""TLS<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(write<S2SV_blank>hangup)<S2SV_blank>with<S2SV_blank>%ld<S2SV_blank>unsent<S2SV_blank>byte(s)"" , ( long ) c -> sock_ptr ) ; throw_exception ( c , 1 ) ; } s_log ( LOG_INFO , ""TLS<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(write<S2SV_blank>hangup)"" ) ; SSL_set_shutdown ( c -> ssl , SSL_get_shutdown ( c -> ssl ) | SSL_SENT_SHUTDOWN ) ; } if ( sock_open_wr && SSL_get_shutdown ( c -> ssl ) & SSL_RECEIVED_SHUTDOWN && ! c -> ssl_ptr ) { sock_open_wr = 0 ; if ( ! c -> sock_wfd -> is_socket ) { s_log ( LOG_DEBUG , ""Closing<S2SV_blank>the<S2SV_blank>file<S2SV_blank>descriptor"" ) ; sock_open_rd = 0 ; } else if ( ! shutdown ( c -> sock_wfd -> fd , SHUT_WR ) ) { s_log ( LOG_DEBUG , ""Sent<S2SV_blank>socket<S2SV_blank>write<S2SV_blank>shutdown"" ) ; } else { s_log ( LOG_DEBUG , ""Failed<S2SV_blank>to<S2SV_blank>send<S2SV_blank>socket<S2SV_blank>write<S2SV_blank>shutdown"" ) ; sock_open_rd = 0 ; } } if ( ! ( SSL_get_shutdown ( c -> ssl ) & SSL_SENT_SHUTDOWN ) && ! sock_open_rd && ! c -> sock_ptr && ! write_wants_write ) { if ( SSL_version ( c -> ssl ) != SSL2_VERSION ) { s_log ( LOG_DEBUG , ""Sending<S2SV_blank>close_notify<S2SV_blank>alert"" ) ; shutdown_wants_write = 1 ; } else { s_log ( LOG_DEBUG , ""Closing<S2SV_blank>SSLv2<S2SV_blank>socket"" ) ; if ( c -> ssl_rfd -> is_socket ) shutdown ( c -> ssl_rfd -> fd , SHUT_RD ) ; if ( c -> ssl_wfd -> is_socket ) shutdown ( c -> ssl_wfd -> fd , SHUT_WR ) ; SSL_set_shutdown ( c -> ssl , SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN ) ; } } if ( ++ watchdog > 100 ) { s_log ( LOG_ERR , ""transfer()<S2SV_blank>loop<S2SV_blank>executes<S2SV_blank>not<S2SV_blank>transferring<S2SV_blank>any<S2SV_blank>data"" ) ; s_log ( LOG_ERR , ""please<S2SV_blank>report<S2SV_blank>the<S2SV_blank>problem<S2SV_blank>to<S2SV_blank>Michal.Trojnara@stunnel.org"" ) ; stunnel_info ( LOG_ERR ) ; # if OPENSSL_VERSION_NUMBER >= 0x10100000L s_log ( LOG_ERR , ""protocol=%s,<S2SV_blank>SSL_pending=%d,<S2SV_blank>SSL_has_pending=%d"" , SSL_get_version ( c -> ssl ) , SSL_pending ( c -> ssl ) , SSL_has_pending ( c -> ssl ) ) ; # else s_log ( LOG_ERR , ""protocol=%s,<S2SV_blank>SSL_pending=%d"" , SSL_get_version ( c -> ssl ) , SSL_pending ( c -> ssl ) ) ; # endif s_log ( LOG_ERR , ""sock_open_rd=%s,<S2SV_blank>sock_open_wr=%s"" , sock_open_rd ? ""Y"" : ""n"" , sock_open_wr ? ""Y"" : ""n"" ) ; s_log ( LOG_ERR , ""SSL_RECEIVED_SHUTDOWN=%s,<S2SV_blank>SSL_SENT_SHUTDOWN=%s"" , ( SSL_get_shutdown ( c -> ssl ) & SSL_RECEIVED_SHUTDOWN ) ? ""Y"" : ""n"" , ( SSL_get_shutdown ( c -> ssl ) & SSL_SENT_SHUTDOWN ) ? ""Y"" : ""n"" ) ; s_log ( LOG_ERR , ""sock_can_rd=%s,<S2SV_blank>sock_can_wr=%s"" , sock_can_rd ? ""Y"" : ""n"" , sock_can_wr ? ""Y"" : ""n"" ) ; s_log ( LOG_ERR , ""ssl_can_rd=%s,<S2SV_blank>ssl_can_wr=%s"" , ssl_can_rd ? ""Y"" : ""n"" , ssl_can_wr ? ""Y"" : ""n"" ) ; s_log ( LOG_ERR , ""read_wants_read=%s,<S2SV_blank>read_wants_write=%s"" , read_wants_read ? ""Y"" : ""n"" , read_wants_write ? ""Y"" : ""n"" ) ; s_log ( LOG_ERR , ""write_wants_read=%s,<S2SV_blank>write_wants_write=%s"" , write_wants_read ? ""Y"" : ""n"" , write_wants_write ? ""Y"" : ""n"" ) ; s_log ( LOG_ERR , ""shutdown_wants_read=%s,<S2SV_blank>shutdown_wants_write=%s"" , shutdown_wants_read ? ""Y"" : ""n"" , shutdown_wants_write ? ""Y"" : ""n"" ) ; s_log ( LOG_ERR , ""socket<S2SV_blank>input<S2SV_blank>buffer:<S2SV_blank>%ld<S2SV_blank>byte(s),<S2SV_blank>"" ""TLS<S2SV_blank>input<S2SV_blank>buffer:<S2SV_blank>%ld<S2SV_blank>byte(s)"" , ( long ) c -> sock_ptr , ( long ) c -> ssl_ptr ) ; throw_exception ( c , 1 ) ; } } while ( sock_open_wr || ! ( SSL_get_shutdown ( c -> ssl ) & SSL_SENT_SHUTDOWN ) || shutdown_wants_read || shutdown_wants_write ) ; }
","<S2SV_ModStart> watchdog = 0 <S2SV_ModEnd> ; int err <S2SV_ModStart> shutdown_wants_write ) { int <S2SV_ModStart> -> ssl , <S2SV_ModEnd> num ) ; <S2SV_ModStart> break ; case SSL_ERROR_WANT_WRITE : s_log ( LOG_DEBUG , ""SSL_shutdown<S2SV_blank>returned<S2SV_blank>WANT_WRITE:<S2SV_blank>retrying"" ) ; shutdown_wants_read = 0 ; shutdown_wants_write = 1 ; break ; case SSL_ERROR_WANT_READ : s_log ( LOG_DEBUG , ""SSL_shutdown<S2SV_blank>returned<S2SV_blank>WANT_READ:<S2SV_blank>retrying"" ) ; shutdown_wants_read = 1 ; shutdown_wants_write = 0 ; break ; case SSL_ERROR_SSL : sslerror ( ""SSL_shutdown"" ) ; throw_exception ( c , 1 ) ; case SSL_ERROR_ZERO_RETURN : <S2SV_ModEnd> SSL_set_shutdown ( c <S2SV_ModStart> break ; case SSL_ERROR_SYSCALL : if ( parse_socket_error ( c , ""SSL_shutdown"" ) ) break ; <S2SV_ModEnd> SSL_set_shutdown ( c <S2SV_ModStart> ; break ; default : s_log ( LOG_ERR , ""SSL_shutdown/SSL_get_error<S2SV_blank>returned<S2SV_blank>%d"" , err ) ; throw_exception ( c , 1 <S2SV_ModEnd> ) ; } <S2SV_ModStart> sock_can_wr ) { ssize_t <S2SV_ModStart> sock_can_rd ) { ssize_t <S2SV_ModStart> ) ) { int num = SSL_write ( c -> ssl , c -> sock_buff , ( int ) ( c -> sock_ptr ) ) ; <S2SV_ModStart> = 0 ; <S2SV_ModEnd> switch ( err <S2SV_ModStart> -> ssl , <S2SV_ModEnd> num ) ) <S2SV_ModStart> break ; case SSL_ERROR_SSL : sslerror ( ""SSL_write"" ) ; throw_exception ( c , 1 ) ; case SSL_ERROR_ZERO_RETURN : case <S2SV_ModStart> : if ( parse_socket_error ( c , ""SSL_write"" ) && num <S2SV_ModEnd> ) break ; <S2SV_ModStart> ; break ; default : s_log ( LOG_ERR , ""SSL_write/SSL_get_error<S2SV_blank>returned<S2SV_blank>%d"" , err ) ; throw_exception ( c , 1 ) ; } } if ( ( read_wants_read && ( ssl_can_rd || pending ) ) || ( read_wants_write && ssl_can_wr ) ) { int num = SSL_read ( c -> ssl , c -> ssl_buff + c -> ssl_ptr , ( int ) ( BUFFSIZE - c -> ssl_ptr ) ) ; read_wants_read = 0 ; read_wants_write = 0 ; switch ( err = SSL_get_error ( c -> ssl , num ) ) { case SSL_ERROR_NONE : if ( num == 0 ) { s_log ( LOG_DEBUG , ""SSL_read<S2SV_blank>returned<S2SV_blank>0"" ) ; break ; } c -> ssl_ptr += ( size_t ) num ; watchdog = 0 ; break ; case SSL_ERROR_WANT_WRITE : s_log ( LOG_DEBUG , ""SSL_read<S2SV_blank>returned<S2SV_blank>WANT_WRITE:<S2SV_blank>retrying"" ) ; read_wants_write = 1 ; break ; case SSL_ERROR_WANT_READ : # if 0 s_log ( LOG_DEBUG , ""SSL_read<S2SV_blank>returned<S2SV_blank>WANT_READ:<S2SV_blank>retrying"" ) ; # endif read_wants_read = 1 ; break ; case SSL_ERROR_WANT_X509_LOOKUP : s_log ( LOG_DEBUG , ""SSL_read<S2SV_blank>returned<S2SV_blank>WANT_X509_LOOKUP:<S2SV_blank>retrying"" ) ; break ; case SSL_ERROR_SSL : sslerror ( ""SSL_read"" ) ; throw_exception ( c , 1 ) ; <S2SV_ModStart> ( LOG_INFO , ""TLS<S2SV_blank>closed<S2SV_blank>(SSL_read)"" <S2SV_ModEnd> ) ; if <S2SV_ModStart> break ; case SSL_ERROR_SYSCALL : if ( parse_socket_error ( c , ""SSL_read"" ) && num <S2SV_ModEnd> ) break ; <S2SV_ModStart> ) ; break <S2SV_ModEnd> ; default :
"
1,"CWE-552 static ssize_t _epoll_writev ( oe_fd_t * desc , const struct oe_iovec * iov , int iovcnt ) { ssize_t ret = - 1 ; epoll_t * file = _cast_epoll ( desc ) ; void * buf = NULL ; size_t buf_size = 0 ; <S2SV_StartBug> if ( ! file || ( iovcnt && ! iov ) || iovcnt < 0 || iovcnt > OE_IOV_MAX ) <S2SV_EndBug> OE_RAISE_ERRNO ( OE_EINVAL ) ; <S2SV_StartBug> if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> OE_RAISE_ERRNO ( OE_ENOMEM ) ; <S2SV_EndBug> if ( oe_syscall_writev_ocall ( & ret , file -> host_fd , buf , iovcnt , buf_size ) != OE_OK ) { OE_RAISE_ERRNO ( OE_EINVAL ) ; } <S2SV_StartBug> done : <S2SV_EndBug> if ( buf ) oe_free ( buf ) ; return ret ; }
","<S2SV_ModStart> = 0 ; size_t data_size = 0 ; <S2SV_ModStart> , & buf_size , & data_size <S2SV_ModStart> OE_RAISE_ERRNO ( OE_ENOMEM ) ; if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL <S2SV_ModStart> ) ; } if ( ret > ( ssize_t ) data_size ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; }
"
2,"CWE-20 static int netbk_count_requests ( struct xenvif * vif , struct xen_netif_tx_request * first , struct xen_netif_tx_request * txp , int work_to_do ) { RING_IDX cons = vif -> tx . req_cons ; int frags = 0 ; if ( ! ( first -> flags & XEN_NETTXF_more_data ) ) return 0 ; do { if ( frags >= work_to_do ) { <S2SV_StartBug> netdev_dbg ( vif -> dev , ""Need<S2SV_blank>more<S2SV_blank>frags\\n"" ) ; <S2SV_EndBug> return - frags ; } if ( unlikely ( frags >= MAX_SKB_FRAGS ) ) { <S2SV_StartBug> netdev_dbg ( vif -> dev , ""Too<S2SV_blank>many<S2SV_blank>frags\\n"" ) ; <S2SV_EndBug> return - frags ; } memcpy ( txp , RING_GET_REQUEST ( & vif -> tx , cons + frags ) , sizeof ( * txp ) ) ; if ( txp -> size > first -> size ) { <S2SV_StartBug> netdev_dbg ( vif -> dev , ""Frags<S2SV_blank>galore\\n"" ) ; <S2SV_EndBug> return - frags ; } first -> size -= txp -> size ; frags ++ ; if ( unlikely ( ( txp -> offset + txp -> size ) > PAGE_SIZE ) ) { <S2SV_StartBug> netdev_dbg ( vif -> dev , ""txp->offset:<S2SV_blank>%x,<S2SV_blank>size:<S2SV_blank>%u\\n"" , <S2SV_EndBug> <S2SV_StartBug> txp -> offset , txp -> size ) ; <S2SV_EndBug> return - frags ; } } while ( ( txp ++ ) -> flags & XEN_NETTXF_more_data ) ; return frags ; }
","<S2SV_ModStart> work_to_do ) { netdev_err <S2SV_ModEnd> ( vif -> <S2SV_ModStart> dev , ""Need<S2SV_blank>more<S2SV_blank>frags\\n"" ) ; netbk_fatal_tx_err ( vif <S2SV_ModStart> ) ) { netdev_err <S2SV_ModEnd> ( vif -> <S2SV_ModStart> dev , ""Too<S2SV_blank>many<S2SV_blank>frags\\n"" ) ; netbk_fatal_tx_err ( vif <S2SV_ModStart> size ) { netdev_err ( vif -> dev , ""Frag<S2SV_blank>is<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>frame.\\n"" ) ; netbk_fatal_tx_err ( vif <S2SV_ModEnd> ) ; return <S2SV_ModStart> ) ) { netdev_err <S2SV_ModEnd> ( vif -> <S2SV_ModStart> txp -> size ) ; netbk_fatal_tx_err ( vif
"
3,"CWE-399 static int fst_get_iface ( struct fst_card_info * card , struct fst_port_info * port , struct ifreq * ifr ) { sync_serial_settings sync ; int i ; switch ( port -> hwif ) { case E1 : ifr -> ifr_settings . type = IF_IFACE_E1 ; break ; case T1 : ifr -> ifr_settings . type = IF_IFACE_T1 ; break ; case V35 : ifr -> ifr_settings . type = IF_IFACE_V35 ; break ; case V24 : ifr -> ifr_settings . type = IF_IFACE_V24 ; break ; case X21D : ifr -> ifr_settings . type = IF_IFACE_X21D ; break ; case X21 : default : ifr -> ifr_settings . type = IF_IFACE_X21 ; break ; } if ( ifr -> ifr_settings . size == 0 ) { return 0 ; } if ( ifr -> ifr_settings . size < sizeof ( sync ) ) { return - ENOMEM ; } i = port -> index ; <S2SV_StartBug> sync . clock_rate = FST_RDL ( card , portConfig [ i ] . lineSpeed ) ; <S2SV_EndBug> sync . clock_type = FST_RDB ( card , portConfig [ i ] . internalClock ) == INTCLK ? CLOCK_INT : CLOCK_EXT ; sync . loopback = 0 ; if ( copy_to_user ( ifr -> ifr_settings . ifs_ifsu . sync , & sync , sizeof ( sync ) ) ) { return - EFAULT ; } ifr -> ifr_settings . size = sizeof ( sync ) ; return 0 ; }
","<S2SV_ModStart> -> index ; memset ( & sync , 0 , sizeof ( sync ) ) ;
"
4,"CWE-20 void httpClientParseQopParam ( const HttpParam * param , HttpWwwAuthenticateHeader * authHeader ) { # if ( HTTP_CLIENT_DIGEST_AUTH_SUPPORT == ENABLED ) size_t i ; size_t n ; authHeader -> qop = HTTP_AUTH_QOP_NONE ; for ( i = 0 ; i < param -> valueLen ; i += ( n + 1 ) ) { for ( n = 0 ; ( i + n ) < param -> valueLen ; n ++ ) { <S2SV_StartBug> if ( strchr ( "",<S2SV_blank>\\t"" , param -> value [ i + n ] ) ) <S2SV_EndBug> break ; } if ( n == 4 && ! osStrncasecmp ( param -> value + i , ""auth"" , 4 ) ) { authHeader -> qop = HTTP_AUTH_QOP_AUTH ; } } if ( authHeader -> qop == HTTP_AUTH_QOP_NONE ) { authHeader -> mode = HTTP_AUTH_MODE_NONE ; } # endif }
","<S2SV_ModStart> { if ( osStrchr <S2SV_ModEnd> ( "",<S2SV_blank>\\t"" , <S2SV_ModStart> n ] ) != NULL ) { break ; } <S2SV_ModEnd> } if (
"
5,"CWE-119 static void swap_frame_buffers ( VP9Decoder * pbi ) { int ref_index = 0 , mask ; VP9_COMMON * const cm = & pbi -> common ; <S2SV_StartBug> for ( mask = pbi -> refresh_frame_flags ; mask ; mask >>= 1 ) { <S2SV_EndBug> <S2SV_StartBug> if ( mask & 1 ) { <S2SV_EndBug> const int old_idx = cm -> ref_frame_map [ ref_index ] ; <S2SV_StartBug> ref_cnt_fb ( cm -> frame_bufs , & cm -> ref_frame_map [ ref_index ] , <S2SV_EndBug> <S2SV_StartBug> cm -> new_fb_idx ) ; <S2SV_EndBug> <S2SV_StartBug> if ( old_idx >= 0 && cm -> frame_bufs [ old_idx ] . ref_count == 0 ) <S2SV_EndBug> cm -> release_fb_cb ( cm -> cb_priv , & cm -> frame_bufs [ old_idx ] . raw_frame_buffer ) ; } ++ ref_index ; } cm -> frame_to_show = get_frame_new_buffer ( cm ) ; cm -> frame_bufs [ cm -> new_fb_idx ] . ref_count -- ; for ( ref_index = 0 ; ref_index < 3 ; ref_index ++ ) <S2SV_StartBug> cm -> frame_refs [ ref_index ] . idx = INT_MAX ; <S2SV_EndBug> }
","<S2SV_ModStart> -> common ; BufferPool * const pool = cm -> buffer_pool ; RefCntBuffer * const frame_bufs = cm -> buffer_pool -> frame_bufs ; lock_buffer_pool ( pool ) ; <S2SV_ModStart> 1 ) { const int old_idx = cm -> ref_frame_map [ ref_index ] ; decrease_ref_count ( old_idx , frame_bufs , pool ) ; if ( <S2SV_ModEnd> ( mask & <S2SV_ModStart> & 1 ) && old_idx >= 0 ) { decrease_ref_count ( old_idx , frame_bufs , pool ) ; } cm -> ref_frame_map [ ref_index ] = cm -> next_ref_frame_map [ ref_index ] ; ++ ref_index ; } for ( ; ref_index < REF_FRAMES && ! cm -> show_existing_frame ; ++ ref_index ) <S2SV_ModStart> ref_index ] ; decrease_ref_count ( old_idx , frame_bufs , pool ) ; cm -> ref_frame_map [ ref_index ] = cm -> next_ref_frame_map [ ref_index ] ; } unlock_buffer_pool ( pool ) ; pbi -> hold_ref_buf = 0 ; cm -> frame_to_show = get_frame_new_buffer ( cm ) ; if ( ! pbi -> frame_parallel_decode || ! cm -> show_frame ) { lock_buffer_pool ( pool ) ; -- frame_bufs [ <S2SV_ModEnd> cm -> new_fb_idx <S2SV_ModStart> cm -> new_fb_idx <S2SV_ModEnd> ] . ref_count <S2SV_ModStart> ] . ref_count ; unlock_buffer_pool ( pool ) ; } <S2SV_ModEnd> for ( ref_index <S2SV_ModStart> . idx = - 1 <S2SV_ModEnd> ; } <S2SV_null>
"
6,"CWE-119 static void dtls1_clear_queues ( SSL * s ) { pitem * item = NULL ; hm_fragment * frag = NULL ; DTLS1_RECORD_DATA * rdata ; while ( ( item = pqueue_pop ( s -> d1 -> unprocessed_rcds . q ) ) != NULL ) { rdata = ( DTLS1_RECORD_DATA * ) item -> data ; if ( rdata -> rbuf . buf ) { OPENSSL_free ( rdata -> rbuf . buf ) ; } OPENSSL_free ( item -> data ) ; pitem_free ( item ) ; } while ( ( item = pqueue_pop ( s -> d1 -> processed_rcds . q ) ) != NULL ) { rdata = ( DTLS1_RECORD_DATA * ) item -> data ; if ( rdata -> rbuf . buf ) { OPENSSL_free ( rdata -> rbuf . buf ) ; } OPENSSL_free ( item -> data ) ; pitem_free ( item ) ; } while ( ( item = pqueue_pop ( s -> d1 -> buffered_messages ) ) != NULL ) { frag = ( hm_fragment * ) item -> data ; OPENSSL_free ( frag -> fragment ) ; OPENSSL_free ( frag ) ; pitem_free ( item ) ; } while ( ( item = pqueue_pop ( s -> d1 -> sent_messages ) ) != NULL ) { frag = ( hm_fragment * ) item -> data ; OPENSSL_free ( frag -> fragment ) ; OPENSSL_free ( frag ) ; pitem_free ( item ) ; } while ( ( item = pqueue_pop ( s -> d1 -> buffered_app_data . q ) ) != NULL ) { <S2SV_StartBug> frag = ( hm_fragment * ) item -> data ; <S2SV_EndBug> OPENSSL_free ( frag -> fragment ) ; OPENSSL_free ( frag ) ; pitem_free ( item ) ; } }
","<S2SV_ModStart> NULL ) { rdata = ( DTLS1_RECORD_DATA * ) item -> data ; if ( rdata -> rbuf . buf ) { OPENSSL_free ( rdata -> rbuf . buf ) ; } OPENSSL_free ( item -> data <S2SV_ModEnd> ) ; pitem_free
"
7,"CWE-74 int pop_open_connection ( struct PopAccountData * adata ) { char buf [ 1024 ] ; int rc = pop_connect ( adata ) ; if ( rc < 0 ) return rc ; rc = pop_capabilities ( adata , 0 ) ; if ( rc == - 1 ) goto err_conn ; if ( rc == - 2 ) return - 2 ; # ifdef USE_SSL if ( ! adata -> conn -> ssf && ( adata -> cmd_stls || C_SslForceTls ) ) { if ( C_SslForceTls ) adata -> use_stls = 2 ; if ( adata -> use_stls == 0 ) { enum QuadOption ans = query_quadoption ( C_SslStarttls , _ ( ""Secure<S2SV_blank>connection<S2SV_blank>with<S2SV_blank>TLS?"" ) ) ; if ( ans == MUTT_ABORT ) return - 2 ; adata -> use_stls = 1 ; if ( ans == MUTT_YES ) adata -> use_stls = 2 ; } if ( adata -> use_stls == 2 ) { mutt_str_strfcpy ( buf , ""STLS\\r\\n"" , sizeof ( buf ) ) ; rc = pop_query ( adata , buf , sizeof ( buf ) ) ; <S2SV_StartBug> if ( rc == - 1 ) <S2SV_EndBug> goto err_conn ; if ( rc != 0 ) { mutt_error ( ""%s"" , adata -> err_msg ) ; } else if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could<S2SV_blank>not<S2SV_blank>negotiate<S2SV_blank>TLS<S2SV_blank>connection"" ) ) ; return - 2 ; } else { rc = pop_capabilities ( adata , 1 ) ; if ( rc == - 1 ) goto err_conn ; if ( rc == - 2 ) return - 2 ; } } } if ( C_SslForceTls && ! adata -> conn -> ssf ) { mutt_error ( _ ( ""Encrypted<S2SV_blank>connection<S2SV_blank>unavailable"" ) ) ; return - 2 ; } # endif rc = pop_authenticate ( adata ) ; if ( rc == - 1 ) goto err_conn ; if ( rc == - 3 ) mutt_clear_error ( ) ; if ( rc != 0 ) return rc ; rc = pop_capabilities ( adata , 2 ) ; if ( rc == - 1 ) goto err_conn ; if ( rc == - 2 ) return - 2 ; mutt_str_strfcpy ( buf , ""STAT\\r\\n"" , sizeof ( buf ) ) ; rc = pop_query ( adata , buf , sizeof ( buf ) ) ; if ( rc == - 1 ) goto err_conn ; if ( rc == - 2 ) { mutt_error ( ""%s"" , adata -> err_msg ) ; return rc ; } unsigned int n = 0 , size = 0 ; sscanf ( buf , ""+OK<S2SV_blank>%u<S2SV_blank>%u"" , & n , & size ) ; adata -> size = size ; return 0 ; err_conn : adata -> status = POP_DISCONNECTED ; mutt_error ( _ ( ""Server<S2SV_blank>closed<S2SV_blank>connection"" ) ) ; return - 1 ; }
","<S2SV_ModStart> ) ) ; mutt_socket_empty ( adata -> conn ) ;
"
8,"CWE-264 static int do_remount ( struct path * path , int flags , int mnt_flags , void * data ) { int err ; struct super_block * sb = path -> mnt -> mnt_sb ; struct mount * mnt = real_mount ( path -> mnt ) ; if ( ! check_mnt ( mnt ) ) return - EINVAL ; if ( path -> dentry != path -> mnt -> mnt_root ) return - EINVAL ; if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_READONLY ) && ! ( mnt_flags & MNT_READONLY ) ) { return - EPERM ; } <S2SV_StartBug> err = security_sb_remount ( sb , data ) ; <S2SV_EndBug> if ( err ) return err ; down_write ( & sb -> s_umount ) ; if ( flags & MS_BIND ) err = change_mount_flags ( path -> mnt , flags ) ; else if ( ! capable ( CAP_SYS_ADMIN ) ) err = - EPERM ; else err = do_remount_sb ( sb , flags , data , 0 ) ; if ( ! err ) { lock_mount_hash ( ) ; mnt_flags |= mnt -> mnt . mnt_flags & ~ MNT_USER_SETTABLE_MASK ; mnt -> mnt . mnt_flags = mnt_flags ; touch_mnt_namespace ( mnt -> mnt_ns ) ; unlock_mount_hash ( ) ; } up_write ( & sb -> s_umount ) ; return err ; }
","<S2SV_ModStart> EPERM ; } if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_NODEV ) && ! ( mnt_flags & MNT_NODEV ) ) { return - EPERM ; } if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_NOSUID ) && ! ( mnt_flags & MNT_NOSUID ) ) { return - EPERM ; } if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_NOEXEC ) && ! ( mnt_flags & MNT_NOEXEC ) ) { return - EPERM ; } if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_ATIME ) && ( ( mnt -> mnt . mnt_flags & MNT_ATIME_MASK ) != ( mnt_flags & MNT_ATIME_MASK ) ) ) { return - EPERM ; }
"
9,"CWE-20 int prepareForShutdown ( ) { redisLog ( REDIS_WARNING , ""User<S2SV_blank>requested<S2SV_blank>shutdown,<S2SV_blank>saving<S2SV_blank>DB..."" ) ; if ( server . bgsavechildpid != - 1 ) { redisLog ( REDIS_WARNING , ""There<S2SV_blank>is<S2SV_blank>a<S2SV_blank>live<S2SV_blank>saving<S2SV_blank>child.<S2SV_blank>Killing<S2SV_blank>it!"" ) ; kill ( server . bgsavechildpid , SIGKILL ) ; rdbRemoveTempFile ( server . bgsavechildpid ) ; } if ( server . appendonly ) { <S2SV_StartBug> aof_fsync ( server . appendfd ) ; <S2SV_EndBug> if ( server . vm_enabled ) unlink ( server . vm_swap_file ) ; } else if ( server . saveparamslen > 0 ) { if ( rdbSave ( server . dbfilename ) != REDIS_OK ) { redisLog ( REDIS_WARNING , ""Error<S2SV_blank>trying<S2SV_blank>to<S2SV_blank>save<S2SV_blank>the<S2SV_blank>DB,<S2SV_blank>can\'t<S2SV_blank>exit"" ) ; return REDIS_ERR ; } } else { redisLog ( REDIS_WARNING , ""Not<S2SV_blank>saving<S2SV_blank>DB."" ) ; } if ( server . daemonize ) unlink ( server . pidfile ) ; redisLog ( REDIS_WARNING , ""Server<S2SV_blank>exit<S2SV_blank>now,<S2SV_blank>bye<S2SV_blank>bye..."" ) ; return REDIS_OK ; }
","<S2SV_ModStart> server . appendfd <S2SV_ModEnd> ) ; }
"
10,"CWE-190 jas_matrix_t * jas_seq2d_input ( FILE * in ) { jas_matrix_t * matrix ; <S2SV_StartBug> int i ; <S2SV_EndBug> int j ; long x ; <S2SV_StartBug> int numrows ; <S2SV_EndBug> int numcols ; int xoff ; int yoff ; <S2SV_StartBug> if ( fscanf ( in , ""%d<S2SV_blank>%d"" , & xoff , & yoff ) != 2 ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( fscanf ( in , ""%d<S2SV_blank>%d"" , & numcols , & numrows ) != 2 ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> if ( ! ( matrix = jas_seq2d_create ( xoff , yoff , xoff + numcols , yoff + numrows ) ) ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> if ( jas_matrix_numrows ( matrix ) != numrows || jas_matrix_numcols ( matrix ) != numcols ) { abort ( ) ; } for ( i = 0 ; i < jas_matrix_numrows ( matrix ) ; i ++ ) { for ( j = 0 ; j < jas_matrix_numcols ( matrix ) ; j ++ ) { if ( fscanf ( in , ""%ld"" , & x ) != 1 ) { jas_matrix_destroy ( matrix ) ; return 0 ; } jas_matrix_set ( matrix , i , j , JAS_CAST ( jas_seqent_t , x ) ) ; } } return matrix ; }
","<S2SV_ModStart> * matrix ; jas_matind_t i ; jas_matind_t <S2SV_ModEnd> j ; long <S2SV_ModStart> long x ; jas_matind_t numrows ; jas_matind_t numcols ; jas_matind_t xoff ; jas_matind_t yoff ; long tmp_xoff ; long tmp_yoff ; long tmp_numrows ; long tmp_numcols <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( in , ""%ld<S2SV_blank>%ld"" , & tmp_xoff , & tmp_yoff <S2SV_ModEnd> ) != 2 <S2SV_ModStart> != 2 ) { return 0 ; } xoff = tmp_xoff ; yoff = tmp_yoff <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( in , ""%ld<S2SV_blank>%ld"" , & tmp_numcols , & tmp_numrows <S2SV_ModEnd> ) != 2 <S2SV_ModStart> != 2 ) { return 0 ; } numrows = tmp_numrows ; numcols = tmp_numcols <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) ) { return 0 ; } <S2SV_ModEnd> if ( jas_matrix_numrows
"
11,"CWE-000 void ping_unhash ( struct sock * sk ) { struct inet_sock * isk = inet_sk ( sk ) ; pr_debug ( ""ping_unhash(isk=%p,isk->num=%u)\\n"" , isk , isk -> inet_num ) ; <S2SV_StartBug> if ( sk_hashed ( sk ) ) { <S2SV_EndBug> <S2SV_StartBug> write_lock_bh ( & ping_table . lock ) ; <S2SV_EndBug> hlist_nulls_del ( & sk -> sk_nulls_node ) ; sk_nulls_node_init ( & sk -> sk_nulls_node ) ; sock_put ( sk ) ; isk -> inet_num = 0 ; isk -> inet_sport = 0 ; sock_prot_inuse_add ( sock_net ( sk ) , sk -> sk_prot , - 1 ) ; <S2SV_StartBug> write_unlock_bh ( & ping_table . lock ) ; <S2SV_EndBug> } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> inet_num ) ; write_lock_bh ( & ping_table . lock ) ; <S2SV_ModStart> ) ) { <S2SV_ModEnd> hlist_nulls_del ( & <S2SV_ModStart> 1 ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
"
12,"CWE-19 int ext2_xattr_get ( struct inode * inode , int name_index , const char * name , void * buffer , size_t buffer_size ) { struct buffer_head * bh = NULL ; struct ext2_xattr_entry * entry ; size_t name_len , size ; char * end ; <S2SV_StartBug> int error ; <S2SV_EndBug> ea_idebug ( inode , ""name=%d.%s,<S2SV_blank>buffer=%p,<S2SV_blank>buffer_size=%ld"" , name_index , name , buffer , ( long ) buffer_size ) ; if ( name == NULL ) return - EINVAL ; name_len = strlen ( name ) ; if ( name_len > 255 ) return - ERANGE ; down_read ( & EXT2_I ( inode ) -> xattr_sem ) ; error = - ENODATA ; if ( ! EXT2_I ( inode ) -> i_file_acl ) goto cleanup ; ea_idebug ( inode , ""reading<S2SV_blank>block<S2SV_blank>%d"" , EXT2_I ( inode ) -> i_file_acl ) ; bh = sb_bread ( inode -> i_sb , EXT2_I ( inode ) -> i_file_acl ) ; error = - EIO ; if ( ! bh ) goto cleanup ; ea_bdebug ( bh , ""b_count=%d,<S2SV_blank>refcount=%d"" , atomic_read ( & ( bh -> b_count ) ) , le32_to_cpu ( HDR ( bh ) -> h_refcount ) ) ; end = bh -> b_data + bh -> b_size ; if ( HDR ( bh ) -> h_magic != cpu_to_le32 ( EXT2_XATTR_MAGIC ) || HDR ( bh ) -> h_blocks != cpu_to_le32 ( 1 ) ) { bad_block : ext2_error ( inode -> i_sb , ""ext2_xattr_get"" , ""inode<S2SV_blank>%ld:<S2SV_blank>bad<S2SV_blank>block<S2SV_blank>%d"" , inode -> i_ino , EXT2_I ( inode ) -> i_file_acl ) ; error = - EIO ; goto cleanup ; } entry = FIRST_ENTRY ( bh ) ; while ( ! IS_LAST_ENTRY ( entry ) ) { struct ext2_xattr_entry * next = EXT2_XATTR_NEXT ( entry ) ; if ( ( char * ) next >= end ) goto bad_block ; if ( name_index == entry -> e_name_index && name_len == entry -> e_name_len && memcmp ( name , entry -> e_name , name_len ) == 0 ) goto found ; entry = next ; } <S2SV_StartBug> if ( ext2_xattr_cache_insert ( bh ) ) <S2SV_EndBug> ea_idebug ( inode , ""cache<S2SV_blank>insert<S2SV_blank>failed"" ) ; error = - ENODATA ; goto cleanup ; found : if ( entry -> e_value_block != 0 ) goto bad_block ; size = le32_to_cpu ( entry -> e_value_size ) ; if ( size > inode -> i_sb -> s_blocksize || le16_to_cpu ( entry -> e_value_offs ) + size > inode -> i_sb -> s_blocksize ) goto bad_block ; <S2SV_StartBug> if ( ext2_xattr_cache_insert ( bh ) ) <S2SV_EndBug> ea_idebug ( inode , ""cache<S2SV_blank>insert<S2SV_blank>failed"" ) ; if ( buffer ) { error = - ERANGE ; if ( size > buffer_size ) goto cleanup ; memcpy ( buffer , bh -> b_data + le16_to_cpu ( entry -> e_value_offs ) , size ) ; } error = size ; cleanup : brelse ( bh ) ; up_read ( & EXT2_I ( inode ) -> xattr_sem ) ; return error ; }
","<S2SV_ModStart> ; int error ; struct mb2_cache * ext2_mb_cache = EXT2_SB ( inode -> i_sb ) -> s_mb_cache <S2SV_ModStart> ( ext2_xattr_cache_insert ( ext2_mb_cache , <S2SV_ModStart> ( ext2_xattr_cache_insert ( ext2_mb_cache ,
"
13,"CWE-787 BOOL nsc_process_message ( NSC_CONTEXT * context , UINT16 bpp , UINT32 width , UINT32 height , const BYTE * data , UINT32 length , BYTE * pDstData , UINT32 DstFormat , UINT32 nDstStride , UINT32 nXDst , UINT32 nYDst , UINT32 nWidth , UINT32 nHeight , UINT32 flip ) { wStream * s ; BOOL ret ; s = Stream_New ( ( BYTE * ) data , length ) ; if ( ! s ) return FALSE ; if ( nDstStride == 0 ) nDstStride = nWidth * GetBytesPerPixel ( DstFormat ) ; switch ( bpp ) { case 32 : context -> format = PIXEL_FORMAT_BGRA32 ; break ; case 24 : context -> format = PIXEL_FORMAT_BGR24 ; break ; case 16 : context -> format = PIXEL_FORMAT_BGR16 ; break ; case 8 : context -> format = PIXEL_FORMAT_RGB8 ; break ; case 4 : context -> format = PIXEL_FORMAT_A4 ; break ; default : Stream_Free ( s , TRUE ) ; return FALSE ; } context -> width = width ; context -> height = height ; ret = nsc_context_initialize ( context , s ) ; Stream_Free ( s , FALSE ) ; if ( ! ret ) return FALSE ; <S2SV_StartBug> PROFILER_ENTER ( context -> priv -> prof_nsc_rle_decompress_data ) <S2SV_EndBug> <S2SV_StartBug> nsc_rle_decompress_data ( context ) ; <S2SV_EndBug> PROFILER_EXIT ( context -> priv -> prof_nsc_rle_decompress_data ) <S2SV_StartBug> PROFILER_ENTER ( context -> priv -> prof_nsc_decode ) <S2SV_EndBug> <S2SV_StartBug> context -> decode ( context ) ; <S2SV_EndBug> <S2SV_StartBug> PROFILER_EXIT ( context -> priv -> prof_nsc_decode ) <S2SV_EndBug> if ( ! freerdp_image_copy ( pDstData , DstFormat , nDstStride , nXDst , nYDst , width , height , context -> BitmapData , PIXEL_FORMAT_BGRA32 , 0 , 0 , 0 , NULL , flip ) ) return FALSE ; return TRUE ; }
","<S2SV_ModStart> return FALSE ; { BOOL rc ; <S2SV_ModStart> -> prof_nsc_rle_decompress_data ) rc = <S2SV_ModStart> -> prof_nsc_rle_decompress_data ) if ( ! rc ) return FALSE ; } { BOOL rc ; <S2SV_ModStart> -> prof_nsc_decode ) rc = <S2SV_ModStart> -> prof_nsc_decode ) if ( ! rc ) return FALSE ; }
"
14,"CWE-200 int x25_negotiate_facilities ( struct sk_buff * skb , struct sock * sk , struct x25_facilities * new , struct x25_dte_facilities * dte ) { struct x25_sock * x25 = x25_sk ( sk ) ; struct x25_facilities * ours = & x25 -> facilities ; struct x25_facilities theirs ; int len ; memset ( & theirs , 0 , sizeof ( theirs ) ) ; <S2SV_StartBug> memcpy ( new , ours , sizeof ( * new ) ) ; <S2SV_EndBug> len = x25_parse_facilities ( skb , & theirs , dte , & x25 -> vc_facil_mask ) ; if ( len < 0 ) return len ; if ( ( theirs . reverse & 0x01 ) && ( ours -> reverse & 0x01 ) ) { SOCK_DEBUG ( sk , ""X.25:<S2SV_blank>rejecting<S2SV_blank>reverse<S2SV_blank>charging<S2SV_blank>request\\n"" ) ; return - 1 ; } new -> reverse = theirs . reverse ; if ( theirs . throughput ) { int theirs_in = theirs . throughput & 0x0f ; int theirs_out = theirs . throughput & 0xf0 ; int ours_in = ours -> throughput & 0x0f ; int ours_out = ours -> throughput & 0xf0 ; if ( ! ours_in || theirs_in < ours_in ) { SOCK_DEBUG ( sk , ""X.25:<S2SV_blank>inbound<S2SV_blank>throughput<S2SV_blank>negotiated\\n"" ) ; new -> throughput = ( new -> throughput & 0xf0 ) | theirs_in ; } if ( ! ours_out || theirs_out < ours_out ) { SOCK_DEBUG ( sk , ""X.25:<S2SV_blank>outbound<S2SV_blank>throughput<S2SV_blank>negotiated\\n"" ) ; new -> throughput = ( new -> throughput & 0x0f ) | theirs_out ; } } if ( theirs . pacsize_in && theirs . pacsize_out ) { if ( theirs . pacsize_in < ours -> pacsize_in ) { SOCK_DEBUG ( sk , ""X.25:<S2SV_blank>packet<S2SV_blank>size<S2SV_blank>inwards<S2SV_blank>negotiated<S2SV_blank>down\\n"" ) ; new -> pacsize_in = theirs . pacsize_in ; } if ( theirs . pacsize_out < ours -> pacsize_out ) { SOCK_DEBUG ( sk , ""X.25:<S2SV_blank>packet<S2SV_blank>size<S2SV_blank>outwards<S2SV_blank>negotiated<S2SV_blank>down\\n"" ) ; new -> pacsize_out = theirs . pacsize_out ; } } if ( theirs . winsize_in && theirs . winsize_out ) { if ( theirs . winsize_in < ours -> winsize_in ) { SOCK_DEBUG ( sk , ""X.25:<S2SV_blank>window<S2SV_blank>size<S2SV_blank>inwards<S2SV_blank>negotiated<S2SV_blank>down\\n"" ) ; new -> winsize_in = theirs . winsize_in ; } if ( theirs . winsize_out < ours -> winsize_out ) { SOCK_DEBUG ( sk , ""X.25:<S2SV_blank>window<S2SV_blank>size<S2SV_blank>outwards<S2SV_blank>negotiated<S2SV_blank>down\\n"" ) ; new -> winsize_out = theirs . winsize_out ; } } return len ; }
","<S2SV_ModStart> ( * new ) ) ; memset ( dte , 0 , sizeof ( * dte
"
15,"CWE-119 static void write_profile ( BITSTREAM_PROFILE profile , <S2SV_StartBug> struct vp9_write_bit_buffer * wb ) { <S2SV_EndBug> <S2SV_StartBug> assert ( profile < MAX_PROFILES ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , profile & 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , profile >> 1 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> profile , struct vpx_write_bit_buffer <S2SV_ModEnd> * wb ) <S2SV_ModStart> wb ) { switch ( profile ) { case PROFILE_0 : vpx_wb_write_literal ( wb , 0 , 2 ) ; break ; case PROFILE_1 : vpx_wb_write_literal <S2SV_ModEnd> ( wb , <S2SV_ModStart> ( wb , 2 , 2 ) ; break ; case PROFILE_2 : vpx_wb_write_literal <S2SV_ModEnd> ( wb , <S2SV_ModStart> ( wb , 1 , 2 ) ; break ; case PROFILE_3 : vpx_wb_write_literal ( wb , 6 , 3 ) ; break ; default : assert ( 0 <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } }
"
16,"CWE-190 static s32 gf_hevc_read_sps_bs_internal ( GF_BitStream * bs , HEVCState * hevc , u8 layer_id , u32 * vui_flag_pos ) { s32 vps_id , sps_id = - 1 ; u32 i , nb_CTUs , depth ; HEVC_SPS * sps ; HEVC_VPS * vps ; HEVC_ProfileTierLevel ptl ; Bool multiLayerExtSpsFlag ; u8 sps_ext_or_max_sub_layers_minus1 , max_sub_layers_minus1 ; if ( vui_flag_pos ) * vui_flag_pos = 0 ; vps_id = gf_bs_read_int_log ( bs , 4 , ""vps_id"" ) ; <S2SV_StartBug> if ( vps_id >= 16 ) { <S2SV_EndBug> return - 1 ; } memset ( & ptl , 0 , sizeof ( ptl ) ) ; max_sub_layers_minus1 = 0 ; sps_ext_or_max_sub_layers_minus1 = 0 ; if ( layer_id == 0 ) max_sub_layers_minus1 = gf_bs_read_int_log ( bs , 3 , ""max_sub_layers_minus1"" ) ; else sps_ext_or_max_sub_layers_minus1 = gf_bs_read_int_log ( bs , 3 , ""sps_ext_or_max_sub_layers_minus1"" ) ; multiLayerExtSpsFlag = ( layer_id != 0 ) && ( sps_ext_or_max_sub_layers_minus1 == 7 ) ; if ( ! multiLayerExtSpsFlag ) { gf_bs_read_int_log ( bs , 1 , ""temporal_id_nesting_flag"" ) ; hevc_profile_tier_level ( bs , 1 , max_sub_layers_minus1 , & ptl , 0 ) ; } sps_id = gf_bs_read_ue_log ( bs , ""sps_id"" ) ; if ( ( sps_id < 0 ) || ( sps_id >= 16 ) ) { return - 1 ; } sps = & hevc -> sps [ sps_id ] ; if ( ! sps -> state ) { sps -> state = 1 ; sps -> id = sps_id ; sps -> vps_id = vps_id ; } sps -> ptl = ptl ; vps = & hevc -> vps [ vps_id ] ; sps -> max_sub_layers_minus1 = 0 ; sps -> sps_ext_or_max_sub_layers_minus1 = 0 ; sps -> colour_primaries = 2 ; sps -> transfer_characteristic = 2 ; sps -> matrix_coeffs = 2 ; if ( multiLayerExtSpsFlag ) { sps -> update_rep_format_flag = gf_bs_read_int_log ( bs , 1 , ""update_rep_format_flag"" ) ; if ( sps -> update_rep_format_flag ) { sps -> rep_format_idx = gf_bs_read_int_log ( bs , 8 , ""rep_format_idx"" ) ; } else { sps -> rep_format_idx = vps -> rep_format_idx [ layer_id ] ; } sps -> width = vps -> rep_formats [ sps -> rep_format_idx ] . pic_width_luma_samples ; sps -> height = vps -> rep_formats [ sps -> rep_format_idx ] . pic_height_luma_samples ; sps -> chroma_format_idc = vps -> rep_formats [ sps -> rep_format_idx ] . chroma_format_idc ; sps -> bit_depth_luma = vps -> rep_formats [ sps -> rep_format_idx ] . bit_depth_luma ; sps -> bit_depth_chroma = vps -> rep_formats [ sps -> rep_format_idx ] . bit_depth_chroma ; sps -> separate_colour_plane_flag = vps -> rep_formats [ sps -> rep_format_idx ] . separate_colour_plane_flag ; sps -> ptl = vps -> ext_ptl [ 0 ] ; } else { sps -> chroma_format_idc = gf_bs_read_ue_log ( bs , ""chroma_format_idc"" ) ; if ( sps -> chroma_format_idc == 3 ) sps -> separate_colour_plane_flag = gf_bs_read_int_log ( bs , 1 , ""separate_colour_plane_flag"" ) ; sps -> width = gf_bs_read_ue_log ( bs , ""width"" ) ; sps -> height = gf_bs_read_ue_log ( bs , ""height"" ) ; if ( ( sps -> cw_flag = gf_bs_read_int_log ( bs , 1 , ""conformance_window_flag"" ) ) ) { u32 SubWidthC , SubHeightC ; if ( sps -> chroma_format_idc == 1 ) { SubWidthC = SubHeightC = 2 ; } else if ( sps -> chroma_format_idc == 2 ) { SubWidthC = 2 ; SubHeightC = 1 ; } else { SubWidthC = SubHeightC = 1 ; } sps -> cw_left = gf_bs_read_ue_log ( bs , ""conformance_window_left"" ) ; sps -> cw_right = gf_bs_read_ue_log ( bs , ""conformance_window_right"" ) ; sps -> cw_top = gf_bs_read_ue_log ( bs , ""conformance_window_top"" ) ; sps -> cw_bottom = gf_bs_read_ue_log ( bs , ""conformance_window_bottom"" ) ; sps -> width -= SubWidthC * ( sps -> cw_left + sps -> cw_right ) ; sps -> height -= SubHeightC * ( sps -> cw_top + sps -> cw_bottom ) ; } sps -> bit_depth_luma = 8 + gf_bs_read_ue_log ( bs , ""bit_depth_luma_minus8"" ) ; sps -> bit_depth_chroma = 8 + gf_bs_read_ue_log ( bs , ""bit_depth_chroma_minus8"" ) ; } sps -> log2_max_pic_order_cnt_lsb = 4 + gf_bs_read_ue_log ( bs , ""log2_max_pic_order_cnt_lsb_minus4"" ) ; if ( ! multiLayerExtSpsFlag ) { sps -> sub_layer_ordering_info_present_flag = gf_bs_read_int_log ( bs , 1 , ""sub_layer_ordering_info_present_flag"" ) ; for ( i = sps -> sub_layer_ordering_info_present_flag ? 0 : sps -> max_sub_layers_minus1 ; i <= sps -> max_sub_layers_minus1 ; i ++ ) { gf_bs_read_ue_log_idx ( bs , ""max_dec_pic_buffering"" , i ) ; gf_bs_read_ue_log_idx ( bs , ""num_reorder_pics"" , i ) ; gf_bs_read_ue_log_idx ( bs , ""max_latency_increase"" , i ) ; } } sps -> log2_min_luma_coding_block_size = 3 + gf_bs_read_ue_log ( bs , ""log2_min_luma_coding_block_size_minus3"" ) ; sps -> log2_diff_max_min_luma_coding_block_size = gf_bs_read_ue_log ( bs , ""log2_diff_max_min_luma_coding_block_size"" ) ; sps -> max_CU_width = ( 1 << ( sps -> log2_min_luma_coding_block_size + sps -> log2_diff_max_min_luma_coding_block_size ) ) ; sps -> max_CU_height = ( 1 << ( sps -> log2_min_luma_coding_block_size + sps -> log2_diff_max_min_luma_coding_block_size ) ) ; sps -> log2_min_transform_block_size = 2 + gf_bs_read_ue_log ( bs , ""log2_min_transform_block_size_minus2"" ) ; sps -> log2_max_transform_block_size = sps -> log2_min_transform_block_size + gf_bs_read_ue_log ( bs , ""log2_max_transform_block_size"" ) ; depth = 0 ; sps -> max_transform_hierarchy_depth_inter = gf_bs_read_ue_log ( bs , ""max_transform_hierarchy_depth_inter"" ) ; sps -> max_transform_hierarchy_depth_intra = gf_bs_read_ue_log ( bs , ""max_transform_hierarchy_depth_intra"" ) ; while ( ( u32 ) ( sps -> max_CU_width >> sps -> log2_diff_max_min_luma_coding_block_size ) > ( u32 ) ( 1 << ( sps -> log2_min_transform_block_size + depth ) ) ) { depth ++ ; } sps -> max_CU_depth = sps -> log2_diff_max_min_luma_coding_block_size + depth ; nb_CTUs = ( ( sps -> width + sps -> max_CU_width - 1 ) / sps -> max_CU_width ) * ( ( sps -> height + sps -> max_CU_height - 1 ) / sps -> max_CU_height ) ; sps -> bitsSliceSegmentAddress = 0 ; while ( nb_CTUs > ( u32 ) ( 1 << sps -> bitsSliceSegmentAddress ) ) { sps -> bitsSliceSegmentAddress ++ ; } sps -> scaling_list_enable_flag = gf_bs_read_int_log ( bs , 1 , ""scaling_list_enable_flag"" ) ; if ( sps -> scaling_list_enable_flag ) { sps -> infer_scaling_list_flag = 0 ; sps -> scaling_list_ref_layer_id = 0 ; if ( multiLayerExtSpsFlag ) { sps -> infer_scaling_list_flag = gf_bs_read_int_log ( bs , 1 , ""infer_scaling_list_flag"" ) ; } if ( sps -> infer_scaling_list_flag ) { sps -> scaling_list_ref_layer_id = gf_bs_read_int_log ( bs , 6 , ""scaling_list_ref_layer_id"" ) ; } else { sps -> scaling_list_data_present_flag = gf_bs_read_int_log ( bs , 1 , ""scaling_list_data_present_flag"" ) ; if ( sps -> scaling_list_data_present_flag ) { hevc_scaling_list_data ( bs ) ; } } } sps -> asymmetric_motion_partitions_enabled_flag = gf_bs_read_int_log ( bs , 1 , ""asymmetric_motion_partitions_enabled_flag"" ) ; sps -> sample_adaptive_offset_enabled_flag = gf_bs_read_int_log ( bs , 1 , ""sample_adaptive_offset_enabled_flag"" ) ; if ( ( sps -> pcm_enabled_flag = gf_bs_read_int_log ( bs , 1 , ""pcm_enabled_flag"" ) ) ) { sps -> pcm_sample_bit_depth_luma_minus1 = gf_bs_read_int_log ( bs , 4 , ""pcm_sample_bit_depth_luma_minus1"" ) ; sps -> pcm_sample_bit_depth_chroma_minus1 = gf_bs_read_int_log ( bs , 4 , ""pcm_sample_bit_depth_chroma_minus1"" ) ; sps -> log2_min_pcm_luma_coding_block_size_minus3 = gf_bs_read_ue_log ( bs , ""log2_min_pcm_luma_coding_block_size_minus3"" ) ; sps -> log2_diff_max_min_pcm_luma_coding_block_size = gf_bs_read_ue_log ( bs , ""log2_diff_max_min_pcm_luma_coding_block_size"" ) ; sps -> pcm_loop_filter_disable_flag = gf_bs_read_int_log ( bs , 1 , ""pcm_loop_filter_disable_flag"" ) ; } sps -> num_short_term_ref_pic_sets = gf_bs_read_ue_log ( bs , ""num_short_term_ref_pic_sets"" ) ; if ( sps -> num_short_term_ref_pic_sets > 64 ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CODING , ( ""[HEVC]<S2SV_blank>Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>short<S2SV_blank>term<S2SV_blank>reference<S2SV_blank>picture<S2SV_blank>sets<S2SV_blank>%d\\n"" , sps -> num_short_term_ref_pic_sets ) ) ; return - 1 ; } for ( i = 0 ; i < sps -> num_short_term_ref_pic_sets ; i ++ ) { Bool ret = hevc_parse_short_term_ref_pic_set ( bs , sps , i ) ; if ( ! ret ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CODING , ( ""[HEVC]<S2SV_blank>Invalid<S2SV_blank>short_term_ref_pic_set\\n"" ) ) ; return - 1 ; } } sps -> long_term_ref_pics_present_flag = gf_bs_read_int_log ( bs , 1 , ""long_term_ref_pics_present_flag"" ) ; if ( sps -> long_term_ref_pics_present_flag ) { sps -> num_long_term_ref_pic_sps = gf_bs_read_ue_log ( bs , ""num_long_term_ref_pic_sps"" ) ; for ( i = 0 ; i < sps -> num_long_term_ref_pic_sps ; i ++ ) { gf_bs_read_int_log_idx ( bs , sps -> log2_max_pic_order_cnt_lsb , ""lt_ref_pic_poc_lsb_sps"" , i ) ; gf_bs_read_int_log_idx ( bs , 1 , ""used_by_curr_pic_lt_sps_flag"" , i ) ; } } sps -> temporal_mvp_enable_flag = gf_bs_read_int_log ( bs , 1 , ""temporal_mvp_enable_flag"" ) ; sps -> strong_intra_smoothing_enable_flag = gf_bs_read_int_log ( bs , 1 , ""strong_intra_smoothing_enable_flag"" ) ; if ( vui_flag_pos ) * vui_flag_pos = ( u32 ) gf_bs_get_bit_offset ( bs ) ; if ( ( sps -> vui_parameters_present_flag = gf_bs_read_int_log ( bs , 1 , ""vui_parameters_present_flag"" ) ) ) { sps -> aspect_ratio_info_present_flag = gf_bs_read_int_log ( bs , 1 , ""aspect_ratio_info_present_flag"" ) ; if ( sps -> aspect_ratio_info_present_flag ) { sps -> sar_idc = gf_bs_read_int_log ( bs , 8 , ""aspect_ratio_idc"" ) ; if ( sps -> sar_idc == 255 ) { sps -> sar_width = gf_bs_read_int_log ( bs , 16 , ""aspect_ratio_width"" ) ; sps -> sar_height = gf_bs_read_int_log ( bs , 16 , ""aspect_ratio_height"" ) ; } else if ( sps -> sar_idc < 17 ) { sps -> sar_width = hevc_sar [ sps -> sar_idc ] . w ; sps -> sar_height = hevc_sar [ sps -> sar_idc ] . h ; } } if ( ( sps -> overscan_info_present = gf_bs_read_int_log ( bs , 1 , ""overscan_info_present"" ) ) ) sps -> overscan_appropriate = gf_bs_read_int_log ( bs , 1 , ""overscan_appropriate"" ) ; sps -> video_signal_type_present_flag = gf_bs_read_int_log ( bs , 1 , ""video_signal_type_present_flag"" ) ; if ( sps -> video_signal_type_present_flag ) { sps -> video_format = gf_bs_read_int_log ( bs , 3 , ""video_format"" ) ; sps -> video_full_range_flag = gf_bs_read_int_log ( bs , 1 , ""video_full_range_flag"" ) ; if ( ( sps -> colour_description_present_flag = gf_bs_read_int_log ( bs , 1 , ""colour_description_present_flag"" ) ) ) { sps -> colour_primaries = gf_bs_read_int_log ( bs , 8 , ""colour_primaries"" ) ; sps -> transfer_characteristic = gf_bs_read_int_log ( bs , 8 , ""transfer_characteristic"" ) ; sps -> matrix_coeffs = gf_bs_read_int_log ( bs , 8 , ""matrix_coefficients"" ) ; } } if ( ( sps -> chroma_loc_info_present_flag = gf_bs_read_int_log ( bs , 1 , ""chroma_loc_info_present_flag"" ) ) ) { sps -> chroma_sample_loc_type_top_field = gf_bs_read_ue_log ( bs , ""chroma_sample_loc_type_top_field"" ) ; sps -> chroma_sample_loc_type_bottom_field = gf_bs_read_ue_log ( bs , ""chroma_sample_loc_type_bottom_field"" ) ; } sps -> neutra_chroma_indication_flag = gf_bs_read_int_log ( bs , 1 , ""neutra_chroma_indication_flag"" ) ; sps -> field_seq_flag = gf_bs_read_int_log ( bs , 1 , ""field_seq_flag"" ) ; sps -> frame_field_info_present_flag = gf_bs_read_int_log ( bs , 1 , ""frame_field_info_present_flag"" ) ; if ( ( sps -> default_display_window_flag = gf_bs_read_int_log ( bs , 1 , ""default_display_window_flag"" ) ) ) { sps -> left_offset = gf_bs_read_ue_log ( bs , ""display_window_left_offset"" ) ; sps -> right_offset = gf_bs_read_ue_log ( bs , ""display_window_right_offset"" ) ; sps -> top_offset = gf_bs_read_ue_log ( bs , ""display_window_top_offset"" ) ; sps -> bottom_offset = gf_bs_read_ue_log ( bs , ""display_window_bottom_offset"" ) ; } sps -> has_timing_info = gf_bs_read_int_log ( bs , 1 , ""has_timing_info"" ) ; if ( sps -> has_timing_info ) { sps -> num_units_in_tick = gf_bs_read_int_log ( bs , 32 , ""num_units_in_tick"" ) ; sps -> time_scale = gf_bs_read_int_log ( bs , 32 , ""time_scale"" ) ; sps -> poc_proportional_to_timing_flag = gf_bs_read_int_log ( bs , 1 , ""poc_proportional_to_timing_flag"" ) ; if ( sps -> poc_proportional_to_timing_flag ) sps -> num_ticks_poc_diff_one_minus1 = gf_bs_read_ue_log ( bs , ""num_ticks_poc_diff_one_minus1"" ) ; if ( ( sps -> hrd_parameters_present_flag = gf_bs_read_int_log ( bs , 1 , ""hrd_parameters_present_flag"" ) ) ) { return sps_id ; } } if ( gf_bs_read_int_log ( bs , 1 , ""bitstream_restriction_flag"" ) ) { gf_bs_read_int_log ( bs , 1 , ""tiles_fixed_structure_flag"" ) ; gf_bs_read_int_log ( bs , 1 , ""motion_vectors_over_pic_boundaries_flag"" ) ; gf_bs_read_int_log ( bs , 1 , ""restricted_ref_pic_lists_flag"" ) ; gf_bs_read_ue_log ( bs , ""min_spatial_segmentation_idc"" ) ; gf_bs_read_ue_log ( bs , ""max_bytes_per_pic_denom"" ) ; gf_bs_read_ue_log ( bs , ""max_bits_per_min_cu_denom"" ) ; gf_bs_read_ue_log ( bs , ""log2_max_mv_length_horizontal"" ) ; gf_bs_read_ue_log ( bs , ""log2_max_mv_length_vertical"" ) ; } } if ( gf_bs_read_int_log ( bs , 1 , ""sps_extension_flag"" ) ) { # if 0 while ( gf_bs_available ( bs ) ) { gf_bs_read_int ( bs , 1 ) ; } # endif } return sps_id ; }
","<S2SV_ModStart> ; if ( ( vps_id < 0 ) || ( <S2SV_ModStart> vps_id >= 16 )
"
17,"CWE-416 CURLcode Curl_close ( struct Curl_easy * data ) { struct Curl_multi * m ; if ( ! data ) return CURLE_OK ; Curl_expire_clear ( data ) ; m = data -> multi ; if ( m ) curl_multi_remove_handle ( data -> multi , data ) ; <S2SV_StartBug> if ( data -> multi_easy ) <S2SV_EndBug> <S2SV_StartBug> curl_multi_cleanup ( data -> multi_easy ) ; <S2SV_EndBug> Curl_llist_destroy ( & data -> state . timeoutlist , NULL ) ; data -> magic = 0 ; if ( data -> state . rangestringalloc ) free ( data -> state . range ) ; Curl_free_request_state ( data ) ; Curl_ssl_close_all ( data ) ; Curl_safefree ( data -> state . first_host ) ; Curl_safefree ( data -> state . scratch ) ; Curl_ssl_free_certinfo ( data ) ; free ( data -> req . newurl ) ; data -> req . newurl = NULL ; if ( data -> change . referer_alloc ) { Curl_safefree ( data -> change . referer ) ; data -> change . referer_alloc = FALSE ; } data -> change . referer = NULL ; Curl_up_free ( data ) ; Curl_safefree ( data -> state . buffer ) ; Curl_safefree ( data -> state . headerbuff ) ; Curl_safefree ( data -> state . ulbuf ) ; Curl_flush_cookies ( data , 1 ) ; Curl_digest_cleanup ( data ) ; Curl_safefree ( data -> info . contenttype ) ; Curl_safefree ( data -> info . wouldredirect ) ; Curl_resolver_cleanup ( data -> state . resolver ) ; Curl_http2_cleanup_dependencies ( data ) ; Curl_convert_close ( data ) ; if ( data -> share ) { Curl_share_lock ( data , CURL_LOCK_DATA_SHARE , CURL_LOCK_ACCESS_SINGLE ) ; data -> share -> dirty -- ; Curl_share_unlock ( data , CURL_LOCK_DATA_SHARE ) ; } Curl_wildcard_dtor ( & data -> wildcard ) ; Curl_freeset ( data ) ; free ( data ) ; return CURLE_OK ; }
","<S2SV_ModStart> -> multi_easy ) { <S2SV_ModStart> multi_easy ) ; data -> multi_easy = NULL ; }
"
18,"CWE-119 int mlx4_register_mac ( struct mlx4_dev * dev , u8 port , u64 mac , int * index ) { struct mlx4_mac_table * table = & mlx4_priv ( dev ) -> port [ port ] . mac_table ; int i , err = 0 ; int free = - 1 ; mlx4_dbg ( dev , ""Registering<S2SV_blank>MAC:<S2SV_blank>0x%llx\\n"" , ( unsigned long long ) mac ) ; mutex_lock ( & table -> mutex ) ; for ( i = 0 ; i < MLX4_MAX_MAC_NUM - 1 ; i ++ ) { if ( free < 0 && ! table -> refs [ i ] ) { free = i ; continue ; } if ( mac == ( MLX4_MAC_MASK & be64_to_cpu ( table -> entries [ i ] ) ) ) { * index = i ; ++ table -> refs [ i ] ; goto out ; } } <S2SV_StartBug> mlx4_dbg ( dev , ""Free<S2SV_blank>MAC<S2SV_blank>index<S2SV_blank>is<S2SV_blank>%d\\n"" , free ) ; <S2SV_EndBug> if ( table -> total == table -> max ) { err = - ENOSPC ; goto out ; } table -> refs [ free ] = 1 ; table -> entries [ free ] = cpu_to_be64 ( mac | MLX4_MAC_VALID ) ; err = mlx4_set_port_mac_table ( dev , port , table -> entries ) ; if ( unlikely ( err ) ) { mlx4_err ( dev , ""Failed<S2SV_blank>adding<S2SV_blank>MAC:<S2SV_blank>0x%llx\\n"" , ( unsigned long long ) mac ) ; table -> refs [ free ] = 0 ; table -> entries [ free ] = 0 ; goto out ; } * index = free ; ++ table -> total ; out : mutex_unlock ( & table -> mutex ) ; return err ; }
","<S2SV_ModStart> ; } } if ( free < 0 ) { err = - ENOMEM ; goto out ; }
"
19,"CWE-000 <S2SV_StartBug> static void parse_input ( h2o_http2_conn_t * conn ) <S2SV_EndBug> { size_t http2_max_concurrent_requests_per_connection = conn -> super . ctx -> globalconf -> http2 . max_concurrent_requests_per_connection ; int perform_early_exit = 0 ; if ( conn -> num_streams . pull . half_closed + conn -> num_streams . push . half_closed != http2_max_concurrent_requests_per_connection ) perform_early_exit = 1 ; while ( conn -> state < H2O_HTTP2_CONN_STATE_IS_CLOSING && conn -> sock -> input -> size != 0 ) { if ( perform_early_exit == 1 && conn -> num_streams . pull . half_closed + conn -> num_streams . push . half_closed == http2_max_concurrent_requests_per_connection ) goto EarlyExit ; const char * err_desc = NULL ; ssize_t ret = conn -> _read_expect ( conn , ( uint8_t * ) conn -> sock -> input -> bytes , conn -> sock -> input -> size , & err_desc ) ; if ( ret == H2O_HTTP2_ERROR_INCOMPLETE ) { break ; } else if ( ret < 0 ) { if ( ret != H2O_HTTP2_ERROR_PROTOCOL_CLOSE_IMMEDIATELY ) { enqueue_goaway ( conn , ( int ) ret , err_desc != NULL ? ( h2o_iovec_t ) { ( char * ) err_desc , strlen ( err_desc ) } : ( h2o_iovec_t ) { } ) ; } <S2SV_StartBug> close_connection ( conn ) ; <S2SV_EndBug> return ; } h2o_buffer_consume ( & conn -> sock -> input , ret ) ; } if ( ! h2o_socket_is_reading ( conn -> sock ) ) h2o_socket_read_start ( conn -> sock , on_read ) ; <S2SV_StartBug> return ; <S2SV_EndBug> EarlyExit : if ( h2o_socket_is_reading ( conn -> sock ) ) h2o_socket_read_stop ( conn -> sock ) ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> parse_input ( h2o_http2_conn_t <S2SV_ModStart> ) ; } return <S2SV_ModStart> ( conn ) <S2SV_ModEnd> ; } h2o_buffer_consume <S2SV_ModStart> ) ; return 0 <S2SV_ModStart> sock ) ; return 0 ;
"
20,"CWE-125 static int parse_elements ( netdissect_options * ndo , struct mgmt_body_t * pbody , const u_char * p , int offset , u_int length ) { u_int elementlen ; struct ssid_t ssid ; struct challenge_t challenge ; struct rates_t rates ; struct ds_t ds ; struct cf_t cf ; struct tim_t tim ; pbody -> challenge_present = 0 ; pbody -> ssid_present = 0 ; pbody -> rates_present = 0 ; pbody -> ds_present = 0 ; pbody -> cf_present = 0 ; pbody -> tim_present = 0 ; while ( length != 0 ) { if ( ! ND_TTEST2 ( * ( p + offset ) , 2 ) ) return 0 ; if ( length < 2 ) return 0 ; elementlen = * ( p + offset + 1 ) ; if ( ! ND_TTEST2 ( * ( p + offset + 2 ) , elementlen ) ) return 0 ; if ( length < elementlen + 2 ) return 0 ; switch ( * ( p + offset ) ) { case E_SSID : memcpy ( & ssid , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( ssid . length != 0 ) { if ( ssid . length > sizeof ( ssid . ssid ) - 1 ) return 0 ; if ( ! ND_TTEST2 ( * ( p + offset ) , ssid . length ) ) return 0 ; if ( length < ssid . length ) return 0 ; memcpy ( & ssid . ssid , p + offset , ssid . length ) ; offset += ssid . length ; length -= ssid . length ; } ssid . ssid [ ssid . length ] = '\\0' ; if ( ! pbody -> ssid_present ) { pbody -> ssid = ssid ; pbody -> ssid_present = 1 ; } break ; case E_CHALLENGE : memcpy ( & challenge , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( challenge . length != 0 ) { if ( challenge . length > sizeof ( challenge . text ) - 1 ) return 0 ; if ( ! ND_TTEST2 ( * ( p + offset ) , challenge . length ) ) return 0 ; if ( length < challenge . length ) return 0 ; memcpy ( & challenge . text , p + offset , challenge . length ) ; offset += challenge . length ; length -= challenge . length ; } challenge . text [ challenge . length ] = '\\0' ; if ( ! pbody -> challenge_present ) { pbody -> challenge = challenge ; pbody -> challenge_present = 1 ; } break ; case E_RATES : memcpy ( & rates , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( rates . length != 0 ) { if ( rates . length > sizeof rates . rate ) return 0 ; if ( ! ND_TTEST2 ( * ( p + offset ) , rates . length ) ) return 0 ; if ( length < rates . length ) return 0 ; memcpy ( & rates . rate , p + offset , rates . length ) ; offset += rates . length ; length -= rates . length ; } if ( ! pbody -> rates_present && rates . length != 0 ) { pbody -> rates = rates ; pbody -> rates_present = 1 ; } break ; case E_DS : memcpy ( & ds , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( ds . length != 1 ) { offset += ds . length ; length -= ds . length ; break ; } ds . channel = * ( p + offset ) ; offset += 1 ; length -= 1 ; if ( ! pbody -> ds_present ) { pbody -> ds = ds ; pbody -> ds_present = 1 ; } break ; case E_CF : memcpy ( & cf , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( cf . length != 6 ) { offset += cf . length ; length -= cf . length ; break ; } memcpy ( & cf . count , p + offset , 6 ) ; offset += 6 ; length -= 6 ; if ( ! pbody -> cf_present ) { pbody -> cf = cf ; pbody -> cf_present = 1 ; } break ; case E_TIM : memcpy ( & tim , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( tim . length <= 3 ) { offset += tim . length ; length -= tim . length ; break ; } if ( tim . length - 3 > ( int ) sizeof tim . bitmap ) return 0 ; memcpy ( & tim . count , p + offset , 3 ) ; offset += 3 ; length -= 3 ; <S2SV_StartBug> memcpy ( tim . bitmap , p + ( tim . length - 3 ) , <S2SV_EndBug> <S2SV_StartBug> ( tim . length - 3 ) ) ; <S2SV_EndBug> offset += tim . length - 3 ; <S2SV_StartBug> length -= tim . length - 3 ; <S2SV_EndBug> if ( ! pbody -> tim_present ) { pbody -> tim = tim ; pbody -> tim_present = 1 ; } break ; default : # if 0 ND_PRINT ( ( ndo , ""(1)<S2SV_blank>unhandled<S2SV_blank>element_id<S2SV_blank>(%d)<S2SV_blank><S2SV_blank>"" , * ( p + offset ) ) ) ; # endif offset += 2 + elementlen ; length -= 2 + elementlen ; break ; } } return 1 ; }
","<S2SV_ModStart> , p + offset + 3 , <S2SV_ModEnd> tim . length <S2SV_ModStart> - 3 ) ; offset += <S2SV_ModEnd> tim . length <S2SV_ModStart> length - 3 ; length -= <S2SV_ModEnd> tim . length <S2SV_ModStart> - 3 ; <S2SV_ModEnd> if ( !
"
21,"CWE-476 static int nfc_genl_deactivate_target ( struct sk_buff * skb , struct genl_info * info ) { struct nfc_dev * dev ; u32 device_idx , target_idx ; int rc ; <S2SV_StartBug> if ( ! info -> attrs [ NFC_ATTR_DEVICE_INDEX ] ) <S2SV_EndBug> return - EINVAL ; device_idx = nla_get_u32 ( info -> attrs [ NFC_ATTR_DEVICE_INDEX ] ) ; dev = nfc_get_device ( device_idx ) ; if ( ! dev ) return - ENODEV ; target_idx = nla_get_u32 ( info -> attrs [ NFC_ATTR_TARGET_INDEX ] ) ; rc = nfc_deactivate_target ( dev , target_idx , NFC_TARGET_MODE_SLEEP ) ; nfc_put_device ( dev ) ; return rc ; }
","<S2SV_ModStart> attrs [ NFC_ATTR_DEVICE_INDEX ] || ! info -> attrs [ NFC_ATTR_TARGET_INDEX
"
22,"CWE-119 int wasm_dis ( WasmOp * op , const unsigned char * buf , int buf_len ) { op -> len = 1 ; op -> op = buf [ 0 ] ; if ( op -> op > 0xbf ) { return 1 ; } WasmOpDef * opdef = & opcodes [ op -> op ] ; switch ( op -> op ) { case WASM_OP_TRAP : case WASM_OP_NOP : case WASM_OP_ELSE : case WASM_OP_RETURN : case WASM_OP_DROP : case WASM_OP_SELECT : case WASM_OP_I32EQZ : case WASM_OP_I32EQ : case WASM_OP_I32NE : case WASM_OP_I32LTS : case WASM_OP_I32LTU : case WASM_OP_I32GTS : case WASM_OP_I32GTU : case WASM_OP_I32LES : case WASM_OP_I32LEU : case WASM_OP_I32GES : case WASM_OP_I32GEU : case WASM_OP_I64EQZ : case WASM_OP_I64EQ : case WASM_OP_I64NE : case WASM_OP_I64LTS : case WASM_OP_I64LTU : case WASM_OP_I64GTS : case WASM_OP_I64GTU : case WASM_OP_I64LES : case WASM_OP_I64LEU : case WASM_OP_I64GES : case WASM_OP_I64GEU : case WASM_OP_F32EQ : case WASM_OP_F32NE : case WASM_OP_F32LT : case WASM_OP_F32GT : case WASM_OP_F32LE : case WASM_OP_F32GE : case WASM_OP_F64EQ : case WASM_OP_F64NE : case WASM_OP_F64LT : case WASM_OP_F64GT : case WASM_OP_F64LE : case WASM_OP_F64GE : case WASM_OP_I32CLZ : case WASM_OP_I32CTZ : case WASM_OP_I32POPCNT : case WASM_OP_I32ADD : case WASM_OP_I32SUB : case WASM_OP_I32MUL : case WASM_OP_I32DIVS : case WASM_OP_I32DIVU : case WASM_OP_I32REMS : case WASM_OP_I32REMU : case WASM_OP_I32AND : case WASM_OP_I32OR : case WASM_OP_I32XOR : case WASM_OP_I32SHL : case WASM_OP_I32SHRS : case WASM_OP_I32SHRU : case WASM_OP_I32ROTL : case WASM_OP_I32ROTR : case WASM_OP_I64CLZ : case WASM_OP_I64CTZ : case WASM_OP_I64POPCNT : case WASM_OP_I64ADD : case WASM_OP_I64SUB : case WASM_OP_I64MUL : case WASM_OP_I64DIVS : case WASM_OP_I64DIVU : case WASM_OP_I64REMS : case WASM_OP_I64REMU : case WASM_OP_I64AND : case WASM_OP_I64OR : case WASM_OP_I64XOR : case WASM_OP_I64SHL : case WASM_OP_I64SHRS : case WASM_OP_I64SHRU : case WASM_OP_I64ROTL : case WASM_OP_I64ROTR : case WASM_OP_F32ABS : case WASM_OP_F32NEG : case WASM_OP_F32CEIL : case WASM_OP_F32FLOOR : case WASM_OP_F32TRUNC : case WASM_OP_F32NEAREST : case WASM_OP_F32SQRT : case WASM_OP_F32ADD : case WASM_OP_F32SUB : case WASM_OP_F32MUL : case WASM_OP_F32DIV : case WASM_OP_F32MIN : case WASM_OP_F32MAX : case WASM_OP_F32COPYSIGN : case WASM_OP_F64ABS : case WASM_OP_F64NEG : case WASM_OP_F64CEIL : case WASM_OP_F64FLOOR : case WASM_OP_F64TRUNC : case WASM_OP_F64NEAREST : case WASM_OP_F64SQRT : case WASM_OP_F64ADD : case WASM_OP_F64SUB : case WASM_OP_F64MUL : case WASM_OP_F64DIV : case WASM_OP_F64MIN : case WASM_OP_F64MAX : case WASM_OP_F64COPYSIGN : case WASM_OP_I32WRAPI64 : case WASM_OP_I32TRUNCSF32 : case WASM_OP_I32TRUNCUF32 : case WASM_OP_I32TRUNCSF64 : case WASM_OP_I32TRUNCUF64 : case WASM_OP_I64EXTENDSI32 : case WASM_OP_I64EXTENDUI32 : case WASM_OP_I64TRUNCSF32 : case WASM_OP_I64TRUNCUF32 : case WASM_OP_I64TRUNCSF64 : case WASM_OP_I64TRUNCUF64 : case WASM_OP_F32CONVERTSI32 : case WASM_OP_F32CONVERTUI32 : case WASM_OP_F32CONVERTSI64 : case WASM_OP_F32CONVERTUI64 : case WASM_OP_F32DEMOTEF64 : case WASM_OP_F64CONVERTSI32 : case WASM_OP_F64CONVERTUI32 : case WASM_OP_F64CONVERTSI64 : case WASM_OP_F64CONVERTUI64 : case WASM_OP_F64PROMOTEF32 : case WASM_OP_I32REINTERPRETF32 : case WASM_OP_I64REINTERPRETF64 : case WASM_OP_F32REINTERPRETI32 : case WASM_OP_F64REINTERPRETI64 : case WASM_OP_END : { snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s"" , opdef -> txt ) ; } break ; case WASM_OP_BLOCK : case WASM_OP_LOOP : case WASM_OP_IF : { st32 val = 0 ; size_t n = read_i32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; switch ( 0x80 - val ) { case R_BIN_WASM_VALUETYPE_EMPTY : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s"" , opdef -> txt ) ; break ; case R_BIN_WASM_VALUETYPE_i32 : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>(result<S2SV_blank>i32)"" , opdef -> txt ) ; break ; case R_BIN_WASM_VALUETYPE_i64 : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>(result<S2SV_blank>i64)"" , opdef -> txt ) ; break ; case R_BIN_WASM_VALUETYPE_f32 : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>(result<S2SV_blank>f32)"" , opdef -> txt ) ; break ; case R_BIN_WASM_VALUETYPE_f64 : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>(result<S2SV_blank>f64)"" , opdef -> txt ) ; break ; default : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>(result<S2SV_blank>?)"" , opdef -> txt ) ; break ; } op -> len += n ; } break ; case WASM_OP_BR : case WASM_OP_BRIF : case WASM_OP_CALL : { ut32 val = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%d"" , opdef -> txt , val ) ; op -> len += n ; } break ; case WASM_OP_BRTABLE : { ut32 count = 0 , * table = NULL , def = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & count ) ; if ( ! ( n > 0 && n < buf_len ) ) { goto err ; } if ( ! ( table = calloc ( count , sizeof ( ut32 ) ) ) ) { goto err ; } int i = 0 ; op -> len += n ; for ( i = 0 ; i < count ; i ++ ) { n = read_u32_leb128 ( buf + op -> len , buf + buf_len , & table [ i ] ) ; if ( ! ( op -> len + n <= buf_len ) ) { goto beach ; } op -> len += n ; } n = read_u32_leb128 ( buf + op -> len , buf + buf_len , & def ) ; if ( ! ( n > 0 && n + op -> len < buf_len ) ) { goto beach ; } op -> len += n ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%d<S2SV_blank>"" , opdef -> txt , count ) ; <S2SV_StartBug> for ( i = 0 ; i < count && strlen ( op -> txt ) + 10 < R_ASM_BUFSIZE ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> int optxtlen = strlen ( op -> txt ) ; <S2SV_EndBug> snprintf ( op -> txt + optxtlen , R_ASM_BUFSIZE - optxtlen , ""%d<S2SV_blank>"" , table [ i ] ) ; <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> snprintf ( op -> txt + strlen ( op -> txt ) , R_ASM_BUFSIZE , ""%d"" , def ) ; <S2SV_EndBug> free ( table ) ; break ; beach : free ( table ) ; goto err ; } break ; case WASM_OP_CALLINDIRECT : { ut32 val = 0 , reserved = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; op -> len += n ; n = read_u32_leb128 ( buf + op -> len , buf + buf_len , & reserved ) ; if ( ! ( n == 1 && op -> len + n <= buf_len ) ) goto err ; reserved &= 0x1 ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%d<S2SV_blank>%d"" , opdef -> txt , val , reserved ) ; op -> len += n ; } break ; case WASM_OP_GETLOCAL : case WASM_OP_SETLOCAL : case WASM_OP_TEELOCAL : case WASM_OP_GETGLOBAL : case WASM_OP_SETGLOBAL : { ut32 val = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%d"" , opdef -> txt , val ) ; op -> len += n ; } break ; case WASM_OP_I32LOAD : case WASM_OP_I64LOAD : case WASM_OP_F32LOAD : case WASM_OP_F64LOAD : case WASM_OP_I32LOAD8S : case WASM_OP_I32LOAD8U : case WASM_OP_I32LOAD16S : case WASM_OP_I32LOAD16U : case WASM_OP_I64LOAD8S : case WASM_OP_I64LOAD8U : case WASM_OP_I64LOAD16S : case WASM_OP_I64LOAD16U : case WASM_OP_I64LOAD32S : case WASM_OP_I64LOAD32U : case WASM_OP_I32STORE : case WASM_OP_I64STORE : case WASM_OP_F32STORE : case WASM_OP_F64STORE : case WASM_OP_I32STORE8 : case WASM_OP_I32STORE16 : case WASM_OP_I64STORE8 : case WASM_OP_I64STORE16 : case WASM_OP_I64STORE32 : { ut32 flag = 0 , offset = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & flag ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; op -> len += n ; n = read_u32_leb128 ( buf + op -> len , buf + buf_len , & offset ) ; if ( ! ( n > 0 && op -> len + n <= buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%d<S2SV_blank>%d"" , opdef -> txt , flag , offset ) ; op -> len += n ; } break ; case WASM_OP_CURRENTMEMORY : case WASM_OP_GROWMEMORY : { ut32 reserved = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & reserved ) ; if ( ! ( n == 1 && n < buf_len ) ) goto err ; reserved &= 0x1 ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%d"" , opdef -> txt , reserved ) ; op -> len += n ; } break ; case WASM_OP_I32CONST : { st32 val = 0 ; size_t n = read_i32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%"" PFMT32d , opdef -> txt , val ) ; op -> len += n ; } break ; case WASM_OP_I64CONST : { st64 val = 0 ; size_t n = read_i64_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%"" PFMT64d , opdef -> txt , val ) ; op -> len += n ; } break ; case WASM_OP_F32CONST : { ut32 val = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; long double d = ( long double ) val ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%"" LDBLFMT , opdef -> txt , d ) ; op -> len += n ; } break ; case WASM_OP_F64CONST : { ut64 val = 0 ; size_t n = read_u64_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; long double d = ( long double ) val ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%"" LDBLFMT , opdef -> txt , d ) ; op -> len += n ; } break ; default : goto err ; } return op -> len ; err : op -> len = 1 ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""invalid"" ) ; return op -> len ; }
","<S2SV_ModStart> count ) ; char * txt = op -> txt ; int txtLen = strlen ( op -> txt ) ; int txtLeft = R_ASM_BUFSIZE - txtLen ; txt += txtLen ; <S2SV_ModStart> < count && txtLen <S2SV_ModEnd> + 10 < <S2SV_ModStart> ++ ) { snprintf ( txt , txtLeft <S2SV_ModEnd> , ""%d<S2SV_blank>"" , <S2SV_ModStart> ] ) ; txtLen = strlen ( txt ) ; txt += txtLen ; txtLeft -= txtLen ; <S2SV_ModStart> } snprintf ( txt , txtLeft - 1 <S2SV_ModEnd> , ""%d"" ,
"
23,"CWE-59 void vrrp_print_data ( void ) { <S2SV_StartBug> FILE * file = fopen ( dump_file , ""w"" ) ; <S2SV_EndBug> if ( ! file ) { log_message ( LOG_INFO , ""Can\'t<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>(%d:<S2SV_blank>%s)"" , dump_file , errno , strerror ( errno ) ) ; return ; } dump_data_vrrp ( file ) ; fclose ( file ) ; }
","<S2SV_ModStart> * file = fopen_safe <S2SV_ModEnd> ( dump_file ,
"
24,"CWE-190 static Image * ReadTXTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char colorspace [ MaxTextExtent ] , text [ MaxTextExtent ] ; Image * image ; IndexPacket * indexes ; long x_offset , y_offset ; MagickBooleanType status ; MagickPixelPacket pixel ; QuantumAny range ; register ssize_t i , x ; register PixelPacket * q ; ssize_t count , type , y ; unsigned long depth , height , max_value , width ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( text , 0 , sizeof ( text ) ) ; ( void ) ReadBlobString ( image , text ) ; if ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) != 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { width = 0 ; height = 0 ; max_value = 0 ; * colorspace = '\\0' ; count = ( ssize_t ) sscanf ( text + 32 , ""%lu,%lu,%lu,%s"" , & width , & height , & max_value , colorspace ) ; if ( ( count != 4 ) || ( width == 0 ) || ( height == 0 ) || ( max_value == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> columns = width ; image -> rows = height ; <S2SV_StartBug> for ( depth = 1 ; ( GetQuantumRange ( depth ) + 1 ) < max_value ; depth ++ ) <S2SV_EndBug> <S2SV_StartBug> if ( depth >= 64 ) <S2SV_EndBug> break ; image -> depth = depth ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } LocaleLower ( colorspace ) ; i = ( ssize_t ) strlen ( colorspace ) - 1 ; image -> matte = MagickFalse ; if ( ( i > 0 ) && ( colorspace [ i ] == 'a' ) ) { colorspace [ i ] = '\\0' ; image -> matte = MagickTrue ; } type = ParseCommandOption ( MagickColorspaceOptions , MagickFalse , colorspace ) ; if ( type < 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> colorspace = ( ColorspaceType ) type ; ( void ) ResetMagickMemory ( & pixel , 0 , sizeof ( pixel ) ) ; ( void ) SetImageBackgroundColor ( image ) ; range = GetQuantumRange ( image -> depth ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { double blue , green , index , opacity , red ; red = 0.0 ; green = 0.0 ; blue = 0.0 ; index = 0.0 ; opacity = 0.0 ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( ReadBlobString ( image , text ) == ( char * ) NULL ) break ; switch ( image -> colorspace ) { case GRAYColorspace : { if ( image -> matte != MagickFalse ) { ( void ) sscanf ( text , ""%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & opacity ) ; green = red ; blue = red ; break ; } ( void ) sscanf ( text , ""%ld,%ld:<S2SV_blank>(%lf%*[%,]"" , & x_offset , & y_offset , & red ) ; green = red ; blue = red ; break ; } case CMYKColorspace : { if ( image -> matte != MagickFalse ) { ( void ) sscanf ( text , ""%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & green , & blue , & index , & opacity ) ; break ; } ( void ) sscanf ( text , ""%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & green , & blue , & index ) ; break ; } default : { if ( image -> matte != MagickFalse ) { ( void ) sscanf ( text , ""%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & green , & blue , & opacity ) ; break ; } ( void ) sscanf ( text , ""%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & green , & blue ) ; break ; } } if ( strchr ( text , '%' ) != ( char * ) NULL ) { red *= 0.01 * range ; green *= 0.01 * range ; blue *= 0.01 * range ; index *= 0.01 * range ; opacity *= 0.01 * range ; } if ( image -> colorspace == LabColorspace ) { green += ( range + 1 ) / 2.0 ; blue += ( range + 1 ) / 2.0 ; } pixel . red = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( red + 0.5 ) , range ) ; pixel . green = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( green + 0.5 ) , range ) ; pixel . blue = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( blue + 0.5 ) , range ) ; pixel . index = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( index + 0.5 ) , range ) ; pixel . opacity = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( opacity + 0.5 ) , range ) ; q = GetAuthenticPixels ( image , ( ssize_t ) x_offset , ( ssize_t ) y_offset , 1 , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) continue ; SetPixelRed ( q , pixel . red ) ; SetPixelGreen ( q , pixel . green ) ; SetPixelBlue ( q , pixel . blue ) ; if ( image -> colorspace == CMYKColorspace ) { indexes = GetAuthenticIndexQueue ( image ) ; SetPixelIndex ( indexes , pixel . index ) ; } if ( image -> matte != MagickFalse ) SetPixelAlpha ( q , pixel . opacity ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } } if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } ( void ) ReadBlobString ( image , text ) ; if ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) == 0 ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) == 0 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> = height ; if ( ( max_value == 0 ) || ( max_value > 4294967295 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; <S2SV_ModStart> depth ++ ) <S2SV_ModEnd> ; image ->
"
25,"CWE-000 WORD32 ih264d_video_decode ( iv_obj_t * dec_hdl , void * pv_api_ip , void * pv_api_op ) { dec_struct_t * ps_dec = ( dec_struct_t * ) ( dec_hdl -> pv_codec_handle ) ; WORD32 i4_err_status = 0 ; UWORD8 * pu1_buf = NULL ; WORD32 buflen ; UWORD32 u4_max_ofst , u4_length_of_start_code = 0 ; UWORD32 bytes_consumed = 0 ; UWORD32 cur_slice_is_nonref = 0 ; UWORD32 u4_next_is_aud ; UWORD32 u4_first_start_code_found = 0 ; WORD32 ret = 0 , api_ret_value = IV_SUCCESS ; WORD32 header_data_left = 0 , frame_data_left = 0 ; UWORD8 * pu1_bitstrm_buf ; ivd_video_decode_ip_t * ps_dec_ip ; ivd_video_decode_op_t * ps_dec_op ; ithread_set_name ( ( void * ) ""Parse_thread"" ) ; ps_dec_ip = ( ivd_video_decode_ip_t * ) pv_api_ip ; ps_dec_op = ( ivd_video_decode_op_t * ) pv_api_op ; { UWORD32 u4_size ; u4_size = ps_dec_op -> u4_size ; memset ( ps_dec_op , 0 , sizeof ( ivd_video_decode_op_t ) ) ; ps_dec_op -> u4_size = u4_size ; } ps_dec -> pv_dec_out = ps_dec_op ; ps_dec -> process_called = 1 ; if ( ps_dec -> init_done != 1 ) { return IV_FAIL ; } DATA_SYNC ( ) ; if ( 0 == ps_dec -> u1_flushfrm ) { if ( ps_dec_ip -> pv_stream_buffer == NULL ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL ; return IV_FAIL ; } if ( ps_dec_ip -> u4_num_Bytes <= 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DEC_NUMBYTES_INV ; return IV_FAIL ; } } ps_dec -> u1_pic_decode_done = 0 ; ps_dec_op -> u4_num_bytes_consumed = 0 ; ps_dec -> ps_out_buffer = NULL ; if ( ps_dec_ip -> u4_size >= offsetof ( ivd_video_decode_ip_t , s_out_buffer ) ) ps_dec -> ps_out_buffer = & ps_dec_ip -> s_out_buffer ; ps_dec -> u4_fmt_conv_cur_row = 0 ; ps_dec -> u4_output_present = 0 ; ps_dec -> s_disp_op . u4_error_code = 1 ; ps_dec -> u4_fmt_conv_num_rows = FMT_CONV_NUM_ROWS ; ps_dec -> u4_stop_threads = 0 ; if ( 0 == ps_dec -> u4_share_disp_buf && ps_dec -> i4_decode_header == 0 ) { UWORD32 i ; if ( ps_dec -> ps_out_buffer -> u4_num_bufs == 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS ; return IV_FAIL ; } for ( i = 0 ; i < ps_dec -> ps_out_buffer -> u4_num_bufs ; i ++ ) { if ( ps_dec -> ps_out_buffer -> pu1_bufs [ i ] == NULL ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL ; return IV_FAIL ; } if ( ps_dec -> ps_out_buffer -> u4_min_out_buf_size [ i ] == 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUF_SIZE ; return IV_FAIL ; } } } if ( ps_dec -> u4_total_frames_decoded >= NUM_FRAMES_LIMIT ) { ps_dec_op -> u4_error_code = ERROR_FRAME_LIMIT_OVER ; return IV_FAIL ; } ps_dec -> u4_ts = ps_dec_ip -> u4_ts ; ps_dec_op -> u4_error_code = 0 ; ps_dec_op -> e_pic_type = - 1 ; ps_dec_op -> u4_output_present = 0 ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec -> i4_frametype = - 1 ; ps_dec -> i4_content_type = - 1 ; <S2SV_StartBug> { <S2SV_EndBug> if ( ( TOP_FIELD_ONLY | BOT_FIELD_ONLY ) == ps_dec -> u1_top_bottom_decoded ) { ps_dec -> u1_top_bottom_decoded = 0 ; } } ps_dec -> u4_slice_start_code_found = 0 ; if ( ps_dec -> u1_init_dec_flag == 1 && ps_dec -> u4_share_disp_buf == 1 && ps_dec -> u1_flushfrm == 0 ) { UWORD32 i ; WORD32 disp_avail = 0 , free_id ; for ( i = 0 ; i < ps_dec -> u1_pic_bufs ; i ++ ) { if ( 0 == ps_dec -> u4_disp_buf_mapping [ i ] || 1 == ps_dec -> u4_disp_buf_to_be_freed [ i ] ) { disp_avail = 1 ; break ; } } if ( 0 == disp_avail ) { ps_dec_op -> u4_error_code = IVD_DEC_REF_BUF_NULL ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; return ( IV_FAIL ) ; } while ( 1 ) { pic_buffer_t * ps_pic_buf ; ps_pic_buf = ( pic_buffer_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , & free_id ) ; if ( ps_pic_buf == NULL ) { UWORD32 i , display_queued = 0 ; for ( i = 0 ; i < ( MAX_DISP_BUFS_NEW ) ; i ++ ) { if ( 0 != ps_dec -> u4_disp_buf_mapping [ i ] ) { display_queued = 1 ; break ; } } if ( 1 == display_queued ) { ps_dec_op -> u4_error_code = IVD_DEC_REF_BUF_NULL ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; return ( IV_FAIL ) ; } } else { if ( 1 == ps_dec -> u4_disp_buf_mapping [ free_id ] ) { ih264_buf_mgr_set_status ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , free_id , BUF_MGR_IO ) ; } else { ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , free_id , BUF_MGR_IO ) ; break ; } } } } if ( ps_dec -> u1_flushfrm && ps_dec -> u1_init_dec_flag ) { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 == ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = 0 ; ps_dec -> u4_fmt_conv_num_rows = ps_dec -> s_disp_frame_info . u4_y_ht ; ih264d_format_convert ( ps_dec , & ( ps_dec -> s_disp_op ) , ps_dec -> u4_fmt_conv_cur_row , ps_dec -> u4_fmt_conv_num_rows ) ; ps_dec -> u4_fmt_conv_cur_row += ps_dec -> u4_fmt_conv_num_rows ; ps_dec -> u4_output_present = 1 ; } ih264d_release_display_field ( ps_dec , & ( ps_dec -> s_disp_op ) ) ; ps_dec_op -> u4_pic_wd = ( UWORD32 ) ps_dec -> u2_disp_width ; ps_dec_op -> u4_pic_ht = ( UWORD32 ) ps_dec -> u2_disp_height ; ps_dec_op -> u4_new_seq = 0 ; ps_dec_op -> u4_output_present = ps_dec -> u4_output_present ; ps_dec_op -> u4_progressive_frame_flag = ps_dec -> s_disp_op . u4_progressive_frame_flag ; ps_dec_op -> e_output_format = ps_dec -> s_disp_op . e_output_format ; ps_dec_op -> s_disp_frm_buf = ps_dec -> s_disp_op . s_disp_frm_buf ; ps_dec_op -> e4_fld_type = ps_dec -> s_disp_op . e4_fld_type ; ps_dec_op -> u4_ts = ps_dec -> s_disp_op . u4_ts ; ps_dec_op -> u4_disp_buf_id = ps_dec -> s_disp_op . u4_disp_buf_id ; ps_dec_op -> u4_is_ref_flag = - 1 ; ps_dec_op -> e_pic_type = IV_NA_FRAME ; ps_dec_op -> u4_frame_decoded_flag = 0 ; if ( 0 == ps_dec -> s_disp_op . u4_error_code ) { return ( IV_SUCCESS ) ; } else return ( IV_FAIL ) ; } if ( ps_dec -> u1_res_changed == 1 ) { ih264d_init_decoder ( ps_dec ) ; } ps_dec -> u4_prev_nal_skipped = 0 ; ps_dec -> u2_cur_mb_addr = 0 ; ps_dec -> u2_total_mbs_coded = 0 ; ps_dec -> u2_cur_slice_num = 0 ; ps_dec -> cur_dec_mb_num = 0 ; ps_dec -> cur_recon_mb_num = 0 ; ps_dec -> u4_first_slice_in_pic = 2 ; ps_dec -> u1_first_pb_nal_in_pic = 1 ; ps_dec -> u1_slice_header_done = 0 ; ps_dec -> u1_dangling_field = 0 ; ps_dec -> u4_dec_thread_created = 0 ; ps_dec -> u4_bs_deblk_thread_created = 0 ; ps_dec -> u4_cur_bs_mb_num = 0 ; ps_dec -> u4_start_recon_deblk = 0 ; DEBUG_THREADS_PRINTF ( ""<S2SV_blank>Starting<S2SV_blank>process<S2SV_blank>call\\n"" ) ; ps_dec -> u4_pic_buf_got = 0 ; do { pu1_buf = ( UWORD8 * ) ps_dec_ip -> pv_stream_buffer + ps_dec_op -> u4_num_bytes_consumed ; u4_max_ofst = ps_dec_ip -> u4_num_Bytes - ps_dec_op -> u4_num_bytes_consumed ; pu1_bitstrm_buf = ps_dec -> ps_mem_tab [ MEM_REC_BITSBUF ] . pv_base ; u4_next_is_aud = 0 ; buflen = ih264d_find_start_code ( pu1_buf , 0 , u4_max_ofst , & u4_length_of_start_code , & u4_next_is_aud ) ; if ( buflen == - 1 ) buflen = 0 ; buflen = MIN ( buflen , ( WORD32 ) ( ps_dec -> ps_mem_tab [ MEM_REC_BITSBUF ] . u4_mem_size - 8 ) ) ; bytes_consumed = buflen + u4_length_of_start_code ; ps_dec_op -> u4_num_bytes_consumed += bytes_consumed ; if ( buflen >= MAX_NAL_UNIT_SIZE ) { ih264d_fill_output_struct_from_context ( ps_dec , ps_dec_op ) ; H264_DEC_DEBUG_PRINT ( ""\\nNal<S2SV_blank>Size<S2SV_blank>exceeded<S2SV_blank>%d,<S2SV_blank>Processing<S2SV_blank>Stopped..\\n"" , MAX_NAL_UNIT_SIZE ) ; ps_dec -> i4_error_code = 1 << IVD_CORRUPTEDDATA ; ps_dec_op -> e_pic_type = - 1 ; ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_pic_buf_got == 0 ) { if ( ps_dec -> i4_header_decoded == 3 ) { ps_dec -> u2_total_mbs_coded = ps_dec -> ps_cur_sps -> u2_max_mb_addr + 1 ; } if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return IV_FAIL ; } else { ps_dec -> u1_pic_decode_done = 1 ; continue ; } } { UWORD8 u1_firstbyte , u1_nal_ref_idc ; if ( ps_dec -> i4_app_skip_mode == IVD_SKIP_B ) { u1_firstbyte = * ( pu1_buf + u4_length_of_start_code ) ; u1_nal_ref_idc = ( UWORD8 ) ( NAL_REF_IDC ( u1_firstbyte ) ) ; if ( u1_nal_ref_idc == 0 ) { cur_slice_is_nonref = 1 ; continue ; } else { if ( 1 == cur_slice_is_nonref ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; ps_dec_op -> e_pic_type = IV_B_FRAME ; ps_dec_op -> u4_error_code = IVD_DEC_FRM_SKIPPED ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec_op -> u4_size = sizeof ( ivd_video_decode_op_t ) ; ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return ( IV_FAIL ) ; } } } } if ( buflen ) { memcpy ( pu1_bitstrm_buf , pu1_buf + u4_length_of_start_code , buflen ) ; u4_first_start_code_found = 1 ; } else { if ( u4_first_start_code_found == 0 ) { ps_dec -> i4_error_code = ERROR_START_CODE_NOT_FOUND ; ps_dec_op -> u4_error_code |= 1 << IVD_INSUFFICIENTDATA ; if ( ps_dec -> u4_pic_buf_got == 0 ) { ih264d_fill_output_struct_from_context ( ps_dec , ps_dec_op ) ; ps_dec_op -> u4_error_code = ps_dec -> i4_error_code ; ps_dec_op -> u4_frame_decoded_flag = 0 ; return ( IV_FAIL ) ; } else { ps_dec -> u1_pic_decode_done = 1 ; continue ; } } else { frame_data_left = 0 ; header_data_left = 0 ; continue ; } } ps_dec -> u4_return_to_app = 0 ; ret = ih264d_parse_nal_unit ( dec_hdl , ps_dec_op , pu1_bitstrm_buf , buflen ) ; if ( ret != OK ) { UWORD32 error = ih264d_map_error ( ret ) ; ps_dec_op -> u4_error_code = error | ret ; api_ret_value = IV_FAIL ; if ( ( ret == IVD_RES_CHANGED ) || ( ret == IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED ) || ( ret == ERROR_UNAVAIL_PICBUF_T ) || ( ret == ERROR_UNAVAIL_MVBUF_T ) || ( ret == ERROR_INV_SPS_PPS_T ) ) { ps_dec -> u4_slice_start_code_found = 0 ; break ; } if ( ( ret == ERROR_INCOMPLETE_FRAME ) || ( ret == ERROR_DANGLING_FIELD_IN_PIC ) ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; api_ret_value = IV_FAIL ; break ; } if ( ret == ERROR_IN_LAST_SLICE_OF_PIC ) { api_ret_value = IV_FAIL ; break ; } } if ( ps_dec -> u4_return_to_app ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; ps_dec_op -> u4_error_code = IVD_DEC_FRM_SKIPPED ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec_op -> u4_size = sizeof ( ivd_video_decode_op_t ) ; ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return ( IV_FAIL ) ; } header_data_left = ( ( ps_dec -> i4_decode_header == 1 ) && ( ps_dec -> i4_header_decoded != 3 ) && ( ps_dec_op -> u4_num_bytes_consumed < ps_dec_ip -> u4_num_Bytes ) ) ; frame_data_left = ( ( ( ps_dec -> i4_decode_header == 0 ) && ( ( ps_dec -> u1_pic_decode_done == 0 ) || ( u4_next_is_aud == 1 ) ) ) && ( ps_dec_op -> u4_num_bytes_consumed < ps_dec_ip -> u4_num_Bytes ) ) ; } while ( ( header_data_left == 1 ) || ( frame_data_left == 1 ) ) ; if ( ( ps_dec -> u4_slice_start_code_found == 1 ) && ps_dec -> u2_total_mbs_coded < ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { WORD32 num_mb_skipped ; WORD32 prev_slice_err ; pocstruct_t temp_poc ; WORD32 ret1 ; WORD32 ht_in_mbs ; ht_in_mbs = ps_dec -> u2_pic_ht >> ( 4 + ps_dec -> ps_cur_slice -> u1_field_pic_flag ) ; num_mb_skipped = ( ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; if ( ps_dec -> u4_first_slice_in_pic && ( ps_dec -> u4_pic_buf_got == 0 ) ) prev_slice_err = 1 ; else prev_slice_err = 2 ; if ( ps_dec -> u4_first_slice_in_pic && ( ps_dec -> u2_total_mbs_coded == 0 ) ) prev_slice_err = 1 ; ret1 = ih264d_mark_err_slice_skip ( ps_dec , num_mb_skipped , ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL , ps_dec -> ps_cur_slice -> u2_frame_num , & temp_poc , prev_slice_err ) ; if ( ( ret1 == ERROR_UNAVAIL_PICBUF_T ) || ( ret1 == ERROR_UNAVAIL_MVBUF_T ) || ( ret1 == ERROR_INV_SPS_PPS_T ) ) { ret = ret1 ; } } if ( ( ret == IVD_RES_CHANGED ) || ( ret == IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED ) || ( ret == ERROR_UNAVAIL_PICBUF_T ) || ( ret == ERROR_UNAVAIL_MVBUF_T ) || ( ret == ERROR_INV_SPS_PPS_T ) ) { ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } if ( ret == IVD_RES_CHANGED ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; } return IV_FAIL ; } if ( ps_dec -> u1_separate_parse ) { if ( ps_dec -> u4_num_cores == 2 ) { if ( ( ps_dec -> u4_nmb_deblk == 0 ) && ( ps_dec -> u4_start_recon_deblk == 1 ) && ( ps_dec -> ps_cur_sps -> u1_mb_aff_flag == 0 ) ) { UWORD32 u4_num_mbs , u4_max_addr ; tfr_ctxt_t s_tfr_ctxt ; tfr_ctxt_t * ps_tfr_cxt = & s_tfr_ctxt ; pad_mgr_t * ps_pad_mgr = & ps_dec -> s_pad_mgr ; u4_max_addr = ( ps_dec -> u2_frm_wd_in_mbs * ps_dec -> u2_frm_ht_in_mbs ) - 1 ; ps_dec -> u4_cur_bs_mb_num = u4_max_addr + 1 ; ih264d_init_deblk_tfr_ctxt ( ps_dec , ps_pad_mgr , ps_tfr_cxt , ps_dec -> u2_frm_wd_in_mbs , 0 ) ; u4_num_mbs = u4_max_addr - ps_dec -> u4_cur_deblk_mb_num + 1 ; DEBUG_PERF_PRINTF ( ""mbs<S2SV_blank>left<S2SV_blank>for<S2SV_blank>deblocking=<S2SV_blank>%d<S2SV_blank>\\n"" , u4_num_mbs ) ; if ( u4_num_mbs != 0 ) ih264d_check_mb_map_deblk ( ps_dec , u4_num_mbs , ps_tfr_cxt , 1 ) ; ps_dec -> u4_start_recon_deblk = 0 ; } } ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } } DATA_SYNC ( ) ; if ( ( ps_dec_op -> u4_error_code & 0xff ) != ERROR_DYNAMIC_RESOLUTION_NOT_SUPPORTED ) { ps_dec_op -> u4_pic_wd = ( UWORD32 ) ps_dec -> u2_disp_width ; ps_dec_op -> u4_pic_ht = ( UWORD32 ) ps_dec -> u2_disp_height ; } if ( ps_dec -> i4_header_decoded != 3 ) { ps_dec_op -> u4_error_code |= ( 1 << IVD_INSUFFICIENTDATA ) ; } if ( ps_dec -> i4_decode_header == 1 && ps_dec -> i4_header_decoded != 3 ) { ps_dec_op -> u4_error_code |= ( 1 << IVD_INSUFFICIENTDATA ) ; } if ( ps_dec -> u4_prev_nal_skipped ) { ps_dec_op -> u4_error_code = IVD_DEC_FRM_SKIPPED ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec_op -> u4_size = sizeof ( ivd_video_decode_op_t ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return ( IV_FAIL ) ; } if ( ( ps_dec -> u4_slice_start_code_found == 1 ) && ( ERROR_DANGLING_FIELD_IN_PIC != i4_err_status ) ) { if ( ps_dec -> ps_cur_slice -> u1_field_pic_flag ) { if ( 1 == ps_dec -> ps_cur_slice -> u1_bottom_field_flag ) { ps_dec -> u1_top_bottom_decoded |= BOT_FIELD_ONLY ; } else { ps_dec -> u1_top_bottom_decoded |= TOP_FIELD_ONLY ; } } if ( ( ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) == 0 ) && ( ps_dec -> u4_pic_buf_got == 1 ) ) { ret = ih264d_deblock_display ( ps_dec ) ; <S2SV_StartBug> if ( ret != 0 ) <S2SV_EndBug> { return IV_FAIL ; } } if ( ps_dec -> i4_header_decoded == 3 ) { ps_dec -> u2_total_mbs_coded = ps_dec -> ps_cur_sps -> u2_max_mb_addr + 1 ; } if ( ps_dec -> ps_cur_slice -> u1_nal_unit_type == IDR_SLICE_NAL ) { ps_dec -> i4_frametype = IV_IDR_FRAME ; } else if ( ps_dec -> i4_pic_type == B_SLICE ) { ps_dec -> i4_frametype = IV_B_FRAME ; } else if ( ps_dec -> i4_pic_type == P_SLICE ) { ps_dec -> i4_frametype = IV_P_FRAME ; } else if ( ps_dec -> i4_pic_type == I_SLICE ) { ps_dec -> i4_frametype = IV_I_FRAME ; } else { H264_DEC_DEBUG_PRINT ( ""Shouldn\'t<S2SV_blank>come<S2SV_blank>here\\n"" ) ; } ps_dec -> i4_content_type = ps_dec -> ps_cur_slice -> u1_field_pic_flag ; ps_dec -> u4_total_frames_decoded = ps_dec -> u4_total_frames_decoded + 2 ; ps_dec -> u4_total_frames_decoded = ps_dec -> u4_total_frames_decoded - ps_dec -> ps_cur_slice -> u1_field_pic_flag ; } if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } { if ( ( 0 == ps_dec -> u4_num_reorder_frames_at_init ) && ps_dec -> u1_init_dec_flag ) { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 == ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = 0 ; ps_dec -> u4_output_present = 1 ; } } ih264d_fill_output_struct_from_context ( ps_dec , ps_dec_op ) ; if ( ps_dec -> u4_output_present && ( ps_dec -> u4_fmt_conv_cur_row < ps_dec -> s_disp_frame_info . u4_y_ht ) ) { ps_dec -> u4_fmt_conv_num_rows = ps_dec -> s_disp_frame_info . u4_y_ht - ps_dec -> u4_fmt_conv_cur_row ; ih264d_format_convert ( ps_dec , & ( ps_dec -> s_disp_op ) , ps_dec -> u4_fmt_conv_cur_row , ps_dec -> u4_fmt_conv_num_rows ) ; ps_dec -> u4_fmt_conv_cur_row += ps_dec -> u4_fmt_conv_num_rows ; } ih264d_release_display_field ( ps_dec , & ( ps_dec -> s_disp_op ) ) ; } if ( ps_dec -> i4_decode_header == 1 && ( ps_dec -> i4_header_decoded & 1 ) == 1 ) { ps_dec_op -> u4_progressive_frame_flag = 1 ; if ( ( NULL != ps_dec -> ps_cur_sps ) && ( 1 == ( ps_dec -> ps_cur_sps -> u1_is_valid ) ) ) { if ( ( 0 == ps_dec -> ps_sps -> u1_frame_mbs_only_flag ) && ( 0 == ps_dec -> ps_sps -> u1_mb_aff_flag ) ) ps_dec_op -> u4_progressive_frame_flag = 0 ; } } <S2SV_StartBug> DATA_SYNC ( ) ; <S2SV_EndBug> H264_DEC_DEBUG_PRINT ( ""The<S2SV_blank>num<S2SV_blank>bytes<S2SV_blank>consumed:<S2SV_blank>%d\\n"" , ps_dec_op -> u4_num_bytes_consumed ) ; return api_ret_value ; }
","<S2SV_ModStart> - 1 ; <S2SV_ModEnd> ps_dec -> u4_slice_start_code_found <S2SV_ModStart> ps_dec ) ; <S2SV_ModEnd> } if ( <S2SV_ModStart> ; } } if ( ( TOP_FIELD_ONLY | BOT_FIELD_ONLY ) == ps_dec -> u1_top_bottom_decoded ) { ps_dec -> u1_top_bottom_decoded = 0 ; } if ( ps_dec -> u4_pic_buf_got == 1 ) { if ( 1 == ps_dec -> u1_last_pic_not_decoded ) { ret = ih264d_end_of_pic_dispbuf_mgr ( ps_dec ) ; if ( ret != OK ) return ret ; ret = ih264d_end_of_pic ( ps_dec ) ; if ( ret != OK ) return ret ; } else { ret = ih264d_end_of_pic ( ps_dec ) ; if ( ret != OK ) return ret ; } }
"
26,"CWE-787 static void InsertRow ( Image * image , unsigned char * p , ssize_t y , int bpp , ExceptionInfo * exception ) { int bit ; Quantum index ; register Quantum * q ; ssize_t x ; switch ( bpp ) { case 1 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { index = ( ( * p ) & ( 0x80 >> bit ) ? 0x01 : 0x00 ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( ssize_t ) ( image -> columns % 8 ) ; bit ++ ) { index = ( ( * p ) & ( 0x80 >> bit ) ? 0x01 : 0x00 ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ! SyncAuthenticPixels ( image , exception ) ) break ; break ; } case 2 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; <S2SV_StartBug> for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 4 ) <S2SV_EndBug> { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; <S2SV_StartBug> p ++ ; <S2SV_EndBug> q += GetPixelChannels ( image ) ; } if ( ( image -> columns % 4 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; <S2SV_StartBug> if ( ( image -> columns % 4 ) >= 1 ) <S2SV_EndBug> { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; <S2SV_StartBug> if ( ( image -> columns % 4 ) >= 2 ) <S2SV_EndBug> { index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; } } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; break ; } case 4 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x0f , exception ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p ) & 0x0f , exception ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } if ( ( image -> columns % 2 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x0f , exception ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; break ; } case 8 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { index = ConstrainColormapIndex ( image , * p , exception ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } break ; case 24 : q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) break ; break ; } }
","<S2SV_ModStart> -> columns - 3 <S2SV_ModEnd> ) ; x <S2SV_ModStart> q ) ; q += GetPixelChannels ( image ) ; p ++ <S2SV_ModEnd> ; } if <S2SV_ModStart> % 4 ) > <S2SV_ModEnd> 1 ) { <S2SV_ModStart> % 4 ) > <S2SV_ModEnd> 2 ) {
"
27,"CWE-119 static SCSIRequest * scsi_new_request ( SCSIDevice * d , uint32_t tag , uint32_t lun , void * hba_private ) { SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , d ) ; SCSIRequest * req ; <S2SV_StartBug> SCSIDiskReq * r ; <S2SV_EndBug> req = scsi_req_alloc ( & scsi_disk_reqops , & s -> qdev , tag , lun , hba_private ) ; <S2SV_StartBug> r = DO_UPCAST ( SCSIDiskReq , req , req ) ; <S2SV_EndBug> r -> iov . iov_base = qemu_blockalign ( s -> bs , SCSI_DMA_BUF_SIZE ) ; return req ; }
","<S2SV_ModStart> * req ; <S2SV_ModEnd> req = scsi_req_alloc <S2SV_ModStart> hba_private ) ; <S2SV_ModEnd> return req ;
"
28,"CWE-399 void __scm_destroy ( struct scm_cookie * scm ) { struct scm_fp_list * fpl = scm -> fp ; int i ; if ( fpl ) { scm -> fp = NULL ; for ( i = fpl -> count - 1 ; i >= 0 ; i -- ) fput ( fpl -> fp [ i ] ) ; <S2SV_StartBug> kfree ( fpl ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> ] ) ; free_uid ( fpl -> user ) ;
"
29,"CWE-362 static struct sock * tcp_v6_syn_recv_sock ( struct sock * sk , struct sk_buff * skb , struct request_sock * req , struct dst_entry * dst ) { struct inet6_request_sock * treq ; struct ipv6_pinfo * newnp , * np = inet6_sk ( sk ) ; struct tcp6_sock * newtcp6sk ; struct inet_sock * newinet ; struct tcp_sock * newtp ; struct sock * newsk ; struct ipv6_txoptions * opt ; # ifdef CONFIG_TCP_MD5SIG struct tcp_md5sig_key * key ; # endif if ( skb -> protocol == htons ( ETH_P_IP ) ) { newsk = tcp_v4_syn_recv_sock ( sk , skb , req , dst ) ; if ( newsk == NULL ) return NULL ; newtcp6sk = ( struct tcp6_sock * ) newsk ; inet_sk ( newsk ) -> pinet6 = & newtcp6sk -> inet6 ; newinet = inet_sk ( newsk ) ; newnp = inet6_sk ( newsk ) ; newtp = tcp_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; ipv6_addr_set_v4mapped ( newinet -> inet_daddr , & newnp -> daddr ) ; ipv6_addr_set_v4mapped ( newinet -> inet_saddr , & newnp -> saddr ) ; ipv6_addr_copy ( & newnp -> rcv_saddr , & newnp -> saddr ) ; inet_csk ( newsk ) -> icsk_af_ops = & ipv6_mapped ; newsk -> sk_backlog_rcv = tcp_v4_do_rcv ; # ifdef CONFIG_TCP_MD5SIG newtp -> af_specific = & tcp_sock_ipv6_mapped_specific ; # endif newnp -> pktoptions = NULL ; newnp -> opt = NULL ; newnp -> mcast_oif = inet6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; tcp_sync_mss ( newsk , inet_csk ( newsk ) -> icsk_pmtu_cookie ) ; return newsk ; } treq = inet6_rsk ( req ) ; opt = np -> opt ; if ( sk_acceptq_is_full ( sk ) ) goto out_overflow ; if ( ! dst ) { dst = inet6_csk_route_req ( sk , req ) ; if ( ! dst ) goto out ; } newsk = tcp_create_openreq_child ( sk , req , skb ) ; if ( newsk == NULL ) goto out_nonewsk ; newsk -> sk_gso_type = SKB_GSO_TCPV6 ; __ip6_dst_store ( newsk , dst , NULL , NULL ) ; newtcp6sk = ( struct tcp6_sock * ) newsk ; inet_sk ( newsk ) -> pinet6 = & newtcp6sk -> inet6 ; newtp = tcp_sk ( newsk ) ; newinet = inet_sk ( newsk ) ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; ipv6_addr_copy ( & newnp -> daddr , & treq -> rmt_addr ) ; ipv6_addr_copy ( & newnp -> saddr , & treq -> loc_addr ) ; ipv6_addr_copy ( & newnp -> rcv_saddr , & treq -> loc_addr ) ; newsk -> sk_bound_dev_if = treq -> iif ; <S2SV_StartBug> newinet -> opt = NULL ; <S2SV_EndBug> newnp -> ipv6_fl_list = NULL ; newnp -> rxopt . all = np -> rxopt . all ; newnp -> pktoptions = NULL ; if ( treq -> pktopts != NULL ) { newnp -> pktoptions = skb_clone ( treq -> pktopts , GFP_ATOMIC ) ; kfree_skb ( treq -> pktopts ) ; treq -> pktopts = NULL ; if ( newnp -> pktoptions ) skb_set_owner_r ( newnp -> pktoptions , newsk ) ; } newnp -> opt = NULL ; newnp -> mcast_oif = inet6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; if ( opt ) { newnp -> opt = ipv6_dup_options ( newsk , opt ) ; if ( opt != np -> opt ) sock_kfree_s ( sk , opt , opt -> tot_len ) ; } inet_csk ( newsk ) -> icsk_ext_hdr_len = 0 ; if ( newnp -> opt ) inet_csk ( newsk ) -> icsk_ext_hdr_len = ( newnp -> opt -> opt_nflen + newnp -> opt -> opt_flen ) ; tcp_mtup_init ( newsk ) ; tcp_sync_mss ( newsk , dst_mtu ( dst ) ) ; newtp -> advmss = dst_metric_advmss ( dst ) ; tcp_initialize_rcv_mss ( newsk ) ; newinet -> inet_daddr = newinet -> inet_saddr = LOOPBACK4_IPV6 ; newinet -> inet_rcv_saddr = LOOPBACK4_IPV6 ; # ifdef CONFIG_TCP_MD5SIG if ( ( key = tcp_v6_md5_do_lookup ( sk , & newnp -> daddr ) ) != NULL ) { char * newkey = kmemdup ( key -> key , key -> keylen , GFP_ATOMIC ) ; if ( newkey != NULL ) tcp_v6_md5_do_add ( newsk , & newnp -> daddr , newkey , key -> keylen ) ; } # endif if ( __inet_inherit_port ( sk , newsk ) < 0 ) { sock_put ( newsk ) ; goto out ; } __inet6_hash ( newsk , NULL ) ; return newsk ; out_overflow : NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_LISTENOVERFLOWS ) ; out_nonewsk : if ( opt && opt != np -> opt ) sock_kfree_s ( sk , opt , opt -> tot_len ) ; dst_release ( dst ) ; out : NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_LISTENDROPS ) ; return NULL ; }
","<S2SV_ModStart> ; newinet -> inet_opt <S2SV_ModEnd> = NULL ;
"
30,"CWE-388 static int vc4_get_bcl ( struct drm_device * dev , struct vc4_exec_info * exec ) { struct drm_vc4_submit_cl * args = exec -> args ; void * temp = NULL ; void * bin ; int ret = 0 ; uint32_t bin_offset = 0 ; uint32_t shader_rec_offset = roundup ( bin_offset + args -> bin_cl_size , 16 ) ; uint32_t uniforms_offset = shader_rec_offset + args -> shader_rec_size ; uint32_t exec_size = uniforms_offset + args -> uniforms_size ; uint32_t temp_size = exec_size + ( sizeof ( struct vc4_shader_state ) * args -> shader_rec_count ) ; struct vc4_bo * bo ; if ( shader_rec_offset < args -> bin_cl_size || uniforms_offset < shader_rec_offset || exec_size < uniforms_offset || args -> shader_rec_count >= ( UINT_MAX / sizeof ( struct vc4_shader_state ) ) || temp_size < exec_size ) { DRM_ERROR ( ""overflow<S2SV_blank>in<S2SV_blank>exec<S2SV_blank>arguments\\n"" ) ; <S2SV_StartBug> goto fail ; <S2SV_EndBug> } temp = drm_malloc_ab ( temp_size , 1 ) ; if ( ! temp ) { DRM_ERROR ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>storage<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>"" ""in<S2SV_blank>bin/render<S2SV_blank>CLs.\\n"" ) ; ret = - ENOMEM ; goto fail ; } bin = temp + bin_offset ; exec -> shader_rec_u = temp + shader_rec_offset ; exec -> uniforms_u = temp + uniforms_offset ; exec -> shader_state = temp + exec_size ; exec -> shader_state_size = args -> shader_rec_count ; if ( copy_from_user ( bin , ( void __user * ) ( uintptr_t ) args -> bin_cl , args -> bin_cl_size ) ) { ret = - EFAULT ; goto fail ; } if ( copy_from_user ( exec -> shader_rec_u , ( void __user * ) ( uintptr_t ) args -> shader_rec , args -> shader_rec_size ) ) { ret = - EFAULT ; goto fail ; } if ( copy_from_user ( exec -> uniforms_u , ( void __user * ) ( uintptr_t ) args -> uniforms , args -> uniforms_size ) ) { ret = - EFAULT ; goto fail ; } bo = vc4_bo_create ( dev , exec_size , true ) ; if ( IS_ERR ( bo ) ) { DRM_ERROR ( ""Couldn\'t<S2SV_blank>allocate<S2SV_blank>BO<S2SV_blank>for<S2SV_blank>binning\\n"" ) ; ret = PTR_ERR ( bo ) ; goto fail ; } exec -> exec_bo = & bo -> base ; list_add_tail ( & to_vc4_bo ( & exec -> exec_bo -> base ) -> unref_head , & exec -> unref_list ) ; exec -> ct0ca = exec -> exec_bo -> paddr + bin_offset ; exec -> bin_u = bin ; exec -> shader_rec_v = exec -> exec_bo -> vaddr + shader_rec_offset ; exec -> shader_rec_p = exec -> exec_bo -> paddr + shader_rec_offset ; exec -> shader_rec_size = args -> shader_rec_size ; exec -> uniforms_v = exec -> exec_bo -> vaddr + uniforms_offset ; exec -> uniforms_p = exec -> exec_bo -> paddr + uniforms_offset ; exec -> uniforms_size = args -> uniforms_size ; ret = vc4_validate_bin_cl ( dev , exec -> exec_bo -> vaddr + bin_offset , bin , exec ) ; if ( ret ) goto fail ; ret = vc4_validate_shader_recs ( dev , exec ) ; if ( ret ) goto fail ; ret = vc4_wait_for_seqno ( dev , exec -> bin_dep_seqno , ~ 0ull , true ) ; fail : drm_free_large ( temp ) ; return ret ; }
","<S2SV_ModStart> ""overflow<S2SV_blank>in<S2SV_blank>exec<S2SV_blank>arguments\\n"" ) ; ret = - EINVAL ;
"
31,"CWE-17 int lxc_attach ( const char * name , const char * lxcpath , lxc_attach_exec_t exec_function , void * exec_payload , lxc_attach_options_t * options , pid_t * attached_process ) { int ret , status ; pid_t init_pid , pid , attached_pid , expected ; struct lxc_proc_context_info * init_ctx ; char * cwd ; char * new_cwd ; int ipc_sockets [ 2 ] ; <S2SV_StartBug> signed long personality ; <S2SV_EndBug> if ( ! options ) options = & attach_static_default_options ; init_pid = lxc_cmd_get_init_pid ( name , lxcpath ) ; if ( init_pid < 0 ) { ERROR ( ""failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>the<S2SV_blank>init<S2SV_blank>pid"" ) ; return - 1 ; } init_ctx = lxc_proc_get_context_info ( init_pid ) ; if ( ! init_ctx ) { ERROR ( ""failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>context<S2SV_blank>of<S2SV_blank>the<S2SV_blank>init<S2SV_blank>process,<S2SV_blank>pid<S2SV_blank>=<S2SV_blank>%ld"" , ( long ) init_pid ) ; return - 1 ; } personality = get_personality ( name , lxcpath ) ; if ( init_ctx -> personality < 0 ) { ERROR ( ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>personality<S2SV_blank>of<S2SV_blank>the<S2SV_blank>container"" ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } init_ctx -> personality = personality ; if ( ! fetch_seccomp ( name , lxcpath , init_ctx , options ) ) WARN ( ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>seccomp<S2SV_blank>policy"" ) ; cwd = getcwd ( NULL , 0 ) ; if ( options -> namespaces == - 1 ) { options -> namespaces = lxc_cmd_get_clone_flags ( name , lxcpath ) ; if ( options -> namespaces == - 1 ) { ERROR ( ""failed<S2SV_blank>to<S2SV_blank>automatically<S2SV_blank>determine<S2SV_blank>the<S2SV_blank>"" ""namespaces<S2SV_blank>which<S2SV_blank>the<S2SV_blank>container<S2SV_blank>unshared"" ) ; free ( cwd ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } } ret = socketpair ( PF_LOCAL , SOCK_STREAM | SOCK_CLOEXEC , 0 , ipc_sockets ) ; if ( ret < 0 ) { SYSERROR ( ""could<S2SV_blank>not<S2SV_blank>set<S2SV_blank>up<S2SV_blank>required<S2SV_blank>IPC<S2SV_blank>mechanism<S2SV_blank>for<S2SV_blank>attaching"" ) ; free ( cwd ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } pid = fork ( ) ; if ( pid < 0 ) { SYSERROR ( ""failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>first<S2SV_blank>subprocess"" ) ; free ( cwd ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } if ( pid ) { pid_t to_cleanup_pid = pid ; close ( ipc_sockets [ 1 ] ) ; free ( cwd ) ; if ( options -> attach_flags & LXC_ATTACH_MOVE_TO_CGROUP ) { if ( ! cgroup_attach ( name , lxcpath , pid ) ) goto cleanup_error ; } status = 0 ; ret = lxc_write_nointr ( ipc_sockets [ 0 ] , & status , sizeof ( status ) ) ; if ( ret <= 0 ) { ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(0)"" ) ; goto cleanup_error ; } ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & attached_pid , sizeof ( attached_pid ) , NULL ) ; if ( ret <= 0 ) { if ( ret != 0 ) ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>pid<S2SV_blank>of<S2SV_blank>attached<S2SV_blank>process"" ) ; goto cleanup_error ; } if ( options -> stdin_fd == 0 ) { signal ( SIGINT , SIG_IGN ) ; signal ( SIGQUIT , SIG_IGN ) ; } ret = wait_for_pid ( pid ) ; if ( ret < 0 ) goto cleanup_error ; to_cleanup_pid = attached_pid ; status = 0 ; ret = lxc_write_nointr ( ipc_sockets [ 0 ] , & status , sizeof ( status ) ) ; if ( ret <= 0 ) { ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(0)"" ) ; goto cleanup_error ; } expected = 1 ; ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) { if ( ret != 0 ) ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>(1)"" ) ; goto cleanup_error ; } status = 2 ; ret = lxc_write_nointr ( ipc_sockets [ 0 ] , & status , sizeof ( status ) ) ; if ( ret <= 0 ) { ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(2)"" ) ; goto cleanup_error ; } shutdown ( ipc_sockets [ 0 ] , SHUT_RDWR ) ; close ( ipc_sockets [ 0 ] ) ; lxc_proc_put_context_info ( init_ctx ) ; * attached_process = attached_pid ; return 0 ; cleanup_error : shutdown ( ipc_sockets [ 0 ] , SHUT_RDWR ) ; close ( ipc_sockets [ 0 ] ) ; if ( to_cleanup_pid ) ( void ) wait_for_pid ( to_cleanup_pid ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } close ( ipc_sockets [ 0 ] ) ; expected = 0 ; status = - 1 ; ret = lxc_read_nointr_expect ( ipc_sockets [ 1 ] , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) { ERROR ( ""error<S2SV_blank>communicating<S2SV_blank>with<S2SV_blank>child<S2SV_blank>process"" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } <S2SV_StartBug> ret = lxc_attach_to_ns ( init_pid , options -> namespaces ) ; <S2SV_EndBug> if ( ret < 0 ) { ERROR ( ""failed<S2SV_blank>to<S2SV_blank>enter<S2SV_blank>the<S2SV_blank>namespace"" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } if ( options -> initial_cwd ) new_cwd = options -> initial_cwd ; else new_cwd = cwd ; ret = chdir ( new_cwd ) ; if ( ret < 0 ) WARN ( ""could<S2SV_blank>not<S2SV_blank>change<S2SV_blank>directory<S2SV_blank>to<S2SV_blank>\'%s\'"" , new_cwd ) ; free ( cwd ) ; { struct attach_clone_payload payload = { . ipc_socket = ipc_sockets [ 1 ] , . options = options , . init_ctx = init_ctx , . exec_function = exec_function , <S2SV_StartBug> . exec_payload = exec_payload <S2SV_EndBug> } ; pid = lxc_clone ( attach_child_main , & payload , CLONE_PARENT ) ; } if ( pid <= 0 ) { SYSERROR ( ""failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>subprocess"" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } ret = lxc_write_nointr ( ipc_sockets [ 1 ] , & pid , sizeof ( pid ) ) ; if ( ret != sizeof ( pid ) ) { ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>main<S2SV_blank>process<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>of<S2SV_blank>the<S2SV_blank>attached<S2SV_blank>process"" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } rexit ( 0 ) ; }
","<S2SV_ModStart> 2 ] ; int procfd ; <S2SV_ModStart> ) ; } procfd = open ( ""/proc"" , O_DIRECTORY | O_RDONLY ) ; if ( procfd < 0 ) { SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>/proc"" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } <S2SV_ModStart> exec_payload = exec_payload , . procfd = procfd
"
32,"CWE-77 static int save_dev ( blkid_dev dev , FILE * file ) { struct list_head * p ; if ( ! dev || dev -> bid_name [ 0 ] != '/' ) return 0 ; DBG ( SAVE , ul_debug ( ""device<S2SV_blank>%s,<S2SV_blank>type<S2SV_blank>%s"" , dev -> bid_name , dev -> bid_type ? dev -> bid_type : ""(null)"" ) ) ; fprintf ( file , ""<device<S2SV_blank>DEVNO=\\""0x%04lx\\""<S2SV_blank>TIME=\\""%ld.%ld\\"""" , ( unsigned long ) dev -> bid_devno , ( long ) dev -> bid_time , ( long ) dev -> bid_utime ) ; if ( dev -> bid_pri ) fprintf ( file , ""<S2SV_blank>PRI=\\""%d\\"""" , dev -> bid_pri ) ; list_for_each ( p , & dev -> bid_tags ) { blkid_tag tag = list_entry ( p , struct blkid_struct_tag , bit_tags ) ; <S2SV_StartBug> fprintf ( file , ""<S2SV_blank>%s=\\""%s\\"""" , tag -> bit_name , tag -> bit_val ) ; <S2SV_EndBug> } fprintf ( file , "">%s</device>\\n"" , dev -> bid_name ) ; return 0 ; }
","<S2SV_ModStart> bit_tags ) ; fputc ( '<S2SV_blank>' , file ) ; fputs ( <S2SV_ModEnd> tag -> bit_name <S2SV_ModStart> -> bit_name , file ) ; fputc ( '=' , file ) ; save_quoted ( <S2SV_ModStart> tag -> bit_val , file
"
33,"CWE-125 static void parse_sec_attr_44 ( sc_file_t * file , const u8 * buf , size_t len ) { const int df_idx [ 8 ] = { SC_AC_OP_DELETE , SC_AC_OP_CREATE , SC_AC_OP_CREATE , SC_AC_OP_INVALIDATE , SC_AC_OP_REHABILITATE , SC_AC_OP_LOCK , SC_AC_OP_DELETE , - 1 } ; const int ef_idx [ 8 ] = { SC_AC_OP_READ , SC_AC_OP_UPDATE , SC_AC_OP_WRITE , SC_AC_OP_INVALIDATE , SC_AC_OP_REHABILITATE , - 1 , SC_AC_OP_ERASE , - 1 } ; const int efi_idx [ 8 ] = { SC_AC_OP_READ , SC_AC_OP_ERASE , SC_AC_OP_UPDATE , SC_AC_OP_INVALIDATE , SC_AC_OP_REHABILITATE , - 1 , SC_AC_OP_ERASE , - 1 } ; u8 bValue ; int i ; int iKeyRef = 0 ; int iMethod ; int iPinCount ; int iOffset = 0 ; int iOperation ; const int * p_idx ; while ( len > 1 ) { size_t iACLen = buf [ iOffset ] & 0x0F ; if ( iACLen > len ) break ; iMethod = SC_AC_NONE ; if ( buf [ iOffset ] & 0X80 ) { size_t iParmLen = 1 ; size_t iKeyLen = 0 ; if ( buf [ iOffset ] & 0x20 ) iKeyLen ++ ; if ( buf [ iOffset + 1 ] & 0x40 ) iParmLen ++ ; if ( buf [ iOffset + 1 ] & 0x20 ) iParmLen ++ ; if ( buf [ iOffset + 1 ] & 0x10 ) iParmLen ++ ; if ( buf [ iOffset + 1 ] & 0x08 ) iParmLen ++ ; if ( iKeyLen ) { int iSC ; if ( len < 1 + ( size_t ) iACLen ) break ; iSC = buf [ iOffset + iACLen ] ; switch ( ( iSC >> 5 ) & 0x03 ) { case 0 : iMethod = SC_AC_TERM ; break ; case 1 : iMethod = SC_AC_AUT ; break ; case 2 : case 3 : iMethod = SC_AC_PRO ; break ; } iKeyRef = iSC & 0x1F ; } if ( iACLen > ( 1 + iParmLen + iKeyLen ) ) { if ( len < 1 + 1 + 1 + ( size_t ) iParmLen ) break ; iKeyRef = buf [ iOffset + 1 + 1 + iParmLen ] ; iMethod = SC_AC_CHV ; } if ( len < 1 + 2 ) break ; switch ( buf [ iOffset + 2 ] ) { case 0x2A : iOperation = SC_AC_OP_CRYPTO ; break ; case 0x46 : iOperation = SC_AC_OP_UPDATE ; break ; default : iOperation = SC_AC_OP_SELECT ; break ; } sc_file_add_acl_entry ( file , iOperation , iMethod , iKeyRef ) ; } else { switch ( file -> type ) { case SC_FILE_TYPE_DF : p_idx = df_idx ; break ; case SC_FILE_TYPE_INTERNAL_EF : p_idx = efi_idx ; break ; default : p_idx = ef_idx ; break ; } <S2SV_StartBug> iPinCount = iACLen - 1 ; <S2SV_EndBug> if ( buf [ iOffset ] & 0x20 ) { int iSC ; if ( len < 1 + ( size_t ) iACLen ) break ; iSC = buf [ iOffset + iACLen ] ; switch ( ( iSC >> 5 ) & 0x03 ) { case 0 : iMethod = SC_AC_TERM ; break ; case 1 : iMethod = SC_AC_AUT ; break ; case 2 : case 3 : iMethod = SC_AC_PRO ; break ; } iKeyRef = iSC & 0x1F ; iPinCount -- ; } if ( iPinCount > 0 ) { if ( len < 1 + 2 ) break ; iKeyRef = buf [ iOffset + 2 ] ; iMethod = SC_AC_CHV ; } bValue = buf [ iOffset + 1 ] ; for ( i = 0 ; i < 8 ; i ++ ) { if ( ( bValue & 1 ) && ( p_idx [ i ] >= 0 ) ) sc_file_add_acl_entry ( file , p_idx [ i ] , iMethod , iKeyRef ) ; bValue >>= 1 ; } } iOffset += iACLen + 1 ; len -= iACLen + 1 ; } }
","<S2SV_ModStart> iPinCount = iACLen > 0 ? iACLen - 1 : 0 <S2SV_ModEnd> ; if (
"
34,"CWE-264 static inline unsigned long zap_pmd_range ( struct mmu_gather * tlb , struct vm_area_struct * vma , pud_t * pud , unsigned long addr , unsigned long end , struct zap_details * details ) { pmd_t * pmd ; unsigned long next ; pmd = pmd_offset ( pud , addr ) ; do { next = pmd_addr_end ( addr , end ) ; if ( pmd_trans_huge ( * pmd ) ) { if ( next - addr != HPAGE_PMD_SIZE ) { VM_BUG_ON ( ! rwsem_is_locked ( & tlb -> mm -> mmap_sem ) ) ; split_huge_page_pmd ( vma -> vm_mm , pmd ) ; } else if ( zap_huge_pmd ( tlb , vma , pmd , addr ) ) <S2SV_StartBug> continue ; <S2SV_EndBug> } <S2SV_StartBug> if ( pmd_none_or_clear_bad ( pmd ) ) <S2SV_EndBug> <S2SV_StartBug> continue ; <S2SV_EndBug> <S2SV_StartBug> next = zap_pte_range ( tlb , vma , pmd , addr , next , details ) ; <S2SV_EndBug> cond_resched ( ) ; } while ( pmd ++ , addr = next , addr != end ) ; return addr ; }
","<S2SV_ModStart> addr ) ) goto next <S2SV_ModEnd> ; } if <S2SV_ModStart> } if ( pmd_none_or_trans_huge_or_clear_bad <S2SV_ModEnd> ( pmd ) <S2SV_ModStart> pmd ) ) goto next <S2SV_ModEnd> ; next = <S2SV_ModStart> details ) ; next :
"
35,"CWE-000 static struct sock * dccp_v6_request_recv_sock ( const struct sock * sk , struct sk_buff * skb , struct request_sock * req , struct dst_entry * dst , struct request_sock * req_unhash , bool * own_req ) { struct inet_request_sock * ireq = inet_rsk ( req ) ; struct ipv6_pinfo * newnp ; const struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct ipv6_txoptions * opt ; struct inet_sock * newinet ; struct dccp6_sock * newdp6 ; struct sock * newsk ; if ( skb -> protocol == htons ( ETH_P_IP ) ) { newsk = dccp_v4_request_recv_sock ( sk , skb , req , dst , req_unhash , own_req ) ; if ( newsk == NULL ) return NULL ; newdp6 = ( struct dccp6_sock * ) newsk ; newinet = inet_sk ( newsk ) ; newinet -> pinet6 = & newdp6 -> inet6 ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; newnp -> saddr = newsk -> sk_v6_rcv_saddr ; inet_csk ( newsk ) -> icsk_af_ops = & dccp_ipv6_mapped ; newsk -> sk_backlog_rcv = dccp_v4_do_rcv ; newnp -> pktoptions = NULL ; newnp -> opt = NULL ; <S2SV_StartBug> newnp -> mcast_oif = inet6_iif ( skb ) ; <S2SV_EndBug> newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; dccp_sync_mss ( newsk , inet_csk ( newsk ) -> icsk_pmtu_cookie ) ; return newsk ; } if ( sk_acceptq_is_full ( sk ) ) goto out_overflow ; if ( ! dst ) { struct flowi6 fl6 ; dst = inet6_csk_route_req ( sk , & fl6 , req , IPPROTO_DCCP ) ; if ( ! dst ) goto out ; } newsk = dccp_create_openreq_child ( sk , req , skb ) ; if ( newsk == NULL ) goto out_nonewsk ; ip6_dst_store ( newsk , dst , NULL , NULL ) ; newsk -> sk_route_caps = dst -> dev -> features & ~ ( NETIF_F_IP_CSUM | NETIF_F_TSO ) ; newdp6 = ( struct dccp6_sock * ) newsk ; newinet = inet_sk ( newsk ) ; newinet -> pinet6 = & newdp6 -> inet6 ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; newsk -> sk_v6_daddr = ireq -> ir_v6_rmt_addr ; newnp -> saddr = ireq -> ir_v6_loc_addr ; newsk -> sk_v6_rcv_saddr = ireq -> ir_v6_loc_addr ; newsk -> sk_bound_dev_if = ireq -> ir_iif ; newinet -> inet_opt = NULL ; newnp -> rxopt . all = np -> rxopt . all ; <S2SV_StartBug> newnp -> pktoptions = NULL ; <S2SV_EndBug> newnp -> opt = NULL ; newnp -> mcast_oif = inet6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; opt = ireq -> ipv6_opt ; if ( ! opt ) opt = rcu_dereference ( np -> opt ) ; if ( opt ) { opt = ipv6_dup_options ( newsk , opt ) ; RCU_INIT_POINTER ( newnp -> opt , opt ) ; } inet_csk ( newsk ) -> icsk_ext_hdr_len = 0 ; if ( opt ) inet_csk ( newsk ) -> icsk_ext_hdr_len = opt -> opt_nflen + opt -> opt_flen ; dccp_sync_mss ( newsk , dst_mtu ( dst ) ) ; newinet -> inet_daddr = newinet -> inet_saddr = LOOPBACK4_IPV6 ; newinet -> inet_rcv_saddr = LOOPBACK4_IPV6 ; if ( __inet_inherit_port ( sk , newsk ) < 0 ) { inet_csk_prepare_forced_close ( newsk ) ; dccp_done ( newsk ) ; goto out ; } * own_req = inet_ehash_nolisten ( newsk , req_to_sk ( req_unhash ) ) ; if ( * own_req && ireq -> pktopts ) { newnp -> pktoptions = skb_clone ( ireq -> pktopts , GFP_ATOMIC ) ; consume_skb ( ireq -> pktopts ) ; ireq -> pktopts = NULL ; if ( newnp -> pktoptions ) skb_set_owner_r ( newnp -> pktoptions , newsk ) ; } return newsk ; out_overflow : __NET_INC_STATS ( sock_net ( sk ) , LINUX_MIB_LISTENOVERFLOWS ) ; out_nonewsk : dst_release ( dst ) ; out : __NET_INC_STATS ( sock_net ( sk ) , LINUX_MIB_LISTENDROPS ) ; return NULL ; }
","<S2SV_ModStart> ; newnp -> ipv6_mc_list = NULL ; newnp -> ipv6_ac_list = NULL ; newnp -> ipv6_fl_list = NULL ; newnp -> <S2SV_ModStart> ; newnp -> ipv6_mc_list = NULL ; newnp -> ipv6_ac_list = NULL ; newnp -> ipv6_fl_list = NULL ; newnp ->
"
36,"CWE-284 static int ndp_sock_recv ( struct ndp * ndp ) { struct ndp_msg * msg ; enum ndp_msg_type msg_type ; size_t len ; int err ; msg = ndp_msg_alloc ( ) ; if ( ! msg ) return - ENOMEM ; len = ndp_msg_payload_maxlen ( msg ) ; err = myrecvfrom6 ( ndp -> sock , msg -> buf , & len , 0 , <S2SV_StartBug> & msg -> addrto , & msg -> ifindex ) ; <S2SV_EndBug> if ( err ) { err ( ndp , ""Failed<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>message"" ) ; goto free_msg ; } <S2SV_StartBug> dbg ( ndp , ""rcvd<S2SV_blank>from:<S2SV_blank>%s,<S2SV_blank>ifindex:<S2SV_blank>%u"" , <S2SV_EndBug> <S2SV_StartBug> str_in6_addr ( & msg -> addrto ) , msg -> ifindex ) ; <S2SV_EndBug> if ( len < sizeof ( * msg -> icmp6_hdr ) ) { warn ( ndp , ""rcvd<S2SV_blank>icmp6<S2SV_blank>packet<S2SV_blank>too<S2SV_blank>short<S2SV_blank>(%luB)"" , len ) ; err = 0 ; goto free_msg ; } err = ndp_msg_type_by_raw_type ( & msg_type , msg -> icmp6_hdr -> icmp6_type ) ; if ( err ) { err = 0 ; goto free_msg ; } ndp_msg_init ( msg , msg_type ) ; ndp_msg_payload_len_set ( msg , len ) ; if ( ! ndp_msg_check_valid ( msg ) ) { warn ( ndp , ""rcvd<S2SV_blank>invalid<S2SV_blank>ND<S2SV_blank>message"" ) ; err = 0 ; goto free_msg ; } dbg ( ndp , ""rcvd<S2SV_blank>%s,<S2SV_blank>len:<S2SV_blank>%zuB"" , ndp_msg_type_info ( msg_type ) -> strabbr , len ) ; if ( ! ndp_msg_check_opts ( msg ) ) { err = 0 ; goto free_msg ; } err = ndp_call_handlers ( ndp , msg ) ; ; free_msg : ndp_msg_destroy ( msg ) ; return err ; }
","<S2SV_ModStart> msg -> ifindex , & msg -> hoplimit <S2SV_ModStart> ( ndp , ""rcvd<S2SV_blank>from:<S2SV_blank>%s,<S2SV_blank>ifindex:<S2SV_blank>%u,<S2SV_blank>hoplimit:<S2SV_blank>%d"" <S2SV_ModEnd> , str_in6_addr ( <S2SV_ModStart> msg -> ifindex , msg -> hoplimit ) ; if ( msg -> hoplimit != 255 ) { warn ( ndp , ""ignoring<S2SV_blank>packet<S2SV_blank>with<S2SV_blank>bad<S2SV_blank>hop<S2SV_blank>limit<S2SV_blank>(%d)"" , msg -> hoplimit ) ; err = 0 ; goto free_msg ; } <S2SV_ModEnd> if ( len
"
37,"CWE-399 static void xen_netbk_tx_submit ( struct xen_netbk * netbk ) { struct gnttab_copy * gop = netbk -> tx_copy_ops ; struct sk_buff * skb ; while ( ( skb = __skb_dequeue ( & netbk -> tx_queue ) ) != NULL ) { struct xen_netif_tx_request * txp ; struct xenvif * vif ; u16 pending_idx ; unsigned data_len ; pending_idx = * ( ( u16 * ) skb -> data ) ; vif = netbk -> pending_tx_info [ pending_idx ] . vif ; txp = & netbk -> pending_tx_info [ pending_idx ] . req ; if ( unlikely ( xen_netbk_tx_check_gop ( netbk , skb , & gop ) ) ) { netdev_dbg ( vif -> dev , ""netback<S2SV_blank>grant<S2SV_blank>failed.\\n"" ) ; skb_shinfo ( skb ) -> nr_frags = 0 ; kfree_skb ( skb ) ; continue ; } data_len = skb -> len ; memcpy ( skb -> data , ( void * ) ( idx_to_kaddr ( netbk , pending_idx ) | txp -> offset ) , data_len ) ; if ( data_len < txp -> size ) { txp -> offset += data_len ; txp -> size -= data_len ; } else { <S2SV_StartBug> xen_netbk_idx_release ( netbk , pending_idx ) ; <S2SV_EndBug> } if ( txp -> flags & XEN_NETTXF_csum_blank ) skb -> ip_summed = CHECKSUM_PARTIAL ; else if ( txp -> flags & XEN_NETTXF_data_validated ) skb -> ip_summed = CHECKSUM_UNNECESSARY ; xen_netbk_fill_frags ( netbk , skb ) ; if ( skb_headlen ( skb ) < PKT_PROT_LEN && skb_is_nonlinear ( skb ) ) { int target = min_t ( int , skb -> len , PKT_PROT_LEN ) ; __pskb_pull_tail ( skb , target - skb_headlen ( skb ) ) ; } skb -> dev = vif -> dev ; skb -> protocol = eth_type_trans ( skb , skb -> dev ) ; if ( checksum_setup ( vif , skb ) ) { netdev_dbg ( vif -> dev , ""Can\'t<S2SV_blank>setup<S2SV_blank>checksum<S2SV_blank>in<S2SV_blank>net_tx_action\\n"" ) ; kfree_skb ( skb ) ; continue ; } vif -> dev -> stats . rx_bytes += skb -> len ; vif -> dev -> stats . rx_packets ++ ; xenvif_receive_skb ( vif , skb ) ; } }
","<S2SV_ModStart> netbk , pending_idx , XEN_NETIF_RSP_OKAY
"
38,"CWE-20 int kvm_read_guest_page ( struct kvm * kvm , gfn_t gfn , void * data , int offset , int len ) { int r ; unsigned long addr ; addr = gfn_to_hva ( kvm , gfn ) ; if ( kvm_is_error_hva ( addr ) ) return - EFAULT ; <S2SV_StartBug> r = copy_from_user ( data , ( void __user * ) addr + offset , len ) ; <S2SV_EndBug> if ( r ) return - EFAULT ; return 0 ; }
","<S2SV_ModStart> ; r = __copy_from_user <S2SV_ModEnd> ( data ,
"
39,"CWE-20 static int mxf_read_primer_pack ( void * arg , AVIOContext * pb , int tag , int size , UID uid , int64_t klv_offset ) { MXFContext * mxf = arg ; int item_num = avio_rb32 ( pb ) ; int item_len = avio_rb32 ( pb ) ; if ( item_len != 18 ) { avpriv_request_sample ( pb , ""Primer<S2SV_blank>pack<S2SV_blank>item<S2SV_blank>length<S2SV_blank>%d"" , item_len ) ; return AVERROR_PATCHWELCOME ; } <S2SV_StartBug> if ( item_num > 65536 ) { <S2SV_EndBug> av_log ( mxf -> fc , AV_LOG_ERROR , ""item_num<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large\\n"" , item_num ) ; return AVERROR_INVALIDDATA ; } if ( mxf -> local_tags ) av_log ( mxf -> fc , AV_LOG_VERBOSE , ""Multiple<S2SV_blank>primer<S2SV_blank>packs\\n"" ) ; av_free ( mxf -> local_tags ) ; mxf -> local_tags_count = 0 ; mxf -> local_tags = av_calloc ( item_num , item_len ) ; if ( ! mxf -> local_tags ) return AVERROR ( ENOMEM ) ; mxf -> local_tags_count = item_num ; avio_read ( pb , mxf -> local_tags , item_num * item_len ) ; return 0 ; }
","<S2SV_ModStart> item_num > 65536 || item_num < 0
"
40,"CWE-19 int xfs_attr3_leaf_getvalue ( struct xfs_buf * bp , struct xfs_da_args * args ) { struct xfs_attr_leafblock * leaf ; struct xfs_attr3_icleaf_hdr ichdr ; struct xfs_attr_leaf_entry * entry ; struct xfs_attr_leaf_name_local * name_loc ; struct xfs_attr_leaf_name_remote * name_rmt ; int valuelen ; leaf = bp -> b_addr ; xfs_attr3_leaf_hdr_from_disk ( & ichdr , leaf ) ; ASSERT ( ichdr . count < XFS_LBSIZE ( args -> dp -> i_mount ) / 8 ) ; ASSERT ( args -> index < ichdr . count ) ; entry = & xfs_attr3_leaf_entryp ( leaf ) [ args -> index ] ; if ( entry -> flags & XFS_ATTR_LOCAL ) { name_loc = xfs_attr3_leaf_name_local ( leaf , args -> index ) ; ASSERT ( name_loc -> namelen == args -> namelen ) ; ASSERT ( memcmp ( args -> name , name_loc -> nameval , args -> namelen ) == 0 ) ; valuelen = be16_to_cpu ( name_loc -> valuelen ) ; if ( args -> flags & ATTR_KERNOVAL ) { args -> valuelen = valuelen ; return 0 ; } if ( args -> valuelen < valuelen ) { args -> valuelen = valuelen ; return XFS_ERROR ( ERANGE ) ; } args -> valuelen = valuelen ; memcpy ( args -> value , & name_loc -> nameval [ args -> namelen ] , valuelen ) ; } else { name_rmt = xfs_attr3_leaf_name_remote ( leaf , args -> index ) ; ASSERT ( name_rmt -> namelen == args -> namelen ) ; ASSERT ( memcmp ( args -> name , name_rmt -> name , args -> namelen ) == 0 ) ; <S2SV_StartBug> valuelen = be32_to_cpu ( name_rmt -> valuelen ) ; <S2SV_EndBug> args -> rmtblkno = be32_to_cpu ( name_rmt -> valueblk ) ; args -> rmtblkcnt = xfs_attr3_rmt_blocks ( args -> dp -> i_mount , <S2SV_StartBug> valuelen ) ; <S2SV_EndBug> if ( args -> flags & ATTR_KERNOVAL ) { <S2SV_StartBug> args -> valuelen = valuelen ; <S2SV_EndBug> return 0 ; } <S2SV_StartBug> if ( args -> valuelen < valuelen ) { <S2SV_EndBug> args -> valuelen = valuelen ; return XFS_ERROR ( ERANGE ) ; } <S2SV_StartBug> args -> valuelen = valuelen ; <S2SV_EndBug> } return 0 ; }
","<S2SV_ModStart> 0 ) ; args -> rmtvaluelen <S2SV_ModEnd> = be32_to_cpu ( <S2SV_ModStart> -> i_mount , args -> rmtvaluelen <S2SV_ModEnd> ) ; if <S2SV_ModStart> -> valuelen = args -> rmtvaluelen <S2SV_ModEnd> ; return 0 <S2SV_ModStart> -> valuelen < args -> rmtvaluelen ) { args -> valuelen = args -> rmtvaluelen <S2SV_ModEnd> ; return XFS_ERROR <S2SV_ModStart> -> valuelen = args -> rmtvaluelen <S2SV_ModEnd> ; } return
"
41,"CWE-125 void vtp_print ( netdissect_options * ndo , const u_char * pptr , u_int length ) { int type , len , tlv_len , tlv_value , mgmtd_len ; const u_char * tptr ; const struct vtp_vlan_ * vtp_vlan ; if ( length < VTP_HEADER_LEN ) goto trunc ; tptr = pptr ; ND_TCHECK2 ( * tptr , VTP_HEADER_LEN ) ; type = * ( tptr + 1 ) ; ND_PRINT ( ( ndo , ""VTPv%u,<S2SV_blank>Message<S2SV_blank>%s<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u"" , * tptr , tok2str ( vtp_message_type_values , ""Unknown<S2SV_blank>message<S2SV_blank>type"" , type ) , type , length ) ) ; if ( ndo -> ndo_vflag < 1 ) { return ; } ND_PRINT ( ( ndo , ""\\n\\tDomain<S2SV_blank>name:<S2SV_blank>"" ) ) ; mgmtd_len = * ( tptr + 3 ) ; if ( mgmtd_len < 1 || mgmtd_len > 32 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[invalid<S2SV_blank>MgmtD<S2SV_blank>Len<S2SV_blank>%d]"" , mgmtd_len ) ) ; return ; } fn_printzp ( ndo , tptr + 4 , mgmtd_len , NULL ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>%s:<S2SV_blank>%u"" , tok2str ( vtp_header_values , ""Unknown"" , type ) , * ( tptr + 2 ) ) ) ; tptr += VTP_HEADER_LEN ; switch ( type ) { case VTP_SUMMARY_ADV : ND_TCHECK2 ( * tptr , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Config<S2SV_blank>Rev<S2SV_blank>%x,<S2SV_blank>Updater<S2SV_blank>%s"" , EXTRACT_32BITS ( tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; tptr += 8 ; ND_TCHECK2 ( * tptr , VTP_UPDATE_TIMESTAMP_LEN ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>Timestamp<S2SV_blank>0x%08x<S2SV_blank>0x%08x<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) ) ) ; tptr += VTP_UPDATE_TIMESTAMP_LEN ; ND_TCHECK2 ( * tptr , VTP_MD5_DIGEST_LEN ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>MD5<S2SV_blank>digest:<S2SV_blank>%08x%08x%08x%08x"" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) , EXTRACT_32BITS ( tptr + 12 ) ) ) ; tptr += VTP_MD5_DIGEST_LEN ; break ; case VTP_SUBSET_ADV : <S2SV_StartBug> ND_PRINT ( ( ndo , "",<S2SV_blank>Config<S2SV_blank>Rev<S2SV_blank>%x"" , EXTRACT_32BITS ( tptr ) ) ) ; <S2SV_EndBug> tptr += 4 ; <S2SV_StartBug> while ( tptr < ( pptr + length ) ) { <S2SV_EndBug> len = * tptr ; if ( len == 0 ) break ; ND_TCHECK2 ( * tptr , len ) ; vtp_vlan = ( const struct vtp_vlan_ * ) tptr ; ND_TCHECK ( * vtp_vlan ) ; ND_PRINT ( ( ndo , ""\\n\\tVLAN<S2SV_blank>info<S2SV_blank>status<S2SV_blank>%s,<S2SV_blank>type<S2SV_blank>%s,<S2SV_blank>VLAN-id<S2SV_blank>%u,<S2SV_blank>MTU<S2SV_blank>%u,<S2SV_blank>SAID<S2SV_blank>0x%08x,<S2SV_blank>Name<S2SV_blank>"" , tok2str ( vtp_vlan_status , ""Unknown"" , vtp_vlan -> status ) , tok2str ( vtp_vlan_type_values , ""Unknown"" , vtp_vlan -> type ) , EXTRACT_16BITS ( & vtp_vlan -> vlanid ) , EXTRACT_16BITS ( & vtp_vlan -> mtu ) , EXTRACT_32BITS ( & vtp_vlan -> index ) ) ) ; fn_printzp ( ndo , tptr + VTP_VLAN_INFO_OFFSET , vtp_vlan -> name_len , NULL ) ; len -= VTP_VLAN_INFO_OFFSET + 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ; tptr += VTP_VLAN_INFO_OFFSET + 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ; while ( len > 0 ) { type = * tptr ; tlv_len = * ( tptr + 1 ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t%s<S2SV_blank>(0x%04x)<S2SV_blank>TLV"" , tok2str ( vtp_vlan_tlv_values , ""Unknown"" , type ) , type ) ) ; if ( type == 0 || tlv_len == 0 ) { return ; } ND_TCHECK2 ( * tptr , tlv_len * 2 + 2 ) ; tlv_value = EXTRACT_16BITS ( tptr + 2 ) ; switch ( type ) { case VTP_VLAN_STE_HOP_COUNT : ND_PRINT ( ( ndo , "",<S2SV_blank>%u"" , tlv_value ) ) ; break ; case VTP_VLAN_PRUNING : ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>(%u)"" , tlv_value == 1 ? ""Enabled"" : ""Disabled"" , tlv_value ) ) ; break ; case VTP_VLAN_STP_TYPE : ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( vtp_stp_type_values , ""Unknown"" , tlv_value ) , tlv_value ) ) ; break ; case VTP_VLAN_BRIDGE_TYPE : ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>(%u)"" , tlv_value == 1 ? ""SRB"" : ""SRT"" , tlv_value ) ) ; break ; case VTP_VLAN_BACKUP_CRF_MODE : ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>(%u)"" , tlv_value == 1 ? ""Backup"" : ""Not<S2SV_blank>backup"" , tlv_value ) ) ; break ; case VTP_VLAN_SOURCE_ROUTING_RING_NUMBER : case VTP_VLAN_SOURCE_ROUTING_BRIDGE_NUMBER : case VTP_VLAN_PARENT_VLAN : case VTP_VLAN_TRANS_BRIDGED_VLAN : case VTP_VLAN_ARP_HOP_COUNT : default : print_unknown_data ( ndo , tptr , ""\\n\\t\\t<S2SV_blank><S2SV_blank>"" , 2 + tlv_len * 2 ) ; break ; } len -= 2 + tlv_len * 2 ; tptr += 2 + tlv_len * 2 ; } } break ; case VTP_ADV_REQUEST : ND_TCHECK2 ( * tptr , 4 ) ; ND_PRINT ( ( ndo , ""\\n\\tStart<S2SV_blank>value:<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr ) ) ) ; break ; case VTP_JOIN_MESSAGE : break ; default : break ; } return ; trunc : ND_PRINT ( ( ndo , ""[|vtp]"" ) ) ; }
","<S2SV_ModStart> case VTP_SUBSET_ADV : ND_TCHECK_32BITS ( tptr ) ; <S2SV_ModStart> ) ) { ND_TCHECK_8BITS ( tptr ) ;
"
42,"CWE-273 int unquoted_glob_pattern_p ( string ) register char * string ; { register int c ; char * send ; int open , bsquote ; DECLARE_MBSTATE ; open = bsquote = 0 ; send = string + strlen ( string ) ; while ( c = * string ++ ) { switch ( c ) { case '?' : case '*' : return ( 1 ) ; case '[' : open ++ ; continue ; case ']' : if ( open ) return ( 1 ) ; continue ; <S2SV_StartBug> case '+' : <S2SV_EndBug> case '@' : case '!' : if ( * string == '(' ) return ( 1 ) ; continue ; case '\\\\' : if ( * string != '\\0' && * string != '/' ) { bsquote = 1 ; string ++ ; continue ; } <S2SV_StartBug> else if ( * string == 0 ) <S2SV_EndBug> return ( 0 ) ; case CTLESC : if ( * string ++ == '\\0' ) return ( 0 ) ; } # ifdef HANDLE_MULTIBYTE string -- ; ADVANCE_CHAR_P ( string , send - string ) ; string ++ ; # else ADVANCE_CHAR_P ( string , send - string ) ; # endif } return ( ( bsquote && posix_glob_backslash ) ? 2 : 0 ) ; }
","<S2SV_ModStart> continue ; case '/' : if ( open ) open = 0 ; case <S2SV_ModStart> else if ( open && * string == '/' ) { string ++ ; continue ; } else if (
"
43,"CWE-125 static int update_write_order_info ( rdpContext * context , wStream * s , ORDER_INFO * orderInfo , size_t offset ) { size_t position ; WINPR_UNUSED ( context ) ; position = Stream_GetPosition ( s ) ; Stream_SetPosition ( s , offset ) ; Stream_Write_UINT8 ( s , orderInfo -> controlFlags ) ; if ( orderInfo -> controlFlags & ORDER_TYPE_CHANGE ) Stream_Write_UINT8 ( s , orderInfo -> orderType ) ; update_write_field_flags ( s , orderInfo -> fieldFlags , orderInfo -> controlFlags , <S2SV_StartBug> PRIMARY_DRAWING_ORDER_FIELD_BYTES [ orderInfo -> orderType ] ) ; <S2SV_EndBug> update_write_bounds ( s , orderInfo ) ; Stream_SetPosition ( s , position ) ; return 0 ; }
","<S2SV_ModStart> -> controlFlags , get_primary_drawing_order_field_bytes ( <S2SV_ModEnd> orderInfo -> orderType <S2SV_ModStart> orderInfo -> orderType , NULL ) <S2SV_ModEnd> ) ; update_write_bounds
"
44,"CWE-264 bool inode_owner_or_capable ( const struct inode * inode ) <S2SV_StartBug> { <S2SV_EndBug> if ( uid_eq ( current_fsuid ( ) , inode -> i_uid ) ) return true ; <S2SV_StartBug> if ( inode_capable ( inode , CAP_FOWNER ) ) <S2SV_EndBug> return true ; return false ; }
","<S2SV_ModStart> inode ) { struct user_namespace * ns ; <S2SV_ModStart> return true ; ns = current_user_ns ( ) ; if ( ns_capable ( ns , CAP_FOWNER ) && kuid_has_mapping ( ns , inode -> i_uid <S2SV_ModEnd> ) ) return
"
45,"CWE-415 static int sctp_wait_for_sndbuf ( struct sctp_association * asoc , long * timeo_p , size_t msg_len ) { struct sock * sk = asoc -> base . sk ; int err = 0 ; long current_timeo = * timeo_p ; DEFINE_WAIT ( wait ) ; pr_debug ( ""%s:<S2SV_blank>asoc:%p,<S2SV_blank>timeo:%ld,<S2SV_blank>msg_len:%zu\\n"" , __func__ , asoc , * timeo_p , msg_len ) ; sctp_association_hold ( asoc ) ; for ( ; ; ) { prepare_to_wait_exclusive ( & asoc -> wait , & wait , TASK_INTERRUPTIBLE ) ; if ( ! * timeo_p ) goto do_nonblock ; if ( sk -> sk_err || asoc -> state >= SCTP_STATE_SHUTDOWN_PENDING || asoc -> base . dead ) goto do_error ; if ( signal_pending ( current ) ) goto do_interrupted ; if ( msg_len <= sctp_wspace ( asoc ) ) break ; release_sock ( sk ) ; current_timeo = schedule_timeout ( current_timeo ) ; <S2SV_StartBug> if ( sk != asoc -> base . sk ) <S2SV_EndBug> goto do_error ; lock_sock ( sk ) ; * timeo_p = current_timeo ; } out : finish_wait ( & asoc -> wait , & wait ) ; sctp_association_put ( asoc ) ; return err ; do_error : err = - EPIPE ; goto out ; do_interrupted : err = sock_intr_errno ( * timeo_p ) ; goto out ; do_nonblock : err = - EAGAIN ; goto out ; }
","<S2SV_ModStart> current_timeo ) ; <S2SV_ModEnd> lock_sock ( sk
"
46,"CWE-416 static int updateDevice ( const struct header * headers , time_t t ) { struct device * * pp = & devlist ; struct device * p = * pp ; while ( p ) { if ( p -> headers [ HEADER_NT ] . l == headers [ HEADER_NT ] . l && ( 0 == memcmp ( p -> headers [ HEADER_NT ] . p , headers [ HEADER_NT ] . p , headers [ HEADER_NT ] . l ) ) && p -> headers [ HEADER_USN ] . l == headers [ HEADER_USN ] . l && ( 0 == memcmp ( p -> headers [ HEADER_USN ] . p , headers [ HEADER_USN ] . p , headers [ HEADER_USN ] . l ) ) ) { syslog ( LOG_DEBUG , ""device<S2SV_blank>updated<S2SV_blank>:<S2SV_blank>%.*s"" , headers [ HEADER_USN ] . l , headers [ HEADER_USN ] . p ) ; p -> t = t ; if ( headers [ HEADER_LOCATION ] . l > p -> headers [ HEADER_LOCATION ] . l ) { struct device * tmp ; tmp = realloc ( p , sizeof ( struct device ) + headers [ 0 ] . l + headers [ 1 ] . l + headers [ 2 ] . l ) ; if ( ! tmp ) { syslog ( LOG_ERR , ""updateDevice()<S2SV_blank>:<S2SV_blank>memory<S2SV_blank>allocation<S2SV_blank>error"" ) ; <S2SV_StartBug> free ( p ) ; <S2SV_EndBug> return 0 ; } p = tmp ; * pp = p ; } memcpy ( p -> data + p -> headers [ 0 ] . l + p -> headers [ 1 ] . l , headers [ 2 ] . p , headers [ 2 ] . l ) ; return 0 ; } pp = & p -> next ; p = * pp ; } syslog ( LOG_INFO , ""new<S2SV_blank>device<S2SV_blank>discovered<S2SV_blank>:<S2SV_blank>%.*s"" , headers [ HEADER_USN ] . l , headers [ HEADER_USN ] . p ) ; { char * pc ; int i ; p = malloc ( sizeof ( struct device ) + headers [ 0 ] . l + headers [ 1 ] . l + headers [ 2 ] . l ) ; if ( ! p ) { syslog ( LOG_ERR , ""updateDevice():<S2SV_blank>cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; return - 1 ; } p -> next = devlist ; p -> t = t ; pc = p -> data ; for ( i = 0 ; i < 3 ; i ++ ) { p -> headers [ i ] . p = pc ; p -> headers [ i ] . l = headers [ i ] . l ; memcpy ( pc , headers [ i ] . p , headers [ i ] . l ) ; pc += headers [ i ] . l ; } devlist = p ; sendNotifications ( NOTIF_NEW , p , NULL ) ; } return 1 ; }
","<S2SV_ModStart> ""updateDevice()<S2SV_blank>:<S2SV_blank>memory<S2SV_blank>allocation<S2SV_blank>error"" ) ; * pp = p -> next ;
"
47,"CWE-20 static int encrypted_update ( struct key * key , struct key_preparsed_payload * prep ) { struct encrypted_key_payload * epayload = key -> payload . data [ 0 ] ; struct encrypted_key_payload * new_epayload ; char * buf ; char * new_master_desc = NULL ; const char * format = NULL ; size_t datalen = prep -> datalen ; int ret = 0 ; <S2SV_StartBug> if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) <S2SV_EndBug> return - ENOKEY ; if ( datalen <= 0 || datalen > 32767 || ! prep -> data ) return - EINVAL ; buf = kmalloc ( datalen + 1 , GFP_KERNEL ) ; if ( ! buf ) return - ENOMEM ; buf [ datalen ] = 0 ; memcpy ( buf , prep -> data , datalen ) ; ret = datablob_parse ( buf , & format , & new_master_desc , NULL , NULL ) ; if ( ret < 0 ) goto out ; ret = valid_master_desc ( new_master_desc , epayload -> master_desc ) ; if ( ret < 0 ) goto out ; new_epayload = encrypted_key_alloc ( key , epayload -> format , new_master_desc , epayload -> datalen ) ; if ( IS_ERR ( new_epayload ) ) { ret = PTR_ERR ( new_epayload ) ; goto out ; } __ekey_init ( new_epayload , epayload -> format , new_master_desc , epayload -> datalen ) ; memcpy ( new_epayload -> iv , epayload -> iv , ivsize ) ; memcpy ( new_epayload -> payload_data , epayload -> payload_data , epayload -> payload_datalen ) ; rcu_assign_keypointer ( key , new_epayload ) ; call_rcu ( & epayload -> rcu , encrypted_rcu_free ) ; out : kzfree ( buf ) ; return ret ; }
","<S2SV_ModStart> ; if ( key_is_negative ( key <S2SV_ModEnd> ) ) return
"
48,"CWE-20 static int parse_rock_ridge_inode_internal ( struct iso_directory_record * de , <S2SV_StartBug> struct inode * inode , int regard_xa ) <S2SV_EndBug> { int symlink_len = 0 ; <S2SV_StartBug> int cnt , sig ; <S2SV_EndBug> struct inode * reloc ; struct rock_ridge * rr ; int rootflag ; struct rock_state rs ; int ret = 0 ; if ( ! ISOFS_SB ( inode -> i_sb ) -> s_rock ) return 0 ; init_rock_state ( & rs , inode ) ; setup_rock_ridge ( de , inode , & rs ) ; <S2SV_StartBug> if ( regard_xa ) { <S2SV_EndBug> rs . chr += 14 ; rs . len -= 14 ; if ( rs . len < 0 ) rs . len = 0 ; } repeat : while ( rs . len > 2 ) { rr = ( struct rock_ridge * ) rs . chr ; if ( rr -> len < 3 ) goto out ; sig = isonum_721 ( rs . chr ) ; if ( rock_check_overflow ( & rs , sig ) ) goto eio ; rs . chr += rr -> len ; rs . len -= rr -> len ; if ( rs . len < 0 ) goto out ; switch ( sig ) { # ifndef CONFIG_ZISOFS case SIG ( 'R' , 'R' ) : if ( ( rr -> u . RR . flags [ 0 ] & ( RR_PX | RR_TF | RR_SL | RR_CL ) ) == 0 ) goto out ; break ; # endif case SIG ( 'S' , 'P' ) : if ( check_sp ( rr , inode ) ) goto out ; break ; case SIG ( 'C' , 'E' ) : rs . cont_extent = isonum_733 ( rr -> u . CE . extent ) ; rs . cont_offset = isonum_733 ( rr -> u . CE . offset ) ; rs . cont_size = isonum_733 ( rr -> u . CE . size ) ; break ; case SIG ( 'E' , 'R' ) : ISOFS_SB ( inode -> i_sb ) -> s_rock = 1 ; printk ( KERN_DEBUG ""ISO<S2SV_blank>9660<S2SV_blank>Extensions:<S2SV_blank>"" ) ; { int p ; for ( p = 0 ; p < rr -> u . ER . len_id ; p ++ ) printk ( ""%c"" , rr -> u . ER . data [ p ] ) ; } printk ( ""\\n"" ) ; break ; case SIG ( 'P' , 'X' ) : inode -> i_mode = isonum_733 ( rr -> u . PX . mode ) ; set_nlink ( inode , isonum_733 ( rr -> u . PX . n_links ) ) ; i_uid_write ( inode , isonum_733 ( rr -> u . PX . uid ) ) ; i_gid_write ( inode , isonum_733 ( rr -> u . PX . gid ) ) ; break ; case SIG ( 'P' , 'N' ) : { int high , low ; high = isonum_733 ( rr -> u . PN . dev_high ) ; low = isonum_733 ( rr -> u . PN . dev_low ) ; if ( ( low & ~ 0xff ) && high == 0 ) { inode -> i_rdev = MKDEV ( low >> 8 , low & 0xff ) ; } else { inode -> i_rdev = MKDEV ( high , low ) ; } } break ; case SIG ( 'T' , 'F' ) : cnt = 0 ; if ( rr -> u . TF . flags & TF_CREATE ) { inode -> i_ctime . tv_sec = iso_date ( rr -> u . TF . times [ cnt ++ ] . time , 0 ) ; inode -> i_ctime . tv_nsec = 0 ; } if ( rr -> u . TF . flags & TF_MODIFY ) { inode -> i_mtime . tv_sec = iso_date ( rr -> u . TF . times [ cnt ++ ] . time , 0 ) ; inode -> i_mtime . tv_nsec = 0 ; } if ( rr -> u . TF . flags & TF_ACCESS ) { inode -> i_atime . tv_sec = iso_date ( rr -> u . TF . times [ cnt ++ ] . time , 0 ) ; inode -> i_atime . tv_nsec = 0 ; } if ( rr -> u . TF . flags & TF_ATTRIBUTES ) { inode -> i_ctime . tv_sec = iso_date ( rr -> u . TF . times [ cnt ++ ] . time , 0 ) ; inode -> i_ctime . tv_nsec = 0 ; } break ; case SIG ( 'S' , 'L' ) : { int slen ; struct SL_component * slp ; struct SL_component * oldslp ; slen = rr -> len - 5 ; slp = & rr -> u . SL . link ; inode -> i_size = symlink_len ; while ( slen > 1 ) { rootflag = 0 ; switch ( slp -> flags & ~ 1 ) { case 0 : inode -> i_size += slp -> len ; break ; case 2 : inode -> i_size += 1 ; break ; case 4 : inode -> i_size += 2 ; break ; case 8 : rootflag = 1 ; inode -> i_size += 1 ; break ; default : printk ( ""Symlink<S2SV_blank>component<S2SV_blank>flag<S2SV_blank>"" ""not<S2SV_blank>implemented\\n"" ) ; } slen -= slp -> len + 2 ; oldslp = slp ; slp = ( struct SL_component * ) ( ( ( char * ) slp ) + slp -> len + 2 ) ; if ( slen < 2 ) { if ( ( ( rr -> u . SL . flags & 1 ) != 0 ) && ( ( oldslp -> flags & 1 ) == 0 ) ) inode -> i_size += 1 ; break ; } if ( ! rootflag && ( oldslp -> flags & 1 ) == 0 ) inode -> i_size += 1 ; } } symlink_len = inode -> i_size ; break ; case SIG ( 'R' , 'E' ) : printk ( KERN_WARNING ""Attempt<S2SV_blank>to<S2SV_blank>read<S2SV_blank>inode<S2SV_blank>for<S2SV_blank>"" ""relocated<S2SV_blank>directory\\n"" ) ; goto out ; case SIG ( 'C' , 'L' ) : <S2SV_StartBug> ISOFS_I ( inode ) -> i_first_extent = <S2SV_EndBug> isonum_733 ( rr -> u . CL . location ) ; reloc = <S2SV_StartBug> isofs_iget ( inode -> i_sb , <S2SV_EndBug> <S2SV_StartBug> ISOFS_I ( inode ) -> i_first_extent , <S2SV_EndBug> 0 ) ; if ( IS_ERR ( reloc ) ) { ret = PTR_ERR ( reloc ) ; goto out ; } inode -> i_mode = reloc -> i_mode ; set_nlink ( inode , reloc -> i_nlink ) ; inode -> i_uid = reloc -> i_uid ; inode -> i_gid = reloc -> i_gid ; inode -> i_rdev = reloc -> i_rdev ; inode -> i_size = reloc -> i_size ; inode -> i_blocks = reloc -> i_blocks ; inode -> i_atime = reloc -> i_atime ; inode -> i_ctime = reloc -> i_ctime ; inode -> i_mtime = reloc -> i_mtime ; iput ( reloc ) ; break ; # ifdef CONFIG_ZISOFS case SIG ( 'Z' , 'F' ) : { int algo ; if ( ISOFS_SB ( inode -> i_sb ) -> s_nocompress ) break ; algo = isonum_721 ( rr -> u . ZF . algorithm ) ; if ( algo == SIG ( 'p' , 'z' ) ) { int block_shift = isonum_711 ( & rr -> u . ZF . parms [ 1 ] ) ; if ( block_shift > 17 ) { printk ( KERN_WARNING ""isofs:<S2SV_blank>"" ""Can\'t<S2SV_blank>handle<S2SV_blank>ZF<S2SV_blank>block<S2SV_blank>"" ""size<S2SV_blank>of<S2SV_blank>2^%d\\n"" , block_shift ) ; } else { ISOFS_I ( inode ) -> i_file_format = isofs_file_compressed ; ISOFS_I ( inode ) -> i_format_parm [ 0 ] = isonum_711 ( & rr -> u . ZF . parms [ 0 ] ) ; ISOFS_I ( inode ) -> i_format_parm [ 1 ] = isonum_711 ( & rr -> u . ZF . parms [ 1 ] ) ; inode -> i_size = isonum_733 ( rr -> u . ZF . real_size ) ; } } else { printk ( KERN_WARNING ""isofs:<S2SV_blank>Unknown<S2SV_blank>ZF<S2SV_blank>compression<S2SV_blank>"" ""algorithm:<S2SV_blank>%c%c\\n"" , rr -> u . ZF . algorithm [ 0 ] , rr -> u . ZF . algorithm [ 1 ] ) ; } break ; } # endif default : break ; } } ret = rock_continue ( & rs ) ; if ( ret == 0 ) goto repeat ; if ( ret == 1 ) ret = 0 ; out : kfree ( rs . buffer ) ; return ret ; eio : ret = - EIO ; goto out ; }
","<S2SV_ModStart> inode , int flags <S2SV_ModEnd> ) { int <S2SV_ModStart> cnt , sig ; unsigned int reloc_block <S2SV_ModStart> ; if ( flags & RR_REGARD_XA <S2SV_ModEnd> ) { rs <S2SV_ModStart> 'L' ) : if ( flags & RR_RELOC_DE ) { printk ( KERN_ERR ""ISOFS:<S2SV_blank>Recursive<S2SV_blank>directory<S2SV_blank>relocation<S2SV_blank>"" ""is<S2SV_blank>not<S2SV_blank>supported\\n"" ) ; goto eio ; } reloc_block = isonum_733 ( rr -> u . CL . location ) ; if ( reloc_block == <S2SV_ModStart> inode ) -> i_iget5_block && ISOFS_I ( inode ) -> i_iget5_offset == 0 ) { printk ( KERN_ERR ""ISOFS:<S2SV_blank>Directory<S2SV_blank>relocation<S2SV_blank>points<S2SV_blank>to<S2SV_blank>"" ""itself\\n"" ) ; goto eio ; } ISOFS_I ( inode ) -> i_first_extent = reloc_block <S2SV_ModEnd> ; reloc = <S2SV_ModStart> ; reloc = isofs_iget_reloc <S2SV_ModEnd> ( inode -> <S2SV_ModStart> -> i_sb , reloc_block , <S2SV_ModEnd> 0 ) ;
"
49,"CWE-190 int jas_stream_read ( jas_stream_t * stream , void * buf , int cnt ) { int n ; int c ; <S2SV_StartBug> char * bufptr ; <S2SV_EndBug> bufptr = buf ; n = 0 ; while ( n < cnt ) { if ( ( c = jas_stream_getc ( stream ) ) == EOF ) { return n ; } * bufptr ++ = c ; ++ n ; } return n ; }
","<S2SV_ModStart> * bufptr ; if ( cnt < 0 ) { jas_deprecated ( ""negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_read"" ) ; }
"
50,"CWE-000 static void ext4_end_io_dio ( struct kiocb * iocb , loff_t offset , ssize_t size , void * private ) { ext4_io_end_t * io_end = iocb -> private ; struct workqueue_struct * wq ; <S2SV_StartBug> if ( ! io_end || ! size ) <S2SV_EndBug> return ; ext_debug ( ""ext4_end_io_dio():<S2SV_blank>io_end<S2SV_blank>0x%p"" ""for<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>iocb<S2SV_blank>0x%p,<S2SV_blank>offset<S2SV_blank>%llu,<S2SV_blank>size<S2SV_blank>%llu\\n"" , iocb -> private , io_end -> inode -> i_ino , iocb , offset , size ) ; if ( io_end -> flag != EXT4_IO_UNWRITTEN ) { ext4_free_io_end ( io_end ) ; iocb -> private = NULL ; return ; } io_end -> offset = offset ; io_end -> size = size ; <S2SV_StartBug> wq = EXT4_SB ( io_end -> inode -> i_sb ) -> dio_unwritten_wq ; <S2SV_EndBug> queue_work ( wq , & io_end -> work ) ; <S2SV_StartBug> list_add_tail ( & io_end -> list , <S2SV_EndBug> <S2SV_StartBug> & EXT4_I ( io_end -> inode ) -> i_completed_io_list ) ; <S2SV_EndBug> iocb -> private = NULL ; }
","<S2SV_ModStart> * wq ; unsigned long flags ; struct ext4_inode_info * ei ; <S2SV_ModStart> = size ; io_end -> flag = EXT4_IO_UNWRITTEN ; <S2SV_ModStart> work ) ; ei = EXT4_I ( io_end -> inode ) ; spin_lock_irqsave ( & ei -> i_completed_io_lock , flags ) ; <S2SV_ModStart> -> list , & ei -> i_completed_io_list ) ; spin_unlock_irqrestore ( & ei -> i_completed_io_lock , flags <S2SV_ModEnd> ) ; iocb
"
51,"CWE-119 <S2SV_StartBug> static vpx_codec_err_t vp8_get_last_ref_frame ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> int ctrl_id , va_list args ) { int * ref_info = va_arg ( args , int * ) ; if ( ref_info && ! ctx -> yv12_frame_buffers . use_frame_threads ) { VP8D_COMP * pbi = ( VP8D_COMP * ) ctx -> yv12_frame_buffers . pbi [ 0 ] ; VP8_COMMON * oci = & pbi -> common ; * ref_info = ( vp8dx_references_buffer ( oci , ALTREF_FRAME ) ? VP8_ALTR_FRAME : 0 ) | ( vp8dx_references_buffer ( oci , GOLDEN_FRAME ) ? VP8_GOLD_FRAME : 0 ) | ( vp8dx_references_buffer ( oci , LAST_FRAME ) ? VP8_LAST_FRAME : 0 ) ; return VPX_CODEC_OK ; } else return VPX_CODEC_INVALID_PARAM ; }
","<S2SV_ModStart> vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args
"
52,"CWE-401 static struct clock_source * dce120_clock_source_create ( struct dc_context * ctx , struct dc_bios * bios , enum clock_source_id id , const struct dce110_clk_src_regs * regs , bool dp_clk_src ) { struct dce110_clk_src * clk_src = kzalloc ( sizeof ( * clk_src ) , GFP_KERNEL ) ; if ( ! clk_src ) return NULL ; if ( dce112_clk_src_construct ( clk_src , ctx , bios , id , regs , & cs_shift , & cs_mask ) ) { clk_src -> base . dp_clk_src = dp_clk_src ; return & clk_src -> base ; } <S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug> return NULL ; }
","<S2SV_ModStart> base ; } kfree ( clk_src ) ;
"
53,"CWE-119 <S2SV_StartBug> static int read_intra_segment_id ( VP9_COMMON * const cm , MACROBLOCKD * const xd , <S2SV_EndBug> int mi_row , int mi_col , vp9_reader * r ) { <S2SV_StartBug> struct segmentation * const seg = & cm -> seg ; <S2SV_EndBug> const BLOCK_SIZE bsize = xd -> mi [ 0 ] -> mbmi . sb_type ; int segment_id ; if ( ! seg -> enabled ) return 0 ; <S2SV_StartBug> if ( ! seg -> update_map ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> segment_id = read_segment_id ( r , seg ) ; <S2SV_StartBug> set_segment_id ( cm , bsize , mi_row , mi_col , segment_id ) ; <S2SV_EndBug> return segment_id ; }
","<S2SV_ModStart> const cm , int mi_offset , int x_mis , int y_mis , vpx_reader <S2SV_ModEnd> * r ) <S2SV_ModStart> cm -> seg <S2SV_ModEnd> ; int segment_id <S2SV_ModStart> -> update_map ) { copy_segment_id ( cm , cm -> last_frame_seg_map , cm -> current_frame_seg_map , mi_offset , x_mis , y_mis ) ; <S2SV_ModStart> return 0 ; } <S2SV_ModStart> ( cm , mi_offset , x_mis , y_mis <S2SV_ModEnd> , segment_id )
"
54,"CWE-400 int perf_output_begin ( struct perf_output_handle * handle , struct perf_event * event , unsigned int size , <S2SV_StartBug> int nmi , int sample ) <S2SV_EndBug> { struct ring_buffer * rb ; unsigned long tail , offset , head ; int have_lost ; struct perf_sample_data sample_data ; struct { struct perf_event_header header ; u64 id ; u64 lost ; } lost_event ; rcu_read_lock ( ) ; if ( event -> parent ) event = event -> parent ; rb = rcu_dereference ( event -> rb ) ; if ( ! rb ) goto out ; handle -> rb = rb ; handle -> event = event ; <S2SV_StartBug> handle -> nmi = nmi ; <S2SV_EndBug> handle -> sample = sample ; if ( ! rb -> nr_pages ) goto out ; have_lost = local_read ( & rb -> lost ) ; if ( have_lost ) { lost_event . header . size = sizeof ( lost_event ) ; perf_event_header__init_id ( & lost_event . header , & sample_data , event ) ; size += lost_event . header . size ; } perf_output_get_handle ( handle ) ; do { tail = ACCESS_ONCE ( rb -> user_page -> data_tail ) ; smp_rmb ( ) ; offset = head = local_read ( & rb -> head ) ; head += size ; if ( unlikely ( ! perf_output_space ( rb , tail , offset , head ) ) ) goto fail ; } while ( local_cmpxchg ( & rb -> head , offset , head ) != offset ) ; if ( head - local_read ( & rb -> wakeup ) > rb -> watermark ) local_add ( rb -> watermark , & rb -> wakeup ) ; handle -> page = offset >> ( PAGE_SHIFT + page_order ( rb ) ) ; handle -> page &= rb -> nr_pages - 1 ; handle -> size = offset & ( ( PAGE_SIZE << page_order ( rb ) ) - 1 ) ; handle -> addr = rb -> data_pages [ handle -> page ] ; handle -> addr += handle -> size ; handle -> size = ( PAGE_SIZE << page_order ( rb ) ) - handle -> size ; if ( have_lost ) { lost_event . header . type = PERF_RECORD_LOST ; lost_event . header . misc = 0 ; lost_event . id = event -> id ; lost_event . lost = local_xchg ( & rb -> lost , 0 ) ; perf_output_put ( handle , lost_event ) ; perf_event__output_id_sample ( event , handle , & sample_data ) ; } return 0 ; fail : local_inc ( & rb -> lost ) ; perf_output_put_handle ( handle ) ; out : rcu_read_unlock ( ) ; return - ENOSPC ; }
","<S2SV_ModStart> size , int <S2SV_ModEnd> sample ) { <S2SV_ModStart> ; handle -> <S2SV_ModEnd> sample = sample
"
55,"CWE-119 static int check_alu_op ( struct bpf_verifier_env * env , struct bpf_insn * insn ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; int err ; if ( opcode == BPF_END || opcode == BPF_NEG ) { if ( opcode == BPF_NEG ) { if ( BPF_SRC ( insn -> code ) != 0 || insn -> src_reg != BPF_REG_0 || insn -> off != 0 || insn -> imm != 0 ) { verbose ( env , ""BPF_NEG<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } } else { if ( insn -> src_reg != BPF_REG_0 || insn -> off != 0 || ( insn -> imm != 16 && insn -> imm != 32 && insn -> imm != 64 ) || BPF_CLASS ( insn -> code ) == BPF_ALU64 ) { verbose ( env , ""BPF_END<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; if ( is_pointer_value ( env , insn -> dst_reg ) ) { verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>prohibited\\n"" , insn -> dst_reg ) ; return - EACCES ; } err = check_reg_arg ( env , insn -> dst_reg , DST_OP ) ; if ( err ) return err ; } else if ( opcode == BPF_MOV ) { if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( insn -> imm != 0 || insn -> off != 0 ) { verbose ( env , ""BPF_MOV<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; } else { if ( insn -> src_reg != BPF_REG_0 || insn -> off != 0 ) { verbose ( env , ""BPF_MOV<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , DST_OP ) ; if ( err ) return err ; if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) { regs [ insn -> dst_reg ] = regs [ insn -> src_reg ] ; regs [ insn -> dst_reg ] . live |= REG_LIVE_WRITTEN ; } else { if ( is_pointer_value ( env , insn -> src_reg ) ) { verbose ( env , ""R%d<S2SV_blank>partial<S2SV_blank>copy<S2SV_blank>of<S2SV_blank>pointer\\n"" , insn -> src_reg ) ; return - EACCES ; } mark_reg_unknown ( env , regs , insn -> dst_reg ) ; regs [ insn -> dst_reg ] . var_off = tnum_cast ( regs [ insn -> dst_reg ] . var_off , 4 ) ; __update_reg_bounds ( & regs [ insn -> dst_reg ] ) ; } } else { regs [ insn -> dst_reg ] . type = SCALAR_VALUE ; <S2SV_StartBug> __mark_reg_known ( regs + insn -> dst_reg , insn -> imm ) ; <S2SV_EndBug> } } else if ( opcode > BPF_END ) { verbose ( env , ""invalid<S2SV_blank>BPF_ALU<S2SV_blank>opcode<S2SV_blank>%x\\n"" , opcode ) ; return - EINVAL ; } else { if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( insn -> imm != 0 || insn -> off != 0 ) { verbose ( env , ""BPF_ALU<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; } else { if ( insn -> src_reg != BPF_REG_0 || insn -> off != 0 ) { verbose ( env , ""BPF_ALU<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; if ( ( opcode == BPF_MOD || opcode == BPF_DIV ) && BPF_SRC ( insn -> code ) == BPF_K && insn -> imm == 0 ) { verbose ( env , ""div<S2SV_blank>by<S2SV_blank>zero\\n"" ) ; return - EINVAL ; } if ( ( opcode == BPF_LSH || opcode == BPF_RSH || opcode == BPF_ARSH ) && BPF_SRC ( insn -> code ) == BPF_K ) { int size = BPF_CLASS ( insn -> code ) == BPF_ALU64 ? 64 : 32 ; if ( insn -> imm < 0 || insn -> imm >= size ) { verbose ( env , ""invalid<S2SV_blank>shift<S2SV_blank>%d\\n"" , insn -> imm ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , DST_OP_NO_MARK ) ; if ( err ) return err ; return adjust_reg_min_max_vals ( env , insn ) ; } return 0 ; }
","<S2SV_ModStart> = SCALAR_VALUE ; if ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) { <S2SV_ModStart> -> dst_reg , insn -> imm ) ; } else { __mark_reg_known ( regs + insn -> dst_reg , ( u32 ) insn -> imm ) ; } <S2SV_ModEnd> } } else
"
56,"CWE-119 static inline int check_entry_size_and_hooks ( struct arpt_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct arpt_entry ) != 0 || ( unsigned char * ) e + sizeof ( struct arpt_entry ) >= limit || ( unsigned char * ) e + e -> next_offset > limit ) { duprintf ( ""Bad<S2SV_blank>offset<S2SV_blank>%p\\n"" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct arpt_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\n"" , e , e -> next_offset ) ; return - EINVAL ; } err = check_entry ( e ) ; if ( err ) return err ; for ( h = 0 ; h < NF_ARP_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) { <S2SV_StartBug> pr_err ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>"" <S2SV_EndBug> ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"" ""ACCEPT/DROP\\n"" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows [ h ] ; } } e -> counters = ( ( struct xt_counters ) { 0 , 0 } ) ; e -> comefrom = 0 ; return 0 ; }
","<S2SV_ModStart> ) ) { pr_debug <S2SV_ModEnd> ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>"" ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>""
"
57,"CWE-416 void fe_netjoin_deinit ( void ) { while ( joinservers != NULL ) netjoin_server_remove ( joinservers -> data ) ; if ( join_tag != - 1 ) { g_source_remove ( join_tag ) ; signal_remove ( ""print<S2SV_blank>starting"" , ( SIGNAL_FUNC ) sig_print_starting ) ; } signal_remove ( ""setup<S2SV_blank>changed"" , ( SIGNAL_FUNC ) read_settings ) ; <S2SV_StartBug> signal_remove ( ""message<S2SV_blank>quit"" , ( SIGNAL_FUNC ) msg_quit ) ; <S2SV_EndBug> signal_remove ( ""message<S2SV_blank>join"" , ( SIGNAL_FUNC ) msg_join ) ; signal_remove ( ""message<S2SV_blank>irc<S2SV_blank>mode"" , ( SIGNAL_FUNC ) msg_mode ) ; }
","<S2SV_ModStart> ; signal_remove ( ""server<S2SV_blank>disconnected"" , ( SIGNAL_FUNC ) sig_server_disconnected ) ; signal_remove (
"
58,"CWE-399 int __kvm_set_memory_region ( struct kvm * kvm , struct kvm_userspace_memory_region * mem , int user_alloc ) { int r ; gfn_t base_gfn ; unsigned long npages ; struct kvm_memory_slot * memslot , * slot ; struct kvm_memory_slot old , new ; struct kvm_memslots * slots , * old_memslots ; r = check_memory_region_flags ( mem ) ; if ( r ) goto out ; r = - EINVAL ; if ( mem -> memory_size & ( PAGE_SIZE - 1 ) ) goto out ; if ( mem -> guest_phys_addr & ( PAGE_SIZE - 1 ) ) goto out ; if ( user_alloc && ( ( mem -> userspace_addr & ( PAGE_SIZE - 1 ) ) || ! access_ok ( VERIFY_WRITE , ( void __user * ) ( unsigned long ) mem -> userspace_addr , mem -> memory_size ) ) ) goto out ; if ( mem -> slot >= KVM_MEM_SLOTS_NUM ) goto out ; if ( mem -> guest_phys_addr + mem -> memory_size < mem -> guest_phys_addr ) goto out ; memslot = id_to_memslot ( kvm -> memslots , mem -> slot ) ; base_gfn = mem -> guest_phys_addr >> PAGE_SHIFT ; npages = mem -> memory_size >> PAGE_SHIFT ; r = - EINVAL ; if ( npages > KVM_MEM_MAX_NR_PAGES ) goto out ; if ( ! npages ) mem -> flags &= ~ KVM_MEM_LOG_DIRTY_PAGES ; new = old = * memslot ; new . id = mem -> slot ; new . base_gfn = base_gfn ; new . npages = npages ; new . flags = mem -> flags ; r = - EINVAL ; if ( npages && old . npages && npages != old . npages ) goto out_free ; if ( ! npages && ! old . npages ) goto out_free ; r = - EEXIST ; kvm_for_each_memslot ( slot , kvm -> memslots ) { if ( slot -> id >= KVM_MEMORY_SLOTS || slot == memslot ) continue ; if ( ! ( ( base_gfn + npages <= slot -> base_gfn ) || ( base_gfn >= slot -> base_gfn + slot -> npages ) ) ) goto out_free ; } if ( ! ( new . flags & KVM_MEM_LOG_DIRTY_PAGES ) ) new . dirty_bitmap = NULL ; r = - ENOMEM ; if ( ! old . npages ) { new . user_alloc = user_alloc ; new . userspace_addr = mem -> userspace_addr ; if ( kvm_arch_create_memslot ( & new , npages ) ) goto out_free ; } else if ( npages && mem -> userspace_addr != old . userspace_addr ) { r = - EINVAL ; goto out_free ; } if ( ( new . flags & KVM_MEM_LOG_DIRTY_PAGES ) && ! new . dirty_bitmap ) { if ( kvm_create_dirty_bitmap ( & new ) < 0 ) goto out_free ; } if ( ! npages || base_gfn != old . base_gfn ) { struct kvm_memory_slot * slot ; r = - ENOMEM ; slots = kmemdup ( kvm -> memslots , sizeof ( struct kvm_memslots ) , GFP_KERNEL ) ; if ( ! slots ) goto out_free ; slot = id_to_memslot ( slots , mem -> slot ) ; slot -> flags |= KVM_MEMSLOT_INVALID ; update_memslots ( slots , NULL ) ; old_memslots = kvm -> memslots ; rcu_assign_pointer ( kvm -> memslots , slots ) ; synchronize_srcu_expedited ( & kvm -> srcu ) ; <S2SV_StartBug> kvm_arch_flush_shadow_memslot ( kvm , slot ) ; <S2SV_EndBug> kfree ( old_memslots ) ; } r = kvm_arch_prepare_memory_region ( kvm , & new , old , mem , user_alloc ) ; if ( r ) <S2SV_StartBug> goto out_free ; <S2SV_EndBug> if ( npages ) { r = kvm_iommu_map_pages ( kvm , & new ) ; if ( r ) goto out_free ; } else kvm_iommu_unmap_pages ( kvm , & old ) ; r = - ENOMEM ; slots = kmemdup ( kvm -> memslots , sizeof ( struct kvm_memslots ) , GFP_KERNEL ) ; if ( ! slots ) goto out_free ; <S2SV_StartBug> if ( ! npages ) { <S2SV_EndBug> new . dirty_bitmap = NULL ; memset ( & new . arch , 0 , sizeof ( new . arch ) ) ; } update_memslots ( slots , & new ) ; old_memslots = kvm -> memslots ; rcu_assign_pointer ( kvm -> memslots , slots ) ; synchronize_srcu_expedited ( & kvm -> srcu ) ; kvm_arch_commit_memory_region ( kvm , mem , old , user_alloc ) ; kvm_free_physmem_slot ( & old , & new ) ; kfree ( old_memslots ) ; return 0 ; <S2SV_StartBug> out_free : <S2SV_EndBug> kvm_free_physmem_slot ( & new , & old ) ; out : return r ; }
","<S2SV_ModStart> srcu ) ; kvm_iommu_unmap_pages ( kvm , & old ) ; <S2SV_ModStart> ) goto out_free <S2SV_ModEnd> ; r = <S2SV_ModStart> ; if ( npages ) { r = kvm_iommu_map_pages ( kvm , & new ) ; if ( r ) goto out_slots ; } if ( <S2SV_ModStart> return 0 ; out_slots : kfree ( slots ) ;
"
59,"CWE-119 void vp8_update_gf_useage_maps ( VP8_COMP * cpi , VP8_COMMON * cm , MACROBLOCK * x ) { int mb_row , mb_col ; MODE_INFO * this_mb_mode_info = cm -> mi ; x -> gf_active_ptr = ( signed char * ) cpi -> gf_active_flags ; if ( ( cm -> frame_type == KEY_FRAME ) || ( cm -> refresh_golden_frame ) ) { <S2SV_StartBug> vpx_memset ( cpi -> gf_active_flags , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ; <S2SV_EndBug> cpi -> gf_active_count = cm -> mb_rows * cm -> mb_cols ; } else { for ( mb_row = 0 ; mb_row < cm -> mb_rows ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cm -> mb_cols ; mb_col ++ ) { if ( ( this_mb_mode_info -> mbmi . ref_frame == GOLDEN_FRAME ) || ( this_mb_mode_info -> mbmi . ref_frame == ALTREF_FRAME ) ) { if ( * ( x -> gf_active_ptr ) == 0 ) { * ( x -> gf_active_ptr ) = 1 ; cpi -> gf_active_count ++ ; } } else if ( ( this_mb_mode_info -> mbmi . mode != ZEROMV ) && * ( x -> gf_active_ptr ) ) { * ( x -> gf_active_ptr ) = 0 ; cpi -> gf_active_count -- ; } x -> gf_active_ptr ++ ; this_mb_mode_info ++ ; } this_mb_mode_info ++ ; } } }
","<S2SV_ModStart> ) ) { memset <S2SV_ModEnd> ( cpi ->
"
60,"CWE-476 bool ExprResolveLhs ( struct xkb_context * ctx , const ExprDef * expr , const char * * elem_rtrn , const char * * field_rtrn , ExprDef * * index_rtrn ) { switch ( expr -> expr . op ) { case EXPR_IDENT : * elem_rtrn = NULL ; * field_rtrn = xkb_atom_text ( ctx , expr -> ident . ident ) ; * index_rtrn = NULL ; return ( * field_rtrn != NULL ) ; case EXPR_FIELD_REF : * elem_rtrn = xkb_atom_text ( ctx , expr -> field_ref . element ) ; * field_rtrn = xkb_atom_text ( ctx , expr -> field_ref . field ) ; * index_rtrn = NULL ; <S2SV_StartBug> return true ; <S2SV_EndBug> case EXPR_ARRAY_REF : * elem_rtrn = xkb_atom_text ( ctx , expr -> array_ref . element ) ; * field_rtrn = xkb_atom_text ( ctx , expr -> array_ref . field ) ; * index_rtrn = expr -> array_ref . entry ; <S2SV_StartBug> return true ; <S2SV_EndBug> default : break ; } log_wsgo ( ctx , ""Unexpected<S2SV_blank>operator<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>ResolveLhs\\n"" , expr -> expr . op ) ; return false ; }
","<S2SV_ModStart> NULL ; return ( * elem_rtrn != NULL && * field_rtrn != NULL ) <S2SV_ModEnd> ; case EXPR_ARRAY_REF <S2SV_ModStart> . entry ; if ( expr -> array_ref . element != XKB_ATOM_NONE && * elem_rtrn == NULL ) return false ; if ( * field_rtrn == NULL ) return false ;
"
61,"CWE-200 static void ipv6_select_ident ( struct frag_hdr * fhdr , struct rt6_info * rt ) { static u32 ip6_idents_hashrnd __read_mostly ; <S2SV_StartBug> u32 hash , id ; <S2SV_EndBug> <S2SV_StartBug> net_get_random_once ( & ip6_idents_hashrnd , sizeof ( ip6_idents_hashrnd ) ) ; <S2SV_EndBug> hash = __ipv6_addr_jhash ( & rt -> rt6i_dst . addr , ip6_idents_hashrnd ) ; hash = __ipv6_addr_jhash ( & rt -> rt6i_src . addr , hash ) ; <S2SV_StartBug> id = ip_idents_reserve ( hash , 1 ) ; <S2SV_EndBug> fhdr -> identification = htonl ( id ) ; }
","<S2SV_ModStart> ip6_idents_hashrnd __read_mostly ; static u32 ip6_idents_hashrnd_extra __read_mostly ; <S2SV_ModStart> sizeof ( ip6_idents_hashrnd ) ) ; net_get_random_once ( & ip6_idents_hashrnd_extra , sizeof ( ip6_idents_hashrnd_extra <S2SV_ModStart> hash ) ; hash = jhash_1word ( hash , ip6_idents_hashrnd_extra ) ;
"
62,"CWE-125 void bootp_print ( netdissect_options * ndo , register const u_char * cp , u_int length ) { register const struct bootp * bp ; static const u_char vm_cmu [ 4 ] = VM_CMU ; static const u_char vm_rfc1048 [ 4 ] = VM_RFC1048 ; bp = ( const struct bootp * ) cp ; ND_TCHECK ( bp -> bp_op ) ; ND_PRINT ( ( ndo , ""BOOTP/DHCP,<S2SV_blank>%s"" , tok2str ( bootp_op_values , ""unknown<S2SV_blank>(0x%02x)"" , bp -> bp_op ) ) ) ; ND_TCHECK ( bp -> bp_hlen ) ; if ( bp -> bp_htype == 1 && bp -> bp_hlen == 6 && bp -> bp_op == BOOTPREQUEST ) { ND_TCHECK2 ( bp -> bp_chaddr [ 0 ] , 6 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>from<S2SV_blank>%s"" , etheraddr_string ( ndo , bp -> bp_chaddr ) ) ) ; } ND_PRINT ( ( ndo , "",<S2SV_blank>length<S2SV_blank>%u"" , length ) ) ; if ( ! ndo -> ndo_vflag ) return ; ND_TCHECK ( bp -> bp_secs ) ; if ( bp -> bp_htype != 1 ) ND_PRINT ( ( ndo , "",<S2SV_blank>htype<S2SV_blank>%d"" , bp -> bp_htype ) ) ; if ( bp -> bp_htype != 1 || bp -> bp_hlen != 6 ) ND_PRINT ( ( ndo , "",<S2SV_blank>hlen<S2SV_blank>%d"" , bp -> bp_hlen ) ) ; if ( bp -> bp_hops ) ND_PRINT ( ( ndo , "",<S2SV_blank>hops<S2SV_blank>%d"" , bp -> bp_hops ) ) ; if ( EXTRACT_32BITS ( & bp -> bp_xid ) ) ND_PRINT ( ( ndo , "",<S2SV_blank>xid<S2SV_blank>0x%x"" , EXTRACT_32BITS ( & bp -> bp_xid ) ) ) ; if ( EXTRACT_16BITS ( & bp -> bp_secs ) ) ND_PRINT ( ( ndo , "",<S2SV_blank>secs<S2SV_blank>%d"" , EXTRACT_16BITS ( & bp -> bp_secs ) ) ) ; <S2SV_StartBug> ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s]"" , <S2SV_EndBug> bittok2str ( bootp_flag_values , ""none"" , EXTRACT_16BITS ( & bp -> bp_flags ) ) ) ) ; if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""<S2SV_blank>(0x%04x)"" , EXTRACT_16BITS ( & bp -> bp_flags ) ) ) ; ND_TCHECK ( bp -> bp_ciaddr ) ; if ( EXTRACT_32BITS ( & bp -> bp_ciaddr . s_addr ) ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Client-IP<S2SV_blank>%s"" , ipaddr_string ( ndo , & bp -> bp_ciaddr ) ) ) ; ND_TCHECK ( bp -> bp_yiaddr ) ; if ( EXTRACT_32BITS ( & bp -> bp_yiaddr . s_addr ) ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Your-IP<S2SV_blank>%s"" , ipaddr_string ( ndo , & bp -> bp_yiaddr ) ) ) ; ND_TCHECK ( bp -> bp_siaddr ) ; if ( EXTRACT_32BITS ( & bp -> bp_siaddr . s_addr ) ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Server-IP<S2SV_blank>%s"" , ipaddr_string ( ndo , & bp -> bp_siaddr ) ) ) ; ND_TCHECK ( bp -> bp_giaddr ) ; if ( EXTRACT_32BITS ( & bp -> bp_giaddr . s_addr ) ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Gateway-IP<S2SV_blank>%s"" , ipaddr_string ( ndo , & bp -> bp_giaddr ) ) ) ; if ( bp -> bp_htype == 1 && bp -> bp_hlen == 6 ) { ND_TCHECK2 ( bp -> bp_chaddr [ 0 ] , 6 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Client-Ethernet-Address<S2SV_blank>%s"" , etheraddr_string ( ndo , bp -> bp_chaddr ) ) ) ; } ND_TCHECK2 ( bp -> bp_sname [ 0 ] , 1 ) ; if ( * bp -> bp_sname ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>sname<S2SV_blank>\\"""" ) ) ; if ( fn_printztn ( ndo , bp -> bp_sname , ( u_int ) sizeof bp -> bp_sname , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; ND_PRINT ( ( ndo , ""%s"" , tstr + 1 ) ) ; return ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } ND_TCHECK2 ( bp -> bp_file [ 0 ] , 1 ) ; if ( * bp -> bp_file ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>file<S2SV_blank>\\"""" ) ) ; if ( fn_printztn ( ndo , bp -> bp_file , ( u_int ) sizeof bp -> bp_file , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; ND_PRINT ( ( ndo , ""%s"" , tstr + 1 ) ) ; return ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } ND_TCHECK ( bp -> bp_vend [ 0 ] ) ; if ( memcmp ( ( const char * ) bp -> bp_vend , vm_rfc1048 , sizeof ( uint32_t ) ) == 0 ) rfc1048_print ( ndo , bp -> bp_vend ) ; else if ( memcmp ( ( const char * ) bp -> bp_vend , vm_cmu , sizeof ( uint32_t ) ) == 0 ) cmu_print ( ndo , bp -> bp_vend ) ; else { uint32_t ul ; ul = EXTRACT_32BITS ( & bp -> bp_vend ) ; if ( ul != 0 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Vendor-#0x%x"" , ul ) ) ; } return ; trunc : ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; }
","<S2SV_ModStart> ) ) ; ND_TCHECK ( bp -> bp_flags ) ;
"
63,"CWE-476 BOOL security_decrypt ( BYTE * data , int length , rdpRdp * rdp ) <S2SV_StartBug> { <S2SV_EndBug> if ( rdp -> decrypt_use_count >= 4096 ) { security_key_update ( rdp -> decrypt_key , rdp -> decrypt_update_key , rdp -> rc4_key_len ) ; crypto_rc4_free ( rdp -> rc4_decrypt_key ) ; rdp -> rc4_decrypt_key = crypto_rc4_init ( rdp -> decrypt_key , rdp -> rc4_key_len ) ; rdp -> decrypt_use_count = 0 ; } crypto_rc4 ( rdp -> rc4_decrypt_key , length , data , data ) ; rdp -> decrypt_use_count += 1 ; rdp -> decrypt_checksum_use_count ++ ; return TRUE ; }
","<S2SV_ModStart> rdp ) { if ( rdp -> rc4_decrypt_key == NULL ) return FALSE ;
"
64,"CWE-399 static int dcbnl_ieee_fill ( struct sk_buff * skb , struct net_device * netdev ) { struct nlattr * ieee , * app ; struct dcb_app_type * itr ; const struct dcbnl_rtnl_ops * ops = netdev -> dcbnl_ops ; int dcbx ; int err ; if ( nla_put_string ( skb , DCB_ATTR_IFNAME , netdev -> name ) ) return - EMSGSIZE ; ieee = nla_nest_start ( skb , DCB_ATTR_IEEE ) ; if ( ! ieee ) return - EMSGSIZE ; if ( ops -> ieee_getets ) { struct ieee_ets ets ; <S2SV_StartBug> err = ops -> ieee_getets ( netdev , & ets ) ; <S2SV_EndBug> if ( ! err && nla_put ( skb , DCB_ATTR_IEEE_ETS , sizeof ( ets ) , & ets ) ) return - EMSGSIZE ; } if ( ops -> ieee_getmaxrate ) { struct ieee_maxrate maxrate ; <S2SV_StartBug> err = ops -> ieee_getmaxrate ( netdev , & maxrate ) ; <S2SV_EndBug> if ( ! err ) { err = nla_put ( skb , DCB_ATTR_IEEE_MAXRATE , sizeof ( maxrate ) , & maxrate ) ; if ( err ) return - EMSGSIZE ; } } if ( ops -> ieee_getpfc ) { <S2SV_StartBug> struct ieee_pfc pfc ; <S2SV_EndBug> err = ops -> ieee_getpfc ( netdev , & pfc ) ; if ( ! err && nla_put ( skb , DCB_ATTR_IEEE_PFC , sizeof ( pfc ) , & pfc ) ) return - EMSGSIZE ; } app = nla_nest_start ( skb , DCB_ATTR_IEEE_APP_TABLE ) ; if ( ! app ) return - EMSGSIZE ; spin_lock ( & dcb_lock ) ; list_for_each_entry ( itr , & dcb_app_list , list ) { if ( itr -> ifindex == netdev -> ifindex ) { err = nla_put ( skb , DCB_ATTR_IEEE_APP , sizeof ( itr -> app ) , & itr -> app ) ; if ( err ) { spin_unlock ( & dcb_lock ) ; return - EMSGSIZE ; } } } if ( netdev -> dcbnl_ops -> getdcbx ) dcbx = netdev -> dcbnl_ops -> getdcbx ( netdev ) ; else dcbx = - EOPNOTSUPP ; spin_unlock ( & dcb_lock ) ; nla_nest_end ( skb , app ) ; if ( ops -> ieee_peer_getets ) { struct ieee_ets ets ; <S2SV_StartBug> err = ops -> ieee_peer_getets ( netdev , & ets ) ; <S2SV_EndBug> if ( ! err && nla_put ( skb , DCB_ATTR_IEEE_PEER_ETS , sizeof ( ets ) , & ets ) ) return - EMSGSIZE ; } if ( ops -> ieee_peer_getpfc ) { <S2SV_StartBug> struct ieee_pfc pfc ; <S2SV_EndBug> err = ops -> ieee_peer_getpfc ( netdev , & pfc ) ; if ( ! err && nla_put ( skb , DCB_ATTR_IEEE_PEER_PFC , sizeof ( pfc ) , & pfc ) ) return - EMSGSIZE ; } if ( ops -> peer_getappinfo && ops -> peer_getapptable ) { err = dcbnl_build_peer_app ( netdev , skb , DCB_ATTR_IEEE_PEER_APP , DCB_ATTR_IEEE_APP_UNSPEC , DCB_ATTR_IEEE_APP ) ; if ( err ) return - EMSGSIZE ; } nla_nest_end ( skb , ieee ) ; if ( dcbx >= 0 ) { err = nla_put_u8 ( skb , DCB_ATTR_DCBX , dcbx ) ; if ( err ) return - EMSGSIZE ; } return 0 ; }
","<S2SV_ModStart> ieee_ets ets ; memset ( & ets , 0 , sizeof ( ets ) ) ; <S2SV_ModStart> ieee_maxrate maxrate ; memset ( & maxrate , 0 , sizeof ( maxrate ) ) ; <S2SV_ModStart> struct ieee_pfc pfc ; memset ( & pfc , 0 , sizeof ( pfc ) ) <S2SV_ModStart> ieee_ets ets ; memset ( & ets , 0 , sizeof ( ets ) ) ; <S2SV_ModStart> struct ieee_pfc pfc ; memset ( & pfc , 0 , sizeof ( pfc ) )
"
65,"CWE-284 static int tap_if_down ( const char * devname ) { struct ifreq ifr ; int sk ; sk = socket ( AF_INET , SOCK_DGRAM , 0 ) ; if ( sk < 0 ) return - 1 ; memset ( & ifr , 0 , sizeof ( ifr ) ) ; strncpy ( ifr . ifr_name , devname , IF_NAMESIZE - 1 ) ; ifr . ifr_flags &= ~ IFF_UP ; <S2SV_StartBug> ioctl ( sk , SIOCSIFFLAGS , ( caddr_t ) & ifr ) ; <S2SV_EndBug> close ( sk ) ; return 0 ; }
","<S2SV_ModStart> ~ IFF_UP ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) & ifr )
"
66,"CWE-362 static void create_watching_parent ( void ) { pid_t child ; sigset_t ourset ; struct sigaction oldact [ 3 ] ; int status = 0 ; int retval ; retval = pam_open_session ( pamh , 0 ) ; if ( is_pam_failure ( retval ) ) { cleanup_pam ( retval ) ; errx ( EXIT_FAILURE , _ ( ""cannot<S2SV_blank>open<S2SV_blank>session:<S2SV_blank>%s"" ) , pam_strerror ( pamh , retval ) ) ; } else _pam_session_opened = 1 ; memset ( oldact , 0 , sizeof ( oldact ) ) ; child = fork ( ) ; if ( child == ( pid_t ) - 1 ) { cleanup_pam ( PAM_ABORT ) ; err ( EXIT_FAILURE , _ ( ""cannot<S2SV_blank>create<S2SV_blank>child<S2SV_blank>process"" ) ) ; } if ( child == 0 ) return ; if ( chdir ( ""/"" ) != 0 ) warn ( _ ( ""cannot<S2SV_blank>change<S2SV_blank>directory<S2SV_blank>to<S2SV_blank>%s"" ) , ""/"" ) ; sigfillset ( & ourset ) ; if ( sigprocmask ( SIG_BLOCK , & ourset , NULL ) ) { warn ( _ ( ""cannot<S2SV_blank>block<S2SV_blank>signals"" ) ) ; caught_signal = true ; } if ( ! caught_signal ) { struct sigaction action ; action . sa_handler = su_catch_sig ; sigemptyset ( & action . sa_mask ) ; action . sa_flags = 0 ; sigemptyset ( & ourset ) ; if ( ! same_session ) { if ( sigaddset ( & ourset , SIGINT ) || sigaddset ( & ourset , SIGQUIT ) ) { warn ( _ ( ""cannot<S2SV_blank>set<S2SV_blank>signal<S2SV_blank>handler"" ) ) ; caught_signal = true ; } } if ( ! caught_signal && ( sigaddset ( & ourset , SIGTERM ) || sigaddset ( & ourset , SIGALRM ) || sigaction ( SIGTERM , & action , & oldact [ 0 ] ) || sigprocmask ( SIG_UNBLOCK , & ourset , NULL ) ) ) { warn ( _ ( ""cannot<S2SV_blank>set<S2SV_blank>signal<S2SV_blank>handler"" ) ) ; caught_signal = true ; } if ( ! caught_signal && ! same_session && ( sigaction ( SIGINT , & action , & oldact [ 1 ] ) || sigaction ( SIGQUIT , & action , & oldact [ 2 ] ) ) ) { warn ( _ ( ""cannot<S2SV_blank>set<S2SV_blank>signal<S2SV_blank>handler"" ) ) ; caught_signal = true ; } } if ( ! caught_signal ) { pid_t pid ; for ( ; ; ) { pid = waitpid ( child , & status , WUNTRACED ) ; if ( pid != ( pid_t ) - 1 && WIFSTOPPED ( status ) ) { kill ( getpid ( ) , SIGSTOP ) ; kill ( pid , SIGCONT ) ; } else break ; } if ( pid != ( pid_t ) - 1 ) { if ( WIFSIGNALED ( status ) ) { fprintf ( stderr , ""%s%s\\n"" , strsignal ( WTERMSIG ( status ) ) , WCOREDUMP ( status ) ? _ ( ""<S2SV_blank>(core<S2SV_blank>dumped)"" ) : """" ) ; status = WTERMSIG ( status ) + 128 ; } else status = WEXITSTATUS ( status ) ; <S2SV_StartBug> } <S2SV_EndBug> else if ( caught_signal ) status = caught_signal + 128 ; else status = 1 ; } else status = 1 ; <S2SV_StartBug> if ( caught_signal ) <S2SV_EndBug> { fprintf ( stderr , _ ( ""\\nSession<S2SV_blank>terminated,<S2SV_blank>killing<S2SV_blank>shell..."" ) ) ; kill ( child , SIGTERM ) ; } cleanup_pam ( PAM_SUCCESS ) ; if ( caught_signal ) { <S2SV_StartBug> sleep ( 2 ) ; <S2SV_EndBug> kill ( child , SIGKILL ) ; <S2SV_StartBug> fprintf ( stderr , _ ( ""<S2SV_blank>...killed.\\n"" ) ) ; <S2SV_EndBug> switch ( caught_signal ) { case SIGTERM : sigaction ( SIGTERM , & oldact [ 0 ] , NULL ) ; break ; case SIGINT : sigaction ( SIGINT , & oldact [ 1 ] , NULL ) ; break ; case SIGQUIT : sigaction ( SIGQUIT , & oldact [ 2 ] , NULL ) ; break ; default : caught_signal = SIGKILL ; break ; } kill ( getpid ( ) , caught_signal ) ; } exit ( status ) ; }
","<S2SV_ModStart> status ) ; child = ( pid_t ) - 1 ; <S2SV_ModStart> if ( caught_signal && child != ( pid_t ) - 1 <S2SV_ModStart> caught_signal ) { if ( child != ( pid_t ) - 1 ) { <S2SV_ModStart> ) ) ; }
"
67,"CWE-20 static int parse_rock_ridge_inode_internal ( struct iso_directory_record * de , <S2SV_StartBug> struct inode * inode , int regard_xa ) <S2SV_EndBug> { int symlink_len = 0 ; <S2SV_StartBug> int cnt , sig ; <S2SV_EndBug> struct inode * reloc ; struct rock_ridge * rr ; int rootflag ; struct rock_state rs ; int ret = 0 ; if ( ! ISOFS_SB ( inode -> i_sb ) -> s_rock ) return 0 ; init_rock_state ( & rs , inode ) ; setup_rock_ridge ( de , inode , & rs ) ; <S2SV_StartBug> if ( regard_xa ) { <S2SV_EndBug> rs . chr += 14 ; rs . len -= 14 ; if ( rs . len < 0 ) rs . len = 0 ; } repeat : while ( rs . len > 2 ) { rr = ( struct rock_ridge * ) rs . chr ; if ( rr -> len < 3 ) goto out ; sig = isonum_721 ( rs . chr ) ; if ( rock_check_overflow ( & rs , sig ) ) goto eio ; rs . chr += rr -> len ; rs . len -= rr -> len ; if ( rs . len < 0 ) goto out ; switch ( sig ) { # ifndef CONFIG_ZISOFS case SIG ( 'R' , 'R' ) : if ( ( rr -> u . RR . flags [ 0 ] & ( RR_PX | RR_TF | RR_SL | RR_CL ) ) == 0 ) goto out ; break ; # endif case SIG ( 'S' , 'P' ) : if ( check_sp ( rr , inode ) ) goto out ; break ; case SIG ( 'C' , 'E' ) : rs . cont_extent = isonum_733 ( rr -> u . CE . extent ) ; rs . cont_offset = isonum_733 ( rr -> u . CE . offset ) ; rs . cont_size = isonum_733 ( rr -> u . CE . size ) ; break ; case SIG ( 'E' , 'R' ) : ISOFS_SB ( inode -> i_sb ) -> s_rock = 1 ; printk ( KERN_DEBUG ""ISO<S2SV_blank>9660<S2SV_blank>Extensions:<S2SV_blank>"" ) ; { int p ; for ( p = 0 ; p < rr -> u . ER . len_id ; p ++ ) printk ( ""%c"" , rr -> u . ER . data [ p ] ) ; } printk ( ""\\n"" ) ; break ; case SIG ( 'P' , 'X' ) : inode -> i_mode = isonum_733 ( rr -> u . PX . mode ) ; set_nlink ( inode , isonum_733 ( rr -> u . PX . n_links ) ) ; i_uid_write ( inode , isonum_733 ( rr -> u . PX . uid ) ) ; i_gid_write ( inode , isonum_733 ( rr -> u . PX . gid ) ) ; break ; case SIG ( 'P' , 'N' ) : { int high , low ; high = isonum_733 ( rr -> u . PN . dev_high ) ; low = isonum_733 ( rr -> u . PN . dev_low ) ; if ( ( low & ~ 0xff ) && high == 0 ) { inode -> i_rdev = MKDEV ( low >> 8 , low & 0xff ) ; } else { inode -> i_rdev = MKDEV ( high , low ) ; } } break ; case SIG ( 'T' , 'F' ) : cnt = 0 ; if ( rr -> u . TF . flags & TF_CREATE ) { inode -> i_ctime . tv_sec = iso_date ( rr -> u . TF . times [ cnt ++ ] . time , 0 ) ; inode -> i_ctime . tv_nsec = 0 ; } if ( rr -> u . TF . flags & TF_MODIFY ) { inode -> i_mtime . tv_sec = iso_date ( rr -> u . TF . times [ cnt ++ ] . time , 0 ) ; inode -> i_mtime . tv_nsec = 0 ; } if ( rr -> u . TF . flags & TF_ACCESS ) { inode -> i_atime . tv_sec = iso_date ( rr -> u . TF . times [ cnt ++ ] . time , 0 ) ; inode -> i_atime . tv_nsec = 0 ; } if ( rr -> u . TF . flags & TF_ATTRIBUTES ) { inode -> i_ctime . tv_sec = iso_date ( rr -> u . TF . times [ cnt ++ ] . time , 0 ) ; inode -> i_ctime . tv_nsec = 0 ; } break ; case SIG ( 'S' , 'L' ) : { int slen ; struct SL_component * slp ; struct SL_component * oldslp ; slen = rr -> len - 5 ; slp = & rr -> u . SL . link ; inode -> i_size = symlink_len ; while ( slen > 1 ) { rootflag = 0 ; switch ( slp -> flags & ~ 1 ) { case 0 : inode -> i_size += slp -> len ; break ; case 2 : inode -> i_size += 1 ; break ; case 4 : inode -> i_size += 2 ; break ; case 8 : rootflag = 1 ; inode -> i_size += 1 ; break ; default : printk ( ""Symlink<S2SV_blank>component<S2SV_blank>flag<S2SV_blank>"" ""not<S2SV_blank>implemented\\n"" ) ; } slen -= slp -> len + 2 ; oldslp = slp ; slp = ( struct SL_component * ) ( ( ( char * ) slp ) + slp -> len + 2 ) ; if ( slen < 2 ) { if ( ( ( rr -> u . SL . flags & 1 ) != 0 ) && ( ( oldslp -> flags & 1 ) == 0 ) ) inode -> i_size += 1 ; break ; } if ( ! rootflag && ( oldslp -> flags & 1 ) == 0 ) inode -> i_size += 1 ; } } symlink_len = inode -> i_size ; break ; case SIG ( 'R' , 'E' ) : printk ( KERN_WARNING ""Attempt<S2SV_blank>to<S2SV_blank>read<S2SV_blank>inode<S2SV_blank>for<S2SV_blank>"" ""relocated<S2SV_blank>directory\\n"" ) ; goto out ; case SIG ( 'C' , 'L' ) : <S2SV_StartBug> ISOFS_I ( inode ) -> i_first_extent = <S2SV_EndBug> isonum_733 ( rr -> u . CL . location ) ; reloc = <S2SV_StartBug> isofs_iget ( inode -> i_sb , <S2SV_EndBug> <S2SV_StartBug> ISOFS_I ( inode ) -> i_first_extent , <S2SV_EndBug> 0 ) ; if ( IS_ERR ( reloc ) ) { ret = PTR_ERR ( reloc ) ; goto out ; } inode -> i_mode = reloc -> i_mode ; set_nlink ( inode , reloc -> i_nlink ) ; inode -> i_uid = reloc -> i_uid ; inode -> i_gid = reloc -> i_gid ; inode -> i_rdev = reloc -> i_rdev ; inode -> i_size = reloc -> i_size ; inode -> i_blocks = reloc -> i_blocks ; inode -> i_atime = reloc -> i_atime ; inode -> i_ctime = reloc -> i_ctime ; inode -> i_mtime = reloc -> i_mtime ; iput ( reloc ) ; break ; # ifdef CONFIG_ZISOFS case SIG ( 'Z' , 'F' ) : { int algo ; if ( ISOFS_SB ( inode -> i_sb ) -> s_nocompress ) break ; algo = isonum_721 ( rr -> u . ZF . algorithm ) ; if ( algo == SIG ( 'p' , 'z' ) ) { int block_shift = isonum_711 ( & rr -> u . ZF . parms [ 1 ] ) ; if ( block_shift > 17 ) { printk ( KERN_WARNING ""isofs:<S2SV_blank>"" ""Can\'t<S2SV_blank>handle<S2SV_blank>ZF<S2SV_blank>block<S2SV_blank>"" ""size<S2SV_blank>of<S2SV_blank>2^%d\\n"" , block_shift ) ; } else { ISOFS_I ( inode ) -> i_file_format = isofs_file_compressed ; ISOFS_I ( inode ) -> i_format_parm [ 0 ] = isonum_711 ( & rr -> u . ZF . parms [ 0 ] ) ; ISOFS_I ( inode ) -> i_format_parm [ 1 ] = isonum_711 ( & rr -> u . ZF . parms [ 1 ] ) ; inode -> i_size = isonum_733 ( rr -> u . ZF . real_size ) ; } } else { printk ( KERN_WARNING ""isofs:<S2SV_blank>Unknown<S2SV_blank>ZF<S2SV_blank>compression<S2SV_blank>"" ""algorithm:<S2SV_blank>%c%c\\n"" , rr -> u . ZF . algorithm [ 0 ] , rr -> u . ZF . algorithm [ 1 ] ) ; } break ; } # endif default : break ; } } ret = rock_continue ( & rs ) ; if ( ret == 0 ) goto repeat ; if ( ret == 1 ) ret = 0 ; out : kfree ( rs . buffer ) ; return ret ; eio : ret = - EIO ; goto out ; }
","<S2SV_ModStart> inode , int flags <S2SV_ModEnd> ) { int <S2SV_ModStart> cnt , sig ; unsigned int reloc_block <S2SV_ModStart> ; if ( flags & RR_REGARD_XA <S2SV_ModEnd> ) { rs <S2SV_ModStart> 'L' ) : if ( flags & RR_RELOC_DE ) { printk ( KERN_ERR ""ISOFS:<S2SV_blank>Recursive<S2SV_blank>directory<S2SV_blank>relocation<S2SV_blank>"" ""is<S2SV_blank>not<S2SV_blank>supported\\n"" ) ; goto eio ; } reloc_block = isonum_733 ( rr -> u . CL . location ) ; if ( reloc_block == <S2SV_ModStart> inode ) -> i_iget5_block && ISOFS_I ( inode ) -> i_iget5_offset == 0 ) { printk ( KERN_ERR ""ISOFS:<S2SV_blank>Directory<S2SV_blank>relocation<S2SV_blank>points<S2SV_blank>to<S2SV_blank>"" ""itself\\n"" ) ; goto eio ; } ISOFS_I ( inode ) -> i_first_extent = reloc_block <S2SV_ModEnd> ; reloc = <S2SV_ModStart> ; reloc = isofs_iget_reloc <S2SV_ModEnd> ( inode -> <S2SV_ModStart> -> i_sb , reloc_block , <S2SV_ModEnd> 0 ) ;
"
68,"CWE-476 void pdo_stmt_init ( TSRMLS_D ) { zend_class_entry ce ; INIT_CLASS_ENTRY ( ce , ""PDOStatement"" , pdo_dbstmt_functions ) ; pdo_dbstmt_ce = zend_register_internal_class ( & ce TSRMLS_CC ) ; pdo_dbstmt_ce -> get_iterator = pdo_stmt_iter_get ; pdo_dbstmt_ce -> create_object = pdo_dbstmt_new ; zend_class_implements ( pdo_dbstmt_ce TSRMLS_CC , 1 , zend_ce_traversable ) ; zend_declare_property_null ( pdo_dbstmt_ce , ""queryString"" , sizeof ( ""queryString"" ) - 1 , ZEND_ACC_PUBLIC TSRMLS_CC ) ; memcpy ( & pdo_dbstmt_object_handlers , & std_object_handlers , sizeof ( zend_object_handlers ) ) ; pdo_dbstmt_object_handlers . write_property = dbstmt_prop_write ; pdo_dbstmt_object_handlers . unset_property = dbstmt_prop_delete ; pdo_dbstmt_object_handlers . get_method = dbstmt_method_get ; pdo_dbstmt_object_handlers . compare_objects = dbstmt_compare ; pdo_dbstmt_object_handlers . clone_obj = dbstmt_clone_obj ; INIT_CLASS_ENTRY ( ce , ""PDORow"" , pdo_row_functions ) ; pdo_row_ce = zend_register_internal_class ( & ce TSRMLS_CC ) ; pdo_row_ce -> ce_flags |= ZEND_ACC_FINAL_CLASS ; pdo_row_ce -> create_object = pdo_row_new ; pdo_row_ce -> serialize = pdo_row_serialize ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> = pdo_row_serialize ; pdo_row_ce -> unserialize = zend_class_unserialize_deny ;
"
69,"CWE-119 char * _single_string_alloc_and_copy ( LPCWSTR in ) { char * chr ; int len = 0 ; if ( ! in ) { <S2SV_StartBug> return in ; <S2SV_EndBug> } while ( in [ len ] != 0 ) { len ++ ; } chr = malloc ( len + 1 ) ; len = 0 ; while ( in [ len ] != 0 ) { chr [ len ] = 0xFF & in [ len ] ; len ++ ; } chr [ len ++ ] = '\\0' ; return chr ; }
","<S2SV_ModStart> ) { return NULL <S2SV_ModEnd> ; } while
"
70,"CWE-416 static void regulator_ena_gpio_free ( struct regulator_dev * rdev ) { struct regulator_enable_gpio * pin , * n ; if ( ! rdev -> ena_pin ) return ; list_for_each_entry_safe ( pin , n , & regulator_ena_gpio_list , list ) { if ( pin -> gpiod == rdev -> ena_pin -> gpiod ) { if ( pin -> request_count <= 1 ) { pin -> request_count = 0 ; gpiod_put ( pin -> gpiod ) ; list_del ( & pin -> list ) ; kfree ( pin ) ; <S2SV_StartBug> } else { <S2SV_EndBug> pin -> request_count -- ; } } } }
","<S2SV_ModStart> pin ) ; rdev -> ena_pin = NULL ; return ;
"
71,"CWE-200 static void llc_cmsg_rcv ( struct msghdr * msg , struct sk_buff * skb ) { struct llc_sock * llc = llc_sk ( skb -> sk ) ; if ( llc -> cmsg_flags & LLC_CMSG_PKTINFO ) { <S2SV_StartBug> struct llc_pktinfo info ; <S2SV_EndBug> info . lpi_ifindex = llc_sk ( skb -> sk ) -> dev -> ifindex ; llc_pdu_decode_dsap ( skb , & info . lpi_sap ) ; llc_pdu_decode_da ( skb , info . lpi_mac ) ; put_cmsg ( msg , SOL_LLC , LLC_OPT_PKTINFO , sizeof ( info ) , & info ) ; } }
","<S2SV_ModStart> struct llc_pktinfo info ; memset ( & info , 0 , sizeof ( info ) )
"
72,"CWE-20 bool_t dm9000IrqHandler ( NetInterface * interface ) { bool_t flag ; uint8_t status ; uint8_t mask ; Dm9000Context * context ; flag = FALSE ; context = ( Dm9000Context * ) interface -> nicContext ; <S2SV_StartBug> status = dm9000ReadReg ( DM9000_REG_ISR ) ; <S2SV_EndBug> if ( ( status & ISR_LNKCHG ) != 0 ) { mask = dm9000ReadReg ( DM9000_REG_IMR ) ; <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_IMR , mask & ~ IMR_LNKCHGI ) ; <S2SV_EndBug> interface -> nicEvent = TRUE ; flag |= osSetEventFromIsr ( & netEvent ) ; } <S2SV_StartBug> if ( ( status & ISR_PT ) != 0 ) <S2SV_EndBug> { if ( dm9000ReadReg ( DM9000_REG_NSR ) & ( NSR_TX2END | NSR_TX1END ) ) { if ( context -> queuedPackets > 0 ) { context -> queuedPackets -- ; } flag |= osSetEventFromIsr ( & interface -> nicTxEvent ) ; } <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_ISR , ISR_PT ) ; <S2SV_EndBug> } if ( ( status & ISR_PR ) != 0 ) { mask = dm9000ReadReg ( DM9000_REG_IMR ) ; <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_IMR , mask & ~ IMR_PRI ) ; <S2SV_EndBug> interface -> nicEvent = TRUE ; flag |= osSetEventFromIsr ( & netEvent ) ; } return flag ; }
","<S2SV_ModStart> = dm9000ReadReg ( DM9000_ISR ) ; if ( ( status & DM9000_ISR_LNKCHG ) != 0 ) { mask = dm9000ReadReg ( DM9000_IMR <S2SV_ModEnd> ) ; dm9000WriteReg <S2SV_ModStart> ; dm9000WriteReg ( DM9000_IMR <S2SV_ModEnd> , mask & <S2SV_ModStart> mask & ~ DM9000_IMR_LNKCHGI <S2SV_ModEnd> ) ; interface <S2SV_ModStart> ( status & DM9000_ISR_PT ) != 0 ) { if ( ( dm9000ReadReg ( DM9000_NSR ) & ( DM9000_NSR_TX2END | DM9000_NSR_TX1END ) ) != 0 <S2SV_ModEnd> ) { if <S2SV_ModStart> } dm9000WriteReg ( DM9000_ISR , DM9000_ISR_PT ) ; } if ( ( status & DM9000_ISR_PR ) != 0 ) { mask = dm9000ReadReg ( DM9000_IMR <S2SV_ModEnd> ) ; dm9000WriteReg <S2SV_ModStart> ; dm9000WriteReg ( DM9000_IMR <S2SV_ModEnd> , mask & <S2SV_ModStart> mask & ~ DM9000_IMR_PRI <S2SV_ModEnd> ) ; interface
"
73,"CWE-119 <S2SV_StartBug> void validate_positive_rational ( const char * msg , <S2SV_EndBug> struct vpx_rational * rat ) { if ( rat -> den < 0 ) { rat -> num *= - 1 ; rat -> den *= - 1 ; } if ( rat -> num < 0 ) die ( ""Error:<S2SV_blank>%s<S2SV_blank>must<S2SV_blank>be<S2SV_blank>positive\\n"" , msg ) ; if ( ! rat -> den ) die ( ""Error:<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>zero<S2SV_blank>denominator\\n"" , msg ) ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
"
74,"CWE-119 static void t1_check_unusual_charstring ( void ) { char * p = strstr ( t1_line_array , charstringname ) + strlen ( charstringname ) ; int i ; if ( sscanf ( p , ""%i"" , & i ) != 1 ) { strcpy ( t1_buf_array , t1_line_array ) ; * ( strend ( t1_buf_array ) - 1 ) = '<S2SV_blank>' ; t1_getline ( ) ; <S2SV_StartBug> strcat ( t1_buf_array , t1_line_array ) ; <S2SV_EndBug> strcpy ( t1_line_array , t1_buf_array ) ; t1_line_ptr = eol ( t1_line_array ) ; } }
","<S2SV_ModStart> ( ) ; alloc_array ( t1_buf , strlen ( t1_line_array ) + strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ; <S2SV_ModStart> t1_buf_array , t1_line_array ) ; alloc_array ( t1_line , strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE
"
75,"CWE-835 static void gsm_xsmp_client_disconnect ( GsmXSMPClient * client ) { if ( client -> priv -> watch_id > 0 ) { g_source_remove ( client -> priv -> watch_id ) ; } if ( client -> priv -> conn != NULL ) { SmsCleanUp ( client -> priv -> conn ) ; } if ( client -> priv -> ice_connection != NULL ) { IceSetShutdownNegotiation ( client -> priv -> ice_connection , FALSE ) ; IceCloseConnection ( client -> priv -> ice_connection ) ; } <S2SV_StartBug> if ( client -> priv -> protocol_timeout > 0 ) { <S2SV_EndBug> g_source_remove ( client -> priv -> protocol_timeout ) ; } }
","<S2SV_ModStart> ) ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
"
76,"CWE-125 void pgm_print ( netdissect_options * ndo , register const u_char * bp , register u_int length , register const u_char * bp2 ) { register const struct pgm_header * pgm ; register const struct ip * ip ; register char ch ; uint16_t sport , dport ; u_int nla_afnum ; char nla_buf [ INET6_ADDRSTRLEN ] ; register const struct ip6_hdr * ip6 ; uint8_t opt_type , opt_len ; uint32_t seq , opts_len , len , offset ; pgm = ( const struct pgm_header * ) bp ; ip = ( const struct ip * ) bp2 ; if ( IP_V ( ip ) == 6 ) ip6 = ( const struct ip6_hdr * ) bp2 ; else ip6 = NULL ; ch = '\\0' ; if ( ! ND_TTEST ( pgm -> pgm_dport ) ) { if ( ip6 ) { ND_PRINT ( ( ndo , ""%s<S2SV_blank>><S2SV_blank>%s:<S2SV_blank>[|pgm]"" , ip6addr_string ( ndo , & ip6 -> ip6_src ) , ip6addr_string ( ndo , & ip6 -> ip6_dst ) ) ) ; return ; } else { ND_PRINT ( ( ndo , ""%s<S2SV_blank>><S2SV_blank>%s:<S2SV_blank>[|pgm]"" , ipaddr_string ( ndo , & ip -> ip_src ) , ipaddr_string ( ndo , & ip -> ip_dst ) ) ) ; return ; } } sport = EXTRACT_16BITS ( & pgm -> pgm_sport ) ; dport = EXTRACT_16BITS ( & pgm -> pgm_dport ) ; if ( ip6 ) { if ( ip6 -> ip6_nxt == IPPROTO_PGM ) { ND_PRINT ( ( ndo , ""%s.%s<S2SV_blank>><S2SV_blank>%s.%s:<S2SV_blank>"" , ip6addr_string ( ndo , & ip6 -> ip6_src ) , tcpport_string ( ndo , sport ) , ip6addr_string ( ndo , & ip6 -> ip6_dst ) , tcpport_string ( ndo , dport ) ) ) ; } else { ND_PRINT ( ( ndo , ""%s<S2SV_blank>><S2SV_blank>%s:<S2SV_blank>"" , tcpport_string ( ndo , sport ) , tcpport_string ( ndo , dport ) ) ) ; } } else { if ( ip -> ip_p == IPPROTO_PGM ) { ND_PRINT ( ( ndo , ""%s.%s<S2SV_blank>><S2SV_blank>%s.%s:<S2SV_blank>"" , ipaddr_string ( ndo , & ip -> ip_src ) , tcpport_string ( ndo , sport ) , ipaddr_string ( ndo , & ip -> ip_dst ) , tcpport_string ( ndo , dport ) ) ) ; } else { ND_PRINT ( ( ndo , ""%s<S2SV_blank>><S2SV_blank>%s:<S2SV_blank>"" , tcpport_string ( ndo , sport ) , tcpport_string ( ndo , dport ) ) ) ; } } ND_TCHECK ( * pgm ) ; ND_PRINT ( ( ndo , ""PGM,<S2SV_blank>length<S2SV_blank>%u"" , EXTRACT_16BITS ( & pgm -> pgm_length ) ) ) ; if ( ! ndo -> ndo_vflag ) return ; ND_PRINT ( ( ndo , ""<S2SV_blank>0x%02x%02x%02x%02x%02x%02x<S2SV_blank>"" , pgm -> pgm_gsid [ 0 ] , pgm -> pgm_gsid [ 1 ] , pgm -> pgm_gsid [ 2 ] , pgm -> pgm_gsid [ 3 ] , pgm -> pgm_gsid [ 4 ] , pgm -> pgm_gsid [ 5 ] ) ) ; switch ( pgm -> pgm_type ) { case PGM_SPM : { const struct pgm_spm * spm ; spm = ( const struct pgm_spm * ) ( pgm + 1 ) ; ND_TCHECK ( * spm ) ; bp = ( const u_char * ) ( spm + 1 ) ; switch ( EXTRACT_16BITS ( & spm -> pgms_nla_afi ) ) { case AFNUM_INET : ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } ND_PRINT ( ( ndo , ""SPM<S2SV_blank>seq<S2SV_blank>%u<S2SV_blank>trail<S2SV_blank>%u<S2SV_blank>lead<S2SV_blank>%u<S2SV_blank>nla<S2SV_blank>%s"" , EXTRACT_32BITS ( & spm -> pgms_seq ) , EXTRACT_32BITS ( & spm -> pgms_trailseq ) , EXTRACT_32BITS ( & spm -> pgms_leadseq ) , nla_buf ) ) ; break ; } case PGM_POLL : { const struct pgm_poll * poll_msg ; poll_msg = ( const struct pgm_poll * ) ( pgm + 1 ) ; ND_TCHECK ( * poll_msg ) ; ND_PRINT ( ( ndo , ""POLL<S2SV_blank>seq<S2SV_blank>%u<S2SV_blank>round<S2SV_blank>%u"" , EXTRACT_32BITS ( & poll_msg -> pgmp_seq ) , EXTRACT_16BITS ( & poll_msg -> pgmp_round ) ) ) ; bp = ( const u_char * ) ( poll_msg + 1 ) ; break ; } case PGM_POLR : { const struct pgm_polr * polr ; uint32_t ivl , rnd , mask ; polr = ( const struct pgm_polr * ) ( pgm + 1 ) ; ND_TCHECK ( * polr ) ; bp = ( const u_char * ) ( polr + 1 ) ; switch ( EXTRACT_16BITS ( & polr -> pgmp_nla_afi ) ) { case AFNUM_INET : ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } ND_TCHECK2 ( * bp , sizeof ( uint32_t ) ) ; ivl = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_TCHECK2 ( * bp , sizeof ( uint32_t ) ) ; rnd = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_TCHECK2 ( * bp , sizeof ( uint32_t ) ) ; mask = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_PRINT ( ( ndo , ""POLR<S2SV_blank>seq<S2SV_blank>%u<S2SV_blank>round<S2SV_blank>%u<S2SV_blank>nla<S2SV_blank>%s<S2SV_blank>ivl<S2SV_blank>%u<S2SV_blank>rnd<S2SV_blank>0x%08x<S2SV_blank>"" ""mask<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( & polr -> pgmp_seq ) , EXTRACT_16BITS ( & polr -> pgmp_round ) , nla_buf , ivl , rnd , mask ) ) ; break ; } case PGM_ODATA : { const struct pgm_data * odata ; odata = ( const struct pgm_data * ) ( pgm + 1 ) ; ND_TCHECK ( * odata ) ; ND_PRINT ( ( ndo , ""ODATA<S2SV_blank>trail<S2SV_blank>%u<S2SV_blank>seq<S2SV_blank>%u"" , EXTRACT_32BITS ( & odata -> pgmd_trailseq ) , EXTRACT_32BITS ( & odata -> pgmd_seq ) ) ) ; bp = ( const u_char * ) ( odata + 1 ) ; break ; } case PGM_RDATA : { const struct pgm_data * rdata ; rdata = ( const struct pgm_data * ) ( pgm + 1 ) ; ND_TCHECK ( * rdata ) ; ND_PRINT ( ( ndo , ""RDATA<S2SV_blank>trail<S2SV_blank>%u<S2SV_blank>seq<S2SV_blank>%u"" , EXTRACT_32BITS ( & rdata -> pgmd_trailseq ) , EXTRACT_32BITS ( & rdata -> pgmd_seq ) ) ) ; bp = ( const u_char * ) ( rdata + 1 ) ; break ; } case PGM_NAK : case PGM_NULLNAK : case PGM_NCF : { const struct pgm_nak * nak ; char source_buf [ INET6_ADDRSTRLEN ] , group_buf [ INET6_ADDRSTRLEN ] ; nak = ( const struct pgm_nak * ) ( pgm + 1 ) ; ND_TCHECK ( * nak ) ; bp = ( const u_char * ) ( nak + 1 ) ; switch ( EXTRACT_16BITS ( & nak -> pgmn_source_afi ) ) { case AFNUM_INET : ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , source_buf , sizeof ( source_buf ) ) ; bp += sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , source_buf , sizeof ( source_buf ) ) ; bp += sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } bp += ( 2 * sizeof ( uint16_t ) ) ; switch ( EXTRACT_16BITS ( bp ) ) { case AFNUM_INET : ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , group_buf , sizeof ( group_buf ) ) ; bp += sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , group_buf , sizeof ( group_buf ) ) ; bp += sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } switch ( pgm -> pgm_type ) { case PGM_NAK : ND_PRINT ( ( ndo , ""NAK<S2SV_blank>"" ) ) ; break ; case PGM_NULLNAK : ND_PRINT ( ( ndo , ""NNAK<S2SV_blank>"" ) ) ; break ; case PGM_NCF : ND_PRINT ( ( ndo , ""NCF<S2SV_blank>"" ) ) ; break ; default : break ; } ND_PRINT ( ( ndo , ""(%s<S2SV_blank>-><S2SV_blank>%s),<S2SV_blank>seq<S2SV_blank>%u"" , source_buf , group_buf , EXTRACT_32BITS ( & nak -> pgmn_seq ) ) ) ; break ; } case PGM_ACK : { const struct pgm_ack * ack ; ack = ( const struct pgm_ack * ) ( pgm + 1 ) ; ND_TCHECK ( * ack ) ; ND_PRINT ( ( ndo , ""ACK<S2SV_blank>seq<S2SV_blank>%u"" , EXTRACT_32BITS ( & ack -> pgma_rx_max_seq ) ) ) ; bp = ( const u_char * ) ( ack + 1 ) ; break ; } case PGM_SPMR : ND_PRINT ( ( ndo , ""SPMR"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""UNKNOWN<S2SV_blank>type<S2SV_blank>0x%02x"" , pgm -> pgm_type ) ) ; break ; } if ( pgm -> pgm_options & PGM_OPT_BIT_PRESENT ) { if ( ! ND_TTEST2 ( * bp , PGM_MIN_OPT_LEN ) ) { ND_PRINT ( ( ndo , ""[|OPT]"" ) ) ; return ; } opt_type = * bp ++ ; if ( ( opt_type & PGM_OPT_MASK ) != PGM_OPT_LENGTH ) { ND_PRINT ( ( ndo , ""[First<S2SV_blank>option<S2SV_blank>bad,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>PGM_OPT_LENGTH,<S2SV_blank>is<S2SV_blank>%u]"" , opt_type & PGM_OPT_MASK ) ) ; return ; } opt_len = * bp ++ ; if ( opt_len != 4 ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_LENGTH<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>4]"" , opt_len ) ) ; return ; } opts_len = EXTRACT_16BITS ( bp ) ; if ( opts_len < 4 ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>total<S2SV_blank>option<S2SV_blank>length<S2SV_blank>%u<S2SV_blank><<S2SV_blank>4]"" , opts_len ) ) ; return ; } bp += sizeof ( uint16_t ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>OPTS<S2SV_blank>LEN<S2SV_blank>%d"" , opts_len ) ) ; opts_len -= 4 ; while ( opts_len ) { if ( opts_len < PGM_MIN_OPT_LEN ) { ND_PRINT ( ( ndo , ""[Total<S2SV_blank>option<S2SV_blank>length<S2SV_blank>leaves<S2SV_blank>no<S2SV_blank>room<S2SV_blank>for<S2SV_blank>final<S2SV_blank>option]"" ) ) ; return ; } if ( ! ND_TTEST2 ( * bp , 2 ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[|OPT]"" ) ) ; return ; } opt_type = * bp ++ ; opt_len = * bp ++ ; if ( opt_len < PGM_MIN_OPT_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%u]"" , opt_len , PGM_MIN_OPT_LEN ) ) ; break ; } if ( opts_len < opt_len ) { ND_PRINT ( ( ndo , ""[Total<S2SV_blank>option<S2SV_blank>length<S2SV_blank>leaves<S2SV_blank>no<S2SV_blank>room<S2SV_blank>for<S2SV_blank>final<S2SV_blank>option]"" ) ) ; return ; } if ( ! ND_TTEST2 ( * bp , opt_len - 2 ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[|OPT]"" ) ) ; return ; } switch ( opt_type & PGM_OPT_MASK ) { case PGM_OPT_LENGTH : <S2SV_StartBug> if ( opt_len != 4 ) { <S2SV_EndBug> ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_LENGTH<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>4]"" , opt_len ) ) ; return ; } <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>OPTS<S2SV_blank>LEN<S2SV_blank>(extra?)<S2SV_blank>%d"" , EXTRACT_16BITS ( bp ) ) ) ; <S2SV_EndBug> bp += sizeof ( uint16_t ) ; opts_len -= 4 ; <S2SV_StartBug> break ; <S2SV_EndBug> case PGM_OPT_FRAGMENT : <S2SV_StartBug> if ( opt_len != 16 ) { <S2SV_EndBug> ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_FRAGMENT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>16]"" , opt_len ) ) ; return ; } bp += 2 ; seq = EXTRACT_32BITS ( bp ) ; <S2SV_StartBug> bp += sizeof ( uint32_t ) ; <S2SV_EndBug> offset = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; len = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>FRAG<S2SV_blank>seq<S2SV_blank>%u<S2SV_blank>off<S2SV_blank>%u<S2SV_blank>len<S2SV_blank>%u"" , seq , offset , len ) ) ; <S2SV_StartBug> opts_len -= 16 ; <S2SV_EndBug> break ; case PGM_OPT_NAK_LIST : bp += 2 ; opt_len -= sizeof ( uint32_t ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>NAK<S2SV_blank>LIST"" ) ) ; while ( opt_len ) { <S2SV_StartBug> if ( opt_len < sizeof ( uint32_t ) ) { <S2SV_EndBug> ND_PRINT ( ( ndo , ""[Option<S2SV_blank>length<S2SV_blank>not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4]"" ) ) ; return ; } <S2SV_StartBug> ND_TCHECK2 ( * bp , sizeof ( uint32_t ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>%u"" , EXTRACT_32BITS ( bp ) ) ) ; <S2SV_EndBug> bp += sizeof ( uint32_t ) ; opt_len -= sizeof ( uint32_t ) ; <S2SV_StartBug> opts_len -= sizeof ( uint32_t ) ; <S2SV_EndBug> } break ; case PGM_OPT_JOIN : <S2SV_StartBug> if ( opt_len != 8 ) { <S2SV_EndBug> ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_JOIN<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>8]"" , opt_len ) ) ; return ; } bp += 2 ; <S2SV_StartBug> seq = EXTRACT_32BITS ( bp ) ; <S2SV_EndBug> <S2SV_StartBug> bp += sizeof ( uint32_t ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>JOIN<S2SV_blank>%u"" , seq ) ) ; <S2SV_StartBug> opts_len -= 8 ; <S2SV_EndBug> break ; case PGM_OPT_NAK_BO_IVL : <S2SV_StartBug> if ( opt_len != 12 ) { <S2SV_EndBug> ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_NAK_BO_IVL<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>12]"" , opt_len ) ) ; return ; } <S2SV_StartBug> bp += 2 ; <S2SV_EndBug> offset = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; seq = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>BACKOFF<S2SV_blank>ivl<S2SV_blank>%u<S2SV_blank>ivlseq<S2SV_blank>%u"" , offset , seq ) ) ; <S2SV_StartBug> opts_len -= 12 ; <S2SV_EndBug> break ; case PGM_OPT_NAK_BO_RNG : <S2SV_StartBug> if ( opt_len != 12 ) { <S2SV_EndBug> ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_NAK_BO_RNG<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>12]"" , opt_len ) ) ; return ; } <S2SV_StartBug> bp += 2 ; <S2SV_EndBug> offset = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; seq = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>BACKOFF<S2SV_blank>max<S2SV_blank>%u<S2SV_blank>min<S2SV_blank>%u"" , offset , seq ) ) ; <S2SV_StartBug> opts_len -= 12 ; <S2SV_EndBug> break ; case PGM_OPT_REDIRECT : bp += 2 ; nla_afnum = EXTRACT_16BITS ( bp ) ; bp += ( 2 * sizeof ( uint16_t ) ) ; switch ( nla_afnum ) { case AFNUM_INET : <S2SV_StartBug> if ( opt_len != 4 + sizeof ( struct in_addr ) ) { <S2SV_EndBug> ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_REDIRECT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>4<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; <S2SV_StartBug> opts_len -= 4 + sizeof ( struct in_addr ) ; <S2SV_EndBug> break ; case AFNUM_INET6 : <S2SV_StartBug> if ( opt_len != 4 + sizeof ( struct in6_addr ) ) { <S2SV_EndBug> ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_REDIRECT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>4<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; <S2SV_StartBug> opts_len -= 4 + sizeof ( struct in6_addr ) ; <S2SV_EndBug> break ; default : goto trunc ; break ; } <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>REDIRECT<S2SV_blank>%s"" , nla_buf ) ) ; <S2SV_EndBug> break ; <S2SV_StartBug> case PGM_OPT_PARITY_PRM : <S2SV_EndBug> <S2SV_StartBug> if ( opt_len != 8 ) { <S2SV_EndBug> ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PARITY_PRM<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>8]"" , opt_len ) ) ; return ; } <S2SV_StartBug> bp += 2 ; <S2SV_EndBug> len = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>PARITY<S2SV_blank>MAXTGS<S2SV_blank>%u"" , len ) ) ; <S2SV_StartBug> opts_len -= 8 ; <S2SV_EndBug> break ; case PGM_OPT_PARITY_GRP : <S2SV_StartBug> if ( opt_len != 8 ) { <S2SV_EndBug> ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PARITY_GRP<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>8]"" , opt_len ) ) ; return ; } <S2SV_StartBug> bp += 2 ; <S2SV_EndBug> seq = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>PARITY<S2SV_blank>GROUP<S2SV_blank>%u"" , seq ) ) ; <S2SV_StartBug> opts_len -= 8 ; <S2SV_EndBug> break ; case PGM_OPT_CURR_TGSIZE : if ( opt_len != 8 ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_CURR_TGSIZE<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>8]"" , opt_len ) ) ; return ; } bp += 2 ; len = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>PARITY<S2SV_blank>ATGS<S2SV_blank>%u"" , len ) ) ; opts_len -= 8 ; break ; case PGM_OPT_NBR_UNREACH : if ( opt_len != 4 ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_NBR_UNREACH<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>4]"" , opt_len ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>NBR_UNREACH"" ) ) ; opts_len -= 4 ; break ; case PGM_OPT_PATH_NLA : ND_PRINT ( ( ndo , ""<S2SV_blank>PATH_NLA<S2SV_blank>[%d]"" , opt_len ) ) ; bp += opt_len ; opts_len -= opt_len ; break ; case PGM_OPT_SYN : if ( opt_len != 4 ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_SYN<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>4]"" , opt_len ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>SYN"" ) ) ; opts_len -= 4 ; break ; case PGM_OPT_FIN : if ( opt_len != 4 ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_FIN<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>4]"" , opt_len ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>FIN"" ) ) ; opts_len -= 4 ; break ; case PGM_OPT_RST : if ( opt_len != 4 ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_RST<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>4]"" , opt_len ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>RST"" ) ) ; opts_len -= 4 ; break ; case PGM_OPT_CR : ND_PRINT ( ( ndo , ""<S2SV_blank>CR"" ) ) ; bp += opt_len ; opts_len -= opt_len ; break ; case PGM_OPT_CRQST : if ( opt_len != 4 ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_CRQST<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>4]"" , opt_len ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>CRQST"" ) ) ; opts_len -= 4 ; break ; case PGM_OPT_PGMCC_DATA : bp += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; nla_afnum = EXTRACT_16BITS ( bp ) ; bp += ( 2 * sizeof ( uint16_t ) ) ; switch ( nla_afnum ) { case AFNUM_INET : if ( opt_len != 12 + sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PGMCC_DATA<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>12<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; opts_len -= 12 + sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : if ( opt_len != 12 + sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PGMCC_DATA<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>12<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; opts_len -= 12 + sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } ND_PRINT ( ( ndo , ""<S2SV_blank>PGMCC<S2SV_blank>DATA<S2SV_blank>%u<S2SV_blank>%s"" , offset , nla_buf ) ) ; break ; case PGM_OPT_PGMCC_FEEDBACK : bp += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; nla_afnum = EXTRACT_16BITS ( bp ) ; bp += ( 2 * sizeof ( uint16_t ) ) ; switch ( nla_afnum ) { case AFNUM_INET : if ( opt_len != 12 + sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PGMCC_DATA<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>12<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; opts_len -= 12 + sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : if ( opt_len != 12 + sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PGMCC_DATA<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>12<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; opts_len -= 12 + sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } ND_PRINT ( ( ndo , ""<S2SV_blank>PGMCC<S2SV_blank>FEEDBACK<S2SV_blank>%u<S2SV_blank>%s"" , offset , nla_buf ) ) ; break ; default : ND_PRINT ( ( ndo , ""<S2SV_blank>OPT_%02X<S2SV_blank>[%d]<S2SV_blank>"" , opt_type , opt_len ) ) ; bp += opt_len ; opts_len -= opt_len ; break ; } if ( opt_type & PGM_OPT_END ) break ; } } ND_PRINT ( ( ndo , ""<S2SV_blank>[%u]"" , length ) ) ; if ( ndo -> ndo_packettype == PT_PGM_ZMTP1 && ( pgm -> pgm_type == PGM_ODATA || pgm -> pgm_type == PGM_RDATA ) ) zmtp1_print_datagram ( ndo , bp , EXTRACT_16BITS ( & pgm -> pgm_length ) ) ; return ; trunc : ND_PRINT ( ( ndo , ""[|pgm]"" ) ) ; if ( ch != '\\0' ) ND_PRINT ( ( ndo , "">"" ) ) ; }
","<S2SV_ModStart> case PGM_OPT_LENGTH : # define PGM_OPT_LENGTH_LEN ( 2 + 2 ) <S2SV_ModStart> ( opt_len != PGM_OPT_LENGTH_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_LENGTH<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_LENGTH_LEN ) ) ; return ; } ND_PRINT ( ( ndo , ""<S2SV_blank>OPTS<S2SV_blank>LEN<S2SV_blank>(extra?)<S2SV_blank>%d"" , EXTRACT_16BITS ( bp ) ) ) ; bp += 2 ; opts_len -= PGM_OPT_LENGTH_LEN ; break ; case PGM_OPT_FRAGMENT : # define PGM_OPT_FRAGMENT_LEN ( 2 + 2 + 4 + 4 + 4 ) if ( opt_len != PGM_OPT_FRAGMENT_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_FRAGMENT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_FRAGMENT_LEN <S2SV_ModEnd> ) ) ; <S2SV_ModStart> return ; } bp += 2 ; seq = EXTRACT_32BITS ( bp ) ; bp += 4 ; offset = EXTRACT_32BITS ( bp ) ; bp += 4 ; len = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>FRAG<S2SV_blank>seq<S2SV_blank>%u<S2SV_blank>off<S2SV_blank>%u<S2SV_blank>len<S2SV_blank>%u"" , seq , offset , len ) ) ; opts_len -= PGM_OPT_FRAGMENT_LEN ; break ; case PGM_OPT_NAK_LIST : bp += 2 ; opt_len -= 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>NAK<S2SV_blank>LIST"" ) ) ; while ( opt_len ) { if ( opt_len < 4 ) { ND_PRINT ( ( ndo , ""[Option<S2SV_blank>length<S2SV_blank>not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4]"" ) ) ; return ; } ND_TCHECK2 ( * bp , 4 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u"" , EXTRACT_32BITS ( bp ) ) ) ; bp += 4 ; opt_len -= 4 <S2SV_ModEnd> ; opts_len -= <S2SV_ModStart> -= 4 ; } break ; case PGM_OPT_JOIN : # define PGM_OPT_JOIN_LEN ( 2 + 2 + 4 ) <S2SV_ModEnd> if ( opt_len <S2SV_ModStart> ( opt_len != PGM_OPT_JOIN_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_JOIN<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_JOIN_LEN <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>JOIN<S2SV_blank>%u"" , seq <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ; opts_len -= PGM_OPT_JOIN_LEN ; break ; case PGM_OPT_NAK_BO_IVL : # define PGM_OPT_NAK_BO_IVL_LEN ( 2 + 2 + 4 + 4 ) <S2SV_ModEnd> if ( opt_len <S2SV_ModStart> if ( opt_len != PGM_OPT_NAK_BO_IVL_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_NAK_BO_IVL<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_NAK_BO_IVL_LEN <S2SV_ModEnd> ) ) ; <S2SV_ModStart> return ; } bp += 2 ; offset = <S2SV_ModEnd> EXTRACT_32BITS ( bp <S2SV_ModStart> ( bp ) ; bp += 4 ; seq = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>BACKOFF<S2SV_blank>ivl<S2SV_blank>%u<S2SV_blank>ivlseq<S2SV_blank>%u"" , offset , seq ) <S2SV_ModEnd> ) ; opts_len <S2SV_ModStart> ; opts_len -= PGM_OPT_NAK_BO_IVL_LEN ; break ; case PGM_OPT_NAK_BO_RNG : # define PGM_OPT_NAK_BO_RNG_LEN ( 2 + 2 + 4 + 4 ) <S2SV_ModEnd> if ( opt_len <S2SV_ModStart> ( opt_len != PGM_OPT_NAK_BO_RNG_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_NAK_BO_RNG<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_NAK_BO_RNG_LEN <S2SV_ModEnd> ) ) ; <S2SV_ModStart> += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += 4 ; <S2SV_ModStart> ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>BACKOFF<S2SV_blank>max<S2SV_blank>%u<S2SV_blank>min<S2SV_blank>%u"" , offset <S2SV_ModEnd> , seq ) <S2SV_ModStart> ; opts_len -= PGM_OPT_NAK_BO_RNG_LEN ; break ; case PGM_OPT_REDIRECT : # define PGM_OPT_REDIRECT_FIXED_LEN ( 2 + 2 + 2 + 2 ) <S2SV_ModEnd> if ( opt_len <S2SV_ModStart> if ( opt_len < PGM_OPT_REDIRECT_FIXED_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_REDIRECT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%u]"" , opt_len , PGM_OPT_REDIRECT_FIXED_LEN ) ) ; return ; } bp += 2 ; nla_afnum = EXTRACT_16BITS ( bp ) ; bp += 2 + 2 ; switch ( nla_afnum ) { case AFNUM_INET : if ( opt_len != PGM_OPT_REDIRECT_FIXED_LEN + sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_REDIRECT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len , PGM_OPT_REDIRECT_FIXED_LEN <S2SV_ModEnd> ) ) ; <S2SV_ModStart> return ; } ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr <S2SV_ModEnd> ) ; opts_len <S2SV_ModStart> ; opts_len -= PGM_OPT_REDIRECT_FIXED_LEN + sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 <S2SV_ModEnd> : if ( <S2SV_ModStart> ( opt_len != PGM_OPT_REDIRECT_FIXED_LEN + sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_REDIRECT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , PGM_OPT_REDIRECT_FIXED_LEN <S2SV_ModEnd> , opt_len ) <S2SV_ModStart> return ; } ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr <S2SV_ModEnd> ) ; opts_len <S2SV_ModStart> ; opts_len -= PGM_OPT_REDIRECT_FIXED_LEN + sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } ND_PRINT ( ( ndo , ""<S2SV_blank>REDIRECT<S2SV_blank>%s"" , nla_buf ) ) ; break ; case PGM_OPT_PARITY_PRM : # define PGM_OPT_PARITY_PRM_LEN ( 2 + 2 + 4 ) <S2SV_ModEnd> if ( opt_len <S2SV_ModStart> ( opt_len != PGM_OPT_PARITY_PRM_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PARITY_PRM<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_PARITY_PRM_LEN ) ) ; return ; } bp += 2 ; len = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>PARITY<S2SV_blank>MAXTGS<S2SV_blank>%u"" , len ) <S2SV_ModEnd> ) ; opts_len <S2SV_ModStart> ; opts_len -= PGM_OPT_PARITY_PRM_LEN ; break ; case PGM_OPT_PARITY_GRP : # define PGM_OPT_PARITY_GRP_LEN ( 2 + 2 + 4 ) <S2SV_ModEnd> if ( opt_len <S2SV_ModStart> ( opt_len != PGM_OPT_PARITY_GRP_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PARITY_GRP<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_PARITY_GRP_LEN ) ) ; return ; } bp += 2 ; seq = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>PARITY<S2SV_blank>GROUP<S2SV_blank>%u"" , seq ) <S2SV_ModEnd> ) ; opts_len <S2SV_ModStart> ; opts_len -= PGM_OPT_PARITY_GRP_LEN ; break ; case PGM_OPT_CURR_TGSIZE : # define PGM_OPT_CURR_TGSIZE_LEN ( 2 + 2 + 4 ) if ( opt_len != PGM_OPT_CURR_TGSIZE_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_CURR_TGSIZE<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_CURR_TGSIZE_LEN ) ) ; return ; } bp += 2 ; len = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>PARITY<S2SV_blank>ATGS<S2SV_blank>%u"" , len ) ) ; opts_len -= PGM_OPT_CURR_TGSIZE_LEN ; break ; case PGM_OPT_NBR_UNREACH : # define PGM_OPT_NBR_UNREACH_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_NBR_UNREACH_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_NBR_UNREACH<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_NBR_UNREACH_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>NBR_UNREACH"" ) ) ; opts_len -= PGM_OPT_NBR_UNREACH_LEN ; break ; case PGM_OPT_PATH_NLA : ND_PRINT ( ( ndo , ""<S2SV_blank>PATH_NLA<S2SV_blank>[%d]"" , opt_len ) ) ; bp += opt_len ; opts_len -= opt_len ; break ; case PGM_OPT_SYN : # define PGM_OPT_SYN_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_SYN_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_SYN<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_SYN_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>SYN"" ) ) ; opts_len -= PGM_OPT_SYN_LEN ; break ; case PGM_OPT_FIN : # define PGM_OPT_FIN_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_FIN_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_FIN<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_FIN_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>FIN"" ) ) ; opts_len -= PGM_OPT_FIN_LEN ; break ; case PGM_OPT_RST : # define PGM_OPT_RST_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_RST_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_RST<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_RST_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>RST"" ) ) ; opts_len -= PGM_OPT_RST_LEN ; break ; case PGM_OPT_CR : ND_PRINT ( ( ndo , ""<S2SV_blank>CR"" ) ) ; bp += opt_len ; opts_len -= opt_len ; break ; case PGM_OPT_CRQST : # define PGM_OPT_CRQST_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_CRQST_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_CRQST<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_CRQST_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>CRQST"" ) ) ; opts_len -= PGM_OPT_CRQST_LEN ; break ; case PGM_OPT_PGMCC_DATA : # define PGM_OPT_PGMCC_DATA_FIXED_LEN ( 2 + 2 + 4 + 2 + 2 ) if ( opt_len < PGM_OPT_PGMCC_DATA_FIXED_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PGMCC_DATA<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%u]"" , opt_len , PGM_OPT_PGMCC_DATA_FIXED_LEN ) ) ; return ; } bp += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += 4 ; nla_afnum = EXTRACT_16BITS ( bp ) ; bp += 2 + 2 ; switch ( nla_afnum ) { case AFNUM_INET : if ( opt_len != PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PGMCC_DATA<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len , PGM_OPT_PGMCC_DATA_FIXED_LEN ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; opts_len -= PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : if ( opt_len != PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PGMCC_DATA<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len , PGM_OPT_PGMCC_DATA_FIXED_LEN ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; opts_len -= PGM_OPT_PGMCC_DATA_FIXED_LEN <S2SV_ModEnd> + sizeof ( <S2SV_ModStart> ( ndo , ""<S2SV_blank>PGMCC<S2SV_blank>DATA<S2SV_blank>%u<S2SV_blank>%s"" , offset <S2SV_ModEnd> , nla_buf ) <S2SV_ModStart> break ; case PGM_OPT_PGMCC_FEEDBACK : # define PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN ( 2 + 2 + 4 + 2 + 2 ) <S2SV_ModEnd> if ( opt_len <S2SV_ModStart> if ( opt_len < PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>PGM_OPT_PGMCC_FEEDBACK<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%u]"" , opt_len , PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN ) ) ; return ; } bp += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += 4 ; nla_afnum = EXTRACT_16BITS ( bp ) ; bp += 2 + 2 ; switch ( nla_afnum ) { case AFNUM_INET : if ( opt_len != PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PGMCC_FEEDBACK<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len , PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN <S2SV_ModEnd> ) ) ; <S2SV_ModStart> return ; } ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr <S2SV_ModEnd> ) ; opts_len <S2SV_ModStart> ; opts_len -= PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 <S2SV_ModEnd> : if ( <S2SV_ModStart> ( opt_len != PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PGMCC_FEEDBACK<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len , PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN <S2SV_ModEnd> ) ) ; <S2SV_ModStart> return ; } ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr <S2SV_ModEnd> ) ; opts_len <S2SV_ModStart> ; opts_len -= PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN <S2SV_ModEnd> + sizeof (
"
77,"CWE-404 static int nfs4_callback_svc ( void * vrqstp ) { int err ; struct svc_rqst * rqstp = vrqstp ; set_freezable ( ) ; <S2SV_StartBug> while ( ! kthread_should_stop ( ) ) { <S2SV_EndBug> err = svc_recv ( rqstp , MAX_SCHEDULE_TIMEOUT ) ; if ( err == - EAGAIN || err == - EINTR ) continue ; svc_process ( rqstp ) ; } <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
","<S2SV_ModStart> while ( ! kthread_freezable_should_stop ( NULL <S2SV_ModEnd> ) ) { <S2SV_ModStart> ) ) { if ( signal_pending ( current ) ) flush_signals ( current ) ; <S2SV_ModStart> ) ; } svc_exit_thread ( rqstp ) ; module_put_and_exit ( 0 ) ;
"
78,"CWE-284 int btsock_thread_add_fd ( int h , int fd , int type , int flags , uint32_t user_id ) { if ( h < 0 || h >= MAX_THREAD ) { APPL_TRACE_ERROR ( ""invalid<S2SV_blank>bt<S2SV_blank>thread<S2SV_blank>handle:%d"" , h ) ; return FALSE ; } if ( ts [ h ] . cmd_fdw == - 1 ) { APPL_TRACE_ERROR ( ""cmd<S2SV_blank>socket<S2SV_blank>is<S2SV_blank>not<S2SV_blank>created.<S2SV_blank>socket<S2SV_blank>thread<S2SV_blank>may<S2SV_blank>not<S2SV_blank>initialized"" ) ; return FALSE ; } if ( flags & SOCK_THREAD_ADD_FD_SYNC ) { if ( ts [ h ] . thread_id == pthread_self ( ) ) { flags &= ~ SOCK_THREAD_ADD_FD_SYNC ; add_poll ( h , fd , type , flags , user_id ) ; return TRUE ; } APPL_TRACE_DEBUG ( ""THREAD_ADD_FD_SYNC<S2SV_blank>is<S2SV_blank>not<S2SV_blank>called<S2SV_blank>in<S2SV_blank>poll<S2SV_blank>thread,<S2SV_blank>fallback<S2SV_blank>to<S2SV_blank>async"" ) ; } sock_cmd_t cmd = { CMD_ADD_FD , fd , type , flags , user_id } ; APPL_TRACE_DEBUG ( ""adding<S2SV_blank>fd:%d,<S2SV_blank>flags:0x%x"" , fd , flags ) ; <S2SV_StartBug> return send ( ts [ h ] . cmd_fdw , & cmd , sizeof ( cmd ) , 0 ) == sizeof ( cmd ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ) ; return TEMP_FAILURE_RETRY ( <S2SV_ModStart> , 0 ) )
"
79,"CWE-125 static void l2tp_result_code_print ( netdissect_options * ndo , const u_char * dat , u_int length ) { const uint16_t * ptr = ( const uint16_t * ) dat ; <S2SV_StartBug> ND_PRINT ( ( ndo , ""%u"" , EXTRACT_16BITS ( ptr ) ) ) ; ptr ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( length > 2 ) { <S2SV_EndBug> ND_PRINT ( ( ndo , ""/%u"" , EXTRACT_16BITS ( ptr ) ) ) ; ptr ++ ; <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( length > 4 ) { <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; <S2SV_StartBug> print_string ( ndo , ( const u_char * ) ptr , length - 4 ) ; <S2SV_EndBug> } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> ) dat ; if ( length < 2 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } <S2SV_ModStart> ; ptr ++ ; length -= 2 <S2SV_ModStart> if ( length == 0 ) return ; if ( length < <S2SV_ModEnd> 2 ) { <S2SV_ModStart> 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } <S2SV_ModStart> ptr ++ ; length -= 2 ; <S2SV_ModEnd> if ( length <S2SV_ModStart> if ( length == 0 ) return ; <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> ptr , length <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
"
80,"CWE-119 static int tiffcp ( TIFF * in , TIFF * out ) { <S2SV_StartBug> uint16 bitspersample , samplesperpixel = 1 ; <S2SV_EndBug> uint16 input_compression , input_photometric = PHOTOMETRIC_MINISBLACK ; copyFunc cf ; uint32 width , length ; struct cpTag * p ; CopyField ( TIFFTAG_IMAGEWIDTH , width ) ; CopyField ( TIFFTAG_IMAGELENGTH , length ) ; CopyField ( TIFFTAG_BITSPERSAMPLE , bitspersample ) ; CopyField ( TIFFTAG_SAMPLESPERPIXEL , samplesperpixel ) ; if ( compression != ( uint16 ) - 1 ) TIFFSetField ( out , TIFFTAG_COMPRESSION , compression ) ; else CopyField ( TIFFTAG_COMPRESSION , compression ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_COMPRESSION , & input_compression ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_PHOTOMETRIC , & input_photometric ) ; if ( input_compression == COMPRESSION_JPEG ) { TIFFSetField ( in , TIFFTAG_JPEGCOLORMODE , JPEGCOLORMODE_RGB ) ; } else if ( input_photometric == PHOTOMETRIC_YCBCR ) { uint16 subsamplinghor , subsamplingver ; TIFFGetFieldDefaulted ( in , TIFFTAG_YCBCRSUBSAMPLING , & subsamplinghor , & subsamplingver ) ; if ( subsamplinghor != 1 || subsamplingver != 1 ) { fprintf ( stderr , ""tiffcp:<S2SV_blank>%s:<S2SV_blank>Can\'t<S2SV_blank>copy/convert<S2SV_blank>subsampled<S2SV_blank>image.\\n"" , TIFFFileName ( in ) ) ; return FALSE ; } } if ( compression == COMPRESSION_JPEG ) { if ( input_photometric == PHOTOMETRIC_RGB && jpegcolormode == JPEGCOLORMODE_RGB ) TIFFSetField ( out , TIFFTAG_PHOTOMETRIC , PHOTOMETRIC_YCBCR ) ; else TIFFSetField ( out , TIFFTAG_PHOTOMETRIC , input_photometric ) ; } else if ( compression == COMPRESSION_SGILOG || compression == COMPRESSION_SGILOG24 ) TIFFSetField ( out , TIFFTAG_PHOTOMETRIC , samplesperpixel == 1 ? PHOTOMETRIC_LOGL : PHOTOMETRIC_LOGLUV ) ; else if ( input_compression == COMPRESSION_JPEG && samplesperpixel == 3 ) { TIFFSetField ( out , TIFFTAG_PHOTOMETRIC , PHOTOMETRIC_RGB ) ; } else CopyTag ( TIFFTAG_PHOTOMETRIC , 1 , TIFF_SHORT ) ; if ( fillorder != 0 ) TIFFSetField ( out , TIFFTAG_FILLORDER , fillorder ) ; else CopyTag ( TIFFTAG_FILLORDER , 1 , TIFF_SHORT ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_ORIENTATION , & orientation ) ; switch ( orientation ) { case ORIENTATION_BOTRIGHT : case ORIENTATION_RIGHTBOT : TIFFWarning ( TIFFFileName ( in ) , ""using<S2SV_blank>bottom-left<S2SV_blank>orientation"" ) ; orientation = ORIENTATION_BOTLEFT ; case ORIENTATION_LEFTBOT : case ORIENTATION_BOTLEFT : break ; case ORIENTATION_TOPRIGHT : case ORIENTATION_RIGHTTOP : default : TIFFWarning ( TIFFFileName ( in ) , ""using<S2SV_blank>top-left<S2SV_blank>orientation"" ) ; orientation = ORIENTATION_TOPLEFT ; case ORIENTATION_LEFTTOP : case ORIENTATION_TOPLEFT : break ; } TIFFSetField ( out , TIFFTAG_ORIENTATION , orientation ) ; if ( outtiled == - 1 ) outtiled = TIFFIsTiled ( in ) ; if ( outtiled ) { if ( tilewidth == ( uint32 ) - 1 ) TIFFGetField ( in , TIFFTAG_TILEWIDTH , & tilewidth ) ; if ( tilelength == ( uint32 ) - 1 ) TIFFGetField ( in , TIFFTAG_TILELENGTH , & tilelength ) ; TIFFDefaultTileSize ( out , & tilewidth , & tilelength ) ; TIFFSetField ( out , TIFFTAG_TILEWIDTH , tilewidth ) ; TIFFSetField ( out , TIFFTAG_TILELENGTH , tilelength ) ; } else { if ( rowsperstrip == ( uint32 ) 0 ) { if ( ! TIFFGetField ( in , TIFFTAG_ROWSPERSTRIP , & rowsperstrip ) ) { rowsperstrip = TIFFDefaultStripSize ( out , rowsperstrip ) ; } if ( rowsperstrip > length && rowsperstrip != ( uint32 ) - 1 ) rowsperstrip = length ; } else if ( rowsperstrip == ( uint32 ) - 1 ) rowsperstrip = length ; TIFFSetField ( out , TIFFTAG_ROWSPERSTRIP , rowsperstrip ) ; } if ( config != ( uint16 ) - 1 ) TIFFSetField ( out , TIFFTAG_PLANARCONFIG , config ) ; else CopyField ( TIFFTAG_PLANARCONFIG , config ) ; if ( samplesperpixel <= 4 ) CopyTag ( TIFFTAG_TRANSFERFUNCTION , 4 , TIFF_SHORT ) ; CopyTag ( TIFFTAG_COLORMAP , 4 , TIFF_SHORT ) ; switch ( compression ) { case COMPRESSION_JPEG : TIFFSetField ( out , TIFFTAG_JPEGQUALITY , quality ) ; TIFFSetField ( out , TIFFTAG_JPEGCOLORMODE , jpegcolormode ) ; break ; case COMPRESSION_JBIG : CopyTag ( TIFFTAG_FAXRECVPARAMS , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_FAXRECVTIME , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_FAXSUBADDRESS , 1 , TIFF_ASCII ) ; CopyTag ( TIFFTAG_FAXDCS , 1 , TIFF_ASCII ) ; break ; case COMPRESSION_LZW : case COMPRESSION_ADOBE_DEFLATE : case COMPRESSION_DEFLATE : case COMPRESSION_LZMA : if ( predictor != ( uint16 ) - 1 ) TIFFSetField ( out , TIFFTAG_PREDICTOR , predictor ) ; else CopyField ( TIFFTAG_PREDICTOR , predictor ) ; if ( preset != - 1 ) { if ( compression == COMPRESSION_ADOBE_DEFLATE || compression == COMPRESSION_DEFLATE ) TIFFSetField ( out , TIFFTAG_ZIPQUALITY , preset ) ; else if ( compression == COMPRESSION_LZMA ) TIFFSetField ( out , TIFFTAG_LZMAPRESET , preset ) ; } break ; case COMPRESSION_CCITTFAX3 : case COMPRESSION_CCITTFAX4 : if ( compression == COMPRESSION_CCITTFAX3 ) { if ( g3opts != ( uint32 ) - 1 ) TIFFSetField ( out , TIFFTAG_GROUP3OPTIONS , g3opts ) ; else CopyField ( TIFFTAG_GROUP3OPTIONS , g3opts ) ; } else CopyTag ( TIFFTAG_GROUP4OPTIONS , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_BADFAXLINES , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_CLEANFAXDATA , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_CONSECUTIVEBADFAXLINES , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_FAXRECVPARAMS , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_FAXRECVTIME , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_FAXSUBADDRESS , 1 , TIFF_ASCII ) ; break ; } { uint32 len32 ; void * * data ; if ( TIFFGetField ( in , TIFFTAG_ICCPROFILE , & len32 , & data ) ) TIFFSetField ( out , TIFFTAG_ICCPROFILE , len32 , data ) ; } { uint16 ninks ; const char * inknames ; if ( TIFFGetField ( in , TIFFTAG_NUMBEROFINKS , & ninks ) ) { TIFFSetField ( out , TIFFTAG_NUMBEROFINKS , ninks ) ; if ( TIFFGetField ( in , TIFFTAG_INKNAMES , & inknames ) ) { int inknameslen = strlen ( inknames ) + 1 ; const char * cp = inknames ; while ( ninks > 1 ) { cp = strchr ( cp , '\\0' ) ; cp ++ ; inknameslen += ( strlen ( cp ) + 1 ) ; ninks -- ; } TIFFSetField ( out , TIFFTAG_INKNAMES , inknameslen , inknames ) ; } } } { unsigned short pg0 , pg1 ; if ( pageInSeq == 1 ) { if ( pageNum < 0 ) { if ( TIFFGetField ( in , TIFFTAG_PAGENUMBER , & pg0 , & pg1 ) ) TIFFSetField ( out , TIFFTAG_PAGENUMBER , pg0 , pg1 ) ; } else TIFFSetField ( out , TIFFTAG_PAGENUMBER , pageNum ++ , 0 ) ; } else { if ( TIFFGetField ( in , TIFFTAG_PAGENUMBER , & pg0 , & pg1 ) ) { if ( pageNum < 0 ) TIFFSetField ( out , TIFFTAG_PAGENUMBER , pg0 , pg1 ) ; else TIFFSetField ( out , TIFFTAG_PAGENUMBER , pageNum ++ , 0 ) ; } } } for ( p = tags ; p < & tags [ NTAGS ] ; p ++ ) CopyTag ( p -> tag , p -> count , p -> type ) ; cf = pickCopyFunc ( in , out , bitspersample , samplesperpixel ) ; return ( cf ? ( * cf ) ( in , out , length , width , samplesperpixel ) : FALSE ) ; }
","<S2SV_ModStart> { uint16 bitspersample = 1
"
81,"CWE-326 static VALUE ossl_cipher_initialize ( VALUE self , VALUE str ) { EVP_CIPHER_CTX * ctx ; const EVP_CIPHER * cipher ; <S2SV_StartBug> char * name ; <S2SV_EndBug> unsigned char dummy_key [ EVP_MAX_KEY_LENGTH ] = { 0 } ; name = StringValueCStr ( str ) ; GetCipherInit ( self , ctx ) ; if ( ctx ) { ossl_raise ( rb_eRuntimeError , ""Cipher<S2SV_blank>already<S2SV_blank>inititalized!"" ) ; } AllocCipher ( self , ctx ) ; if ( ! ( cipher = EVP_get_cipherbyname ( name ) ) ) { ossl_raise ( rb_eRuntimeError , ""unsupported<S2SV_blank>cipher<S2SV_blank>algorithm<S2SV_blank>(%"" PRIsVALUE "")"" , str ) ; } <S2SV_StartBug> if ( EVP_CipherInit_ex ( ctx , cipher , NULL , dummy_key , NULL , - 1 ) != 1 ) <S2SV_EndBug> ossl_raise ( eCipherError , NULL ) ; return self ; }
","<S2SV_ModStart> char * name <S2SV_ModEnd> ; name = <S2SV_ModStart> , NULL , NULL <S2SV_ModEnd> , NULL ,
"
82,"CWE-000 <S2SV_StartBug> void close_connection ( h2o_http2_conn_t * conn ) <S2SV_EndBug> { conn -> state = H2O_HTTP2_CONN_STATE_IS_CLOSING ; if ( conn -> _write . buf_in_flight != NULL || h2o_timeout_is_linked ( & conn -> _write . timeout_entry ) ) { } else { close_connection_now ( conn ) ; <S2SV_StartBug> } <S2SV_EndBug> }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> int <S2SV_ModEnd> close_connection ( h2o_http2_conn_t <S2SV_ModStart> conn ) ; return - 1 ; } return 0 ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
"
83,"CWE-125 opj_pi_iterator_t * opj_pi_create_decode ( opj_image_t * p_image , opj_cp_t * p_cp , OPJ_UINT32 p_tile_no ) { OPJ_UINT32 pino ; OPJ_UINT32 compno , resno ; OPJ_UINT32 * l_tmp_data ; OPJ_UINT32 * * l_tmp_ptr ; OPJ_UINT32 l_max_res ; OPJ_UINT32 l_max_prec ; OPJ_INT32 l_tx0 , l_tx1 , l_ty0 , l_ty1 ; OPJ_UINT32 l_dx_min , l_dy_min ; OPJ_UINT32 l_bound ; OPJ_UINT32 l_step_p , l_step_c , l_step_r , l_step_l ; OPJ_UINT32 l_data_stride ; opj_pi_iterator_t * l_pi = 00 ; opj_tcp_t * l_tcp = 00 ; const opj_tccp_t * l_tccp = 00 ; opj_pi_comp_t * l_current_comp = 00 ; opj_image_comp_t * l_img_comp = 00 ; opj_pi_iterator_t * l_current_pi = 00 ; OPJ_UINT32 * l_encoding_value_ptr = 00 ; assert ( p_cp != 00 ) ; assert ( p_image != 00 ) ; assert ( p_tile_no < p_cp -> tw * p_cp -> th ) ; l_tcp = & p_cp -> tcps [ p_tile_no ] ; l_bound = l_tcp -> numpocs + 1 ; l_data_stride = 4 * OPJ_J2K_MAXRLVLS ; l_tmp_data = ( OPJ_UINT32 * ) opj_malloc ( l_data_stride * p_image -> numcomps * sizeof ( OPJ_UINT32 ) ) ; if ( ! l_tmp_data ) { return 00 ; } l_tmp_ptr = ( OPJ_UINT32 * * ) opj_malloc ( p_image -> numcomps * sizeof ( OPJ_UINT32 * ) ) ; if ( ! l_tmp_ptr ) { opj_free ( l_tmp_data ) ; return 00 ; } l_pi = opj_pi_create ( p_image , p_cp , p_tile_no ) ; if ( ! l_pi ) { opj_free ( l_tmp_data ) ; opj_free ( l_tmp_ptr ) ; return 00 ; } l_encoding_value_ptr = l_tmp_data ; for ( compno = 0 ; compno < p_image -> numcomps ; ++ compno ) { l_tmp_ptr [ compno ] = l_encoding_value_ptr ; l_encoding_value_ptr += l_data_stride ; } opj_get_all_encoding_parameters ( p_image , p_cp , p_tile_no , & l_tx0 , & l_tx1 , & l_ty0 , & l_ty1 , & l_dx_min , & l_dy_min , & l_max_prec , & l_max_res , l_tmp_ptr ) ; l_step_p = 1 ; l_step_c = l_max_prec * l_step_p ; l_step_r = p_image -> numcomps * l_step_c ; l_step_l = l_max_res * l_step_r ; l_current_pi = l_pi ; l_current_pi -> include = 00 ; if ( l_step_l <= ( SIZE_MAX / ( l_tcp -> numlayers + 1U ) ) ) { <S2SV_StartBug> l_current_pi -> include = ( OPJ_INT16 * ) opj_calloc ( ( l_tcp -> numlayers + 1 ) * l_step_l , sizeof ( OPJ_INT16 ) ) ; <S2SV_EndBug> } if ( ! l_current_pi -> include ) { opj_free ( l_tmp_data ) ; opj_free ( l_tmp_ptr ) ; opj_pi_destroy ( l_pi , l_bound ) ; return 00 ; } l_current_comp = l_current_pi -> comps ; l_img_comp = p_image -> comps ; l_tccp = l_tcp -> tccps ; l_current_pi -> tx0 = l_tx0 ; l_current_pi -> ty0 = l_ty0 ; l_current_pi -> tx1 = l_tx1 ; l_current_pi -> ty1 = l_ty1 ; l_current_pi -> step_p = l_step_p ; l_current_pi -> step_c = l_step_c ; l_current_pi -> step_r = l_step_r ; l_current_pi -> step_l = l_step_l ; for ( compno = 0 ; compno < l_current_pi -> numcomps ; ++ compno ) { opj_pi_resolution_t * l_res = l_current_comp -> resolutions ; l_encoding_value_ptr = l_tmp_ptr [ compno ] ; l_current_comp -> dx = l_img_comp -> dx ; l_current_comp -> dy = l_img_comp -> dy ; for ( resno = 0 ; resno < l_current_comp -> numresolutions ; resno ++ ) { l_res -> pdx = * ( l_encoding_value_ptr ++ ) ; l_res -> pdy = * ( l_encoding_value_ptr ++ ) ; l_res -> pw = * ( l_encoding_value_ptr ++ ) ; l_res -> ph = * ( l_encoding_value_ptr ++ ) ; ++ l_res ; } ++ l_current_comp ; ++ l_img_comp ; ++ l_tccp ; } ++ l_current_pi ; for ( pino = 1 ; pino < l_bound ; ++ pino ) { l_current_comp = l_current_pi -> comps ; l_img_comp = p_image -> comps ; l_tccp = l_tcp -> tccps ; l_current_pi -> tx0 = l_tx0 ; l_current_pi -> ty0 = l_ty0 ; l_current_pi -> tx1 = l_tx1 ; l_current_pi -> ty1 = l_ty1 ; l_current_pi -> step_p = l_step_p ; l_current_pi -> step_c = l_step_c ; l_current_pi -> step_r = l_step_r ; l_current_pi -> step_l = l_step_l ; for ( compno = 0 ; compno < l_current_pi -> numcomps ; ++ compno ) { opj_pi_resolution_t * l_res = l_current_comp -> resolutions ; l_encoding_value_ptr = l_tmp_ptr [ compno ] ; l_current_comp -> dx = l_img_comp -> dx ; l_current_comp -> dy = l_img_comp -> dy ; for ( resno = 0 ; resno < l_current_comp -> numresolutions ; resno ++ ) { l_res -> pdx = * ( l_encoding_value_ptr ++ ) ; l_res -> pdy = * ( l_encoding_value_ptr ++ ) ; l_res -> pw = * ( l_encoding_value_ptr ++ ) ; l_res -> ph = * ( l_encoding_value_ptr ++ ) ; ++ l_res ; } ++ l_current_comp ; ++ l_img_comp ; ++ l_tccp ; } l_current_pi -> include = ( l_current_pi - 1 ) -> include ; ++ l_current_pi ; } opj_free ( l_tmp_data ) ; l_tmp_data = 00 ; opj_free ( l_tmp_ptr ) ; l_tmp_ptr = 00 ; if ( l_tcp -> POC ) { opj_pi_update_decode_poc ( l_pi , l_tcp , l_max_prec , l_max_res ) ; } else { opj_pi_update_decode_not_poc ( l_pi , l_tcp , l_max_prec , l_max_res ) ; } return l_pi ; }
","<S2SV_ModStart> opj_calloc ( ( size_t ) ( <S2SV_ModStart> -> numlayers + 1U <S2SV_ModEnd> ) * l_step_l
"
84,"CWE-119 int hugetlb_mcopy_atomic_pte ( struct mm_struct * dst_mm , pte_t * dst_pte , struct vm_area_struct * dst_vma , unsigned long dst_addr , unsigned long src_addr , struct page * * pagep ) { <S2SV_StartBug> int vm_shared = dst_vma -> vm_flags & VM_SHARED ; <S2SV_EndBug> struct hstate * h = hstate_vma ( dst_vma ) ; pte_t _dst_pte ; spinlock_t * ptl ; int ret ; struct page * page ; if ( ! * pagep ) { ret = - ENOMEM ; page = alloc_huge_page ( dst_vma , dst_addr , 0 ) ; if ( IS_ERR ( page ) ) goto out ; ret = copy_huge_page_from_user ( page , ( const void __user * ) src_addr , pages_per_huge_page ( h ) , false ) ; if ( unlikely ( ret ) ) { ret = - EFAULT ; * pagep = page ; goto out ; } } else { page = * pagep ; * pagep = NULL ; } __SetPageUptodate ( page ) ; set_page_huge_active ( page ) ; <S2SV_StartBug> if ( vm_shared ) { <S2SV_EndBug> <S2SV_StartBug> struct address_space * mapping = dst_vma -> vm_file -> f_mapping ; <S2SV_EndBug> pgoff_t idx = vma_hugecache_offset ( h , dst_vma , dst_addr ) ; ret = huge_add_to_page_cache ( page , mapping , idx ) ; if ( ret ) goto out_release_nounlock ; } ptl = huge_pte_lockptr ( h , dst_mm , dst_pte ) ; <S2SV_StartBug> spin_lock ( ptl ) ; <S2SV_EndBug> ret = - EEXIST ; if ( ! huge_pte_none ( huge_ptep_get ( dst_pte ) ) ) goto out_release_unlock ; if ( vm_shared ) { page_dup_rmap ( page , true ) ; } else { ClearPagePrivate ( page ) ; hugepage_add_new_anon_rmap ( page , dst_vma , dst_addr ) ; } _dst_pte = make_huge_pte ( dst_vma , page , dst_vma -> vm_flags & VM_WRITE ) ; if ( dst_vma -> vm_flags & VM_WRITE ) _dst_pte = huge_pte_mkdirty ( _dst_pte ) ; _dst_pte = pte_mkyoung ( _dst_pte ) ; set_huge_pte_at ( dst_mm , dst_addr , dst_pte , _dst_pte ) ; ( void ) huge_ptep_set_access_flags ( dst_vma , dst_addr , dst_pte , _dst_pte , dst_vma -> vm_flags & VM_WRITE ) ; hugetlb_count_add ( pages_per_huge_page ( h ) , dst_mm ) ; update_mmu_cache ( dst_vma , dst_addr , dst_pte ) ; spin_unlock ( ptl ) ; if ( vm_shared ) unlock_page ( page ) ; ret = 0 ; out : return ret ; out_release_unlock : spin_unlock ( ptl ) ; if ( vm_shared ) unlock_page ( page ) ; out_release_nounlock : put_page ( page ) ; goto out ; }
","<S2SV_ModStart> pagep ) { struct address_space * mapping ; pgoff_t idx ; unsigned long size ; <S2SV_ModStart> page ) ; mapping = dst_vma -> vm_file -> f_mapping ; idx = vma_hugecache_offset ( h , dst_vma , dst_addr ) ; <S2SV_ModStart> vm_shared ) { size = i_size_read ( mapping -> host ) >> huge_page_shift ( h ) ; ret = - EFAULT ; if ( idx >= size ) goto out_release_nounlock <S2SV_ModEnd> ; ret = <S2SV_ModStart> ( ptl ) ; size = i_size_read ( mapping -> host ) >> huge_page_shift ( h ) ; ret = - EFAULT ; if ( idx >= size ) goto out_release_unlock
"
85,"CWE-119 <S2SV_StartBug> void vp9_choose_segmap_coding_method ( VP9_COMP * cpi ) { <S2SV_EndBug> VP9_COMMON * const cm = & cpi -> common ; struct segmentation * seg = & cm -> seg ; int no_pred_cost ; int t_pred_cost = INT_MAX ; int i , tile_col , mi_row , mi_col ; int temporal_predictor_count [ PREDICTION_PROBS ] [ 2 ] = { { 0 } } ; int no_pred_segcounts [ MAX_SEGMENTS ] = { 0 } ; int t_unpred_seg_counts [ MAX_SEGMENTS ] = { 0 } ; <S2SV_StartBug> vp9_prob no_pred_tree [ SEG_TREE_PROBS ] ; <S2SV_EndBug> <S2SV_StartBug> vp9_prob t_pred_tree [ SEG_TREE_PROBS ] ; <S2SV_EndBug> <S2SV_StartBug> vp9_prob t_nopred_prob [ PREDICTION_PROBS ] ; <S2SV_EndBug> <S2SV_StartBug> const int mis = cm -> mi_stride ; <S2SV_EndBug> MODE_INFO * * mi_ptr , * * mi ; vpx_memset ( seg -> tree_probs , 255 , sizeof ( seg -> tree_probs ) ) ; <S2SV_StartBug> vpx_memset ( seg -> pred_probs , 255 , sizeof ( seg -> pred_probs ) ) ; <S2SV_EndBug> for ( tile_col = 0 ; tile_col < 1 << cm -> log2_tile_cols ; tile_col ++ ) { TileInfo tile ; <S2SV_StartBug> vp9_tile_init ( & tile , cm , 0 , tile_col ) ; <S2SV_EndBug> mi_ptr = cm -> mi_grid_visible + tile . mi_col_start ; for ( mi_row = 0 ; mi_row < cm -> mi_rows ; <S2SV_StartBug> mi_row += 8 , mi_ptr += 8 * mis ) { <S2SV_EndBug> mi = mi_ptr ; for ( mi_col = tile . mi_col_start ; mi_col < tile . mi_col_end ; mi_col += 8 , mi += 8 ) <S2SV_StartBug> count_segs_sb ( cpi , & tile , mi , no_pred_segcounts , <S2SV_EndBug> temporal_predictor_count , t_unpred_seg_counts , mi_row , mi_col , BLOCK_64X64 ) ; } } calc_segtree_probs ( no_pred_segcounts , no_pred_tree ) ; no_pred_cost = cost_segmap ( no_pred_segcounts , no_pred_tree ) ; if ( ! frame_is_intra_only ( cm ) ) { calc_segtree_probs ( t_unpred_seg_counts , t_pred_tree ) ; t_pred_cost = cost_segmap ( t_unpred_seg_counts , t_pred_tree ) ; for ( i = 0 ; i < PREDICTION_PROBS ; i ++ ) { const int count0 = temporal_predictor_count [ i ] [ 0 ] ; const int count1 = temporal_predictor_count [ i ] [ 1 ] ; t_nopred_prob [ i ] = get_binary_prob ( count0 , count1 ) ; t_pred_cost += count0 * vp9_cost_zero ( t_nopred_prob [ i ] ) + count1 * vp9_cost_one ( t_nopred_prob [ i ] ) ; } } if ( t_pred_cost < no_pred_cost ) { seg -> temporal_update = 1 ; <S2SV_StartBug> vpx_memcpy ( seg -> tree_probs , t_pred_tree , sizeof ( t_pred_tree ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( seg -> pred_probs , t_nopred_prob , sizeof ( t_nopred_prob ) ) ; <S2SV_EndBug> } else { seg -> temporal_update = 0 ; <S2SV_StartBug> vpx_memcpy ( seg -> tree_probs , no_pred_tree , sizeof ( no_pred_tree ) ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> void vp9_choose_segmap_coding_method ( VP9_COMMON * cm , MACROBLOCKD * xd ) { <S2SV_ModEnd> struct segmentation * <S2SV_ModStart> 0 } ; vpx_prob <S2SV_ModEnd> no_pred_tree [ SEG_TREE_PROBS <S2SV_ModStart> SEG_TREE_PROBS ] ; vpx_prob <S2SV_ModEnd> t_pred_tree [ SEG_TREE_PROBS <S2SV_ModStart> SEG_TREE_PROBS ] ; vpx_prob <S2SV_ModEnd> t_nopred_prob [ PREDICTION_PROBS <S2SV_ModStart> PREDICTION_PROBS ] ; memset <S2SV_ModEnd> ( seg -> <S2SV_ModStart> ) ) ; memset <S2SV_ModEnd> ( seg -> <S2SV_ModStart> TileInfo tile ; MODE_INFO * * mi_ptr ; <S2SV_ModStart> += 8 * cm -> mi_stride ) { MODE_INFO * * <S2SV_ModEnd> mi = mi_ptr <S2SV_ModStart> ) count_segs_sb ( cm , xd <S2SV_ModEnd> , & tile <S2SV_ModStart> = 1 ; memcpy <S2SV_ModEnd> ( seg -> <S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( seg -> <S2SV_ModStart> = 0 ; memcpy <S2SV_ModEnd> ( seg ->
"
86,"CWE-476 int btrfs_init_dev_replace ( struct btrfs_fs_info * fs_info ) { struct btrfs_key key ; struct btrfs_root * dev_root = fs_info -> dev_root ; struct btrfs_dev_replace * dev_replace = & fs_info -> dev_replace ; struct extent_buffer * eb ; int slot ; int ret = 0 ; struct btrfs_path * path = NULL ; int item_size ; struct btrfs_dev_replace_item * ptr ; u64 src_devid ; path = btrfs_alloc_path ( ) ; if ( ! path ) { ret = - ENOMEM ; goto out ; } key . objectid = 0 ; key . type = BTRFS_DEV_REPLACE_KEY ; key . offset = 0 ; ret = btrfs_search_slot ( NULL , dev_root , & key , path , 0 , 0 ) ; if ( ret ) { no_valid_dev_replace_entry_found : ret = 0 ; dev_replace -> replace_state = BTRFS_DEV_REPLACE_ITEM_STATE_NEVER_STARTED ; dev_replace -> cont_reading_from_srcdev_mode = BTRFS_DEV_REPLACE_ITEM_CONT_READING_FROM_SRCDEV_MODE_ALWAYS ; dev_replace -> time_started = 0 ; dev_replace -> time_stopped = 0 ; atomic64_set ( & dev_replace -> num_write_errors , 0 ) ; atomic64_set ( & dev_replace -> num_uncorrectable_read_errors , 0 ) ; dev_replace -> cursor_left = 0 ; dev_replace -> committed_cursor_left = 0 ; dev_replace -> cursor_left_last_write_of_item = 0 ; dev_replace -> cursor_right = 0 ; dev_replace -> srcdev = NULL ; dev_replace -> tgtdev = NULL ; dev_replace -> is_valid = 0 ; dev_replace -> item_needs_writeback = 0 ; goto out ; } slot = path -> slots [ 0 ] ; eb = path -> nodes [ 0 ] ; item_size = btrfs_item_size_nr ( eb , slot ) ; ptr = btrfs_item_ptr ( eb , slot , struct btrfs_dev_replace_item ) ; if ( item_size != sizeof ( struct btrfs_dev_replace_item ) ) { btrfs_warn ( fs_info , ""dev_replace<S2SV_blank>entry<S2SV_blank>found<S2SV_blank>has<S2SV_blank>unexpected<S2SV_blank>size,<S2SV_blank>ignore<S2SV_blank>entry"" ) ; goto no_valid_dev_replace_entry_found ; } src_devid = btrfs_dev_replace_src_devid ( eb , ptr ) ; dev_replace -> cont_reading_from_srcdev_mode = btrfs_dev_replace_cont_reading_from_srcdev_mode ( eb , ptr ) ; dev_replace -> replace_state = btrfs_dev_replace_replace_state ( eb , ptr ) ; dev_replace -> time_started = btrfs_dev_replace_time_started ( eb , ptr ) ; dev_replace -> time_stopped = btrfs_dev_replace_time_stopped ( eb , ptr ) ; atomic64_set ( & dev_replace -> num_write_errors , btrfs_dev_replace_num_write_errors ( eb , ptr ) ) ; atomic64_set ( & dev_replace -> num_uncorrectable_read_errors , btrfs_dev_replace_num_uncorrectable_read_errors ( eb , ptr ) ) ; dev_replace -> cursor_left = btrfs_dev_replace_cursor_left ( eb , ptr ) ; dev_replace -> committed_cursor_left = dev_replace -> cursor_left ; dev_replace -> cursor_left_last_write_of_item = dev_replace -> cursor_left ; dev_replace -> cursor_right = btrfs_dev_replace_cursor_right ( eb , ptr ) ; dev_replace -> is_valid = 1 ; dev_replace -> item_needs_writeback = 0 ; switch ( dev_replace -> replace_state ) { case BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED : case BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED : case BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED : dev_replace -> srcdev = NULL ; dev_replace -> tgtdev = NULL ; break ; case BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED : case BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED : dev_replace -> srcdev = btrfs_find_device ( fs_info -> fs_devices , <S2SV_StartBug> src_devid , NULL , NULL ) ; <S2SV_EndBug> dev_replace -> tgtdev = btrfs_find_device ( fs_info -> fs_devices , BTRFS_DEV_REPLACE_DEVID , <S2SV_StartBug> NULL , NULL ) ; <S2SV_EndBug> if ( ! dev_replace -> srcdev && ! btrfs_test_opt ( fs_info , DEGRADED ) ) { ret = - EIO ; btrfs_warn ( fs_info , ""cannot<S2SV_blank>mount<S2SV_blank>because<S2SV_blank>device<S2SV_blank>replace<S2SV_blank>operation<S2SV_blank>is<S2SV_blank>ongoing<S2SV_blank>and"" ) ; btrfs_warn ( fs_info , ""srcdev<S2SV_blank>(devid<S2SV_blank>%llu)<S2SV_blank>is<S2SV_blank>missing,<S2SV_blank>need<S2SV_blank>to<S2SV_blank>run<S2SV_blank>\'btrfs<S2SV_blank>dev<S2SV_blank>scan\'?"" , src_devid ) ; } if ( ! dev_replace -> tgtdev && ! btrfs_test_opt ( fs_info , DEGRADED ) ) { ret = - EIO ; btrfs_warn ( fs_info , ""cannot<S2SV_blank>mount<S2SV_blank>because<S2SV_blank>device<S2SV_blank>replace<S2SV_blank>operation<S2SV_blank>is<S2SV_blank>ongoing<S2SV_blank>and"" ) ; btrfs_warn ( fs_info , ""tgtdev<S2SV_blank>(devid<S2SV_blank>%llu)<S2SV_blank>is<S2SV_blank>missing,<S2SV_blank>need<S2SV_blank>to<S2SV_blank>run<S2SV_blank>\'btrfs<S2SV_blank>dev<S2SV_blank>scan\'?"" , BTRFS_DEV_REPLACE_DEVID ) ; } if ( dev_replace -> tgtdev ) { if ( dev_replace -> srcdev ) { dev_replace -> tgtdev -> total_bytes = dev_replace -> srcdev -> total_bytes ; dev_replace -> tgtdev -> disk_total_bytes = dev_replace -> srcdev -> disk_total_bytes ; dev_replace -> tgtdev -> commit_total_bytes = dev_replace -> srcdev -> commit_total_bytes ; dev_replace -> tgtdev -> bytes_used = dev_replace -> srcdev -> bytes_used ; dev_replace -> tgtdev -> commit_bytes_used = dev_replace -> srcdev -> commit_bytes_used ; } set_bit ( BTRFS_DEV_STATE_REPLACE_TGT , & dev_replace -> tgtdev -> dev_state ) ; WARN_ON ( fs_info -> fs_devices -> rw_devices == 0 ) ; dev_replace -> tgtdev -> io_width = fs_info -> sectorsize ; dev_replace -> tgtdev -> io_align = fs_info -> sectorsize ; dev_replace -> tgtdev -> sector_size = fs_info -> sectorsize ; dev_replace -> tgtdev -> fs_info = fs_info ; set_bit ( BTRFS_DEV_STATE_IN_FS_METADATA , & dev_replace -> tgtdev -> dev_state ) ; } break ; } out : btrfs_free_path ( path ) ; return ret ; }
","<S2SV_ModStart> NULL , NULL , true <S2SV_ModStart> NULL , NULL , true
"
87,"CWE-200 static int run_post_create ( const char * dirname ) { if ( ! dir_is_in_dump_location ( dirname ) ) { error_msg ( ""Bad<S2SV_blank>problem<S2SV_blank>directory<S2SV_blank>name<S2SV_blank>\'%s\',<S2SV_blank>should<S2SV_blank>start<S2SV_blank>with:<S2SV_blank>\'%s\'"" , dirname , g_settings_dump_location ) ; return 400 ; } <S2SV_StartBug> if ( ! dump_dir_accessible_by_uid ( dirname , client_uid ) ) <S2SV_EndBug> { if ( errno == ENOTDIR ) { error_msg ( ""Path<S2SV_blank>\'%s\'<S2SV_blank>isn\'t<S2SV_blank>problem<S2SV_blank>directory"" , dirname ) ; return 404 ; } error_msg ( ""Problem<S2SV_blank>directory<S2SV_blank>\'%s\'<S2SV_blank>can\'t<S2SV_blank>be<S2SV_blank>accessed<S2SV_blank>by<S2SV_blank>user<S2SV_blank>with<S2SV_blank>uid<S2SV_blank>%ld"" , dirname , ( long ) client_uid ) ; return 403 ; } int child_stdout_fd ; int child_pid = spawn_event_handler_child ( dirname , ""post-create"" , & child_stdout_fd ) ; char * dup_of_dir = NULL ; struct strbuf * cmd_output = strbuf_new ( ) ; bool child_is_post_create = 1 ; read_child_output : for ( ; ; ) { char buf [ 250 ] ; errno = 0 ; int r = safe_read ( child_stdout_fd , buf , sizeof ( buf ) - 1 ) ; if ( r <= 0 ) break ; buf [ r ] = '\\0' ; char * raw = buf ; char * newline ; while ( ( newline = strchr ( raw , '\\n' ) ) != NULL ) { * newline = '\\0' ; strbuf_append_str ( cmd_output , raw ) ; char * msg = cmd_output -> buf ; log ( ""%s"" , msg ) ; if ( child_is_post_create && prefixcmp ( msg , ""DUP_OF_DIR:<S2SV_blank>"" ) == 0 ) { free ( dup_of_dir ) ; dup_of_dir = xstrdup ( msg + strlen ( ""DUP_OF_DIR:<S2SV_blank>"" ) ) ; } strbuf_clear ( cmd_output ) ; raw = newline + 1 ; } strbuf_append_str ( cmd_output , raw ) ; } int status = 0 ; if ( safe_waitpid ( child_pid , & status , 0 ) <= 0 ) perror_msg ( ""waitpid(%d)"" , child_pid ) ; if ( ! child_is_post_create ) goto ret ; if ( status != 0 ) { if ( WIFSIGNALED ( status ) ) { log ( ""\'post-create\'<S2SV_blank>on<S2SV_blank>\'%s\'<S2SV_blank>killed<S2SV_blank>by<S2SV_blank>signal<S2SV_blank>%d"" , dirname , WTERMSIG ( status ) ) ; goto delete_bad_dir ; } if ( ! dup_of_dir ) { log ( ""\'post-create\'<S2SV_blank>on<S2SV_blank>\'%s\'<S2SV_blank>exited<S2SV_blank>with<S2SV_blank>%d"" , dirname , WEXITSTATUS ( status ) ) ; goto delete_bad_dir ; } } const char * work_dir = ( dup_of_dir ? dup_of_dir : dirname ) ; struct dump_dir * dd = dd_opendir ( work_dir , 0 ) ; if ( ! dd ) goto delete_bad_dir ; char * count_str = dd_load_text_ext ( dd , FILENAME_COUNT , DD_FAIL_QUIETLY_ENOENT ) ; unsigned long count = strtoul ( count_str , NULL , 10 ) ; if ( ( status != 0 && dup_of_dir ) || count == 0 ) { count ++ ; char new_count_str [ sizeof ( long ) * 3 + 2 ] ; sprintf ( new_count_str , ""%lu"" , count ) ; dd_save_text ( dd , FILENAME_COUNT , new_count_str ) ; if ( strcmp ( dd -> dd_dirname , dirname ) != 0 ) { struct dump_dir * new_dd = dd_opendir ( dirname , DD_OPEN_READONLY ) ; char * last_ocr = NULL ; if ( new_dd ) { last_ocr = dd_load_text_ext ( new_dd , FILENAME_TIME , DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE | DD_FAIL_QUIETLY_ENOENT ) ; dd_close ( new_dd ) ; } else { error_msg ( ""Can\'t<S2SV_blank>read<S2SV_blank>the<S2SV_blank>last<S2SV_blank>occurrence<S2SV_blank>file<S2SV_blank>from<S2SV_blank>the<S2SV_blank>new<S2SV_blank>dump<S2SV_blank>directory."" ) ; } if ( ! last_ocr ) { log ( ""Using<S2SV_blank>current<S2SV_blank>time<S2SV_blank>for<S2SV_blank>the<S2SV_blank>last<S2SV_blank>occurrence<S2SV_blank>file<S2SV_blank>which<S2SV_blank>may<S2SV_blank>be<S2SV_blank>incorrect."" ) ; time_t t = time ( NULL ) ; last_ocr = xasprintf ( ""%lu"" , ( long ) t ) ; } dd_save_text ( dd , FILENAME_LAST_OCCURRENCE , last_ocr ) ; free ( last_ocr ) ; } } dd_sanitize_mode_and_owner ( dd ) ; dd_close ( dd ) ; if ( ! dup_of_dir ) log_notice ( ""New<S2SV_blank>problem<S2SV_blank>directory<S2SV_blank>%s,<S2SV_blank>processing"" , work_dir ) ; else { log_warning ( ""Deleting<S2SV_blank>problem<S2SV_blank>directory<S2SV_blank>%s<S2SV_blank>(dup<S2SV_blank>of<S2SV_blank>%s)"" , strrchr ( dirname , '/' ) + 1 , strrchr ( dup_of_dir , '/' ) + 1 ) ; delete_dump_dir ( dirname ) ; } int fd ; child_pid = spawn_event_handler_child ( work_dir , ( dup_of_dir ? ""notify-dup"" : ""notify"" ) , & fd ) ; xmove_fd ( fd , child_stdout_fd ) ; child_is_post_create = 0 ; strbuf_clear ( cmd_output ) ; free ( dup_of_dir ) ; dup_of_dir = NULL ; goto read_child_output ; delete_bad_dir : log_warning ( ""Deleting<S2SV_blank>problem<S2SV_blank>directory<S2SV_blank>\'%s\'"" , dirname ) ; delete_dump_dir ( dirname ) ; ret : strbuf_free ( cmd_output ) ; free ( dup_of_dir ) ; close ( child_stdout_fd ) ; return 0 ; }
","<S2SV_ModStart> 400 ; } if ( g_settings_privatereports ) { struct stat statbuf ; if ( lstat ( dirname , & statbuf ) != 0 || ! S_ISDIR ( statbuf . st_mode ) ) { error_msg ( ""Path<S2SV_blank>\'%s\'<S2SV_blank>isn\'t<S2SV_blank>directory"" , dirname ) ; return 404 ; } struct group * gr = getgrnam ( ""abrt"" ) ; if ( ! gr ) { error_msg ( ""Group<S2SV_blank>\'abrt\'<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist"" ) ; return 500 ; } if ( statbuf . st_uid != 0 || ! ( statbuf . st_gid == 0 || statbuf . st_gid == gr -> gr_gid ) || statbuf . st_mode & 07 ) { error_msg ( ""Problem<S2SV_blank>directory<S2SV_blank>\'%s\'<S2SV_blank>isn\'t<S2SV_blank>owned<S2SV_blank>by<S2SV_blank>root:abrt<S2SV_blank>or<S2SV_blank>others<S2SV_blank>are<S2SV_blank>not<S2SV_blank>restricted<S2SV_blank>from<S2SV_blank>access"" , dirname ) ; return 403 ; } struct dump_dir * dd = dd_opendir ( dirname , DD_OPEN_READONLY ) ; const bool complete = dd && problem_dump_dir_is_complete ( dd ) ; dd_close ( dd ) ; if ( complete ) { error_msg ( ""Problem<S2SV_blank>directory<S2SV_blank>\'%s\'<S2SV_blank>has<S2SV_blank>already<S2SV_blank>been<S2SV_blank>processed"" , dirname ) ; return 403 ; } } else
"
88,"CWE-284 void _modinit ( module_t * m ) { service_named_bind_command ( ""chanserv"" , & cs_flags ) ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> cs_flags ) ; add_bool_conf_item ( ""ANOPE_FLAGS_COMPAT"" , & chansvs . me -> conf_table , 0 , & anope_flags_compat , true ) ; hook_add_event ( ""nick_can_register"" ) ; hook_add_nick_can_register ( check_registration_keywords ) ; hook_add_event ( ""user_can_register"" ) ; hook_add_user_can_register ( check_registration_keywords ) ;
"
89,"CWE-119 static int PredictorEncodeTile ( TIFF * tif , uint8 * bp0 , tmsize_t cc0 , uint16 s ) { static const char module [ ] = ""PredictorEncodeTile"" ; TIFFPredictorState * sp = PredictorState ( tif ) ; uint8 * working_copy ; tmsize_t cc = cc0 , rowsize ; unsigned char * bp ; int result_code ; assert ( sp != NULL ) ; assert ( sp -> encodepfunc != NULL ) ; assert ( sp -> encodetile != NULL ) ; working_copy = ( uint8 * ) _TIFFmalloc ( cc0 ) ; if ( working_copy == NULL ) { TIFFErrorExt ( tif -> tif_clientdata , module , ""Out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>allocating<S2SV_blank>"" TIFF_SSIZE_FORMAT ""<S2SV_blank>byte<S2SV_blank>temp<S2SV_blank>buffer."" , cc0 ) ; return 0 ; } memcpy ( working_copy , bp0 , cc0 ) ; bp = working_copy ; rowsize = sp -> rowsize ; assert ( rowsize > 0 ) ; <S2SV_StartBug> assert ( ( cc0 % rowsize ) == 0 ) ; <S2SV_EndBug> while ( cc > 0 ) { ( * sp -> encodepfunc ) ( tif , bp , rowsize ) ; cc -= rowsize ; bp += rowsize ; } result_code = ( * sp -> encodetile ) ( tif , working_copy , cc0 , s ) ; _TIFFfree ( working_copy ) ; return result_code ; }
","<S2SV_ModStart> 0 ) ; if <S2SV_ModEnd> ( ( cc0 <S2SV_ModStart> % rowsize ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""PredictorEncodeTile"" , ""%s"" , ""(cc0%rowsize)!=0"" ) ; return 0 ; } <S2SV_ModEnd> while ( cc
"
90,"CWE-362 int ext4_setattr ( struct dentry * dentry , struct iattr * attr ) { struct inode * inode = d_inode ( dentry ) ; int error , rc = 0 ; int orphan = 0 ; const unsigned int ia_valid = attr -> ia_valid ; error = inode_change_ok ( inode , attr ) ; if ( error ) return error ; if ( is_quota_modification ( inode , attr ) ) { error = dquot_initialize ( inode ) ; if ( error ) return error ; } if ( ( ia_valid & ATTR_UID && ! uid_eq ( attr -> ia_uid , inode -> i_uid ) ) || ( ia_valid & ATTR_GID && ! gid_eq ( attr -> ia_gid , inode -> i_gid ) ) ) { handle_t * handle ; handle = ext4_journal_start ( inode , EXT4_HT_QUOTA , ( EXT4_MAXQUOTAS_INIT_BLOCKS ( inode -> i_sb ) + EXT4_MAXQUOTAS_DEL_BLOCKS ( inode -> i_sb ) ) + 3 ) ; if ( IS_ERR ( handle ) ) { error = PTR_ERR ( handle ) ; goto err_out ; } error = dquot_transfer ( inode , attr ) ; if ( error ) { ext4_journal_stop ( handle ) ; return error ; } if ( attr -> ia_valid & ATTR_UID ) inode -> i_uid = attr -> ia_uid ; if ( attr -> ia_valid & ATTR_GID ) inode -> i_gid = attr -> ia_gid ; error = ext4_mark_inode_dirty ( handle , inode ) ; ext4_journal_stop ( handle ) ; } if ( attr -> ia_valid & ATTR_SIZE ) { handle_t * handle ; loff_t oldsize = inode -> i_size ; int shrink = ( attr -> ia_size <= inode -> i_size ) ; if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) { struct ext4_sb_info * sbi = EXT4_SB ( inode -> i_sb ) ; if ( attr -> ia_size > sbi -> s_bitmap_maxbytes ) return - EFBIG ; } if ( ! S_ISREG ( inode -> i_mode ) ) return - EINVAL ; if ( IS_I_VERSION ( inode ) && attr -> ia_size != inode -> i_size ) inode_inc_iversion ( inode ) ; if ( ext4_should_order_data ( inode ) && ( attr -> ia_size < inode -> i_size ) ) { error = ext4_begin_ordered_truncate ( inode , attr -> ia_size ) ; if ( error ) goto err_out ; } if ( attr -> ia_size != inode -> i_size ) { handle = ext4_journal_start ( inode , EXT4_HT_INODE , 3 ) ; if ( IS_ERR ( handle ) ) { error = PTR_ERR ( handle ) ; goto err_out ; } if ( ext4_handle_valid ( handle ) && shrink ) { error = ext4_orphan_add ( handle , inode ) ; orphan = 1 ; } if ( ! shrink ) { inode -> i_mtime = ext4_current_time ( inode ) ; inode -> i_ctime = inode -> i_mtime ; } down_write ( & EXT4_I ( inode ) -> i_data_sem ) ; EXT4_I ( inode ) -> i_disksize = attr -> ia_size ; rc = ext4_mark_inode_dirty ( handle , inode ) ; if ( ! error ) error = rc ; if ( ! error ) i_size_write ( inode , attr -> ia_size ) ; up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; ext4_journal_stop ( handle ) ; if ( error ) { if ( orphan ) ext4_orphan_del ( NULL , inode ) ; goto err_out ; } } if ( ! shrink ) pagecache_isize_extended ( inode , oldsize , inode -> i_size ) ; if ( orphan ) { if ( ! ext4_should_journal_data ( inode ) ) { ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; ext4_inode_resume_unlocked_dio ( inode ) ; } else ext4_wait_for_tail_page_commit ( inode ) ; } <S2SV_StartBug> truncate_pagecache ( inode , inode -> i_size ) ; <S2SV_EndBug> if ( shrink ) <S2SV_StartBug> ext4_truncate ( inode ) ; <S2SV_EndBug> } if ( ! rc ) { setattr_copy ( inode , attr ) ; mark_inode_dirty ( inode ) ; } if ( orphan && inode -> i_nlink ) ext4_orphan_del ( NULL , inode ) ; if ( ! rc && ( ia_valid & ATTR_MODE ) ) rc = posix_acl_chmod ( inode , inode -> i_mode ) ; err_out : ext4_std_error ( inode -> i_sb , error ) ; if ( ! error ) error = rc ; return error ; }
","<S2SV_ModStart> ) ; } down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModStart> ext4_truncate ( inode ) ; up_write ( & EXT4_I ( inode ) -> i_mmap_sem
"
91,"CWE-264 static struct cifsSesInfo * cifs_get_smb_ses ( struct TCP_Server_Info * server , struct smb_vol * volume_info ) { int rc = - ENOMEM , xid ; struct cifsSesInfo * ses ; xid = GetXid ( ) ; <S2SV_StartBug> ses = cifs_find_smb_ses ( server , volume_info -> username ) ; <S2SV_EndBug> if ( ses ) { cFYI ( 1 , ""Existing<S2SV_blank>smb<S2SV_blank>sess<S2SV_blank>found<S2SV_blank>(status=%d)"" , ses -> status ) ; cifs_put_tcp_session ( server ) ; mutex_lock ( & ses -> session_mutex ) ; rc = cifs_negotiate_protocol ( xid , ses ) ; if ( rc ) { mutex_unlock ( & ses -> session_mutex ) ; cifs_put_smb_ses ( ses ) ; FreeXid ( xid ) ; return ERR_PTR ( rc ) ; } if ( ses -> need_reconnect ) { cFYI ( 1 , ""Session<S2SV_blank>needs<S2SV_blank>reconnect"" ) ; rc = cifs_setup_session ( xid , ses , volume_info -> local_nls ) ; if ( rc ) { mutex_unlock ( & ses -> session_mutex ) ; cifs_put_smb_ses ( ses ) ; FreeXid ( xid ) ; return ERR_PTR ( rc ) ; } } mutex_unlock ( & ses -> session_mutex ) ; FreeXid ( xid ) ; return ses ; } cFYI ( 1 , ""Existing<S2SV_blank>smb<S2SV_blank>sess<S2SV_blank>not<S2SV_blank>found"" ) ; ses = sesInfoAlloc ( ) ; if ( ses == NULL ) goto get_ses_fail ; ses -> server = server ; if ( server -> addr . sockAddr6 . sin6_family == AF_INET6 ) sprintf ( ses -> serverName , ""%pI6"" , & server -> addr . sockAddr6 . sin6_addr ) ; else sprintf ( ses -> serverName , ""%pI4"" , & server -> addr . sockAddr . sin_addr . s_addr ) ; if ( volume_info -> username ) strncpy ( ses -> userName , volume_info -> username , MAX_USERNAME_SIZE ) ; if ( volume_info -> password ) { ses -> password = kstrdup ( volume_info -> password , GFP_KERNEL ) ; if ( ! ses -> password ) goto get_ses_fail ; } if ( volume_info -> domainname ) { int len = strlen ( volume_info -> domainname ) ; ses -> domainName = kmalloc ( len + 1 , GFP_KERNEL ) ; if ( ses -> domainName ) strcpy ( ses -> domainName , volume_info -> domainname ) ; } ses -> linux_uid = volume_info -> linux_uid ; ses -> overrideSecFlg = volume_info -> secFlg ; mutex_lock ( & ses -> session_mutex ) ; rc = cifs_negotiate_protocol ( xid , ses ) ; if ( ! rc ) rc = cifs_setup_session ( xid , ses , volume_info -> local_nls ) ; mutex_unlock ( & ses -> session_mutex ) ; if ( rc ) goto get_ses_fail ; write_lock ( & cifs_tcp_ses_lock ) ; list_add ( & ses -> smb_ses_list , & server -> smb_ses_list ) ; write_unlock ( & cifs_tcp_ses_lock ) ; FreeXid ( xid ) ; return ses ; get_ses_fail : sesInfoFree ( ses ) ; FreeXid ( xid ) ; return ERR_PTR ( rc ) ; }
","<S2SV_ModStart> server , volume_info <S2SV_ModEnd> ) ; if
"
92,"CWE-189 static int perf_swevent_init ( struct perf_event * event ) { <S2SV_StartBug> int event_id = event -> attr . config ; <S2SV_EndBug> if ( event -> attr . type != PERF_TYPE_SOFTWARE ) return - ENOENT ; if ( has_branch_stack ( event ) ) return - EOPNOTSUPP ; switch ( event_id ) { case PERF_COUNT_SW_CPU_CLOCK : case PERF_COUNT_SW_TASK_CLOCK : return - ENOENT ; default : break ; } if ( event_id >= PERF_COUNT_SW_MAX ) return - ENOENT ; if ( ! event -> parent ) { int err ; err = swevent_hlist_get ( event ) ; if ( err ) return err ; static_key_slow_inc ( & perf_swevent_enabled [ event_id ] ) ; event -> destroy = sw_perf_event_destroy ; } return 0 ; }
","<S2SV_ModStart> event ) { u64 <S2SV_ModEnd> event_id = event
"
93,"CWE-310 unsigned long lh_char_hash ( const void * k ) { <S2SV_StartBug> unsigned int h = 0 ; <S2SV_EndBug> <S2SV_StartBug> const char * data = ( const char * ) k ; <S2SV_EndBug> while ( * data != 0 ) h = h * 129 + ( unsigned int ) ( * data ++ ) + LH_PRIME ; return h ; }
","<S2SV_ModStart> k ) { static volatile int random_seed = - 1 ; if ( random_seed == - 1 ) { int seed ; while ( ( seed = json_c_get_random_seed ( ) ) == - 1 ) ; # if defined __GNUC__ __sync_val_compare_and_swap ( & random_seed , - 1 , seed ) ; # elif defined _MSC_VER InterlockedCompareExchange ( & random_seed , seed , - 1 ) ; # else # warning ""racy<S2SV_blank>random<S2SV_blank>seed<S2SV_blank>initializtion<S2SV_blank>if<S2SV_blank>used<S2SV_blank>by<S2SV_blank>multiple<S2SV_blank>threads"" random_seed = seed ; # endif } return hashlittle ( <S2SV_ModEnd> ( const char <S2SV_ModStart> * ) k , strlen ( ( const char * ) k ) , random_seed ) <S2SV_ModEnd> ; } <S2SV_null>
"
94,"CWE-552 static ssize_t _consolefs_read ( oe_fd_t * file_ , void * buf , size_t count ) { ssize_t ret = - 1 ; file_t * file = _cast_file ( file_ ) ; <S2SV_StartBug> if ( ! file ) <S2SV_EndBug> OE_RAISE_ERRNO ( OE_EINVAL ) ; if ( oe_syscall_read_ocall ( & ret , file -> host_fd , buf , count ) != OE_OK ) OE_RAISE_ERRNO ( OE_EINVAL ) ; <S2SV_StartBug> done : <S2SV_EndBug> return ret ; }
","<S2SV_ModStart> ( ! file || count > OE_SSIZE_MAX <S2SV_ModStart> OE_EINVAL ) ; if ( ret > ( ssize_t ) count ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; }
"
95,"CWE-000 static uint16_t http_dissect_hdrs ( struct worker * w , struct http * hp , int fd , char * p , const struct http_conn * htc ) { char * q , * r ; txt t = htc -> rxbuf ; if ( * p == '\\r' ) p ++ ; hp -> nhd = HTTP_HDR_FIRST ; hp -> conds = 0 ; r = NULL ; for ( ; p < t . e ; p = r ) { q = r = p ; while ( r < t . e ) { <S2SV_StartBug> if ( ! vct_iscrlf ( * r ) ) { <S2SV_EndBug> r ++ ; continue ; } q = r ; assert ( r < t . e ) ; r += vct_skipcrlf ( r ) ; if ( r >= t . e ) break ; if ( ! vct_issp ( * r ) ) break ; while ( vct_islws ( * q ) ) * q ++ = '<S2SV_blank>' ; } if ( q - p > htc -> maxhdr ) { VSC_C_main -> losthdr ++ ; WSL ( w , SLT_LostHeader , fd , ""%.*s"" , q - p > 20 ? 20 : q - p , p ) ; return ( 413 ) ; } if ( p == q ) break ; if ( ( p [ 0 ] == 'i' || p [ 0 ] == 'I' ) && ( p [ 1 ] == 'f' || p [ 1 ] == 'F' ) && p [ 2 ] == '-' ) hp -> conds = 1 ; while ( q > p && vct_issp ( q [ - 1 ] ) ) q -- ; * q = '\\0' ; if ( hp -> nhd < hp -> shd ) { hp -> hdf [ hp -> nhd ] = 0 ; hp -> hd [ hp -> nhd ] . b = p ; hp -> hd [ hp -> nhd ] . e = q ; WSLH ( w , fd , hp , hp -> nhd ) ; hp -> nhd ++ ; } else { VSC_C_main -> losthdr ++ ; WSL ( w , SLT_LostHeader , fd , ""%.*s"" , q - p > 20 ? 20 : q - p , p ) ; return ( 413 ) ; } } return ( 0 ) ; }
","<S2SV_ModStart> ! vct_iscrlf ( <S2SV_ModEnd> r ) )
"
96,"CWE-119 static Image * ReadWPGImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { typedef struct { size_t FileId ; MagickOffsetType DataOffset ; unsigned int ProductType ; unsigned int FileType ; unsigned char MajorVersion ; unsigned char MinorVersion ; unsigned int EncryptKey ; unsigned int Reserved ; } WPGHeader ; typedef struct { unsigned char RecType ; size_t RecordLength ; } WPGRecord ; typedef struct { unsigned char Class ; unsigned char RecType ; size_t Extension ; size_t RecordLength ; } WPG2Record ; typedef struct { unsigned HorizontalUnits ; unsigned VerticalUnits ; unsigned char PosSizePrecision ; } WPG2Start ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType1 ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned char Depth ; unsigned char Compression ; } WPG2BitmapType1 ; typedef struct { unsigned int RotAngle ; unsigned int LowLeftX ; unsigned int LowLeftY ; unsigned int UpRightX ; unsigned int UpRightY ; unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType2 ; typedef struct { unsigned int StartIndex ; unsigned int NumOfEntries ; } WPGColorMapRec ; Image * image ; unsigned int status ; WPGHeader Header ; WPGRecord Rec ; WPG2Record Rec2 ; WPG2Start StartWPG ; WPGBitmapType1 BitmapHeader1 ; WPG2BitmapType1 Bitmap2Header1 ; WPGBitmapType2 BitmapHeader2 ; WPGColorMapRec WPG_Palette ; int i , bpp , WPG2Flags ; ssize_t ldblk ; size_t one ; unsigned char * BImgBuff ; tCTM CTM ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; one = 1 ; image = AcquireImage ( image_info ) ; image -> depth = 8 ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } Header . FileId = ReadBlobLSBLong ( image ) ; Header . DataOffset = ( MagickOffsetType ) ReadBlobLSBLong ( image ) ; Header . ProductType = ReadBlobLSBShort ( image ) ; Header . FileType = ReadBlobLSBShort ( image ) ; Header . MajorVersion = ReadBlobByte ( image ) ; Header . MinorVersion = ReadBlobByte ( image ) ; Header . EncryptKey = ReadBlobLSBShort ( image ) ; Header . Reserved = ReadBlobLSBShort ( image ) ; if ( Header . FileId != 0x435057FF || ( Header . ProductType >> 8 ) != 0x16 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( Header . EncryptKey != 0 ) ThrowReaderException ( CoderError , ""EncryptedWPGImageFileNotSupported"" ) ; image -> columns = 1 ; image -> rows = 1 ; image -> colors = 0 ; bpp = 0 ; BitmapHeader2 . RotAngle = 0 ; Rec2 . RecordLength = 0 ; switch ( Header . FileType ) { case 1 : while ( ! EOFBlob ( image ) ) { ( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ; if ( EOFBlob ( image ) ) break ; Rec . RecType = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rd_WP_DWORD ( image , & Rec . RecordLength ) ; if ( Rec . RecordLength > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( EOFBlob ( image ) ) break ; Header . DataOffset = TellBlob ( image ) + Rec . RecordLength ; switch ( Rec . RecType ) { case 0x0B : BitmapHeader1 . Width = ReadBlobLSBShort ( image ) ; BitmapHeader1 . Height = ReadBlobLSBShort ( image ) ; if ( ( BitmapHeader1 . Width == 0 ) || ( BitmapHeader1 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; BitmapHeader1 . Depth = ReadBlobLSBShort ( image ) ; BitmapHeader1 . HorzRes = ReadBlobLSBShort ( image ) ; BitmapHeader1 . VertRes = ReadBlobLSBShort ( image ) ; if ( BitmapHeader1 . HorzRes && BitmapHeader1 . VertRes ) { image -> units = PixelsPerCentimeterResolution ; image -> x_resolution = BitmapHeader1 . HorzRes / 470.0 ; image -> y_resolution = BitmapHeader1 . VertRes / 470.0 ; } image -> columns = BitmapHeader1 . Width ; image -> rows = BitmapHeader1 . Height ; bpp = BitmapHeader1 . Depth ; goto UnpackRaster ; case 0x0E : WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ; WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ; if ( ( WPG_Palette . NumOfEntries - WPG_Palette . StartIndex ) > <S2SV_StartBug> ( Rec2 . RecordLength - 2 - 2 ) / 3 ) <S2SV_EndBug> ThrowReaderException ( CorruptImageError , ""InvalidColormapIndex"" ) ; image -> colors = WPG_Palette . NumOfEntries ; if ( ! AcquireImageColormap ( image , image -> colors ) ) goto NoMemory ; for ( i = WPG_Palette . StartIndex ; i < ( int ) WPG_Palette . NumOfEntries ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; } break ; case 0x11 : if ( Rec . RecordLength > 8 ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + 8 , ( ssize_t ) Rec . RecordLength - 8 , exception ) ; break ; case 0x14 : BitmapHeader2 . RotAngle = ReadBlobLSBShort ( image ) ; BitmapHeader2 . LowLeftX = ReadBlobLSBShort ( image ) ; BitmapHeader2 . LowLeftY = ReadBlobLSBShort ( image ) ; BitmapHeader2 . UpRightX = ReadBlobLSBShort ( image ) ; BitmapHeader2 . UpRightY = ReadBlobLSBShort ( image ) ; BitmapHeader2 . Width = ReadBlobLSBShort ( image ) ; BitmapHeader2 . Height = ReadBlobLSBShort ( image ) ; if ( ( BitmapHeader2 . Width == 0 ) || ( BitmapHeader2 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; BitmapHeader2 . Depth = ReadBlobLSBShort ( image ) ; BitmapHeader2 . HorzRes = ReadBlobLSBShort ( image ) ; BitmapHeader2 . VertRes = ReadBlobLSBShort ( image ) ; image -> units = PixelsPerCentimeterResolution ; image -> page . width = ( unsigned int ) ( ( BitmapHeader2 . LowLeftX - BitmapHeader2 . UpRightX ) / 470.0 ) ; image -> page . height = ( unsigned int ) ( ( BitmapHeader2 . LowLeftX - BitmapHeader2 . UpRightY ) / 470.0 ) ; image -> page . x = ( int ) ( BitmapHeader2 . LowLeftX / 470.0 ) ; image -> page . y = ( int ) ( BitmapHeader2 . LowLeftX / 470.0 ) ; if ( BitmapHeader2 . HorzRes && BitmapHeader2 . VertRes ) { image -> x_resolution = BitmapHeader2 . HorzRes / 470.0 ; image -> y_resolution = BitmapHeader2 . VertRes / 470.0 ; } image -> columns = BitmapHeader2 . Width ; image -> rows = BitmapHeader2 . Height ; bpp = BitmapHeader2 . Depth ; UnpackRaster : status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) break ; if ( ( image -> colors == 0 ) && ( bpp <= 16 ) ) { image -> colors = one << bpp ; if ( ! AcquireImageColormap ( image , image -> colors ) ) { NoMemory : ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } for ( i = 0 ; ( i < ( int ) image -> colors ) && ( i < 256 ) ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( WPG1_Palette [ i ] . Red ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( WPG1_Palette [ i ] . Green ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( WPG1_Palette [ i ] . Blue ) ; } } else { if ( bpp < 24 ) if ( ( image -> colors < ( one << bpp ) ) && ( bpp != 24 ) ) image -> colormap = ( PixelPacket * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ; } if ( bpp == 1 ) { if ( image -> colormap [ 0 ] . red == 0 && image -> colormap [ 0 ] . green == 0 && image -> colormap [ 0 ] . blue == 0 && image -> colormap [ 1 ] . red == 0 && image -> colormap [ 1 ] . green == 0 && image -> colormap [ 1 ] . blue == 0 ) { image -> colormap [ 1 ] . red = image -> colormap [ 1 ] . green = image -> colormap [ 1 ] . blue = QuantumRange ; } } if ( UnpackWPGRaster ( image , bpp ) < 0 ) { DecompressionFailed : ThrowReaderException ( CoderError , ""UnableToDecompressImage"" ) ; } if ( Rec . RecType == 0x14 && BitmapHeader2 . RotAngle != 0 && ! image_info -> ping ) { if ( BitmapHeader2 . RotAngle & 0x8000 ) { Image * flop_image ; flop_image = FlopImage ( image , exception ) ; if ( flop_image != ( Image * ) NULL ) { DuplicateBlob ( flop_image , image ) ; ReplaceImageInList ( & image , flop_image ) ; } } if ( BitmapHeader2 . RotAngle & 0x2000 ) { Image * flip_image ; flip_image = FlipImage ( image , exception ) ; if ( flip_image != ( Image * ) NULL ) { DuplicateBlob ( flip_image , image ) ; ReplaceImageInList ( & image , flip_image ) ; } } if ( BitmapHeader2 . RotAngle & 0x0FFF ) { Image * rotate_image ; rotate_image = RotateImage ( image , ( BitmapHeader2 . RotAngle & 0x0FFF ) , exception ) ; if ( rotate_image != ( Image * ) NULL ) { DuplicateBlob ( rotate_image , image ) ; ReplaceImageInList ( & image , rotate_image ) ; } } } AcquireNextImage ( image_info , image ) ; image -> depth = 8 ; if ( image -> next == ( Image * ) NULL ) goto Finish ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 1 ; image -> colors = 0 ; break ; case 0x1B : if ( Rec . RecordLength > 0x3C ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + 0x3C , ( ssize_t ) Rec . RecordLength - 0x3C , exception ) ; break ; } } break ; case 2 : ( void ) memset ( CTM , 0 , sizeof ( CTM ) ) ; StartWPG . PosSizePrecision = 0 ; while ( ! EOFBlob ( image ) ) { ( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ; if ( EOFBlob ( image ) ) break ; Rec2 . Class = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rec2 . RecType = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rd_WP_DWORD ( image , & Rec2 . Extension ) ; Rd_WP_DWORD ( image , & Rec2 . RecordLength ) ; if ( EOFBlob ( image ) ) break ; Header . DataOffset = TellBlob ( image ) + Rec2 . RecordLength ; switch ( Rec2 . RecType ) { case 1 : StartWPG . HorizontalUnits = ReadBlobLSBShort ( image ) ; StartWPG . VerticalUnits = ReadBlobLSBShort ( image ) ; StartWPG . PosSizePrecision = ReadBlobByte ( image ) ; break ; case 0x0C : WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ; WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ; if ( ( WPG_Palette . NumOfEntries - WPG_Palette . StartIndex ) > ( Rec2 . RecordLength - 2 - 2 ) / 3 ) ThrowReaderException ( CorruptImageError , ""InvalidColormapIndex"" ) ; image -> colors = WPG_Palette . NumOfEntries ; if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = WPG_Palette . StartIndex ; i < ( int ) WPG_Palette . NumOfEntries ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; ( void ) ReadBlobByte ( image ) ; } break ; case 0x0E : Bitmap2Header1 . Width = ReadBlobLSBShort ( image ) ; Bitmap2Header1 . Height = ReadBlobLSBShort ( image ) ; if ( ( Bitmap2Header1 . Width == 0 ) || ( Bitmap2Header1 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; Bitmap2Header1 . Depth = ReadBlobByte ( image ) ; Bitmap2Header1 . Compression = ReadBlobByte ( image ) ; if ( Bitmap2Header1 . Compression > 1 ) continue ; switch ( Bitmap2Header1 . Depth ) { case 1 : bpp = 1 ; break ; case 2 : bpp = 2 ; break ; case 3 : bpp = 4 ; break ; case 4 : bpp = 8 ; break ; case 8 : bpp = 24 ; break ; default : continue ; } image -> columns = Bitmap2Header1 . Width ; image -> rows = Bitmap2Header1 . Height ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) break ; if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) { size_t one ; one = 1 ; image -> colors = one << bpp ; if ( ! AcquireImageColormap ( image , image -> colors ) ) goto NoMemory ; } else { if ( bpp < 24 ) if ( image -> colors < ( one << bpp ) && bpp != 24 ) image -> colormap = ( PixelPacket * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ; } switch ( Bitmap2Header1 . Compression ) { case 0 : { ldblk = ( ssize_t ) ( ( bpp * image -> columns + 7 ) / 8 ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ldblk + 1 , sizeof ( * BImgBuff ) ) ; if ( BImgBuff == ( unsigned char * ) NULL ) goto NoMemory ; for ( i = 0 ; i < ( ssize_t ) image -> rows ; i ++ ) { ( void ) ReadBlob ( image , ldblk , BImgBuff ) ; InsertRow ( BImgBuff , i , image , bpp ) ; } if ( BImgBuff ) BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ; break ; } case 1 : { if ( UnpackWPG2Raster ( image , bpp ) < 0 ) goto DecompressionFailed ; break ; } } if ( CTM [ 0 ] [ 0 ] < 0 && ! image_info -> ping ) { Image * flop_image ; flop_image = FlopImage ( image , exception ) ; if ( flop_image != ( Image * ) NULL ) { DuplicateBlob ( flop_image , image ) ; ReplaceImageInList ( & image , flop_image ) ; } } if ( CTM [ 1 ] [ 1 ] < 0 && ! image_info -> ping ) { Image * flip_image ; flip_image = FlipImage ( image , exception ) ; if ( flip_image != ( Image * ) NULL ) { DuplicateBlob ( flip_image , image ) ; ReplaceImageInList ( & image , flip_image ) ; } } AcquireNextImage ( image_info , image ) ; image -> depth = 8 ; if ( image -> next == ( Image * ) NULL ) goto Finish ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 1 ; image -> colors = 0 ; break ; case 0x12 : i = ReadBlobLSBShort ( image ) ; if ( Rec2 . RecordLength > ( unsigned int ) i ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + i , ( ssize_t ) ( Rec2 . RecordLength - i - 2 ) , exception ) ; break ; case 0x1B : WPG2Flags = LoadWPG2Flags ( image , StartWPG . PosSizePrecision , NULL , & CTM ) ; ( void ) WPG2Flags ; break ; } } break ; default : { ThrowReaderException ( CoderError , ""DataEncodingSchemeIsNotSupported"" ) ; } } Finish : ( void ) CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = ( size_t ) scene ++ ; } if ( image == ( Image * ) NULL ) ThrowReaderException ( CorruptImageError , ""ImageFileDoesNotContainAnyImageData"" ) ; return ( image ) ; }
","<S2SV_ModStart> ) / 3 ) ThrowReaderException ( CorruptImageError , ""InvalidColormapIndex"" ) ; if ( WPG_Palette . StartIndex > WPG_Palette . NumOfEntries
"
97,"CWE-000 void luaV_execute ( lua_State * L , CallInfo * ci ) { LClosure * cl ; TValue * k ; StkId base ; const Instruction * pc ; int trap ; # if LUA_USE_JUMPTABLE # include ""ljumptab.h"" # endif tailcall : trap = L -> hookmask ; cl = clLvalue ( s2v ( ci -> func ) ) ; k = cl -> p -> k ; pc = ci -> u . l . savedpc ; if ( trap ) { if ( cl -> p -> is_vararg ) trap = 0 ; else if ( pc == cl -> p -> code ) luaD_hookcall ( L , ci ) ; ci -> u . l . trap = 1 ; } base = ci -> func + 1 ; for ( ; ; ) { Instruction i ; StkId ra ; vmfetch ( ) ; lua_assert ( base == ci -> func + 1 ) ; lua_assert ( base <= L -> top && L -> top < L -> stack + L -> stacksize ) ; lua_assert ( isIT ( i ) || ( cast_void ( L -> top = base ) , 1 ) ) ; vmdispatch ( GET_OPCODE ( i ) ) { vmcase ( OP_MOVE ) { setobjs2s ( L , ra , RB ( i ) ) ; vmbreak ; } vmcase ( OP_LOADI ) { lua_Integer b = GETARG_sBx ( i ) ; setivalue ( s2v ( ra ) , b ) ; vmbreak ; } vmcase ( OP_LOADF ) { int b = GETARG_sBx ( i ) ; setfltvalue ( s2v ( ra ) , cast_num ( b ) ) ; vmbreak ; } vmcase ( OP_LOADK ) { TValue * rb = k + GETARG_Bx ( i ) ; setobj2s ( L , ra , rb ) ; vmbreak ; } vmcase ( OP_LOADKX ) { TValue * rb ; rb = k + GETARG_Ax ( * pc ) ; pc ++ ; setobj2s ( L , ra , rb ) ; vmbreak ; } vmcase ( OP_LOADFALSE ) { setbfvalue ( s2v ( ra ) ) ; vmbreak ; } vmcase ( OP_LFALSESKIP ) { setbfvalue ( s2v ( ra ) ) ; pc ++ ; vmbreak ; } vmcase ( OP_LOADTRUE ) { setbtvalue ( s2v ( ra ) ) ; vmbreak ; } vmcase ( OP_LOADNIL ) { int b = GETARG_B ( i ) ; do { setnilvalue ( s2v ( ra ++ ) ) ; } while ( b -- ) ; vmbreak ; } vmcase ( OP_GETUPVAL ) { int b = GETARG_B ( i ) ; setobj2s ( L , ra , cl -> upvals [ b ] -> v ) ; vmbreak ; } vmcase ( OP_SETUPVAL ) { UpVal * uv = cl -> upvals [ GETARG_B ( i ) ] ; setobj ( L , uv -> v , s2v ( ra ) ) ; luaC_barrier ( L , uv , s2v ( ra ) ) ; vmbreak ; } vmcase ( OP_GETTABUP ) { const TValue * slot ; TValue * upval = cl -> upvals [ GETARG_B ( i ) ] -> v ; TValue * rc = KC ( i ) ; TString * key = tsvalue ( rc ) ; if ( luaV_fastget ( L , upval , key , slot , luaH_getshortstr ) ) { setobj2s ( L , ra , slot ) ; } else Protect ( luaV_finishget ( L , upval , rc , ra , slot ) ) ; vmbreak ; } vmcase ( OP_GETTABLE ) { const TValue * slot ; TValue * rb = vRB ( i ) ; TValue * rc = vRC ( i ) ; lua_Unsigned n ; if ( ttisinteger ( rc ) ? ( cast_void ( n = ivalue ( rc ) ) , luaV_fastgeti ( L , rb , n , slot ) ) : luaV_fastget ( L , rb , rc , slot , luaH_get ) ) { setobj2s ( L , ra , slot ) ; } else Protect ( luaV_finishget ( L , rb , rc , ra , slot ) ) ; vmbreak ; } vmcase ( OP_GETI ) { const TValue * slot ; TValue * rb = vRB ( i ) ; int c = GETARG_C ( i ) ; if ( luaV_fastgeti ( L , rb , c , slot ) ) { setobj2s ( L , ra , slot ) ; } else { TValue key ; setivalue ( & key , c ) ; Protect ( luaV_finishget ( L , rb , & key , ra , slot ) ) ; } vmbreak ; } vmcase ( OP_GETFIELD ) { const TValue * slot ; TValue * rb = vRB ( i ) ; TValue * rc = KC ( i ) ; TString * key = tsvalue ( rc ) ; if ( luaV_fastget ( L , rb , key , slot , luaH_getshortstr ) ) { setobj2s ( L , ra , slot ) ; } else Protect ( luaV_finishget ( L , rb , rc , ra , slot ) ) ; vmbreak ; } vmcase ( OP_SETTABUP ) { const TValue * slot ; TValue * upval = cl -> upvals [ GETARG_A ( i ) ] -> v ; TValue * rb = KB ( i ) ; TValue * rc = RKC ( i ) ; TString * key = tsvalue ( rb ) ; if ( luaV_fastget ( L , upval , key , slot , luaH_getshortstr ) ) { luaV_finishfastset ( L , upval , slot , rc ) ; } else Protect ( luaV_finishset ( L , upval , rb , rc , slot ) ) ; vmbreak ; } vmcase ( OP_SETTABLE ) { const TValue * slot ; TValue * rb = vRB ( i ) ; TValue * rc = RKC ( i ) ; lua_Unsigned n ; if ( ttisinteger ( rb ) ? ( cast_void ( n = ivalue ( rb ) ) , luaV_fastgeti ( L , s2v ( ra ) , n , slot ) ) : luaV_fastget ( L , s2v ( ra ) , rb , slot , luaH_get ) ) { luaV_finishfastset ( L , s2v ( ra ) , slot , rc ) ; } else Protect ( luaV_finishset ( L , s2v ( ra ) , rb , rc , slot ) ) ; vmbreak ; } vmcase ( OP_SETI ) { const TValue * slot ; int c = GETARG_B ( i ) ; TValue * rc = RKC ( i ) ; if ( luaV_fastgeti ( L , s2v ( ra ) , c , slot ) ) { luaV_finishfastset ( L , s2v ( ra ) , slot , rc ) ; } else { TValue key ; setivalue ( & key , c ) ; Protect ( luaV_finishset ( L , s2v ( ra ) , & key , rc , slot ) ) ; } vmbreak ; } vmcase ( OP_SETFIELD ) { const TValue * slot ; TValue * rb = KB ( i ) ; TValue * rc = RKC ( i ) ; TString * key = tsvalue ( rb ) ; if ( luaV_fastget ( L , s2v ( ra ) , key , slot , luaH_getshortstr ) ) { luaV_finishfastset ( L , s2v ( ra ) , slot , rc ) ; } else Protect ( luaV_finishset ( L , s2v ( ra ) , rb , rc , slot ) ) ; vmbreak ; } vmcase ( OP_NEWTABLE ) { int b = GETARG_B ( i ) ; int c = GETARG_C ( i ) ; Table * t ; if ( b > 0 ) b = 1 << ( b - 1 ) ; lua_assert ( ( ! TESTARG_k ( i ) ) == ( GETARG_Ax ( * pc ) == 0 ) ) ; if ( TESTARG_k ( i ) ) c += GETARG_Ax ( * pc ) * ( MAXARG_C + 1 ) ; pc ++ ; L -> top = ra + 1 ; t = luaH_new ( L ) ; sethvalue2s ( L , ra , t ) ; if ( b != 0 || c != 0 ) luaH_resize ( L , t , c , b ) ; checkGC ( L , ra + 1 ) ; vmbreak ; } vmcase ( OP_SELF ) { const TValue * slot ; TValue * rb = vRB ( i ) ; TValue * rc = RKC ( i ) ; TString * key = tsvalue ( rc ) ; setobj2s ( L , ra + 1 , rb ) ; if ( luaV_fastget ( L , rb , key , slot , luaH_getstr ) ) { setobj2s ( L , ra , slot ) ; } else Protect ( luaV_finishget ( L , rb , rc , ra , slot ) ) ; vmbreak ; } vmcase ( OP_ADDI ) { op_arithI ( L , l_addi , luai_numadd ) ; vmbreak ; } vmcase ( OP_ADDK ) { op_arithK ( L , l_addi , luai_numadd ) ; vmbreak ; } vmcase ( OP_SUBK ) { op_arithK ( L , l_subi , luai_numsub ) ; vmbreak ; } vmcase ( OP_MULK ) { op_arithK ( L , l_muli , luai_nummul ) ; vmbreak ; } vmcase ( OP_MODK ) { op_arithK ( L , luaV_mod , luaV_modf ) ; vmbreak ; } vmcase ( OP_POWK ) { op_arithfK ( L , luai_numpow ) ; vmbreak ; } vmcase ( OP_DIVK ) { op_arithfK ( L , luai_numdiv ) ; vmbreak ; } vmcase ( OP_IDIVK ) { op_arithK ( L , luaV_idiv , luai_numidiv ) ; vmbreak ; } vmcase ( OP_BANDK ) { op_bitwiseK ( L , l_band ) ; vmbreak ; } vmcase ( OP_BORK ) { op_bitwiseK ( L , l_bor ) ; vmbreak ; } vmcase ( OP_BXORK ) { op_bitwiseK ( L , l_bxor ) ; vmbreak ; } vmcase ( OP_SHRI ) { TValue * rb = vRB ( i ) ; int ic = GETARG_sC ( i ) ; lua_Integer ib ; if ( tointegerns ( rb , & ib ) ) { pc ++ ; setivalue ( s2v ( ra ) , luaV_shiftl ( ib , - ic ) ) ; } vmbreak ; } vmcase ( OP_SHLI ) { TValue * rb = vRB ( i ) ; int ic = GETARG_sC ( i ) ; lua_Integer ib ; if ( tointegerns ( rb , & ib ) ) { pc ++ ; setivalue ( s2v ( ra ) , luaV_shiftl ( ic , ib ) ) ; } vmbreak ; } vmcase ( OP_ADD ) { op_arith ( L , l_addi , luai_numadd ) ; vmbreak ; } vmcase ( OP_SUB ) { op_arith ( L , l_subi , luai_numsub ) ; vmbreak ; } vmcase ( OP_MUL ) { op_arith ( L , l_muli , luai_nummul ) ; vmbreak ; } vmcase ( OP_MOD ) { op_arith ( L , luaV_mod , luaV_modf ) ; vmbreak ; } vmcase ( OP_POW ) { op_arithf ( L , luai_numpow ) ; vmbreak ; } vmcase ( OP_DIV ) { op_arithf ( L , luai_numdiv ) ; vmbreak ; } vmcase ( OP_IDIV ) { op_arith ( L , luaV_idiv , luai_numidiv ) ; vmbreak ; } vmcase ( OP_BAND ) { op_bitwise ( L , l_band ) ; vmbreak ; } vmcase ( OP_BOR ) { op_bitwise ( L , l_bor ) ; vmbreak ; } vmcase ( OP_BXOR ) { op_bitwise ( L , l_bxor ) ; vmbreak ; } vmcase ( OP_SHR ) { op_bitwise ( L , luaV_shiftr ) ; vmbreak ; } vmcase ( OP_SHL ) { op_bitwise ( L , luaV_shiftl ) ; vmbreak ; } vmcase ( OP_MMBIN ) { Instruction pi = * ( pc - 2 ) ; TValue * rb = vRB ( i ) ; TMS tm = ( TMS ) GETARG_C ( i ) ; StkId result = RA ( pi ) ; lua_assert ( OP_ADD <= GET_OPCODE ( pi ) && GET_OPCODE ( pi ) <= OP_SHR ) ; Protect ( luaT_trybinTM ( L , s2v ( ra ) , rb , result , tm ) ) ; vmbreak ; } vmcase ( OP_MMBINI ) { Instruction pi = * ( pc - 2 ) ; int imm = GETARG_sB ( i ) ; TMS tm = ( TMS ) GETARG_C ( i ) ; int flip = GETARG_k ( i ) ; StkId result = RA ( pi ) ; Protect ( luaT_trybiniTM ( L , s2v ( ra ) , imm , flip , result , tm ) ) ; vmbreak ; } vmcase ( OP_MMBINK ) { Instruction pi = * ( pc - 2 ) ; TValue * imm = KB ( i ) ; TMS tm = ( TMS ) GETARG_C ( i ) ; int flip = GETARG_k ( i ) ; StkId result = RA ( pi ) ; Protect ( luaT_trybinassocTM ( L , s2v ( ra ) , imm , flip , result , tm ) ) ; vmbreak ; } vmcase ( OP_UNM ) { TValue * rb = vRB ( i ) ; lua_Number nb ; if ( ttisinteger ( rb ) ) { lua_Integer ib = ivalue ( rb ) ; setivalue ( s2v ( ra ) , intop ( - , 0 , ib ) ) ; } else if ( tonumberns ( rb , nb ) ) { setfltvalue ( s2v ( ra ) , luai_numunm ( L , nb ) ) ; } else Protect ( luaT_trybinTM ( L , rb , rb , ra , TM_UNM ) ) ; vmbreak ; } vmcase ( OP_BNOT ) { TValue * rb = vRB ( i ) ; lua_Integer ib ; if ( tointegerns ( rb , & ib ) ) { setivalue ( s2v ( ra ) , intop ( ^ , ~ l_castS2U ( 0 ) , ib ) ) ; } else Protect ( luaT_trybinTM ( L , rb , rb , ra , TM_BNOT ) ) ; vmbreak ; } vmcase ( OP_NOT ) { TValue * rb = vRB ( i ) ; if ( l_isfalse ( rb ) ) setbtvalue ( s2v ( ra ) ) ; else setbfvalue ( s2v ( ra ) ) ; vmbreak ; } vmcase ( OP_LEN ) { Protect ( luaV_objlen ( L , ra , vRB ( i ) ) ) ; vmbreak ; } vmcase ( OP_CONCAT ) { int n = GETARG_B ( i ) ; L -> top = ra + n ; ProtectNT ( luaV_concat ( L , n ) ) ; checkGC ( L , L -> top ) ; vmbreak ; } vmcase ( OP_CLOSE ) { Protect ( luaF_close ( L , ra , LUA_OK ) ) ; vmbreak ; } vmcase ( OP_TBC ) { halfProtect ( luaF_newtbcupval ( L , ra ) ) ; vmbreak ; } vmcase ( OP_JMP ) { dojump ( ci , i , 0 ) ; vmbreak ; } vmcase ( OP_EQ ) { int cond ; TValue * rb = vRB ( i ) ; Protect ( cond = luaV_equalobj ( L , s2v ( ra ) , rb ) ) ; docondjump ( ) ; vmbreak ; } vmcase ( OP_LT ) { op_order ( L , l_lti , LTnum , lessthanothers ) ; vmbreak ; } vmcase ( OP_LE ) { op_order ( L , l_lei , LEnum , lessequalothers ) ; vmbreak ; } vmcase ( OP_EQK ) { TValue * rb = KB ( i ) ; int cond = luaV_rawequalobj ( s2v ( ra ) , rb ) ; docondjump ( ) ; vmbreak ; } vmcase ( OP_EQI ) { int cond ; int im = GETARG_sB ( i ) ; if ( ttisinteger ( s2v ( ra ) ) ) cond = ( ivalue ( s2v ( ra ) ) == im ) ; else if ( ttisfloat ( s2v ( ra ) ) ) cond = luai_numeq ( fltvalue ( s2v ( ra ) ) , cast_num ( im ) ) ; else cond = 0 ; docondjump ( ) ; vmbreak ; } vmcase ( OP_LTI ) { op_orderI ( L , l_lti , luai_numlt , 0 , TM_LT ) ; vmbreak ; } vmcase ( OP_LEI ) { op_orderI ( L , l_lei , luai_numle , 0 , TM_LE ) ; vmbreak ; } vmcase ( OP_GTI ) { op_orderI ( L , l_gti , luai_numgt , 1 , TM_LT ) ; vmbreak ; } vmcase ( OP_GEI ) { op_orderI ( L , l_gei , luai_numge , 1 , TM_LE ) ; vmbreak ; } vmcase ( OP_TEST ) { int cond = ! l_isfalse ( s2v ( ra ) ) ; docondjump ( ) ; vmbreak ; } vmcase ( OP_TESTSET ) { TValue * rb = vRB ( i ) ; if ( l_isfalse ( rb ) == GETARG_k ( i ) ) pc ++ ; else { setobj2s ( L , ra , rb ) ; donextjump ( ci ) ; } vmbreak ; } vmcase ( OP_CALL ) { int b = GETARG_B ( i ) ; int nresults = GETARG_C ( i ) - 1 ; if ( b != 0 ) L -> top = ra + b ; ProtectNT ( luaD_call ( L , ra , nresults ) ) ; vmbreak ; } vmcase ( OP_TAILCALL ) { int b = GETARG_B ( i ) ; int nparams1 = GETARG_C ( i ) ; int delta = ( nparams1 ) ? ci -> u . l . nextraargs + nparams1 : 0 ; if ( b != 0 ) L -> top = ra + b ; else b = cast_int ( L -> top - ra ) ; savepc ( ci ) ; if ( TESTARG_k ( i ) ) { luaF_close ( L , base , NOCLOSINGMETH ) ; lua_assert ( base == ci -> func + 1 ) ; } while ( ! ttisfunction ( s2v ( ra ) ) ) { luaD_tryfuncTM ( L , ra ) ; b ++ ; checkstackGCp ( L , 1 , ra ) ; } if ( ! ttisLclosure ( s2v ( ra ) ) ) { luaD_call ( L , ra , LUA_MULTRET ) ; updatetrap ( ci ) ; updatestack ( ci ) ; ci -> func -= delta ; luaD_poscall ( L , ci , cast_int ( L -> top - ra ) ) ; return ; } ci -> func -= delta ; luaD_pretailcall ( L , ci , ra , b ) ; goto tailcall ; } vmcase ( OP_RETURN ) { int n = GETARG_B ( i ) - 1 ; int nparams1 = GETARG_C ( i ) ; if ( n < 0 ) n = cast_int ( L -> top - ra ) ; savepc ( ci ) ; if ( TESTARG_k ( i ) ) { if ( L -> top < ci -> top ) L -> top = ci -> top ; luaF_close ( L , base , LUA_OK ) ; updatetrap ( ci ) ; updatestack ( ci ) ; } if ( nparams1 ) ci -> func -= ci -> u . l . nextraargs + nparams1 ; L -> top = ra + n ; luaD_poscall ( L , ci , n ) ; return ; } vmcase ( OP_RETURN0 ) { if ( L -> hookmask ) { L -> top = ra ; halfProtectNT ( luaD_poscall ( L , ci , 0 ) ) ; } else { int nres = ci -> nresults ; L -> ci = ci -> previous ; L -> top = base - 1 ; while ( nres -- > 0 ) setnilvalue ( s2v ( L -> top ++ ) ) ; } return ; } vmcase ( OP_RETURN1 ) { if ( L -> hookmask ) { L -> top = ra + 1 ; halfProtectNT ( luaD_poscall ( L , ci , 1 ) ) ; } else { int nres = ci -> nresults ; L -> ci = ci -> previous ; if ( nres == 0 ) L -> top = base - 1 ; else { setobjs2s ( L , base - 1 , ra ) ; L -> top = base ; while ( -- nres > 0 ) setnilvalue ( s2v ( L -> top ++ ) ) ; } } return ; } vmcase ( OP_FORLOOP ) { if ( ttisinteger ( s2v ( ra + 2 ) ) ) { lua_Unsigned count = l_castS2U ( ivalue ( s2v ( ra + 1 ) ) ) ; if ( count > 0 ) { lua_Integer step = ivalue ( s2v ( ra + 2 ) ) ; lua_Integer idx = ivalue ( s2v ( ra ) ) ; chgivalue ( s2v ( ra + 1 ) , count - 1 ) ; idx = intop ( + , idx , step ) ; chgivalue ( s2v ( ra ) , idx ) ; setivalue ( s2v ( ra + 3 ) , idx ) ; pc -= GETARG_Bx ( i ) ; } } else if ( floatforloop ( ra ) ) pc -= GETARG_Bx ( i ) ; updatetrap ( ci ) ; vmbreak ; } vmcase ( OP_FORPREP ) { savestate ( L , ci ) ; if ( forprep ( L , ra ) ) pc += GETARG_Bx ( i ) + 1 ; vmbreak ; } vmcase ( OP_TFORPREP ) { halfProtect ( luaF_newtbcupval ( L , ra + 3 ) ) ; pc += GETARG_Bx ( i ) ; i = * ( pc ++ ) ; lua_assert ( GET_OPCODE ( i ) == OP_TFORCALL && ra == RA ( i ) ) ; goto l_tforcall ; } vmcase ( OP_TFORCALL ) { l_tforcall : memcpy ( ra + 4 , ra , 3 * sizeof ( * ra ) ) ; L -> top = ra + 4 + 3 ; ProtectNT ( luaD_call ( L , ra + 4 , GETARG_C ( i ) ) ) ; updatestack ( ci ) ; i = * ( pc ++ ) ; lua_assert ( GET_OPCODE ( i ) == OP_TFORLOOP && ra == RA ( i ) ) ; goto l_tforloop ; } vmcase ( OP_TFORLOOP ) { l_tforloop : if ( ! ttisnil ( s2v ( ra + 4 ) ) ) { setobjs2s ( L , ra + 2 , ra + 4 ) ; pc -= GETARG_Bx ( i ) ; } vmbreak ; } vmcase ( OP_SETLIST ) { int n = GETARG_B ( i ) ; unsigned int last = GETARG_C ( i ) ; Table * h = hvalue ( s2v ( ra ) ) ; if ( n == 0 ) n = cast_int ( L -> top - ra ) - 1 ; else L -> top = ci -> top ; last += n ; if ( TESTARG_k ( i ) ) { last += GETARG_Ax ( * pc ) * ( MAXARG_C + 1 ) ; pc ++ ; } if ( last > luaH_realasize ( h ) ) luaH_resizearray ( L , h , last ) ; for ( ; n > 0 ; n -- ) { TValue * val = s2v ( ra + n ) ; setobj2t ( L , & h -> array [ last - 1 ] , val ) ; last -- ; luaC_barrierback ( L , obj2gco ( h ) , val ) ; } vmbreak ; } vmcase ( OP_CLOSURE ) { Proto * p = cl -> p -> p [ GETARG_Bx ( i ) ] ; halfProtect ( pushclosure ( L , p , cl -> upvals , base , ra ) ) ; checkGC ( L , ra + 1 ) ; vmbreak ; } vmcase ( OP_VARARG ) { int n = GETARG_C ( i ) - 1 ; Protect ( luaT_getvarargs ( L , ci , ra , n ) ) ; vmbreak ; } vmcase ( OP_VARARGPREP ) { ProtectNT ( luaT_adjustvarargs ( L , GETARG_A ( i ) , ci , cl -> p ) ) ; if ( trap ) { luaD_hookcall ( L , ci ) ; <S2SV_StartBug> L -> oldpc = pc + 1 ; <S2SV_EndBug> } updatebase ( ci ) ; vmbreak ; } vmcase ( OP_EXTRAARG ) { lua_assert ( 0 ) ; vmbreak ; } } } }
","<S2SV_ModStart> -> oldpc = <S2SV_ModEnd> 1 ; }
"
98,"CWE-000 int main ( int argc , char * argv [ ] ) { OM_uint32 minor , major ; gss_ctx_id_t context ; gss_union_ctx_id_desc uctx ; krb5_gss_ctx_id_rec kgctx ; krb5_key k1 , k2 ; krb5_keyblock kb1 , kb2 ; gss_buffer_desc in , out ; unsigned char k1buf [ 32 ] , k2buf [ 32 ] , outbuf [ 44 ] ; size_t i ; context = ( gss_ctx_id_t ) & uctx ; uctx . mech_type = & mech_krb5 ; uctx . internal_ctx_id = ( gss_ctx_id_t ) & kgctx ; kgctx . k5_context = NULL ; <S2SV_StartBug> kgctx . have_acceptor_subkey = 1 ; <S2SV_EndBug> kb1 . contents = k1buf ; kb2 . contents = k2buf ; for ( i = 0 ; i < sizeof ( tests ) / sizeof ( * tests ) ; i ++ ) { kb1 . enctype = tests [ i ] . enctype ; kb1 . length = fromhex ( tests [ i ] . key1 , k1buf ) ; check_k5err ( NULL , ""create_key"" , krb5_k_create_key ( NULL , & kb1 , & k1 ) ) ; kgctx . subkey = k1 ; kb2 . enctype = tests [ i ] . enctype ; kb2 . length = fromhex ( tests [ i ] . key2 , k2buf ) ; check_k5err ( NULL , ""create_key"" , krb5_k_create_key ( NULL , & kb2 , & k2 ) ) ; kgctx . acceptor_subkey = k2 ; in . length = 0 ; in . value = NULL ; major = gss_pseudo_random ( & minor , context , GSS_C_PRF_KEY_PARTIAL , & in , 44 , & out ) ; check_gsserr ( ""gss_pseudo_random"" , major , minor ) ; ( void ) fromhex ( tests [ i ] . out1 , outbuf ) ; assert ( out . length == 44 && memcmp ( out . value , outbuf , 44 ) == 0 ) ; ( void ) gss_release_buffer ( & minor , & out ) ; in . length = strlen ( inputstr ) ; in . value = ( char * ) inputstr ; major = gss_pseudo_random ( & minor , context , GSS_C_PRF_KEY_FULL , & in , 44 , & out ) ; check_gsserr ( ""gss_pseudo_random"" , major , minor ) ; ( void ) fromhex ( tests [ i ] . out2 , outbuf ) ; assert ( out . length == 44 && memcmp ( out . value , outbuf , 44 ) == 0 ) ; ( void ) gss_release_buffer ( & minor , & out ) ; major = gss_pseudo_random ( & minor , context , GSS_C_PRF_KEY_FULL , & in , 0 , & out ) ; check_gsserr ( ""gss_pseudo_random"" , major , minor ) ; assert ( out . length == 0 ) ; ( void ) gss_release_buffer ( & minor , & out ) ; krb5_k_free_key ( NULL , k1 ) ; krb5_k_free_key ( NULL , k2 ) ; } return 0 ; }
","<S2SV_ModStart> ; kgctx . established = 1 ; kgctx .
"
99,"CWE-119 char * cJSON_PrintUnformatted ( cJSON * item ) { <S2SV_StartBug> return print_value ( item , 0 , 0 ) ; <S2SV_EndBug> }
","<S2SV_ModStart> 0 , 0 , 0
"
100,"CWE-401 struct clock_source * dce112_clock_source_create ( struct dc_context * ctx , struct dc_bios * bios , enum clock_source_id id , const struct dce110_clk_src_regs * regs , bool dp_clk_src ) { struct dce110_clk_src * clk_src = kzalloc ( sizeof ( struct dce110_clk_src ) , GFP_KERNEL ) ; if ( ! clk_src ) return NULL ; if ( dce112_clk_src_construct ( clk_src , ctx , bios , id , regs , & cs_shift , & cs_mask ) ) { clk_src -> base . dp_clk_src = dp_clk_src ; return & clk_src -> base ; } <S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug> return NULL ; }
","<S2SV_ModStart> base ; } kfree ( clk_src ) ;
"
101,"CWE-000 unsigned int get_random_int ( void ) { <S2SV_StartBug> struct keydata * keyptr ; <S2SV_EndBug> __u32 * hash = get_cpu_var ( get_random_int_hash ) ; <S2SV_StartBug> int ret ; <S2SV_EndBug> keyptr = get_keyptr ( ) ; hash [ 0 ] += current -> pid + jiffies + get_cycles ( ) ; <S2SV_StartBug> ret = half_md4_transform ( hash , keyptr -> secret ) ; <S2SV_EndBug> put_cpu_var ( get_random_int_hash ) ; return ret ; }
","<S2SV_ModStart> void ) { <S2SV_ModEnd> __u32 * hash <S2SV_ModStart> get_random_int_hash ) ; unsigned int ret <S2SV_ModEnd> ; hash [ <S2SV_ModStart> ( ) ; md5_transform <S2SV_ModEnd> ( hash , <S2SV_ModStart> ( hash , random_int_secret ) ; ret = hash [ 0 ] <S2SV_ModEnd> ; put_cpu_var (
"
102,"CWE-119 void grubfs_free ( GrubFS * gf ) { if ( gf ) { <S2SV_StartBug> if ( gf -> file && gf -> file -> device ) <S2SV_EndBug> <S2SV_StartBug> free ( gf -> file -> device -> disk ) ; <S2SV_EndBug> free ( gf -> file ) ; free ( gf ) ; } }
","<S2SV_ModStart> -> device ) { <S2SV_ModStart> disk ) ; }
"
103,"CWE-000 static int crypto_report_one ( struct crypto_alg * alg , struct crypto_user_alg * ualg , struct sk_buff * skb ) { <S2SV_StartBug> strlcpy ( ualg -> cru_name , alg -> cra_name , sizeof ( ualg -> cru_name ) ) ; <S2SV_EndBug> <S2SV_StartBug> strlcpy ( ualg -> cru_driver_name , alg -> cra_driver_name , <S2SV_EndBug> sizeof ( ualg -> cru_driver_name ) ) ; <S2SV_StartBug> strlcpy ( ualg -> cru_module_name , module_name ( alg -> cra_module ) , <S2SV_EndBug> sizeof ( ualg -> cru_module_name ) ) ; ualg -> cru_type = 0 ; ualg -> cru_mask = 0 ; ualg -> cru_flags = alg -> cra_flags ; ualg -> cru_refcnt = refcount_read ( & alg -> cra_refcnt ) ; if ( nla_put_u32 ( skb , CRYPTOCFGA_PRIORITY_VAL , alg -> cra_priority ) ) goto nla_put_failure ; if ( alg -> cra_flags & CRYPTO_ALG_LARVAL ) { struct crypto_report_larval rl ; <S2SV_StartBug> strlcpy ( rl . type , ""larval"" , sizeof ( rl . type ) ) ; <S2SV_EndBug> if ( nla_put ( skb , CRYPTOCFGA_REPORT_LARVAL , sizeof ( struct crypto_report_larval ) , & rl ) ) goto nla_put_failure ; goto out ; } if ( alg -> cra_type && alg -> cra_type -> report ) { if ( alg -> cra_type -> report ( skb , alg ) ) goto nla_put_failure ; goto out ; } switch ( alg -> cra_flags & ( CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL ) ) { case CRYPTO_ALG_TYPE_CIPHER : if ( crypto_report_cipher ( skb , alg ) ) goto nla_put_failure ; break ; case CRYPTO_ALG_TYPE_COMPRESS : if ( crypto_report_comp ( skb , alg ) ) goto nla_put_failure ; break ; case CRYPTO_ALG_TYPE_ACOMPRESS : if ( crypto_report_acomp ( skb , alg ) ) goto nla_put_failure ; break ; case CRYPTO_ALG_TYPE_AKCIPHER : if ( crypto_report_akcipher ( skb , alg ) ) goto nla_put_failure ; break ; case CRYPTO_ALG_TYPE_KPP : if ( crypto_report_kpp ( skb , alg ) ) goto nla_put_failure ; break ; } out : return 0 ; nla_put_failure : return - EMSGSIZE ; }
","<S2SV_ModStart> skb ) { strncpy <S2SV_ModEnd> ( ualg -> <S2SV_ModStart> ) ) ; strncpy <S2SV_ModEnd> ( ualg -> <S2SV_ModStart> ) ) ; strncpy <S2SV_ModEnd> ( ualg -> <S2SV_ModStart> crypto_report_larval rl ; strncpy <S2SV_ModEnd> ( rl .
"
104,"CWE-119 static bool regsafe ( struct bpf_reg_state * rold , struct bpf_reg_state * rcur , struct idpair * idmap ) { if ( ! ( rold -> live & REG_LIVE_READ ) ) return true ; if ( memcmp ( rold , rcur , offsetof ( struct bpf_reg_state , live ) ) == 0 ) return true ; if ( rold -> type == NOT_INIT ) return true ; if ( rcur -> type == NOT_INIT ) return false ; switch ( rold -> type ) { case SCALAR_VALUE : if ( rcur -> type == SCALAR_VALUE ) { return range_within ( rold , rcur ) && tnum_in ( rold -> var_off , rcur -> var_off ) ; } else { <S2SV_StartBug> return rold -> umin_value == 0 && <S2SV_EndBug> rold -> umax_value == U64_MAX && rold -> smin_value == S64_MIN && rold -> smax_value == S64_MAX && tnum_is_unknown ( rold -> var_off ) ; } case PTR_TO_MAP_VALUE : return memcmp ( rold , rcur , offsetof ( struct bpf_reg_state , id ) ) == 0 && range_within ( rold , rcur ) && tnum_in ( rold -> var_off , rcur -> var_off ) ; case PTR_TO_MAP_VALUE_OR_NULL : if ( rcur -> type != PTR_TO_MAP_VALUE_OR_NULL ) return false ; if ( memcmp ( rold , rcur , offsetof ( struct bpf_reg_state , id ) ) ) return false ; return check_ids ( rold -> id , rcur -> id , idmap ) ; case PTR_TO_PACKET_META : case PTR_TO_PACKET : if ( rcur -> type != rold -> type ) return false ; if ( rold -> range > rcur -> range ) return false ; if ( rold -> off != rcur -> off ) return false ; if ( rold -> id && ! check_ids ( rold -> id , rcur -> id , idmap ) ) return false ; return range_within ( rold , rcur ) && tnum_in ( rold -> var_off , rcur -> var_off ) ; case PTR_TO_CTX : case CONST_PTR_TO_MAP : case PTR_TO_STACK : case PTR_TO_PACKET_END : default : return false ; } WARN_ON_ONCE ( 1 ) ; return false ; }
","<S2SV_ModStart> else { return false <S2SV_ModEnd> ; } case
"
105,"CWE-190 static int jas_iccgetuint64 ( jas_stream_t * in , jas_iccuint64_t * val ) { <S2SV_StartBug> ulonglong tmp ; <S2SV_EndBug> if ( jas_iccgetuint ( in , 8 , & tmp ) ) return - 1 ; * val = tmp ; return 0 ; }
","<S2SV_ModStart> val ) { jas_ulonglong <S2SV_ModEnd> tmp ; if
"
106,"CWE-416 CURLcode Curl_close ( struct Curl_easy * data ) { struct Curl_multi * m ; if ( ! data ) return CURLE_OK ; Curl_expire_clear ( data ) ; m = data -> multi ; if ( m ) curl_multi_remove_handle ( data -> multi , data ) ; <S2SV_StartBug> if ( data -> multi_easy ) <S2SV_EndBug> <S2SV_StartBug> curl_multi_cleanup ( data -> multi_easy ) ; <S2SV_EndBug> Curl_llist_destroy ( & data -> state . timeoutlist , NULL ) ; data -> magic = 0 ; if ( data -> state . rangestringalloc ) free ( data -> state . range ) ; Curl_free_request_state ( data ) ; Curl_ssl_close_all ( data ) ; Curl_safefree ( data -> state . first_host ) ; Curl_safefree ( data -> state . scratch ) ; Curl_ssl_free_certinfo ( data ) ; free ( data -> req . newurl ) ; data -> req . newurl = NULL ; if ( data -> change . referer_alloc ) { Curl_safefree ( data -> change . referer ) ; data -> change . referer_alloc = FALSE ; } data -> change . referer = NULL ; Curl_up_free ( data ) ; Curl_safefree ( data -> state . buffer ) ; Curl_safefree ( data -> state . headerbuff ) ; Curl_safefree ( data -> state . ulbuf ) ; Curl_flush_cookies ( data , 1 ) ; Curl_digest_cleanup ( data ) ; Curl_safefree ( data -> info . contenttype ) ; Curl_safefree ( data -> info . wouldredirect ) ; Curl_resolver_cleanup ( data -> state . resolver ) ; Curl_http2_cleanup_dependencies ( data ) ; Curl_convert_close ( data ) ; if ( data -> share ) { Curl_share_lock ( data , CURL_LOCK_DATA_SHARE , CURL_LOCK_ACCESS_SINGLE ) ; data -> share -> dirty -- ; Curl_share_unlock ( data , CURL_LOCK_DATA_SHARE ) ; } Curl_wildcard_dtor ( & data -> wildcard ) ; Curl_freeset ( data ) ; free ( data ) ; return CURLE_OK ; }
","<S2SV_ModStart> -> multi_easy ) { <S2SV_ModStart> multi_easy ) ; data -> multi_easy = NULL ; }
"
107,"CWE-476 static int crypto_rng_init_tfm ( struct crypto_tfm * tfm ) { <S2SV_StartBug> struct crypto_rng * rng = __crypto_rng_cast ( tfm ) ; <S2SV_EndBug> struct rng_alg * alg = crypto_rng_alg ( rng ) ; struct old_rng_alg * oalg = crypto_old_rng_alg ( rng ) ; if ( oalg -> rng_make_random ) { rng -> generate = generate ; rng -> seed = rngapi_reset ; rng -> seedsize = oalg -> seedsize ; return 0 ; } rng -> generate = alg -> generate ; rng -> seed = alg -> seed ; rng -> seedsize = alg -> seedsize ; return 0 ; }
","<S2SV_ModStart> tfm ) { <S2SV_ModEnd> return 0 ;
"
108,"CWE-119 static enum led_brightness k90_backlight_get ( struct led_classdev * led_cdev ) { int ret ; struct k90_led * led = container_of ( led_cdev , struct k90_led , cdev ) ; struct device * dev = led -> cdev . dev -> parent ; struct usb_interface * usbif = to_usb_interface ( dev -> parent ) ; struct usb_device * usbdev = interface_to_usbdev ( usbif ) ; int brightness ; <S2SV_StartBug> char data [ 8 ] ; <S2SV_EndBug> ret = usb_control_msg ( usbdev , usb_rcvctrlpipe ( usbdev , 0 ) , K90_REQUEST_STATUS , USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE , 0 , 0 , data , 8 , USB_CTRL_SET_TIMEOUT ) ; if ( ret < 0 ) { dev_warn ( dev , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>K90<S2SV_blank>initial<S2SV_blank>state<S2SV_blank>(error<S2SV_blank>%d).\\n"" , ret ) ; <S2SV_StartBug> return - EIO ; <S2SV_EndBug> } brightness = data [ 4 ] ; if ( brightness < 0 || brightness > 3 ) { dev_warn ( dev , ""Read<S2SV_blank>invalid<S2SV_blank>backlight<S2SV_blank>brightness:<S2SV_blank>%02hhx.\\n"" , data [ 4 ] ) ; <S2SV_StartBug> return - EIO ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> return brightness ; }
","<S2SV_ModStart> brightness ; char * data ; data = kmalloc ( 8 , GFP_KERNEL ) ; if ( ! data ) return - ENOMEM <S2SV_ModEnd> ; ret = <S2SV_ModStart> ret ) ; ret = - EIO ; goto out <S2SV_ModEnd> ; } brightness <S2SV_ModStart> ] ) ; ret = <S2SV_ModEnd> - EIO ; <S2SV_ModStart> - EIO ; goto out ; } ret = brightness ; out : kfree ( data ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
"
109,"CWE-476 static int compile_bag_node ( BagNode * node , regex_t * reg , ScanEnv * env ) { int r , len ; switch ( node -> type ) { case BAG_MEMORY : r = compile_bag_memory_node ( node , reg , env ) ; break ; case BAG_OPTION : r = compile_option_node ( node , reg , env ) ; break ; case BAG_STOP_BACKTRACK : if ( NODE_IS_STOP_BT_SIMPLE_REPEAT ( node ) ) { QuantNode * qn = QUANT_ ( NODE_BAG_BODY ( node ) ) ; r = compile_tree_n_times ( NODE_QUANT_BODY ( qn ) , qn -> lower , reg , env ) ; if ( r != 0 ) return r ; len = compile_length_tree ( NODE_QUANT_BODY ( qn ) , reg ) ; if ( len < 0 ) return len ; r = add_op ( reg , OP_PUSH ) ; if ( r != 0 ) return r ; COP ( reg ) -> push . addr = SIZE_INC_OP + len + SIZE_OP_POP_OUT + SIZE_OP_JUMP ; r = compile_tree ( NODE_QUANT_BODY ( qn ) , reg , env ) ; if ( r != 0 ) return r ; r = add_op ( reg , OP_POP_OUT ) ; if ( r != 0 ) return r ; r = add_op ( reg , OP_JUMP ) ; if ( r != 0 ) return r ; COP ( reg ) -> jump . addr = - ( ( int ) SIZE_OP_PUSH + len + ( int ) SIZE_OP_POP_OUT ) ; } else { r = add_op ( reg , OP_ATOMIC_START ) ; if ( r != 0 ) return r ; r = compile_tree ( NODE_BAG_BODY ( node ) , reg , env ) ; if ( r != 0 ) return r ; r = add_op ( reg , OP_ATOMIC_END ) ; } break ; case BAG_IF_ELSE : { <S2SV_StartBug> int cond_len , then_len , jump_len ; <S2SV_EndBug> Node * cond = NODE_BAG_BODY ( node ) ; Node * Then = node -> te . Then ; Node * Else = node -> te . Else ; r = add_op ( reg , OP_ATOMIC_START ) ; if ( r != 0 ) return r ; cond_len = compile_length_tree ( cond , reg ) ; if ( cond_len < 0 ) return cond_len ; if ( IS_NOT_NULL ( Then ) ) { then_len = compile_length_tree ( Then , reg ) ; if ( then_len < 0 ) return then_len ; } else then_len = 0 ; <S2SV_StartBug> jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END ; <S2SV_EndBug> if ( IS_NOT_NULL ( Else ) ) jump_len += SIZE_OP_JUMP ; r = add_op ( reg , OP_PUSH ) ; if ( r != 0 ) return r ; COP ( reg ) -> push . addr = SIZE_INC_OP + jump_len ; r = compile_tree ( cond , reg , env ) ; if ( r != 0 ) return r ; r = add_op ( reg , OP_ATOMIC_END ) ; if ( r != 0 ) return r ; if ( IS_NOT_NULL ( Then ) ) { r = compile_tree ( Then , reg , env ) ; if ( r != 0 ) return r ; } if ( IS_NOT_NULL ( Else ) ) { <S2SV_StartBug> int else_len = compile_length_tree ( Else , reg ) ; <S2SV_EndBug> r = add_op ( reg , OP_JUMP ) ; if ( r != 0 ) return r ; <S2SV_StartBug> COP ( reg ) -> jump . addr = else_len + SIZE_INC_OP ; <S2SV_EndBug> <S2SV_StartBug> r = compile_tree ( Else , reg , env ) ; <S2SV_EndBug> } } break ; } return r ; }
","<S2SV_ModStart> , then_len , else_len , <S2SV_ModStart> then_len + SIZE_OP_ATOMIC_END + <S2SV_ModEnd> SIZE_OP_JUMP ; r <S2SV_ModStart> ) ) { <S2SV_ModEnd> else_len = compile_length_tree <S2SV_ModStart> , reg ) ; if ( else_len < 0 ) return else_len ; } else else_len = 0 <S2SV_ModStart> . addr = SIZE_OP_ATOMIC_END + <S2SV_ModStart> ; r = add_op ( reg , OP_ATOMIC_END ) ; if ( r != 0 ) return r ; if ( IS_NOT_NULL ( Else ) ) { r =
"
110,"CWE-189 static void sgi_timer_get ( struct k_itimer * timr , struct itimerspec * cur_setting ) { if ( timr -> it . mmtimer . clock == TIMER_OFF ) { cur_setting -> it_interval . tv_nsec = 0 ; cur_setting -> it_interval . tv_sec = 0 ; cur_setting -> it_value . tv_nsec = 0 ; cur_setting -> it_value . tv_sec = 0 ; return ; } <S2SV_StartBug> ns_to_timespec ( cur_setting -> it_interval , timr -> it . mmtimer . incr * sgi_clock_period ) ; <S2SV_EndBug> <S2SV_StartBug> ns_to_timespec ( cur_setting -> it_value , ( timr -> it . mmtimer . expires - rtc_time ( ) ) * sgi_clock_period ) ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> }
","<S2SV_ModStart> return ; } <S2SV_ModEnd> cur_setting -> it_interval <S2SV_ModStart> cur_setting -> it_interval = ns_to_timespec ( <S2SV_ModEnd> timr -> it <S2SV_ModStart> sgi_clock_period ) ; <S2SV_ModEnd> cur_setting -> it_value <S2SV_ModStart> cur_setting -> it_value = ns_to_timespec ( <S2SV_ModEnd> ( timr -> <S2SV_ModStart> sgi_clock_period ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
"
111,"CWE-125 <S2SV_StartBug> static void read_quant_matrix_ext ( MpegEncContext * s , GetBitContext * gb ) <S2SV_EndBug> { int i , j , v ; <S2SV_StartBug> if ( get_bits1 ( gb ) ) { <S2SV_EndBug> for ( i = 0 ; i < 64 ; i ++ ) { v = get_bits ( gb , 8 ) ; j = s -> idsp . idct_permutation [ ff_zigzag_direct [ i ] ] ; s -> intra_matrix [ j ] = v ; s -> chroma_intra_matrix [ j ] = v ; } } if ( get_bits1 ( gb ) ) { <S2SV_StartBug> for ( i = 0 ; i < 64 ; i ++ ) { <S2SV_EndBug> get_bits ( gb , 8 ) ; } } <S2SV_StartBug> if ( get_bits1 ( gb ) ) { <S2SV_EndBug> for ( i = 0 ; i < 64 ; i ++ ) { v = get_bits ( gb , 8 ) ; j = s -> idsp . idct_permutation [ ff_zigzag_direct [ i ] ] ; s -> chroma_intra_matrix [ j ] = v ; } } if ( get_bits1 ( gb ) ) { <S2SV_StartBug> for ( i = 0 ; i < 64 ; i ++ ) { <S2SV_EndBug> get_bits ( gb , 8 ) ; } } next_start_code_studio ( gb ) ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> read_quant_matrix_ext ( MpegEncContext <S2SV_ModStart> ) ) { if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> ) ) { if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> ) ) { if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> ) ) { if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> gb ) ; return 0 ;
"
112,"CWE-787 static void WritePixels ( struct ngiflib_img * i , struct ngiflib_decode_context * context , const u8 * pixels , u16 n ) { u16 tocopy ; struct ngiflib_gif * p = i -> parent ; while ( n > 0 ) { tocopy = ( context -> Xtogo < n ) ? context -> Xtogo : n ; if ( ! i -> gce . transparent_flag ) { # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif ngiflib_memcpy ( context -> frbuff_p . p8 , pixels , tocopy ) ; pixels += tocopy ; context -> frbuff_p . p8 += tocopy ; # ifndef NGIFLIB_INDEXED_ONLY } else { int j ; for ( j = ( int ) tocopy ; j > 0 ; j -- ) { * ( context -> frbuff_p . p32 ++ ) = GifIndexToTrueColor ( i -> palette , * pixels ++ ) ; } } # endif } else { int j ; # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif for ( j = ( int ) tocopy ; j > 0 ; j -- ) { if ( * pixels != i -> gce . transparent_color ) * context -> frbuff_p . p8 = * pixels ; pixels ++ ; context -> frbuff_p . p8 ++ ; } # ifndef NGIFLIB_INDEXED_ONLY } else { for ( j = ( int ) tocopy ; j > 0 ; j -- ) { if ( * pixels != i -> gce . transparent_color ) { * context -> frbuff_p . p32 = GifIndexToTrueColor ( i -> palette , * pixels ) ; } pixels ++ ; context -> frbuff_p . p32 ++ ; } } # endif } context -> Xtogo -= tocopy ; if ( context -> Xtogo == 0 ) { # ifdef NGIFLIB_ENABLE_CALLBACKS if ( p -> line_cb ) p -> line_cb ( p , context -> line_p , context -> curY ) ; # endif context -> Xtogo = i -> width ; switch ( context -> pass ) { case 0 : context -> curY ++ ; break ; case 1 : context -> curY += 8 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 4 ; } break ; case 2 : context -> curY += 8 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 2 ; } break ; case 3 : context -> curY += 4 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 1 ; } break ; case 4 : context -> curY += 2 ; <S2SV_StartBug> break ; <S2SV_EndBug> } # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif # ifdef NGIFLIB_ENABLE_CALLBACKS context -> line_p . p8 = p -> frbuff . p8 + ( u32 ) context -> curY * p -> width ; context -> frbuff_p . p8 = context -> line_p . p8 + i -> posX ; # else context -> frbuff_p . p8 = p -> frbuff . p8 + ( u32 ) context -> curY * p -> width + i -> posX ; # endif # ifndef NGIFLIB_INDEXED_ONLY } else { # ifdef NGIFLIB_ENABLE_CALLBACKS context -> line_p . p32 = p -> frbuff . p32 + ( u32 ) context -> curY * p -> width ; context -> frbuff_p . p32 = context -> line_p . p32 + i -> posX ; # else context -> frbuff_p . p32 = p -> frbuff . p32 + ( u32 ) context -> curY * p -> width + i -> posX ; # endif } # endif } n -= tocopy ; } }
","<S2SV_ModStart> += 8 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> += 8 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> += 4 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> ; break ; } while ( context -> pass > 0 && context -> pass < 4 && context -> curY >= p -> height ) { switch ( ++ context -> pass ) { case 2 : context -> curY = i -> posY + 4 ; break ; case 3 : context -> curY = i -> posY + 2 ; break ; case 4 : context -> curY = i -> posY + 1 ; break ; }
"
113,"CWE-415 static int f_midi_set_alt ( struct usb_function * f , unsigned intf , unsigned alt ) { struct f_midi * midi = func_to_midi ( f ) ; unsigned i ; int err ; if ( intf != midi -> ms_id ) return 0 ; err = f_midi_start_ep ( midi , f , midi -> in_ep ) ; if ( err ) return err ; err = f_midi_start_ep ( midi , f , midi -> out_ep ) ; if ( err ) return err ; while ( kfifo_avail ( & midi -> in_req_fifo ) ) { struct usb_request * req = midi_alloc_ep_req ( midi -> in_ep , midi -> buflen ) ; if ( req == NULL ) return - ENOMEM ; req -> length = 0 ; req -> complete = f_midi_complete ; kfifo_put ( & midi -> in_req_fifo , req ) ; } for ( i = 0 ; i < midi -> qlen && err == 0 ; i ++ ) { struct usb_request * req = midi_alloc_ep_req ( midi -> out_ep , midi -> buflen ) ; if ( req == NULL ) return - ENOMEM ; req -> complete = f_midi_complete ; err = usb_ep_queue ( midi -> out_ep , req , GFP_ATOMIC ) ; if ( err ) { ERROR ( midi , ""%s:<S2SV_blank>couldn\'t<S2SV_blank>enqueue<S2SV_blank>request:<S2SV_blank>%d\\n"" , midi -> out_ep -> name , err ) ; <S2SV_StartBug> free_ep_req ( midi -> out_ep , req ) ; <S2SV_EndBug> return err ; } } return 0 ; }
","<S2SV_ModStart> err ) ; if ( req -> buf != NULL )
"
114,"CWE-119 void vp8_end_second_pass ( VP8_COMP * cpi ) { <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> cpi ) { ( void ) cpi ;
"
115,"CWE-264 static ssize_t hfi1_file_write ( struct file * fp , const char __user * data , size_t count , loff_t * offset ) { const struct hfi1_cmd __user * ucmd ; struct hfi1_filedata * fd = fp -> private_data ; struct hfi1_ctxtdata * uctxt = fd -> uctxt ; struct hfi1_cmd cmd ; struct hfi1_user_info uinfo ; struct hfi1_tid_info tinfo ; unsigned long addr ; ssize_t consumed = 0 , copy = 0 , ret = 0 ; void * dest = NULL ; __u64 user_val = 0 ; int uctxt_required = 1 ; int must_be_root = 0 ; <S2SV_StartBug> if ( count < sizeof ( cmd ) ) { <S2SV_EndBug> ret = - EINVAL ; goto bail ; } ucmd = ( const struct hfi1_cmd __user * ) data ; if ( copy_from_user ( & cmd , ucmd , sizeof ( cmd ) ) ) { ret = - EFAULT ; goto bail ; } consumed = sizeof ( cmd ) ; switch ( cmd . type ) { case HFI1_CMD_ASSIGN_CTXT : uctxt_required = 0 ; copy = sizeof ( uinfo ) ; dest = & uinfo ; break ; case HFI1_CMD_SDMA_STATUS_UPD : case HFI1_CMD_CREDIT_UPD : copy = 0 ; break ; case HFI1_CMD_TID_UPDATE : case HFI1_CMD_TID_FREE : case HFI1_CMD_TID_INVAL_READ : copy = sizeof ( tinfo ) ; dest = & tinfo ; break ; case HFI1_CMD_USER_INFO : case HFI1_CMD_RECV_CTRL : case HFI1_CMD_POLL_TYPE : case HFI1_CMD_ACK_EVENT : case HFI1_CMD_CTXT_INFO : case HFI1_CMD_SET_PKEY : case HFI1_CMD_CTXT_RESET : copy = 0 ; user_val = cmd . addr ; break ; case HFI1_CMD_EP_INFO : case HFI1_CMD_EP_ERASE_CHIP : case HFI1_CMD_EP_ERASE_RANGE : case HFI1_CMD_EP_READ_RANGE : case HFI1_CMD_EP_WRITE_RANGE : uctxt_required = 0 ; must_be_root = 1 ; copy = 0 ; break ; default : ret = - EINVAL ; goto bail ; } if ( copy ) { if ( copy_from_user ( dest , ( void __user * ) cmd . addr , copy ) ) { ret = - EFAULT ; goto bail ; } consumed += copy ; } if ( uctxt_required && ! uctxt ) { ret = - EINVAL ; goto bail ; } if ( must_be_root && ! capable ( CAP_SYS_ADMIN ) ) { ret = - EPERM ; goto bail ; } switch ( cmd . type ) { case HFI1_CMD_ASSIGN_CTXT : ret = assign_ctxt ( fp , & uinfo ) ; if ( ret < 0 ) goto bail ; ret = setup_ctxt ( fp ) ; if ( ret ) goto bail ; ret = user_init ( fp ) ; break ; case HFI1_CMD_CTXT_INFO : ret = get_ctxt_info ( fp , ( void __user * ) ( unsigned long ) user_val , cmd . len ) ; break ; case HFI1_CMD_USER_INFO : ret = get_base_info ( fp , ( void __user * ) ( unsigned long ) user_val , cmd . len ) ; break ; case HFI1_CMD_SDMA_STATUS_UPD : break ; case HFI1_CMD_CREDIT_UPD : if ( uctxt && uctxt -> sc ) sc_return_credits ( uctxt -> sc ) ; break ; case HFI1_CMD_TID_UPDATE : ret = hfi1_user_exp_rcv_setup ( fp , & tinfo ) ; if ( ! ret ) { addr = ( unsigned long ) cmd . addr + offsetof ( struct hfi1_tid_info , tidcnt ) ; if ( copy_to_user ( ( void __user * ) addr , & tinfo . tidcnt , sizeof ( tinfo . tidcnt ) + sizeof ( tinfo . length ) ) ) ret = - EFAULT ; } break ; case HFI1_CMD_TID_INVAL_READ : ret = hfi1_user_exp_rcv_invalid ( fp , & tinfo ) ; if ( ret ) break ; addr = ( unsigned long ) cmd . addr + offsetof ( struct hfi1_tid_info , tidcnt ) ; if ( copy_to_user ( ( void __user * ) addr , & tinfo . tidcnt , sizeof ( tinfo . tidcnt ) ) ) ret = - EFAULT ; break ; case HFI1_CMD_TID_FREE : ret = hfi1_user_exp_rcv_clear ( fp , & tinfo ) ; if ( ret ) break ; addr = ( unsigned long ) cmd . addr + offsetof ( struct hfi1_tid_info , tidcnt ) ; if ( copy_to_user ( ( void __user * ) addr , & tinfo . tidcnt , sizeof ( tinfo . tidcnt ) ) ) ret = - EFAULT ; break ; case HFI1_CMD_RECV_CTRL : ret = manage_rcvq ( uctxt , fd -> subctxt , ( int ) user_val ) ; break ; case HFI1_CMD_POLL_TYPE : uctxt -> poll_type = ( typeof ( uctxt -> poll_type ) ) user_val ; break ; case HFI1_CMD_ACK_EVENT : ret = user_event_ack ( uctxt , fd -> subctxt , user_val ) ; break ; case HFI1_CMD_SET_PKEY : if ( HFI1_CAP_IS_USET ( PKEY_CHECK ) ) ret = set_ctxt_pkey ( uctxt , fd -> subctxt , user_val ) ; else ret = - EPERM ; break ; case HFI1_CMD_CTXT_RESET : { struct send_context * sc ; struct hfi1_devdata * dd ; if ( ! uctxt || ! uctxt -> dd || ! uctxt -> sc ) { ret = - EINVAL ; break ; } dd = uctxt -> dd ; sc = uctxt -> sc ; wait_event_interruptible_timeout ( sc -> halt_wait , ( sc -> flags & SCF_HALTED ) , msecs_to_jiffies ( SEND_CTXT_HALT_TIMEOUT ) ) ; if ( ! ( sc -> flags & SCF_HALTED ) ) { ret = - ENOLCK ; break ; } if ( sc -> flags & SCF_FROZEN ) { wait_event_interruptible_timeout ( dd -> event_queue , ! ( ACCESS_ONCE ( dd -> flags ) & HFI1_FROZEN ) , msecs_to_jiffies ( SEND_CTXT_HALT_TIMEOUT ) ) ; if ( dd -> flags & HFI1_FROZEN ) { ret = - ENOLCK ; break ; } if ( dd -> flags & HFI1_FORCED_FREEZE ) { ret = - ENODEV ; break ; } sc_disable ( sc ) ; ret = sc_enable ( sc ) ; hfi1_rcvctrl ( dd , HFI1_RCVCTRL_CTXT_ENB , uctxt -> ctxt ) ; } else { ret = sc_restart ( sc ) ; } if ( ! ret ) sc_return_credits ( sc ) ; break ; } case HFI1_CMD_EP_INFO : case HFI1_CMD_EP_ERASE_CHIP : case HFI1_CMD_EP_ERASE_RANGE : case HFI1_CMD_EP_READ_RANGE : case HFI1_CMD_EP_WRITE_RANGE : ret = handle_eprom_command ( fp , & cmd ) ; break ; } if ( ret >= 0 ) ret = consumed ; bail : return ret ; }
","<S2SV_ModStart> ; if ( WARN_ON_ONCE ( ! ib_safe_file_access ( fp ) ) ) return - EACCES ; if (
"
116,"CWE-119 void jpc_qmfb_split_colgrp ( jpc_fix_t * a , int numrows , int stride , int parity ) { int bufsize = JPC_CEILDIVPOW2 ( numrows , 1 ) ; jpc_fix_t splitbuf [ QMFB_SPLITBUFSIZE * JPC_QMFB_COLGRPSIZE ] ; jpc_fix_t * buf = splitbuf ; jpc_fix_t * srcptr ; jpc_fix_t * dstptr ; register jpc_fix_t * srcptr2 ; register jpc_fix_t * dstptr2 ; register int n ; register int i ; int m ; <S2SV_StartBug> int hstartcol ; <S2SV_EndBug> if ( bufsize > QMFB_SPLITBUFSIZE ) { <S2SV_StartBug> if ( ! ( buf = jas_alloc2 ( bufsize , sizeof ( jpc_fix_t ) ) ) ) { <S2SV_EndBug> abort ( ) ; } } if ( numrows >= 2 ) { <S2SV_StartBug> hstartcol = ( numrows + 1 - parity ) >> 1 ; <S2SV_EndBug> <S2SV_StartBug> m = numrows - hstartcol ; <S2SV_EndBug> n = m ; dstptr = buf ; srcptr = & a [ ( 1 - parity ) * stride ] ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < JPC_QMFB_COLGRPSIZE ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += JPC_QMFB_COLGRPSIZE ; srcptr += stride << 1 ; } dstptr = & a [ ( 1 - parity ) * stride ] ; srcptr = & a [ ( 2 - parity ) * stride ] ; n = numrows - m - ( ! parity ) ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < JPC_QMFB_COLGRPSIZE ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += stride ; srcptr += stride << 1 ; } <S2SV_StartBug> dstptr = & a [ hstartcol * stride ] ; <S2SV_EndBug> srcptr = buf ; n = m ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < JPC_QMFB_COLGRPSIZE ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += stride ; srcptr += JPC_QMFB_COLGRPSIZE ; } } if ( buf != splitbuf ) { jas_free ( buf ) ; } }
","<S2SV_ModStart> m ; int hstartrow <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( buf = jas_alloc3 <S2SV_ModEnd> ( bufsize , <S2SV_ModStart> ( bufsize , JPC_QMFB_COLGRPSIZE , <S2SV_ModStart> 2 ) { hstartrow <S2SV_ModEnd> = ( numrows <S2SV_ModStart> = numrows - hstartrow <S2SV_ModEnd> ; n = <S2SV_ModStart> & a [ hstartrow <S2SV_ModEnd> * stride ]
"
117,"CWE-119 static void fill_variance ( int64_t s2 , int64_t s , int c , var * v ) { v -> sum_square_error = s2 ; v -> sum_error = s ; <S2SV_StartBug> v -> count = c ; <S2SV_EndBug> <S2SV_StartBug> if ( c > 0 ) <S2SV_EndBug> v -> variance = ( int ) ( 256 * ( v -> sum_square_error - v -> sum_error * v -> sum_error / v -> count ) / v -> count ) ; else v -> variance = 0 ; }
","<S2SV_ModStart> ; v -> log2_count <S2SV_ModEnd> = c ; <S2SV_ModStart> = c ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
"
118,"CWE-399 static int ovl_copy_up_locked ( struct dentry * workdir , struct dentry * upperdir , struct dentry * dentry , struct path * lowerpath , struct kstat * stat , struct iattr * attr , const char * link ) { struct inode * wdir = workdir -> d_inode ; struct inode * udir = upperdir -> d_inode ; struct dentry * newdentry = NULL ; struct dentry * upper = NULL ; umode_t mode = stat -> mode ; int err ; newdentry = ovl_lookup_temp ( workdir , dentry ) ; err = PTR_ERR ( newdentry ) ; if ( IS_ERR ( newdentry ) ) goto out ; upper = lookup_one_len ( dentry -> d_name . name , upperdir , dentry -> d_name . len ) ; err = PTR_ERR ( upper ) ; if ( IS_ERR ( upper ) ) goto out1 ; stat -> mode &= S_IFMT ; err = ovl_create_real ( wdir , newdentry , stat , link , NULL , true ) ; stat -> mode = mode ; if ( err ) goto out2 ; if ( S_ISREG ( stat -> mode ) ) { struct path upperpath ; ovl_path_upper ( dentry , & upperpath ) ; BUG_ON ( upperpath . dentry != NULL ) ; upperpath . dentry = newdentry ; err = ovl_copy_up_data ( lowerpath , & upperpath , stat -> size ) ; if ( err ) goto out_cleanup ; } err = ovl_copy_xattr ( lowerpath -> dentry , newdentry ) ; if ( err ) goto out_cleanup ; mutex_lock ( & newdentry -> d_inode -> i_mutex ) ; err = ovl_set_attr ( newdentry , stat ) ; if ( ! err && attr ) err = notify_change ( newdentry , attr , NULL ) ; mutex_unlock ( & newdentry -> d_inode -> i_mutex ) ; if ( err ) goto out_cleanup ; err = ovl_do_rename ( wdir , newdentry , udir , upper , 0 ) ; if ( err ) goto out_cleanup ; ovl_dentry_update ( dentry , newdentry ) ; newdentry = NULL ; if ( ! S_ISDIR ( stat -> mode ) ) ovl_dentry_set_opaque ( dentry , true ) ; out2 : dput ( upper ) ; out1 : dput ( newdentry ) ; out : return err ; out_cleanup : ovl_cleanup ( wdir , newdentry ) ; <S2SV_StartBug> goto out ; <S2SV_EndBug> }
","<S2SV_ModStart> ) ; goto out2 <S2SV_ModEnd> ; } <S2SV_null>
"
119,"CWE-787 IMPEG2D_ERROR_CODES_T impeg2d_dec_seq_hdr ( dec_state_t * ps_dec ) { stream_t * ps_stream ; ps_stream = & ps_dec -> s_bit_stream ; UWORD16 u2_height ; UWORD16 u2_width ; if ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) != SEQUENCE_HEADER_CODE ) { impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; return IMPEG2D_FRM_HDR_START_CODE_NOT_FOUND ; } impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; u2_width = impeg2d_bit_stream_get ( ps_stream , 12 ) ; u2_height = impeg2d_bit_stream_get ( ps_stream , 12 ) ; if ( 0 == u2_width || 0 == u2_height ) { IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_FRM_HDR_DECODE_ERR ; return e_error ; } if ( ( u2_width != ps_dec -> u2_horizontal_size ) || ( u2_height != ps_dec -> u2_vertical_size ) ) { if ( 0 == ps_dec -> u2_header_done ) { ps_dec -> u2_horizontal_size = u2_width ; ps_dec -> u2_vertical_size = u2_height ; <S2SV_StartBug> if ( 0 == ps_dec -> u4_frm_buf_stride ) <S2SV_EndBug> { ps_dec -> u4_frm_buf_stride = ( UWORD32 ) ( u2_width ) ; } } else { if ( 0 == ps_dec -> i4_pic_count ) { return ( IMPEG2D_ERROR_CODES_T ) IMPEG2D_FRM_HDR_DECODE_ERR ; } <S2SV_StartBug> else if ( ( u2_width > ps_dec -> u2_create_max_width ) <S2SV_EndBug> <S2SV_StartBug> || ( u2_height > ps_dec -> u2_create_max_height ) ) <S2SV_EndBug> { IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS ; ps_dec -> u2_reinit_max_height = u2_height ; ps_dec -> u2_reinit_max_width = u2_width ; return e_error ; } else { return ( IMPEG2D_ERROR_CODES_T ) IVD_RES_CHANGED ; } } } if ( ( ps_dec -> u2_horizontal_size > ps_dec -> u2_create_max_width ) || ( ps_dec -> u2_vertical_size > ps_dec -> u2_create_max_height ) ) { IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS ; ps_dec -> u2_reinit_max_height = ps_dec -> u2_vertical_size ; ps_dec -> u2_reinit_max_width = ps_dec -> u2_horizontal_size ; <S2SV_StartBug> return e_error ; <S2SV_EndBug> } ps_dec -> u2_aspect_ratio_info = impeg2d_bit_stream_get ( ps_stream , 4 ) ; ps_dec -> u2_frame_rate_code = impeg2d_bit_stream_get ( ps_stream , 4 ) ; if ( ps_dec -> u2_frame_rate_code > MPEG2_MAX_FRAME_RATE_CODE ) { return IMPEG2D_FRM_HDR_DECODE_ERR ; } impeg2d_bit_stream_flush ( ps_stream , 18 ) ; GET_MARKER_BIT ( ps_dec , ps_stream ) ; impeg2d_bit_stream_flush ( ps_stream , 11 ) ; if ( impeg2d_bit_stream_get_bit ( ps_stream ) == 1 ) { UWORD16 i ; for ( i = 0 ; i < NUM_PELS_IN_BLOCK ; i ++ ) { ps_dec -> au1_intra_quant_matrix [ gau1_impeg2_inv_scan_zig_zag [ i ] ] = ( UWORD8 ) impeg2d_bit_stream_get ( ps_stream , 8 ) ; } } else { memcpy ( ps_dec -> au1_intra_quant_matrix , gau1_impeg2_intra_quant_matrix_default , NUM_PELS_IN_BLOCK ) ; } if ( impeg2d_bit_stream_get_bit ( ps_stream ) == 1 ) { UWORD16 i ; for ( i = 0 ; i < NUM_PELS_IN_BLOCK ; i ++ ) { ps_dec -> au1_inter_quant_matrix [ gau1_impeg2_inv_scan_zig_zag [ i ] ] = ( UWORD8 ) impeg2d_bit_stream_get ( ps_stream , 8 ) ; } } else { memcpy ( ps_dec -> au1_inter_quant_matrix , gau1_impeg2_inter_quant_matrix_default , NUM_PELS_IN_BLOCK ) ; } impeg2d_next_start_code ( ps_dec ) ; return ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE ; }
","<S2SV_ModStart> = u2_height ; } else { <S2SV_ModStart> == ps_dec -> i4_pic_count ) { return ( IMPEG2D_ERROR_CODES_T ) IMPEG2D_FRM_HDR_DECODE_ERR ; } else if ( ( u2_width > ps_dec -> u2_create_max_width ) || ( u2_height > ps_dec -> u2_create_max_height ) ) { IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS ; ps_dec -> u2_reinit_max_height = u2_height ; ps_dec -> u2_reinit_max_width = u2_width ; return e_error <S2SV_ModEnd> ; } else <S2SV_ModStart> if ( ( ps_dec -> u2_horizontal_size < MIN_WIDTH <S2SV_ModEnd> ) || ( <S2SV_ModStart> ) || ( ps_dec -> u2_vertical_size < MIN_HEIGHT ) ) { return IMPEG2D_UNSUPPORTED_DIMENSIONS <S2SV_ModEnd> ; } else <S2SV_ModStart> ; return e_error ; } if ( ( ps_dec -> u2_horizontal_size < MIN_WIDTH ) || ( ps_dec -> u2_vertical_size < MIN_HEIGHT ) ) { return IMPEG2D_UNSUPPORTED_DIMENSIONS
"
120,"CWE-119 static plist_t parse_string_node ( const char * * bnode , uint64_t size ) { plist_data_t data = plist_new_plist_data ( ) ; data -> type = PLIST_STRING ; data -> strval = ( char * ) malloc ( sizeof ( char ) * ( size + 1 ) ) ; <S2SV_StartBug> memcpy ( data -> strval , * bnode , size ) ; <S2SV_EndBug> data -> strval [ size ] = '\\0' ; data -> length = strlen ( data -> strval ) ; return node_create ( NULL , data ) ; }
","<S2SV_ModStart> ) ) ; if ( ! data -> strval ) { plist_free_data ( data ) ; PLIST_BIN_ERR ( ""%s:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>%"" PRIu64 ""<S2SV_blank>bytes\\n"" , __func__ , sizeof ( char ) * ( size + 1 ) ) ; return NULL ; }
"
121,"CWE-369 static void box_blur_line ( gint box_width , gint even_offset , guchar * src , guchar * dest , gint len , gint bpp ) { gint i ; gint lead ; gint output ; gint trail ; <S2SV_StartBug> gint * ac ; <S2SV_EndBug> ac = g_new0 ( gint , bpp ) ; lead = 0 ; if ( box_width % 2 != 0 ) { output = lead - ( box_width - 1 ) / 2 ; trail = lead - box_width ; } else { if ( even_offset == 1 ) { output = lead + 1 - box_width / 2 ; trail = lead - box_width ; } else if ( even_offset == - 1 ) { output = lead - box_width / 2 ; trail = lead - box_width ; } else { g_assert_not_reached ( ) ; } } for ( i = 0 ; i < bpp ; i ++ ) ac [ i ] = 0 ; while ( output < len ) { guint coverage = ( lead < len ? lead : len - 1 ) - ( trail >= 0 ? trail : - 1 ) ; # ifdef READABLE_BOXBLUR_CODE for ( i = 0 ; i < bpp ; i ++ ) { if ( lead < len ) ac [ i ] += src [ bpp * lead + i ] ; if ( trail >= 0 ) ac [ i ] -= src [ bpp * trail + i ] ; if ( output >= 0 ) dest [ bpp * output + i ] = ( ac [ i ] + ( coverage >> 1 ) ) / coverage ; } # endif if ( lead < len ) { if ( trail >= 0 ) { for ( i = 0 ; i < bpp ; i ++ ) { ac [ i ] += src [ bpp * lead + i ] ; ac [ i ] -= src [ bpp * trail + i ] ; dest [ bpp * output + i ] = ( ac [ i ] + ( coverage >> 1 ) ) / coverage ; } } else if ( output >= 0 ) { for ( i = 0 ; i < bpp ; i ++ ) { ac [ i ] += src [ bpp * lead + i ] ; dest [ bpp * output + i ] = ( ac [ i ] + ( coverage >> 1 ) ) / coverage ; } } else { for ( i = 0 ; i < bpp ; i ++ ) ac [ i ] += src [ bpp * lead + i ] ; } } else if ( trail >= 0 ) { for ( i = 0 ; i < bpp ; i ++ ) { ac [ i ] -= src [ bpp * trail + i ] ; dest [ bpp * output + i ] = ( ac [ i ] + ( coverage >> 1 ) ) / coverage ; } } else if ( output >= 0 ) { for ( i = 0 ; i < bpp ; i ++ ) dest [ bpp * output + i ] = ( ac [ i ] + ( coverage >> 1 ) ) / coverage ; } lead ++ ; output ++ ; trail ++ ; } g_free ( ac ) ; }
","<S2SV_ModStart> gint * ac ; g_assert ( box_width > 0 )
"
122,"CWE-476 static int nsv_read_chunk ( AVFormatContext * s , int fill_header ) { NSVContext * nsv = s -> priv_data ; AVIOContext * pb = s -> pb ; AVStream * st [ 2 ] = { NULL , NULL } ; NSVStream * nst ; AVPacket * pkt ; int i , err = 0 ; uint8_t auxcount ; uint32_t vsize ; uint16_t asize ; <S2SV_StartBug> uint16_t auxsize ; <S2SV_EndBug> if ( nsv -> ahead [ 0 ] . data || nsv -> ahead [ 1 ] . data ) return 0 ; null_chunk_retry : if ( pb -> eof_reached ) return - 1 ; for ( i = 0 ; i < NSV_MAX_RESYNC_TRIES && nsv -> state < NSV_FOUND_NSVS && ! err ; i ++ ) err = nsv_resync ( s ) ; if ( err < 0 ) return err ; if ( nsv -> state == NSV_FOUND_NSVS ) err = nsv_parse_NSVs_header ( s ) ; if ( err < 0 ) return err ; if ( nsv -> state != NSV_HAS_READ_NSVS && nsv -> state != NSV_FOUND_BEEF ) return - 1 ; auxcount = avio_r8 ( pb ) ; vsize = avio_rl16 ( pb ) ; asize = avio_rl16 ( pb ) ; vsize = ( vsize << 4 ) | ( auxcount >> 4 ) ; auxcount &= 0x0f ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>CHUNK<S2SV_blank>%"" PRIu8 ""<S2SV_blank>aux,<S2SV_blank>%"" PRIu32 ""<S2SV_blank>bytes<S2SV_blank>video,<S2SV_blank>%"" PRIu16 ""<S2SV_blank>bytes<S2SV_blank>audio\\n"" , auxcount , vsize , asize ) ; for ( i = 0 ; i < auxcount ; i ++ ) { uint32_t av_unused auxtag ; auxsize = avio_rl16 ( pb ) ; auxtag = avio_rl32 ( pb ) ; avio_skip ( pb , auxsize ) ; vsize -= auxsize + sizeof ( uint16_t ) + sizeof ( uint32_t ) ; } if ( pb -> eof_reached ) return - 1 ; if ( ! vsize && ! asize ) { nsv -> state = NSV_UNSYNC ; goto null_chunk_retry ; } if ( s -> nb_streams > 0 ) st [ s -> streams [ 0 ] -> id ] = s -> streams [ 0 ] ; if ( s -> nb_streams > 1 ) st [ s -> streams [ 1 ] -> id ] = s -> streams [ 1 ] ; if ( vsize && st [ NSV_ST_VIDEO ] ) { nst = st [ NSV_ST_VIDEO ] -> priv_data ; pkt = & nsv -> ahead [ NSV_ST_VIDEO ] ; <S2SV_StartBug> av_get_packet ( pb , pkt , vsize ) ; <S2SV_EndBug> pkt -> stream_index = st [ NSV_ST_VIDEO ] -> index ; pkt -> dts = nst -> frame_offset ; pkt -> flags |= nsv -> state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0 ; for ( i = 0 ; i < FFMIN ( 8 , vsize ) ; i ++ ) av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>video:<S2SV_blank>[%d]<S2SV_blank>=<S2SV_blank>%02"" PRIx8 ""\\n"" , i , pkt -> data [ i ] ) ; } if ( st [ NSV_ST_VIDEO ] ) ( ( NSVStream * ) st [ NSV_ST_VIDEO ] -> priv_data ) -> frame_offset ++ ; if ( asize && st [ NSV_ST_AUDIO ] ) { nst = st [ NSV_ST_AUDIO ] -> priv_data ; pkt = & nsv -> ahead [ NSV_ST_AUDIO ] ; if ( asize && st [ NSV_ST_AUDIO ] -> codecpar -> codec_tag == MKTAG ( 'P' , 'C' , 'M' , '<S2SV_blank>' ) ) { uint8_t bps ; uint8_t channels ; uint16_t samplerate ; bps = avio_r8 ( pb ) ; channels = avio_r8 ( pb ) ; samplerate = avio_rl16 ( pb ) ; if ( ! channels || ! samplerate ) return AVERROR_INVALIDDATA ; asize -= 4 ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>RAWAUDIO:<S2SV_blank>bps<S2SV_blank>%"" PRIu8 "",<S2SV_blank>nchan<S2SV_blank>%"" PRIu8 "",<S2SV_blank>srate<S2SV_blank>%"" PRIu16 ""\\n"" , bps , channels , samplerate ) ; if ( fill_header ) { st [ NSV_ST_AUDIO ] -> need_parsing = AVSTREAM_PARSE_NONE ; if ( bps != 16 ) { av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>AUDIO<S2SV_blank>bit/sample<S2SV_blank>!=<S2SV_blank>16<S2SV_blank>(%"" PRIu8 "")!!!\\n"" , bps ) ; } bps /= channels ; if ( bps == 8 ) st [ NSV_ST_AUDIO ] -> codecpar -> codec_id = AV_CODEC_ID_PCM_U8 ; samplerate /= 4 ; channels = 1 ; st [ NSV_ST_AUDIO ] -> codecpar -> channels = channels ; st [ NSV_ST_AUDIO ] -> codecpar -> sample_rate = samplerate ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>RAWAUDIO:<S2SV_blank>bps<S2SV_blank>%"" PRIu8 "",<S2SV_blank>nchan<S2SV_blank>%"" PRIu8 "",<S2SV_blank>srate<S2SV_blank>%"" PRIu16 ""\\n"" , bps , channels , samplerate ) ; } } <S2SV_StartBug> av_get_packet ( pb , pkt , asize ) ; <S2SV_EndBug> pkt -> stream_index = st [ NSV_ST_AUDIO ] -> index ; pkt -> flags |= nsv -> state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0 ; if ( nsv -> state == NSV_HAS_READ_NSVS && st [ NSV_ST_VIDEO ] ) { pkt -> dts = ( ( ( NSVStream * ) st [ NSV_ST_VIDEO ] -> priv_data ) -> frame_offset - 1 ) ; pkt -> dts *= ( int64_t ) 1000 * nsv -> framerate . den ; pkt -> dts += ( int64_t ) nsv -> avsync * nsv -> framerate . num ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>AUDIO:<S2SV_blank>sync:%"" PRId16 "",<S2SV_blank>dts:%"" PRId64 , nsv -> avsync , pkt -> dts ) ; } nst -> frame_offset ++ ; } nsv -> state = NSV_UNSYNC ; return 0 ; }
","<S2SV_ModStart> ; uint16_t auxsize ; int ret <S2SV_ModStart> NSV_ST_VIDEO ] ; if ( ( ret = <S2SV_ModStart> , vsize ) ) < 0 ) return ret <S2SV_ModStart> ; } } if ( ( ret = <S2SV_ModStart> , asize ) ) < 0 ) return ret
"
123,"CWE-401 static int ca8210_probe ( struct spi_device * spi_device ) { struct ca8210_priv * priv ; struct ieee802154_hw * hw ; struct ca8210_platform_data * pdata ; int ret ; dev_info ( & spi_device -> dev , ""Inserting<S2SV_blank>ca8210\\n"" ) ; hw = ieee802154_alloc_hw ( sizeof ( struct ca8210_priv ) , & ca8210_phy_ops ) ; if ( ! hw ) { dev_crit ( & spi_device -> dev , ""ieee802154_alloc_hw<S2SV_blank>failed\\n"" ) ; ret = - ENOMEM ; goto error ; } priv = hw -> priv ; priv -> hw = hw ; priv -> spi = spi_device ; hw -> parent = & spi_device -> dev ; spin_lock_init ( & priv -> lock ) ; priv -> async_tx_pending = false ; priv -> hw_registered = false ; priv -> sync_up = 0 ; priv -> sync_down = 0 ; priv -> promiscuous = false ; priv -> retries = 0 ; init_completion ( & priv -> ca8210_is_awake ) ; init_completion ( & priv -> spi_transfer_complete ) ; init_completion ( & priv -> sync_exchange_complete ) ; spi_set_drvdata ( priv -> spi , priv ) ; if ( IS_ENABLED ( CONFIG_IEEE802154_CA8210_DEBUGFS ) ) { cascoda_api_upstream = ca8210_test_int_driver_write ; ca8210_test_interface_init ( priv ) ; } else { cascoda_api_upstream = NULL ; } ca8210_hw_setup ( hw ) ; ieee802154_random_extended_addr ( & hw -> phy -> perm_extended_addr ) ; pdata = kmalloc ( sizeof ( * pdata ) , GFP_KERNEL ) ; if ( ! pdata ) { ret = - ENOMEM ; goto error ; } <S2SV_StartBug> ret = ca8210_get_platform_data ( priv -> spi , pdata ) ; <S2SV_EndBug> if ( ret ) { dev_crit ( & spi_device -> dev , ""ca8210_get_platform_data<S2SV_blank>failed\\n"" ) ; goto error ; } priv -> spi -> dev . platform_data = pdata ; <S2SV_StartBug> ret = ca8210_dev_com_init ( priv ) ; <S2SV_EndBug> if ( ret ) { dev_crit ( & spi_device -> dev , ""ca8210_dev_com_init<S2SV_blank>failed\\n"" ) ; goto error ; } ret = ca8210_reset_init ( priv -> spi ) ; if ( ret ) { dev_crit ( & spi_device -> dev , ""ca8210_reset_init<S2SV_blank>failed\\n"" ) ; goto error ; } ret = ca8210_interrupt_init ( priv -> spi ) ; if ( ret ) { dev_crit ( & spi_device -> dev , ""ca8210_interrupt_init<S2SV_blank>failed\\n"" ) ; goto error ; } msleep ( 100 ) ; ca8210_reset_send ( priv -> spi , 1 ) ; ret = tdme_chipinit ( priv -> spi ) ; if ( ret ) { dev_crit ( & spi_device -> dev , ""tdme_chipinit<S2SV_blank>failed\\n"" ) ; goto error ; } if ( pdata -> extclockenable ) { ret = ca8210_config_extern_clk ( pdata , priv -> spi , 1 ) ; if ( ret ) { dev_crit ( & spi_device -> dev , ""ca8210_config_extern_clk<S2SV_blank>failed\\n"" ) ; goto error ; } ret = ca8210_register_ext_clock ( priv -> spi ) ; if ( ret ) { dev_crit ( & spi_device -> dev , ""ca8210_register_ext_clock<S2SV_blank>failed\\n"" ) ; goto error ; } } ret = ieee802154_register_hw ( hw ) ; if ( ret ) { dev_crit ( & spi_device -> dev , ""ieee802154_register_hw<S2SV_blank>failed\\n"" ) ; goto error ; } priv -> hw_registered = true ; return 0 ; error : msleep ( 100 ) ; ca8210_remove ( spi_device ) ; return link_to_linux_err ( ret ) ; }
","<S2SV_ModStart> error ; } <S2SV_ModEnd> priv -> spi <S2SV_ModStart> ; ret = ca8210_get_platform_data ( priv -> spi , pdata ) ; if ( ret ) { dev_crit ( & spi_device -> dev , ""ca8210_get_platform_data<S2SV_blank>failed\\n"" ) ; goto error ; } ret =
"
124,"CWE-125 PyMODINIT_FUNC PyInit__ast ( void ) { PyObject * m , * d ; if ( ! init_types ( ) ) return NULL ; m = PyModule_Create ( & _astmodule ) ; if ( ! m ) return NULL ; d = PyModule_GetDict ( m ) ; if ( PyDict_SetItemString ( d , ""AST"" , ( PyObject * ) & AST_type ) < 0 ) return NULL ; if ( PyModule_AddIntMacro ( m , PyCF_ONLY_AST ) < 0 ) return NULL ; <S2SV_StartBug> if ( PyDict_SetItemString ( d , ""mod"" , ( PyObject * ) mod_type ) < 0 ) return NULL ; <S2SV_EndBug> if ( PyDict_SetItemString ( d , ""Module"" , ( PyObject * ) Module_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Interactive"" , ( PyObject * ) Interactive_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Expression"" , ( PyObject * ) Expression_type ) < 0 ) return NULL ; <S2SV_StartBug> if ( PyDict_SetItemString ( d , ""Suite"" , ( PyObject * ) Suite_type ) < 0 ) return <S2SV_EndBug> NULL ; if ( PyDict_SetItemString ( d , ""stmt"" , ( PyObject * ) stmt_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""FunctionDef"" , ( PyObject * ) FunctionDef_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""AsyncFunctionDef"" , ( PyObject * ) AsyncFunctionDef_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""ClassDef"" , ( PyObject * ) ClassDef_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Return"" , ( PyObject * ) Return_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Delete"" , ( PyObject * ) Delete_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Assign"" , ( PyObject * ) Assign_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""AugAssign"" , ( PyObject * ) AugAssign_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""AnnAssign"" , ( PyObject * ) AnnAssign_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""For"" , ( PyObject * ) For_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""AsyncFor"" , ( PyObject * ) AsyncFor_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""While"" , ( PyObject * ) While_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""If"" , ( PyObject * ) If_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""With"" , ( PyObject * ) With_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""AsyncWith"" , ( PyObject * ) AsyncWith_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Raise"" , ( PyObject * ) Raise_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Try"" , ( PyObject * ) Try_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Assert"" , ( PyObject * ) Assert_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Import"" , ( PyObject * ) Import_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""ImportFrom"" , ( PyObject * ) ImportFrom_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Global"" , ( PyObject * ) Global_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Nonlocal"" , ( PyObject * ) Nonlocal_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Expr"" , ( PyObject * ) Expr_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Pass"" , ( PyObject * ) Pass_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Break"" , ( PyObject * ) Break_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Continue"" , ( PyObject * ) Continue_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""expr"" , ( PyObject * ) expr_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""BoolOp"" , ( PyObject * ) BoolOp_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""NamedExpr"" , ( PyObject * ) NamedExpr_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""BinOp"" , ( PyObject * ) BinOp_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""UnaryOp"" , ( PyObject * ) UnaryOp_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Lambda"" , ( PyObject * ) Lambda_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""IfExp"" , ( PyObject * ) IfExp_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Dict"" , ( PyObject * ) Dict_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Set"" , ( PyObject * ) Set_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""ListComp"" , ( PyObject * ) ListComp_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""SetComp"" , ( PyObject * ) SetComp_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""DictComp"" , ( PyObject * ) DictComp_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""GeneratorExp"" , ( PyObject * ) GeneratorExp_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Await"" , ( PyObject * ) Await_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Yield"" , ( PyObject * ) Yield_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""YieldFrom"" , ( PyObject * ) YieldFrom_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Compare"" , ( PyObject * ) Compare_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Call"" , ( PyObject * ) Call_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""FormattedValue"" , ( PyObject * ) FormattedValue_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""JoinedStr"" , ( PyObject * ) JoinedStr_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Constant"" , ( PyObject * ) Constant_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Attribute"" , ( PyObject * ) Attribute_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Subscript"" , ( PyObject * ) Subscript_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Starred"" , ( PyObject * ) Starred_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Name"" , ( PyObject * ) Name_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""List"" , ( PyObject * ) List_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Tuple"" , ( PyObject * ) Tuple_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""expr_context"" , ( PyObject * ) expr_context_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Load"" , ( PyObject * ) Load_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Store"" , ( PyObject * ) Store_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Del"" , ( PyObject * ) Del_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""AugLoad"" , ( PyObject * ) AugLoad_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""AugStore"" , ( PyObject * ) AugStore_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Param"" , ( PyObject * ) Param_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""NamedStore"" , ( PyObject * ) NamedStore_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""slice"" , ( PyObject * ) slice_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Slice"" , ( PyObject * ) Slice_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""ExtSlice"" , ( PyObject * ) ExtSlice_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Index"" , ( PyObject * ) Index_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""boolop"" , ( PyObject * ) boolop_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""And"" , ( PyObject * ) And_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Or"" , ( PyObject * ) Or_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""operator"" , ( PyObject * ) operator_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Add"" , ( PyObject * ) Add_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Sub"" , ( PyObject * ) Sub_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Mult"" , ( PyObject * ) Mult_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""MatMult"" , ( PyObject * ) MatMult_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Div"" , ( PyObject * ) Div_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Mod"" , ( PyObject * ) Mod_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Pow"" , ( PyObject * ) Pow_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""LShift"" , ( PyObject * ) LShift_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""RShift"" , ( PyObject * ) RShift_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""BitOr"" , ( PyObject * ) BitOr_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""BitXor"" , ( PyObject * ) BitXor_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""BitAnd"" , ( PyObject * ) BitAnd_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""FloorDiv"" , ( PyObject * ) FloorDiv_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""unaryop"" , ( PyObject * ) unaryop_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Invert"" , ( PyObject * ) Invert_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Not"" , ( PyObject * ) Not_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""UAdd"" , ( PyObject * ) UAdd_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""USub"" , ( PyObject * ) USub_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""cmpop"" , ( PyObject * ) cmpop_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Eq"" , ( PyObject * ) Eq_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""NotEq"" , ( PyObject * ) NotEq_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Lt"" , ( PyObject * ) Lt_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""LtE"" , ( PyObject * ) LtE_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Gt"" , ( PyObject * ) Gt_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""GtE"" , ( PyObject * ) GtE_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Is"" , ( PyObject * ) Is_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""IsNot"" , ( PyObject * ) IsNot_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""In"" , ( PyObject * ) In_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""NotIn"" , ( PyObject * ) NotIn_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""comprehension"" , ( PyObject * ) comprehension_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""excepthandler"" , ( PyObject * ) excepthandler_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""ExceptHandler"" , ( PyObject * ) ExceptHandler_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""arguments"" , ( PyObject * ) arguments_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""arg"" , ( PyObject * ) arg_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""keyword"" , ( PyObject * ) keyword_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""alias"" , ( PyObject * ) alias_type ) < 0 ) return NULL ; <S2SV_StartBug> if ( PyDict_SetItemString ( d , ""withitem"" , ( PyObject * ) withitem_type ) < 0 ) <S2SV_EndBug> return NULL ; return m ; }
","<S2SV_ModStart> ; if ( PyModule_AddIntMacro ( m , PyCF_TYPE_COMMENTS ) < 0 ) return NULL ; if ( <S2SV_ModStart> ( d , ""FunctionType"" , ( PyObject * ) FunctionType_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , <S2SV_ModStart> * ) withitem_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""type_ignore"" , ( PyObject * ) type_ignore_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""TypeIgnore"" , ( PyObject * ) TypeIgnore_type
"
125,"CWE-119 struct se_portal_group * tcm_loop_make_naa_tpg ( struct se_wwn * wwn , struct config_group * group , const char * name ) { struct tcm_loop_hba * tl_hba = container_of ( wwn , struct tcm_loop_hba , tl_hba_wwn ) ; struct tcm_loop_tpg * tl_tpg ; char * tpgt_str , * end_ptr ; int ret ; unsigned short int tpgt ; tpgt_str = strstr ( name , ""tpgt_"" ) ; if ( ! tpgt_str ) { printk ( KERN_ERR ""Unable<S2SV_blank>to<S2SV_blank>locate<S2SV_blank>\\""tpgt_#\\""<S2SV_blank>directory"" ""<S2SV_blank>group\\n"" ) ; return ERR_PTR ( - EINVAL ) ; } tpgt_str += 5 ; tpgt = ( unsigned short int ) simple_strtoul ( tpgt_str , & end_ptr , 0 ) ; <S2SV_StartBug> if ( tpgt > TL_TPGS_PER_HBA ) { <S2SV_EndBug> printk ( KERN_ERR ""Passed<S2SV_blank>tpgt:<S2SV_blank>%hu<S2SV_blank>exceeds<S2SV_blank>TL_TPGS_PER_HBA:"" ""<S2SV_blank>%u\\n"" , tpgt , TL_TPGS_PER_HBA ) ; return ERR_PTR ( - EINVAL ) ; } tl_tpg = & tl_hba -> tl_hba_tpgs [ tpgt ] ; tl_tpg -> tl_hba = tl_hba ; tl_tpg -> tl_tpgt = tpgt ; ret = core_tpg_register ( & tcm_loop_fabric_configfs -> tf_ops , wwn , & tl_tpg -> tl_se_tpg , tl_tpg , TRANSPORT_TPG_TYPE_NORMAL ) ; if ( ret < 0 ) return ERR_PTR ( - ENOMEM ) ; printk ( KERN_INFO ""TCM_Loop_ConfigFS:<S2SV_blank>Allocated<S2SV_blank>Emulated<S2SV_blank>%s"" ""<S2SV_blank>Target<S2SV_blank>Port<S2SV_blank>%s,t,0x%04x\\n"" , tcm_loop_dump_proto_id ( tl_hba ) , config_item_name ( & wwn -> wwn_group . cg_item ) , tpgt ) ; return & tl_tpg -> tl_se_tpg ; }
","<S2SV_ModStart> if ( tpgt >= <S2SV_ModEnd> TL_TPGS_PER_HBA ) {
"
126,"CWE-416 int snd_timer_open ( struct snd_timer_instance * * ti , char * owner , struct snd_timer_id * tid , unsigned int slave_id ) { struct snd_timer * timer ; struct snd_timer_instance * timeri = NULL ; struct device * card_dev_to_put = NULL ; int err ; mutex_lock ( & register_mutex ) ; if ( tid -> dev_class == SNDRV_TIMER_CLASS_SLAVE ) { if ( tid -> dev_sclass <= SNDRV_TIMER_SCLASS_NONE || tid -> dev_sclass > SNDRV_TIMER_SCLASS_OSS_SEQUENCER ) { pr_debug ( ""ALSA:<S2SV_blank>timer:<S2SV_blank>invalid<S2SV_blank>slave<S2SV_blank>class<S2SV_blank>%i\\n"" , tid -> dev_sclass ) ; err = - EINVAL ; goto unlock ; } timeri = snd_timer_instance_new ( owner , NULL ) ; if ( ! timeri ) { err = - ENOMEM ; goto unlock ; } timeri -> slave_class = tid -> dev_sclass ; timeri -> slave_id = tid -> device ; timeri -> flags |= SNDRV_TIMER_IFLG_SLAVE ; list_add_tail ( & timeri -> open_list , & snd_timer_slave_list ) ; err = snd_timer_check_slave ( timeri ) ; if ( err < 0 ) { snd_timer_close_locked ( timeri , & card_dev_to_put ) ; timeri = NULL ; } goto unlock ; } timer = snd_timer_find ( tid ) ; # ifdef CONFIG_MODULES if ( ! timer ) { mutex_unlock ( & register_mutex ) ; snd_timer_request ( tid ) ; mutex_lock ( & register_mutex ) ; timer = snd_timer_find ( tid ) ; } # endif if ( ! timer ) { err = - ENODEV ; goto unlock ; } if ( ! list_empty ( & timer -> open_list_head ) ) { <S2SV_StartBug> timeri = list_entry ( timer -> open_list_head . next , <S2SV_EndBug> struct snd_timer_instance , open_list ) ; <S2SV_StartBug> if ( timeri -> flags & SNDRV_TIMER_IFLG_EXCLUSIVE ) { <S2SV_EndBug> <S2SV_StartBug> err = - EBUSY ; <S2SV_EndBug> timeri = NULL ; goto unlock ; } } if ( timer -> num_instances >= timer -> max_instances ) { err = - EBUSY ; goto unlock ; } timeri = snd_timer_instance_new ( owner , timer ) ; if ( ! timeri ) { err = - ENOMEM ; goto unlock ; } if ( timer -> card ) get_device ( & timer -> card -> card_dev ) ; timeri -> slave_class = tid -> dev_sclass ; timeri -> slave_id = slave_id ; if ( list_empty ( & timer -> open_list_head ) && timer -> hw . open ) { err = timer -> hw . open ( timer ) ; if ( err ) { kfree ( timeri -> owner ) ; kfree ( timeri ) ; timeri = NULL ; if ( timer -> card ) card_dev_to_put = & timer -> card -> card_dev ; module_put ( timer -> module ) ; goto unlock ; } } list_add_tail ( & timeri -> open_list , & timer -> open_list_head ) ; timer -> num_instances ++ ; err = snd_timer_check_master ( timeri ) ; if ( err < 0 ) { snd_timer_close_locked ( timeri , & card_dev_to_put ) ; timeri = NULL ; } unlock : mutex_unlock ( & register_mutex ) ; if ( card_dev_to_put ) put_device ( card_dev_to_put ) ; * ti = timeri ; return err ; }
","<S2SV_ModStart> ) ) { struct snd_timer_instance * t = <S2SV_ModEnd> list_entry ( timer <S2SV_ModStart> ; if ( t <S2SV_ModEnd> -> flags & <S2SV_ModStart> = - EBUSY <S2SV_ModEnd> ; goto unlock
"
127,"CWE-119 int32_t DownmixLib_Create ( const effect_uuid_t * uuid , <S2SV_StartBug> int32_t sessionId , <S2SV_EndBug> <S2SV_StartBug> int32_t ioId , <S2SV_EndBug> effect_handle_t * pHandle ) { int ret ; int i ; downmix_module_t * module ; const effect_descriptor_t * desc ; ALOGV ( ""DownmixLib_Create()"" ) ; # ifdef DOWNMIX_TEST_CHANNEL_INDEX ALOGI ( ""DOWNMIX_TEST_CHANNEL_INDEX:<S2SV_blank>should<S2SV_blank>work:"" ) ; Downmix_testIndexComputation ( AUDIO_CHANNEL_OUT_FRONT_LEFT | AUDIO_CHANNEL_OUT_FRONT_RIGHT | AUDIO_CHANNEL_OUT_LOW_FREQUENCY | AUDIO_CHANNEL_OUT_BACK_CENTER ) ; Downmix_testIndexComputation ( CHANNEL_MASK_QUAD_SIDE | CHANNEL_MASK_QUAD_BACK ) ; Downmix_testIndexComputation ( CHANNEL_MASK_5POINT1_SIDE | AUDIO_CHANNEL_OUT_BACK_CENTER ) ; Downmix_testIndexComputation ( CHANNEL_MASK_5POINT1_BACK | AUDIO_CHANNEL_OUT_BACK_CENTER ) ; ALOGI ( ""DOWNMIX_TEST_CHANNEL_INDEX:<S2SV_blank>should<S2SV_blank>NOT<S2SV_blank>work:"" ) ; Downmix_testIndexComputation ( AUDIO_CHANNEL_OUT_FRONT_LEFT | AUDIO_CHANNEL_OUT_FRONT_RIGHT | AUDIO_CHANNEL_OUT_LOW_FREQUENCY | AUDIO_CHANNEL_OUT_BACK_LEFT ) ; Downmix_testIndexComputation ( AUDIO_CHANNEL_OUT_FRONT_LEFT | AUDIO_CHANNEL_OUT_FRONT_RIGHT | AUDIO_CHANNEL_OUT_LOW_FREQUENCY | AUDIO_CHANNEL_OUT_SIDE_LEFT ) ; Downmix_testIndexComputation ( AUDIO_CHANNEL_OUT_FRONT_LEFT | AUDIO_CHANNEL_OUT_BACK_LEFT | AUDIO_CHANNEL_OUT_BACK_RIGHT ) ; Downmix_testIndexComputation ( AUDIO_CHANNEL_OUT_FRONT_LEFT | AUDIO_CHANNEL_OUT_SIDE_LEFT | AUDIO_CHANNEL_OUT_SIDE_RIGHT ) ; # endif if ( pHandle == NULL || uuid == NULL ) { return - EINVAL ; } for ( i = 0 ; i < kNbEffects ; i ++ ) { desc = gDescriptors [ i ] ; if ( memcmp ( uuid , & desc -> uuid , sizeof ( effect_uuid_t ) ) == 0 ) { break ; } } if ( i == kNbEffects ) { return - ENOENT ; } module = malloc ( sizeof ( downmix_module_t ) ) ; module -> itfe = & gDownmixInterface ; module -> context . state = DOWNMIX_STATE_UNINITIALIZED ; ret = Downmix_Init ( module ) ; if ( ret < 0 ) { ALOGW ( ""DownmixLib_Create()<S2SV_blank>init<S2SV_blank>failed"" ) ; free ( module ) ; return ret ; } * pHandle = ( effect_handle_t ) module ; ALOGV ( ""DownmixLib_Create()<S2SV_blank>%p<S2SV_blank>,<S2SV_blank>size<S2SV_blank>%zu"" , module , sizeof ( downmix_module_t ) ) ; return 0 ; }
","<S2SV_ModStart> , int32_t sessionId __unused <S2SV_ModStart> , int32_t ioId __unused
"
128,"CWE-119 static int nl80211_start_sched_scan ( struct sk_buff * skb , struct genl_info * info ) { struct cfg80211_sched_scan_request * request ; struct cfg80211_registered_device * rdev = info -> user_ptr [ 0 ] ; struct net_device * dev = info -> user_ptr [ 1 ] ; struct nlattr * attr ; struct wiphy * wiphy ; int err , tmp , n_ssids = 0 , n_channels , i ; u32 interval ; enum ieee80211_band band ; size_t ie_len ; if ( ! ( rdev -> wiphy . flags & WIPHY_FLAG_SUPPORTS_SCHED_SCAN ) || ! rdev -> ops -> sched_scan_start ) return - EOPNOTSUPP ; if ( ! is_valid_ie_attr ( info -> attrs [ NL80211_ATTR_IE ] ) ) return - EINVAL ; if ( rdev -> sched_scan_req ) return - EINPROGRESS ; if ( ! info -> attrs [ NL80211_ATTR_SCHED_SCAN_INTERVAL ] ) return - EINVAL ; interval = nla_get_u32 ( info -> attrs [ NL80211_ATTR_SCHED_SCAN_INTERVAL ] ) ; if ( interval == 0 ) return - EINVAL ; wiphy = & rdev -> wiphy ; if ( info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] ) { n_channels = validate_scan_freqs ( info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] ) ; if ( ! n_channels ) return - EINVAL ; } else { n_channels = 0 ; for ( band = 0 ; band < IEEE80211_NUM_BANDS ; band ++ ) if ( wiphy -> bands [ band ] ) n_channels += wiphy -> bands [ band ] -> n_channels ; } if ( info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] ) nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] , tmp ) n_ssids ++ ; if ( n_ssids > wiphy -> max_scan_ssids ) return - EINVAL ; if ( info -> attrs [ NL80211_ATTR_IE ] ) ie_len = nla_len ( info -> attrs [ NL80211_ATTR_IE ] ) ; else ie_len = 0 ; if ( ie_len > wiphy -> max_scan_ie_len ) return - EINVAL ; request = kzalloc ( sizeof ( * request ) + sizeof ( * request -> ssids ) * n_ssids + sizeof ( * request -> channels ) * n_channels + ie_len , GFP_KERNEL ) ; if ( ! request ) return - ENOMEM ; if ( n_ssids ) request -> ssids = ( void * ) & request -> channels [ n_channels ] ; request -> n_ssids = n_ssids ; if ( ie_len ) { if ( request -> ssids ) request -> ie = ( void * ) ( request -> ssids + n_ssids ) ; else request -> ie = ( void * ) ( request -> channels + n_channels ) ; } i = 0 ; if ( info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] ) { nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] , tmp ) { struct ieee80211_channel * chan ; chan = ieee80211_get_channel ( wiphy , nla_get_u32 ( attr ) ) ; if ( ! chan ) { err = - EINVAL ; goto out_free ; } if ( chan -> flags & IEEE80211_CHAN_DISABLED ) continue ; request -> channels [ i ] = chan ; i ++ ; } } else { for ( band = 0 ; band < IEEE80211_NUM_BANDS ; band ++ ) { int j ; if ( ! wiphy -> bands [ band ] ) continue ; for ( j = 0 ; j < wiphy -> bands [ band ] -> n_channels ; j ++ ) { struct ieee80211_channel * chan ; chan = & wiphy -> bands [ band ] -> channels [ j ] ; if ( chan -> flags & IEEE80211_CHAN_DISABLED ) continue ; request -> channels [ i ] = chan ; i ++ ; } } } if ( ! i ) { err = - EINVAL ; goto out_free ; } request -> n_channels = i ; i = 0 ; if ( info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] ) { nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] , tmp ) { <S2SV_StartBug> if ( request -> ssids [ i ] . ssid_len > <S2SV_EndBug> IEEE80211_MAX_SSID_LEN ) { err = - EINVAL ; goto out_free ; } memcpy ( request -> ssids [ i ] . ssid , nla_data ( attr ) , nla_len ( attr ) ) ; <S2SV_StartBug> request -> ssids [ i ] . ssid_len = nla_len ( attr ) ; <S2SV_EndBug> i ++ ; } } if ( info -> attrs [ NL80211_ATTR_IE ] ) { request -> ie_len = nla_len ( info -> attrs [ NL80211_ATTR_IE ] ) ; memcpy ( ( void * ) request -> ie , nla_data ( info -> attrs [ NL80211_ATTR_IE ] ) , request -> ie_len ) ; } request -> dev = dev ; request -> wiphy = & rdev -> wiphy ; request -> interval = interval ; err = rdev -> ops -> sched_scan_start ( & rdev -> wiphy , dev , request ) ; if ( ! err ) { rdev -> sched_scan_req = request ; nl80211_send_sched_scan ( rdev , dev , NL80211_CMD_START_SCHED_SCAN ) ; goto out ; } out_free : kfree ( request ) ; out : return err ; }
","<S2SV_ModStart> tmp ) { request -> ssids [ i ] . ssid_len = nla_len ( attr ) ; <S2SV_ModStart> ) ) ; <S2SV_ModEnd> i ++ ;
"
129,"CWE-611 void init_directory_config ( directory_config * dcfg ) { if ( dcfg == NULL ) return ; if ( dcfg -> is_enabled == NOT_SET ) dcfg -> is_enabled = 0 ; if ( dcfg -> reqbody_access == NOT_SET ) dcfg -> reqbody_access = 0 ; if ( dcfg -> reqintercept_oe == NOT_SET ) dcfg -> reqintercept_oe = 0 ; if ( dcfg -> reqbody_buffering == NOT_SET ) dcfg -> reqbody_buffering = REQUEST_BODY_FORCEBUF_OFF ; if ( dcfg -> reqbody_inmemory_limit == NOT_SET ) dcfg -> reqbody_inmemory_limit = REQUEST_BODY_DEFAULT_INMEMORY_LIMIT ; if ( dcfg -> reqbody_limit == NOT_SET ) dcfg -> reqbody_limit = REQUEST_BODY_DEFAULT_LIMIT ; if ( dcfg -> reqbody_no_files_limit == NOT_SET ) dcfg -> reqbody_no_files_limit = REQUEST_BODY_NO_FILES_DEFAULT_LIMIT ; if ( dcfg -> resbody_access == NOT_SET ) dcfg -> resbody_access = 0 ; if ( dcfg -> of_limit == NOT_SET ) dcfg -> of_limit = RESPONSE_BODY_DEFAULT_LIMIT ; if ( dcfg -> if_limit_action == NOT_SET ) dcfg -> if_limit_action = REQUEST_BODY_LIMIT_ACTION_REJECT ; if ( dcfg -> of_limit_action == NOT_SET ) dcfg -> of_limit_action = RESPONSE_BODY_LIMIT_ACTION_REJECT ; if ( dcfg -> of_mime_types == NOT_SET_P ) { dcfg -> of_mime_types = apr_table_make ( dcfg -> mp , 3 ) ; if ( dcfg -> of_mime_types_cleared != 1 ) { apr_table_setn ( dcfg -> of_mime_types , ""text/plain"" , ""1"" ) ; apr_table_setn ( dcfg -> of_mime_types , ""text/html"" , ""1"" ) ; } } if ( dcfg -> debuglog_fd == NOT_SET_P ) dcfg -> debuglog_fd = NULL ; if ( dcfg -> debuglog_name == NOT_SET_P ) dcfg -> debuglog_name = NULL ; if ( dcfg -> debuglog_level == NOT_SET ) dcfg -> debuglog_level = 0 ; if ( dcfg -> cookie_format == NOT_SET ) dcfg -> cookie_format = 0 ; if ( dcfg -> argument_separator == NOT_SET ) dcfg -> argument_separator = '&' ; if ( dcfg -> cookiev0_separator == NOT_SET_P ) dcfg -> cookiev0_separator = NULL ; if ( dcfg -> rule_inheritance == NOT_SET ) dcfg -> rule_inheritance = 1 ; if ( dcfg -> auditlog_flag == NOT_SET ) dcfg -> auditlog_flag = 0 ; if ( dcfg -> auditlog_type == NOT_SET ) dcfg -> auditlog_type = AUDITLOG_SERIAL ; if ( dcfg -> max_rule_time == NOT_SET ) dcfg -> max_rule_time = 0 ; if ( dcfg -> auditlog_dirperms == NOT_SET ) dcfg -> auditlog_dirperms = CREATEMODE_DIR ; if ( dcfg -> auditlog_fileperms == NOT_SET ) dcfg -> auditlog_fileperms = CREATEMODE ; if ( dcfg -> auditlog_fd == NOT_SET_P ) dcfg -> auditlog_fd = NULL ; if ( dcfg -> auditlog2_fd == NOT_SET_P ) dcfg -> auditlog2_fd = NULL ; if ( dcfg -> auditlog_name == NOT_SET_P ) dcfg -> auditlog_name = NULL ; if ( dcfg -> auditlog2_name == NOT_SET_P ) dcfg -> auditlog2_name = NULL ; if ( dcfg -> auditlog_storage_dir == NOT_SET_P ) dcfg -> auditlog_storage_dir = NULL ; if ( dcfg -> auditlog_parts == NOT_SET_P ) dcfg -> auditlog_parts = ""ABCFHZ"" ; if ( dcfg -> auditlog_relevant_regex == NOT_SET_P ) dcfg -> auditlog_relevant_regex = NULL ; if ( dcfg -> tmp_dir == NOT_SET_P ) dcfg -> tmp_dir = guess_tmp_dir ( dcfg -> mp ) ; if ( dcfg -> upload_dir == NOT_SET_P ) dcfg -> upload_dir = NULL ; if ( dcfg -> upload_keep_files == NOT_SET ) dcfg -> upload_keep_files = KEEP_FILES_OFF ; if ( dcfg -> upload_validates_files == NOT_SET ) dcfg -> upload_validates_files = 0 ; if ( dcfg -> upload_filemode == NOT_SET ) dcfg -> upload_filemode = 0600 ; if ( dcfg -> upload_file_limit == NOT_SET ) dcfg -> upload_file_limit = 100 ; if ( dcfg -> data_dir == NOT_SET_P ) dcfg -> data_dir = NULL ; if ( dcfg -> webappid == NOT_SET_P ) dcfg -> webappid = ""default"" ; if ( dcfg -> sensor_id == NOT_SET_P ) dcfg -> sensor_id = ""default"" ; if ( dcfg -> httpBlkey == NOT_SET_P ) dcfg -> httpBlkey = NULL ; if ( dcfg -> content_injection_enabled == NOT_SET ) dcfg -> content_injection_enabled = 0 ; if ( dcfg -> stream_inbody_inspection == NOT_SET ) dcfg -> stream_inbody_inspection = 0 ; if ( dcfg -> stream_outbody_inspection == NOT_SET ) dcfg -> stream_outbody_inspection = 0 ; if ( dcfg -> geo == NOT_SET_P ) dcfg -> geo = NULL ; if ( dcfg -> gsb == NOT_SET_P ) dcfg -> gsb = NULL ; if ( dcfg -> u_map == NOT_SET_P ) dcfg -> u_map = NULL ; if ( dcfg -> cache_trans == NOT_SET ) dcfg -> cache_trans = MODSEC_CACHE_DISABLED ; if ( dcfg -> cache_trans_incremental == NOT_SET ) dcfg -> cache_trans_incremental = 0 ; if ( dcfg -> cache_trans_min == ( apr_size_t ) NOT_SET ) dcfg -> cache_trans_min = 32 ; if ( dcfg -> cache_trans_max == ( apr_size_t ) NOT_SET ) dcfg -> cache_trans_max = 1024 ; if ( dcfg -> cache_trans_maxitems == ( apr_size_t ) NOT_SET ) dcfg -> cache_trans_maxitems = 512 ; if ( dcfg -> request_encoding == NOT_SET_P ) dcfg -> request_encoding = NULL ; if ( dcfg -> disable_backend_compression == NOT_SET ) dcfg -> disable_backend_compression = 0 ; if ( dcfg -> col_timeout == NOT_SET ) dcfg -> col_timeout = 3600 ; if ( dcfg -> crypto_key == NOT_SET_P ) dcfg -> crypto_key = getkey ( dcfg -> mp ) ; if ( dcfg -> crypto_key_len == NOT_SET ) dcfg -> crypto_key_len = strlen ( dcfg -> crypto_key ) ; if ( dcfg -> crypto_key_add == NOT_SET ) dcfg -> crypto_key_add = HASH_KEYONLY ; if ( dcfg -> crypto_param_name == NOT_SET_P ) dcfg -> crypto_param_name = ""crypt"" ; if ( dcfg -> hash_is_enabled == NOT_SET ) dcfg -> hash_is_enabled = HASH_DISABLED ; if ( dcfg -> hash_enforcement == NOT_SET ) dcfg -> hash_enforcement = HASH_DISABLED ; if ( dcfg -> crypto_hash_href_rx == NOT_SET ) dcfg -> crypto_hash_href_rx = 0 ; if ( dcfg -> crypto_hash_faction_rx == NOT_SET ) dcfg -> crypto_hash_faction_rx = 0 ; if ( dcfg -> crypto_hash_location_rx == NOT_SET ) dcfg -> crypto_hash_location_rx = 0 ; if ( dcfg -> crypto_hash_iframesrc_rx == NOT_SET ) dcfg -> crypto_hash_iframesrc_rx = 0 ; if ( dcfg -> crypto_hash_framesrc_rx == NOT_SET ) dcfg -> crypto_hash_framesrc_rx = 0 ; if ( dcfg -> crypto_hash_href_pm == NOT_SET ) dcfg -> crypto_hash_href_pm = 0 ; if ( dcfg -> crypto_hash_faction_pm == NOT_SET ) dcfg -> crypto_hash_faction_pm = 0 ; if ( dcfg -> crypto_hash_location_pm == NOT_SET ) dcfg -> crypto_hash_location_pm = 0 ; if ( dcfg -> crypto_hash_iframesrc_pm == NOT_SET ) dcfg -> crypto_hash_iframesrc_pm = 0 ; if ( dcfg -> crypto_hash_framesrc_pm == NOT_SET ) dcfg -> crypto_hash_framesrc_pm = 0 ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> = 0 ; if ( dcfg -> xml_external_entity == NOT_SET ) dcfg -> xml_external_entity = 0 ;
"
130,"CWE-119 static void multiframe_quality_enhance_block ( int blksize , int qcurr , int qprev , unsigned char * y , unsigned char * u , unsigned char * v , int y_stride , int uv_stride , unsigned char * yd , unsigned char * ud , unsigned char * vd , int yd_stride , int uvd_stride ) { static const unsigned char VP8_ZEROS [ 16 ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; int uvblksize = blksize >> 1 ; int qdiff = qcurr - qprev ; int i ; unsigned char * up ; unsigned char * udp ; unsigned char * vp ; unsigned char * vdp ; unsigned int act , actd , sad , usad , vsad , sse , thr , thrsq , actrisk ; if ( blksize == 16 ) { <S2SV_StartBug> actd = ( vp8_variance16x16 ( yd , yd_stride , VP8_ZEROS , 0 , & sse ) + 128 ) >> 8 ; <S2SV_EndBug> <S2SV_StartBug> act = ( vp8_variance16x16 ( y , y_stride , VP8_ZEROS , 0 , & sse ) + 128 ) >> 8 ; <S2SV_EndBug> # ifdef USE_SSD <S2SV_StartBug> sad = ( vp8_variance16x16 ( y , y_stride , yd , yd_stride , & sse ) ) ; <S2SV_EndBug> sad = ( sse + 128 ) >> 8 ; usad = ( vp8_variance8x8 ( u , uv_stride , ud , uvd_stride , & sse ) ) ; usad = ( sse + 32 ) >> 6 ; <S2SV_StartBug> vsad = ( vp8_variance8x8 ( v , uv_stride , vd , uvd_stride , & sse ) ) ; <S2SV_EndBug> vsad = ( sse + 32 ) >> 6 ; # else sad = ( vp8_sad16x16 ( y , y_stride , yd , yd_stride , UINT_MAX ) + 128 ) >> 8 ; usad = ( vp8_sad8x8 ( u , uv_stride , ud , uvd_stride , UINT_MAX ) + 32 ) >> 6 ; vsad = ( vp8_sad8x8 ( v , uv_stride , vd , uvd_stride , UINT_MAX ) + 32 ) >> 6 ; # endif } else { actd = ( vp8_variance8x8 ( yd , yd_stride , VP8_ZEROS , 0 , & sse ) + 32 ) >> 6 ; <S2SV_StartBug> act = ( vp8_variance8x8 ( y , y_stride , VP8_ZEROS , 0 , & sse ) + 32 ) >> 6 ; <S2SV_EndBug> # ifdef USE_SSD <S2SV_StartBug> sad = ( vp8_variance8x8 ( y , y_stride , yd , yd_stride , & sse ) ) ; <S2SV_EndBug> sad = ( sse + 32 ) >> 6 ; <S2SV_StartBug> usad = ( vp8_variance4x4 ( u , uv_stride , ud , uvd_stride , & sse ) ) ; <S2SV_EndBug> usad = ( sse + 8 ) >> 4 ; <S2SV_StartBug> vsad = ( vp8_variance4x4 ( v , uv_stride , vd , uvd_stride , & sse ) ) ; <S2SV_EndBug> vsad = ( sse + 8 ) >> 4 ; # else sad = ( vp8_sad8x8 ( y , y_stride , yd , yd_stride , UINT_MAX ) + 32 ) >> 6 ; usad = ( vp8_sad4x4 ( u , uv_stride , ud , uvd_stride , UINT_MAX ) + 8 ) >> 4 ; vsad = ( vp8_sad4x4 ( v , uv_stride , vd , uvd_stride , UINT_MAX ) + 8 ) >> 4 ; # endif } actrisk = ( actd > act * 5 ) ; thr = ( qdiff >> 4 ) ; while ( actd >>= 1 ) thr ++ ; while ( qprev >>= 2 ) thr ++ ; # ifdef USE_SSD thrsq = thr * thr ; if ( sad < thrsq && 4 * usad < thrsq && 4 * vsad < thrsq && ! actrisk ) # else if ( sad < thr && 2 * usad < thr && 2 * vsad < thr && ! actrisk ) # endif { int ifactor ; # ifdef USE_SSD sad = int_sqrt ( sad ) ; # endif ifactor = ( sad << MFQE_PRECISION ) / thr ; ifactor >>= ( qdiff >> 5 ) ; if ( ifactor ) { apply_ifactor ( y , y_stride , yd , yd_stride , u , v , uv_stride , ud , vd , uvd_stride , blksize , ifactor ) ; } } else { if ( blksize == 16 ) { vp8_copy_mem16x16 ( y , y_stride , yd , yd_stride ) ; vp8_copy_mem8x8 ( u , uv_stride , ud , uvd_stride ) ; vp8_copy_mem8x8 ( v , uv_stride , vd , uvd_stride ) ; } else { vp8_copy_mem8x8 ( y , y_stride , yd , yd_stride ) ; for ( up = u , udp = ud , i = 0 ; i < uvblksize ; ++ i , up += uv_stride , udp += uvd_stride ) <S2SV_StartBug> vpx_memcpy ( udp , up , uvblksize ) ; <S2SV_EndBug> for ( vp = v , vdp = vd , i = 0 ; i < uvblksize ; ++ i , vp += uv_stride , vdp += uvd_stride ) <S2SV_StartBug> vpx_memcpy ( vdp , vp , uvblksize ) ; <S2SV_EndBug> } } }
","<S2SV_ModStart> actd = ( vpx_variance16x16 <S2SV_ModEnd> ( yd , <S2SV_ModStart> act = ( vpx_variance16x16 <S2SV_ModEnd> ( y , <S2SV_ModStart> # ifdef USE_SSD vpx_variance16x16 ( y , y_stride , yd , yd_stride , & sse ) ; <S2SV_ModStart> sad = ( sse + 128 ) >> 8 ; vpx_variance8x8 ( u , uv_stride , ud , uvd_stride , & sse ) ; usad = ( sse + 32 ) >> 6 ; vpx_variance8x8 ( v , uv_stride , vd , uvd_stride , & sse ) ; vsad = ( sse + 32 ) >> 6 ; # else sad = ( vpx_sad16x16 <S2SV_ModEnd> ( y , <S2SV_ModStart> yd , yd_stride ) + 128 ) >> 8 ; usad = ( vpx_sad8x8 ( u , uv_stride , ud , uvd_stride ) + 32 ) >> 6 ; vsad = ( vpx_sad8x8 ( v , uv_stride , vd , uvd_stride ) + 32 ) >> 6 ; # endif } else { actd = ( vpx_variance8x8 ( yd , yd_stride , VP8_ZEROS , 0 <S2SV_ModStart> & sse ) <S2SV_ModEnd> + 32 ) <S2SV_ModStart> >> 6 ; <S2SV_ModEnd> act = ( <S2SV_ModStart> act = ( vpx_variance8x8 <S2SV_ModEnd> ( y , <S2SV_ModStart> # ifdef USE_SSD vpx_variance8x8 ( y , y_stride , yd , yd_stride , & sse ) ; <S2SV_ModStart> sad = ( sse + 32 ) >> 6 ; vpx_variance4x4 ( u , uv_stride , ud , uvd_stride , & sse ) ; usad = ( sse + 8 ) >> 4 ; vpx_variance4x4 ( v , uv_stride , vd , uvd_stride , & sse ) ; vsad = ( sse + 8 ) >> 4 ; # else sad = ( vpx_sad8x8 <S2SV_ModEnd> ( y , <S2SV_ModStart> yd , yd_stride ) <S2SV_ModEnd> + 32 ) <S2SV_ModStart> usad = ( vpx_sad4x4 <S2SV_ModEnd> ( u , <S2SV_ModStart> ud , uvd_stride ) <S2SV_ModEnd> + 8 ) <S2SV_ModStart> vsad = ( vpx_sad4x4 <S2SV_ModEnd> ( v , <S2SV_ModStart> vd , uvd_stride <S2SV_ModEnd> ) + 8 <S2SV_ModStart> += uvd_stride ) memcpy <S2SV_ModEnd> ( udp , <S2SV_ModStart> += uvd_stride ) memcpy <S2SV_ModEnd> ( vdp ,
"
131,"CWE-20 static int __br_mdb_del ( struct net_bridge * br , struct br_mdb_entry * entry ) { struct net_bridge_mdb_htable * mdb ; struct net_bridge_mdb_entry * mp ; struct net_bridge_port_group * p ; struct net_bridge_port_group __rcu * * pp ; struct br_ip ip ; int err = - EINVAL ; if ( ! netif_running ( br -> dev ) || br -> multicast_disabled ) return - EINVAL ; if ( timer_pending ( & br -> multicast_querier_timer ) ) return - EBUSY ; ip . proto = entry -> addr . proto ; if ( ip . proto == htons ( ETH_P_IP ) ) ip . u . ip4 = entry -> addr . u . ip4 ; # if IS_ENABLED ( CONFIG_IPV6 ) else ip . u . ip6 = entry -> addr . u . ip6 ; # endif spin_lock_bh ( & br -> multicast_lock ) ; mdb = mlock_dereference ( br -> mdb , br ) ; mp = br_mdb_ip_get ( mdb , & ip ) ; if ( ! mp ) goto unlock ; for ( pp = & mp -> ports ; ( p = mlock_dereference ( * pp , br ) ) != NULL ; pp = & p -> next ) { if ( ! p -> port || p -> port -> dev -> ifindex != entry -> ifindex ) continue ; if ( p -> port -> state == BR_STATE_DISABLED ) goto unlock ; rcu_assign_pointer ( * pp , p -> next ) ; hlist_del_init ( & p -> mglist ) ; del_timer ( & p -> timer ) ; call_rcu_bh ( & p -> rcu , br_multicast_free_pg ) ; err = 0 ; <S2SV_StartBug> if ( ! mp -> ports && ! mp -> mglist && <S2SV_EndBug> netif_running ( br -> dev ) ) mod_timer ( & mp -> timer , jiffies ) ; break ; } unlock : spin_unlock_bh ( & br -> multicast_lock ) ; return err ; }
","<S2SV_ModStart> -> mglist && mp -> timer_armed &&
"
132,"CWE-416 static int ipxitf_ioctl ( unsigned int cmd , void __user * arg ) { int rc = - EINVAL ; struct ifreq ifr ; int val ; switch ( cmd ) { case SIOCSIFADDR : { struct sockaddr_ipx * sipx ; struct ipx_interface_definition f ; rc = - EFAULT ; if ( copy_from_user ( & ifr , arg , sizeof ( ifr ) ) ) break ; sipx = ( struct sockaddr_ipx * ) & ifr . ifr_addr ; rc = - EINVAL ; if ( sipx -> sipx_family != AF_IPX ) break ; f . ipx_network = sipx -> sipx_network ; memcpy ( f . ipx_device , ifr . ifr_name , sizeof ( f . ipx_device ) ) ; memcpy ( f . ipx_node , sipx -> sipx_node , IPX_NODE_LEN ) ; f . ipx_dlink_type = sipx -> sipx_type ; f . ipx_special = sipx -> sipx_special ; if ( sipx -> sipx_action == IPX_DLTITF ) rc = ipxitf_delete ( & f ) ; else rc = ipxitf_create ( & f ) ; break ; } case SIOCGIFADDR : { struct sockaddr_ipx * sipx ; struct ipx_interface * ipxif ; struct net_device * dev ; rc = - EFAULT ; if ( copy_from_user ( & ifr , arg , sizeof ( ifr ) ) ) break ; sipx = ( struct sockaddr_ipx * ) & ifr . ifr_addr ; dev = __dev_get_by_name ( & init_net , ifr . ifr_name ) ; rc = - ENODEV ; if ( ! dev ) break ; ipxif = ipxitf_find_using_phys ( dev , ipx_map_frame_type ( sipx -> sipx_type ) ) ; rc = - EADDRNOTAVAIL ; if ( ! ipxif ) break ; sipx -> sipx_family = AF_IPX ; sipx -> sipx_network = ipxif -> if_netnum ; memcpy ( sipx -> sipx_node , ipxif -> if_node , sizeof ( sipx -> sipx_node ) ) ; <S2SV_StartBug> rc = - EFAULT ; <S2SV_EndBug> <S2SV_StartBug> if ( copy_to_user ( arg , & ifr , sizeof ( ifr ) ) ) <S2SV_EndBug> break ; <S2SV_StartBug> ipxitf_put ( ipxif ) ; <S2SV_EndBug> rc = 0 ; break ; } case SIOCAIPXITFCRT : rc = - EFAULT ; if ( get_user ( val , ( unsigned char __user * ) arg ) ) break ; rc = 0 ; ipxcfg_auto_create_interfaces = val ; break ; case SIOCAIPXPRISLT : rc = - EFAULT ; if ( get_user ( val , ( unsigned char __user * ) arg ) ) break ; rc = 0 ; ipxcfg_set_auto_select ( val ) ; break ; } return rc ; }
","<S2SV_ModStart> ; rc = 0 ; if ( copy_to_user ( arg , & ifr , sizeof ( ifr ) ) ) rc = <S2SV_ModStart> - EFAULT ; <S2SV_ModEnd> ipxitf_put ( ipxif <S2SV_ModStart> ( ipxif ) <S2SV_ModEnd> ; break ;
"
133,"CWE-119 void safe_fprintf ( FILE * f , const char * fmt , ... ) { char fmtbuff_stack [ 256 ] ; char outbuff [ 256 ] ; char * fmtbuff_heap ; char * fmtbuff ; int fmtbuff_length ; int length , n ; va_list ap ; const char * p ; unsigned i ; wchar_t wc ; char try_wc ; fmtbuff_heap = NULL ; fmtbuff_length = sizeof ( fmtbuff_stack ) ; fmtbuff = fmtbuff_stack ; va_start ( ap , fmt ) ; length = vsnprintf ( fmtbuff , fmtbuff_length , fmt , ap ) ; va_end ( ap ) ; while ( length < 0 || length >= fmtbuff_length ) { if ( length >= fmtbuff_length ) fmtbuff_length = length + 1 ; else if ( fmtbuff_length < 8192 ) fmtbuff_length *= 2 ; else if ( fmtbuff_length < 1000000 ) fmtbuff_length += fmtbuff_length / 4 ; else { length = fmtbuff_length ; fmtbuff_heap [ length - 1 ] = '\\0' ; break ; } free ( fmtbuff_heap ) ; fmtbuff_heap = malloc ( fmtbuff_length ) ; if ( fmtbuff_heap != NULL ) { fmtbuff = fmtbuff_heap ; va_start ( ap , fmt ) ; length = vsnprintf ( fmtbuff , fmtbuff_length , fmt , ap ) ; va_end ( ap ) ; } else { length = sizeof ( fmtbuff_stack ) - 1 ; break ; } } if ( mbtowc ( NULL , NULL , 1 ) == - 1 ) { free ( fmtbuff_heap ) ; return ; } p = fmtbuff ; i = 0 ; try_wc = 1 ; while ( * p != '\\0' ) { if ( try_wc && ( n = mbtowc ( & wc , p , length ) ) != - 1 ) { length -= n ; if ( iswprint ( wc ) && wc != L'\\\\' ) { while ( n -- > 0 ) outbuff [ i ++ ] = * p ++ ; } else { while ( n -- > 0 ) i += ( unsigned ) bsdtar_expand_char ( outbuff , i , * p ++ ) ; } } else { i += ( unsigned ) bsdtar_expand_char ( outbuff , i , * p ++ ) ; try_wc = 0 ; } <S2SV_StartBug> if ( i > ( sizeof ( outbuff ) - 20 ) ) { <S2SV_EndBug> outbuff [ i ] = '\\0' ; fprintf ( f , ""%s"" , outbuff ) ; i = 0 ; } } outbuff [ i ] = '\\0' ; fprintf ( f , ""%s"" , outbuff ) ; free ( fmtbuff_heap ) ; }
","<S2SV_ModStart> outbuff ) - 128 <S2SV_ModEnd> ) ) {
"
134,"CWE-119 <S2SV_StartBug> int vp8_denoiser_filter_sse2 ( YV12_BUFFER_CONFIG * mc_running_avg , <S2SV_EndBug> YV12_BUFFER_CONFIG * running_avg , MACROBLOCK * signal , unsigned int motion_magnitude , int y_offset , int uv_offset ) { <S2SV_StartBug> unsigned char * sig = signal -> thismb ; <S2SV_EndBug> int sig_stride = 16 ; <S2SV_StartBug> unsigned char * mc_running_avg_y = mc_running_avg -> y_buffer + y_offset ; <S2SV_EndBug> int mc_avg_y_stride = mc_running_avg -> y_stride ; <S2SV_StartBug> unsigned char * running_avg_y = running_avg -> y_buffer + y_offset ; <S2SV_EndBug> int avg_y_stride = running_avg -> y_stride ; int r ; <S2SV_StartBug> __m128i acc_diff = _mm_setzero_si128 ( ) ; <S2SV_EndBug> const __m128i k_0 = _mm_setzero_si128 ( ) ; const __m128i k_4 = _mm_set1_epi8 ( 4 ) ; const __m128i k_8 = _mm_set1_epi8 ( 8 ) ; const __m128i k_16 = _mm_set1_epi8 ( 16 ) ; const __m128i l3 = _mm_set1_epi8 ( <S2SV_StartBug> ( motion_magnitude <= MOTION_MAGNITUDE_THRESHOLD ) ? 7 : 6 ) ; <S2SV_EndBug> const __m128i l32 = _mm_set1_epi8 ( 2 ) ; const __m128i l21 = _mm_set1_epi8 ( 1 ) ; for ( r = 0 ; r < 16 ; ++ r ) { const __m128i v_sig = _mm_loadu_si128 ( ( __m128i * ) ( & sig [ 0 ] ) ) ; const __m128i v_mc_running_avg_y = _mm_loadu_si128 ( ( __m128i * ) ( & mc_running_avg_y [ 0 ] ) ) ; __m128i v_running_avg_y ; const __m128i pdiff = _mm_subs_epu8 ( v_mc_running_avg_y , v_sig ) ; const __m128i ndiff = _mm_subs_epu8 ( v_sig , v_mc_running_avg_y ) ; const __m128i diff_sign = _mm_cmpeq_epi8 ( pdiff , k_0 ) ; const __m128i clamped_absdiff = _mm_min_epu8 ( _mm_or_si128 ( pdiff , ndiff ) , k_16 ) ; const __m128i mask2 = _mm_cmpgt_epi8 ( k_16 , clamped_absdiff ) ; const __m128i mask1 = _mm_cmpgt_epi8 ( k_8 , clamped_absdiff ) ; const __m128i mask0 = _mm_cmpgt_epi8 ( k_4 , clamped_absdiff ) ; __m128i adj2 = _mm_and_si128 ( mask2 , l32 ) ; const __m128i adj1 = _mm_and_si128 ( mask1 , l21 ) ; const __m128i adj0 = _mm_and_si128 ( mask0 , clamped_absdiff ) ; __m128i adj , padj , nadj ; adj2 = _mm_add_epi8 ( adj2 , adj1 ) ; adj = _mm_sub_epi8 ( l3 , adj2 ) ; adj = _mm_andnot_si128 ( mask0 , adj ) ; adj = _mm_or_si128 ( adj , adj0 ) ; padj = _mm_andnot_si128 ( diff_sign , adj ) ; nadj = _mm_and_si128 ( diff_sign , adj ) ; v_running_avg_y = _mm_adds_epu8 ( v_sig , padj ) ; v_running_avg_y = _mm_subs_epu8 ( v_running_avg_y , nadj ) ; _mm_storeu_si128 ( ( __m128i * ) running_avg_y , v_running_avg_y ) ; acc_diff = _mm_adds_epi8 ( acc_diff , padj ) ; acc_diff = _mm_subs_epi8 ( acc_diff , nadj ) ; sig += sig_stride ; mc_running_avg_y += mc_avg_y_stride ; running_avg_y += avg_y_stride ; } { <S2SV_StartBug> union sum_union s ; <S2SV_EndBug> int sum_diff = 0 ; <S2SV_StartBug> s . v = acc_diff ; <S2SV_EndBug> <S2SV_StartBug> sum_diff = s . e [ 0 ] + s . e [ 1 ] + s . e [ 2 ] + s . e [ 3 ] + s . e [ 4 ] + s . e [ 5 ] <S2SV_EndBug> + s . e [ 6 ] + s . e [ 7 ] + s . e [ 8 ] + s . e [ 9 ] + s . e [ 10 ] + s . e [ 11 ] + s . e [ 12 ] + s . e [ 13 ] + s . e [ 14 ] + s . e [ 15 ] ; <S2SV_StartBug> if ( abs ( sum_diff ) > SUM_DIFF_THRESHOLD ) <S2SV_EndBug> { return COPY_BLOCK ; } <S2SV_StartBug> } <S2SV_EndBug> vp8_copy_mem16x16 ( running_avg -> y_buffer + y_offset , avg_y_stride , <S2SV_StartBug> signal -> thismb , sig_stride ) ; <S2SV_EndBug> return FILTER_BLOCK ; }
","<S2SV_ModStart> int vp8_denoiser_filter_sse2 ( <S2SV_ModEnd> unsigned char * <S2SV_ModStart> unsigned char * mc_running_avg_y , int mc_avg_y_stride , <S2SV_ModEnd> unsigned char * <S2SV_ModStart> unsigned char * running_avg_y , int avg_y_stride , <S2SV_ModEnd> unsigned char * <S2SV_ModStart> unsigned char * sig , int sig_stride , unsigned int motion_magnitude , int increase_denoising ) { unsigned char * running_avg_y_start = running_avg_y ; unsigned char * sig_start = sig ; unsigned int sum_diff_thresh <S2SV_ModEnd> ; int r <S2SV_ModStart> int r ; int shift_inc = ( increase_denoising && <S2SV_ModEnd> motion_magnitude <= MOTION_MAGNITUDE_THRESHOLD <S2SV_ModStart> MOTION_MAGNITUDE_THRESHOLD ) ? 1 : 0 ; __m128i acc_diff = _mm_setzero_si128 ( ) ; const __m128i k_0 = _mm_setzero_si128 ( ) ; const __m128i k_4 = _mm_set1_epi8 ( 4 + shift_inc ) ; const __m128i k_8 = _mm_set1_epi8 ( 8 ) ; const __m128i k_16 = _mm_set1_epi8 ( 16 ) ; const __m128i l3 = _mm_set1_epi8 ( ( motion_magnitude <= MOTION_MAGNITUDE_THRESHOLD ) ? 7 + shift_inc <S2SV_ModEnd> : 6 ) <S2SV_ModStart> ; } { unsigned int abs_sum_diff = abs_sum_diff_16x1 ( acc_diff ) ; sum_diff_thresh = SUM_DIFF_THRESHOLD ; if ( increase_denoising ) sum_diff_thresh = SUM_DIFF_THRESHOLD_HIGH ; if ( abs_sum_diff > sum_diff_thresh ) { int delta = ( ( abs_sum_diff - sum_diff_thresh ) >> 8 ) + 1 ; if ( delta < 4 ) { const __m128i k_delta = _mm_set1_epi8 ( delta ) ; sig -= sig_stride * 16 ; mc_running_avg_y -= mc_avg_y_stride * 16 ; running_avg_y -= avg_y_stride * 16 ; for ( r <S2SV_ModEnd> = 0 ; <S2SV_ModStart> = 0 ; r < 16 ; ++ r ) { __m128i v_running_avg_y = _mm_loadu_si128 ( ( __m128i * ) ( & running_avg_y <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> [ 0 ] ) ) ; const __m128i v_sig = _mm_loadu_si128 ( ( __m128i * ) ( & sig [ 0 ] ) ) ; const __m128i v_mc_running_avg_y = _mm_loadu_si128 ( ( __m128i * ) ( & mc_running_avg_y [ 0 ] ) ) ; const __m128i pdiff = _mm_subs_epu8 ( v_mc_running_avg_y , v_sig ) ; const __m128i ndiff = _mm_subs_epu8 ( v_sig , v_mc_running_avg_y ) ; const __m128i diff_sign = _mm_cmpeq_epi8 ( pdiff , k_0 ) ; const __m128i adj = _mm_min_epu8 ( _mm_or_si128 ( pdiff , ndiff ) , k_delta ) ; __m128i padj , nadj ; padj = _mm_andnot_si128 ( diff_sign , adj ) ; nadj = _mm_and_si128 ( diff_sign , adj ) ; v_running_avg_y = _mm_subs_epu8 ( v_running_avg_y , padj ) ; v_running_avg_y = _mm_adds_epu8 ( v_running_avg_y , nadj ) ; _mm_storeu_si128 ( ( __m128i * ) running_avg_y , v_running_avg_y ) ; acc_diff = _mm_subs_epi8 ( acc_diff , padj ) ; acc_diff = _mm_adds_epi8 ( acc_diff , nadj ) ; sig += sig_stride ; mc_running_avg_y += mc_avg_y_stride ; running_avg_y += avg_y_stride ; } abs_sum_diff = abs_sum_diff_16x1 ( acc_diff ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; if ( abs_sum_diff > sum_diff_thresh ) <S2SV_ModEnd> { return COPY_BLOCK <S2SV_ModStart> ; } } else { return COPY_BLOCK ; } } } vp8_copy_mem16x16 ( running_avg_y_start <S2SV_ModEnd> , avg_y_stride , <S2SV_ModStart> , avg_y_stride , sig_start <S2SV_ModEnd> , sig_stride )
"
135,"CWE-200 static void __net_random_once_deferred ( struct work_struct * w ) { struct __net_random_once_work * work = container_of ( w , struct __net_random_once_work , work ) ; <S2SV_StartBug> if ( ! static_key_enabled ( work -> key ) ) <S2SV_EndBug> static_key_slow_inc ( work -> key ) ; kfree ( work ) ; }
","<S2SV_ModStart> work ) ; BUG_ON <S2SV_ModEnd> ( ! static_key_enabled <S2SV_ModStart> key ) ) ; static_key_slow_dec <S2SV_ModEnd> ( work ->
"
136,"CWE-416 static struct mm_struct * mm_init ( struct mm_struct * mm , struct task_struct * p , struct user_namespace * user_ns ) { mm -> mmap = NULL ; mm -> mm_rb = RB_ROOT ; mm -> vmacache_seqnum = 0 ; atomic_set ( & mm -> mm_users , 1 ) ; atomic_set ( & mm -> mm_count , 1 ) ; init_rwsem ( & mm -> mmap_sem ) ; INIT_LIST_HEAD ( & mm -> mmlist ) ; mm -> core_state = NULL ; atomic_long_set ( & mm -> nr_ptes , 0 ) ; mm_nr_pmds_init ( mm ) ; mm -> map_count = 0 ; mm -> locked_vm = 0 ; mm -> pinned_vm = 0 ; memset ( & mm -> rss_stat , 0 , sizeof ( mm -> rss_stat ) ) ; spin_lock_init ( & mm -> page_table_lock ) ; mm_init_cpumask ( mm ) ; mm_init_aio ( mm ) ; mm_init_owner ( mm , p ) ; <S2SV_StartBug> mmu_notifier_mm_init ( mm ) ; <S2SV_EndBug> init_tlb_flush_pending ( mm ) ; # if defined ( CONFIG_TRANSPARENT_HUGEPAGE ) && ! USE_SPLIT_PMD_PTLOCKS mm -> pmd_huge_pte = NULL ; # endif if ( current -> mm ) { mm -> flags = current -> mm -> flags & MMF_INIT_MASK ; mm -> def_flags = current -> mm -> def_flags & VM_INIT_DEF_MASK ; } else { mm -> flags = default_dump_filter ; mm -> def_flags = 0 ; } if ( mm_alloc_pgd ( mm ) ) goto fail_nopgd ; if ( init_new_context ( p , mm ) ) goto fail_nocontext ; mm -> user_ns = get_user_ns ( user_ns ) ; return mm ; fail_nocontext : mm_free_pgd ( mm ) ; fail_nopgd : free_mm ( mm ) ; return NULL ; }
","<S2SV_ModStart> p ) ; RCU_INIT_POINTER ( mm -> exe_file , NULL ) ;
"
137,"CWE-476 VTermState * vterm_obtain_state ( VTerm * vt ) { VTermState * state ; if ( vt -> state ) return vt -> state ; <S2SV_StartBug> state = vterm_state_new ( vt ) ; <S2SV_EndBug> vt -> state = state ; state -> combine_chars_size = 16 ; state -> combine_chars = vterm_allocator_malloc ( state -> vt , state -> combine_chars_size * sizeof ( state -> combine_chars [ 0 ] ) ) ; state -> tabstops = vterm_allocator_malloc ( state -> vt , ( state -> cols + 7 ) / 8 ) ; state -> lineinfo = vterm_allocator_malloc ( state -> vt , state -> rows * sizeof ( VTermLineInfo ) ) ; state -> encoding_utf8 . enc = vterm_lookup_encoding ( ENC_UTF8 , 'u' ) ; if ( * state -> encoding_utf8 . enc -> init != NULL ) ( * state -> encoding_utf8 . enc -> init ) ( state -> encoding_utf8 . enc , state -> encoding_utf8 . data ) ; vterm_parser_set_callbacks ( vt , & parser_callbacks , state ) ; return state ; }
","<S2SV_ModStart> ( vt ) ; if ( state == NULL ) return NULL
"
138,"CWE-189 static int fixup_bpf_calls ( struct bpf_verifier_env * env ) { struct bpf_prog * prog = env -> prog ; struct bpf_insn * insn = prog -> insnsi ; const struct bpf_func_proto * fn ; const int insn_cnt = prog -> len ; const struct bpf_map_ops * ops ; struct bpf_insn_aux_data * aux ; struct bpf_insn insn_buf [ 16 ] ; struct bpf_prog * new_prog ; struct bpf_map * map_ptr ; int i , cnt , delta = 0 ; for ( i = 0 ; i < insn_cnt ; i ++ , insn ++ ) { if ( insn -> code == ( BPF_ALU64 | BPF_MOD | BPF_X ) || insn -> code == ( BPF_ALU64 | BPF_DIV | BPF_X ) || insn -> code == ( BPF_ALU | BPF_MOD | BPF_X ) || insn -> code == ( BPF_ALU | BPF_DIV | BPF_X ) ) { bool is64 = BPF_CLASS ( insn -> code ) == BPF_ALU64 ; struct bpf_insn mask_and_div [ ] = { BPF_MOV32_REG ( insn -> src_reg , insn -> src_reg ) , BPF_JMP_IMM ( BPF_JNE , insn -> src_reg , 0 , 2 ) , BPF_ALU32_REG ( BPF_XOR , insn -> dst_reg , insn -> dst_reg ) , BPF_JMP_IMM ( BPF_JA , 0 , 0 , 1 ) , * insn , } ; struct bpf_insn mask_and_mod [ ] = { BPF_MOV32_REG ( insn -> src_reg , insn -> src_reg ) , BPF_JMP_IMM ( BPF_JEQ , insn -> src_reg , 0 , 1 ) , * insn , } ; struct bpf_insn * patchlet ; if ( insn -> code == ( BPF_ALU64 | BPF_DIV | BPF_X ) || insn -> code == ( BPF_ALU | BPF_DIV | BPF_X ) ) { patchlet = mask_and_div + ( is64 ? 1 : 0 ) ; cnt = ARRAY_SIZE ( mask_and_div ) - ( is64 ? 1 : 0 ) ; } else { patchlet = mask_and_mod + ( is64 ? 1 : 0 ) ; cnt = ARRAY_SIZE ( mask_and_mod ) - ( is64 ? 1 : 0 ) ; } new_prog = bpf_patch_insn_data ( env , i + delta , patchlet , cnt ) ; if ( ! new_prog ) return - ENOMEM ; delta += cnt - 1 ; env -> prog = prog = new_prog ; insn = new_prog -> insnsi + i + delta ; continue ; } if ( BPF_CLASS ( insn -> code ) == BPF_LD && ( BPF_MODE ( insn -> code ) == BPF_ABS || BPF_MODE ( insn -> code ) == BPF_IND ) ) { cnt = env -> ops -> gen_ld_abs ( insn , insn_buf ) ; if ( cnt == 0 || cnt >= ARRAY_SIZE ( insn_buf ) ) { verbose ( env , ""bpf<S2SV_blank>verifier<S2SV_blank>is<S2SV_blank>misconfigured\\n"" ) ; return - EINVAL ; } new_prog = bpf_patch_insn_data ( env , i + delta , insn_buf , cnt ) ; if ( ! new_prog ) return - ENOMEM ; delta += cnt - 1 ; env -> prog = prog = new_prog ; insn = new_prog -> insnsi + i + delta ; continue ; } <S2SV_StartBug> if ( insn -> code != ( BPF_JMP | BPF_CALL ) ) <S2SV_EndBug> continue ; if ( insn -> src_reg == BPF_PSEUDO_CALL ) continue ; if ( insn -> imm == BPF_FUNC_get_route_realm ) prog -> dst_needed = 1 ; if ( insn -> imm == BPF_FUNC_get_prandom_u32 ) bpf_user_rnd_init_once ( ) ; if ( insn -> imm == BPF_FUNC_override_return ) prog -> kprobe_override = 1 ; if ( insn -> imm == BPF_FUNC_tail_call ) { prog -> cb_access = 1 ; env -> prog -> aux -> stack_depth = MAX_BPF_STACK ; env -> prog -> aux -> max_pkt_offset = MAX_PACKET_OFF ; insn -> imm = 0 ; insn -> code = BPF_JMP | BPF_TAIL_CALL ; aux = & env -> insn_aux_data [ i + delta ] ; <S2SV_StartBug> if ( ! bpf_map_ptr_unpriv ( aux ) ) <S2SV_EndBug> continue ; <S2SV_StartBug> if ( bpf_map_ptr_poisoned ( aux ) ) { <S2SV_EndBug> verbose ( env , ""tail_call<S2SV_blank>abusing<S2SV_blank>map_ptr\\n"" ) ; return - EINVAL ; } map_ptr = BPF_MAP_PTR ( aux -> map_state ) ; insn_buf [ 0 ] = BPF_JMP_IMM ( BPF_JGE , BPF_REG_3 , map_ptr -> max_entries , 2 ) ; insn_buf [ 1 ] = BPF_ALU32_IMM ( BPF_AND , BPF_REG_3 , container_of ( map_ptr , struct bpf_array , map ) -> index_mask ) ; insn_buf [ 2 ] = * insn ; cnt = 3 ; new_prog = bpf_patch_insn_data ( env , i + delta , insn_buf , cnt ) ; if ( ! new_prog ) return - ENOMEM ; delta += cnt - 1 ; env -> prog = prog = new_prog ; insn = new_prog -> insnsi + i + delta ; continue ; } <S2SV_StartBug> if ( prog -> jit_requested && BITS_PER_LONG == 64 && <S2SV_EndBug> ( insn -> imm == BPF_FUNC_map_lookup_elem || insn -> imm == BPF_FUNC_map_update_elem || insn -> imm == BPF_FUNC_map_delete_elem || insn -> imm == BPF_FUNC_map_push_elem || insn -> imm == BPF_FUNC_map_pop_elem || insn -> imm == BPF_FUNC_map_peek_elem ) ) { aux = & env -> insn_aux_data [ i + delta ] ; <S2SV_StartBug> if ( bpf_map_ptr_poisoned ( aux ) ) <S2SV_EndBug> <S2SV_StartBug> goto patch_call_imm ; <S2SV_EndBug> map_ptr = BPF_MAP_PTR ( aux -> map_state ) ; <S2SV_StartBug> ops = map_ptr -> ops ; <S2SV_EndBug> if ( insn -> imm == BPF_FUNC_map_lookup_elem && ops -> map_gen_lookup ) { <S2SV_StartBug> cnt = ops -> map_gen_lookup ( map_ptr , insn_buf ) ; <S2SV_EndBug> if ( cnt == 0 || cnt >= ARRAY_SIZE ( insn_buf ) ) { verbose ( env , ""bpf<S2SV_blank>verifier<S2SV_blank>is<S2SV_blank>misconfigured\\n"" ) ; return - EINVAL ; } new_prog = bpf_patch_insn_data ( env , i + delta , insn_buf , cnt ) ; if ( ! new_prog ) return - ENOMEM ; delta += cnt - 1 ; env -> prog = prog = new_prog ; insn = new_prog -> insnsi + i + delta ; continue ; } <S2SV_StartBug> BUILD_BUG_ON ( ! __same_type ( ops -> map_lookup_elem , <S2SV_EndBug> ( void * ( * ) ( struct bpf_map * map , void * key ) ) NULL ) ) ; BUILD_BUG_ON ( ! __same_type ( ops -> map_delete_elem , ( int ( * ) ( struct bpf_map * map , void * key ) ) NULL ) ) ; BUILD_BUG_ON ( ! __same_type ( ops -> map_update_elem , ( int ( * ) ( struct bpf_map * map , void * key , void * value , u64 flags ) ) NULL ) ) ; BUILD_BUG_ON ( ! __same_type ( ops -> map_push_elem , ( int ( * ) ( struct bpf_map * map , void * value , u64 flags ) ) NULL ) ) ; BUILD_BUG_ON ( ! __same_type ( ops -> map_pop_elem , ( int ( * ) ( struct bpf_map * map , void * value ) ) NULL ) ) ; BUILD_BUG_ON ( ! __same_type ( ops -> map_peek_elem , ( int ( * ) ( struct bpf_map * map , void * value ) ) NULL ) ) ; switch ( insn -> imm ) { case BPF_FUNC_map_lookup_elem : insn -> imm = BPF_CAST_CALL ( ops -> map_lookup_elem ) - __bpf_call_base ; continue ; case BPF_FUNC_map_update_elem : insn -> imm = BPF_CAST_CALL ( ops -> map_update_elem ) - __bpf_call_base ; continue ; case BPF_FUNC_map_delete_elem : insn -> imm = BPF_CAST_CALL ( ops -> map_delete_elem ) - __bpf_call_base ; continue ; case BPF_FUNC_map_push_elem : insn -> imm = BPF_CAST_CALL ( ops -> map_push_elem ) - __bpf_call_base ; continue ; case BPF_FUNC_map_pop_elem : insn -> imm = BPF_CAST_CALL ( ops -> map_pop_elem ) - __bpf_call_base ; continue ; case BPF_FUNC_map_peek_elem : insn -> imm = BPF_CAST_CALL ( ops -> map_peek_elem ) - __bpf_call_base ; continue ; } goto patch_call_imm ; } patch_call_imm : fn = env -> ops -> get_func_proto ( insn -> imm , env -> prog ) ; if ( ! fn -> func ) { verbose ( env , ""kernel<S2SV_blank>subsystem<S2SV_blank>misconfigured<S2SV_blank>func<S2SV_blank>%s#%d\\n"" , func_id_name ( insn -> imm ) , insn -> imm ) ; return - EFAULT ; } insn -> imm = fn -> func - __bpf_call_base ; } return 0 ; }
","<S2SV_ModStart> insn -> code == ( BPF_ALU64 | BPF_ADD | BPF_X ) || insn -> code == ( BPF_ALU64 | BPF_SUB | BPF_X ) ) { const u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X ; const u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X ; struct bpf_insn insn_buf [ 16 ] ; struct bpf_insn * patch = & insn_buf [ 0 ] ; bool issrc , isneg ; u32 off_reg <S2SV_ModEnd> ; aux = <S2SV_ModStart> if ( ! aux -> alu_state <S2SV_ModEnd> ) continue ; <S2SV_ModStart> ) continue ; isneg = aux -> alu_state & BPF_ALU_NEG_VALUE ; issrc = ( aux -> alu_state & BPF_ALU_SANITIZE ) == BPF_ALU_SANITIZE_SRC ; off_reg = issrc ? insn -> src_reg : insn -> dst_reg ; if ( isneg ) * patch ++ = BPF_ALU64_IMM ( BPF_MUL , off_reg , - 1 ) ; * patch ++ = BPF_MOV32_IMM ( BPF_REG_AX , aux -> alu_limit - 1 ) ; * patch ++ = BPF_ALU64_REG ( BPF_SUB , BPF_REG_AX , off_reg ) ; * patch ++ = BPF_ALU64_REG ( BPF_OR , BPF_REG_AX , off_reg ) ; * patch ++ = BPF_ALU64_IMM ( BPF_NEG , BPF_REG_AX , 0 ) ; * patch ++ = BPF_ALU64_IMM ( BPF_ARSH , BPF_REG_AX , 63 ) ; if ( issrc ) { * patch ++ = BPF_ALU64_REG ( BPF_AND , BPF_REG_AX , off_reg ) ; insn -> src_reg = BPF_REG_AX ; } else { * patch ++ = BPF_ALU64_REG ( BPF_AND , off_reg , BPF_REG_AX ) ; } if ( isneg ) insn -> code = insn -> code == code_add ? code_sub : code_add ; * patch ++ = * insn ; if ( issrc && isneg ) * patch ++ = BPF_ALU64_IMM ( BPF_MUL , off_reg , - 1 ) ; cnt = patch - insn_buf <S2SV_ModEnd> ; new_prog = <S2SV_ModStart> } if ( insn -> code != ( BPF_JMP | BPF_CALL ) ) continue ; if ( insn -> src_reg == BPF_PSEUDO_CALL ) continue ; if ( insn -> imm == BPF_FUNC_get_route_realm ) prog -> dst_needed = 1 ; if ( insn -> imm == BPF_FUNC_get_prandom_u32 ) bpf_user_rnd_init_once ( ) ; if ( insn -> imm == BPF_FUNC_override_return ) prog -> kprobe_override = 1 ; if ( insn -> imm == BPF_FUNC_tail_call ) { prog -> cb_access = 1 ; env -> prog -> aux -> stack_depth = MAX_BPF_STACK ; env -> prog -> aux -> max_pkt_offset = MAX_PACKET_OFF ; insn -> imm = 0 ; insn -> code = BPF_JMP | BPF_TAIL_CALL ; <S2SV_ModEnd> aux = & <S2SV_ModStart> ; if ( ! bpf_map_ptr_unpriv ( aux ) ) continue ; if ( <S2SV_ModStart> aux ) ) { verbose ( env , ""tail_call<S2SV_blank>abusing<S2SV_blank>map_ptr\\n"" ) ; return - EINVAL ; } <S2SV_ModEnd> map_ptr = BPF_MAP_PTR <S2SV_ModStart> map_state ) ; insn_buf [ 0 ] = BPF_JMP_IMM ( BPF_JGE , BPF_REG_3 , map_ptr -> max_entries , 2 ) ; insn_buf [ 1 ] = BPF_ALU32_IMM ( BPF_AND , BPF_REG_3 , container_of <S2SV_ModEnd> ( map_ptr , <S2SV_ModStart> ( map_ptr , struct bpf_array , map ) -> index_mask ) ; insn_buf [ 2 ] = * insn ; cnt = 3 ; <S2SV_ModEnd> new_prog = bpf_patch_insn_data <S2SV_ModStart> continue ; } if ( prog -> jit_requested && BITS_PER_LONG == 64 && ( insn -> imm == BPF_FUNC_map_lookup_elem || insn -> imm == BPF_FUNC_map_update_elem || insn -> imm == BPF_FUNC_map_delete_elem || insn -> imm == BPF_FUNC_map_push_elem || insn -> imm == BPF_FUNC_map_pop_elem || insn -> imm == BPF_FUNC_map_peek_elem ) ) { aux = & env -> insn_aux_data [ i + delta ] ; if ( bpf_map_ptr_poisoned ( aux ) ) goto patch_call_imm ; map_ptr = BPF_MAP_PTR ( aux -> map_state ) ; ops = map_ptr -> ops ; if ( insn -> imm == BPF_FUNC_map_lookup_elem && ops -> map_gen_lookup ) { cnt = ops -> map_gen_lookup ( map_ptr , insn_buf ) ; if ( cnt == 0 || cnt >= ARRAY_SIZE ( insn_buf ) ) { verbose ( env , ""bpf<S2SV_blank>verifier<S2SV_blank>is<S2SV_blank>misconfigured\\n"" ) ; return - EINVAL ; } new_prog = bpf_patch_insn_data ( env , i + delta , insn_buf , cnt ) ; if ( ! new_prog ) return - ENOMEM ; delta += cnt - 1 ; env -> prog = prog = new_prog ; insn = new_prog -> insnsi + i + delta ; continue ; }
"
139,"CWE-552 static ssize_t _epoll_readv ( oe_fd_t * desc , const struct oe_iovec * iov , int iovcnt ) { ssize_t ret = - 1 ; epoll_t * file = _cast_epoll ( desc ) ; void * buf = NULL ; size_t buf_size = 0 ; <S2SV_StartBug> if ( ! file || ( iovcnt && ! iov ) || iovcnt < 0 || iovcnt > OE_IOV_MAX ) <S2SV_EndBug> OE_RAISE_ERRNO ( OE_EINVAL ) ; <S2SV_StartBug> if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> OE_RAISE_ERRNO ( OE_ENOMEM ) ; <S2SV_EndBug> if ( oe_syscall_readv_ocall ( & ret , file -> host_fd , buf , iovcnt , buf_size ) != OE_OK ) { OE_RAISE_ERRNO ( OE_EINVAL ) ; } <S2SV_StartBug> if ( oe_iov_sync ( iov , iovcnt , buf , buf_size ) != 0 ) <S2SV_EndBug> OE_RAISE_ERRNO ( OE_EINVAL ) ; done : if ( buf ) oe_free ( buf ) ; return ret ; }
","<S2SV_ModStart> = 0 ; size_t data_size = 0 ; <S2SV_ModStart> , & buf_size , & data_size <S2SV_ModStart> OE_RAISE_ERRNO ( OE_ENOMEM ) ; if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL <S2SV_ModStart> } if ( ret > ( ssize_t ) data_size ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } if (
"
140,"CWE-787 static void iriap_getvaluebyclass_indication ( struct iriap_cb * self , struct sk_buff * skb ) { struct ias_object * obj ; struct ias_attrib * attrib ; int name_len ; int attr_len ; char name [ IAS_MAX_CLASSNAME + 1 ] ; char attr [ IAS_MAX_ATTRIBNAME + 1 ] ; __u8 * fp ; int n ; IRDA_DEBUG ( 4 , ""%s()\\n"" , __func__ ) ; IRDA_ASSERT ( self != NULL , return ; ) ; IRDA_ASSERT ( self -> magic == IAS_MAGIC , return ; ) ; IRDA_ASSERT ( skb != NULL , return ; ) ; fp = skb -> data ; n = 1 ; name_len = fp [ n ++ ] ; <S2SV_StartBug> memcpy ( name , fp + n , name_len ) ; n += name_len ; <S2SV_EndBug> name [ name_len ] = '\\0' ; <S2SV_StartBug> attr_len = fp [ n ++ ] ; <S2SV_EndBug> memcpy ( attr , fp + n , attr_len ) ; n += attr_len ; attr [ attr_len ] = '\\0' ; IRDA_DEBUG ( 4 , ""LM-IAS:<S2SV_blank>Looking<S2SV_blank>up<S2SV_blank>%s:<S2SV_blank>%s\\n"" , name , attr ) ; obj = irias_find_object ( name ) ; if ( obj == NULL ) { IRDA_DEBUG ( 2 , ""LM-IAS:<S2SV_blank>Object<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>found\\n"" , name ) ; iriap_getvaluebyclass_response ( self , 0x1235 , IAS_CLASS_UNKNOWN , & irias_missing ) ; return ; } IRDA_DEBUG ( 4 , ""LM-IAS:<S2SV_blank>found<S2SV_blank>%s,<S2SV_blank>id=%d\\n"" , obj -> name , obj -> id ) ; attrib = irias_find_attrib ( obj , attr ) ; if ( attrib == NULL ) { IRDA_DEBUG ( 2 , ""LM-IAS:<S2SV_blank>Attribute<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>found\\n"" , attr ) ; iriap_getvaluebyclass_response ( self , obj -> id , IAS_ATTRIB_UNKNOWN , & irias_missing ) ; return ; } iriap_getvaluebyclass_response ( self , obj -> id , IAS_SUCCESS , attrib -> value ) ; }
","<S2SV_ModStart> ++ ] ; IRDA_ASSERT ( name_len < IAS_MAX_CLASSNAME + 1 , return ; ) ; <S2SV_ModStart> n ++ ] ; IRDA_ASSERT ( attr_len < IAS_MAX_ATTRIBNAME + 1 , return ; )
"
141,"CWE-362 int ext4_punch_hole ( struct inode * inode , loff_t offset , loff_t length ) { struct super_block * sb = inode -> i_sb ; ext4_lblk_t first_block , stop_block ; struct address_space * mapping = inode -> i_mapping ; loff_t first_block_offset , last_block_offset ; handle_t * handle ; unsigned int credits ; int ret = 0 ; if ( ! S_ISREG ( inode -> i_mode ) ) return - EOPNOTSUPP ; trace_ext4_punch_hole ( inode , offset , length , 0 ) ; if ( mapping -> nrpages && mapping_tagged ( mapping , PAGECACHE_TAG_DIRTY ) ) { ret = filemap_write_and_wait_range ( mapping , offset , offset + length - 1 ) ; if ( ret ) return ret ; } mutex_lock ( & inode -> i_mutex ) ; if ( offset >= inode -> i_size ) goto out_mutex ; if ( offset + length > inode -> i_size ) { length = inode -> i_size + PAGE_CACHE_SIZE - ( inode -> i_size & ( PAGE_CACHE_SIZE - 1 ) ) - offset ; } if ( offset & ( sb -> s_blocksize - 1 ) || ( offset + length ) & ( sb -> s_blocksize - 1 ) ) { ret = ext4_inode_attach_jinode ( inode ) ; if ( ret < 0 ) goto out_mutex ; } <S2SV_StartBug> first_block_offset = round_up ( offset , sb -> s_blocksize ) ; <S2SV_EndBug> last_block_offset = round_down ( ( offset + length ) , sb -> s_blocksize ) - 1 ; if ( last_block_offset > first_block_offset ) truncate_pagecache_range ( inode , first_block_offset , last_block_offset ) ; <S2SV_StartBug> ext4_inode_block_unlocked_dio ( inode ) ; <S2SV_EndBug> inode_dio_wait ( inode ) ; if ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) credits = ext4_writepage_trans_blocks ( inode ) ; else credits = ext4_blocks_for_truncate ( inode ) ; handle = ext4_journal_start ( inode , EXT4_HT_TRUNCATE , credits ) ; if ( IS_ERR ( handle ) ) { ret = PTR_ERR ( handle ) ; ext4_std_error ( sb , ret ) ; goto out_dio ; } ret = ext4_zero_partial_blocks ( handle , inode , offset , length ) ; if ( ret ) goto out_stop ; first_block = ( offset + sb -> s_blocksize - 1 ) >> EXT4_BLOCK_SIZE_BITS ( sb ) ; stop_block = ( offset + length ) >> EXT4_BLOCK_SIZE_BITS ( sb ) ; if ( first_block >= stop_block ) goto out_stop ; down_write ( & EXT4_I ( inode ) -> i_data_sem ) ; ext4_discard_preallocations ( inode ) ; ret = ext4_es_remove_extent ( inode , first_block , stop_block - first_block ) ; if ( ret ) { up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; goto out_stop ; } if ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ret = ext4_ext_remove_space ( inode , first_block , stop_block - 1 ) ; else ret = ext4_ind_remove_space ( handle , inode , first_block , stop_block ) ; up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; if ( IS_SYNC ( inode ) ) ext4_handle_sync ( handle ) ; <S2SV_StartBug> if ( last_block_offset > first_block_offset ) <S2SV_EndBug> truncate_pagecache_range ( inode , first_block_offset , last_block_offset ) ; inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ; ext4_mark_inode_dirty ( handle , inode ) ; out_stop : ext4_journal_stop ( handle ) ; out_dio : <S2SV_StartBug> ext4_inode_resume_unlocked_dio ( inode ) ; <S2SV_EndBug> out_mutex : mutex_unlock ( & inode -> i_mutex ) ; return ret ; }
","<S2SV_ModStart> out_mutex ; } ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModStart> last_block_offset ) ; <S2SV_ModEnd> if ( ext4_test_inode_flag <S2SV_ModStart> handle ) ; <S2SV_ModEnd> inode -> i_mtime <S2SV_ModStart> ; out_dio : up_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ;
"
142,"CWE-772 static Image * ReadPALMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; IndexPacket index ; MagickBooleanType status ; MagickOffsetType totalOffset , seekNextDepth ; MagickPixelPacket transpix ; register IndexPacket * indexes ; register ssize_t i , x ; register PixelPacket * q ; size_t bytes_per_row , flags , bits_per_pixel , version , nextDepthOffset , transparentIndex , compressionType , byte , mask , redbits , greenbits , bluebits , one , pad , size , bit ; ssize_t count , y ; unsigned char <S2SV_StartBug> * lastrow , <S2SV_EndBug> * one_row , * ptr ; unsigned short color16 ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { ( void ) DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } totalOffset = 0 ; do { image -> columns = ReadBlobMSBShort ( image ) ; image -> rows = ReadBlobMSBShort ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( CorruptImageError , ""NegativeOrZeroImageSize"" ) ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } bytes_per_row = ReadBlobMSBShort ( image ) ; flags = ReadBlobMSBShort ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; if ( ( bits_per_pixel != 1 ) && ( bits_per_pixel != 2 ) && ( bits_per_pixel != 4 ) && ( bits_per_pixel != 8 ) && ( bits_per_pixel != 16 ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedBitsPerPixel"" ) ; version = ( size_t ) ReadBlobByte ( image ) ; if ( ( version != 0 ) && ( version != 1 ) && ( version != 2 ) ) ThrowReaderException ( CorruptImageError , ""FileFormatVersionMismatch"" ) ; nextDepthOffset = ( size_t ) ReadBlobMSBShort ( image ) ; transparentIndex = ( size_t ) ReadBlobByte ( image ) ; compressionType = ( size_t ) ReadBlobByte ( image ) ; if ( ( compressionType != PALM_COMPRESSION_NONE ) && ( compressionType != PALM_COMPRESSION_SCANLINE ) && ( compressionType != PALM_COMPRESSION_RLE ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedImageCompression"" ) ; pad = ReadBlobMSBShort ( image ) ; ( void ) pad ; one = 1 ; if ( ( bits_per_pixel < 16 ) && ( AcquireImageColormap ( image , one << bits_per_pixel ) == MagickFalse ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; GetMagickPixelPacket ( image , & transpix ) ; if ( bits_per_pixel == 16 ) { redbits = ( size_t ) ReadBlobByte ( image ) ; ( void ) redbits ; greenbits = ( size_t ) ReadBlobByte ( image ) ; ( void ) greenbits ; bluebits = ( size_t ) ReadBlobByte ( image ) ; ( void ) bluebits ; ReadBlobByte ( image ) ; ReadBlobByte ( image ) ; transpix . red = ( MagickRealType ) ( QuantumRange * ReadBlobByte ( image ) / 31 ) ; transpix . green = ( MagickRealType ) ( QuantumRange * ReadBlobByte ( image ) / 63 ) ; transpix . blue = ( MagickRealType ) ( QuantumRange * ReadBlobByte ( image ) / 31 ) ; } if ( bits_per_pixel == 8 ) { IndexPacket index ; if ( flags & PALM_HAS_COLORMAP_FLAG ) { count = ( ssize_t ) ReadBlobMSBShort ( image ) ; for ( i = 0 ; i < ( ssize_t ) count ; i ++ ) { ReadBlobByte ( image ) ; index = ConstrainColormapIndex ( image , ( size_t ) ( 255 - i ) ) ; image -> colormap [ ( int ) index ] . red = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ ( int ) index ] . green = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ ( int ) index ] . blue = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; } } else for ( i = 0 ; i < ( ssize_t ) ( 1L << bits_per_pixel ) ; i ++ ) { index = ConstrainColormapIndex ( image , ( size_t ) ( 255 - i ) ) ; image -> colormap [ ( int ) index ] . red = ScaleCharToQuantum ( PalmPalette [ i ] [ 0 ] ) ; image -> colormap [ ( int ) index ] . green = ScaleCharToQuantum ( PalmPalette [ i ] [ 1 ] ) ; image -> colormap [ ( int ) index ] . blue = ScaleCharToQuantum ( PalmPalette [ i ] [ 2 ] ) ; } } if ( flags & PALM_IS_COMPRESSED_FLAG ) size = ReadBlobMSBShort ( image ) ; ( void ) size ; image -> storage_class = DirectClass ; if ( bits_per_pixel < 16 ) { image -> storage_class = PseudoClass ; image -> depth = 8 ; } if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( image ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } one_row = ( unsigned char * ) AcquireQuantumMemory ( MagickMax ( bytes_per_row , 2 * image -> columns ) , sizeof ( * one_row ) ) ; if ( one_row == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_StartBug> lastrow = ( unsigned char * ) NULL ; <S2SV_EndBug> if ( compressionType == PALM_COMPRESSION_SCANLINE ) { <S2SV_StartBug> lastrow = ( unsigned char * ) AcquireQuantumMemory ( MagickMax ( bytes_per_row , <S2SV_EndBug> <S2SV_StartBug> 2 * image -> columns ) , sizeof ( * lastrow ) ) ; <S2SV_EndBug> if ( lastrow == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } mask = ( size_t ) ( 1U << bits_per_pixel ) - 1 ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { if ( ( flags & PALM_IS_COMPRESSED_FLAG ) == 0 ) { image -> compression = NoCompression ; count = ReadBlob ( image , bytes_per_row , one_row ) ; if ( count != ( ssize_t ) bytes_per_row ) break ; } else { if ( compressionType == PALM_COMPRESSION_RLE ) { image -> compression = RLECompression ; for ( i = 0 ; i < ( ssize_t ) bytes_per_row ; ) { count = ( ssize_t ) ReadBlobByte ( image ) ; if ( count < 0 ) break ; count = MagickMin ( count , ( ssize_t ) bytes_per_row - i ) ; byte = ( size_t ) ReadBlobByte ( image ) ; ( void ) ResetMagickMemory ( one_row + i , ( int ) byte , ( size_t ) count ) ; i += count ; } } else if ( compressionType == PALM_COMPRESSION_SCANLINE ) { size_t one ; one = 1 ; image -> compression = FaxCompression ; for ( i = 0 ; i < ( ssize_t ) bytes_per_row ; i += 8 ) { count = ( ssize_t ) ReadBlobByte ( image ) ; if ( count < 0 ) break ; byte = ( size_t ) MagickMin ( ( ssize_t ) bytes_per_row - i , 8 ) ; for ( bit = 0 ; bit < byte ; bit ++ ) { if ( ( y == 0 ) || ( count & ( one << ( 7 - bit ) ) ) ) one_row [ i + bit ] = ( unsigned char ) ReadBlobByte ( image ) ; else <S2SV_StartBug> one_row [ i + bit ] = lastrow [ i + bit ] ; <S2SV_EndBug> } } <S2SV_StartBug> ( void ) CopyMagickMemory ( lastrow , one_row , bytes_per_row ) ; <S2SV_EndBug> } } ptr = one_row ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; if ( bits_per_pixel == 16 ) { if ( image -> columns > ( 2 * bytes_per_row ) ) { one_row = ( unsigned char * ) RelinquishMagickMemory ( one_row ) ; if ( compressionType == PALM_COMPRESSION_SCANLINE ) <S2SV_StartBug> lastrow = ( unsigned char * ) RelinquishMagickMemory ( lastrow ) ; <S2SV_EndBug> ThrowReaderException ( CorruptImageError , ""CorruptImage"" ) ; } for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { color16 = ( * ptr ++ << 8 ) ; color16 |= ( * ptr ++ ) ; SetPixelRed ( q , ( QuantumRange * ( ( color16 >> 11 ) & 0x1f ) ) / 0x1f ) ; SetPixelGreen ( q , ( QuantumRange * ( ( color16 >> 5 ) & 0x3f ) ) / 0x3f ) ; SetPixelBlue ( q , ( QuantumRange * ( ( color16 >> 0 ) & 0x1f ) ) / 0x1f ) ; SetPixelOpacity ( q , OpaqueOpacity ) ; q ++ ; } } else { bit = 8 - bits_per_pixel ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( ( size_t ) ( ptr - one_row ) >= bytes_per_row ) { one_row = ( unsigned char * ) RelinquishMagickMemory ( one_row ) ; if ( compressionType == PALM_COMPRESSION_SCANLINE ) <S2SV_StartBug> lastrow = ( unsigned char * ) RelinquishMagickMemory ( lastrow ) ; <S2SV_EndBug> ThrowReaderException ( CorruptImageError , ""CorruptImage"" ) ; } index = ( IndexPacket ) ( mask - ( ( ( * ptr ) & ( mask << bit ) ) >> bit ) ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; if ( bit ) bit -= bits_per_pixel ; else { ptr ++ ; bit = 8 - bits_per_pixel ; } q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } if ( flags & PALM_HAS_TRANSPARENCY_FLAG ) { IndexPacket index = ConstrainColormapIndex ( image , ( mask - transparentIndex ) ) ; if ( bits_per_pixel != 16 ) SetMagickPixelPacket ( image , image -> colormap + ( ssize_t ) index , ( const IndexPacket * ) NULL , & transpix ) ; ( void ) TransparentPaintImage ( image , & transpix , ( Quantum ) TransparentOpacity , MagickFalse ) ; } one_row = ( unsigned char * ) RelinquishMagickMemory ( one_row ) ; if ( compressionType == PALM_COMPRESSION_SCANLINE ) <S2SV_StartBug> lastrow = ( unsigned char * ) RelinquishMagickMemory ( lastrow ) ; <S2SV_EndBug> if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( nextDepthOffset != 0 ) { totalOffset += ( MagickOffsetType ) ( nextDepthOffset * 4 ) ; if ( totalOffset >= ( MagickOffsetType ) GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) else seekNextDepth = SeekBlob ( image , totalOffset , SEEK_SET ) ; if ( seekNextDepth != totalOffset ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { ( void ) DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( nextDepthOffset != 0 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> unsigned char * last_row <S2SV_ModEnd> , * one_row <S2SV_ModStart> ""MemoryAllocationFailed"" ) ; last_row <S2SV_ModEnd> = ( unsigned <S2SV_ModStart> PALM_COMPRESSION_SCANLINE ) { last_row <S2SV_ModEnd> = ( unsigned <S2SV_ModStart> sizeof ( * last_row ) ) ; if ( last_row <S2SV_ModEnd> == ( unsigned <S2SV_ModStart> bit ] = last_row <S2SV_ModEnd> [ i + <S2SV_ModStart> ) CopyMagickMemory ( last_row <S2SV_ModEnd> , one_row , <S2SV_ModStart> == PALM_COMPRESSION_SCANLINE ) last_row <S2SV_ModEnd> = ( unsigned <S2SV_ModStart> ) RelinquishMagickMemory ( last_row <S2SV_ModEnd> ) ; ThrowReaderException <S2SV_ModStart> == PALM_COMPRESSION_SCANLINE ) last_row <S2SV_ModEnd> = ( unsigned <S2SV_ModStart> ) RelinquishMagickMemory ( last_row <S2SV_ModEnd> ) ; ThrowReaderException <S2SV_ModStart> == PALM_COMPRESSION_SCANLINE ) last_row <S2SV_ModEnd> = ( unsigned <S2SV_ModStart> ) RelinquishMagickMemory ( last_row <S2SV_ModEnd> ) ; if
"
143,"CWE-20 static void _out_verify ( conn_t out , nad_t nad ) { int attr , ns ; jid_t from , to ; conn_t in ; char * rkey ; int valid ; attr = nad_find_attr ( nad , 0 , - 1 , ""from"" , NULL ) ; if ( attr < 0 || ( from = jid_new ( NAD_AVAL ( nad , attr ) , NAD_AVAL_L ( nad , attr ) ) ) == NULL ) { log_debug ( ZONE , ""missing<S2SV_blank>or<S2SV_blank>invalid<S2SV_blank>from<S2SV_blank>on<S2SV_blank>db<S2SV_blank>verify<S2SV_blank>packet"" ) ; nad_free ( nad ) ; return ; } attr = nad_find_attr ( nad , 0 , - 1 , ""to"" , NULL ) ; if ( attr < 0 || ( to = jid_new ( NAD_AVAL ( nad , attr ) , NAD_AVAL_L ( nad , attr ) ) ) == NULL ) { log_debug ( ZONE , ""missing<S2SV_blank>or<S2SV_blank>invalid<S2SV_blank>to<S2SV_blank>on<S2SV_blank>db<S2SV_blank>verify<S2SV_blank>packet"" ) ; jid_free ( from ) ; nad_free ( nad ) ; return ; } attr = nad_find_attr ( nad , 0 , - 1 , ""id"" , NULL ) ; if ( attr < 0 ) { log_debug ( ZONE , ""missing<S2SV_blank>id<S2SV_blank>on<S2SV_blank>db<S2SV_blank>verify<S2SV_blank>packet"" ) ; jid_free ( from ) ; jid_free ( to ) ; nad_free ( nad ) ; return ; } in = xhash_getx ( out -> s2s -> in , NAD_AVAL ( nad , attr ) , NAD_AVAL_L ( nad , attr ) ) ; if ( in == NULL ) { log_debug ( ZONE , ""got<S2SV_blank>a<S2SV_blank>verify<S2SV_blank>for<S2SV_blank>incoming<S2SV_blank>conn<S2SV_blank>%.*s,<S2SV_blank>but<S2SV_blank>it<S2SV_blank>doesn\'t<S2SV_blank>exist,<S2SV_blank>dropping<S2SV_blank>the<S2SV_blank>packet"" , NAD_AVAL_L ( nad , attr ) , NAD_AVAL ( nad , attr ) ) ; jid_free ( from ) ; jid_free ( to ) ; nad_free ( nad ) ; return ; } rkey = s2s_route_key ( NULL , to -> domain , from -> domain ) ; attr = nad_find_attr ( nad , 0 , - 1 , ""type"" , ""valid"" ) ; <S2SV_StartBug> if ( attr >= 0 ) { <S2SV_EndBug> xhash_put ( in -> states , pstrdup ( xhash_pool ( in -> states ) , rkey ) , ( void * ) conn_VALID ) ; log_write ( in -> s2s -> log , LOG_NOTICE , ""[%d]<S2SV_blank>[%s,<S2SV_blank>port=%d]<S2SV_blank>incoming<S2SV_blank>route<S2SV_blank>\'%s\'<S2SV_blank>is<S2SV_blank>now<S2SV_blank>valid%s%s"" , in -> fd -> fd , in -> ip , in -> port , rkey , ( in -> s -> flags & SX_SSL_WRAPPER ) ? "",<S2SV_blank>TLS<S2SV_blank>negotiated"" : """" , in -> s -> compressed ? "",<S2SV_blank>ZLIB<S2SV_blank>compression<S2SV_blank>enabled"" : """" ) ; valid = 1 ; } else { log_write ( in -> s2s -> log , LOG_NOTICE , ""[%d]<S2SV_blank>[%s,<S2SV_blank>port=%d]<S2SV_blank>incoming<S2SV_blank>route<S2SV_blank>\'%s\'<S2SV_blank>is<S2SV_blank>now<S2SV_blank>invalid"" , in -> fd -> fd , in -> ip , in -> port , rkey ) ; valid = 0 ; } free ( rkey ) ; nad_free ( nad ) ; -- out -> verify ; nad = nad_new ( ) ; ns = nad_add_namespace ( nad , uri_DIALBACK , ""db"" ) ; nad_append_elem ( nad , ns , ""result"" , 0 ) ; nad_append_attr ( nad , - 1 , ""to"" , from -> domain ) ; nad_append_attr ( nad , - 1 , ""from"" , to -> domain ) ; nad_append_attr ( nad , - 1 , ""type"" , valid ? ""valid"" : ""invalid"" ) ; sx_nad_write ( in -> s , nad ) ; if ( ! valid ) { sx_error ( in -> s , stream_err_INVALID_ID , ""dialback<S2SV_blank>negotiation<S2SV_blank>failed"" ) ; sx_close ( in -> s ) ; } jid_free ( from ) ; jid_free ( to ) ; }
","<S2SV_ModStart> attr >= 0 && xhash_get ( in -> states , rkey ) == ( void * ) conn_INPROGRESS
"
144,"CWE-399 static int do_tkill ( pid_t tgid , pid_t pid , int sig ) { <S2SV_StartBug> struct siginfo info ; <S2SV_EndBug> info . si_signo = sig ; info . si_errno = 0 ; info . si_code = SI_TKILL ; info . si_pid = task_tgid_vnr ( current ) ; info . si_uid = from_kuid_munged ( current_user_ns ( ) , current_uid ( ) ) ; return do_send_specific ( tgid , pid , sig , & info ) ; }
","<S2SV_ModStart> struct siginfo info = { }
"
145,"CWE-399 <S2SV_StartBug> void ptrace_triggered ( struct perf_event * bp , int nmi , <S2SV_EndBug> struct perf_sample_data * data , struct pt_regs * regs ) { struct perf_event_attr attr ; attr = bp -> attr ; attr . disabled = true ; modify_user_hw_breakpoint ( bp , & attr ) ; }
","<S2SV_ModStart> perf_event * bp <S2SV_ModEnd> , struct perf_sample_data
"
146,"CWE-119 static ssize_t k90_show_current_profile ( struct device * dev , struct device_attribute * attr , char * buf ) { int ret ; struct usb_interface * usbif = to_usb_interface ( dev -> parent ) ; struct usb_device * usbdev = interface_to_usbdev ( usbif ) ; int current_profile ; <S2SV_StartBug> char data [ 8 ] ; <S2SV_EndBug> ret = usb_control_msg ( usbdev , usb_rcvctrlpipe ( usbdev , 0 ) , K90_REQUEST_STATUS , USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE , 0 , 0 , data , 8 , USB_CTRL_SET_TIMEOUT ) ; if ( ret < 0 ) { dev_warn ( dev , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>K90<S2SV_blank>initial<S2SV_blank>state<S2SV_blank>(error<S2SV_blank>%d).\\n"" , ret ) ; <S2SV_StartBug> return - EIO ; <S2SV_EndBug> } current_profile = data [ 7 ] ; if ( current_profile < 1 || current_profile > 3 ) { dev_warn ( dev , ""Read<S2SV_blank>invalid<S2SV_blank>current<S2SV_blank>profile:<S2SV_blank>%02hhx.\\n"" , data [ 7 ] ) ; <S2SV_StartBug> return - EIO ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> return snprintf ( buf , PAGE_SIZE , ""%d\\n"" , current_profile ) ; }
","<S2SV_ModStart> current_profile ; char * data ; data = kmalloc ( 8 , GFP_KERNEL ) ; if ( ! data ) return - ENOMEM <S2SV_ModEnd> ; ret = <S2SV_ModStart> ret ) ; ret = - EIO ; goto out <S2SV_ModEnd> ; } current_profile <S2SV_ModStart> ] ) ; ret = <S2SV_ModEnd> - EIO ; <S2SV_ModStart> - EIO ; goto out ; } ret = snprintf ( buf , PAGE_SIZE , ""%d\\n"" , current_profile ) ; out : kfree ( data ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
"
147,"CWE-264 static void opl3_panning ( int dev , int voice , int value ) { <S2SV_StartBug> devc -> voc [ voice ] . panning = value ; <S2SV_EndBug> }
","<S2SV_ModStart> value ) { if ( voice < 0 || voice >= devc -> nr_voice ) return ;
"
148,"CWE-119 timestamp PGTYPEStimestamp_from_asc ( char * str , char * * endptr ) { timestamp result ; # ifdef HAVE_INT64_TIMESTAMP int64 noresult = 0 ; # else double noresult = 0.0 ; # endif fsec_t fsec ; struct tm tt , * tm = & tt ; int dtype ; int nf ; char * field [ MAXDATEFIELDS ] ; int ftype [ MAXDATEFIELDS ] ; char lowstr [ MAXDATELEN + MAXDATEFIELDS ] ; char * realptr ; char * * ptr = ( endptr != NULL ) ? endptr : & realptr ; <S2SV_StartBug> if ( strlen ( str ) >= sizeof ( lowstr ) ) <S2SV_EndBug> { errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult ) ; } <S2SV_StartBug> if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 || <S2SV_EndBug> DecodeDateTime ( field , ftype , nf , & dtype , tm , & fsec , 0 ) != 0 ) { errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult ) ; } switch ( dtype ) { case DTK_DATE : if ( tm2timestamp ( tm , fsec , NULL , & result ) != 0 ) { errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult ) ; } break ; case DTK_EPOCH : result = SetEpochTimestamp ( ) ; break ; case DTK_LATE : TIMESTAMP_NOEND ( result ) ; break ; case DTK_EARLY : TIMESTAMP_NOBEGIN ( result ) ; break ; case DTK_INVALID : errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult ) ; default : errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult ) ; } errno = 0 ; return result ; }
","<S2SV_ModStart> ( str ) > MAXDATELEN ) { errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult ) ; } if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 || DecodeDateTime ( field , ftype , nf , & dtype , tm , & fsec , 0 ) != 0 ) { errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult ) ; } switch ( dtype ) { case DTK_DATE : if ( tm2timestamp ( tm , fsec , NULL , & result <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ) != 0 <S2SV_ModEnd> ) { errno
"
149,"CWE-264 static inline int check_entry_size_and_hooks ( struct arpt_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct arpt_entry ) != 0 || ( unsigned char * ) e + sizeof ( struct arpt_entry ) >= limit || ( unsigned char * ) e + e -> next_offset > limit ) { duprintf ( ""Bad<S2SV_blank>offset<S2SV_blank>%p\\n"" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct arpt_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\n"" , e , e -> next_offset ) ; return - EINVAL ; } if ( ! arp_checkentry ( & e -> arp ) ) return - EINVAL ; <S2SV_StartBug> err = xt_check_entry_offsets ( e , e -> target_offset , e -> next_offset ) ; <S2SV_EndBug> if ( err ) return err ; for ( h = 0 ; h < NF_ARP_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) { pr_debug ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>"" ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"" ""ACCEPT/DROP\\n"" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows [ h ] ; } } e -> counters = ( ( struct xt_counters ) { 0 , 0 } ) ; e -> comefrom = 0 ; return 0 ; }
","<S2SV_ModStart> , e -> elems , e ->
"
150,"CWE-284 static int check_rpcsec_auth ( struct svc_req * rqstp ) { gss_ctx_id_t ctx ; krb5_context kctx ; OM_uint32 maj_stat , min_stat ; gss_name_t name ; krb5_principal princ ; int ret , success ; krb5_data * c1 , * c2 , * realm ; gss_buffer_desc gss_str ; kadm5_server_handle_t handle ; size_t slen ; char * sdots ; success = 0 ; handle = ( kadm5_server_handle_t ) global_server_handle ; if ( rqstp -> rq_cred . oa_flavor != RPCSEC_GSS ) return 0 ; ctx = rqstp -> rq_svccred ; maj_stat = gss_inquire_context ( & min_stat , ctx , NULL , & name , NULL , NULL , NULL , NULL , NULL ) ; if ( maj_stat != GSS_S_COMPLETE ) { krb5_klog_syslog ( LOG_ERR , _ ( ""check_rpcsec_auth:<S2SV_blank>failed<S2SV_blank>"" ""inquire_context,<S2SV_blank>stat=%u"" ) , maj_stat ) ; log_badauth ( maj_stat , min_stat , rqstp -> rq_xprt , NULL ) ; goto fail_name ; } kctx = handle -> context ; ret = gss_to_krb5_name_1 ( rqstp , kctx , name , & princ , & gss_str ) ; if ( ret == 0 ) goto fail_name ; slen = gss_str . length ; trunc_name ( & slen , & sdots ) ; if ( krb5_princ_size ( kctx , princ ) != 2 ) goto fail_princ ; c1 = krb5_princ_component ( kctx , princ , 0 ) ; c2 = krb5_princ_component ( kctx , princ , 1 ) ; realm = krb5_princ_realm ( kctx , princ ) ; <S2SV_StartBug> if ( strncmp ( handle -> params . realm , realm -> data , realm -> length ) == 0 <S2SV_EndBug> && strncmp ( ""kadmin"" , c1 -> data , c1 -> length ) == 0 ) { if ( strncmp ( ""history"" , c2 -> data , c2 -> length ) == 0 ) goto fail_princ ; else success = 1 ; } fail_princ : if ( ! success ) { krb5_klog_syslog ( LOG_ERR , _ ( ""bad<S2SV_blank>service<S2SV_blank>principal<S2SV_blank>%.*s%s"" ) , ( int ) slen , ( char * ) gss_str . value , sdots ) ; } gss_release_buffer ( & min_stat , & gss_str ) ; krb5_free_principal ( kctx , princ ) ; fail_name : gss_release_name ( & min_stat , & name ) ; return success ; }
","<S2SV_ModStart> princ ) ; success = data_eq_string ( * realm , <S2SV_ModEnd> handle -> params <S2SV_ModStart> params . realm ) && data_eq_string ( * c1 , ""kadmin"" ) && ! data_eq_string ( * c2 , ""history"" ) ; <S2SV_ModEnd> fail_princ : if
"
151,"CWE-400 static long pmcraid_ioctl_passthrough ( struct pmcraid_instance * pinstance , unsigned int ioctl_cmd , unsigned int buflen , unsigned long arg ) { struct pmcraid_passthrough_ioctl_buffer * buffer ; struct pmcraid_ioarcb * ioarcb ; struct pmcraid_cmd * cmd ; struct pmcraid_cmd * cancel_cmd ; unsigned long request_buffer ; unsigned long request_offset ; unsigned long lock_flags ; void * ioasa ; u32 ioasc ; int request_size ; int buffer_size ; u8 access , direction ; int rc = 0 ; if ( pinstance -> ioa_reset_in_progress ) { rc = wait_event_interruptible_timeout ( pinstance -> reset_wait_q , ! pinstance -> ioa_reset_in_progress , msecs_to_jiffies ( 10000 ) ) ; if ( ! rc ) return - ETIMEDOUT ; else if ( rc < 0 ) return - ERESTARTSYS ; } if ( pinstance -> ioa_state != IOA_STATE_OPERATIONAL ) { pmcraid_err ( ""IOA<S2SV_blank>is<S2SV_blank>not<S2SV_blank>operational\\n"" ) ; return - ENOTTY ; } buffer_size = sizeof ( struct pmcraid_passthrough_ioctl_buffer ) ; buffer = kmalloc ( buffer_size , GFP_KERNEL ) ; if ( ! buffer ) { pmcraid_err ( ""no<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>passthrough<S2SV_blank>buffer\\n"" ) ; return - ENOMEM ; } request_offset = offsetof ( struct pmcraid_passthrough_ioctl_buffer , request_buffer ) ; request_buffer = arg + request_offset ; rc = __copy_from_user ( buffer , ( struct pmcraid_passthrough_ioctl_buffer * ) arg , sizeof ( struct pmcraid_passthrough_ioctl_buffer ) ) ; ioasa = ( void * ) ( arg + offsetof ( struct pmcraid_passthrough_ioctl_buffer , ioasa ) ) ; if ( rc ) { pmcraid_err ( ""ioctl:<S2SV_blank>can\'t<S2SV_blank>copy<S2SV_blank>passthrough<S2SV_blank>buffer\\n"" ) ; rc = - EFAULT ; goto out_free_buffer ; } request_size = buffer -> ioarcb . data_transfer_length ; if ( buffer -> ioarcb . request_flags0 & TRANSFER_DIR_WRITE ) { access = VERIFY_READ ; direction = DMA_TO_DEVICE ; } else { access = VERIFY_WRITE ; direction = DMA_FROM_DEVICE ; } if ( request_size > 0 ) { rc = access_ok ( access , arg , request_offset + request_size ) ; if ( ! rc ) { rc = - EFAULT ; goto out_free_buffer ; } } else if ( request_size < 0 ) { rc = - EINVAL ; goto out_free_buffer ; } if ( buffer -> ioarcb . add_cmd_param_length > PMCRAID_ADD_CMD_PARAM_LEN ) { rc = - EINVAL ; goto out_free_buffer ; } cmd = pmcraid_get_free_cmd ( pinstance ) ; if ( ! cmd ) { pmcraid_err ( ""free<S2SV_blank>command<S2SV_blank>block<S2SV_blank>is<S2SV_blank>not<S2SV_blank>available\\n"" ) ; rc = - ENOMEM ; goto out_free_buffer ; } cmd -> scsi_cmd = NULL ; ioarcb = & ( cmd -> ioa_cb -> ioarcb ) ; ioarcb -> resource_handle = buffer -> ioarcb . resource_handle ; ioarcb -> data_transfer_length = buffer -> ioarcb . data_transfer_length ; ioarcb -> cmd_timeout = buffer -> ioarcb . cmd_timeout ; ioarcb -> request_type = buffer -> ioarcb . request_type ; ioarcb -> request_flags0 = buffer -> ioarcb . request_flags0 ; ioarcb -> request_flags1 = buffer -> ioarcb . request_flags1 ; memcpy ( ioarcb -> cdb , buffer -> ioarcb . cdb , PMCRAID_MAX_CDB_LEN ) ; if ( buffer -> ioarcb . add_cmd_param_length ) { ioarcb -> add_cmd_param_length = buffer -> ioarcb . add_cmd_param_length ; ioarcb -> add_cmd_param_offset = buffer -> ioarcb . add_cmd_param_offset ; memcpy ( ioarcb -> add_data . u . add_cmd_params , buffer -> ioarcb . add_data . u . add_cmd_params , buffer -> ioarcb . add_cmd_param_length ) ; } ioarcb -> hrrq_id = atomic_add_return ( 1 , & ( pinstance -> last_message_id ) ) % pinstance -> num_hrrq ; if ( request_size ) { rc = pmcraid_build_passthrough_ioadls ( cmd , request_size , direction ) ; if ( rc ) { pmcraid_err ( ""couldn\'t<S2SV_blank>build<S2SV_blank>passthrough<S2SV_blank>ioadls\\n"" ) ; goto out_free_buffer ; <S2SV_StartBug> } <S2SV_EndBug> } if ( direction == DMA_TO_DEVICE && request_size > 0 ) { rc = pmcraid_copy_sglist ( cmd -> sglist , request_buffer , request_size , direction ) ; if ( rc ) { pmcraid_err ( ""failed<S2SV_blank>to<S2SV_blank>copy<S2SV_blank>user<S2SV_blank>buffer\\n"" ) ; goto out_free_sglist ; } } cmd -> cmd_done = pmcraid_internal_done ; init_completion ( & cmd -> wait_for_completion ) ; cmd -> completion_req = 1 ; pmcraid_info ( ""command(%d)<S2SV_blank>(CDB[0]<S2SV_blank>=<S2SV_blank>%x)<S2SV_blank>for<S2SV_blank>%x\\n"" , le32_to_cpu ( cmd -> ioa_cb -> ioarcb . response_handle ) >> 2 , cmd -> ioa_cb -> ioarcb . cdb [ 0 ] , le32_to_cpu ( cmd -> ioa_cb -> ioarcb . resource_handle ) ) ; spin_lock_irqsave ( pinstance -> host -> host_lock , lock_flags ) ; _pmcraid_fire_command ( cmd ) ; spin_unlock_irqrestore ( pinstance -> host -> host_lock , lock_flags ) ; buffer -> ioarcb . cmd_timeout = 0 ; if ( buffer -> ioarcb . cmd_timeout == 0 ) { wait_for_completion ( & cmd -> wait_for_completion ) ; } else if ( ! wait_for_completion_timeout ( & cmd -> wait_for_completion , msecs_to_jiffies ( buffer -> ioarcb . cmd_timeout * 1000 ) ) ) { pmcraid_info ( ""aborting<S2SV_blank>cmd<S2SV_blank>%d<S2SV_blank>(CDB[0]<S2SV_blank>=<S2SV_blank>%x)<S2SV_blank>due<S2SV_blank>to<S2SV_blank>timeout\\n"" , le32_to_cpu ( cmd -> ioa_cb -> ioarcb . response_handle >> 2 ) , cmd -> ioa_cb -> ioarcb . cdb [ 0 ] ) ; spin_lock_irqsave ( pinstance -> host -> host_lock , lock_flags ) ; cancel_cmd = pmcraid_abort_cmd ( cmd ) ; spin_unlock_irqrestore ( pinstance -> host -> host_lock , lock_flags ) ; if ( cancel_cmd ) { wait_for_completion ( & cancel_cmd -> wait_for_completion ) ; ioasc = cancel_cmd -> ioa_cb -> ioasa . ioasc ; pmcraid_return_cmd ( cancel_cmd ) ; if ( ioasc == PMCRAID_IOASC_IOA_WAS_RESET || PMCRAID_IOASC_SENSE_KEY ( ioasc ) == 0x00 ) { if ( ioasc != PMCRAID_IOASC_GC_IOARCB_NOTFOUND ) rc = - ETIMEDOUT ; goto out_handle_response ; } } if ( ! wait_for_completion_timeout ( & cmd -> wait_for_completion , msecs_to_jiffies ( 150 * 1000 ) ) ) { pmcraid_reset_bringup ( cmd -> drv_inst ) ; rc = - ETIMEDOUT ; } } out_handle_response : if ( copy_to_user ( ioasa , & cmd -> ioa_cb -> ioasa , sizeof ( struct pmcraid_ioasa ) ) ) { pmcraid_err ( ""failed<S2SV_blank>to<S2SV_blank>copy<S2SV_blank>ioasa<S2SV_blank>buffer<S2SV_blank>to<S2SV_blank>user\\n"" ) ; rc = - EFAULT ; } else if ( direction == DMA_FROM_DEVICE && request_size > 0 ) { rc = pmcraid_copy_sglist ( cmd -> sglist , request_buffer , request_size , direction ) ; if ( rc ) { pmcraid_err ( ""failed<S2SV_blank>to<S2SV_blank>copy<S2SV_blank>user<S2SV_blank>buffer\\n"" ) ; rc = - EFAULT ; } } out_free_sglist : pmcraid_release_passthrough_ioadls ( cmd , request_size , direction ) ; pmcraid_return_cmd ( cmd ) ; out_free_buffer : kfree ( buffer ) ; return rc ; }
","<S2SV_ModStart> out_free_buffer ; } } else if ( request_size < 0 ) { rc = - EINVAL ; goto out_free_buffer ;
"
152,"CWE-000 int perf_config ( config_fn_t fn , void * data ) { <S2SV_StartBug> int ret = 0 , found = 0 ; <S2SV_EndBug> char * repo_config = NULL ; const char * home = NULL ; if ( config_exclusive_filename ) return perf_config_from_file ( fn , config_exclusive_filename , data ) ; if ( perf_config_system ( ) && ! access ( perf_etc_perfconfig ( ) , R_OK ) ) { ret += perf_config_from_file ( fn , perf_etc_perfconfig ( ) , data ) ; found += 1 ; } home = getenv ( ""HOME"" ) ; if ( perf_config_global ( ) && home ) { char * user_config = strdup ( mkpath ( ""%s/.perfconfig"" , home ) ) ; if ( ! access ( user_config , R_OK ) ) { ret += perf_config_from_file ( fn , user_config , data ) ; found += 1 ; } free ( user_config ) ; } <S2SV_StartBug> repo_config = perf_pathdup ( ""config"" ) ; <S2SV_EndBug> if ( ! access ( repo_config , R_OK ) ) { ret += perf_config_from_file ( fn , repo_config , data ) ; found += 1 ; } free ( repo_config ) ; if ( found == 0 ) return - 1 ; return ret ; }
","<S2SV_ModStart> found = 0 <S2SV_ModEnd> ; const char <S2SV_ModStart> ) ; } <S2SV_ModEnd> if ( found
"
153,"CWE-362 static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <S2SV_StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <S2SV_EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <S2SV_StartBug> if ( ! po -> running ) <S2SV_EndBug> <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> if ( po -> fanout ) <S2SV_StartBug> return - EALREADY ; <S2SV_EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <S2SV_StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! po -> rollover ) <S2SV_EndBug> return - ENOMEM ; <S2SV_StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <S2SV_StartBug> mutex_unlock ( & fanout_mutex ) ; <S2SV_EndBug> <S2SV_StartBug> if ( err ) { <S2SV_EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
","<S2SV_ModStart> ) { struct packet_rollover * rollover = NULL ; struct <S2SV_ModStart> EINVAL ; } mutex_lock ( & fanout_mutex ) ; err = - EINVAL ; <S2SV_ModStart> -> running ) goto out ; err = - EALREADY <S2SV_ModEnd> ; if ( <S2SV_ModStart> -> fanout ) goto out <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) { err = - ENOMEM ; <S2SV_ModEnd> rollover = kzalloc <S2SV_ModStart> sizeof ( * <S2SV_ModEnd> rollover ) , <S2SV_ModStart> if ( ! rollover ) goto out <S2SV_ModEnd> ; atomic_long_set ( <S2SV_ModStart> atomic_long_set ( & <S2SV_ModEnd> rollover -> num <S2SV_ModStart> atomic_long_set ( & <S2SV_ModEnd> rollover -> num_huge <S2SV_ModStart> atomic_long_set ( & <S2SV_ModEnd> rollover -> num_failed <S2SV_ModStart> 0 ) ; po -> rollover = rollover ; } <S2SV_ModEnd> match = NULL <S2SV_ModStart> } out : if ( err && rollover ) { kfree ( rollover ) ; po -> rollover = NULL ; } <S2SV_ModStart> fanout_mutex ) ; <S2SV_ModEnd> return err ;
"
154,"CWE-416 static void nick_hash_remove ( CHANNEL_REC * channel , NICK_REC * nick ) { <S2SV_StartBug> NICK_REC * list ; <S2SV_EndBug> list = g_hash_table_lookup ( channel -> nicks , nick -> nick ) ; if ( list == NULL ) return ; <S2SV_StartBug> if ( list == nick || list -> next == NULL ) { <S2SV_EndBug> g_hash_table_remove ( channel -> nicks , nick -> nick ) ; if ( list -> next != NULL ) { <S2SV_StartBug> g_hash_table_insert ( channel -> nicks , nick -> next -> nick , <S2SV_EndBug> nick -> next ) ; } <S2SV_StartBug> } else { <S2SV_EndBug> while ( list -> next != nick ) list = list -> next ; list -> next = nick -> next ; } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> NICK_REC * list , * newlist <S2SV_ModStart> list == nick ) { newlist = <S2SV_ModEnd> nick -> next <S2SV_ModStart> nick -> next ; <S2SV_ModEnd> } else { <S2SV_ModStart> } else { newlist = list ; <S2SV_ModStart> next ; } g_hash_table_remove ( channel -> nicks , nick -> nick ) ; if ( newlist != NULL ) { g_hash_table_insert ( channel -> nicks , newlist -> nick , newlist ) ; }
"
155,"CWE-284 static void ImportGrayQuantum ( const Image * image , QuantumInfo * quantum_info , const MagickSizeType number_pixels , const unsigned char * magick_restrict p , Quantum * magick_restrict q , ExceptionInfo * exception ) { QuantumAny range ; register ssize_t x ; ssize_t bit ; unsigned int pixel ; assert ( image != ( Image * ) NULL ) ; assert ( image -> signature == MagickCoreSignature ) ; <S2SV_StartBug> switch ( quantum_info -> depth ) <S2SV_EndBug> { case 1 : { register Quantum black , white ; black = 0 ; white = QuantumRange ; if ( quantum_info -> min_is_white != MagickFalse ) { black = QuantumRange ; white = 0 ; } for ( x = 0 ; x < ( ( ssize_t ) number_pixels - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { SetPixelGray ( image , ( ( * p ) & ( 1 << ( 7 - bit ) ) ) == 0 ? black : white , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } for ( bit = 0 ; bit < ( ssize_t ) ( number_pixels % 8 ) ; bit ++ ) { SetPixelGray ( image , ( ( * p ) & ( 0x01 << ( 7 - bit ) ) ) == 0 ? black : white , q ) ; q += GetPixelChannels ( image ) ; } if ( bit != 0 ) p ++ ; break ; } case 4 : { register unsigned char pixel ; range = GetQuantumRange ( quantum_info -> depth ) ; for ( x = 0 ; x < ( ( ssize_t ) number_pixels - 1 ) ; x += 2 ) { pixel = ( unsigned char ) ( ( * p >> 4 ) & 0xf ) ; SetPixelGray ( image , ScaleAnyToQuantum ( pixel , range ) , q ) ; q += GetPixelChannels ( image ) ; pixel = ( unsigned char ) ( ( * p ) & 0xf ) ; SetPixelGray ( image , ScaleAnyToQuantum ( pixel , range ) , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } for ( bit = 0 ; bit < ( ssize_t ) ( number_pixels % 2 ) ; bit ++ ) { pixel = ( unsigned char ) ( * p ++ >> 4 ) ; SetPixelGray ( image , ScaleAnyToQuantum ( pixel , range ) , q ) ; q += GetPixelChannels ( image ) ; } break ; } case 8 : { unsigned char pixel ; if ( quantum_info -> min_is_white != MagickFalse ) { for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) { p = PushCharPixel ( p , & pixel ) ; SetPixelGray ( image , ScaleCharToQuantum ( pixel ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; p += quantum_info -> pad ; q += GetPixelChannels ( image ) ; } break ; } for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) { p = PushCharPixel ( p , & pixel ) ; SetPixelGray ( image , ScaleCharToQuantum ( pixel ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; p += quantum_info -> pad ; q += GetPixelChannels ( image ) ; } break ; } case 10 : { range = GetQuantumRange ( quantum_info -> depth ) ; if ( quantum_info -> pack == MagickFalse ) { if ( image -> endian == LSBEndian ) { for ( x = 0 ; x < ( ssize_t ) ( number_pixels - 2 ) ; x += 3 ) { p = PushLongPixel ( quantum_info -> endian , p , & pixel ) ; SetPixelGray ( image , ScaleAnyToQuantum ( ( pixel >> 22 ) & 0x3ff , range ) , q ) ; q += GetPixelChannels ( image ) ; SetPixelGray ( image , ScaleAnyToQuantum ( ( pixel >> 12 ) & 0x3ff , range ) , q ) ; q += GetPixelChannels ( image ) ; SetPixelGray ( image , ScaleAnyToQuantum ( ( pixel >> 2 ) & 0x3ff , range ) , q ) ; p += quantum_info -> pad ; q += GetPixelChannels ( image ) ; } p = PushLongPixel ( quantum_info -> endian , p , & pixel ) ; if ( x ++ < ( ssize_t ) ( number_pixels - 1 ) ) { SetPixelGray ( image , ScaleAnyToQuantum ( ( pixel >> 22 ) & 0x3ff , range ) , q ) ; q += GetPixelChannels ( image ) ; } if ( x ++ < ( ssize_t ) number_pixels ) { SetPixelGray ( image , ScaleAnyToQuantum ( ( pixel >> 12 ) & 0x3ff , range ) , q ) ; q += GetPixelChannels ( image ) ; } break ; } for ( x = 0 ; x < ( ssize_t ) ( number_pixels - 2 ) ; x += 3 ) { p = PushLongPixel ( quantum_info -> endian , p , & pixel ) ; SetPixelGray ( image , ScaleAnyToQuantum ( ( pixel >> 2 ) & 0x3ff , range ) , q ) ; q += GetPixelChannels ( image ) ; SetPixelGray ( image , ScaleAnyToQuantum ( ( pixel >> 12 ) & 0x3ff , range ) , q ) ; q += GetPixelChannels ( image ) ; SetPixelGray ( image , ScaleAnyToQuantum ( ( pixel >> 22 ) & 0x3ff , range ) , q ) ; p += quantum_info -> pad ; q += GetPixelChannels ( image ) ; } p = PushLongPixel ( quantum_info -> endian , p , & pixel ) ; if ( x ++ < ( ssize_t ) ( number_pixels - 1 ) ) { SetPixelGray ( image , ScaleAnyToQuantum ( ( pixel >> 2 ) & 0x3ff , range ) , q ) ; q += GetPixelChannels ( image ) ; } if ( x ++ < ( ssize_t ) number_pixels ) { SetPixelGray ( image , ScaleAnyToQuantum ( ( pixel >> 12 ) & 0x3ff , range ) , q ) ; q += GetPixelChannels ( image ) ; } break ; } for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) { p = PushQuantumPixel ( quantum_info , p , & pixel ) ; SetPixelGray ( image , ScaleAnyToQuantum ( pixel , range ) , q ) ; p += quantum_info -> pad ; q += GetPixelChannels ( image ) ; } break ; } case 12 : { range = GetQuantumRange ( quantum_info -> depth ) ; if ( quantum_info -> pack == MagickFalse ) { unsigned short pixel ; for ( x = 0 ; x < ( ssize_t ) ( number_pixels - 1 ) ; x += 2 ) { p = PushShortPixel ( quantum_info -> endian , p , & pixel ) ; SetPixelGray ( image , ScaleAnyToQuantum ( ( QuantumAny ) ( pixel >> 4 ) , range ) , q ) ; q += GetPixelChannels ( image ) ; p = PushShortPixel ( quantum_info -> endian , p , & pixel ) ; SetPixelGray ( image , ScaleAnyToQuantum ( ( QuantumAny ) ( pixel >> 4 ) , range ) , q ) ; p += quantum_info -> pad ; q += GetPixelChannels ( image ) ; } for ( bit = 0 ; bit < ( ssize_t ) ( number_pixels % 2 ) ; bit ++ ) { p = PushShortPixel ( quantum_info -> endian , p , & pixel ) ; SetPixelGray ( image , ScaleAnyToQuantum ( ( QuantumAny ) ( pixel >> 4 ) , range ) , q ) ; p += quantum_info -> pad ; q += GetPixelChannels ( image ) ; } if ( bit != 0 ) p ++ ; break ; } for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) { p = PushQuantumPixel ( quantum_info , p , & pixel ) ; SetPixelGray ( image , ScaleAnyToQuantum ( pixel , range ) , q ) ; p += quantum_info -> pad ; q += GetPixelChannels ( image ) ; } break ; } case 16 : { unsigned short pixel ; if ( quantum_info -> min_is_white != MagickFalse ) { for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) { p = PushShortPixel ( quantum_info -> endian , p , & pixel ) ; SetPixelGray ( image , ScaleShortToQuantum ( pixel ) , q ) ; p += quantum_info -> pad ; q += GetPixelChannels ( image ) ; } break ; } if ( quantum_info -> format == FloatingPointQuantumFormat ) { for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) { p = PushShortPixel ( quantum_info -> endian , p , & pixel ) ; SetPixelGray ( image , ClampToQuantum ( QuantumRange * HalfToSinglePrecision ( pixel ) ) , q ) ; p += quantum_info -> pad ; q += GetPixelChannels ( image ) ; } break ; } for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) { p = PushShortPixel ( quantum_info -> endian , p , & pixel ) ; SetPixelGray ( image , ScaleShortToQuantum ( pixel ) , q ) ; p += quantum_info -> pad ; q += GetPixelChannels ( image ) ; } break ; } case 32 : { unsigned int pixel ; if ( quantum_info -> format == FloatingPointQuantumFormat ) { float pixel ; for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) { p = PushFloatPixel ( quantum_info , p , & pixel ) ; SetPixelGray ( image , ClampToQuantum ( pixel ) , q ) ; p += quantum_info -> pad ; q += GetPixelChannels ( image ) ; } break ; } for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) { p = PushLongPixel ( quantum_info -> endian , p , & pixel ) ; SetPixelGray ( image , ScaleLongToQuantum ( pixel ) , q ) ; p += quantum_info -> pad ; q += GetPixelChannels ( image ) ; } break ; } case 64 : { if ( quantum_info -> format == FloatingPointQuantumFormat ) { double pixel ; for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) { p = PushDoublePixel ( quantum_info , p , & pixel ) ; SetPixelGray ( image , ClampToQuantum ( pixel ) , q ) ; p += quantum_info -> pad ; q += GetPixelChannels ( image ) ; } break ; } } default : { range = GetQuantumRange ( quantum_info -> depth ) ; for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) { p = PushQuantumPixel ( quantum_info , p , & pixel ) ; SetPixelGray ( image , ScaleAnyToQuantum ( pixel , range ) , q ) ; p += quantum_info -> pad ; q += GetPixelChannels ( image ) ; } break ; } } }
","<S2SV_ModStart> MagickCoreSignature ) ; pixel = 0 ;
"
156,"CWE-835 static int read_data ( void * opaque , uint8_t * buf , int buf_size ) { struct playlist * v = opaque ; HLSContext * c = v -> parent -> priv_data ; int ret , i ; <S2SV_StartBug> int just_opened = 0 ; <S2SV_EndBug> restart : if ( ! v -> needed ) return AVERROR_EOF ; if ( ! v -> input ) { int64_t reload_interval ; struct segment * seg ; if ( v -> ctx && v -> ctx -> nb_streams ) { v -> needed = 0 ; for ( i = 0 ; i < v -> n_main_streams ; i ++ ) { if ( v -> main_streams [ i ] -> discard < AVDISCARD_ALL ) { v -> needed = 1 ; break ; } } } if ( ! v -> needed ) { av_log ( v -> parent , AV_LOG_INFO , ""No<S2SV_blank>longer<S2SV_blank>receiving<S2SV_blank>playlist<S2SV_blank>%d\\n"" , v -> index ) ; return AVERROR_EOF ; } reload_interval = default_reload_interval ( v ) ; reload : <S2SV_StartBug> if ( ! v -> finished && <S2SV_EndBug> av_gettime_relative ( ) - v -> last_load_time >= reload_interval ) { if ( ( ret = parse_playlist ( c , v -> url , v , NULL ) ) < 0 ) { av_log ( v -> parent , AV_LOG_WARNING , ""Failed<S2SV_blank>to<S2SV_blank>reload<S2SV_blank>playlist<S2SV_blank>%d\\n"" , v -> index ) ; return ret ; } reload_interval = v -> target_duration / 2 ; } if ( v -> cur_seq_no < v -> start_seq_no ) { av_log ( NULL , AV_LOG_WARNING , ""skipping<S2SV_blank>%d<S2SV_blank>segments<S2SV_blank>ahead,<S2SV_blank>expired<S2SV_blank>from<S2SV_blank>playlists\\n"" , v -> start_seq_no - v -> cur_seq_no ) ; v -> cur_seq_no = v -> start_seq_no ; } if ( v -> cur_seq_no >= v -> start_seq_no + v -> n_segments ) { if ( v -> finished ) return AVERROR_EOF ; while ( av_gettime_relative ( ) - v -> last_load_time < reload_interval ) { if ( ff_check_interrupt ( c -> interrupt_callback ) ) return AVERROR_EXIT ; av_usleep ( 100 * 1000 ) ; } goto reload ; } seg = current_segment ( v ) ; ret = update_init_section ( v , seg ) ; if ( ret ) return ret ; ret = open_input ( c , v , seg ) ; if ( ret < 0 ) { if ( ff_check_interrupt ( c -> interrupt_callback ) ) return AVERROR_EXIT ; av_log ( v -> parent , AV_LOG_WARNING , ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>segment<S2SV_blank>of<S2SV_blank>playlist<S2SV_blank>%d\\n"" , v -> index ) ; v -> cur_seq_no += 1 ; goto reload ; } just_opened = 1 ; } if ( v -> init_sec_buf_read_offset < v -> init_sec_data_len ) { int copy_size = FFMIN ( v -> init_sec_data_len - v -> init_sec_buf_read_offset , buf_size ) ; memcpy ( buf , v -> init_sec_buf , copy_size ) ; v -> init_sec_buf_read_offset += copy_size ; return copy_size ; } ret = read_from_url ( v , current_segment ( v ) , buf , buf_size , READ_NORMAL ) ; if ( ret > 0 ) { if ( just_opened && v -> is_id3_timestamped != 0 ) { intercept_id3 ( v , buf , buf_size , & ret ) ; } return ret ; } ff_format_io_close ( v -> parent , & v -> input ) ; v -> cur_seq_no ++ ; c -> cur_seq_no = v -> cur_seq_no ; goto restart ; }
","<S2SV_ModStart> ; int just_opened = 0 ; int reload_count <S2SV_ModStart> ; reload : reload_count ++ ; if ( reload_count > c -> max_reload ) return AVERROR_EOF ;
"
157,"CWE-125 static int jpeg_size ( unsigned char * data , unsigned int data_size , int * width , int * height ) { int i = 0 ; if ( i + 3 < data_size && data [ i ] == 0xFF && data [ i + 1 ] == 0xD8 && data [ i + 2 ] == 0xFF && data [ i + 3 ] == 0xE0 ) { i += 4 ; if ( i + 6 < data_size && data [ i + 2 ] == 'J' && data [ i + 3 ] == 'F' && data [ i + 4 ] == 'I' && data [ i + 5 ] == 'F' && data [ i + 6 ] == 0x00 ) { unsigned short block_length = data [ i ] * 256 + data [ i + 1 ] ; while ( i < data_size ) { i += block_length ; if ( ( i + 1 ) >= data_size ) return - 1 ; if ( data [ i ] != 0xFF ) return - 1 ; if ( data [ i + 1 ] == 0xC0 ) { * height = data [ i + 5 ] * 256 + data [ i + 6 ] ; * width = data [ i + 7 ] * 256 + data [ i + 8 ] ; return 0 ; } i += 2 ; <S2SV_StartBug> block_length = data [ i ] * 256 + data [ i + 1 ] ; <S2SV_EndBug> } } } return - 1 ; }
","<S2SV_ModStart> += 2 ; if ( i + 1 < data_size )
"
158,"CWE-119 TEE_Result syscall_cryp_derive_key ( unsigned long state , const struct utee_attribute * usr_params , unsigned long param_count , unsigned long derived_key ) { TEE_Result res = TEE_ERROR_NOT_SUPPORTED ; struct tee_ta_session * sess ; struct tee_obj * ko ; struct tee_obj * so ; struct tee_cryp_state * cs ; struct tee_cryp_obj_secret * sk ; const struct tee_cryp_obj_type_props * type_props ; TEE_Attribute * params = NULL ; struct user_ta_ctx * utc ; res = tee_ta_get_current_session ( & sess ) ; if ( res != TEE_SUCCESS ) return res ; utc = to_user_ta_ctx ( sess -> ctx ) ; res = tee_svc_cryp_get_state ( sess , tee_svc_uref_to_vaddr ( state ) , & cs ) ; if ( res != TEE_SUCCESS ) return res ; <S2SV_StartBug> params = malloc ( sizeof ( TEE_Attribute ) * param_count ) ; <S2SV_EndBug> if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY ; res = copy_in_attrs ( utc , usr_params , param_count , params ) ; if ( res != TEE_SUCCESS ) goto out ; res = tee_obj_get ( utc , cs -> key1 , & ko ) ; if ( res != TEE_SUCCESS ) goto out ; res = tee_obj_get ( utc , tee_svc_uref_to_vaddr ( derived_key ) , & so ) ; if ( res != TEE_SUCCESS ) goto out ; sk = so -> attr ; type_props = tee_svc_find_type_props ( so -> info . objectType ) ; if ( ! type_props ) { res = TEE_ERROR_NOT_SUPPORTED ; goto out ; } if ( cs -> algo == TEE_ALG_DH_DERIVE_SHARED_SECRET ) { size_t alloc_size ; struct bignum * pub ; struct bignum * ss ; if ( param_count != 1 || params [ 0 ] . attributeID != TEE_ATTR_DH_PUBLIC_VALUE ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } alloc_size = params [ 0 ] . content . ref . length * 8 ; pub = crypto_bignum_allocate ( alloc_size ) ; ss = crypto_bignum_allocate ( alloc_size ) ; if ( pub && ss ) { crypto_bignum_bin2bn ( params [ 0 ] . content . ref . buffer , params [ 0 ] . content . ref . length , pub ) ; res = crypto_acipher_dh_shared_secret ( ko -> attr , pub , ss ) ; if ( res == TEE_SUCCESS ) { sk -> key_size = crypto_bignum_num_bytes ( ss ) ; crypto_bignum_bn2bin ( ss , ( uint8_t * ) ( sk + 1 ) ) ; so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; } } else { res = TEE_ERROR_OUT_OF_MEMORY ; } crypto_bignum_free ( pub ) ; crypto_bignum_free ( ss ) ; } else if ( TEE_ALG_GET_MAIN_ALG ( cs -> algo ) == TEE_MAIN_ALGO_ECDH ) { size_t alloc_size ; struct ecc_public_key key_public ; uint8_t * pt_secret ; unsigned long pt_secret_len ; if ( param_count != 2 || params [ 0 ] . attributeID != TEE_ATTR_ECC_PUBLIC_VALUE_X || params [ 1 ] . attributeID != TEE_ATTR_ECC_PUBLIC_VALUE_Y ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } switch ( cs -> algo ) { case TEE_ALG_ECDH_P192 : alloc_size = 192 ; break ; case TEE_ALG_ECDH_P224 : alloc_size = 224 ; break ; case TEE_ALG_ECDH_P256 : alloc_size = 256 ; break ; case TEE_ALG_ECDH_P384 : alloc_size = 384 ; break ; case TEE_ALG_ECDH_P521 : alloc_size = 521 ; break ; default : res = TEE_ERROR_NOT_IMPLEMENTED ; goto out ; } res = crypto_acipher_alloc_ecc_public_key ( & key_public , alloc_size ) ; if ( res != TEE_SUCCESS ) goto out ; key_public . curve = ( ( struct ecc_keypair * ) ko -> attr ) -> curve ; crypto_bignum_bin2bn ( params [ 0 ] . content . ref . buffer , params [ 0 ] . content . ref . length , key_public . x ) ; crypto_bignum_bin2bn ( params [ 1 ] . content . ref . buffer , params [ 1 ] . content . ref . length , key_public . y ) ; pt_secret = ( uint8_t * ) ( sk + 1 ) ; pt_secret_len = sk -> alloc_size ; res = crypto_acipher_ecc_shared_secret ( ko -> attr , & key_public , pt_secret , & pt_secret_len ) ; if ( res == TEE_SUCCESS ) { sk -> key_size = pt_secret_len ; so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; } crypto_acipher_free_ecc_public_key ( & key_public ) ; } # if defined ( CFG_CRYPTO_HKDF ) else if ( TEE_ALG_GET_MAIN_ALG ( cs -> algo ) == TEE_MAIN_ALGO_HKDF ) { void * salt , * info ; size_t salt_len , info_len , okm_len ; uint32_t hash_id = TEE_ALG_GET_DIGEST_HASH ( cs -> algo ) ; struct tee_cryp_obj_secret * ik = ko -> attr ; const uint8_t * ikm = ( const uint8_t * ) ( ik + 1 ) ; res = get_hkdf_params ( params , param_count , & salt , & salt_len , & info , & info_len , & okm_len ) ; if ( res != TEE_SUCCESS ) goto out ; if ( okm_len > ik -> alloc_size ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } res = tee_cryp_hkdf ( hash_id , ikm , ik -> key_size , salt , salt_len , info , info_len , ( uint8_t * ) ( sk + 1 ) , okm_len ) ; if ( res == TEE_SUCCESS ) { sk -> key_size = okm_len ; so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; } } # endif # if defined ( CFG_CRYPTO_CONCAT_KDF ) else if ( TEE_ALG_GET_MAIN_ALG ( cs -> algo ) == TEE_MAIN_ALGO_CONCAT_KDF ) { void * info ; size_t info_len , derived_key_len ; uint32_t hash_id = TEE_ALG_GET_DIGEST_HASH ( cs -> algo ) ; struct tee_cryp_obj_secret * ss = ko -> attr ; const uint8_t * shared_secret = ( const uint8_t * ) ( ss + 1 ) ; res = get_concat_kdf_params ( params , param_count , & info , & info_len , & derived_key_len ) ; if ( res != TEE_SUCCESS ) goto out ; if ( derived_key_len > ss -> alloc_size ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } res = tee_cryp_concat_kdf ( hash_id , shared_secret , ss -> key_size , info , info_len , ( uint8_t * ) ( sk + 1 ) , derived_key_len ) ; if ( res == TEE_SUCCESS ) { sk -> key_size = derived_key_len ; so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; } } # endif # if defined ( CFG_CRYPTO_PBKDF2 ) else if ( TEE_ALG_GET_MAIN_ALG ( cs -> algo ) == TEE_MAIN_ALGO_PBKDF2 ) { void * salt ; size_t salt_len , iteration_count , derived_key_len ; uint32_t hash_id = TEE_ALG_GET_DIGEST_HASH ( cs -> algo ) ; struct tee_cryp_obj_secret * ss = ko -> attr ; const uint8_t * password = ( const uint8_t * ) ( ss + 1 ) ; res = get_pbkdf2_params ( params , param_count , & salt , & salt_len , & derived_key_len , & iteration_count ) ; if ( res != TEE_SUCCESS ) goto out ; if ( derived_key_len > ss -> alloc_size ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } res = tee_cryp_pbkdf2 ( hash_id , password , ss -> key_size , salt , salt_len , iteration_count , ( uint8_t * ) ( sk + 1 ) , derived_key_len ) ; if ( res == TEE_SUCCESS ) { sk -> key_size = derived_key_len ; so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; } } # endif else res = TEE_ERROR_NOT_SUPPORTED ; out : free ( params ) ; return res ; }
","<S2SV_ModStart> return res ; size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , param_count , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; <S2SV_ModStart> = malloc ( alloc_size <S2SV_ModEnd> ) ; if
"
159,"CWE-125 static void file_add_mapi_attrs ( File * file , MAPI_Attr * * attrs ) { int i ; for ( i = 0 ; attrs [ i ] ; i ++ ) { MAPI_Attr * a = attrs [ i ] ; if ( a -> num_values ) { switch ( a -> name ) { case MAPI_ATTACH_LONG_FILENAME : <S2SV_StartBug> if ( file -> name ) XFREE ( file -> name ) ; <S2SV_EndBug> file -> name = strdup ( ( char * ) a -> values [ 0 ] . data . buf ) ; break ; case MAPI_ATTACH_DATA_OBJ : <S2SV_StartBug> file -> len = a -> values [ 0 ] . len ; <S2SV_EndBug> if ( file -> data ) XFREE ( file -> data ) ; file -> data = CHECKED_XMALLOC ( unsigned char , file -> len ) ; memmove ( file -> data , a -> values [ 0 ] . data . buf , file -> len ) ; break ; case MAPI_ATTACH_MIME_TAG : <S2SV_StartBug> if ( file -> mime_type ) XFREE ( file -> mime_type ) ; <S2SV_EndBug> file -> mime_type = CHECKED_XMALLOC ( char , a -> values [ 0 ] . len ) ; memmove ( file -> mime_type , a -> values [ 0 ] . data . buf , a -> values [ 0 ] . len ) ; break ; case MAPI_ATTACH_CONTENT_ID : <S2SV_StartBug> if ( file -> content_id ) XFREE ( file -> content_id ) ; <S2SV_EndBug> file -> content_id = CHECKED_XMALLOC ( char , a -> values [ 0 ] . len ) ; memmove ( file -> content_id , a -> values [ 0 ] . data . buf , a -> values [ 0 ] . len ) ; break ; default : break ; } } } }
","<S2SV_ModStart> case MAPI_ATTACH_LONG_FILENAME : assert ( a -> type == szMAPI_STRING ) ; <S2SV_ModStart> case MAPI_ATTACH_DATA_OBJ : assert ( ( a -> type == szMAPI_BINARY ) || ( a -> type == szMAPI_OBJECT ) ) ; <S2SV_ModStart> case MAPI_ATTACH_MIME_TAG : assert ( a -> type == szMAPI_STRING ) ; <S2SV_ModStart> case MAPI_ATTACH_CONTENT_ID : assert ( a -> type == szMAPI_STRING ) ;
"
160,"CWE-125 static void gre_print_0 ( netdissect_options * ndo , const u_char * bp , u_int length ) { u_int len = length ; uint16_t flags , prot ; flags = EXTRACT_16BITS ( bp ) ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s]"" , bittok2str ( gre_flag_values , ""none"" , flags ) ) ) ; len -= 2 ; bp += 2 ; ND_TCHECK2 ( * bp , 2 ) ; if ( len < 2 ) goto trunc ; prot = EXTRACT_16BITS ( bp ) ; len -= 2 ; bp += 2 ; if ( ( flags & GRE_CP ) | ( flags & GRE_RP ) ) { ND_TCHECK2 ( * bp , 2 ) ; if ( len < 2 ) goto trunc ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>sum<S2SV_blank>0x%x"" , EXTRACT_16BITS ( bp ) ) ) ; bp += 2 ; len -= 2 ; ND_TCHECK2 ( * bp , 2 ) ; if ( len < 2 ) goto trunc ; ND_PRINT ( ( ndo , "",<S2SV_blank>off<S2SV_blank>0x%x"" , EXTRACT_16BITS ( bp ) ) ) ; bp += 2 ; len -= 2 ; } if ( flags & GRE_KP ) { ND_TCHECK2 ( * bp , 4 ) ; if ( len < 4 ) goto trunc ; ND_PRINT ( ( ndo , "",<S2SV_blank>key=0x%x"" , EXTRACT_32BITS ( bp ) ) ) ; bp += 4 ; len -= 4 ; } if ( flags & GRE_SP ) { ND_TCHECK2 ( * bp , 4 ) ; if ( len < 4 ) goto trunc ; ND_PRINT ( ( ndo , "",<S2SV_blank>seq<S2SV_blank>%u"" , EXTRACT_32BITS ( bp ) ) ) ; bp += 4 ; len -= 4 ; } if ( flags & GRE_RP ) { for ( ; ; ) { uint16_t af ; uint8_t sreoff ; uint8_t srelen ; ND_TCHECK2 ( * bp , 4 ) ; if ( len < 4 ) goto trunc ; af = EXTRACT_16BITS ( bp ) ; sreoff = * ( bp + 2 ) ; srelen = * ( bp + 3 ) ; bp += 4 ; len -= 4 ; if ( af == 0 && srelen == 0 ) break ; if ( ! gre_sre_print ( ndo , af , sreoff , srelen , bp , len ) ) goto trunc ; if ( len < srelen ) goto trunc ; bp += srelen ; len -= srelen ; } } if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>proto<S2SV_blank>%s<S2SV_blank>(0x%04x)"" , tok2str ( ethertype_values , ""unknown"" , prot ) , prot ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>length<S2SV_blank>%u"" , length ) ) ; if ( ndo -> ndo_vflag < 1 ) ND_PRINT ( ( ndo , "":<S2SV_blank>"" ) ) ; else ND_PRINT ( ( ndo , ""\\n\\t"" ) ) ; switch ( prot ) { case ETHERTYPE_IP : ip_print ( ndo , bp , len ) ; break ; case ETHERTYPE_IPV6 : ip6_print ( ndo , bp , len ) ; break ; case ETHERTYPE_MPLS : mpls_print ( ndo , bp , len ) ; break ; case ETHERTYPE_IPX : ipx_print ( ndo , bp , len ) ; break ; case ETHERTYPE_ATALK : atalk_print ( ndo , bp , len ) ; break ; case ETHERTYPE_GRE_ISO : <S2SV_StartBug> isoclns_print ( ndo , bp , len , ndo -> ndo_snapend - bp ) ; <S2SV_EndBug> break ; case ETHERTYPE_TEB : ether_print ( ndo , bp , len , ndo -> ndo_snapend - bp , NULL , NULL ) ; break ; default : ND_PRINT ( ( ndo , ""gre-proto-0x%x"" , prot ) ) ; } return ; trunc : ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; }
","<S2SV_ModStart> bp , len ) ; break ; case ETHERTYPE_TEB : ether_print ( ndo , bp , len <S2SV_ModStart> ndo_snapend - bp <S2SV_ModEnd> , NULL ,
"
161,"CWE-119 int X509_cmp_time ( const ASN1_TIME * ctm , time_t * cmp_time ) { char * str ; ASN1_TIME atm ; long offset ; char buff1 [ 24 ] , buff2 [ 24 ] , * p ; <S2SV_StartBug> int i , j ; <S2SV_EndBug> p = buff1 ; <S2SV_StartBug> i = ctm -> length ; <S2SV_EndBug> str = ( char * ) ctm -> data ; if ( ctm -> type == V_ASN1_UTCTIME ) { <S2SV_StartBug> if ( ( i < 11 ) || ( i > 17 ) ) <S2SV_EndBug> return 0 ; memcpy ( p , str , 10 ) ; p += 10 ; str += 10 ; <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( i < 13 ) <S2SV_EndBug> return 0 ; memcpy ( p , str , 12 ) ; p += 12 ; str += 12 ; <S2SV_StartBug> } <S2SV_EndBug> if ( ( * str == 'Z' ) || ( * str == '-' ) || ( * str == '+' ) ) { * ( p ++ ) = '0' ; * ( p ++ ) = '0' ; } else { <S2SV_StartBug> * ( p ++ ) = * ( str ++ ) ; <S2SV_EndBug> * ( p ++ ) = * ( str ++ ) ; if ( * str == '.' ) { str ++ ; <S2SV_StartBug> while ( ( * str >= '0' ) && ( * str <= '9' ) ) <S2SV_EndBug> str ++ ; } } * ( p ++ ) = 'Z' ; * ( p ++ ) = '\\0' ; <S2SV_StartBug> if ( * str == 'Z' ) <S2SV_EndBug> offset = 0 ; <S2SV_StartBug> else { <S2SV_EndBug> <S2SV_StartBug> if ( ( * str != '+' ) && ( * str != '-' ) ) <S2SV_EndBug> return 0 ; offset = ( ( str [ 1 ] - '0' ) * 10 + ( str [ 2 ] - '0' ) ) * 60 ; offset += ( str [ 3 ] - '0' ) * 10 + ( str [ 4 ] - '0' ) ; if ( * str == '-' ) offset = - offset ; } atm . type = ctm -> type ; atm . flags = 0 ; atm . length = sizeof ( buff2 ) ; atm . data = ( unsigned char * ) buff2 ; if ( X509_time_adj ( & atm , offset * 60 , cmp_time ) == NULL ) return 0 ; if ( ctm -> type == V_ASN1_UTCTIME ) { i = ( buff1 [ 0 ] - '0' ) * 10 + ( buff1 [ 1 ] - '0' ) ; if ( i < 50 ) i += 100 ; j = ( buff2 [ 0 ] - '0' ) * 10 + ( buff2 [ 1 ] - '0' ) ; if ( j < 50 ) j += 100 ; if ( i < j ) return - 1 ; if ( i > j ) return 1 ; } i = strcmp ( buff1 , buff2 ) ; if ( i == 0 ) return - 1 ; else return i ; }
","<S2SV_ModStart> i , j , remaining <S2SV_ModStart> = buff1 ; remaining <S2SV_ModEnd> = ctm -> <S2SV_ModStart> V_ASN1_UTCTIME ) { int min_length = sizeof ( ""YYMMDDHHMMZ"" ) - 1 ; int max_length = sizeof ( ""YYMMDDHHMMSS+hhmm"" ) - 1 ; if ( remaining < min_length || remaining > max_length <S2SV_ModEnd> ) return 0 <S2SV_ModStart> += 10 ; remaining -= 10 ; <S2SV_ModStart> } else { int min_length = sizeof ( ""YYYYMMDDHHMMZ"" ) - 1 ; int max_length = sizeof ( ""YYYYMMDDHHMMSS.fff+hhmm"" ) - 1 ; if ( remaining < min_length || remaining > max_length <S2SV_ModEnd> ) return 0 <S2SV_ModStart> += 12 ; remaining -= 12 ; <S2SV_ModStart> } else { if ( remaining < 2 ) return 0 ; * ( p ++ ) = * ( str ++ ) ; * ( p ++ ) = * ( str ++ ) ; remaining -= 2 ; if ( remaining && <S2SV_ModEnd> * str == <S2SV_ModStart> str ++ ; remaining -- ; for ( i = 0 ; i < 3 && remaining ; i ++ , str ++ , remaining -- ) { if ( * str < '0' || * str > '9' ) break ; } <S2SV_ModEnd> } } * <S2SV_ModStart> ; if ( ! remaining ) return 0 ; if ( <S2SV_ModStart> == 'Z' ) { if ( remaining != 1 ) return 0 ; <S2SV_ModStart> = 0 ; } <S2SV_ModStart> != '-' ) ) return 0 ; if ( remaining != 5 ) return 0 ; if ( str [ 1 ] < '0' || str [ 1 ] > '9' || str [ 2 ] < '0' || str [ 2 ] > '9' || str [ 3 ] < '0' || str [ 3 ] > '9' || str [ 4 ] < '0' || str [ 4 ] > '9'
"
162,"CWE-362 int hci_req_sync ( struct hci_dev * hdev , int ( * req ) ( struct hci_request * req , unsigned long opt ) , unsigned long opt , u32 timeout , u8 * hci_status ) { int ret ; <S2SV_StartBug> if ( ! test_bit ( HCI_UP , & hdev -> flags ) ) <S2SV_EndBug> <S2SV_StartBug> return - ENETDOWN ; <S2SV_EndBug> hci_req_sync_lock ( hdev ) ; ret = __hci_req_sync ( hdev , req , opt , timeout , hci_status ) ; <S2SV_StartBug> hci_req_sync_unlock ( hdev ) ; <S2SV_EndBug> return ret ; }
","<S2SV_ModStart> int ret ; hci_req_sync_lock ( hdev ) ; if ( <S2SV_ModEnd> test_bit ( HCI_UP <S2SV_ModStart> flags ) ) <S2SV_ModEnd> ret = __hci_req_sync <S2SV_ModStart> hci_status ) ; else ret = - ENETDOWN ;
"
163,"CWE-399 SYSCALL_DEFINE1 ( inotify_init1 , int , flags ) { struct fsnotify_group * group ; struct user_struct * user ; int ret ; BUILD_BUG_ON ( IN_CLOEXEC != O_CLOEXEC ) ; BUILD_BUG_ON ( IN_NONBLOCK != O_NONBLOCK ) ; if ( flags & ~ ( IN_CLOEXEC | IN_NONBLOCK ) ) return - EINVAL ; user = get_current_user ( ) ; if ( unlikely ( atomic_read ( & user -> inotify_devs ) >= inotify_max_user_instances ) ) { ret = - EMFILE ; goto out_free_uid ; } group = inotify_new_group ( user , inotify_max_queued_events ) ; if ( IS_ERR ( group ) ) { ret = PTR_ERR ( group ) ; goto out_free_uid ; } atomic_inc ( & user -> inotify_devs ) ; ret = anon_inode_getfd ( ""inotify"" , & inotify_fops , group , O_RDONLY | flags ) ; if ( ret >= 0 ) return ret ; <S2SV_StartBug> atomic_dec ( & user -> inotify_devs ) ; <S2SV_EndBug> out_free_uid : free_uid ( user ) ; return ret ; }
","<S2SV_ModStart> return ret ; fsnotify_put_group ( group ) ;
"
164,"CWE-369 static void change_port_settings ( struct tty_struct * tty , struct edgeport_port * edge_port , struct ktermios * old_termios ) { struct device * dev = & edge_port -> port -> dev ; struct ump_uart_config * config ; int baud ; unsigned cflag ; int status ; int port_number = edge_port -> port -> port_number ; config = kmalloc ( sizeof ( * config ) , GFP_KERNEL ) ; if ( ! config ) { tty -> termios = * old_termios ; return ; } cflag = tty -> termios . c_cflag ; config -> wFlags = 0 ; config -> wFlags |= UMP_MASK_UART_FLAGS_RECEIVE_MS_INT ; config -> wFlags |= UMP_MASK_UART_FLAGS_AUTO_START_ON_ERR ; config -> bUartMode = ( __u8 ) ( edge_port -> bUartMode ) ; switch ( cflag & CSIZE ) { case CS5 : config -> bDataBits = UMP_UART_CHAR5BITS ; dev_dbg ( dev , ""%s<S2SV_blank>-<S2SV_blank>data<S2SV_blank>bits<S2SV_blank>=<S2SV_blank>5\\n"" , __func__ ) ; break ; case CS6 : config -> bDataBits = UMP_UART_CHAR6BITS ; dev_dbg ( dev , ""%s<S2SV_blank>-<S2SV_blank>data<S2SV_blank>bits<S2SV_blank>=<S2SV_blank>6\\n"" , __func__ ) ; break ; case CS7 : config -> bDataBits = UMP_UART_CHAR7BITS ; dev_dbg ( dev , ""%s<S2SV_blank>-<S2SV_blank>data<S2SV_blank>bits<S2SV_blank>=<S2SV_blank>7\\n"" , __func__ ) ; break ; default : case CS8 : config -> bDataBits = UMP_UART_CHAR8BITS ; dev_dbg ( dev , ""%s<S2SV_blank>-<S2SV_blank>data<S2SV_blank>bits<S2SV_blank>=<S2SV_blank>8\\n"" , __func__ ) ; break ; } if ( cflag & PARENB ) { if ( cflag & PARODD ) { config -> wFlags |= UMP_MASK_UART_FLAGS_PARITY ; config -> bParity = UMP_UART_ODDPARITY ; dev_dbg ( dev , ""%s<S2SV_blank>-<S2SV_blank>parity<S2SV_blank>=<S2SV_blank>odd\\n"" , __func__ ) ; } else { config -> wFlags |= UMP_MASK_UART_FLAGS_PARITY ; config -> bParity = UMP_UART_EVENPARITY ; dev_dbg ( dev , ""%s<S2SV_blank>-<S2SV_blank>parity<S2SV_blank>=<S2SV_blank>even\\n"" , __func__ ) ; } } else { config -> bParity = UMP_UART_NOPARITY ; dev_dbg ( dev , ""%s<S2SV_blank>-<S2SV_blank>parity<S2SV_blank>=<S2SV_blank>none\\n"" , __func__ ) ; } if ( cflag & CSTOPB ) { config -> bStopBits = UMP_UART_STOPBIT2 ; dev_dbg ( dev , ""%s<S2SV_blank>-<S2SV_blank>stop<S2SV_blank>bits<S2SV_blank>=<S2SV_blank>2\\n"" , __func__ ) ; } else { config -> bStopBits = UMP_UART_STOPBIT1 ; dev_dbg ( dev , ""%s<S2SV_blank>-<S2SV_blank>stop<S2SV_blank>bits<S2SV_blank>=<S2SV_blank>1\\n"" , __func__ ) ; } if ( cflag & CRTSCTS ) { config -> wFlags |= UMP_MASK_UART_FLAGS_OUT_X_CTS_FLOW ; config -> wFlags |= UMP_MASK_UART_FLAGS_RTS_FLOW ; dev_dbg ( dev , ""%s<S2SV_blank>-<S2SV_blank>RTS/CTS<S2SV_blank>is<S2SV_blank>enabled\\n"" , __func__ ) ; } else { dev_dbg ( dev , ""%s<S2SV_blank>-<S2SV_blank>RTS/CTS<S2SV_blank>is<S2SV_blank>disabled\\n"" , __func__ ) ; restart_read ( edge_port ) ; } config -> cXon = START_CHAR ( tty ) ; config -> cXoff = STOP_CHAR ( tty ) ; if ( I_IXOFF ( tty ) ) { config -> wFlags |= UMP_MASK_UART_FLAGS_IN_X ; dev_dbg ( dev , ""%s<S2SV_blank>-<S2SV_blank>INBOUND<S2SV_blank>XON/XOFF<S2SV_blank>is<S2SV_blank>enabled,<S2SV_blank>XON<S2SV_blank>=<S2SV_blank>%2x,<S2SV_blank>XOFF<S2SV_blank>=<S2SV_blank>%2x\\n"" , __func__ , config -> cXon , config -> cXoff ) ; } else dev_dbg ( dev , ""%s<S2SV_blank>-<S2SV_blank>INBOUND<S2SV_blank>XON/XOFF<S2SV_blank>is<S2SV_blank>disabled\\n"" , __func__ ) ; if ( I_IXON ( tty ) ) { config -> wFlags |= UMP_MASK_UART_FLAGS_OUT_X ; dev_dbg ( dev , ""%s<S2SV_blank>-<S2SV_blank>OUTBOUND<S2SV_blank>XON/XOFF<S2SV_blank>is<S2SV_blank>enabled,<S2SV_blank>XON<S2SV_blank>=<S2SV_blank>%2x,<S2SV_blank>XOFF<S2SV_blank>=<S2SV_blank>%2x\\n"" , __func__ , config -> cXon , config -> cXoff ) ; } else dev_dbg ( dev , ""%s<S2SV_blank>-<S2SV_blank>OUTBOUND<S2SV_blank>XON/XOFF<S2SV_blank>is<S2SV_blank>disabled\\n"" , __func__ ) ; tty -> termios . c_cflag &= ~ CMSPAR ; baud = tty_get_baud_rate ( tty ) ; if ( ! baud ) { baud = 9600 ; <S2SV_StartBug> } else <S2SV_EndBug> <S2SV_StartBug> tty_encode_baud_rate ( tty , baud , baud ) ; <S2SV_EndBug> edge_port -> baud_rate = baud ; config -> wBaudRate = ( __u16 ) ( ( 461550L + baud / 2 ) / baud ) ; dev_dbg ( dev , ""%s<S2SV_blank>-<S2SV_blank>baud<S2SV_blank>rate<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>wBaudRate<S2SV_blank>=<S2SV_blank>%d\\n"" , __func__ , baud , config -> wBaudRate ) ; dev_dbg ( dev , ""wBaudRate:<S2SV_blank><S2SV_blank><S2SV_blank>%d\\n"" , ( int ) ( 461550L / config -> wBaudRate ) ) ; dev_dbg ( dev , ""wFlags:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%x\\n"" , config -> wFlags ) ; dev_dbg ( dev , ""bDataBits:<S2SV_blank><S2SV_blank><S2SV_blank>%d\\n"" , config -> bDataBits ) ; dev_dbg ( dev , ""bParity:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d\\n"" , config -> bParity ) ; dev_dbg ( dev , ""bStopBits:<S2SV_blank><S2SV_blank><S2SV_blank>%d\\n"" , config -> bStopBits ) ; dev_dbg ( dev , ""cXon:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d\\n"" , config -> cXon ) ; dev_dbg ( dev , ""cXoff:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d\\n"" , config -> cXoff ) ; dev_dbg ( dev , ""bUartMode:<S2SV_blank><S2SV_blank><S2SV_blank>%d\\n"" , config -> bUartMode ) ; cpu_to_be16s ( & config -> wFlags ) ; cpu_to_be16s ( & config -> wBaudRate ) ; status = send_cmd ( edge_port -> port -> serial -> dev , UMPC_SET_CONFIG , ( __u8 ) ( UMPM_UART1_PORT + port_number ) , 0 , ( __u8 * ) config , sizeof ( * config ) ) ; if ( status ) dev_dbg ( dev , ""%s<S2SV_blank>-<S2SV_blank>error<S2SV_blank>%d<S2SV_blank>when<S2SV_blank>trying<S2SV_blank>to<S2SV_blank>write<S2SV_blank>config<S2SV_blank>to<S2SV_blank>device\\n"" , __func__ , status ) ; kfree ( config ) ; }
","<S2SV_ModStart> ; } else { baud = min ( baud , 461550 ) ; <S2SV_ModStart> baud ) ; }
"
165,"CWE-119 static vpx_codec_err_t ctrl_get_last_ref_updates ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctrl_id , va_list args ) { <S2SV_EndBug> int * const update_info = va_arg ( args , int * ) ; <S2SV_StartBug> if ( update_info ) { <S2SV_EndBug> <S2SV_StartBug> if ( ctx -> pbi ) <S2SV_EndBug> <S2SV_StartBug> * update_info = ctx -> pbi -> refresh_frame_flags ; <S2SV_EndBug> else return VPX_CODEC_ERROR ; return VPX_CODEC_OK ; } else { <S2SV_StartBug> return VPX_CODEC_INVALID_PARAM ; <S2SV_EndBug> } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> * ctx , <S2SV_ModEnd> va_list args ) <S2SV_ModStart> ; if ( ctx -> frame_parallel_decode ) { set_error_detail ( ctx , ""Not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>frame<S2SV_blank>parallel<S2SV_blank>decode"" ) ; return VPX_CODEC_INCAPABLE ; } if ( <S2SV_ModStart> ( ctx -> frame_workers ) { VPxWorker * const worker = ctx -> frame_workers ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; <S2SV_ModEnd> * update_info = <S2SV_ModStart> * update_info = frame_worker_data <S2SV_ModEnd> -> pbi -> <S2SV_ModStart> pbi -> refresh_frame_flags <S2SV_ModEnd> ; return VPX_CODEC_OK <S2SV_ModStart> else { return VPX_CODEC_ERROR <S2SV_ModEnd> ; } } <S2SV_ModStart> ; } } return VPX_CODEC_INVALID_PARAM ; }
"
166,"CWE-125 static struct sk_buff * ipv6_gso_segment ( struct sk_buff * skb , netdev_features_t features ) { struct sk_buff * segs = ERR_PTR ( - EINVAL ) ; struct ipv6hdr * ipv6h ; const struct net_offload * ops ; int proto ; struct frag_hdr * fptr ; unsigned int unfrag_ip6hlen ; unsigned int payload_len ; u8 * prevhdr ; int offset = 0 ; bool encap , udpfrag ; int nhoff ; bool gso_partial ; skb_reset_network_header ( skb ) ; nhoff = skb_network_header ( skb ) - skb_mac_header ( skb ) ; if ( unlikely ( ! pskb_may_pull ( skb , sizeof ( * ipv6h ) ) ) ) goto out ; encap = SKB_GSO_CB ( skb ) -> encap_level > 0 ; if ( encap ) features &= skb -> dev -> hw_enc_features ; SKB_GSO_CB ( skb ) -> encap_level += sizeof ( * ipv6h ) ; ipv6h = ipv6_hdr ( skb ) ; __skb_pull ( skb , sizeof ( * ipv6h ) ) ; segs = ERR_PTR ( - EPROTONOSUPPORT ) ; proto = ipv6_gso_pull_exthdrs ( skb , ipv6h -> nexthdr ) ; if ( skb -> encapsulation && skb_shinfo ( skb ) -> gso_type & ( SKB_GSO_IPXIP4 | SKB_GSO_IPXIP6 ) ) udpfrag = proto == IPPROTO_UDP && encap ; else udpfrag = proto == IPPROTO_UDP && ! skb -> encapsulation ; ops = rcu_dereference ( inet6_offloads [ proto ] ) ; if ( likely ( ops && ops -> callbacks . gso_segment ) ) { skb_reset_transport_header ( skb ) ; segs = ops -> callbacks . gso_segment ( skb , features ) ; } if ( IS_ERR_OR_NULL ( segs ) ) goto out ; gso_partial = ! ! ( skb_shinfo ( segs ) -> gso_type & SKB_GSO_PARTIAL ) ; for ( skb = segs ; skb ; skb = skb -> next ) { ipv6h = ( struct ipv6hdr * ) ( skb_mac_header ( skb ) + nhoff ) ; if ( gso_partial ) payload_len = skb_shinfo ( skb ) -> gso_size + SKB_GSO_CB ( skb ) -> data_offset + skb -> head - ( unsigned char * ) ( ipv6h + 1 ) ; else payload_len = skb -> len - nhoff - sizeof ( * ipv6h ) ; ipv6h -> payload_len = htons ( payload_len ) ; skb -> network_header = ( u8 * ) ipv6h - skb -> head ; if ( udpfrag ) { unfrag_ip6hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; <S2SV_StartBug> fptr = ( struct frag_hdr * ) ( ( u8 * ) ipv6h + unfrag_ip6hlen ) ; <S2SV_EndBug> fptr -> frag_off = htons ( offset ) ; if ( skb -> next ) fptr -> frag_off |= htons ( IP6_MF ) ; offset += ( ntohs ( ipv6h -> payload_len ) - sizeof ( struct frag_hdr ) ) ; } if ( encap ) skb_reset_inner_headers ( skb ) ; } out : return segs ; }
","<S2SV_ModStart> prevhdr ) ; if ( unfrag_ip6hlen < 0 ) return ERR_PTR ( unfrag_ip6hlen ) ;
"
167,"CWE-59 int rpmPackageFilesInstall ( rpmts ts , rpmte te , rpmfiles files , rpmpsm psm , char * * failedFile ) { FD_t payload = rpmtePayload ( te ) ; rpmfi fi = rpmfiNewArchiveReader ( payload , files , RPMFI_ITER_READ_ARCHIVE ) ; rpmfs fs = rpmteGetFileStates ( te ) ; rpmPlugins plugins = rpmtsPlugins ( ts ) ; struct stat sb ; int saveerrno = errno ; int rc = 0 ; int nodigest = ( rpmtsFlags ( ts ) & RPMTRANS_FLAG_NOFILEDIGEST ) ? 1 : 0 ; int nofcaps = ( rpmtsFlags ( ts ) & RPMTRANS_FLAG_NOCAPS ) ? 1 : 0 ; int firsthardlink = - 1 ; int skip ; rpmFileAction action ; char * tid = NULL ; const char * suffix ; char * fpath = NULL ; if ( fi == NULL ) { rc = RPMERR_BAD_MAGIC ; goto exit ; } rasprintf ( & tid , "";%08x"" , ( unsigned ) rpmtsGetTid ( ts ) ) ; rc = fsmMkdirs ( files , fs , plugins ) ; while ( ! rc ) { rc = rpmfiNext ( fi ) ; if ( rc < 0 ) { if ( rc == RPMERR_ITER_END ) rc = 0 ; break ; } action = rpmfsGetAction ( fs , rpmfiFX ( fi ) ) ; skip = XFA_SKIPPING ( action ) ; suffix = S_ISDIR ( rpmfiFMode ( fi ) ) ? NULL : tid ; if ( action != FA_TOUCH ) { fpath = fsmFsPath ( fi , suffix ) ; } else { fpath = fsmFsPath ( fi , """" ) ; } rc = rpmfiStat ( fi , 1 , & sb ) ; fsmDebug ( fpath , action , & sb ) ; if ( rc ) break ; rc = rpmpluginsCallFsmFilePre ( plugins , fi , fpath , sb . st_mode , action ) ; if ( rc ) { skip = 1 ; } else { setFileState ( fs , rpmfiFX ( fi ) ) ; } if ( ! skip ) { int setmeta = 1 ; if ( ! suffix ) { rc = fsmBackup ( fi , action ) ; } if ( ! suffix ) { rc = fsmVerify ( fpath , fi ) ; } else { rc = ( action == FA_TOUCH ) ? 0 : RPMERR_ENOENT ; } if ( S_ISREG ( sb . st_mode ) ) { if ( rc == RPMERR_ENOENT ) { rc = fsmMkfile ( fi , fpath , files , psm , nodigest , & setmeta , & firsthardlink ) ; } } else if ( S_ISDIR ( sb . st_mode ) ) { if ( rc == RPMERR_ENOENT ) { mode_t mode = sb . st_mode ; mode &= ~ 07777 ; mode |= 00700 ; rc = fsmMkdir ( fpath , mode ) ; } } else if ( S_ISLNK ( sb . st_mode ) ) { if ( rc == RPMERR_ENOENT ) { rc = fsmSymlink ( rpmfiFLink ( fi ) , fpath ) ; } } else if ( S_ISFIFO ( sb . st_mode ) ) { if ( rc == RPMERR_ENOENT ) { rc = fsmMkfifo ( fpath , 0000 ) ; } } else if ( S_ISCHR ( sb . st_mode ) || S_ISBLK ( sb . st_mode ) || S_ISSOCK ( sb . st_mode ) ) { if ( rc == RPMERR_ENOENT ) { rc = fsmMknod ( fpath , sb . st_mode , sb . st_rdev ) ; } } else { if ( ! IS_DEV_LOG ( fpath ) ) rc = RPMERR_UNKNOWN_FILETYPE ; } if ( ! rc && setmeta ) { rc = fsmSetmeta ( fpath , fi , plugins , action , & sb , nofcaps ) ; } } else if ( firsthardlink >= 0 && rpmfiArchiveHasContent ( fi ) ) { char * fn = rpmfilesFN ( files , firsthardlink ) ; <S2SV_StartBug> rc = expandRegular ( fi , fn , psm , nodigest , 0 ) ; <S2SV_EndBug> firsthardlink = - 1 ; free ( fn ) ; } if ( rc ) { if ( ! skip ) { if ( suffix && ( action != FA_TOUCH ) ) { ( void ) fsmRemove ( fpath , sb . st_mode ) ; } errno = saveerrno ; } } else { rpmpsmNotify ( psm , RPMCALLBACK_INST_PROGRESS , rpmfiArchiveTell ( fi ) ) ; if ( ! skip ) { if ( suffix ) rc = fsmBackup ( fi , action ) ; if ( ! rc ) rc = fsmCommit ( & fpath , fi , action , suffix ) ; } } if ( rc ) * failedFile = xstrdup ( fpath ) ; rpmpluginsCallFsmFilePost ( plugins , fi , fpath , sb . st_mode , action , rc ) ; fpath = _free ( fpath ) ; } rpmswAdd ( rpmtsOp ( ts , RPMTS_OP_UNCOMPRESS ) , fdOp ( payload , FDSTAT_READ ) ) ; rpmswAdd ( rpmtsOp ( ts , RPMTS_OP_DIGEST ) , fdOp ( payload , FDSTAT_DIGEST ) ) ; exit : rpmfiArchiveClose ( fi ) ; rpmfiFree ( fi ) ; Fclose ( payload ) ; free ( tid ) ; free ( fpath ) ; return rc ; }
","<S2SV_ModStart> , psm , 0 ,
"
168,"CWE-284 int vfs_open ( const struct path * path , struct file * file , const struct cred * cred ) { <S2SV_StartBug> struct dentry * dentry = path -> dentry ; <S2SV_EndBug> <S2SV_StartBug> struct inode * inode = dentry -> d_inode ; <S2SV_EndBug> file -> f_path = * path ; if ( dentry -> d_flags & DCACHE_OP_SELECT_INODE ) { inode = dentry -> d_op -> d_select_inode ( dentry , file -> f_flags ) ; if ( IS_ERR ( inode ) ) return PTR_ERR ( inode ) ; <S2SV_StartBug> } <S2SV_EndBug> return do_dentry_open ( file , inode , NULL , cred ) ; }
","<S2SV_ModStart> ) { struct <S2SV_ModEnd> inode * inode <S2SV_ModStart> * inode = vfs_select_inode ( path -> <S2SV_ModEnd> dentry , file <S2SV_ModStart> inode ) ; file -> f_path = * path ; <S2SV_ModEnd> return do_dentry_open (
"
169,"CWE-17 static void parseFirstLine ( Webs * wp ) { char * op , * protoVer , * url , * host , * query , * path , * port , * ext , * buf ; int listenPort ; assert ( wp ) ; assert ( websValid ( wp ) ) ; op = getToken ( wp , 0 ) ; if ( op == NULL || * op == '\\0' ) { websError ( wp , HTTP_CODE_NOT_FOUND | WEBS_CLOSE , ""Bad<S2SV_blank>HTTP<S2SV_blank>request"" ) ; return ; } wp -> method = supper ( sclone ( op ) ) ; url = getToken ( wp , 0 ) ; if ( url == NULL || * url == '\\0' ) { websError ( wp , HTTP_CODE_BAD_REQUEST | WEBS_CLOSE , ""Bad<S2SV_blank>HTTP<S2SV_blank>request"" ) ; return ; } if ( strlen ( url ) > ME_GOAHEAD_LIMIT_URI ) { websError ( wp , HTTP_CODE_REQUEST_URL_TOO_LARGE | WEBS_CLOSE , ""URI<S2SV_blank>too<S2SV_blank>big"" ) ; return ; } protoVer = getToken ( wp , ""\\r\\n"" ) ; if ( websGetLogLevel ( ) == 2 ) { trace ( 2 , ""%s<S2SV_blank>%s<S2SV_blank>%s"" , wp -> method , url , protoVer ) ; } host = path = port = query = ext = NULL ; if ( websUrlParse ( url , & buf , NULL , & host , & port , & path , & ext , NULL , & query ) < 0 ) { error ( ""Cannot<S2SV_blank>parse<S2SV_blank>URL:<S2SV_blank>%s"" , url ) ; websError ( wp , HTTP_CODE_BAD_REQUEST | WEBS_CLOSE | WEBS_NOLOG , ""Bad<S2SV_blank>URL"" ) ; return ; } <S2SV_StartBug> if ( ( wp -> path = websNormalizeUriPath ( path ) ) == 0 ) { <S2SV_EndBug> error ( ""Cannot<S2SV_blank>normalize<S2SV_blank>URL:<S2SV_blank>%s"" , url ) ; websError ( wp , HTTP_CODE_BAD_REQUEST | WEBS_CLOSE | WEBS_NOLOG , ""Bad<S2SV_blank>URL"" ) ; wfree ( buf ) ; return ; } wp -> url = sclone ( url ) ; if ( ext ) { wp -> ext = sclone ( slower ( ext ) ) ; } wp -> filename = sfmt ( ""%s%s"" , websGetDocuments ( ) , wp -> path ) ; wp -> query = sclone ( query ) ; wp -> host = sclone ( host ) ; wp -> protocol = wp -> flags & WEBS_SECURE ? ""https"" : ""http"" ; if ( smatch ( protoVer , ""HTTP/1.1"" ) ) { wp -> flags |= WEBS_KEEP_ALIVE | WEBS_HTTP11 ; } else if ( smatch ( protoVer , ""HTTP/1.0"" ) ) { wp -> flags &= ~ ( WEBS_HTTP11 ) ; } else { protoVer = sclone ( ""HTTP/1.1"" ) ; websError ( wp , WEBS_CLOSE | HTTP_CODE_NOT_ACCEPTABLE , ""Unsupported<S2SV_blank>HTTP<S2SV_blank>protocol"" ) ; } wp -> protoVersion = sclone ( protoVer ) ; if ( ( listenPort = socketGetPort ( wp -> listenSid ) ) >= 0 ) { wp -> port = listenPort ; } else { wp -> port = atoi ( port ) ; } wfree ( buf ) ; }
","<S2SV_ModStart> -> path = websValidateUriPath <S2SV_ModEnd> ( path )
"
170,"CWE-119 static int airspy_probe ( struct usb_interface * intf , const struct usb_device_id * id ) { struct airspy * s ; int ret ; u8 u8tmp , buf [ BUF_SIZE ] ; s = kzalloc ( sizeof ( struct airspy ) , GFP_KERNEL ) ; if ( s == NULL ) { dev_err ( & intf -> dev , ""Could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>state\\n"" ) ; return - ENOMEM ; } mutex_init ( & s -> v4l2_lock ) ; mutex_init ( & s -> vb_queue_lock ) ; spin_lock_init ( & s -> queued_bufs_lock ) ; INIT_LIST_HEAD ( & s -> queued_bufs ) ; s -> dev = & intf -> dev ; s -> udev = interface_to_usbdev ( intf ) ; s -> f_adc = bands [ 0 ] . rangelow ; s -> f_rf = bands_rf [ 0 ] . rangelow ; s -> pixelformat = formats [ 0 ] . pixelformat ; s -> buffersize = formats [ 0 ] . buffersize ; ret = airspy_ctrl_msg ( s , CMD_BOARD_ID_READ , 0 , 0 , & u8tmp , 1 ) ; if ( ret == 0 ) ret = airspy_ctrl_msg ( s , CMD_VERSION_STRING_READ , 0 , 0 , buf , BUF_SIZE ) ; if ( ret ) { dev_err ( s -> dev , ""Could<S2SV_blank>not<S2SV_blank>detect<S2SV_blank>board\\n"" ) ; goto err_free_mem ; } buf [ BUF_SIZE - 1 ] = '\\0' ; dev_info ( s -> dev , ""Board<S2SV_blank>ID:<S2SV_blank>%02x\\n"" , u8tmp ) ; dev_info ( s -> dev , ""Firmware<S2SV_blank>version:<S2SV_blank>%s\\n"" , buf ) ; s -> vb_queue . type = V4L2_BUF_TYPE_SDR_CAPTURE ; s -> vb_queue . io_modes = VB2_MMAP | VB2_USERPTR | VB2_READ ; s -> vb_queue . drv_priv = s ; s -> vb_queue . buf_struct_size = sizeof ( struct airspy_frame_buf ) ; s -> vb_queue . ops = & airspy_vb2_ops ; s -> vb_queue . mem_ops = & vb2_vmalloc_memops ; s -> vb_queue . timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC ; ret = vb2_queue_init ( & s -> vb_queue ) ; if ( ret ) { dev_err ( s -> dev , ""Could<S2SV_blank>not<S2SV_blank>initialize<S2SV_blank>vb2<S2SV_blank>queue\\n"" ) ; goto err_free_mem ; } s -> vdev = airspy_template ; s -> vdev . queue = & s -> vb_queue ; s -> vdev . queue -> lock = & s -> vb_queue_lock ; video_set_drvdata ( & s -> vdev , s ) ; s -> v4l2_dev . release = airspy_video_release ; ret = v4l2_device_register ( & intf -> dev , & s -> v4l2_dev ) ; if ( ret ) { dev_err ( s -> dev , ""Failed<S2SV_blank>to<S2SV_blank>register<S2SV_blank>v4l2-device<S2SV_blank>(%d)\\n"" , ret ) ; goto err_free_mem ; } v4l2_ctrl_handler_init ( & s -> hdl , 5 ) ; s -> lna_gain_auto = v4l2_ctrl_new_std ( & s -> hdl , & airspy_ctrl_ops , V4L2_CID_RF_TUNER_LNA_GAIN_AUTO , 0 , 1 , 1 , 0 ) ; s -> lna_gain = v4l2_ctrl_new_std ( & s -> hdl , & airspy_ctrl_ops , V4L2_CID_RF_TUNER_LNA_GAIN , 0 , 14 , 1 , 8 ) ; v4l2_ctrl_auto_cluster ( 2 , & s -> lna_gain_auto , 0 , false ) ; s -> mixer_gain_auto = v4l2_ctrl_new_std ( & s -> hdl , & airspy_ctrl_ops , V4L2_CID_RF_TUNER_MIXER_GAIN_AUTO , 0 , 1 , 1 , 0 ) ; s -> mixer_gain = v4l2_ctrl_new_std ( & s -> hdl , & airspy_ctrl_ops , V4L2_CID_RF_TUNER_MIXER_GAIN , 0 , 15 , 1 , 8 ) ; v4l2_ctrl_auto_cluster ( 2 , & s -> mixer_gain_auto , 0 , false ) ; s -> if_gain = v4l2_ctrl_new_std ( & s -> hdl , & airspy_ctrl_ops , V4L2_CID_RF_TUNER_IF_GAIN , 0 , 15 , 1 , 0 ) ; if ( s -> hdl . error ) { ret = s -> hdl . error ; dev_err ( s -> dev , ""Could<S2SV_blank>not<S2SV_blank>initialize<S2SV_blank>controls\\n"" ) ; goto err_free_controls ; } v4l2_ctrl_handler_setup ( & s -> hdl ) ; s -> v4l2_dev . ctrl_handler = & s -> hdl ; s -> vdev . v4l2_dev = & s -> v4l2_dev ; s -> vdev . lock = & s -> v4l2_lock ; ret = video_register_device ( & s -> vdev , VFL_TYPE_SDR , - 1 ) ; if ( ret ) { dev_err ( s -> dev , ""Failed<S2SV_blank>to<S2SV_blank>register<S2SV_blank>as<S2SV_blank>video<S2SV_blank>device<S2SV_blank>(%d)\\n"" , ret ) ; <S2SV_StartBug> goto err_unregister_v4l2_dev ; <S2SV_EndBug> } dev_info ( s -> dev , ""Registered<S2SV_blank>as<S2SV_blank>%s\\n"" , video_device_node_name ( & s -> vdev ) ) ; dev_notice ( s -> dev , ""SDR<S2SV_blank>API<S2SV_blank>is<S2SV_blank>still<S2SV_blank>slightly<S2SV_blank>experimental<S2SV_blank>and<S2SV_blank>functionality<S2SV_blank>changes<S2SV_blank>may<S2SV_blank>follow\\n"" ) ; return 0 ; err_free_controls : v4l2_ctrl_handler_free ( & s -> hdl ) ; <S2SV_StartBug> err_unregister_v4l2_dev : <S2SV_EndBug> v4l2_device_unregister ( & s -> v4l2_dev ) ; err_free_mem : kfree ( s ) ; return ret ; }
","<S2SV_ModStart> ) ; goto err_free_controls <S2SV_ModEnd> ; } dev_info <S2SV_ModStart> hdl ) ; <S2SV_ModEnd> v4l2_device_unregister ( &
"
171,"CWE-125 int obj2ast_stmt ( PyObject * obj , stmt_ty * out , PyArena * arena ) { int isinstance ; PyObject * tmp = NULL ; int lineno ; int col_offset ; if ( obj == Py_None ) { * out = NULL ; return 0 ; } <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_lineno ) ) { <S2SV_EndBug> int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_lineno ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; <S2SV_StartBug> res = obj2ast_int ( tmp , & lineno , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""lineno\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>stmt"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_col_offset ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_col_offset ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_int ( tmp , & col_offset , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""col_offset\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>stmt"" ) ; return 1 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) FunctionDef_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { identifier name ; arguments_ty args ; asdl_seq * body ; asdl_seq * decorator_list ; expr_ty returns ; string type_comment ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_name ) ) { <S2SV_EndBug> int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_name ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_identifier ( tmp , & name , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""name\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionDef"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_args ) ) { int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_args ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_arguments ( tmp , & args , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""args\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionDef"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""FunctionDef<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""FunctionDef<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( body , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionDef"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_decorator_list ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_decorator_list ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""FunctionDef<S2SV_blank>field<S2SV_blank>\\""decorator_list\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; decorator_list = _Ta3_asdl_seq_new ( len , arena ) ; if ( decorator_list == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""FunctionDef<S2SV_blank>field<S2SV_blank>\\""decorator_list\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( decorator_list , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""decorator_list\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionDef"" ) ; return 1 ; } <S2SV_StartBug> if ( exists_not_none ( obj , & PyId_returns ) ) { <S2SV_EndBug> int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_returns ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & returns , arena ) ; if ( res != 0 ) goto failed ; <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { returns = NULL ; } if ( exists_not_none ( obj , & PyId_type_comment ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_type_comment ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_string ( tmp , & type_comment , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { type_comment = NULL ; } * out = FunctionDef ( name , args , body , decorator_list , returns , type_comment , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) AsyncFunctionDef_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { identifier name ; arguments_ty args ; asdl_seq * body ; asdl_seq * decorator_list ; expr_ty returns ; string type_comment ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_name ) ) { <S2SV_EndBug> int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_name ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_identifier ( tmp , & name , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""name\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFunctionDef"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_args ) ) { int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_args ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_arguments ( tmp , & args , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""args\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFunctionDef"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""AsyncFunctionDef<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""AsyncFunctionDef<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( body , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFunctionDef"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_decorator_list ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_decorator_list ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""AsyncFunctionDef<S2SV_blank>field<S2SV_blank>\\""decorator_list\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; decorator_list = _Ta3_asdl_seq_new ( len , arena ) ; if ( decorator_list == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""AsyncFunctionDef<S2SV_blank>field<S2SV_blank>\\""decorator_list\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( decorator_list , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""decorator_list\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFunctionDef"" ) ; return 1 ; } <S2SV_StartBug> if ( exists_not_none ( obj , & PyId_returns ) ) { <S2SV_EndBug> int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_returns ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & returns , arena ) ; if ( res != 0 ) goto failed ; <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { returns = NULL ; } if ( exists_not_none ( obj , & PyId_type_comment ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_type_comment ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_string ( tmp , & type_comment , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { type_comment = NULL ; } * out = AsyncFunctionDef ( name , args , body , decorator_list , returns , type_comment , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) ClassDef_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { identifier name ; asdl_seq * bases ; asdl_seq * keywords ; asdl_seq * body ; asdl_seq * decorator_list ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_name ) ) { <S2SV_EndBug> int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_name ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_identifier ( tmp , & name , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""name\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ClassDef"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_bases ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_bases ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""ClassDef<S2SV_blank>field<S2SV_blank>\\""bases\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; bases = _Ta3_asdl_seq_new ( len , arena ) ; if ( bases == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""ClassDef<S2SV_blank>field<S2SV_blank>\\""bases\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( bases , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""bases\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ClassDef"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_keywords ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_keywords ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""ClassDef<S2SV_blank>field<S2SV_blank>\\""keywords\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; keywords = _Ta3_asdl_seq_new ( len , arena ) ; if ( keywords == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> keyword_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_keyword ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""ClassDef<S2SV_blank>field<S2SV_blank>\\""keywords\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( keywords , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""keywords\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ClassDef"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""ClassDef<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""ClassDef<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( body , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ClassDef"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_decorator_list ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_decorator_list ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""ClassDef<S2SV_blank>field<S2SV_blank>\\""decorator_list\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; decorator_list = _Ta3_asdl_seq_new ( len , arena ) ; if ( decorator_list == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""ClassDef<S2SV_blank>field<S2SV_blank>\\""decorator_list\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( decorator_list , i , value ) ; <S2SV_EndBug> } <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""decorator_list\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ClassDef"" ) ; return 1 ; } * out = ClassDef ( name , bases , keywords , body , decorator_list , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Return_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty value ; <S2SV_StartBug> if ( exists_not_none ( obj , & PyId_value ) ) { <S2SV_EndBug> int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & value , arena ) ; if ( res != 0 ) goto failed ; <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { value = NULL ; } * out = Return ( value , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Delete_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * targets ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_targets ) ) { <S2SV_EndBug> int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_targets ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Delete<S2SV_blank>field<S2SV_blank>\\""targets\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; targets = _Ta3_asdl_seq_new ( len , arena ) ; if ( targets == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Delete<S2SV_blank>field<S2SV_blank>\\""targets\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( targets , i , value ) ; <S2SV_EndBug> } <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""targets\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Delete"" ) ; return 1 ; } * out = Delete ( targets , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Assign_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * targets ; expr_ty value ; string type_comment ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_targets ) ) { <S2SV_EndBug> int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_targets ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Assign<S2SV_blank>field<S2SV_blank>\\""targets\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; targets = _Ta3_asdl_seq_new ( len , arena ) ; if ( targets == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Assign<S2SV_blank>field<S2SV_blank>\\""targets\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( targets , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""targets\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Assign"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) { int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & value , arena ) ; if ( res != 0 ) goto failed ; <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""value\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Assign"" ) ; return 1 ; } if ( exists_not_none ( obj , & PyId_type_comment ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_type_comment ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_string ( tmp , & type_comment , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { type_comment = NULL ; } * out = Assign ( targets , value , type_comment , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) AugAssign_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty target ; operator_ty op ; expr_ty value ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_target ) ) { <S2SV_EndBug> int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_target ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; <S2SV_StartBug> res = obj2ast_expr ( tmp , & target , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""target\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AugAssign"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_op ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_op ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_operator ( tmp , & op , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""op\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AugAssign"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & value , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""value\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AugAssign"" ) ; return 1 ; } * out = AugAssign ( target , op , value , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) AnnAssign_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty target ; expr_ty annotation ; expr_ty value ; int simple ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_target ) ) { <S2SV_EndBug> int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_target ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; <S2SV_StartBug> res = obj2ast_expr ( tmp , & target , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""target\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AnnAssign"" ) ; <S2SV_EndBug> return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_annotation ) ) { int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_annotation ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & annotation , arena ) ; if ( res != 0 ) goto failed ; <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""annotation\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AnnAssign"" ) ; return 1 ; } if ( exists_not_none ( obj , & PyId_value ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & value , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { value = NULL ; } if ( _PyObject_HasAttrId ( obj , & PyId_simple ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_simple ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_int ( tmp , & simple , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""simple\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AnnAssign"" ) ; return 1 ; } * out = AnnAssign ( target , annotation , value , simple , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) For_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty target ; expr_ty iter ; asdl_seq * body ; asdl_seq * orelse ; string type_comment ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_target ) ) { <S2SV_EndBug> int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_target ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; <S2SV_StartBug> res = obj2ast_expr ( tmp , & target , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""target\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>For"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_iter ) ) { int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_iter ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & iter , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""iter\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>For"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""For<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""For<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( body , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>For"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_orelse ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_orelse ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""For<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; orelse = _Ta3_asdl_seq_new ( len , arena ) ; if ( orelse == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""For<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( orelse , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>For"" ) ; return 1 ; } if ( exists_not_none ( obj , & PyId_type_comment ) ) { int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_type_comment ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_string ( tmp , & type_comment , arena ) ; if ( res != 0 ) goto failed ; <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { type_comment = NULL ; } * out = For ( target , iter , body , orelse , type_comment , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) AsyncFor_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty target ; expr_ty iter ; asdl_seq * body ; asdl_seq * orelse ; string type_comment ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_target ) ) { <S2SV_EndBug> int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_target ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; <S2SV_StartBug> res = obj2ast_expr ( tmp , & target , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""target\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFor"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_iter ) ) { int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_iter ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & iter , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""iter\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFor"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""AsyncFor<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""AsyncFor<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( body , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFor"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_orelse ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_orelse ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""AsyncFor<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; orelse = _Ta3_asdl_seq_new ( len , arena ) ; if ( orelse == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""AsyncFor<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( orelse , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFor"" ) ; return 1 ; } if ( exists_not_none ( obj , & PyId_type_comment ) ) { int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_type_comment ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_string ( tmp , & type_comment , arena ) ; if ( res != 0 ) goto failed ; <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { type_comment = NULL ; } * out = AsyncFor ( target , iter , body , orelse , type_comment , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) While_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty test ; asdl_seq * body ; asdl_seq * orelse ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_test ) ) { <S2SV_EndBug> int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_test ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & test , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""test\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>While"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""While<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""While<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( body , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>While"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_orelse ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_orelse ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""While<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; orelse = _Ta3_asdl_seq_new ( len , arena ) ; if ( orelse == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""While<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( orelse , i , value ) ; <S2SV_EndBug> } <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>While"" ) ; return 1 ; } * out = While ( test , body , orelse , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) If_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty test ; asdl_seq * body ; asdl_seq * orelse ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_test ) ) { <S2SV_EndBug> int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_test ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & test , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""test\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>If"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""If<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""If<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( body , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>If"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_orelse ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_orelse ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""If<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; orelse = _Ta3_asdl_seq_new ( len , arena ) ; if ( orelse == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""If<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( orelse , i , value ) ; <S2SV_EndBug> } <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>If"" ) ; return 1 ; } * out = If ( test , body , orelse , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) With_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * items ; asdl_seq * body ; string type_comment ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_items ) ) { <S2SV_EndBug> int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_items ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""With<S2SV_blank>field<S2SV_blank>\\""items\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; items = _Ta3_asdl_seq_new ( len , arena ) ; if ( items == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> withitem_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_withitem ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""With<S2SV_blank>field<S2SV_blank>\\""items\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( items , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""items\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>With"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""With<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""With<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( body , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>With"" ) ; return 1 ; } if ( exists_not_none ( obj , & PyId_type_comment ) ) { int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_type_comment ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_string ( tmp , & type_comment , arena ) ; if ( res != 0 ) goto failed ; <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { type_comment = NULL ; } * out = With ( items , body , type_comment , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) AsyncWith_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * items ; asdl_seq * body ; string type_comment ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_items ) ) { <S2SV_EndBug> int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_items ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""AsyncWith<S2SV_blank>field<S2SV_blank>\\""items\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; items = _Ta3_asdl_seq_new ( len , arena ) ; if ( items == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> withitem_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_withitem ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""AsyncWith<S2SV_blank>field<S2SV_blank>\\""items\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( items , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""items\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncWith"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""AsyncWith<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""AsyncWith<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( body , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncWith"" ) ; return 1 ; } if ( exists_not_none ( obj , & PyId_type_comment ) ) { int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_type_comment ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_string ( tmp , & type_comment , arena ) ; if ( res != 0 ) goto failed ; <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { type_comment = NULL ; } * out = AsyncWith ( items , body , type_comment , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Raise_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty exc ; expr_ty cause ; <S2SV_StartBug> if ( exists_not_none ( obj , & PyId_exc ) ) { <S2SV_EndBug> int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_exc ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; <S2SV_StartBug> res = obj2ast_expr ( tmp , & exc , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { exc = NULL ; } if ( exists_not_none ( obj , & PyId_cause ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_cause ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & cause , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { cause = NULL ; } * out = Raise ( exc , cause , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Try_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; asdl_seq * handlers ; asdl_seq * orelse ; asdl_seq * finalbody ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { <S2SV_EndBug> int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Try<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Try<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( body , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Try"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_handlers ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_handlers ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Try<S2SV_blank>field<S2SV_blank>\\""handlers\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; handlers = _Ta3_asdl_seq_new ( len , arena ) ; if ( handlers == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> excepthandler_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_excepthandler ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Try<S2SV_blank>field<S2SV_blank>\\""handlers\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( handlers , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""handlers\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Try"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_orelse ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_orelse ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Try<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; orelse = _Ta3_asdl_seq_new ( len , arena ) ; if ( orelse == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Try<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( orelse , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Try"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_finalbody ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_finalbody ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Try<S2SV_blank>field<S2SV_blank>\\""finalbody\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; finalbody = _Ta3_asdl_seq_new ( len , arena ) ; if ( finalbody == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Try<S2SV_blank>field<S2SV_blank>\\""finalbody\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( finalbody , i , value ) ; <S2SV_EndBug> } <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""finalbody\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Try"" ) ; return 1 ; } * out = Try ( body , handlers , orelse , finalbody , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Assert_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty test ; expr_ty msg ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_test ) ) { <S2SV_EndBug> int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_test ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; <S2SV_StartBug> res = obj2ast_expr ( tmp , & test , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""test\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Assert"" ) ; return 1 ; } if ( exists_not_none ( obj , & PyId_msg ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_msg ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & msg , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { msg = NULL ; } * out = Assert ( test , msg , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Import_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * names ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_names ) ) { <S2SV_EndBug> int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_names ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Import<S2SV_blank>field<S2SV_blank>\\""names\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; names = _Ta3_asdl_seq_new ( len , arena ) ; if ( names == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> alias_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_alias ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Import<S2SV_blank>field<S2SV_blank>\\""names\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( names , i , value ) ; <S2SV_EndBug> } <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""names\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Import"" ) ; return 1 ; } * out = Import ( names , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) ImportFrom_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { identifier module ; asdl_seq * names ; int level ; <S2SV_StartBug> if ( exists_not_none ( obj , & PyId_module ) ) { <S2SV_EndBug> int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_module ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_identifier ( tmp , & module , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { module = NULL ; } if ( _PyObject_HasAttrId ( obj , & PyId_names ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_names ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""ImportFrom<S2SV_blank>field<S2SV_blank>\\""names\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; names = _Ta3_asdl_seq_new ( len , arena ) ; if ( names == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> alias_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_alias ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""ImportFrom<S2SV_blank>field<S2SV_blank>\\""names\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( names , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""names\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ImportFrom"" ) ; return 1 ; } if ( exists_not_none ( obj , & PyId_level ) ) { int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_level ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_int ( tmp , & level , arena ) ; if ( res != 0 ) goto failed ; <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { level = 0 ; } * out = ImportFrom ( module , names , level , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Global_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * names ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_names ) ) { <S2SV_EndBug> int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_names ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Global<S2SV_blank>field<S2SV_blank>\\""names\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; names = _Ta3_asdl_seq_new ( len , arena ) ; if ( names == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> identifier value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_identifier ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Global<S2SV_blank>field<S2SV_blank>\\""names\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( names , i , value ) ; <S2SV_EndBug> } <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""names\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Global"" ) ; return 1 ; } * out = Global ( names , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Nonlocal_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * names ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_names ) ) { <S2SV_EndBug> int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_names ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Nonlocal<S2SV_blank>field<S2SV_blank>\\""names\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; names = _Ta3_asdl_seq_new ( len , arena ) ; if ( names == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> identifier value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_identifier ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Nonlocal<S2SV_blank>field<S2SV_blank>\\""names\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( names , i , value ) ; <S2SV_EndBug> } <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""names\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Nonlocal"" ) ; return 1 ; } * out = Nonlocal ( names , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Expr_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty value ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) { <S2SV_EndBug> int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & value , arena ) ; if ( res != 0 ) goto failed ; <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""value\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Expr"" ) ; return 1 ; } * out = Expr ( value , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Pass_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { * out = Pass ( lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Break_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { * out = Break ( lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Continue_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { * out = Continue ( lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } PyErr_Format ( PyExc_TypeError , ""expected<S2SV_blank>some<S2SV_blank>sort<S2SV_blank>of<S2SV_blank>stmt,<S2SV_blank>but<S2SV_blank>got<S2SV_blank>%R"" , obj ) ; failed : Py_XDECREF ( tmp ) ; return 1 ; }
","<S2SV_ModStart> } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_lineno , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""lineno\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>stmt"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_int ( tmp , & lineno , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_col_offset , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""col_offset\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>stmt"" ) ; return 1 ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> tmp , & col_offset <S2SV_ModEnd> , arena ) <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } isinstance <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_name , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""name\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionDef"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_identifier ( tmp , & name , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_args , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""args\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionDef"" ) ; return 1 ; } else { int res ; res = obj2ast_arguments ( tmp , & args <S2SV_ModEnd> , arena ) <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionDef"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> int res ; <S2SV_ModEnd> Py_ssize_t len ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_decorator_list , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""decorator_list\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionDef"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { expr_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_returns , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; returns = NULL ; } else { int res ; res = obj2ast_expr ( tmp , & returns , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_string ( tmp , & type_comment <S2SV_ModEnd> , arena ) <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_name , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""name\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFunctionDef"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_identifier ( tmp , & name , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_args , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""args\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFunctionDef"" ) ; return 1 ; } else { int res ; res = obj2ast_arguments ( tmp , & args <S2SV_ModEnd> , arena ) <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFunctionDef"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> int res ; <S2SV_ModEnd> Py_ssize_t len ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_decorator_list , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""decorator_list\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFunctionDef"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { expr_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_returns , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; returns = NULL ; } else { int res ; res = obj2ast_expr ( tmp , & returns , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_string ( tmp , & type_comment <S2SV_ModEnd> , arena ) <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_name , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""name\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ClassDef"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_identifier ( tmp , & name , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_bases , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""bases\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ClassDef"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { expr_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_keywords , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""keywords\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ClassDef"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { keyword_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ClassDef"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_decorator_list , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""decorator_list\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ClassDef"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { expr_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_value , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; value = NULL ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; <S2SV_ModEnd> res = obj2ast_expr <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_targets , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""targets\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Delete"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { expr_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_targets , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""targets\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Assign"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { expr_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val ) ; } Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_value , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""value\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Assign"" ) ; return 1 ; } else { int res ; res = obj2ast_expr ( tmp , & value , arena ) ; if ( res != 0 ) goto failed ; <S2SV_ModEnd> Py_CLEAR ( tmp <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> int res ; res = obj2ast_string ( tmp , & type_comment <S2SV_ModEnd> , arena ) <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_target , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""target\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AugAssign"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_expr ( tmp , & target , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_op , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""op\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AugAssign"" ) ; return 1 ; } else { int res ; res = obj2ast_operator ( tmp , & op , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_value , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""value\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AugAssign"" ) ; return 1 ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> tmp , & value <S2SV_ModEnd> , arena ) <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_target , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""target\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AnnAssign"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_expr ( tmp , & target , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_annotation , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""annotation\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AnnAssign"" ) ; return 1 ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> tmp , & annotation <S2SV_ModEnd> , arena ) <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_value , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; value = NULL ; } else { int res ; res = obj2ast_expr ( tmp , & value , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_simple , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { <S2SV_ModEnd> PyErr_SetString ( PyExc_TypeError <S2SV_ModStart> ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""simple\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AnnAssign"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_int ( tmp , & simple <S2SV_ModEnd> , arena ) <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_target , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""target\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>For"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_expr ( tmp , & target , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_iter , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""iter\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>For"" ) ; return 1 ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> tmp , & iter <S2SV_ModEnd> , arena ) <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>For"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> int res ; <S2SV_ModEnd> Py_ssize_t len ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_orelse , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>For"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> int res ; <S2SV_ModEnd> res = obj2ast_string <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_target , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""target\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFor"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_expr ( tmp , & target , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_iter , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""iter\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFor"" ) ; return 1 ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> tmp , & iter <S2SV_ModEnd> , arena ) <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFor"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> int res ; <S2SV_ModEnd> Py_ssize_t len ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_orelse , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFor"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> int res ; <S2SV_ModEnd> res = obj2ast_string <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_test , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""test\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>While"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_expr ( tmp , & test , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>While"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_orelse , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>While"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_test , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""test\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>If"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_expr ( tmp , & test , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>If"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_orelse , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>If"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_items , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""items\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>With"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { withitem_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>With"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> int res ; <S2SV_ModEnd> res = obj2ast_string <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_items , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""items\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncWith"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { withitem_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncWith"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> int res ; <S2SV_ModEnd> res = obj2ast_string <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_exc , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; exc = NULL ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_expr ( tmp , & exc , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_cause , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; cause = NULL ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> tmp , & cause <S2SV_ModEnd> , arena ) <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Try"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_handlers , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""handlers\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Try"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { excepthandler_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_orelse , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Try"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_finalbody , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""finalbody\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Try"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_test , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""test\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Assert"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_expr ( tmp , & test , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_msg , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; msg = NULL ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> tmp , & msg <S2SV_ModEnd> , arena ) <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_names , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""names\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Import"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { alias_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_module , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; module = NULL ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_identifier ( tmp , & module , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_names , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""names\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ImportFrom"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { alias_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_level , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; level = 0 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> int res ; <S2SV_ModEnd> res = obj2ast_int <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_names , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""names\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Global"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { identifier val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_names , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""names\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Nonlocal"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { identifier val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_value , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""value\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Expr"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; <S2SV_ModEnd> res = obj2ast_expr <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } *
"
172,"CWE-295 NOEXPORT void print_cipher ( CLI * c ) { SSL_CIPHER * cipher ; # ifndef OPENSSL_NO_COMP const COMP_METHOD * compression , * expansion ; # endif if ( c -> opt -> log_level < LOG_INFO ) return ; s_log ( LOG_INFO , ""TLS<S2SV_blank>%s:<S2SV_blank>%s"" , c -> opt -> option . client ? ""connected"" : ""accepted"" , SSL_session_reused ( c -> ssl ) && ! c -> flag . psk ? ""previous<S2SV_blank>session<S2SV_blank>reused"" : ""new<S2SV_blank>session<S2SV_blank>negotiated"" ) ; cipher = ( SSL_CIPHER * ) SSL_get_current_cipher ( c -> ssl ) ; s_log ( LOG_INFO , ""%s<S2SV_blank>ciphersuite:<S2SV_blank>%s<S2SV_blank>(%d-bit<S2SV_blank>encryption)"" , SSL_get_version ( c -> ssl ) , SSL_CIPHER_get_name ( cipher ) , SSL_CIPHER_get_bits ( cipher , NULL ) ) ; <S2SV_StartBug> # ifndef OPENSSL_NO_COMP <S2SV_EndBug> compression = SSL_get_current_compression ( c -> ssl ) ; expansion = SSL_get_current_expansion ( c -> ssl ) ; s_log ( compression || expansion ? LOG_INFO : LOG_DEBUG , ""Compression:<S2SV_blank>%s,<S2SV_blank>expansion:<S2SV_blank>%s"" , compression ? SSL_COMP_get_name ( compression ) : ""null"" , expansion ? SSL_COMP_get_name ( expansion ) : ""null"" ) ; # endif }
","<S2SV_ModStart> ) ; # if OPENSSL_VERSION_NUMBER >= 0x10101000L print_tmp_key ( c -> ssl ) ; # endif #
"
173,"CWE-119 <S2SV_StartBug> static void get_sb_partition_size_range ( VP9_COMP * cpi , MODE_INFO * * mi_8x8 , <S2SV_EndBug> BLOCK_SIZE * min_block_size , <S2SV_StartBug> BLOCK_SIZE * max_block_size ) { <S2SV_EndBug> MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; int sb_width_in_blocks = MI_BLOCK_SIZE ; int sb_height_in_blocks = MI_BLOCK_SIZE ; int i , j ; int index = 0 ; for ( i = 0 ; i < sb_height_in_blocks ; ++ i ) { for ( j = 0 ; j < sb_width_in_blocks ; ++ j ) { MODE_INFO * mi = mi_8x8 [ index + j ] ; BLOCK_SIZE sb_type = mi ? mi -> mbmi . sb_type : 0 ; <S2SV_StartBug> * min_block_size = MIN ( * min_block_size , sb_type ) ; <S2SV_EndBug> * max_block_size = MAX ( * max_block_size , sb_type ) ; } index += xd -> mi_stride ; } }
","<S2SV_ModStart> void get_sb_partition_size_range ( MACROBLOCKD * xd <S2SV_ModEnd> , MODE_INFO * <S2SV_ModStart> BLOCK_SIZE * max_block_size , int bs_hist [ BLOCK_SIZES ] ) { <S2SV_ModEnd> int sb_width_in_blocks = <S2SV_ModStart> : 0 ; bs_hist [ sb_type ] ++ ;
"
174,"CWE-125 static const char * expr_context_name ( expr_context_ty ctx ) { switch ( ctx ) { case Load : return ""Load"" ; case Store : return ""Store"" ; case Del : return ""Del"" ; case AugLoad : return ""AugLoad"" ; case AugStore : return ""AugStore"" ; case Param : return ""Param"" ; default : <S2SV_StartBug> assert ( 0 ) ; <S2SV_EndBug> return ""(unknown)"" ; } }
","<S2SV_ModStart> ; default : abort ( ) <S2SV_ModEnd> ; } }
"
175,"CWE-20 static int security_context_to_sid_core ( const char * scontext , u32 scontext_len , u32 * sid , u32 def_sid , gfp_t gfp_flags , int force ) { char * scontext2 , * str = NULL ; struct context context ; <S2SV_StartBug> int rc = 0 ; <S2SV_EndBug> if ( ! ss_initialized ) { int i ; for ( i = 1 ; i < SECINITSID_NUM ; i ++ ) { if ( ! strcmp ( initial_sid_to_string [ i ] , scontext ) ) { * sid = i ; return 0 ; } } * sid = SECINITSID_KERNEL ; return 0 ; } * sid = SECSID_NULL ; scontext2 = kmalloc ( scontext_len + 1 , gfp_flags ) ; if ( ! scontext2 ) return - ENOMEM ; memcpy ( scontext2 , scontext , scontext_len ) ; scontext2 [ scontext_len ] = 0 ; if ( force ) { rc = - ENOMEM ; str = kstrdup ( scontext2 , gfp_flags ) ; if ( ! str ) goto out ; } read_lock ( & policy_rwlock ) ; rc = string_to_context_struct ( & policydb , & sidtab , scontext2 , scontext_len , & context , def_sid ) ; if ( rc == - EINVAL && force ) { context . str = str ; context . len = scontext_len ; str = NULL ; } else if ( rc ) goto out_unlock ; rc = sidtab_context_to_sid ( & sidtab , & context , sid ) ; context_destroy ( & context ) ; out_unlock : read_unlock ( & policy_rwlock ) ; out : kfree ( scontext2 ) ; kfree ( str ) ; return rc ; }
","<S2SV_ModStart> rc = 0 ; if ( ! scontext_len ) return - EINVAL
"
176,"CWE-59 void vrrp_print_stats ( void ) { <S2SV_StartBug> FILE * file ; <S2SV_EndBug> <S2SV_StartBug> file = fopen ( stats_file , ""w"" ) ; <S2SV_EndBug> if ( ! file ) { log_message ( LOG_INFO , ""Can\'t<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>(%d:<S2SV_blank>%s)"" , stats_file , errno , strerror ( errno ) ) ; return ; } list l = vrrp_data -> vrrp ; element e ; vrrp_t * vrrp ; <S2SV_StartBug> for ( e = LIST_HEAD ( l ) ; e ; ELEMENT_NEXT ( e ) ) { <S2SV_EndBug> vrrp = ELEMENT_DATA ( e ) ; fprintf ( file , ""VRRP<S2SV_blank>Instance:<S2SV_blank>%s\\n"" , vrrp -> iname ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank>Advertisements:\\n"" ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Received:<S2SV_blank>%"" PRIu64 ""\\n"" , vrrp -> stats -> advert_rcvd ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Sent:<S2SV_blank>%d\\n"" , vrrp -> stats -> advert_sent ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank>Became<S2SV_blank>master:<S2SV_blank>%d\\n"" , vrrp -> stats -> become_master ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank>Released<S2SV_blank>master:<S2SV_blank>%d\\n"" , vrrp -> stats -> release_master ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank>Packet<S2SV_blank>Errors:\\n"" ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Length:<S2SV_blank>%"" PRIu64 ""\\n"" , vrrp -> stats -> packet_len_err ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>TTL:<S2SV_blank>%"" PRIu64 ""\\n"" , vrrp -> stats -> ip_ttl_err ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Invalid<S2SV_blank>Type:<S2SV_blank>%"" PRIu64 ""\\n"" , vrrp -> stats -> invalid_type_rcvd ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Advertisement<S2SV_blank>Interval:<S2SV_blank>%"" PRIu64 ""\\n"" , vrrp -> stats -> advert_interval_err ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Address<S2SV_blank>List:<S2SV_blank>%"" PRIu64 ""\\n"" , vrrp -> stats -> addr_list_err ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank>Authentication<S2SV_blank>Errors:\\n"" ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Invalid<S2SV_blank>Type:<S2SV_blank>%d\\n"" , vrrp -> stats -> invalid_authtype ) ; # ifdef _WITH_VRRP_AUTH_ fprintf ( file , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Type<S2SV_blank>Mismatch:<S2SV_blank>%d\\n"" , vrrp -> stats -> authtype_mismatch ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Failure:<S2SV_blank>%d\\n"" , vrrp -> stats -> auth_failure ) ; # endif fprintf ( file , ""<S2SV_blank><S2SV_blank>Priority<S2SV_blank>Zero:\\n"" ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Received:<S2SV_blank>%"" PRIu64 ""\\n"" , vrrp -> stats -> pri_zero_rcvd ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Sent:<S2SV_blank>%"" PRIu64 ""\\n"" , vrrp -> stats -> pri_zero_sent ) ; } fclose ( file ) ; }
","<S2SV_ModStart> FILE * file = fopen_safe <S2SV_ModEnd> ( stats_file , <S2SV_ModStart> , ""w"" ) <S2SV_ModEnd> ; element e <S2SV_ModStart> * vrrp ; if ( ! file ) { log_message ( LOG_INFO , ""Can\'t<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>(%d:<S2SV_blank>%s)"" , stats_file , errno , strerror ( errno ) ) ; return ; } LIST_FOREACH ( vrrp_data -> vrrp , vrrp , e ) { <S2SV_ModEnd> fprintf ( file
"
177,"CWE-436 static gssize find_auth_end ( FlatpakProxyClient * client , Buffer * buffer ) { <S2SV_StartBug> guchar * match ; <S2SV_EndBug> int i ; if ( client -> auth_end_offset > 0 ) { gsize left = strlen ( AUTH_END_STRING ) - client -> auth_end_offset ; <S2SV_StartBug> gsize to_match = MIN ( left , buffer -> pos ) ; <S2SV_EndBug> <S2SV_StartBug> if ( memcmp ( buffer -> data , & AUTH_END_STRING [ client -> auth_end_offset ] , to_match ) == 0 ) <S2SV_EndBug> { client -> auth_end_offset += to_match ; if ( client -> auth_end_offset == strlen ( AUTH_END_STRING ) ) return to_match ; return - 1 ; } client -> auth_end_offset = - 1 ; } match = memmem ( buffer , buffer -> pos , AUTH_END_STRING , strlen ( AUTH_END_STRING ) ) ; if ( match != NULL ) <S2SV_StartBug> return match - buffer -> data + strlen ( AUTH_END_STRING ) ; <S2SV_EndBug> for ( i = MIN ( strlen ( AUTH_END_STRING ) - 1 , buffer -> pos ) ; i > 0 ; i -- ) { if ( memcmp ( buffer -> data + buffer -> pos - i , AUTH_END_STRING , i ) == 0 ) { client -> auth_end_offset = i ; break ; } } return - 1 ; }
","<S2SV_ModStart> buffer ) { goffset offset = 0 ; gsize original_size = client -> auth_buffer -> len ; g_byte_array_append ( client -> auth_buffer <S2SV_ModEnd> , buffer -> <S2SV_ModStart> , buffer -> data , buffer -> <S2SV_ModStart> pos ) ; while ( TRUE ) { guint8 * line_start = client -> auth_buffer <S2SV_ModEnd> -> data + <S2SV_ModStart> -> data + offset ; gsize remaining_data = client -> auth_buffer -> len - offset ; guint8 * line_end ; line_end = memmem ( line_start , remaining_data , AUTH_LINE_SENTINEL , strlen ( AUTH_LINE_SENTINEL ) ) ; if ( line_end ) { offset = ( line_end + strlen ( AUTH_LINE_SENTINEL ) - line_start ) ; if ( ! auth_line_is_valid ( line_start , line_end ) ) return FIND_AUTH_END_ABORT ; * line_end = 0 ; if ( auth_line_is_begin ( line_start ) ) return offset - original_size ; } else { g_byte_array_remove_range ( client -> auth_buffer , 0 , offset ) ; if ( client -> auth_buffer -> len >= 16 * 1024 ) return FIND_AUTH_END_ABORT ; return FIND_AUTH_END_CONTINUE ; } } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
"
178,"CWE-295 static int int_x509_param_set_hosts ( X509_VERIFY_PARAM_ID * id , int mode , const char * name , size_t namelen ) { char * copy ; <S2SV_StartBug> if ( name && memchr ( name , '\\0' , namelen ) ) <S2SV_EndBug> return 0 ; if ( mode == SET_HOST && id -> hosts ) { string_stack_free ( id -> hosts ) ; id -> hosts = NULL ; } if ( name == NULL || namelen == 0 ) return 1 ; copy = strndup ( name , namelen ) ; if ( copy == NULL ) return 0 ; if ( id -> hosts == NULL && ( id -> hosts = sk_OPENSSL_STRING_new_null ( ) ) == NULL ) { free ( copy ) ; return 0 ; } if ( ! sk_OPENSSL_STRING_push ( id -> hosts , copy ) ) { free ( copy ) ; if ( sk_OPENSSL_STRING_num ( id -> hosts ) == 0 ) { sk_OPENSSL_STRING_free ( id -> hosts ) ; id -> hosts = NULL ; } return 0 ; } return 1 ; }
","<S2SV_ModStart> if ( name != NULL && namelen == 0 ) namelen = strlen ( name ) ; if ( name
"
179,"CWE-189 static int adjust_ptr_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , const struct bpf_reg_state * ptr_reg , const struct bpf_reg_state * off_reg ) { struct bpf_verifier_state * vstate = env -> cur_state ; struct bpf_func_state * state = vstate -> frame [ vstate -> curframe ] ; struct bpf_reg_state * regs = state -> regs , * dst_reg ; bool known = tnum_is_const ( off_reg -> var_off ) ; s64 smin_val = off_reg -> smin_value , smax_val = off_reg -> smax_value , smin_ptr = ptr_reg -> smin_value , smax_ptr = ptr_reg -> smax_value ; u64 umin_val = off_reg -> umin_value , umax_val = off_reg -> umax_value , umin_ptr = ptr_reg -> umin_value , umax_ptr = ptr_reg -> umax_value ; u32 dst = insn -> dst_reg , src = insn -> src_reg ; <S2SV_StartBug> u8 opcode = BPF_OP ( insn -> code ) ; <S2SV_EndBug> dst_reg = & regs [ dst ] ; if ( ( known && ( smin_val != smax_val || umin_val != umax_val ) ) || smin_val > smax_val || umin_val > umax_val ) { __mark_reg_unknown ( dst_reg ) ; return 0 ; } if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { verbose ( env , ""R%d<S2SV_blank>32-bit<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>prohibited\\n"" , dst ) ; return - EACCES ; } switch ( ptr_reg -> type ) { case PTR_TO_MAP_VALUE_OR_NULL : verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>prohibited,<S2SV_blank>null-check<S2SV_blank>it<S2SV_blank>first\\n"" , dst , reg_type_str [ ptr_reg -> type ] ) ; return - EACCES ; case CONST_PTR_TO_MAP : case PTR_TO_PACKET_END : case PTR_TO_SOCKET : case PTR_TO_SOCKET_OR_NULL : verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>prohibited\\n"" , dst , reg_type_str [ ptr_reg -> type ] ) ; return - EACCES ; case PTR_TO_MAP_VALUE : if ( ! env -> allow_ptr_leaks && ! known && ( smin_val < 0 ) != ( smax_val < 0 ) ) { verbose ( env , ""R%d<S2SV_blank>has<S2SV_blank>unknown<S2SV_blank>scalar<S2SV_blank>with<S2SV_blank>mixed<S2SV_blank>signed<S2SV_blank>bounds,<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>with<S2SV_blank>it<S2SV_blank>prohibited<S2SV_blank>for<S2SV_blank>!root\\n"" , off_reg == dst_reg ? dst : src ) ; return - EACCES ; } default : break ; } dst_reg -> type = ptr_reg -> type ; dst_reg -> id = ptr_reg -> id ; if ( ! check_reg_sane_offset ( env , off_reg , ptr_reg -> type ) || ! check_reg_sane_offset ( env , ptr_reg , ptr_reg -> type ) ) return - EINVAL ; switch ( opcode ) { case BPF_ADD : <S2SV_StartBug> if ( known && ( ptr_reg -> off + smin_val == <S2SV_EndBug> ( s64 ) ( s32 ) ( ptr_reg -> off + smin_val ) ) ) { dst_reg -> smin_value = smin_ptr ; dst_reg -> smax_value = smax_ptr ; dst_reg -> umin_value = umin_ptr ; dst_reg -> umax_value = umax_ptr ; dst_reg -> var_off = ptr_reg -> var_off ; dst_reg -> off = ptr_reg -> off + smin_val ; dst_reg -> raw = ptr_reg -> raw ; break ; } if ( signed_add_overflows ( smin_ptr , smin_val ) || signed_add_overflows ( smax_ptr , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = smin_ptr + smin_val ; dst_reg -> smax_value = smax_ptr + smax_val ; } if ( umin_ptr + umin_val < umin_ptr || umax_ptr + umax_val < umax_ptr ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value = umin_ptr + umin_val ; dst_reg -> umax_value = umax_ptr + umax_val ; } dst_reg -> var_off = tnum_add ( ptr_reg -> var_off , off_reg -> var_off ) ; dst_reg -> off = ptr_reg -> off ; dst_reg -> raw = ptr_reg -> raw ; if ( reg_is_pkt_pointer ( ptr_reg ) ) { dst_reg -> id = ++ env -> id_gen ; dst_reg -> raw = 0 ; } break ; case BPF_SUB : <S2SV_StartBug> if ( dst_reg == off_reg ) { <S2SV_EndBug> verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>subtract<S2SV_blank>pointer<S2SV_blank>from<S2SV_blank>scalar\\n"" , dst ) ; return - EACCES ; } if ( ptr_reg -> type == PTR_TO_STACK ) { verbose ( env , ""R%d<S2SV_blank>subtraction<S2SV_blank>from<S2SV_blank>stack<S2SV_blank>pointer<S2SV_blank>prohibited\\n"" , dst ) ; return - EACCES ; } if ( known && ( ptr_reg -> off - smin_val == ( s64 ) ( s32 ) ( ptr_reg -> off - smin_val ) ) ) { dst_reg -> smin_value = smin_ptr ; dst_reg -> smax_value = smax_ptr ; dst_reg -> umin_value = umin_ptr ; dst_reg -> umax_value = umax_ptr ; dst_reg -> var_off = ptr_reg -> var_off ; dst_reg -> id = ptr_reg -> id ; dst_reg -> off = ptr_reg -> off - smin_val ; dst_reg -> raw = ptr_reg -> raw ; break ; } if ( signed_sub_overflows ( smin_ptr , smax_val ) || signed_sub_overflows ( smax_ptr , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = smin_ptr - smax_val ; dst_reg -> smax_value = smax_ptr - smin_val ; } if ( umin_ptr < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value = umin_ptr - umax_val ; dst_reg -> umax_value = umax_ptr - umin_val ; } dst_reg -> var_off = tnum_sub ( ptr_reg -> var_off , off_reg -> var_off ) ; dst_reg -> off = ptr_reg -> off ; dst_reg -> raw = ptr_reg -> raw ; if ( reg_is_pkt_pointer ( ptr_reg ) ) { dst_reg -> id = ++ env -> id_gen ; if ( smin_val < 0 ) dst_reg -> raw = 0 ; } break ; case BPF_AND : case BPF_OR : case BPF_XOR : verbose ( env , ""R%d<S2SV_blank>bitwise<S2SV_blank>operator<S2SV_blank>%s<S2SV_blank>on<S2SV_blank>pointer<S2SV_blank>prohibited\\n"" , dst , bpf_alu_string [ opcode >> 4 ] ) ; return - EACCES ; default : verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>with<S2SV_blank>%s<S2SV_blank>operator<S2SV_blank>prohibited\\n"" , dst , bpf_alu_string [ opcode >> 4 ] ) ; return - EACCES ; } if ( ! check_reg_sane_offset ( env , dst_reg , ptr_reg -> type ) ) return - EINVAL ; __update_reg_bounds ( dst_reg ) ; __reg_deduce_bounds ( dst_reg ) ; __reg_bound_offset ( dst_reg ) ; if ( ! env -> allow_ptr_leaks ) { if ( dst_reg -> type == PTR_TO_MAP_VALUE && check_map_access ( env , dst , dst_reg -> off , 1 , false ) ) { verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>of<S2SV_blank>map<S2SV_blank>value<S2SV_blank>goes<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range,<S2SV_blank>"" ""prohibited<S2SV_blank>for<S2SV_blank>!root\\n"" , dst ) ; return - EACCES ; } else if ( dst_reg -> type == PTR_TO_STACK && check_stack_access ( env , dst_reg , dst_reg -> off + dst_reg -> var_off . value , 1 ) ) { verbose ( env , ""R%d<S2SV_blank>stack<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>goes<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range,<S2SV_blank>"" ""prohibited<S2SV_blank>for<S2SV_blank>!root\\n"" , dst ) ; return - EACCES ; } } return 0 ; }
","<S2SV_ModStart> -> code ) ; int ret <S2SV_ModStart> case BPF_ADD : ret = sanitize_ptr_alu ( env , insn , ptr_reg , dst_reg , smin_val < 0 ) ; if ( ret < 0 ) { verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>add<S2SV_blank>from<S2SV_blank>different<S2SV_blank>maps<S2SV_blank>or<S2SV_blank>paths\\n"" , dst ) ; return ret ; } <S2SV_ModStart> case BPF_SUB : ret = sanitize_ptr_alu ( env , insn , ptr_reg , dst_reg , smin_val < 0 ) ; if ( ret < 0 ) { verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>sub<S2SV_blank>from<S2SV_blank>different<S2SV_blank>maps<S2SV_blank>or<S2SV_blank>paths\\n"" , dst ) ; return ret ; }
"
180,"CWE-362 void flush_tlb_mm_range ( struct mm_struct * mm , unsigned long start , unsigned long end , unsigned long vmflag ) { unsigned long addr ; unsigned long base_pages_to_flush = TLB_FLUSH_ALL ; preempt_disable ( ) ; <S2SV_StartBug> if ( current -> active_mm != mm ) <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> if ( ! current -> mm ) { leave_mm ( smp_processor_id ( ) ) ; <S2SV_StartBug> goto out ; <S2SV_EndBug> } if ( ( end != TLB_FLUSH_ALL ) && ! ( vmflag & VM_HUGETLB ) ) base_pages_to_flush = ( end - start ) >> PAGE_SHIFT ; if ( base_pages_to_flush > tlb_single_page_flush_ceiling ) { base_pages_to_flush = TLB_FLUSH_ALL ; count_vm_tlb_event ( NR_TLB_LOCAL_FLUSH_ALL ) ; local_flush_tlb ( ) ; } else { for ( addr = start ; addr < end ; addr += PAGE_SIZE ) { count_vm_tlb_event ( NR_TLB_LOCAL_FLUSH_ONE ) ; __flush_tlb_single ( addr ) ; } } trace_tlb_flush ( TLB_LOCAL_MM_SHOOTDOWN , base_pages_to_flush ) ; out : if ( base_pages_to_flush == TLB_FLUSH_ALL ) { start = 0UL ; end = TLB_FLUSH_ALL ; } if ( cpumask_any_but ( mm_cpumask ( mm ) , smp_processor_id ( ) ) < nr_cpu_ids ) flush_tlb_others ( mm_cpumask ( mm ) , mm , start , end ) ; preempt_enable ( ) ; }
","<S2SV_ModStart> != mm ) { smp_mb ( ) ; <S2SV_ModStart> goto out ; } <S2SV_ModStart> ) ) ; smp_mb ( ) ;
"
181,"CWE-399 void br_mdb_notify ( struct net_device * dev , struct net_bridge_port * port , struct br_ip * group , int type ) { <S2SV_StartBug> struct br_mdb_entry entry ; <S2SV_EndBug> entry . ifindex = port -> dev -> ifindex ; entry . addr . proto = group -> proto ; entry . addr . u . ip4 = group -> u . ip4 ; # if IS_ENABLED ( CONFIG_IPV6 ) entry . addr . u . ip6 = group -> u . ip6 ; # endif __br_mdb_notify ( dev , & entry , type ) ; }
","<S2SV_ModStart> struct br_mdb_entry entry ; memset ( & entry , 0 , sizeof ( entry ) )
"
182,"CWE-20 void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; <S2SV_StartBug> * dptr ++ = 0xAA ; <S2SV_EndBug> memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE:<S2SV_blank>rose_write_internal<S2SV_blank>-<S2SV_blank>invalid<S2SV_blank>frametype<S2SV_blank>%02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
","<S2SV_ModStart> dptr ++ = ROSE_CALL_REQ_ADDR_LEN_VAL <S2SV_ModEnd> ; memcpy (
"
183,"CWE-119 static inline void header_put_le_int ( SF_PRIVATE * psf , int x ) <S2SV_StartBug> { if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 4 ) <S2SV_EndBug> <S2SV_StartBug> { psf -> header [ psf -> headindex ++ ] = x ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = ( x >> 8 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = ( x >> 16 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = ( x >> 24 ) ; <S2SV_EndBug> <S2SV_StartBug> } ; <S2SV_EndBug> }
","<S2SV_ModStart> x ) { <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . ptr [ <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
"
184,"CWE-20 static int snd_hrtimer_start ( struct snd_timer * t ) { struct snd_hrtimer * stime = t -> private_data ; atomic_set ( & stime -> running , 0 ) ; <S2SV_StartBug> hrtimer_cancel ( & stime -> hrt ) ; <S2SV_EndBug> hrtimer_start ( & stime -> hrt , ns_to_ktime ( t -> sticks * resolution ) , HRTIMER_MODE_REL ) ; atomic_set ( & stime -> running , 1 ) ; return 0 ; }
","<S2SV_ModStart> 0 ) ; hrtimer_try_to_cancel <S2SV_ModEnd> ( & stime
"
185,"CWE-120 static void handle_PORT ( ctrl_t * ctrl , char * str ) { int a , b , c , d , e , f ; char addr [ INET_ADDRSTRLEN ] ; struct sockaddr_in sin ; if ( ctrl -> data_sd > 0 ) { uev_io_stop ( & ctrl -> data_watcher ) ; close ( ctrl -> data_sd ) ; ctrl -> data_sd = - 1 ; } sscanf ( str , ""%d,%d,%d,%d,%d,%d"" , & a , & b , & c , & d , & e , & f ) ; <S2SV_StartBug> sprintf ( addr , ""%d.%d.%d.%d"" , a , b , c , d ) ; <S2SV_EndBug> if ( ! inet_aton ( addr , & ( sin . sin_addr ) ) ) { ERR ( 0 , ""Invalid<S2SV_blank>address<S2SV_blank>\'%s\'<S2SV_blank>given<S2SV_blank>to<S2SV_blank>PORT<S2SV_blank>command"" , addr ) ; send_msg ( ctrl -> sd , ""500<S2SV_blank>Illegal<S2SV_blank>PORT<S2SV_blank>command.\\r\\n"" ) ; return ; } strlcpy ( ctrl -> data_address , addr , sizeof ( ctrl -> data_address ) ) ; ctrl -> data_port = e * 256 + f ; DBG ( ""Client<S2SV_blank>PORT<S2SV_blank>command<S2SV_blank>accepted<S2SV_blank>for<S2SV_blank>%s:%d"" , ctrl -> data_address , ctrl -> data_port ) ; send_msg ( ctrl -> sd , ""200<S2SV_blank>PORT<S2SV_blank>command<S2SV_blank>successful.\\r\\n"" ) ; }
","<S2SV_ModStart> f ) ; snprintf ( addr , sizeof ( addr ) <S2SV_ModEnd> , ""%d.%d.%d.%d"" ,
"
186,"CWE-20 static int cbor2json ( OSCTXT * pCborCtxt , OSCTXT * pJsonCtxt ) { int ret = 0 ; OSOCTET tag , ub ; ret = rtxReadBytes ( pCborCtxt , & ub , 1 ) ; if ( 0 != ret ) return LOG_RTERR ( pCborCtxt , ret ) ; tag = ub >> 5 ; switch ( tag ) { case OSRTCBOR_UINT : { OSUINTTYPE value ; ret = rtCborDecUInt ( pCborCtxt , ub , & value ) ; if ( 0 != ret ) return LOG_RTERR ( pCborCtxt , ret ) ; # ifndef _NO_INT64_SUPPORT ret = rtJsonEncUInt64Value ( pJsonCtxt , value ) ; # else ret = rtJsonEncUIntValue ( pJsonCtxt , value ) ; # endif if ( 0 != ret ) return LOG_RTERR ( pJsonCtxt , ret ) ; break ; } case OSRTCBOR_NEGINT : { OSINTTYPE value ; ret = rtCborDecInt ( pCborCtxt , ub , & value ) ; if ( 0 != ret ) return LOG_RTERR ( pCborCtxt , ret ) ; # ifndef _NO_INT64_SUPPORT ret = rtJsonEncInt64Value ( pJsonCtxt , value ) ; # else ret = rtJsonEncIntValue ( pJsonCtxt , value ) ; # endif if ( 0 != ret ) return LOG_RTERR ( pJsonCtxt , ret ) ; break ; } case OSRTCBOR_BYTESTR : { OSDynOctStr64 byteStr ; ret = rtCborDecDynByteStr ( pCborCtxt , ub , & byteStr ) ; if ( 0 != ret ) return LOG_RTERR ( pCborCtxt , ret ) ; ret = rtJsonEncHexStr ( pJsonCtxt , byteStr . numocts , byteStr . data ) ; rtxMemFreePtr ( pCborCtxt , byteStr . data ) ; if ( 0 != ret ) return LOG_RTERR ( pJsonCtxt , ret ) ; break ; } case OSRTCBOR_UTF8STR : { OSUTF8CHAR * utf8str ; <S2SV_StartBug> ret = rtCborDecDynUTF8Str ( pCborCtxt , ub , ( char * * ) & utf8str ) ; <S2SV_EndBug> ret = rtJsonEncStringValue ( pJsonCtxt , utf8str ) ; rtxMemFreePtr ( pCborCtxt , utf8str ) ; if ( 0 != ret ) return LOG_RTERR ( pJsonCtxt , ret ) ; break ; } case OSRTCBOR_ARRAY : case OSRTCBOR_MAP : { OSOCTET len = ub & 0x1F ; char startChar = ( tag == OSRTCBOR_ARRAY ) ? '[' : '{' ; char endChar = ( tag == OSRTCBOR_ARRAY ) ? ']' : '}' ; OSRTSAFEPUTCHAR ( pJsonCtxt , startChar ) ; if ( len == OSRTCBOR_INDEF ) { OSBOOL first = TRUE ; for ( ; ; ) { if ( OSRTCBOR_MATCHEOC ( pCborCtxt ) ) { pCborCtxt -> buffer . byteIndex ++ ; break ; } if ( ! first ) OSRTSAFEPUTCHAR ( pJsonCtxt , ',' ) ; else first = FALSE ; if ( tag == OSRTCBOR_MAP ) { ret = cborElemNameToJson ( pCborCtxt , pJsonCtxt ) ; } if ( 0 == ret ) ret = cbor2json ( pCborCtxt , pJsonCtxt ) ; if ( 0 != ret ) { OSCTXT * pctxt = ( rtxErrGetErrorCnt ( pJsonCtxt ) > 0 ) ? pJsonCtxt : pCborCtxt ; return LOG_RTERR ( pctxt , ret ) ; } } } else { OSSIZE nitems ; ret = rtCborDecSize ( pCborCtxt , len , & nitems ) ; if ( 0 == ret ) { OSSIZE i ; for ( i = 0 ; i < nitems ; i ++ ) { if ( 0 != i ) OSRTSAFEPUTCHAR ( pJsonCtxt , ',' ) ; if ( tag == OSRTCBOR_MAP ) { ret = cborElemNameToJson ( pCborCtxt , pJsonCtxt ) ; } if ( 0 == ret ) ret = cbor2json ( pCborCtxt , pJsonCtxt ) ; if ( 0 != ret ) { OSCTXT * pctxt = ( rtxErrGetErrorCnt ( pJsonCtxt ) > 0 ) ? pJsonCtxt : pCborCtxt ; return LOG_RTERR ( pctxt , ret ) ; } } } } OSRTSAFEPUTCHAR ( pJsonCtxt , endChar ) ; break ; } case OSRTCBOR_FLOAT : if ( tag == OSRTCBOR_FALSEENC || tag == OSRTCBOR_TRUEENC ) { OSBOOL boolval = ( ub == OSRTCBOR_TRUEENC ) ? TRUE : FALSE ; ret = rtJsonEncBoolValue ( pJsonCtxt , boolval ) ; if ( 0 != ret ) return LOG_RTERR ( pJsonCtxt , ret ) ; } else if ( tag == OSRTCBOR_FLT16ENC || tag == OSRTCBOR_FLT32ENC || tag == OSRTCBOR_FLT64ENC ) { OSDOUBLE fltval ; ret = rtCborDecFloat ( pCborCtxt , ub , & fltval ) ; if ( 0 != ret ) return LOG_RTERR ( pCborCtxt , ret ) ; ret = rtJsonEncDoubleValue ( pJsonCtxt , fltval , 0 ) ; if ( 0 != ret ) return LOG_RTERR ( pJsonCtxt , ret ) ; } else { ret = cborTagNotSupp ( pCborCtxt , tag ) ; } break ; default : ret = cborTagNotSupp ( pCborCtxt , tag ) ; } return ret ; }
","<S2SV_ModStart> ) & utf8str ) ; if ( 0 != ret ) return LOG_RTERR ( pCborCtxt , ret
"
187,"CWE-476 static GF_Err av1dmx_parse_flush_sample ( GF_Filter * filter , GF_AV1DmxCtx * ctx ) { u32 pck_size ; GF_FilterPacket * pck ; <S2SV_StartBug> u8 * output ; <S2SV_EndBug> gf_bs_get_content_no_truncate ( ctx -> state . bs , & ctx -> state . frame_obus , & pck_size , & ctx -> state . frame_obus_alloc ) ; if ( ! pck_size ) { GF_LOG ( GF_LOG_DEBUG , GF_LOG_CONTAINER , ( ""[AV1Dmx]<S2SV_blank>no<S2SV_blank>frame<S2SV_blank>OBU,<S2SV_blank>skipping<S2SV_blank>OBU\\n"" ) ) ; return GF_OK ; } pck = gf_filter_pck_new_alloc ( ctx -> opid , pck_size , & output ) ; if ( ctx -> src_pck ) gf_filter_pck_merge_properties ( ctx -> src_pck , pck ) ; gf_filter_pck_set_cts ( pck , ctx -> cts ) ; gf_filter_pck_set_sap ( pck , ctx -> state . frame_state . key_frame ? GF_FILTER_SAP_1 : 0 ) ; memcpy ( output , ctx -> state . frame_obus , pck_size ) ; if ( ctx -> deps ) { u8 flags = 0 ; flags = ( ctx -> state . frame_state . key_frame ) ? 2 : 1 ; flags <<= 2 ; flags |= ctx -> state . frame_state . refresh_frame_flags ? 1 : 2 ; flags <<= 2 ; gf_filter_pck_set_dependency_flags ( pck , flags ) ; } gf_filter_pck_send ( pck ) ; av1dmx_update_cts ( ctx ) ; gf_av1_reset_state ( & ctx -> state , GF_FALSE ) ; return GF_OK ; }
","<S2SV_ModStart> u8 * output ; if ( ! ctx -> opid ) return GF_NON_COMPLIANT_BITSTREAM
"
188,"CWE-78 void imap_munge_mbox_name ( struct ImapData * idata , char * dest , size_t dlen , const char * src ) { char * buf = mutt_str_strdup ( src ) ; imap_utf_encode ( idata , & buf ) ; <S2SV_StartBug> imap_quote_string ( dest , dlen , buf ) ; <S2SV_EndBug> FREE ( & buf ) ; }
","<S2SV_ModStart> dlen , buf , false
"
189,"CWE-119 <S2SV_StartBug> static int t220_frontend_attach ( struct dvb_usb_adapter * d ) <S2SV_EndBug> { u8 obuf [ 3 ] = { 0xe , 0x87 , 0 } ; u8 ibuf [ ] = { 0 } ; <S2SV_StartBug> if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ; <S2SV_StartBug> obuf [ 0 ] = 0xe ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = 0x86 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ; <S2SV_StartBug> obuf [ 0 ] = 0xe ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = 0x80 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ; <S2SV_StartBug> msleep ( 50 ) ; <S2SV_EndBug> obuf [ 0 ] = 0xe ; obuf [ 1 ] = 0x80 ; obuf [ 2 ] = 1 ; <S2SV_StartBug> if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ; <S2SV_EndBug> obuf [ 0 ] = 0x51 ; if ( dvb_usb_generic_rw ( d -> dev , obuf , 1 , ibuf , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ; <S2SV_StartBug> d -> fe_adap [ 0 ] . fe = dvb_attach ( cxd2820r_attach , & cxd2820r_config , <S2SV_EndBug> <S2SV_StartBug> & d -> dev -> i2c_adap , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( d -> fe_adap [ 0 ] . fe != NULL ) { <S2SV_EndBug> <S2SV_StartBug> if ( dvb_attach ( tda18271_attach , d -> fe_adap [ 0 ] . fe , 0x60 , <S2SV_EndBug> <S2SV_StartBug> & d -> dev -> i2c_adap , & tda18271_config ) ) { <S2SV_EndBug> info ( ""Attached<S2SV_blank>TDA18271HD/CXD2820R!"" ) ; return 0 ; } } info ( ""Failed<S2SV_blank>to<S2SV_blank>attach<S2SV_blank>TDA18271HD/CXD2820R!"" ) ; return - EIO ; }
","<S2SV_ModStart> struct dvb_usb_adapter * adap ) { struct dvb_usb_device * d = adap -> dev ; struct dw2102_state * state = d -> priv ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x87 ; state -> data [ 2 ] = 0x0 ; if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x86 ; state -> data [ 2 ] = 1 <S2SV_ModEnd> ; if ( <S2SV_ModStart> dvb_usb_generic_rw ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0xe ; state -> data [ 1 ] = 0x80 ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> 2 ] = 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> dvb_usb_generic_rw ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ; msleep ( 50 ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0xe ; state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> = 0x80 ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> 2 ] = 1 <S2SV_ModEnd> ; if ( <S2SV_ModStart> dvb_usb_generic_rw ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ; state -> data [ 0 ] = 0x51 <S2SV_ModEnd> ; if ( <S2SV_ModStart> dvb_usb_generic_rw ( d , state -> data , 1 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> ) err ( <S2SV_ModEnd> ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ; <S2SV_ModStart> ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ; mutex_unlock ( & d -> data_mutex ) ; adap <S2SV_ModEnd> -> fe_adap [ <S2SV_ModStart> & d -> <S2SV_ModEnd> i2c_adap , NULL <S2SV_ModStart> ; if ( adap <S2SV_ModEnd> -> fe_adap [ <S2SV_ModStart> ( tda18271_attach , adap <S2SV_ModEnd> -> fe_adap [ <S2SV_ModStart> , & d <S2SV_ModEnd> -> i2c_adap ,
"
190,"CWE-000 static void sas_eh_handle_sas_errors ( struct Scsi_Host * shost , struct list_head * work_q ) { struct scsi_cmnd * cmd , * n ; enum task_disposition res = TASK_IS_DONE ; int tmf_resp , need_reset ; struct sas_internal * i = to_sas_internal ( shost -> transportt ) ; unsigned long flags ; struct sas_ha_struct * ha = SHOST_TO_SAS_HA ( shost ) ; LIST_HEAD ( done ) ; list_for_each_entry_safe ( cmd , n , work_q , eh_entry ) { struct domain_device * dev = cmd_to_domain_dev ( cmd ) ; struct sas_task * task ; spin_lock_irqsave ( & dev -> done_lock , flags ) ; task = TO_SAS_TASK ( cmd ) ; spin_unlock_irqrestore ( & dev -> done_lock , flags ) ; if ( ! task ) list_move_tail ( & cmd -> eh_entry , & done ) ; } Again : list_for_each_entry_safe ( cmd , n , work_q , eh_entry ) { struct sas_task * task = TO_SAS_TASK ( cmd ) ; list_del_init ( & cmd -> eh_entry ) ; spin_lock_irqsave ( & task -> task_state_lock , flags ) ; need_reset = task -> task_state_flags & SAS_TASK_NEED_DEV_RESET ; spin_unlock_irqrestore ( & task -> task_state_lock , flags ) ; if ( need_reset ) { SAS_DPRINTK ( ""%s:<S2SV_blank>task<S2SV_blank>0x%p<S2SV_blank>requests<S2SV_blank>reset\\n"" , __func__ , task ) ; goto reset ; } SAS_DPRINTK ( ""trying<S2SV_blank>to<S2SV_blank>find<S2SV_blank>task<S2SV_blank>0x%p\\n"" , task ) ; res = sas_scsi_find_task ( task ) ; switch ( res ) { case TASK_IS_DONE : SAS_DPRINTK ( ""%s:<S2SV_blank>task<S2SV_blank>0x%p<S2SV_blank>is<S2SV_blank>done\\n"" , __func__ , task ) ; <S2SV_StartBug> sas_eh_defer_cmd ( cmd ) ; <S2SV_EndBug> continue ; case TASK_IS_ABORTED : SAS_DPRINTK ( ""%s:<S2SV_blank>task<S2SV_blank>0x%p<S2SV_blank>is<S2SV_blank>aborted\\n"" , __func__ , task ) ; <S2SV_StartBug> sas_eh_defer_cmd ( cmd ) ; <S2SV_EndBug> continue ; case TASK_IS_AT_LU : SAS_DPRINTK ( ""task<S2SV_blank>0x%p<S2SV_blank>is<S2SV_blank>at<S2SV_blank>LU:<S2SV_blank>lu<S2SV_blank>recover\\n"" , task ) ; reset : tmf_resp = sas_recover_lu ( task -> dev , cmd ) ; if ( tmf_resp == TMF_RESP_FUNC_COMPLETE ) { SAS_DPRINTK ( ""dev<S2SV_blank>%016llx<S2SV_blank>LU<S2SV_blank>%llx<S2SV_blank>is<S2SV_blank>"" ""recovered\\n"" , SAS_ADDR ( task -> dev ) , cmd -> device -> lun ) ; <S2SV_StartBug> sas_eh_defer_cmd ( cmd ) ; <S2SV_EndBug> sas_scsi_clear_queue_lu ( work_q , cmd ) ; goto Again ; } case TASK_IS_NOT_AT_LU : case TASK_ABORT_FAILED : SAS_DPRINTK ( ""task<S2SV_blank>0x%p<S2SV_blank>is<S2SV_blank>not<S2SV_blank>at<S2SV_blank>LU:<S2SV_blank>I_T<S2SV_blank>recover\\n"" , task ) ; tmf_resp = sas_recover_I_T ( task -> dev ) ; if ( tmf_resp == TMF_RESP_FUNC_COMPLETE || tmf_resp == - ENODEV ) { struct domain_device * dev = task -> dev ; SAS_DPRINTK ( ""I_T<S2SV_blank>%016llx<S2SV_blank>recovered\\n"" , SAS_ADDR ( task -> dev -> sas_addr ) ) ; sas_eh_finish_cmd ( cmd ) ; sas_scsi_clear_queue_I_T ( work_q , dev ) ; goto Again ; } try_to_reset_cmd_device ( cmd ) ; if ( i -> dft -> lldd_clear_nexus_port ) { struct asd_sas_port * port = task -> dev -> port ; SAS_DPRINTK ( ""clearing<S2SV_blank>nexus<S2SV_blank>for<S2SV_blank>port:%d\\n"" , port -> id ) ; res = i -> dft -> lldd_clear_nexus_port ( port ) ; if ( res == TMF_RESP_FUNC_COMPLETE ) { SAS_DPRINTK ( ""clear<S2SV_blank>nexus<S2SV_blank>port:%d<S2SV_blank>"" ""succeeded\\n"" , port -> id ) ; sas_eh_finish_cmd ( cmd ) ; sas_scsi_clear_queue_port ( work_q , port ) ; goto Again ; } } if ( i -> dft -> lldd_clear_nexus_ha ) { SAS_DPRINTK ( ""clear<S2SV_blank>nexus<S2SV_blank>ha\\n"" ) ; res = i -> dft -> lldd_clear_nexus_ha ( ha ) ; if ( res == TMF_RESP_FUNC_COMPLETE ) { SAS_DPRINTK ( ""clear<S2SV_blank>nexus<S2SV_blank>ha<S2SV_blank>"" ""succeeded\\n"" ) ; sas_eh_finish_cmd ( cmd ) ; goto clear_q ; } } SAS_DPRINTK ( ""error<S2SV_blank>from<S2SV_blank><S2SV_blank>device<S2SV_blank>%llx,<S2SV_blank>LUN<S2SV_blank>%llx<S2SV_blank>"" ""couldn\'t<S2SV_blank>be<S2SV_blank>recovered<S2SV_blank>in<S2SV_blank>any<S2SV_blank>way\\n"" , SAS_ADDR ( task -> dev -> sas_addr ) , cmd -> device -> lun ) ; sas_eh_finish_cmd ( cmd ) ; goto clear_q ; } } out : list_splice_tail ( & done , work_q ) ; list_splice_tail_init ( & ha -> eh_ata_q , work_q ) ; return ; clear_q : SAS_DPRINTK ( ""---<S2SV_blank>Exit<S2SV_blank>%s<S2SV_blank>--<S2SV_blank>clear_q\\n"" , __func__ ) ; list_for_each_entry_safe ( cmd , n , work_q , eh_entry ) sas_eh_finish_cmd ( cmd ) ; goto out ; }
","<S2SV_ModStart> task ) ; sas_eh_finish_cmd <S2SV_ModEnd> ( cmd ) <S2SV_ModStart> task ) ; sas_eh_finish_cmd <S2SV_ModEnd> ( cmd ) <S2SV_ModStart> lun ) ; sas_eh_finish_cmd <S2SV_ModEnd> ( cmd )
"
191,"CWE-119 void vp8_reset_mb_tokens_context ( MACROBLOCKD * x ) { ENTROPY_CONTEXT * a_ctx = ( ( ENTROPY_CONTEXT * ) x -> above_context ) ; ENTROPY_CONTEXT * l_ctx = ( ( ENTROPY_CONTEXT * ) x -> left_context ) ; <S2SV_StartBug> vpx_memset ( a_ctx , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( l_ctx , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) - 1 ) ; <S2SV_EndBug> if ( ! x -> mode_info_context -> mbmi . is_4x4 ) { a_ctx [ 8 ] = l_ctx [ 8 ] = 0 ; } }
","<S2SV_ModStart> left_context ) ; memset <S2SV_ModEnd> ( a_ctx , <S2SV_ModStart> 1 ) ; memset <S2SV_ModEnd> ( l_ctx ,
"
192,"CWE-200 static unsigned create_oops_dump_dirs ( GList * oops_list , unsigned oops_cnt ) { unsigned countdown = MAX_DUMPED_DD_COUNT ; log_notice ( ""Saving<S2SV_blank>%u<S2SV_blank>oopses<S2SV_blank>as<S2SV_blank>problem<S2SV_blank>dirs"" , oops_cnt >= countdown ? countdown : oops_cnt ) ; char * cmdline_str = xmalloc_fopen_fgetline_fclose ( ""/proc/cmdline"" ) ; char * fips_enabled = xmalloc_fopen_fgetline_fclose ( ""/proc/sys/crypto/fips_enabled"" ) ; char * proc_modules = xmalloc_open_read_close ( ""/proc/modules"" , NULL ) ; char * suspend_stats = xmalloc_open_read_close ( ""/sys/kernel/debug/suspend_stats"" , NULL ) ; time_t t = time ( NULL ) ; const char * iso_date = iso_date_string ( & t ) ; uid_t my_euid = ( uid_t ) - 1L ; mode_t mode = DEFAULT_DUMP_DIR_MODE | S_IROTH ; if ( ! world_readable_dump ) { mode = DEFAULT_DUMP_DIR_MODE ; my_euid = geteuid ( ) ; } <S2SV_StartBug> pid_t my_pid = getpid ( ) ; <S2SV_EndBug> unsigned idx = 0 ; unsigned errors = 0 ; while ( idx < oops_cnt ) { char base [ sizeof ( ""oops-YYYY-MM-DD-hh:mm:ss-%lu-%lu"" ) + 2 * sizeof ( long ) * 3 ] ; sprintf ( base , ""oops-%s-%lu-%lu"" , iso_date , ( long ) my_pid , ( long ) idx ) ; char * path = concat_path_file ( debug_dumps_dir , base ) ; struct dump_dir * dd = dd_create ( path , my_euid , mode ) ; if ( dd ) { dd_create_basic_files ( dd , my_euid , NULL ) ; save_oops_data_in_dump_dir ( dd , ( char * ) g_list_nth_data ( oops_list , idx ++ ) , proc_modules ) ; dd_save_text ( dd , FILENAME_ABRT_VERSION , VERSION ) ; dd_save_text ( dd , FILENAME_ANALYZER , ""Kerneloops"" ) ; dd_save_text ( dd , FILENAME_TYPE , ""Kerneloops"" ) ; if ( cmdline_str ) dd_save_text ( dd , FILENAME_CMDLINE , cmdline_str ) ; if ( proc_modules ) dd_save_text ( dd , ""proc_modules"" , proc_modules ) ; if ( fips_enabled && strcmp ( fips_enabled , ""0"" ) != 0 ) dd_save_text ( dd , ""fips_enabled"" , fips_enabled ) ; if ( suspend_stats ) dd_save_text ( dd , ""suspend_stats"" , suspend_stats ) ; dd_close ( dd ) ; notify_new_path ( path ) ; } else errors ++ ; free ( path ) ; if ( -- countdown == 0 ) break ; if ( dd && throttle_dd_creation ) sleep ( 1 ) ; } free ( cmdline_str ) ; free ( proc_modules ) ; free ( fips_enabled ) ; free ( suspend_stats ) ; return errors ; }
","<S2SV_ModStart> ) ; } if ( g_settings_privatereports ) { if ( world_readable_dump ) log ( ""Not<S2SV_blank>going<S2SV_blank>to<S2SV_blank>make<S2SV_blank>dump<S2SV_blank>directories<S2SV_blank>world<S2SV_blank>readable<S2SV_blank>because<S2SV_blank>PrivateReports<S2SV_blank>is<S2SV_blank>on"" ) ; mode = DEFAULT_DUMP_DIR_MODE ; my_euid = 0 ; }
"
193,"CWE-20 static int lz4_uncompress ( const char * source , char * dest , int osize ) { const BYTE * ip = ( const BYTE * ) source ; const BYTE * ref ; BYTE * op = ( BYTE * ) dest ; BYTE * const oend = op + osize ; BYTE * cpy ; unsigned token ; size_t length ; size_t dec32table [ ] = { 0 , 3 , 2 , 3 , 0 , 0 , 0 , 0 } ; # if LZ4_ARCH64 size_t dec64table [ ] = { 0 , 0 , 0 , - 1 , 0 , 1 , 2 , 3 } ; # endif while ( 1 ) { token = * ip ++ ; length = ( token >> ML_BITS ) ; if ( length == RUN_MASK ) { size_t len ; len = * ip ++ ; for ( ; len == 255 ; length += 255 ) len = * ip ++ ; <S2SV_StartBug> length += len ; <S2SV_EndBug> } cpy = op + length ; if ( unlikely ( cpy > oend - COPYLENGTH ) ) { if ( cpy != oend ) goto _output_error ; memcpy ( op , ip , length ) ; ip += length ; break ; } LZ4_WILDCOPY ( ip , op , cpy ) ; ip -= ( op - cpy ) ; op = cpy ; LZ4_READ_LITTLEENDIAN_16 ( ref , cpy , ip ) ; ip += 2 ; if ( unlikely ( ref < ( BYTE * const ) dest ) ) goto _output_error ; length = token & ML_MASK ; if ( length == ML_MASK ) { for ( ; * ip == 255 ; length += 255 ) ip ++ ; length += * ip ++ ; } if ( unlikely ( ( op - ref ) < STEPSIZE ) ) { # if LZ4_ARCH64 size_t dec64 = dec64table [ op - ref ] ; # else const int dec64 = 0 ; # endif op [ 0 ] = ref [ 0 ] ; op [ 1 ] = ref [ 1 ] ; op [ 2 ] = ref [ 2 ] ; op [ 3 ] = ref [ 3 ] ; op += 4 ; ref += 4 ; ref -= dec32table [ op - ref ] ; PUT4 ( ref , op ) ; op += STEPSIZE - 4 ; ref -= dec64 ; } else { LZ4_COPYSTEP ( ref , op ) ; } cpy = op + length - ( STEPSIZE - 4 ) ; if ( cpy > ( oend - COPYLENGTH ) ) { if ( cpy > oend ) goto _output_error ; LZ4_SECURECOPY ( ref , op , ( oend - COPYLENGTH ) ) ; while ( op < cpy ) * op ++ = * ref ++ ; op = cpy ; if ( op == oend ) goto _output_error ; continue ; } LZ4_SECURECOPY ( ref , op , cpy ) ; op = cpy ; } return ( int ) ( ( ( char * ) ip ) - source ) ; _output_error : return ( int ) ( - ( ( ( char * ) ip ) - source ) ) ; }
","<S2SV_ModStart> ip ++ ; if ( unlikely ( length > ( size_t ) ( length + len ) ) ) goto _output_error ;
"
194,"CWE-119 static void update_sharpness ( loop_filter_info_n * lfi , int sharpness_lvl ) { int lvl ; for ( lvl = 0 ; lvl <= MAX_LOOP_FILTER ; lvl ++ ) { int block_inside_limit = lvl >> ( ( sharpness_lvl > 0 ) + ( sharpness_lvl > 4 ) ) ; if ( sharpness_lvl > 0 ) { if ( block_inside_limit > ( 9 - sharpness_lvl ) ) block_inside_limit = ( 9 - sharpness_lvl ) ; } if ( block_inside_limit < 1 ) block_inside_limit = 1 ; <S2SV_StartBug> vpx_memset ( lfi -> lfthr [ lvl ] . lim , block_inside_limit , SIMD_WIDTH ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( lfi -> lfthr [ lvl ] . mblim , ( 2 * ( lvl + 2 ) + block_inside_limit ) , <S2SV_EndBug> SIMD_WIDTH ) ; } }
","<S2SV_ModStart> = 1 ; memset <S2SV_ModEnd> ( lfi -> <S2SV_ModStart> SIMD_WIDTH ) ; memset <S2SV_ModEnd> ( lfi ->
"
195,"CWE-125 static void <S2SV_StartBug> l2tp_bearer_type_print ( netdissect_options * ndo , const u_char * dat ) <S2SV_EndBug> { <S2SV_StartBug> const uint32_t * ptr = ( const uint32_t * ) dat ; <S2SV_EndBug> if ( EXTRACT_32BITS ( ptr ) & L2TP_BEARER_TYPE_ANALOG_MASK ) { ND_PRINT ( ( ndo , ""A"" ) ) ; } if ( EXTRACT_32BITS ( ptr ) & L2TP_BEARER_TYPE_DIGITAL_MASK ) { ND_PRINT ( ( ndo , ""D"" ) ) ; } }
","<S2SV_ModStart> u_char * dat , u_int length <S2SV_ModStart> ) dat ; if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; }
"
196,"CWE-189 void dwc3_gadget_giveback ( struct dwc3_ep * dep , struct dwc3_request * req , int status ) { struct dwc3 * dwc = dep -> dwc ; <S2SV_StartBug> req -> started = false ; <S2SV_EndBug> list_del ( & req -> list ) ; req -> remaining = 0 ; if ( req -> request . status == - EINPROGRESS ) req -> request . status = status ; if ( req -> trb ) usb_gadget_unmap_request_by_dev ( dwc -> sysdev , & req -> request , req -> direction ) ; req -> trb = NULL ; trace_dwc3_gadget_giveback ( req ) ; spin_unlock ( & dwc -> lock ) ; usb_gadget_giveback_request ( & dep -> endpoint , & req -> request ) ; spin_lock ( & dwc -> lock ) ; <S2SV_StartBug> if ( dep -> number > 1 ) <S2SV_EndBug> pm_runtime_put ( dwc -> dev ) ; }
","<S2SV_ModStart> -> dwc ; dwc3_gadget_del_and_unmap_request ( dep , req , status <S2SV_ModEnd> ) ; spin_unlock <S2SV_ModStart> lock ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
"
197,"CWE-119 static int dtls1_buffer_record ( SSL * s , record_pqueue * queue , unsigned char * priority ) { DTLS1_RECORD_DATA * rdata ; pitem * item ; if ( pqueue_size ( queue -> q ) >= 100 ) return 0 ; rdata = OPENSSL_malloc ( sizeof ( DTLS1_RECORD_DATA ) ) ; item = pitem_new ( priority , rdata ) ; if ( rdata == NULL || item == NULL ) { if ( rdata != NULL ) OPENSSL_free ( rdata ) ; if ( item != NULL ) pitem_free ( item ) ; SSLerr ( SSL_F_DTLS1_BUFFER_RECORD , ERR_R_INTERNAL_ERROR ) ; return ( 0 ) ; } rdata -> packet = s -> packet ; rdata -> packet_length = s -> packet_length ; memcpy ( & ( rdata -> rbuf ) , & ( s -> s3 -> rbuf ) , sizeof ( SSL3_BUFFER ) ) ; memcpy ( & ( rdata -> rrec ) , & ( s -> s3 -> rrec ) , sizeof ( SSL3_RECORD ) ) ; item -> data = rdata ; # ifndef OPENSSL_NO_SCTP if ( BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) && ( s -> state == SSL3_ST_SR_FINISHED_A || s -> state == SSL3_ST_CR_FINISHED_A ) ) { BIO_ctrl ( SSL_get_rbio ( s ) , BIO_CTRL_DGRAM_SCTP_GET_RCVINFO , sizeof ( rdata -> recordinfo ) , & rdata -> recordinfo ) ; } # endif s -> packet = NULL ; s -> packet_length = 0 ; memset ( & ( s -> s3 -> rbuf ) , 0 , sizeof ( SSL3_BUFFER ) ) ; memset ( & ( s -> s3 -> rrec ) , 0 , sizeof ( SSL3_RECORD ) ) ; if ( ! ssl3_setup_buffers ( s ) ) { SSLerr ( SSL_F_DTLS1_BUFFER_RECORD , ERR_R_INTERNAL_ERROR ) ; <S2SV_StartBug> OPENSSL_free ( rdata ) ; <S2SV_EndBug> pitem_free ( item ) ; <S2SV_StartBug> return ( 0 ) ; <S2SV_EndBug> } if ( pqueue_insert ( queue -> q , item ) == NULL ) { SSLerr ( SSL_F_DTLS1_BUFFER_RECORD , ERR_R_INTERNAL_ERROR ) ; <S2SV_StartBug> OPENSSL_free ( rdata ) ; <S2SV_EndBug> pitem_free ( item ) ; <S2SV_StartBug> return ( 0 ) ; <S2SV_EndBug> } return ( 1 ) ; }
","<S2SV_ModStart> ERR_R_INTERNAL_ERROR ) ; if ( rdata -> rbuf . buf != NULL ) <S2SV_ModStart> OPENSSL_free ( rdata -> rbuf . buf ) ; OPENSSL_free ( rdata <S2SV_ModStart> ; return ( - 1 <S2SV_ModEnd> ) ; } <S2SV_ModStart> ERR_R_INTERNAL_ERROR ) ; if ( rdata -> rbuf . buf != NULL ) <S2SV_ModStart> OPENSSL_free ( rdata -> rbuf . buf ) ; OPENSSL_free ( rdata <S2SV_ModStart> ; return ( - 1 <S2SV_ModEnd> ) ; }
"
198,"CWE-416 static OPJ_BOOL opj_j2k_write_mco ( opj_j2k_t * p_j2k , struct opj_stream_private * p_stream , struct opj_event_mgr * p_manager ) { OPJ_BYTE * l_current_data = 00 ; OPJ_UINT32 l_mco_size ; opj_tcp_t * l_tcp = 00 ; opj_simple_mcc_decorrelation_data_t * l_mcc_record ; OPJ_UINT32 i ; assert ( p_j2k != 00 ) ; assert ( p_manager != 00 ) ; assert ( p_stream != 00 ) ; l_tcp = & ( p_j2k -> m_cp . tcps [ p_j2k -> m_current_tile_number ] ) ; <S2SV_StartBug> l_current_data = p_j2k -> m_specific_param . m_encoder . m_header_tile_data ; <S2SV_EndBug> l_mco_size = 5 + l_tcp -> m_nb_mcc_records ; if ( l_mco_size > p_j2k -> m_specific_param . m_encoder . m_header_tile_data_size ) { OPJ_BYTE * new_header_tile_data = ( OPJ_BYTE * ) opj_realloc ( p_j2k -> m_specific_param . m_encoder . m_header_tile_data , l_mco_size ) ; if ( ! new_header_tile_data ) { opj_free ( p_j2k -> m_specific_param . m_encoder . m_header_tile_data ) ; p_j2k -> m_specific_param . m_encoder . m_header_tile_data = NULL ; p_j2k -> m_specific_param . m_encoder . m_header_tile_data_size = 0 ; opj_event_msg ( p_manager , EVT_ERROR , ""Not<S2SV_blank>enough<S2SV_blank>memory<S2SV_blank>to<S2SV_blank>write<S2SV_blank>MCO<S2SV_blank>marker\\n"" ) ; return OPJ_FALSE ; } p_j2k -> m_specific_param . m_encoder . m_header_tile_data = new_header_tile_data ; p_j2k -> m_specific_param . m_encoder . m_header_tile_data_size = l_mco_size ; } <S2SV_StartBug> opj_write_bytes ( l_current_data , J2K_MS_MCO , 2 ) ; <S2SV_EndBug> l_current_data += 2 ; opj_write_bytes ( l_current_data , l_mco_size - 2 , 2 ) ; l_current_data += 2 ; opj_write_bytes ( l_current_data , l_tcp -> m_nb_mcc_records , 1 ) ; ++ l_current_data ; l_mcc_record = l_tcp -> m_mcc_records ; for ( i = 0 ; i < l_tcp -> m_nb_mcc_records ; ++ i ) { opj_write_bytes ( l_current_data , l_mcc_record -> m_index , 1 ) ; ++ l_current_data ; ++ l_mcc_record ; } if ( opj_stream_write_data ( p_stream , p_j2k -> m_specific_param . m_encoder . m_header_tile_data , l_mco_size , p_manager ) != l_mco_size ) { return OPJ_FALSE ; } return OPJ_TRUE ; }
","<S2SV_ModStart> ] ) ; <S2SV_ModEnd> l_mco_size = 5 <S2SV_ModStart> l_mco_size ; } l_current_data = p_j2k -> m_specific_param . m_encoder . m_header_tile_data ;
"
199,"CWE-264 <S2SV_StartBug> int xt_check_entry_offsets ( const void * base , <S2SV_EndBug> unsigned int target_offset , unsigned int next_offset ) { <S2SV_StartBug> const struct xt_entry_target * t ; <S2SV_EndBug> <S2SV_StartBug> const char * e = base ; <S2SV_EndBug> if ( target_offset + sizeof ( * t ) > next_offset ) return - EINVAL ; t = ( void * ) ( e + target_offset ) ; if ( t -> u . target_size < sizeof ( * t ) ) return - EINVAL ; if ( target_offset + t -> u . target_size > next_offset ) return - EINVAL ; if ( strcmp ( t -> u . user . name , XT_STANDARD_TARGET ) == 0 && target_offset + sizeof ( struct xt_standard_target ) != next_offset ) return - EINVAL ; return 0 ; }
","<S2SV_ModStart> void * base , const char * elems <S2SV_ModStart> next_offset ) { long size_of_base_struct = elems - ( const char * ) base ; <S2SV_ModStart> e = base ; if ( target_offset < size_of_base_struct ) return - EINVAL
"
200,"CWE-119 static int PredictorEncodeRow ( TIFF * tif , uint8 * bp , tmsize_t cc , uint16 s ) { TIFFPredictorState * sp = PredictorState ( tif ) ; assert ( sp != NULL ) ; assert ( sp -> encodepfunc != NULL ) ; assert ( sp -> encoderow != NULL ) ; <S2SV_StartBug> ( * sp -> encodepfunc ) ( tif , bp , cc ) ; <S2SV_EndBug> return ( * sp -> encoderow ) ( tif , bp , cc , s ) ; }
","<S2SV_ModStart> NULL ) ; if ( ! <S2SV_ModStart> , cc ) ) return 0
"
201,"CWE-000 static krb5_error_code process_db_args ( krb5_context context , char * * db_args , xargs_t * xargs , OPERATION optype ) { int i = 0 ; krb5_error_code st = 0 ; char * arg = NULL , * arg_val = NULL ; char * * dptr = NULL ; unsigned int arg_val_len = 0 ; if ( db_args ) { for ( i = 0 ; db_args [ i ] ; ++ i ) { arg = strtok_r ( db_args [ i ] , ""="" , & arg_val ) ; <S2SV_StartBug> if ( strcmp ( arg , TKTPOLICY_ARG ) == 0 ) { <S2SV_EndBug> dptr = & xargs -> tktpolicydn ; } else { if ( strcmp ( arg , USERDN_ARG ) == 0 ) { if ( optype == MODIFY_PRINCIPAL || xargs -> dn != NULL || xargs -> containerdn != NULL || xargs -> linkdn != NULL ) { st = EINVAL ; k5_setmsg ( context , st , _ ( ""%s<S2SV_blank>option<S2SV_blank>not<S2SV_blank>supported"" ) , arg ) ; goto cleanup ; } dptr = & xargs -> dn ; } else if ( strcmp ( arg , CONTAINERDN_ARG ) == 0 ) { if ( optype == MODIFY_PRINCIPAL || xargs -> dn != NULL || xargs -> containerdn != NULL ) { st = EINVAL ; k5_setmsg ( context , st , _ ( ""%s<S2SV_blank>option<S2SV_blank>not<S2SV_blank>supported"" ) , arg ) ; goto cleanup ; } dptr = & xargs -> containerdn ; } else if ( strcmp ( arg , LINKDN_ARG ) == 0 ) { if ( xargs -> dn != NULL || xargs -> linkdn != NULL ) { st = EINVAL ; k5_setmsg ( context , st , _ ( ""%s<S2SV_blank>option<S2SV_blank>not<S2SV_blank>supported"" ) , arg ) ; goto cleanup ; } dptr = & xargs -> linkdn ; } else { st = EINVAL ; k5_setmsg ( context , st , _ ( ""unknown<S2SV_blank>option:<S2SV_blank>%s"" ) , arg ) ; goto cleanup ; } xargs -> dn_from_kbd = TRUE ; if ( arg_val == NULL || strlen ( arg_val ) == 0 ) { st = EINVAL ; k5_setmsg ( context , st , _ ( ""%s<S2SV_blank>option<S2SV_blank>value<S2SV_blank>missing"" ) , arg ) ; goto cleanup ; } } if ( arg_val == NULL ) { st = EINVAL ; k5_setmsg ( context , st , _ ( ""%s<S2SV_blank>option<S2SV_blank>value<S2SV_blank>missing"" ) , arg ) ; goto cleanup ; } arg_val_len = strlen ( arg_val ) + 1 ; if ( strcmp ( arg , TKTPOLICY_ARG ) == 0 ) { if ( ( st = krb5_ldap_name_to_policydn ( context , arg_val , dptr ) ) != 0 ) goto cleanup ; } else { * dptr = k5memdup ( arg_val , arg_val_len , & st ) ; if ( * dptr == NULL ) goto cleanup ; } } } cleanup : return st ; }
","<S2SV_ModStart> arg_val ) ; arg = ( arg != NULL ) ? arg : """" ;
"
202,"CWE-119 static void numtostr ( js_State * J , const char * fmt , int w , double n ) { <S2SV_StartBug> char buf [ 32 ] , * e ; <S2SV_EndBug> sprintf ( buf , fmt , w , n ) ; e = strchr ( buf , 'e' ) ; if ( e ) { int exp = atoi ( e + 1 ) ; sprintf ( e , ""e%+d"" , exp ) ; } js_pushstring ( J , buf ) ; }
","<S2SV_ModStart> char buf [ 50 <S2SV_ModEnd> ] , *
"
203,"CWE-22 static int pop_fetch_headers ( struct Context * ctx ) { struct PopData * pop_data = ( struct PopData * ) ctx -> data ; struct Progress progress ; # ifdef USE_HCACHE header_cache_t * hc = pop_hcache_open ( pop_data , ctx -> path ) ; # endif time ( & pop_data -> check_time ) ; pop_data -> clear_cache = false ; for ( int i = 0 ; i < ctx -> msgcount ; i ++ ) ctx -> hdrs [ i ] -> refno = - 1 ; const int old_count = ctx -> msgcount ; int ret = pop_fetch_data ( pop_data , ""UIDL\\r\\n"" , NULL , fetch_uidl , ctx ) ; const int new_count = ctx -> msgcount ; ctx -> msgcount = old_count ; if ( pop_data -> cmd_uidl == 2 ) { if ( ret == 0 ) { pop_data -> cmd_uidl = 1 ; mutt_debug ( 1 , ""set<S2SV_blank>UIDL<S2SV_blank>capability\\n"" ) ; } if ( ret == - 2 && pop_data -> cmd_uidl == 2 ) { pop_data -> cmd_uidl = 0 ; mutt_debug ( 1 , ""unset<S2SV_blank>UIDL<S2SV_blank>capability\\n"" ) ; snprintf ( pop_data -> err_msg , sizeof ( pop_data -> err_msg ) , ""%s"" , _ ( ""Command<S2SV_blank>UIDL<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>server."" ) ) ; } } if ( ! ctx -> quiet ) { mutt_progress_init ( & progress , _ ( ""Fetching<S2SV_blank>message<S2SV_blank>headers..."" ) , MUTT_PROGRESS_MSG , ReadInc , new_count - old_count ) ; } if ( ret == 0 ) { int i , deleted ; for ( i = 0 , deleted = 0 ; i < old_count ; i ++ ) { if ( ctx -> hdrs [ i ] -> refno == - 1 ) { ctx -> hdrs [ i ] -> deleted = true ; deleted ++ ; } } if ( deleted > 0 ) { mutt_error ( ngettext ( ""%d<S2SV_blank>message<S2SV_blank>has<S2SV_blank>been<S2SV_blank>lost.<S2SV_blank>Try<S2SV_blank>reopening<S2SV_blank>the<S2SV_blank>mailbox."" , ""%d<S2SV_blank>messages<S2SV_blank>have<S2SV_blank>been<S2SV_blank>lost.<S2SV_blank>Try<S2SV_blank>reopening<S2SV_blank>the<S2SV_blank>mailbox."" , deleted ) , deleted ) ; } bool hcached = false ; for ( i = old_count ; i < new_count ; i ++ ) { if ( ! ctx -> quiet ) mutt_progress_update ( & progress , i + 1 - old_count , - 1 ) ; # ifdef USE_HCACHE void * data = mutt_hcache_fetch ( hc , ctx -> hdrs [ i ] -> data , strlen ( ctx -> hdrs [ i ] -> data ) ) ; if ( data ) { char * uidl = mutt_str_strdup ( ctx -> hdrs [ i ] -> data ) ; int refno = ctx -> hdrs [ i ] -> refno ; int index = ctx -> hdrs [ i ] -> index ; struct Header * h = mutt_hcache_restore ( ( unsigned char * ) data ) ; mutt_hcache_free ( hc , & data ) ; mutt_header_free ( & ctx -> hdrs [ i ] ) ; ctx -> hdrs [ i ] = h ; ctx -> hdrs [ i ] -> refno = refno ; ctx -> hdrs [ i ] -> index = index ; ctx -> hdrs [ i ] -> data = uidl ; ret = 0 ; hcached = true ; } else # endif if ( ( ret = pop_read_header ( pop_data , ctx -> hdrs [ i ] ) ) < 0 ) break ; # ifdef USE_HCACHE else { mutt_hcache_store ( hc , ctx -> hdrs [ i ] -> data , strlen ( ctx -> hdrs [ i ] -> data ) , ctx -> hdrs [ i ] , 0 ) ; } # endif const bool bcached = <S2SV_StartBug> ( mutt_bcache_exists ( pop_data -> bcache , ctx -> hdrs [ i ] -> data ) == 0 ) ; <S2SV_EndBug> ctx -> hdrs [ i ] -> old = false ; ctx -> hdrs [ i ] -> read = false ; if ( hcached ) { if ( bcached ) ctx -> hdrs [ i ] -> read = true ; else if ( MarkOld ) ctx -> hdrs [ i ] -> old = true ; } else { if ( bcached ) ctx -> hdrs [ i ] -> read = true ; } ctx -> msgcount ++ ; } if ( i > old_count ) mx_update_context ( ctx , i - old_count ) ; } # ifdef USE_HCACHE mutt_hcache_close ( hc ) ; # endif if ( ret < 0 ) { for ( int i = ctx -> msgcount ; i < new_count ; i ++ ) mutt_header_free ( & ctx -> hdrs [ i ] ) ; return ret ; } if ( MessageCacheClean ) mutt_bcache_list ( pop_data -> bcache , msg_cache_check , ( void * ) ctx ) ; mutt_clear_error ( ) ; return ( new_count - old_count ) ; }
","<S2SV_ModStart> -> bcache , cache_id ( ctx -> hdrs [ i ] -> data ) <S2SV_ModEnd> ) == 0
"
204,"CWE-119 static ssize_t wdm_read ( struct file * file , char __user * buffer , size_t count , loff_t * ppos ) { int rv , cntr ; int i = 0 ; struct wdm_device * desc = file -> private_data ; rv = mutex_lock_interruptible ( & desc -> rlock ) ; if ( rv < 0 ) return - ERESTARTSYS ; cntr = ACCESS_ONCE ( desc -> length ) ; if ( cntr == 0 ) { desc -> read = 0 ; retry : if ( test_bit ( WDM_DISCONNECTING , & desc -> flags ) ) { rv = - ENODEV ; goto err ; } <S2SV_StartBug> i ++ ; <S2SV_EndBug> if ( file -> f_flags & O_NONBLOCK ) { if ( ! test_bit ( WDM_READ , & desc -> flags ) ) { rv = cntr ? cntr : - EAGAIN ; goto err ; } rv = 0 ; } else { rv = wait_event_interruptible ( desc -> wait , test_bit ( WDM_READ , & desc -> flags ) ) ; } if ( test_bit ( WDM_DISCONNECTING , & desc -> flags ) ) { rv = - ENODEV ; goto err ; } if ( test_bit ( WDM_RESETTING , & desc -> flags ) ) { rv = - EIO ; goto err ; } usb_mark_last_busy ( interface_to_usbdev ( desc -> intf ) ) ; if ( rv < 0 ) { rv = - ERESTARTSYS ; goto err ; } spin_lock_irq ( & desc -> iuspin ) ; if ( desc -> rerr ) { desc -> rerr = 0 ; spin_unlock_irq ( & desc -> iuspin ) ; rv = - EIO ; goto err ; } if ( ! test_bit ( WDM_READ , & desc -> flags ) ) { spin_unlock_irq ( & desc -> iuspin ) ; goto retry ; } if ( ! desc -> reslength ) { dev_dbg ( & desc -> intf -> dev , ""%s:<S2SV_blank>zero<S2SV_blank>length<S2SV_blank>-<S2SV_blank>clearing<S2SV_blank>WDM_READ\\n"" , __func__ ) ; clear_bit ( WDM_READ , & desc -> flags ) ; spin_unlock_irq ( & desc -> iuspin ) ; goto retry ; } cntr = desc -> length ; spin_unlock_irq ( & desc -> iuspin ) ; } if ( cntr > count ) cntr = count ; rv = copy_to_user ( buffer , desc -> ubuf , cntr ) ; if ( rv > 0 ) { rv = - EFAULT ; goto err ; } spin_lock_irq ( & desc -> iuspin ) ; for ( i = 0 ; i < desc -> length - cntr ; i ++ ) desc -> ubuf [ i ] = desc -> ubuf [ i + cntr ] ; desc -> length -= cntr ; if ( ! desc -> length ) clear_bit ( WDM_READ , & desc -> flags ) ; spin_unlock_irq ( & desc -> iuspin ) ; rv = cntr ; err : mutex_unlock ( & desc -> rlock ) ; return rv ; }
","<S2SV_ModStart> err ; } if ( test_bit ( WDM_OVERFLOW , & desc -> flags ) ) { clear_bit ( WDM_OVERFLOW , & desc -> flags ) ; rv = - ENOBUFS ; goto err ; }
"
205,"CWE-476 static int peer_recv_callback ( rdpTransport * transport , wStream * s , void * extra ) { freerdp_peer * client = ( freerdp_peer * ) extra ; rdpRdp * rdp = client -> context -> rdp ; switch ( rdp -> state ) { case CONNECTION_STATE_INITIAL : if ( ! rdp_server_accept_nego ( rdp , s ) ) return - 1 ; if ( rdp -> nego -> selected_protocol & PROTOCOL_NLA ) { sspi_CopyAuthIdentity ( & client -> identity , & ( rdp -> nego -> transport -> credssp -> identity ) ) ; IFCALLRET ( client -> Logon , client -> authenticated , client , & client -> identity , TRUE ) ; credssp_free ( rdp -> nego -> transport -> credssp ) ; <S2SV_StartBug> } <S2SV_EndBug> else { IFCALLRET ( client -> Logon , client -> authenticated , client , & client -> identity , FALSE ) ; } break ; case CONNECTION_STATE_NEGO : if ( ! rdp_server_accept_mcs_connect_initial ( rdp , s ) ) return - 1 ; break ; case CONNECTION_STATE_MCS_CONNECT : if ( ! rdp_server_accept_mcs_erect_domain_request ( rdp , s ) ) return - 1 ; break ; case CONNECTION_STATE_MCS_ERECT_DOMAIN : if ( ! rdp_server_accept_mcs_attach_user_request ( rdp , s ) ) return - 1 ; break ; case CONNECTION_STATE_MCS_ATTACH_USER : if ( ! rdp_server_accept_mcs_channel_join_request ( rdp , s ) ) return - 1 ; break ; case CONNECTION_STATE_MCS_CHANNEL_JOIN : if ( rdp -> settings -> DisableEncryption ) { if ( ! rdp_server_accept_client_keys ( rdp , s ) ) return - 1 ; break ; } rdp -> state = CONNECTION_STATE_ESTABLISH_KEYS ; case CONNECTION_STATE_ESTABLISH_KEYS : if ( ! rdp_server_accept_client_info ( rdp , s ) ) return - 1 ; IFCALL ( client -> Capabilities , client ) ; if ( ! rdp_send_demand_active ( rdp ) ) return - 1 ; break ; case CONNECTION_STATE_LICENSE : if ( ! rdp_server_accept_confirm_active ( rdp , s ) ) { Stream_SetPosition ( s , 0 ) ; return peer_recv_pdu ( client , s ) ; } break ; case CONNECTION_STATE_ACTIVE : if ( peer_recv_pdu ( client , s ) < 0 ) return - 1 ; break ; default : fprintf ( stderr , ""Invalid<S2SV_blank>state<S2SV_blank>%d\\n"" , rdp -> state ) ; return - 1 ; } return 0 ; }
","<S2SV_ModStart> credssp ) ; rdp -> nego -> transport -> credssp = NULL ;
"
206,"CWE-119 static int filter_frame ( AVFilterLink * inlink , AVFrame * frame ) { AVFilterContext * ctx = inlink -> dst ; const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( inlink -> format ) ; uint32_t plane_checksum [ 4 ] = { 0 } , checksum = 0 ; int i , plane , vsub = desc -> log2_chroma_h ; <S2SV_StartBug> for ( plane = 0 ; plane < 4 && frame -> data [ plane ] ; plane ++ ) { <S2SV_EndBug> int64_t linesize = av_image_get_linesize ( frame -> format , frame -> width , plane ) ; uint8_t * data = frame -> data [ plane ] ; int h = plane == 1 || plane == 2 ? FF_CEIL_RSHIFT ( inlink -> h , vsub ) : inlink -> h ; if ( linesize < 0 ) return linesize ; for ( i = 0 ; i < h ; i ++ ) { plane_checksum [ plane ] = av_adler32_update ( plane_checksum [ plane ] , data , linesize ) ; checksum = av_adler32_update ( checksum , data , linesize ) ; data += frame -> linesize [ plane ] ; } } av_log ( ctx , AV_LOG_INFO , ""n:%"" PRId64 ""<S2SV_blank>pts:%s<S2SV_blank>pts_time:%s<S2SV_blank>pos:%"" PRId64 ""<S2SV_blank>"" ""fmt:%s<S2SV_blank>sar:%d/%d<S2SV_blank>s:%dx%d<S2SV_blank>i:%c<S2SV_blank>iskey:%d<S2SV_blank>type:%c<S2SV_blank>"" ""checksum:%08X<S2SV_blank>plane_checksum:[%08X"" , inlink -> frame_count , av_ts2str ( frame -> pts ) , av_ts2timestr ( frame -> pts , & inlink -> time_base ) , av_frame_get_pkt_pos ( frame ) , desc -> name , frame -> sample_aspect_ratio . num , frame -> sample_aspect_ratio . den , frame -> width , frame -> height , ! frame -> interlaced_frame ? 'P' : frame -> top_field_first ? 'T' : 'B' , frame -> key_frame , av_get_picture_type_char ( frame -> pict_type ) , checksum , plane_checksum [ 0 ] ) ; <S2SV_StartBug> for ( plane = 1 ; plane < 4 && frame -> data [ plane ] ; plane ++ ) <S2SV_EndBug> av_log ( ctx , AV_LOG_INFO , ""<S2SV_blank>%08X"" , plane_checksum [ plane ] ) ; av_log ( ctx , AV_LOG_INFO , ""]\\n"" ) ; return ff_filter_frame ( inlink -> dst -> outputs [ 0 ] , frame ) ; }
","<S2SV_ModStart> frame -> data [ plane ] && frame -> linesize <S2SV_ModStart> [ plane ] && frame -> linesize [ plane ]
"
207,"CWE-754 void sqlite3Pragma ( Parse * pParse , Token * pId1 , Token * pId2 , Token * pValue , int minusFlag ) { char * zLeft = 0 ; char * zRight = 0 ; const char * zDb = 0 ; Token * pId ; char * aFcntl [ 4 ] ; int iDb ; int rc ; sqlite3 * db = pParse -> db ; Db * pDb ; Vdbe * v = sqlite3GetVdbe ( pParse ) ; const PragmaName * pPragma ; if ( v == 0 ) return ; sqlite3VdbeRunOnlyOnce ( v ) ; pParse -> nMem = 2 ; iDb = sqlite3TwoPartName ( pParse , pId1 , pId2 , & pId ) ; if ( iDb < 0 ) return ; pDb = & db -> aDb [ iDb ] ; if ( iDb == 1 && sqlite3OpenTempDatabase ( pParse ) ) { return ; } zLeft = sqlite3NameFromToken ( db , pId ) ; if ( ! zLeft ) return ; if ( minusFlag ) { zRight = sqlite3MPrintf ( db , ""-%T"" , pValue ) ; } else { zRight = sqlite3NameFromToken ( db , pValue ) ; } assert ( pId2 ) ; zDb = pId2 -> n > 0 ? pDb -> zDbSName : 0 ; if ( sqlite3AuthCheck ( pParse , SQLITE_PRAGMA , zLeft , zRight , zDb ) ) { goto pragma_out ; } aFcntl [ 0 ] = 0 ; aFcntl [ 1 ] = zLeft ; aFcntl [ 2 ] = zRight ; aFcntl [ 3 ] = 0 ; db -> busyHandler . nBusy = 0 ; rc = sqlite3_file_control ( db , zDb , SQLITE_FCNTL_PRAGMA , ( void * ) aFcntl ) ; if ( rc == SQLITE_OK ) { sqlite3VdbeSetNumCols ( v , 1 ) ; sqlite3VdbeSetColName ( v , 0 , COLNAME_NAME , aFcntl [ 0 ] , SQLITE_TRANSIENT ) ; returnSingleText ( v , aFcntl [ 0 ] ) ; sqlite3_free ( aFcntl [ 0 ] ) ; goto pragma_out ; } if ( rc != SQLITE_NOTFOUND ) { if ( aFcntl [ 0 ] ) { sqlite3ErrorMsg ( pParse , ""%s"" , aFcntl [ 0 ] ) ; sqlite3_free ( aFcntl [ 0 ] ) ; } pParse -> nErr ++ ; pParse -> rc = rc ; goto pragma_out ; } pPragma = pragmaLocate ( zLeft ) ; if ( pPragma == 0 ) goto pragma_out ; if ( ( pPragma -> mPragFlg & PragFlg_NeedSchema ) != 0 ) { if ( sqlite3ReadSchema ( pParse ) ) goto pragma_out ; } if ( ( pPragma -> mPragFlg & PragFlg_NoColumns ) == 0 && ( ( pPragma -> mPragFlg & PragFlg_NoColumns1 ) == 0 || zRight == 0 ) ) { setPragmaResultColumnNames ( v , pPragma ) ; } switch ( pPragma -> ePragTyp ) { # if ! defined ( SQLITE_OMIT_PAGER_PRAGMAS ) && ! defined ( SQLITE_OMIT_DEPRECATED ) case PragTyp_DEFAULT_CACHE_SIZE : { static const int iLn = VDBE_OFFSET_LINENO ( 2 ) ; static const VdbeOpList getCacheSize [ ] = { { OP_Transaction , 0 , 0 , 0 } , { OP_ReadCookie , 0 , 1 , BTREE_DEFAULT_CACHE_SIZE } , { OP_IfPos , 1 , 8 , 0 } , { OP_Integer , 0 , 2 , 0 } , { OP_Subtract , 1 , 2 , 1 } , { OP_IfPos , 1 , 8 , 0 } , { OP_Integer , 0 , 1 , 0 } , { OP_Noop , 0 , 0 , 0 } , { OP_ResultRow , 1 , 1 , 0 } , } ; VdbeOp * aOp ; sqlite3VdbeUsesBtree ( v , iDb ) ; if ( ! zRight ) { pParse -> nMem += 2 ; sqlite3VdbeVerifyNoMallocRequired ( v , ArraySize ( getCacheSize ) ) ; aOp = sqlite3VdbeAddOpList ( v , ArraySize ( getCacheSize ) , getCacheSize , iLn ) ; if ( ONLY_IF_REALLOC_STRESS ( aOp == 0 ) ) break ; aOp [ 0 ] . p1 = iDb ; aOp [ 1 ] . p1 = iDb ; aOp [ 6 ] . p1 = SQLITE_DEFAULT_CACHE_SIZE ; } else { int size = sqlite3AbsInt32 ( sqlite3Atoi ( zRight ) ) ; sqlite3BeginWriteOperation ( pParse , 0 , iDb ) ; sqlite3VdbeAddOp3 ( v , OP_SetCookie , iDb , BTREE_DEFAULT_CACHE_SIZE , size ) ; assert ( sqlite3SchemaMutexHeld ( db , iDb , 0 ) ) ; pDb -> pSchema -> cache_size = size ; sqlite3BtreeSetCacheSize ( pDb -> pBt , pDb -> pSchema -> cache_size ) ; } break ; } # endif # if ! defined ( SQLITE_OMIT_PAGER_PRAGMAS ) case PragTyp_PAGE_SIZE : { Btree * pBt = pDb -> pBt ; assert ( pBt != 0 ) ; if ( ! zRight ) { int size = ALWAYS ( pBt ) ? sqlite3BtreeGetPageSize ( pBt ) : 0 ; returnSingleInt ( v , size ) ; } else { db -> nextPagesize = sqlite3Atoi ( zRight ) ; if ( SQLITE_NOMEM == sqlite3BtreeSetPageSize ( pBt , db -> nextPagesize , - 1 , 0 ) ) { sqlite3OomFault ( db ) ; } } break ; } case PragTyp_SECURE_DELETE : { Btree * pBt = pDb -> pBt ; int b = - 1 ; assert ( pBt != 0 ) ; if ( zRight ) { if ( sqlite3_stricmp ( zRight , ""fast"" ) == 0 ) { b = 2 ; } else { b = sqlite3GetBoolean ( zRight , 0 ) ; } } if ( pId2 -> n == 0 && b >= 0 ) { int ii ; for ( ii = 0 ; ii < db -> nDb ; ii ++ ) { sqlite3BtreeSecureDelete ( db -> aDb [ ii ] . pBt , b ) ; } } b = sqlite3BtreeSecureDelete ( pBt , b ) ; returnSingleInt ( v , b ) ; break ; } case PragTyp_PAGE_COUNT : { int iReg ; sqlite3CodeVerifySchema ( pParse , iDb ) ; iReg = ++ pParse -> nMem ; if ( sqlite3Tolower ( zLeft [ 0 ] ) == 'p' ) { sqlite3VdbeAddOp2 ( v , OP_Pagecount , iDb , iReg ) ; } else { sqlite3VdbeAddOp3 ( v , OP_MaxPgcnt , iDb , iReg , sqlite3AbsInt32 ( sqlite3Atoi ( zRight ) ) ) ; } sqlite3VdbeAddOp2 ( v , OP_ResultRow , iReg , 1 ) ; break ; } case PragTyp_LOCKING_MODE : { const char * zRet = ""normal"" ; int eMode = getLockingMode ( zRight ) ; if ( pId2 -> n == 0 && eMode == PAGER_LOCKINGMODE_QUERY ) { eMode = db -> dfltLockMode ; } else { Pager * pPager ; if ( pId2 -> n == 0 ) { int ii ; assert ( pDb == & db -> aDb [ 0 ] ) ; for ( ii = 2 ; ii < db -> nDb ; ii ++ ) { pPager = sqlite3BtreePager ( db -> aDb [ ii ] . pBt ) ; sqlite3PagerLockingMode ( pPager , eMode ) ; } db -> dfltLockMode = ( u8 ) eMode ; } pPager = sqlite3BtreePager ( pDb -> pBt ) ; eMode = sqlite3PagerLockingMode ( pPager , eMode ) ; } assert ( eMode == PAGER_LOCKINGMODE_NORMAL || eMode == PAGER_LOCKINGMODE_EXCLUSIVE ) ; if ( eMode == PAGER_LOCKINGMODE_EXCLUSIVE ) { zRet = ""exclusive"" ; } returnSingleText ( v , zRet ) ; break ; } case PragTyp_JOURNAL_MODE : { int eMode ; int ii ; if ( zRight == 0 ) { eMode = PAGER_JOURNALMODE_QUERY ; } else { const char * zMode ; int n = sqlite3Strlen30 ( zRight ) ; for ( eMode = 0 ; ( zMode = sqlite3JournalModename ( eMode ) ) != 0 ; eMode ++ ) { if ( sqlite3StrNICmp ( zRight , zMode , n ) == 0 ) break ; } if ( ! zMode ) { eMode = PAGER_JOURNALMODE_QUERY ; } if ( eMode == PAGER_JOURNALMODE_OFF && ( db -> flags & SQLITE_Defensive ) != 0 ) { eMode = PAGER_JOURNALMODE_QUERY ; } } if ( eMode == PAGER_JOURNALMODE_QUERY && pId2 -> n == 0 ) { iDb = 0 ; pId2 -> n = 1 ; } for ( ii = db -> nDb - 1 ; ii >= 0 ; ii -- ) { if ( db -> aDb [ ii ] . pBt && ( ii == iDb || pId2 -> n == 0 ) ) { sqlite3VdbeUsesBtree ( v , ii ) ; sqlite3VdbeAddOp3 ( v , OP_JournalMode , ii , 1 , eMode ) ; } } sqlite3VdbeAddOp2 ( v , OP_ResultRow , 1 , 1 ) ; break ; } case PragTyp_JOURNAL_SIZE_LIMIT : { Pager * pPager = sqlite3BtreePager ( pDb -> pBt ) ; i64 iLimit = - 2 ; if ( zRight ) { sqlite3DecOrHexToI64 ( zRight , & iLimit ) ; if ( iLimit < - 1 ) iLimit = - 1 ; } iLimit = sqlite3PagerJournalSizeLimit ( pPager , iLimit ) ; returnSingleInt ( v , iLimit ) ; break ; } # endif # ifndef SQLITE_OMIT_AUTOVACUUM case PragTyp_AUTO_VACUUM : { Btree * pBt = pDb -> pBt ; assert ( pBt != 0 ) ; if ( ! zRight ) { returnSingleInt ( v , sqlite3BtreeGetAutoVacuum ( pBt ) ) ; } else { int eAuto = getAutoVacuum ( zRight ) ; assert ( eAuto >= 0 && eAuto <= 2 ) ; db -> nextAutovac = ( u8 ) eAuto ; rc = sqlite3BtreeSetAutoVacuum ( pBt , eAuto ) ; if ( rc == SQLITE_OK && ( eAuto == 1 || eAuto == 2 ) ) { static const int iLn = VDBE_OFFSET_LINENO ( 2 ) ; static const VdbeOpList setMeta6 [ ] = { { OP_Transaction , 0 , 1 , 0 } , { OP_ReadCookie , 0 , 1 , BTREE_LARGEST_ROOT_PAGE } , { OP_If , 1 , 0 , 0 } , { OP_Halt , SQLITE_OK , OE_Abort , 0 } , { OP_SetCookie , 0 , BTREE_INCR_VACUUM , 0 } , } ; VdbeOp * aOp ; int iAddr = sqlite3VdbeCurrentAddr ( v ) ; sqlite3VdbeVerifyNoMallocRequired ( v , ArraySize ( setMeta6 ) ) ; aOp = sqlite3VdbeAddOpList ( v , ArraySize ( setMeta6 ) , setMeta6 , iLn ) ; if ( ONLY_IF_REALLOC_STRESS ( aOp == 0 ) ) break ; aOp [ 0 ] . p1 = iDb ; aOp [ 1 ] . p1 = iDb ; aOp [ 2 ] . p2 = iAddr + 4 ; aOp [ 4 ] . p1 = iDb ; aOp [ 4 ] . p3 = eAuto - 1 ; sqlite3VdbeUsesBtree ( v , iDb ) ; } } break ; } # endif # ifndef SQLITE_OMIT_AUTOVACUUM case PragTyp_INCREMENTAL_VACUUM : { int iLimit , addr ; if ( zRight == 0 || ! sqlite3GetInt32 ( zRight , & iLimit ) || iLimit <= 0 ) { iLimit = 0x7fffffff ; } sqlite3BeginWriteOperation ( pParse , 0 , iDb ) ; sqlite3VdbeAddOp2 ( v , OP_Integer , iLimit , 1 ) ; addr = sqlite3VdbeAddOp1 ( v , OP_IncrVacuum , iDb ) ; VdbeCoverage ( v ) ; sqlite3VdbeAddOp1 ( v , OP_ResultRow , 1 ) ; sqlite3VdbeAddOp2 ( v , OP_AddImm , 1 , - 1 ) ; sqlite3VdbeAddOp2 ( v , OP_IfPos , 1 , addr ) ; VdbeCoverage ( v ) ; sqlite3VdbeJumpHere ( v , addr ) ; break ; } # endif # ifndef SQLITE_OMIT_PAGER_PRAGMAS case PragTyp_CACHE_SIZE : { assert ( sqlite3SchemaMutexHeld ( db , iDb , 0 ) ) ; if ( ! zRight ) { returnSingleInt ( v , pDb -> pSchema -> cache_size ) ; } else { int size = sqlite3Atoi ( zRight ) ; pDb -> pSchema -> cache_size = size ; sqlite3BtreeSetCacheSize ( pDb -> pBt , pDb -> pSchema -> cache_size ) ; } break ; } case PragTyp_CACHE_SPILL : { assert ( sqlite3SchemaMutexHeld ( db , iDb , 0 ) ) ; if ( ! zRight ) { returnSingleInt ( v , ( db -> flags & SQLITE_CacheSpill ) == 0 ? 0 : sqlite3BtreeSetSpillSize ( pDb -> pBt , 0 ) ) ; } else { int size = 1 ; if ( sqlite3GetInt32 ( zRight , & size ) ) { sqlite3BtreeSetSpillSize ( pDb -> pBt , size ) ; } if ( sqlite3GetBoolean ( zRight , size != 0 ) ) { db -> flags |= SQLITE_CacheSpill ; } else { db -> flags &= ~ ( u64 ) SQLITE_CacheSpill ; } setAllPagerFlags ( db ) ; } break ; } case PragTyp_MMAP_SIZE : { sqlite3_int64 sz ; # if SQLITE_MAX_MMAP_SIZE > 0 assert ( sqlite3SchemaMutexHeld ( db , iDb , 0 ) ) ; if ( zRight ) { int ii ; sqlite3DecOrHexToI64 ( zRight , & sz ) ; if ( sz < 0 ) sz = sqlite3GlobalConfig . szMmap ; if ( pId2 -> n == 0 ) db -> szMmap = sz ; for ( ii = db -> nDb - 1 ; ii >= 0 ; ii -- ) { if ( db -> aDb [ ii ] . pBt && ( ii == iDb || pId2 -> n == 0 ) ) { sqlite3BtreeSetMmapLimit ( db -> aDb [ ii ] . pBt , sz ) ; } } } sz = - 1 ; rc = sqlite3_file_control ( db , zDb , SQLITE_FCNTL_MMAP_SIZE , & sz ) ; # else sz = 0 ; rc = SQLITE_OK ; # endif if ( rc == SQLITE_OK ) { returnSingleInt ( v , sz ) ; } else if ( rc != SQLITE_NOTFOUND ) { pParse -> nErr ++ ; pParse -> rc = rc ; } break ; } case PragTyp_TEMP_STORE : { if ( ! zRight ) { returnSingleInt ( v , db -> temp_store ) ; } else { changeTempStorage ( pParse , zRight ) ; } break ; } case PragTyp_TEMP_STORE_DIRECTORY : { if ( ! zRight ) { returnSingleText ( v , sqlite3_temp_directory ) ; } else { # ifndef SQLITE_OMIT_WSD if ( zRight [ 0 ] ) { int res ; rc = sqlite3OsAccess ( db -> pVfs , zRight , SQLITE_ACCESS_READWRITE , & res ) ; if ( rc != SQLITE_OK || res == 0 ) { sqlite3ErrorMsg ( pParse , ""not<S2SV_blank>a<S2SV_blank>writable<S2SV_blank>directory"" ) ; goto pragma_out ; } } if ( SQLITE_TEMP_STORE == 0 || ( SQLITE_TEMP_STORE == 1 && db -> temp_store <= 1 ) || ( SQLITE_TEMP_STORE == 2 && db -> temp_store == 1 ) ) { invalidateTempStorage ( pParse ) ; } sqlite3_free ( sqlite3_temp_directory ) ; if ( zRight [ 0 ] ) { sqlite3_temp_directory = sqlite3_mprintf ( ""%s"" , zRight ) ; } else { sqlite3_temp_directory = 0 ; } # endif } break ; } # if SQLITE_OS_WIN case PragTyp_DATA_STORE_DIRECTORY : { if ( ! zRight ) { returnSingleText ( v , sqlite3_data_directory ) ; } else { # ifndef SQLITE_OMIT_WSD if ( zRight [ 0 ] ) { int res ; rc = sqlite3OsAccess ( db -> pVfs , zRight , SQLITE_ACCESS_READWRITE , & res ) ; if ( rc != SQLITE_OK || res == 0 ) { sqlite3ErrorMsg ( pParse , ""not<S2SV_blank>a<S2SV_blank>writable<S2SV_blank>directory"" ) ; goto pragma_out ; } } sqlite3_free ( sqlite3_data_directory ) ; if ( zRight [ 0 ] ) { sqlite3_data_directory = sqlite3_mprintf ( ""%s"" , zRight ) ; } else { sqlite3_data_directory = 0 ; } # endif } break ; } # endif # if SQLITE_ENABLE_LOCKING_STYLE case PragTyp_LOCK_PROXY_FILE : { if ( ! zRight ) { Pager * pPager = sqlite3BtreePager ( pDb -> pBt ) ; char * proxy_file_path = NULL ; sqlite3_file * pFile = sqlite3PagerFile ( pPager ) ; sqlite3OsFileControlHint ( pFile , SQLITE_GET_LOCKPROXYFILE , & proxy_file_path ) ; returnSingleText ( v , proxy_file_path ) ; } else { Pager * pPager = sqlite3BtreePager ( pDb -> pBt ) ; sqlite3_file * pFile = sqlite3PagerFile ( pPager ) ; int res ; if ( zRight [ 0 ] ) { res = sqlite3OsFileControl ( pFile , SQLITE_SET_LOCKPROXYFILE , zRight ) ; } else { res = sqlite3OsFileControl ( pFile , SQLITE_SET_LOCKPROXYFILE , NULL ) ; } if ( res != SQLITE_OK ) { sqlite3ErrorMsg ( pParse , ""failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>lock<S2SV_blank>proxy<S2SV_blank>file"" ) ; goto pragma_out ; } } break ; } # endif case PragTyp_SYNCHRONOUS : { if ( ! zRight ) { returnSingleInt ( v , pDb -> safety_level - 1 ) ; } else { if ( ! db -> autoCommit ) { sqlite3ErrorMsg ( pParse , ""Safety<S2SV_blank>level<S2SV_blank>may<S2SV_blank>not<S2SV_blank>be<S2SV_blank>changed<S2SV_blank>inside<S2SV_blank>a<S2SV_blank>transaction"" ) ; } else if ( iDb != 1 ) { int iLevel = ( getSafetyLevel ( zRight , 0 , 1 ) + 1 ) & PAGER_SYNCHRONOUS_MASK ; if ( iLevel == 0 ) iLevel = 1 ; pDb -> safety_level = iLevel ; pDb -> bSyncSet = 1 ; setAllPagerFlags ( db ) ; } } break ; } # endif # ifndef SQLITE_OMIT_FLAG_PRAGMAS case PragTyp_FLAG : { if ( zRight == 0 ) { setPragmaResultColumnNames ( v , pPragma ) ; returnSingleInt ( v , ( db -> flags & pPragma -> iArg ) != 0 ) ; } else { u64 mask = pPragma -> iArg ; if ( db -> autoCommit == 0 ) { mask &= ~ ( SQLITE_ForeignKeys ) ; } # if SQLITE_USER_AUTHENTICATION if ( db -> auth . authLevel == UAUTH_User ) { mask &= ~ ( SQLITE_WriteSchema ) ; } # endif if ( sqlite3GetBoolean ( zRight , 0 ) ) { db -> flags |= mask ; } else { db -> flags &= ~ mask ; if ( mask == SQLITE_DeferFKs ) db -> nDeferredImmCons = 0 ; } sqlite3VdbeAddOp0 ( v , OP_Expire ) ; setAllPagerFlags ( db ) ; } break ; } # endif # ifndef SQLITE_OMIT_SCHEMA_PRAGMAS case PragTyp_TABLE_INFO : if ( zRight ) { Table * pTab ; pTab = sqlite3LocateTable ( pParse , LOCATE_NOERR , zRight , zDb ) ; if ( pTab ) { int iTabDb = sqlite3SchemaToIndex ( db , pTab -> pSchema ) ; int i , k ; int nHidden = 0 ; Column * pCol ; Index * pPk = sqlite3PrimaryKeyIndex ( pTab ) ; pParse -> nMem = 7 ; sqlite3CodeVerifySchema ( pParse , iTabDb ) ; sqlite3ViewGetColumnNames ( pParse , pTab ) ; for ( i = 0 , pCol = pTab -> aCol ; i < pTab -> nCol ; i ++ , pCol ++ ) { int isHidden = 0 ; if ( pCol -> colFlags & COLFLAG_NOINSERT ) { if ( pPragma -> iArg == 0 ) { nHidden ++ ; continue ; } if ( pCol -> colFlags & COLFLAG_VIRTUAL ) { isHidden = 2 ; } else if ( pCol -> colFlags & COLFLAG_STORED ) { isHidden = 3 ; } else { assert ( pCol -> colFlags & COLFLAG_HIDDEN ) ; isHidden = 1 ; } } if ( ( pCol -> colFlags & COLFLAG_PRIMKEY ) == 0 ) { k = 0 ; } else if ( pPk == 0 ) { k = 1 ; } else { for ( k = 1 ; k <= pTab -> nCol && pPk -> aiColumn [ k - 1 ] != i ; k ++ ) { } } assert ( pCol -> pDflt == 0 || pCol -> pDflt -> op == TK_SPAN || isHidden >= 2 ) ; sqlite3VdbeMultiLoad ( v , 1 , pPragma -> iArg ? ""issisii"" : ""issisi"" , i - nHidden , pCol -> zName , sqlite3ColumnType ( pCol , """" ) , pCol -> notNull ? 1 : 0 , pCol -> pDflt && isHidden < 2 ? pCol -> pDflt -> u . zToken : 0 , k , isHidden ) ; } } } break ; # ifdef SQLITE_DEBUG case PragTyp_STATS : { Index * pIdx ; HashElem * i ; pParse -> nMem = 5 ; sqlite3CodeVerifySchema ( pParse , iDb ) ; for ( i = sqliteHashFirst ( & pDb -> pSchema -> tblHash ) ; i ; i = sqliteHashNext ( i ) ) { Table * pTab = sqliteHashData ( i ) ; sqlite3VdbeMultiLoad ( v , 1 , ""ssiii"" , pTab -> zName , 0 , pTab -> szTabRow , pTab -> nRowLogEst , pTab -> tabFlags ) ; for ( pIdx = pTab -> pIndex ; pIdx ; pIdx = pIdx -> pNext ) { sqlite3VdbeMultiLoad ( v , 2 , ""siiiX"" , pIdx -> zName , pIdx -> szIdxRow , pIdx -> aiRowLogEst [ 0 ] , pIdx -> hasStat1 ) ; sqlite3VdbeAddOp2 ( v , OP_ResultRow , 1 , 5 ) ; } } } break ; # endif case PragTyp_INDEX_INFO : if ( zRight ) { Index * pIdx ; Table * pTab ; pIdx = sqlite3FindIndex ( db , zRight , zDb ) ; if ( pIdx == 0 ) { pTab = sqlite3LocateTable ( pParse , LOCATE_NOERR , zRight , zDb ) ; if ( pTab && ! HasRowid ( pTab ) ) { pIdx = sqlite3PrimaryKeyIndex ( pTab ) ; } } if ( pIdx ) { int iIdxDb = sqlite3SchemaToIndex ( db , pIdx -> pSchema ) ; int i ; int mx ; if ( pPragma -> iArg ) { mx = pIdx -> nColumn ; pParse -> nMem = 6 ; } else { mx = pIdx -> nKeyCol ; pParse -> nMem = 3 ; } pTab = pIdx -> pTable ; sqlite3CodeVerifySchema ( pParse , iIdxDb ) ; assert ( pParse -> nMem <= pPragma -> nPragCName ) ; for ( i = 0 ; i < mx ; i ++ ) { i16 cnum = pIdx -> aiColumn [ i ] ; sqlite3VdbeMultiLoad ( v , 1 , ""iisX"" , i , cnum , cnum < 0 ? 0 : pTab -> aCol [ cnum ] . zName ) ; if ( pPragma -> iArg ) { sqlite3VdbeMultiLoad ( v , 4 , ""isiX"" , pIdx -> aSortOrder [ i ] , pIdx -> azColl [ i ] , i < pIdx -> nKeyCol ) ; } sqlite3VdbeAddOp2 ( v , OP_ResultRow , 1 , pParse -> nMem ) ; } } } break ; case PragTyp_INDEX_LIST : if ( zRight ) { Index * pIdx ; Table * pTab ; int i ; pTab = sqlite3FindTable ( db , zRight , zDb ) ; if ( pTab ) { int iTabDb = sqlite3SchemaToIndex ( db , pTab -> pSchema ) ; pParse -> nMem = 5 ; sqlite3CodeVerifySchema ( pParse , iTabDb ) ; for ( pIdx = pTab -> pIndex , i = 0 ; pIdx ; pIdx = pIdx -> pNext , i ++ ) { const char * azOrigin [ ] = { ""c"" , ""u"" , ""pk"" } ; sqlite3VdbeMultiLoad ( v , 1 , ""isisi"" , i , pIdx -> zName , IsUniqueIndex ( pIdx ) , azOrigin [ pIdx -> idxType ] , pIdx -> pPartIdxWhere != 0 ) ; } } } break ; case PragTyp_DATABASE_LIST : { int i ; pParse -> nMem = 3 ; for ( i = 0 ; i < db -> nDb ; i ++ ) { if ( db -> aDb [ i ] . pBt == 0 ) continue ; assert ( db -> aDb [ i ] . zDbSName != 0 ) ; sqlite3VdbeMultiLoad ( v , 1 , ""iss"" , i , db -> aDb [ i ] . zDbSName , sqlite3BtreeGetFilename ( db -> aDb [ i ] . pBt ) ) ; } } break ; case PragTyp_COLLATION_LIST : { int i = 0 ; HashElem * p ; pParse -> nMem = 2 ; for ( p = sqliteHashFirst ( & db -> aCollSeq ) ; p ; p = sqliteHashNext ( p ) ) { CollSeq * pColl = ( CollSeq * ) sqliteHashData ( p ) ; sqlite3VdbeMultiLoad ( v , 1 , ""is"" , i ++ , pColl -> zName ) ; } } break ; # ifndef SQLITE_OMIT_INTROSPECTION_PRAGMAS case PragTyp_FUNCTION_LIST : { int i ; HashElem * j ; FuncDef * p ; pParse -> nMem = 2 ; for ( i = 0 ; i < SQLITE_FUNC_HASH_SZ ; i ++ ) { for ( p = sqlite3BuiltinFunctions . a [ i ] ; p ; p = p -> u . pHash ) { if ( p -> funcFlags & SQLITE_FUNC_INTERNAL ) continue ; sqlite3VdbeMultiLoad ( v , 1 , ""si"" , p -> zName , 1 ) ; } } for ( j = sqliteHashFirst ( & db -> aFunc ) ; j ; j = sqliteHashNext ( j ) ) { p = ( FuncDef * ) sqliteHashData ( j ) ; sqlite3VdbeMultiLoad ( v , 1 , ""si"" , p -> zName , 0 ) ; } } break ; # ifndef SQLITE_OMIT_VIRTUALTABLE case PragTyp_MODULE_LIST : { HashElem * j ; pParse -> nMem = 1 ; for ( j = sqliteHashFirst ( & db -> aModule ) ; j ; j = sqliteHashNext ( j ) ) { Module * pMod = ( Module * ) sqliteHashData ( j ) ; sqlite3VdbeMultiLoad ( v , 1 , ""s"" , pMod -> zName ) ; } } break ; # endif case PragTyp_PRAGMA_LIST : { int i ; for ( i = 0 ; i < ArraySize ( aPragmaName ) ; i ++ ) { sqlite3VdbeMultiLoad ( v , 1 , ""s"" , aPragmaName [ i ] . zName ) ; } } break ; # endif # endif # ifndef SQLITE_OMIT_FOREIGN_KEY case PragTyp_FOREIGN_KEY_LIST : if ( zRight ) { FKey * pFK ; Table * pTab ; pTab = sqlite3FindTable ( db , zRight , zDb ) ; if ( pTab ) { pFK = pTab -> pFKey ; if ( pFK ) { int iTabDb = sqlite3SchemaToIndex ( db , pTab -> pSchema ) ; int i = 0 ; pParse -> nMem = 8 ; sqlite3CodeVerifySchema ( pParse , iTabDb ) ; while ( pFK ) { int j ; for ( j = 0 ; j < pFK -> nCol ; j ++ ) { sqlite3VdbeMultiLoad ( v , 1 , ""iissssss"" , i , j , pFK -> zTo , pTab -> aCol [ pFK -> aCol [ j ] . iFrom ] . zName , pFK -> aCol [ j ] . zCol , actionName ( pFK -> aAction [ 1 ] ) , actionName ( pFK -> aAction [ 0 ] ) , ""NONE"" ) ; } ++ i ; pFK = pFK -> pNextFrom ; } } } } break ; # endif # ifndef SQLITE_OMIT_FOREIGN_KEY # ifndef SQLITE_OMIT_TRIGGER case PragTyp_FOREIGN_KEY_CHECK : { FKey * pFK ; Table * pTab ; Table * pParent ; Index * pIdx ; int i ; int j ; HashElem * k ; int x ; int regResult ; int regKey ; int regRow ; int addrTop ; int addrOk ; int * aiCols ; regResult = pParse -> nMem + 1 ; pParse -> nMem += 4 ; regKey = ++ pParse -> nMem ; regRow = ++ pParse -> nMem ; k = sqliteHashFirst ( & db -> aDb [ iDb ] . pSchema -> tblHash ) ; while ( k ) { int iTabDb ; if ( zRight ) { pTab = sqlite3LocateTable ( pParse , 0 , zRight , zDb ) ; k = 0 ; } else { pTab = ( Table * ) sqliteHashData ( k ) ; k = sqliteHashNext ( k ) ; } if ( pTab == 0 || pTab -> pFKey == 0 ) continue ; iTabDb = sqlite3SchemaToIndex ( db , pTab -> pSchema ) ; sqlite3CodeVerifySchema ( pParse , iTabDb ) ; sqlite3TableLock ( pParse , iTabDb , pTab -> tnum , 0 , pTab -> zName ) ; if ( pTab -> nCol + regRow > pParse -> nMem ) pParse -> nMem = pTab -> nCol + regRow ; sqlite3OpenTable ( pParse , 0 , iTabDb , pTab , OP_OpenRead ) ; sqlite3VdbeLoadString ( v , regResult , pTab -> zName ) ; for ( i = 1 , pFK = pTab -> pFKey ; pFK ; i ++ , pFK = pFK -> pNextFrom ) { pParent = sqlite3FindTable ( db , pFK -> zTo , zDb ) ; if ( pParent == 0 ) continue ; pIdx = 0 ; sqlite3TableLock ( pParse , iTabDb , pParent -> tnum , 0 , pParent -> zName ) ; x = sqlite3FkLocateIndex ( pParse , pParent , pFK , & pIdx , 0 ) ; if ( x == 0 ) { if ( pIdx == 0 ) { sqlite3OpenTable ( pParse , i , iTabDb , pParent , OP_OpenRead ) ; } else { sqlite3VdbeAddOp3 ( v , OP_OpenRead , i , pIdx -> tnum , iTabDb ) ; sqlite3VdbeSetP4KeyInfo ( pParse , pIdx ) ; } } else { k = 0 ; break ; } } assert ( pParse -> nErr > 0 || pFK == 0 ) ; if ( pFK ) break ; if ( pParse -> nTab < i ) pParse -> nTab = i ; addrTop = sqlite3VdbeAddOp1 ( v , OP_Rewind , 0 ) ; VdbeCoverage ( v ) ; for ( i = 1 , pFK = pTab -> pFKey ; pFK ; i ++ , pFK = pFK -> pNextFrom ) { pParent = sqlite3FindTable ( db , pFK -> zTo , zDb ) ; pIdx = 0 ; aiCols = 0 ; if ( pParent ) { x = sqlite3FkLocateIndex ( pParse , pParent , pFK , & pIdx , & aiCols ) ; assert ( x == 0 ) ; } addrOk = sqlite3VdbeMakeLabel ( pParse ) ; for ( j = 0 ; j < pFK -> nCol ; j ++ ) { int iCol = aiCols ? aiCols [ j ] : pFK -> aCol [ j ] . iFrom ; sqlite3ExprCodeGetColumnOfTable ( v , pTab , 0 , iCol , regRow + j ) ; sqlite3VdbeAddOp2 ( v , OP_IsNull , regRow + j , addrOk ) ; VdbeCoverage ( v ) ; } if ( pIdx ) { sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regRow , pFK -> nCol , regKey , sqlite3IndexAffinityStr ( db , pIdx ) , pFK -> nCol ) ; sqlite3VdbeAddOp4Int ( v , OP_Found , i , addrOk , regKey , 0 ) ; VdbeCoverage ( v ) ; } else if ( pParent ) { int jmp = sqlite3VdbeCurrentAddr ( v ) + 2 ; sqlite3VdbeAddOp3 ( v , OP_SeekRowid , i , jmp , regRow ) ; VdbeCoverage ( v ) ; sqlite3VdbeGoto ( v , addrOk ) ; assert ( pFK -> nCol == 1 ) ; } if ( HasRowid ( pTab ) ) { sqlite3VdbeAddOp2 ( v , OP_Rowid , 0 , regResult + 1 ) ; } else { sqlite3VdbeAddOp2 ( v , OP_Null , 0 , regResult + 1 ) ; } sqlite3VdbeMultiLoad ( v , regResult + 2 , ""siX"" , pFK -> zTo , i - 1 ) ; sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , 4 ) ; sqlite3VdbeResolveLabel ( v , addrOk ) ; sqlite3DbFree ( db , aiCols ) ; } sqlite3VdbeAddOp2 ( v , OP_Next , 0 , addrTop + 1 ) ; VdbeCoverage ( v ) ; sqlite3VdbeJumpHere ( v , addrTop ) ; } } break ; # endif # endif # ifndef SQLITE_OMIT_CASE_SENSITIVE_LIKE_PRAGMA case PragTyp_CASE_SENSITIVE_LIKE : { if ( zRight ) { sqlite3RegisterLikeFunctions ( db , sqlite3GetBoolean ( zRight , 0 ) ) ; } } break ; # endif # ifndef SQLITE_INTEGRITY_CHECK_ERROR_MAX # define SQLITE_INTEGRITY_CHECK_ERROR_MAX 100 # endif # ifndef SQLITE_OMIT_INTEGRITY_CHECK case PragTyp_INTEGRITY_CHECK : { int i , j , addr , mxErr ; int isQuick = ( sqlite3Tolower ( zLeft [ 0 ] ) == 'q' ) ; assert ( iDb >= 0 ) ; assert ( iDb == 0 || pId2 -> z ) ; if ( pId2 -> z == 0 ) iDb = - 1 ; pParse -> nMem = 6 ; mxErr = SQLITE_INTEGRITY_CHECK_ERROR_MAX ; if ( zRight ) { sqlite3GetInt32 ( zRight , & mxErr ) ; if ( mxErr <= 0 ) { mxErr = SQLITE_INTEGRITY_CHECK_ERROR_MAX ; } } sqlite3VdbeAddOp2 ( v , OP_Integer , mxErr - 1 , 1 ) ; for ( i = 0 ; i < db -> nDb ; i ++ ) { HashElem * x ; Hash * pTbls ; int * aRoot ; int cnt = 0 ; int mxIdx = 0 ; if ( OMIT_TEMPDB && i == 1 ) continue ; if ( iDb >= 0 && i != iDb ) continue ; sqlite3CodeVerifySchema ( pParse , i ) ; assert ( sqlite3SchemaMutexHeld ( db , i , 0 ) ) ; pTbls = & db -> aDb [ i ] . pSchema -> tblHash ; for ( cnt = 0 , x = sqliteHashFirst ( pTbls ) ; x ; x = sqliteHashNext ( x ) ) { Table * pTab = sqliteHashData ( x ) ; Index * pIdx ; int nIdx ; if ( HasRowid ( pTab ) ) cnt ++ ; for ( nIdx = 0 , pIdx = pTab -> pIndex ; pIdx ; pIdx = pIdx -> pNext , nIdx ++ ) { cnt ++ ; } if ( nIdx > mxIdx ) mxIdx = nIdx ; } aRoot = sqlite3DbMallocRawNN ( db , sizeof ( int ) * ( cnt + 1 ) ) ; if ( aRoot == 0 ) break ; for ( cnt = 0 , x = sqliteHashFirst ( pTbls ) ; x ; x = sqliteHashNext ( x ) ) { Table * pTab = sqliteHashData ( x ) ; Index * pIdx ; if ( HasRowid ( pTab ) ) aRoot [ ++ cnt ] = pTab -> tnum ; for ( pIdx = pTab -> pIndex ; pIdx ; pIdx = pIdx -> pNext ) { aRoot [ ++ cnt ] = pIdx -> tnum ; } } aRoot [ 0 ] = cnt ; pParse -> nMem = MAX ( pParse -> nMem , 8 + mxIdx ) ; sqlite3ClearTempRegCache ( pParse ) ; sqlite3VdbeAddOp4 ( v , OP_IntegrityCk , 2 , cnt , 1 , ( char * ) aRoot , P4_INTARRAY ) ; sqlite3VdbeChangeP5 ( v , ( u8 ) i ) ; addr = sqlite3VdbeAddOp1 ( v , OP_IsNull , 2 ) ; VdbeCoverage ( v ) ; sqlite3VdbeAddOp4 ( v , OP_String8 , 0 , 3 , 0 , sqlite3MPrintf ( db , ""***<S2SV_blank>in<S2SV_blank>database<S2SV_blank>%s<S2SV_blank>***\\n"" , db -> aDb [ i ] . zDbSName ) , P4_DYNAMIC ) ; sqlite3VdbeAddOp3 ( v , OP_Concat , 2 , 3 , 3 ) ; integrityCheckResultRow ( v ) ; sqlite3VdbeJumpHere ( v , addr ) ; for ( x = sqliteHashFirst ( pTbls ) ; x ; x = sqliteHashNext ( x ) ) { Table * pTab = sqliteHashData ( x ) ; Index * pIdx , * pPk ; Index * pPrior = 0 ; int loopTop ; int iDataCur , iIdxCur ; int r1 = - 1 ; if ( pTab -> tnum < 1 ) continue ; pPk = HasRowid ( pTab ) ? 0 : sqlite3PrimaryKeyIndex ( pTab ) ; sqlite3OpenTableAndIndices ( pParse , pTab , OP_OpenRead , 0 , 1 , 0 , & iDataCur , & iIdxCur ) ; sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , 7 ) ; for ( j = 0 , pIdx = pTab -> pIndex ; pIdx ; pIdx = pIdx -> pNext , j ++ ) { sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , 8 + j ) ; } assert ( pParse -> nMem >= 8 + j ) ; assert ( sqlite3NoTempsInRange ( pParse , 1 , 7 + j ) ) ; sqlite3VdbeAddOp2 ( v , OP_Rewind , iDataCur , 0 ) ; VdbeCoverage ( v ) ; loopTop = sqlite3VdbeAddOp2 ( v , OP_AddImm , 7 , 1 ) ; if ( ! isQuick ) { sqlite3VdbeAddOp3 ( v , OP_Column , iDataCur , pTab -> nNVCol - 1 , 3 ) ; sqlite3VdbeChangeP5 ( v , OPFLAG_TYPEOFARG ) ; } for ( j = 0 ; j < pTab -> nCol ; j ++ ) { char * zErr ; int jmp2 ; if ( j == pTab -> iPKey ) continue ; if ( pTab -> aCol [ j ] . notNull == 0 ) continue ; sqlite3ExprCodeGetColumnOfTable ( v , pTab , iDataCur , j , 3 ) ; <S2SV_StartBug> sqlite3VdbeChangeP5 ( v , OPFLAG_TYPEOFARG ) ; <S2SV_EndBug> jmp2 = sqlite3VdbeAddOp1 ( v , OP_NotNull , 3 ) ; VdbeCoverage ( v ) ; zErr = sqlite3MPrintf ( db , ""NULL<S2SV_blank>value<S2SV_blank>in<S2SV_blank>%s.%s"" , pTab -> zName , pTab -> aCol [ j ] . zName ) ; sqlite3VdbeAddOp4 ( v , OP_String8 , 0 , 3 , 0 , zErr , P4_DYNAMIC ) ; integrityCheckResultRow ( v ) ; sqlite3VdbeJumpHere ( v , jmp2 ) ; } if ( pTab -> pCheck && ( db -> flags & SQLITE_IgnoreChecks ) == 0 ) { ExprList * pCheck = sqlite3ExprListDup ( db , pTab -> pCheck , 0 ) ; if ( db -> mallocFailed == 0 ) { int addrCkFault = sqlite3VdbeMakeLabel ( pParse ) ; int addrCkOk = sqlite3VdbeMakeLabel ( pParse ) ; char * zErr ; int k ; pParse -> iSelfTab = iDataCur + 1 ; for ( k = pCheck -> nExpr - 1 ; k > 0 ; k -- ) { sqlite3ExprIfFalse ( pParse , pCheck -> a [ k ] . pExpr , addrCkFault , 0 ) ; } sqlite3ExprIfTrue ( pParse , pCheck -> a [ 0 ] . pExpr , addrCkOk , SQLITE_JUMPIFNULL ) ; sqlite3VdbeResolveLabel ( v , addrCkFault ) ; pParse -> iSelfTab = 0 ; zErr = sqlite3MPrintf ( db , ""CHECK<S2SV_blank>constraint<S2SV_blank>failed<S2SV_blank>in<S2SV_blank>%s"" , pTab -> zName ) ; sqlite3VdbeAddOp4 ( v , OP_String8 , 0 , 3 , 0 , zErr , P4_DYNAMIC ) ; integrityCheckResultRow ( v ) ; sqlite3VdbeResolveLabel ( v , addrCkOk ) ; } sqlite3ExprListDelete ( db , pCheck ) ; } if ( ! isQuick ) { for ( j = 0 , pIdx = pTab -> pIndex ; pIdx ; pIdx = pIdx -> pNext , j ++ ) { int jmp2 , jmp3 , jmp4 , jmp5 ; int ckUniq = sqlite3VdbeMakeLabel ( pParse ) ; if ( pPk == pIdx ) continue ; r1 = sqlite3GenerateIndexKey ( pParse , pIdx , iDataCur , 0 , 0 , & jmp3 , pPrior , r1 ) ; pPrior = pIdx ; sqlite3VdbeAddOp2 ( v , OP_AddImm , 8 + j , 1 ) ; jmp2 = sqlite3VdbeAddOp4Int ( v , OP_Found , iIdxCur + j , ckUniq , r1 , pIdx -> nColumn ) ; VdbeCoverage ( v ) ; sqlite3VdbeLoadString ( v , 3 , ""row<S2SV_blank>"" ) ; sqlite3VdbeAddOp3 ( v , OP_Concat , 7 , 3 , 3 ) ; sqlite3VdbeLoadString ( v , 4 , ""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>index<S2SV_blank>"" ) ; sqlite3VdbeAddOp3 ( v , OP_Concat , 4 , 3 , 3 ) ; jmp5 = sqlite3VdbeLoadString ( v , 4 , pIdx -> zName ) ; sqlite3VdbeAddOp3 ( v , OP_Concat , 4 , 3 , 3 ) ; jmp4 = integrityCheckResultRow ( v ) ; sqlite3VdbeJumpHere ( v , jmp2 ) ; if ( IsUniqueIndex ( pIdx ) ) { int uniqOk = sqlite3VdbeMakeLabel ( pParse ) ; int jmp6 ; int kk ; for ( kk = 0 ; kk < pIdx -> nKeyCol ; kk ++ ) { int iCol = pIdx -> aiColumn [ kk ] ; assert ( iCol != XN_ROWID && iCol < pTab -> nCol ) ; if ( iCol >= 0 && pTab -> aCol [ iCol ] . notNull ) continue ; sqlite3VdbeAddOp2 ( v , OP_IsNull , r1 + kk , uniqOk ) ; VdbeCoverage ( v ) ; } jmp6 = sqlite3VdbeAddOp1 ( v , OP_Next , iIdxCur + j ) ; VdbeCoverage ( v ) ; sqlite3VdbeGoto ( v , uniqOk ) ; sqlite3VdbeJumpHere ( v , jmp6 ) ; sqlite3VdbeAddOp4Int ( v , OP_IdxGT , iIdxCur + j , uniqOk , r1 , pIdx -> nKeyCol ) ; VdbeCoverage ( v ) ; sqlite3VdbeLoadString ( v , 3 , ""non-unique<S2SV_blank>entry<S2SV_blank>in<S2SV_blank>index<S2SV_blank>"" ) ; sqlite3VdbeGoto ( v , jmp5 ) ; sqlite3VdbeResolveLabel ( v , uniqOk ) ; } sqlite3VdbeJumpHere ( v , jmp4 ) ; sqlite3ResolvePartIdxLabel ( pParse , jmp3 ) ; } } sqlite3VdbeAddOp2 ( v , OP_Next , iDataCur , loopTop ) ; VdbeCoverage ( v ) ; sqlite3VdbeJumpHere ( v , loopTop - 1 ) ; # ifndef SQLITE_OMIT_BTREECOUNT if ( ! isQuick ) { sqlite3VdbeLoadString ( v , 2 , ""wrong<S2SV_blank>#<S2SV_blank>of<S2SV_blank>entries<S2SV_blank>in<S2SV_blank>index<S2SV_blank>"" ) ; for ( j = 0 , pIdx = pTab -> pIndex ; pIdx ; pIdx = pIdx -> pNext , j ++ ) { if ( pPk == pIdx ) continue ; sqlite3VdbeAddOp2 ( v , OP_Count , iIdxCur + j , 3 ) ; addr = sqlite3VdbeAddOp3 ( v , OP_Eq , 8 + j , 0 , 3 ) ; VdbeCoverage ( v ) ; sqlite3VdbeChangeP5 ( v , SQLITE_NOTNULL ) ; sqlite3VdbeLoadString ( v , 4 , pIdx -> zName ) ; sqlite3VdbeAddOp3 ( v , OP_Concat , 4 , 2 , 3 ) ; integrityCheckResultRow ( v ) ; sqlite3VdbeJumpHere ( v , addr ) ; } } # endif } } { static const int iLn = VDBE_OFFSET_LINENO ( 2 ) ; static const VdbeOpList endCode [ ] = { { OP_AddImm , 1 , 0 , 0 } , { OP_IfNotZero , 1 , 4 , 0 } , { OP_String8 , 0 , 3 , 0 } , { OP_ResultRow , 3 , 1 , 0 } , { OP_Halt , 0 , 0 , 0 } , { OP_String8 , 0 , 3 , 0 } , { OP_Goto , 0 , 3 , 0 } , } ; VdbeOp * aOp ; aOp = sqlite3VdbeAddOpList ( v , ArraySize ( endCode ) , endCode , iLn ) ; if ( aOp ) { aOp [ 0 ] . p2 = 1 - mxErr ; aOp [ 2 ] . p4type = P4_STATIC ; aOp [ 2 ] . p4 . z = ""ok"" ; aOp [ 5 ] . p4type = P4_STATIC ; aOp [ 5 ] . p4 . z = ( char * ) sqlite3ErrStr ( SQLITE_CORRUPT ) ; } sqlite3VdbeChangeP3 ( v , 0 , sqlite3VdbeCurrentAddr ( v ) - 2 ) ; } } break ; # endif # ifndef SQLITE_OMIT_UTF16 case PragTyp_ENCODING : { static const struct EncName { char * zName ; u8 enc ; } encnames [ ] = { { ""UTF8"" , SQLITE_UTF8 } , { ""UTF-8"" , SQLITE_UTF8 } , { ""UTF-16le"" , SQLITE_UTF16LE } , { ""UTF-16be"" , SQLITE_UTF16BE } , { ""UTF16le"" , SQLITE_UTF16LE } , { ""UTF16be"" , SQLITE_UTF16BE } , { ""UTF-16"" , 0 } , { ""UTF16"" , 0 } , { 0 , 0 } } ; const struct EncName * pEnc ; if ( ! zRight ) { if ( sqlite3ReadSchema ( pParse ) ) goto pragma_out ; assert ( encnames [ SQLITE_UTF8 ] . enc == SQLITE_UTF8 ) ; assert ( encnames [ SQLITE_UTF16LE ] . enc == SQLITE_UTF16LE ) ; assert ( encnames [ SQLITE_UTF16BE ] . enc == SQLITE_UTF16BE ) ; returnSingleText ( v , encnames [ ENC ( pParse -> db ) ] . zName ) ; } else { if ( ! ( DbHasProperty ( db , 0 , DB_SchemaLoaded ) ) || DbHasProperty ( db , 0 , DB_Empty ) ) { for ( pEnc = & encnames [ 0 ] ; pEnc -> zName ; pEnc ++ ) { if ( 0 == sqlite3StrICmp ( zRight , pEnc -> zName ) ) { SCHEMA_ENC ( db ) = ENC ( db ) = pEnc -> enc ? pEnc -> enc : SQLITE_UTF16NATIVE ; break ; } } if ( ! pEnc -> zName ) { sqlite3ErrorMsg ( pParse , ""unsupported<S2SV_blank>encoding:<S2SV_blank>%s"" , zRight ) ; } } } } break ; # endif # ifndef SQLITE_OMIT_SCHEMA_VERSION_PRAGMAS case PragTyp_HEADER_VALUE : { int iCookie = pPragma -> iArg ; sqlite3VdbeUsesBtree ( v , iDb ) ; if ( zRight && ( pPragma -> mPragFlg & PragFlg_ReadOnly ) == 0 ) { static const VdbeOpList setCookie [ ] = { { OP_Transaction , 0 , 1 , 0 } , { OP_SetCookie , 0 , 0 , 0 } , } ; VdbeOp * aOp ; sqlite3VdbeVerifyNoMallocRequired ( v , ArraySize ( setCookie ) ) ; aOp = sqlite3VdbeAddOpList ( v , ArraySize ( setCookie ) , setCookie , 0 ) ; if ( ONLY_IF_REALLOC_STRESS ( aOp == 0 ) ) break ; aOp [ 0 ] . p1 = iDb ; aOp [ 1 ] . p1 = iDb ; aOp [ 1 ] . p2 = iCookie ; aOp [ 1 ] . p3 = sqlite3Atoi ( zRight ) ; } else { static const VdbeOpList readCookie [ ] = { { OP_Transaction , 0 , 0 , 0 } , { OP_ReadCookie , 0 , 1 , 0 } , { OP_ResultRow , 1 , 1 , 0 } } ; VdbeOp * aOp ; sqlite3VdbeVerifyNoMallocRequired ( v , ArraySize ( readCookie ) ) ; aOp = sqlite3VdbeAddOpList ( v , ArraySize ( readCookie ) , readCookie , 0 ) ; if ( ONLY_IF_REALLOC_STRESS ( aOp == 0 ) ) break ; aOp [ 0 ] . p1 = iDb ; aOp [ 1 ] . p1 = iDb ; aOp [ 1 ] . p3 = iCookie ; sqlite3VdbeReusable ( v ) ; } } break ; # endif # ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS case PragTyp_COMPILE_OPTIONS : { int i = 0 ; const char * zOpt ; pParse -> nMem = 1 ; while ( ( zOpt = sqlite3_compileoption_get ( i ++ ) ) != 0 ) { sqlite3VdbeLoadString ( v , 1 , zOpt ) ; sqlite3VdbeAddOp2 ( v , OP_ResultRow , 1 , 1 ) ; } sqlite3VdbeReusable ( v ) ; } break ; # endif # ifndef SQLITE_OMIT_WAL case PragTyp_WAL_CHECKPOINT : { int iBt = ( pId2 -> z ? iDb : SQLITE_MAX_ATTACHED ) ; int eMode = SQLITE_CHECKPOINT_PASSIVE ; if ( zRight ) { if ( sqlite3StrICmp ( zRight , ""full"" ) == 0 ) { eMode = SQLITE_CHECKPOINT_FULL ; } else if ( sqlite3StrICmp ( zRight , ""restart"" ) == 0 ) { eMode = SQLITE_CHECKPOINT_RESTART ; } else if ( sqlite3StrICmp ( zRight , ""truncate"" ) == 0 ) { eMode = SQLITE_CHECKPOINT_TRUNCATE ; } } pParse -> nMem = 3 ; sqlite3VdbeAddOp3 ( v , OP_Checkpoint , iBt , eMode , 1 ) ; sqlite3VdbeAddOp2 ( v , OP_ResultRow , 1 , 3 ) ; } break ; case PragTyp_WAL_AUTOCHECKPOINT : { if ( zRight ) { sqlite3_wal_autocheckpoint ( db , sqlite3Atoi ( zRight ) ) ; } returnSingleInt ( v , db -> xWalCallback == sqlite3WalDefaultHook ? SQLITE_PTR_TO_INT ( db -> pWalArg ) : 0 ) ; } break ; # endif case PragTyp_SHRINK_MEMORY : { sqlite3_db_release_memory ( db ) ; break ; } case PragTyp_OPTIMIZE : { int iDbLast ; int iTabCur ; HashElem * k ; Schema * pSchema ; Table * pTab ; Index * pIdx ; LogEst szThreshold ; char * zSubSql ; u32 opMask ; if ( zRight ) { opMask = ( u32 ) sqlite3Atoi ( zRight ) ; if ( ( opMask & 0x02 ) == 0 ) break ; } else { opMask = 0xfffe ; } iTabCur = pParse -> nTab ++ ; for ( iDbLast = zDb ? iDb : db -> nDb - 1 ; iDb <= iDbLast ; iDb ++ ) { if ( iDb == 1 ) continue ; sqlite3CodeVerifySchema ( pParse , iDb ) ; pSchema = db -> aDb [ iDb ] . pSchema ; for ( k = sqliteHashFirst ( & pSchema -> tblHash ) ; k ; k = sqliteHashNext ( k ) ) { pTab = ( Table * ) sqliteHashData ( k ) ; if ( ( pTab -> tabFlags & TF_StatsUsed ) == 0 ) continue ; szThreshold = pTab -> nRowLogEst + 46 ; assert ( sqlite3LogEst ( 25 ) == 46 ) ; for ( pIdx = pTab -> pIndex ; pIdx ; pIdx = pIdx -> pNext ) { if ( ! pIdx -> hasStat1 ) { szThreshold = 0 ; break ; } } if ( szThreshold ) { sqlite3OpenTable ( pParse , iTabCur , iDb , pTab , OP_OpenRead ) ; sqlite3VdbeAddOp3 ( v , OP_IfSmaller , iTabCur , sqlite3VdbeCurrentAddr ( v ) + 2 + ( opMask & 1 ) , szThreshold ) ; VdbeCoverage ( v ) ; } zSubSql = sqlite3MPrintf ( db , ""ANALYZE<S2SV_blank>\\""%w\\"".\\""%w\\"""" , db -> aDb [ iDb ] . zDbSName , pTab -> zName ) ; if ( opMask & 0x01 ) { int r1 = sqlite3GetTempReg ( pParse ) ; sqlite3VdbeAddOp4 ( v , OP_String8 , 0 , r1 , 0 , zSubSql , P4_DYNAMIC ) ; sqlite3VdbeAddOp2 ( v , OP_ResultRow , r1 , 1 ) ; } else { sqlite3VdbeAddOp4 ( v , OP_SqlExec , 0 , 0 , 0 , zSubSql , P4_DYNAMIC ) ; } } } sqlite3VdbeAddOp0 ( v , OP_Expire ) ; break ; } default : { assert ( pPragma -> ePragTyp == PragTyp_BUSY_TIMEOUT ) ; if ( zRight ) { sqlite3_busy_timeout ( db , sqlite3Atoi ( zRight ) ) ; } returnSingleInt ( v , db -> busyTimeout ) ; break ; } case PragTyp_SOFT_HEAP_LIMIT : { sqlite3_int64 N ; if ( zRight && sqlite3DecOrHexToI64 ( zRight , & N ) == SQLITE_OK ) { sqlite3_soft_heap_limit64 ( N ) ; } returnSingleInt ( v , sqlite3_soft_heap_limit64 ( - 1 ) ) ; break ; } case PragTyp_HARD_HEAP_LIMIT : { sqlite3_int64 N ; if ( zRight && sqlite3DecOrHexToI64 ( zRight , & N ) == SQLITE_OK ) { sqlite3_int64 iPrior = sqlite3_hard_heap_limit64 ( - 1 ) ; if ( N > 0 && ( iPrior == 0 || iPrior > N ) ) sqlite3_hard_heap_limit64 ( N ) ; } returnSingleInt ( v , sqlite3_hard_heap_limit64 ( - 1 ) ) ; break ; } case PragTyp_THREADS : { sqlite3_int64 N ; if ( zRight && sqlite3DecOrHexToI64 ( zRight , & N ) == SQLITE_OK && N >= 0 ) { sqlite3_limit ( db , SQLITE_LIMIT_WORKER_THREADS , ( int ) ( N & 0x7fffffff ) ) ; } returnSingleInt ( v , sqlite3_limit ( db , SQLITE_LIMIT_WORKER_THREADS , - 1 ) ) ; break ; } # if defined ( SQLITE_DEBUG ) || defined ( SQLITE_TEST ) case PragTyp_LOCK_STATUS : { static const char * const azLockName [ ] = { ""unlocked"" , ""shared"" , ""reserved"" , ""pending"" , ""exclusive"" } ; int i ; pParse -> nMem = 2 ; for ( i = 0 ; i < db -> nDb ; i ++ ) { Btree * pBt ; const char * zState = ""unknown"" ; int j ; if ( db -> aDb [ i ] . zDbSName == 0 ) continue ; pBt = db -> aDb [ i ] . pBt ; if ( pBt == 0 || sqlite3BtreePager ( pBt ) == 0 ) { zState = ""closed"" ; } else if ( sqlite3_file_control ( db , i ? db -> aDb [ i ] . zDbSName : 0 , SQLITE_FCNTL_LOCKSTATE , & j ) == SQLITE_OK ) { zState = azLockName [ j ] ; } sqlite3VdbeMultiLoad ( v , 1 , ""ss"" , db -> aDb [ i ] . zDbSName , zState ) ; } break ; } # endif # ifdef SQLITE_HAS_CODEC case PragTyp_KEY : { if ( zRight ) { char zBuf [ 40 ] ; const char * zKey = zRight ; int n ; if ( pPragma -> iArg == 2 || pPragma -> iArg == 3 ) { u8 iByte ; int i ; for ( i = 0 , iByte = 0 ; i < sizeof ( zBuf ) * 2 && sqlite3Isxdigit ( zRight [ i ] ) ; i ++ ) { iByte = ( iByte << 4 ) + sqlite3HexToInt ( zRight [ i ] ) ; if ( ( i & 1 ) != 0 ) zBuf [ i / 2 ] = iByte ; } zKey = zBuf ; n = i / 2 ; } else { n = pPragma -> iArg < 4 ? sqlite3Strlen30 ( zRight ) : - 1 ; } if ( ( pPragma -> iArg & 1 ) == 0 ) { rc = sqlite3_key_v2 ( db , zDb , zKey , n ) ; } else { rc = sqlite3_rekey_v2 ( db , zDb , zKey , n ) ; } if ( rc == SQLITE_OK && n != 0 ) { sqlite3VdbeSetNumCols ( v , 1 ) ; sqlite3VdbeSetColName ( v , 0 , COLNAME_NAME , ""ok"" , SQLITE_STATIC ) ; returnSingleText ( v , ""ok"" ) ; } } break ; } # endif # if defined ( SQLITE_HAS_CODEC ) || defined ( SQLITE_ENABLE_CEROD ) case PragTyp_ACTIVATE_EXTENSIONS : if ( zRight ) { # ifdef SQLITE_HAS_CODEC if ( sqlite3StrNICmp ( zRight , ""see-"" , 4 ) == 0 ) { sqlite3_activate_see ( & zRight [ 4 ] ) ; } # endif # ifdef SQLITE_ENABLE_CEROD if ( sqlite3StrNICmp ( zRight , ""cerod-"" , 6 ) == 0 ) { sqlite3_activate_cerod ( & zRight [ 6 ] ) ; } # endif } break ; # endif } if ( ( pPragma -> mPragFlg & PragFlg_NoColumns1 ) && zRight ) { sqlite3VdbeVerifyNoResultRow ( v ) ; } pragma_out : sqlite3DbFree ( db , zLeft ) ; sqlite3DbFree ( db , zRight ) ; }
","<S2SV_ModStart> 3 ) ; if ( sqlite3VdbeGetOp ( v , - 1 ) -> opcode == OP_Column ) { <S2SV_ModStart> OPFLAG_TYPEOFARG ) ; }
"
208,"CWE-772 int virtio_gpu_object_create ( struct virtio_gpu_device * vgdev , unsigned long size , bool kernel , bool pinned , struct virtio_gpu_object * * bo_ptr ) { struct virtio_gpu_object * bo ; enum ttm_bo_type type ; size_t acc_size ; int ret ; if ( kernel ) type = ttm_bo_type_kernel ; else type = ttm_bo_type_device ; * bo_ptr = NULL ; acc_size = ttm_bo_dma_acc_size ( & vgdev -> mman . bdev , size , sizeof ( struct virtio_gpu_object ) ) ; bo = kzalloc ( sizeof ( struct virtio_gpu_object ) , GFP_KERNEL ) ; if ( bo == NULL ) return - ENOMEM ; size = roundup ( size , PAGE_SIZE ) ; ret = drm_gem_object_init ( vgdev -> ddev , & bo -> gem_base , size ) ; if ( ret != 0 ) <S2SV_StartBug> return ret ; <S2SV_EndBug> bo -> dumb = false ; virtio_gpu_init_ttm_placement ( bo , pinned ) ; ret = ttm_bo_init ( & vgdev -> mman . bdev , & bo -> tbo , size , type , & bo -> placement , 0 , ! kernel , NULL , acc_size , NULL , NULL , & virtio_gpu_ttm_bo_destroy ) ; if ( ret != 0 ) return ret ; * bo_ptr = bo ; return 0 ; }
","<S2SV_ModStart> != 0 ) { kfree ( bo ) ; return ret ; } <S2SV_ModEnd> bo -> dumb
"
209,"CWE-362 static long __mptctl_ioctl ( struct file * file , unsigned int cmd , unsigned long arg ) { mpt_ioctl_header __user * uhdr = ( void __user * ) arg ; mpt_ioctl_header khdr ; int iocnum ; unsigned iocnumX ; int nonblock = ( file -> f_flags & O_NONBLOCK ) ; int ret ; MPT_ADAPTER * iocp = NULL ; if ( copy_from_user ( & khdr , uhdr , sizeof ( khdr ) ) ) { printk ( KERN_ERR MYNAM ""%s::mptctl_ioctl()<S2SV_blank>@%d<S2SV_blank>-<S2SV_blank>"" ""Unable<S2SV_blank>to<S2SV_blank>copy<S2SV_blank>mpt_ioctl_header<S2SV_blank>data<S2SV_blank>@<S2SV_blank>%p\\n"" , __FILE__ , __LINE__ , uhdr ) ; return - EFAULT ; } ret = - ENXIO ; iocnumX = khdr . iocnum & 0xFF ; if ( ( ( iocnum = mpt_verify_adapter ( iocnumX , & iocp ) ) < 0 ) || ( iocp == NULL ) ) return - ENODEV ; if ( ! iocp -> active ) { printk ( KERN_DEBUG MYNAM ""%s::mptctl_ioctl()<S2SV_blank>@%d<S2SV_blank>-<S2SV_blank>Controller<S2SV_blank>disabled.\\n"" , __FILE__ , __LINE__ ) ; return - EFAULT ; } if ( ( cmd & ~ IOCSIZE_MASK ) == ( MPTIOCINFO & ~ IOCSIZE_MASK ) ) { <S2SV_StartBug> return mptctl_getiocinfo ( arg , _IOC_SIZE ( cmd ) ) ; <S2SV_EndBug> } else if ( cmd == MPTTARGETINFO ) { <S2SV_StartBug> return mptctl_gettargetinfo ( arg ) ; <S2SV_EndBug> } else if ( cmd == MPTTEST ) { <S2SV_StartBug> return mptctl_readtest ( arg ) ; <S2SV_EndBug> } else if ( cmd == MPTEVENTQUERY ) { <S2SV_StartBug> return mptctl_eventquery ( arg ) ; <S2SV_EndBug> } else if ( cmd == MPTEVENTENABLE ) { <S2SV_StartBug> return mptctl_eventenable ( arg ) ; <S2SV_EndBug> } else if ( cmd == MPTEVENTREPORT ) { <S2SV_StartBug> return mptctl_eventreport ( arg ) ; <S2SV_EndBug> } else if ( cmd == MPTFWREPLACE ) { <S2SV_StartBug> return mptctl_replace_fw ( arg ) ; <S2SV_EndBug> } if ( ( ret = mptctl_syscall_down ( iocp , nonblock ) ) != 0 ) return ret ; if ( cmd == MPTFWDOWNLOAD ) <S2SV_StartBug> ret = mptctl_fw_download ( arg ) ; <S2SV_EndBug> else if ( cmd == MPTCOMMAND ) <S2SV_StartBug> ret = mptctl_mpt_command ( arg ) ; <S2SV_EndBug> else if ( cmd == MPTHARDRESET ) <S2SV_StartBug> ret = mptctl_do_reset ( arg ) ; <S2SV_EndBug> else if ( ( cmd & ~ IOCSIZE_MASK ) == ( HP_GETHOSTINFO & ~ IOCSIZE_MASK ) ) <S2SV_StartBug> ret = mptctl_hp_hostinfo ( arg , _IOC_SIZE ( cmd ) ) ; <S2SV_EndBug> else if ( cmd == HP_GETTARGETINFO ) <S2SV_StartBug> ret = mptctl_hp_targetinfo ( arg ) ; <S2SV_EndBug> else ret = - EINVAL ; mutex_unlock ( & iocp -> ioctl_cmds . mutex ) ; return ret ; }
","<S2SV_ModStart> return mptctl_getiocinfo ( iocp , <S2SV_ModStart> return mptctl_gettargetinfo ( iocp , <S2SV_ModStart> return mptctl_readtest ( iocp , <S2SV_ModStart> return mptctl_eventquery ( iocp , <S2SV_ModStart> return mptctl_eventenable ( iocp , <S2SV_ModStart> return mptctl_eventreport ( iocp , <S2SV_ModStart> return mptctl_replace_fw ( iocp , <S2SV_ModStart> = mptctl_fw_download ( iocp , <S2SV_ModStart> = mptctl_mpt_command ( iocp , <S2SV_ModStart> = mptctl_do_reset ( iocp , <S2SV_ModStart> = mptctl_hp_hostinfo ( iocp , <S2SV_ModStart> = mptctl_hp_targetinfo ( iocp ,
"
210,"CWE-400 <S2SV_StartBug> static int __perf_event_overflow ( struct perf_event * event , int nmi , <S2SV_EndBug> int throttle , struct perf_sample_data * data , struct pt_regs * regs ) { int events = atomic_read ( & event -> event_limit ) ; struct hw_perf_event * hwc = & event -> hw ; int ret = 0 ; if ( unlikely ( ! is_sampling_event ( event ) ) ) return 0 ; if ( unlikely ( hwc -> interrupts >= max_samples_per_tick ) ) { if ( throttle ) { hwc -> interrupts = MAX_INTERRUPTS ; perf_log_throttle ( event , 0 ) ; ret = 1 ; } } else hwc -> interrupts ++ ; if ( event -> attr . freq ) { u64 now = perf_clock ( ) ; s64 delta = now - hwc -> freq_time_stamp ; hwc -> freq_time_stamp = now ; if ( delta > 0 && delta < 2 * TICK_NSEC ) perf_adjust_period ( event , delta , hwc -> last_period ) ; } event -> pending_kill = POLL_IN ; if ( events && atomic_dec_and_test ( & event -> event_limit ) ) { ret = 1 ; event -> pending_kill = POLL_HUP ; <S2SV_StartBug> if ( nmi ) { <S2SV_EndBug> event -> pending_disable = 1 ; irq_work_queue ( & event -> pending ) ; <S2SV_StartBug> } else <S2SV_EndBug> perf_event_disable ( event ) ; } if ( event -> overflow_handler ) event -> overflow_handler ( event , nmi , data , regs ) ; else <S2SV_StartBug> perf_event_output ( event , nmi , data , regs ) ; <S2SV_EndBug> if ( event -> fasync && event -> pending_kill ) { <S2SV_StartBug> if ( nmi ) { <S2SV_EndBug> event -> pending_wakeup = 1 ; <S2SV_StartBug> irq_work_queue ( & event -> pending ) ; <S2SV_EndBug> } else perf_event_wakeup ( event ) ; } return ret ; }
","<S2SV_ModStart> perf_event * event <S2SV_ModEnd> , int throttle <S2SV_ModStart> = POLL_HUP ; <S2SV_ModEnd> event -> pending_disable <S2SV_ModStart> ) ; } if ( event -> overflow_handler ) event -> overflow_handler ( event , data , regs ) ; else <S2SV_ModEnd> perf_event_output ( event <S2SV_ModStart> perf_event_output ( event <S2SV_ModEnd> , data , <S2SV_ModStart> pending_kill ) { <S2SV_ModEnd> event -> pending_wakeup <S2SV_ModStart> event -> pending <S2SV_ModEnd> ) ; }
"
211,"CWE-399 SYSCALL_DEFINE1 ( inotify_init1 , int , flags ) { <S2SV_StartBug> struct fsnotify_group * group ; <S2SV_EndBug> struct user_struct * user ; int ret ; BUILD_BUG_ON ( IN_CLOEXEC != O_CLOEXEC ) ; BUILD_BUG_ON ( IN_NONBLOCK != O_NONBLOCK ) ; if ( flags & ~ ( IN_CLOEXEC | IN_NONBLOCK ) ) return - EINVAL ; <S2SV_StartBug> user = get_current_user ( ) ; <S2SV_EndBug> if ( unlikely ( atomic_read ( & user -> inotify_devs ) >= inotify_max_user_instances ) ) { ret = - EMFILE ; goto out_free_uid ; } <S2SV_StartBug> group = inotify_new_group ( user , inotify_max_queued_events ) ; <S2SV_EndBug> <S2SV_StartBug> if ( IS_ERR ( group ) ) { <S2SV_EndBug> <S2SV_StartBug> ret = PTR_ERR ( group ) ; <S2SV_EndBug> goto out_free_uid ; } atomic_inc ( & user -> inotify_devs ) ; ret = anon_inode_getfd ( ""inotify"" , & inotify_fops , group , O_RDONLY | flags ) ; <S2SV_StartBug> if ( ret >= 0 ) <S2SV_EndBug> return ret ; <S2SV_StartBug> fsnotify_put_group ( group ) ; <S2SV_EndBug> atomic_dec ( & user -> inotify_devs ) ; out_free_uid : free_uid ( user ) ; return ret ; }
","<S2SV_ModStart> fsnotify_group * group <S2SV_ModEnd> ; int ret <S2SV_ModStart> - EINVAL ; <S2SV_ModEnd> group = inotify_new_group <S2SV_ModStart> = inotify_new_group ( <S2SV_ModEnd> inotify_max_queued_events ) ; <S2SV_ModStart> group ) ) return <S2SV_ModEnd> PTR_ERR ( group <S2SV_ModStart> PTR_ERR ( group <S2SV_ModEnd> ) ; ret <S2SV_ModStart> if ( ret < 0 ) <S2SV_ModEnd> fsnotify_put_group ( group <S2SV_ModStart> fsnotify_put_group ( group <S2SV_ModEnd> ) ; return
"
212,"CWE-399 static int ceph_x_decrypt ( struct ceph_crypto_key * secret , <S2SV_StartBug> void * * p , void * end , void * obuf , size_t olen ) <S2SV_EndBug> { struct ceph_x_encrypt_header head ; size_t head_len = sizeof ( head ) ; int len , ret ; len = ceph_decode_32 ( p ) ; if ( * p + len > end ) return - EINVAL ; dout ( ""ceph_x_decrypt<S2SV_blank>len<S2SV_blank>%d\\n"" , len ) ; <S2SV_StartBug> ret = ceph_decrypt2 ( secret , & head , & head_len , obuf , & olen , <S2SV_EndBug> * p , len ) ; if ( ret ) return ret ; if ( head . struct_v != 1 || le64_to_cpu ( head . magic ) != CEPHX_ENC_MAGIC ) return - EPERM ; * p += len ; return olen ; }
","<S2SV_ModStart> end , void * <S2SV_ModStart> len ) ; if ( * obuf == NULL ) { * obuf = kmalloc ( len , GFP_NOFS ) ; if ( ! * obuf ) return - ENOMEM ; olen = len ; } <S2SV_ModStart> & head_len , *
"
213,"CWE-362 static int snd_timer_user_open ( struct inode * inode , struct file * file ) { struct snd_timer_user * tu ; int err ; err = nonseekable_open ( inode , file ) ; if ( err < 0 ) return err ; tu = kzalloc ( sizeof ( * tu ) , GFP_KERNEL ) ; if ( tu == NULL ) return - ENOMEM ; spin_lock_init ( & tu -> qlock ) ; init_waitqueue_head ( & tu -> qchange_sleep ) ; <S2SV_StartBug> mutex_init ( & tu -> tread_sem ) ; <S2SV_EndBug> tu -> ticks = 1 ; tu -> queue_size = 128 ; tu -> queue = kmalloc ( tu -> queue_size * sizeof ( struct snd_timer_read ) , GFP_KERNEL ) ; if ( tu -> queue == NULL ) { kfree ( tu ) ; return - ENOMEM ; } file -> private_data = tu ; return 0 ; }
","<S2SV_ModStart> & tu -> ioctl_lock <S2SV_ModEnd> ) ; tu
"
214,"CWE-119 static void decode_residue ( vorb * f , float * residue_buffers [ ] , int ch , int n , int rn , uint8 * do_not_decode ) { int i , j , pass ; Residue * r = f -> residue_config + rn ; int rtype = f -> residue_types [ rn ] ; int c = r -> classbook ; int classwords = f -> codebooks [ c ] . dimensions ; <S2SV_StartBug> int n_read = r -> end - r -> begin ; <S2SV_EndBug> int part_read = n_read / r -> part_size ; int temp_alloc_point = temp_alloc_save ( f ) ; # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE uint8 * * * part_classdata = ( uint8 * * * ) temp_block_array ( f , f -> channels , part_read * sizeof ( * * part_classdata ) ) ; # else int * * classifications = ( int * * ) temp_block_array ( f , f -> channels , part_read * sizeof ( * * classifications ) ) ; # endif CHECK ( f ) ; for ( i = 0 ; i < ch ; ++ i ) if ( ! do_not_decode [ i ] ) memset ( residue_buffers [ i ] , 0 , sizeof ( float ) * n ) ; if ( rtype == 2 && ch != 1 ) { for ( j = 0 ; j < ch ; ++ j ) if ( ! do_not_decode [ j ] ) break ; if ( j == ch ) goto done ; for ( pass = 0 ; pass < 8 ; ++ pass ) { int pcount = 0 , class_set = 0 ; if ( ch == 2 ) { while ( pcount < part_read ) { int z = r -> begin + pcount * r -> part_size ; int c_inter = ( z & 1 ) , p_inter = z >> 1 ; if ( pass == 0 ) { Codebook * c = f -> codebooks + r -> classbook ; int q ; DECODE ( q , f , c ) ; if ( q == EOP ) goto done ; # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE part_classdata [ 0 ] [ class_set ] = r -> classdata [ q ] ; # else for ( i = classwords - 1 ; i >= 0 ; -- i ) { classifications [ 0 ] [ i + pcount ] = q % r -> classifications ; q /= r -> classifications ; } # endif } for ( i = 0 ; i < classwords && pcount < part_read ; ++ i , ++ pcount ) { int z = r -> begin + pcount * r -> part_size ; # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE int c = part_classdata [ 0 ] [ class_set ] [ i ] ; # else int c = classifications [ 0 ] [ pcount ] ; # endif int b = r -> residue_books [ c ] [ pass ] ; if ( b >= 0 ) { Codebook * book = f -> codebooks + b ; # ifdef STB_VORBIS_DIVIDES_IN_CODEBOOK if ( ! codebook_decode_deinterleave_repeat ( f , book , residue_buffers , ch , & c_inter , & p_inter , n , r -> part_size ) ) goto done ; # else if ( ! codebook_decode_deinterleave_repeat ( f , book , residue_buffers , ch , & c_inter , & p_inter , n , r -> part_size ) ) goto done ; # endif } else { z += r -> part_size ; c_inter = z & 1 ; p_inter = z >> 1 ; } } # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE ++ class_set ; # endif } } else if ( ch == 1 ) { while ( pcount < part_read ) { int z = r -> begin + pcount * r -> part_size ; int c_inter = 0 , p_inter = z ; if ( pass == 0 ) { Codebook * c = f -> codebooks + r -> classbook ; int q ; DECODE ( q , f , c ) ; if ( q == EOP ) goto done ; # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE part_classdata [ 0 ] [ class_set ] = r -> classdata [ q ] ; # else for ( i = classwords - 1 ; i >= 0 ; -- i ) { classifications [ 0 ] [ i + pcount ] = q % r -> classifications ; q /= r -> classifications ; } # endif } for ( i = 0 ; i < classwords && pcount < part_read ; ++ i , ++ pcount ) { int z = r -> begin + pcount * r -> part_size ; # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE int c = part_classdata [ 0 ] [ class_set ] [ i ] ; # else int c = classifications [ 0 ] [ pcount ] ; # endif int b = r -> residue_books [ c ] [ pass ] ; if ( b >= 0 ) { Codebook * book = f -> codebooks + b ; if ( ! codebook_decode_deinterleave_repeat ( f , book , residue_buffers , ch , & c_inter , & p_inter , n , r -> part_size ) ) goto done ; } else { z += r -> part_size ; c_inter = 0 ; p_inter = z ; } } # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE ++ class_set ; # endif } } else { while ( pcount < part_read ) { int z = r -> begin + pcount * r -> part_size ; int c_inter = z % ch , p_inter = z / ch ; if ( pass == 0 ) { Codebook * c = f -> codebooks + r -> classbook ; int q ; DECODE ( q , f , c ) ; if ( q == EOP ) goto done ; # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE part_classdata [ 0 ] [ class_set ] = r -> classdata [ q ] ; # else for ( i = classwords - 1 ; i >= 0 ; -- i ) { classifications [ 0 ] [ i + pcount ] = q % r -> classifications ; q /= r -> classifications ; } # endif } for ( i = 0 ; i < classwords && pcount < part_read ; ++ i , ++ pcount ) { int z = r -> begin + pcount * r -> part_size ; # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE int c = part_classdata [ 0 ] [ class_set ] [ i ] ; # else int c = classifications [ 0 ] [ pcount ] ; # endif int b = r -> residue_books [ c ] [ pass ] ; if ( b >= 0 ) { Codebook * book = f -> codebooks + b ; if ( ! codebook_decode_deinterleave_repeat ( f , book , residue_buffers , ch , & c_inter , & p_inter , n , r -> part_size ) ) goto done ; } else { z += r -> part_size ; c_inter = z % ch ; p_inter = z / ch ; } } # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE ++ class_set ; # endif } } } goto done ; } CHECK ( f ) ; for ( pass = 0 ; pass < 8 ; ++ pass ) { int pcount = 0 , class_set = 0 ; while ( pcount < part_read ) { if ( pass == 0 ) { for ( j = 0 ; j < ch ; ++ j ) { if ( ! do_not_decode [ j ] ) { Codebook * c = f -> codebooks + r -> classbook ; int temp ; DECODE ( temp , f , c ) ; if ( temp == EOP ) goto done ; # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE part_classdata [ j ] [ class_set ] = r -> classdata [ temp ] ; # else for ( i = classwords - 1 ; i >= 0 ; -- i ) { classifications [ j ] [ i + pcount ] = temp % r -> classifications ; temp /= r -> classifications ; } # endif } } } for ( i = 0 ; i < classwords && pcount < part_read ; ++ i , ++ pcount ) { for ( j = 0 ; j < ch ; ++ j ) { if ( ! do_not_decode [ j ] ) { # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE int c = part_classdata [ j ] [ class_set ] [ i ] ; # else int c = classifications [ j ] [ pcount ] ; # endif int b = r -> residue_books [ c ] [ pass ] ; if ( b >= 0 ) { float * target = residue_buffers [ j ] ; int offset = r -> begin + pcount * r -> part_size ; int n = r -> part_size ; Codebook * book = f -> codebooks + b ; if ( ! residue_decode ( f , book , target , offset , n , rtype ) ) goto done ; } } } } # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE ++ class_set ; # endif } } done : CHECK ( f ) ; # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE temp_free ( f , part_classdata ) ; # else temp_free ( f , classifications ) ; # endif temp_alloc_restore ( f , temp_alloc_point ) ; }
","<S2SV_ModStart> . dimensions ; unsigned int actual_size = rtype == 2 ? n * 2 : n ; unsigned int limit_r_begin = ( r -> begin < actual_size ? r -> begin : actual_size ) ; unsigned int limit_r_end = ( r -> end < actual_size ? r -> end : actual_size ) ; <S2SV_ModStart> int n_read = limit_r_end - limit_r_begin <S2SV_ModEnd> ; int part_read
"
215,"CWE-119 static uint32_t scsi_init_iovec ( SCSIDiskReq * r ) <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> r -> iov . iov_len = MIN ( r -> sector_count * 512 , SCSI_DMA_BUF_SIZE ) ; <S2SV_EndBug> qemu_iovec_init_external ( & r -> qiov , & r -> iov , 1 ) ; return r -> qiov . size / 512 ; }
","<S2SV_ModStart> r ) { SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> req . dev ) ; if ( ! r -> iov . iov_base ) { r -> buflen = SCSI_DMA_BUF_SIZE ; r -> iov . iov_base = qemu_blockalign ( s -> bs , r -> buflen ) ; } <S2SV_ModStart> * 512 , r -> buflen <S2SV_ModEnd> ) ; qemu_iovec_init_external
"
216,"CWE-264 static int em_jcxz ( struct x86_emulate_ctxt * ctxt ) <S2SV_StartBug> { <S2SV_EndBug> if ( address_mask ( ctxt , reg_read ( ctxt , VCPU_REGS_RCX ) ) == 0 ) <S2SV_StartBug> jmp_rel ( ctxt , ctxt -> src . val ) ; <S2SV_EndBug> <S2SV_StartBug> return X86EMUL_CONTINUE ; <S2SV_EndBug> }
","<S2SV_ModStart> ctxt ) { int rc = X86EMUL_CONTINUE ; <S2SV_ModStart> == 0 ) rc = <S2SV_ModStart> ) ; return rc <S2SV_ModEnd> ; } <S2SV_null>
"
217,"CWE-399 static int br_mdb_dump ( struct sk_buff * skb , struct netlink_callback * cb ) { struct net_device * dev ; struct net * net = sock_net ( skb -> sk ) ; struct nlmsghdr * nlh = NULL ; int idx = 0 , s_idx ; s_idx = cb -> args [ 0 ] ; rcu_read_lock ( ) ; cb -> seq = net -> dev_base_seq + br_mdb_rehash_seq ; for_each_netdev_rcu ( net , dev ) { if ( dev -> priv_flags & IFF_EBRIDGE ) { struct br_port_msg * bpm ; if ( idx < s_idx ) goto skip ; nlh = nlmsg_put ( skb , NETLINK_CB ( cb -> skb ) . portid , cb -> nlh -> nlmsg_seq , RTM_GETMDB , sizeof ( * bpm ) , NLM_F_MULTI ) ; if ( nlh == NULL ) break ; <S2SV_StartBug> bpm = nlmsg_data ( nlh ) ; <S2SV_EndBug> bpm -> ifindex = dev -> ifindex ; if ( br_mdb_fill_info ( skb , cb , dev ) < 0 ) goto out ; if ( br_rports_fill_info ( skb , cb , dev ) < 0 ) goto out ; cb -> args [ 1 ] = 0 ; nlmsg_end ( skb , nlh ) ; skip : idx ++ ; } } out : if ( nlh ) nlmsg_end ( skb , nlh ) ; rcu_read_unlock ( ) ; cb -> args [ 0 ] = idx ; return skb -> len ; }
","<S2SV_ModStart> nlmsg_data ( nlh ) ; memset ( bpm , 0 , sizeof ( * bpm )
"
218,"CWE-200 static int raw_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; size_t copied = 0 ; int err = - EOPNOTSUPP ; struct sockaddr_in * sin = ( struct sockaddr_in * ) msg -> msg_name ; struct sk_buff * skb ; if ( flags & MSG_OOB ) <S2SV_StartBug> goto out ; <S2SV_EndBug> if ( addr_len ) * addr_len = sizeof ( * sin ) ; if ( flags & MSG_ERRQUEUE ) { err = ip_recv_error ( sk , msg , len ) ; goto out ; } skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) goto out ; copied = skb -> len ; if ( len < copied ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto done ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( sin ) { sin -> sin_family = AF_INET ; sin -> sin_addr . s_addr = ip_hdr ( skb ) -> saddr ; sin -> sin_port = 0 ; memset ( & sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( inet -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ; if ( flags & MSG_TRUNC ) copied = skb -> len ; done : skb_free_datagram ( sk , skb ) ; out : if ( err ) return err ; return copied ; }
","<S2SV_ModStart> ) goto out <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) ; * addr_len = sizeof ( * sin ) ;
"
219,"CWE-404 static int install_thread_keyring ( void ) { struct cred * new ; int ret ; new = prepare_creds ( ) ; if ( ! new ) <S2SV_StartBug> return - ENOMEM ; <S2SV_EndBug> BUG_ON ( new -> thread_keyring ) ; ret = install_thread_keyring_to_cred ( new ) ; if ( ret < 0 ) { abort_creds ( new ) ; return ret ; } return commit_creds ( new ) ; }
","<S2SV_ModStart> return - ENOMEM <S2SV_ModEnd> ; ret =
"
220,"CWE-189 static int do_check ( struct bpf_verifier_env * env ) { struct bpf_verifier_state * state ; struct bpf_insn * insns = env -> prog -> insnsi ; struct bpf_reg_state * regs ; int insn_cnt = env -> prog -> len , i ; int insn_processed = 0 ; bool do_print_state = false ; env -> prev_linfo = NULL ; state = kzalloc ( sizeof ( struct bpf_verifier_state ) , GFP_KERNEL ) ; if ( ! state ) return - ENOMEM ; state -> curframe = 0 ; <S2SV_StartBug> state -> frame [ 0 ] = kzalloc ( sizeof ( struct bpf_func_state ) , GFP_KERNEL ) ; <S2SV_EndBug> if ( ! state -> frame [ 0 ] ) { kfree ( state ) ; return - ENOMEM ; } env -> cur_state = state ; init_func_state ( env , state -> frame [ 0 ] , BPF_MAIN_FUNC , 0 , 0 ) ; for ( ; ; ) { struct bpf_insn * insn ; u8 class ; int err ; if ( env -> insn_idx >= insn_cnt ) { verbose ( env , ""invalid<S2SV_blank>insn<S2SV_blank>idx<S2SV_blank>%d<S2SV_blank>insn_cnt<S2SV_blank>%d\\n"" , env -> insn_idx , insn_cnt ) ; return - EFAULT ; } insn = & insns [ env -> insn_idx ] ; class = BPF_CLASS ( insn -> code ) ; if ( ++ insn_processed > BPF_COMPLEXITY_LIMIT_INSNS ) { verbose ( env , ""BPF<S2SV_blank>program<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large.<S2SV_blank>Processed<S2SV_blank>%d<S2SV_blank>insn\\n"" , insn_processed ) ; return - E2BIG ; } err = is_state_visited ( env , env -> insn_idx ) ; if ( err < 0 ) return err ; if ( err == 1 ) { if ( env -> log . level ) { if ( do_print_state ) <S2SV_StartBug> verbose ( env , ""\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d:<S2SV_blank>safe\\n"" , <S2SV_EndBug> <S2SV_StartBug> env -> prev_insn_idx , env -> insn_idx ) ; <S2SV_EndBug> else verbose ( env , ""%d:<S2SV_blank>safe\\n"" , env -> insn_idx ) ; } goto process_bpf_exit ; } if ( signal_pending ( current ) ) return - EAGAIN ; if ( need_resched ( ) ) cond_resched ( ) ; if ( env -> log . level > 1 || ( env -> log . level && do_print_state ) ) { if ( env -> log . level > 1 ) verbose ( env , ""%d:"" , env -> insn_idx ) ; else <S2SV_StartBug> verbose ( env , ""\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d:"" , <S2SV_EndBug> <S2SV_StartBug> env -> prev_insn_idx , env -> insn_idx ) ; <S2SV_EndBug> print_verifier_state ( env , state -> frame [ state -> curframe ] ) ; do_print_state = false ; } if ( env -> log . level ) { const struct bpf_insn_cbs cbs = { . cb_print = verbose , . private_data = env , } ; verbose_linfo ( env , env -> insn_idx , "";<S2SV_blank>"" ) ; verbose ( env , ""%d:<S2SV_blank>"" , env -> insn_idx ) ; print_bpf_insn ( & cbs , insn , env -> allow_ptr_leaks ) ; } if ( bpf_prog_is_dev_bound ( env -> prog -> aux ) ) { err = bpf_prog_offload_verify_insn ( env , env -> insn_idx , env -> prev_insn_idx ) ; if ( err ) return err ; } regs = cur_regs ( env ) ; env -> insn_aux_data [ env -> insn_idx ] . seen = true ; if ( class == BPF_ALU || class == BPF_ALU64 ) { err = check_alu_op ( env , insn ) ; if ( err ) return err ; } else if ( class == BPF_LDX ) { enum bpf_reg_type * prev_src_type , src_reg_type ; err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; err = check_reg_arg ( env , insn -> dst_reg , DST_OP_NO_MARK ) ; if ( err ) return err ; src_reg_type = regs [ insn -> src_reg ] . type ; err = check_mem_access ( env , env -> insn_idx , insn -> src_reg , insn -> off , BPF_SIZE ( insn -> code ) , BPF_READ , insn -> dst_reg , false ) ; if ( err ) return err ; prev_src_type = & env -> insn_aux_data [ env -> insn_idx ] . ptr_type ; if ( * prev_src_type == NOT_INIT ) { * prev_src_type = src_reg_type ; } else if ( reg_type_mismatch ( src_reg_type , * prev_src_type ) ) { verbose ( env , ""same<S2SV_blank>insn<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>used<S2SV_blank>with<S2SV_blank>different<S2SV_blank>pointers\\n"" ) ; return - EINVAL ; } } else if ( class == BPF_STX ) { enum bpf_reg_type * prev_dst_type , dst_reg_type ; if ( BPF_MODE ( insn -> code ) == BPF_XADD ) { err = check_xadd ( env , env -> insn_idx , insn ) ; if ( err ) return err ; env -> insn_idx ++ ; continue ; } err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; dst_reg_type = regs [ insn -> dst_reg ] . type ; err = check_mem_access ( env , env -> insn_idx , insn -> dst_reg , insn -> off , BPF_SIZE ( insn -> code ) , BPF_WRITE , insn -> src_reg , false ) ; if ( err ) return err ; prev_dst_type = & env -> insn_aux_data [ env -> insn_idx ] . ptr_type ; if ( * prev_dst_type == NOT_INIT ) { * prev_dst_type = dst_reg_type ; } else if ( reg_type_mismatch ( dst_reg_type , * prev_dst_type ) ) { verbose ( env , ""same<S2SV_blank>insn<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>used<S2SV_blank>with<S2SV_blank>different<S2SV_blank>pointers\\n"" ) ; return - EINVAL ; } } else if ( class == BPF_ST ) { if ( BPF_MODE ( insn -> code ) != BPF_MEM || insn -> src_reg != BPF_REG_0 ) { verbose ( env , ""BPF_ST<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; if ( is_ctx_reg ( env , insn -> dst_reg ) ) { verbose ( env , ""BPF_ST<S2SV_blank>stores<S2SV_blank>into<S2SV_blank>R%d<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed\\n"" , insn -> dst_reg , reg_type_str [ reg_state ( env , insn -> dst_reg ) -> type ] ) ; return - EACCES ; } err = check_mem_access ( env , env -> insn_idx , insn -> dst_reg , insn -> off , BPF_SIZE ( insn -> code ) , BPF_WRITE , - 1 , false ) ; if ( err ) return err ; } else if ( class == BPF_JMP ) { u8 opcode = BPF_OP ( insn -> code ) ; if ( opcode == BPF_CALL ) { if ( BPF_SRC ( insn -> code ) != BPF_K || insn -> off != 0 || ( insn -> src_reg != BPF_REG_0 && insn -> src_reg != BPF_PSEUDO_CALL ) || insn -> dst_reg != BPF_REG_0 ) { verbose ( env , ""BPF_CALL<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } if ( insn -> src_reg == BPF_PSEUDO_CALL ) err = check_func_call ( env , insn , & env -> insn_idx ) ; else err = check_helper_call ( env , insn -> imm , env -> insn_idx ) ; if ( err ) return err ; } else if ( opcode == BPF_JA ) { if ( BPF_SRC ( insn -> code ) != BPF_K || insn -> imm != 0 || insn -> src_reg != BPF_REG_0 || insn -> dst_reg != BPF_REG_0 ) { verbose ( env , ""BPF_JA<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } env -> insn_idx += insn -> off + 1 ; continue ; } else if ( opcode == BPF_EXIT ) { if ( BPF_SRC ( insn -> code ) != BPF_K || insn -> imm != 0 || insn -> src_reg != BPF_REG_0 || insn -> dst_reg != BPF_REG_0 ) { verbose ( env , ""BPF_EXIT<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } if ( state -> curframe ) { env -> prev_insn_idx = env -> insn_idx ; err = prepare_func_exit ( env , & env -> insn_idx ) ; if ( err ) return err ; do_print_state = true ; continue ; } err = check_reference_leak ( env ) ; if ( err ) return err ; err = check_reg_arg ( env , BPF_REG_0 , SRC_OP ) ; if ( err ) return err ; if ( is_pointer_value ( env , BPF_REG_0 ) ) { verbose ( env , ""R0<S2SV_blank>leaks<S2SV_blank>addr<S2SV_blank>as<S2SV_blank>return<S2SV_blank>value\\n"" ) ; return - EACCES ; } err = check_return_code ( env ) ; if ( err ) return err ; process_bpf_exit : err = pop_stack ( env , & env -> prev_insn_idx , & env -> insn_idx ) ; if ( err < 0 ) { if ( err != - ENOENT ) return err ; break ; } else { do_print_state = true ; continue ; } } else { err = check_cond_jmp_op ( env , insn , & env -> insn_idx ) ; if ( err ) return err ; } } else if ( class == BPF_LD ) { u8 mode = BPF_MODE ( insn -> code ) ; if ( mode == BPF_ABS || mode == BPF_IND ) { err = check_ld_abs ( env , insn ) ; if ( err ) return err ; } else if ( mode == BPF_IMM ) { err = check_ld_imm ( env , insn ) ; if ( err ) return err ; env -> insn_idx ++ ; env -> insn_aux_data [ env -> insn_idx ] . seen = true ; } else { verbose ( env , ""invalid<S2SV_blank>BPF_LD<S2SV_blank>mode\\n"" ) ; return - EINVAL ; } } else { verbose ( env , ""unknown<S2SV_blank>insn<S2SV_blank>class<S2SV_blank>%d\\n"" , class ) ; return - EINVAL ; } env -> insn_idx ++ ; } verbose ( env , ""processed<S2SV_blank>%d<S2SV_blank>insns<S2SV_blank>(limit<S2SV_blank>%d),<S2SV_blank>stack<S2SV_blank>depth<S2SV_blank>"" , insn_processed , BPF_COMPLEXITY_LIMIT_INSNS ) ; for ( i = 0 ; i < env -> subprog_cnt ; i ++ ) { u32 depth = env -> subprog_info [ i ] . stack_depth ; verbose ( env , ""%d"" , depth ) ; if ( i + 1 < env -> subprog_cnt ) verbose ( env , ""+"" ) ; } verbose ( env , ""\\n"" ) ; env -> prog -> aux -> stack_depth = env -> subprog_info [ 0 ] . stack_depth ; return 0 ; }
","<S2SV_ModStart> ; state -> speculative = false ; state -> <S2SV_ModStart> ( env , ""\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d%s:<S2SV_blank>safe\\n"" <S2SV_ModEnd> , env -> <S2SV_ModStart> env -> insn_idx , env -> cur_state -> speculative ? ""<S2SV_blank>(speculative<S2SV_blank>execution)"" : """" <S2SV_ModStart> ( env , ""\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d%s:"" <S2SV_ModEnd> , env -> <S2SV_ModStart> env -> insn_idx , env -> cur_state -> speculative ? ""<S2SV_blank>(speculative<S2SV_blank>execution)"" : """"
"
221,"CWE-787 char * rfbProcessFileTransferReadBuffer ( rfbClientPtr cl , uint32_t length ) { char * buffer = NULL ; int n = 0 ; FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN ( """" , cl , NULL ) ; <S2SV_StartBug> if ( length > 0 ) { <S2SV_EndBug> <S2SV_StartBug> buffer = malloc ( ( uint64_t ) length + 1 ) ; <S2SV_EndBug> if ( buffer != NULL ) { if ( ( n = rfbReadExact ( cl , ( char * ) buffer , length ) ) <= 0 ) { if ( n != 0 ) rfbLogPerror ( ""rfbProcessFileTransferReadBuffer:<S2SV_blank>read"" ) ; rfbCloseClient ( cl ) ; if ( buffer != NULL ) free ( buffer ) ; return NULL ; } buffer [ length ] = 0 ; } } return buffer ; }
","<S2SV_ModStart> if ( length == SIZE_MAX ) { rfbErr ( ""rfbProcessFileTransferReadBuffer:<S2SV_blank>too<S2SV_blank>big<S2SV_blank>file<S2SV_blank>transfer<S2SV_blank>length<S2SV_blank>requested:<S2SV_blank>%u"" , ( unsigned int ) length ) ; rfbCloseClient ( cl ) ; return NULL ; } if ( length <S2SV_ModStart> malloc ( ( size_t <S2SV_ModEnd> ) length +
"
222,"CWE-189 static int sanitize_ptr_alu ( struct bpf_verifier_env * env , struct bpf_insn * insn , const struct bpf_reg_state * ptr_reg , struct bpf_reg_state * dst_reg , bool off_is_neg ) { struct bpf_verifier_state * vstate = env -> cur_state ; struct bpf_insn_aux_data * aux = cur_aux ( env ) ; bool ptr_is_dst_reg = ptr_reg == dst_reg ; u8 opcode = BPF_OP ( insn -> code ) ; u32 alu_state , alu_limit ; struct bpf_reg_state tmp ; bool ret ; <S2SV_StartBug> if ( env -> allow_ptr_leaks || BPF_SRC ( insn -> code ) == BPF_K ) <S2SV_EndBug> return 0 ; if ( vstate -> speculative ) goto do_sim ; alu_state = off_is_neg ? BPF_ALU_NEG_VALUE : 0 ; alu_state |= ptr_is_dst_reg ? BPF_ALU_SANITIZE_SRC : BPF_ALU_SANITIZE_DST ; if ( retrieve_ptr_limit ( ptr_reg , & alu_limit , opcode , off_is_neg ) ) return 0 ; <S2SV_StartBug> if ( aux -> alu_state && <S2SV_EndBug> ( aux -> alu_state != alu_state || aux -> alu_limit != alu_limit ) ) <S2SV_StartBug> return - EACCES ; <S2SV_EndBug> aux -> alu_state = alu_state ; aux -> alu_limit = alu_limit ; do_sim : if ( ! ptr_is_dst_reg ) { tmp = * dst_reg ; * dst_reg = * ptr_reg ; } ret = push_stack ( env , env -> insn_idx + 1 , env -> insn_idx , true ) ; if ( ! ptr_is_dst_reg ) * dst_reg = tmp ; return ! ret ? - EFAULT : 0 ; }
","<S2SV_ModStart> ; if ( can_skip_alu_sanitation ( env , insn ) <S2SV_ModEnd> ) return 0 <S2SV_ModStart> ; if ( update_alu_sanitation_state ( aux , alu_state , <S2SV_ModEnd> alu_limit ) ) <S2SV_ModStart> return - EACCES <S2SV_ModEnd> ; do_sim :
"
223,"CWE-20 apr_status_t ap_http_filter ( ap_filter_t * f , apr_bucket_brigade * b , ap_input_mode_t mode , apr_read_type_e block , apr_off_t readbytes ) { core_server_config * conf ; apr_bucket * e ; http_ctx_t * ctx = f -> ctx ; apr_status_t rv ; apr_off_t totalread ; int again ; conf = ( core_server_config * ) ap_get_module_config ( f -> r -> server -> module_config , & core_module ) ; if ( mode != AP_MODE_READBYTES && mode != AP_MODE_GETLINE ) { return ap_get_brigade ( f -> next , b , mode , block , readbytes ) ; } if ( ! ctx ) { const char * tenc , * lenp ; f -> ctx = ctx = apr_pcalloc ( f -> r -> pool , sizeof ( * ctx ) ) ; ctx -> state = BODY_NONE ; if ( ! f -> r -> proxyreq ) { ctx -> limit = ap_get_limit_req_body ( f -> r ) ; } else { ctx -> limit = 0 ; } tenc = apr_table_get ( f -> r -> headers_in , ""Transfer-Encoding"" ) ; lenp = apr_table_get ( f -> r -> headers_in , ""Content-Length"" ) ; if ( tenc ) { if ( strcasecmp ( tenc , ""chunked"" ) == 0 || ap_find_last_token ( f -> r -> pool , tenc , ""chunked"" ) ) { ctx -> state = BODY_CHUNK ; } else if ( f -> r -> proxyreq == PROXYREQ_RESPONSE ) { ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , f -> r , APLOGNO ( 02555 ) <S2SV_StartBug> ""Unknown<S2SV_blank>Transfer-Encoding:<S2SV_blank>%s;"" <S2SV_EndBug> ""<S2SV_blank>using<S2SV_blank>read-until-close"" , tenc ) ; tenc = NULL ; } else { ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , f -> r , APLOGNO ( 01585 ) ""Unknown<S2SV_blank>Transfer-Encoding:<S2SV_blank>%s"" , tenc ) ; return APR_EGENERAL ; } lenp = NULL ; } if ( lenp ) { char * endstr ; ctx -> state = BODY_LENGTH ; if ( apr_strtoff ( & ctx -> remaining , lenp , & endstr , 10 ) || endstr == lenp || * endstr || ctx -> remaining < 0 ) { ctx -> remaining = 0 ; ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , f -> r , APLOGNO ( 01587 ) ""Invalid<S2SV_blank>Content-Length"" ) ; <S2SV_StartBug> return APR_ENOSPC ; <S2SV_EndBug> } if ( ctx -> limit && ctx -> limit < ctx -> remaining ) { ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , f -> r , APLOGNO ( 01588 ) ""Requested<S2SV_blank>content-length<S2SV_blank>of<S2SV_blank>%"" APR_OFF_T_FMT ""<S2SV_blank>is<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>the<S2SV_blank>configured<S2SV_blank>limit"" ""<S2SV_blank>of<S2SV_blank>%"" APR_OFF_T_FMT , ctx -> remaining , ctx -> limit ) ; return APR_ENOSPC ; } } if ( ctx -> state == BODY_NONE && f -> r -> proxyreq != PROXYREQ_RESPONSE ) { e = apr_bucket_eos_create ( f -> c -> bucket_alloc ) ; APR_BRIGADE_INSERT_TAIL ( b , e ) ; ctx -> eos_sent = 1 ; return APR_SUCCESS ; } if ( ( ctx -> state == BODY_CHUNK || ( ctx -> state == BODY_LENGTH && ctx -> remaining > 0 ) ) && f -> r -> expecting_100 && f -> r -> proto_num >= HTTP_VERSION ( 1 , 1 ) && ! ( f -> r -> eos_sent || f -> r -> bytes_sent ) ) { if ( ! ap_is_HTTP_SUCCESS ( f -> r -> status ) ) { ctx -> state = BODY_NONE ; ctx -> eos_sent = 1 ; } else { char * tmp ; int len ; apr_bucket_brigade * bb ; bb = apr_brigade_create ( f -> r -> pool , f -> c -> bucket_alloc ) ; f -> r -> expecting_100 = 0 ; tmp = apr_pstrcat ( f -> r -> pool , AP_SERVER_PROTOCOL ""<S2SV_blank>"" , ap_get_status_line ( HTTP_CONTINUE ) , CRLF CRLF , NULL ) ; len = strlen ( tmp ) ; ap_xlate_proto_to_ascii ( tmp , len ) ; e = apr_bucket_pool_create ( tmp , len , f -> r -> pool , f -> c -> bucket_alloc ) ; APR_BRIGADE_INSERT_HEAD ( bb , e ) ; e = apr_bucket_flush_create ( f -> c -> bucket_alloc ) ; APR_BRIGADE_INSERT_TAIL ( bb , e ) ; rv = ap_pass_brigade ( f -> c -> output_filters , bb ) ; <S2SV_StartBug> if ( rv != APR_SUCCESS ) { <S2SV_EndBug> return AP_FILTER_ERROR ; } } } } if ( ctx -> eos_sent ) { e = apr_bucket_eos_create ( f -> c -> bucket_alloc ) ; APR_BRIGADE_INSERT_TAIL ( b , e ) ; return APR_SUCCESS ; } do { apr_brigade_cleanup ( b ) ; again = 0 ; switch ( ctx -> state ) { case BODY_CHUNK : case BODY_CHUNK_PART : case BODY_CHUNK_EXT : <S2SV_StartBug> case BODY_CHUNK_END : { <S2SV_EndBug> rv = ap_get_brigade ( f -> next , b , AP_MODE_GETLINE , block , 0 ) ; if ( block == APR_NONBLOCK_READ && ( ( rv == APR_SUCCESS && APR_BRIGADE_EMPTY ( b ) ) || ( APR_STATUS_IS_EAGAIN ( rv ) ) ) ) { return APR_EAGAIN ; } if ( rv == APR_EOF ) { return APR_INCOMPLETE ; } if ( rv != APR_SUCCESS ) { return rv ; } e = APR_BRIGADE_FIRST ( b ) ; while ( e != APR_BRIGADE_SENTINEL ( b ) ) { const char * buffer ; apr_size_t len ; if ( ! APR_BUCKET_IS_METADATA ( e ) ) { rv = apr_bucket_read ( e , & buffer , & len , APR_BLOCK_READ ) ; if ( rv == APR_SUCCESS ) { rv = parse_chunk_size ( ctx , buffer , len , f -> r -> server -> limit_req_fieldsize ) ; } if ( rv != APR_SUCCESS ) { ap_log_rerror ( APLOG_MARK , APLOG_INFO , rv , f -> r , APLOGNO ( 01590 ) ""Error<S2SV_blank>reading<S2SV_blank>chunk<S2SV_blank>%s<S2SV_blank>"" , ( APR_ENOSPC == rv ) ? ""(overflow)"" : """" ) ; return rv ; } } apr_bucket_delete ( e ) ; e = APR_BRIGADE_FIRST ( b ) ; } again = 1 ; if ( ctx -> state == BODY_CHUNK_TRAILER ) { <S2SV_StartBug> int merge_trailers = <S2SV_EndBug> conf -> merge_trailers == AP_MERGE_TRAILERS_ENABLE ; return read_chunked_trailers ( ctx , f , b , merge_trailers ) ; } break ; } case BODY_NONE : case BODY_LENGTH : case BODY_CHUNK_DATA : { if ( ctx -> state != BODY_NONE && ctx -> remaining < readbytes ) { readbytes = ctx -> remaining ; } if ( readbytes > 0 ) { rv = ap_get_brigade ( f -> next , b , mode , block , readbytes ) ; if ( block == APR_NONBLOCK_READ && ( ( rv == APR_SUCCESS && APR_BRIGADE_EMPTY ( b ) ) || ( APR_STATUS_IS_EAGAIN ( rv ) ) ) ) { return APR_EAGAIN ; } if ( rv == APR_EOF && ctx -> state != BODY_NONE && ctx -> remaining > 0 ) { return APR_INCOMPLETE ; } if ( rv != APR_SUCCESS ) { return rv ; } apr_brigade_length ( b , 0 , & totalread ) ; AP_DEBUG_ASSERT ( totalread >= 0 ) ; if ( ctx -> state != BODY_NONE ) { ctx -> remaining -= totalread ; if ( ctx -> remaining > 0 ) { e = APR_BRIGADE_LAST ( b ) ; if ( APR_BUCKET_IS_EOS ( e ) ) { apr_bucket_delete ( e ) ; return APR_INCOMPLETE ; } } else if ( ctx -> state == BODY_CHUNK_DATA ) { ctx -> state = BODY_CHUNK_END ; ctx -> chunk_used = 0 ; } } } if ( ctx -> state == BODY_LENGTH && ctx -> remaining == 0 ) { e = apr_bucket_eos_create ( f -> c -> bucket_alloc ) ; APR_BRIGADE_INSERT_TAIL ( b , e ) ; ctx -> eos_sent = 1 ; } if ( ctx -> limit ) { ctx -> limit_used += totalread ; if ( ctx -> limit < ctx -> limit_used ) { ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , f -> r , APLOGNO ( 01591 ) ""Read<S2SV_blank>content-length<S2SV_blank>of<S2SV_blank>%"" APR_OFF_T_FMT ""<S2SV_blank>is<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>the<S2SV_blank>configured<S2SV_blank>limit"" ""<S2SV_blank>of<S2SV_blank>%"" APR_OFF_T_FMT , ctx -> limit_used , ctx -> limit ) ; return APR_ENOSPC ; } } break ; } case BODY_CHUNK_TRAILER : { rv = ap_get_brigade ( f -> next , b , mode , block , readbytes ) ; if ( block == APR_NONBLOCK_READ && ( ( rv == APR_SUCCESS && APR_BRIGADE_EMPTY ( b ) ) || ( APR_STATUS_IS_EAGAIN ( rv ) ) ) ) { return APR_EAGAIN ; } if ( rv != APR_SUCCESS ) { return rv ; } break ; } default : { <S2SV_StartBug> break ; <S2SV_EndBug> } } } while ( again ) ; return APR_SUCCESS ; }
","<S2SV_ModStart> ( 02555 ) ""Unknown<S2SV_blank>Transfer-Encoding:<S2SV_blank>%s;<S2SV_blank>"" ""using<S2SV_blank>read-until-close"" <S2SV_ModEnd> , tenc ) <S2SV_ModStart> ) ; return APR_EINVAL <S2SV_ModEnd> ; } if <S2SV_ModStart> bb ) ; apr_brigade_cleanup ( bb ) ; <S2SV_ModStart> BODY_CHUNK_EXT : case BODY_CHUNK_LF : case BODY_CHUNK_END : case BODY_CHUNK_END_LF <S2SV_ModEnd> : { rv <S2SV_ModStart> BODY_CHUNK_TRAILER ) { return read_chunked_trailers ( ctx , f , b , conf -> merge_trailers == AP_MERGE_TRAILERS_ENABLE <S2SV_ModEnd> ) ; } <S2SV_ModStart> default : { ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , f -> r , APLOGNO ( 02901 ) ""Unexpected<S2SV_blank>body<S2SV_blank>state<S2SV_blank>(%i)"" , ( int ) ctx -> state ) ; return APR_EGENERAL <S2SV_ModEnd> ; } }
"
224,"CWE-119 static VALUE cState_object_nl_set ( VALUE self , VALUE object_nl ) { unsigned long len ; GET_STATE ( self ) ; Check_Type ( object_nl , T_STRING ) ; len = RSTRING_LEN ( object_nl ) ; if ( len == 0 ) { if ( state -> object_nl ) { ruby_xfree ( state -> object_nl ) ; state -> object_nl = NULL ; } } else { if ( state -> object_nl ) ruby_xfree ( state -> object_nl ) ; <S2SV_StartBug> state -> object_nl = strdup ( RSTRING_PTR ( object_nl ) ) ; <S2SV_EndBug> state -> object_nl_len = len ; } return Qnil ; }
","<S2SV_ModStart> -> object_nl = fstrndup <S2SV_ModEnd> ( RSTRING_PTR ( <S2SV_ModStart> ( object_nl ) , len
"
225,"CWE-78 static void <S2SV_StartBug> build_config ( char * prefix , struct server * server ) <S2SV_EndBug> { char * path = NULL ; int path_size = strlen ( prefix ) + strlen ( server -> port ) + 20 ; path = ss_malloc ( path_size ) ; snprintf ( path , path_size , ""%s/.shadowsocks_%s.conf"" , prefix , server -> port ) ; FILE * f = fopen ( path , ""w+"" ) ; if ( f == NULL ) { if ( verbose ) { LOGE ( ""unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>config<S2SV_blank>file"" ) ; } ss_free ( path ) ; return ; } fprintf ( f , ""{\\n"" ) ; fprintf ( f , ""\\""server_port\\"":%d,\\n"" , atoi ( server -> port ) ) ; <S2SV_StartBug> fprintf ( f , ""\\""password\\"":\\""%s\\"""" , server -> password ) ; <S2SV_EndBug> if ( server -> fast_open [ 0 ] ) fprintf ( f , "",\\n\\""fast_open\\"":<S2SV_blank>%s"" , server -> fast_open ) ; if ( server -> mode ) fprintf ( f , "",\\n\\""mode\\"":\\""%s\\"""" , server -> mode ) ; <S2SV_StartBug> if ( server -> method ) fprintf ( f , "",\\n\\""method\\"":\\""%s\\"""" , server -> method ) ; <S2SV_EndBug> if ( server -> plugin ) fprintf ( f , "",\\n\\""plugin\\"":\\""%s\\"""" , server -> plugin ) ; if ( server -> plugin_opts ) fprintf ( f , "",\\n\\""plugin_opts\\"":\\""%s\\"""" , server -> plugin_opts ) ; fprintf ( f , ""\\n}\\n"" ) ; fclose ( f ) ; ss_free ( path ) ; }
","<S2SV_ModStart> prefix , struct manager_ctx * manager , struct <S2SV_ModStart> server -> password ) ; if ( server -> method ) fprintf ( f , "",\\n\\""method\\"":\\""%s\\"""" , server -> method ) ; else if ( manager -> method ) fprintf ( f , "",\\n\\""method\\"":\\""%s\\"""" , manager -> method <S2SV_ModStart> ( server -> <S2SV_ModEnd> plugin ) fprintf
"
226,"CWE-125 static int dccp_print_option ( netdissect_options * ndo , const u_char * option , u_int hlen ) { uint8_t optlen , i ; ND_TCHECK ( * option ) ; if ( * option >= 32 ) { ND_TCHECK ( * ( option + 1 ) ) ; optlen = * ( option + 1 ) ; if ( optlen < 2 ) { if ( * option >= 128 ) ND_PRINT ( ( ndo , ""CCID<S2SV_blank>option<S2SV_blank>%u<S2SV_blank>optlen<S2SV_blank>too<S2SV_blank>short"" , * option ) ) ; else ND_PRINT ( ( ndo , ""%s<S2SV_blank>optlen<S2SV_blank>too<S2SV_blank>short"" , tok2str ( dccp_option_values , ""Option<S2SV_blank>%u"" , * option ) ) ) ; return 0 ; } } else optlen = 1 ; if ( hlen < optlen ) { if ( * option >= 128 ) ND_PRINT ( ( ndo , ""CCID<S2SV_blank>option<S2SV_blank>%u<S2SV_blank>optlen<S2SV_blank>goes<S2SV_blank>past<S2SV_blank>header<S2SV_blank>length"" , * option ) ) ; else ND_PRINT ( ( ndo , ""%s<S2SV_blank>optlen<S2SV_blank>goes<S2SV_blank>past<S2SV_blank>header<S2SV_blank>length"" , tok2str ( dccp_option_values , ""Option<S2SV_blank>%u"" , * option ) ) ) ; return 0 ; } ND_TCHECK2 ( * option , optlen ) ; if ( * option >= 128 ) { ND_PRINT ( ( ndo , ""CCID<S2SV_blank>option<S2SV_blank>%d"" , * option ) ) ; switch ( optlen ) { case 4 : ND_PRINT ( ( ndo , ""<S2SV_blank>%u"" , EXTRACT_16BITS ( option + 2 ) ) ) ; break ; case 6 : ND_PRINT ( ( ndo , ""<S2SV_blank>%u"" , EXTRACT_32BITS ( option + 2 ) ) ) ; break ; default : break ; } } else { ND_PRINT ( ( ndo , ""%s"" , tok2str ( dccp_option_values , ""Option<S2SV_blank>%u"" , * option ) ) ) ; switch ( * option ) { case 32 : case 33 : case 34 : case 35 : if ( optlen < 3 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>optlen<S2SV_blank>too<S2SV_blank>short"" ) ) ; return optlen ; } if ( * ( option + 2 ) < 10 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , dccp_feature_nums [ * ( option + 2 ) ] ) ) ; for ( i = 0 ; i < optlen - 3 ; i ++ ) ND_PRINT ( ( ndo , ""<S2SV_blank>%d"" , * ( option + 3 + i ) ) ) ; } break ; case 36 : if ( optlen > 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>0x"" ) ) ; for ( i = 0 ; i < optlen - 2 ; i ++ ) ND_PRINT ( ( ndo , ""%02x"" , * ( option + 2 + i ) ) ) ; } break ; case 37 : for ( i = 0 ; i < optlen - 2 ; i ++ ) ND_PRINT ( ( ndo , ""<S2SV_blank>%d"" , * ( option + 2 + i ) ) ) ; break ; case 38 : if ( optlen > 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>0x"" ) ) ; for ( i = 0 ; i < optlen - 2 ; i ++ ) ND_PRINT ( ( ndo , ""%02x"" , * ( option + 2 + i ) ) ) ; } break ; case 39 : if ( optlen > 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>0x"" ) ) ; for ( i = 0 ; i < optlen - 2 ; i ++ ) ND_PRINT ( ( ndo , ""%02x"" , * ( option + 2 + i ) ) ) ; } break ; case 40 : if ( optlen > 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>0x"" ) ) ; for ( i = 0 ; i < optlen - 2 ; i ++ ) ND_PRINT ( ( ndo , ""%02x"" , * ( option + 2 + i ) ) ) ; } break ; case 41 : <S2SV_StartBug> if ( optlen == 4 ) <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>%u"" , EXTRACT_32BITS ( option + 2 ) ) ) ; else <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>optlen<S2SV_blank>!=<S2SV_blank>4"" ) ) ; <S2SV_EndBug> break ; case 42 : <S2SV_StartBug> if ( optlen == 4 ) <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>%u"" , EXTRACT_32BITS ( option + 2 ) ) ) ; <S2SV_EndBug> else <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>optlen<S2SV_blank>!=<S2SV_blank>4"" ) ) ; <S2SV_EndBug> break ; case 43 : if ( optlen == 6 ) ND_PRINT ( ( ndo , ""<S2SV_blank>%u"" , EXTRACT_32BITS ( option + 2 ) ) ) ; else if ( optlen == 4 ) ND_PRINT ( ( ndo , ""<S2SV_blank>%u"" , EXTRACT_16BITS ( option + 2 ) ) ) ; else ND_PRINT ( ( ndo , ""<S2SV_blank>optlen<S2SV_blank>!=<S2SV_blank>4<S2SV_blank>or<S2SV_blank>6"" ) ) ; break ; case 44 : if ( optlen > 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; for ( i = 0 ; i < optlen - 2 ; i ++ ) ND_PRINT ( ( ndo , ""%02x"" , * ( option + 2 + i ) ) ) ; } break ; } } return optlen ; trunc : ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return 0 ; }
","<S2SV_ModStart> ( optlen == 6 <S2SV_ModEnd> ) ND_PRINT ( <S2SV_ModStart> ( ndo , ""<S2SV_blank>[optlen<S2SV_blank>!=<S2SV_blank>6]"" <S2SV_ModEnd> ) ) ; <S2SV_ModStart> case 42 : switch ( optlen ) { case 6 : ND_PRINT ( ( ndo , ""<S2SV_blank>%u"" , EXTRACT_32BITS ( option + 2 ) ) ) ; break ; case 8 : ND_PRINT ( ( ndo , ""<S2SV_blank>%u"" , EXTRACT_32BITS ( option + 2 ) ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>(elapsed<S2SV_blank>time<S2SV_blank>%u)"" , EXTRACT_16BITS ( option + 6 ) ) ) ; break ; case 10 : ND_PRINT ( ( ndo , ""<S2SV_blank>%u"" , EXTRACT_32BITS ( option + 2 ) ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>(elapsed<S2SV_blank>time<S2SV_blank>%u)"" , EXTRACT_32BITS ( option + 6 ) ) ) ; break ; default : ND_PRINT ( ( ndo , ""<S2SV_blank>[optlen<S2SV_blank>!=<S2SV_blank>6<S2SV_blank>or<S2SV_blank>8<S2SV_blank>or<S2SV_blank>10]"" ) ) ; break ; } break ; case 43 : if ( optlen == 6 ) ND_PRINT ( ( ndo , ""<S2SV_blank>%u"" , EXTRACT_32BITS ( option + 2 ) ) ) ; else <S2SV_ModStart> , ""<S2SV_blank>%u"" , EXTRACT_16BITS <S2SV_ModEnd> ( option + <S2SV_ModStart> ( ndo , ""<S2SV_blank>[optlen<S2SV_blank>!=<S2SV_blank>4<S2SV_blank>or<S2SV_blank>6]"" <S2SV_ModEnd> ) ) ;
"
227,"CWE-190 static int growOpArray ( Vdbe * v , int nOp ) { VdbeOp * pNew ; Parse * p = v -> pParse ; # ifdef SQLITE_TEST_REALLOC_STRESS <S2SV_StartBug> int nNew = ( v -> nOpAlloc >= 512 ? v -> nOpAlloc * 2 : v -> nOpAlloc + nOp ) ; <S2SV_EndBug> # else <S2SV_StartBug> int nNew = ( v -> nOpAlloc ? v -> nOpAlloc * 2 : ( int ) ( 1024 / sizeof ( Op ) ) ) ; <S2SV_EndBug> UNUSED_PARAMETER ( nOp ) ; # endif if ( nNew > p -> db -> aLimit [ SQLITE_LIMIT_VDBE_OP ] ) { sqlite3OomFault ( p -> db ) ; return SQLITE_NOMEM ; } assert ( nOp <= ( 1024 / sizeof ( Op ) ) ) ; assert ( nNew >= ( v -> nOpAlloc + nOp ) ) ; pNew = sqlite3DbRealloc ( p -> db , v -> aOp , nNew * sizeof ( Op ) ) ; if ( pNew ) { p -> szOpAlloc = sqlite3DbMallocSize ( p -> db , pNew ) ; v -> nOpAlloc = p -> szOpAlloc / sizeof ( Op ) ; v -> aOp = pNew ; } return ( pNew ? SQLITE_OK : SQLITE_NOMEM_BKPT ) ; }
","<S2SV_ModStart> # ifdef SQLITE_TEST_REALLOC_STRESS sqlite3_int64 <S2SV_ModEnd> nNew = ( <S2SV_ModStart> >= 512 ? 2 * ( sqlite3_int64 ) v -> nOpAlloc : ( sqlite3_int64 ) <S2SV_ModEnd> v -> nOpAlloc <S2SV_ModStart> ; # else sqlite3_int64 <S2SV_ModEnd> nNew = ( <S2SV_ModStart> -> nOpAlloc ? 2 * ( sqlite3_int64 ) v -> nOpAlloc : ( sqlite3_int64 ) <S2SV_ModEnd> 1024 / sizeof <S2SV_ModStart> sizeof ( Op <S2SV_ModEnd> ) ) ;
"
228,"CWE-284 int socket_accept ( int fd , uint16_t port ) { # ifdef WIN32 int addr_len ; # else socklen_t addr_len ; # endif int result ; struct sockaddr_in addr ; memset ( & addr , 0 , sizeof ( addr ) ) ; addr . sin_family = AF_INET ; <S2SV_StartBug> addr . sin_addr . s_addr = htonl ( INADDR_ANY ) ; <S2SV_EndBug> addr . sin_port = htons ( port ) ; addr_len = sizeof ( addr ) ; result = accept ( fd , ( struct sockaddr * ) & addr , & addr_len ) ; return result ; }
","<S2SV_ModStart> = htonl ( INADDR_LOOPBACK <S2SV_ModEnd> ) ; addr
"
229,"CWE-19 int ext2_xattr_set ( struct inode * inode , int name_index , const char * name , const void * value , size_t value_len , int flags ) { struct super_block * sb = inode -> i_sb ; struct buffer_head * bh = NULL ; struct ext2_xattr_header * header = NULL ; struct ext2_xattr_entry * here , * last ; size_t name_len , free , min_offs = sb -> s_blocksize ; int not_found = 1 , error ; char * end ; ea_idebug ( inode , ""name=%d.%s,<S2SV_blank>value=%p,<S2SV_blank>value_len=%ld"" , name_index , name , value , ( long ) value_len ) ; if ( value == NULL ) value_len = 0 ; if ( name == NULL ) return - EINVAL ; name_len = strlen ( name ) ; if ( name_len > 255 || value_len > sb -> s_blocksize ) return - ERANGE ; down_write ( & EXT2_I ( inode ) -> xattr_sem ) ; if ( EXT2_I ( inode ) -> i_file_acl ) { bh = sb_bread ( sb , EXT2_I ( inode ) -> i_file_acl ) ; error = - EIO ; if ( ! bh ) goto cleanup ; ea_bdebug ( bh , ""b_count=%d,<S2SV_blank>refcount=%d"" , atomic_read ( & ( bh -> b_count ) ) , le32_to_cpu ( HDR ( bh ) -> h_refcount ) ) ; header = HDR ( bh ) ; end = bh -> b_data + bh -> b_size ; if ( header -> h_magic != cpu_to_le32 ( EXT2_XATTR_MAGIC ) || header -> h_blocks != cpu_to_le32 ( 1 ) ) { bad_block : ext2_error ( sb , ""ext2_xattr_set"" , ""inode<S2SV_blank>%ld:<S2SV_blank>bad<S2SV_blank>block<S2SV_blank>%d"" , inode -> i_ino , EXT2_I ( inode ) -> i_file_acl ) ; error = - EIO ; goto cleanup ; } here = FIRST_ENTRY ( bh ) ; while ( ! IS_LAST_ENTRY ( here ) ) { struct ext2_xattr_entry * next = EXT2_XATTR_NEXT ( here ) ; if ( ( char * ) next >= end ) goto bad_block ; if ( ! here -> e_value_block && here -> e_value_size ) { size_t offs = le16_to_cpu ( here -> e_value_offs ) ; if ( offs < min_offs ) min_offs = offs ; } not_found = name_index - here -> e_name_index ; if ( ! not_found ) not_found = name_len - here -> e_name_len ; if ( ! not_found ) not_found = memcmp ( name , here -> e_name , name_len ) ; if ( not_found <= 0 ) break ; here = next ; } last = here ; while ( ! IS_LAST_ENTRY ( last ) ) { struct ext2_xattr_entry * next = EXT2_XATTR_NEXT ( last ) ; if ( ( char * ) next >= end ) goto bad_block ; if ( ! last -> e_value_block && last -> e_value_size ) { size_t offs = le16_to_cpu ( last -> e_value_offs ) ; if ( offs < min_offs ) min_offs = offs ; } last = next ; } free = min_offs - ( ( char * ) last - ( char * ) header ) - sizeof ( __u32 ) ; } else { free = sb -> s_blocksize - sizeof ( struct ext2_xattr_header ) - sizeof ( __u32 ) ; here = last = NULL ; } if ( not_found ) { error = - ENODATA ; if ( flags & XATTR_REPLACE ) goto cleanup ; error = 0 ; if ( value == NULL ) goto cleanup ; } else { error = - EEXIST ; if ( flags & XATTR_CREATE ) goto cleanup ; if ( ! here -> e_value_block && here -> e_value_size ) { size_t size = le32_to_cpu ( here -> e_value_size ) ; if ( le16_to_cpu ( here -> e_value_offs ) + size > sb -> s_blocksize || size > sb -> s_blocksize ) goto bad_block ; free += EXT2_XATTR_SIZE ( size ) ; } free += EXT2_XATTR_LEN ( name_len ) ; } error = - ENOSPC ; if ( free < EXT2_XATTR_LEN ( name_len ) + EXT2_XATTR_SIZE ( value_len ) ) goto cleanup ; if ( header ) { <S2SV_StartBug> struct mb_cache_entry * ce ; <S2SV_EndBug> ce = mb_cache_entry_get ( ext2_xattr_cache , bh -> b_bdev , bh -> b_blocknr ) ; lock_buffer ( bh ) ; if ( header -> h_refcount == cpu_to_le32 ( 1 ) ) { <S2SV_StartBug> ea_bdebug ( bh , ""modifying<S2SV_blank>in-place"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ce ) <S2SV_EndBug> mb_cache_entry_free ( ce ) ; } else { <S2SV_StartBug> int offset ; <S2SV_EndBug> if ( ce ) mb_cache_entry_release ( ce ) ; unlock_buffer ( bh ) ; ea_bdebug ( bh , ""cloning"" ) ; header = kmalloc ( bh -> b_size , GFP_KERNEL ) ; error = - ENOMEM ; if ( header == NULL ) goto cleanup ; memcpy ( header , HDR ( bh ) , bh -> b_size ) ; header -> h_refcount = cpu_to_le32 ( 1 ) ; offset = ( char * ) here - bh -> b_data ; here = ENTRY ( ( char * ) header + offset ) ; offset = ( char * ) last - bh -> b_data ; last = ENTRY ( ( char * ) header + offset ) ; } } else { header = kzalloc ( sb -> s_blocksize , GFP_KERNEL ) ; error = - ENOMEM ; if ( header == NULL ) goto cleanup ; end = ( char * ) header + sb -> s_blocksize ; header -> h_magic = cpu_to_le32 ( EXT2_XATTR_MAGIC ) ; header -> h_blocks = header -> h_refcount = cpu_to_le32 ( 1 ) ; last = here = ENTRY ( header + 1 ) ; } if ( not_found ) { size_t size = EXT2_XATTR_LEN ( name_len ) ; size_t rest = ( char * ) last - ( char * ) here ; memmove ( ( char * ) here + size , here , rest ) ; memset ( here , 0 , size ) ; here -> e_name_index = name_index ; here -> e_name_len = name_len ; memcpy ( here -> e_name , name , name_len ) ; } else { if ( ! here -> e_value_block && here -> e_value_size ) { char * first_val = ( char * ) header + min_offs ; size_t offs = le16_to_cpu ( here -> e_value_offs ) ; char * val = ( char * ) header + offs ; size_t size = EXT2_XATTR_SIZE ( le32_to_cpu ( here -> e_value_size ) ) ; if ( size == EXT2_XATTR_SIZE ( value_len ) ) { here -> e_value_size = cpu_to_le32 ( value_len ) ; memset ( val + size - EXT2_XATTR_PAD , 0 , EXT2_XATTR_PAD ) ; memcpy ( val , value , value_len ) ; goto skip_replace ; } memmove ( first_val + size , first_val , val - first_val ) ; memset ( first_val , 0 , size ) ; here -> e_value_offs = 0 ; min_offs += size ; last = ENTRY ( header + 1 ) ; while ( ! IS_LAST_ENTRY ( last ) ) { size_t o = le16_to_cpu ( last -> e_value_offs ) ; if ( ! last -> e_value_block && o < offs ) last -> e_value_offs = cpu_to_le16 ( o + size ) ; last = EXT2_XATTR_NEXT ( last ) ; } } if ( value == NULL ) { size_t size = EXT2_XATTR_LEN ( name_len ) ; last = ENTRY ( ( char * ) last - size ) ; memmove ( here , ( char * ) here + size , ( char * ) last - ( char * ) here ) ; memset ( last , 0 , size ) ; } } if ( value != NULL ) { here -> e_value_size = cpu_to_le32 ( value_len ) ; if ( value_len ) { size_t size = EXT2_XATTR_SIZE ( value_len ) ; char * val = ( char * ) header + min_offs - size ; here -> e_value_offs = cpu_to_le16 ( ( char * ) val - ( char * ) header ) ; memset ( val + size - EXT2_XATTR_PAD , 0 , EXT2_XATTR_PAD ) ; memcpy ( val , value , value_len ) ; } } skip_replace : if ( IS_LAST_ENTRY ( ENTRY ( header + 1 ) ) ) { if ( bh && header == HDR ( bh ) ) unlock_buffer ( bh ) ; error = ext2_xattr_set2 ( inode , bh , NULL ) ; } else { ext2_xattr_rehash ( header , here ) ; if ( bh && header == HDR ( bh ) ) unlock_buffer ( bh ) ; error = ext2_xattr_set2 ( inode , bh , header ) ; } cleanup : brelse ( bh ) ; if ( ! ( bh && header == HDR ( bh ) ) ) kfree ( header ) ; up_write ( & EXT2_I ( inode ) -> xattr_sem ) ; return error ; }
","<S2SV_ModStart> header ) { <S2SV_ModEnd> lock_buffer ( bh <S2SV_ModStart> ) ) { __u32 hash = le32_to_cpu ( header -> h_hash ) ; <S2SV_ModStart> ""modifying<S2SV_blank>in-place"" ) ; mb2_cache_entry_delete_block ( EXT2_SB ( sb ) -> s_mb_cache , hash , bh -> b_blocknr <S2SV_ModEnd> ) ; } <S2SV_ModStart> { int offset <S2SV_ModEnd> ; unlock_buffer (
"
230,"CWE-119 static int chmd_read_headers ( struct mspack_system * sys , struct mspack_file * fh , struct mschmd_header * chm , int entire ) { unsigned int section , name_len , x , errors , num_chunks ; unsigned char buf [ 0x54 ] , * chunk = NULL , * name , * p , * end ; struct mschmd_file * fi , * link = NULL ; off_t offset , length ; int num_entries ; chm -> files = NULL ; chm -> sysfiles = NULL ; chm -> chunk_cache = NULL ; chm -> sec0 . base . chm = chm ; chm -> sec0 . base . id = 0 ; chm -> sec1 . base . chm = chm ; chm -> sec1 . base . id = 1 ; chm -> sec1 . content = NULL ; chm -> sec1 . control = NULL ; chm -> sec1 . spaninfo = NULL ; chm -> sec1 . rtable = NULL ; if ( sys -> read ( fh , & buf [ 0 ] , chmhead_SIZEOF ) != chmhead_SIZEOF ) { return MSPACK_ERR_READ ; } if ( EndGetI32 ( & buf [ chmhead_Signature ] ) != 0x46535449 ) { return MSPACK_ERR_SIGNATURE ; } if ( memcmp ( & buf [ chmhead_GUID1 ] , & guids [ 0 ] , 32L ) != 0 ) { D ( ( ""incorrect<S2SV_blank>GUIDs"" ) ) return MSPACK_ERR_SIGNATURE ; } chm -> version = EndGetI32 ( & buf [ chmhead_Version ] ) ; chm -> timestamp = EndGetM32 ( & buf [ chmhead_Timestamp ] ) ; chm -> language = EndGetI32 ( & buf [ chmhead_LanguageID ] ) ; if ( chm -> version > 3 ) { sys -> message ( fh , ""WARNING;<S2SV_blank>CHM<S2SV_blank>version<S2SV_blank>><S2SV_blank>3"" ) ; } if ( sys -> read ( fh , & buf [ 0 ] , chmhst3_SIZEOF ) != chmhst3_SIZEOF ) { return MSPACK_ERR_READ ; } if ( read_off64 ( & offset , & buf [ chmhst_OffsetHS0 ] , sys , fh ) || read_off64 ( & chm -> dir_offset , & buf [ chmhst_OffsetHS1 ] , sys , fh ) || read_off64 ( & chm -> sec0 . offset , & buf [ chmhst3_OffsetCS0 ] , sys , fh ) ) { return MSPACK_ERR_DATAFORMAT ; } if ( sys -> seek ( fh , offset , MSPACK_SYS_SEEK_START ) ) { return MSPACK_ERR_SEEK ; } if ( sys -> read ( fh , & buf [ 0 ] , chmhs0_SIZEOF ) != chmhs0_SIZEOF ) { return MSPACK_ERR_READ ; } if ( read_off64 ( & chm -> length , & buf [ chmhs0_FileLen ] , sys , fh ) ) { return MSPACK_ERR_DATAFORMAT ; } if ( sys -> seek ( fh , chm -> dir_offset , MSPACK_SYS_SEEK_START ) ) { return MSPACK_ERR_SEEK ; } if ( sys -> read ( fh , & buf [ 0 ] , chmhs1_SIZEOF ) != chmhs1_SIZEOF ) { return MSPACK_ERR_READ ; } chm -> dir_offset = sys -> tell ( fh ) ; chm -> chunk_size = EndGetI32 ( & buf [ chmhs1_ChunkSize ] ) ; chm -> density = EndGetI32 ( & buf [ chmhs1_Density ] ) ; chm -> depth = EndGetI32 ( & buf [ chmhs1_Depth ] ) ; chm -> index_root = EndGetI32 ( & buf [ chmhs1_IndexRoot ] ) ; chm -> num_chunks = EndGetI32 ( & buf [ chmhs1_NumChunks ] ) ; chm -> first_pmgl = EndGetI32 ( & buf [ chmhs1_FirstPMGL ] ) ; chm -> last_pmgl = EndGetI32 ( & buf [ chmhs1_LastPMGL ] ) ; if ( chm -> version < 3 ) { chm -> sec0 . offset = chm -> dir_offset + ( chm -> chunk_size * chm -> num_chunks ) ; } if ( chm -> sec0 . offset > chm -> length ) { D ( ( ""content<S2SV_blank>section<S2SV_blank>begins<S2SV_blank>after<S2SV_blank>file<S2SV_blank>has<S2SV_blank>ended"" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( chm -> chunk_size < ( pmgl_Entries + 2 ) ) { D ( ( ""chunk<S2SV_blank>size<S2SV_blank>not<S2SV_blank>large<S2SV_blank>enough"" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( chm -> num_chunks == 0 ) { D ( ( ""no<S2SV_blank>chunks"" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( chm -> num_chunks > 100000 ) { D ( ( ""more<S2SV_blank>than<S2SV_blank>100,000<S2SV_blank>chunks"" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( ( off_t ) chm -> chunk_size * ( off_t ) chm -> num_chunks > chm -> length ) { D ( ( ""chunks<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>entire<S2SV_blank>file"" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( ( chm -> chunk_size & ( chm -> chunk_size - 1 ) ) != 0 ) { sys -> message ( fh , ""WARNING;<S2SV_blank>chunk<S2SV_blank>size<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>power<S2SV_blank>of<S2SV_blank>two"" ) ; } if ( chm -> first_pmgl != 0 ) { sys -> message ( fh , ""WARNING;<S2SV_blank>first<S2SV_blank>PMGL<S2SV_blank>chunk<S2SV_blank>is<S2SV_blank>not<S2SV_blank>zero"" ) ; } if ( chm -> first_pmgl > chm -> last_pmgl ) { D ( ( ""first<S2SV_blank>pmgl<S2SV_blank>chunk<S2SV_blank>is<S2SV_blank>after<S2SV_blank>last<S2SV_blank>pmgl<S2SV_blank>chunk"" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( chm -> index_root != 0xFFFFFFFF && chm -> index_root >= chm -> num_chunks ) { D ( ( ""index_root<S2SV_blank>outside<S2SV_blank>valid<S2SV_blank>range"" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( ! entire ) { return MSPACK_ERR_OK ; } if ( ( x = chm -> first_pmgl ) != 0 ) { if ( sys -> seek ( fh , ( off_t ) ( x * chm -> chunk_size ) , MSPACK_SYS_SEEK_CUR ) ) { return MSPACK_ERR_SEEK ; } } num_chunks = chm -> last_pmgl - x + 1 ; if ( ! ( chunk = ( unsigned char * ) sys -> alloc ( sys , ( size_t ) chm -> chunk_size ) ) ) { return MSPACK_ERR_NOMEMORY ; } errors = 0 ; while ( num_chunks -- ) { if ( sys -> read ( fh , chunk , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { sys -> free ( chunk ) ; return MSPACK_ERR_READ ; } if ( EndGetI32 ( & chunk [ pmgl_Signature ] ) != 0x4C474D50 ) continue ; if ( EndGetI32 ( & chunk [ pmgl_QuickRefSize ] ) < 2 ) { sys -> message ( fh , ""WARNING;<S2SV_blank>PMGL<S2SV_blank>quickref<S2SV_blank>area<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small"" ) ; } if ( EndGetI32 ( & chunk [ pmgl_QuickRefSize ] ) > ( ( int ) chm -> chunk_size - pmgl_Entries ) ) { sys -> message ( fh , ""WARNING;<S2SV_blank>PMGL<S2SV_blank>quickref<S2SV_blank>area<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large"" ) ; } p = & chunk [ pmgl_Entries ] ; end = & chunk [ chm -> chunk_size - 2 ] ; num_entries = EndGetI16 ( end ) ; while ( num_entries -- ) { READ_ENCINT ( name_len ) ; if ( name_len > ( unsigned int ) ( end - p ) ) goto chunk_end ; name = p ; p += name_len ; READ_ENCINT ( section ) ; READ_ENCINT ( offset ) ; READ_ENCINT ( length ) ; if ( name_len < 2 || ! name [ 0 ] || ! name [ 1 ] ) continue ; if ( ( offset == 0 ) && ( length == 0 ) ) { if ( ( name_len > 0 ) && ( name [ name_len - 1 ] == '/' ) ) continue ; } if ( section > 1 ) { sys -> message ( fh , ""invalid<S2SV_blank>section<S2SV_blank>number<S2SV_blank>\'%u\'."" , section ) ; continue ; } if ( ! ( fi = ( struct mschmd_file * ) sys -> alloc ( sys , sizeof ( struct mschmd_file ) + name_len + 1 ) ) ) { sys -> free ( chunk ) ; return MSPACK_ERR_NOMEMORY ; } fi -> next = NULL ; fi -> filename = ( char * ) & fi [ 1 ] ; fi -> section = ( ( section == 0 ) ? ( struct mschmd_section * ) ( & chm -> sec0 ) : ( struct mschmd_section * ) ( & chm -> sec1 ) ) ; fi -> offset = offset ; fi -> length = length ; sys -> copy ( name , fi -> filename , ( size_t ) name_len ) ; fi -> filename [ name_len ] = '\\0' ; if ( name [ 0 ] == ':' && name [ 1 ] == ':' ) { <S2SV_StartBug> if ( memcmp ( & name [ 2 ] , & content_name [ 2 ] , 31L ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( memcmp ( & name [ 33 ] , & content_name [ 33 ] , 8L ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> chm -> sec1 . content = fi ; <S2SV_EndBug> } <S2SV_StartBug> else if ( memcmp ( & name [ 33 ] , & control_name [ 33 ] , 11L ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> chm -> sec1 . control = fi ; <S2SV_EndBug> } <S2SV_StartBug> else if ( memcmp ( & name [ 33 ] , & spaninfo_name [ 33 ] , 8L ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> chm -> sec1 . spaninfo = fi ; <S2SV_EndBug> } else if ( memcmp ( & name [ 33 ] , & rtable_name [ 33 ] , 72L ) == 0 ) { chm -> sec1 . rtable = fi ; <S2SV_StartBug> } <S2SV_EndBug> } fi -> next = chm -> sysfiles ; chm -> sysfiles = fi ; } else { if ( link ) link -> next = fi ; else chm -> files = fi ; link = fi ; } } chunk_end : if ( num_entries >= 0 ) { D ( ( ""chunk<S2SV_blank>ended<S2SV_blank>before<S2SV_blank>all<S2SV_blank>entries<S2SV_blank>could<S2SV_blank>be<S2SV_blank>read"" ) ) errors ++ ; } } sys -> free ( chunk ) ; return ( errors > 0 ) ? MSPACK_ERR_DATAFORMAT : MSPACK_ERR_OK ; }
","<S2SV_ModStart> { if ( name_len == 40 && memcmp ( name , content_name , 40 <S2SV_ModEnd> ) == 0 <S2SV_ModStart> 0 ) { chm -> sec1 . content = fi ; } else if ( name_len == 44 && memcmp ( name , control_name , 44 <S2SV_ModEnd> ) == 0 <S2SV_ModStart> -> sec1 . control <S2SV_ModEnd> = fi ; <S2SV_ModStart> else if ( name_len == 41 && memcmp ( name , spaninfo_name , 41 <S2SV_ModEnd> ) == 0 <S2SV_ModStart> -> sec1 . spaninfo <S2SV_ModEnd> = fi ; <S2SV_ModStart> else if ( name_len == 105 && memcmp ( name , rtable_name , 105 <S2SV_ModEnd> ) == 0 <S2SV_ModStart> -> sec1 . <S2SV_ModEnd> rtable = fi <S2SV_ModStart> = fi ; <S2SV_ModEnd> } fi ->
"
231,"CWE-404 int install_thread_keyring_to_cred ( struct cred * new ) { <S2SV_StartBug> struct key * keyring ; <S2SV_EndBug> keyring = keyring_alloc ( ""_tid"" , new -> uid , new -> gid , new , KEY_POS_ALL | KEY_USR_VIEW , KEY_ALLOC_QUOTA_OVERRUN , NULL , NULL ) ; if ( IS_ERR ( keyring ) ) return PTR_ERR ( keyring ) ; new -> thread_keyring = keyring ; return 0 ; }
","<S2SV_ModStart> key * keyring ; if ( new -> thread_keyring ) return 0
"
232,"CWE-189 Datum path_in ( PG_FUNCTION_ARGS ) { char * str = PG_GETARG_CSTRING ( 0 ) ; PATH * path ; int isopen ; char * s ; int npts ; <S2SV_StartBug> int size ; <S2SV_EndBug> int depth = 0 ; if ( ( npts = pair_count ( str , ',' ) ) <= 0 ) ereport ( ERROR , ( errcode ( ERRCODE_INVALID_TEXT_REPRESENTATION ) , errmsg ( ""invalid<S2SV_blank>input<S2SV_blank>syntax<S2SV_blank>for<S2SV_blank>type<S2SV_blank>path:<S2SV_blank>\\""%s\\"""" , str ) ) ) ; s = str ; while ( isspace ( ( unsigned char ) * s ) ) s ++ ; if ( ( * s == LDELIM ) && ( strrchr ( s , LDELIM ) == s ) ) { s ++ ; depth ++ ; } <S2SV_StartBug> size = offsetof ( PATH , p [ 0 ] ) + sizeof ( path -> p [ 0 ] ) * npts ; <S2SV_EndBug> path = ( PATH * ) palloc ( size ) ; SET_VARSIZE ( path , size ) ; path -> npts = npts ; if ( ( ! path_decode ( TRUE , npts , s , & isopen , & s , & ( path -> p [ 0 ] ) ) ) && ( ! ( ( depth == 0 ) && ( * s == '\\0' ) ) ) && ! ( ( depth >= 1 ) && ( * s == RDELIM ) ) ) ereport ( ERROR , ( errcode ( ERRCODE_INVALID_TEXT_REPRESENTATION ) , errmsg ( ""invalid<S2SV_blank>input<S2SV_blank>syntax<S2SV_blank>for<S2SV_blank>type<S2SV_blank>path:<S2SV_blank>\\""%s\\"""" , str ) ) ) ; path -> closed = ( ! isopen ) ; path -> dummy = 0 ; PG_RETURN_PATH_P ( path ) ; }
","<S2SV_ModStart> ; int size ; int base_size <S2SV_ModStart> ++ ; } base_size = sizeof ( path -> <S2SV_ModEnd> p [ 0 <S2SV_ModStart> 0 ] ) * npts ; size = offsetof ( PATH , <S2SV_ModEnd> p [ 0 <S2SV_ModStart> 0 ] ) + base_size ; if ( base_size / npts != sizeof ( path -> p [ 0 ] ) || size <= base_size ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""too<S2SV_blank>many<S2SV_blank>points<S2SV_blank>requested"" ) ) ) <S2SV_ModEnd> ; path =
"
233,"CWE-189 Pairs * hstoreArrayToPairs ( ArrayType * a , int * npairs ) { Datum * key_datums ; bool * key_nulls ; int key_count ; Pairs * key_pairs ; int bufsiz ; int i , j ; deconstruct_array ( a , TEXTOID , - 1 , false , 'i' , & key_datums , & key_nulls , & key_count ) ; if ( key_count == 0 ) { * npairs = 0 ; return NULL ; } <S2SV_StartBug> key_pairs = palloc ( sizeof ( Pairs ) * key_count ) ; <S2SV_EndBug> for ( i = 0 , j = 0 ; i < key_count ; i ++ ) { if ( ! key_nulls [ i ] ) { key_pairs [ j ] . key = VARDATA ( key_datums [ i ] ) ; key_pairs [ j ] . keylen = VARSIZE ( key_datums [ i ] ) - VARHDRSZ ; key_pairs [ j ] . val = NULL ; key_pairs [ j ] . vallen = 0 ; key_pairs [ j ] . needfree = 0 ; key_pairs [ j ] . isnull = 1 ; j ++ ; } } * npairs = hstoreUniquePairs ( key_pairs , j , & bufsiz ) ; return key_pairs ; }
","<S2SV_ModStart> NULL ; } if ( key_count > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , key_count , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) ) ;
"
234,"CWE-119 static xmlChar * xmlParseAttValueComplex ( xmlParserCtxtPtr ctxt , int * attlen , int normalize ) { xmlChar limit = 0 ; xmlChar * buf = NULL ; xmlChar * rep = NULL ; int len = 0 ; int buf_size = 0 ; int c , l , in_space = 0 ; xmlChar * current = NULL ; xmlEntityPtr ent ; if ( NXT ( 0 ) == \'""\' ) { ctxt -> instate = XML_PARSER_ATTRIBUTE_VALUE ; limit = \'""\' ; NEXT ; } else if ( NXT ( 0 ) == '\\'' ) { limit = '\\'' ; ctxt -> instate = XML_PARSER_ATTRIBUTE_VALUE ; NEXT ; } else { xmlFatalErr ( ctxt , XML_ERR_ATTRIBUTE_NOT_STARTED , NULL ) ; return ( NULL ) ; } buf_size = XML_PARSER_BUFFER_SIZE ; buf = ( xmlChar * ) xmlMallocAtomic ( buf_size * sizeof ( xmlChar ) ) ; if ( buf == NULL ) goto mem_error ; c = CUR_CHAR ( l ) ; while ( ( NXT ( 0 ) != limit ) && ( IS_CHAR ( c ) ) && ( c != '<' ) ) { if ( c == 0 ) break ; if ( c == '&' ) { in_space = 0 ; if ( NXT ( 1 ) == '#' ) { int val = xmlParseCharRef ( ctxt ) ; if ( val == '&' ) { if ( ctxt -> replaceEntities ) { if ( len > buf_size - 10 ) { growBuffer ( buf , 10 ) ; } buf [ len ++ ] = '&' ; } else { if ( len > buf_size - 10 ) { growBuffer ( buf , 10 ) ; } buf [ len ++ ] = '&' ; buf [ len ++ ] = '#' ; buf [ len ++ ] = '3' ; buf [ len ++ ] = '8' ; buf [ len ++ ] = ';' ; } } else if ( val != 0 ) { if ( len > buf_size - 10 ) { growBuffer ( buf , 10 ) ; } len += xmlCopyChar ( 0 , & buf [ len ] , val ) ; } } else { ent = xmlParseEntityRef ( ctxt ) ; ctxt -> nbentities ++ ; if ( ent != NULL ) ctxt -> nbentities += ent -> owner ; if ( ( ent != NULL ) && ( ent -> etype == XML_INTERNAL_PREDEFINED_ENTITY ) ) { if ( len > buf_size - 10 ) { growBuffer ( buf , 10 ) ; } if ( ( ctxt -> replaceEntities == 0 ) && ( ent -> content [ 0 ] == '&' ) ) { buf [ len ++ ] = '&' ; buf [ len ++ ] = '#' ; buf [ len ++ ] = '3' ; buf [ len ++ ] = '8' ; buf [ len ++ ] = ';' ; } else { buf [ len ++ ] = ent -> content [ 0 ] ; } } else if ( ( ent != NULL ) && ( ctxt -> replaceEntities != 0 ) ) { if ( ent -> etype != XML_INTERNAL_PREDEFINED_ENTITY ) { rep = xmlStringDecodeEntities ( ctxt , ent -> content , XML_SUBSTITUTE_REF , 0 , 0 , 0 ) ; if ( rep != NULL ) { current = rep ; while ( * current != 0 ) { if ( ( * current == 0xD ) || ( * current == 0xA ) || ( * current == 0x9 ) ) { buf [ len ++ ] = 0x20 ; current ++ ; } else buf [ len ++ ] = * current ++ ; if ( len > buf_size - 10 ) { growBuffer ( buf , 10 ) ; } } xmlFree ( rep ) ; rep = NULL ; } } else { if ( len > buf_size - 10 ) { growBuffer ( buf , 10 ) ; } if ( ent -> content != NULL ) buf [ len ++ ] = ent -> content [ 0 ] ; } } else if ( ent != NULL ) { int i = xmlStrlen ( ent -> name ) ; const xmlChar * cur = ent -> name ; if ( ( ent -> etype != XML_INTERNAL_PREDEFINED_ENTITY ) && ( ent -> content != NULL ) ) { rep = xmlStringDecodeEntities ( ctxt , ent -> content , XML_SUBSTITUTE_REF , 0 , 0 , 0 ) ; if ( rep != NULL ) { xmlFree ( rep ) ; rep = NULL ; } } buf [ len ++ ] = '&' ; while ( len > buf_size - i - 10 ) { growBuffer ( buf , i + 10 ) ; } for ( ; i > 0 ; i -- ) buf [ len ++ ] = * cur ++ ; buf [ len ++ ] = ';' ; } } } else { if ( ( c == 0x20 ) || ( c == 0xD ) || ( c == 0xA ) || ( c == 0x9 ) ) { if ( ( len != 0 ) || ( ! normalize ) ) { if ( ( ! normalize ) || ( ! in_space ) ) { COPY_BUF ( l , buf , len , 0x20 ) ; while ( len > buf_size - 10 ) { growBuffer ( buf , 10 ) ; } } in_space = 1 ; } } else { in_space = 0 ; COPY_BUF ( l , buf , len , c ) ; if ( len > buf_size - 10 ) { growBuffer ( buf , 10 ) ; } } NEXTL ( l ) ; } GROW ; c = CUR_CHAR ( l ) ; } if ( ( in_space ) && ( normalize ) ) { <S2SV_StartBug> while ( buf [ len - 1 ] == 0x20 ) len -- ; <S2SV_EndBug> } buf [ len ] = 0 ; if ( RAW == '<' ) { xmlFatalErr ( ctxt , XML_ERR_LT_IN_ATTRIBUTE , NULL ) ; } else if ( RAW != limit ) { if ( ( c != 0 ) && ( ! IS_CHAR ( c ) ) ) { xmlFatalErrMsg ( ctxt , XML_ERR_INVALID_CHAR , ""invalid<S2SV_blank>character<S2SV_blank>in<S2SV_blank>attribute<S2SV_blank>value\\n"" ) ; } else { xmlFatalErrMsg ( ctxt , XML_ERR_ATTRIBUTE_NOT_FINISHED , ""AttValue:<S2SV_blank>\'<S2SV_blank>expected\\n"" ) ; } } else NEXT ; if ( attlen != NULL ) * attlen = len ; return ( buf ) ; mem_error : xmlErrMemory ( ctxt , NULL ) ; if ( buf != NULL ) xmlFree ( buf ) ; if ( rep != NULL ) xmlFree ( rep ) ; return ( NULL ) ; }
","<S2SV_ModStart> { while ( ( len > 0 ) && ( <S2SV_ModStart> == 0x20 ) )
"
235,"CWE-119 php_stream * php_stream_url_wrap_http_ex ( php_stream_wrapper * wrapper , const char * path , const char * mode , int options , char * * opened_path , php_stream_context * context , int redirect_max , int flags STREAMS_DC TSRMLS_DC ) { php_stream * stream = NULL ; php_url * resource = NULL ; int use_ssl ; int use_proxy = 0 ; char * scratch = NULL ; char * tmp = NULL ; char * ua_str = NULL ; zval * * ua_zval = NULL , * * tmpzval = NULL , * ssl_proxy_peer_name = NULL ; int scratch_len = 0 ; int body = 0 ; char location [ HTTP_HEADER_BLOCK_SIZE ] ; zval * response_header = NULL ; int reqok = 0 ; char * http_header_line = NULL ; char tmp_line [ 128 ] ; size_t chunk_size = 0 , file_size = 0 ; int eol_detect = 0 ; char * transport_string , * errstr = NULL ; int transport_len , have_header = 0 , request_fulluri = 0 , ignore_errors = 0 ; char * protocol_version = NULL ; int protocol_version_len = 3 ; struct timeval timeout ; char * user_headers = NULL ; int header_init = ( ( flags & HTTP_WRAPPER_HEADER_INIT ) != 0 ) ; int redirected = ( ( flags & HTTP_WRAPPER_REDIRECTED ) != 0 ) ; int follow_location = 1 ; php_stream_filter * transfer_encoding = NULL ; int response_code ; tmp_line [ 0 ] = '\\0' ; if ( redirect_max < 1 ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""Redirection<S2SV_blank>limit<S2SV_blank>reached,<S2SV_blank>aborting"" ) ; return NULL ; } resource = php_url_parse ( path ) ; if ( resource == NULL ) { return NULL ; } if ( strncasecmp ( resource -> scheme , ""http"" , sizeof ( ""http"" ) ) && strncasecmp ( resource -> scheme , ""https"" , sizeof ( ""https"" ) ) ) { if ( ! context || php_stream_context_get_option ( context , wrapper -> wops -> label , ""proxy"" , & tmpzval ) == FAILURE || Z_TYPE_PP ( tmpzval ) != IS_STRING || Z_STRLEN_PP ( tmpzval ) <= 0 ) { php_url_free ( resource ) ; return php_stream_open_wrapper_ex ( path , mode , REPORT_ERRORS , NULL , context ) ; } request_fulluri = 1 ; use_ssl = 0 ; use_proxy = 1 ; transport_len = Z_STRLEN_PP ( tmpzval ) ; transport_string = estrndup ( Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) ) ; } else { if ( strpbrk ( mode , ""awx+"" ) ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""HTTP<S2SV_blank>wrapper<S2SV_blank>does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>writeable<S2SV_blank>connections"" ) ; php_url_free ( resource ) ; return NULL ; } use_ssl = resource -> scheme && ( strlen ( resource -> scheme ) > 4 ) && resource -> scheme [ 4 ] == 's' ; if ( use_ssl && resource -> port == 0 ) resource -> port = 443 ; else if ( resource -> port == 0 ) resource -> port = 80 ; if ( context && php_stream_context_get_option ( context , wrapper -> wops -> label , ""proxy"" , & tmpzval ) == SUCCESS && Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) > 0 ) { use_proxy = 1 ; transport_len = Z_STRLEN_PP ( tmpzval ) ; transport_string = estrndup ( Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) ) ; } else { transport_len = spprintf ( & transport_string , 0 , ""%s://%s:%d"" , use_ssl ? ""ssl"" : ""tcp"" , resource -> host , resource -> port ) ; } } if ( context && php_stream_context_get_option ( context , wrapper -> wops -> label , ""timeout"" , & tmpzval ) == SUCCESS ) { SEPARATE_ZVAL ( tmpzval ) ; convert_to_double_ex ( tmpzval ) ; timeout . tv_sec = ( time_t ) Z_DVAL_PP ( tmpzval ) ; timeout . tv_usec = ( size_t ) ( ( Z_DVAL_PP ( tmpzval ) - timeout . tv_sec ) * 1000000 ) ; } else { timeout . tv_sec = FG ( default_socket_timeout ) ; timeout . tv_usec = 0 ; } stream = php_stream_xport_create ( transport_string , transport_len , options , STREAM_XPORT_CLIENT | STREAM_XPORT_CONNECT , NULL , & timeout , context , & errstr , NULL ) ; if ( stream ) { php_stream_set_option ( stream , PHP_STREAM_OPTION_READ_TIMEOUT , 0 , & timeout ) ; } if ( errstr ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""%s"" , errstr ) ; efree ( errstr ) ; errstr = NULL ; } efree ( transport_string ) ; if ( stream && use_proxy && use_ssl ) { smart_str header = { 0 } ; if ( ! context || php_stream_context_get_option ( context , ""ssl"" , ""peer_name"" , & tmpzval ) == FAILURE ) { MAKE_STD_ZVAL ( ssl_proxy_peer_name ) ; ZVAL_STRING ( ssl_proxy_peer_name , resource -> host , 1 ) ; php_stream_context_set_option ( stream -> context , ""ssl"" , ""peer_name"" , ssl_proxy_peer_name ) ; } smart_str_appendl ( & header , ""CONNECT<S2SV_blank>"" , sizeof ( ""CONNECT<S2SV_blank>"" ) - 1 ) ; smart_str_appends ( & header , resource -> host ) ; smart_str_appendc ( & header , ':' ) ; smart_str_append_unsigned ( & header , resource -> port ) ; smart_str_appendl ( & header , ""<S2SV_blank>HTTP/1.0\\r\\n"" , sizeof ( ""<S2SV_blank>HTTP/1.0\\r\\n"" ) - 1 ) ; if ( context && php_stream_context_get_option ( context , ""http"" , ""header"" , & tmpzval ) == SUCCESS ) { char * s , * p ; if ( Z_TYPE_PP ( tmpzval ) == IS_ARRAY ) { HashPosition pos ; zval * * tmpheader = NULL ; for ( zend_hash_internal_pointer_reset_ex ( Z_ARRVAL_PP ( tmpzval ) , & pos ) ; SUCCESS == zend_hash_get_current_data_ex ( Z_ARRVAL_PP ( tmpzval ) , ( void * ) & tmpheader , & pos ) ; zend_hash_move_forward_ex ( Z_ARRVAL_PP ( tmpzval ) , & pos ) ) { if ( Z_TYPE_PP ( tmpheader ) == IS_STRING ) { s = Z_STRVAL_PP ( tmpheader ) ; do { while ( * s == '<S2SV_blank>' || * s == '\\t' ) s ++ ; p = s ; while ( * p != 0 && * p != ':' && * p != '\\r' && * p != '\\n' ) p ++ ; if ( * p == ':' ) { p ++ ; if ( p - s == sizeof ( ""Proxy-Authorization:"" ) - 1 && zend_binary_strcasecmp ( s , sizeof ( ""Proxy-Authorization:"" ) - 1 , ""Proxy-Authorization:"" , sizeof ( ""Proxy-Authorization:"" ) - 1 ) == 0 ) { while ( * p != 0 && * p != '\\r' && * p != '\\n' ) p ++ ; smart_str_appendl ( & header , s , p - s ) ; smart_str_appendl ( & header , ""\\r\\n"" , sizeof ( ""\\r\\n"" ) - 1 ) ; goto finish ; } else { while ( * p != 0 && * p != '\\r' && * p != '\\n' ) p ++ ; } } s = p ; while ( * s == '\\r' || * s == '\\n' ) s ++ ; } while ( * s != 0 ) ; } } } else if ( Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) ) { s = Z_STRVAL_PP ( tmpzval ) ; do { while ( * s == '<S2SV_blank>' || * s == '\\t' ) s ++ ; p = s ; while ( * p != 0 && * p != ':' && * p != '\\r' && * p != '\\n' ) p ++ ; if ( * p == ':' ) { p ++ ; if ( p - s == sizeof ( ""Proxy-Authorization:"" ) - 1 && zend_binary_strcasecmp ( s , sizeof ( ""Proxy-Authorization:"" ) - 1 , ""Proxy-Authorization:"" , sizeof ( ""Proxy-Authorization:"" ) - 1 ) == 0 ) { while ( * p != 0 && * p != '\\r' && * p != '\\n' ) p ++ ; smart_str_appendl ( & header , s , p - s ) ; smart_str_appendl ( & header , ""\\r\\n"" , sizeof ( ""\\r\\n"" ) - 1 ) ; goto finish ; } else { while ( * p != 0 && * p != '\\r' && * p != '\\n' ) p ++ ; } } s = p ; while ( * s == '\\r' || * s == '\\n' ) s ++ ; } while ( * s != 0 ) ; } } finish : smart_str_appendl ( & header , ""\\r\\n"" , sizeof ( ""\\r\\n"" ) - 1 ) ; if ( php_stream_write ( stream , header . c , header . len ) != header . len ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""Cannot<S2SV_blank>connect<S2SV_blank>to<S2SV_blank>HTTPS<S2SV_blank>server<S2SV_blank>through<S2SV_blank>proxy"" ) ; php_stream_close ( stream ) ; stream = NULL ; } smart_str_free ( & header ) ; if ( stream ) { char header_line [ HTTP_HEADER_BLOCK_SIZE ] ; while ( php_stream_gets ( stream , header_line , HTTP_HEADER_BLOCK_SIZE - 1 ) != NULL ) { if ( header_line [ 0 ] == '\\n' || header_line [ 0 ] == '\\r' || header_line [ 0 ] == '\\0' ) { break ; } } } if ( stream ) { if ( php_stream_xport_crypto_setup ( stream , STREAM_CRYPTO_METHOD_SSLv23_CLIENT , NULL TSRMLS_CC ) < 0 || php_stream_xport_crypto_enable ( stream , 1 TSRMLS_CC ) < 0 ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""Cannot<S2SV_blank>connect<S2SV_blank>to<S2SV_blank>HTTPS<S2SV_blank>server<S2SV_blank>through<S2SV_blank>proxy"" ) ; php_stream_close ( stream ) ; stream = NULL ; } } } if ( stream == NULL ) goto out ; if ( options & STREAM_WILL_CAST ) chunk_size = php_stream_set_chunk_size ( stream , 1 ) ; eol_detect = stream -> flags & ( PHP_STREAM_FLAG_DETECT_EOL | PHP_STREAM_FLAG_EOL_MAC ) ; stream -> flags &= ~ ( PHP_STREAM_FLAG_DETECT_EOL | PHP_STREAM_FLAG_EOL_MAC ) ; php_stream_context_set ( stream , context ) ; php_stream_notify_info ( context , PHP_STREAM_NOTIFY_CONNECT , NULL , 0 ) ; if ( header_init && context && php_stream_context_get_option ( context , ""http"" , ""max_redirects"" , & tmpzval ) == SUCCESS ) { SEPARATE_ZVAL ( tmpzval ) ; convert_to_long_ex ( tmpzval ) ; redirect_max = Z_LVAL_PP ( tmpzval ) ; } if ( context && php_stream_context_get_option ( context , ""http"" , ""method"" , & tmpzval ) == SUCCESS ) { if ( Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) > 0 ) { if ( ! redirected || ( Z_STRLEN_PP ( tmpzval ) == 3 && memcmp ( ""GET"" , Z_STRVAL_PP ( tmpzval ) , 3 ) == 0 ) || ( Z_STRLEN_PP ( tmpzval ) == 4 && memcmp ( ""HEAD"" , Z_STRVAL_PP ( tmpzval ) , 4 ) == 0 ) ) { scratch_len = strlen ( path ) + 29 + Z_STRLEN_PP ( tmpzval ) ; scratch = emalloc ( scratch_len ) ; strlcpy ( scratch , Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) + 1 ) ; strncat ( scratch , ""<S2SV_blank>"" , 1 ) ; } } } if ( context && php_stream_context_get_option ( context , ""http"" , ""protocol_version"" , & tmpzval ) == SUCCESS ) { SEPARATE_ZVAL ( tmpzval ) ; convert_to_double_ex ( tmpzval ) ; protocol_version_len = spprintf ( & protocol_version , 0 , ""%.1F"" , Z_DVAL_PP ( tmpzval ) ) ; } if ( ! scratch ) { scratch_len = strlen ( path ) + 29 + protocol_version_len ; scratch = emalloc ( scratch_len ) ; strncpy ( scratch , ""GET<S2SV_blank>"" , scratch_len ) ; } if ( ! request_fulluri && context && php_stream_context_get_option ( context , ""http"" , ""request_fulluri"" , & tmpzval ) == SUCCESS ) { zval ztmp = * * tmpzval ; zval_copy_ctor ( & ztmp ) ; convert_to_boolean ( & ztmp ) ; request_fulluri = Z_BVAL ( ztmp ) ? 1 : 0 ; zval_dtor ( & ztmp ) ; } if ( request_fulluri ) { strcat ( scratch , path ) ; } else { if ( resource -> path && * resource -> path ) { strlcat ( scratch , resource -> path , scratch_len ) ; } else { strlcat ( scratch , ""/"" , scratch_len ) ; } if ( resource -> query ) { strlcat ( scratch , ""?"" , scratch_len ) ; strlcat ( scratch , resource -> query , scratch_len ) ; } } if ( protocol_version ) { strlcat ( scratch , ""<S2SV_blank>HTTP/"" , scratch_len ) ; strlcat ( scratch , protocol_version , scratch_len ) ; strlcat ( scratch , ""\\r\\n"" , scratch_len ) ; } else { strlcat ( scratch , ""<S2SV_blank>HTTP/1.0\\r\\n"" , scratch_len ) ; } php_stream_write ( stream , scratch , strlen ( scratch ) ) ; if ( context && php_stream_context_get_option ( context , ""http"" , ""header"" , & tmpzval ) == SUCCESS ) { tmp = NULL ; if ( Z_TYPE_PP ( tmpzval ) == IS_ARRAY ) { HashPosition pos ; zval * * tmpheader = NULL ; smart_str tmpstr = { 0 } ; for ( zend_hash_internal_pointer_reset_ex ( Z_ARRVAL_PP ( tmpzval ) , & pos ) ; SUCCESS == zend_hash_get_current_data_ex ( Z_ARRVAL_PP ( tmpzval ) , ( void * ) & tmpheader , & pos ) ; zend_hash_move_forward_ex ( Z_ARRVAL_PP ( tmpzval ) , & pos ) ) { if ( Z_TYPE_PP ( tmpheader ) == IS_STRING ) { smart_str_appendl ( & tmpstr , Z_STRVAL_PP ( tmpheader ) , Z_STRLEN_PP ( tmpheader ) ) ; smart_str_appendl ( & tmpstr , ""\\r\\n"" , sizeof ( ""\\r\\n"" ) - 1 ) ; } } smart_str_0 ( & tmpstr ) ; if ( tmpstr . c ) { tmp = php_trim ( tmpstr . c , strlen ( tmpstr . c ) , NULL , 0 , NULL , 3 TSRMLS_CC ) ; smart_str_free ( & tmpstr ) ; } } if ( Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) ) { tmp = php_trim ( Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) , NULL , 0 , NULL , 3 TSRMLS_CC ) ; } if ( tmp && strlen ( tmp ) > 0 ) { char * s ; user_headers = estrdup ( tmp ) ; php_strtolower ( tmp , strlen ( tmp ) ) ; if ( ! header_init ) { strip_header ( user_headers , tmp , ""content-length:"" ) ; strip_header ( user_headers , tmp , ""content-type:"" ) ; } if ( ( s = strstr ( tmp , ""user-agent:"" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == '<S2SV_blank>' ) ) { have_header |= HTTP_HEADER_USER_AGENT ; } if ( ( s = strstr ( tmp , ""host:"" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == '<S2SV_blank>' ) ) { have_header |= HTTP_HEADER_HOST ; } if ( ( s = strstr ( tmp , ""from:"" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == '<S2SV_blank>' ) ) { have_header |= HTTP_HEADER_FROM ; } if ( ( s = strstr ( tmp , ""authorization:"" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == '<S2SV_blank>' ) ) { have_header |= HTTP_HEADER_AUTH ; } if ( ( s = strstr ( tmp , ""content-length:"" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == '<S2SV_blank>' ) ) { have_header |= HTTP_HEADER_CONTENT_LENGTH ; } if ( ( s = strstr ( tmp , ""content-type:"" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == '<S2SV_blank>' ) ) { have_header |= HTTP_HEADER_TYPE ; } if ( ( s = strstr ( tmp , ""connection:"" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == '<S2SV_blank>' ) ) { have_header |= HTTP_HEADER_CONNECTION ; } if ( use_proxy && use_ssl && ( s = strstr ( tmp , ""proxy-authorization:"" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == '<S2SV_blank>' ) ) { char * p = s + sizeof ( ""proxy-authorization:"" ) - 1 ; while ( s > tmp && ( * ( s - 1 ) == '<S2SV_blank>' || * ( s - 1 ) == '\\t' ) ) s -- ; while ( * p != 0 && * p != '\\r' && * p != '\\n' ) p ++ ; while ( * p == '\\r' || * p == '\\n' ) p ++ ; if ( * p == 0 ) { if ( s == tmp ) { efree ( user_headers ) ; user_headers = NULL ; } else { while ( s > tmp && ( * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' ) ) s -- ; user_headers [ s - tmp ] = 0 ; } } else { memmove ( user_headers + ( s - tmp ) , user_headers + ( p - tmp ) , strlen ( p ) + 1 ) ; } } } if ( tmp ) { efree ( tmp ) ; } } if ( ( ( have_header & HTTP_HEADER_AUTH ) == 0 ) && resource -> user ) { php_url_decode ( resource -> user , strlen ( resource -> user ) ) ; strcpy ( scratch , resource -> user ) ; strcat ( scratch , "":"" ) ; if ( resource -> pass ) { php_url_decode ( resource -> pass , strlen ( resource -> pass ) ) ; strcat ( scratch , resource -> pass ) ; } tmp = ( char * ) php_base64_encode ( ( unsigned char * ) scratch , strlen ( scratch ) , NULL ) ; if ( snprintf ( scratch , scratch_len , ""Authorization:<S2SV_blank>Basic<S2SV_blank>%s\\r\\n"" , tmp ) > 0 ) { php_stream_write ( stream , scratch , strlen ( scratch ) ) ; php_stream_notify_info ( context , PHP_STREAM_NOTIFY_AUTH_REQUIRED , NULL , 0 ) ; } efree ( tmp ) ; tmp = NULL ; } if ( ( ( have_header & HTTP_HEADER_FROM ) == 0 ) && FG ( from_address ) ) { if ( snprintf ( scratch , scratch_len , ""From:<S2SV_blank>%s\\r\\n"" , FG ( from_address ) ) > 0 ) php_stream_write ( stream , scratch , strlen ( scratch ) ) ; } if ( ( have_header & HTTP_HEADER_HOST ) == 0 ) { if ( ( use_ssl && resource -> port != 443 && resource -> port != 0 ) || ( ! use_ssl && resource -> port != 80 && resource -> port != 0 ) ) { if ( snprintf ( scratch , scratch_len , ""Host:<S2SV_blank>%s:%i\\r\\n"" , resource -> host , resource -> port ) > 0 ) php_stream_write ( stream , scratch , strlen ( scratch ) ) ; } else { if ( snprintf ( scratch , scratch_len , ""Host:<S2SV_blank>%s\\r\\n"" , resource -> host ) > 0 ) { php_stream_write ( stream , scratch , strlen ( scratch ) ) ; } } } if ( ( have_header & HTTP_HEADER_CONNECTION ) == 0 ) { php_stream_write_string ( stream , ""Connection:<S2SV_blank>close\\r\\n"" ) ; } if ( context && php_stream_context_get_option ( context , ""http"" , ""user_agent"" , & ua_zval ) == SUCCESS && Z_TYPE_PP ( ua_zval ) == IS_STRING ) { ua_str = Z_STRVAL_PP ( ua_zval ) ; } else if ( FG ( user_agent ) ) { ua_str = FG ( user_agent ) ; } if ( ( ( have_header & HTTP_HEADER_USER_AGENT ) == 0 ) && ua_str ) { # define _UA_HEADER ""User-Agent:<S2SV_blank>%s\\r\\n"" char * ua ; size_t ua_len ; ua_len = sizeof ( _UA_HEADER ) + strlen ( ua_str ) ; if ( ua_len > sizeof ( _UA_HEADER ) ) { ua = emalloc ( ua_len + 1 ) ; if ( ( ua_len = slprintf ( ua , ua_len , _UA_HEADER , ua_str ) ) > 0 ) { ua [ ua_len ] = 0 ; php_stream_write ( stream , ua , ua_len ) ; } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Cannot<S2SV_blank>construct<S2SV_blank>User-agent<S2SV_blank>header"" ) ; } if ( ua ) { efree ( ua ) ; } } } if ( user_headers ) { if ( header_init && context && ! ( have_header & HTTP_HEADER_CONTENT_LENGTH ) && php_stream_context_get_option ( context , ""http"" , ""content"" , & tmpzval ) == SUCCESS && Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) > 0 ) { scratch_len = slprintf ( scratch , scratch_len , ""Content-Length:<S2SV_blank>%d\\r\\n"" , Z_STRLEN_PP ( tmpzval ) ) ; php_stream_write ( stream , scratch , scratch_len ) ; have_header |= HTTP_HEADER_CONTENT_LENGTH ; } php_stream_write ( stream , user_headers , strlen ( user_headers ) ) ; php_stream_write ( stream , ""\\r\\n"" , sizeof ( ""\\r\\n"" ) - 1 ) ; efree ( user_headers ) ; } if ( header_init && context && php_stream_context_get_option ( context , ""http"" , ""content"" , & tmpzval ) == SUCCESS && Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) > 0 ) { if ( ! ( have_header & HTTP_HEADER_CONTENT_LENGTH ) ) { scratch_len = slprintf ( scratch , scratch_len , ""Content-Length:<S2SV_blank>%d\\r\\n"" , Z_STRLEN_PP ( tmpzval ) ) ; php_stream_write ( stream , scratch , scratch_len ) ; } if ( ! ( have_header & HTTP_HEADER_TYPE ) ) { php_stream_write ( stream , ""Content-Type:<S2SV_blank>application/x-www-form-urlencoded\\r\\n"" , sizeof ( ""Content-Type:<S2SV_blank>application/x-www-form-urlencoded\\r\\n"" ) - 1 ) ; php_error_docref ( NULL TSRMLS_CC , E_NOTICE , ""Content-type<S2SV_blank>not<S2SV_blank>specified<S2SV_blank>assuming<S2SV_blank>application/x-www-form-urlencoded"" ) ; } php_stream_write ( stream , ""\\r\\n"" , sizeof ( ""\\r\\n"" ) - 1 ) ; php_stream_write ( stream , Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) ) ; } else { php_stream_write ( stream , ""\\r\\n"" , sizeof ( ""\\r\\n"" ) - 1 ) ; } location [ 0 ] = '\\0' ; if ( ! EG ( active_symbol_table ) ) { zend_rebuild_symbol_table ( TSRMLS_C ) ; } if ( header_init ) { zval * ztmp ; MAKE_STD_ZVAL ( ztmp ) ; array_init ( ztmp ) ; ZEND_SET_SYMBOL ( EG ( active_symbol_table ) , ""http_response_header"" , ztmp ) ; } { zval * * rh ; if ( zend_hash_find ( EG ( active_symbol_table ) , ""http_response_header"" , sizeof ( ""http_response_header"" ) , ( void * * ) & rh ) != SUCCESS || Z_TYPE_PP ( rh ) != IS_ARRAY ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""HTTP<S2SV_blank>request<S2SV_blank>failed,<S2SV_blank>http_response_header<S2SV_blank>overwritten"" ) ; goto out ; } response_header = * rh ; Z_ADDREF_P ( response_header ) ; } if ( ! php_stream_eof ( stream ) ) { size_t tmp_line_len ; if ( php_stream_get_line ( stream , tmp_line , sizeof ( tmp_line ) - 1 , & tmp_line_len ) != NULL ) { zval * http_response ; if ( tmp_line_len > 9 ) { response_code = atoi ( tmp_line + 9 ) ; } else { response_code = 0 ; } if ( context && SUCCESS == php_stream_context_get_option ( context , ""http"" , ""ignore_errors"" , & tmpzval ) ) { ignore_errors = zend_is_true ( * tmpzval ) ; } if ( ( options & STREAM_ONLY_GET_HEADERS ) || ignore_errors ) { reqok = 1 ; } if ( response_code >= 100 && response_code < 200 ) { while ( ! php_stream_eof ( stream ) && php_stream_get_line ( stream , tmp_line , sizeof ( tmp_line ) - 1 , & tmp_line_len ) != NULL && ( tmp_line_len < sizeof ( ""HTTP/1"" ) - 1 || strncasecmp ( tmp_line , ""HTTP/1"" , sizeof ( ""HTTP/1"" ) - 1 ) ) ) ; if ( tmp_line_len > 9 ) { response_code = atoi ( tmp_line + 9 ) ; } else { response_code = 0 ; } } if ( response_code >= 200 && response_code < 400 ) { reqok = 1 ; } else { switch ( response_code ) { case 403 : php_stream_notify_error ( context , PHP_STREAM_NOTIFY_AUTH_RESULT , tmp_line , response_code ) ; break ; default : if ( ! tmp_line_len ) { tmp_line [ 0 ] = '\\0' ; } php_stream_notify_error ( context , PHP_STREAM_NOTIFY_FAILURE , tmp_line , response_code ) ; } } <S2SV_StartBug> if ( tmp_line [ tmp_line_len - 1 ] == '\\n' ) { <S2SV_EndBug> -- tmp_line_len ; <S2SV_StartBug> if ( tmp_line [ tmp_line_len - 1 ] == '\\r' ) { <S2SV_EndBug> -- tmp_line_len ; } } MAKE_STD_ZVAL ( http_response ) ; ZVAL_STRINGL ( http_response , tmp_line , tmp_line_len , 1 ) ; zend_hash_next_index_insert ( Z_ARRVAL_P ( response_header ) , & http_response , sizeof ( zval * ) , NULL ) ; } } else { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""HTTP<S2SV_blank>request<S2SV_blank>failed,<S2SV_blank>unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>socket!"" ) ; goto out ; } http_header_line = emalloc ( HTTP_HEADER_BLOCK_SIZE ) ; while ( ! body && ! php_stream_eof ( stream ) ) { size_t http_header_line_length ; if ( php_stream_get_line ( stream , http_header_line , HTTP_HEADER_BLOCK_SIZE , & http_header_line_length ) && * http_header_line != '\\n' && * http_header_line != '\\r' ) { char * e = http_header_line + http_header_line_length - 1 ; if ( * e != '\\n' ) { do { if ( php_stream_get_line ( stream , http_header_line , HTTP_HEADER_BLOCK_SIZE , & http_header_line_length ) == NULL ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>HTTP<S2SV_blank>headers"" ) ; goto out ; } e = http_header_line + http_header_line_length - 1 ; } while ( * e != '\\n' ) ; continue ; } while ( * e == '\\n' || * e == '\\r' ) { e -- ; } http_header_line_length = e - http_header_line + 1 ; http_header_line [ http_header_line_length ] = '\\0' ; if ( ! strncasecmp ( http_header_line , ""Location:<S2SV_blank>"" , 10 ) ) { if ( context && php_stream_context_get_option ( context , ""http"" , ""follow_location"" , & tmpzval ) == SUCCESS ) { SEPARATE_ZVAL ( tmpzval ) ; convert_to_long_ex ( tmpzval ) ; follow_location = Z_LVAL_PP ( tmpzval ) ; } else if ( ! ( response_code >= 300 && response_code < 304 || 307 == response_code || 308 == response_code ) ) { follow_location = 0 ; } strlcpy ( location , http_header_line + 10 , sizeof ( location ) ) ; } else if ( ! strncasecmp ( http_header_line , ""Content-Type:<S2SV_blank>"" , 14 ) ) { php_stream_notify_info ( context , PHP_STREAM_NOTIFY_MIME_TYPE_IS , http_header_line + 14 , 0 ) ; } else if ( ! strncasecmp ( http_header_line , ""Content-Length:<S2SV_blank>"" , 16 ) ) { file_size = atoi ( http_header_line + 16 ) ; php_stream_notify_file_size ( context , file_size , http_header_line , 0 ) ; } else if ( ! strncasecmp ( http_header_line , ""Transfer-Encoding:<S2SV_blank>chunked"" , sizeof ( ""Transfer-Encoding:<S2SV_blank>chunked"" ) ) ) { if ( ! ( options & STREAM_ONLY_GET_HEADERS ) ) { long decode = 1 ; if ( context && php_stream_context_get_option ( context , ""http"" , ""auto_decode"" , & tmpzval ) == SUCCESS ) { SEPARATE_ZVAL ( tmpzval ) ; convert_to_boolean ( * tmpzval ) ; decode = Z_LVAL_PP ( tmpzval ) ; } if ( decode ) { transfer_encoding = php_stream_filter_create ( ""dechunk"" , NULL , php_stream_is_persistent ( stream ) TSRMLS_CC ) ; if ( transfer_encoding ) { continue ; } } } } if ( http_header_line [ 0 ] == '\\0' ) { body = 1 ; } else { zval * http_header ; MAKE_STD_ZVAL ( http_header ) ; ZVAL_STRINGL ( http_header , http_header_line , http_header_line_length , 1 ) ; zend_hash_next_index_insert ( Z_ARRVAL_P ( response_header ) , & http_header , sizeof ( zval * ) , NULL ) ; } } else { break ; } } if ( ! reqok || ( location [ 0 ] != '\\0' && follow_location ) ) { if ( ! follow_location || ( ( ( options & STREAM_ONLY_GET_HEADERS ) || ignore_errors ) && redirect_max <= 1 ) ) { goto out ; } if ( location [ 0 ] != '\\0' ) php_stream_notify_info ( context , PHP_STREAM_NOTIFY_REDIRECTED , location , 0 ) ; php_stream_close ( stream ) ; stream = NULL ; if ( location [ 0 ] != '\\0' ) { char new_path [ HTTP_HEADER_BLOCK_SIZE ] ; char loc_path [ HTTP_HEADER_BLOCK_SIZE ] ; * new_path = '\\0' ; if ( strlen ( location ) < 8 || ( strncasecmp ( location , ""http://"" , sizeof ( ""http://"" ) - 1 ) && strncasecmp ( location , ""https://"" , sizeof ( ""https://"" ) - 1 ) && strncasecmp ( location , ""ftp://"" , sizeof ( ""ftp://"" ) - 1 ) && strncasecmp ( location , ""ftps://"" , sizeof ( ""ftps://"" ) - 1 ) ) ) { if ( * location != '/' ) { if ( * ( location + 1 ) != '\\0' && resource -> path ) { char * s = strrchr ( resource -> path , '/' ) ; if ( ! s ) { s = resource -> path ; if ( ! s [ 0 ] ) { efree ( s ) ; s = resource -> path = estrdup ( ""/"" ) ; } else { * s = '/' ; } } s [ 1 ] = '\\0' ; if ( resource -> path && * ( resource -> path ) == '/' && * ( resource -> path + 1 ) == '\\0' ) { snprintf ( loc_path , sizeof ( loc_path ) - 1 , ""%s%s"" , resource -> path , location ) ; } else { snprintf ( loc_path , sizeof ( loc_path ) - 1 , ""%s/%s"" , resource -> path , location ) ; } } else { snprintf ( loc_path , sizeof ( loc_path ) - 1 , ""/%s"" , location ) ; } } else { strlcpy ( loc_path , location , sizeof ( loc_path ) ) ; } if ( ( use_ssl && resource -> port != 443 ) || ( ! use_ssl && resource -> port != 80 ) ) { snprintf ( new_path , sizeof ( new_path ) - 1 , ""%s://%s:%d%s"" , resource -> scheme , resource -> host , resource -> port , loc_path ) ; } else { snprintf ( new_path , sizeof ( new_path ) - 1 , ""%s://%s%s"" , resource -> scheme , resource -> host , loc_path ) ; } } else { strlcpy ( new_path , location , sizeof ( new_path ) ) ; } php_url_free ( resource ) ; if ( ( resource = php_url_parse ( new_path ) ) == NULL ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""Invalid<S2SV_blank>redirect<S2SV_blank>URL!<S2SV_blank>%s"" , new_path ) ; goto out ; } <S2SV_StartBug> # define CHECK_FOR_CNTRL_CHARS ( val ) { if ( val ) { unsigned char * s , * e ; int l ; l = php_url_decode ( val , strlen ( val ) ) ; s = ( unsigned char * ) val ; e = s + l ; while ( s < e ) { if ( iscntrl ( * s ) ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""Invalid<S2SV_blank>redirect<S2SV_blank>URL!<S2SV_blank>%s"" , new_path ) ; goto out ; } s ++ ; } } } <S2SV_EndBug> if ( strncasecmp ( new_path , ""http://"" , sizeof ( ""http://"" ) - 1 ) || strncasecmp ( new_path , ""https://"" , sizeof ( ""https://"" ) - 1 ) ) { CHECK_FOR_CNTRL_CHARS ( resource -> user ) CHECK_FOR_CNTRL_CHARS ( resource -> pass ) CHECK_FOR_CNTRL_CHARS ( resource -> path ) } stream = php_stream_url_wrap_http_ex ( wrapper , new_path , mode , options , opened_path , context , -- redirect_max , HTTP_WRAPPER_REDIRECTED STREAMS_CC TSRMLS_CC ) ; } else { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""HTTP<S2SV_blank>request<S2SV_blank>failed!<S2SV_blank>%s"" , tmp_line ) ; } } out : if ( protocol_version ) { efree ( protocol_version ) ; } if ( http_header_line ) { efree ( http_header_line ) ; } if ( scratch ) { efree ( scratch ) ; } if ( resource ) { php_url_free ( resource ) ; } if ( stream ) { if ( header_init ) { stream -> wrapperdata = response_header ; } else { if ( response_header ) { Z_DELREF_P ( response_header ) ; } } php_stream_notify_progress_init ( context , 0 , file_size ) ; if ( options & STREAM_WILL_CAST ) php_stream_set_chunk_size ( stream , chunk_size ) ; stream -> flags |= eol_detect ; stream -> position = 0 ; strlcpy ( stream -> mode , mode , sizeof ( stream -> mode ) ) ; if ( transfer_encoding ) { php_stream_filter_append ( & stream -> readfilters , transfer_encoding ) ; } } else { if ( response_header ) { Z_DELREF_P ( response_header ) ; } if ( transfer_encoding ) { php_stream_filter_free ( transfer_encoding TSRMLS_CC ) ; } } return stream ; }
","<S2SV_ModStart> } if ( tmp_line_len >= 1 && <S2SV_ModStart> ; if ( tmp_line_len >= 1 && <S2SV_ModStart> ; } } \\\n} <S2SV_ModEnd> if ( strncasecmp
"
236,"CWE-404 int nfs3svc_decode_readargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_readargs * args ) { unsigned int len ; int v ; u32 max_blocksize = svc_max_payload ( rqstp ) ; p = decode_fh ( p , & args -> fh ) ; if ( ! p ) return 0 ; p = xdr_decode_hyper ( p , & args -> offset ) ; <S2SV_StartBug> args -> count = ntohl ( * p ++ ) ; <S2SV_EndBug> len = min ( args -> count , max_blocksize ) ; v = 0 ; while ( len > 0 ) { struct page * p = * ( rqstp -> rq_next_page ++ ) ; rqstp -> rq_vec [ v ] . iov_base = page_address ( p ) ; rqstp -> rq_vec [ v ] . iov_len = min_t ( unsigned int , len , PAGE_SIZE ) ; len -= rqstp -> rq_vec [ v ] . iov_len ; v ++ ; } args -> vlen = v ; <S2SV_StartBug> return xdr_argsize_check ( rqstp , p ) ; <S2SV_EndBug> }
","<S2SV_ModStart> p ++ ) ; if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 <S2SV_ModStart> v ; return 1 <S2SV_ModEnd> ; } <S2SV_null>
"
237,"CWE-119 static int sd_e_h ( GWindow gw , GEvent * event ) { struct sd_data * sd = GDrawGetUserData ( gw ) ; if ( sd == NULL ) return ( true ) ; if ( event -> type == et_close ) { SD_DoCancel ( sd ) ; <S2SV_StartBug> } else if ( event -> type == et_char ) { <S2SV_EndBug> if ( event -> u . chr . keysym == GK_F1 || event -> u . chr . keysym == GK_Help ) { help ( ""scripting.html"" ) ; return ( true ) ; } return ( false ) ; } else if ( event -> type == et_map ) GDrawRaise ( gw ) ; else if ( event -> type == et_resize ) GDrawRequestExpose ( gw , NULL , false ) ; return ( true ) ; }
","<S2SV_ModStart> -> type == et_controlevent && event -> u . control . subtype == et_textchanged ) { sd -> fv -> script_unsaved = ! GTextFieldIsEmpty ( GWidgetGetControl ( sd -> gw , CID_Script ) ) ; } else if ( event -> type == et_controlevent && event -> u . control . subtype == et_save ) { sd -> fv -> script_unsaved = false ; } else if ( event -> type ==
"
238,"CWE-617 void pci_lintr_request ( struct pci_vdev * dev ) { struct businfo * bi ; struct slotinfo * si ; int bestpin , bestcount , pin ; bi = pci_businfo [ dev -> bus ] ; <S2SV_StartBug> assert ( bi != NULL ) ; <S2SV_EndBug> si = & bi -> slotinfo [ dev -> slot ] ; bestpin = 0 ; bestcount = si -> si_intpins [ 0 ] . ii_count ; for ( pin = 1 ; pin < 4 ; pin ++ ) { if ( si -> si_intpins [ pin ] . ii_count < bestcount ) { bestpin = pin ; bestcount = si -> si_intpins [ pin ] . ii_count ; } } si -> si_intpins [ bestpin ] . ii_count ++ ; dev -> lintr . pin = bestpin + 1 ; pci_set_cfgdata8 ( dev , PCIR_INTPIN , bestpin + 1 ) ; }
","<S2SV_ModStart> bus ] ; if ( bi == NULL ) { pr_err ( ""%s:<S2SV_blank>pci<S2SV_blank>[%s]<S2SV_blank>has<S2SV_blank>wrong<S2SV_blank>bus<S2SV_blank>%d<S2SV_blank>info!\\n"" , __func__ , dev -> name , dev -> bus ) ; return ; } <S2SV_ModEnd> si = &
"
239,"CWE-134 static void zend_throw_or_error ( int fetch_type , zend_class_entry * exception_ce , const char * format , ... ) { va_list va ; char * message = NULL ; va_start ( va , format ) ; zend_vspprintf ( & message , 0 , format , va ) ; if ( fetch_type & ZEND_FETCH_CLASS_EXCEPTION ) { <S2SV_StartBug> zend_throw_error ( exception_ce , message ) ; <S2SV_EndBug> } else { zend_error ( E_ERROR , ""%s"" , message ) ; } efree ( message ) ; va_end ( va ) ; }
","<S2SV_ModStart> ( exception_ce , ""%s"" ,
"
240,"CWE-835 static Image * ReadBMPImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { BMPInfo bmp_info ; Image * image ; MagickBooleanType status ; MagickOffsetType offset , start_position ; MemoryInfo * pixel_info ; Quantum index ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bit , bytes_per_line , length ; ssize_t count , y ; unsigned char magick [ 12 ] , * pixels ; unsigned int blue , green , offset_bits , red ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) memset ( & bmp_info , 0 , sizeof ( bmp_info ) ) ; bmp_info . ba_offset = 0 ; start_position = 0 ; offset_bits = 0 ; count = ReadBlob ( image , 2 , magick ) ; if ( count != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { PixelInfo quantum_bits ; PixelPacket shift ; start_position = TellBlob ( image ) - 2 ; bmp_info . ba_offset = 0 ; while ( LocaleNCompare ( ( char * ) magick , ""BA"" , 2 ) == 0 ) { bmp_info . file_size = ReadBlobLSBLong ( image ) ; bmp_info . ba_offset = ReadBlobLSBLong ( image ) ; bmp_info . offset_bits = ReadBlobLSBLong ( image ) ; count = ReadBlob ( image , 2 , magick ) ; if ( count != 2 ) break ; } if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Magick:<S2SV_blank>%c%c"" , magick [ 0 ] , magick [ 1 ] ) ; if ( ( count != 2 ) || ( ( LocaleNCompare ( ( char * ) magick , ""BM"" , 2 ) != 0 ) && ( LocaleNCompare ( ( char * ) magick , ""CI"" , 2 ) != 0 ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; bmp_info . file_size = ReadBlobLSBLong ( image ) ; ( void ) ReadBlobLSBLong ( image ) ; bmp_info . offset_bits = ReadBlobLSBLong ( image ) ; bmp_info . size = ReadBlobLSBLong ( image ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>BMP<S2SV_blank>size:<S2SV_blank>%u"" , bmp_info . size ) ; if ( bmp_info . size == 12 ) { ( void ) CopyMagickString ( image -> magick , ""BMP2"" , MagickPathExtent ) ; bmp_info . width = ( ssize_t ) ( ( short ) ReadBlobLSBShort ( image ) ) ; bmp_info . height = ( ssize_t ) ( ( short ) ReadBlobLSBShort ( image ) ) ; bmp_info . planes = ReadBlobLSBShort ( image ) ; bmp_info . bits_per_pixel = ReadBlobLSBShort ( image ) ; bmp_info . x_pixels = 0 ; bmp_info . y_pixels = 0 ; bmp_info . number_colors = 0 ; bmp_info . compression = BI_RGB ; bmp_info . image_size = 0 ; bmp_info . alpha_mask = 0 ; if ( image -> debug != MagickFalse ) { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Format:<S2SV_blank>OS/2<S2SV_blank>Bitmap"" ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Geometry:<S2SV_blank>%.20gx%.20g"" , ( double ) bmp_info . width , ( double ) bmp_info . height ) ; } } else { if ( bmp_info . size < 40 ) ThrowReaderException ( CorruptImageError , ""NonOS2HeaderSizeError"" ) ; bmp_info . width = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; bmp_info . height = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; bmp_info . planes = ReadBlobLSBShort ( image ) ; bmp_info . bits_per_pixel = ReadBlobLSBShort ( image ) ; bmp_info . compression = ReadBlobLSBLong ( image ) ; bmp_info . image_size = ReadBlobLSBLong ( image ) ; bmp_info . x_pixels = ReadBlobLSBLong ( image ) ; bmp_info . y_pixels = ReadBlobLSBLong ( image ) ; bmp_info . number_colors = ReadBlobLSBLong ( image ) ; <S2SV_StartBug> if ( bmp_info . number_colors > GetBlobSize ( image ) ) <S2SV_EndBug> ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; bmp_info . colors_important = ReadBlobLSBLong ( image ) ; if ( image -> debug != MagickFalse ) { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Format:<S2SV_blank>MS<S2SV_blank>Windows<S2SV_blank>bitmap"" ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Geometry:<S2SV_blank>%.20gx%.20g"" , ( double ) bmp_info . width , ( double ) bmp_info . height ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Bits<S2SV_blank>per<S2SV_blank>pixel:<S2SV_blank>%.20g"" , ( double ) bmp_info . bits_per_pixel ) ; switch ( bmp_info . compression ) { case BI_RGB : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RGB"" ) ; break ; } case BI_RLE4 : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RLE4"" ) ; break ; } case BI_RLE8 : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RLE8"" ) ; break ; } case BI_BITFIELDS : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_BITFIELDS"" ) ; break ; } case BI_PNG : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_PNG"" ) ; break ; } case BI_JPEG : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_JPEG"" ) ; break ; } default : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>UNKNOWN<S2SV_blank>(%u)"" , bmp_info . compression ) ; } } ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Number<S2SV_blank>of<S2SV_blank>colors:<S2SV_blank>%u"" , bmp_info . number_colors ) ; } bmp_info . red_mask = ReadBlobLSBLong ( image ) ; bmp_info . green_mask = ReadBlobLSBLong ( image ) ; bmp_info . blue_mask = ReadBlobLSBLong ( image ) ; if ( bmp_info . size > 40 ) { double gamma ; bmp_info . alpha_mask = ReadBlobLSBLong ( image ) ; bmp_info . colorspace = ReadBlobLSBSignedLong ( image ) ; # define BMP_DENOM ( ( double ) 0x40000000 ) bmp_info . red_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . red_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . red_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . green_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . green_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . green_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . blue_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . blue_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . blue_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; gamma = bmp_info . red_primary . x + bmp_info . red_primary . y + bmp_info . red_primary . z ; gamma = PerceptibleReciprocal ( gamma ) ; bmp_info . red_primary . x *= gamma ; bmp_info . red_primary . y *= gamma ; image -> chromaticity . red_primary . x = bmp_info . red_primary . x ; image -> chromaticity . red_primary . y = bmp_info . red_primary . y ; gamma = bmp_info . green_primary . x + bmp_info . green_primary . y + bmp_info . green_primary . z ; gamma = PerceptibleReciprocal ( gamma ) ; bmp_info . green_primary . x *= gamma ; bmp_info . green_primary . y *= gamma ; image -> chromaticity . green_primary . x = bmp_info . green_primary . x ; image -> chromaticity . green_primary . y = bmp_info . green_primary . y ; gamma = bmp_info . blue_primary . x + bmp_info . blue_primary . y + bmp_info . blue_primary . z ; gamma = PerceptibleReciprocal ( gamma ) ; bmp_info . blue_primary . x *= gamma ; bmp_info . blue_primary . y *= gamma ; image -> chromaticity . blue_primary . x = bmp_info . blue_primary . x ; image -> chromaticity . blue_primary . y = bmp_info . blue_primary . y ; bmp_info . gamma_scale . x = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; bmp_info . gamma_scale . y = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; bmp_info . gamma_scale . z = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; image -> gamma = ( bmp_info . gamma_scale . x + bmp_info . gamma_scale . y + bmp_info . gamma_scale . z ) / 3.0 ; } else ( void ) CopyMagickString ( image -> magick , ""BMP3"" , MagickPathExtent ) ; if ( bmp_info . size > 108 ) { size_t intent ; intent = ReadBlobLSBLong ( image ) ; switch ( ( int ) intent ) { case LCS_GM_BUSINESS : { image -> rendering_intent = SaturationIntent ; break ; } case LCS_GM_GRAPHICS : { image -> rendering_intent = RelativeIntent ; break ; } case LCS_GM_IMAGES : { image -> rendering_intent = PerceptualIntent ; break ; } case LCS_GM_ABS_COLORIMETRIC : { image -> rendering_intent = AbsoluteIntent ; break ; } } ( void ) ReadBlobLSBLong ( image ) ; ( void ) ReadBlobLSBLong ( image ) ; ( void ) ReadBlobLSBLong ( image ) ; } } if ( ( MagickSizeType ) bmp_info . file_size > GetBlobSize ( image ) ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageError , ""LengthAndFilesizeDoNotMatch"" , ""`%s\'"" , image -> filename ) ; else if ( ( MagickSizeType ) bmp_info . file_size < GetBlobSize ( image ) ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageWarning , ""LengthAndFilesizeDoNotMatch"" , ""`%s\'"" , image -> filename ) ; if ( bmp_info . width <= 0 ) ThrowReaderException ( CorruptImageError , ""NegativeOrZeroImageSize"" ) ; if ( bmp_info . height == 0 ) ThrowReaderException ( CorruptImageError , ""NegativeOrZeroImageSize"" ) ; if ( bmp_info . planes != 1 ) ThrowReaderException ( CorruptImageError , ""StaticPlanesValueNotEqualToOne"" ) ; if ( ( bmp_info . bits_per_pixel != 1 ) && ( bmp_info . bits_per_pixel != 4 ) && ( bmp_info . bits_per_pixel != 8 ) && ( bmp_info . bits_per_pixel != 16 ) && ( bmp_info . bits_per_pixel != 24 ) && ( bmp_info . bits_per_pixel != 32 ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedBitsPerPixel"" ) ; if ( bmp_info . bits_per_pixel < 16 && bmp_info . number_colors > ( 1U << bmp_info . bits_per_pixel ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedNumberOfColors"" ) ; if ( ( bmp_info . compression == 1 ) && ( bmp_info . bits_per_pixel != 8 ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedBitsPerPixel"" ) ; if ( ( bmp_info . compression == 2 ) && ( bmp_info . bits_per_pixel != 4 ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedBitsPerPixel"" ) ; if ( ( bmp_info . compression == 3 ) && ( bmp_info . bits_per_pixel < 16 ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedBitsPerPixel"" ) ; switch ( bmp_info . compression ) { case BI_RGB : image -> compression = NoCompression ; break ; case BI_RLE8 : case BI_RLE4 : image -> compression = RLECompression ; break ; case BI_BITFIELDS : break ; case BI_JPEG : ThrowReaderException ( CoderError , ""JPEGCompressNotSupported"" ) ; case BI_PNG : ThrowReaderException ( CoderError , ""PNGCompressNotSupported"" ) ; default : ThrowReaderException ( CorruptImageError , ""UnrecognizedImageCompression"" ) ; } image -> columns = ( size_t ) MagickAbsoluteValue ( bmp_info . width ) ; image -> rows = ( size_t ) MagickAbsoluteValue ( bmp_info . height ) ; image -> depth = bmp_info . bits_per_pixel <= 8 ? bmp_info . bits_per_pixel : 8 ; image -> alpha_trait = ( ( bmp_info . alpha_mask != 0 ) && ( bmp_info . compression == BI_BITFIELDS ) ) ? BlendPixelTrait : UndefinedPixelTrait ; if ( bmp_info . bits_per_pixel < 16 ) { size_t one ; image -> storage_class = PseudoClass ; image -> colors = bmp_info . number_colors ; one = 1 ; if ( image -> colors == 0 ) image -> colors = one << bmp_info . bits_per_pixel ; } image -> resolution . x = ( double ) bmp_info . x_pixels / 100.0 ; image -> resolution . y = ( double ) bmp_info . y_pixels / 100.0 ; image -> units = PixelsPerCentimeterResolution ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( image -> storage_class == PseudoClass ) { unsigned char * bmp_colormap ; size_t packet_size ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Reading<S2SV_blank>colormap<S2SV_blank>of<S2SV_blank>%.20g<S2SV_blank>colors"" , ( double ) image -> colors ) ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; bmp_colormap = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) image -> colors , 4 * sizeof ( * bmp_colormap ) ) ; if ( bmp_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( ( bmp_info . size == 12 ) || ( bmp_info . size == 64 ) ) packet_size = 3 ; else packet_size = 4 ; offset = SeekBlob ( image , start_position + 14 + bmp_info . size , SEEK_SET ) ; if ( offset < 0 ) { bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ; ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } count = ReadBlob ( image , packet_size * image -> colors , bmp_colormap ) ; if ( count != ( ssize_t ) ( packet_size * image -> colors ) ) { bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ; ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } p = bmp_colormap ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ; if ( packet_size == 4 ) p ++ ; } bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ; } if ( bmp_info . offset_bits == offset_bits ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; offset_bits = bmp_info . offset_bits ; offset = SeekBlob ( image , start_position + bmp_info . offset_bits , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( bmp_info . compression == BI_RLE4 ) bmp_info . bits_per_pixel <<= 1 ; bytes_per_line = 4 * ( ( image -> columns * bmp_info . bits_per_pixel + 31 ) / 32 ) ; length = ( size_t ) bytes_per_line * image -> rows ; if ( ( bmp_info . compression == BI_RGB ) || ( bmp_info . compression == BI_BITFIELDS ) ) { if ( ( MagickSizeType ) length > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; pixel_info = AcquireVirtualMemory ( image -> rows , MagickMax ( bytes_per_line , image -> columns + 256UL ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Reading<S2SV_blank>pixels<S2SV_blank>(%.20g<S2SV_blank>bytes)"" , ( double ) length ) ; count = ReadBlob ( image , length , pixels ) ; if ( count != ( ssize_t ) length ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } } else { pixel_info = AcquireVirtualMemory ( image -> rows , MagickMax ( bytes_per_line , image -> columns + 256UL ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; status = DecodeImage ( image , bmp_info . compression , pixels , image -> columns * image -> rows ) ; if ( status == MagickFalse ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToRunlengthDecodeImage"" ) ; } } if ( bmp_info . compression == BI_RGB ) { if ( ( image -> alpha_trait == UndefinedPixelTrait ) && ( bmp_info . size == 40 ) && ( bmp_info . bits_per_pixel == 32 ) ) { bytes_per_line = 4 * ( image -> columns ) ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( * ( p + 3 ) != 0 ) { image -> alpha_trait = BlendPixelTrait ; y = - 1 ; break ; } p += 4 ; } } } bmp_info . alpha_mask = image -> alpha_trait != UndefinedPixelTrait ? 0xff000000U : 0U ; bmp_info . red_mask = 0x00ff0000U ; bmp_info . green_mask = 0x0000ff00U ; bmp_info . blue_mask = 0x000000ffU ; if ( bmp_info . bits_per_pixel == 16 ) { bmp_info . red_mask = 0x00007c00U ; bmp_info . green_mask = 0x000003e0U ; bmp_info . blue_mask = 0x0000001fU ; } } ( void ) memset ( & shift , 0 , sizeof ( shift ) ) ; ( void ) memset ( & quantum_bits , 0 , sizeof ( quantum_bits ) ) ; if ( ( bmp_info . bits_per_pixel == 16 ) || ( bmp_info . bits_per_pixel == 32 ) ) { register unsigned int sample ; if ( bmp_info . red_mask != 0 ) while ( ( ( bmp_info . red_mask << shift . red ) & 0x80000000UL ) == 0 ) { shift . red ++ ; if ( shift . red >= 32U ) break ; } if ( bmp_info . green_mask != 0 ) while ( ( ( bmp_info . green_mask << shift . green ) & 0x80000000UL ) == 0 ) { shift . green ++ ; if ( shift . green >= 32U ) break ; } if ( bmp_info . blue_mask != 0 ) while ( ( ( bmp_info . blue_mask << shift . blue ) & 0x80000000UL ) == 0 ) { shift . blue ++ ; if ( shift . blue >= 32U ) break ; } if ( bmp_info . alpha_mask != 0 ) while ( ( ( bmp_info . alpha_mask << shift . alpha ) & 0x80000000UL ) == 0 ) { shift . alpha ++ ; if ( shift . alpha >= 32U ) break ; } sample = shift . red ; while ( ( ( bmp_info . red_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . red = ( MagickRealType ) ( sample - shift . red ) ; sample = shift . green ; while ( ( ( bmp_info . green_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . green = ( MagickRealType ) ( sample - shift . green ) ; sample = shift . blue ; while ( ( ( bmp_info . blue_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . blue = ( MagickRealType ) ( sample - shift . blue ) ; sample = shift . alpha ; while ( ( ( bmp_info . alpha_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . alpha = ( MagickRealType ) ( sample - shift . alpha ) ; } switch ( bmp_info . bits_per_pixel ) { case 1 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { index = ( Quantum ) ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ? 0x01 : 0x00 ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( image -> columns % 8 ) ; bit ++ ) { index = ( Quantum ) ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ? 0x01 : 0x00 ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; break ; } case 4 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { ValidateColormapValue ( image , ( ssize_t ) ( ( * p >> 4 ) & 0x0f ) , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; ValidateColormapValue ( image , ( ssize_t ) ( * p & 0x0f ) , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; } if ( ( image -> columns % 2 ) != 0 ) { ValidateColormapValue ( image , ( ssize_t ) ( ( * p >> 4 ) & 0xf ) , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; x ++ ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; break ; } case 8 : { if ( ( bmp_info . compression == BI_RLE8 ) || ( bmp_info . compression == BI_RLE4 ) ) bytes_per_line = image -> columns ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = ( ssize_t ) image -> columns ; x != 0 ; -- x ) { ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; break ; } case 16 : { unsigned int alpha , pixel ; if ( ( bmp_info . compression != BI_RGB ) && ( bmp_info . compression != BI_BITFIELDS ) ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnrecognizedImageCompression"" ) ; } bytes_per_line = 2 * ( image -> columns + image -> columns % 2 ) ; image -> storage_class = DirectClass ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { pixel = ( unsigned int ) ( * p ++ ) ; pixel |= ( * p ++ ) << 8 ; red = ( ( pixel & bmp_info . red_mask ) << shift . red ) >> 16 ; if ( quantum_bits . red == 5 ) red |= ( ( red & 0xe000 ) >> 5 ) ; if ( quantum_bits . red <= 8 ) red |= ( ( red & 0xff00 ) >> 8 ) ; green = ( ( pixel & bmp_info . green_mask ) << shift . green ) >> 16 ; if ( quantum_bits . green == 5 ) green |= ( ( green & 0xe000 ) >> 5 ) ; if ( quantum_bits . green == 6 ) green |= ( ( green & 0xc000 ) >> 6 ) ; if ( quantum_bits . green <= 8 ) green |= ( ( green & 0xff00 ) >> 8 ) ; blue = ( ( pixel & bmp_info . blue_mask ) << shift . blue ) >> 16 ; if ( quantum_bits . blue == 5 ) blue |= ( ( blue & 0xe000 ) >> 5 ) ; if ( quantum_bits . blue <= 8 ) blue |= ( ( blue & 0xff00 ) >> 8 ) ; SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) red ) , q ) ; SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) green ) , q ) ; SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) blue ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) { alpha = ( ( pixel & bmp_info . alpha_mask ) << shift . alpha ) >> 16 ; if ( quantum_bits . alpha <= 8 ) alpha |= ( ( alpha & 0xff00 ) >> 8 ) ; SetPixelAlpha ( image , ScaleShortToQuantum ( ( unsigned short ) alpha ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 24 : { bytes_per_line = 4 * ( ( image -> columns * 24 + 31 ) / 32 ) ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 32 : { if ( ( bmp_info . compression != BI_RGB ) && ( bmp_info . compression != BI_BITFIELDS ) ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnrecognizedImageCompression"" ) ; } bytes_per_line = 4 * ( image -> columns ) ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { unsigned int alpha , pixel ; p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { pixel = ( unsigned int ) ( * p ++ ) ; pixel |= ( ( unsigned int ) * p ++ << 8 ) ; pixel |= ( ( unsigned int ) * p ++ << 16 ) ; pixel |= ( ( unsigned int ) * p ++ << 24 ) ; red = ( ( pixel & bmp_info . red_mask ) << shift . red ) >> 16 ; if ( quantum_bits . red == 8 ) red |= ( red >> 8 ) ; green = ( ( pixel & bmp_info . green_mask ) << shift . green ) >> 16 ; if ( quantum_bits . green == 8 ) green |= ( green >> 8 ) ; blue = ( ( pixel & bmp_info . blue_mask ) << shift . blue ) >> 16 ; if ( quantum_bits . blue == 8 ) blue |= ( blue >> 8 ) ; SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) red ) , q ) ; SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) green ) , q ) ; SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) blue ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) { alpha = ( ( pixel & bmp_info . alpha_mask ) << shift . alpha ) >> 16 ; if ( quantum_bits . alpha == 8 ) alpha |= ( alpha >> 8 ) ; SetPixelAlpha ( image , ScaleShortToQuantum ( ( unsigned short ) alpha ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } default : { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } } pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( y > 0 ) break ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( bmp_info . height < 0 ) { Image * flipped_image ; flipped_image = FlipImage ( image , exception ) ; if ( flipped_image != ( Image * ) NULL ) { DuplicateBlob ( flipped_image , image ) ; ReplaceImageInList ( & image , flipped_image ) ; image = flipped_image ; } } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; <S2SV_StartBug> * magick = '\\0' ; <S2SV_EndBug> <S2SV_StartBug> if ( bmp_info . ba_offset != 0 ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> offset = SeekBlob ( image , ( MagickOffsetType ) bmp_info . ba_offset , SEEK_SET ) ; <S2SV_StartBug> if ( offset < 0 ) <S2SV_EndBug> ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; <S2SV_StartBug> } <S2SV_EndBug> count = ReadBlob ( image , 2 , magick ) ; if ( ( count == 2 ) && ( IsBMP ( magick , 2 ) != MagickFalse ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( IsBMP ( magick , 2 ) != MagickFalse ) ; ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> ; if ( ( MagickSizeType ) <S2SV_ModStart> ) break ; offset = ( MagickOffsetType ) <S2SV_ModEnd> bmp_info . ba_offset <S2SV_ModStart> bmp_info . ba_offset ; if ( offset <S2SV_ModStart> != 0 ) if ( <S2SV_ModEnd> ( offset < <S2SV_ModStart> ( offset < TellBlob ( image ) ) || ( SeekBlob ( image , offset , SEEK_SET ) != offset ) <S2SV_ModEnd> ) ThrowReaderException ( <S2SV_ModStart> ""ImproperImageHeader"" ) ; * magick = '\\0' ; <S2SV_ModEnd> count = ReadBlob
"
241,"CWE-200 static int l2tp_ip6_getname ( struct socket * sock , struct sockaddr * uaddr , int * uaddr_len , int peer ) { struct sockaddr_l2tpip6 * lsa = ( struct sockaddr_l2tpip6 * ) uaddr ; struct sock * sk = sock -> sk ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct l2tp_ip6_sock * lsk = l2tp_ip6_sk ( sk ) ; lsa -> l2tp_family = AF_INET6 ; lsa -> l2tp_flowinfo = 0 ; lsa -> l2tp_scope_id = 0 ; <S2SV_StartBug> if ( peer ) { <S2SV_EndBug> if ( ! lsk -> peer_conn_id ) return - ENOTCONN ; lsa -> l2tp_conn_id = lsk -> peer_conn_id ; lsa -> l2tp_addr = np -> daddr ; if ( np -> sndflow ) lsa -> l2tp_flowinfo = np -> flow_label ; } else { if ( ipv6_addr_any ( & np -> rcv_saddr ) ) lsa -> l2tp_addr = np -> saddr ; else lsa -> l2tp_addr = np -> rcv_saddr ; lsa -> l2tp_conn_id = lsk -> conn_id ; } if ( ipv6_addr_type ( & lsa -> l2tp_addr ) & IPV6_ADDR_LINKLOCAL ) lsa -> l2tp_scope_id = sk -> sk_bound_dev_if ; * uaddr_len = sizeof ( * lsa ) ; return 0 ; }
","<S2SV_ModStart> = 0 ; lsa -> l2tp_unused = 0 ;
"
242,"CWE-119 static int psf_close ( SF_PRIVATE * psf ) { uint32_t k ; int error = 0 ; if ( psf -> codec_close ) { error = psf -> codec_close ( psf ) ; psf -> codec_close = NULL ; } ; if ( psf -> container_close ) error = psf -> container_close ( psf ) ; error = psf_fclose ( psf ) ; <S2SV_StartBug> psf_close_rsrc ( psf ) ; <S2SV_EndBug> free ( psf -> container_data ) ; free ( psf -> codec_data ) ; free ( psf -> interleave ) ; free ( psf -> dither ) ; free ( psf -> peak_info ) ; free ( psf -> broadcast_16k ) ; free ( psf -> loop_info ) ; free ( psf -> instrument ) ; free ( psf -> cues ) ; free ( psf -> channel_map ) ; free ( psf -> format_desc ) ; free ( psf -> strings . storage ) ; if ( psf -> wchunks . chunks ) for ( k = 0 ; k < psf -> wchunks . used ; k ++ ) free ( psf -> wchunks . chunks [ k ] . data ) ; free ( psf -> rchunks . chunks ) ; free ( psf -> wchunks . chunks ) ; free ( psf -> iterator ) ; free ( psf -> cart_16k ) ; memset ( psf , 0 , sizeof ( SF_PRIVATE ) ) ; free ( psf ) ; return error ; }
","<S2SV_ModStart> psf_close_rsrc ( psf ) ; free ( psf -> header . ptr
"
243,"CWE-000 int sas_ex_revalidate_domain ( struct domain_device * port_dev ) { int res ; struct domain_device * dev = NULL ; res = sas_find_bcast_dev ( port_dev , & dev ) ; <S2SV_StartBug> while ( res == 0 && dev ) { <S2SV_EndBug> struct expander_device * ex = & dev -> ex_dev ; int i = 0 , phy_id ; do { phy_id = - 1 ; res = sas_find_bcast_phy ( dev , & phy_id , i , true ) ; if ( phy_id == - 1 ) break ; res = sas_rediscover ( dev , phy_id ) ; i = phy_id + 1 ; } while ( i < ex -> num_phys ) ; <S2SV_StartBug> dev = NULL ; <S2SV_EndBug> res = sas_find_bcast_dev ( port_dev , & dev ) ; } return res ; }
","<S2SV_ModStart> dev ) ; if <S2SV_ModEnd> ( res == <S2SV_ModStart> num_phys ) ; <S2SV_ModEnd> } return res
"
244,"CWE-125 static void set_fdc ( int drive ) <S2SV_StartBug> { <S2SV_EndBug> if ( drive >= 0 && drive < N_DRIVE ) { <S2SV_StartBug> fdc = FDC ( drive ) ; <S2SV_EndBug> current_drive = drive ; } <S2SV_StartBug> if ( fdc != 1 && fdc != 0 ) { <S2SV_EndBug> pr_info ( ""bad<S2SV_blank>fdc<S2SV_blank>value\\n"" ) ; return ; <S2SV_StartBug> } <S2SV_EndBug> set_dor ( fdc , ~ 0 , 8 ) ; # if N_FDC > 1 set_dor ( 1 - fdc , ~ 8 , 0 ) ; # endif if ( FDCS -> rawcmd == 2 ) reset_fdc_info ( 1 ) ; if ( fd_inb ( FD_STATUS ) != STATUS_READY ) FDCS -> reset = 1 ; }
","<S2SV_ModStart> drive ) { unsigned int new_fdc = fdc ; <S2SV_ModStart> N_DRIVE ) { new_fdc <S2SV_ModEnd> = FDC ( <S2SV_ModStart> } if ( new_fdc >= N_FDC <S2SV_ModEnd> ) { pr_info <S2SV_ModStart> return ; } fdc = new_fdc ;
"
245,"CWE-416 static void timerfd_remove_cancel ( struct timerfd_ctx * ctx ) { <S2SV_StartBug> if ( ctx -> might_cancel ) { <S2SV_EndBug> ctx -> might_cancel = false ; <S2SV_StartBug> spin_lock ( & cancel_lock ) ; <S2SV_EndBug> <S2SV_StartBug> list_del_rcu ( & ctx -> clist ) ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock ( & cancel_lock ) ; <S2SV_EndBug> } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> ctx ) { <S2SV_ModEnd> spin_lock ( & <S2SV_ModStart> spin_lock ( & ctx -> <S2SV_ModStart> cancel_lock ) ; __timerfd_remove_cancel ( ctx <S2SV_ModEnd> ) ; spin_unlock <S2SV_ModStart> spin_unlock ( & ctx -> <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
"
246,"CWE-125 static stmt_ty ast_for_async_funcdef ( struct compiling * c , const node * n , asdl_seq * decorator_seq ) { REQ ( n , async_funcdef ) ; <S2SV_StartBug> REQ ( CHILD ( n , 0 ) , ASYNC ) ; <S2SV_EndBug> REQ ( CHILD ( n , 1 ) , funcdef ) ; <S2SV_StartBug> return ast_for_funcdef_impl ( c , CHILD ( n , 1 ) , decorator_seq , <S2SV_EndBug> <S2SV_StartBug> 1 ) ; <S2SV_EndBug> }
","<S2SV_ModStart> 0 ) , NAME ) ; assert ( strcmp ( STR ( CHILD ( n , 0 ) ) , ""async"" ) == 0 <S2SV_ModEnd> ) ; REQ <S2SV_ModStart> ( c , n <S2SV_ModEnd> , decorator_seq , <S2SV_ModStart> , decorator_seq , true <S2SV_ModEnd> ) ; }
"
247,"CWE-119 int ssh_packet_get_state ( struct ssh * ssh , struct sshbuf * m ) { struct session_state * state = ssh -> state ; u_char * p ; size_t slen , rlen ; int r , ssh1cipher ; if ( ! compat20 ) { ssh1cipher = cipher_ctx_get_number ( state -> receive_context ) ; slen = cipher_get_keyiv_len ( state -> send_context ) ; rlen = cipher_get_keyiv_len ( state -> receive_context ) ; if ( ( r = sshbuf_put_u32 ( m , state -> remote_protocol_flags ) ) != 0 || ( r = sshbuf_put_u32 ( m , ssh1cipher ) ) != 0 || ( r = sshbuf_put_string ( m , state -> ssh1_key , state -> ssh1_keylen ) ) != 0 || ( r = sshbuf_put_u32 ( m , slen ) ) != 0 || ( r = sshbuf_reserve ( m , slen , & p ) ) != 0 || ( r = cipher_get_keyiv ( state -> send_context , p , slen ) ) != 0 || ( r = sshbuf_put_u32 ( m , rlen ) ) != 0 || ( r = sshbuf_reserve ( m , rlen , & p ) ) != 0 || ( r = cipher_get_keyiv ( state -> receive_context , p , rlen ) ) != 0 ) return r ; } else { if ( ( r = kex_to_blob ( m , ssh -> kex ) ) != 0 || ( r = newkeys_to_blob ( m , ssh , MODE_OUT ) ) != 0 || ( r = newkeys_to_blob ( m , ssh , MODE_IN ) ) != 0 || ( r = sshbuf_put_u64 ( m , state -> rekey_limit ) ) != 0 || ( r = sshbuf_put_u32 ( m , state -> rekey_interval ) ) != 0 || ( r = sshbuf_put_u32 ( m , state -> p_send . seqnr ) ) != 0 || ( r = sshbuf_put_u64 ( m , state -> p_send . blocks ) ) != 0 || ( r = sshbuf_put_u32 ( m , state -> p_send . packets ) ) != 0 || ( r = sshbuf_put_u64 ( m , state -> p_send . bytes ) ) != 0 || ( r = sshbuf_put_u32 ( m , state -> p_read . seqnr ) ) != 0 || ( r = sshbuf_put_u64 ( m , state -> p_read . blocks ) ) != 0 || ( r = sshbuf_put_u32 ( m , state -> p_read . packets ) ) != 0 || ( r = sshbuf_put_u64 ( m , state -> p_read . bytes ) ) != 0 ) return r ; } slen = cipher_get_keycontext ( state -> send_context , NULL ) ; rlen = cipher_get_keycontext ( state -> receive_context , NULL ) ; if ( ( r = sshbuf_put_u32 ( m , slen ) ) != 0 || ( r = sshbuf_reserve ( m , slen , & p ) ) != 0 ) return r ; if ( cipher_get_keycontext ( state -> send_context , p ) != ( int ) slen ) return SSH_ERR_INTERNAL_ERROR ; if ( ( r = sshbuf_put_u32 ( m , rlen ) ) != 0 || ( r = sshbuf_reserve ( m , rlen , & p ) ) != 0 ) return r ; if ( cipher_get_keycontext ( state -> receive_context , p ) != ( int ) rlen ) return SSH_ERR_INTERNAL_ERROR ; <S2SV_StartBug> if ( ( r = ssh_packet_get_compress_state ( m , ssh ) ) != 0 || <S2SV_EndBug> ( r = sshbuf_put_stringb ( m , state -> input ) ) != 0 || ( r = sshbuf_put_stringb ( m , state -> output ) ) != 0 ) return r ; return 0 ; }
","<S2SV_ModStart> ( r = <S2SV_ModEnd> sshbuf_put_stringb ( m
"
248,"CWE-125 u_int null_if_print ( netdissect_options * ndo , const struct pcap_pkthdr * h , const u_char * p ) { u_int length = h -> len ; u_int caplen = h -> caplen ; u_int family ; if ( caplen < NULL_HDRLEN ) { ND_PRINT ( ( ndo , ""[|null]"" ) ) ; return ( NULL_HDRLEN ) ; } memcpy ( ( char * ) & family , ( const char * ) p , sizeof ( family ) ) ; if ( ( family & 0xFFFF0000 ) != 0 ) family = SWAPLONG ( family ) ; if ( ndo -> ndo_eflag ) null_hdr_print ( ndo , family , length ) ; length -= NULL_HDRLEN ; caplen -= NULL_HDRLEN ; p += NULL_HDRLEN ; switch ( family ) { case BSD_AFNUM_INET : ip_print ( ndo , p , length ) ; break ; case BSD_AFNUM_INET6_BSD : case BSD_AFNUM_INET6_FREEBSD : case BSD_AFNUM_INET6_DARWIN : ip6_print ( ndo , p , length ) ; break ; case BSD_AFNUM_ISO : <S2SV_StartBug> isoclns_print ( ndo , p , length , caplen ) ; <S2SV_EndBug> break ; case BSD_AFNUM_APPLETALK : atalk_print ( ndo , p , length ) ; break ; case BSD_AFNUM_IPX : ipx_print ( ndo , p , length ) ; break ; default : if ( ! ndo -> ndo_eflag ) null_hdr_print ( ndo , family , length + NULL_HDRLEN ) ; if ( ! ndo -> ndo_suppress_default_print ) ND_DEFAULTPRINT ( p , caplen ) ; } return ( NULL_HDRLEN ) ; }
","<S2SV_ModStart> p , length <S2SV_ModEnd> ) ; break
"
249,"CWE-125 static Sdb * store_versioninfo_gnu_verdef ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { const char * section_name = """" ; const char * link_section_name = """" ; char * end = NULL ; Elf_ ( Shdr ) * link_shdr = NULL ; ut8 dfs [ sizeof ( Elf_ ( Verdef ) ) ] = { 0 } ; Sdb * sdb ; int cnt , i ; if ( shdr -> sh_link > bin -> ehdr . e_shnum ) { return false ; } link_shdr = & bin -> shdr [ shdr -> sh_link ] ; if ( shdr -> sh_size < 1 ) { return false ; } Elf_ ( Verdef ) * defs = calloc ( shdr -> sh_size , sizeof ( char ) ) ; if ( ! defs ) { return false ; } if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) { section_name = & bin -> shstrtab [ shdr -> sh_name ] ; } if ( link_shdr && bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) { link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ; } if ( ! defs ) { bprintf ( ""Warning:<S2SV_blank>Cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>(Check<S2SV_blank>Elf_(Verdef))\\n"" ) ; return NULL ; } sdb = sdb_new0 ( ) ; end = ( char * ) defs + shdr -> sh_size ; sdb_set ( sdb , ""section_name"" , section_name , 0 ) ; sdb_num_set ( sdb , ""entries"" , shdr -> sh_info , 0 ) ; sdb_num_set ( sdb , ""addr"" , shdr -> sh_addr , 0 ) ; sdb_num_set ( sdb , ""offset"" , shdr -> sh_offset , 0 ) ; sdb_num_set ( sdb , ""link"" , shdr -> sh_link , 0 ) ; sdb_set ( sdb , ""link_section_name"" , link_section_name , 0 ) ; for ( cnt = 0 , i = 0 ; i >= 0 && cnt < shdr -> sh_info && ( ( char * ) defs + i < end ) ; ++ cnt ) { Sdb * sdb_verdef = sdb_new0 ( ) ; char * vstart = ( ( char * ) defs ) + i ; char key [ 32 ] = { 0 } ; Elf_ ( Verdef ) * verdef = ( Elf_ ( Verdef ) * ) vstart ; Elf_ ( Verdaux ) aux = { 0 } ; int j = 0 ; int isum = 0 ; r_buf_read_at ( bin -> b , shdr -> sh_offset + i , dfs , sizeof ( Elf_ ( Verdef ) ) ) ; verdef -> vd_version = READ16 ( dfs , j ) verdef -> vd_flags = READ16 ( dfs , j ) verdef -> vd_ndx = READ16 ( dfs , j ) verdef -> vd_cnt = READ16 ( dfs , j ) verdef -> vd_hash = READ32 ( dfs , j ) verdef -> vd_aux = READ32 ( dfs , j ) verdef -> vd_next = READ32 ( dfs , j ) <S2SV_StartBug> vstart += verdef -> vd_aux ; <S2SV_EndBug> if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { sdb_free ( sdb_verdef ) ; goto out_error ; } j = 0 ; aux . vda_name = READ32 ( vstart , j ) aux . vda_next = READ32 ( vstart , j ) isum = i + verdef -> vd_aux ; if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; goto out_error ; } sdb_num_set ( sdb_verdef , ""idx"" , i , 0 ) ; sdb_num_set ( sdb_verdef , ""vd_version"" , verdef -> vd_version , 0 ) ; sdb_num_set ( sdb_verdef , ""vd_ndx"" , verdef -> vd_ndx , 0 ) ; sdb_num_set ( sdb_verdef , ""vd_cnt"" , verdef -> vd_cnt , 0 ) ; sdb_set ( sdb_verdef , ""vda_name"" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; sdb_set ( sdb_verdef , ""flags"" , get_ver_flags ( verdef -> vd_flags ) , 0 ) ; for ( j = 1 ; j < verdef -> vd_cnt ; ++ j ) { int k ; Sdb * sdb_parent = sdb_new0 ( ) ; isum += aux . vda_next ; vstart += aux . vda_next ; if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } k = 0 ; aux . vda_name = READ32 ( vstart , k ) aux . vda_next = READ32 ( vstart , k ) if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } sdb_num_set ( sdb_parent , ""idx"" , isum , 0 ) ; sdb_num_set ( sdb_parent , ""parent"" , j , 0 ) ; sdb_set ( sdb_parent , ""vda_name"" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; snprintf ( key , sizeof ( key ) , ""parent%d"" , j - 1 ) ; sdb_ns_set ( sdb_verdef , key , sdb_parent ) ; } snprintf ( key , sizeof ( key ) , ""verdef%d"" , cnt ) ; sdb_ns_set ( sdb , key , sdb_verdef ) ; if ( ! verdef -> vd_next ) { sdb_free ( sdb_verdef ) ; goto out_error ; } if ( ( st32 ) verdef -> vd_next < 1 ) { eprintf ( ""Warning:<S2SV_blank>Invalid<S2SV_blank>vd_next<S2SV_blank>in<S2SV_blank>the<S2SV_blank>ELF<S2SV_blank>version\\n"" ) ; break ; } i += verdef -> vd_next ; } free ( defs ) ; return sdb ; out_error : free ( defs ) ; sdb_free ( sdb ) ; return NULL ; }
","<S2SV_ModStart> , j ) int vdaux = verdef -> vd_aux ; if ( vdaux < 1 ) { sdb_free ( sdb_verdef ) ; goto out_error ; } vstart += vdaux <S2SV_ModEnd> ; if (
"
250,"CWE-369 void fmtutil_macbitmap_read_pixmap_only_fields ( deark * c , dbuf * f , struct fmtutil_macbitmap_info * bi , i64 pos ) { i64 pixmap_version ; i64 pack_size ; i64 plane_bytes ; i64 n ; de_dbg ( c , ""additional<S2SV_blank>PixMap<S2SV_blank>header<S2SV_blank>fields,<S2SV_blank>at<S2SV_blank>%d"" , ( int ) pos ) ; de_dbg_indent ( c , 1 ) ; pixmap_version = dbuf_getu16be ( f , pos + 0 ) ; de_dbg ( c , ""pixmap<S2SV_blank>version:<S2SV_blank>%d"" , ( int ) pixmap_version ) ; bi -> packing_type = dbuf_getu16be ( f , pos + 2 ) ; de_dbg ( c , ""packing<S2SV_blank>type:<S2SV_blank>%d"" , ( int ) bi -> packing_type ) ; pack_size = dbuf_getu32be ( f , pos + 4 ) ; de_dbg ( c , ""pixel<S2SV_blank>data<S2SV_blank>length:<S2SV_blank>%d"" , ( int ) pack_size ) ; bi -> hdpi = pict_read_fixed ( f , pos + 8 ) ; bi -> vdpi = pict_read_fixed ( f , pos + 12 ) ; de_dbg ( c , ""dpi:<S2SV_blank>%.2f"" DE_CHAR_TIMES ""%.2f"" , bi -> hdpi , bi -> vdpi ) ; bi -> pixeltype = dbuf_getu16be ( f , pos + 16 ) ; bi -> pixelsize = dbuf_getu16be ( f , pos + 18 ) ; bi -> cmpcount = dbuf_getu16be ( f , pos + 20 ) ; bi -> cmpsize = dbuf_getu16be ( f , pos + 22 ) ; de_dbg ( c , ""pixel<S2SV_blank>type=%d,<S2SV_blank>bits/pixel=%d,<S2SV_blank>components/pixel=%d,<S2SV_blank>bits/comp=%d"" , ( int ) bi -> pixeltype , ( int ) bi -> pixelsize , ( int ) bi -> cmpcount , ( int ) bi -> cmpsize ) ; <S2SV_StartBug> bi -> pdwidth = ( bi -> rowbytes * 8 ) / bi -> pixelsize ; <S2SV_EndBug> <S2SV_StartBug> if ( bi -> pdwidth < bi -> npwidth ) { <S2SV_EndBug> bi -> pdwidth = bi -> npwidth ; } plane_bytes = dbuf_getu32be ( f , pos + 24 ) ; de_dbg ( c , ""plane<S2SV_blank>bytes:<S2SV_blank>%d"" , ( int ) plane_bytes ) ; bi -> pmTable = ( u32 ) dbuf_getu32be ( f , pos + 28 ) ; de_dbg ( c , ""pmTable:<S2SV_blank>0x%08x"" , ( unsigned int ) bi -> pmTable ) ; n = dbuf_getu32be ( f , pos + 32 ) ; de_dbg ( c , ""pmReserved:<S2SV_blank>0x%08x"" , ( unsigned int ) n ) ; de_dbg_indent ( c , - 1 ) ; }
","<S2SV_ModStart> cmpsize ) ; if ( bi -> pixelsize > 0 ) { <S2SV_ModStart> -> pixelsize ; }
"
251,"CWE-20 static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; <S2SV_StartBug> DPRINTF ( 4 , ( ""enabling<S2SV_blank>filegen<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>statistics<S2SV_blank>\'%s%s\'\\n"" , <S2SV_EndBug> filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; <S2SV_StartBug> filegen_flag = filegen -> flag ; <S2SV_EndBug> filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown<S2SV_blank>filegen<S2SV_blank>flag<S2SV_blank>token<S2SV_blank>%d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown<S2SV_blank>filegen<S2SV_blank>option<S2SV_blank>token<S2SV_blank>%d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
","<S2SV_ModStart> filegen_string ) ; if ( NULL == filegen ) { msyslog ( LOG_ERR , ""stats<S2SV_blank>%s<S2SV_blank>unrecognized"" , filegen_string ) ; continue ; } <S2SV_ModStart> filegen_file ) ; if ( NULL == filegen ) { msyslog ( LOG_ERR , ""filegen<S2SV_blank>category<S2SV_blank>\'%s\'<S2SV_blank>unrecognized"" , filegen_file ) ; continue ; }
"
252,"CWE-787 static void rdpsnddbg_process ( STREAM s ) { unsigned int pkglen ; static char * rest = NULL ; <S2SV_StartBug> char * buf ; <S2SV_EndBug> pkglen = s -> end - s -> p ; buf = ( char * ) xmalloc ( pkglen + 1 ) ; STRNCPY ( buf , ( char * ) s -> p , pkglen + 1 ) ; str_handle_lines ( buf , & rest , rdpsnddbg_line_handler , NULL ) ; xfree ( buf ) ; }
","<S2SV_ModStart> * buf ; if ( ! s_check ( s ) ) { rdp_protocol_error ( ""rdpsnddbg_process(),<S2SV_blank>stream<S2SV_blank>is<S2SV_blank>in<S2SV_blank>unstable<S2SV_blank>state"" , s ) ; }
"
253,"CWE-416 static int xfrm_dump_policy ( struct sk_buff * skb , struct netlink_callback * cb ) { struct net * net = sock_net ( skb -> sk ) ; <S2SV_StartBug> struct xfrm_policy_walk * walk = ( struct xfrm_policy_walk * ) & cb -> args [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> struct xfrm_dump_info info ; <S2SV_EndBug> BUILD_BUG_ON ( sizeof ( struct xfrm_policy_walk ) > sizeof ( cb -> args ) - sizeof ( cb -> args [ 0 ] ) ) ; info . in_skb = cb -> skb ; info . out_skb = skb ; info . nlmsg_seq = cb -> nlh -> nlmsg_seq ; info . nlmsg_flags = NLM_F_MULTI ; <S2SV_StartBug> if ( ! cb -> args [ 0 ] ) { <S2SV_EndBug> cb -> args [ 0 ] = 1 ; xfrm_policy_walk_init ( walk , XFRM_POLICY_TYPE_ANY ) ; } ( void ) xfrm_policy_walk ( net , walk , dump_one_policy , & info ) ; return skb -> len ; }
","<S2SV_ModStart> xfrm_policy_walk * ) <S2SV_ModEnd> cb -> args <S2SV_ModStart> cb -> args <S2SV_ModEnd> ; struct xfrm_dump_info <S2SV_ModStart> struct xfrm_dump_info info <S2SV_ModEnd> ; info . <S2SV_ModStart> = NLM_F_MULTI ; <S2SV_ModEnd> ( void )
"
254,"CWE-264 static FILE * open_log_file ( void ) { <S2SV_StartBug> if ( log_fp ) <S2SV_EndBug> return log_fp ; log_fp = fopen ( log_file , ""a+"" ) ; if ( log_fp == NULL ) { <S2SV_StartBug> if ( daemon_mode == FALSE ) { <S2SV_EndBug> printf ( ""Warning:<S2SV_blank>Cannot<S2SV_blank>open<S2SV_blank>log<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>for<S2SV_blank>writing\\n"" , log_file ) ; <S2SV_StartBug> } <S2SV_EndBug> return NULL ; } ( void ) fcntl ( fileno ( log_fp ) , F_SETFD , FD_CLOEXEC ) ; return log_fp ; }
","<S2SV_ModStart> void ) { int fh ; struct stat st ; if ( log_fp ) return log_fp ; if ( ( fh = open ( log_file , O_RDWR | O_APPEND | O_CREAT | O_NOFOLLOW , S_IRUSR | S_IWUSR ) ) == - 1 ) { if ( daemon_mode == FALSE ) printf ( ""Warning:<S2SV_blank>Cannot<S2SV_blank>open<S2SV_blank>log<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>for<S2SV_blank>writing\\n"" , log_file ) ; return NULL ; } log_fp = fdopen ( fh <S2SV_ModEnd> , ""a+"" ) <S2SV_ModStart> == FALSE ) <S2SV_ModEnd> printf ( ""Warning:<S2SV_blank>Cannot<S2SV_blank>open<S2SV_blank>log<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>for<S2SV_blank>writing\\n"" <S2SV_ModStart> log_file ) ; return NULL ; } if ( ( fstat ( fh , & st ) ) == - 1 ) { log_fp = NULL ; close ( fh ) ; if ( daemon_mode == FALSE ) printf ( ""Warning:<S2SV_blank>Cannot<S2SV_blank>fstat<S2SV_blank>log<S2SV_blank>file<S2SV_blank>\'%s\'\\n"" , log_file ) ; return NULL ; } if ( st . st_nlink != 1 || ( st . st_mode & S_IFMT ) != S_IFREG ) { log_fp = NULL ; close ( fh ) ; if ( daemon_mode == FALSE ) printf ( ""Warning:<S2SV_blank>log<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>mode\\n"" , log_file ) ; <S2SV_ModEnd> return NULL ;
"
255,"CWE-119 static PixelChannels * * AcquirePixelThreadSet ( const Image * images ) { const Image * next ; PixelChannels * * pixels ; register ssize_t i ; size_t columns , <S2SV_StartBug> number_threads ; <S2SV_EndBug> <S2SV_StartBug> number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ; <S2SV_EndBug> <S2SV_StartBug> pixels = ( PixelChannels * * ) AcquireQuantumMemory ( number_threads , <S2SV_EndBug> sizeof ( * pixels ) ) ; if ( pixels == ( PixelChannels * * ) NULL ) return ( ( PixelChannels * * ) NULL ) ; <S2SV_StartBug> ( void ) memset ( pixels , 0 , number_threads * sizeof ( * pixels ) ) ; <S2SV_EndBug> columns = images -> columns ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) number_threads ; i ++ ) <S2SV_EndBug> { register ssize_t j ; pixels [ i ] = ( PixelChannels * ) AcquireQuantumMemory ( columns , sizeof ( * * pixels ) ) ; if ( pixels [ i ] == ( PixelChannels * ) NULL ) return ( DestroyPixelThreadSet ( pixels ) ) ; for ( j = 0 ; j < ( ssize_t ) columns ; j ++ ) { register ssize_t k ; for ( k = 0 ; k < MaxPixelChannels ; k ++ ) pixels [ i ] [ j ] . channel [ k ] = 0.0 ; } } return ( pixels ) ; }
","<S2SV_ModStart> size_t columns , rows ; rows = MagickMax ( GetImageListLength ( images ) , <S2SV_ModEnd> ( size_t ) <S2SV_ModStart> ( ThreadResource ) ) <S2SV_ModStart> ) AcquireQuantumMemory ( rows , <S2SV_ModEnd> sizeof ( * <S2SV_ModStart> NULL ) ; columns = MaxPixelChannels ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; for ( i = 0 <S2SV_ModEnd> ; i < <S2SV_ModStart> ( ssize_t ) rows <S2SV_ModEnd> ; i ++
"
256,"CWE-835 static Image * ReadTXTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char colorspace [ MagickPathExtent ] , text [ MagickPathExtent ] ; Image * image ; long x_offset , y_offset ; PixelInfo pixel ; MagickBooleanType status ; QuantumAny range ; register ssize_t i , x ; register Quantum * q ; ssize_t count , type , y ; unsigned long depth , height , max_value , width ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( text , 0 , sizeof ( text ) ) ; ( void ) ReadBlobString ( image , text ) ; if ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) != 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { width = 0 ; height = 0 ; max_value = 0 ; * colorspace = '\\0' ; count = ( ssize_t ) sscanf ( text + 32 , ""%lu,%lu,%lu,%s"" , & width , & height , & max_value , colorspace ) ; if ( ( count != 4 ) || ( width == 0 ) || ( height == 0 ) || ( max_value == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> columns = width ; image -> rows = height ; for ( depth = 1 ; ( GetQuantumRange ( depth ) + 1 ) < max_value ; depth ++ ) ; image -> depth = depth ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; LocaleLower ( colorspace ) ; i = ( ssize_t ) strlen ( colorspace ) - 1 ; image -> alpha_trait = UndefinedPixelTrait ; if ( ( i > 0 ) && ( colorspace [ i ] == 'a' ) ) { colorspace [ i ] = '\\0' ; image -> alpha_trait = BlendPixelTrait ; } type = ParseCommandOption ( MagickColorspaceOptions , MagickFalse , colorspace ) ; if ( type < 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; ( void ) SetImageBackgroundColor ( image , exception ) ; ( void ) SetImageColorspace ( image , ( ColorspaceType ) type , exception ) ; GetPixelInfo ( image , & pixel ) ; range = GetQuantumRange ( image -> depth ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { double alpha , black , blue , green , red ; red = 0.0 ; green = 0.0 ; blue = 0.0 ; black = 0.0 ; alpha = 0.0 ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( ReadBlobString ( image , text ) == ( char * ) NULL ) break ; switch ( image -> colorspace ) { case GRAYColorspace : { if ( image -> alpha_trait != UndefinedPixelTrait ) { count = ( ssize_t ) sscanf ( text , ""%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & alpha ) ; green = red ; blue = red ; break ; } count = ( ssize_t ) sscanf ( text , ""%ld,%ld:<S2SV_blank>(%lf%*[%,]"" , & x_offset , & y_offset , & red ) ; green = red ; blue = red ; break ; } case CMYKColorspace : { if ( image -> alpha_trait != UndefinedPixelTrait ) { count = ( ssize_t ) sscanf ( text , ""%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & green , & blue , & black , & alpha ) ; break ; } count = ( ssize_t ) sscanf ( text , ""%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & green , & blue , & black ) ; break ; } default : { if ( image -> alpha_trait != UndefinedPixelTrait ) { count = ( ssize_t ) sscanf ( text , ""%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & green , & blue , & alpha ) ; break ; } count = ( ssize_t ) sscanf ( text , ""%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & green , & blue ) ; break ; } } if ( strchr ( text , '%' ) != ( char * ) NULL ) { red *= 0.01 * range ; green *= 0.01 * range ; blue *= 0.01 * range ; black *= 0.01 * range ; alpha *= 0.01 * range ; } if ( image -> colorspace == LabColorspace ) { green += ( range + 1 ) / 2.0 ; blue += ( range + 1 ) / 2.0 ; } pixel . red = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( red + 0.5 ) , range ) ; pixel . green = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( green + 0.5 ) , range ) ; pixel . blue = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( blue + 0.5 ) , range ) ; pixel . black = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( black + 0.5 ) , range ) ; pixel . alpha = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( alpha + 0.5 ) , range ) ; q = GetAuthenticPixels ( image , ( ssize_t ) x_offset , ( ssize_t ) y_offset , 1 , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) continue ; SetPixelViaPixelInfo ( image , & pixel , q ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } } <S2SV_StartBug> ( void ) ReadBlobString ( image , text ) ; <S2SV_EndBug> if ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) == 0 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) == 0 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> ; } } if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; }
"
257,"CWE-125 void icmp_print ( netdissect_options * ndo , const u_char * bp , u_int plen , const u_char * bp2 , int fragmented ) { char * cp ; const struct icmp * dp ; const struct icmp_ext_t * ext_dp ; const struct ip * ip ; const char * str , * fmt ; const struct ip * oip ; const struct udphdr * ouh ; const uint8_t * obj_tptr ; uint32_t raw_label ; const u_char * snapend_save ; const struct icmp_mpls_ext_object_header_t * icmp_mpls_ext_object_header ; u_int hlen , dport , mtu , obj_tlen , obj_class_num , obj_ctype ; char buf [ MAXHOSTNAMELEN + 100 ] ; struct cksum_vec vec [ 1 ] ; dp = ( const struct icmp * ) bp ; ext_dp = ( const struct icmp_ext_t * ) bp ; ip = ( const struct ip * ) bp2 ; str = buf ; ND_TCHECK ( dp -> icmp_code ) ; switch ( dp -> icmp_type ) { case ICMP_ECHO : case ICMP_ECHOREPLY : ND_TCHECK ( dp -> icmp_seq ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""echo<S2SV_blank>%s,<S2SV_blank>id<S2SV_blank>%u,<S2SV_blank>seq<S2SV_blank>%u"" , dp -> icmp_type == ICMP_ECHO ? ""request"" : ""reply"" , EXTRACT_16BITS ( & dp -> icmp_id ) , EXTRACT_16BITS ( & dp -> icmp_seq ) ) ; break ; case ICMP_UNREACH : ND_TCHECK ( dp -> icmp_ip . ip_dst ) ; switch ( dp -> icmp_code ) { case ICMP_UNREACH_PROTOCOL : ND_TCHECK ( dp -> icmp_ip . ip_p ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>protocol<S2SV_blank>%d<S2SV_blank>unreachable"" , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) , dp -> icmp_ip . ip_p ) ; break ; case ICMP_UNREACH_PORT : ND_TCHECK ( dp -> icmp_ip . ip_p ) ; oip = & dp -> icmp_ip ; hlen = IP_HL ( oip ) * 4 ; ouh = ( const struct udphdr * ) ( ( ( const u_char * ) oip ) + hlen ) ; ND_TCHECK ( ouh -> uh_dport ) ; dport = EXTRACT_16BITS ( & ouh -> uh_dport ) ; switch ( oip -> ip_p ) { case IPPROTO_TCP : ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>tcp<S2SV_blank>port<S2SV_blank>%s<S2SV_blank>unreachable"" , ipaddr_string ( ndo , & oip -> ip_dst ) , tcpport_string ( ndo , dport ) ) ; break ; case IPPROTO_UDP : ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>udp<S2SV_blank>port<S2SV_blank>%s<S2SV_blank>unreachable"" , ipaddr_string ( ndo , & oip -> ip_dst ) , udpport_string ( ndo , dport ) ) ; break ; default : ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>protocol<S2SV_blank>%d<S2SV_blank>port<S2SV_blank>%d<S2SV_blank>unreachable"" , ipaddr_string ( ndo , & oip -> ip_dst ) , oip -> ip_p , dport ) ; break ; } break ; case ICMP_UNREACH_NEEDFRAG : { register const struct mtu_discovery * mp ; mp = ( const struct mtu_discovery * ) ( const u_char * ) & dp -> icmp_void ; mtu = EXTRACT_16BITS ( & mp -> nexthopmtu ) ; if ( mtu ) { ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>unreachable<S2SV_blank>-<S2SV_blank>need<S2SV_blank>to<S2SV_blank>frag<S2SV_blank>(mtu<S2SV_blank>%d)"" , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) , mtu ) ; } else { ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>unreachable<S2SV_blank>-<S2SV_blank>need<S2SV_blank>to<S2SV_blank>frag"" , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) ) ; } } break ; default : fmt = tok2str ( unreach2str , ""#%d<S2SV_blank>%%s<S2SV_blank>unreachable"" , dp -> icmp_code ) ; ( void ) snprintf ( buf , sizeof ( buf ) , fmt , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) ) ; break ; } break ; case ICMP_REDIRECT : ND_TCHECK ( dp -> icmp_ip . ip_dst ) ; fmt = tok2str ( type2str , ""redirect-#%d<S2SV_blank>%%s<S2SV_blank>to<S2SV_blank>net<S2SV_blank>%%s"" , dp -> icmp_code ) ; ( void ) snprintf ( buf , sizeof ( buf ) , fmt , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) , ipaddr_string ( ndo , & dp -> icmp_gwaddr ) ) ; break ; case ICMP_ROUTERADVERT : { register const struct ih_rdiscovery * ihp ; register const struct id_rdiscovery * idp ; u_int lifetime , num , size ; ( void ) snprintf ( buf , sizeof ( buf ) , ""router<S2SV_blank>advertisement"" ) ; cp = buf + strlen ( buf ) ; ihp = ( const struct ih_rdiscovery * ) & dp -> icmp_void ; ND_TCHECK ( * ihp ) ; ( void ) strncpy ( cp , ""<S2SV_blank>lifetime<S2SV_blank>"" , sizeof ( buf ) - ( cp - buf ) ) ; cp = buf + strlen ( buf ) ; lifetime = EXTRACT_16BITS ( & ihp -> ird_lifetime ) ; if ( lifetime < 60 ) { ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""%u"" , lifetime ) ; } else if ( lifetime < 60 * 60 ) { ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""%u:%02u"" , lifetime / 60 , lifetime % 60 ) ; } else { ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""%u:%02u:%02u"" , lifetime / 3600 , ( lifetime % 3600 ) / 60 , lifetime % 60 ) ; } cp = buf + strlen ( buf ) ; num = ihp -> ird_addrnum ; ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""<S2SV_blank>%d:"" , num ) ; cp = buf + strlen ( buf ) ; size = ihp -> ird_addrsiz ; if ( size != 2 ) { ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""<S2SV_blank>[size<S2SV_blank>%d]"" , size ) ; break ; } idp = ( const struct id_rdiscovery * ) & dp -> icmp_data ; while ( num -- > 0 ) { ND_TCHECK ( * idp ) ; ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""<S2SV_blank>{%s<S2SV_blank>%u}"" , ipaddr_string ( ndo , & idp -> ird_addr ) , EXTRACT_32BITS ( & idp -> ird_pref ) ) ; cp = buf + strlen ( buf ) ; ++ idp ; } } break ; case ICMP_TIMXCEED : ND_TCHECK ( dp -> icmp_ip . ip_dst ) ; switch ( dp -> icmp_code ) { case ICMP_TIMXCEED_INTRANS : str = ""time<S2SV_blank>exceeded<S2SV_blank>in-transit"" ; break ; case ICMP_TIMXCEED_REASS : str = ""ip<S2SV_blank>reassembly<S2SV_blank>time<S2SV_blank>exceeded"" ; break ; default : ( void ) snprintf ( buf , sizeof ( buf ) , ""time<S2SV_blank>exceeded-#%d"" , dp -> icmp_code ) ; break ; } break ; case ICMP_PARAMPROB : if ( dp -> icmp_code ) ( void ) snprintf ( buf , sizeof ( buf ) , ""parameter<S2SV_blank>problem<S2SV_blank>-<S2SV_blank>code<S2SV_blank>%d"" , dp -> icmp_code ) ; else { ND_TCHECK ( dp -> icmp_pptr ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""parameter<S2SV_blank>problem<S2SV_blank>-<S2SV_blank>octet<S2SV_blank>%d"" , dp -> icmp_pptr ) ; } break ; case ICMP_MASKREPLY : ND_TCHECK ( dp -> icmp_mask ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""address<S2SV_blank>mask<S2SV_blank>is<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( & dp -> icmp_mask ) ) ; break ; case ICMP_TSTAMP : ND_TCHECK ( dp -> icmp_seq ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""time<S2SV_blank>stamp<S2SV_blank>query<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>seq<S2SV_blank>%u"" , EXTRACT_16BITS ( & dp -> icmp_id ) , EXTRACT_16BITS ( & dp -> icmp_seq ) ) ; break ; case ICMP_TSTAMPREPLY : ND_TCHECK ( dp -> icmp_ttime ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""time<S2SV_blank>stamp<S2SV_blank>reply<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>seq<S2SV_blank>%u:<S2SV_blank>org<S2SV_blank>%s"" , EXTRACT_16BITS ( & dp -> icmp_id ) , EXTRACT_16BITS ( & dp -> icmp_seq ) , icmp_tstamp_print ( EXTRACT_32BITS ( & dp -> icmp_otime ) ) ) ; ( void ) snprintf ( buf + strlen ( buf ) , sizeof ( buf ) - strlen ( buf ) , "",<S2SV_blank>recv<S2SV_blank>%s"" , icmp_tstamp_print ( EXTRACT_32BITS ( & dp -> icmp_rtime ) ) ) ; ( void ) snprintf ( buf + strlen ( buf ) , sizeof ( buf ) - strlen ( buf ) , "",<S2SV_blank>xmit<S2SV_blank>%s"" , icmp_tstamp_print ( EXTRACT_32BITS ( & dp -> icmp_ttime ) ) ) ; break ; default : str = tok2str ( icmp2str , ""type-#%d"" , dp -> icmp_type ) ; break ; } ND_PRINT ( ( ndo , ""ICMP<S2SV_blank>%s,<S2SV_blank>length<S2SV_blank>%u"" , str , plen ) ) ; if ( ndo -> ndo_vflag && ! fragmented ) { uint16_t sum , icmp_sum ; if ( ND_TTEST2 ( * bp , plen ) ) { vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) dp ; vec [ 0 ] . len = plen ; sum = in_cksum ( vec , 1 ) ; if ( sum != 0 ) { icmp_sum = EXTRACT_16BITS ( & dp -> icmp_cksum ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>(wrong<S2SV_blank>icmp<S2SV_blank>cksum<S2SV_blank>%x<S2SV_blank>(->%x)!)"" , icmp_sum , in_cksum_shouldbe ( icmp_sum , sum ) ) ) ; } } } if ( ndo -> ndo_vflag >= 1 && ICMP_ERRTYPE ( dp -> icmp_type ) ) { bp += 8 ; ND_PRINT ( ( ndo , ""\\n\\t"" ) ) ; ip = ( const struct ip * ) bp ; <S2SV_StartBug> snapend_save = ndo -> ndo_snapend ; <S2SV_EndBug> ip_print ( ndo , bp , EXTRACT_16BITS ( & ip -> ip_len ) ) ; ndo -> ndo_snapend = snapend_save ; } if ( ndo -> ndo_vflag >= 1 && plen > ICMP_EXTD_MINLEN && ICMP_MPLS_EXT_TYPE ( dp -> icmp_type ) ) { ND_TCHECK ( * ext_dp ) ; if ( ! ext_dp -> icmp_length && ND_TTEST2 ( ext_dp -> icmp_ext_version_res , plen - ICMP_EXTD_MINLEN ) ) { vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) & ext_dp -> icmp_ext_version_res ; vec [ 0 ] . len = plen - ICMP_EXTD_MINLEN ; if ( in_cksum ( vec , 1 ) ) { return ; } } ND_PRINT ( ( ndo , ""\\n\\tMPLS<S2SV_blank>extension<S2SV_blank>v%u"" , ICMP_MPLS_EXT_EXTRACT_VERSION ( * ( ext_dp -> icmp_ext_version_res ) ) ) ) ; if ( ICMP_MPLS_EXT_EXTRACT_VERSION ( * ( ext_dp -> icmp_ext_version_res ) ) != ICMP_MPLS_EXT_VERSION ) { ND_PRINT ( ( ndo , ""<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" ) ) ; return ; } hlen = plen - ICMP_EXTD_MINLEN ; if ( ND_TTEST2 ( ext_dp -> icmp_ext_version_res , hlen ) ) { vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) & ext_dp -> icmp_ext_version_res ; vec [ 0 ] . len = hlen ; ND_PRINT ( ( ndo , "",<S2SV_blank>checksum<S2SV_blank>0x%04x<S2SV_blank>(%scorrect),<S2SV_blank>length<S2SV_blank>%u"" , EXTRACT_16BITS ( ext_dp -> icmp_ext_checksum ) , in_cksum ( vec , 1 ) ? ""in"" : """" , hlen ) ) ; } hlen -= 4 ; obj_tptr = ( const uint8_t * ) ext_dp -> icmp_ext_data ; while ( hlen > sizeof ( struct icmp_mpls_ext_object_header_t ) ) { icmp_mpls_ext_object_header = ( const struct icmp_mpls_ext_object_header_t * ) obj_tptr ; ND_TCHECK ( * icmp_mpls_ext_object_header ) ; obj_tlen = EXTRACT_16BITS ( icmp_mpls_ext_object_header -> length ) ; obj_class_num = icmp_mpls_ext_object_header -> class_num ; obj_ctype = icmp_mpls_ext_object_header -> ctype ; obj_tptr += sizeof ( struct icmp_mpls_ext_object_header_t ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Object<S2SV_blank>(%u),<S2SV_blank>Class-Type:<S2SV_blank>%u,<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( icmp_mpls_ext_obj_values , ""unknown"" , obj_class_num ) , obj_class_num , obj_ctype , obj_tlen ) ) ; hlen -= sizeof ( struct icmp_mpls_ext_object_header_t ) ; if ( ( obj_class_num == 0 ) || ( obj_tlen < sizeof ( struct icmp_mpls_ext_object_header_t ) ) ) { return ; } obj_tlen -= sizeof ( struct icmp_mpls_ext_object_header_t ) ; switch ( obj_class_num ) { case 1 : switch ( obj_ctype ) { case 1 : ND_TCHECK2 ( * obj_tptr , 4 ) ; raw_label = EXTRACT_32BITS ( obj_tptr ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>label<S2SV_blank>%u,<S2SV_blank>exp<S2SV_blank>%u"" , MPLS_LABEL ( raw_label ) , MPLS_EXP ( raw_label ) ) ) ; if ( MPLS_STACK ( raw_label ) ) ND_PRINT ( ( ndo , "",<S2SV_blank>[S]"" ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>ttl<S2SV_blank>%u"" , MPLS_TTL ( raw_label ) ) ) ; break ; default : print_unknown_data ( ndo , obj_tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , obj_tlen ) ; } break ; case 2 : default : print_unknown_data ( ndo , obj_tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , obj_tlen ) ; break ; } if ( hlen < obj_tlen ) break ; hlen -= obj_tlen ; obj_tptr += obj_tlen ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|icmp]"" ) ) ; }
","<S2SV_ModStart> ndo -> ndo_snapend ; ND_TCHECK_16BITS ( & ip -> ip_len )
"
258,"CWE-125 static const struct usb_cdc_union_desc * ims_pcu_get_cdc_union_desc ( struct usb_interface * intf ) { const void * buf = intf -> altsetting -> extra ; size_t buflen = intf -> altsetting -> extralen ; struct usb_cdc_union_desc * union_desc ; if ( ! buf ) { dev_err ( & intf -> dev , ""Missing<S2SV_blank>descriptor<S2SV_blank>data\\n"" ) ; return NULL ; } if ( ! buflen ) { dev_err ( & intf -> dev , ""Zero<S2SV_blank>length<S2SV_blank>descriptor\\n"" ) ; return NULL ; } <S2SV_StartBug> while ( buflen > 0 ) { <S2SV_EndBug> union_desc = ( struct usb_cdc_union_desc * ) buf ; if ( union_desc -> bDescriptorType == USB_DT_CS_INTERFACE && union_desc -> bDescriptorSubType == USB_CDC_UNION_TYPE ) { dev_dbg ( & intf -> dev , ""Found<S2SV_blank>union<S2SV_blank>header\\n"" ) ; <S2SV_StartBug> return union_desc ; <S2SV_EndBug> } buflen -= union_desc -> bLength ; buf += union_desc -> bLength ; } dev_err ( & intf -> dev , ""Missing<S2SV_blank>CDC<S2SV_blank>union<S2SV_blank>descriptor\\n"" ) ; return NULL ; }
","<S2SV_ModStart> while ( buflen >= sizeof ( * union_desc ) ) { union_desc = ( struct usb_cdc_union_desc * ) buf ; if ( union_desc -> bLength > buflen ) { dev_err ( & intf -> dev , ""Too<S2SV_blank>large<S2SV_blank>descriptor\\n"" ) ; return NULL ; } <S2SV_ModEnd> if ( union_desc <S2SV_ModStart> ""Found<S2SV_blank>union<S2SV_blank>header\\n"" ) ; if ( union_desc -> bLength >= sizeof ( * union_desc ) ) return union_desc ; dev_err ( & intf -> dev , ""Union<S2SV_blank>descriptor<S2SV_blank>to<S2SV_blank>short<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%zd\\n)"" , union_desc -> bLength , sizeof ( * union_desc ) ) ; return NULL <S2SV_ModEnd> ; } buflen
"
259,"CWE-119 static AVFrame * get_video_buffer ( AVFilterLink * inlink , int w , int h ) { PadContext * s = inlink -> dst -> priv ; AVFrame * frame = ff_get_video_buffer ( inlink -> dst -> outputs [ 0 ] , w + ( s -> w - s -> in_w ) , h + ( s -> h - s -> in_h ) ) ; int plane ; if ( ! frame ) return NULL ; frame -> width = w ; frame -> height = h ; <S2SV_StartBug> for ( plane = 0 ; plane < 4 && frame -> data [ plane ] ; plane ++ ) { <S2SV_EndBug> int hsub = s -> draw . hsub [ plane ] ; int vsub = s -> draw . vsub [ plane ] ; frame -> data [ plane ] += ( s -> x >> hsub ) * s -> draw . pixelstep [ plane ] + ( s -> y >> vsub ) * frame -> linesize [ plane ] ; } return frame ; }
","<S2SV_ModStart> [ plane ] && frame -> linesize [ plane ]
"
260,"CWE-19 int xfs_attr3_leaf_clearflag ( struct xfs_da_args * args ) { struct xfs_attr_leafblock * leaf ; struct xfs_attr_leaf_entry * entry ; struct xfs_attr_leaf_name_remote * name_rmt ; struct xfs_buf * bp ; int error ; # ifdef DEBUG struct xfs_attr3_icleaf_hdr ichdr ; xfs_attr_leaf_name_local_t * name_loc ; int namelen ; char * name ; # endif trace_xfs_attr_leaf_clearflag ( args ) ; error = xfs_attr3_leaf_read ( args -> trans , args -> dp , args -> blkno , - 1 , & bp ) ; if ( error ) return ( error ) ; leaf = bp -> b_addr ; entry = & xfs_attr3_leaf_entryp ( leaf ) [ args -> index ] ; ASSERT ( entry -> flags & XFS_ATTR_INCOMPLETE ) ; # ifdef DEBUG xfs_attr3_leaf_hdr_from_disk ( & ichdr , leaf ) ; ASSERT ( args -> index < ichdr . count ) ; ASSERT ( args -> index >= 0 ) ; if ( entry -> flags & XFS_ATTR_LOCAL ) { name_loc = xfs_attr3_leaf_name_local ( leaf , args -> index ) ; namelen = name_loc -> namelen ; name = ( char * ) name_loc -> nameval ; } else { name_rmt = xfs_attr3_leaf_name_remote ( leaf , args -> index ) ; namelen = name_rmt -> namelen ; name = ( char * ) name_rmt -> name ; } ASSERT ( be32_to_cpu ( entry -> hashval ) == args -> hashval ) ; ASSERT ( namelen == args -> namelen ) ; ASSERT ( memcmp ( name , args -> name , namelen ) == 0 ) ; # endif entry -> flags &= ~ XFS_ATTR_INCOMPLETE ; xfs_trans_log_buf ( args -> trans , bp , XFS_DA_LOGRANGE ( leaf , entry , sizeof ( * entry ) ) ) ; if ( args -> rmtblkno ) { ASSERT ( ( entry -> flags & XFS_ATTR_LOCAL ) == 0 ) ; name_rmt = xfs_attr3_leaf_name_remote ( leaf , args -> index ) ; name_rmt -> valueblk = cpu_to_be32 ( args -> rmtblkno ) ; <S2SV_StartBug> name_rmt -> valuelen = cpu_to_be32 ( args -> valuelen ) ; <S2SV_EndBug> xfs_trans_log_buf ( args -> trans , bp , XFS_DA_LOGRANGE ( leaf , name_rmt , sizeof ( * name_rmt ) ) ) ; } return xfs_trans_roll ( & args -> trans , args -> dp ) ; }
","<S2SV_ModStart> ( args -> rmtvaluelen <S2SV_ModEnd> ) ; xfs_trans_log_buf
"
261,"CWE-20 static cupsd_job_t * add_job ( cupsd_client_t * con , cupsd_printer_t * printer , mime_type_t * filetype ) { http_status_t status ; ipp_attribute_t * attr , * auth_info ; const char * mandatory ; const char * val ; int priority ; cupsd_job_t * job ; char job_uri [ HTTP_MAX_URI ] ; int kbytes ; int i ; int lowerpagerange ; int exact ; ipp_attribute_t * media_col , * media_margin ; ipp_t * unsup_col ; static const char * const readonly [ ] = { ""date-time-at-completed"" , ""date-time-at-creation"" , ""date-time-at-processing"" , ""job-detailed-status-messages"" , ""job-document-access-errors"" , ""job-id"" , ""job-impressions-completed"" , ""job-k-octets-completed"" , ""job-media-sheets-completed"" , ""job-pages-completed"" , ""job-printer-up-time"" , ""job-printer-uri"" , ""job-state"" , ""job-state-message"" , ""job-state-reasons"" , ""job-uri"" , ""number-of-documents"" , ""number-of-intervening-jobs"" , ""output-device-assigned"" , ""time-at-completed"" , ""time-at-creation"" , ""time-at-processing"" } ; cupsdLogMessage ( CUPSD_LOG_DEBUG2 , ""add_job(%p[%d],<S2SV_blank>%p(%s),<S2SV_blank>%p(%s/%s))"" , con , con -> number , printer , printer -> name , filetype , filetype ? filetype -> super : ""none"" , filetype ? filetype -> type : ""none"" ) ; if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , ""localhost"" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) ) { send_ipp_status ( con , IPP_NOT_AUTHORIZED , _ ( ""The<S2SV_blank>printer<S2SV_blank>or<S2SV_blank>class<S2SV_blank>is<S2SV_blank>not<S2SV_blank>shared."" ) ) ; return ( NULL ) ; } auth_info = ippFindAttribute ( con -> request , ""auth-info"" , IPP_TAG_TEXT ) ; if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK ) { send_http_error ( con , status , printer ) ; return ( NULL ) ; } else if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , ""negotiate"" ) && ! con -> username [ 0 ] ) { send_http_error ( con , HTTP_UNAUTHORIZED , printer ) ; return ( NULL ) ; } # ifdef HAVE_SSL else if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) ) { send_http_error ( con , HTTP_UPGRADE_REQUIRED , printer ) ; return ( NULL ) ; } # endif if ( ! printer -> accepting ) { send_ipp_status ( con , IPP_NOT_ACCEPTING , _ ( ""Destination<S2SV_blank>\\""%s\\""<S2SV_blank>is<S2SV_blank>not<S2SV_blank>accepting<S2SV_blank>jobs."" ) , printer -> name ) ; return ( NULL ) ; } for ( i = 0 ; i < ( int ) ( sizeof ( readonly ) / sizeof ( readonly [ 0 ] ) ) ; i ++ ) { if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL ) { ippDeleteAttribute ( con -> request , attr ) ; if ( StrictConformance ) { send_ipp_status ( con , IPP_BAD_REQUEST , _ ( ""The<S2SV_blank>\'%s\'<S2SV_blank>Job<S2SV_blank>Status<S2SV_blank>attribute<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>supplied<S2SV_blank>in<S2SV_blank>a<S2SV_blank>job<S2SV_blank>creation<S2SV_blank>request."" ) , readonly [ i ] ) ; return ( NULL ) ; } cupsdLogMessage ( CUPSD_LOG_INFO , ""Unexpected<S2SV_blank>\'%s\'<S2SV_blank>Job<S2SV_blank>Status<S2SV_blank>attribute<S2SV_blank>in<S2SV_blank>a<S2SV_blank>job<S2SV_blank>creation<S2SV_blank>request."" , readonly [ i ] ) ; } } if ( printer -> pc ) { for ( mandatory = ( char * ) cupsArrayFirst ( printer -> pc -> mandatory ) ; mandatory ; mandatory = ( char * ) cupsArrayNext ( printer -> pc -> mandatory ) ) { if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) ) { send_ipp_status ( con , IPP_CONFLICT , _ ( ""The<S2SV_blank>\\""%s\\""<S2SV_blank>attribute<S2SV_blank>is<S2SV_blank>required<S2SV_blank>for<S2SV_blank>print<S2SV_blank>jobs."" ) , mandatory ) ; return ( NULL ) ; } } } if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) ) { char mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; snprintf ( mimetype , sizeof ( mimetype ) , ""%s/%s"" , filetype -> super , filetype -> type ) ; send_ipp_status ( con , IPP_DOCUMENT_FORMAT , _ ( ""Unsupported<S2SV_blank>format<S2SV_blank>\\""%s\\""."" ) , mimetype ) ; ippAddString ( con -> response , IPP_TAG_UNSUPPORTED_GROUP , IPP_TAG_MIMETYPE , ""document-format"" , NULL , mimetype ) ; return ( NULL ) ; } if ( ( attr = ippFindAttribute ( con -> request , ""copies"" , IPP_TAG_INTEGER ) ) != NULL ) { if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies ) { send_ipp_status ( con , IPP_ATTRIBUTES , _ ( ""Bad<S2SV_blank>copies<S2SV_blank>value<S2SV_blank>%d."" ) , attr -> values [ 0 ] . integer ) ; ippAddInteger ( con -> response , IPP_TAG_UNSUPPORTED_GROUP , IPP_TAG_INTEGER , ""copies"" , attr -> values [ 0 ] . integer ) ; return ( NULL ) ; } } if ( ( attr = ippFindAttribute ( con -> request , ""job-sheets"" , IPP_TAG_ZERO ) ) != NULL ) { if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME ) { send_ipp_status ( con , IPP_BAD_REQUEST , _ ( ""Bad<S2SV_blank>job-sheets<S2SV_blank>value<S2SV_blank>type."" ) ) ; return ( NULL ) ; } if ( attr -> num_values > 2 ) { send_ipp_status ( con , IPP_BAD_REQUEST , _ ( ""Too<S2SV_blank>many<S2SV_blank>job-sheets<S2SV_blank>values<S2SV_blank>(%d<S2SV_blank>><S2SV_blank>2)."" ) , attr -> num_values ) ; return ( NULL ) ; } for ( i = 0 ; i < attr -> num_values ; i ++ ) if ( strcmp ( attr -> values [ i ] . string . text , ""none"" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) ) { send_ipp_status ( con , IPP_BAD_REQUEST , _ ( ""Bad<S2SV_blank>job-sheets<S2SV_blank>value<S2SV_blank>\\""%s\\""."" ) , attr -> values [ i ] . string . text ) ; return ( NULL ) ; } } if ( ( attr = ippFindAttribute ( con -> request , ""number-up"" , IPP_TAG_INTEGER ) ) != NULL ) { if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 ) { send_ipp_status ( con , IPP_ATTRIBUTES , _ ( ""Bad<S2SV_blank>number-up<S2SV_blank>value<S2SV_blank>%d."" ) , attr -> values [ 0 ] . integer ) ; ippAddInteger ( con -> response , IPP_TAG_UNSUPPORTED_GROUP , IPP_TAG_INTEGER , ""number-up"" , attr -> values [ 0 ] . integer ) ; return ( NULL ) ; } } if ( ( attr = ippFindAttribute ( con -> request , ""page-ranges"" , IPP_TAG_RANGE ) ) != NULL ) { for ( i = 0 , lowerpagerange = 1 ; i < attr -> num_values ; i ++ ) { if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper ) { send_ipp_status ( con , IPP_BAD_REQUEST , _ ( ""Bad<S2SV_blank>page-ranges<S2SV_blank>values<S2SV_blank>%d-%d."" ) , attr -> values [ i ] . range . lower , attr -> values [ i ] . range . upper ) ; return ( NULL ) ; } lowerpagerange = attr -> values [ i ] . range . upper + 1 ; } } if ( ! ippFindAttribute ( con -> request , ""PageRegion"" , IPP_TAG_ZERO ) && ! ippFindAttribute ( con -> request , ""PageSize"" , IPP_TAG_ZERO ) && _ppdCacheGetPageSize ( printer -> pc , con -> request , NULL , & exact ) ) { if ( ! exact && ( media_col = ippFindAttribute ( con -> request , ""media-col"" , IPP_TAG_BEGIN_COLLECTION ) ) != NULL ) { send_ipp_status ( con , IPP_OK_SUBST , _ ( ""Unsupported<S2SV_blank>margins."" ) ) ; unsup_col = ippNew ( ) ; if ( ( media_margin = ippFindAttribute ( media_col -> values [ 0 ] . collection , ""media-bottom-margin"" , IPP_TAG_INTEGER ) ) != NULL ) ippAddInteger ( unsup_col , IPP_TAG_ZERO , IPP_TAG_INTEGER , ""media-bottom-margin"" , media_margin -> values [ 0 ] . integer ) ; if ( ( media_margin = ippFindAttribute ( media_col -> values [ 0 ] . collection , ""media-left-margin"" , IPP_TAG_INTEGER ) ) != NULL ) ippAddInteger ( unsup_col , IPP_TAG_ZERO , IPP_TAG_INTEGER , ""media-left-margin"" , media_margin -> values [ 0 ] . integer ) ; if ( ( media_margin = ippFindAttribute ( media_col -> values [ 0 ] . collection , ""media-right-margin"" , IPP_TAG_INTEGER ) ) != NULL ) ippAddInteger ( unsup_col , IPP_TAG_ZERO , IPP_TAG_INTEGER , ""media-right-margin"" , media_margin -> values [ 0 ] . integer ) ; if ( ( media_margin = ippFindAttribute ( media_col -> values [ 0 ] . collection , ""media-top-margin"" , IPP_TAG_INTEGER ) ) != NULL ) ippAddInteger ( unsup_col , IPP_TAG_ZERO , IPP_TAG_INTEGER , ""media-top-margin"" , media_margin -> values [ 0 ] . integer ) ; ippAddCollection ( con -> response , IPP_TAG_UNSUPPORTED_GROUP , ""media-col"" , unsup_col ) ; ippDelete ( unsup_col ) ; } } if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs ) cupsdCleanJobs ( ) ; if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs ) { send_ipp_status ( con , IPP_NOT_POSSIBLE , _ ( ""Too<S2SV_blank>many<S2SV_blank>active<S2SV_blank>jobs."" ) ) ; return ( NULL ) ; } if ( ( i = check_quotas ( con , printer ) ) < 0 ) { send_ipp_status ( con , IPP_NOT_POSSIBLE , _ ( ""Quota<S2SV_blank>limit<S2SV_blank>reached."" ) ) ; return ( NULL ) ; } else if ( i == 0 ) { send_ipp_status ( con , IPP_NOT_AUTHORIZED , _ ( ""Not<S2SV_blank>allowed<S2SV_blank>to<S2SV_blank>print."" ) ) ; return ( NULL ) ; } if ( ( attr = ippFindAttribute ( con -> request , ""job-priority"" , IPP_TAG_INTEGER ) ) != NULL ) priority = attr -> values [ 0 ] . integer ; else { if ( ( val = cupsGetOption ( ""job-priority"" , printer -> num_options , printer -> options ) ) != NULL ) priority = atoi ( val ) ; else priority = 50 ; ippAddInteger ( con -> request , IPP_TAG_JOB , IPP_TAG_INTEGER , ""job-priority"" , priority ) ; } if ( ( attr = ippFindAttribute ( con -> request , ""job-name"" , IPP_TAG_ZERO ) ) == NULL ) ippAddString ( con -> request , IPP_TAG_JOB , IPP_TAG_NAME , ""job-name"" , NULL , ""Untitled"" ) ; else if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 ) { send_ipp_status ( con , IPP_ATTRIBUTES , _ ( ""Bad<S2SV_blank>job-name<S2SV_blank>value:<S2SV_blank>Wrong<S2SV_blank>type<S2SV_blank>or<S2SV_blank>count."" ) ) ; if ( ( attr = ippCopyAttribute ( con -> response , attr , 0 ) ) != NULL ) attr -> group_tag = IPP_TAG_UNSUPPORTED_GROUP ; return ( NULL ) ; } else if ( ! ippValidateAttribute ( attr ) ) { send_ipp_status ( con , IPP_ATTRIBUTES , _ ( ""Bad<S2SV_blank>job-name<S2SV_blank>value:<S2SV_blank>%s"" ) , cupsLastErrorString ( ) ) ; if ( ( attr = ippCopyAttribute ( con -> response , attr , 0 ) ) != NULL ) attr -> group_tag = IPP_TAG_UNSUPPORTED_GROUP ; return ( NULL ) ; } <S2SV_StartBug> if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL ) <S2SV_EndBug> { send_ipp_status ( con , IPP_INTERNAL_ERROR , _ ( ""Unable<S2SV_blank>to<S2SV_blank>add<S2SV_blank>job<S2SV_blank>for<S2SV_blank>destination<S2SV_blank>\\""%s\\""."" ) , printer -> name ) ; return ( NULL ) ; } job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ) ; job -> attrs = con -> request ; job -> dirty = 1 ; con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ) ; cupsdMarkDirty ( CUPSD_DIRTY_JOBS ) ; add_job_uuid ( job ) ; <S2SV_StartBug> apply_printer_defaults ( printer , job ) ; <S2SV_EndBug> attr = ippFindAttribute ( job -> attrs , ""requesting-user-name"" , IPP_TAG_NAME ) ; if ( con -> username [ 0 ] ) { cupsdSetString ( & job -> username , con -> username ) ; if ( attr ) ippSetString ( job -> attrs , & attr , 0 , con -> username ) ; } else if ( attr ) { cupsdLogMessage ( CUPSD_LOG_DEBUG , ""add_job:<S2SV_blank>requesting-user-name=\\""%s\\"""" , attr -> values [ 0 ] . string . text ) ; cupsdSetString ( & job -> username , attr -> values [ 0 ] . string . text ) ; } else cupsdSetString ( & job -> username , ""anonymous"" ) ; if ( ! attr ) ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , ""job-originating-user-name"" , NULL , job -> username ) ; else { ippSetGroupTag ( job -> attrs , & attr , IPP_TAG_JOB ) ; ippSetName ( job -> attrs , & attr , ""job-originating-user-name"" ) ; } if ( con -> username [ 0 ] || auth_info ) { save_auth_info ( con , job , auth_info ) ; if ( auth_info ) ippDeleteAttribute ( job -> attrs , auth_info ) ; } if ( ( attr = ippFindAttribute ( con -> request , ""job-name"" , IPP_TAG_NAME ) ) != NULL ) cupsdSetString ( & ( job -> name ) , attr -> values [ 0 ] . string . text ) ; if ( ( attr = ippFindAttribute ( job -> attrs , ""job-originating-host-name"" , IPP_TAG_ZERO ) ) != NULL ) { if ( attr -> value_tag != IPP_TAG_NAME || attr -> num_values != 1 || strcmp ( con -> http -> hostname , ""localhost"" ) ) { ippDeleteAttribute ( job -> attrs , attr ) ; ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , ""job-originating-host-name"" , NULL , con -> http -> hostname ) ; } else ippSetGroupTag ( job -> attrs , & attr , IPP_TAG_JOB ) ; } else { ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , ""job-originating-host-name"" , NULL , con -> http -> hostname ) ; } ippAddOutOfBand ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NOVALUE , ""date-time-at-completed"" ) ; ippAddDate ( job -> attrs , IPP_TAG_JOB , ""date-time-at-creation"" , ippTimeToDate ( time ( NULL ) ) ) ; ippAddOutOfBand ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NOVALUE , ""date-time-at-processing"" ) ; ippAddOutOfBand ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NOVALUE , ""time-at-completed"" ) ; ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , ""time-at-creation"" , time ( NULL ) ) ; ippAddOutOfBand ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NOVALUE , ""time-at-processing"" ) ; ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , ""job-id"" , job -> id ) ; job -> state = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_ENUM , ""job-state"" , IPP_JOB_STOPPED ) ; job -> state_value = ( ipp_jstate_t ) job -> state -> values [ 0 ] . integer ; job -> reasons = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , ""job-state-reasons"" , NULL , ""job-incoming"" ) ; job -> impressions = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , ""job-impressions-completed"" , 0 ) ; job -> sheets = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , ""job-media-sheets-completed"" , 0 ) ; ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_URI , ""job-printer-uri"" , NULL , printer -> uri ) ; if ( ( attr = ippFindAttribute ( job -> attrs , ""job-k-octets"" , IPP_TAG_INTEGER ) ) != NULL ) attr -> values [ 0 ] . integer = 0 ; else ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , ""job-k-octets"" , 0 ) ; if ( ( attr = ippFindAttribute ( job -> attrs , ""job-hold-until"" , IPP_TAG_KEYWORD ) ) == NULL ) attr = ippFindAttribute ( job -> attrs , ""job-hold-until"" , IPP_TAG_NAME ) ; if ( ! attr ) { if ( ( val = cupsGetOption ( ""job-hold-until"" , printer -> num_options , printer -> options ) ) == NULL ) val = ""no-hold"" ; attr = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , ""job-hold-until"" , NULL , val ) ; } if ( printer -> holding_new_jobs ) { if ( attr && strcmp ( attr -> values [ 0 ] . string . text , ""no-hold"" ) ) cupsdSetJobHoldUntil ( job , ippGetString ( attr , 0 , NULL ) , 0 ) ; else cupsdSetJobHoldUntil ( job , ""indefinite"" , 0 ) ; job -> state -> values [ 0 ] . integer = IPP_JOB_HELD ; job -> state_value = IPP_JOB_HELD ; ippSetString ( job -> attrs , & job -> reasons , 0 , ""job-held-on-create"" ) ; } else if ( attr && strcmp ( attr -> values [ 0 ] . string . text , ""no-hold"" ) ) { cupsdSetJobHoldUntil ( job , attr -> values [ 0 ] . string . text , 0 ) ; job -> state -> values [ 0 ] . integer = IPP_JOB_HELD ; job -> state_value = IPP_JOB_HELD ; ippSetString ( job -> attrs , & job -> reasons , 0 , ""job-hold-until-specified"" ) ; } else if ( job -> attrs -> request . op . operation_id == IPP_CREATE_JOB ) { job -> hold_until = time ( NULL ) + MultipleOperationTimeout ; job -> state -> values [ 0 ] . integer = IPP_JOB_HELD ; job -> state_value = IPP_JOB_HELD ; } else { job -> state -> values [ 0 ] . integer = IPP_JOB_PENDING ; job -> state_value = IPP_JOB_PENDING ; ippSetString ( job -> attrs , & job -> reasons , 0 , ""none"" ) ; } if ( ! ( printer -> type & CUPS_PRINTER_REMOTE ) || Classification ) { if ( ( attr = ippFindAttribute ( job -> attrs , ""job-sheets"" , IPP_TAG_ZERO ) ) == NULL ) { cupsdLogMessage ( CUPSD_LOG_DEBUG , ""Adding<S2SV_blank>default<S2SV_blank>job-sheets<S2SV_blank>values<S2SV_blank>\\""%s,%s\\""..."" , printer -> job_sheets [ 0 ] , printer -> job_sheets [ 1 ] ) ; attr = ippAddStrings ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , ""job-sheets"" , 2 , NULL , NULL ) ; ippSetString ( job -> attrs , & attr , 0 , printer -> job_sheets [ 0 ] ) ; ippSetString ( job -> attrs , & attr , 1 , printer -> job_sheets [ 1 ] ) ; } job -> job_sheets = attr ; if ( Classification ) { cupsdLogMessage ( CUPSD_LOG_INFO , ""Classification=\\""%s\\"",<S2SV_blank>ClassifyOverride=%d"" , Classification ? Classification : ""(null)"" , ClassifyOverride ) ; if ( ClassifyOverride ) { if ( ! strcmp ( attr -> values [ 0 ] . string . text , ""none"" ) && ( attr -> num_values == 1 || ! strcmp ( attr -> values [ 1 ] . string . text , ""none"" ) ) ) { ippSetString ( job -> attrs , & attr , 0 , Classification ) ; cupsdLogJob ( job , CUPSD_LOG_NOTICE , ""CLASSIFICATION<S2SV_blank>FORCED<S2SV_blank>"" ""job-sheets=\\""%s,none\\"",<S2SV_blank>"" ""job-originating-user-name=\\""%s\\"""" , Classification , job -> username ) ; } else if ( attr -> num_values == 2 && strcmp ( attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text ) && strcmp ( attr -> values [ 0 ] . string . text , ""none"" ) && strcmp ( attr -> values [ 1 ] . string . text , ""none"" ) ) { ippSetString ( job -> attrs , & attr , 1 , attr -> values [ 0 ] . string . text ) ; cupsdLogJob ( job , CUPSD_LOG_NOTICE , ""CLASSIFICATION<S2SV_blank>FORCED<S2SV_blank>"" ""job-sheets=\\""%s,%s\\"",<S2SV_blank>"" ""job-originating-user-name=\\""%s\\"""" , attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text , job -> username ) ; } else if ( strcmp ( attr -> values [ 0 ] . string . text , Classification ) && strcmp ( attr -> values [ 0 ] . string . text , ""none"" ) && ( attr -> num_values == 1 || ( strcmp ( attr -> values [ 1 ] . string . text , Classification ) && strcmp ( attr -> values [ 1 ] . string . text , ""none"" ) ) ) ) { if ( attr -> num_values == 1 ) cupsdLogJob ( job , CUPSD_LOG_NOTICE , ""CLASSIFICATION<S2SV_blank>OVERRIDDEN<S2SV_blank>"" ""job-sheets=\\""%s\\"",<S2SV_blank>"" ""job-originating-user-name=\\""%s\\"""" , attr -> values [ 0 ] . string . text , job -> username ) ; else cupsdLogJob ( job , CUPSD_LOG_NOTICE , ""CLASSIFICATION<S2SV_blank>OVERRIDDEN<S2SV_blank>"" ""job-sheets=\\""%s,%s\\"",fffff<S2SV_blank>"" ""job-originating-user-name=\\""%s\\"""" , attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text , job -> username ) ; } } else if ( strcmp ( attr -> values [ 0 ] . string . text , Classification ) && ( attr -> num_values == 1 || strcmp ( attr -> values [ 1 ] . string . text , Classification ) ) ) { if ( attr -> num_values > 1 && ! strcmp ( attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text ) ) { ippSetString ( job -> attrs , & attr , 0 , Classification ) ; ippSetString ( job -> attrs , & attr , 1 , Classification ) ; } else { if ( attr -> num_values == 1 || strcmp ( attr -> values [ 0 ] . string . text , ""none"" ) ) ippSetString ( job -> attrs , & attr , 0 , Classification ) ; if ( attr -> num_values > 1 && strcmp ( attr -> values [ 1 ] . string . text , ""none"" ) ) ippSetString ( job -> attrs , & attr , 1 , Classification ) ; } if ( attr -> num_values > 1 ) cupsdLogJob ( job , CUPSD_LOG_NOTICE , ""CLASSIFICATION<S2SV_blank>FORCED<S2SV_blank>"" ""job-sheets=\\""%s,%s\\"",<S2SV_blank>"" ""job-originating-user-name=\\""%s\\"""" , attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text , job -> username ) ; else cupsdLogJob ( job , CUPSD_LOG_NOTICE , ""CLASSIFICATION<S2SV_blank>FORCED<S2SV_blank>"" ""job-sheets=\\""%s\\"",<S2SV_blank>"" ""job-originating-user-name=\\""%s\\"""" , Classification , job -> username ) ; } } if ( ! ( printer -> type & CUPS_PRINTER_REMOTE ) ) { cupsdLogJob ( job , CUPSD_LOG_INFO , ""Adding<S2SV_blank>start<S2SV_blank>banner<S2SV_blank>page<S2SV_blank>\\""%s\\""."" , attr -> values [ 0 ] . string . text ) ; if ( ( kbytes = copy_banner ( con , job , attr -> values [ 0 ] . string . text ) ) < 0 ) { cupsdSetJobState ( job , IPP_JOB_ABORTED , CUPSD_JOB_PURGE , ""Aborting<S2SV_blank>job<S2SV_blank>because<S2SV_blank>the<S2SV_blank>start<S2SV_blank>banner<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>"" ""copied."" ) ; return ( NULL ) ; } cupsdUpdateQuota ( printer , job -> username , 0 , kbytes ) ; } } else if ( ( attr = ippFindAttribute ( job -> attrs , ""job-sheets"" , IPP_TAG_ZERO ) ) != NULL ) job -> job_sheets = attr ; httpAssembleURIf ( HTTP_URI_CODING_ALL , job_uri , sizeof ( job_uri ) , ""ipp"" , NULL , con -> clientname , con -> clientport , ""/jobs/%d"" , job -> id ) ; ippAddString ( con -> response , IPP_TAG_JOB , IPP_TAG_URI , ""job-uri"" , NULL , job_uri ) ; ippAddInteger ( con -> response , IPP_TAG_JOB , IPP_TAG_INTEGER , ""job-id"" , job -> id ) ; ippAddInteger ( con -> response , IPP_TAG_JOB , IPP_TAG_ENUM , ""job-state"" , job -> state_value ) ; ippAddString ( con -> response , IPP_TAG_JOB , IPP_TAG_TEXT , ""job-state-message"" , NULL , """" ) ; ippAddString ( con -> response , IPP_TAG_JOB , IPP_TAG_KEYWORD , ""job-state-reasons"" , NULL , job -> reasons -> values [ 0 ] . string . text ) ; con -> response -> request . status . status_code = IPP_OK ; add_job_subscriptions ( con , job ) ; for ( attr = job -> attrs -> attrs -> next -> next ; attr ; attr = attr -> next ) attr -> group_tag = IPP_TAG_JOB ; cupsdAddEvent ( CUPSD_EVENT_JOB_CREATED , printer , job , ""Job<S2SV_blank>created."" ) ; return ( job ) ; }
","<S2SV_ModStart> ) ; } attr = ippFindAttribute ( con -> request , ""requesting-user-name"" , IPP_TAG_NAME ) ; if ( attr && ! ippValidateAttribute ( attr ) ) { send_ipp_status ( con , IPP_ATTRIBUTES , _ ( ""Bad<S2SV_blank>requesting-user-name<S2SV_blank>value:<S2SV_blank>%s"" ) , cupsLastErrorString ( ) ) ; if ( ( attr = ippCopyAttribute ( con -> response , attr , 0 ) ) != NULL ) attr -> group_tag = IPP_TAG_UNSUPPORTED_GROUP ; return ( NULL ) ; } <S2SV_ModStart> printer , job <S2SV_ModEnd> ) ; if
"
262,"CWE-119 char * cJSON_Print ( cJSON * item ) { <S2SV_StartBug> return print_value ( item , 0 , 1 ) ; <S2SV_EndBug> }
","<S2SV_ModStart> 0 , 1 , 0
"
263,"CWE-20 static int cma_req_handler ( struct ib_cm_id * cm_id , struct ib_cm_event * ib_event ) { struct rdma_id_private * listen_id , * conn_id ; struct rdma_cm_event event ; int offset , ret ; <S2SV_StartBug> u8 smac [ ETH_ALEN ] ; <S2SV_EndBug> u8 alt_smac [ ETH_ALEN ] ; u8 * psmac = smac ; u8 * palt_smac = alt_smac ; int is_iboe = ( ( rdma_node_get_transport ( cm_id -> device -> node_type ) == RDMA_TRANSPORT_IB ) && ( rdma_port_get_link_layer ( cm_id -> device , ib_event -> param . req_rcvd . port ) == IB_LINK_LAYER_ETHERNET ) ) ; listen_id = cm_id -> context ; if ( ! cma_check_req_qp_type ( & listen_id -> id , ib_event ) ) return - EINVAL ; if ( cma_disable_callback ( listen_id , RDMA_CM_LISTEN ) ) return - ECONNABORTED ; memset ( & event , 0 , sizeof event ) ; offset = cma_user_data_offset ( listen_id ) ; event . event = RDMA_CM_EVENT_CONNECT_REQUEST ; if ( ib_event -> event == IB_CM_SIDR_REQ_RECEIVED ) { conn_id = cma_new_udp_id ( & listen_id -> id , ib_event ) ; event . param . ud . private_data = ib_event -> private_data + offset ; event . param . ud . private_data_len = IB_CM_SIDR_REQ_PRIVATE_DATA_SIZE - offset ; } else { conn_id = cma_new_conn_id ( & listen_id -> id , ib_event ) ; cma_set_req_event_data ( & event , & ib_event -> param . req_rcvd , ib_event -> private_data , offset ) ; } if ( ! conn_id ) { ret = - ENOMEM ; goto err1 ; } mutex_lock_nested ( & conn_id -> handler_mutex , SINGLE_DEPTH_NESTING ) ; ret = cma_acquire_dev ( conn_id , listen_id ) ; if ( ret ) goto err2 ; conn_id -> cm_id . ib = cm_id ; cm_id -> context = conn_id ; cm_id -> cm_handler = cma_ib_handler ; atomic_inc ( & conn_id -> refcount ) ; ret = conn_id -> id . event_handler ( & conn_id -> id , & event ) ; if ( ret ) goto err3 ; <S2SV_StartBug> if ( is_iboe ) { <S2SV_EndBug> if ( ib_event -> param . req_rcvd . primary_path != NULL ) rdma_addr_find_smac_by_sgid ( & ib_event -> param . req_rcvd . primary_path -> sgid , psmac , NULL ) ; else psmac = NULL ; if ( ib_event -> param . req_rcvd . alternate_path != NULL ) rdma_addr_find_smac_by_sgid ( & ib_event -> param . req_rcvd . alternate_path -> sgid , palt_smac , NULL ) ; else palt_smac = NULL ; } <S2SV_StartBug> mutex_lock ( & lock ) ; <S2SV_EndBug> if ( is_iboe ) ib_update_cm_av ( cm_id , psmac , palt_smac ) ; if ( cma_comp ( conn_id , RDMA_CM_CONNECT ) && ( conn_id -> id . qp_type != IB_QPT_UD ) ) ib_send_cm_mra ( cm_id , CMA_CM_MRA_SETTING , NULL , 0 ) ; mutex_unlock ( & lock ) ; mutex_unlock ( & conn_id -> handler_mutex ) ; mutex_unlock ( & listen_id -> handler_mutex ) ; cma_deref_id ( conn_id ) ; return 0 ; err3 : cma_deref_id ( conn_id ) ; conn_id -> cm_id . ib = NULL ; err2 : cma_exch ( conn_id , RDMA_CM_DESTROYING ) ; mutex_unlock ( & conn_id -> handler_mutex ) ; err1 : mutex_unlock ( & listen_id -> handler_mutex ) ; if ( conn_id ) rdma_destroy_id ( & conn_id -> id ) ; return ret ; }
","<S2SV_ModStart> , ret ; <S2SV_ModEnd> listen_id = cm_id <S2SV_ModStart> goto err3 ; <S2SV_ModEnd> mutex_lock ( & <S2SV_ModStart> ( & lock <S2SV_ModEnd> ) ; if
"
264,"CWE-119 <S2SV_StartBug> static vpx_codec_err_t vp8e_get_reference ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> int ctr_id , va_list args ) { vpx_ref_frame_t * data = va_arg ( args , vpx_ref_frame_t * ) ; if ( data ) { vpx_ref_frame_t * frame = ( vpx_ref_frame_t * ) data ; YV12_BUFFER_CONFIG sd ; image2yuvconfig ( & frame -> img , & sd ) ; vp8_get_reference ( ctx -> cpi , frame -> frame_type , & sd ) ; return VPX_CODEC_OK ; } else return VPX_CODEC_INVALID_PARAM ; }
","<S2SV_ModStart> vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args
"
265,"CWE-119 void vp8_denoiser_free ( VP8_DENOISER * denoiser ) { int i ; assert ( denoiser ) ; for ( i = 0 ; i < MAX_REF_FRAMES ; i ++ ) { vp8_yv12_de_alloc_frame_buffer ( & denoiser -> yv12_running_avg [ i ] ) ; } vp8_yv12_de_alloc_frame_buffer ( & denoiser -> yv12_mc_running_avg ) ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> yv12_mc_running_avg ) ; vp8_yv12_de_alloc_frame_buffer ( & denoiser -> yv12_last_source ) ; vpx_free ( denoiser -> denoise_state ) ;
"
266,"CWE-763 <S2SV_StartBug> static void pcrypt_free ( struct crypto_instance * inst ) <S2SV_EndBug> { <S2SV_StartBug> struct pcrypt_instance_ctx * ctx = crypto_instance_ctx ( inst ) ; <S2SV_EndBug> crypto_drop_aead ( & ctx -> spawn ) ; kfree ( inst ) ; }
","<S2SV_ModStart> pcrypt_free ( struct aead_instance <S2SV_ModEnd> * inst ) <S2SV_ModStart> * ctx = aead_instance_ctx <S2SV_ModEnd> ( inst )
"
267,"CWE-22 static int pop_sync_mailbox ( struct Context * ctx , int * index_hint ) { int i , j , ret = 0 ; char buf [ LONG_STRING ] ; struct PopData * pop_data = ( struct PopData * ) ctx -> data ; struct Progress progress ; # ifdef USE_HCACHE header_cache_t * hc = NULL ; # endif pop_data -> check_time = 0 ; while ( true ) { if ( pop_reconnect ( ctx ) < 0 ) return - 1 ; mutt_progress_init ( & progress , _ ( ""Marking<S2SV_blank>messages<S2SV_blank>deleted..."" ) , MUTT_PROGRESS_MSG , WriteInc , ctx -> deleted ) ; # ifdef USE_HCACHE hc = pop_hcache_open ( pop_data , ctx -> path ) ; # endif for ( i = 0 , j = 0 , ret = 0 ; ret == 0 && i < ctx -> msgcount ; i ++ ) { if ( ctx -> hdrs [ i ] -> deleted && ctx -> hdrs [ i ] -> refno != - 1 ) { j ++ ; if ( ! ctx -> quiet ) mutt_progress_update ( & progress , j , - 1 ) ; snprintf ( buf , sizeof ( buf ) , ""DELE<S2SV_blank>%d\\r\\n"" , ctx -> hdrs [ i ] -> refno ) ; ret = pop_query ( pop_data , buf , sizeof ( buf ) ) ; if ( ret == 0 ) { <S2SV_StartBug> mutt_bcache_del ( pop_data -> bcache , ctx -> hdrs [ i ] -> data ) ; <S2SV_EndBug> # ifdef USE_HCACHE mutt_hcache_delete ( hc , ctx -> hdrs [ i ] -> data , strlen ( ctx -> hdrs [ i ] -> data ) ) ; # endif } } # ifdef USE_HCACHE if ( ctx -> hdrs [ i ] -> changed ) { mutt_hcache_store ( hc , ctx -> hdrs [ i ] -> data , strlen ( ctx -> hdrs [ i ] -> data ) , ctx -> hdrs [ i ] , 0 ) ; } # endif } # ifdef USE_HCACHE mutt_hcache_close ( hc ) ; # endif if ( ret == 0 ) { mutt_str_strfcpy ( buf , ""QUIT\\r\\n"" , sizeof ( buf ) ) ; ret = pop_query ( pop_data , buf , sizeof ( buf ) ) ; } if ( ret == 0 ) { pop_data -> clear_cache = true ; pop_clear_cache ( pop_data ) ; pop_data -> status = POP_DISCONNECTED ; return 0 ; } if ( ret == - 2 ) { mutt_error ( ""%s"" , pop_data -> err_msg ) ; return - 1 ; } } }
","<S2SV_ModStart> -> bcache , cache_id ( <S2SV_ModStart> ] -> data )
"
268,"CWE-200 void * vips_malloc ( VipsObject * object , size_t size ) { void * buf ; <S2SV_StartBug> buf = g_malloc ( size ) ; <S2SV_EndBug> if ( object ) { g_signal_connect ( object , ""postclose"" , G_CALLBACK ( vips_malloc_cb ) , buf ) ; object -> local_memory += size ; } return ( buf ) ; }
","<S2SV_ModStart> ; buf = g_malloc0 <S2SV_ModEnd> ( size )
"
269,"CWE-000 <S2SV_StartBug> struct nfs_open_context * nfs_find_open_context ( struct inode * inode , struct rpc_cred * cred , int mode ) <S2SV_EndBug> { struct nfs_inode * nfsi = NFS_I ( inode ) ; struct nfs_open_context * pos , * ctx = NULL ; spin_lock ( & inode -> i_lock ) ; list_for_each_entry ( pos , & nfsi -> open_files , list ) { if ( cred != NULL && pos -> cred != cred ) continue ; if ( ( pos -> mode & mode ) == mode ) { ctx = get_nfs_open_context ( pos ) ; break ; } } spin_unlock ( & inode -> i_lock ) ; return ctx ; }
","<S2SV_ModStart> * cred , fmode_t <S2SV_ModEnd> mode ) {
"
270,"CWE-119 static const char * parse_scheme ( struct parse_state * state ) { size_t mb ; const char * tmp = state -> ptr ; do { switch ( * state -> ptr ) { case ':' : state -> url . scheme = & state -> buffer [ 0 ] ; state -> buffer [ state -> offset ++ ] = 0 ; return ++ state -> ptr ; case '0' : case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : case '8' : case '9' : case '+' : case '-' : case '.' : if ( state -> ptr == tmp ) { <S2SV_StartBug> return tmp ; <S2SV_EndBug> } case 'A' : case 'B' : case 'C' : case 'D' : case 'E' : case 'F' : case 'G' : case 'H' : case 'I' : case 'J' : case 'K' : case 'L' : case 'M' : case 'N' : case 'O' : case 'P' : case 'Q' : case 'R' : case 'S' : case 'T' : case 'U' : case 'V' : case 'W' : case 'X' : case 'Y' : case 'Z' : case 'a' : case 'b' : case 'c' : case 'd' : case 'e' : case 'f' : case 'g' : case 'h' : case 'i' : case 'j' : case 'k' : case 'l' : case 'm' : case 'n' : case 'o' : case 'p' : case 'q' : case 'r' : case 's' : case 't' : case 'u' : case 'v' : case 'w' : case 'x' : case 'y' : case 'z' : state -> buffer [ state -> offset ++ ] = * state -> ptr ; break ; default : if ( ! ( mb = parse_mb ( state , PARSE_SCHEME , state -> ptr , state -> end , tmp , 1 ) ) ) { <S2SV_StartBug> return tmp ; <S2SV_EndBug> } state -> ptr += mb - 1 ; } } while ( ++ state -> ptr != state -> end ) ; <S2SV_StartBug> return state -> ptr = tmp ; <S2SV_EndBug> }
","<S2SV_ModStart> tmp ) { goto softfail <S2SV_ModEnd> ; } case <S2SV_ModStart> ) ) { goto softfail <S2SV_ModEnd> ; } state <S2SV_ModStart> end ) ; softfail : state -> offset = 0 ;
"
271,"CWE-17 static int attach_child_main ( void * data ) { struct attach_clone_payload * payload = ( struct attach_clone_payload * ) data ; int ipc_socket = payload -> ipc_socket ; <S2SV_StartBug> lxc_attach_options_t * options = payload -> options ; <S2SV_EndBug> struct lxc_proc_context_info * init_ctx = payload -> init_ctx ; # if HAVE_SYS_PERSONALITY_H long new_personality ; # endif int ret ; int status ; int expected ; long flags ; int fd ; uid_t new_uid ; gid_t new_gid ; expected = 0 ; status = - 1 ; ret = lxc_read_nointr_expect ( ipc_socket , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) { ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>(0)"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } if ( ! ( options -> namespaces & CLONE_NEWNS ) && ( options -> attach_flags & LXC_ATTACH_REMOUNT_PROC_SYS ) ) { ret = lxc_attach_remount_sys_proc ( ) ; if ( ret < 0 ) { shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } # if HAVE_SYS_PERSONALITY_H if ( options -> personality < 0 ) new_personality = init_ctx -> personality ; else new_personality = options -> personality ; if ( options -> attach_flags & LXC_ATTACH_SET_PERSONALITY ) { ret = personality ( new_personality ) ; if ( ret < 0 ) { SYSERROR ( ""could<S2SV_blank>not<S2SV_blank>ensure<S2SV_blank>correct<S2SV_blank>architecture"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } # endif if ( options -> attach_flags & LXC_ATTACH_DROP_CAPABILITIES ) { ret = lxc_attach_drop_privs ( init_ctx ) ; if ( ret < 0 ) { ERROR ( ""could<S2SV_blank>not<S2SV_blank>drop<S2SV_blank>privileges"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } ret = lxc_attach_set_environment ( options -> env_policy , options -> extra_env_vars , options -> extra_keep_env ) ; if ( ret < 0 ) { ERROR ( ""could<S2SV_blank>not<S2SV_blank>set<S2SV_blank>initial<S2SV_blank>environment<S2SV_blank>for<S2SV_blank>attached<S2SV_blank>process"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } new_uid = 0 ; new_gid = 0 ; if ( options -> namespaces & CLONE_NEWUSER ) lxc_attach_get_init_uidgid ( & new_uid , & new_gid ) ; if ( options -> uid != ( uid_t ) - 1 ) new_uid = options -> uid ; if ( options -> gid != ( gid_t ) - 1 ) new_gid = options -> gid ; if ( options -> stdin_fd && isatty ( options -> stdin_fd ) ) { if ( setsid ( ) < 0 ) { SYSERROR ( ""unable<S2SV_blank>to<S2SV_blank>setsid"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } if ( ioctl ( options -> stdin_fd , TIOCSCTTY , ( char * ) NULL ) < 0 ) { SYSERROR ( ""unable<S2SV_blank>to<S2SV_blank>TIOCSTTY"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } if ( ( new_gid != 0 || options -> namespaces & CLONE_NEWUSER ) ) { if ( setgid ( new_gid ) || setgroups ( 0 , NULL ) ) { SYSERROR ( ""switching<S2SV_blank>to<S2SV_blank>container<S2SV_blank>gid"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } if ( ( new_uid != 0 || options -> namespaces & CLONE_NEWUSER ) && setuid ( new_uid ) ) { SYSERROR ( ""switching<S2SV_blank>to<S2SV_blank>container<S2SV_blank>uid"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } status = 1 ; ret = lxc_write_nointr ( ipc_socket , & status , sizeof ( status ) ) ; if ( ret != sizeof ( status ) ) { ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(1)"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } expected = 2 ; status = - 1 ; ret = lxc_read_nointr_expect ( ipc_socket , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) { ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>final<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>(2)"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } shutdown ( ipc_socket , SHUT_RDWR ) ; close ( ipc_socket ) ; <S2SV_StartBug> if ( ( options -> namespaces & CLONE_NEWNS ) && ( options -> attach_flags & LXC_ATTACH_LSM ) ) { <S2SV_EndBug> int on_exec ; <S2SV_StartBug> int proc_mounted ; <S2SV_EndBug> on_exec = options -> attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0 ; <S2SV_StartBug> proc_mounted = mount_proc_if_needed ( ""/"" ) ; <S2SV_EndBug> if ( proc_mounted == - 1 ) { ERROR ( ""Error<S2SV_blank>mounting<S2SV_blank>a<S2SV_blank>sane<S2SV_blank>/proc"" ) ; rexit ( - 1 ) ; } <S2SV_StartBug> ret = lsm_process_label_set ( init_ctx -> lsm_label , <S2SV_EndBug> init_ctx -> container -> lxc_conf , 0 , on_exec ) ; if ( proc_mounted ) umount ( ""/proc"" ) ; if ( ret < 0 ) { rexit ( - 1 ) ; } } if ( init_ctx -> container && init_ctx -> container -> lxc_conf && lxc_seccomp_load ( init_ctx -> container -> lxc_conf ) != 0 ) { ERROR ( ""Loading<S2SV_blank>seccomp<S2SV_blank>policy"" ) ; rexit ( - 1 ) ; } lxc_proc_put_context_info ( init_ctx ) ; if ( options -> stdin_fd >= 0 && options -> stdin_fd != 0 ) dup2 ( options -> stdin_fd , 0 ) ; if ( options -> stdout_fd >= 0 && options -> stdout_fd != 1 ) dup2 ( options -> stdout_fd , 1 ) ; if ( options -> stderr_fd >= 0 && options -> stderr_fd != 2 ) dup2 ( options -> stderr_fd , 2 ) ; if ( options -> stdin_fd > 2 ) close ( options -> stdin_fd ) ; if ( options -> stdout_fd > 2 ) close ( options -> stdout_fd ) ; if ( options -> stderr_fd > 2 ) close ( options -> stderr_fd ) ; for ( fd = 0 ; fd <= 2 ; fd ++ ) { flags = fcntl ( fd , F_GETFL ) ; if ( flags < 0 ) continue ; if ( flags & FD_CLOEXEC ) { if ( fcntl ( fd , F_SETFL , flags & ~ FD_CLOEXEC ) < 0 ) { SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>clear<S2SV_blank>CLOEXEC<S2SV_blank>from<S2SV_blank>fd"" ) ; } } } <S2SV_StartBug> rexit ( payload -> exec_function ( payload -> exec_payload ) ) ; <S2SV_EndBug> }
","<S2SV_ModStart> -> ipc_socket ; int procfd = payload -> procfd ; <S2SV_ModStart> & LXC_ATTACH_LSM ) && init_ctx -> lsm_label <S2SV_ModStart> int on_exec ; <S2SV_ModEnd> on_exec = options <S2SV_ModStart> : 0 ; if ( lsm_set_label_at ( procfd , on_exec , <S2SV_ModEnd> init_ctx -> lsm_label <S2SV_ModStart> init_ctx -> lsm_label ) <S2SV_ModEnd> < 0 ) <S2SV_ModStart> } } } close ( procfd ) ;
"
272,"CWE-119 <S2SV_StartBug> void usage_exit ( ) { <S2SV_EndBug> fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank><codec><S2SV_blank><width><S2SV_blank><height><S2SV_blank><infile><S2SV_blank><outfile><S2SV_blank>"" ""<keyframe-interval><S2SV_blank>[<error-resilient>]\\nSee<S2SV_blank>comments<S2SV_blank>in<S2SV_blank>"" ""simple_encoder.c<S2SV_blank>for<S2SV_blank>more<S2SV_blank>information.\\n"" , exec_name ) ; exit ( EXIT_FAILURE ) ; }
","<S2SV_ModStart> void usage_exit ( void
"
273,"CWE-772 generic_ret * rename_principal_2_svc ( rprinc_arg * arg , struct svc_req * rqstp ) { static generic_ret ret ; <S2SV_StartBug> char * prime_arg1 , <S2SV_EndBug> * prime_arg2 ; <S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; restriction_t * rp ; const char * errmsg = NULL ; size_t tlen1 , tlen2 , clen , slen ; char * tdots1 , * tdots2 , * cdots , * sdots ; xdr_free ( xdr_generic_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> src , & prime_arg1 ) || krb5_unparse_name ( handle -> context , arg -> dest , & prime_arg2 ) ) { ret . code = KADM5_BAD_PRINCIPAL ; goto exit_func ; } tlen1 = strlen ( prime_arg1 ) ; trunc_name ( & tlen1 , & tdots1 ) ; tlen2 = strlen ( prime_arg2 ) ; trunc_name ( & tlen2 , & tdots2 ) ; clen = client_name . length ; trunc_name ( & clen , & cdots ) ; slen = service_name . length ; trunc_name ( & slen , & sdots ) ; ret . code = KADM5_OK ; if ( ! CHANGEPW_SERVICE ( rqstp ) ) { if ( ! kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_DELETE , arg -> src , NULL ) ) ret . code = KADM5_AUTH_DELETE ; if ( ! kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_ADD , arg -> dest , & rp ) || rp ) { if ( ret . code == KADM5_AUTH_DELETE ) ret . code = KADM5_AUTH_INSUFFICIENT ; else ret . code = KADM5_AUTH_ADD ; } } else ret . code = KADM5_AUTH_INSUFFICIENT ; if ( ret . code != KADM5_OK ) { krb5_klog_syslog ( LOG_NOTICE , _ ( ""Unauthorized<S2SV_blank>request:<S2SV_blank>kadm5_rename_principal,<S2SV_blank>"" ""%.*s%s<S2SV_blank>to<S2SV_blank>%.*s%s,<S2SV_blank>"" ""client=%.*s%s,<S2SV_blank>service=%.*s%s,<S2SV_blank>addr=%s"" ) , ( int ) tlen1 , prime_arg1 , tdots1 , ( int ) tlen2 , prime_arg2 , tdots2 , ( int ) clen , ( char * ) client_name . value , cdots , ( int ) slen , ( char * ) service_name . value , sdots , client_addr ( rqstp -> rq_xprt ) ) ; } else { ret . code = kadm5_rename_principal ( ( void * ) handle , arg -> src , arg -> dest ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; krb5_klog_syslog ( LOG_NOTICE , _ ( ""Request:<S2SV_blank>kadm5_rename_principal,<S2SV_blank>"" ""%.*s%s<S2SV_blank>to<S2SV_blank>%.*s%s,<S2SV_blank>%s,<S2SV_blank>"" ""client=%.*s%s,<S2SV_blank>service=%.*s%s,<S2SV_blank>addr=%s"" ) , ( int ) tlen1 , prime_arg1 , tdots1 , ( int ) tlen2 , prime_arg2 , tdots2 , errmsg ? errmsg : _ ( ""success"" ) , ( int ) clen , ( char * ) client_name . value , cdots , ( int ) slen , ( char * ) service_name . value , sdots , client_addr ( rqstp -> rq_xprt ) ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } <S2SV_StartBug> free ( prime_arg1 ) ; <S2SV_EndBug> free ( prime_arg2 ) ; gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; exit_func : free_server_handle ( handle ) ; return & ret ; }
","<S2SV_ModStart> char * prime_arg1 = NULL , * prime_arg2 = NULL <S2SV_ModEnd> ; gss_buffer_desc client_name <S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> ) ; } exit_func : free ( prime_arg1 ) ; free ( prime_arg2 ) ; gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
"
274,"CWE-264 int generic_permission ( struct inode * inode , int mask ) { int ret ; ret = acl_permission_check ( inode , mask ) ; if ( ret != - EACCES ) return ret ; if ( S_ISDIR ( inode -> i_mode ) ) { <S2SV_StartBug> if ( inode_capable ( inode , CAP_DAC_OVERRIDE ) ) <S2SV_EndBug> return 0 ; if ( ! ( mask & MAY_WRITE ) ) <S2SV_StartBug> if ( inode_capable ( inode , CAP_DAC_READ_SEARCH ) ) <S2SV_EndBug> return 0 ; return - EACCES ; } if ( ! ( mask & MAY_EXEC ) || ( inode -> i_mode & S_IXUGO ) ) <S2SV_StartBug> if ( inode_capable ( inode , CAP_DAC_OVERRIDE ) ) <S2SV_EndBug> return 0 ; mask &= MAY_READ | MAY_WRITE | MAY_EXEC ; if ( mask == MAY_READ ) <S2SV_StartBug> if ( inode_capable ( inode , CAP_DAC_READ_SEARCH ) ) <S2SV_EndBug> return 0 ; return - EACCES ; }
","<S2SV_ModStart> { if ( capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode , <S2SV_ModStart> ) if ( capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode , <S2SV_ModStart> ) if ( capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode , <S2SV_ModStart> ) if ( capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode ,
"
275,"CWE-787 VOID ixheaacd_shiftrountine_with_rnd_hq ( WORD32 * qmf_real , WORD32 * qmf_imag , WORD32 * filter_states , WORD32 len , WORD32 shift ) { WORD32 * filter_states_rev = filter_states + len ; WORD32 treal , timag ; WORD32 j ; for ( j = ( len - 1 ) ; j >= 0 ; j -= 2 ) { WORD32 r1 , r2 , i1 , i2 ; i2 = qmf_imag [ j ] ; r2 = qmf_real [ j ] ; r1 = * qmf_real ++ ; i1 = * qmf_imag ++ ; <S2SV_StartBug> timag = ixheaacd_add32 ( i1 , r1 ) ; <S2SV_EndBug> timag = ( ixheaacd_shl32_sat ( timag , shift ) ) ; filter_states_rev [ j ] = timag ; <S2SV_StartBug> treal = ixheaacd_sub32 ( i2 , r2 ) ; <S2SV_EndBug> treal = ( ixheaacd_shl32_sat ( treal , shift ) ) ; filter_states [ j ] = treal ; treal = ixheaacd_sub32 ( i1 , r1 ) ; treal = ( ixheaacd_shl32_sat ( treal , shift ) ) ; * filter_states ++ = treal ; timag = ixheaacd_add32 ( i2 , r2 ) ; timag = ( ixheaacd_shl32_sat ( timag , shift ) ) ; * filter_states_rev ++ = timag ; } }
","<S2SV_ModStart> ; timag = ixheaacd_add32_sat <S2SV_ModEnd> ( i1 , <S2SV_ModStart> ; treal = ixheaacd_sub32_sat ( i2 , r2 ) ; treal = ( ixheaacd_shl32_sat ( treal , shift ) ) ; filter_states [ j ] = treal ; treal = ixheaacd_sub32_sat ( i1 , r1 ) ; treal = ( ixheaacd_shl32_sat ( treal , shift ) ) ; * filter_states ++ = treal ; timag = ixheaacd_add32_sat <S2SV_ModEnd> ( i2 ,
"
276,"CWE-119 static void kvp_respond_to_host ( char * key , char * value , int error ) { struct hv_kvp_msg * kvp_msg ; struct hv_kvp_msg_enumerate * kvp_data ; char * key_name ; struct icmsg_hdr * icmsghdrp ; int keylen , valuelen ; u32 buf_len ; struct vmbus_channel * channel ; u64 req_id ; if ( ! kvp_transaction . active ) { pr_warn ( ""KVP:<S2SV_blank>Transaction<S2SV_blank>not<S2SV_blank>active\\n"" ) ; return ; } buf_len = kvp_transaction . recv_len ; channel = kvp_transaction . recv_channel ; req_id = kvp_transaction . recv_req_id ; kvp_transaction . active = false ; if ( channel -> onchannel_callback == NULL ) return ; icmsghdrp = ( struct icmsg_hdr * ) & recv_buffer [ sizeof ( struct vmbuspipe_hdr ) ] ; kvp_msg = ( struct hv_kvp_msg * ) & recv_buffer [ sizeof ( struct vmbuspipe_hdr ) + sizeof ( struct icmsg_hdr ) ] ; kvp_data = & kvp_msg -> kvp_data ; key_name = key ; if ( error ) { icmsghdrp -> status = HV_E_FAIL ; goto response_done ; } <S2SV_StartBug> keylen = utf8s_to_utf16s ( key_name , strlen ( key_name ) , <S2SV_EndBug> <S2SV_StartBug> ( wchar_t * ) kvp_data -> data . key ) ; <S2SV_EndBug> kvp_data -> data . key_size = 2 * ( keylen + 1 ) ; <S2SV_StartBug> valuelen = utf8s_to_utf16s ( value , strlen ( value ) , <S2SV_EndBug> <S2SV_StartBug> ( wchar_t * ) kvp_data -> data . value ) ; <S2SV_EndBug> kvp_data -> data . value_size = 2 * ( valuelen + 1 ) ; kvp_data -> data . value_type = REG_SZ ; icmsghdrp -> status = HV_S_OK ; response_done : icmsghdrp -> icflags = ICMSGHDRFLAG_TRANSACTION | ICMSGHDRFLAG_RESPONSE ; vmbus_sendpacket ( channel , recv_buffer , buf_len , req_id , VM_PKT_DATA_INBAND , 0 ) ; }
","<S2SV_ModStart> key_name ) , UTF16_HOST_ENDIAN , <S2SV_ModStart> data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE / 2 <S2SV_ModStart> value ) , UTF16_HOST_ENDIAN , <S2SV_ModStart> data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE / 2
"
277,"CWE-119 static void Scale2D ( unsigned char * source , int source_pitch , unsigned int source_width , unsigned int source_height , unsigned char * dest , int dest_pitch , unsigned int dest_width , unsigned int dest_height , unsigned char * temp_area , unsigned char temp_area_height , unsigned int hscale , unsigned int hratio , unsigned int vscale , unsigned int vratio , unsigned int interlaced ) { int i , j , k ; int bands ; int dest_band_height ; int source_band_height ; typedef void ( * Scale1D ) ( const unsigned char * source , int source_step , unsigned int source_scale , unsigned int source_length , unsigned char * dest , int dest_step , unsigned int dest_scale , unsigned int dest_length ) ; Scale1D Scale1Dv = scale1d_c ; Scale1D Scale1Dh = scale1d_c ; void ( * horiz_line_scale ) ( const unsigned char * , unsigned int , unsigned char * , unsigned int ) = NULL ; void ( * vert_band_scale ) ( unsigned char * , unsigned int , unsigned char * , unsigned int , unsigned int ) = NULL ; int ratio_scalable = 1 ; int interpolation = 0 ; unsigned char * source_base ; unsigned char * line_src ; source_base = ( unsigned char * ) source ; if ( source_pitch < 0 ) { int offset ; offset = ( source_height - 1 ) ; offset *= source_pitch ; source_base += offset ; } switch ( hratio * 10 / hscale ) { case 8 : horiz_line_scale = vp8_horizontal_line_5_4_scale ; break ; case 6 : horiz_line_scale = vp8_horizontal_line_5_3_scale ; break ; case 5 : horiz_line_scale = vp8_horizontal_line_2_1_scale ; break ; default : ratio_scalable = 0 ; break ; } switch ( vratio * 10 / vscale ) { case 8 : vert_band_scale = vp8_vertical_band_5_4_scale ; source_band_height = 5 ; dest_band_height = 4 ; break ; case 6 : vert_band_scale = vp8_vertical_band_5_3_scale ; source_band_height = 5 ; dest_band_height = 3 ; break ; case 5 : if ( interlaced ) { vert_band_scale = vp8_vertical_band_2_1_scale ; } else { interpolation = 1 ; vert_band_scale = vp8_vertical_band_2_1_scale_i ; } source_band_height = 2 ; dest_band_height = 1 ; break ; default : ratio_scalable = 0 ; break ; } if ( ratio_scalable ) { if ( source_height == dest_height ) { for ( k = 0 ; k < ( int ) dest_height ; k ++ ) { horiz_line_scale ( source , source_width , dest , dest_width ) ; source += source_pitch ; dest += dest_pitch ; } return ; } if ( interpolation ) { if ( source < source_base ) source = source_base ; horiz_line_scale ( source , source_width , temp_area , dest_width ) ; } for ( k = 0 ; k < ( int ) ( dest_height + dest_band_height - 1 ) / dest_band_height ; k ++ ) { for ( i = 0 ; i < source_band_height ; i ++ ) { line_src = ( unsigned char * ) source + i * source_pitch ; if ( line_src < source_base ) line_src = source_base ; horiz_line_scale ( line_src , source_width , temp_area + ( i + 1 ) * dest_pitch , dest_width ) ; } vert_band_scale ( temp_area + dest_pitch , dest_pitch , dest , dest_pitch , dest_width ) ; if ( interpolation ) <S2SV_StartBug> vpx_memcpy ( temp_area , temp_area + source_band_height * dest_pitch , dest_width ) ; <S2SV_EndBug> source += ( unsigned long ) source_band_height * source_pitch ; dest += ( unsigned long ) dest_band_height * dest_pitch ; } return ; } if ( hscale == 2 && hratio == 1 ) Scale1Dh = scale1d_2t1_ps ; if ( vscale == 2 && vratio == 1 ) { if ( interlaced ) Scale1Dv = scale1d_2t1_ps ; else Scale1Dv = scale1d_2t1_i ; } if ( source_height == dest_height ) { for ( k = 0 ; k < ( int ) dest_height ; k ++ ) { Scale1Dh ( source , 1 , hscale , source_width + 1 , dest , 1 , hratio , dest_width ) ; source += source_pitch ; dest += dest_pitch ; } return ; } if ( dest_height > source_height ) { dest_band_height = temp_area_height - 1 ; source_band_height = dest_band_height * source_height / dest_height ; } else { source_band_height = temp_area_height - 1 ; dest_band_height = source_band_height * vratio / vscale ; } Scale1Dh ( source , 1 , hscale , source_width + 1 , temp_area , 1 , hratio , dest_width ) ; bands = ( dest_height + dest_band_height - 1 ) / dest_band_height ; for ( k = 0 ; k < bands ; k ++ ) { for ( i = 1 ; i < source_band_height + 1 ; i ++ ) { if ( k * source_band_height + i < ( int ) source_height ) { Scale1Dh ( source + i * source_pitch , 1 , hscale , source_width + 1 , temp_area + i * dest_pitch , 1 , hratio , dest_width ) ; } else { <S2SV_StartBug> vpx_memcpy ( temp_area + i * dest_pitch , temp_area + ( i - 1 ) * dest_pitch , dest_pitch ) ; <S2SV_EndBug> } } for ( j = 0 ; j < ( int ) dest_width ; j ++ ) { Scale1Dv ( & temp_area [ j ] , dest_pitch , vscale , source_band_height + 1 , & dest [ j ] , dest_pitch , vratio , dest_band_height ) ; } <S2SV_StartBug> vpx_memcpy ( temp_area , temp_area + source_band_height * dest_pitch , dest_pitch ) ; <S2SV_EndBug> source += source_band_height * source_pitch ; dest += dest_band_height * dest_pitch ; } }
","<S2SV_ModStart> ( interpolation ) memcpy <S2SV_ModEnd> ( temp_area , <S2SV_ModStart> } else { memcpy <S2SV_ModEnd> ( temp_area + <S2SV_ModStart> ) ; } memcpy <S2SV_ModEnd> ( temp_area ,
"
278,"CWE-119 static int kill_something_info ( int sig , struct siginfo * info , pid_t pid ) { int ret ; if ( pid > 0 ) { rcu_read_lock ( ) ; ret = kill_pid_info ( sig , info , find_vpid ( pid ) ) ; rcu_read_unlock ( ) ; return ret ; <S2SV_StartBug> } <S2SV_EndBug> read_lock ( & tasklist_lock ) ; if ( pid != - 1 ) { ret = __kill_pgrp_info ( sig , info , pid ? find_vpid ( - pid ) : task_pgrp ( current ) ) ; } else { int retval = 0 , count = 0 ; struct task_struct * p ; for_each_process ( p ) { if ( task_pid_vnr ( p ) > 1 && ! same_thread_group ( p , current ) ) { int err = group_send_sig_info ( sig , info , p ) ; ++ count ; if ( err != - EPERM ) retval = err ; } } ret = count ? retval : - ESRCH ; } read_unlock ( & tasklist_lock ) ; return ret ; }
","<S2SV_ModStart> ret ; } if ( pid == INT_MIN ) return - ESRCH ;
"
279,"CWE-362 SYSCALL_DEFINE3 ( shmctl , int , shmid , int , cmd , struct shmid_ds __user * , buf ) { struct shmid_kernel * shp ; int err , version ; struct ipc_namespace * ns ; if ( cmd < 0 || shmid < 0 ) return - EINVAL ; version = ipc_parse_version ( & cmd ) ; ns = current -> nsproxy -> ipc_ns ; switch ( cmd ) { case IPC_INFO : case SHM_INFO : case SHM_STAT : case IPC_STAT : return shmctl_nolock ( ns , shmid , cmd , version , buf ) ; case IPC_RMID : case IPC_SET : return shmctl_down ( ns , shmid , cmd , buf , version ) ; case SHM_LOCK : case SHM_UNLOCK : { struct file * shm_file ; rcu_read_lock ( ) ; shp = shm_obtain_object_check ( ns , shmid ) ; if ( IS_ERR ( shp ) ) { err = PTR_ERR ( shp ) ; goto out_unlock1 ; } audit_ipc_obj ( & ( shp -> shm_perm ) ) ; err = security_shm_shmctl ( shp , cmd ) ; if ( err ) goto out_unlock1 ; ipc_lock_object ( & shp -> shm_perm ) ; if ( ! ns_capable ( ns -> user_ns , CAP_IPC_LOCK ) ) { kuid_t euid = current_euid ( ) ; err = - EPERM ; if ( ! uid_eq ( euid , shp -> shm_perm . uid ) && ! uid_eq ( euid , shp -> shm_perm . cuid ) ) goto out_unlock0 ; if ( cmd == SHM_LOCK && ! rlimit ( RLIMIT_MEMLOCK ) ) goto out_unlock0 ; } shm_file = shp -> shm_file ; <S2SV_StartBug> if ( is_file_hugepages ( shm_file ) ) <S2SV_EndBug> goto out_unlock0 ; if ( cmd == SHM_LOCK ) { struct user_struct * user = current_user ( ) ; err = shmem_lock ( shm_file , 1 , user ) ; if ( ! err && ! ( shp -> shm_perm . mode & SHM_LOCKED ) ) { shp -> shm_perm . mode |= SHM_LOCKED ; shp -> mlock_user = user ; } goto out_unlock0 ; } if ( ! ( shp -> shm_perm . mode & SHM_LOCKED ) ) goto out_unlock0 ; shmem_lock ( shm_file , 0 , shp -> mlock_user ) ; shp -> shm_perm . mode &= ~ SHM_LOCKED ; shp -> mlock_user = NULL ; get_file ( shm_file ) ; ipc_unlock_object ( & shp -> shm_perm ) ; rcu_read_unlock ( ) ; shmem_unlock_mapping ( shm_file -> f_mapping ) ; fput ( shm_file ) ; return err ; } default : return - EINVAL ; } out_unlock0 : ipc_unlock_object ( & shp -> shm_perm ) ; out_unlock1 : rcu_read_unlock ( ) ; return err ; }
","<S2SV_ModStart> ; if ( shm_file == NULL ) { err = - EIDRM ; goto out_unlock0 ; } if (
"
280,"CWE-787 static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) { EXRContext * s = avctx -> priv_data ; ThreadFrame frame = { . f = data } ; AVFrame * picture = data ; uint8_t * ptr ; int i , y , ret , ymax ; int planes ; int out_line_size ; int nb_blocks ; uint64_t start_offset_table ; uint64_t start_next_scanline ; PutByteContext offset_table_writer ; bytestream2_init ( & s -> gb , avpkt -> data , avpkt -> size ) ; if ( ( ret = decode_header ( s , picture ) ) < 0 ) return ret ; switch ( s -> pixel_type ) { case EXR_FLOAT : case EXR_HALF : if ( s -> channel_offsets [ 3 ] >= 0 ) { if ( ! s -> is_luma ) { avctx -> pix_fmt = AV_PIX_FMT_GBRAPF32 ; } else { avctx -> pix_fmt = AV_PIX_FMT_GBRAPF32 ; } } else { if ( ! s -> is_luma ) { avctx -> pix_fmt = AV_PIX_FMT_GBRPF32 ; } else { avctx -> pix_fmt = AV_PIX_FMT_GRAYF32 ; } } break ; case EXR_UINT : if ( s -> channel_offsets [ 3 ] >= 0 ) { if ( ! s -> is_luma ) { avctx -> pix_fmt = AV_PIX_FMT_RGBA64 ; } else { avctx -> pix_fmt = AV_PIX_FMT_YA16 ; } } else { if ( ! s -> is_luma ) { avctx -> pix_fmt = AV_PIX_FMT_RGB48 ; } else { avctx -> pix_fmt = AV_PIX_FMT_GRAY16 ; } } break ; default : av_log ( avctx , AV_LOG_ERROR , ""Missing<S2SV_blank>channel<S2SV_blank>list.\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( s -> apply_trc_type != AVCOL_TRC_UNSPECIFIED ) avctx -> color_trc = s -> apply_trc_type ; switch ( s -> compression ) { case EXR_RAW : case EXR_RLE : case EXR_ZIP1 : s -> scan_lines_per_block = 1 ; break ; case EXR_PXR24 : case EXR_ZIP16 : s -> scan_lines_per_block = 16 ; break ; case EXR_PIZ : case EXR_B44 : case EXR_B44A : s -> scan_lines_per_block = 32 ; break ; default : avpriv_report_missing_feature ( avctx , ""Compression<S2SV_blank>%d"" , s -> compression ) ; return AVERROR_PATCHWELCOME ; } if ( s -> xmin > s -> xmax || s -> ymin > s -> ymax || s -> ydelta == 0xFFFFFFFF || s -> xdelta == 0xFFFFFFFF ) { av_log ( avctx , AV_LOG_ERROR , ""Wrong<S2SV_blank>or<S2SV_blank>missing<S2SV_blank>size<S2SV_blank>information.\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( ( ret = ff_set_dimensions ( avctx , s -> w , s -> h ) ) < 0 ) return ret ; s -> desc = av_pix_fmt_desc_get ( avctx -> pix_fmt ) ; if ( ! s -> desc ) return AVERROR_INVALIDDATA ; if ( s -> desc -> flags & AV_PIX_FMT_FLAG_FLOAT ) { planes = s -> desc -> nb_components ; out_line_size = avctx -> width * 4 ; } else { planes = 1 ; out_line_size = avctx -> width * 2 * s -> desc -> nb_components ; } if ( s -> is_tile ) { nb_blocks = ( ( s -> xdelta + s -> tile_attr . xSize - 1 ) / s -> tile_attr . xSize ) * ( ( s -> ydelta + s -> tile_attr . ySize - 1 ) / s -> tile_attr . ySize ) ; } else { nb_blocks = ( s -> ydelta + s -> scan_lines_per_block - 1 ) / s -> scan_lines_per_block ; } if ( ( ret = ff_thread_get_buffer ( avctx , & frame , 0 ) ) < 0 ) return ret ; if ( bytestream2_get_bytes_left ( & s -> gb ) / 8 < nb_blocks ) return AVERROR_INVALIDDATA ; if ( ! s -> is_tile && bytestream2_peek_le64 ( & s -> gb ) == 0 ) { av_log ( s -> avctx , AV_LOG_DEBUG , ""recreating<S2SV_blank>invalid<S2SV_blank>scanline<S2SV_blank>offset<S2SV_blank>table\\n"" ) ; start_offset_table = bytestream2_tell ( & s -> gb ) ; start_next_scanline = start_offset_table + nb_blocks * 8 ; bytestream2_init_writer ( & offset_table_writer , & avpkt -> data [ start_offset_table ] , nb_blocks * 8 ) ; for ( y = 0 ; y < nb_blocks ; y ++ ) { bytestream2_put_le64 ( & offset_table_writer , start_next_scanline ) ; bytestream2_seek ( & s -> gb , start_next_scanline + 4 , SEEK_SET ) ; start_next_scanline += ( bytestream2_get_le32 ( & s -> gb ) + 8 ) ; } bytestream2_seek ( & s -> gb , start_offset_table , SEEK_SET ) ; } s -> buf = avpkt -> data ; s -> buf_size = avpkt -> size ; for ( i = 0 ; i < planes ; i ++ ) { ptr = picture -> data [ i ] ; <S2SV_StartBug> for ( y = 0 ; y < s -> ymin ; y ++ ) { <S2SV_EndBug> memset ( ptr , 0 , out_line_size ) ; ptr += picture -> linesize [ i ] ; } } s -> picture = picture ; avctx -> execute2 ( avctx , decode_block , s -> thread_data , NULL , nb_blocks ) ; ymax = FFMAX ( 0 , s -> ymax + 1 ) ; for ( i = 0 ; i < planes ; i ++ ) { ptr = picture -> data [ i ] + ( ymax * picture -> linesize [ i ] ) ; for ( y = ymax ; y < avctx -> height ; y ++ ) { memset ( ptr , 0 , out_line_size ) ; ptr += picture -> linesize [ i ] ; } } picture -> pict_type = AV_PICTURE_TYPE_I ; * got_frame = 1 ; return avpkt -> size ; }
","<S2SV_ModStart> ; y < FFMIN ( <S2SV_ModStart> s -> ymin , s -> h )
"
281,"CWE-000 static int tty_open ( struct inode * inode , struct file * filp ) { struct tty_struct * tty = NULL ; int noctty , retval ; struct tty_driver * driver ; int index ; dev_t device = inode -> i_rdev ; unsigned saved_flags = filp -> f_flags ; nonseekable_open ( inode , filp ) ; retry_open : noctty = filp -> f_flags & O_NOCTTY ; index = - 1 ; retval = 0 ; mutex_lock ( & tty_mutex ) ; tty_lock ( ) ; if ( device == MKDEV ( TTYAUX_MAJOR , 0 ) ) { tty = get_current_tty ( ) ; if ( ! tty ) { tty_unlock ( ) ; mutex_unlock ( & tty_mutex ) ; return - ENXIO ; } driver = tty_driver_kref_get ( tty -> driver ) ; index = tty -> index ; filp -> f_flags |= O_NONBLOCK ; tty_kref_put ( tty ) ; goto got_driver ; } # ifdef CONFIG_VT if ( device == MKDEV ( TTY_MAJOR , 0 ) ) { extern struct tty_driver * console_driver ; driver = tty_driver_kref_get ( console_driver ) ; index = fg_console ; noctty = 1 ; goto got_driver ; } # endif if ( device == MKDEV ( TTYAUX_MAJOR , 1 ) ) { struct tty_driver * console_driver = console_device ( & index ) ; if ( console_driver ) { driver = tty_driver_kref_get ( console_driver ) ; if ( driver ) { filp -> f_flags |= O_NONBLOCK ; noctty = 1 ; goto got_driver ; } } tty_unlock ( ) ; mutex_unlock ( & tty_mutex ) ; return - ENODEV ; } driver = get_tty_driver ( device , & index ) ; if ( ! driver ) { tty_unlock ( ) ; mutex_unlock ( & tty_mutex ) ; return - ENODEV ; } got_driver : if ( ! tty ) { tty = tty_driver_lookup_tty ( driver , inode , index ) ; if ( IS_ERR ( tty ) ) { tty_unlock ( ) ; mutex_unlock ( & tty_mutex ) ; <S2SV_StartBug> return PTR_ERR ( tty ) ; <S2SV_EndBug> } } if ( tty ) { retval = tty_reopen ( tty ) ; if ( retval ) tty = ERR_PTR ( retval ) ; } else tty = tty_init_dev ( driver , index , 0 ) ; mutex_unlock ( & tty_mutex ) ; tty_driver_kref_put ( driver ) ; if ( IS_ERR ( tty ) ) { tty_unlock ( ) ; return PTR_ERR ( tty ) ; } retval = tty_add_file ( tty , filp ) ; if ( retval ) { tty_unlock ( ) ; tty_release ( inode , filp ) ; return retval ; } check_tty_count ( tty , ""tty_open"" ) ; if ( tty -> driver -> type == TTY_DRIVER_TYPE_PTY && tty -> driver -> subtype == PTY_TYPE_MASTER ) noctty = 1 ; # ifdef TTY_DEBUG_HANGUP printk ( KERN_DEBUG ""opening<S2SV_blank>%s..."" , tty -> name ) ; # endif if ( tty -> ops -> open ) retval = tty -> ops -> open ( tty , filp ) ; else retval = - ENODEV ; filp -> f_flags = saved_flags ; if ( ! retval && test_bit ( TTY_EXCLUSIVE , & tty -> flags ) && ! capable ( CAP_SYS_ADMIN ) ) retval = - EBUSY ; if ( retval ) { # ifdef TTY_DEBUG_HANGUP printk ( KERN_DEBUG ""error<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>opening<S2SV_blank>%s..."" , retval , tty -> name ) ; # endif tty_unlock ( ) ; tty_release ( inode , filp ) ; if ( retval != - ERESTARTSYS ) return retval ; if ( signal_pending ( current ) ) return retval ; schedule ( ) ; tty_lock ( ) ; if ( filp -> f_op == & hung_up_tty_fops ) filp -> f_op = & tty_fops ; tty_unlock ( ) ; goto retry_open ; } tty_unlock ( ) ; mutex_lock ( & tty_mutex ) ; tty_lock ( ) ; spin_lock_irq ( & current -> sighand -> siglock ) ; if ( ! noctty && current -> signal -> leader && ! current -> signal -> tty && tty -> session == NULL ) __proc_set_tty ( current , tty ) ; spin_unlock_irq ( & current -> sighand -> siglock ) ; tty_unlock ( ) ; mutex_unlock ( & tty_mutex ) ; return 0 ; }
","<S2SV_ModStart> tty_mutex ) ; tty_driver_kref_put ( driver ) ;
"
282,"CWE-285 int ext2_set_acl ( struct inode * inode , struct posix_acl * acl , int type ) { int name_index ; void * value = NULL ; size_t size = 0 ; int error ; switch ( type ) { case ACL_TYPE_ACCESS : name_index = EXT2_XATTR_INDEX_POSIX_ACL_ACCESS ; if ( acl ) { <S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> if ( error < 0 ) return error ; else { inode -> i_ctime = CURRENT_TIME_SEC ; mark_inode_dirty ( inode ) ; <S2SV_StartBug> if ( error == 0 ) <S2SV_EndBug> acl = NULL ; } } break ; case ACL_TYPE_DEFAULT : name_index = EXT2_XATTR_INDEX_POSIX_ACL_DEFAULT ; if ( ! S_ISDIR ( inode -> i_mode ) ) return acl ? - EACCES : 0 ; break ; default : return - EINVAL ; } if ( acl ) { value = ext2_acl_to_disk ( acl , & size ) ; if ( IS_ERR ( value ) ) return ( int ) PTR_ERR ( value ) ; } error = ext2_xattr_set ( inode , name_index , """" , value , size , 0 ) ; kfree ( value ) ; if ( ! error ) set_cached_acl ( inode , type , acl ) ; return error ; }
","<S2SV_ModStart> { error = posix_acl_update_mode ( inode <S2SV_ModEnd> , & inode <S2SV_ModStart> inode -> i_mode , & acl ) ; if ( error ) return error ; <S2SV_ModEnd> inode -> i_ctime <S2SV_ModStart> inode ) ; <S2SV_ModEnd> } break ;
"
283,"CWE-772 int sas_smp_get_phy_events ( struct sas_phy * phy ) { int res ; u8 * req ; u8 * resp ; struct sas_rphy * rphy = dev_to_rphy ( phy -> dev . parent ) ; struct domain_device * dev = sas_find_dev_by_rphy ( rphy ) ; req = alloc_smp_req ( RPEL_REQ_SIZE ) ; if ( ! req ) return - ENOMEM ; resp = alloc_smp_resp ( RPEL_RESP_SIZE ) ; if ( ! resp ) { kfree ( req ) ; return - ENOMEM ; } req [ 1 ] = SMP_REPORT_PHY_ERR_LOG ; req [ 9 ] = phy -> number ; res = smp_execute_task ( dev , req , RPEL_REQ_SIZE , resp , RPEL_RESP_SIZE ) ; if ( ! res ) goto out ; phy -> invalid_dword_count = scsi_to_u32 ( & resp [ 12 ] ) ; phy -> running_disparity_error_count = scsi_to_u32 ( & resp [ 16 ] ) ; phy -> loss_of_dword_sync_count = scsi_to_u32 ( & resp [ 20 ] ) ; phy -> phy_reset_problem_count = scsi_to_u32 ( & resp [ 24 ] ) ; out : <S2SV_StartBug> kfree ( resp ) ; <S2SV_EndBug> return res ; }
","<S2SV_ModStart> : kfree ( req ) ; kfree (
"
284,"CWE-189 Datum poly_in ( PG_FUNCTION_ARGS ) { char * str = PG_GETARG_CSTRING ( 0 ) ; POLYGON * poly ; int npts ; int size ; <S2SV_StartBug> int isopen ; <S2SV_EndBug> char * s ; if ( ( npts = pair_count ( str , ',' ) ) <= 0 ) ereport ( ERROR , ( errcode ( ERRCODE_INVALID_TEXT_REPRESENTATION ) , errmsg ( ""invalid<S2SV_blank>input<S2SV_blank>syntax<S2SV_blank>for<S2SV_blank>type<S2SV_blank>polygon:<S2SV_blank>\\""%s\\"""" , str ) ) ) ; <S2SV_StartBug> size = offsetof ( POLYGON , p [ 0 ] ) + sizeof ( poly -> p [ 0 ] ) * npts ; <S2SV_EndBug> poly = ( POLYGON * ) palloc0 ( size ) ; SET_VARSIZE ( poly , size ) ; poly -> npts = npts ; if ( ( ! path_decode ( FALSE , npts , str , & isopen , & s , & ( poly -> p [ 0 ] ) ) ) || ( * s != '\\0' ) ) ereport ( ERROR , ( errcode ( ERRCODE_INVALID_TEXT_REPRESENTATION ) , errmsg ( ""invalid<S2SV_blank>input<S2SV_blank>syntax<S2SV_blank>for<S2SV_blank>type<S2SV_blank>polygon:<S2SV_blank>\\""%s\\"""" , str ) ) ) ; make_bound_box ( poly ) ; PG_RETURN_POLYGON_P ( poly ) ; }
","<S2SV_ModStart> size ; int base_size ; int <S2SV_ModStart> ) ) ; base_size = sizeof ( poly -> p [ 0 ] ) * npts ; <S2SV_ModStart> ] ) + base_size ; if ( base_size / npts != <S2SV_ModStart> 0 ] ) || size <= base_size ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""too<S2SV_blank>many<S2SV_blank>points<S2SV_blank>requested"" ) ) ) <S2SV_ModEnd> ; poly =
"
285,"CWE-264 int create_user_ns ( struct cred * new ) { struct user_namespace * ns , * parent_ns = new -> user_ns ; kuid_t owner = new -> euid ; kgid_t group = new -> egid ; <S2SV_StartBug> int ret ; <S2SV_EndBug> if ( ! kuid_has_mapping ( parent_ns , owner ) || ! kgid_has_mapping ( parent_ns , group ) ) return - EPERM ; ns = kmem_cache_zalloc ( user_ns_cachep , GFP_KERNEL ) ; if ( ! ns ) return - ENOMEM ; ret = proc_alloc_inum ( & ns -> proc_inum ) ; if ( ret ) { kmem_cache_free ( user_ns_cachep , ns ) ; return ret ; } atomic_set ( & ns -> count , 1 ) ; ns -> parent = parent_ns ; ns -> owner = owner ; ns -> group = group ; set_cred_user_ns ( new , ns ) ; return 0 ; }
","<S2SV_ModStart> ; int ret ; if ( current_chrooted ( ) ) return - EPERM
"
286,"CWE-20 static Image * ReadPICTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { <S2SV_StartBug> # define ThrowPICTException ( exception , message ) { if ( tile_image != ( Image * ) NULL ) tile_image = DestroyImage ( tile_image ) ; if ( read_info != ( ImageInfo * ) NULL ) read_info = DestroyImageInfo ( read_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> char geometry [ MagickPathExtent ] , header_ole [ 4 ] ; Image * image , * tile_image ; ImageInfo * read_info ; int c , code ; MagickBooleanType jpeg , status ; PICTRectangle frame ; PICTPixmap pixmap ; Quantum index ; register Quantum * q ; register ssize_t i , x ; size_t extent , length ; ssize_t count , flags , j , version , y ; StringInfo * profile ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } read_info = ( ImageInfo * ) NULL ; tile_image = ( Image * ) NULL ; pixmap . bits_per_pixel = 0 ; pixmap . component_count = 0 ; header_ole [ 0 ] = ReadBlobByte ( image ) ; header_ole [ 1 ] = ReadBlobByte ( image ) ; header_ole [ 2 ] = ReadBlobByte ( image ) ; header_ole [ 3 ] = ReadBlobByte ( image ) ; if ( ! ( ( header_ole [ 0 ] == 0x50 ) && ( header_ole [ 1 ] == 0x49 ) && ( header_ole [ 2 ] == 0x43 ) && ( header_ole [ 3 ] == 0x54 ) ) ) for ( i = 0 ; i < 508 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; ( void ) ReadBlobMSBShort ( image ) ; if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; while ( ( c = ReadBlobByte ( image ) ) == 0 ) ; if ( c != 0x11 ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; version = ( ssize_t ) ReadBlobByte ( image ) ; if ( version == 2 ) { c = ReadBlobByte ( image ) ; if ( c != 0xff ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; } else if ( version != 1 ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( frame . left < 0 ) || ( frame . right < 0 ) || ( frame . top < 0 ) || ( frame . bottom < 0 ) || ( frame . left >= frame . right ) || ( frame . top >= frame . bottom ) ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; flags = 0 ; image -> depth = 8 ; image -> columns = ( size_t ) ( frame . right - frame . left ) ; image -> rows = ( size_t ) ( frame . bottom - frame . top ) ; image -> resolution . x = DefaultResolution ; image -> resolution . y = DefaultResolution ; image -> units = UndefinedResolution ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status != MagickFalse ) status = ResetImagePixels ( image , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; jpeg = MagickFalse ; for ( code = 0 ; EOFBlob ( image ) == MagickFalse ; ) { if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( ( version == 1 ) || ( ( TellBlob ( image ) % 2 ) != 0 ) ) code = ReadBlobByte ( image ) ; if ( version == 2 ) code = ReadBlobMSBSignedShort ( image ) ; if ( code < 0 ) break ; if ( code == 0 ) continue ; if ( code > 0xa1 ) { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""%04X:"" , code ) ; } else { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>%04X<S2SV_blank>%s:<S2SV_blank>%s"" , code , codes [ code ] . name , codes [ code ] . description ) ; switch ( code ) { case 0x01 : { length = ReadBlobMSBShort ( image ) ; <S2SV_StartBug> if ( length != 0x000a ) <S2SV_EndBug> { for ( i = 0 ; i < ( ssize_t ) ( length - 2 ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; break ; } if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( ( frame . left & 0x8000 ) != 0 ) || ( ( frame . top & 0x8000 ) != 0 ) ) break ; image -> columns = ( size_t ) ( frame . right - frame . left ) ; image -> rows = ( size_t ) ( frame . bottom - frame . top ) ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status != MagickFalse ) status = ResetImagePixels ( image , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; break ; } case 0x12 : case 0x13 : case 0x14 : { ssize_t pattern ; size_t height , width ; pattern = ( ssize_t ) ReadBlobMSBShort ( image ) ; for ( i = 0 ; i < 8 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; if ( pattern == 2 ) { for ( i = 0 ; i < 5 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; break ; } if ( pattern != 1 ) ThrowPICTException ( CorruptImageError , ""UnknownPatternType"" ) ; length = ReadBlobMSBShort ( image ) ; <S2SV_StartBug> if ( ReadRectangle ( image , & frame ) == MagickFalse ) <S2SV_EndBug> ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ReadPixmap ( image , & pixmap ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> depth = ( size_t ) pixmap . component_size ; image -> resolution . x = 1.0 * pixmap . horizontal_resolution ; image -> resolution . y = 1.0 * pixmap . vertical_resolution ; image -> units = PixelsPerInchResolution ; ( void ) ReadBlobMSBLong ( image ) ; flags = ( ssize_t ) ReadBlobMSBShort ( image ) ; <S2SV_StartBug> length = ReadBlobMSBShort ( image ) ; <S2SV_EndBug> for ( i = 0 ; i <= ( ssize_t ) length ; i ++ ) ( void ) ReadBlobMSBLong ( image ) ; width = ( size_t ) ( frame . bottom - frame . top ) ; height = ( size_t ) ( frame . right - frame . left ) ; if ( pixmap . bits_per_pixel <= 8 ) length &= 0x7fff ; if ( pixmap . bits_per_pixel == 16 ) width <<= 1 ; if ( length == 0 ) length = width ; if ( length < 8 ) { for ( i = 0 ; i < ( ssize_t ) ( length * height ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } else for ( i = 0 ; i < ( ssize_t ) height ; i ++ ) { if ( EOFBlob ( image ) != MagickFalse ) break ; if ( length > 200 ) { for ( j = 0 ; j < ( ssize_t ) ReadBlobMSBShort ( image ) ; j ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } else for ( j = 0 ; j < ( ssize_t ) ReadBlobByte ( image ) ; j ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } break ; } case 0x1b : { image -> background_color . red = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; image -> background_color . green = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; image -> background_color . blue = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; break ; } case 0x70 : case 0x71 : case 0x72 : case 0x73 : case 0x74 : case 0x75 : case 0x76 : case 0x77 : { <S2SV_StartBug> length = ReadBlobMSBShort ( image ) ; <S2SV_EndBug> for ( i = 0 ; i < ( ssize_t ) ( length - 2 ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; break ; } case 0x90 : case 0x91 : case 0x98 : case 0x99 : case 0x9a : case 0x9b : { PICTRectangle source , destination ; register unsigned char * p ; size_t j ; ssize_t bytes_per_line ; unsigned char * pixels ; bytes_per_line = 0 ; if ( ( code != 0x9a ) && ( code != 0x9b ) ) bytes_per_line = ( ssize_t ) ReadBlobMSBShort ( image ) ; else { ( void ) ReadBlobMSBShort ( image ) ; ( void ) ReadBlobMSBShort ( image ) ; ( void ) ReadBlobMSBShort ( image ) ; } if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; tile_image = CloneImage ( image , ( size_t ) ( frame . right - frame . left ) , ( size_t ) ( frame . bottom - frame . top ) , MagickTrue , exception ) ; if ( tile_image == ( Image * ) NULL ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( code == 0x9a ) || ( code == 0x9b ) || ( ( bytes_per_line & 0x8000 ) != 0 ) ) { if ( ReadPixmap ( image , & pixmap ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; tile_image -> depth = ( size_t ) pixmap . component_size ; tile_image -> alpha_trait = pixmap . component_count == 4 ? BlendPixelTrait : UndefinedPixelTrait ; tile_image -> resolution . x = ( double ) pixmap . horizontal_resolution ; tile_image -> resolution . y = ( double ) pixmap . vertical_resolution ; tile_image -> units = PixelsPerInchResolution ; if ( tile_image -> alpha_trait != UndefinedPixelTrait ) ( void ) SetImageAlpha ( tile_image , OpaqueAlpha , exception ) ; } if ( ( code != 0x9a ) && ( code != 0x9b ) ) { tile_image -> colors = 2 ; if ( ( bytes_per_line & 0x8000 ) != 0 ) { ( void ) ReadBlobMSBLong ( image ) ; flags = ( ssize_t ) ReadBlobMSBShort ( image ) ; tile_image -> colors = 1UL * ReadBlobMSBShort ( image ) + 1 ; } status = AcquireImageColormap ( tile_image , tile_image -> colors , exception ) ; if ( status == MagickFalse ) ThrowPICTException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( ( bytes_per_line & 0x8000 ) != 0 ) { for ( i = 0 ; i < ( ssize_t ) tile_image -> colors ; i ++ ) { j = ReadBlobMSBShort ( image ) % tile_image -> colors ; if ( ( flags & 0x8000 ) != 0 ) j = ( size_t ) i ; tile_image -> colormap [ j ] . red = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; tile_image -> colormap [ j ] . green = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; tile_image -> colormap [ j ] . blue = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; } } else { for ( i = 0 ; i < ( ssize_t ) tile_image -> colors ; i ++ ) { tile_image -> colormap [ i ] . red = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . red ) ; tile_image -> colormap [ i ] . green = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . green ) ; tile_image -> colormap [ i ] . blue = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . blue ) ; } } } if ( EOFBlob ( image ) != MagickFalse ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( ReadRectangle ( image , & source ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ReadRectangle ( image , & destination ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; ( void ) ReadBlobMSBShort ( image ) ; if ( ( code == 0x91 ) || ( code == 0x99 ) || ( code == 0x9b ) ) { <S2SV_StartBug> length = ReadBlobMSBShort ( image ) ; <S2SV_EndBug> for ( i = 0 ; i < ( ssize_t ) ( length - 2 ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } if ( ( code != 0x9a ) && ( code != 0x9b ) && ( bytes_per_line & 0x8000 ) == 0 ) pixels = DecodeImage ( image , tile_image , ( size_t ) bytes_per_line , 1 , & extent ) ; else pixels = DecodeImage ( image , tile_image , ( size_t ) bytes_per_line , ( unsigned int ) pixmap . bits_per_pixel , & extent ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowPICTException ( CorruptImageError , ""UnableToUncompressImage"" ) ; p = pixels ; for ( y = 0 ; y < ( ssize_t ) tile_image -> rows ; y ++ ) { if ( p > ( pixels + extent + image -> columns ) ) { pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; ThrowPICTException ( CorruptImageError , ""NotEnoughPixelData"" ) ; } q = QueueAuthenticPixels ( tile_image , 0 , y , tile_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) tile_image -> columns ; x ++ ) { if ( tile_image -> storage_class == PseudoClass ) { index = ( Quantum ) ConstrainColormapIndex ( tile_image , ( ssize_t ) * p , exception ) ; SetPixelIndex ( tile_image , index , q ) ; SetPixelRed ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . red , q ) ; SetPixelGreen ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . green , q ) ; SetPixelBlue ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . blue , q ) ; } else { if ( pixmap . bits_per_pixel == 16 ) { i = ( ssize_t ) ( * p ++ ) ; j = ( size_t ) ( * p ) ; SetPixelRed ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( i & 0x7c ) << 1 ) ) , q ) ; SetPixelGreen ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( ( i & 0x03 ) << 6 ) | ( ( j & 0xe0 ) >> 2 ) ) ) , q ) ; SetPixelBlue ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( j & 0x1f ) << 3 ) ) , q ) ; } else if ( tile_image -> alpha_trait == UndefinedPixelTrait ) { if ( p > ( pixels + extent + 2 * image -> columns ) ) ThrowPICTException ( CorruptImageError , ""NotEnoughPixelData"" ) ; SetPixelRed ( tile_image , ScaleCharToQuantum ( * p ) , q ) ; SetPixelGreen ( tile_image , ScaleCharToQuantum ( * ( p + tile_image -> columns ) ) , q ) ; SetPixelBlue ( tile_image , ScaleCharToQuantum ( * ( p + 2 * tile_image -> columns ) ) , q ) ; } else { if ( p > ( pixels + extent + 3 * image -> columns ) ) ThrowPICTException ( CorruptImageError , ""NotEnoughPixelData"" ) ; SetPixelAlpha ( tile_image , ScaleCharToQuantum ( * p ) , q ) ; SetPixelRed ( tile_image , ScaleCharToQuantum ( * ( p + tile_image -> columns ) ) , q ) ; SetPixelGreen ( tile_image , ScaleCharToQuantum ( * ( p + 2 * tile_image -> columns ) ) , q ) ; SetPixelBlue ( tile_image , ScaleCharToQuantum ( * ( p + 3 * tile_image -> columns ) ) , q ) ; } } p ++ ; q += GetPixelChannels ( tile_image ) ; } if ( SyncAuthenticPixels ( tile_image , exception ) == MagickFalse ) break ; if ( ( tile_image -> storage_class == DirectClass ) && ( pixmap . bits_per_pixel != 16 ) ) { p += ( pixmap . component_count - 1 ) * tile_image -> columns ; if ( p < pixels ) break ; } status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , tile_image -> rows ) ; if ( status == MagickFalse ) break ; } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( ( jpeg == MagickFalse ) && ( EOFBlob ( image ) == MagickFalse ) ) if ( ( code == 0x9a ) || ( code == 0x9b ) || ( ( bytes_per_line & 0x8000 ) != 0 ) ) ( void ) CompositeImage ( image , tile_image , CopyCompositeOp , MagickTrue , ( ssize_t ) destination . left , ( ssize_t ) destination . top , exception ) ; tile_image = DestroyImage ( tile_image ) ; break ; } case 0xa1 : { unsigned char * info ; size_t type ; type = ReadBlobMSBShort ( image ) ; length = ReadBlobMSBShort ( image ) ; <S2SV_StartBug> if ( length == 0 ) <S2SV_EndBug> break ; ( void ) ReadBlobMSBLong ( image ) ; length -= MagickMin ( length , 4 ) ; if ( length == 0 ) break ; info = ( unsigned char * ) AcquireQuantumMemory ( length , sizeof ( * info ) ) ; if ( info == ( unsigned char * ) NULL ) break ; count = ReadBlob ( image , length , info ) ; if ( count != ( ssize_t ) length ) { info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; ThrowPICTException ( ResourceLimitError , ""UnableToReadImageData"" ) ; } switch ( type ) { case 0xe0 : { profile = BlobToStringInfo ( ( const void * ) NULL , length ) ; SetStringInfoDatum ( profile , info ) ; status = SetImageProfile ( image , ""icc"" , profile , exception ) ; profile = DestroyStringInfo ( profile ) ; if ( status == MagickFalse ) { info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; ThrowPICTException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } break ; } case 0x1f2 : { profile = BlobToStringInfo ( ( const void * ) NULL , length ) ; SetStringInfoDatum ( profile , info ) ; status = SetImageProfile ( image , ""iptc"" , profile , exception ) ; if ( status == MagickFalse ) { info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; ThrowPICTException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } profile = DestroyStringInfo ( profile ) ; break ; } default : break ; } info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; break ; } default : { if ( codes [ code ] . length == - 1 ) ( void ) ReadBlobMSBShort ( image ) ; else for ( i = 0 ; i < ( ssize_t ) codes [ code ] . length ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } } } if ( code == 0xc00 ) { for ( i = 0 ; i < 24 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; continue ; } if ( ( ( code >= 0xb0 ) && ( code <= 0xcf ) ) || ( ( code >= 0x8000 ) && ( code <= 0x80ff ) ) ) continue ; if ( code == 0x8200 ) { char filename [ MaxTextExtent ] ; FILE * file ; int unique_file ; jpeg = MagickTrue ; read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; ( void ) FormatLocaleString ( read_info -> filename , MaxTextExtent , ""jpeg:%s"" , filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ; if ( ( unique_file == - 1 ) || ( file == ( FILE * ) NULL ) ) { ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; ( void ) CopyMagickString ( image -> filename , read_info -> filename , MagickPathExtent ) ; ThrowPICTException ( FileOpenError , ""UnableToCreateTemporaryFile"" ) ; } length = ReadBlobMSBLong ( image ) ; <S2SV_StartBug> if ( length > 154 ) <S2SV_EndBug> { for ( i = 0 ; i < 6 ; i ++ ) ( void ) ReadBlobMSBLong ( image ) ; if ( ReadRectangle ( image , & frame ) == MagickFalse ) { ( void ) fclose ( file ) ; ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; } for ( i = 0 ; i < 122 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; for ( i = 0 ; i < ( ssize_t ) ( length - 154 ) ; i ++ ) { c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; if ( fputc ( c , file ) != c ) break ; } } ( void ) fclose ( file ) ; ( void ) close ( unique_file ) ; tile_image = ReadImage ( read_info , exception ) ; ( void ) RelinquishUniqueFileResource ( filename ) ; read_info = DestroyImageInfo ( read_info ) ; if ( tile_image == ( Image * ) NULL ) continue ; ( void ) FormatLocaleString ( geometry , MagickPathExtent , ""%.20gx%.20g"" , ( double ) MagickMax ( image -> columns , tile_image -> columns ) , ( double ) MagickMax ( image -> rows , tile_image -> rows ) ) ; ( void ) SetImageExtent ( image , MagickMax ( image -> columns , tile_image -> columns ) , MagickMax ( image -> rows , tile_image -> rows ) , exception ) ; ( void ) TransformImageColorspace ( image , tile_image -> colorspace , exception ) ; ( void ) CompositeImage ( image , tile_image , CopyCompositeOp , MagickTrue , ( ssize_t ) frame . left , ( ssize_t ) frame . right , exception ) ; image -> compression = tile_image -> compression ; tile_image = DestroyImage ( tile_image ) ; continue ; } if ( ( code == 0xff ) || ( code == 0xffff ) ) break ; if ( ( ( code >= 0xd0 ) && ( code <= 0xfe ) ) || ( ( code >= 0x8100 ) && ( code <= 0xffff ) ) ) { length = ReadBlobMSBShort ( image ) ; <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) <S2SV_EndBug> if ( ReadBlobByte ( image ) == EOF ) break ; continue ; } if ( ( code >= 0x100 ) && ( code <= 0x7fff ) ) { length = ( size_t ) ( ( code >> 7 ) & 0xff ) ; <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) <S2SV_EndBug> if ( ReadBlobByte ( image ) == EOF ) break ; continue ; } } ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> , message ) \\\n{ <S2SV_ModEnd> if ( tile_image <S2SV_ModStart> ) ) ; \\\n} <S2SV_ModEnd> char geometry [ <S2SV_ModStart> if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( length <S2SV_ModStart> ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( <S2SV_ModStart> ReadBlobMSBShort ( image ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" <S2SV_ModStart> ReadBlobMSBShort ( image ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" <S2SV_ModStart> ReadBlobMSBShort ( image ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" <S2SV_ModStart> if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( length <S2SV_ModStart> ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( length > <S2SV_ModStart> image ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; <S2SV_ModStart> 0xff ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;
"
287,"CWE-399 static int ceph_x_proc_ticket_reply ( struct ceph_auth_client * ac , struct ceph_crypto_key * secret , void * buf , void * end ) { void * p = buf ; <S2SV_StartBug> char * dbuf ; <S2SV_EndBug> char * ticket_buf ; u8 reply_struct_v ; u32 num ; <S2SV_StartBug> int ret ; <S2SV_EndBug> dbuf = kmalloc ( TEMP_TICKET_BUF_LEN , GFP_NOFS ) ; if ( ! dbuf ) return - ENOMEM ; ret = - ENOMEM ; ticket_buf = kmalloc ( TEMP_TICKET_BUF_LEN , GFP_NOFS ) ; if ( ! ticket_buf ) goto out_dbuf ; ceph_decode_8_safe ( & p , end , reply_struct_v , bad ) ; if ( reply_struct_v != 1 ) return - EINVAL ; ceph_decode_32_safe ( & p , end , num , bad ) ; dout ( ""%d<S2SV_blank>tickets\\n"" , num ) ; while ( num -- ) { <S2SV_StartBug> ret = process_one_ticket ( ac , secret , & p , end , <S2SV_EndBug> dbuf , ticket_buf ) ; if ( ret ) <S2SV_StartBug> goto out ; <S2SV_EndBug> } ret = 0 ; out : kfree ( ticket_buf ) ; out_dbuf : kfree ( dbuf ) ; return ret ; bad : <S2SV_StartBug> ret = - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> }
","<S2SV_ModStart> = buf ; <S2SV_ModEnd> u8 reply_struct_v ; <S2SV_ModStart> ; int ret <S2SV_ModEnd> ; ceph_decode_8_safe ( <S2SV_ModStart> p , end <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( ret ) return ret ; } return 0 <S2SV_ModEnd> ; bad : <S2SV_ModStart> ; bad : return <S2SV_ModEnd> - EINVAL ; <S2SV_ModStart> - EINVAL ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
"
288,"CWE-200 static int raptor_rss_parse_start ( raptor_parser * rdf_parser ) { raptor_uri * uri = rdf_parser -> base_uri ; raptor_rss_parser * rss_parser = ( raptor_rss_parser * ) rdf_parser -> context ; int n ; if ( ! uri ) return 1 ; for ( n = 0 ; n < RAPTOR_RSS_NAMESPACES_SIZE ; n ++ ) rss_parser -> nspaces_seen [ n ] = 'N' ; raptor_sax2_set_option ( rss_parser -> sax2 , RAPTOR_OPTION_NO_NET , NULL , RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_NO_NET ) ) ; raptor_sax2_set_option ( rss_parser -> sax2 , RAPTOR_OPTION_NO_FILE , NULL , RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_NO_FILE ) ) ; <S2SV_StartBug> if ( rdf_parser -> uri_filter ) <S2SV_EndBug> raptor_sax2_set_uri_filter ( rss_parser -> sax2 , rdf_parser -> uri_filter , rdf_parser -> uri_filter_user_data ) ; raptor_sax2_parse_start ( rss_parser -> sax2 , uri ) ; return 0 ; }
","<S2SV_ModStart> ) ) ; raptor_sax2_set_option ( rss_parser -> sax2 , RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES , NULL , RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES ) ) ;
"
289,"CWE-200 static int hidp_setup_hid ( struct hidp_session * session , struct hidp_connadd_req * req ) { struct hid_device * hid ; int err ; session -> rd_data = kzalloc ( req -> rd_size , GFP_KERNEL ) ; if ( ! session -> rd_data ) return - ENOMEM ; if ( copy_from_user ( session -> rd_data , req -> rd_data , req -> rd_size ) ) { err = - EFAULT ; goto fault ; } session -> rd_size = req -> rd_size ; hid = hid_allocate_device ( ) ; if ( IS_ERR ( hid ) ) { err = PTR_ERR ( hid ) ; goto fault ; } session -> hid = hid ; hid -> driver_data = session ; hid -> bus = BUS_BLUETOOTH ; hid -> vendor = req -> vendor ; hid -> product = req -> product ; hid -> version = req -> version ; hid -> country = req -> country ; <S2SV_StartBug> strncpy ( hid -> name , req -> name , 128 ) ; <S2SV_EndBug> snprintf ( hid -> phys , sizeof ( hid -> phys ) , ""%pMR"" , & bt_sk ( session -> ctrl_sock -> sk ) -> src ) ; snprintf ( hid -> uniq , sizeof ( hid -> uniq ) , ""%pMR"" , & bt_sk ( session -> ctrl_sock -> sk ) -> dst ) ; hid -> dev . parent = & session -> conn -> dev ; hid -> ll_driver = & hidp_hid_driver ; hid -> hid_get_raw_report = hidp_get_raw_report ; hid -> hid_output_raw_report = hidp_output_raw_report ; if ( hid_ignore ( hid ) ) { hid_destroy_device ( session -> hid ) ; session -> hid = NULL ; return - ENODEV ; } return 0 ; fault : kfree ( session -> rd_data ) ; session -> rd_data = NULL ; return err ; }
","<S2SV_ModStart> -> name , sizeof ( req -> name ) - 1 <S2SV_ModEnd> ) ; snprintf
"
290,"CWE-119 static int get_refresh_mask ( VP9_COMP * cpi ) { <S2SV_StartBug> # if CONFIG_MULTIPLE_ARF <S2SV_EndBug> if ( ! cpi -> multi_arf_enabled && cpi -> refresh_golden_frame && ! cpi -> refresh_alt_ref_frame ) { # else if ( cpi -> refresh_golden_frame && ! cpi -> refresh_alt_ref_frame && ! cpi -> use_svc ) { # endif return ( cpi -> refresh_last_frame << cpi -> lst_fb_idx ) | ( cpi -> refresh_golden_frame << cpi -> alt_fb_idx ) ; } else { int arf_idx = cpi -> alt_fb_idx ; <S2SV_StartBug> # if CONFIG_MULTIPLE_ARF <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> multi_arf_enabled ) { <S2SV_EndBug> int sn = cpi -> sequence_number ; <S2SV_StartBug> arf_idx = ( cpi -> frame_coding_order [ sn ] < 0 ) ? <S2SV_EndBug> cpi -> arf_buffer_idx [ sn + 1 ] : cpi -> arf_buffer_idx [ sn ] ; } <S2SV_StartBug> # endif <S2SV_EndBug> return ( cpi -> refresh_last_frame << cpi -> lst_fb_idx ) | ( cpi -> refresh_golden_frame << cpi -> gld_fb_idx ) | ( cpi -> refresh_alt_ref_frame << arf_idx ) ; } }
","<S2SV_ModStart> cpi ) { if ( vp9_preserve_existing_gf ( cpi ) ) { <S2SV_ModEnd> return ( cpi <S2SV_ModStart> -> alt_fb_idx ; if ( <S2SV_ModEnd> ( cpi -> <S2SV_ModStart> ( cpi -> oxcf . pass == 2 ) && cpi -> multi_arf_allowed ) { const GF_GROUP * const gf_group = & cpi -> twopass . gf_group <S2SV_ModEnd> ; arf_idx = <S2SV_ModStart> ; arf_idx = gf_group -> arf_update_idx [ gf_group -> index <S2SV_ModEnd> ] ; } <S2SV_ModStart> ] ; } <S2SV_ModEnd> return ( cpi
"
291,"CWE-119 static void command_port_read_callback ( struct urb * urb ) { struct usb_serial_port * command_port = urb -> context ; struct whiteheat_command_private * command_info ; int status = urb -> status ; unsigned char * data = urb -> transfer_buffer ; int result ; command_info = usb_get_serial_port_data ( command_port ) ; if ( ! command_info ) { dev_dbg ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>command_info<S2SV_blank>is<S2SV_blank>NULL,<S2SV_blank>exiting.\\n"" , __func__ ) ; return ; } <S2SV_StartBug> if ( status ) { <S2SV_EndBug> dev_dbg ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>nonzero<S2SV_blank>urb<S2SV_blank>status:<S2SV_blank>%d\\n"" , __func__ , status ) ; if ( status != - ENOENT ) command_info -> command_finished = WHITEHEAT_CMD_FAILURE ; wake_up ( & command_info -> wait_command ) ; return ; } usb_serial_debug_data ( & command_port -> dev , __func__ , urb -> actual_length , data ) ; if ( data [ 0 ] == WHITEHEAT_CMD_COMPLETE ) { command_info -> command_finished = WHITEHEAT_CMD_COMPLETE ; wake_up ( & command_info -> wait_command ) ; } else if ( data [ 0 ] == WHITEHEAT_CMD_FAILURE ) { command_info -> command_finished = WHITEHEAT_CMD_FAILURE ; wake_up ( & command_info -> wait_command ) ; } else if ( data [ 0 ] == WHITEHEAT_EVENT ) { dev_dbg ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>event<S2SV_blank>received\\n"" , __func__ ) ; <S2SV_StartBug> } else if ( data [ 0 ] == WHITEHEAT_GET_DTR_RTS ) { <S2SV_EndBug> memcpy ( command_info -> result_buffer , & data [ 1 ] , <S2SV_StartBug> urb -> actual_length - 1 ) ; <S2SV_EndBug> command_info -> command_finished = WHITEHEAT_CMD_COMPLETE ; wake_up ( & command_info -> wait_command ) ; } else dev_dbg ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>reply<S2SV_blank>from<S2SV_blank>firmware\\n"" , __func__ ) ; result = usb_submit_urb ( command_port -> read_urb , GFP_ATOMIC ) ; if ( result ) dev_dbg ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>failed<S2SV_blank>resubmitting<S2SV_blank>read<S2SV_blank>urb,<S2SV_blank>error<S2SV_blank>%d\\n"" , __func__ , result ) ; }
","<S2SV_ModStart> } if ( ! urb -> actual_length ) { dev_dbg ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>empty<S2SV_blank>response,<S2SV_blank>exiting.\\n"" , __func__ ) ; return ; } if ( <S2SV_ModStart> else if ( ( <S2SV_ModStart> == WHITEHEAT_GET_DTR_RTS ) && ( <S2SV_ModEnd> urb -> actual_length <S2SV_ModStart> actual_length - 1 <= sizeof ( command_info -> result_buffer ) ) ) { memcpy ( command_info -> result_buffer , & data [ 1 ] , urb -> actual_length - 1
"
292,"CWE-119 l_int32 gplotGenCommandFile ( GPLOT * gplot ) { <S2SV_StartBug> char buf [ L_BUF_SIZE ] ; <S2SV_EndBug> char * cmdstr , * plottitle , * dataname ; l_int32 i , plotstyle , nplots ; FILE * fp ; PROCNAME ( ""gplotGenCommandFile"" ) ; if ( ! gplot ) return ERROR_INT ( ""gplot<S2SV_blank>not<S2SV_blank>defined"" , procName , 1 ) ; sarrayClear ( gplot -> cmddata ) ; if ( gplot -> title ) { <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>title<S2SV_blank>\'%s\'"" , gplot -> title ) ; <S2SV_EndBug> sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ; } if ( gplot -> xlabel ) { <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>xlabel<S2SV_blank>\'%s\'"" , gplot -> xlabel ) ; <S2SV_EndBug> sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ; } if ( gplot -> ylabel ) { <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>ylabel<S2SV_blank>\'%s\'"" , gplot -> ylabel ) ; <S2SV_EndBug> sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ; } if ( gplot -> outformat == GPLOT_PNG ) { <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>terminal<S2SV_blank>png;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\'%s\'"" , <S2SV_EndBug> gplot -> outname ) ; } else if ( gplot -> outformat == GPLOT_PS ) { <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>terminal<S2SV_blank>postscript;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\'%s\'"" , <S2SV_EndBug> gplot -> outname ) ; } else if ( gplot -> outformat == GPLOT_EPS ) { <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , <S2SV_EndBug> ""set<S2SV_blank>terminal<S2SV_blank>postscript<S2SV_blank>eps;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\'%s\'"" , gplot -> outname ) ; } else if ( gplot -> outformat == GPLOT_LATEX ) { <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>terminal<S2SV_blank>latex;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\'%s\'"" , <S2SV_EndBug> gplot -> outname ) ; } sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ; if ( gplot -> scaling == GPLOT_LOG_SCALE_X || gplot -> scaling == GPLOT_LOG_SCALE_X_Y ) { <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>logscale<S2SV_blank>x"" ) ; <S2SV_EndBug> sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ; } if ( gplot -> scaling == GPLOT_LOG_SCALE_Y || gplot -> scaling == GPLOT_LOG_SCALE_X_Y ) { <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>logscale<S2SV_blank>y"" ) ; <S2SV_EndBug> sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ; } nplots = sarrayGetCount ( gplot -> datanames ) ; for ( i = 0 ; i < nplots ; i ++ ) { plottitle = sarrayGetString ( gplot -> plottitles , i , L_NOCOPY ) ; dataname = sarrayGetString ( gplot -> datanames , i , L_NOCOPY ) ; numaGetIValue ( gplot -> plotstyles , i , & plotstyle ) ; if ( nplots == 1 ) { <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""plot<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s"" , <S2SV_EndBug> dataname , plottitle , gplotstylenames [ plotstyle ] ) ; } else { if ( i == 0 ) <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""plot<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s,<S2SV_blank>\\\\"" , <S2SV_EndBug> dataname , plottitle , gplotstylenames [ plotstyle ] ) ; else if ( i < nplots - 1 ) <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s,<S2SV_blank>\\\\"" , <S2SV_EndBug> dataname , plottitle , gplotstylenames [ plotstyle ] ) ; else <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s"" , <S2SV_EndBug> dataname , plottitle , gplotstylenames [ plotstyle ] ) ; } sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ; } cmdstr = sarrayToString ( gplot -> cmddata , 1 ) ; if ( ( fp = fopenWriteStream ( gplot -> cmdname , ""w"" ) ) == NULL ) { LEPT_FREE ( cmdstr ) ; return ERROR_INT ( ""cmd<S2SV_blank>stream<S2SV_blank>not<S2SV_blank>opened"" , procName , 1 ) ; } fwrite ( cmdstr , 1 , strlen ( cmdstr ) , fp ) ; fclose ( fp ) ; LEPT_FREE ( cmdstr ) ; return 0 ; }
","<S2SV_ModStart> char buf [ L_BUFSIZE <S2SV_ModEnd> ] ; char <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , ""set<S2SV_blank>title<S2SV_blank>\'%s\'"" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , ""set<S2SV_blank>xlabel<S2SV_blank>\'%s\'"" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , ""set<S2SV_blank>ylabel<S2SV_blank>\'%s\'"" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , ""set<S2SV_blank>terminal<S2SV_blank>png;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\'%s\'"" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , ""set<S2SV_blank>terminal<S2SV_blank>postscript;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\'%s\'"" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , ""set<S2SV_blank>terminal<S2SV_blank>postscript<S2SV_blank>eps;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\'%s\'"" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , ""set<S2SV_blank>terminal<S2SV_blank>latex;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\'%s\'"" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , ""set<S2SV_blank>logscale<S2SV_blank>x"" ) <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , ""set<S2SV_blank>logscale<S2SV_blank>y"" ) <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , ""plot<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s"" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , ""plot<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s,<S2SV_blank>\\\\"" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , ""<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s,<S2SV_blank>\\\\"" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , ""<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s"" ,
"
293,"CWE-119 static int atusb_read_reg ( struct atusb * atusb , uint8_t reg ) { struct usb_device * usb_dev = atusb -> usb_dev ; int ret ; <S2SV_StartBug> uint8_t value ; <S2SV_EndBug> dev_dbg ( & usb_dev -> dev , ""atusb:<S2SV_blank>reg<S2SV_blank>=<S2SV_blank>0x%x\\n"" , reg ) ; ret = atusb_control_msg ( atusb , usb_rcvctrlpipe ( usb_dev , 0 ) , ATUSB_REG_READ , ATUSB_REQ_FROM_DEV , <S2SV_StartBug> 0 , reg , & value , 1 , 1000 ) ; <S2SV_EndBug> <S2SV_StartBug> return ret >= 0 ? value : ret ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> ret ; uint8_t * buffer ; uint8_t value ; buffer = kmalloc ( 1 , GFP_KERNEL ) ; if ( ! buffer ) return - ENOMEM <S2SV_ModEnd> ; dev_dbg ( <S2SV_ModStart> , reg , buffer <S2SV_ModEnd> , 1 , <S2SV_ModStart> 1000 ) ; if ( <S2SV_ModEnd> ret >= 0 <S2SV_ModStart> ret >= 0 ) { value = buffer [ 0 ] ; kfree ( buffer ) ; return value ; } else { kfree ( buffer ) ; return <S2SV_ModEnd> ret ; } <S2SV_ModStart> ret ; } }
"
294,"CWE-787 void * adminchild ( struct clientparam * param ) { int i , res ; char * buf ; char username [ 256 ] ; char * sb ; char * req = NULL ; struct printparam pp ; <S2SV_StartBug> int contentlen = 0 ; <S2SV_EndBug> int isform = 0 ; pp . inbuf = 0 ; pp . cp = param ; buf = myalloc ( LINESIZE ) ; if ( ! buf ) { RETURN ( 555 ) ; } i = sockgetlinebuf ( param , CLIENT , ( unsigned char * ) buf , LINESIZE - 1 , '\\n' , conf . timeouts [ STRING_S ] ) ; if ( i < 5 || ( ( buf [ 0 ] != 'G' || buf [ 1 ] != 'E' || buf [ 2 ] != 'T' || buf [ 3 ] != '<S2SV_blank>' || buf [ 4 ] != '/' ) && ( buf [ 0 ] != 'P' || buf [ 1 ] != 'O' || buf [ 2 ] != 'S' || buf [ 3 ] != 'T' || buf [ 4 ] != '<S2SV_blank>' || buf [ 5 ] != '/' ) ) ) { RETURN ( 701 ) ; } buf [ i ] = 0 ; sb = strchr ( buf + 5 , '<S2SV_blank>' ) ; if ( ! sb ) { RETURN ( 702 ) ; } * sb = 0 ; req = mystrdup ( buf + ( ( * buf == 'P' ) ? 6 : 5 ) ) ; while ( ( i = sockgetlinebuf ( param , CLIENT , ( unsigned char * ) buf , LINESIZE - 1 , '\\n' , conf . timeouts [ STRING_S ] ) ) > 2 ) { buf [ i ] = 0 ; if ( i > 19 && ( ! strncasecmp ( buf , ""authorization"" , 13 ) ) ) { sb = strchr ( buf , ':' ) ; if ( ! sb ) continue ; ++ sb ; while ( isspace ( * sb ) ) sb ++ ; if ( ! * sb || strncasecmp ( sb , ""basic"" , 5 ) ) { continue ; } sb += 5 ; while ( isspace ( * sb ) ) sb ++ ; i = de64 ( ( unsigned char * ) sb , ( unsigned char * ) username , 255 ) ; if ( i <= 0 ) continue ; username [ i ] = 0 ; sb = strchr ( ( char * ) username , ':' ) ; if ( sb ) { * sb = 0 ; if ( param -> password ) myfree ( param -> password ) ; param -> password = ( unsigned char * ) mystrdup ( sb + 1 ) ; } if ( param -> username ) myfree ( param -> username ) ; param -> username = ( unsigned char * ) mystrdup ( username ) ; continue ; } else if ( i > 15 && ( ! strncasecmp ( buf , ""content-length:"" , 15 ) ) ) { sb = buf + 15 ; while ( isspace ( * sb ) ) sb ++ ; <S2SV_StartBug> contentlen = atoi ( sb ) ; <S2SV_EndBug> } else if ( i > 13 && ( ! strncasecmp ( buf , ""content-type:"" , 13 ) ) ) { sb = buf + 13 ; while ( isspace ( * sb ) ) sb ++ ; if ( ! strncasecmp ( sb , ""x-www-form-urlencoded"" , 21 ) ) isform = 1 ; } } param -> operation = ADMIN ; if ( isform && contentlen ) { printstr ( & pp , ""HTTP/1.0<S2SV_blank>100<S2SV_blank>Continue\\r\\n\\r\\n"" ) ; stdpr ( & pp , NULL , 0 ) ; } res = ( * param -> srv -> authfunc ) ( param ) ; if ( res && res != 10 ) { printstr ( & pp , authreq ) ; RETURN ( res ) ; } if ( param -> srv -> singlepacket || param -> redirected ) { if ( * req == 'C' ) req [ 1 ] = 0 ; else * req = 0 ; } sprintf ( buf , ok , conf . stringtable ? ( char * ) conf . stringtable [ 2 ] : ""3proxy"" , conf . stringtable ? ( char * ) conf . stringtable [ 2 ] : ""3[APA3A]<S2SV_blank>tiny<S2SV_blank>proxy"" , conf . stringtable ? ( char * ) conf . stringtable [ 3 ] : """" ) ; if ( * req != 'S' ) printstr ( & pp , buf ) ; switch ( * req ) { case 'C' : printstr ( & pp , counters ) ; { struct trafcount * cp ; int num = 0 ; for ( cp = conf . trafcounter ; cp ; cp = cp -> next , num ++ ) { int inbuf = 0 ; if ( cp -> ace && ( param -> srv -> singlepacket || param -> redirected ) ) { if ( ! ACLmatches ( cp -> ace , param ) ) continue ; } if ( req [ 1 ] == 'S' && atoi ( req + 2 ) == num ) cp -> disabled = 0 ; if ( req [ 1 ] == 'D' && atoi ( req + 2 ) == num ) cp -> disabled = 1 ; inbuf += sprintf ( buf , ""<tr>"" ""<td>%s</td><td><A<S2SV_blank>HREF=\\\'/C%c%d\\\'>%s</A></td><td>"" , ( cp -> comment ) ? cp -> comment : ""&nbsp;"" , ( cp -> disabled ) ? 'S' : 'D' , num , ( cp -> disabled ) ? ""NO"" : ""YES"" ) ; if ( ! cp -> ace || ! cp -> ace -> users ) { inbuf += sprintf ( buf + inbuf , ""<center>ANY</center>"" ) ; } else { inbuf += printuserlist ( buf + inbuf , LINESIZE - 800 , cp -> ace -> users , "",<br<S2SV_blank>/>\\r\\n"" ) ; } inbuf += sprintf ( buf + inbuf , ""</td><td>"" ) ; if ( ! cp -> ace || ! cp -> ace -> src ) { inbuf += sprintf ( buf + inbuf , ""<center>ANY</center>"" ) ; } else { inbuf += printiplist ( buf + inbuf , LINESIZE - 512 , cp -> ace -> src , "",<br<S2SV_blank>/>\\r\\n"" ) ; } inbuf += sprintf ( buf + inbuf , ""</td><td>"" ) ; if ( ! cp -> ace || ! cp -> ace -> dst ) { inbuf += sprintf ( buf + inbuf , ""<center>ANY</center>"" ) ; } else { inbuf += printiplist ( buf + inbuf , LINESIZE - 512 , cp -> ace -> dst , "",<br<S2SV_blank>/>\\r\\n"" ) ; } inbuf += sprintf ( buf + inbuf , ""</td><td>"" ) ; if ( ! cp -> ace || ! cp -> ace -> ports ) { inbuf += sprintf ( buf + inbuf , ""<center>ANY</center>"" ) ; } else { inbuf += printportlist ( buf + inbuf , LINESIZE - 128 , cp -> ace -> ports , "",<br<S2SV_blank>/>\\r\\n"" ) ; } if ( cp -> type == NONE ) { inbuf += sprintf ( buf + inbuf , ""</td><td<S2SV_blank>colspan=\\\'6\\\'<S2SV_blank>align=\\\'center\\\'>exclude<S2SV_blank>from<S2SV_blank>limitation</td></tr>\\r\\n"" ) ; } else { inbuf += sprintf ( buf + inbuf , ""</td><td>%"" PRINTF_INT64_MODIFIER ""u</td>"" ""<td>MB%s</td>"" ""<td>%"" PRINTF_INT64_MODIFIER ""u</td>"" ""<td>%s</td>"" , cp -> traflim64 / ( 1024 * 1024 ) , rotations [ cp -> type ] , cp -> traf64 , cp -> cleared ? ctime ( & cp -> cleared ) : ""never"" ) ; inbuf += sprintf ( buf + inbuf , ""<td>%s</td>"" ""<td>%i</td>"" ""</tr>\\r\\n"" , cp -> updated ? ctime ( & cp -> updated ) : ""never"" , cp -> number ) ; } printstr ( & pp , buf ) ; } } printstr ( & pp , counterstail ) ; break ; case 'R' : conf . needreload = 1 ; printstr ( & pp , ""<h3>Reload<S2SV_blank>scheduled</h3>"" ) ; break ; case 'S' : { if ( req [ 1 ] == 'X' ) { printstr ( & pp , style ) ; break ; } printstr ( & pp , xml ) ; printval ( conf . services , TYPE_SERVER , 0 , & pp ) ; printstr ( & pp , postxml ) ; } break ; case 'F' : { FILE * fp ; char buf [ 256 ] ; fp = confopen ( ) ; if ( ! fp ) { printstr ( & pp , ""<h3><font<S2SV_blank>color=\\""red\\"">Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>config<S2SV_blank>file</font></h3>"" ) ; break ; } printstr ( & pp , ""<h3>Please<S2SV_blank>be<S2SV_blank>careful<S2SV_blank>editing<S2SV_blank>config<S2SV_blank>file<S2SV_blank>remotely</h3>"" ) ; <S2SV_StartBug> printstr ( & pp , ""<form<S2SV_blank>method=\\""POST\\""<S2SV_blank>action=\\""/U\\""><textarea<S2SV_blank>cols=\\""80\\""<S2SV_blank>rows=\\""30\\""<S2SV_blank>name=\\""conffile\\"">"" ) ; <S2SV_EndBug> while ( fgets ( buf , 256 , fp ) ) { printstr ( & pp , buf ) ; } if ( ! writable ) fclose ( fp ) ; printstr ( & pp , ""</textarea><br><input<S2SV_blank>type=\\""Submit\\""></form>"" ) ; break ; } case 'U' : { <S2SV_StartBug> int l = 0 ; <S2SV_EndBug> int error = 0 ; <S2SV_StartBug> if ( ! writable || fseek ( writable , 0 , 0 ) ) { <S2SV_EndBug> error = 1 ; } <S2SV_StartBug> while ( ( i = sockgetlinebuf ( param , CLIENT , ( unsigned char * ) buf , LINESIZE - 1 , '+' , conf . timeouts [ STRING_S ] ) ) > 0 ) { <S2SV_EndBug> if ( i > ( contentlen - l ) ) i = ( contentlen - l ) ; <S2SV_StartBug> buf [ i ] = 0 ; <S2SV_EndBug> if ( ! l ) { if ( strncasecmp ( buf , ""conffile="" , 9 ) ) error = 1 ; } <S2SV_StartBug> if ( ! error ) { <S2SV_EndBug> decodeurl ( ( unsigned char * ) buf , 1 ) ; fprintf ( writable , ""%s"" , l ? buf : buf + 9 ) ; } <S2SV_StartBug> l += i ; <S2SV_EndBug> if ( l >= contentlen ) break ; } if ( writable && ! error ) { fflush ( writable ) ; # ifndef _WINCE ftruncate ( fileno ( writable ) , ftell ( writable ) ) ; # endif } printstr ( & pp , error ? ""<h3><font<S2SV_blank>color=\\""red\\"">Config<S2SV_blank>file<S2SV_blank>is<S2SV_blank>not<S2SV_blank>writable</font></h3>Make<S2SV_blank>sure<S2SV_blank>you<S2SV_blank>have<S2SV_blank>\\""writable\\""<S2SV_blank>command<S2SV_blank>in<S2SV_blank>configuration<S2SV_blank>file"" : ""<h3>Configuration<S2SV_blank>updated</h3>"" ) ; } break ; default : printstr ( & pp , ( char * ) conf . stringtable [ WEBBANNERS ] ) ; break ; } if ( * req != 'S' ) printstr ( & pp , tail ) ; CLEANRET : printstr ( & pp , NULL ) ; if ( buf ) myfree ( buf ) ; ( * param -> srv -> logfunc ) ( param , ( unsigned char * ) req ) ; if ( req ) myfree ( req ) ; freeparam ( param ) ; return ( NULL ) ; }
","<S2SV_ModStart> printparam pp ; unsigned <S2SV_ModEnd> contentlen = 0 <S2SV_ModStart> sb ++ ; sscanf ( sb , ""%u"" , & contentlen ) ; if ( contentlen > LINESIZE * 1024 ) contentlen = 0 <S2SV_ModEnd> ; } else <S2SV_ModStart> & pp , ""<form<S2SV_blank>method=\\""POST\\""<S2SV_blank>action=\\""/U\\""<S2SV_blank>enctype=\\""application/x-www-form-urlencoded\\""><textarea<S2SV_blank>cols=\\""80\\""<S2SV_blank>rows=\\""30\\""<S2SV_blank>name=\\""conffile\\"">"" <S2SV_ModEnd> ) ; while <S2SV_ModStart> 'U' : { unsigned <S2SV_ModEnd> l = 0 <S2SV_ModStart> ! writable || ! contentlen || <S2SV_ModStart> } while ( l < contentlen && <S2SV_ModStart> ) buf , ( contentlen - l ) > <S2SV_ModStart> LINESIZE - 1 ? LINESIZE - 1 : contentlen - l <S2SV_ModStart> l ) ; if ( ! l ) { if ( i < 9 || <S2SV_ModEnd> strncasecmp ( buf <S2SV_ModStart> error ) { buf [ i ] = 0 ; <S2SV_ModStart> l += i <S2SV_ModEnd> ; } if
"
295,"CWE-20 bool_t enc624j600IrqHandler ( NetInterface * interface ) { bool_t flag ; uint16_t status ; flag = FALSE ; <S2SV_StartBug> enc624j600ClearBit ( interface , ENC624J600_REG_EIE , EIE_INTIE ) ; <S2SV_EndBug> <S2SV_StartBug> status = enc624j600ReadReg ( interface , ENC624J600_REG_EIR ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( status & EIR_LINKIF ) != 0 ) <S2SV_EndBug> { <S2SV_StartBug> enc624j600ClearBit ( interface , ENC624J600_REG_EIE , EIE_LINKIE ) ; <S2SV_EndBug> interface -> nicEvent = TRUE ; flag |= osSetEventFromIsr ( & netEvent ) ; } <S2SV_StartBug> if ( ( status & EIR_PKTIF ) != 0 ) <S2SV_EndBug> { <S2SV_StartBug> enc624j600ClearBit ( interface , ENC624J600_REG_EIE , EIE_PKTIE ) ; <S2SV_EndBug> interface -> nicEvent = TRUE ; flag |= osSetEventFromIsr ( & netEvent ) ; } <S2SV_StartBug> if ( ( status & ( EIR_TXIF | EIR_TXABTIF ) ) != 0 ) <S2SV_EndBug> { <S2SV_StartBug> enc624j600ClearBit ( interface , ENC624J600_REG_EIR , EIR_TXIF | EIR_TXABTIF ) ; <S2SV_EndBug> flag |= osSetEventFromIsr ( & interface -> nicTxEvent ) ; } <S2SV_StartBug> enc624j600SetBit ( interface , ENC624J600_REG_EIE , EIE_INTIE ) ; <S2SV_EndBug> return flag ; }
","<S2SV_ModStart> ( interface , ENC624J600_EIE , ENC624J600_EIE_INTIE <S2SV_ModEnd> ) ; status <S2SV_ModStart> ( interface , ENC624J600_EIR <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( status & ENC624J600_EIR_LINKIF <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ( interface , ENC624J600_EIE , ENC624J600_EIE_LINKIE <S2SV_ModEnd> ) ; interface <S2SV_ModStart> ( status & ENC624J600_EIR_PKTIF <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ( interface , ENC624J600_EIE , ENC624J600_EIE_PKTIE <S2SV_ModEnd> ) ; interface <S2SV_ModStart> status & ( ENC624J600_EIR_TXIF | ENC624J600_EIR_TXABTIF <S2SV_ModEnd> ) ) != <S2SV_ModStart> ( interface , ENC624J600_EIR , ENC624J600_EIR_TXIF | ENC624J600_EIR_TXABTIF <S2SV_ModEnd> ) ; flag <S2SV_ModStart> ( interface , ENC624J600_EIE , ENC624J600_EIE_INTIE <S2SV_ModEnd> ) ; return
"
296,"CWE-119 int vp9_rc_bits_per_mb ( FRAME_TYPE frame_type , int qindex , <S2SV_StartBug> double correction_factor ) { <S2SV_EndBug> <S2SV_StartBug> const double q = vp9_convert_qindex_to_q ( qindex ) ; <S2SV_EndBug> <S2SV_StartBug> int enumerator = frame_type == KEY_FRAME ? 3300000 : 2250000 ; <S2SV_EndBug> enumerator += ( int ) ( enumerator * q ) >> 12 ; <S2SV_StartBug> return ( int ) ( 0.5 + ( enumerator * correction_factor / q ) ) ; <S2SV_EndBug> }
","<S2SV_ModStart> , double correction_factor , vpx_bit_depth_t bit_depth <S2SV_ModStart> vp9_convert_qindex_to_q ( qindex , bit_depth <S2SV_ModStart> == KEY_FRAME ? 2700000 : 1800000 ; assert ( correction_factor <= MAX_BPB_FACTOR && correction_factor >= MIN_BPB_FACTOR ) <S2SV_ModEnd> ; enumerator += <S2SV_ModStart> int ) ( <S2SV_ModEnd> enumerator * correction_factor <S2SV_ModStart> / q ) <S2SV_ModEnd> ; } <S2SV_null>
"
297,"CWE-362 static int sctp_wait_for_sndbuf ( struct sctp_association * asoc , long * timeo_p , size_t msg_len ) { struct sock * sk = asoc -> base . sk ; int err = 0 ; long current_timeo = * timeo_p ; DEFINE_WAIT ( wait ) ; pr_debug ( ""%s:<S2SV_blank>asoc:%p,<S2SV_blank>timeo:%ld,<S2SV_blank>msg_len:%zu\\n"" , __func__ , asoc , * timeo_p , msg_len ) ; sctp_association_hold ( asoc ) ; for ( ; ; ) { prepare_to_wait_exclusive ( & asoc -> wait , & wait , TASK_INTERRUPTIBLE ) ; if ( ! * timeo_p ) goto do_nonblock ; if ( sk -> sk_err || asoc -> state >= SCTP_STATE_SHUTDOWN_PENDING || asoc -> base . dead ) goto do_error ; if ( signal_pending ( current ) ) goto do_interrupted ; if ( msg_len <= sctp_wspace ( asoc ) ) break ; release_sock ( sk ) ; current_timeo = schedule_timeout ( current_timeo ) ; <S2SV_StartBug> BUG_ON ( sk != asoc -> base . sk ) ; <S2SV_EndBug> lock_sock ( sk ) ; * timeo_p = current_timeo ; } out : finish_wait ( & asoc -> wait , & wait ) ; sctp_association_put ( asoc ) ; return err ; do_error : err = - EPIPE ; goto out ; do_interrupted : err = sock_intr_errno ( * timeo_p ) ; goto out ; do_nonblock : err = - EAGAIN ; goto out ; }
","<S2SV_ModStart> current_timeo ) ; if <S2SV_ModEnd> ( sk != <S2SV_ModStart> . sk ) goto do_error
"
298,"CWE-119 static vpx_codec_err_t ctrl_set_postproc ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> # if CONFIG_VP9_POSTPROC vp8_postproc_cfg_t * data = va_arg ( args , vp8_postproc_cfg_t * ) ; if ( data ) { ctx -> postproc_cfg_set = 1 ; ctx -> postproc_cfg = * ( ( vp8_postproc_cfg_t * ) data ) ; return VPX_CODEC_OK ; } else { return VPX_CODEC_INVALID_PARAM ; } # else <S2SV_StartBug> return VPX_CODEC_INCAPABLE ; <S2SV_EndBug> # endif }
","<S2SV_ModStart> * ctx , <S2SV_ModEnd> va_list args ) <S2SV_ModStart> } # else ( void ) ctx ; ( void ) args ;
"
299,"CWE-416 static ssize_t userfaultfd_ctx_read ( struct userfaultfd_ctx * ctx , int no_wait , struct uffd_msg * msg ) { ssize_t ret ; DECLARE_WAITQUEUE ( wait , current ) ; struct userfaultfd_wait_queue * uwq ; LIST_HEAD ( fork_event ) ; struct userfaultfd_ctx * fork_nctx = NULL ; spin_lock ( & ctx -> fd_wqh . lock ) ; __add_wait_queue ( & ctx -> fd_wqh , & wait ) ; for ( ; ; ) { set_current_state ( TASK_INTERRUPTIBLE ) ; spin_lock ( & ctx -> fault_pending_wqh . lock ) ; uwq = find_userfault ( ctx ) ; if ( uwq ) { write_seqcount_begin ( & ctx -> refile_seq ) ; list_del ( & uwq -> wq . entry ) ; __add_wait_queue ( & ctx -> fault_wqh , & uwq -> wq ) ; write_seqcount_end ( & ctx -> refile_seq ) ; * msg = uwq -> msg ; spin_unlock ( & ctx -> fault_pending_wqh . lock ) ; ret = 0 ; break ; } spin_unlock ( & ctx -> fault_pending_wqh . lock ) ; spin_lock ( & ctx -> event_wqh . lock ) ; uwq = find_userfault_evt ( ctx ) ; if ( uwq ) { * msg = uwq -> msg ; if ( uwq -> msg . event == UFFD_EVENT_FORK ) { fork_nctx = ( struct userfaultfd_ctx * ) ( unsigned long ) uwq -> msg . arg . reserved . reserved1 ; list_move ( & uwq -> wq . entry , & fork_event ) ; <S2SV_StartBug> spin_unlock ( & ctx -> event_wqh . lock ) ; <S2SV_EndBug> ret = 0 ; break ; } userfaultfd_event_complete ( ctx , uwq ) ; spin_unlock ( & ctx -> event_wqh . lock ) ; ret = 0 ; break ; } spin_unlock ( & ctx -> event_wqh . lock ) ; if ( signal_pending ( current ) ) { ret = - ERESTARTSYS ; break ; } if ( no_wait ) { ret = - EAGAIN ; break ; } spin_unlock ( & ctx -> fd_wqh . lock ) ; schedule ( ) ; spin_lock ( & ctx -> fd_wqh . lock ) ; } __remove_wait_queue ( & ctx -> fd_wqh , & wait ) ; __set_current_state ( TASK_RUNNING ) ; spin_unlock ( & ctx -> fd_wqh . lock ) ; if ( ! ret && msg -> event == UFFD_EVENT_FORK ) { ret = resolve_userfault_fork ( ctx , fork_nctx , msg ) ; <S2SV_StartBug> if ( ! ret ) { <S2SV_EndBug> spin_lock ( & ctx -> event_wqh . lock ) ; if ( ! list_empty ( & fork_event ) ) { <S2SV_StartBug> uwq = list_first_entry ( & fork_event , <S2SV_EndBug> typeof ( * uwq ) , wq . entry ) ; list_del ( & uwq -> wq . entry ) ; __add_wait_queue ( & ctx -> event_wqh , & uwq -> wq ) ; <S2SV_StartBug> userfaultfd_event_complete ( ctx , uwq ) ; <S2SV_EndBug> } <S2SV_StartBug> spin_unlock ( & ctx -> event_wqh . lock ) ; <S2SV_EndBug> } } return ret ; }
","<S2SV_ModStart> fork_event ) ; userfaultfd_ctx_get ( fork_nctx ) ; <S2SV_ModStart> msg ) ; <S2SV_ModEnd> spin_lock ( & <S2SV_ModStart> ) ) { userfaultfd_ctx_put ( fork_nctx ) ; <S2SV_ModStart> wq ) ; if ( likely ( ! ret ) ) <S2SV_ModStart> ) ; } else { if ( ret ) userfaultfd_ctx_put ( fork_nctx ) ; } spin_unlock ( & ctx -> event_wqh . lock ) ; <S2SV_ModEnd> } return ret
"
300,"CWE-264 asmlinkage long sys_oabi_fcntl64 ( unsigned int fd , unsigned int cmd , unsigned long arg ) { <S2SV_StartBug> struct oabi_flock64 user ; <S2SV_EndBug> struct flock64 kernel ; mm_segment_t fs = USER_DS ; unsigned long local_arg = arg ; int ret ; switch ( cmd ) { case F_OFD_GETLK : case F_OFD_SETLK : case F_OFD_SETLKW : case F_GETLK64 : case F_SETLK64 : case F_SETLKW64 : <S2SV_StartBug> if ( copy_from_user ( & user , ( struct oabi_flock64 __user * ) arg , <S2SV_EndBug> sizeof ( user ) ) ) return - EFAULT ; kernel . l_type = user . l_type ; kernel . l_whence = user . l_whence ; kernel . l_start = user . l_start ; kernel . l_len = user . l_len ; kernel . l_pid = user . l_pid ; local_arg = ( unsigned long ) & kernel ; fs = get_fs ( ) ; set_fs ( KERNEL_DS ) ; } <S2SV_StartBug> ret = sys_fcntl64 ( fd , cmd , local_arg ) ; <S2SV_EndBug> switch ( cmd ) { case F_GETLK64 : if ( ! ret ) { user . l_type = kernel . l_type ; user . l_whence = kernel . l_whence ; user . l_start = kernel . l_start ; user . l_len = kernel . l_len ; user . l_pid = kernel . l_pid ; if ( copy_to_user ( ( struct oabi_flock64 __user * ) arg , & user , sizeof ( user ) ) ) ret = - EFAULT ; } case F_SETLK64 : case F_SETLKW64 : set_fs ( fs ) ; } <S2SV_StartBug> return ret ; <S2SV_EndBug> }
","<S2SV_ModStart> arg ) { <S2SV_ModEnd> switch ( cmd <S2SV_ModStart> case F_SETLKW64 : return do_locks ( fd , cmd , arg ) ; default : return <S2SV_ModEnd> sys_fcntl64 ( fd <S2SV_ModStart> , cmd , arg <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
"
301,"CWE-119 static void do_ssh2_kex ( void ) { char * myproposal [ PROPOSAL_MAX ] = { KEX_SERVER } ; struct kex * kex ; int r ; myproposal [ PROPOSAL_KEX_ALGS ] = compat_kex_proposal ( options . kex_algorithms ) ; myproposal [ PROPOSAL_ENC_ALGS_CTOS ] = compat_cipher_proposal ( options . ciphers ) ; myproposal [ PROPOSAL_ENC_ALGS_STOC ] = compat_cipher_proposal ( options . ciphers ) ; myproposal [ PROPOSAL_MAC_ALGS_CTOS ] = myproposal [ PROPOSAL_MAC_ALGS_STOC ] = options . macs ; if ( options . compression == COMP_NONE ) { myproposal [ PROPOSAL_COMP_ALGS_CTOS ] = myproposal [ PROPOSAL_COMP_ALGS_STOC ] = ""none"" ; <S2SV_StartBug> } else if ( options . compression == COMP_DELAYED ) { <S2SV_EndBug> myproposal [ PROPOSAL_COMP_ALGS_CTOS ] = myproposal [ PROPOSAL_COMP_ALGS_STOC ] = ""none,zlib@openssh.com"" ; } if ( options . rekey_limit || options . rekey_interval ) packet_set_rekey_limits ( options . rekey_limit , ( time_t ) options . rekey_interval ) ; myproposal [ PROPOSAL_SERVER_HOST_KEY_ALGS ] = compat_pkalg_proposal ( list_hostkey_types ( ) ) ; if ( ( r = kex_setup ( active_state , myproposal ) ) != 0 ) fatal ( ""kex_setup:<S2SV_blank>%s"" , ssh_err ( r ) ) ; kex = active_state -> kex ; # ifdef WITH_OPENSSL kex -> kex [ KEX_DH_GRP1_SHA1 ] = kexdh_server ; kex -> kex [ KEX_DH_GRP14_SHA1 ] = kexdh_server ; kex -> kex [ KEX_DH_GRP14_SHA256 ] = kexdh_server ; kex -> kex [ KEX_DH_GRP16_SHA512 ] = kexdh_server ; kex -> kex [ KEX_DH_GRP18_SHA512 ] = kexdh_server ; kex -> kex [ KEX_DH_GEX_SHA1 ] = kexgex_server ; kex -> kex [ KEX_DH_GEX_SHA256 ] = kexgex_server ; kex -> kex [ KEX_ECDH_SHA2 ] = kexecdh_server ; # endif kex -> kex [ KEX_C25519_SHA256 ] = kexc25519_server ; kex -> server = 1 ; kex -> client_version_string = client_version_string ; kex -> server_version_string = server_version_string ; kex -> load_host_public_key = & get_hostkey_public_by_type ; kex -> load_host_private_key = & get_hostkey_private_by_type ; kex -> host_key_index = & get_hostkey_index ; kex -> sign = sshd_hostkey_sign ; dispatch_run ( DISPATCH_BLOCK , & kex -> done , active_state ) ; session_id2 = kex -> session_id ; session_id2_len = kex -> session_id_len ; # ifdef DEBUG_KEXDH packet_start ( SSH2_MSG_IGNORE ) ; packet_put_cstring ( ""markus"" ) ; packet_send ( ) ; packet_write_wait ( ) ; # endif debug ( ""KEX<S2SV_blank>done"" ) ; }
","<S2SV_ModStart> ""none"" ; } <S2SV_ModEnd> if ( options
"
302,"CWE-89 static CURLcode imap_parse_url_path ( struct connectdata * conn ) { struct imap_conn * imapc = & conn -> proto . imapc ; struct SessionHandle * data = conn -> data ; const char * path = data -> state . path ; <S2SV_StartBug> int len ; <S2SV_EndBug> if ( ! * path ) path = ""INBOX"" ; <S2SV_StartBug> imapc -> mailbox = curl_easy_unescape ( data , path , 0 , & len ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! imapc -> mailbox ) <S2SV_EndBug> return CURLE_OUT_OF_MEMORY ; return CURLE_OK ; }
","<S2SV_ModStart> . path ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> = ""INBOX"" ; return Curl_urldecode <S2SV_ModEnd> ( data , <S2SV_ModStart> 0 , & <S2SV_ModEnd> imapc -> mailbox <S2SV_ModStart> imapc -> mailbox , NULL , TRUE ) <S2SV_ModEnd> ; } <S2SV_null>
"
303,"CWE-416 static long ion_ioctl ( struct file * filp , unsigned int cmd , unsigned long arg ) { struct ion_client * client = filp -> private_data ; struct ion_device * dev = client -> dev ; struct ion_handle * cleanup_handle = NULL ; int ret = 0 ; unsigned int dir ; union { struct ion_fd_data fd ; struct ion_allocation_data allocation ; struct ion_handle_data handle ; struct ion_custom_data custom ; } data ; dir = ion_ioctl_dir ( cmd ) ; if ( _IOC_SIZE ( cmd ) > sizeof ( data ) ) return - EINVAL ; if ( dir & _IOC_WRITE ) if ( copy_from_user ( & data , ( void __user * ) arg , _IOC_SIZE ( cmd ) ) ) return - EFAULT ; switch ( cmd ) { case ION_IOC_ALLOC : { struct ion_handle * handle ; handle = ion_alloc ( client , data . allocation . len , data . allocation . align , data . allocation . heap_id_mask , data . allocation . flags ) ; if ( IS_ERR ( handle ) ) return PTR_ERR ( handle ) ; data . allocation . handle = handle -> id ; cleanup_handle = handle ; break ; } case ION_IOC_FREE : { struct ion_handle * handle ; <S2SV_StartBug> handle = ion_handle_get_by_id ( client , data . handle . handle ) ; <S2SV_EndBug> <S2SV_StartBug> if ( IS_ERR ( handle ) ) <S2SV_EndBug> return PTR_ERR ( handle ) ; <S2SV_StartBug> ion_free ( client , handle ) ; <S2SV_EndBug> ion_handle_put ( handle ) ; break ; } case ION_IOC_SHARE : case ION_IOC_MAP : { struct ion_handle * handle ; handle = ion_handle_get_by_id ( client , data . handle . handle ) ; if ( IS_ERR ( handle ) ) return PTR_ERR ( handle ) ; data . fd . fd = ion_share_dma_buf_fd ( client , handle ) ; ion_handle_put ( handle ) ; if ( data . fd . fd < 0 ) ret = data . fd . fd ; break ; } case ION_IOC_IMPORT : { struct ion_handle * handle ; handle = ion_import_dma_buf_fd ( client , data . fd . fd ) ; if ( IS_ERR ( handle ) ) ret = PTR_ERR ( handle ) ; else data . handle . handle = handle -> id ; break ; } case ION_IOC_SYNC : { ret = ion_sync_for_device ( client , data . fd . fd ) ; break ; } case ION_IOC_CUSTOM : { if ( ! dev -> custom_ioctl ) return - ENOTTY ; ret = dev -> custom_ioctl ( client , data . custom . cmd , data . custom . arg ) ; break ; } default : return - ENOTTY ; } if ( dir & _IOC_READ ) { if ( copy_to_user ( ( void __user * ) arg , & data , _IOC_SIZE ( cmd ) ) ) { if ( cleanup_handle ) ion_free ( client , cleanup_handle ) ; return - EFAULT ; } } return ret ; }
","<S2SV_ModStart> * handle ; mutex_lock ( & client -> lock ) ; handle = ion_handle_get_by_id_nolock <S2SV_ModEnd> ( client , <S2SV_ModStart> handle ) ) { mutex_unlock ( & client -> lock ) ; <S2SV_ModStart> handle ) ; } ion_free_nolock ( client , handle ) ; ion_handle_put_nolock ( handle ) ; mutex_unlock ( & client -> lock <S2SV_ModEnd> ) ; break
"
304,"CWE-476 av_cold void ff_mpv_idct_init ( MpegEncContext * s ) <S2SV_StartBug> { <S2SV_EndBug> ff_idctdsp_init ( & s -> idsp , s -> avctx ) ; if ( s -> alternate_scan ) { ff_init_scantable ( s -> idsp . idct_permutation , & s -> inter_scantable , ff_alternate_vertical_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_scantable , ff_alternate_vertical_scan ) ; } else { ff_init_scantable ( s -> idsp . idct_permutation , & s -> inter_scantable , ff_zigzag_direct ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_scantable , ff_zigzag_direct ) ; } ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_h_scantable , ff_alternate_horizontal_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_v_scantable , ff_alternate_vertical_scan ) ; }
","<S2SV_ModStart> s ) { if ( s -> codec_id == AV_CODEC_ID_MPEG4 ) s -> idsp . mpeg4_studio_profile = s -> studio_profile ;
"
305,"CWE-119 static void test_show_object ( struct object * object , <S2SV_StartBug> struct strbuf * path , <S2SV_EndBug> <S2SV_StartBug> const char * last , void * data ) <S2SV_EndBug> { struct bitmap_test_data * tdata = data ; int bitmap_pos ; bitmap_pos = bitmap_position ( object -> oid . hash ) ; if ( bitmap_pos < 0 ) die ( ""Object<S2SV_blank>not<S2SV_blank>in<S2SV_blank>bitmap:<S2SV_blank>%s\\n"" , oid_to_hex ( & object -> oid ) ) ; bitmap_set ( tdata -> base , bitmap_pos ) ; display_progress ( tdata -> prg , ++ tdata -> seen ) ; }
","<S2SV_ModStart> * object , <S2SV_ModEnd> const char * <S2SV_ModStart> const char * name <S2SV_ModEnd> , void *
"
306,"CWE-119 const vpx_image_t * vpx_codec_get_preview_frame ( vpx_codec_ctx_t * ctx ) { vpx_image_t * img = NULL ; if ( ctx ) { if ( ! ctx -> iface || ! ctx -> priv ) ctx -> err = VPX_CODEC_ERROR ; else if ( ! ( ctx -> iface -> caps & VPX_CODEC_CAP_ENCODER ) ) ctx -> err = VPX_CODEC_INCAPABLE ; else if ( ! ctx -> iface -> enc . get_preview ) ctx -> err = VPX_CODEC_INCAPABLE ; else <S2SV_StartBug> img = ctx -> iface -> enc . get_preview ( ctx -> priv -> alg_priv ) ; <S2SV_EndBug> } return img ; }
","<S2SV_ModStart> . get_preview ( get_alg_priv ( ctx ) <S2SV_ModEnd> ) ; }
"
307,"CWE-20 static int __br_mdb_del ( struct net_bridge * br , struct br_mdb_entry * entry ) { struct net_bridge_mdb_htable * mdb ; struct net_bridge_mdb_entry * mp ; struct net_bridge_port_group * p ; struct net_bridge_port_group __rcu * * pp ; struct br_ip ip ; int err = - EINVAL ; if ( ! netif_running ( br -> dev ) || br -> multicast_disabled ) return - EINVAL ; if ( timer_pending ( & br -> multicast_querier_timer ) ) return - EBUSY ; ip . proto = entry -> addr . proto ; if ( ip . proto == htons ( ETH_P_IP ) ) ip . u . ip4 = entry -> addr . u . ip4 ; # if IS_ENABLED ( CONFIG_IPV6 ) else ip . u . ip6 = entry -> addr . u . ip6 ; # endif spin_lock_bh ( & br -> multicast_lock ) ; mdb = mlock_dereference ( br -> mdb , br ) ; mp = br_mdb_ip_get ( mdb , & ip ) ; if ( ! mp ) goto unlock ; for ( pp = & mp -> ports ; ( p = mlock_dereference ( * pp , br ) ) != NULL ; pp = & p -> next ) { if ( ! p -> port || p -> port -> dev -> ifindex != entry -> ifindex ) continue ; if ( p -> port -> state == BR_STATE_DISABLED ) goto unlock ; rcu_assign_pointer ( * pp , p -> next ) ; hlist_del_init ( & p -> mglist ) ; del_timer ( & p -> timer ) ; call_rcu_bh ( & p -> rcu , br_multicast_free_pg ) ; err = 0 ; <S2SV_StartBug> if ( ! mp -> ports && ! mp -> mglist && <S2SV_EndBug> netif_running ( br -> dev ) ) mod_timer ( & mp -> timer , jiffies ) ; break ; } unlock : spin_unlock_bh ( & br -> multicast_lock ) ; return err ; }
","<S2SV_ModStart> -> mglist && mp -> timer_armed &&
"
308,"CWE-20 void sctp_association_free ( struct sctp_association * asoc ) { struct sock * sk = asoc -> base . sk ; struct sctp_transport * transport ; struct list_head * pos , * temp ; int i ; <S2SV_StartBug> if ( ! asoc -> temp ) { <S2SV_EndBug> list_del ( & asoc -> asocs ) ; if ( sctp_style ( sk , TCP ) && sctp_sstate ( sk , LISTENING ) ) sk -> sk_ack_backlog -- ; } asoc -> base . dead = true ; sctp_outq_free ( & asoc -> outqueue ) ; sctp_ulpq_free ( & asoc -> ulpq ) ; sctp_inq_free ( & asoc -> base . inqueue ) ; sctp_tsnmap_free ( & asoc -> peer . tsn_map ) ; sctp_ssnmap_free ( asoc -> ssnmap ) ; sctp_bind_addr_free ( & asoc -> base . bind_addr ) ; for ( i = SCTP_EVENT_TIMEOUT_NONE ; i < SCTP_NUM_TIMEOUT_TYPES ; ++ i ) { if ( del_timer ( & asoc -> timers [ i ] ) ) sctp_association_put ( asoc ) ; } kfree ( asoc -> peer . cookie ) ; kfree ( asoc -> peer . peer_random ) ; kfree ( asoc -> peer . peer_chunks ) ; kfree ( asoc -> peer . peer_hmacs ) ; list_for_each_safe ( pos , temp , & asoc -> peer . transport_addr_list ) { transport = list_entry ( pos , struct sctp_transport , transports ) ; list_del_rcu ( pos ) ; sctp_transport_free ( transport ) ; } asoc -> peer . transport_count = 0 ; sctp_asconf_queue_teardown ( asoc ) ; if ( asoc -> asconf_addr_del_pending != NULL ) kfree ( asoc -> asconf_addr_del_pending ) ; sctp_auth_destroy_keys ( & asoc -> endpoint_shared_keys ) ; sctp_auth_key_put ( asoc -> asoc_shared_key ) ; sctp_association_put ( asoc ) ; }
","<S2SV_ModStart> if ( ! list_empty ( & asoc -> asocs ) <S2SV_ModEnd> ) { list_del
"
309,"CWE-787 int mp4client_main ( int argc , char * * argv ) { char c ; const char * str ; int ret_val = 0 ; u32 i , times [ 100 ] , nb_times , dump_mode ; u32 simulation_time_in_ms = 0 ; u32 initial_service_id = 0 ; Bool auto_exit = GF_FALSE ; Bool logs_set = GF_FALSE ; Bool start_fs = GF_FALSE ; Bool use_rtix = GF_FALSE ; Bool pause_at_first = GF_FALSE ; Bool no_cfg_save = GF_FALSE ; Bool is_cfg_only = GF_FALSE ; Double play_from = 0 ; # ifdef GPAC_MEMORY_TRACKING GF_MemTrackerType mem_track = GF_MemTrackerNone ; # endif Double fps = GF_IMPORT_DEFAULT_FPS ; Bool fill_ar , visible , do_uncache , has_command ; char * url_arg , * out_arg , * the_cfg , * rti_file , * views , * mosaic ; FILE * logfile = NULL ; Float scale = 1 ; # ifndef WIN32 dlopen ( NULL , RTLD_NOW | RTLD_GLOBAL ) ; # endif strcpy ( the_url , ""."" ) ; memset ( & user , 0 , sizeof ( GF_User ) ) ; dump_mode = DUMP_NONE ; fill_ar = visible = do_uncache = has_command = GF_FALSE ; url_arg = out_arg = the_cfg = rti_file = views = mosaic = NULL ; nb_times = 0 ; times [ 0 ] = 0 ; for ( i = 1 ; i < ( u32 ) argc ; i ++ ) { char * arg = argv [ i ] ; if ( ! strcmp ( arg , ""-c"" ) || ! strcmp ( arg , ""-cfg"" ) ) { the_cfg = argv [ i + 1 ] ; i ++ ; } else if ( ! strcmp ( arg , ""-mem-track"" ) || ! strcmp ( arg , ""-mem-track-stack"" ) ) { # ifdef GPAC_MEMORY_TRACKING mem_track = ! strcmp ( arg , ""-mem-track-stack"" ) ? GF_MemTrackerBackTrace : GF_MemTrackerSimple ; # else fprintf ( stderr , ""WARNING<S2SV_blank>-<S2SV_blank>GPAC<S2SV_blank>not<S2SV_blank>compiled<S2SV_blank>with<S2SV_blank>Memory<S2SV_blank>Tracker<S2SV_blank>-<S2SV_blank>ignoring<S2SV_blank>\\""%s\\""\\n"" , arg ) ; # endif } else if ( ! strcmp ( arg , ""-gui"" ) ) { gui_mode = 1 ; } else if ( ! strcmp ( arg , ""-guid"" ) ) { gui_mode = 2 ; } else if ( ! strcmp ( arg , ""-h"" ) || ! strcmp ( arg , ""-help"" ) ) { PrintUsage ( ) ; return 0 ; } } # ifdef GPAC_MEMORY_TRACKING gf_sys_init ( mem_track ) ; # else gf_sys_init ( GF_MemTrackerNone ) ; # endif gf_sys_set_args ( argc , ( const char * * ) argv ) ; cfg_file = gf_cfg_init ( the_cfg , NULL ) ; if ( ! cfg_file ) { fprintf ( stderr , ""Error:<S2SV_blank>Configuration<S2SV_blank>File<S2SV_blank>not<S2SV_blank>found\\n"" ) ; return 1 ; } if ( gf_log_set_tools_levels ( gf_cfg_get_key ( cfg_file , ""General"" , ""Logs"" ) ) != GF_OK ) { return 1 ; } if ( gf_cfg_get_key ( cfg_file , ""General"" , ""Logs"" ) != NULL ) { logs_set = GF_TRUE ; } if ( ! gui_mode ) { str = gf_cfg_get_key ( cfg_file , ""General"" , ""ForceGUI"" ) ; if ( str && ! strcmp ( str , ""yes"" ) ) gui_mode = 1 ; } for ( i = 1 ; i < ( u32 ) argc ; i ++ ) { char * arg = argv [ i ] ; if ( ! strcmp ( arg , ""-rti"" ) ) { rti_file = argv [ i + 1 ] ; i ++ ; } else if ( ! strcmp ( arg , ""-rtix"" ) ) { rti_file = argv [ i + 1 ] ; i ++ ; use_rtix = GF_TRUE ; } else if ( ! stricmp ( arg , ""-size"" ) ) { if ( sscanf ( argv [ i + 1 ] , ""%dx%d"" , & forced_width , & forced_height ) != 2 ) { forced_width = forced_height = 0 ; } i ++ ; } else if ( ! strcmp ( arg , ""-quiet"" ) ) { be_quiet = 1 ; } else if ( ! strcmp ( arg , ""-strict-error"" ) ) { gf_log_set_strict_error ( 1 ) ; } else if ( ! strcmp ( arg , ""-log-file"" ) || ! strcmp ( arg , ""-lf"" ) ) { logfile = gf_fopen ( argv [ i + 1 ] , ""wt"" ) ; gf_log_set_callback ( logfile , on_gpac_log ) ; i ++ ; } else if ( ! strcmp ( arg , ""-logs"" ) ) { if ( gf_log_set_tools_levels ( argv [ i + 1 ] ) != GF_OK ) { return 1 ; } logs_set = GF_TRUE ; i ++ ; } else if ( ! strcmp ( arg , ""-log-clock"" ) || ! strcmp ( arg , ""-lc"" ) ) { log_time_start = 1 ; } else if ( ! strcmp ( arg , ""-log-utc"" ) || ! strcmp ( arg , ""-lu"" ) ) { log_utc_time = 1 ; } # if defined ( __DARWIN__ ) || defined ( __APPLE__ ) else if ( ! strcmp ( arg , ""-thread"" ) ) threading_flags = 0 ; # else else if ( ! strcmp ( arg , ""-no-thread"" ) ) threading_flags = GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_WINDOW_NO_THREAD ; # endif else if ( ! strcmp ( arg , ""-no-cthread"" ) || ! strcmp ( arg , ""-no-compositor-thread"" ) ) threading_flags |= GF_TERM_NO_COMPOSITOR_THREAD ; else if ( ! strcmp ( arg , ""-no-audio"" ) ) no_audio = 1 ; else if ( ! strcmp ( arg , ""-no-regulation"" ) ) no_regulation = 1 ; else if ( ! strcmp ( arg , ""-fs"" ) ) start_fs = 1 ; else if ( ! strcmp ( arg , ""-opt"" ) ) { set_cfg_option ( argv [ i + 1 ] ) ; i ++ ; } else if ( ! strcmp ( arg , ""-conf"" ) ) { set_cfg_option ( argv [ i + 1 ] ) ; is_cfg_only = GF_TRUE ; i ++ ; } else if ( ! strcmp ( arg , ""-ifce"" ) ) { gf_cfg_set_key ( cfg_file , ""Network"" , ""DefaultMCastInterface"" , argv [ i + 1 ] ) ; i ++ ; } else if ( ! stricmp ( arg , ""-help"" ) ) { PrintUsage ( ) ; return 1 ; } else if ( ! stricmp ( arg , ""-noprog"" ) ) { no_prog = 1 ; gf_set_progress_callback ( NULL , progress_quiet ) ; } else if ( ! stricmp ( arg , ""-no-save"" ) || ! stricmp ( arg , ""--no-save"" ) ) { no_cfg_save = 1 ; } else if ( ! stricmp ( arg , ""-ntp-shift"" ) ) { s32 shift = atoi ( argv [ i + 1 ] ) ; i ++ ; gf_net_set_ntp_shift ( shift ) ; } else if ( ! stricmp ( arg , ""-run-for"" ) ) { simulation_time_in_ms = atoi ( argv [ i + 1 ] ) * 1000 ; if ( ! simulation_time_in_ms ) simulation_time_in_ms = 1 ; i ++ ; } else if ( ! strcmp ( arg , ""-out"" ) ) { out_arg = argv [ i + 1 ] ; i ++ ; } else if ( ! stricmp ( arg , ""-fps"" ) ) { fps = atof ( argv [ i + 1 ] ) ; i ++ ; } else if ( ! strcmp ( arg , ""-avi"" ) || ! strcmp ( arg , ""-sha"" ) ) { dump_mode &= 0xFFFF0000 ; if ( ! strcmp ( arg , ""-sha"" ) ) dump_mode |= DUMP_SHA1 ; else dump_mode |= DUMP_AVI ; if ( ( url_arg || ( i + 2 < ( u32 ) argc ) ) && get_time_list ( argv [ i + 1 ] , times , & nb_times ) ) { if ( ! strcmp ( arg , ""-avi"" ) && ( nb_times != 2 ) ) { fprintf ( stderr , ""Only<S2SV_blank>one<S2SV_blank>time<S2SV_blank>arg<S2SV_blank>found<S2SV_blank>for<S2SV_blank>-avi<S2SV_blank>-<S2SV_blank>check<S2SV_blank>usage\\n"" ) ; return 1 ; } i ++ ; } } else if ( ! strcmp ( arg , ""-rgbds"" ) ) { dump_mode |= DUMP_RGB_DEPTH_SHAPE ; } else if ( ! strcmp ( arg , ""-rgbd"" ) ) { dump_mode |= DUMP_RGB_DEPTH ; } else if ( ! strcmp ( arg , ""-depth"" ) ) { dump_mode |= DUMP_DEPTH_ONLY ; } else if ( ! strcmp ( arg , ""-bmp"" ) ) { dump_mode &= 0xFFFF0000 ; dump_mode |= DUMP_BMP ; if ( ( url_arg || ( i + 2 < ( u32 ) argc ) ) && get_time_list ( argv [ i + 1 ] , times , & nb_times ) ) i ++ ; } else if ( ! strcmp ( arg , ""-png"" ) ) { dump_mode &= 0xFFFF0000 ; dump_mode |= DUMP_PNG ; if ( ( url_arg || ( i + 2 < ( u32 ) argc ) ) && get_time_list ( argv [ i + 1 ] , times , & nb_times ) ) i ++ ; } else if ( ! strcmp ( arg , ""-raw"" ) ) { dump_mode &= 0xFFFF0000 ; dump_mode |= DUMP_RAW ; if ( ( url_arg || ( i + 2 < ( u32 ) argc ) ) && get_time_list ( argv [ i + 1 ] , times , & nb_times ) ) i ++ ; } else if ( ! stricmp ( arg , ""-scale"" ) ) { sscanf ( argv [ i + 1 ] , ""%f"" , & scale ) ; i ++ ; } else if ( ! strcmp ( arg , ""-c"" ) || ! strcmp ( arg , ""-cfg"" ) ) { i ++ ; } if ( ! gui_mode ) { if ( arg [ 0 ] != '-' ) { if ( url_arg ) { fprintf ( stderr , ""Several<S2SV_blank>input<S2SV_blank>URLs<S2SV_blank>provided<S2SV_blank>(\\""%s\\"",<S2SV_blank>\\""%s\\"").<S2SV_blank>Check<S2SV_blank>your<S2SV_blank>command-line.\\n"" , url_arg , arg ) ; return 1 ; } url_arg = arg ; } else if ( ! strcmp ( arg , ""-loop"" ) ) loop_at_end = 1 ; else if ( ! strcmp ( arg , ""-bench"" ) ) bench_mode = 1 ; else if ( ! strcmp ( arg , ""-vbench"" ) ) bench_mode = 2 ; else if ( ! strcmp ( arg , ""-sbench"" ) ) bench_mode = 3 ; else if ( ! strcmp ( arg , ""-no-addon"" ) ) enable_add_ons = GF_FALSE ; else if ( ! strcmp ( arg , ""-pause"" ) ) pause_at_first = 1 ; else if ( ! strcmp ( arg , ""-play-from"" ) ) { play_from = atof ( ( const char * ) argv [ i + 1 ] ) ; i ++ ; } else if ( ! strcmp ( arg , ""-speed"" ) ) { playback_speed = FLT2FIX ( atof ( ( const char * ) argv [ i + 1 ] ) ) ; if ( playback_speed <= 0 ) playback_speed = FIX_ONE ; i ++ ; } else if ( ! strcmp ( arg , ""-no-wnd"" ) ) user . init_flags |= GF_TERM_WINDOWLESS ; else if ( ! strcmp ( arg , ""-no-back"" ) ) user . init_flags |= GF_TERM_WINDOW_TRANSPARENT ; else if ( ! strcmp ( arg , ""-align"" ) ) { if ( argv [ i + 1 ] [ 0 ] == 'm' ) align_mode = 1 ; else if ( argv [ i + 1 ] [ 0 ] == 'b' ) align_mode = 2 ; align_mode <<= 8 ; if ( argv [ i + 1 ] [ 1 ] == 'm' ) align_mode |= 1 ; else if ( argv [ i + 1 ] [ 1 ] == 'r' ) align_mode |= 2 ; i ++ ; } else if ( ! strcmp ( arg , ""-fill"" ) ) { fill_ar = GF_TRUE ; } else if ( ! strcmp ( arg , ""-show"" ) ) { visible = 1 ; } else if ( ! strcmp ( arg , ""-uncache"" ) ) { do_uncache = GF_TRUE ; } else if ( ! strcmp ( arg , ""-exit"" ) ) auto_exit = GF_TRUE ; else if ( ! stricmp ( arg , ""-views"" ) ) { views = argv [ i + 1 ] ; i ++ ; } else if ( ! stricmp ( arg , ""-mosaic"" ) ) { mosaic = argv [ i + 1 ] ; i ++ ; } else if ( ! stricmp ( arg , ""-com"" ) ) { has_command = GF_TRUE ; i ++ ; } else if ( ! stricmp ( arg , ""-service"" ) ) { initial_service_id = atoi ( argv [ i + 1 ] ) ; i ++ ; } } } if ( is_cfg_only ) { gf_cfg_del ( cfg_file ) ; fprintf ( stderr , ""GPAC<S2SV_blank>Config<S2SV_blank>updated\\n"" ) ; return 0 ; } if ( do_uncache ) { const char * cache_dir = gf_cfg_get_key ( cfg_file , ""General"" , ""CacheDirectory"" ) ; do_flatten_cache ( cache_dir ) ; fprintf ( stderr , ""GPAC<S2SV_blank>Cache<S2SV_blank>dir<S2SV_blank>%s<S2SV_blank>flattened\\n"" , cache_dir ) ; gf_cfg_del ( cfg_file ) ; return 0 ; } if ( dump_mode && ! url_arg ) { FILE * test ; url_arg = ( char * ) gf_cfg_get_key ( cfg_file , ""General"" , ""StartupFile"" ) ; test = url_arg ? gf_fopen ( url_arg , ""rt"" ) : NULL ; if ( ! test ) url_arg = NULL ; else gf_fclose ( test ) ; if ( ! url_arg ) { fprintf ( stderr , ""Missing<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>dump\\n"" ) ; PrintUsage ( ) ; if ( logfile ) gf_fclose ( logfile ) ; return 1 ; } } if ( ! gui_mode && ! url_arg && ( gf_cfg_get_key ( cfg_file , ""General"" , ""StartupFile"" ) != NULL ) ) { gui_mode = 1 ; } # ifdef WIN32 if ( gui_mode == 1 ) { const char * opt ; TCHAR buffer [ 1024 ] ; DWORD res = GetCurrentDirectory ( 1024 , buffer ) ; buffer [ res ] = 0 ; opt = gf_cfg_get_key ( cfg_file , ""General"" , ""ModulesDirectory"" ) ; if ( strstr ( opt , buffer ) ) { gui_mode = 1 ; } else { gui_mode = 2 ; } } # endif if ( gui_mode == 1 ) { hide_shell ( 1 ) ; } if ( gui_mode ) { no_prog = 1 ; gf_set_progress_callback ( NULL , progress_quiet ) ; } if ( ! url_arg && simulation_time_in_ms ) simulation_time_in_ms += gf_sys_clock ( ) ; # if defined ( __DARWIN__ ) || defined ( __APPLE__ ) carbon_init ( ) ; # endif if ( dump_mode ) rti_file = NULL ; if ( ! logs_set ) { gf_log_set_tool_level ( GF_LOG_ALL , GF_LOG_WARNING ) ; } if ( rti_file || logfile || log_utc_time || log_time_start ) gf_log_set_callback ( NULL , on_gpac_log ) ; if ( rti_file ) init_rti_logs ( rti_file , url_arg , use_rtix ) ; { GF_SystemRTInfo rti ; if ( gf_sys_get_rti ( 0 , & rti , 0 ) ) fprintf ( stderr , ""System<S2SV_blank>info:<S2SV_blank>%d<S2SV_blank>MB<S2SV_blank>RAM<S2SV_blank>-<S2SV_blank>%d<S2SV_blank>cores\\n"" , ( u32 ) ( rti . physical_memory / 1024 / 1024 ) , rti . nb_cores ) ; } if ( dump_mode ) { user . init_flags |= GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_NO_REGULATION ; if ( ! visible ) user . init_flags |= GF_TERM_INIT_HIDE ; gf_cfg_set_key ( cfg_file , ""Audio"" , ""DriverName"" , ""Raw<S2SV_blank>Audio<S2SV_blank>Output"" ) ; no_cfg_save = GF_TRUE ; } else { init_w = forced_width ; init_h = forced_height ; } user . modules = gf_modules_new ( NULL , cfg_file ) ; if ( user . modules ) i = gf_modules_get_count ( user . modules ) ; if ( ! i || ! user . modules ) { fprintf ( stderr , ""Error:<S2SV_blank>no<S2SV_blank>modules<S2SV_blank>found<S2SV_blank>-<S2SV_blank>exiting\\n"" ) ; if ( user . modules ) gf_modules_del ( user . modules ) ; gf_cfg_del ( cfg_file ) ; gf_sys_close ( ) ; if ( logfile ) gf_fclose ( logfile ) ; return 1 ; } fprintf ( stderr , ""Modules<S2SV_blank>Found<S2SV_blank>:<S2SV_blank>%d<S2SV_blank>\\n"" , i ) ; str = gf_cfg_get_key ( cfg_file , ""General"" , ""GPACVersion"" ) ; if ( ! str || strcmp ( str , GPAC_FULL_VERSION ) ) { gf_cfg_del_section ( cfg_file , ""PluginsCache"" ) ; gf_cfg_set_key ( cfg_file , ""General"" , ""GPACVersion"" , GPAC_FULL_VERSION ) ; } user . config = cfg_file ; user . EventProc = GPAC_EventProc ; user . opaque = user . modules ; if ( threading_flags ) user . init_flags |= threading_flags ; if ( no_audio ) user . init_flags |= GF_TERM_NO_AUDIO ; if ( no_regulation ) user . init_flags |= GF_TERM_NO_REGULATION ; if ( threading_flags & ( GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD ) ) term_step = GF_TRUE ; if ( dump_mode ) user . init_flags |= GF_TERM_USE_AUDIO_HW_CLOCK ; if ( bench_mode ) { gf_cfg_discard_changes ( user . config ) ; auto_exit = GF_TRUE ; gf_cfg_set_key ( user . config , ""Audio"" , ""DriverName"" , ""Raw<S2SV_blank>Audio<S2SV_blank>Output"" ) ; if ( bench_mode != 2 ) { gf_cfg_set_key ( user . config , ""Video"" , ""DriverName"" , ""Raw<S2SV_blank>Video<S2SV_blank>Output"" ) ; gf_cfg_set_key ( user . config , ""RAWVideo"" , ""RawOutput"" , ""null"" ) ; gf_cfg_set_key ( user . config , ""Compositor"" , ""OpenGLMode"" , ""disable"" ) ; } else { gf_cfg_set_key ( user . config , ""Video"" , ""DisableVSync"" , ""yes"" ) ; } } { char dim [ 50 ] ; sprintf ( dim , ""%d"" , forced_width ) ; gf_cfg_set_key ( user . config , ""Compositor"" , ""DefaultWidth"" , forced_width ? dim : NULL ) ; sprintf ( dim , ""%d"" , forced_height ) ; gf_cfg_set_key ( user . config , ""Compositor"" , ""DefaultHeight"" , forced_height ? dim : NULL ) ; } fprintf ( stderr , ""Loading<S2SV_blank>GPAC<S2SV_blank>Terminal\\n"" ) ; i = gf_sys_clock ( ) ; term = gf_term_new ( & user ) ; if ( ! term ) { fprintf ( stderr , ""\\nInit<S2SV_blank>error<S2SV_blank>-<S2SV_blank>check<S2SV_blank>you<S2SV_blank>have<S2SV_blank>at<S2SV_blank>least<S2SV_blank>one<S2SV_blank>video<S2SV_blank>out<S2SV_blank>and<S2SV_blank>one<S2SV_blank>rasterizer...\\nFound<S2SV_blank>modules:\\n"" ) ; list_modules ( user . modules ) ; gf_modules_del ( user . modules ) ; gf_cfg_discard_changes ( cfg_file ) ; gf_cfg_del ( cfg_file ) ; gf_sys_close ( ) ; if ( logfile ) gf_fclose ( logfile ) ; return 1 ; } fprintf ( stderr , ""Terminal<S2SV_blank>Loaded<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>ms\\n"" , gf_sys_clock ( ) - i ) ; if ( bench_mode ) { display_rti = 2 ; gf_term_set_option ( term , GF_OPT_VIDEO_BENCH , ( bench_mode == 3 ) ? 2 : 1 ) ; if ( bench_mode == 1 ) bench_mode = 2 ; } if ( dump_mode ) { if ( fill_ar ) gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_FILL_SCREEN ) ; } else { str = gf_cfg_get_key ( cfg_file , ""Video"" , ""DriverName"" ) ; if ( ! bench_mode && ! strcmp ( str , ""Raw<S2SV_blank>Video<S2SV_blank>Output"" ) ) fprintf ( stderr , ""WARNING:<S2SV_blank>using<S2SV_blank>raw<S2SV_blank>output<S2SV_blank>video<S2SV_blank>(memory<S2SV_blank>only)<S2SV_blank>-<S2SV_blank>no<S2SV_blank>display<S2SV_blank>used\\n"" ) ; str = gf_cfg_get_key ( cfg_file , ""Audio"" , ""DriverName"" ) ; if ( ! str || ! strcmp ( str , ""No<S2SV_blank>Audio<S2SV_blank>Output<S2SV_blank>Available"" ) ) fprintf ( stderr , ""WARNING:<S2SV_blank>no<S2SV_blank>audio<S2SV_blank>output<S2SV_blank>available<S2SV_blank>-<S2SV_blank>make<S2SV_blank>sure<S2SV_blank>no<S2SV_blank>other<S2SV_blank>program<S2SV_blank>is<S2SV_blank>locking<S2SV_blank>the<S2SV_blank>sound<S2SV_blank>card\\n"" ) ; str = gf_cfg_get_key ( cfg_file , ""General"" , ""NoMIMETypeFetch"" ) ; no_mime_check = ( str && ! stricmp ( str , ""yes"" ) ) ? 1 : 0 ; } str = gf_cfg_get_key ( cfg_file , ""HTTPProxy"" , ""Enabled"" ) ; if ( str && ! strcmp ( str , ""yes"" ) ) { str = gf_cfg_get_key ( cfg_file , ""HTTPProxy"" , ""Name"" ) ; if ( str ) fprintf ( stderr , ""HTTP<S2SV_blank>Proxy<S2SV_blank>%s<S2SV_blank>enabled\\n"" , str ) ; } if ( rti_file ) { str = gf_cfg_get_key ( cfg_file , ""General"" , ""RTIRefreshPeriod"" ) ; if ( str ) { rti_update_time_ms = atoi ( str ) ; } else { gf_cfg_set_key ( cfg_file , ""General"" , ""RTIRefreshPeriod"" , ""200"" ) ; } UpdateRTInfo ( ""At<S2SV_blank>GPAC<S2SV_blank>load<S2SV_blank>time\\n"" ) ; } Run = 1 ; if ( dump_mode ) { if ( ! nb_times ) { times [ 0 ] = 0 ; nb_times ++ ; } ret_val = dump_file ( url_arg , out_arg , dump_mode , fps , forced_width , forced_height , scale , times , nb_times ) ; Run = 0 ; } else if ( views ) { } else if ( ! gui_mode && url_arg ) { char * ext ; if ( strlen ( url_arg ) >= sizeof ( the_url ) ) { fprintf ( stderr , ""Input<S2SV_blank>url<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long,<S2SV_blank>truncating<S2SV_blank>to<S2SV_blank>%d<S2SV_blank>chars.\\n"" , url_arg , ( int ) ( sizeof ( the_url ) - 1 ) ) ; strncpy ( the_url , url_arg , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_url ) - 1 ] = 0 ; } else { strcpy ( the_url , url_arg ) ; } ext = strrchr ( the_url , '.' ) ; if ( ext && ( ! stricmp ( ext , "".m3u"" ) || ! stricmp ( ext , "".pls"" ) ) ) { GF_Err e = GF_OK ; fprintf ( stderr , ""Opening<S2SV_blank>Playlist<S2SV_blank>%s\\n"" , the_url ) ; strcpy ( pl_path , the_url ) ; if ( ! strncmp ( ""http:"" , the_url , 5 ) ) { GF_DownloadSession * sess = gf_dm_sess_new ( term -> downloader , the_url , GF_NETIO_SESSION_NOT_THREADED , NULL , NULL , & e ) ; if ( sess ) { e = gf_dm_sess_process ( sess ) ; if ( ! e ) { strncpy ( the_url , gf_dm_sess_get_cache_name ( sess ) , sizeof ( the_url ) - 1 ) ; <S2SV_StartBug> the_url [ sizeof ( the_cfg ) - 1 ] = 0 ; <S2SV_EndBug> } gf_dm_sess_del ( sess ) ; } } playlist = e ? NULL : gf_fopen ( the_url , ""rt"" ) ; readonly_playlist = 1 ; if ( playlist ) { request_next_playlist_item = GF_TRUE ; } else { if ( e ) fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>playlist<S2SV_blank>%s:<S2SV_blank>%s\\n"" , the_url , gf_error_to_string ( e ) ) ; fprintf ( stderr , ""Hit<S2SV_blank>\'h\'<S2SV_blank>for<S2SV_blank>help\\n\\n"" ) ; } } else { fprintf ( stderr , ""Opening<S2SV_blank>URL<S2SV_blank>%s\\n"" , the_url ) ; if ( pause_at_first ) fprintf ( stderr , ""[Status:<S2SV_blank>Paused]\\n"" ) ; gf_term_connect_from_time ( term , the_url , ( u64 ) ( play_from * 1000 ) , pause_at_first ) ; } } else { fprintf ( stderr , ""Hit<S2SV_blank>\'h\'<S2SV_blank>for<S2SV_blank>help\\n\\n"" ) ; str = gf_cfg_get_key ( cfg_file , ""General"" , ""StartupFile"" ) ; if ( str ) { strncpy ( the_url , ""MP4Client<S2SV_blank>"" GPAC_FULL_VERSION , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_url ) - 1 ] = 0 ; gf_term_connect ( term , str ) ; startup_file = 1 ; is_connected = 1 ; } } if ( gui_mode == 2 ) gui_mode = 0 ; if ( start_fs ) gf_term_set_option ( term , GF_OPT_FULLSCREEN , 1 ) ; if ( views ) { char szTemp [ 4046 ] ; sprintf ( szTemp , ""views://%s"" , views ) ; gf_term_connect ( term , szTemp ) ; } if ( mosaic ) { char szTemp [ 4046 ] ; sprintf ( szTemp , ""mosaic://%s"" , mosaic ) ; gf_term_connect ( term , szTemp ) ; } if ( bench_mode ) { rti_update_time_ms = 500 ; bench_mode_start = gf_sys_clock ( ) ; } while ( Run ) { if ( ( gui_mode == 1 ) || ! gf_prompt_has_input ( ) ) { if ( reload ) { reload = 0 ; gf_term_disconnect ( term ) ; gf_term_connect ( term , startup_file ? gf_cfg_get_key ( cfg_file , ""General"" , ""StartupFile"" ) : the_url ) ; } if ( restart && gf_term_get_option ( term , GF_OPT_IS_OVER ) ) { restart = 0 ; gf_term_play_from_time ( term , 0 , 0 ) ; } if ( request_next_playlist_item ) { c = '\\n' ; request_next_playlist_item = 0 ; goto force_input ; } if ( has_command && is_connected ) { has_command = GF_FALSE ; for ( i = 0 ; i < ( u32 ) argc ; i ++ ) { if ( ! strcmp ( argv [ i ] , ""-com"" ) ) { gf_term_scene_update ( term , NULL , argv [ i + 1 ] ) ; i ++ ; } } } if ( initial_service_id && is_connected ) { GF_ObjectManager * root_od = gf_term_get_root_object ( term ) ; if ( root_od ) { gf_term_select_service ( term , root_od , initial_service_id ) ; initial_service_id = 0 ; } } if ( ! use_rtix || display_rti ) UpdateRTInfo ( NULL ) ; if ( term_step ) { gf_term_process_step ( term ) ; } else { gf_sleep ( rti_update_time_ms ) ; } if ( auto_exit && eos_seen && gf_term_get_option ( term , GF_OPT_IS_OVER ) ) { Run = GF_FALSE ; } if ( simulation_time_in_ms && ( ( gf_term_get_elapsed_time_in_ms ( term ) > simulation_time_in_ms ) || ( ! url_arg && gf_sys_clock ( ) > simulation_time_in_ms ) ) ) { Run = GF_FALSE ; } continue ; } c = gf_prompt_get_char ( ) ; force_input : switch ( c ) { case 'q' : { GF_Event evt ; memset ( & evt , 0 , sizeof ( GF_Event ) ) ; evt . type = GF_EVENT_QUIT ; gf_term_send_event ( term , & evt ) ; } break ; case 'X' : exit ( 0 ) ; break ; case 'Q' : break ; case 'o' : startup_file = 0 ; gf_term_disconnect ( term ) ; fprintf ( stderr , ""Enter<S2SV_blank>the<S2SV_blank>absolute<S2SV_blank>URL\\n"" ) ; if ( 1 > scanf ( ""%s"" , the_url ) ) { fprintf ( stderr , ""Cannot<S2SV_blank>read<S2SV_blank>absolute<S2SV_blank>URL,<S2SV_blank>aborting\\n"" ) ; break ; } if ( rti_file ) init_rti_logs ( rti_file , the_url , use_rtix ) ; gf_term_connect ( term , the_url ) ; break ; case 'O' : gf_term_disconnect ( term ) ; fprintf ( stderr , ""Enter<S2SV_blank>the<S2SV_blank>absolute<S2SV_blank>URL<S2SV_blank>to<S2SV_blank>the<S2SV_blank>playlist\\n"" ) ; if ( 1 > scanf ( ""%s"" , the_url ) ) { fprintf ( stderr , ""Cannot<S2SV_blank>read<S2SV_blank>the<S2SV_blank>absolute<S2SV_blank>URL,<S2SV_blank>aborting.\\n"" ) ; break ; } playlist = gf_fopen ( the_url , ""rt"" ) ; if ( playlist ) { if ( 1 > fscanf ( playlist , ""%s"" , the_url ) ) { fprintf ( stderr , ""Cannot<S2SV_blank>read<S2SV_blank>any<S2SV_blank>URL<S2SV_blank>from<S2SV_blank>playlist,<S2SV_blank>aborting.\\n"" ) ; gf_fclose ( playlist ) ; break ; } fprintf ( stderr , ""Opening<S2SV_blank>URL<S2SV_blank>%s\\n"" , the_url ) ; gf_term_connect ( term , the_url ) ; } break ; case '\\n' : case 'N' : if ( playlist ) { int res ; gf_term_disconnect ( term ) ; res = fscanf ( playlist , ""%s"" , the_url ) ; if ( ( res == EOF ) && loop_at_end ) { fseek ( playlist , 0 , SEEK_SET ) ; res = fscanf ( playlist , ""%s"" , the_url ) ; } if ( res == EOF ) { fprintf ( stderr , ""No<S2SV_blank>more<S2SV_blank>items<S2SV_blank>-<S2SV_blank>exiting\\n"" ) ; Run = 0 ; } else if ( the_url [ 0 ] == '#' ) { request_next_playlist_item = GF_TRUE ; } else { fprintf ( stderr , ""Opening<S2SV_blank>URL<S2SV_blank>%s\\n"" , the_url ) ; gf_term_connect_with_path ( term , the_url , pl_path ) ; } } break ; case 'P' : if ( playlist ) { u32 count ; gf_term_disconnect ( term ) ; if ( 1 > scanf ( ""%u"" , & count ) ) { fprintf ( stderr , ""Cannot<S2SV_blank>read<S2SV_blank>number,<S2SV_blank>aborting.\\n"" ) ; break ; } while ( count ) { if ( fscanf ( playlist , ""%s"" , the_url ) ) { fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>line,<S2SV_blank>aborting\\n"" ) ; break ; } count -- ; } fprintf ( stderr , ""Opening<S2SV_blank>URL<S2SV_blank>%s\\n"" , the_url ) ; gf_term_connect ( term , the_url ) ; } break ; case 'r' : if ( is_connected ) reload = 1 ; break ; case 'D' : if ( is_connected ) gf_term_disconnect ( term ) ; break ; case 'p' : if ( is_connected ) { Bool is_pause = gf_term_get_option ( term , GF_OPT_PLAY_STATE ) ; fprintf ( stderr , ""[Status:<S2SV_blank>%s]\\n"" , is_pause ? ""Playing"" : ""Paused"" ) ; gf_term_set_option ( term , GF_OPT_PLAY_STATE , is_pause ? GF_STATE_PLAYING : GF_STATE_PAUSED ) ; } break ; case 's' : if ( is_connected ) { gf_term_set_option ( term , GF_OPT_PLAY_STATE , GF_STATE_STEP_PAUSE ) ; fprintf ( stderr , ""Step<S2SV_blank>time:<S2SV_blank>"" ) ; PrintTime ( gf_term_get_time_in_ms ( term ) ) ; fprintf ( stderr , ""\\n"" ) ; } break ; case 'z' : case 'T' : if ( ! CanSeek || ( Duration <= 2000 ) ) { fprintf ( stderr , ""scene<S2SV_blank>not<S2SV_blank>seekable\\n"" ) ; } else { Double res ; s32 seekTo ; fprintf ( stderr , ""Duration:<S2SV_blank>"" ) ; PrintTime ( Duration ) ; res = gf_term_get_time_in_ms ( term ) ; if ( c == 'z' ) { res *= 100 ; res /= ( s64 ) Duration ; fprintf ( stderr , ""<S2SV_blank>(current<S2SV_blank>%.2f<S2SV_blank>%%)\\nEnter<S2SV_blank>Seek<S2SV_blank>percentage:\\n"" , res ) ; if ( scanf ( ""%d"" , & seekTo ) == 1 ) { if ( seekTo > 100 ) seekTo = 100 ; res = ( Double ) ( s64 ) Duration ; res /= 100 ; res *= seekTo ; gf_term_play_from_time ( term , ( u64 ) ( s64 ) res , 0 ) ; } } else { u32 r , h , m , s ; fprintf ( stderr , ""<S2SV_blank>-<S2SV_blank>Current<S2SV_blank>Time:<S2SV_blank>"" ) ; PrintTime ( ( u64 ) res ) ; fprintf ( stderr , ""\\nEnter<S2SV_blank>seek<S2SV_blank>time<S2SV_blank>(Format:<S2SV_blank>s,<S2SV_blank>m:s<S2SV_blank>or<S2SV_blank>h:m:s):\\n"" ) ; h = m = s = 0 ; r = scanf ( ""%d:%d:%d"" , & h , & m , & s ) ; if ( r == 2 ) { s = m ; m = h ; h = 0 ; } else if ( r == 1 ) { s = h ; m = h = 0 ; } if ( r && ( r <= 3 ) ) { u64 time = h * 3600 + m * 60 + s ; gf_term_play_from_time ( term , time * 1000 , 0 ) ; } } } break ; case 't' : { if ( is_connected ) { fprintf ( stderr , ""Current<S2SV_blank>Time:<S2SV_blank>"" ) ; PrintTime ( gf_term_get_time_in_ms ( term ) ) ; fprintf ( stderr , ""<S2SV_blank>-<S2SV_blank>Duration:<S2SV_blank>"" ) ; PrintTime ( Duration ) ; fprintf ( stderr , ""\\n"" ) ; } } break ; case 'w' : if ( is_connected ) PrintWorldInfo ( term ) ; break ; case 'v' : if ( is_connected ) PrintODList ( term , NULL , 0 , 0 , ""Root"" ) ; break ; case 'i' : if ( is_connected ) { u32 ID ; fprintf ( stderr , ""Enter<S2SV_blank>OD<S2SV_blank>ID<S2SV_blank>(0<S2SV_blank>for<S2SV_blank>main<S2SV_blank>OD):<S2SV_blank>"" ) ; fflush ( stderr ) ; if ( scanf ( ""%ud"" , & ID ) == 1 ) { ViewOD ( term , ID , ( u32 ) - 1 , NULL ) ; } else { char str_url [ GF_MAX_PATH ] ; if ( scanf ( ""%s"" , str_url ) == 1 ) ViewOD ( term , 0 , ( u32 ) - 1 , str_url ) ; } } break ; case 'j' : if ( is_connected ) { u32 num ; do { fprintf ( stderr , ""Enter<S2SV_blank>OD<S2SV_blank>number<S2SV_blank>(0<S2SV_blank>for<S2SV_blank>main<S2SV_blank>OD):<S2SV_blank>"" ) ; fflush ( stderr ) ; } while ( 1 > scanf ( ""%ud"" , & num ) ) ; ViewOD ( term , ( u32 ) - 1 , num , NULL ) ; } break ; case 'b' : if ( is_connected ) ViewODs ( term , 1 ) ; break ; case 'm' : if ( is_connected ) ViewODs ( term , 0 ) ; break ; case 'l' : list_modules ( user . modules ) ; break ; case 'n' : if ( is_connected ) set_navigation ( ) ; break ; case 'x' : if ( is_connected ) gf_term_set_option ( term , GF_OPT_NAVIGATION_TYPE , 0 ) ; break ; case 'd' : if ( is_connected ) { GF_ObjectManager * odm = NULL ; char radname [ GF_MAX_PATH ] , * sExt ; GF_Err e ; u32 i , count , odid ; Bool xml_dump , std_out ; radname [ 0 ] = 0 ; do { fprintf ( stderr , ""Enter<S2SV_blank>Inline<S2SV_blank>OD<S2SV_blank>ID<S2SV_blank>if<S2SV_blank>any<S2SV_blank>or<S2SV_blank>0<S2SV_blank>:<S2SV_blank>"" ) ; fflush ( stderr ) ; } while ( 1 > scanf ( ""%ud"" , & odid ) ) ; if ( odid ) { GF_ObjectManager * root_odm = gf_term_get_root_object ( term ) ; if ( ! root_odm ) break ; count = gf_term_get_object_count ( term , root_odm ) ; for ( i = 0 ; i < count ; i ++ ) { GF_MediaInfo info ; odm = gf_term_get_object ( term , root_odm , i ) ; if ( gf_term_get_object_info ( term , odm , & info ) == GF_OK ) { if ( info . od -> objectDescriptorID == odid ) break ; } odm = NULL ; } } do { fprintf ( stderr , ""Enter<S2SV_blank>file<S2SV_blank>radical<S2SV_blank>name<S2SV_blank>(+\\\'.x\\\'<S2SV_blank>for<S2SV_blank>XML<S2SV_blank>dumping)<S2SV_blank>-<S2SV_blank>\\""std\\""<S2SV_blank>for<S2SV_blank>stderr:<S2SV_blank>"" ) ; fflush ( stderr ) ; } while ( 1 > scanf ( ""%s"" , radname ) ) ; sExt = strrchr ( radname , '.' ) ; xml_dump = 0 ; if ( sExt ) { if ( ! stricmp ( sExt , "".x"" ) ) xml_dump = 1 ; sExt [ 0 ] = 0 ; } std_out = strnicmp ( radname , ""std"" , 3 ) ? 0 : 1 ; e = gf_term_dump_scene ( term , std_out ? NULL : radname , NULL , xml_dump , 0 , odm ) ; fprintf ( stderr , ""Dump<S2SV_blank>done<S2SV_blank>(%s)\\n"" , gf_error_to_string ( e ) ) ; } break ; case 'c' : PrintGPACConfig ( ) ; break ; case '3' : { Bool use_3d = ! gf_term_get_option ( term , GF_OPT_USE_OPENGL ) ; if ( gf_term_set_option ( term , GF_OPT_USE_OPENGL , use_3d ) == GF_OK ) { fprintf ( stderr , ""Using<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>2D<S2SV_blank>drawing\\n"" , use_3d ? ""OpenGL"" : ""2D<S2SV_blank>rasterizer"" ) ; } } break ; case 'k' : { Bool opt = gf_term_get_option ( term , GF_OPT_STRESS_MODE ) ; opt = ! opt ; fprintf ( stderr , ""Turning<S2SV_blank>stress<S2SV_blank>mode<S2SV_blank>%s\\n"" , opt ? ""on"" : ""off"" ) ; gf_term_set_option ( term , GF_OPT_STRESS_MODE , opt ) ; } break ; case '4' : gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_4_3 ) ; break ; case '5' : gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_16_9 ) ; break ; case '6' : gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_FILL_SCREEN ) ; break ; case '7' : gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_KEEP ) ; break ; case 'C' : switch ( gf_term_get_option ( term , GF_OPT_MEDIA_CACHE ) ) { case GF_MEDIA_CACHE_DISABLED : gf_term_set_option ( term , GF_OPT_MEDIA_CACHE , GF_MEDIA_CACHE_ENABLED ) ; break ; case GF_MEDIA_CACHE_ENABLED : gf_term_set_option ( term , GF_OPT_MEDIA_CACHE , GF_MEDIA_CACHE_DISABLED ) ; break ; case GF_MEDIA_CACHE_RUNNING : fprintf ( stderr , ""Streaming<S2SV_blank>Cache<S2SV_blank>is<S2SV_blank>running<S2SV_blank>-<S2SV_blank>please<S2SV_blank>stop<S2SV_blank>it<S2SV_blank>first\\n"" ) ; continue ; } switch ( gf_term_get_option ( term , GF_OPT_MEDIA_CACHE ) ) { case GF_MEDIA_CACHE_ENABLED : fprintf ( stderr , ""Streaming<S2SV_blank>Cache<S2SV_blank>Enabled\\n"" ) ; break ; case GF_MEDIA_CACHE_DISABLED : fprintf ( stderr , ""Streaming<S2SV_blank>Cache<S2SV_blank>Disabled\\n"" ) ; break ; case GF_MEDIA_CACHE_RUNNING : fprintf ( stderr , ""Streaming<S2SV_blank>Cache<S2SV_blank>Running\\n"" ) ; break ; } break ; case 'S' : case 'A' : if ( gf_term_get_option ( term , GF_OPT_MEDIA_CACHE ) == GF_MEDIA_CACHE_RUNNING ) { gf_term_set_option ( term , GF_OPT_MEDIA_CACHE , ( c == 'S' ) ? GF_MEDIA_CACHE_DISABLED : GF_MEDIA_CACHE_DISCARD ) ; fprintf ( stderr , ""Streaming<S2SV_blank>Cache<S2SV_blank>stopped\\n"" ) ; } else { fprintf ( stderr , ""Streaming<S2SV_blank>Cache<S2SV_blank>not<S2SV_blank>running\\n"" ) ; } break ; case 'R' : display_rti = ! display_rti ; ResetCaption ( ) ; break ; case 'F' : if ( display_rti ) display_rti = 0 ; else display_rti = 2 ; ResetCaption ( ) ; break ; case 'u' : { GF_Err e ; char szCom [ 8192 ] ; fprintf ( stderr , ""Enter<S2SV_blank>command<S2SV_blank>to<S2SV_blank>send:\\n"" ) ; fflush ( stdin ) ; szCom [ 0 ] = 0 ; if ( 1 > scanf ( ""%[^\\t\\n]"" , szCom ) ) { fprintf ( stderr , ""Cannot<S2SV_blank>read<S2SV_blank>command<S2SV_blank>to<S2SV_blank>send,<S2SV_blank>aborting.\\n"" ) ; break ; } e = gf_term_scene_update ( term , NULL , szCom ) ; if ( e ) fprintf ( stderr , ""Processing<S2SV_blank>command<S2SV_blank>failed:<S2SV_blank>%s\\n"" , gf_error_to_string ( e ) ) ; } break ; case 'e' : { GF_Err e ; char jsCode [ 8192 ] ; fprintf ( stderr , ""Enter<S2SV_blank>JavaScript<S2SV_blank>code<S2SV_blank>to<S2SV_blank>evaluate:\\n"" ) ; fflush ( stdin ) ; jsCode [ 0 ] = 0 ; if ( 1 > scanf ( ""%[^\\t\\n]"" , jsCode ) ) { fprintf ( stderr , ""Cannot<S2SV_blank>read<S2SV_blank>code<S2SV_blank>to<S2SV_blank>evaluate,<S2SV_blank>aborting.\\n"" ) ; break ; } e = gf_term_scene_update ( term , ""application/ecmascript"" , jsCode ) ; if ( e ) fprintf ( stderr , ""Processing<S2SV_blank>JS<S2SV_blank>code<S2SV_blank>failed:<S2SV_blank>%s\\n"" , gf_error_to_string ( e ) ) ; } break ; case 'L' : { char szLog [ 1024 ] , * cur_logs ; cur_logs = gf_log_get_tools_levels ( ) ; fprintf ( stderr , ""Enter<S2SV_blank>new<S2SV_blank>log<S2SV_blank>level<S2SV_blank>(current<S2SV_blank>tools<S2SV_blank>%s):\\n"" , cur_logs ) ; gf_free ( cur_logs ) ; if ( scanf ( ""%s"" , szLog ) < 1 ) { fprintf ( stderr , ""Cannot<S2SV_blank>read<S2SV_blank>new<S2SV_blank>log<S2SV_blank>level,<S2SV_blank>aborting.\\n"" ) ; break ; } gf_log_modify_tools_levels ( szLog ) ; } break ; case 'g' : { GF_SystemRTInfo rti ; gf_sys_get_rti ( rti_update_time_ms , & rti , 0 ) ; fprintf ( stderr , ""GPAC<S2SV_blank>allocated<S2SV_blank>memory<S2SV_blank>"" LLD ""\\n"" , rti . gpac_memory ) ; } break ; case 'M' : { u32 size ; do { fprintf ( stderr , ""Enter<S2SV_blank>new<S2SV_blank>video<S2SV_blank>cache<S2SV_blank>memory<S2SV_blank>in<S2SV_blank>kBytes<S2SV_blank>(current<S2SV_blank>%ud):\\n"" , gf_term_get_option ( term , GF_OPT_VIDEO_CACHE_SIZE ) ) ; } while ( 1 > scanf ( ""%ud"" , & size ) ) ; gf_term_set_option ( term , GF_OPT_VIDEO_CACHE_SIZE , size ) ; } break ; case 'H' : { u32 http_bitrate = gf_term_get_option ( term , GF_OPT_HTTP_MAX_RATE ) ; do { fprintf ( stderr , ""Enter<S2SV_blank>new<S2SV_blank>http<S2SV_blank>bitrate<S2SV_blank>in<S2SV_blank>bps<S2SV_blank>(0<S2SV_blank>for<S2SV_blank>none)<S2SV_blank>-<S2SV_blank>current<S2SV_blank>limit:<S2SV_blank>%d\\n"" , http_bitrate ) ; } while ( 1 > scanf ( ""%ud"" , & http_bitrate ) ) ; gf_term_set_option ( term , GF_OPT_HTTP_MAX_RATE , http_bitrate ) ; } break ; case 'E' : gf_term_set_option ( term , GF_OPT_RELOAD_CONFIG , 1 ) ; break ; case 'B' : switch_bench ( ! bench_mode ) ; break ; case 'Y' : { char szOpt [ 8192 ] ; fprintf ( stderr , ""Enter<S2SV_blank>option<S2SV_blank>to<S2SV_blank>set<S2SV_blank>(Section:Name=Value):\\n"" ) ; fflush ( stdin ) ; szOpt [ 0 ] = 0 ; if ( 1 > scanf ( ""%[^\\t\\n]"" , szOpt ) ) { fprintf ( stderr , ""Cannot<S2SV_blank>read<S2SV_blank>option\\n"" ) ; break ; } set_cfg_option ( szOpt ) ; } break ; case 'Z' : { char szFileName [ 100 ] ; u32 nb_pass , nb_views , offscreen_view = 0 ; GF_VideoSurface fb ; GF_Err e ; nb_pass = 1 ; nb_views = gf_term_get_option ( term , GF_OPT_NUM_STEREO_VIEWS ) ; if ( nb_views > 1 ) { fprintf ( stderr , ""Auto-stereo<S2SV_blank>mode<S2SV_blank>detected<S2SV_blank>-<S2SV_blank>type<S2SV_blank>number<S2SV_blank>of<S2SV_blank>view<S2SV_blank>to<S2SV_blank>dump<S2SV_blank>(0<S2SV_blank>is<S2SV_blank>main<S2SV_blank>output,<S2SV_blank>1<S2SV_blank>to<S2SV_blank>%d<S2SV_blank>offscreen<S2SV_blank>view,<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>all<S2SV_blank>offscreen,<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>all<S2SV_blank>offscreen<S2SV_blank>and<S2SV_blank>main)\\n"" , nb_views , nb_views + 1 , nb_views + 2 ) ; if ( scanf ( ""%d"" , & offscreen_view ) != 1 ) { offscreen_view = 0 ; } if ( offscreen_view == nb_views + 1 ) { offscreen_view = 1 ; nb_pass = nb_views ; } else if ( offscreen_view == nb_views + 2 ) { offscreen_view = 0 ; nb_pass = nb_views + 1 ; } } while ( nb_pass ) { nb_pass -- ; if ( offscreen_view ) { sprintf ( szFileName , ""view%d_dump.png"" , offscreen_view ) ; e = gf_term_get_offscreen_buffer ( term , & fb , offscreen_view - 1 , 0 ) ; } else { sprintf ( szFileName , ""gpac_video_dump_"" LLU "".png"" , gf_net_get_utc ( ) ) ; e = gf_term_get_screen_buffer ( term , & fb ) ; } offscreen_view ++ ; if ( e ) { fprintf ( stderr , ""Error<S2SV_blank>dumping<S2SV_blank>screen<S2SV_blank>buffer<S2SV_blank>%s\\n"" , gf_error_to_string ( e ) ) ; nb_pass = 0 ; } else { # ifndef GPAC_DISABLE_AV_PARSERS u32 dst_size = fb . width * fb . height * 4 ; char * dst = ( char * ) gf_malloc ( sizeof ( char ) * dst_size ) ; e = gf_img_png_enc ( fb . video_buffer , fb . width , fb . height , fb . pitch_y , fb . pixel_format , dst , & dst_size ) ; if ( e ) { fprintf ( stderr , ""Error<S2SV_blank>encoding<S2SV_blank>PNG<S2SV_blank>%s\\n"" , gf_error_to_string ( e ) ) ; nb_pass = 0 ; } else { FILE * png = gf_fopen ( szFileName , ""wb"" ) ; if ( ! png ) { fprintf ( stderr , ""Error<S2SV_blank>writing<S2SV_blank>file<S2SV_blank>%s\\n"" , szFileName ) ; nb_pass = 0 ; } else { gf_fwrite ( dst , dst_size , 1 , png ) ; gf_fclose ( png ) ; fprintf ( stderr , ""Dump<S2SV_blank>to<S2SV_blank>%s\\n"" , szFileName ) ; } } if ( dst ) gf_free ( dst ) ; gf_term_release_screen_buffer ( term , & fb ) ; # endif } } fprintf ( stderr , ""Done:<S2SV_blank>%s\\n"" , szFileName ) ; } break ; case 'G' : { GF_ObjectManager * root_od , * odm ; u32 index ; char szOpt [ 8192 ] ; fprintf ( stderr , ""Enter<S2SV_blank>0-based<S2SV_blank>index<S2SV_blank>of<S2SV_blank>object<S2SV_blank>to<S2SV_blank>select<S2SV_blank>or<S2SV_blank>service<S2SV_blank>ID:\\n"" ) ; fflush ( stdin ) ; szOpt [ 0 ] = 0 ; if ( 1 > scanf ( ""%[^\\t\\n]"" , szOpt ) ) { fprintf ( stderr , ""Cannot<S2SV_blank>read<S2SV_blank>OD<S2SV_blank>ID\\n"" ) ; break ; } index = atoi ( szOpt ) ; odm = NULL ; root_od = gf_term_get_root_object ( term ) ; if ( root_od ) { if ( gf_term_find_service ( term , root_od , index ) ) { gf_term_select_service ( term , root_od , index ) ; } else { fprintf ( stderr , ""Cannot<S2SV_blank>find<S2SV_blank>service<S2SV_blank>%d<S2SV_blank>-<S2SV_blank>trying<S2SV_blank>with<S2SV_blank>object<S2SV_blank>index\\n"" , index ) ; odm = gf_term_get_object ( term , root_od , index ) ; if ( odm ) { gf_term_select_object ( term , odm ) ; } else { fprintf ( stderr , ""Cannot<S2SV_blank>find<S2SV_blank>object<S2SV_blank>at<S2SV_blank>index<S2SV_blank>%d\\n"" , index ) ; } } } } break ; case 'h' : PrintHelp ( ) ; break ; default : break ; } } if ( bench_mode ) { PrintAVInfo ( GF_TRUE ) ; } if ( simulation_time_in_ms ) { gf_log_set_strict_error ( 0 ) ; } i = gf_sys_clock ( ) ; gf_term_disconnect ( term ) ; if ( rti_file ) UpdateRTInfo ( ""Disconnected\\n"" ) ; fprintf ( stderr , ""Deleting<S2SV_blank>terminal...<S2SV_blank>"" ) ; if ( playlist ) gf_fclose ( playlist ) ; # if defined ( __DARWIN__ ) || defined ( __APPLE__ ) carbon_uninit ( ) ; # endif gf_term_del ( term ) ; fprintf ( stderr , ""done<S2SV_blank>(in<S2SV_blank>%d<S2SV_blank>ms)<S2SV_blank>-<S2SV_blank>ran<S2SV_blank>for<S2SV_blank>%d<S2SV_blank>ms\\n"" , gf_sys_clock ( ) - i , gf_sys_clock ( ) ) ; fprintf ( stderr , ""GPAC<S2SV_blank>cleanup<S2SV_blank>...\\n"" ) ; gf_modules_del ( user . modules ) ; if ( no_cfg_save ) gf_cfg_discard_changes ( cfg_file ) ; gf_cfg_del ( cfg_file ) ; gf_sys_close ( ) ; if ( rti_logs ) gf_fclose ( rti_logs ) ; if ( logfile ) gf_fclose ( logfile ) ; if ( gui_mode ) { hide_shell ( 2 ) ; } # ifdef GPAC_MEMORY_TRACKING if ( mem_track && ( gf_memory_size ( ) || gf_file_handles_count ( ) ) ) { gf_log_set_tool_level ( GF_LOG_MEMORY , GF_LOG_INFO ) ; gf_memory_print ( ) ; return 2 ; } # endif return ret_val ; }
","<S2SV_ModStart> [ sizeof ( the_url <S2SV_ModEnd> ) - 1
"
310,"CWE-119 <S2SV_StartBug> static vpx_codec_err_t vp8e_update_reference ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> int ctr_id , va_list args ) { int update = va_arg ( args , int ) ; vp8_update_reference ( ctx -> cpi , update ) ; return VPX_CODEC_OK ; }
","<S2SV_ModStart> vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args
"
311,"CWE-834 static Image * ReadPSImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define BoundingBox ""BoundingBox:"" # define BeginDocument ""BeginDocument:"" # define BeginXMPPacket ""<?xpacket<S2SV_blank>begin="" # define EndXMPPacket ""<?xpacket<S2SV_blank>end="" # define ICCProfile ""BeginICCProfile:"" # define CMYKCustomColor ""CMYKCustomColor:"" # define CMYKProcessColor ""CMYKProcessColor:"" # define DocumentMedia ""DocumentMedia:"" # define DocumentCustomColors ""DocumentCustomColors:"" # define DocumentProcessColors ""DocumentProcessColors:"" # define EndDocument ""EndDocument:"" # define HiResBoundingBox ""HiResBoundingBox:"" # define ImageData ""ImageData:"" # define PageBoundingBox ""PageBoundingBox:"" # define LanguageLevel ""LanguageLevel:"" # define PageMedia ""PageMedia:"" # define Pages ""Pages:"" # define PhotoshopProfile ""BeginPhotoshop:"" # define PostscriptLevel ""!PS-"" # define RenderPostscriptText ""<S2SV_blank><S2SV_blank>Rendering<S2SV_blank>Postscript...<S2SV_blank><S2SV_blank>"" # define SpotColor ""+<S2SV_blank>"" char command [ MagickPathExtent ] , * density , filename [ MagickPathExtent ] , geometry [ MagickPathExtent ] , input_filename [ MagickPathExtent ] , message [ MagickPathExtent ] , * options , postscript_filename [ MagickPathExtent ] ; const char * option ; const DelegateInfo * delegate_info ; GeometryInfo geometry_info ; Image * image , * next , * postscript_image ; ImageInfo * read_info ; int c , file ; MagickBooleanType cmyk , fitPage , skip , status ; MagickStatusType flags ; PointInfo delta , resolution ; RectangleInfo page ; register char * p ; register ssize_t i ; SegmentInfo bounds , hires_bounds ; short int hex_digits [ 256 ] ; size_t length ; ssize_t count , priority ; StringInfo * profile ; unsigned long columns , extent , language_level , pages , rows , scene , spotcolor ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } status = AcquireUniqueSymbolicLink ( image_info -> filename , input_filename ) ; if ( status == MagickFalse ) { ThrowFileException ( exception , FileOpenError , ""UnableToCreateTemporaryFile"" , image_info -> filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( hex_digits , 0 , sizeof ( hex_digits ) ) ; hex_digits [ ( int ) '0' ] = 0 ; hex_digits [ ( int ) '1' ] = 1 ; hex_digits [ ( int ) '2' ] = 2 ; hex_digits [ ( int ) '3' ] = 3 ; hex_digits [ ( int ) '4' ] = 4 ; hex_digits [ ( int ) '5' ] = 5 ; hex_digits [ ( int ) '6' ] = 6 ; hex_digits [ ( int ) '7' ] = 7 ; hex_digits [ ( int ) '8' ] = 8 ; hex_digits [ ( int ) '9' ] = 9 ; hex_digits [ ( int ) 'a' ] = 10 ; hex_digits [ ( int ) 'b' ] = 11 ; hex_digits [ ( int ) 'c' ] = 12 ; hex_digits [ ( int ) 'd' ] = 13 ; hex_digits [ ( int ) 'e' ] = 14 ; hex_digits [ ( int ) 'f' ] = 15 ; hex_digits [ ( int ) 'A' ] = 10 ; hex_digits [ ( int ) 'B' ] = 11 ; hex_digits [ ( int ) 'C' ] = 12 ; hex_digits [ ( int ) 'D' ] = 13 ; hex_digits [ ( int ) 'E' ] = 14 ; hex_digits [ ( int ) 'F' ] = 15 ; delta . x = DefaultResolution ; delta . y = DefaultResolution ; if ( ( image -> resolution . x == 0.0 ) || ( image -> resolution . y == 0.0 ) ) { flags = ParseGeometry ( PSDensityGeometry , & geometry_info ) ; image -> resolution . x = geometry_info . rho ; image -> resolution . y = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> resolution . y = image -> resolution . x ; } if ( image_info -> density != ( char * ) NULL ) { flags = ParseGeometry ( image_info -> density , & geometry_info ) ; image -> resolution . x = geometry_info . rho ; image -> resolution . y = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> resolution . y = image -> resolution . x ; } ( void ) ParseAbsoluteGeometry ( PSPageGeometry , & page ) ; if ( image_info -> page != ( char * ) NULL ) ( void ) ParseAbsoluteGeometry ( image_info -> page , & page ) ; resolution = image -> resolution ; page . width = ( size_t ) ceil ( ( double ) ( page . width * resolution . x / delta . x ) - 0.5 ) ; page . height = ( size_t ) ceil ( ( double ) ( page . height * resolution . y / delta . y ) - 0.5 ) ; ( void ) ResetMagickMemory ( & bounds , 0 , sizeof ( bounds ) ) ; ( void ) ResetMagickMemory ( command , 0 , sizeof ( command ) ) ; cmyk = image_info -> colorspace == CMYKColorspace ? MagickTrue : MagickFalse ; ( void ) ResetMagickMemory ( & hires_bounds , 0 , sizeof ( hires_bounds ) ) ; columns = 0 ; rows = 0 ; priority = 0 ; rows = 0 ; extent = 0 ; spotcolor = 0 ; language_level = 1 ; pages = ( ~ 0UL ) ; skip = MagickFalse ; p = command ; for ( c = ReadBlobByte ( image ) ; c != EOF ; c = ReadBlobByte ( image ) ) { * p ++ = ( char ) c ; if ( ( strchr ( ""\\n\\r%"" , c ) == ( char * ) NULL ) && ( ( size_t ) ( p - command ) < ( MagickPathExtent - 1 ) ) ) continue ; * p = '\\0' ; p = command ; if ( LocaleNCompare ( BeginDocument , command , strlen ( BeginDocument ) ) == 0 ) skip = MagickTrue ; if ( LocaleNCompare ( EndDocument , command , strlen ( EndDocument ) ) == 0 ) skip = MagickFalse ; if ( skip != MagickFalse ) continue ; if ( LocaleNCompare ( PostscriptLevel , command , strlen ( PostscriptLevel ) ) == 0 ) { ( void ) SetImageProperty ( image , ""ps:Level"" , command + 4 , exception ) ; if ( GlobExpression ( command , ""*EPSF-*"" , MagickTrue ) != MagickFalse ) pages = 1 ; } if ( LocaleNCompare ( LanguageLevel , command , strlen ( LanguageLevel ) ) == 0 ) ( void ) sscanf ( command , LanguageLevel ""<S2SV_blank>%lu"" , & language_level ) ; if ( LocaleNCompare ( Pages , command , strlen ( Pages ) ) == 0 ) ( void ) sscanf ( command , Pages ""<S2SV_blank>%lu"" , & pages ) ; if ( LocaleNCompare ( ImageData , command , strlen ( ImageData ) ) == 0 ) ( void ) sscanf ( command , ImageData ""<S2SV_blank>%lu<S2SV_blank>%lu"" , & columns , & rows ) ; if ( LocaleNCompare ( ICCProfile , command , strlen ( ICCProfile ) ) == 0 ) { unsigned char * datum ; profile = AcquireStringInfo ( MagickPathExtent ) ; datum = GetStringInfoDatum ( profile ) ; for ( i = 0 ; ( c = ProfileInteger ( image , hex_digits ) ) != EOF ; i ++ ) { if ( i >= ( ssize_t ) GetStringInfoLength ( profile ) ) { SetStringInfoLength ( profile , ( size_t ) i << 1 ) ; datum = GetStringInfoDatum ( profile ) ; } datum [ i ] = ( unsigned char ) c ; } SetStringInfoLength ( profile , ( size_t ) i + 1 ) ; ( void ) SetImageProfile ( image , ""icc"" , profile , exception ) ; profile = DestroyStringInfo ( profile ) ; continue ; } if ( LocaleNCompare ( PhotoshopProfile , command , strlen ( PhotoshopProfile ) ) == 0 ) { unsigned char * q ; count = ( ssize_t ) sscanf ( command , PhotoshopProfile ""<S2SV_blank>%lu"" , & extent ) ; if ( count != 1 ) continue ; length = extent ; <S2SV_StartBug> profile = BlobToStringInfo ( ( const void * ) NULL , length ) ; <S2SV_EndBug> if ( profile != ( StringInfo * ) NULL ) { q = GetStringInfoDatum ( profile ) ; for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) * q ++ = ( unsigned char ) ProfileInteger ( image , hex_digits ) ; ( void ) SetImageProfile ( image , ""8bim"" , profile , exception ) ; profile = DestroyStringInfo ( profile ) ; } continue ; } if ( LocaleNCompare ( BeginXMPPacket , command , strlen ( BeginXMPPacket ) ) == 0 ) { p = command ; profile = StringToStringInfo ( command ) ; for ( i = GetStringInfoLength ( profile ) - 1 ; c != EOF ; i ++ ) { SetStringInfoLength ( profile , i + 1 ) ; c = ReadBlobByte ( image ) ; GetStringInfoDatum ( profile ) [ i ] = ( unsigned char ) c ; * p ++ = ( char ) c ; if ( ( strchr ( ""\\n\\r%"" , c ) == ( char * ) NULL ) && ( ( size_t ) ( p - command ) < ( MagickPathExtent - 1 ) ) ) continue ; * p = '\\0' ; p = command ; if ( LocaleNCompare ( EndXMPPacket , command , strlen ( EndXMPPacket ) ) == 0 ) break ; } SetStringInfoLength ( profile , i ) ; ( void ) SetImageProfile ( image , ""xmp"" , profile , exception ) ; profile = DestroyStringInfo ( profile ) ; continue ; } length = strlen ( DocumentProcessColors ) ; if ( LocaleNCompare ( DocumentProcessColors , command , length ) == 0 ) { if ( ( GlobExpression ( command , ""*Cyan*"" , MagickTrue ) != MagickFalse ) || ( GlobExpression ( command , ""*Magenta*"" , MagickTrue ) != MagickFalse ) || ( GlobExpression ( command , ""*Yellow*"" , MagickTrue ) != MagickFalse ) ) cmyk = MagickTrue ; } if ( LocaleNCompare ( CMYKCustomColor , command , strlen ( CMYKCustomColor ) ) == 0 ) cmyk = MagickTrue ; if ( LocaleNCompare ( CMYKProcessColor , command , strlen ( CMYKProcessColor ) ) == 0 ) cmyk = MagickTrue ; length = strlen ( DocumentCustomColors ) ; if ( ( LocaleNCompare ( DocumentCustomColors , command , length ) == 0 ) || ( LocaleNCompare ( CMYKCustomColor , command , strlen ( CMYKCustomColor ) ) == 0 ) || ( LocaleNCompare ( SpotColor , command , strlen ( SpotColor ) ) == 0 ) ) { char property [ MagickPathExtent ] , * value ; register char * q ; ( void ) FormatLocaleString ( property , MagickPathExtent , ""ps:SpotColor-%.20g"" , ( double ) ( spotcolor ++ ) ) ; for ( q = command ; * q != '\\0' ; q ++ ) if ( isspace ( ( int ) ( unsigned char ) * q ) != 0 ) break ; value = AcquireString ( q ) ; ( void ) SubstituteString ( & value , ""("" , """" ) ; ( void ) SubstituteString ( & value , "")"" , """" ) ; ( void ) StripString ( value ) ; ( void ) SetImageProperty ( image , property , value , exception ) ; value = DestroyString ( value ) ; continue ; } if ( image_info -> page != ( char * ) NULL ) continue ; count = 0 ; i = 0 ; if ( LocaleNCompare ( BoundingBox , command , strlen ( BoundingBox ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , BoundingBox ""<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf"" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 2 ; } if ( LocaleNCompare ( DocumentMedia , command , strlen ( DocumentMedia ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , DocumentMedia ""<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf"" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 1 ; } if ( LocaleNCompare ( HiResBoundingBox , command , strlen ( HiResBoundingBox ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , HiResBoundingBox ""<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf"" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 3 ; } if ( LocaleNCompare ( PageBoundingBox , command , strlen ( PageBoundingBox ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , PageBoundingBox ""<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf"" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 1 ; } if ( LocaleNCompare ( PageMedia , command , strlen ( PageMedia ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , PageMedia ""<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf"" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 1 ; } if ( ( count != 4 ) || ( i < ( ssize_t ) priority ) ) continue ; if ( ( fabs ( bounds . x2 - bounds . x1 ) <= fabs ( hires_bounds . x2 - hires_bounds . x1 ) ) || ( fabs ( bounds . y2 - bounds . y1 ) <= fabs ( hires_bounds . y2 - hires_bounds . y1 ) ) ) if ( i == ( ssize_t ) priority ) continue ; hires_bounds = bounds ; priority = i ; } if ( ( fabs ( hires_bounds . x2 - hires_bounds . x1 ) >= MagickEpsilon ) && ( fabs ( hires_bounds . y2 - hires_bounds . y1 ) >= MagickEpsilon ) ) { ( void ) FormatLocaleString ( geometry , MagickPathExtent , ""%gx%g%+.15g%+.15g"" , hires_bounds . x2 - hires_bounds . x1 , hires_bounds . y2 - hires_bounds . y1 , hires_bounds . x1 , hires_bounds . y1 ) ; ( void ) SetImageProperty ( image , ""ps:HiResBoundingBox"" , geometry , exception ) ; page . width = ( size_t ) ceil ( ( double ) ( ( hires_bounds . x2 - hires_bounds . x1 ) * resolution . x / delta . x ) - 0.5 ) ; page . height = ( size_t ) ceil ( ( double ) ( ( hires_bounds . y2 - hires_bounds . y1 ) * resolution . y / delta . y ) - 0.5 ) ; } fitPage = MagickFalse ; option = GetImageOption ( image_info , ""eps:fit-page"" ) ; if ( option != ( char * ) NULL ) { char * page_geometry ; page_geometry = GetPageGeometry ( option ) ; flags = ParseMetaGeometry ( page_geometry , & page . x , & page . y , & page . width , & page . height ) ; if ( flags == NoValue ) { ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , OptionError , ""InvalidGeometry"" , ""`%s\'"" , option ) ; image = DestroyImage ( image ) ; return ( ( Image * ) NULL ) ; } page . width = ( size_t ) ceil ( ( double ) ( page . width * image -> resolution . x / delta . x ) - 0.5 ) ; page . height = ( size_t ) ceil ( ( double ) ( page . height * image -> resolution . y / delta . y ) - 0.5 ) ; page_geometry = DestroyString ( page_geometry ) ; fitPage = MagickTrue ; } ( void ) CloseBlob ( image ) ; if ( IssRGBCompatibleColorspace ( image_info -> colorspace ) != MagickFalse ) cmyk = MagickFalse ; file = AcquireUniqueFileResource ( postscript_filename ) ; if ( file == - 1 ) { ThrowFileException ( exception , FileOpenError , ""UnableToOpenFile"" , image_info -> filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) CopyMagickString ( command , ""/setpagedevice<S2SV_blank>{pop}<S2SV_blank>bind<S2SV_blank>1<S2SV_blank>index<S2SV_blank>where<S2SV_blank>{"" ""dup<S2SV_blank>wcheck<S2SV_blank>{3<S2SV_blank>1<S2SV_blank>roll<S2SV_blank>put}<S2SV_blank>{pop<S2SV_blank>def}<S2SV_blank>ifelse}<S2SV_blank>{def}<S2SV_blank>ifelse\\n"" ""<</UseCIEColor<S2SV_blank>true>>setpagedevice\\n"" , MagickPathExtent ) ; count = write ( file , command , ( unsigned int ) strlen ( command ) ) ; if ( image_info -> page == ( char * ) NULL ) { char translate_geometry [ MagickPathExtent ] ; ( void ) FormatLocaleString ( translate_geometry , MagickPathExtent , ""%g<S2SV_blank>%g<S2SV_blank>translate\\n"" , - bounds . x1 , - bounds . y1 ) ; count = write ( file , translate_geometry , ( unsigned int ) strlen ( translate_geometry ) ) ; } file = close ( file ) - 1 ; if ( image_info -> monochrome != MagickFalse ) delegate_info = GetDelegateInfo ( ""ps:mono"" , ( char * ) NULL , exception ) ; else if ( cmyk != MagickFalse ) delegate_info = GetDelegateInfo ( ""ps:cmyk"" , ( char * ) NULL , exception ) ; else delegate_info = GetDelegateInfo ( ""ps:alpha"" , ( char * ) NULL , exception ) ; if ( delegate_info == ( const DelegateInfo * ) NULL ) { ( void ) RelinquishUniqueFileResource ( postscript_filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } density = AcquireString ( """" ) ; options = AcquireString ( """" ) ; ( void ) FormatLocaleString ( density , MagickPathExtent , ""%gx%g"" , resolution . x , resolution . y ) ; ( void ) FormatLocaleString ( options , MagickPathExtent , ""-g%.20gx%.20g<S2SV_blank>"" , ( double ) page . width , ( double ) page . height ) ; read_info = CloneImageInfo ( image_info ) ; * read_info -> magick = '\\0' ; if ( read_info -> number_scenes != 0 ) { char pages [ MagickPathExtent ] ; ( void ) FormatLocaleString ( pages , MagickPathExtent , ""-dFirstPage=%.20g<S2SV_blank>"" ""-dLastPage=%.20g<S2SV_blank>"" , ( double ) read_info -> scene + 1 , ( double ) ( read_info -> scene + read_info -> number_scenes ) ) ; ( void ) ConcatenateMagickString ( options , pages , MagickPathExtent ) ; read_info -> number_scenes = 0 ; if ( read_info -> scenes != ( char * ) NULL ) * read_info -> scenes = '\\0' ; } if ( * image_info -> magick == 'E' ) { option = GetImageOption ( image_info , ""eps:use-cropbox"" ) ; if ( ( option == ( const char * ) NULL ) || ( IsStringTrue ( option ) != MagickFalse ) ) ( void ) ConcatenateMagickString ( options , ""-dEPSCrop<S2SV_blank>"" , MagickPathExtent ) ; if ( fitPage != MagickFalse ) ( void ) ConcatenateMagickString ( options , ""-dEPSFitPage<S2SV_blank>"" , MagickPathExtent ) ; } ( void ) CopyMagickString ( filename , read_info -> filename , MagickPathExtent ) ; ( void ) AcquireUniqueFilename ( filename ) ; ( void ) RelinquishUniqueFileResource ( filename ) ; ( void ) ConcatenateMagickString ( filename , ""%d"" , MagickPathExtent ) ; ( void ) FormatLocaleString ( command , MagickPathExtent , GetDelegateCommands ( delegate_info ) , read_info -> antialias != MagickFalse ? 4 : 1 , read_info -> antialias != MagickFalse ? 4 : 1 , density , options , filename , postscript_filename , input_filename ) ; options = DestroyString ( options ) ; density = DestroyString ( density ) ; * message = '\\0' ; status = InvokePostscriptDelegate ( read_info -> verbose , command , message , exception ) ; ( void ) InterpretImageFilename ( image_info , image , filename , 1 , read_info -> filename , exception ) ; if ( ( status == MagickFalse ) || ( IsPostscriptRendered ( read_info -> filename ) == MagickFalse ) ) { ( void ) ConcatenateMagickString ( command , ""<S2SV_blank>-c<S2SV_blank>showpage"" , MagickPathExtent ) ; status = InvokePostscriptDelegate ( read_info -> verbose , command , message , exception ) ; } ( void ) RelinquishUniqueFileResource ( postscript_filename ) ; ( void ) RelinquishUniqueFileResource ( input_filename ) ; postscript_image = ( Image * ) NULL ; if ( status == MagickFalse ) for ( i = 1 ; ; i ++ ) { ( void ) InterpretImageFilename ( image_info , image , filename , ( int ) i , read_info -> filename , exception ) ; if ( IsPostscriptRendered ( read_info -> filename ) == MagickFalse ) break ; ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; } else for ( i = 1 ; ; i ++ ) { ( void ) InterpretImageFilename ( image_info , image , filename , ( int ) i , read_info -> filename , exception ) ; if ( IsPostscriptRendered ( read_info -> filename ) == MagickFalse ) break ; read_info -> blob = NULL ; read_info -> length = 0 ; next = ReadImage ( read_info , exception ) ; ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; if ( next == ( Image * ) NULL ) break ; AppendImageToList ( & postscript_image , next ) ; } ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; read_info = DestroyImageInfo ( read_info ) ; if ( postscript_image == ( Image * ) NULL ) { if ( * message != '\\0' ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , DelegateError , ""PostscriptDelegateFailed"" , ""`%s\'"" , message ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( LocaleCompare ( postscript_image -> magick , ""BMP"" ) == 0 ) { Image * cmyk_image ; cmyk_image = ConsolidateCMYKImages ( postscript_image , exception ) ; if ( cmyk_image != ( Image * ) NULL ) { postscript_image = DestroyImageList ( postscript_image ) ; postscript_image = cmyk_image ; } } if ( image_info -> number_scenes != 0 ) { Image * clone_image ; for ( i = 0 ; i < ( ssize_t ) image_info -> scene ; i ++ ) { clone_image = CloneImage ( postscript_image , 1 , 1 , MagickTrue , exception ) ; if ( clone_image != ( Image * ) NULL ) PrependImageToList ( & postscript_image , clone_image ) ; } } do { ( void ) CopyMagickString ( postscript_image -> filename , filename , MagickPathExtent ) ; ( void ) CopyMagickString ( postscript_image -> magick , image -> magick , MagickPathExtent ) ; if ( columns != 0 ) postscript_image -> magick_columns = columns ; if ( rows != 0 ) postscript_image -> magick_rows = rows ; postscript_image -> page = page ; ( void ) CloneImageProfiles ( postscript_image , image ) ; ( void ) CloneImageProperties ( postscript_image , image ) ; next = SyncNextImageInList ( postscript_image ) ; if ( next != ( Image * ) NULL ) postscript_image = next ; } while ( next != ( Image * ) NULL ) ; image = DestroyImageList ( image ) ; scene = 0 ; for ( next = GetFirstImageInList ( postscript_image ) ; next != ( Image * ) NULL ; ) { next -> scene = scene ++ ; next = GetNextImageInList ( next ) ; } return ( GetFirstImageInList ( postscript_image ) ) ; }
","<S2SV_ModStart> = extent ; if ( length > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;
"
312,"CWE-362 static int sctp_setsockopt_auto_asconf ( struct sock * sk , char __user * optval , unsigned int optlen ) { int val ; struct sctp_sock * sp = sctp_sk ( sk ) ; if ( optlen < sizeof ( int ) ) return - EINVAL ; if ( get_user ( val , ( int __user * ) optval ) ) return - EFAULT ; if ( ! sctp_is_ep_boundall ( sk ) && val ) return - EINVAL ; if ( ( val && sp -> do_auto_asconf ) || ( ! val && ! sp -> do_auto_asconf ) ) return 0 ; <S2SV_StartBug> if ( val == 0 && sp -> do_auto_asconf ) { <S2SV_EndBug> list_del ( & sp -> auto_asconf_list ) ; sp -> do_auto_asconf = 0 ; } else if ( val && ! sp -> do_auto_asconf ) { list_add_tail ( & sp -> auto_asconf_list , & sock_net ( sk ) -> sctp . auto_asconf_splist ) ; sp -> do_auto_asconf = 1 ; } <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
","<S2SV_ModStart> return 0 ; spin_lock_bh ( & sock_net ( sk ) -> sctp . addr_wq_lock ) ; <S2SV_ModStart> 1 ; } spin_unlock_bh ( & sock_net ( sk ) -> sctp . addr_wq_lock ) ;
"
313,"CWE-190 int jas_stream_gobble ( jas_stream_t * stream , int n ) { <S2SV_StartBug> int m ; <S2SV_EndBug> m = n ; for ( m = n ; m > 0 ; -- m ) { if ( jas_stream_getc ( stream ) == EOF ) { return n - m ; } } return n ; }
","<S2SV_ModStart> int m ; if ( n < 0 ) { jas_deprecated ( ""negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_gobble"" ) ; }
"
314,"CWE-400 static struct task_struct * copy_process ( unsigned long clone_flags , unsigned long stack_start , struct pt_regs * regs , unsigned long stack_size , int __user * child_tidptr , struct pid * pid , int trace ) { int retval ; struct task_struct * p ; int cgroup_callbacks_done = 0 ; if ( ( clone_flags & ( CLONE_NEWNS | CLONE_FS ) ) == ( CLONE_NEWNS | CLONE_FS ) ) return ERR_PTR ( - EINVAL ) ; if ( ( clone_flags & CLONE_THREAD ) && ! ( clone_flags & CLONE_SIGHAND ) ) return ERR_PTR ( - EINVAL ) ; if ( ( clone_flags & CLONE_SIGHAND ) && ! ( clone_flags & CLONE_VM ) ) return ERR_PTR ( - EINVAL ) ; if ( ( clone_flags & CLONE_PARENT ) && current -> signal -> flags & SIGNAL_UNKILLABLE ) return ERR_PTR ( - EINVAL ) ; retval = security_task_create ( clone_flags ) ; if ( retval ) goto fork_out ; retval = - ENOMEM ; p = dup_task_struct ( current ) ; if ( ! p ) goto fork_out ; ftrace_graph_init_task ( p ) ; rt_mutex_init_task ( p ) ; # ifdef CONFIG_PROVE_LOCKING DEBUG_LOCKS_WARN_ON ( ! p -> hardirqs_enabled ) ; DEBUG_LOCKS_WARN_ON ( ! p -> softirqs_enabled ) ; # endif retval = - EAGAIN ; if ( atomic_read ( & p -> real_cred -> user -> processes ) >= p -> signal -> rlim [ RLIMIT_NPROC ] . rlim_cur ) { if ( ! capable ( CAP_SYS_ADMIN ) && ! capable ( CAP_SYS_RESOURCE ) && p -> real_cred -> user != INIT_USER ) goto bad_fork_free ; } retval = copy_creds ( p , clone_flags ) ; if ( retval < 0 ) goto bad_fork_free ; retval = - EAGAIN ; if ( nr_threads >= max_threads ) goto bad_fork_cleanup_count ; if ( ! try_module_get ( task_thread_info ( p ) -> exec_domain -> module ) ) goto bad_fork_cleanup_count ; p -> did_exec = 0 ; delayacct_tsk_init ( p ) ; copy_flags ( clone_flags , p ) ; INIT_LIST_HEAD ( & p -> children ) ; INIT_LIST_HEAD ( & p -> sibling ) ; rcu_copy_process ( p ) ; p -> vfork_done = NULL ; spin_lock_init ( & p -> alloc_lock ) ; init_sigpending ( & p -> pending ) ; p -> utime = cputime_zero ; p -> stime = cputime_zero ; p -> gtime = cputime_zero ; p -> utimescaled = cputime_zero ; p -> stimescaled = cputime_zero ; p -> prev_utime = cputime_zero ; p -> prev_stime = cputime_zero ; p -> default_timer_slack_ns = current -> timer_slack_ns ; task_io_accounting_init ( & p -> ioac ) ; acct_clear_integrals ( p ) ; posix_cpu_timers_init ( p ) ; p -> lock_depth = - 1 ; do_posix_clock_monotonic_gettime ( & p -> start_time ) ; p -> real_start_time = p -> start_time ; monotonic_to_bootbased ( & p -> real_start_time ) ; p -> io_context = NULL ; p -> audit_context = NULL ; cgroup_fork ( p ) ; # ifdef CONFIG_NUMA p -> mempolicy = mpol_dup ( p -> mempolicy ) ; if ( IS_ERR ( p -> mempolicy ) ) { retval = PTR_ERR ( p -> mempolicy ) ; p -> mempolicy = NULL ; goto bad_fork_cleanup_cgroup ; } mpol_fix_fork_child_flag ( p ) ; # endif # ifdef CONFIG_TRACE_IRQFLAGS p -> irq_events = 0 ; # ifdef __ARCH_WANT_INTERRUPTS_ON_CTXSW p -> hardirqs_enabled = 1 ; # else p -> hardirqs_enabled = 0 ; # endif p -> hardirq_enable_ip = 0 ; p -> hardirq_enable_event = 0 ; p -> hardirq_disable_ip = _THIS_IP_ ; p -> hardirq_disable_event = 0 ; p -> softirqs_enabled = 1 ; p -> softirq_enable_ip = _THIS_IP_ ; p -> softirq_enable_event = 0 ; p -> softirq_disable_ip = 0 ; p -> softirq_disable_event = 0 ; p -> hardirq_context = 0 ; p -> softirq_context = 0 ; # endif # ifdef CONFIG_LOCKDEP p -> lockdep_depth = 0 ; p -> curr_chain_key = 0 ; p -> lockdep_recursion = 0 ; # endif # ifdef CONFIG_DEBUG_MUTEXES p -> blocked_on = NULL ; # endif p -> bts = NULL ; p -> stack_start = stack_start ; sched_fork ( p , clone_flags ) ; retval = perf_event_init_task ( p ) ; if ( retval ) goto bad_fork_cleanup_policy ; if ( ( retval = audit_alloc ( p ) ) ) goto bad_fork_cleanup_policy ; if ( ( retval = copy_semundo ( clone_flags , p ) ) ) goto bad_fork_cleanup_audit ; if ( ( retval = copy_files ( clone_flags , p ) ) ) goto bad_fork_cleanup_semundo ; if ( ( retval = copy_fs ( clone_flags , p ) ) ) goto bad_fork_cleanup_files ; if ( ( retval = copy_sighand ( clone_flags , p ) ) ) goto bad_fork_cleanup_fs ; if ( ( retval = copy_signal ( clone_flags , p ) ) ) goto bad_fork_cleanup_sighand ; if ( ( retval = copy_mm ( clone_flags , p ) ) ) goto bad_fork_cleanup_signal ; if ( ( retval = copy_namespaces ( clone_flags , p ) ) ) goto bad_fork_cleanup_mm ; if ( ( retval = copy_io ( clone_flags , p ) ) ) goto bad_fork_cleanup_namespaces ; retval = copy_thread ( clone_flags , stack_start , stack_size , p , regs ) ; if ( retval ) goto bad_fork_cleanup_io ; if ( pid != & init_struct_pid ) { retval = - ENOMEM ; pid = alloc_pid ( p -> nsproxy -> pid_ns ) ; if ( ! pid ) goto bad_fork_cleanup_io ; if ( clone_flags & CLONE_NEWPID ) { retval = pid_ns_prepare_proc ( p -> nsproxy -> pid_ns ) ; if ( retval < 0 ) goto bad_fork_free_pid ; } } p -> pid = pid_nr ( pid ) ; p -> tgid = p -> pid ; if ( clone_flags & CLONE_THREAD ) p -> tgid = current -> tgid ; if ( current -> nsproxy != p -> nsproxy ) { retval = ns_cgroup_clone ( p , pid ) ; if ( retval ) goto bad_fork_free_pid ; } p -> set_child_tid = ( clone_flags & CLONE_CHILD_SETTID ) ? child_tidptr : NULL ; p -> clear_child_tid = ( clone_flags & CLONE_CHILD_CLEARTID ) ? child_tidptr : NULL ; # ifdef CONFIG_FUTEX p -> robust_list = NULL ; # ifdef CONFIG_COMPAT p -> compat_robust_list = NULL ; # endif INIT_LIST_HEAD ( & p -> pi_state_list ) ; p -> pi_state_cache = NULL ; # endif if ( ( clone_flags & ( CLONE_VM | CLONE_VFORK ) ) == CLONE_VM ) p -> sas_ss_sp = p -> sas_ss_size = 0 ; clear_tsk_thread_flag ( p , TIF_SYSCALL_TRACE ) ; # ifdef TIF_SYSCALL_EMU clear_tsk_thread_flag ( p , TIF_SYSCALL_EMU ) ; # endif clear_all_latency_tracing ( p ) ; p -> exit_signal = ( clone_flags & CLONE_THREAD ) ? - 1 : ( clone_flags & CSIGNAL ) ; p -> pdeath_signal = 0 ; p -> exit_state = 0 ; p -> group_leader = p ; INIT_LIST_HEAD ( & p -> thread_group ) ; cgroup_fork_callbacks ( p ) ; cgroup_callbacks_done = 1 ; write_lock_irq ( & tasklist_lock ) ; p -> cpus_allowed = current -> cpus_allowed ; p -> rt . nr_cpus_allowed = current -> rt . nr_cpus_allowed ; if ( unlikely ( ! cpu_isset ( task_cpu ( p ) , p -> cpus_allowed ) || ! cpu_online ( task_cpu ( p ) ) ) ) set_task_cpu ( p , smp_processor_id ( ) ) ; if ( clone_flags & ( CLONE_PARENT | CLONE_THREAD ) ) { p -> real_parent = current -> real_parent ; p -> parent_exec_id = current -> parent_exec_id ; } else { p -> real_parent = current ; p -> parent_exec_id = current -> self_exec_id ; } spin_lock ( & current -> sighand -> siglock ) ; recalc_sigpending ( ) ; if ( signal_pending ( current ) ) { spin_unlock ( & current -> sighand -> siglock ) ; write_unlock_irq ( & tasklist_lock ) ; retval = - ERESTARTNOINTR ; goto bad_fork_free_pid ; } if ( clone_flags & CLONE_THREAD ) { atomic_inc ( & current -> signal -> count ) ; atomic_inc ( & current -> signal -> live ) ; p -> group_leader = current -> group_leader ; list_add_tail_rcu ( & p -> thread_group , & p -> group_leader -> thread_group ) ; } if ( likely ( p -> pid ) ) { list_add_tail ( & p -> sibling , & p -> real_parent -> children ) ; tracehook_finish_clone ( p , clone_flags , trace ) ; if ( thread_group_leader ( p ) ) { if ( clone_flags & CLONE_NEWPID ) p -> nsproxy -> pid_ns -> child_reaper = p ; p -> signal -> leader_pid = pid ; tty_kref_put ( p -> signal -> tty ) ; p -> signal -> tty = tty_kref_get ( current -> signal -> tty ) ; attach_pid ( p , PIDTYPE_PGID , task_pgrp ( current ) ) ; attach_pid ( p , PIDTYPE_SID , task_session ( current ) ) ; list_add_tail_rcu ( & p -> tasks , & init_task . tasks ) ; __get_cpu_var ( process_counts ) ++ ; } attach_pid ( p , PIDTYPE_PID , pid ) ; nr_threads ++ ; } total_forks ++ ; spin_unlock ( & current -> sighand -> siglock ) ; write_unlock_irq ( & tasklist_lock ) ; proc_fork_connector ( p ) ; cgroup_post_fork ( p ) ; perf_event_fork ( p ) ; return p ; bad_fork_free_pid : if ( pid != & init_struct_pid ) free_pid ( pid ) ; bad_fork_cleanup_io : <S2SV_StartBug> put_io_context ( p -> io_context ) ; <S2SV_EndBug> bad_fork_cleanup_namespaces : exit_task_namespaces ( p ) ; bad_fork_cleanup_mm : if ( p -> mm ) mmput ( p -> mm ) ; bad_fork_cleanup_signal : if ( ! ( clone_flags & CLONE_THREAD ) ) __cleanup_signal ( p -> signal ) ; bad_fork_cleanup_sighand : __cleanup_sighand ( p -> sighand ) ; bad_fork_cleanup_fs : exit_fs ( p ) ; bad_fork_cleanup_files : exit_files ( p ) ; bad_fork_cleanup_semundo : exit_sem ( p ) ; bad_fork_cleanup_audit : audit_free ( p ) ; bad_fork_cleanup_policy : perf_event_free_task ( p ) ; # ifdef CONFIG_NUMA mpol_put ( p -> mempolicy ) ; bad_fork_cleanup_cgroup : # endif cgroup_exit ( p , cgroup_callbacks_done ) ; delayacct_tsk_free ( p ) ; module_put ( task_thread_info ( p ) -> exec_domain -> module ) ; bad_fork_cleanup_count : atomic_dec ( & p -> cred -> user -> processes ) ; exit_creds ( p ) ; bad_fork_free : free_task ( p ) ; fork_out : return ERR_PTR ( retval ) ; }
","<S2SV_ModStart> ; bad_fork_cleanup_io : if <S2SV_ModEnd> ( p -> <S2SV_ModStart> p -> io_context ) exit_io_context ( p
"
315,"CWE-787 <S2SV_StartBug> static int shash_no_setkey ( struct crypto_shash * tfm , const u8 * key , <S2SV_EndBug> unsigned int keylen ) { return - ENOSYS ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> int shash_no_setkey (
"
316,"CWE-552 ssize_t oe_recvfrom ( int sockfd , void * buf , size_t len , int flags , <S2SV_StartBug> const struct oe_sockaddr * src_addr , <S2SV_EndBug> oe_socklen_t * addrlen ) { ssize_t ret = - 1 ; oe_fd_t * sock ; if ( ! ( sock = oe_fdtable_get ( sockfd , OE_FD_TYPE_SOCKET ) ) ) OE_RAISE_ERRNO ( oe_errno ) ; ret = sock -> ops . socket . recvfrom ( sock , buf , len , flags , src_addr , addrlen ) ; done : return ret ; }
","<S2SV_ModStart> int flags , <S2SV_ModEnd> struct oe_sockaddr *
"
317,"CWE-416 <S2SV_StartBug> static void buffer_pipe_buf_get ( struct pipe_inode_info * pipe , <S2SV_EndBug> struct pipe_buffer * buf ) { struct buffer_ref * ref = ( struct buffer_ref * ) buf -> private ; <S2SV_StartBug> ref -> ref ++ ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static bool <S2SV_ModEnd> buffer_pipe_buf_get ( struct <S2SV_ModStart> -> private ; if ( ref -> ref > INT_MAX / 2 ) return false ; <S2SV_ModStart> ref ++ ; return true ;
"
318,"CWE-200 int equalizer_get_parameter ( effect_context_t * context , effect_param_t * p , uint32_t * size ) { equalizer_context_t * eq_ctxt = ( equalizer_context_t * ) context ; int voffset = ( ( p -> psize - 1 ) / sizeof ( int32_t ) + 1 ) * sizeof ( int32_t ) ; int32_t * param_tmp = ( int32_t * ) p -> data ; int32_t param = * param_tmp ++ ; int32_t param2 ; char * name ; void * value = p -> data + voffset ; int i ; ALOGV ( ""%s"" , __func__ ) ; p -> status = 0 ; switch ( param ) { case EQ_PARAM_NUM_BANDS : case EQ_PARAM_CUR_PRESET : case EQ_PARAM_GET_NUM_OF_PRESETS : case EQ_PARAM_BAND_LEVEL : case EQ_PARAM_GET_BAND : if ( p -> vsize < sizeof ( int16_t ) ) p -> status = - EINVAL ; p -> vsize = sizeof ( int16_t ) ; break ; case EQ_PARAM_LEVEL_RANGE : if ( p -> vsize < 2 * sizeof ( int16_t ) ) p -> status = - EINVAL ; p -> vsize = 2 * sizeof ( int16_t ) ; break ; case EQ_PARAM_BAND_FREQ_RANGE : if ( p -> vsize < 2 * sizeof ( int32_t ) ) p -> status = - EINVAL ; p -> vsize = 2 * sizeof ( int32_t ) ; break ; case EQ_PARAM_CENTER_FREQ : if ( p -> vsize < sizeof ( int32_t ) ) p -> status = - EINVAL ; p -> vsize = sizeof ( int32_t ) ; break ; case EQ_PARAM_GET_PRESET_NAME : break ; case EQ_PARAM_PROPERTIES : if ( p -> vsize < ( 2 + NUM_EQ_BANDS ) * sizeof ( uint16_t ) ) p -> status = - EINVAL ; p -> vsize = ( 2 + NUM_EQ_BANDS ) * sizeof ( uint16_t ) ; break ; default : p -> status = - EINVAL ; } * size = sizeof ( effect_param_t ) + voffset + p -> vsize ; if ( p -> status != 0 ) return 0 ; switch ( param ) { case EQ_PARAM_NUM_BANDS : ALOGV ( ""%s:<S2SV_blank>EQ_PARAM_NUM_BANDS"" , __func__ ) ; * ( uint16_t * ) value = ( uint16_t ) NUM_EQ_BANDS ; break ; case EQ_PARAM_LEVEL_RANGE : ALOGV ( ""%s:<S2SV_blank>EQ_PARAM_LEVEL_RANGE"" , __func__ ) ; * ( int16_t * ) value = - 1500 ; * ( ( int16_t * ) value + 1 ) = 1500 ; break ; case EQ_PARAM_BAND_LEVEL : ALOGV ( ""%s:<S2SV_blank>EQ_PARAM_BAND_LEVEL"" , __func__ ) ; param2 = * param_tmp ; <S2SV_StartBug> if ( param2 >= NUM_EQ_BANDS ) { <S2SV_EndBug> p -> status = - EINVAL ; <S2SV_StartBug> break ; <S2SV_EndBug> } * ( int16_t * ) value = ( int16_t ) equalizer_get_band_level ( eq_ctxt , param2 ) ; break ; case EQ_PARAM_CENTER_FREQ : ALOGV ( ""%s:<S2SV_blank>EQ_PARAM_CENTER_FREQ"" , __func__ ) ; param2 = * param_tmp ; <S2SV_StartBug> if ( param2 >= NUM_EQ_BANDS ) { <S2SV_EndBug> p -> status = - EINVAL ; <S2SV_StartBug> break ; <S2SV_EndBug> } * ( int32_t * ) value = equalizer_get_center_frequency ( eq_ctxt , param2 ) ; break ; case EQ_PARAM_BAND_FREQ_RANGE : ALOGV ( ""%s:<S2SV_blank>EQ_PARAM_BAND_FREQ_RANGE"" , __func__ ) ; param2 = * param_tmp ; <S2SV_StartBug> if ( param2 >= NUM_EQ_BANDS ) { <S2SV_EndBug> <S2SV_StartBug> p -> status = - EINVAL ; <S2SV_EndBug> break ; } equalizer_get_band_freq_range ( eq_ctxt , param2 , ( uint32_t * ) value , ( ( uint32_t * ) value + 1 ) ) ; break ; case EQ_PARAM_GET_BAND : ALOGV ( ""%s:<S2SV_blank>EQ_PARAM_GET_BAND"" , __func__ ) ; param2 = * param_tmp ; * ( uint16_t * ) value = ( uint16_t ) equalizer_get_band ( eq_ctxt , param2 ) ; break ; case EQ_PARAM_CUR_PRESET : ALOGV ( ""%s:<S2SV_blank>EQ_PARAM_CUR_PRESET"" , __func__ ) ; * ( uint16_t * ) value = ( uint16_t ) equalizer_get_preset ( eq_ctxt ) ; break ; case EQ_PARAM_GET_NUM_OF_PRESETS : ALOGV ( ""%s:<S2SV_blank>EQ_PARAM_GET_NUM_OF_PRESETS"" , __func__ ) ; * ( uint16_t * ) value = ( uint16_t ) equalizer_get_num_presets ( eq_ctxt ) ; break ; case EQ_PARAM_GET_PRESET_NAME : ALOGV ( ""%s:<S2SV_blank>EQ_PARAM_GET_PRESET_NAME"" , __func__ ) ; param2 = * param_tmp ; ALOGV ( ""param2:<S2SV_blank>%d"" , param2 ) ; if ( param2 >= equalizer_get_num_presets ( eq_ctxt ) ) { p -> status = - EINVAL ; break ; } name = ( char * ) value ; strlcpy ( name , equalizer_get_preset_name ( eq_ctxt , param2 ) , p -> vsize - 1 ) ; name [ p -> vsize - 1 ] = 0 ; p -> vsize = strlen ( name ) + 1 ; break ; case EQ_PARAM_PROPERTIES : { ALOGV ( ""%s:<S2SV_blank>EQ_PARAM_PROPERTIES"" , __func__ ) ; int16_t * prop = ( int16_t * ) value ; prop [ 0 ] = ( int16_t ) equalizer_get_preset ( eq_ctxt ) ; prop [ 1 ] = ( int16_t ) NUM_EQ_BANDS ; for ( i = 0 ; i < NUM_EQ_BANDS ; i ++ ) { prop [ 2 + i ] = ( int16_t ) equalizer_get_band_level ( eq_ctxt , i ) ; } } break ; default : p -> status = - EINVAL ; break ; } return 0 ; }
","<S2SV_ModStart> if ( param2 < 0 || param2 <S2SV_ModStart> - EINVAL ; if ( param2 < 0 ) { android_errorWriteLog ( 0x534e4554 , ""32438598"" ) ; ALOGW ( ""\\tERROR<S2SV_blank>EQ_PARAM_BAND_LEVEL<S2SV_blank>band<S2SV_blank>%d"" , param2 ) ; } <S2SV_ModStart> ; if ( param2 < 0 || <S2SV_ModStart> - EINVAL ; if ( param2 < 0 ) { android_errorWriteLog ( 0x534e4554 , ""32436341"" ) ; ALOGW ( ""\\tERROR<S2SV_blank>EQ_PARAM_CENTER_FREQ<S2SV_blank>band<S2SV_blank>%d"" , param2 ) ; } <S2SV_ModStart> ; if ( param2 < 0 || <S2SV_ModStart> - EINVAL ; if ( param2 < 0 ) { android_errorWriteLog ( 0x534e4554 , ""32247948"" ) ; ALOGW ( ""\\tERROR<S2SV_blank>EQ_PARAM_BAND_FREQ_RANGE<S2SV_blank>band<S2SV_blank>%d"" , param2 ) ; }
"
319,"CWE-20 static cupsd_job_t * add_job ( cupsd_client_t * con , cupsd_printer_t * printer , mime_type_t * filetype ) { http_status_t status ; ipp_attribute_t * attr , * auth_info ; const char * mandatory ; const char * val ; int priority ; cupsd_job_t * job ; char job_uri [ HTTP_MAX_URI ] ; int kbytes ; int i ; int lowerpagerange ; int exact ; ipp_attribute_t * media_col , * media_margin ; ipp_t * unsup_col ; static const char * const readonly [ ] = { ""date-time-at-completed"" , ""date-time-at-creation"" , ""date-time-at-processing"" , ""job-detailed-status-messages"" , ""job-document-access-errors"" , ""job-id"" , ""job-impressions-completed"" , ""job-k-octets-completed"" , ""job-media-sheets-completed"" , ""job-pages-completed"" , ""job-printer-up-time"" , ""job-printer-uri"" , ""job-state"" , ""job-state-message"" , ""job-state-reasons"" , ""job-uri"" , ""number-of-documents"" , ""number-of-intervening-jobs"" , ""output-device-assigned"" , ""time-at-completed"" , ""time-at-creation"" , ""time-at-processing"" } ; cupsdLogMessage ( CUPSD_LOG_DEBUG2 , ""add_job(%p[%d],<S2SV_blank>%p(%s),<S2SV_blank>%p(%s/%s))"" , con , con -> number , printer , printer -> name , filetype , filetype ? filetype -> super : ""none"" , filetype ? filetype -> type : ""none"" ) ; if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , ""localhost"" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) ) { send_ipp_status ( con , IPP_NOT_AUTHORIZED , _ ( ""The<S2SV_blank>printer<S2SV_blank>or<S2SV_blank>class<S2SV_blank>is<S2SV_blank>not<S2SV_blank>shared."" ) ) ; return ( NULL ) ; } auth_info = ippFindAttribute ( con -> request , ""auth-info"" , IPP_TAG_TEXT ) ; if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK ) { send_http_error ( con , status , printer ) ; return ( NULL ) ; } else if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , ""negotiate"" ) && ! con -> username [ 0 ] ) { send_http_error ( con , HTTP_UNAUTHORIZED , printer ) ; return ( NULL ) ; } # ifdef HAVE_SSL else if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) ) { send_http_error ( con , HTTP_UPGRADE_REQUIRED , printer ) ; return ( NULL ) ; } # endif if ( ! printer -> accepting ) { send_ipp_status ( con , IPP_NOT_ACCEPTING , _ ( ""Destination<S2SV_blank>\\""%s\\""<S2SV_blank>is<S2SV_blank>not<S2SV_blank>accepting<S2SV_blank>jobs."" ) , printer -> name ) ; return ( NULL ) ; } for ( i = 0 ; i < ( int ) ( sizeof ( readonly ) / sizeof ( readonly [ 0 ] ) ) ; i ++ ) { if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL ) { ippDeleteAttribute ( con -> request , attr ) ; if ( StrictConformance ) { send_ipp_status ( con , IPP_BAD_REQUEST , _ ( ""The<S2SV_blank>\'%s\'<S2SV_blank>Job<S2SV_blank>Status<S2SV_blank>attribute<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>supplied<S2SV_blank>in<S2SV_blank>a<S2SV_blank>job<S2SV_blank>creation<S2SV_blank>request."" ) , readonly [ i ] ) ; return ( NULL ) ; } cupsdLogMessage ( CUPSD_LOG_INFO , ""Unexpected<S2SV_blank>\'%s\'<S2SV_blank>Job<S2SV_blank>Status<S2SV_blank>attribute<S2SV_blank>in<S2SV_blank>a<S2SV_blank>job<S2SV_blank>creation<S2SV_blank>request."" , readonly [ i ] ) ; } } if ( printer -> pc ) { for ( mandatory = ( char * ) cupsArrayFirst ( printer -> pc -> mandatory ) ; mandatory ; mandatory = ( char * ) cupsArrayNext ( printer -> pc -> mandatory ) ) { if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) ) { send_ipp_status ( con , IPP_CONFLICT , _ ( ""The<S2SV_blank>\\""%s\\""<S2SV_blank>attribute<S2SV_blank>is<S2SV_blank>required<S2SV_blank>for<S2SV_blank>print<S2SV_blank>jobs."" ) , mandatory ) ; return ( NULL ) ; } } } if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) ) { char mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; snprintf ( mimetype , sizeof ( mimetype ) , ""%s/%s"" , filetype -> super , filetype -> type ) ; send_ipp_status ( con , IPP_DOCUMENT_FORMAT , _ ( ""Unsupported<S2SV_blank>format<S2SV_blank>\\""%s\\""."" ) , mimetype ) ; ippAddString ( con -> response , IPP_TAG_UNSUPPORTED_GROUP , IPP_TAG_MIMETYPE , ""document-format"" , NULL , mimetype ) ; return ( NULL ) ; } if ( ( attr = ippFindAttribute ( con -> request , ""copies"" , IPP_TAG_INTEGER ) ) != NULL ) { if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies ) { send_ipp_status ( con , IPP_ATTRIBUTES , _ ( ""Bad<S2SV_blank>copies<S2SV_blank>value<S2SV_blank>%d."" ) , attr -> values [ 0 ] . integer ) ; ippAddInteger ( con -> response , IPP_TAG_UNSUPPORTED_GROUP , IPP_TAG_INTEGER , ""copies"" , attr -> values [ 0 ] . integer ) ; return ( NULL ) ; } } if ( ( attr = ippFindAttribute ( con -> request , ""job-sheets"" , IPP_TAG_ZERO ) ) != NULL ) { if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME ) { send_ipp_status ( con , IPP_BAD_REQUEST , _ ( ""Bad<S2SV_blank>job-sheets<S2SV_blank>value<S2SV_blank>type."" ) ) ; return ( NULL ) ; } if ( attr -> num_values > 2 ) { send_ipp_status ( con , IPP_BAD_REQUEST , _ ( ""Too<S2SV_blank>many<S2SV_blank>job-sheets<S2SV_blank>values<S2SV_blank>(%d<S2SV_blank>><S2SV_blank>2)."" ) , attr -> num_values ) ; return ( NULL ) ; } for ( i = 0 ; i < attr -> num_values ; i ++ ) if ( strcmp ( attr -> values [ i ] . string . text , ""none"" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) ) { send_ipp_status ( con , IPP_BAD_REQUEST , _ ( ""Bad<S2SV_blank>job-sheets<S2SV_blank>value<S2SV_blank>\\""%s\\""."" ) , attr -> values [ i ] . string . text ) ; return ( NULL ) ; } } if ( ( attr = ippFindAttribute ( con -> request , ""number-up"" , IPP_TAG_INTEGER ) ) != NULL ) { if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 ) { send_ipp_status ( con , IPP_ATTRIBUTES , _ ( ""Bad<S2SV_blank>number-up<S2SV_blank>value<S2SV_blank>%d."" ) , attr -> values [ 0 ] . integer ) ; ippAddInteger ( con -> response , IPP_TAG_UNSUPPORTED_GROUP , IPP_TAG_INTEGER , ""number-up"" , attr -> values [ 0 ] . integer ) ; return ( NULL ) ; } } if ( ( attr = ippFindAttribute ( con -> request , ""page-ranges"" , IPP_TAG_RANGE ) ) != NULL ) { for ( i = 0 , lowerpagerange = 1 ; i < attr -> num_values ; i ++ ) { if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper ) { send_ipp_status ( con , IPP_BAD_REQUEST , _ ( ""Bad<S2SV_blank>page-ranges<S2SV_blank>values<S2SV_blank>%d-%d."" ) , attr -> values [ i ] . range . lower , attr -> values [ i ] . range . upper ) ; return ( NULL ) ; } lowerpagerange = attr -> values [ i ] . range . upper + 1 ; } } if ( ! ippFindAttribute ( con -> request , ""PageRegion"" , IPP_TAG_ZERO ) && ! ippFindAttribute ( con -> request , ""PageSize"" , IPP_TAG_ZERO ) && _ppdCacheGetPageSize ( printer -> pc , con -> request , NULL , & exact ) ) { if ( ! exact && ( media_col = ippFindAttribute ( con -> request , ""media-col"" , IPP_TAG_BEGIN_COLLECTION ) ) != NULL ) { send_ipp_status ( con , IPP_OK_SUBST , _ ( ""Unsupported<S2SV_blank>margins."" ) ) ; unsup_col = ippNew ( ) ; if ( ( media_margin = ippFindAttribute ( media_col -> values [ 0 ] . collection , ""media-bottom-margin"" , IPP_TAG_INTEGER ) ) != NULL ) ippAddInteger ( unsup_col , IPP_TAG_ZERO , IPP_TAG_INTEGER , ""media-bottom-margin"" , media_margin -> values [ 0 ] . integer ) ; if ( ( media_margin = ippFindAttribute ( media_col -> values [ 0 ] . collection , ""media-left-margin"" , IPP_TAG_INTEGER ) ) != NULL ) ippAddInteger ( unsup_col , IPP_TAG_ZERO , IPP_TAG_INTEGER , ""media-left-margin"" , media_margin -> values [ 0 ] . integer ) ; if ( ( media_margin = ippFindAttribute ( media_col -> values [ 0 ] . collection , ""media-right-margin"" , IPP_TAG_INTEGER ) ) != NULL ) ippAddInteger ( unsup_col , IPP_TAG_ZERO , IPP_TAG_INTEGER , ""media-right-margin"" , media_margin -> values [ 0 ] . integer ) ; if ( ( media_margin = ippFindAttribute ( media_col -> values [ 0 ] . collection , ""media-top-margin"" , IPP_TAG_INTEGER ) ) != NULL ) ippAddInteger ( unsup_col , IPP_TAG_ZERO , IPP_TAG_INTEGER , ""media-top-margin"" , media_margin -> values [ 0 ] . integer ) ; ippAddCollection ( con -> response , IPP_TAG_UNSUPPORTED_GROUP , ""media-col"" , unsup_col ) ; ippDelete ( unsup_col ) ; } } if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs ) cupsdCleanJobs ( ) ; if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs ) { send_ipp_status ( con , IPP_NOT_POSSIBLE , _ ( ""Too<S2SV_blank>many<S2SV_blank>active<S2SV_blank>jobs."" ) ) ; return ( NULL ) ; } if ( ( i = check_quotas ( con , printer ) ) < 0 ) { send_ipp_status ( con , IPP_NOT_POSSIBLE , _ ( ""Quota<S2SV_blank>limit<S2SV_blank>reached."" ) ) ; return ( NULL ) ; } else if ( i == 0 ) { send_ipp_status ( con , IPP_NOT_AUTHORIZED , _ ( ""Not<S2SV_blank>allowed<S2SV_blank>to<S2SV_blank>print."" ) ) ; return ( NULL ) ; } if ( ( attr = ippFindAttribute ( con -> request , ""job-priority"" , IPP_TAG_INTEGER ) ) != NULL ) priority = attr -> values [ 0 ] . integer ; else { if ( ( val = cupsGetOption ( ""job-priority"" , printer -> num_options , printer -> options ) ) != NULL ) priority = atoi ( val ) ; else priority = 50 ; ippAddInteger ( con -> request , IPP_TAG_JOB , IPP_TAG_INTEGER , ""job-priority"" , priority ) ; } if ( ( attr = ippFindAttribute ( con -> request , ""job-name"" , IPP_TAG_ZERO ) ) == NULL ) ippAddString ( con -> request , IPP_TAG_JOB , IPP_TAG_NAME , ""job-name"" , NULL , ""Untitled"" ) ; else if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 ) { send_ipp_status ( con , IPP_ATTRIBUTES , _ ( ""Bad<S2SV_blank>job-name<S2SV_blank>value:<S2SV_blank>Wrong<S2SV_blank>type<S2SV_blank>or<S2SV_blank>count."" ) ) ; if ( ( attr = ippCopyAttribute ( con -> response , attr , 0 ) ) != NULL ) attr -> group_tag = IPP_TAG_UNSUPPORTED_GROUP ; return ( NULL ) ; } else if ( ! ippValidateAttribute ( attr ) ) { send_ipp_status ( con , IPP_ATTRIBUTES , _ ( ""Bad<S2SV_blank>job-name<S2SV_blank>value:<S2SV_blank>%s"" ) , cupsLastErrorString ( ) ) ; if ( ( attr = ippCopyAttribute ( con -> response , attr , 0 ) ) != NULL ) attr -> group_tag = IPP_TAG_UNSUPPORTED_GROUP ; return ( NULL ) ; } <S2SV_StartBug> if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL ) <S2SV_EndBug> { send_ipp_status ( con , IPP_INTERNAL_ERROR , _ ( ""Unable<S2SV_blank>to<S2SV_blank>add<S2SV_blank>job<S2SV_blank>for<S2SV_blank>destination<S2SV_blank>\\""%s\\""."" ) , printer -> name ) ; return ( NULL ) ; } job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ) ; job -> attrs = con -> request ; job -> dirty = 1 ; con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ) ; cupsdMarkDirty ( CUPSD_DIRTY_JOBS ) ; add_job_uuid ( job ) ; <S2SV_StartBug> apply_printer_defaults ( printer , job ) ; <S2SV_EndBug> attr = ippFindAttribute ( job -> attrs , ""requesting-user-name"" , IPP_TAG_NAME ) ; if ( con -> username [ 0 ] ) { cupsdSetString ( & job -> username , con -> username ) ; if ( attr ) ippSetString ( job -> attrs , & attr , 0 , con -> username ) ; } else if ( attr ) { cupsdLogMessage ( CUPSD_LOG_DEBUG , ""add_job:<S2SV_blank>requesting-user-name=\\""%s\\"""" , attr -> values [ 0 ] . string . text ) ; cupsdSetString ( & job -> username , attr -> values [ 0 ] . string . text ) ; } else cupsdSetString ( & job -> username , ""anonymous"" ) ; if ( ! attr ) ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , ""job-originating-user-name"" , NULL , job -> username ) ; else { ippSetGroupTag ( job -> attrs , & attr , IPP_TAG_JOB ) ; ippSetName ( job -> attrs , & attr , ""job-originating-user-name"" ) ; } if ( con -> username [ 0 ] || auth_info ) { save_auth_info ( con , job , auth_info ) ; if ( auth_info ) ippDeleteAttribute ( job -> attrs , auth_info ) ; } if ( ( attr = ippFindAttribute ( con -> request , ""job-name"" , IPP_TAG_NAME ) ) != NULL ) cupsdSetString ( & ( job -> name ) , attr -> values [ 0 ] . string . text ) ; if ( ( attr = ippFindAttribute ( job -> attrs , ""job-originating-host-name"" , IPP_TAG_ZERO ) ) != NULL ) { if ( attr -> value_tag != IPP_TAG_NAME || attr -> num_values != 1 || strcmp ( con -> http -> hostname , ""localhost"" ) ) { ippDeleteAttribute ( job -> attrs , attr ) ; ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , ""job-originating-host-name"" , NULL , con -> http -> hostname ) ; } else ippSetGroupTag ( job -> attrs , & attr , IPP_TAG_JOB ) ; } else { ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , ""job-originating-host-name"" , NULL , con -> http -> hostname ) ; } ippAddOutOfBand ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NOVALUE , ""date-time-at-completed"" ) ; ippAddDate ( job -> attrs , IPP_TAG_JOB , ""date-time-at-creation"" , ippTimeToDate ( time ( NULL ) ) ) ; ippAddOutOfBand ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NOVALUE , ""date-time-at-processing"" ) ; ippAddOutOfBand ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NOVALUE , ""time-at-completed"" ) ; ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , ""time-at-creation"" , time ( NULL ) ) ; ippAddOutOfBand ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NOVALUE , ""time-at-processing"" ) ; ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , ""job-id"" , job -> id ) ; job -> state = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_ENUM , ""job-state"" , IPP_JOB_STOPPED ) ; job -> state_value = ( ipp_jstate_t ) job -> state -> values [ 0 ] . integer ; job -> reasons = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , ""job-state-reasons"" , NULL , ""job-incoming"" ) ; job -> impressions = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , ""job-impressions-completed"" , 0 ) ; job -> sheets = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , ""job-media-sheets-completed"" , 0 ) ; ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_URI , ""job-printer-uri"" , NULL , printer -> uri ) ; if ( ( attr = ippFindAttribute ( job -> attrs , ""job-k-octets"" , IPP_TAG_INTEGER ) ) != NULL ) attr -> values [ 0 ] . integer = 0 ; else ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , ""job-k-octets"" , 0 ) ; if ( ( attr = ippFindAttribute ( job -> attrs , ""job-hold-until"" , IPP_TAG_KEYWORD ) ) == NULL ) attr = ippFindAttribute ( job -> attrs , ""job-hold-until"" , IPP_TAG_NAME ) ; if ( ! attr ) { if ( ( val = cupsGetOption ( ""job-hold-until"" , printer -> num_options , printer -> options ) ) == NULL ) val = ""no-hold"" ; attr = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , ""job-hold-until"" , NULL , val ) ; } if ( printer -> holding_new_jobs ) { if ( attr && strcmp ( attr -> values [ 0 ] . string . text , ""no-hold"" ) ) cupsdSetJobHoldUntil ( job , ippGetString ( attr , 0 , NULL ) , 0 ) ; else cupsdSetJobHoldUntil ( job , ""indefinite"" , 0 ) ; job -> state -> values [ 0 ] . integer = IPP_JOB_HELD ; job -> state_value = IPP_JOB_HELD ; ippSetString ( job -> attrs , & job -> reasons , 0 , ""job-held-on-create"" ) ; } else if ( attr && strcmp ( attr -> values [ 0 ] . string . text , ""no-hold"" ) ) { cupsdSetJobHoldUntil ( job , attr -> values [ 0 ] . string . text , 0 ) ; job -> state -> values [ 0 ] . integer = IPP_JOB_HELD ; job -> state_value = IPP_JOB_HELD ; ippSetString ( job -> attrs , & job -> reasons , 0 , ""job-hold-until-specified"" ) ; } else if ( job -> attrs -> request . op . operation_id == IPP_CREATE_JOB ) { job -> hold_until = time ( NULL ) + MultipleOperationTimeout ; job -> state -> values [ 0 ] . integer = IPP_JOB_HELD ; job -> state_value = IPP_JOB_HELD ; } else { job -> state -> values [ 0 ] . integer = IPP_JOB_PENDING ; job -> state_value = IPP_JOB_PENDING ; ippSetString ( job -> attrs , & job -> reasons , 0 , ""none"" ) ; } if ( ! ( printer -> type & CUPS_PRINTER_REMOTE ) || Classification ) { if ( ( attr = ippFindAttribute ( job -> attrs , ""job-sheets"" , IPP_TAG_ZERO ) ) == NULL ) { cupsdLogMessage ( CUPSD_LOG_DEBUG , ""Adding<S2SV_blank>default<S2SV_blank>job-sheets<S2SV_blank>values<S2SV_blank>\\""%s,%s\\""..."" , printer -> job_sheets [ 0 ] , printer -> job_sheets [ 1 ] ) ; attr = ippAddStrings ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , ""job-sheets"" , 2 , NULL , NULL ) ; ippSetString ( job -> attrs , & attr , 0 , printer -> job_sheets [ 0 ] ) ; ippSetString ( job -> attrs , & attr , 1 , printer -> job_sheets [ 1 ] ) ; } job -> job_sheets = attr ; if ( Classification ) { cupsdLogMessage ( CUPSD_LOG_INFO , ""Classification=\\""%s\\"",<S2SV_blank>ClassifyOverride=%d"" , Classification ? Classification : ""(null)"" , ClassifyOverride ) ; if ( ClassifyOverride ) { if ( ! strcmp ( attr -> values [ 0 ] . string . text , ""none"" ) && ( attr -> num_values == 1 || ! strcmp ( attr -> values [ 1 ] . string . text , ""none"" ) ) ) { ippSetString ( job -> attrs , & attr , 0 , Classification ) ; cupsdLogJob ( job , CUPSD_LOG_NOTICE , ""CLASSIFICATION<S2SV_blank>FORCED<S2SV_blank>"" ""job-sheets=\\""%s,none\\"",<S2SV_blank>"" ""job-originating-user-name=\\""%s\\"""" , Classification , job -> username ) ; } else if ( attr -> num_values == 2 && strcmp ( attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text ) && strcmp ( attr -> values [ 0 ] . string . text , ""none"" ) && strcmp ( attr -> values [ 1 ] . string . text , ""none"" ) ) { ippSetString ( job -> attrs , & attr , 1 , attr -> values [ 0 ] . string . text ) ; cupsdLogJob ( job , CUPSD_LOG_NOTICE , ""CLASSIFICATION<S2SV_blank>FORCED<S2SV_blank>"" ""job-sheets=\\""%s,%s\\"",<S2SV_blank>"" ""job-originating-user-name=\\""%s\\"""" , attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text , job -> username ) ; } else if ( strcmp ( attr -> values [ 0 ] . string . text , Classification ) && strcmp ( attr -> values [ 0 ] . string . text , ""none"" ) && ( attr -> num_values == 1 || ( strcmp ( attr -> values [ 1 ] . string . text , Classification ) && strcmp ( attr -> values [ 1 ] . string . text , ""none"" ) ) ) ) { if ( attr -> num_values == 1 ) cupsdLogJob ( job , CUPSD_LOG_NOTICE , ""CLASSIFICATION<S2SV_blank>OVERRIDDEN<S2SV_blank>"" ""job-sheets=\\""%s\\"",<S2SV_blank>"" ""job-originating-user-name=\\""%s\\"""" , attr -> values [ 0 ] . string . text , job -> username ) ; else cupsdLogJob ( job , CUPSD_LOG_NOTICE , ""CLASSIFICATION<S2SV_blank>OVERRIDDEN<S2SV_blank>"" ""job-sheets=\\""%s,%s\\"",fffff<S2SV_blank>"" ""job-originating-user-name=\\""%s\\"""" , attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text , job -> username ) ; } } else if ( strcmp ( attr -> values [ 0 ] . string . text , Classification ) && ( attr -> num_values == 1 || strcmp ( attr -> values [ 1 ] . string . text , Classification ) ) ) { if ( attr -> num_values > 1 && ! strcmp ( attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text ) ) { ippSetString ( job -> attrs , & attr , 0 , Classification ) ; ippSetString ( job -> attrs , & attr , 1 , Classification ) ; } else { if ( attr -> num_values == 1 || strcmp ( attr -> values [ 0 ] . string . text , ""none"" ) ) ippSetString ( job -> attrs , & attr , 0 , Classification ) ; if ( attr -> num_values > 1 && strcmp ( attr -> values [ 1 ] . string . text , ""none"" ) ) ippSetString ( job -> attrs , & attr , 1 , Classification ) ; } if ( attr -> num_values > 1 ) cupsdLogJob ( job , CUPSD_LOG_NOTICE , ""CLASSIFICATION<S2SV_blank>FORCED<S2SV_blank>"" ""job-sheets=\\""%s,%s\\"",<S2SV_blank>"" ""job-originating-user-name=\\""%s\\"""" , attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text , job -> username ) ; else cupsdLogJob ( job , CUPSD_LOG_NOTICE , ""CLASSIFICATION<S2SV_blank>FORCED<S2SV_blank>"" ""job-sheets=\\""%s\\"",<S2SV_blank>"" ""job-originating-user-name=\\""%s\\"""" , Classification , job -> username ) ; } } if ( ! ( printer -> type & CUPS_PRINTER_REMOTE ) ) { cupsdLogJob ( job , CUPSD_LOG_INFO , ""Adding<S2SV_blank>start<S2SV_blank>banner<S2SV_blank>page<S2SV_blank>\\""%s\\""."" , attr -> values [ 0 ] . string . text ) ; if ( ( kbytes = copy_banner ( con , job , attr -> values [ 0 ] . string . text ) ) < 0 ) { cupsdSetJobState ( job , IPP_JOB_ABORTED , CUPSD_JOB_PURGE , ""Aborting<S2SV_blank>job<S2SV_blank>because<S2SV_blank>the<S2SV_blank>start<S2SV_blank>banner<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>"" ""copied."" ) ; return ( NULL ) ; } cupsdUpdateQuota ( printer , job -> username , 0 , kbytes ) ; } } else if ( ( attr = ippFindAttribute ( job -> attrs , ""job-sheets"" , IPP_TAG_ZERO ) ) != NULL ) job -> job_sheets = attr ; httpAssembleURIf ( HTTP_URI_CODING_ALL , job_uri , sizeof ( job_uri ) , ""ipp"" , NULL , con -> clientname , con -> clientport , ""/jobs/%d"" , job -> id ) ; ippAddString ( con -> response , IPP_TAG_JOB , IPP_TAG_URI , ""job-uri"" , NULL , job_uri ) ; ippAddInteger ( con -> response , IPP_TAG_JOB , IPP_TAG_INTEGER , ""job-id"" , job -> id ) ; ippAddInteger ( con -> response , IPP_TAG_JOB , IPP_TAG_ENUM , ""job-state"" , job -> state_value ) ; ippAddString ( con -> response , IPP_TAG_JOB , IPP_TAG_TEXT , ""job-state-message"" , NULL , """" ) ; ippAddString ( con -> response , IPP_TAG_JOB , IPP_TAG_KEYWORD , ""job-state-reasons"" , NULL , job -> reasons -> values [ 0 ] . string . text ) ; con -> response -> request . status . status_code = IPP_OK ; add_job_subscriptions ( con , job ) ; for ( attr = job -> attrs -> attrs -> next -> next ; attr ; attr = attr -> next ) attr -> group_tag = IPP_TAG_JOB ; cupsdAddEvent ( CUPSD_EVENT_JOB_CREATED , printer , job , ""Job<S2SV_blank>created."" ) ; return ( job ) ; }
","<S2SV_ModStart> ) ; } attr = ippFindAttribute ( con -> request , ""requesting-user-name"" , IPP_TAG_NAME ) ; if ( attr && ! ippValidateAttribute ( attr ) ) { send_ipp_status ( con , IPP_ATTRIBUTES , _ ( ""Bad<S2SV_blank>requesting-user-name<S2SV_blank>value:<S2SV_blank>%s"" ) , cupsLastErrorString ( ) ) ; if ( ( attr = ippCopyAttribute ( con -> response , attr , 0 ) ) != NULL ) attr -> group_tag = IPP_TAG_UNSUPPORTED_GROUP ; return ( NULL ) ; } <S2SV_ModStart> printer , job <S2SV_ModEnd> ) ; if
"
320,"CWE-190 uint8_t hfs_cat_traverse ( HFS_INFO * hfs , TSK_HFS_BTREE_CB a_cb , void * ptr ) { TSK_FS_INFO * fs = & ( hfs -> fs_info ) ; uint32_t cur_node ; char * node ; uint16_t nodesize ; uint8_t is_done = 0 ; tsk_error_reset ( ) ; nodesize = tsk_getu16 ( fs -> endian , hfs -> catalog_header . nodesize ) ; if ( ( node = ( char * ) tsk_malloc ( nodesize ) ) == NULL ) return 1 ; cur_node = tsk_getu32 ( fs -> endian , hfs -> catalog_header . rootNode ) ; if ( cur_node == 0 ) { if ( tsk_verbose ) tsk_fprintf ( stderr , ""hfs_cat_traverse:<S2SV_blank>"" ""empty<S2SV_blank>extents<S2SV_blank>btree\\n"" ) ; free ( node ) ; return 1 ; } if ( tsk_verbose ) tsk_fprintf ( stderr , ""hfs_cat_traverse:<S2SV_blank>starting<S2SV_blank>at<S2SV_blank>"" ""root<S2SV_blank>node<S2SV_blank>%"" PRIu32 "";<S2SV_blank>nodesize<S2SV_blank>=<S2SV_blank>%"" PRIu16 ""\\n"" , cur_node , nodesize ) ; is_done = 0 ; while ( is_done == 0 ) { TSK_OFF_T cur_off ; uint16_t num_rec ; ssize_t cnt ; hfs_btree_node * node_desc ; if ( cur_node > tsk_getu32 ( fs -> endian , hfs -> catalog_header . totalNodes ) ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>Node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>for<S2SV_blank>file"" , cur_node ) ; free ( node ) ; return 1 ; } cur_off = cur_node * nodesize ; cnt = tsk_fs_attr_read ( hfs -> catalog_attr , cur_off , node , nodesize , 0 ) ; if ( cnt != nodesize ) { if ( cnt >= 0 ) { tsk_error_reset ( ) ; tsk_error_set_errno ( TSK_ERR_FS_READ ) ; } tsk_error_set_errstr2 ( ""hfs_cat_traverse:<S2SV_blank>Error<S2SV_blank>reading<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>%"" PRIuOFF , cur_node , cur_off ) ; free ( node ) ; return 1 ; } if ( nodesize < sizeof ( hfs_btree_node ) ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>Node<S2SV_blank>size<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>to<S2SV_blank>be<S2SV_blank>valid"" , nodesize ) ; free ( node ) ; return 1 ; } node_desc = ( hfs_btree_node * ) node ; num_rec = tsk_getu16 ( fs -> endian , node_desc -> num_rec ) ; if ( tsk_verbose ) tsk_fprintf ( stderr , ""hfs_cat_traverse:<S2SV_blank>node<S2SV_blank>%"" PRIu32 ""<S2SV_blank>@<S2SV_blank>%"" PRIu64 ""<S2SV_blank>has<S2SV_blank>%"" PRIu16 ""<S2SV_blank>records\\n"" , cur_node , cur_off , num_rec ) ; if ( num_rec == 0 ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>zero<S2SV_blank>records<S2SV_blank>in<S2SV_blank>node<S2SV_blank>%"" PRIu32 , cur_node ) ; free ( node ) ; return 1 ; } if ( node_desc -> type == HFS_BT_NODE_TYPE_IDX ) { uint32_t next_node = 0 ; int rec ; for ( rec = 0 ; rec < num_rec ; ++ rec ) { size_t rec_off ; hfs_btree_key_cat * key ; uint8_t retval ; <S2SV_StartBug> uint16_t keylen ; <S2SV_EndBug> rec_off = tsk_getu16 ( fs -> endian , & node [ nodesize - ( rec + 1 ) * 2 ] ) ; if ( rec_off > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>record<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>index<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%"" PRIu16 "")"" , rec , cur_node , ( int ) rec_off , nodesize ) ; free ( node ) ; return 1 ; } key = ( hfs_btree_key_cat * ) & node [ rec_off ] ; keylen = 2 + tsk_getu16 ( hfs -> fs_info . endian , key -> key_len ) ; if ( ( keylen ) > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>length<S2SV_blank>of<S2SV_blank>key<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>index<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%"" PRIu16 "")"" , rec , cur_node , keylen , nodesize ) ; free ( node ) ; return 1 ; } retval = a_cb ( hfs , HFS_BT_NODE_TYPE_IDX , key , cur_off + rec_off , ptr ) ; if ( retval == HFS_BTREE_CB_ERR ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr2 ( ""hfs_cat_traverse:<S2SV_blank>Callback<S2SV_blank>returned<S2SV_blank>error"" ) ; free ( node ) ; return 1 ; } else if ( ( retval == HFS_BTREE_CB_IDX_LT ) || ( next_node == 0 ) ) { hfs_btree_index_record * idx_rec ; int keylen = 2 + hfs_get_idxkeylen ( hfs , tsk_getu16 ( fs -> endian , key -> key_len ) , & ( hfs -> catalog_header ) ) ; if ( rec_off + keylen > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>record<S2SV_blank>and<S2SV_blank>keylength<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>index<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%"" PRIu16 "")"" , rec , cur_node , ( int ) rec_off + keylen , nodesize ) ; free ( node ) ; return 1 ; } idx_rec = ( hfs_btree_index_record * ) & node [ rec_off + keylen ] ; next_node = tsk_getu32 ( fs -> endian , idx_rec -> childNode ) ; } if ( retval == HFS_BTREE_CB_IDX_EQGT ) { break ; } } if ( next_node == 0 ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>did<S2SV_blank>not<S2SV_blank>find<S2SV_blank>any<S2SV_blank>keys<S2SV_blank>in<S2SV_blank>index<S2SV_blank>node<S2SV_blank>%d"" , cur_node ) ; is_done = 1 ; break ; } if ( next_node == cur_node ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>references<S2SV_blank>itself<S2SV_blank>as<S2SV_blank>next<S2SV_blank>node"" , cur_node ) ; is_done = 1 ; break ; } cur_node = next_node ; } else if ( node_desc -> type == HFS_BT_NODE_TYPE_LEAF ) { int rec ; for ( rec = 0 ; rec < num_rec ; ++ rec ) { size_t rec_off ; hfs_btree_key_cat * key ; uint8_t retval ; <S2SV_StartBug> uint16_t keylen ; <S2SV_EndBug> rec_off = tsk_getu16 ( fs -> endian , & node [ nodesize - ( rec + 1 ) * 2 ] ) ; if ( rec_off > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>record<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>leaf<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%"" PRIu16 "")"" , rec , cur_node , ( int ) rec_off , nodesize ) ; free ( node ) ; return 1 ; } key = ( hfs_btree_key_cat * ) & node [ rec_off ] ; keylen = 2 + tsk_getu16 ( hfs -> fs_info . endian , key -> key_len ) ; if ( ( keylen ) > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>length<S2SV_blank>of<S2SV_blank>key<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>leaf<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%"" PRIu16 "")"" , rec , cur_node , keylen , nodesize ) ; free ( node ) ; return 1 ; } retval = a_cb ( hfs , HFS_BT_NODE_TYPE_LEAF , key , cur_off + rec_off , ptr ) ; if ( retval == HFS_BTREE_CB_LEAF_STOP ) { is_done = 1 ; break ; } else if ( retval == HFS_BTREE_CB_ERR ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr2 ( ""hfs_cat_traverse:<S2SV_blank>Callback<S2SV_blank>returned<S2SV_blank>error"" ) ; free ( node ) ; return 1 ; } } if ( is_done == 0 ) { cur_node = tsk_getu32 ( fs -> endian , node_desc -> flink ) ; if ( cur_node == 0 ) { is_done = 1 ; } if ( tsk_verbose ) tsk_fprintf ( stderr , ""hfs_cat_traverse:<S2SV_blank>moving<S2SV_blank>forward<S2SV_blank>to<S2SV_blank>next<S2SV_blank>leaf"" ) ; } } else { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>btree<S2SV_blank>node<S2SV_blank>%"" PRIu32 ""<S2SV_blank>(%"" PRIu64 "")<S2SV_blank>is<S2SV_blank>neither<S2SV_blank>index<S2SV_blank>nor<S2SV_blank>leaf<S2SV_blank>(%"" PRIu8 "")"" , cur_node , cur_off , node_desc -> type ) ; free ( node ) ; return 1 ; } } free ( node ) ; return 0 ; }
","<S2SV_ModStart> uint8_t retval ; int <S2SV_ModEnd> keylen ; rec_off <S2SV_ModStart> uint8_t retval ; int <S2SV_ModEnd> keylen ; rec_off
"
321,"CWE-601 int am_check_url ( request_rec * r , const char * url ) { const char * i ; for ( i = url ; * i ; i ++ ) { if ( * i >= 0 && * i < '<S2SV_blank>' ) { AM_LOG_RERROR ( APLOG_MARK , APLOG_ERR , HTTP_BAD_REQUEST , r , ""Control<S2SV_blank>character<S2SV_blank>detected<S2SV_blank>in<S2SV_blank>URL."" ) ; return HTTP_BAD_REQUEST ; } <S2SV_StartBug> } <S2SV_EndBug> return OK ; }
","<S2SV_ModStart> HTTP_BAD_REQUEST ; } if ( * i == '\\\\' ) { AM_LOG_RERROR ( APLOG_MARK , APLOG_ERR , HTTP_BAD_REQUEST , r , ""Backslash<S2SV_blank>character<S2SV_blank>detected<S2SV_blank>in<S2SV_blank>URL."" ) ; return HTTP_BAD_REQUEST ; }
"
322,"CWE-120 int ConnectClientToUnixSock ( const char * sockFile ) { # ifdef WIN32 rfbClientErr ( ""Windows<S2SV_blank>doesn\'t<S2SV_blank>support<S2SV_blank>UNIX<S2SV_blank>sockets\\n"" ) ; return - 1 ; # else int sock ; struct sockaddr_un addr ; <S2SV_StartBug> addr . sun_family = AF_UNIX ; <S2SV_EndBug> strcpy ( addr . sun_path , sockFile ) ; sock = socket ( AF_UNIX , SOCK_STREAM , 0 ) ; if ( sock < 0 ) { rfbClientErr ( ""ConnectToUnixSock:<S2SV_blank>socket<S2SV_blank>(%s)\\n"" , strerror ( errno ) ) ; return - 1 ; } if ( connect ( sock , ( struct sockaddr * ) & addr , sizeof ( addr . sun_family ) + strlen ( addr . sun_path ) ) < 0 ) { rfbClientErr ( ""ConnectToUnixSock:<S2SV_blank>connect\\n"" ) ; close ( sock ) ; return - 1 ; } return sock ; # endif }
","<S2SV_ModStart> = AF_UNIX ; if ( strlen ( sockFile ) + 1 > sizeof ( addr . sun_path ) ) { rfbClientErr ( ""ConnectToUnixSock:<S2SV_blank>socket<S2SV_blank>file<S2SV_blank>name<S2SV_blank>too<S2SV_blank>long\\n"" ) ; return - 1 ; }
"
323,"CWE-119 static void encode_frame_to_data_rate ( VP8_COMP * cpi , unsigned long * size , unsigned char * dest , unsigned char * dest_end , unsigned int * frame_flags ) { int Q ; int frame_over_shoot_limit ; int frame_under_shoot_limit ; int Loop = 0 ; int loop_count ; VP8_COMMON * cm = & cpi -> common ; int active_worst_qchanged = 0 ; # if ! ( CONFIG_REALTIME_ONLY ) int q_low ; int q_high ; int zbin_oq_high ; int zbin_oq_low = 0 ; int top_index ; int bottom_index ; int overshoot_seen = 0 ; int undershoot_seen = 0 ; # endif int drop_mark = ( int ) ( cpi -> oxcf . drop_frames_water_mark * cpi -> oxcf . optimal_buffer_level / 100 ) ; int drop_mark75 = drop_mark * 2 / 3 ; int drop_mark50 = drop_mark / 4 ; int drop_mark25 = drop_mark / 8 ; vp8_clear_system_state ( ) ; # if CONFIG_MULTITHREAD if ( cpi -> b_lpf_running ) { sem_wait ( & cpi -> h_event_end_lpf ) ; cpi -> b_lpf_running = 0 ; } # endif if ( cpi -> force_next_frame_intra ) { cm -> frame_type = KEY_FRAME ; cpi -> force_next_frame_intra = 0 ; } # if ! ( CONFIG_REALTIME_ONLY ) if ( cpi -> pass == 2 ) { if ( cpi -> common . refresh_alt_ref_frame ) { cpi -> per_frame_bandwidth = cpi -> twopass . gf_bits ; cpi -> target_bandwidth = ( int ) ( cpi -> twopass . gf_bits * cpi -> output_framerate ) ; } } else # endif cpi -> per_frame_bandwidth = ( int ) ( cpi -> target_bandwidth / cpi -> output_framerate ) ; cm -> copy_buffer_to_gf = 0 ; cm -> copy_buffer_to_arf = 0 ; cpi -> mb . zbin_over_quant = 0 ; cpi -> mb . zbin_mode_boost = 0 ; cpi -> mb . zbin_mode_boost_enabled = 1 ; if ( cpi -> pass == 2 ) { if ( cpi -> gfu_boost <= 400 ) { cpi -> mb . zbin_mode_boost_enabled = 0 ; } } if ( cpi -> source_alt_ref_active ) cpi -> common . ref_frame_sign_bias [ ALTREF_FRAME ] = 1 ; else cpi -> common . ref_frame_sign_bias [ ALTREF_FRAME ] = 0 ; if ( ( cm -> current_video_frame == 0 ) || ( cm -> frame_flags & FRAMEFLAGS_KEY ) || ( cpi -> oxcf . auto_key && ( cpi -> frames_since_key % cpi -> key_frame_frequency == 0 ) ) ) { cm -> frame_type = KEY_FRAME ; <S2SV_StartBug> } <S2SV_EndBug> # if CONFIG_MULTI_RES_ENCODING <S2SV_StartBug> if ( cpi -> oxcf . mr_encoder_id ) <S2SV_EndBug> { LOWER_RES_FRAME_INFO * low_res_frame_info <S2SV_StartBug> = ( LOWER_RES_FRAME_INFO * ) cpi -> oxcf . mr_low_res_mode_info ; <S2SV_EndBug> cm -> frame_type = low_res_frame_info -> frame_type ; if ( cm -> frame_type != KEY_FRAME ) { cpi -> mr_low_res_mv_avail = 1 ; cpi -> mr_low_res_mv_avail &= ! ( low_res_frame_info -> is_frame_dropped ) ; if ( cpi -> ref_frame_flags & VP8_LAST_FRAME ) cpi -> mr_low_res_mv_avail &= ( cpi -> current_ref_frames [ LAST_FRAME ] == low_res_frame_info -> low_res_ref_frames [ LAST_FRAME ] ) ; if ( cpi -> ref_frame_flags & VP8_GOLD_FRAME ) cpi -> mr_low_res_mv_avail &= ( cpi -> current_ref_frames [ GOLDEN_FRAME ] == low_res_frame_info -> low_res_ref_frames [ GOLDEN_FRAME ] ) ; <S2SV_StartBug> if ( cpi -> ref_frame_flags & VP8_ALTR_FRAME ) <S2SV_EndBug> <S2SV_StartBug> cpi -> mr_low_res_mv_avail &= ( cpi -> current_ref_frames [ ALTREF_FRAME ] <S2SV_EndBug> == low_res_frame_info -> low_res_ref_frames [ ALTREF_FRAME ] ) ; } } # endif if ( cm -> frame_type == KEY_FRAME ) { int i ; setup_features ( cpi ) ; cpi -> source_alt_ref_active = 0 ; for ( i = 0 ; i < MAX_MODES ; i ++ ) { cpi -> mb . rd_thresh_mult [ i ] = 128 ; <S2SV_StartBug> } <S2SV_EndBug> } # if 0 { cpi -> one_pass_frame_index = cm -> current_video_frame % MAX_LAG_BUFFERS ; cpi -> one_pass_frame_stats [ cpi -> one_pass_frame_index ] . frames_so_far = 0 ; cpi -> one_pass_frame_stats [ cpi -> one_pass_frame_index ] . frame_intra_error = 0.0 ; cpi -> one_pass_frame_stats [ cpi -> one_pass_frame_index ] . frame_coded_error = 0.0 ; cpi -> one_pass_frame_stats [ cpi -> one_pass_frame_index ] . frame_pcnt_inter = 0.0 ; cpi -> one_pass_frame_stats [ cpi -> one_pass_frame_index ] . frame_pcnt_motion = 0.0 ; cpi -> one_pass_frame_stats [ cpi -> one_pass_frame_index ] . frame_mvr = 0.0 ; cpi -> one_pass_frame_stats [ cpi -> one_pass_frame_index ] . frame_mvr_abs = 0.0 ; cpi -> one_pass_frame_stats [ cpi -> one_pass_frame_index ] . frame_mvc = 0.0 ; cpi -> one_pass_frame_stats [ cpi -> one_pass_frame_index ] . frame_mvc_abs = 0.0 ; } # endif update_rd_ref_frame_probs ( cpi ) ; if ( cpi -> drop_frames_allowed ) { if ( ( cpi -> buffer_level > drop_mark ) && ( cpi -> decimation_factor > 0 ) ) cpi -> decimation_factor -- ; if ( cpi -> buffer_level > drop_mark75 && cpi -> decimation_factor > 0 ) cpi -> decimation_factor = 1 ; else if ( cpi -> buffer_level < drop_mark25 && ( cpi -> decimation_factor == 2 || cpi -> decimation_factor == 3 ) ) { cpi -> decimation_factor = 3 ; } else if ( cpi -> buffer_level < drop_mark50 && ( cpi -> decimation_factor == 1 || cpi -> decimation_factor == 2 ) ) { cpi -> decimation_factor = 2 ; } else if ( cpi -> buffer_level < drop_mark75 && ( cpi -> decimation_factor == 0 || cpi -> decimation_factor == 1 ) ) { cpi -> decimation_factor = 1 ; } } if ( cpi -> decimation_factor > 0 ) { switch ( cpi -> decimation_factor ) { case 1 : cpi -> per_frame_bandwidth = cpi -> per_frame_bandwidth * 3 / 2 ; break ; case 2 : cpi -> per_frame_bandwidth = cpi -> per_frame_bandwidth * 5 / 4 ; break ; case 3 : cpi -> per_frame_bandwidth = cpi -> per_frame_bandwidth * 5 / 4 ; break ; } if ( cm -> frame_type == KEY_FRAME ) { cpi -> decimation_count = cpi -> decimation_factor ; } else if ( cpi -> decimation_count > 0 ) { cpi -> decimation_count -- ; cpi -> bits_off_target += cpi -> av_per_frame_bandwidth ; if ( cpi -> bits_off_target > cpi -> oxcf . maximum_buffer_size ) cpi -> bits_off_target = cpi -> oxcf . maximum_buffer_size ; # if CONFIG_MULTI_RES_ENCODING vp8_store_drop_frame_info ( cpi ) ; # endif cm -> current_video_frame ++ ; cpi -> frames_since_key ++ ; cpi -> temporal_pattern_counter ++ ; # if CONFIG_INTERNAL_STATS cpi -> count ++ ; # endif cpi -> buffer_level = cpi -> bits_off_target ; if ( cpi -> oxcf . number_of_layers > 1 ) { unsigned int i ; for ( i = cpi -> current_layer + 1 ; i < cpi -> oxcf . number_of_layers ; i ++ ) { LAYER_CONTEXT * lc = & cpi -> layer_context [ i ] ; lc -> bits_off_target += ( int ) ( lc -> target_bandwidth / lc -> framerate ) ; if ( lc -> bits_off_target > lc -> maximum_buffer_size ) lc -> bits_off_target = lc -> maximum_buffer_size ; lc -> buffer_level = lc -> bits_off_target ; } } return ; } else cpi -> decimation_count = cpi -> decimation_factor ; } else cpi -> decimation_count = 0 ; if ( ! vp8_pick_frame_size ( cpi ) ) { # if CONFIG_MULTI_RES_ENCODING vp8_store_drop_frame_info ( cpi ) ; # endif cm -> current_video_frame ++ ; cpi -> frames_since_key ++ ; cpi -> temporal_pattern_counter ++ ; return ; } if ( ( cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) && ( cpi -> buffer_level >= cpi -> oxcf . optimal_buffer_level ) && cpi -> buffered_mode ) { int Adjustment = cpi -> active_worst_quality / 4 ; if ( Adjustment ) { int buff_lvl_step ; if ( cpi -> buffer_level < cpi -> oxcf . maximum_buffer_size ) { buff_lvl_step = ( int ) ( ( cpi -> oxcf . maximum_buffer_size - cpi -> oxcf . optimal_buffer_level ) / Adjustment ) ; if ( buff_lvl_step ) Adjustment = ( int ) ( ( cpi -> buffer_level - cpi -> oxcf . optimal_buffer_level ) / buff_lvl_step ) ; else Adjustment = 0 ; } cpi -> active_worst_quality -= Adjustment ; if ( cpi -> active_worst_quality < cpi -> active_best_quality ) cpi -> active_worst_quality = cpi -> active_best_quality ; } } if ( ( cpi -> pass == 2 ) || ( cpi -> ni_frames > 150 ) ) { vp8_clear_system_state ( ) ; Q = cpi -> active_worst_quality ; if ( cm -> frame_type == KEY_FRAME ) { if ( cpi -> pass == 2 ) { if ( cpi -> gfu_boost > 600 ) cpi -> active_best_quality = kf_low_motion_minq [ Q ] ; else cpi -> active_best_quality = kf_high_motion_minq [ Q ] ; if ( cpi -> this_key_frame_forced ) { if ( cpi -> active_best_quality > cpi -> avg_frame_qindex * 7 / 8 ) cpi -> active_best_quality = cpi -> avg_frame_qindex * 7 / 8 ; else if ( cpi -> active_best_quality < cpi -> avg_frame_qindex >> 2 ) cpi -> active_best_quality = cpi -> avg_frame_qindex >> 2 ; } } else cpi -> active_best_quality = kf_high_motion_minq [ Q ] ; } else if ( cpi -> oxcf . number_of_layers == 1 && ( cm -> refresh_golden_frame || cpi -> common . refresh_alt_ref_frame ) ) { if ( ( cpi -> frames_since_key > 1 ) && ( cpi -> avg_frame_qindex < cpi -> active_worst_quality ) ) { Q = cpi -> avg_frame_qindex ; } if ( ( cpi -> oxcf . end_usage == USAGE_CONSTRAINED_QUALITY ) && ( Q < cpi -> cq_target_quality ) ) { Q = cpi -> cq_target_quality ; } if ( cpi -> pass == 2 ) { if ( cpi -> gfu_boost > 1000 ) cpi -> active_best_quality = gf_low_motion_minq [ Q ] ; else if ( cpi -> gfu_boost < 400 ) cpi -> active_best_quality = gf_high_motion_minq [ Q ] ; else cpi -> active_best_quality = gf_mid_motion_minq [ Q ] ; if ( cpi -> oxcf . end_usage == USAGE_CONSTRAINED_QUALITY ) { cpi -> active_best_quality = cpi -> active_best_quality * 15 / 16 ; } } else cpi -> active_best_quality = gf_high_motion_minq [ Q ] ; } else { cpi -> active_best_quality = inter_minq [ Q ] ; if ( ( cpi -> oxcf . end_usage == USAGE_CONSTRAINED_QUALITY ) && ( cpi -> active_best_quality < cpi -> cq_target_quality ) ) { if ( cpi -> rolling_actual_bits < cpi -> min_frame_bandwidth ) cpi -> active_best_quality = cpi -> oxcf . cq_level ; else cpi -> active_best_quality = cpi -> cq_target_quality ; } } if ( cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) { if ( cpi -> buffer_level >= cpi -> oxcf . maximum_buffer_size ) cpi -> active_best_quality = cpi -> best_quality ; else if ( cpi -> buffer_level > cpi -> oxcf . optimal_buffer_level ) { int Fraction = ( int ) ( ( ( cpi -> buffer_level - cpi -> oxcf . optimal_buffer_level ) * 128 ) / ( cpi -> oxcf . maximum_buffer_size - cpi -> oxcf . optimal_buffer_level ) ) ; int min_qadjustment = ( ( cpi -> active_best_quality - cpi -> best_quality ) * Fraction ) / 128 ; cpi -> active_best_quality -= min_qadjustment ; } } } else if ( cpi -> oxcf . end_usage == USAGE_CONSTRAINED_QUALITY ) { if ( ( cm -> frame_type == KEY_FRAME ) || cm -> refresh_golden_frame || cpi -> common . refresh_alt_ref_frame ) { cpi -> active_best_quality = cpi -> best_quality ; } else if ( cpi -> active_best_quality < cpi -> cq_target_quality ) { cpi -> active_best_quality = cpi -> cq_target_quality ; } } if ( cpi -> active_worst_quality > cpi -> worst_quality ) cpi -> active_worst_quality = cpi -> worst_quality ; if ( cpi -> active_best_quality < cpi -> best_quality ) cpi -> active_best_quality = cpi -> best_quality ; if ( cpi -> active_worst_quality < cpi -> active_best_quality ) cpi -> active_worst_quality = cpi -> active_best_quality ; Q = vp8_regulate_q ( cpi , cpi -> this_frame_target ) ; # if ! ( CONFIG_REALTIME_ONLY ) if ( cm -> frame_type == KEY_FRAME ) zbin_oq_high = 0 ; else if ( ( cpi -> oxcf . number_of_layers == 1 ) && ( ( cm -> refresh_alt_ref_frame || ( cm -> refresh_golden_frame && ! cpi -> source_alt_ref_active ) ) ) ) { zbin_oq_high = 16 ; } else zbin_oq_high = ZBIN_OQ_MAX ; # endif if ( cpi -> cyclic_refresh_mode_enabled ) { <S2SV_StartBug> if ( cpi -> current_layer == 0 ) <S2SV_EndBug> cyclic_background_refresh ( cpi , Q , 0 ) ; else disable_segmentation ( cpi ) ; } vp8_compute_frame_size_bounds ( cpi , & frame_under_shoot_limit , & frame_over_shoot_limit ) ; # if ! ( CONFIG_REALTIME_ONLY ) bottom_index = cpi -> active_best_quality ; top_index = cpi -> active_worst_quality ; q_low = cpi -> active_best_quality ; q_high = cpi -> active_worst_quality ; # endif vp8_save_coding_context ( cpi ) ; loop_count = 0 ; <S2SV_StartBug> scale_and_extend_source ( cpi -> un_scaled_source , cpi ) ; <S2SV_EndBug> # if ! ( CONFIG_REALTIME_ONLY ) && CONFIG_POSTPROC && ! ( CONFIG_TEMPORAL_DENOISING ) if ( cpi -> oxcf . noise_sensitivity > 0 ) { unsigned char * src ; int l = 0 ; switch ( cpi -> oxcf . noise_sensitivity ) { case 1 : l = 20 ; break ; case 2 : l = 40 ; break ; case 3 : l = 60 ; break ; case 4 : l = 80 ; break ; case 5 : l = 100 ; break ; case 6 : l = 150 ; break ; } if ( cm -> frame_type == KEY_FRAME ) { <S2SV_StartBug> vp8_de_noise ( cm , cpi -> Source , cpi -> Source , l , 1 , 0 ) ; <S2SV_EndBug> } else { <S2SV_StartBug> vp8_de_noise ( cm , cpi -> Source , cpi -> Source , l , 1 , 0 ) ; <S2SV_EndBug> src = cpi -> Source -> y_buffer ; if ( cpi -> Source -> y_stride < 0 ) { src += cpi -> Source -> y_stride * ( cpi -> Source -> y_height - 1 ) ; } } } # endif # ifdef OUTPUT_YUV_SRC <S2SV_StartBug> vp8_write_yuv_frame ( cpi -> Source ) ; <S2SV_EndBug> # endif do { vp8_clear_system_state ( ) ; vp8_set_quantizer ( cpi , Q ) ; if ( cpi -> common . mb_no_coeff_skip ) { cpi -> prob_skip_false = cpi -> base_skip_false_prob [ Q ] ; if ( cm -> frame_type != KEY_FRAME ) { if ( cpi -> common . refresh_alt_ref_frame ) { if ( cpi -> last_skip_false_probs [ 2 ] != 0 ) cpi -> prob_skip_false = cpi -> last_skip_false_probs [ 2 ] ; } else if ( cpi -> common . refresh_golden_frame ) { if ( cpi -> last_skip_false_probs [ 1 ] != 0 ) cpi -> prob_skip_false = cpi -> last_skip_false_probs [ 1 ] ; } else { if ( cpi -> last_skip_false_probs [ 0 ] != 0 ) cpi -> prob_skip_false = cpi -> last_skip_false_probs [ 0 ] ; } if ( cpi -> prob_skip_false < 5 ) cpi -> prob_skip_false = 5 ; if ( cpi -> prob_skip_false > 250 ) cpi -> prob_skip_false = 250 ; if ( cpi -> oxcf . number_of_layers == 1 && cpi -> is_src_frame_alt_ref ) cpi -> prob_skip_false = 1 ; } # if 0 if ( cpi -> pass != 1 ) { FILE * f = fopen ( ""skip.stt"" , ""a"" ) ; fprintf ( f , ""%d,<S2SV_blank>%d,<S2SV_blank>%4d<S2SV_blank>"" , cpi -> common . refresh_golden_frame , cpi -> common . refresh_alt_ref_frame , cpi -> prob_skip_false ) ; fclose ( f ) ; } # endif } if ( cm -> frame_type == KEY_FRAME ) { if ( resize_key_frame ( cpi ) ) { Q = vp8_regulate_q ( cpi , cpi -> this_frame_target ) ; if ( cpi -> cyclic_refresh_mode_enabled ) { if ( cpi -> current_layer == 0 ) cyclic_background_refresh ( cpi , Q , 0 ) ; else disable_segmentation ( cpi ) ; } <S2SV_StartBug> vp8_set_quantizer ( cpi , Q ) ; <S2SV_EndBug> } vp8_setup_key_frame ( cpi ) ; } # if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING { if ( cpi -> oxcf . error_resilient_mode ) cm -> refresh_entropy_probs = 0 ; if ( cpi -> oxcf . error_resilient_mode & VPX_ERROR_RESILIENT_PARTITIONS ) { if ( cm -> frame_type == KEY_FRAME ) cm -> refresh_entropy_probs = 1 ; } if ( cm -> refresh_entropy_probs == 0 ) { <S2SV_StartBug> vpx_memcpy ( & cm -> lfc , & cm -> fc , sizeof ( cm -> fc ) ) ; <S2SV_EndBug> } vp8_update_coef_context ( cpi ) ; vp8_update_coef_probs ( cpi ) ; vp8_encode_frame ( cpi ) ; } # else <S2SV_StartBug> vp8_encode_frame ( cpi ) ; <S2SV_EndBug> cpi -> projected_frame_size -= vp8_estimate_entropy_savings ( cpi ) ; cpi -> projected_frame_size = ( cpi -> projected_frame_size > 0 ) ? cpi -> projected_frame_size : 0 ; # endif vp8_clear_system_state ( ) ; if ( cpi -> pass != 2 && cpi -> oxcf . auto_key && cm -> frame_type != KEY_FRAME && cpi -> compressor_speed != 2 ) { # if ! ( CONFIG_REALTIME_ONLY ) if ( decide_key_frame ( cpi ) ) { cm -> frame_type = KEY_FRAME ; vp8_pick_frame_size ( cpi ) ; cpi -> source_alt_ref_active = 0 ; setup_features ( cpi ) ; vp8_restore_coding_context ( cpi ) ; Q = vp8_regulate_q ( cpi , cpi -> this_frame_target ) ; vp8_compute_frame_size_bounds ( cpi , & frame_under_shoot_limit , & frame_over_shoot_limit ) ; bottom_index = cpi -> active_best_quality ; top_index = cpi -> active_worst_quality ; q_low = cpi -> active_best_quality ; q_high = cpi -> active_worst_quality ; loop_count ++ ; Loop = 1 ; continue ; } # endif } vp8_clear_system_state ( ) ; if ( frame_over_shoot_limit == 0 ) frame_over_shoot_limit = 1 ; if ( ( ( cpi -> pass != 2 ) || ( cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) ) && ( Q == cpi -> active_worst_quality ) && ( cpi -> active_worst_quality < cpi -> worst_quality ) && ( cpi -> projected_frame_size > frame_over_shoot_limit ) ) { int over_size_percent = ( ( cpi -> projected_frame_size - frame_over_shoot_limit ) * 100 ) / frame_over_shoot_limit ; while ( ( cpi -> active_worst_quality < cpi -> worst_quality ) && ( over_size_percent > 0 ) ) { cpi -> active_worst_quality ++ ; over_size_percent = ( int ) ( over_size_percent * 0.96 ) ; } # if ! ( CONFIG_REALTIME_ONLY ) top_index = cpi -> active_worst_quality ; # endif active_worst_qchanged = 1 ; } else active_worst_qchanged = 0 ; # if ! ( CONFIG_REALTIME_ONLY ) if ( ( cm -> frame_type == KEY_FRAME ) && cpi -> this_key_frame_forced ) { int last_q = Q ; int kf_err = vp8_calc_ss_err ( cpi -> Source , & cm -> yv12_fb [ cm -> new_fb_idx ] ) ; if ( kf_err > ( ( cpi -> ambient_err * 7 ) >> 3 ) ) { q_high = ( Q > q_low ) ? ( Q - 1 ) : q_low ; Q = ( q_high + q_low ) >> 1 ; } else if ( kf_err < ( cpi -> ambient_err >> 1 ) ) { q_low = ( Q < q_high ) ? ( Q + 1 ) : q_high ; Q = ( q_high + q_low + 1 ) >> 1 ; } if ( Q > q_high ) Q = q_high ; else if ( Q < q_low ) Q = q_low ; Loop = Q != last_q ; } else if ( recode_loop_test ( cpi , frame_over_shoot_limit , frame_under_shoot_limit , Q , top_index , bottom_index ) ) { int last_q = Q ; int Retries = 0 ; if ( cpi -> projected_frame_size > cpi -> this_frame_target ) { q_low = ( Q < q_high ) ? ( Q + 1 ) : q_high ; if ( cpi -> mb . zbin_over_quant > 0 ) zbin_oq_low = ( cpi -> mb . zbin_over_quant < zbin_oq_high ) ? ( cpi -> mb . zbin_over_quant + 1 ) : zbin_oq_high ; if ( undershoot_seen ) { if ( ! active_worst_qchanged ) vp8_update_rate_correction_factors ( cpi , 1 ) ; Q = ( q_high + q_low + 1 ) / 2 ; if ( Q < MAXQ ) cpi -> mb . zbin_over_quant = 0 ; else { zbin_oq_low = ( cpi -> mb . zbin_over_quant < zbin_oq_high ) ? ( cpi -> mb . zbin_over_quant + 1 ) : zbin_oq_high ; cpi -> mb . zbin_over_quant = ( zbin_oq_high + zbin_oq_low ) / 2 ; } } else { if ( ! active_worst_qchanged ) vp8_update_rate_correction_factors ( cpi , 0 ) ; Q = vp8_regulate_q ( cpi , cpi -> this_frame_target ) ; while ( ( ( Q < q_low ) || ( cpi -> mb . zbin_over_quant < zbin_oq_low ) ) && ( Retries < 10 ) ) { vp8_update_rate_correction_factors ( cpi , 0 ) ; Q = vp8_regulate_q ( cpi , cpi -> this_frame_target ) ; Retries ++ ; } } overshoot_seen = 1 ; } else { if ( cpi -> mb . zbin_over_quant == 0 ) q_high = ( Q > q_low ) ? ( Q - 1 ) : q_low ; else zbin_oq_high = ( cpi -> mb . zbin_over_quant > zbin_oq_low ) ? ( cpi -> mb . zbin_over_quant - 1 ) : zbin_oq_low ; if ( overshoot_seen ) { if ( ! active_worst_qchanged ) vp8_update_rate_correction_factors ( cpi , 1 ) ; Q = ( q_high + q_low ) / 2 ; if ( Q < MAXQ ) cpi -> mb . zbin_over_quant = 0 ; else cpi -> mb . zbin_over_quant = ( zbin_oq_high + zbin_oq_low ) / 2 ; } else { if ( ! active_worst_qchanged ) vp8_update_rate_correction_factors ( cpi , 0 ) ; Q = vp8_regulate_q ( cpi , cpi -> this_frame_target ) ; if ( ( cpi -> oxcf . end_usage == USAGE_CONSTRAINED_QUALITY ) && ( Q < q_low ) ) { q_low = Q ; } while ( ( ( Q > q_high ) || ( cpi -> mb . zbin_over_quant > zbin_oq_high ) ) && ( Retries < 10 ) ) { vp8_update_rate_correction_factors ( cpi , 0 ) ; Q = vp8_regulate_q ( cpi , cpi -> this_frame_target ) ; Retries ++ ; } } undershoot_seen = 1 ; } if ( Q > q_high ) Q = q_high ; else if ( Q < q_low ) Q = q_low ; cpi -> mb . zbin_over_quant = ( cpi -> mb . zbin_over_quant < zbin_oq_low ) ? zbin_oq_low : ( cpi -> mb . zbin_over_quant > zbin_oq_high ) ? zbin_oq_high : cpi -> mb . zbin_over_quant ; Loop = Q != last_q ; } else # endif Loop = 0 ; if ( cpi -> is_src_frame_alt_ref ) Loop = 0 ; if ( Loop == 1 ) { vp8_restore_coding_context ( cpi ) ; loop_count ++ ; # if CONFIG_INTERNAL_STATS cpi -> tot_recode_hits ++ ; # endif } } while ( Loop == 1 ) ; # if 0 { cpi -> one_pass_frame_stats [ cpi -> one_pass_frame_index ] . frame_coded_error = ( double ) cpi -> prediction_error ; cpi -> one_pass_frame_stats [ cpi -> one_pass_frame_index ] . frame_intra_error = ( double ) cpi -> intra_error ; cpi -> one_pass_frame_stats [ cpi -> one_pass_frame_index ] . frame_pcnt_inter = ( double ) ( 100 - cpi -> this_frame_percent_intra ) / 100.0 ; } # endif if ( cpi -> next_key_frame_forced && ( cpi -> twopass . frames_to_key == 0 ) ) { cpi -> ambient_err = vp8_calc_ss_err ( cpi -> Source , & cm -> yv12_fb [ cm -> new_fb_idx ] ) ; } # if CONFIG_MULTI_RES_ENCODING if ( ! cpi -> oxcf . mr_encoder_id && cm -> show_frame ) # else if ( cm -> show_frame ) # endif { int mb_row ; int mb_col ; MODE_INFO * tmp = cm -> mip ; if ( cm -> frame_type != KEY_FRAME ) { for ( mb_row = 0 ; mb_row < cm -> mb_rows + 1 ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cm -> mb_cols + 1 ; mb_col ++ ) { if ( tmp -> mbmi . ref_frame != INTRA_FRAME ) cpi -> lfmv [ mb_col + mb_row * ( cm -> mode_info_stride + 1 ) ] . as_int = tmp -> mbmi . mv . as_int ; cpi -> lf_ref_frame_sign_bias [ mb_col + mb_row * ( cm -> mode_info_stride + 1 ) ] = cm -> ref_frame_sign_bias [ tmp -> mbmi . ref_frame ] ; cpi -> lf_ref_frame [ mb_col + mb_row * ( cm -> mode_info_stride + 1 ) ] = tmp -> mbmi . ref_frame ; tmp ++ ; } } } } { int mb_row ; int mb_col ; MODE_INFO * tmp = cm -> mi ; cpi -> zeromv_count = 0 ; if ( cm -> frame_type != KEY_FRAME ) { for ( mb_row = 0 ; mb_row < cm -> mb_rows ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cm -> mb_cols ; mb_col ++ ) { <S2SV_StartBug> if ( tmp -> mbmi . mode == ZEROMV ) <S2SV_EndBug> cpi -> zeromv_count ++ ; tmp ++ ; } tmp ++ ; } } } # if CONFIG_MULTI_RES_ENCODING vp8_cal_dissimilarity ( cpi ) ; # endif if ( cpi -> oxcf . number_of_layers == 1 ) vp8_update_gf_useage_maps ( cpi , cm , & cpi -> mb ) ; if ( cm -> frame_type == KEY_FRAME ) cm -> refresh_last_frame = 1 ; # if 0 { FILE * f = fopen ( ""gfactive.stt"" , ""a"" ) ; fprintf ( f , ""%8d<S2SV_blank>%8d<S2SV_blank>%8d<S2SV_blank>%8d<S2SV_blank>%8d\\n"" , cm -> current_video_frame , ( 100 * cpi -> gf_active_count ) / ( cpi -> common . mb_rows * cpi -> common . mb_cols ) , cpi -> this_iiratio , cpi -> next_iiratio , cm -> refresh_golden_frame ) ; fclose ( f ) ; } # endif if ( ! cpi -> oxcf . error_resilient_mode && cm -> refresh_golden_frame ) cm -> copy_buffer_to_arf = 2 ; else cm -> copy_buffer_to_arf = 0 ; cm -> frame_to_show = & cm -> yv12_fb [ cm -> new_fb_idx ] ; <S2SV_StartBug> # if CONFIG_MULTITHREAD <S2SV_EndBug> if ( cpi -> b_multi_threaded ) { <S2SV_StartBug> sem_post ( & cpi -> h_event_start_lpf ) ; <S2SV_EndBug> cpi -> b_lpf_running = 1 ; } else # endif { vp8_loopfilter_frame ( cpi , cm ) ; } <S2SV_StartBug> update_reference_frames ( cpi ) ; <S2SV_EndBug> # if ! ( CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING ) if ( cpi -> oxcf . error_resilient_mode ) { cm -> refresh_entropy_probs = 0 ; } # endif # if CONFIG_MULTITHREAD if ( cpi -> b_multi_threaded ) sem_wait ( & cpi -> h_event_end_lpf ) ; # endif vp8_pack_bitstream ( cpi , dest , dest_end , size ) ; # if CONFIG_MULTITHREAD if ( cpi -> b_lpf_running && cpi -> b_calculate_psnr ) { sem_wait ( & cpi -> h_event_end_lpf ) ; cpi -> b_lpf_running = 0 ; } # endif cm -> last_frame_type = cm -> frame_type ; cpi -> total_byte_count += ( * size ) ; cpi -> projected_frame_size = ( * size ) << 3 ; if ( cpi -> oxcf . number_of_layers > 1 ) { unsigned int i ; for ( i = cpi -> current_layer + 1 ; i < cpi -> oxcf . number_of_layers ; i ++ ) cpi -> layer_context [ i ] . total_byte_count += ( * size ) ; } if ( ! active_worst_qchanged ) vp8_update_rate_correction_factors ( cpi , 2 ) ; cpi -> last_q [ cm -> frame_type ] = cm -> base_qindex ; if ( cm -> frame_type == KEY_FRAME ) { vp8_adjust_key_frame_context ( cpi ) ; } if ( cm -> frame_type != KEY_FRAME ) cpi -> avg_frame_qindex = ( 2 + 3 * cpi -> avg_frame_qindex + cm -> base_qindex ) >> 2 ; if ( ( cm -> frame_type != KEY_FRAME ) && ( ( cpi -> oxcf . number_of_layers > 1 ) || ( ! cm -> refresh_golden_frame && ! cm -> refresh_alt_ref_frame ) ) ) { cpi -> ni_frames ++ ; if ( cpi -> pass == 2 ) { cpi -> ni_tot_qi += Q ; cpi -> ni_av_qi = ( cpi -> ni_tot_qi / cpi -> ni_frames ) ; } else { if ( cpi -> ni_frames > 150 ) { cpi -> ni_tot_qi += Q ; cpi -> ni_av_qi = ( cpi -> ni_tot_qi / cpi -> ni_frames ) ; } else { cpi -> ni_tot_qi += Q ; cpi -> ni_av_qi = ( ( cpi -> ni_tot_qi / cpi -> ni_frames ) + cpi -> worst_quality + 1 ) / 2 ; } if ( Q > cpi -> ni_av_qi ) cpi -> ni_av_qi = Q - 1 ; } } if ( ! cm -> show_frame ) cpi -> bits_off_target -= cpi -> projected_frame_size ; else cpi -> bits_off_target += cpi -> av_per_frame_bandwidth - cpi -> projected_frame_size ; if ( cpi -> bits_off_target > cpi -> oxcf . maximum_buffer_size ) <S2SV_StartBug> cpi -> bits_off_target = cpi -> oxcf . maximum_buffer_size ; <S2SV_EndBug> cpi -> rolling_target_bits = ( ( cpi -> rolling_target_bits * 3 ) + cpi -> this_frame_target + 2 ) / 4 ; cpi -> rolling_actual_bits = ( ( cpi -> rolling_actual_bits * 3 ) + cpi -> projected_frame_size + 2 ) / 4 ; cpi -> long_rolling_target_bits = ( ( cpi -> long_rolling_target_bits * 31 ) + cpi -> this_frame_target + 16 ) / 32 ; cpi -> long_rolling_actual_bits = ( ( cpi -> long_rolling_actual_bits * 31 ) + cpi -> projected_frame_size + 16 ) / 32 ; cpi -> total_actual_bits += cpi -> projected_frame_size ; cpi -> total_target_vs_actual += ( cpi -> this_frame_target - cpi -> projected_frame_size ) ; cpi -> buffer_level = cpi -> bits_off_target ; if ( cpi -> oxcf . number_of_layers > 1 ) { unsigned int i ; for ( i = cpi -> current_layer + 1 ; i < cpi -> oxcf . number_of_layers ; i ++ ) { LAYER_CONTEXT * lc = & cpi -> layer_context [ i ] ; int bits_off_for_this_layer = ( int ) ( lc -> target_bandwidth / lc -> framerate - cpi -> projected_frame_size ) ; lc -> bits_off_target += bits_off_for_this_layer ; if ( lc -> bits_off_target > lc -> maximum_buffer_size ) lc -> bits_off_target = lc -> maximum_buffer_size ; lc -> total_actual_bits += cpi -> projected_frame_size ; lc -> total_target_vs_actual += bits_off_for_this_layer ; lc -> buffer_level = lc -> bits_off_target ; } } if ( cm -> frame_type == KEY_FRAME ) { cpi -> twopass . kf_group_bits += cpi -> this_frame_target - cpi -> projected_frame_size ; if ( cpi -> twopass . kf_group_bits < 0 ) cpi -> twopass . kf_group_bits = 0 ; } else if ( cm -> refresh_golden_frame || cm -> refresh_alt_ref_frame ) { cpi -> twopass . gf_group_bits += cpi -> this_frame_target - cpi -> projected_frame_size ; if ( cpi -> twopass . gf_group_bits < 0 ) cpi -> twopass . gf_group_bits = 0 ; } if ( cm -> frame_type != KEY_FRAME ) { if ( cpi -> common . refresh_alt_ref_frame ) { cpi -> last_skip_false_probs [ 2 ] = cpi -> prob_skip_false ; cpi -> last_skip_probs_q [ 2 ] = cm -> base_qindex ; } else if ( cpi -> common . refresh_golden_frame ) { cpi -> last_skip_false_probs [ 1 ] = cpi -> prob_skip_false ; cpi -> last_skip_probs_q [ 1 ] = cm -> base_qindex ; } else { cpi -> last_skip_false_probs [ 0 ] = cpi -> prob_skip_false ; cpi -> last_skip_probs_q [ 0 ] = cm -> base_qindex ; cpi -> base_skip_false_prob [ cm -> base_qindex ] = cpi -> prob_skip_false ; } } # if 0 && CONFIG_INTERNAL_STATS { FILE * f = fopen ( ""tmp.stt"" , ""a"" ) ; vp8_clear_system_state ( ) ; if ( cpi -> twopass . total_left_stats . coded_error != 0.0 ) fprintf ( f , ""%10d<S2SV_blank>%10d<S2SV_blank>%10d<S2SV_blank>%10d<S2SV_blank>%10d<S2SV_blank>%10"" PRId64 ""<S2SV_blank>%10"" PRId64 ""%10"" PRId64 ""<S2SV_blank>%10d<S2SV_blank>%6d<S2SV_blank>%6d<S2SV_blank>%6d<S2SV_blank>%6d<S2SV_blank>%5d<S2SV_blank>%5d<S2SV_blank>%5d<S2SV_blank>%8d<S2SV_blank>"" ""%8.2lf<S2SV_blank>%"" PRId64 ""<S2SV_blank>%10.3lf<S2SV_blank>%10"" PRId64 ""<S2SV_blank>%8d\\n"" , cpi -> common . current_video_frame , cpi -> this_frame_target , cpi -> projected_frame_size , ( cpi -> projected_frame_size - cpi -> this_frame_target ) , cpi -> total_target_vs_actual , cpi -> buffer_level , ( cpi -> oxcf . starting_buffer_level - cpi -> bits_off_target ) , cpi -> total_actual_bits , cm -> base_qindex , cpi -> active_best_quality , cpi -> active_worst_quality , cpi -> ni_av_qi , cpi -> cq_target_quality , cm -> refresh_golden_frame , cm -> refresh_alt_ref_frame , cm -> frame_type , cpi -> gfu_boost , cpi -> twopass . est_max_qcorrection_factor , cpi -> twopass . bits_left , cpi -> twopass . total_left_stats . coded_error , ( double ) cpi -> twopass . bits_left / cpi -> twopass . total_left_stats . coded_error , cpi -> tot_recode_hits ) ; else fprintf ( f , ""%10d<S2SV_blank>%10d<S2SV_blank>%10d<S2SV_blank>%10d<S2SV_blank>%10d<S2SV_blank>%10"" PRId64 ""<S2SV_blank>%10"" PRId64 ""%10"" PRId64 ""<S2SV_blank>%10d<S2SV_blank>%6d<S2SV_blank>%6d<S2SV_blank>%6d<S2SV_blank>%6d<S2SV_blank>%5d<S2SV_blank>%5d<S2SV_blank>%5d<S2SV_blank>%8d<S2SV_blank>"" ""%8.2lf<S2SV_blank>%"" PRId64 ""<S2SV_blank>%10.3lf<S2SV_blank>%8d\\n"" , cpi -> common . current_video_frame , cpi -> this_frame_target , cpi -> projected_frame_size , ( cpi -> projected_frame_size - cpi -> this_frame_target ) , cpi -> total_target_vs_actual , cpi -> buffer_level , ( cpi -> oxcf . starting_buffer_level - cpi -> bits_off_target ) , cpi -> total_actual_bits , cm -> base_qindex , cpi -> active_best_quality , cpi -> active_worst_quality , cpi -> ni_av_qi , cpi -> cq_target_quality , cm -> refresh_golden_frame , cm -> refresh_alt_ref_frame , cm -> frame_type , cpi -> gfu_boost , cpi -> twopass . est_max_qcorrection_factor , cpi -> twopass . bits_left , cpi -> twopass . total_left_stats . coded_error , cpi -> tot_recode_hits ) ; fclose ( f ) ; { FILE * fmodes = fopen ( ""Modes.stt"" , ""a"" ) ; fprintf ( fmodes , ""%6d:%1d:%1d:%1d<S2SV_blank>"" , cpi -> common . current_video_frame , cm -> frame_type , cm -> refresh_golden_frame , cm -> refresh_alt_ref_frame ) ; fprintf ( fmodes , ""\\n"" ) ; fclose ( fmodes ) ; } } # endif if ( cm -> refresh_golden_frame == 1 ) cm -> frame_flags = cm -> frame_flags | FRAMEFLAGS_GOLDEN ; else cm -> frame_flags = cm -> frame_flags & ~ FRAMEFLAGS_GOLDEN ; if ( cm -> refresh_alt_ref_frame == 1 ) cm -> frame_flags = cm -> frame_flags | FRAMEFLAGS_ALTREF ; else cm -> frame_flags = cm -> frame_flags & ~ FRAMEFLAGS_ALTREF ; if ( cm -> refresh_last_frame & cm -> refresh_golden_frame ) cpi -> gold_is_last = 1 ; else if ( cm -> refresh_last_frame ^ cm -> refresh_golden_frame ) cpi -> gold_is_last = 0 ; if ( cm -> refresh_last_frame & cm -> refresh_alt_ref_frame ) cpi -> alt_is_last = 1 ; else if ( cm -> refresh_last_frame ^ cm -> refresh_alt_ref_frame ) cpi -> alt_is_last = 0 ; if ( cm -> refresh_alt_ref_frame & cm -> refresh_golden_frame ) cpi -> gold_is_alt = 1 ; else if ( cm -> refresh_alt_ref_frame ^ cm -> refresh_golden_frame ) cpi -> gold_is_alt = 0 ; cpi -> ref_frame_flags = VP8_ALTR_FRAME | VP8_GOLD_FRAME | VP8_LAST_FRAME ; if ( cpi -> gold_is_last ) cpi -> ref_frame_flags &= ~ VP8_GOLD_FRAME ; if ( cpi -> alt_is_last ) cpi -> ref_frame_flags &= ~ VP8_ALTR_FRAME ; if ( cpi -> gold_is_alt ) cpi -> ref_frame_flags &= ~ VP8_ALTR_FRAME ; if ( ! cpi -> oxcf . error_resilient_mode ) { if ( cpi -> oxcf . play_alternate && cm -> refresh_alt_ref_frame && ( cm -> frame_type != KEY_FRAME ) ) update_alt_ref_frame_stats ( cpi ) ; else update_golden_frame_stats ( cpi ) ; } if ( cm -> frame_type == KEY_FRAME ) { * frame_flags = cm -> frame_flags | FRAMEFLAGS_KEY ; cm -> frame_type = INTER_FRAME ; cpi -> last_frame_percent_intra = 100 ; } else { * frame_flags = cm -> frame_flags & ~ FRAMEFLAGS_KEY ; cpi -> last_frame_percent_intra = cpi -> this_frame_percent_intra ; } cpi -> mb . e_mbd . update_mb_segmentation_map = 0 ; cpi -> mb . e_mbd . update_mb_segmentation_data = 0 ; cpi -> mb . e_mbd . mode_ref_lf_delta_update = 0 ; if ( cm -> show_frame ) { cm -> current_video_frame ++ ; cpi -> frames_since_key ++ ; cpi -> temporal_pattern_counter ++ ; } # if 0 { char filename [ 512 ] ; FILE * recon_file ; sprintf ( filename , ""enc%04d.yuv"" , ( int ) cm -> current_video_frame ) ; recon_file = fopen ( filename , ""wb"" ) ; fwrite ( cm -> yv12_fb [ cm -> lst_fb_idx ] . buffer_alloc , cm -> yv12_fb [ cm -> lst_fb_idx ] . frame_size , 1 , recon_file ) ; fclose ( recon_file ) ; } # endif }
","<S2SV_ModStart> = KEY_FRAME ; # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity == 4 ) { vp8_denoiser_set_parameters ( & cpi -> denoiser , kDenoiserOnYUV ) ; } # endif } # if <S2SV_ModEnd> CONFIG_MULTI_RES_ENCODING if ( <S2SV_ModStart> -> oxcf . mr_total_resolutions > 1 ) <S2SV_ModEnd> { LOWER_RES_FRAME_INFO * <S2SV_ModStart> . mr_low_res_mode_info ; if ( cpi -> oxcf . mr_encoder_id ) { <S2SV_ModStart> ] ) ; } } if ( cm -> frame_type == KEY_FRAME ) { if ( cpi -> oxcf . mr_encoder_id ) { if ( cpi -> common . current_video_frame == 0 && cpi -> buffer_level == 0 ) { unsigned int i ; cpi -> bits_off_target = cpi -> oxcf . starting_buffer_level ; cpi -> buffer_level = cpi -> oxcf . starting_buffer_level ; for ( i = 0 ; i < cpi -> oxcf . number_of_layers ; i ++ ) { LAYER_CONTEXT * lc = & cpi -> layer_context [ i ] ; lc -> bits_off_target = lc -> starting_buffer_level ; lc -> buffer_level = lc -> starting_buffer_level ; } } cpi -> common . current_video_frame = low_res_frame_info -> key_frame_counter_value ; } else { low_res_frame_info -> key_frame_counter_value = cpi -> common . current_video_frame ; } } } # endif cpi -> closest_reference_frame = LAST_FRAME ; if ( cm -> frame_type != KEY_FRAME ) { int i ; MV_REFERENCE_FRAME closest_ref = INTRA_FRAME ; if ( cpi -> ref_frame_flags & VP8_LAST_FRAME ) { closest_ref = LAST_FRAME ; } else if ( cpi -> ref_frame_flags & VP8_GOLD_FRAME ) { closest_ref = GOLDEN_FRAME ; } else <S2SV_ModStart> & VP8_ALTR_FRAME ) { closest_ref = ALTREF_FRAME ; } for ( i = 1 ; i <= 3 ; i ++ ) { vpx_ref_frame_type_t ref_frame_type = ( vpx_ref_frame_type_t ) ( ( i == 3 ) ? 4 : i ) ; if ( cpi -> ref_frame_flags & ref_frame_type ) { if ( ( cm -> current_video_frame - <S2SV_ModEnd> cpi -> current_ref_frames <S2SV_ModStart> -> current_ref_frames [ i ] ) < ( cm -> current_video_frame - cpi -> current_ref_frames [ closest_ref ] ) ) { closest_ref = i ; } } } cpi -> closest_reference_frame = closest_ref ; } <S2SV_ModEnd> if ( cm <S2SV_ModStart> 128 ; } memset ( cpi -> consec_zero_last , 0 , cm -> mb_rows * cm -> mb_cols ) ; memset ( cpi -> consec_zero_last_mvbias , 0 , ( cpi -> common . mb_rows * cpi -> common . mb_cols ) ) ; <S2SV_ModStart> cyclic_refresh_mode_enabled ) { int disable_cr_gf = ( cpi -> oxcf . screen_content_mode == 2 && cm -> refresh_golden_frame ) ; <S2SV_ModStart> current_layer == 0 && cpi -> force_maxqp == 0 && ! disable_cr_gf <S2SV_ModStart> cpi ) ; # if CONFIG_TEMPORAL_DENOISING && CONFIG_POSTPROC if ( cpi -> oxcf . noise_sensitivity >= 3 ) { if ( cpi -> denoiser . denoise_pars . spatial_blur != 0 ) { vp8_de_noise ( cm , cpi -> Source , cpi -> Source , cpi -> denoiser . denoise_pars . spatial_blur , 1 , 0 , 0 ) ; } } # endif <S2SV_ModStart> 1 , 0 , 1 <S2SV_ModStart> 1 , 0 , 1 <S2SV_ModStart> OUTPUT_YUV_SRC vp8_write_yuv_frame ( yuv_file , <S2SV_ModStart> ) ; } memset ( cpi -> consec_zero_last , 0 , cm -> mb_rows * cm -> mb_cols ) ; memset ( cpi -> consec_zero_last_mvbias , 0 , ( cpi -> common . mb_rows * cpi -> common . mb_cols ) ) ; <S2SV_ModStart> 0 ) { memcpy <S2SV_ModEnd> ( & cm <S2SV_ModStart> cpi ) ; if ( cpi -> oxcf . screen_content_mode == 2 ) { if ( vp8_drop_encodedframe_overshoot ( cpi , Q ) ) return ; } <S2SV_ModStart> mode == ZEROMV && tmp -> mbmi . ref_frame == LAST_FRAME <S2SV_ModStart> ; # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity > 0 && cpi -> oxcf . noise_sensitivity < 4 && ! cpi -> oxcf . screen_content_mode && cpi -> frames_since_key % 8 == 0 && cm -> frame_type != KEY_FRAME ) { cpi -> mse_source_denoised = measure_square_diff_partial ( <S2SV_ModEnd> & cpi -> <S2SV_ModStart> & cpi -> denoiser . yv12_running_avg [ INTRA_FRAME ] , cpi -> Source , cpi ) ; } if ( cpi -> oxcf . noise_sensitivity == 4 && ! cpi -> oxcf . screen_content_mode && cpi -> frames_since_key % 8 == 0 && cm -> frame_type != KEY_FRAME ) { process_denoiser_mode_change ( cpi ) ; } # endif # if CONFIG_MULTITHREAD if ( cpi -> b_multi_threaded ) { sem_post ( & cpi -> h_event_start_lpf ) ; cpi -> b_lpf_running = 1 ; } else # endif <S2SV_ModEnd> { vp8_loopfilter_frame ( <S2SV_ModStart> cpi ) ; # ifdef OUTPUT_YUV_DENOISED vp8_write_yuv_frame ( yuv_denoised_file , & cpi -> denoiser . yv12_running_avg [ INTRA_FRAME ] ) ; # endif <S2SV_ModStart> -> bits_off_target = cpi -> oxcf . maximum_buffer_size ; if ( cpi -> drop_frames_allowed == 0 && cpi -> oxcf . screen_content_mode && cpi -> bits_off_target < - cpi -> oxcf . maximum_buffer_size ) cpi -> bits_off_target = -
"
324,"CWE-119 <S2SV_StartBug> void impeg2d_dec_pnb_mb_params ( dec_state_t * ps_dec ) <S2SV_EndBug> { stream_t * ps_stream = & ps_dec -> s_bit_stream ; UWORD16 u2_mb_addr_incr ; UWORD16 u2_total_len ; UWORD16 u2_len ; UWORD16 u2_mb_type ; UWORD32 u4_next_word ; const dec_mb_params_t * ps_dec_mb_params ; if ( impeg2d_bit_stream_nxt ( ps_stream , 1 ) == 1 ) { impeg2d_bit_stream_flush ( ps_stream , 1 ) ; } else { u2_mb_addr_incr = impeg2d_get_mb_addr_incr ( ps_stream ) ; if ( ps_dec -> u2_first_mb ) { ps_dec -> u2_mb_x = u2_mb_addr_incr - 1 ; ps_dec -> u2_mb_x = MIN ( ps_dec -> u2_mb_x , ( ps_dec -> u2_num_horiz_mb - 1 ) ) ; u2_mb_addr_incr = 1 ; ps_dec -> u2_first_mb = 0 ; } else { if ( ps_dec -> u2_is_mpeg2 && ( ( ps_dec -> u2_mb_x + u2_mb_addr_incr ) > ps_dec -> u2_num_horiz_mb ) ) { u2_mb_addr_incr = ps_dec -> u2_num_horiz_mb - ps_dec -> u2_mb_x ; } impeg2d_dec_skip_mbs ( ps_dec , ( UWORD16 ) ( u2_mb_addr_incr - 1 ) ) ; } } u4_next_word = ( UWORD16 ) impeg2d_bit_stream_nxt ( ps_stream , 16 ) ; { u2_mb_type = ps_dec -> pu2_mb_type [ BITS ( ( UWORD16 ) u4_next_word , 15 , 10 ) ] ; u2_len = BITS ( u2_mb_type , 15 , 8 ) ; u2_total_len = u2_len ; u4_next_word = ( UWORD16 ) LSW ( ( UWORD16 ) u4_next_word << u2_len ) ; } { WORD32 i4_motion_type = ps_dec -> u2_motion_type ; if ( ( u2_mb_type & MB_FORW_OR_BACK ) && ps_dec -> u2_read_motion_type ) { ps_dec -> u2_motion_type = BITS ( ( UWORD16 ) u4_next_word , 15 , 14 ) ; u2_total_len += MB_MOTION_TYPE_LEN ; u4_next_word = ( UWORD16 ) LSW ( ( UWORD16 ) u4_next_word << MB_MOTION_TYPE_LEN ) ; i4_motion_type = ps_dec -> u2_motion_type ; } if ( ( u2_mb_type & MB_FORW_OR_BACK ) && ( ( i4_motion_type == 0 ) || ( i4_motion_type == 3 ) || ( i4_motion_type == 4 ) || ( i4_motion_type >= 7 ) ) ) { i4_motion_type = 1 ; } } { if ( ( u2_mb_type & MB_CODED ) && ps_dec -> u2_read_dct_type ) { ps_dec -> u2_field_dct = BIT ( ( UWORD16 ) u4_next_word , 15 ) ; u2_total_len += MB_DCT_TYPE_LEN ; u4_next_word = ( UWORD16 ) LSW ( ( UWORD16 ) u4_next_word << MB_DCT_TYPE_LEN ) ; } } if ( u2_mb_type & MB_QUANT ) { UWORD16 u2_quant_scale_code ; u2_quant_scale_code = BITS ( ( UWORD16 ) u4_next_word , 15 , 11 ) ; ps_dec -> u1_quant_scale = ( ps_dec -> u2_q_scale_type ) ? gau1_impeg2_non_linear_quant_scale [ u2_quant_scale_code ] : ( u2_quant_scale_code << 1 ) ; u2_total_len += MB_QUANT_SCALE_CODE_LEN ; } impeg2d_bit_stream_flush ( ps_stream , u2_total_len ) ; ps_dec -> u2_coded_mb = ( UWORD16 ) ( u2_mb_type & MB_CODED ) ; if ( u2_mb_type & MB_BIDRECT ) { UWORD16 u2_index = ( ps_dec -> u2_motion_type ) ; ps_dec -> u2_prev_intra_mb = 0 ; ps_dec -> e_mb_pred = BIDIRECT ; ps_dec_mb_params = & ps_dec -> ps_func_bi_direct [ u2_index ] ; ps_dec -> s_mb_type = ps_dec_mb_params -> s_mb_type ; <S2SV_StartBug> ps_dec_mb_params -> pf_func_mb_params ( ps_dec ) ; <S2SV_EndBug> } else if ( u2_mb_type & MB_FORW_OR_BACK ) { UWORD16 u2_refPic = ! ( u2_mb_type & MB_MV_FORW ) ; UWORD16 u2_index = ( ps_dec -> u2_motion_type ) ; ps_dec -> u2_prev_intra_mb = 0 ; ps_dec -> e_mb_pred = ( e_pred_direction_t ) u2_refPic ; ps_dec_mb_params = & ps_dec -> ps_func_forw_or_back [ u2_index ] ; ps_dec -> s_mb_type = ps_dec_mb_params -> s_mb_type ; <S2SV_StartBug> ps_dec_mb_params -> pf_func_mb_params ( ps_dec ) ; <S2SV_EndBug> } else if ( u2_mb_type & MB_TYPE_INTRA ) { ps_dec -> u2_prev_intra_mb = 1 ; impeg2d_dec_intra_mb ( ps_dec ) ; } else { ps_dec -> u2_prev_intra_mb = 0 ; ps_dec -> e_mb_pred = FORW ; ps_dec -> u2_motion_type = 0 ; impeg2d_dec_0mv_coded_mb ( ps_dec ) ; } if ( ( u2_mb_type & MB_TYPE_INTRA ) ) { ps_dec -> u2_cbp = 0x3f ; ps_dec -> u2_prev_intra_mb = 1 ; } else { ps_dec -> u2_prev_intra_mb = 0 ; ps_dec -> u2_def_dc_pred [ Y_LUMA ] = 128 << ps_dec -> u2_intra_dc_precision ; ps_dec -> u2_def_dc_pred [ U_CHROMA ] = 128 << ps_dec -> u2_intra_dc_precision ; ps_dec -> u2_def_dc_pred [ V_CHROMA ] = 128 << ps_dec -> u2_intra_dc_precision ; if ( ( ps_dec -> u2_coded_mb ) ) { UWORD16 cbpValue ; cbpValue = gau2_impeg2d_cbp_code [ impeg2d_bit_stream_nxt ( ps_stream , MB_CBP_LEN ) ] ; ps_dec -> u2_cbp = cbpValue & 0xFF ; impeg2d_bit_stream_flush ( ps_stream , ( cbpValue >> 8 ) & 0x0FF ) ; } else { ps_dec -> u2_cbp = 0 ; } } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> WORD32 <S2SV_ModEnd> impeg2d_dec_pnb_mb_params ( dec_state_t <S2SV_ModStart> -> s_mb_type ; if ( NULL == ps_dec_mb_params -> pf_func_mb_params ) return - 1 ; <S2SV_ModStart> -> s_mb_type ; if ( NULL == ps_dec_mb_params -> pf_func_mb_params ) return - 1 ; <S2SV_ModStart> ; } } return 0 ;
"
325,"CWE-190 int rpc_pack ( rpc_pkg * pkg , void * * data , uint32_t * size ) { static void * send_buf ; static size_t send_buf_size ; <S2SV_StartBug> uint32_t pkg_size = RPC_PKG_HEAD_SIZE + pkg -> ext_size + pkg -> body_size ; <S2SV_EndBug> if ( send_buf_size < pkg_size ) { if ( send_buf ) free ( send_buf ) ; send_buf_size = pkg_size * 2 ; send_buf = malloc ( send_buf_size ) ; <S2SV_StartBug> assert ( send_buf != NULL ) ; <S2SV_EndBug> } memcpy ( send_buf , pkg , RPC_PKG_HEAD_SIZE ) ; if ( pkg -> ext_size ) memcpy ( send_buf + RPC_PKG_HEAD_SIZE , pkg -> ext , pkg -> ext_size ) ; if ( pkg -> body_size ) memcpy ( send_buf + RPC_PKG_HEAD_SIZE + pkg -> ext_size , pkg -> body , pkg -> body_size ) ; pkg = send_buf ; pkg -> magic = htole32 ( RPC_PKG_MAGIC ) ; pkg -> command = htole32 ( pkg -> command ) ; pkg -> pkg_type = htole16 ( pkg -> pkg_type ) ; pkg -> result = htole32 ( pkg -> result ) ; pkg -> sequence = htole32 ( pkg -> sequence ) ; pkg -> req_id = htole64 ( pkg -> req_id ) ; pkg -> body_size = htole32 ( pkg -> body_size ) ; pkg -> ext_size = htole16 ( pkg -> ext_size ) ; pkg -> crc32 = 0 ; pkg -> crc32 = htole32 ( generate_crc32c ( send_buf , pkg_size ) ) ; * data = send_buf ; * size = pkg_size ; return 0 ; }
","<S2SV_ModStart> ; uint32_t pkg_size ; if ( pkg -> body_size > RPC_PKG_MAX_BODY_SIZE ) { return - 1 ; } pkg_size <S2SV_ModStart> send_buf_size ) ; if ( send_buf == NULL ) { return - 1 ; } <S2SV_ModEnd> } memcpy (
"
326,"CWE-125 struct _mdi * _WM_ParseNewMus ( uint8_t * mus_data , uint32_t mus_size ) { uint8_t mus_hdr [ ] = { 'M' , 'U' , 'S' , 0x1A } ; uint32_t mus_song_ofs = 0 ; uint32_t mus_song_len = 0 ; uint16_t mus_ch_cnt1 = 0 ; uint16_t mus_ch_cnt2 = 0 ; uint16_t mus_no_instr = 0 ; uint32_t mus_data_ofs = 0 ; uint16_t * mus_mid_instr = NULL ; uint16_t mus_instr_cnt = 0 ; struct _mdi * mus_mdi ; uint32_t mus_divisions = 60 ; float tempo_f = 0.0 ; uint16_t mus_freq = 0 ; float samples_per_tick_f = 0.0 ; <S2SV_StartBug> uint8_t mus_event [ ] = { 0 , 0 , 0 , 0 } ; <S2SV_EndBug> uint8_t mus_event_size = 0 ; uint8_t mus_prev_vol [ ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; uint32_t setup_ret = 0 ; uint32_t mus_ticks = 0 ; uint32_t sample_count = 0 ; float sample_count_f = 0.0 ; float sample_remainder = 0.0 ; uint16_t pitchbend_tmp = 0 ; if ( mus_size < 17 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_MUS , ""File<S2SV_blank>too<S2SV_blank>short"" , 0 ) ; return NULL ; } if ( memcmp ( mus_data , mus_hdr , 4 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_MUS , NULL , 0 ) ; return NULL ; } mus_song_len = ( mus_data [ 5 ] << 8 ) | mus_data [ 4 ] ; mus_song_ofs = ( mus_data [ 7 ] << 8 ) | mus_data [ 6 ] ; mus_ch_cnt1 = ( mus_data [ 9 ] << 8 ) | mus_data [ 8 ] ; mus_ch_cnt2 = ( mus_data [ 11 ] << 8 ) | mus_data [ 10 ] ; UNUSED ( mus_ch_cnt1 ) ; UNUSED ( mus_ch_cnt2 ) ; mus_no_instr = ( mus_data [ 13 ] << 8 ) | mus_data [ 12 ] ; mus_data_ofs = 16 ; if ( mus_size < ( mus_data_ofs + ( mus_no_instr << 1 ) + mus_song_len ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_MUS , ""File<S2SV_blank>too<S2SV_blank>short"" , 0 ) ; return NULL ; } mus_mid_instr = malloc ( mus_no_instr * sizeof ( uint16_t ) ) ; for ( mus_instr_cnt = 0 ; mus_instr_cnt < mus_no_instr ; mus_instr_cnt ++ ) { mus_mid_instr [ mus_instr_cnt ] = ( mus_data [ mus_data_ofs + 1 ] << 8 ) | mus_data [ mus_data_ofs ] ; mus_data_ofs += 2 ; } mus_data_ofs = mus_song_ofs ; mus_freq = _cvt_get_option ( WM_CO_FREQUENCY ) ; if ( mus_freq == 0 ) mus_freq = 140 ; if ( ( _WM_MixerOptions & WM_MO_ROUNDTEMPO ) ) { tempo_f = ( float ) ( 60000000 / mus_freq ) + 0.5f ; } else { tempo_f = ( float ) ( 60000000 / mus_freq ) ; } samples_per_tick_f = _WM_GetSamplesPerTick ( mus_divisions , ( uint32_t ) tempo_f ) ; mus_mdi = _WM_initMDI ( ) ; _WM_midi_setup_divisions ( mus_mdi , mus_divisions ) ; _WM_midi_setup_tempo ( mus_mdi , ( uint32_t ) tempo_f ) ; do { _mus_build_event : # if 1 MUS_EVENT_DEBUG ( ""Before"" , mus_data [ mus_data_ofs ] , 0 ) ; if ( ( mus_data [ mus_data_ofs ] & 0x0f ) == 0x0f ) { mus_data [ mus_data_ofs ] = ( mus_data [ mus_data_ofs ] & 0xf0 ) | 0x09 ; } else if ( ( mus_data [ mus_data_ofs ] & 0x0f ) == 0x09 ) { mus_data [ mus_data_ofs ] = ( mus_data [ mus_data_ofs ] & 0xf0 ) | 0x0f ; } MUS_EVENT_DEBUG ( ""After"" , mus_data [ mus_data_ofs ] , 0 ) ; # endif switch ( ( mus_data [ mus_data_ofs ] >> 4 ) & 0x07 ) { case 0 : mus_event_size = 2 ; mus_event [ 0 ] = 0x80 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = mus_data [ mus_data_ofs + 1 ] ; mus_event [ 2 ] = 0 ; mus_event [ 3 ] = 0 ; break ; case 1 : if ( mus_data [ mus_data_ofs + 1 ] & 0x80 ) { mus_event_size = 3 ; mus_event [ 0 ] = 0x90 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = mus_data [ mus_data_ofs + 1 ] & 0x7f ; mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; mus_event [ 3 ] = 0 ; mus_prev_vol [ mus_data [ mus_data_ofs ] & 0x0f ] = mus_event [ 2 ] ; } else { mus_event_size = 2 ; mus_event [ 0 ] = 0x90 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = mus_data [ mus_data_ofs + 1 ] ; mus_event [ 2 ] = mus_prev_vol [ mus_data [ mus_data_ofs ] & 0x0f ] ; mus_event [ 3 ] = 0 ; } break ; case 2 : mus_event_size = 2 ; mus_event [ 0 ] = 0xe0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; pitchbend_tmp = mus_data [ mus_data_ofs + 1 ] << 6 ; mus_event [ 1 ] = pitchbend_tmp & 0x7f ; mus_event [ 2 ] = ( pitchbend_tmp >> 7 ) & 0x7f ; mus_event [ 3 ] = 0 ; break ; case 3 : mus_event_size = 2 ; switch ( mus_data [ mus_data_ofs + 1 ] ) { case 10 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 120 ; mus_event [ 2 ] = 0 ; mus_event [ 3 ] = 0 ; break ; case 11 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 123 ; mus_event [ 2 ] = 0 ; mus_event [ 3 ] = 0 ; break ; case 12 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 126 ; mus_event [ 2 ] = 0 ; mus_event [ 3 ] = 0 ; break ; case 13 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 127 ; mus_event [ 2 ] = 0 ; mus_event [ 3 ] = 0 ; break ; case 14 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 121 ; mus_event [ 2 ] = 0 ; mus_event [ 3 ] = 0 ; break ; default : goto _mus_next_data ; } break ; case 4 : mus_event_size = 3 ; switch ( mus_data [ mus_data_ofs + 1 ] ) { case 0 : mus_event [ 0 ] = 0xc0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = mus_data [ mus_data_ofs + 2 ] ; mus_event [ 2 ] = 0 ; mus_event [ 3 ] = 0 ; break ; case 1 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 0 ; mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; mus_event [ 3 ] = 0 ; break ; case 2 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 1 ; mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; mus_event [ 3 ] = 0 ; break ; case 3 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 7 ; mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; mus_event [ 3 ] = 0 ; break ; case 4 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 10 ; mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; mus_event [ 3 ] = 0 ; break ; case 5 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 11 ; mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; mus_event [ 3 ] = 0 ; break ; case 6 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 91 ; mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; mus_event [ 3 ] = 0 ; break ; case 7 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 93 ; mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; mus_event [ 3 ] = 0 ; break ; case 8 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 64 ; mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; mus_event [ 3 ] = 0 ; break ; case 9 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 67 ; mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; mus_event [ 3 ] = 0 ; break ; default : goto _mus_next_data ; } break ; case 5 : mus_event_size = 1 ; goto _mus_next_data ; break ; case 6 : goto _mus_end_of_song ; break ; case 7 : mus_event_size = 1 ; goto _mus_next_data ; break ; } <S2SV_StartBug> setup_ret = _WM_SetupMidiEvent ( mus_mdi , ( uint8_t * ) mus_event , 0 ) ; <S2SV_EndBug> if ( setup_ret == 0 ) { goto _mus_end ; } _mus_next_data : if ( ! ( mus_data [ mus_data_ofs ] & 0x80 ) ) { mus_data_ofs += mus_event_size ; goto _mus_build_event ; } mus_data_ofs += mus_event_size ; mus_ticks = 0 ; do { mus_ticks = ( mus_ticks << 7 ) | ( mus_data [ mus_data_ofs ++ ] & 0x7f ) ; } while ( mus_data [ mus_data_ofs - 1 ] & 0x80 ) ; sample_count_f = ( ( float ) mus_ticks * samples_per_tick_f ) + sample_remainder ; sample_count = ( uint32_t ) sample_count_f ; sample_remainder = sample_count_f - ( float ) sample_count ; mus_mdi -> events [ mus_mdi -> event_count - 1 ] . samples_to_next = sample_count ; mus_mdi -> extra_info . approx_total_samples += sample_count ; } while ( mus_data_ofs < mus_size ) ; _mus_end_of_song : if ( ( mus_mdi -> reverb = _WM_init_reverb ( _WM_SampleRate , _WM_reverb_room_width , _WM_reverb_room_length , _WM_reverb_listen_posx , _WM_reverb_listen_posy ) ) == NULL ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_MEM , ""to<S2SV_blank>init<S2SV_blank>reverb"" , 0 ) ; goto _mus_end ; } _WM_midi_setup_endoftrack ( mus_mdi ) ; mus_mdi -> extra_info . current_sample = 0 ; mus_mdi -> current_event = & mus_mdi -> events [ 0 ] ; mus_mdi -> samples_to_mix = 0 ; mus_mdi -> note = NULL ; _WM_ResetToStart ( mus_mdi ) ; _mus_end : free ( mus_mid_instr ) ; if ( mus_mdi -> reverb ) return ( mus_mdi ) ; _WM_freeMDI ( mus_mdi ) ; return NULL ; }
","<S2SV_ModStart> = 0.0 ; # define MUS_SZ 4 <S2SV_ModStart> uint8_t mus_event [ MUS_SZ <S2SV_ModStart> * ) mus_event , MUS_SZ
"
327,"CWE-119 int cdf_read_property_info ( const cdf_stream_t * sst , const cdf_header_t * h , uint32_t offs , cdf_property_info_t * * info , size_t * count , size_t * maxcount ) { const cdf_section_header_t * shp ; cdf_section_header_t sh ; const uint8_t * p , * q , * e ; int16_t s16 ; int32_t s32 ; uint32_t u32 ; int64_t s64 ; uint64_t u64 ; cdf_timestamp_t tp ; size_t i , o , o4 , nelements , j ; cdf_property_info_t * inp ; if ( offs > UINT32_MAX / 4 ) { errno = EFTYPE ; goto out ; } shp = CAST ( const cdf_section_header_t * , ( const void * ) ( ( const char * ) sst -> sst_tab + offs ) ) ; if ( cdf_check_stream_offset ( sst , h , shp , sizeof ( * shp ) , __LINE__ ) == - 1 ) goto out ; sh . sh_len = CDF_TOLE4 ( shp -> sh_len ) ; # define CDF_SHLEN_LIMIT ( UINT32_MAX / 8 ) if ( sh . sh_len > CDF_SHLEN_LIMIT ) { errno = EFTYPE ; goto out ; } sh . sh_properties = CDF_TOLE4 ( shp -> sh_properties ) ; # define CDF_PROP_LIMIT ( UINT32_MAX / ( 4 * sizeof ( * inp ) ) ) if ( sh . sh_properties > CDF_PROP_LIMIT ) goto out ; DPRINTF ( ( ""section<S2SV_blank>len:<S2SV_blank>%u<S2SV_blank>properties<S2SV_blank>%u\\n"" , sh . sh_len , sh . sh_properties ) ) ; if ( * maxcount ) { if ( * maxcount > CDF_PROP_LIMIT ) goto out ; * maxcount += sh . sh_properties ; inp = CAST ( cdf_property_info_t * , realloc ( * info , * maxcount * sizeof ( * inp ) ) ) ; } else { * maxcount = sh . sh_properties ; inp = CAST ( cdf_property_info_t * , malloc ( * maxcount * sizeof ( * inp ) ) ) ; } if ( inp == NULL ) goto out ; * info = inp ; inp += * count ; * count += sh . sh_properties ; p = CAST ( const uint8_t * , ( const void * ) ( ( const char * ) ( const void * ) sst -> sst_tab + offs + sizeof ( sh ) ) ) ; e = CAST ( const uint8_t * , ( const void * ) ( ( ( const char * ) ( const void * ) shp ) + sh . sh_len ) ) ; if ( cdf_check_stream_offset ( sst , h , e , 0 , __LINE__ ) == - 1 ) goto out ; for ( i = 0 ; i < sh . sh_properties ; i ++ ) { size_t ofs = CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ; q = ( const uint8_t * ) ( const void * ) ( ( const char * ) ( const void * ) p + ofs - 2 * sizeof ( uint32_t ) ) ; if ( q > e ) { DPRINTF ( ( ""Ran<S2SV_blank>of<S2SV_blank>the<S2SV_blank>end<S2SV_blank>%p<S2SV_blank>><S2SV_blank>%p\\n"" , q , e ) ) ; goto out ; } inp [ i ] . pi_id = CDF_GETUINT32 ( p , i << 1 ) ; inp [ i ] . pi_type = CDF_GETUINT32 ( q , 0 ) ; DPRINTF ( ( ""%"" SIZE_T_FORMAT ""u)<S2SV_blank>id=%x<S2SV_blank>type=%x<S2SV_blank>offs=0x%tx,0x%x\\n"" , i , inp [ i ] . pi_id , inp [ i ] . pi_type , q - p , offs ) ) ; if ( inp [ i ] . pi_type & CDF_VECTOR ) { nelements = CDF_GETUINT32 ( q , 1 ) ; <S2SV_StartBug> o = 2 ; <S2SV_EndBug> } else { nelements = 1 ; o = 1 ; } o4 = o * sizeof ( uint32_t ) ; if ( inp [ i ] . pi_type & ( CDF_ARRAY | CDF_BYREF | CDF_RESERVED ) ) goto unknown ; switch ( inp [ i ] . pi_type & CDF_TYPEMASK ) { case CDF_NULL : case CDF_EMPTY : break ; case CDF_SIGNED16 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s16 , & q [ o4 ] , sizeof ( s16 ) ) ; inp [ i ] . pi_s16 = CDF_TOLE2 ( s16 ) ; break ; case CDF_SIGNED32 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s32 , & q [ o4 ] , sizeof ( s32 ) ) ; inp [ i ] . pi_s32 = CDF_TOLE4 ( ( uint32_t ) s32 ) ; break ; case CDF_BOOL : case CDF_UNSIGNED32 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u32 , & q [ o4 ] , sizeof ( u32 ) ) ; inp [ i ] . pi_u32 = CDF_TOLE4 ( u32 ) ; break ; case CDF_SIGNED64 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s64 , & q [ o4 ] , sizeof ( s64 ) ) ; inp [ i ] . pi_s64 = CDF_TOLE8 ( ( uint64_t ) s64 ) ; break ; case CDF_UNSIGNED64 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u64 , & q [ o4 ] , sizeof ( u64 ) ) ; inp [ i ] . pi_u64 = CDF_TOLE8 ( ( uint64_t ) u64 ) ; break ; case CDF_FLOAT : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u32 , & q [ o4 ] , sizeof ( u32 ) ) ; u32 = CDF_TOLE4 ( u32 ) ; memcpy ( & inp [ i ] . pi_f , & u32 , sizeof ( inp [ i ] . pi_f ) ) ; break ; case CDF_DOUBLE : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u64 , & q [ o4 ] , sizeof ( u64 ) ) ; u64 = CDF_TOLE8 ( ( uint64_t ) u64 ) ; memcpy ( & inp [ i ] . pi_d , & u64 , sizeof ( inp [ i ] . pi_d ) ) ; break ; case CDF_LENGTH32_STRING : case CDF_LENGTH32_WSTRING : if ( nelements > 1 ) { size_t nelem = inp - * info ; if ( * maxcount > CDF_PROP_LIMIT || nelements > CDF_PROP_LIMIT ) goto out ; * maxcount += nelements ; inp = CAST ( cdf_property_info_t * , realloc ( * info , * maxcount * sizeof ( * inp ) ) ) ; if ( inp == NULL ) goto out ; * info = inp ; inp = * info + nelem ; } DPRINTF ( ( ""nelements<S2SV_blank>=<S2SV_blank>%"" SIZE_T_FORMAT ""u\\n"" , nelements ) ) ; <S2SV_StartBug> for ( j = 0 ; j < nelements ; j ++ , i ++ ) { <S2SV_EndBug> uint32_t l = CDF_GETUINT32 ( q , o ) ; inp [ i ] . pi_str . s_len = l ; inp [ i ] . pi_str . s_buf = ( const char * ) ( const void * ) ( & q [ o4 + sizeof ( l ) ] ) ; DPRINTF ( ( ""l<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>r<S2SV_blank>=<S2SV_blank>%"" SIZE_T_FORMAT ""u,<S2SV_blank>s<S2SV_blank>=<S2SV_blank>%s\\n"" , l , CDF_ROUND ( l , sizeof ( l ) ) , inp [ i ] . pi_str . s_buf ) ) ; if ( l & 1 ) l ++ ; o += l >> 1 ; if ( q + o >= e ) goto out ; o4 = o * sizeof ( uint32_t ) ; } i -- ; break ; case CDF_FILETIME : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & tp , & q [ o4 ] , sizeof ( tp ) ) ; inp [ i ] . pi_tp = CDF_TOLE8 ( ( uint64_t ) tp ) ; break ; case CDF_CLIPBOARD : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; break ; default : unknown : DPRINTF ( ( ""Don\'t<S2SV_blank>know<S2SV_blank>how<S2SV_blank>to<S2SV_blank>deal<S2SV_blank>with<S2SV_blank>%x\\n"" , inp [ i ] . pi_type ) ) ; break ; } } return 0 ; out : free ( * info ) ; return - 1 ; }
","<S2SV_ModStart> 1 ) ; if ( nelements == 0 ) { DPRINTF ( ( ""CDF_VECTOR<S2SV_blank>with<S2SV_blank>nelements<S2SV_blank>==<S2SV_blank>0\\n"" ) ) ; goto out ; } <S2SV_ModStart> j < nelements && i < sh . sh_properties ; <S2SV_ModEnd> j ++ ,
"
328,"CWE-119 void edge_sparse_csr_reader_double ( const char * i_csr_file_in , unsigned int * * o_row_idx , unsigned int * * o_column_idx , double * * o_values , unsigned int * o_row_count , unsigned int * o_column_count , unsigned int * o_element_count ) { FILE * l_csr_file_handle ; const unsigned int l_line_length = 512 ; char l_line [ 512 + 1 ] ; unsigned int l_header_read = 0 ; unsigned int * l_row_idx_id = NULL ; unsigned int l_i = 0 ; l_csr_file_handle = fopen ( i_csr_file_in , ""r"" ) ; if ( l_csr_file_handle == NULL ) { fprintf ( stderr , ""cannot<S2SV_blank>open<S2SV_blank>CSR<S2SV_blank>file!\\n"" ) ; return ; } while ( fgets ( l_line , l_line_length , l_csr_file_handle ) != NULL ) { if ( strlen ( l_line ) == l_line_length ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>read<S2SV_blank>file<S2SV_blank>length!\\n"" ) ; return ; } if ( l_line [ 0 ] == '%' ) { continue ; } else { if ( l_header_read == 0 ) { <S2SV_StartBug> if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%u"" , o_row_count , o_column_count , o_element_count ) == 3 ) { <S2SV_EndBug> * o_column_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_element_count ) ) ; * o_row_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_row_count + 1 ) ) ; * o_values = ( double * ) malloc ( sizeof ( double ) * ( * o_element_count ) ) ; l_row_idx_id = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_row_count ) ) ; if ( ( * o_row_idx == NULL ) || ( * o_column_idx == NULL ) || ( * o_values == NULL ) || ( l_row_idx_id == NULL ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>sp<S2SV_blank>data!\\n"" ) ; return ; } memset ( * o_row_idx , 0 , sizeof ( unsigned int ) * ( * o_row_count + 1 ) ) ; memset ( * o_column_idx , 0 , sizeof ( unsigned int ) * ( * o_element_count ) ) ; memset ( * o_values , 0 , sizeof ( double ) * ( * o_element_count ) ) ; memset ( l_row_idx_id , 0 , sizeof ( unsigned int ) * ( * o_row_count ) ) ; for ( l_i = 0 ; l_i < ( * o_row_count + 1 ) ; l_i ++ ) ( * o_row_idx ) [ l_i ] = ( * o_element_count ) ; ( * o_row_idx ) [ 0 ] = 0 ; l_i = 0 ; l_header_read = 1 ; } else { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>csr<S2SV_blank>description!\\n"" ) ; return ; } } else { unsigned int l_row , l_column ; double l_value ; if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%lf"" , & l_row , & l_column , & l_value ) != 3 ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>read<S2SV_blank>element!\\n"" ) ; return ; } l_row -- ; l_column -- ; ( * o_column_idx ) [ l_i ] = l_column ; ( * o_values ) [ l_i ] = l_value ; l_i ++ ; l_row_idx_id [ l_row ] = 1 ; ( * o_row_idx ) [ l_row + 1 ] = l_i ; } } } fclose ( l_csr_file_handle ) ; if ( l_i != ( * o_element_count ) ) { fprintf ( stderr , ""we<S2SV_blank>were<S2SV_blank>not<S2SV_blank>able<S2SV_blank>to<S2SV_blank>read<S2SV_blank>all<S2SV_blank>elements!\\n"" ) ; return ; } for ( l_i = 0 ; l_i < ( * o_row_count ) ; l_i ++ ) { if ( l_row_idx_id [ l_i ] == 0 ) { ( * o_row_idx ) [ l_i + 1 ] = ( * o_row_idx ) [ l_i ] ; } } if ( l_row_idx_id != NULL ) { free ( l_row_idx_id ) ; } }
","<S2SV_ModStart> { if ( 3 == <S2SV_ModStart> , o_element_count ) && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) <S2SV_ModEnd> { * o_column_idx
"
329,"CWE-119 static int udf_load_logicalvol ( struct super_block * sb , sector_t block , struct kernel_lb_addr * fileset ) { struct logicalVolDesc * lvd ; <S2SV_StartBug> int i , j , offset ; <S2SV_EndBug> uint8_t type ; struct udf_sb_info * sbi = UDF_SB ( sb ) ; struct genericPartitionMap * gpm ; uint16_t ident ; struct buffer_head * bh ; unsigned int table_len ; int ret = 0 ; bh = udf_read_tagged ( sb , block , block , & ident ) ; if ( ! bh ) return 1 ; BUG_ON ( ident != TAG_IDENT_LVD ) ; lvd = ( struct logicalVolDesc * ) bh -> b_data ; table_len = le32_to_cpu ( lvd -> mapTableLength ) ; if ( sizeof ( * lvd ) + table_len > sb -> s_blocksize ) { udf_err ( sb , ""error<S2SV_blank>loading<S2SV_blank>logical<S2SV_blank>volume<S2SV_blank>descriptor:<S2SV_blank>"" ""Partition<S2SV_blank>table<S2SV_blank>too<S2SV_blank>long<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%lu)\\n"" , table_len , sb -> s_blocksize - sizeof ( * lvd ) ) ; goto out_bh ; } ret = udf_sb_alloc_partition_maps ( sb , le32_to_cpu ( lvd -> numPartitionMaps ) ) ; if ( ret ) goto out_bh ; for ( i = 0 , offset = 0 ; i < sbi -> s_partitions && offset < table_len ; i ++ , offset += gpm -> partitionMapLength ) { struct udf_part_map * map = & sbi -> s_partmaps [ i ] ; gpm = ( struct genericPartitionMap * ) & ( lvd -> partitionMaps [ offset ] ) ; type = gpm -> partitionMapType ; if ( type == 1 ) { struct genericPartitionMap1 * gpm1 = ( struct genericPartitionMap1 * ) gpm ; map -> s_partition_type = UDF_TYPE1_MAP15 ; map -> s_volumeseqnum = le16_to_cpu ( gpm1 -> volSeqNum ) ; map -> s_partition_num = le16_to_cpu ( gpm1 -> partitionNum ) ; map -> s_partition_func = NULL ; } else if ( type == 2 ) { struct udfPartitionMap2 * upm2 = ( struct udfPartitionMap2 * ) gpm ; if ( ! strncmp ( upm2 -> partIdent . ident , UDF_ID_VIRTUAL , strlen ( UDF_ID_VIRTUAL ) ) ) { u16 suf = le16_to_cpu ( ( ( __le16 * ) upm2 -> partIdent . identSuffix ) [ 0 ] ) ; if ( suf < 0x0200 ) { map -> s_partition_type = UDF_VIRTUAL_MAP15 ; map -> s_partition_func = udf_get_pblock_virt15 ; } else { map -> s_partition_type = UDF_VIRTUAL_MAP20 ; map -> s_partition_func = udf_get_pblock_virt20 ; } } else if ( ! strncmp ( upm2 -> partIdent . ident , UDF_ID_SPARABLE , strlen ( UDF_ID_SPARABLE ) ) ) { <S2SV_StartBug> uint32_t loc ; <S2SV_EndBug> struct sparingTable * st ; <S2SV_StartBug> struct sparablePartitionMap * spm = <S2SV_EndBug> ( struct sparablePartitionMap * ) gpm ; map -> s_partition_type = UDF_SPARABLE_MAP15 ; map -> s_type_specific . s_sparing . s_packet_len = le16_to_cpu ( spm -> packetLength ) ; for ( j = 0 ; j < spm -> numSparingTables ; j ++ ) { struct buffer_head * bh2 ; loc = le32_to_cpu ( spm -> locSparingTable [ j ] ) ; bh2 = udf_read_tagged ( sb , loc , loc , & ident ) ; map -> s_type_specific . s_sparing . s_spar_map [ j ] = bh2 ; if ( bh2 == NULL ) continue ; st = ( struct sparingTable * ) bh2 -> b_data ; if ( ident != 0 || strncmp ( st -> sparingIdent . ident , UDF_ID_SPARING , strlen ( UDF_ID_SPARING ) ) ) { brelse ( bh2 ) ; map -> s_type_specific . s_sparing . s_spar_map [ j ] = NULL ; } } map -> s_partition_func = udf_get_pblock_spar15 ; } else if ( ! strncmp ( upm2 -> partIdent . ident , UDF_ID_METADATA , strlen ( UDF_ID_METADATA ) ) ) { struct udf_meta_data * mdata = & map -> s_type_specific . s_metadata ; struct metadataPartitionMap * mdm = ( struct metadataPartitionMap * ) & ( lvd -> partitionMaps [ offset ] ) ; udf_debug ( ""Parsing<S2SV_blank>Logical<S2SV_blank>vol<S2SV_blank>part<S2SV_blank>%d<S2SV_blank>type<S2SV_blank>%d<S2SV_blank><S2SV_blank>id=%s\\n"" , i , type , UDF_ID_METADATA ) ; map -> s_partition_type = UDF_METADATA_MAP25 ; map -> s_partition_func = udf_get_pblock_meta25 ; mdata -> s_meta_file_loc = le32_to_cpu ( mdm -> metadataFileLoc ) ; mdata -> s_mirror_file_loc = le32_to_cpu ( mdm -> metadataMirrorFileLoc ) ; mdata -> s_bitmap_file_loc = le32_to_cpu ( mdm -> metadataBitmapFileLoc ) ; mdata -> s_alloc_unit_size = le32_to_cpu ( mdm -> allocUnitSize ) ; mdata -> s_align_unit_size = le16_to_cpu ( mdm -> alignUnitSize ) ; if ( mdm -> flags & 0x01 ) mdata -> s_flags |= MF_DUPLICATE_MD ; udf_debug ( ""Metadata<S2SV_blank>Ident<S2SV_blank>suffix=0x%x\\n"" , le16_to_cpu ( * ( __le16 * ) mdm -> partIdent . identSuffix ) ) ; udf_debug ( ""Metadata<S2SV_blank>part<S2SV_blank>num=%d\\n"" , le16_to_cpu ( mdm -> partitionNum ) ) ; udf_debug ( ""Metadata<S2SV_blank>part<S2SV_blank>alloc<S2SV_blank>unit<S2SV_blank>size=%d\\n"" , le32_to_cpu ( mdm -> allocUnitSize ) ) ; udf_debug ( ""Metadata<S2SV_blank>file<S2SV_blank>loc=%d\\n"" , le32_to_cpu ( mdm -> metadataFileLoc ) ) ; udf_debug ( ""Mirror<S2SV_blank>file<S2SV_blank>loc=%d\\n"" , le32_to_cpu ( mdm -> metadataMirrorFileLoc ) ) ; udf_debug ( ""Bitmap<S2SV_blank>file<S2SV_blank>loc=%d\\n"" , le32_to_cpu ( mdm -> metadataBitmapFileLoc ) ) ; udf_debug ( ""Flags:<S2SV_blank>%d<S2SV_blank>%d\\n"" , mdata -> s_flags , mdm -> flags ) ; } else { udf_debug ( ""Unknown<S2SV_blank>ident:<S2SV_blank>%s\\n"" , upm2 -> partIdent . ident ) ; continue ; } map -> s_volumeseqnum = le16_to_cpu ( upm2 -> volSeqNum ) ; map -> s_partition_num = le16_to_cpu ( upm2 -> partitionNum ) ; } udf_debug ( ""Partition<S2SV_blank>(%d:%d)<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>on<S2SV_blank>volume<S2SV_blank>%d\\n"" , i , map -> s_partition_num , type , map -> s_volumeseqnum ) ; } if ( fileset ) { struct long_ad * la = ( struct long_ad * ) & ( lvd -> logicalVolContentsUse [ 0 ] ) ; * fileset = lelb_to_cpu ( la -> extLocation ) ; udf_debug ( ""FileSet<S2SV_blank>found<S2SV_blank>in<S2SV_blank>LogicalVolDesc<S2SV_blank>at<S2SV_blank>block=%d,<S2SV_blank>partition=%d\\n"" , fileset -> logicalBlockNum , fileset -> partitionReferenceNum ) ; } if ( lvd -> integritySeqExt . extLength ) udf_load_logicalvolint ( sb , leea_to_cpu ( lvd -> integritySeqExt ) ) ; out_bh : brelse ( bh ) ; return ret ; }
","<S2SV_ModStart> ; int i <S2SV_ModEnd> , offset ; <S2SV_ModStart> ) ) { if ( udf_load_sparable_map ( sb , map , ( <S2SV_ModEnd> struct sparablePartitionMap * <S2SV_ModStart> struct sparablePartitionMap * ) gpm ) < 0 ) goto out_bh <S2SV_ModEnd> ; } else
"
330,"CWE-834 static int nsv_parse_NSVf_header ( AVFormatContext * s ) { NSVContext * nsv = s -> priv_data ; AVIOContext * pb = s -> pb ; unsigned int av_unused file_size ; unsigned int size ; int64_t duration ; int strings_size ; int table_entries ; int table_entries_used ; nsv -> state = NSV_UNSYNC ; size = avio_rl32 ( pb ) ; if ( size < 28 ) return - 1 ; nsv -> NSVf_end = size ; file_size = ( uint32_t ) avio_rl32 ( pb ) ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>NSVf<S2SV_blank>chunk_size<S2SV_blank>%u\\n"" , size ) ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>NSVf<S2SV_blank>file_size<S2SV_blank>%u\\n"" , file_size ) ; nsv -> duration = duration = avio_rl32 ( pb ) ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>NSVf<S2SV_blank>duration<S2SV_blank>%"" PRId64 ""<S2SV_blank>ms\\n"" , duration ) ; strings_size = avio_rl32 ( pb ) ; table_entries = avio_rl32 ( pb ) ; table_entries_used = avio_rl32 ( pb ) ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>NSVf<S2SV_blank>info-strings<S2SV_blank>size:<S2SV_blank>%d,<S2SV_blank>table<S2SV_blank>entries:<S2SV_blank>%d,<S2SV_blank>bis<S2SV_blank>%d\\n"" , strings_size , table_entries , table_entries_used ) ; if ( avio_feof ( pb ) ) return - 1 ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>got<S2SV_blank>header;<S2SV_blank>filepos<S2SV_blank>%"" PRId64 ""\\n"" , avio_tell ( pb ) ) ; if ( strings_size > 0 ) { char * strings ; char * p , * endp ; char * token , * value ; char quote ; p = strings = av_mallocz ( ( size_t ) strings_size + 1 ) ; if ( ! p ) return AVERROR ( ENOMEM ) ; endp = strings + strings_size ; avio_read ( pb , strings , strings_size ) ; while ( p < endp ) { while ( * p == '<S2SV_blank>' ) p ++ ; if ( p >= endp - 2 ) break ; token = p ; p = strchr ( p , '=' ) ; if ( ! p || p >= endp - 2 ) break ; * p ++ = '\\0' ; quote = * p ++ ; value = p ; p = strchr ( p , quote ) ; if ( ! p || p >= endp ) break ; * p ++ = '\\0' ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>NSVf<S2SV_blank>INFO:<S2SV_blank>%s=\'%s\'\\n"" , token , value ) ; av_dict_set ( & s -> metadata , token , value , 0 ) ; } av_free ( strings ) ; } if ( avio_feof ( pb ) ) return - 1 ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>got<S2SV_blank>infos;<S2SV_blank>filepos<S2SV_blank>%"" PRId64 ""\\n"" , avio_tell ( pb ) ) ; if ( table_entries_used > 0 ) { int i ; nsv -> index_entries = table_entries_used ; if ( ( unsigned ) table_entries_used >= UINT_MAX / sizeof ( uint32_t ) ) return - 1 ; nsv -> nsvs_file_offset = av_malloc_array ( ( unsigned ) table_entries_used , sizeof ( uint32_t ) ) ; if ( ! nsv -> nsvs_file_offset ) return AVERROR ( ENOMEM ) ; <S2SV_StartBug> for ( i = 0 ; i < table_entries_used ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> nsv -> nsvs_file_offset [ i ] = avio_rl32 ( pb ) + size ; <S2SV_EndBug> if ( table_entries > table_entries_used && avio_rl32 ( pb ) == MKTAG ( 'T' , 'O' , 'C' , '2' ) ) { nsv -> nsvs_timestamps = av_malloc_array ( ( unsigned ) table_entries_used , sizeof ( uint32_t ) ) ; if ( ! nsv -> nsvs_timestamps ) return AVERROR ( ENOMEM ) ; for ( i = 0 ; i < table_entries_used ; i ++ ) { nsv -> nsvs_timestamps [ i ] = avio_rl32 ( pb ) ; } } } av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>got<S2SV_blank>index;<S2SV_blank>filepos<S2SV_blank>%"" PRId64 ""\\n"" , avio_tell ( pb ) ) ; avio_seek ( pb , nsv -> base_offset + size , SEEK_SET ) ; if ( avio_feof ( pb ) ) return - 1 ; nsv -> state = NSV_HAS_READ_NSVF ; return 0 ; }
","<S2SV_ModStart> i ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> + size ; }
"
331,"CWE-119 Bool GPAC_EventProc ( void * ptr , GF_Event * evt ) { if ( ! term ) return 0 ; if ( gui_mode == 1 ) { if ( evt -> type == GF_EVENT_QUIT ) { Run = 0 ; } else if ( evt -> type == GF_EVENT_KEYDOWN ) { switch ( evt -> key . key_code ) { case GF_KEY_C : if ( evt -> key . flags & ( GF_KEY_MOD_CTRL | GF_KEY_MOD_ALT ) ) { hide_shell ( shell_visible ? 1 : 0 ) ; if ( shell_visible ) gui_mode = 2 ; } break ; default : break ; } } return 0 ; } switch ( evt -> type ) { case GF_EVENT_DURATION : Duration = ( u64 ) ( 1000 * ( s64 ) evt -> duration . duration ) ; CanSeek = evt -> duration . can_seek ; break ; case GF_EVENT_MESSAGE : { const char * servName ; if ( ! evt -> message . service || ! strcmp ( evt -> message . service , the_url ) ) { servName = """" ; } else if ( ! strnicmp ( evt -> message . service , ""data:"" , 5 ) ) { servName = ""(embedded<S2SV_blank>data)"" ; } else { servName = evt -> message . service ; } if ( ! evt -> message . message ) return 0 ; if ( evt -> message . error ) { if ( ! is_connected ) last_error = evt -> message . error ; if ( evt -> message . error == GF_SCRIPT_INFO ) { GF_LOG ( GF_LOG_INFO , GF_LOG_CONSOLE , ( ""%s\\n"" , evt -> message . message ) ) ; } else { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONSOLE , ( ""%s<S2SV_blank>%s:<S2SV_blank>%s\\n"" , servName , evt -> message . message , gf_error_to_string ( evt -> message . error ) ) ) ; } } else if ( ! be_quiet ) GF_LOG ( GF_LOG_INFO , GF_LOG_CONSOLE , ( ""%s<S2SV_blank>%s\\n"" , servName , evt -> message . message ) ) ; } break ; case GF_EVENT_PROGRESS : { char * szTitle = """" ; if ( evt -> progress . progress_type == 0 ) { szTitle = ""Buffer<S2SV_blank>"" ; if ( bench_mode && ( bench_mode != 3 ) ) { if ( evt -> progress . done >= evt -> progress . total ) bench_buffer = 0 ; else bench_buffer = 1 + 100 * evt -> progress . done / evt -> progress . total ; break ; } } else if ( evt -> progress . progress_type == 1 ) { if ( bench_mode ) break ; szTitle = ""Download<S2SV_blank>"" ; } else if ( evt -> progress . progress_type == 2 ) szTitle = ""Import<S2SV_blank>"" ; gf_set_progress ( szTitle , evt -> progress . done , evt -> progress . total ) ; } break ; case GF_EVENT_DBLCLICK : gf_term_set_option ( term , GF_OPT_FULLSCREEN , ! gf_term_get_option ( term , GF_OPT_FULLSCREEN ) ) ; return 0 ; case GF_EVENT_MOUSEDOWN : if ( evt -> mouse . button == GF_MOUSE_RIGHT ) { right_down = 1 ; last_x = evt -> mouse . x ; last_y = evt -> mouse . y ; } return 0 ; case GF_EVENT_MOUSEUP : if ( evt -> mouse . button == GF_MOUSE_RIGHT ) { right_down = 0 ; last_x = evt -> mouse . x ; last_y = evt -> mouse . y ; } return 0 ; case GF_EVENT_MOUSEMOVE : if ( right_down && ( user . init_flags & GF_TERM_WINDOWLESS ) ) { GF_Event move ; move . move . x = evt -> mouse . x - last_x ; move . move . y = last_y - evt -> mouse . y ; move . type = GF_EVENT_MOVE ; move . move . relative = 1 ; gf_term_user_event ( term , & move ) ; } return 0 ; case GF_EVENT_KEYUP : switch ( evt -> key . key_code ) { case GF_KEY_SPACE : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) switch_bench ( ! bench_mode ) ; break ; } break ; case GF_EVENT_KEYDOWN : gf_term_process_shortcut ( term , evt ) ; switch ( evt -> key . key_code ) { case GF_KEY_SPACE : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) { if ( ! bench_mode ) switch_bench ( ! bench_mode ) ; } break ; case GF_KEY_PAGEDOWN : case GF_KEY_MEDIANEXTTRACK : request_next_playlist_item = 1 ; break ; case GF_KEY_MEDIAPREVIOUSTRACK : break ; case GF_KEY_ESCAPE : gf_term_set_option ( term , GF_OPT_FULLSCREEN , ! gf_term_get_option ( term , GF_OPT_FULLSCREEN ) ) ; break ; case GF_KEY_C : if ( evt -> key . flags & ( GF_KEY_MOD_CTRL | GF_KEY_MOD_ALT ) ) { hide_shell ( shell_visible ? 1 : 0 ) ; if ( ! shell_visible ) gui_mode = 1 ; } break ; case GF_KEY_F : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) fprintf ( stderr , ""Rendering<S2SV_blank>rate:<S2SV_blank>%f<S2SV_blank>FPS\\n"" , gf_term_get_framerate ( term , 0 ) ) ; break ; case GF_KEY_T : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) fprintf ( stderr , ""Scene<S2SV_blank>Time:<S2SV_blank>%f<S2SV_blank>\\n"" , gf_term_get_time_in_ms ( term ) / 1000.0 ) ; break ; case GF_KEY_D : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) gf_term_set_option ( term , GF_OPT_DRAW_MODE , ( gf_term_get_option ( term , GF_OPT_DRAW_MODE ) == GF_DRAW_MODE_DEFER ) ? GF_DRAW_MODE_IMMEDIATE : GF_DRAW_MODE_DEFER ) ; break ; case GF_KEY_4 : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_4_3 ) ; break ; case GF_KEY_5 : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_16_9 ) ; break ; case GF_KEY_6 : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_FILL_SCREEN ) ; break ; case GF_KEY_7 : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_KEEP ) ; break ; case GF_KEY_O : if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) { if ( gf_term_get_option ( term , GF_OPT_MAIN_ADDON ) ) { fprintf ( stderr , ""Resuming<S2SV_blank>to<S2SV_blank>main<S2SV_blank>content\\n"" ) ; gf_term_set_option ( term , GF_OPT_PLAY_STATE , GF_STATE_PLAY_LIVE ) ; } else { fprintf ( stderr , ""Main<S2SV_blank>addon<S2SV_blank>not<S2SV_blank>enabled\\n"" ) ; } } break ; case GF_KEY_P : if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) { u32 pause_state = gf_term_get_option ( term , GF_OPT_PLAY_STATE ) ; fprintf ( stderr , ""[Status:<S2SV_blank>%s]\\n"" , pause_state ? ""Playing"" : ""Paused"" ) ; if ( ( pause_state == GF_STATE_PAUSED ) && ( evt -> key . flags & GF_KEY_MOD_SHIFT ) ) { gf_term_set_option ( term , GF_OPT_PLAY_STATE , GF_STATE_PLAY_LIVE ) ; } else { gf_term_set_option ( term , GF_OPT_PLAY_STATE , ( pause_state == GF_STATE_PAUSED ) ? GF_STATE_PLAYING : GF_STATE_PAUSED ) ; } } break ; case GF_KEY_S : if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) { gf_term_set_option ( term , GF_OPT_PLAY_STATE , GF_STATE_STEP_PAUSE ) ; fprintf ( stderr , ""Step<S2SV_blank>time:<S2SV_blank>"" ) ; PrintTime ( gf_term_get_time_in_ms ( term ) ) ; fprintf ( stderr , ""\\n"" ) ; } break ; case GF_KEY_B : if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) ViewODs ( term , 1 ) ; break ; case GF_KEY_M : if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) ViewODs ( term , 0 ) ; break ; case GF_KEY_H : if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) { gf_term_switch_quality ( term , 1 ) ; } break ; case GF_KEY_L : if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) { gf_term_switch_quality ( term , 0 ) ; } break ; case GF_KEY_F5 : if ( is_connected ) reload = 1 ; break ; case GF_KEY_A : addon_visible = ! addon_visible ; gf_term_toggle_addons ( term , addon_visible ) ; break ; case GF_KEY_UP : if ( ( evt -> key . flags & VK_MOD ) && is_connected ) { do_set_speed ( playback_speed * 2 ) ; } break ; case GF_KEY_DOWN : if ( ( evt -> key . flags & VK_MOD ) && is_connected ) { do_set_speed ( playback_speed / 2 ) ; } break ; case GF_KEY_LEFT : if ( ( evt -> key . flags & VK_MOD ) && is_connected ) { do_set_speed ( - 1 * playback_speed ) ; } break ; } break ; case GF_EVENT_CONNECT : if ( evt -> connect . is_connected ) { is_connected = 1 ; fprintf ( stderr , ""Service<S2SV_blank>Connected\\n"" ) ; eos_seen = GF_FALSE ; if ( playback_speed != FIX_ONE ) gf_term_set_speed ( term , playback_speed ) ; } else if ( is_connected ) { fprintf ( stderr , ""Service<S2SV_blank>%s\\n"" , is_connected ? ""Disconnected"" : ""Connection<S2SV_blank>Failed"" ) ; is_connected = 0 ; Duration = 0 ; } if ( init_w && init_h ) { gf_term_set_size ( term , init_w , init_h ) ; } ResetCaption ( ) ; break ; case GF_EVENT_EOS : eos_seen = GF_TRUE ; if ( playlist ) { if ( Duration > 1500 ) request_next_playlist_item = GF_TRUE ; } else if ( loop_at_end ) { restart = 1 ; } break ; case GF_EVENT_SIZE : if ( user . init_flags & GF_TERM_WINDOWLESS ) { GF_Event move ; move . type = GF_EVENT_MOVE ; move . move . align_x = align_mode & 0xFF ; move . move . align_y = ( align_mode >> 8 ) & 0xFF ; move . move . relative = 2 ; gf_term_user_event ( term , & move ) ; } break ; case GF_EVENT_SCENE_SIZE : if ( forced_width && forced_height ) { GF_Event size ; size . type = GF_EVENT_SIZE ; size . size . width = forced_width ; size . size . height = forced_height ; gf_term_user_event ( term , & size ) ; } break ; case GF_EVENT_METADATA : ResetCaption ( ) ; break ; case GF_EVENT_RELOAD : if ( is_connected ) reload = 1 ; break ; case GF_EVENT_DROPFILE : { u32 i , pos ; if ( readonly_playlist ) { gf_fclose ( playlist ) ; playlist = NULL ; } readonly_playlist = 0 ; if ( ! playlist ) { readonly_playlist = 0 ; playlist = gf_temp_file_new ( NULL ) ; } pos = ftell ( playlist ) ; i = 0 ; while ( i < evt -> open_file . nb_files ) { if ( evt -> open_file . files [ i ] != NULL ) { fprintf ( playlist , ""%s\\n"" , evt -> open_file . files [ i ] ) ; } i ++ ; } fseek ( playlist , pos , SEEK_SET ) ; request_next_playlist_item = 1 ; } return 1 ; case GF_EVENT_QUIT : if ( evt -> message . error ) { fprintf ( stderr , ""A<S2SV_blank>fatal<S2SV_blank>error<S2SV_blank>was<S2SV_blank>encoutered:<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>-<S2SV_blank>exiting<S2SV_blank>...\\n"" , evt -> message . message ? evt -> message . message : ""no<S2SV_blank>details"" , gf_error_to_string ( evt -> message . error ) ) ; } Run = 0 ; break ; case GF_EVENT_DISCONNECT : gf_term_disconnect ( term ) ; break ; case GF_EVENT_MIGRATE : { } break ; case GF_EVENT_NAVIGATE_INFO : if ( evt -> navigate . to_url ) fprintf ( stderr , ""Go<S2SV_blank>to<S2SV_blank>URL:<S2SV_blank>\\""%s\\""\\r"" , evt -> navigate . to_url ) ; break ; case GF_EVENT_NAVIGATE : if ( gf_term_is_supported_url ( term , evt -> navigate . to_url , 1 , no_mime_check ) ) { <S2SV_StartBug> strcpy ( the_url , evt -> navigate . to_url ) ; <S2SV_EndBug> fprintf ( stderr , ""Navigating<S2SV_blank>to<S2SV_blank>URL<S2SV_blank>%s\\n"" , the_url ) ; gf_term_navigate_to ( term , evt -> navigate . to_url ) ; return 1 ; } else { fprintf ( stderr , ""Navigation<S2SV_blank>destination<S2SV_blank>not<S2SV_blank>supported\\nGo<S2SV_blank>to<S2SV_blank>URL:<S2SV_blank>%s\\n"" , evt -> navigate . to_url ) ; } break ; case GF_EVENT_SET_CAPTION : gf_term_user_event ( term , evt ) ; break ; case GF_EVENT_AUTHORIZATION : { int maxTries = 1 ; assert ( evt -> type == GF_EVENT_AUTHORIZATION ) ; assert ( evt -> auth . user ) ; assert ( evt -> auth . password ) ; assert ( evt -> auth . site_url ) ; while ( ( ! strlen ( evt -> auth . user ) || ! strlen ( evt -> auth . password ) ) && ( maxTries -- ) >= 0 ) { fprintf ( stderr , ""****<S2SV_blank>Authorization<S2SV_blank>required<S2SV_blank>for<S2SV_blank>site<S2SV_blank>%s<S2SV_blank>****\\n"" , evt -> auth . site_url ) ; fprintf ( stderr , ""login<S2SV_blank><S2SV_blank><S2SV_blank>:<S2SV_blank>"" ) ; read_line_input ( evt -> auth . user , 50 , 1 ) ; fprintf ( stderr , ""\\npassword:<S2SV_blank>"" ) ; read_line_input ( evt -> auth . password , 50 , 0 ) ; fprintf ( stderr , ""*********\\n"" ) ; } if ( maxTries < 0 ) { fprintf ( stderr , ""****<S2SV_blank>No<S2SV_blank>User<S2SV_blank>or<S2SV_blank>password<S2SV_blank>has<S2SV_blank>been<S2SV_blank>filled,<S2SV_blank>aborting<S2SV_blank>***\\n"" ) ; return 0 ; } return 1 ; } case GF_EVENT_ADDON_DETECTED : if ( enable_add_ons ) { fprintf ( stderr , ""Media<S2SV_blank>Addon<S2SV_blank>%s<S2SV_blank>detected<S2SV_blank>-<S2SV_blank>enabling<S2SV_blank>it\\n"" , evt -> addon_connect . addon_url ) ; addon_visible = 1 ; } return enable_add_ons ; } return 0 ; }
","<S2SV_ModStart> ) ) { strncpy <S2SV_ModEnd> ( the_url , <S2SV_ModStart> navigate . to_url , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_url ) - 1 ] = 0 <S2SV_ModEnd> ; fprintf (
"
332,"CWE-704 static void n_tty_set_termios ( struct tty_struct * tty , struct ktermios * old ) { struct n_tty_data * ldata = tty -> disc_data ; <S2SV_StartBug> if ( ! old || ( old -> c_lflag ^ tty -> termios . c_lflag ) & ICANON ) { <S2SV_EndBug> bitmap_zero ( ldata -> read_flags , N_TTY_BUF_SIZE ) ; ldata -> line_start = ldata -> read_tail ; if ( ! L_ICANON ( tty ) || ! read_cnt ( ldata ) ) { ldata -> canon_head = ldata -> read_tail ; ldata -> push = 0 ; } else { set_bit ( ( ldata -> read_head - 1 ) & ( N_TTY_BUF_SIZE - 1 ) , ldata -> read_flags ) ; ldata -> canon_head = ldata -> read_head ; ldata -> push = 1 ; } ldata -> commit_head = ldata -> read_head ; ldata -> erasing = 0 ; ldata -> lnext = 0 ; } ldata -> icanon = ( L_ICANON ( tty ) != 0 ) ; if ( I_ISTRIP ( tty ) || I_IUCLC ( tty ) || I_IGNCR ( tty ) || I_ICRNL ( tty ) || I_INLCR ( tty ) || L_ICANON ( tty ) || I_IXON ( tty ) || L_ISIG ( tty ) || L_ECHO ( tty ) || I_PARMRK ( tty ) ) { bitmap_zero ( ldata -> char_map , 256 ) ; if ( I_IGNCR ( tty ) || I_ICRNL ( tty ) ) set_bit ( '\\r' , ldata -> char_map ) ; if ( I_INLCR ( tty ) ) set_bit ( '\\n' , ldata -> char_map ) ; if ( L_ICANON ( tty ) ) { set_bit ( ERASE_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( KILL_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( EOF_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( '\\n' , ldata -> char_map ) ; set_bit ( EOL_CHAR ( tty ) , ldata -> char_map ) ; if ( L_IEXTEN ( tty ) ) { set_bit ( WERASE_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( LNEXT_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( EOL2_CHAR ( tty ) , ldata -> char_map ) ; if ( L_ECHO ( tty ) ) set_bit ( REPRINT_CHAR ( tty ) , ldata -> char_map ) ; } } if ( I_IXON ( tty ) ) { set_bit ( START_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( STOP_CHAR ( tty ) , ldata -> char_map ) ; } if ( L_ISIG ( tty ) ) { set_bit ( INTR_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( QUIT_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( SUSP_CHAR ( tty ) , ldata -> char_map ) ; } clear_bit ( __DISABLED_CHAR , ldata -> char_map ) ; ldata -> raw = 0 ; ldata -> real_raw = 0 ; } else { ldata -> raw = 1 ; if ( ( I_IGNBRK ( tty ) || ( ! I_BRKINT ( tty ) && ! I_PARMRK ( tty ) ) ) && ( I_IGNPAR ( tty ) || ! I_INPCK ( tty ) ) && ( tty -> driver -> flags & TTY_DRIVER_REAL_RAW ) ) ldata -> real_raw = 1 ; else ldata -> real_raw = 0 ; } if ( ! I_IXON ( tty ) && old && ( old -> c_iflag & IXON ) && ! tty -> flow_stopped ) { start_tty ( tty ) ; process_echoes ( tty ) ; } wake_up_interruptible ( & tty -> write_wait ) ; wake_up_interruptible ( & tty -> read_wait ) ; }
","<S2SV_ModStart> c_lflag ) & ( ICANON | EXTPROC ) <S2SV_ModEnd> ) { bitmap_zero
"
333,"CWE-285 static int __jfs_set_acl ( tid_t tid , struct inode * inode , int type , struct posix_acl * acl ) { char * ea_name ; int rc ; int size = 0 ; char * value = NULL ; switch ( type ) { case ACL_TYPE_ACCESS : ea_name = XATTR_NAME_POSIX_ACL_ACCESS ; if ( acl ) { <S2SV_StartBug> rc = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> if ( rc < 0 ) <S2SV_StartBug> return rc ; <S2SV_EndBug> inode -> i_ctime = CURRENT_TIME ; mark_inode_dirty ( inode ) ; if ( rc == 0 ) acl = NULL ; } break ; case ACL_TYPE_DEFAULT : ea_name = XATTR_NAME_POSIX_ACL_DEFAULT ; break ; default : return - EINVAL ; } if ( acl ) { size = posix_acl_xattr_size ( acl -> a_count ) ; value = kmalloc ( size , GFP_KERNEL ) ; if ( ! value ) return - ENOMEM ; rc = posix_acl_to_xattr ( & init_user_ns , acl , value , size ) ; if ( rc < 0 ) goto out ; } rc = __jfs_setxattr ( tid , inode , ea_name , value , size , 0 ) ; out : kfree ( value ) ; if ( ! rc ) set_cached_acl ( inode , type , acl ) ; return rc ; }
","<S2SV_ModStart> { rc = posix_acl_update_mode ( inode <S2SV_ModEnd> , & inode <S2SV_ModStart> inode -> i_mode , & acl ) ; if ( rc ) return rc ; inode -> i_ctime = CURRENT_TIME ; mark_inode_dirty ( inode ) ; } break ; case ACL_TYPE_DEFAULT : ea_name = XATTR_NAME_POSIX_ACL_DEFAULT ; break ; default : return - EINVAL ; } if ( acl ) { size = posix_acl_xattr_size ( acl -> a_count ) ; value = kmalloc ( size , GFP_KERNEL ) ; if ( ! value ) return - ENOMEM ; rc = posix_acl_to_xattr ( & init_user_ns , acl , value , size <S2SV_ModStart> < 0 ) <S2SV_ModEnd> goto out ;
"
334,"CWE-20 NORET_TYPE void do_exit ( long code ) { struct task_struct * tsk = current ; int group_dead ; profile_task_exit ( tsk ) ; WARN_ON ( atomic_read ( & tsk -> fs_excl ) ) ; if ( unlikely ( in_interrupt ( ) ) ) panic ( ""Aiee,<S2SV_blank>killing<S2SV_blank>interrupt<S2SV_blank>handler!"" ) ; if ( unlikely ( ! tsk -> pid ) ) panic ( ""Attempted<S2SV_blank>to<S2SV_blank>kill<S2SV_blank>the<S2SV_blank>idle<S2SV_blank>task!"" ) ; tracehook_report_exit ( & code ) ; validate_creds_for_do_exit ( tsk ) ; if ( unlikely ( tsk -> flags & PF_EXITING ) ) { printk ( KERN_ALERT ""Fixing<S2SV_blank>recursive<S2SV_blank>fault<S2SV_blank>but<S2SV_blank>reboot<S2SV_blank>is<S2SV_blank>needed!\\n"" ) ; tsk -> flags |= PF_EXITPIDONE ; set_current_state ( TASK_UNINTERRUPTIBLE ) ; schedule ( ) ; } exit_irq_thread ( ) ; exit_signals ( tsk ) ; smp_mb ( ) ; spin_unlock_wait ( & tsk -> pi_lock ) ; if ( unlikely ( in_atomic ( ) ) ) printk ( KERN_INFO ""note:<S2SV_blank>%s[%d]<S2SV_blank>exited<S2SV_blank>with<S2SV_blank>preempt_count<S2SV_blank>%d\\n"" , current -> comm , task_pid_nr ( current ) , preempt_count ( ) ) ; acct_update_integrals ( tsk ) ; group_dead = atomic_dec_and_test ( & tsk -> signal -> live ) ; if ( group_dead ) { hrtimer_cancel ( & tsk -> signal -> real_timer ) ; exit_itimers ( tsk -> signal ) ; if ( tsk -> mm ) setmax_mm_hiwater_rss ( & tsk -> signal -> maxrss , tsk -> mm ) ; } acct_collect ( code , group_dead ) ; if ( group_dead ) tty_audit_exit ( ) ; if ( unlikely ( tsk -> audit_context ) ) audit_free ( tsk ) ; tsk -> exit_code = code ; taskstats_exit ( tsk , group_dead ) ; exit_mm ( tsk ) ; if ( group_dead ) acct_process ( ) ; trace_sched_process_exit ( tsk ) ; exit_sem ( tsk ) ; exit_files ( tsk ) ; exit_fs ( tsk ) ; check_stack_usage ( ) ; exit_thread ( ) ; cgroup_exit ( tsk , 1 ) ; if ( group_dead && tsk -> signal -> leader ) disassociate_ctty ( 1 ) ; module_put ( task_thread_info ( tsk ) -> exec_domain -> module ) ; proc_exit_connector ( tsk ) ; perf_event_exit_task ( tsk ) ; exit_notify ( tsk , group_dead ) ; # ifdef CONFIG_NUMA mpol_put ( tsk -> mempolicy ) ; tsk -> mempolicy = NULL ; # endif # ifdef CONFIG_FUTEX if ( unlikely ( current -> pi_state_cache ) ) kfree ( current -> pi_state_cache ) ; # endif debug_check_no_locks_held ( tsk ) ; tsk -> flags |= PF_EXITPIDONE ; if ( tsk -> io_context ) <S2SV_StartBug> exit_io_context ( ) ; <S2SV_EndBug> if ( tsk -> splice_pipe ) __free_pipe_info ( tsk -> splice_pipe ) ; validate_creds_for_do_exit ( tsk ) ; preempt_disable ( ) ; exit_rcu ( ) ; tsk -> state = TASK_DEAD ; schedule ( ) ; BUG ( ) ; for ( ; ; ) cpu_relax ( ) ; }
","<S2SV_ModStart> ) exit_io_context ( tsk
"
335,"CWE-000 int iwch_cxgb3_ofld_send ( struct t3cdev * tdev , struct sk_buff * skb ) { int error = 0 ; struct cxio_rdev * rdev ; rdev = ( struct cxio_rdev * ) tdev -> ulp ; if ( cxio_fatal_error ( rdev ) ) { kfree_skb ( skb ) ; return - EIO ; } error = cxgb3_ofld_send ( tdev , skb ) ; if ( error < 0 ) kfree_skb ( skb ) ; <S2SV_StartBug> return error ; <S2SV_EndBug> }
","<S2SV_ModStart> ; return error < 0 ? error : 0
"
336,"CWE-834 static int asf_read_marker ( AVFormatContext * s , int64_t size ) { AVIOContext * pb = s -> pb ; ASFContext * asf = s -> priv_data ; int i , count , name_len , ret ; char name [ 1024 ] ; avio_rl64 ( pb ) ; avio_rl64 ( pb ) ; count = avio_rl32 ( pb ) ; avio_rl16 ( pb ) ; name_len = avio_rl16 ( pb ) ; <S2SV_StartBug> for ( i = 0 ; i < name_len ; i ++ ) <S2SV_EndBug> avio_r8 ( pb ) ; for ( i = 0 ; i < count ; i ++ ) { int64_t pres_time ; <S2SV_StartBug> int name_len ; <S2SV_EndBug> avio_rl64 ( pb ) ; pres_time = avio_rl64 ( pb ) ; pres_time -= asf -> hdr . preroll * 10000 ; avio_rl16 ( pb ) ; avio_rl32 ( pb ) ; avio_rl32 ( pb ) ; name_len = avio_rl32 ( pb ) ; if ( ( ret = avio_get_str16le ( pb , name_len * 2 , name , sizeof ( name ) ) ) < name_len ) avio_skip ( pb , name_len - ret ) ; avpriv_new_chapter ( s , i , ( AVRational ) { 1 , 10000000 } , pres_time , AV_NOPTS_VALUE , name ) ; } return 0 ; }
","<S2SV_ModStart> pb ) ; avio_skip ( pb , name_len <S2SV_ModEnd> ) ; for <S2SV_ModStart> ; int name_len ; if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA
"
337,"CWE-787 static OPJ_BOOL opj_t2_encode_packet ( OPJ_UINT32 tileno , opj_tcd_tile_t * tile , opj_tcp_t * tcp , opj_pi_iterator_t * pi , OPJ_BYTE * dest , OPJ_UINT32 * p_data_written , OPJ_UINT32 length , opj_codestream_info_t * cstr_info , J2K_T2_MODE p_t2_mode , opj_event_mgr_t * p_manager ) { OPJ_UINT32 bandno , cblkno ; OPJ_BYTE * c = dest ; OPJ_UINT32 l_nb_bytes ; OPJ_UINT32 compno = pi -> compno ; OPJ_UINT32 resno = pi -> resno ; OPJ_UINT32 precno = pi -> precno ; OPJ_UINT32 layno = pi -> layno ; OPJ_UINT32 l_nb_blocks ; opj_tcd_band_t * band = 00 ; opj_tcd_cblk_enc_t * cblk = 00 ; opj_tcd_pass_t * pass = 00 ; opj_tcd_tilecomp_t * tilec = & tile -> comps [ compno ] ; opj_tcd_resolution_t * res = & tilec -> resolutions [ resno ] ; opj_bio_t * bio = 00 ; OPJ_BOOL packet_empty = OPJ_TRUE ; <S2SV_StartBug> if ( tcp -> csty & J2K_CP_CSTY_SOP ) { <S2SV_EndBug> c [ 0 ] = 255 ; c [ 1 ] = 145 ; c [ 2 ] = 0 ; c [ 3 ] = 4 ; # if 0 c [ 4 ] = ( tile -> packno % 65536 ) / 256 ; c [ 5 ] = ( tile -> packno % 65536 ) % 256 ; # else c [ 4 ] = ( tile -> packno >> 8 ) & 0xff ; c [ 5 ] = tile -> packno & 0xff ; # endif c += 6 ; length -= 6 ; } if ( ! layno ) { band = res -> bands ; for ( bandno = 0 ; bandno < res -> numbands ; ++ bandno , ++ band ) { opj_tcd_precinct_t * prc ; if ( opj_tcd_is_band_empty ( band ) ) { continue ; } prc = & band -> precincts [ precno ] ; opj_tgt_reset ( prc -> incltree ) ; opj_tgt_reset ( prc -> imsbtree ) ; l_nb_blocks = prc -> cw * prc -> ch ; for ( cblkno = 0 ; cblkno < l_nb_blocks ; ++ cblkno ) { cblk = & prc -> cblks . enc [ cblkno ] ; cblk -> numpasses = 0 ; opj_tgt_setvalue ( prc -> imsbtree , cblkno , band -> numbps - ( OPJ_INT32 ) cblk -> numbps ) ; } } } bio = opj_bio_create ( ) ; if ( ! bio ) { return OPJ_FALSE ; } opj_bio_init_enc ( bio , c , length ) ; band = res -> bands ; for ( bandno = 0 ; bandno < res -> numbands ; ++ bandno , ++ band ) { opj_tcd_precinct_t * prc ; if ( opj_tcd_is_band_empty ( band ) ) { continue ; } prc = & band -> precincts [ precno ] ; l_nb_blocks = prc -> cw * prc -> ch ; cblk = prc -> cblks . enc ; for ( cblkno = 0 ; cblkno < l_nb_blocks ; cblkno ++ , ++ cblk ) { opj_tcd_layer_t * layer = & cblk -> layers [ layno ] ; if ( ! layer -> numpasses ) { continue ; } packet_empty = OPJ_FALSE ; break ; } if ( ! packet_empty ) { break ; } } opj_bio_write ( bio , packet_empty ? 0 : 1 , 1 ) ; band = res -> bands ; for ( bandno = 0 ; ! packet_empty && bandno < res -> numbands ; ++ bandno , ++ band ) { opj_tcd_precinct_t * prc ; if ( opj_tcd_is_band_empty ( band ) ) { continue ; } prc = & band -> precincts [ precno ] ; l_nb_blocks = prc -> cw * prc -> ch ; cblk = prc -> cblks . enc ; for ( cblkno = 0 ; cblkno < l_nb_blocks ; ++ cblkno ) { opj_tcd_layer_t * layer = & cblk -> layers [ layno ] ; if ( ! cblk -> numpasses && layer -> numpasses ) { opj_tgt_setvalue ( prc -> incltree , cblkno , ( OPJ_INT32 ) layno ) ; } ++ cblk ; } cblk = prc -> cblks . enc ; for ( cblkno = 0 ; cblkno < l_nb_blocks ; cblkno ++ ) { opj_tcd_layer_t * layer = & cblk -> layers [ layno ] ; OPJ_UINT32 increment = 0 ; OPJ_UINT32 nump = 0 ; OPJ_UINT32 len = 0 , passno ; OPJ_UINT32 l_nb_passes ; if ( ! cblk -> numpasses ) { opj_tgt_encode ( bio , prc -> incltree , cblkno , ( OPJ_INT32 ) ( layno + 1 ) ) ; } else { opj_bio_write ( bio , layer -> numpasses != 0 , 1 ) ; } if ( ! layer -> numpasses ) { ++ cblk ; continue ; } if ( ! cblk -> numpasses ) { cblk -> numlenbits = 3 ; opj_tgt_encode ( bio , prc -> imsbtree , cblkno , 999 ) ; } opj_t2_putnumpasses ( bio , layer -> numpasses ) ; l_nb_passes = cblk -> numpasses + layer -> numpasses ; pass = cblk -> passes + cblk -> numpasses ; for ( passno = cblk -> numpasses ; passno < l_nb_passes ; ++ passno ) { ++ nump ; len += pass -> len ; if ( pass -> term || passno == ( cblk -> numpasses + layer -> numpasses ) - 1 ) { increment = ( OPJ_UINT32 ) opj_int_max ( ( OPJ_INT32 ) increment , opj_int_floorlog2 ( ( OPJ_INT32 ) len ) + 1 - ( ( OPJ_INT32 ) cblk -> numlenbits + opj_int_floorlog2 ( ( OPJ_INT32 ) nump ) ) ) ; len = 0 ; nump = 0 ; } ++ pass ; } opj_t2_putcommacode ( bio , ( OPJ_INT32 ) increment ) ; cblk -> numlenbits += increment ; pass = cblk -> passes + cblk -> numpasses ; for ( passno = cblk -> numpasses ; passno < l_nb_passes ; ++ passno ) { nump ++ ; len += pass -> len ; if ( pass -> term || passno == ( cblk -> numpasses + layer -> numpasses ) - 1 ) { opj_bio_write ( bio , ( OPJ_UINT32 ) len , cblk -> numlenbits + ( OPJ_UINT32 ) opj_int_floorlog2 ( ( OPJ_INT32 ) nump ) ) ; len = 0 ; nump = 0 ; } ++ pass ; } ++ cblk ; } } if ( ! opj_bio_flush ( bio ) ) { opj_bio_destroy ( bio ) ; return OPJ_FALSE ; } l_nb_bytes = ( OPJ_UINT32 ) opj_bio_numbytes ( bio ) ; c += l_nb_bytes ; length -= l_nb_bytes ; opj_bio_destroy ( bio ) ; <S2SV_StartBug> if ( tcp -> csty & J2K_CP_CSTY_EPH ) { <S2SV_EndBug> c [ 0 ] = 255 ; c [ 1 ] = 146 ; c += 2 ; length -= 2 ; } if ( cstr_info && cstr_info -> index_write ) { opj_packet_info_t * info_PK = & cstr_info -> tile [ tileno ] . packet [ cstr_info -> packno ] ; info_PK -> end_ph_pos = ( OPJ_INT32 ) ( c - dest ) ; } band = res -> bands ; for ( bandno = 0 ; ! packet_empty && bandno < res -> numbands ; bandno ++ , ++ band ) { opj_tcd_precinct_t * prc ; if ( opj_tcd_is_band_empty ( band ) ) { continue ; } prc = & band -> precincts [ precno ] ; l_nb_blocks = prc -> cw * prc -> ch ; cblk = prc -> cblks . enc ; for ( cblkno = 0 ; cblkno < l_nb_blocks ; ++ cblkno ) { opj_tcd_layer_t * layer = & cblk -> layers [ layno ] ; if ( ! layer -> numpasses ) { ++ cblk ; continue ; } if ( layer -> len > length ) { if ( p_t2_mode == FINAL_PASS ) { opj_event_msg ( p_manager , EVT_ERROR , ""opj_t2_encode_packet():<S2SV_blank>only<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>remaining<S2SV_blank>in<S2SV_blank>"" ""output<S2SV_blank>buffer.<S2SV_blank>%u<S2SV_blank>needed.\\n"" , length , layer -> len ) ; } return OPJ_FALSE ; } memcpy ( c , layer -> data , layer -> len ) ; cblk -> numpasses += layer -> numpasses ; c += layer -> len ; length -= layer -> len ; if ( cstr_info && cstr_info -> index_write ) { opj_packet_info_t * info_PK = & cstr_info -> tile [ tileno ] . packet [ cstr_info -> packno ] ; info_PK -> disto += layer -> disto ; if ( cstr_info -> D_max < info_PK -> disto ) { cstr_info -> D_max = info_PK -> disto ; } } ++ cblk ; } } assert ( c >= dest ) ; * p_data_written += ( OPJ_UINT32 ) ( c - dest ) ; return OPJ_TRUE ; }
","<S2SV_ModStart> J2K_CP_CSTY_SOP ) { if ( length < 6 ) { if ( p_t2_mode == FINAL_PASS ) { opj_event_msg ( p_manager , EVT_ERROR , ""opj_t2_encode_packet():<S2SV_blank>only<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>remaining<S2SV_blank>in<S2SV_blank>"" ""output<S2SV_blank>buffer.<S2SV_blank>%u<S2SV_blank>needed.\\n"" , length , 6 ) ; } return OPJ_FALSE ; } <S2SV_ModStart> J2K_CP_CSTY_EPH ) { if ( length < 2 ) { if ( p_t2_mode == FINAL_PASS ) { opj_event_msg ( p_manager , EVT_ERROR , ""opj_t2_encode_packet():<S2SV_blank>only<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>remaining<S2SV_blank>in<S2SV_blank>"" ""output<S2SV_blank>buffer.<S2SV_blank>%u<S2SV_blank>needed.\\n"" , length , 2 ) ; } return OPJ_FALSE ; }
"
338,"CWE-119 <S2SV_StartBug> static inline bool unconditional ( const struct ipt_ip * ip ) <S2SV_EndBug> { static const struct ipt_ip uncond ; <S2SV_StartBug> return memcmp ( ip , & uncond , sizeof ( uncond ) ) == 0 ; <S2SV_EndBug> # undef FWINV }
","<S2SV_ModStart> ( const struct ipt_entry * e <S2SV_ModEnd> ) { static <S2SV_ModStart> uncond ; return e -> target_offset == sizeof ( struct ipt_entry ) && memcmp ( & e -> <S2SV_ModEnd> ip , &
"
339,"CWE-125 int libevt_record_values_read_event ( libevt_record_values_t * record_values , uint8_t * record_data , size_t record_data_size , uint8_t strict_mode , libcerror_error_t * * error ) { static char * function = ""libevt_record_values_read_event"" ; size_t record_data_offset = 0 ; size_t strings_data_offset = 0 ; ssize_t value_data_size = 0 ; uint32_t data_offset = 0 ; uint32_t data_size = 0 ; uint32_t members_data_size = 0 ; uint32_t size = 0 ; uint32_t size_copy = 0 ; uint32_t strings_offset = 0 ; uint32_t strings_size = 0 ; uint32_t user_sid_offset = 0 ; uint32_t user_sid_size = 0 ; # if defined ( HAVE_DEBUG_OUTPUT ) uint32_t value_32bit = 0 ; uint16_t value_16bit = 0 ; # endif if ( record_values == NULL ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_ARGUMENTS , LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE , ""%s:<S2SV_blank>invalid<S2SV_blank>record<S2SV_blank>values."" , function ) ; return ( - 1 ) ; } if ( record_data == NULL ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_ARGUMENTS , LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE , ""%s:<S2SV_blank>invalid<S2SV_blank>record<S2SV_blank>data."" , function ) ; return ( - 1 ) ; } if ( record_data_size > ( size_t ) SSIZE_MAX ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_ARGUMENTS , LIBCERROR_ARGUMENT_ERROR_VALUE_EXCEEDS_MAXIMUM , ""%s:<S2SV_blank>invalid<S2SV_blank>record<S2SV_blank>data<S2SV_blank>size<S2SV_blank>value<S2SV_blank>exceeds<S2SV_blank>maximum."" , function ) ; return ( - 1 ) ; } if ( record_data_size < ( sizeof ( evt_record_event_header_t ) + 4 ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>record<S2SV_blank>data<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; return ( - 1 ) ; } byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> size , size ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> record_number , record_values -> number ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> creation_time , record_values -> creation_time ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> written_time , record_values -> written_time ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> event_identifier , record_values -> event_identifier ) ; byte_stream_copy_to_uint16_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> event_type , record_values -> event_type ) ; byte_stream_copy_to_uint16_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> event_category , record_values -> event_category ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> strings_offset , strings_offset ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> user_sid_size , user_sid_size ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> user_sid_offset , user_sid_offset ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> data_size , data_size ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> data_offset , data_offset ) ; byte_stream_copy_to_uint32_little_endian ( & ( record_data [ record_data_size - 4 ] ) , size_copy ) ; # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) { libcnotify_printf ( ""%s:<S2SV_blank>size\\t\\t\\t\\t\\t:<S2SV_blank>%"" PRIu32 ""\\n"" , function , size ) ; libcnotify_printf ( ""%s:<S2SV_blank>signature\\t\\t\\t\\t:<S2SV_blank>%c%c%c%c\\n"" , function , ( ( evt_record_event_header_t * ) record_data ) -> signature [ 0 ] , ( ( evt_record_event_header_t * ) record_data ) -> signature [ 1 ] , ( ( evt_record_event_header_t * ) record_data ) -> signature [ 2 ] , ( ( evt_record_event_header_t * ) record_data ) -> signature [ 3 ] ) ; libcnotify_printf ( ""%s:<S2SV_blank>record<S2SV_blank>number\\t\\t\\t\\t:<S2SV_blank>%"" PRIu32 ""\\n"" , function , record_values -> number ) ; if ( libevt_debug_print_posix_time_value ( function , ""creation<S2SV_blank>time\\t\\t\\t\\t"" , ( ( evt_record_event_header_t * ) record_data ) -> creation_time , 4 , LIBFDATETIME_ENDIAN_LITTLE , LIBFDATETIME_POSIX_TIME_VALUE_TYPE_SECONDS_32BIT_SIGNED , LIBFDATETIME_STRING_FORMAT_TYPE_CTIME | LIBFDATETIME_STRING_FORMAT_FLAG_DATE_TIME , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_PRINT_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>print<S2SV_blank>POSIX<S2SV_blank>time<S2SV_blank>value."" , function ) ; goto on_error ; } if ( libevt_debug_print_posix_time_value ( function , ""written<S2SV_blank>time\\t\\t\\t\\t"" , ( ( evt_record_event_header_t * ) record_data ) -> written_time , 4 , LIBFDATETIME_ENDIAN_LITTLE , LIBFDATETIME_POSIX_TIME_VALUE_TYPE_SECONDS_32BIT_SIGNED , LIBFDATETIME_STRING_FORMAT_TYPE_CTIME | LIBFDATETIME_STRING_FORMAT_FLAG_DATE_TIME , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_PRINT_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>print<S2SV_blank>POSIX<S2SV_blank>time<S2SV_blank>value."" , function ) ; goto on_error ; } libcnotify_printf ( ""%s:<S2SV_blank>event<S2SV_blank>identifier\\t\\t\\t:<S2SV_blank>0x%08"" PRIx32 ""\\n"" , function , record_values -> event_identifier ) ; libcnotify_printf ( ""%s:<S2SV_blank>event<S2SV_blank>identifier:<S2SV_blank>code\\t\\t\\t:<S2SV_blank>%"" PRIu32 ""\\n"" , function , record_values -> event_identifier & 0x0000ffffUL ) ; libcnotify_printf ( ""%s:<S2SV_blank>event<S2SV_blank>identifier:<S2SV_blank>facility\\t\\t:<S2SV_blank>%"" PRIu32 ""\\n"" , function , ( record_values -> event_identifier & 0x0fff0000UL ) >> 16 ) ; libcnotify_printf ( ""%s:<S2SV_blank>event<S2SV_blank>identifier:<S2SV_blank>reserved\\t\\t:<S2SV_blank>%"" PRIu32 ""\\n"" , function , ( record_values -> event_identifier & 0x10000000UL ) >> 28 ) ; libcnotify_printf ( ""%s:<S2SV_blank>event<S2SV_blank>identifier:<S2SV_blank>customer<S2SV_blank>flags\\t:<S2SV_blank>%"" PRIu32 ""\\n"" , function , ( record_values -> event_identifier & 0x20000000UL ) >> 29 ) ; libcnotify_printf ( ""%s:<S2SV_blank>event<S2SV_blank>identifier:<S2SV_blank>severity\\t\\t:<S2SV_blank>%"" PRIu32 ""<S2SV_blank>("" , function , ( record_values -> event_identifier & 0xc0000000UL ) >> 30 ) ; libevt_debug_print_event_identifier_severity ( record_values -> event_identifier ) ; libcnotify_printf ( "")\\n"" ) ; libcnotify_printf ( ""%s:<S2SV_blank>event<S2SV_blank>type\\t\\t\\t\\t:<S2SV_blank>%"" PRIu16 ""<S2SV_blank>("" , function , record_values -> event_type ) ; libevt_debug_print_event_type ( record_values -> event_type ) ; libcnotify_printf ( "")\\n"" ) ; byte_stream_copy_to_uint16_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> number_of_strings , value_16bit ) ; libcnotify_printf ( ""%s:<S2SV_blank>number<S2SV_blank>of<S2SV_blank>strings\\t\\t\\t:<S2SV_blank>%"" PRIu16 ""\\n"" , function , value_16bit ) ; libcnotify_printf ( ""%s:<S2SV_blank>event<S2SV_blank>category\\t\\t\\t\\t:<S2SV_blank>%"" PRIu16 ""\\n"" , function , record_values -> event_category ) ; byte_stream_copy_to_uint16_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> event_flags , value_16bit ) ; libcnotify_printf ( ""%s:<S2SV_blank>event<S2SV_blank>flags\\t\\t\\t\\t:<S2SV_blank>0x%04"" PRIx16 ""\\n"" , function , value_16bit ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> closing_record_number , value_32bit ) ; libcnotify_printf ( ""%s:<S2SV_blank>closing<S2SV_blank>record<S2SV_blank>values<S2SV_blank>number\\t\\t:<S2SV_blank>%"" PRIu32 ""\\n"" , function , value_32bit ) ; libcnotify_printf ( ""%s:<S2SV_blank>strings<S2SV_blank>offset\\t\\t\\t\\t:<S2SV_blank>%"" PRIu32 ""\\n"" , function , strings_offset ) ; libcnotify_printf ( ""%s:<S2SV_blank>user<S2SV_blank>security<S2SV_blank>identifier<S2SV_blank>(SID)<S2SV_blank>size\\t:<S2SV_blank>%"" PRIu32 ""\\n"" , function , user_sid_size ) ; libcnotify_printf ( ""%s:<S2SV_blank>user<S2SV_blank>security<S2SV_blank>identifier<S2SV_blank>(SID)<S2SV_blank>offset\\t:<S2SV_blank>%"" PRIu32 ""\\n"" , function , user_sid_offset ) ; libcnotify_printf ( ""%s:<S2SV_blank>data<S2SV_blank>size\\t\\t\\t\\t:<S2SV_blank>%"" PRIu32 ""\\n"" , function , data_size ) ; libcnotify_printf ( ""%s:<S2SV_blank>data<S2SV_blank>offset\\t\\t\\t\\t:<S2SV_blank>%"" PRIu32 ""\\n"" , function , data_offset ) ; } # endif record_data_offset = sizeof ( evt_record_event_header_t ) ; if ( ( user_sid_offset == 0 ) && ( user_sid_size != 0 ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>user<S2SV_blank>SID<S2SV_blank>offset<S2SV_blank>or<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } if ( user_sid_offset != 0 ) { if ( ( ( size_t ) user_sid_offset < record_data_offset ) || ( ( size_t ) user_sid_offset >= ( record_data_size - 4 ) ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>user<S2SV_blank>SID<S2SV_blank>offset<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } if ( user_sid_size != 0 ) { if ( ( size_t ) ( user_sid_offset + user_sid_size ) > ( record_data_size - 4 ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>user<S2SV_blank>SID<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } } } if ( ( ( size_t ) strings_offset < user_sid_offset ) || ( ( size_t ) strings_offset >= ( record_data_size - 4 ) ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>strings<S2SV_blank>offset<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } if ( ( ( size_t ) data_offset < strings_offset ) || ( ( size_t ) data_offset >= ( record_data_size - 4 ) ) ) { if ( data_size != 0 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>data<S2SV_blank>offset<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } data_offset = ( uint32_t ) record_data_size - 4 ; } if ( ( ( size_t ) strings_offset >= ( record_data_size - 4 ) ) && ( strings_offset != data_offset ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>strings<S2SV_blank>offset<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } if ( strings_offset != 0 ) { if ( strings_offset < record_data_offset ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>strings<S2SV_blank>offset<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } } if ( user_sid_offset != 0 ) { members_data_size = user_sid_offset - ( uint32_t ) record_data_offset ; } else if ( strings_offset != 0 ) { members_data_size = strings_offset - ( uint32_t ) record_data_offset ; } if ( strings_offset != 0 ) { strings_size = data_offset - strings_offset ; } if ( data_size != 0 ) { if ( ( size_t ) ( data_offset + data_size ) > ( record_data_size - 4 ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>data<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } } if ( members_data_size != 0 ) { # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) { libcnotify_printf ( ""%s:<S2SV_blank>members<S2SV_blank>data:\\n"" , function ) ; libcnotify_print_data ( & ( record_data [ record_data_offset ] ) , members_data_size , LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA ) ; } # endif if ( libfvalue_value_type_initialize ( & ( record_values -> source_name ) , LIBFVALUE_VALUE_TYPE_STRING_UTF16 , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>source<S2SV_blank>name<S2SV_blank>value."" , function ) ; goto on_error ; } value_data_size = libfvalue_value_type_set_data_string ( record_values -> source_name , & ( record_data [ record_data_offset ] ) , members_data_size , LIBFVALUE_CODEPAGE_UTF16_LITTLE_ENDIAN , LIBFVALUE_VALUE_DATA_FLAG_MANAGED , error ) ; if ( value_data_size == - 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_SET_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>data<S2SV_blank>of<S2SV_blank>source<S2SV_blank>name<S2SV_blank>value."" , function ) ; goto on_error ; } # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) { libcnotify_printf ( ""%s:<S2SV_blank>source<S2SV_blank>name\\t\\t\\t\\t:<S2SV_blank>"" , function ) ; if ( libfvalue_value_print ( record_values -> source_name , 0 , 0 , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_PRINT_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>print<S2SV_blank>source<S2SV_blank>name<S2SV_blank>value."" , function ) ; goto on_error ; } libcnotify_printf ( ""\\n"" ) ; } # endif record_data_offset += value_data_size ; members_data_size -= ( uint32_t ) value_data_size ; if ( libfvalue_value_type_initialize ( & ( record_values -> computer_name ) , LIBFVALUE_VALUE_TYPE_STRING_UTF16 , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>computer<S2SV_blank>name<S2SV_blank>value."" , function ) ; goto on_error ; } value_data_size = libfvalue_value_type_set_data_string ( record_values -> computer_name , & ( record_data [ record_data_offset ] ) , members_data_size , LIBFVALUE_CODEPAGE_UTF16_LITTLE_ENDIAN , LIBFVALUE_VALUE_DATA_FLAG_MANAGED , error ) ; if ( value_data_size == - 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_SET_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>data<S2SV_blank>of<S2SV_blank>computer<S2SV_blank>name<S2SV_blank>value."" , function ) ; goto on_error ; } # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) { libcnotify_printf ( ""%s:<S2SV_blank>computer<S2SV_blank>name\\t\\t\\t\\t:<S2SV_blank>"" , function ) ; if ( libfvalue_value_print ( record_values -> computer_name , 0 , 0 , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_PRINT_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>print<S2SV_blank>computer<S2SV_blank>name<S2SV_blank>value."" , function ) ; goto on_error ; } libcnotify_printf ( ""\\n"" ) ; } # endif record_data_offset += value_data_size ; members_data_size -= ( uint32_t ) value_data_size ; if ( members_data_size > 0 ) { # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) { libcnotify_printf ( ""%s:<S2SV_blank>members<S2SV_blank>trailing<S2SV_blank>data:\\n"" , function ) ; libcnotify_print_data ( & ( record_data [ record_data_offset ] ) , members_data_size , LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA ) ; } # endif record_data_offset += members_data_size ; } } if ( user_sid_size != 0 ) { <S2SV_StartBug> if ( libfvalue_value_type_initialize ( <S2SV_EndBug> & ( record_values -> user_security_identifier ) , LIBFVALUE_VALUE_TYPE_NT_SECURITY_IDENTIFIER , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>user<S2SV_blank>security<S2SV_blank>identifier<S2SV_blank>(SID)<S2SV_blank>value."" , function ) ; goto on_error ; } if ( libfvalue_value_set_data ( record_values -> user_security_identifier , & ( record_data [ user_sid_offset ] ) , ( size_t ) user_sid_size , LIBFVALUE_ENDIAN_LITTLE , LIBFVALUE_VALUE_DATA_FLAG_MANAGED , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_SET_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>data<S2SV_blank>of<S2SV_blank>user<S2SV_blank>security<S2SV_blank>identifier<S2SV_blank>(SID)<S2SV_blank>value."" , function ) ; goto on_error ; } # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) { libcnotify_printf ( ""%s:<S2SV_blank>user<S2SV_blank>security<S2SV_blank>identifier<S2SV_blank>(SID)\\t\\t:<S2SV_blank>"" , function ) ; if ( libfvalue_value_print ( record_values -> user_security_identifier , 0 , 0 , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_PRINT_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>print<S2SV_blank>user<S2SV_blank>security<S2SV_blank>identifier<S2SV_blank>(SID)<S2SV_blank>value."" , function ) ; goto on_error ; } libcnotify_printf ( ""\\n"" ) ; } # endif record_data_offset += user_sid_size ; } if ( strings_size != 0 ) <S2SV_StartBug> { <S2SV_EndBug> # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) { libcnotify_printf ( ""%s:<S2SV_blank>strings<S2SV_blank>data:\\n"" , function ) ; libcnotify_print_data ( & ( record_data [ strings_offset ] ) , strings_size , LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA ) ; } # endif if ( size_copy == 0 ) { strings_data_offset = strings_offset + strings_size - 2 ; while ( strings_data_offset > strings_offset ) { if ( ( record_data [ strings_data_offset ] != 0 ) || ( record_data [ strings_data_offset + 1 ] != 0 ) ) { strings_size += 2 ; break ; } strings_data_offset -= 2 ; strings_size -= 2 ; } } if ( libfvalue_value_type_initialize ( & ( record_values -> strings ) , LIBFVALUE_VALUE_TYPE_STRING_UTF16 , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>strings<S2SV_blank>value."" , function ) ; goto on_error ; } value_data_size = libfvalue_value_type_set_data_strings_array ( record_values -> strings , & ( record_data [ strings_offset ] ) , strings_size , LIBFVALUE_CODEPAGE_UTF16_LITTLE_ENDIAN , error ) ; if ( value_data_size == - 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_SET_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>data<S2SV_blank>of<S2SV_blank>strings<S2SV_blank>value."" , function ) ; goto on_error ; } record_data_offset += strings_size ; } if ( data_size != 0 ) { <S2SV_StartBug> # if defined ( HAVE_DEBUG_OUTPUT ) <S2SV_EndBug> if ( libcnotify_verbose != 0 ) { libcnotify_printf ( ""%s:<S2SV_blank>data:\\n"" , function ) ; libcnotify_print_data ( <S2SV_StartBug> & ( record_data [ data_offset ] ) , <S2SV_EndBug> ( size_t ) data_size , LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA ) ; } # endif if ( libfvalue_value_type_initialize ( & ( record_values -> data ) , LIBFVALUE_VALUE_TYPE_BINARY_DATA , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>data<S2SV_blank>value."" , function ) ; goto on_error ; } if ( libfvalue_value_set_data ( record_values -> data , & ( record_data [ record_data_offset ] ) , ( size_t ) data_size , LIBFVALUE_ENDIAN_LITTLE , LIBFVALUE_VALUE_DATA_FLAG_MANAGED , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_SET_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>data<S2SV_blank>of<S2SV_blank>data<S2SV_blank>value."" , function ) ; goto on_error ; } # if defined ( HAVE_DEBUG_OUTPUT ) record_data_offset += data_size ; # endif } # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) { if ( record_data_offset < ( record_data_size - 4 ) ) { libcnotify_printf ( ""%s:<S2SV_blank>padding:\\n"" , function ) ; libcnotify_print_data ( & ( record_data [ record_data_offset ] ) , ( size_t ) record_data_size - record_data_offset - 4 , LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA ) ; } libcnotify_printf ( ""%s:<S2SV_blank>size<S2SV_blank>copy\\t\\t\\t\\t:<S2SV_blank>%"" PRIu32 ""\\n"" , function , size_copy ) ; libcnotify_printf ( ""\\n"" ) ; } # endif if ( ( strict_mode == 0 ) && ( size_copy == 0 ) ) { size_copy = size ; } if ( size != size_copy ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_INPUT , LIBCERROR_INPUT_ERROR_VALUE_MISMATCH , ""%s:<S2SV_blank>value<S2SV_blank>mismatch<S2SV_blank>for<S2SV_blank>size<S2SV_blank>and<S2SV_blank>size<S2SV_blank>copy."" , function ) ; goto on_error ; } if ( record_data_size != ( size_t ) size ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_INPUT , LIBCERROR_INPUT_ERROR_VALUE_MISMATCH , ""%s:<S2SV_blank>value<S2SV_blank>mismatch<S2SV_blank>for<S2SV_blank>record_values<S2SV_blank>data<S2SV_blank>size<S2SV_blank>and<S2SV_blank>size."" , function ) ; goto on_error ; } return ( 1 ) ; on_error : if ( record_values -> data != NULL ) { libfvalue_value_free ( & ( record_values -> data ) , NULL ) ; } if ( record_values -> strings != NULL ) { libfvalue_value_free ( & ( record_values -> strings ) , NULL ) ; } if ( record_values -> user_security_identifier != NULL ) { libfvalue_value_free ( & ( record_values -> user_security_identifier ) , NULL ) ; } if ( record_values -> computer_name != NULL ) { libfvalue_value_free ( & ( record_values -> computer_name ) , NULL ) ; } if ( record_values -> source_name != NULL ) { libfvalue_value_free ( & ( record_values -> source_name ) , NULL ) ; } return ( - 1 ) ; }
","<S2SV_ModStart> { if ( user_sid_size > ( ( record_data_size - 4 ) - user_sid_offset ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>user<S2SV_blank>SID<S2SV_blank>data<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } if ( <S2SV_ModStart> 0 ) { if ( strings_size > ( ( record_data_size - 4 ) - strings_offset ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>strings<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } <S2SV_ModStart> 0 ) { if ( data_size > ( ( record_data_size - 4 ) - data_offset ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>data<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } <S2SV_ModStart> ( record_data [ record_data_offset <S2SV_ModEnd> ] ) ,
"
340,"CWE-476 krb5_error_code _kdc_as_rep ( kdc_request_t r , krb5_data * reply , const char * from , struct sockaddr * from_addr , int datagram_reply ) { krb5_context context = r -> context ; krb5_kdc_configuration * config = r -> config ; KDC_REQ * req = & r -> req ; KDC_REQ_BODY * b = NULL ; AS_REP rep ; KDCOptions f ; krb5_enctype setype ; krb5_error_code ret = 0 ; Key * skey ; int found_pa = 0 ; int i , flags = HDB_F_FOR_AS_REQ ; METHOD_DATA error_method ; const PA_DATA * pa ; memset ( & rep , 0 , sizeof ( rep ) ) ; error_method . len = 0 ; error_method . val = NULL ; ret = _kdc_fast_unwrap_request ( r ) ; if ( ret ) { _kdc_r_log ( r , 0 , ""FAST<S2SV_blank>unwrap<S2SV_blank>request<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>failed:<S2SV_blank>%d"" , from , ret ) ; goto out ; } b = & req -> req_body ; f = b -> kdc_options ; if ( f . canonicalize ) flags |= HDB_F_CANON ; if ( b -> sname == NULL ) { ret = KRB5KRB_ERR_GENERIC ; _kdc_set_e_text ( r , ""No<S2SV_blank>server<S2SV_blank>in<S2SV_blank>request"" ) ; } else { ret = _krb5_principalname2krb5_principal ( context , & r -> server_princ , * ( b -> sname ) , b -> realm ) ; if ( ret == 0 ) ret = krb5_unparse_name ( context , r -> server_princ , & r -> server_name ) ; } if ( ret ) { kdc_log ( context , config , 0 , ""AS-REQ<S2SV_blank>malformed<S2SV_blank>server<S2SV_blank>name<S2SV_blank>from<S2SV_blank>%s"" , from ) ; goto out ; } if ( b -> cname == NULL ) { ret = KRB5KRB_ERR_GENERIC ; _kdc_set_e_text ( r , ""No<S2SV_blank>client<S2SV_blank>in<S2SV_blank>request"" ) ; } else { ret = _krb5_principalname2krb5_principal ( context , & r -> client_princ , * ( b -> cname ) , b -> realm ) ; if ( ret ) goto out ; ret = krb5_unparse_name ( context , r -> client_princ , & r -> client_name ) ; } if ( ret ) { kdc_log ( context , config , 0 , ""AS-REQ<S2SV_blank>malformed<S2SV_blank>client<S2SV_blank>name<S2SV_blank>from<S2SV_blank>%s"" , from ) ; goto out ; } kdc_log ( context , config , 0 , ""AS-REQ<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>%s"" , r -> client_name , from , r -> server_name ) ; if ( _kdc_is_anonymous ( context , r -> client_princ ) ) { if ( ! _kdc_is_anon_request ( b ) ) { kdc_log ( context , config , 0 , ""Anonymous<S2SV_blank>ticket<S2SV_blank>w/o<S2SV_blank>anonymous<S2SV_blank>flag"" ) ; ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; goto out ; } } else if ( _kdc_is_anon_request ( b ) ) { kdc_log ( context , config , 0 , ""Request<S2SV_blank>for<S2SV_blank>a<S2SV_blank>anonymous<S2SV_blank>ticket<S2SV_blank>with<S2SV_blank>non<S2SV_blank>"" ""anonymous<S2SV_blank>client<S2SV_blank>name:<S2SV_blank>%s"" , r -> client_name ) ; ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; goto out ; } ret = _kdc_db_fetch ( context , config , r -> client_princ , HDB_F_GET_CLIENT | flags , NULL , & r -> clientdb , & r -> client ) ; if ( ret == HDB_ERR_NOT_FOUND_HERE ) { kdc_log ( context , config , 5 , ""client<S2SV_blank>%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>secrets<S2SV_blank>at<S2SV_blank>this<S2SV_blank>KDC,<S2SV_blank>need<S2SV_blank>to<S2SV_blank>proxy"" , r -> client_name ) ; goto out ; } else if ( ret == HDB_ERR_WRONG_REALM ) { char * fixed_client_name = NULL ; ret = krb5_unparse_name ( context , r -> client -> entry . principal , & fixed_client_name ) ; if ( ret ) { goto out ; } kdc_log ( context , config , 0 , ""WRONG_REALM<S2SV_blank>-<S2SV_blank>%s<S2SV_blank>-><S2SV_blank>%s"" , r -> client_name , fixed_client_name ) ; free ( fixed_client_name ) ; ret = _kdc_fast_mk_error ( context , r , & error_method , r -> armor_crypto , & req -> req_body , KRB5_KDC_ERR_WRONG_REALM , NULL , r -> server_princ , NULL , & r -> client -> entry . principal -> realm , NULL , NULL , reply ) ; goto out ; } else if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 0 , ""UNKNOWN<S2SV_blank>--<S2SV_blank>%s:<S2SV_blank>%s"" , r -> client_name , msg ) ; krb5_free_error_message ( context , msg ) ; ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; goto out ; } ret = _kdc_db_fetch ( context , config , r -> server_princ , HDB_F_GET_SERVER | HDB_F_GET_KRBTGT | flags , NULL , NULL , & r -> server ) ; if ( ret == HDB_ERR_NOT_FOUND_HERE ) { kdc_log ( context , config , 5 , ""target<S2SV_blank>%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>secrets<S2SV_blank>at<S2SV_blank>this<S2SV_blank>KDC,<S2SV_blank>need<S2SV_blank>to<S2SV_blank>proxy"" , r -> server_name ) ; goto out ; } else if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 0 , ""UNKNOWN<S2SV_blank>--<S2SV_blank>%s:<S2SV_blank>%s"" , r -> server_name , msg ) ; krb5_free_error_message ( context , msg ) ; ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN ; goto out ; } ret = _kdc_find_etype ( context , krb5_principal_is_krbtgt ( context , r -> server_princ ) ? config -> tgt_use_strongest_session_key : config -> svc_use_strongest_session_key , FALSE , r -> client , b -> etype . val , b -> etype . len , & r -> sessionetype , NULL ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Client<S2SV_blank>(%s)<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>no<S2SV_blank>common<S2SV_blank>enctypes<S2SV_blank>with<S2SV_blank>KDC<S2SV_blank>"" ""to<S2SV_blank>use<S2SV_blank>for<S2SV_blank>the<S2SV_blank>session<S2SV_blank>key"" , r -> client_name , from ) ; goto out ; } if ( req -> padata ) { unsigned int n ; log_patypes ( context , config , req -> padata ) ; for ( n = 0 ; ! found_pa && n < sizeof ( pat ) / sizeof ( pat [ 0 ] ) ; n ++ ) { if ( pat [ n ] . validate == NULL ) continue ; if ( r -> armor_crypto == NULL && ( pat [ n ] . flags & PA_REQ_FAST ) ) continue ; kdc_log ( context , config , 5 , ""Looking<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>pa-data<S2SV_blank>--<S2SV_blank>%s"" , pat [ n ] . name , r -> client_name ) ; i = 0 ; pa = _kdc_find_padata ( req , & i , pat [ n ] . type ) ; if ( pa ) { ret = pat [ n ] . validate ( r , pa ) ; if ( ret != 0 ) { goto out ; } kdc_log ( context , config , 0 , ""%s<S2SV_blank>pre-authentication<S2SV_blank>succeeded<S2SV_blank>--<S2SV_blank>%s"" , pat [ n ] . name , r -> client_name ) ; found_pa = 1 ; r -> et . flags . pre_authent = 1 ; } } } if ( found_pa == 0 ) { Key * ckey = NULL ; size_t n ; for ( n = 0 ; n < sizeof ( pat ) / sizeof ( pat [ 0 ] ) ; n ++ ) { if ( ( pat [ n ] . flags & PA_ANNOUNCE ) == 0 ) continue ; ret = krb5_padata_add ( context , & error_method , pat [ n ] . type , NULL , 0 ) ; if ( ret ) goto out ; } ret = _kdc_find_etype ( context , config -> preauth_use_strongest_session_key , TRUE , r -> client , b -> etype . val , b -> etype . len , NULL , & ckey ) ; if ( ret == 0 ) { if ( older_enctype ( ckey -> key . keytype ) ) { ret = get_pa_etype_info ( context , config , & error_method , ckey ) ; if ( ret ) goto out ; } ret = get_pa_etype_info2 ( context , config , & error_method , ckey ) ; if ( ret ) goto out ; } if ( require_preauth_p ( r ) || _kdc_is_anon_request ( b ) ) { ret = KRB5KDC_ERR_PREAUTH_REQUIRED ; _kdc_set_e_text ( r , ""Need<S2SV_blank>to<S2SV_blank>use<S2SV_blank>PA-ENC-TIMESTAMP/PA-PK-AS-REQ"" ) ; goto out ; } if ( ckey == NULL ) { ret = KRB5KDC_ERR_CLIENT_NOTYET ; _kdc_set_e_text ( r , ""Doesn\'t<S2SV_blank>have<S2SV_blank>a<S2SV_blank>client<S2SV_blank>key<S2SV_blank>available"" ) ; goto out ; } krb5_free_keyblock_contents ( r -> context , & r -> reply_key ) ; ret = krb5_copy_keyblock_contents ( r -> context , & ckey -> key , & r -> reply_key ) ; if ( ret ) goto out ; } if ( r -> clientdb -> hdb_auth_status ) { r -> clientdb -> hdb_auth_status ( context , r -> clientdb , r -> client , HDB_AUTH_SUCCESS ) ; } ret = _kdc_check_access ( context , config , r -> client , r -> client_name , r -> server , r -> server_name , req , & error_method ) ; if ( ret ) goto out ; ret = _kdc_get_preferred_key ( context , config , r -> server , r -> server_name , & setype , & skey ) ; if ( ret ) goto out ; if ( f . renew || f . validate || f . proxy || f . forwarded || f . enc_tkt_in_skey || ( _kdc_is_anon_request ( b ) && ! config -> allow_anonymous ) ) { ret = KRB5KDC_ERR_BADOPTION ; _kdc_set_e_text ( r , ""Bad<S2SV_blank>KDC<S2SV_blank>options"" ) ; goto out ; } rep . pvno = 5 ; rep . msg_type = krb_as_rep ; if ( _kdc_is_anonymous ( context , r -> client_princ ) ) { Realm anon_realm = KRB5_ANON_REALM ; ret = copy_Realm ( & anon_realm , & rep . crealm ) ; } else ret = copy_Realm ( & r -> client -> entry . principal -> realm , & rep . crealm ) ; if ( ret ) goto out ; ret = _krb5_principal2principalname ( & rep . cname , r -> client -> entry . principal ) ; if ( ret ) goto out ; rep . ticket . tkt_vno = 5 ; ret = copy_Realm ( & r -> server -> entry . principal -> realm , & rep . ticket . realm ) ; if ( ret ) goto out ; _krb5_principal2principalname ( & rep . ticket . sname , r -> server -> entry . principal ) ; # define CNT ( sp , t ) ( ( ( sp ) -> sname -> name_type ) == KRB5_NT_ ## t ) if ( CNT ( b , UNKNOWN ) || CNT ( b , PRINCIPAL ) || CNT ( b , SRV_INST ) || CNT ( b , SRV_HST ) || CNT ( b , SRV_XHST ) ) rep . ticket . sname . name_type = b -> sname -> name_type ; # undef CNT r -> et . flags . initial = 1 ; if ( r -> client -> entry . flags . forwardable && r -> server -> entry . flags . forwardable ) r -> et . flags . forwardable = f . forwardable ; else if ( f . forwardable ) { _kdc_set_e_text ( r , ""Ticket<S2SV_blank>may<S2SV_blank>not<S2SV_blank>be<S2SV_blank>forwardable"" ) ; ret = KRB5KDC_ERR_POLICY ; goto out ; } if ( r -> client -> entry . flags . proxiable && r -> server -> entry . flags . proxiable ) r -> et . flags . proxiable = f . proxiable ; else if ( f . proxiable ) { _kdc_set_e_text ( r , ""Ticket<S2SV_blank>may<S2SV_blank>not<S2SV_blank>be<S2SV_blank>proxiable"" ) ; ret = KRB5KDC_ERR_POLICY ; goto out ; } if ( r -> client -> entry . flags . postdate && r -> server -> entry . flags . postdate ) r -> et . flags . may_postdate = f . allow_postdate ; else if ( f . allow_postdate ) { _kdc_set_e_text ( r , ""Ticket<S2SV_blank>may<S2SV_blank>not<S2SV_blank>be<S2SV_blank>postdate"" ) ; ret = KRB5KDC_ERR_POLICY ; goto out ; } if ( ! _kdc_check_addresses ( context , config , b -> addresses , from_addr ) ) { _kdc_set_e_text ( r , ""Bad<S2SV_blank>address<S2SV_blank>list<S2SV_blank>in<S2SV_blank>requested"" ) ; ret = KRB5KRB_AP_ERR_BADADDR ; goto out ; } ret = copy_PrincipalName ( & rep . cname , & r -> et . cname ) ; if ( ret ) goto out ; ret = copy_Realm ( & rep . crealm , & r -> et . crealm ) ; if ( ret ) goto out ; { time_t start ; time_t t ; start = r -> et . authtime = kdc_time ; if ( f . postdated && req -> req_body . from ) { ALLOC ( r -> et . starttime ) ; start = * r -> et . starttime = * req -> req_body . from ; r -> et . flags . invalid = 1 ; r -> et . flags . postdated = 1 ; } _kdc_fix_time ( & b -> till ) ; t = * b -> till ; if ( r -> client -> entry . max_life ) t = start + min ( t - start , * r -> client -> entry . max_life ) ; if ( r -> server -> entry . max_life ) t = start + min ( t - start , * r -> server -> entry . max_life ) ; # if 0 t = min ( t , start + realm -> max_life ) ; # endif r -> et . endtime = t ; if ( f . renewable_ok && r -> et . endtime < * b -> till ) { f . renewable = 1 ; if ( b -> rtime == NULL ) { ALLOC ( b -> rtime ) ; * b -> rtime = 0 ; } if ( * b -> rtime < * b -> till ) * b -> rtime = * b -> till ; } if ( f . renewable && b -> rtime ) { t = * b -> rtime ; if ( t == 0 ) t = MAX_TIME ; if ( r -> client -> entry . max_renew ) t = start + min ( t - start , * r -> client -> entry . max_renew ) ; if ( r -> server -> entry . max_renew ) t = start + min ( t - start , * r -> server -> entry . max_renew ) ; # if 0 t = min ( t , start + realm -> max_renew ) ; # endif ALLOC ( r -> et . renew_till ) ; * r -> et . renew_till = t ; r -> et . flags . renewable = 1 ; } } if ( _kdc_is_anon_request ( b ) ) r -> et . flags . anonymous = 1 ; if ( b -> addresses ) { ALLOC ( r -> et . caddr ) ; copy_HostAddresses ( b -> addresses , r -> et . caddr ) ; } r -> et . transited . tr_type = DOMAIN_X500_COMPRESS ; krb5_data_zero ( & r -> et . transited . contents ) ; r -> ek . last_req . val = malloc ( 2 * sizeof ( * r -> ek . last_req . val ) ) ; if ( r -> ek . last_req . val == NULL ) { ret = ENOMEM ; goto out ; } r -> ek . last_req . len = 0 ; if ( r -> client -> entry . pw_end && ( config -> kdc_warn_pwexpire == 0 || kdc_time + config -> kdc_warn_pwexpire >= * r -> client -> entry . pw_end ) ) { r -> ek . last_req . val [ r -> ek . last_req . len ] . lr_type = LR_PW_EXPTIME ; r -> ek . last_req . val [ r -> ek . last_req . len ] . lr_value = * r -> client -> entry . pw_end ; ++ r -> ek . last_req . len ; } if ( r -> client -> entry . valid_end ) { r -> ek . last_req . val [ r -> ek . last_req . len ] . lr_type = LR_ACCT_EXPTIME ; r -> ek . last_req . val [ r -> ek . last_req . len ] . lr_value = * r -> client -> entry . valid_end ; ++ r -> ek . last_req . len ; } if ( r -> ek . last_req . len == 0 ) { r -> ek . last_req . val [ r -> ek . last_req . len ] . lr_type = LR_NONE ; r -> ek . last_req . val [ r -> ek . last_req . len ] . lr_value = 0 ; ++ r -> ek . last_req . len ; } r -> ek . nonce = b -> nonce ; if ( r -> client -> entry . valid_end || r -> client -> entry . pw_end ) { ALLOC ( r -> ek . key_expiration ) ; if ( r -> client -> entry . valid_end ) { if ( r -> client -> entry . pw_end ) * r -> ek . key_expiration = min ( * r -> client -> entry . valid_end , * r -> client -> entry . pw_end ) ; else * r -> ek . key_expiration = * r -> client -> entry . valid_end ; } else * r -> ek . key_expiration = * r -> client -> entry . pw_end ; } else r -> ek . key_expiration = NULL ; r -> ek . flags = r -> et . flags ; r -> ek . authtime = r -> et . authtime ; if ( r -> et . starttime ) { ALLOC ( r -> ek . starttime ) ; * r -> ek . starttime = * r -> et . starttime ; } r -> ek . endtime = r -> et . endtime ; if ( r -> et . renew_till ) { ALLOC ( r -> ek . renew_till ) ; * r -> ek . renew_till = * r -> et . renew_till ; } ret = copy_Realm ( & rep . ticket . realm , & r -> ek . srealm ) ; if ( ret ) goto out ; ret = copy_PrincipalName ( & rep . ticket . sname , & r -> ek . sname ) ; if ( ret ) goto out ; if ( r -> et . caddr ) { ALLOC ( r -> ek . caddr ) ; copy_HostAddresses ( r -> et . caddr , r -> ek . caddr ) ; } if ( r -> session_key . keytype == ETYPE_NULL ) { ret = krb5_generate_random_keyblock ( context , r -> sessionetype , & r -> session_key ) ; if ( ret ) goto out ; } if ( r -> reply_key . keytype == ETYPE_NULL ) { _kdc_set_e_text ( r , ""Client<S2SV_blank>have<S2SV_blank>no<S2SV_blank>reply<S2SV_blank>key"" ) ; ret = KRB5KDC_ERR_CLIENT_NOTYET ; goto out ; } ret = copy_EncryptionKey ( & r -> session_key , & r -> et . key ) ; if ( ret ) goto out ; ret = copy_EncryptionKey ( & r -> session_key , & r -> ek . key ) ; if ( ret ) goto out ; if ( r -> outpadata . len ) { ALLOC ( rep . padata ) ; if ( rep . padata == NULL ) { ret = ENOMEM ; goto out ; } ret = copy_METHOD_DATA ( & r -> outpadata , rep . padata ) ; if ( ret ) goto out ; } if ( send_pac_p ( context , req ) ) { generate_pac ( r , skey ) ; } _kdc_log_timestamp ( context , config , ""AS-REQ"" , r -> et . authtime , r -> et . starttime , r -> et . endtime , r -> et . renew_till ) ; ret = _kdc_add_KRB5SignedPath ( context , config , r -> server , setype , r -> client -> entry . principal , NULL , NULL , & r -> et ) ; if ( ret ) goto out ; log_as_req ( context , config , r -> reply_key . keytype , setype , b ) ; r -> et . flags . enc_pa_rep = r -> ek . flags . enc_pa_rep = 1 ; i = 0 ; pa = _kdc_find_padata ( req , & i , KRB5_PADATA_REQ_ENC_PA_REP ) ; if ( pa ) { ret = add_enc_pa_rep ( r ) ; if ( ret ) { const char * msg = krb5_get_error_message ( r -> context , ret ) ; _kdc_r_log ( r , 0 , ""add_enc_pa_rep<S2SV_blank>failed:<S2SV_blank>%s:<S2SV_blank>%d"" , msg , ret ) ; krb5_free_error_message ( r -> context , msg ) ; goto out ; } } ret = _kdc_encode_reply ( context , config , r -> armor_crypto , req -> req_body . nonce , & rep , & r -> et , & r -> ek , setype , r -> server -> entry . kvno , & skey -> key , r -> client -> entry . kvno , & r -> reply_key , 0 , & r -> e_text , reply ) ; if ( ret ) goto out ; if ( datagram_reply && reply -> length > config -> max_datagram_reply_length ) { krb5_data_free ( reply ) ; ret = KRB5KRB_ERR_RESPONSE_TOO_BIG ; _kdc_set_e_text ( r , ""Reply<S2SV_blank>packet<S2SV_blank>too<S2SV_blank>large"" ) ; } out : free_AS_REP ( & rep ) ; if ( ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply -> length == 0 ) { ret = _kdc_fast_mk_error ( context , r , & error_method , r -> armor_crypto , & req -> req_body , ret , r -> e_text , r -> server_princ , <S2SV_StartBug> & r -> client_princ -> name , <S2SV_EndBug> <S2SV_StartBug> & r -> client_princ -> realm , <S2SV_EndBug> NULL , NULL , reply ) ; if ( ret ) goto out2 ; } out2 : free_EncTicketPart ( & r -> et ) ; free_EncKDCRepPart ( & r -> ek ) ; free_KDCFastState ( & r -> fast ) ; if ( error_method . len ) free_METHOD_DATA ( & error_method ) ; if ( r -> outpadata . len ) free_METHOD_DATA ( & r -> outpadata ) ; if ( r -> client_princ ) { krb5_free_principal ( context , r -> client_princ ) ; r -> client_princ = NULL ; } if ( r -> client_name ) { free ( r -> client_name ) ; r -> client_name = NULL ; } if ( r -> server_princ ) { krb5_free_principal ( context , r -> server_princ ) ; r -> server_princ = NULL ; } if ( r -> server_name ) { free ( r -> server_name ) ; r -> server_name = NULL ; } if ( r -> client ) _kdc_free_ent ( context , r -> client ) ; if ( r -> server ) _kdc_free_ent ( context , r -> server ) ; if ( r -> armor_crypto ) { krb5_crypto_destroy ( r -> context , r -> armor_crypto ) ; r -> armor_crypto = NULL ; } krb5_free_keyblock_contents ( r -> context , & r -> reply_key ) ; krb5_free_keyblock_contents ( r -> context , & r -> session_key ) ; return ret ; }
","<S2SV_ModStart> -> server_princ , <S2SV_ModEnd> r -> client_princ <S2SV_ModStart> r -> client_princ ? & r -> client_princ -> name : NULL , <S2SV_ModEnd> r -> client_princ <S2SV_ModStart> r -> client_princ ? & r -> client_princ -> realm : NULL <S2SV_ModEnd> , NULL ,
"
341,"CWE-264 static int command_read ( struct pci_dev * dev , int offset , u16 * value , void * data ) { <S2SV_StartBug> int i ; <S2SV_EndBug> int ret ; <S2SV_StartBug> ret = xen_pcibk_read_config_word ( dev , offset , value , data ) ; <S2SV_EndBug> if ( ! pci_is_enabled ( dev ) ) return ret ; for ( i = 0 ; i < PCI_ROM_RESOURCE ; i ++ ) { if ( dev -> resource [ i ] . flags & IORESOURCE_IO ) <S2SV_StartBug> * value |= PCI_COMMAND_IO ; <S2SV_EndBug> if ( dev -> resource [ i ] . flags & IORESOURCE_MEM ) * value |= PCI_COMMAND_MEMORY ; } return ret ; }
","<S2SV_ModStart> ) { int ret = pci_read_config_word <S2SV_ModEnd> ( dev , <S2SV_ModStart> offset , value ) ; const struct pci_cmd_info * cmd = data ; * value &= PCI_COMMAND_GUEST ; <S2SV_ModEnd> * value |= <S2SV_ModStart> * value |= cmd -> val & ~ PCI_COMMAND_GUEST ; <S2SV_ModEnd> return ret ;
"
342,"CWE-20 error_t coapClientReadBody ( CoapClientRequest * request , void * data , size_t size , size_t * received ) { error_t error ; size_t n ; uint32_t value ; uint32_t blockPos ; uint32_t blockSzx ; size_t payloadLen ; const uint8_t * payload ; CoapMessage * requestMsg ; CoapMessage * responseMsg ; CoapCode responseCode ; error = NO_ERROR ; * received = 0 ; while ( * received < size ) { responseMsg = coapClientGetResponseMessage ( request ) ; error = coapClientReadPayload ( responseMsg , data , size - * received , & n ) ; if ( error == NO_ERROR ) { data = ( uint8_t * ) data + n ; * received += n ; } else if ( error == ERROR_END_OF_STREAM ) { requestMsg = coapClientGetRequestMessage ( request ) ; error = coapClientGetUintOption ( requestMsg , COAP_OPT_BLOCK2 , 0 , & value ) ; if ( ! error ) { blockPos = COAP_GET_BLOCK_POS ( value ) ; blockSzx = COAP_GET_BLOCK_SZX ( value ) ; } else { blockPos = 0 ; blockSzx = request -> rxBlockSzx ; } error = coapClientGetUintOption ( responseMsg , COAP_OPT_BLOCK2 , 0 , & value ) ; if ( ! error ) { if ( COAP_GET_BLOCK_SZX ( value ) >= COAP_BLOCK_SIZE_RESERVED ) { error = ERROR_FAILURE ; break ; } if ( COAP_GET_BLOCK_POS ( value ) != blockPos ) { error = ERROR_FAILURE ; break ; } if ( ! COAP_GET_BLOCK_M ( value ) ) { error = ERROR_END_OF_STREAM ; break ; } error = coapClientGetPayload ( responseMsg , & payload , & payloadLen ) ; if ( error ) break ; if ( payloadLen != COAP_GET_BLOCK_SIZE ( value ) ) { error = ERROR_FAILURE ; break ; } if ( blockSzx > COAP_GET_BLOCK_SZX ( value ) ) blockSzx = COAP_GET_BLOCK_SZX ( value ) ; blockPos += COAP_GET_BLOCK_SIZE ( value ) ; COAP_SET_BLOCK_NUM ( value , blockPos >> ( blockSzx + 4 ) ) ; COAP_SET_BLOCK_M ( value , 0 ) ; COAP_SET_BLOCK_SZX ( value , blockSzx ) ; error = coapClientSetUintOption ( requestMsg , COAP_OPT_BLOCK2 , 0 , value ) ; if ( error ) break ; error = coapClientSendRequest ( request , NULL , NULL ) ; if ( error ) break ; responseMsg = coapClientGetResponseMessage ( request ) ; error = coapClientGetResponseCode ( responseMsg , & responseCode ) ; if ( error ) break ; if ( COAP_GET_CODE_CLASS ( responseCode ) != COAP_CODE_CLASS_SUCCESS ) { error = ERROR_INVALID_STATUS ; break ; } } else { if ( blockPos == 0 ) <S2SV_StartBug> error = ERROR_END_OF_STREAM ; <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> error = ERROR_FAILURE ; <S2SV_EndBug> break ; } } else { break ; } } if ( * received > 0 ) { if ( error == ERROR_END_OF_STREAM ) error = NO_ERROR ; } return error ; }
","<S2SV_ModStart> == 0 ) { <S2SV_ModStart> = ERROR_END_OF_STREAM ; } else { <S2SV_ModEnd> error = ERROR_FAILURE <S2SV_ModStart> = ERROR_FAILURE ; }
"
343,"CWE-416 int SMB2_read ( const unsigned int xid , struct cifs_io_parms * io_parms , unsigned int * nbytes , char * * buf , int * buf_type ) { struct smb_rqst rqst ; int resp_buftype , rc = - EACCES ; struct smb2_read_plain_req * req = NULL ; struct smb2_read_rsp * rsp = NULL ; struct kvec iov [ 1 ] ; struct kvec rsp_iov ; unsigned int total_len ; int flags = CIFS_LOG_ERROR ; struct cifs_ses * ses = io_parms -> tcon -> ses ; * nbytes = 0 ; rc = smb2_new_read_req ( ( void * * ) & req , & total_len , io_parms , NULL , 0 , 0 ) ; if ( rc ) return rc ; if ( smb3_encryption_required ( io_parms -> tcon ) ) flags |= CIFS_TRANSFORM_REQ ; iov [ 0 ] . iov_base = ( char * ) req ; iov [ 0 ] . iov_len = total_len ; memset ( & rqst , 0 , sizeof ( struct smb_rqst ) ) ; rqst . rq_iov = iov ; rqst . rq_nvec = 1 ; rc = cifs_send_recv ( xid , ses , & rqst , & resp_buftype , flags , & rsp_iov ) ; <S2SV_StartBug> cifs_small_buf_release ( req ) ; <S2SV_EndBug> rsp = ( struct smb2_read_rsp * ) rsp_iov . iov_base ; if ( rc ) { if ( rc != - ENODATA ) { cifs_stats_fail_inc ( io_parms -> tcon , SMB2_READ_HE ) ; cifs_dbg ( VFS , ""Send<S2SV_blank>error<S2SV_blank>in<S2SV_blank>read<S2SV_blank>=<S2SV_blank>%d\\n"" , rc ) ; trace_smb3_read_err ( xid , req -> PersistentFileId , io_parms -> tcon -> tid , ses -> Suid , io_parms -> offset , io_parms -> length , rc ) ; } else trace_smb3_read_done ( xid , req -> PersistentFileId , io_parms -> tcon -> tid , ses -> Suid , io_parms -> offset , 0 ) ; free_rsp_buf ( resp_buftype , rsp_iov . iov_base ) ; return rc == - ENODATA ? 0 : rc ; } else trace_smb3_read_done ( xid , req -> PersistentFileId , io_parms -> tcon -> tid , ses -> Suid , io_parms -> offset , io_parms -> length ) ; <S2SV_StartBug> * nbytes = le32_to_cpu ( rsp -> DataLength ) ; <S2SV_EndBug> if ( ( * nbytes > CIFS_MAX_MSGSIZE ) || ( * nbytes > io_parms -> length ) ) { cifs_dbg ( FYI , ""bad<S2SV_blank>length<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>count<S2SV_blank>%d\\n"" , * nbytes , io_parms -> length ) ; rc = - EIO ; * nbytes = 0 ; } if ( * buf ) { memcpy ( * buf , ( char * ) rsp + rsp -> DataOffset , * nbytes ) ; free_rsp_buf ( resp_buftype , rsp_iov . iov_base ) ; } else if ( resp_buftype != CIFS_NO_BUFFER ) { * buf = rsp_iov . iov_base ; if ( resp_buftype == CIFS_SMALL_BUFFER ) * buf_type = CIFS_SMALL_BUFFER ; else if ( resp_buftype == CIFS_LARGE_BUFFER ) * buf_type = CIFS_LARGE_BUFFER ; } return rc ; }
","<S2SV_ModStart> rsp_iov ) ; <S2SV_ModEnd> rsp = ( <S2SV_ModStart> length ) ; cifs_small_buf_release ( req ) ;
"
344,"CWE-119 static int filter_frame ( AVFilterLink * inlink , AVFrame * frame ) { AVFilterContext * ctx = inlink -> dst ; FieldOrderContext * s = ctx -> priv ; AVFilterLink * outlink = ctx -> outputs [ 0 ] ; int h , plane , line_step , line_size , line ; uint8_t * data ; if ( ! frame -> interlaced_frame || frame -> top_field_first == s -> dst_tff ) return ff_filter_frame ( outlink , frame ) ; av_dlog ( ctx , ""picture<S2SV_blank>will<S2SV_blank>move<S2SV_blank>%s<S2SV_blank>one<S2SV_blank>line\\n"" , s -> dst_tff ? ""up"" : ""down"" ) ; h = frame -> height ; <S2SV_StartBug> for ( plane = 0 ; plane < 4 && frame -> data [ plane ] ; plane ++ ) { <S2SV_EndBug> line_step = frame -> linesize [ plane ] ; line_size = s -> line_size [ plane ] ; data = frame -> data [ plane ] ; if ( s -> dst_tff ) { for ( line = 0 ; line < h ; line ++ ) { if ( 1 + line < frame -> height ) { memcpy ( data , data + line_step , line_size ) ; } else { memcpy ( data , data - line_step - line_step , line_size ) ; } data += line_step ; } } else { data += ( h - 1 ) * line_step ; for ( line = h - 1 ; line >= 0 ; line -- ) { if ( line > 0 ) { memcpy ( data , data - line_step , line_size ) ; } else { memcpy ( data , data + line_step + line_step , line_size ) ; } data -= line_step ; } } } frame -> top_field_first = s -> dst_tff ; return ff_filter_frame ( outlink , frame ) ; }
","<S2SV_ModStart> [ plane ] && frame -> linesize [ plane ]
"
345,"CWE-264 <S2SV_StartBug> static unsigned int stack_maxrandom_size ( void ) <S2SV_EndBug> { <S2SV_StartBug> unsigned int max = 0 ; <S2SV_EndBug> if ( ( current -> flags & PF_RANDOMIZE ) && ! ( current -> personality & ADDR_NO_RANDOMIZE ) ) { <S2SV_StartBug> max = ( ( - 1U ) & STACK_RND_MASK ) << PAGE_SHIFT ; <S2SV_EndBug> } return max ; }
","<S2SV_ModStart> <S2SV_null> static unsigned long <S2SV_ModEnd> stack_maxrandom_size ( void <S2SV_ModStart> ) { unsigned long <S2SV_ModEnd> max = 0 <S2SV_ModStart> ( ( - 1UL <S2SV_ModEnd> ) & STACK_RND_MASK
"
346,"CWE-362 static int smb_send_rqst ( struct TCP_Server_Info * server , struct smb_rqst * rqst ) { int rc ; struct kvec * iov = rqst -> rq_iov ; int n_vec = rqst -> rq_nvec ; unsigned int smb_buf_length = get_rfc1002_length ( iov [ 0 ] . iov_base ) ; unsigned int i ; size_t total_len = 0 , sent ; struct socket * ssocket = server -> ssocket ; <S2SV_StartBug> int val = 1 ; <S2SV_EndBug> cFYI ( 1 , ""Sending<S2SV_blank>smb:<S2SV_blank>smb_len=%u"" , smb_buf_length ) ; dump_smb ( iov [ 0 ] . iov_base , iov [ 0 ] . iov_len ) ; kernel_setsockopt ( ssocket , SOL_TCP , TCP_CORK , ( char * ) & val , sizeof ( val ) ) ; rc = smb_send_kvec ( server , iov , n_vec , & sent ) ; if ( rc < 0 ) goto uncork ; total_len += sent ; for ( i = 0 ; i < rqst -> rq_npages ; i ++ ) { struct kvec p_iov ; cifs_rqst_page_to_kvec ( rqst , i , & p_iov ) ; rc = smb_send_kvec ( server , & p_iov , 1 , & sent ) ; kunmap ( rqst -> rq_pages [ i ] ) ; if ( rc < 0 ) break ; total_len += sent ; } uncork : val = 0 ; kernel_setsockopt ( ssocket , SOL_TCP , TCP_CORK , ( char * ) & val , sizeof ( val ) ) ; if ( ( total_len > 0 ) && ( total_len != smb_buf_length + 4 ) ) { cFYI ( 1 , ""partial<S2SV_blank>send<S2SV_blank>(wanted=%u<S2SV_blank>sent=%zu):<S2SV_blank>terminating<S2SV_blank>"" ""session"" , smb_buf_length + 4 , total_len ) ; server -> tcpStatus = CifsNeedReconnect ; } if ( rc < 0 && rc != - EINTR ) cERROR ( 1 , ""Error<S2SV_blank>%d<S2SV_blank>sending<S2SV_blank>data<S2SV_blank>on<S2SV_blank>socket<S2SV_blank>to<S2SV_blank>server"" , rc ) ; else rc = 0 ; return rc ; }
","<S2SV_ModStart> val = 1 ; if ( ssocket == NULL ) return - ENOTSOCK
"
347,"CWE-362 int snd_card_new ( struct device * parent , int idx , const char * xid , struct module * module , int extra_size , struct snd_card * * card_ret ) { struct snd_card * card ; int err ; if ( snd_BUG_ON ( ! card_ret ) ) return - EINVAL ; * card_ret = NULL ; if ( extra_size < 0 ) extra_size = 0 ; card = kzalloc ( sizeof ( * card ) + extra_size , GFP_KERNEL ) ; if ( ! card ) return - ENOMEM ; if ( extra_size > 0 ) card -> private_data = ( char * ) card + sizeof ( struct snd_card ) ; if ( xid ) strlcpy ( card -> id , xid , sizeof ( card -> id ) ) ; err = 0 ; mutex_lock ( & snd_card_mutex ) ; if ( idx < 0 ) idx = get_slot_from_bitmask ( idx , module_slot_match , module ) ; if ( idx < 0 ) idx = get_slot_from_bitmask ( idx , check_empty_slot , module ) ; if ( idx < 0 ) err = - ENODEV ; else if ( idx < snd_ecards_limit ) { if ( test_bit ( idx , snd_cards_lock ) ) err = - EBUSY ; } else if ( idx >= SNDRV_CARDS ) err = - ENODEV ; if ( err < 0 ) { mutex_unlock ( & snd_card_mutex ) ; dev_err ( parent , ""cannot<S2SV_blank>find<S2SV_blank>the<S2SV_blank>slot<S2SV_blank>for<S2SV_blank>index<S2SV_blank>%d<S2SV_blank>(range<S2SV_blank>0-%i),<S2SV_blank>error:<S2SV_blank>%d\\n"" , idx , snd_ecards_limit - 1 , err ) ; kfree ( card ) ; return err ; } set_bit ( idx , snd_cards_lock ) ; if ( idx >= snd_ecards_limit ) snd_ecards_limit = idx + 1 ; mutex_unlock ( & snd_card_mutex ) ; card -> dev = parent ; card -> number = idx ; card -> module = module ; INIT_LIST_HEAD ( & card -> devices ) ; init_rwsem ( & card -> controls_rwsem ) ; rwlock_init ( & card -> ctl_files_rwlock ) ; <S2SV_StartBug> INIT_LIST_HEAD ( & card -> controls ) ; <S2SV_EndBug> INIT_LIST_HEAD ( & card -> ctl_files ) ; spin_lock_init ( & card -> files_lock ) ; INIT_LIST_HEAD ( & card -> files_list ) ; # ifdef CONFIG_PM mutex_init ( & card -> power_lock ) ; init_waitqueue_head ( & card -> power_sleep ) ; # endif device_initialize ( & card -> card_dev ) ; card -> card_dev . parent = parent ; card -> card_dev . class = sound_class ; card -> card_dev . release = release_card_device ; card -> card_dev . groups = card_dev_attr_groups ; err = kobject_set_name ( & card -> card_dev . kobj , ""card%d"" , idx ) ; if ( err < 0 ) goto __error ; err = snd_ctl_create ( card ) ; if ( err < 0 ) { dev_err ( parent , ""unable<S2SV_blank>to<S2SV_blank>register<S2SV_blank>control<S2SV_blank>minors\\n"" ) ; goto __error ; } err = snd_info_card_create ( card ) ; if ( err < 0 ) { dev_err ( parent , ""unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>card<S2SV_blank>info\\n"" ) ; goto __error_ctl ; } * card_ret = card ; return 0 ; __error_ctl : snd_device_free_all ( card ) ; __error : put_device ( & card -> card_dev ) ; return err ; }
","<S2SV_ModStart> ctl_files_rwlock ) ; mutex_init ( & card -> user_ctl_lock ) ;
"
348,"CWE-399 struct sctp_chunk * sctp_assoc_lookup_asconf_ack ( const struct sctp_association * asoc , __be32 serial ) { struct sctp_chunk * ack ; list_for_each_entry ( ack , & asoc -> asconf_ack_list , transmitted_list ) { <S2SV_StartBug> if ( ack -> subh . addip_hdr -> serial == serial ) { <S2SV_EndBug> sctp_chunk_hold ( ack ) ; return ack ; } } return NULL ; }
","<S2SV_ModStart> { if ( sctp_chunk_pending ( ack ) ) continue ; if (
"
349,"CWE-119 static void process_blob ( struct rev_info * revs , struct blob * blob , show_object_fn show , struct strbuf * path , const char * name , void * cb_data ) { struct object * obj = & blob -> object ; <S2SV_StartBug> if ( ! revs -> blob_objects ) <S2SV_EndBug> return ; if ( ! obj ) die ( ""bad<S2SV_blank>blob<S2SV_blank>object"" ) ; if ( obj -> flags & ( UNINTERESTING | SEEN ) ) return ; obj -> flags |= SEEN ; <S2SV_StartBug> show ( obj , path , name , cb_data ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> -> object ; size_t pathlen ; <S2SV_ModStart> |= SEEN ; pathlen = path -> len ; strbuf_addstr ( path , name ) ; <S2SV_ModStart> obj , path -> buf <S2SV_ModEnd> , cb_data ) <S2SV_ModStart> cb_data ) ; strbuf_setlen ( path , pathlen ) ;
"
350,"CWE-476 int btrfs_scrub_dev ( struct btrfs_fs_info * fs_info , u64 devid , u64 start , u64 end , struct btrfs_scrub_progress * progress , int readonly , int is_dev_replace ) { struct scrub_ctx * sctx ; int ret ; struct btrfs_device * dev ; unsigned int nofs_flag ; if ( btrfs_fs_closing ( fs_info ) ) return - EINVAL ; if ( fs_info -> nodesize > BTRFS_STRIPE_LEN ) { btrfs_err ( fs_info , ""scrub:<S2SV_blank>size<S2SV_blank>assumption<S2SV_blank>nodesize<S2SV_blank><=<S2SV_blank>BTRFS_STRIPE_LEN<S2SV_blank>(%d<S2SV_blank><=<S2SV_blank>%d)<S2SV_blank>fails"" , fs_info -> nodesize , BTRFS_STRIPE_LEN ) ; return - EINVAL ; } if ( fs_info -> sectorsize != PAGE_SIZE ) { btrfs_err_rl ( fs_info , ""scrub:<S2SV_blank>size<S2SV_blank>assumption<S2SV_blank>sectorsize<S2SV_blank>!=<S2SV_blank>PAGE_SIZE<S2SV_blank>(%d<S2SV_blank>!=<S2SV_blank>%lu)<S2SV_blank>fails"" , fs_info -> sectorsize , PAGE_SIZE ) ; return - EINVAL ; } if ( fs_info -> nodesize > PAGE_SIZE * SCRUB_MAX_PAGES_PER_BLOCK || fs_info -> sectorsize > PAGE_SIZE * SCRUB_MAX_PAGES_PER_BLOCK ) { btrfs_err ( fs_info , ""scrub:<S2SV_blank>size<S2SV_blank>assumption<S2SV_blank>nodesize<S2SV_blank>and<S2SV_blank>sectorsize<S2SV_blank><=<S2SV_blank>SCRUB_MAX_PAGES_PER_BLOCK<S2SV_blank>(%d<S2SV_blank><=<S2SV_blank>%d<S2SV_blank>&&<S2SV_blank>%d<S2SV_blank><=<S2SV_blank>%d)<S2SV_blank>fails"" , fs_info -> nodesize , SCRUB_MAX_PAGES_PER_BLOCK , fs_info -> sectorsize , SCRUB_MAX_PAGES_PER_BLOCK ) ; return - EINVAL ; } sctx = scrub_setup_ctx ( fs_info , is_dev_replace ) ; if ( IS_ERR ( sctx ) ) return PTR_ERR ( sctx ) ; mutex_lock ( & fs_info -> fs_devices -> device_list_mutex ) ; <S2SV_StartBug> dev = btrfs_find_device ( fs_info -> fs_devices , devid , NULL , NULL ) ; <S2SV_EndBug> if ( ! dev || ( test_bit ( BTRFS_DEV_STATE_MISSING , & dev -> dev_state ) && ! is_dev_replace ) ) { mutex_unlock ( & fs_info -> fs_devices -> device_list_mutex ) ; ret = - ENODEV ; goto out_free_ctx ; } if ( ! is_dev_replace && ! readonly && ! test_bit ( BTRFS_DEV_STATE_WRITEABLE , & dev -> dev_state ) ) { mutex_unlock ( & fs_info -> fs_devices -> device_list_mutex ) ; btrfs_err_in_rcu ( fs_info , ""scrub:<S2SV_blank>device<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>writable"" , rcu_str_deref ( dev -> name ) ) ; ret = - EROFS ; goto out_free_ctx ; } mutex_lock ( & fs_info -> scrub_lock ) ; if ( ! test_bit ( BTRFS_DEV_STATE_IN_FS_METADATA , & dev -> dev_state ) || test_bit ( BTRFS_DEV_STATE_REPLACE_TGT , & dev -> dev_state ) ) { mutex_unlock ( & fs_info -> scrub_lock ) ; mutex_unlock ( & fs_info -> fs_devices -> device_list_mutex ) ; ret = - EIO ; goto out_free_ctx ; } down_read ( & fs_info -> dev_replace . rwsem ) ; if ( dev -> scrub_ctx || ( ! is_dev_replace && btrfs_dev_replace_is_ongoing ( & fs_info -> dev_replace ) ) ) { up_read ( & fs_info -> dev_replace . rwsem ) ; mutex_unlock ( & fs_info -> scrub_lock ) ; mutex_unlock ( & fs_info -> fs_devices -> device_list_mutex ) ; ret = - EINPROGRESS ; goto out_free_ctx ; } up_read ( & fs_info -> dev_replace . rwsem ) ; ret = scrub_workers_get ( fs_info , is_dev_replace ) ; if ( ret ) { mutex_unlock ( & fs_info -> scrub_lock ) ; mutex_unlock ( & fs_info -> fs_devices -> device_list_mutex ) ; goto out_free_ctx ; } sctx -> readonly = readonly ; dev -> scrub_ctx = sctx ; mutex_unlock ( & fs_info -> fs_devices -> device_list_mutex ) ; __scrub_blocked_if_needed ( fs_info ) ; atomic_inc ( & fs_info -> scrubs_running ) ; mutex_unlock ( & fs_info -> scrub_lock ) ; nofs_flag = memalloc_nofs_save ( ) ; if ( ! is_dev_replace ) { mutex_lock ( & fs_info -> fs_devices -> device_list_mutex ) ; ret = scrub_supers ( sctx , dev ) ; mutex_unlock ( & fs_info -> fs_devices -> device_list_mutex ) ; } if ( ! ret ) ret = scrub_enumerate_chunks ( sctx , dev , start , end ) ; memalloc_nofs_restore ( nofs_flag ) ; wait_event ( sctx -> list_wait , atomic_read ( & sctx -> bios_in_flight ) == 0 ) ; atomic_dec ( & fs_info -> scrubs_running ) ; wake_up ( & fs_info -> scrub_pause_wait ) ; wait_event ( sctx -> list_wait , atomic_read ( & sctx -> workers_pending ) == 0 ) ; if ( progress ) memcpy ( progress , & sctx -> stat , sizeof ( * progress ) ) ; mutex_lock ( & fs_info -> scrub_lock ) ; dev -> scrub_ctx = NULL ; scrub_workers_put ( fs_info ) ; mutex_unlock ( & fs_info -> scrub_lock ) ; scrub_put_ctx ( sctx ) ; return ret ; out_free_ctx : scrub_free_ctx ( sctx ) ; return ret ; }
","<S2SV_ModStart> NULL , NULL , true
"
351,"CWE-77 static void print_value ( int output , int num , const char * devname , const char * value , const char * name , size_t valsz ) { if ( output & OUTPUT_VALUE_ONLY ) { fputs ( value , stdout ) ; fputc ( '\\n' , stdout ) ; } else if ( output & OUTPUT_UDEV_LIST ) { print_udev_format ( name , value ) ; } else if ( output & OUTPUT_EXPORT_LIST ) { if ( num == 1 && devname ) printf ( ""DEVNAME=%s\\n"" , devname ) ; fputs ( name , stdout ) ; fputs ( ""="" , stdout ) ; <S2SV_StartBug> safe_print ( value , valsz , NULL ) ; <S2SV_EndBug> fputs ( ""\\n"" , stdout ) ; } else { if ( num == 1 && devname ) printf ( ""%s:"" , devname ) ; fputs ( ""<S2SV_blank>"" , stdout ) ; fputs ( name , stdout ) ; fputs ( ""=\\"""" , stdout ) ; <S2SV_StartBug> safe_print ( value , valsz , ""\\"""" ) ; <S2SV_EndBug> fputs ( ""\\"""" , stdout ) ; } }
","<S2SV_ModStart> , valsz , ""<S2SV_blank>\\\\\\""\'$`<>"" <S2SV_ModEnd> ) ; fputs <S2SV_ModStart> , valsz , ""\\""\\\\"" ) ; fputs ( ""\\"""" <S2SV_ModEnd> , stdout )
"
352,"CWE-295 void options_defaults ( ) { SERVICE_OPTIONS * service ; memset ( & new_global_options , 0 , sizeof ( GLOBAL_OPTIONS ) ) ; memset ( & new_service_options , 0 , sizeof ( SERVICE_OPTIONS ) ) ; new_service_options . next = NULL ; <S2SV_StartBug> parse_global_option ( CMD_SET_DEFAULTS , NULL , NULL ) ; <S2SV_EndBug> service = & new_service_options ; parse_service_option ( CMD_SET_DEFAULTS , & service , NULL , NULL ) ; }
","<S2SV_ModStart> ( CMD_SET_DEFAULTS , & new_global_options ,
"
353,"CWE-119 DECLAREreadFunc ( readContigTilesIntoBuffer ) { int status = 1 ; tsize_t tilesize = TIFFTileSize ( in ) ; tdata_t tilebuf ; uint32 imagew = TIFFScanlineSize ( in ) ; uint32 tilew = TIFFTileRowSize ( in ) ; <S2SV_StartBug> int iskew = imagew - tilew ; <S2SV_EndBug> uint8 * bufp = ( uint8 * ) buf ; uint32 tw , tl ; uint32 row ; ( void ) spp ; tilebuf = _TIFFmalloc ( tilesize ) ; if ( tilebuf == 0 ) return 0 ; _TIFFmemset ( tilebuf , 0 , tilesize ) ; ( void ) TIFFGetField ( in , TIFFTAG_TILEWIDTH , & tw ) ; ( void ) TIFFGetField ( in , TIFFTAG_TILELENGTH , & tl ) ; for ( row = 0 ; row < imagelength ; row += tl ) { uint32 nrow = ( row + tl > imagelength ) ? imagelength - row : tl ; uint32 colb = 0 ; uint32 col ; for ( col = 0 ; col < imagewidth && colb < imagew ; col += tw ) { if ( TIFFReadTile ( in , tilebuf , col , row , 0 , 0 ) < 0 && ! ignore ) { TIFFError ( TIFFFileName ( in ) , ""Error,<S2SV_blank>can\'t<S2SV_blank>read<S2SV_blank>tile<S2SV_blank>at<S2SV_blank>%lu<S2SV_blank>%lu"" , ( unsigned long ) col , ( unsigned long ) row ) ; status = 0 ; goto done ; } <S2SV_StartBug> if ( colb + tilew > imagew ) { <S2SV_EndBug> uint32 width = imagew - colb ; uint32 oskew = tilew - width ; cpStripToTile ( bufp + colb , tilebuf , nrow , width , oskew + iskew , oskew ) ; } else cpStripToTile ( bufp + colb , tilebuf , nrow , tilew , iskew , 0 ) ; colb += tilew ; } bufp += imagew * nrow ; } done : _TIFFfree ( tilebuf ) ; return status ; }
","<S2SV_ModStart> in ) ; int64 iskew = ( int64 ) imagew - ( int64 ) <S2SV_ModEnd> tilew ; uint8 <S2SV_ModStart> if ( colb > iskew <S2SV_ModEnd> ) { uint32
"
354,"CWE-125 static int telnet_parse ( netdissect_options * ndo , const u_char * sp , u_int length , int print ) { int i , x ; u_int c ; const u_char * osp , * p ; # define FETCH ( c , sp , length ) do { if ( length < 1 ) goto pktend ; ND_TCHECK ( * sp ) ; c = * sp ++ ; length -- ; } while ( 0 ) osp = sp ; FETCH ( c , sp , length ) ; if ( c != IAC ) goto pktend ; FETCH ( c , sp , length ) ; if ( c == IAC ) { if ( print ) ND_PRINT ( ( ndo , ""IAC<S2SV_blank>IAC"" ) ) ; goto done ; } i = c - TELCMD_FIRST ; if ( i < 0 || i > IAC - TELCMD_FIRST ) goto pktend ; switch ( c ) { case DONT : case DO : case WONT : case WILL : case SB : FETCH ( x , sp , length ) ; if ( x >= 0 && x < NTELOPTS ) { if ( print ) ND_PRINT ( ( ndo , ""%s<S2SV_blank>%s"" , telcmds [ i ] , telopts [ x ] ) ) ; } else { if ( print ) ND_PRINT ( ( ndo , ""%s<S2SV_blank>%#x"" , telcmds [ i ] , x ) ) ; } if ( c != SB ) break ; p = sp ; while ( length > ( u_int ) ( p + 1 - sp ) ) { ND_TCHECK2 ( * p , 2 ) ; if ( p [ 0 ] == IAC && p [ 1 ] == SE ) break ; p ++ ; } <S2SV_StartBug> if ( * p != IAC ) <S2SV_EndBug> goto pktend ; switch ( x ) { case TELOPT_AUTHENTICATION : if ( p <= sp ) break ; FETCH ( c , sp , length ) ; if ( print ) ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , STR_OR_ID ( c , authcmd ) ) ) ; if ( p <= sp ) break ; FETCH ( c , sp , length ) ; if ( print ) ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , STR_OR_ID ( c , authtype ) ) ) ; break ; case TELOPT_ENCRYPT : if ( p <= sp ) break ; FETCH ( c , sp , length ) ; if ( print ) ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , STR_OR_ID ( c , enccmd ) ) ) ; if ( p <= sp ) break ; FETCH ( c , sp , length ) ; if ( print ) ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , STR_OR_ID ( c , enctype ) ) ) ; break ; default : if ( p <= sp ) break ; FETCH ( c , sp , length ) ; if ( print ) ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , STR_OR_ID ( c , cmds ) ) ) ; break ; } while ( p > sp ) { FETCH ( x , sp , length ) ; if ( print ) ND_PRINT ( ( ndo , ""<S2SV_blank>%#x"" , x ) ) ; } if ( print ) ND_PRINT ( ( ndo , ""<S2SV_blank>SE"" ) ) ; sp += 2 ; break ; default : if ( print ) ND_PRINT ( ( ndo , ""%s"" , telcmds [ i ] ) ) ; goto done ; } done : return sp - osp ; trunc : ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; pktend : return - 1 ; # undef FETCH }
","<S2SV_ModStart> ++ ; } ND_TCHECK ( * p ) ;
"
355,"CWE-19 static void ext4_xattr_release_block ( handle_t * handle , struct inode * inode , struct buffer_head * bh ) { <S2SV_StartBug> struct mb_cache_entry * ce = NULL ; <S2SV_EndBug> <S2SV_StartBug> int error = 0 ; <S2SV_EndBug> struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ; ce = mb_cache_entry_get ( ext4_mb_cache , bh -> b_bdev , bh -> b_blocknr ) ; BUFFER_TRACE ( bh , ""get_write_access"" ) ; error = ext4_journal_get_write_access ( handle , bh ) ; if ( error ) goto out ; lock_buffer ( bh ) ; if ( BHDR ( bh ) -> h_refcount == cpu_to_le32 ( 1 ) ) { <S2SV_StartBug> ea_bdebug ( bh , ""refcount<S2SV_blank>now=0;<S2SV_blank>freeing"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ce ) <S2SV_EndBug> mb_cache_entry_free ( ce ) ; get_bh ( bh ) ; unlock_buffer ( bh ) ; ext4_free_blocks ( handle , inode , bh , 0 , 1 , EXT4_FREE_BLOCKS_METADATA | EXT4_FREE_BLOCKS_FORGET ) ; } else { le32_add_cpu ( & BHDR ( bh ) -> h_refcount , - 1 ) ; <S2SV_StartBug> if ( ce ) <S2SV_EndBug> mb_cache_entry_release ( ce ) ; if ( ext4_handle_valid ( handle ) ) error = ext4_handle_dirty_xattr_block ( handle , inode , bh ) ; unlock_buffer ( bh ) ; if ( ! ext4_handle_valid ( handle ) ) error = ext4_handle_dirty_xattr_block ( handle , inode , bh ) ; if ( IS_SYNC ( inode ) ) ext4_handle_sync ( handle ) ; dquot_free_block ( inode , EXT4_C2B ( EXT4_SB ( inode -> i_sb ) , 1 ) ) ; ea_bdebug ( bh , ""refcount<S2SV_blank>now=%d;<S2SV_blank>releasing"" , le32_to_cpu ( BHDR ( bh ) -> h_refcount ) ) ; } out : ext4_std_error ( inode -> i_sb , error ) ; return ; }
","<S2SV_ModStart> bh ) { <S2SV_ModEnd> int error = <S2SV_ModStart> error = 0 <S2SV_ModEnd> ; BUFFER_TRACE ( <S2SV_ModStart> ) ) { __u32 hash = le32_to_cpu ( BHDR ( bh ) -> h_hash ) ; <S2SV_ModStart> ""refcount<S2SV_blank>now=0;<S2SV_blank>freeing"" ) ; mb2_cache_entry_delete_block ( EXT4_GET_MB_CACHE ( inode ) , hash , bh -> b_blocknr <S2SV_ModEnd> ) ; get_bh <S2SV_ModStart> ; if ( <S2SV_ModEnd> ext4_handle_valid ( handle
"
356,"CWE-787 int TIFFFlushData1 ( TIFF * tif ) { if ( tif -> tif_rawcc > 0 && tif -> tif_flags & TIFF_BUF4WRITE ) { if ( ! isFillOrder ( tif , tif -> tif_dir . td_fillorder ) && ( tif -> tif_flags & TIFF_NOBITREV ) == 0 ) TIFFReverseBits ( ( uint8 * ) tif -> tif_rawdata , tif -> tif_rawcc ) ; if ( ! TIFFAppendToStrip ( tif , isTiled ( tif ) ? tif -> tif_curtile : tif -> tif_curstrip , tif -> tif_rawdata , tif -> tif_rawcc ) ) <S2SV_StartBug> return ( 0 ) ; <S2SV_EndBug> tif -> tif_rawcc = 0 ; tif -> tif_rawcp = tif -> tif_rawdata ; } return ( 1 ) ; }
","<S2SV_ModStart> tif_rawcc ) ) { tif -> tif_rawcc = 0 ; tif -> tif_rawcp = tif -> tif_rawdata ; <S2SV_ModStart> 0 ) ; }
"
357,"CWE-125 static mrb_value fiber_switch ( mrb_state * mrb , mrb_value self , mrb_int len , const mrb_value * a , mrb_bool resume , mrb_bool vmexec ) { struct mrb_context * c = fiber_check ( mrb , self ) ; struct mrb_context * old_c = mrb -> c ; <S2SV_StartBug> mrb_value value ; <S2SV_EndBug> <S2SV_StartBug> fiber_check_cfunc ( mrb , c ) ; <S2SV_EndBug> <S2SV_StartBug> if ( resume && c -> status == MRB_FIBER_TRANSFERRED ) { <S2SV_EndBug> mrb_raise ( mrb , E_FIBER_ERROR , ""resuming<S2SV_blank>transferred<S2SV_blank>fiber"" ) ; } <S2SV_StartBug> if ( c -> status == MRB_FIBER_RUNNING || c -> status == MRB_FIBER_RESUMED ) { <S2SV_EndBug> mrb_raise ( mrb , E_FIBER_ERROR , ""double<S2SV_blank>resume<S2SV_blank>(fib)"" ) ; } <S2SV_StartBug> if ( c -> status == MRB_FIBER_TERMINATED ) { <S2SV_EndBug> mrb_raise ( mrb , E_FIBER_ERROR , ""resuming<S2SV_blank>dead<S2SV_blank>fiber"" ) ; } <S2SV_StartBug> mrb -> c -> status = resume ? MRB_FIBER_RESUMED : MRB_FIBER_TRANSFERRED ; <S2SV_EndBug> c -> prev = resume ? mrb -> c : ( c -> prev ? c -> prev : mrb -> root_c ) ; <S2SV_StartBug> if ( c -> status == MRB_FIBER_CREATED ) { <S2SV_EndBug> mrb_value * b , * e ; <S2SV_StartBug> if ( len >= c -> stend - c -> stack ) { <S2SV_EndBug> mrb_raise ( mrb , E_FIBER_ERROR , ""too<S2SV_blank>many<S2SV_blank>arguments<S2SV_blank>to<S2SV_blank>fiber"" ) ; } b = c -> stack + 1 ; e = b + len ; while ( b < e ) { * b ++ = * a ++ ; } c -> cibase -> argc = ( int ) len ; value = c -> stack [ 0 ] = MRB_PROC_ENV ( c -> ci -> proc ) -> stack [ 0 ] ; } else { value = fiber_result ( mrb , a , len ) ; } <S2SV_StartBug> fiber_switch_context ( mrb , c ) ; <S2SV_EndBug> if ( vmexec ) { c -> vmexec = TRUE ; value = mrb_vm_exec ( mrb , c -> ci [ - 1 ] . proc , c -> ci -> pc ) ; mrb -> c = old_c ; } else { MARK_CONTEXT_MODIFY ( c ) ; } return value ; }
","<S2SV_ModStart> -> c ; enum mrb_fiber_state status ; <S2SV_ModStart> , c ) ; status = c -> status <S2SV_ModStart> ( resume && <S2SV_ModEnd> status == MRB_FIBER_TRANSFERRED <S2SV_ModStart> } if ( <S2SV_ModEnd> status == MRB_FIBER_RUNNING <S2SV_ModStart> == MRB_FIBER_RUNNING || <S2SV_ModEnd> status == MRB_FIBER_RESUMED <S2SV_ModStart> } if ( <S2SV_ModEnd> status == MRB_FIBER_TERMINATED <S2SV_ModStart> ) ; } old_c <S2SV_ModEnd> -> status = <S2SV_ModStart> root_c ) ; fiber_switch_context ( mrb , c ) ; if ( <S2SV_ModEnd> status == MRB_FIBER_CREATED <S2SV_ModStart> * e ; mrb_stack_extend ( mrb , len + 2 ) ; <S2SV_ModEnd> b = c <S2SV_ModStart> ) ; } <S2SV_ModEnd> if ( vmexec
"
358,"CWE-190 int mif_validate ( jas_stream_t * in ) { <S2SV_StartBug> uchar buf [ MIF_MAGICLEN ] ; <S2SV_EndBug> uint_fast32_t magic ; int i ; int n ; assert ( JAS_STREAM_MAXPUTBACK >= MIF_MAGICLEN ) ; if ( ( n = jas_stream_read ( in , buf , MIF_MAGICLEN ) ) < 0 ) { return - 1 ; } for ( i = n - 1 ; i >= 0 ; -- i ) { if ( jas_stream_ungetc ( in , buf [ i ] ) == EOF ) { return - 1 ; } } if ( n < MIF_MAGICLEN ) { return - 1 ; } magic = ( JAS_CAST ( uint_fast32_t , buf [ 0 ] ) << 24 ) | ( JAS_CAST ( uint_fast32_t , buf [ 1 ] ) << 16 ) | ( JAS_CAST ( uint_fast32_t , buf [ 2 ] ) << 8 ) | buf [ 3 ] ; if ( magic != MIF_MAGIC ) { return - 1 ; } return 0 ; }
","<S2SV_ModStart> in ) { jas_uchar <S2SV_ModEnd> buf [ MIF_MAGICLEN
"
359,"CWE-125 static int mpeg4_decode_studio_block ( MpegEncContext * s , int32_t block [ 64 ] , int n ) { Mpeg4DecContext * ctx = s -> avctx -> priv_data ; int cc , dct_dc_size , dct_diff , code , j , idx = 1 , group = 0 , run = 0 , additional_code_len , sign , mismatch ; VLC * cur_vlc = & ctx -> studio_intra_tab [ 0 ] ; uint8_t * const scantable = s -> intra_scantable . permutated ; const uint16_t * quant_matrix ; uint32_t flc ; const int min = - 1 * ( 1 << ( s -> avctx -> bits_per_raw_sample + 6 ) ) ; const int max = ( ( 1 << ( s -> avctx -> bits_per_raw_sample + 6 ) ) - 1 ) ; mismatch = 1 ; memset ( block , 0 , 64 * sizeof ( int32_t ) ) ; if ( n < 4 ) { cc = 0 ; dct_dc_size = get_vlc2 ( & s -> gb , ctx -> studio_luma_dc . table , STUDIO_INTRA_BITS , 2 ) ; quant_matrix = s -> intra_matrix ; } else { cc = ( n & 1 ) + 1 ; if ( ctx -> rgb ) dct_dc_size = get_vlc2 ( & s -> gb , ctx -> studio_luma_dc . table , STUDIO_INTRA_BITS , 2 ) ; else dct_dc_size = get_vlc2 ( & s -> gb , ctx -> studio_chroma_dc . table , STUDIO_INTRA_BITS , 2 ) ; quant_matrix = s -> chroma_intra_matrix ; } if ( dct_dc_size < 0 ) { av_log ( s -> avctx , AV_LOG_ERROR , ""illegal<S2SV_blank>dct_dc_size<S2SV_blank>vlc\\n"" ) ; return AVERROR_INVALIDDATA ; } else if ( dct_dc_size == 0 ) { dct_diff = 0 ; } else { dct_diff = get_xbits ( & s -> gb , dct_dc_size ) ; if ( dct_dc_size > 8 ) { if ( ! check_marker ( s -> avctx , & s -> gb , ""dct_dc_size<S2SV_blank>><S2SV_blank>8"" ) ) return AVERROR_INVALIDDATA ; } } s -> last_dc [ cc ] += dct_diff ; if ( s -> mpeg_quant ) block [ 0 ] = s -> last_dc [ cc ] * ( 8 >> s -> intra_dc_precision ) ; else block [ 0 ] = s -> last_dc [ cc ] * ( 8 >> s -> intra_dc_precision ) * ( 8 >> s -> dct_precision ) ; block [ 0 ] = av_clip ( block [ 0 ] , min , max ) ; mismatch ^= block [ 0 ] ; while ( 1 ) { group = get_vlc2 ( & s -> gb , cur_vlc -> table , STUDIO_INTRA_BITS , 2 ) ; if ( group < 0 ) { av_log ( s -> avctx , AV_LOG_ERROR , ""illegal<S2SV_blank>ac<S2SV_blank>coefficient<S2SV_blank>group<S2SV_blank>vlc\\n"" ) ; return AVERROR_INVALIDDATA ; } additional_code_len = ac_state_tab [ group ] [ 0 ] ; cur_vlc = & ctx -> studio_intra_tab [ ac_state_tab [ group ] [ 1 ] ] ; if ( group == 0 ) { break ; } else if ( group >= 1 && group <= 6 ) { run = 1 << additional_code_len ; if ( additional_code_len ) run += get_bits ( & s -> gb , additional_code_len ) ; idx += run ; continue ; } else if ( group >= 7 && group <= 12 ) { code = get_bits ( & s -> gb , additional_code_len ) ; sign = code & 1 ; code >>= 1 ; run = ( 1 << ( additional_code_len - 1 ) ) + code ; idx += run ; <S2SV_StartBug> j = scantable [ idx ++ ] ; <S2SV_EndBug> block [ j ] = sign ? 1 : - 1 ; } else if ( group >= 13 && group <= 20 ) { <S2SV_StartBug> j = scantable [ idx ++ ] ; <S2SV_EndBug> block [ j ] = get_xbits ( & s -> gb , additional_code_len ) ; <S2SV_StartBug> } else if ( group == 21 ) { <S2SV_EndBug> j = scantable [ idx ++ ] ; additional_code_len = s -> avctx -> bits_per_raw_sample + s -> dct_precision + 4 ; flc = get_bits ( & s -> gb , additional_code_len ) ; if ( flc >> ( additional_code_len - 1 ) ) block [ j ] = - 1 * ( ( flc ^ ( ( 1 << additional_code_len ) - 1 ) ) + 1 ) ; else block [ j ] = flc ; } block [ j ] = ( ( 8 * 2 * block [ j ] * quant_matrix [ j ] * s -> qscale ) >> s -> dct_precision ) / 32 ; block [ j ] = av_clip ( block [ j ] , min , max ) ; mismatch ^= block [ j ] ; } block [ 63 ] ^= mismatch & 1 ; return 0 ; }
","<S2SV_ModStart> += run ; if ( idx > 63 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> 20 ) { if ( idx > 63 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> 21 ) { if ( idx > 63 ) return AVERROR_INVALIDDATA ;
"
360,"CWE-119 void unix_notinflight ( struct file * fp ) { struct sock * s = unix_get_socket ( fp ) ; <S2SV_StartBug> if ( s ) { <S2SV_EndBug> <S2SV_StartBug> struct unix_sock * u = unix_sk ( s ) ; <S2SV_EndBug> spin_lock ( & unix_gc_lock ) ; BUG_ON ( list_empty ( & u -> link ) ) ; if ( atomic_long_dec_and_test ( & u -> inflight ) ) list_del_init ( & u -> link ) ; unix_tot_inflight -- ; <S2SV_StartBug> spin_unlock ( & unix_gc_lock ) ; <S2SV_EndBug> } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> fp ) ; spin_lock ( & unix_gc_lock ) ; <S2SV_ModStart> unix_sk ( s <S2SV_ModEnd> ) ; BUG_ON <S2SV_ModStart> unix_tot_inflight -- ; } fp -> f_cred -> user -> unix_inflight -- ; <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
"
361,"CWE-000 static void hub_activate ( struct usb_hub * hub , enum hub_activation_type type ) { struct usb_device * hdev = hub -> hdev ; struct usb_hcd * hcd ; int ret ; int port1 ; int status ; bool need_debounce_delay = false ; unsigned delay ; <S2SV_StartBug> if ( type == HUB_INIT2 ) <S2SV_EndBug> goto init2 ; <S2SV_StartBug> if ( type == HUB_INIT3 ) <S2SV_EndBug> goto init3 ; if ( type != HUB_RESUME ) { if ( hdev -> parent && hub_is_superspeed ( hdev ) ) { ret = usb_control_msg ( hdev , usb_sndctrlpipe ( hdev , 0 ) , HUB_SET_DEPTH , USB_RT_HUB , hdev -> level - 1 , 0 , NULL , 0 , USB_CTRL_SET_TIMEOUT ) ; if ( ret < 0 ) dev_err ( hub -> intfdev , ""set<S2SV_blank>hub<S2SV_blank>depth<S2SV_blank>failed\\n"" ) ; } if ( type == HUB_INIT ) { delay = hub_power_on_good_delay ( hub ) ; hub_power_on ( hub , false ) ; INIT_DELAYED_WORK ( & hub -> init_work , hub_init_func2 ) ; queue_delayed_work ( system_power_efficient_wq , & hub -> init_work , msecs_to_jiffies ( delay ) ) ; usb_autopm_get_interface_no_resume ( to_usb_interface ( hub -> intfdev ) ) ; return ; } else if ( type == HUB_RESET_RESUME ) { hcd = bus_to_hcd ( hdev -> bus ) ; if ( hcd -> driver -> update_hub_device ) { ret = hcd -> driver -> update_hub_device ( hcd , hdev , & hub -> tt , GFP_NOIO ) ; if ( ret < 0 ) { dev_err ( hub -> intfdev , ""Host<S2SV_blank>not<S2SV_blank>"" ""accepting<S2SV_blank>hub<S2SV_blank>info<S2SV_blank>"" ""update.\\n"" ) ; dev_err ( hub -> intfdev , ""LS/FS<S2SV_blank>devices<S2SV_blank>"" ""and<S2SV_blank>hubs<S2SV_blank>may<S2SV_blank>not<S2SV_blank>work<S2SV_blank>"" ""under<S2SV_blank>this<S2SV_blank>hub\\n."" ) ; } } hub_power_on ( hub , true ) ; } else { hub_power_on ( hub , true ) ; } } init2 : for ( port1 = 1 ; port1 <= hdev -> maxchild ; ++ port1 ) { struct usb_port * port_dev = hub -> ports [ port1 - 1 ] ; struct usb_device * udev = port_dev -> child ; u16 portstatus , portchange ; portstatus = portchange = 0 ; status = hub_port_status ( hub , port1 , & portstatus , & portchange ) ; if ( udev || ( portstatus & USB_PORT_STAT_CONNECTION ) ) dev_dbg ( & port_dev -> dev , ""status<S2SV_blank>%04x<S2SV_blank>change<S2SV_blank>%04x\\n"" , portstatus , portchange ) ; if ( ( portstatus & USB_PORT_STAT_ENABLE ) && ( type != HUB_RESUME || ! ( portstatus & USB_PORT_STAT_CONNECTION ) || ! udev || udev -> state == USB_STATE_NOTATTACHED ) ) { portstatus &= ~ USB_PORT_STAT_ENABLE ; if ( ! hub_is_superspeed ( hdev ) ) usb_clear_port_feature ( hdev , port1 , USB_PORT_FEAT_ENABLE ) ; } if ( portchange & USB_PORT_STAT_C_CONNECTION ) { need_debounce_delay = true ; usb_clear_port_feature ( hub -> hdev , port1 , USB_PORT_FEAT_C_CONNECTION ) ; } if ( portchange & USB_PORT_STAT_C_ENABLE ) { need_debounce_delay = true ; usb_clear_port_feature ( hub -> hdev , port1 , USB_PORT_FEAT_C_ENABLE ) ; } if ( portchange & USB_PORT_STAT_C_RESET ) { need_debounce_delay = true ; usb_clear_port_feature ( hub -> hdev , port1 , USB_PORT_FEAT_C_RESET ) ; } if ( ( portchange & USB_PORT_STAT_C_BH_RESET ) && hub_is_superspeed ( hub -> hdev ) ) { need_debounce_delay = true ; usb_clear_port_feature ( hub -> hdev , port1 , USB_PORT_FEAT_C_BH_PORT_RESET ) ; } if ( ! ( portstatus & USB_PORT_STAT_CONNECTION ) || ( portchange & USB_PORT_STAT_C_CONNECTION ) ) clear_bit ( port1 , hub -> removed_bits ) ; if ( ! udev || udev -> state == USB_STATE_NOTATTACHED ) { if ( udev || ( portstatus & USB_PORT_STAT_CONNECTION ) || ( portstatus & USB_PORT_STAT_OVERCURRENT ) ) set_bit ( port1 , hub -> change_bits ) ; } else if ( portstatus & USB_PORT_STAT_ENABLE ) { bool port_resumed = ( portstatus & USB_PORT_STAT_LINK_STATE ) == USB_SS_PORT_LS_U0 ; if ( portchange || ( hub_is_superspeed ( hub -> hdev ) && port_resumed ) ) set_bit ( port1 , hub -> change_bits ) ; } else if ( udev -> persist_enabled ) { # ifdef CONFIG_PM udev -> reset_resume = 1 ; # endif if ( test_bit ( port1 , hub -> power_bits ) ) set_bit ( port1 , hub -> change_bits ) ; } else { usb_set_device_state ( udev , USB_STATE_NOTATTACHED ) ; set_bit ( port1 , hub -> change_bits ) ; } } if ( need_debounce_delay ) { delay = HUB_DEBOUNCE_STABLE ; if ( type == HUB_INIT2 ) { INIT_DELAYED_WORK ( & hub -> init_work , hub_init_func3 ) ; queue_delayed_work ( system_power_efficient_wq , & hub -> init_work , msecs_to_jiffies ( delay ) ) ; <S2SV_StartBug> return ; <S2SV_EndBug> } else { msleep ( delay ) ; } } init3 : hub -> quiescing = 0 ; status = usb_submit_urb ( hub -> urb , GFP_NOIO ) ; if ( status < 0 ) dev_err ( hub -> intfdev , ""activate<S2SV_blank>--><S2SV_blank>%d\\n"" , status ) ; if ( hub -> has_indicators && blinkenlights ) queue_delayed_work ( system_power_efficient_wq , & hub -> leds , LED_CYCLE_PERIOD ) ; kick_hub_wq ( hub ) ; if ( type <= HUB_INIT3 ) usb_autopm_put_interface_async ( to_usb_interface ( hub -> intfdev ) ) ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> type == HUB_INIT2 || type == HUB_INIT3 ) { device_lock ( hub -> intfdev ) ; if ( hub -> disconnected ) { device_unlock ( hub -> intfdev ) ; kref_put ( & hub -> kref , hub_release ) ; return ; } if ( type == HUB_INIT2 <S2SV_ModStart> goto init2 ; goto init3 ; } kref_get ( & hub -> kref ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) ; device_unlock ( hub -> intfdev ) ; <S2SV_ModStart> ) ) ; if ( type == HUB_INIT2 || type == HUB_INIT3 ) device_unlock ( hub -> intfdev ) ; kref_put ( & hub -> kref , hub_release ) ;
"
362,"CWE-20 error_t httpClientAddQueryParam ( HttpClientContext * context , const char_t * name , const char_t * value ) { size_t nameLen ; size_t valueLen ; char_t separator ; char_t * p ; if ( context == NULL || name == NULL ) return ERROR_INVALID_PARAMETER ; if ( name [ 0 ] == '\\0' ) return ERROR_INVALID_PARAMETER ; if ( context -> requestState != HTTP_REQ_STATE_FORMAT_HEADER ) return ERROR_WRONG_STATE ; if ( context -> bufferLen > HTTP_CLIENT_BUFFER_SIZE ) return ERROR_INVALID_SYNTAX ; context -> buffer [ context -> bufferLen ] = '\\0' ; <S2SV_StartBug> p = strchr ( context -> buffer , '<S2SV_blank>' ) ; <S2SV_EndBug> if ( p == NULL ) return ERROR_INVALID_SYNTAX ; p = strpbrk ( p + 1 , ""<S2SV_blank>?"" ) ; if ( p == NULL ) return ERROR_INVALID_SYNTAX ; if ( * p == '?' ) { <S2SV_StartBug> p = strchr ( p + 1 , '<S2SV_blank>' ) ; <S2SV_EndBug> if ( p == NULL ) return ERROR_INVALID_SYNTAX ; separator = '&' ; } else { separator = '?' ; } nameLen = osStrlen ( name ) ; if ( value == NULL ) { if ( ( context -> bufferLen + nameLen + 1 ) > HTTP_CLIENT_BUFFER_SIZE ) return ERROR_BUFFER_OVERFLOW ; osMemmove ( p + nameLen + 1 , p , context -> buffer + context -> bufferLen + 1 - p ) ; p [ 0 ] = separator ; osStrncpy ( p + 1 , name , nameLen ) ; context -> bufferLen += nameLen + 1 ; } else { valueLen = osStrlen ( value ) ; if ( ( context -> bufferLen + nameLen + valueLen + 2 ) > HTTP_CLIENT_BUFFER_SIZE ) return ERROR_BUFFER_OVERFLOW ; osMemmove ( p + nameLen + valueLen + 2 , p , context -> buffer + context -> bufferLen + 1 - p ) ; p [ 0 ] = separator ; osStrncpy ( p + 1 , name , nameLen ) ; p [ nameLen + 1 ] = '=' ; osStrncpy ( p + nameLen + 2 , value , valueLen ) ; context -> bufferLen += nameLen + valueLen + 2 ; } return NO_ERROR ; }
","<S2SV_ModStart> ; p = osStrchr <S2SV_ModEnd> ( context -> <S2SV_ModStart> { p = osStrchr <S2SV_ModEnd> ( p +
"
363,"CWE-191 DECLAREcpFunc ( cpDecodedStrips ) { tsize_t stripsize = TIFFStripSize ( in ) ; tdata_t buf = _TIFFmalloc ( stripsize ) ; ( void ) imagewidth ; ( void ) spp ; if ( buf ) { tstrip_t s , ns = TIFFNumberOfStrips ( in ) ; uint32 row = 0 ; _TIFFmemset ( buf , 0 , stripsize ) ; <S2SV_StartBug> for ( s = 0 ; s < ns ; s ++ ) { <S2SV_EndBug> tsize_t cc = ( row + rowsperstrip > imagelength ) ? TIFFVStripSize ( in , imagelength - row ) : stripsize ; if ( TIFFReadEncodedStrip ( in , s , buf , cc ) < 0 && ! ignore ) { TIFFError ( TIFFFileName ( in ) , ""Error,<S2SV_blank>can\'t<S2SV_blank>read<S2SV_blank>strip<S2SV_blank>%lu"" , ( unsigned long ) s ) ; goto bad ; } if ( TIFFWriteEncodedStrip ( out , s , buf , cc ) < 0 ) { TIFFError ( TIFFFileName ( out ) , ""Error,<S2SV_blank>can\'t<S2SV_blank>write<S2SV_blank>strip<S2SV_blank>%lu"" , ( unsigned long ) s ) ; goto bad ; } row += rowsperstrip ; } _TIFFfree ( buf ) ; return 1 ; } else { TIFFError ( TIFFFileName ( in ) , ""Error,<S2SV_blank>can\'t<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>buffer<S2SV_blank>of<S2SV_blank>size<S2SV_blank>%lu<S2SV_blank>"" ""to<S2SV_blank>read<S2SV_blank>strips"" , ( unsigned long ) stripsize ) ; return 0 ; } bad : _TIFFfree ( buf ) ; return 0 ; }
","<S2SV_ModStart> s < ns && row < imagelength
"
364,"CWE-119 <S2SV_StartBug> static void encode_txfm_probs ( VP9_COMMON * cm , vp9_writer * w ) { <S2SV_EndBug> vp9_write_literal ( w , MIN ( cm -> tx_mode , ALLOW_32X32 ) , 2 ) ; if ( cm -> tx_mode >= ALLOW_32X32 ) <S2SV_StartBug> vp9_write_bit ( w , cm -> tx_mode == TX_MODE_SELECT ) ; <S2SV_EndBug> if ( cm -> tx_mode == TX_MODE_SELECT ) { int i , j ; unsigned int ct_8x8p [ TX_SIZES - 3 ] [ 2 ] ; unsigned int ct_16x16p [ TX_SIZES - 2 ] [ 2 ] ; unsigned int ct_32x32p [ TX_SIZES - 1 ] [ 2 ] ; for ( i = 0 ; i < TX_SIZE_CONTEXTS ; i ++ ) { <S2SV_StartBug> tx_counts_to_branch_counts_8x8 ( cm -> counts . tx . p8x8 [ i ] , ct_8x8p ) ; <S2SV_EndBug> for ( j = 0 ; j < TX_SIZES - 3 ; j ++ ) <S2SV_StartBug> vp9_cond_prob_diff_update ( w , & cm -> fc . tx_probs . p8x8 [ i ] [ j ] , ct_8x8p [ j ] ) ; <S2SV_EndBug> } for ( i = 0 ; i < TX_SIZE_CONTEXTS ; i ++ ) { <S2SV_StartBug> tx_counts_to_branch_counts_16x16 ( cm -> counts . tx . p16x16 [ i ] , ct_16x16p ) ; <S2SV_EndBug> for ( j = 0 ; j < TX_SIZES - 2 ; j ++ ) <S2SV_StartBug> vp9_cond_prob_diff_update ( w , & cm -> fc . tx_probs . p16x16 [ i ] [ j ] , <S2SV_EndBug> ct_16x16p [ j ] ) ; } for ( i = 0 ; i < TX_SIZE_CONTEXTS ; i ++ ) { <S2SV_StartBug> tx_counts_to_branch_counts_32x32 ( cm -> counts . tx . p32x32 [ i ] , ct_32x32p ) ; <S2SV_EndBug> for ( j = 0 ; j < TX_SIZES - 1 ; j ++ ) <S2SV_StartBug> vp9_cond_prob_diff_update ( w , & cm -> fc . tx_probs . p32x32 [ i ] [ j ] , <S2SV_EndBug> ct_32x32p [ j ] ) ; } } }
","<S2SV_ModStart> * cm , vpx_writer * w , FRAME_COUNTS * counts ) { vpx_write_literal <S2SV_ModEnd> ( w , <S2SV_ModStart> >= ALLOW_32X32 ) vpx_write_bit <S2SV_ModEnd> ( w , <S2SV_ModStart> { tx_counts_to_branch_counts_8x8 ( counts -> <S2SV_ModEnd> tx . p8x8 <S2SV_ModStart> cm -> fc -> <S2SV_ModEnd> tx_probs . p8x8 <S2SV_ModStart> { tx_counts_to_branch_counts_16x16 ( counts -> <S2SV_ModEnd> tx . p16x16 <S2SV_ModStart> cm -> fc -> <S2SV_ModEnd> tx_probs . p16x16 <S2SV_ModStart> { tx_counts_to_branch_counts_32x32 ( counts -> <S2SV_ModEnd> tx . p32x32 <S2SV_ModStart> cm -> fc -> <S2SV_ModEnd> tx_probs . p32x32
"
365,"CWE-119 static int cmd_mount ( void * data , const char * _input ) { ut64 off = 0 ; char * input , * oinput , * ptr , * ptr2 ; RList * list ; RListIter * iter ; RFSFile * file ; RFSRoot * root ; RFSPlugin * plug ; RFSPartition * part ; RCore * core = ( RCore * ) data ; if ( ! strncmp ( ""kdir"" , _input , 4 ) ) { return cmd_mkdir ( data , _input ) ; } if ( ! strncmp ( ""v"" , _input , 1 ) ) { return cmd_mv ( data , _input ) ; } input = oinput = strdup ( _input ) ; switch ( * input ) { case '<S2SV_blank>' : input ++ ; if ( input [ 0 ] == '<S2SV_blank>' ) <S2SV_StartBug> input ++ ; <S2SV_EndBug> ptr = strchr ( input , '<S2SV_blank>' ) ; if ( ptr ) { * ptr = 0 ; ptr ++ ; ptr2 = strchr ( ptr , '<S2SV_blank>' ) ; if ( ptr2 ) { * ptr2 = 0 ; off = r_num_math ( core -> num , ptr2 + 1 ) ; } <S2SV_StartBug> if ( ! r_fs_mount ( core -> fs , ptr , input , off ) ) <S2SV_EndBug> eprintf ( ""Cannot<S2SV_blank>mount<S2SV_blank>%s\\n"" , input ) ; <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( ! ( ptr = r_fs_name ( core -> fs , core -> offset ) ) ) <S2SV_EndBug> eprintf ( ""Unknown<S2SV_blank>filesystem<S2SV_blank>type\\n"" ) ; <S2SV_StartBug> else if ( ! r_fs_mount ( core -> fs , ptr , input , core -> offset ) ) <S2SV_EndBug> <S2SV_StartBug> eprintf ( ""Cannot<S2SV_blank>mount<S2SV_blank>%s\\n"" , input ) ; <S2SV_EndBug> free ( ptr ) ; } break ; case '-' : r_fs_umount ( core -> fs , input + 1 ) ; break ; case '*' : eprintf ( ""List<S2SV_blank>commands<S2SV_blank>in<S2SV_blank>radare<S2SV_blank>format\\n"" ) ; r_list_foreach ( core -> fs -> roots , iter , root ) { r_cons_printf ( ""m<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>0x%"" PFMT64x ""\\n"" , root -> path , root -> p -> name , root -> delta ) ; } break ; case '\\0' : r_list_foreach ( core -> fs -> roots , iter , root ) { r_cons_printf ( ""%s\\t0x%"" PFMT64x ""\\t%s\\n"" , root -> p -> name , root -> delta , root -> path ) ; } break ; case 'l' : r_list_foreach ( core -> fs -> plugins , iter , plug ) { r_cons_printf ( ""%10s<S2SV_blank><S2SV_blank>%s\\n"" , plug -> name , plug -> desc ) ; } break ; case 'd' : input ++ ; if ( input [ 0 ] == '<S2SV_blank>' ) input ++ ; list = r_fs_dir ( core -> fs , input ) ; if ( list ) { r_list_foreach ( list , iter , file ) { r_cons_printf ( ""%c<S2SV_blank>%s\\n"" , file -> type , file -> name ) ; } r_list_free ( list ) ; } else eprintf ( ""Cannot<S2SV_blank>open<S2SV_blank>\'%s\'<S2SV_blank>directory\\n"" , input ) ; break ; case 'p' : input ++ ; if ( * input == '<S2SV_blank>' ) input ++ ; ptr = strchr ( input , '<S2SV_blank>' ) ; if ( ptr ) { * ptr = 0 ; off = r_num_math ( core -> num , ptr + 1 ) ; } list = r_fs_partitions ( core -> fs , input , off ) ; if ( list ) { r_list_foreach ( list , iter , part ) { r_cons_printf ( ""%d<S2SV_blank>%02x<S2SV_blank>0x%010"" PFMT64x ""<S2SV_blank>0x%010"" PFMT64x ""\\n"" , part -> number , part -> type , part -> start , part -> start + part -> length ) ; } r_list_free ( list ) ; } else eprintf ( ""Cannot<S2SV_blank>read<S2SV_blank>partition\\n"" ) ; break ; case 'o' : input ++ ; if ( input [ 0 ] == '<S2SV_blank>' ) input ++ ; file = r_fs_open ( core -> fs , input ) ; if ( file ) { r_fs_read ( core -> fs , file , 0 , file -> size ) ; r_cons_printf ( ""f<S2SV_blank>file<S2SV_blank>%d<S2SV_blank>0x%08"" PFMT64x ""\\n"" , file -> size , file -> off ) ; r_fs_close ( core -> fs , file ) ; } else eprintf ( ""Cannot<S2SV_blank>open<S2SV_blank>file\\n"" ) ; break ; case 'g' : input ++ ; if ( * input == '<S2SV_blank>' ) input ++ ; ptr = strchr ( input , '<S2SV_blank>' ) ; if ( ptr ) * ptr ++ = 0 ; else ptr = ""./"" ; file = r_fs_open ( core -> fs , input ) ; if ( file ) { r_fs_read ( core -> fs , file , 0 , file -> size ) ; write ( 1 , file -> data , file -> size ) ; r_fs_close ( core -> fs , file ) ; write ( 1 , ""\\n"" , 1 ) ; } else if ( ! r_fs_dir_dump ( core -> fs , input , ptr ) ) eprintf ( ""Cannot<S2SV_blank>open<S2SV_blank>file\\n"" ) ; break ; case 'f' : input ++ ; switch ( * input ) { case '?' : r_cons_printf ( ""Usage:<S2SV_blank>mf[no]<S2SV_blank>[...]\\n"" ""<S2SV_blank>mfn<S2SV_blank>/foo<S2SV_blank>*.c<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>;<S2SV_blank>search<S2SV_blank>files<S2SV_blank>by<S2SV_blank>name<S2SV_blank>in<S2SV_blank>/foo<S2SV_blank>path\\n"" ""<S2SV_blank>mfo<S2SV_blank>/foo<S2SV_blank>0x5e91<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>;<S2SV_blank>search<S2SV_blank>files<S2SV_blank>by<S2SV_blank>offset<S2SV_blank>in<S2SV_blank>/foo<S2SV_blank>path\\n"" ) ; break ; case 'n' : input ++ ; if ( * input == '<S2SV_blank>' ) input ++ ; ptr = strchr ( input , '<S2SV_blank>' ) ; if ( ptr ) { * ptr ++ = 0 ; list = r_fs_find_name ( core -> fs , input , ptr ) ; r_list_foreach ( list , iter , ptr ) { r_str_chop_path ( ptr ) ; printf ( ""%s\\n"" , ptr ) ; } } else eprintf ( ""Unknown<S2SV_blank>store<S2SV_blank>path\\n"" ) ; break ; case 'o' : input ++ ; if ( * input == '<S2SV_blank>' ) input ++ ; ptr = strchr ( input , '<S2SV_blank>' ) ; if ( ptr ) { * ptr ++ = 0 ; ut64 off = r_num_math ( core -> num , ptr ) ; list = r_fs_find_off ( core -> fs , input , off ) ; r_list_foreach ( list , iter , ptr ) { r_str_chop_path ( ptr ) ; printf ( ""%s\\n"" , ptr ) ; } } else eprintf ( ""Unknown<S2SV_blank>store<S2SV_blank>path\\n"" ) ; break ; } break ; case 's' : if ( core -> http_up ) { free ( oinput ) ; return false ; } input ++ ; if ( input [ 0 ] == '<S2SV_blank>' ) input ++ ; r_fs_prompt ( core -> fs , input ) ; break ; case 'y' : eprintf ( ""TODO\\n"" ) ; break ; case '?' : { const char * help_msg [ ] = { ""Usage:"" , ""m[-?*dgy]<S2SV_blank>[...]<S2SV_blank>"" , ""Mountpoints<S2SV_blank>management"" , ""m"" , """" , ""List<S2SV_blank>all<S2SV_blank>mountpoints<S2SV_blank>in<S2SV_blank>human<S2SV_blank>readable<S2SV_blank>format"" , ""m*"" , """" , ""Same<S2SV_blank>as<S2SV_blank>above,<S2SV_blank>but<S2SV_blank>in<S2SV_blank>r2<S2SV_blank>commands"" , ""ml"" , """" , ""List<S2SV_blank>filesystem<S2SV_blank>plugins"" , ""m"" , ""<S2SV_blank>/mnt"" , ""Mount<S2SV_blank>fs<S2SV_blank>at<S2SV_blank>/mnt<S2SV_blank>with<S2SV_blank>autodetect<S2SV_blank>fs<S2SV_blank>and<S2SV_blank>current<S2SV_blank>offset"" , ""m"" , ""<S2SV_blank>/mnt<S2SV_blank>ext2<S2SV_blank>0"" , ""Mount<S2SV_blank>ext2<S2SV_blank>fs<S2SV_blank>at<S2SV_blank>/mnt<S2SV_blank>with<S2SV_blank>delta<S2SV_blank>0<S2SV_blank>on<S2SV_blank>IO"" , ""m-/"" , """" , ""Umount<S2SV_blank>given<S2SV_blank>path<S2SV_blank>(/)"" , ""my"" , """" , ""Yank<S2SV_blank>contents<S2SV_blank>of<S2SV_blank>file<S2SV_blank>into<S2SV_blank>clipboard"" , ""mo"" , ""<S2SV_blank>/foo"" , ""Get<S2SV_blank>offset<S2SV_blank>and<S2SV_blank>size<S2SV_blank>of<S2SV_blank>given<S2SV_blank>file"" , ""mg"" , ""<S2SV_blank>/foo"" , ""Get<S2SV_blank>contents<S2SV_blank>of<S2SV_blank>file/dir<S2SV_blank>dumped<S2SV_blank>to<S2SV_blank>disk<S2SV_blank>(XXX?)"" , ""mf"" , ""[?]<S2SV_blank>[o|n]"" , ""Search<S2SV_blank>files<S2SV_blank>for<S2SV_blank>given<S2SV_blank>filename<S2SV_blank>or<S2SV_blank>for<S2SV_blank>offset"" , ""md"" , ""<S2SV_blank>/"" , ""List<S2SV_blank>directory<S2SV_blank>contents<S2SV_blank>for<S2SV_blank>path"" , ""mp"" , """" , ""List<S2SV_blank>all<S2SV_blank>supported<S2SV_blank>partition<S2SV_blank>types"" , ""mp"" , ""<S2SV_blank>msdos<S2SV_blank>0"" , ""Show<S2SV_blank>partitions<S2SV_blank>in<S2SV_blank>msdos<S2SV_blank>format<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>0"" , ""ms"" , ""<S2SV_blank>/mnt"" , ""Open<S2SV_blank>filesystem<S2SV_blank>prompt<S2SV_blank>at<S2SV_blank>/mnt"" , NULL } ; r_core_cmd_help ( core , help_msg ) ; } break ; } free ( oinput ) ; return 0 ; }
","<S2SV_ModStart> == '<S2SV_blank>' ) { input ++ ; } <S2SV_ModEnd> ptr = strchr <S2SV_ModStart> off ) ) { <S2SV_ModStart> ) ; } } <S2SV_ModStart> ) ) ) { <S2SV_ModStart> ""Unknown<S2SV_blank>filesystem<S2SV_blank>type\\n"" ) ; } <S2SV_ModStart> offset ) ) { <S2SV_ModStart> input ) ; }
"
366,"CWE-415 static BOOL GetStartupData ( HANDLE pipe , STARTUP_DATA * sud ) { size_t size , len ; <S2SV_StartBug> BOOL ret = FALSE ; <S2SV_EndBug> WCHAR * data = NULL ; DWORD bytes , read ; bytes = PeekNamedPipeAsync ( pipe , 1 , & exit_event ) ; if ( bytes == 0 ) { MsgToEventLog ( M_SYSERR , TEXT ( ""PeekNamedPipeAsync<S2SV_blank>failed"" ) ) ; ReturnLastError ( pipe , L""PeekNamedPipeAsync"" ) ; <S2SV_StartBug> goto out ; <S2SV_EndBug> } size = bytes / sizeof ( * data ) ; if ( size == 0 ) { MsgToEventLog ( M_SYSERR , TEXT ( ""malformed<S2SV_blank>startup<S2SV_blank>data:<S2SV_blank>1<S2SV_blank>byte<S2SV_blank>received"" ) ) ; ReturnError ( pipe , ERROR_STARTUP_DATA , L""GetStartupData"" , 1 , & exit_event ) ; <S2SV_StartBug> goto out ; <S2SV_EndBug> } data = malloc ( bytes ) ; if ( data == NULL ) { MsgToEventLog ( M_SYSERR , TEXT ( ""malloc<S2SV_blank>failed"" ) ) ; ReturnLastError ( pipe , L""malloc"" ) ; <S2SV_StartBug> goto out ; <S2SV_EndBug> } read = ReadPipeAsync ( pipe , data , bytes , 1 , & exit_event ) ; if ( bytes != read ) { MsgToEventLog ( M_SYSERR , TEXT ( ""ReadPipeAsync<S2SV_blank>failed"" ) ) ; ReturnLastError ( pipe , L""ReadPipeAsync"" ) ; <S2SV_StartBug> goto out ; <S2SV_EndBug> } if ( data [ size - 1 ] != 0 ) { MsgToEventLog ( M_ERR , TEXT ( ""Startup<S2SV_blank>data<S2SV_blank>is<S2SV_blank>not<S2SV_blank>NULL<S2SV_blank>terminated"" ) ) ; ReturnError ( pipe , ERROR_STARTUP_DATA , L""GetStartupData"" , 1 , & exit_event ) ; <S2SV_StartBug> goto out ; <S2SV_EndBug> } sud -> directory = data ; len = wcslen ( sud -> directory ) + 1 ; size -= len ; if ( size <= 0 ) { MsgToEventLog ( M_ERR , TEXT ( ""Startup<S2SV_blank>data<S2SV_blank>ends<S2SV_blank>at<S2SV_blank>working<S2SV_blank>directory"" ) ) ; ReturnError ( pipe , ERROR_STARTUP_DATA , L""GetStartupData"" , 1 , & exit_event ) ; <S2SV_StartBug> goto out ; <S2SV_EndBug> } sud -> options = sud -> directory + len ; len = wcslen ( sud -> options ) + 1 ; size -= len ; if ( size <= 0 ) { MsgToEventLog ( M_ERR , TEXT ( ""Startup<S2SV_blank>data<S2SV_blank>ends<S2SV_blank>at<S2SV_blank>command<S2SV_blank>line<S2SV_blank>options"" ) ) ; ReturnError ( pipe , ERROR_STARTUP_DATA , L""GetStartupData"" , 1 , & exit_event ) ; <S2SV_StartBug> goto out ; <S2SV_EndBug> } sud -> std_input = sud -> options + len ; <S2SV_StartBug> data = NULL ; <S2SV_EndBug> <S2SV_StartBug> ret = TRUE ; <S2SV_EndBug> out : free ( data ) ; <S2SV_StartBug> return ret ; <S2SV_EndBug> }
","<S2SV_ModStart> , len ; <S2SV_ModEnd> WCHAR * data <S2SV_ModStart> ) ; goto err <S2SV_ModEnd> ; } size <S2SV_ModStart> ) ; goto err <S2SV_ModEnd> ; } data <S2SV_ModStart> ) ; goto err <S2SV_ModEnd> ; } read <S2SV_ModStart> ) ; goto err <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ; goto err <S2SV_ModEnd> ; } sud <S2SV_ModStart> ) ; goto err <S2SV_ModEnd> ; } sud <S2SV_ModStart> ) ; goto err <S2SV_ModEnd> ; } sud <S2SV_ModStart> + len ; return TRUE ; err : sud -> directory <S2SV_ModEnd> = NULL ; <S2SV_ModStart> = NULL ; <S2SV_ModEnd> free ( data <S2SV_ModStart> ) ; return FALSE <S2SV_ModEnd> ; } <S2SV_null>
"
367,"CWE-787 int mwifiex_ret_wmm_get_status ( struct mwifiex_private * priv , const struct host_cmd_ds_command * resp ) { u8 * curr = ( u8 * ) & resp -> params . get_wmm_status ; uint16_t resp_len = le16_to_cpu ( resp -> size ) , tlv_len ; int mask = IEEE80211_WMM_IE_AP_QOSINFO_PARAM_SET_CNT_MASK ; bool valid = true ; struct mwifiex_ie_types_data * tlv_hdr ; struct mwifiex_ie_types_wmm_queue_status * tlv_wmm_qstatus ; struct ieee_types_wmm_parameter * wmm_param_ie = NULL ; struct mwifiex_wmm_ac_status * ac_status ; mwifiex_dbg ( priv -> adapter , INFO , ""info:<S2SV_blank>WMM:<S2SV_blank>WMM_GET_STATUS<S2SV_blank>cmdresp<S2SV_blank>received:<S2SV_blank>%d\\n"" , resp_len ) ; while ( ( resp_len >= sizeof ( tlv_hdr -> header ) ) && valid ) { tlv_hdr = ( struct mwifiex_ie_types_data * ) curr ; tlv_len = le16_to_cpu ( tlv_hdr -> header . len ) ; if ( resp_len < tlv_len + sizeof ( tlv_hdr -> header ) ) break ; switch ( le16_to_cpu ( tlv_hdr -> header . type ) ) { case TLV_TYPE_WMMQSTATUS : tlv_wmm_qstatus = ( struct mwifiex_ie_types_wmm_queue_status * ) tlv_hdr ; mwifiex_dbg ( priv -> adapter , CMD , ""info:<S2SV_blank>CMD_RESP:<S2SV_blank>WMM_GET_STATUS:\\t"" ""QSTATUS<S2SV_blank>TLV:<S2SV_blank>%d,<S2SV_blank>%d,<S2SV_blank>%d\\n"" , tlv_wmm_qstatus -> queue_index , tlv_wmm_qstatus -> flow_required , tlv_wmm_qstatus -> disabled ) ; ac_status = & priv -> wmm . ac_status [ tlv_wmm_qstatus -> queue_index ] ; ac_status -> disabled = tlv_wmm_qstatus -> disabled ; ac_status -> flow_required = tlv_wmm_qstatus -> flow_required ; ac_status -> flow_created = tlv_wmm_qstatus -> flow_created ; break ; case WLAN_EID_VENDOR_SPECIFIC : wmm_param_ie = ( struct ieee_types_wmm_parameter * ) ( curr + 2 ) ; wmm_param_ie -> vend_hdr . len = ( u8 ) tlv_len ; wmm_param_ie -> vend_hdr . element_id = WLAN_EID_VENDOR_SPECIFIC ; mwifiex_dbg ( priv -> adapter , CMD , ""info:<S2SV_blank>CMD_RESP:<S2SV_blank>WMM_GET_STATUS:\\t"" ""WMM<S2SV_blank>Parameter<S2SV_blank>Set<S2SV_blank>Count:<S2SV_blank>%d\\n"" , wmm_param_ie -> qos_info_bitmap & mask ) ; <S2SV_StartBug> memcpy ( ( u8 * ) & priv -> curr_bss_params . bss_descriptor . <S2SV_EndBug> wmm_ie , wmm_param_ie , wmm_param_ie -> vend_hdr . len + 2 ) ; break ; default : valid = false ; break ; } curr += ( tlv_len + sizeof ( tlv_hdr -> header ) ) ; resp_len -= ( tlv_len + sizeof ( tlv_hdr -> header ) ) ; } mwifiex_wmm_setup_queue_priorities ( priv , wmm_param_ie ) ; mwifiex_wmm_setup_ac_downgrade ( priv ) ; return 0 ; }
","<S2SV_ModStart> mask ) ; if ( wmm_param_ie -> vend_hdr . len + 2 > sizeof ( struct ieee_types_wmm_parameter ) ) break ;
"
368,"CWE-200 int readfile ( char_u * fname , char_u * sfname , linenr_T from , linenr_T lines_to_skip , linenr_T lines_to_read , exarg_T * eap , int flags ) { int fd = 0 ; int newfile = ( flags & READ_NEW ) ; int check_readonly ; int filtering = ( flags & READ_FILTER ) ; int read_stdin = ( flags & READ_STDIN ) ; int read_buffer = ( flags & READ_BUFFER ) ; int read_fifo = ( flags & READ_FIFO ) ; int set_options = newfile || read_buffer || ( eap != NULL && eap -> read_edit ) ; linenr_T read_buf_lnum = 1 ; colnr_T read_buf_col = 0 ; char_u c ; linenr_T lnum = from ; char_u * ptr = NULL ; char_u * buffer = NULL ; char_u * new_buffer = NULL ; char_u * line_start = NULL ; int wasempty ; colnr_T len ; long size = 0 ; char_u * p ; off_T filesize = 0 ; int skip_read = FALSE ; # ifdef FEAT_CRYPT char_u * cryptkey = NULL ; int did_ask_for_key = FALSE ; # endif # ifdef FEAT_PERSISTENT_UNDO context_sha256_T sha_ctx ; int read_undo_file = FALSE ; # endif int split = 0 ; # define UNKNOWN 0x0fffffff linenr_T linecnt ; int error = FALSE ; int ff_error = EOL_UNKNOWN ; long linerest = 0 ; # ifdef UNIX int perm = 0 ; int swap_mode = - 1 ; # else int perm ; # endif int fileformat = 0 ; int keep_fileformat = FALSE ; stat_T st ; int file_readonly ; linenr_T skip_count = 0 ; linenr_T read_count = 0 ; int msg_save = msg_scroll ; linenr_T read_no_eol_lnum = 0 ; int try_mac ; int try_dos ; int try_unix ; int file_rewind = FALSE ; # ifdef FEAT_MBYTE int can_retry ; linenr_T conv_error = 0 ; linenr_T illegal_byte = 0 ; int keep_dest_enc = FALSE ; int bad_char_behavior = BAD_REPLACE ; char_u * tmpname = NULL ; int fio_flags = 0 ; char_u * fenc ; int fenc_alloced ; char_u * fenc_next = NULL ; int advance_fenc = FALSE ; long real_size = 0 ; # ifdef USE_ICONV iconv_t iconv_fd = ( iconv_t ) - 1 ; # ifdef FEAT_EVAL int did_iconv = FALSE ; # endif # endif int converted = FALSE ; int notconverted = FALSE ; char_u conv_rest [ CONV_RESTLEN ] ; int conv_restlen = 0 ; # endif # ifdef FEAT_AUTOCMD buf_T * old_curbuf ; char_u * old_b_ffname ; char_u * old_b_fname ; int using_b_ffname ; int using_b_fname ; # endif # ifdef FEAT_AUTOCMD au_did_filetype = FALSE ; # endif curbuf -> b_no_eol_lnum = 0 ; if ( curbuf -> b_ffname == NULL && ! filtering && fname != NULL && vim_strchr ( p_cpo , CPO_FNAMER ) != NULL && ! ( flags & READ_DUMMY ) ) { if ( set_rw_fname ( fname , sfname ) == FAIL ) return FAIL ; } # ifdef FEAT_AUTOCMD old_curbuf = curbuf ; old_b_ffname = curbuf -> b_ffname ; old_b_fname = curbuf -> b_fname ; using_b_ffname = ( fname == curbuf -> b_ffname ) || ( sfname == curbuf -> b_ffname ) ; using_b_fname = ( fname == curbuf -> b_fname ) || ( sfname == curbuf -> b_fname ) ; # endif ex_no_reprint = TRUE ; need_fileinfo = FALSE ; if ( sfname == NULL ) sfname = fname ; # if defined ( UNIX ) fname = sfname ; # endif # ifdef FEAT_AUTOCMD if ( ! filtering && ! read_stdin && ! read_buffer ) { pos_T pos ; pos = curbuf -> b_op_start ; curbuf -> b_op_start . lnum = ( ( from == 0 ) ? 1 : from ) ; curbuf -> b_op_start . col = 0 ; if ( newfile ) { if ( apply_autocmds_exarg ( EVENT_BUFREADCMD , NULL , sfname , FALSE , curbuf , eap ) ) # ifdef FEAT_EVAL return aborting ( ) ? FAIL : OK ; # else return OK ; # endif } else if ( apply_autocmds_exarg ( EVENT_FILEREADCMD , sfname , sfname , FALSE , NULL , eap ) ) # ifdef FEAT_EVAL return aborting ( ) ? FAIL : OK ; # else return OK ; # endif curbuf -> b_op_start = pos ; } # endif if ( ( shortmess ( SHM_OVER ) || curbuf -> b_help ) && p_verbose == 0 ) msg_scroll = FALSE ; else msg_scroll = TRUE ; if ( fname != NULL && * fname != NUL ) { p = fname + STRLEN ( fname ) ; if ( after_pathsep ( fname , p ) || STRLEN ( fname ) >= MAXPATHL ) { filemess ( curbuf , fname , ( char_u * ) _ ( ""Illegal<S2SV_blank>file<S2SV_blank>name"" ) , 0 ) ; msg_end ( ) ; msg_scroll = msg_save ; return FAIL ; } } if ( ! read_stdin && ! read_buffer && ! read_fifo ) { # ifdef UNIX perm = mch_getperm ( fname ) ; if ( perm >= 0 && ! S_ISREG ( perm ) # ifdef S_ISFIFO && ! S_ISFIFO ( perm ) # endif # ifdef S_ISSOCK && ! S_ISSOCK ( perm ) # endif # ifdef OPEN_CHR_FILES && ! ( S_ISCHR ( perm ) && is_dev_fd_file ( fname ) ) # endif ) { int retval = FAIL ; if ( S_ISDIR ( perm ) ) { filemess ( curbuf , fname , ( char_u * ) _ ( ""is<S2SV_blank>a<S2SV_blank>directory"" ) , 0 ) ; retval = NOTDONE ; } else filemess ( curbuf , fname , ( char_u * ) _ ( ""is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>file"" ) , 0 ) ; msg_end ( ) ; msg_scroll = msg_save ; return retval ; } # endif # if defined ( MSWIN ) if ( ! p_odev && mch_nodetype ( fname ) == NODE_WRITABLE ) { filemess ( curbuf , fname , ( char_u * ) _ ( ""is<S2SV_blank>a<S2SV_blank>device<S2SV_blank>(disabled<S2SV_blank>with<S2SV_blank>\'opendevice\'<S2SV_blank>option)"" ) , 0 ) ; msg_end ( ) ; msg_scroll = msg_save ; return FAIL ; } # endif } set_file_options ( set_options , eap ) ; check_readonly = ( newfile && ( curbuf -> b_flags & BF_CHECK_RO ) ) ; if ( check_readonly && ! readonlymode ) curbuf -> b_p_ro = FALSE ; if ( newfile && ! read_stdin && ! read_buffer && ! read_fifo ) { if ( mch_stat ( ( char * ) fname , & st ) >= 0 ) { buf_store_time ( curbuf , & st , fname ) ; curbuf -> b_mtime_read = curbuf -> b_mtime ; # ifdef UNIX swap_mode = ( st . st_mode & 0644 ) | 0600 ; # endif # ifdef FEAT_CW_EDITOR ( void ) GetFSSpecFromPath ( curbuf -> b_ffname , & curbuf -> b_FSSpec ) ; # endif # ifdef VMS curbuf -> b_fab_rfm = st . st_fab_rfm ; curbuf -> b_fab_rat = st . st_fab_rat ; curbuf -> b_fab_mrs = st . st_fab_mrs ; # endif } else { curbuf -> b_mtime = 0 ; curbuf -> b_mtime_read = 0 ; curbuf -> b_orig_size = 0 ; curbuf -> b_orig_mode = 0 ; } curbuf -> b_flags &= ~ ( BF_NEW | BF_NEW_W ) ; } file_readonly = FALSE ; if ( read_stdin ) { # if defined ( MSWIN ) setmode ( 0 , O_BINARY ) ; # endif } else if ( ! read_buffer ) { # ifdef USE_MCH_ACCESS if ( # ifdef UNIX ! ( perm & 0222 ) || # endif mch_access ( ( char * ) fname , W_OK ) ) file_readonly = TRUE ; fd = mch_open ( ( char * ) fname , O_RDONLY | O_EXTRA , 0 ) ; # else if ( ! newfile || readonlymode || ( fd = mch_open ( ( char * ) fname , O_RDWR | O_EXTRA , 0 ) ) < 0 ) { file_readonly = TRUE ; fd = mch_open ( ( char * ) fname , O_RDONLY | O_EXTRA , 0 ) ; } # endif } if ( fd < 0 ) { # ifndef UNIX int isdir_f ; # endif msg_scroll = msg_save ; # ifndef UNIX isdir_f = ( mch_isdir ( fname ) ) ; perm = mch_getperm ( fname ) ; if ( isdir_f ) { filemess ( curbuf , sfname , ( char_u * ) _ ( ""is<S2SV_blank>a<S2SV_blank>directory"" ) , 0 ) ; curbuf -> b_p_ro = TRUE ; } else # endif if ( newfile ) { if ( perm < 0 # ifdef ENOENT && errno == ENOENT # endif ) { curbuf -> b_flags |= BF_NEW ; # ifdef FEAT_QUICKFIX if ( ! bt_dontwrite ( curbuf ) ) # endif { check_need_swap ( newfile ) ; # ifdef FEAT_AUTOCMD if ( curbuf != old_curbuf || ( using_b_ffname && ( old_b_ffname != curbuf -> b_ffname ) ) || ( using_b_fname && ( old_b_fname != curbuf -> b_fname ) ) ) { EMSG ( _ ( e_auchangedbuf ) ) ; return FAIL ; } # endif } if ( dir_of_file_exists ( fname ) ) filemess ( curbuf , sfname , ( char_u * ) _ ( ""[New<S2SV_blank>File]"" ) , 0 ) ; else filemess ( curbuf , sfname , ( char_u * ) _ ( ""[New<S2SV_blank>DIRECTORY]"" ) , 0 ) ; # ifdef FEAT_VIMINFO check_marks_read ( ) ; # endif # ifdef FEAT_MBYTE if ( eap != NULL ) set_forced_fenc ( eap ) ; # endif # ifdef FEAT_AUTOCMD apply_autocmds_exarg ( EVENT_BUFNEWFILE , sfname , sfname , FALSE , curbuf , eap ) ; # endif save_file_ff ( curbuf ) ; # if defined ( FEAT_AUTOCMD ) && defined ( FEAT_EVAL ) if ( aborting ( ) ) return FAIL ; # endif return OK ; } else { filemess ( curbuf , sfname , ( char_u * ) ( # ifdef EFBIG ( errno == EFBIG ) ? _ ( ""[File<S2SV_blank>too<S2SV_blank>big]"" ) : # endif # ifdef EOVERFLOW ( errno == EOVERFLOW ) ? _ ( ""[File<S2SV_blank>too<S2SV_blank>big]"" ) : # endif _ ( ""[Permission<S2SV_blank>Denied]"" ) ) , 0 ) ; curbuf -> b_p_ro = TRUE ; } } return FAIL ; } if ( ( check_readonly && file_readonly ) || curbuf -> b_help ) curbuf -> b_p_ro = TRUE ; if ( set_options ) { if ( ! read_buffer ) { curbuf -> b_p_eol = TRUE ; curbuf -> b_start_eol = TRUE ; } # ifdef FEAT_MBYTE curbuf -> b_p_bomb = FALSE ; curbuf -> b_start_bomb = FALSE ; # endif } # ifdef FEAT_QUICKFIX if ( ! bt_dontwrite ( curbuf ) ) # endif { check_need_swap ( newfile ) ; # ifdef FEAT_AUTOCMD if ( ! read_stdin && ( curbuf != old_curbuf || ( using_b_ffname && ( old_b_ffname != curbuf -> b_ffname ) ) || ( using_b_fname && ( old_b_fname != curbuf -> b_fname ) ) ) ) { EMSG ( _ ( e_auchangedbuf ) ) ; if ( ! read_buffer ) close ( fd ) ; return FAIL ; } # endif # ifdef UNIX if ( swap_mode > 0 && curbuf -> b_ml . ml_mfp != NULL && curbuf -> b_ml . ml_mfp -> mf_fname != NULL ) <S2SV_StartBug> ( void ) mch_setperm ( curbuf -> b_ml . ml_mfp -> mf_fname , ( long ) swap_mode ) ; <S2SV_EndBug> # endif } # if defined ( HAS_SWAP_EXISTS_ACTION ) if ( swap_exists_action == SEA_QUIT ) { if ( ! read_buffer && ! read_stdin ) close ( fd ) ; return FAIL ; } # endif ++ no_wait_return ; curbuf -> b_op_start . lnum = ( ( from == 0 ) ? 1 : from ) ; curbuf -> b_op_start . col = 0 ; try_mac = ( vim_strchr ( p_ffs , 'm' ) != NULL ) ; try_dos = ( vim_strchr ( p_ffs , 'd' ) != NULL ) ; try_unix = ( vim_strchr ( p_ffs , 'x' ) != NULL ) ; # ifdef FEAT_AUTOCMD if ( ! read_buffer ) { int m = msg_scroll ; int n = msg_scrolled ; if ( ! read_stdin ) close ( fd ) ; msg_scroll = TRUE ; if ( filtering ) apply_autocmds_exarg ( EVENT_FILTERREADPRE , NULL , sfname , FALSE , curbuf , eap ) ; else if ( read_stdin ) apply_autocmds_exarg ( EVENT_STDINREADPRE , NULL , sfname , FALSE , curbuf , eap ) ; else if ( newfile ) apply_autocmds_exarg ( EVENT_BUFREADPRE , NULL , sfname , FALSE , curbuf , eap ) ; else apply_autocmds_exarg ( EVENT_FILEREADPRE , sfname , sfname , FALSE , NULL , eap ) ; try_mac = ( vim_strchr ( p_ffs , 'm' ) != NULL ) ; try_dos = ( vim_strchr ( p_ffs , 'd' ) != NULL ) ; try_unix = ( vim_strchr ( p_ffs , 'x' ) != NULL ) ; if ( msg_scrolled == n ) msg_scroll = m ; # ifdef FEAT_EVAL if ( aborting ( ) ) { -- no_wait_return ; msg_scroll = msg_save ; curbuf -> b_p_ro = TRUE ; return FAIL ; } # endif if ( ! read_stdin && ( curbuf != old_curbuf || ( using_b_ffname && ( old_b_ffname != curbuf -> b_ffname ) ) || ( using_b_fname && ( old_b_fname != curbuf -> b_fname ) ) || ( fd = mch_open ( ( char * ) fname , O_RDONLY | O_EXTRA , 0 ) ) < 0 ) ) { -- no_wait_return ; msg_scroll = msg_save ; if ( fd < 0 ) EMSG ( _ ( ""E200:<S2SV_blank>*ReadPre<S2SV_blank>autocommands<S2SV_blank>made<S2SV_blank>the<S2SV_blank>file<S2SV_blank>unreadable"" ) ) ; else EMSG ( _ ( ""E201:<S2SV_blank>*ReadPre<S2SV_blank>autocommands<S2SV_blank>must<S2SV_blank>not<S2SV_blank>change<S2SV_blank>current<S2SV_blank>buffer"" ) ) ; curbuf -> b_p_ro = TRUE ; return FAIL ; } } # endif wasempty = ( curbuf -> b_ml . ml_flags & ML_EMPTY ) ; if ( ! recoverymode && ! filtering && ! ( flags & READ_DUMMY ) ) { if ( read_stdin ) { # ifndef ALWAYS_USE_GUI mch_msg ( _ ( ""Vim:<S2SV_blank>Reading<S2SV_blank>from<S2SV_blank>stdin...\\n"" ) ) ; # endif # ifdef FEAT_GUI if ( gui . in_use && ! gui . dying && ! gui . starting ) { p = ( char_u * ) _ ( ""Reading<S2SV_blank>from<S2SV_blank>stdin..."" ) ; gui_write ( p , ( int ) STRLEN ( p ) ) ; } # endif } else if ( ! read_buffer ) filemess ( curbuf , sfname , ( char_u * ) """" , 0 ) ; } msg_scroll = FALSE ; linecnt = curbuf -> b_ml . ml_line_count ; # ifdef FEAT_MBYTE if ( eap != NULL && eap -> bad_char != 0 ) { bad_char_behavior = eap -> bad_char ; if ( set_options ) curbuf -> b_bad_char = eap -> bad_char ; } else curbuf -> b_bad_char = 0 ; if ( eap != NULL && eap -> force_enc != 0 ) { fenc = enc_canonize ( eap -> cmd + eap -> force_enc ) ; fenc_alloced = TRUE ; keep_dest_enc = TRUE ; } else if ( curbuf -> b_p_bin ) { fenc = ( char_u * ) """" ; fenc_alloced = FALSE ; } else if ( curbuf -> b_help ) { char_u firstline [ 80 ] ; int fc ; fenc = ( char_u * ) ""latin1"" ; c = enc_utf8 ; if ( ! c && ! read_stdin ) { fc = fname [ STRLEN ( fname ) - 1 ] ; if ( TOLOWER_ASC ( fc ) == 'x' ) { len = read_eintr ( fd , firstline , 80 ) ; vim_lseek ( fd , ( off_T ) 0L , SEEK_SET ) ; for ( p = firstline ; p < firstline + len ; ++ p ) if ( * p >= 0x80 ) { c = TRUE ; break ; } } } if ( c ) { fenc_next = fenc ; fenc = ( char_u * ) ""utf-8"" ; if ( ! enc_utf8 ) keep_dest_enc = TRUE ; } fenc_alloced = FALSE ; } else if ( * p_fencs == NUL ) { fenc = curbuf -> b_p_fenc ; fenc_alloced = FALSE ; } else { fenc_next = p_fencs ; fenc = next_fenc ( & fenc_next ) ; fenc_alloced = TRUE ; } # endif retry : if ( file_rewind ) { if ( read_buffer ) { read_buf_lnum = 1 ; read_buf_col = 0 ; } else if ( read_stdin || vim_lseek ( fd , ( off_T ) 0L , SEEK_SET ) != 0 ) { error = TRUE ; goto failed ; } while ( lnum > from ) ml_delete ( lnum -- , FALSE ) ; file_rewind = FALSE ; # ifdef FEAT_MBYTE if ( set_options ) { curbuf -> b_p_bomb = FALSE ; curbuf -> b_start_bomb = FALSE ; } conv_error = 0 ; # endif } if ( keep_fileformat ) keep_fileformat = FALSE ; else { if ( eap != NULL && eap -> force_ff != 0 ) { fileformat = get_fileformat_force ( curbuf , eap ) ; try_unix = try_dos = try_mac = FALSE ; } else if ( curbuf -> b_p_bin ) fileformat = EOL_UNIX ; else if ( * p_ffs == NUL ) fileformat = get_fileformat ( curbuf ) ; else fileformat = EOL_UNKNOWN ; } # ifdef FEAT_MBYTE # ifdef USE_ICONV if ( iconv_fd != ( iconv_t ) - 1 ) { iconv_close ( iconv_fd ) ; iconv_fd = ( iconv_t ) - 1 ; } # endif if ( advance_fenc ) { advance_fenc = FALSE ; if ( eap != NULL && eap -> force_enc != 0 ) { notconverted = TRUE ; conv_error = 0 ; if ( fenc_alloced ) vim_free ( fenc ) ; fenc = ( char_u * ) """" ; fenc_alloced = FALSE ; } else { if ( fenc_alloced ) vim_free ( fenc ) ; if ( fenc_next != NULL ) { fenc = next_fenc ( & fenc_next ) ; fenc_alloced = ( fenc_next != NULL ) ; } else { fenc = ( char_u * ) """" ; fenc_alloced = FALSE ; } } if ( tmpname != NULL ) { mch_remove ( tmpname ) ; vim_free ( tmpname ) ; tmpname = NULL ; } } fio_flags = 0 ; converted = need_conversion ( fenc ) ; if ( converted ) { if ( STRCMP ( fenc , ENC_UCSBOM ) == 0 ) fio_flags = FIO_UCSBOM ; else if ( enc_utf8 || STRCMP ( p_enc , ""latin1"" ) == 0 ) fio_flags = get_fio_flags ( fenc ) ; # ifdef WIN3264 if ( fio_flags == 0 ) fio_flags = get_win_fio_flags ( fenc ) ; # endif # ifdef MACOS_CONVERT if ( fio_flags == 0 ) fio_flags = get_mac_fio_flags ( fenc ) ; # endif # ifdef USE_ICONV if ( fio_flags == 0 # ifdef FEAT_EVAL && ! did_iconv # endif ) iconv_fd = ( iconv_t ) my_iconv_open ( enc_utf8 ? ( char_u * ) ""utf-8"" : p_enc , fenc ) ; # endif # ifdef FEAT_EVAL if ( fio_flags == 0 && ! read_stdin && ! read_buffer && * p_ccv != NUL && ! read_fifo # ifdef USE_ICONV && iconv_fd == ( iconv_t ) - 1 # endif ) { # ifdef USE_ICONV did_iconv = FALSE ; # endif if ( tmpname == NULL ) { tmpname = readfile_charconvert ( fname , fenc , & fd ) ; if ( tmpname == NULL ) { advance_fenc = TRUE ; if ( fd < 0 ) { EMSG ( _ ( ""E202:<S2SV_blank>Conversion<S2SV_blank>made<S2SV_blank>file<S2SV_blank>unreadable!"" ) ) ; error = TRUE ; goto failed ; } goto retry ; } } } else # endif { if ( fio_flags == 0 # ifdef USE_ICONV && iconv_fd == ( iconv_t ) - 1 # endif ) { advance_fenc = TRUE ; goto retry ; } } } can_retry = ( * fenc != NUL && ! read_stdin && ! read_fifo && ! keep_dest_enc ) ; # endif if ( ! skip_read ) { linerest = 0 ; filesize = 0 ; skip_count = lines_to_skip ; read_count = lines_to_read ; # ifdef FEAT_MBYTE conv_restlen = 0 ; # endif # ifdef FEAT_PERSISTENT_UNDO read_undo_file = ( newfile && ( flags & READ_KEEP_UNDO ) == 0 && curbuf -> b_ffname != NULL && curbuf -> b_p_udf && ! filtering && ! read_fifo && ! read_stdin && ! read_buffer ) ; if ( read_undo_file ) sha256_start ( & sha_ctx ) ; # endif # ifdef FEAT_CRYPT if ( curbuf -> b_cryptstate != NULL ) { crypt_free_state ( curbuf -> b_cryptstate ) ; curbuf -> b_cryptstate = NULL ; } # endif } while ( ! error && ! got_int ) { # if VIM_SIZEOF_INT <= 2 if ( linerest >= 0x7ff0 ) { ++ split ; * ptr = NL ; size = 1 ; } else # endif { if ( ! skip_read ) { # if VIM_SIZEOF_INT > 2 # if defined ( SSIZE_MAX ) && ( SSIZE_MAX < 0x10000L ) size = SSIZE_MAX ; # else size = 0x10000L ; # endif # else size = 0x7ff0L - linerest ; # endif for ( ; size >= 10 ; size = ( long ) ( ( long_u ) size >> 1 ) ) { if ( ( new_buffer = lalloc ( ( long_u ) ( size + linerest + 1 ) , FALSE ) ) != NULL ) break ; } if ( new_buffer == NULL ) { do_outofmem_msg ( ( long_u ) ( size * 2 + linerest + 1 ) ) ; error = TRUE ; break ; } if ( linerest ) mch_memmove ( new_buffer , ptr - linerest , ( size_t ) linerest ) ; vim_free ( buffer ) ; buffer = new_buffer ; ptr = buffer + linerest ; line_start = buffer ; # ifdef FEAT_MBYTE real_size = ( int ) size ; # ifdef USE_ICONV if ( iconv_fd != ( iconv_t ) - 1 ) size = size / ICONV_MULT ; else # endif if ( fio_flags & FIO_LATIN1 ) size = size / 2 ; else if ( fio_flags & ( FIO_UCS2 | FIO_UTF16 ) ) size = ( size * 2 / 3 ) & ~ 1 ; else if ( fio_flags & FIO_UCS4 ) size = ( size * 2 / 3 ) & ~ 3 ; else if ( fio_flags == FIO_UCSBOM ) size = size / ICONV_MULT ; # ifdef WIN3264 else if ( fio_flags & FIO_CODEPAGE ) size = size / ICONV_MULT ; # endif # ifdef MACOS_CONVERT else if ( fio_flags & FIO_MACROMAN ) size = size / ICONV_MULT ; # endif # endif # ifdef FEAT_MBYTE if ( conv_restlen > 0 ) { mch_memmove ( ptr , conv_rest , conv_restlen ) ; ptr += conv_restlen ; size -= conv_restlen ; } # endif if ( read_buffer ) { if ( read_buf_lnum > from ) size = 0 ; else { int n , ni ; long tlen ; tlen = 0 ; for ( ; ; ) { p = ml_get ( read_buf_lnum ) + read_buf_col ; n = ( int ) STRLEN ( p ) ; if ( ( int ) tlen + n + 1 > size ) { n = ( int ) ( size - tlen ) ; for ( ni = 0 ; ni < n ; ++ ni ) { if ( p [ ni ] == NL ) ptr [ tlen ++ ] = NUL ; else ptr [ tlen ++ ] = p [ ni ] ; } read_buf_col += n ; break ; } else { for ( ni = 0 ; ni < n ; ++ ni ) { if ( p [ ni ] == NL ) ptr [ tlen ++ ] = NUL ; else ptr [ tlen ++ ] = p [ ni ] ; } ptr [ tlen ++ ] = NL ; read_buf_col = 0 ; if ( ++ read_buf_lnum > from ) { if ( ! curbuf -> b_p_eol ) -- tlen ; size = tlen ; break ; } } } } } else { size = read_eintr ( fd , ptr , size ) ; } # ifdef FEAT_CRYPT if ( filesize == 0 && size > 0 ) cryptkey = check_for_cryptkey ( cryptkey , ptr , & size , & filesize , newfile , sfname , & did_ask_for_key ) ; if ( cryptkey != NULL && curbuf -> b_cryptstate != NULL && size > 0 ) { if ( crypt_works_inplace ( curbuf -> b_cryptstate ) ) { crypt_decode_inplace ( curbuf -> b_cryptstate , ptr , size ) ; } else { char_u * newptr = NULL ; int decrypted_size ; decrypted_size = crypt_decode_alloc ( curbuf -> b_cryptstate , ptr , size , & newptr ) ; if ( size > 0 && decrypted_size == 0 ) continue ; if ( linerest == 0 ) { new_buffer = newptr ; } else { long_u new_size ; new_size = ( long_u ) ( decrypted_size + linerest + 1 ) ; new_buffer = lalloc ( new_size , FALSE ) ; if ( new_buffer == NULL ) { do_outofmem_msg ( new_size ) ; error = TRUE ; break ; } mch_memmove ( new_buffer , buffer , linerest ) ; if ( newptr != NULL ) mch_memmove ( new_buffer + linerest , newptr , decrypted_size ) ; } if ( new_buffer != NULL ) { vim_free ( buffer ) ; buffer = new_buffer ; new_buffer = NULL ; line_start = buffer ; ptr = buffer + linerest ; } size = decrypted_size ; } } # endif if ( size <= 0 ) { if ( size < 0 ) error = TRUE ; # ifdef FEAT_MBYTE else if ( conv_restlen > 0 ) { if ( fio_flags != 0 # ifdef USE_ICONV || iconv_fd != ( iconv_t ) - 1 # endif ) { if ( can_retry ) goto rewind_retry ; if ( conv_error == 0 ) conv_error = curbuf -> b_ml . ml_line_count - linecnt + 1 ; } else if ( illegal_byte == 0 ) illegal_byte = curbuf -> b_ml . ml_line_count - linecnt + 1 ; if ( bad_char_behavior == BAD_DROP ) { * ( ptr - conv_restlen ) = NUL ; conv_restlen = 0 ; } else { if ( bad_char_behavior != BAD_KEEP && ( fio_flags != 0 # ifdef USE_ICONV || iconv_fd != ( iconv_t ) - 1 # endif ) ) { while ( conv_restlen > 0 ) { * ( -- ptr ) = bad_char_behavior ; -- conv_restlen ; } } fio_flags = 0 ; # ifdef USE_ICONV if ( iconv_fd != ( iconv_t ) - 1 ) { iconv_close ( iconv_fd ) ; iconv_fd = ( iconv_t ) - 1 ; } # endif } } # endif } } skip_read = FALSE ; # ifdef FEAT_MBYTE if ( ( filesize == 0 # ifdef FEAT_CRYPT || ( cryptkey != NULL && filesize == crypt_get_header_len ( crypt_get_method_nr ( curbuf ) ) ) # endif ) && ( fio_flags == FIO_UCSBOM || ( ! curbuf -> b_p_bomb && tmpname == NULL && ( * fenc == 'u' || ( * fenc == NUL && enc_utf8 ) ) ) ) ) { char_u * ccname ; int blen ; if ( size < 2 || curbuf -> b_p_bin ) ccname = NULL ; else ccname = check_for_bom ( ptr , size , & blen , fio_flags == FIO_UCSBOM ? FIO_ALL : get_fio_flags ( fenc ) ) ; if ( ccname != NULL ) { filesize += blen ; size -= blen ; mch_memmove ( ptr , ptr + blen , ( size_t ) size ) ; if ( set_options ) { curbuf -> b_p_bomb = TRUE ; curbuf -> b_start_bomb = TRUE ; } } if ( fio_flags == FIO_UCSBOM ) { if ( ccname == NULL ) { advance_fenc = TRUE ; } else { if ( fenc_alloced ) vim_free ( fenc ) ; fenc = ccname ; fenc_alloced = FALSE ; } skip_read = TRUE ; goto retry ; } } ptr -= conv_restlen ; size += conv_restlen ; conv_restlen = 0 ; # endif if ( size <= 0 ) break ; # ifdef FEAT_MBYTE # ifdef USE_ICONV if ( iconv_fd != ( iconv_t ) - 1 ) { const char * fromp ; char * top ; size_t from_size ; size_t to_size ; fromp = ( char * ) ptr ; from_size = size ; ptr += size ; top = ( char * ) ptr ; to_size = real_size - size ; while ( ( iconv ( iconv_fd , ( void * ) & fromp , & from_size , & top , & to_size ) == ( size_t ) - 1 && ICONV_ERRNO != ICONV_EINVAL ) || from_size > CONV_RESTLEN ) { if ( can_retry ) goto rewind_retry ; if ( conv_error == 0 ) conv_error = readfile_linenr ( linecnt , ptr , ( char_u * ) top ) ; ++ fromp ; -- from_size ; if ( bad_char_behavior == BAD_KEEP ) { * top ++ = * ( fromp - 1 ) ; -- to_size ; } else if ( bad_char_behavior != BAD_DROP ) { * top ++ = bad_char_behavior ; -- to_size ; } } if ( from_size > 0 ) { mch_memmove ( conv_rest , ( char_u * ) fromp , from_size ) ; conv_restlen = ( int ) from_size ; } line_start = ptr - linerest ; mch_memmove ( line_start , buffer , ( size_t ) linerest ) ; size = ( long ) ( ( char_u * ) top - ptr ) ; } # endif # ifdef WIN3264 if ( fio_flags & FIO_CODEPAGE ) { char_u * src , * dst ; WCHAR ucs2buf [ 3 ] ; int ucs2len ; int codepage = FIO_GET_CP ( fio_flags ) ; int bytelen ; int found_bad ; char replstr [ 2 ] ; if ( bad_char_behavior > 0 ) replstr [ 0 ] = bad_char_behavior ; else replstr [ 0 ] = '?' ; replstr [ 1 ] = NUL ; src = ptr + real_size - size ; mch_memmove ( src , ptr , size ) ; dst = ptr ; size = size ; while ( size > 0 ) { found_bad = FALSE ; # ifdef CP_UTF8 if ( codepage == CP_UTF8 ) { bytelen = ( int ) utf_ptr2len_len ( src , size ) ; if ( bytelen > size ) { if ( bytelen <= CONV_RESTLEN ) break ; bytelen = size ; found_bad = TRUE ; } else { int u8c = utf_ptr2char ( src ) ; if ( u8c > 0xffff || ( * src >= 0x80 && bytelen == 1 ) ) found_bad = TRUE ; ucs2buf [ 0 ] = u8c ; ucs2len = 1 ; } } else # endif { for ( bytelen = 1 ; bytelen <= size && bytelen <= 3 ; ++ bytelen ) { ucs2len = MultiByteToWideChar ( codepage , MB_ERR_INVALID_CHARS , ( LPCSTR ) src , bytelen , ucs2buf , 3 ) ; if ( ucs2len > 0 ) break ; } if ( ucs2len == 0 ) { if ( size == 1 ) break ; found_bad = TRUE ; bytelen = 1 ; } } if ( ! found_bad ) { int i ; if ( enc_utf8 ) { for ( i = 0 ; i < ucs2len ; ++ i ) dst += utf_char2bytes ( ucs2buf [ i ] , dst ) ; } else { BOOL bad = FALSE ; int dstlen ; dstlen = WideCharToMultiByte ( enc_codepage , 0 , ( LPCWSTR ) ucs2buf , ucs2len , ( LPSTR ) dst , ( int ) ( src - dst ) , replstr , & bad ) ; if ( bad ) found_bad = TRUE ; else dst += dstlen ; } } if ( found_bad ) { if ( can_retry ) goto rewind_retry ; if ( conv_error == 0 ) conv_error = readfile_linenr ( linecnt , ptr , dst ) ; if ( bad_char_behavior != BAD_DROP ) { if ( bad_char_behavior == BAD_KEEP ) { mch_memmove ( dst , src , bytelen ) ; dst += bytelen ; } else * dst ++ = bad_char_behavior ; } } src += bytelen ; size -= bytelen ; } if ( size > 0 ) { mch_memmove ( conv_rest , src , size ) ; conv_restlen = size ; } size = ( long ) ( dst - ptr ) ; } else # endif # ifdef MACOS_CONVERT if ( fio_flags & FIO_MACROMAN ) { if ( macroman2enc ( ptr , & size , real_size ) == FAIL ) goto rewind_retry ; } else # endif if ( fio_flags != 0 ) { int u8c ; char_u * dest ; char_u * tail = NULL ; dest = ptr + real_size ; if ( fio_flags == FIO_LATIN1 || fio_flags == FIO_UTF8 ) { p = ptr + size ; if ( fio_flags == FIO_UTF8 ) { tail = ptr + size - 1 ; while ( tail > ptr && ( * tail & 0xc0 ) == 0x80 ) -- tail ; if ( tail + utf_byte2len ( * tail ) <= ptr + size ) tail = NULL ; else p = tail ; } } else if ( fio_flags & ( FIO_UCS2 | FIO_UTF16 ) ) { p = ptr + ( size & ~ 1 ) ; if ( size & 1 ) tail = p ; if ( ( fio_flags & FIO_UTF16 ) && p > ptr ) { if ( fio_flags & FIO_ENDIAN_L ) { u8c = ( * -- p << 8 ) ; u8c += * -- p ; } else { u8c = * -- p ; u8c += ( * -- p << 8 ) ; } if ( u8c >= 0xd800 && u8c <= 0xdbff ) tail = p ; else p += 2 ; } } else { p = ptr + ( size & ~ 3 ) ; if ( size & 3 ) tail = p ; } if ( tail != NULL ) { conv_restlen = ( int ) ( ( ptr + size ) - tail ) ; mch_memmove ( conv_rest , ( char_u * ) tail , conv_restlen ) ; size -= conv_restlen ; } while ( p > ptr ) { if ( fio_flags & FIO_LATIN1 ) u8c = * -- p ; else if ( fio_flags & ( FIO_UCS2 | FIO_UTF16 ) ) { if ( fio_flags & FIO_ENDIAN_L ) { u8c = ( * -- p << 8 ) ; u8c += * -- p ; } else { u8c = * -- p ; u8c += ( * -- p << 8 ) ; } if ( ( fio_flags & FIO_UTF16 ) && u8c >= 0xdc00 && u8c <= 0xdfff ) { int u16c ; if ( p == ptr ) { if ( can_retry ) goto rewind_retry ; if ( conv_error == 0 ) conv_error = readfile_linenr ( linecnt , ptr , p ) ; if ( bad_char_behavior == BAD_DROP ) continue ; if ( bad_char_behavior != BAD_KEEP ) u8c = bad_char_behavior ; } if ( fio_flags & FIO_ENDIAN_L ) { u16c = ( * -- p << 8 ) ; u16c += * -- p ; } else { u16c = * -- p ; u16c += ( * -- p << 8 ) ; } u8c = 0x10000 + ( ( u16c & 0x3ff ) << 10 ) + ( u8c & 0x3ff ) ; if ( u16c < 0xd800 || u16c > 0xdbff ) { if ( can_retry ) goto rewind_retry ; if ( conv_error == 0 ) conv_error = readfile_linenr ( linecnt , ptr , p ) ; if ( bad_char_behavior == BAD_DROP ) continue ; if ( bad_char_behavior != BAD_KEEP ) u8c = bad_char_behavior ; } } } else if ( fio_flags & FIO_UCS4 ) { if ( fio_flags & FIO_ENDIAN_L ) { u8c = ( unsigned ) * -- p << 24 ; u8c += ( unsigned ) * -- p << 16 ; u8c += ( unsigned ) * -- p << 8 ; u8c += * -- p ; } else { u8c = * -- p ; u8c += ( unsigned ) * -- p << 8 ; u8c += ( unsigned ) * -- p << 16 ; u8c += ( unsigned ) * -- p << 24 ; } } else { if ( * -- p < 0x80 ) u8c = * p ; else { len = utf_head_off ( ptr , p ) ; p -= len ; u8c = utf_ptr2char ( p ) ; if ( len == 0 ) { if ( can_retry ) goto rewind_retry ; if ( conv_error == 0 ) conv_error = readfile_linenr ( linecnt , ptr , p ) ; if ( bad_char_behavior == BAD_DROP ) continue ; if ( bad_char_behavior != BAD_KEEP ) u8c = bad_char_behavior ; } } } if ( enc_utf8 ) { dest -= utf_char2len ( u8c ) ; ( void ) utf_char2bytes ( u8c , dest ) ; } else { -- dest ; if ( u8c >= 0x100 ) { if ( can_retry ) goto rewind_retry ; if ( conv_error == 0 ) conv_error = readfile_linenr ( linecnt , ptr , p ) ; if ( bad_char_behavior == BAD_DROP ) ++ dest ; else if ( bad_char_behavior == BAD_KEEP ) * dest = u8c ; else if ( eap != NULL && eap -> bad_char != 0 ) * dest = bad_char_behavior ; else * dest = 0xBF ; } else * dest = u8c ; } } line_start = dest - linerest ; mch_memmove ( line_start , buffer , ( size_t ) linerest ) ; size = ( long ) ( ( ptr + real_size ) - dest ) ; ptr = dest ; } else if ( enc_utf8 && ! curbuf -> b_p_bin ) { int incomplete_tail = FALSE ; for ( p = ptr ; ; ++ p ) { int todo = ( int ) ( ( ptr + size ) - p ) ; int l ; if ( todo <= 0 ) break ; if ( * p >= 0x80 ) { l = utf_ptr2len_len ( p , todo ) ; if ( l > todo && ! incomplete_tail ) { if ( p > ptr || filesize > 0 ) incomplete_tail = TRUE ; if ( p > ptr ) { conv_restlen = todo ; mch_memmove ( conv_rest , p , conv_restlen ) ; size -= conv_restlen ; break ; } } if ( l == 1 || l > todo ) { if ( can_retry && ! incomplete_tail ) break ; # ifdef USE_ICONV if ( iconv_fd != ( iconv_t ) - 1 && conv_error == 0 ) conv_error = readfile_linenr ( linecnt , ptr , p ) ; # endif if ( conv_error == 0 && illegal_byte == 0 ) illegal_byte = readfile_linenr ( linecnt , ptr , p ) ; if ( bad_char_behavior == BAD_DROP ) { mch_memmove ( p , p + 1 , todo - 1 ) ; -- p ; -- size ; } else if ( bad_char_behavior != BAD_KEEP ) * p = bad_char_behavior ; } else p += l - 1 ; } } if ( p < ptr + size && ! incomplete_tail ) { rewind_retry : # if defined ( FEAT_EVAL ) && defined ( USE_ICONV ) if ( * p_ccv != NUL && iconv_fd != ( iconv_t ) - 1 ) did_iconv = TRUE ; else # endif advance_fenc = TRUE ; file_rewind = TRUE ; goto retry ; } } # endif filesize += size ; if ( fileformat == EOL_UNKNOWN ) { if ( try_dos || try_unix ) { if ( try_mac ) try_mac = 1 ; for ( p = ptr ; p < ptr + size ; ++ p ) { if ( * p == NL ) { if ( ! try_unix || ( try_dos && p > ptr && p [ - 1 ] == CAR ) ) fileformat = EOL_DOS ; else fileformat = EOL_UNIX ; break ; } else if ( * p == CAR && try_mac ) try_mac ++ ; } if ( fileformat == EOL_UNIX && try_mac ) { try_mac = 1 ; try_unix = 1 ; for ( ; p >= ptr && * p != CAR ; p -- ) ; if ( p >= ptr ) { for ( p = ptr ; p < ptr + size ; ++ p ) { if ( * p == NL ) try_unix ++ ; else if ( * p == CAR ) try_mac ++ ; } if ( try_mac > try_unix ) fileformat = EOL_MAC ; } } else if ( fileformat == EOL_UNKNOWN && try_mac == 1 ) fileformat = default_fileformat ( ) ; } if ( fileformat == EOL_UNKNOWN && try_mac ) fileformat = EOL_MAC ; if ( fileformat == EOL_UNKNOWN ) fileformat = default_fileformat ( ) ; if ( set_options ) set_fileformat ( fileformat , OPT_LOCAL ) ; } } if ( fileformat == EOL_MAC ) { -- ptr ; while ( ++ ptr , -- size >= 0 ) { if ( ( c = * ptr ) != NUL && c != CAR && c != NL ) continue ; if ( c == NUL ) * ptr = NL ; else if ( c == NL ) * ptr = CAR ; else { if ( skip_count == 0 ) { * ptr = NUL ; len = ( colnr_T ) ( ptr - line_start + 1 ) ; if ( ml_append ( lnum , line_start , len , newfile ) == FAIL ) { error = TRUE ; break ; } # ifdef FEAT_PERSISTENT_UNDO if ( read_undo_file ) sha256_update ( & sha_ctx , line_start , len ) ; # endif ++ lnum ; if ( -- read_count == 0 ) { error = TRUE ; line_start = ptr ; break ; } } else -- skip_count ; line_start = ptr + 1 ; } } } else { -- ptr ; while ( ++ ptr , -- size >= 0 ) { if ( ( c = * ptr ) != NUL && c != NL ) continue ; if ( c == NUL ) * ptr = NL ; else { if ( skip_count == 0 ) { * ptr = NUL ; len = ( colnr_T ) ( ptr - line_start + 1 ) ; if ( fileformat == EOL_DOS ) { if ( ptr > line_start && ptr [ - 1 ] == CAR ) { ptr [ - 1 ] = NUL ; -- len ; } else if ( ff_error != EOL_DOS ) { if ( try_unix && ! read_stdin && ( read_buffer || vim_lseek ( fd , ( off_T ) 0L , SEEK_SET ) == 0 ) ) { fileformat = EOL_UNIX ; if ( set_options ) set_fileformat ( EOL_UNIX , OPT_LOCAL ) ; file_rewind = TRUE ; keep_fileformat = TRUE ; goto retry ; } ff_error = EOL_DOS ; } } if ( ml_append ( lnum , line_start , len , newfile ) == FAIL ) { error = TRUE ; break ; } # ifdef FEAT_PERSISTENT_UNDO if ( read_undo_file ) sha256_update ( & sha_ctx , line_start , len ) ; # endif ++ lnum ; if ( -- read_count == 0 ) { error = TRUE ; line_start = ptr ; break ; } } else -- skip_count ; line_start = ptr + 1 ; } } } linerest = ( long ) ( ptr - line_start ) ; ui_breakcheck ( ) ; } failed : if ( error && read_count == 0 ) error = FALSE ; if ( ! error && ! got_int && linerest != 0 && ! ( ! curbuf -> b_p_bin && fileformat == EOL_DOS && * line_start == Ctrl_Z && ptr == line_start + 1 ) ) { if ( set_options ) curbuf -> b_p_eol = FALSE ; * ptr = NUL ; len = ( colnr_T ) ( ptr - line_start + 1 ) ; if ( ml_append ( lnum , line_start , len , newfile ) == FAIL ) error = TRUE ; else { # ifdef FEAT_PERSISTENT_UNDO if ( read_undo_file ) sha256_update ( & sha_ctx , line_start , len ) ; # endif read_no_eol_lnum = ++ lnum ; } } if ( set_options ) save_file_ff ( curbuf ) ; # ifdef FEAT_CRYPT if ( curbuf -> b_cryptstate != NULL ) { crypt_free_state ( curbuf -> b_cryptstate ) ; curbuf -> b_cryptstate = NULL ; } if ( cryptkey != NULL && cryptkey != curbuf -> b_p_key ) crypt_free_key ( cryptkey ) ; # endif # ifdef FEAT_MBYTE if ( set_options ) set_string_option_direct ( ( char_u * ) ""fenc"" , - 1 , fenc , OPT_FREE | OPT_LOCAL , 0 ) ; if ( fenc_alloced ) vim_free ( fenc ) ; # ifdef USE_ICONV if ( iconv_fd != ( iconv_t ) - 1 ) { iconv_close ( iconv_fd ) ; iconv_fd = ( iconv_t ) - 1 ; } # endif # endif if ( ! read_buffer && ! read_stdin ) close ( fd ) ; # ifdef HAVE_FD_CLOEXEC else { int fdflags = fcntl ( fd , F_GETFD ) ; if ( fdflags >= 0 && ( fdflags & FD_CLOEXEC ) == 0 ) ( void ) fcntl ( fd , F_SETFD , fdflags | FD_CLOEXEC ) ; } # endif vim_free ( buffer ) ; # ifdef HAVE_DUP if ( read_stdin ) { close ( 0 ) ; ignored = dup ( 2 ) ; } # endif # ifdef FEAT_MBYTE if ( tmpname != NULL ) { mch_remove ( tmpname ) ; vim_free ( tmpname ) ; } # endif -- no_wait_return ; if ( ! recoverymode ) { if ( newfile && wasempty && ! ( curbuf -> b_ml . ml_flags & ML_EMPTY ) ) { # ifdef FEAT_NETBEANS_INTG netbeansFireChanges = 0 ; # endif ml_delete ( curbuf -> b_ml . ml_line_count , FALSE ) ; # ifdef FEAT_NETBEANS_INTG netbeansFireChanges = 1 ; # endif -- linecnt ; } linecnt = curbuf -> b_ml . ml_line_count - linecnt ; if ( filesize == 0 ) linecnt = 0 ; if ( newfile || read_buffer ) { redraw_curbuf_later ( NOT_VALID ) ; # ifdef FEAT_DIFF diff_invalidate ( curbuf ) ; # endif # ifdef FEAT_FOLDING foldUpdateAll ( curwin ) ; # endif } else if ( linecnt ) appended_lines_mark ( from , linecnt ) ; # ifndef ALWAYS_USE_GUI if ( read_stdin ) { settmode ( TMODE_RAW ) ; starttermcap ( ) ; screenclear ( ) ; } # endif if ( got_int ) { if ( ! ( flags & READ_DUMMY ) ) { filemess ( curbuf , sfname , ( char_u * ) _ ( e_interr ) , 0 ) ; if ( newfile ) curbuf -> b_p_ro = TRUE ; } msg_scroll = msg_save ; # ifdef FEAT_VIMINFO check_marks_read ( ) ; # endif return OK ; } if ( ! filtering && ! ( flags & READ_DUMMY ) ) { msg_add_fname ( curbuf , sfname ) ; c = FALSE ; # ifdef UNIX # ifdef S_ISFIFO if ( S_ISFIFO ( perm ) ) { STRCAT ( IObuff , _ ( ""[fifo/socket]"" ) ) ; c = TRUE ; } # else # ifdef S_IFIFO if ( ( perm & S_IFMT ) == S_IFIFO ) { STRCAT ( IObuff , _ ( ""[fifo]"" ) ) ; c = TRUE ; } # endif # ifdef S_IFSOCK if ( ( perm & S_IFMT ) == S_IFSOCK ) { STRCAT ( IObuff , _ ( ""[socket]"" ) ) ; c = TRUE ; } # endif # endif # ifdef OPEN_CHR_FILES if ( S_ISCHR ( perm ) ) { STRCAT ( IObuff , _ ( ""[character<S2SV_blank>special]"" ) ) ; c = TRUE ; } # endif # endif if ( curbuf -> b_p_ro ) { STRCAT ( IObuff , shortmess ( SHM_RO ) ? _ ( ""[RO]"" ) : _ ( ""[readonly]"" ) ) ; c = TRUE ; } if ( read_no_eol_lnum ) { msg_add_eol ( ) ; c = TRUE ; } if ( ff_error == EOL_DOS ) { STRCAT ( IObuff , _ ( ""[CR<S2SV_blank>missing]"" ) ) ; c = TRUE ; } if ( split ) { STRCAT ( IObuff , _ ( ""[long<S2SV_blank>lines<S2SV_blank>split]"" ) ) ; c = TRUE ; } # ifdef FEAT_MBYTE if ( notconverted ) { STRCAT ( IObuff , _ ( ""[NOT<S2SV_blank>converted]"" ) ) ; c = TRUE ; } else if ( converted ) { STRCAT ( IObuff , _ ( ""[converted]"" ) ) ; c = TRUE ; } # endif # ifdef FEAT_CRYPT if ( cryptkey != NULL ) { crypt_append_msg ( curbuf ) ; c = TRUE ; } # endif # ifdef FEAT_MBYTE if ( conv_error != 0 ) { sprintf ( ( char * ) IObuff + STRLEN ( IObuff ) , _ ( ""[CONVERSION<S2SV_blank>ERROR<S2SV_blank>in<S2SV_blank>line<S2SV_blank>%ld]"" ) , ( long ) conv_error ) ; c = TRUE ; } else if ( illegal_byte > 0 ) { sprintf ( ( char * ) IObuff + STRLEN ( IObuff ) , _ ( ""[ILLEGAL<S2SV_blank>BYTE<S2SV_blank>in<S2SV_blank>line<S2SV_blank>%ld]"" ) , ( long ) illegal_byte ) ; c = TRUE ; } else # endif if ( error ) { STRCAT ( IObuff , _ ( ""[READ<S2SV_blank>ERRORS]"" ) ) ; c = TRUE ; } if ( msg_add_fileformat ( fileformat ) ) c = TRUE ; # ifdef FEAT_CRYPT if ( cryptkey != NULL ) msg_add_lines ( c , ( long ) linecnt , filesize - crypt_get_header_len ( crypt_get_method_nr ( curbuf ) ) ) ; else # endif msg_add_lines ( c , ( long ) linecnt , filesize ) ; vim_free ( keep_msg ) ; keep_msg = NULL ; msg_scrolled_ign = TRUE ; # ifdef ALWAYS_USE_GUI if ( read_stdin || read_buffer ) p = msg_may_trunc ( FALSE , IObuff ) ; else # endif p = msg_trunc_attr ( IObuff , FALSE , 0 ) ; if ( read_stdin || read_buffer || restart_edit != 0 || ( msg_scrolled != 0 && ! need_wait_return ) ) set_keep_msg ( p , 0 ) ; msg_scrolled_ign = FALSE ; } if ( newfile && ( error # ifdef FEAT_MBYTE || conv_error != 0 || ( illegal_byte > 0 && bad_char_behavior != BAD_KEEP ) # endif ) ) curbuf -> b_p_ro = TRUE ; u_clearline ( ) ; if ( exmode_active ) curwin -> w_cursor . lnum = from + linecnt ; else curwin -> w_cursor . lnum = from + 1 ; check_cursor_lnum ( ) ; beginline ( BL_WHITE | BL_FIX ) ; curbuf -> b_op_start . lnum = from + 1 ; curbuf -> b_op_start . col = 0 ; curbuf -> b_op_end . lnum = from + linecnt ; curbuf -> b_op_end . col = 0 ; # ifdef WIN32 if ( newfile && ! read_stdin && ! read_buffer && mch_stat ( ( char * ) fname , & st ) >= 0 ) { buf_store_time ( curbuf , & st , fname ) ; curbuf -> b_mtime_read = curbuf -> b_mtime ; } # endif } msg_scroll = msg_save ; # ifdef FEAT_VIMINFO check_marks_read ( ) ; # endif curbuf -> b_no_eol_lnum = read_no_eol_lnum ; if ( flags & READ_KEEP_UNDO ) u_find_first_changed ( ) ; # ifdef FEAT_PERSISTENT_UNDO if ( read_undo_file ) { char_u hash [ UNDO_HASH_SIZE ] ; sha256_finish ( & sha_ctx , hash ) ; u_read_undo ( NULL , hash , fname ) ; } # endif # ifdef FEAT_AUTOCMD if ( ! read_stdin && ! read_fifo && ( ! read_buffer || sfname != NULL ) ) { int m = msg_scroll ; int n = msg_scrolled ; if ( set_options ) save_file_ff ( curbuf ) ; msg_scroll = TRUE ; if ( filtering ) apply_autocmds_exarg ( EVENT_FILTERREADPOST , NULL , sfname , FALSE , curbuf , eap ) ; else if ( newfile || ( read_buffer && sfname != NULL ) ) { apply_autocmds_exarg ( EVENT_BUFREADPOST , NULL , sfname , FALSE , curbuf , eap ) ; if ( ! au_did_filetype && * curbuf -> b_p_ft != NUL ) apply_autocmds ( EVENT_FILETYPE , curbuf -> b_p_ft , curbuf -> b_fname , TRUE , curbuf ) ; } else apply_autocmds_exarg ( EVENT_FILEREADPOST , sfname , sfname , FALSE , NULL , eap ) ; if ( msg_scrolled == n ) msg_scroll = m ; # ifdef FEAT_EVAL if ( aborting ( ) ) return FAIL ; # endif } # endif if ( recoverymode && error ) return FAIL ; return OK ; }
","<S2SV_ModStart> != NULL ) { char_u * swap_fname = <S2SV_ModEnd> curbuf -> b_ml <S2SV_ModStart> ml_mfp -> mf_fname ; if ( ( swap_mode & 044 ) == 040 ) { stat_T swap_st ; if ( mch_stat ( ( char * ) swap_fname , & swap_st ) >= 0 && st . st_gid != swap_st . st_gid && fchown ( curbuf -> b_ml . ml_mfp -> mf_fd , - 1 , st . st_gid ) == - 1 ) swap_mode &= 0600 ; } ( void ) mch_setperm ( swap_fname <S2SV_ModStart> swap_mode ) ; }
"
369,"CWE-400 static int cop1Emulate ( struct pt_regs * xcp , struct mips_fpu_struct * ctx , void * __user * fault_addr ) { mips_instruction ir ; unsigned long emulpc , contpc ; unsigned int cond ; if ( ! access_ok ( VERIFY_READ , xcp -> cp0_epc , sizeof ( mips_instruction ) ) ) { MIPS_FPU_EMU_INC_STATS ( errors ) ; * fault_addr = ( mips_instruction __user * ) xcp -> cp0_epc ; return SIGBUS ; } if ( __get_user ( ir , ( mips_instruction __user * ) xcp -> cp0_epc ) ) { MIPS_FPU_EMU_INC_STATS ( errors ) ; * fault_addr = ( mips_instruction __user * ) xcp -> cp0_epc ; return SIGSEGV ; } if ( ( xcp -> cp0_cause & CAUSEF_BD ) && ! isBranchInstr ( & ir ) ) xcp -> cp0_cause &= ~ CAUSEF_BD ; if ( xcp -> cp0_cause & CAUSEF_BD ) { emulpc = xcp -> cp0_epc + 4 ; if ( __compute_return_epc ( xcp ) ) { # ifdef CP1DBG printk ( ""failed<S2SV_blank>to<S2SV_blank>emulate<S2SV_blank>branch<S2SV_blank>at<S2SV_blank>%p\\n"" , ( void * ) ( xcp -> cp0_epc ) ) ; # endif return SIGILL ; } if ( ! access_ok ( VERIFY_READ , emulpc , sizeof ( mips_instruction ) ) ) { MIPS_FPU_EMU_INC_STATS ( errors ) ; * fault_addr = ( mips_instruction __user * ) emulpc ; return SIGBUS ; } if ( __get_user ( ir , ( mips_instruction __user * ) emulpc ) ) { MIPS_FPU_EMU_INC_STATS ( errors ) ; * fault_addr = ( mips_instruction __user * ) emulpc ; return SIGSEGV ; } contpc = xcp -> cp0_epc ; xcp -> cp0_epc = emulpc - 4 ; } else { emulpc = xcp -> cp0_epc ; contpc = xcp -> cp0_epc + 4 ; } emul : perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , <S2SV_StartBug> 1 , 0 , xcp , 0 ) ; <S2SV_EndBug> MIPS_FPU_EMU_INC_STATS ( emulated ) ; switch ( MIPSInst_OPCODE ( ir ) ) { case ldc1_op : { u64 __user * va = ( u64 __user * ) ( xcp -> regs [ MIPSInst_RS ( ir ) ] + MIPSInst_SIMM ( ir ) ) ; u64 val ; MIPS_FPU_EMU_INC_STATS ( loads ) ; if ( ! access_ok ( VERIFY_READ , va , sizeof ( u64 ) ) ) { MIPS_FPU_EMU_INC_STATS ( errors ) ; * fault_addr = va ; return SIGBUS ; } if ( __get_user ( val , va ) ) { MIPS_FPU_EMU_INC_STATS ( errors ) ; * fault_addr = va ; return SIGSEGV ; } DITOREG ( val , MIPSInst_RT ( ir ) ) ; break ; } case sdc1_op : { u64 __user * va = ( u64 __user * ) ( xcp -> regs [ MIPSInst_RS ( ir ) ] + MIPSInst_SIMM ( ir ) ) ; u64 val ; MIPS_FPU_EMU_INC_STATS ( stores ) ; DIFROMREG ( val , MIPSInst_RT ( ir ) ) ; if ( ! access_ok ( VERIFY_WRITE , va , sizeof ( u64 ) ) ) { MIPS_FPU_EMU_INC_STATS ( errors ) ; * fault_addr = va ; return SIGBUS ; } if ( __put_user ( val , va ) ) { MIPS_FPU_EMU_INC_STATS ( errors ) ; * fault_addr = va ; return SIGSEGV ; } break ; } case lwc1_op : { u32 __user * va = ( u32 __user * ) ( xcp -> regs [ MIPSInst_RS ( ir ) ] + MIPSInst_SIMM ( ir ) ) ; u32 val ; MIPS_FPU_EMU_INC_STATS ( loads ) ; if ( ! access_ok ( VERIFY_READ , va , sizeof ( u32 ) ) ) { MIPS_FPU_EMU_INC_STATS ( errors ) ; * fault_addr = va ; return SIGBUS ; } if ( __get_user ( val , va ) ) { MIPS_FPU_EMU_INC_STATS ( errors ) ; * fault_addr = va ; return SIGSEGV ; } SITOREG ( val , MIPSInst_RT ( ir ) ) ; break ; } case swc1_op : { u32 __user * va = ( u32 __user * ) ( xcp -> regs [ MIPSInst_RS ( ir ) ] + MIPSInst_SIMM ( ir ) ) ; u32 val ; MIPS_FPU_EMU_INC_STATS ( stores ) ; SIFROMREG ( val , MIPSInst_RT ( ir ) ) ; if ( ! access_ok ( VERIFY_WRITE , va , sizeof ( u32 ) ) ) { MIPS_FPU_EMU_INC_STATS ( errors ) ; * fault_addr = va ; return SIGBUS ; } if ( __put_user ( val , va ) ) { MIPS_FPU_EMU_INC_STATS ( errors ) ; * fault_addr = va ; return SIGSEGV ; } break ; } case cop1_op : switch ( MIPSInst_RS ( ir ) ) { # if defined ( __mips64 ) case dmfc_op : if ( MIPSInst_RT ( ir ) != 0 ) { DIFROMREG ( xcp -> regs [ MIPSInst_RT ( ir ) ] , MIPSInst_RD ( ir ) ) ; } break ; case dmtc_op : DITOREG ( xcp -> regs [ MIPSInst_RT ( ir ) ] , MIPSInst_RD ( ir ) ) ; break ; # endif case mfc_op : if ( MIPSInst_RT ( ir ) != 0 ) { SIFROMREG ( xcp -> regs [ MIPSInst_RT ( ir ) ] , MIPSInst_RD ( ir ) ) ; } break ; case mtc_op : SITOREG ( xcp -> regs [ MIPSInst_RT ( ir ) ] , MIPSInst_RD ( ir ) ) ; break ; case cfc_op : { u32 value ; if ( MIPSInst_RD ( ir ) == FPCREG_CSR ) { value = ctx -> fcr31 ; value = ( value & ~ FPU_CSR_RM ) | mips_rm [ modeindex ( value ) ] ; # ifdef CSRTRACE printk ( ""%p<S2SV_blank>gpr[%d]<-csr=%08x\\n"" , ( void * ) ( xcp -> cp0_epc ) , MIPSInst_RT ( ir ) , value ) ; # endif } else if ( MIPSInst_RD ( ir ) == FPCREG_RID ) value = 0 ; else value = 0 ; if ( MIPSInst_RT ( ir ) ) xcp -> regs [ MIPSInst_RT ( ir ) ] = value ; break ; } case ctc_op : { u32 value ; if ( MIPSInst_RT ( ir ) == 0 ) value = 0 ; else value = xcp -> regs [ MIPSInst_RT ( ir ) ] ; if ( MIPSInst_RD ( ir ) == FPCREG_CSR ) { # ifdef CSRTRACE printk ( ""%p<S2SV_blank>gpr[%d]->csr=%08x\\n"" , ( void * ) ( xcp -> cp0_epc ) , MIPSInst_RT ( ir ) , value ) ; # endif ctx -> fcr31 = ( value & ~ ( FPU_CSR_RSVD | FPU_CSR_RM ) ) | ieee_rm [ modeindex ( value ) ] ; } if ( ( ctx -> fcr31 >> 5 ) & ctx -> fcr31 & FPU_CSR_ALL_E ) { return SIGFPE ; } break ; } case bc_op : { int likely = 0 ; if ( xcp -> cp0_cause & CAUSEF_BD ) return SIGILL ; # if __mips >= 4 cond = ctx -> fcr31 & fpucondbit [ MIPSInst_RT ( ir ) >> 2 ] ; # else cond = ctx -> fcr31 & FPU_CSR_COND ; # endif switch ( MIPSInst_RT ( ir ) & 3 ) { case bcfl_op : likely = 1 ; case bcf_op : cond = ! cond ; break ; case bctl_op : likely = 1 ; case bct_op : break ; default : return SIGILL ; } xcp -> cp0_cause |= CAUSEF_BD ; if ( cond ) { xcp -> cp0_epc += 4 ; contpc = ( xcp -> cp0_epc + ( MIPSInst_SIMM ( ir ) << 2 ) ) ; if ( ! access_ok ( VERIFY_READ , xcp -> cp0_epc , sizeof ( mips_instruction ) ) ) { MIPS_FPU_EMU_INC_STATS ( errors ) ; * fault_addr = ( mips_instruction __user * ) xcp -> cp0_epc ; return SIGBUS ; } if ( __get_user ( ir , ( mips_instruction __user * ) xcp -> cp0_epc ) ) { MIPS_FPU_EMU_INC_STATS ( errors ) ; * fault_addr = ( mips_instruction __user * ) xcp -> cp0_epc ; return SIGSEGV ; } switch ( MIPSInst_OPCODE ( ir ) ) { case lwc1_op : case swc1_op : # if ( __mips >= 2 || defined ( __mips64 ) ) case ldc1_op : case sdc1_op : # endif case cop1_op : # if __mips >= 4 && __mips != 32 case cop1x_op : # endif goto emul ; # if __mips >= 4 case spec_op : if ( MIPSInst_FUNC ( ir ) == movc_op ) goto emul ; break ; # endif } return mips_dsemul ( xcp , ir , contpc ) ; } else { if ( likely ) { xcp -> cp0_epc += 4 ; contpc += 4 ; } } break ; } default : if ( ! ( MIPSInst_RS ( ir ) & 0x10 ) ) return SIGILL ; { int sig ; if ( ( sig = fpu_emu ( xcp , ctx , ir ) ) ) return sig ; } } break ; # if __mips >= 4 && __mips != 32 case cop1x_op : { int sig = fpux_emu ( xcp , ctx , ir , fault_addr ) ; if ( sig ) return sig ; break ; } # endif # if __mips >= 4 case spec_op : if ( MIPSInst_FUNC ( ir ) != movc_op ) return SIGILL ; cond = fpucondbit [ MIPSInst_RT ( ir ) >> 2 ] ; if ( ( ( ctx -> fcr31 & cond ) != 0 ) == ( ( MIPSInst_RT ( ir ) & 1 ) != 0 ) ) xcp -> regs [ MIPSInst_RD ( ir ) ] = xcp -> regs [ MIPSInst_RS ( ir ) ] ; break ; # endif default : return SIGILL ; } xcp -> cp0_epc = contpc ; xcp -> cp0_cause &= ~ CAUSEF_BD ; return 0 ; }
","<S2SV_ModStart> PERF_COUNT_SW_EMULATION_FAULTS , 1 <S2SV_ModEnd> , xcp ,
"
370,"CWE-399 static void hugetlb_vm_op_close ( struct vm_area_struct * vma ) { struct hstate * h = hstate_vma ( vma ) ; struct resv_map * reservations = vma_resv_map ( vma ) ; struct hugepage_subpool * spool = subpool_vma ( vma ) ; unsigned long reserve ; unsigned long start ; unsigned long end ; if ( reservations ) { start = vma_hugecache_offset ( h , vma , vma -> vm_start ) ; end = vma_hugecache_offset ( h , vma , vma -> vm_end ) ; reserve = ( end - start ) - region_count ( & reservations -> regions , start , end ) ; <S2SV_StartBug> kref_put ( & reservations -> refs , resv_map_release ) ; <S2SV_EndBug> if ( reserve ) { hugetlb_acct_memory ( h , - reserve ) ; hugepage_subpool_put_pages ( spool , reserve ) ; } } }
","<S2SV_ModStart> end ) ; resv_map_put ( vma <S2SV_ModEnd> ) ; if
"
371,"CWE-20 static int rose_parse_national ( unsigned char * p , struct rose_facilities_struct * facilities , int len ) { unsigned char * pt ; unsigned char l , lg , n = 0 ; int fac_national_digis_received = 0 ; do { switch ( * p & 0xC0 ) { case 0x00 : p += 2 ; n += 2 ; len -= 2 ; break ; case 0x40 : if ( * p == FAC_NATIONAL_RAND ) facilities -> rand = ( ( p [ 1 ] << 8 ) & 0xFF00 ) + ( ( p [ 2 ] << 0 ) & 0x00FF ) ; p += 3 ; n += 3 ; len -= 3 ; break ; case 0x80 : p += 4 ; n += 4 ; len -= 4 ; break ; case 0xC0 : l = p [ 1 ] ; if ( * p == FAC_NATIONAL_DEST_DIGI ) { if ( ! fac_national_digis_received ) { memcpy ( & facilities -> source_digis [ 0 ] , p + 2 , AX25_ADDR_LEN ) ; facilities -> source_ndigis = 1 ; } } else if ( * p == FAC_NATIONAL_SRC_DIGI ) { if ( ! fac_national_digis_received ) { memcpy ( & facilities -> dest_digis [ 0 ] , p + 2 , AX25_ADDR_LEN ) ; facilities -> dest_ndigis = 1 ; } } else if ( * p == FAC_NATIONAL_FAIL_CALL ) { memcpy ( & facilities -> fail_call , p + 2 , AX25_ADDR_LEN ) ; } else if ( * p == FAC_NATIONAL_FAIL_ADD ) { memcpy ( & facilities -> fail_addr , p + 3 , ROSE_ADDR_LEN ) ; } else if ( * p == FAC_NATIONAL_DIGIS ) { fac_national_digis_received = 1 ; facilities -> source_ndigis = 0 ; facilities -> dest_ndigis = 0 ; for ( pt = p + 2 , lg = 0 ; lg < l ; pt += AX25_ADDR_LEN , lg += AX25_ADDR_LEN ) { <S2SV_StartBug> if ( pt [ 6 ] & AX25_HBIT ) <S2SV_EndBug> memcpy ( & facilities -> dest_digis [ facilities -> dest_ndigis ++ ] , pt , AX25_ADDR_LEN ) ; <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> memcpy ( & facilities -> source_digis [ facilities -> source_ndigis ++ ] , pt , AX25_ADDR_LEN ) ; <S2SV_EndBug> } } p += l + 2 ; n += l + 2 ; len -= l + 2 ; break ; } } while ( * p != 0x00 && len > 0 ) ; return n ; }
","<S2SV_ModStart> & AX25_HBIT ) { if ( facilities -> dest_ndigis >= ROSE_MAX_DIGIS ) return - 1 ; <S2SV_ModStart> AX25_ADDR_LEN ) ; } else { if ( facilities -> source_ndigis >= ROSE_MAX_DIGIS ) return - 1 ; <S2SV_ModEnd> memcpy ( & <S2SV_ModStart> AX25_ADDR_LEN ) ; }
"
372,"CWE-200 static int get_bitmap_file ( struct mddev * mddev , void __user * arg ) { mdu_bitmap_file_t * file = NULL ; char * ptr ; int err ; <S2SV_StartBug> file = kmalloc ( sizeof ( * file ) , GFP_NOIO ) ; <S2SV_EndBug> if ( ! file ) return - ENOMEM ; err = 0 ; spin_lock ( & mddev -> lock ) ; if ( ! mddev -> bitmap_info . file ) file -> pathname [ 0 ] = '\\0' ; else if ( ( ptr = file_path ( mddev -> bitmap_info . file , file -> pathname , sizeof ( file -> pathname ) ) ) , IS_ERR ( ptr ) ) err = PTR_ERR ( ptr ) ; else memmove ( file -> pathname , ptr , sizeof ( file -> pathname ) - ( ptr - file -> pathname ) ) ; spin_unlock ( & mddev -> lock ) ; if ( err == 0 && copy_to_user ( arg , file , sizeof ( * file ) ) ) err = - EFAULT ; kfree ( file ) ; return err ; }
","<S2SV_ModStart> ; file = kzalloc <S2SV_ModEnd> ( sizeof (
"
373,"CWE-119 static int aiff_read_chanmap ( SF_PRIVATE * psf , unsigned dword ) { const AIFF_CAF_CHANNEL_MAP * map_info ; unsigned channel_bitmap , channel_decriptions , bytesread ; int layout_tag ; bytesread = psf_binheader_readf ( psf , ""444"" , & layout_tag , & channel_bitmap , & channel_decriptions ) ; if ( ( map_info = aiff_caf_of_channel_layout_tag ( layout_tag ) ) == NULL ) return 0 ; psf_log_printf ( psf , ""<S2SV_blank><S2SV_blank>Tag<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>:<S2SV_blank>%x\\n"" , layout_tag ) ; if ( map_info ) psf_log_printf ( psf , ""<S2SV_blank><S2SV_blank>Layout<S2SV_blank>:<S2SV_blank>%s\\n"" , map_info -> name ) ; if ( bytesread < dword ) psf_binheader_readf ( psf , ""j"" , dword - bytesread ) ; if ( map_info -> channel_map != NULL ) <S2SV_StartBug> { size_t chanmap_size = psf -> sf . channels * sizeof ( psf -> channel_map [ 0 ] ) ; <S2SV_EndBug> free ( psf -> channel_map ) ; if ( ( psf -> channel_map = malloc ( chanmap_size ) ) == NULL ) return SFE_MALLOC_FAILED ; memcpy ( psf -> channel_map , map_info -> channel_map , chanmap_size ) ; } ; return 0 ; }
","<S2SV_ModStart> size_t chanmap_size = SF_MIN ( <S2SV_ModStart> sf . channels , layout_tag & 0xffff )
"
374,"CWE-772 int hsr_dev_finalize ( struct net_device * hsr_dev , struct net_device * slave [ 2 ] , unsigned char multicast_spec , u8 protocol_version ) { struct hsr_priv * hsr ; struct hsr_port * port ; int res ; hsr = netdev_priv ( hsr_dev ) ; INIT_LIST_HEAD ( & hsr -> ports ) ; INIT_LIST_HEAD ( & hsr -> node_db ) ; INIT_LIST_HEAD ( & hsr -> self_node_db ) ; ether_addr_copy ( hsr_dev -> dev_addr , slave [ 0 ] -> dev_addr ) ; res = hsr_create_self_node ( & hsr -> self_node_db , hsr_dev -> dev_addr , slave [ 1 ] -> dev_addr ) ; if ( res < 0 ) return res ; spin_lock_init ( & hsr -> seqnr_lock ) ; hsr -> sequence_nr = HSR_SEQNR_START ; hsr -> sup_sequence_nr = HSR_SUP_SEQNR_START ; timer_setup ( & hsr -> announce_timer , hsr_announce , 0 ) ; timer_setup ( & hsr -> prune_timer , hsr_prune_nodes , 0 ) ; ether_addr_copy ( hsr -> sup_multicast_addr , def_multicast_addr ) ; hsr -> sup_multicast_addr [ ETH_ALEN - 1 ] = multicast_spec ; hsr -> protVersion = protocol_version ; netif_carrier_off ( hsr_dev ) ; res = hsr_add_port ( hsr , hsr_dev , HSR_PT_MASTER ) ; if ( res ) <S2SV_StartBug> return res ; <S2SV_EndBug> res = register_netdevice ( hsr_dev ) ; if ( res ) goto fail ; res = hsr_add_port ( hsr , slave [ 0 ] , HSR_PT_SLAVE_A ) ; if ( res ) goto fail ; res = hsr_add_port ( hsr , slave [ 1 ] , HSR_PT_SLAVE_B ) ; if ( res ) goto fail ; mod_timer ( & hsr -> prune_timer , jiffies + msecs_to_jiffies ( PRUNE_PERIOD ) ) ; return 0 ; fail : hsr_for_each_port ( hsr , port ) hsr_del_port ( port ) ; <S2SV_StartBug> return res ; <S2SV_EndBug> }
","<S2SV_ModStart> ( res ) goto err_add_port <S2SV_ModEnd> ; res = <S2SV_ModStart> port ) ; err_add_port : hsr_del_node ( & hsr -> self_node_db ) ;
"
375,"CWE-119 WORD32 ih264d_video_decode ( iv_obj_t * dec_hdl , void * pv_api_ip , void * pv_api_op ) { dec_struct_t * ps_dec = ( dec_struct_t * ) ( dec_hdl -> pv_codec_handle ) ; WORD32 i4_err_status = 0 ; UWORD8 * pu1_buf = NULL ; WORD32 buflen ; UWORD32 u4_max_ofst , u4_length_of_start_code = 0 ; UWORD32 bytes_consumed = 0 ; UWORD32 cur_slice_is_nonref = 0 ; UWORD32 u4_next_is_aud ; UWORD32 u4_first_start_code_found = 0 ; WORD32 ret = 0 , api_ret_value = IV_SUCCESS ; WORD32 header_data_left = 0 , frame_data_left = 0 ; UWORD8 * pu1_bitstrm_buf ; ivd_video_decode_ip_t * ps_dec_ip ; ivd_video_decode_op_t * ps_dec_op ; ithread_set_name ( ( void * ) ""Parse_thread"" ) ; ps_dec_ip = ( ivd_video_decode_ip_t * ) pv_api_ip ; ps_dec_op = ( ivd_video_decode_op_t * ) pv_api_op ; { UWORD32 u4_size ; u4_size = ps_dec_op -> u4_size ; memset ( ps_dec_op , 0 , sizeof ( ivd_video_decode_op_t ) ) ; ps_dec_op -> u4_size = u4_size ; } ps_dec -> pv_dec_out = ps_dec_op ; if ( ps_dec -> init_done != 1 ) { return IV_FAIL ; } DATA_SYNC ( ) ; if ( 0 == ps_dec -> u1_flushfrm ) { if ( ps_dec_ip -> pv_stream_buffer == NULL ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL ; return IV_FAIL ; } if ( ps_dec_ip -> u4_num_Bytes <= 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DEC_NUMBYTES_INV ; return IV_FAIL ; } } ps_dec -> u1_pic_decode_done = 0 ; ps_dec_op -> u4_num_bytes_consumed = 0 ; ps_dec -> ps_out_buffer = NULL ; if ( ps_dec_ip -> u4_size >= offsetof ( ivd_video_decode_ip_t , s_out_buffer ) ) ps_dec -> ps_out_buffer = & ps_dec_ip -> s_out_buffer ; ps_dec -> u4_fmt_conv_cur_row = 0 ; ps_dec -> u4_output_present = 0 ; ps_dec -> s_disp_op . u4_error_code = 1 ; ps_dec -> u4_fmt_conv_num_rows = FMT_CONV_NUM_ROWS ; if ( 0 == ps_dec -> u4_share_disp_buf && ps_dec -> i4_decode_header == 0 ) { UWORD32 i ; if ( ps_dec -> ps_out_buffer -> u4_num_bufs == 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS ; return IV_FAIL ; } for ( i = 0 ; i < ps_dec -> ps_out_buffer -> u4_num_bufs ; i ++ ) { if ( ps_dec -> ps_out_buffer -> pu1_bufs [ i ] == NULL ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL ; return IV_FAIL ; } if ( ps_dec -> ps_out_buffer -> u4_min_out_buf_size [ i ] == 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUF_SIZE ; return IV_FAIL ; } } } if ( ps_dec -> u4_total_frames_decoded >= NUM_FRAMES_LIMIT ) { ps_dec_op -> u4_error_code = ERROR_FRAME_LIMIT_OVER ; return IV_FAIL ; } ps_dec -> u4_ts = ps_dec_ip -> u4_ts ; ps_dec_op -> u4_error_code = 0 ; ps_dec_op -> e_pic_type = - 1 ; ps_dec_op -> u4_output_present = 0 ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec -> i4_frametype = - 1 ; ps_dec -> i4_content_type = - 1 ; { if ( ( TOP_FIELD_ONLY | BOT_FIELD_ONLY ) == ps_dec -> u1_top_bottom_decoded ) { ps_dec -> u1_top_bottom_decoded = 0 ; } } ps_dec -> u4_slice_start_code_found = 0 ; if ( ps_dec -> u1_init_dec_flag == 1 && ps_dec -> u4_share_disp_buf == 1 && ps_dec -> u1_flushfrm == 0 ) { UWORD32 i ; WORD32 disp_avail = 0 , free_id ; for ( i = 0 ; i < ps_dec -> u1_pic_bufs ; i ++ ) { if ( 0 == ps_dec -> u4_disp_buf_mapping [ i ] || 1 == ps_dec -> u4_disp_buf_to_be_freed [ i ] ) { disp_avail = 1 ; break ; } } if ( 0 == disp_avail ) { ps_dec_op -> u4_error_code = IVD_DEC_REF_BUF_NULL ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; return ( IV_FAIL ) ; } while ( 1 ) { pic_buffer_t * ps_pic_buf ; ps_pic_buf = ( pic_buffer_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , & free_id ) ; if ( ps_pic_buf == NULL ) { UWORD32 i , display_queued = 0 ; for ( i = 0 ; i < ( MAX_DISP_BUFS_NEW ) ; i ++ ) { if ( 0 != ps_dec -> u4_disp_buf_mapping [ i ] ) { display_queued = 1 ; break ; } } if ( 1 == display_queued ) { ps_dec_op -> u4_error_code = IVD_DEC_REF_BUF_NULL ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; return ( IV_FAIL ) ; } } else { if ( 1 == ps_dec -> u4_disp_buf_mapping [ free_id ] ) { ih264_buf_mgr_set_status ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , free_id , BUF_MGR_IO ) ; } else { ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , free_id , BUF_MGR_IO ) ; break ; } } } } if ( ps_dec -> u1_flushfrm && ps_dec -> u1_init_dec_flag ) { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 == ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = 0 ; ps_dec -> u4_fmt_conv_num_rows = ps_dec -> s_disp_frame_info . u4_y_ht ; ih264d_format_convert ( ps_dec , & ( ps_dec -> s_disp_op ) , ps_dec -> u4_fmt_conv_cur_row , ps_dec -> u4_fmt_conv_num_rows ) ; ps_dec -> u4_fmt_conv_cur_row += ps_dec -> u4_fmt_conv_num_rows ; ps_dec -> u4_output_present = 1 ; } ih264d_release_display_field ( ps_dec , & ( ps_dec -> s_disp_op ) ) ; ps_dec_op -> u4_pic_wd = ( UWORD32 ) ps_dec -> u2_disp_width ; ps_dec_op -> u4_pic_ht = ( UWORD32 ) ps_dec -> u2_disp_height ; ps_dec_op -> u4_new_seq = 0 ; ps_dec_op -> u4_output_present = ps_dec -> u4_output_present ; ps_dec_op -> u4_progressive_frame_flag = ps_dec -> s_disp_op . u4_progressive_frame_flag ; ps_dec_op -> e_output_format = ps_dec -> s_disp_op . e_output_format ; ps_dec_op -> s_disp_frm_buf = ps_dec -> s_disp_op . s_disp_frm_buf ; ps_dec_op -> e4_fld_type = ps_dec -> s_disp_op . e4_fld_type ; ps_dec_op -> u4_ts = ps_dec -> s_disp_op . u4_ts ; ps_dec_op -> u4_disp_buf_id = ps_dec -> s_disp_op . u4_disp_buf_id ; ps_dec_op -> u4_is_ref_flag = - 1 ; ps_dec_op -> e_pic_type = IV_NA_FRAME ; ps_dec_op -> u4_frame_decoded_flag = 0 ; if ( 0 == ps_dec -> s_disp_op . u4_error_code ) { return ( IV_SUCCESS ) ; } else return ( IV_FAIL ) ; } if ( ps_dec -> u1_res_changed == 1 ) { ih264d_init_decoder ( ps_dec ) ; } ps_dec -> u4_prev_nal_skipped = 0 ; ps_dec -> u2_cur_mb_addr = 0 ; ps_dec -> u2_total_mbs_coded = 0 ; ps_dec -> u2_cur_slice_num = 0 ; ps_dec -> cur_dec_mb_num = 0 ; ps_dec -> cur_recon_mb_num = 0 ; ps_dec -> u4_first_slice_in_pic = 2 ; ps_dec -> u1_slice_header_done = 0 ; ps_dec -> u1_dangling_field = 0 ; ps_dec -> u4_dec_thread_created = 0 ; ps_dec -> u4_bs_deblk_thread_created = 0 ; <S2SV_StartBug> ps_dec -> u4_cur_bs_mb_num = 0 ; <S2SV_EndBug> DEBUG_THREADS_PRINTF ( ""<S2SV_blank>Starting<S2SV_blank>process<S2SV_blank>call\\n"" ) ; ps_dec -> u4_pic_buf_got = 0 ; do { WORD32 buf_size ; pu1_buf = ( UWORD8 * ) ps_dec_ip -> pv_stream_buffer + ps_dec_op -> u4_num_bytes_consumed ; u4_max_ofst = ps_dec_ip -> u4_num_Bytes - ps_dec_op -> u4_num_bytes_consumed ; if ( ( NULL == ps_dec -> pu1_bits_buf_dynamic ) && ( ps_dec -> i4_header_decoded & 1 ) ) { WORD32 size ; void * pv_buf ; void * pv_mem_ctxt = ps_dec -> pv_mem_ctxt ; size = MAX ( 256000 , ps_dec -> u2_pic_wd * ps_dec -> u2_pic_ht * 3 / 2 ) ; pv_buf = ps_dec -> pf_aligned_alloc ( pv_mem_ctxt , 128 , size ) ; RETURN_IF ( ( NULL == pv_buf ) , IV_FAIL ) ; ps_dec -> pu1_bits_buf_dynamic = pv_buf ; ps_dec -> u4_dynamic_bits_buf_size = size ; } if ( ps_dec -> pu1_bits_buf_dynamic ) { pu1_bitstrm_buf = ps_dec -> pu1_bits_buf_dynamic ; buf_size = ps_dec -> u4_dynamic_bits_buf_size ; } else { pu1_bitstrm_buf = ps_dec -> pu1_bits_buf_static ; buf_size = ps_dec -> u4_static_bits_buf_size ; } u4_next_is_aud = 0 ; buflen = ih264d_find_start_code ( pu1_buf , 0 , u4_max_ofst , & u4_length_of_start_code , & u4_next_is_aud ) ; if ( buflen == - 1 ) buflen = 0 ; buflen = MIN ( buflen , buf_size ) ; bytes_consumed = buflen + u4_length_of_start_code ; ps_dec_op -> u4_num_bytes_consumed += bytes_consumed ; { UWORD8 u1_firstbyte , u1_nal_ref_idc ; if ( ps_dec -> i4_app_skip_mode == IVD_SKIP_B ) { u1_firstbyte = * ( pu1_buf + u4_length_of_start_code ) ; u1_nal_ref_idc = ( UWORD8 ) ( NAL_REF_IDC ( u1_firstbyte ) ) ; if ( u1_nal_ref_idc == 0 ) { cur_slice_is_nonref = 1 ; continue ; } else { if ( 1 == cur_slice_is_nonref ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; ps_dec_op -> e_pic_type = IV_B_FRAME ; ps_dec_op -> u4_error_code = IVD_DEC_FRM_SKIPPED ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec_op -> u4_size = sizeof ( ivd_video_decode_op_t ) ; ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return ( IV_FAIL ) ; } } } } if ( buflen ) { memcpy ( pu1_bitstrm_buf , pu1_buf + u4_length_of_start_code , buflen ) ; if ( ( buflen + 8 ) < buf_size ) { memset ( pu1_bitstrm_buf + buflen , 0 , 8 ) ; } u4_first_start_code_found = 1 ; } else { if ( u4_first_start_code_found == 0 ) { ps_dec -> i4_error_code = ERROR_START_CODE_NOT_FOUND ; ps_dec_op -> u4_error_code |= 1 << IVD_INSUFFICIENTDATA ; if ( ps_dec -> u4_pic_buf_got == 0 ) { ih264d_fill_output_struct_from_context ( ps_dec , ps_dec_op ) ; ps_dec_op -> u4_error_code = ps_dec -> i4_error_code ; ps_dec_op -> u4_frame_decoded_flag = 0 ; return ( IV_FAIL ) ; } else { ps_dec -> u1_pic_decode_done = 1 ; continue ; } } else { frame_data_left = 0 ; continue ; } } ps_dec -> u4_return_to_app = 0 ; ret = ih264d_parse_nal_unit ( dec_hdl , ps_dec_op , pu1_bitstrm_buf , buflen ) ; if ( ret != OK ) { UWORD32 error = ih264d_map_error ( ret ) ; ps_dec_op -> u4_error_code = error | ret ; api_ret_value = IV_FAIL ; if ( ( ret == IVD_RES_CHANGED ) || ( ret == IVD_MEM_ALLOC_FAILED ) || ( ret == ERROR_UNAVAIL_PICBUF_T ) || ( ret == ERROR_UNAVAIL_MVBUF_T ) ) { break ; } if ( ( ret == ERROR_INCOMPLETE_FRAME ) || ( ret == ERROR_DANGLING_FIELD_IN_PIC ) ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; api_ret_value = IV_FAIL ; break ; } if ( ret == ERROR_IN_LAST_SLICE_OF_PIC ) { api_ret_value = IV_FAIL ; break ; } } if ( ps_dec -> u4_return_to_app ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; ps_dec_op -> u4_error_code = IVD_DEC_FRM_SKIPPED ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec_op -> u4_size = sizeof ( ivd_video_decode_op_t ) ; ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return ( IV_FAIL ) ; } header_data_left = ( ( ps_dec -> i4_decode_header == 1 ) && ( ps_dec -> i4_header_decoded != 3 ) && ( ps_dec_op -> u4_num_bytes_consumed < ps_dec_ip -> u4_num_Bytes ) ) ; frame_data_left = ( ( ( ps_dec -> i4_decode_header == 0 ) && ( ( ps_dec -> u1_pic_decode_done == 0 ) || ( u4_next_is_aud == 1 ) ) ) && ( ps_dec_op -> u4_num_bytes_consumed < ps_dec_ip -> u4_num_Bytes ) ) ; } while ( ( header_data_left == 1 ) || ( frame_data_left == 1 ) ) ; if ( ( ps_dec -> u4_slice_start_code_found == 1 ) && ( ret != IVD_MEM_ALLOC_FAILED ) && ps_dec -> u2_total_mbs_coded < ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { WORD32 num_mb_skipped ; WORD32 prev_slice_err ; pocstruct_t temp_poc ; WORD32 ret1 ; num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; if ( ps_dec -> u4_first_slice_in_pic && ( ps_dec -> u4_pic_buf_got == 0 ) ) prev_slice_err = 1 ; else prev_slice_err = 2 ; ret1 = ih264d_mark_err_slice_skip ( ps_dec , num_mb_skipped , ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL , ps_dec -> ps_cur_slice -> u2_frame_num , & temp_poc , prev_slice_err ) ; if ( ( ret1 == ERROR_UNAVAIL_PICBUF_T ) || ( ret1 == ERROR_UNAVAIL_MVBUF_T ) ) { return IV_FAIL ; } } if ( ( ret == IVD_RES_CHANGED ) || ( ret == IVD_MEM_ALLOC_FAILED ) || ( ret == ERROR_UNAVAIL_PICBUF_T ) || ( ret == ERROR_UNAVAIL_MVBUF_T ) ) { ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } if ( ret == IVD_RES_CHANGED ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; } return IV_FAIL ; } if ( ps_dec -> u1_separate_parse ) { if ( ps_dec -> u4_num_cores == 2 ) { if ( ( ps_dec -> u4_nmb_deblk == 0 ) && ( ps_dec -> u4_start_recon_deblk == 1 ) && ( ps_dec -> ps_cur_sps -> u1_mb_aff_flag == 0 ) ) { UWORD32 u4_num_mbs , u4_max_addr ; tfr_ctxt_t s_tfr_ctxt ; tfr_ctxt_t * ps_tfr_cxt = & s_tfr_ctxt ; pad_mgr_t * ps_pad_mgr = & ps_dec -> s_pad_mgr ; u4_max_addr = ( ps_dec -> u2_frm_wd_in_mbs * ps_dec -> u2_frm_ht_in_mbs ) - 1 ; ps_dec -> u4_cur_bs_mb_num = u4_max_addr + 1 ; ih264d_init_deblk_tfr_ctxt ( ps_dec , ps_pad_mgr , ps_tfr_cxt , ps_dec -> u2_frm_wd_in_mbs , 0 ) ; u4_num_mbs = u4_max_addr - ps_dec -> u4_cur_deblk_mb_num + 1 ; DEBUG_PERF_PRINTF ( ""mbs<S2SV_blank>left<S2SV_blank>for<S2SV_blank>deblocking=<S2SV_blank>%d<S2SV_blank>\\n"" , u4_num_mbs ) ; if ( u4_num_mbs != 0 ) ih264d_check_mb_map_deblk ( ps_dec , u4_num_mbs , ps_tfr_cxt , 1 ) ; ps_dec -> u4_start_recon_deblk = 0 ; } } ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } } DATA_SYNC ( ) ; if ( ( ps_dec_op -> u4_error_code & 0xff ) != ERROR_DYNAMIC_RESOLUTION_NOT_SUPPORTED ) { ps_dec_op -> u4_pic_wd = ( UWORD32 ) ps_dec -> u2_disp_width ; ps_dec_op -> u4_pic_ht = ( UWORD32 ) ps_dec -> u2_disp_height ; } if ( ps_dec -> i4_header_decoded != 3 ) { ps_dec_op -> u4_error_code |= ( 1 << IVD_INSUFFICIENTDATA ) ; } if ( ps_dec -> i4_decode_header == 1 && ps_dec -> i4_header_decoded != 3 ) { ps_dec_op -> u4_error_code |= ( 1 << IVD_INSUFFICIENTDATA ) ; } if ( ps_dec -> u4_prev_nal_skipped ) { ps_dec_op -> u4_error_code = IVD_DEC_FRM_SKIPPED ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec_op -> u4_size = sizeof ( ivd_video_decode_op_t ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return ( IV_FAIL ) ; } if ( ( ps_dec -> u4_slice_start_code_found == 1 ) && ( ERROR_DANGLING_FIELD_IN_PIC != i4_err_status ) ) { if ( ps_dec -> ps_cur_slice -> u1_field_pic_flag ) { if ( 1 == ps_dec -> ps_cur_slice -> u1_bottom_field_flag ) { ps_dec -> u1_top_bottom_decoded |= BOT_FIELD_ONLY ; } else { ps_dec -> u1_top_bottom_decoded |= TOP_FIELD_ONLY ; } } if ( ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) == 0 ) { ret = ih264d_deblock_display ( ps_dec ) ; if ( ret != 0 ) { return IV_FAIL ; } } if ( ps_dec -> i4_header_decoded == 3 ) { ps_dec -> u2_total_mbs_coded = ps_dec -> ps_cur_sps -> u2_max_mb_addr + 1 ; } if ( ps_dec -> ps_cur_slice -> u1_nal_unit_type == IDR_SLICE_NAL ) { ps_dec -> i4_frametype = IV_IDR_FRAME ; } else if ( ps_dec -> i4_pic_type == B_SLICE ) { ps_dec -> i4_frametype = IV_B_FRAME ; } else if ( ps_dec -> i4_pic_type == P_SLICE ) { ps_dec -> i4_frametype = IV_P_FRAME ; } else if ( ps_dec -> i4_pic_type == I_SLICE ) { ps_dec -> i4_frametype = IV_I_FRAME ; } else { H264_DEC_DEBUG_PRINT ( ""Shouldn\'t<S2SV_blank>come<S2SV_blank>here\\n"" ) ; } ps_dec -> i4_content_type = ps_dec -> ps_cur_slice -> u1_field_pic_flag ; ps_dec -> u4_total_frames_decoded = ps_dec -> u4_total_frames_decoded + 2 ; ps_dec -> u4_total_frames_decoded = ps_dec -> u4_total_frames_decoded - ps_dec -> ps_cur_slice -> u1_field_pic_flag ; } if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } { if ( ( IVD_DECODE_FRAME_OUT == ps_dec -> e_frm_out_mode ) && ps_dec -> u1_init_dec_flag ) { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 == ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = 0 ; ps_dec -> u4_output_present = 1 ; } } ih264d_fill_output_struct_from_context ( ps_dec , ps_dec_op ) ; if ( ps_dec -> u4_output_present && ( ps_dec -> u4_fmt_conv_cur_row < ps_dec -> s_disp_frame_info . u4_y_ht ) ) { ps_dec -> u4_fmt_conv_num_rows = ps_dec -> s_disp_frame_info . u4_y_ht - ps_dec -> u4_fmt_conv_cur_row ; ih264d_format_convert ( ps_dec , & ( ps_dec -> s_disp_op ) , ps_dec -> u4_fmt_conv_cur_row , ps_dec -> u4_fmt_conv_num_rows ) ; ps_dec -> u4_fmt_conv_cur_row += ps_dec -> u4_fmt_conv_num_rows ; } ih264d_release_display_field ( ps_dec , & ( ps_dec -> s_disp_op ) ) ; } if ( ps_dec -> i4_decode_header == 1 && ( ps_dec -> i4_header_decoded & 1 ) == 1 ) { ps_dec_op -> u4_progressive_frame_flag = 1 ; if ( ( NULL != ps_dec -> ps_cur_sps ) && ( 1 == ( ps_dec -> ps_cur_sps -> u1_is_valid ) ) ) { if ( ( 0 == ps_dec -> ps_sps -> u1_frame_mbs_only_flag ) && ( 0 == ps_dec -> ps_sps -> u1_mb_aff_flag ) ) ps_dec_op -> u4_progressive_frame_flag = 0 ; } } DATA_SYNC ( ) ; H264_DEC_DEBUG_PRINT ( ""The<S2SV_blank>num<S2SV_blank>bytes<S2SV_blank>consumed:<S2SV_blank>%d\\n"" , ps_dec_op -> u4_num_bytes_consumed ) ; return api_ret_value ; }
","<S2SV_ModStart> ps_dec -> u4_cur_bs_mb_num = 0 ; ps_dec -> u4_start_recon_deblk
"
376,"CWE-20 static Image * ReadCUTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { <S2SV_StartBug> # define ThrowCUTReaderException ( severity , tag ) { if ( palette != NULL ) palette = DestroyImage ( palette ) ; if ( clone_info != NULL ) clone_info = DestroyImageInfo ( clone_info ) ; ThrowReaderException ( severity , tag ) ; } <S2SV_EndBug> Image * image , * palette ; ImageInfo * clone_info ; MagickBooleanType status ; MagickOffsetType offset ; size_t EncodedByte ; unsigned char RunCount , RunValue , RunCountMasked ; CUTHeader Header ; CUTPalHeader PalHeader ; ssize_t depth ; ssize_t i , j ; ssize_t ldblk ; unsigned char * BImgBuff = NULL , * ptrB ; register Quantum * q ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } palette = NULL ; clone_info = NULL ; Header . Width = ReadBlobLSBShort ( image ) ; Header . Height = ReadBlobLSBShort ( image ) ; Header . Reserved = ReadBlobLSBShort ( image ) ; if ( Header . Width == 0 || Header . Height == 0 || Header . Reserved != 0 ) CUT_KO : ThrowCUTReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; EncodedByte = ReadBlobLSBShort ( image ) ; RunCount = ( unsigned char ) ReadBlobByte ( image ) ; RunCountMasked = RunCount & 0x7F ; ldblk = 0 ; while ( ( int ) RunCountMasked != 0 ) { i = 1 ; if ( ( int ) RunCount < 0x80 ) i = ( ssize_t ) RunCountMasked ; offset = SeekBlob ( image , TellBlob ( image ) + i , SEEK_SET ) ; if ( offset < 0 ) ThrowCUTReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( EOFBlob ( image ) != MagickFalse ) goto CUT_KO ; EncodedByte -= i + 1 ; ldblk += ( ssize_t ) RunCountMasked ; RunCount = ( unsigned char ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) goto CUT_KO ; RunCountMasked = RunCount & 0x7F ; } if ( EncodedByte != 1 ) goto CUT_KO ; i = 0 ; if ( ldblk == ( int ) Header . Width ) i = 8 ; if ( 2 * ldblk == ( int ) Header . Width ) i = 4 ; if ( 8 * ldblk == ( int ) Header . Width ) i = 1 ; if ( i == 0 ) goto CUT_KO ; depth = i ; image -> columns = Header . Width ; image -> rows = Header . Height ; image -> depth = 8 ; image -> colors = ( size_t ) ( GetQuantumRange ( 1UL * i ) + 1 ) ; if ( image_info -> ping != MagickFalse ) goto Finish ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( ( clone_info = CloneImageInfo ( image_info ) ) == NULL ) goto NoPalette ; i = ( ssize_t ) strlen ( clone_info -> filename ) ; j = i ; while ( -- i > 0 ) { if ( clone_info -> filename [ i ] == '.' ) { break ; } if ( clone_info -> filename [ i ] == '/' || clone_info -> filename [ i ] == '\\\\' || clone_info -> filename [ i ] == ':' ) { i = j ; break ; } } ( void ) CopyMagickString ( clone_info -> filename + i , "".PAL"" , ( size_t ) ( MagickPathExtent - i ) ) ; if ( ( clone_info -> file = fopen_utf8 ( clone_info -> filename , ""rb"" ) ) == NULL ) { ( void ) CopyMagickString ( clone_info -> filename + i , "".pal"" , ( size_t ) ( MagickPathExtent - i ) ) ; if ( ( clone_info -> file = fopen_utf8 ( clone_info -> filename , ""rb"" ) ) == NULL ) { clone_info -> filename [ i ] = '\\0' ; if ( ( clone_info -> file = fopen_utf8 ( clone_info -> filename , ""rb"" ) ) == NULL ) { clone_info = DestroyImageInfo ( clone_info ) ; clone_info = NULL ; goto NoPalette ; } } } if ( ( palette = AcquireImage ( clone_info , exception ) ) == NULL ) goto NoPalette ; status = OpenBlob ( clone_info , palette , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { ErasePalette : palette = DestroyImage ( palette ) ; palette = NULL ; goto NoPalette ; } if ( palette != NULL ) { ( void ) ReadBlob ( palette , 2 , ( unsigned char * ) PalHeader . FileId ) ; if ( strncmp ( PalHeader . FileId , ""AH"" , 2 ) != 0 ) goto ErasePalette ; PalHeader . Version = ReadBlobLSBShort ( palette ) ; PalHeader . Size = ReadBlobLSBShort ( palette ) ; PalHeader . FileType = ( char ) ReadBlobByte ( palette ) ; PalHeader . SubType = ( char ) ReadBlobByte ( palette ) ; PalHeader . BoardID = ReadBlobLSBShort ( palette ) ; PalHeader . GraphicsMode = ReadBlobLSBShort ( palette ) ; PalHeader . MaxIndex = ReadBlobLSBShort ( palette ) ; PalHeader . MaxRed = ReadBlobLSBShort ( palette ) ; PalHeader . MaxGreen = ReadBlobLSBShort ( palette ) ; PalHeader . MaxBlue = ReadBlobLSBShort ( palette ) ; ( void ) ReadBlob ( palette , 20 , ( unsigned char * ) PalHeader . PaletteId ) ; if ( EOFBlob ( image ) ) ThrowCUTReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( PalHeader . MaxIndex < 1 ) goto ErasePalette ; image -> colors = PalHeader . MaxIndex + 1 ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) goto NoMemory ; if ( PalHeader . MaxRed == 0 ) PalHeader . MaxRed = ( unsigned int ) QuantumRange ; if ( PalHeader . MaxGreen == 0 ) PalHeader . MaxGreen = ( unsigned int ) QuantumRange ; if ( PalHeader . MaxBlue == 0 ) PalHeader . MaxBlue = ( unsigned int ) QuantumRange ; for ( i = 0 ; i <= ( int ) PalHeader . MaxIndex ; i ++ ) { j = ( ssize_t ) TellBlob ( palette ) ; if ( ( j % 512 ) > 512 - 6 ) { j = ( ( j / 512 ) + 1 ) * 512 ; offset = SeekBlob ( palette , j , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } image -> colormap [ i ] . red = ( Quantum ) ReadBlobLSBShort ( palette ) ; if ( QuantumRange != ( Quantum ) PalHeader . MaxRed ) { image -> colormap [ i ] . red = ClampToQuantum ( ( ( double ) image -> colormap [ i ] . red * QuantumRange + ( PalHeader . MaxRed >> 1 ) ) / PalHeader . MaxRed ) ; } image -> colormap [ i ] . green = ( Quantum ) ReadBlobLSBShort ( palette ) ; if ( QuantumRange != ( Quantum ) PalHeader . MaxGreen ) { image -> colormap [ i ] . green = ClampToQuantum ( ( ( double ) image -> colormap [ i ] . green * QuantumRange + ( PalHeader . MaxGreen >> 1 ) ) / PalHeader . MaxGreen ) ; } image -> colormap [ i ] . blue = ( Quantum ) ReadBlobLSBShort ( palette ) ; if ( QuantumRange != ( Quantum ) PalHeader . MaxBlue ) { image -> colormap [ i ] . blue = ClampToQuantum ( ( ( double ) image -> colormap [ i ] . blue * QuantumRange + ( PalHeader . MaxBlue >> 1 ) ) / PalHeader . MaxBlue ) ; } } if ( EOFBlob ( image ) ) ThrowCUTReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } NoPalette : if ( palette == NULL ) { image -> colors = 256 ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) { NoMemory : ThrowCUTReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) i ) ; } } BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ldblk , sizeof ( * BImgBuff ) ) ; if ( BImgBuff == NULL ) goto NoMemory ; <S2SV_StartBug> offset = SeekBlob ( image , 6 , SEEK_SET ) ; <S2SV_EndBug> if ( offset < 0 ) { if ( palette != NULL ) palette = DestroyImage ( palette ) ; if ( clone_info != NULL ) clone_info = DestroyImageInfo ( clone_info ) ; BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ; ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } for ( i = 0 ; i < ( int ) Header . Height ; i ++ ) { EncodedByte = ReadBlobLSBShort ( image ) ; ptrB = BImgBuff ; j = ldblk ; RunCount = ( unsigned char ) ReadBlobByte ( image ) ; RunCountMasked = RunCount & 0x7F ; while ( ( int ) RunCountMasked != 0 ) { if ( ( ssize_t ) RunCountMasked > j ) { RunCountMasked = ( unsigned char ) j ; if ( j == 0 ) { break ; } } if ( ( int ) RunCount > 0x80 ) { RunValue = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) memset ( ptrB , ( int ) RunValue , ( size_t ) RunCountMasked ) ; } else { ( void ) ReadBlob ( image , ( size_t ) RunCountMasked , ptrB ) ; } ptrB += ( int ) RunCountMasked ; j -= ( int ) RunCountMasked ; if ( EOFBlob ( image ) != MagickFalse ) goto Finish ; RunCount = ( unsigned char ) ReadBlobByte ( image ) ; RunCountMasked = RunCount & 0x7F ; } InsertRow ( image , depth , BImgBuff , i , exception ) ; } ( void ) SyncImage ( image , exception ) ; if ( palette == NULL ) { if ( ( image -> storage_class == PseudoClass ) && ( SetImageGray ( image , exception ) != MagickFalse ) ) { if ( GetCutColors ( image , exception ) == 2 ) { for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { register Quantum sample ; sample = ScaleCharToQuantum ( ( unsigned char ) i ) ; if ( image -> colormap [ i ] . red != sample ) goto Finish ; if ( image -> colormap [ i ] . green != sample ) goto Finish ; if ( image -> colormap [ i ] . blue != sample ) goto Finish ; } image -> colormap [ 1 ] . red = image -> colormap [ 1 ] . green = image -> colormap [ 1 ] . blue = QuantumRange ; for ( i = 0 ; i < ( ssize_t ) image -> rows ; i ++ ) { q = QueueAuthenticPixels ( image , 0 , i , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( j = 0 ; j < ( ssize_t ) image -> columns ; j ++ ) { if ( GetPixelRed ( image , q ) == ScaleCharToQuantum ( 1 ) ) { SetPixelRed ( image , QuantumRange , q ) ; SetPixelGreen ( image , QuantumRange , q ) ; SetPixelBlue ( image , QuantumRange , q ) ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) goto Finish ; } } } } Finish : if ( BImgBuff != NULL ) BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ; if ( palette != NULL ) palette = DestroyImage ( palette ) ; if ( clone_info != NULL ) clone_info = DestroyImageInfo ( clone_info ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> , tag ) \\\n{ <S2SV_ModEnd> if ( palette <S2SV_ModStart> tag ) ; \\\n} <S2SV_ModEnd> Image * image <S2SV_ModStart> goto NoMemory ; ( void ) memset ( BImgBuff , 0 , ( size_t ) ldblk * sizeof ( * BImgBuff ) ) ;
"
377,"CWE-000 int evm_update_evmxattr ( struct dentry * dentry , const char * xattr_name , const char * xattr_value , size_t xattr_value_len ) { struct inode * inode = dentry -> d_inode ; struct evm_ima_xattr_data xattr_data ; int rc = 0 ; rc = evm_calc_hmac ( dentry , xattr_name , xattr_value , xattr_value_len , xattr_data . digest ) ; if ( rc == 0 ) { xattr_data . type = EVM_XATTR_HMAC ; rc = __vfs_setxattr_noperm ( dentry , XATTR_NAME_EVM , & xattr_data , sizeof ( xattr_data ) , 0 ) ; } <S2SV_StartBug> else if ( rc == - ENODATA ) <S2SV_EndBug> rc = inode -> i_op -> removexattr ( dentry , XATTR_NAME_EVM ) ; <S2SV_StartBug> return rc ; <S2SV_EndBug> }
","<S2SV_ModStart> == - ENODATA && inode -> i_op -> removexattr ) { <S2SV_ModEnd> rc = inode <S2SV_ModStart> XATTR_NAME_EVM ) ; }
"
378,"CWE-476 static int jp2_cmap_getdata ( jp2_box_t * box , jas_stream_t * in ) { jp2_cmap_t * cmap = & box -> data . cmap ; jp2_cmapent_t * ent ; <S2SV_StartBug> unsigned int i ; <S2SV_EndBug> cmap -> numchans = ( box -> datalen ) / 4 ; if ( ! ( cmap -> ents = jas_alloc2 ( cmap -> numchans , sizeof ( jp2_cmapent_t ) ) ) ) { return - 1 ; } for ( i = 0 ; i < cmap -> numchans ; ++ i ) { ent = & cmap -> ents [ i ] ; if ( jp2_getuint16 ( in , & ent -> cmptno ) || jp2_getuint8 ( in , & ent -> map ) || jp2_getuint8 ( in , & ent -> pcol ) ) { return - 1 ; } } return 0 ; }
","<S2SV_ModStart> unsigned int i ; cmap -> ents = 0
"
379,"CWE-20 static int hash_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct hash_ctx * ctx = ask -> private ; unsigned ds = crypto_ahash_digestsize ( crypto_ahash_reqtfm ( & ctx -> req ) ) ; int err ; if ( len > ds ) len = ds ; else if ( len < ds ) msg -> msg_flags |= MSG_TRUNC ; <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> lock_sock ( sk ) ; if ( ctx -> more ) { ctx -> more = 0 ; ahash_request_set_crypt ( & ctx -> req , NULL , ctx -> result , 0 ) ; err = af_alg_wait_for_completion ( crypto_ahash_final ( & ctx -> req ) , & ctx -> completion ) ; if ( err ) goto unlock ; } err = memcpy_toiovec ( msg -> msg_iov , ctx -> result , len ) ; unlock : release_sock ( sk ) ; return err ? : len ; }
","<S2SV_ModStart> |= MSG_TRUNC ; <S2SV_ModEnd> lock_sock ( sk
"
380,"CWE-125 static u64 __skb_get_nlattr_nest ( u64 ctx , u64 A , u64 X , u64 r4 , u64 r5 ) { struct sk_buff * skb = ( struct sk_buff * ) ( long ) ctx ; struct nlattr * nla ; if ( skb_is_nonlinear ( skb ) ) return 0 ; <S2SV_StartBug> if ( A > skb -> len - sizeof ( struct nlattr ) ) <S2SV_EndBug> return 0 ; nla = ( struct nlattr * ) & skb -> data [ A ] ; <S2SV_StartBug> if ( nla -> nla_len > A - skb -> len ) <S2SV_EndBug> return 0 ; nla = nla_find_nested ( nla , X ) ; if ( nla ) return ( void * ) nla - ( void * ) skb -> data ; return 0 ; }
","<S2SV_ModStart> ; if ( skb -> len < sizeof ( struct nlattr ) ) return 0 ; if ( <S2SV_ModStart> -> nla_len > <S2SV_ModEnd> skb -> len <S2SV_ModStart> skb -> len - A
"
381,"CWE-200 <S2SV_StartBug> static u32 __ipv6_select_ident ( struct net * net , u32 hashrnd , <S2SV_EndBug> const struct in6_addr * dst , const struct in6_addr * src ) { <S2SV_StartBug> u32 hash , id ; <S2SV_EndBug> <S2SV_StartBug> hash = __ipv6_addr_jhash ( dst , hashrnd ) ; <S2SV_EndBug> <S2SV_StartBug> hash = __ipv6_addr_jhash ( src , hash ) ; <S2SV_EndBug> hash ^= net_hash_mix ( net ) ; id = ip_idents_reserve ( hash , 1 ) ; if ( unlikely ( ! id ) ) id = 1 << 31 ; return id ; }
","<S2SV_ModStart> net * net <S2SV_ModEnd> , const struct <S2SV_ModStart> src ) { const struct { struct in6_addr dst ; struct in6_addr src ; } __aligned ( SIPHASH_ALIGNMENT ) combined = { . dst = * dst , . src = * src , } ; <S2SV_ModStart> , id ; if ( unlikely ( siphash_key_is_zero ( & net -> ipv4 . ip_id_key ) ) ) get_random_bytes ( & net -> ipv4 . ip_id_key , sizeof ( net -> ipv4 . ip_id_key ) <S2SV_ModEnd> ) ; hash <S2SV_ModStart> ; hash = siphash ( & combined , sizeof ( combined ) , & net -> ipv4 . ip_id_key <S2SV_ModEnd> ) ; id
"
382,"CWE-362 static int snd_ctl_elem_user_tlv ( struct snd_kcontrol * kcontrol , int op_flag , unsigned int size , unsigned int __user * tlv ) { struct user_element * ue = kcontrol -> private_data ; int change = 0 ; void * new_data ; if ( op_flag > 0 ) { if ( size > 1024 * 128 ) return - EINVAL ; new_data = memdup_user ( tlv , size ) ; if ( IS_ERR ( new_data ) ) return PTR_ERR ( new_data ) ; <S2SV_StartBug> change = ue -> tlv_data_size != size ; <S2SV_EndBug> if ( ! change ) change = memcmp ( ue -> tlv_data , new_data , size ) ; kfree ( ue -> tlv_data ) ; ue -> tlv_data = new_data ; ue -> tlv_data_size = size ; <S2SV_StartBug> } else { <S2SV_EndBug> if ( ! ue -> tlv_data_size || ! ue -> tlv_data ) <S2SV_StartBug> return - ENXIO ; <S2SV_EndBug> <S2SV_StartBug> if ( size < ue -> tlv_data_size ) <S2SV_EndBug> <S2SV_StartBug> return - ENOSPC ; <S2SV_EndBug> <S2SV_StartBug> if ( copy_to_user ( tlv , ue -> tlv_data , ue -> tlv_data_size ) ) <S2SV_EndBug> <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> return change ; }
","<S2SV_ModStart> new_data ) ; mutex_lock ( & ue -> card -> user_ctl_lock ) ; <S2SV_ModStart> = size ; mutex_unlock ( & ue -> card -> user_ctl_lock ) ; <S2SV_ModStart> } else { int ret = 0 ; mutex_lock ( & ue -> card -> user_ctl_lock ) ; <S2SV_ModStart> -> tlv_data ) { ret = <S2SV_ModEnd> - ENXIO ; <S2SV_ModStart> - ENXIO ; goto err_unlock ; } <S2SV_ModStart> -> tlv_data_size ) { ret = <S2SV_ModEnd> - ENOSPC ; <S2SV_ModStart> - ENOSPC ; goto err_unlock ; } <S2SV_ModStart> tlv_data_size ) ) ret = <S2SV_ModEnd> - EFAULT ; <S2SV_ModStart> - EFAULT ; err_unlock : mutex_unlock ( & ue -> card -> user_ctl_lock ) ; if ( ret ) return ret ;
"
383,"CWE-20 int key_update ( key_ref_t key_ref , const void * payload , size_t plen ) { struct key_preparsed_payload prep ; struct key * key = key_ref_to_ptr ( key_ref ) ; int ret ; key_check ( key ) ; ret = key_permission ( key_ref , KEY_NEED_WRITE ) ; if ( ret < 0 ) return ret ; if ( ! key -> type -> update ) return - EOPNOTSUPP ; memset ( & prep , 0 , sizeof ( prep ) ) ; prep . data = payload ; prep . datalen = plen ; prep . quotalen = key -> type -> def_datalen ; prep . expiry = TIME_T_MAX ; if ( key -> type -> preparse ) { ret = key -> type -> preparse ( & prep ) ; if ( ret < 0 ) goto error ; } down_write ( & key -> sem ) ; ret = key -> type -> update ( key , & prep ) ; if ( ret == 0 ) <S2SV_StartBug> clear_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ; <S2SV_EndBug> up_write ( & key -> sem ) ; error : if ( key -> type -> preparse ) key -> type -> free_preparse ( & prep ) ; return ret ; }
","<S2SV_ModStart> == 0 ) mark_key_instantiated ( key , 0 <S2SV_ModEnd> ) ; up_write
"
384,"CWE-399 static long vhost_net_set_backend ( struct vhost_net * n , unsigned index , int fd ) { struct socket * sock , * oldsock ; struct vhost_virtqueue * vq ; struct vhost_net_virtqueue * nvq ; struct vhost_net_ubuf_ref * ubufs , * oldubufs = NULL ; int r ; mutex_lock ( & n -> dev . mutex ) ; r = vhost_dev_check_owner ( & n -> dev ) ; if ( r ) goto err ; if ( index >= VHOST_NET_VQ_MAX ) { r = - ENOBUFS ; goto err ; } vq = & n -> vqs [ index ] . vq ; nvq = & n -> vqs [ index ] ; mutex_lock ( & vq -> mutex ) ; if ( ! vhost_vq_access_ok ( vq ) ) { r = - EFAULT ; goto err_vq ; } sock = get_socket ( fd ) ; if ( IS_ERR ( sock ) ) { r = PTR_ERR ( sock ) ; goto err_vq ; } oldsock = rcu_dereference_protected ( vq -> private_data , lockdep_is_held ( & vq -> mutex ) ) ; if ( sock != oldsock ) { ubufs = vhost_net_ubuf_alloc ( vq , sock && vhost_sock_zcopy ( sock ) ) ; if ( IS_ERR ( ubufs ) ) { r = PTR_ERR ( ubufs ) ; goto err_ubufs ; } vhost_net_disable_vq ( n , vq ) ; rcu_assign_pointer ( vq -> private_data , sock ) ; r = vhost_init_used ( vq ) ; if ( r ) goto err_used ; r = vhost_net_enable_vq ( n , vq ) ; if ( r ) goto err_used ; oldubufs = nvq -> ubufs ; nvq -> ubufs = ubufs ; n -> tx_packets = 0 ; n -> tx_zcopy_err = 0 ; n -> tx_flush = false ; } mutex_unlock ( & vq -> mutex ) ; if ( oldubufs ) { <S2SV_StartBug> vhost_net_ubuf_put_and_wait ( oldubufs ) ; <S2SV_EndBug> mutex_lock ( & vq -> mutex ) ; vhost_zerocopy_signal_used ( n , vq ) ; mutex_unlock ( & vq -> mutex ) ; } if ( oldsock ) { vhost_net_flush_vq ( n , index ) ; fput ( oldsock -> file ) ; } mutex_unlock ( & n -> dev . mutex ) ; return 0 ; err_used : rcu_assign_pointer ( vq -> private_data , oldsock ) ; vhost_net_enable_vq ( n , vq ) ; if ( ubufs ) <S2SV_StartBug> vhost_net_ubuf_put_and_wait ( ubufs ) ; <S2SV_EndBug> err_ubufs : fput ( sock -> file ) ; err_vq : mutex_unlock ( & vq -> mutex ) ; err : mutex_unlock ( & n -> dev . mutex ) ; return r ; }
","<S2SV_ModStart> oldubufs ) { vhost_net_ubuf_put_wait_and_free <S2SV_ModEnd> ( oldubufs ) <S2SV_ModStart> ( ubufs ) vhost_net_ubuf_put_wait_and_free <S2SV_ModEnd> ( ubufs )
"
385,"CWE-119 <S2SV_StartBug> static int svc_log ( SvcContext * svc_ctx , int level , const char * fmt , ... ) { <S2SV_EndBug> char buf [ 512 ] ; int retval = 0 ; va_list ap ; <S2SV_StartBug> SvcInternal * const si = get_svc_internal ( svc_ctx ) ; <S2SV_EndBug> if ( level > svc_ctx -> log_level ) { return retval ; } va_start ( ap , fmt ) ; retval = vsnprintf ( buf , sizeof ( buf ) , fmt , ap ) ; va_end ( ap ) ; if ( svc_ctx -> log_print ) { printf ( ""%s"" , buf ) ; } else { strncat ( si -> message_buffer , buf , sizeof ( si -> message_buffer ) - strlen ( si -> message_buffer ) - 1 ) ; } if ( level == SVC_LOG_ERROR ) { si -> codec_ctx -> err_detail = si -> message_buffer ; } return retval ; }
","<S2SV_ModStart> * svc_ctx , SVC_LOG_LEVEL <S2SV_ModEnd> level , const <S2SV_ModStart> va_list ap ; SvcInternal_t <S2SV_ModEnd> * const si
"
386,"CWE-000 static void ip_expire ( unsigned long arg ) { struct ipq * qp ; struct net * net ; qp = container_of ( ( struct inet_frag_queue * ) arg , struct ipq , q ) ; net = container_of ( qp -> q . net , struct net , ipv4 . frags ) ; spin_lock ( & qp -> q . lock ) ; if ( qp -> q . last_in & INET_FRAG_COMPLETE ) goto out ; ipq_kill ( qp ) ; IP_INC_STATS_BH ( net , IPSTATS_MIB_REASMTIMEOUT ) ; IP_INC_STATS_BH ( net , IPSTATS_MIB_REASMFAILS ) ; if ( ( qp -> q . last_in & INET_FRAG_FIRST_IN ) && qp -> q . fragments != NULL ) { struct sk_buff * head = qp -> q . fragments ; <S2SV_StartBug> rcu_read_lock ( ) ; <S2SV_EndBug> head -> dev = dev_get_by_index_rcu ( net , qp -> iif ) ; <S2SV_StartBug> if ( ! head -> dev ) <S2SV_EndBug> goto out_rcu_unlock ; <S2SV_StartBug> if ( qp -> user == IP_DEFRAG_CONNTRACK_IN && ! skb_dst ( head ) ) { <S2SV_EndBug> const struct iphdr * iph = ip_hdr ( head ) ; int err = ip_route_input ( head , iph -> daddr , iph -> saddr , iph -> tos , head -> dev ) ; if ( unlikely ( err ) ) goto out_rcu_unlock ; if ( skb_rtable ( head ) -> rt_type != RTN_LOCAL ) goto out_rcu_unlock ; <S2SV_StartBug> } <S2SV_EndBug> icmp_send ( head , ICMP_TIME_EXCEEDED , ICMP_EXC_FRAGTIME , 0 ) ; out_rcu_unlock : rcu_read_unlock ( ) ; } out : spin_unlock ( & qp -> q . lock ) ; ipq_put ( qp ) ; }
","<S2SV_ModStart> . fragments ; const struct iphdr * iph ; int err ; <S2SV_ModStart> head -> dev ) goto out_rcu_unlock ; skb_dst_drop ( head ) ; iph = ip_hdr ( head ) ; err = ip_route_input_noref ( head , iph -> daddr , iph -> saddr , iph -> tos , head -> dev ) ; if ( err <S2SV_ModStart> == IP_DEFRAG_CONNTRACK_IN && <S2SV_ModEnd> skb_rtable ( head <S2SV_ModStart> goto out_rcu_unlock ; <S2SV_ModEnd> icmp_send ( head
"
387,"CWE-189 Image * AutoResizeImage ( const Image * image , const char * option , MagickOffsetType * count , ExceptionInfo * exception ) { # define MAX_SIZES 16 char * q ; const char * p ; Image * resized , * images ; register ssize_t i ; size_t sizes [ MAX_SIZES ] = { 256 , 192 , 128 , 96 , 64 , 48 , 40 , 32 , 24 , 16 } ; images = NULL ; * count = 0 ; i = 0 ; p = option ; while ( * p != '\\0' && i < MAX_SIZES ) { size_t size ; while ( ( isspace ( ( int ) ( ( unsigned char ) * p ) ) != 0 ) ) p ++ ; size = ( size_t ) strtol ( p , & q , 10 ) ; <S2SV_StartBug> if ( p == q || size < 16 || size > 256 ) <S2SV_EndBug> return ( ( Image * ) NULL ) ; p = q ; sizes [ i ++ ] = size ; while ( ( isspace ( ( int ) ( ( unsigned char ) * p ) ) != 0 ) || ( * p == ',' ) ) p ++ ; } if ( i == 0 ) i = 10 ; * count = i ; for ( i = 0 ; i < * count ; i ++ ) { resized = ResizeImage ( image , sizes [ i ] , sizes [ i ] , image -> filter , exception ) ; if ( resized == ( Image * ) NULL ) return ( DestroyImageList ( images ) ) ; if ( images == ( Image * ) NULL ) images = resized ; else AppendImageToList ( & images , resized ) ; } return ( images ) ; }
","<S2SV_ModStart> ; if ( ( <S2SV_ModStart> p == q ) || ( <S2SV_ModEnd> size < 16 <S2SV_ModStart> size < 16 ) || ( <S2SV_ModEnd> size > 256 <S2SV_ModStart> size > 256 )
"
388,"CWE-125 <S2SV_StartBug> static void <S2SV_EndBug> ip_printts ( netdissect_options * ndo , register const u_char * cp , u_int length ) { register u_int ptr ; register u_int len ; int hoplen ; const char * type ; if ( length < 4 ) { ND_PRINT ( ( ndo , ""[bad<S2SV_blank>length<S2SV_blank>%u]"" , length ) ) ; <S2SV_StartBug> return ; <S2SV_EndBug> } ND_PRINT ( ( ndo , ""<S2SV_blank>TS{"" ) ) ; hoplen = ( ( cp [ 3 ] & 0xF ) != IPOPT_TS_TSONLY ) ? 8 : 4 ; if ( ( length - 4 ) & ( hoplen - 1 ) ) ND_PRINT ( ( ndo , ""[bad<S2SV_blank>length<S2SV_blank>%u]"" , length ) ) ; <S2SV_StartBug> ptr = cp [ 2 ] - 1 ; <S2SV_EndBug> len = 0 ; if ( ptr < 4 || ( ( ptr - 4 ) & ( hoplen - 1 ) ) || ptr > length + 1 ) ND_PRINT ( ( ndo , ""[bad<S2SV_blank>ptr<S2SV_blank>%u]"" , cp [ 2 ] ) ) ; <S2SV_StartBug> switch ( cp [ 3 ] & 0xF ) { <S2SV_EndBug> case IPOPT_TS_TSONLY : ND_PRINT ( ( ndo , ""TSONLY"" ) ) ; break ; case IPOPT_TS_TSANDADDR : ND_PRINT ( ( ndo , ""TS+ADDR"" ) ) ; break ; case 2 : ND_PRINT ( ( ndo , ""PRESPEC2.0"" ) ) ; break ; case 3 : ND_PRINT ( ( ndo , ""PRESPEC"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""[bad<S2SV_blank>ts<S2SV_blank>type<S2SV_blank>%d]"" , cp [ 3 ] & 0xF ) ) ; goto done ; } type = ""<S2SV_blank>"" ; for ( len = 4 ; len < length ; len += hoplen ) { if ( ptr == len ) <S2SV_StartBug> type = ""<S2SV_blank>^<S2SV_blank>"" ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""%s%d@%s"" , type , EXTRACT_32BITS ( & cp [ len + hoplen - 4 ] ) , hoplen != 8 ? """" : ipaddr_string ( ndo , & cp [ len ] ) ) ) ; type = ""<S2SV_blank>"" ; } done : ND_PRINT ( ( ndo , ""%s"" , ptr == len ? ""<S2SV_blank>^<S2SV_blank>"" : """" ) ) ; if ( cp [ 3 ] >> 4 ) ND_PRINT ( ( ndo , ""<S2SV_blank>[%d<S2SV_blank>hops<S2SV_blank>not<S2SV_blank>recorded]}<S2SV_blank>"" , cp [ 3 ] >> 4 ) ) ; else ND_PRINT ( ( ndo , ""}"" ) ) ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> ip_printts ( netdissect_options <S2SV_ModStart> ) ; return ( 0 ) <S2SV_ModStart> ) ) ; ND_TCHECK ( cp [ 2 ] ) ; <S2SV_ModStart> ) ) ; ND_TCHECK ( cp [ 3 ] ) ; <S2SV_ModStart> type = ""<S2SV_blank>^<S2SV_blank>"" ; ND_TCHECK2 ( cp [ len ] , hoplen ) <S2SV_ModStart> ) ) ; return ( 0 ) ; trunc : return ( - 1 ) ;
"
389,"CWE-416 int yr_execute_code ( YR_RULES * rules , YR_SCAN_CONTEXT * context , int timeout , time_t start_time ) { int64_t mem [ MEM_SIZE ] ; int32_t sp = 0 ; uint8_t * ip = rules -> code_start ; YR_VALUE args [ MAX_FUNCTION_ARGS ] ; YR_VALUE * stack ; YR_VALUE r1 ; YR_VALUE r2 ; YR_VALUE r3 ; # ifdef PROFILING_ENABLED YR_RULE * current_rule = NULL ; # endif YR_RULE * rule ; YR_MATCH * match ; YR_OBJECT_FUNCTION * function ; <S2SV_StartBug> char * identifier ; <S2SV_EndBug> char * args_fmt ; int i ; int found ; int count ; int result = ERROR_SUCCESS ; int stop = FALSE ; int cycle = 0 ; int tidx = context -> tidx ; int stack_size ; # ifdef PROFILING_ENABLED clock_t start = clock ( ) ; # endif yr_get_configuration ( YR_CONFIG_STACK_SIZE , ( void * ) & stack_size ) ; stack = ( YR_VALUE * ) yr_malloc ( stack_size * sizeof ( YR_VALUE ) ) ; if ( stack == NULL ) <S2SV_StartBug> return ERROR_INSUFFICIENT_MEMORY ; <S2SV_EndBug> while ( ! stop ) { switch ( * ip ) { case OP_NOP : break ; case OP_HALT : assert ( sp == 0 ) ; stop = TRUE ; break ; case OP_PUSH : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; push ( r1 ) ; break ; case OP_POP : pop ( r1 ) ; break ; case OP_CLEAR_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; mem [ r1 . i ] = 0 ; break ; case OP_ADD_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; if ( ! is_undef ( r2 ) ) mem [ r1 . i ] += r2 . i ; break ; case OP_INCR_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; mem [ r1 . i ] ++ ; break ; case OP_PUSH_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . i = mem [ r1 . i ] ; push ( r1 ) ; break ; case OP_POP_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; mem [ r1 . i ] = r2 . i ; break ; case OP_SWAPUNDEF : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; if ( is_undef ( r2 ) ) { r1 . i = mem [ r1 . i ] ; push ( r1 ) ; } else { push ( r2 ) ; } break ; case OP_JNUNDEF : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( ! is_undef ( r1 ) , ip ) ; break ; case OP_JLE : pop ( r2 ) ; pop ( r1 ) ; push ( r1 ) ; push ( r2 ) ; ip = jmp_if ( r1 . i <= r2 . i , ip ) ; break ; case OP_JTRUE : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( ! is_undef ( r1 ) && r1 . i , ip ) ; break ; case OP_JFALSE : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( is_undef ( r1 ) || ! r1 . i , ip ) ; break ; case OP_AND : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) || is_undef ( r2 ) ) r1 . i = 0 ; else r1 . i = r1 . i && r2 . i ; push ( r1 ) ; break ; case OP_OR : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) ) { push ( r2 ) ; } else if ( is_undef ( r2 ) ) { push ( r1 ) ; } else { r1 . i = r1 . i || r2 . i ; push ( r1 ) ; } break ; case OP_NOT : pop ( r1 ) ; if ( is_undef ( r1 ) ) r1 . i = UNDEFINED ; else r1 . i = ! r1 . i ; push ( r1 ) ; break ; case OP_MOD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r2 . i != 0 ) r1 . i = r1 . i % r2 . i ; else r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_SHR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i >> r2 . i ; push ( r1 ) ; break ; case OP_SHL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i << r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_NOT : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = ~ r1 . i ; push ( r1 ) ; break ; case OP_BITWISE_AND : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i & r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_OR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i | r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_XOR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i ^ r2 . i ; push ( r1 ) ; break ; case OP_PUSH_RULE : rule = * ( YR_RULE * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . i = rule -> t_flags [ tidx ] & RULE_TFLAGS_MATCH ? 1 : 0 ; push ( r1 ) ; break ; case OP_INIT_RULE : # ifdef PROFILING_ENABLED current_rule = * ( YR_RULE * * ) ( ip + 1 ) ; # endif ip += sizeof ( uint64_t ) ; break ; case OP_MATCH_RULE : pop ( r1 ) ; rule = * ( YR_RULE * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; if ( ! is_undef ( r1 ) && r1 . i ) rule -> t_flags [ tidx ] |= RULE_TFLAGS_MATCH ; else if ( RULE_IS_GLOBAL ( rule ) ) rule -> ns -> t_flags [ tidx ] |= NAMESPACE_TFLAGS_UNSATISFIED_GLOBAL ; # ifdef PROFILING_ENABLED rule -> clock_ticks += clock ( ) - start ; start = clock ( ) ; # endif <S2SV_StartBug> break ; <S2SV_EndBug> case OP_OBJ_LOAD : identifier = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . o = ( YR_OBJECT * ) yr_hash_table_lookup ( context -> objects_table , identifier , NULL ) ; assert ( r1 . o != NULL ) ; push ( r1 ) ; break ; case OP_OBJ_FIELD : identifier = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . o = yr_object_lookup_field ( r1 . o , identifier ) ; assert ( r1 . o != NULL ) ; push ( r1 ) ; break ; case OP_OBJ_VALUE : pop ( r1 ) ; ensure_defined ( r1 ) ; switch ( r1 . o -> type ) { case OBJECT_TYPE_INTEGER : r1 . i = ( ( YR_OBJECT_INTEGER * ) r1 . o ) -> value ; break ; case OBJECT_TYPE_FLOAT : if ( isnan ( ( ( YR_OBJECT_DOUBLE * ) r1 . o ) -> value ) ) r1 . i = UNDEFINED ; else r1 . d = ( ( YR_OBJECT_DOUBLE * ) r1 . o ) -> value ; break ; case OBJECT_TYPE_STRING : if ( ( ( YR_OBJECT_STRING * ) r1 . o ) -> value == NULL ) r1 . i = UNDEFINED ; else r1 . p = ( ( YR_OBJECT_STRING * ) r1 . o ) -> value ; break ; default : assert ( FALSE ) ; } push ( r1 ) ; break ; case OP_INDEX_ARRAY : pop ( r1 ) ; pop ( r2 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; assert ( r2 . o -> type == OBJECT_TYPE_ARRAY ) ; r1 . o = yr_object_array_get_item ( r2 . o , 0 , ( int ) r1 . i ) ; if ( r1 . o == NULL ) r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_LOOKUP_DICT : pop ( r1 ) ; pop ( r2 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; assert ( r2 . o -> type == OBJECT_TYPE_DICTIONARY ) ; r1 . o = yr_object_dict_get_item ( r2 . o , 0 , r1 . ss -> c_string ) ; if ( r1 . o == NULL ) r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_CALL : args_fmt = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; i = ( int ) strlen ( args_fmt ) ; count = 0 ; while ( i > 0 ) { pop ( r1 ) ; if ( is_undef ( r1 ) ) count ++ ; args [ i - 1 ] = r1 ; i -- ; } pop ( r2 ) ; ensure_defined ( r2 ) ; if ( count > 0 ) { r1 . i = UNDEFINED ; push ( r1 ) ; break ; } function = ( YR_OBJECT_FUNCTION * ) r2 . o ; result = ERROR_INTERNAL_FATAL_ERROR ; for ( i = 0 ; i < MAX_OVERLOADED_FUNCTIONS ; i ++ ) { if ( function -> prototypes [ i ] . arguments_fmt == NULL ) break ; if ( strcmp ( function -> prototypes [ i ] . arguments_fmt , args_fmt ) == 0 ) { result = function -> prototypes [ i ] . code ( args , context , function ) ; break ; } } assert ( i < MAX_OVERLOADED_FUNCTIONS ) ; if ( result == ERROR_SUCCESS ) <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> r1 . o = function -> return_obj ; <S2SV_EndBug> push ( r1 ) ; } else { stop = TRUE ; } break ; case OP_FOUND : pop ( r1 ) ; r1 . i = r1 . s -> matches [ tidx ] . tail != NULL ? 1 : 0 ; push ( r1 ) ; break ; case OP_FOUND_AT : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) ) { r1 . i = 0 ; push ( r1 ) ; break ; } match = r2 . s -> matches [ tidx ] . head ; r3 . i = FALSE ; while ( match != NULL ) { if ( r1 . i == match -> base + match -> offset ) { r3 . i = TRUE ; break ; } if ( r1 . i < match -> base + match -> offset ) break ; match = match -> next ; } push ( r3 ) ; break ; case OP_FOUND_IN : pop ( r3 ) ; pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; match = r3 . s -> matches [ tidx ] . head ; r3 . i = FALSE ; while ( match != NULL && ! r3 . i ) { if ( match -> base + match -> offset >= r1 . i && match -> base + match -> offset <= r2 . i ) { r3 . i = TRUE ; } if ( match -> base + match -> offset > r2 . i ) break ; match = match -> next ; } push ( r3 ) ; break ; case OP_COUNT : pop ( r1 ) ; r1 . i = r1 . s -> matches [ tidx ] . count ; push ( r1 ) ; break ; case OP_OFFSET : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; match = r2 . s -> matches [ tidx ] . head ; i = 1 ; r3 . i = UNDEFINED ; while ( match != NULL && r3 . i == UNDEFINED ) { if ( r1 . i == i ) r3 . i = match -> base + match -> offset ; i ++ ; match = match -> next ; } push ( r3 ) ; break ; case OP_LENGTH : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; match = r2 . s -> matches [ tidx ] . head ; i = 1 ; r3 . i = UNDEFINED ; while ( match != NULL && r3 . i == UNDEFINED ) { if ( r1 . i == i ) r3 . i = match -> match_length ; i ++ ; match = match -> next ; } push ( r3 ) ; break ; case OP_OF : found = 0 ; count = 0 ; pop ( r1 ) ; while ( ! is_undef ( r1 ) ) { if ( r1 . s -> matches [ tidx ] . tail != NULL ) found ++ ; count ++ ; pop ( r1 ) ; } pop ( r2 ) ; if ( is_undef ( r2 ) ) r1 . i = found >= count ? 1 : 0 ; else r1 . i = found >= r2 . i ? 1 : 0 ; push ( r1 ) ; break ; case OP_FILESIZE : r1 . i = context -> file_size ; push ( r1 ) ; break ; case OP_ENTRYPOINT : r1 . i = context -> entry_point ; push ( r1 ) ; break ; case OP_INT8 : pop ( r1 ) ; r1 . i = read_int8_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT16 : pop ( r1 ) ; r1 . i = read_int16_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT32 : pop ( r1 ) ; r1 . i = read_int32_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT8 : pop ( r1 ) ; r1 . i = read_uint8_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT16 : pop ( r1 ) ; r1 . i = read_uint16_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT32 : pop ( r1 ) ; r1 . i = read_uint32_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT8BE : pop ( r1 ) ; r1 . i = read_int8_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT16BE : pop ( r1 ) ; r1 . i = read_int16_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT32BE : pop ( r1 ) ; r1 . i = read_int32_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT8BE : pop ( r1 ) ; r1 . i = read_uint8_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT16BE : pop ( r1 ) ; r1 . i = read_uint16_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT32BE : pop ( r1 ) ; r1 . i = read_uint32_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_CONTAINS : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; r1 . i = memmem ( r1 . ss -> c_string , r1 . ss -> length , r2 . ss -> c_string , r2 . ss -> length ) != NULL ; push ( r1 ) ; break ; case OP_IMPORT : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; result = yr_modules_load ( ( char * ) r1 . p , context ) ; if ( result != ERROR_SUCCESS ) stop = TRUE ; break ; case OP_MATCHES : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r1 . ss -> length == 0 ) { r1 . i = FALSE ; push ( r1 ) ; break ; } result = yr_re_exec ( ( uint8_t * ) r2 . re -> code , ( uint8_t * ) r1 . ss -> c_string , r1 . ss -> length , 0 , r2 . re -> flags | RE_FLAGS_SCAN , NULL , NULL , & found ) ; if ( result != ERROR_SUCCESS ) stop = TRUE ; r1 . i = found >= 0 ; push ( r1 ) ; break ; case OP_INT_TO_DBL : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r2 = stack [ sp - r1 . i ] ; if ( is_undef ( r2 ) ) stack [ sp - r1 . i ] . i = UNDEFINED ; else stack [ sp - r1 . i ] . d = ( double ) r2 . i ; break ; case OP_STR_TO_BOOL : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . ss -> length > 0 ; push ( r1 ) ; break ; case OP_INT_EQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i == r2 . i ; push ( r1 ) ; break ; case OP_INT_NEQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i != r2 . i ; push ( r1 ) ; break ; case OP_INT_LT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i < r2 . i ; push ( r1 ) ; break ; case OP_INT_GT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i > r2 . i ; push ( r1 ) ; break ; case OP_INT_LE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i <= r2 . i ; push ( r1 ) ; break ; case OP_INT_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i >= r2 . i ; push ( r1 ) ; break ; case OP_INT_ADD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i + r2 . i ; push ( r1 ) ; break ; case OP_INT_SUB : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i - r2 . i ; push ( r1 ) ; break ; case OP_INT_MUL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i * r2 . i ; push ( r1 ) ; break ; case OP_INT_DIV : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r2 . i != 0 ) r1 . i = r1 . i / r2 . i ; else r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_INT_MINUS : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = - r1 . i ; push ( r1 ) ; break ; case OP_DBL_LT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d < r2 . d ; push ( r1 ) ; break ; case OP_DBL_GT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d > r2 . d ; push ( r1 ) ; break ; case OP_DBL_LE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d <= r2 . d ; push ( r1 ) ; break ; case OP_DBL_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d >= r2 . d ; push ( r1 ) ; break ; case OP_DBL_EQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d == r2 . d ; push ( r1 ) ; break ; case OP_DBL_NEQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d != r2 . d ; push ( r1 ) ; break ; case OP_DBL_ADD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d + r2 . d ; push ( r1 ) ; break ; case OP_DBL_SUB : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d - r2 . d ; push ( r1 ) ; break ; case OP_DBL_MUL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d * r2 . d ; push ( r1 ) ; break ; case OP_DBL_DIV : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d / r2 . d ; push ( r1 ) ; break ; case OP_DBL_MINUS : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . d = - r1 . d ; push ( r1 ) ; break ; case OP_STR_EQ : case OP_STR_NEQ : case OP_STR_LT : case OP_STR_LE : case OP_STR_GT : case OP_STR_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; switch ( * ip ) { case OP_STR_EQ : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) == 0 ) ; break ; case OP_STR_NEQ : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) != 0 ) ; break ; case OP_STR_LT : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) < 0 ) ; break ; case OP_STR_LE : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) <= 0 ) ; break ; case OP_STR_GT : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) > 0 ) ; break ; case OP_STR_GE : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) >= 0 ) ; break ; } push ( r1 ) ; break ; default : assert ( FALSE ) ; } if ( timeout > 0 ) { if ( ++ cycle == 10 ) { if ( difftime ( time ( NULL ) , start_time ) > timeout ) { # ifdef PROFILING_ENABLED assert ( current_rule != NULL ) ; current_rule -> clock_ticks += clock ( ) - start ; # endif result = ERROR_SCAN_TIMEOUT ; stop = TRUE ; } cycle = 0 ; } } ip ++ ; } <S2SV_StartBug> yr_modules_unload_all ( context ) ; <S2SV_EndBug> yr_free ( stack ) ; return result ; }
","<S2SV_ModStart> * function ; YR_OBJECT * * obj_ptr ; YR_ARENA * obj_arena ; <S2SV_ModStart> ) return ERROR_INSUFFICIENT_MEMORY ; FAIL_ON_ERROR_WITH_CLEANUP ( yr_arena_create ( 1024 , 0 , & obj_arena ) , yr_free ( stack ) ) <S2SV_ModStart> ; # endif assert ( sp == 0 ) ; <S2SV_ModStart> == ERROR_SUCCESS ) result = yr_object_copy ( function -> return_obj , & <S2SV_ModEnd> r1 . o <S2SV_ModStart> r1 . o ) ; if ( result == ERROR_SUCCESS ) result = yr_arena_write_data ( obj_arena , & r1 . o , sizeof ( r1 . o ) , NULL ) ; stop = ( result != ERROR_SUCCESS ) ; push ( r1 ) ; <S2SV_ModEnd> break ; case <S2SV_ModStart> ++ ; } obj_ptr = ( YR_OBJECT * * ) yr_arena_base_address ( obj_arena ) ; while ( obj_ptr != NULL ) { yr_object_destroy ( * obj_ptr ) ; obj_ptr = ( YR_OBJECT * * ) yr_arena_next_address ( obj_arena , obj_ptr , sizeof ( YR_OBJECT * ) ) ; } yr_arena_destroy ( obj_arena ) ;
"
390,"CWE-369 int tcp_disconnect ( struct sock * sk , int flags ) { struct inet_sock * inet = inet_sk ( sk ) ; struct inet_connection_sock * icsk = inet_csk ( sk ) ; struct tcp_sock * tp = tcp_sk ( sk ) ; int err = 0 ; int old_state = sk -> sk_state ; if ( old_state != TCP_CLOSE ) tcp_set_state ( sk , TCP_CLOSE ) ; if ( old_state == TCP_LISTEN ) { inet_csk_listen_stop ( sk ) ; } else if ( unlikely ( tp -> repair ) ) { sk -> sk_err = ECONNABORTED ; } else if ( tcp_need_reset ( old_state ) || ( tp -> snd_nxt != tp -> write_seq && ( 1 << old_state ) & ( TCPF_CLOSING | TCPF_LAST_ACK ) ) ) { tcp_send_active_reset ( sk , gfp_any ( ) ) ; sk -> sk_err = ECONNRESET ; } else if ( old_state == TCP_SYN_SENT ) sk -> sk_err = ECONNRESET ; tcp_clear_xmit_timers ( sk ) ; __skb_queue_purge ( & sk -> sk_receive_queue ) ; tcp_write_queue_purge ( sk ) ; tcp_fastopen_active_disable_ofo_check ( sk ) ; skb_rbtree_purge ( & tp -> out_of_order_queue ) ; inet -> inet_dport = 0 ; if ( ! ( sk -> sk_userlocks & SOCK_BINDADDR_LOCK ) ) inet_reset_saddr ( sk ) ; sk -> sk_shutdown = 0 ; sock_reset_flag ( sk , SOCK_DONE ) ; tp -> srtt_us = 0 ; tp -> write_seq += tp -> max_window + 2 ; if ( tp -> write_seq == 0 ) tp -> write_seq = 1 ; icsk -> icsk_backoff = 0 ; tp -> snd_cwnd = 2 ; icsk -> icsk_probes_out = 0 ; tp -> packets_out = 0 ; tp -> snd_ssthresh = TCP_INFINITE_SSTHRESH ; tp -> snd_cwnd_cnt = 0 ; tp -> window_clamp = 0 ; tcp_set_ca_state ( sk , TCP_CA_Open ) ; tcp_clear_retrans ( tp ) ; inet_csk_delack_init ( sk ) ; <S2SV_StartBug> tcp_init_send_head ( sk ) ; <S2SV_EndBug> memset ( & tp -> rx_opt , 0 , sizeof ( tp -> rx_opt ) ) ; __sk_dst_reset ( sk ) ; tcp_saved_syn_free ( tp ) ; tcp_free_fastopen_req ( tp ) ; inet -> defer_connect = 0 ; WARN_ON ( inet -> inet_num && ! icsk -> icsk_bind_hash ) ; sk -> sk_error_report ( sk ) ; return err ; }
","<S2SV_ModStart> sk ) ; icsk -> icsk_ack . rcv_mss = TCP_MIN_MSS ;
"
391,"CWE-119 void WT_InterpolateNoLoop ( S_WT_VOICE * pWTVoice , S_WT_INT_FRAME * pWTIntFrame ) { EAS_PCM * pOutputBuffer ; EAS_I32 phaseInc ; EAS_I32 phaseFrac ; EAS_I32 acc0 ; const EAS_SAMPLE * pSamples ; EAS_I32 samp1 ; EAS_I32 samp2 ; EAS_I32 numSamples ; numSamples = pWTIntFrame -> numSamples ; if ( numSamples <= 0 ) { <S2SV_StartBug> ALOGE ( ""b/26366256"" ) ; <S2SV_EndBug> return ; } pOutputBuffer = pWTIntFrame -> pAudioBuffer ; phaseInc = pWTIntFrame -> frame . phaseIncrement ; pSamples = ( const EAS_SAMPLE * ) pWTVoice -> phaseAccum ; phaseFrac = ( EAS_I32 ) pWTVoice -> phaseFrac ; # if defined ( _8_BIT_SAMPLES ) samp1 = pSamples [ 0 ] << 8 ; samp2 = pSamples [ 1 ] << 8 ; # else samp1 = pSamples [ 0 ] ; samp2 = pSamples [ 1 ] ; # endif while ( numSamples -- ) { acc0 = samp2 - samp1 ; acc0 = acc0 * phaseFrac ; acc0 = samp1 + ( acc0 >> NUM_PHASE_FRAC_BITS ) ; * pOutputBuffer ++ = ( EAS_I16 ) ( acc0 >> 2 ) ; phaseFrac += phaseInc ; acc0 = phaseFrac >> NUM_PHASE_FRAC_BITS ; if ( acc0 > 0 ) { pSamples += acc0 ; phaseFrac = ( EAS_I32 ) ( ( EAS_U32 ) phaseFrac & PHASE_FRAC_MASK ) ; # if defined ( _8_BIT_SAMPLES ) samp1 = pSamples [ 0 ] << 8 ; samp2 = pSamples [ 1 ] << 8 ; # else samp1 = pSamples [ 0 ] ; samp2 = pSamples [ 1 ] ; # endif } } pWTVoice -> phaseAccum = ( EAS_U32 ) pSamples ; pWTVoice -> phaseFrac = ( EAS_U32 ) phaseFrac ; }
","<S2SV_ModStart> ALOGE ( ""b/26366256"" ) ; android_errorWriteLog ( 0x534e4554 , ""26366256""
"
392,"CWE-119 static int g2m_init_buffers ( G2MContext * c ) { int aligned_height ; if ( ! c -> framebuf || c -> old_width < c -> width || c -> old_height < c -> height ) { <S2SV_StartBug> c -> framebuf_stride = FFALIGN ( c -> width * 3 , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> aligned_height = FFALIGN ( c -> height , 16 ) ; <S2SV_EndBug> av_free ( c -> framebuf ) ; c -> framebuf = av_mallocz ( c -> framebuf_stride * aligned_height ) ; if ( ! c -> framebuf ) return AVERROR ( ENOMEM ) ; } if ( ! c -> synth_tile || ! c -> jpeg_tile || c -> old_tile_w < c -> tile_width || c -> old_tile_h < c -> tile_height ) { c -> tile_stride = FFALIGN ( c -> tile_width , 16 ) * 3 ; aligned_height = FFALIGN ( c -> tile_height , 16 ) ; av_free ( c -> synth_tile ) ; av_free ( c -> jpeg_tile ) ; av_free ( c -> kempf_buf ) ; av_free ( c -> kempf_flags ) ; c -> synth_tile = av_mallocz ( c -> tile_stride * aligned_height ) ; c -> jpeg_tile = av_mallocz ( c -> tile_stride * aligned_height ) ; c -> kempf_buf = av_mallocz ( ( c -> tile_width + 1 ) * aligned_height + FF_INPUT_BUFFER_PADDING_SIZE ) ; c -> kempf_flags = av_mallocz ( c -> tile_width * aligned_height ) ; if ( ! c -> synth_tile || ! c -> jpeg_tile || ! c -> kempf_buf || ! c -> kempf_flags ) return AVERROR ( ENOMEM ) ; } return 0 ; }
","<S2SV_ModStart> c -> width + 15 <S2SV_ModEnd> , 16 ) <S2SV_ModStart> , 16 ) * 3 ; aligned_height = <S2SV_ModEnd> c -> height <S2SV_ModStart> c -> height + 15 <S2SV_ModEnd> ; av_free (
"
393,"CWE-362 hsm_com_errno_t hcom_client_init ( OUT p_hsm_com_client_hdl_t * p_hdl , IN char * server_path , IN char * client_path , IN int max_data_len ) { hsm_com_client_hdl_t * hdl = NULL ; hsm_com_errno_t res = HSM_COM_OK ; if ( ( strlen ( server_path ) > ( HSM_COM_SVR_MAX_PATH - 1 ) ) || ( strlen ( server_path ) == 0 ) ) { res = HSM_COM_PATH_ERR ; goto cleanup ; } if ( ( strlen ( client_path ) > ( HSM_COM_SVR_MAX_PATH - 1 ) ) || ( strlen ( client_path ) == 0 ) ) { res = HSM_COM_PATH_ERR ; goto cleanup ; } if ( ( hdl = calloc ( 1 , sizeof ( hsm_com_client_hdl_t ) ) ) == NULL ) { res = HSM_COM_NO_MEM ; goto cleanup ; } if ( ( hdl -> scr . scratch = malloc ( max_data_len ) ) == NULL ) { res = HSM_COM_NO_MEM ; goto cleanup ; } if ( ( hdl -> recv_buf = malloc ( max_data_len ) ) == NULL ) { res = HSM_COM_NO_MEM ; goto cleanup ; } if ( ( hdl -> send_buf = malloc ( max_data_len ) ) == NULL ) { res = HSM_COM_NO_MEM ; goto cleanup ; } hdl -> scr . scratch_fill = 0 ; hdl -> scr . scratch_len = max_data_len ; hdl -> buf_len = max_data_len ; hdl -> trans_id = 1 ; strcpy ( hdl -> s_path , server_path ) ; strcpy ( hdl -> c_path , client_path ) ; <S2SV_StartBug> hdl -> client_state = HSM_COM_C_STATE_IN ; <S2SV_EndBug> * p_hdl = hdl ; return res ; cleanup : if ( hdl ) { if ( hdl -> scr . scratch ) { free ( hdl -> scr . scratch ) ; } if ( hdl -> recv_buf ) { free ( hdl -> recv_buf ) ; } free ( hdl ) ; } return res ; }
","<S2SV_ModStart> client_path ) ; if ( mkstemp ( hdl -> c_path ) == - 1 ) { res = HSM_COM_PATH_ERR ; goto cleanup ; }
"
394,"CWE-119 int evutil_parse_sockaddr_port ( const char * ip_as_string , struct sockaddr * out , int * outlen ) { int port ; char buf [ 128 ] ; const char * cp , * addr_part , * port_part ; int is_ipv6 ; cp = strchr ( ip_as_string , ':' ) ; if ( * ip_as_string == '[' ) { <S2SV_StartBug> int len ; <S2SV_EndBug> if ( ! ( cp = strchr ( ip_as_string , ']' ) ) ) { return - 1 ; } <S2SV_StartBug> len = ( int ) ( cp - ( ip_as_string + 1 ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( len > ( int ) sizeof ( buf ) - 1 ) { <S2SV_EndBug> return - 1 ; } memcpy ( buf , ip_as_string + 1 , len ) ; buf [ len ] = '\\0' ; addr_part = buf ; if ( cp [ 1 ] == ':' ) port_part = cp + 2 ; else port_part = NULL ; is_ipv6 = 1 ; } else if ( cp && strchr ( cp + 1 , ':' ) ) { is_ipv6 = 1 ; addr_part = ip_as_string ; port_part = NULL ; } else if ( cp ) { is_ipv6 = 0 ; if ( cp - ip_as_string > ( int ) sizeof ( buf ) - 1 ) { return - 1 ; } memcpy ( buf , ip_as_string , cp - ip_as_string ) ; buf [ cp - ip_as_string ] = '\\0' ; addr_part = buf ; port_part = cp + 1 ; } else { addr_part = ip_as_string ; port_part = NULL ; is_ipv6 = 0 ; } if ( port_part == NULL ) { port = 0 ; } else { port = atoi ( port_part ) ; if ( port <= 0 || port > 65535 ) { return - 1 ; } } if ( ! addr_part ) return - 1 ; # ifdef AF_INET6 if ( is_ipv6 ) { struct sockaddr_in6 sin6 ; memset ( & sin6 , 0 , sizeof ( sin6 ) ) ; # ifdef EVENT__HAVE_STRUCT_SOCKADDR_IN6_SIN6_LEN sin6 . sin6_len = sizeof ( sin6 ) ; # endif sin6 . sin6_family = AF_INET6 ; sin6 . sin6_port = htons ( port ) ; if ( 1 != evutil_inet_pton ( AF_INET6 , addr_part , & sin6 . sin6_addr ) ) return - 1 ; if ( ( int ) sizeof ( sin6 ) > * outlen ) return - 1 ; memset ( out , 0 , * outlen ) ; memcpy ( out , & sin6 , sizeof ( sin6 ) ) ; * outlen = sizeof ( sin6 ) ; return 0 ; } else # endif { struct sockaddr_in sin ; memset ( & sin , 0 , sizeof ( sin ) ) ; # ifdef EVENT__HAVE_STRUCT_SOCKADDR_IN_SIN_LEN sin . sin_len = sizeof ( sin ) ; # endif sin . sin_family = AF_INET ; sin . sin_port = htons ( port ) ; if ( 1 != evutil_inet_pton ( AF_INET , addr_part , & sin . sin_addr ) ) return - 1 ; if ( ( int ) sizeof ( sin ) > * outlen ) return - 1 ; memset ( out , 0 , * outlen ) ; memcpy ( out , & sin , sizeof ( sin ) ) ; * outlen = sizeof ( sin ) ; return 0 ; } }
","<S2SV_ModStart> '[' ) { size_t <S2SV_ModEnd> len ; if <S2SV_ModStart> } len = <S2SV_ModEnd> ( cp - <S2SV_ModStart> ( len > <S2SV_ModEnd> sizeof ( buf
"
395,"CWE-119 int cJSON_GetArraySize ( cJSON * array ) { cJSON * c = array -> child ; int i = 0 ; <S2SV_StartBug> while ( c ) { <S2SV_EndBug> ++ i ; c = c -> next ; <S2SV_StartBug> } <S2SV_EndBug> return i ; }
","<S2SV_ModStart> ( c ) i ++ , <S2SV_ModEnd> c = c <S2SV_ModStart> -> next ; <S2SV_ModEnd> return i ;
"
396,"CWE-254 static inline int handle_dots ( struct nameidata * nd , int type ) { if ( type == LAST_DOTDOT ) { if ( nd -> flags & LOOKUP_RCU ) { return follow_dotdot_rcu ( nd ) ; } else <S2SV_StartBug> follow_dotdot ( nd ) ; <S2SV_EndBug> } return 0 ; }
","<S2SV_ModStart> ; } else return
"
397,"CWE-000 OM_uint32 gss_krb5int_export_lucid_sec_context ( OM_uint32 * minor_status , const gss_ctx_id_t context_handle , const gss_OID desired_object , gss_buffer_set_t * data_set ) { krb5_error_code kret = 0 ; OM_uint32 retval ; krb5_gss_ctx_id_t ctx = ( krb5_gss_ctx_id_t ) context_handle ; void * lctx = NULL ; int version = 0 ; gss_buffer_desc rep ; retval = GSS_S_FAILURE ; * minor_status = 0 ; * data_set = GSS_C_NO_BUFFER_SET ; <S2SV_StartBug> retval = generic_gss_oid_decompose ( minor_status , <S2SV_EndBug> GSS_KRB5_EXPORT_LUCID_SEC_CONTEXT_OID , GSS_KRB5_EXPORT_LUCID_SEC_CONTEXT_OID_LENGTH , desired_object , & version ) ; if ( GSS_ERROR ( retval ) ) return retval ; switch ( version ) { case 1 : kret = make_external_lucid_ctx_v1 ( ( krb5_pointer ) ctx , version , & lctx ) ; break ; default : kret = ( OM_uint32 ) KG_LUCID_VERSION ; break ; } if ( kret ) goto error_out ; rep . value = & lctx ; rep . length = sizeof ( lctx ) ; retval = generic_gss_add_buffer_set_member ( minor_status , & rep , data_set ) ; if ( GSS_ERROR ( retval ) ) goto error_out ; error_out : if ( * minor_status == 0 ) * minor_status = ( OM_uint32 ) kret ; return ( retval ) ; }
","<S2SV_ModStart> = GSS_C_NO_BUFFER_SET ; if ( ctx -> terminated || ! ctx -> established ) { * minor_status = KG_CTX_INCOMPLETE ; return GSS_S_NO_CONTEXT ; }
"
398,"CWE-787 static RD_BOOL seamless_process_line ( const char * line , void * data ) { UNUSED ( data ) ; char * p , * l ; char * tok1 , * tok3 , * tok4 , * tok5 , * tok6 , * tok7 , * tok8 ; unsigned long id , flags ; char * endptr ; l = xstrdup ( line ) ; p = l ; logger ( Core , Debug , ""seamless_process_line(),<S2SV_blank>got<S2SV_blank>\'%s\'"" , p ) ; tok1 = seamless_get_token ( & p ) ; ( void ) seamless_get_token ( & p ) ; tok3 = seamless_get_token ( & p ) ; tok4 = seamless_get_token ( & p ) ; tok5 = seamless_get_token ( & p ) ; tok6 = seamless_get_token ( & p ) ; tok7 = seamless_get_token ( & p ) ; tok8 = seamless_get_token ( & p ) ; if ( ! strcmp ( ""CREATE"" , tok1 ) ) { unsigned long group , parent ; if ( ! tok6 ) return False ; id = strtoul ( tok3 , & endptr , 0 ) ; if ( * endptr ) return False ; group = strtoul ( tok4 , & endptr , 0 ) ; if ( * endptr ) return False ; parent = strtoul ( tok5 , & endptr , 0 ) ; if ( * endptr ) return False ; flags = strtoul ( tok6 , & endptr , 0 ) ; if ( * endptr ) return False ; ui_seamless_create_window ( id , group , parent , flags ) ; } else if ( ! strcmp ( ""DESTROY"" , tok1 ) ) { if ( ! tok4 ) return False ; id = strtoul ( tok3 , & endptr , 0 ) ; if ( * endptr ) return False ; flags = strtoul ( tok4 , & endptr , 0 ) ; if ( * endptr ) return False ; ui_seamless_destroy_window ( id , flags ) ; } else if ( ! strcmp ( ""DESTROYGRP"" , tok1 ) ) { if ( ! tok4 ) return False ; id = strtoul ( tok3 , & endptr , 0 ) ; if ( * endptr ) return False ; flags = strtoul ( tok4 , & endptr , 0 ) ; if ( * endptr ) return False ; ui_seamless_destroy_group ( id , flags ) ; } else if ( ! strcmp ( ""SETICON"" , tok1 ) ) { int chunk , width , height , len ; char byte [ 3 ] ; if ( ! tok8 ) return False ; id = strtoul ( tok3 , & endptr , 0 ) ; if ( * endptr ) return False ; chunk = strtoul ( tok4 , & endptr , 0 ) ; if ( * endptr ) return False ; width = strtoul ( tok6 , & endptr , 0 ) ; if ( * endptr ) return False ; height = strtoul ( tok7 , & endptr , 0 ) ; if ( * endptr ) return False ; byte [ 2 ] = '\\0' ; len = 0 ; while ( * tok8 != '\\0' ) { byte [ 0 ] = * tok8 ; tok8 ++ ; if ( * tok8 == '\\0' ) return False ; byte [ 1 ] = * tok8 ; tok8 ++ ; icon_buf [ len ] = strtol ( byte , NULL , 16 ) ; len ++ ; <S2SV_StartBug> } <S2SV_EndBug> ui_seamless_seticon ( id , tok5 , width , height , chunk , icon_buf , len ) ; } else if ( ! strcmp ( ""DELICON"" , tok1 ) ) { int width , height ; if ( ! tok6 ) return False ; id = strtoul ( tok3 , & endptr , 0 ) ; if ( * endptr ) return False ; width = strtoul ( tok5 , & endptr , 0 ) ; if ( * endptr ) return False ; height = strtoul ( tok6 , & endptr , 0 ) ; if ( * endptr ) return False ; ui_seamless_delicon ( id , tok4 , width , height ) ; } else if ( ! strcmp ( ""POSITION"" , tok1 ) ) { int x , y , width , height ; if ( ! tok8 ) return False ; id = strtoul ( tok3 , & endptr , 0 ) ; if ( * endptr ) return False ; x = strtol ( tok4 , & endptr , 0 ) ; if ( * endptr ) return False ; y = strtol ( tok5 , & endptr , 0 ) ; if ( * endptr ) return False ; width = strtol ( tok6 , & endptr , 0 ) ; if ( * endptr ) return False ; height = strtol ( tok7 , & endptr , 0 ) ; if ( * endptr ) return False ; flags = strtoul ( tok8 , & endptr , 0 ) ; if ( * endptr ) return False ; ui_seamless_move_window ( id , x , y , width , height , flags ) ; } else if ( ! strcmp ( ""ZCHANGE"" , tok1 ) ) { unsigned long behind ; id = strtoul ( tok3 , & endptr , 0 ) ; if ( * endptr ) return False ; behind = strtoul ( tok4 , & endptr , 0 ) ; if ( * endptr ) return False ; flags = strtoul ( tok5 , & endptr , 0 ) ; if ( * endptr ) return False ; ui_seamless_restack_window ( id , behind , flags ) ; } else if ( ! strcmp ( ""TITLE"" , tok1 ) ) { if ( ! tok5 ) return False ; id = strtoul ( tok3 , & endptr , 0 ) ; if ( * endptr ) return False ; flags = strtoul ( tok5 , & endptr , 0 ) ; if ( * endptr ) return False ; ui_seamless_settitle ( id , tok4 , flags ) ; } else if ( ! strcmp ( ""STATE"" , tok1 ) ) { unsigned int state ; if ( ! tok5 ) return False ; id = strtoul ( tok3 , & endptr , 0 ) ; if ( * endptr ) return False ; state = strtoul ( tok4 , & endptr , 0 ) ; if ( * endptr ) return False ; flags = strtoul ( tok5 , & endptr , 0 ) ; if ( * endptr ) return False ; ui_seamless_setstate ( id , state , flags ) ; } else if ( ! strcmp ( ""DEBUG"" , tok1 ) ) { logger ( Core , Debug , ""seamless_process_line(),<S2SV_blank>%s"" , line ) ; } else if ( ! strcmp ( ""SYNCBEGIN"" , tok1 ) ) { if ( ! tok3 ) return False ; flags = strtoul ( tok3 , & endptr , 0 ) ; if ( * endptr ) return False ; ui_seamless_syncbegin ( flags ) ; } else if ( ! strcmp ( ""SYNCEND"" , tok1 ) ) { if ( ! tok3 ) return False ; flags = strtoul ( tok3 , & endptr , 0 ) ; if ( * endptr ) return False ; } else if ( ! strcmp ( ""HELLO"" , tok1 ) ) { if ( ! tok3 ) return False ; flags = strtoul ( tok3 , & endptr , 0 ) ; if ( * endptr ) return False ; ui_seamless_begin ( ! ! ( flags & SEAMLESSRDP_HELLO_HIDDEN ) ) ; } else if ( ! strcmp ( ""ACK"" , tok1 ) ) { unsigned int serial ; serial = strtoul ( tok3 , & endptr , 0 ) ; if ( * endptr ) return False ; ui_seamless_ack ( serial ) ; } else if ( ! strcmp ( ""HIDE"" , tok1 ) ) { if ( ! tok3 ) return False ; flags = strtoul ( tok3 , & endptr , 0 ) ; if ( * endptr ) return False ; ui_seamless_hide_desktop ( ) ; } else if ( ! strcmp ( ""UNHIDE"" , tok1 ) ) { if ( ! tok3 ) return False ; flags = strtoul ( tok3 , & endptr , 0 ) ; if ( * endptr ) return False ; ui_seamless_unhide_desktop ( ) ; } xfree ( l ) ; return True ; }
","<S2SV_ModStart> len ++ ; if ( ( size_t ) len >= sizeof ( icon_buf ) ) { logger ( Protocol , Warning , ""seamless_process_line(),<S2SV_blank>icon<S2SV_blank>data<S2SV_blank>would<S2SV_blank>overrun<S2SV_blank>icon_buf"" ) ; break ; }
"
399,"CWE-319 static int mincore_pte_range ( pmd_t * pmd , unsigned long addr , unsigned long end , struct mm_walk * walk ) { spinlock_t * ptl ; struct vm_area_struct * vma = walk -> vma ; pte_t * ptep ; unsigned char * vec = walk -> private ; int nr = ( end - addr ) >> PAGE_SHIFT ; ptl = pmd_trans_huge_lock ( pmd , vma ) ; if ( ptl ) { memset ( vec , 1 , nr ) ; spin_unlock ( ptl ) ; goto out ; } if ( pmd_trans_unstable ( pmd ) ) { <S2SV_StartBug> __mincore_unmapped_range ( addr , end , vma , vec ) ; <S2SV_EndBug> goto out ; } ptep = pte_offset_map_lock ( walk -> mm , pmd , addr , & ptl ) ; for ( ; addr != end ; ptep ++ , addr += PAGE_SIZE ) { pte_t pte = * ptep ; if ( pte_none ( pte ) ) <S2SV_StartBug> __mincore_unmapped_range ( addr , addr + PAGE_SIZE , <S2SV_EndBug> vma , vec ) ; else if ( pte_present ( pte ) ) * vec = 1 ; else { swp_entry_t entry = pte_to_swp_entry ( pte ) ; <S2SV_StartBug> if ( non_swap_entry ( entry ) ) { <S2SV_EndBug> * vec = 1 ; } else { # ifdef CONFIG_SWAP * vec = mincore_page ( swap_address_space ( entry ) , swp_offset ( entry ) ) ; # else WARN_ON ( 1 ) ; * vec = 1 ; # endif } } vec ++ ; } pte_unmap_unlock ( ptep - 1 , ptl ) ; out : walk -> private += nr ; cond_resched ( ) ; return 0 ; }
","<S2SV_ModStart> ) ) { memset ( vec , 1 , nr <S2SV_ModEnd> ) ; goto <S2SV_ModStart> pte ) ) * vec = 0 <S2SV_ModEnd> ; else if <S2SV_ModStart> pte ) ; * vec = ! ! <S2SV_ModEnd> non_swap_entry ( entry <S2SV_ModStart> ( entry ) ; <S2SV_ModEnd> } vec ++
"
400,"CWE-772 gpols_ret * get_pols_2_svc ( gpols_arg * arg , struct svc_req * rqstp ) { static gpols_ret ret ; char * prime_arg ; <S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_gpols_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } prime_arg = arg -> exp ; if ( prime_arg == NULL ) prime_arg = ""*"" ; if ( CHANGEPW_SERVICE ( rqstp ) || ! kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_LIST , NULL , NULL ) ) { ret . code = KADM5_AUTH_LIST ; log_unauth ( ""kadm5_get_policies"" , prime_arg , & client_name , & service_name , rqstp ) ; } else { ret . code = kadm5_get_policies ( ( void * ) handle , arg -> exp , & ret . pols , & ret . count ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( ""kadm5_get_policies"" , prime_arg , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> gss_release_buffer ( & minor_stat , & service_name ) ; exit_func : free_server_handle ( handle ) ; return & ret ; }
","<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> ) ; } exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
"
401,"CWE-362 static void userfaultfd_event_wait_completion ( struct userfaultfd_ctx * ctx , struct userfaultfd_wait_queue * ewq ) { struct userfaultfd_ctx * release_new_ctx ; if ( WARN_ON_ONCE ( current -> flags & PF_EXITING ) ) goto out ; ewq -> ctx = ctx ; init_waitqueue_entry ( & ewq -> wq , current ) ; release_new_ctx = NULL ; spin_lock ( & ctx -> event_wqh . lock ) ; __add_wait_queue ( & ctx -> event_wqh , & ewq -> wq ) ; for ( ; ; ) { set_current_state ( TASK_KILLABLE ) ; if ( ewq -> msg . event == 0 ) break ; if ( READ_ONCE ( ctx -> released ) || fatal_signal_pending ( current ) ) { __remove_wait_queue ( & ctx -> event_wqh , & ewq -> wq ) ; if ( ewq -> msg . event == UFFD_EVENT_FORK ) { struct userfaultfd_ctx * new ; new = ( struct userfaultfd_ctx * ) ( unsigned long ) ewq -> msg . arg . reserved . reserved1 ; release_new_ctx = new ; } break ; } spin_unlock ( & ctx -> event_wqh . lock ) ; wake_up_poll ( & ctx -> fd_wqh , EPOLLIN ) ; schedule ( ) ; spin_lock ( & ctx -> event_wqh . lock ) ; } __set_current_state ( TASK_RUNNING ) ; spin_unlock ( & ctx -> event_wqh . lock ) ; if ( release_new_ctx ) { struct vm_area_struct * vma ; struct mm_struct * mm = release_new_ctx -> mm ; down_write ( & mm -> mmap_sem ) ; <S2SV_StartBug> for ( vma = mm -> mmap ; vma ; vma = vma -> vm_next ) <S2SV_EndBug> if ( vma -> vm_userfaultfd_ctx . ctx == release_new_ctx ) { vma -> vm_userfaultfd_ctx = NULL_VM_UFFD_CTX ; vma -> vm_flags &= ~ ( VM_UFFD_WP | VM_UFFD_MISSING ) ; } up_write ( & mm -> mmap_sem ) ; userfaultfd_ctx_put ( release_new_ctx ) ; } out : WRITE_ONCE ( ctx -> mmap_changing , false ) ; userfaultfd_ctx_put ( ctx ) ; }
","<S2SV_ModStart> mmap_sem ) ; VM_WARN_ON ( ! mmget_still_valid ( mm ) ) ;
"
402,"CWE-125 JsVar * jswrap_graphics_createArrayBuffer ( int width , int height , int bpp , JsVar * options ) { if ( width <= 0 || height <= 0 || width > 32767 || height > 32767 ) { jsExceptionHere ( JSET_ERROR , ""Invalid<S2SV_blank>Size"" ) ; return 0 ; } if ( ! isValidBPP ( bpp ) ) { jsExceptionHere ( JSET_ERROR , ""Invalid<S2SV_blank>BPP"" ) ; return 0 ; } JsVar * parent = jspNewObject ( 0 , ""Graphics"" ) ; if ( ! parent ) return 0 ; JsGraphics gfx ; graphicsStructInit ( & gfx ) ; gfx . data . type = JSGRAPHICSTYPE_ARRAYBUFFER ; gfx . data . flags = JSGRAPHICSFLAGS_NONE ; gfx . graphicsVar = parent ; gfx . data . width = ( unsigned short ) width ; gfx . data . height = ( unsigned short ) height ; gfx . data . bpp = ( unsigned char ) bpp ; if ( jsvIsObject ( options ) ) { if ( jsvGetBoolAndUnLock ( jsvObjectGetChild ( options , ""zigzag"" , 0 ) ) ) gfx . data . flags = ( JsGraphicsFlags ) ( gfx . data . flags | JSGRAPHICSFLAGS_ARRAYBUFFER_ZIGZAG ) ; if ( jsvGetBoolAndUnLock ( jsvObjectGetChild ( options , ""msb"" , 0 ) ) ) gfx . data . flags = ( JsGraphicsFlags ) ( gfx . data . flags | JSGRAPHICSFLAGS_ARRAYBUFFER_MSB ) ; if ( jsvGetBoolAndUnLock ( jsvObjectGetChild ( options , ""vertical_byte"" , 0 ) ) ) { if ( gfx . data . bpp == 1 ) gfx . data . flags = ( JsGraphicsFlags ) ( gfx . data . flags | JSGRAPHICSFLAGS_ARRAYBUFFER_VERTICAL_BYTE ) ; else <S2SV_StartBug> jsWarn ( ""vertical_byte<S2SV_blank>only<S2SV_blank>works<S2SV_blank>for<S2SV_blank>1bpp<S2SV_blank>ArrayBuffers\\n"" ) ; <S2SV_EndBug> } JsVar * colorv = jsvObjectGetChild ( options , ""color_order"" , 0 ) ; if ( colorv ) { if ( jsvIsStringEqual ( colorv , ""rgb"" ) ) ; else if ( ! jsvIsStringEqual ( colorv , ""brg"" ) ) gfx . data . flags = ( JsGraphicsFlags ) ( gfx . data . flags | JSGRAPHICSFLAGS_COLOR_BRG ) ; else if ( ! jsvIsStringEqual ( colorv , ""bgr"" ) ) gfx . data . flags = ( JsGraphicsFlags ) ( gfx . data . flags | JSGRAPHICSFLAGS_COLOR_BGR ) ; else if ( ! jsvIsStringEqual ( colorv , ""gbr"" ) ) gfx . data . flags = ( JsGraphicsFlags ) ( gfx . data . flags | JSGRAPHICSFLAGS_COLOR_GBR ) ; else if ( ! jsvIsStringEqual ( colorv , ""grb"" ) ) gfx . data . flags = ( JsGraphicsFlags ) ( gfx . data . flags | JSGRAPHICSFLAGS_COLOR_GRB ) ; else if ( ! jsvIsStringEqual ( colorv , ""rbg"" ) ) gfx . data . flags = ( JsGraphicsFlags ) ( gfx . data . flags | JSGRAPHICSFLAGS_COLOR_RBG ) ; else jsWarn ( ""color_order<S2SV_blank>must<S2SV_blank>be<S2SV_blank>3<S2SV_blank>characters"" ) ; jsvUnLock ( colorv ) ; } } lcdInit_ArrayBuffer ( & gfx ) ; graphicsSetVar ( & gfx ) ; return parent ; }
","<S2SV_ModStart> ) ; else { jsExceptionHere ( JSET_ERROR , <S2SV_ModEnd> ""vertical_byte<S2SV_blank>only<S2SV_blank>works<S2SV_blank>for<S2SV_blank>1bpp<S2SV_blank>ArrayBuffers\\n"" ) ; <S2SV_ModStart> ""vertical_byte<S2SV_blank>only<S2SV_blank>works<S2SV_blank>for<S2SV_blank>1bpp<S2SV_blank>ArrayBuffers\\n"" ) ; return 0 ; } if ( gfx . data . height & 7 ) { jsExceptionHere ( JSET_ERROR , ""height<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>8<S2SV_blank>when<S2SV_blank>using<S2SV_blank>vertical_byte\\n"" ) ; return 0 ; }
"
403,"CWE-119 static Image * ReadBMPImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { BMPInfo bmp_info ; Image * image ; IndexPacket index ; MagickBooleanType status ; MagickOffsetType offset , start_position ; MemoryInfo * pixel_info ; register IndexPacket * indexes ; register PixelPacket * q ; register ssize_t i , x ; register unsigned char * p ; size_t bit , blue , bytes_per_line , green , length , red ; ssize_t count , y ; unsigned char magick [ 12 ] , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & bmp_info , 0 , sizeof ( bmp_info ) ) ; bmp_info . ba_offset = 0 ; start_position = 0 ; count = ReadBlob ( image , 2 , magick ) ; do { LongPixelPacket shift ; PixelPacket quantum_bits ; size_t profile_data , profile_size ; if ( bmp_info . ba_offset == 0 ) start_position = TellBlob ( image ) - 2 ; bmp_info . ba_offset = 0 ; while ( LocaleNCompare ( ( char * ) magick , ""BA"" , 2 ) == 0 ) { bmp_info . file_size = ReadBlobLSBLong ( image ) ; bmp_info . ba_offset = ReadBlobLSBLong ( image ) ; bmp_info . offset_bits = ReadBlobLSBLong ( image ) ; count = ReadBlob ( image , 2 , magick ) ; if ( count != 2 ) break ; } if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Magick:<S2SV_blank>%c%c"" , magick [ 0 ] , magick [ 1 ] ) ; if ( ( count == 0 ) || ( ( LocaleNCompare ( ( char * ) magick , ""BM"" , 2 ) != 0 ) && ( LocaleNCompare ( ( char * ) magick , ""CI"" , 2 ) != 0 ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; bmp_info . file_size = ReadBlobLSBLong ( image ) ; ( void ) ReadBlobLSBLong ( image ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>File_size<S2SV_blank>in<S2SV_blank>header:<S2SV_blank><S2SV_blank>%u<S2SV_blank>bytes"" , bmp_info . file_size ) ; bmp_info . offset_bits = ReadBlobLSBLong ( image ) ; bmp_info . size = ReadBlobLSBLong ( image ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>BMP<S2SV_blank>size:<S2SV_blank>%u"" , bmp_info . size ) ; if ( bmp_info . size == 12 ) { ( void ) CopyMagickString ( image -> magick , ""BMP2"" , MaxTextExtent ) ; bmp_info . width = ( ssize_t ) ( ( short ) ReadBlobLSBShort ( image ) ) ; bmp_info . height = ( ssize_t ) ( ( short ) ReadBlobLSBShort ( image ) ) ; bmp_info . planes = ReadBlobLSBShort ( image ) ; bmp_info . bits_per_pixel = ReadBlobLSBShort ( image ) ; bmp_info . x_pixels = 0 ; bmp_info . y_pixels = 0 ; bmp_info . number_colors = 0 ; bmp_info . compression = BI_RGB ; bmp_info . image_size = 0 ; bmp_info . alpha_mask = 0 ; if ( image -> debug != MagickFalse ) { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Format:<S2SV_blank>OS/2<S2SV_blank>Bitmap"" ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Geometry:<S2SV_blank>%.20gx%.20g"" , ( double ) bmp_info . width , ( double ) bmp_info . height ) ; } } else { if ( bmp_info . size < 40 ) ThrowReaderException ( CorruptImageError , ""NonOS2HeaderSizeError"" ) ; bmp_info . width = ( ssize_t ) ( ( int ) ReadBlobLSBLong ( image ) ) ; bmp_info . height = ( ssize_t ) ( ( int ) ReadBlobLSBLong ( image ) ) ; bmp_info . planes = ReadBlobLSBShort ( image ) ; bmp_info . bits_per_pixel = ReadBlobLSBShort ( image ) ; bmp_info . compression = ReadBlobLSBLong ( image ) ; bmp_info . image_size = ReadBlobLSBLong ( image ) ; bmp_info . x_pixels = ReadBlobLSBLong ( image ) ; bmp_info . y_pixels = ReadBlobLSBLong ( image ) ; bmp_info . number_colors = ReadBlobLSBLong ( image ) ; bmp_info . colors_important = ReadBlobLSBLong ( image ) ; profile_data = 0 ; profile_size = 0 ; if ( image -> debug != MagickFalse ) { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Format:<S2SV_blank>MS<S2SV_blank>Windows<S2SV_blank>bitmap"" ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Geometry:<S2SV_blank>%.20gx%.20g"" , ( double ) bmp_info . width , ( double ) bmp_info . height ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Bits<S2SV_blank>per<S2SV_blank>pixel:<S2SV_blank>%.20g"" , ( double ) bmp_info . bits_per_pixel ) ; switch ( ( int ) bmp_info . compression ) { case BI_RGB : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RGB"" ) ; break ; } case BI_RLE4 : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RLE4"" ) ; break ; } case BI_RLE8 : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RLE8"" ) ; break ; } case BI_BITFIELDS : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_BITFIELDS"" ) ; break ; } case BI_PNG : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_PNG"" ) ; break ; } case BI_JPEG : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_JPEG"" ) ; break ; } default : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>UNKNOWN<S2SV_blank>(%u)"" , bmp_info . compression ) ; } } ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Number<S2SV_blank>of<S2SV_blank>colors:<S2SV_blank>%u"" , bmp_info . number_colors ) ; } bmp_info . red_mask = ReadBlobLSBLong ( image ) ; bmp_info . green_mask = ReadBlobLSBLong ( image ) ; bmp_info . blue_mask = ReadBlobLSBLong ( image ) ; if ( bmp_info . size > 40 ) { double sum ; bmp_info . alpha_mask = ReadBlobLSBLong ( image ) ; bmp_info . colorspace = ( int ) ReadBlobLSBLong ( image ) ; # define BMP_DENOM ( ( double ) 0x40000000 ) bmp_info . red_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . red_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . red_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . green_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . green_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . green_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . blue_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . blue_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . blue_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; sum = bmp_info . red_primary . x + bmp_info . red_primary . y + bmp_info . red_primary . z ; bmp_info . red_primary . x /= sum ; bmp_info . red_primary . y /= sum ; image -> chromaticity . red_primary . x = bmp_info . red_primary . x ; image -> chromaticity . red_primary . y = bmp_info . red_primary . y ; sum = bmp_info . green_primary . x + bmp_info . green_primary . y + bmp_info . green_primary . z ; bmp_info . green_primary . x /= sum ; bmp_info . green_primary . y /= sum ; image -> chromaticity . green_primary . x = bmp_info . green_primary . x ; image -> chromaticity . green_primary . y = bmp_info . green_primary . y ; sum = bmp_info . blue_primary . x + bmp_info . blue_primary . y + bmp_info . blue_primary . z ; bmp_info . blue_primary . x /= sum ; bmp_info . blue_primary . y /= sum ; image -> chromaticity . blue_primary . x = bmp_info . blue_primary . x ; image -> chromaticity . blue_primary . y = bmp_info . blue_primary . y ; bmp_info . gamma_scale . x = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; bmp_info . gamma_scale . y = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; bmp_info . gamma_scale . z = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; image -> gamma = ( bmp_info . gamma_scale . x + bmp_info . gamma_scale . y + bmp_info . gamma_scale . z ) / 3.0 ; } else ( void ) CopyMagickString ( image -> magick , ""BMP3"" , MaxTextExtent ) ; if ( bmp_info . size > 108 ) { size_t intent ; intent = ReadBlobLSBLong ( image ) ; switch ( ( int ) intent ) { case LCS_GM_BUSINESS : { image -> rendering_intent = SaturationIntent ; break ; } case LCS_GM_GRAPHICS : { image -> rendering_intent = RelativeIntent ; break ; } case LCS_GM_IMAGES : { image -> rendering_intent = PerceptualIntent ; break ; } case LCS_GM_ABS_COLORIMETRIC : { image -> rendering_intent = AbsoluteIntent ; break ; } } profile_data = ReadBlobLSBLong ( image ) ; profile_size = ReadBlobLSBLong ( image ) ; ( void ) profile_data ; ( void ) profile_size ; ( void ) ReadBlobLSBLong ( image ) ; } } if ( ( MagickSizeType ) bmp_info . file_size > GetBlobSize ( image ) ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageError , ""LengthAndFilesizeDoNotMatch"" , ""`%s\'"" , image -> filename ) ; else if ( ( MagickSizeType ) bmp_info . file_size < GetBlobSize ( image ) ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageWarning , ""LengthAndFilesizeDoNotMatch"" , ""`%s\'"" , image -> filename ) ; if ( bmp_info . width <= 0 ) ThrowReaderException ( CorruptImageError , ""NegativeOrZeroImageSize"" ) ; if ( bmp_info . height == 0 ) ThrowReaderException ( CorruptImageError , ""NegativeOrZeroImageSize"" ) ; if ( bmp_info . planes != 1 ) ThrowReaderException ( CorruptImageError , ""StaticPlanesValueNotEqualToOne"" ) ; if ( ( bmp_info . bits_per_pixel != 1 ) && ( bmp_info . bits_per_pixel != 4 ) && ( bmp_info . bits_per_pixel != 8 ) && ( bmp_info . bits_per_pixel != 16 ) && ( bmp_info . bits_per_pixel != 24 ) && ( bmp_info . bits_per_pixel != 32 ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedBitsPerPixel"" ) ; if ( bmp_info . bits_per_pixel < 16 && bmp_info . number_colors > ( 1U << bmp_info . bits_per_pixel ) ) { ThrowReaderException ( CorruptImageError , ""UnrecognizedNumberOfColors"" ) ; } if ( ( bmp_info . compression == 1 ) && ( bmp_info . bits_per_pixel != 8 ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedBitsPerPixel"" ) ; if ( ( bmp_info . compression == 2 ) && ( bmp_info . bits_per_pixel != 4 ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedBitsPerPixel"" ) ; if ( ( bmp_info . compression == 3 ) && ( bmp_info . bits_per_pixel < 16 ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedBitsPerPixel"" ) ; switch ( bmp_info . compression ) { case BI_RGB : case BI_RLE8 : case BI_RLE4 : case BI_BITFIELDS : break ; case BI_JPEG : ThrowReaderException ( CoderError , ""JPEGCompressNotSupported"" ) ; case BI_PNG : ThrowReaderException ( CoderError , ""PNGCompressNotSupported"" ) ; default : ThrowReaderException ( CorruptImageError , ""UnrecognizedImageCompression"" ) ; } image -> columns = ( size_t ) MagickAbsoluteValue ( bmp_info . width ) ; image -> rows = ( size_t ) MagickAbsoluteValue ( bmp_info . height ) ; image -> depth = bmp_info . bits_per_pixel <= 8 ? bmp_info . bits_per_pixel : 8 ; image -> matte = ( ( bmp_info . alpha_mask != 0 ) && ( bmp_info . compression == BI_BITFIELDS ) ) || ( bmp_info . bits_per_pixel == 32 ) ? MagickTrue : MagickFalse ; if ( bmp_info . bits_per_pixel < 16 ) { size_t one ; image -> storage_class = PseudoClass ; image -> colors = bmp_info . number_colors ; one = 1 ; if ( image -> colors == 0 ) image -> colors = one << bmp_info . bits_per_pixel ; } if ( image -> storage_class == PseudoClass ) { unsigned char * bmp_colormap ; size_t packet_size ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Reading<S2SV_blank>colormap<S2SV_blank>of<S2SV_blank>%.20g<S2SV_blank>colors"" , ( double ) image -> colors ) ; if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; bmp_colormap = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) image -> colors , 4 * sizeof ( * bmp_colormap ) ) ; if ( bmp_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( ( bmp_info . size == 12 ) || ( bmp_info . size == 64 ) ) packet_size = 3 ; else packet_size = 4 ; offset = SeekBlob ( image , start_position + 14 + bmp_info . size , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; count = ReadBlob ( image , packet_size * image -> colors , bmp_colormap ) ; if ( count != ( ssize_t ) ( packet_size * image -> colors ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; p = bmp_colormap ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . blue = ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . red = ScaleCharToQuantum ( * p ++ ) ; if ( packet_size == 4 ) p ++ ; } bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ; } image -> x_resolution = ( double ) bmp_info . x_pixels / 100.0 ; image -> y_resolution = ( double ) bmp_info . y_pixels / 100.0 ; image -> units = PixelsPerCentimeterResolution ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) <S2SV_StartBug> break ; <S2SV_EndBug> offset = SeekBlob ( image , start_position + bmp_info . offset_bits , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( bmp_info . compression == BI_RLE4 ) bmp_info . bits_per_pixel <<= 1 ; bytes_per_line = 4 * ( ( image -> columns * bmp_info . bits_per_pixel + 31 ) / 32 ) ; length = ( size_t ) bytes_per_line * image -> rows ; pixel_info = AcquireVirtualMemory ( ( size_t ) image -> rows , MagickMax ( bytes_per_line , image -> columns + 256UL ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; if ( ( bmp_info . compression == BI_RGB ) || ( bmp_info . compression == BI_BITFIELDS ) ) { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Reading<S2SV_blank>pixels<S2SV_blank>(%.20g<S2SV_blank>bytes)"" , ( double ) length ) ; count = ReadBlob ( image , length , pixels ) ; if ( count != ( ssize_t ) length ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } } else { status = DecodeImage ( image , bmp_info . compression , pixels ) ; if ( status == MagickFalse ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToRunlengthDecodeImage"" ) ; } } if ( bmp_info . compression == BI_RGB ) { bmp_info . alpha_mask = image -> matte != MagickFalse ? 0xff000000U : 0U ; bmp_info . red_mask = 0x00ff0000U ; bmp_info . green_mask = 0x0000ff00U ; bmp_info . blue_mask = 0x000000ffU ; if ( bmp_info . bits_per_pixel == 16 ) { bmp_info . red_mask = 0x00007c00U ; bmp_info . green_mask = 0x000003e0U ; bmp_info . blue_mask = 0x0000001fU ; } } if ( ( bmp_info . bits_per_pixel == 16 ) || ( bmp_info . bits_per_pixel == 32 ) ) { register size_t sample ; ( void ) ResetMagickMemory ( & shift , 0 , sizeof ( shift ) ) ; ( void ) ResetMagickMemory ( & quantum_bits , 0 , sizeof ( quantum_bits ) ) ; if ( bmp_info . red_mask != 0 ) while ( ( ( bmp_info . red_mask << shift . red ) & 0x80000000UL ) == 0 ) shift . red ++ ; if ( bmp_info . green_mask != 0 ) while ( ( ( bmp_info . green_mask << shift . green ) & 0x80000000UL ) == 0 ) shift . green ++ ; if ( bmp_info . blue_mask != 0 ) while ( ( ( bmp_info . blue_mask << shift . blue ) & 0x80000000UL ) == 0 ) shift . blue ++ ; if ( bmp_info . alpha_mask != 0 ) while ( ( ( bmp_info . alpha_mask << shift . opacity ) & 0x80000000UL ) == 0 ) shift . opacity ++ ; sample = shift . red ; while ( ( ( bmp_info . red_mask << sample ) & 0x80000000UL ) != 0 ) sample ++ ; quantum_bits . red = ClampToQuantum ( ( MagickRealType ) sample - shift . red ) ; sample = shift . green ; while ( ( ( bmp_info . green_mask << sample ) & 0x80000000UL ) != 0 ) sample ++ ; quantum_bits . green = ClampToQuantum ( ( MagickRealType ) sample - shift . green ) ; sample = shift . blue ; while ( ( ( bmp_info . blue_mask << sample ) & 0x80000000UL ) != 0 ) sample ++ ; quantum_bits . blue = ClampToQuantum ( ( MagickRealType ) sample - shift . blue ) ; sample = shift . opacity ; while ( ( ( bmp_info . alpha_mask << sample ) & 0x80000000UL ) != 0 ) sample ++ ; quantum_bits . opacity = ClampToQuantum ( ( MagickRealType ) sample - shift . opacity ) ; } switch ( bmp_info . bits_per_pixel ) { case 1 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { index = ( IndexPacket ) ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ? 0x01 : 0x00 ) ; SetPixelIndex ( indexes + x + bit , index ) ; q ++ ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( image -> columns % 8 ) ; bit ++ ) { index = ( IndexPacket ) ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ? 0x01 : 0x00 ) ; SetPixelIndex ( indexes + x + bit , index ) ; } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image ) ; break ; } case 4 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x0f ) ; SetPixelIndex ( indexes + x , index ) ; index = ConstrainColormapIndex ( image , * p & 0x0f ) ; SetPixelIndex ( indexes + x + 1 , index ) ; p ++ ; } if ( ( image -> columns % 2 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0xf ) ; SetPixelIndex ( indexes + x , index ) ; p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image ) ; break ; } case 8 : { if ( ( bmp_info . compression == BI_RLE8 ) || ( bmp_info . compression == BI_RLE4 ) ) bytes_per_line = image -> columns ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = ( ssize_t ) image -> columns ; x != 0 ; -- x ) { index = ConstrainColormapIndex ( image , * p ) ; SetPixelIndex ( indexes , index ) ; indexes ++ ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image ) ; break ; } case 16 : { size_t alpha , pixel ; if ( bmp_info . compression != BI_RGB && bmp_info . compression != BI_BITFIELDS ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnrecognizedImageCompression"" ) ; } bytes_per_line = 2 * ( image -> columns + image -> columns % 2 ) ; image -> storage_class = DirectClass ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { pixel = ( size_t ) ( * p ++ ) ; pixel |= ( * p ++ ) << 8 ; red = ( ( pixel & bmp_info . red_mask ) << shift . red ) >> 16 ; if ( quantum_bits . red == 5 ) red |= ( ( red & 0xe000 ) >> 5 ) ; if ( quantum_bits . red <= 8 ) red |= ( ( red & 0xff00 ) >> 8 ) ; green = ( ( pixel & bmp_info . green_mask ) << shift . green ) >> 16 ; if ( quantum_bits . green == 5 ) green |= ( ( green & 0xe000 ) >> 5 ) ; if ( quantum_bits . green == 6 ) green |= ( ( green & 0xc000 ) >> 6 ) ; if ( quantum_bits . green <= 8 ) green |= ( ( green & 0xff00 ) >> 8 ) ; blue = ( ( pixel & bmp_info . blue_mask ) << shift . blue ) >> 16 ; if ( quantum_bits . blue == 5 ) blue |= ( ( blue & 0xe000 ) >> 5 ) ; if ( quantum_bits . blue <= 8 ) blue |= ( ( blue & 0xff00 ) >> 8 ) ; alpha = ( ( pixel & bmp_info . alpha_mask ) << shift . opacity ) >> 16 ; if ( quantum_bits . opacity <= 8 ) alpha |= ( ( alpha & 0xff00 ) >> 8 ) ; SetPixelRed ( q , ScaleShortToQuantum ( ( unsigned short ) red ) ) ; SetPixelGreen ( q , ScaleShortToQuantum ( ( unsigned short ) green ) ) ; SetPixelBlue ( q , ScaleShortToQuantum ( ( unsigned short ) blue ) ) ; SetPixelOpacity ( q , OpaqueOpacity ) ; if ( image -> matte != MagickFalse ) SetPixelAlpha ( q , ScaleShortToQuantum ( ( unsigned short ) alpha ) ) ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 24 : { bytes_per_line = 4 * ( ( image -> columns * 24 + 31 ) / 32 ) ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelOpacity ( q , OpaqueOpacity ) ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 32 : { if ( ( bmp_info . compression != BI_RGB ) && ( bmp_info . compression != BI_BITFIELDS ) ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnrecognizedImageCompression"" ) ; } bytes_per_line = 4 * ( image -> columns ) ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { size_t alpha , pixel ; p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { pixel = ( size_t ) ( * p ++ ) ; pixel |= ( ( size_t ) * p ++ << 8 ) ; pixel |= ( ( size_t ) * p ++ << 16 ) ; pixel |= ( ( size_t ) * p ++ << 24 ) ; red = ( ( pixel & bmp_info . red_mask ) << shift . red ) >> 16 ; if ( quantum_bits . red == 8 ) red |= ( red >> 8 ) ; green = ( ( pixel & bmp_info . green_mask ) << shift . green ) >> 16 ; if ( quantum_bits . green == 8 ) green |= ( green >> 8 ) ; blue = ( ( pixel & bmp_info . blue_mask ) << shift . blue ) >> 16 ; if ( quantum_bits . blue == 8 ) blue |= ( blue >> 8 ) ; alpha = ( ( pixel & bmp_info . alpha_mask ) << shift . opacity ) >> 16 ; if ( quantum_bits . opacity == 8 ) alpha |= ( alpha >> 8 ) ; SetPixelRed ( q , ScaleShortToQuantum ( ( unsigned short ) red ) ) ; SetPixelGreen ( q , ScaleShortToQuantum ( ( unsigned short ) green ) ) ; SetPixelBlue ( q , ScaleShortToQuantum ( ( unsigned short ) blue ) ) ; SetPixelAlpha ( q , OpaqueOpacity ) ; if ( image -> matte != MagickFalse ) SetPixelAlpha ( q , ScaleShortToQuantum ( ( unsigned short ) alpha ) ) ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } default : { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } } pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( bmp_info . height < 0 ) { Image * flipped_image ; flipped_image = FlipImage ( image , exception ) ; if ( flipped_image != ( Image * ) NULL ) { DuplicateBlob ( flipped_image , image ) ; image = DestroyImage ( image ) ; image = flipped_image ; } } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; * magick = '\\0' ; if ( bmp_info . ba_offset != 0 ) { offset = SeekBlob ( image , ( MagickOffsetType ) bmp_info . ba_offset , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } count = ReadBlob ( image , 2 , magick ) ; if ( ( count == 2 ) && ( IsBMP ( magick , 2 ) != MagickFalse ) ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( IsBMP ( magick , 2 ) != MagickFalse ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
"
404,"CWE-119 TEE_Result syscall_asymm_operate ( unsigned long state , const struct utee_attribute * usr_params , size_t num_params , const void * src_data , size_t src_len , void * dst_data , uint64_t * dst_len ) { TEE_Result res ; struct tee_cryp_state * cs ; struct tee_ta_session * sess ; uint64_t dlen64 ; size_t dlen ; struct tee_obj * o ; void * label = NULL ; size_t label_len = 0 ; size_t n ; int salt_len ; TEE_Attribute * params = NULL ; struct user_ta_ctx * utc ; res = tee_ta_get_current_session ( & sess ) ; if ( res != TEE_SUCCESS ) return res ; utc = to_user_ta_ctx ( sess -> ctx ) ; res = tee_svc_cryp_get_state ( sess , tee_svc_uref_to_vaddr ( state ) , & cs ) ; if ( res != TEE_SUCCESS ) return res ; res = tee_mmu_check_access_rights ( utc , TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER , ( uaddr_t ) src_data , src_len ) ; if ( res != TEE_SUCCESS ) return res ; res = tee_svc_copy_from_user ( & dlen64 , dst_len , sizeof ( dlen64 ) ) ; if ( res != TEE_SUCCESS ) return res ; dlen = dlen64 ; res = tee_mmu_check_access_rights ( utc , TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_WRITE | TEE_MEMORY_ACCESS_ANY_OWNER , ( uaddr_t ) dst_data , dlen ) ; if ( res != TEE_SUCCESS ) return res ; <S2SV_StartBug> params = malloc ( sizeof ( TEE_Attribute ) * num_params ) ; <S2SV_EndBug> if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY ; res = copy_in_attrs ( utc , usr_params , num_params , params ) ; if ( res != TEE_SUCCESS ) goto out ; res = tee_obj_get ( utc , cs -> key1 , & o ) ; if ( res != TEE_SUCCESS ) goto out ; if ( ( o -> info . handleFlags & TEE_HANDLE_FLAG_INITIALIZED ) == 0 ) { res = TEE_ERROR_GENERIC ; goto out ; } switch ( cs -> algo ) { case TEE_ALG_RSA_NOPAD : if ( cs -> mode == TEE_MODE_ENCRYPT ) { res = crypto_acipher_rsanopad_encrypt ( o -> attr , src_data , src_len , dst_data , & dlen ) ; } else if ( cs -> mode == TEE_MODE_DECRYPT ) { res = crypto_acipher_rsanopad_decrypt ( o -> attr , src_data , src_len , dst_data , & dlen ) ; } else { res = TEE_ERROR_GENERIC ; } break ; case TEE_ALG_RSAES_PKCS1_V1_5 : case TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA1 : case TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA224 : case TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA256 : case TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA384 : case TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA512 : for ( n = 0 ; n < num_params ; n ++ ) { if ( params [ n ] . attributeID == TEE_ATTR_RSA_OAEP_LABEL ) { label = params [ n ] . content . ref . buffer ; label_len = params [ n ] . content . ref . length ; break ; } } if ( cs -> mode == TEE_MODE_ENCRYPT ) { res = crypto_acipher_rsaes_encrypt ( cs -> algo , o -> attr , label , label_len , src_data , src_len , dst_data , & dlen ) ; } else if ( cs -> mode == TEE_MODE_DECRYPT ) { res = crypto_acipher_rsaes_decrypt ( cs -> algo , o -> attr , label , label_len , src_data , src_len , dst_data , & dlen ) ; } else { res = TEE_ERROR_BAD_PARAMETERS ; } break ; # if defined ( CFG_CRYPTO_RSASSA_NA1 ) case TEE_ALG_RSASSA_PKCS1_V1_5 : # endif case TEE_ALG_RSASSA_PKCS1_V1_5_MD5 : case TEE_ALG_RSASSA_PKCS1_V1_5_SHA1 : case TEE_ALG_RSASSA_PKCS1_V1_5_SHA224 : case TEE_ALG_RSASSA_PKCS1_V1_5_SHA256 : case TEE_ALG_RSASSA_PKCS1_V1_5_SHA384 : case TEE_ALG_RSASSA_PKCS1_V1_5_SHA512 : case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1 : case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224 : case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256 : case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384 : case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512 : if ( cs -> mode != TEE_MODE_SIGN ) { res = TEE_ERROR_BAD_PARAMETERS ; break ; } salt_len = pkcs1_get_salt_len ( params , num_params , src_len ) ; res = crypto_acipher_rsassa_sign ( cs -> algo , o -> attr , salt_len , src_data , src_len , dst_data , & dlen ) ; break ; case TEE_ALG_DSA_SHA1 : case TEE_ALG_DSA_SHA224 : case TEE_ALG_DSA_SHA256 : res = crypto_acipher_dsa_sign ( cs -> algo , o -> attr , src_data , src_len , dst_data , & dlen ) ; break ; case TEE_ALG_ECDSA_P192 : case TEE_ALG_ECDSA_P224 : case TEE_ALG_ECDSA_P256 : case TEE_ALG_ECDSA_P384 : case TEE_ALG_ECDSA_P521 : res = crypto_acipher_ecc_sign ( cs -> algo , o -> attr , src_data , src_len , dst_data , & dlen ) ; break ; default : res = TEE_ERROR_BAD_PARAMETERS ; break ; } out : free ( params ) ; if ( res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER ) { TEE_Result res2 ; dlen64 = dlen ; res2 = tee_svc_copy_to_user ( dst_len , & dlen64 , sizeof ( * dst_len ) ) ; if ( res2 != TEE_SUCCESS ) return res2 ; } return res ; }
","<S2SV_ModStart> return res ; size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , num_params , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; <S2SV_ModStart> = malloc ( alloc_size <S2SV_ModEnd> ) ; if
"
405,"CWE-416 static int archive_read_format_rar_read_data ( struct archive_read * a , const void * * buff , size_t * size , int64_t * offset ) { struct rar * rar = ( struct rar * ) ( a -> format -> data ) ; int ret ; if ( rar -> has_encrypted_entries == ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW ) { rar -> has_encrypted_entries = 0 ; } if ( rar -> bytes_unconsumed > 0 ) { __archive_read_consume ( a , rar -> bytes_unconsumed ) ; rar -> bytes_unconsumed = 0 ; } * buff = NULL ; if ( rar -> entry_eof || rar -> offset_seek >= rar -> unp_size ) { * size = 0 ; * offset = rar -> offset ; if ( * offset < rar -> unp_size ) * offset = rar -> unp_size ; return ( ARCHIVE_EOF ) ; } switch ( rar -> compression_method ) { case COMPRESS_METHOD_STORE : ret = read_data_stored ( a , buff , size , offset ) ; break ; case COMPRESS_METHOD_FASTEST : case COMPRESS_METHOD_FAST : case COMPRESS_METHOD_NORMAL : case COMPRESS_METHOD_GOOD : case COMPRESS_METHOD_BEST : ret = read_data_compressed ( a , buff , size , offset ) ; <S2SV_StartBug> if ( ret != ARCHIVE_OK && ret != ARCHIVE_WARN ) <S2SV_EndBug> __archive_ppmd7_functions . Ppmd7_Free ( & rar -> ppmd7_context ) ; <S2SV_StartBug> break ; <S2SV_EndBug> default : archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>for<S2SV_blank>RAR<S2SV_blank>file."" ) ; ret = ARCHIVE_FATAL ; break ; } return ( ret ) ; }
","<S2SV_ModStart> != ARCHIVE_WARN ) { <S2SV_ModStart> ppmd7_context ) ; rar -> start_new_table = 1 ; }
"
406,"CWE-119 void vp8_init_mbmode_probs ( VP8_COMMON * x ) { <S2SV_StartBug> vpx_memcpy ( x -> fc . ymode_prob , vp8_ymode_prob , sizeof ( vp8_ymode_prob ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( x -> fc . uv_mode_prob , vp8_uv_mode_prob , sizeof ( vp8_uv_mode_prob ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( x -> fc . sub_mv_ref_prob , sub_mv_ref_prob , sizeof ( sub_mv_ref_prob ) ) ; <S2SV_EndBug> }
","<S2SV_ModStart> x ) { memcpy <S2SV_ModEnd> ( x -> <S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( x -> <S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( x ->
"
407,"CWE-476 static int tls_construct_cke_ecdhe ( SSL * s , unsigned char * * p , int * len , int * al ) { # ifndef OPENSSL_NO_EC unsigned char * encodedPoint = NULL ; int encoded_pt_len = 0 ; EVP_PKEY * ckey = NULL , * skey = NULL ; skey = s -> s3 -> peer_tmp ; if ( skey == NULL ) { SSLerr ( SSL_F_TLS_CONSTRUCT_CKE_ECDHE , ERR_R_INTERNAL_ERROR ) ; return 0 ; } ckey = ssl_generate_pkey ( skey ) ; <S2SV_StartBug> if ( ssl_derive ( s , ckey , skey ) == 0 ) { <S2SV_EndBug> SSLerr ( SSL_F_TLS_CONSTRUCT_CKE_ECDHE , ERR_R_EVP_LIB ) ; goto err ; } encoded_pt_len = EVP_PKEY_get1_tls_encodedpoint ( ckey , & encodedPoint ) ; if ( encoded_pt_len == 0 ) { SSLerr ( SSL_F_TLS_CONSTRUCT_CKE_ECDHE , ERR_R_EC_LIB ) ; goto err ; } EVP_PKEY_free ( ckey ) ; ckey = NULL ; * len = encoded_pt_len ; * * p = * len ; * p += 1 ; memcpy ( * p , encodedPoint , * len ) ; * len += 1 ; OPENSSL_free ( encodedPoint ) ; return 1 ; err : EVP_PKEY_free ( ckey ) ; return 0 ; # else SSLerr ( SSL_F_TLS_CONSTRUCT_CKE_ECDHE , ERR_R_INTERNAL_ERROR ) ; * al = SSL_AD_INTERNAL_ERROR ; return 0 ; # endif }
","<S2SV_ModStart> ; if ( ckey == NULL ) { SSLerr ( SSL_F_TLS_CONSTRUCT_CKE_ECDHE , ERR_R_INTERNAL_ERROR ) ; goto err ; } if (
"
408,"CWE-119 void vp9_adapt_mode_probs ( VP9_COMMON * cm ) { int i , j ; <S2SV_StartBug> FRAME_CONTEXT * fc = & cm -> fc ; <S2SV_EndBug> const FRAME_CONTEXT * pre_fc = & cm -> frame_contexts [ cm -> frame_context_idx ] ; const FRAME_COUNTS * counts = & cm -> counts ; for ( i = 0 ; i < INTRA_INTER_CONTEXTS ; i ++ ) <S2SV_StartBug> fc -> intra_inter_prob [ i ] = adapt_prob ( pre_fc -> intra_inter_prob [ i ] , <S2SV_EndBug> counts -> intra_inter [ i ] ) ; for ( i = 0 ; i < COMP_INTER_CONTEXTS ; i ++ ) <S2SV_StartBug> fc -> comp_inter_prob [ i ] = adapt_prob ( pre_fc -> comp_inter_prob [ i ] , <S2SV_EndBug> counts -> comp_inter [ i ] ) ; for ( i = 0 ; i < REF_CONTEXTS ; i ++ ) <S2SV_StartBug> fc -> comp_ref_prob [ i ] = adapt_prob ( pre_fc -> comp_ref_prob [ i ] , <S2SV_EndBug> counts -> comp_ref [ i ] ) ; for ( i = 0 ; i < REF_CONTEXTS ; i ++ ) for ( j = 0 ; j < 2 ; j ++ ) <S2SV_StartBug> fc -> single_ref_prob [ i ] [ j ] = adapt_prob ( pre_fc -> single_ref_prob [ i ] [ j ] , <S2SV_EndBug> counts -> single_ref [ i ] [ j ] ) ; for ( i = 0 ; i < INTER_MODE_CONTEXTS ; i ++ ) <S2SV_StartBug> adapt_probs ( vp9_inter_mode_tree , pre_fc -> inter_mode_probs [ i ] , <S2SV_EndBug> counts -> inter_mode [ i ] , fc -> inter_mode_probs [ i ] ) ; for ( i = 0 ; i < BLOCK_SIZE_GROUPS ; i ++ ) <S2SV_StartBug> adapt_probs ( vp9_intra_mode_tree , pre_fc -> y_mode_prob [ i ] , <S2SV_EndBug> counts -> y_mode [ i ] , fc -> y_mode_prob [ i ] ) ; for ( i = 0 ; i < INTRA_MODES ; ++ i ) <S2SV_StartBug> adapt_probs ( vp9_intra_mode_tree , pre_fc -> uv_mode_prob [ i ] , <S2SV_EndBug> counts -> uv_mode [ i ] , fc -> uv_mode_prob [ i ] ) ; for ( i = 0 ; i < PARTITION_CONTEXTS ; i ++ ) <S2SV_StartBug> adapt_probs ( vp9_partition_tree , pre_fc -> partition_prob [ i ] , <S2SV_EndBug> counts -> partition [ i ] , fc -> partition_prob [ i ] ) ; if ( cm -> interp_filter == SWITCHABLE ) { for ( i = 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; i ++ ) <S2SV_StartBug> adapt_probs ( vp9_switchable_interp_tree , pre_fc -> switchable_interp_prob [ i ] , <S2SV_EndBug> counts -> switchable_interp [ i ] , fc -> switchable_interp_prob [ i ] ) ; } if ( cm -> tx_mode == TX_MODE_SELECT ) { int j ; unsigned int branch_ct_8x8p [ TX_SIZES - 3 ] [ 2 ] ; unsigned int branch_ct_16x16p [ TX_SIZES - 2 ] [ 2 ] ; unsigned int branch_ct_32x32p [ TX_SIZES - 1 ] [ 2 ] ; for ( i = 0 ; i < TX_SIZE_CONTEXTS ; ++ i ) { tx_counts_to_branch_counts_8x8 ( counts -> tx . p8x8 [ i ] , branch_ct_8x8p ) ; for ( j = 0 ; j < TX_SIZES - 3 ; ++ j ) <S2SV_StartBug> fc -> tx_probs . p8x8 [ i ] [ j ] = adapt_prob ( pre_fc -> tx_probs . p8x8 [ i ] [ j ] , <S2SV_EndBug> branch_ct_8x8p [ j ] ) ; tx_counts_to_branch_counts_16x16 ( counts -> tx . p16x16 [ i ] , branch_ct_16x16p ) ; for ( j = 0 ; j < TX_SIZES - 2 ; ++ j ) <S2SV_StartBug> fc -> tx_probs . p16x16 [ i ] [ j ] = adapt_prob ( pre_fc -> tx_probs . p16x16 [ i ] [ j ] , <S2SV_EndBug> branch_ct_16x16p [ j ] ) ; tx_counts_to_branch_counts_32x32 ( counts -> tx . p32x32 [ i ] , branch_ct_32x32p ) ; for ( j = 0 ; j < TX_SIZES - 1 ; ++ j ) <S2SV_StartBug> fc -> tx_probs . p32x32 [ i ] [ j ] = adapt_prob ( pre_fc -> tx_probs . p32x32 [ i ] [ j ] , <S2SV_EndBug> branch_ct_32x32p [ j ] ) ; } } for ( i = 0 ; i < SKIP_CONTEXTS ; ++ i ) <S2SV_StartBug> fc -> skip_probs [ i ] = adapt_prob ( pre_fc -> skip_probs [ i ] , counts -> skip [ i ] ) ; <S2SV_EndBug> }
","<S2SV_ModStart> * fc = <S2SV_ModEnd> cm -> fc <S2SV_ModStart> i ] = mode_mv_merge_probs <S2SV_ModEnd> ( pre_fc -> <S2SV_ModStart> i ] = mode_mv_merge_probs <S2SV_ModEnd> ( pre_fc -> <S2SV_ModStart> i ] = mode_mv_merge_probs <S2SV_ModEnd> ( pre_fc -> <S2SV_ModStart> j ] = mode_mv_merge_probs ( <S2SV_ModEnd> pre_fc -> single_ref_prob <S2SV_ModStart> i ++ ) vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_inter_mode_tree , <S2SV_ModStart> i ++ ) vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_intra_mode_tree , <S2SV_ModStart> ++ i ) vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_intra_mode_tree , <S2SV_ModStart> i ++ ) vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_partition_tree , <S2SV_ModStart> i ++ ) vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_switchable_interp_tree , <S2SV_ModStart> j ] = mode_mv_merge_probs ( <S2SV_ModEnd> pre_fc -> tx_probs <S2SV_ModStart> j ] = mode_mv_merge_probs ( <S2SV_ModEnd> pre_fc -> tx_probs <S2SV_ModStart> j ] = mode_mv_merge_probs ( <S2SV_ModEnd> pre_fc -> tx_probs <S2SV_ModStart> i ] = mode_mv_merge_probs ( <S2SV_ModEnd> pre_fc -> skip_probs
"
409,"CWE-476 int validate_as_request ( kdc_realm_t * kdc_active_realm , register krb5_kdc_req * request , krb5_db_entry client , krb5_db_entry server , krb5_timestamp kdc_time , const char * * status , krb5_pa_data * * * e_data ) { int errcode ; krb5_error_code ret ; if ( request -> kdc_options & AS_INVALID_OPTIONS ) { * status = ""INVALID<S2SV_blank>AS<S2SV_blank>OPTIONS"" ; return KDC_ERR_BADOPTION ; } if ( client . expiration && client . expiration < kdc_time ) { * status = ""CLIENT<S2SV_blank>EXPIRED"" ; if ( vague_errors ) return ( KRB_ERR_GENERIC ) ; else return ( KDC_ERR_NAME_EXP ) ; } if ( client . pw_expiration && client . pw_expiration < kdc_time && ! isflagset ( server . attributes , KRB5_KDB_PWCHANGE_SERVICE ) ) { * status = ""CLIENT<S2SV_blank>KEY<S2SV_blank>EXPIRED"" ; if ( vague_errors ) return ( KRB_ERR_GENERIC ) ; else return ( KDC_ERR_KEY_EXP ) ; } if ( server . expiration && server . expiration < kdc_time ) { * status = ""SERVICE<S2SV_blank>EXPIRED"" ; return ( KDC_ERR_SERVICE_EXP ) ; } if ( isflagset ( client . attributes , KRB5_KDB_REQUIRES_PWCHANGE ) && ! isflagset ( server . attributes , KRB5_KDB_PWCHANGE_SERVICE ) ) { * status = ""REQUIRED<S2SV_blank>PWCHANGE"" ; return ( KDC_ERR_KEY_EXP ) ; } if ( ( isflagset ( request -> kdc_options , KDC_OPT_ALLOW_POSTDATE ) || isflagset ( request -> kdc_options , KDC_OPT_POSTDATED ) ) && ( isflagset ( client . attributes , KRB5_KDB_DISALLOW_POSTDATED ) || isflagset ( server . attributes , KRB5_KDB_DISALLOW_POSTDATED ) ) ) { * status = ""POSTDATE<S2SV_blank>NOT<S2SV_blank>ALLOWED"" ; return ( KDC_ERR_CANNOT_POSTDATE ) ; } if ( isflagset ( request -> kdc_options , KDC_OPT_PROXIABLE ) && ( isflagset ( client . attributes , KRB5_KDB_DISALLOW_PROXIABLE ) || isflagset ( server . attributes , KRB5_KDB_DISALLOW_PROXIABLE ) ) ) { * status = ""PROXIABLE<S2SV_blank>NOT<S2SV_blank>ALLOWED"" ; return ( KDC_ERR_POLICY ) ; } if ( isflagset ( client . attributes , KRB5_KDB_DISALLOW_ALL_TIX ) ) { * status = ""CLIENT<S2SV_blank>LOCKED<S2SV_blank>OUT"" ; return ( KDC_ERR_CLIENT_REVOKED ) ; } if ( isflagset ( server . attributes , KRB5_KDB_DISALLOW_ALL_TIX ) ) { * status = ""SERVICE<S2SV_blank>LOCKED<S2SV_blank>OUT"" ; return ( KDC_ERR_S_PRINCIPAL_UNKNOWN ) ; } if ( isflagset ( server . attributes , KRB5_KDB_DISALLOW_SVR ) ) { * status = ""SERVICE<S2SV_blank>NOT<S2SV_blank>ALLOWED"" ; return ( KDC_ERR_MUST_USE_USER2USER ) ; } <S2SV_StartBug> if ( check_anon ( kdc_active_realm , request -> client , request -> server ) != 0 ) { <S2SV_EndBug> * status = ""ANONYMOUS<S2SV_blank>NOT<S2SV_blank>ALLOWED"" ; return ( KDC_ERR_POLICY ) ; } ret = krb5_db_check_policy_as ( kdc_context , request , & client , & server , kdc_time , status , e_data ) ; if ( ret && ret != KRB5_PLUGIN_OP_NOTSUPP ) return errcode_to_protocol ( ret ) ; errcode = against_local_policy_as ( request , client , server , kdc_time , status , e_data ) ; if ( errcode ) return errcode ; return 0 ; }
","<S2SV_ModStart> ( kdc_active_realm , client . princ <S2SV_ModEnd> , request ->
"
410,"CWE-119 static int decode_dds1 ( GetByteContext * gb , uint8_t * frame , int width , int height ) { const uint8_t * frame_start = frame ; const uint8_t * frame_end = frame + width * height ; int mask = 0x10000 , bitbuf = 0 ; int i , v , offset , count , segments ; segments = bytestream2_get_le16 ( gb ) ; while ( segments -- ) { if ( bytestream2_get_bytes_left ( gb ) < 2 ) return AVERROR_INVALIDDATA ; if ( mask == 0x10000 ) { bitbuf = bytestream2_get_le16u ( gb ) ; mask = 1 ; } if ( bitbuf & mask ) { v = bytestream2_get_le16 ( gb ) ; offset = ( v & 0x1FFF ) << 2 ; count = ( ( v >> 13 ) + 2 ) << 1 ; if ( frame - frame_start < offset || frame_end - frame < count * 2 + width ) return AVERROR_INVALIDDATA ; for ( i = 0 ; i < count ; i ++ ) { frame [ 0 ] = frame [ 1 ] = frame [ width ] = frame [ width + 1 ] = frame [ - offset ] ; frame += 2 ; } } else if ( bitbuf & ( mask << 1 ) ) { v = bytestream2_get_le16 ( gb ) * 2 ; if ( frame - frame_end < v ) return AVERROR_INVALIDDATA ; frame += v ; } else { <S2SV_StartBug> if ( frame_end - frame < width + 3 ) <S2SV_EndBug> return AVERROR_INVALIDDATA ; frame [ 0 ] = frame [ 1 ] = frame [ width ] = frame [ width + 1 ] = bytestream2_get_byte ( gb ) ; frame += 2 ; frame [ 0 ] = frame [ 1 ] = frame [ width ] = frame [ width + 1 ] = bytestream2_get_byte ( gb ) ; frame += 2 ; } mask <<= 2 ; } return 0 ; }
","<S2SV_ModStart> < width + 4 <S2SV_ModEnd> ) return AVERROR_INVALIDDATA
"
411,"CWE-119 static ssize_t macvtap_get_user ( struct macvtap_queue * q , struct msghdr * m , const struct iovec * iv , unsigned long total_len , size_t count , int noblock ) { struct sk_buff * skb ; struct macvlan_dev * vlan ; unsigned long len = total_len ; int err ; struct virtio_net_hdr vnet_hdr = { 0 } ; int vnet_hdr_len = 0 ; <S2SV_StartBug> int copylen ; <S2SV_EndBug> bool zerocopy = false ; if ( q -> flags & IFF_VNET_HDR ) { vnet_hdr_len = q -> vnet_hdr_sz ; err = - EINVAL ; if ( len < vnet_hdr_len ) goto err ; len -= vnet_hdr_len ; err = memcpy_fromiovecend ( ( void * ) & vnet_hdr , iv , 0 , sizeof ( vnet_hdr ) ) ; if ( err < 0 ) goto err ; if ( ( vnet_hdr . flags & VIRTIO_NET_HDR_F_NEEDS_CSUM ) && vnet_hdr . csum_start + vnet_hdr . csum_offset + 2 > vnet_hdr . hdr_len ) vnet_hdr . hdr_len = vnet_hdr . csum_start + vnet_hdr . csum_offset + 2 ; err = - EINVAL ; if ( vnet_hdr . hdr_len > len ) goto err ; } err = - EINVAL ; if ( unlikely ( len < ETH_HLEN ) ) goto err ; <S2SV_StartBug> if ( m && m -> msg_control && sock_flag ( & q -> sk , SOCK_ZEROCOPY ) ) <S2SV_EndBug> zerocopy = true ; if ( zerocopy ) { <S2SV_StartBug> copylen = vnet_hdr . hdr_len ; <S2SV_EndBug> if ( ! copylen ) copylen = GOODCOPY_LEN ; } else copylen = len ; skb = macvtap_alloc_skb ( & q -> sk , NET_IP_ALIGN , copylen , vnet_hdr . hdr_len , noblock , & err ) ; if ( ! skb ) goto err ; if ( zerocopy ) err = zerocopy_sg_from_iovec ( skb , iv , vnet_hdr_len , count ) ; else err = skb_copy_datagram_from_iovec ( skb , 0 , iv , vnet_hdr_len , len ) ; if ( err ) goto err_kfree ; skb_set_network_header ( skb , ETH_HLEN ) ; skb_reset_mac_header ( skb ) ; skb -> protocol = eth_hdr ( skb ) -> h_proto ; if ( vnet_hdr_len ) { err = macvtap_skb_from_vnet_hdr ( skb , & vnet_hdr ) ; if ( err ) goto err_kfree ; } rcu_read_lock_bh ( ) ; vlan = rcu_dereference_bh ( q -> vlan ) ; if ( zerocopy ) { skb_shinfo ( skb ) -> destructor_arg = m -> msg_control ; skb_shinfo ( skb ) -> tx_flags |= SKBTX_DEV_ZEROCOPY ; } if ( vlan ) macvlan_start_xmit ( skb , vlan -> dev ) ; else kfree_skb ( skb ) ; rcu_read_unlock_bh ( ) ; return total_len ; err_kfree : kfree_skb ( skb ) ; err : rcu_read_lock_bh ( ) ; vlan = rcu_dereference_bh ( q -> vlan ) ; if ( vlan ) vlan -> dev -> stats . tx_dropped ++ ; rcu_read_unlock_bh ( ) ; return err ; }
","<S2SV_ModStart> ; int copylen = 0 <S2SV_ModStart> goto err ; err = - EMSGSIZE ; if ( unlikely ( count > UIO_MAXIOV ) ) goto err ; <S2SV_ModStart> zerocopy ) { if ( count > MAX_SKB_FRAGS ) { copylen = iov_length ( iv , count - MAX_SKB_FRAGS ) ; if ( copylen < vnet_hdr_len ) copylen = 0 ; else copylen -= vnet_hdr_len ; } if ( copylen < vnet_hdr . hdr_len )
"
412,"CWE-264 <S2SV_StartBug> static bool do_write_pids ( pid_t tpid , const char * contrl , const char * cg , const char * file , const char * buf ) <S2SV_EndBug> { int sock [ 2 ] = { - 1 , - 1 } ; pid_t qpid , cpid = - 1 ; FILE * pids_file = NULL ; bool answer = false , fail = false ; pids_file = open_pids_file ( contrl , cg ) ; if ( ! pids_file ) return false ; if ( socketpair ( AF_UNIX , SOCK_DGRAM , 0 , sock ) < 0 ) { perror ( ""socketpair"" ) ; goto out ; } cpid = fork ( ) ; if ( cpid == - 1 ) goto out ; if ( ! cpid ) { fclose ( pids_file ) ; pid_from_ns_wrapper ( sock [ 1 ] , tpid ) ; } const char * ptr = buf ; while ( sscanf ( ptr , ""%d"" , & qpid ) == 1 ) { struct ucred cred ; char v ; if ( write ( sock [ 0 ] , & qpid , sizeof ( qpid ) ) != sizeof ( qpid ) ) { fprintf ( stderr , ""%s:<S2SV_blank>error<S2SV_blank>writing<S2SV_blank>pid<S2SV_blank>to<S2SV_blank>child:<S2SV_blank>%s\\n"" , __func__ , strerror ( errno ) ) ; goto out ; } if ( recv_creds ( sock [ 0 ] , & cred , & v ) ) { if ( v == '0' ) { <S2SV_StartBug> if ( fprintf ( pids_file , ""%d"" , ( int ) cred . pid ) < 0 ) <S2SV_EndBug> fail = true ; } } ptr = strchr ( ptr , '\\n' ) ; if ( ! ptr ) break ; ptr ++ ; } qpid = - 1 ; if ( write ( sock [ 0 ] , & qpid , sizeof ( qpid ) ) != sizeof ( qpid ) ) fprintf ( stderr , ""Warning:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ask<S2SV_blank>child<S2SV_blank>to<S2SV_blank>exit\\n"" ) ; if ( ! fail ) answer = true ; out : if ( cpid != - 1 ) wait_for_pid ( cpid ) ; if ( sock [ 0 ] != - 1 ) { close ( sock [ 0 ] ) ; close ( sock [ 1 ] ) ; } if ( pids_file ) { if ( fclose ( pids_file ) != 0 ) answer = false ; } return answer ; }
","<S2SV_ModStart> pid_t tpid , uid_t tuid , <S2SV_ModStart> { if ( ! may_move_pid ( tpid , tuid , <S2SV_ModEnd> cred . pid <S2SV_ModStart> . pid ) ) { fail = true ; break ; } if ( fprintf ( pids_file , ""%d"" , ( int ) cred . pid )
"
413,"CWE-401 struct clock_source * dcn10_clock_source_create ( struct dc_context * ctx , struct dc_bios * bios , enum clock_source_id id , const struct dce110_clk_src_regs * regs , bool dp_clk_src ) { struct dce110_clk_src * clk_src = kzalloc ( sizeof ( struct dce110_clk_src ) , GFP_KERNEL ) ; if ( ! clk_src ) return NULL ; if ( dce112_clk_src_construct ( clk_src , ctx , bios , id , regs , & cs_shift , & cs_mask ) ) { clk_src -> base . dp_clk_src = dp_clk_src ; return & clk_src -> base ; } <S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug> return NULL ; }
","<S2SV_ModStart> base ; } kfree ( clk_src ) ;
"
414,"CWE-119 static void set_entropy_context_b ( int plane , int block , BLOCK_SIZE plane_bsize , TX_SIZE tx_size , void * arg ) { struct tokenize_b_args * const args = arg ; <S2SV_StartBug> MACROBLOCKD * const xd = args -> xd ; <S2SV_EndBug> <S2SV_StartBug> struct macroblock_plane * p = & args -> cpi -> mb . plane [ plane ] ; <S2SV_EndBug> struct macroblockd_plane * pd = & xd -> plane [ plane ] ; int aoff , loff ; txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & aoff , & loff ) ; vp9_set_contexts ( xd , pd , plane_bsize , tx_size , p -> eobs [ block ] > 0 , aoff , loff ) ; }
","<S2SV_ModStart> = arg ; ThreadData * const td = args -> td ; MACROBLOCK * const x = & td -> mb ; <S2SV_ModStart> const xd = & x -> e_mbd <S2SV_ModEnd> ; struct macroblock_plane <S2SV_ModStart> p = & x -> <S2SV_ModEnd> plane [ plane
"
415,"CWE-119 void WT_VoiceGain ( S_WT_VOICE * pWTVoice , S_WT_INT_FRAME * pWTIntFrame ) { EAS_I32 * pMixBuffer ; EAS_PCM * pInputBuffer ; EAS_I32 gain ; EAS_I32 gainIncrement ; EAS_I32 tmp0 ; EAS_I32 tmp1 ; EAS_I32 tmp2 ; EAS_I32 numSamples ; # if ( NUM_OUTPUT_CHANNELS == 2 ) EAS_I32 gainLeft , gainRight ; # endif numSamples = pWTIntFrame -> numSamples ; if ( numSamples <= 0 ) { <S2SV_StartBug> ALOGE ( ""b/26366256"" ) ; <S2SV_EndBug> return ; } pMixBuffer = pWTIntFrame -> pMixBuffer ; pInputBuffer = pWTIntFrame -> pAudioBuffer ; gainIncrement = ( pWTIntFrame -> frame . gainTarget - pWTIntFrame -> prevGain ) << ( 16 - SYNTH_UPDATE_PERIOD_IN_BITS ) ; if ( gainIncrement < 0 ) gainIncrement ++ ; gain = pWTIntFrame -> prevGain << 16 ; # if ( NUM_OUTPUT_CHANNELS == 2 ) gainLeft = pWTVoice -> gainLeft ; gainRight = pWTVoice -> gainRight ; # endif while ( numSamples -- ) { tmp0 = * pInputBuffer ++ ; gain += gainIncrement ; tmp2 = gain >> 16 ; tmp2 *= tmp0 ; # if ( NUM_OUTPUT_CHANNELS == 2 ) tmp2 = tmp2 >> 14 ; tmp1 = * pMixBuffer ; tmp0 = tmp2 * gainLeft ; tmp0 = tmp0 >> NUM_MIXER_GUARD_BITS ; tmp1 += tmp0 ; * pMixBuffer ++ = tmp1 ; tmp1 = * pMixBuffer ; tmp0 = tmp2 * gainRight ; tmp0 = tmp0 >> NUM_MIXER_GUARD_BITS ; tmp1 += tmp0 ; * pMixBuffer ++ = tmp1 ; # else tmp1 = * pMixBuffer ; tmp2 = tmp2 >> ( NUM_MIXER_GUARD_BITS - 1 ) ; tmp1 += tmp2 ; * pMixBuffer ++ = tmp1 ; # endif } }
","<S2SV_ModStart> ALOGE ( ""b/26366256"" ) ; android_errorWriteLog ( 0x534e4554 , ""26366256""
"
416,"CWE-200 static void set_orig_addr ( struct msghdr * m , struct tipc_msg * msg ) { struct sockaddr_tipc * addr = ( struct sockaddr_tipc * ) m -> msg_name ; if ( addr ) { addr -> family = AF_TIPC ; <S2SV_StartBug> addr -> addrtype = TIPC_ADDR_ID ; <S2SV_EndBug> addr -> addr . id . ref = msg_origport ( msg ) ; addr -> addr . id . node = msg_orignode ( msg ) ; addr -> addr . name . domain = 0 ; addr -> scope = 0 ; m -> msg_namelen = sizeof ( struct sockaddr_tipc ) ; } }
","<S2SV_ModStart> addrtype = TIPC_ADDR_ID ; memset ( & addr -> addr , 0 , sizeof ( addr -> addr ) )
"
417,"CWE-400 static int xen_evtchn_cpu_prepare ( unsigned int cpu ) { <S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> if ( evtchn_ops -> percpu_init ) ret = evtchn_ops -> percpu_init ( cpu ) ; return ret ; }
","<S2SV_ModStart> ret = 0 ; xen_cpu_init_eoi ( cpu )
"
418,"CWE-189 static long pmcraid_ioctl_passthrough ( struct pmcraid_instance * pinstance , unsigned int ioctl_cmd , unsigned int buflen , unsigned long arg ) { struct pmcraid_passthrough_ioctl_buffer * buffer ; struct pmcraid_ioarcb * ioarcb ; struct pmcraid_cmd * cmd ; struct pmcraid_cmd * cancel_cmd ; unsigned long request_buffer ; unsigned long request_offset ; unsigned long lock_flags ; void * ioasa ; u32 ioasc ; int request_size ; int buffer_size ; u8 access , direction ; int rc = 0 ; if ( pinstance -> ioa_reset_in_progress ) { rc = wait_event_interruptible_timeout ( pinstance -> reset_wait_q , ! pinstance -> ioa_reset_in_progress , msecs_to_jiffies ( 10000 ) ) ; if ( ! rc ) return - ETIMEDOUT ; else if ( rc < 0 ) return - ERESTARTSYS ; } if ( pinstance -> ioa_state != IOA_STATE_OPERATIONAL ) { pmcraid_err ( ""IOA<S2SV_blank>is<S2SV_blank>not<S2SV_blank>operational\\n"" ) ; return - ENOTTY ; } buffer_size = sizeof ( struct pmcraid_passthrough_ioctl_buffer ) ; buffer = kmalloc ( buffer_size , GFP_KERNEL ) ; if ( ! buffer ) { pmcraid_err ( ""no<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>passthrough<S2SV_blank>buffer\\n"" ) ; return - ENOMEM ; } request_offset = offsetof ( struct pmcraid_passthrough_ioctl_buffer , request_buffer ) ; request_buffer = arg + request_offset ; rc = __copy_from_user ( buffer , ( struct pmcraid_passthrough_ioctl_buffer * ) arg , sizeof ( struct pmcraid_passthrough_ioctl_buffer ) ) ; ioasa = ( void * ) ( arg + offsetof ( struct pmcraid_passthrough_ioctl_buffer , ioasa ) ) ; if ( rc ) { pmcraid_err ( ""ioctl:<S2SV_blank>can\'t<S2SV_blank>copy<S2SV_blank>passthrough<S2SV_blank>buffer\\n"" ) ; rc = - EFAULT ; goto out_free_buffer ; } request_size = buffer -> ioarcb . data_transfer_length ; if ( buffer -> ioarcb . request_flags0 & TRANSFER_DIR_WRITE ) { access = VERIFY_READ ; direction = DMA_TO_DEVICE ; } else { access = VERIFY_WRITE ; direction = DMA_FROM_DEVICE ; } if ( request_size > 0 ) { rc = access_ok ( access , arg , request_offset + request_size ) ; if ( ! rc ) { rc = - EFAULT ; goto out_free_buffer ; } } else if ( request_size < 0 ) { rc = - EINVAL ; goto out_free_buffer ; } if ( buffer -> ioarcb . add_cmd_param_length > PMCRAID_ADD_CMD_PARAM_LEN ) { rc = - EINVAL ; goto out_free_buffer ; } cmd = pmcraid_get_free_cmd ( pinstance ) ; if ( ! cmd ) { pmcraid_err ( ""free<S2SV_blank>command<S2SV_blank>block<S2SV_blank>is<S2SV_blank>not<S2SV_blank>available\\n"" ) ; rc = - ENOMEM ; goto out_free_buffer ; } cmd -> scsi_cmd = NULL ; ioarcb = & ( cmd -> ioa_cb -> ioarcb ) ; ioarcb -> resource_handle = buffer -> ioarcb . resource_handle ; ioarcb -> data_transfer_length = buffer -> ioarcb . data_transfer_length ; ioarcb -> cmd_timeout = buffer -> ioarcb . cmd_timeout ; ioarcb -> request_type = buffer -> ioarcb . request_type ; ioarcb -> request_flags0 = buffer -> ioarcb . request_flags0 ; ioarcb -> request_flags1 = buffer -> ioarcb . request_flags1 ; memcpy ( ioarcb -> cdb , buffer -> ioarcb . cdb , PMCRAID_MAX_CDB_LEN ) ; if ( buffer -> ioarcb . add_cmd_param_length ) { ioarcb -> add_cmd_param_length = buffer -> ioarcb . add_cmd_param_length ; ioarcb -> add_cmd_param_offset = buffer -> ioarcb . add_cmd_param_offset ; memcpy ( ioarcb -> add_data . u . add_cmd_params , buffer -> ioarcb . add_data . u . add_cmd_params , buffer -> ioarcb . add_cmd_param_length ) ; } ioarcb -> hrrq_id = atomic_add_return ( 1 , & ( pinstance -> last_message_id ) ) % pinstance -> num_hrrq ; if ( request_size ) { rc = pmcraid_build_passthrough_ioadls ( cmd , request_size , direction ) ; if ( rc ) { pmcraid_err ( ""couldn\'t<S2SV_blank>build<S2SV_blank>passthrough<S2SV_blank>ioadls\\n"" ) ; goto out_free_buffer ; <S2SV_StartBug> } <S2SV_EndBug> } if ( direction == DMA_TO_DEVICE && request_size > 0 ) { rc = pmcraid_copy_sglist ( cmd -> sglist , request_buffer , request_size , direction ) ; if ( rc ) { pmcraid_err ( ""failed<S2SV_blank>to<S2SV_blank>copy<S2SV_blank>user<S2SV_blank>buffer\\n"" ) ; goto out_free_sglist ; } } cmd -> cmd_done = pmcraid_internal_done ; init_completion ( & cmd -> wait_for_completion ) ; cmd -> completion_req = 1 ; pmcraid_info ( ""command(%d)<S2SV_blank>(CDB[0]<S2SV_blank>=<S2SV_blank>%x)<S2SV_blank>for<S2SV_blank>%x\\n"" , le32_to_cpu ( cmd -> ioa_cb -> ioarcb . response_handle ) >> 2 , cmd -> ioa_cb -> ioarcb . cdb [ 0 ] , le32_to_cpu ( cmd -> ioa_cb -> ioarcb . resource_handle ) ) ; spin_lock_irqsave ( pinstance -> host -> host_lock , lock_flags ) ; _pmcraid_fire_command ( cmd ) ; spin_unlock_irqrestore ( pinstance -> host -> host_lock , lock_flags ) ; buffer -> ioarcb . cmd_timeout = 0 ; if ( buffer -> ioarcb . cmd_timeout == 0 ) { wait_for_completion ( & cmd -> wait_for_completion ) ; } else if ( ! wait_for_completion_timeout ( & cmd -> wait_for_completion , msecs_to_jiffies ( buffer -> ioarcb . cmd_timeout * 1000 ) ) ) { pmcraid_info ( ""aborting<S2SV_blank>cmd<S2SV_blank>%d<S2SV_blank>(CDB[0]<S2SV_blank>=<S2SV_blank>%x)<S2SV_blank>due<S2SV_blank>to<S2SV_blank>timeout\\n"" , le32_to_cpu ( cmd -> ioa_cb -> ioarcb . response_handle >> 2 ) , cmd -> ioa_cb -> ioarcb . cdb [ 0 ] ) ; spin_lock_irqsave ( pinstance -> host -> host_lock , lock_flags ) ; cancel_cmd = pmcraid_abort_cmd ( cmd ) ; spin_unlock_irqrestore ( pinstance -> host -> host_lock , lock_flags ) ; if ( cancel_cmd ) { wait_for_completion ( & cancel_cmd -> wait_for_completion ) ; ioasc = cancel_cmd -> ioa_cb -> ioasa . ioasc ; pmcraid_return_cmd ( cancel_cmd ) ; if ( ioasc == PMCRAID_IOASC_IOA_WAS_RESET || PMCRAID_IOASC_SENSE_KEY ( ioasc ) == 0x00 ) { if ( ioasc != PMCRAID_IOASC_GC_IOARCB_NOTFOUND ) rc = - ETIMEDOUT ; goto out_handle_response ; } } if ( ! wait_for_completion_timeout ( & cmd -> wait_for_completion , msecs_to_jiffies ( 150 * 1000 ) ) ) { pmcraid_reset_bringup ( cmd -> drv_inst ) ; rc = - ETIMEDOUT ; } } out_handle_response : if ( copy_to_user ( ioasa , & cmd -> ioa_cb -> ioasa , sizeof ( struct pmcraid_ioasa ) ) ) { pmcraid_err ( ""failed<S2SV_blank>to<S2SV_blank>copy<S2SV_blank>ioasa<S2SV_blank>buffer<S2SV_blank>to<S2SV_blank>user\\n"" ) ; rc = - EFAULT ; } else if ( direction == DMA_FROM_DEVICE && request_size > 0 ) { rc = pmcraid_copy_sglist ( cmd -> sglist , request_buffer , request_size , direction ) ; if ( rc ) { pmcraid_err ( ""failed<S2SV_blank>to<S2SV_blank>copy<S2SV_blank>user<S2SV_blank>buffer\\n"" ) ; rc = - EFAULT ; } } out_free_sglist : pmcraid_release_passthrough_ioadls ( cmd , request_size , direction ) ; pmcraid_return_cmd ( cmd ) ; out_free_buffer : kfree ( buffer ) ; return rc ; }
","<S2SV_ModStart> out_free_buffer ; } } else if ( request_size < 0 ) { rc = - EINVAL ; goto out_free_buffer ;
"
419,"CWE-772 generic_ret * chpass_principal_2_svc ( chpass_arg * arg , struct svc_req * rqstp ) { static generic_ret ret ; char * prime_arg ; <S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_generic_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> princ , & prime_arg ) ) { ret . code = KADM5_BAD_PRINCIPAL ; goto exit_func ; } if ( cmp_gss_krb5_name ( handle , rqst2name ( rqstp ) , arg -> princ ) ) { ret . code = chpass_principal_wrapper_3 ( ( void * ) handle , arg -> princ , FALSE , 0 , NULL , arg -> pass ) ; } else if ( ! ( CHANGEPW_SERVICE ( rqstp ) ) && kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_CHANGEPW , arg -> princ , NULL ) ) { ret . code = kadm5_chpass_principal ( ( void * ) handle , arg -> princ , arg -> pass ) ; } else { log_unauth ( ""kadm5_chpass_principal"" , prime_arg , & client_name , & service_name , rqstp ) ; ret . code = KADM5_AUTH_CHANGEPW ; } if ( ret . code != KADM5_AUTH_CHANGEPW ) { if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( ""kadm5_chpass_principal"" , prime_arg , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } free ( prime_arg ) ; <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> gss_release_buffer ( & minor_stat , & service_name ) ; exit_func : free_server_handle ( handle ) ; return & ret ; }
","<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> prime_arg ) ; exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
"
420,"CWE-908 static int kvaser_usb_leaf_set_opt_mode ( const struct kvaser_usb_net_priv * priv ) { struct kvaser_cmd * cmd ; int rc ; <S2SV_StartBug> cmd = kmalloc ( sizeof ( * cmd ) , GFP_KERNEL ) ; <S2SV_EndBug> if ( ! cmd ) return - ENOMEM ; cmd -> id = CMD_SET_CTRL_MODE ; cmd -> len = CMD_HEADER_LEN + sizeof ( struct kvaser_cmd_ctrl_mode ) ; cmd -> u . ctrl_mode . tid = 0xff ; cmd -> u . ctrl_mode . channel = priv -> channel ; if ( priv -> can . ctrlmode & CAN_CTRLMODE_LISTENONLY ) cmd -> u . ctrl_mode . ctrl_mode = KVASER_CTRL_MODE_SILENT ; else cmd -> u . ctrl_mode . ctrl_mode = KVASER_CTRL_MODE_NORMAL ; rc = kvaser_usb_send_cmd ( priv -> dev , cmd , cmd -> len ) ; kfree ( cmd ) ; return rc ; }
","<S2SV_ModStart> ; cmd = kzalloc <S2SV_ModEnd> ( sizeof (
"
421,"CWE-200 static int sco_sock_bind ( struct socket * sock , struct sockaddr * addr , int addr_len ) { struct sockaddr_sco * sa = ( struct sockaddr_sco * ) addr ; struct sock * sk = sock -> sk ; int err = 0 ; BT_DBG ( ""sk<S2SV_blank>%p<S2SV_blank>%pMR"" , sk , & sa -> sco_bdaddr ) ; <S2SV_StartBug> if ( ! addr || addr -> sa_family != AF_BLUETOOTH ) <S2SV_EndBug> return - EINVAL ; lock_sock ( sk ) ; if ( sk -> sk_state != BT_OPEN ) { err = - EBADFD ; goto done ; } if ( sk -> sk_type != SOCK_SEQPACKET ) { err = - EINVAL ; goto done ; } bacpy ( & sco_pi ( sk ) -> src , & sa -> sco_bdaddr ) ; sk -> sk_state = BT_BOUND ; done : release_sock ( sk ) ; return err ; }
","<S2SV_ModStart> sa_family != AF_BLUETOOTH ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_sco )
"
422,"CWE-404 int nfsd_cross_mnt ( struct svc_rqst * rqstp , struct dentry * * dpp , struct svc_export * * expp ) { struct svc_export * exp = * expp , * exp2 = NULL ; struct dentry * dentry = * dpp ; struct path path = { . mnt = mntget ( exp -> ex_path . mnt ) , . dentry = dget ( dentry ) } ; int err = 0 ; err = follow_down ( & path ) ; if ( err < 0 ) <S2SV_StartBug> goto out ; <S2SV_EndBug> exp2 = rqst_exp_get_by_name ( rqstp , & path ) ; if ( IS_ERR ( exp2 ) ) { err = PTR_ERR ( exp2 ) ; if ( err == - ENOENT && ! ( exp -> ex_flags & NFSEXP_V4ROOT ) ) err = 0 ; path_put ( & path ) ; goto out ; } if ( nfsd_v4client ( rqstp ) || ( exp -> ex_flags & NFSEXP_CROSSMOUNT ) || EX_NOHIDE ( exp2 ) ) { * dpp = path . dentry ; path . dentry = dentry ; * expp = exp2 ; exp2 = exp ; } path_put ( & path ) ; exp_put ( exp2 ) ; out : return err ; }
","<S2SV_ModStart> goto out ; if ( path . mnt == exp -> ex_path . mnt && path . dentry == dentry && nfsd_mountpoint ( dentry , exp ) == 2 ) { path_put ( & path ) ; goto out ; }
"
423,"CWE-119 static void videobuf_vm_open ( struct vm_area_struct * vma ) { struct videobuf_mapping * map = vma -> vm_private_data ; <S2SV_StartBug> dprintk ( 2 , ""vm_open<S2SV_blank>%p<S2SV_blank>[count=%d,vma=%08lx-%08lx]\\n"" , map , <S2SV_EndBug> map -> count , vma -> vm_start , vma -> vm_end ) ; map -> count ++ ; }
","<S2SV_ModStart> ( 2 , ""vm_open<S2SV_blank>%p<S2SV_blank>[count=%u,vma=%08lx-%08lx]\\n"" <S2SV_ModEnd> , map ,
"
424,"CWE-74 gboolean flatpak_run_add_environment_args ( FlatpakBwrap * bwrap , const char * app_info_path , FlatpakRunFlags flags , const char * app_id , FlatpakContext * context , GFile * app_id_dir , GPtrArray * previous_app_id_dirs , FlatpakExports * * exports_out , GCancellable * cancellable , GError * * error ) { g_autoptr ( GError ) my_error = NULL ; g_autoptr ( FlatpakExports ) exports = NULL ; g_autoptr ( FlatpakBwrap ) proxy_arg_bwrap = flatpak_bwrap_new ( flatpak_bwrap_empty_env ) ; gboolean has_wayland = FALSE ; gboolean allow_x11 = FALSE ; if ( ( context -> shares & FLATPAK_CONTEXT_SHARED_IPC ) == 0 ) { g_debug ( ""Disallowing<S2SV_blank>ipc<S2SV_blank>access"" ) ; flatpak_bwrap_add_args ( bwrap , ""--unshare-ipc"" , NULL ) ; } if ( ( context -> shares & FLATPAK_CONTEXT_SHARED_NETWORK ) == 0 ) { g_debug ( ""Disallowing<S2SV_blank>network<S2SV_blank>access"" ) ; flatpak_bwrap_add_args ( bwrap , ""--unshare-net"" , NULL ) ; } if ( context -> devices & FLATPAK_CONTEXT_DEVICE_ALL ) { flatpak_bwrap_add_args ( bwrap , ""--dev-bind"" , ""/dev"" , ""/dev"" , NULL ) ; if ( g_file_test ( ""/dev/shm"" , G_FILE_TEST_IS_DIR ) ) { if ( ( context -> devices & FLATPAK_CONTEXT_DEVICE_SHM ) == 0 ) flatpak_bwrap_add_args ( bwrap , ""--tmpfs"" , ""/dev/shm"" , NULL ) ; } else if ( g_file_test ( ""/dev/shm"" , G_FILE_TEST_IS_SYMLINK ) ) { g_autofree char * link = flatpak_readlink ( ""/dev/shm"" , NULL ) ; if ( g_strcmp0 ( link , ""/run/shm"" ) == 0 ) { if ( context -> devices & FLATPAK_CONTEXT_DEVICE_SHM && g_file_test ( ""/run/shm"" , G_FILE_TEST_IS_DIR ) ) flatpak_bwrap_add_args ( bwrap , ""--bind"" , ""/run/shm"" , ""/run/shm"" , NULL ) ; else flatpak_bwrap_add_args ( bwrap , ""--dir"" , ""/run/shm"" , NULL ) ; } else g_warning ( ""Unexpected<S2SV_blank>/dev/shm<S2SV_blank>symlink<S2SV_blank>%s"" , link ) ; } } else { flatpak_bwrap_add_args ( bwrap , ""--dev"" , ""/dev"" , NULL ) ; if ( context -> devices & FLATPAK_CONTEXT_DEVICE_DRI ) { g_debug ( ""Allowing<S2SV_blank>dri<S2SV_blank>access"" ) ; int i ; char * dri_devices [ ] = { ""/dev/dri"" , ""/dev/mali"" , ""/dev/mali0"" , ""/dev/umplock"" , ""/dev/nvidiactl"" , ""/dev/nvidia-modeset"" , ""/dev/nvidia-uvm"" , ""/dev/nvidia-uvm-tools"" , } ; for ( i = 0 ; i < G_N_ELEMENTS ( dri_devices ) ; i ++ ) { if ( g_file_test ( dri_devices [ i ] , G_FILE_TEST_EXISTS ) ) flatpak_bwrap_add_args ( bwrap , ""--dev-bind"" , dri_devices [ i ] , dri_devices [ i ] , NULL ) ; } char nvidia_dev [ 14 ] ; for ( i = 0 ; i < 20 ; i ++ ) { g_snprintf ( nvidia_dev , sizeof ( nvidia_dev ) , ""/dev/nvidia%d"" , i ) ; if ( g_file_test ( nvidia_dev , G_FILE_TEST_EXISTS ) ) flatpak_bwrap_add_args ( bwrap , ""--dev-bind"" , nvidia_dev , nvidia_dev , NULL ) ; } } if ( context -> devices & FLATPAK_CONTEXT_DEVICE_KVM ) { g_debug ( ""Allowing<S2SV_blank>kvm<S2SV_blank>access"" ) ; if ( g_file_test ( ""/dev/kvm"" , G_FILE_TEST_EXISTS ) ) flatpak_bwrap_add_args ( bwrap , ""--dev-bind"" , ""/dev/kvm"" , ""/dev/kvm"" , NULL ) ; } if ( context -> devices & FLATPAK_CONTEXT_DEVICE_SHM ) { g_autofree char * real_dev_shm = realpath ( ""/dev/shm"" , NULL ) ; g_debug ( ""Allowing<S2SV_blank>/dev/shm<S2SV_blank>access<S2SV_blank>(as<S2SV_blank>%s)"" , real_dev_shm ) ; if ( real_dev_shm != NULL ) flatpak_bwrap_add_args ( bwrap , ""--bind"" , real_dev_shm , ""/dev/shm"" , NULL ) ; } } flatpak_context_append_bwrap_filesystem ( context , bwrap , app_id , app_id_dir , previous_app_id_dirs , & exports ) ; if ( context -> sockets & FLATPAK_CONTEXT_SOCKET_WAYLAND ) { g_debug ( ""Allowing<S2SV_blank>wayland<S2SV_blank>access"" ) ; has_wayland = flatpak_run_add_wayland_args ( bwrap ) ; } if ( ( context -> sockets & FLATPAK_CONTEXT_SOCKET_FALLBACK_X11 ) != 0 ) allow_x11 = ! has_wayland ; else allow_x11 = ( context -> sockets & FLATPAK_CONTEXT_SOCKET_X11 ) != 0 ; flatpak_run_add_x11_args ( bwrap , allow_x11 ) ; if ( context -> sockets & FLATPAK_CONTEXT_SOCKET_SSH_AUTH ) { flatpak_run_add_ssh_args ( bwrap ) ; } if ( context -> sockets & FLATPAK_CONTEXT_SOCKET_PULSEAUDIO ) { g_debug ( ""Allowing<S2SV_blank>pulseaudio<S2SV_blank>access"" ) ; flatpak_run_add_pulseaudio_args ( bwrap ) ; } if ( context -> sockets & FLATPAK_CONTEXT_SOCKET_PCSC ) { flatpak_run_add_pcsc_args ( bwrap ) ; } if ( context -> sockets & FLATPAK_CONTEXT_SOCKET_CUPS ) { flatpak_run_add_cups_args ( bwrap ) ; } flatpak_run_add_session_dbus_args ( bwrap , proxy_arg_bwrap , context , flags , app_id ) ; flatpak_run_add_system_dbus_args ( bwrap , proxy_arg_bwrap , context , flags ) ; flatpak_run_add_a11y_dbus_args ( bwrap , proxy_arg_bwrap , context , flags ) ; <S2SV_StartBug> if ( g_environ_getenv ( bwrap -> envp , ""LD_LIBRARY_PATH"" ) != NULL ) <S2SV_EndBug> { flatpak_bwrap_add_args ( bwrap , ""--setenv"" , ""LD_LIBRARY_PATH"" , g_environ_getenv ( bwrap -> envp , ""LD_LIBRARY_PATH"" ) , NULL ) ; flatpak_bwrap_unset_env ( bwrap , ""LD_LIBRARY_PATH"" ) ; } if ( g_environ_getenv ( bwrap -> envp , ""TMPDIR"" ) != NULL ) { flatpak_bwrap_add_args ( bwrap , ""--setenv"" , ""TMPDIR"" , g_environ_getenv ( bwrap -> envp , ""TMPDIR"" ) , NULL ) ; flatpak_bwrap_unset_env ( bwrap , ""TMPDIR"" ) ; } if ( ! flatpak_run_in_transient_unit ( app_id , & my_error ) ) { g_debug ( ""Failed<S2SV_blank>to<S2SV_blank>run<S2SV_blank>in<S2SV_blank>transient<S2SV_blank>scope:<S2SV_blank>%s"" , my_error -> message ) ; g_clear_error ( & my_error ) ; } if ( ! flatpak_bwrap_is_empty ( proxy_arg_bwrap ) && ! start_dbus_proxy ( bwrap , proxy_arg_bwrap , app_info_path , error ) ) return FALSE ; if ( exports_out ) * exports_out = g_steal_pointer ( & exports ) ; return TRUE ; }
","<S2SV_ModStart> ; if ( <S2SV_ModEnd> ! flatpak_run_in_transient_unit (
"
425,"CWE-404 static int omninet_open ( struct tty_struct * tty , struct usb_serial_port * port ) { <S2SV_StartBug> struct usb_serial * serial = port -> serial ; <S2SV_EndBug> struct usb_serial_port * wport ; wport = serial -> port [ 1 ] ; tty_port_tty_set ( & wport -> port , tty ) ; return usb_serial_generic_open ( tty , port ) ; }
","<S2SV_ModStart> port ) { <S2SV_ModEnd> return usb_serial_generic_open (
"
426,"CWE-000 static void sas_init_port ( struct asd_sas_port * port , struct sas_ha_struct * sas_ha , int i ) { memset ( port , 0 , sizeof ( * port ) ) ; port -> id = i ; INIT_LIST_HEAD ( & port -> dev_list ) ; INIT_LIST_HEAD ( & port -> disco_list ) ; INIT_LIST_HEAD ( & port -> destroy_list ) ; <S2SV_StartBug> spin_lock_init ( & port -> phy_list_lock ) ; <S2SV_EndBug> INIT_LIST_HEAD ( & port -> phy_list ) ; port -> ha = sas_ha ; spin_lock_init ( & port -> dev_list_lock ) ; }
","<S2SV_ModStart> destroy_list ) ; INIT_LIST_HEAD ( & port -> sas_port_del_list ) ;
"
427,"CWE-611 <S2SV_StartBug> int xml_init ( modsec_rec * msr , char * * error_msg ) { <S2SV_EndBug> if ( error_msg == NULL ) return - 1 ; * error_msg = NULL ; msr -> xml = apr_pcalloc ( msr -> mp , sizeof ( xml_data ) ) ; if ( msr -> xml == NULL ) return - 1 ; <S2SV_StartBug> return 1 ; <S2SV_EndBug> }
","<S2SV_ModStart> error_msg ) { xmlParserInputBufferCreateFilenameFunc entity ; <S2SV_ModStart> - 1 ; if ( msr -> txcfg -> xml_external_entity == 0 ) { entity = xmlParserInputBufferCreateFilenameDefault ( xml_unload_external_entity ) ; }
"
428,"CWE-264 static int encrypted_update ( struct key * key , struct key_preparsed_payload * prep ) { struct encrypted_key_payload * epayload = key -> payload . data [ 0 ] ; struct encrypted_key_payload * new_epayload ; char * buf ; char * new_master_desc = NULL ; const char * format = NULL ; size_t datalen = prep -> datalen ; <S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> if ( datalen <= 0 || datalen > 32767 || ! prep -> data ) return - EINVAL ; buf = kmalloc ( datalen + 1 , GFP_KERNEL ) ; if ( ! buf ) return - ENOMEM ; buf [ datalen ] = 0 ; memcpy ( buf , prep -> data , datalen ) ; ret = datablob_parse ( buf , & format , & new_master_desc , NULL , NULL ) ; if ( ret < 0 ) goto out ; ret = valid_master_desc ( new_master_desc , epayload -> master_desc ) ; if ( ret < 0 ) goto out ; new_epayload = encrypted_key_alloc ( key , epayload -> format , new_master_desc , epayload -> datalen ) ; if ( IS_ERR ( new_epayload ) ) { ret = PTR_ERR ( new_epayload ) ; goto out ; } __ekey_init ( new_epayload , epayload -> format , new_master_desc , epayload -> datalen ) ; memcpy ( new_epayload -> iv , epayload -> iv , ivsize ) ; memcpy ( new_epayload -> payload_data , epayload -> payload_data , epayload -> payload_datalen ) ; rcu_assign_keypointer ( key , new_epayload ) ; call_rcu ( & epayload -> rcu , encrypted_rcu_free ) ; out : kfree ( buf ) ; return ret ; }
","<S2SV_ModStart> ret = 0 ; if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) return - ENOKEY
"
429,"CWE-119 static inline int object_common2 ( UNSERIALIZE_PARAMETER , long elements ) { zval * retval_ptr = NULL ; zval fname ; if ( Z_TYPE_PP ( rval ) != IS_OBJECT ) { return 0 ; } if ( ! process_nested_data ( UNSERIALIZE_PASSTHRU , Z_OBJPROP_PP ( rval ) , elements , 1 ) ) { if ( Z_TYPE_PP ( rval ) == IS_OBJECT ) { zend_hash_clean ( Z_OBJPROP_PP ( rval ) ) ; <S2SV_StartBug> } <S2SV_EndBug> ZVAL_NULL ( * rval ) ; return 0 ; } if ( Z_TYPE_PP ( rval ) != IS_OBJECT ) { return 0 ; } if ( Z_OBJCE_PP ( rval ) != PHP_IC_ENTRY && zend_hash_exists ( & Z_OBJCE_PP ( rval ) -> function_table , ""__wakeup"" , sizeof ( ""__wakeup"" ) ) ) { INIT_PZVAL ( & fname ) ; ZVAL_STRINGL ( & fname , ""__wakeup"" , sizeof ( ""__wakeup"" ) - 1 , 0 ) ; BG ( serialize_lock ) ++ ; call_user_function_ex ( CG ( function_table ) , rval , & fname , & retval_ptr , 0 , 0 , 1 , NULL TSRMLS_CC ) ; BG ( serialize_lock ) -- ; } if ( retval_ptr ) { zval_ptr_dtor ( & retval_ptr ) ; } if ( EG ( exception ) ) { return 0 ; } return finish_nested_data ( UNSERIALIZE_PASSTHRU ) ; }
","<S2SV_ModStart> ) ) ; zend_object_store_ctor_failed ( * rval TSRMLS_CC ) ;
"
430,"CWE-415 void gdImageGifCtx ( gdImagePtr im , gdIOCtxPtr out ) { <S2SV_StartBug> gdImagePtr pim = 0 , tim = im ; <S2SV_EndBug> int interlace , BitsPerPixel ; interlace = im -> interlace ; if ( im -> trueColor ) { <S2SV_StartBug> pim = gdImageCreatePaletteFromTrueColor ( im , 1 , 256 ) ; <S2SV_EndBug> if ( ! pim ) { return ; } tim = pim ; } BitsPerPixel = colorstobpp ( tim -> colorsTotal ) ; GIFEncode ( out , tim -> sx , tim -> sy , tim -> interlace , 0 , tim -> transparent , BitsPerPixel , tim -> red , tim -> green , tim -> blue , tim ) ; if ( pim ) { gdImageDestroy ( pim ) ; } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> out ) { _gdImageGifCtx <S2SV_ModEnd> ( im , <S2SV_ModStart> ( im , out <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
"
431,"CWE-326 __be32 ipv6_proxy_select_ident ( struct net * net , struct sk_buff * skb ) { <S2SV_StartBug> static u32 ip6_proxy_idents_hashrnd __read_mostly ; <S2SV_EndBug> struct in6_addr buf [ 2 ] ; struct in6_addr * addrs ; u32 id ; addrs = skb_header_pointer ( skb , skb_network_offset ( skb ) + offsetof ( struct ipv6hdr , saddr ) , sizeof ( buf ) , buf ) ; if ( ! addrs ) return 0 ; <S2SV_StartBug> net_get_random_once ( & ip6_proxy_idents_hashrnd , <S2SV_EndBug> sizeof ( ip6_proxy_idents_hashrnd ) ) ; <S2SV_StartBug> id = __ipv6_select_ident ( net , ip6_proxy_idents_hashrnd , <S2SV_EndBug> & addrs [ 1 ] , & addrs [ 0 ] ) ; return htonl ( id ) ; }
","<S2SV_ModStart> skb ) { <S2SV_ModEnd> struct in6_addr buf <S2SV_ModStart> return 0 ; <S2SV_ModEnd> id = __ipv6_select_ident <S2SV_ModStart> ( net , <S2SV_ModEnd> & addrs [
"
432,"CWE-787 static void rdpsnd_process_training ( STREAM in ) { uint16 tick ; uint16 packsize ; <S2SV_StartBug> STREAM out ; <S2SV_EndBug> in_uint16_le ( in , tick ) ; in_uint16_le ( in , packsize ) ; logger ( Sound , Debug , ""rdpsnd_process_training(),<S2SV_blank>tick=0x%04x"" , ( unsigned ) tick ) ; out = rdpsnd_init_packet ( SNDC_TRAINING , 4 ) ; out_uint16_le ( out , tick ) ; out_uint16_le ( out , packsize ) ; s_mark_end ( out ) ; rdpsnd_send ( out ) ; }
","<S2SV_ModStart> STREAM out ; struct stream packet = * in ; if ( ! s_check_rem ( in , 4 ) ) { rdp_protocol_error ( ""rdpsnd_process_training(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>training<S2SV_blank>data<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ; }
"
433,"CWE-362 int dccp_v4_connect ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { const struct sockaddr_in * usin = ( struct sockaddr_in * ) uaddr ; struct inet_sock * inet = inet_sk ( sk ) ; struct dccp_sock * dp = dccp_sk ( sk ) ; __be16 orig_sport , orig_dport ; __be32 daddr , nexthop ; struct flowi4 fl4 ; struct rtable * rt ; <S2SV_StartBug> int err ; <S2SV_EndBug> dp -> dccps_role = DCCP_ROLE_CLIENT ; if ( addr_len < sizeof ( struct sockaddr_in ) ) return - EINVAL ; if ( usin -> sin_family != AF_INET ) return - EAFNOSUPPORT ; nexthop = daddr = usin -> sin_addr . s_addr ; <S2SV_StartBug> if ( inet -> opt != NULL && inet -> opt -> srr ) { <S2SV_EndBug> if ( daddr == 0 ) return - EINVAL ; <S2SV_StartBug> nexthop = inet -> opt -> faddr ; <S2SV_EndBug> } orig_sport = inet -> inet_sport ; orig_dport = usin -> sin_port ; rt = ip_route_connect ( & fl4 , nexthop , inet -> inet_saddr , RT_CONN_FLAGS ( sk ) , sk -> sk_bound_dev_if , IPPROTO_DCCP , orig_sport , orig_dport , sk , true ) ; if ( IS_ERR ( rt ) ) return PTR_ERR ( rt ) ; if ( rt -> rt_flags & ( RTCF_MULTICAST | RTCF_BROADCAST ) ) { ip_rt_put ( rt ) ; return - ENETUNREACH ; } <S2SV_StartBug> if ( inet -> opt == NULL || ! inet -> opt -> srr ) <S2SV_EndBug> daddr = rt -> rt_dst ; if ( inet -> inet_saddr == 0 ) inet -> inet_saddr = rt -> rt_src ; inet -> inet_rcv_saddr = inet -> inet_saddr ; inet -> inet_dport = usin -> sin_port ; inet -> inet_daddr = daddr ; inet_csk ( sk ) -> icsk_ext_hdr_len = 0 ; <S2SV_StartBug> if ( inet -> opt != NULL ) <S2SV_EndBug> inet_csk ( sk ) -> icsk_ext_hdr_len = inet -> opt -> optlen ; dccp_set_state ( sk , DCCP_REQUESTING ) ; err = inet_hash_connect ( & dccp_death_row , sk ) ; if ( err != 0 ) goto failure ; rt = ip_route_newports ( & fl4 , rt , orig_sport , orig_dport , inet -> inet_sport , inet -> inet_dport , sk ) ; if ( IS_ERR ( rt ) ) { rt = NULL ; goto failure ; } sk_setup_caps ( sk , & rt -> dst ) ; dp -> dccps_iss = secure_dccp_sequence_number ( inet -> inet_saddr , inet -> inet_daddr , inet -> inet_sport , inet -> inet_dport ) ; inet -> inet_id = dp -> dccps_iss ^ jiffies ; err = dccp_connect ( sk ) ; rt = NULL ; if ( err != 0 ) goto failure ; out : return err ; failure : dccp_set_state ( sk , DCCP_CLOSED ) ; ip_rt_put ( rt ) ; sk -> sk_route_caps = 0 ; inet -> inet_dport = 0 ; goto out ; }
","<S2SV_ModStart> ; int err ; struct ip_options_rcu * inet_opt <S2SV_ModStart> . s_addr ; inet_opt = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) ; if ( inet_opt <S2SV_ModEnd> != NULL && <S2SV_ModStart> != NULL && inet_opt -> opt . <S2SV_ModEnd> srr ) { <S2SV_ModStart> ; nexthop = inet_opt -> opt . <S2SV_ModEnd> faddr ; } <S2SV_ModStart> } if ( inet_opt <S2SV_ModEnd> == NULL || <S2SV_ModStart> NULL || ! inet_opt -> opt . <S2SV_ModEnd> srr ) daddr <S2SV_ModStart> ; if ( inet_opt ) inet_csk ( sk ) -> icsk_ext_hdr_len = inet_opt -> opt . <S2SV_ModEnd> optlen ; dccp_set_state
"
434,"CWE-787 size_t OpenMP4Source ( char * filename , uint32_t traktype , uint32_t traksubtype ) { mp4object * mp4 = ( mp4object * ) malloc ( sizeof ( mp4object ) ) ; if ( mp4 == NULL ) return 0 ; <S2SV_StartBug> memset ( mp4 , 0 , sizeof ( mp4object ) ) ; <S2SV_EndBug> # ifdef _WINDOWS fopen_s ( & mp4 -> mediafp , filename , ""rb"" ) ; # else mp4 -> mediafp = fopen ( filename , ""rb"" ) ; # endif if ( mp4 -> mediafp ) { uint32_t qttag , qtsize32 , skip , type = 0 , subtype = 0 , num ; size_t len ; int32_t nest = 0 ; uint64_t nestsize [ MAX_NEST_LEVEL ] = { 0 } ; uint64_t lastsize = 0 , qtsize ; do { len = fread ( & qtsize32 , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & qttag , 1 , 4 , mp4 -> mediafp ) ; <S2SV_StartBug> if ( len == 8 ) <S2SV_EndBug> { if ( ! VALID_FOURCC ( qttag ) ) { <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , lastsize - 8 - 8 , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( lastsize - 8 ) ; continue ; } qtsize32 = BYTESWAP32 ( qtsize32 ) ; if ( qtsize32 == 1 ) { <S2SV_StartBug> fread ( & qtsize , 1 , 8 , mp4 -> mediafp ) ; <S2SV_EndBug> qtsize = BYTESWAP64 ( qtsize ) - 8 ; } else qtsize = qtsize32 ; nest ++ ; if ( qtsize < 8 ) break ; if ( nest >= MAX_NEST_LEVEL ) break ; nestsize [ nest ] = qtsize ; lastsize = qtsize ; # if PRINT_MP4_STRUCTURE for ( int i = 1 ; i < nest ; i ++ ) printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ) ; printf ( ""%c%c%c%c<S2SV_blank>(%lld)\\n"" , ( qttag & 0xff ) , ( ( qttag >> 8 ) & 0xff ) , ( ( qttag >> 16 ) & 0xff ) , ( ( qttag >> 24 ) & 0xff ) , qtsize ) ; if ( qttag == MAKEID ( 'm' , 'd' , 'a' , 't' ) || qttag == MAKEID ( 'f' , 't' , 'y' , 'p' ) || <S2SV_StartBug> qttag == MAKEID ( 'u' , 'd' , 't' , 'a' ) ) <S2SV_EndBug> { <S2SV_StartBug> LONGSEEK ( mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( qtsize ) ; continue ; } # else if ( qttag != MAKEID ( 'm' , 'o' , 'o' , 'v' ) && qttag != MAKEID ( 'm' , 'v' , 'h' , 'd' ) && qttag != MAKEID ( 't' , 'r' , 'a' , 'k' ) && qttag != MAKEID ( 'm' , 'd' , 'i' , 'a' ) && qttag != MAKEID ( 'm' , 'd' , 'h' , 'd' ) && qttag != MAKEID ( 'm' , 'i' , 'n' , 'f' ) && qttag != MAKEID ( 'g' , 'm' , 'i' , 'n' ) && qttag != MAKEID ( 'd' , 'i' , 'n' , 'f' ) && qttag != MAKEID ( 'a' , 'l' , 'i' , 's' ) && qttag != MAKEID ( 's' , 't' , 's' , 'd' ) && <S2SV_StartBug> qttag != MAKEID ( 'a' , 'l' , 'i' , 's' ) && <S2SV_EndBug> <S2SV_StartBug> qttag != MAKEID ( 'a' , 'l' , 'i' , 's' ) && <S2SV_EndBug> <S2SV_StartBug> qttag != MAKEID ( 's' , 't' , 'b' , 'l' ) && <S2SV_EndBug> <S2SV_StartBug> qttag != MAKEID ( 's' , 't' , 't' , 's' ) && <S2SV_EndBug> <S2SV_StartBug> qttag != MAKEID ( 's' , 't' , 's' , 'c' ) && <S2SV_EndBug> <S2SV_StartBug> qttag != MAKEID ( 's' , 't' , 's' , 'z' ) && <S2SV_EndBug> <S2SV_StartBug> qttag != MAKEID ( 's' , 't' , 'c' , 'o' ) && <S2SV_EndBug> qttag != MAKEID ( 'c' , 'o' , '6' , '4' ) && qttag != MAKEID ( 'h' , 'd' , 'l' , 'r' ) ) { <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( qtsize ) ; } else # endif if ( qttag == MAKEID ( 'm' , 'v' , 'h' , 'd' ) ) { len = fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & mp4 -> clockdemon , 1 , 4 , mp4 -> mediafp ) ; mp4 -> clockdemon = BYTESWAP32 ( mp4 -> clockdemon ) ; len += fread ( & mp4 -> clockcount , 1 , 4 , mp4 -> mediafp ) ; mp4 -> clockcount = BYTESWAP32 ( mp4 -> clockcount ) ; <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( qtsize ) ; } else if ( qttag == MAKEID ( 'm' , 'd' , 'h' , 'd' ) ) { media_header md ; len = fread ( & md , 1 , sizeof ( md ) , mp4 -> mediafp ) ; if ( len == sizeof ( md ) ) { md . creation_time = BYTESWAP32 ( md . creation_time ) ; md . modification_time = BYTESWAP32 ( md . modification_time ) ; md . time_scale = BYTESWAP32 ( md . time_scale ) ; md . duration = BYTESWAP32 ( md . duration ) ; mp4 -> trak_clockdemon = md . time_scale ; mp4 -> trak_clockcount = md . duration ; if ( mp4 -> videolength == 0.0 ) { mp4 -> videolength = ( float ) ( ( double ) mp4 -> trak_clockcount / ( double ) mp4 -> trak_clockdemon ) ; } } <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( qtsize ) ; } else if ( qttag == MAKEID ( 'h' , 'd' , 'l' , 'r' ) ) { uint32_t temp ; len = fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & temp , 1 , 4 , mp4 -> mediafp ) ; <S2SV_StartBug> if ( temp != MAKEID ( 'a' , 'l' , 'i' , 's' ) ) <S2SV_EndBug> type = temp ; <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( qtsize ) ; } else if ( qttag == MAKEID ( 's' , 't' , 's' , 'd' ) ) { if ( type == traktype ) { len = fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & subtype , 1 , 4 , mp4 -> mediafp ) ; if ( len == 16 ) { if ( subtype != traksubtype ) { type = 0 ; } } <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> } else <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( qtsize ) ; } else if ( qttag == MAKEID ( 's' , 't' , 's' , 'c' ) ) { if ( type == traktype ) { len = fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & num , 1 , 4 , mp4 -> mediafp ) ; num = BYTESWAP32 ( num ) ; if ( num * 12 <= qtsize - 8 - len ) { mp4 -> metastsc_count = num ; if ( mp4 -> metastsc ) free ( mp4 -> metastsc ) ; <S2SV_StartBug> mp4 -> metastsc = ( SampleToChunk * ) malloc ( num * 12 ) ; <S2SV_EndBug> if ( mp4 -> metastsc ) { <S2SV_StartBug> uint32_t total_stsc = num ; <S2SV_EndBug> len += fread ( mp4 -> metastsc , 1 , num * sizeof ( SampleToChunk ) , mp4 -> mediafp ) ; do { num -- ; mp4 -> metastsc [ num ] . chunk_num = BYTESWAP32 ( mp4 -> metastsc [ num ] . chunk_num ) ; mp4 -> metastsc [ num ] . samples = BYTESWAP32 ( mp4 -> metastsc [ num ] . samples ) ; mp4 -> metastsc [ num ] . id = BYTESWAP32 ( mp4 -> metastsc [ num ] . id ) ; } while ( num > 0 ) ; } <S2SV_StartBug> if ( mp4 -> metastsc_count == 1 && mp4 -> metastsc [ 0 ] . samples == 1 ) <S2SV_EndBug> { if ( mp4 -> metastsc ) free ( mp4 -> metastsc ) ; mp4 -> metastsc = NULL ; <S2SV_StartBug> mp4 -> metastsc_count = 0 ; <S2SV_EndBug> } } <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> } else <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( qtsize ) ; } else if ( qttag == MAKEID ( 's' , 't' , 's' , 'z' ) ) { if ( type == traktype ) { uint32_t equalsamplesize ; len = fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & equalsamplesize , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & num , 1 , 4 , mp4 -> mediafp ) ; num = BYTESWAP32 ( num ) ; if ( num * 4 <= qtsize - 8 - len ) { mp4 -> metasize_count = num ; if ( mp4 -> metasizes ) free ( mp4 -> metasizes ) ; <S2SV_StartBug> mp4 -> metasizes = ( uint32_t * ) malloc ( num * 4 ) ; <S2SV_EndBug> if ( mp4 -> metasizes ) { if ( equalsamplesize == 0 ) { len += fread ( mp4 -> metasizes , 1 , num * 4 , mp4 -> mediafp ) ; do { num -- ; mp4 -> metasizes [ num ] = BYTESWAP32 ( mp4 -> metasizes [ num ] ) ; } while ( num > 0 ) ; } else { equalsamplesize = BYTESWAP32 ( equalsamplesize ) ; do { num -- ; mp4 -> metasizes [ num ] = equalsamplesize ; } while ( num > 0 ) ; } } } <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> } else <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( qtsize ) ; } else if ( qttag == MAKEID ( 's' , 't' , 'c' , 'o' ) ) { if ( type == traktype ) { len = fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & num , 1 , 4 , mp4 -> mediafp ) ; num = BYTESWAP32 ( num ) ; if ( num * 4 <= qtsize - 8 - len ) { <S2SV_StartBug> if ( mp4 -> metastsc_count > 0 && num != mp4 -> metasize_count ) <S2SV_EndBug> { <S2SV_StartBug> mp4 -> indexcount = mp4 -> metasize_count ; <S2SV_EndBug> <S2SV_StartBug> if ( mp4 -> metaoffsets ) free ( mp4 -> metaoffsets ) ; <S2SV_EndBug> <S2SV_StartBug> mp4 -> metaoffsets = ( uint64_t * ) malloc ( mp4 -> metasize_count * 8 ) ; <S2SV_EndBug> if ( mp4 -> metaoffsets ) { uint32_t * metaoffsets32 = NULL ; metaoffsets32 = ( uint32_t * ) malloc ( num * 4 ) ; if ( metaoffsets32 ) { uint64_t fileoffset = 0 ; int stsc_pos = 0 ; int stco_pos = 0 ; int repeat = 1 ; len += fread ( metaoffsets32 , 1 , num * 4 , mp4 -> mediafp ) ; do { num -- ; metaoffsets32 [ num ] = BYTESWAP32 ( metaoffsets32 [ num ] ) ; } while ( num > 0 ) ; mp4 -> metaoffsets [ 0 ] = fileoffset = metaoffsets32 [ stco_pos ] ; num = 1 ; <S2SV_StartBug> while ( num < mp4 -> metasize_count ) <S2SV_EndBug> { if ( stsc_pos + 1 < ( int ) mp4 -> metastsc_count && num == stsc_pos ) { stco_pos ++ ; stsc_pos ++ ; fileoffset = ( uint64_t ) metaoffsets32 [ stco_pos ] ; repeat = 1 ; } else if ( repeat == mp4 -> metastsc [ stsc_pos ] . samples ) { <S2SV_StartBug> stco_pos ++ ; <S2SV_EndBug> fileoffset = ( uint64_t ) metaoffsets32 [ stco_pos ] ; <S2SV_StartBug> repeat = 1 ; <S2SV_EndBug> } else { fileoffset += ( uint64_t ) mp4 -> metasizes [ num - 1 ] ; <S2SV_StartBug> repeat ++ ; <S2SV_EndBug> } mp4 -> metaoffsets [ num ] = fileoffset ; num ++ ; } if ( mp4 -> metastsc ) free ( mp4 -> metastsc ) ; mp4 -> metastsc = NULL ; mp4 -> metastsc_count = 0 ; free ( metaoffsets32 ) ; } } } else { <S2SV_StartBug> mp4 -> indexcount = num ; <S2SV_EndBug> <S2SV_StartBug> if ( mp4 -> metaoffsets ) free ( mp4 -> metaoffsets ) ; <S2SV_EndBug> mp4 -> metaoffsets = ( uint64_t * ) malloc ( num * 8 ) ; if ( mp4 -> metaoffsets ) { uint32_t * metaoffsets32 = NULL ; metaoffsets32 = ( uint32_t * ) malloc ( num * 4 ) ; if ( metaoffsets32 ) { size_t readlen = fread ( metaoffsets32 , 1 , num * 4 , mp4 -> mediafp ) ; len += readlen ; do { num -- ; mp4 -> metaoffsets [ num ] = BYTESWAP32 ( metaoffsets32 [ num ] ) ; } while ( num > 0 ) ; free ( metaoffsets32 ) ; } } } <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> } else <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( qtsize ) ; } else if ( qttag == MAKEID ( 'c' , 'o' , '6' , '4' ) ) { if ( type == traktype ) { len = fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & num , 1 , 4 , mp4 -> mediafp ) ; num = BYTESWAP32 ( num ) ; <S2SV_StartBug> if ( num * 8 <= qtsize - 8 - len ) <S2SV_EndBug> { if ( mp4 -> metastsc_count > 0 && num != mp4 -> metasize_count ) { mp4 -> indexcount = mp4 -> metasize_count ; <S2SV_StartBug> if ( mp4 -> metaoffsets ) free ( mp4 -> metaoffsets ) ; <S2SV_EndBug> mp4 -> metaoffsets = ( uint64_t * ) malloc ( mp4 -> metasize_count * 8 ) ; if ( mp4 -> metaoffsets ) { uint64_t * metaoffsets64 = NULL ; metaoffsets64 = ( uint64_t * ) malloc ( num * 8 ) ; if ( metaoffsets64 ) { uint64_t fileoffset = 0 ; int stsc_pos = 0 ; int stco_pos = 0 ; len += fread ( metaoffsets64 , 1 , num * 8 , mp4 -> mediafp ) ; do { num -- ; metaoffsets64 [ num ] = BYTESWAP64 ( metaoffsets64 [ num ] ) ; } while ( num > 0 ) ; fileoffset = metaoffsets64 [ 0 ] ; mp4 -> metaoffsets [ 0 ] = fileoffset ; num = 1 ; while ( num < mp4 -> metasize_count ) { if ( num != mp4 -> metastsc [ stsc_pos ] . chunk_num - 1 && 0 == ( num - ( mp4 -> metastsc [ stsc_pos ] . chunk_num - 1 ) ) % mp4 -> metastsc [ stsc_pos ] . samples ) { stco_pos ++ ; fileoffset = ( uint64_t ) metaoffsets64 [ stco_pos ] ; } else { fileoffset += ( uint64_t ) mp4 -> metasizes [ num - 1 ] ; } mp4 -> metaoffsets [ num ] = fileoffset ; num ++ ; } if ( mp4 -> metastsc ) free ( mp4 -> metastsc ) ; mp4 -> metastsc = NULL ; mp4 -> metastsc_count = 0 ; free ( metaoffsets64 ) ; } } } else { <S2SV_StartBug> mp4 -> indexcount = num ; <S2SV_EndBug> if ( mp4 -> metaoffsets ) free ( mp4 -> metaoffsets ) ; mp4 -> metaoffsets = ( uint64_t * ) malloc ( num * 8 ) ; if ( mp4 -> metaoffsets ) { len += fread ( mp4 -> metaoffsets , 1 , num * 8 , mp4 -> mediafp ) ; do { num -- ; mp4 -> metaoffsets [ num ] = BYTESWAP64 ( mp4 -> metaoffsets [ num ] ) ; } while ( num > 0 ) ; } } } <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> } else <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( qtsize ) ; } else if ( qttag == MAKEID ( 's' , 't' , 't' , 's' ) ) { if ( type == traktype ) { uint32_t totaldur = 0 , samples = 0 ; int32_t entries = 0 ; len = fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & num , 1 , 4 , mp4 -> mediafp ) ; num = BYTESWAP32 ( num ) ; if ( num * 8 <= qtsize - 8 - len ) { entries = num ; mp4 -> meta_clockdemon = mp4 -> trak_clockdemon ; mp4 -> meta_clockcount = mp4 -> trak_clockcount ; while ( entries > 0 ) { int32_t samplecount ; int32_t duration ; len += fread ( & samplecount , 1 , 4 , mp4 -> mediafp ) ; samplecount = BYTESWAP32 ( samplecount ) ; len += fread ( & duration , 1 , 4 , mp4 -> mediafp ) ; duration = BYTESWAP32 ( duration ) ; samples += samplecount ; entries -- ; totaldur += duration ; mp4 -> metadatalength += ( double ) ( ( double ) samplecount * ( double ) duration / ( double ) mp4 -> meta_clockdemon ) ; } mp4 -> basemetadataduration = mp4 -> metadatalength * ( double ) mp4 -> meta_clockdemon / ( double ) samples ; } <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> } else <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( qtsize ) ; } else { NESTSIZE ( 8 ) ; } } else { break ; } } while ( len > 0 ) ; <S2SV_StartBug> } <S2SV_EndBug> else { free ( mp4 ) ; mp4 = NULL ; } return ( size_t ) mp4 ; }
","<S2SV_ModStart> mp4object ) ) ; struct stat64 mp4stat ; stat64 ( filename , & mp4stat ) ; mp4 -> filesize = mp4stat . st_size ; if ( mp4 -> filesize < 64 ) return 0 <S2SV_ModStart> mediafp ) ; mp4 -> filepos += len ; <S2SV_ModStart> len == 8 && mp4 -> filepos < mp4 -> filesize <S2SV_ModStart> ) ) { CloseSource ( ( size_t ) mp4 ) ; mp4 = NULL ; break <S2SV_ModEnd> ; } qtsize32 <S2SV_ModStart> 1 ) { len = <S2SV_ModStart> -> mediafp ) ; mp4 -> filepos += len <S2SV_ModStart> , 'a' ) || qttag == MAKEID ( 'f' , 'r' , 'e' , 'e' ) ) { LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> != MAKEID ( 's' , 't' , 'b' , 'l' <S2SV_ModEnd> ) && qttag <S2SV_ModStart> != MAKEID ( 's' , 't' , 't' <S2SV_ModEnd> , 's' ) <S2SV_ModStart> , 't' , 's' , 'c' <S2SV_ModEnd> ) && qttag <S2SV_ModStart> , 't' , 's' , 'z' <S2SV_ModEnd> ) && qttag <S2SV_ModStart> , 't' , 'c' , 'o' <S2SV_ModEnd> ) && qttag <S2SV_ModStart> != MAKEID ( 'c' , 'o' , '6' , '4' <S2SV_ModEnd> ) && qttag <S2SV_ModStart> != MAKEID ( <S2SV_ModEnd> 'h' , 'd' <S2SV_ModStart> ) ) { LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> clockcount ) ; mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> ; } } mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> , 's' ) && temp != MAKEID ( 'u' , 'r' , 'l' , '<S2SV_blank>' ) <S2SV_ModStart> = temp ; mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> ; } } mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; } <S2SV_ModStart> ; } else LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> metastsc ) ; if ( num > 0 ) { <S2SV_ModStart> ( num * sizeof ( SampleToChunk ) <S2SV_ModEnd> ) ; if <S2SV_ModStart> metastsc ) { <S2SV_ModEnd> len += fread <S2SV_ModStart> ) ; } } else { CloseSource ( ( size_t ) mp4 ) ; mp4 <S2SV_ModEnd> = NULL ; <S2SV_ModStart> = NULL ; break ; } } mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; } <S2SV_ModStart> ; } else LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> metasizes ) ; if ( num > 0 ) { <S2SV_ModStart> } } } else { CloseSource ( ( size_t ) mp4 ) ; mp4 = NULL ; break ; } } mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; } <S2SV_ModStart> ; } else LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> len ) { uint32_t metastco_count = num ; <S2SV_ModStart> -> indexcount = num <S2SV_ModEnd> ; if ( <S2SV_ModStart> metaoffsets ) ; if ( num > 0 ) { <S2SV_ModStart> ) malloc ( num <S2SV_ModEnd> * 8 ) <S2SV_ModStart> < mp4 -> indexcount ) { if ( ( uint32_t ) <S2SV_ModEnd> repeat == mp4 <S2SV_ModStart> samples ) { if ( ( uint32_t ) stco_pos + 1 < metastco_count ) { <S2SV_ModStart> stco_pos ] ; <S2SV_ModEnd> } else { <S2SV_ModStart> 1 ] ; } if ( ( uint32_t ) stsc_pos + 1 < mp4 -> metastsc_count ) if ( mp4 -> metastsc [ stsc_pos + 1 ] . chunk_num == ( uint32_t ) stco_pos + 1 ) stsc_pos ++ ; repeat = 1 ; } else { fileoffset += ( uint64_t ) mp4 -> metasizes [ num - 1 ] ; <S2SV_ModStart> } else { CloseSource ( ( size_t ) mp4 ) ; mp4 = NULL ; break ; } } else { <S2SV_ModStart> metaoffsets ) ; if ( num > 0 ) { <S2SV_ModStart> } } } else { CloseSource ( ( size_t ) mp4 ) ; mp4 = NULL ; break ; } } } mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; } <S2SV_ModStart> ; } else LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> if ( num == 0 ) { CloseSource ( ( size_t ) mp4 ) ; mp4 = NULL ; break ; } if ( num <S2SV_ModStart> metaoffsets ) ; if ( mp4 -> metasize_count ) { <S2SV_ModStart> } else { CloseSource ( ( size_t ) mp4 ) ; mp4 = NULL ; break ; } } else { <S2SV_ModStart> } } } mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; } <S2SV_ModStart> ; } else LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> samples ; } mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; } <S2SV_ModStart> ; } else LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> 0 ) ; if ( mp4 ) { if ( mp4 -> metasizes == NULL || mp4 -> metaoffsets == NULL ) { CloseSource ( ( size_t ) mp4 ) ; mp4 = NULL ; } }
"
435,"CWE-000 int sas_discover_sata ( struct domain_device * dev ) { int res ; if ( dev -> dev_type == SAS_SATA_PM ) return - ENODEV ; dev -> sata_dev . class = sas_get_ata_command_set ( dev ) ; sas_fill_in_rphy ( dev , dev -> rphy ) ; res = sas_notify_lldd_dev_found ( dev ) ; if ( res ) return res ; <S2SV_StartBug> sas_discover_event ( dev -> port , DISCE_PROBE ) ; <S2SV_EndBug> return 0 ; }
","<S2SV_ModStart> return res ; <S2SV_ModEnd> return 0 ;
"
436,"CWE-119 static void setup_features ( VP8_COMP * cpi ) { if ( cpi -> mb . e_mbd . segmentation_enabled ) { cpi -> mb . e_mbd . update_mb_segmentation_map = 1 ; cpi -> mb . e_mbd . update_mb_segmentation_data = 1 ; } else { cpi -> mb . e_mbd . update_mb_segmentation_map = 0 ; cpi -> mb . e_mbd . update_mb_segmentation_data = 0 ; } cpi -> mb . e_mbd . mode_ref_lf_delta_enabled = 0 ; cpi -> mb . e_mbd . mode_ref_lf_delta_update = 0 ; <S2SV_StartBug> vpx_memset ( cpi -> mb . e_mbd . ref_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . ref_lf_deltas ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( cpi -> mb . e_mbd . mode_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . mode_lf_deltas ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( cpi -> mb . e_mbd . last_ref_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . ref_lf_deltas ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( cpi -> mb . e_mbd . last_mode_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . mode_lf_deltas ) ) ; <S2SV_EndBug> set_default_lf_deltas ( cpi ) ; }
","<S2SV_ModStart> = 0 ; memset <S2SV_ModEnd> ( cpi -> <S2SV_ModStart> ) ) ; memset <S2SV_ModEnd> ( cpi -> <S2SV_ModStart> ) ) ; memset <S2SV_ModEnd> ( cpi -> <S2SV_ModStart> ) ) ; memset <S2SV_ModEnd> ( cpi ->
"
437,"CWE-476 jp2_box_t * jp2_box_create ( int type ) { jp2_box_t * box ; jp2_boxinfo_t * boxinfo ; <S2SV_StartBug> if ( ! ( box = jas_malloc ( sizeof ( jp2_box_t ) ) ) ) { <S2SV_EndBug> return 0 ; } <S2SV_StartBug> memset ( box , 0 , sizeof ( jp2_box_t ) ) ; <S2SV_EndBug> box -> type = type ; box -> len = 0 ; if ( ! ( boxinfo = jp2_boxinfolookup ( type ) ) ) { return 0 ; } box -> info = boxinfo ; box -> ops = & boxinfo -> ops ; return box ; }
","<S2SV_ModStart> ( box = jp2_box_create0 ( <S2SV_ModEnd> ) ) ) <S2SV_ModStart> 0 ; } <S2SV_ModEnd> box -> type
"
438,"CWE-476 void gf_isom_cenc_get_default_info_internal ( GF_TrackBox * trak , u32 sampleDescriptionIndex , u32 * container_type , Bool * default_IsEncrypted , u8 * crypt_byte_block , u8 * skip_byte_block , const u8 * * key_info , u32 * key_info_size ) { GF_ProtectionSchemeInfoBox * sinf ; if ( default_IsEncrypted ) * default_IsEncrypted = GF_FALSE ; if ( crypt_byte_block ) * crypt_byte_block = 0 ; if ( skip_byte_block ) * skip_byte_block = 0 ; if ( container_type ) * container_type = 0 ; if ( key_info ) * key_info = NULL ; if ( key_info_size ) * key_info_size = 0 ; sinf = isom_get_sinf_entry ( trak , sampleDescriptionIndex , GF_ISOM_CENC_SCHEME , NULL ) ; if ( ! sinf ) sinf = isom_get_sinf_entry ( trak , sampleDescriptionIndex , GF_ISOM_CBC_SCHEME , NULL ) ; if ( ! sinf ) sinf = isom_get_sinf_entry ( trak , sampleDescriptionIndex , GF_ISOM_CENS_SCHEME , NULL ) ; if ( ! sinf ) sinf = isom_get_sinf_entry ( trak , sampleDescriptionIndex , GF_ISOM_CBCS_SCHEME , NULL ) ; if ( ! sinf ) sinf = isom_get_sinf_entry ( trak , sampleDescriptionIndex , GF_ISOM_PIFF_SCHEME , NULL ) ; if ( ! sinf ) { u32 i , nb_stsd = gf_list_count ( trak -> Media -> information -> sampleTable -> SampleDescription -> child_boxes ) ; for ( i = 0 ; i < nb_stsd ; i ++ ) { GF_ProtectionSchemeInfoBox * a_sinf ; GF_SampleEntryBox * sentry = NULL ; if ( i + 1 == sampleDescriptionIndex ) continue ; sentry = gf_list_get ( trak -> Media -> information -> sampleTable -> SampleDescription -> child_boxes , i ) ; a_sinf = ( GF_ProtectionSchemeInfoBox * ) gf_isom_box_find_child ( sentry -> child_boxes , GF_ISOM_BOX_TYPE_SINF ) ; if ( ! a_sinf ) continue ; return ; } } if ( sinf && sinf -> info && sinf -> info -> tenc ) { if ( default_IsEncrypted ) * default_IsEncrypted = sinf -> info -> tenc -> isProtected ; if ( crypt_byte_block ) * crypt_byte_block = sinf -> info -> tenc -> crypt_byte_block ; if ( skip_byte_block ) * skip_byte_block = sinf -> info -> tenc -> skip_byte_block ; if ( key_info ) * key_info = sinf -> info -> tenc -> key_info ; if ( key_info_size ) { * key_info_size = 20 ; if ( ! sinf -> info -> tenc -> key_info [ 3 ] ) * key_info_size += 1 + sinf -> info -> tenc -> key_info [ 20 ] ; } if ( container_type ) * container_type = GF_ISOM_BOX_TYPE_SENC ; } else if ( sinf && sinf -> info && sinf -> info -> piff_tenc ) { if ( default_IsEncrypted ) * default_IsEncrypted = GF_TRUE ; if ( key_info ) * key_info = sinf -> info -> piff_tenc -> key_info ; if ( key_info_size ) * key_info_size = 19 ; if ( container_type ) * container_type = GF_ISOM_BOX_UUID_PSEC ; } else { u32 i , count = 0 ; GF_CENCSampleEncryptionGroupEntry * seig_entry = NULL ; if ( ! trak -> moov -> mov -> is_smooth ) count = gf_list_count ( trak -> Media -> information -> sampleTable -> sampleGroupsDescription ) ; for ( i = 0 ; i < count ; i ++ ) { GF_SampleGroupDescriptionBox * sgdesc = ( GF_SampleGroupDescriptionBox * ) gf_list_get ( trak -> Media -> information -> sampleTable -> sampleGroupsDescription , i ) ; if ( sgdesc -> grouping_type != GF_ISOM_SAMPLE_GROUP_SEIG ) continue ; if ( sgdesc -> default_description_index ) seig_entry = gf_list_get ( sgdesc -> group_descriptions , sgdesc -> default_description_index - 1 ) ; else seig_entry = gf_list_get ( sgdesc -> group_descriptions , 0 ) ; <S2SV_StartBug> if ( ! seig_entry -> key_info [ 0 ] ) <S2SV_EndBug> seig_entry = NULL ; break ; } if ( seig_entry ) { if ( default_IsEncrypted ) * default_IsEncrypted = seig_entry -> IsProtected ; if ( crypt_byte_block ) * crypt_byte_block = seig_entry -> crypt_byte_block ; if ( skip_byte_block ) * skip_byte_block = seig_entry -> skip_byte_block ; if ( key_info ) * key_info = seig_entry -> key_info ; if ( key_info_size ) * key_info_size = seig_entry -> key_info_size ; if ( container_type ) * container_type = GF_ISOM_BOX_TYPE_SENC ; } else { if ( ! trak -> moov -> mov -> is_smooth ) { trak -> moov -> mov -> is_smooth = GF_TRUE ; GF_LOG ( GF_LOG_WARNING , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>senc<S2SV_blank>box<S2SV_blank>without<S2SV_blank>tenc,<S2SV_blank>assuming<S2SV_blank>MS<S2SV_blank>smooth+piff\\n"" ) ) ; } if ( default_IsEncrypted ) * default_IsEncrypted = GF_TRUE ; if ( container_type ) * container_type = GF_ISOM_BOX_UUID_PSEC ; } } if ( container_type && trak -> sample_encryption ) { if ( trak -> sample_encryption -> type == GF_ISOM_BOX_TYPE_SENC ) * container_type = GF_ISOM_BOX_TYPE_SENC ; else if ( trak -> sample_encryption -> type == GF_ISOM_BOX_TYPE_UUID ) * container_type = ( ( GF_UUIDBox * ) trak -> sample_encryption ) -> internal_4cc ; } }
","<S2SV_ModStart> ; if ( seig_entry &&
"
439,"CWE-119 static int get_registers ( rtl8150_t * dev , u16 indx , u16 size , void * data ) { <S2SV_StartBug> return usb_control_msg ( dev -> udev , usb_rcvctrlpipe ( dev -> udev , 0 ) , <S2SV_EndBug> RTL8150_REQ_GET_REGS , RTL8150_REQT_READ , <S2SV_StartBug> indx , 0 , data , size , 500 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> data ) { void * buf ; int ret ; buf = kmalloc ( size , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM ; ret = <S2SV_ModEnd> usb_control_msg ( dev <S2SV_ModStart> , 0 , buf <S2SV_ModEnd> , size , <S2SV_ModStart> 500 ) ; if ( ret > 0 && ret <= size ) memcpy ( data , buf , ret ) ; kfree ( buf ) ; return ret ;
"
440,"CWE-617 int pci_emul_add_capability ( struct pci_vdev * dev , u_char * capdata , int caplen ) { int i , capoff , reallen ; uint16_t sts ; <S2SV_StartBug> assert ( caplen > 0 ) ; <S2SV_EndBug> reallen = roundup2 ( caplen , 4 ) ; sts = pci_get_cfgdata16 ( dev , PCIR_STATUS ) ; if ( ( sts & PCIM_STATUS_CAPPRESENT ) == 0 ) capoff = CAP_START_OFFSET ; else capoff = dev -> capend + 1 ; if ( capoff + reallen > PCI_REGMAX + 1 ) return - 1 ; if ( ( sts & PCIM_STATUS_CAPPRESENT ) == 0 ) { pci_set_cfgdata8 ( dev , PCIR_CAP_PTR , capoff ) ; pci_set_cfgdata16 ( dev , PCIR_STATUS , sts | PCIM_STATUS_CAPPRESENT ) ; } else pci_set_cfgdata8 ( dev , dev -> prevcap + 1 , capoff ) ; for ( i = 0 ; i < caplen ; i ++ ) pci_set_cfgdata8 ( dev , capoff + i , capdata [ i ] ) ; pci_set_cfgdata8 ( dev , capoff + 1 , 0 ) ; dev -> prevcap = capoff ; dev -> capend = capoff + reallen - 1 ; return 0 ; }
","<S2SV_ModStart> uint16_t sts ; <S2SV_ModEnd> reallen = roundup2
"
441,"CWE-119 static int read_public_key ( RSA * rsa ) { int r ; sc_path_t path ; sc_file_t * file ; u8 buf [ 2048 ] , * p = buf ; size_t bufsize , keysize ; r = select_app_df ( ) ; if ( r ) return 1 ; sc_format_path ( ""I1012"" , & path ) ; r = sc_select_file ( card , & path , & file ) ; if ( r ) { fprintf ( stderr , ""Unable<S2SV_blank>to<S2SV_blank>select<S2SV_blank>public<S2SV_blank>key<S2SV_blank>file:<S2SV_blank>%s\\n"" , sc_strerror ( r ) ) ; return 2 ; } <S2SV_StartBug> bufsize = file -> size ; <S2SV_EndBug> sc_file_free ( file ) ; r = sc_read_binary ( card , 0 , buf , bufsize , 0 ) ; if ( r < 0 ) { fprintf ( stderr , ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>public<S2SV_blank>key<S2SV_blank>file:<S2SV_blank>%s\\n"" , sc_strerror ( r ) ) ; return 2 ; } bufsize = r ; do { if ( bufsize < 4 ) return 3 ; keysize = ( p [ 0 ] << 8 ) | p [ 1 ] ; if ( keysize == 0 ) break ; if ( keysize < 3 ) return 3 ; if ( p [ 2 ] == opt_key_num ) break ; p += keysize ; bufsize -= keysize ; } while ( 1 ) ; if ( keysize == 0 ) { printf ( ""Key<S2SV_blank>number<S2SV_blank>%d<S2SV_blank>not<S2SV_blank>found.\\n"" , opt_key_num ) ; return 2 ; } return parse_public_key ( p , keysize , rsa ) ; }
","<S2SV_ModStart> } bufsize = MIN ( <S2SV_ModStart> file -> size , sizeof buf )
"
442,"CWE-416 static void snd_usb_mixer_free ( struct usb_mixer_interface * mixer ) <S2SV_StartBug> { <S2SV_EndBug> kfree ( mixer -> id_elems ) ; if ( mixer -> urb ) { kfree ( mixer -> urb -> transfer_buffer ) ; usb_free_urb ( mixer -> urb ) ; } usb_free_urb ( mixer -> rc_urb ) ; kfree ( mixer -> rc_setup_packet ) ; kfree ( mixer ) ; }
","<S2SV_ModStart> mixer ) { snd_usb_mixer_disconnect ( mixer ) ;
"
443,"CWE-416 static int usb_audio_probe ( struct usb_interface * intf , const struct usb_device_id * usb_id ) { struct usb_device * dev = interface_to_usbdev ( intf ) ; const struct snd_usb_audio_quirk * quirk = ( const struct snd_usb_audio_quirk * ) usb_id -> driver_info ; struct snd_usb_audio * chip ; int i , err ; struct usb_host_interface * alts ; int ifnum ; u32 id ; alts = & intf -> altsetting [ 0 ] ; ifnum = get_iface_desc ( alts ) -> bInterfaceNumber ; id = USB_ID ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( get_alias_id ( dev , & id ) ) quirk = get_alias_quirk ( dev , id ) ; if ( quirk && quirk -> ifnum >= 0 && ifnum != quirk -> ifnum ) return - ENXIO ; err = snd_usb_apply_boot_quirk ( dev , intf , quirk , id ) ; if ( err < 0 ) return err ; chip = NULL ; mutex_lock ( & register_mutex ) ; for ( i = 0 ; i < SNDRV_CARDS ; i ++ ) { if ( usb_chip [ i ] && usb_chip [ i ] -> dev == dev ) { if ( atomic_read ( & usb_chip [ i ] -> shutdown ) ) { dev_err ( & dev -> dev , ""USB<S2SV_blank>device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>the<S2SV_blank>shutdown<S2SV_blank>state,<S2SV_blank>cannot<S2SV_blank>create<S2SV_blank>a<S2SV_blank>card<S2SV_blank>instance\\n"" ) ; err = - EIO ; goto __error ; } chip = usb_chip [ i ] ; atomic_inc ( & chip -> active ) ; break ; } } if ( ! chip ) { for ( i = 0 ; i < SNDRV_CARDS ; i ++ ) if ( ! usb_chip [ i ] && ( vid [ i ] == - 1 || vid [ i ] == USB_ID_VENDOR ( id ) ) && ( pid [ i ] == - 1 || pid [ i ] == USB_ID_PRODUCT ( id ) ) ) { if ( enable [ i ] ) { err = snd_usb_audio_create ( intf , dev , i , quirk , id , & chip ) ; if ( err < 0 ) goto __error ; chip -> pm_intf = intf ; break ; } else if ( vid [ i ] != - 1 || pid [ i ] != - 1 ) { dev_info ( & dev -> dev , ""device<S2SV_blank>(%04x:%04x)<S2SV_blank>is<S2SV_blank>disabled\\n"" , USB_ID_VENDOR ( id ) , USB_ID_PRODUCT ( id ) ) ; err = - ENOENT ; goto __error ; } } if ( ! chip ) { dev_err ( & dev -> dev , ""no<S2SV_blank>available<S2SV_blank>usb<S2SV_blank>audio<S2SV_blank>device\\n"" ) ; err = - ENODEV ; goto __error ; } } dev_set_drvdata ( & dev -> dev , chip ) ; if ( ! chip -> ctrl_intf ) chip -> ctrl_intf = alts ; chip -> txfr_quirk = 0 ; err = 1 ; if ( quirk && quirk -> ifnum != QUIRK_NO_INTERFACE ) { err = snd_usb_create_quirk ( chip , intf , & usb_audio_driver , quirk ) ; if ( err < 0 ) goto __error ; } if ( err > 0 ) { err = snd_usb_create_streams ( chip , ifnum ) ; if ( err < 0 ) goto __error ; err = snd_usb_create_mixer ( chip , ifnum , ignore_ctl_error ) ; if ( err < 0 ) goto __error ; } err = snd_card_register ( chip -> card ) ; if ( err < 0 ) goto __error ; usb_chip [ chip -> index ] = chip ; chip -> num_interfaces ++ ; usb_set_intfdata ( intf , chip ) ; atomic_dec ( & chip -> active ) ; mutex_unlock ( & register_mutex ) ; return 0 ; __error : if ( chip ) { <S2SV_StartBug> if ( ! chip -> num_interfaces ) <S2SV_EndBug> snd_card_free ( chip -> card ) ; <S2SV_StartBug> atomic_dec ( & chip -> active ) ; <S2SV_EndBug> } mutex_unlock ( & register_mutex ) ; return err ; }
","<S2SV_ModStart> chip ) { atomic_dec ( & chip -> active ) ; <S2SV_ModStart> card ) ; <S2SV_ModEnd> } mutex_unlock (
"
444,"CWE-362 static int <S2SV_StartBug> mptctl_eventenable ( unsigned long arg ) <S2SV_EndBug> { struct mpt_ioctl_eventenable __user * uarg = ( void __user * ) arg ; <S2SV_StartBug> struct mpt_ioctl_eventenable karg ; <S2SV_EndBug> MPT_ADAPTER * ioc ; int iocnum ; if ( copy_from_user ( & karg , uarg , sizeof ( struct mpt_ioctl_eventenable ) ) ) { printk ( KERN_ERR MYNAM ""%s@%d::mptctl_eventenable<S2SV_blank>-<S2SV_blank>"" ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>mpt_ioctl_eventenable<S2SV_blank>struct<S2SV_blank>@<S2SV_blank>%p\\n"" , __FILE__ , __LINE__ , uarg ) ; <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> } if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || ( ioc == NULL ) ) { printk ( KERN_DEBUG MYNAM ""%s::mptctl_eventenable()<S2SV_blank>@%d<S2SV_blank>-<S2SV_blank>ioc%d<S2SV_blank>not<S2SV_blank>found!\\n"" , __FILE__ , __LINE__ , iocnum ) ; return - ENODEV ; } dctlprintk ( ioc , printk ( MYIOC_s_DEBUG_FMT ""mptctl_eventenable<S2SV_blank>called.\\n"" , ioc -> name ) ) ; if ( ioc -> events == NULL ) { int sz = MPTCTL_EVENT_LOG_SIZE * sizeof ( MPT_IOCTL_EVENTS ) ; ioc -> events = kzalloc ( sz , GFP_KERNEL ) ; if ( ! ioc -> events ) { printk ( MYIOC_s_ERR_FMT "":<S2SV_blank>ERROR<S2SV_blank>-<S2SV_blank>Insufficient<S2SV_blank>memory<S2SV_blank>to<S2SV_blank>add<S2SV_blank>adapter!\\n"" , ioc -> name ) ; return - ENOMEM ; } ioc -> alloc_total += sz ; ioc -> eventContext = 0 ; } ioc -> eventTypes = karg . eventTypes ; return 0 ; }
","<S2SV_ModStart> int mptctl_eventenable ( MPT_ADAPTER * ioc , <S2SV_ModStart> struct mpt_ioctl_eventenable karg <S2SV_ModEnd> ; if ( <S2SV_ModStart> return - EFAULT <S2SV_ModEnd> ; } dctlprintk
"
445,"CWE-119 static void videobuf_vm_open ( struct vm_area_struct * vma ) { struct videobuf_mapping * map = vma -> vm_private_data ; <S2SV_StartBug> dprintk ( 2 , ""vm_open<S2SV_blank>%p<S2SV_blank>[count=%d,vma=%08lx-%08lx]\\n"" , map , <S2SV_EndBug> map -> count , vma -> vm_start , vma -> vm_end ) ; map -> count ++ ; }
","<S2SV_ModStart> ( 2 , ""vm_open<S2SV_blank>%p<S2SV_blank>[count=%u,vma=%08lx-%08lx]\\n"" <S2SV_ModEnd> , map ,
"
446,"CWE-119 static int host_start ( struct ci13xxx * ci ) { struct usb_hcd * hcd ; struct ehci_hcd * ehci ; int ret ; if ( usb_disabled ( ) ) return - ENODEV ; hcd = usb_create_hcd ( & ci_ehci_hc_driver , ci -> dev , dev_name ( ci -> dev ) ) ; if ( ! hcd ) return - ENOMEM ; dev_set_drvdata ( ci -> dev , ci ) ; hcd -> rsrc_start = ci -> hw_bank . phys ; hcd -> rsrc_len = ci -> hw_bank . size ; hcd -> regs = ci -> hw_bank . abs ; hcd -> has_tt = 1 ; hcd -> power_budget = ci -> platdata -> power_budget ; hcd -> phy = ci -> transceiver ; ehci = hcd_to_ehci ( hcd ) ; ehci -> caps = ci -> hw_bank . cap ; ehci -> has_hostpc = ci -> hw_bank . lpm ; ret = usb_add_hcd ( hcd , 0 , 0 ) ; if ( ret ) usb_put_hcd ( hcd ) ; else ci -> hcd = hcd ; <S2SV_StartBug> return ret ; <S2SV_EndBug> }
","<S2SV_ModStart> = hcd ; if ( ci -> platdata -> flags & CI13XXX_DISABLE_STREAMING ) hw_write ( ci , OP_USBMODE , USBMODE_CI_SDIS , USBMODE_CI_SDIS ) ;
"
447,"CWE-20 static int sco_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct sco_pinfo * pi = sco_pi ( sk ) ; lock_sock ( sk ) ; if ( sk -> sk_state == BT_CONNECT2 && test_bit ( BT_SK_DEFER_SETUP , & bt_sk ( sk ) -> flags ) ) { sco_conn_defer_accept ( pi -> conn -> hcon , pi -> setting ) ; sk -> sk_state = BT_CONFIG ; <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> release_sock ( sk ) ; return 0 ; } release_sock ( sk ) ; return bt_sock_recvmsg ( iocb , sock , msg , len , flags ) ; }
","<S2SV_ModStart> = BT_CONFIG ; <S2SV_ModEnd> release_sock ( sk
"
448,"CWE-119 static int rd_inter4x4_uv ( VP8_COMP * cpi , MACROBLOCK * x , int * rate , int * distortion , int fullpixel ) <S2SV_StartBug> { <S2SV_EndBug> vp8_build_inter4x4_predictors_mbuv ( & x -> e_mbd ) ; vp8_subtract_mbuv ( x -> src_diff , x -> src . u_buffer , x -> src . v_buffer , x -> src . uv_stride , & x -> e_mbd . predictor [ 256 ] , & x -> e_mbd . predictor [ 320 ] , 8 ) ; vp8_transform_mbuv ( x ) ; vp8_quantize_mbuv ( x ) ; * rate = rd_cost_mbuv ( x ) ; * distortion = vp8_mbuverror ( x ) / 4 ; return RDCOST ( x -> rdmult , x -> rddiv , * rate , * distortion ) ; }
","<S2SV_ModStart> fullpixel ) { ( void ) cpi ; ( void ) fullpixel ;
"
449,"CWE-000 int ocfs2_setattr ( struct dentry * dentry , struct iattr * attr ) { int status = 0 , size_change ; int inode_locked = 0 ; struct inode * inode = d_inode ( dentry ) ; struct super_block * sb = inode -> i_sb ; struct ocfs2_super * osb = OCFS2_SB ( sb ) ; struct buffer_head * bh = NULL ; handle_t * handle = NULL ; struct dquot * transfer_to [ MAXQUOTAS ] = { } ; int qtype ; int had_lock ; struct ocfs2_lock_holder oh ; trace_ocfs2_setattr ( inode , dentry , ( unsigned long long ) OCFS2_I ( inode ) -> ip_blkno , dentry -> d_name . len , dentry -> d_name . name , attr -> ia_valid , attr -> ia_mode , from_kuid ( & init_user_ns , attr -> ia_uid ) , from_kgid ( & init_user_ns , attr -> ia_gid ) ) ; if ( S_ISLNK ( inode -> i_mode ) ) attr -> ia_valid &= ~ ATTR_SIZE ; # define OCFS2_VALID_ATTRS ( ATTR_ATIME | ATTR_MTIME | ATTR_CTIME | ATTR_SIZE | ATTR_GID | ATTR_UID | ATTR_MODE ) if ( ! ( attr -> ia_valid & OCFS2_VALID_ATTRS ) ) return 0 ; status = setattr_prepare ( dentry , attr ) ; if ( status ) return status ; if ( is_quota_modification ( inode , attr ) ) { status = dquot_initialize ( inode ) ; if ( status ) return status ; } size_change = S_ISREG ( inode -> i_mode ) && attr -> ia_valid & ATTR_SIZE ; if ( size_change ) { <S2SV_StartBug> status = ocfs2_rw_lock ( inode , 1 ) ; <S2SV_EndBug> if ( status < 0 ) { mlog_errno ( status ) ; goto bail ; } } had_lock = ocfs2_inode_lock_tracker ( inode , & bh , 1 , & oh ) ; if ( had_lock < 0 ) { status = had_lock ; goto bail_unlock_rw ; } else if ( had_lock ) { mlog ( ML_ERROR , ""Another<S2SV_blank>case<S2SV_blank>of<S2SV_blank>recursive<S2SV_blank>locking:\\n"" ) ; dump_stack ( ) ; } inode_locked = 1 ; if ( size_change ) { status = inode_newsize_ok ( inode , attr -> ia_size ) ; if ( status ) <S2SV_StartBug> goto bail_unlock ; <S2SV_EndBug> inode_dio_wait ( inode ) ; if ( i_size_read ( inode ) >= attr -> ia_size ) { if ( ocfs2_should_order_data ( inode ) ) { status = ocfs2_begin_ordered_truncate ( inode , attr -> ia_size ) ; if ( status ) goto bail_unlock ; } status = ocfs2_truncate_file ( inode , bh , attr -> ia_size ) ; } else status = ocfs2_extend_file ( inode , bh , attr -> ia_size ) ; if ( status < 0 ) { if ( status != - ENOSPC ) mlog_errno ( status ) ; status = - ENOSPC ; goto bail_unlock ; } } if ( ( attr -> ia_valid & ATTR_UID && ! uid_eq ( attr -> ia_uid , inode -> i_uid ) ) || ( attr -> ia_valid & ATTR_GID && ! gid_eq ( attr -> ia_gid , inode -> i_gid ) ) ) { if ( attr -> ia_valid & ATTR_UID && ! uid_eq ( attr -> ia_uid , inode -> i_uid ) && OCFS2_HAS_RO_COMPAT_FEATURE ( sb , OCFS2_FEATURE_RO_COMPAT_USRQUOTA ) ) { transfer_to [ USRQUOTA ] = dqget ( sb , make_kqid_uid ( attr -> ia_uid ) ) ; if ( IS_ERR ( transfer_to [ USRQUOTA ] ) ) { status = PTR_ERR ( transfer_to [ USRQUOTA ] ) ; goto bail_unlock ; } } if ( attr -> ia_valid & ATTR_GID && ! gid_eq ( attr -> ia_gid , inode -> i_gid ) && OCFS2_HAS_RO_COMPAT_FEATURE ( sb , OCFS2_FEATURE_RO_COMPAT_GRPQUOTA ) ) { transfer_to [ GRPQUOTA ] = dqget ( sb , make_kqid_gid ( attr -> ia_gid ) ) ; if ( IS_ERR ( transfer_to [ GRPQUOTA ] ) ) { status = PTR_ERR ( transfer_to [ GRPQUOTA ] ) ; goto bail_unlock ; } } handle = ocfs2_start_trans ( osb , OCFS2_INODE_UPDATE_CREDITS + 2 * ocfs2_quota_trans_credits ( sb ) ) ; if ( IS_ERR ( handle ) ) { status = PTR_ERR ( handle ) ; mlog_errno ( status ) ; goto bail_unlock ; } status = __dquot_transfer ( inode , transfer_to ) ; if ( status < 0 ) goto bail_commit ; } else { handle = ocfs2_start_trans ( osb , OCFS2_INODE_UPDATE_CREDITS ) ; if ( IS_ERR ( handle ) ) { status = PTR_ERR ( handle ) ; mlog_errno ( status ) ; goto bail_unlock ; } } setattr_copy ( inode , attr ) ; mark_inode_dirty ( inode ) ; status = ocfs2_mark_inode_dirty ( handle , inode , bh ) ; if ( status < 0 ) mlog_errno ( status ) ; bail_commit : ocfs2_commit_trans ( osb , handle ) ; bail_unlock : if ( status && inode_locked ) { ocfs2_inode_unlock_tracker ( inode , 1 , & oh , had_lock ) ; inode_locked = 0 ; } bail_unlock_rw : if ( size_change ) ocfs2_rw_unlock ( inode , 1 ) ; bail : for ( qtype = 0 ; qtype < OCFS2_MAXQUOTAS ; qtype ++ ) dqput ( transfer_to [ qtype ] ) ; if ( ! status && attr -> ia_valid & ATTR_MODE ) { status = ocfs2_acl_chmod ( inode , bh ) ; if ( status < 0 ) mlog_errno ( status ) ; } if ( inode_locked ) ocfs2_inode_unlock_tracker ( inode , 1 , & oh , had_lock ) ; brelse ( bh ) ; return status ; }
","<S2SV_ModStart> size_change ) { inode_dio_wait ( inode ) ; <S2SV_ModStart> ) goto bail_unlock <S2SV_ModEnd> ; if (
"
450,"CWE-119 static __forceinline void draw_line ( float * output , int x0 , int y0 , int x1 , int y1 , int n ) { int dy = y1 - y0 ; int adx = x1 - x0 ; int ady = abs ( dy ) ; int base ; int x = x0 , y = y0 ; int err = 0 ; int sy ; # ifdef STB_VORBIS_DIVIDE_TABLE if ( adx < DIVTAB_DENOM && ady < DIVTAB_NUMER ) { if ( dy < 0 ) { base = - integer_divide_table [ ady ] [ adx ] ; sy = base - 1 ; } else { base = integer_divide_table [ ady ] [ adx ] ; sy = base + 1 ; } } else { base = dy / adx ; if ( dy < 0 ) sy = base - 1 ; else sy = base + 1 ; } # else base = dy / adx ; if ( dy < 0 ) sy = base - 1 ; else sy = base + 1 ; # endif ady -= abs ( base ) * adx ; if ( x1 > n ) x1 = n ; if ( x < x1 ) { <S2SV_StartBug> LINE_OP ( output [ x ] , inverse_db_table [ y ] ) ; <S2SV_EndBug> for ( ++ x ; x < x1 ; ++ x ) { err += ady ; if ( err >= adx ) { err -= adx ; y += sy ; } else y += base ; <S2SV_StartBug> LINE_OP ( output [ x ] , inverse_db_table [ y ] ) ; <S2SV_EndBug> } } }
","<S2SV_ModStart> inverse_db_table [ y & 255 <S2SV_ModStart> inverse_db_table [ y & 255
"
451,"CWE-476 static struct o2nm_cluster * to_o2nm_cluster_from_node ( struct o2nm_node * node ) { <S2SV_StartBug> return to_o2nm_cluster ( node -> nd_item . ci_parent -> ci_parent ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> node ) { if ( node -> nd_item . ci_parent ) <S2SV_ModStart> ci_parent ) ; else return NULL ;
"
452,"CWE-369 static int mov_write_audio_tag ( AVFormatContext * s , AVIOContext * pb , MOVMuxContext * mov , MOVTrack * track ) { int64_t pos = avio_tell ( pb ) ; int version = 0 ; uint32_t tag = track -> tag ; if ( track -> mode == MODE_MOV ) { <S2SV_StartBug> if ( track -> timescale > UINT16_MAX ) { <S2SV_EndBug> if ( mov_get_lpcm_flags ( track -> par -> codec_id ) ) tag = AV_RL32 ( ""lpcm"" ) ; version = 2 ; } else if ( track -> audio_vbr || mov_pcm_le_gt16 ( track -> par -> codec_id ) || mov_pcm_be_gt16 ( track -> par -> codec_id ) || track -> par -> codec_id == AV_CODEC_ID_ADPCM_MS || track -> par -> codec_id == AV_CODEC_ID_ADPCM_IMA_WAV || track -> par -> codec_id == AV_CODEC_ID_QDM2 ) { version = 1 ; } } avio_wb32 ( pb , 0 ) ; if ( mov -> encryption_scheme != MOV_ENC_NONE ) { ffio_wfourcc ( pb , ""enca"" ) ; } else { avio_wl32 ( pb , tag ) ; } avio_wb32 ( pb , 0 ) ; avio_wb16 ( pb , 0 ) ; avio_wb16 ( pb , 1 ) ; avio_wb16 ( pb , version ) ; avio_wb16 ( pb , 0 ) ; avio_wb32 ( pb , 0 ) ; if ( version == 2 ) { avio_wb16 ( pb , 3 ) ; avio_wb16 ( pb , 16 ) ; avio_wb16 ( pb , 0xfffe ) ; avio_wb16 ( pb , 0 ) ; avio_wb32 ( pb , 0x00010000 ) ; avio_wb32 ( pb , 72 ) ; avio_wb64 ( pb , av_double2int ( track -> par -> sample_rate ) ) ; avio_wb32 ( pb , track -> par -> channels ) ; avio_wb32 ( pb , 0x7F000000 ) ; avio_wb32 ( pb , av_get_bits_per_sample ( track -> par -> codec_id ) ) ; avio_wb32 ( pb , mov_get_lpcm_flags ( track -> par -> codec_id ) ) ; avio_wb32 ( pb , track -> sample_size ) ; avio_wb32 ( pb , get_samples_per_packet ( track ) ) ; } else { if ( track -> mode == MODE_MOV ) { avio_wb16 ( pb , track -> par -> channels ) ; if ( track -> par -> codec_id == AV_CODEC_ID_PCM_U8 || track -> par -> codec_id == AV_CODEC_ID_PCM_S8 ) avio_wb16 ( pb , 8 ) ; else if ( track -> par -> codec_id == AV_CODEC_ID_ADPCM_G726 ) avio_wb16 ( pb , track -> par -> bits_per_coded_sample ) ; else avio_wb16 ( pb , 16 ) ; avio_wb16 ( pb , track -> audio_vbr ? - 2 : 0 ) ; } else { if ( track -> par -> codec_id == AV_CODEC_ID_FLAC || track -> par -> codec_id == AV_CODEC_ID_OPUS ) { avio_wb16 ( pb , track -> par -> channels ) ; } else { avio_wb16 ( pb , 2 ) ; } if ( track -> par -> codec_id == AV_CODEC_ID_FLAC ) { avio_wb16 ( pb , track -> par -> bits_per_raw_sample ) ; } else { avio_wb16 ( pb , 16 ) ; } avio_wb16 ( pb , 0 ) ; } avio_wb16 ( pb , 0 ) ; if ( track -> par -> codec_id == AV_CODEC_ID_OPUS ) avio_wb16 ( pb , 48000 ) ; else avio_wb16 ( pb , track -> par -> sample_rate <= UINT16_MAX ? track -> par -> sample_rate : 0 ) ; avio_wb16 ( pb , 0 ) ; } if ( version == 1 ) { if ( mov_pcm_le_gt16 ( track -> par -> codec_id ) || mov_pcm_be_gt16 ( track -> par -> codec_id ) ) avio_wb32 ( pb , 1 ) ; else avio_wb32 ( pb , track -> par -> frame_size ) ; avio_wb32 ( pb , track -> sample_size / track -> par -> channels ) ; avio_wb32 ( pb , track -> sample_size ) ; avio_wb32 ( pb , 2 ) ; } if ( track -> mode == MODE_MOV && ( track -> par -> codec_id == AV_CODEC_ID_AAC || track -> par -> codec_id == AV_CODEC_ID_AC3 || track -> par -> codec_id == AV_CODEC_ID_EAC3 || track -> par -> codec_id == AV_CODEC_ID_AMR_NB || track -> par -> codec_id == AV_CODEC_ID_ALAC || track -> par -> codec_id == AV_CODEC_ID_ADPCM_MS || track -> par -> codec_id == AV_CODEC_ID_ADPCM_IMA_WAV || track -> par -> codec_id == AV_CODEC_ID_QDM2 || ( mov_pcm_le_gt16 ( track -> par -> codec_id ) && version == 1 ) || ( mov_pcm_be_gt16 ( track -> par -> codec_id ) && version == 1 ) ) ) mov_write_wave_tag ( s , pb , track ) ; else if ( track -> tag == MKTAG ( 'm' , 'p' , '4' , 'a' ) ) mov_write_esds_tag ( pb , track ) ; else if ( track -> par -> codec_id == AV_CODEC_ID_AMR_NB ) mov_write_amr_tag ( pb , track ) ; else if ( track -> par -> codec_id == AV_CODEC_ID_AC3 ) mov_write_ac3_tag ( pb , track ) ; else if ( track -> par -> codec_id == AV_CODEC_ID_EAC3 ) mov_write_eac3_tag ( pb , track ) ; else if ( track -> par -> codec_id == AV_CODEC_ID_ALAC ) mov_write_extradata_tag ( pb , track ) ; else if ( track -> par -> codec_id == AV_CODEC_ID_WMAPRO ) mov_write_wfex_tag ( s , pb , track ) ; else if ( track -> par -> codec_id == AV_CODEC_ID_FLAC ) mov_write_dfla_tag ( pb , track ) ; else if ( track -> par -> codec_id == AV_CODEC_ID_OPUS ) mov_write_dops_tag ( pb , track ) ; else if ( track -> vos_len > 0 ) mov_write_glbl_tag ( pb , track ) ; if ( track -> mode == MODE_MOV && track -> par -> codec_type == AVMEDIA_TYPE_AUDIO ) mov_write_chan_tag ( s , pb , track ) ; if ( mov -> encryption_scheme != MOV_ENC_NONE ) { ff_mov_cenc_write_sinf_tag ( track , pb , mov -> encryption_kid ) ; } return update_size ( pb , pos ) ; }
","<S2SV_ModStart> timescale > UINT16_MAX || ! track -> par -> channels
"
453,"CWE-119 <S2SV_StartBug> static void <S2SV_EndBug> swabHorAcc16 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { uint16 * wp = ( uint16 * ) cp0 ; tmsize_t wc = cc / 2 ; TIFFSwabArrayOfShort ( wp , wc ) ; <S2SV_StartBug> horAcc16 ( tif , cp0 , cc ) ; <S2SV_EndBug> }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> swabHorAcc16 ( TIFF <S2SV_ModStart> wc ) ; return
"
454,"CWE-787 static void seamless_process ( STREAM s ) { unsigned int pkglen ; <S2SV_StartBug> char * buf ; <S2SV_EndBug> pkglen = s -> end - s -> p ; buf = xmalloc ( pkglen + 1 ) ; STRNCPY ( buf , ( char * ) s -> p , pkglen + 1 ) ; str_handle_lines ( buf , & seamless_rest , seamless_line_handler , NULL ) ; xfree ( buf ) ; }
","<S2SV_ModStart> * buf ; struct stream packet = * s ; if ( ! s_check ( s ) ) { rdp_protocol_error ( ""seamless_process(),<S2SV_blank>stream<S2SV_blank>is<S2SV_blank>in<S2SV_blank>unstable<S2SV_blank>state"" , & packet ) ; }
"
455,"CWE-000 static PyObject * get_value ( PyObject * self , const char * buffer , int * position , int type , int max , PyObject * as_class , unsigned char tz_aware , unsigned char uuid_subtype ) { struct module_state * state = GETSTATE ( self ) ; PyObject * value ; PyObject * error ; switch ( type ) { case 1 : { double d ; if ( max < 8 ) { goto invalid ; } memcpy ( & d , buffer + * position , 8 ) ; value = PyFloat_FromDouble ( d ) ; if ( ! value ) { return NULL ; } * position += 8 ; break ; } case 2 : case 14 : { int value_length = ( ( int * ) ( buffer + * position ) ) [ 0 ] - 1 ; if ( max < value_length ) { goto invalid ; } * position += 4 ; value = PyUnicode_DecodeUTF8 ( buffer + * position , value_length , ""strict"" ) ; if ( ! value ) { return NULL ; } * position += value_length + 1 ; break ; } case 3 : { int size ; memcpy ( & size , buffer + * position , 4 ) ; if ( max < size ) { goto invalid ; } value = elements_to_dict ( self , buffer + * position + 4 , size - 5 , as_class , tz_aware , uuid_subtype ) ; if ( ! value ) { return NULL ; } if ( strcmp ( buffer + * position + 5 , ""$ref"" ) == 0 ) { PyObject * dbref ; PyObject * collection = PyDict_GetItemString ( value , ""$ref"" ) ; PyObject * id = PyDict_GetItemString ( value , ""$id"" ) ; PyObject * database = PyDict_GetItemString ( value , ""$db"" ) ; Py_INCREF ( collection ) ; PyDict_DelItemString ( value , ""$ref"" ) ; <S2SV_StartBug> Py_INCREF ( id ) ; <S2SV_EndBug> <S2SV_StartBug> PyDict_DelItemString ( value , ""$id"" ) ; <S2SV_EndBug> if ( database == NULL ) { database = Py_None ; Py_INCREF ( database ) ; } else { Py_INCREF ( database ) ; PyDict_DelItemString ( value , ""$db"" ) ; } dbref = PyObject_CallFunctionObjArgs ( state -> DBRef , collection , id , database , value , NULL ) ; Py_DECREF ( value ) ; value = dbref ; Py_DECREF ( id ) ; Py_DECREF ( collection ) ; Py_DECREF ( database ) ; if ( ! value ) { return NULL ; } } * position += size ; break ; } case 4 : { int size , end ; memcpy ( & size , buffer + * position , 4 ) ; if ( max < size ) { goto invalid ; } end = * position + size - 1 ; * position += 4 ; value = PyList_New ( 0 ) ; if ( ! value ) { return NULL ; } while ( * position < end ) { PyObject * to_append ; int type = ( int ) buffer [ ( * position ) ++ ] ; int key_size = strlen ( buffer + * position ) ; * position += key_size + 1 ; to_append = get_value ( self , buffer , position , type , max - key_size , as_class , tz_aware , uuid_subtype ) ; if ( ! to_append ) { Py_DECREF ( value ) ; return NULL ; } PyList_Append ( value , to_append ) ; Py_DECREF ( to_append ) ; } ( * position ) ++ ; break ; } case 5 : { PyObject * data ; PyObject * st ; int length , subtype ; memcpy ( & length , buffer + * position , 4 ) ; if ( max < length ) { goto invalid ; } subtype = ( unsigned char ) buffer [ * position + 4 ] ; # if PY_MAJOR_VERSION >= 3 if ( subtype == 0 ) { value = PyBytes_FromStringAndSize ( buffer + * position + 5 , length ) ; * position += length + 5 ; break ; } if ( subtype == 2 ) { data = PyBytes_FromStringAndSize ( buffer + * position + 9 , length - 4 ) ; } else { data = PyBytes_FromStringAndSize ( buffer + * position + 5 , length ) ; } # else if ( subtype == 2 ) { data = PyString_FromStringAndSize ( buffer + * position + 9 , length - 4 ) ; } else { data = PyString_FromStringAndSize ( buffer + * position + 5 , length ) ; } # endif if ( ! data ) { return NULL ; } if ( ( subtype == 3 || subtype == 4 ) && state -> UUID ) { PyObject * kwargs ; PyObject * args = PyTuple_New ( 0 ) ; if ( ! args ) { Py_DECREF ( data ) ; return NULL ; } kwargs = PyDict_New ( ) ; if ( ! kwargs ) { Py_DECREF ( data ) ; Py_DECREF ( args ) ; return NULL ; } assert ( length == 16 ) ; if ( uuid_subtype == CSHARP_LEGACY ) { PyDict_SetItemString ( kwargs , ""bytes_le"" , data ) ; } else { if ( uuid_subtype == JAVA_LEGACY ) { char big_endian [ 16 ] ; _fix_java ( buffer + * position + 5 , big_endian ) ; Py_DECREF ( data ) ; # if PY_MAJOR_VERSION >= 3 data = PyBytes_FromStringAndSize ( big_endian , length ) ; # else data = PyString_FromStringAndSize ( big_endian , length ) ; # endif } PyDict_SetItemString ( kwargs , ""bytes"" , data ) ; } value = PyObject_Call ( state -> UUID , args , kwargs ) ; Py_DECREF ( args ) ; Py_DECREF ( kwargs ) ; Py_DECREF ( data ) ; if ( ! value ) { return NULL ; } * position += length + 5 ; break ; } # if PY_MAJOR_VERSION >= 3 st = PyLong_FromLong ( subtype ) ; # else st = PyInt_FromLong ( subtype ) ; # endif if ( ! st ) { Py_DECREF ( data ) ; return NULL ; } value = PyObject_CallFunctionObjArgs ( state -> Binary , data , st , NULL ) ; Py_DECREF ( st ) ; Py_DECREF ( data ) ; if ( ! value ) { return NULL ; } * position += length + 5 ; break ; } case 6 : case 10 : { value = Py_None ; Py_INCREF ( value ) ; break ; } case 7 : { if ( max < 12 ) { goto invalid ; } # if PY_MAJOR_VERSION >= 3 value = PyObject_CallFunction ( state -> ObjectId , ""y#"" , buffer + * position , 12 ) ; # else value = PyObject_CallFunction ( state -> ObjectId , ""s#"" , buffer + * position , 12 ) ; # endif if ( ! value ) { return NULL ; } * position += 12 ; break ; } case 8 : { value = buffer [ ( * position ) ++ ] ? Py_True : Py_False ; Py_INCREF ( value ) ; break ; } case 9 : { PyObject * naive ; PyObject * replace ; PyObject * args ; PyObject * kwargs ; if ( max < 8 ) { goto invalid ; } naive = datetime_from_millis ( * ( long long * ) ( buffer + * position ) ) ; * position += 8 ; if ( ! tz_aware ) { value = naive ; break ; } if ( ! naive ) { return NULL ; } replace = PyObject_GetAttrString ( naive , ""replace"" ) ; Py_DECREF ( naive ) ; if ( ! replace ) { return NULL ; } args = PyTuple_New ( 0 ) ; if ( ! args ) { Py_DECREF ( replace ) ; return NULL ; } kwargs = PyDict_New ( ) ; if ( ! kwargs ) { Py_DECREF ( replace ) ; Py_DECREF ( args ) ; return NULL ; } if ( PyDict_SetItemString ( kwargs , ""tzinfo"" , state -> UTC ) == - 1 ) { Py_DECREF ( replace ) ; Py_DECREF ( args ) ; Py_DECREF ( kwargs ) ; return NULL ; } value = PyObject_Call ( replace , args , kwargs ) ; Py_DECREF ( replace ) ; Py_DECREF ( args ) ; Py_DECREF ( kwargs ) ; break ; } case 11 : { PyObject * pattern ; int flags_length , flags , i ; int pattern_length = strlen ( buffer + * position ) ; if ( max < pattern_length ) { goto invalid ; } pattern = PyUnicode_DecodeUTF8 ( buffer + * position , pattern_length , ""strict"" ) ; if ( ! pattern ) { return NULL ; } * position += pattern_length + 1 ; flags_length = strlen ( buffer + * position ) ; if ( max < pattern_length + flags_length ) { Py_DECREF ( pattern ) ; goto invalid ; } flags = 0 ; for ( i = 0 ; i < flags_length ; i ++ ) { if ( buffer [ * position + i ] == 'i' ) { flags |= 2 ; } else if ( buffer [ * position + i ] == 'l' ) { flags |= 4 ; } else if ( buffer [ * position + i ] == 'm' ) { flags |= 8 ; } else if ( buffer [ * position + i ] == 's' ) { flags |= 16 ; } else if ( buffer [ * position + i ] == 'u' ) { flags |= 32 ; } else if ( buffer [ * position + i ] == 'x' ) { flags |= 64 ; } } * position += flags_length + 1 ; value = PyObject_CallFunction ( state -> RECompile , ""Oi"" , pattern , flags ) ; Py_DECREF ( pattern ) ; break ; } case 12 : { int collection_length ; PyObject * collection ; PyObject * id ; * position += 4 ; collection_length = strlen ( buffer + * position ) ; if ( max < collection_length ) { goto invalid ; } collection = PyUnicode_DecodeUTF8 ( buffer + * position , collection_length , ""strict"" ) ; if ( ! collection ) { return NULL ; } * position += collection_length + 1 ; if ( max < collection_length + 12 ) { Py_DECREF ( collection ) ; goto invalid ; } id = PyObject_CallFunction ( state -> ObjectId , ""s#"" , buffer + * position , 12 ) ; if ( ! id ) { Py_DECREF ( collection ) ; return NULL ; } * position += 12 ; value = PyObject_CallFunctionObjArgs ( state -> DBRef , collection , id , NULL ) ; Py_DECREF ( collection ) ; Py_DECREF ( id ) ; break ; } case 13 : { PyObject * code ; int value_length = ( ( int * ) ( buffer + * position ) ) [ 0 ] - 1 ; if ( max < value_length ) { goto invalid ; } * position += 4 ; code = PyUnicode_DecodeUTF8 ( buffer + * position , value_length , ""strict"" ) ; if ( ! code ) { return NULL ; } * position += value_length + 1 ; value = PyObject_CallFunctionObjArgs ( state -> Code , code , NULL , NULL ) ; Py_DECREF ( code ) ; break ; } case 15 : { int code_length , scope_size ; PyObject * code ; PyObject * scope ; * position += 8 ; code_length = strlen ( buffer + * position ) ; if ( max < 8 + code_length ) { goto invalid ; } code = PyUnicode_DecodeUTF8 ( buffer + * position , code_length , ""strict"" ) ; if ( ! code ) { return NULL ; } * position += code_length + 1 ; memcpy ( & scope_size , buffer + * position , 4 ) ; scope = elements_to_dict ( self , buffer + * position + 4 , scope_size - 5 , ( PyObject * ) & PyDict_Type , tz_aware , uuid_subtype ) ; if ( ! scope ) { Py_DECREF ( code ) ; return NULL ; } * position += scope_size ; value = PyObject_CallFunctionObjArgs ( state -> Code , code , scope , NULL ) ; Py_DECREF ( code ) ; Py_DECREF ( scope ) ; break ; } case 16 : { int i ; if ( max < 4 ) { goto invalid ; } memcpy ( & i , buffer + * position , 4 ) ; # if PY_MAJOR_VERSION >= 3 value = PyLong_FromLong ( i ) ; # else value = PyInt_FromLong ( i ) ; # endif if ( ! value ) { return NULL ; } * position += 4 ; break ; } case 17 : { unsigned int time , inc ; if ( max < 8 ) { goto invalid ; } memcpy ( & inc , buffer + * position , 4 ) ; memcpy ( & time , buffer + * position + 4 , 4 ) ; value = PyObject_CallFunction ( state -> Timestamp , ""II"" , time , inc ) ; if ( ! value ) { return NULL ; } * position += 8 ; break ; } case 18 : { long long ll ; if ( max < 8 ) { goto invalid ; } memcpy ( & ll , buffer + * position , 8 ) ; value = PyLong_FromLongLong ( ll ) ; if ( ! value ) { return NULL ; } * position += 8 ; break ; } case - 1 : { value = PyObject_CallFunctionObjArgs ( state -> MinKey , NULL ) ; break ; } case 127 : { value = PyObject_CallFunctionObjArgs ( state -> MaxKey , NULL ) ; break ; } default : { PyObject * InvalidDocument = _error ( ""InvalidDocument"" ) ; PyErr_SetString ( InvalidDocument , ""no<S2SV_blank>c<S2SV_blank>decoder<S2SV_blank>for<S2SV_blank>this<S2SV_blank>type<S2SV_blank>yet"" ) ; Py_DECREF ( InvalidDocument ) ; return NULL ; } } return value ; invalid : error = _error ( ""InvalidBSON"" ) ; PyErr_SetNone ( error ) ; Py_DECREF ( error ) ; return NULL ; }
","<S2SV_ModStart> ""$ref"" ) ; if ( id == NULL ) { id = Py_None ; <S2SV_ModStart> id ) ; } else { Py_INCREF ( id ) ; <S2SV_ModStart> ""$id"" ) ; }
"
456,"CWE-416 static long do_get_mempolicy ( int * policy , nodemask_t * nmask , unsigned long addr , unsigned long flags ) { int err ; struct mm_struct * mm = current -> mm ; struct vm_area_struct * vma = NULL ; struct mempolicy * pol = current -> mempolicy ; if ( flags & ~ ( unsigned long ) ( MPOL_F_NODE | MPOL_F_ADDR | MPOL_F_MEMS_ALLOWED ) ) return - EINVAL ; if ( flags & MPOL_F_MEMS_ALLOWED ) { if ( flags & ( MPOL_F_NODE | MPOL_F_ADDR ) ) return - EINVAL ; * policy = 0 ; task_lock ( current ) ; * nmask = cpuset_current_mems_allowed ; task_unlock ( current ) ; return 0 ; } if ( flags & MPOL_F_ADDR ) { down_read ( & mm -> mmap_sem ) ; vma = find_vma_intersection ( mm , addr , addr + 1 ) ; if ( ! vma ) { up_read ( & mm -> mmap_sem ) ; return - EFAULT ; } if ( vma -> vm_ops && vma -> vm_ops -> get_policy ) pol = vma -> vm_ops -> get_policy ( vma , addr ) ; else pol = vma -> vm_policy ; } else if ( addr ) return - EINVAL ; if ( ! pol ) pol = & default_policy ; if ( flags & MPOL_F_NODE ) { if ( flags & MPOL_F_ADDR ) { err = lookup_node ( addr ) ; if ( err < 0 ) goto out ; * policy = err ; } else if ( pol == current -> mempolicy && pol -> mode == MPOL_INTERLEAVE ) { * policy = next_node_in ( current -> il_prev , pol -> v . nodes ) ; } else { err = - EINVAL ; goto out ; } } else { * policy = pol == & default_policy ? MPOL_DEFAULT : pol -> mode ; * policy |= ( pol -> flags & MPOL_MODE_FLAGS ) ; } <S2SV_StartBug> if ( vma ) { <S2SV_EndBug> up_read ( & current -> mm -> mmap_sem ) ; vma = NULL ; } err = 0 ; if ( nmask ) { if ( mpol_store_user_nodemask ( pol ) ) { * nmask = pol -> w . user_nodemask ; } else { task_lock ( current ) ; get_policy_nodemask ( pol , nmask ) ; task_unlock ( current ) ; } } out : mpol_cond_put ( pol ) ; if ( vma ) up_read ( & current -> mm -> mmap_sem ) ; return err ; }
","<S2SV_ModStart> ) ; } <S2SV_ModEnd> err = 0
"
457,"CWE-476 static bool check_client_passwd ( PgSocket * client , const char * passwd ) { char md5 [ MD5_PASSWD_LEN + 1 ] ; const char * correct ; PgUser * user = client -> auth_user ; <S2SV_StartBug> if ( ! * passwd || ! * user -> passwd ) <S2SV_EndBug> return false ; switch ( cf_auth_type ) { case AUTH_PLAIN : return strcmp ( user -> passwd , passwd ) == 0 ; case AUTH_CRYPT : correct = crypt ( user -> passwd , ( char * ) client -> tmp_login_salt ) ; return correct && strcmp ( correct , passwd ) == 0 ; case AUTH_MD5 : if ( strlen ( passwd ) != MD5_PASSWD_LEN ) return false ; if ( ! isMD5 ( user -> passwd ) ) pg_md5_encrypt ( user -> passwd , user -> name , strlen ( user -> name ) , user -> passwd ) ; pg_md5_encrypt ( user -> passwd + 3 , ( char * ) client -> tmp_login_salt , 4 , md5 ) ; return strcmp ( md5 , passwd ) == 0 ; } return false ; }
","<S2SV_ModStart> if ( ! user ) { slog_error ( client , ""Password<S2SV_blank>packet<S2SV_blank>before<S2SV_blank>auth<S2SV_blank>packet?"" ) ; return false ; } if ( !
"
458,"CWE-20 static int futex_wait_requeue_pi ( u32 __user * uaddr , unsigned int flags , u32 val , ktime_t * abs_time , u32 bitset , u32 __user * uaddr2 ) { struct hrtimer_sleeper timeout , * to = NULL ; struct rt_mutex_waiter rt_waiter ; struct rt_mutex * pi_mutex = NULL ; struct futex_hash_bucket * hb ; union futex_key key2 = FUTEX_KEY_INIT ; struct futex_q q = futex_q_init ; <S2SV_StartBug> int res , ret ; <S2SV_EndBug> if ( ! bitset ) return - EINVAL ; if ( abs_time ) { to = & timeout ; hrtimer_init_on_stack ( & to -> timer , ( flags & FLAGS_CLOCKRT ) ? CLOCK_REALTIME : CLOCK_MONOTONIC , HRTIMER_MODE_ABS ) ; hrtimer_init_sleeper ( to , current ) ; hrtimer_set_expires_range_ns ( & to -> timer , * abs_time , current -> timer_slack_ns ) ; } debug_rt_mutex_init_waiter ( & rt_waiter ) ; rt_waiter . task = NULL ; ret = get_futex_key ( uaddr2 , flags & FLAGS_SHARED , & key2 , VERIFY_WRITE ) ; if ( unlikely ( ret != 0 ) ) goto out ; q . bitset = bitset ; q . rt_waiter = & rt_waiter ; q . requeue_pi_key = & key2 ; ret = futex_wait_setup ( uaddr , val , flags , & q , & hb ) ; if ( ret ) goto out_key2 ; futex_wait_queue_me ( hb , & q , to ) ; spin_lock ( & hb -> lock ) ; ret = handle_early_requeue_pi_wakeup ( hb , & q , & key2 , to ) ; spin_unlock ( & hb -> lock ) ; if ( ret ) goto out_put_keys ; if ( ! q . rt_waiter ) { if ( q . pi_state && ( q . pi_state -> owner != current ) ) { spin_lock ( q . lock_ptr ) ; ret = fixup_pi_state_owner ( uaddr2 , & q , current ) ; spin_unlock ( q . lock_ptr ) ; } } else { WARN_ON ( ! q . pi_state ) ; pi_mutex = & q . pi_state -> pi_mutex ; ret = rt_mutex_finish_proxy_lock ( pi_mutex , to , & rt_waiter , 1 ) ; debug_rt_mutex_free_waiter ( & rt_waiter ) ; spin_lock ( q . lock_ptr ) ; res = fixup_owner ( uaddr2 , & q , ! ret ) ; if ( res ) ret = ( res < 0 ) ? res : 0 ; unqueue_me_pi ( & q ) ; } if ( ret == - EFAULT ) { if ( pi_mutex && rt_mutex_owner ( pi_mutex ) == current ) rt_mutex_unlock ( pi_mutex ) ; } else if ( ret == - EINTR ) { ret = - EWOULDBLOCK ; } out_put_keys : put_futex_key ( & q . key ) ; out_key2 : put_futex_key ( & key2 ) ; out : if ( to ) { hrtimer_cancel ( & to -> timer ) ; destroy_hrtimer_on_stack ( & to -> timer ) ; } return ret ; }
","<S2SV_ModStart> res , ret ; if ( uaddr == uaddr2 ) return - EINVAL
"
459,"CWE-119 IHEVCD_ERROR_T ihevcd_parse_sps ( codec_t * ps_codec ) { IHEVCD_ERROR_T ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; WORD32 value ; WORD32 i ; WORD32 vps_id ; WORD32 sps_max_sub_layers ; WORD32 sps_id ; WORD32 sps_temporal_id_nesting_flag ; sps_t * ps_sps ; profile_tier_lvl_info_t s_ptl ; bitstrm_t * ps_bitstrm = & ps_codec -> s_parse . s_bitstrm ; BITS_PARSE ( ""video_parameter_set_id"" , value , ps_bitstrm , 4 ) ; vps_id = value ; vps_id = CLIP3 ( vps_id , 0 , MAX_VPS_CNT - 1 ) ; BITS_PARSE ( ""sps_max_sub_layers_minus1"" , value , ps_bitstrm , 3 ) ; sps_max_sub_layers = value + 1 ; sps_max_sub_layers = CLIP3 ( sps_max_sub_layers , 1 , 7 ) ; BITS_PARSE ( ""sps_temporal_id_nesting_flag"" , value , ps_bitstrm , 1 ) ; sps_temporal_id_nesting_flag = value ; ret = ihevcd_profile_tier_level ( ps_bitstrm , & ( s_ptl ) , 1 , ( sps_max_sub_layers - 1 ) ) ; UEV_PARSE ( ""seq_parameter_set_id"" , value , ps_bitstrm ) ; sps_id = value ; if ( ( sps_id >= MAX_SPS_CNT ) || ( sps_id < 0 ) ) { if ( ps_codec -> i4_sps_done ) return IHEVCD_UNSUPPORTED_SPS_ID ; else sps_id = 0 ; } ps_sps = ( ps_codec -> s_parse . ps_sps_base + MAX_SPS_CNT - 1 ) ; ps_sps -> i1_sps_id = sps_id ; ps_sps -> i1_vps_id = vps_id ; ps_sps -> i1_sps_max_sub_layers = sps_max_sub_layers ; ps_sps -> i1_sps_temporal_id_nesting_flag = sps_temporal_id_nesting_flag ; ps_codec -> i4_sps_id = sps_id ; memcpy ( & ps_sps -> s_ptl , & s_ptl , sizeof ( profile_tier_lvl_info_t ) ) ; UEV_PARSE ( ""chroma_format_idc"" , value , ps_bitstrm ) ; ps_sps -> i1_chroma_format_idc = value ; if ( ps_sps -> i1_chroma_format_idc != CHROMA_FMT_IDC_YUV420 ) { ps_codec -> s_parse . i4_error_code = IHEVCD_UNSUPPORTED_CHROMA_FMT_IDC ; return ( IHEVCD_ERROR_T ) IHEVCD_UNSUPPORTED_CHROMA_FMT_IDC ; } if ( CHROMA_FMT_IDC_YUV444_PLANES == ps_sps -> i1_chroma_format_idc ) { BITS_PARSE ( ""separate_colour_plane_flag"" , value , ps_bitstrm , 1 ) ; ps_sps -> i1_separate_colour_plane_flag = value ; } else { ps_sps -> i1_separate_colour_plane_flag = 0 ; } UEV_PARSE ( ""pic_width_in_luma_samples"" , value , ps_bitstrm ) ; ps_sps -> i2_pic_width_in_luma_samples = value ; UEV_PARSE ( ""pic_height_in_luma_samples"" , value , ps_bitstrm ) ; ps_sps -> i2_pic_height_in_luma_samples = value ; if ( ( 0 >= ps_sps -> i2_pic_width_in_luma_samples ) || ( 0 >= ps_sps -> i2_pic_height_in_luma_samples ) ) return IHEVCD_INVALID_PARAMETER ; ps_sps -> i2_pic_width_in_luma_samples = ALIGN8 ( ps_sps -> i2_pic_width_in_luma_samples ) ; ps_sps -> i2_pic_height_in_luma_samples = ALIGN8 ( ps_sps -> i2_pic_height_in_luma_samples ) ; if ( ( ps_sps -> i2_pic_width_in_luma_samples > ps_codec -> i4_max_wd ) || ( ps_sps -> i2_pic_width_in_luma_samples * ps_sps -> i2_pic_height_in_luma_samples > ps_codec -> i4_max_wd * ps_codec -> i4_max_ht ) || ( ps_sps -> i2_pic_height_in_luma_samples > MAX ( ps_codec -> i4_max_wd , ps_codec -> i4_max_ht ) ) ) { ps_codec -> i4_new_max_wd = ps_sps -> i2_pic_width_in_luma_samples ; ps_codec -> i4_new_max_ht = ps_sps -> i2_pic_height_in_luma_samples ; return ( IHEVCD_ERROR_T ) IHEVCD_UNSUPPORTED_DIMENSIONS ; } BITS_PARSE ( ""pic_cropping_flag"" , value , ps_bitstrm , 1 ) ; ps_sps -> i1_pic_cropping_flag = value ; if ( ps_sps -> i1_pic_cropping_flag ) { UEV_PARSE ( ""pic_crop_left_offset"" , value , ps_bitstrm ) ; ps_sps -> i2_pic_crop_left_offset = value ; UEV_PARSE ( ""pic_crop_right_offset"" , value , ps_bitstrm ) ; ps_sps -> i2_pic_crop_right_offset = value ; UEV_PARSE ( ""pic_crop_top_offset"" , value , ps_bitstrm ) ; ps_sps -> i2_pic_crop_top_offset = value ; UEV_PARSE ( ""pic_crop_bottom_offset"" , value , ps_bitstrm ) ; ps_sps -> i2_pic_crop_bottom_offset = value ; } else { ps_sps -> i2_pic_crop_left_offset = 0 ; ps_sps -> i2_pic_crop_right_offset = 0 ; ps_sps -> i2_pic_crop_top_offset = 0 ; ps_sps -> i2_pic_crop_bottom_offset = 0 ; } UEV_PARSE ( ""bit_depth_luma_minus8"" , value , ps_bitstrm ) ; if ( 0 != value ) return IHEVCD_UNSUPPORTED_BIT_DEPTH ; UEV_PARSE ( ""bit_depth_chroma_minus8"" , value , ps_bitstrm ) ; if ( 0 != value ) return IHEVCD_UNSUPPORTED_BIT_DEPTH ; UEV_PARSE ( ""log2_max_pic_order_cnt_lsb_minus4"" , value , ps_bitstrm ) ; ps_sps -> i1_log2_max_pic_order_cnt_lsb = value + 4 ; BITS_PARSE ( ""sps_sub_layer_ordering_info_present_flag"" , value , ps_bitstrm , 1 ) ; ps_sps -> i1_sps_sub_layer_ordering_info_present_flag = value ; i = ( ps_sps -> i1_sps_sub_layer_ordering_info_present_flag ? 0 : ( ps_sps -> i1_sps_max_sub_layers - 1 ) ) ; for ( ; i < ps_sps -> i1_sps_max_sub_layers ; i ++ ) { UEV_PARSE ( ""max_dec_pic_buffering"" , value , ps_bitstrm ) ; ps_sps -> ai1_sps_max_dec_pic_buffering [ i ] = value + 1 ; <S2SV_StartBug> UEV_PARSE ( ""num_reorder_pics"" , value , ps_bitstrm ) ; <S2SV_EndBug> ps_sps -> ai1_sps_max_num_reorder_pics [ i ] = value ; <S2SV_StartBug> UEV_PARSE ( ""max_latency_increase"" , value , ps_bitstrm ) ; <S2SV_EndBug> ps_sps -> ai1_sps_max_latency_increase [ i ] = value ; } UEV_PARSE ( ""log2_min_coding_block_size_minus3"" , value , ps_bitstrm ) ; ps_sps -> i1_log2_min_coding_block_size = value + 3 ; UEV_PARSE ( ""log2_diff_max_min_coding_block_size"" , value , ps_bitstrm ) ; ps_sps -> i1_log2_diff_max_min_coding_block_size = value ; UEV_PARSE ( ""log2_min_transform_block_size_minus2"" , value , ps_bitstrm ) ; ps_sps -> i1_log2_min_transform_block_size = value + 2 ; UEV_PARSE ( ""log2_diff_max_min_transform_block_size"" , value , ps_bitstrm ) ; ps_sps -> i1_log2_diff_max_min_transform_block_size = value ; ps_sps -> i1_log2_max_transform_block_size = ps_sps -> i1_log2_min_transform_block_size + ps_sps -> i1_log2_diff_max_min_transform_block_size ; ps_sps -> i1_log2_ctb_size = ps_sps -> i1_log2_min_coding_block_size + ps_sps -> i1_log2_diff_max_min_coding_block_size ; if ( ( ps_sps -> i1_log2_min_coding_block_size < 3 ) || ( ps_sps -> i1_log2_min_transform_block_size < 2 ) || ( ps_sps -> i1_log2_diff_max_min_transform_block_size < 0 ) || ( ps_sps -> i1_log2_max_transform_block_size > ps_sps -> i1_log2_ctb_size ) || ( ps_sps -> i1_log2_ctb_size < 4 ) || ( ps_sps -> i1_log2_ctb_size > 6 ) ) { return IHEVCD_INVALID_PARAMETER ; } ps_sps -> i1_log2_min_pcm_coding_block_size = 0 ; ps_sps -> i1_log2_diff_max_min_pcm_coding_block_size = 0 ; UEV_PARSE ( ""max_transform_hierarchy_depth_inter"" , value , ps_bitstrm ) ; ps_sps -> i1_max_transform_hierarchy_depth_inter = value ; UEV_PARSE ( ""max_transform_hierarchy_depth_intra"" , value , ps_bitstrm ) ; ps_sps -> i1_max_transform_hierarchy_depth_intra = value ; BITS_PARSE ( ""scaling_list_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_sps -> i1_scaling_list_enable_flag = value ; if ( ps_sps -> i1_scaling_list_enable_flag ) { COPY_DEFAULT_SCALING_LIST ( ps_sps -> pi2_scaling_mat ) ; BITS_PARSE ( ""sps_scaling_list_data_present_flag"" , value , ps_bitstrm , 1 ) ; ps_sps -> i1_sps_scaling_list_data_present_flag = value ; if ( ps_sps -> i1_sps_scaling_list_data_present_flag ) ihevcd_scaling_list_data ( ps_codec , ps_sps -> pi2_scaling_mat ) ; } else { COPY_FLAT_SCALING_LIST ( ps_sps -> pi2_scaling_mat ) ; } BITS_PARSE ( ""asymmetric_motion_partitions_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_sps -> i1_amp_enabled_flag = value ; BITS_PARSE ( ""sample_adaptive_offset_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_sps -> i1_sample_adaptive_offset_enabled_flag = value ; BITS_PARSE ( ""pcm_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_sps -> i1_pcm_enabled_flag = value ; if ( ps_sps -> i1_pcm_enabled_flag ) { BITS_PARSE ( ""pcm_sample_bit_depth_luma"" , value , ps_bitstrm , 4 ) ; ps_sps -> i1_pcm_sample_bit_depth_luma = value + 1 ; BITS_PARSE ( ""pcm_sample_bit_depth_chroma"" , value , ps_bitstrm , 4 ) ; ps_sps -> i1_pcm_sample_bit_depth_chroma = value + 1 ; UEV_PARSE ( ""log2_min_pcm_coding_block_size_minus3"" , value , ps_bitstrm ) ; ps_sps -> i1_log2_min_pcm_coding_block_size = value + 3 ; UEV_PARSE ( ""log2_diff_max_min_pcm_coding_block_size"" , value , ps_bitstrm ) ; ps_sps -> i1_log2_diff_max_min_pcm_coding_block_size = value ; BITS_PARSE ( ""pcm_loop_filter_disable_flag"" , value , ps_bitstrm , 1 ) ; ps_sps -> i1_pcm_loop_filter_disable_flag = value ; } UEV_PARSE ( ""num_short_term_ref_pic_sets"" , value , ps_bitstrm ) ; ps_sps -> i1_num_short_term_ref_pic_sets = value ; ps_sps -> i1_num_short_term_ref_pic_sets = CLIP3 ( ps_sps -> i1_num_short_term_ref_pic_sets , 0 , MAX_STREF_PICS_SPS ) ; for ( i = 0 ; i < ps_sps -> i1_num_short_term_ref_pic_sets ; i ++ ) ihevcd_short_term_ref_pic_set ( ps_bitstrm , & ps_sps -> as_stref_picset [ 0 ] , ps_sps -> i1_num_short_term_ref_pic_sets , i , & ps_sps -> as_stref_picset [ i ] ) ; BITS_PARSE ( ""long_term_ref_pics_present_flag"" , value , ps_bitstrm , 1 ) ; ps_sps -> i1_long_term_ref_pics_present_flag = value ; if ( ps_sps -> i1_long_term_ref_pics_present_flag ) { UEV_PARSE ( ""num_long_term_ref_pics_sps"" , value , ps_bitstrm ) ; ps_sps -> i1_num_long_term_ref_pics_sps = value ; for ( i = 0 ; i < ps_sps -> i1_num_long_term_ref_pics_sps ; i ++ ) { BITS_PARSE ( ""lt_ref_pic_poc_lsb_sps[<S2SV_blank>i<S2SV_blank>]"" , value , ps_bitstrm , ps_sps -> i1_log2_max_pic_order_cnt_lsb ) ; ps_sps -> ai1_lt_ref_pic_poc_lsb_sps [ i ] = value ; BITS_PARSE ( ""used_by_curr_pic_lt_sps_flag[<S2SV_blank>i<S2SV_blank>]"" , value , ps_bitstrm , 1 ) ; ps_sps -> ai1_used_by_curr_pic_lt_sps_flag [ i ] = value ; } } BITS_PARSE ( ""sps_temporal_mvp_enable_flag"" , value , ps_bitstrm , 1 ) ; ps_sps -> i1_sps_temporal_mvp_enable_flag = value ; BITS_PARSE ( ""sps_strong_intra_smoothing_enable_flag"" , value , ps_bitstrm , 1 ) ; ps_sps -> i1_strong_intra_smoothing_enable_flag = value ; BITS_PARSE ( ""vui_parameters_present_flag"" , value , ps_bitstrm , 1 ) ; ps_sps -> i1_vui_parameters_present_flag = value ; if ( ps_sps -> i1_vui_parameters_present_flag ) ihevcd_parse_vui_parameters ( ps_bitstrm , & ps_sps -> s_vui_parameters , ps_sps -> i1_sps_max_sub_layers - 1 ) ; BITS_PARSE ( ""sps_extension_flag"" , value , ps_bitstrm , 1 ) ; { WORD32 numerator ; WORD32 ceil_offset ; ceil_offset = ( 1 << ps_sps -> i1_log2_ctb_size ) - 1 ; numerator = ps_sps -> i2_pic_width_in_luma_samples ; ps_sps -> i2_pic_wd_in_ctb = ( ( numerator + ceil_offset ) / ( 1 << ps_sps -> i1_log2_ctb_size ) ) ; numerator = ps_sps -> i2_pic_height_in_luma_samples ; ps_sps -> i2_pic_ht_in_ctb = ( ( numerator + ceil_offset ) / ( 1 << ps_sps -> i1_log2_ctb_size ) ) ; ps_sps -> i4_pic_size_in_ctb = ps_sps -> i2_pic_ht_in_ctb * ps_sps -> i2_pic_wd_in_ctb ; if ( 0 == ps_codec -> i4_sps_done ) ps_codec -> s_parse . i4_next_ctb_indx = ps_sps -> i4_pic_size_in_ctb ; numerator = ps_sps -> i2_pic_width_in_luma_samples ; ps_sps -> i2_pic_wd_in_min_cb = numerator / ( 1 << ps_sps -> i1_log2_min_coding_block_size ) ; numerator = ps_sps -> i2_pic_height_in_luma_samples ; ps_sps -> i2_pic_ht_in_min_cb = numerator / ( 1 << ps_sps -> i1_log2_min_coding_block_size ) ; } if ( ( 0 != ps_codec -> i4_first_pic_done ) && ( ( ps_codec -> i4_wd != ps_sps -> i2_pic_width_in_luma_samples ) || ( ps_codec -> i4_ht != ps_sps -> i2_pic_height_in_luma_samples ) ) ) { ps_codec -> i4_reset_flag = 1 ; ps_codec -> i4_error_code = IVD_RES_CHANGED ; return ( IHEVCD_ERROR_T ) IHEVCD_FAIL ; } { WORD32 disp_wd , disp_ht ; WORD32 crop_unit_x , crop_unit_y ; crop_unit_x = 1 ; crop_unit_y = 1 ; if ( CHROMA_FMT_IDC_YUV420 == ps_sps -> i1_chroma_format_idc ) { crop_unit_x = 2 ; crop_unit_y = 2 ; } disp_wd = ps_sps -> i2_pic_width_in_luma_samples ; disp_wd -= ps_sps -> i2_pic_crop_left_offset * crop_unit_x ; disp_wd -= ps_sps -> i2_pic_crop_right_offset * crop_unit_x ; disp_ht = ps_sps -> i2_pic_height_in_luma_samples ; disp_ht -= ps_sps -> i2_pic_crop_top_offset * crop_unit_y ; disp_ht -= ps_sps -> i2_pic_crop_bottom_offset * crop_unit_y ; if ( ( 0 >= disp_wd ) || ( 0 >= disp_ht ) ) return IHEVCD_INVALID_PARAMETER ; ps_codec -> i4_disp_wd = disp_wd ; ps_codec -> i4_disp_ht = disp_ht ; ps_codec -> i4_wd = ps_sps -> i2_pic_width_in_luma_samples ; ps_codec -> i4_ht = ps_sps -> i2_pic_height_in_luma_samples ; { WORD32 ref_strd ; ref_strd = ALIGN32 ( ps_sps -> i2_pic_width_in_luma_samples + PAD_WD ) ; if ( ps_codec -> i4_strd < ref_strd ) { ps_codec -> i4_strd = ref_strd ; } } if ( 0 == ps_codec -> i4_share_disp_buf ) { if ( ps_codec -> i4_disp_strd < ps_codec -> i4_disp_wd ) { ps_codec -> i4_disp_strd = ps_codec -> i4_disp_wd ; } } else { if ( ps_codec -> i4_disp_strd < ps_codec -> i4_strd ) { ps_codec -> i4_disp_strd = ps_codec -> i4_strd ; } } } ps_codec -> i4_sps_done = 1 ; return ret ; }
","<S2SV_ModStart> + 1 ; if ( ps_sps -> ai1_sps_max_dec_pic_buffering [ i ] > MAX_DPB_SIZE ) { return IHEVCD_INVALID_PARAMETER ; } <S2SV_ModStart> = value ; if ( ps_sps -> ai1_sps_max_num_reorder_pics [ i ] > ps_sps -> ai1_sps_max_dec_pic_buffering [ i ] ) { return IHEVCD_INVALID_PARAMETER ; }
"
460,"CWE-190 static int <S2SV_StartBug> _PyMemoTable_ResizeTable ( PyMemoTable * self , Py_ssize_t min_size ) <S2SV_EndBug> { PyMemoEntry * oldtable = NULL ; PyMemoEntry * oldentry , * newentry ; <S2SV_StartBug> Py_ssize_t new_size = MT_MINSIZE ; <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t to_process ; <S2SV_EndBug> assert ( min_size > 0 ) ; <S2SV_StartBug> while ( new_size < min_size && new_size > 0 ) <S2SV_EndBug> new_size <<= 1 ; if ( new_size <= 0 ) { PyErr_NoMemory ( ) ; return - 1 ; } assert ( ( new_size & ( new_size - 1 ) ) == 0 ) ; oldtable = self -> mt_table ; self -> mt_table = PyMem_NEW ( PyMemoEntry , new_size ) ; if ( self -> mt_table == NULL ) { self -> mt_table = oldtable ; PyErr_NoMemory ( ) ; return - 1 ; } self -> mt_allocated = new_size ; self -> mt_mask = new_size - 1 ; memset ( self -> mt_table , 0 , sizeof ( PyMemoEntry ) * new_size ) ; to_process = self -> mt_used ; for ( oldentry = oldtable ; to_process > 0 ; oldentry ++ ) { if ( oldentry -> me_key != NULL ) { to_process -- ; newentry = _PyMemoTable_Lookup ( self , oldentry -> me_key ) ; newentry -> me_key = oldentry -> me_key ; newentry -> me_value = oldentry -> me_value ; } } PyMem_FREE ( oldtable ) ; return 0 ; }
","<S2SV_ModStart> * self , size_t <S2SV_ModEnd> min_size ) { <S2SV_ModStart> * newentry ; size_t <S2SV_ModEnd> new_size = MT_MINSIZE <S2SV_ModStart> = MT_MINSIZE ; size_t <S2SV_ModEnd> to_process ; assert <S2SV_ModStart> 0 ) ; if ( min_size > PY_SSIZE_T_MAX ) { PyErr_NoMemory ( ) ; return - 1 ; } <S2SV_ModStart> new_size < min_size ) { new_size <<= <S2SV_ModEnd> 1 ; }
"
461,"CWE-119 static __init int sctp_init ( void ) { int i ; int status = - EINVAL ; unsigned long goal ; unsigned long limit ; int max_share ; int order ; sock_skb_cb_check_size ( sizeof ( struct sctp_ulpevent ) ) ; status = - ENOBUFS ; sctp_bucket_cachep = kmem_cache_create ( ""sctp_bind_bucket"" , sizeof ( struct sctp_bind_bucket ) , 0 , SLAB_HWCACHE_ALIGN , NULL ) ; if ( ! sctp_bucket_cachep ) goto out ; sctp_chunk_cachep = kmem_cache_create ( ""sctp_chunk"" , sizeof ( struct sctp_chunk ) , 0 , SLAB_HWCACHE_ALIGN , NULL ) ; if ( ! sctp_chunk_cachep ) goto err_chunk_cachep ; status = percpu_counter_init ( & sctp_sockets_allocated , 0 , GFP_KERNEL ) ; if ( status ) goto err_percpu_counter_init ; sctp_max_instreams = SCTP_DEFAULT_INSTREAMS ; sctp_max_outstreams = SCTP_DEFAULT_OUTSTREAMS ; idr_init ( & sctp_assocs_id ) ; limit = nr_free_buffer_pages ( ) / 8 ; limit = max ( limit , 128UL ) ; sysctl_sctp_mem [ 0 ] = limit / 4 * 3 ; sysctl_sctp_mem [ 1 ] = limit ; sysctl_sctp_mem [ 2 ] = sysctl_sctp_mem [ 0 ] * 2 ; limit = ( sysctl_sctp_mem [ 1 ] ) << ( PAGE_SHIFT - 7 ) ; max_share = min ( 4UL * 1024 * 1024 , limit ) ; sysctl_sctp_rmem [ 0 ] = SK_MEM_QUANTUM ; sysctl_sctp_rmem [ 1 ] = 1500 * SKB_TRUESIZE ( 1 ) ; sysctl_sctp_rmem [ 2 ] = max ( sysctl_sctp_rmem [ 1 ] , max_share ) ; sysctl_sctp_wmem [ 0 ] = SK_MEM_QUANTUM ; sysctl_sctp_wmem [ 1 ] = 16 * 1024 ; sysctl_sctp_wmem [ 2 ] = max ( 64 * 1024 , max_share ) ; if ( totalram_pages >= ( 128 * 1024 ) ) goal = totalram_pages >> ( 22 - PAGE_SHIFT ) ; else goal = totalram_pages >> ( 24 - PAGE_SHIFT ) ; for ( order = 0 ; ( 1UL << order ) < goal ; order ++ ) ; do { sctp_assoc_hashsize = ( 1UL << order ) * PAGE_SIZE / sizeof ( struct sctp_hashbucket ) ; if ( ( sctp_assoc_hashsize > ( 64 * 1024 ) ) && order > 0 ) continue ; sctp_assoc_hashtable = ( struct sctp_hashbucket * ) __get_free_pages ( GFP_ATOMIC | __GFP_NOWARN , order ) ; } while ( ! sctp_assoc_hashtable && -- order > 0 ) ; if ( ! sctp_assoc_hashtable ) { pr_err ( ""Failed<S2SV_blank>association<S2SV_blank>hash<S2SV_blank>alloc\\n"" ) ; status = - ENOMEM ; goto err_ahash_alloc ; } for ( i = 0 ; i < sctp_assoc_hashsize ; i ++ ) { rwlock_init ( & sctp_assoc_hashtable [ i ] . lock ) ; INIT_HLIST_HEAD ( & sctp_assoc_hashtable [ i ] . chain ) ; } sctp_ep_hashsize = 64 ; sctp_ep_hashtable = kmalloc ( 64 * sizeof ( struct sctp_hashbucket ) , GFP_KERNEL ) ; if ( ! sctp_ep_hashtable ) { pr_err ( ""Failed<S2SV_blank>endpoint_hash<S2SV_blank>alloc\\n"" ) ; status = - ENOMEM ; goto err_ehash_alloc ; } for ( i = 0 ; i < sctp_ep_hashsize ; i ++ ) { rwlock_init ( & sctp_ep_hashtable [ i ] . lock ) ; INIT_HLIST_HEAD ( & sctp_ep_hashtable [ i ] . chain ) ; } do { sctp_port_hashsize = ( 1UL << order ) * PAGE_SIZE / sizeof ( struct sctp_bind_hashbucket ) ; if ( ( sctp_port_hashsize > ( 64 * 1024 ) ) && order > 0 ) continue ; sctp_port_hashtable = ( struct sctp_bind_hashbucket * ) __get_free_pages ( GFP_ATOMIC | __GFP_NOWARN , order ) ; } while ( ! sctp_port_hashtable && -- order > 0 ) ; if ( ! sctp_port_hashtable ) { pr_err ( ""Failed<S2SV_blank>bind<S2SV_blank>hash<S2SV_blank>alloc\\n"" ) ; status = - ENOMEM ; goto err_bhash_alloc ; } for ( i = 0 ; i < sctp_port_hashsize ; i ++ ) { spin_lock_init ( & sctp_port_hashtable [ i ] . lock ) ; INIT_HLIST_HEAD ( & sctp_port_hashtable [ i ] . chain ) ; } pr_info ( ""Hash<S2SV_blank>tables<S2SV_blank>configured<S2SV_blank>(established<S2SV_blank>%d<S2SV_blank>bind<S2SV_blank>%d)\\n"" , sctp_assoc_hashsize , sctp_port_hashsize ) ; sctp_sysctl_register ( ) ; INIT_LIST_HEAD ( & sctp_address_families ) ; sctp_v4_pf_init ( ) ; sctp_v6_pf_init ( ) ; <S2SV_StartBug> status = sctp_v4_protosw_init ( ) ; <S2SV_EndBug> if ( status ) goto err_protosw_init ; status = sctp_v6_protosw_init ( ) ; if ( status ) goto err_v6_protosw_init ; <S2SV_StartBug> status = register_pernet_subsys ( & sctp_net_ops ) ; <S2SV_EndBug> if ( status ) goto err_register_pernet_subsys ; status = sctp_v4_add_protocol ( ) ; if ( status ) goto err_add_protocol ; status = sctp_v6_add_protocol ( ) ; if ( status ) goto err_v6_add_protocol ; out : return status ; err_v6_add_protocol : sctp_v4_del_protocol ( ) ; err_add_protocol : <S2SV_StartBug> unregister_pernet_subsys ( & sctp_net_ops ) ; <S2SV_EndBug> err_register_pernet_subsys : sctp_v6_protosw_exit ( ) ; err_v6_protosw_init : sctp_v4_protosw_exit ( ) ; <S2SV_StartBug> err_protosw_init : <S2SV_EndBug> sctp_v4_pf_exit ( ) ; sctp_v6_pf_exit ( ) ; sctp_sysctl_unregister ( ) ; free_pages ( ( unsigned long ) sctp_port_hashtable , get_order ( sctp_port_hashsize * sizeof ( struct sctp_bind_hashbucket ) ) ) ; err_bhash_alloc : kfree ( sctp_ep_hashtable ) ; err_ehash_alloc : free_pages ( ( unsigned long ) sctp_assoc_hashtable , get_order ( sctp_assoc_hashsize * sizeof ( struct sctp_hashbucket ) ) ) ; err_ahash_alloc : percpu_counter_destroy ( & sctp_sockets_allocated ) ; err_percpu_counter_init : kmem_cache_destroy ( sctp_chunk_cachep ) ; err_chunk_cachep : kmem_cache_destroy ( sctp_bucket_cachep ) ; goto out ; }
","<S2SV_ModStart> ; status = register_pernet_subsys ( & sctp_defaults_ops ) ; if ( status ) goto err_register_defaults ; status = <S2SV_ModStart> register_pernet_subsys ( & sctp_ctrlsock_ops ) ; if ( status ) goto err_register_ctrlsock <S2SV_ModEnd> ; status = <S2SV_ModStart> unregister_pernet_subsys ( & sctp_ctrlsock_ops ) ; err_register_ctrlsock <S2SV_ModEnd> : sctp_v6_protosw_exit ( <S2SV_ModStart> ) ; err_protosw_init : unregister_pernet_subsys ( & sctp_defaults_ops ) ; err_register_defaults
"
462,"CWE-000 LUA_API void lua_sethook ( lua_State * L , lua_Hook func , int mask , int count ) { if ( func == NULL || mask == 0 ) { mask = 0 ; func = NULL ; } <S2SV_StartBug> if ( isLua ( L -> ci ) ) <S2SV_EndBug> L -> oldpc = L -> ci -> u . l . savedpc ; L -> hook = func ; L -> basehookcount = count ; resethookcount ( L ) ; L -> hookmask = cast_byte ( mask ) ; if ( mask ) settraps ( L -> ci ) ; }
","<S2SV_ModStart> NULL ; } <S2SV_ModEnd> L -> hook
"
463,"CWE-119 static char * cJSON_strdup ( const char * str ) { size_t len ; char * copy ; len = strlen ( str ) + 1 ; if ( ! ( copy = ( char * ) cJSON_malloc ( len ) ) ) return 0 ; memcpy ( copy , str , len ) ; return copy ; }
","
"
464,"CWE-189 void jiffies_to_timeval ( const unsigned long jiffies , struct timeval * value ) { <S2SV_StartBug> u64 nsec = ( u64 ) jiffies * TICK_NSEC ; <S2SV_EndBug> long tv_usec ; <S2SV_StartBug> value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & tv_usec ) ; <S2SV_EndBug> tv_usec /= NSEC_PER_USEC ; <S2SV_StartBug> value -> tv_usec = tv_usec ; <S2SV_EndBug> }
","<S2SV_ModStart> value ) { u32 rem ; value -> tv_sec = div_u64_rem ( <S2SV_ModEnd> ( u64 ) <S2SV_ModStart> jiffies * TICK_NSEC , <S2SV_ModEnd> NSEC_PER_SEC , & <S2SV_ModStart> NSEC_PER_SEC , & rem ) <S2SV_ModEnd> ; value -> <S2SV_ModStart> -> tv_usec = rem / NSEC_PER_USEC <S2SV_ModEnd> ; } <S2SV_null>
"
465,"CWE-617 struct lldpd_mgmt * lldpd_alloc_mgmt ( int family , void * addrptr , size_t addrsize , u_int32_t iface ) { struct lldpd_mgmt * mgmt ; log_debug ( ""alloc"" , ""allocate<S2SV_blank>a<S2SV_blank>new<S2SV_blank>management<S2SV_blank>address<S2SV_blank>(family:<S2SV_blank>%d)"" , family ) ; if ( family <= LLDPD_AF_UNSPEC || family >= LLDPD_AF_LAST ) { errno = EAFNOSUPPORT ; return NULL ; } if ( addrsize > LLDPD_MGMT_MAXADDRSIZE ) { errno = EOVERFLOW ; return NULL ; } mgmt = calloc ( 1 , sizeof ( struct lldpd_mgmt ) ) ; if ( mgmt == NULL ) { errno = ENOMEM ; return NULL ; } mgmt -> m_family = family ; <S2SV_StartBug> assert ( addrsize <= LLDPD_MGMT_MAXADDRSIZE ) ; <S2SV_EndBug> memcpy ( & mgmt -> m_addr , addrptr , addrsize ) ; mgmt -> m_addrsize = addrsize ; mgmt -> m_iface = iface ; return mgmt ; }
","<S2SV_ModStart> = family ; <S2SV_ModEnd> memcpy ( &
"
466,"CWE-918 static inline char * parse_ip_address_ex ( const char * str , size_t str_len , int * portno , int get_err , zend_string * * err ) { char * colon ; char * host = NULL ; # ifdef HAVE_IPV6 <S2SV_StartBug> char * p ; <S2SV_EndBug> if ( * ( str ) == '[' && str_len > 1 ) { <S2SV_StartBug> p = memchr ( str + 1 , ']' , str_len - 2 ) ; <S2SV_EndBug> if ( ! p || * ( p + 1 ) != ':' ) { if ( get_err ) { * err = strpprintf ( 0 , ""Failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>IPv6<S2SV_blank>address<S2SV_blank>\\""%s\\"""" , str ) ; } return NULL ; } <S2SV_StartBug> * portno = atoi ( p + 2 ) ; <S2SV_EndBug> return estrndup ( str + 1 , p - str - 1 ) ; } # endif if ( str_len ) { colon = memchr ( str , ':' , str_len - 1 ) ; } else { colon = NULL ; } if ( colon ) { <S2SV_StartBug> * portno = atoi ( colon + 1 ) ; <S2SV_EndBug> host = estrndup ( str , colon - str ) ; <S2SV_StartBug> } else { <S2SV_EndBug> if ( get_err ) { * err = strpprintf ( 0 , ""Failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>address<S2SV_blank>\\""%s\\"""" , str ) ; } return NULL ; } <S2SV_StartBug> return host ; <S2SV_EndBug> }
","<S2SV_ModStart> # ifdef HAVE_IPV6 <S2SV_ModEnd> if ( * <S2SV_ModStart> 1 ) { char * <S2SV_ModStart> - 2 ) , * e = NULL <S2SV_ModStart> * portno = strtol <S2SV_ModEnd> ( p + <S2SV_ModStart> p + 2 , & e , 10 ) ; if ( e && * e ) { if ( get_err ) { * err = strpprintf ( 0 , ""Failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>address<S2SV_blank>\\""%s\\"""" , str ) ; } return NULL ; } <S2SV_ModEnd> return estrndup ( <S2SV_ModStart> colon ) { char * e = NULL ; <S2SV_ModStart> * portno = strtol ( colon + 1 , & e , 10 ) ; if ( ! e || ! * e ) { return <S2SV_ModEnd> estrndup ( str <S2SV_ModStart> ) ; } } <S2SV_ModEnd> if ( get_err <S2SV_ModStart> NULL ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
"
467,"CWE-190 static int adjust_ptr_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , const struct bpf_reg_state * ptr_reg , const struct bpf_reg_state * off_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) , * dst_reg ; bool known = tnum_is_const ( off_reg -> var_off ) ; s64 smin_val = off_reg -> smin_value , smax_val = off_reg -> smax_value , smin_ptr = ptr_reg -> smin_value , smax_ptr = ptr_reg -> smax_value ; u64 umin_val = off_reg -> umin_value , umax_val = off_reg -> umax_value , umin_ptr = ptr_reg -> umin_value , umax_ptr = ptr_reg -> umax_value ; u8 opcode = BPF_OP ( insn -> code ) ; u32 dst = insn -> dst_reg ; dst_reg = & regs [ dst ] ; if ( WARN_ON_ONCE ( known && ( smin_val != smax_val ) ) ) { print_verifier_state ( env , env -> cur_state ) ; verbose ( env , ""verifier<S2SV_blank>internal<S2SV_blank>error:<S2SV_blank>known<S2SV_blank>but<S2SV_blank>bad<S2SV_blank>sbounds\\n"" ) ; return - EINVAL ; } if ( WARN_ON_ONCE ( known && ( umin_val != umax_val ) ) ) { print_verifier_state ( env , env -> cur_state ) ; verbose ( env , ""verifier<S2SV_blank>internal<S2SV_blank>error:<S2SV_blank>known<S2SV_blank>but<S2SV_blank>bad<S2SV_blank>ubounds\\n"" ) ; return - EINVAL ; } if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%d<S2SV_blank>32-bit<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>prohibited\\n"" , dst ) ; return - EACCES ; } if ( ptr_reg -> type == PTR_TO_MAP_VALUE_OR_NULL ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>on<S2SV_blank>PTR_TO_MAP_VALUE_OR_NULL<S2SV_blank>prohibited,<S2SV_blank>null-check<S2SV_blank>it<S2SV_blank>first\\n"" , dst ) ; return - EACCES ; } if ( ptr_reg -> type == CONST_PTR_TO_MAP ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>on<S2SV_blank>CONST_PTR_TO_MAP<S2SV_blank>prohibited\\n"" , dst ) ; return - EACCES ; } if ( ptr_reg -> type == PTR_TO_PACKET_END ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>on<S2SV_blank>PTR_TO_PACKET_END<S2SV_blank>prohibited\\n"" , dst ) ; return - EACCES ; } dst_reg -> type = ptr_reg -> type ; <S2SV_StartBug> dst_reg -> id = ptr_reg -> id ; <S2SV_EndBug> switch ( opcode ) { case BPF_ADD : if ( known && ( ptr_reg -> off + smin_val == ( s64 ) ( s32 ) ( ptr_reg -> off + smin_val ) ) ) { dst_reg -> smin_value = smin_ptr ; dst_reg -> smax_value = smax_ptr ; dst_reg -> umin_value = umin_ptr ; dst_reg -> umax_value = umax_ptr ; dst_reg -> var_off = ptr_reg -> var_off ; dst_reg -> off = ptr_reg -> off + smin_val ; dst_reg -> range = ptr_reg -> range ; break ; } if ( signed_add_overflows ( smin_ptr , smin_val ) || signed_add_overflows ( smax_ptr , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = smin_ptr + smin_val ; dst_reg -> smax_value = smax_ptr + smax_val ; } if ( umin_ptr + umin_val < umin_ptr || umax_ptr + umax_val < umax_ptr ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value = umin_ptr + umin_val ; dst_reg -> umax_value = umax_ptr + umax_val ; } dst_reg -> var_off = tnum_add ( ptr_reg -> var_off , off_reg -> var_off ) ; dst_reg -> off = ptr_reg -> off ; if ( reg_is_pkt_pointer ( ptr_reg ) ) { dst_reg -> id = ++ env -> id_gen ; dst_reg -> range = 0 ; } break ; case BPF_SUB : if ( dst_reg == off_reg ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>subtract<S2SV_blank>pointer<S2SV_blank>from<S2SV_blank>scalar\\n"" , dst ) ; return - EACCES ; } if ( ptr_reg -> type == PTR_TO_STACK ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%d<S2SV_blank>subtraction<S2SV_blank>from<S2SV_blank>stack<S2SV_blank>pointer<S2SV_blank>prohibited\\n"" , dst ) ; return - EACCES ; } if ( known && ( ptr_reg -> off - smin_val == ( s64 ) ( s32 ) ( ptr_reg -> off - smin_val ) ) ) { dst_reg -> smin_value = smin_ptr ; dst_reg -> smax_value = smax_ptr ; dst_reg -> umin_value = umin_ptr ; dst_reg -> umax_value = umax_ptr ; dst_reg -> var_off = ptr_reg -> var_off ; dst_reg -> id = ptr_reg -> id ; dst_reg -> off = ptr_reg -> off - smin_val ; dst_reg -> range = ptr_reg -> range ; break ; } if ( signed_sub_overflows ( smin_ptr , smax_val ) || signed_sub_overflows ( smax_ptr , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = smin_ptr - smax_val ; dst_reg -> smax_value = smax_ptr - smin_val ; } if ( umin_ptr < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value = umin_ptr - umax_val ; dst_reg -> umax_value = umax_ptr - umin_val ; } dst_reg -> var_off = tnum_sub ( ptr_reg -> var_off , off_reg -> var_off ) ; dst_reg -> off = ptr_reg -> off ; if ( reg_is_pkt_pointer ( ptr_reg ) ) { dst_reg -> id = ++ env -> id_gen ; if ( smin_val < 0 ) dst_reg -> range = 0 ; } break ; case BPF_AND : case BPF_OR : case BPF_XOR : if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%d<S2SV_blank>bitwise<S2SV_blank>operator<S2SV_blank>%s<S2SV_blank>on<S2SV_blank>pointer<S2SV_blank>prohibited\\n"" , dst , bpf_alu_string [ opcode >> 4 ] ) ; return - EACCES ; default : if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>with<S2SV_blank>%s<S2SV_blank>operator<S2SV_blank>prohibited\\n"" , dst , bpf_alu_string [ opcode >> 4 ] ) ; return - EACCES ; } <S2SV_StartBug> __update_reg_bounds ( dst_reg ) ; <S2SV_EndBug> __reg_deduce_bounds ( dst_reg ) ; __reg_bound_offset ( dst_reg ) ; return 0 ; }
","<S2SV_ModStart> ptr_reg -> id ; if ( ! check_reg_sane_offset ( env , off_reg , ptr_reg -> type ) || ! check_reg_sane_offset ( env , ptr_reg , ptr_reg -> type ) ) return - EINVAL <S2SV_ModStart> EACCES ; } if ( ! check_reg_sane_offset ( env , dst_reg , ptr_reg -> type ) ) return - EINVAL ;
"
468,"CWE-284 static void toggle_os_keylockstates ( int fd , int changedlockstates ) { BTIF_TRACE_EVENT ( ""%s:<S2SV_blank>fd<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>changedlockstates<S2SV_blank>=<S2SV_blank>0x%x"" , __FUNCTION__ , fd , changedlockstates ) ; UINT8 hidreport [ 9 ] ; int reportIndex ; memset ( hidreport , 0 , 9 ) ; hidreport [ 0 ] = 1 ; reportIndex = 4 ; if ( changedlockstates & BTIF_HH_KEYSTATE_MASK_CAPSLOCK ) { BTIF_TRACE_DEBUG ( ""%s<S2SV_blank>Setting<S2SV_blank>CAPSLOCK"" , __FUNCTION__ ) ; hidreport [ reportIndex ++ ] = ( UINT8 ) HID_REPORT_CAPSLOCK ; } if ( changedlockstates & BTIF_HH_KEYSTATE_MASK_NUMLOCK ) { BTIF_TRACE_DEBUG ( ""%s<S2SV_blank>Setting<S2SV_blank>NUMLOCK"" , __FUNCTION__ ) ; hidreport [ reportIndex ++ ] = ( UINT8 ) HID_REPORT_NUMLOCK ; } if ( changedlockstates & BTIF_HH_KEYSTATE_MASK_SCROLLLOCK ) { BTIF_TRACE_DEBUG ( ""%s<S2SV_blank>Setting<S2SV_blank>SCROLLLOCK"" , __FUNCTION__ ) ; hidreport [ reportIndex ++ ] = ( UINT8 ) HID_REPORT_SCROLLLOCK ; } BTIF_TRACE_DEBUG ( ""Writing<S2SV_blank>hidreport<S2SV_blank>#1<S2SV_blank>to<S2SV_blank>os:<S2SV_blank>"" ""%s:<S2SV_blank><S2SV_blank>%x<S2SV_blank>%x<S2SV_blank>%x"" , __FUNCTION__ , hidreport [ 0 ] , hidreport [ 1 ] , hidreport [ 2 ] ) ; BTIF_TRACE_DEBUG ( ""%s:<S2SV_blank><S2SV_blank>%x<S2SV_blank>%x<S2SV_blank>%x"" , __FUNCTION__ , hidreport [ 3 ] , hidreport [ 4 ] , hidreport [ 5 ] ) ; BTIF_TRACE_DEBUG ( ""%s:<S2SV_blank><S2SV_blank>%x<S2SV_blank>%x<S2SV_blank>%x"" , __FUNCTION__ , hidreport [ 6 ] , hidreport [ 7 ] , hidreport [ 8 ] ) ; bta_hh_co_write ( fd , hidreport , sizeof ( hidreport ) ) ; <S2SV_StartBug> usleep ( 200000 ) ; <S2SV_EndBug> memset ( hidreport , 0 , 9 ) ; hidreport [ 0 ] = 1 ; BTIF_TRACE_DEBUG ( ""Writing<S2SV_blank>hidreport<S2SV_blank>#2<S2SV_blank>to<S2SV_blank>os:<S2SV_blank>"" ""%s:<S2SV_blank><S2SV_blank>%x<S2SV_blank>%x<S2SV_blank>%x"" , __FUNCTION__ , hidreport [ 0 ] , hidreport [ 1 ] , hidreport [ 2 ] ) ; BTIF_TRACE_DEBUG ( ""%s:<S2SV_blank><S2SV_blank>%x<S2SV_blank>%x<S2SV_blank>%x"" , __FUNCTION__ , hidreport [ 3 ] , hidreport [ 4 ] , hidreport [ 5 ] ) ; BTIF_TRACE_DEBUG ( ""%s:<S2SV_blank><S2SV_blank>%x<S2SV_blank>%x<S2SV_blank>%x<S2SV_blank>"" , __FUNCTION__ , hidreport [ 6 ] , hidreport [ 7 ] , hidreport [ 8 ] ) ; bta_hh_co_write ( fd , hidreport , sizeof ( hidreport ) ) ; }
","<S2SV_ModStart> ) ) ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> usleep ( 200000 )
"
469,"CWE-284 socket_t * socket_accept ( const socket_t * socket ) { assert ( socket != NULL ) ; <S2SV_StartBug> int fd = accept ( socket -> fd , NULL , NULL ) ; <S2SV_EndBug> if ( fd == INVALID_FD ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>accept<S2SV_blank>socket:<S2SV_blank>%s"" , __func__ , strerror ( errno ) ) ; return NULL ; } socket_t * ret = ( socket_t * ) osi_calloc ( sizeof ( socket_t ) ) ; if ( ! ret ) { close ( fd ) ; LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>socket."" , __func__ ) ; return NULL ; } ret -> fd = fd ; return ret ; }
","<S2SV_ModStart> int fd = TEMP_FAILURE_RETRY ( <S2SV_ModStart> NULL , NULL )
"
470,"CWE-119 static void yv12_extend_frame_left_right_c ( YV12_BUFFER_CONFIG * ybf , unsigned char * y_src , unsigned char * u_src , unsigned char * v_src ) { int i ; unsigned char * src_ptr1 , * src_ptr2 ; unsigned char * dest_ptr1 , * dest_ptr2 ; unsigned int Border ; int plane_stride ; int plane_height ; int plane_width ; Border = ybf -> border ; plane_stride = ybf -> y_stride ; plane_height = 16 ; plane_width = ybf -> y_width ; src_ptr1 = y_src ; src_ptr2 = src_ptr1 + plane_width - 1 ; dest_ptr1 = src_ptr1 - Border ; dest_ptr2 = src_ptr2 + 1 ; for ( i = 0 ; i < plane_height ; i ++ ) { <S2SV_StartBug> vpx_memset ( dest_ptr1 , src_ptr1 [ 0 ] , Border ) ; <S2SV_EndBug> vpx_memset ( dest_ptr2 , src_ptr2 [ 0 ] , Border ) ; src_ptr1 += plane_stride ; src_ptr2 += plane_stride ; dest_ptr1 += plane_stride ; dest_ptr2 += plane_stride ; } plane_stride = ybf -> uv_stride ; plane_height = 8 ; plane_width = ybf -> uv_width ; Border /= 2 ; src_ptr1 = u_src ; src_ptr2 = src_ptr1 + plane_width - 1 ; dest_ptr1 = src_ptr1 - Border ; dest_ptr2 = src_ptr2 + 1 ; for ( i = 0 ; i < plane_height ; i ++ ) { <S2SV_StartBug> vpx_memset ( dest_ptr1 , src_ptr1 [ 0 ] , Border ) ; <S2SV_EndBug> vpx_memset ( dest_ptr2 , src_ptr2 [ 0 ] , Border ) ; src_ptr1 += plane_stride ; src_ptr2 += plane_stride ; dest_ptr1 += plane_stride ; dest_ptr2 += plane_stride ; } src_ptr1 = v_src ; src_ptr2 = src_ptr1 + plane_width - 1 ; dest_ptr1 = src_ptr1 - Border ; dest_ptr2 = src_ptr2 + 1 ; for ( i = 0 ; i < plane_height ; i ++ ) { <S2SV_StartBug> vpx_memset ( dest_ptr1 , src_ptr1 [ 0 ] , Border ) ; <S2SV_EndBug> vpx_memset ( dest_ptr2 , src_ptr2 [ 0 ] , Border ) ; src_ptr1 += plane_stride ; src_ptr2 += plane_stride ; dest_ptr1 += plane_stride ; dest_ptr2 += plane_stride ; } }
","<S2SV_ModStart> ++ ) { memset ( dest_ptr1 , src_ptr1 [ 0 ] , Border ) ; memset <S2SV_ModEnd> ( dest_ptr2 , <S2SV_ModStart> ++ ) { memset ( dest_ptr1 , src_ptr1 [ 0 ] , Border ) ; memset <S2SV_ModEnd> ( dest_ptr2 , <S2SV_ModStart> ++ ) { memset ( dest_ptr1 , src_ptr1 [ 0 ] , Border ) ; memset <S2SV_ModEnd> ( dest_ptr2 ,
"
471,"CWE-416 PHP_MINIT_FUNCTION ( spl_array ) { REGISTER_SPL_STD_CLASS_EX ( ArrayObject , spl_array_object_new , spl_funcs_ArrayObject ) ; REGISTER_SPL_IMPLEMENTS ( ArrayObject , Aggregate ) ; REGISTER_SPL_IMPLEMENTS ( ArrayObject , ArrayAccess ) ; REGISTER_SPL_IMPLEMENTS ( ArrayObject , Serializable ) ; REGISTER_SPL_IMPLEMENTS ( ArrayObject , Countable ) ; memcpy ( & spl_handler_ArrayObject , zend_get_std_object_handlers ( ) , sizeof ( zend_object_handlers ) ) ; spl_handler_ArrayObject . clone_obj = spl_array_object_clone ; spl_handler_ArrayObject . read_dimension = spl_array_read_dimension ; spl_handler_ArrayObject . write_dimension = spl_array_write_dimension ; spl_handler_ArrayObject . unset_dimension = spl_array_unset_dimension ; spl_handler_ArrayObject . has_dimension = spl_array_has_dimension ; spl_handler_ArrayObject . count_elements = spl_array_object_count_elements ; spl_handler_ArrayObject . get_properties = spl_array_get_properties ; <S2SV_StartBug> spl_handler_ArrayObject . get_debug_info = spl_array_get_debug_info ; <S2SV_EndBug> spl_handler_ArrayObject . read_property = spl_array_read_property ; spl_handler_ArrayObject . write_property = spl_array_write_property ; spl_handler_ArrayObject . get_property_ptr_ptr = spl_array_get_property_ptr_ptr ; spl_handler_ArrayObject . has_property = spl_array_has_property ; spl_handler_ArrayObject . unset_property = spl_array_unset_property ; spl_handler_ArrayObject . compare_objects = spl_array_compare_objects ; REGISTER_SPL_STD_CLASS_EX ( ArrayIterator , spl_array_object_new , spl_funcs_ArrayIterator ) ; REGISTER_SPL_IMPLEMENTS ( ArrayIterator , Iterator ) ; REGISTER_SPL_IMPLEMENTS ( ArrayIterator , ArrayAccess ) ; REGISTER_SPL_IMPLEMENTS ( ArrayIterator , SeekableIterator ) ; REGISTER_SPL_IMPLEMENTS ( ArrayIterator , Serializable ) ; REGISTER_SPL_IMPLEMENTS ( ArrayIterator , Countable ) ; memcpy ( & spl_handler_ArrayIterator , & spl_handler_ArrayObject , sizeof ( zend_object_handlers ) ) ; spl_ce_ArrayIterator -> get_iterator = spl_array_get_iterator ; REGISTER_SPL_SUB_CLASS_EX ( RecursiveArrayIterator , ArrayIterator , spl_array_object_new , spl_funcs_RecursiveArrayIterator ) ; REGISTER_SPL_IMPLEMENTS ( RecursiveArrayIterator , RecursiveIterator ) ; spl_ce_RecursiveArrayIterator -> get_iterator = spl_array_get_iterator ; REGISTER_SPL_CLASS_CONST_LONG ( ArrayObject , ""STD_PROP_LIST"" , SPL_ARRAY_STD_PROP_LIST ) ; REGISTER_SPL_CLASS_CONST_LONG ( ArrayObject , ""ARRAY_AS_PROPS"" , SPL_ARRAY_ARRAY_AS_PROPS ) ; REGISTER_SPL_CLASS_CONST_LONG ( ArrayIterator , ""STD_PROP_LIST"" , SPL_ARRAY_STD_PROP_LIST ) ; REGISTER_SPL_CLASS_CONST_LONG ( ArrayIterator , ""ARRAY_AS_PROPS"" , SPL_ARRAY_ARRAY_AS_PROPS ) ; REGISTER_SPL_CLASS_CONST_LONG ( RecursiveArrayIterator , ""CHILD_ARRAYS_ONLY"" , SPL_ARRAY_CHILD_ARRAYS_ONLY ) ; return SUCCESS ; }
","<S2SV_ModStart> get_debug_info = spl_array_get_debug_info ; spl_handler_ArrayObject . get_gc = spl_array_get_gc
"
472,"CWE-189 Datum hstore_from_arrays ( PG_FUNCTION_ARGS ) { int32 buflen ; HStore * out ; Pairs * pairs ; Datum * key_datums ; bool * key_nulls ; int key_count ; Datum * value_datums ; bool * value_nulls ; int value_count ; ArrayType * key_array ; ArrayType * value_array ; int i ; if ( PG_ARGISNULL ( 0 ) ) PG_RETURN_NULL ( ) ; key_array = PG_GETARG_ARRAYTYPE_P ( 0 ) ; Assert ( ARR_ELEMTYPE ( key_array ) == TEXTOID ) ; if ( ARR_NDIM ( key_array ) > 1 ) ereport ( ERROR , ( errcode ( ERRCODE_ARRAY_SUBSCRIPT_ERROR ) , errmsg ( ""wrong<S2SV_blank>number<S2SV_blank>of<S2SV_blank>array<S2SV_blank>subscripts"" ) ) ) ; deconstruct_array ( key_array , TEXTOID , - 1 , false , 'i' , <S2SV_StartBug> & key_datums , & key_nulls , & key_count ) ; <S2SV_EndBug> if ( PG_ARGISNULL ( 1 ) ) { value_array = NULL ; value_count = key_count ; value_datums = NULL ; value_nulls = NULL ; } else { value_array = PG_GETARG_ARRAYTYPE_P ( 1 ) ; Assert ( ARR_ELEMTYPE ( value_array ) == TEXTOID ) ; if ( ARR_NDIM ( value_array ) > 1 ) ereport ( ERROR , ( errcode ( ERRCODE_ARRAY_SUBSCRIPT_ERROR ) , errmsg ( ""wrong<S2SV_blank>number<S2SV_blank>of<S2SV_blank>array<S2SV_blank>subscripts"" ) ) ) ; if ( ( ARR_NDIM ( key_array ) > 0 || ARR_NDIM ( value_array ) > 0 ) && ( ARR_NDIM ( key_array ) != ARR_NDIM ( value_array ) || ARR_DIMS ( key_array ) [ 0 ] != ARR_DIMS ( value_array ) [ 0 ] || ARR_LBOUND ( key_array ) [ 0 ] != ARR_LBOUND ( value_array ) [ 0 ] ) ) ereport ( ERROR , ( errcode ( ERRCODE_ARRAY_SUBSCRIPT_ERROR ) , errmsg ( ""arrays<S2SV_blank>must<S2SV_blank>have<S2SV_blank>same<S2SV_blank>bounds"" ) ) ) ; deconstruct_array ( value_array , TEXTOID , - 1 , false , 'i' , & value_datums , & value_nulls , & value_count ) ; Assert ( key_count == value_count ) ; } pairs = palloc ( key_count * sizeof ( Pairs ) ) ; for ( i = 0 ; i < key_count ; ++ i ) { if ( key_nulls [ i ] ) ereport ( ERROR , ( errcode ( ERRCODE_NULL_VALUE_NOT_ALLOWED ) , errmsg ( ""null<S2SV_blank>value<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>for<S2SV_blank>hstore<S2SV_blank>key"" ) ) ) ; if ( ! value_nulls || value_nulls [ i ] ) { pairs [ i ] . key = VARDATA_ANY ( key_datums [ i ] ) ; pairs [ i ] . val = NULL ; pairs [ i ] . keylen = hstoreCheckKeyLen ( VARSIZE_ANY_EXHDR ( key_datums [ i ] ) ) ; pairs [ i ] . vallen = 4 ; pairs [ i ] . isnull = true ; pairs [ i ] . needfree = false ; } else { pairs [ i ] . key = VARDATA_ANY ( key_datums [ i ] ) ; pairs [ i ] . val = VARDATA_ANY ( value_datums [ i ] ) ; pairs [ i ] . keylen = hstoreCheckKeyLen ( VARSIZE_ANY_EXHDR ( key_datums [ i ] ) ) ; pairs [ i ] . vallen = hstoreCheckValLen ( VARSIZE_ANY_EXHDR ( value_datums [ i ] ) ) ; pairs [ i ] . isnull = false ; pairs [ i ] . needfree = false ; } } key_count = hstoreUniquePairs ( pairs , key_count , & buflen ) ; out = hstorePairs ( pairs , key_count , buflen ) ; PG_RETURN_POINTER ( out ) ; }
","<S2SV_ModStart> , & key_count ) ; if ( key_count > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , key_count , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) )
"
473,"CWE-617 static int connection_edge_process_relay_cell ( cell_t * cell , circuit_t * circ , edge_connection_t * conn , crypt_path_t * layer_hint ) { static int num_seen = 0 ; relay_header_t rh ; unsigned domain = layer_hint ? LD_APP : LD_EXIT ; int reason ; int optimistic_data = 0 ; tor_assert ( cell ) ; tor_assert ( circ ) ; relay_header_unpack ( & rh , cell -> payload ) ; num_seen ++ ; log_debug ( domain , ""Now<S2SV_blank>seen<S2SV_blank>%d<S2SV_blank>relay<S2SV_blank>cells<S2SV_blank>here<S2SV_blank>(command<S2SV_blank>%d,<S2SV_blank>stream<S2SV_blank>%d)."" , num_seen , rh . command , rh . stream_id ) ; if ( rh . length > RELAY_PAYLOAD_SIZE ) { log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , ""Relay<S2SV_blank>cell<S2SV_blank>length<S2SV_blank>field<S2SV_blank>too<S2SV_blank>long.<S2SV_blank>Closing<S2SV_blank>circuit."" ) ; return - END_CIRC_REASON_TORPROTOCOL ; } if ( rh . stream_id == 0 ) { switch ( rh . command ) { case RELAY_COMMAND_BEGIN : case RELAY_COMMAND_CONNECTED : case RELAY_COMMAND_DATA : case RELAY_COMMAND_END : case RELAY_COMMAND_RESOLVE : case RELAY_COMMAND_RESOLVED : case RELAY_COMMAND_BEGIN_DIR : log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , ""Relay<S2SV_blank>command<S2SV_blank>%d<S2SV_blank>with<S2SV_blank>zero<S2SV_blank>"" ""stream_id.<S2SV_blank>Dropping."" , ( int ) rh . command ) ; return 0 ; default : ; } } if ( conn && ! connection_state_is_open ( TO_CONN ( conn ) ) ) { if ( conn -> base_ . type == CONN_TYPE_EXIT && ( conn -> base_ . state == EXIT_CONN_STATE_CONNECTING || conn -> base_ . state == EXIT_CONN_STATE_RESOLVING ) && rh . command == RELAY_COMMAND_DATA ) { optimistic_data = 1 ; } else { return connection_edge_process_relay_cell_not_open ( & rh , cell , circ , conn , layer_hint ) ; } } switch ( rh . command ) { case RELAY_COMMAND_DROP : return 0 ; case RELAY_COMMAND_BEGIN : case RELAY_COMMAND_BEGIN_DIR : if ( layer_hint && circ -> purpose != CIRCUIT_PURPOSE_S_REND_JOINED ) { log_fn ( LOG_PROTOCOL_WARN , LD_APP , ""Relay<S2SV_blank>begin<S2SV_blank>request<S2SV_blank>unsupported<S2SV_blank>at<S2SV_blank>AP.<S2SV_blank>Dropping."" ) ; return 0 ; } if ( circ -> purpose == CIRCUIT_PURPOSE_S_REND_JOINED && layer_hint != TO_ORIGIN_CIRCUIT ( circ ) -> cpath -> prev ) { log_fn ( LOG_PROTOCOL_WARN , LD_APP , ""Relay<S2SV_blank>begin<S2SV_blank>request<S2SV_blank>to<S2SV_blank>Hidden<S2SV_blank>Service<S2SV_blank>"" ""from<S2SV_blank>intermediary<S2SV_blank>node.<S2SV_blank>Dropping."" ) ; return 0 ; } if ( conn ) { log_fn ( LOG_PROTOCOL_WARN , domain , ""Begin<S2SV_blank>cell<S2SV_blank>for<S2SV_blank>known<S2SV_blank>stream.<S2SV_blank>Dropping."" ) ; return 0 ; } <S2SV_StartBug> if ( rh . command == RELAY_COMMAND_BEGIN_DIR ) { <S2SV_EndBug> static uint64_t next_id = 0 ; circ -> dirreq_id = ++ next_id ; TO_OR_CIRCUIT ( circ ) -> p_chan -> dirreq_id = circ -> dirreq_id ; } return connection_exit_begin_conn ( cell , circ ) ; case RELAY_COMMAND_DATA : ++ stats_n_data_cells_received ; if ( ( layer_hint && -- layer_hint -> deliver_window < 0 ) || ( ! layer_hint && -- circ -> deliver_window < 0 ) ) { log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , ""(relay<S2SV_blank>data)<S2SV_blank>circ<S2SV_blank>deliver_window<S2SV_blank>below<S2SV_blank>0.<S2SV_blank>Killing."" ) ; if ( conn ) { connection_edge_end ( conn , END_STREAM_REASON_TORPROTOCOL ) ; connection_mark_for_close ( TO_CONN ( conn ) ) ; } return - END_CIRC_REASON_TORPROTOCOL ; } log_debug ( domain , ""circ<S2SV_blank>deliver_window<S2SV_blank>now<S2SV_blank>%d."" , layer_hint ? layer_hint -> deliver_window : circ -> deliver_window ) ; circuit_consider_sending_sendme ( circ , layer_hint ) ; if ( ! conn ) { log_info ( domain , ""data<S2SV_blank>cell<S2SV_blank>dropped,<S2SV_blank>unknown<S2SV_blank>stream<S2SV_blank>(streamid<S2SV_blank>%d)."" , rh . stream_id ) ; return 0 ; } if ( -- conn -> deliver_window < 0 ) { log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , ""(relay<S2SV_blank>data)<S2SV_blank>conn<S2SV_blank>deliver_window<S2SV_blank>below<S2SV_blank>0.<S2SV_blank>Killing."" ) ; return - END_CIRC_REASON_TORPROTOCOL ; } stats_n_data_bytes_received += rh . length ; connection_write_to_buf ( ( char * ) ( cell -> payload + RELAY_HEADER_SIZE ) , rh . length , TO_CONN ( conn ) ) ; if ( ! optimistic_data ) { connection_edge_consider_sending_sendme ( conn ) ; } return 0 ; case RELAY_COMMAND_END : reason = rh . length > 0 ? get_uint8 ( cell -> payload + RELAY_HEADER_SIZE ) : END_STREAM_REASON_MISC ; if ( ! conn ) { log_info ( domain , ""end<S2SV_blank>cell<S2SV_blank>(%s)<S2SV_blank>dropped,<S2SV_blank>unknown<S2SV_blank>stream."" , stream_end_reason_to_string ( reason ) ) ; return 0 ; } log_info ( domain , TOR_SOCKET_T_FORMAT "":<S2SV_blank>end<S2SV_blank>cell<S2SV_blank>(%s)<S2SV_blank>for<S2SV_blank>stream<S2SV_blank>%d.<S2SV_blank>"" ""Removing<S2SV_blank>stream."" , conn -> base_ . s , stream_end_reason_to_string ( reason ) , conn -> stream_id ) ; if ( conn -> base_ . type == CONN_TYPE_AP ) { entry_connection_t * entry_conn = EDGE_TO_ENTRY_CONN ( conn ) ; if ( entry_conn -> socks_request && ! entry_conn -> socks_request -> has_finished ) log_warn ( LD_BUG , ""open<S2SV_blank>stream<S2SV_blank>hasn\'t<S2SV_blank>sent<S2SV_blank>socks<S2SV_blank>answer<S2SV_blank>yet?<S2SV_blank>Closing."" ) ; } conn -> edge_has_sent_end = 1 ; if ( ! conn -> end_reason ) conn -> end_reason = reason | END_STREAM_REASON_FLAG_REMOTE ; if ( ! conn -> base_ . marked_for_close ) { connection_mark_and_flush ( TO_CONN ( conn ) ) ; } return 0 ; case RELAY_COMMAND_EXTEND : case RELAY_COMMAND_EXTEND2 : { static uint64_t total_n_extend = 0 , total_nonearly = 0 ; total_n_extend ++ ; if ( rh . stream_id ) { log_fn ( LOG_PROTOCOL_WARN , domain , ""\'extend\'<S2SV_blank>cell<S2SV_blank>received<S2SV_blank>for<S2SV_blank>non-zero<S2SV_blank>stream.<S2SV_blank>Dropping."" ) ; return 0 ; } if ( cell -> command != CELL_RELAY_EARLY && ! networkstatus_get_param ( NULL , ""AllowNonearlyExtend"" , 0 , 0 , 1 ) ) { # define EARLY_WARNING_INTERVAL 3600 static ratelim_t early_warning_limit = RATELIM_INIT ( EARLY_WARNING_INTERVAL ) ; char * m ; if ( cell -> command == CELL_RELAY ) { ++ total_nonearly ; if ( ( m = rate_limit_log ( & early_warning_limit , approx_time ( ) ) ) ) { double percentage = ( ( double ) total_nonearly ) / total_n_extend ; percentage *= 100 ; log_fn ( LOG_PROTOCOL_WARN , domain , ""EXTEND<S2SV_blank>cell<S2SV_blank>received,<S2SV_blank>"" ""but<S2SV_blank>not<S2SV_blank>via<S2SV_blank>RELAY_EARLY.<S2SV_blank>Dropping.%s"" , m ) ; log_fn ( LOG_PROTOCOL_WARN , domain , ""<S2SV_blank><S2SV_blank>(We<S2SV_blank>have<S2SV_blank>dropped<S2SV_blank>%.02f%%<S2SV_blank>of<S2SV_blank>"" ""all<S2SV_blank>EXTEND<S2SV_blank>cells<S2SV_blank>for<S2SV_blank>this<S2SV_blank>reason)"" , percentage ) ; tor_free ( m ) ; } } else { log_fn ( LOG_WARN , domain , ""EXTEND<S2SV_blank>cell<S2SV_blank>received,<S2SV_blank>in<S2SV_blank>a<S2SV_blank>cell<S2SV_blank>with<S2SV_blank>type<S2SV_blank>%d!<S2SV_blank>Dropping."" , cell -> command ) ; } return 0 ; } return circuit_extend ( cell , circ ) ; } case RELAY_COMMAND_EXTENDED : case RELAY_COMMAND_EXTENDED2 : if ( ! layer_hint ) { log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , ""\'extended\'<S2SV_blank>unsupported<S2SV_blank>at<S2SV_blank>non-origin.<S2SV_blank>Dropping."" ) ; return 0 ; } log_debug ( domain , ""Got<S2SV_blank>an<S2SV_blank>extended<S2SV_blank>cell!<S2SV_blank>Yay."" ) ; { extended_cell_t extended_cell ; if ( extended_cell_parse ( & extended_cell , rh . command , ( const uint8_t * ) cell -> payload + RELAY_HEADER_SIZE , rh . length ) < 0 ) { log_warn ( LD_PROTOCOL , ""Can\'t<S2SV_blank>parse<S2SV_blank>EXTENDED<S2SV_blank>cell;<S2SV_blank>killing<S2SV_blank>circuit."" ) ; return - END_CIRC_REASON_TORPROTOCOL ; } if ( ( reason = circuit_finish_handshake ( TO_ORIGIN_CIRCUIT ( circ ) , & extended_cell . created_cell ) ) < 0 ) { log_warn ( domain , ""circuit_finish_handshake<S2SV_blank>failed."" ) ; return reason ; } } if ( ( reason = circuit_send_next_onion_skin ( TO_ORIGIN_CIRCUIT ( circ ) ) ) < 0 ) { log_info ( domain , ""circuit_send_next_onion_skin()<S2SV_blank>failed."" ) ; return reason ; } return 0 ; case RELAY_COMMAND_TRUNCATE : if ( layer_hint ) { log_fn ( LOG_PROTOCOL_WARN , LD_APP , ""\'truncate\'<S2SV_blank>unsupported<S2SV_blank>at<S2SV_blank>origin.<S2SV_blank>Dropping."" ) ; return 0 ; } if ( circ -> n_hop ) { if ( circ -> n_chan ) log_warn ( LD_BUG , ""n_chan<S2SV_blank>and<S2SV_blank>n_hop<S2SV_blank>set<S2SV_blank>on<S2SV_blank>the<S2SV_blank>same<S2SV_blank>circuit!"" ) ; extend_info_free ( circ -> n_hop ) ; circ -> n_hop = NULL ; tor_free ( circ -> n_chan_create_cell ) ; circuit_set_state ( circ , CIRCUIT_STATE_OPEN ) ; } if ( circ -> n_chan ) { uint8_t trunc_reason = get_uint8 ( cell -> payload + RELAY_HEADER_SIZE ) ; circuit_clear_cell_queue ( circ , circ -> n_chan ) ; channel_send_destroy ( circ -> n_circ_id , circ -> n_chan , trunc_reason ) ; circuit_set_n_circid_chan ( circ , 0 , NULL ) ; } log_debug ( LD_EXIT , ""Processed<S2SV_blank>\'truncate\',<S2SV_blank>replying."" ) ; { char payload [ 1 ] ; payload [ 0 ] = ( char ) END_CIRC_REASON_REQUESTED ; relay_send_command_from_edge ( 0 , circ , RELAY_COMMAND_TRUNCATED , payload , sizeof ( payload ) , NULL ) ; } return 0 ; case RELAY_COMMAND_TRUNCATED : if ( ! layer_hint ) { log_fn ( LOG_PROTOCOL_WARN , LD_EXIT , ""\'truncated\'<S2SV_blank>unsupported<S2SV_blank>at<S2SV_blank>non-origin.<S2SV_blank>Dropping."" ) ; return 0 ; } circuit_truncated ( TO_ORIGIN_CIRCUIT ( circ ) , layer_hint , get_uint8 ( cell -> payload + RELAY_HEADER_SIZE ) ) ; return 0 ; case RELAY_COMMAND_CONNECTED : if ( conn ) { log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , ""\'connected\'<S2SV_blank>unsupported<S2SV_blank>while<S2SV_blank>open.<S2SV_blank>Closing<S2SV_blank>circ."" ) ; return - END_CIRC_REASON_TORPROTOCOL ; } log_info ( domain , ""\'connected\'<S2SV_blank>received,<S2SV_blank>no<S2SV_blank>conn<S2SV_blank>attached<S2SV_blank>anymore.<S2SV_blank>Ignoring."" ) ; return 0 ; case RELAY_COMMAND_SENDME : if ( ! rh . stream_id ) { if ( layer_hint ) { if ( layer_hint -> package_window + CIRCWINDOW_INCREMENT > CIRCWINDOW_START_MAX ) { log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , ""Unexpected<S2SV_blank>sendme<S2SV_blank>cell<S2SV_blank>from<S2SV_blank>exit<S2SV_blank>relay.<S2SV_blank>"" ""Closing<S2SV_blank>circ."" ) ; return - END_CIRC_REASON_TORPROTOCOL ; } layer_hint -> package_window += CIRCWINDOW_INCREMENT ; log_debug ( LD_APP , ""circ-level<S2SV_blank>sendme<S2SV_blank>at<S2SV_blank>origin,<S2SV_blank>packagewindow<S2SV_blank>%d."" , layer_hint -> package_window ) ; circuit_resume_edge_reading ( circ , layer_hint ) ; } else { if ( circ -> package_window + CIRCWINDOW_INCREMENT > CIRCWINDOW_START_MAX ) { log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , ""Unexpected<S2SV_blank>sendme<S2SV_blank>cell<S2SV_blank>from<S2SV_blank>client.<S2SV_blank>"" ""Closing<S2SV_blank>circ<S2SV_blank>(window<S2SV_blank>%d)."" , circ -> package_window ) ; return - END_CIRC_REASON_TORPROTOCOL ; } circ -> package_window += CIRCWINDOW_INCREMENT ; log_debug ( LD_APP , ""circ-level<S2SV_blank>sendme<S2SV_blank>at<S2SV_blank>non-origin,<S2SV_blank>packagewindow<S2SV_blank>%d."" , circ -> package_window ) ; circuit_resume_edge_reading ( circ , layer_hint ) ; } return 0 ; } if ( ! conn ) { log_info ( domain , ""sendme<S2SV_blank>cell<S2SV_blank>dropped,<S2SV_blank>unknown<S2SV_blank>stream<S2SV_blank>(streamid<S2SV_blank>%d)."" , rh . stream_id ) ; return 0 ; } conn -> package_window += STREAMWINDOW_INCREMENT ; log_debug ( domain , ""stream-level<S2SV_blank>sendme,<S2SV_blank>packagewindow<S2SV_blank>now<S2SV_blank>%d."" , conn -> package_window ) ; if ( circuit_queue_streams_are_blocked ( circ ) ) { return 0 ; } connection_start_reading ( TO_CONN ( conn ) ) ; if ( connection_edge_package_raw_inbuf ( conn , 1 , NULL ) < 0 ) { connection_mark_for_close ( TO_CONN ( conn ) ) ; return 0 ; } return 0 ; case RELAY_COMMAND_RESOLVE : if ( layer_hint ) { log_fn ( LOG_PROTOCOL_WARN , LD_APP , ""resolve<S2SV_blank>request<S2SV_blank>unsupported<S2SV_blank>at<S2SV_blank>AP;<S2SV_blank>dropping."" ) ; return 0 ; } else if ( conn ) { log_fn ( LOG_PROTOCOL_WARN , domain , ""resolve<S2SV_blank>request<S2SV_blank>for<S2SV_blank>known<S2SV_blank>stream;<S2SV_blank>dropping."" ) ; return 0 ; } else if ( circ -> purpose != CIRCUIT_PURPOSE_OR ) { log_fn ( LOG_PROTOCOL_WARN , domain , ""resolve<S2SV_blank>request<S2SV_blank>on<S2SV_blank>circ<S2SV_blank>with<S2SV_blank>purpose<S2SV_blank>%d;<S2SV_blank>dropping"" , circ -> purpose ) ; return 0 ; } connection_exit_begin_resolve ( cell , TO_OR_CIRCUIT ( circ ) ) ; return 0 ; case RELAY_COMMAND_RESOLVED : if ( conn ) { log_fn ( LOG_PROTOCOL_WARN , domain , ""\'resolved\'<S2SV_blank>unsupported<S2SV_blank>while<S2SV_blank>open.<S2SV_blank>Closing<S2SV_blank>circ."" ) ; return - END_CIRC_REASON_TORPROTOCOL ; } log_info ( domain , ""\'resolved\'<S2SV_blank>received,<S2SV_blank>no<S2SV_blank>conn<S2SV_blank>attached<S2SV_blank>anymore.<S2SV_blank>Ignoring."" ) ; return 0 ; case RELAY_COMMAND_ESTABLISH_INTRO : case RELAY_COMMAND_ESTABLISH_RENDEZVOUS : case RELAY_COMMAND_INTRODUCE1 : case RELAY_COMMAND_INTRODUCE2 : case RELAY_COMMAND_INTRODUCE_ACK : case RELAY_COMMAND_RENDEZVOUS1 : case RELAY_COMMAND_RENDEZVOUS2 : case RELAY_COMMAND_INTRO_ESTABLISHED : case RELAY_COMMAND_RENDEZVOUS_ESTABLISHED : rend_process_relay_cell ( circ , layer_hint , rh . command , rh . length , cell -> payload + RELAY_HEADER_SIZE ) ; return 0 ; } log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , ""Received<S2SV_blank>unknown<S2SV_blank>relay<S2SV_blank>command<S2SV_blank>%d.<S2SV_blank>Perhaps<S2SV_blank>the<S2SV_blank>other<S2SV_blank>side<S2SV_blank>is<S2SV_blank>using<S2SV_blank>"" ""a<S2SV_blank>newer<S2SV_blank>version<S2SV_blank>of<S2SV_blank>Tor?<S2SV_blank>Dropping."" , rh . command ) ; return 0 ; }
","<S2SV_ModStart> command == RELAY_COMMAND_BEGIN_DIR && circ -> purpose != CIRCUIT_PURPOSE_S_REND_JOINED
"
474,"CWE-17 static struct super_block * alloc_super ( struct file_system_type * type , int flags ) { struct super_block * s = kzalloc ( sizeof ( struct super_block ) , GFP_USER ) ; static const struct super_operations default_op ; int i ; if ( ! s ) return NULL ; if ( security_sb_alloc ( s ) ) goto fail ; <S2SV_StartBug> # ifdef CONFIG_SMP <S2SV_EndBug> s -> s_files = alloc_percpu ( struct list_head ) ; if ( ! s -> s_files ) goto fail ; <S2SV_StartBug> for_each_possible_cpu ( i ) <S2SV_EndBug> INIT_LIST_HEAD ( per_cpu_ptr ( s -> s_files , i ) ) ; # else INIT_LIST_HEAD ( & s -> s_files ) ; # endif for ( i = 0 ; i < SB_FREEZE_LEVELS ; i ++ ) { if ( percpu_counter_init ( & s -> s_writers . counter [ i ] , 0 ) < 0 ) goto fail ; <S2SV_StartBug> lockdep_init_map ( & s -> s_writers . lock_map [ i ] , sb_writers_name [ i ] , <S2SV_EndBug> & type -> s_writers_key [ i ] , 0 ) ; } init_waitqueue_head ( & s -> s_writers . wait ) ; init_waitqueue_head ( & s -> s_writers . wait_unfrozen ) ; s -> s_flags = flags ; s -> s_bdi = & default_backing_dev_info ; INIT_HLIST_NODE ( & s -> s_instances ) ; INIT_HLIST_BL_HEAD ( & s -> s_anon ) ; INIT_LIST_HEAD ( & s -> s_inodes ) ; <S2SV_StartBug> if ( list_lru_init ( & s -> s_dentry_lru ) ) <S2SV_EndBug> goto fail ; <S2SV_StartBug> if ( list_lru_init ( & s -> s_inode_lru ) ) <S2SV_EndBug> goto fail ; INIT_LIST_HEAD ( & s -> s_mounts ) ; init_rwsem ( & s -> s_umount ) ; lockdep_set_class ( & s -> s_umount , & type -> s_umount_key ) ; down_write_nested ( & s -> s_umount , SINGLE_DEPTH_NESTING ) ; s -> s_count = 1 ; atomic_set ( & s -> s_active , 1 ) ; mutex_init ( & s -> s_vfs_rename_mutex ) ; lockdep_set_class ( & s -> s_vfs_rename_mutex , & type -> s_vfs_rename_key ) ; mutex_init ( & s -> s_dquot . dqio_mutex ) ; mutex_init ( & s -> s_dquot . dqonoff_mutex ) ; init_rwsem ( & s -> s_dquot . dqptr_sem ) ; s -> s_maxbytes = MAX_NON_LFS ; s -> s_op = & default_op ; s -> s_time_gran = 1000000000 ; s -> cleancache_poolid = - 1 ; s -> s_shrink . seeks = DEFAULT_SEEKS ; s -> s_shrink . scan_objects = super_cache_scan ; s -> s_shrink . count_objects = super_cache_count ; s -> s_shrink . batch = 1024 ; s -> s_shrink . flags = SHRINKER_NUMA_AWARE ; return s ; fail : destroy_super ( s ) ; return NULL ; }
","<S2SV_ModStart> goto fail ; for ( i = 0 ; i < SB_FREEZE_LEVELS ; i ++ ) { if ( percpu_counter_init ( & s -> s_writers . counter [ i ] , 0 ) < 0 <S2SV_ModEnd> ) goto fail <S2SV_ModStart> goto fail ; lockdep_init_map ( & s -> s_writers . lock_map [ i ] , sb_writers_name [ i ] , & type -> s_writers_key [ i ] , 0 ) ; } init_waitqueue_head ( & s -> s_writers . wait ) ; init_waitqueue_head ( & s -> s_writers . wait_unfrozen ) ; s -> s_flags = flags ; s -> s_bdi = & default_backing_dev_info ; INIT_HLIST_NODE ( & s -> s_instances ) ; INIT_HLIST_BL_HEAD ( & s -> s_anon ) ; INIT_LIST_HEAD ( & s -> s_inodes ) ; if ( list_lru_init ( & s -> s_dentry_lru ) <S2SV_ModEnd> ) goto fail <S2SV_ModStart> goto fail ; <S2SV_ModEnd> if ( list_lru_init <S2SV_ModStart> & s -> s_inode_lru <S2SV_ModEnd> ) ) goto <S2SV_ModStart> goto fail ; <S2SV_ModEnd> INIT_LIST_HEAD ( &
"
475,"CWE-000 static int unix_dgram_connect ( struct socket * sock , struct sockaddr * addr , int alen , int flags ) { struct sock * sk = sock -> sk ; struct net * net = sock_net ( sk ) ; struct sockaddr_un * sunaddr = ( struct sockaddr_un * ) addr ; struct sock * other ; unsigned int hash ; int err ; if ( addr -> sa_family != AF_UNSPEC ) { err = unix_mkname ( sunaddr , alen , & hash ) ; if ( err < 0 ) goto out ; alen = err ; if ( test_bit ( SOCK_PASSCRED , & sock -> flags ) && ! unix_sk ( sk ) -> addr && ( err = unix_autobind ( sock ) ) != 0 ) goto out ; restart : other = unix_find_other ( net , sunaddr , alen , sock -> type , hash , & err ) ; if ( ! other ) goto out ; unix_state_double_lock ( sk , other ) ; if ( sock_flag ( other , SOCK_DEAD ) ) { unix_state_double_unlock ( sk , other ) ; sock_put ( other ) ; goto restart ; } err = - EPERM ; if ( ! unix_may_send ( sk , other ) ) goto out_unlock ; err = security_unix_may_send ( sk -> sk_socket , other -> sk_socket ) ; if ( err ) goto out_unlock ; } else { other = NULL ; unix_state_double_lock ( sk , other ) ; } if ( unix_peer ( sk ) ) { struct sock * old_peer = unix_peer ( sk ) ; unix_peer ( sk ) = other ; <S2SV_StartBug> unix_state_double_unlock ( sk , other ) ; <S2SV_EndBug> if ( other != old_peer ) unix_dgram_disconnected ( sk , old_peer ) ; sock_put ( old_peer ) ; } else { unix_peer ( sk ) = other ; unix_state_double_unlock ( sk , other ) ; } return 0 ; out_unlock : unix_state_double_unlock ( sk , other ) ; sock_put ( other ) ; out : return err ; }
","<S2SV_ModStart> = other ; unix_dgram_peer_wake_disconnect_wakeup ( sk , old_peer ) ;
"
476,"CWE-119 static INLINE void store_pred_mv ( MACROBLOCK * x , PICK_MODE_CONTEXT * ctx ) { <S2SV_StartBug> vpx_memcpy ( ctx -> pred_mv , x -> pred_mv , sizeof ( x -> pred_mv ) ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ctx ) { memcpy <S2SV_ModEnd> ( ctx ->
"
477,"CWE-787 int main ( int argc , char * argv [ ] ) { int32_t ret = GPMF_OK ; GPMF_stream metadata_stream , * ms = & metadata_stream ; double metadatalength ; uint32_t * payload = NULL ; if ( argc != 2 ) { printf ( ""usage:<S2SV_blank>%s<S2SV_blank><file_with_GPMF>\\n"" , argv [ 0 ] ) ; return - 1 ; } size_t mp4 = OpenMP4Source ( argv [ 1 ] , MOV_GPMF_TRAK_TYPE , MOV_GPMF_TRAK_SUBTYPE ) ; <S2SV_StartBug> metadatalength = GetDuration ( mp4 ) ; <S2SV_EndBug> if ( metadatalength > 0.0 ) { uint32_t index , payloads = GetNumberPayloads ( mp4 ) ; # if 1 if ( payloads == 1 ) { uint32_t payloadsize = GetPayloadSize ( mp4 , 0 ) ; payload = GetPayload ( mp4 , payload , 0 ) ; if ( payload == NULL ) goto cleanup ; ret = GPMF_Init ( ms , payload , payloadsize ) ; if ( ret != GPMF_OK ) goto cleanup ; ret = GPMF_Validate ( ms , GPMF_RECURSE_LEVELS ) ; if ( GPMF_OK != ret ) { printf ( ""Invalid<S2SV_blank>Structure\\n"" ) ; goto cleanup ; } GPMF_ResetState ( ms ) ; do { PrintGPMF ( ms ) ; } while ( GPMF_OK == GPMF_Next ( ms , GPMF_RECURSE_LEVELS ) ) ; GPMF_ResetState ( ms ) ; printf ( ""\\n"" ) ; } # endif for ( index = 0 ; index < payloads ; index ++ ) { uint32_t payloadsize = GetPayloadSize ( mp4 , index ) ; <S2SV_StartBug> float in = 0.0 , out = 0.0 ; <S2SV_EndBug> payload = GetPayload ( mp4 , payload , index ) ; if ( payload == NULL ) goto cleanup ; ret = GetPayloadTime ( mp4 , index , & in , & out ) ; if ( ret != GPMF_OK ) goto cleanup ; ret = GPMF_Init ( ms , payload , payloadsize ) ; if ( ret != GPMF_OK ) goto cleanup ; # if 1 if ( index == 0 ) { ret = GPMF_FindNext ( ms , GPMF_KEY_STREAM , GPMF_RECURSE_LEVELS ) ; while ( GPMF_OK == ret ) { ret = GPMF_SeekToSamples ( ms ) ; if ( GPMF_OK == ret ) { uint32_t key = GPMF_Key ( ms ) ; GPMF_SampleType type = GPMF_Type ( ms ) ; uint32_t elements = GPMF_ElementsInStruct ( ms ) ; uint32_t samples = GPMF_PayloadSampleCount ( ms ) ; if ( samples ) { printf ( ""<S2SV_blank><S2SV_blank>STRM<S2SV_blank>of<S2SV_blank>%c%c%c%c<S2SV_blank>"" , PRINTF_4CC ( key ) ) ; if ( type == GPMF_TYPE_COMPLEX ) { GPMF_stream find_stream ; GPMF_CopyState ( ms , & find_stream ) ; if ( GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_TYPE , GPMF_CURRENT_LEVEL ) ) { char tmp [ 64 ] ; char * data = ( char * ) GPMF_RawData ( & find_stream ) ; int size = GPMF_RawDataSize ( & find_stream ) ; if ( size < sizeof ( tmp ) ) { memcpy ( tmp , data , size ) ; tmp [ size ] = 0 ; printf ( ""of<S2SV_blank>type<S2SV_blank>%s<S2SV_blank>"" , tmp ) ; } } } else { printf ( ""of<S2SV_blank>type<S2SV_blank>%c<S2SV_blank>"" , type ) ; } printf ( ""with<S2SV_blank>%d<S2SV_blank>sample%s<S2SV_blank>"" , samples , samples > 1 ? ""s"" : """" ) ; if ( elements > 1 ) printf ( ""--<S2SV_blank>%d<S2SV_blank>elements<S2SV_blank>per<S2SV_blank>sample"" , elements ) ; printf ( ""\\n"" ) ; } ret = GPMF_FindNext ( ms , GPMF_KEY_STREAM , GPMF_RECURSE_LEVELS ) ; } else { if ( ret == GPMF_ERROR_BAD_STRUCTURE ) { ret = GPMF_Next ( ms , GPMF_CURRENT_LEVEL ) ; } } } GPMF_ResetState ( ms ) ; printf ( ""\\n"" ) ; } # endif # if 1 if ( index == 0 ) { if ( GPMF_OK == GPMF_FindNext ( ms , STR2FOURCC ( ""GPS5"" ) , GPMF_RECURSE_LEVELS ) || GPMF_OK == GPMF_FindNext ( ms , STR2FOURCC ( ""GPRI"" ) , GPMF_RECURSE_LEVELS ) ) { uint32_t key = GPMF_Key ( ms ) ; uint32_t samples = GPMF_Repeat ( ms ) ; uint32_t elements = GPMF_ElementsInStruct ( ms ) ; uint32_t buffersize = samples * elements * sizeof ( double ) ; GPMF_stream find_stream ; double * ptr , * tmpbuffer = malloc ( buffersize ) ; char units [ 10 ] [ 6 ] = { """" } ; uint32_t unit_samples = 1 ; printf ( ""MP4<S2SV_blank>Payload<S2SV_blank>time<S2SV_blank>%.3f<S2SV_blank>to<S2SV_blank>%.3f<S2SV_blank>seconds\\n"" , in , out ) ; if ( tmpbuffer && samples ) { uint32_t i , j ; GPMF_CopyState ( ms , & find_stream ) ; if ( GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_SI_UNITS , GPMF_CURRENT_LEVEL ) || GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_UNITS , GPMF_CURRENT_LEVEL ) ) { char * data = ( char * ) GPMF_RawData ( & find_stream ) ; int ssize = GPMF_StructSize ( & find_stream ) ; unit_samples = GPMF_Repeat ( & find_stream ) ; for ( i = 0 ; i < unit_samples ; i ++ ) { memcpy ( units [ i ] , data , ssize ) ; units [ i ] [ ssize ] = 0 ; data += ssize ; } } GPMF_ScaledData ( ms , tmpbuffer , buffersize , 0 , samples , GPMF_TYPE_DOUBLE ) ; ptr = tmpbuffer ; for ( i = 0 ; i < samples ; i ++ ) { printf ( ""%c%c%c%c<S2SV_blank>"" , PRINTF_4CC ( key ) ) ; for ( j = 0 ; j < elements ; j ++ ) printf ( ""%.3f%s,<S2SV_blank>"" , * ptr ++ , units [ j % unit_samples ] ) ; printf ( ""\\n"" ) ; } free ( tmpbuffer ) ; } } GPMF_ResetState ( ms ) ; printf ( ""\\n"" ) ; } # endif } # if 1 while ( GPMF_OK == GPMF_FindNext ( ms , GPMF_KEY_STREAM , GPMF_RECURSE_LEVELS ) ) { if ( GPMF_OK == GPMF_SeekToSamples ( ms ) ) { <S2SV_StartBug> uint32_t fourcc = GPMF_Key ( ms ) ; <S2SV_EndBug> <S2SV_StartBug> double rate = GetGPMFSampleRate ( mp4 , fourcc , GPMF_SAMPLE_RATE_PRECISE ) ; <S2SV_EndBug> <S2SV_StartBug> printf ( ""%c%c%c%c<S2SV_blank>sampling<S2SV_blank>rate<S2SV_blank>=<S2SV_blank>%f<S2SV_blank>Hz\\n"" , PRINTF_4CC ( fourcc ) , rate ) ; <S2SV_EndBug> } } # endif cleanup : if ( payload ) FreePayload ( payload ) ; payload = NULL ; CloseSource ( mp4 ) ; } return ret ; }
","<S2SV_ModStart> MOV_GPMF_TRAK_SUBTYPE ) ; if ( mp4 == 0 ) { printf ( ""error:<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>MP4/MOV\\n"" , argv [ 1 ] ) ; return - 1 ; } <S2SV_ModStart> index ) ; double <S2SV_ModEnd> in = 0.0 <S2SV_ModStart> ) ) { double in = 0.0 , out = 0.0 ; <S2SV_ModStart> fourcc , GPMF_SAMPLE_RATE_PRECISE , & in , & out ) ; printf ( ""%c%c%c%c<S2SV_blank>sampling<S2SV_blank>rate<S2SV_blank>=<S2SV_blank>%f<S2SV_blank>Hz<S2SV_blank>(from<S2SV_blank>%f<S2SV_blank>to<S2SV_blank>%f)\\n"" <S2SV_ModEnd> , PRINTF_4CC ( <S2SV_ModStart> ) , rate , in , out
"
478,"CWE-125 u_int atm_if_print ( netdissect_options * ndo , const struct pcap_pkthdr * h , const u_char * p ) { u_int caplen = h -> caplen ; u_int length = h -> len ; uint32_t llchdr ; u_int hdrlen = 0 ; if ( caplen < 1 || length < 1 ) { ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return ( caplen ) ; } if ( * p == LLC_UI ) { if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""CNLPID<S2SV_blank>"" ) ) ; <S2SV_StartBug> isoclns_print ( ndo , p + 1 , length - 1 , caplen - 1 ) ; <S2SV_EndBug> return hdrlen ; } if ( caplen < 3 || length < 3 ) { ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return ( caplen ) ; } llchdr = EXTRACT_24BITS ( p ) ; if ( llchdr != LLC_UI_HDR ( LLCSAP_SNAP ) && llchdr != LLC_UI_HDR ( LLCSAP_ISONS ) && llchdr != LLC_UI_HDR ( LLCSAP_IP ) ) { if ( caplen < 20 || length < 20 ) { ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return ( caplen ) ; } if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""%08x%08x<S2SV_blank>%08x%08x<S2SV_blank>"" , EXTRACT_32BITS ( p ) , EXTRACT_32BITS ( p + 4 ) , EXTRACT_32BITS ( p + 8 ) , EXTRACT_32BITS ( p + 12 ) ) ) ; p += 20 ; length -= 20 ; caplen -= 20 ; hdrlen += 20 ; } hdrlen += atm_llc_print ( ndo , p , length , caplen ) ; return ( hdrlen ) ; }
","<S2SV_ModStart> length - 1 <S2SV_ModEnd> ) ; return
"
479,"CWE-125 static MagickBooleanType Get8BIMProperty ( const Image * image , const char * key , ExceptionInfo * exception ) { char * attribute , format [ MagickPathExtent ] , name [ MagickPathExtent ] , * resource ; const StringInfo * profile ; const unsigned char * info ; long start , stop ; MagickBooleanType status ; register ssize_t i ; size_t length ; ssize_t count , id , sub_number ; profile = GetImageProfile ( image , ""8bim"" ) ; if ( profile == ( StringInfo * ) NULL ) return ( MagickFalse ) ; count = ( ssize_t ) sscanf ( key , ""8BIM:%ld,%ld:%1024[^\\n]\\n%1024[^\\n]"" , & start , & stop , name , format ) ; if ( ( count != 2 ) && ( count != 3 ) && ( count != 4 ) ) return ( MagickFalse ) ; if ( count < 4 ) ( void ) CopyMagickString ( format , ""SVG"" , MagickPathExtent ) ; if ( count < 3 ) * name = '\\0' ; sub_number = 1 ; if ( * name == '#' ) sub_number = ( ssize_t ) StringToLong ( & name [ 1 ] ) ; sub_number = MagickMax ( sub_number , 1L ) ; resource = ( char * ) NULL ; status = MagickFalse ; length = GetStringInfoLength ( profile ) ; info = GetStringInfoDatum ( profile ) ; while ( ( length > 0 ) && ( status == MagickFalse ) ) { if ( ReadPropertyByte ( & info , & length ) != ( unsigned char ) '8' ) continue ; if ( ReadPropertyByte ( & info , & length ) != ( unsigned char ) 'B' ) continue ; if ( ReadPropertyByte ( & info , & length ) != ( unsigned char ) 'I' ) continue ; if ( ReadPropertyByte ( & info , & length ) != ( unsigned char ) 'M' ) continue ; id = ( ssize_t ) ReadPropertyMSBShort ( & info , & length ) ; if ( id < ( ssize_t ) start ) continue ; if ( id > ( ssize_t ) stop ) continue ; if ( resource != ( char * ) NULL ) resource = DestroyString ( resource ) ; count = ( ssize_t ) ReadPropertyByte ( & info , & length ) ; if ( ( count != 0 ) && ( ( size_t ) count <= length ) ) { resource = ( char * ) NULL ; if ( ~ ( ( size_t ) count ) >= ( MagickPathExtent - 1 ) ) resource = ( char * ) AcquireQuantumMemory ( ( size_t ) count + MagickPathExtent , sizeof ( * resource ) ) ; if ( resource != ( char * ) NULL ) { for ( i = 0 ; i < ( ssize_t ) count ; i ++ ) resource [ i ] = ( char ) ReadPropertyByte ( & info , & length ) ; resource [ count ] = '\\0' ; } } if ( ( count & 0x01 ) == 0 ) ( void ) ReadPropertyByte ( & info , & length ) ; count = ( ssize_t ) ReadPropertyMSBLong ( & info , & length ) ; <S2SV_StartBug> if ( ( * name != '\\0' ) && ( * name != '#' ) ) <S2SV_EndBug> if ( ( resource == ( char * ) NULL ) || ( LocaleCompare ( name , resource ) != 0 ) ) { info += count ; length -= MagickMin ( count , ( ssize_t ) length ) ; continue ; } if ( ( * name == '#' ) && ( sub_number != 1 ) ) { sub_number -- ; info += count ; length -= MagickMin ( count , ( ssize_t ) length ) ; continue ; } attribute = ( char * ) NULL ; if ( ~ ( ( size_t ) count ) >= ( MagickPathExtent - 1 ) ) attribute = ( char * ) AcquireQuantumMemory ( ( size_t ) count + MagickPathExtent , sizeof ( * attribute ) ) ; if ( attribute != ( char * ) NULL ) { ( void ) CopyMagickMemory ( attribute , ( char * ) info , ( size_t ) count ) ; attribute [ count ] = '\\0' ; info += count ; length -= MagickMin ( count , ( ssize_t ) length ) ; if ( ( id <= 1999 ) || ( id >= 2999 ) ) ( void ) SetImageProperty ( ( Image * ) image , key , ( const char * ) attribute , exception ) ; else { char * path ; if ( LocaleCompare ( format , ""svg"" ) == 0 ) path = TraceSVGClippath ( ( unsigned char * ) attribute , ( size_t ) count , image -> columns , image -> rows ) ; else path = TracePSClippath ( ( unsigned char * ) attribute , ( size_t ) count ) ; ( void ) SetImageProperty ( ( Image * ) image , key , ( const char * ) path , exception ) ; path = DestroyString ( path ) ; } attribute = DestroyString ( attribute ) ; status = MagickTrue ; } } if ( resource != ( char * ) NULL ) resource = DestroyString ( resource ) ; return ( status ) ; }
","<S2SV_ModStart> if ( ( count < 0 ) || ( ( size_t ) count > length ) ) { length = 0 ; continue ; } if ( (
"
480,"CWE-190 static int jas_iccgetuint16 ( jas_stream_t * in , jas_iccuint16_t * val ) { <S2SV_StartBug> ulonglong tmp ; <S2SV_EndBug> if ( jas_iccgetuint ( in , 2 , & tmp ) ) return - 1 ; * val = tmp ; return 0 ; }
","<S2SV_ModStart> val ) { jas_ulonglong <S2SV_ModEnd> tmp ; if
"
481,"CWE-190 static int jpc_dec_process_siz ( jpc_dec_t * dec , jpc_ms_t * ms ) { jpc_siz_t * siz = & ms -> parms . siz ; int compno ; int tileno ; jpc_dec_tile_t * tile ; jpc_dec_tcomp_t * tcomp ; int htileno ; int vtileno ; jpc_dec_cmpt_t * cmpt ; <S2SV_StartBug> dec -> xstart = siz -> xoff ; <S2SV_EndBug> dec -> ystart = siz -> yoff ; dec -> xend = siz -> width ; dec -> yend = siz -> height ; dec -> tilewidth = siz -> tilewidth ; dec -> tileheight = siz -> tileheight ; dec -> tilexoff = siz -> tilexoff ; dec -> tileyoff = siz -> tileyoff ; dec -> numcomps = siz -> numcomps ; if ( ! ( dec -> cp = jpc_dec_cp_create ( dec -> numcomps ) ) ) { return - 1 ; } if ( ! ( dec -> cmpts = jas_alloc2 ( dec -> numcomps , sizeof ( jpc_dec_cmpt_t ) ) ) ) { return - 1 ; } for ( compno = 0 , cmpt = dec -> cmpts ; compno < dec -> numcomps ; ++ compno , ++ cmpt ) { cmpt -> prec = siz -> comps [ compno ] . prec ; cmpt -> sgnd = siz -> comps [ compno ] . sgnd ; cmpt -> hstep = siz -> comps [ compno ] . hsamp ; cmpt -> vstep = siz -> comps [ compno ] . vsamp ; cmpt -> width = JPC_CEILDIV ( dec -> xend , cmpt -> hstep ) - JPC_CEILDIV ( dec -> xstart , cmpt -> hstep ) ; cmpt -> height = JPC_CEILDIV ( dec -> yend , cmpt -> vstep ) - JPC_CEILDIV ( dec -> ystart , cmpt -> vstep ) ; cmpt -> hsubstep = 0 ; cmpt -> vsubstep = 0 ; } dec -> image = 0 ; dec -> numhtiles = JPC_CEILDIV ( dec -> xend - dec -> tilexoff , dec -> tilewidth ) ; dec -> numvtiles = JPC_CEILDIV ( dec -> yend - dec -> tileyoff , dec -> tileheight ) ; <S2SV_StartBug> dec -> numtiles = dec -> numhtiles * dec -> numvtiles ; <S2SV_EndBug> JAS_DBGLOG ( 10 , ( ""numtiles<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>numhtiles<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>numvtiles<S2SV_blank>=<S2SV_blank>%d;\\n"" , dec -> numtiles , dec -> numhtiles , dec -> numvtiles ) ) ; if ( ! ( dec -> tiles = jas_alloc2 ( dec -> numtiles , sizeof ( jpc_dec_tile_t ) ) ) ) { return - 1 ; } <S2SV_StartBug> for ( tileno = 0 , tile = dec -> tiles ; tileno < dec -> numtiles ; ++ tileno , <S2SV_EndBug> ++ tile ) { htileno = tileno % dec -> numhtiles ; vtileno = tileno / dec -> numhtiles ; tile -> realmode = 0 ; tile -> state = JPC_TILE_INIT ; tile -> xstart = JAS_MAX ( dec -> tilexoff + htileno * dec -> tilewidth , dec -> xstart ) ; tile -> ystart = JAS_MAX ( dec -> tileyoff + vtileno * dec -> tileheight , dec -> ystart ) ; tile -> xend = JAS_MIN ( dec -> tilexoff + ( htileno + 1 ) * dec -> tilewidth , dec -> xend ) ; tile -> yend = JAS_MIN ( dec -> tileyoff + ( vtileno + 1 ) * dec -> tileheight , dec -> yend ) ; tile -> numparts = 0 ; tile -> partno = 0 ; tile -> pkthdrstream = 0 ; tile -> pkthdrstreampos = 0 ; tile -> pptstab = 0 ; tile -> cp = 0 ; tile -> pi = 0 ; if ( ! ( tile -> tcomps = jas_alloc2 ( dec -> numcomps , sizeof ( jpc_dec_tcomp_t ) ) ) ) { return - 1 ; } for ( compno = 0 , cmpt = dec -> cmpts , tcomp = tile -> tcomps ; compno < dec -> numcomps ; ++ compno , ++ cmpt , ++ tcomp ) { tcomp -> rlvls = 0 ; tcomp -> numrlvls = 0 ; tcomp -> data = 0 ; tcomp -> xstart = JPC_CEILDIV ( tile -> xstart , cmpt -> hstep ) ; tcomp -> ystart = JPC_CEILDIV ( tile -> ystart , cmpt -> vstep ) ; tcomp -> xend = JPC_CEILDIV ( tile -> xend , cmpt -> hstep ) ; tcomp -> yend = JPC_CEILDIV ( tile -> yend , cmpt -> vstep ) ; tcomp -> tsfb = 0 ; } } dec -> pkthdrstreams = 0 ; dec -> state = JPC_MH ; return 0 ; }
","<S2SV_ModStart> * cmpt ; size_t size ; <S2SV_ModStart> tileheight ) ; if ( ! jas_safe_size_mul ( <S2SV_ModEnd> dec -> numhtiles <S2SV_ModStart> dec -> numhtiles , <S2SV_ModEnd> dec -> numvtiles <S2SV_ModStart> dec -> numvtiles , & size <S2SV_ModEnd> ) ) { <S2SV_ModStart> 1 ; } dec -> numtiles = size ; JAS_DBGLOG ( 10 , ( ""numtiles<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>numhtiles<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>numvtiles<S2SV_blank>=<S2SV_blank>%d;\\n"" , dec -> numtiles , dec -> numhtiles , dec -> numvtiles ) ) ; if ( ! ( dec -> tiles = jas_alloc2 ( dec -> numtiles , sizeof ( jpc_dec_tile_t ) ) ) ) { return - 1 ; }
"
482,"CWE-362 static void put_ucounts ( struct ucounts * ucounts ) { unsigned long flags ; <S2SV_StartBug> if ( atomic_dec_and_test ( & ucounts -> count ) ) { <S2SV_EndBug> spin_lock_irqsave ( & ucounts_lock , flags ) ; <S2SV_StartBug> hlist_del_init ( & ucounts -> node ) ; <S2SV_EndBug> spin_unlock_irqrestore ( & ucounts_lock , flags ) ; kfree ( ucounts ) ; } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> long flags ; <S2SV_ModEnd> spin_lock_irqsave ( & <S2SV_ModStart> flags ) ; ucounts -> count -= 1 ; if ( ! ucounts -> count ) <S2SV_ModStart> -> node ) ; else ucounts = NULL <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
"
483,"CWE-20 static krb5_error_code process_chpw_request ( krb5_context context , void * server_handle , char * realm , krb5_keytab keytab , const krb5_fulladdr * local_faddr , const krb5_fulladdr * remote_faddr , krb5_data * req , krb5_data * rep ) { krb5_error_code ret ; char * ptr ; unsigned int plen , vno ; krb5_data ap_req , ap_rep = empty_data ( ) ; krb5_data cipher = empty_data ( ) , clear = empty_data ( ) ; krb5_auth_context auth_context = NULL ; krb5_principal changepw = NULL ; krb5_principal client , target = NULL ; krb5_ticket * ticket = NULL ; krb5_replay_data replay ; krb5_error krberror ; int numresult ; char strresult [ 1024 ] ; char * clientstr = NULL , * targetstr = NULL ; const char * errmsg = NULL ; size_t clen ; char * cdots ; struct sockaddr_storage ss ; socklen_t salen ; char addrbuf [ 100 ] ; krb5_address * addr = remote_faddr -> address ; * rep = empty_data ( ) ; if ( req -> length < 4 ) { ret = KRB5KRB_AP_ERR_MODIFIED ; numresult = KRB5_KPASSWD_MALFORMED ; strlcpy ( strresult , ""Request<S2SV_blank>was<S2SV_blank>truncated"" , sizeof ( strresult ) ) ; <S2SV_StartBug> goto chpwfail ; <S2SV_EndBug> } ptr = req -> data ; plen = ( * ptr ++ & 0xff ) ; plen = ( plen << 8 ) | ( * ptr ++ & 0xff ) ; if ( plen != req -> length ) { ret = KRB5KRB_AP_ERR_MODIFIED ; numresult = KRB5_KPASSWD_MALFORMED ; strlcpy ( strresult , ""Request<S2SV_blank>length<S2SV_blank>was<S2SV_blank>inconsistent"" , sizeof ( strresult ) ) ; <S2SV_StartBug> goto chpwfail ; <S2SV_EndBug> } vno = ( * ptr ++ & 0xff ) ; vno = ( vno << 8 ) | ( * ptr ++ & 0xff ) ; if ( vno != 1 && vno != RFC3244_VERSION ) { ret = KRB5KDC_ERR_BAD_PVNO ; numresult = KRB5_KPASSWD_BAD_VERSION ; snprintf ( strresult , sizeof ( strresult ) , ""Request<S2SV_blank>contained<S2SV_blank>unknown<S2SV_blank>protocol<S2SV_blank>version<S2SV_blank>number<S2SV_blank>%d"" , vno ) ; <S2SV_StartBug> goto chpwfail ; <S2SV_EndBug> } ap_req . length = ( * ptr ++ & 0xff ) ; ap_req . length = ( ap_req . length << 8 ) | ( * ptr ++ & 0xff ) ; if ( ptr + ap_req . length >= req -> data + req -> length ) { ret = KRB5KRB_AP_ERR_MODIFIED ; numresult = KRB5_KPASSWD_MALFORMED ; strlcpy ( strresult , ""Request<S2SV_blank>was<S2SV_blank>truncated<S2SV_blank>in<S2SV_blank>AP-REQ"" , sizeof ( strresult ) ) ; <S2SV_StartBug> goto chpwfail ; <S2SV_EndBug> } ap_req . data = ptr ; ptr += ap_req . length ; ret = krb5_auth_con_init ( context , & auth_context ) ; if ( ret ) { numresult = KRB5_KPASSWD_HARDERROR ; strlcpy ( strresult , ""Failed<S2SV_blank>initializing<S2SV_blank>auth<S2SV_blank>context"" , sizeof ( strresult ) ) ; goto chpwfail ; } ret = krb5_auth_con_setflags ( context , auth_context , KRB5_AUTH_CONTEXT_DO_SEQUENCE ) ; if ( ret ) { numresult = KRB5_KPASSWD_HARDERROR ; strlcpy ( strresult , ""Failed<S2SV_blank>initializing<S2SV_blank>auth<S2SV_blank>context"" , sizeof ( strresult ) ) ; goto chpwfail ; } ret = krb5_build_principal ( context , & changepw , strlen ( realm ) , realm , ""kadmin"" , ""changepw"" , NULL ) ; if ( ret ) { numresult = KRB5_KPASSWD_HARDERROR ; strlcpy ( strresult , ""Failed<S2SV_blank>building<S2SV_blank>kadmin/changepw<S2SV_blank>principal"" , sizeof ( strresult ) ) ; goto chpwfail ; } ret = krb5_rd_req ( context , & auth_context , & ap_req , changepw , keytab , NULL , & ticket ) ; if ( ret ) { numresult = KRB5_KPASSWD_AUTHERROR ; strlcpy ( strresult , ""Failed<S2SV_blank>reading<S2SV_blank>application<S2SV_blank>request"" , sizeof ( strresult ) ) ; goto chpwfail ; } ret = krb5_mk_rep ( context , auth_context , & ap_rep ) ; if ( ret ) { numresult = KRB5_KPASSWD_AUTHERROR ; strlcpy ( strresult , ""Failed<S2SV_blank>replying<S2SV_blank>to<S2SV_blank>application<S2SV_blank>request"" , sizeof ( strresult ) ) ; goto chpwfail ; } cipher . length = ( req -> data + req -> length ) - ptr ; cipher . data = ptr ; ret = krb5_rd_priv ( context , auth_context , & cipher , & clear , & replay ) ; if ( ret ) { numresult = KRB5_KPASSWD_HARDERROR ; strlcpy ( strresult , ""Failed<S2SV_blank>decrypting<S2SV_blank>request"" , sizeof ( strresult ) ) ; goto chpwfail ; } client = ticket -> enc_part2 -> client ; if ( vno == RFC3244_VERSION ) { krb5_data * clear_data ; ret = decode_krb5_setpw_req ( & clear , & clear_data , & target ) ; if ( ret != 0 ) { numresult = KRB5_KPASSWD_MALFORMED ; strlcpy ( strresult , ""Failed<S2SV_blank>decoding<S2SV_blank>ChangePasswdData"" , sizeof ( strresult ) ) ; goto chpwfail ; } zapfree ( clear . data , clear . length ) ; clear = * clear_data ; free ( clear_data ) ; if ( target != NULL ) { ret = krb5_unparse_name ( context , target , & targetstr ) ; if ( ret != 0 ) { numresult = KRB5_KPASSWD_HARDERROR ; strlcpy ( strresult , ""Failed<S2SV_blank>unparsing<S2SV_blank>target<S2SV_blank>name<S2SV_blank>for<S2SV_blank>log"" , sizeof ( strresult ) ) ; goto chpwfail ; } } } ret = krb5_unparse_name ( context , client , & clientstr ) ; if ( ret ) { numresult = KRB5_KPASSWD_HARDERROR ; strlcpy ( strresult , ""Failed<S2SV_blank>unparsing<S2SV_blank>client<S2SV_blank>name<S2SV_blank>for<S2SV_blank>log"" , sizeof ( strresult ) ) ; goto chpwfail ; } if ( vno == 1 && ( ticket -> enc_part2 -> flags & TKT_FLG_INITIAL ) == 0 ) { numresult = KRB5_KPASSWD_INITIAL_FLAG_NEEDED ; strlcpy ( strresult , ""Ticket<S2SV_blank>must<S2SV_blank>be<S2SV_blank>derived<S2SV_blank>from<S2SV_blank>a<S2SV_blank>password"" , sizeof ( strresult ) ) ; goto chpwfail ; } ptr = k5memdup0 ( clear . data , clear . length , & ret ) ; ret = schpw_util_wrapper ( server_handle , client , target , ( ticket -> enc_part2 -> flags & TKT_FLG_INITIAL ) != 0 , ptr , NULL , strresult , sizeof ( strresult ) ) ; if ( ret ) errmsg = krb5_get_error_message ( context , ret ) ; zapfree ( clear . data , clear . length ) ; zapfree ( ptr , clear . length ) ; clear = empty_data ( ) ; clen = strlen ( clientstr ) ; trunc_name ( & clen , & cdots ) ; switch ( addr -> addrtype ) { case ADDRTYPE_INET : { struct sockaddr_in * sin = ss2sin ( & ss ) ; sin -> sin_family = AF_INET ; memcpy ( & sin -> sin_addr , addr -> contents , addr -> length ) ; sin -> sin_port = htons ( remote_faddr -> port ) ; salen = sizeof ( * sin ) ; break ; } case ADDRTYPE_INET6 : { struct sockaddr_in6 * sin6 = ss2sin6 ( & ss ) ; sin6 -> sin6_family = AF_INET6 ; memcpy ( & sin6 -> sin6_addr , addr -> contents , addr -> length ) ; sin6 -> sin6_port = htons ( remote_faddr -> port ) ; salen = sizeof ( * sin6 ) ; break ; } default : { struct sockaddr * sa = ss2sa ( & ss ) ; sa -> sa_family = AF_UNSPEC ; salen = sizeof ( * sa ) ; break ; } } if ( getnameinfo ( ss2sa ( & ss ) , salen , addrbuf , sizeof ( addrbuf ) , NULL , 0 , NI_NUMERICHOST | NI_NUMERICSERV ) != 0 ) strlcpy ( addrbuf , ""<unprintable>"" , sizeof ( addrbuf ) ) ; if ( vno == RFC3244_VERSION ) { size_t tlen ; char * tdots ; const char * targetp ; if ( target == NULL ) { tlen = clen ; tdots = cdots ; targetp = targetstr ; } else { tlen = strlen ( targetstr ) ; trunc_name ( & tlen , & tdots ) ; targetp = clientstr ; } krb5_klog_syslog ( LOG_NOTICE , _ ( ""setpw<S2SV_blank>request<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>by<S2SV_blank>%.*s%s<S2SV_blank>for<S2SV_blank>"" ""%.*s%s:<S2SV_blank>%s"" ) , addrbuf , ( int ) clen , clientstr , cdots , ( int ) tlen , targetp , tdots , errmsg ? errmsg : ""success"" ) ; } else { krb5_klog_syslog ( LOG_NOTICE , _ ( ""chpw<S2SV_blank>request<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>%.*s%s:<S2SV_blank>%s"" ) , addrbuf , ( int ) clen , clientstr , cdots , errmsg ? errmsg : ""success"" ) ; } switch ( ret ) { case KADM5_AUTH_CHANGEPW : numresult = KRB5_KPASSWD_ACCESSDENIED ; break ; case KADM5_PASS_Q_TOOSHORT : case KADM5_PASS_REUSE : case KADM5_PASS_Q_CLASS : case KADM5_PASS_Q_DICT : case KADM5_PASS_Q_GENERIC : case KADM5_PASS_TOOSOON : numresult = KRB5_KPASSWD_SOFTERROR ; break ; case 0 : numresult = KRB5_KPASSWD_SUCCESS ; strlcpy ( strresult , """" , sizeof ( strresult ) ) ; break ; default : numresult = KRB5_KPASSWD_HARDERROR ; break ; } chpwfail : clear . length = 2 + strlen ( strresult ) ; clear . data = ( char * ) malloc ( clear . length ) ; ptr = clear . data ; * ptr ++ = ( numresult >> 8 ) & 0xff ; * ptr ++ = numresult & 0xff ; memcpy ( ptr , strresult , strlen ( strresult ) ) ; cipher = empty_data ( ) ; if ( ap_rep . length ) { ret = krb5_auth_con_setaddrs ( context , auth_context , local_faddr -> address , NULL ) ; if ( ret ) { numresult = KRB5_KPASSWD_HARDERROR ; strlcpy ( strresult , ""Failed<S2SV_blank>storing<S2SV_blank>client<S2SV_blank>and<S2SV_blank>server<S2SV_blank>internet<S2SV_blank>addresses"" , sizeof ( strresult ) ) ; } else { ret = krb5_mk_priv ( context , auth_context , & clear , & cipher , & replay ) ; if ( ret ) { numresult = KRB5_KPASSWD_HARDERROR ; strlcpy ( strresult , ""Failed<S2SV_blank>encrypting<S2SV_blank>reply"" , sizeof ( strresult ) ) ; } } } if ( cipher . length == 0 ) { if ( ap_rep . length ) { free ( ap_rep . data ) ; ap_rep = empty_data ( ) ; } krberror . ctime = 0 ; krberror . cusec = 0 ; krberror . susec = 0 ; ret = krb5_timeofday ( context , & krberror . stime ) ; if ( ret ) goto bailout ; krberror . error = ret ; krberror . error -= ERROR_TABLE_BASE_krb5 ; if ( krberror . error < 0 || krberror . error > 128 ) krberror . error = KRB_ERR_GENERIC ; krberror . client = NULL ; ret = krb5_build_principal ( context , & krberror . server , strlen ( realm ) , realm , ""kadmin"" , ""changepw"" , NULL ) ; if ( ret ) goto bailout ; krberror . text . length = 0 ; krberror . e_data = clear ; ret = krb5_mk_error ( context , & krberror , & cipher ) ; krb5_free_principal ( context , krberror . server ) ; if ( ret ) goto bailout ; } ret = alloc_data ( rep , 6 + ap_rep . length + cipher . length ) ; if ( ret ) goto bailout ; ptr = rep -> data ; * ptr ++ = ( rep -> length >> 8 ) & 0xff ; * ptr ++ = rep -> length & 0xff ; * ptr ++ = 0 ; * ptr ++ = 1 ; * ptr ++ = ( ap_rep . length >> 8 ) & 0xff ; * ptr ++ = ap_rep . length & 0xff ; if ( ap_rep . length ) { memcpy ( ptr , ap_rep . data , ap_rep . length ) ; ptr += ap_rep . length ; } memcpy ( ptr , cipher . data , cipher . length ) ; bailout : krb5_auth_con_free ( context , auth_context ) ; krb5_free_principal ( context , changepw ) ; krb5_free_ticket ( context , ticket ) ; free ( ap_rep . data ) ; free ( clear . data ) ; free ( cipher . data ) ; krb5_free_principal ( context , target ) ; krb5_free_unparsed_name ( context , targetstr ) ; krb5_free_unparsed_name ( context , clientstr ) ; krb5_free_error_message ( context , errmsg ) ; return ret ; }
","<S2SV_ModStart> ) ; goto bailout <S2SV_ModEnd> ; } ptr <S2SV_ModStart> ) ; goto bailout <S2SV_ModEnd> ; } vno <S2SV_ModStart> ) ; goto bailout <S2SV_ModEnd> ; } ap_req <S2SV_ModStart> ) ; goto bailout <S2SV_ModEnd> ; } ap_req
"
484,"CWE-59 int pam_sm_authenticate ( pam_handle_t * pamh , int flags , int argc , const char * * argv ) { struct passwd * pw = NULL , pw_s ; const char * user = NULL ; cfg_t cfg_st ; cfg_t * cfg = & cfg_st ; char buffer [ BUFSIZE ] ; char * buf = NULL ; char * authfile_dir ; size_t authfile_dir_len ; int pgu_ret , gpn_ret ; int retval = PAM_IGNORE ; device_t * devices = NULL ; unsigned n_devices = 0 ; <S2SV_StartBug> int openasuser ; <S2SV_EndBug> int should_free_origin = 0 ; int should_free_appid = 0 ; int should_free_auth_file = 0 ; <S2SV_StartBug> int should_free_authpending_file = 0 ; <S2SV_EndBug> parse_cfg ( flags , argc , argv , cfg ) ; if ( ! cfg -> origin ) { strcpy ( buffer , DEFAULT_ORIGIN_PREFIX ) ; if ( gethostname ( buffer + strlen ( DEFAULT_ORIGIN_PREFIX ) , BUFSIZE - strlen ( DEFAULT_ORIGIN_PREFIX ) ) == - 1 ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>host<S2SV_blank>name"" ) ; goto done ; } DBG ( ""Origin<S2SV_blank>not<S2SV_blank>specified,<S2SV_blank>using<S2SV_blank>\\""%s\\"""" , buffer ) ; cfg -> origin = strdup ( buffer ) ; if ( ! cfg -> origin ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto done ; } else { should_free_origin = 1 ; } } if ( ! cfg -> appid ) { DBG ( ""Appid<S2SV_blank>not<S2SV_blank>specified,<S2SV_blank>using<S2SV_blank>the<S2SV_blank>same<S2SV_blank>value<S2SV_blank>of<S2SV_blank>origin<S2SV_blank>(%s)"" , cfg -> origin ) ; cfg -> appid = strdup ( cfg -> origin ) ; if ( ! cfg -> appid ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory"" ) goto done ; } else { should_free_appid = 1 ; } } if ( cfg -> max_devs == 0 ) { DBG ( ""Maximum<S2SV_blank>devices<S2SV_blank>number<S2SV_blank>not<S2SV_blank>set.<S2SV_blank>Using<S2SV_blank>default<S2SV_blank>(%d)"" , MAX_DEVS ) ; cfg -> max_devs = MAX_DEVS ; } devices = malloc ( sizeof ( device_t ) * cfg -> max_devs ) ; if ( ! devices ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory"" ) ; retval = PAM_IGNORE ; goto done ; } pgu_ret = pam_get_user ( pamh , & user , NULL ) ; if ( pgu_ret != PAM_SUCCESS || user == NULL ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>access<S2SV_blank>user<S2SV_blank>%s"" , user ) ; retval = PAM_CONV_ERR ; goto done ; } DBG ( ""Requesting<S2SV_blank>authentication<S2SV_blank>for<S2SV_blank>user<S2SV_blank>%s"" , user ) ; gpn_ret = getpwnam_r ( user , & pw_s , buffer , sizeof ( buffer ) , & pw ) ; if ( gpn_ret != 0 || pw == NULL || pw -> pw_dir == NULL || pw -> pw_dir [ 0 ] != '/' ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>retrieve<S2SV_blank>credentials<S2SV_blank>for<S2SV_blank>user<S2SV_blank>%s,<S2SV_blank>(%s)"" , user , strerror ( errno ) ) ; retval = PAM_USER_UNKNOWN ; goto done ; } DBG ( ""Found<S2SV_blank>user<S2SV_blank>%s"" , user ) ; DBG ( ""Home<S2SV_blank>directory<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>%s"" , user , pw -> pw_dir ) ; if ( ! cfg -> auth_file ) { buf = NULL ; authfile_dir = secure_getenv ( DEFAULT_AUTHFILE_DIR_VAR ) ; if ( ! authfile_dir ) { DBG ( ""Variable<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>set.<S2SV_blank>Using<S2SV_blank>default<S2SV_blank>value<S2SV_blank>($HOME/.config/)"" , DEFAULT_AUTHFILE_DIR_VAR ) ; authfile_dir_len = strlen ( pw -> pw_dir ) + strlen ( ""/.config"" ) + strlen ( DEFAULT_AUTHFILE ) + 1 ; buf = malloc ( sizeof ( char ) * ( authfile_dir_len ) ) ; if ( ! buf ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory"" ) ; retval = PAM_IGNORE ; goto done ; } <S2SV_StartBug> snprintf ( buf , authfile_dir_len , <S2SV_EndBug> ""%s/.config%s"" , pw -> pw_dir , DEFAULT_AUTHFILE ) ; } else { DBG ( ""Variable<S2SV_blank>%s<S2SV_blank>set<S2SV_blank>to<S2SV_blank>%s"" , DEFAULT_AUTHFILE_DIR_VAR , authfile_dir ) ; authfile_dir_len = strlen ( authfile_dir ) + strlen ( DEFAULT_AUTHFILE ) + 1 ; buf = malloc ( sizeof ( char ) * ( authfile_dir_len ) ) ; if ( ! buf ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory"" ) ; retval = PAM_IGNORE ; goto done ; } snprintf ( buf , authfile_dir_len , ""%s%s"" , authfile_dir , DEFAULT_AUTHFILE ) ; <S2SV_StartBug> } <S2SV_EndBug> DBG ( ""Using<S2SV_blank>default<S2SV_blank>authentication<S2SV_blank>file<S2SV_blank>%s"" , buf ) ; <S2SV_StartBug> cfg -> auth_file = buf ; <S2SV_EndBug> should_free_auth_file = 1 ; buf = NULL ; } else { DBG ( ""Using<S2SV_blank>authentication<S2SV_blank>file<S2SV_blank>%s"" , cfg -> auth_file ) ; } <S2SV_StartBug> openasuser = geteuid ( ) == 0 && cfg -> openasuser ; <S2SV_EndBug> <S2SV_StartBug> if ( openasuser ) { <S2SV_EndBug> <S2SV_StartBug> if ( seteuid ( pw_s . pw_uid ) ) { <S2SV_EndBug> <S2SV_StartBug> DBG ( ""Unable<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>user<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>%i"" , pw_s . pw_uid ) ; <S2SV_EndBug> retval = PAM_IGNORE ; goto done ; } <S2SV_StartBug> DBG ( ""Switched<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>%i"" , pw_s . pw_uid ) ; <S2SV_EndBug> } retval = get_devices_from_authfile ( cfg -> auth_file , user , cfg -> max_devs , cfg -> debug , cfg -> debug_file , devices , & n_devices ) ; if ( openasuser ) { <S2SV_StartBug> if ( seteuid ( 0 ) ) { <S2SV_EndBug> DBG ( ""Unable<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>back<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>0"" ) ; retval = PAM_IGNORE ; goto done ; } <S2SV_StartBug> DBG ( ""Switched<S2SV_blank>back<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>0"" ) ; <S2SV_EndBug> } if ( retval != 1 ) { n_devices = 0 ; } if ( n_devices == 0 ) { if ( cfg -> nouserok ) { DBG ( ""Found<S2SV_blank>no<S2SV_blank>devices<S2SV_blank>but<S2SV_blank>nouserok<S2SV_blank>specified.<S2SV_blank>Skipping<S2SV_blank>authentication"" ) ; retval = PAM_SUCCESS ; goto done ; } else if ( retval != 1 ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>devices<S2SV_blank>from<S2SV_blank>file<S2SV_blank>%s"" , cfg -> auth_file ) ; retval = PAM_AUTHINFO_UNAVAIL ; goto done ; } else { DBG ( ""Found<S2SV_blank>no<S2SV_blank>devices.<S2SV_blank>Aborting."" ) ; retval = PAM_AUTHINFO_UNAVAIL ; goto done ; } } if ( ! cfg -> authpending_file ) { int actual_size = snprintf ( buffer , BUFSIZE , DEFAULT_AUTHPENDING_FILE_PATH , getuid ( ) ) ; if ( actual_size >= 0 && actual_size < BUFSIZE ) { cfg -> authpending_file = strdup ( buffer ) ; } if ( ! cfg -> authpending_file ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>the<S2SV_blank>authpending_file,<S2SV_blank>touch<S2SV_blank>request<S2SV_blank>notifications<S2SV_blank>will<S2SV_blank>not<S2SV_blank>be<S2SV_blank>emitted"" ) ; } else { should_free_authpending_file = 1 ; } } else { if ( strlen ( cfg -> authpending_file ) == 0 ) { DBG ( ""authpending_file<S2SV_blank>is<S2SV_blank>set<S2SV_blank>to<S2SV_blank>an<S2SV_blank>empty<S2SV_blank>value,<S2SV_blank>touch<S2SV_blank>request<S2SV_blank>notifications<S2SV_blank>will<S2SV_blank>be<S2SV_blank>disabled"" ) ; cfg -> authpending_file = NULL ; } } int authpending_file_descriptor = - 1 ; if ( cfg -> authpending_file ) { DBG ( ""Using<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>for<S2SV_blank>emitting<S2SV_blank>touch<S2SV_blank>request<S2SV_blank>notifications"" , cfg -> authpending_file ) ; authpending_file_descriptor = open ( cfg -> authpending_file , O_RDONLY | O_CREAT | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY , 0664 ) ; if ( authpending_file_descriptor < 0 ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>emit<S2SV_blank>\'authentication<S2SV_blank>started\'<S2SV_blank>notification<S2SV_blank>by<S2SV_blank>opening<S2SV_blank>the<S2SV_blank>file<S2SV_blank>\'%s\',<S2SV_blank>(%s)"" , cfg -> authpending_file , strerror ( errno ) ) ; } } if ( cfg -> manual == 0 ) { if ( cfg -> interactive ) { converse ( pamh , PAM_PROMPT_ECHO_ON , cfg -> prompt != NULL ? cfg -> prompt : DEFAULT_PROMPT ) ; } retval = do_authentication ( cfg , devices , n_devices , pamh ) ; } else { retval = do_manual_authentication ( cfg , devices , n_devices , pamh ) ; } if ( authpending_file_descriptor >= 0 ) { if ( close ( authpending_file_descriptor ) < 0 ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>emit<S2SV_blank>\'authentication<S2SV_blank>stopped\'<S2SV_blank>notification<S2SV_blank>by<S2SV_blank>closing<S2SV_blank>the<S2SV_blank>file<S2SV_blank>\'%s\',<S2SV_blank>(%s)"" , cfg -> authpending_file , strerror ( errno ) ) ; } } if ( retval != 1 ) { DBG ( ""do_authentication<S2SV_blank>returned<S2SV_blank>%d"" , retval ) ; retval = PAM_AUTH_ERR ; goto done ; } retval = PAM_SUCCESS ; done : free_devices ( devices , n_devices ) ; if ( buf ) { free ( buf ) ; buf = NULL ; } if ( should_free_origin ) { free ( ( char * ) cfg -> origin ) ; cfg -> origin = NULL ; } if ( should_free_appid ) { free ( ( char * ) cfg -> appid ) ; cfg -> appid = NULL ; } if ( should_free_auth_file ) { free ( ( char * ) cfg -> auth_file ) ; cfg -> auth_file = NULL ; } if ( should_free_authpending_file ) { free ( ( char * ) cfg -> authpending_file ) ; cfg -> authpending_file = NULL ; } if ( cfg -> alwaysok && retval != PAM_SUCCESS ) { DBG ( ""alwaysok<S2SV_blank>needed<S2SV_blank>(otherwise<S2SV_blank>return<S2SV_blank>with<S2SV_blank>%d)"" , retval ) ; retval = PAM_SUCCESS ; } DBG ( ""done.<S2SV_blank>[%s]"" , pam_strerror ( pamh , retval ) ) ; if ( cfg -> is_custom_debug_file ) { fclose ( cfg -> debug_file ) ; } return retval ; }
","<S2SV_ModStart> ; int openasuser = 0 <S2SV_ModStart> should_free_authpending_file = 0 ; PAM_MODUTIL_DEF_PRIVS ( privs ) <S2SV_ModStart> done ; } openasuser = geteuid ( ) == 0 ? 1 : 0 ; <S2SV_ModStart> DEFAULT_AUTHFILE ) ; if ( ! openasuser ) { DBG ( ""WARNING:<S2SV_blank>not<S2SV_blank>dropping<S2SV_blank>privileges<S2SV_blank>when<S2SV_blank>reading<S2SV_blank>%s,<S2SV_blank>please<S2SV_blank>"" ""consider<S2SV_blank>setting<S2SV_blank>openasuser=1<S2SV_blank>in<S2SV_blank>the<S2SV_blank>module<S2SV_blank>configuration"" <S2SV_ModEnd> , buf ) <S2SV_ModStart> buf ) ; } } DBG ( ""Using<S2SV_blank>authentication<S2SV_blank>file<S2SV_blank>%s"" , buf ) ; <S2SV_ModStart> ) ; } if ( ! openasuser ) { openasuser <S2SV_ModEnd> = geteuid ( <S2SV_ModStart> -> openasuser ; } <S2SV_ModStart> openasuser ) { DBG ( ""Dropping<S2SV_blank>privileges"" ) ; if ( pam_modutil_drop_priv ( pamh , & privs , pw <S2SV_ModEnd> ) ) { <S2SV_ModStart> ( ""Unable<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>user<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>%i"" , pw -> <S2SV_ModEnd> pw_uid ) ; <S2SV_ModStart> ( ""Switched<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>%i"" , pw -> <S2SV_ModEnd> pw_uid ) ; <S2SV_ModStart> { if ( pam_modutil_regain_priv ( pamh , & privs ) ) { DBG ( ""could<S2SV_blank>not<S2SV_blank>restore<S2SV_blank>privileges"" <S2SV_ModEnd> ) ; retval <S2SV_ModStart> } DBG ( ""Restored<S2SV_blank>privileges"" <S2SV_ModEnd> ) ; }
"
485,"CWE-20 static int netlink_recvmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct scm_cookie scm ; struct sock * sk = sock -> sk ; struct netlink_sock * nlk = nlk_sk ( sk ) ; int noblock = flags & MSG_DONTWAIT ; size_t copied ; struct sk_buff * skb , * data_skb ; int err , ret ; if ( flags & MSG_OOB ) return - EOPNOTSUPP ; copied = 0 ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( skb == NULL ) goto out ; data_skb = skb ; # ifdef CONFIG_COMPAT_NETLINK_MESSAGES if ( unlikely ( skb_shinfo ( skb ) -> frag_list ) ) { if ( flags & MSG_CMSG_COMPAT ) data_skb = skb_shinfo ( skb ) -> frag_list ; } # endif <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> copied = data_skb -> len ; if ( len < copied ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } skb_reset_transport_header ( data_skb ) ; err = skb_copy_datagram_iovec ( data_skb , 0 , msg -> msg_iov , copied ) ; if ( msg -> msg_name ) { struct sockaddr_nl * addr = ( struct sockaddr_nl * ) msg -> msg_name ; addr -> nl_family = AF_NETLINK ; addr -> nl_pad = 0 ; addr -> nl_pid = NETLINK_CB ( skb ) . portid ; addr -> nl_groups = netlink_group_mask ( NETLINK_CB ( skb ) . dst_group ) ; msg -> msg_namelen = sizeof ( * addr ) ; } if ( nlk -> flags & NETLINK_RECV_PKTINFO ) netlink_cmsg_recv_pktinfo ( msg , skb ) ; if ( NULL == siocb -> scm ) { memset ( & scm , 0 , sizeof ( scm ) ) ; siocb -> scm = & scm ; } siocb -> scm -> creds = * NETLINK_CREDS ( skb ) ; if ( flags & MSG_TRUNC ) copied = data_skb -> len ; skb_free_datagram ( sk , skb ) ; if ( nlk -> cb_running && atomic_read ( & sk -> sk_rmem_alloc ) <= sk -> sk_rcvbuf / 2 ) { ret = netlink_dump ( sk ) ; if ( ret ) { sk -> sk_err = ret ; sk -> sk_error_report ( sk ) ; } } scm_recv ( sock , msg , siocb -> scm , flags ) ; out : netlink_rcv_wake ( sk ) ; return err ? : copied ; }
","<S2SV_ModStart> } # endif <S2SV_ModEnd> copied = data_skb
"
486,"CWE-601 int am_check_url ( request_rec * r , const char * url ) { const char * i ; for ( i = url ; * i ; i ++ ) { if ( * i >= 0 && * i < '<S2SV_blank>' ) { AM_LOG_RERROR ( APLOG_MARK , APLOG_ERR , HTTP_BAD_REQUEST , r , ""Control<S2SV_blank>character<S2SV_blank>detected<S2SV_blank>in<S2SV_blank>URL."" ) ; return HTTP_BAD_REQUEST ; } <S2SV_StartBug> } <S2SV_EndBug> return OK ; }
","<S2SV_ModStart> HTTP_BAD_REQUEST ; } if ( * i == '\\\\' ) { AM_LOG_RERROR ( APLOG_MARK , APLOG_ERR , HTTP_BAD_REQUEST , r , ""Backslash<S2SV_blank>character<S2SV_blank>detected<S2SV_blank>in<S2SV_blank>URL."" ) ; return HTTP_BAD_REQUEST ; }
"
487,"CWE-200 static int dgram_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { size_t copied = 0 ; int err = - EOPNOTSUPP ; struct sk_buff * skb ; struct sockaddr_ieee802154 * saddr ; saddr = ( struct sockaddr_ieee802154 * ) msg -> msg_name ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) goto out ; copied = skb -> len ; if ( len < copied ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto done ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( saddr ) { saddr -> family = AF_IEEE802154 ; saddr -> addr = mac_cb ( skb ) -> sa ; <S2SV_StartBug> } <S2SV_EndBug> if ( addr_len ) * addr_len = sizeof ( * saddr ) ; if ( flags & MSG_TRUNC ) copied = skb -> len ; done : skb_free_datagram ( sk , skb ) ; out : if ( err ) return err ; return copied ; }
","<S2SV_ModStart> -> sa ; * addr_len = sizeof ( * saddr ) ; } <S2SV_ModEnd> if ( flags
"
488,"CWE-189 tsize_t t2p_readwrite_pdf_image_tile ( T2P * t2p , TIFF * input , TIFF * output , ttile_t tile ) { uint16 edge = 0 ; tsize_t written = 0 ; unsigned char * buffer = NULL ; tsize_t bufferoffset = 0 ; unsigned char * samplebuffer = NULL ; tsize_t samplebufferoffset = 0 ; tsize_t read = 0 ; uint16 i = 0 ; ttile_t tilecount = 0 ; ttile_t septilecount = 0 ; tsize_t septilesize = 0 ; # ifdef JPEG_SUPPORT unsigned char * jpt ; float * xfloatp ; uint32 xuint32 = 0 ; # endif if ( t2p -> t2p_error != T2P_ERR_OK ) return ( 0 ) ; edge |= t2p_tile_is_right_edge ( t2p -> tiff_tiles [ t2p -> pdf_page ] , tile ) ; edge |= t2p_tile_is_bottom_edge ( t2p -> tiff_tiles [ t2p -> pdf_page ] , tile ) ; if ( ( t2p -> pdf_transcode == T2P_TRANSCODE_RAW ) && ( ( edge == 0 ) # if defined ( JPEG_SUPPORT ) || defined ( OJPEG_SUPPORT ) || ( t2p -> pdf_compression == T2P_COMPRESS_JPEG ) # endif ) ) { # ifdef CCITT_SUPPORT if ( t2p -> pdf_compression == T2P_COMPRESS_G4 ) { buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>"" ""for<S2SV_blank>t2p_readwrite_pdf_image_tile,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } TIFFReadRawTile ( input , tile , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; if ( t2p -> tiff_fillorder == FILLORDER_LSB2MSB ) { TIFFReverseBits ( buffer , t2p -> tiff_datasize ) ; } t2pWriteFile ( output , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; _TIFFfree ( buffer ) ; return ( t2p -> tiff_datasize ) ; } # endif # ifdef ZIP_SUPPORT if ( t2p -> pdf_compression == T2P_COMPRESS_ZIP ) { buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>"" ""for<S2SV_blank>t2p_readwrite_pdf_image_tile,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } TIFFReadRawTile ( input , tile , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; if ( t2p -> tiff_fillorder == FILLORDER_LSB2MSB ) { TIFFReverseBits ( buffer , t2p -> tiff_datasize ) ; } t2pWriteFile ( output , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; _TIFFfree ( buffer ) ; return ( t2p -> tiff_datasize ) ; } # endif # ifdef OJPEG_SUPPORT if ( t2p -> tiff_compression == COMPRESSION_OJPEG ) { if ( ! t2p -> pdf_ojpegdata ) { TIFFError ( TIFF2PDF_MODULE , ""No<S2SV_blank>support<S2SV_blank>for<S2SV_blank>OJPEG<S2SV_blank>image<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>"" ""bad<S2SV_blank>tables"" , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>"" ""for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } _TIFFmemcpy ( buffer , t2p -> pdf_ojpegdata , t2p -> pdf_ojpegdatalength ) ; if ( edge != 0 ) { if ( t2p_tile_is_bottom_edge ( t2p -> tiff_tiles [ t2p -> pdf_page ] , tile ) ) { buffer [ 7 ] = ( t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_edgetilelength >> 8 ) & 0xff ; buffer [ 8 ] = ( t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_edgetilelength ) & 0xff ; } if ( t2p_tile_is_right_edge ( t2p -> tiff_tiles [ t2p -> pdf_page ] , tile ) ) { buffer [ 9 ] = ( t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_edgetilewidth >> 8 ) & 0xff ; buffer [ 10 ] = ( t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_edgetilewidth ) & 0xff ; } } bufferoffset = t2p -> pdf_ojpegdatalength ; bufferoffset += TIFFReadRawTile ( input , tile , ( tdata_t ) & ( ( ( unsigned char * ) buffer ) [ bufferoffset ] ) , - 1 ) ; ( ( unsigned char * ) buffer ) [ bufferoffset ++ ] = 0xff ; ( ( unsigned char * ) buffer ) [ bufferoffset ++ ] = 0xd9 ; t2pWriteFile ( output , ( tdata_t ) buffer , bufferoffset ) ; _TIFFfree ( buffer ) ; return ( bufferoffset ) ; } # endif # ifdef JPEG_SUPPORT if ( t2p -> tiff_compression == COMPRESSION_JPEG ) { unsigned char table_end [ 2 ] ; uint32 count = 0 ; buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>"" TIFF_SIZE_FORMAT ""<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>"" ""for<S2SV_blank>t2p_readwrite_pdf_image_tile,<S2SV_blank>%s"" , ( TIFF_SIZE_T ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } if ( TIFFGetField ( input , TIFFTAG_JPEGTABLES , & count , & jpt ) != 0 ) { <S2SV_StartBug> if ( count >= 4 ) { <S2SV_EndBug> int retTIFFReadRawTile ; _TIFFmemcpy ( buffer , jpt , count - 2 ) ; bufferoffset += count - 2 ; table_end [ 0 ] = buffer [ bufferoffset - 2 ] ; table_end [ 1 ] = buffer [ bufferoffset - 1 ] ; xuint32 = bufferoffset ; bufferoffset -= 2 ; retTIFFReadRawTile = TIFFReadRawTile ( input , tile , ( tdata_t ) & ( ( ( unsigned char * ) buffer ) [ bufferoffset ] ) , - 1 ) ; if ( retTIFFReadRawTile < 0 ) { _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } bufferoffset += retTIFFReadRawTile ; buffer [ xuint32 - 2 ] = table_end [ 0 ] ; buffer [ xuint32 - 1 ] = table_end [ 1 ] ; } } t2pWriteFile ( output , ( tdata_t ) buffer , bufferoffset ) ; _TIFFfree ( buffer ) ; return ( bufferoffset ) ; } # endif ( void ) 0 ; } if ( t2p -> pdf_sample == T2P_SAMPLE_NOTHING ) { buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>"" ""t2p_readwrite_pdf_image_tile,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } read = TIFFReadEncodedTile ( input , tile , ( tdata_t ) & buffer [ bufferoffset ] , t2p -> tiff_datasize ) ; if ( read == - 1 ) { TIFFError ( TIFF2PDF_MODULE , ""Error<S2SV_blank>on<S2SV_blank>decoding<S2SV_blank>tile<S2SV_blank>%u<S2SV_blank>of<S2SV_blank>%s"" , tile , TIFFFileName ( input ) ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } } else { if ( t2p -> pdf_sample == T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG ) { septilesize = TIFFTileSize ( input ) ; septilecount = TIFFNumberOfTiles ( input ) ; tilecount = septilecount / t2p -> tiff_samplesperpixel ; buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>"" ""for<S2SV_blank>t2p_readwrite_pdf_image_tile,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } samplebuffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( samplebuffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>"" ""for<S2SV_blank>t2p_readwrite_pdf_image_tile,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } samplebufferoffset = 0 ; for ( i = 0 ; i < t2p -> tiff_samplesperpixel ; i ++ ) { read = TIFFReadEncodedTile ( input , tile + i * tilecount , ( tdata_t ) & ( samplebuffer [ samplebufferoffset ] ) , septilesize ) ; if ( read == - 1 ) { TIFFError ( TIFF2PDF_MODULE , ""Error<S2SV_blank>on<S2SV_blank>decoding<S2SV_blank>tile<S2SV_blank>%u<S2SV_blank>of<S2SV_blank>%s"" , tile + i * tilecount , TIFFFileName ( input ) ) ; _TIFFfree ( samplebuffer ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } samplebufferoffset += read ; } t2p_sample_planar_separate_to_contig ( t2p , & ( buffer [ bufferoffset ] ) , samplebuffer , samplebufferoffset ) ; bufferoffset += samplebufferoffset ; _TIFFfree ( samplebuffer ) ; } if ( buffer == NULL ) { buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>"" ""for<S2SV_blank>t2p_readwrite_pdf_image_tile,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } read = TIFFReadEncodedTile ( input , tile , ( tdata_t ) & buffer [ bufferoffset ] , t2p -> tiff_datasize ) ; if ( read == - 1 ) { TIFFError ( TIFF2PDF_MODULE , ""Error<S2SV_blank>on<S2SV_blank>decoding<S2SV_blank>tile<S2SV_blank>%u<S2SV_blank>of<S2SV_blank>%s"" , tile , TIFFFileName ( input ) ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } } if ( t2p -> pdf_sample & T2P_SAMPLE_RGBA_TO_RGB ) { t2p -> tiff_datasize = t2p_sample_rgba_to_rgb ( ( tdata_t ) buffer , t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_tilewidth * t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_tilelength ) ; } if ( t2p -> pdf_sample & T2P_SAMPLE_RGBAA_TO_RGB ) { t2p -> tiff_datasize = t2p_sample_rgbaa_to_rgb ( ( tdata_t ) buffer , t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_tilewidth * t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_tilelength ) ; } if ( t2p -> pdf_sample & T2P_SAMPLE_YCBCR_TO_RGB ) { TIFFError ( TIFF2PDF_MODULE , ""No<S2SV_blank>support<S2SV_blank>for<S2SV_blank>YCbCr<S2SV_blank>to<S2SV_blank>RGB<S2SV_blank>in<S2SV_blank>tile<S2SV_blank>for<S2SV_blank>%s"" , TIFFFileName ( input ) ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } if ( t2p -> pdf_sample & T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED ) { t2p -> tiff_datasize = t2p_sample_lab_signed_to_unsigned ( ( tdata_t ) buffer , t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_tilewidth * t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_tilelength ) ; } } if ( t2p_tile_is_right_edge ( t2p -> tiff_tiles [ t2p -> pdf_page ] , tile ) != 0 ) { t2p_tile_collapse_left ( buffer , TIFFTileRowSize ( input ) , t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_tilewidth , t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_edgetilewidth , t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_tilelength ) ; } t2p_disable ( output ) ; TIFFSetField ( output , TIFFTAG_PHOTOMETRIC , t2p -> tiff_photometric ) ; TIFFSetField ( output , TIFFTAG_BITSPERSAMPLE , t2p -> tiff_bitspersample ) ; TIFFSetField ( output , TIFFTAG_SAMPLESPERPIXEL , t2p -> tiff_samplesperpixel ) ; if ( t2p_tile_is_right_edge ( t2p -> tiff_tiles [ t2p -> pdf_page ] , tile ) == 0 ) { TIFFSetField ( output , TIFFTAG_IMAGEWIDTH , t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_tilewidth ) ; } else { TIFFSetField ( output , TIFFTAG_IMAGEWIDTH , t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_edgetilewidth ) ; } if ( t2p_tile_is_bottom_edge ( t2p -> tiff_tiles [ t2p -> pdf_page ] , tile ) == 0 ) { TIFFSetField ( output , TIFFTAG_IMAGELENGTH , t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_tilelength ) ; TIFFSetField ( output , TIFFTAG_ROWSPERSTRIP , t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_tilelength ) ; } else { TIFFSetField ( output , TIFFTAG_IMAGELENGTH , t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_edgetilelength ) ; TIFFSetField ( output , TIFFTAG_ROWSPERSTRIP , t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_edgetilelength ) ; } TIFFSetField ( output , TIFFTAG_PLANARCONFIG , PLANARCONFIG_CONTIG ) ; TIFFSetField ( output , TIFFTAG_FILLORDER , FILLORDER_MSB2LSB ) ; switch ( t2p -> pdf_compression ) { case T2P_COMPRESS_NONE : TIFFSetField ( output , TIFFTAG_COMPRESSION , COMPRESSION_NONE ) ; break ; # ifdef CCITT_SUPPORT case T2P_COMPRESS_G4 : TIFFSetField ( output , TIFFTAG_COMPRESSION , COMPRESSION_CCITTFAX4 ) ; break ; # endif # ifdef JPEG_SUPPORT case T2P_COMPRESS_JPEG : if ( t2p -> tiff_photometric == PHOTOMETRIC_YCBCR ) { uint16 hor = 0 , ver = 0 ; if ( TIFFGetField ( input , TIFFTAG_YCBCRSUBSAMPLING , & hor , & ver ) != 0 ) { if ( hor != 0 && ver != 0 ) { TIFFSetField ( output , TIFFTAG_YCBCRSUBSAMPLING , hor , ver ) ; } } if ( TIFFGetField ( input , TIFFTAG_REFERENCEBLACKWHITE , & xfloatp ) != 0 ) { TIFFSetField ( output , TIFFTAG_REFERENCEBLACKWHITE , xfloatp ) ; } } TIFFSetField ( output , TIFFTAG_COMPRESSION , COMPRESSION_JPEG ) ; TIFFSetField ( output , TIFFTAG_JPEGTABLESMODE , 0 ) ; if ( t2p -> pdf_colorspace & ( T2P_CS_RGB | T2P_CS_LAB ) ) { TIFFSetField ( output , TIFFTAG_PHOTOMETRIC , PHOTOMETRIC_YCBCR ) ; if ( t2p -> tiff_photometric != PHOTOMETRIC_YCBCR ) { TIFFSetField ( output , TIFFTAG_JPEGCOLORMODE , JPEGCOLORMODE_RGB ) ; } else { TIFFSetField ( output , TIFFTAG_JPEGCOLORMODE , JPEGCOLORMODE_RAW ) ; } } if ( t2p -> pdf_colorspace & T2P_CS_GRAY ) { ( void ) 0 ; } if ( t2p -> pdf_colorspace & T2P_CS_CMYK ) { ( void ) 0 ; } if ( t2p -> pdf_defaultcompressionquality != 0 ) { TIFFSetField ( output , TIFFTAG_JPEGQUALITY , t2p -> pdf_defaultcompressionquality ) ; } break ; # endif # ifdef ZIP_SUPPORT case T2P_COMPRESS_ZIP : TIFFSetField ( output , TIFFTAG_COMPRESSION , COMPRESSION_DEFLATE ) ; if ( t2p -> pdf_defaultcompressionquality % 100 != 0 ) { TIFFSetField ( output , TIFFTAG_PREDICTOR , t2p -> pdf_defaultcompressionquality % 100 ) ; } if ( t2p -> pdf_defaultcompressionquality / 100 != 0 ) { TIFFSetField ( output , TIFFTAG_ZIPQUALITY , ( t2p -> pdf_defaultcompressionquality / 100 ) ) ; } break ; # endif default : break ; } t2p_enable ( output ) ; t2p -> outputwritten = 0 ; bufferoffset = TIFFWriteEncodedStrip ( output , ( tstrip_t ) 0 , buffer , TIFFStripSize ( output ) ) ; if ( buffer != NULL ) { _TIFFfree ( buffer ) ; buffer = NULL ; } if ( bufferoffset == - 1 ) { TIFFError ( TIFF2PDF_MODULE , ""Error<S2SV_blank>writing<S2SV_blank>encoded<S2SV_blank>tile<S2SV_blank>to<S2SV_blank>output<S2SV_blank>PDF<S2SV_blank>%s"" , TIFFFileName ( output ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } written = t2p -> outputwritten ; return ( written ) ; }
","<S2SV_ModStart> if ( count > <S2SV_ModEnd> 4 ) {
"
489,"CWE-119 <S2SV_StartBug> void vp9_fht4x4_sse2 ( const int16_t * input , int16_t * output , <S2SV_EndBug> int stride , int tx_type ) { __m128i in [ 4 ] ; switch ( tx_type ) { case DCT_DCT : <S2SV_StartBug> vp9_fdct4x4_sse2 ( input , output , stride ) ; <S2SV_EndBug> break ; case ADST_DCT : load_buffer_4x4 ( input , in , stride ) ; fadst4_sse2 ( in ) ; fdct4_sse2 ( in ) ; write_buffer_4x4 ( output , in ) ; break ; case DCT_ADST : load_buffer_4x4 ( input , in , stride ) ; fdct4_sse2 ( in ) ; fadst4_sse2 ( in ) ; write_buffer_4x4 ( output , in ) ; break ; case ADST_ADST : load_buffer_4x4 ( input , in , stride ) ; fadst4_sse2 ( in ) ; fadst4_sse2 ( in ) ; write_buffer_4x4 ( output , in ) ; break ; default : assert ( 0 ) ; break ; } }
","<S2SV_ModStart> * input , tran_low_t <S2SV_ModEnd> * output , <S2SV_ModStart> case DCT_DCT : vpx_fdct4x4_sse2 <S2SV_ModEnd> ( input ,
"
490,"CWE-20 static int read_bytes ( FILE * fp , void * buf , size_t bytes_to_read , int fail_on_eof , char * errbuf ) { size_t amt_read ; amt_read = fread ( buf , 1 , bytes_to_read , fp ) ; if ( amt_read != bytes_to_read ) { if ( ferror ( fp ) ) { pcap_fmt_errmsg_for_errno ( errbuf , PCAP_ERRBUF_SIZE , errno , ""error<S2SV_blank>reading<S2SV_blank>dump<S2SV_blank>file"" ) ; } else { if ( amt_read == 0 && ! fail_on_eof ) return ( 0 ) ; pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , <S2SV_StartBug> ""truncated<S2SV_blank>dump<S2SV_blank>file;<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>read<S2SV_blank>%"" PRIsize ""<S2SV_blank>bytes,<S2SV_blank>only<S2SV_blank>got<S2SV_blank>%"" PRIsize , <S2SV_EndBug> bytes_to_read , amt_read ) ; } return ( - 1 ) ; } return ( 1 ) ; }
","<S2SV_ModStart> , PCAP_ERRBUF_SIZE , ""truncated<S2SV_blank>pcapng<S2SV_blank>dump<S2SV_blank>file;<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>read<S2SV_blank>%"" <S2SV_ModEnd> PRIsize ""<S2SV_blank>bytes,<S2SV_blank>only<S2SV_blank>got<S2SV_blank>%"" PRIsize
"
491,"CWE-125 static Image * ReadSUNImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define RMT_EQUAL_RGB 1 # define RMT_NONE 0 # define RMT_RAW 2 # define RT_STANDARD 1 # define RT_ENCODED 2 # define RT_FORMAT_RGB 3 typedef struct _SUNInfo { unsigned int magic , width , height , depth , length , type , maptype , maplength ; } SUNInfo ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bytes_per_line , extent , <S2SV_StartBug> length ; <S2SV_EndBug> ssize_t count , y ; SUNInfo sun_info ; unsigned char * sun_data , * sun_pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & sun_info , 0 , sizeof ( sun_info ) ) ; sun_info . magic = ReadBlobMSBLong ( image ) ; do { if ( sun_info . magic != 0x59a66a95 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; sun_info . width = ReadBlobMSBLong ( image ) ; sun_info . height = ReadBlobMSBLong ( image ) ; sun_info . depth = ReadBlobMSBLong ( image ) ; sun_info . length = ReadBlobMSBLong ( image ) ; sun_info . type = ReadBlobMSBLong ( image ) ; sun_info . maptype = ReadBlobMSBLong ( image ) ; sun_info . maplength = ReadBlobMSBLong ( image ) ; extent = sun_info . height * sun_info . width ; if ( ( sun_info . height != 0 ) && ( sun_info . width != extent / sun_info . height ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . type != RT_STANDARD ) && ( sun_info . type != RT_ENCODED ) && ( sun_info . type != RT_FORMAT_RGB ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype == RMT_NONE ) && ( sun_info . maplength != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . depth == 0 ) || ( sun_info . depth > 32 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype != RMT_NONE ) && ( sun_info . maptype != RMT_EQUAL_RGB ) && ( sun_info . maptype != RMT_RAW ) ) ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; image -> depth = sun_info . depth <= 8 ? sun_info . depth : MAGICKCORE_QUANTUM_DEPTH ; if ( sun_info . depth < 24 ) { size_t one ; image -> colors = sun_info . maplength ; one = 1 ; if ( sun_info . maptype == RMT_NONE ) image -> colors = one << sun_info . depth ; if ( sun_info . maptype == RMT_EQUAL_RGB ) image -> colors = sun_info . maplength / 3 ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } switch ( sun_info . maptype ) { case RMT_NONE : break ; case RMT_EQUAL_RGB : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } case RMT_RAW : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( sun_info . maplength , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , sun_info . maplength , sun_colormap ) ; if ( count != ( ssize_t ) sun_info . maplength ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; } image -> alpha_trait = sun_info . depth == 32 ? BlendPixelTrait : UndefinedPixelTrait ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( ( sun_info . length * sizeof ( * sun_data ) ) / sizeof ( * sun_data ) != sun_info . length || ! sun_info . length ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; if ( ( sun_info . type != RT_ENCODED ) && ( ( number_pixels * sun_info . depth ) > ( 8 * sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; bytes_per_line = sun_info . width * sun_info . depth ; sun_data = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( sun_info . length , bytes_per_line * sun_info . width ) , sizeof ( * sun_data ) ) ; if ( sun_data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ( ssize_t ) ReadBlob ( image , sun_info . length , sun_data ) ; if ( count != ( ssize_t ) sun_info . length ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; <S2SV_StartBug> sun_pixels = sun_data ; <S2SV_EndBug> bytes_per_line = 0 ; if ( sun_info . type == RT_ENCODED ) { size_t height ; height = sun_info . height ; if ( ( height == 0 ) || ( sun_info . width == 0 ) || ( sun_info . depth == 0 ) || ( ( bytes_per_line / sun_info . depth ) != sun_info . width ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; bytes_per_line += 15 ; bytes_per_line <<= 1 ; if ( ( bytes_per_line >> 1 ) != ( sun_info . width * sun_info . depth + 15 ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; bytes_per_line >>= 4 ; sun_pixels = ( unsigned char * ) AcquireQuantumMemory ( height , bytes_per_line * sizeof ( * sun_pixels ) ) ; if ( sun_pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_StartBug> ( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line * <S2SV_EndBug> height ) ; sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ; <S2SV_StartBug> } <S2SV_EndBug> p = sun_pixels ; if ( sun_info . depth == 1 ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 7 ; bit >= 0 ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 7 ; bit >= ( int ) ( 8 - ( image -> columns % 8 ) ) ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( ( ( image -> columns / 8 ) + ( image -> columns % 8 ? 1 : 0 ) ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } else if ( image -> storage_class == PseudoClass ) { if ( bytes_per_line == 0 ) bytes_per_line = image -> columns ; length = image -> rows * ( image -> columns + image -> columns % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( ( image -> columns % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { size_t bytes_per_pixel ; bytes_per_pixel = 3 ; if ( image -> alpha_trait != UndefinedPixelTrait ) bytes_per_pixel ++ ; if ( bytes_per_line == 0 ) bytes_per_line = bytes_per_pixel * image -> columns ; length = image -> rows * ( bytes_per_line + bytes_per_line % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( sun_info . type == RT_STANDARD ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } else { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } if ( image -> colors != 0 ) { SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelRed ( image , q ) ] . red ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelGreen ( image , q ) ] . green ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelBlue ( image , q ) ] . blue ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( ( ( bytes_per_pixel * image -> columns ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image , exception ) ; sun_pixels = ( unsigned char * ) RelinquishMagickMemory ( sun_pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; sun_info . magic = ReadBlobMSBLong ( image ) ; if ( sun_info . magic == 0x59a66a95 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( sun_info . magic == 0x59a66a95 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> , extent , height , <S2SV_ModStart> ""UnableToReadImageData"" ) ; <S2SV_ModEnd> height = sun_info <S2SV_ModStart> ""MemoryAllocationFailed"" ) ; if ( sun_info . type == RT_ENCODED ) <S2SV_ModStart> sun_data ) ; <S2SV_ModEnd> p = sun_pixels
"
492,"CWE-125 int main ( int argc , char * argv [ ] ) { FILE * iplist = NULL ; plist_t root_node = NULL ; char * plist_out = NULL ; uint32_t size = 0 ; int read_size = 0 ; char * plist_entire = NULL ; struct stat filestats ; options_t * options = parse_arguments ( argc , argv ) ; if ( ! options ) { print_usage ( argc , argv ) ; return 0 ; } iplist = fopen ( options -> in_file , ""rb"" ) ; if ( ! iplist ) { free ( options ) ; return 1 ; } <S2SV_StartBug> stat ( options -> in_file , & filestats ) ; <S2SV_EndBug> plist_entire = ( char * ) malloc ( sizeof ( char ) * ( filestats . st_size + 1 ) ) ; read_size = fread ( plist_entire , sizeof ( char ) , filestats . st_size , iplist ) ; fclose ( iplist ) ; if ( memcmp ( plist_entire , ""bplist00"" , 8 ) == 0 ) { plist_from_bin ( plist_entire , read_size , & root_node ) ; plist_to_xml ( root_node , & plist_out , & size ) ; } else { plist_from_xml ( plist_entire , read_size , & root_node ) ; plist_to_bin ( root_node , & plist_out , & size ) ; } plist_free ( root_node ) ; free ( plist_entire ) ; if ( plist_out ) { if ( options -> out_file != NULL ) { FILE * oplist = fopen ( options -> out_file , ""wb"" ) ; if ( ! oplist ) { free ( options ) ; return 1 ; } fwrite ( plist_out , size , sizeof ( char ) , oplist ) ; fclose ( oplist ) ; } else fwrite ( plist_out , size , sizeof ( char ) , stdout ) ; free ( plist_out ) ; } else printf ( ""ERROR:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>convert<S2SV_blank>input<S2SV_blank>file.\\n"" ) ; free ( options ) ; return 0 ; }
","<S2SV_ModStart> filestats ) ; if ( filestats . st_size < 8 ) { printf ( ""ERROR:<S2SV_blank>Input<S2SV_blank>file<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>to<S2SV_blank>contain<S2SV_blank>valid<S2SV_blank>plist<S2SV_blank>data.\\n"" ) ; return - 1 ; }
"
493,"CWE-20 static int adjust_insn_aux_data ( struct bpf_verifier_env * env , u32 prog_len , u32 off , u32 cnt ) { <S2SV_StartBug> struct bpf_insn_aux_data * new_data , * old_data = env -> insn_aux_data ; <S2SV_EndBug> if ( cnt == 1 ) return 0 ; new_data = vzalloc ( sizeof ( struct bpf_insn_aux_data ) * prog_len ) ; if ( ! new_data ) return - ENOMEM ; memcpy ( new_data , old_data , sizeof ( struct bpf_insn_aux_data ) * off ) ; memcpy ( new_data + off + cnt - 1 , old_data + off , sizeof ( struct bpf_insn_aux_data ) * ( prog_len - off - cnt + 1 ) ) ; <S2SV_StartBug> env -> insn_aux_data = new_data ; <S2SV_EndBug> vfree ( old_data ) ; return 0 ; }
","<S2SV_ModStart> env -> insn_aux_data ; int i <S2SV_ModStart> ) ) ; for ( i = off ; i < off + cnt - 1 ; i ++ ) new_data [ i ] . seen = true ;
"
494,"CWE-125 void qedi_dbg_info ( struct qedi_dbg_ctx * qedi , const char * func , u32 line , u32 level , const char * fmt , ... ) { va_list va ; <S2SV_StartBug> struct va_format vaf ; <S2SV_EndBug> char nfunc [ 32 ] ; memset ( nfunc , 0 , sizeof ( nfunc ) ) ; memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ; va_start ( va , fmt ) ; vaf . fmt = fmt ; vaf . va = & va ; if ( ! ( qedi_dbg_log & level ) ) goto ret ; if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_info ( ""[%s]:[%s:%d]:%d:<S2SV_blank>%pV"" , dev_name ( & qedi -> pdev -> dev ) , <S2SV_StartBug> nfunc , line , qedi -> host_no , & vaf ) ; <S2SV_EndBug> else <S2SV_StartBug> pr_info ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , nfunc , line , & vaf ) ; <S2SV_EndBug> ret : va_end ( va ) ; }
","<S2SV_ModStart> struct va_format vaf <S2SV_ModEnd> ; va_start ( <S2SV_ModStart> dev ) , func <S2SV_ModEnd> , line , <S2SV_ModStart> ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , func <S2SV_ModEnd> , line ,
"
495,"CWE-667 static void * gp_worker_main ( void * pvt ) { struct gp_thread * t = ( struct gp_thread * ) pvt ; struct gp_query * q = NULL ; char dummy = 0 ; int ret ; while ( ! t -> pool -> shutdown ) { gp_debug_set_conn_id ( 0 ) ; pthread_mutex_lock ( & t -> cond_mutex ) ; while ( t -> query == NULL ) { pthread_cond_wait ( & t -> cond_wakeup , & t -> cond_mutex ) ; <S2SV_StartBug> if ( t -> pool -> shutdown ) { <S2SV_EndBug> pthread_exit ( NULL ) ; } } q = t -> query ; t -> query = NULL ; pthread_mutex_unlock ( & t -> cond_mutex ) ; gp_debug_set_conn_id ( gp_conn_get_cid ( q -> conn ) ) ; GPDEBUGN ( 3 , ""[status]<S2SV_blank>Handling<S2SV_blank>query<S2SV_blank>input:<S2SV_blank>%p<S2SV_blank>(%zu)\\n"" , q -> buffer , q -> buflen ) ; gp_handle_query ( t -> pool , q ) ; GPDEBUGN ( 3 , ""[status]<S2SV_blank>Handling<S2SV_blank>query<S2SV_blank>output:<S2SV_blank>%p<S2SV_blank>(%zu)\\n"" , q -> buffer , q -> buflen ) ; pthread_mutex_lock ( & t -> pool -> lock ) ; q -> next = t -> pool -> reply_list ; t -> pool -> reply_list = q ; if ( ! t -> pool -> shutdown ) { LIST_DEL ( t -> pool -> busy_list , t ) ; LIST_ADD ( t -> pool -> free_list , t ) ; } pthread_mutex_unlock ( & t -> pool -> lock ) ; ret = write ( t -> pool -> sig_pipe [ 1 ] , & dummy , 1 ) ; if ( ret == - 1 ) { GPERROR ( ""Failed<S2SV_blank>to<S2SV_blank>signal<S2SV_blank>dispatcher!"" ) ; } } pthread_exit ( NULL ) ; }
","<S2SV_ModStart> shutdown ) { pthread_mutex_unlock ( & t -> cond_mutex ) ;
"
496,"CWE-310 static void prefetch_dec ( void ) <S2SV_StartBug> { <S2SV_EndBug> prefetch_table ( ( const void * ) & dec_tables , sizeof ( dec_tables ) ) ; }
","<S2SV_ModStart> void ) { dec_tables . counter_head ++ ; dec_tables . counter_tail ++ ;
"
497,"CWE-000 int jpc_bitstream_putbits ( jpc_bitstream_t * bitstream , int n , long v ) { int m ; <S2SV_StartBug> assert ( n >= 0 && n < 32 ) ; <S2SV_EndBug> assert ( ! ( v & ( ~ JAS_ONES ( n ) ) ) ) ; m = n - 1 ; while ( -- n >= 0 ) { if ( jpc_bitstream_putbit ( bitstream , ( v >> m ) & 1 ) == EOF ) { return EOF ; } v <<= 1 ; } return 0 ; }
","<S2SV_ModStart> int m ; if ( n < 0 || n >= 32 ) { return EOF ; } <S2SV_ModEnd> assert ( !
"
498,"CWE-125 static int dhcpv4_print ( netdissect_options * ndo , const u_char * cp , u_int length , int indent ) { u_int i , t ; const u_char * tlv , * value ; uint8_t type , optlen ; i = 0 ; while ( i < length ) { <S2SV_StartBug> tlv = cp + i ; <S2SV_EndBug> type = ( uint8_t ) tlv [ 0 ] ; optlen = ( uint8_t ) tlv [ 1 ] ; value = tlv + 2 ; ND_PRINT ( ( ndo , ""\\n"" ) ) ; for ( t = indent ; t > 0 ; t -- ) ND_PRINT ( ( ndo , ""\\t"" ) ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( dh4opt_str , ""Unknown"" , type ) ) ) ; <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>(%u)"" , optlen + 2 ) ) ; <S2SV_EndBug> switch ( type ) { case DH4OPT_DNS_SERVERS : case DH4OPT_NTP_SERVERS : { if ( optlen < 4 || optlen % 4 != 0 ) { return - 1 ; } for ( t = 0 ; t < optlen ; t += 4 ) ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , ipaddr_string ( ndo , value + t ) ) ) ; } break ; case DH4OPT_DOMAIN_SEARCH : { const u_char * tp = value ; while ( tp < value + optlen ) { ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; if ( ( tp = ns_nprint ( ndo , tp , value + optlen ) ) == NULL ) return - 1 ; } } break ; } i += 2 + optlen ; } return 0 ; }
","<S2SV_ModStart> length ) { if ( i + 2 > length ) return - 1 ; <S2SV_ModStart> 2 ) ) ; if ( i + 2 + optlen > length ) return - 1
"
499,"CWE-269 qboolean S_AL_Init ( soundInterface_t * si ) { # ifdef USE_OPENAL const char * device = NULL ; const char * inputdevice = NULL ; int i ; if ( ! si ) { return qfalse ; } for ( i = 0 ; i < MAX_RAW_STREAMS ; i ++ ) { streamSourceHandles [ i ] = - 1 ; streamPlaying [ i ] = qfalse ; streamSources [ i ] = 0 ; streamNumBuffers [ i ] = 0 ; streamBufIndex [ i ] = 0 ; } s_alPrecache = Cvar_Get ( ""s_alPrecache"" , ""1"" , CVAR_ARCHIVE ) ; s_alGain = Cvar_Get ( ""s_alGain"" , ""1.0"" , CVAR_ARCHIVE ) ; s_alSources = Cvar_Get ( ""s_alSources"" , ""128"" , CVAR_ARCHIVE ) ; s_alDopplerFactor = Cvar_Get ( ""s_alDopplerFactor"" , ""1.0"" , CVAR_ARCHIVE ) ; s_alDopplerSpeed = Cvar_Get ( ""s_alDopplerSpeed"" , ""9000"" , CVAR_ARCHIVE ) ; s_alMinDistance = Cvar_Get ( ""s_alMinDistance"" , ""256"" , CVAR_ARCHIVE ) ; s_alMaxDistance = Cvar_Get ( ""s_alMaxDistance"" , ""1024"" , CVAR_ARCHIVE ) ; s_alRolloff = Cvar_Get ( ""s_alRolloff"" , ""1.3"" , CVAR_ARCHIVE ) ; s_alGraceDistance = Cvar_Get ( ""s_alGraceDistance"" , ""512"" , CVAR_ARCHIVE ) ; s_alTalkAnims = Cvar_Get ( ""s_alTalkAnims"" , ""160"" , CVAR_ARCHIVE ) ; <S2SV_StartBug> s_alDriver = Cvar_Get ( ""s_alDriver"" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_EndBug> s_alInputDevice = Cvar_Get ( ""s_alInputDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_StartBug> s_alDevice = Cvar_Get ( ""s_alDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_EndBug> if ( ! QAL_Init ( s_alDriver -> string ) ) { # if defined ( _WIN32 ) if ( ! Q_stricmp ( s_alDriver -> string , ALDRIVER_DEFAULT ) && ! QAL_Init ( ""OpenAL64.dll"" ) ) { # elif defined ( __APPLE__ ) if ( ! Q_stricmp ( s_alDriver -> string , ALDRIVER_DEFAULT ) && ! QAL_Init ( ""/System/Library/Frameworks/OpenAL.framework/OpenAL"" ) ) { # else if ( ! Q_stricmp ( s_alDriver -> string , ALDRIVER_DEFAULT ) || ! QAL_Init ( ALDRIVER_DEFAULT ) ) { # endif return qfalse ; } } device = s_alDevice -> string ; if ( device && ! * device ) device = NULL ; inputdevice = s_alInputDevice -> string ; if ( inputdevice && ! * inputdevice ) inputdevice = NULL ; enumeration_all_ext = qalcIsExtensionPresent ( NULL , ""ALC_ENUMERATE_ALL_EXT"" ) ; enumeration_ext = qalcIsExtensionPresent ( NULL , ""ALC_ENUMERATION_EXT"" ) ; if ( enumeration_ext || enumeration_all_ext ) { char devicenames [ 16384 ] = """" ; const char * devicelist ; # ifdef _WIN32 const char * defaultdevice ; # endif int curlen ; if ( enumeration_all_ext ) { devicelist = qalcGetString ( NULL , ALC_ALL_DEVICES_SPECIFIER ) ; # ifdef _WIN32 defaultdevice = qalcGetString ( NULL , ALC_DEFAULT_ALL_DEVICES_SPECIFIER ) ; # endif } else { devicelist = qalcGetString ( NULL , ALC_DEVICE_SPECIFIER ) ; # ifdef _WIN32 defaultdevice = qalcGetString ( NULL , ALC_DEFAULT_DEVICE_SPECIFIER ) ; # endif enumeration_ext = qtrue ; } # ifdef _WIN32 if ( ! device && defaultdevice && ! strcmp ( defaultdevice , ""Generic<S2SV_blank>Hardware"" ) ) device = ""Generic<S2SV_blank>Software"" ; # endif if ( devicelist ) { while ( ( curlen = strlen ( devicelist ) ) ) { Q_strcat ( devicenames , sizeof ( devicenames ) , devicelist ) ; Q_strcat ( devicenames , sizeof ( devicenames ) , ""\\n"" ) ; devicelist += curlen + 1 ; } } s_alAvailableDevices = Cvar_Get ( ""s_alAvailableDevices"" , devicenames , CVAR_ROM | CVAR_NORESTART ) ; } alDevice = qalcOpenDevice ( device ) ; if ( ! alDevice && device ) { Com_Printf ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>OpenAL<S2SV_blank>device<S2SV_blank>\'%s\',<S2SV_blank>trying<S2SV_blank>default.\\n"" , device ) ; alDevice = qalcOpenDevice ( NULL ) ; } if ( ! alDevice ) { QAL_Shutdown ( ) ; Com_Printf ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>OpenAL<S2SV_blank>device.\\n"" ) ; return qfalse ; } alContext = qalcCreateContext ( alDevice , NULL ) ; if ( ! alContext ) { QAL_Shutdown ( ) ; qalcCloseDevice ( alDevice ) ; Com_Printf ( ""Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>OpenAL<S2SV_blank>context.\\n"" ) ; return qfalse ; } qalcMakeContextCurrent ( alContext ) ; S_AL_BufferInit ( ) ; S_AL_SrcInit ( ) ; Com_Printf ( ""Allocated<S2SV_blank>%d<S2SV_blank>sources.\\n"" , srcCount ) ; qalDistanceModel ( AL_INVERSE_DISTANCE_CLAMPED ) ; qalDopplerFactor ( s_alDopplerFactor -> value ) ; qalSpeedOfSound ( s_alDopplerSpeed -> value ) ; # ifdef USE_VOIP s_alCapture = Cvar_Get ( ""s_alCapture"" , ""1"" , CVAR_ARCHIVE | CVAR_LATCH ) ; if ( ! s_alCapture -> integer ) { Com_Printf ( ""OpenAL<S2SV_blank>capture<S2SV_blank>support<S2SV_blank>disabled<S2SV_blank>by<S2SV_blank>user<S2SV_blank>(\'+set<S2SV_blank>s_alCapture<S2SV_blank>1\'<S2SV_blank>to<S2SV_blank>enable)\\n"" ) ; } # if USE_MUMBLE else if ( cl_useMumble -> integer ) { Com_Printf ( ""OpenAL<S2SV_blank>capture<S2SV_blank>support<S2SV_blank>disabled<S2SV_blank>for<S2SV_blank>Mumble<S2SV_blank>support\\n"" ) ; } # endif else { # ifdef __APPLE__ if ( qalcCaptureOpenDevice == NULL ) # else if ( ! qalcIsExtensionPresent ( NULL , ""ALC_EXT_capture"" ) ) # endif { Com_Printf ( ""No<S2SV_blank>ALC_EXT_capture<S2SV_blank>support,<S2SV_blank>can\'t<S2SV_blank>record<S2SV_blank>audio.\\n"" ) ; } else { char inputdevicenames [ 16384 ] = """" ; const char * inputdevicelist ; const char * defaultinputdevice ; int curlen ; capture_ext = qtrue ; inputdevicelist = qalcGetString ( NULL , ALC_CAPTURE_DEVICE_SPECIFIER ) ; defaultinputdevice = qalcGetString ( NULL , ALC_CAPTURE_DEFAULT_DEVICE_SPECIFIER ) ; if ( inputdevicelist ) { while ( ( curlen = strlen ( inputdevicelist ) ) ) { Q_strcat ( inputdevicenames , sizeof ( inputdevicenames ) , inputdevicelist ) ; Q_strcat ( inputdevicenames , sizeof ( inputdevicenames ) , ""\\n"" ) ; inputdevicelist += curlen + 1 ; } } s_alAvailableInputDevices = Cvar_Get ( ""s_alAvailableInputDevices"" , inputdevicenames , CVAR_ROM | CVAR_NORESTART ) ; Com_Printf ( ""OpenAL<S2SV_blank>default<S2SV_blank>capture<S2SV_blank>device<S2SV_blank>is<S2SV_blank>\'%s\'\\n"" , defaultinputdevice ? defaultinputdevice : ""none"" ) ; alCaptureDevice = qalcCaptureOpenDevice ( inputdevice , 48000 , AL_FORMAT_MONO16 , VOIP_MAX_PACKET_SAMPLES * 4 ) ; if ( ! alCaptureDevice && inputdevice ) { Com_Printf ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>OpenAL<S2SV_blank>Input<S2SV_blank>device<S2SV_blank>\'%s\',<S2SV_blank>trying<S2SV_blank>default.\\n"" , inputdevice ) ; alCaptureDevice = qalcCaptureOpenDevice ( NULL , 48000 , AL_FORMAT_MONO16 , VOIP_MAX_PACKET_SAMPLES * 4 ) ; } Com_Printf ( ""OpenAL<S2SV_blank>capture<S2SV_blank>device<S2SV_blank>%s.\\n"" , ( alCaptureDevice == NULL ) ? ""failed<S2SV_blank>to<S2SV_blank>open"" : ""opened"" ) ; } } # endif si -> Shutdown = S_AL_Shutdown ; si -> StartSound = S_AL_StartSound ; si -> StartSoundEx = S_AL_StartSoundEx ; si -> StartLocalSound = S_AL_StartLocalSound ; si -> StartBackgroundTrack = S_AL_StartBackgroundTrack ; si -> StopBackgroundTrack = S_AL_StopBackgroundTrack ; si -> FadeStreamingSound = S_AL_FadeStreamingSound ; si -> FadeAllSounds = S_AL_FadeAllSounds ; si -> StartStreamingSound = S_AL_StartStreamingSound ; si -> StopEntStreamingSound = S_AL_StopEntStreamingSound ; si -> GetVoiceAmplitude = S_AL_GetVoiceAmplitude ; si -> RawSamples = S_AL_RawSamples ; si -> StopAllSounds = S_AL_StopAllSounds ; si -> ClearLoopingSounds = S_AL_ClearLoopingSounds ; si -> AddLoopingSound = S_AL_AddLoopingSound ; si -> AddRealLoopingSound = S_AL_AddRealLoopingSound ; si -> StopLoopingSound = S_AL_StopLoopingSound ; si -> Respatialize = S_AL_Respatialize ; si -> UpdateEntityPosition = S_AL_UpdateEntityPosition ; si -> Update = S_AL_Update ; si -> DisableSounds = S_AL_DisableSounds ; si -> BeginRegistration = S_AL_BeginRegistration ; si -> RegisterSound = S_AL_RegisterSound ; si -> ClearSoundBuffer = S_AL_ClearSoundBuffer ; si -> SoundInfo = S_AL_SoundInfo ; si -> SoundList = S_AL_SoundList ; # ifdef USE_VOIP si -> StartCapture = S_AL_StartCapture ; si -> AvailableCaptureSamples = S_AL_AvailableCaptureSamples ; si -> Capture = S_AL_Capture ; si -> StopCapture = S_AL_StopCapture ; si -> MasterGain = S_AL_MasterGain ; # endif return qtrue ; # else return qfalse ; # endif }
","<S2SV_ModStart> CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED <S2SV_ModStart> CVAR_LATCH ) ; if ( COM_CompareExtension ( s_alDriver -> string , "".pk3"" ) ) { Com_Printf ( ""Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\""%s\\"""" , s_alDriver -> string ) ; return qfalse ; }
"
500,"CWE-189 Datum bqarr_in ( PG_FUNCTION_ARGS ) { char * buf = ( char * ) PG_GETARG_POINTER ( 0 ) ; WORKSTATE state ; int32 i ; QUERYTYPE * query ; int32 commonlen ; ITEM * ptr ; NODE * tmp ; int32 pos = 0 ; # ifdef BS_DEBUG StringInfoData pbuf ; # endif state . buf = buf ; state . state = WAITOPERAND ; state . count = 0 ; state . num = 0 ; state . str = NULL ; makepol ( & state ) ; if ( ! state . num ) ereport ( ERROR , ( errcode ( ERRCODE_INVALID_PARAMETER_VALUE ) , errmsg ( ""empty<S2SV_blank>query"" ) ) ) ; <S2SV_StartBug> commonlen = COMPUTESIZE ( state . num ) ; <S2SV_EndBug> query = ( QUERYTYPE * ) palloc ( commonlen ) ; SET_VARSIZE ( query , commonlen ) ; query -> size = state . num ; ptr = GETQUERY ( query ) ; for ( i = state . num - 1 ; i >= 0 ; i -- ) { ptr [ i ] . type = state . str -> type ; ptr [ i ] . val = state . str -> val ; tmp = state . str -> next ; pfree ( state . str ) ; state . str = tmp ; } pos = query -> size - 1 ; findoprnd ( ptr , & pos ) ; # ifdef BS_DEBUG initStringInfo ( & pbuf ) ; for ( i = 0 ; i < query -> size ; i ++ ) { if ( ptr [ i ] . type == OPR ) appendStringInfo ( & pbuf , ""%c(%d)<S2SV_blank>"" , ptr [ i ] . val , ptr [ i ] . left ) ; else appendStringInfo ( & pbuf , ""%d<S2SV_blank>"" , ptr [ i ] . val ) ; } elog ( DEBUG3 , ""POR:<S2SV_blank>%s"" , pbuf . data ) ; pfree ( pbuf . data ) ; # endif PG_RETURN_POINTER ( query ) ; }
","<S2SV_ModStart> ) ) ; if ( state . num > QUERYTYPEMAXITEMS ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>query<S2SV_blank>items<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , state . num , ( int ) QUERYTYPEMAXITEMS ) ) ) ;
"
501,"CWE-119 static void zero_stats ( FIRSTPASS_STATS * section ) { <S2SV_StartBug> section -> frame = 0.0 ; <S2SV_EndBug> section -> intra_error = 0.0 ; section -> coded_error = 0.0 ; <S2SV_StartBug> section -> sr_coded_error = 0.0 ; <S2SV_EndBug> section -> ssim_weighted_pred_err = 0.0 ; section -> pcnt_inter = 0.0 ; section -> pcnt_motion = 0.0 ; section -> pcnt_second_ref = 0.0 ; <S2SV_StartBug> section -> pcnt_neutral = 0.0 ; <S2SV_EndBug> section -> MVr = 0.0 ; section -> mvr_abs = 0.0 ; section -> MVc = 0.0 ; section -> mvc_abs = 0.0 ; section -> MVrv = 0.0 ; section -> MVcv = 0.0 ; section -> mv_in_out_count = 0.0 ; section -> new_mv_count = 0.0 ; section -> count = 0.0 ; section -> duration = 1.0 ; section -> spatial_layer_id = 0 ; }
","<S2SV_ModStart> section -> frame = 0.0 ; section -> weight <S2SV_ModStart> section -> sr_coded_error <S2SV_ModEnd> = 0.0 ; <S2SV_ModStart> section -> pcnt_neutral = 0.0 ; section -> intra_skip_pct = 0.0 ; section -> inactive_zone_rows = 0.0 ; section -> inactive_zone_cols
"
502,"CWE-787 int pdf_load_xrefs ( FILE * fp , pdf_t * pdf ) { int i , ver , is_linear ; long pos , pos_count ; char x , * c , buf [ 256 ] ; c = NULL ; pdf -> n_xrefs = 0 ; fseek ( fp , 0 , SEEK_SET ) ; while ( get_next_eof ( fp ) >= 0 ) ++ pdf -> n_xrefs ; if ( ! pdf -> n_xrefs ) return 0 ; fseek ( fp , 0 , SEEK_SET ) ; <S2SV_StartBug> pdf -> xrefs = calloc ( 1 , sizeof ( xref_t ) * pdf -> n_xrefs ) ; <S2SV_EndBug> ver = 1 ; for ( i = 0 ; i < pdf -> n_xrefs ; i ++ ) { if ( ( pos = get_next_eof ( fp ) ) < 0 ) break ; pdf -> xrefs [ i ] . version = ver ++ ; pos_count = 0 ; while ( SAFE_F ( fp , ( ( x = fgetc ( fp ) ) != 'f' ) ) ) fseek ( fp , pos - ( ++ pos_count ) , SEEK_SET ) ; if ( pos_count >= sizeof ( buf ) ) { ERR ( ""Failed<S2SV_blank>to<S2SV_blank>locate<S2SV_blank>the<S2SV_blank>startxref<S2SV_blank>token.<S2SV_blank>"" ""This<S2SV_blank>might<S2SV_blank>be<S2SV_blank>a<S2SV_blank>corrupt<S2SV_blank>PDF.\\n"" ) ; return - 1 ; } memset ( buf , 0 , sizeof ( buf ) ) ; SAFE_E ( fread ( buf , 1 , pos_count , fp ) , pos_count , ""Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>startxref.\\n"" ) ; c = buf ; while ( * c == '<S2SV_blank>' || * c == '\\n' || * c == '\\r' ) ++ c ; pdf -> xrefs [ i ] . start = atol ( c ) ; if ( pdf -> xrefs [ i ] . start == 0 ) get_xref_linear_skipped ( fp , & pdf -> xrefs [ i ] ) ; else { pos = ftell ( fp ) ; fseek ( fp , pdf -> xrefs [ i ] . start , SEEK_SET ) ; pdf -> xrefs [ i ] . end = get_next_eof ( fp ) ; fseek ( fp , pos , SEEK_SET ) ; } if ( ! is_valid_xref ( fp , pdf , & pdf -> xrefs [ i ] ) ) { is_linear = pdf -> xrefs [ i ] . is_linear ; memset ( & pdf -> xrefs [ i ] , 0 , sizeof ( xref_t ) ) ; pdf -> xrefs [ i ] . is_linear = is_linear ; rewind ( fp ) ; get_next_eof ( fp ) ; continue ; } load_xref_entries ( fp , & pdf -> xrefs [ i ] ) ; } if ( pdf -> xrefs [ 0 ] . is_linear ) resolve_linearized_pdf ( pdf ) ; load_creator ( fp , pdf ) ; return pdf -> n_xrefs ; }
","<S2SV_ModStart> -> xrefs = safe_calloc ( <S2SV_ModEnd> sizeof ( xref_t
"
503,"CWE-772 static bool fib6_rule_suppress ( struct fib_rule * rule , struct fib_lookup_arg * arg ) { struct fib6_result * res = arg -> result ; struct rt6_info * rt = res -> rt6 ; struct net_device * dev = NULL ; if ( ! rt ) return false ; if ( rt -> rt6i_idev ) dev = rt -> rt6i_idev -> dev ; if ( rt -> rt6i_dst . plen <= rule -> suppress_prefixlen ) goto suppress_route ; if ( rule -> suppress_ifgroup != - 1 && dev && dev -> group == rule -> suppress_ifgroup ) goto suppress_route ; return false ; suppress_route : <S2SV_StartBug> ip6_rt_put ( rt ) ; <S2SV_EndBug> return true ; }
","<S2SV_ModStart> ; suppress_route : if ( ! ( arg -> flags & FIB_LOOKUP_NOREF ) )
"
504,"CWE-119 static __u8 * mr_report_fixup ( struct hid_device * hdev , __u8 * rdesc , unsigned int * rsize ) { <S2SV_StartBug> if ( * rsize >= 30 && rdesc [ 29 ] == 0x05 && rdesc [ 30 ] == 0x09 ) { <S2SV_EndBug> hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>button/consumer<S2SV_blank>in<S2SV_blank>HID<S2SV_blank>report<S2SV_blank>descriptor\\n"" ) ; rdesc [ 30 ] = 0x0c ; } return rdesc ; }
","<S2SV_ModStart> * rsize >= 31 <S2SV_ModEnd> && rdesc [
"
505,"CWE-264 int x86_emulate_insn ( struct x86_emulate_ctxt * ctxt ) { const struct x86_emulate_ops * ops = ctxt -> ops ; int rc = X86EMUL_CONTINUE ; int saved_dst_type = ctxt -> dst . type ; ctxt -> mem_read . pos = 0 ; if ( ctxt -> lock_prefix && ( ! ( ctxt -> d & Lock ) || ctxt -> dst . type != OP_MEM ) ) { rc = emulate_ud ( ctxt ) ; goto done ; } if ( ( ctxt -> d & SrcMask ) == SrcMemFAddr && ctxt -> src . type != OP_MEM ) { rc = emulate_ud ( ctxt ) ; goto done ; } if ( unlikely ( ctxt -> d & ( No64 | Undefined | Sse | Mmx | Intercept | CheckPerm | Priv | Prot | String ) ) ) { if ( ( ctxt -> mode == X86EMUL_MODE_PROT64 && ( ctxt -> d & No64 ) ) || ( ctxt -> d & Undefined ) ) { rc = emulate_ud ( ctxt ) ; goto done ; } if ( ( ( ctxt -> d & ( Sse | Mmx ) ) && ( ( ops -> get_cr ( ctxt , 0 ) & X86_CR0_EM ) ) ) || ( ( ctxt -> d & Sse ) && ! ( ops -> get_cr ( ctxt , 4 ) & X86_CR4_OSFXSR ) ) ) { rc = emulate_ud ( ctxt ) ; goto done ; } if ( ( ctxt -> d & ( Sse | Mmx ) ) && ( ops -> get_cr ( ctxt , 0 ) & X86_CR0_TS ) ) { rc = emulate_nm ( ctxt ) ; goto done ; } if ( ctxt -> d & Mmx ) { rc = flush_pending_x87_faults ( ctxt ) ; if ( rc != X86EMUL_CONTINUE ) goto done ; fetch_possible_mmx_operand ( ctxt , & ctxt -> src ) ; fetch_possible_mmx_operand ( ctxt , & ctxt -> src2 ) ; if ( ! ( ctxt -> d & Mov ) ) fetch_possible_mmx_operand ( ctxt , & ctxt -> dst ) ; } if ( unlikely ( ctxt -> guest_mode ) && ( ctxt -> d & Intercept ) ) { rc = emulator_check_intercept ( ctxt , ctxt -> intercept , X86_ICPT_PRE_EXCEPT ) ; if ( rc != X86EMUL_CONTINUE ) goto done ; } if ( ( ctxt -> d & Priv ) && ops -> cpl ( ctxt ) ) { if ( ctxt -> d & PrivUD ) rc = emulate_ud ( ctxt ) ; else rc = emulate_gp ( ctxt , 0 ) ; goto done ; } if ( ( ctxt -> d & Prot ) && ctxt -> mode < X86EMUL_MODE_PROT16 ) { rc = emulate_ud ( ctxt ) ; goto done ; } if ( ctxt -> d & CheckPerm ) { rc = ctxt -> check_perm ( ctxt ) ; if ( rc != X86EMUL_CONTINUE ) goto done ; } if ( unlikely ( ctxt -> guest_mode ) && ( ctxt -> d & Intercept ) ) { rc = emulator_check_intercept ( ctxt , ctxt -> intercept , X86_ICPT_POST_EXCEPT ) ; if ( rc != X86EMUL_CONTINUE ) goto done ; } if ( ctxt -> rep_prefix && ( ctxt -> d & String ) ) { if ( address_mask ( ctxt , reg_read ( ctxt , VCPU_REGS_RCX ) ) == 0 ) { ctxt -> eip = ctxt -> _eip ; ctxt -> eflags &= ~ EFLG_RF ; goto done ; } } } if ( ( ctxt -> src . type == OP_MEM ) && ! ( ctxt -> d & NoAccess ) ) { rc = segmented_read ( ctxt , ctxt -> src . addr . mem , ctxt -> src . valptr , ctxt -> src . bytes ) ; if ( rc != X86EMUL_CONTINUE ) goto done ; ctxt -> src . orig_val64 = ctxt -> src . val64 ; } if ( ctxt -> src2 . type == OP_MEM ) { rc = segmented_read ( ctxt , ctxt -> src2 . addr . mem , & ctxt -> src2 . val , ctxt -> src2 . bytes ) ; if ( rc != X86EMUL_CONTINUE ) goto done ; } if ( ( ctxt -> d & DstMask ) == ImplicitOps ) goto special_insn ; if ( ( ctxt -> dst . type == OP_MEM ) && ! ( ctxt -> d & Mov ) ) { rc = segmented_read ( ctxt , ctxt -> dst . addr . mem , & ctxt -> dst . val , ctxt -> dst . bytes ) ; if ( rc != X86EMUL_CONTINUE ) goto done ; } ctxt -> dst . orig_val = ctxt -> dst . val ; special_insn : if ( unlikely ( ctxt -> guest_mode ) && ( ctxt -> d & Intercept ) ) { rc = emulator_check_intercept ( ctxt , ctxt -> intercept , X86_ICPT_POST_MEMACCESS ) ; if ( rc != X86EMUL_CONTINUE ) goto done ; } if ( ctxt -> rep_prefix && ( ctxt -> d & String ) ) ctxt -> eflags |= EFLG_RF ; else ctxt -> eflags &= ~ EFLG_RF ; if ( ctxt -> execute ) { if ( ctxt -> d & Fastop ) { void ( * fop ) ( struct fastop * ) = ( void * ) ctxt -> execute ; rc = fastop ( ctxt , fop ) ; if ( rc != X86EMUL_CONTINUE ) goto done ; goto writeback ; } rc = ctxt -> execute ( ctxt ) ; if ( rc != X86EMUL_CONTINUE ) goto done ; goto writeback ; } if ( ctxt -> opcode_len == 2 ) goto twobyte_insn ; else if ( ctxt -> opcode_len == 3 ) goto threebyte_insn ; switch ( ctxt -> b ) { case 0x63 : if ( ctxt -> mode != X86EMUL_MODE_PROT64 ) goto cannot_emulate ; ctxt -> dst . val = ( s32 ) ctxt -> src . val ; break ; case 0x70 ... 0x7f : if ( test_cc ( ctxt -> b , ctxt -> eflags ) ) <S2SV_StartBug> jmp_rel ( ctxt , ctxt -> src . val ) ; <S2SV_EndBug> break ; case 0x8d : ctxt -> dst . val = ctxt -> src . addr . mem . ea ; break ; case 0x90 ... 0x97 : if ( ctxt -> dst . addr . reg == reg_rmw ( ctxt , VCPU_REGS_RAX ) ) ctxt -> dst . type = OP_NONE ; else rc = em_xchg ( ctxt ) ; break ; case 0x98 : switch ( ctxt -> op_bytes ) { case 2 : ctxt -> dst . val = ( s8 ) ctxt -> dst . val ; break ; case 4 : ctxt -> dst . val = ( s16 ) ctxt -> dst . val ; break ; case 8 : ctxt -> dst . val = ( s32 ) ctxt -> dst . val ; break ; } break ; case 0xcc : rc = emulate_int ( ctxt , 3 ) ; break ; case 0xcd : rc = emulate_int ( ctxt , ctxt -> src . val ) ; break ; case 0xce : if ( ctxt -> eflags & EFLG_OF ) rc = emulate_int ( ctxt , 4 ) ; break ; case 0xe9 : case 0xeb : <S2SV_StartBug> jmp_rel ( ctxt , ctxt -> src . val ) ; <S2SV_EndBug> ctxt -> dst . type = OP_NONE ; break ; case 0xf4 : ctxt -> ops -> halt ( ctxt ) ; break ; case 0xf5 : ctxt -> eflags ^= EFLG_CF ; break ; case 0xf8 : ctxt -> eflags &= ~ EFLG_CF ; break ; case 0xf9 : ctxt -> eflags |= EFLG_CF ; break ; case 0xfc : ctxt -> eflags &= ~ EFLG_DF ; break ; case 0xfd : ctxt -> eflags |= EFLG_DF ; break ; default : goto cannot_emulate ; } if ( rc != X86EMUL_CONTINUE ) goto done ; writeback : if ( ctxt -> d & SrcWrite ) { BUG_ON ( ctxt -> src . type == OP_MEM || ctxt -> src . type == OP_MEM_STR ) ; rc = writeback ( ctxt , & ctxt -> src ) ; if ( rc != X86EMUL_CONTINUE ) goto done ; } if ( ! ( ctxt -> d & NoWrite ) ) { rc = writeback ( ctxt , & ctxt -> dst ) ; if ( rc != X86EMUL_CONTINUE ) goto done ; } ctxt -> dst . type = saved_dst_type ; if ( ( ctxt -> d & SrcMask ) == SrcSI ) string_addr_inc ( ctxt , VCPU_REGS_RSI , & ctxt -> src ) ; if ( ( ctxt -> d & DstMask ) == DstDI ) string_addr_inc ( ctxt , VCPU_REGS_RDI , & ctxt -> dst ) ; if ( ctxt -> rep_prefix && ( ctxt -> d & String ) ) { unsigned int count ; struct read_cache * r = & ctxt -> io_read ; if ( ( ctxt -> d & SrcMask ) == SrcSI ) count = ctxt -> src . count ; else count = ctxt -> dst . count ; register_address_increment ( ctxt , reg_rmw ( ctxt , VCPU_REGS_RCX ) , - count ) ; if ( ! string_insn_completed ( ctxt ) ) { if ( ( r -> end != 0 || reg_read ( ctxt , VCPU_REGS_RCX ) & 0x3ff ) && ( r -> end == 0 || r -> end != r -> pos ) ) { ctxt -> mem_read . end = 0 ; writeback_registers ( ctxt ) ; return EMULATION_RESTART ; } goto done ; } ctxt -> eflags &= ~ EFLG_RF ; } ctxt -> eip = ctxt -> _eip ; done : if ( rc == X86EMUL_PROPAGATE_FAULT ) { WARN_ON ( ctxt -> exception . vector > 0x1f ) ; ctxt -> have_exception = true ; } if ( rc == X86EMUL_INTERCEPTED ) return EMULATION_INTERCEPTED ; if ( rc == X86EMUL_CONTINUE ) writeback_registers ( ctxt ) ; return ( rc == X86EMUL_UNHANDLEABLE ) ? EMULATION_FAILED : EMULATION_OK ; twobyte_insn : switch ( ctxt -> b ) { case 0x09 : ( ctxt -> ops -> wbinvd ) ( ctxt ) ; break ; case 0x08 : case 0x0d : case 0x18 : case 0x1f : break ; case 0x20 : ctxt -> dst . val = ops -> get_cr ( ctxt , ctxt -> modrm_reg ) ; break ; case 0x21 : ops -> get_dr ( ctxt , ctxt -> modrm_reg , & ctxt -> dst . val ) ; break ; case 0x40 ... 0x4f : if ( test_cc ( ctxt -> b , ctxt -> eflags ) ) ctxt -> dst . val = ctxt -> src . val ; else if ( ctxt -> mode != X86EMUL_MODE_PROT64 || ctxt -> op_bytes != 4 ) ctxt -> dst . type = OP_NONE ; break ; case 0x80 ... 0x8f : if ( test_cc ( ctxt -> b , ctxt -> eflags ) ) <S2SV_StartBug> jmp_rel ( ctxt , ctxt -> src . val ) ; <S2SV_EndBug> break ; case 0x90 ... 0x9f : ctxt -> dst . val = test_cc ( ctxt -> b , ctxt -> eflags ) ; break ; case 0xae : break ; case 0xb6 ... 0xb7 : ctxt -> dst . bytes = ctxt -> op_bytes ; ctxt -> dst . val = ( ctxt -> src . bytes == 1 ) ? ( u8 ) ctxt -> src . val : ( u16 ) ctxt -> src . val ; break ; case 0xbe ... 0xbf : ctxt -> dst . bytes = ctxt -> op_bytes ; ctxt -> dst . val = ( ctxt -> src . bytes == 1 ) ? ( s8 ) ctxt -> src . val : ( s16 ) ctxt -> src . val ; break ; case 0xc3 : ctxt -> dst . bytes = ctxt -> op_bytes ; ctxt -> dst . val = ( ctxt -> op_bytes == 8 ) ? ( u64 ) ctxt -> src . val : ( u32 ) ctxt -> src . val ; break ; default : goto cannot_emulate ; } threebyte_insn : if ( rc != X86EMUL_CONTINUE ) goto done ; goto writeback ; cannot_emulate : return EMULATION_FAILED ; }
","<S2SV_ModStart> eflags ) ) rc = <S2SV_ModStart> case 0xeb : rc = <S2SV_ModStart> eflags ) ) rc =
"
506,"CWE-000 int install_user_keyrings ( void ) { struct user_struct * user ; const struct cred * cred ; struct key * uid_keyring , * session_keyring ; key_perm_t user_keyring_perm ; char buf [ 20 ] ; int ret ; uid_t uid ; user_keyring_perm = ( KEY_POS_ALL & ~ KEY_POS_SETATTR ) | KEY_USR_ALL ; cred = current_cred ( ) ; user = cred -> user ; uid = from_kuid ( cred -> user_ns , user -> uid ) ; kenter ( ""%p{%u}"" , user , uid ) ; if ( user -> uid_keyring && user -> session_keyring ) { kleave ( ""<S2SV_blank>=<S2SV_blank>0<S2SV_blank>[exist]"" ) ; return 0 ; } mutex_lock ( & key_user_keyring_mutex ) ; ret = 0 ; if ( ! user -> uid_keyring ) { sprintf ( buf , ""_uid.%u"" , uid ) ; uid_keyring = find_keyring_by_name ( buf , true ) ; if ( IS_ERR ( uid_keyring ) ) { uid_keyring = keyring_alloc ( buf , user -> uid , INVALID_GID , cred , user_keyring_perm , <S2SV_StartBug> KEY_ALLOC_IN_QUOTA , <S2SV_EndBug> NULL , NULL ) ; if ( IS_ERR ( uid_keyring ) ) { ret = PTR_ERR ( uid_keyring ) ; goto error ; } } sprintf ( buf , ""_uid_ses.%u"" , uid ) ; session_keyring = find_keyring_by_name ( buf , true ) ; if ( IS_ERR ( session_keyring ) ) { session_keyring = keyring_alloc ( buf , user -> uid , INVALID_GID , cred , user_keyring_perm , <S2SV_StartBug> KEY_ALLOC_IN_QUOTA , <S2SV_EndBug> NULL , NULL ) ; if ( IS_ERR ( session_keyring ) ) { ret = PTR_ERR ( session_keyring ) ; goto error_release ; } ret = key_link ( session_keyring , uid_keyring ) ; if ( ret < 0 ) goto error_release_both ; } user -> uid_keyring = uid_keyring ; user -> session_keyring = session_keyring ; } mutex_unlock ( & key_user_keyring_mutex ) ; kleave ( ""<S2SV_blank>=<S2SV_blank>0"" ) ; return 0 ; error_release_both : key_put ( session_keyring ) ; error_release : key_put ( uid_keyring ) ; error : mutex_unlock ( & key_user_keyring_mutex ) ; kleave ( ""<S2SV_blank>=<S2SV_blank>%d"" , ret ) ; return ret ; }
","<S2SV_ModStart> , user_keyring_perm , KEY_ALLOC_UID_KEYRING | <S2SV_ModStart> , user_keyring_perm , KEY_ALLOC_UID_KEYRING |
"
507,"CWE-190 int jas_seq2d_output ( jas_matrix_t * matrix , FILE * out ) { # define MAXLINELEN 80 <S2SV_StartBug> int i ; <S2SV_EndBug> int j ; jas_seqent_t x ; char buf [ MAXLINELEN + 1 ] ; char sbuf [ MAXLINELEN + 1 ] ; int n ; fprintf ( out , ""%"" PRIiFAST32 ""<S2SV_blank>%"" PRIiFAST32 ""\\n"" , jas_seq2d_xstart ( matrix ) , jas_seq2d_ystart ( matrix ) ) ; fprintf ( out , ""%"" PRIiFAST32 ""<S2SV_blank>%"" PRIiFAST32 ""\\n"" , jas_matrix_numcols ( matrix ) , jas_matrix_numrows ( matrix ) ) ; buf [ 0 ] = '\\0' ; for ( i = 0 ; i < jas_matrix_numrows ( matrix ) ; ++ i ) { for ( j = 0 ; j < jas_matrix_numcols ( matrix ) ; ++ j ) { x = jas_matrix_get ( matrix , i , j ) ; sprintf ( sbuf , ""%s%4ld"" , ( strlen ( buf ) > 0 ) ? ""<S2SV_blank>"" : """" , JAS_CAST ( long , x ) ) ; n = JAS_CAST ( int , strlen ( buf ) ) ; if ( n + JAS_CAST ( int , strlen ( sbuf ) ) > MAXLINELEN ) { fputs ( buf , out ) ; fputs ( ""\\n"" , out ) ; buf [ 0 ] = '\\0' ; } strcat ( buf , sbuf ) ; if ( j == jas_matrix_numcols ( matrix ) - 1 ) { fputs ( buf , out ) ; fputs ( ""\\n"" , out ) ; buf [ 0 ] = '\\0' ; } } } fputs ( buf , out ) ; return 0 ; }
","<S2SV_ModStart> define MAXLINELEN 80 jas_matind_t i ; jas_matind_t <S2SV_ModEnd> j ; jas_seqent_t
"
508,"CWE-264 static int rio_ioctl ( struct net_device * dev , struct ifreq * rq , int cmd ) { int phy_addr ; struct netdev_private * np = netdev_priv ( dev ) ; <S2SV_StartBug> struct mii_data * miidata = ( struct mii_data * ) & rq -> ifr_ifru ; <S2SV_EndBug> struct netdev_desc * desc ; int i ; phy_addr = np -> phy_addr ; switch ( cmd ) { <S2SV_StartBug> case SIOCDEVPRIVATE : <S2SV_EndBug> break ; <S2SV_StartBug> case SIOCDEVPRIVATE + 1 : <S2SV_EndBug> <S2SV_StartBug> miidata -> out_value = mii_read ( dev , phy_addr , miidata -> reg_num ) ; <S2SV_EndBug> break ; <S2SV_StartBug> case SIOCDEVPRIVATE + 2 : <S2SV_EndBug> <S2SV_StartBug> mii_write ( dev , phy_addr , miidata -> reg_num , miidata -> in_value ) ; <S2SV_EndBug> break ; case SIOCDEVPRIVATE + 3 : break ; case SIOCDEVPRIVATE + 4 : break ; case SIOCDEVPRIVATE + 5 : netif_stop_queue ( dev ) ; break ; case SIOCDEVPRIVATE + 6 : netif_wake_queue ( dev ) ; break ; case SIOCDEVPRIVATE + 7 : printk ( ""tx_full=%x<S2SV_blank>cur_tx=%lx<S2SV_blank>old_tx=%lx<S2SV_blank>cur_rx=%lx<S2SV_blank>old_rx=%lx\\n"" , netif_queue_stopped ( dev ) , np -> cur_tx , np -> old_tx , np -> cur_rx , np -> old_rx ) ; break ; case SIOCDEVPRIVATE + 8 : printk ( ""TX<S2SV_blank>ring:\\n"" ) ; for ( i = 0 ; i < TX_RING_SIZE ; i ++ ) { desc = & np -> tx_ring [ i ] ; printk ( ""%02x:cur:%08x<S2SV_blank>next:%08x<S2SV_blank>status:%08x<S2SV_blank>frag1:%08x<S2SV_blank>frag0:%08x"" , i , ( u32 ) ( np -> tx_ring_dma + i * sizeof ( * desc ) ) , ( u32 ) le64_to_cpu ( desc -> next_desc ) , ( u32 ) le64_to_cpu ( desc -> status ) , ( u32 ) ( le64_to_cpu ( desc -> fraginfo ) >> 32 ) , ( u32 ) le64_to_cpu ( desc -> fraginfo ) ) ; printk ( ""\\n"" ) ; } printk ( ""\\n"" ) ; break ; default : return - EOPNOTSUPP ; } return 0 ; }
","<S2SV_ModStart> ) ; struct mii_ioctl_data <S2SV_ModEnd> * miidata = <S2SV_ModStart> * miidata = if_mii ( rq ) <S2SV_ModEnd> ; phy_addr = <S2SV_ModStart> ) { case SIOCGMIIPHY : miidata -> phy_id = phy_addr ; <S2SV_ModEnd> break ; case <S2SV_ModStart> break ; case SIOCGMIIREG <S2SV_ModEnd> : miidata -> <S2SV_ModStart> : miidata -> val_out <S2SV_ModEnd> = mii_read ( <S2SV_ModStart> break ; case SIOCSMIIREG : if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; <S2SV_ModEnd> mii_write ( dev <S2SV_ModStart> , miidata -> val_in <S2SV_ModEnd> ) ; break
"
509,"CWE-119 static Image * ReadSGIImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; SGIInfo iris_info ; size_t bytes_per_pixel , quantum ; ssize_t count , y , z ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } iris_info . magic = ReadBlobMSBShort ( image ) ; do { if ( iris_info . magic != 0x01DA ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; iris_info . storage = ( unsigned char ) ReadBlobByte ( image ) ; switch ( iris_info . storage ) { case 0x00 : image -> compression = NoCompression ; break ; case 0x01 : image -> compression = RLECompression ; break ; default : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } iris_info . bytes_per_pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( iris_info . bytes_per_pixel == 0 ) || ( iris_info . bytes_per_pixel > 2 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; <S2SV_StartBug> iris_info . dimension = ReadBlobMSBShort ( image ) ; <S2SV_EndBug> iris_info . columns = ReadBlobMSBShort ( image ) ; iris_info . rows = ReadBlobMSBShort ( image ) ; iris_info . depth = ReadBlobMSBShort ( image ) ; if ( ( iris_info . depth == 0 ) || ( iris_info . depth > 4 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; iris_info . minimum_value = ReadBlobMSBLong ( image ) ; iris_info . maximum_value = ReadBlobMSBLong ( image ) ; iris_info . sans = ReadBlobMSBLong ( image ) ; count = ReadBlob ( image , sizeof ( iris_info . name ) , ( unsigned char * ) iris_info . name ) ; if ( ( size_t ) count != sizeof ( iris_info . name ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; iris_info . name [ sizeof ( iris_info . name ) - 1 ] = '\\0' ; if ( * iris_info . name != '\\0' ) ( void ) SetImageProperty ( image , ""label"" , iris_info . name , exception ) ; iris_info . pixel_format = ReadBlobMSBLong ( image ) ; if ( iris_info . pixel_format != 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; count = ReadBlob ( image , sizeof ( iris_info . filler ) , iris_info . filler ) ; if ( ( size_t ) count != sizeof ( iris_info . filler ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> columns = iris_info . columns ; image -> rows = iris_info . rows ; image -> depth = ( size_t ) MagickMin ( iris_info . depth , MAGICKCORE_QUANTUM_DEPTH ) ; if ( iris_info . pixel_format == 0 ) image -> depth = ( size_t ) MagickMin ( ( size_t ) 8 * iris_info . bytes_per_pixel , MAGICKCORE_QUANTUM_DEPTH ) ; if ( iris_info . depth < 3 ) { image -> storage_class = PseudoClass ; image -> colors = ( size_t ) ( iris_info . bytes_per_pixel > 1 ? 65535 : 256 ) ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; bytes_per_pixel = ( size_t ) iris_info . bytes_per_pixel ; number_pixels = ( MagickSizeType ) iris_info . columns * iris_info . rows ; if ( ( 4 * bytes_per_pixel * number_pixels ) != ( ( MagickSizeType ) ( size_t ) ( 4 * bytes_per_pixel * number_pixels ) ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( iris_info . columns , iris_info . rows * 4 * bytes_per_pixel * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; if ( ( int ) iris_info . storage != 0x01 ) { unsigned char * scanline ; scanline = ( unsigned char * ) AcquireQuantumMemory ( iris_info . columns , bytes_per_pixel * sizeof ( * scanline ) ) ; if ( scanline == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( z = 0 ; z < ( ssize_t ) iris_info . depth ; z ++ ) { p = pixels + bytes_per_pixel * z ; for ( y = 0 ; y < ( ssize_t ) iris_info . rows ; y ++ ) { count = ReadBlob ( image , bytes_per_pixel * iris_info . columns , scanline ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; if ( bytes_per_pixel == 2 ) for ( x = 0 ; x < ( ssize_t ) iris_info . columns ; x ++ ) { * p = scanline [ 2 * x ] ; * ( p + 1 ) = scanline [ 2 * x + 1 ] ; p += 8 ; } else for ( x = 0 ; x < ( ssize_t ) iris_info . columns ; x ++ ) { * p = scanline [ x ] ; p += 4 ; } } } scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; } else { MemoryInfo * packet_info ; size_t * runlength ; ssize_t offset , * offsets ; unsigned char * packets ; unsigned int data_order ; offsets = ( ssize_t * ) AcquireQuantumMemory ( ( size_t ) iris_info . rows , iris_info . depth * sizeof ( * offsets ) ) ; runlength = ( size_t * ) AcquireQuantumMemory ( iris_info . rows , iris_info . depth * sizeof ( * runlength ) ) ; packet_info = AcquireVirtualMemory ( ( size_t ) iris_info . columns + 10UL , 4UL * sizeof ( * packets ) ) ; if ( ( offsets == ( ssize_t * ) NULL ) || ( runlength == ( size_t * ) NULL ) || ( packet_info == ( MemoryInfo * ) NULL ) ) { if ( offsets == ( ssize_t * ) NULL ) offsets = ( ssize_t * ) RelinquishMagickMemory ( offsets ) ; if ( runlength == ( size_t * ) NULL ) runlength = ( size_t * ) RelinquishMagickMemory ( runlength ) ; if ( packet_info == ( MemoryInfo * ) NULL ) packet_info = RelinquishVirtualMemory ( packet_info ) ; ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } packets = ( unsigned char * ) GetVirtualMemoryBlob ( packet_info ) ; for ( i = 0 ; i < ( ssize_t ) ( iris_info . rows * iris_info . depth ) ; i ++ ) offsets [ i ] = ( ssize_t ) ReadBlobMSBSignedLong ( image ) ; for ( i = 0 ; i < ( ssize_t ) ( iris_info . rows * iris_info . depth ) ; i ++ ) { runlength [ i ] = ReadBlobMSBLong ( image ) ; if ( runlength [ i ] > ( 4 * ( size_t ) iris_info . columns + 10 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } offset = 0 ; data_order = 0 ; for ( y = 0 ; ( ( y < ( ssize_t ) iris_info . rows ) && ( data_order == 0 ) ) ; y ++ ) for ( z = 0 ; ( ( z < ( ssize_t ) iris_info . depth ) && ( data_order == 0 ) ) ; z ++ ) { if ( offsets [ y + z * iris_info . rows ] < offset ) data_order = 1 ; offset = offsets [ y + z * iris_info . rows ] ; } offset = ( ssize_t ) TellBlob ( image ) ; if ( data_order == 1 ) { for ( z = 0 ; z < ( ssize_t ) iris_info . depth ; z ++ ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) iris_info . rows ; y ++ ) { if ( offset != offsets [ y + z * iris_info . rows ] ) { offset = offsets [ y + z * iris_info . rows ] ; offset = ( ssize_t ) SeekBlob ( image , ( MagickOffsetType ) offset , SEEK_SET ) ; } count = ReadBlob ( image , ( size_t ) runlength [ y + z * iris_info . rows ] , packets ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; offset += ( ssize_t ) runlength [ y + z * iris_info . rows ] ; status = SGIDecode ( bytes_per_pixel , ( ssize_t ) ( runlength [ y + z * iris_info . rows ] / bytes_per_pixel ) , packets , ( ssize_t ) iris_info . columns , p + bytes_per_pixel * z ) ; if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; p += ( iris_info . columns * 4 * bytes_per_pixel ) ; } } } else { MagickOffsetType position ; position = TellBlob ( image ) ; p = pixels ; for ( y = 0 ; y < ( ssize_t ) iris_info . rows ; y ++ ) { for ( z = 0 ; z < ( ssize_t ) iris_info . depth ; z ++ ) { if ( offset != offsets [ y + z * iris_info . rows ] ) { offset = offsets [ y + z * iris_info . rows ] ; offset = ( ssize_t ) SeekBlob ( image , ( MagickOffsetType ) offset , SEEK_SET ) ; } count = ReadBlob ( image , ( size_t ) runlength [ y + z * iris_info . rows ] , packets ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; offset += ( ssize_t ) runlength [ y + z * iris_info . rows ] ; status = SGIDecode ( bytes_per_pixel , ( ssize_t ) ( runlength [ y + z * iris_info . rows ] / bytes_per_pixel ) , packets , ( ssize_t ) iris_info . columns , p + bytes_per_pixel * z ) ; if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } p += ( iris_info . columns * 4 * bytes_per_pixel ) ; } offset = ( ssize_t ) SeekBlob ( image , position , SEEK_SET ) ; } packet_info = RelinquishVirtualMemory ( packet_info ) ; runlength = ( size_t * ) RelinquishMagickMemory ( runlength ) ; offsets = ( ssize_t * ) RelinquishMagickMemory ( offsets ) ; } image -> alpha_trait = iris_info . depth == 4 ? BlendPixelTrait : UndefinedPixelTrait ; image -> columns = iris_info . columns ; image -> rows = iris_info . rows ; if ( image -> storage_class == DirectClass ) { if ( bytes_per_pixel == 2 ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 8 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 0 ) << 8 ) | ( * ( p + 1 ) ) ) ) , q ) ; SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 2 ) << 8 ) | ( * ( p + 3 ) ) ) ) , q ) ; SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 4 ) << 8 ) | ( * ( p + 5 ) ) ) ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 6 ) << 8 ) | ( * ( p + 7 ) ) ) ) , q ) ; p += 8 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 4 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * ( p + 1 ) ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * ( p + 2 ) ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * ( p + 3 ) ) , q ) ; p += 4 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( bytes_per_pixel == 2 ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 8 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { quantum = ( * p << 8 ) ; quantum |= ( * ( p + 1 ) ) ; SetPixelIndex ( image , ( Quantum ) quantum , q ) ; p += 8 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 4 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p , q ) ; p += 4 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; } pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; iris_info . magic = ReadBlobMSBShort ( image ) ; if ( iris_info . magic == 0x01DA ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( iris_info . magic == 0x01DA ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> ReadBlobMSBShort ( image ) ; if ( ( iris_info . dimension == 0 ) || ( iris_info . dimension > 3 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader""
"
510,"CWE-125 void pgm_print ( netdissect_options * ndo , register const u_char * bp , register u_int length , register const u_char * bp2 ) { register const struct pgm_header * pgm ; register const struct ip * ip ; register char ch ; uint16_t sport , dport ; u_int nla_afnum ; char nla_buf [ INET6_ADDRSTRLEN ] ; register const struct ip6_hdr * ip6 ; uint8_t opt_type , opt_len ; uint32_t seq , opts_len , len , offset ; pgm = ( const struct pgm_header * ) bp ; ip = ( const struct ip * ) bp2 ; if ( IP_V ( ip ) == 6 ) ip6 = ( const struct ip6_hdr * ) bp2 ; else ip6 = NULL ; ch = '\\0' ; if ( ! ND_TTEST ( pgm -> pgm_dport ) ) { if ( ip6 ) { ND_PRINT ( ( ndo , ""%s<S2SV_blank>><S2SV_blank>%s:<S2SV_blank>[|pgm]"" , ip6addr_string ( ndo , & ip6 -> ip6_src ) , ip6addr_string ( ndo , & ip6 -> ip6_dst ) ) ) ; <S2SV_StartBug> return ; <S2SV_EndBug> } else { ND_PRINT ( ( ndo , ""%s<S2SV_blank>><S2SV_blank>%s:<S2SV_blank>[|pgm]"" , ipaddr_string ( ndo , & ip -> ip_src ) , ipaddr_string ( ndo , & ip -> ip_dst ) ) ) ; <S2SV_StartBug> return ; <S2SV_EndBug> } } sport = EXTRACT_16BITS ( & pgm -> pgm_sport ) ; dport = EXTRACT_16BITS ( & pgm -> pgm_dport ) ; if ( ip6 ) { if ( ip6 -> ip6_nxt == IPPROTO_PGM ) { ND_PRINT ( ( ndo , ""%s.%s<S2SV_blank>><S2SV_blank>%s.%s:<S2SV_blank>"" , ip6addr_string ( ndo , & ip6 -> ip6_src ) , tcpport_string ( ndo , sport ) , ip6addr_string ( ndo , & ip6 -> ip6_dst ) , tcpport_string ( ndo , dport ) ) ) ; } else { ND_PRINT ( ( ndo , ""%s<S2SV_blank>><S2SV_blank>%s:<S2SV_blank>"" , tcpport_string ( ndo , sport ) , tcpport_string ( ndo , dport ) ) ) ; } } else { if ( ip -> ip_p == IPPROTO_PGM ) { ND_PRINT ( ( ndo , ""%s.%s<S2SV_blank>><S2SV_blank>%s.%s:<S2SV_blank>"" , ipaddr_string ( ndo , & ip -> ip_src ) , tcpport_string ( ndo , sport ) , ipaddr_string ( ndo , & ip -> ip_dst ) , tcpport_string ( ndo , dport ) ) ) ; } else { ND_PRINT ( ( ndo , ""%s<S2SV_blank>><S2SV_blank>%s:<S2SV_blank>"" , tcpport_string ( ndo , sport ) , tcpport_string ( ndo , dport ) ) ) ; } } ND_TCHECK ( * pgm ) ; ND_PRINT ( ( ndo , ""PGM,<S2SV_blank>length<S2SV_blank>%u"" , EXTRACT_16BITS ( & pgm -> pgm_length ) ) ) ; if ( ! ndo -> ndo_vflag ) return ; ND_PRINT ( ( ndo , ""<S2SV_blank>0x%02x%02x%02x%02x%02x%02x<S2SV_blank>"" , pgm -> pgm_gsid [ 0 ] , pgm -> pgm_gsid [ 1 ] , pgm -> pgm_gsid [ 2 ] , pgm -> pgm_gsid [ 3 ] , pgm -> pgm_gsid [ 4 ] , pgm -> pgm_gsid [ 5 ] ) ) ; switch ( pgm -> pgm_type ) { case PGM_SPM : { const struct pgm_spm * spm ; spm = ( const struct pgm_spm * ) ( pgm + 1 ) ; ND_TCHECK ( * spm ) ; bp = ( const u_char * ) ( spm + 1 ) ; switch ( EXTRACT_16BITS ( & spm -> pgms_nla_afi ) ) { case AFNUM_INET : ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } ND_PRINT ( ( ndo , ""SPM<S2SV_blank>seq<S2SV_blank>%u<S2SV_blank>trail<S2SV_blank>%u<S2SV_blank>lead<S2SV_blank>%u<S2SV_blank>nla<S2SV_blank>%s"" , EXTRACT_32BITS ( & spm -> pgms_seq ) , EXTRACT_32BITS ( & spm -> pgms_trailseq ) , EXTRACT_32BITS ( & spm -> pgms_leadseq ) , nla_buf ) ) ; break ; } case PGM_POLL : { const struct pgm_poll * poll_msg ; poll_msg = ( const struct pgm_poll * ) ( pgm + 1 ) ; ND_TCHECK ( * poll_msg ) ; ND_PRINT ( ( ndo , ""POLL<S2SV_blank>seq<S2SV_blank>%u<S2SV_blank>round<S2SV_blank>%u"" , EXTRACT_32BITS ( & poll_msg -> pgmp_seq ) , EXTRACT_16BITS ( & poll_msg -> pgmp_round ) ) ) ; bp = ( const u_char * ) ( poll_msg + 1 ) ; break ; } case PGM_POLR : { const struct pgm_polr * polr ; uint32_t ivl , rnd , mask ; polr = ( const struct pgm_polr * ) ( pgm + 1 ) ; ND_TCHECK ( * polr ) ; bp = ( const u_char * ) ( polr + 1 ) ; switch ( EXTRACT_16BITS ( & polr -> pgmp_nla_afi ) ) { case AFNUM_INET : ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } ND_TCHECK2 ( * bp , sizeof ( uint32_t ) ) ; ivl = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_TCHECK2 ( * bp , sizeof ( uint32_t ) ) ; rnd = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_TCHECK2 ( * bp , sizeof ( uint32_t ) ) ; mask = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_PRINT ( ( ndo , ""POLR<S2SV_blank>seq<S2SV_blank>%u<S2SV_blank>round<S2SV_blank>%u<S2SV_blank>nla<S2SV_blank>%s<S2SV_blank>ivl<S2SV_blank>%u<S2SV_blank>rnd<S2SV_blank>0x%08x<S2SV_blank>"" ""mask<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( & polr -> pgmp_seq ) , EXTRACT_16BITS ( & polr -> pgmp_round ) , nla_buf , ivl , rnd , mask ) ) ; break ; } case PGM_ODATA : { const struct pgm_data * odata ; odata = ( const struct pgm_data * ) ( pgm + 1 ) ; ND_TCHECK ( * odata ) ; ND_PRINT ( ( ndo , ""ODATA<S2SV_blank>trail<S2SV_blank>%u<S2SV_blank>seq<S2SV_blank>%u"" , EXTRACT_32BITS ( & odata -> pgmd_trailseq ) , EXTRACT_32BITS ( & odata -> pgmd_seq ) ) ) ; bp = ( const u_char * ) ( odata + 1 ) ; break ; } case PGM_RDATA : { const struct pgm_data * rdata ; rdata = ( const struct pgm_data * ) ( pgm + 1 ) ; ND_TCHECK ( * rdata ) ; ND_PRINT ( ( ndo , ""RDATA<S2SV_blank>trail<S2SV_blank>%u<S2SV_blank>seq<S2SV_blank>%u"" , EXTRACT_32BITS ( & rdata -> pgmd_trailseq ) , EXTRACT_32BITS ( & rdata -> pgmd_seq ) ) ) ; bp = ( const u_char * ) ( rdata + 1 ) ; break ; } case PGM_NAK : case PGM_NULLNAK : case PGM_NCF : { const struct pgm_nak * nak ; char source_buf [ INET6_ADDRSTRLEN ] , group_buf [ INET6_ADDRSTRLEN ] ; nak = ( const struct pgm_nak * ) ( pgm + 1 ) ; ND_TCHECK ( * nak ) ; bp = ( const u_char * ) ( nak + 1 ) ; switch ( EXTRACT_16BITS ( & nak -> pgmn_source_afi ) ) { case AFNUM_INET : ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , source_buf , sizeof ( source_buf ) ) ; bp += sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , source_buf , sizeof ( source_buf ) ) ; bp += sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } bp += ( 2 * sizeof ( uint16_t ) ) ; <S2SV_StartBug> switch ( EXTRACT_16BITS ( bp ) ) { <S2SV_EndBug> case AFNUM_INET : ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , group_buf , sizeof ( group_buf ) ) ; bp += sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , group_buf , sizeof ( group_buf ) ) ; bp += sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } switch ( pgm -> pgm_type ) { case PGM_NAK : ND_PRINT ( ( ndo , ""NAK<S2SV_blank>"" ) ) ; break ; case PGM_NULLNAK : ND_PRINT ( ( ndo , ""NNAK<S2SV_blank>"" ) ) ; break ; case PGM_NCF : ND_PRINT ( ( ndo , ""NCF<S2SV_blank>"" ) ) ; break ; default : break ; } ND_PRINT ( ( ndo , ""(%s<S2SV_blank>-><S2SV_blank>%s),<S2SV_blank>seq<S2SV_blank>%u"" , source_buf , group_buf , EXTRACT_32BITS ( & nak -> pgmn_seq ) ) ) ; break ; } case PGM_ACK : { const struct pgm_ack * ack ; ack = ( const struct pgm_ack * ) ( pgm + 1 ) ; ND_TCHECK ( * ack ) ; ND_PRINT ( ( ndo , ""ACK<S2SV_blank>seq<S2SV_blank>%u"" , EXTRACT_32BITS ( & ack -> pgma_rx_max_seq ) ) ) ; bp = ( const u_char * ) ( ack + 1 ) ; break ; } case PGM_SPMR : ND_PRINT ( ( ndo , ""SPMR"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""UNKNOWN<S2SV_blank>type<S2SV_blank>0x%02x"" , pgm -> pgm_type ) ) ; break ; } if ( pgm -> pgm_options & PGM_OPT_BIT_PRESENT ) { if ( ! ND_TTEST2 ( * bp , PGM_MIN_OPT_LEN ) ) { ND_PRINT ( ( ndo , ""[|OPT]"" ) ) ; return ; } opt_type = * bp ++ ; if ( ( opt_type & PGM_OPT_MASK ) != PGM_OPT_LENGTH ) { ND_PRINT ( ( ndo , ""[First<S2SV_blank>option<S2SV_blank>bad,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>PGM_OPT_LENGTH,<S2SV_blank>is<S2SV_blank>%u]"" , opt_type & PGM_OPT_MASK ) ) ; return ; } opt_len = * bp ++ ; if ( opt_len != 4 ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_LENGTH<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>4]"" , opt_len ) ) ; return ; } opts_len = EXTRACT_16BITS ( bp ) ; if ( opts_len < 4 ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>total<S2SV_blank>option<S2SV_blank>length<S2SV_blank>%u<S2SV_blank><<S2SV_blank>4]"" , opts_len ) ) ; return ; } bp += sizeof ( uint16_t ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>OPTS<S2SV_blank>LEN<S2SV_blank>%d"" , opts_len ) ) ; opts_len -= 4 ; while ( opts_len ) { if ( opts_len < PGM_MIN_OPT_LEN ) { ND_PRINT ( ( ndo , ""[Total<S2SV_blank>option<S2SV_blank>length<S2SV_blank>leaves<S2SV_blank>no<S2SV_blank>room<S2SV_blank>for<S2SV_blank>final<S2SV_blank>option]"" ) ) ; return ; } if ( ! ND_TTEST2 ( * bp , 2 ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[|OPT]"" ) ) ; return ; } opt_type = * bp ++ ; opt_len = * bp ++ ; if ( opt_len < PGM_MIN_OPT_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%u]"" , opt_len , PGM_MIN_OPT_LEN ) ) ; break ; } if ( opts_len < opt_len ) { ND_PRINT ( ( ndo , ""[Total<S2SV_blank>option<S2SV_blank>length<S2SV_blank>leaves<S2SV_blank>no<S2SV_blank>room<S2SV_blank>for<S2SV_blank>final<S2SV_blank>option]"" ) ) ; return ; } if ( ! ND_TTEST2 ( * bp , opt_len - 2 ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[|OPT]"" ) ) ; return ; } switch ( opt_type & PGM_OPT_MASK ) { case PGM_OPT_LENGTH : # define PGM_OPT_LENGTH_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_LENGTH_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_LENGTH<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_LENGTH_LEN ) ) ; return ; } ND_PRINT ( ( ndo , ""<S2SV_blank>OPTS<S2SV_blank>LEN<S2SV_blank>(extra?)<S2SV_blank>%d"" , EXTRACT_16BITS ( bp ) ) ) ; bp += 2 ; opts_len -= PGM_OPT_LENGTH_LEN ; break ; case PGM_OPT_FRAGMENT : # define PGM_OPT_FRAGMENT_LEN ( 2 + 2 + 4 + 4 + 4 ) if ( opt_len != PGM_OPT_FRAGMENT_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_FRAGMENT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_FRAGMENT_LEN ) ) ; return ; } bp += 2 ; seq = EXTRACT_32BITS ( bp ) ; bp += 4 ; offset = EXTRACT_32BITS ( bp ) ; bp += 4 ; len = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>FRAG<S2SV_blank>seq<S2SV_blank>%u<S2SV_blank>off<S2SV_blank>%u<S2SV_blank>len<S2SV_blank>%u"" , seq , offset , len ) ) ; opts_len -= PGM_OPT_FRAGMENT_LEN ; break ; case PGM_OPT_NAK_LIST : bp += 2 ; opt_len -= 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>NAK<S2SV_blank>LIST"" ) ) ; while ( opt_len ) { if ( opt_len < 4 ) { ND_PRINT ( ( ndo , ""[Option<S2SV_blank>length<S2SV_blank>not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4]"" ) ) ; return ; } ND_TCHECK2 ( * bp , 4 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u"" , EXTRACT_32BITS ( bp ) ) ) ; bp += 4 ; opt_len -= 4 ; opts_len -= 4 ; } break ; case PGM_OPT_JOIN : # define PGM_OPT_JOIN_LEN ( 2 + 2 + 4 ) if ( opt_len != PGM_OPT_JOIN_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_JOIN<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_JOIN_LEN ) ) ; return ; } bp += 2 ; seq = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>JOIN<S2SV_blank>%u"" , seq ) ) ; opts_len -= PGM_OPT_JOIN_LEN ; break ; case PGM_OPT_NAK_BO_IVL : # define PGM_OPT_NAK_BO_IVL_LEN ( 2 + 2 + 4 + 4 ) if ( opt_len != PGM_OPT_NAK_BO_IVL_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_NAK_BO_IVL<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_NAK_BO_IVL_LEN ) ) ; return ; } bp += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += 4 ; seq = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>BACKOFF<S2SV_blank>ivl<S2SV_blank>%u<S2SV_blank>ivlseq<S2SV_blank>%u"" , offset , seq ) ) ; opts_len -= PGM_OPT_NAK_BO_IVL_LEN ; break ; case PGM_OPT_NAK_BO_RNG : # define PGM_OPT_NAK_BO_RNG_LEN ( 2 + 2 + 4 + 4 ) if ( opt_len != PGM_OPT_NAK_BO_RNG_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_NAK_BO_RNG<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_NAK_BO_RNG_LEN ) ) ; return ; } bp += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += 4 ; seq = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>BACKOFF<S2SV_blank>max<S2SV_blank>%u<S2SV_blank>min<S2SV_blank>%u"" , offset , seq ) ) ; opts_len -= PGM_OPT_NAK_BO_RNG_LEN ; break ; case PGM_OPT_REDIRECT : # define PGM_OPT_REDIRECT_FIXED_LEN ( 2 + 2 + 2 + 2 ) if ( opt_len < PGM_OPT_REDIRECT_FIXED_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_REDIRECT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%u]"" , opt_len , PGM_OPT_REDIRECT_FIXED_LEN ) ) ; return ; } bp += 2 ; nla_afnum = EXTRACT_16BITS ( bp ) ; bp += 2 + 2 ; switch ( nla_afnum ) { case AFNUM_INET : if ( opt_len != PGM_OPT_REDIRECT_FIXED_LEN + sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_REDIRECT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len , PGM_OPT_REDIRECT_FIXED_LEN ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; opts_len -= PGM_OPT_REDIRECT_FIXED_LEN + sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : if ( opt_len != PGM_OPT_REDIRECT_FIXED_LEN + sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_REDIRECT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , PGM_OPT_REDIRECT_FIXED_LEN , opt_len ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; opts_len -= PGM_OPT_REDIRECT_FIXED_LEN + sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } ND_PRINT ( ( ndo , ""<S2SV_blank>REDIRECT<S2SV_blank>%s"" , nla_buf ) ) ; break ; case PGM_OPT_PARITY_PRM : # define PGM_OPT_PARITY_PRM_LEN ( 2 + 2 + 4 ) if ( opt_len != PGM_OPT_PARITY_PRM_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PARITY_PRM<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_PARITY_PRM_LEN ) ) ; return ; } bp += 2 ; len = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>PARITY<S2SV_blank>MAXTGS<S2SV_blank>%u"" , len ) ) ; opts_len -= PGM_OPT_PARITY_PRM_LEN ; break ; case PGM_OPT_PARITY_GRP : # define PGM_OPT_PARITY_GRP_LEN ( 2 + 2 + 4 ) if ( opt_len != PGM_OPT_PARITY_GRP_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PARITY_GRP<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_PARITY_GRP_LEN ) ) ; return ; } bp += 2 ; seq = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>PARITY<S2SV_blank>GROUP<S2SV_blank>%u"" , seq ) ) ; opts_len -= PGM_OPT_PARITY_GRP_LEN ; break ; case PGM_OPT_CURR_TGSIZE : # define PGM_OPT_CURR_TGSIZE_LEN ( 2 + 2 + 4 ) if ( opt_len != PGM_OPT_CURR_TGSIZE_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_CURR_TGSIZE<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_CURR_TGSIZE_LEN ) ) ; return ; } bp += 2 ; len = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>PARITY<S2SV_blank>ATGS<S2SV_blank>%u"" , len ) ) ; opts_len -= PGM_OPT_CURR_TGSIZE_LEN ; break ; case PGM_OPT_NBR_UNREACH : # define PGM_OPT_NBR_UNREACH_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_NBR_UNREACH_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_NBR_UNREACH<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_NBR_UNREACH_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>NBR_UNREACH"" ) ) ; opts_len -= PGM_OPT_NBR_UNREACH_LEN ; break ; case PGM_OPT_PATH_NLA : ND_PRINT ( ( ndo , ""<S2SV_blank>PATH_NLA<S2SV_blank>[%d]"" , opt_len ) ) ; bp += opt_len ; opts_len -= opt_len ; break ; case PGM_OPT_SYN : # define PGM_OPT_SYN_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_SYN_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_SYN<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_SYN_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>SYN"" ) ) ; opts_len -= PGM_OPT_SYN_LEN ; break ; case PGM_OPT_FIN : # define PGM_OPT_FIN_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_FIN_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_FIN<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_FIN_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>FIN"" ) ) ; opts_len -= PGM_OPT_FIN_LEN ; break ; case PGM_OPT_RST : # define PGM_OPT_RST_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_RST_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_RST<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_RST_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>RST"" ) ) ; opts_len -= PGM_OPT_RST_LEN ; break ; case PGM_OPT_CR : ND_PRINT ( ( ndo , ""<S2SV_blank>CR"" ) ) ; bp += opt_len ; opts_len -= opt_len ; break ; case PGM_OPT_CRQST : # define PGM_OPT_CRQST_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_CRQST_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_CRQST<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_CRQST_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>CRQST"" ) ) ; opts_len -= PGM_OPT_CRQST_LEN ; break ; case PGM_OPT_PGMCC_DATA : # define PGM_OPT_PGMCC_DATA_FIXED_LEN ( 2 + 2 + 4 + 2 + 2 ) if ( opt_len < PGM_OPT_PGMCC_DATA_FIXED_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PGMCC_DATA<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%u]"" , opt_len , PGM_OPT_PGMCC_DATA_FIXED_LEN ) ) ; return ; } bp += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += 4 ; nla_afnum = EXTRACT_16BITS ( bp ) ; bp += 2 + 2 ; switch ( nla_afnum ) { case AFNUM_INET : if ( opt_len != PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PGMCC_DATA<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len , PGM_OPT_PGMCC_DATA_FIXED_LEN ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; opts_len -= PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : if ( opt_len != PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PGMCC_DATA<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len , PGM_OPT_PGMCC_DATA_FIXED_LEN ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; opts_len -= PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } ND_PRINT ( ( ndo , ""<S2SV_blank>PGMCC<S2SV_blank>DATA<S2SV_blank>%u<S2SV_blank>%s"" , offset , nla_buf ) ) ; break ; case PGM_OPT_PGMCC_FEEDBACK : # define PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN ( 2 + 2 + 4 + 2 + 2 ) if ( opt_len < PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>PGM_OPT_PGMCC_FEEDBACK<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%u]"" , opt_len , PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN ) ) ; return ; } bp += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += 4 ; nla_afnum = EXTRACT_16BITS ( bp ) ; bp += 2 + 2 ; switch ( nla_afnum ) { case AFNUM_INET : if ( opt_len != PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PGMCC_FEEDBACK<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len , PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; opts_len -= PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : if ( opt_len != PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PGMCC_FEEDBACK<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len , PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; opts_len -= PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } ND_PRINT ( ( ndo , ""<S2SV_blank>PGMCC<S2SV_blank>FEEDBACK<S2SV_blank>%u<S2SV_blank>%s"" , offset , nla_buf ) ) ; break ; default : ND_PRINT ( ( ndo , ""<S2SV_blank>OPT_%02X<S2SV_blank>[%d]<S2SV_blank>"" , opt_type , opt_len ) ) ; bp += opt_len ; opts_len -= opt_len ; break ; } if ( opt_type & PGM_OPT_END ) break ; } } ND_PRINT ( ( ndo , ""<S2SV_blank>[%u]"" , length ) ) ; if ( ndo -> ndo_packettype == PT_PGM_ZMTP1 && ( pgm -> pgm_type == PGM_ODATA || pgm -> pgm_type == PGM_RDATA ) ) zmtp1_print_datagram ( ndo , bp , EXTRACT_16BITS ( & pgm -> pgm_length ) ) ; return ; trunc : ND_PRINT ( ( ndo , ""[|pgm]"" ) ) ; if ( ch != '\\0' ) ND_PRINT ( ( ndo , "">"" ) ) ; }
","<S2SV_ModStart> ) ) ; <S2SV_ModEnd> } else { <S2SV_ModStart> ) ) ; } return ; <S2SV_ModEnd> } sport = <S2SV_ModStart> ) ) ; ND_TCHECK_16BITS ( bp ) ;
"
511,"CWE-20 static int cma_req_handler ( struct ib_cm_id * cm_id , struct ib_cm_event * ib_event ) { struct rdma_id_private * listen_id , * conn_id ; struct rdma_cm_event event ; int offset , ret ; <S2SV_StartBug> u8 smac [ ETH_ALEN ] ; <S2SV_EndBug> u8 alt_smac [ ETH_ALEN ] ; u8 * psmac = smac ; u8 * palt_smac = alt_smac ; int is_iboe = ( ( rdma_node_get_transport ( cm_id -> device -> node_type ) == RDMA_TRANSPORT_IB ) && ( rdma_port_get_link_layer ( cm_id -> device , ib_event -> param . req_rcvd . port ) == IB_LINK_LAYER_ETHERNET ) ) ; listen_id = cm_id -> context ; if ( ! cma_check_req_qp_type ( & listen_id -> id , ib_event ) ) return - EINVAL ; if ( cma_disable_callback ( listen_id , RDMA_CM_LISTEN ) ) return - ECONNABORTED ; memset ( & event , 0 , sizeof event ) ; offset = cma_user_data_offset ( listen_id ) ; event . event = RDMA_CM_EVENT_CONNECT_REQUEST ; if ( ib_event -> event == IB_CM_SIDR_REQ_RECEIVED ) { conn_id = cma_new_udp_id ( & listen_id -> id , ib_event ) ; event . param . ud . private_data = ib_event -> private_data + offset ; event . param . ud . private_data_len = IB_CM_SIDR_REQ_PRIVATE_DATA_SIZE - offset ; } else { conn_id = cma_new_conn_id ( & listen_id -> id , ib_event ) ; cma_set_req_event_data ( & event , & ib_event -> param . req_rcvd , ib_event -> private_data , offset ) ; } if ( ! conn_id ) { ret = - ENOMEM ; goto err1 ; } mutex_lock_nested ( & conn_id -> handler_mutex , SINGLE_DEPTH_NESTING ) ; ret = cma_acquire_dev ( conn_id , listen_id ) ; if ( ret ) goto err2 ; conn_id -> cm_id . ib = cm_id ; cm_id -> context = conn_id ; cm_id -> cm_handler = cma_ib_handler ; atomic_inc ( & conn_id -> refcount ) ; ret = conn_id -> id . event_handler ( & conn_id -> id , & event ) ; if ( ret ) goto err3 ; <S2SV_StartBug> if ( is_iboe ) { <S2SV_EndBug> if ( ib_event -> param . req_rcvd . primary_path != NULL ) rdma_addr_find_smac_by_sgid ( & ib_event -> param . req_rcvd . primary_path -> sgid , psmac , NULL ) ; else psmac = NULL ; if ( ib_event -> param . req_rcvd . alternate_path != NULL ) rdma_addr_find_smac_by_sgid ( & ib_event -> param . req_rcvd . alternate_path -> sgid , palt_smac , NULL ) ; else palt_smac = NULL ; } <S2SV_StartBug> mutex_lock ( & lock ) ; <S2SV_EndBug> if ( is_iboe ) ib_update_cm_av ( cm_id , psmac , palt_smac ) ; if ( cma_comp ( conn_id , RDMA_CM_CONNECT ) && ( conn_id -> id . qp_type != IB_QPT_UD ) ) ib_send_cm_mra ( cm_id , CMA_CM_MRA_SETTING , NULL , 0 ) ; mutex_unlock ( & lock ) ; mutex_unlock ( & conn_id -> handler_mutex ) ; mutex_unlock ( & listen_id -> handler_mutex ) ; cma_deref_id ( conn_id ) ; return 0 ; err3 : cma_deref_id ( conn_id ) ; conn_id -> cm_id . ib = NULL ; err2 : cma_exch ( conn_id , RDMA_CM_DESTROYING ) ; mutex_unlock ( & conn_id -> handler_mutex ) ; err1 : mutex_unlock ( & listen_id -> handler_mutex ) ; if ( conn_id ) rdma_destroy_id ( & conn_id -> id ) ; return ret ; }
","<S2SV_ModStart> , ret ; <S2SV_ModEnd> listen_id = cm_id <S2SV_ModStart> goto err3 ; <S2SV_ModEnd> mutex_lock ( & <S2SV_ModStart> ( & lock <S2SV_ModEnd> ) ; if
"
512,"CWE-200 int vcc_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct atm_vcc * vcc ; struct sk_buff * skb ; <S2SV_StartBug> int copied , error = - EINVAL ; <S2SV_EndBug> if ( sock -> state != SS_CONNECTED ) return - ENOTCONN ; if ( flags & ~ ( MSG_DONTWAIT | MSG_PEEK ) ) return - EOPNOTSUPP ; vcc = ATM_SD ( sock ) ; if ( test_bit ( ATM_VF_RELEASED , & vcc -> flags ) || test_bit ( ATM_VF_CLOSE , & vcc -> flags ) || ! test_bit ( ATM_VF_READY , & vcc -> flags ) ) return 0 ; skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & error ) ; if ( ! skb ) return error ; copied = skb -> len ; if ( copied > size ) { copied = size ; msg -> msg_flags |= MSG_TRUNC ; } error = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( error ) return error ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( ! ( flags & MSG_PEEK ) ) { pr_debug ( ""%d<S2SV_blank>-=<S2SV_blank>%d\\n"" , atomic_read ( & sk -> sk_rmem_alloc ) , skb -> truesize ) ; atm_return ( vcc , skb -> truesize ) ; } skb_free_datagram ( sk , skb ) ; return copied ; }
","<S2SV_ModStart> = - EINVAL ; msg -> msg_namelen = 0
"
513,"CWE-000 static int orinoco_ioctl_set_auth ( struct net_device * dev , struct iw_request_info * info , union iwreq_data * wrqu , char * extra ) { struct orinoco_private * priv = ndev_priv ( dev ) ; hermes_t * hw = & priv -> hw ; struct iw_param * param = & wrqu -> param ; unsigned long flags ; int ret = - EINPROGRESS ; if ( orinoco_lock ( priv , & flags ) != 0 ) return - EBUSY ; switch ( param -> flags & IW_AUTH_INDEX ) { case IW_AUTH_WPA_VERSION : case IW_AUTH_CIPHER_PAIRWISE : case IW_AUTH_CIPHER_GROUP : case IW_AUTH_RX_UNENCRYPTED_EAPOL : case IW_AUTH_PRIVACY_INVOKED : case IW_AUTH_DROP_UNENCRYPTED : break ; case IW_AUTH_KEY_MGMT : priv -> key_mgmt = param -> value ; break ; case IW_AUTH_TKIP_COUNTERMEASURES : if ( param -> value ) { priv -> tkip_cm_active = 1 ; <S2SV_StartBug> ret = hermes_enable_port ( hw , 0 ) ; <S2SV_EndBug> } else { priv -> tkip_cm_active = 0 ; ret = hermes_disable_port ( hw , 0 ) ; } break ; case IW_AUTH_80211_AUTH_ALG : if ( param -> value & IW_AUTH_ALG_SHARED_KEY ) priv -> wep_restrict = 1 ; else if ( param -> value & IW_AUTH_ALG_OPEN_SYSTEM ) priv -> wep_restrict = 0 ; else ret = - EINVAL ; break ; case IW_AUTH_WPA_ENABLED : if ( priv -> has_wpa ) { priv -> wpa_enabled = param -> value ? 1 : 0 ; } else { if ( param -> value ) ret = - EOPNOTSUPP ; priv -> wpa_enabled = 0 ; } break ; default : ret = - EOPNOTSUPP ; } orinoco_unlock ( priv , & flags ) ; return ret ; }
","<S2SV_ModStart> ; ret = hermes_disable_port ( hw , 0 ) ; } else { priv -> tkip_cm_active = 0 ; ret = hermes_enable_port <S2SV_ModEnd> ( hw ,
"
514,"CWE-200 static int l2cap_sock_getname ( struct socket * sock , struct sockaddr * addr , int * len , int peer ) { struct sockaddr_l2 * la = ( struct sockaddr_l2 * ) addr ; struct sock * sk = sock -> sk ; struct l2cap_chan * chan = l2cap_pi ( sk ) -> chan ; <S2SV_StartBug> BT_DBG ( ""sock<S2SV_blank>%p,<S2SV_blank>sk<S2SV_blank>%p"" , sock , sk ) ; <S2SV_EndBug> addr -> sa_family = AF_BLUETOOTH ; * len = sizeof ( struct sockaddr_l2 ) ; if ( peer ) { la -> l2_psm = chan -> psm ; bacpy ( & la -> l2_bdaddr , & bt_sk ( sk ) -> dst ) ; la -> l2_cid = cpu_to_le16 ( chan -> dcid ) ; } else { la -> l2_psm = chan -> sport ; bacpy ( & la -> l2_bdaddr , & bt_sk ( sk ) -> src ) ; la -> l2_cid = cpu_to_le16 ( chan -> scid ) ; } return 0 ; }
","<S2SV_ModStart> sock , sk ) ; memset ( la , 0 , sizeof ( struct sockaddr_l2 )
"
515,"CWE-295 static krb5_error_code tgs_build_reply ( krb5_context context , krb5_kdc_configuration * config , KDC_REQ * req , KDC_REQ_BODY * b , hdb_entry_ex * krbtgt , krb5_enctype krbtgt_etype , const krb5_keyblock * replykey , int rk_is_subkey , krb5_ticket * ticket , krb5_data * reply , const char * from , const char * * e_text , AuthorizationData * * auth_data , const struct sockaddr * from_addr ) { krb5_error_code ret ; krb5_principal cp = NULL , sp = NULL , rsp = NULL , tp = NULL , dp = NULL ; krb5_principal krbtgt_out_principal = NULL ; char * spn = NULL , * cpn = NULL , * tpn = NULL , * dpn = NULL , * krbtgt_out_n = NULL ; hdb_entry_ex * server = NULL , * client = NULL , * s4u2self_impersonated_client = NULL ; HDB * clientdb , * s4u2self_impersonated_clientdb ; krb5_realm ref_realm = NULL ; EncTicketPart * tgt = & ticket -> ticket ; krb5_principals spp = NULL ; const EncryptionKey * ekey ; krb5_keyblock sessionkey ; krb5_kvno kvno ; <S2SV_StartBug> krb5_data rspac ; <S2SV_EndBug> const char * our_realm = krb5_principal_get_comp_string ( context , krbtgt -> entry . principal , 1 ) ; char * * capath = NULL ; size_t num_capath = 0 ; hdb_entry_ex * krbtgt_out = NULL ; METHOD_DATA enc_pa_data ; PrincipalName * s ; Realm r ; EncTicketPart adtkt ; char opt_str [ 128 ] ; int signedpath = 0 ; Key * tkey_check ; Key * tkey_sign ; int flags = HDB_F_FOR_TGS_REQ ; memset ( & sessionkey , 0 , sizeof ( sessionkey ) ) ; memset ( & adtkt , 0 , sizeof ( adtkt ) ) ; krb5_data_zero ( & rspac ) ; memset ( & enc_pa_data , 0 , sizeof ( enc_pa_data ) ) ; s = b -> sname ; r = b -> realm ; flags |= HDB_F_CANON ; if ( b -> kdc_options . enc_tkt_in_skey ) { Ticket * t ; hdb_entry_ex * uu ; krb5_principal p ; Key * uukey ; krb5uint32 second_kvno = 0 ; krb5uint32 * kvno_ptr = NULL ; if ( b -> additional_tickets == NULL || b -> additional_tickets -> len == 0 ) { ret = KRB5KDC_ERR_BADOPTION ; kdc_log ( context , config , 0 , ""No<S2SV_blank>second<S2SV_blank>ticket<S2SV_blank>present<S2SV_blank>in<S2SV_blank>request"" ) ; goto out ; } t = & b -> additional_tickets -> val [ 0 ] ; if ( ! get_krbtgt_realm ( & t -> sname ) ) { kdc_log ( context , config , 0 , ""Additional<S2SV_blank>ticket<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>ticket-granting<S2SV_blank>ticket"" ) ; ret = KRB5KDC_ERR_POLICY ; goto out ; } _krb5_principalname2krb5_principal ( context , & p , t -> sname , t -> realm ) ; if ( t -> enc_part . kvno ) { second_kvno = * t -> enc_part . kvno ; kvno_ptr = & second_kvno ; } ret = _kdc_db_fetch ( context , config , p , HDB_F_GET_KRBTGT , kvno_ptr , NULL , & uu ) ; krb5_free_principal ( context , p ) ; if ( ret ) { if ( ret == HDB_ERR_NOENTRY ) ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN ; goto out ; } ret = hdb_enctype2key ( context , & uu -> entry , NULL , t -> enc_part . etype , & uukey ) ; if ( ret ) { _kdc_free_ent ( context , uu ) ; ret = KRB5KDC_ERR_ETYPE_NOSUPP ; goto out ; } ret = krb5_decrypt_ticket ( context , t , & uukey -> key , & adtkt , 0 ) ; _kdc_free_ent ( context , uu ) ; if ( ret ) goto out ; ret = verify_flags ( context , config , & adtkt , spn ) ; if ( ret ) goto out ; s = & adtkt . cname ; r = adtkt . crealm ; } _krb5_principalname2krb5_principal ( context , & sp , * s , r ) ; ret = krb5_unparse_name ( context , sp , & spn ) ; if ( ret ) goto out ; _krb5_principalname2krb5_principal ( context , & cp , tgt -> cname , tgt -> crealm ) ; ret = krb5_unparse_name ( context , cp , & cpn ) ; if ( ret ) goto out ; unparse_flags ( KDCOptions2int ( b -> kdc_options ) , asn1_KDCOptions_units ( ) , opt_str , sizeof ( opt_str ) ) ; if ( * opt_str ) kdc_log ( context , config , 0 , ""TGS-REQ<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>[%s]"" , cpn , from , spn , opt_str ) ; else kdc_log ( context , config , 0 , ""TGS-REQ<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>%s"" , cpn , from , spn ) ; server_lookup : ret = _kdc_db_fetch ( context , config , sp , HDB_F_GET_SERVER | flags , NULL , NULL , & server ) ; if ( ret == HDB_ERR_NOT_FOUND_HERE ) { kdc_log ( context , config , 5 , ""target<S2SV_blank>%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>secrets<S2SV_blank>at<S2SV_blank>this<S2SV_blank>KDC,<S2SV_blank>need<S2SV_blank>to<S2SV_blank>proxy"" , sp ) ; goto out ; } else if ( ret == HDB_ERR_WRONG_REALM ) { free ( ref_realm ) ; ref_realm = strdup ( server -> entry . principal -> realm ) ; if ( ref_realm == NULL ) { ret = krb5_enomem ( context ) ; goto out ; } kdc_log ( context , config , 5 , ""Returning<S2SV_blank>a<S2SV_blank>referral<S2SV_blank>to<S2SV_blank>realm<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>"" ""server<S2SV_blank>%s."" , ref_realm , spn ) ; krb5_free_principal ( context , sp ) ; sp = NULL ; ret = krb5_make_principal ( context , & sp , r , KRB5_TGS_NAME , ref_realm , NULL ) ; if ( ret ) goto out ; free ( spn ) ; spn = NULL ; ret = krb5_unparse_name ( context , sp , & spn ) ; if ( ret ) goto out ; goto server_lookup ; } else if ( ret ) { const char * new_rlm , * msg ; Realm req_rlm ; krb5_realm * realms ; if ( ( req_rlm = get_krbtgt_realm ( & sp -> name ) ) != NULL ) { if ( capath == NULL ) { ret = _krb5_find_capath ( context , tgt -> crealm , our_realm , req_rlm , TRUE , & capath , & num_capath ) ; if ( ret ) goto out ; } new_rlm = num_capath > 0 ? capath [ -- num_capath ] : NULL ; if ( new_rlm ) { kdc_log ( context , config , 5 , ""krbtgt<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>via<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>"" ""realm<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>found,<S2SV_blank>trying<S2SV_blank>%s"" , tgt -> crealm , our_realm , req_rlm , new_rlm ) ; free ( ref_realm ) ; ref_realm = strdup ( new_rlm ) ; if ( ref_realm == NULL ) { ret = krb5_enomem ( context ) ; goto out ; } krb5_free_principal ( context , sp ) ; sp = NULL ; krb5_make_principal ( context , & sp , r , KRB5_TGS_NAME , ref_realm , NULL ) ; free ( spn ) ; spn = NULL ; ret = krb5_unparse_name ( context , sp , & spn ) ; if ( ret ) goto out ; goto server_lookup ; } } else if ( need_referral ( context , config , & b -> kdc_options , sp , & realms ) ) { if ( strcmp ( realms [ 0 ] , sp -> realm ) != 0 ) { kdc_log ( context , config , 5 , ""Returning<S2SV_blank>a<S2SV_blank>referral<S2SV_blank>to<S2SV_blank>realm<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>"" ""server<S2SV_blank>%s<S2SV_blank>that<S2SV_blank>was<S2SV_blank>not<S2SV_blank>found"" , realms [ 0 ] , spn ) ; krb5_free_principal ( context , sp ) ; sp = NULL ; krb5_make_principal ( context , & sp , r , KRB5_TGS_NAME , realms [ 0 ] , NULL ) ; free ( spn ) ; spn = NULL ; ret = krb5_unparse_name ( context , sp , & spn ) ; if ( ret ) { krb5_free_host_realm ( context , realms ) ; goto out ; } free ( ref_realm ) ; ref_realm = strdup ( realms [ 0 ] ) ; krb5_free_host_realm ( context , realms ) ; goto server_lookup ; } krb5_free_host_realm ( context , realms ) ; } msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 0 , ""Server<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>database:<S2SV_blank>%s:<S2SV_blank>%s"" , spn , msg ) ; krb5_free_error_message ( context , msg ) ; if ( ret == HDB_ERR_NOENTRY ) ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN ; goto out ; } if ( b -> kdc_options . canonicalize ) rsp = server -> entry . principal ; else rsp = sp ; { krb5_enctype etype ; if ( b -> kdc_options . enc_tkt_in_skey ) { size_t i ; ekey = & adtkt . key ; for ( i = 0 ; i < b -> etype . len ; i ++ ) if ( b -> etype . val [ i ] == adtkt . key . keytype ) break ; if ( i == b -> etype . len ) { kdc_log ( context , config , 0 , ""Addition<S2SV_blank>ticket<S2SV_blank>have<S2SV_blank>not<S2SV_blank>matching<S2SV_blank>etypes"" ) ; krb5_clear_error_message ( context ) ; ret = KRB5KDC_ERR_ETYPE_NOSUPP ; goto out ; } etype = b -> etype . val [ i ] ; kvno = 0 ; } else { Key * skey ; ret = _kdc_find_etype ( context , krb5_principal_is_krbtgt ( context , sp ) ? config -> tgt_use_strongest_session_key : config -> svc_use_strongest_session_key , FALSE , server , b -> etype . val , b -> etype . len , & etype , NULL ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Server<S2SV_blank>(%s)<S2SV_blank>has<S2SV_blank>no<S2SV_blank>support<S2SV_blank>for<S2SV_blank>etypes"" , spn ) ; goto out ; } ret = _kdc_get_preferred_key ( context , config , server , spn , NULL , & skey ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Server<S2SV_blank>(%s)<S2SV_blank>has<S2SV_blank>no<S2SV_blank>supported<S2SV_blank>etypes"" , spn ) ; goto out ; } ekey = & skey -> key ; kvno = server -> entry . kvno ; } ret = krb5_generate_random_keyblock ( context , etype , & sessionkey ) ; if ( ret ) goto out ; } ret = hdb_enctype2key ( context , & krbtgt -> entry , NULL , krbtgt_etype , & tkey_check ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>key<S2SV_blank>for<S2SV_blank>krbtgt<S2SV_blank>PAC<S2SV_blank>check"" ) ; goto out ; } ret = krb5_make_principal ( context , & krbtgt_out_principal , our_realm , KRB5_TGS_NAME , our_realm , NULL ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Failed<S2SV_blank>to<S2SV_blank>make<S2SV_blank>krbtgt<S2SV_blank>principal<S2SV_blank>name<S2SV_blank>object<S2SV_blank>for<S2SV_blank>"" ""authz-data<S2SV_blank>signatures"" ) ; goto out ; } ret = krb5_unparse_name ( context , krbtgt_out_principal , & krbtgt_out_n ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Failed<S2SV_blank>to<S2SV_blank>make<S2SV_blank>krbtgt<S2SV_blank>principal<S2SV_blank>name<S2SV_blank>object<S2SV_blank>for<S2SV_blank>"" ""authz-data<S2SV_blank>signatures"" ) ; goto out ; } ret = _kdc_db_fetch ( context , config , krbtgt_out_principal , HDB_F_GET_KRBTGT , NULL , NULL , & krbtgt_out ) ; if ( ret ) { char * ktpn = NULL ; ret = krb5_unparse_name ( context , krbtgt -> entry . principal , & ktpn ) ; kdc_log ( context , config , 0 , ""No<S2SV_blank>such<S2SV_blank>principal<S2SV_blank>%s<S2SV_blank>(needed<S2SV_blank>for<S2SV_blank>authz-data<S2SV_blank>signature<S2SV_blank>keys)<S2SV_blank>"" ""while<S2SV_blank>processing<S2SV_blank>TGS-REQ<S2SV_blank>for<S2SV_blank>service<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>krbtg<S2SV_blank>%s"" , krbtgt_out_n , spn , ( ret == 0 ) ? ktpn : ""<unknown>"" ) ; free ( ktpn ) ; ret = KRB5KRB_AP_ERR_NOT_US ; goto out ; } if ( strcmp ( krb5_principal_get_realm ( context , server -> entry . principal ) , krb5_principal_get_realm ( context , krbtgt_out -> entry . principal ) ) != 0 ) { char * ktpn ; ret = krb5_unparse_name ( context , krbtgt_out -> entry . principal , & ktpn ) ; kdc_log ( context , config , 0 , ""Request<S2SV_blank>with<S2SV_blank>wrong<S2SV_blank>krbtgt:<S2SV_blank>%s"" , ( ret == 0 ) ? ktpn : ""<unknown>"" ) ; if ( ret == 0 ) free ( ktpn ) ; ret = KRB5KRB_AP_ERR_NOT_US ; goto out ; } ret = _kdc_get_preferred_key ( context , config , krbtgt_out , krbtgt_out_n , NULL , & tkey_sign ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>key<S2SV_blank>for<S2SV_blank>krbtgt<S2SV_blank>PAC<S2SV_blank>signature"" ) ; goto out ; } ret = hdb_enctype2key ( context , & krbtgt_out -> entry , NULL , tkey_sign -> key . keytype , & tkey_sign ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>key<S2SV_blank>for<S2SV_blank>krbtgt<S2SV_blank>PAC<S2SV_blank>signature"" ) ; goto out ; } ret = _kdc_db_fetch ( context , config , cp , HDB_F_GET_CLIENT | flags , NULL , & clientdb , & client ) ; if ( ret == HDB_ERR_NOT_FOUND_HERE ) { } else if ( ret ) { const char * krbtgt_realm , * msg ; krbtgt_realm = krb5_principal_get_realm ( context , krbtgt_out -> entry . principal ) ; if ( strcmp ( krb5_principal_get_realm ( context , cp ) , krbtgt_realm ) == 0 ) { if ( ret == HDB_ERR_NOENTRY ) ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; kdc_log ( context , config , 1 , ""Client<S2SV_blank>no<S2SV_blank>longer<S2SV_blank>in<S2SV_blank>database:<S2SV_blank>%s"" , cpn ) ; goto out ; } msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 1 , ""Client<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>database:<S2SV_blank>%s"" , msg ) ; krb5_free_error_message ( context , msg ) ; } ret = check_PAC ( context , config , cp , NULL , client , server , krbtgt , & tkey_check -> key , ekey , & tkey_sign -> key , tgt , & rspac , & signedpath ) ; if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 0 , ""Verify<S2SV_blank>PAC<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>%s"" , spn , cpn , from , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } ret = check_KRB5SignedPath ( context , config , krbtgt , cp , tgt , & spp , & signedpath ) ; if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 0 , ""KRB5SignedPath<S2SV_blank>check<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>%s"" , spn , cpn , from , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } tp = cp ; tpn = cpn ; if ( client ) { const PA_DATA * sdata ; int i = 0 ; sdata = _kdc_find_padata ( req , & i , KRB5_PADATA_FOR_USER ) ; if ( sdata ) { krb5_crypto crypto ; krb5_data datack ; PA_S4U2Self self ; const char * str ; ret = decode_PA_S4U2Self ( sdata -> padata_value . data , sdata -> padata_value . length , & self , NULL ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>PA-S4U2Self"" ) ; goto out ; } ret = _krb5_s4u2self_to_checksumdata ( context , & self , & datack ) ; if ( ret ) goto out ; ret = krb5_crypto_init ( context , & tgt -> key , 0 , & crypto ) ; if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; free_PA_S4U2Self ( & self ) ; krb5_data_free ( & datack ) ; kdc_log ( context , config , 0 , ""krb5_crypto_init<S2SV_blank>failed:<S2SV_blank>%s"" , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } ret = krb5_verify_checksum ( context , crypto , KRB5_KU_OTHER_CKSUM , datack . data , datack . length , & self . cksum ) ; krb5_data_free ( & datack ) ; krb5_crypto_destroy ( context , crypto ) ; if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; free_PA_S4U2Self ( & self ) ; kdc_log ( context , config , 0 , ""krb5_verify_checksum<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>S4U2Self:<S2SV_blank>%s"" , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } ret = _krb5_principalname2krb5_principal ( context , & tp , self . name , self . realm ) ; free_PA_S4U2Self ( & self ) ; if ( ret ) goto out ; ret = krb5_unparse_name ( context , tp , & tpn ) ; if ( ret ) goto out ; if ( rspac . data ) { krb5_pac p = NULL ; krb5_data_free ( & rspac ) ; ret = _kdc_db_fetch ( context , config , tp , HDB_F_GET_CLIENT | flags , NULL , & s4u2self_impersonated_clientdb , & s4u2self_impersonated_client ) ; if ( ret ) { const char * msg ; if ( ret == HDB_ERR_NOENTRY ) ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 1 , ""S2U4Self<S2SV_blank>principal<S2SV_blank>to<S2SV_blank>impersonate<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>database:<S2SV_blank>%s"" , tpn , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } ret = _kdc_pac_generate ( context , s4u2self_impersonated_client , & p ) ; if ( ret ) { kdc_log ( context , config , 0 , ""PAC<S2SV_blank>generation<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>--<S2SV_blank>%s"" , tpn ) ; goto out ; } if ( p != NULL ) { ret = _krb5_pac_sign ( context , p , ticket -> ticket . authtime , s4u2self_impersonated_client -> entry . principal , ekey , & tkey_sign -> key , & rspac ) ; krb5_pac_free ( context , p ) ; if ( ret ) { kdc_log ( context , config , 0 , ""PAC<S2SV_blank>signing<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>--<S2SV_blank>%s"" , tpn ) ; goto out ; } } } ret = check_s4u2self ( context , config , clientdb , client , sp ) ; if ( ret ) { kdc_log ( context , config , 0 , ""S4U2Self:<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>"" ""to<S2SV_blank>impersonate<S2SV_blank>to<S2SV_blank>service<S2SV_blank>"" ""(tried<S2SV_blank>for<S2SV_blank>user<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>service<S2SV_blank>%s)"" , cpn , tpn , spn ) ; goto out ; } if ( client -> entry . flags . trusted_for_delegation ) { str = ""[forwardable]"" ; } else { b -> kdc_options . forwardable = 0 ; str = """" ; } kdc_log ( context , config , 0 , ""s4u2self<S2SV_blank>%s<S2SV_blank>impersonating<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>"" ""service<S2SV_blank>%s<S2SV_blank>%s"" , cpn , tpn , spn , str ) ; } } if ( client != NULL && b -> additional_tickets != NULL && b -> additional_tickets -> len != 0 && b -> kdc_options . enc_tkt_in_skey == 0 ) { int ad_signedpath = 0 ; Key * clientkey ; Ticket * t ; if ( ! signedpath ) { ret = KRB5KDC_ERR_BADOPTION ; kdc_log ( context , config , 0 , ""Constrained<S2SV_blank>delegation<S2SV_blank>done<S2SV_blank>on<S2SV_blank>service<S2SV_blank>ticket<S2SV_blank>%s/%s"" , cpn , spn ) ; goto out ; } t = & b -> additional_tickets -> val [ 0 ] ; ret = hdb_enctype2key ( context , & client -> entry , hdb_kvno2keys ( context , & client -> entry , t -> enc_part . kvno ? * t -> enc_part . kvno : 0 ) , t -> enc_part . etype , & clientkey ) ; if ( ret ) { ret = KRB5KDC_ERR_ETYPE_NOSUPP ; goto out ; } ret = krb5_decrypt_ticket ( context , t , & clientkey -> key , & adtkt , 0 ) ; if ( ret ) { kdc_log ( context , config , 0 , ""failed<S2SV_blank>to<S2SV_blank>decrypt<S2SV_blank>ticket<S2SV_blank>for<S2SV_blank>"" ""constrained<S2SV_blank>delegation<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>"" , cpn , spn ) ; goto out ; } ret = _krb5_principalname2krb5_principal ( context , & tp , adtkt . cname , adtkt . crealm ) ; if ( ret ) goto out ; ret = krb5_unparse_name ( context , tp , & tpn ) ; if ( ret ) goto out ; ret = _krb5_principalname2krb5_principal ( context , & dp , t -> sname , t -> realm ) ; if ( ret ) goto out ; ret = krb5_unparse_name ( context , dp , & dpn ) ; if ( ret ) goto out ; if ( adtkt . flags . forwardable == 0 ) { kdc_log ( context , config , 0 , ""Missing<S2SV_blank>forwardable<S2SV_blank>flag<S2SV_blank>on<S2SV_blank>ticket<S2SV_blank>for<S2SV_blank>"" ""constrained<S2SV_blank>delegation<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>as<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>"" , cpn , dpn , tpn , spn ) ; ret = KRB5KDC_ERR_BADOPTION ; goto out ; } ret = check_constrained_delegation ( context , config , clientdb , client , server , sp ) ; if ( ret ) { kdc_log ( context , config , 0 , ""constrained<S2SV_blank>delegation<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>as<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>allowed"" , cpn , dpn , tpn , spn ) ; goto out ; } ret = verify_flags ( context , config , & adtkt , tpn ) ; if ( ret ) { goto out ; } krb5_data_free ( & rspac ) ; ret = check_PAC ( context , config , tp , dp , client , server , krbtgt , & clientkey -> key , ekey , & tkey_sign -> key , & adtkt , & rspac , & ad_signedpath ) ; if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 0 , ""Verify<S2SV_blank>delegated<S2SV_blank>PAC<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>client"" ""%s<S2SV_blank>(%s)<S2SV_blank>as<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>%s"" , spn , cpn , dpn , tpn , from , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } ret = check_KRB5SignedPath ( context , config , krbtgt , cp , & adtkt , NULL , & ad_signedpath ) ; if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 0 , ""KRB5SignedPath<S2SV_blank>check<S2SV_blank>from<S2SV_blank>service<S2SV_blank>%s<S2SV_blank>failed<S2SV_blank>"" ""for<S2SV_blank>delegation<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s<S2SV_blank>(%s)"" ""from<S2SV_blank>%s<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>%s"" , spn , tpn , dpn , cpn , from , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } if ( ! ad_signedpath ) { ret = KRB5KDC_ERR_BADOPTION ; kdc_log ( context , config , 0 , ""Ticket<S2SV_blank>not<S2SV_blank>signed<S2SV_blank>with<S2SV_blank>PAC<S2SV_blank>nor<S2SV_blank>SignedPath<S2SV_blank>service<S2SV_blank>%s<S2SV_blank>failed<S2SV_blank>"" ""for<S2SV_blank>delegation<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s<S2SV_blank>(%s)"" ""from<S2SV_blank>%s"" , spn , tpn , dpn , cpn , from ) ; goto out ; } kdc_log ( context , config , 0 , ""constrained<S2SV_blank>delegation<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>"" ""from<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>%s"" , tpn , cpn , dpn , spn ) ; } ret = kdc_check_flags ( context , config , client , cpn , server , spn , FALSE ) ; if ( ret ) goto out ; if ( ( b -> kdc_options . validate || b -> kdc_options . renew ) && ! krb5_principal_compare ( context , krbtgt -> entry . principal , server -> entry . principal ) ) { kdc_log ( context , config , 0 , ""Inconsistent<S2SV_blank>request."" ) ; ret = KRB5KDC_ERR_SERVER_NOMATCH ; goto out ; } if ( ! _kdc_check_addresses ( context , config , tgt -> caddr , from_addr ) ) { ret = KRB5KRB_AP_ERR_BADADDR ; kdc_log ( context , config , 0 , ""Request<S2SV_blank>from<S2SV_blank>wrong<S2SV_blank>address"" ) ; goto out ; } if ( ref_realm ) { PA_DATA pa ; krb5_crypto crypto ; kdc_log ( context , config , 0 , ""Adding<S2SV_blank>server<S2SV_blank>referral<S2SV_blank>to<S2SV_blank>%s"" , ref_realm ) ; ret = krb5_crypto_init ( context , & sessionkey , 0 , & crypto ) ; if ( ret ) goto out ; ret = build_server_referral ( context , config , crypto , ref_realm , NULL , s , & pa . padata_value ) ; krb5_crypto_destroy ( context , crypto ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Failed<S2SV_blank>building<S2SV_blank>server<S2SV_blank>referral"" ) ; goto out ; } pa . padata_type = KRB5_PADATA_SERVER_REFERRAL ; ret = add_METHOD_DATA ( & enc_pa_data , & pa ) ; krb5_data_free ( & pa . padata_value ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Add<S2SV_blank>server<S2SV_blank>referral<S2SV_blank>METHOD-DATA<S2SV_blank>failed"" ) ; goto out ; } } ret = tgs_make_reply ( context , config , b , tp , tgt , replykey , rk_is_subkey , ekey , & sessionkey , kvno , * auth_data , server , rsp , spn , client , cp , <S2SV_StartBug> krbtgt_out , <S2SV_EndBug> tkey_sign -> key . keytype , spp , & rspac , & enc_pa_data , e_text , reply ) ; out : if ( tpn != cpn ) free ( tpn ) ; free ( spn ) ; free ( cpn ) ; free ( dpn ) ; free ( krbtgt_out_n ) ; _krb5_free_capath ( context , capath ) ; krb5_data_free ( & rspac ) ; krb5_free_keyblock_contents ( context , & sessionkey ) ; if ( krbtgt_out ) _kdc_free_ent ( context , krbtgt_out ) ; if ( server ) _kdc_free_ent ( context , server ) ; if ( client ) _kdc_free_ent ( context , client ) ; if ( s4u2self_impersonated_client ) _kdc_free_ent ( context , s4u2self_impersonated_client ) ; if ( tp && tp != cp ) krb5_free_principal ( context , tp ) ; krb5_free_principal ( context , cp ) ; krb5_free_principal ( context , dp ) ; krb5_free_principal ( context , sp ) ; krb5_free_principal ( context , krbtgt_out_principal ) ; free ( ref_realm ) ; free_METHOD_DATA ( & enc_pa_data ) ; free_EncTicketPart ( & adtkt ) ; return ret ; }
","<S2SV_ModStart> ; krb5_data rspac ; const char * tgt_realm = krb5_principal_get_realm ( context , krbtgt -> entry . principal ) <S2SV_ModStart> , cp , tgt_realm ,
"
516,"CWE-436 bgp_size_t bgp_packet_attribute ( struct bgp * bgp , struct peer * peer , struct stream * s , struct attr * attr , struct bpacket_attr_vec_arr * vecarr , struct prefix * p , afi_t afi , safi_t safi , struct peer * from , struct prefix_rd * prd , mpls_label_t * label , uint32_t num_labels , int addpath_encode , uint32_t addpath_tx_id ) { size_t cp ; size_t aspath_sizep ; struct aspath * aspath ; int send_as4_path = 0 ; int send_as4_aggregator = 0 ; int use32bit = ( CHECK_FLAG ( peer -> cap , PEER_CAP_AS4_RCV ) ) ? 1 : 0 ; if ( ! bgp ) bgp = peer -> bgp ; cp = stream_get_endp ( s ) ; if ( p && ! ( ( afi == AFI_IP && safi == SAFI_UNICAST ) && ! peer_cap_enhe ( peer , afi , safi ) ) ) { size_t mpattrlen_pos = 0 ; mpattrlen_pos = bgp_packet_mpattr_start ( s , peer , afi , safi , vecarr , attr ) ; bgp_packet_mpattr_prefix ( s , afi , safi , p , prd , label , num_labels , addpath_encode , addpath_tx_id , attr ) ; bgp_packet_mpattr_end ( s , mpattrlen_pos ) ; } stream_putc ( s , BGP_ATTR_FLAG_TRANS ) ; stream_putc ( s , BGP_ATTR_ORIGIN ) ; stream_putc ( s , 1 ) ; stream_putc ( s , attr -> origin ) ; if ( peer -> sort == BGP_PEER_EBGP && ( ! CHECK_FLAG ( peer -> af_flags [ afi ] [ safi ] , PEER_FLAG_AS_PATH_UNCHANGED ) || attr -> aspath -> segments == NULL ) && ( ! CHECK_FLAG ( peer -> af_flags [ afi ] [ safi ] , PEER_FLAG_RSERVER_CLIENT ) ) ) { aspath = aspath_dup ( attr -> aspath ) ; aspath = aspath_delete_confed_seq ( aspath ) ; if ( CHECK_FLAG ( bgp -> config , BGP_CONFIG_CONFEDERATION ) ) { aspath = aspath_add_seq ( aspath , bgp -> confed_id ) ; } else { if ( peer -> change_local_as ) { if ( ! CHECK_FLAG ( peer -> flags , PEER_FLAG_LOCAL_AS_REPLACE_AS ) ) { aspath = aspath_add_seq ( aspath , peer -> local_as ) ; } aspath = aspath_add_seq ( aspath , peer -> change_local_as ) ; } else { aspath = aspath_add_seq ( aspath , peer -> local_as ) ; } } } else if ( peer -> sort == BGP_PEER_CONFED ) { aspath = aspath_dup ( attr -> aspath ) ; aspath = aspath_add_confed_seq ( aspath , peer -> local_as ) ; } else aspath = attr -> aspath ; stream_putc ( s , BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_EXTLEN ) ; stream_putc ( s , BGP_ATTR_AS_PATH ) ; aspath_sizep = stream_get_endp ( s ) ; stream_putw ( s , 0 ) ; stream_putw_at ( s , aspath_sizep , aspath_put ( s , aspath , use32bit ) ) ; if ( ! use32bit && aspath_has_as4 ( aspath ) ) send_as4_path = 1 ; if ( afi == AFI_IP && safi == SAFI_UNICAST && ! peer_cap_enhe ( peer , afi , safi ) ) { if ( attr -> flag & ATTR_FLAG_BIT ( BGP_ATTR_NEXT_HOP ) ) { stream_putc ( s , BGP_ATTR_FLAG_TRANS ) ; stream_putc ( s , BGP_ATTR_NEXT_HOP ) ; bpacket_attr_vec_arr_set_vec ( vecarr , BGP_ATTR_VEC_NH , s , attr ) ; stream_putc ( s , 4 ) ; stream_put_ipv4 ( s , attr -> nexthop . s_addr ) ; } else if ( peer_cap_enhe ( from , afi , safi ) ) { stream_putc ( s , BGP_ATTR_FLAG_TRANS ) ; stream_putc ( s , BGP_ATTR_NEXT_HOP ) ; bpacket_attr_vec_arr_set_vec ( vecarr , BGP_ATTR_VEC_NH , s , NULL ) ; stream_putc ( s , 4 ) ; stream_put_ipv4 ( s , 0 ) ; } } if ( attr -> flag & ATTR_FLAG_BIT ( BGP_ATTR_MULTI_EXIT_DISC ) || bgp -> maxmed_active ) { stream_putc ( s , BGP_ATTR_FLAG_OPTIONAL ) ; stream_putc ( s , BGP_ATTR_MULTI_EXIT_DISC ) ; stream_putc ( s , 4 ) ; stream_putl ( s , ( bgp -> maxmed_active ? bgp -> maxmed_value : attr -> med ) ) ; } if ( peer -> sort == BGP_PEER_IBGP || peer -> sort == BGP_PEER_CONFED ) { stream_putc ( s , BGP_ATTR_FLAG_TRANS ) ; stream_putc ( s , BGP_ATTR_LOCAL_PREF ) ; stream_putc ( s , 4 ) ; stream_putl ( s , attr -> local_pref ) ; } if ( attr -> flag & ATTR_FLAG_BIT ( BGP_ATTR_ATOMIC_AGGREGATE ) ) { stream_putc ( s , BGP_ATTR_FLAG_TRANS ) ; stream_putc ( s , BGP_ATTR_ATOMIC_AGGREGATE ) ; stream_putc ( s , 0 ) ; } if ( attr -> flag & ATTR_FLAG_BIT ( BGP_ATTR_AGGREGATOR ) ) { stream_putc ( s , BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS ) ; stream_putc ( s , BGP_ATTR_AGGREGATOR ) ; if ( use32bit ) { stream_putc ( s , 8 ) ; stream_putl ( s , attr -> aggregator_as ) ; } else { stream_putc ( s , 6 ) ; if ( attr -> aggregator_as > 65535 ) { stream_putw ( s , BGP_AS_TRANS ) ; send_as4_aggregator = 1 ; } else stream_putw ( s , ( uint16_t ) attr -> aggregator_as ) ; } stream_put_ipv4 ( s , attr -> aggregator_addr . s_addr ) ; } if ( CHECK_FLAG ( peer -> af_flags [ afi ] [ safi ] , PEER_FLAG_SEND_COMMUNITY ) && ( attr -> flag & ATTR_FLAG_BIT ( BGP_ATTR_COMMUNITIES ) ) ) { if ( attr -> community -> size * 4 > 255 ) { stream_putc ( s , BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_EXTLEN ) ; stream_putc ( s , BGP_ATTR_COMMUNITIES ) ; stream_putw ( s , attr -> community -> size * 4 ) ; } else { stream_putc ( s , BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS ) ; stream_putc ( s , BGP_ATTR_COMMUNITIES ) ; stream_putc ( s , attr -> community -> size * 4 ) ; } stream_put ( s , attr -> community -> val , attr -> community -> size * 4 ) ; } if ( CHECK_FLAG ( peer -> af_flags [ afi ] [ safi ] , PEER_FLAG_SEND_LARGE_COMMUNITY ) && ( attr -> flag & ATTR_FLAG_BIT ( BGP_ATTR_LARGE_COMMUNITIES ) ) ) { if ( lcom_length ( attr -> lcommunity ) > 255 ) { stream_putc ( s , BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_EXTLEN ) ; stream_putc ( s , BGP_ATTR_LARGE_COMMUNITIES ) ; stream_putw ( s , lcom_length ( attr -> lcommunity ) ) ; } else { stream_putc ( s , BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS ) ; stream_putc ( s , BGP_ATTR_LARGE_COMMUNITIES ) ; stream_putc ( s , lcom_length ( attr -> lcommunity ) ) ; } stream_put ( s , attr -> lcommunity -> val , lcom_length ( attr -> lcommunity ) ) ; } if ( peer -> sort == BGP_PEER_IBGP && from && from -> sort == BGP_PEER_IBGP ) { stream_putc ( s , BGP_ATTR_FLAG_OPTIONAL ) ; stream_putc ( s , BGP_ATTR_ORIGINATOR_ID ) ; stream_putc ( s , 4 ) ; if ( attr -> flag & ATTR_FLAG_BIT ( BGP_ATTR_ORIGINATOR_ID ) ) stream_put_in_addr ( s , & attr -> originator_id ) ; else stream_put_in_addr ( s , & from -> remote_id ) ; stream_putc ( s , BGP_ATTR_FLAG_OPTIONAL ) ; stream_putc ( s , BGP_ATTR_CLUSTER_LIST ) ; if ( attr -> cluster ) { stream_putc ( s , attr -> cluster -> length + 4 ) ; if ( bgp -> config & BGP_CONFIG_CLUSTER_ID ) stream_put_in_addr ( s , & bgp -> cluster_id ) ; else stream_put_in_addr ( s , & bgp -> router_id ) ; stream_put ( s , attr -> cluster -> list , attr -> cluster -> length ) ; } else { stream_putc ( s , 4 ) ; if ( bgp -> config & BGP_CONFIG_CLUSTER_ID ) stream_put_in_addr ( s , & bgp -> cluster_id ) ; else stream_put_in_addr ( s , & bgp -> router_id ) ; } } if ( CHECK_FLAG ( peer -> af_flags [ afi ] [ safi ] , PEER_FLAG_SEND_EXT_COMMUNITY ) && ( attr -> flag & ATTR_FLAG_BIT ( BGP_ATTR_EXT_COMMUNITIES ) ) ) { if ( peer -> sort == BGP_PEER_IBGP || peer -> sort == BGP_PEER_CONFED ) { if ( attr -> ecommunity -> size * 8 > 255 ) { stream_putc ( s , BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_EXTLEN ) ; stream_putc ( s , BGP_ATTR_EXT_COMMUNITIES ) ; stream_putw ( s , attr -> ecommunity -> size * 8 ) ; } else { stream_putc ( s , BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS ) ; stream_putc ( s , BGP_ATTR_EXT_COMMUNITIES ) ; stream_putc ( s , attr -> ecommunity -> size * 8 ) ; } stream_put ( s , attr -> ecommunity -> val , attr -> ecommunity -> size * 8 ) ; } else { uint8_t * pnt ; int tbit ; int ecom_tr_size = 0 ; int i ; for ( i = 0 ; i < attr -> ecommunity -> size ; i ++ ) { pnt = attr -> ecommunity -> val + ( i * 8 ) ; tbit = * pnt ; if ( CHECK_FLAG ( tbit , ECOMMUNITY_FLAG_NON_TRANSITIVE ) ) continue ; ecom_tr_size ++ ; } if ( ecom_tr_size ) { if ( ecom_tr_size * 8 > 255 ) { stream_putc ( s , BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_EXTLEN ) ; stream_putc ( s , BGP_ATTR_EXT_COMMUNITIES ) ; stream_putw ( s , ecom_tr_size * 8 ) ; } else { stream_putc ( s , BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS ) ; stream_putc ( s , BGP_ATTR_EXT_COMMUNITIES ) ; stream_putc ( s , ecom_tr_size * 8 ) ; } for ( i = 0 ; i < attr -> ecommunity -> size ; i ++ ) { pnt = attr -> ecommunity -> val + ( i * 8 ) ; tbit = * pnt ; if ( CHECK_FLAG ( tbit , ECOMMUNITY_FLAG_NON_TRANSITIVE ) ) continue ; stream_put ( s , pnt , 8 ) ; } } } } if ( safi == SAFI_LABELED_UNICAST ) { if ( attr -> flag & ATTR_FLAG_BIT ( BGP_ATTR_PREFIX_SID ) ) { uint32_t label_index ; label_index = attr -> label_index ; if ( label_index != BGP_INVALID_LABEL_INDEX ) { stream_putc ( s , BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS ) ; stream_putc ( s , BGP_ATTR_PREFIX_SID ) ; stream_putc ( s , 10 ) ; stream_putc ( s , BGP_PREFIX_SID_LABEL_INDEX ) ; stream_putw ( s , BGP_PREFIX_SID_LABEL_INDEX_LENGTH ) ; stream_putc ( s , 0 ) ; stream_putw ( s , 0 ) ; stream_putl ( s , label_index ) ; } } } if ( send_as4_path ) { aspath = aspath_delete_confed_seq ( aspath ) ; stream_putc ( s , BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_EXTLEN ) ; stream_putc ( s , BGP_ATTR_AS4_PATH ) ; aspath_sizep = stream_get_endp ( s ) ; stream_putw ( s , 0 ) ; stream_putw_at ( s , aspath_sizep , aspath_put ( s , aspath , 1 ) ) ; } if ( aspath != attr -> aspath ) aspath_free ( aspath ) ; if ( send_as4_aggregator ) { stream_putc ( s , BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS ) ; stream_putc ( s , BGP_ATTR_AS4_AGGREGATOR ) ; stream_putc ( s , 8 ) ; stream_putl ( s , attr -> aggregator_as ) ; stream_put_ipv4 ( s , attr -> aggregator_addr . s_addr ) ; } if ( ( ( afi == AFI_IP || afi == AFI_IP6 ) && ( safi == SAFI_ENCAP || safi == SAFI_MPLS_VPN ) ) || ( afi == AFI_L2VPN && safi == SAFI_EVPN ) ) { bgp_packet_mpattr_tea ( bgp , peer , s , attr , BGP_ATTR_ENCAP ) ; <S2SV_StartBug> # if ENABLE_BGP_VNC <S2SV_EndBug> bgp_packet_mpattr_tea ( bgp , peer , s , attr , BGP_ATTR_VNC ) ; # endif } if ( attr -> flag & ATTR_FLAG_BIT ( BGP_ATTR_PMSI_TUNNEL ) ) { stream_putc ( s , BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS ) ; stream_putc ( s , BGP_ATTR_PMSI_TUNNEL ) ; stream_putc ( s , 9 ) ; stream_putc ( s , 0 ) ; stream_putc ( s , PMSI_TNLTYPE_INGR_REPL ) ; stream_put ( s , & ( attr -> label ) , BGP_LABEL_BYTES ) ; stream_put_ipv4 ( s , attr -> nexthop . s_addr ) ; } if ( attr -> transit ) stream_put ( s , attr -> transit -> val , attr -> transit -> length ) ; return stream_get_endp ( s ) - cp ; }
","<S2SV_ModStart> ; # if ENABLE_BGP_VNC_ATTR <S2SV_ModEnd> bgp_packet_mpattr_tea ( bgp
"
517,"CWE-119 static void stellaris_enet_class_init ( ObjectClass * klass , void * data ) { DeviceClass * dc = DEVICE_CLASS ( klass ) ; SysBusDeviceClass * k = SYS_BUS_DEVICE_CLASS ( klass ) ; k -> init = stellaris_enet_init ; dc -> unrealize = stellaris_enet_unrealize ; dc -> props = stellaris_enet_properties ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> = stellaris_enet_properties ; dc -> vmsd = & vmstate_stellaris_enet ;
"
518,"CWE-269 static int store_asoundrc ( void ) { fs_build_mnt_dir ( ) ; char * src ; char * dest = RUN_ASOUNDRC_FILE ; FILE * fp = fopen ( dest , ""w"" ) ; if ( fp ) { fprintf ( fp , ""\\n"" ) ; SET_PERMS_STREAM ( fp , getuid ( ) , getgid ( ) , 0644 ) ; fclose ( fp ) ; } if ( asprintf ( & src , ""%s/.asoundrc"" , cfg . homedir ) == - 1 ) errExit ( ""asprintf"" ) ; struct stat s ; if ( stat ( src , & s ) == 0 ) { if ( is_link ( src ) ) { <S2SV_StartBug> fprintf ( stderr , ""Error:<S2SV_blank>invalid<S2SV_blank>.asoundrc<S2SV_blank>file\\n"" ) ; <S2SV_EndBug> exit ( 1 ) ; } <S2SV_StartBug> pid_t child = fork ( ) ; <S2SV_EndBug> if ( child < 0 ) errExit ( ""fork"" ) ; if ( child == 0 ) { drop_privs ( 0 ) ; int rv = copy_file ( src , dest ) ; if ( rv ) <S2SV_StartBug> fprintf ( stderr , ""Warning:<S2SV_blank>cannot<S2SV_blank>transfer<S2SV_blank>.asoundrc<S2SV_blank>in<S2SV_blank>private<S2SV_blank>home<S2SV_blank>directory\\n"" ) ; <S2SV_EndBug> else { <S2SV_StartBug> fs_logger2 ( ""clone"" , dest ) ; <S2SV_EndBug> } _exit ( 0 ) ; } waitpid ( child , NULL , 0 ) ; if ( chown ( dest , getuid ( ) , getgid ( ) ) == - 1 ) errExit ( ""fchown"" ) ; if ( chmod ( dest , 0644 ) == - 1 ) errExit ( ""fchmod"" ) ; return 1 ; } return 0 ; }
","<S2SV_ModStart> ) ) { char * rp = realpath ( src , NULL ) ; if ( ! rp ) { <S2SV_ModStart> ( stderr , ""Error:<S2SV_blank>Cannot<S2SV_blank>access<S2SV_blank>%s\\n"" , src <S2SV_ModEnd> ) ; exit <S2SV_ModStart> ) ; } if ( strncmp ( rp , cfg . homedir , strlen ( cfg . homedir ) ) != 0 ) { <S2SV_ModEnd> fprintf ( stderr <S2SV_ModStart> ( stderr , ""Error:<S2SV_blank>.asoundrc<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symbolic<S2SV_blank>link<S2SV_blank>pointing<S2SV_blank>to<S2SV_blank>a<S2SV_blank>file<S2SV_blank>outside<S2SV_blank>home<S2SV_blank>directory\\n"" ) ; exit ( 1 ) ; } free ( rp ) ; } copy_file_as_user ( src , dest , getuid ( ) , getgid ( ) , 0644 ) ; <S2SV_ModEnd> fs_logger2 ( ""clone"" <S2SV_ModStart> ""clone"" , dest <S2SV_ModEnd> ) ; return
"
519,"CWE-000 int assoc_array_gc ( struct assoc_array * array , const struct assoc_array_ops * ops , bool ( * iterator ) ( void * object , void * iterator_data ) , void * iterator_data ) { struct assoc_array_shortcut * shortcut , * new_s ; struct assoc_array_node * node , * new_n ; struct assoc_array_edit * edit ; struct assoc_array_ptr * cursor , * ptr ; struct assoc_array_ptr * new_root , * new_parent , * * new_ptr_pp ; unsigned long nr_leaves_on_tree ; int keylen , slot , nr_free , next_slot , i ; pr_devel ( ""-->%s()\\n"" , __func__ ) ; if ( ! array -> root ) return 0 ; edit = kzalloc ( sizeof ( struct assoc_array_edit ) , GFP_KERNEL ) ; if ( ! edit ) return - ENOMEM ; edit -> array = array ; edit -> ops = ops ; edit -> ops_for_excised_subtree = ops ; edit -> set [ 0 ] . ptr = & array -> root ; edit -> excised_subtree = array -> root ; new_root = new_parent = NULL ; new_ptr_pp = & new_root ; cursor = array -> root ; descend : if ( assoc_array_ptr_is_shortcut ( cursor ) ) { shortcut = assoc_array_ptr_to_shortcut ( cursor ) ; keylen = round_up ( shortcut -> skip_to_level , ASSOC_ARRAY_KEY_CHUNK_SIZE ) ; keylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT ; new_s = kmalloc ( sizeof ( struct assoc_array_shortcut ) + keylen * sizeof ( unsigned long ) , GFP_KERNEL ) ; if ( ! new_s ) goto enomem ; pr_devel ( ""dup<S2SV_blank>shortcut<S2SV_blank>%p<S2SV_blank>-><S2SV_blank>%p\\n"" , shortcut , new_s ) ; memcpy ( new_s , shortcut , ( sizeof ( struct assoc_array_shortcut ) + keylen * sizeof ( unsigned long ) ) ) ; new_s -> back_pointer = new_parent ; new_s -> parent_slot = shortcut -> parent_slot ; * new_ptr_pp = new_parent = assoc_array_shortcut_to_ptr ( new_s ) ; new_ptr_pp = & new_s -> next_node ; cursor = shortcut -> next_node ; } node = assoc_array_ptr_to_node ( cursor ) ; new_n = kzalloc ( sizeof ( struct assoc_array_node ) , GFP_KERNEL ) ; if ( ! new_n ) goto enomem ; pr_devel ( ""dup<S2SV_blank>node<S2SV_blank>%p<S2SV_blank>-><S2SV_blank>%p\\n"" , node , new_n ) ; new_n -> back_pointer = new_parent ; new_n -> parent_slot = node -> parent_slot ; * new_ptr_pp = new_parent = assoc_array_node_to_ptr ( new_n ) ; new_ptr_pp = NULL ; slot = 0 ; continue_node : for ( ; slot < ASSOC_ARRAY_FAN_OUT ; slot ++ ) { ptr = node -> slots [ slot ] ; if ( ! ptr ) continue ; if ( assoc_array_ptr_is_leaf ( ptr ) ) { if ( iterator ( assoc_array_ptr_to_leaf ( ptr ) , iterator_data ) ) new_n -> slots [ slot ] = ptr ; continue ; } new_ptr_pp = & new_n -> slots [ slot ] ; cursor = ptr ; goto descend ; } pr_devel ( ""--<S2SV_blank>compress<S2SV_blank>node<S2SV_blank>%p<S2SV_blank>--\\n"" , new_n ) ; new_n -> nr_leaves_on_branch = 0 ; nr_free = 0 ; for ( slot = 0 ; slot < ASSOC_ARRAY_FAN_OUT ; slot ++ ) { ptr = new_n -> slots [ slot ] ; if ( ! ptr ) nr_free ++ ; else if ( assoc_array_ptr_is_leaf ( ptr ) ) new_n -> nr_leaves_on_branch ++ ; } pr_devel ( ""free=%d,<S2SV_blank>leaves=%lu\\n"" , nr_free , new_n -> nr_leaves_on_branch ) ; next_slot = 0 ; for ( slot = 0 ; slot < ASSOC_ARRAY_FAN_OUT ; slot ++ ) { struct assoc_array_shortcut * s ; struct assoc_array_node * child ; ptr = new_n -> slots [ slot ] ; if ( ! ptr || assoc_array_ptr_is_leaf ( ptr ) ) continue ; s = NULL ; if ( assoc_array_ptr_is_shortcut ( ptr ) ) { s = assoc_array_ptr_to_shortcut ( ptr ) ; ptr = s -> next_node ; } child = assoc_array_ptr_to_node ( ptr ) ; new_n -> nr_leaves_on_branch += child -> nr_leaves_on_branch ; if ( child -> nr_leaves_on_branch <= nr_free + 1 ) { pr_devel ( ""[%d]<S2SV_blank>fold<S2SV_blank>node<S2SV_blank>%lu/%d<S2SV_blank>[nx<S2SV_blank>%d]\\n"" , slot , child -> nr_leaves_on_branch , nr_free + 1 , next_slot ) ; BUG_ON ( s ) ; new_n -> slots [ slot ] = NULL ; nr_free ++ ; if ( slot < next_slot ) next_slot = slot ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { struct assoc_array_ptr * p = child -> slots [ i ] ; if ( ! p ) continue ; BUG_ON ( assoc_array_ptr_is_meta ( p ) ) ; while ( new_n -> slots [ next_slot ] ) next_slot ++ ; BUG_ON ( next_slot >= ASSOC_ARRAY_FAN_OUT ) ; new_n -> slots [ next_slot ++ ] = p ; nr_free -- ; } kfree ( child ) ; } else { pr_devel ( ""[%d]<S2SV_blank>retain<S2SV_blank>node<S2SV_blank>%lu/%d<S2SV_blank>[nx<S2SV_blank>%d]\\n"" , slot , child -> nr_leaves_on_branch , nr_free + 1 , next_slot ) ; } } pr_devel ( ""after:<S2SV_blank>%lu\\n"" , new_n -> nr_leaves_on_branch ) ; nr_leaves_on_tree = new_n -> nr_leaves_on_branch ; if ( nr_free == ASSOC_ARRAY_FAN_OUT - 1 ) { for ( slot = 0 ; slot < ASSOC_ARRAY_FAN_OUT ; slot ++ ) if ( ( ptr = new_n -> slots [ slot ] ) ) break ; if ( assoc_array_ptr_is_meta ( ptr ) && assoc_array_ptr_is_shortcut ( ptr ) ) { pr_devel ( ""excise<S2SV_blank>node<S2SV_blank>%p<S2SV_blank>with<S2SV_blank>1<S2SV_blank>shortcut\\n"" , new_n ) ; new_s = assoc_array_ptr_to_shortcut ( ptr ) ; new_parent = new_n -> back_pointer ; slot = new_n -> parent_slot ; kfree ( new_n ) ; if ( ! new_parent ) { new_s -> back_pointer = NULL ; new_s -> parent_slot = 0 ; new_root = ptr ; goto gc_complete ; } if ( assoc_array_ptr_is_shortcut ( new_parent ) ) { struct assoc_array_shortcut * s = assoc_array_ptr_to_shortcut ( new_parent ) ; pr_devel ( ""excise<S2SV_blank>preceding<S2SV_blank>shortcut\\n"" ) ; new_parent = new_s -> back_pointer = s -> back_pointer ; slot = new_s -> parent_slot = s -> parent_slot ; kfree ( s ) ; if ( ! new_parent ) { new_s -> back_pointer = NULL ; new_s -> parent_slot = 0 ; new_root = ptr ; goto gc_complete ; } } new_s -> back_pointer = new_parent ; new_s -> parent_slot = slot ; new_n = assoc_array_ptr_to_node ( new_parent ) ; new_n -> slots [ slot ] = ptr ; goto ascend_old_tree ; } } ptr = new_n -> back_pointer ; if ( ! ptr ) goto gc_complete ; if ( assoc_array_ptr_is_shortcut ( ptr ) ) { new_s = assoc_array_ptr_to_shortcut ( ptr ) ; new_parent = new_s -> back_pointer ; slot = new_s -> parent_slot ; if ( new_n -> nr_leaves_on_branch <= ASSOC_ARRAY_FAN_OUT ) { struct assoc_array_node * n ; pr_devel ( ""excise<S2SV_blank>shortcut\\n"" ) ; new_n -> back_pointer = new_parent ; new_n -> parent_slot = slot ; kfree ( new_s ) ; if ( ! new_parent ) { new_root = assoc_array_node_to_ptr ( new_n ) ; goto gc_complete ; } n = assoc_array_ptr_to_node ( new_parent ) ; n -> slots [ slot ] = assoc_array_node_to_ptr ( new_n ) ; } } else { new_parent = ptr ; } new_n = assoc_array_ptr_to_node ( new_parent ) ; ascend_old_tree : ptr = node -> back_pointer ; if ( assoc_array_ptr_is_shortcut ( ptr ) ) { shortcut = assoc_array_ptr_to_shortcut ( ptr ) ; slot = shortcut -> parent_slot ; cursor = shortcut -> back_pointer ; <S2SV_StartBug> } else { <S2SV_EndBug> slot = node -> parent_slot ; cursor = ptr ; } <S2SV_StartBug> BUG_ON ( ! ptr ) ; <S2SV_EndBug> node = assoc_array_ptr_to_node ( cursor ) ; slot ++ ; goto continue_node ; gc_complete : edit -> set [ 0 ] . to = new_root ; assoc_array_apply_edit ( edit ) ; array -> nr_leaves_on_tree = nr_leaves_on_tree ; return 0 ; enomem : pr_devel ( ""enomem\\n"" ) ; assoc_array_destroy_subtree ( new_root , edit -> ops ) ; kfree ( edit ) ; return - ENOMEM ; }
","<S2SV_ModStart> -> back_pointer ; if ( ! cursor ) goto gc_complete ; <S2SV_ModStart> BUG_ON ( ! cursor <S2SV_ModEnd> ) ; node
"
520,"CWE-401 static Image * ReadSIXELImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char * sixel_buffer ; Image * image ; MagickBooleanType status ; register char * p ; register ssize_t x ; register Quantum * q ; size_t length ; ssize_t i , j , y ; unsigned char * sixel_pixels , * sixel_palette ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } length = MagickPathExtent ; sixel_buffer = ( char * ) AcquireQuantumMemory ( ( size_t ) length + MagickPathExtent , sizeof ( * sixel_buffer ) ) ; p = sixel_buffer ; if ( sixel_buffer != ( char * ) NULL ) while ( ReadBlobString ( image , p ) != ( char * ) NULL ) { if ( ( * p == '#' ) && ( ( p == sixel_buffer ) || ( * ( p - 1 ) == '\\n' ) ) ) continue ; if ( ( * p == '}' ) && ( * ( p + 1 ) == ';' ) ) break ; p += strlen ( p ) ; if ( ( size_t ) ( p - sixel_buffer + MagickPathExtent + 1 ) < length ) continue ; length <<= 1 ; sixel_buffer = ( char * ) ResizeQuantumMemory ( sixel_buffer , length + MagickPathExtent + 1 , sizeof ( * sixel_buffer ) ) ; if ( sixel_buffer == ( char * ) NULL ) break ; p = sixel_buffer + strlen ( sixel_buffer ) ; } if ( sixel_buffer == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; sixel_buffer [ length ] = '\\0' ; if ( sixel_decode ( image , ( unsigned char * ) sixel_buffer , & sixel_pixels , & image -> columns , & image -> rows , & sixel_palette , & image -> colors , exception ) == MagickFalse ) { <S2SV_StartBug> sixel_buffer = ( char * ) RelinquishMagickMemory ( sixel_buffer ) ; <S2SV_EndBug> ThrowReaderException ( CorruptImageError , ""CorruptImage"" ) ; } sixel_buffer = ( char * ) RelinquishMagickMemory ( sixel_buffer ) ; image -> depth = 24 ; image -> storage_class = PseudoClass ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) { sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels ) ; sixel_palette = ( unsigned char * ) RelinquishMagickMemory ( sixel_palette ) ; return ( DestroyImageList ( image ) ) ; } if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) { sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels ) ; sixel_palette = ( unsigned char * ) RelinquishMagickMemory ( sixel_palette ) ; ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } for ( i = 0 ; i < ( ssize_t ) image -> colors ; ++ i ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( sixel_palette [ i * 4 + 0 ] ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( sixel_palette [ i * 4 + 1 ] ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( sixel_palette [ i * 4 + 2 ] ) ; } j = 0 ; if ( image_info -> ping == MagickFalse ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { j = ( ssize_t ) sixel_pixels [ y * image -> columns + x ] ; SetPixelIndex ( image , j , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } if ( y < ( ssize_t ) image -> rows ) { sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels ) ; sixel_palette = ( unsigned char * ) RelinquishMagickMemory ( sixel_palette ) ; ThrowReaderException ( CorruptImageError , ""NotEnoughPixelData"" ) ; } } sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels ) ; sixel_palette = ( unsigned char * ) RelinquishMagickMemory ( sixel_palette ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> RelinquishMagickMemory ( sixel_buffer ) ; sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels
"
521,"CWE-189 PHP_FUNCTION ( imagecrop ) { zval * IM ; gdImagePtr im ; gdImagePtr im_crop ; gdRect rect ; zval * z_rect ; zval * * tmp ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""ra"" , & IM , & z_rect ) == FAILURE ) { return ; } ZEND_FETCH_RESOURCE ( im , gdImagePtr , & IM , - 1 , ""Image"" , le_gd ) ; if ( zend_hash_find ( HASH_OF ( z_rect ) , ""x"" , sizeof ( ""x"" ) , ( void * * ) & tmp ) != FAILURE ) { <S2SV_StartBug> rect . x = Z_LVAL_PP ( tmp ) ; <S2SV_EndBug> } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>x<S2SV_blank>position"" ) ; RETURN_FALSE ; } if ( zend_hash_find ( HASH_OF ( z_rect ) , ""y"" , sizeof ( ""x"" ) , ( void * * ) & tmp ) != FAILURE ) { <S2SV_StartBug> rect . y = Z_LVAL_PP ( tmp ) ; <S2SV_EndBug> } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>y<S2SV_blank>position"" ) ; RETURN_FALSE ; } if ( zend_hash_find ( HASH_OF ( z_rect ) , ""width"" , sizeof ( ""width"" ) , ( void * * ) & tmp ) != FAILURE ) { <S2SV_StartBug> rect . width = Z_LVAL_PP ( tmp ) ; <S2SV_EndBug> } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>width"" ) ; RETURN_FALSE ; } if ( zend_hash_find ( HASH_OF ( z_rect ) , ""height"" , sizeof ( ""height"" ) , ( void * * ) & tmp ) != FAILURE ) { <S2SV_StartBug> rect . height = Z_LVAL_PP ( tmp ) ; <S2SV_EndBug> } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>height"" ) ; RETURN_FALSE ; } im_crop = gdImageCrop ( im , & rect ) ; if ( im_crop == NULL ) { RETURN_FALSE ; } else { ZEND_REGISTER_RESOURCE ( return_value , im_crop , le_gd ) ; } }
","<S2SV_ModStart> FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; <S2SV_ModStart> . x = Z_LVAL ( lval ) ; } else { rect . x = <S2SV_ModStart> tmp ) ; } <S2SV_ModStart> FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; <S2SV_ModStart> . y = Z_LVAL ( lval ) ; } else { rect . y = <S2SV_ModStart> tmp ) ; } <S2SV_ModStart> FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; <S2SV_ModStart> . width = Z_LVAL ( lval ) ; } else { rect . width = <S2SV_ModStart> tmp ) ; } <S2SV_ModStart> FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; <S2SV_ModStart> . height = Z_LVAL ( lval ) ; } else { rect . height = <S2SV_ModStart> tmp ) ; }
"
522,"CWE-400 static void alpha_perf_event_irq_handler ( unsigned long la_ptr , struct pt_regs * regs ) { struct cpu_hw_events * cpuc ; struct perf_sample_data data ; struct perf_event * event ; struct hw_perf_event * hwc ; int idx , j ; __get_cpu_var ( irq_pmi_count ) ++ ; cpuc = & __get_cpu_var ( cpu_hw_events ) ; wrperfmon ( PERFMON_CMD_DISABLE , cpuc -> idx_mask ) ; if ( unlikely ( la_ptr >= alpha_pmu -> num_pmcs ) ) { irq_err_count ++ ; pr_warning ( ""PMI:<S2SV_blank>silly<S2SV_blank>index<S2SV_blank>%ld\\n"" , la_ptr ) ; wrperfmon ( PERFMON_CMD_ENABLE , cpuc -> idx_mask ) ; return ; } idx = la_ptr ; perf_sample_data_init ( & data , 0 ) ; for ( j = 0 ; j < cpuc -> n_events ; j ++ ) { if ( cpuc -> current_idx [ j ] == idx ) break ; } if ( unlikely ( j == cpuc -> n_events ) ) { wrperfmon ( PERFMON_CMD_ENABLE , cpuc -> idx_mask ) ; return ; } event = cpuc -> event [ j ] ; if ( unlikely ( ! event ) ) { irq_err_count ++ ; pr_warning ( ""PMI:<S2SV_blank>No<S2SV_blank>event<S2SV_blank>at<S2SV_blank>index<S2SV_blank>%d!\\n"" , idx ) ; wrperfmon ( PERFMON_CMD_ENABLE , cpuc -> idx_mask ) ; return ; } hwc = & event -> hw ; alpha_perf_event_update ( event , hwc , idx , alpha_pmu -> pmc_max_period [ idx ] + 1 ) ; data . period = event -> hw . last_period ; if ( alpha_perf_event_set_period ( event , hwc , idx ) ) { <S2SV_StartBug> if ( perf_event_overflow ( event , 1 , & data , regs ) ) { <S2SV_EndBug> alpha_pmu_stop ( event , 0 ) ; } } wrperfmon ( PERFMON_CMD_ENABLE , cpuc -> idx_mask ) ; return ; }
","<S2SV_ModStart> ( event , <S2SV_ModEnd> & data ,
"
523,"CWE-252 static void init_syntax_once ( ) { register int c ; <S2SV_StartBug> static int done ; <S2SV_EndBug> if ( done ) return ; bzero ( re_syntax_table , sizeof re_syntax_table ) ; <S2SV_StartBug> for ( c = 'a' ; c <= 'z' ; c ++ ) <S2SV_EndBug> re_syntax_table [ c ] = Sword ; for ( c = 'A' ; c <= 'Z' ; c ++ ) re_syntax_table [ c ] = Sword ; for ( c = '0' ; c <= '9' ; c ++ ) re_syntax_table [ c ] = Sword ; re_syntax_table [ '_' ] = Sword ; done = 1 ; }
","<S2SV_ModStart> static int done = 0 <S2SV_ModStart> ( c = 0 ; c < CHAR_SET_SIZE ; ++ c ) if ( ISALNUM ( c ) <S2SV_ModEnd> ) re_syntax_table [
"
524,"CWE-200 static void sg_fill_request_table ( Sg_fd * sfp , sg_req_info_t * rinfo ) { Sg_request * srp ; int val ; unsigned int ms ; val = 0 ; list_for_each_entry ( srp , & sfp -> rq_list , entry ) { if ( val > SG_MAX_QUEUE ) break ; <S2SV_StartBug> memset ( & rinfo [ val ] , 0 , SZ_SG_REQ_INFO ) ; <S2SV_EndBug> rinfo [ val ] . req_state = srp -> done + 1 ; rinfo [ val ] . problem = srp -> header . masked_status & srp -> header . host_status & srp -> header . driver_status ; if ( srp -> done ) rinfo [ val ] . duration = srp -> header . duration ; else { ms = jiffies_to_msecs ( jiffies ) ; rinfo [ val ] . duration = ( ms > srp -> header . duration ) ? ( ms - srp -> header . duration ) : 0 ; } rinfo [ val ] . orphan = srp -> orphan ; rinfo [ val ] . sg_io_owned = srp -> sg_io_owned ; rinfo [ val ] . pack_id = srp -> header . pack_id ; rinfo [ val ] . usr_ptr = srp -> header . usr_ptr ; val ++ ; } }
","<S2SV_ModStart> ) break ; <S2SV_ModEnd> rinfo [ val
"
525,"CWE-310 int ASN1_item_verify ( const ASN1_ITEM * it , X509_ALGOR * a , ASN1_BIT_STRING * signature , void * asn , EVP_PKEY * pkey ) { EVP_MD_CTX ctx ; unsigned char * buf_in = NULL ; int ret = - 1 , inl ; int mdnid , pknid ; if ( ! pkey ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_PASSED_NULL_PARAMETER ) ; return - 1 ; } if ( signature -> type == V_ASN1_BIT_STRING && signature -> flags & 0x7 ) { <S2SV_StartBug> ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ; <S2SV_EndBug> return - 1 ; } EVP_MD_CTX_init ( & ctx ) ; if ( ! OBJ_find_sigid_algs ( OBJ_obj2nid ( a -> algorithm ) , & mdnid , & pknid ) ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM ) ; goto err ; } if ( mdnid == NID_undef ) { if ( ! pkey -> ameth || ! pkey -> ameth -> item_verify ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM ) ; goto err ; } ret = pkey -> ameth -> item_verify ( & ctx , it , asn , a , signature , pkey ) ; if ( ret != 2 ) goto err ; ret = - 1 ; } else { const EVP_MD * type ; type = EVP_get_digestbynid ( mdnid ) ; if ( type == NULL ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM ) ; goto err ; } if ( EVP_PKEY_type ( pknid ) != pkey -> ameth -> pkey_id ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_WRONG_PUBLIC_KEY_TYPE ) ; goto err ; } if ( ! EVP_DigestVerifyInit ( & ctx , NULL , type , NULL , pkey ) ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_EVP_LIB ) ; ret = 0 ; goto err ; } } inl = ASN1_item_i2d ( asn , & buf_in , it ) ; if ( buf_in == NULL ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_MALLOC_FAILURE ) ; goto err ; } ret = EVP_DigestVerifyUpdate ( & ctx , buf_in , inl ) ; OPENSSL_cleanse ( buf_in , ( unsigned int ) inl ) ; OPENSSL_free ( buf_in ) ; if ( ! ret ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_EVP_LIB ) ; goto err ; } ret = - 1 ; if ( EVP_DigestVerifyFinal ( & ctx , signature -> data , ( size_t ) signature -> length ) <= 0 ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_EVP_LIB ) ; ret = 0 ; goto err ; } ret = 1 ; err : EVP_MD_CTX_cleanup ( & ctx ) ; return ( ret ) ; }
","<S2SV_ModStart> { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY <S2SV_ModEnd> , ASN1_R_INVALID_BIT_STRING_BITS_LEFT )
"
526,"CWE-119 static size_t read_uncompressed_header ( VP9Decoder * pbi , <S2SV_StartBug> struct vp9_read_bit_buffer * rb ) { <S2SV_EndBug> VP9_COMMON * const cm = & pbi -> common ; <S2SV_StartBug> size_t sz ; <S2SV_EndBug> <S2SV_StartBug> int i ; <S2SV_EndBug> cm -> last_frame_type = cm -> frame_type ; <S2SV_StartBug> if ( vp9_rb_read_literal ( rb , 2 ) != VP9_FRAME_MARKER ) <S2SV_EndBug> vpx_internal_error ( & cm -> error , VPX_CODEC_UNSUP_BITSTREAM , ""Invalid<S2SV_blank>frame<S2SV_blank>marker"" ) ; <S2SV_StartBug> cm -> profile = read_profile ( rb ) ; <S2SV_EndBug> if ( cm -> profile >= MAX_PROFILES ) vpx_internal_error ( & cm -> error , VPX_CODEC_UNSUP_BITSTREAM , ""Unsupported<S2SV_blank>bitstream<S2SV_blank>profile"" ) ; <S2SV_StartBug> cm -> show_existing_frame = vp9_rb_read_bit ( rb ) ; <S2SV_EndBug> if ( cm -> show_existing_frame ) { <S2SV_StartBug> const int frame_to_show = cm -> ref_frame_map [ vp9_rb_read_literal ( rb , 3 ) ] ; <S2SV_EndBug> <S2SV_StartBug> if ( cm -> frame_bufs [ frame_to_show ] . ref_count < 1 ) <S2SV_EndBug> vpx_internal_error ( & cm -> error , VPX_CODEC_UNSUP_BITSTREAM , ""Buffer<S2SV_blank>%d<S2SV_blank>does<S2SV_blank>not<S2SV_blank>contain<S2SV_blank>a<S2SV_blank>decoded<S2SV_blank>frame"" , frame_to_show ) ; <S2SV_StartBug> ref_cnt_fb ( cm -> frame_bufs , & cm -> new_fb_idx , frame_to_show ) ; <S2SV_EndBug> pbi -> refresh_frame_flags = 0 ; cm -> lf . filter_level = 0 ; cm -> show_frame = 1 ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> } <S2SV_StartBug> cm -> frame_type = ( FRAME_TYPE ) vp9_rb_read_bit ( rb ) ; <S2SV_EndBug> <S2SV_StartBug> cm -> show_frame = vp9_rb_read_bit ( rb ) ; <S2SV_EndBug> <S2SV_StartBug> cm -> error_resilient_mode = vp9_rb_read_bit ( rb ) ; <S2SV_EndBug> if ( cm -> frame_type == KEY_FRAME ) { <S2SV_StartBug> check_sync_code ( cm , rb ) ; <S2SV_EndBug> if ( cm -> profile > PROFILE_1 ) cm -> bit_depth = vp9_rb_read_bit ( rb ) ? BITS_12 : BITS_10 ; cm -> color_space = ( COLOR_SPACE ) vp9_rb_read_literal ( rb , 3 ) ; if ( cm -> color_space != SRGB ) { vp9_rb_read_bit ( rb ) ; if ( cm -> profile >= PROFILE_1 ) { cm -> subsampling_x = vp9_rb_read_bit ( rb ) ; cm -> subsampling_y = vp9_rb_read_bit ( rb ) ; vp9_rb_read_bit ( rb ) ; } else { cm -> subsampling_y = cm -> subsampling_x = 1 ; } } else { if ( cm -> profile >= PROFILE_1 ) { cm -> subsampling_y = cm -> subsampling_x = 0 ; vp9_rb_read_bit ( rb ) ; } else { vpx_internal_error ( & cm -> error , VPX_CODEC_UNSUP_BITSTREAM , <S2SV_StartBug> ""RGB<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>profile<S2SV_blank>0"" ) ; <S2SV_EndBug> } } pbi -> refresh_frame_flags = ( 1 << REF_FRAMES ) - 1 ; for ( i = 0 ; i < REFS_PER_FRAME ; ++ i ) { <S2SV_StartBug> cm -> frame_refs [ i ] . idx = cm -> new_fb_idx ; <S2SV_EndBug> <S2SV_StartBug> cm -> frame_refs [ i ] . buf = get_frame_new_buffer ( cm ) ; <S2SV_EndBug> } <S2SV_StartBug> setup_frame_size ( cm , rb ) ; <S2SV_EndBug> } else { <S2SV_StartBug> cm -> intra_only = cm -> show_frame ? 0 : vp9_rb_read_bit ( rb ) ; <S2SV_EndBug> cm -> reset_frame_context = cm -> error_resilient_mode ? <S2SV_StartBug> 0 : vp9_rb_read_literal ( rb , 2 ) ; <S2SV_EndBug> if ( cm -> intra_only ) { <S2SV_StartBug> check_sync_code ( cm , rb ) ; <S2SV_EndBug> <S2SV_StartBug> pbi -> refresh_frame_flags = vp9_rb_read_literal ( rb , REF_FRAMES ) ; <S2SV_EndBug> setup_frame_size ( cm , rb ) ; <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> pbi -> refresh_frame_flags = vp9_rb_read_literal ( rb , REF_FRAMES ) ; <S2SV_EndBug> for ( i = 0 ; i < REFS_PER_FRAME ; ++ i ) { <S2SV_StartBug> const int ref = vp9_rb_read_literal ( rb , REF_FRAMES_LOG2 ) ; <S2SV_EndBug> const int idx = cm -> ref_frame_map [ ref ] ; <S2SV_StartBug> cm -> frame_refs [ i ] . idx = idx ; <S2SV_EndBug> <S2SV_StartBug> cm -> frame_refs [ i ] . buf = & cm -> frame_bufs [ idx ] . buf ; <S2SV_EndBug> <S2SV_StartBug> cm -> ref_frame_sign_bias [ LAST_FRAME + i ] = vp9_rb_read_bit ( rb ) ; <S2SV_EndBug> } setup_frame_size_with_refs ( cm , rb ) ; <S2SV_StartBug> cm -> allow_high_precision_mv = vp9_rb_read_bit ( rb ) ; <S2SV_EndBug> cm -> interp_filter = read_interp_filter ( rb ) ; for ( i = 0 ; i < REFS_PER_FRAME ; ++ i ) { RefBuffer * const ref_buf = & cm -> frame_refs [ i ] ; <S2SV_StartBug> vp9_setup_scale_factors_for_frame ( & ref_buf -> sf , <S2SV_EndBug> ref_buf -> buf -> y_crop_width , ref_buf -> buf -> y_crop_height , <S2SV_StartBug> cm -> width , cm -> height ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vp9_is_scaled ( & ref_buf -> sf ) ) <S2SV_EndBug> <S2SV_StartBug> vp9_extend_frame_borders ( ref_buf -> buf ) ; <S2SV_EndBug> } } } if ( ! cm -> error_resilient_mode ) { <S2SV_StartBug> cm -> coding_use_prev_mi = 1 ; <S2SV_EndBug> <S2SV_StartBug> cm -> refresh_frame_context = vp9_rb_read_bit ( rb ) ; <S2SV_EndBug> cm -> frame_parallel_decoding_mode = vp9_rb_read_bit ( rb ) ; } else { <S2SV_StartBug> cm -> coding_use_prev_mi = 0 ; <S2SV_EndBug> cm -> refresh_frame_context = 0 ; cm -> frame_parallel_decoding_mode = 1 ; <S2SV_StartBug> } <S2SV_EndBug> cm -> frame_context_idx = vp9_rb_read_literal ( rb , FRAME_CONTEXTS_LOG2 ) ; if ( frame_is_intra_only ( cm ) || cm -> error_resilient_mode ) vp9_setup_past_independence ( cm ) ; setup_loopfilter ( & cm -> lf , rb ) ; setup_quantization ( cm , & pbi -> mb , rb ) ; setup_segmentation ( & cm -> seg , rb ) ; <S2SV_StartBug> setup_tile_info ( cm , rb ) ; <S2SV_EndBug> <S2SV_StartBug> sz = vp9_rb_read_literal ( rb , 16 ) ; <S2SV_EndBug> if ( sz == 0 ) vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , ""Invalid<S2SV_blank>header<S2SV_blank>size"" ) ; return sz ; }
","<S2SV_ModStart> pbi , struct vpx_read_bit_buffer <S2SV_ModEnd> * rb ) <S2SV_ModStart> -> common ; BufferPool * const pool = cm -> buffer_pool ; RefCntBuffer * const frame_bufs = pool -> frame_bufs ; int i , mask , ref_index = 0 ; <S2SV_ModStart> size_t sz ; <S2SV_ModEnd> cm -> last_frame_type <S2SV_ModStart> -> frame_type ; cm -> last_intra_only = cm -> intra_only ; if ( vpx_rb_read_literal <S2SV_ModEnd> ( rb , <S2SV_ModStart> -> profile = vp9_read_profile ( rb ) ; # if CONFIG_VP9_HIGHBITDEPTH <S2SV_ModEnd> if ( cm <S2SV_ModStart> ""Unsupported<S2SV_blank>bitstream<S2SV_blank>profile"" ) ; # else if ( cm -> profile >= PROFILE_2 ) vpx_internal_error ( & cm -> error , VPX_CODEC_UNSUP_BITSTREAM , ""Unsupported<S2SV_blank>bitstream<S2SV_blank>profile"" ) ; # endif <S2SV_ModStart> -> show_existing_frame = vpx_rb_read_bit <S2SV_ModEnd> ( rb ) <S2SV_ModStart> -> ref_frame_map [ vpx_rb_read_literal <S2SV_ModEnd> ( rb , <S2SV_ModStart> ) ] ; lock_buffer_pool ( pool ) ; if ( frame_to_show < 0 || <S2SV_ModEnd> frame_bufs [ frame_to_show <S2SV_ModStart> < 1 ) { unlock_buffer_pool ( pool ) ; <S2SV_ModStart> frame_to_show ) ; } ref_cnt_fb ( <S2SV_ModEnd> frame_bufs , & <S2SV_ModStart> new_fb_idx , frame_to_show ) ; unlock_buffer_pool ( pool <S2SV_ModStart> = 1 ; if ( pbi -> frame_parallel_decode ) { for ( i = 0 ; i < REF_FRAMES ; ++ i ) cm -> next_ref_frame_map [ i ] = cm -> ref_frame_map [ i ] ; } <S2SV_ModStart> ( FRAME_TYPE ) vpx_rb_read_bit <S2SV_ModEnd> ( rb ) <S2SV_ModStart> -> show_frame = vpx_rb_read_bit <S2SV_ModEnd> ( rb ) <S2SV_ModStart> -> error_resilient_mode = vpx_rb_read_bit <S2SV_ModEnd> ( rb ) <S2SV_ModStart> KEY_FRAME ) { if ( ! vp9_read_sync_code ( rb ) ) <S2SV_ModEnd> vpx_internal_error ( & <S2SV_ModStart> , VPX_CODEC_UNSUP_BITSTREAM , ""Invalid<S2SV_blank>frame<S2SV_blank>sync<S2SV_blank>code"" ) ; read_bitdepth_colorspace_sampling ( cm , rb ) ; <S2SV_ModEnd> pbi -> refresh_frame_flags <S2SV_ModStart> . idx = INVALID_IDX <S2SV_ModEnd> ; cm -> <S2SV_ModStart> . buf = NULL <S2SV_ModEnd> ; } setup_frame_size <S2SV_ModStart> rb ) ; if ( pbi -> need_resync ) { memset ( & cm -> ref_frame_map , - 1 , sizeof ( cm -> ref_frame_map ) ) ; pbi -> need_resync = 0 ; } <S2SV_ModStart> ? 0 : vpx_rb_read_bit <S2SV_ModEnd> ( rb ) <S2SV_ModStart> ? 0 : vpx_rb_read_literal <S2SV_ModEnd> ( rb , <S2SV_ModStart> intra_only ) { if ( ! vp9_read_sync_code ( rb ) ) vpx_internal_error ( & cm -> error , VPX_CODEC_UNSUP_BITSTREAM , ""Invalid<S2SV_blank>frame<S2SV_blank>sync<S2SV_blank>code"" ) ; if ( cm -> profile > PROFILE_0 ) { read_bitdepth_colorspace_sampling ( cm , rb ) ; } else { cm -> color_space = VPX_CS_BT_601 ; cm -> subsampling_y = cm -> subsampling_x = 1 ; cm -> bit_depth = VPX_BITS_8 ; # if CONFIG_VP9_HIGHBITDEPTH cm -> use_highbitdepth = 0 ; # endif } <S2SV_ModEnd> pbi -> refresh_frame_flags <S2SV_ModStart> -> refresh_frame_flags = vpx_rb_read_literal <S2SV_ModEnd> ( rb , <S2SV_ModStart> rb ) ; if ( pbi -> need_resync ) { memset ( & cm -> ref_frame_map , - 1 , sizeof ( cm -> ref_frame_map ) ) ; pbi -> need_resync = 0 ; } } else if ( pbi -> need_resync != 1 ) <S2SV_ModEnd> { pbi -> <S2SV_ModStart> -> refresh_frame_flags = vpx_rb_read_literal <S2SV_ModEnd> ( rb , <S2SV_ModStart> int ref = vpx_rb_read_literal <S2SV_ModEnd> ( rb , <S2SV_ModStart> ref ] ; RefBuffer * const ref_frame = & <S2SV_ModStart> [ i ] ; ref_frame -> <S2SV_ModEnd> idx = idx <S2SV_ModStart> = idx ; ref_frame -> buf = & frame_bufs [ idx <S2SV_ModEnd> ] . buf <S2SV_ModStart> ] . buf <S2SV_ModEnd> ; cm -> <S2SV_ModStart> i ] = vpx_rb_read_bit <S2SV_ModEnd> ( rb ) <S2SV_ModStart> -> allow_high_precision_mv = vpx_rb_read_bit <S2SV_ModEnd> ( rb ) <S2SV_ModStart> i ] ; # if CONFIG_VP9_HIGHBITDEPTH <S2SV_ModStart> cm -> height , cm -> use_highbitdepth ) ; # else vp9_setup_scale_factors_for_frame <S2SV_ModEnd> ( & ref_buf <S2SV_ModStart> ref_buf -> sf , <S2SV_ModEnd> ref_buf -> buf <S2SV_ModStart> ref_buf -> buf -> y_crop_width , ref_buf -> buf -> y_crop_height , cm -> width , cm -> height ) ; # endif } } } # if CONFIG_VP9_HIGHBITDEPTH get_frame_new_buffer ( cm ) -> bit_depth = cm -> bit_depth ; # endif get_frame_new_buffer ( cm ) -> color_space = cm -> color_space ; if ( pbi -> need_resync ) { vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , ""Keyframe<S2SV_blank>/<S2SV_blank>intra-only<S2SV_blank>frame<S2SV_blank>required<S2SV_blank>to<S2SV_blank>reset<S2SV_blank>decoder"" ""<S2SV_blank>state"" ) ; <S2SV_ModEnd> } if ( <S2SV_ModStart> { cm -> refresh_frame_context = vpx_rb_read_bit ( rb ) ; cm -> frame_parallel_decoding_mode = vpx_rb_read_bit ( rb ) ; } else { cm -> refresh_frame_context = 0 ; cm -> frame_parallel_decoding_mode <S2SV_ModEnd> = 1 ; <S2SV_ModStart> = 1 ; } cm -> frame_context_idx = vpx_rb_read_literal ( rb , FRAME_CONTEXTS_LOG2 ) ; lock_buffer_pool ( pool ) ; for ( mask = pbi -> refresh_frame_flags ; mask ; mask >>= 1 ) { if ( mask & 1 ) { cm -> next_ref_frame_map [ ref_index ] = cm -> new_fb_idx ; ++ frame_bufs [ cm -> new_fb_idx ] . ref_count <S2SV_ModEnd> ; } else <S2SV_ModStart> { cm -> next_ref_frame_map [ ref_index ] = cm -> ref_frame_map [ ref_index ] ; } if ( cm -> ref_frame_map [ ref_index ] >= 0 ) ++ frame_bufs [ cm -> ref_frame_map [ ref_index ] ] . ref_count ; ++ ref_index ; } for ( ; ref_index < REF_FRAMES ; ++ ref_index ) { cm -> next_ref_frame_map [ ref_index ] = cm -> ref_frame_map [ ref_index ] ; if ( cm -> ref_frame_map [ ref_index ] >= 0 ) ++ frame_bufs [ cm -> ref_frame_map [ ref_index ] ] . ref_count ; } unlock_buffer_pool ( pool ) ; pbi -> hold_ref_buf <S2SV_ModEnd> = 1 ; <S2SV_ModStart> = 1 ; <S2SV_ModEnd> if ( frame_is_intra_only <S2SV_ModStart> rb ) ; setup_segmentation_dequant ( cm ) ; <S2SV_ModStart> ; sz = vpx_rb_read_literal <S2SV_ModEnd> ( rb ,
"
527,"CWE-125 static void parse_hid_report_descriptor ( struct gtco * device , char * report , int length ) { struct device * ddev = & device -> intf -> dev ; int x , i = 0 ; __u8 prefix ; __u8 size ; __u8 tag ; __u8 type ; __u8 data = 0 ; __u16 data16 = 0 ; __u32 data32 = 0 ; int inputnum = 0 ; __u32 usage = 0 ; __u32 globalval [ TAG_GLOB_MAX ] ; __u32 oldval [ TAG_GLOB_MAX ] ; char maintype = 'x' ; char globtype [ 12 ] ; int indent = 0 ; char indentstr [ 10 ] = """" ; dev_dbg ( ddev , ""======>>>>>>PARSE<<<<<<======\\n"" ) ; while ( i < length ) { <S2SV_StartBug> prefix = report [ i ] ; <S2SV_EndBug> i ++ ; size = PREF_SIZE ( prefix ) ; switch ( size ) { case 1 : data = report [ i ] ; break ; case 2 : data16 = get_unaligned_le16 ( & report [ i ] ) ; break ; <S2SV_StartBug> case 3 : <S2SV_EndBug> size = 4 ; data32 = get_unaligned_le32 ( & report [ i ] ) ; break ; } i += size ; tag = PREF_TAG ( prefix ) ; type = PREF_TYPE ( prefix ) ; switch ( type ) { case TYPE_MAIN : strcpy ( globtype , """" ) ; switch ( tag ) { case TAG_MAIN_INPUT : maintype = 'I' ; if ( data == 2 ) strcpy ( globtype , ""Variable"" ) ; else if ( data == 3 ) strcpy ( globtype , ""Var|Const"" ) ; dev_dbg ( ddev , "":::::<S2SV_blank>Saving<S2SV_blank>Report:<S2SV_blank>%d<S2SV_blank>input<S2SV_blank>#%d<S2SV_blank>Max:<S2SV_blank>0x%X(%d)<S2SV_blank>Min:0x%X(%d)<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bits\\n"" , globalval [ TAG_GLOB_REPORT_ID ] , inputnum , globalval [ TAG_GLOB_LOG_MAX ] , globalval [ TAG_GLOB_LOG_MAX ] , globalval [ TAG_GLOB_LOG_MIN ] , globalval [ TAG_GLOB_LOG_MIN ] , globalval [ TAG_GLOB_REPORT_SZ ] * globalval [ TAG_GLOB_REPORT_CNT ] ) ; switch ( inputnum ) { case 0 : dev_dbg ( ddev , ""GER:<S2SV_blank>X<S2SV_blank>Usage:<S2SV_blank>0x%x\\n"" , usage ) ; if ( device -> max_X == 0 ) { device -> max_X = globalval [ TAG_GLOB_LOG_MAX ] ; device -> min_X = globalval [ TAG_GLOB_LOG_MIN ] ; } break ; case 1 : dev_dbg ( ddev , ""GER:<S2SV_blank>Y<S2SV_blank>Usage:<S2SV_blank>0x%x\\n"" , usage ) ; if ( device -> max_Y == 0 ) { device -> max_Y = globalval [ TAG_GLOB_LOG_MAX ] ; device -> min_Y = globalval [ TAG_GLOB_LOG_MIN ] ; } break ; default : if ( usage == DIGITIZER_USAGE_TILT_X ) { if ( device -> maxtilt_X == 0 ) { device -> maxtilt_X = globalval [ TAG_GLOB_LOG_MAX ] ; device -> mintilt_X = globalval [ TAG_GLOB_LOG_MIN ] ; } } if ( usage == DIGITIZER_USAGE_TILT_Y ) { if ( device -> maxtilt_Y == 0 ) { device -> maxtilt_Y = globalval [ TAG_GLOB_LOG_MAX ] ; device -> mintilt_Y = globalval [ TAG_GLOB_LOG_MIN ] ; } } if ( usage == DIGITIZER_USAGE_TIP_PRESSURE ) { if ( device -> maxpressure == 0 ) { device -> maxpressure = globalval [ TAG_GLOB_LOG_MAX ] ; device -> minpressure = globalval [ TAG_GLOB_LOG_MIN ] ; } } break ; } inputnum ++ ; break ; case TAG_MAIN_OUTPUT : maintype = 'O' ; break ; case TAG_MAIN_FEATURE : maintype = 'F' ; break ; case TAG_MAIN_COL_START : maintype = 'S' ; if ( data == 0 ) { dev_dbg ( ddev , ""======>>>>>><S2SV_blank>Physical\\n"" ) ; strcpy ( globtype , ""Physical"" ) ; } else dev_dbg ( ddev , ""======>>>>>>\\n"" ) ; indent ++ ; for ( x = 0 ; x < indent ; x ++ ) indentstr [ x ] = '-' ; indentstr [ x ] = 0 ; for ( x = 0 ; x < TAG_GLOB_MAX ; x ++ ) oldval [ x ] = globalval [ x ] ; break ; case TAG_MAIN_COL_END : dev_dbg ( ddev , ""<<<<<<======\\n"" ) ; maintype = 'E' ; indent -- ; for ( x = 0 ; x < indent ; x ++ ) indentstr [ x ] = '-' ; indentstr [ x ] = 0 ; for ( x = 0 ; x < TAG_GLOB_MAX ; x ++ ) globalval [ x ] = oldval [ x ] ; break ; } switch ( size ) { case 1 : dev_dbg ( ddev , ""%sMAINTAG:(%d)<S2SV_blank>%c<S2SV_blank>SIZE:<S2SV_blank>%d<S2SV_blank>Data:<S2SV_blank>%s<S2SV_blank>0x%x\\n"" , indentstr , tag , maintype , size , globtype , data ) ; break ; case 2 : dev_dbg ( ddev , ""%sMAINTAG:(%d)<S2SV_blank>%c<S2SV_blank>SIZE:<S2SV_blank>%d<S2SV_blank>Data:<S2SV_blank>%s<S2SV_blank>0x%x\\n"" , indentstr , tag , maintype , size , globtype , data16 ) ; break ; case 4 : dev_dbg ( ddev , ""%sMAINTAG:(%d)<S2SV_blank>%c<S2SV_blank>SIZE:<S2SV_blank>%d<S2SV_blank>Data:<S2SV_blank>%s<S2SV_blank>0x%x\\n"" , indentstr , tag , maintype , size , globtype , data32 ) ; break ; } break ; case TYPE_GLOBAL : switch ( tag ) { case TAG_GLOB_USAGE : if ( device -> usage == 0 ) device -> usage = data ; strcpy ( globtype , ""USAGE"" ) ; break ; case TAG_GLOB_LOG_MIN : strcpy ( globtype , ""LOG_MIN"" ) ; break ; case TAG_GLOB_LOG_MAX : strcpy ( globtype , ""LOG_MAX"" ) ; break ; case TAG_GLOB_PHYS_MIN : strcpy ( globtype , ""PHYS_MIN"" ) ; break ; case TAG_GLOB_PHYS_MAX : strcpy ( globtype , ""PHYS_MAX"" ) ; break ; case TAG_GLOB_UNIT_EXP : strcpy ( globtype , ""EXP"" ) ; break ; case TAG_GLOB_UNIT : strcpy ( globtype , ""UNIT"" ) ; break ; case TAG_GLOB_REPORT_SZ : strcpy ( globtype , ""REPORT_SZ"" ) ; break ; case TAG_GLOB_REPORT_ID : strcpy ( globtype , ""REPORT_ID"" ) ; inputnum = 0 ; break ; case TAG_GLOB_REPORT_CNT : strcpy ( globtype , ""REPORT_CNT"" ) ; break ; case TAG_GLOB_PUSH : strcpy ( globtype , ""PUSH"" ) ; break ; case TAG_GLOB_POP : strcpy ( globtype , ""POP"" ) ; break ; } if ( tag < TAG_GLOB_MAX ) { switch ( size ) { case 1 : dev_dbg ( ddev , ""%sGLOBALTAG:%s(%d)<S2SV_blank>SIZE:<S2SV_blank>%d<S2SV_blank>Data:<S2SV_blank>0x%x\\n"" , indentstr , globtype , tag , size , data ) ; globalval [ tag ] = data ; break ; case 2 : dev_dbg ( ddev , ""%sGLOBALTAG:%s(%d)<S2SV_blank>SIZE:<S2SV_blank>%d<S2SV_blank>Data:<S2SV_blank>0x%x\\n"" , indentstr , globtype , tag , size , data16 ) ; globalval [ tag ] = data16 ; break ; case 4 : dev_dbg ( ddev , ""%sGLOBALTAG:%s(%d)<S2SV_blank>SIZE:<S2SV_blank>%d<S2SV_blank>Data:<S2SV_blank>0x%x\\n"" , indentstr , globtype , tag , size , data32 ) ; globalval [ tag ] = data32 ; break ; } } else { dev_dbg ( ddev , ""%sGLOBALTAG:<S2SV_blank>ILLEGAL<S2SV_blank>TAG:%d<S2SV_blank>SIZE:<S2SV_blank>%d\\n"" , indentstr , tag , size ) ; } break ; case TYPE_LOCAL : switch ( tag ) { case TAG_GLOB_USAGE : strcpy ( globtype , ""USAGE"" ) ; usage = data ; break ; case TAG_GLOB_LOG_MIN : strcpy ( globtype , ""MIN"" ) ; break ; case TAG_GLOB_LOG_MAX : strcpy ( globtype , ""MAX"" ) ; break ; default : strcpy ( globtype , ""UNKNOWN"" ) ; break ; } switch ( size ) { case 1 : dev_dbg ( ddev , ""%sLOCALTAG:(%d)<S2SV_blank>%s<S2SV_blank>SIZE:<S2SV_blank>%d<S2SV_blank>Data:<S2SV_blank>0x%x\\n"" , indentstr , tag , globtype , size , data ) ; break ; case 2 : dev_dbg ( ddev , ""%sLOCALTAG:(%d)<S2SV_blank>%s<S2SV_blank>SIZE:<S2SV_blank>%d<S2SV_blank>Data:<S2SV_blank>0x%x\\n"" , indentstr , tag , globtype , size , data16 ) ; break ; case 4 : dev_dbg ( ddev , ""%sLOCALTAG:(%d)<S2SV_blank>%s<S2SV_blank>SIZE:<S2SV_blank>%d<S2SV_blank>Data:<S2SV_blank>0x%x\\n"" , indentstr , tag , globtype , size , data32 ) ; break ; } break ; } } }
","<S2SV_ModStart> report [ i ++ ] ; size = ( 1U << PREF_SIZE ( prefix ) ) >> 1 ; if ( i + size > length ) { dev_err ( ddev , ""Not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>(need<S2SV_blank>%d,<S2SV_blank>have<S2SV_blank>%d)\\n"" , i + size , length ) ; break ; } <S2SV_ModEnd> switch ( size <S2SV_ModStart> break ; case 4 : <S2SV_ModEnd> data32 = get_unaligned_le32
"
528,"CWE-119 static int rc_pick_q_and_bounds_one_pass_vbr ( const VP9_COMP * cpi , int * bottom_index , int * top_index ) { const VP9_COMMON * const cm = & cpi -> common ; const RATE_CONTROL * const rc = & cpi -> rc ; <S2SV_StartBug> const VP9_CONFIG * const oxcf = & cpi -> oxcf ; <S2SV_EndBug> <S2SV_StartBug> int active_best_quality ; <S2SV_EndBug> int active_worst_quality = calc_active_worst_quality_one_pass_vbr ( cpi ) ; int q ; <S2SV_StartBug> if ( frame_is_intra_only ( cm ) ) { <S2SV_EndBug> <S2SV_StartBug> active_best_quality = rc -> best_quality ; <S2SV_EndBug> # if ! CONFIG_MULTIPLE_ARF if ( rc -> this_key_frame_forced ) { int qindex = rc -> last_boosted_qindex ; <S2SV_StartBug> double last_boosted_q = vp9_convert_qindex_to_q ( qindex ) ; <S2SV_EndBug> int delta_qindex = vp9_compute_qdelta ( rc , last_boosted_q , <S2SV_StartBug> last_boosted_q * 0.75 ) ; <S2SV_EndBug> active_best_quality = MAX ( qindex + delta_qindex , rc -> best_quality ) ; <S2SV_StartBug> } else if ( cm -> current_video_frame > 0 ) { <S2SV_EndBug> double q_adj_factor = 1.0 ; double q_val ; <S2SV_StartBug> active_best_quality = get_active_quality ( rc -> avg_frame_qindex [ KEY_FRAME ] , <S2SV_EndBug> <S2SV_StartBug> rc -> kf_boost , <S2SV_EndBug> kf_low , kf_high , kf_low_motion_minq , kf_high_motion_minq ) ; if ( ( cm -> width * cm -> height ) <= ( 352 * 288 ) ) { q_adj_factor -= 0.25 ; } <S2SV_StartBug> q_val = vp9_convert_qindex_to_q ( active_best_quality ) ; <S2SV_EndBug> active_best_quality += vp9_compute_qdelta ( rc , q_val , <S2SV_StartBug> q_val * q_adj_factor ) ; <S2SV_EndBug> } # else double current_q ; current_q = vp9_convert_qindex_to_q ( active_worst_quality ) ; active_best_quality = active_worst_quality + vp9_compute_qdelta ( rc , current_q , current_q * 0.3 ) ; # endif } else if ( ! rc -> is_src_frame_alt_ref && ( cpi -> refresh_golden_frame || cpi -> refresh_alt_ref_frame ) ) { if ( rc -> frames_since_key > 1 && rc -> avg_frame_qindex [ INTER_FRAME ] < active_worst_quality ) { q = rc -> avg_frame_qindex [ INTER_FRAME ] ; } else { q = rc -> avg_frame_qindex [ KEY_FRAME ] ; } <S2SV_StartBug> if ( oxcf -> end_usage == USAGE_CONSTRAINED_QUALITY ) { <S2SV_EndBug> <S2SV_StartBug> if ( q < cpi -> cq_target_quality ) <S2SV_EndBug> q = cpi -> cq_target_quality ; if ( rc -> frames_since_key > 1 ) { active_best_quality = get_active_quality ( q , rc -> gfu_boost , gf_low , gf_high , afq_low_motion_minq , afq_high_motion_minq ) ; } else { active_best_quality = get_active_quality ( q , rc -> gfu_boost , gf_low , gf_high , gf_low_motion_minq , gf_high_motion_minq ) ; } active_best_quality = active_best_quality * 15 / 16 ; <S2SV_StartBug> } else if ( oxcf -> end_usage == USAGE_CONSTANT_QUALITY ) { <S2SV_EndBug> if ( ! cpi -> refresh_alt_ref_frame ) { <S2SV_StartBug> active_best_quality = cpi -> cq_target_quality ; <S2SV_EndBug> } else { if ( rc -> frames_since_key > 1 ) { active_best_quality = get_active_quality ( q , rc -> gfu_boost , gf_low , gf_high , afq_low_motion_minq , afq_high_motion_minq ) ; } else { active_best_quality = get_active_quality ( q , rc -> gfu_boost , gf_low , gf_high , gf_low_motion_minq , gf_high_motion_minq ) ; } } } else { active_best_quality = get_active_quality ( q , rc -> gfu_boost , gf_low , gf_high , gf_low_motion_minq , gf_high_motion_minq ) ; } } else { <S2SV_StartBug> if ( oxcf -> end_usage == USAGE_CONSTANT_QUALITY ) { <S2SV_EndBug> active_best_quality = cpi -> cq_target_quality ; } else { if ( cm -> current_video_frame > 1 ) active_best_quality = inter_minq [ rc -> avg_frame_qindex [ INTER_FRAME ] ] ; else active_best_quality = inter_minq [ rc -> avg_frame_qindex [ KEY_FRAME ] ] ; <S2SV_StartBug> if ( ( oxcf -> end_usage == USAGE_CONSTRAINED_QUALITY ) && <S2SV_EndBug> <S2SV_StartBug> ( active_best_quality < cpi -> cq_target_quality ) ) { <S2SV_EndBug> if ( rc -> rolling_actual_bits < rc -> min_frame_bandwidth ) active_best_quality = oxcf -> cq_level ; else active_best_quality = cpi -> cq_target_quality ; } } } active_best_quality = clamp ( active_best_quality , rc -> best_quality , rc -> worst_quality ) ; active_worst_quality = clamp ( active_worst_quality , active_best_quality , rc -> worst_quality ) ; * top_index = active_worst_quality ; * bottom_index = active_best_quality ; <S2SV_StartBug> # if LIMIT_QRANGE_FOR_ALTREF_AND_KEY <S2SV_EndBug> <S2SV_StartBug> if ( cm -> frame_type == KEY_FRAME && ! rc -> this_key_frame_forced ) { <S2SV_EndBug> if ( ! ( cm -> current_video_frame == 0 ) ) <S2SV_StartBug> * top_index = ( active_worst_quality + active_best_quality * 3 ) / 4 ; <S2SV_EndBug> } else if ( ! rc -> is_src_frame_alt_ref && ( cpi -> refresh_golden_frame || cpi -> refresh_alt_ref_frame ) ) { * top_index = ( active_worst_quality + active_best_quality ) / 2 ; } # endif <S2SV_StartBug> if ( oxcf -> end_usage == USAGE_CONSTANT_QUALITY ) { <S2SV_EndBug> q = active_best_quality ; } else if ( ( cm -> frame_type == KEY_FRAME ) && rc -> this_key_frame_forced ) { q = rc -> last_boosted_qindex ; } else { q = vp9_rc_regulate_q ( cpi , rc -> this_frame_target , active_best_quality , active_worst_quality ) ; if ( q > * top_index ) { if ( rc -> this_frame_target >= rc -> max_frame_bandwidth ) * top_index = q ; else q = * top_index ; } } <S2SV_StartBug> # if CONFIG_MULTIPLE_ARF <S2SV_EndBug> if ( cpi -> multi_arf_enabled && ( cm -> frame_type != KEY_FRAME ) && cpi -> oxcf . end_usage != USAGE_CONSTANT_QUALITY ) { double new_q ; double current_q = vp9_convert_qindex_to_q ( active_worst_quality ) ; int level = cpi -> this_frame_weight ; assert ( level >= 0 ) ; new_q = current_q * ( 1.0 - ( 0.2 * ( cpi -> max_arf_level - level ) ) ) ; q = active_worst_quality + vp9_compute_qdelta ( rc , current_q , new_q ) ; * bottom_index = q ; * top_index = q ; printf ( ""frame:%d<S2SV_blank>q:%d\\n"" , cm -> current_video_frame , q ) ; } # endif assert ( * top_index <= rc -> worst_quality && * top_index >= rc -> best_quality ) ; assert ( * bottom_index <= rc -> worst_quality && * bottom_index >= rc -> best_quality ) ; assert ( q <= rc -> worst_quality && q >= rc -> best_quality ) ; return q ; }
","<S2SV_ModStart> rc ; const VP9EncoderConfig <S2SV_ModEnd> * const oxcf <S2SV_ModStart> -> oxcf ; const int cq_level = get_active_cq_level ( rc , oxcf ) ; <S2SV_ModStart> int q ; int * inter_minq ; ASSIGN_MINQ_TABLE ( cm -> bit_depth , inter_minq ) ; <S2SV_ModStart> ) ) { <S2SV_ModEnd> if ( rc <S2SV_ModStart> vp9_convert_qindex_to_q ( qindex , cm -> bit_depth <S2SV_ModStart> last_boosted_q * 0.75 , cm -> bit_depth <S2SV_ModStart> ; } else <S2SV_ModEnd> { double q_adj_factor <S2SV_ModStart> ; active_best_quality = get_kf_active_quality ( rc , <S2SV_ModEnd> rc -> avg_frame_qindex <S2SV_ModStart> KEY_FRAME ] , cm -> bit_depth <S2SV_ModEnd> ) ; if <S2SV_ModStart> vp9_convert_qindex_to_q ( active_best_quality , cm -> bit_depth <S2SV_ModStart> q_val * q_adj_factor , cm -> bit_depth ) ; } <S2SV_ModEnd> } else if <S2SV_ModStart> ( oxcf -> rc_mode == VPX_CQ <S2SV_ModEnd> ) { if <S2SV_ModStart> ( q < cq_level ) q = cq_level ; active_best_quality = get_gf_active_quality ( rc , q , cm -> bit_depth ) ; <S2SV_ModEnd> active_best_quality = active_best_quality <S2SV_ModStart> ( oxcf -> rc_mode == VPX_Q <S2SV_ModEnd> ) { if <S2SV_ModStart> { active_best_quality = cq_level ; } else { active_best_quality = get_gf_active_quality ( rc , q , cm -> bit_depth ) ; } } else { active_best_quality = get_gf_active_quality ( rc , q , cm -> bit_depth <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( oxcf -> rc_mode == VPX_Q ) { active_best_quality = cq_level <S2SV_ModEnd> ; } else <S2SV_ModStart> ( oxcf -> rc_mode == VPX_CQ <S2SV_ModEnd> ) && ( <S2SV_ModStart> ( active_best_quality < cq_level ) ) { active_best_quality = cq_level <S2SV_ModEnd> ; } } <S2SV_ModStart> # if LIMIT_QRANGE_FOR_ALTREF_AND_KEY { int qdelta = 0 ; vpx_clear_system_state ( ) ; <S2SV_ModStart> rc -> this_key_frame_forced && <S2SV_ModEnd> ! ( cm <S2SV_ModStart> 0 ) ) { qdelta = vp9_compute_qdelta_by_rate ( & cpi -> rc , cm -> frame_type , active_worst_quality , 2.0 , cm -> bit_depth ) ; } else if ( ! rc -> is_src_frame_alt_ref && ( cpi -> refresh_golden_frame || cpi -> refresh_alt_ref_frame ) ) { qdelta = vp9_compute_qdelta_by_rate ( & cpi -> rc , cm -> frame_type , active_worst_quality , 1.75 , cm -> bit_depth ) ; } * top_index = active_worst_quality + qdelta ; * top_index = ( * top_index > * bottom_index ) ? * top_index : * bottom_index <S2SV_ModEnd> ; } # <S2SV_ModStart> ( oxcf -> rc_mode == VPX_Q <S2SV_ModEnd> ) { q <S2SV_ModStart> ; } } <S2SV_ModEnd> assert ( *
"
529,"CWE-125 char * Ta3Tokenizer_FindEncodingFilename ( int fd , PyObject * filename ) { struct tok_state * tok ; FILE * fp ; char * p_start = NULL , * p_end = NULL , * encoding = NULL ; # ifndef PGEN <S2SV_StartBug> # if PY_MINOR_VERSION >= 4 <S2SV_EndBug> fd = _Py_dup ( fd ) ; <S2SV_StartBug> # endif <S2SV_EndBug> # else fd = dup ( fd ) ; # endif if ( fd < 0 ) { return NULL ; } fp = fdopen ( fd , ""r"" ) ; if ( fp == NULL ) { return NULL ; } tok = Ta3Tokenizer_FromFile ( fp , NULL , NULL , NULL ) ; if ( tok == NULL ) { fclose ( fp ) ; return NULL ; } # ifndef PGEN if ( filename != NULL ) { Py_INCREF ( filename ) ; tok -> filename = filename ; } else { tok -> filename = PyUnicode_FromString ( ""<string>"" ) ; if ( tok -> filename == NULL ) { fclose ( fp ) ; Ta3Tokenizer_Free ( tok ) ; return encoding ; } } # endif while ( tok -> lineno < 2 && tok -> done == E_OK ) { Ta3Tokenizer_Get ( tok , & p_start , & p_end ) ; } fclose ( fp ) ; if ( tok -> encoding ) { encoding = ( char * ) PyMem_MALLOC ( strlen ( tok -> encoding ) + 1 ) ; if ( encoding ) strcpy ( encoding , tok -> encoding ) ; } Ta3Tokenizer_Free ( tok ) ; return encoding ; }
","<S2SV_ModStart> # ifndef PGEN <S2SV_ModEnd> fd = _Py_dup <S2SV_ModStart> fd ) ; <S2SV_ModEnd> # else fd
"
530,"CWE-189 void bpf_jit_compile ( struct sk_filter * fp ) { u8 temp [ 64 ] ; u8 * prog ; unsigned int proglen , oldproglen = 0 ; int ilen , i ; int t_offset , f_offset ; u8 t_op , f_op , seen = 0 , pass ; u8 * image = NULL ; u8 * func ; int pc_ret0 = - 1 ; unsigned int cleanup_addr ; unsigned int * addrs ; const struct sock_filter * filter = fp -> insns ; int flen = fp -> len ; if ( ! bpf_jit_enable ) return ; addrs = kmalloc ( flen * sizeof ( * addrs ) , GFP_KERNEL ) ; if ( addrs == NULL ) return ; for ( proglen = 0 , i = 0 ; i < flen ; i ++ ) { proglen += 64 ; addrs [ i ] = proglen ; } cleanup_addr = proglen ; for ( pass = 0 ; pass < 10 ; pass ++ ) { proglen = 0 ; prog = temp ; if ( seen ) { EMIT4 ( 0x55 , 0x48 , 0x89 , 0xe5 ) ; EMIT4 ( 0x48 , 0x83 , 0xec , 96 ) ; if ( seen & ( SEEN_XREG | SEEN_DATAREF ) ) EMIT4 ( 0x48 , 0x89 , 0x5d , 0xf8 ) ; if ( seen & SEEN_XREG ) CLEAR_X ( ) ; if ( seen & SEEN_DATAREF ) { if ( offsetof ( struct sk_buff , len ) <= 127 ) EMIT4 ( 0x44 , 0x8b , 0x4f , offsetof ( struct sk_buff , len ) ) ; else { EMIT3 ( 0x44 , 0x8b , 0x8f ) ; EMIT ( offsetof ( struct sk_buff , len ) , 4 ) ; } if ( is_imm8 ( offsetof ( struct sk_buff , data_len ) ) ) EMIT4 ( 0x44 , 0x2b , 0x4f , offsetof ( struct sk_buff , data_len ) ) ; else { EMIT3 ( 0x44 , 0x2b , 0x8f ) ; EMIT ( offsetof ( struct sk_buff , data_len ) , 4 ) ; } if ( is_imm8 ( offsetof ( struct sk_buff , data ) ) ) EMIT4 ( 0x4c , 0x8b , 0x47 , offsetof ( struct sk_buff , data ) ) ; else { EMIT3 ( 0x4c , 0x8b , 0x87 ) ; EMIT ( offsetof ( struct sk_buff , data ) , 4 ) ; } } } switch ( filter [ 0 ] . code ) { case BPF_S_RET_K : case BPF_S_LD_W_LEN : case BPF_S_ANC_PROTOCOL : case BPF_S_ANC_IFINDEX : case BPF_S_ANC_MARK : case BPF_S_ANC_RXHASH : case BPF_S_ANC_CPU : case BPF_S_ANC_QUEUE : case BPF_S_LD_W_ABS : case BPF_S_LD_H_ABS : case BPF_S_LD_B_ABS : break ; default : CLEAR_A ( ) ; } for ( i = 0 ; i < flen ; i ++ ) { unsigned int K = filter [ i ] . k ; switch ( filter [ i ] . code ) { case BPF_S_ALU_ADD_X : seen |= SEEN_XREG ; EMIT2 ( 0x01 , 0xd8 ) ; break ; case BPF_S_ALU_ADD_K : if ( ! K ) break ; if ( is_imm8 ( K ) ) EMIT3 ( 0x83 , 0xc0 , K ) ; else EMIT1_off32 ( 0x05 , K ) ; break ; case BPF_S_ALU_SUB_X : seen |= SEEN_XREG ; EMIT2 ( 0x29 , 0xd8 ) ; break ; case BPF_S_ALU_SUB_K : if ( ! K ) break ; if ( is_imm8 ( K ) ) EMIT3 ( 0x83 , 0xe8 , K ) ; else EMIT1_off32 ( 0x2d , K ) ; break ; case BPF_S_ALU_MUL_X : seen |= SEEN_XREG ; EMIT3 ( 0x0f , 0xaf , 0xc3 ) ; break ; case BPF_S_ALU_MUL_K : if ( is_imm8 ( K ) ) EMIT3 ( 0x6b , 0xc0 , K ) ; else { EMIT2 ( 0x69 , 0xc0 ) ; EMIT ( K , 4 ) ; } break ; case BPF_S_ALU_DIV_X : seen |= SEEN_XREG ; EMIT2 ( 0x85 , 0xdb ) ; if ( pc_ret0 != - 1 ) EMIT_COND_JMP ( X86_JE , addrs [ pc_ret0 ] - ( addrs [ i ] - 4 ) ) ; else { EMIT_COND_JMP ( X86_JNE , 2 + 5 ) ; CLEAR_A ( ) ; EMIT1_off32 ( 0xe9 , cleanup_addr - ( addrs [ i ] - 4 ) ) ; } EMIT4 ( 0x31 , 0xd2 , 0xf7 , 0xf3 ) ; break ; case BPF_S_ALU_DIV_K : EMIT3 ( 0x48 , 0x69 , 0xc0 ) ; EMIT ( K , 4 ) ; EMIT4 ( 0x48 , 0xc1 , 0xe8 , 0x20 ) ; break ; case BPF_S_ALU_AND_X : seen |= SEEN_XREG ; EMIT2 ( 0x21 , 0xd8 ) ; break ; case BPF_S_ALU_AND_K : if ( K >= 0xFFFFFF00 ) { EMIT2 ( 0x24 , K & 0xFF ) ; } else if ( K >= 0xFFFF0000 ) { EMIT2 ( 0x66 , 0x25 ) ; EMIT2 ( K , 2 ) ; } else { EMIT1_off32 ( 0x25 , K ) ; } break ; case BPF_S_ALU_OR_X : seen |= SEEN_XREG ; EMIT2 ( 0x09 , 0xd8 ) ; break ; case BPF_S_ALU_OR_K : if ( is_imm8 ( K ) ) EMIT3 ( 0x83 , 0xc8 , K ) ; else EMIT1_off32 ( 0x0d , K ) ; break ; case BPF_S_ALU_LSH_X : seen |= SEEN_XREG ; EMIT4 ( 0x89 , 0xd9 , 0xd3 , 0xe0 ) ; break ; case BPF_S_ALU_LSH_K : if ( K == 0 ) break ; else if ( K == 1 ) EMIT2 ( 0xd1 , 0xe0 ) ; else EMIT3 ( 0xc1 , 0xe0 , K ) ; break ; case BPF_S_ALU_RSH_X : seen |= SEEN_XREG ; EMIT4 ( 0x89 , 0xd9 , 0xd3 , 0xe8 ) ; break ; case BPF_S_ALU_RSH_K : if ( K == 0 ) break ; else if ( K == 1 ) EMIT2 ( 0xd1 , 0xe8 ) ; else EMIT3 ( 0xc1 , 0xe8 , K ) ; break ; case BPF_S_ALU_NEG : EMIT2 ( 0xf7 , 0xd8 ) ; break ; case BPF_S_RET_K : if ( ! K ) { if ( pc_ret0 == - 1 ) pc_ret0 = i ; CLEAR_A ( ) ; } else { EMIT1_off32 ( 0xb8 , K ) ; } case BPF_S_RET_A : if ( seen ) { if ( i != flen - 1 ) { EMIT_JMP ( cleanup_addr - addrs [ i ] ) ; break ; } if ( seen & SEEN_XREG ) EMIT4 ( 0x48 , 0x8b , 0x5d , 0xf8 ) ; EMIT1 ( 0xc9 ) ; } EMIT1 ( 0xc3 ) ; break ; case BPF_S_MISC_TAX : seen |= SEEN_XREG ; EMIT2 ( 0x89 , 0xc3 ) ; break ; case BPF_S_MISC_TXA : seen |= SEEN_XREG ; EMIT2 ( 0x89 , 0xd8 ) ; break ; case BPF_S_LD_IMM : if ( ! K ) CLEAR_A ( ) ; else EMIT1_off32 ( 0xb8 , K ) ; break ; case BPF_S_LDX_IMM : seen |= SEEN_XREG ; if ( ! K ) CLEAR_X ( ) ; else EMIT1_off32 ( 0xbb , K ) ; break ; case BPF_S_LD_MEM : seen |= SEEN_MEM ; EMIT3 ( 0x8b , 0x45 , 0xf0 - K * 4 ) ; break ; case BPF_S_LDX_MEM : seen |= SEEN_XREG | SEEN_MEM ; EMIT3 ( 0x8b , 0x5d , 0xf0 - K * 4 ) ; break ; case BPF_S_ST : seen |= SEEN_MEM ; EMIT3 ( 0x89 , 0x45 , 0xf0 - K * 4 ) ; break ; case BPF_S_STX : seen |= SEEN_XREG | SEEN_MEM ; EMIT3 ( 0x89 , 0x5d , 0xf0 - K * 4 ) ; break ; case BPF_S_LD_W_LEN : BUILD_BUG_ON ( FIELD_SIZEOF ( struct sk_buff , len ) != 4 ) ; if ( is_imm8 ( offsetof ( struct sk_buff , len ) ) ) EMIT3 ( 0x8b , 0x47 , offsetof ( struct sk_buff , len ) ) ; else { EMIT2 ( 0x8b , 0x87 ) ; EMIT ( offsetof ( struct sk_buff , len ) , 4 ) ; } break ; case BPF_S_LDX_W_LEN : seen |= SEEN_XREG ; if ( is_imm8 ( offsetof ( struct sk_buff , len ) ) ) EMIT3 ( 0x8b , 0x5f , offsetof ( struct sk_buff , len ) ) ; else { EMIT2 ( 0x8b , 0x9f ) ; EMIT ( offsetof ( struct sk_buff , len ) , 4 ) ; } break ; case BPF_S_ANC_PROTOCOL : BUILD_BUG_ON ( FIELD_SIZEOF ( struct sk_buff , protocol ) != 2 ) ; if ( is_imm8 ( offsetof ( struct sk_buff , protocol ) ) ) { EMIT4 ( 0x0f , 0xb7 , 0x47 , offsetof ( struct sk_buff , protocol ) ) ; } else { EMIT3 ( 0x0f , 0xb7 , 0x87 ) ; EMIT ( offsetof ( struct sk_buff , protocol ) , 4 ) ; } EMIT2 ( 0x86 , 0xc4 ) ; break ; case BPF_S_ANC_IFINDEX : if ( is_imm8 ( offsetof ( struct sk_buff , dev ) ) ) { EMIT4 ( 0x48 , 0x8b , 0x47 , offsetof ( struct sk_buff , dev ) ) ; } else { EMIT3 ( 0x48 , 0x8b , 0x87 ) ; EMIT ( offsetof ( struct sk_buff , dev ) , 4 ) ; } EMIT3 ( 0x48 , 0x85 , 0xc0 ) ; EMIT_COND_JMP ( X86_JE , cleanup_addr - ( addrs [ i ] - 6 ) ) ; BUILD_BUG_ON ( FIELD_SIZEOF ( struct net_device , ifindex ) != 4 ) ; EMIT2 ( 0x8b , 0x80 ) ; EMIT ( offsetof ( struct net_device , ifindex ) , 4 ) ; break ; case BPF_S_ANC_MARK : BUILD_BUG_ON ( FIELD_SIZEOF ( struct sk_buff , mark ) != 4 ) ; if ( is_imm8 ( offsetof ( struct sk_buff , mark ) ) ) { EMIT3 ( 0x8b , 0x47 , offsetof ( struct sk_buff , mark ) ) ; } else { EMIT2 ( 0x8b , 0x87 ) ; EMIT ( offsetof ( struct sk_buff , mark ) , 4 ) ; } break ; case BPF_S_ANC_RXHASH : BUILD_BUG_ON ( FIELD_SIZEOF ( struct sk_buff , rxhash ) != 4 ) ; if ( is_imm8 ( offsetof ( struct sk_buff , rxhash ) ) ) { EMIT3 ( 0x8b , 0x47 , offsetof ( struct sk_buff , rxhash ) ) ; } else { EMIT2 ( 0x8b , 0x87 ) ; EMIT ( offsetof ( struct sk_buff , rxhash ) , 4 ) ; } break ; case BPF_S_ANC_QUEUE : BUILD_BUG_ON ( FIELD_SIZEOF ( struct sk_buff , queue_mapping ) != 2 ) ; if ( is_imm8 ( offsetof ( struct sk_buff , queue_mapping ) ) ) { EMIT4 ( 0x0f , 0xb7 , 0x47 , offsetof ( struct sk_buff , queue_mapping ) ) ; } else { EMIT3 ( 0x0f , 0xb7 , 0x87 ) ; EMIT ( offsetof ( struct sk_buff , queue_mapping ) , 4 ) ; } break ; case BPF_S_ANC_CPU : # ifdef CONFIG_SMP EMIT4 ( 0x65 , 0x8b , 0x04 , 0x25 ) ; EMIT ( ( u32 ) ( unsigned long ) & cpu_number , 4 ) ; # else CLEAR_A ( ) ; # endif break ; case BPF_S_LD_W_ABS : func = sk_load_word ; common_load : seen |= SEEN_DATAREF ; if ( ( int ) K < 0 ) goto out ; t_offset = func - ( image + addrs [ i ] ) ; EMIT1_off32 ( 0xbe , K ) ; EMIT1_off32 ( 0xe8 , t_offset ) ; break ; case BPF_S_LD_H_ABS : func = sk_load_half ; goto common_load ; case BPF_S_LD_B_ABS : func = sk_load_byte ; goto common_load ; case BPF_S_LDX_B_MSH : if ( ( int ) K < 0 ) { if ( pc_ret0 != - 1 ) { EMIT_JMP ( addrs [ pc_ret0 ] - addrs [ i ] ) ; break ; } CLEAR_A ( ) ; EMIT_JMP ( cleanup_addr - addrs [ i ] ) ; break ; } seen |= SEEN_DATAREF | SEEN_XREG ; t_offset = sk_load_byte_msh - ( image + addrs [ i ] ) ; EMIT1_off32 ( 0xbe , K ) ; EMIT1_off32 ( 0xe8 , t_offset ) ; break ; case BPF_S_LD_W_IND : func = sk_load_word_ind ; common_load_ind : seen |= SEEN_DATAREF | SEEN_XREG ; t_offset = func - ( image + addrs [ i ] ) ; EMIT1_off32 ( 0xbe , K ) ; EMIT1_off32 ( 0xe8 , t_offset ) ; break ; case BPF_S_LD_H_IND : func = sk_load_half_ind ; goto common_load_ind ; case BPF_S_LD_B_IND : func = sk_load_byte_ind ; goto common_load_ind ; case BPF_S_JMP_JA : t_offset = addrs [ i + K ] - addrs [ i ] ; EMIT_JMP ( t_offset ) ; break ; COND_SEL ( BPF_S_JMP_JGT_K , X86_JA , X86_JBE ) ; COND_SEL ( BPF_S_JMP_JGE_K , X86_JAE , X86_JB ) ; COND_SEL ( BPF_S_JMP_JEQ_K , X86_JE , X86_JNE ) ; COND_SEL ( BPF_S_JMP_JSET_K , X86_JNE , X86_JE ) ; COND_SEL ( BPF_S_JMP_JGT_X , X86_JA , X86_JBE ) ; COND_SEL ( BPF_S_JMP_JGE_X , X86_JAE , X86_JB ) ; COND_SEL ( BPF_S_JMP_JEQ_X , X86_JE , X86_JNE ) ; COND_SEL ( BPF_S_JMP_JSET_X , X86_JNE , X86_JE ) ; cond_branch : f_offset = addrs [ i + filter [ i ] . jf ] - addrs [ i ] ; t_offset = addrs [ i + filter [ i ] . jt ] - addrs [ i ] ; if ( filter [ i ] . jt == filter [ i ] . jf ) { EMIT_JMP ( t_offset ) ; break ; } switch ( filter [ i ] . code ) { case BPF_S_JMP_JGT_X : case BPF_S_JMP_JGE_X : case BPF_S_JMP_JEQ_X : seen |= SEEN_XREG ; EMIT2 ( 0x39 , 0xd8 ) ; break ; case BPF_S_JMP_JSET_X : seen |= SEEN_XREG ; EMIT2 ( 0x85 , 0xd8 ) ; break ; case BPF_S_JMP_JEQ_K : if ( K == 0 ) { EMIT2 ( 0x85 , 0xc0 ) ; break ; } case BPF_S_JMP_JGT_K : case BPF_S_JMP_JGE_K : if ( K <= 127 ) EMIT3 ( 0x83 , 0xf8 , K ) ; else EMIT1_off32 ( 0x3d , K ) ; break ; case BPF_S_JMP_JSET_K : if ( K <= 0xFF ) EMIT2 ( 0xa8 , K ) ; else if ( ! ( K & 0xFFFF00FF ) ) EMIT3 ( 0xf6 , 0xc4 , K >> 8 ) ; else if ( K <= 0xFFFF ) { EMIT2 ( 0x66 , 0xa9 ) ; EMIT ( K , 2 ) ; } else { EMIT1_off32 ( 0xa9 , K ) ; } break ; } if ( filter [ i ] . jt != 0 ) { <S2SV_StartBug> if ( filter [ i ] . jf ) <S2SV_EndBug> <S2SV_StartBug> t_offset += is_near ( f_offset ) ? 2 : 6 ; <S2SV_EndBug> EMIT_COND_JMP ( t_op , t_offset ) ; if ( filter [ i ] . jf ) EMIT_JMP ( f_offset ) ; break ; } EMIT_COND_JMP ( f_op , f_offset ) ; break ; default : goto out ; } ilen = prog - temp ; if ( image ) { if ( unlikely ( proglen + ilen > oldproglen ) ) { pr_err ( ""bpb_jit_compile<S2SV_blank>fatal<S2SV_blank>error\\n"" ) ; kfree ( addrs ) ; module_free ( NULL , image ) ; return ; } memcpy ( image + proglen , temp , ilen ) ; } proglen += ilen ; addrs [ i ] = proglen ; prog = temp ; } cleanup_addr = proglen - 1 ; if ( seen ) cleanup_addr -= 1 ; if ( seen & SEEN_XREG ) cleanup_addr -= 4 ; if ( image ) { WARN_ON ( proglen != oldproglen ) ; break ; } if ( proglen == oldproglen ) { image = module_alloc ( max_t ( unsigned int , proglen , sizeof ( struct work_struct ) ) ) ; if ( ! image ) goto out ; } oldproglen = proglen ; } if ( bpf_jit_enable > 1 ) pr_err ( ""flen=%d<S2SV_blank>proglen=%u<S2SV_blank>pass=%d<S2SV_blank>image=%p\\n"" , flen , proglen , pass , image ) ; if ( image ) { if ( bpf_jit_enable > 1 ) print_hex_dump ( KERN_ERR , ""JIT<S2SV_blank>code:<S2SV_blank>"" , DUMP_PREFIX_ADDRESS , 16 , 1 , image , proglen , false ) ; bpf_flush_icache ( image , image + proglen ) ; fp -> bpf_func = ( void * ) image ; } out : kfree ( addrs ) ; return ; }
","<S2SV_ModStart> ] . jf && f_offset <S2SV_ModStart> ? 2 : 5 <S2SV_ModEnd> ; EMIT_COND_JMP (
"
531,"CWE-119 static int lookup1_values ( int entries , int dim ) { int r = ( int ) floor ( exp ( ( float ) log ( ( float ) entries ) / dim ) ) ; if ( ( int ) floor ( pow ( ( float ) r + 1 , dim ) ) <= entries ) ++ r ; <S2SV_StartBug> assert ( pow ( ( float ) r + 1 , dim ) > entries ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( ( int ) floor ( pow ( ( float ) r , dim ) ) <= entries ) ; <S2SV_EndBug> return r ; }
","<S2SV_ModStart> ++ r ; if <S2SV_ModEnd> ( pow ( <S2SV_ModStart> , dim ) <= entries ) return - 1 ; if <S2SV_ModEnd> ( ( int <S2SV_ModStart> dim ) ) > entries ) return - 1 <S2SV_ModEnd> ; return r
"
532,"CWE-200 static void tv_details_row_activated ( GtkTreeView * tree_view , GtkTreePath * tree_path_UNUSED , GtkTreeViewColumn * column , gpointer user_data ) { gchar * item_name ; struct problem_item * item = get_current_problem_item_or_NULL ( tree_view , & item_name ) ; if ( ! item || ! ( item -> flags & CD_FLAG_TXT ) ) goto ret ; if ( ! strchr ( item -> content , '\\n' ) ) goto ret ; gint exitcode ; gchar * arg [ 3 ] ; arg [ 0 ] = ( char * ) ""xdg-open"" ; arg [ 1 ] = concat_path_file ( g_dump_dir_name , item_name ) ; arg [ 2 ] = NULL ; const gboolean spawn_ret = g_spawn_sync ( NULL , arg , NULL , G_SPAWN_SEARCH_PATH | G_SPAWN_STDOUT_TO_DEV_NULL , NULL , NULL , NULL , NULL , & exitcode , NULL ) ; if ( spawn_ret == FALSE || exitcode != EXIT_SUCCESS ) { GtkWidget * dialog = gtk_dialog_new_with_buttons ( _ ( ""View/edit<S2SV_blank>a<S2SV_blank>text<S2SV_blank>file"" ) , GTK_WINDOW ( g_wnd_assistant ) , GTK_DIALOG_MODAL | GTK_DIALOG_DESTROY_WITH_PARENT , NULL , NULL ) ; GtkWidget * vbox = gtk_dialog_get_content_area ( GTK_DIALOG ( dialog ) ) ; GtkWidget * scrolled = gtk_scrolled_window_new ( NULL , NULL ) ; GtkWidget * textview = gtk_text_view_new ( ) ; gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , _ ( ""_Save"" ) , GTK_RESPONSE_OK ) ; gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , _ ( ""_Cancel"" ) , GTK_RESPONSE_CANCEL ) ; gtk_box_pack_start ( GTK_BOX ( vbox ) , scrolled , TRUE , TRUE , 0 ) ; gtk_widget_set_size_request ( scrolled , 640 , 480 ) ; gtk_widget_show ( scrolled ) ; # if ( ( GTK_MAJOR_VERSION == 3 && GTK_MINOR_VERSION < 7 ) || ( GTK_MAJOR_VERSION == 3 && GTK_MINOR_VERSION == 7 && GTK_MICRO_VERSION < 8 ) ) gtk_scrolled_window_add_with_viewport ( GTK_SCROLLED_WINDOW ( scrolled ) , textview ) ; # else gtk_container_add ( GTK_CONTAINER ( scrolled ) , textview ) ; # endif gtk_widget_show ( textview ) ; load_text_to_text_view ( GTK_TEXT_VIEW ( textview ) , item_name ) ; if ( gtk_dialog_run ( GTK_DIALOG ( dialog ) ) == GTK_RESPONSE_OK ) <S2SV_StartBug> save_text_from_text_view ( GTK_TEXT_VIEW ( textview ) , item_name ) ; <S2SV_EndBug> gtk_widget_destroy ( textview ) ; gtk_widget_destroy ( scrolled ) ; gtk_widget_destroy ( dialog ) ; } free ( arg [ 1 ] ) ; ret : g_free ( item_name ) ; }
","<S2SV_ModStart> == GTK_RESPONSE_OK ) { <S2SV_ModStart> item_name ) ; problem_data_reload_from_dump_dir ( ) ; update_gui_state_from_problem_data ( 0 ) ; }
"
533,"CWE-310 void bn_mul_comba8 ( BN_ULONG * r , BN_ULONG * a , BN_ULONG * b ) { <S2SV_StartBug> BN_ULONG t1 , t2 ; <S2SV_EndBug> BN_ULONG c1 , c2 , c3 ; c1 = 0 ; c2 = 0 ; c3 = 0 ; mul_add_c ( a [ 0 ] , b [ 0 ] , c1 , c2 , c3 ) ; r [ 0 ] = c1 ; c1 = 0 ; mul_add_c ( a [ 0 ] , b [ 1 ] , c2 , c3 , c1 ) ; mul_add_c ( a [ 1 ] , b [ 0 ] , c2 , c3 , c1 ) ; r [ 1 ] = c2 ; c2 = 0 ; mul_add_c ( a [ 2 ] , b [ 0 ] , c3 , c1 , c2 ) ; mul_add_c ( a [ 1 ] , b [ 1 ] , c3 , c1 , c2 ) ; mul_add_c ( a [ 0 ] , b [ 2 ] , c3 , c1 , c2 ) ; r [ 2 ] = c3 ; c3 = 0 ; mul_add_c ( a [ 0 ] , b [ 3 ] , c1 , c2 , c3 ) ; mul_add_c ( a [ 1 ] , b [ 2 ] , c1 , c2 , c3 ) ; mul_add_c ( a [ 2 ] , b [ 1 ] , c1 , c2 , c3 ) ; mul_add_c ( a [ 3 ] , b [ 0 ] , c1 , c2 , c3 ) ; r [ 3 ] = c1 ; c1 = 0 ; mul_add_c ( a [ 4 ] , b [ 0 ] , c2 , c3 , c1 ) ; mul_add_c ( a [ 3 ] , b [ 1 ] , c2 , c3 , c1 ) ; mul_add_c ( a [ 2 ] , b [ 2 ] , c2 , c3 , c1 ) ; mul_add_c ( a [ 1 ] , b [ 3 ] , c2 , c3 , c1 ) ; mul_add_c ( a [ 0 ] , b [ 4 ] , c2 , c3 , c1 ) ; r [ 4 ] = c2 ; c2 = 0 ; mul_add_c ( a [ 0 ] , b [ 5 ] , c3 , c1 , c2 ) ; mul_add_c ( a [ 1 ] , b [ 4 ] , c3 , c1 , c2 ) ; mul_add_c ( a [ 2 ] , b [ 3 ] , c3 , c1 , c2 ) ; mul_add_c ( a [ 3 ] , b [ 2 ] , c3 , c1 , c2 ) ; mul_add_c ( a [ 4 ] , b [ 1 ] , c3 , c1 , c2 ) ; mul_add_c ( a [ 5 ] , b [ 0 ] , c3 , c1 , c2 ) ; r [ 5 ] = c3 ; c3 = 0 ; mul_add_c ( a [ 6 ] , b [ 0 ] , c1 , c2 , c3 ) ; mul_add_c ( a [ 5 ] , b [ 1 ] , c1 , c2 , c3 ) ; mul_add_c ( a [ 4 ] , b [ 2 ] , c1 , c2 , c3 ) ; mul_add_c ( a [ 3 ] , b [ 3 ] , c1 , c2 , c3 ) ; mul_add_c ( a [ 2 ] , b [ 4 ] , c1 , c2 , c3 ) ; mul_add_c ( a [ 1 ] , b [ 5 ] , c1 , c2 , c3 ) ; mul_add_c ( a [ 0 ] , b [ 6 ] , c1 , c2 , c3 ) ; r [ 6 ] = c1 ; c1 = 0 ; mul_add_c ( a [ 0 ] , b [ 7 ] , c2 , c3 , c1 ) ; mul_add_c ( a [ 1 ] , b [ 6 ] , c2 , c3 , c1 ) ; mul_add_c ( a [ 2 ] , b [ 5 ] , c2 , c3 , c1 ) ; mul_add_c ( a [ 3 ] , b [ 4 ] , c2 , c3 , c1 ) ; mul_add_c ( a [ 4 ] , b [ 3 ] , c2 , c3 , c1 ) ; mul_add_c ( a [ 5 ] , b [ 2 ] , c2 , c3 , c1 ) ; mul_add_c ( a [ 6 ] , b [ 1 ] , c2 , c3 , c1 ) ; mul_add_c ( a [ 7 ] , b [ 0 ] , c2 , c3 , c1 ) ; r [ 7 ] = c2 ; c2 = 0 ; mul_add_c ( a [ 7 ] , b [ 1 ] , c3 , c1 , c2 ) ; mul_add_c ( a [ 6 ] , b [ 2 ] , c3 , c1 , c2 ) ; mul_add_c ( a [ 5 ] , b [ 3 ] , c3 , c1 , c2 ) ; mul_add_c ( a [ 4 ] , b [ 4 ] , c3 , c1 , c2 ) ; mul_add_c ( a [ 3 ] , b [ 5 ] , c3 , c1 , c2 ) ; mul_add_c ( a [ 2 ] , b [ 6 ] , c3 , c1 , c2 ) ; mul_add_c ( a [ 1 ] , b [ 7 ] , c3 , c1 , c2 ) ; r [ 8 ] = c3 ; c3 = 0 ; mul_add_c ( a [ 2 ] , b [ 7 ] , c1 , c2 , c3 ) ; mul_add_c ( a [ 3 ] , b [ 6 ] , c1 , c2 , c3 ) ; mul_add_c ( a [ 4 ] , b [ 5 ] , c1 , c2 , c3 ) ; mul_add_c ( a [ 5 ] , b [ 4 ] , c1 , c2 , c3 ) ; mul_add_c ( a [ 6 ] , b [ 3 ] , c1 , c2 , c3 ) ; mul_add_c ( a [ 7 ] , b [ 2 ] , c1 , c2 , c3 ) ; r [ 9 ] = c1 ; c1 = 0 ; mul_add_c ( a [ 7 ] , b [ 3 ] , c2 , c3 , c1 ) ; mul_add_c ( a [ 6 ] , b [ 4 ] , c2 , c3 , c1 ) ; mul_add_c ( a [ 5 ] , b [ 5 ] , c2 , c3 , c1 ) ; mul_add_c ( a [ 4 ] , b [ 6 ] , c2 , c3 , c1 ) ; mul_add_c ( a [ 3 ] , b [ 7 ] , c2 , c3 , c1 ) ; r [ 10 ] = c2 ; c2 = 0 ; mul_add_c ( a [ 4 ] , b [ 7 ] , c3 , c1 , c2 ) ; mul_add_c ( a [ 5 ] , b [ 6 ] , c3 , c1 , c2 ) ; mul_add_c ( a [ 6 ] , b [ 5 ] , c3 , c1 , c2 ) ; mul_add_c ( a [ 7 ] , b [ 4 ] , c3 , c1 , c2 ) ; r [ 11 ] = c3 ; c3 = 0 ; mul_add_c ( a [ 7 ] , b [ 5 ] , c1 , c2 , c3 ) ; mul_add_c ( a [ 6 ] , b [ 6 ] , c1 , c2 , c3 ) ; mul_add_c ( a [ 5 ] , b [ 7 ] , c1 , c2 , c3 ) ; r [ 12 ] = c1 ; c1 = 0 ; mul_add_c ( a [ 6 ] , b [ 7 ] , c2 , c3 , c1 ) ; mul_add_c ( a [ 7 ] , b [ 6 ] , c2 , c3 , c1 ) ; r [ 13 ] = c2 ; c2 = 0 ; mul_add_c ( a [ 7 ] , b [ 7 ] , c3 , c1 , c2 ) ; r [ 14 ] = c3 ; r [ 15 ] = c1 ; }
","<S2SV_ModStart> ) { BN_ULONG <S2SV_ModEnd> c1 , c2
"
534,"CWE-369 static int set_geometry ( unsigned int cmd , struct floppy_struct * g , int drive , int type , struct block_device * bdev ) { int cnt ; if ( g -> sect <= 0 || <S2SV_StartBug> g -> head <= 0 || <S2SV_EndBug> g -> track <= 0 || g -> track > UDP -> tracks >> STRETCH ( g ) || ( g -> stretch & ~ ( FD_STRETCH | FD_SWAPSIDES | FD_SECTBASEMASK ) ) != 0 ) return - EINVAL ; if ( type ) { if ( ! capable ( CAP_SYS_ADMIN ) ) return - EPERM ; mutex_lock ( & open_lock ) ; if ( lock_fdc ( drive ) ) { mutex_unlock ( & open_lock ) ; return - EINTR ; } floppy_type [ type ] = * g ; floppy_type [ type ] . name = ""user<S2SV_blank>format"" ; for ( cnt = type << 2 ; cnt < ( type << 2 ) + 4 ; cnt ++ ) floppy_sizes [ cnt ] = floppy_sizes [ cnt + 0x80 ] = floppy_type [ type ] . size + 1 ; process_fd_request ( ) ; for ( cnt = 0 ; cnt < N_DRIVE ; cnt ++ ) { struct block_device * bdev = opened_bdev [ cnt ] ; if ( ! bdev || ITYPE ( drive_state [ cnt ] . fd_device ) != type ) continue ; __invalidate_device ( bdev , true ) ; } mutex_unlock ( & open_lock ) ; } else { int oldStretch ; if ( lock_fdc ( drive ) ) return - EINTR ; if ( cmd != FDDEFPRM ) { if ( poll_drive ( true , FD_RAW_NEED_DISK ) == - EINTR ) return - EINTR ; } oldStretch = g -> stretch ; user_params [ drive ] = * g ; if ( buffer_drive == drive ) SUPBOUND ( buffer_max , user_params [ drive ] . sect ) ; current_type [ drive ] = & user_params [ drive ] ; floppy_sizes [ drive ] = user_params [ drive ] . size ; if ( cmd == FDDEFPRM ) DRS -> keep_data = - 1 ; else DRS -> keep_data = 1 ; if ( DRS -> maxblock > user_params [ drive ] . sect || DRS -> maxtrack || ( ( user_params [ drive ] . sect ^ oldStretch ) & ( FD_SWAPSIDES | FD_SECTBASEMASK ) ) ) invalidate_drive ( bdev ) ; else process_fd_request ( ) ; } return 0 ; }
","<S2SV_ModStart> -> head <= 0 || ( unsigned char ) ( ( g -> sect << 2 ) >> FD_SIZECODE ( g ) ) ==
"
535,"CWE-285 int __gfs2_set_acl ( struct inode * inode , struct posix_acl * acl , int type ) { int error ; int len ; char * data ; const char * name = gfs2_acl_name ( type ) ; if ( acl && acl -> a_count > GFS2_ACL_MAX_ENTRIES ( GFS2_SB ( inode ) ) ) return - E2BIG ; if ( type == ACL_TYPE_ACCESS ) { umode_t mode = inode -> i_mode ; <S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & mode ) ; <S2SV_EndBug> if ( error < 0 ) return error ; if ( error == 0 ) acl = NULL ; <S2SV_StartBug> if ( mode != inode -> i_mode ) { <S2SV_EndBug> inode -> i_mode = mode ; mark_inode_dirty ( inode ) ; <S2SV_StartBug> } <S2SV_EndBug> } if ( acl ) { len = posix_acl_to_xattr ( & init_user_ns , acl , NULL , 0 ) ; if ( len == 0 ) return 0 ; data = kmalloc ( len , GFP_NOFS ) ; if ( data == NULL ) return - ENOMEM ; error = posix_acl_to_xattr ( & init_user_ns , acl , data , len ) ; if ( error < 0 ) goto out ; } else { data = NULL ; len = 0 ; } error = __gfs2_xattr_set ( inode , name , data , len , 0 , GFS2_EATYPE_SYS ) ; if ( error ) goto out ; set_cached_acl ( inode , type , acl ) ; out : kfree ( data ) ; return error ; }
","<S2SV_ModStart> ; error = posix_acl_update_mode ( inode , & inode -> i_mode , & acl ) ; if ( error ) return error <S2SV_ModEnd> ; if ( <S2SV_ModStart> -> i_mode ) <S2SV_ModEnd> mark_inode_dirty ( inode <S2SV_ModStart> inode ) ; <S2SV_ModEnd> } if (
"
536,"CWE-476 static OM_uint32 acc_ctx_cont ( OM_uint32 * minstat , gss_buffer_t buf , gss_ctx_id_t * ctx , gss_buffer_t * responseToken , gss_buffer_t * mechListMIC , OM_uint32 * negState , send_token_flag * return_token ) { OM_uint32 ret , tmpmin ; gss_OID supportedMech ; spnego_gss_ctx_id_t sc ; unsigned int len ; unsigned char * ptr , * bufstart ; sc = ( spnego_gss_ctx_id_t ) * ctx ; ret = GSS_S_DEFECTIVE_TOKEN ; * negState = REJECT ; * minstat = 0 ; supportedMech = GSS_C_NO_OID ; * return_token = ERROR_TOKEN_SEND ; * responseToken = * mechListMIC = GSS_C_NO_BUFFER ; ptr = bufstart = buf -> value ; # define REMAIN ( buf -> length - ( ptr - bufstart ) ) <S2SV_StartBug> if ( REMAIN > INT_MAX ) <S2SV_EndBug> return GSS_S_DEFECTIVE_TOKEN ; if ( * ptr == HEADER_ID ) { ret = g_verify_token_header ( gss_mech_spnego , & len , & ptr , 0 , REMAIN ) ; if ( ret ) { * minstat = ret ; return GSS_S_DEFECTIVE_TOKEN ; } } if ( * ptr != ( CONTEXT | 0x01 ) ) { return GSS_S_DEFECTIVE_TOKEN ; } ret = get_negTokenResp ( minstat , ptr , REMAIN , negState , & supportedMech , responseToken , mechListMIC ) ; if ( ret != GSS_S_COMPLETE ) goto cleanup ; if ( * responseToken == GSS_C_NO_BUFFER && * mechListMIC == GSS_C_NO_BUFFER ) { ret = GSS_S_DEFECTIVE_TOKEN ; goto cleanup ; } if ( supportedMech != GSS_C_NO_OID ) { ret = GSS_S_DEFECTIVE_TOKEN ; goto cleanup ; } sc -> firstpass = 0 ; * negState = ACCEPT_INCOMPLETE ; * return_token = CONT_TOKEN_SEND ; cleanup : if ( supportedMech != GSS_C_NO_OID ) { generic_gss_release_oid ( & tmpmin , & supportedMech ) ; } return ret ; # undef REMAIN }
","<S2SV_ModStart> if ( REMAIN == 0 || REMAIN
"
537,"CWE-119 static void block_rd_txfm ( int plane , int block , BLOCK_SIZE plane_bsize , TX_SIZE tx_size , void * arg ) { struct rdcost_block_args * args = arg ; MACROBLOCK * const x = args -> x ; MACROBLOCKD * const xd = & x -> e_mbd ; MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ; int64_t rd1 , rd2 , rd ; <S2SV_StartBug> if ( args -> skip ) <S2SV_EndBug> return ; <S2SV_StartBug> if ( ! is_inter_block ( mbmi ) ) <S2SV_EndBug> <S2SV_StartBug> vp9_encode_block_intra ( x , plane , block , plane_bsize , tx_size , & mbmi -> skip ) ; <S2SV_EndBug> else vp9_xform_quant ( x , plane , block , plane_bsize , tx_size ) ; <S2SV_StartBug> dist_block ( plane , block , tx_size , args ) ; <S2SV_EndBug> rate_block ( plane , block , plane_bsize , tx_size , args ) ; <S2SV_StartBug> rd1 = RDCOST ( x -> rdmult , x -> rddiv , args -> rate , args -> dist ) ; <S2SV_EndBug> <S2SV_StartBug> rd2 = RDCOST ( x -> rdmult , x -> rddiv , 0 , args -> sse ) ; <S2SV_EndBug> rd = MIN ( rd1 , rd2 ) ; if ( plane == 0 ) x -> zcoeff_blk [ tx_size ] [ block ] = ! x -> plane [ plane ] . eobs [ block ] || ( rd1 > rd2 && ! xd -> lossless ) ; <S2SV_StartBug> args -> this_rate += args -> rate ; <S2SV_EndBug> <S2SV_StartBug> args -> this_dist += args -> dist ; <S2SV_EndBug> <S2SV_StartBug> args -> this_sse += args -> sse ; <S2SV_EndBug> args -> this_rd += rd ; if ( args -> this_rd > args -> best_rd ) { <S2SV_StartBug> args -> skip = 1 ; <S2SV_EndBug> return ; } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> , rd ; int rate ; int64_t dist ; int64_t sse ; if ( args -> exit_early <S2SV_ModEnd> ) return ; <S2SV_ModStart> mbmi ) ) { struct encode_b_args arg = { x , NULL , & mbmi -> skip } ; vp9_encode_block_intra ( <S2SV_ModEnd> plane , block <S2SV_ModStart> tx_size , & arg ) ; dist_block ( x , plane , block , tx_size , & dist , & sse ) ; } else if ( max_txsize_lookup [ plane_bsize ] == tx_size ) { if ( x -> skip_txfm [ ( plane << 2 ) + ( block >> ( tx_size << 1 ) ) ] == SKIP_TXFM_NONE ) { <S2SV_ModEnd> vp9_xform_quant ( x <S2SV_ModStart> ; dist_block ( x , plane , block , tx_size , & dist , & sse ) ; } else if ( x -> skip_txfm [ ( plane << 2 ) + ( block >> ( tx_size << 1 ) ) ] == SKIP_TXFM_AC_ONLY ) { tran_low_t * const coeff = BLOCK_OFFSET ( x -> plane [ plane ] . coeff , block ) ; tran_low_t * const dqcoeff = BLOCK_OFFSET ( xd -> plane [ plane ] . dqcoeff , block ) ; vp9_xform_quant_dc ( x , plane , block , plane_bsize , tx_size ) ; sse = x -> bsse [ ( plane << 2 ) + ( block >> ( tx_size << 1 ) ) ] << 4 ; dist = sse ; if ( x -> plane [ plane ] . eobs [ block ] ) { const int64_t orig_sse = ( int64_t ) coeff [ 0 ] * coeff [ 0 ] ; const int64_t resd_sse = coeff [ 0 ] - dqcoeff [ 0 ] ; int64_t dc_correct = orig_sse - resd_sse * resd_sse ; # if CONFIG_VP9_HIGHBITDEPTH dc_correct >>= ( ( xd -> bd - 8 ) * 2 ) ; # endif if ( tx_size != TX_32X32 ) dc_correct >>= 2 ; dist = MAX ( 0 , sse - dc_correct ) ; } } else { x -> plane [ plane ] . eobs [ block ] = 0 ; sse = x -> bsse [ ( plane << 2 ) + ( block >> ( tx_size << 1 ) ) ] << 4 ; dist = sse ; } } else { vp9_xform_quant ( x , plane , block , plane_bsize , tx_size ) ; dist_block ( x , plane , block , tx_size , & dist , & sse ) ; } rd = RDCOST ( x -> rdmult , x -> rddiv , 0 , dist ) ; if ( args -> this_rd + rd > args -> best_rd ) { args -> exit_early = 1 ; return ; } rate = <S2SV_ModEnd> rate_block ( plane <S2SV_ModStart> -> rddiv , rate , <S2SV_ModEnd> dist ) ; <S2SV_ModStart> , 0 , <S2SV_ModEnd> sse ) ; <S2SV_ModStart> -> this_rate += <S2SV_ModEnd> rate ; args <S2SV_ModStart> -> this_dist += <S2SV_ModEnd> dist ; args <S2SV_ModStart> -> this_sse += <S2SV_ModEnd> sse ; args <S2SV_ModStart> { args -> exit_early <S2SV_ModEnd> = 1 ; <S2SV_ModStart> return ; } args -> skippable &= ! x -> plane [ plane ] . eobs [ block ] ;
"
538,"CWE-264 void setattr_copy ( struct inode * inode , const struct iattr * attr ) { unsigned int ia_valid = attr -> ia_valid ; if ( ia_valid & ATTR_UID ) inode -> i_uid = attr -> ia_uid ; if ( ia_valid & ATTR_GID ) inode -> i_gid = attr -> ia_gid ; if ( ia_valid & ATTR_ATIME ) inode -> i_atime = timespec_trunc ( attr -> ia_atime , inode -> i_sb -> s_time_gran ) ; if ( ia_valid & ATTR_MTIME ) inode -> i_mtime = timespec_trunc ( attr -> ia_mtime , inode -> i_sb -> s_time_gran ) ; if ( ia_valid & ATTR_CTIME ) inode -> i_ctime = timespec_trunc ( attr -> ia_ctime , inode -> i_sb -> s_time_gran ) ; if ( ia_valid & ATTR_MODE ) { umode_t mode = attr -> ia_mode ; if ( ! in_group_p ( inode -> i_gid ) && <S2SV_StartBug> ! inode_capable ( inode , CAP_FSETID ) ) <S2SV_EndBug> mode &= ~ S_ISGID ; inode -> i_mode = mode ; } }
","<S2SV_ModStart> ) && ! capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode ,
"
539,"CWE-119 static int compare_img ( const vpx_image_t * const img1 , const vpx_image_t * const img2 ) { <S2SV_StartBug> const uint32_t c_w = <S2SV_EndBug> ( img1 -> d_w + img1 -> x_chroma_shift ) >> img1 -> x_chroma_shift ; const uint32_t c_h = ( img1 -> d_h + img1 -> y_chroma_shift ) >> img1 -> y_chroma_shift ; uint32_t i ; int match = 1 ; match &= ( img1 -> fmt == img2 -> fmt ) ; match &= ( img1 -> d_w == img2 -> d_w ) ; match &= ( img1 -> d_h == img2 -> d_h ) ; <S2SV_StartBug> for ( i = 0 ; i < img1 -> d_h ; ++ i ) <S2SV_EndBug> match &= ( memcmp ( img1 -> planes [ VPX_PLANE_Y ] + i * img1 -> stride [ VPX_PLANE_Y ] , img2 -> planes [ VPX_PLANE_Y ] + i * img2 -> stride [ VPX_PLANE_Y ] , <S2SV_StartBug> img1 -> d_w ) == 0 ) ; <S2SV_EndBug> for ( i = 0 ; i < c_h ; ++ i ) match &= ( memcmp ( img1 -> planes [ VPX_PLANE_U ] + i * img1 -> stride [ VPX_PLANE_U ] , img2 -> planes [ VPX_PLANE_U ] + i * img2 -> stride [ VPX_PLANE_U ] , c_w ) == 0 ) ; for ( i = 0 ; i < c_h ; ++ i ) match &= ( memcmp ( img1 -> planes [ VPX_PLANE_V ] + i * img1 -> stride [ VPX_PLANE_V ] , img2 -> planes [ VPX_PLANE_V ] + i * img2 -> stride [ VPX_PLANE_V ] , c_w ) == 0 ) ; return match ; }
","<S2SV_ModStart> img2 ) { uint32_t l_w = img1 -> d_w ; <S2SV_ModEnd> uint32_t c_w = <S2SV_ModStart> d_h ) ; # if CONFIG_VP9_HIGHBITDEPTH if ( img1 -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) { l_w *= 2 ; c_w *= 2 ; } # endif <S2SV_ModStart> VPX_PLANE_Y ] , l_w <S2SV_ModEnd> ) == 0
"
540,"CWE-119 char * irc_ctcp_dcc_filename_without_quotes ( const char * filename ) { int length ; length = strlen ( filename ) ; <S2SV_StartBug> if ( length > 0 ) <S2SV_EndBug> { if ( ( filename [ 0 ] == \'\\""\' ) && ( filename [ length - 1 ] == \'\\""\' ) ) return weechat_strndup ( filename + 1 , length - 2 ) ; } return strdup ( filename ) ; }
","<S2SV_ModStart> ( length > 1 <S2SV_ModEnd> ) { if
"
541,"CWE-119 static void rd_use_partition ( VP9_COMP * cpi , <S2SV_StartBug> const TileInfo * const tile , <S2SV_EndBug> MODE_INFO * * mi_8x8 , TOKENEXTRA * * tp , int mi_row , int mi_col , BLOCK_SIZE bsize , int * rate , int64_t * dist , <S2SV_StartBug> int do_recon ) { <S2SV_EndBug> VP9_COMMON * const cm = & cpi -> common ; <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> MACROBLOCKD * const xd = & x -> e_mbd ; const int mis = cm -> mi_stride ; <S2SV_StartBug> const int bsl = b_width_log2 ( bsize ) ; <S2SV_EndBug> const int mi_step = num_4x4_blocks_wide_lookup [ bsize ] / 2 ; const int bss = ( 1 << bsl ) / 4 ; int i , pl ; PARTITION_TYPE partition = PARTITION_NONE ; BLOCK_SIZE subsize ; ENTROPY_CONTEXT l [ 16 * MAX_MB_PLANE ] , a [ 16 * MAX_MB_PLANE ] ; PARTITION_CONTEXT sl [ 8 ] , sa [ 8 ] ; <S2SV_StartBug> int last_part_rate = INT_MAX ; <S2SV_EndBug> int64_t last_part_dist = INT64_MAX ; int64_t last_part_rd = INT64_MAX ; int none_rate = INT_MAX ; int64_t none_dist = INT64_MAX ; int64_t none_rd = INT64_MAX ; int chosen_rate = INT_MAX ; int64_t chosen_dist = INT64_MAX ; int64_t chosen_rd = INT64_MAX ; BLOCK_SIZE sub_subsize = BLOCK_4X4 ; int splits_below = 0 ; BLOCK_SIZE bs_type = mi_8x8 [ 0 ] -> mbmi . sb_type ; int do_partition_search = 1 ; <S2SV_StartBug> if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) <S2SV_EndBug> return ; assert ( num_4x4_blocks_wide_lookup [ bsize ] == num_4x4_blocks_high_lookup [ bsize ] ) ; <S2SV_StartBug> partition = partition_lookup [ bsl ] [ bs_type ] ; <S2SV_EndBug> subsize = get_subsize ( bsize , partition ) ; <S2SV_StartBug> if ( bsize < BLOCK_8X8 ) { <S2SV_EndBug> if ( x -> ab_index != 0 ) { * rate = 0 ; * dist = 0 ; return ; } } else { * ( get_sb_partitioning ( x , bsize ) ) = subsize ; } save_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ; <S2SV_StartBug> if ( bsize == BLOCK_16X16 ) { <S2SV_EndBug> <S2SV_StartBug> set_offsets ( cpi , tile , mi_row , mi_col , bsize ) ; <S2SV_EndBug> x -> mb_energy = vp9_block_energy ( cpi , x , bsize ) ; <S2SV_StartBug> } else { <S2SV_EndBug> x -> in_active_map = check_active_map ( cpi , x , mi_row , mi_col , bsize ) ; } if ( ! x -> in_active_map ) { do_partition_search = 0 ; if ( mi_row + ( mi_step >> 1 ) < cm -> mi_rows && mi_col + ( mi_step >> 1 ) < cm -> mi_cols ) { * ( get_sb_partitioning ( x , bsize ) ) = bsize ; bs_type = mi_8x8 [ 0 ] -> mbmi . sb_type = bsize ; subsize = bsize ; partition = PARTITION_NONE ; } } if ( do_partition_search && cpi -> sf . partition_search_type == SEARCH_PARTITION && cpi -> sf . adjust_partitioning_from_last_frame ) { if ( partition == PARTITION_SPLIT && subsize > BLOCK_8X8 ) { sub_subsize = get_subsize ( subsize , PARTITION_SPLIT ) ; splits_below = 1 ; for ( i = 0 ; i < 4 ; i ++ ) { int jj = i >> 1 , ii = i & 0x01 ; MODE_INFO * this_mi = mi_8x8 [ jj * bss * mis + ii * bss ] ; if ( this_mi && this_mi -> mbmi . sb_type >= sub_subsize ) { splits_below = 0 ; } } } if ( partition != PARTITION_NONE && ! splits_below && mi_row + ( mi_step >> 1 ) < cm -> mi_rows && mi_col + ( mi_step >> 1 ) < cm -> mi_cols ) { <S2SV_StartBug> * ( get_sb_partitioning ( x , bsize ) ) = bsize ; <S2SV_EndBug> <S2SV_StartBug> rd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & none_rate , & none_dist , bsize , <S2SV_EndBug> get_block_context ( x , bsize ) , INT64_MAX ) ; pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; <S2SV_StartBug> if ( none_rate < INT_MAX ) { <S2SV_EndBug> <S2SV_StartBug> none_rate += x -> partition_cost [ pl ] [ PARTITION_NONE ] ; <S2SV_EndBug> <S2SV_StartBug> none_rd = RDCOST ( x -> rdmult , x -> rddiv , none_rate , none_dist ) ; <S2SV_EndBug> } <S2SV_StartBug> restore_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ; <S2SV_EndBug> mi_8x8 [ 0 ] -> mbmi . sb_type = bs_type ; <S2SV_StartBug> * ( get_sb_partitioning ( x , bsize ) ) = subsize ; <S2SV_EndBug> } } switch ( partition ) { case PARTITION_NONE : <S2SV_StartBug> rd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & last_part_rate , <S2SV_EndBug> & last_part_dist , bsize , get_block_context ( x , bsize ) , INT64_MAX ) ; break ; case PARTITION_HORZ : <S2SV_StartBug> * get_sb_index ( x , subsize ) = 0 ; <S2SV_EndBug> rd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & last_part_rate , & last_part_dist , subsize , get_block_context ( x , subsize ) , INT64_MAX ) ; <S2SV_StartBug> if ( last_part_rate != INT_MAX && <S2SV_EndBug> bsize >= BLOCK_8X8 && mi_row + ( mi_step >> 1 ) < cm -> mi_rows ) { <S2SV_StartBug> int rt = 0 ; <S2SV_EndBug> int64_t dt = 0 ; <S2SV_StartBug> update_state ( cpi , get_block_context ( x , subsize ) , mi_row , mi_col , <S2SV_EndBug> subsize , 0 ) ; encode_superblock ( cpi , tp , 0 , mi_row , mi_col , subsize ) ; * get_sb_index ( x , subsize ) = 1 ; <S2SV_StartBug> rd_pick_sb_modes ( cpi , tile , mi_row + ( mi_step >> 1 ) , mi_col , & rt , & dt , <S2SV_EndBug> <S2SV_StartBug> subsize , get_block_context ( x , subsize ) , INT64_MAX ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rt == INT_MAX || dt == INT64_MAX ) { <S2SV_EndBug> <S2SV_StartBug> last_part_rate = INT_MAX ; <S2SV_EndBug> last_part_dist = INT64_MAX ; break ; } <S2SV_StartBug> last_part_rate += rt ; <S2SV_EndBug> last_part_dist += dt ; } break ; case PARTITION_VERT : <S2SV_StartBug> * get_sb_index ( x , subsize ) = 0 ; <S2SV_EndBug> rd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & last_part_rate , & last_part_dist , subsize , get_block_context ( x , subsize ) , INT64_MAX ) ; <S2SV_StartBug> if ( last_part_rate != INT_MAX && <S2SV_EndBug> bsize >= BLOCK_8X8 && mi_col + ( mi_step >> 1 ) < cm -> mi_cols ) { <S2SV_StartBug> int rt = 0 ; <S2SV_EndBug> int64_t dt = 0 ; <S2SV_StartBug> update_state ( cpi , get_block_context ( x , subsize ) , mi_row , mi_col , <S2SV_EndBug> subsize , 0 ) ; encode_superblock ( cpi , tp , 0 , mi_row , mi_col , subsize ) ; * get_sb_index ( x , subsize ) = 1 ; <S2SV_StartBug> rd_pick_sb_modes ( cpi , tile , mi_row , mi_col + ( mi_step >> 1 ) , & rt , & dt , <S2SV_EndBug> <S2SV_StartBug> subsize , get_block_context ( x , subsize ) , INT64_MAX ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rt == INT_MAX || dt == INT64_MAX ) { <S2SV_EndBug> <S2SV_StartBug> last_part_rate = INT_MAX ; <S2SV_EndBug> last_part_dist = INT64_MAX ; break ; } <S2SV_StartBug> last_part_rate += rt ; <S2SV_EndBug> last_part_dist += dt ; } break ; case PARTITION_SPLIT : <S2SV_StartBug> last_part_rate = 0 ; <S2SV_EndBug> last_part_dist = 0 ; for ( i = 0 ; i < 4 ; i ++ ) { int x_idx = ( i & 1 ) * ( mi_step >> 1 ) ; int y_idx = ( i >> 1 ) * ( mi_step >> 1 ) ; int jj = i >> 1 , ii = i & 0x01 ; <S2SV_StartBug> int rt ; <S2SV_EndBug> int64_t dt ; if ( ( mi_row + y_idx >= cm -> mi_rows ) || ( mi_col + x_idx >= cm -> mi_cols ) ) continue ; <S2SV_StartBug> * get_sb_index ( x , subsize ) = i ; <S2SV_EndBug> rd_use_partition ( cpi , tile , mi_8x8 + jj * bss * mis + ii * bss , tp , mi_row + y_idx , mi_col + x_idx , subsize , & rt , & dt , <S2SV_StartBug> i != 3 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rt == INT_MAX || dt == INT64_MAX ) { <S2SV_EndBug> <S2SV_StartBug> last_part_rate = INT_MAX ; <S2SV_EndBug> last_part_dist = INT64_MAX ; break ; } <S2SV_StartBug> last_part_rate += rt ; <S2SV_EndBug> last_part_dist += dt ; } break ; default : assert ( 0 ) ; <S2SV_StartBug> } <S2SV_EndBug> pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; <S2SV_StartBug> if ( last_part_rate < INT_MAX ) { <S2SV_EndBug> <S2SV_StartBug> last_part_rate += x -> partition_cost [ pl ] [ partition ] ; <S2SV_EndBug> <S2SV_StartBug> last_part_rd = RDCOST ( x -> rdmult , x -> rddiv , last_part_rate , last_part_dist ) ; <S2SV_EndBug> } if ( do_partition_search && cpi -> sf . adjust_partitioning_from_last_frame && cpi -> sf . partition_search_type == SEARCH_PARTITION && partition != PARTITION_SPLIT && bsize > BLOCK_8X8 && ( mi_row + mi_step < cm -> mi_rows || mi_row + ( mi_step >> 1 ) == cm -> mi_rows ) && ( mi_col + mi_step < cm -> mi_cols || mi_col + ( mi_step >> 1 ) == cm -> mi_cols ) ) { BLOCK_SIZE split_subsize = get_subsize ( bsize , PARTITION_SPLIT ) ; <S2SV_StartBug> chosen_rate = 0 ; <S2SV_EndBug> chosen_dist = 0 ; <S2SV_StartBug> restore_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ; <S2SV_EndBug> for ( i = 0 ; i < 4 ; i ++ ) { int x_idx = ( i & 1 ) * ( mi_step >> 1 ) ; int y_idx = ( i >> 1 ) * ( mi_step >> 1 ) ; <S2SV_StartBug> int rt = 0 ; <S2SV_EndBug> int64_t dt = 0 ; ENTROPY_CONTEXT l [ 16 * MAX_MB_PLANE ] , a [ 16 * MAX_MB_PLANE ] ; PARTITION_CONTEXT sl [ 8 ] , sa [ 8 ] ; if ( ( mi_row + y_idx >= cm -> mi_rows ) || ( mi_col + x_idx >= cm -> mi_cols ) ) continue ; <S2SV_StartBug> * get_sb_index ( x , split_subsize ) = i ; <S2SV_EndBug> * get_sb_partitioning ( x , bsize ) = split_subsize ; * get_sb_partitioning ( x , split_subsize ) = split_subsize ; save_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ; <S2SV_StartBug> rd_pick_sb_modes ( cpi , tile , mi_row + y_idx , mi_col + x_idx , & rt , & dt , <S2SV_EndBug> split_subsize , get_block_context ( x , split_subsize ) , INT64_MAX ) ; restore_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ; <S2SV_StartBug> if ( rt == INT_MAX || dt == INT64_MAX ) { <S2SV_EndBug> <S2SV_StartBug> chosen_rate = INT_MAX ; <S2SV_EndBug> chosen_dist = INT64_MAX ; break ; } <S2SV_StartBug> chosen_rate += rt ; <S2SV_EndBug> chosen_dist += dt ; if ( i != 3 ) <S2SV_StartBug> encode_sb ( cpi , tile , tp , mi_row + y_idx , mi_col + x_idx , 0 , <S2SV_EndBug> <S2SV_StartBug> split_subsize ) ; <S2SV_EndBug> pl = partition_plane_context ( xd , mi_row + y_idx , mi_col + x_idx , split_subsize ) ; <S2SV_StartBug> chosen_rate += x -> partition_cost [ pl ] [ PARTITION_NONE ] ; <S2SV_EndBug> } pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; <S2SV_StartBug> if ( chosen_rate < INT_MAX ) { <S2SV_EndBug> <S2SV_StartBug> chosen_rate += x -> partition_cost [ pl ] [ PARTITION_SPLIT ] ; <S2SV_EndBug> <S2SV_StartBug> chosen_rd = RDCOST ( x -> rdmult , x -> rddiv , chosen_rate , chosen_dist ) ; <S2SV_EndBug> } } if ( last_part_rd < chosen_rd ) { mi_8x8 [ 0 ] -> mbmi . sb_type = bsize ; if ( bsize >= BLOCK_8X8 ) <S2SV_StartBug> * ( get_sb_partitioning ( x , bsize ) ) = subsize ; <S2SV_EndBug> chosen_rate = last_part_rate ; chosen_dist = last_part_dist ; chosen_rd = last_part_rd ; } if ( none_rd < chosen_rd ) { if ( bsize >= BLOCK_8X8 ) <S2SV_StartBug> * ( get_sb_partitioning ( x , bsize ) ) = bsize ; <S2SV_EndBug> chosen_rate = none_rate ; chosen_dist = none_dist ; } <S2SV_StartBug> restore_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ; <S2SV_EndBug> if ( bsize == BLOCK_64X64 ) <S2SV_StartBug> assert ( chosen_rate < INT_MAX && chosen_dist < INT64_MAX ) ; <S2SV_EndBug> if ( do_recon ) { int output_enabled = ( bsize == BLOCK_64X64 ) ; <S2SV_StartBug> if ( ( cpi -> oxcf . aq_mode == COMPLEXITY_AQ ) && cm -> seg . update_map ) { <S2SV_EndBug> vp9_select_in_frame_q_segment ( cpi , mi_row , mi_col , output_enabled , chosen_rate ) ; } if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) vp9_cyclic_refresh_set_rate_and_dist_sb ( cpi -> cyclic_refresh , chosen_rate , chosen_dist ) ; encode_sb ( cpi , tile , tp , mi_row , mi_col , output_enabled , bsize ) ; } * rate = chosen_rate ; <S2SV_StartBug> * dist = chosen_dist ; <S2SV_EndBug> }
","<S2SV_ModStart> * cpi , ThreadData * td , TileDataEnc * tile_data <S2SV_ModEnd> , MODE_INFO * <S2SV_ModStart> , int do_recon , PC_TREE * pc_tree <S2SV_ModStart> -> common ; TileInfo * const tile_info = & tile_data -> tile_info ; <S2SV_ModStart> x = & td <S2SV_ModEnd> -> mb ; <S2SV_ModStart> int bsl = b_width_log2_lookup [ bsize ] <S2SV_ModEnd> ; const int <S2SV_ModStart> 8 ] ; RD_COST last_part_rdc , none_rdc , chosen_rdc <S2SV_ModEnd> ; BLOCK_SIZE sub_subsize <S2SV_ModStart> = 1 ; PICK_MODE_CONTEXT * ctx = & pc_tree -> none ; <S2SV_ModStart> ] ) ; vp9_rd_cost_reset ( & last_part_rdc ) ; vp9_rd_cost_reset ( & none_rdc ) ; vp9_rd_cost_reset ( & chosen_rdc ) ; <S2SV_ModStart> partition ) ; pc_tree -> partitioning = partition ; save_context ( x <S2SV_ModEnd> , mi_row , <S2SV_ModStart> bsize == BLOCK_16X16 && cpi -> oxcf . aq_mode <S2SV_ModStart> ( cpi , tile_info , x <S2SV_ModEnd> , mi_row , <S2SV_ModStart> bsize ) ; <S2SV_ModEnd> } if ( <S2SV_ModStart> mi_cols ) { pc_tree -> partitioning = PARTITION_NONE <S2SV_ModEnd> ; rd_pick_sb_modes ( <S2SV_ModStart> ( cpi , tile_data , x , mi_row , mi_col , & none_rdc , bsize , ctx <S2SV_ModEnd> , INT64_MAX ) <S2SV_ModStart> ; if ( none_rdc . rate <S2SV_ModEnd> < INT_MAX ) <S2SV_ModStart> INT_MAX ) { none_rdc . rate += cpi <S2SV_ModEnd> -> partition_cost [ <S2SV_ModStart> PARTITION_NONE ] ; none_rdc . rdcost <S2SV_ModEnd> = RDCOST ( <S2SV_ModStart> -> rddiv , none_rdc . rate , none_rdc . dist <S2SV_ModEnd> ) ; } <S2SV_ModStart> } restore_context ( x <S2SV_ModEnd> , mi_row , <S2SV_ModStart> = bs_type ; pc_tree -> partitioning = partition <S2SV_ModEnd> ; } } <S2SV_ModStart> ( cpi , tile_data , x , mi_row , mi_col , & last_part_rdc , bsize , ctx <S2SV_ModEnd> , INT64_MAX ) <S2SV_ModStart> case PARTITION_HORZ : rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & last_part_rdc , subsize , & pc_tree -> horizontal [ 0 ] , <S2SV_ModEnd> INT64_MAX ) ; <S2SV_ModStart> ; if ( last_part_rdc . rate <S2SV_ModEnd> != INT_MAX && <S2SV_ModStart> mi_rows ) { RD_COST tmp_rdc ; PICK_MODE_CONTEXT * ctx = & pc_tree -> horizontal [ 0 ] ; vp9_rd_cost_init ( & tmp_rdc ) <S2SV_ModEnd> ; update_state ( <S2SV_ModStart> ( cpi , td , ctx , mi_row , mi_col , subsize , 0 ) ; encode_superblock ( cpi , td , tp , 0 , mi_row , mi_col , subsize , ctx ) <S2SV_ModEnd> ; rd_pick_sb_modes ( <S2SV_ModStart> ( cpi , tile_data , x , <S2SV_ModEnd> mi_row + ( <S2SV_ModStart> mi_col , & tmp_rdc <S2SV_ModEnd> , subsize , <S2SV_ModStart> , subsize , & pc_tree -> horizontal [ 1 ] <S2SV_ModEnd> , INT64_MAX ) <S2SV_ModStart> ; if ( tmp_rdc . rate <S2SV_ModEnd> == INT_MAX || <S2SV_ModStart> == INT_MAX || tmp_rdc . dist <S2SV_ModEnd> == INT64_MAX ) <S2SV_ModStart> INT64_MAX ) { vp9_rd_cost_reset ( & last_part_rdc ) <S2SV_ModEnd> ; break ; <S2SV_ModStart> break ; } last_part_rdc . rate += tmp_rdc . rate ; last_part_rdc . dist += tmp_rdc . dist ; last_part_rdc . rdcost += tmp_rdc . rdcost <S2SV_ModEnd> ; } break <S2SV_ModStart> case PARTITION_VERT : rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & last_part_rdc , subsize , & pc_tree -> vertical [ 0 ] <S2SV_ModEnd> , INT64_MAX ) <S2SV_ModStart> ; if ( last_part_rdc . rate <S2SV_ModEnd> != INT_MAX && <S2SV_ModStart> mi_cols ) { RD_COST tmp_rdc ; PICK_MODE_CONTEXT * ctx = & pc_tree -> vertical [ 0 ] ; vp9_rd_cost_init ( & tmp_rdc ) <S2SV_ModEnd> ; update_state ( <S2SV_ModStart> ( cpi , td , ctx , mi_row , mi_col , subsize , 0 ) ; encode_superblock ( cpi , td , tp , 0 , mi_row , mi_col , subsize , ctx ) <S2SV_ModEnd> ; rd_pick_sb_modes ( <S2SV_ModStart> ( cpi , tile_data , x , <S2SV_ModEnd> mi_row , mi_col <S2SV_ModStart> ) , & tmp_rdc <S2SV_ModEnd> , subsize , <S2SV_ModStart> , subsize , & pc_tree -> vertical [ bsize > BLOCK_8X8 ] , <S2SV_ModEnd> INT64_MAX ) ; <S2SV_ModStart> ; if ( tmp_rdc . rate <S2SV_ModEnd> == INT_MAX || <S2SV_ModStart> == INT_MAX || tmp_rdc . dist <S2SV_ModEnd> == INT64_MAX ) <S2SV_ModStart> INT64_MAX ) { vp9_rd_cost_reset ( & last_part_rdc ) <S2SV_ModEnd> ; break ; <S2SV_ModStart> break ; } last_part_rdc . rate += tmp_rdc . rate ; last_part_rdc . dist += tmp_rdc . dist ; last_part_rdc . rdcost += tmp_rdc . rdcost <S2SV_ModEnd> ; } break <S2SV_ModStart> case PARTITION_SPLIT : if ( bsize == BLOCK_8X8 ) { rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & last_part_rdc , subsize , pc_tree -> leaf_split [ 0 ] , INT64_MAX ) ; break ; } last_part_rdc . rate = 0 ; last_part_rdc . dist = 0 ; last_part_rdc . rdcost <S2SV_ModEnd> = 0 ; <S2SV_ModStart> & 0x01 ; RD_COST tmp_rdc <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) continue ; vp9_rd_cost_init ( & tmp_rdc ) ; rd_use_partition ( cpi , td , tile_data , mi_8x8 + jj * bss * mis + ii * bss , tp , mi_row + y_idx , mi_col + x_idx , subsize , & tmp_rdc . rate , & tmp_rdc . dist <S2SV_ModEnd> , i != <S2SV_ModStart> i != 3 , pc_tree -> split [ i ] ) ; if ( tmp_rdc . rate <S2SV_ModEnd> == INT_MAX || <S2SV_ModStart> == INT_MAX || tmp_rdc . dist <S2SV_ModEnd> == INT64_MAX ) <S2SV_ModStart> INT64_MAX ) { vp9_rd_cost_reset ( & last_part_rdc ) <S2SV_ModEnd> ; break ; <S2SV_ModStart> break ; } last_part_rdc . rate += tmp_rdc . rate ; last_part_rdc . dist += tmp_rdc . dist <S2SV_ModEnd> ; } break <S2SV_ModStart> 0 ) ; break ; <S2SV_ModStart> ; if ( last_part_rdc . rate <S2SV_ModEnd> < INT_MAX ) <S2SV_ModStart> INT_MAX ) { last_part_rdc . rate += cpi <S2SV_ModEnd> -> partition_cost [ <S2SV_ModStart> partition ] ; last_part_rdc . rdcost <S2SV_ModEnd> = RDCOST ( <S2SV_ModStart> -> rddiv , last_part_rdc . rate , last_part_rdc . dist <S2SV_ModEnd> ) ; } <S2SV_ModStart> PARTITION_SPLIT ) ; chosen_rdc . rate = 0 ; chosen_rdc . dist <S2SV_ModEnd> = 0 ; <S2SV_ModStart> ; restore_context ( x <S2SV_ModEnd> , mi_row , <S2SV_ModStart> , bsize ) ; pc_tree -> partitioning = PARTITION_SPLIT <S2SV_ModStart> 1 ) ; RD_COST tmp_rdc <S2SV_ModEnd> ; ENTROPY_CONTEXT l <S2SV_ModStart> ) continue ; save_context ( x , mi_row , mi_col , a , l , sa , sl , bsize ) ; pc_tree -> split [ i ] -> partitioning = PARTITION_NONE ; rd_pick_sb_modes ( cpi , tile_data , x , mi_row + y_idx , mi_col + x_idx , & tmp_rdc , split_subsize , & pc_tree -> split [ i ] -> none , INT64_MAX ) ; restore_context ( x <S2SV_ModEnd> , mi_row , <S2SV_ModStart> bsize ) ; if ( tmp_rdc . rate <S2SV_ModEnd> == INT_MAX || <S2SV_ModStart> == INT_MAX || tmp_rdc . dist <S2SV_ModEnd> == INT64_MAX ) <S2SV_ModStart> INT64_MAX ) { vp9_rd_cost_reset ( & chosen_rdc ) <S2SV_ModEnd> ; break ; <S2SV_ModStart> break ; } chosen_rdc . rate += tmp_rdc . rate ; chosen_rdc . dist += tmp_rdc . dist <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( cpi , td , tile_info <S2SV_ModEnd> , tp , <S2SV_ModStart> 0 , split_subsize , pc_tree -> split [ i ] <S2SV_ModStart> split_subsize ) ; chosen_rdc . rate += cpi <S2SV_ModEnd> -> partition_cost [ <S2SV_ModStart> ; if ( chosen_rdc . rate <S2SV_ModEnd> < INT_MAX ) <S2SV_ModStart> INT_MAX ) { chosen_rdc . rate += cpi <S2SV_ModEnd> -> partition_cost [ <S2SV_ModStart> PARTITION_SPLIT ] ; chosen_rdc . rdcost <S2SV_ModEnd> = RDCOST ( <S2SV_ModStart> -> rddiv , chosen_rdc . rate , chosen_rdc . dist ) ; } } if ( last_part_rdc . rdcost < chosen_rdc . rdcost <S2SV_ModEnd> ) { mi_8x8 <S2SV_ModStart> >= BLOCK_8X8 ) pc_tree -> partitioning = partition ; chosen_rdc = last_part_rdc ; } if ( none_rdc . rdcost < chosen_rdc . rdcost <S2SV_ModEnd> ) { if <S2SV_ModStart> >= BLOCK_8X8 ) pc_tree -> partitioning = PARTITION_NONE ; chosen_rdc = none_rdc <S2SV_ModEnd> ; } restore_context <S2SV_ModStart> } restore_context ( x <S2SV_ModEnd> , mi_row , <S2SV_ModStart> ) assert ( chosen_rdc . rate <S2SV_ModEnd> < INT_MAX && <S2SV_ModStart> < INT_MAX && chosen_rdc . dist <S2SV_ModEnd> < INT64_MAX ) <S2SV_ModStart> BLOCK_64X64 ) ; encode_sb ( cpi , td , tile_info , tp , mi_row , mi_col , output_enabled , bsize , pc_tree ) ; } * rate = chosen_rdc . rate <S2SV_ModEnd> ; * dist <S2SV_ModStart> * dist = chosen_rdc . dist <S2SV_ModEnd> ; } <S2SV_null>
"
542,"CWE-125 static struct sk_buff * ipv6_gso_segment ( struct sk_buff * skb , netdev_features_t features ) { struct sk_buff * segs = ERR_PTR ( - EINVAL ) ; struct ipv6hdr * ipv6h ; const struct net_offload * ops ; int proto ; struct frag_hdr * fptr ; unsigned int unfrag_ip6hlen ; unsigned int payload_len ; u8 * prevhdr ; int offset = 0 ; bool encap , udpfrag ; int nhoff ; bool gso_partial ; skb_reset_network_header ( skb ) ; nhoff = skb_network_header ( skb ) - skb_mac_header ( skb ) ; if ( unlikely ( ! pskb_may_pull ( skb , sizeof ( * ipv6h ) ) ) ) goto out ; encap = SKB_GSO_CB ( skb ) -> encap_level > 0 ; if ( encap ) features &= skb -> dev -> hw_enc_features ; SKB_GSO_CB ( skb ) -> encap_level += sizeof ( * ipv6h ) ; ipv6h = ipv6_hdr ( skb ) ; __skb_pull ( skb , sizeof ( * ipv6h ) ) ; segs = ERR_PTR ( - EPROTONOSUPPORT ) ; proto = ipv6_gso_pull_exthdrs ( skb , ipv6h -> nexthdr ) ; if ( skb -> encapsulation && skb_shinfo ( skb ) -> gso_type & ( SKB_GSO_IPXIP4 | SKB_GSO_IPXIP6 ) ) udpfrag = proto == IPPROTO_UDP && encap ; else udpfrag = proto == IPPROTO_UDP && ! skb -> encapsulation ; ops = rcu_dereference ( inet6_offloads [ proto ] ) ; if ( likely ( ops && ops -> callbacks . gso_segment ) ) { skb_reset_transport_header ( skb ) ; segs = ops -> callbacks . gso_segment ( skb , features ) ; } if ( IS_ERR_OR_NULL ( segs ) ) goto out ; gso_partial = ! ! ( skb_shinfo ( segs ) -> gso_type & SKB_GSO_PARTIAL ) ; for ( skb = segs ; skb ; skb = skb -> next ) { ipv6h = ( struct ipv6hdr * ) ( skb_mac_header ( skb ) + nhoff ) ; if ( gso_partial ) payload_len = skb_shinfo ( skb ) -> gso_size + SKB_GSO_CB ( skb ) -> data_offset + skb -> head - ( unsigned char * ) ( ipv6h + 1 ) ; else payload_len = skb -> len - nhoff - sizeof ( * ipv6h ) ; ipv6h -> payload_len = htons ( payload_len ) ; skb -> network_header = ( u8 * ) ipv6h - skb -> head ; if ( udpfrag ) { unfrag_ip6hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; <S2SV_StartBug> fptr = ( struct frag_hdr * ) ( ( u8 * ) ipv6h + unfrag_ip6hlen ) ; <S2SV_EndBug> fptr -> frag_off = htons ( offset ) ; if ( skb -> next ) fptr -> frag_off |= htons ( IP6_MF ) ; offset += ( ntohs ( ipv6h -> payload_len ) - sizeof ( struct frag_hdr ) ) ; } if ( encap ) skb_reset_inner_headers ( skb ) ; } out : return segs ; }
","<S2SV_ModStart> prevhdr ) ; if ( unfrag_ip6hlen < 0 ) return ERR_PTR ( unfrag_ip6hlen ) ;
"
543,"CWE-125 static expr_ty ast_for_call ( struct compiling * c , const node * n , expr_ty func ) { int i , nargs , nkeywords , ngens ; asdl_seq * args ; asdl_seq * keywords ; expr_ty vararg = NULL , kwarg = NULL ; REQ ( n , arglist ) ; nargs = 0 ; nkeywords = 0 ; ngens = 0 ; for ( i = 0 ; i < NCH ( n ) ; i ++ ) { node * ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == argument ) { if ( NCH ( ch ) == 1 ) nargs ++ ; else if ( TYPE ( CHILD ( ch , 1 ) ) == comp_for ) ngens ++ ; else nkeywords ++ ; } } if ( ngens > 1 || ( ngens && ( nargs || nkeywords ) ) ) { ast_error ( n , ""Generator<S2SV_blank>expression<S2SV_blank>must<S2SV_blank>be<S2SV_blank>parenthesized<S2SV_blank>"" ""if<S2SV_blank>not<S2SV_blank>sole<S2SV_blank>argument"" ) ; return NULL ; } if ( nargs + nkeywords + ngens > 255 ) { ast_error ( n , ""more<S2SV_blank>than<S2SV_blank>255<S2SV_blank>arguments"" ) ; return NULL ; } args = asdl_seq_new ( nargs + ngens , c -> c_arena ) ; if ( ! args ) return NULL ; keywords = asdl_seq_new ( nkeywords , c -> c_arena ) ; if ( ! keywords ) return NULL ; nargs = 0 ; nkeywords = 0 ; for ( i = 0 ; i < NCH ( n ) ; i ++ ) { node * ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == argument ) { expr_ty e ; if ( NCH ( ch ) == 1 ) { if ( nkeywords ) { ast_error ( CHILD ( ch , 0 ) , ""non-keyword<S2SV_blank>arg<S2SV_blank>after<S2SV_blank>keyword<S2SV_blank>arg"" ) ; return NULL ; } if ( vararg ) { ast_error ( CHILD ( ch , 0 ) , ""only<S2SV_blank>named<S2SV_blank>arguments<S2SV_blank>may<S2SV_blank>follow<S2SV_blank>*expression"" ) ; return NULL ; } e = ast_for_expr ( c , CHILD ( ch , 0 ) ) ; if ( ! e ) return NULL ; asdl_seq_SET ( args , nargs ++ , e ) ; } else if ( TYPE ( CHILD ( ch , 1 ) ) == comp_for ) { e = ast_for_genexp ( c , ch ) ; if ( ! e ) return NULL ; asdl_seq_SET ( args , nargs ++ , e ) ; } else { keyword_ty kw ; identifier key ; int k ; <S2SV_StartBug> char * tmp ; <S2SV_EndBug> e = ast_for_expr ( c , CHILD ( ch , 0 ) ) ; if ( ! e ) return NULL ; if ( e -> kind == Lambda_kind ) { ast_error ( CHILD ( ch , 0 ) , ""lambda<S2SV_blank>cannot<S2SV_blank>contain<S2SV_blank>assignment"" ) ; return NULL ; } else if ( e -> kind != Name_kind ) { ast_error ( CHILD ( ch , 0 ) , ""keyword<S2SV_blank>can\'t<S2SV_blank>be<S2SV_blank>an<S2SV_blank>expression"" ) ; return NULL ; } key = e -> v . Name . id ; if ( ! forbidden_check ( c , CHILD ( ch , 0 ) , PyUnicode_AsUTF8 ( key ) ) ) return NULL ; for ( k = 0 ; k < nkeywords ; k ++ ) { tmp = _PyUnicode_AsString ( ( ( keyword_ty ) asdl_seq_GET ( keywords , k ) ) -> arg ) ; if ( ! strcmp ( tmp , _PyUnicode_AsString ( key ) ) ) { ast_error ( CHILD ( ch , 0 ) , ""keyword<S2SV_blank>argument<S2SV_blank>repeated"" ) ; return NULL ; } } e = ast_for_expr ( c , CHILD ( ch , 2 ) ) ; if ( ! e ) return NULL ; kw = keyword ( key , e , c -> c_arena ) ; if ( ! kw ) return NULL ; asdl_seq_SET ( keywords , nkeywords ++ , kw ) ; } } else if ( TYPE ( ch ) == STAR ) { vararg = ast_for_expr ( c , CHILD ( n , i + 1 ) ) ; if ( ! vararg ) return NULL ; i ++ ; } else if ( TYPE ( ch ) == DOUBLESTAR ) { kwarg = ast_for_expr ( c , CHILD ( n , i + 1 ) ) ; if ( ! kwarg ) return NULL ; i ++ ; } } return Call ( func , args , keywords , vararg , kwarg , func -> lineno , func -> col_offset , c -> c_arena ) ; }
","<S2SV_ModStart> int k ; const
"
544,"CWE-119 <S2SV_StartBug> static int input_stats ( struct twopass_rc * p , FIRSTPASS_STATS * fps ) { <S2SV_EndBug> if ( p -> stats_in >= p -> stats_in_end ) return EOF ; * fps = * p -> stats_in ; ++ p -> stats_in ; return 1 ; }
","<S2SV_ModStart> int input_stats ( TWO_PASS <S2SV_ModEnd> * p ,
"
545,"CWE-189 void pango_glyph_string_set_size ( PangoGlyphString * string , gint new_len ) { g_return_if_fail ( new_len >= 0 ) ; while ( new_len > string -> space ) { if ( string -> space == 0 ) <S2SV_StartBug> string -> space = 1 ; <S2SV_EndBug> else <S2SV_StartBug> string -> space *= 2 ; <S2SV_EndBug> <S2SV_StartBug> if ( string -> space < 0 ) <S2SV_EndBug> { g_warning ( ""glyph<S2SV_blank>string<S2SV_blank>length<S2SV_blank>overflows<S2SV_blank>maximum<S2SV_blank>integer<S2SV_blank>size,<S2SV_blank>truncated"" ) ; <S2SV_StartBug> new_len = string -> space = G_MAXINT - 8 ; <S2SV_EndBug> } } string -> glyphs = g_realloc ( string -> glyphs , string -> space * sizeof ( PangoGlyphInfo ) ) ; string -> log_clusters = g_realloc ( string -> log_clusters , string -> space * sizeof ( gint ) ) ; string -> num_glyphs = new_len ; }
","<S2SV_ModStart> == 0 ) { <S2SV_ModStart> -> space = 4 ; } else { const guint max_space = MIN ( G_MAXINT , G_MAXSIZE / MAX ( sizeof ( PangoGlyphInfo ) , sizeof ( gint ) ) ) ; guint more_space = ( guint ) <S2SV_ModEnd> string -> space <S2SV_ModStart> string -> space * <S2SV_ModEnd> 2 ; if <S2SV_ModStart> ; if ( more_space > max_space ) { more_space = max_space ; if ( ( guint ) new_len > max_space ) { g_error ( ""%s:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>glyph<S2SV_blank>string<S2SV_blank>of<S2SV_blank>length<S2SV_blank>%i\\n"" , G_STRLOC , new_len ) ; } } <S2SV_ModEnd> string -> space <S2SV_ModStart> -> space = more_space <S2SV_ModEnd> ; } }
"
546,"CWE-532 static int klsi_105_get_line_state ( struct usb_serial_port * port , unsigned long * line_state_p ) { int rc ; u8 * status_buf ; __u16 status ; dev_info ( & port -> serial -> dev -> dev , ""sending<S2SV_blank>SIO<S2SV_blank>Poll<S2SV_blank>request\\n"" ) ; status_buf = kmalloc ( KLSI_STATUSBUF_LEN , GFP_KERNEL ) ; if ( ! status_buf ) return - ENOMEM ; status_buf [ 0 ] = 0xff ; status_buf [ 1 ] = 0xff ; rc = usb_control_msg ( port -> serial -> dev , usb_rcvctrlpipe ( port -> serial -> dev , 0 ) , KL5KUSB105A_SIO_POLL , USB_TYPE_VENDOR | USB_DIR_IN , 0 , 0 , status_buf , KLSI_STATUSBUF_LEN , 10000 ) ; <S2SV_StartBug> if ( rc < 0 ) <S2SV_EndBug> <S2SV_StartBug> dev_err ( & port -> dev , ""Reading<S2SV_blank>line<S2SV_blank>status<S2SV_blank>failed<S2SV_blank>(error<S2SV_blank>=<S2SV_blank>%d)\\n"" , <S2SV_EndBug> rc ) ; else { status = get_unaligned_le16 ( status_buf ) ; dev_info ( & port -> serial -> dev -> dev , ""read<S2SV_blank>status<S2SV_blank>%x<S2SV_blank>%x\\n"" , status_buf [ 0 ] , status_buf [ 1 ] ) ; * line_state_p = klsi_105_status2linestate ( status ) ; } kfree ( status_buf ) ; return rc ; }
","<S2SV_ModStart> if ( rc != KLSI_STATUSBUF_LEN ) { <S2SV_ModEnd> dev_err ( & <S2SV_ModStart> -> dev , ""reading<S2SV_blank>line<S2SV_blank>status<S2SV_blank>failed:<S2SV_blank>%d\\n"" , rc ) ; if ( rc >= 0 ) rc = - EIO ; } <S2SV_ModEnd> else { status
"
547,"CWE-772 static Image * ReadMPCImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char cache_filename [ MagickPathExtent ] , id [ MagickPathExtent ] , keyword [ MagickPathExtent ] , * options ; const unsigned char * p ; GeometryInfo geometry_info ; Image * image ; int c ; LinkedListInfo * profiles ; MagickBooleanType status ; MagickOffsetType offset ; MagickStatusType flags ; register ssize_t i ; size_t depth , length ; ssize_t count ; StringInfo * profile ; unsigned int signature ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) CopyMagickString ( cache_filename , image -> filename , MagickPathExtent ) ; AppendImageFormat ( ""cache"" , cache_filename ) ; c = ReadBlobByte ( image ) ; if ( c == EOF ) { image = DestroyImage ( image ) ; return ( ( Image * ) NULL ) ; } * id = '\\0' ; ( void ) ResetMagickMemory ( keyword , 0 , sizeof ( keyword ) ) ; offset = 0 ; do { profiles = ( LinkedListInfo * ) NULL ; length = MagickPathExtent ; options = AcquireString ( ( char * ) NULL ) ; signature = GetMagickSignature ( ( const StringInfo * ) NULL ) ; image -> depth = 8 ; image -> compression = NoCompression ; while ( ( isgraph ( c ) != MagickFalse ) && ( c != ( int ) ':' ) ) { register char * p ; if ( c == ( int ) '{' ) { char * comment ; length = MagickPathExtent ; comment = AcquireString ( ( char * ) NULL ) ; for ( p = comment ; comment != ( char * ) NULL ; p ++ ) { c = ReadBlobByte ( image ) ; if ( c == ( int ) '\\\\' ) c = ReadBlobByte ( image ) ; else if ( ( c == EOF ) || ( c == ( int ) '}' ) ) break ; if ( ( size_t ) ( p - comment + 1 ) >= length ) { * p = '\\0' ; length <<= 1 ; comment = ( char * ) ResizeQuantumMemory ( comment , length + MagickPathExtent , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) break ; p = comment + strlen ( comment ) ; } * p = ( char ) c ; } if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; * p = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment , exception ) ; comment = DestroyString ( comment ) ; c = ReadBlobByte ( image ) ; } else if ( isalnum ( c ) != MagickFalse ) { length = MagickPathExtent ; p = keyword ; do { if ( c == ( int ) '=' ) break ; if ( ( size_t ) ( p - keyword ) < ( MagickPathExtent - 1 ) ) * p ++ = ( char ) c ; c = ReadBlobByte ( image ) ; } while ( c != EOF ) ; * p = '\\0' ; p = options ; while ( isspace ( ( int ) ( ( unsigned char ) c ) ) != 0 ) c = ReadBlobByte ( image ) ; if ( c == ( int ) '=' ) { c = ReadBlobByte ( image ) ; while ( ( c != ( int ) '}' ) && ( c != EOF ) ) { if ( ( size_t ) ( p - options + 1 ) >= length ) { * p = '\\0' ; length <<= 1 ; options = ( char * ) ResizeQuantumMemory ( options , length + MagickPathExtent , sizeof ( * options ) ) ; if ( options == ( char * ) NULL ) break ; p = options + strlen ( options ) ; } * p ++ = ( char ) c ; c = ReadBlobByte ( image ) ; if ( c == '\\\\' ) { c = ReadBlobByte ( image ) ; if ( c == ( int ) '}' ) { * p ++ = ( char ) c ; c = ReadBlobByte ( image ) ; } } if ( * options != '{' ) if ( isspace ( ( int ) ( ( unsigned char ) c ) ) != 0 ) break ; } if ( options == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } * p = '\\0' ; if ( * options == '{' ) ( void ) CopyMagickString ( options , options + 1 , strlen ( options ) ) ; switch ( * keyword ) { case 'a' : case 'A' : { if ( LocaleCompare ( keyword , ""alpha-color"" ) == 0 ) { ( void ) QueryColorCompliance ( options , AllCompliance , & image -> alpha_color , exception ) ; break ; } if ( LocaleCompare ( keyword , ""alpha-trait"" ) == 0 ) { ssize_t alpha_trait ; alpha_trait = ParseCommandOption ( MagickPixelTraitOptions , MagickFalse , options ) ; if ( alpha_trait < 0 ) break ; image -> alpha_trait = ( PixelTrait ) alpha_trait ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'b' : case 'B' : { if ( LocaleCompare ( keyword , ""background-color"" ) == 0 ) { ( void ) QueryColorCompliance ( options , AllCompliance , & image -> background_color , exception ) ; break ; } if ( LocaleCompare ( keyword , ""blue-primary"" ) == 0 ) { flags = ParseGeometry ( options , & geometry_info ) ; image -> chromaticity . blue_primary . x = geometry_info . rho ; image -> chromaticity . blue_primary . y = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> chromaticity . blue_primary . y = image -> chromaticity . blue_primary . x ; break ; } if ( LocaleCompare ( keyword , ""border-color"" ) == 0 ) { ( void ) QueryColorCompliance ( options , AllCompliance , & image -> border_color , exception ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'c' : case 'C' : { if ( LocaleCompare ( keyword , ""class"" ) == 0 ) { ssize_t storage_class ; storage_class = ParseCommandOption ( MagickClassOptions , MagickFalse , options ) ; if ( storage_class < 0 ) break ; image -> storage_class = ( ClassType ) storage_class ; break ; } if ( LocaleCompare ( keyword , ""colors"" ) == 0 ) { image -> colors = StringToUnsignedLong ( options ) ; break ; } if ( LocaleCompare ( keyword , ""colorspace"" ) == 0 ) { ssize_t colorspace ; colorspace = ParseCommandOption ( MagickColorspaceOptions , MagickFalse , options ) ; if ( colorspace < 0 ) break ; image -> colorspace = ( ColorspaceType ) colorspace ; break ; } if ( LocaleCompare ( keyword , ""compression"" ) == 0 ) { ssize_t compression ; compression = ParseCommandOption ( MagickCompressOptions , MagickFalse , options ) ; if ( compression < 0 ) break ; image -> compression = ( CompressionType ) compression ; break ; } if ( LocaleCompare ( keyword , ""columns"" ) == 0 ) { image -> columns = StringToUnsignedLong ( options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'd' : case 'D' : { if ( LocaleCompare ( keyword , ""delay"" ) == 0 ) { image -> delay = StringToUnsignedLong ( options ) ; break ; } if ( LocaleCompare ( keyword , ""depth"" ) == 0 ) { image -> depth = StringToUnsignedLong ( options ) ; break ; } if ( LocaleCompare ( keyword , ""dispose"" ) == 0 ) { ssize_t dispose ; dispose = ParseCommandOption ( MagickDisposeOptions , MagickFalse , options ) ; if ( dispose < 0 ) break ; image -> dispose = ( DisposeType ) dispose ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'e' : case 'E' : { if ( LocaleCompare ( keyword , ""endian"" ) == 0 ) { ssize_t endian ; endian = ParseCommandOption ( MagickEndianOptions , MagickFalse , options ) ; if ( endian < 0 ) break ; image -> endian = ( EndianType ) endian ; break ; } if ( LocaleCompare ( keyword , ""error"" ) == 0 ) { image -> error . mean_error_per_pixel = StringToDouble ( options , ( char * * ) NULL ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'g' : case 'G' : { if ( LocaleCompare ( keyword , ""gamma"" ) == 0 ) { image -> gamma = StringToDouble ( options , ( char * * ) NULL ) ; break ; } if ( LocaleCompare ( keyword , ""green-primary"" ) == 0 ) { flags = ParseGeometry ( options , & geometry_info ) ; image -> chromaticity . green_primary . x = geometry_info . rho ; image -> chromaticity . green_primary . y = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> chromaticity . green_primary . y = image -> chromaticity . green_primary . x ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'i' : case 'I' : { if ( LocaleCompare ( keyword , ""id"" ) == 0 ) { ( void ) CopyMagickString ( id , options , MagickPathExtent ) ; break ; } if ( LocaleCompare ( keyword , ""iterations"" ) == 0 ) { image -> iterations = StringToUnsignedLong ( options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'm' : case 'M' : { if ( LocaleCompare ( keyword , ""magick-signature"" ) == 0 ) { signature = ( unsigned int ) StringToUnsignedLong ( options ) ; break ; } if ( LocaleCompare ( keyword , ""maximum-error"" ) == 0 ) { image -> error . normalized_maximum_error = StringToDouble ( options , ( char * * ) NULL ) ; break ; } if ( LocaleCompare ( keyword , ""mean-error"" ) == 0 ) { image -> error . normalized_mean_error = StringToDouble ( options , ( char * * ) NULL ) ; break ; } if ( LocaleCompare ( keyword , ""montage"" ) == 0 ) { ( void ) CloneString ( & image -> montage , options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'o' : case 'O' : { if ( LocaleCompare ( keyword , ""orientation"" ) == 0 ) { ssize_t orientation ; orientation = ParseCommandOption ( MagickOrientationOptions , MagickFalse , options ) ; if ( orientation < 0 ) break ; image -> orientation = ( OrientationType ) orientation ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'p' : case 'P' : { if ( LocaleCompare ( keyword , ""page"" ) == 0 ) { char * geometry ; geometry = GetPageGeometry ( options ) ; ( void ) ParseAbsoluteGeometry ( geometry , & image -> page ) ; geometry = DestroyString ( geometry ) ; break ; } if ( LocaleCompare ( keyword , ""pixel-intensity"" ) == 0 ) { ssize_t intensity ; intensity = ParseCommandOption ( MagickPixelIntensityOptions , MagickFalse , options ) ; if ( intensity < 0 ) break ; image -> intensity = ( PixelIntensityMethod ) intensity ; break ; } if ( ( LocaleNCompare ( keyword , ""profile:"" , 8 ) == 0 ) || ( LocaleNCompare ( keyword , ""profile-"" , 8 ) == 0 ) ) { if ( profiles == ( LinkedListInfo * ) NULL ) profiles = NewLinkedList ( 0 ) ; ( void ) AppendValueToLinkedList ( profiles , AcquireString ( keyword + 8 ) ) ; profile = BlobToStringInfo ( ( const void * ) NULL , ( size_t ) StringToLong ( options ) ) ; if ( profile == ( StringInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) SetImageProfile ( image , keyword + 8 , profile , exception ) ; profile = DestroyStringInfo ( profile ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'q' : case 'Q' : { if ( LocaleCompare ( keyword , ""quality"" ) == 0 ) { image -> quality = StringToUnsignedLong ( options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'r' : case 'R' : { if ( LocaleCompare ( keyword , ""red-primary"" ) == 0 ) { flags = ParseGeometry ( options , & geometry_info ) ; image -> chromaticity . red_primary . x = geometry_info . rho ; if ( ( flags & SigmaValue ) != 0 ) image -> chromaticity . red_primary . y = geometry_info . sigma ; break ; } if ( LocaleCompare ( keyword , ""rendering-intent"" ) == 0 ) { ssize_t rendering_intent ; rendering_intent = ParseCommandOption ( MagickIntentOptions , MagickFalse , options ) ; if ( rendering_intent < 0 ) break ; image -> rendering_intent = ( RenderingIntent ) rendering_intent ; break ; } if ( LocaleCompare ( keyword , ""resolution"" ) == 0 ) { flags = ParseGeometry ( options , & geometry_info ) ; image -> resolution . x = geometry_info . rho ; image -> resolution . y = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> resolution . y = image -> resolution . x ; break ; } if ( LocaleCompare ( keyword , ""rows"" ) == 0 ) { image -> rows = StringToUnsignedLong ( options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 's' : case 'S' : { if ( LocaleCompare ( keyword , ""scene"" ) == 0 ) { image -> scene = StringToUnsignedLong ( options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 't' : case 'T' : { if ( LocaleCompare ( keyword , ""ticks-per-second"" ) == 0 ) { image -> ticks_per_second = ( ssize_t ) StringToLong ( options ) ; break ; } if ( LocaleCompare ( keyword , ""tile-offset"" ) == 0 ) { char * geometry ; geometry = GetPageGeometry ( options ) ; ( void ) ParseAbsoluteGeometry ( geometry , & image -> tile_offset ) ; geometry = DestroyString ( geometry ) ; } if ( LocaleCompare ( keyword , ""type"" ) == 0 ) { ssize_t type ; type = ParseCommandOption ( MagickTypeOptions , MagickFalse , options ) ; if ( type < 0 ) break ; image -> type = ( ImageType ) type ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'u' : case 'U' : { if ( LocaleCompare ( keyword , ""units"" ) == 0 ) { ssize_t units ; units = ParseCommandOption ( MagickResolutionOptions , MagickFalse , options ) ; if ( units < 0 ) break ; image -> units = ( ResolutionType ) units ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'w' : case 'W' : { if ( LocaleCompare ( keyword , ""white-point"" ) == 0 ) { flags = ParseGeometry ( options , & geometry_info ) ; image -> chromaticity . white_point . x = geometry_info . rho ; image -> chromaticity . white_point . y = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> chromaticity . white_point . y = image -> chromaticity . white_point . x ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } default : { ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } } } else c = ReadBlobByte ( image ) ; while ( isspace ( ( int ) ( ( unsigned char ) c ) ) != 0 ) c = ReadBlobByte ( image ) ; } options = DestroyString ( options ) ; ( void ) ReadBlobByte ( image ) ; if ( ( LocaleCompare ( id , ""MagickCache"" ) != 0 ) || ( image -> storage_class == UndefinedClass ) || ( image -> compression == UndefinedCompression ) || ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( signature != GetMagickSignature ( ( const StringInfo * ) NULL ) ) ThrowReaderException ( CacheError , ""IncompatibleAPI"" ) ; if ( image -> montage != ( char * ) NULL ) { register char * p ; length = MagickPathExtent ; image -> directory = AcquireString ( ( char * ) NULL ) ; p = image -> directory ; do { * p = '\\0' ; if ( ( strlen ( image -> directory ) + MagickPathExtent ) >= length ) { length <<= 1 ; image -> directory = ( char * ) ResizeQuantumMemory ( image -> directory , length + MagickPathExtent , sizeof ( * image -> directory ) ) ; if ( image -> directory == ( char * ) NULL ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; p = image -> directory + strlen ( image -> directory ) ; } c = ReadBlobByte ( image ) ; * p ++ = ( char ) c ; } while ( c != ( int ) '\\0' ) ; } if ( profiles != ( LinkedListInfo * ) NULL ) { const char * name ; const StringInfo * profile ; register unsigned char * p ; ResetLinkedListIterator ( profiles ) ; name = ( const char * ) GetNextValueInLinkedList ( profiles ) ; while ( name != ( const char * ) NULL ) { profile = GetImageProfile ( image , name ) ; if ( profile != ( StringInfo * ) NULL ) { p = GetStringInfoDatum ( profile ) ; count = ReadBlob ( image , GetStringInfoLength ( profile ) , p ) ; } name = ( const char * ) GetNextValueInLinkedList ( profiles ) ; } profiles = DestroyLinkedList ( profiles , RelinquishMagickMemory ) ; } depth = GetImageQuantumDepth ( image , MagickFalse ) ; if ( image -> storage_class == PseudoClass ) { <S2SV_StartBug> if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) <S2SV_EndBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( image -> colors != 0 ) { size_t packet_size ; unsigned char * colormap ; packet_size = ( size_t ) ( 3UL * depth / 8UL ) ; colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , packet_size * sizeof ( * colormap ) ) ; if ( colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , packet_size * image -> colors , colormap ) ; if ( count != ( ssize_t ) ( packet_size * image -> colors ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; p = colormap ; switch ( depth ) { default : ThrowReaderException ( CorruptImageError , ""ImageDepthNotSupported"" ) ; case 8 : { unsigned char pixel ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { p = PushCharPixel ( p , & pixel ) ; image -> colormap [ i ] . red = ScaleCharToQuantum ( pixel ) ; p = PushCharPixel ( p , & pixel ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( pixel ) ; p = PushCharPixel ( p , & pixel ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( pixel ) ; } break ; } case 16 : { unsigned short pixel ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { p = PushShortPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . red = ScaleShortToQuantum ( pixel ) ; p = PushShortPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . green = ScaleShortToQuantum ( pixel ) ; p = PushShortPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . blue = ScaleShortToQuantum ( pixel ) ; } break ; } case 32 : { unsigned int pixel ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { p = PushLongPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . red = ScaleLongToQuantum ( pixel ) ; p = PushLongPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . green = ScaleLongToQuantum ( pixel ) ; p = PushLongPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . blue = ScaleLongToQuantum ( pixel ) ; } break ; } } colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; } } if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; <S2SV_StartBug> status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; <S2SV_EndBug> if ( status == MagickFalse ) <S2SV_StartBug> return ( DestroyImageList ( image ) ) ; <S2SV_EndBug> status = PersistPixelCache ( image , cache_filename , MagickTrue , & offset , exception ) ; if ( status == MagickFalse ) ThrowReaderException ( CacheError , ""UnableToPersistPixelCache"" ) ; do { c = ReadBlobByte ( image ) ; } while ( ( isgraph ( c ) == MagickFalse ) && ( c != EOF ) ) ; if ( c != EOF ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( c != EOF ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> PseudoClass ) { image -> colormap = ( PixelInfo * ) AcquireQuantumMemory ( <S2SV_ModEnd> image -> colors <S2SV_ModStart> image -> colors + 1 , sizeof ( * image -> colormap ) ) ; if ( image -> colormap == ( PixelInfo * ) NULL <S2SV_ModEnd> ) ThrowReaderException ( <S2SV_ModStart> ) break ; if ( ( AcquireMagickResource ( WidthResource <S2SV_ModEnd> , image -> <S2SV_ModStart> image -> columns ) == MagickFalse ) || ( AcquireMagickResource ( HeightResource <S2SV_ModStart> image -> rows ) <S2SV_ModEnd> == MagickFalse ) <S2SV_ModStart> == MagickFalse ) ) ThrowReaderException ( ImageError , ""WidthOrHeightExceedsLimit"" <S2SV_ModEnd> ) ; status
"
548,"CWE-119 int ParseWave64HeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int64_t total_samples = 0 , infilesize ; Wave64ChunkHeader chunk_header ; Wave64FileHeader filehdr ; WaveHeader WaveHeader ; <S2SV_StartBug> uint32_t bcount ; <S2SV_EndBug> infilesize = DoGetFileSize ( infile ) ; memcpy ( & filehdr , fourcc , 4 ) ; if ( ! DoReadFile ( infile , ( ( char * ) & filehdr ) + 4 , sizeof ( Wave64FileHeader ) - 4 , & bcount ) || bcount != sizeof ( Wave64FileHeader ) - 4 || memcmp ( filehdr . ckID , riff_guid , sizeof ( riff_guid ) ) || memcmp ( filehdr . formType , wave_guid , sizeof ( wave_guid ) ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & filehdr , sizeof ( filehdr ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } # if 1 WavpackLittleEndianToNative ( & filehdr , Wave64ChunkHeaderFormat ) ; if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && filehdr . ckSize && filehdr . ckSize + 1 && filehdr . ckSize != infilesize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } # endif while ( 1 ) { if ( ! DoReadFile ( infile , & chunk_header , sizeof ( Wave64ChunkHeader ) , & bcount ) || bcount != sizeof ( Wave64ChunkHeader ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & chunk_header , sizeof ( Wave64ChunkHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackLittleEndianToNative ( & chunk_header , Wave64ChunkHeaderFormat ) ; chunk_header . ckSize -= sizeof ( chunk_header ) ; if ( ! memcmp ( chunk_header . ckID , fmt_guid , sizeof ( fmt_guid ) ) ) { <S2SV_StartBug> int supported = TRUE , format ; <S2SV_EndBug> chunk_header . ckSize = ( chunk_header . ckSize + 7 ) & ~ 7L ; if ( chunk_header . ckSize < 16 || chunk_header . ckSize > sizeof ( WaveHeader ) || ! DoReadFile ( infile , & WaveHeader , ( uint32_t ) chunk_header . ckSize , & bcount ) || bcount != chunk_header . ckSize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & WaveHeader , ( uint32_t ) chunk_header . ckSize ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackLittleEndianToNative ( & WaveHeader , WaveHeaderFormat ) ; if ( debug_logging_mode ) { error_line ( ""format<S2SV_blank>tag<S2SV_blank>size<S2SV_blank>=<S2SV_blank>%d"" , chunk_header . ckSize ) ; error_line ( ""FormatTag<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>NumChannels<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>BitsPerSample<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . FormatTag , WaveHeader . NumChannels , WaveHeader . BitsPerSample ) ; error_line ( ""BlockAlign<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>SampleRate<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>BytesPerSecond<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . BlockAlign , WaveHeader . SampleRate , WaveHeader . BytesPerSecond ) ; if ( chunk_header . ckSize > 16 ) error_line ( ""cbSize<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>ValidBitsPerSample<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . cbSize , WaveHeader . ValidBitsPerSample ) ; if ( chunk_header . ckSize > 20 ) error_line ( ""ChannelMask<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>SubFormat<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . ChannelMask , WaveHeader . SubFormat ) ; } if ( chunk_header . ckSize > 16 && WaveHeader . cbSize == 2 ) config -> qmode |= QMODE_ADOBE_MODE ; format = ( WaveHeader . FormatTag == 0xfffe && chunk_header . ckSize == 40 ) ? WaveHeader . SubFormat : WaveHeader . FormatTag ; config -> bits_per_sample = ( chunk_header . ckSize == 40 && WaveHeader . ValidBitsPerSample ) ? WaveHeader . ValidBitsPerSample : WaveHeader . BitsPerSample ; if ( format != 1 && format != 3 ) supported = FALSE ; if ( format == 3 && config -> bits_per_sample != 32 ) supported = FALSE ; if ( ! WaveHeader . NumChannels || WaveHeader . NumChannels > 256 || WaveHeader . BlockAlign / WaveHeader . NumChannels < ( config -> bits_per_sample + 7 ) / 8 || WaveHeader . BlockAlign / WaveHeader . NumChannels > 4 || WaveHeader . BlockAlign % WaveHeader . NumChannels ) supported = FALSE ; if ( config -> bits_per_sample < 1 || config -> bits_per_sample > 32 ) supported = FALSE ; if ( ! supported ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>an<S2SV_blank>unsupported<S2SV_blank>.W64<S2SV_blank>format!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( chunk_header . ckSize < 40 ) { if ( ! config -> channel_mask && ! ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) { if ( WaveHeader . NumChannels <= 2 ) config -> channel_mask = 0x5 - WaveHeader . NumChannels ; else if ( WaveHeader . NumChannels <= 18 ) config -> channel_mask = ( 1 << WaveHeader . NumChannels ) - 1 ; else config -> channel_mask = 0x3ffff ; } } else if ( WaveHeader . ChannelMask && ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) ) { error_line ( ""this<S2SV_blank>W64<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!"" ) ; return WAVPACK_SOFT_ERROR ; } else if ( WaveHeader . ChannelMask ) config -> channel_mask = WaveHeader . ChannelMask ; if ( format == 3 ) config -> float_norm_exp = 127 ; else if ( ( config -> qmode & QMODE_ADOBE_MODE ) && WaveHeader . BlockAlign / WaveHeader . NumChannels == 4 ) { if ( WaveHeader . BitsPerSample == 24 ) config -> float_norm_exp = 127 + 23 ; else if ( WaveHeader . BitsPerSample == 32 ) config -> float_norm_exp = 127 + 15 ; } if ( debug_logging_mode ) { if ( config -> float_norm_exp == 127 ) error_line ( ""data<S2SV_blank>format:<S2SV_blank>normalized<S2SV_blank>32-bit<S2SV_blank>floating<S2SV_blank>point"" ) ; else error_line ( ""data<S2SV_blank>format:<S2SV_blank>%d-bit<S2SV_blank>integers<S2SV_blank>stored<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>byte(s)"" , config -> bits_per_sample , WaveHeader . BlockAlign / WaveHeader . NumChannels ) ; } } else if ( ! memcmp ( chunk_header . ckID , data_guid , sizeof ( data_guid ) ) ) { if ( ! WaveHeader . NumChannels ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( ( config -> qmode & QMODE_IGNORE_LENGTH ) || chunk_header . ckSize <= 0 ) { config -> qmode |= QMODE_IGNORE_LENGTH ; if ( infilesize && DoGetFilePosition ( infile ) != - 1 ) total_samples = ( infilesize - DoGetFilePosition ( infile ) ) / WaveHeader . BlockAlign ; else total_samples = - 1 ; } else { if ( infilesize && infilesize - chunk_header . ckSize > 16777216 ) { error_line ( ""this<S2SV_blank>.W64<S2SV_blank>file<S2SV_blank>has<S2SV_blank>over<S2SV_blank>16<S2SV_blank>MB<S2SV_blank>of<S2SV_blank>extra<S2SV_blank>RIFF<S2SV_blank>data,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" ) ; return WAVPACK_SOFT_ERROR ; } total_samples = chunk_header . ckSize / WaveHeader . BlockAlign ; if ( ! total_samples ) { error_line ( ""this<S2SV_blank>.W64<S2SV_blank>file<S2SV_blank>has<S2SV_blank>no<S2SV_blank>audio<S2SV_blank>samples,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" ) ; return WAVPACK_SOFT_ERROR ; } if ( total_samples > MAX_WAVPACK_SAMPLES ) { error_line ( ""%s<S2SV_blank>has<S2SV_blank>too<S2SV_blank>many<S2SV_blank>samples<S2SV_blank>for<S2SV_blank>WavPack!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } } config -> bytes_per_sample = WaveHeader . BlockAlign / WaveHeader . NumChannels ; config -> num_channels = WaveHeader . NumChannels ; config -> sample_rate = WaveHeader . SampleRate ; break ; } else { int bytes_to_copy = ( chunk_header . ckSize + 7 ) & ~ 7L ; char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff = malloc ( bytes_to_copy ) ; if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , chunk_header . ckID [ 0 ] , chunk_header . ckID [ 1 ] , chunk_header . ckID [ 2 ] , chunk_header . ckID [ 3 ] , chunk_header . ckSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , NULL ) ) { error_line ( ""%s:<S2SV_blank>%s"" , infilename , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } return WAVPACK_NO_ERROR ; }
","<S2SV_ModStart> WaveHeader WaveHeader ; int format_chunk = 0 ; <S2SV_ModStart> , format ; if ( format_chunk ++ ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; }
"
549,"CWE-362 static void create_watching_parent ( void ) { pid_t child ; sigset_t ourset ; struct sigaction oldact [ 3 ] ; int status = 0 ; int retval ; retval = pam_open_session ( pamh , 0 ) ; if ( is_pam_failure ( retval ) ) { cleanup_pam ( retval ) ; errx ( EXIT_FAILURE , _ ( ""cannot<S2SV_blank>open<S2SV_blank>session:<S2SV_blank>%s"" ) , pam_strerror ( pamh , retval ) ) ; } else _pam_session_opened = 1 ; memset ( oldact , 0 , sizeof ( oldact ) ) ; child = fork ( ) ; if ( child == ( pid_t ) - 1 ) { cleanup_pam ( PAM_ABORT ) ; err ( EXIT_FAILURE , _ ( ""cannot<S2SV_blank>create<S2SV_blank>child<S2SV_blank>process"" ) ) ; } if ( child == 0 ) return ; if ( chdir ( ""/"" ) != 0 ) warn ( _ ( ""cannot<S2SV_blank>change<S2SV_blank>directory<S2SV_blank>to<S2SV_blank>%s"" ) , ""/"" ) ; sigfillset ( & ourset ) ; if ( sigprocmask ( SIG_BLOCK , & ourset , NULL ) ) { warn ( _ ( ""cannot<S2SV_blank>block<S2SV_blank>signals"" ) ) ; caught_signal = true ; } if ( ! caught_signal ) { struct sigaction action ; action . sa_handler = su_catch_sig ; sigemptyset ( & action . sa_mask ) ; action . sa_flags = 0 ; sigemptyset ( & ourset ) ; if ( ! same_session ) { if ( sigaddset ( & ourset , SIGINT ) || sigaddset ( & ourset , SIGQUIT ) ) { warn ( _ ( ""cannot<S2SV_blank>set<S2SV_blank>signal<S2SV_blank>handler"" ) ) ; caught_signal = true ; } } if ( ! caught_signal && ( sigaddset ( & ourset , SIGTERM ) || sigaddset ( & ourset , SIGALRM ) || sigaction ( SIGTERM , & action , & oldact [ 0 ] ) || sigprocmask ( SIG_UNBLOCK , & ourset , NULL ) ) ) { warn ( _ ( ""cannot<S2SV_blank>set<S2SV_blank>signal<S2SV_blank>handler"" ) ) ; caught_signal = true ; } if ( ! caught_signal && ! same_session && ( sigaction ( SIGINT , & action , & oldact [ 1 ] ) || sigaction ( SIGQUIT , & action , & oldact [ 2 ] ) ) ) { warn ( _ ( ""cannot<S2SV_blank>set<S2SV_blank>signal<S2SV_blank>handler"" ) ) ; caught_signal = true ; } } if ( ! caught_signal ) { pid_t pid ; for ( ; ; ) { pid = waitpid ( child , & status , WUNTRACED ) ; if ( pid != ( pid_t ) - 1 && WIFSTOPPED ( status ) ) { kill ( getpid ( ) , SIGSTOP ) ; kill ( pid , SIGCONT ) ; } else break ; } if ( pid != ( pid_t ) - 1 ) { if ( WIFSIGNALED ( status ) ) { fprintf ( stderr , ""%s%s\\n"" , strsignal ( WTERMSIG ( status ) ) , WCOREDUMP ( status ) ? _ ( ""<S2SV_blank>(core<S2SV_blank>dumped)"" ) : """" ) ; status = WTERMSIG ( status ) + 128 ; } else status = WEXITSTATUS ( status ) ; <S2SV_StartBug> } <S2SV_EndBug> else if ( caught_signal ) status = caught_signal + 128 ; else status = 1 ; } else status = 1 ; <S2SV_StartBug> if ( caught_signal ) <S2SV_EndBug> { fprintf ( stderr , _ ( ""\\nSession<S2SV_blank>terminated,<S2SV_blank>killing<S2SV_blank>shell..."" ) ) ; kill ( child , SIGTERM ) ; } cleanup_pam ( PAM_SUCCESS ) ; if ( caught_signal ) { <S2SV_StartBug> sleep ( 2 ) ; <S2SV_EndBug> kill ( child , SIGKILL ) ; <S2SV_StartBug> fprintf ( stderr , _ ( ""<S2SV_blank>...killed.\\n"" ) ) ; <S2SV_EndBug> switch ( caught_signal ) { case SIGTERM : sigaction ( SIGTERM , & oldact [ 0 ] , NULL ) ; break ; case SIGINT : sigaction ( SIGINT , & oldact [ 1 ] , NULL ) ; break ; case SIGQUIT : sigaction ( SIGQUIT , & oldact [ 2 ] , NULL ) ; break ; default : caught_signal = SIGKILL ; break ; } kill ( getpid ( ) , caught_signal ) ; } exit ( status ) ; }
","<S2SV_ModStart> status ) ; child = ( pid_t ) - 1 ; <S2SV_ModStart> if ( caught_signal && child != ( pid_t ) - 1 <S2SV_ModStart> caught_signal ) { if ( child != ( pid_t ) - 1 ) { <S2SV_ModStart> ) ) ; }
"
550,"CWE-125 static int print_lcp_config_options ( netdissect_options * ndo , const u_char * p , int length ) { int len , opt ; if ( length < 2 ) return 0 ; ND_TCHECK2 ( * p , 2 ) ; len = p [ 1 ] ; opt = p [ 0 ] ; if ( length < len ) return 0 ; if ( len < 2 ) { if ( ( opt >= LCPOPT_MIN ) && ( opt <= LCPOPT_MAX ) ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>2)"" , lcpconfopts [ opt ] , opt , len ) ) ; else ND_PRINT ( ( ndo , ""\\n\\tunknown<S2SV_blank>LCP<S2SV_blank>option<S2SV_blank>0x%02x"" , opt ) ) ; return 0 ; } if ( ( opt >= LCPOPT_MIN ) && ( opt <= LCPOPT_MAX ) ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u"" , lcpconfopts [ opt ] , opt , len ) ) ; else { ND_PRINT ( ( ndo , ""\\n\\tunknown<S2SV_blank>LCP<S2SV_blank>option<S2SV_blank>0x%02x"" , opt ) ) ; return len ; } switch ( opt ) { case LCPOPT_VEXT : if ( len < 6 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>6)"" ) ) ; return len ; } <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 3 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , "":<S2SV_blank>Vendor:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( oui_values , ""Unknown"" , EXTRACT_24BITS ( p + 2 ) ) , EXTRACT_24BITS ( p + 2 ) ) ) ; # if 0 ND_TCHECK ( p [ 5 ] ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>kind:<S2SV_blank>0x%02x"" , p [ 5 ] ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>Value:<S2SV_blank>0x"" ) ) ; for ( i = 0 ; i < len - 6 ; i ++ ) { ND_TCHECK ( p [ 6 + i ] ) ; ND_PRINT ( ( ndo , ""%02x"" , p [ 6 + i ] ) ) ; } # endif break ; case LCPOPT_MRU : if ( len != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>4)"" ) ) ; return len ; } <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , "":<S2SV_blank>%u"" , EXTRACT_16BITS ( p + 2 ) ) ) ; break ; case LCPOPT_ACCM : if ( len != 6 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>6)"" ) ) ; return len ; } <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 4 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , "":<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( p + 2 ) ) ) ; break ; case LCPOPT_AP : if ( len < 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>4)"" ) ) ; return len ; } <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , "":<S2SV_blank>%s"" , tok2str ( ppptype2str , ""Unknown<S2SV_blank>Auth<S2SV_blank>Proto<S2SV_blank>(0x04x)"" , EXTRACT_16BITS ( p + 2 ) ) ) ) ; switch ( EXTRACT_16BITS ( p + 2 ) ) { case PPP_CHAP : ND_TCHECK ( p [ 4 ] ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , tok2str ( authalg_values , ""Unknown<S2SV_blank>Auth<S2SV_blank>Alg<S2SV_blank>%u"" , p [ 4 ] ) ) ) ; break ; case PPP_PAP : case PPP_EAP : case PPP_SPAP : case PPP_SPAP_OLD : break ; default : print_unknown_data ( ndo , p , ""\\n\\t"" , len ) ; } break ; case LCPOPT_QP : if ( len < 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>4)"" ) ) ; return 0 ; } <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <S2SV_EndBug> if ( EXTRACT_16BITS ( p + 2 ) == PPP_LQM ) ND_PRINT ( ( ndo , "":<S2SV_blank>LQR"" ) ) ; else ND_PRINT ( ( ndo , "":<S2SV_blank>unknown"" ) ) ; break ; case LCPOPT_MN : if ( len != 6 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>6)"" ) ) ; return 0 ; } <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 4 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , "":<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( p + 2 ) ) ) ; break ; case LCPOPT_PFC : break ; case LCPOPT_ACFC : break ; case LCPOPT_LD : if ( len != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>4)"" ) ) ; return 0 ; } <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , "":<S2SV_blank>0x%04x"" , EXTRACT_16BITS ( p + 2 ) ) ) ; break ; case LCPOPT_CBACK : if ( len < 3 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>3)"" ) ) ; return 0 ; } ND_PRINT ( ( ndo , "":<S2SV_blank>"" ) ) ; ND_TCHECK ( p [ 2 ] ) ; ND_PRINT ( ( ndo , "":<S2SV_blank>Callback<S2SV_blank>Operation<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( ppp_callback_values , ""Unknown"" , p [ 2 ] ) , p [ 2 ] ) ) ; break ; case LCPOPT_MLMRRU : if ( len != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>4)"" ) ) ; return 0 ; } <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , "":<S2SV_blank>%u"" , EXTRACT_16BITS ( p + 2 ) ) ) ; break ; case LCPOPT_MLED : if ( len < 3 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>3)"" ) ) ; return 0 ; } ND_TCHECK ( p [ 2 ] ) ; switch ( p [ 2 ] ) { case MEDCLASS_NULL : ND_PRINT ( ( ndo , "":<S2SV_blank>Null"" ) ) ; break ; case MEDCLASS_LOCAL : ND_PRINT ( ( ndo , "":<S2SV_blank>Local"" ) ) ; break ; case MEDCLASS_IPV4 : if ( len != 7 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>7)"" ) ) ; return 0 ; } ND_TCHECK2 ( * ( p + 3 ) , 4 ) ; ND_PRINT ( ( ndo , "":<S2SV_blank>IPv4<S2SV_blank>%s"" , ipaddr_string ( ndo , p + 3 ) ) ) ; break ; case MEDCLASS_MAC : if ( len != 9 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>9)"" ) ) ; return 0 ; } ND_TCHECK2 ( * ( p + 3 ) , 6 ) ; ND_PRINT ( ( ndo , "":<S2SV_blank>MAC<S2SV_blank>%s"" , etheraddr_string ( ndo , p + 3 ) ) ) ; break ; case MEDCLASS_MNB : ND_PRINT ( ( ndo , "":<S2SV_blank>Magic-Num-Block"" ) ) ; break ; case MEDCLASS_PSNDN : ND_PRINT ( ( ndo , "":<S2SV_blank>PSNDN"" ) ) ; break ; default : ND_PRINT ( ( ndo , "":<S2SV_blank>Unknown<S2SV_blank>class<S2SV_blank>%u"" , p [ 2 ] ) ) ; break ; } break ; # if 0 case LCPOPT_DEP6 : case LCPOPT_FCSALT : case LCPOPT_SDP : case LCPOPT_NUMMODE : case LCPOPT_DEP12 : case LCPOPT_DEP14 : case LCPOPT_DEP15 : case LCPOPT_DEP16 : case LCPOPT_MLSSNHF : case LCPOPT_PROP : case LCPOPT_DCEID : case LCPOPT_MPP : case LCPOPT_LCPAOPT : case LCPOPT_COBS : case LCPOPT_PE : case LCPOPT_MLHF : case LCPOPT_I18N : case LCPOPT_SDLOS : case LCPOPT_PPPMUX : break ; # endif default : if ( ndo -> ndo_vflag < 2 ) print_unknown_data ( ndo , & p [ 2 ] , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len - 2 ) ; break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , & p [ 2 ] , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len - 2 ) ; return len ; trunc : ND_PRINT ( ( ndo , ""[|lcp]"" ) ) ; return 0 ; }
","<S2SV_ModStart> len ; } ND_TCHECK_24BITS ( p + 2 <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> len ; } ND_TCHECK_16BITS ( p + <S2SV_ModEnd> 2 ) ; <S2SV_ModStart> len ; } ND_TCHECK_32BITS ( p + 2 <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> len ; } ND_TCHECK_16BITS ( p + <S2SV_ModEnd> 2 ) ; <S2SV_ModStart> 0 ; } ND_TCHECK_16BITS ( p + <S2SV_ModEnd> 2 ) ; <S2SV_ModStart> 0 ; } ND_TCHECK_32BITS ( p + 2 <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> 0 ; } ND_TCHECK_16BITS ( p + <S2SV_ModEnd> 2 ) ; <S2SV_ModStart> 0 ; } ND_TCHECK_16BITS ( p + <S2SV_ModEnd> 2 ) ;
"
551,"CWE-772 static Image * ReadARTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { const unsigned char * pixels ; Image * image ; QuantumInfo * quantum_info ; MagickBooleanType status ; size_t length ; ssize_t count , y ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> depth = 1 ; image -> endian = MSBEndian ; ( void ) ReadBlobLSBShort ( image ) ; image -> columns = ( size_t ) ReadBlobLSBShort ( image ) ; ( void ) ReadBlobLSBShort ( image ) ; image -> rows = ( size_t ) ReadBlobLSBShort ( image ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; SetImageColorspace ( image , GRAYColorspace , exception ) ; quantum_info = AcquireQuantumInfo ( image_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; length = GetQuantumExtent ( image , quantum_info , GrayQuantum ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { register Quantum * magick_restrict q ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; if ( count != ( ssize_t ) length ) <S2SV_StartBug> ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; <S2SV_EndBug> ( void ) ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , GrayQuantum , pixels , exception ) ; pixels = ( const unsigned char * ) ReadBlobStream ( image , ( size_t ) ( - ( ssize_t ) length ) & 0x01 , GetQuantumPixels ( quantum_info ) , & count ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( SetImageProgress ( image , LoadImageTag , y , image -> rows ) == MagickFalse ) break ; } SetQuantumImageType ( image , GrayQuantum ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> ) length ) { quantum_info = DestroyQuantumInfo ( quantum_info ) ; <S2SV_ModStart> ""UnableToReadImageData"" ) ; }
"
552,"CWE-125 static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , ""<S2SV_blank>#%d<S2SV_blank>id=%s<S2SV_blank>"" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , ""<S2SV_blank>#%d<S2SV_blank>id=%d<S2SV_blank>"" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { <S2SV_StartBug> if ( map && nmap ) { <S2SV_EndBug> <S2SV_StartBug> cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , <S2SV_EndBug> map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
","<S2SV_ModStart> && nmap ) <S2SV_ModEnd> cp = ikev1_attrmap_print <S2SV_ModStart> , cp , ep2 , map , nmap ) ; else cp = ikev1_attr_print ( ndo , cp , ep2 ) ; if ( cp == NULL ) goto trunc ; } if <S2SV_ModStart> < ep2 ) <S2SV_ModEnd> ND_PRINT ( (
"
553,"CWE-190 jas_matrix_t * jas_matrix_create ( int numrows , int numcols ) { jas_matrix_t * matrix ; int i ; <S2SV_StartBug> if ( numrows < 0 || numcols < 0 ) { <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> } if ( ! ( matrix = jas_malloc ( sizeof ( jas_matrix_t ) ) ) ) { <S2SV_StartBug> return 0 ; <S2SV_EndBug> } matrix -> flags_ = 0 ; matrix -> numrows_ = numrows ; matrix -> numcols_ = numcols ; matrix -> rows_ = 0 ; matrix -> maxrows_ = numrows ; matrix -> data_ = 0 ; <S2SV_StartBug> matrix -> datasize_ = numrows * numcols ; <S2SV_EndBug> if ( matrix -> maxrows_ > 0 ) { if ( ! ( matrix -> rows_ = jas_alloc2 ( matrix -> maxrows_ , sizeof ( jas_seqent_t * ) ) ) ) { <S2SV_StartBug> jas_matrix_destroy ( matrix ) ; <S2SV_EndBug> return 0 ; } } if ( matrix -> datasize_ > 0 ) { if ( ! ( matrix -> data_ = jas_alloc2 ( matrix -> datasize_ , sizeof ( jas_seqent_t ) ) ) ) { <S2SV_StartBug> jas_matrix_destroy ( matrix ) ; <S2SV_EndBug> return 0 ; } } for ( i = 0 ; i < numrows ; ++ i ) { matrix -> rows_ [ i ] = & matrix -> data_ [ i * matrix -> numcols_ ] ; } for ( i = 0 ; i < matrix -> datasize_ ; ++ i ) { matrix -> data_ [ i ] = 0 ; } matrix -> xstart_ = 0 ; matrix -> ystart_ = 0 ; matrix -> xend_ = matrix -> numcols_ ; matrix -> yend_ = matrix -> numrows_ ; return matrix ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> int i ; size_t size ; matrix = 0 ; <S2SV_ModStart> 0 ) { goto error <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ) { goto error <S2SV_ModEnd> ; } matrix <S2SV_ModStart> -> datasize_ = 0 ; if ( ! jas_safe_size_mul ( numrows , numcols , & size ) ) { goto error ; } matrix -> datasize_ = size <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) { goto error <S2SV_ModEnd> ; } } <S2SV_ModStart> ) ) { goto error <S2SV_ModEnd> ; } } <S2SV_ModStart> return matrix ; error : if ( matrix ) { jas_matrix_destroy ( matrix ) ; } return 0 ;
"
554,"CWE-476 static int rds_ib_laddr_check ( __be32 addr ) { int ret ; struct rdma_cm_id * cm_id ; struct sockaddr_in sin ; cm_id = rdma_create_id ( NULL , NULL , RDMA_PS_TCP , IB_QPT_RC ) ; if ( IS_ERR ( cm_id ) ) return PTR_ERR ( cm_id ) ; memset ( & sin , 0 , sizeof ( sin ) ) ; sin . sin_family = AF_INET ; sin . sin_addr . s_addr = addr ; ret = rdma_bind_addr ( cm_id , ( struct sockaddr * ) & sin ) ; <S2SV_StartBug> if ( ret || cm_id -> device -> node_type != RDMA_NODE_IB_CA ) <S2SV_EndBug> ret = - EADDRNOTAVAIL ; rdsdebug ( ""addr<S2SV_blank>%pI4<S2SV_blank>ret<S2SV_blank>%d<S2SV_blank>node<S2SV_blank>type<S2SV_blank>%d\\n"" , & addr , ret , cm_id -> device ? cm_id -> device -> node_type : - 1 ) ; rdma_destroy_id ( cm_id ) ; return ret ; }
","<S2SV_ModStart> ( ret || ! cm_id -> device ||
"
555,"CWE-352 static void doPost ( HttpRequest req , HttpResponse res ) { set_content_type ( res , ""text/html"" ) ; <S2SV_StartBug> if ( ACTION ( RUN ) ) <S2SV_EndBug> handle_run ( req , res ) ; else if ( ACTION ( STATUS ) ) print_status ( req , res , 1 ) ; else if ( ACTION ( STATUS2 ) ) print_status ( req , res , 2 ) ; else if ( ACTION ( SUMMARY ) ) print_summary ( req , res ) ; else if ( ACTION ( REPORT ) ) _printReport ( req , res ) ; else if ( ACTION ( DOACTION ) ) <S2SV_StartBug> handle_do_action ( req , res ) ; <S2SV_EndBug> else <S2SV_StartBug> handle_action ( req , res ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ( ACTION ( RUNTIME ) ) handle_runtime_action ( req , res ) ; else if ( ACTION ( VIEWLOG ) ) do_viewlog <S2SV_ModEnd> ( req , <S2SV_ModStart> DOACTION ) ) handle_doaction <S2SV_ModEnd> ( req , <S2SV_ModStart> ) ; else handle_service_action <S2SV_ModEnd> ( req ,
"
556,"CWE-119 static int logi_dj_ll_raw_request ( struct hid_device * hid , unsigned char reportnum , __u8 * buf , size_t count , unsigned char report_type , int reqtype ) { struct dj_device * djdev = hid -> driver_data ; struct dj_receiver_dev * djrcv_dev = djdev -> dj_receiver_dev ; u8 * out_buf ; int ret ; if ( buf [ 0 ] != REPORT_TYPE_LEDS ) return - EINVAL ; out_buf = kzalloc ( DJREPORT_SHORT_LENGTH , GFP_ATOMIC ) ; if ( ! out_buf ) return - ENOMEM ; <S2SV_StartBug> if ( count < DJREPORT_SHORT_LENGTH - 2 ) <S2SV_EndBug> count = DJREPORT_SHORT_LENGTH - 2 ; out_buf [ 0 ] = REPORT_ID_DJ_SHORT ; out_buf [ 1 ] = djdev -> device_index ; memcpy ( out_buf + 2 , buf , count ) ; ret = hid_hw_raw_request ( djrcv_dev -> hdev , out_buf [ 0 ] , out_buf , DJREPORT_SHORT_LENGTH , report_type , reqtype ) ; kfree ( out_buf ) ; return ret ; }
","<S2SV_ModStart> if ( count > <S2SV_ModEnd> DJREPORT_SHORT_LENGTH - 2
"
557,"CWE-772 generic_ret * purgekeys_2_svc ( purgekeys_arg * arg , struct svc_req * rqstp ) { static generic_ret ret ; char * prime_arg , * funcname ; <S2SV_StartBug> gss_buffer_desc client_name , service_name ; <S2SV_EndBug> OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_generic_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; funcname = ""kadm5_purgekeys"" ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> princ , & prime_arg ) ) { ret . code = KADM5_BAD_PRINCIPAL ; goto exit_func ; } if ( ! cmp_gss_krb5_name ( handle , rqst2name ( rqstp ) , arg -> princ ) && ( CHANGEPW_SERVICE ( rqstp ) || ! kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_MODIFY , arg -> princ , NULL ) ) ) { ret . code = KADM5_AUTH_MODIFY ; log_unauth ( funcname , prime_arg , & client_name , & service_name , rqstp ) ; } else { ret . code = kadm5_purgekeys ( ( void * ) handle , arg -> princ , arg -> keepkvno ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( funcname , prime_arg , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } free ( prime_arg ) ; <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_StartBug> exit_func : <S2SV_EndBug> free_server_handle ( handle ) ; return & ret ; }
","<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> prime_arg ) ; exit_func : <S2SV_ModStart> service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
"
558,"CWE-400 static int hwahc_security_create ( struct hwahc * hwahc ) { int result ; struct wusbhc * wusbhc = & hwahc -> wusbhc ; struct usb_device * usb_dev = hwahc -> wa . usb_dev ; struct device * dev = & usb_dev -> dev ; struct usb_security_descriptor * secd ; struct usb_encryption_descriptor * etd ; void * itr , * top ; size_t itr_size , needed , bytes ; u8 index ; char buf [ 64 ] ; index = ( usb_dev -> actconfig - usb_dev -> config ) / sizeof ( usb_dev -> config [ 0 ] ) ; itr = usb_dev -> rawdescriptors [ index ] ; itr_size = le16_to_cpu ( usb_dev -> actconfig -> desc . wTotalLength ) ; top = itr + itr_size ; result = __usb_get_extra_descriptor ( usb_dev -> rawdescriptors [ index ] , le16_to_cpu ( usb_dev -> actconfig -> desc . wTotalLength ) , <S2SV_StartBug> USB_DT_SECURITY , ( void * * ) & secd ) ; <S2SV_EndBug> if ( result == - 1 ) { dev_warn ( dev , ""BUG?<S2SV_blank>WUSB<S2SV_blank>host<S2SV_blank>has<S2SV_blank>no<S2SV_blank>security<S2SV_blank>descriptors\\n"" ) ; return 0 ; } needed = sizeof ( * secd ) ; if ( top - ( void * ) secd < needed ) { dev_err ( dev , ""BUG?<S2SV_blank>Not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>to<S2SV_blank>process<S2SV_blank>security<S2SV_blank>"" ""descriptor<S2SV_blank>header<S2SV_blank>(%zu<S2SV_blank>bytes<S2SV_blank>left<S2SV_blank>vs<S2SV_blank>%zu<S2SV_blank>needed)\\n"" , top - ( void * ) secd , needed ) ; return 0 ; } needed = le16_to_cpu ( secd -> wTotalLength ) ; if ( top - ( void * ) secd < needed ) { dev_err ( dev , ""BUG?<S2SV_blank>Not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>to<S2SV_blank>process<S2SV_blank>security<S2SV_blank>"" ""descriptors<S2SV_blank>(%zu<S2SV_blank>bytes<S2SV_blank>left<S2SV_blank>vs<S2SV_blank>%zu<S2SV_blank>needed)\\n"" , top - ( void * ) secd , needed ) ; return 0 ; } itr = ( void * ) secd + sizeof ( * secd ) ; top = ( void * ) secd + le16_to_cpu ( secd -> wTotalLength ) ; index = 0 ; bytes = 0 ; while ( itr < top ) { etd = itr ; if ( top - itr < sizeof ( * etd ) ) { dev_err ( dev , ""BUG:<S2SV_blank>bad<S2SV_blank>host<S2SV_blank>security<S2SV_blank>descriptor;<S2SV_blank>"" ""not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>(%zu<S2SV_blank>vs<S2SV_blank>%zu<S2SV_blank>left)\\n"" , top - itr , sizeof ( * etd ) ) ; break ; } if ( etd -> bLength < sizeof ( * etd ) ) { dev_err ( dev , ""BUG:<S2SV_blank>bad<S2SV_blank>host<S2SV_blank>encryption<S2SV_blank>descriptor;<S2SV_blank>"" ""descriptor<S2SV_blank>is<S2SV_blank>too<S2SV_blank>short<S2SV_blank>"" ""(%zu<S2SV_blank>vs<S2SV_blank>%zu<S2SV_blank>needed)\\n"" , ( size_t ) etd -> bLength , sizeof ( * etd ) ) ; break ; } itr += etd -> bLength ; bytes += snprintf ( buf + bytes , sizeof ( buf ) - bytes , ""%s<S2SV_blank>(0x%02x)<S2SV_blank>"" , wusb_et_name ( etd -> bEncryptionType ) , etd -> bEncryptionValue ) ; wusbhc -> ccm1_etd = etd ; } dev_info ( dev , ""supported<S2SV_blank>encryption<S2SV_blank>types:<S2SV_blank>%s\\n"" , buf ) ; if ( wusbhc -> ccm1_etd == NULL ) { dev_err ( dev , ""E:<S2SV_blank>host<S2SV_blank>doesn\'t<S2SV_blank>support<S2SV_blank>CCM-1<S2SV_blank>crypto\\n"" ) ; return 0 ; } return 0 ; }
","<S2SV_ModStart> ) & secd , sizeof ( * secd )
"
559,"CWE-22 DEFINE_TEST ( test_write_disk_secure ) { # if defined ( _WIN32 ) && ! defined ( __CYGWIN__ ) skipping ( ""archive_write_disk<S2SV_blank>security<S2SV_blank>checks<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>on<S2SV_blank>Windows"" ) ; # else struct archive * a ; struct archive_entry * ae ; struct stat st ; assertUmask ( UMASK ) ; assert ( ( a = archive_write_disk_new ( ) ) != NULL ) ; assert ( ( ae = archive_entry_new ( ) ) != NULL ) ; archive_entry_copy_pathname ( ae , ""dir"" ) ; archive_entry_set_mode ( ae , S_IFDIR | 0777 ) ; assert ( 0 == archive_write_header ( a , ae ) ) ; archive_entry_free ( ae ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assert ( ( ae = archive_entry_new ( ) ) != NULL ) ; archive_entry_copy_pathname ( ae , ""link_to_dir"" ) ; archive_entry_set_mode ( ae , S_IFLNK | 0777 ) ; archive_entry_set_symlink ( ae , ""dir"" ) ; archive_write_disk_set_options ( a , 0 ) ; assert ( 0 == archive_write_header ( a , ae ) ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assert ( archive_entry_clear ( ae ) != NULL ) ; archive_entry_copy_pathname ( ae , ""link_to_dir/filea"" ) ; archive_entry_set_mode ( ae , S_IFREG | 0777 ) ; assert ( 0 == archive_write_header ( a , ae ) ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assert ( archive_entry_clear ( ae ) != NULL ) ; archive_entry_copy_pathname ( ae , ""link_to_dir/fileb"" ) ; archive_entry_set_mode ( ae , S_IFREG | 0777 ) ; archive_write_disk_set_options ( a , ARCHIVE_EXTRACT_SECURE_SYMLINKS ) ; failure ( ""Extracting<S2SV_blank>a<S2SV_blank>file<S2SV_blank>through<S2SV_blank>a<S2SV_blank>symlink<S2SV_blank>should<S2SV_blank>fail<S2SV_blank>here."" ) ; assertEqualInt ( ARCHIVE_FAILED , archive_write_header ( a , ae ) ) ; archive_entry_free ( ae ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assert ( ( ae = archive_entry_new ( ) ) != NULL ) ; archive_entry_copy_pathname ( ae , ""link_to_dir2"" ) ; archive_entry_set_mode ( ae , S_IFLNK | 0777 ) ; archive_entry_set_symlink ( ae , ""dir"" ) ; archive_write_disk_set_options ( a , 0 ) ; assert ( 0 == archive_write_header ( a , ae ) ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assert ( archive_entry_clear ( ae ) != NULL ) ; archive_entry_copy_pathname ( ae , ""link_to_dir2/filec"" ) ; archive_entry_set_mode ( ae , S_IFREG | 0777 ) ; archive_write_disk_set_options ( a , ARCHIVE_EXTRACT_SECURE_SYMLINKS | ARCHIVE_EXTRACT_UNLINK ) ; assertEqualIntA ( a , ARCHIVE_OK , archive_write_header ( a , ae ) ) ; archive_entry_free ( ae ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assert ( ( ae = archive_entry_new ( ) ) != NULL ) ; archive_entry_copy_pathname ( ae , ""link_to_dir3"" ) ; archive_entry_set_mode ( ae , S_IFLNK | 0777 ) ; archive_entry_set_symlink ( ae , ""dir"" ) ; archive_write_disk_set_options ( a , 0 ) ; assert ( 0 == archive_write_header ( a , ae ) ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assert ( archive_entry_clear ( ae ) != NULL ) ; archive_entry_copy_pathname ( ae , ""link_to_dir3"" ) ; archive_entry_set_mode ( ae , S_IFDIR | 0777 ) ; assert ( 0 == archive_write_header ( a , ae ) ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assertEqualInt ( 0 , lstat ( ""link_to_dir3"" , & st ) ) ; assert ( S_ISLNK ( st . st_mode ) ) ; archive_entry_free ( ae ) ; assert ( ( ae = archive_entry_new ( ) ) != NULL ) ; archive_entry_copy_pathname ( ae , ""link_to_dir4"" ) ; archive_entry_set_mode ( ae , S_IFLNK | 0777 ) ; archive_entry_set_symlink ( ae , ""nonexistent_dir"" ) ; archive_write_disk_set_options ( a , 0 ) ; assert ( 0 == archive_write_header ( a , ae ) ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assert ( archive_entry_clear ( ae ) != NULL ) ; archive_entry_copy_pathname ( ae , ""link_to_dir4"" ) ; archive_entry_set_mode ( ae , S_IFDIR | 0777 ) ; assert ( 0 == archive_write_header ( a , ae ) ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assertEqualInt ( 0 , lstat ( ""link_to_dir4"" , & st ) ) ; assert ( S_ISDIR ( st . st_mode ) ) ; archive_entry_free ( ae ) ; assert ( ( ae = archive_entry_new ( ) ) != NULL ) ; archive_entry_copy_pathname ( ae , ""non_dir"" ) ; archive_entry_set_mode ( ae , S_IFREG | 0777 ) ; archive_write_disk_set_options ( a , 0 ) ; assert ( 0 == archive_write_header ( a , ae ) ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; archive_entry_copy_pathname ( ae , ""link_to_dir5"" ) ; archive_entry_set_mode ( ae , S_IFLNK | 0777 ) ; archive_entry_set_symlink ( ae , ""non_dir"" ) ; archive_write_disk_set_options ( a , 0 ) ; assert ( 0 == archive_write_header ( a , ae ) ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assert ( archive_entry_clear ( ae ) != NULL ) ; archive_entry_copy_pathname ( ae , ""link_to_dir5"" ) ; archive_entry_set_mode ( ae , S_IFDIR | 0777 ) ; assert ( 0 == archive_write_header ( a , ae ) ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assertEqualInt ( 0 , lstat ( ""link_to_dir5"" , & st ) ) ; assert ( S_ISDIR ( st . st_mode ) ) ; archive_entry_free ( ae ) ; <S2SV_StartBug> assertEqualInt ( ARCHIVE_OK , archive_write_free ( a ) ) ; <S2SV_EndBug> assert ( 0 == lstat ( ""dir"" , & st ) ) ; failure ( ""dir:<S2SV_blank>st.st_mode=%o"" , st . st_mode ) ; assert ( ( st . st_mode & 0777 ) == 0755 ) ; assert ( 0 == lstat ( ""link_to_dir"" , & st ) ) ; failure ( ""link_to_dir:<S2SV_blank>st.st_mode=%o"" , st . st_mode ) ; assert ( S_ISLNK ( st . st_mode ) ) ; # if HAVE_LCHMOD failure ( ""link_to_dir:<S2SV_blank>st.st_mode=%o"" , st . st_mode ) ; assert ( ( st . st_mode & 07777 ) == 0755 ) ; # endif assert ( 0 == lstat ( ""dir/filea"" , & st ) ) ; failure ( ""dir/filea:<S2SV_blank>st.st_mode=%o"" , st . st_mode ) ; assert ( ( st . st_mode & 07777 ) == 0755 ) ; failure ( ""dir/fileb:<S2SV_blank>This<S2SV_blank>file<S2SV_blank>should<S2SV_blank>not<S2SV_blank>have<S2SV_blank>been<S2SV_blank>created"" ) ; assert ( 0 != lstat ( ""dir/fileb"" , & st ) ) ; assert ( 0 == lstat ( ""link_to_dir2"" , & st ) ) ; failure ( ""link_to_dir2<S2SV_blank>should<S2SV_blank>have<S2SV_blank>been<S2SV_blank>re-created<S2SV_blank>as<S2SV_blank>a<S2SV_blank>true<S2SV_blank>dir"" ) ; assert ( S_ISDIR ( st . st_mode ) ) ; failure ( ""link_to_dir2:<S2SV_blank>Implicit<S2SV_blank>dir<S2SV_blank>creation<S2SV_blank>should<S2SV_blank>obey<S2SV_blank>umask,<S2SV_blank>but<S2SV_blank>st.st_mode=%o"" , st . st_mode ) ; assert ( ( st . st_mode & 0777 ) == 0755 ) ; assert ( 0 == lstat ( ""link_to_dir2/filec"" , & st ) ) ; assert ( S_ISREG ( st . st_mode ) ) ; failure ( ""link_to_dir2/filec:<S2SV_blank>st.st_mode=%o"" , st . st_mode ) ; assert ( ( st . st_mode & 07777 ) == 0755 ) ; # endif }
","<S2SV_ModStart> ae ) ; assert ( ( ae = archive_entry_new ( ) ) != NULL ) ; archive_entry_copy_pathname ( ae , ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ; archive_entry_set_mode ( ae , S_IFREG | 0777 ) ; assert ( 0 == archive_write_header ( a , ae ) ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assertFileExists ( ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ; assert ( 0 == unlink ( ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ) ; assert ( archive_entry_clear ( ae ) != NULL ) ; archive_entry_copy_pathname ( ae , ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ; archive_entry_set_mode ( ae , S_IFREG | 0777 ) ; archive_write_disk_set_options ( a , ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ) ; failure ( ""Extracting<S2SV_blank>an<S2SV_blank>absolute<S2SV_blank>path<S2SV_blank>should<S2SV_blank>fail<S2SV_blank>here."" ) ; assertEqualInt ( ARCHIVE_FAILED , archive_write_header ( a , ae ) ) ; archive_entry_free ( ae ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assertFileNotExists ( ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ;
"
560,"CWE-119 static inline int check_entry_size_and_hooks ( struct arpt_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct arpt_entry ) != 0 || <S2SV_StartBug> ( unsigned char * ) e + sizeof ( struct arpt_entry ) >= limit ) { <S2SV_EndBug> duprintf ( ""Bad<S2SV_blank>offset<S2SV_blank>%p\\n"" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct arpt_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\n"" , e , e -> next_offset ) ; return - EINVAL ; } err = check_entry ( e ) ; if ( err ) return err ; for ( h = 0 ; h < NF_ARP_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) { pr_err ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>"" ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"" ""ACCEPT/DROP\\n"" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows [ h ] ; } } e -> counters = ( ( struct xt_counters ) { 0 , 0 } ) ; e -> comefrom = 0 ; return 0 ; }
","<S2SV_ModStart> arpt_entry ) >= limit || ( unsigned char * ) e + e -> next_offset >
"
561,"CWE-674 static void yydestruct ( const char * yymsg , int yytype , YYSTYPE * yyvaluep , void * yyscanner , HEX_LEX_ENVIRONMENT * lex_env ) { YYUSE ( yyvaluep ) ; YYUSE ( yyscanner ) ; YYUSE ( lex_env ) ; if ( ! yymsg ) yymsg = ""Deleting"" ; YY_SYMBOL_PRINT ( yymsg , yytype , yyvaluep , yylocationp ) ; YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN switch ( yytype ) { case 16 : <S2SV_StartBug> # line 94 ""hex_grammar.y"" <S2SV_EndBug> { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1023 ""hex_grammar.c"" break ; case 17 : <S2SV_StartBug> # line 95 ""hex_grammar.y"" <S2SV_EndBug> { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1029 ""hex_grammar.c"" break ; case 18 : <S2SV_StartBug> # line 96 ""hex_grammar.y"" <S2SV_EndBug> { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1035 ""hex_grammar.c"" break ; case 19 : <S2SV_StartBug> # line 97 ""hex_grammar.y"" <S2SV_EndBug> { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1041 ""hex_grammar.c"" break ; case 21 : <S2SV_StartBug> # line 100 ""hex_grammar.y"" <S2SV_EndBug> { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1047 ""hex_grammar.c"" break ; case 22 : <S2SV_StartBug> # line 99 ""hex_grammar.y"" <S2SV_EndBug> { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1053 ""hex_grammar.c"" break ; case 23 : <S2SV_StartBug> # line 98 ""hex_grammar.y"" <S2SV_EndBug> { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1059 ""hex_grammar.c"" break ; default : break ; } YY_IGNORE_MAYBE_UNINITIALIZED_END }
","<S2SV_ModStart> : # line 101 ""hex_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1030 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 102 ""hex_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1036 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 103 ""hex_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1042 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 104 ""hex_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1048 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 107 ""hex_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1054 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 106 ""hex_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1060 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 105 ""hex_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1066 <S2SV_ModEnd> ""hex_grammar.c"" break ;
"
562,"CWE-362 static int snd_ctl_elem_user_get ( struct snd_kcontrol * kcontrol , struct snd_ctl_elem_value * ucontrol ) { struct user_element * ue = kcontrol -> private_data ; <S2SV_StartBug> memcpy ( & ucontrol -> value , ue -> elem_data , ue -> elem_data_size ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
","<S2SV_ModStart> -> private_data ; mutex_lock ( & ue -> card -> user_ctl_lock ) ; <S2SV_ModStart> elem_data_size ) ; mutex_unlock ( & ue -> card -> user_ctl_lock ) ;
"
563,"CWE-834 static Image * ReadXBMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char buffer [ MagickPathExtent ] , name [ MagickPathExtent ] ; Image <S2SV_StartBug> * image ; <S2SV_EndBug> MagickBooleanType status ; register ssize_t i , x ; register Quantum * q ; register unsigned char * p ; short int hex_digits [ 256 ] ; ssize_t y ; unsigned char * data ; unsigned int bit , byte , bytes_per_line , height , length , padding , <S2SV_StartBug> value , <S2SV_EndBug> version , width ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } width = 0 ; height = 0 ; while ( ReadBlobString ( image , buffer ) != ( char * ) NULL ) if ( sscanf ( buffer , ""#define<S2SV_blank>%32s<S2SV_blank>%u"" , name , & width ) == 2 ) if ( ( strlen ( name ) >= 6 ) && ( LocaleCompare ( name + strlen ( name ) - 6 , ""_width"" ) == 0 ) ) break ; while ( ReadBlobString ( image , buffer ) != ( char * ) NULL ) if ( sscanf ( buffer , ""#define<S2SV_blank>%32s<S2SV_blank>%u"" , name , & height ) == 2 ) if ( ( strlen ( name ) >= 7 ) && ( LocaleCompare ( name + strlen ( name ) - 7 , ""_height"" ) == 0 ) ) break ; image -> columns = width ; image -> rows = height ; image -> depth = 8 ; image -> storage_class = PseudoClass ; image -> colors = 2 ; version = 11 ; while ( ReadBlobString ( image , buffer ) != ( char * ) NULL ) { if ( sscanf ( buffer , ""static<S2SV_blank>short<S2SV_blank>%32s<S2SV_blank>=<S2SV_blank>{"" , name ) == 1 ) version = 10 ; else if ( sscanf ( buffer , ""static<S2SV_blank>unsigned<S2SV_blank>char<S2SV_blank>%32s<S2SV_blank>=<S2SV_blank>{"" , name ) == 1 ) version = 11 ; else if ( sscanf ( buffer , ""static<S2SV_blank>char<S2SV_blank>%32s<S2SV_blank>=<S2SV_blank>{"" , name ) == 1 ) version = 11 ; else continue ; p = ( unsigned char * ) strrchr ( name , '_' ) ; if ( p == ( unsigned char * ) NULL ) p = ( unsigned char * ) name ; else p ++ ; if ( LocaleCompare ( ""bits[]"" , ( char * ) p ) == 0 ) break ; } if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) || ( EOFBlob ( image ) != MagickFalse ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_StartBug> image -> colormap [ 0 ] . red = QuantumRange ; <S2SV_EndBug> <S2SV_StartBug> image -> colormap [ 0 ] . green = QuantumRange ; <S2SV_EndBug> <S2SV_StartBug> image -> colormap [ 0 ] . blue = QuantumRange ; <S2SV_EndBug> <S2SV_StartBug> image -> colormap [ 1 ] . red = ( Quantum ) 0 ; <S2SV_EndBug> <S2SV_StartBug> image -> colormap [ 1 ] . green = ( Quantum ) 0 ; <S2SV_EndBug> <S2SV_StartBug> image -> colormap [ 1 ] . blue = ( Quantum ) 0 ; <S2SV_EndBug> if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; hex_digits [ ( int ) '0' ] = 0 ; hex_digits [ ( int ) '1' ] = 1 ; hex_digits [ ( int ) '2' ] = 2 ; hex_digits [ ( int ) '3' ] = 3 ; hex_digits [ ( int ) '4' ] = 4 ; hex_digits [ ( int ) '5' ] = 5 ; hex_digits [ ( int ) '6' ] = 6 ; hex_digits [ ( int ) '7' ] = 7 ; hex_digits [ ( int ) '8' ] = 8 ; hex_digits [ ( int ) '9' ] = 9 ; hex_digits [ ( int ) 'A' ] = 10 ; hex_digits [ ( int ) 'B' ] = 11 ; hex_digits [ ( int ) 'C' ] = 12 ; hex_digits [ ( int ) 'D' ] = 13 ; hex_digits [ ( int ) 'E' ] = 14 ; hex_digits [ ( int ) 'F' ] = 15 ; hex_digits [ ( int ) 'a' ] = 10 ; hex_digits [ ( int ) 'b' ] = 11 ; hex_digits [ ( int ) 'c' ] = 12 ; hex_digits [ ( int ) 'd' ] = 13 ; hex_digits [ ( int ) 'e' ] = 14 ; hex_digits [ ( int ) 'f' ] = 15 ; hex_digits [ ( int ) 'x' ] = 0 ; hex_digits [ ( int ) '<S2SV_blank>' ] = ( - 1 ) ; hex_digits [ ( int ) ',' ] = ( - 1 ) ; hex_digits [ ( int ) '}' ] = ( - 1 ) ; hex_digits [ ( int ) '\\n' ] = ( - 1 ) ; hex_digits [ ( int ) '\\t' ] = ( - 1 ) ; padding = 0 ; if ( ( ( image -> columns % 16 ) != 0 ) && ( ( image -> columns % 16 ) < 9 ) && ( version == 10 ) ) padding = 1 ; bytes_per_line = ( unsigned int ) ( image -> columns + 7 ) / 8 + padding ; length = ( unsigned int ) image -> rows ; data = ( unsigned char * ) AcquireQuantumMemory ( length , bytes_per_line * sizeof ( * data ) ) ; if ( data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = data ; if ( version == 10 ) for ( i = 0 ; i < ( ssize_t ) ( bytes_per_line * image -> rows ) ; ( i += 2 ) ) { <S2SV_StartBug> value = XBMInteger ( image , hex_digits ) ; <S2SV_EndBug> <S2SV_StartBug> * p ++ = ( unsigned char ) value ; <S2SV_EndBug> if ( ( padding == 0 ) || ( ( ( i + 2 ) % bytes_per_line ) != 0 ) ) <S2SV_StartBug> * p ++ = ( unsigned char ) ( value >> 8 ) ; <S2SV_EndBug> } else for ( i = 0 ; i < ( ssize_t ) ( bytes_per_line * image -> rows ) ; i ++ ) { <S2SV_StartBug> value = XBMInteger ( image , hex_digits ) ; <S2SV_EndBug> <S2SV_StartBug> * p ++ = ( unsigned char ) value ; <S2SV_EndBug> } p = data ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; bit = 0 ; byte = 0 ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( bit == 0 ) <S2SV_StartBug> byte = ( size_t ) ( * p ++ ) ; <S2SV_EndBug> SetPixelIndex ( image , ( Quantum ) ( ( byte & 0x01 ) != 0 ? 0x01 : 0x00 ) , q ) ; bit ++ ; byte >>= 1 ; if ( bit == 8 ) bit = 0 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; ( void ) SyncImage ( image , exception ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> Image * image ; int c <S2SV_ModStart> , padding , <S2SV_ModEnd> version , width <S2SV_ModStart> . red = ( MagickRealType ) <S2SV_ModStart> . green = ( MagickRealType ) <S2SV_ModStart> . blue = ( MagickRealType ) <S2SV_ModStart> . red = 0.0 <S2SV_ModEnd> ; image -> <S2SV_ModStart> . green = 0.0 <S2SV_ModEnd> ; image -> <S2SV_ModStart> . blue = 0.0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) { c <S2SV_ModEnd> = XBMInteger ( <S2SV_ModStart> , hex_digits ) ; if ( c < 0 ) break <S2SV_ModStart> unsigned char ) c <S2SV_ModEnd> ; if ( <S2SV_ModStart> char ) ( c <S2SV_ModEnd> >> 8 ) <S2SV_ModStart> ++ ) { c <S2SV_ModEnd> = XBMInteger ( <S2SV_ModStart> , hex_digits ) ; if ( c < 0 ) break <S2SV_ModStart> unsigned char ) c ; } if ( EOFBlob ( image ) != MagickFalse ) { data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) <S2SV_ModEnd> ; } p <S2SV_ModStart> byte = ( unsigned int <S2SV_ModEnd> ) ( *
"
564,"CWE-787 static PixelChannels * * AcquirePixelThreadSet ( const Image * images ) { const Image * next ; PixelChannels * * pixels ; register ssize_t i ; size_t columns , <S2SV_StartBug> number_threads ; <S2SV_EndBug> <S2SV_StartBug> number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ; <S2SV_EndBug> <S2SV_StartBug> pixels = ( PixelChannels * * ) AcquireQuantumMemory ( number_threads , <S2SV_EndBug> sizeof ( * pixels ) ) ; if ( pixels == ( PixelChannels * * ) NULL ) return ( ( PixelChannels * * ) NULL ) ; <S2SV_StartBug> ( void ) memset ( pixels , 0 , number_threads * sizeof ( * pixels ) ) ; <S2SV_EndBug> columns = images -> columns ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) number_threads ; i ++ ) <S2SV_EndBug> { register ssize_t j ; pixels [ i ] = ( PixelChannels * ) AcquireQuantumMemory ( columns , sizeof ( * * pixels ) ) ; if ( pixels [ i ] == ( PixelChannels * ) NULL ) return ( DestroyPixelThreadSet ( pixels ) ) ; for ( j = 0 ; j < ( ssize_t ) columns ; j ++ ) { register ssize_t k ; for ( k = 0 ; k < MaxPixelChannels ; k ++ ) pixels [ i ] [ j ] . channel [ k ] = 0.0 ; } } return ( pixels ) ; }
","<S2SV_ModStart> size_t columns , rows ; rows = MagickMax ( GetImageListLength ( images ) , <S2SV_ModEnd> ( size_t ) <S2SV_ModStart> ( ThreadResource ) ) <S2SV_ModStart> ) AcquireQuantumMemory ( rows , <S2SV_ModEnd> sizeof ( * <S2SV_ModStart> NULL ) ; columns = MaxPixelChannels ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; for ( i = 0 <S2SV_ModEnd> ; i < <S2SV_ModStart> ( ssize_t ) rows <S2SV_ModEnd> ; i ++
"
565,"CWE-119 <S2SV_StartBug> static void rd_pick_sb_modes ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_EndBug> int mi_row , int mi_col , <S2SV_StartBug> int * totalrate , int64_t * totaldist , <S2SV_EndBug> BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx , int64_t best_rd ) { VP9_COMMON * const cm = & cpi -> common ; <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> MACROBLOCKD * const xd = & x -> e_mbd ; MB_MODE_INFO * mbmi ; struct macroblock_plane * const p = x -> plane ; struct macroblockd_plane * const pd = xd -> plane ; const AQ_MODE aq_mode = cpi -> oxcf . aq_mode ; int i , orig_rdmult ; <S2SV_StartBug> double rdmult_ratio ; <S2SV_EndBug> vp9_clear_system_state ( ) ; rdmult_ratio = 1.0 ; x -> use_lp32x32fdct = 1 ; <S2SV_StartBug> if ( bsize < BLOCK_8X8 ) { <S2SV_EndBug> if ( x -> ab_index != 0 ) { * totalrate = 0 ; * totaldist = 0 ; return ; } } <S2SV_StartBug> set_offsets ( cpi , tile , mi_row , mi_col , bsize ) ; <S2SV_EndBug> mbmi = & xd -> mi [ 0 ] -> mbmi ; mbmi -> sb_type = bsize ; for ( i = 0 ; i < MAX_MB_PLANE ; ++ i ) { p [ i ] . coeff = ctx -> coeff_pbuf [ i ] [ 0 ] ; p [ i ] . qcoeff = ctx -> qcoeff_pbuf [ i ] [ 0 ] ; pd [ i ] . dqcoeff = ctx -> dqcoeff_pbuf [ i ] [ 0 ] ; p [ i ] . eobs = ctx -> eobs_pbuf [ i ] [ 0 ] ; } ctx -> is_coded = 0 ; <S2SV_StartBug> x -> skip_recode = 0 ; <S2SV_EndBug> mbmi -> skip = 0 ; <S2SV_StartBug> x -> source_variance = get_sby_perpixel_variance ( cpi , x , bsize ) ; <S2SV_EndBug> if ( aq_mode == VARIANCE_AQ ) { const int energy = bsize <= BLOCK_16X16 ? x -> mb_energy : vp9_block_energy ( cpi , x , bsize ) ; if ( cm -> frame_type == KEY_FRAME || cpi -> refresh_alt_ref_frame || ( cpi -> refresh_golden_frame && ! cpi -> rc . is_src_frame_alt_ref ) ) { mbmi -> segment_id = vp9_vaq_segment_id ( energy ) ; } else { const uint8_t * const map = cm -> seg . update_map ? cpi -> segmentation_map : cm -> last_frame_seg_map ; <S2SV_StartBug> mbmi -> segment_id = vp9_get_segment_id ( cm , map , bsize , mi_row , mi_col ) ; <S2SV_EndBug> } <S2SV_StartBug> rdmult_ratio = vp9_vaq_rdmult_ratio ( energy ) ; <S2SV_EndBug> vp9_init_plane_quantizers ( cpi , x ) ; } <S2SV_StartBug> orig_rdmult = x -> rdmult ; <S2SV_EndBug> if ( cpi -> oxcf . tuning == VP8_TUNE_SSIM ) activity_masking ( cpi , x ) ; if ( aq_mode == VARIANCE_AQ ) { vp9_clear_system_state ( ) ; x -> rdmult = ( int ) round ( x -> rdmult * rdmult_ratio ) ; } else if ( aq_mode == COMPLEXITY_AQ ) { <S2SV_StartBug> const int mi_offset = mi_row * cm -> mi_cols + mi_col ; <S2SV_EndBug> unsigned char complexity = cpi -> complexity_map [ mi_offset ] ; const int is_edge = ( mi_row <= 1 ) || ( mi_row >= ( cm -> mi_rows - 2 ) ) || ( mi_col <= 1 ) || ( mi_col >= ( cm -> mi_cols - 2 ) ) ; if ( ! is_edge && ( complexity > 128 ) ) <S2SV_StartBug> x -> rdmult += ( ( x -> rdmult * ( complexity - 128 ) ) / 256 ) ; <S2SV_EndBug> } else if ( aq_mode == CYCLIC_REFRESH_AQ ) { const uint8_t * const map = cm -> seg . update_map ? cpi -> segmentation_map : cm -> last_frame_seg_map ; <S2SV_StartBug> if ( vp9_get_segment_id ( cm , map , bsize , mi_row , mi_col ) ) <S2SV_EndBug> x -> rdmult = vp9_cyclic_refresh_get_rdmult ( cpi -> cyclic_refresh ) ; } if ( frame_is_intra_only ( cm ) ) { <S2SV_StartBug> vp9_rd_pick_intra_mode_sb ( cpi , x , totalrate , totaldist , bsize , ctx , <S2SV_EndBug> best_rd ) ; } else { <S2SV_StartBug> if ( bsize >= BLOCK_8X8 ) <S2SV_EndBug> <S2SV_StartBug> vp9_rd_pick_inter_mode_sb ( cpi , x , tile , mi_row , mi_col , <S2SV_EndBug> <S2SV_StartBug> totalrate , totaldist , bsize , ctx , best_rd ) ; <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> vp9_rd_pick_inter_mode_sub8x8 ( cpi , x , tile , mi_row , mi_col , totalrate , <S2SV_EndBug> totaldist , bsize , ctx , best_rd ) ; } <S2SV_StartBug> if ( aq_mode == VARIANCE_AQ ) { <S2SV_EndBug> x -> rdmult = orig_rdmult ; <S2SV_StartBug> if ( * totalrate != INT_MAX ) { <S2SV_EndBug> vp9_clear_system_state ( ) ; * totalrate = ( int ) round ( * totalrate * rdmult_ratio ) ; } <S2SV_StartBug> } else if ( aq_mode == COMPLEXITY_AQ || aq_mode == CYCLIC_REFRESH_AQ ) { <S2SV_EndBug> x -> rdmult = orig_rdmult ; } }
","<S2SV_ModStart> * cpi , TileDataEnc * tile_data , MACROBLOCK * const x <S2SV_ModEnd> , int mi_row <S2SV_ModStart> int mi_col , RD_COST * rd_cost <S2SV_ModEnd> , BLOCK_SIZE bsize <S2SV_ModStart> -> common ; TileInfo * const tile_info = & tile_data -> tile_info <S2SV_ModEnd> ; MACROBLOCKD * <S2SV_ModStart> , orig_rdmult ; vpx_clear_system_state ( ) <S2SV_ModEnd> ; x -> <S2SV_ModStart> = 1 ; <S2SV_ModEnd> set_offsets ( cpi <S2SV_ModStart> ( cpi , tile_info , x <S2SV_ModEnd> , mi_row , <S2SV_ModStart> = 0 ; ctx -> skippable = 0 ; ctx -> pred_pixel_ready = 0 ; <S2SV_ModStart> = 0 ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { <S2SV_ModStart> -> source_variance = vp9_high_get_sby_perpixel_variance ( cpi , & x -> plane [ 0 ] . src , bsize , xd -> bd ) ; } else { x -> source_variance = vp9_get_sby_perpixel_variance ( cpi , & x -> plane [ 0 ] . src , bsize ) ; } # else x -> source_variance = vp9_get_sby_perpixel_variance ( cpi , & x -> plane [ 0 ] . src , bsize ) ; # endif orig_rdmult = x -> rdmult <S2SV_ModEnd> ; if ( <S2SV_ModStart> -> segment_id = get_segment_id <S2SV_ModEnd> ( cm , <S2SV_ModStart> ) ; } <S2SV_ModEnd> x -> rdmult <S2SV_ModStart> x -> rdmult = set_segment_rdmult ( cpi , x , mbmi -> segment_id <S2SV_ModEnd> ) ; } <S2SV_ModStart> COMPLEXITY_AQ ) { <S2SV_ModEnd> x -> rdmult <S2SV_ModStart> x -> rdmult = set_segment_rdmult ( cpi , x , mbmi -> segment_id <S2SV_ModEnd> ) ; } <S2SV_ModStart> ; if ( cyclic_refresh_segment_id_boosted ( get_segment_id <S2SV_ModEnd> ( cm , <S2SV_ModStart> mi_col ) ) ) <S2SV_ModStart> , x , rd_cost , bsize , ctx , <S2SV_ModEnd> best_rd ) ; <S2SV_ModStart> >= BLOCK_8X8 ) { if ( segfeature_active ( & cm -> seg , mbmi -> segment_id , SEG_LVL_SKIP ) ) vp9_rd_pick_inter_mode_sb_seg_skip ( cpi , tile_data , x , rd_cost , bsize , ctx , best_rd ) ; else <S2SV_ModStart> ( cpi , tile_data , x <S2SV_ModEnd> , mi_row , <S2SV_ModStart> , mi_col , rd_cost <S2SV_ModEnd> , bsize , <S2SV_ModStart> best_rd ) ; } else { <S2SV_ModEnd> vp9_rd_pick_inter_mode_sub8x8 ( cpi <S2SV_ModStart> ( cpi , tile_data , x <S2SV_ModEnd> , mi_row , <S2SV_ModStart> , mi_col , rd_cost <S2SV_ModEnd> , bsize , <S2SV_ModStart> ) ; } } if ( ( rd_cost -> rate <S2SV_ModEnd> != INT_MAX ) <S2SV_ModStart> != INT_MAX ) && <S2SV_ModEnd> ( aq_mode == <S2SV_ModStart> aq_mode == COMPLEXITY_AQ ) && ( bsize >= BLOCK_16X16 ) && ( cm -> frame_type == KEY_FRAME || cpi -> refresh_alt_ref_frame || ( cpi -> refresh_golden_frame && ! cpi -> rc . is_src_frame_alt_ref ) ) ) { vp9_caq_select_segment ( cpi , x , bsize , mi_row , mi_col , rd_cost -> rate ) ; } x -> rdmult = orig_rdmult ; if ( rd_cost -> rate == INT_MAX ) rd_cost -> rdcost = INT64_MAX ; ctx -> rate = rd_cost -> rate ; ctx -> dist = rd_cost -> dist ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
"
566,"CWE-476 static int dissect_usb_ms_bulk ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * parent_tree , void * data ) { usb_conv_info_t * usb_conv_info ; usb_ms_conv_info_t * usb_ms_conv_info ; proto_tree * tree ; proto_item * ti ; guint32 signature = 0 ; int offset = 0 ; gboolean is_request ; itl_nexus_t * itl ; itlq_nexus_t * itlq ; if ( data == NULL ) return 0 ; usb_conv_info = ( usb_conv_info_t * ) data ; usb_ms_conv_info = ( usb_ms_conv_info_t * ) usb_conv_info -> class_data ; if ( ! usb_ms_conv_info ) { usb_ms_conv_info = wmem_new ( wmem_file_scope ( ) , usb_ms_conv_info_t ) ; usb_ms_conv_info -> itl = wmem_tree_new ( wmem_file_scope ( ) ) ; usb_ms_conv_info -> itlq = wmem_tree_new ( wmem_file_scope ( ) ) ; usb_conv_info -> class_data = usb_ms_conv_info ; <S2SV_StartBug> } <S2SV_EndBug> is_request = ( pinfo -> srcport == NO_ENDPOINT ) ; col_set_str ( pinfo -> cinfo , COL_PROTOCOL , ""USBMS"" ) ; col_clear ( pinfo -> cinfo , COL_INFO ) ; ti = proto_tree_add_protocol_format ( parent_tree , proto_usb_ms , tvb , 0 , - 1 , ""USB<S2SV_blank>Mass<S2SV_blank>Storage"" ) ; tree = proto_item_add_subtree ( ti , ett_usb_ms ) ; signature = tvb_get_letohl ( tvb , offset ) ; if ( is_request && ( signature == 0x43425355 ) && ( tvb_reported_length ( tvb ) == 31 ) ) { tvbuff_t * cdb_tvb ; int cdbrlen , cdblen ; guint8 lun , flags ; guint32 datalen ; proto_tree_add_item ( tree , hf_usb_ms_dCBWSignature , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ; offset += 4 ; proto_tree_add_item ( tree , hf_usb_ms_dCBWTag , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ; offset += 4 ; proto_tree_add_item ( tree , hf_usb_ms_dCBWDataTransferLength , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ; datalen = tvb_get_letohl ( tvb , offset ) ; offset += 4 ; proto_tree_add_item ( tree , hf_usb_ms_dCBWFlags , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; flags = tvb_get_guint8 ( tvb , offset ) ; offset += 1 ; proto_tree_add_item ( tree , hf_usb_ms_dCBWTarget , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; proto_tree_add_item ( tree , hf_usb_ms_dCBWLUN , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; lun = tvb_get_guint8 ( tvb , offset ) & 0x0f ; offset += 1 ; itl = ( itl_nexus_t * ) wmem_tree_lookup32 ( usb_ms_conv_info -> itl , lun ) ; if ( ! itl ) { itl = wmem_new ( wmem_file_scope ( ) , itl_nexus_t ) ; itl -> cmdset = 0xff ; itl -> conversation = NULL ; wmem_tree_insert32 ( usb_ms_conv_info -> itl , lun , itl ) ; } itlq = ( itlq_nexus_t * ) wmem_tree_lookup32 ( usb_ms_conv_info -> itlq , pinfo -> num ) ; if ( ! itlq ) { itlq = wmem_new ( wmem_file_scope ( ) , itlq_nexus_t ) ; itlq -> lun = lun ; itlq -> scsi_opcode = 0xffff ; itlq -> task_flags = 0 ; if ( datalen ) { if ( flags & 0x80 ) { itlq -> task_flags |= SCSI_DATA_READ ; } else { itlq -> task_flags |= SCSI_DATA_WRITE ; } } itlq -> data_length = datalen ; itlq -> bidir_data_length = 0 ; itlq -> fc_time = pinfo -> abs_ts ; itlq -> first_exchange_frame = pinfo -> num ; itlq -> last_exchange_frame = 0 ; itlq -> flags = 0 ; itlq -> alloc_len = 0 ; itlq -> extra_data = NULL ; wmem_tree_insert32 ( usb_ms_conv_info -> itlq , pinfo -> num , itlq ) ; } proto_tree_add_item ( tree , hf_usb_ms_dCBWCBLength , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; cdbrlen = tvb_get_guint8 ( tvb , offset ) & 0x1f ; offset += 1 ; cdblen = cdbrlen ; if ( cdblen > tvb_captured_length_remaining ( tvb , offset ) ) { cdblen = tvb_captured_length_remaining ( tvb , offset ) ; } if ( cdblen ) { cdb_tvb = tvb_new_subset ( tvb , offset , cdblen , cdbrlen ) ; dissect_scsi_cdb ( cdb_tvb , pinfo , parent_tree , SCSI_DEV_UNKNOWN , itlq , itl ) ; } return tvb_captured_length ( tvb ) ; } if ( ( ! is_request ) && ( signature == 0x53425355 ) && ( tvb_reported_length ( tvb ) == 13 ) ) { guint8 status ; proto_tree_add_item ( tree , hf_usb_ms_dCSWSignature , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ; offset += 4 ; proto_tree_add_item ( tree , hf_usb_ms_dCBWTag , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ; offset += 4 ; proto_tree_add_item ( tree , hf_usb_ms_dCSWDataResidue , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ; offset += 4 ; proto_tree_add_item ( tree , hf_usb_ms_dCSWStatus , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; status = tvb_get_guint8 ( tvb , offset ) ; itlq = ( itlq_nexus_t * ) wmem_tree_lookup32_le ( usb_ms_conv_info -> itlq , pinfo -> num ) ; if ( ! itlq ) { return tvb_captured_length ( tvb ) ; } itlq -> last_exchange_frame = pinfo -> num ; itl = ( itl_nexus_t * ) wmem_tree_lookup32 ( usb_ms_conv_info -> itl , itlq -> lun ) ; if ( ! itl ) { return tvb_captured_length ( tvb ) ; } if ( ! status ) { dissect_scsi_rsp ( tvb , pinfo , parent_tree , itlq , itl , 0 ) ; } else { dissect_scsi_rsp ( tvb , pinfo , parent_tree , itlq , itl , 0x02 ) ; } return tvb_captured_length ( tvb ) ; } itlq = ( itlq_nexus_t * ) wmem_tree_lookup32_le ( usb_ms_conv_info -> itlq , pinfo -> num ) ; if ( ! itlq ) { return tvb_captured_length ( tvb ) ; } itl = ( itl_nexus_t * ) wmem_tree_lookup32 ( usb_ms_conv_info -> itl , itlq -> lun ) ; if ( ! itl ) { return tvb_captured_length ( tvb ) ; } dissect_scsi_payload ( tvb , pinfo , parent_tree , is_request , itlq , itl , 0 ) ; return tvb_captured_length ( tvb ) ; }
","<S2SV_ModStart> = usb_ms_conv_info ; usb_conv_info -> class_data_type = USB_CONV_MASS_STORAGE ; } else if ( usb_conv_info -> class_data_type != USB_CONV_MASS_STORAGE ) { return 0 ;
"
567,"CWE-416 static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; register Quantum * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } quantum_info = ( QuantumInfo * ) NULL ; clone_info = ( ImageInfo * ) NULL ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) != 0 ) { image2 = ReadMATImageV4 ( image_info , image , exception ) ; if ( image2 == NULL ) goto MATLAB_KO ; image = image2 ; goto END_OF_READING ; } MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c"" , MATLAB_HDR . EndianIndicator [ 0 ] , MATLAB_HDR . EndianIndicator [ 1 ] ) ; if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""IM"" , 2 ) ) { ReadBlobXXXLong = ReadBlobLSBLong ; ReadBlobXXXShort = ReadBlobLSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesLSB ; ReadBlobFloatsXXX = ReadBlobFloatsLSB ; image -> endian = LSBEndian ; } else if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""MI"" , 2 ) ) { ReadBlobXXXLong = ReadBlobMSBLong ; ReadBlobXXXShort = ReadBlobMSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesMSB ; ReadBlobFloatsXXX = ReadBlobFloatsMSB ; image -> endian = MSBEndian ; } else goto MATLAB_KO ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) ) { MATLAB_KO : if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; if ( clone_info != ( ImageInfo * ) NULL ) clone_info = DestroyImageInfo ( clone_info ) ; ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } filepos = TellBlob ( image ) ; while ( ! EOFBlob ( image ) ) { Frames = 1 ; ( void ) SeekBlob ( image , filepos , SEEK_SET ) ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; if ( ( MagickSizeType ) ( MATLAB_HDR . ObjectSize + filepos ) > GetBlobSize ( image ) ) goto MATLAB_KO ; filepos += MATLAB_HDR . ObjectSize + 4 + 4 ; clone_info = CloneImageInfo ( image_info ) ; image2 = image ; # if defined ( MAGICKCORE_ZLIB_DELEGATE ) if ( MATLAB_HDR . DataType == miCOMPRESSED ) { image2 = decompress_block ( image , & MATLAB_HDR . ObjectSize , clone_info , exception ) ; if ( image2 == NULL ) continue ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image2 ) ; } # endif if ( MATLAB_HDR . DataType != miMATRIX ) { clone_info = DestroyImageInfo ( clone_info ) ; continue ; } MATLAB_HDR . unknown1 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown2 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown5 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . StructureClass = MATLAB_HDR . unknown5 & 0xFF ; MATLAB_HDR . StructureFlag = ( MATLAB_HDR . unknown5 >> 8 ) & 0xFF ; MATLAB_HDR . unknown3 = ReadBlobXXXLong ( image2 ) ; if ( image != image2 ) MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . DimFlag = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeX = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeY = ReadBlobXXXLong ( image2 ) ; switch ( MATLAB_HDR . DimFlag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = ReadBlobXXXLong ( image2 ) ; ( void ) ReadBlobXXXLong ( image2 ) ; if ( z != 3 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; break ; case 16 : z2 = z = ReadBlobXXXLong ( image2 ) ; if ( z != 3 && z != 1 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; Frames = ReadBlobXXXLong ( image2 ) ; if ( Frames == 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; break ; default : if ( clone_info != ( ImageInfo * ) NULL ) clone_info = DestroyImageInfo ( clone_info ) ; if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; } MATLAB_HDR . Flag1 = ReadBlobXXXShort ( image2 ) ; MATLAB_HDR . NameFlag = ReadBlobXXXShort ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.StructureClass<S2SV_blank>%d"" , MATLAB_HDR . StructureClass ) ; if ( MATLAB_HDR . StructureClass != mxCHAR_CLASS && MATLAB_HDR . StructureClass != mxSINGLE_CLASS && MATLAB_HDR . StructureClass != mxDOUBLE_CLASS && MATLAB_HDR . StructureClass != mxINT8_CLASS && MATLAB_HDR . StructureClass != mxUINT8_CLASS && MATLAB_HDR . StructureClass != mxINT16_CLASS && MATLAB_HDR . StructureClass != mxUINT16_CLASS && MATLAB_HDR . StructureClass != mxINT32_CLASS && MATLAB_HDR . StructureClass != mxUINT32_CLASS && MATLAB_HDR . StructureClass != mxINT64_CLASS && MATLAB_HDR . StructureClass != mxUINT64_CLASS ) ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; switch ( MATLAB_HDR . NameFlag ) { case 0 : size = ReadBlobXXXLong ( image2 ) ; size = 4 * ( ssize_t ) ( ( size + 3 + 1 ) / 4 ) ; ( void ) SeekBlob ( image2 , size , SEEK_CUR ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto MATLAB_KO ; } CellType = ReadBlobXXXLong ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.CellType:<S2SV_blank>%.20g"" , ( double ) CellType ) ; ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; NEXT_FRAME : switch ( CellType ) { case miINT8 : case miUINT8 : sample_size = 8 ; if ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) MATLAB_HDR . SizeX ; break ; case miINT16 : case miUINT16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * MATLAB_HDR . SizeX ) ; break ; case miINT32 : case miUINT32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miINT64 : case miUINT64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; case miSINGLE : sample_size = 32 ; image -> depth = 32 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miDOUBLE : sample_size = 64 ; image -> depth = 64 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; DisableMSCWarning ( 4127 ) if ( sizeof ( double ) != 8 ) RestoreMSCWarning ThrowReaderException ( CoderError , ""IncompatibleSizeOfDouble"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; default : if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; if ( clone_info ) clone_info = DestroyImageInfo ( clone_info ) ; ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; } ( void ) sample_size ; image -> columns = MATLAB_HDR . SizeX ; image -> rows = MATLAB_HDR . SizeY ; one = 1 ; image -> colors = one << image -> depth ; if ( image -> columns == 0 || image -> rows == 0 ) goto MATLAB_KO ; if ( ( unsigned long ) ldblk * MATLAB_HDR . SizeY > MATLAB_HDR . ObjectSize ) goto MATLAB_KO ; if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) { image -> type = GrayscaleType ; SetImageColorspace ( image , GRAYColorspace , exception ) ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) { if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; return ( DestroyImageList ( image ) ) ; } quantum_info = AcquireQuantumInfo ( clone_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( double ) ) ; if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) ResetMagickMemory ( BImgBuff , 0 , ldblk * sizeof ( double ) ) ; MinVal = 0 ; MaxVal = 0 ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { q = GetAuthenticPixels ( image , 0 , MATLAB_HDR . SizeY - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto done_reading ; } if ( ReadBlob ( image2 , ldblk , ( unsigned char * ) BImgBuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } if ( ( CellType == miINT8 || CellType == miUINT8 ) && ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) ) { FixLogical ( ( unsigned char * ) BImgBuff , ldblk ) ; if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) { ImportQuantumPixelsFailed : if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; break ; } } else { if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) goto ImportQuantumPixelsFailed ; if ( z <= 1 && ( CellType == miINT8 || CellType == miINT16 || CellType == miINT32 || CellType == miINT64 ) ) FixSignedValues ( image , q , MATLAB_HDR . SizeX ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } } } while ( z -- >= 2 ) ; ExitLoop : if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { CellType = ReadBlobXXXLong ( image2 ) ; i = ReadBlobXXXLong ( image2 ) ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & MinVal , & MaxVal ) ; } if ( CellType == miDOUBLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobDoublesXXX ( image2 , ldblk , ( double * ) BImgBuff ) ; InsertComplexDoubleRow ( image , ( double * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } if ( CellType == miSINGLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobFloatsXXX ( image2 , ldblk , ( float * ) BImgBuff ) ; InsertComplexFloatRow ( image , ( float * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } } if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) image -> type = GrayscaleType ; if ( image -> depth == 1 ) image -> type = BilevelType ; if ( image2 == image ) image2 = NULL ; rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; blob = rotated_image -> blob ; rotated_image -> blob = image -> blob ; rotated_image -> colors = image -> colors ; image -> blob = blob ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } done_reading : if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } AcquireNextImage ( image_info , image , exception ) ; if ( image -> next == ( Image * ) NULL ) break ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; RelinquishMagickMemory ( BImgBuff ) ; BImgBuff = NULL ; if ( -- Frames > 0 ) { z = z2 ; if ( image2 == NULL ) image2 = image ; goto NEXT_FRAME ; } if ( ( image2 != NULL ) && ( image2 != image ) ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } if ( quantum_info != ( QuantumInfo * ) NULL ) quantum_info = DestroyQuantumInfo ( quantum_info ) ; if ( clone_info ) clone_info = DestroyImageInfo ( clone_info ) ; } RelinquishMagickMemory ( BImgBuff ) ; if ( quantum_info != ( QuantumInfo * ) NULL ) quantum_info = DestroyQuantumInfo ( quantum_info ) ; END_OF_READING : <S2SV_StartBug> if ( clone_info ) <S2SV_EndBug> clone_info = DestroyImageInfo ( clone_info ) ; CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; <S2SV_StartBug> DeleteImageFromList ( & tmp ) ; <S2SV_EndBug> } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != NULL ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } DestroyImageInfo ( clone_info ) ; clone_info = NULL ; } if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""return"" ) ; if ( image == NULL ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) else if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; return ( image ) ; }
","<S2SV_ModStart> ; END_OF_READING : <S2SV_ModEnd> CloseBlob ( image <S2SV_ModStart> -> previous ; if ( tmp == image2 ) image2 = ( Image * ) NULL ;
"
568,"CWE-476 static long btrfs_ioctl_dev_info ( struct btrfs_fs_info * fs_info , void __user * arg ) { struct btrfs_ioctl_dev_info_args * di_args ; struct btrfs_device * dev ; int ret = 0 ; char * s_uuid = NULL ; di_args = memdup_user ( arg , sizeof ( * di_args ) ) ; if ( IS_ERR ( di_args ) ) return PTR_ERR ( di_args ) ; if ( ! btrfs_is_empty_uuid ( di_args -> uuid ) ) s_uuid = di_args -> uuid ; rcu_read_lock ( ) ; dev = btrfs_find_device ( fs_info -> fs_devices , di_args -> devid , s_uuid , <S2SV_StartBug> NULL ) ; <S2SV_EndBug> if ( ! dev ) { ret = - ENODEV ; goto out ; } di_args -> devid = dev -> devid ; di_args -> bytes_used = btrfs_device_get_bytes_used ( dev ) ; di_args -> total_bytes = btrfs_device_get_total_bytes ( dev ) ; memcpy ( di_args -> uuid , dev -> uuid , sizeof ( di_args -> uuid ) ) ; if ( dev -> name ) { strncpy ( di_args -> path , rcu_str_deref ( dev -> name ) , sizeof ( di_args -> path ) - 1 ) ; di_args -> path [ sizeof ( di_args -> path ) - 1 ] = 0 ; } else { di_args -> path [ 0 ] = '\\0' ; } out : rcu_read_unlock ( ) ; if ( ret == 0 && copy_to_user ( arg , di_args , sizeof ( * di_args ) ) ) ret = - EFAULT ; kfree ( di_args ) ; return ret ; }
","<S2SV_ModStart> s_uuid , NULL , true
"
569,"CWE-000 <S2SV_StartBug> static void sas_probe_devices ( struct work_struct * work ) <S2SV_EndBug> { <S2SV_StartBug> struct domain_device * dev , * n ; <S2SV_EndBug> struct sas_discovery_event * ev = to_sas_discovery_event ( work ) ; struct asd_sas_port * port = ev -> port ; clear_bit ( DISCE_PROBE , & port -> disc . pending ) ; list_for_each_entry ( dev , & port -> disco_list , disco_list_node ) { spin_lock_irq ( & port -> dev_list_lock ) ; list_add_tail ( & dev -> dev_list_node , & port -> dev_list ) ; spin_unlock_irq ( & port -> dev_list_lock ) ; } sas_probe_sata ( port ) ; list_for_each_entry_safe ( dev , n , & port -> disco_list , disco_list_node ) { int err ; err = sas_rphy_add ( dev -> rphy ) ; if ( err ) sas_fail_probe ( dev , __func__ , err ) ; else list_del_init ( & dev -> disco_list_node ) ; } }
","<S2SV_ModStart> sas_probe_devices ( struct asd_sas_port * port <S2SV_ModEnd> ) { struct <S2SV_ModStart> , * n <S2SV_ModEnd> ; list_for_each_entry (
"
570,"CWE-416 static int rm_read_multi ( AVFormatContext * s , AVIOContext * pb , AVStream * st , char * mime ) { int number_of_streams = avio_rb16 ( pb ) ; int number_of_mdpr ; int i , ret ; unsigned size2 ; for ( i = 0 ; i < number_of_streams ; i ++ ) avio_rb16 ( pb ) ; number_of_mdpr = avio_rb16 ( pb ) ; if ( number_of_mdpr != 1 ) { avpriv_request_sample ( s , ""MLTI<S2SV_blank>with<S2SV_blank>multiple<S2SV_blank>(%d)<S2SV_blank>MDPR"" , number_of_mdpr ) ; } for ( i = 0 ; i < number_of_mdpr ; i ++ ) { AVStream * st2 ; if ( i > 0 ) { st2 = avformat_new_stream ( s , NULL ) ; if ( ! st2 ) { ret = AVERROR ( ENOMEM ) ; return ret ; } st2 -> id = st -> id + ( i << 16 ) ; st2 -> codecpar -> bit_rate = st -> codecpar -> bit_rate ; st2 -> start_time = st -> start_time ; st2 -> duration = st -> duration ; st2 -> codecpar -> codec_type = AVMEDIA_TYPE_DATA ; st2 -> priv_data = ff_rm_alloc_rmstream ( ) ; if ( ! st2 -> priv_data ) return AVERROR ( ENOMEM ) ; } else st2 = st ; size2 = avio_rb32 ( pb ) ; ret = ff_rm_read_mdpr_codecdata ( s , s -> pb , st2 , st2 -> priv_data , <S2SV_StartBug> size2 , mime ) ; <S2SV_EndBug> if ( ret < 0 ) return ret ; } return 0 ; }
","<S2SV_ModStart> , size2 , NULL <S2SV_ModEnd> ) ; if
"
571,"CWE-787 static int directblockRead ( struct READER * reader , struct DATAOBJECT * dataobject , struct FRACTALHEAP * fractalheap ) { char buf [ 4 ] , * name , * value ; int size , offset_size , length_size , err , len ; uint8_t typeandversion ; uint64_t unknown , heap_header_address , block_offset , block_size , offset , length ; long store ; struct DIR * dir ; struct MYSOFA_ATTRIBUTE * attr ; UNUSED ( offset ) ; UNUSED ( block_size ) ; UNUSED ( block_offset ) ; <S2SV_StartBug> if ( fread ( buf , 1 , 4 , reader -> fhd ) != 4 || strncmp ( buf , ""FHDB"" , 4 ) ) { <S2SV_EndBug> log ( ""cannot<S2SV_blank>read<S2SV_blank>signature<S2SV_blank>of<S2SV_blank>fractal<S2SV_blank>heap<S2SV_blank>indirect<S2SV_blank>block\\n"" ) ; return MYSOFA_INVALID_FORMAT ; } <S2SV_StartBug> log ( ""%08"" PRIX64 ""<S2SV_blank>%.4s\\n"" , ( uint64_t ) ftell ( reader -> fhd ) - 4 , buf ) ; <S2SV_EndBug> if ( fgetc ( reader -> fhd ) != 0 ) { log ( ""object<S2SV_blank>FHDB<S2SV_blank>must<S2SV_blank>have<S2SV_blank>version<S2SV_blank>0\\n"" ) ; return MYSOFA_UNSUPPORTED_FORMAT ; } if ( fseek ( reader -> fhd , reader -> superblock . size_of_offsets , SEEK_CUR ) < 0 ) return errno ; size = ( fractalheap -> maximum_heap_size + 7 ) / 8 ; block_offset = readValue ( reader , size ) ; if ( fractalheap -> flags & 2 ) if ( fseek ( reader -> fhd , 4 , SEEK_CUR ) ) return errno ; offset_size = ceilf ( log2f ( fractalheap -> maximum_heap_size ) / 8 ) ; if ( fractalheap -> maximum_direct_block_size < fractalheap -> maximum_size ) length_size = ceilf ( log2f ( fractalheap -> maximum_direct_block_size ) / 8 ) ; else length_size = ceilf ( log2f ( fractalheap -> maximum_size ) / 8 ) ; log ( ""<S2SV_blank>%d<S2SV_blank>%"" PRIu64 ""<S2SV_blank>%d\\n"" , size , block_offset , offset_size ) ; do { typeandversion = ( uint8_t ) fgetc ( reader -> fhd ) ; offset = readValue ( reader , offset_size ) ; length = readValue ( reader , length_size ) ; if ( offset > 0x10000000 || length > 0x10000000 ) return MYSOFA_UNSUPPORTED_FORMAT ; log ( ""<S2SV_blank>%d<S2SV_blank>%4"" PRIX64 ""<S2SV_blank>%"" PRIX64 ""<S2SV_blank>%08lX\\n"" , typeandversion , offset , length , ftell ( reader -> fhd ) ) ; if ( typeandversion == 3 ) { if ( readValue ( reader , 5 ) != 0x0000040008 ) { log ( ""FHDB<S2SV_blank>type<S2SV_blank>3<S2SV_blank>unsupported<S2SV_blank>values"" ) ; return MYSOFA_UNSUPPORTED_FORMAT ; } if ( ! ( name = malloc ( length + 1 ) ) ) return MYSOFA_NO_MEMORY ; if ( fread ( name , 1 , length , reader -> fhd ) != length ) { free ( name ) ; return MYSOFA_READ_ERROR ; } name [ length ] = 0 ; if ( readValue ( reader , 4 ) != 0x00000013 ) { log ( ""FHDB<S2SV_blank>type<S2SV_blank>3<S2SV_blank>unsupported<S2SV_blank>values"" ) ; free ( name ) ; return MYSOFA_UNSUPPORTED_FORMAT ; } len = ( int ) readValue ( reader , 2 ) ; if ( len > 0x1000 || len < 0 ) { free ( name ) ; return MYSOFA_UNSUPPORTED_FORMAT ; } unknown = readValue ( reader , 6 ) ; if ( unknown == 0x000000020200 ) value = NULL ; else if ( unknown == 0x000000020000 ) { if ( ! ( value = malloc ( len + 1 ) ) ) { free ( name ) ; return MYSOFA_NO_MEMORY ; } if ( fread ( value , 1 , len , reader -> fhd ) != len ) { free ( value ) ; free ( name ) ; return MYSOFA_READ_ERROR ; } value [ len ] = 0 ; } else if ( unknown == 0x20000020000 ) { if ( ! ( value = malloc ( 5 ) ) ) { free ( name ) ; return MYSOFA_NO_MEMORY ; } strcpy ( value , """" ) ; } else { log ( ""FHDB<S2SV_blank>type<S2SV_blank>3<S2SV_blank>unsupported<S2SV_blank>values:<S2SV_blank>%12"" PRIX64 ""\\n"" , unknown ) ; free ( name ) ; return MYSOFA_OK ; } log ( ""<S2SV_blank>%s<S2SV_blank>=<S2SV_blank>%s\\n"" , name , value ) ; attr = malloc ( sizeof ( struct MYSOFA_ATTRIBUTE ) ) ; attr -> name = name ; attr -> value = value ; attr -> next = dataobject -> attributes ; dataobject -> attributes = attr ; } else if ( typeandversion == 1 ) { unknown = readValue ( reader , 6 ) ; if ( unknown ) { log ( ""FHDB<S2SV_blank>type<S2SV_blank>1<S2SV_blank>unsupported<S2SV_blank>values\\n"" ) ; return MYSOFA_UNSUPPORTED_FORMAT ; } len = fgetc ( reader -> fhd ) ; if ( len < 0 ) return MYSOFA_READ_ERROR ; assert ( len < 0x100 ) ; if ( ! ( name = malloc ( len + 1 ) ) ) return MYSOFA_NO_MEMORY ; if ( fread ( name , 1 , len , reader -> fhd ) != len ) { free ( name ) ; return MYSOFA_READ_ERROR ; } name [ len ] = 0 ; heap_header_address = readValue ( reader , reader -> superblock . size_of_offsets ) ; log ( ""\\nfractal<S2SV_blank>head<S2SV_blank>type<S2SV_blank>1<S2SV_blank>length<S2SV_blank>%4"" PRIX64 ""<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>address<S2SV_blank>%"" PRIX64 ""\\n"" , length , name , heap_header_address ) ; dir = malloc ( sizeof ( struct DIR ) ) ; if ( ! dir ) { free ( name ) ; return MYSOFA_NO_MEMORY ; } memset ( dir , 0 , sizeof ( * dir ) ) ; dir -> next = dataobject -> directory ; dataobject -> directory = dir ; store = ftell ( reader -> fhd ) ; if ( fseek ( reader -> fhd , heap_header_address , SEEK_SET ) ) { free ( name ) ; return errno ; } err = dataobjectRead ( reader , & dir -> dataobject , name ) ; if ( err ) { return err ; } if ( store < 0 ) { return errno ; } if ( fseek ( reader -> fhd , store , SEEK_SET ) < 0 ) return errno ; } else if ( typeandversion != 0 ) { log ( ""fractal<S2SV_blank>head<S2SV_blank>unknown<S2SV_blank>type<S2SV_blank>%d\\n"" , typeandversion ) ; return MYSOFA_OK ; } } while ( typeandversion != 0 ) ; <S2SV_StartBug> return MYSOFA_OK ; <S2SV_EndBug> }
","<S2SV_ModStart> ; if ( reader -> recursive_counter >= 10 ) return MYSOFA_INVALID_FORMAT ; else reader -> recursive_counter ++ ; if ( <S2SV_ModStart> ( ""%08"" PRIX64 ""<S2SV_blank>%.4s<S2SV_blank>stack<S2SV_blank>%d\\n"" <S2SV_ModEnd> , ( uint64_t <S2SV_ModStart> 4 , buf , reader -> recursive_counter <S2SV_ModStart> 0 ) ; reader -> recursive_counter -- ;
"
572,"CWE-200 static int pptp_bind ( struct socket * sock , struct sockaddr * uservaddr , int sockaddr_len ) { struct sock * sk = sock -> sk ; struct sockaddr_pppox * sp = ( struct sockaddr_pppox * ) uservaddr ; struct pppox_sock * po = pppox_sk ( sk ) ; struct pptp_opt * opt = & po -> proto . pptp ; int error = 0 ; <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> opt -> src_addr = sp -> sa_addr . pptp ; if ( add_chan ( po ) ) error = - EBUSY ; release_sock ( sk ) ; return error ; }
","<S2SV_ModStart> = 0 ; if ( sockaddr_len < sizeof ( struct sockaddr_pppox ) ) return - EINVAL ;
"
573,"CWE-20 int mpi_powm ( MPI res , MPI base , MPI exp , MPI mod ) { mpi_ptr_t mp_marker = NULL , bp_marker = NULL , ep_marker = NULL ; mpi_ptr_t xp_marker = NULL ; mpi_ptr_t tspace = NULL ; mpi_ptr_t rp , ep , mp , bp ; mpi_size_t esize , msize , bsize , rsize ; int esign , msign , bsign , rsign ; mpi_size_t size ; int mod_shift_cnt ; int negative_result ; int assign_rp = 0 ; mpi_size_t tsize = 0 ; int rc = - ENOMEM ; esize = exp -> nlimbs ; msize = mod -> nlimbs ; size = 2 * msize ; esign = exp -> sign ; msign = mod -> sign ; rp = res -> d ; ep = exp -> d ; if ( ! msize ) return - EINVAL ; if ( ! esize ) { <S2SV_StartBug> rp [ 0 ] = 1 ; <S2SV_EndBug> <S2SV_StartBug> res -> nlimbs = ( msize == 1 && mod -> d [ 0 ] == 1 ) ? 0 : 1 ; <S2SV_EndBug> res -> sign = 0 ; goto leave ; } mp = mp_marker = mpi_alloc_limb_space ( msize ) ; if ( ! mp ) goto enomem ; mod_shift_cnt = count_leading_zeros ( mod -> d [ msize - 1 ] ) ; if ( mod_shift_cnt ) mpihelp_lshift ( mp , mod -> d , msize , mod_shift_cnt ) ; else MPN_COPY ( mp , mod -> d , msize ) ; bsize = base -> nlimbs ; bsign = base -> sign ; if ( bsize > msize ) { bp = bp_marker = mpi_alloc_limb_space ( bsize + 1 ) ; if ( ! bp ) goto enomem ; MPN_COPY ( bp , base -> d , bsize ) ; mpihelp_divrem ( bp + msize , 0 , bp , bsize , mp , msize ) ; bsize = msize ; MPN_NORMALIZE ( bp , bsize ) ; } else bp = base -> d ; if ( ! bsize ) { res -> nlimbs = 0 ; res -> sign = 0 ; goto leave ; } if ( res -> alloced < size ) { if ( rp == ep || rp == mp || rp == bp ) { rp = mpi_alloc_limb_space ( size ) ; if ( ! rp ) goto enomem ; assign_rp = 1 ; } else { if ( mpi_resize ( res , size ) < 0 ) goto enomem ; rp = res -> d ; } } else { if ( rp == bp ) { BUG_ON ( bp_marker ) ; bp = bp_marker = mpi_alloc_limb_space ( bsize ) ; if ( ! bp ) goto enomem ; MPN_COPY ( bp , rp , bsize ) ; } if ( rp == ep ) { ep = ep_marker = mpi_alloc_limb_space ( esize ) ; if ( ! ep ) goto enomem ; MPN_COPY ( ep , rp , esize ) ; } if ( rp == mp ) { BUG_ON ( mp_marker ) ; mp = mp_marker = mpi_alloc_limb_space ( msize ) ; if ( ! mp ) goto enomem ; MPN_COPY ( mp , rp , msize ) ; } } MPN_COPY ( rp , bp , bsize ) ; rsize = bsize ; rsign = bsign ; { mpi_size_t i ; mpi_ptr_t xp ; int c ; mpi_limb_t e ; mpi_limb_t carry_limb ; struct karatsuba_ctx karactx ; xp = xp_marker = mpi_alloc_limb_space ( 2 * ( msize + 1 ) ) ; if ( ! xp ) goto enomem ; memset ( & karactx , 0 , sizeof karactx ) ; negative_result = ( ep [ 0 ] & 1 ) && base -> sign ; i = esize - 1 ; e = ep [ i ] ; c = count_leading_zeros ( e ) ; e = ( e << c ) << 1 ; c = BITS_PER_MPI_LIMB - 1 - c ; for ( ; ; ) { while ( c ) { mpi_ptr_t tp ; mpi_size_t xsize ; if ( rsize < KARATSUBA_THRESHOLD ) mpih_sqr_n_basecase ( xp , rp , rsize ) ; else { if ( ! tspace ) { tsize = 2 * rsize ; tspace = mpi_alloc_limb_space ( tsize ) ; if ( ! tspace ) goto enomem ; } else if ( tsize < ( 2 * rsize ) ) { mpi_free_limb_space ( tspace ) ; tsize = 2 * rsize ; tspace = mpi_alloc_limb_space ( tsize ) ; if ( ! tspace ) goto enomem ; } mpih_sqr_n ( xp , rp , rsize , tspace ) ; } xsize = 2 * rsize ; if ( xsize > msize ) { mpihelp_divrem ( xp + msize , 0 , xp , xsize , mp , msize ) ; xsize = msize ; } tp = rp ; rp = xp ; xp = tp ; rsize = xsize ; if ( ( mpi_limb_signed_t ) e < 0 ) { if ( bsize < KARATSUBA_THRESHOLD ) { mpi_limb_t tmp ; if ( mpihelp_mul ( xp , rp , rsize , bp , bsize , & tmp ) < 0 ) goto enomem ; } else { if ( mpihelp_mul_karatsuba_case ( xp , rp , rsize , bp , bsize , & karactx ) < 0 ) goto enomem ; } xsize = rsize + bsize ; if ( xsize > msize ) { mpihelp_divrem ( xp + msize , 0 , xp , xsize , mp , msize ) ; xsize = msize ; } tp = rp ; rp = xp ; xp = tp ; rsize = xsize ; } e <<= 1 ; c -- ; } i -- ; if ( i < 0 ) break ; e = ep [ i ] ; c = BITS_PER_MPI_LIMB ; } if ( mod_shift_cnt ) { carry_limb = mpihelp_lshift ( res -> d , rp , rsize , mod_shift_cnt ) ; rp = res -> d ; if ( carry_limb ) { rp [ rsize ] = carry_limb ; rsize ++ ; } } else { MPN_COPY ( res -> d , rp , rsize ) ; rp = res -> d ; } if ( rsize >= msize ) { mpihelp_divrem ( rp + msize , 0 , rp , rsize , mp , msize ) ; rsize = msize ; } if ( mod_shift_cnt ) mpihelp_rshift ( rp , rp , rsize , mod_shift_cnt ) ; MPN_NORMALIZE ( rp , rsize ) ; mpihelp_release_karatsuba_ctx ( & karactx ) ; } if ( negative_result && rsize ) { if ( mod_shift_cnt ) mpihelp_rshift ( mp , mp , msize , mod_shift_cnt ) ; mpihelp_sub ( rp , mp , msize , rp , rsize ) ; rsize = msize ; rsign = msign ; MPN_NORMALIZE ( rp , rsize ) ; } res -> nlimbs = rsize ; res -> sign = rsign ; leave : rc = 0 ; enomem : if ( assign_rp ) mpi_assign_limb_space ( res , rp , size ) ; if ( mp_marker ) mpi_free_limb_space ( mp_marker ) ; if ( bp_marker ) mpi_free_limb_space ( bp_marker ) ; if ( ep_marker ) mpi_free_limb_space ( ep_marker ) ; if ( xp_marker ) mpi_free_limb_space ( xp_marker ) ; if ( tspace ) mpi_free_limb_space ( tspace ) ; return rc ; }
","<S2SV_ModStart> esize ) { <S2SV_ModEnd> res -> nlimbs <S2SV_ModStart> : 1 ; if ( res -> nlimbs ) { if ( mpi_resize ( res , 1 ) < 0 ) goto enomem ; rp = res -> d ; rp [ 0 ] = 1 ; }
"
574,"CWE-125 PyObject * ast2obj_withitem ( void * _o ) { withitem_ty o = ( withitem_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { <S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug> return Py_None ; } result = PyType_GenericNew ( withitem_type , NULL , NULL ) ; if ( ! result ) return NULL ; value = ast2obj_expr ( o -> context_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_context_expr , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> optional_vars ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_optional_vars , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }
","<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } result
"
575,"CWE-119 void WT_NoiseGenerator ( S_WT_VOICE * pWTVoice , S_WT_INT_FRAME * pWTIntFrame ) { EAS_PCM * pOutputBuffer ; EAS_I32 phaseInc ; EAS_I32 tmp0 ; EAS_I32 tmp1 ; EAS_I32 nInterpolatedSample ; EAS_I32 numSamples ; numSamples = pWTIntFrame -> numSamples ; if ( numSamples <= 0 ) { <S2SV_StartBug> ALOGE ( ""b/26366256"" ) ; <S2SV_EndBug> return ; } pOutputBuffer = pWTIntFrame -> pAudioBuffer ; phaseInc = pWTIntFrame -> frame . phaseIncrement ; tmp0 = ( EAS_I32 ) ( pWTVoice -> phaseAccum ) >> 18 ; tmp1 = ( EAS_I32 ) ( pWTVoice -> loopEnd ) >> 18 ; while ( numSamples -- ) { nInterpolatedSample = MULT_AUDIO_COEF ( tmp0 , ( PHASE_ONE - pWTVoice -> phaseFrac ) ) ; nInterpolatedSample += MULT_AUDIO_COEF ( tmp1 , pWTVoice -> phaseFrac ) ; * pOutputBuffer ++ = ( EAS_PCM ) nInterpolatedSample ; pWTVoice -> phaseFrac += ( EAS_U32 ) phaseInc ; if ( GET_PHASE_INT_PART ( pWTVoice -> phaseFrac ) ) { tmp0 = tmp1 ; pWTVoice -> phaseAccum = pWTVoice -> loopEnd ; pWTVoice -> loopEnd = ( 5 * pWTVoice -> loopEnd + 1 ) ; tmp1 = ( EAS_I32 ) ( pWTVoice -> loopEnd ) >> 18 ; pWTVoice -> phaseFrac = GET_PHASE_FRAC_PART ( pWTVoice -> phaseFrac ) ; } } }
","<S2SV_ModStart> ALOGE ( ""b/26366256"" ) ; android_errorWriteLog ( 0x534e4554 , ""26366256""
"
576,"CWE-190 static int jpc_ppm_getparms ( jpc_ms_t * ms , jpc_cstate_t * cstate , jas_stream_t * in ) { jpc_ppm_t * ppm = & ms -> parms . ppm ; cstate = 0 ; ppm -> data = 0 ; if ( ms -> len < 1 ) { goto error ; } if ( jpc_getuint8 ( in , & ppm -> ind ) ) { goto error ; } ppm -> len = ms -> len - 1 ; if ( ppm -> len > 0 ) { if ( ! ( ppm -> data = jas_malloc ( ppm -> len ) ) ) { goto error ; } <S2SV_StartBug> if ( JAS_CAST ( uint , jas_stream_read ( in , ppm -> data , ppm -> len ) ) != ppm -> len ) { <S2SV_EndBug> goto error ; } } else { ppm -> data = 0 ; } return 0 ; error : jpc_ppm_destroyparms ( ms ) ; return - 1 ; }
","<S2SV_ModStart> ( JAS_CAST ( jas_uint <S2SV_ModEnd> , jas_stream_read (
"
577,"CWE-362 static int smb_send_kvec ( struct TCP_Server_Info * server , struct kvec * iov , size_t n_vec , size_t * sent ) { int rc = 0 ; int i = 0 ; struct msghdr smb_msg ; unsigned int remaining ; size_t first_vec = 0 ; struct socket * ssocket = server -> ssocket ; <S2SV_StartBug> * sent = 0 ; <S2SV_EndBug> if ( ssocket == NULL ) return - ENOTSOCK ; smb_msg . msg_name = ( struct sockaddr * ) & server -> dstaddr ; smb_msg . msg_namelen = sizeof ( struct sockaddr ) ; smb_msg . msg_control = NULL ; smb_msg . msg_controllen = 0 ; if ( server -> noblocksnd ) smb_msg . msg_flags = MSG_DONTWAIT + MSG_NOSIGNAL ; else smb_msg . msg_flags = MSG_NOSIGNAL ; remaining = 0 ; for ( i = 0 ; i < n_vec ; i ++ ) remaining += iov [ i ] . iov_len ; i = 0 ; while ( remaining ) { rc = kernel_sendmsg ( ssocket , & smb_msg , & iov [ first_vec ] , n_vec - first_vec , remaining ) ; if ( rc == - ENOSPC || rc == - EAGAIN ) { WARN_ON_ONCE ( rc == - ENOSPC ) ; i ++ ; if ( i >= 14 || ( ! server -> noblocksnd && ( i > 2 ) ) ) { cERROR ( 1 , ""sends<S2SV_blank>on<S2SV_blank>sock<S2SV_blank>%p<S2SV_blank>stuck<S2SV_blank>for<S2SV_blank>15<S2SV_blank>"" ""seconds"" , ssocket ) ; rc = - EAGAIN ; break ; } msleep ( 1 << i ) ; continue ; } if ( rc < 0 ) break ; * sent += rc ; if ( rc == remaining ) { remaining = 0 ; break ; } if ( rc > remaining ) { cERROR ( 1 , ""sent<S2SV_blank>%d<S2SV_blank>requested<S2SV_blank>%d"" , rc , remaining ) ; break ; } if ( rc == 0 ) { cERROR ( 1 , ""tcp<S2SV_blank>sent<S2SV_blank>no<S2SV_blank>data"" ) ; msleep ( 500 ) ; continue ; } remaining -= rc ; for ( i = first_vec ; i < n_vec ; i ++ ) { if ( iov [ i ] . iov_len ) { if ( rc > iov [ i ] . iov_len ) { rc -= iov [ i ] . iov_len ; iov [ i ] . iov_len = 0 ; } else { iov [ i ] . iov_base += rc ; iov [ i ] . iov_len -= rc ; first_vec = i ; break ; } } } i = 0 ; rc = 0 ; } return rc ; }
","<S2SV_ModStart> sent = 0 <S2SV_ModEnd> ; smb_msg .
"
578,"CWE-362 void snd_timer_interrupt ( struct snd_timer * timer , unsigned long ticks_left ) { struct snd_timer_instance * ti , * ts , * tmp ; unsigned long resolution , ticks ; struct list_head * p , * ack_list_head ; unsigned long flags ; int use_tasklet = 0 ; if ( timer == NULL ) return ; spin_lock_irqsave ( & timer -> lock , flags ) ; if ( timer -> hw . c_resolution ) resolution = timer -> hw . c_resolution ( timer ) ; else resolution = timer -> hw . resolution ; list_for_each_entry_safe ( ti , tmp , & timer -> active_list_head , active_list ) { if ( ! ( ti -> flags & SNDRV_TIMER_IFLG_RUNNING ) ) continue ; ti -> pticks += ticks_left ; ti -> resolution = resolution ; if ( ti -> cticks < ticks_left ) ti -> cticks = 0 ; else ti -> cticks -= ticks_left ; if ( ti -> cticks ) continue ; if ( ti -> flags & SNDRV_TIMER_IFLG_AUTO ) { ti -> cticks = ti -> ticks ; } else { ti -> flags &= ~ SNDRV_TIMER_IFLG_RUNNING ; if ( -- timer -> running ) <S2SV_StartBug> list_del ( & ti -> active_list ) ; <S2SV_EndBug> } if ( ( timer -> hw . flags & SNDRV_TIMER_HW_TASKLET ) || ( ti -> flags & SNDRV_TIMER_IFLG_FAST ) ) ack_list_head = & timer -> ack_list_head ; else ack_list_head = & timer -> sack_list_head ; if ( list_empty ( & ti -> ack_list ) ) list_add_tail ( & ti -> ack_list , ack_list_head ) ; list_for_each_entry ( ts , & ti -> slave_active_head , active_list ) { ts -> pticks = ti -> pticks ; ts -> resolution = resolution ; if ( list_empty ( & ts -> ack_list ) ) list_add_tail ( & ts -> ack_list , ack_list_head ) ; } } if ( timer -> flags & SNDRV_TIMER_FLG_RESCHED ) snd_timer_reschedule ( timer , timer -> sticks ) ; if ( timer -> running ) { if ( timer -> hw . flags & SNDRV_TIMER_HW_STOP ) { timer -> hw . stop ( timer ) ; timer -> flags |= SNDRV_TIMER_FLG_CHANGE ; } if ( ! ( timer -> hw . flags & SNDRV_TIMER_HW_AUTO ) || ( timer -> flags & SNDRV_TIMER_FLG_CHANGE ) ) { timer -> flags &= ~ SNDRV_TIMER_FLG_CHANGE ; timer -> hw . start ( timer ) ; } } else { timer -> hw . stop ( timer ) ; } while ( ! list_empty ( & timer -> ack_list_head ) ) { p = timer -> ack_list_head . next ; ti = list_entry ( p , struct snd_timer_instance , ack_list ) ; list_del_init ( p ) ; ticks = ti -> pticks ; ti -> pticks = 0 ; ti -> flags |= SNDRV_TIMER_IFLG_CALLBACK ; spin_unlock ( & timer -> lock ) ; if ( ti -> callback ) ti -> callback ( ti , resolution , ticks ) ; spin_lock ( & timer -> lock ) ; ti -> flags &= ~ SNDRV_TIMER_IFLG_CALLBACK ; } use_tasklet = ! list_empty ( & timer -> sack_list_head ) ; spin_unlock_irqrestore ( & timer -> lock , flags ) ; if ( use_tasklet ) tasklet_schedule ( & timer -> task_queue ) ; }
","<S2SV_ModStart> -> running ) list_del_init <S2SV_ModEnd> ( & ti
"
579,"CWE-89 static CURLcode pop3_parse_url_path ( struct connectdata * conn ) { struct pop3_conn * pop3c = & conn -> proto . pop3c ; struct SessionHandle * data = conn -> data ; const char * path = data -> state . path ; <S2SV_StartBug> pop3c -> mailbox = curl_easy_unescape ( data , path , 0 , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! pop3c -> mailbox ) <S2SV_EndBug> return CURLE_OUT_OF_MEMORY ; return CURLE_OK ; }
","<S2SV_ModStart> . path ; return Curl_urldecode <S2SV_ModEnd> ( data , <S2SV_ModStart> , 0 , & <S2SV_ModEnd> pop3c -> mailbox <S2SV_ModStart> pop3c -> mailbox , NULL , TRUE ) <S2SV_ModEnd> ; } <S2SV_null>
"
580,"CWE-20 static int kvm_vm_ioctl_create_vcpu ( struct kvm * kvm , u32 id ) { int r ; struct kvm_vcpu * vcpu , * v ; <S2SV_StartBug> vcpu = kvm_arch_vcpu_create ( kvm , id ) ; <S2SV_EndBug> if ( IS_ERR ( vcpu ) ) return PTR_ERR ( vcpu ) ; preempt_notifier_init ( & vcpu -> preempt_notifier , & kvm_preempt_ops ) ; r = kvm_arch_vcpu_setup ( vcpu ) ; if ( r ) goto vcpu_destroy ; mutex_lock ( & kvm -> lock ) ; if ( ! kvm_vcpu_compatible ( vcpu ) ) { r = - EINVAL ; goto unlock_vcpu_destroy ; } if ( atomic_read ( & kvm -> online_vcpus ) == KVM_MAX_VCPUS ) { r = - EINVAL ; goto unlock_vcpu_destroy ; } kvm_for_each_vcpu ( r , v , kvm ) if ( v -> vcpu_id == id ) { r = - EEXIST ; goto unlock_vcpu_destroy ; } BUG_ON ( kvm -> vcpus [ atomic_read ( & kvm -> online_vcpus ) ] ) ; kvm_get_kvm ( kvm ) ; r = create_vcpu_fd ( vcpu ) ; if ( r < 0 ) { kvm_put_kvm ( kvm ) ; goto unlock_vcpu_destroy ; } kvm -> vcpus [ atomic_read ( & kvm -> online_vcpus ) ] = vcpu ; smp_wmb ( ) ; atomic_inc ( & kvm -> online_vcpus ) ; mutex_unlock ( & kvm -> lock ) ; kvm_arch_vcpu_postcreate ( vcpu ) ; return r ; unlock_vcpu_destroy : mutex_unlock ( & kvm -> lock ) ; vcpu_destroy : kvm_arch_vcpu_destroy ( vcpu ) ; return r ; }
","<S2SV_ModStart> * v ; if ( id >= KVM_MAX_VCPUS ) return - EINVAL ;
"
581,"CWE-74 static int einj_error_inject ( u32 type , u32 flags , u64 param1 , u64 param2 , u64 param3 , u64 param4 ) { int rc ; <S2SV_StartBug> u64 base_addr , size ; <S2SV_EndBug> if ( flags && ( flags & ~ ( SETWA_FLAGS_APICID | SETWA_FLAGS_MEM | SETWA_FLAGS_PCIE_SBDF ) ) ) return - EINVAL ; if ( ! ( param_extension || acpi5 ) ) goto inject ; if ( type & ACPI5_VENDOR_BIT ) { if ( vendor_flags != SETWA_FLAGS_MEM ) goto inject ; } else if ( ! ( type & MEM_ERROR_MASK ) && ! ( flags & SETWA_FLAGS_MEM ) ) goto inject ; base_addr = param1 & param2 ; size = ~ param2 + 1 ; if ( ( ( param2 & PAGE_MASK ) != PAGE_MASK ) || ( ( region_intersects ( base_addr , size , IORESOURCE_SYSTEM_RAM , IORES_DESC_NONE ) != REGION_INTERSECTS ) && ( region_intersects ( base_addr , size , IORESOURCE_MEM , IORES_DESC_PERSISTENT_MEMORY ) != REGION_INTERSECTS ) ) ) return - EINVAL ; inject : mutex_lock ( & einj_mutex ) ; rc = __einj_error_inject ( type , flags , param1 , param2 , param3 , param4 ) ; mutex_unlock ( & einj_mutex ) ; return rc ; }
","<S2SV_ModStart> base_addr , size ; if ( get_securelevel ( ) > 0 ) return - EPERM
"
582,"CWE-125 const char * linkaddr_string ( netdissect_options * ndo , const u_char * ep , const unsigned int type , const unsigned int len ) { register u_int i ; register char * cp ; <S2SV_StartBug> register struct enamemem * tp ; <S2SV_EndBug> if ( len == 0 ) return ( ""<empty>"" ) ; if ( type == LINKADDR_ETHER && len == ETHER_ADDR_LEN ) return ( etheraddr_string ( ndo , ep ) ) ; if ( type == LINKADDR_FRELAY ) return ( q922_string ( ndo , ep , len ) ) ; tp = lookup_bytestring ( ndo , ep , len ) ; <S2SV_StartBug> if ( tp -> e_name ) <S2SV_EndBug> return ( tp -> e_name ) ; tp -> e_name = cp = ( char * ) malloc ( len * 3 ) ; <S2SV_StartBug> if ( tp -> e_name == NULL ) <S2SV_EndBug> ( * ndo -> ndo_error ) ( ndo , ""linkaddr_string:<S2SV_blank>malloc"" ) ; * cp ++ = hex [ * ep >> 4 ] ; * cp ++ = hex [ * ep ++ & 0xf ] ; for ( i = len - 1 ; i > 0 ; -- i ) { * cp ++ = ':' ; * cp ++ = hex [ * ep >> 4 ] ; * cp ++ = hex [ * ep ++ & 0xf ] ; } * cp = '\\0' ; <S2SV_StartBug> return ( tp -> e_name ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ; register struct bsnamemem <S2SV_ModEnd> * tp ; <S2SV_ModStart> ( tp -> bs_name ) return ( tp -> bs_name ) ; tp -> bs_name <S2SV_ModEnd> = cp = <S2SV_ModStart> ( tp -> bs_name <S2SV_ModEnd> == NULL ) <S2SV_ModStart> ( tp -> bs_name <S2SV_ModEnd> ) ; }
"
583,"CWE-119 static int tt_s2_4600_frontend_attach ( struct dvb_usb_adapter * adap ) { struct dvb_usb_device * d = adap -> dev ; <S2SV_StartBug> struct dw2102_state * state = d -> priv ; <S2SV_EndBug> u8 obuf [ 3 ] = { 0xe , 0x80 , 0 } ; u8 ibuf [ ] = { 0 } ; struct i2c_adapter * i2c_adapter ; struct i2c_client * client ; struct i2c_board_info board_info ; struct m88ds3103_platform_data m88ds3103_pdata = { } ; struct ts2020_config ts2020_config = { } ; <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ; <S2SV_StartBug> obuf [ 0 ] = 0xe ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = 0x02 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ; msleep ( 300 ) ; <S2SV_StartBug> obuf [ 0 ] = 0xe ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = 0x83 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ; <S2SV_StartBug> obuf [ 0 ] = 0xe ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = 0x83 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ; <S2SV_StartBug> obuf [ 0 ] = 0x51 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 1 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> err ( ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ; <S2SV_EndBug> m88ds3103_pdata . clk = 27000000 ; m88ds3103_pdata . i2c_wr_max = 33 ; m88ds3103_pdata . ts_mode = M88DS3103_TS_CI ; m88ds3103_pdata . ts_clk = 16000 ; m88ds3103_pdata . ts_clk_pol = 0 ; m88ds3103_pdata . spec_inv = 0 ; m88ds3103_pdata . agc = 0x99 ; m88ds3103_pdata . agc_inv = 0 ; m88ds3103_pdata . clk_out = M88DS3103_CLOCK_OUT_ENABLED ; m88ds3103_pdata . envelope_mode = 0 ; m88ds3103_pdata . lnb_hv_pol = 1 ; m88ds3103_pdata . lnb_en_pol = 0 ; memset ( & board_info , 0 , sizeof ( board_info ) ) ; strlcpy ( board_info . type , ""m88ds3103"" , I2C_NAME_SIZE ) ; board_info . addr = 0x68 ; board_info . platform_data = & m88ds3103_pdata ; request_module ( ""m88ds3103"" ) ; client = i2c_new_device ( & d -> i2c_adap , & board_info ) ; if ( client == NULL || client -> dev . driver == NULL ) return - ENODEV ; if ( ! try_module_get ( client -> dev . driver -> owner ) ) { i2c_unregister_device ( client ) ; return - ENODEV ; } adap -> fe_adap [ 0 ] . fe = m88ds3103_pdata . get_dvb_frontend ( client ) ; i2c_adapter = m88ds3103_pdata . get_i2c_adapter ( client ) ; state -> i2c_client_demod = client ; ts2020_config . fe = adap -> fe_adap [ 0 ] . fe ; memset ( & board_info , 0 , sizeof ( board_info ) ) ; strlcpy ( board_info . type , ""ts2022"" , I2C_NAME_SIZE ) ; board_info . addr = 0x60 ; board_info . platform_data = & ts2020_config ; request_module ( ""ts2020"" ) ; client = i2c_new_device ( i2c_adapter , & board_info ) ; if ( client == NULL || client -> dev . driver == NULL ) { dvb_frontend_detach ( adap -> fe_adap [ 0 ] . fe ) ; return - ENODEV ; } if ( ! try_module_get ( client -> dev . driver -> owner ) ) { i2c_unregister_device ( client ) ; dvb_frontend_detach ( adap -> fe_adap [ 0 ] . fe ) ; return - ENODEV ; } adap -> fe_adap [ 0 ] . fe -> ops . read_signal_strength = adap -> fe_adap [ 0 ] . fe -> ops . tuner_ops . get_rf_strength ; state -> i2c_client_tuner = client ; state -> fe_read_status = adap -> fe_adap [ 0 ] . fe -> ops . read_status ; adap -> fe_adap [ 0 ] . fe -> ops . read_status = tt_s2_4600_read_status ; state -> last_lock = 0 ; return 0 ; }
","<S2SV_ModStart> d -> priv <S2SV_ModEnd> ; struct i2c_adapter <S2SV_ModStart> { } ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x80 ; state -> data [ 2 ] = 0x0 ; <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0xe ; state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> = 0x02 ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> 300 ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0xe ; state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> = 0x83 ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0xe ; state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> = 0x83 ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> ( d , state -> data , 1 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> err ( ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ; mutex_unlock ( & d -> data_mutex
"
584,"CWE-20 static bool nested_vmx_exit_handled ( struct kvm_vcpu * vcpu ) { u32 intr_info = vmcs_read32 ( VM_EXIT_INTR_INFO ) ; struct vcpu_vmx * vmx = to_vmx ( vcpu ) ; struct vmcs12 * vmcs12 = get_vmcs12 ( vcpu ) ; u32 exit_reason = vmx -> exit_reason ; if ( vmx -> nested . nested_run_pending ) return 0 ; if ( unlikely ( vmx -> fail ) ) { pr_info_ratelimited ( ""%s<S2SV_blank>failed<S2SV_blank>vm<S2SV_blank>entry<S2SV_blank>%x\\n"" , __func__ , vmcs_read32 ( VM_INSTRUCTION_ERROR ) ) ; return 1 ; } switch ( exit_reason ) { case EXIT_REASON_EXCEPTION_NMI : if ( ! is_exception ( intr_info ) ) return 0 ; else if ( is_page_fault ( intr_info ) ) return enable_ept ; return vmcs12 -> exception_bitmap & ( 1u << ( intr_info & INTR_INFO_VECTOR_MASK ) ) ; case EXIT_REASON_EXTERNAL_INTERRUPT : return 0 ; case EXIT_REASON_TRIPLE_FAULT : return 1 ; case EXIT_REASON_PENDING_INTERRUPT : return nested_cpu_has ( vmcs12 , CPU_BASED_VIRTUAL_INTR_PENDING ) ; case EXIT_REASON_NMI_WINDOW : return nested_cpu_has ( vmcs12 , CPU_BASED_VIRTUAL_NMI_PENDING ) ; case EXIT_REASON_TASK_SWITCH : return 1 ; case EXIT_REASON_CPUID : return 1 ; case EXIT_REASON_HLT : return nested_cpu_has ( vmcs12 , CPU_BASED_HLT_EXITING ) ; case EXIT_REASON_INVD : return 1 ; case EXIT_REASON_INVLPG : return nested_cpu_has ( vmcs12 , CPU_BASED_INVLPG_EXITING ) ; case EXIT_REASON_RDPMC : return nested_cpu_has ( vmcs12 , CPU_BASED_RDPMC_EXITING ) ; case EXIT_REASON_RDTSC : return nested_cpu_has ( vmcs12 , CPU_BASED_RDTSC_EXITING ) ; case EXIT_REASON_VMCALL : case EXIT_REASON_VMCLEAR : case EXIT_REASON_VMLAUNCH : case EXIT_REASON_VMPTRLD : case EXIT_REASON_VMPTRST : case EXIT_REASON_VMREAD : case EXIT_REASON_VMRESUME : case EXIT_REASON_VMWRITE : case EXIT_REASON_VMOFF : case EXIT_REASON_VMON : <S2SV_StartBug> return 1 ; <S2SV_EndBug> case EXIT_REASON_CR_ACCESS : return nested_vmx_exit_handled_cr ( vcpu , vmcs12 ) ; case EXIT_REASON_DR_ACCESS : return nested_cpu_has ( vmcs12 , CPU_BASED_MOV_DR_EXITING ) ; case EXIT_REASON_IO_INSTRUCTION : return nested_vmx_exit_handled_io ( vcpu , vmcs12 ) ; case EXIT_REASON_MSR_READ : case EXIT_REASON_MSR_WRITE : return nested_vmx_exit_handled_msr ( vcpu , vmcs12 , exit_reason ) ; case EXIT_REASON_INVALID_STATE : return 1 ; case EXIT_REASON_MWAIT_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_MWAIT_EXITING ) ; case EXIT_REASON_MONITOR_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_MONITOR_EXITING ) ; case EXIT_REASON_PAUSE_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_PAUSE_EXITING ) || nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_PAUSE_LOOP_EXITING ) ; case EXIT_REASON_MCE_DURING_VMENTRY : return 0 ; case EXIT_REASON_TPR_BELOW_THRESHOLD : return 1 ; case EXIT_REASON_APIC_ACCESS : return nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES ) ; case EXIT_REASON_EPT_VIOLATION : case EXIT_REASON_EPT_MISCONFIG : return 0 ; case EXIT_REASON_PREEMPTION_TIMER : return vmcs12 -> pin_based_vm_exec_control & PIN_BASED_VMX_PREEMPTION_TIMER ; case EXIT_REASON_WBINVD : return nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_WBINVD_EXITING ) ; case EXIT_REASON_XSETBV : return 1 ; default : return 1 ; } }
","<S2SV_ModStart> case EXIT_REASON_VMON : case EXIT_REASON_INVEPT :
"
585,"CWE-000 static int em_ret ( struct x86_emulate_ctxt * ctxt ) { <S2SV_StartBug> ctxt -> dst . type = OP_REG ; <S2SV_EndBug> ctxt -> dst . addr . reg = & ctxt -> _eip ; <S2SV_StartBug> ctxt -> dst . bytes = ctxt -> op_bytes ; <S2SV_EndBug> return em_pop ( ctxt ) ; }
","<S2SV_ModStart> ctxt ) { int rc ; unsigned long eip ; rc = emulate_pop ( ctxt , & eip , <S2SV_ModEnd> ctxt -> op_bytes <S2SV_ModStart> ctxt -> op_bytes ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; return assign_eip_near ( ctxt , eip <S2SV_ModEnd> ) ; }
"
586,"CWE-20 void LineTo ( double x1 , double y1 ) { <S2SV_StartBug> outpos += <S2SV_EndBug> sprintf ( outpos , ""\\n<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>l"" , x1 , y1 ) ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> y1 ) { sprintf ( outputbuffer <S2SV_ModEnd> , ""\\n<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>l"" , <S2SV_ModStart> y1 ) ; sendClean ( outputbuffer ) ;
"
587,"CWE-119 u32 h264bsdInit ( storage_t * pStorage , u32 noOutputReordering ) { u32 size ; ASSERT ( pStorage ) ; h264bsdInitStorage ( pStorage ) ; size = ( sizeof ( macroblockLayer_t ) + 63 ) & ~ 0x3F ; <S2SV_StartBug> pStorage -> mbLayer = ( macroblockLayer_t * ) H264SwDecMalloc ( size ) ; <S2SV_EndBug> if ( ! pStorage -> mbLayer ) return HANTRO_NOK ; if ( noOutputReordering ) pStorage -> noReordering = HANTRO_TRUE ; return HANTRO_OK ; }
","<S2SV_ModStart> H264SwDecMalloc ( size , 1
"
588,"CWE-200 static void pipe_advance ( struct iov_iter * i , size_t size ) { struct pipe_inode_info * pipe = i -> pipe ; <S2SV_StartBug> struct pipe_buffer * buf ; <S2SV_EndBug> int idx = i -> idx ; size_t off = i -> iov_offset , orig_sz ; if ( unlikely ( i -> count < size ) ) size = i -> count ; <S2SV_StartBug> orig_sz = size ; <S2SV_EndBug> if ( size ) { <S2SV_StartBug> if ( off ) <S2SV_EndBug> <S2SV_StartBug> size += off - pipe -> bufs [ idx ] . offset ; <S2SV_EndBug> while ( 1 ) { buf = & pipe -> bufs [ idx ] ; <S2SV_StartBug> if ( size <= buf -> len ) <S2SV_EndBug> break ; <S2SV_StartBug> size -= buf -> len ; <S2SV_EndBug> idx = next_idx ( idx , pipe ) ; } <S2SV_StartBug> buf -> len = size ; <S2SV_EndBug> i -> idx = idx ; <S2SV_StartBug> off = i -> iov_offset = buf -> offset + size ; <S2SV_EndBug> } if ( off ) idx = next_idx ( idx , pipe ) ; if ( pipe -> nrbufs ) { int unused = ( pipe -> curbuf + pipe -> nrbufs ) & ( pipe -> buffers - 1 ) ; while ( idx != unused ) { pipe_buf_release ( pipe , & pipe -> bufs [ idx ] ) ; idx = next_idx ( idx , pipe ) ; pipe -> nrbufs -- ; } } <S2SV_StartBug> i -> count -= orig_sz ; <S2SV_EndBug> }
","<S2SV_ModStart> -> pipe ; <S2SV_ModEnd> if ( unlikely <S2SV_ModStart> -> count ; <S2SV_ModEnd> if ( size <S2SV_ModStart> size ) { struct pipe_buffer * buf ; size_t off = i -> iov_offset , left = size ; int idx = i -> idx ; <S2SV_ModStart> ( off ) left <S2SV_ModEnd> += off - <S2SV_ModStart> ; if ( left <S2SV_ModEnd> <= buf -> <S2SV_ModStart> ) break ; left <S2SV_ModEnd> -= buf -> <S2SV_ModStart> ) ; } <S2SV_ModEnd> i -> idx <S2SV_ModStart> = idx ; <S2SV_ModEnd> i -> iov_offset <S2SV_ModStart> -> offset + left ; <S2SV_ModEnd> } i -> <S2SV_ModStart> -> count -= size ; pipe_truncate ( i ) <S2SV_ModEnd> ; } <S2SV_null>
"
589,"CWE-125 u_int chdlc_print ( netdissect_options * ndo , register const u_char * p , u_int length ) { u_int proto ; const u_char * bp = p ; if ( length < CHDLC_HDRLEN ) goto trunc ; ND_TCHECK2 ( * p , CHDLC_HDRLEN ) ; proto = EXTRACT_16BITS ( & p [ 2 ] ) ; if ( ndo -> ndo_eflag ) { ND_PRINT ( ( ndo , ""%s,<S2SV_blank>ethertype<S2SV_blank>%s<S2SV_blank>(0x%04x),<S2SV_blank>length<S2SV_blank>%u:<S2SV_blank>"" , tok2str ( chdlc_cast_values , ""0x%02x"" , p [ 0 ] ) , tok2str ( ethertype_values , ""Unknown"" , proto ) , proto , length ) ) ; } length -= CHDLC_HDRLEN ; p += CHDLC_HDRLEN ; switch ( proto ) { case ETHERTYPE_IP : ip_print ( ndo , p , length ) ; break ; case ETHERTYPE_IPV6 : ip6_print ( ndo , p , length ) ; break ; case CHDLC_TYPE_SLARP : chdlc_slarp_print ( ndo , p , length ) ; break ; # if 0 case CHDLC_TYPE_CDP : chdlc_cdp_print ( p , length ) ; break ; # endif case ETHERTYPE_MPLS : case ETHERTYPE_MPLS_MULTI : mpls_print ( ndo , p , length ) ; break ; case ETHERTYPE_ISO : if ( length < 2 ) goto trunc ; ND_TCHECK_16BITS ( p ) ; if ( * ( p + 1 ) == 0x81 || * ( p + 1 ) == 0x82 || * ( p + 1 ) == 0x83 ) <S2SV_StartBug> isoclns_print ( ndo , p + 1 , length - 1 , ndo -> ndo_snapend - p - 1 ) ; <S2SV_EndBug> else <S2SV_StartBug> isoclns_print ( ndo , p , length , ndo -> ndo_snapend - p ) ; <S2SV_EndBug> break ; default : if ( ! ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""unknown<S2SV_blank>CHDLC<S2SV_blank>protocol<S2SV_blank>(0x%04x)"" , proto ) ) ; break ; } return ( CHDLC_HDRLEN ) ; trunc : ND_PRINT ( ( ndo , ""[|chdlc]"" ) ) ; return ndo -> ndo_snapend - bp ; }
","<S2SV_ModStart> length - 1 <S2SV_ModEnd> ) ; else <S2SV_ModStart> p , length <S2SV_ModEnd> ) ; break
"
590,"CWE-772 generic_ret * setkey_principal3_2_svc ( setkey3_arg * arg , struct svc_req * rqstp ) { static generic_ret ret ; char * prime_arg ; <S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_generic_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> princ , & prime_arg ) ) { ret . code = KADM5_BAD_PRINCIPAL ; goto exit_func ; } if ( ! ( CHANGEPW_SERVICE ( rqstp ) ) && kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_SETKEY , arg -> princ , NULL ) ) { ret . code = kadm5_setkey_principal_3 ( ( void * ) handle , arg -> princ , arg -> keepold , arg -> n_ks_tuple , arg -> ks_tuple , arg -> keyblocks , arg -> n_keys ) ; } else { log_unauth ( ""kadm5_setkey_principal"" , prime_arg , & client_name , & service_name , rqstp ) ; ret . code = KADM5_AUTH_SETKEY ; } if ( ret . code != KADM5_AUTH_SETKEY ) { if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( ""kadm5_setkey_principal"" , prime_arg , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } free ( prime_arg ) ; <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> gss_release_buffer ( & minor_stat , & service_name ) ; exit_func : free_server_handle ( handle ) ; return & ret ; }
","<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> prime_arg ) ; exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
"
591,"CWE-125 matvar_t * Mat_VarReadNextInfo4 ( mat_t * mat ) { int M , O , data_type , class_type ; mat_int32_t tmp ; long nBytes ; size_t readresult ; matvar_t * matvar = NULL ; union { mat_uint32_t u ; mat_uint8_t c [ 4 ] ; } endian ; if ( mat == NULL || mat -> fp == NULL ) return NULL ; else if ( NULL == ( matvar = Mat_VarCalloc ( ) ) ) return NULL ; readresult = fread ( & tmp , sizeof ( int ) , 1 , ( FILE * ) mat -> fp ) ; if ( 1 != readresult ) { Mat_VarFree ( matvar ) ; return NULL ; } endian . u = 0x01020304 ; if ( tmp < 0 || tmp > 4052 ) { if ( Mat_int32Swap ( & tmp ) > 4052 ) { Mat_VarFree ( matvar ) ; return NULL ; } } M = ( int ) floor ( tmp / 1000.0 ) ; switch ( M ) { case 0 : mat -> byteswap = endian . c [ 0 ] != 4 ; break ; case 1 : mat -> byteswap = endian . c [ 0 ] != 1 ; break ; default : Mat_VarFree ( matvar ) ; return NULL ; } tmp -= M * 1000 ; O = ( int ) floor ( tmp / 100.0 ) ; if ( 0 != O ) { Mat_VarFree ( matvar ) ; return NULL ; } tmp -= O * 100 ; data_type = ( int ) floor ( tmp / 10.0 ) ; switch ( data_type ) { case 0 : matvar -> data_type = MAT_T_DOUBLE ; break ; case 1 : matvar -> data_type = MAT_T_SINGLE ; break ; case 2 : matvar -> data_type = MAT_T_INT32 ; break ; case 3 : matvar -> data_type = MAT_T_INT16 ; break ; case 4 : matvar -> data_type = MAT_T_UINT16 ; break ; case 5 : matvar -> data_type = MAT_T_UINT8 ; break ; default : Mat_VarFree ( matvar ) ; return NULL ; } tmp -= data_type * 10 ; class_type = ( int ) floor ( tmp / 1.0 ) ; switch ( class_type ) { case 0 : matvar -> class_type = MAT_C_DOUBLE ; break ; case 1 : matvar -> class_type = MAT_C_CHAR ; break ; case 2 : matvar -> class_type = MAT_C_SPARSE ; break ; default : Mat_VarFree ( matvar ) ; return NULL ; } matvar -> rank = 2 ; matvar -> dims = ( size_t * ) calloc ( 2 , sizeof ( * matvar -> dims ) ) ; if ( NULL == matvar -> dims ) { Mat_VarFree ( matvar ) ; return NULL ; } readresult = fread ( & tmp , sizeof ( int ) , 1 , ( FILE * ) mat -> fp ) ; if ( mat -> byteswap ) Mat_int32Swap ( & tmp ) ; matvar -> dims [ 0 ] = tmp ; if ( 1 != readresult ) { Mat_VarFree ( matvar ) ; return NULL ; } readresult = fread ( & tmp , sizeof ( int ) , 1 , ( FILE * ) mat -> fp ) ; if ( mat -> byteswap ) Mat_int32Swap ( & tmp ) ; matvar -> dims [ 1 ] = tmp ; if ( 1 != readresult ) { Mat_VarFree ( matvar ) ; return NULL ; } readresult = fread ( & ( matvar -> isComplex ) , sizeof ( int ) , 1 , ( FILE * ) mat -> fp ) ; if ( 1 != readresult ) { Mat_VarFree ( matvar ) ; return NULL ; } if ( matvar -> isComplex && MAT_C_CHAR == matvar -> class_type ) { Mat_VarFree ( matvar ) ; return NULL ; } readresult = fread ( & tmp , sizeof ( int ) , 1 , ( FILE * ) mat -> fp ) ; if ( 1 != readresult ) { Mat_VarFree ( matvar ) ; return NULL ; } if ( mat -> byteswap ) Mat_int32Swap ( & tmp ) ; if ( tmp < 1 ) { Mat_VarFree ( matvar ) ; return NULL ; } matvar -> name = ( char * ) malloc ( tmp ) ; if ( NULL == matvar -> name ) { Mat_VarFree ( matvar ) ; return NULL ; } readresult = fread ( matvar -> name , 1 , tmp , ( FILE * ) mat -> fp ) ; if ( tmp != readresult ) { Mat_VarFree ( matvar ) ; return NULL ; <S2SV_StartBug> } <S2SV_EndBug> matvar -> internal -> datapos = ftell ( ( FILE * ) mat -> fp ) ; if ( matvar -> internal -> datapos == - 1L ) { Mat_VarFree ( matvar ) ; Mat_Critical ( ""Couldn\'t<S2SV_blank>determine<S2SV_blank>file<S2SV_blank>position"" ) ; return NULL ; } { int err ; size_t tmp2 = Mat_SizeOf ( matvar -> data_type ) ; if ( matvar -> isComplex ) tmp2 *= 2 ; err = SafeMulDims ( matvar , & tmp2 ) ; if ( err ) { Mat_VarFree ( matvar ) ; Mat_Critical ( ""Integer<S2SV_blank>multiplication<S2SV_blank>overflow"" ) ; return NULL ; } nBytes = ( long ) tmp2 ; } ( void ) fseek ( ( FILE * ) mat -> fp , nBytes , SEEK_CUR ) ; return matvar ; }
","<S2SV_ModStart> NULL ; } else { matvar -> name [ tmp - 1 ] = '\\0' ; }
"
592,"CWE-264 static int timer_start ( Unit * u ) { Timer * t = TIMER ( u ) ; TimerValue * v ; assert ( t ) ; assert ( t -> state == TIMER_DEAD || t -> state == TIMER_FAILED ) ; if ( UNIT_TRIGGER ( u ) -> load_state != UNIT_LOADED ) return - ENOENT ; t -> last_trigger = DUAL_TIMESTAMP_NULL ; LIST_FOREACH ( value , v , t -> values ) if ( v -> base == TIMER_ACTIVE ) v -> disabled = false ; if ( t -> stamp_path ) { struct stat st ; if ( stat ( t -> stamp_path , & st ) >= 0 ) t -> last_trigger . realtime = timespec_load ( & st . st_atim ) ; else if ( errno == ENOENT ) <S2SV_StartBug> touch_file ( t -> stamp_path , true , USEC_INFINITY , UID_INVALID , GID_INVALID , 0 ) ; <S2SV_EndBug> } t -> result = TIMER_SUCCESS ; timer_enter_waiting ( t , true ) ; return 1 ; }
","<S2SV_ModStart> , GID_INVALID , MODE_INVALID <S2SV_ModEnd> ) ; }
"
593,"CWE-362 static int snd_timer_user_tselect ( struct file * file , struct snd_timer_select __user * _tselect ) { struct snd_timer_user * tu ; struct snd_timer_select tselect ; char str [ 32 ] ; int err = 0 ; tu = file -> private_data ; <S2SV_StartBug> mutex_lock ( & tu -> tread_sem ) ; <S2SV_EndBug> if ( tu -> timeri ) { snd_timer_close ( tu -> timeri ) ; tu -> timeri = NULL ; } if ( copy_from_user ( & tselect , _tselect , sizeof ( tselect ) ) ) { err = - EFAULT ; goto __err ; } sprintf ( str , ""application<S2SV_blank>%i"" , current -> pid ) ; if ( tselect . id . dev_class != SNDRV_TIMER_CLASS_SLAVE ) tselect . id . dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION ; err = snd_timer_open ( & tu -> timeri , str , & tselect . id , current -> pid ) ; if ( err < 0 ) goto __err ; kfree ( tu -> queue ) ; tu -> queue = NULL ; kfree ( tu -> tqueue ) ; tu -> tqueue = NULL ; if ( tu -> tread ) { tu -> tqueue = kmalloc ( tu -> queue_size * sizeof ( struct snd_timer_tread ) , GFP_KERNEL ) ; if ( tu -> tqueue == NULL ) err = - ENOMEM ; } else { tu -> queue = kmalloc ( tu -> queue_size * sizeof ( struct snd_timer_read ) , GFP_KERNEL ) ; if ( tu -> queue == NULL ) err = - ENOMEM ; } if ( err < 0 ) { snd_timer_close ( tu -> timeri ) ; tu -> timeri = NULL ; } else { tu -> timeri -> flags |= SNDRV_TIMER_IFLG_FAST ; tu -> timeri -> callback = tu -> tread ? snd_timer_user_tinterrupt : snd_timer_user_interrupt ; tu -> timeri -> ccallback = snd_timer_user_ccallback ; tu -> timeri -> callback_data = ( void * ) tu ; } __err : <S2SV_StartBug> mutex_unlock ( & tu -> tread_sem ) ; <S2SV_EndBug> return err ; }
","<S2SV_ModStart> -> private_data ; <S2SV_ModEnd> if ( tu <S2SV_ModStart> } __err : <S2SV_ModEnd> return err ;
"
594,"CWE-74 PS_SERIALIZER_DECODE_FUNC ( php ) { const char * p , * q ; char * name ; const char * endptr = val + vallen ; zval * current ; int namelen ; int has_value ; php_unserialize_data_t var_hash ; <S2SV_StartBug> PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; <S2SV_EndBug> p = val ; while ( p < endptr ) { zval * * tmp ; <S2SV_StartBug> q = p ; <S2SV_EndBug> while ( * q != PS_DELIMITER ) { if ( ++ q >= endptr ) goto break_outer_loop ; } if ( p [ 0 ] == PS_UNDEF_MARKER ) { p ++ ; has_value = 0 ; } else { has_value = 1 ; } namelen = q - p ; name = estrndup ( p , namelen ) ; q ++ ; if ( zend_hash_find ( & EG ( symbol_table ) , name , namelen + 1 , ( void * * ) & tmp ) == SUCCESS ) { if ( ( Z_TYPE_PP ( tmp ) == IS_ARRAY && Z_ARRVAL_PP ( tmp ) == & EG ( symbol_table ) ) || * tmp == PS ( http_session_vars ) ) { <S2SV_StartBug> goto skip ; <S2SV_EndBug> } } if ( has_value ) { ALLOC_INIT_ZVAL ( current ) ; if ( php_var_unserialize ( & current , ( const unsigned char * * ) & q , ( const unsigned char * ) endptr , & var_hash TSRMLS_CC ) ) { <S2SV_StartBug> php_set_session_var ( name , namelen , current , & var_hash TSRMLS_CC ) ; <S2SV_EndBug> } else { var_push_dtor_no_addref ( & var_hash , & current ) ; efree ( name ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; return FAILURE ; } var_push_dtor_no_addref ( & var_hash , & current ) ; } <S2SV_StartBug> PS_ADD_VARL ( name , namelen ) ; <S2SV_EndBug> skip : efree ( name ) ; p = q ; } break_outer_loop : PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; return SUCCESS ; }
","<S2SV_ModStart> php_unserialize_data_t var_hash ; int skip = 0 ; <S2SV_ModStart> q = p ; skip = 0 <S2SV_ModStart> ) ) { skip = 1 <S2SV_ModEnd> ; } } <S2SV_ModStart> ) ) { if ( ! skip ) { <S2SV_ModStart> TSRMLS_CC ) ; } <S2SV_ModStart> ) ; } if ( ! skip ) { <S2SV_ModStart> namelen ) ; }
"
595,"CWE-125 static int bgp_attr_print ( netdissect_options * ndo , u_int atype , const u_char * pptr , u_int len ) { int i ; uint16_t af ; uint8_t safi , snpa , nhlen ; union { float f ; uint32_t i ; } bw ; int advance ; u_int tlen ; const u_char * tptr ; char buf [ MAXHOSTNAMELEN + 100 ] ; int as_size ; tptr = pptr ; tlen = len ; switch ( atype ) { case BGPTYPE_ORIGIN : if ( len != 1 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; else { ND_TCHECK ( * tptr ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_origin_values , ""Unknown<S2SV_blank>Origin<S2SV_blank>Typecode"" , tptr [ 0 ] ) ) ) ; } break ; case BGPTYPE_AS4_PATH : case BGPTYPE_AS_PATH : if ( len % 2 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } if ( ! len ) { ND_PRINT ( ( ndo , ""empty"" ) ) ; break ; } as_size = bgp_attr_get_as_size ( ndo , atype , pptr , len ) ; while ( tptr < pptr + len ) { ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_as_path_segment_open_values , <S2SV_StartBug> ""?"" , tptr [ 0 ] ) ) ) ; <S2SV_EndBug> for ( i = 0 ; i < tptr [ 1 ] * as_size ; i += as_size ) { ND_TCHECK2 ( tptr [ 2 + i ] , as_size ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank>"" , as_printf ( ndo , astostr , sizeof ( astostr ) , as_size == 2 ? EXTRACT_16BITS ( & tptr [ 2 + i ] ) : EXTRACT_32BITS ( & tptr [ 2 + i ] ) ) ) ) ; } ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_as_path_segment_close_values , ""?"" , tptr [ 0 ] ) ) ) ; ND_TCHECK ( tptr [ 1 ] ) ; tptr += 2 + tptr [ 1 ] * as_size ; } break ; case BGPTYPE_NEXT_HOP : if ( len != 4 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; else { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; } break ; case BGPTYPE_MULTI_EXIT_DISC : case BGPTYPE_LOCAL_PREF : if ( len != 4 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; else { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( tptr ) ) ) ; } break ; case BGPTYPE_ATOMIC_AGGREGATE : if ( len != 0 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; case BGPTYPE_AGGREGATOR : if ( len != 6 && len != 8 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , len ) ; if ( len == 6 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_16BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 2 ) ) ) ; } else { ND_PRINT ( ( ndo , ""<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; } break ; case BGPTYPE_AGGREGATOR4 : if ( len != 8 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGPTYPE_COMMUNITIES : if ( len % 4 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } while ( tlen > 0 ) { uint32_t comm ; ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; comm = EXTRACT_32BITS ( tptr ) ; switch ( comm ) { case BGP_COMMUNITY_NO_EXPORT : ND_PRINT ( ( ndo , ""<S2SV_blank>NO_EXPORT"" ) ) ; break ; case BGP_COMMUNITY_NO_ADVERT : ND_PRINT ( ( ndo , ""<S2SV_blank>NO_ADVERTISE"" ) ) ; break ; case BGP_COMMUNITY_NO_EXPORT_SUBCONFED : ND_PRINT ( ( ndo , ""<S2SV_blank>NO_EXPORT_SUBCONFED"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""%u:%u%s"" , ( comm >> 16 ) & 0xffff , comm & 0xffff , ( tlen > 4 ) ? "",<S2SV_blank>"" : """" ) ) ; break ; } tlen -= 4 ; tptr += 4 ; } break ; case BGPTYPE_ORIGINATOR_ID : if ( len != 4 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case BGPTYPE_CLUSTER_LIST : if ( len % 4 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } while ( tlen > 0 ) { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%s%s"" , ipaddr_string ( ndo , tptr ) , ( tlen > 4 ) ? "",<S2SV_blank>"" : """" ) ) ; tlen -= 4 ; tptr += 4 ; } break ; case BGPTYPE_MP_REACH_NLRI : ND_TCHECK2 ( tptr [ 0 ] , 3 ) ; af = EXTRACT_16BITS ( tptr ) ; safi = tptr [ 2 ] ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>AFI:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%sSAFI:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( af_values , ""Unknown<S2SV_blank>AFI"" , af ) , af , ( safi > 128 ) ? ""vendor<S2SV_blank>specific<S2SV_blank>"" : """" , tok2str ( bgp_safi_values , ""Unknown<S2SV_blank>SAFI"" , safi ) , safi ) ) ; switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : break ; default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; goto done ; break ; } tptr += 3 ; ND_TCHECK ( tptr [ 0 ] ) ; nhlen = tptr [ 0 ] ; tlen = nhlen ; tptr ++ ; if ( tlen ) { int nnh = 0 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>nexthop:<S2SV_blank>"" ) ) ; while ( tlen > 0 ) { if ( nnh ++ > 0 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>"" ) ) ; } switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; tlen -= sizeof ( struct in_addr ) ; tptr += sizeof ( struct in_addr ) ; } break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ; tlen -= ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; tptr += ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; } break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : if ( tlen < ( int ) sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ip6addr_string ( ndo , tptr ) ) ) ; tlen -= sizeof ( struct in6_addr ) ; tptr += sizeof ( struct in6_addr ) ; } break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ; tlen -= ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; tptr += ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; } break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; tlen -= ( sizeof ( struct in_addr ) ) ; tptr += ( sizeof ( struct in_addr ) ) ; } break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""%s"" , isonsap_string ( ndo , tptr , tlen ) ) ) ; tptr += tlen ; tlen = 0 ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < BGP_VPN_RD_LEN + 1 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , isonsap_string ( ndo , tptr + BGP_VPN_RD_LEN , tlen - BGP_VPN_RD_LEN ) ) ) ; if ( EXTRACT_32BITS ( tptr + BGP_VPN_RD_LEN ) == 0x47000601 ) ND_PRINT ( ( ndo , ""<S2SV_blank>=<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN + 4 ) ) ) ; else if ( EXTRACT_24BITS ( tptr + BGP_VPN_RD_LEN ) == 0x350000 ) ND_PRINT ( ( ndo , ""<S2SV_blank>=<S2SV_blank>%s"" , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN + 3 ) ) ) ; tptr += tlen ; tlen = 0 ; } break ; default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""no<S2SV_blank>AFI<S2SV_blank>%u/SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; tptr += tlen ; tlen = 0 ; goto done ; break ; } } } ND_PRINT ( ( ndo , "",<S2SV_blank>nh-length:<S2SV_blank>%u"" , nhlen ) ) ; tptr += tlen ; ND_TCHECK ( tptr [ 0 ] ) ; snpa = tptr [ 0 ] ; tptr ++ ; if ( snpa ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%u<S2SV_blank>SNPA"" , snpa ) ) ; for ( ; snpa > 0 ; snpa -- ) { ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d<S2SV_blank>bytes"" , tptr [ 0 ] ) ) ; tptr += tptr [ 0 ] + 1 ; } } else { ND_PRINT ( ( ndo , "",<S2SV_blank>no<S2SV_blank>SNPA"" ) ) ; } while ( len - ( tptr - pptr ) > 0 ) { switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : advance = decode_rt_routing_info ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; default : ND_TCHECK2 ( * tptr , tlen ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; advance = 0 ; tptr = pptr + len ; break ; } if ( advance < 0 ) break ; tptr += advance ; } done : break ; case BGPTYPE_MP_UNREACH_NLRI : ND_TCHECK2 ( tptr [ 0 ] , BGP_MP_NLRI_MINSIZE ) ; af = EXTRACT_16BITS ( tptr ) ; safi = tptr [ 2 ] ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>AFI:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%sSAFI:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( af_values , ""Unknown<S2SV_blank>AFI"" , af ) , af , ( safi > 128 ) ? ""vendor<S2SV_blank>specific<S2SV_blank>"" : """" , tok2str ( bgp_safi_values , ""Unknown<S2SV_blank>SAFI"" , safi ) , safi ) ) ; if ( len == BGP_MP_NLRI_MINSIZE ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>End-of-Rib<S2SV_blank>Marker<S2SV_blank>(empty<S2SV_blank>NLRI)"" ) ) ; tptr += 3 ; while ( len - ( tptr - pptr ) > 0 ) { switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; default : ND_TCHECK2 ( * ( tptr - 3 ) , tlen ) ; ND_PRINT ( ( ndo , ""no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr - 3 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; advance = 0 ; tptr = pptr + len ; break ; } if ( advance < 0 ) break ; tptr += advance ; } break ; case BGPTYPE_EXTD_COMMUNITIES : if ( len % 8 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } while ( tlen > 0 ) { uint16_t extd_comm ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; extd_comm = EXTRACT_16BITS ( tptr ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(0x%04x),<S2SV_blank>Flags<S2SV_blank>[%s]"" , tok2str ( bgp_extd_comm_subtype_values , ""unknown<S2SV_blank>extd<S2SV_blank>community<S2SV_blank>typecode"" , extd_comm ) , extd_comm , bittok2str ( bgp_extd_comm_flag_values , ""none"" , extd_comm ) ) ) ; ND_TCHECK2 ( * ( tptr + 2 ) , 6 ) ; switch ( extd_comm ) { case BGP_EXT_COM_RT_0 : case BGP_EXT_COM_RO_0 : case BGP_EXT_COM_L2VPN_RT_0 : ND_PRINT ( ( ndo , "":<S2SV_blank>%u:%u<S2SV_blank>(=<S2SV_blank>%s)"" , EXTRACT_16BITS ( tptr + 2 ) , EXTRACT_32BITS ( tptr + 4 ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_EXT_COM_RT_1 : case BGP_EXT_COM_RO_1 : case BGP_EXT_COM_L2VPN_RT_1 : case BGP_EXT_COM_VRF_RT_IMP : ND_PRINT ( ( ndo , "":<S2SV_blank>%s:%u"" , ipaddr_string ( ndo , tptr + 2 ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ; break ; case BGP_EXT_COM_RT_2 : case BGP_EXT_COM_RO_2 : ND_PRINT ( ( ndo , "":<S2SV_blank>%s:%u"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr + 2 ) ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ; break ; case BGP_EXT_COM_LINKBAND : bw . i = EXTRACT_32BITS ( tptr + 2 ) ; ND_PRINT ( ( ndo , "":<S2SV_blank>bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , bw . f * 8 / 1000000 ) ) ; break ; case BGP_EXT_COM_VPN_ORIGIN : case BGP_EXT_COM_VPN_ORIGIN2 : case BGP_EXT_COM_VPN_ORIGIN3 : case BGP_EXT_COM_VPN_ORIGIN4 : case BGP_EXT_COM_OSPF_RID : case BGP_EXT_COM_OSPF_RID2 : ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr + 2 ) ) ) ; break ; case BGP_EXT_COM_OSPF_RTYPE : case BGP_EXT_COM_OSPF_RTYPE2 : ND_PRINT ( ( ndo , "":<S2SV_blank>area:%s,<S2SV_blank>router-type:%s,<S2SV_blank>metric-type:%s%s"" , ipaddr_string ( ndo , tptr + 2 ) , tok2str ( bgp_extd_comm_ospf_rtype_values , ""unknown<S2SV_blank>(0x%02x)"" , * ( tptr + 6 ) ) , ( * ( tptr + 7 ) & BGP_OSPF_RTYPE_METRIC_TYPE ) ? ""E2"" : """" , ( ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_EXT ) || ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_NSSA ) ) ? ""E1"" : """" ) ) ; break ; case BGP_EXT_COM_L2INFO : ND_PRINT ( ( ndo , "":<S2SV_blank>%s<S2SV_blank>Control<S2SV_blank>Flags<S2SV_blank>[0x%02x]:MTU<S2SV_blank>%u"" , tok2str ( l2vpn_encaps_values , ""unknown<S2SV_blank>encaps"" , * ( tptr + 2 ) ) , * ( tptr + 3 ) , EXTRACT_16BITS ( tptr + 4 ) ) ) ; break ; case BGP_EXT_COM_SOURCE_AS : ND_PRINT ( ( ndo , "":<S2SV_blank>AS<S2SV_blank>%u"" , EXTRACT_16BITS ( tptr + 2 ) ) ) ; break ; default : ND_TCHECK2 ( * tptr , 8 ) ; print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , 8 ) ; break ; } tlen -= 8 ; tptr += 8 ; } break ; case BGPTYPE_PMSI_TUNNEL : { uint8_t tunnel_type , flags ; tunnel_type = * ( tptr + 1 ) ; flags = * tptr ; tlen = len ; ND_TCHECK2 ( tptr [ 0 ] , 5 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tunnel-type<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>MPLS<S2SV_blank>Label<S2SV_blank>%u"" , tok2str ( bgp_pmsi_tunnel_values , ""Unknown"" , tunnel_type ) , tunnel_type , bittok2str ( bgp_pmsi_flag_values , ""none"" , flags ) , EXTRACT_24BITS ( tptr + 2 ) >> 4 ) ) ; tptr += 5 ; tlen -= 5 ; switch ( tunnel_type ) { case BGP_PMSI_TUNNEL_PIM_SM : case BGP_PMSI_TUNNEL_PIM_BIDIR : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Sender<S2SV_blank>%s,<S2SV_blank>P-Group<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_PIM_SSM : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Root-Node<S2SV_blank>%s,<S2SV_blank>P-Group<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_INGRESS : ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tunnel-Endpoint<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case BGP_PMSI_TUNNEL_LDP_P2MP : case BGP_PMSI_TUNNEL_LDP_MP2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Root-Node<S2SV_blank>%s,<S2SV_blank>LSP-ID<S2SV_blank>0x%08x"" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_RSVP_P2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Extended-Tunnel-ID<S2SV_blank>%s,<S2SV_blank>P2MP-ID<S2SV_blank>0x%08x"" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr + 4 ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; } } break ; } case BGPTYPE_AIGP : { uint8_t type ; uint16_t length ; ND_TCHECK2 ( tptr [ 0 ] , 3 ) ; tlen = len ; while ( tlen >= 3 ) { type = * tptr ; length = EXTRACT_16BITS ( tptr + 1 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>TLV<S2SV_blank>(%u),<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( bgp_aigp_values , ""Unknown"" , type ) , type , length ) ) ; ND_TCHECK2 ( tptr [ 3 ] , length - 3 ) ; switch ( type ) { case BGP_AIGP_TLV : ND_TCHECK2 ( tptr [ 3 ] , 8 ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>metric<S2SV_blank>%"" PRIu64 , EXTRACT_64BITS ( tptr + 3 ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , tptr + 3 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , length - 3 ) ; } } tptr += length ; tlen -= length ; } break ; } case BGPTYPE_ATTR_SET : ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; if ( len < 4 ) goto trunc ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Origin<S2SV_blank>AS:<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) ) ) ; tptr += 4 ; len -= 4 ; while ( len ) { u_int aflags , alenlen , alen ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; if ( len < 2 ) goto trunc ; aflags = * tptr ; atype = * ( tptr + 1 ) ; tptr += 2 ; len -= 2 ; alenlen = bgp_attr_lenlen ( aflags , tptr ) ; ND_TCHECK2 ( tptr [ 0 ] , alenlen ) ; if ( len < alenlen ) goto trunc ; alen = bgp_attr_len ( aflags , tptr ) ; tptr += alenlen ; len -= alenlen ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( bgp_attr_values , ""Unknown<S2SV_blank>Attribute"" , atype ) , atype , alen ) ) ; if ( aflags ) { ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s%s%s%s"" , aflags & 0x80 ? ""O"" : """" , aflags & 0x40 ? ""T"" : """" , aflags & 0x20 ? ""P"" : """" , aflags & 0x10 ? ""E"" : """" ) ) ; if ( aflags & 0xf ) ND_PRINT ( ( ndo , ""+%x"" , aflags & 0xf ) ) ; ND_PRINT ( ( ndo , ""]:<S2SV_blank>"" ) ) ; } if ( ! bgp_attr_print ( ndo , atype , tptr , alen ) ) return 0 ; tptr += alen ; len -= alen ; } break ; case BGPTYPE_LARGE_COMMUNITY : if ( len == 0 || len % 12 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ) ) ; while ( len > 0 ) { ND_TCHECK2 ( * tptr , 12 ) ; ND_PRINT ( ( ndo , ""%u:%u:%u%s"" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) , ( len > 12 ) ? "",<S2SV_blank>"" : """" ) ) ; tptr += 12 ; len -= 12 ; } break ; default : ND_TCHECK2 ( * pptr , len ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>Attribute<S2SV_blank>%u<S2SV_blank>decoder"" , atype ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , pptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len ) ; break ; } if ( ndo -> ndo_vflag > 1 && len ) { ND_TCHECK2 ( * pptr , len ) ; print_unknown_data ( ndo , pptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len ) ; } return 1 ; trunc : return 0 ; }
","<S2SV_ModStart> ] ) ) ) ; ND_TCHECK ( tptr [ 1 ]
"
596,"CWE-125 static PyObject * parsenumber ( struct compiling * c , const char * s ) { char * dup , * end ; PyObject * res = NULL ; assert ( s != NULL ) ; if ( strchr ( s , '_' ) == NULL ) { return parsenumber_raw ( c , s ) ; } dup = PyMem_Malloc ( strlen ( s ) + 1 ) ; <S2SV_StartBug> end = dup ; <S2SV_EndBug> for ( ; * s ; s ++ ) { if ( * s != '_' ) { * end ++ = * s ; } } * end = '\\0' ; res = parsenumber_raw ( c , dup ) ; PyMem_Free ( dup ) ; return res ; }
","<S2SV_ModStart> 1 ) ; if ( dup == NULL ) { return PyErr_NoMemory ( ) ; }
"
597,"CWE-284 int socket_create ( uint16_t port ) { int sfd = - 1 ; int yes = 1 ; # ifdef WIN32 WSADATA wsa_data ; if ( ! wsa_init ) { if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsa_data ) != ERROR_SUCCESS ) { fprintf ( stderr , ""WSAStartup<S2SV_blank>failed!\\n"" ) ; ExitProcess ( - 1 ) ; } wsa_init = 1 ; } # endif struct sockaddr_in saddr ; if ( 0 > ( sfd = socket ( PF_INET , SOCK_STREAM , IPPROTO_TCP ) ) ) { perror ( ""socket()"" ) ; return - 1 ; } if ( setsockopt ( sfd , SOL_SOCKET , SO_REUSEADDR , ( void * ) & yes , sizeof ( int ) ) == - 1 ) { perror ( ""setsockopt()"" ) ; socket_close ( sfd ) ; return - 1 ; } # ifdef SO_NOSIGPIPE if ( setsockopt ( sfd , SOL_SOCKET , SO_NOSIGPIPE , ( void * ) & yes , sizeof ( int ) ) == - 1 ) { perror ( ""setsockopt()"" ) ; socket_close ( sfd ) ; return - 1 ; } # endif memset ( ( void * ) & saddr , 0 , sizeof ( saddr ) ) ; saddr . sin_family = AF_INET ; <S2SV_StartBug> saddr . sin_addr . s_addr = htonl ( INADDR_ANY ) ; <S2SV_EndBug> saddr . sin_port = htons ( port ) ; if ( 0 > bind ( sfd , ( struct sockaddr * ) & saddr , sizeof ( saddr ) ) ) { perror ( ""bind()"" ) ; socket_close ( sfd ) ; return - 1 ; } if ( listen ( sfd , 1 ) == - 1 ) { perror ( ""listen()"" ) ; socket_close ( sfd ) ; return - 1 ; } return sfd ; }
","<S2SV_ModStart> = htonl ( INADDR_LOOPBACK <S2SV_ModEnd> ) ; saddr
"
598,"CWE-125 static int decode_rt_routing_info ( netdissect_options * ndo , const u_char * pptr , char * buf , u_int buflen ) { uint8_t route_target [ 8 ] ; u_int plen ; <S2SV_StartBug> ND_TCHECK ( pptr [ 0 ] ) ; <S2SV_EndBug> plen = pptr [ 0 ] ; if ( 0 == plen ) { snprintf ( buf , buflen , ""default<S2SV_blank>route<S2SV_blank>target"" ) ; return 1 ; } if ( 32 > plen ) return - 1 ; <S2SV_StartBug> plen -= 32 ; <S2SV_EndBug> if ( 64 < plen ) return - 1 ; memset ( & route_target , 0 , sizeof ( route_target ) ) ; <S2SV_StartBug> ND_TCHECK2 ( pptr [ 1 ] , ( plen + 7 ) / 8 ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & route_target , & pptr [ 1 ] , ( plen + 7 ) / 8 ) ; <S2SV_EndBug> if ( plen % 8 ) { ( ( u_char * ) & route_target ) [ ( plen + 7 ) / 8 - 1 ] &= ( ( 0xff00 >> ( plen % 8 ) ) & 0xff ) ; } snprintf ( buf , buflen , ""origin<S2SV_blank>AS:<S2SV_blank>%s,<S2SV_blank>route<S2SV_blank>target<S2SV_blank>%s"" , <S2SV_StartBug> as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( pptr + 1 ) ) , <S2SV_EndBug> bgp_vpn_rd_print ( ndo , ( u_char * ) & route_target ) ) ; return 5 + ( plen + 7 ) / 8 ; trunc : return - 2 ; }
","<S2SV_ModStart> u_int plen ; char asbuf [ sizeof ( astostr ) ] ; <S2SV_ModStart> - 1 ; ND_TCHECK_32BITS ( pptr + 1 ) ; as_printf ( ndo , asbuf , sizeof ( asbuf ) , EXTRACT_32BITS ( pptr + 1 ) ) ; <S2SV_ModStart> ( pptr [ 5 <S2SV_ModEnd> ] , ( <S2SV_ModStart> & pptr [ 5 <S2SV_ModEnd> ] , ( <S2SV_ModStart> , ""origin<S2SV_blank>AS:<S2SV_blank>%s,<S2SV_blank>route<S2SV_blank>target<S2SV_blank>%s"" , asbuf <S2SV_ModEnd> , bgp_vpn_rd_print (
"
599,"CWE-264 static void ptrace_link ( struct task_struct * child , struct task_struct * new_parent ) { <S2SV_StartBug> rcu_read_lock ( ) ; <S2SV_EndBug> <S2SV_StartBug> __ptrace_link ( child , new_parent , __task_cred ( new_parent ) ) ; <S2SV_EndBug> rcu_read_unlock ( ) ; }
","<S2SV_ModStart> new_parent ) { <S2SV_ModEnd> __ptrace_link ( child <S2SV_ModStart> , new_parent , current_cred ( ) <S2SV_ModEnd> ) ; }
"
600,"CWE-264 static void timer_enter_running ( Timer * t ) { _cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL ; int r ; assert ( t ) ; if ( unit_stop_pending ( UNIT ( t ) ) ) return ; r = manager_add_job ( UNIT ( t ) -> manager , JOB_START , UNIT_TRIGGER ( UNIT ( t ) ) , JOB_REPLACE , true , & error , NULL ) ; if ( r < 0 ) goto fail ; dual_timestamp_get ( & t -> last_trigger ) ; if ( t -> stamp_path ) <S2SV_StartBug> touch_file ( t -> stamp_path , true , t -> last_trigger . realtime , UID_INVALID , GID_INVALID , 0 ) ; <S2SV_EndBug> timer_set_state ( t , TIMER_RUNNING ) ; return ; fail : log_unit_warning ( UNIT ( t ) , ""Failed<S2SV_blank>to<S2SV_blank>queue<S2SV_blank>unit<S2SV_blank>startup<S2SV_blank>job:<S2SV_blank>%s"" , bus_error_message ( & error , r ) ) ; timer_enter_dead ( t , TIMER_FAILURE_RESOURCES ) ; }
","<S2SV_ModStart> , GID_INVALID , MODE_INVALID <S2SV_ModEnd> ) ; timer_set_state
"
601,"CWE-264 static int persistent_prepare_exception ( struct dm_exception_store * store , struct dm_exception * e ) { <S2SV_StartBug> struct pstore * ps = get_info ( store ) ; <S2SV_EndBug> uint32_t stride ; chunk_t next_free ; sector_t size = get_dev_size ( dm_snap_cow ( store -> snap ) -> bdev ) ; if ( size < ( ( ps -> next_free + 1 ) * store -> chunk_size ) ) return - ENOSPC ; e -> new_chunk = ps -> next_free ; <S2SV_StartBug> stride = ( ps -> exceptions_per_area + 1 ) ; <S2SV_EndBug> next_free = ++ ps -> next_free ; if ( sector_div ( next_free , stride ) == 1 ) <S2SV_StartBug> ps -> next_free ++ ; <S2SV_EndBug> atomic_inc ( & ps -> pending_count ) ; return 0 ; }
","<S2SV_ModStart> ( store ) <S2SV_ModEnd> ; sector_t size <S2SV_ModStart> -> next_free ; <S2SV_ModEnd> ps -> next_free <S2SV_ModStart> -> next_free ++ ; skip_metadata ( ps )
"
602,"CWE-200 <S2SV_StartBug> static bool tailmatch ( const char * little , const char * bigone ) <S2SV_EndBug> { <S2SV_StartBug> size_t littlelen = strlen ( little ) ; <S2SV_EndBug> <S2SV_StartBug> size_t biglen = strlen ( bigone ) ; <S2SV_EndBug> <S2SV_StartBug> if ( littlelen > biglen ) <S2SV_EndBug> return FALSE ; <S2SV_StartBug> return Curl_raw_equal ( little , bigone + biglen - littlelen ) ? TRUE : FALSE ; <S2SV_EndBug> }
","<S2SV_ModStart> const char * cooke_domain <S2SV_ModEnd> , const char <S2SV_ModStart> const char * hostname <S2SV_ModEnd> ) { size_t <S2SV_ModStart> ) { size_t cookie_domain_len <S2SV_ModEnd> = strlen ( <S2SV_ModStart> = strlen ( cooke_domain <S2SV_ModEnd> ) ; size_t <S2SV_ModStart> ) ; size_t hostname_len <S2SV_ModEnd> = strlen ( <S2SV_ModStart> = strlen ( hostname <S2SV_ModEnd> ) ; if <S2SV_ModStart> ; if ( hostname_len < cookie_domain_len <S2SV_ModEnd> ) return FALSE <S2SV_ModStart> return FALSE ; if ( ! Curl_raw_equal ( cooke_domain , hostname + hostname_len - cookie_domain_len ) ) return FALSE ; if ( hostname_len == cookie_domain_len ) return TRUE ; if ( '.' == * ( hostname + hostname_len - cookie_domain_len - 1 ) ) return TRUE ; return <S2SV_ModEnd> FALSE ; }
"
603,"CWE-189 static int opl3_load_patch ( int dev , int format , const char __user * addr , <S2SV_StartBug> int offs , int count , int pmgr_flag ) <S2SV_EndBug> { struct sbi_instrument ins ; if ( count < sizeof ( ins ) ) { printk ( KERN_WARNING ""FM<S2SV_blank>Error:<S2SV_blank>Patch<S2SV_blank>record<S2SV_blank>too<S2SV_blank>short\\n"" ) ; return - EINVAL ; } <S2SV_StartBug> if ( copy_from_user ( & ( ( char * ) & ins ) [ offs ] , addr + offs , sizeof ( ins ) - offs ) ) <S2SV_EndBug> return - EFAULT ; if ( ins . channel < 0 || ins . channel >= SBFM_MAXINSTR ) { printk ( KERN_WARNING ""FM<S2SV_blank>Error:<S2SV_blank>Invalid<S2SV_blank>instrument<S2SV_blank>number<S2SV_blank>%d\\n"" , ins . channel ) ; return - EINVAL ; } ins . key = format ; return store_instr ( ins . channel , & ins ) ; }
","<S2SV_ModStart> * addr , <S2SV_ModEnd> int count , <S2SV_ModStart> copy_from_user ( & ins , addr <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> ( ins ) <S2SV_ModEnd> ) ) return
"
604,"CWE-120 static int pad_pkcs2 ( bn_t m , int * p_len , int m_len , int k_len , int operation ) { uint8_t pad , h1 [ RLC_MD_LEN ] , h2 [ RLC_MD_LEN ] ; uint8_t * mask = RLC_ALLOCA ( uint8_t , k_len ) ; <S2SV_StartBug> int result = RLC_OK ; <S2SV_EndBug> bn_t t ; bn_null ( t ) ; RLC_TRY { bn_new ( t ) ; switch ( operation ) { case RSA_ENC : md_map ( h1 , NULL , 0 ) ; bn_read_bin ( m , h1 , RLC_MD_LEN ) ; * p_len = k_len - 2 * RLC_MD_LEN - 2 - m_len ; bn_lsh ( m , m , * p_len * 8 ) ; bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , 0x01 ) ; bn_lsh ( m , m , m_len * 8 ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case RSA_ENC_FIN : rand_bytes ( h1 , RLC_MD_LEN ) ; md_mgf ( mask , k_len - RLC_MD_LEN - 1 , h1 , RLC_MD_LEN ) ; bn_read_bin ( t , mask , k_len - RLC_MD_LEN - 1 ) ; for ( int i = 0 ; i < t -> used ; i ++ ) { m -> dp [ i ] ^= t -> dp [ i ] ; } bn_write_bin ( mask , k_len - RLC_MD_LEN - 1 , m ) ; md_mgf ( h2 , RLC_MD_LEN , mask , k_len - RLC_MD_LEN - 1 ) ; for ( int i = 0 ; i < RLC_MD_LEN ; i ++ ) { h1 [ i ] ^= h2 [ i ] ; } bn_read_bin ( t , h1 , RLC_MD_LEN ) ; bn_lsh ( t , t , 8 * ( k_len - RLC_MD_LEN - 1 ) ) ; bn_add ( t , t , m ) ; bn_copy ( m , t ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case RSA_DEC : m_len = k_len - 1 ; bn_rsh ( t , m , 8 * m_len ) ; <S2SV_StartBug> if ( ! bn_is_zero ( t ) ) { <S2SV_EndBug> <S2SV_StartBug> result = RLC_ERR ; <S2SV_EndBug> } m_len -= RLC_MD_LEN ; bn_rsh ( t , m , 8 * m_len ) ; bn_write_bin ( h1 , RLC_MD_LEN , t ) ; bn_mod_2b ( m , m , 8 * m_len ) ; bn_write_bin ( mask , m_len , m ) ; md_mgf ( h2 , RLC_MD_LEN , mask , m_len ) ; for ( int i = 0 ; i < RLC_MD_LEN ; i ++ ) { h1 [ i ] ^= h2 [ i ] ; } md_mgf ( mask , k_len - RLC_MD_LEN - 1 , h1 , RLC_MD_LEN ) ; bn_read_bin ( t , mask , k_len - RLC_MD_LEN - 1 ) ; for ( int i = 0 ; i < t -> used ; i ++ ) { m -> dp [ i ] ^= t -> dp [ i ] ; } m_len -= RLC_MD_LEN ; bn_rsh ( t , m , 8 * m_len ) ; bn_write_bin ( h2 , RLC_MD_LEN , t ) ; md_map ( h1 , NULL , 0 ) ; pad = 0 ; for ( int i = 0 ; i < RLC_MD_LEN ; i ++ ) { <S2SV_StartBug> pad |= h1 [ i ] - h2 [ i ] ; <S2SV_EndBug> } <S2SV_StartBug> if ( result == RLC_OK ) { <S2SV_EndBug> result = ( pad ? RLC_ERR : RLC_OK ) ; } <S2SV_StartBug> bn_mod_2b ( m , m , 8 * m_len ) ; <S2SV_EndBug> * p_len = bn_size_bin ( m ) ; ( * p_len ) -- ; bn_rsh ( t , m , * p_len * 8 ) ; if ( bn_cmp_dig ( t , 1 ) != RLC_EQ ) { result = RLC_ERR ; } bn_mod_2b ( m , m , * p_len * 8 ) ; * p_len = k_len - * p_len ; break ; case RSA_SIG : case RSA_SIG_HASH : bn_zero ( m ) ; bn_lsh ( m , m , 64 ) ; bn_lsh ( m , m , RLC_MD_LEN * 8 ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case RSA_SIG_FIN : memset ( mask , 0 , 8 ) ; bn_write_bin ( mask + 8 , RLC_MD_LEN , m ) ; md_map ( h1 , mask , RLC_MD_LEN + 8 ) ; bn_read_bin ( m , h1 , RLC_MD_LEN ) ; md_mgf ( mask , k_len - RLC_MD_LEN - 1 , h1 , RLC_MD_LEN ) ; bn_read_bin ( t , mask , k_len - RLC_MD_LEN - 1 ) ; t -> dp [ 0 ] ^= 0x01 ; bn_lsh ( t , t , 8 * RLC_MD_LEN ) ; bn_add ( m , t , m ) ; bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PSS ) ; for ( int i = m_len - 1 ; i < 8 * k_len ; i ++ ) { bn_set_bit ( m , i , 0 ) ; } <S2SV_StartBug> break ; <S2SV_EndBug> case RSA_VER : case RSA_VER_HASH : bn_mod_2b ( t , m , 8 ) ; <S2SV_StartBug> if ( bn_cmp_dig ( t , RSA_PSS ) != RLC_EQ ) { <S2SV_EndBug> result = RLC_ERR ; } else { for ( int i = m_len ; i < 8 * k_len ; i ++ ) { if ( bn_get_bit ( m , i ) != 0 ) { result = RLC_ERR ; } } bn_rsh ( m , m , 8 ) ; bn_mod_2b ( t , m , 8 * RLC_MD_LEN ) ; bn_write_bin ( h2 , RLC_MD_LEN , t ) ; bn_rsh ( m , m , 8 * RLC_MD_LEN ) ; bn_write_bin ( h1 , RLC_MD_LEN , t ) ; md_mgf ( mask , k_len - RLC_MD_LEN - 1 , h1 , RLC_MD_LEN ) ; bn_read_bin ( t , mask , k_len - RLC_MD_LEN - 1 ) ; for ( int i = 0 ; i < t -> used ; i ++ ) { m -> dp [ i ] ^= t -> dp [ i ] ; } m -> dp [ 0 ] ^= 0x01 ; for ( int i = m_len - 1 ; i < 8 * k_len ; i ++ ) { bn_set_bit ( m , i - ( ( RLC_MD_LEN + 1 ) * 8 ) , 0 ) ; } <S2SV_StartBug> if ( ! bn_is_zero ( m ) ) { <S2SV_EndBug> <S2SV_StartBug> result = RLC_ERR ; <S2SV_EndBug> } bn_read_bin ( m , h2 , RLC_MD_LEN ) ; * p_len = k_len - RLC_MD_LEN ; } break ; } } RLC_CATCH_ANY { result = RLC_ERR ; } RLC_FINALLY { bn_free ( t ) ; } RLC_FREE ( mask ) ; return result ; }
","<S2SV_ModStart> int result = RLC_ERR <S2SV_ModEnd> ; bn_t t <S2SV_ModStart> 8 ) ; result = RLC_OK ; <S2SV_ModStart> t ) ; result = RLC_OK ; <S2SV_ModStart> ; if ( <S2SV_ModEnd> bn_is_zero ( t <S2SV_ModStart> ) ) { <S2SV_ModEnd> m_len -= RLC_MD_LEN <S2SV_ModStart> [ i ] ^ <S2SV_ModEnd> h2 [ i <S2SV_ModStart> ] ; } bn_mod_2b ( m , m , 8 * m_len ) ; * p_len = bn_size_bin ( m ) ; ( * p_len ) -- ; bn_rsh ( t , m , * p_len * 8 ) ; if ( pad == 0 && bn_cmp_dig ( t , 1 ) == RLC_EQ ) { result = RLC_OK <S2SV_ModEnd> ; } bn_mod_2b <S2SV_ModStart> , m , * p_len * 8 ) ; * p_len = k_len - * p_len ; } <S2SV_ModEnd> break ; case <S2SV_ModStart> 8 ) ; result = RLC_OK ; <S2SV_ModStart> ) ; } result = RLC_OK ; <S2SV_ModStart> 8 ) ; pad = ( uint8_t ) t -> dp [ 0 ] ; if ( pad == RSA_PSS ) { int r = 1 ; for ( int i = m_len ; i < 8 * k_len ; i ++ ) { if ( bn_get_bit ( m , i ) != 0 ) { r = 0 <S2SV_ModEnd> ; } } <S2SV_ModStart> } if ( r == 1 && <S2SV_ModEnd> bn_is_zero ( m <S2SV_ModStart> { result = RLC_OK <S2SV_ModEnd> ; } bn_read_bin
"
605,"CWE-125 void eap_print ( netdissect_options * ndo , register const u_char * cp , u_int length ) { const struct eap_frame_t * eap ; const u_char * tptr ; u_int tlen , type , subtype ; int count = 0 , len ; tptr = cp ; tlen = length ; eap = ( const struct eap_frame_t * ) cp ; ND_TCHECK ( * eap ) ; if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , ""%s<S2SV_blank>(%u)<S2SV_blank>v%u,<S2SV_blank>len<S2SV_blank>%u"" , tok2str ( eap_frame_type_values , ""unknown"" , eap -> type ) , eap -> type , eap -> version , EXTRACT_16BITS ( eap -> length ) ) ) ; return ; } ND_PRINT ( ( ndo , ""%s<S2SV_blank>(%u)<S2SV_blank>v%u,<S2SV_blank>len<S2SV_blank>%u"" , tok2str ( eap_frame_type_values , ""unknown"" , eap -> type ) , eap -> type , eap -> version , EXTRACT_16BITS ( eap -> length ) ) ) ; tptr += sizeof ( const struct eap_frame_t ) ; tlen -= sizeof ( const struct eap_frame_t ) ; switch ( eap -> type ) { case EAP_FRAME_TYPE_PACKET : <S2SV_StartBug> type = * ( tptr ) ; <S2SV_EndBug> len = EXTRACT_16BITS ( tptr + 2 ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>id<S2SV_blank>%u,<S2SV_blank>len<S2SV_blank>%u"" , tok2str ( eap_code_values , ""unknown"" , type ) , type , * ( tptr + 1 ) , len ) ) ; ND_TCHECK2 ( * tptr , len ) ; if ( type <= 2 ) { <S2SV_StartBug> subtype = * ( tptr + 4 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank>Type<S2SV_blank>%s<S2SV_blank>(%u)"" , <S2SV_StartBug> tok2str ( eap_type_values , ""unknown"" , * ( tptr + 4 ) ) , <S2SV_EndBug> * ( tptr + 4 ) ) ) ; switch ( subtype ) { case EAP_TYPE_IDENTITY : if ( len - 5 > 0 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>Identity:<S2SV_blank>"" ) ) ; safeputs ( ndo , tptr + 5 , len - 5 ) ; } break ; case EAP_TYPE_NOTIFICATION : if ( len - 5 > 0 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>Notification:<S2SV_blank>"" ) ) ; safeputs ( ndo , tptr + 5 , len - 5 ) ; } break ; case EAP_TYPE_NAK : count = 5 ; while ( count < len ) { <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>(%u),"" , <S2SV_EndBug> tok2str ( eap_type_values , ""unknown"" , * ( tptr + count ) ) , * ( tptr + count ) ) ) ; count ++ ; } break ; case EAP_TYPE_TTLS : <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>TTLSv%u"" , <S2SV_EndBug> EAP_TTLS_VERSION ( * ( tptr + 5 ) ) ) ) ; <S2SV_StartBug> case EAP_TYPE_TLS : <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>flags<S2SV_blank>[%s]<S2SV_blank>0x%02x,"" , bittok2str ( eap_tls_flags_values , ""none"" , * ( tptr + 5 ) ) , * ( tptr + 5 ) ) ) ; if ( EAP_TLS_EXTRACT_BIT_L ( * ( tptr + 5 ) ) ) { <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr + 6 ) ) ) ; <S2SV_EndBug> } break ; case EAP_TYPE_FAST : <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>FASTv%u"" , <S2SV_EndBug> EAP_TTLS_VERSION ( * ( tptr + 5 ) ) ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>flags<S2SV_blank>[%s]<S2SV_blank>0x%02x,"" , bittok2str ( eap_tls_flags_values , ""none"" , * ( tptr + 5 ) ) , * ( tptr + 5 ) ) ) ; if ( EAP_TLS_EXTRACT_BIT_L ( * ( tptr + 5 ) ) ) { <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr + 6 ) ) ) ; <S2SV_EndBug> } break ; case EAP_TYPE_AKA : case EAP_TYPE_SIM : <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>subtype<S2SV_blank>[%s]<S2SV_blank>0x%02x,"" , <S2SV_EndBug> tok2str ( eap_aka_subtype_values , ""unknown"" , * ( tptr + 5 ) ) , * ( tptr + 5 ) ) ) ; break ; case EAP_TYPE_MD5_CHALLENGE : case EAP_TYPE_OTP : case EAP_TYPE_GTC : case EAP_TYPE_EXPANDED_TYPES : case EAP_TYPE_EXPERIMENTAL : default : break ; } } break ; case EAP_FRAME_TYPE_LOGOFF : case EAP_FRAME_TYPE_ENCAP_ASF_ALERT : default : break ; } return ; trunc : ND_PRINT ( ( ndo , ""\\n\\t[|EAP]"" ) ) ; }
","<S2SV_ModStart> case EAP_FRAME_TYPE_PACKET : ND_TCHECK_8BITS ( tptr ) ; <S2SV_ModStart> * ( tptr ) ; ND_TCHECK_16BITS ( tptr + 2 <S2SV_ModStart> 2 ) { ND_TCHECK_8BITS ( tptr + 4 ) ; <S2SV_ModStart> , ""unknown"" , subtype ) , subtype <S2SV_ModEnd> ) ) ; <S2SV_ModStart> len ) { ND_TCHECK_8BITS ( tptr + count ) ; <S2SV_ModStart> case EAP_TYPE_TTLS : case EAP_TYPE_TLS : ND_TCHECK_8BITS ( tptr + 5 ) ; if ( subtype == EAP_TYPE_TTLS ) <S2SV_ModStart> ) ) ; <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> ) ) { ND_TCHECK_32BITS ( tptr + 6 ) ; <S2SV_ModStart> case EAP_TYPE_FAST : ND_TCHECK_8BITS ( tptr + 5 ) ; <S2SV_ModStart> ) ) { ND_TCHECK_32BITS ( tptr + 6 ) ; <S2SV_ModStart> case EAP_TYPE_SIM : ND_TCHECK_8BITS ( tptr + 5 ) ;
"
606,"CWE-20 static int nntp_fetch_headers ( struct Context * ctx , void * hc , anum_t first , anum_t last , int restore ) { struct NntpData * nntp_data = ctx -> data ; struct FetchCtx fc ; struct Header * hdr = NULL ; char buf [ HUGE_STRING ] ; int rc = 0 ; int oldmsgcount = ctx -> msgcount ; anum_t current ; anum_t first_over = first ; # ifdef USE_HCACHE void * hdata = NULL ; # endif if ( ! last || first > last ) return 0 ; fc . ctx = ctx ; fc . first = first ; fc . last = last ; fc . restore = restore ; <S2SV_StartBug> fc . messages = mutt_mem_calloc ( last - first + 1 , sizeof ( unsigned char ) ) ; <S2SV_EndBug> # ifdef USE_HCACHE fc . hc = hc ; # endif if ( NntpListgroup && nntp_data -> nserv -> hasLISTGROUP && ! nntp_data -> deleted ) { if ( ! ctx -> quiet ) mutt_message ( _ ( ""Fetching<S2SV_blank>list<S2SV_blank>of<S2SV_blank>articles..."" ) ) ; if ( nntp_data -> nserv -> hasLISTGROUPrange ) snprintf ( buf , sizeof ( buf ) , ""LISTGROUP<S2SV_blank>%s<S2SV_blank>%u-%u\\r\\n"" , nntp_data -> group , first , last ) ; else snprintf ( buf , sizeof ( buf ) , ""LISTGROUP<S2SV_blank>%s\\r\\n"" , nntp_data -> group ) ; rc = nntp_fetch_lines ( nntp_data , buf , sizeof ( buf ) , NULL , fetch_numbers , & fc ) ; if ( rc > 0 ) { mutt_error ( ""LISTGROUP:<S2SV_blank>%s"" , buf ) ; } if ( rc == 0 ) { for ( current = first ; current <= last && rc == 0 ; current ++ ) { if ( fc . messages [ current - first ] ) continue ; snprintf ( buf , sizeof ( buf ) , ""%u"" , current ) ; if ( nntp_data -> bcache ) { mutt_debug ( 2 , ""#1<S2SV_blank>mutt_bcache_del<S2SV_blank>%s\\n"" , buf ) ; mutt_bcache_del ( nntp_data -> bcache , buf ) ; } # ifdef USE_HCACHE if ( fc . hc ) { mutt_debug ( 2 , ""mutt_hcache_delete<S2SV_blank>%s\\n"" , buf ) ; mutt_hcache_delete ( fc . hc , buf , strlen ( buf ) ) ; } # endif } } } else { for ( current = first ; current <= last ; current ++ ) fc . messages [ current - first ] = 1 ; } if ( ! ctx -> quiet ) { mutt_progress_init ( & fc . progress , _ ( ""Fetching<S2SV_blank>message<S2SV_blank>headers..."" ) , MUTT_PROGRESS_MSG , ReadInc , last - first + 1 ) ; } for ( current = first ; current <= last && rc == 0 ; current ++ ) { if ( ! ctx -> quiet ) mutt_progress_update ( & fc . progress , current - first + 1 , - 1 ) ; # ifdef USE_HCACHE snprintf ( buf , sizeof ( buf ) , ""%u"" , current ) ; # endif if ( ! fc . messages [ current - first ] ) continue ; if ( ctx -> msgcount >= ctx -> hdrmax ) mx_alloc_memory ( ctx ) ; # ifdef USE_HCACHE hdata = mutt_hcache_fetch ( fc . hc , buf , strlen ( buf ) ) ; if ( hdata ) { mutt_debug ( 2 , ""mutt_hcache_fetch<S2SV_blank>%s\\n"" , buf ) ; ctx -> hdrs [ ctx -> msgcount ] = hdr = mutt_hcache_restore ( hdata ) ; mutt_hcache_free ( fc . hc , & hdata ) ; hdr -> data = 0 ; if ( hdr -> deleted && ! restore ) { mutt_header_free ( & hdr ) ; if ( nntp_data -> bcache ) { mutt_debug ( 2 , ""#2<S2SV_blank>mutt_bcache_del<S2SV_blank>%s\\n"" , buf ) ; mutt_bcache_del ( nntp_data -> bcache , buf ) ; } continue ; } hdr -> read = false ; hdr -> old = false ; } else # endif if ( nntp_data -> deleted ) continue ; else if ( nntp_data -> nserv -> hasOVER || nntp_data -> nserv -> hasXOVER ) { if ( NntpListgroup && nntp_data -> nserv -> hasLISTGROUP ) break ; else continue ; } else { FILE * fp = mutt_file_mkstemp ( ) ; if ( ! fp ) { mutt_perror ( ""mutt_file_mkstemp()<S2SV_blank>failed!"" ) ; rc = - 1 ; break ; } snprintf ( buf , sizeof ( buf ) , ""HEAD<S2SV_blank>%u\\r\\n"" , current ) ; rc = nntp_fetch_lines ( nntp_data , buf , sizeof ( buf ) , NULL , fetch_tempfile , fp ) ; if ( rc ) { mutt_file_fclose ( & fp ) ; if ( rc < 0 ) break ; if ( mutt_str_strncmp ( ""423"" , buf , 3 ) != 0 ) { mutt_error ( ""HEAD:<S2SV_blank>%s"" , buf ) ; break ; } if ( nntp_data -> bcache ) { snprintf ( buf , sizeof ( buf ) , ""%u"" , current ) ; mutt_debug ( 2 , ""#3<S2SV_blank>mutt_bcache_del<S2SV_blank>%s\\n"" , buf ) ; mutt_bcache_del ( nntp_data -> bcache , buf ) ; } rc = 0 ; continue ; } hdr = ctx -> hdrs [ ctx -> msgcount ] = mutt_header_new ( ) ; hdr -> env = mutt_rfc822_read_header ( fp , hdr , 0 , 0 ) ; hdr -> received = hdr -> date_sent ; mutt_file_fclose ( & fp ) ; } hdr -> index = ctx -> msgcount ++ ; hdr -> read = false ; hdr -> old = false ; hdr -> deleted = false ; hdr -> data = mutt_mem_calloc ( 1 , sizeof ( struct NntpHeaderData ) ) ; NHDR ( hdr ) -> article_num = current ; if ( restore ) hdr -> changed = true ; else { nntp_article_status ( ctx , hdr , NULL , NHDR ( hdr ) -> article_num ) ; if ( ! hdr -> read ) nntp_parse_xref ( ctx , hdr ) ; } if ( current > nntp_data -> last_loaded ) nntp_data -> last_loaded = current ; first_over = current + 1 ; } if ( ! NntpListgroup || ! nntp_data -> nserv -> hasLISTGROUP ) current = first_over ; if ( current <= last && rc == 0 && ! nntp_data -> deleted ) { char * cmd = nntp_data -> nserv -> hasOVER ? ""OVER"" : ""XOVER"" ; snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>%u-%u\\r\\n"" , cmd , current , last ) ; rc = nntp_fetch_lines ( nntp_data , buf , sizeof ( buf ) , NULL , parse_overview_line , & fc ) ; if ( rc > 0 ) { mutt_error ( ""%s:<S2SV_blank>%s"" , cmd , buf ) ; } } if ( ctx -> msgcount > oldmsgcount ) mx_update_context ( ctx , ctx -> msgcount - oldmsgcount ) ; FREE ( & fc . messages ) ; if ( rc != 0 ) return - 1 ; mutt_clear_error ( ) ; return 0 ; }
","<S2SV_ModStart> char ) ) ; if ( fc . messages == NULL ) return - 1
"
607,"CWE-119 <S2SV_StartBug> static void <S2SV_EndBug> swabHorAcc32 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { uint32 * wp = ( uint32 * ) cp0 ; tmsize_t wc = cc / 4 ; TIFFSwabArrayOfLong ( wp , wc ) ; <S2SV_StartBug> horAcc32 ( tif , cp0 , cc ) ; <S2SV_EndBug> }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> swabHorAcc32 ( TIFF <S2SV_ModStart> wc ) ; return
"
608,"CWE-416 static struct dst_entry * inet6_csk_route_socket ( struct sock * sk , struct flowi6 * fl6 ) { struct inet_sock * inet = inet_sk ( sk ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct in6_addr * final_p , final ; struct dst_entry * dst ; memset ( fl6 , 0 , sizeof ( * fl6 ) ) ; fl6 -> flowi6_proto = sk -> sk_protocol ; fl6 -> daddr = sk -> sk_v6_daddr ; fl6 -> saddr = np -> saddr ; fl6 -> flowlabel = np -> flow_label ; IP6_ECN_flow_xmit ( sk , fl6 -> flowlabel ) ; fl6 -> flowi6_oif = sk -> sk_bound_dev_if ; fl6 -> flowi6_mark = sk -> sk_mark ; fl6 -> fl6_sport = inet -> inet_sport ; fl6 -> fl6_dport = inet -> inet_dport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( fl6 ) ) ; <S2SV_StartBug> final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ; <S2SV_EndBug> <S2SV_StartBug> dst = __inet6_csk_dst_check ( sk , np -> dst_cookie ) ; <S2SV_EndBug> if ( ! dst ) { dst = ip6_dst_lookup_flow ( sk , fl6 , final_p ) ; if ( ! IS_ERR ( dst ) ) __inet6_csk_dst_store ( sk , dst , NULL , NULL ) ; } return dst ; }
","<S2SV_ModStart> ) ) ; rcu_read_lock ( ) ; <S2SV_ModStart> ( fl6 , rcu_dereference ( <S2SV_ModStart> np -> opt ) <S2SV_ModStart> final ) ; rcu_read_unlock ( ) ;
"
609,"CWE-125 void cfm_print ( netdissect_options * ndo , register const u_char * pptr , register u_int length ) { const struct cfm_common_header_t * cfm_common_header ; const struct cfm_tlv_header_t * cfm_tlv_header ; const uint8_t * tptr , * tlv_ptr ; const uint8_t * namesp ; u_int names_data_remaining ; uint8_t md_nameformat , md_namelength ; const uint8_t * md_name ; uint8_t ma_nameformat , ma_namelength ; const uint8_t * ma_name ; u_int hexdump , tlen , cfm_tlv_len , cfm_tlv_type , ccm_interval ; union { const struct cfm_ccm_t * cfm_ccm ; const struct cfm_lbm_t * cfm_lbm ; const struct cfm_ltm_t * cfm_ltm ; const struct cfm_ltr_t * cfm_ltr ; } msg_ptr ; tptr = pptr ; cfm_common_header = ( const struct cfm_common_header_t * ) pptr ; if ( length < sizeof ( * cfm_common_header ) ) goto tooshort ; ND_TCHECK ( * cfm_common_header ) ; if ( CFM_EXTRACT_VERSION ( cfm_common_header -> mdlevel_version ) != CFM_VERSION ) { ND_PRINT ( ( ndo , ""CFMv%u<S2SV_blank>not<S2SV_blank>supported,<S2SV_blank>length<S2SV_blank>%u"" , CFM_EXTRACT_VERSION ( cfm_common_header -> mdlevel_version ) , length ) ) ; return ; } ND_PRINT ( ( ndo , ""CFMv%u<S2SV_blank>%s,<S2SV_blank>MD<S2SV_blank>Level<S2SV_blank>%u,<S2SV_blank>length<S2SV_blank>%u"" , CFM_EXTRACT_VERSION ( cfm_common_header -> mdlevel_version ) , tok2str ( cfm_opcode_values , ""unknown<S2SV_blank>(%u)"" , cfm_common_header -> opcode ) , CFM_EXTRACT_MD_LEVEL ( cfm_common_header -> mdlevel_version ) , length ) ) ; if ( ndo -> ndo_vflag < 1 ) { return ; } ND_PRINT ( ( ndo , ""\\n\\tFirst<S2SV_blank>TLV<S2SV_blank>offset<S2SV_blank>%u"" , cfm_common_header -> first_tlv_offset ) ) ; tptr += sizeof ( const struct cfm_common_header_t ) ; tlen = length - sizeof ( struct cfm_common_header_t ) ; if ( cfm_common_header -> first_tlv_offset > tlen ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>large,<S2SV_blank>must<S2SV_blank>be<S2SV_blank><=<S2SV_blank>%u)"" , tlen ) ) ; return ; } switch ( cfm_common_header -> opcode ) { case CFM_OPCODE_CCM : msg_ptr . cfm_ccm = ( const struct cfm_ccm_t * ) tptr ; if ( cfm_common_header -> first_tlv_offset < sizeof ( * msg_ptr . cfm_ccm ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>small<S2SV_blank>1,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>%lu)"" , ( unsigned long ) sizeof ( * msg_ptr . cfm_ccm ) ) ) ; return ; } if ( tlen < sizeof ( * msg_ptr . cfm_ccm ) ) goto tooshort ; ND_TCHECK ( * msg_ptr . cfm_ccm ) ; ccm_interval = CFM_EXTRACT_CCM_INTERVAL ( cfm_common_header -> flags ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[CCM<S2SV_blank>Interval<S2SV_blank>%u%s]"" , ccm_interval , cfm_common_header -> flags & CFM_CCM_RDI_FLAG ? "",<S2SV_blank>RDI"" : """" ) ) ; if ( ccm_interval ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>CCM<S2SV_blank>Interval<S2SV_blank>%.3fs"" "",<S2SV_blank>min<S2SV_blank>CCM<S2SV_blank>Lifetime<S2SV_blank>%.3fs,<S2SV_blank>max<S2SV_blank>CCM<S2SV_blank>Lifetime<S2SV_blank>%.3fs"" , ccm_interval_base [ ccm_interval ] , ccm_interval_base [ ccm_interval ] * CCM_INTERVAL_MIN_MULTIPLIER , ccm_interval_base [ ccm_interval ] * CCM_INTERVAL_MAX_MULTIPLIER ) ) ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Sequence<S2SV_blank>Number<S2SV_blank>0x%08x,<S2SV_blank>MA-End-Point-ID<S2SV_blank>0x%04x"" , EXTRACT_32BITS ( msg_ptr . cfm_ccm -> sequence ) , EXTRACT_16BITS ( msg_ptr . cfm_ccm -> ma_epi ) ) ) ; namesp = msg_ptr . cfm_ccm -> names ; names_data_remaining = sizeof ( msg_ptr . cfm_ccm -> names ) ; md_nameformat = * namesp ; namesp ++ ; names_data_remaining -- ; if ( md_nameformat != CFM_CCM_MD_FORMAT_NONE ) { md_namelength = * namesp ; namesp ++ ; names_data_remaining -- ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>MD<S2SV_blank>Name<S2SV_blank>Format<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>MD<S2SV_blank>Name<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( cfm_md_nameformat_values , ""Unknown"" , md_nameformat ) , md_nameformat , md_namelength ) ) ; if ( md_namelength > names_data_remaining - 3 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>large,<S2SV_blank>must<S2SV_blank>be<S2SV_blank><=<S2SV_blank>%u)"" , names_data_remaining - 2 ) ) ; return ; } md_name = namesp ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>MD<S2SV_blank>Name:<S2SV_blank>"" ) ) ; switch ( md_nameformat ) { case CFM_CCM_MD_FORMAT_DNS : case CFM_CCM_MD_FORMAT_CHAR : safeputs ( ndo , md_name , md_namelength ) ; break ; case CFM_CCM_MD_FORMAT_MAC : if ( md_namelength == 6 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>MAC<S2SV_blank>%s"" , etheraddr_string ( ndo , md_name ) ) ) ; } else { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>MAC<S2SV_blank>(length<S2SV_blank>invalid)"" ) ) ; } break ; case CFM_CCM_MA_FORMAT_8021 : default : print_unknown_data ( ndo , md_name , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , md_namelength ) ; } namesp += md_namelength ; names_data_remaining -= md_namelength ; } else { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>MD<S2SV_blank>Name<S2SV_blank>Format<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( cfm_md_nameformat_values , ""Unknown"" , md_nameformat ) , md_nameformat ) ) ; } ma_nameformat = * namesp ; namesp ++ ; names_data_remaining -- ; ma_namelength = * namesp ; namesp ++ ; names_data_remaining -- ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>MA<S2SV_blank>Name-Format<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>MA<S2SV_blank>name<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( cfm_ma_nameformat_values , ""Unknown"" , ma_nameformat ) , ma_nameformat , ma_namelength ) ) ; if ( ma_namelength > names_data_remaining ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>large,<S2SV_blank>must<S2SV_blank>be<S2SV_blank><=<S2SV_blank>%u)"" , names_data_remaining ) ) ; return ; } ma_name = namesp ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>MA<S2SV_blank>Name:<S2SV_blank>"" ) ) ; switch ( ma_nameformat ) { case CFM_CCM_MA_FORMAT_CHAR : safeputs ( ndo , ma_name , ma_namelength ) ; break ; case CFM_CCM_MA_FORMAT_8021 : case CFM_CCM_MA_FORMAT_VID : case CFM_CCM_MA_FORMAT_INT : case CFM_CCM_MA_FORMAT_VPN : default : print_unknown_data ( ndo , ma_name , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , ma_namelength ) ; } break ; case CFM_OPCODE_LTM : msg_ptr . cfm_ltm = ( const struct cfm_ltm_t * ) tptr ; if ( cfm_common_header -> first_tlv_offset < sizeof ( * msg_ptr . cfm_ltm ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>small<S2SV_blank>4,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>%lu)"" , ( unsigned long ) sizeof ( * msg_ptr . cfm_ltm ) ) ) ; return ; } if ( tlen < sizeof ( * msg_ptr . cfm_ltm ) ) goto tooshort ; ND_TCHECK ( * msg_ptr . cfm_ltm ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s]"" , bittok2str ( cfm_ltm_flag_values , ""none"" , cfm_common_header -> flags ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Transaction-ID<S2SV_blank>0x%08x,<S2SV_blank>ttl<S2SV_blank>%u"" , EXTRACT_32BITS ( msg_ptr . cfm_ltm -> transaction_id ) , msg_ptr . cfm_ltm -> ttl ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Original-MAC<S2SV_blank>%s,<S2SV_blank>Target-MAC<S2SV_blank>%s"" , etheraddr_string ( ndo , msg_ptr . cfm_ltm -> original_mac ) , etheraddr_string ( ndo , msg_ptr . cfm_ltm -> target_mac ) ) ) ; break ; case CFM_OPCODE_LTR : msg_ptr . cfm_ltr = ( const struct cfm_ltr_t * ) tptr ; if ( cfm_common_header -> first_tlv_offset < sizeof ( * msg_ptr . cfm_ltr ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>small<S2SV_blank>5,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>%lu)"" , ( unsigned long ) sizeof ( * msg_ptr . cfm_ltr ) ) ) ; return ; } if ( tlen < sizeof ( * msg_ptr . cfm_ltr ) ) goto tooshort ; ND_TCHECK ( * msg_ptr . cfm_ltr ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s]"" , bittok2str ( cfm_ltr_flag_values , ""none"" , cfm_common_header -> flags ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Transaction-ID<S2SV_blank>0x%08x,<S2SV_blank>ttl<S2SV_blank>%u"" , EXTRACT_32BITS ( msg_ptr . cfm_ltr -> transaction_id ) , msg_ptr . cfm_ltr -> ttl ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Replay-Action<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( cfm_ltr_replay_action_values , ""Unknown"" , msg_ptr . cfm_ltr -> replay_action ) , msg_ptr . cfm_ltr -> replay_action ) ) ; break ; case CFM_OPCODE_LBR : case CFM_OPCODE_LBM : default : print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank>"" , tlen - cfm_common_header -> first_tlv_offset ) ; break ; } tptr += cfm_common_header -> first_tlv_offset ; tlen -= cfm_common_header -> first_tlv_offset ; while ( tlen > 0 ) { cfm_tlv_header = ( const struct cfm_tlv_header_t * ) tptr ; ND_TCHECK2 ( * tptr , 1 ) ; cfm_tlv_type = cfm_tlv_header -> type ; ND_PRINT ( ( ndo , ""\\n\\t%s<S2SV_blank>TLV<S2SV_blank>(0x%02x)"" , tok2str ( cfm_tlv_values , ""Unknown"" , cfm_tlv_type ) , cfm_tlv_type ) ) ; if ( cfm_tlv_type == CFM_TLV_END ) { return ; } if ( tlen < sizeof ( struct cfm_tlv_header_t ) ) goto tooshort ; ND_TCHECK2 ( * tptr , sizeof ( struct cfm_tlv_header_t ) ) ; cfm_tlv_len = EXTRACT_16BITS ( & cfm_tlv_header -> length ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>length<S2SV_blank>%u"" , cfm_tlv_len ) ) ; tptr += sizeof ( struct cfm_tlv_header_t ) ; tlen -= sizeof ( struct cfm_tlv_header_t ) ; tlv_ptr = tptr ; if ( tlen < cfm_tlv_len ) goto tooshort ; ND_TCHECK2 ( * tptr , cfm_tlv_len ) ; hexdump = FALSE ; switch ( cfm_tlv_type ) { case CFM_TLV_PORT_STATUS : if ( cfm_tlv_len < 1 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>1)"" ) ) ; return ; } ND_PRINT ( ( ndo , "",<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( cfm_tlv_port_status_values , ""Unknown"" , * tptr ) , * tptr ) ) ; break ; case CFM_TLV_INTERFACE_STATUS : if ( cfm_tlv_len < 1 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>1)"" ) ) ; return ; } ND_PRINT ( ( ndo , "",<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( cfm_tlv_interface_status_values , ""Unknown"" , * tptr ) , * tptr ) ) ; break ; case CFM_TLV_PRIVATE : if ( cfm_tlv_len < 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>4)"" ) ) ; return ; } ND_PRINT ( ( ndo , "",<S2SV_blank>Vendor:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Sub-Type<S2SV_blank>%u"" , tok2str ( oui_values , ""Unknown"" , EXTRACT_24BITS ( tptr ) ) , EXTRACT_24BITS ( tptr ) , * ( tptr + 3 ) ) ) ; hexdump = TRUE ; break ; case CFM_TLV_SENDER_ID : { u_int chassis_id_type , chassis_id_length ; u_int mgmt_addr_length ; if ( cfm_tlv_len < 1 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>1)"" ) ) ; <S2SV_StartBug> return ; <S2SV_EndBug> } chassis_id_length = * tptr ; tptr ++ ; tlen -- ; cfm_tlv_len -- ; if ( chassis_id_length ) { if ( cfm_tlv_len < 1 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>(TLV<S2SV_blank>too<S2SV_blank>short)"" ) ) ; <S2SV_StartBug> return ; <S2SV_EndBug> } chassis_id_type = * tptr ; cfm_tlv_len -- ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Chassis-ID<S2SV_blank>Type<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Chassis-ID<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( cfm_tlv_senderid_chassisid_values , ""Unknown"" , chassis_id_type ) , chassis_id_type , chassis_id_length ) ) ; if ( cfm_tlv_len < chassis_id_length ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>(TLV<S2SV_blank>too<S2SV_blank>short)"" ) ) ; <S2SV_StartBug> return ; <S2SV_EndBug> } switch ( chassis_id_type ) { <S2SV_StartBug> case CFM_CHASSIS_ID_MAC_ADDRESS : <S2SV_EndBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>MAC<S2SV_blank>%s"" , etheraddr_string ( ndo , tptr + 1 ) ) ) ; break ; case CFM_CHASSIS_ID_NETWORK_ADDRESS : <S2SV_StartBug> hexdump |= cfm_network_addr_print ( ndo , tptr ) ; <S2SV_EndBug> break ; case CFM_CHASSIS_ID_INTERFACE_NAME : case CFM_CHASSIS_ID_INTERFACE_ALIAS : case CFM_CHASSIS_ID_LOCAL : case CFM_CHASSIS_ID_CHASSIS_COMPONENT : case CFM_CHASSIS_ID_PORT_COMPONENT : safeputs ( ndo , tptr + 1 , chassis_id_length ) ; break ; default : hexdump = TRUE ; break ; } cfm_tlv_len -= chassis_id_length ; tptr += 1 + chassis_id_length ; tlen -= 1 + chassis_id_length ; } if ( cfm_tlv_len == 0 ) { <S2SV_StartBug> return ; <S2SV_EndBug> } mgmt_addr_length = * tptr ; tptr ++ ; tlen -- ; cfm_tlv_len -- ; <S2SV_StartBug> if ( mgmt_addr_length ) { <S2SV_EndBug> if ( cfm_tlv_len < mgmt_addr_length ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>(TLV<S2SV_blank>too<S2SV_blank>short)"" ) ) ; <S2SV_StartBug> return ; <S2SV_EndBug> } <S2SV_StartBug> cfm_tlv_len -= mgmt_addr_length ; <S2SV_EndBug> tptr += mgmt_addr_length ; tlen -= mgmt_addr_length ; if ( cfm_tlv_len < 1 ) { <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>(TLV<S2SV_blank>too<S2SV_blank>short)"" ) ) ; <S2SV_EndBug> return ; } mgmt_addr_length = * tptr ; tptr ++ ; tlen -- ; cfm_tlv_len -- ; <S2SV_StartBug> if ( mgmt_addr_length ) { <S2SV_EndBug> if ( cfm_tlv_len < mgmt_addr_length ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>(TLV<S2SV_blank>too<S2SV_blank>short)"" ) ) ; return ; } <S2SV_StartBug> cfm_tlv_len -= mgmt_addr_length ; <S2SV_EndBug> tptr += mgmt_addr_length ; tlen -= mgmt_addr_length ; } } break ; } case CFM_TLV_DATA : case CFM_TLV_REPLY_INGRESS : case CFM_TLV_REPLY_EGRESS : default : hexdump = TRUE ; break ; } if ( hexdump || ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , tlv_ptr , ""\\n\\t<S2SV_blank><S2SV_blank>"" , cfm_tlv_len ) ; <S2SV_StartBug> tptr += cfm_tlv_len ; <S2SV_EndBug> tlen -= cfm_tlv_len ; } return ; tooshort : ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank>packet<S2SV_blank>is<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; trunc : ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank>packet<S2SV_blank>exceeded<S2SV_blank>snapshot"" ) ) ; }
","<S2SV_ModStart> ) ) ; goto next_tlv <S2SV_ModEnd> ; } chassis_id_length <S2SV_ModStart> ) ) ; goto next_tlv <S2SV_ModEnd> ; } chassis_id_type <S2SV_ModStart> ) ) ; goto next_tlv <S2SV_ModEnd> ; } switch <S2SV_ModStart> case CFM_CHASSIS_ID_MAC_ADDRESS : if ( chassis_id_length != ETHER_ADDR_LEN ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(invalid<S2SV_blank>MAC<S2SV_blank>address<S2SV_blank>length)"" ) ) ; hexdump = TRUE ; break ; } <S2SV_ModStart> ndo , tptr + 1 , chassis_id_length <S2SV_ModStart> 0 ) { break <S2SV_ModEnd> ; } mgmt_addr_length <S2SV_ModStart> cfm_tlv_len -- ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Management<S2SV_blank>Address<S2SV_blank>Domain<S2SV_blank>Length<S2SV_blank>%u"" , mgmt_addr_length ) ) ; <S2SV_ModStart> ) ) ; goto next_tlv <S2SV_ModEnd> ; } cfm_tlv_len <S2SV_ModStart> cfm_tlv_len -= mgmt_addr_length ; hex_print ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Management<S2SV_blank>Address<S2SV_blank>Domain:<S2SV_blank>"" , tptr , mgmt_addr_length ) <S2SV_ModStart> ( ndo , ""<S2SV_blank>(Management<S2SV_blank>Address<S2SV_blank>Length<S2SV_blank>is<S2SV_blank>missing)"" ) ) ; hexdump = TRUE ; break <S2SV_ModEnd> ; } mgmt_addr_length <S2SV_ModStart> cfm_tlv_len -- ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Management<S2SV_blank>Address<S2SV_blank>Length<S2SV_blank>%u"" , mgmt_addr_length ) ) ; <S2SV_ModStart> cfm_tlv_len -= mgmt_addr_length ; hex_print ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Management<S2SV_blank>Address:<S2SV_blank>"" , tptr , mgmt_addr_length ) <S2SV_ModStart> cfm_tlv_len ) ; next_tlv :
"
610,"CWE-264 int hfsplus_rename_cat ( u32 cnid , struct inode * src_dir , struct qstr * src_name , struct inode * dst_dir , struct qstr * dst_name ) { struct super_block * sb = src_dir -> i_sb ; struct hfs_find_data src_fd , dst_fd ; hfsplus_cat_entry entry ; int entry_size , type ; int err ; dprint ( DBG_CAT_MOD , ""rename_cat:<S2SV_blank>%u<S2SV_blank>-<S2SV_blank>%lu,%s<S2SV_blank>-<S2SV_blank>%lu,%s\\n"" , cnid , src_dir -> i_ino , src_name -> name , dst_dir -> i_ino , dst_name -> name ) ; err = hfs_find_init ( HFSPLUS_SB ( sb ) -> cat_tree , & src_fd ) ; if ( err ) return err ; dst_fd = src_fd ; hfsplus_cat_build_key ( sb , src_fd . search_key , src_dir -> i_ino , src_name ) ; err = hfs_brec_find ( & src_fd ) ; if ( err ) goto out ; <S2SV_StartBug> hfs_bnode_read ( src_fd . bnode , & entry , src_fd . entryoffset , <S2SV_EndBug> src_fd . entrylength ) ; hfsplus_cat_build_key ( sb , dst_fd . search_key , dst_dir -> i_ino , dst_name ) ; err = hfs_brec_find ( & dst_fd ) ; if ( err != - ENOENT ) { if ( ! err ) err = - EEXIST ; goto out ; } err = hfs_brec_insert ( & dst_fd , & entry , src_fd . entrylength ) ; if ( err ) goto out ; dst_dir -> i_size ++ ; dst_dir -> i_mtime = dst_dir -> i_ctime = CURRENT_TIME_SEC ; hfsplus_cat_build_key ( sb , src_fd . search_key , src_dir -> i_ino , src_name ) ; err = hfs_brec_find ( & src_fd ) ; if ( err ) goto out ; err = hfs_brec_remove ( & src_fd ) ; if ( err ) goto out ; src_dir -> i_size -- ; src_dir -> i_mtime = src_dir -> i_ctime = CURRENT_TIME_SEC ; hfsplus_cat_build_key ( sb , src_fd . search_key , cnid , NULL ) ; err = hfs_brec_find ( & src_fd ) ; if ( err ) goto out ; type = hfs_bnode_read_u16 ( src_fd . bnode , src_fd . entryoffset ) ; err = hfs_brec_remove ( & src_fd ) ; if ( err ) goto out ; hfsplus_cat_build_key ( sb , dst_fd . search_key , cnid , NULL ) ; entry_size = hfsplus_fill_cat_thread ( sb , & entry , type , dst_dir -> i_ino , dst_name ) ; err = hfs_brec_find ( & dst_fd ) ; if ( err != - ENOENT ) { if ( ! err ) err = - EEXIST ; goto out ; } err = hfs_brec_insert ( & dst_fd , & entry , entry_size ) ; hfsplus_mark_inode_dirty ( dst_dir , HFSPLUS_I_CAT_DIRTY ) ; hfsplus_mark_inode_dirty ( src_dir , HFSPLUS_I_CAT_DIRTY ) ; out : hfs_bnode_put ( dst_fd . bnode ) ; hfs_find_exit ( & src_fd ) ; return err ; }
","<S2SV_ModStart> goto out ; if ( src_fd . entrylength > sizeof ( entry ) || src_fd . entrylength < 0 ) { err = - EIO ; goto out ; }
"
611,"CWE-476 file_transfer_t * imcb_file_send_start ( struct im_connection * ic , char * handle , char * file_name , size_t file_size ) { bee_t * bee = ic -> bee ; bee_user_t * bu = bee_user_by_handle ( bee , ic , handle ) ; <S2SV_StartBug> if ( bee -> ui -> ft_in_start ) { <S2SV_EndBug> return bee -> ui -> ft_in_start ( bee , bu , file_name , file_size ) ; } else { return NULL ; } }
","<S2SV_ModStart> ui -> ft_in_start && bu
"
612,"CWE-444 static ngx_int_t ngx_http_send_error_page ( ngx_http_request_t * r , ngx_http_err_page_t * err_page ) { ngx_int_t overwrite ; ngx_str_t uri , args ; ngx_table_elt_t * location ; ngx_http_core_loc_conf_t * clcf ; overwrite = err_page -> overwrite ; if ( overwrite && overwrite != NGX_HTTP_OK ) { r -> expect_tested = 1 ; } if ( overwrite >= 0 ) { r -> err_status = overwrite ; } if ( ngx_http_complex_value ( r , & err_page -> value , & uri ) != NGX_OK ) { return NGX_ERROR ; } if ( uri . len && uri . data [ 0 ] == '/' ) { if ( err_page -> value . lengths ) { ngx_http_split_args ( r , & uri , & args ) ; } else { args = err_page -> args ; } if ( r -> method != NGX_HTTP_HEAD ) { r -> method = NGX_HTTP_GET ; r -> method_name = ngx_http_core_get_method ; } return ngx_http_internal_redirect ( r , & uri , & args ) ; } if ( uri . len && uri . data [ 0 ] == '@' ) { return ngx_http_named_location ( r , & uri ) ; } <S2SV_StartBug> location = ngx_list_push ( & r -> headers_out . headers ) ; <S2SV_EndBug> if ( location == NULL ) { return NGX_ERROR ; } if ( overwrite != NGX_HTTP_MOVED_PERMANENTLY && overwrite != NGX_HTTP_MOVED_TEMPORARILY && overwrite != NGX_HTTP_SEE_OTHER && overwrite != NGX_HTTP_TEMPORARY_REDIRECT && overwrite != NGX_HTTP_PERMANENT_REDIRECT ) { r -> err_status = NGX_HTTP_MOVED_TEMPORARILY ; } location -> hash = 1 ; ngx_str_set ( & location -> key , ""Location"" ) ; location -> value = uri ; ngx_http_clear_location ( r ) ; r -> headers_out . location = location ; clcf = ngx_http_get_module_loc_conf ( r , ngx_http_core_module ) ; if ( clcf -> msie_refresh && r -> headers_in . msie ) { return ngx_http_send_refresh ( r ) ; } return ngx_http_send_special_response ( r , clcf , r -> err_status - NGX_HTTP_MOVED_PERMANENTLY + NGX_HTTP_OFF_3XX ) ; }
","<S2SV_ModStart> ) ; } r -> expect_tested = 1 ; if ( ngx_http_discard_request_body ( r ) != NGX_OK ) { r -> keepalive = 0 ; }
"
613,"CWE-189 static int32 makepol ( QPRS_STATE * state ) { int32 val = 0 , type ; int32 lenval = 0 ; char * strval = NULL ; int32 stack [ STACKDEPTH ] ; int32 lenstack = 0 ; uint16 flag = 0 ; <S2SV_StartBug> while ( ( type = gettoken_query ( state , & val , & lenval , & strval , & flag ) ) != END ) <S2SV_EndBug> { switch ( type ) { case VAL : pushval_asis ( state , VAL , strval , lenval , flag ) ; while ( lenstack && ( stack [ lenstack - 1 ] == ( int32 ) '&' || stack [ lenstack - 1 ] == ( int32 ) '!' ) ) { lenstack -- ; pushquery ( state , OPR , stack [ lenstack ] , 0 , 0 , 0 ) ; } break ; case OPR : if ( lenstack && val == ( int32 ) '|' ) pushquery ( state , OPR , val , 0 , 0 , 0 ) ; else { if ( lenstack == STACKDEPTH ) elog ( ERROR , ""stack<S2SV_blank>too<S2SV_blank>short"" ) ; stack [ lenstack ] = val ; lenstack ++ ; } break ; case OPEN : if ( makepol ( state ) == ERR ) return ERR ; while ( lenstack && ( stack [ lenstack - 1 ] == ( int32 ) '&' || stack [ lenstack - 1 ] == ( int32 ) '!' ) ) { lenstack -- ; pushquery ( state , OPR , stack [ lenstack ] , 0 , 0 , 0 ) ; } break ; case CLOSE : while ( lenstack ) { lenstack -- ; pushquery ( state , OPR , stack [ lenstack ] , 0 , 0 , 0 ) ; } ; return END ; break ; case ERR : default : ereport ( ERROR , ( errcode ( ERRCODE_SYNTAX_ERROR ) , errmsg ( ""syntax<S2SV_blank>error"" ) ) ) ; return ERR ; } } while ( lenstack ) { lenstack -- ; pushquery ( state , OPR , stack [ lenstack ] , 0 , 0 , 0 ) ; } ; return END ; }
","<S2SV_ModStart> = 0 ; check_stack_depth ( ) ;
"
614,"CWE-617 static int flv_write_packet ( AVFormatContext * s , AVPacket * pkt ) { AVIOContext * pb = s -> pb ; AVCodecParameters * par = s -> streams [ pkt -> stream_index ] -> codecpar ; FLVContext * flv = s -> priv_data ; FLVStreamContext * sc = s -> streams [ pkt -> stream_index ] -> priv_data ; unsigned ts ; int size = pkt -> size ; uint8_t * data = NULL ; int flags = - 1 , flags_size , ret ; <S2SV_StartBug> int64_t cur_offset = avio_tell ( pb ) ; <S2SV_EndBug> if ( par -> codec_id == AV_CODEC_ID_VP6F || par -> codec_id == AV_CODEC_ID_VP6A || par -> codec_id == AV_CODEC_ID_VP6 || par -> codec_id == AV_CODEC_ID_AAC ) flags_size = 2 ; else if ( par -> codec_id == AV_CODEC_ID_H264 || par -> codec_id == AV_CODEC_ID_MPEG4 ) flags_size = 5 ; else flags_size = 1 ; if ( par -> codec_id == AV_CODEC_ID_AAC || par -> codec_id == AV_CODEC_ID_H264 || par -> codec_id == AV_CODEC_ID_MPEG4 ) { int side_size = 0 ; uint8_t * side = av_packet_get_side_data ( pkt , AV_PKT_DATA_NEW_EXTRADATA , & side_size ) ; if ( side && side_size > 0 && ( side_size != par -> extradata_size || memcmp ( side , par -> extradata , side_size ) ) ) { av_free ( par -> extradata ) ; par -> extradata = av_mallocz ( side_size + AV_INPUT_BUFFER_PADDING_SIZE ) ; if ( ! par -> extradata ) { par -> extradata_size = 0 ; return AVERROR ( ENOMEM ) ; } memcpy ( par -> extradata , side , side_size ) ; par -> extradata_size = side_size ; flv_write_codec_header ( s , par , pkt -> dts ) ; } } if ( flv -> delay == AV_NOPTS_VALUE ) flv -> delay = - pkt -> dts ; if ( pkt -> dts < - flv -> delay ) { av_log ( s , AV_LOG_WARNING , ""Packets<S2SV_blank>are<S2SV_blank>not<S2SV_blank>in<S2SV_blank>the<S2SV_blank>proper<S2SV_blank>order<S2SV_blank>with<S2SV_blank>respect<S2SV_blank>to<S2SV_blank>DTS\\n"" ) ; return AVERROR ( EINVAL ) ; } ts = pkt -> dts ; if ( s -> event_flags & AVSTREAM_EVENT_FLAG_METADATA_UPDATED ) { write_metadata ( s , ts ) ; s -> event_flags &= ~ AVSTREAM_EVENT_FLAG_METADATA_UPDATED ; } avio_write_marker ( pb , av_rescale ( ts , AV_TIME_BASE , 1000 ) , pkt -> flags & AV_PKT_FLAG_KEY && ( flv -> video_par ? par -> codec_type == AVMEDIA_TYPE_VIDEO : 1 ) ? AVIO_DATA_MARKER_SYNC_POINT : AVIO_DATA_MARKER_BOUNDARY_POINT ) ; switch ( par -> codec_type ) { case AVMEDIA_TYPE_VIDEO : avio_w8 ( pb , FLV_TAG_TYPE_VIDEO ) ; flags = ff_codec_get_tag ( flv_video_codec_ids , par -> codec_id ) ; flags |= pkt -> flags & AV_PKT_FLAG_KEY ? FLV_FRAME_KEY : FLV_FRAME_INTER ; break ; case AVMEDIA_TYPE_AUDIO : flags = get_audio_flags ( s , par ) ; av_assert0 ( size ) ; avio_w8 ( pb , FLV_TAG_TYPE_AUDIO ) ; break ; case AVMEDIA_TYPE_SUBTITLE : case AVMEDIA_TYPE_DATA : avio_w8 ( pb , FLV_TAG_TYPE_META ) ; break ; default : return AVERROR ( EINVAL ) ; } if ( par -> codec_id == AV_CODEC_ID_H264 || par -> codec_id == AV_CODEC_ID_MPEG4 ) { if ( par -> extradata_size > 0 && * ( uint8_t * ) par -> extradata != 1 ) if ( ( ret = ff_avc_parse_nal_units_buf ( pkt -> data , & data , & size ) ) < 0 ) return ret ; } else if ( par -> codec_id == AV_CODEC_ID_AAC && pkt -> size > 2 && ( AV_RB16 ( pkt -> data ) & 0xfff0 ) == 0xfff0 ) { if ( ! s -> streams [ pkt -> stream_index ] -> nb_frames ) { av_log ( s , AV_LOG_ERROR , ""Malformed<S2SV_blank>AAC<S2SV_blank>bitstream<S2SV_blank>detected:<S2SV_blank>"" ""use<S2SV_blank>the<S2SV_blank>audio<S2SV_blank>bitstream<S2SV_blank>filter<S2SV_blank>\'aac_adtstoasc\'<S2SV_blank>to<S2SV_blank>fix<S2SV_blank>it<S2SV_blank>"" ""(\'-bsf:a<S2SV_blank>aac_adtstoasc\'<S2SV_blank>option<S2SV_blank>with<S2SV_blank>ffmpeg)\\n"" ) ; return AVERROR_INVALIDDATA ; } av_log ( s , AV_LOG_WARNING , ""aac<S2SV_blank>bitstream<S2SV_blank>error\\n"" ) ; } if ( par -> codec_id == AV_CODEC_ID_SPEEX && ts - sc -> last_ts > 160 ) av_log ( s , AV_LOG_WARNING , ""Warning:<S2SV_blank>Speex<S2SV_blank>stream<S2SV_blank>has<S2SV_blank>more<S2SV_blank>than<S2SV_blank>"" ""8<S2SV_blank>frames<S2SV_blank>per<S2SV_blank>packet.<S2SV_blank>Adobe<S2SV_blank>Flash<S2SV_blank>"" ""Player<S2SV_blank>cannot<S2SV_blank>handle<S2SV_blank>this!\\n"" ) ; if ( sc -> last_ts < ts ) sc -> last_ts = ts ; if ( size + flags_size >= 1 << 24 ) { av_log ( s , AV_LOG_ERROR , ""Too<S2SV_blank>large<S2SV_blank>packet<S2SV_blank>with<S2SV_blank>size<S2SV_blank>%u<S2SV_blank>>=<S2SV_blank>%u\\n"" , size + flags_size , 1 << 24 ) ; return AVERROR ( EINVAL ) ; } avio_wb24 ( pb , size + flags_size ) ; put_timestamp ( pb , ts ) ; avio_wb24 ( pb , flv -> reserved ) ; if ( par -> codec_type == AVMEDIA_TYPE_DATA || par -> codec_type == AVMEDIA_TYPE_SUBTITLE ) { int data_size ; int64_t metadata_size_pos = avio_tell ( pb ) ; if ( par -> codec_id == AV_CODEC_ID_TEXT ) { avio_w8 ( pb , AMF_DATA_TYPE_STRING ) ; put_amf_string ( pb , ""onTextData"" ) ; avio_w8 ( pb , AMF_DATA_TYPE_MIXEDARRAY ) ; avio_wb32 ( pb , 2 ) ; put_amf_string ( pb , ""type"" ) ; avio_w8 ( pb , AMF_DATA_TYPE_STRING ) ; put_amf_string ( pb , ""Text"" ) ; put_amf_string ( pb , ""text"" ) ; avio_w8 ( pb , AMF_DATA_TYPE_STRING ) ; put_amf_string ( pb , pkt -> data ) ; put_amf_string ( pb , """" ) ; avio_w8 ( pb , AMF_END_OF_OBJECT ) ; } else { avio_write ( pb , data ? data : pkt -> data , size ) ; } data_size = avio_tell ( pb ) - metadata_size_pos ; avio_seek ( pb , metadata_size_pos - 10 , SEEK_SET ) ; avio_wb24 ( pb , data_size ) ; avio_seek ( pb , data_size + 10 - 3 , SEEK_CUR ) ; avio_wb32 ( pb , data_size + 11 ) ; } else { av_assert1 ( flags >= 0 ) ; avio_w8 ( pb , flags ) ; if ( par -> codec_id == AV_CODEC_ID_VP6 ) avio_w8 ( pb , 0 ) ; if ( par -> codec_id == AV_CODEC_ID_VP6F || par -> codec_id == AV_CODEC_ID_VP6A ) { if ( par -> extradata_size ) avio_w8 ( pb , par -> extradata [ 0 ] ) ; else avio_w8 ( pb , ( ( FFALIGN ( par -> width , 16 ) - par -> width ) << 4 ) | ( FFALIGN ( par -> height , 16 ) - par -> height ) ) ; } else if ( par -> codec_id == AV_CODEC_ID_AAC ) avio_w8 ( pb , 1 ) ; else if ( par -> codec_id == AV_CODEC_ID_H264 || par -> codec_id == AV_CODEC_ID_MPEG4 ) { avio_w8 ( pb , 1 ) ; avio_wb24 ( pb , pkt -> pts - pkt -> dts ) ; } avio_write ( pb , data ? data : pkt -> data , size ) ; avio_wb32 ( pb , size + flags_size + 11 ) ; flv -> duration = FFMAX ( flv -> duration , pkt -> pts + flv -> delay + pkt -> duration ) ; } if ( flv -> flags & FLV_ADD_KEYFRAME_INDEX ) { switch ( par -> codec_type ) { case AVMEDIA_TYPE_VIDEO : flv -> videosize += ( avio_tell ( pb ) - cur_offset ) ; flv -> lasttimestamp = flv -> acurframeindex / flv -> framerate ; if ( pkt -> flags & AV_PKT_FLAG_KEY ) { double ts = flv -> acurframeindex / flv -> framerate ; int64_t pos = cur_offset ; flv -> lastkeyframetimestamp = flv -> acurframeindex / flv -> framerate ; flv -> lastkeyframelocation = pos ; flv_append_keyframe_info ( s , flv , ts , pos ) ; } flv -> acurframeindex ++ ; break ; case AVMEDIA_TYPE_AUDIO : flv -> audiosize += ( avio_tell ( pb ) - cur_offset ) ; break ; default : av_log ( s , AV_LOG_WARNING , ""par->codec_type<S2SV_blank>is<S2SV_blank>type<S2SV_blank>=<S2SV_blank>[%d]\\n"" , par -> codec_type ) ; break ; } } av_free ( data ) ; return pb -> error ; }
","<S2SV_ModStart> pb ) ; if ( par -> codec_type == AVMEDIA_TYPE_AUDIO && ! pkt -> size ) { av_log ( s , AV_LOG_WARNING , ""Empty<S2SV_blank>audio<S2SV_blank>Packet\\n"" ) ; return AVERROR ( EINVAL ) ; }
"
615,"CWE-125 struct _mdi * _WM_ParseNewMus ( uint8_t * mus_data , uint32_t mus_size ) { uint8_t mus_hdr [ ] = { 'M' , 'U' , 'S' , 0x1A } ; uint32_t mus_song_ofs = 0 ; uint32_t mus_song_len = 0 ; uint16_t mus_ch_cnt1 = 0 ; uint16_t mus_ch_cnt2 = 0 ; uint16_t mus_no_instr = 0 ; uint32_t mus_data_ofs = 0 ; uint16_t * mus_mid_instr = NULL ; uint16_t mus_instr_cnt = 0 ; struct _mdi * mus_mdi ; uint32_t mus_divisions = 60 ; float tempo_f = 0.0 ; uint16_t mus_freq = 0 ; float samples_per_tick_f = 0.0 ; <S2SV_StartBug> uint8_t mus_event [ ] = { 0 , 0 , 0 , 0 } ; <S2SV_EndBug> uint8_t mus_event_size = 0 ; uint8_t mus_prev_vol [ ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; uint32_t setup_ret = 0 ; uint32_t mus_ticks = 0 ; uint32_t sample_count = 0 ; float sample_count_f = 0.0 ; float sample_remainder = 0.0 ; uint16_t pitchbend_tmp = 0 ; if ( mus_size < 17 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_MUS , ""File<S2SV_blank>too<S2SV_blank>short"" , 0 ) ; return NULL ; } if ( memcmp ( mus_data , mus_hdr , 4 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_MUS , NULL , 0 ) ; return NULL ; } mus_song_len = ( mus_data [ 5 ] << 8 ) | mus_data [ 4 ] ; mus_song_ofs = ( mus_data [ 7 ] << 8 ) | mus_data [ 6 ] ; mus_ch_cnt1 = ( mus_data [ 9 ] << 8 ) | mus_data [ 8 ] ; mus_ch_cnt2 = ( mus_data [ 11 ] << 8 ) | mus_data [ 10 ] ; UNUSED ( mus_ch_cnt1 ) ; UNUSED ( mus_ch_cnt2 ) ; mus_no_instr = ( mus_data [ 13 ] << 8 ) | mus_data [ 12 ] ; mus_data_ofs = 16 ; if ( mus_size < ( mus_data_ofs + ( mus_no_instr << 1 ) + mus_song_len ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_MUS , ""File<S2SV_blank>too<S2SV_blank>short"" , 0 ) ; return NULL ; } mus_mid_instr = malloc ( mus_no_instr * sizeof ( uint16_t ) ) ; for ( mus_instr_cnt = 0 ; mus_instr_cnt < mus_no_instr ; mus_instr_cnt ++ ) { mus_mid_instr [ mus_instr_cnt ] = ( mus_data [ mus_data_ofs + 1 ] << 8 ) | mus_data [ mus_data_ofs ] ; mus_data_ofs += 2 ; } mus_data_ofs = mus_song_ofs ; mus_freq = _cvt_get_option ( WM_CO_FREQUENCY ) ; if ( mus_freq == 0 ) mus_freq = 140 ; if ( ( _WM_MixerOptions & WM_MO_ROUNDTEMPO ) ) { tempo_f = ( float ) ( 60000000 / mus_freq ) + 0.5f ; } else { tempo_f = ( float ) ( 60000000 / mus_freq ) ; } samples_per_tick_f = _WM_GetSamplesPerTick ( mus_divisions , ( uint32_t ) tempo_f ) ; mus_mdi = _WM_initMDI ( ) ; _WM_midi_setup_divisions ( mus_mdi , mus_divisions ) ; _WM_midi_setup_tempo ( mus_mdi , ( uint32_t ) tempo_f ) ; do { _mus_build_event : # if 1 MUS_EVENT_DEBUG ( ""Before"" , mus_data [ mus_data_ofs ] , 0 ) ; if ( ( mus_data [ mus_data_ofs ] & 0x0f ) == 0x0f ) { mus_data [ mus_data_ofs ] = ( mus_data [ mus_data_ofs ] & 0xf0 ) | 0x09 ; } else if ( ( mus_data [ mus_data_ofs ] & 0x0f ) == 0x09 ) { mus_data [ mus_data_ofs ] = ( mus_data [ mus_data_ofs ] & 0xf0 ) | 0x0f ; } MUS_EVENT_DEBUG ( ""After"" , mus_data [ mus_data_ofs ] , 0 ) ; # endif switch ( ( mus_data [ mus_data_ofs ] >> 4 ) & 0x07 ) { case 0 : mus_event_size = 2 ; mus_event [ 0 ] = 0x80 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = mus_data [ mus_data_ofs + 1 ] ; mus_event [ 2 ] = 0 ; mus_event [ 3 ] = 0 ; break ; case 1 : if ( mus_data [ mus_data_ofs + 1 ] & 0x80 ) { mus_event_size = 3 ; mus_event [ 0 ] = 0x90 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = mus_data [ mus_data_ofs + 1 ] & 0x7f ; mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; mus_event [ 3 ] = 0 ; mus_prev_vol [ mus_data [ mus_data_ofs ] & 0x0f ] = mus_event [ 2 ] ; } else { mus_event_size = 2 ; mus_event [ 0 ] = 0x90 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = mus_data [ mus_data_ofs + 1 ] ; mus_event [ 2 ] = mus_prev_vol [ mus_data [ mus_data_ofs ] & 0x0f ] ; mus_event [ 3 ] = 0 ; } break ; case 2 : mus_event_size = 2 ; mus_event [ 0 ] = 0xe0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; pitchbend_tmp = mus_data [ mus_data_ofs + 1 ] << 6 ; mus_event [ 1 ] = pitchbend_tmp & 0x7f ; mus_event [ 2 ] = ( pitchbend_tmp >> 7 ) & 0x7f ; mus_event [ 3 ] = 0 ; break ; case 3 : mus_event_size = 2 ; switch ( mus_data [ mus_data_ofs + 1 ] ) { case 10 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 120 ; mus_event [ 2 ] = 0 ; mus_event [ 3 ] = 0 ; break ; case 11 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 123 ; mus_event [ 2 ] = 0 ; mus_event [ 3 ] = 0 ; break ; case 12 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 126 ; mus_event [ 2 ] = 0 ; mus_event [ 3 ] = 0 ; break ; case 13 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 127 ; mus_event [ 2 ] = 0 ; mus_event [ 3 ] = 0 ; break ; case 14 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 121 ; mus_event [ 2 ] = 0 ; mus_event [ 3 ] = 0 ; break ; default : goto _mus_next_data ; } break ; case 4 : mus_event_size = 3 ; switch ( mus_data [ mus_data_ofs + 1 ] ) { case 0 : mus_event [ 0 ] = 0xc0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = mus_data [ mus_data_ofs + 2 ] ; mus_event [ 2 ] = 0 ; mus_event [ 3 ] = 0 ; break ; case 1 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 0 ; mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; mus_event [ 3 ] = 0 ; break ; case 2 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 1 ; mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; mus_event [ 3 ] = 0 ; break ; case 3 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 7 ; mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; mus_event [ 3 ] = 0 ; break ; case 4 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 10 ; mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; mus_event [ 3 ] = 0 ; break ; case 5 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 11 ; mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; mus_event [ 3 ] = 0 ; break ; case 6 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 91 ; mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; mus_event [ 3 ] = 0 ; break ; case 7 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 93 ; mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; mus_event [ 3 ] = 0 ; break ; case 8 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 64 ; mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; mus_event [ 3 ] = 0 ; break ; case 9 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 67 ; mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; mus_event [ 3 ] = 0 ; break ; default : goto _mus_next_data ; } break ; case 5 : mus_event_size = 1 ; goto _mus_next_data ; break ; case 6 : goto _mus_end_of_song ; break ; case 7 : mus_event_size = 1 ; goto _mus_next_data ; break ; } <S2SV_StartBug> setup_ret = _WM_SetupMidiEvent ( mus_mdi , ( uint8_t * ) mus_event , 0 ) ; <S2SV_EndBug> if ( setup_ret == 0 ) { goto _mus_end ; } _mus_next_data : if ( ! ( mus_data [ mus_data_ofs ] & 0x80 ) ) { mus_data_ofs += mus_event_size ; goto _mus_build_event ; } mus_data_ofs += mus_event_size ; mus_ticks = 0 ; do { mus_ticks = ( mus_ticks << 7 ) | ( mus_data [ mus_data_ofs ++ ] & 0x7f ) ; } while ( mus_data [ mus_data_ofs - 1 ] & 0x80 ) ; sample_count_f = ( ( float ) mus_ticks * samples_per_tick_f ) + sample_remainder ; sample_count = ( uint32_t ) sample_count_f ; sample_remainder = sample_count_f - ( float ) sample_count ; mus_mdi -> events [ mus_mdi -> event_count - 1 ] . samples_to_next = sample_count ; mus_mdi -> extra_info . approx_total_samples += sample_count ; } while ( mus_data_ofs < mus_size ) ; _mus_end_of_song : if ( ( mus_mdi -> reverb = _WM_init_reverb ( _WM_SampleRate , _WM_reverb_room_width , _WM_reverb_room_length , _WM_reverb_listen_posx , _WM_reverb_listen_posy ) ) == NULL ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_MEM , ""to<S2SV_blank>init<S2SV_blank>reverb"" , 0 ) ; goto _mus_end ; } _WM_midi_setup_endoftrack ( mus_mdi ) ; mus_mdi -> extra_info . current_sample = 0 ; mus_mdi -> current_event = & mus_mdi -> events [ 0 ] ; mus_mdi -> samples_to_mix = 0 ; mus_mdi -> note = NULL ; _WM_ResetToStart ( mus_mdi ) ; _mus_end : free ( mus_mid_instr ) ; if ( mus_mdi -> reverb ) return ( mus_mdi ) ; _WM_freeMDI ( mus_mdi ) ; return NULL ; }
","<S2SV_ModStart> = 0.0 ; # define MUS_SZ 4 <S2SV_ModStart> uint8_t mus_event [ MUS_SZ <S2SV_ModStart> * ) mus_event , MUS_SZ
"
616,"CWE-401 struct clock_source * dcn20_clock_source_create ( struct dc_context * ctx , struct dc_bios * bios , enum clock_source_id id , const struct dce110_clk_src_regs * regs , bool dp_clk_src ) { struct dce110_clk_src * clk_src = kzalloc ( sizeof ( struct dce110_clk_src ) , GFP_KERNEL ) ; if ( ! clk_src ) return NULL ; if ( dcn20_clk_src_construct ( clk_src , ctx , bios , id , regs , & cs_shift , & cs_mask ) ) { clk_src -> base . dp_clk_src = dp_clk_src ; return & clk_src -> base ; } <S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug> return NULL ; }
","<S2SV_ModStart> base ; } kfree ( clk_src ) ;
"
617,"CWE-125 void mpls_print ( netdissect_options * ndo , const u_char * bp , u_int length ) { const u_char * p ; uint32_t label_entry ; uint16_t label_stack_depth = 0 ; enum mpls_packet_type pt = PT_UNKNOWN ; p = bp ; ND_PRINT ( ( ndo , ""MPLS"" ) ) ; do { ND_TCHECK2 ( * p , sizeof ( label_entry ) ) ; if ( length < sizeof ( label_entry ) ) { ND_PRINT ( ( ndo , ""[|MPLS],<S2SV_blank>length<S2SV_blank>%u"" , length ) ) ; return ; } label_entry = EXTRACT_32BITS ( p ) ; ND_PRINT ( ( ndo , ""%s(label<S2SV_blank>%u"" , ( label_stack_depth && ndo -> ndo_vflag ) ? ""\\n\\t"" : ""<S2SV_blank>"" , MPLS_LABEL ( label_entry ) ) ) ; label_stack_depth ++ ; if ( ndo -> ndo_vflag && MPLS_LABEL ( label_entry ) < sizeof ( mpls_labelname ) / sizeof ( mpls_labelname [ 0 ] ) ) ND_PRINT ( ( ndo , ""<S2SV_blank>(%s)"" , mpls_labelname [ MPLS_LABEL ( label_entry ) ] ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>exp<S2SV_blank>%u"" , MPLS_EXP ( label_entry ) ) ) ; if ( MPLS_STACK ( label_entry ) ) ND_PRINT ( ( ndo , "",<S2SV_blank>[S]"" ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>ttl<S2SV_blank>%u)"" , MPLS_TTL ( label_entry ) ) ) ; p += sizeof ( label_entry ) ; length -= sizeof ( label_entry ) ; } while ( ! MPLS_STACK ( label_entry ) ) ; switch ( MPLS_LABEL ( label_entry ) ) { case 0 : case 3 : pt = PT_IPV4 ; break ; case 2 : pt = PT_IPV6 ; break ; default : ND_TCHECK ( * p ) ; if ( length < 1 ) { return ; } switch ( * p ) { case 0x45 : case 0x46 : case 0x47 : case 0x48 : case 0x49 : case 0x4a : case 0x4b : case 0x4c : case 0x4d : case 0x4e : case 0x4f : pt = PT_IPV4 ; break ; case 0x60 : case 0x61 : case 0x62 : case 0x63 : case 0x64 : case 0x65 : case 0x66 : case 0x67 : case 0x68 : case 0x69 : case 0x6a : case 0x6b : case 0x6c : case 0x6d : case 0x6e : case 0x6f : pt = PT_IPV6 ; break ; case 0x81 : case 0x82 : case 0x83 : pt = PT_OSI ; break ; default : break ; } } if ( pt == PT_UNKNOWN ) { if ( ! ndo -> ndo_suppress_default_print ) ND_DEFAULTPRINT ( p , length ) ; return ; } ND_PRINT ( ( ndo , ndo -> ndo_vflag ? ""\\n\\t"" : ""<S2SV_blank>"" ) ) ; switch ( pt ) { case PT_IPV4 : ip_print ( ndo , p , length ) ; break ; case PT_IPV6 : ip6_print ( ndo , p , length ) ; break ; case PT_OSI : <S2SV_StartBug> isoclns_print ( ndo , p , length , length ) ; <S2SV_EndBug> break ; default : break ; } return ; trunc : ND_PRINT ( ( ndo , ""[|MPLS]"" ) ) ; }
","<S2SV_ModStart> p , length <S2SV_ModEnd> ) ; break
"
618,"CWE-787 rfbBool webSocketsHasDataInBuffer ( rfbClientPtr cl ) { ws_ctx_t * wsctx = ( ws_ctx_t * ) cl -> wsctx ; <S2SV_StartBug> if ( wsctx && wsctx -> readbuflen ) <S2SV_EndBug> return TRUE ; return ( cl -> sslctx && rfbssl_pending ( cl ) > 0 ) ; }
","<S2SV_ModStart> && wsctx -> readlen <S2SV_ModEnd> ) return TRUE
"
619,"CWE-189 static void findoprnd ( ITEM * ptr , int32 * pos ) <S2SV_StartBug> { <S2SV_EndBug> if ( ptr [ * pos ] . type == VAL || ptr [ * pos ] . type == VALTRUE ) { ptr [ * pos ] . left = 0 ; ( * pos ) ++ ; } else if ( ptr [ * pos ] . val == ( int32 ) '!' ) { ptr [ * pos ] . left = 1 ; ( * pos ) ++ ; findoprnd ( ptr , pos ) ; } else { ITEM * curitem = & ptr [ * pos ] ; int32 tmp = * pos ; ( * pos ) ++ ; findoprnd ( ptr , pos ) ; curitem -> left = * pos - tmp ; findoprnd ( ptr , pos ) ; } }
","<S2SV_ModStart> pos ) { check_stack_depth ( ) ;
"
620,"CWE-476 GF_Err HintFile ( GF_ISOFile * file , u32 MTUSize , u32 max_ptime , u32 rtp_rate , u32 base_flags , Bool copy_data , Bool interleave , Bool regular_iod , Bool single_group , Bool hint_no_offset ) { GF_ESD * esd ; GF_InitialObjectDescriptor * iod ; u32 i , val , res , streamType ; u32 sl_mode , prev_ocr , single_ocr , nb_done , tot_bw , bw , flags , spec_type ; GF_Err e ; char szPayload [ 30 ] ; GF_RTPHinter * hinter ; Bool copy , has_iod , single_av ; u8 init_payt = BASE_PAYT ; u32 mtype ; GF_SDP_IODProfile iod_mode = GF_SDP_IOD_NONE ; u32 media_group = 0 ; u8 media_prio = 0 ; tot_bw = 0 ; prev_ocr = 0 ; single_ocr = 1 ; has_iod = 1 ; iod = ( GF_InitialObjectDescriptor * ) gf_isom_get_root_od ( file ) ; if ( ! iod ) has_iod = 0 ; else { if ( ! gf_list_count ( iod -> ESDescriptors ) ) has_iod = 0 ; gf_odf_desc_del ( ( GF_Descriptor * ) iod ) ; } spec_type = gf_isom_guess_specification ( file ) ; single_av = single_group ? 1 : gf_isom_is_single_av ( file ) ; for ( i = 0 ; i < gf_isom_get_track_count ( file ) ; i ++ ) { res = gf_isom_get_media_type ( file , i + 1 ) ; if ( ( res == GF_ISOM_MEDIA_SCENE ) || ( res == GF_ISOM_MEDIA_OD ) ) { if ( gf_isom_is_track_in_root_od ( file , i + 1 ) ) { gf_isom_set_default_sync_track ( file , i + 1 ) ; break ; } } } nb_done = 0 ; for ( i = 0 ; i < gf_isom_get_track_count ( file ) ; i ++ ) { sl_mode = base_flags ; copy = copy_data ; if ( ! gf_isom_get_sample_count ( file , i + 1 ) ) continue ; if ( ! gf_isom_is_track_enabled ( file , i + 1 ) ) { M4_LOG ( GF_LOG_INFO , ( ""Track<S2SV_blank>ID<S2SV_blank>%d<S2SV_blank>disabled<S2SV_blank>-<S2SV_blank>skipping<S2SV_blank>hint\\n"" , gf_isom_get_track_id ( file , i + 1 ) ) ) ; continue ; } mtype = gf_isom_get_media_type ( file , i + 1 ) ; switch ( mtype ) { case GF_ISOM_MEDIA_VISUAL : if ( single_av ) { media_group = 2 ; media_prio = 2 ; } break ; case GF_ISOM_MEDIA_AUXV : if ( single_av ) { media_group = 2 ; media_prio = 3 ; } break ; case GF_ISOM_MEDIA_PICT : if ( single_av ) { media_group = 2 ; media_prio = 4 ; } break ; case GF_ISOM_MEDIA_AUDIO : if ( single_av ) { media_group = 2 ; media_prio = 1 ; } break ; case GF_ISOM_MEDIA_HINT : continue ; default : if ( spec_type == GF_ISOM_BRAND_ISMA ) continue ; } mtype = gf_isom_get_media_subtype ( file , i + 1 , 1 ) ; if ( ( mtype == GF_ISOM_SUBTYPE_MPEG4 ) || ( mtype == GF_ISOM_SUBTYPE_MPEG4_CRYP ) ) mtype = gf_isom_get_mpeg4_subtype ( file , i + 1 , 1 ) ; if ( ! single_av ) { media_group ++ ; media_prio = 1 ; } streamType = 0 ; esd = gf_isom_get_esd ( file , i + 1 , 1 ) ; <S2SV_StartBug> if ( esd ) { <S2SV_EndBug> streamType = esd -> decoderConfig -> streamType ; if ( ! prev_ocr ) { prev_ocr = esd -> OCRESID ; if ( ! esd -> OCRESID ) prev_ocr = esd -> ESID ; } else if ( esd -> OCRESID && prev_ocr != esd -> OCRESID ) { single_ocr = 0 ; } if ( streamType == 1 ) copy = 1 ; } gf_odf_desc_del ( ( GF_Descriptor * ) esd ) ; if ( ! regular_iod && gf_isom_is_track_in_root_od ( file , i + 1 ) ) { if ( gf_isom_get_sample_count ( file , i + 1 ) == 1 ) { GF_ISOSample * samp = gf_isom_get_sample ( file , i + 1 , 1 , & val ) ; if ( streamType ) { res = gf_hinter_can_embbed_data ( samp -> data , samp -> dataLength , streamType ) ; } else { res = 0 ; } if ( samp ) gf_isom_sample_del ( & samp ) ; if ( res ) continue ; } } if ( interleave ) sl_mode |= GP_RTP_PCK_USE_INTERLEAVING ; hinter = gf_hinter_track_new ( file , i + 1 , MTUSize , max_ptime , rtp_rate , sl_mode , init_payt , copy , media_group , media_prio , & e ) ; if ( ! hinter ) { if ( e ) { M4_LOG ( nb_done ? GF_LOG_WARNING : GF_LOG_ERROR , ( ""Cannot<S2SV_blank>create<S2SV_blank>hinter<S2SV_blank>(%s)\\n"" , gf_error_to_string ( e ) ) ) ; if ( ! nb_done ) return e ; } continue ; } if ( hint_no_offset ) gf_hinter_track_force_no_offsets ( hinter ) ; bw = gf_hinter_track_get_bandwidth ( hinter ) ; tot_bw += bw ; flags = gf_hinter_track_get_flags ( hinter ) ; gf_isom_set_nalu_extract_mode ( file , i + 1 , GF_ISOM_NALU_EXTRACT_LAYER_ONLY ) ; gf_hinter_track_get_payload_name ( hinter , szPayload ) ; M4_LOG ( GF_LOG_INFO , ( ""Hinting<S2SV_blank>track<S2SV_blank>ID<S2SV_blank>%d<S2SV_blank>-<S2SV_blank>Type<S2SV_blank>\\""%s:%s\\""<S2SV_blank>(%s)<S2SV_blank>-<S2SV_blank>BW<S2SV_blank>%d<S2SV_blank>kbps\\n"" , gf_isom_get_track_id ( file , i + 1 ) , gf_4cc_to_str ( mtype ) , gf_4cc_to_str ( mtype ) , szPayload , bw ) ) ; if ( flags & GP_RTP_PCK_SYSTEMS_CAROUSEL ) M4_LOG ( GF_LOG_INFO , ( ""\\tMPEG-4<S2SV_blank>Systems<S2SV_blank>stream<S2SV_blank>carousel<S2SV_blank>enabled\\n"" ) ) ; e = gf_hinter_track_process ( hinter ) ; if ( ! e ) e = gf_hinter_track_finalize ( hinter , has_iod ) ; gf_hinter_track_del ( hinter ) ; if ( e ) { M4_LOG ( GF_LOG_ERROR , ( ""Error<S2SV_blank>while<S2SV_blank>hinting<S2SV_blank>(%s)\\n"" , gf_error_to_string ( e ) ) ) ; if ( ! nb_done ) return e ; } init_payt ++ ; nb_done ++ ; } if ( has_iod ) { iod_mode = GF_SDP_IOD_ISMA ; if ( regular_iod ) iod_mode = GF_SDP_IOD_REGULAR ; } else { iod_mode = GF_SDP_IOD_NONE ; } gf_hinter_finalize ( file , iod_mode , tot_bw ) ; if ( ! single_ocr ) M4_LOG ( GF_LOG_WARNING , ( ""Warning:<S2SV_blank>at<S2SV_blank>least<S2SV_blank>2<S2SV_blank>timelines<S2SV_blank>found<S2SV_blank>in<S2SV_blank>the<S2SV_blank>file\\nThis<S2SV_blank>may<S2SV_blank>not<S2SV_blank>be<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>servers/players\\n\\n"" ) ) ; return GF_OK ; }
","<S2SV_ModStart> if ( esd && esd -> decoderConfig
"
621,"CWE-200 static int vmci_transport_dgram_dequeue ( struct kiocb * kiocb , struct vsock_sock * vsk , struct msghdr * msg , size_t len , int flags ) { int err ; int noblock ; struct vmci_datagram * dg ; size_t payload_len ; struct sk_buff * skb ; noblock = flags & MSG_DONTWAIT ; if ( flags & MSG_OOB || flags & MSG_ERRQUEUE ) return - EOPNOTSUPP ; <S2SV_StartBug> err = 0 ; <S2SV_EndBug> skb = skb_recv_datagram ( & vsk -> sk , flags , noblock , & err ) ; if ( err ) return err ; if ( ! skb ) return - EAGAIN ; dg = ( struct vmci_datagram * ) skb -> data ; if ( ! dg ) goto out ; payload_len = dg -> payload_size ; if ( payload_len != skb -> len - sizeof ( * dg ) ) { err = - EINVAL ; goto out ; } if ( payload_len > len ) { payload_len = len ; msg -> msg_flags |= MSG_TRUNC ; } err = skb_copy_datagram_iovec ( skb , sizeof ( * dg ) , msg -> msg_iov , payload_len ) ; if ( err ) goto out ; <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> if ( msg -> msg_name ) { struct sockaddr_vm * vm_addr ; vm_addr = ( struct sockaddr_vm * ) msg -> msg_name ; vsock_addr_init ( vm_addr , dg -> src . context , dg -> src . resource ) ; msg -> msg_namelen = sizeof ( * vm_addr ) ; } err = payload_len ; out : skb_free_datagram ( & vsk -> sk , skb ) ; return err ; }
","<S2SV_ModStart> - EOPNOTSUPP ; msg -> msg_namelen = 0 ; <S2SV_ModStart> goto out ; <S2SV_ModEnd> if ( msg
"
622,"CWE-125 int obj2ast_alias ( PyObject * obj , alias_ty * out , PyArena * arena ) { PyObject * tmp = NULL ; identifier name ; identifier asname ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_name ) ) { <S2SV_EndBug> int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_name ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; <S2SV_StartBug> res = obj2ast_identifier ( tmp , & name , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""name\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>alias"" ) ; return 1 ; } if ( exists_not_none ( obj , & PyId_asname ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_asname ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_identifier ( tmp , & asname , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { asname = NULL ; } * out = alias ( name , asname , arena ) ; return 0 ; failed : Py_XDECREF ( tmp ) ; return 1 ; }
","<S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_name , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""name\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>alias"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_identifier ( tmp , & name , arena ) ; if ( res != 0 <S2SV_ModEnd> ) goto failed <S2SV_ModStart> goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_asname , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; asname = NULL ; } else { int res ; <S2SV_ModStart> tmp , & asname <S2SV_ModEnd> , arena ) <S2SV_ModStart> ) ; } <S2SV_ModEnd> * out =
"
623,"CWE-20 static int encrypt ( struct blkcipher_desc * desc , struct scatterlist * dst , struct scatterlist * src , unsigned int nbytes ) { struct blkcipher_walk walk ; struct crypto_blkcipher * tfm = desc -> tfm ; struct salsa20_ctx * ctx = crypto_blkcipher_ctx ( tfm ) ; int err ; blkcipher_walk_init ( & walk , dst , src , nbytes ) ; err = blkcipher_walk_virt_block ( desc , & walk , 64 ) ; salsa20_ivsetup ( ctx , walk . iv ) ; <S2SV_StartBug> if ( likely ( walk . nbytes == nbytes ) ) <S2SV_EndBug> { salsa20_encrypt_bytes ( ctx , walk . src . virt . addr , walk . dst . virt . addr , nbytes ) ; return blkcipher_walk_done ( desc , & walk , 0 ) ; } while ( walk . nbytes >= 64 ) { salsa20_encrypt_bytes ( ctx , walk . src . virt . addr , walk . dst . virt . addr , walk . nbytes - ( walk . nbytes % 64 ) ) ; err = blkcipher_walk_done ( desc , & walk , walk . nbytes % 64 ) ; } if ( walk . nbytes ) { salsa20_encrypt_bytes ( ctx , walk . src . virt . addr , walk . dst . virt . addr , walk . nbytes ) ; err = blkcipher_walk_done ( desc , & walk , 0 ) ; } return err ; }
","<S2SV_ModStart> iv ) ; <S2SV_ModEnd> while ( walk
"
624,"CWE-000 static int snd_compress_check_input ( struct snd_compr_params * params ) { if ( params -> buffer . fragment_size == 0 || <S2SV_StartBug> params -> buffer . fragments > SIZE_MAX / params -> buffer . fragment_size ) <S2SV_EndBug> return - EINVAL ; if ( params -> codec . id == 0 || params -> codec . id > SND_AUDIOCODEC_MAX ) return - EINVAL ; if ( params -> codec . ch_in == 0 || params -> codec . ch_out == 0 ) return - EINVAL ; return 0 ; }
","<S2SV_ModStart> . fragments > INT_MAX <S2SV_ModEnd> / params ->
"
625,"CWE-119 static MagickBooleanType EncodeImage ( const ImageInfo * image_info , Image * image , const size_t data_size , ExceptionInfo * exception ) { # define MaxCode ( number_bits ) ( ( one << ( number_bits ) ) - 1 ) # define MaxHashTable 5003 # define MaxGIFBits 12UL # define MaxGIFTable ( 1UL << MaxGIFBits ) <S2SV_StartBug> # define GIFOutputCode ( code ) { if ( bits > 0 ) datum |= ( size_t ) ( code ) << bits ; else datum = ( size_t ) ( code ) ; bits += number_bits ; while ( bits >= 8 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } datum >>= 8 ; bits -= 8 ; } if ( free_code > max_code ) { number_bits ++ ; if ( number_bits == MaxGIFBits ) max_code = MaxGIFTable ; else max_code = MaxCode ( number_bits ) ; } } <S2SV_EndBug> Quantum index ; short * hash_code , * hash_prefix , waiting_code ; size_t bits , clear_code , datum , end_of_information_code , free_code , length , max_code , next_pixel , number_bits , one , pass ; ssize_t displacement , offset , k , y ; unsigned char * packet , * hash_suffix ; assert ( image != ( Image * ) NULL ) ; one = 1 ; packet = ( unsigned char * ) AcquireQuantumMemory ( 256 , sizeof ( * packet ) ) ; hash_code = ( short * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_code ) ) ; hash_prefix = ( short * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_prefix ) ) ; hash_suffix = ( unsigned char * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_suffix ) ) ; if ( ( packet == ( unsigned char * ) NULL ) || ( hash_code == ( short * ) NULL ) || ( hash_prefix == ( short * ) NULL ) || ( hash_suffix == ( unsigned char * ) NULL ) ) { if ( packet != ( unsigned char * ) NULL ) packet = ( unsigned char * ) RelinquishMagickMemory ( packet ) ; if ( hash_code != ( short * ) NULL ) hash_code = ( short * ) RelinquishMagickMemory ( hash_code ) ; if ( hash_prefix != ( short * ) NULL ) hash_prefix = ( short * ) RelinquishMagickMemory ( hash_prefix ) ; if ( hash_suffix != ( unsigned char * ) NULL ) hash_suffix = ( unsigned char * ) RelinquishMagickMemory ( hash_suffix ) ; return ( MagickFalse ) ; } ( void ) memset ( packet , 0 , 256 * sizeof ( * packet ) ) ; ( void ) memset ( hash_code , 0 , MaxHashTable * sizeof ( * hash_code ) ) ; ( void ) memset ( hash_prefix , 0 , MaxHashTable * sizeof ( * hash_prefix ) ) ; ( void ) memset ( hash_suffix , 0 , MaxHashTable * sizeof ( * hash_suffix ) ) ; number_bits = data_size ; max_code = MaxCode ( number_bits ) ; clear_code = ( ( short ) one << ( data_size - 1 ) ) ; end_of_information_code = clear_code + 1 ; free_code = clear_code + 2 ; length = 0 ; datum = 0 ; bits = 0 ; GIFOutputCode ( clear_code ) ; offset = 0 ; pass = 0 ; waiting_code = 0 ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { register const Quantum * magick_restrict p ; register ssize_t x ; p = GetVirtualPixels ( image , 0 , offset , image -> columns , 1 , exception ) ; if ( p == ( const Quantum * ) NULL ) break ; if ( y == 0 ) { waiting_code = ( short ) GetPixelIndex ( image , p ) ; p += GetPixelChannels ( image ) ; } for ( x = ( ssize_t ) ( y == 0 ? 1 : 0 ) ; x < ( ssize_t ) image -> columns ; x ++ ) { <S2SV_StartBug> index = ( Quantum ) ( ( size_t ) GetPixelIndex ( image , p ) & 0xff ) ; <S2SV_EndBug> p += GetPixelChannels ( image ) ; k = ( ssize_t ) ( ( ( size_t ) index << ( MaxGIFBits - 8 ) ) + waiting_code ) ; if ( k >= MaxHashTable ) k -= MaxHashTable ; <S2SV_StartBug> next_pixel = MagickFalse ; <S2SV_EndBug> displacement = 1 ; if ( hash_code [ k ] > 0 ) { if ( ( hash_prefix [ k ] == waiting_code ) && ( hash_suffix [ k ] == ( unsigned char ) index ) ) { waiting_code = hash_code [ k ] ; continue ; } if ( k != 0 ) displacement = MaxHashTable - k ; for ( ; ; ) { k -= displacement ; if ( k < 0 ) k += MaxHashTable ; if ( hash_code [ k ] == 0 ) break ; if ( ( hash_prefix [ k ] == waiting_code ) && ( hash_suffix [ k ] == ( unsigned char ) index ) ) { waiting_code = hash_code [ k ] ; next_pixel = MagickTrue ; break ; } } if ( next_pixel != MagickFalse ) continue ; } GIFOutputCode ( waiting_code ) ; if ( free_code < MaxGIFTable ) { hash_code [ k ] = ( short ) free_code ++ ; hash_prefix [ k ] = waiting_code ; hash_suffix [ k ] = ( unsigned char ) index ; } else { for ( k = 0 ; k < MaxHashTable ; k ++ ) hash_code [ k ] = 0 ; free_code = clear_code + 2 ; GIFOutputCode ( clear_code ) ; number_bits = data_size ; max_code = MaxCode ( number_bits ) ; } waiting_code = ( short ) index ; } if ( image_info -> interlace == NoInterlace ) offset ++ ; else switch ( pass ) { case 0 : default : { offset += 8 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 4 ; } break ; } case 1 : { offset += 8 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 2 ; } break ; } case 2 : { offset += 4 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 1 ; } break ; } case 3 : { offset += 2 ; break ; } } } GIFOutputCode ( waiting_code ) ; GIFOutputCode ( end_of_information_code ) ; if ( bits > 0 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } } if ( length > 0 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; } hash_suffix = ( unsigned char * ) RelinquishMagickMemory ( hash_suffix ) ; hash_prefix = ( short * ) RelinquishMagickMemory ( hash_prefix ) ; hash_code = ( short * ) RelinquishMagickMemory ( hash_code ) ; packet = ( unsigned char * ) RelinquishMagickMemory ( packet ) ; return ( MagickTrue ) ; }
","<S2SV_ModStart> ( code ) \\\n{ <S2SV_ModEnd> if ( bits <S2SV_ModStart> ) ; } \\\n} <S2SV_ModEnd> Quantum index ; <S2SV_ModStart> ++ ) { next_pixel = MagickFalse ; displacement = 1 ; <S2SV_ModStart> -= MaxHashTable ; if ( k < 0 ) continue <S2SV_ModEnd> ; if (
"
626,"CWE-834 static int mxf_read_index_entry_array ( AVIOContext * pb , MXFIndexTableSegment * segment ) { int i , length ; segment -> nb_index_entries = avio_rb32 ( pb ) ; length = avio_rb32 ( pb ) ; <S2SV_StartBug> if ( ! ( segment -> temporal_offset_entries = av_calloc ( segment -> nb_index_entries , sizeof ( * segment -> temporal_offset_entries ) ) ) || <S2SV_EndBug> ! ( segment -> flag_entries = av_calloc ( segment -> nb_index_entries , sizeof ( * segment -> flag_entries ) ) ) || ! ( segment -> stream_offset_entries = av_calloc ( segment -> nb_index_entries , sizeof ( * segment -> stream_offset_entries ) ) ) ) { av_freep ( & segment -> temporal_offset_entries ) ; av_freep ( & segment -> flag_entries ) ; return AVERROR ( ENOMEM ) ; } <S2SV_StartBug> for ( i = 0 ; i < segment -> nb_index_entries ; i ++ ) { <S2SV_EndBug> segment -> temporal_offset_entries [ i ] = avio_r8 ( pb ) ; avio_r8 ( pb ) ; segment -> flag_entries [ i ] = avio_r8 ( pb ) ; segment -> stream_offset_entries [ i ] = avio_rb64 ( pb ) ; avio_skip ( pb , length - 11 ) ; } return 0 ; }
","<S2SV_ModStart> ; if ( segment -> nb_index_entries && length < 11 ) return AVERROR_INVALIDDATA ; if ( <S2SV_ModStart> ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ;
"
627,"CWE-369 void * _TIFFmalloc ( tmsize_t s ) <S2SV_StartBug> { <S2SV_EndBug> return ( malloc ( ( size_t ) s ) ) ; }
","<S2SV_ModStart> s ) { if ( s == 0 ) return ( ( void * ) NULL ) ;
"
628,"CWE-119 static void open_output_file ( struct stream_state * stream , <S2SV_StartBug> struct VpxEncoderConfig * global ) { <S2SV_EndBug> const char * fn = stream -> config . out_fn ; const struct vpx_codec_enc_cfg * const cfg = & stream -> config . cfg ; if ( cfg -> g_pass == VPX_RC_FIRST_PASS ) return ; stream -> file = strcmp ( fn , ""-"" ) ? fopen ( fn , ""wb"" ) : set_binary_mode ( stdout ) ; if ( ! stream -> file ) fatal ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>output<S2SV_blank>file"" ) ; if ( stream -> config . write_webm && fseek ( stream -> file , 0 , SEEK_CUR ) ) fatal ( ""WebM<S2SV_blank>output<S2SV_blank>to<S2SV_blank>pipes<S2SV_blank>not<S2SV_blank>supported."" ) ; # if CONFIG_WEBM_IO if ( stream -> config . write_webm ) { stream -> ebml . stream = stream -> file ; write_webm_file_header ( & stream -> ebml , cfg , & global -> framerate , stream -> config . stereo_fmt , <S2SV_StartBug> global -> codec -> fourcc ) ; <S2SV_EndBug> } # endif if ( ! stream -> config . write_webm ) { ivf_write_file_header ( stream -> file , cfg , global -> codec -> fourcc , 0 ) ; } }
","<S2SV_ModStart> VpxEncoderConfig * global , const struct VpxRational * pixel_aspect_ratio <S2SV_ModStart> codec -> fourcc , pixel_aspect_ratio
"
629,"CWE-772 chrand_ret * chrand_principal3_2_svc ( chrand3_arg * arg , struct svc_req * rqstp ) { static chrand_ret ret ; krb5_keyblock * k ; int nkeys ; char * prime_arg , * funcname ; <S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_chrand_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; funcname = ""kadm5_randkey_principal"" ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> princ , & prime_arg ) ) { ret . code = KADM5_BAD_PRINCIPAL ; goto exit_func ; } if ( cmp_gss_krb5_name ( handle , rqst2name ( rqstp ) , arg -> princ ) ) { ret . code = randkey_principal_wrapper_3 ( ( void * ) handle , arg -> princ , arg -> keepold , arg -> n_ks_tuple , arg -> ks_tuple , & k , & nkeys ) ; } else if ( ! ( CHANGEPW_SERVICE ( rqstp ) ) && kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_CHANGEPW , arg -> princ , NULL ) ) { ret . code = kadm5_randkey_principal_3 ( ( void * ) handle , arg -> princ , arg -> keepold , arg -> n_ks_tuple , arg -> ks_tuple , & k , & nkeys ) ; } else { log_unauth ( funcname , prime_arg , & client_name , & service_name , rqstp ) ; ret . code = KADM5_AUTH_CHANGEPW ; } if ( ret . code == KADM5_OK ) { ret . keys = k ; ret . n_keys = nkeys ; } if ( ret . code != KADM5_AUTH_CHANGEPW ) { if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( funcname , prime_arg , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } free ( prime_arg ) ; <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> gss_release_buffer ( & minor_stat , & service_name ) ; exit_func : free_server_handle ( handle ) ; return & ret ; }
","<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> prime_arg ) ; exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
"
630,"CWE-200 int pam_sm_authenticate ( pam_handle_t * pamh , int flags , int argc , const char * * argv ) { struct passwd * pw = NULL , pw_s ; const char * user = NULL ; cfg_t cfg_st ; cfg_t * cfg = & cfg_st ; char buffer [ BUFSIZE ] ; char * buf = NULL ; char * authfile_dir ; size_t authfile_dir_len ; int pgu_ret , gpn_ret ; int retval = PAM_IGNORE ; device_t * devices = NULL ; unsigned n_devices = 0 ; int openasuser ; int should_free_origin = 0 ; int should_free_appid = 0 ; int should_free_auth_file = 0 ; int should_free_authpending_file = 0 ; parse_cfg ( flags , argc , argv , cfg ) ; if ( ! cfg -> origin ) { strcpy ( buffer , DEFAULT_ORIGIN_PREFIX ) ; if ( gethostname ( buffer + strlen ( DEFAULT_ORIGIN_PREFIX ) , BUFSIZE - strlen ( DEFAULT_ORIGIN_PREFIX ) ) == - 1 ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>host<S2SV_blank>name"" ) ; goto done ; } DBG ( ""Origin<S2SV_blank>not<S2SV_blank>specified,<S2SV_blank>using<S2SV_blank>\\""%s\\"""" , buffer ) ; cfg -> origin = strdup ( buffer ) ; if ( ! cfg -> origin ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto done ; } else { should_free_origin = 1 ; } } if ( ! cfg -> appid ) { DBG ( ""Appid<S2SV_blank>not<S2SV_blank>specified,<S2SV_blank>using<S2SV_blank>the<S2SV_blank>same<S2SV_blank>value<S2SV_blank>of<S2SV_blank>origin<S2SV_blank>(%s)"" , cfg -> origin ) ; cfg -> appid = strdup ( cfg -> origin ) ; if ( ! cfg -> appid ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory"" ) goto done ; } else { should_free_appid = 1 ; } } if ( cfg -> max_devs == 0 ) { DBG ( ""Maximum<S2SV_blank>devices<S2SV_blank>number<S2SV_blank>not<S2SV_blank>set.<S2SV_blank>Using<S2SV_blank>default<S2SV_blank>(%d)"" , MAX_DEVS ) ; cfg -> max_devs = MAX_DEVS ; } devices = malloc ( sizeof ( device_t ) * cfg -> max_devs ) ; if ( ! devices ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory"" ) ; retval = PAM_IGNORE ; goto done ; } pgu_ret = pam_get_user ( pamh , & user , NULL ) ; if ( pgu_ret != PAM_SUCCESS || user == NULL ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>access<S2SV_blank>user<S2SV_blank>%s"" , user ) ; retval = PAM_CONV_ERR ; goto done ; } DBG ( ""Requesting<S2SV_blank>authentication<S2SV_blank>for<S2SV_blank>user<S2SV_blank>%s"" , user ) ; gpn_ret = getpwnam_r ( user , & pw_s , buffer , sizeof ( buffer ) , & pw ) ; if ( gpn_ret != 0 || pw == NULL || pw -> pw_dir == NULL || pw -> pw_dir [ 0 ] != '/' ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>retrieve<S2SV_blank>credentials<S2SV_blank>for<S2SV_blank>user<S2SV_blank>%s,<S2SV_blank>(%s)"" , user , strerror ( errno ) ) ; retval = PAM_USER_UNKNOWN ; goto done ; } DBG ( ""Found<S2SV_blank>user<S2SV_blank>%s"" , user ) ; DBG ( ""Home<S2SV_blank>directory<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>%s"" , user , pw -> pw_dir ) ; if ( ! cfg -> auth_file ) { buf = NULL ; authfile_dir = secure_getenv ( DEFAULT_AUTHFILE_DIR_VAR ) ; if ( ! authfile_dir ) { DBG ( ""Variable<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>set.<S2SV_blank>Using<S2SV_blank>default<S2SV_blank>value<S2SV_blank>($HOME/.config/)"" , DEFAULT_AUTHFILE_DIR_VAR ) ; authfile_dir_len = strlen ( pw -> pw_dir ) + strlen ( ""/.config"" ) + strlen ( DEFAULT_AUTHFILE ) + 1 ; buf = malloc ( sizeof ( char ) * ( authfile_dir_len ) ) ; if ( ! buf ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory"" ) ; retval = PAM_IGNORE ; goto done ; } snprintf ( buf , authfile_dir_len , ""%s/.config%s"" , pw -> pw_dir , DEFAULT_AUTHFILE ) ; } else { DBG ( ""Variable<S2SV_blank>%s<S2SV_blank>set<S2SV_blank>to<S2SV_blank>%s"" , DEFAULT_AUTHFILE_DIR_VAR , authfile_dir ) ; authfile_dir_len = strlen ( authfile_dir ) + strlen ( DEFAULT_AUTHFILE ) + 1 ; buf = malloc ( sizeof ( char ) * ( authfile_dir_len ) ) ; if ( ! buf ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory"" ) ; retval = PAM_IGNORE ; goto done ; } snprintf ( buf , authfile_dir_len , ""%s%s"" , authfile_dir , DEFAULT_AUTHFILE ) ; } DBG ( ""Using<S2SV_blank>default<S2SV_blank>authentication<S2SV_blank>file<S2SV_blank>%s"" , buf ) ; cfg -> auth_file = buf ; should_free_auth_file = 1 ; buf = NULL ; } else { DBG ( ""Using<S2SV_blank>authentication<S2SV_blank>file<S2SV_blank>%s"" , cfg -> auth_file ) ; } openasuser = geteuid ( ) == 0 && cfg -> openasuser ; if ( openasuser ) { if ( seteuid ( pw_s . pw_uid ) ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>user<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>%i"" , pw_s . pw_uid ) ; retval = PAM_IGNORE ; goto done ; } DBG ( ""Switched<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>%i"" , pw_s . pw_uid ) ; } retval = get_devices_from_authfile ( cfg -> auth_file , user , cfg -> max_devs , cfg -> debug , cfg -> debug_file , devices , & n_devices ) ; if ( openasuser ) { if ( seteuid ( 0 ) ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>back<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>0"" ) ; retval = PAM_IGNORE ; goto done ; } DBG ( ""Switched<S2SV_blank>back<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>0"" ) ; } if ( retval != 1 ) { n_devices = 0 ; } if ( n_devices == 0 ) { if ( cfg -> nouserok ) { DBG ( ""Found<S2SV_blank>no<S2SV_blank>devices<S2SV_blank>but<S2SV_blank>nouserok<S2SV_blank>specified.<S2SV_blank>Skipping<S2SV_blank>authentication"" ) ; retval = PAM_SUCCESS ; goto done ; } else if ( retval != 1 ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>devices<S2SV_blank>from<S2SV_blank>file<S2SV_blank>%s"" , cfg -> auth_file ) ; retval = PAM_AUTHINFO_UNAVAIL ; goto done ; } else { DBG ( ""Found<S2SV_blank>no<S2SV_blank>devices.<S2SV_blank>Aborting."" ) ; retval = PAM_AUTHINFO_UNAVAIL ; goto done ; } } if ( ! cfg -> authpending_file ) { int actual_size = snprintf ( buffer , BUFSIZE , DEFAULT_AUTHPENDING_FILE_PATH , getuid ( ) ) ; if ( actual_size >= 0 && actual_size < BUFSIZE ) { cfg -> authpending_file = strdup ( buffer ) ; } if ( ! cfg -> authpending_file ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>the<S2SV_blank>authpending_file,<S2SV_blank>touch<S2SV_blank>request<S2SV_blank>notifications<S2SV_blank>will<S2SV_blank>not<S2SV_blank>be<S2SV_blank>emitted"" ) ; } else { should_free_authpending_file = 1 ; } } else { if ( strlen ( cfg -> authpending_file ) == 0 ) { DBG ( ""authpending_file<S2SV_blank>is<S2SV_blank>set<S2SV_blank>to<S2SV_blank>an<S2SV_blank>empty<S2SV_blank>value,<S2SV_blank>touch<S2SV_blank>request<S2SV_blank>notifications<S2SV_blank>will<S2SV_blank>be<S2SV_blank>disabled"" ) ; cfg -> authpending_file = NULL ; } } int authpending_file_descriptor = - 1 ; if ( cfg -> authpending_file ) { DBG ( ""Using<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>for<S2SV_blank>emitting<S2SV_blank>touch<S2SV_blank>request<S2SV_blank>notifications"" , cfg -> authpending_file ) ; <S2SV_StartBug> authpending_file_descriptor = open ( cfg -> authpending_file , O_RDONLY | O_CREAT , 0664 ) ; <S2SV_EndBug> if ( authpending_file_descriptor < 0 ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>emit<S2SV_blank>\'authentication<S2SV_blank>started\'<S2SV_blank>notification<S2SV_blank>by<S2SV_blank>opening<S2SV_blank>the<S2SV_blank>file<S2SV_blank>\'%s\',<S2SV_blank>(%s)"" , cfg -> authpending_file , strerror ( errno ) ) ; } } if ( cfg -> manual == 0 ) { if ( cfg -> interactive ) { converse ( pamh , PAM_PROMPT_ECHO_ON , cfg -> prompt != NULL ? cfg -> prompt : DEFAULT_PROMPT ) ; } retval = do_authentication ( cfg , devices , n_devices , pamh ) ; } else { retval = do_manual_authentication ( cfg , devices , n_devices , pamh ) ; } if ( authpending_file_descriptor >= 0 ) { if ( close ( authpending_file_descriptor ) < 0 ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>emit<S2SV_blank>\'authentication<S2SV_blank>stopped\'<S2SV_blank>notification<S2SV_blank>by<S2SV_blank>closing<S2SV_blank>the<S2SV_blank>file<S2SV_blank>\'%s\',<S2SV_blank>(%s)"" , cfg -> authpending_file , strerror ( errno ) ) ; } } if ( retval != 1 ) { DBG ( ""do_authentication<S2SV_blank>returned<S2SV_blank>%d"" , retval ) ; retval = PAM_AUTH_ERR ; goto done ; } retval = PAM_SUCCESS ; done : free_devices ( devices , n_devices ) ; if ( buf ) { free ( buf ) ; buf = NULL ; } if ( should_free_origin ) { free ( ( char * ) cfg -> origin ) ; cfg -> origin = NULL ; } if ( should_free_appid ) { free ( ( char * ) cfg -> appid ) ; cfg -> appid = NULL ; } if ( should_free_auth_file ) { free ( ( char * ) cfg -> auth_file ) ; cfg -> auth_file = NULL ; } if ( should_free_authpending_file ) { free ( ( char * ) cfg -> authpending_file ) ; cfg -> authpending_file = NULL ; } if ( cfg -> alwaysok && retval != PAM_SUCCESS ) { DBG ( ""alwaysok<S2SV_blank>needed<S2SV_blank>(otherwise<S2SV_blank>return<S2SV_blank>with<S2SV_blank>%d)"" , retval ) ; retval = PAM_SUCCESS ; } DBG ( ""done.<S2SV_blank>[%s]"" , pam_strerror ( pamh , retval ) ) ; <S2SV_StartBug> return retval ; <S2SV_EndBug> }
","<S2SV_ModStart> O_RDONLY | O_CREAT | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY <S2SV_ModStart> ) ) ; if ( cfg -> is_custom_debug_file ) { fclose ( cfg -> debug_file ) ; }
"
631,"CWE-119 void SWFShape_setLeftFillStyle ( SWFShape shape , SWFFillStyle fill ) { ShapeRecord record ; int idx ; if ( shape -> isEnded || shape -> isMorph ) return ; if ( fill == NOFILL ) { record = addStyleRecord ( shape ) ; record . record . stateChange -> leftFill = 0 ; record . record . stateChange -> flags |= SWF_SHAPE_FILLSTYLE0FLAG ; return ; } idx = getFillIdx ( shape , fill ) ; if ( idx == 0 ) { SWFFillStyle_addDependency ( fill , ( SWFCharacter ) shape ) ; if ( addFillStyle ( shape , fill ) < 0 ) return ; idx = getFillIdx ( shape , fill ) ; } <S2SV_StartBug> record = addStyleRecord ( shape ) ; <S2SV_EndBug> record . record . stateChange -> leftFill = idx ; record . record . stateChange -> flags |= SWF_SHAPE_FILLSTYLE0FLAG ; }
","<S2SV_ModStart> ) ; } else if ( idx >= 255 && shape -> useVersion == SWF_SHAPE1 ) { SWF_error ( ""Too<S2SV_blank>many<S2SV_blank>fills<S2SV_blank>for<S2SV_blank>SWFShape<S2SV_blank>V1.\\n"" ""Use<S2SV_blank>a<S2SV_blank>higher<S2SV_blank>SWFShape<S2SV_blank>version\\n"" ) ; }
"
632,"CWE-190 PHPAPI PHP_FUNCTION ( fread ) { zval * arg1 ; long len ; php_stream * stream ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""rl"" , & arg1 , & len ) == FAILURE ) { RETURN_FALSE ; } PHP_STREAM_TO_ZVAL ( stream , & arg1 ) ; if ( len <= 0 ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Length<S2SV_blank>parameter<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0"" ) ; RETURN_FALSE ; } <S2SV_StartBug> Z_STRVAL_P ( return_value ) = emalloc ( len + 1 ) ; <S2SV_EndBug> Z_STRLEN_P ( return_value ) = php_stream_read ( stream , Z_STRVAL_P ( return_value ) , len ) ; Z_STRVAL_P ( return_value ) [ Z_STRLEN_P ( return_value ) ] = 0 ; Z_TYPE_P ( return_value ) = IS_STRING ; }
","<S2SV_ModStart> RETURN_FALSE ; } if ( len > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Length<S2SV_blank>parameter<S2SV_blank>must<S2SV_blank>be<S2SV_blank>no<S2SV_blank>more<S2SV_blank>than<S2SV_blank>%d"" , INT_MAX ) ; RETURN_FALSE ; }
"
633,"CWE-200 long dgnc_mgmt_ioctl ( struct file * file , unsigned int cmd , unsigned long arg ) { unsigned long flags ; void __user * uarg = ( void __user * ) arg ; switch ( cmd ) { case DIGI_GETDD : { struct digi_dinfo ddi ; spin_lock_irqsave ( & dgnc_global_lock , flags ) ; <S2SV_StartBug> ddi . dinfo_nboards = dgnc_NumBoards ; <S2SV_EndBug> sprintf ( ddi . dinfo_version , ""%s"" , DG_PART ) ; spin_unlock_irqrestore ( & dgnc_global_lock , flags ) ; if ( copy_to_user ( uarg , & ddi , sizeof ( ddi ) ) ) return - EFAULT ; break ; } case DIGI_GETBD : { int brd ; struct digi_info di ; if ( copy_from_user ( & brd , uarg , sizeof ( int ) ) ) return - EFAULT ; if ( brd < 0 || brd >= dgnc_NumBoards ) return - ENODEV ; memset ( & di , 0 , sizeof ( di ) ) ; di . info_bdnum = brd ; spin_lock_irqsave ( & dgnc_Board [ brd ] -> bd_lock , flags ) ; di . info_bdtype = dgnc_Board [ brd ] -> dpatype ; di . info_bdstate = dgnc_Board [ brd ] -> dpastatus ; di . info_ioport = 0 ; di . info_physaddr = ( ulong ) dgnc_Board [ brd ] -> membase ; di . info_physsize = ( ulong ) dgnc_Board [ brd ] -> membase - dgnc_Board [ brd ] -> membase_end ; if ( dgnc_Board [ brd ] -> state != BOARD_FAILED ) di . info_nports = dgnc_Board [ brd ] -> nasync ; else di . info_nports = 0 ; spin_unlock_irqrestore ( & dgnc_Board [ brd ] -> bd_lock , flags ) ; if ( copy_to_user ( uarg , & di , sizeof ( di ) ) ) return - EFAULT ; break ; } case DIGI_GET_NI_INFO : { struct channel_t * ch ; struct ni_info ni ; unsigned char mstat = 0 ; uint board = 0 ; uint channel = 0 ; if ( copy_from_user ( & ni , uarg , sizeof ( ni ) ) ) return - EFAULT ; board = ni . board ; channel = ni . channel ; if ( board >= dgnc_NumBoards ) return - ENODEV ; if ( channel >= dgnc_Board [ board ] -> nasync ) return - ENODEV ; ch = dgnc_Board [ board ] -> channels [ channel ] ; if ( ! ch || ch -> magic != DGNC_CHANNEL_MAGIC ) return - ENODEV ; memset ( & ni , 0 , sizeof ( ni ) ) ; ni . board = board ; ni . channel = channel ; spin_lock_irqsave ( & ch -> ch_lock , flags ) ; mstat = ( ch -> ch_mostat | ch -> ch_mistat ) ; if ( mstat & UART_MCR_DTR ) { ni . mstat |= TIOCM_DTR ; ni . dtr = TIOCM_DTR ; } if ( mstat & UART_MCR_RTS ) { ni . mstat |= TIOCM_RTS ; ni . rts = TIOCM_RTS ; } if ( mstat & UART_MSR_CTS ) { ni . mstat |= TIOCM_CTS ; ni . cts = TIOCM_CTS ; } if ( mstat & UART_MSR_RI ) { ni . mstat |= TIOCM_RI ; ni . ri = TIOCM_RI ; } if ( mstat & UART_MSR_DCD ) { ni . mstat |= TIOCM_CD ; ni . dcd = TIOCM_CD ; } if ( mstat & UART_MSR_DSR ) ni . mstat |= TIOCM_DSR ; ni . iflag = ch -> ch_c_iflag ; ni . oflag = ch -> ch_c_oflag ; ni . cflag = ch -> ch_c_cflag ; ni . lflag = ch -> ch_c_lflag ; if ( ch -> ch_digi . digi_flags & CTSPACE || ch -> ch_c_cflag & CRTSCTS ) ni . hflow = 1 ; else ni . hflow = 0 ; if ( ( ch -> ch_flags & CH_STOPI ) || ( ch -> ch_flags & CH_FORCED_STOPI ) ) ni . recv_stopped = 1 ; else ni . recv_stopped = 0 ; if ( ( ch -> ch_flags & CH_STOP ) || ( ch -> ch_flags & CH_FORCED_STOP ) ) ni . xmit_stopped = 1 ; else ni . xmit_stopped = 0 ; ni . curtx = ch -> ch_txcount ; ni . currx = ch -> ch_rxcount ; ni . baud = ch -> ch_old_baud ; spin_unlock_irqrestore ( & ch -> ch_lock , flags ) ; if ( copy_to_user ( uarg , & ni , sizeof ( ni ) ) ) return - EFAULT ; break ; } } return 0 ; }
","<S2SV_ModStart> flags ) ; memset ( & ddi , 0 , sizeof ( ddi ) ) ;
"
634,"CWE-362 static void sctp_generate_timeout_event ( struct sctp_association * asoc , sctp_event_timeout_t timeout_type ) { <S2SV_StartBug> struct net * net = sock_net ( asoc -> base . sk ) ; <S2SV_EndBug> int error = 0 ; <S2SV_StartBug> bh_lock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sock_owned_by_user ( asoc -> base . sk ) ) { <S2SV_EndBug> pr_debug ( ""%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy:<S2SV_blank>timer<S2SV_blank>%d\\n"" , __func__ , timeout_type ) ; if ( ! mod_timer ( & asoc -> timers [ timeout_type ] , jiffies + ( HZ / 20 ) ) ) sctp_association_hold ( asoc ) ; goto out_unlock ; } if ( asoc -> base . dead ) goto out_unlock ; error = sctp_do_sm ( net , SCTP_EVENT_T_TIMEOUT , SCTP_ST_TIMEOUT ( timeout_type ) , asoc -> state , asoc -> ep , asoc , ( void * ) timeout_type , GFP_ATOMIC ) ; if ( error ) <S2SV_StartBug> asoc -> base . sk -> sk_err = - error ; <S2SV_EndBug> out_unlock : <S2SV_StartBug> bh_unlock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> sctp_association_put ( asoc ) ; }
","<S2SV_ModStart> ) { struct sock * sk = asoc -> base . sk ; struct <S2SV_ModStart> = sock_net ( <S2SV_ModEnd> sk ) ; <S2SV_ModStart> ; bh_lock_sock ( <S2SV_ModEnd> sk ) ; <S2SV_ModStart> ( sock_owned_by_user ( <S2SV_ModEnd> sk ) ) <S2SV_ModStart> ( error ) <S2SV_ModEnd> sk -> sk_err <S2SV_ModStart> : bh_unlock_sock ( <S2SV_ModEnd> sk ) ;
"
635,"CWE-125 u_int ieee802_15_4_if_print ( netdissect_options * ndo , const struct pcap_pkthdr * h , const u_char * p ) { u_int caplen = h -> caplen ; u_int hdrlen ; uint16_t fc ; uint8_t seq ; uint16_t panid = 0 ; if ( caplen < 3 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return caplen ; } hdrlen = 3 ; fc = EXTRACT_LE_16BITS ( p ) ; seq = EXTRACT_LE_8BITS ( p + 2 ) ; p += 3 ; caplen -= 3 ; ND_PRINT ( ( ndo , ""IEEE<S2SV_blank>802.15.4<S2SV_blank>%s<S2SV_blank>packet<S2SV_blank>"" , ftypes [ FC_FRAME_TYPE ( fc ) ] ) ) ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""seq<S2SV_blank>%02x<S2SV_blank>"" , seq ) ) ; switch ( FC_DEST_ADDRESSING_MODE ( fc ) ) { case FC_ADDRESSING_MODE_NONE : if ( fc & FC_PAN_ID_COMPRESSION ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""none<S2SV_blank>"" ) ) ; break ; case FC_ADDRESSING_MODE_RESERVED : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""reserved<S2SV_blank>destination<S2SV_blank>addressing<S2SV_blank>mode"" ) ) ; return hdrlen ; case FC_ADDRESSING_MODE_SHORT : if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""%04x:%04x<S2SV_blank>"" , panid , EXTRACT_LE_16BITS ( p + 2 ) ) ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; break ; case FC_ADDRESSING_MODE_LONG : if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; if ( caplen < 8 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) <S2SV_StartBug> ND_PRINT ( ( ndo , ""%04x:%s<S2SV_blank>"" , panid , le64addr_string ( ndo , p + 2 ) ) ) ; <S2SV_EndBug> p += 8 ; caplen -= 8 ; hdrlen += 8 ; break ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""<<S2SV_blank>"" ) ) ; switch ( FC_SRC_ADDRESSING_MODE ( fc ) ) { case FC_ADDRESSING_MODE_NONE : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""none<S2SV_blank>"" ) ) ; break ; case FC_ADDRESSING_MODE_RESERVED : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""reserved<S2SV_blank>source<S2SV_blank>addressing<S2SV_blank>mode"" ) ) ; return 0 ; case FC_ADDRESSING_MODE_SHORT : if ( ! ( fc & FC_PAN_ID_COMPRESSION ) ) { if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; } if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""%04x:%04x<S2SV_blank>"" , panid , EXTRACT_LE_16BITS ( p ) ) ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; break ; case FC_ADDRESSING_MODE_LONG : if ( ! ( fc & FC_PAN_ID_COMPRESSION ) ) { if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; } if ( caplen < 8 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""%04x:%s<S2SV_blank>"" , panid , le64addr_string ( ndo , p ) ) ) ; p += 8 ; caplen -= 8 ; hdrlen += 8 ; break ; } if ( ! ndo -> ndo_suppress_default_print ) ND_DEFAULTPRINT ( p , caplen ) ; return hdrlen ; }
","<S2SV_ModStart> ndo , p <S2SV_ModEnd> ) ) )
"
636,"CWE-252 IHEVCD_ERROR_T ihevcd_parse_slice_header ( codec_t * ps_codec , nal_header_t * ps_nal ) { IHEVCD_ERROR_T ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; WORD32 value ; WORD32 i ; WORD32 sps_id ; pps_t * ps_pps ; sps_t * ps_sps ; slice_header_t * ps_slice_hdr ; WORD32 disable_deblocking_filter_flag ; bitstrm_t * ps_bitstrm = & ps_codec -> s_parse . s_bitstrm ; WORD32 idr_pic_flag ; WORD32 pps_id ; WORD32 first_slice_in_pic_flag ; WORD32 no_output_of_prior_pics_flag = 0 ; WORD8 i1_nal_unit_type = ps_nal -> i1_nal_unit_type ; WORD32 num_poc_total_curr = 0 ; WORD32 slice_address ; if ( ps_codec -> i4_slice_error == 1 ) return ret ; idr_pic_flag = ( NAL_IDR_W_LP == i1_nal_unit_type ) || ( NAL_IDR_N_LP == i1_nal_unit_type ) ; BITS_PARSE ( ""first_slice_in_pic_flag"" , first_slice_in_pic_flag , ps_bitstrm , 1 ) ; if ( ( NAL_BLA_W_LP <= i1_nal_unit_type ) && ( NAL_RSV_RAP_VCL23 >= i1_nal_unit_type ) ) { BITS_PARSE ( ""no_output_of_prior_pics_flag"" , no_output_of_prior_pics_flag , ps_bitstrm , 1 ) ; } UEV_PARSE ( ""pic_parameter_set_id"" , pps_id , ps_bitstrm ) ; pps_id = CLIP3 ( pps_id , 0 , MAX_PPS_CNT - 2 ) ; ps_pps = ps_codec -> s_parse . ps_pps_base + pps_id ; if ( 0 == ps_pps -> i1_pps_valid ) { pps_t * ps_pps_ref = ps_codec -> ps_pps_base ; while ( 0 == ps_pps_ref -> i1_pps_valid ) ps_pps_ref ++ ; if ( ( ps_pps_ref - ps_codec -> ps_pps_base >= MAX_PPS_CNT - 1 ) ) return IHEVCD_INVALID_HEADER ; ihevcd_copy_pps ( ps_codec , pps_id , ps_pps_ref -> i1_pps_id ) ; } sps_id = ps_pps -> i1_sps_id ; ps_sps = ps_codec -> s_parse . ps_sps_base + sps_id ; if ( ( 0 != ps_codec -> u4_pic_cnt || ps_codec -> i4_pic_present ) && first_slice_in_pic_flag ) { if ( ps_codec -> i4_pic_present ) { slice_header_t * ps_slice_hdr_next ; ps_codec -> i4_slice_error = 1 ; ps_codec -> s_parse . i4_cur_slice_idx -- ; if ( ps_codec -> s_parse . i4_cur_slice_idx < 0 ) ps_codec -> s_parse . i4_cur_slice_idx = 0 ; ps_slice_hdr_next = ps_codec -> s_parse . ps_slice_hdr_base + ( ( ps_codec -> s_parse . i4_cur_slice_idx + 1 ) & ( MAX_SLICE_HDR_CNT - 1 ) ) ; ps_slice_hdr_next -> i2_ctb_x = 0 ; ps_slice_hdr_next -> i2_ctb_y = ps_codec -> s_parse . ps_sps -> i2_pic_ht_in_ctb ; return ret ; } else { ps_codec -> i4_slice_error = 0 ; } } if ( first_slice_in_pic_flag ) { ps_codec -> s_parse . i4_cur_slice_idx = 0 ; } else { if ( 0 == ps_codec -> i4_pic_present ) ps_codec -> s_parse . i4_cur_slice_idx = 1 ; } ps_slice_hdr = ps_codec -> s_parse . ps_slice_hdr_base + ( ps_codec -> s_parse . i4_cur_slice_idx & ( MAX_SLICE_HDR_CNT - 1 ) ) ; if ( ( ps_pps -> i1_dependent_slice_enabled_flag ) && ( ! first_slice_in_pic_flag ) ) { BITS_PARSE ( ""dependent_slice_flag"" , value , ps_bitstrm , 1 ) ; if ( value && ( ps_codec -> s_parse . i4_cur_slice_idx > 0 ) ) { ihevcd_copy_slice_hdr ( ps_codec , ( ps_codec -> s_parse . i4_cur_slice_idx & ( MAX_SLICE_HDR_CNT - 1 ) ) , ( ( ps_codec -> s_parse . i4_cur_slice_idx - 1 ) & ( MAX_SLICE_HDR_CNT - 1 ) ) ) ; } ps_slice_hdr -> i1_dependent_slice_flag = value ; } else { ps_slice_hdr -> i1_dependent_slice_flag = 0 ; } ps_slice_hdr -> i1_nal_unit_type = i1_nal_unit_type ; ps_slice_hdr -> i1_pps_id = pps_id ; ps_slice_hdr -> i1_first_slice_in_pic_flag = first_slice_in_pic_flag ; ps_slice_hdr -> i1_no_output_of_prior_pics_flag = 1 ; if ( ( NAL_BLA_W_LP <= i1_nal_unit_type ) && ( NAL_RSV_RAP_VCL23 >= i1_nal_unit_type ) ) { ps_slice_hdr -> i1_no_output_of_prior_pics_flag = no_output_of_prior_pics_flag ; } ps_slice_hdr -> i1_pps_id = pps_id ; if ( ! ps_slice_hdr -> i1_first_slice_in_pic_flag ) { WORD32 num_bits ; num_bits = 32 - CLZ ( ps_sps -> i4_pic_size_in_ctb - 1 ) ; BITS_PARSE ( ""slice_address"" , value , ps_bitstrm , num_bits ) ; slice_address = value ; if ( value >= ps_sps -> i4_pic_size_in_ctb ) return IHEVCD_IGNORE_SLICE ; } else { slice_address = 0 ; } if ( ! ps_slice_hdr -> i1_dependent_slice_flag ) { ps_slice_hdr -> i1_pic_output_flag = 1 ; ps_slice_hdr -> i4_pic_order_cnt_lsb = 0 ; ps_slice_hdr -> i1_num_long_term_sps = 0 ; ps_slice_hdr -> i1_num_long_term_pics = 0 ; for ( i = 0 ; i < ps_pps -> i1_num_extra_slice_header_bits ; i ++ ) { BITS_PARSE ( ""slice_reserved_undetermined_flag[<S2SV_blank>i<S2SV_blank>]"" , value , ps_bitstrm , 1 ) ; } UEV_PARSE ( ""slice_type"" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_slice_type = value ; if ( ( ps_slice_hdr -> i1_nal_unit_type >= NAL_BLA_W_LP ) && ( ps_slice_hdr -> i1_nal_unit_type <= NAL_RSV_RAP_VCL23 ) ) ps_slice_hdr -> i1_slice_type = ISLICE ; if ( ( ps_slice_hdr -> i1_slice_type < 0 ) || ( ps_slice_hdr -> i1_slice_type > 2 ) ) return IHEVCD_IGNORE_SLICE ; if ( ps_pps -> i1_output_flag_present_flag ) { BITS_PARSE ( ""pic_output_flag"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_pic_output_flag = value ; } ps_slice_hdr -> i1_colour_plane_id = 0 ; if ( 1 == ps_sps -> i1_separate_colour_plane_flag ) { BITS_PARSE ( ""colour_plane_id"" , value , ps_bitstrm , 2 ) ; ps_slice_hdr -> i1_colour_plane_id = value ; } ps_slice_hdr -> i1_slice_temporal_mvp_enable_flag = 0 ; if ( ! idr_pic_flag ) { WORD32 st_rps_idx ; WORD32 num_neg_pics ; WORD32 num_pos_pics ; WORD8 * pi1_used ; BITS_PARSE ( ""pic_order_cnt_lsb"" , value , ps_bitstrm , ps_sps -> i1_log2_max_pic_order_cnt_lsb ) ; ps_slice_hdr -> i4_pic_order_cnt_lsb = value ; BITS_PARSE ( ""short_term_ref_pic_set_sps_flag"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_short_term_ref_pic_set_sps_flag = value ; if ( 1 == ps_slice_hdr -> i1_short_term_ref_pic_set_sps_flag ) { WORD32 numbits ; ps_slice_hdr -> i1_short_term_ref_pic_set_idx = 0 ; if ( ps_sps -> i1_num_short_term_ref_pic_sets > 1 ) { numbits = 32 - CLZ ( ps_sps -> i1_num_short_term_ref_pic_sets - 1 ) ; BITS_PARSE ( ""short_term_ref_pic_set_idx"" , value , ps_bitstrm , numbits ) ; ps_slice_hdr -> i1_short_term_ref_pic_set_idx = value ; } st_rps_idx = ps_slice_hdr -> i1_short_term_ref_pic_set_idx ; num_neg_pics = ps_sps -> as_stref_picset [ st_rps_idx ] . i1_num_neg_pics ; num_pos_pics = ps_sps -> as_stref_picset [ st_rps_idx ] . i1_num_pos_pics ; pi1_used = ps_sps -> as_stref_picset [ st_rps_idx ] . ai1_used ; } else { ihevcd_short_term_ref_pic_set ( ps_bitstrm , & ps_sps -> as_stref_picset [ 0 ] , ps_sps -> i1_num_short_term_ref_pic_sets , ps_sps -> i1_num_short_term_ref_pic_sets , & ps_slice_hdr -> s_stref_picset ) ; st_rps_idx = ps_sps -> i1_num_short_term_ref_pic_sets ; num_neg_pics = ps_slice_hdr -> s_stref_picset . i1_num_neg_pics ; num_pos_pics = ps_slice_hdr -> s_stref_picset . i1_num_pos_pics ; pi1_used = ps_slice_hdr -> s_stref_picset . ai1_used ; } if ( ps_sps -> i1_long_term_ref_pics_present_flag ) { if ( ps_sps -> i1_num_long_term_ref_pics_sps > 0 ) { UEV_PARSE ( ""num_long_term_sps"" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_num_long_term_sps = value ; ps_slice_hdr -> i1_num_long_term_sps = CLIP3 ( ps_slice_hdr -> i1_num_long_term_sps , 0 , MAX_DPB_SIZE - num_neg_pics - num_pos_pics ) ; } UEV_PARSE ( ""num_long_term_pics"" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_num_long_term_pics = value ; ps_slice_hdr -> i1_num_long_term_pics = CLIP3 ( ps_slice_hdr -> i1_num_long_term_pics , 0 , MAX_DPB_SIZE - num_neg_pics - num_pos_pics - ps_slice_hdr -> i1_num_long_term_sps ) ; for ( i = 0 ; i < ( ps_slice_hdr -> i1_num_long_term_sps + ps_slice_hdr -> i1_num_long_term_pics ) ; i ++ ) { if ( i < ps_slice_hdr -> i1_num_long_term_sps ) { WORD32 num_bits = 32 - CLZ ( ps_sps -> i1_num_long_term_ref_pics_sps ) ; BITS_PARSE ( ""lt_idx_sps[<S2SV_blank>i<S2SV_blank>]"" , value , ps_bitstrm , num_bits ) ; ps_slice_hdr -> ai4_poc_lsb_lt [ i ] = ps_sps -> ai1_lt_ref_pic_poc_lsb_sps [ value ] ; ps_slice_hdr -> ai1_used_by_curr_pic_lt_flag [ i ] = ps_sps -> ai1_used_by_curr_pic_lt_sps_flag [ value ] ; } else { BITS_PARSE ( ""poc_lsb_lt[<S2SV_blank>i<S2SV_blank>]"" , value , ps_bitstrm , ps_sps -> i1_log2_max_pic_order_cnt_lsb ) ; ps_slice_hdr -> ai4_poc_lsb_lt [ i ] = value ; BITS_PARSE ( ""used_by_curr_pic_lt_flag[<S2SV_blank>i<S2SV_blank>]"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> ai1_used_by_curr_pic_lt_flag [ i ] = value ; } BITS_PARSE ( ""delta_poc_msb_present_flag[<S2SV_blank>i<S2SV_blank>]"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> ai1_delta_poc_msb_present_flag [ i ] = value ; ps_slice_hdr -> ai1_delta_poc_msb_cycle_lt [ i ] = 0 ; if ( ps_slice_hdr -> ai1_delta_poc_msb_present_flag [ i ] ) { UEV_PARSE ( ""delata_poc_msb_cycle_lt[<S2SV_blank>i<S2SV_blank>]"" , value , ps_bitstrm ) ; ps_slice_hdr -> ai1_delta_poc_msb_cycle_lt [ i ] = value ; } if ( ( i != 0 ) && ( i != ps_slice_hdr -> i1_num_long_term_sps ) ) { ps_slice_hdr -> ai1_delta_poc_msb_cycle_lt [ i ] += ps_slice_hdr -> ai1_delta_poc_msb_cycle_lt [ i - 1 ] ; } } } for ( i = 0 ; i < num_neg_pics + num_pos_pics ; i ++ ) { if ( pi1_used [ i ] ) { num_poc_total_curr ++ ; } } for ( i = 0 ; i < ps_slice_hdr -> i1_num_long_term_sps + ps_slice_hdr -> i1_num_long_term_pics ; i ++ ) { if ( ps_slice_hdr -> ai1_used_by_curr_pic_lt_flag [ i ] ) { num_poc_total_curr ++ ; } } if ( ps_sps -> i1_sps_temporal_mvp_enable_flag ) { BITS_PARSE ( ""enable_temporal_mvp_flag"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_slice_temporal_mvp_enable_flag = value ; } } ps_slice_hdr -> i1_slice_sao_luma_flag = 0 ; ps_slice_hdr -> i1_slice_sao_chroma_flag = 0 ; if ( ps_sps -> i1_sample_adaptive_offset_enabled_flag ) { BITS_PARSE ( ""slice_sao_luma_flag"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_slice_sao_luma_flag = value ; BITS_PARSE ( ""slice_sao_chroma_flag"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_slice_sao_chroma_flag = value ; } ps_slice_hdr -> i1_max_num_merge_cand = 1 ; ps_slice_hdr -> i1_cabac_init_flag = 0 ; ps_slice_hdr -> i1_num_ref_idx_l0_active = 0 ; ps_slice_hdr -> i1_num_ref_idx_l1_active = 0 ; ps_slice_hdr -> i1_slice_cb_qp_offset = 0 ; ps_slice_hdr -> i1_slice_cr_qp_offset = 0 ; if ( ( PSLICE == ps_slice_hdr -> i1_slice_type ) || ( BSLICE == ps_slice_hdr -> i1_slice_type ) ) { BITS_PARSE ( ""num_ref_idx_active_override_flag"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_num_ref_idx_active_override_flag = value ; if ( ps_slice_hdr -> i1_num_ref_idx_active_override_flag ) { UEV_PARSE ( ""num_ref_idx_l0_active_minus1"" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_num_ref_idx_l0_active = value + 1 ; if ( BSLICE == ps_slice_hdr -> i1_slice_type ) { UEV_PARSE ( ""num_ref_idx_l1_active_minus1"" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_num_ref_idx_l1_active = value + 1 ; } } else { ps_slice_hdr -> i1_num_ref_idx_l0_active = ps_pps -> i1_num_ref_idx_l0_default_active ; if ( BSLICE == ps_slice_hdr -> i1_slice_type ) { ps_slice_hdr -> i1_num_ref_idx_l1_active = ps_pps -> i1_num_ref_idx_l1_default_active ; } } ps_slice_hdr -> i1_num_ref_idx_l0_active = CLIP3 ( ps_slice_hdr -> i1_num_ref_idx_l0_active , 0 , MAX_DPB_SIZE - 1 ) ; ps_slice_hdr -> i1_num_ref_idx_l1_active = CLIP3 ( ps_slice_hdr -> i1_num_ref_idx_l1_active , 0 , MAX_DPB_SIZE - 1 ) ; if ( 0 == num_poc_total_curr ) return IHEVCD_IGNORE_SLICE ; if ( ( ps_pps -> i1_lists_modification_present_flag ) && ( num_poc_total_curr > 1 ) ) { ihevcd_ref_pic_list_modification ( ps_bitstrm , ps_slice_hdr , num_poc_total_curr ) ; } else { ps_slice_hdr -> s_rplm . i1_ref_pic_list_modification_flag_l0 = 0 ; ps_slice_hdr -> s_rplm . i1_ref_pic_list_modification_flag_l1 = 0 ; } if ( BSLICE == ps_slice_hdr -> i1_slice_type ) { BITS_PARSE ( ""mvd_l1_zero_flag"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_mvd_l1_zero_flag = value ; } ps_slice_hdr -> i1_cabac_init_flag = 0 ; if ( ps_pps -> i1_cabac_init_present_flag ) { BITS_PARSE ( ""cabac_init_flag"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_cabac_init_flag = value ; } ps_slice_hdr -> i1_collocated_from_l0_flag = 1 ; ps_slice_hdr -> i1_collocated_ref_idx = 0 ; if ( ps_slice_hdr -> i1_slice_temporal_mvp_enable_flag ) { if ( BSLICE == ps_slice_hdr -> i1_slice_type ) { BITS_PARSE ( ""collocated_from_l0_flag"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_collocated_from_l0_flag = value ; } if ( ( ps_slice_hdr -> i1_collocated_from_l0_flag && ( ps_slice_hdr -> i1_num_ref_idx_l0_active > 1 ) ) || ( ! ps_slice_hdr -> i1_collocated_from_l0_flag && ( ps_slice_hdr -> i1_num_ref_idx_l1_active > 1 ) ) ) { UEV_PARSE ( ""collocated_ref_idx"" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_collocated_ref_idx = value ; } } ps_slice_hdr -> i1_collocated_ref_idx = CLIP3 ( ps_slice_hdr -> i1_collocated_ref_idx , 0 , MAX_DPB_SIZE - 1 ) ; if ( ( ps_pps -> i1_weighted_pred_flag && ( PSLICE == ps_slice_hdr -> i1_slice_type ) ) || ( ps_pps -> i1_weighted_bipred_flag && ( BSLICE == ps_slice_hdr -> i1_slice_type ) ) ) { ihevcd_parse_pred_wt_ofst ( ps_bitstrm , ps_sps , ps_pps , ps_slice_hdr ) ; } UEV_PARSE ( ""five_minus_max_num_merge_cand"" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_max_num_merge_cand = 5 - value ; } ps_slice_hdr -> i1_max_num_merge_cand = CLIP3 ( ps_slice_hdr -> i1_max_num_merge_cand , 1 , 5 ) ; SEV_PARSE ( ""slice_qp_delta"" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_slice_qp_delta = value ; if ( ps_pps -> i1_pic_slice_level_chroma_qp_offsets_present_flag ) { SEV_PARSE ( ""slice_cb_qp_offset"" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_slice_cb_qp_offset = value ; SEV_PARSE ( ""slice_cr_qp_offset"" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_slice_cr_qp_offset = value ; } ps_slice_hdr -> i1_deblocking_filter_override_flag = 0 ; ps_slice_hdr -> i1_slice_disable_deblocking_filter_flag = ps_pps -> i1_pic_disable_deblocking_filter_flag ; ps_slice_hdr -> i1_beta_offset_div2 = ps_pps -> i1_beta_offset_div2 ; ps_slice_hdr -> i1_tc_offset_div2 = ps_pps -> i1_tc_offset_div2 ; disable_deblocking_filter_flag = ps_pps -> i1_pic_disable_deblocking_filter_flag ; if ( ps_pps -> i1_deblocking_filter_control_present_flag ) { if ( ps_pps -> i1_deblocking_filter_override_enabled_flag ) { BITS_PARSE ( ""deblocking_filter_override_flag"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_deblocking_filter_override_flag = value ; } if ( ps_slice_hdr -> i1_deblocking_filter_override_flag ) { BITS_PARSE ( ""slice_disable_deblocking_filter_flag"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_slice_disable_deblocking_filter_flag = value ; disable_deblocking_filter_flag = ps_slice_hdr -> i1_slice_disable_deblocking_filter_flag ; if ( ! ps_slice_hdr -> i1_slice_disable_deblocking_filter_flag ) { SEV_PARSE ( ""beta_offset_div2"" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_beta_offset_div2 = value ; SEV_PARSE ( ""tc_offset_div2"" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_tc_offset_div2 = value ; } } } ps_slice_hdr -> i1_slice_loop_filter_across_slices_enabled_flag = ps_pps -> i1_loop_filter_across_slices_enabled_flag ; if ( ps_pps -> i1_loop_filter_across_slices_enabled_flag && ( ps_slice_hdr -> i1_slice_sao_luma_flag || ps_slice_hdr -> i1_slice_sao_chroma_flag || ! disable_deblocking_filter_flag ) ) { BITS_PARSE ( ""slice_loop_filter_across_slices_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_slice_loop_filter_across_slices_enabled_flag = value ; } } if ( ( ! first_slice_in_pic_flag ) && ( ps_codec -> i4_pic_present ) ) { slice_header_t * ps_slice_hdr_base = ps_codec -> ps_slice_hdr_base ; if ( ( ps_slice_hdr_base -> i1_pps_id != ps_slice_hdr -> i1_pps_id ) || ( ps_slice_hdr_base -> i4_pic_order_cnt_lsb != ps_slice_hdr -> i4_pic_order_cnt_lsb ) ) { return IHEVCD_IGNORE_SLICE ; } } if ( 0 == ps_codec -> i4_pic_present ) { ps_slice_hdr -> i4_abs_pic_order_cnt = ihevcd_calc_poc ( ps_codec , ps_nal , ps_sps -> i1_log2_max_pic_order_cnt_lsb , ps_slice_hdr -> i4_pic_order_cnt_lsb ) ; } else { ps_slice_hdr -> i4_abs_pic_order_cnt = ps_codec -> s_parse . i4_abs_pic_order_cnt ; } if ( ! first_slice_in_pic_flag ) { if ( ps_codec -> s_parse . i4_abs_pic_order_cnt == ps_slice_hdr -> i4_abs_pic_order_cnt ) { if ( slice_address > ps_codec -> s_parse . i4_next_ctb_indx ) { if ( ps_codec -> i4_pic_present ) { ps_codec -> i4_slice_error = 1 ; ps_codec -> s_parse . i4_cur_slice_idx -- ; if ( ps_codec -> s_parse . i4_cur_slice_idx < 0 ) ps_codec -> s_parse . i4_cur_slice_idx = 0 ; return ret ; } else { return IHEVCD_IGNORE_SLICE ; } } else if ( slice_address < ps_codec -> s_parse . i4_next_ctb_indx ) { return IHEVCD_IGNORE_SLICE ; } else { ps_codec -> i4_slice_error = 0 ; } } else { if ( ps_codec -> i4_pic_present ) { slice_header_t * ps_slice_hdr_next ; ps_codec -> i4_slice_error = 1 ; ps_codec -> s_parse . i4_cur_slice_idx -- ; if ( ps_codec -> s_parse . i4_cur_slice_idx < 0 ) ps_codec -> s_parse . i4_cur_slice_idx = 0 ; ps_slice_hdr_next = ps_codec -> s_parse . ps_slice_hdr_base + ( ( ps_codec -> s_parse . i4_cur_slice_idx + 1 ) & ( MAX_SLICE_HDR_CNT - 1 ) ) ; ps_slice_hdr_next -> i2_ctb_x = 0 ; ps_slice_hdr_next -> i2_ctb_y = ps_codec -> s_parse . ps_sps -> i2_pic_ht_in_ctb ; return ret ; } else { if ( ps_slice_hdr -> i1_dependent_slice_flag ) return IHEVCD_IGNORE_SLICE ; ps_codec -> s_parse . i4_abs_pic_order_cnt = ps_slice_hdr -> i4_abs_pic_order_cnt ; } } } else { if ( ps_codec -> s_parse . i4_abs_pic_order_cnt == ps_slice_hdr -> i4_abs_pic_order_cnt ) return IHEVCD_IGNORE_SLICE ; ps_codec -> s_parse . i4_abs_pic_order_cnt = ps_slice_hdr -> i4_abs_pic_order_cnt ; } ps_slice_hdr -> i4_num_entry_point_offsets = 0 ; if ( ( ps_pps -> i1_tiles_enabled_flag ) || ( ps_pps -> i1_entropy_coding_sync_enabled_flag ) ) { UEV_PARSE ( ""num_entry_point_offsets"" , value , ps_bitstrm ) ; ps_slice_hdr -> i4_num_entry_point_offsets = value ; { WORD32 max_num_entry_point_offsets ; if ( ( ps_pps -> i1_tiles_enabled_flag ) && ( ps_pps -> i1_entropy_coding_sync_enabled_flag ) ) { max_num_entry_point_offsets = ps_pps -> i1_num_tile_columns * ( ps_sps -> i2_pic_ht_in_ctb - 1 ) ; } else if ( ps_pps -> i1_tiles_enabled_flag ) { max_num_entry_point_offsets = ps_pps -> i1_num_tile_columns * ps_pps -> i1_num_tile_rows ; } else { max_num_entry_point_offsets = ( ps_sps -> i2_pic_ht_in_ctb - 1 ) ; } ps_slice_hdr -> i4_num_entry_point_offsets = CLIP3 ( ps_slice_hdr -> i4_num_entry_point_offsets , 0 , max_num_entry_point_offsets ) ; } if ( ps_slice_hdr -> i4_num_entry_point_offsets > 0 ) { UEV_PARSE ( ""offset_len_minus1"" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_offset_len = value + 1 ; for ( i = 0 ; i < ps_slice_hdr -> i4_num_entry_point_offsets ; i ++ ) { BITS_PARSE ( ""entry_point_offset"" , value , ps_bitstrm , ps_slice_hdr -> i1_offset_len ) ; } } } if ( ps_pps -> i1_slice_header_extension_present_flag ) { UEV_PARSE ( ""slice_header_extension_length"" , value , ps_bitstrm ) ; ps_slice_hdr -> i2_slice_header_extension_length = value ; for ( i = 0 ; i < ps_slice_hdr -> i2_slice_header_extension_length ; i ++ ) { BITS_PARSE ( ""slice_header_extension_data_byte"" , value , ps_bitstrm , 8 ) ; } } ihevcd_bits_flush_to_byte_boundary ( ps_bitstrm ) ; { dpb_mgr_t * ps_dpb_mgr = ( dpb_mgr_t * ) ps_codec -> pv_dpb_mgr ; WORD32 r_idx ; if ( ( NAL_IDR_W_LP == ps_slice_hdr -> i1_nal_unit_type ) || ( NAL_IDR_N_LP == ps_slice_hdr -> i1_nal_unit_type ) || ( NAL_BLA_N_LP == ps_slice_hdr -> i1_nal_unit_type ) || ( NAL_BLA_W_DLP == ps_slice_hdr -> i1_nal_unit_type ) || ( NAL_BLA_W_LP == ps_slice_hdr -> i1_nal_unit_type ) || ( 0 == ps_codec -> u4_pic_cnt ) ) { for ( i = 0 ; i < MAX_DPB_BUFS ; i ++ ) { if ( ps_dpb_mgr -> as_dpb_info [ i ] . ps_pic_buf ) { pic_buf_t * ps_pic_buf = ps_dpb_mgr -> as_dpb_info [ i ] . ps_pic_buf ; mv_buf_t * ps_mv_buf ; ihevc_dpb_mgr_del_ref ( ( dpb_mgr_t * ) ps_codec -> pv_dpb_mgr , ( buf_mgr_t * ) ps_codec -> pv_pic_buf_mgr , ps_pic_buf -> i4_abs_poc ) ; ps_mv_buf = ( mv_buf_t * ) ps_codec -> ps_mv_buf ; for ( i = 0 ; i < BUF_MGR_MAX_CNT ; i ++ ) { if ( ps_mv_buf && ps_mv_buf -> i4_abs_poc == ps_pic_buf -> i4_abs_poc ) { ihevc_buf_mgr_release ( ( buf_mgr_t * ) ps_codec -> pv_mv_buf_mgr , i , BUF_MGR_REF ) ; break ; } ps_mv_buf ++ ; } } } for ( r_idx = 0 ; r_idx < MAX_DPB_SIZE ; r_idx ++ ) { ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_pic_buf = NULL ; ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_mv_buf = NULL ; ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_pic_buf = NULL ; ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_mv_buf = NULL ; } } else { <S2SV_StartBug> ihevcd_ref_list ( ps_codec , ps_pps , ps_sps , ps_slice_hdr ) ; <S2SV_EndBug> } } if ( ps_codec -> i4_pic_present ) { pic_buf_t * ps_pic_buf_ref ; mv_buf_t * ps_mv_buf_ref ; WORD32 r_idx ; dpb_mgr_t * ps_dpb_mgr = ( dpb_mgr_t * ) ps_codec -> pv_dpb_mgr ; buf_mgr_t * ps_mv_buf_mgr = ( buf_mgr_t * ) ps_codec -> pv_mv_buf_mgr ; ps_pic_buf_ref = ihevc_dpb_mgr_get_ref_by_nearest_poc ( ps_dpb_mgr , ps_slice_hdr -> i4_abs_pic_order_cnt ) ; if ( NULL == ps_pic_buf_ref ) { ps_pic_buf_ref = ps_codec -> as_process [ 0 ] . ps_cur_pic ; ps_mv_buf_ref = ps_codec -> s_parse . ps_cur_mv_buf ; } else { ps_mv_buf_ref = ihevcd_mv_mgr_get_poc ( ps_mv_buf_mgr , ps_pic_buf_ref -> i4_abs_poc ) ; } for ( r_idx = 0 ; r_idx < ps_slice_hdr -> i1_num_ref_idx_l0_active ; r_idx ++ ) { if ( NULL == ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_pic_buf ) { ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_pic_buf = ( void * ) ps_pic_buf_ref ; ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_mv_buf = ( void * ) ps_mv_buf_ref ; } } for ( r_idx = ps_slice_hdr -> i1_num_ref_idx_l0_active ; r_idx < MAX_DPB_SIZE ; r_idx ++ ) { ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_pic_buf = ( void * ) ps_pic_buf_ref ; ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_mv_buf = ( void * ) ps_mv_buf_ref ; } for ( r_idx = 0 ; r_idx < ps_slice_hdr -> i1_num_ref_idx_l1_active ; r_idx ++ ) { if ( NULL == ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_pic_buf ) { ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_pic_buf = ( void * ) ps_pic_buf_ref ; ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_mv_buf = ( void * ) ps_mv_buf_ref ; } } for ( r_idx = ps_slice_hdr -> i1_num_ref_idx_l1_active ; r_idx < MAX_DPB_SIZE ; r_idx ++ ) { ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_pic_buf = ( void * ) ps_pic_buf_ref ; ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_mv_buf = ( void * ) ps_mv_buf_ref ; } } if ( ! ps_slice_hdr -> i1_first_slice_in_pic_flag ) { ps_slice_hdr -> i2_ctb_x = slice_address % ps_sps -> i2_pic_wd_in_ctb ; ps_slice_hdr -> i2_ctb_y = slice_address / ps_sps -> i2_pic_wd_in_ctb ; if ( ! ps_slice_hdr -> i1_dependent_slice_flag ) { ps_slice_hdr -> i2_independent_ctb_x = ps_slice_hdr -> i2_ctb_x ; ps_slice_hdr -> i2_independent_ctb_y = ps_slice_hdr -> i2_ctb_y ; } } else { ps_slice_hdr -> i2_ctb_x = 0 ; ps_slice_hdr -> i2_ctb_y = 0 ; ps_slice_hdr -> i2_independent_ctb_x = 0 ; ps_slice_hdr -> i2_independent_ctb_y = 0 ; } if ( ( ! first_slice_in_pic_flag ) && ( 0 == ps_codec -> i4_pic_present ) ) { slice_header_t * ps_slice_hdr_prev = ps_codec -> s_parse . ps_slice_hdr_base ; ihevcd_copy_slice_hdr ( ps_codec , 0 , ( ps_codec -> s_parse . i4_cur_slice_idx & ( MAX_SLICE_HDR_CNT - 1 ) ) ) ; ps_codec -> i4_slice_error = 1 ; ps_slice_hdr_prev -> i2_ctb_x = 0 ; ps_slice_hdr_prev -> i2_ctb_y = 0 ; ps_codec -> s_parse . i4_ctb_x = 0 ; ps_codec -> s_parse . i4_ctb_y = 0 ; ps_codec -> s_parse . i4_cur_slice_idx = 0 ; if ( ( ps_slice_hdr -> i2_ctb_x == 0 ) && ( ps_slice_hdr -> i2_ctb_y == 0 ) ) { ps_slice_hdr -> i2_ctb_x ++ ; } } { if ( ( i1_nal_unit_type < NAL_BLA_W_LP ) && ( i1_nal_unit_type % 2 == 0 ) ) { if ( IVD_SKIP_B == ps_codec -> e_pic_skip_mode ) return IHEVCD_IGNORE_SLICE ; } if ( ( IVD_SKIP_PB == ps_codec -> e_pic_skip_mode ) && ( ISLICE != ps_slice_hdr -> i1_slice_type ) ) { return IHEVCD_IGNORE_SLICE ; } } return ret ; }
","<S2SV_ModStart> } else { ret = <S2SV_ModStart> ps_slice_hdr ) ; if ( ( WORD32 ) IHEVCD_SUCCESS != ret ) { return ret ; }
"
637,"CWE-665 int ParseCaffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { <S2SV_StartBug> uint32_t chan_chunk = 0 , channel_layout = 0 , bcount ; <S2SV_EndBug> unsigned char * channel_identities = NULL ; unsigned char * channel_reorder = NULL ; int64_t total_samples = 0 , infilesize ; CAFFileHeader caf_file_header ; CAFChunkHeader caf_chunk_header ; CAFAudioFormat caf_audio_format ; int i ; infilesize = DoGetFileSize ( infile ) ; memcpy ( & caf_file_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & caf_file_header ) + 4 , sizeof ( CAFFileHeader ) - 4 , & bcount ) || bcount != sizeof ( CAFFileHeader ) - 4 ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & caf_file_header , sizeof ( CAFFileHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & caf_file_header , CAFFileHeaderFormat ) ; if ( caf_file_header . mFileVersion != 1 ) { error_line ( ""%s:<S2SV_blank>can\'t<S2SV_blank>handle<S2SV_blank>version<S2SV_blank>%d<S2SV_blank>.CAF<S2SV_blank>files!"" , infilename , caf_file_header . mFileVersion ) ; return WAVPACK_SOFT_ERROR ; } while ( 1 ) { if ( ! DoReadFile ( infile , & caf_chunk_header , sizeof ( CAFChunkHeader ) , & bcount ) || bcount != sizeof ( CAFChunkHeader ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & caf_chunk_header , sizeof ( CAFChunkHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & caf_chunk_header , CAFChunkHeaderFormat ) ; if ( ! strncmp ( caf_chunk_header . mChunkType , ""desc"" , 4 ) ) { int supported = TRUE ; if ( caf_chunk_header . mChunkSize != sizeof ( CAFAudioFormat ) || ! DoReadFile ( infile , & caf_audio_format , ( uint32_t ) caf_chunk_header . mChunkSize , & bcount ) || bcount != caf_chunk_header . mChunkSize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & caf_audio_format , ( uint32_t ) caf_chunk_header . mChunkSize ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } <S2SV_StartBug> WavpackBigEndianToNative ( & caf_audio_format , CAFAudioFormatFormat ) ; <S2SV_EndBug> if ( debug_logging_mode ) { char formatstr [ 5 ] ; memcpy ( formatstr , caf_audio_format . mFormatID , 4 ) ; formatstr [ 4 ] = 0 ; error_line ( ""format<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>flags<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>sampling<S2SV_blank>rate<S2SV_blank>=<S2SV_blank>%g"" , formatstr , caf_audio_format . mFormatFlags , caf_audio_format . mSampleRate ) ; error_line ( ""packet<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>and<S2SV_blank>%d<S2SV_blank>frames"" , caf_audio_format . mBytesPerPacket , caf_audio_format . mFramesPerPacket ) ; error_line ( ""channels<S2SV_blank>per<S2SV_blank>frame<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>bits<S2SV_blank>per<S2SV_blank>channel<S2SV_blank>=<S2SV_blank>%d"" , caf_audio_format . mChannelsPerFrame , caf_audio_format . mBitsPerChannel ) ; } if ( strncmp ( caf_audio_format . mFormatID , ""lpcm"" , 4 ) || ( caf_audio_format . mFormatFlags & ~ 3 ) ) supported = FALSE ; else if ( caf_audio_format . mSampleRate < 1.0 || caf_audio_format . mSampleRate > 16777215.0 || caf_audio_format . mSampleRate != floor ( caf_audio_format . mSampleRate ) ) supported = FALSE ; else if ( ! caf_audio_format . mChannelsPerFrame || caf_audio_format . mChannelsPerFrame > 256 ) supported = FALSE ; else if ( caf_audio_format . mBitsPerChannel < 1 || caf_audio_format . mBitsPerChannel > 32 || ( ( caf_audio_format . mFormatFlags & CAF_FORMAT_FLOAT ) && caf_audio_format . mBitsPerChannel != 32 ) ) supported = FALSE ; else if ( caf_audio_format . mFramesPerPacket != 1 || caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame < ( caf_audio_format . mBitsPerChannel + 7 ) / 8 || caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame > 4 || caf_audio_format . mBytesPerPacket % caf_audio_format . mChannelsPerFrame ) supported = FALSE ; if ( ! supported ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>an<S2SV_blank>unsupported<S2SV_blank>.CAF<S2SV_blank>format!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } config -> bytes_per_sample = caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame ; config -> float_norm_exp = ( caf_audio_format . mFormatFlags & CAF_FORMAT_FLOAT ) ? 127 : 0 ; config -> bits_per_sample = caf_audio_format . mBitsPerChannel ; config -> num_channels = caf_audio_format . mChannelsPerFrame ; config -> sample_rate = ( int ) caf_audio_format . mSampleRate ; if ( ! ( caf_audio_format . mFormatFlags & CAF_FORMAT_LITTLE_ENDIAN ) && config -> bytes_per_sample > 1 ) config -> qmode |= QMODE_BIG_ENDIAN ; if ( config -> bytes_per_sample == 1 ) config -> qmode |= QMODE_SIGNED_BYTES ; if ( debug_logging_mode ) { if ( config -> float_norm_exp == 127 ) error_line ( ""data<S2SV_blank>format:<S2SV_blank>32-bit<S2SV_blank>%s-endian<S2SV_blank>floating<S2SV_blank>point"" , ( config -> qmode & QMODE_BIG_ENDIAN ) ? ""big"" : ""little"" ) ; else error_line ( ""data<S2SV_blank>format:<S2SV_blank>%d-bit<S2SV_blank>%s-endian<S2SV_blank>integers<S2SV_blank>stored<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>byte(s)"" , config -> bits_per_sample , ( config -> qmode & QMODE_BIG_ENDIAN ) ? ""big"" : ""little"" , config -> bytes_per_sample ) ; } } else if ( ! strncmp ( caf_chunk_header . mChunkType , ""chan"" , 4 ) ) { CAFChannelLayout * caf_channel_layout ; if ( caf_chunk_header . mChunkSize < 0 || caf_chunk_header . mChunkSize > 1024 || caf_chunk_header . mChunkSize < sizeof ( CAFChannelLayout ) ) { error_line ( ""this<S2SV_blank>.CAF<S2SV_blank>file<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>\'chan\'<S2SV_blank>chunk!"" ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( ""\'chan\'<S2SV_blank>chunk<S2SV_blank>is<S2SV_blank>%d<S2SV_blank>bytes"" , ( int ) caf_chunk_header . mChunkSize ) ; caf_channel_layout = malloc ( ( size_t ) caf_chunk_header . mChunkSize ) ; if ( ! DoReadFile ( infile , caf_channel_layout , ( uint32_t ) caf_chunk_header . mChunkSize , & bcount ) || bcount != caf_chunk_header . mChunkSize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!"" , infilename ) ; free ( caf_channel_layout ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , caf_channel_layout , ( uint32_t ) caf_chunk_header . mChunkSize ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( caf_channel_layout ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( caf_channel_layout , CAFChannelLayoutFormat ) ; chan_chunk = 1 ; if ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) { error_line ( ""this<S2SV_blank>CAF<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!"" ) ; free ( caf_channel_layout ) ; return WAVPACK_SOFT_ERROR ; } switch ( caf_channel_layout -> mChannelLayoutTag ) { case kCAFChannelLayoutTag_UseChannelDescriptions : { CAFChannelDescription * descriptions = ( CAFChannelDescription * ) ( caf_channel_layout + 1 ) ; int num_descriptions = caf_channel_layout -> mNumberChannelDescriptions ; int label , cindex = 0 , idents = 0 ; if ( caf_chunk_header . mChunkSize != sizeof ( CAFChannelLayout ) + sizeof ( CAFChannelDescription ) * num_descriptions || num_descriptions != config -> num_channels ) { error_line ( ""channel<S2SV_blank>descriptions<S2SV_blank>in<S2SV_blank>\'chan\'<S2SV_blank>chunk<S2SV_blank>are<S2SV_blank>the<S2SV_blank>wrong<S2SV_blank>size!"" ) ; free ( caf_channel_layout ) ; return WAVPACK_SOFT_ERROR ; } if ( num_descriptions >= 256 ) { error_line ( ""%d<S2SV_blank>channel<S2SV_blank>descriptions<S2SV_blank>is<S2SV_blank>more<S2SV_blank>than<S2SV_blank>we<S2SV_blank>can<S2SV_blank>handle...ignoring!"" ) ; break ; } channel_reorder = malloc ( num_descriptions ) ; memset ( channel_reorder , - 1 , num_descriptions ) ; channel_identities = malloc ( num_descriptions + 1 ) ; for ( i = 0 ; i < num_descriptions ; ++ i ) { WavpackBigEndianToNative ( descriptions + i , CAFChannelDescriptionFormat ) ; if ( debug_logging_mode ) error_line ( ""chan<S2SV_blank>%d<S2SV_blank>--><S2SV_blank>%d"" , i + 1 , descriptions [ i ] . mChannelLabel ) ; } for ( label = 1 ; label <= 18 ; ++ label ) for ( i = 0 ; i < num_descriptions ; ++ i ) if ( descriptions [ i ] . mChannelLabel == label ) { config -> channel_mask |= 1 << ( label - 1 ) ; channel_reorder [ i ] = cindex ++ ; break ; } for ( i = 0 ; i < num_descriptions ; ++ i ) if ( channel_reorder [ i ] == ( unsigned char ) - 1 ) { uint32_t clabel = descriptions [ i ] . mChannelLabel ; if ( clabel == 0 || clabel == 0xffffffff || clabel == 100 ) channel_identities [ idents ++ ] = 0xff ; else if ( ( clabel >= 33 && clabel <= 44 ) || ( clabel >= 200 && clabel <= 207 ) || ( clabel >= 301 && clabel <= 305 ) ) channel_identities [ idents ++ ] = clabel >= 301 ? clabel - 80 : clabel ; else { error_line ( ""warning:<S2SV_blank>unknown<S2SV_blank>channel<S2SV_blank>descriptions<S2SV_blank>label:<S2SV_blank>%d"" , clabel ) ; channel_identities [ idents ++ ] = 0xff ; } channel_reorder [ i ] = cindex ++ ; } for ( i = 0 ; i < num_descriptions ; ++ i ) if ( channel_reorder [ i ] != i ) break ; if ( i == num_descriptions ) { free ( channel_reorder ) ; channel_reorder = NULL ; } else { config -> qmode |= QMODE_REORDERED_CHANS ; channel_layout = num_descriptions ; } if ( ! idents ) { free ( channel_identities ) ; channel_identities = NULL ; } else channel_identities [ idents ] = 0 ; if ( debug_logging_mode ) { error_line ( ""layout_tag<S2SV_blank>=<S2SV_blank>0x%08x,<S2SV_blank>so<S2SV_blank>generated<S2SV_blank>bitmap<S2SV_blank>of<S2SV_blank>0x%08x<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>descriptions,<S2SV_blank>%d<S2SV_blank>non-MS"" , caf_channel_layout -> mChannelLayoutTag , config -> channel_mask , caf_channel_layout -> mNumberChannelDescriptions , idents ) ; if ( channel_reorder && num_descriptions <= 8 ) { char reorder_string [ ] = ""12345678"" ; for ( i = 0 ; i < num_descriptions ; ++ i ) reorder_string [ i ] = channel_reorder [ i ] + '1' ; reorder_string [ i ] = 0 ; error_line ( ""reordering<S2SV_blank>string<S2SV_blank>=<S2SV_blank>\\""%s\\""\\n"" , reorder_string ) ; } } } break ; case kCAFChannelLayoutTag_UseChannelBitmap : config -> channel_mask = caf_channel_layout -> mChannelBitmap ; if ( debug_logging_mode ) error_line ( ""layout_tag<S2SV_blank>=<S2SV_blank>0x%08x,<S2SV_blank>so<S2SV_blank>using<S2SV_blank>supplied<S2SV_blank>bitmap<S2SV_blank>of<S2SV_blank>0x%08x"" , caf_channel_layout -> mChannelLayoutTag , caf_channel_layout -> mChannelBitmap ) ; break ; default : for ( i = 0 ; i < NUM_LAYOUTS ; ++ i ) if ( caf_channel_layout -> mChannelLayoutTag == layouts [ i ] . mChannelLayoutTag ) { config -> channel_mask = layouts [ i ] . mChannelBitmap ; channel_layout = layouts [ i ] . mChannelLayoutTag ; if ( layouts [ i ] . mChannelReorder ) { channel_reorder = ( unsigned char * ) strdup ( layouts [ i ] . mChannelReorder ) ; config -> qmode |= QMODE_REORDERED_CHANS ; } if ( layouts [ i ] . mChannelIdentities ) channel_identities = ( unsigned char * ) strdup ( layouts [ i ] . mChannelIdentities ) ; if ( debug_logging_mode ) error_line ( ""layout_tag<S2SV_blank>0x%08x<S2SV_blank>found<S2SV_blank>in<S2SV_blank>table,<S2SV_blank>bitmap<S2SV_blank>=<S2SV_blank>0x%08x,<S2SV_blank>reorder<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>identities<S2SV_blank>=<S2SV_blank>%s"" , channel_layout , config -> channel_mask , channel_reorder ? ""yes"" : ""no"" , channel_identities ? ""yes"" : ""no"" ) ; break ; } if ( i == NUM_LAYOUTS && debug_logging_mode ) error_line ( ""layout_tag<S2SV_blank>0x%08x<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>table...all<S2SV_blank>channels<S2SV_blank>unassigned"" , caf_channel_layout -> mChannelLayoutTag ) ; break ; } free ( caf_channel_layout ) ; } else if ( ! strncmp ( caf_chunk_header . mChunkType , ""data"" , 4 ) ) { uint32_t mEditCount ; <S2SV_StartBug> if ( ! DoReadFile ( infile , & mEditCount , sizeof ( mEditCount ) , & bcount ) || <S2SV_EndBug> bcount != sizeof ( mEditCount ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & mEditCount , sizeof ( mEditCount ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } if ( ( config -> qmode & QMODE_IGNORE_LENGTH ) || caf_chunk_header . mChunkSize == - 1 ) { config -> qmode |= QMODE_IGNORE_LENGTH ; if ( infilesize && DoGetFilePosition ( infile ) != - 1 ) total_samples = ( infilesize - DoGetFilePosition ( infile ) ) / caf_audio_format . mBytesPerPacket ; else total_samples = - 1 ; } else { if ( infilesize && infilesize - caf_chunk_header . mChunkSize > 16777216 ) { error_line ( "".CAF<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>over<S2SV_blank>16<S2SV_blank>MB<S2SV_blank>of<S2SV_blank>extra<S2SV_blank>CAFF<S2SV_blank>data,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( ( caf_chunk_header . mChunkSize - 4 ) % caf_audio_format . mBytesPerPacket ) { error_line ( "".CAF<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>data<S2SV_blank>chunk<S2SV_blank>size,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } total_samples = ( caf_chunk_header . mChunkSize - 4 ) / caf_audio_format . mBytesPerPacket ; if ( ! total_samples ) { error_line ( ""this<S2SV_blank>.CAF<S2SV_blank>file<S2SV_blank>has<S2SV_blank>no<S2SV_blank>audio<S2SV_blank>samples,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" ) ; return WAVPACK_SOFT_ERROR ; } if ( total_samples > MAX_WAVPACK_SAMPLES ) { error_line ( ""%s<S2SV_blank>has<S2SV_blank>too<S2SV_blank>many<S2SV_blank>samples<S2SV_blank>for<S2SV_blank>WavPack!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } } break ; } else { uint32_t bytes_to_copy = ( uint32_t ) caf_chunk_header . mChunkSize ; char * buff ; if ( caf_chunk_header . mChunkSize < 0 || caf_chunk_header . mChunkSize > 1048576 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff = malloc ( bytes_to_copy ) ; if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , caf_chunk_header . mChunkType [ 0 ] , caf_chunk_header . mChunkType [ 1 ] , caf_chunk_header . mChunkType [ 2 ] , caf_chunk_header . mChunkType [ 3 ] , caf_chunk_header . mChunkSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( ! chan_chunk && ! config -> channel_mask && config -> num_channels <= 2 && ! ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) config -> channel_mask = 0x5 - config -> num_channels ; if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , channel_identities ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } if ( channel_identities ) free ( channel_identities ) ; if ( channel_layout || channel_reorder ) { if ( ! WavpackSetChannelLayout ( wpc , channel_layout , channel_reorder ) ) { error_line ( ""problem<S2SV_blank>with<S2SV_blank>setting<S2SV_blank>channel<S2SV_blank>layout<S2SV_blank>(should<S2SV_blank>not<S2SV_blank>happen)"" ) ; return WAVPACK_SOFT_ERROR ; } if ( channel_reorder ) free ( channel_reorder ) ; } return WAVPACK_NO_ERROR ; }
","<S2SV_ModStart> { uint32_t chan_chunk = 0 , desc_chunk <S2SV_ModStart> , CAFAudioFormatFormat ) ; desc_chunk = 1 <S2SV_ModStart> if ( ! desc_chunk || !
"
638,"CWE-119 static void test_function ( char * ( * my_asnprintf ) ( char * , size_t * , const char * , ... ) ) { char buf [ 8 ] ; int size ; for ( size = 0 ; size <= 8 ; size ++ ) { size_t length = size ; char * result = my_asnprintf ( NULL , & length , ""%d"" , 12345 ) ; ASSERT ( result != NULL ) ; ASSERT ( strcmp ( result , ""12345"" ) == 0 ) ; ASSERT ( length == 5 ) ; free ( result ) ; } for ( size = 0 ; size <= 8 ; size ++ ) { size_t length ; char * result ; memcpy ( buf , ""DEADBEEF"" , 8 ) ; length = size ; result = my_asnprintf ( buf , & length , ""%d"" , 12345 ) ; ASSERT ( result != NULL ) ; ASSERT ( strcmp ( result , ""12345"" ) == 0 ) ; ASSERT ( length == 5 ) ; <S2SV_StartBug> if ( size < 6 ) <S2SV_EndBug> ASSERT ( result != buf ) ; ASSERT ( memcmp ( buf + size , & ""DEADBEEF"" [ size ] , 8 - size ) == 0 ) ; if ( result != buf ) free ( result ) ; } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> ( size < 5 + 1 <S2SV_ModEnd> ) ASSERT ( <S2SV_ModStart> ) ; } for ( size = 0 ; size <= 8 ; size ++ ) { size_t length ; char * result ; memcpy ( buf , ""DEADBEEF"" , 8 ) ; length = size ; result = my_asnprintf ( buf , & length , ""%2.0f"" , 1.6314159265358979e+125 ) ; ASSERT ( result != NULL ) ; ASSERT ( strcmp ( result , ""163141592653589790215729350939528493057529598899734151772468186268423257777068536614838678161083520756952076273094236944990208"" ) == 0 ) ; ASSERT ( length == 126 ) ; if ( size < 126 + 1 ) ASSERT ( result != buf ) ; ASSERT ( memcmp ( buf + size , & ""DEADBEEF"" [ size ] , 8 - size ) == 0 ) ; if ( result != buf ) free ( result ) ; }
"
639,"CWE-125 static void ubik_print ( netdissect_options * ndo , register const u_char * bp ) { int ubik_op ; int32_t temp ; ubik_op = EXTRACT_32BITS ( bp + sizeof ( struct rx_header ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>ubik<S2SV_blank>call<S2SV_blank>%s"" , tok2str ( ubik_req , ""op#%d"" , ubik_op ) ) ) ; bp += sizeof ( struct rx_header ) + 4 ; switch ( ubik_op ) { case 10000 : ND_TCHECK2 ( bp [ 0 ] , 4 ) ; temp = EXTRACT_32BITS ( bp ) ; bp += sizeof ( int32_t ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>syncsite<S2SV_blank>%s"" , temp ? ""yes"" : ""no"" ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>votestart"" ) ) ; DATEOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>dbversion"" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>tid"" ) ) ; UBIK_VERSIONOUT ( ) ; break ; case 10003 : ND_PRINT ( ( ndo , ""<S2SV_blank>site"" ) ) ; UINTOUT ( ) ; break ; case 20000 : case 20001 : case 20007 : case 20008 : case 20010 : ND_PRINT ( ( ndo , ""<S2SV_blank>tid"" ) ) ; UBIK_VERSIONOUT ( ) ; break ; case 20002 : ND_PRINT ( ( ndo , ""<S2SV_blank>tid"" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>file"" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>pos"" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>length"" ) ) ; INTOUT ( ) ; <S2SV_StartBug> temp = EXTRACT_32BITS ( bp ) ; <S2SV_EndBug> bp += sizeof ( int32_t ) ; tok2str ( ubik_lock_types , ""type<S2SV_blank>%d"" , temp ) ; break ; case 20003 : ND_PRINT ( ( ndo , ""<S2SV_blank>tid"" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>file"" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>pos"" ) ) ; INTOUT ( ) ; break ; case 20005 : ND_PRINT ( ( ndo , ""<S2SV_blank>file"" ) ) ; INTOUT ( ) ; break ; case 20006 : ND_PRINT ( ( ndo , ""<S2SV_blank>file"" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>length"" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>dbversion"" ) ) ; UBIK_VERSIONOUT ( ) ; break ; case 20009 : ND_PRINT ( ( ndo , ""<S2SV_blank>tid"" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>file"" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>length"" ) ) ; INTOUT ( ) ; break ; case 20012 : ND_PRINT ( ( ndo , ""<S2SV_blank>tid"" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>oldversion"" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>newversion"" ) ) ; UBIK_VERSIONOUT ( ) ; break ; default : ; } return ; trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|ubik]"" ) ) ; }
","<S2SV_ModStart> ( ) ; ND_TCHECK_32BITS ( bp ) ;
"
640,"CWE-59 int add_mibdir ( const char * dirname ) { <S2SV_StartBug> FILE * ip ; <S2SV_EndBug> const char * oldFile = File ; char * * filenames ; int count = 0 ; int filename_count , i ; <S2SV_StartBug> # if ! ( defined ( WIN32 ) || defined ( cygwin ) ) <S2SV_EndBug> char * token ; char space ; char newline ; struct stat dir_stat , idx_stat ; char tmpstr [ 300 ] ; char tmpstr1 [ 300 ] ; # endif DEBUGMSGTL ( ( ""parse-mibs"" , ""Scanning<S2SV_blank>directory<S2SV_blank>%s\\n"" , dirname ) ) ; <S2SV_StartBug> # if ! ( defined ( WIN32 ) || defined ( cygwin ) ) <S2SV_EndBug> token = netsnmp_mibindex_lookup ( dirname ) ; if ( token && stat ( token , & idx_stat ) == 0 && stat ( dirname , & dir_stat ) == 0 ) { if ( dir_stat . st_mtime < idx_stat . st_mtime ) { DEBUGMSGTL ( ( ""parse-mibs"" , ""The<S2SV_blank>index<S2SV_blank>is<S2SV_blank>good\\n"" ) ) ; if ( ( ip = fopen ( token , ""r"" ) ) != NULL ) { fgets ( tmpstr , sizeof ( tmpstr ) , ip ) ; while ( fscanf ( ip , ""%127s%c%299[^\\n]%c"" , token , & space , tmpstr , & newline ) == 4 ) { if ( space != '<S2SV_blank>' || newline != '\\n' ) { snmp_log ( LOG_ERR , ""add_mibdir:<S2SV_blank>strings<S2SV_blank>scanned<S2SV_blank>in<S2SV_blank>from<S2SV_blank>%s/%s<S2SV_blank>"" ""are<S2SV_blank>too<S2SV_blank>large.<S2SV_blank><S2SV_blank>count<S2SV_blank>=<S2SV_blank>%d\\n<S2SV_blank>"" , dirname , "".index"" , count ) ; break ; } snprintf ( tmpstr1 , sizeof ( tmpstr1 ) , ""%s/%s"" , dirname , tmpstr ) ; tmpstr1 [ sizeof ( tmpstr1 ) - 1 ] = 0 ; new_module ( token , tmpstr1 ) ; count ++ ; } fclose ( ip ) ; return count ; } else DEBUGMSGTL ( ( ""parse-mibs"" , ""Can\'t<S2SV_blank>read<S2SV_blank>index\\n"" ) ) ; } else DEBUGMSGTL ( ( ""parse-mibs"" , ""Index<S2SV_blank>outdated\\n"" ) ) ; } else DEBUGMSGTL ( ( ""parse-mibs"" , ""No<S2SV_blank>index\\n"" ) ) ; # endif filename_count = scan_directory ( & filenames , dirname ) ; if ( filename_count >= 0 ) { <S2SV_StartBug> ip = netsnmp_mibindex_new ( dirname ) ; <S2SV_EndBug> for ( i = 0 ; i < filename_count ; i ++ ) { <S2SV_StartBug> if ( add_mibfile ( filenames [ i ] , strrchr ( filenames [ i ] , '/' ) , ip ) == 0 ) <S2SV_EndBug> count ++ ; free ( filenames [ i ] ) ; } <S2SV_StartBug> File = oldFile ; <S2SV_EndBug> if ( ip ) fclose ( ip ) ; free ( filenames ) ; return ( count ) ; } else DEBUGMSGTL ( ( ""parse-mibs"" , ""cannot<S2SV_blank>open<S2SV_blank>MIB<S2SV_blank>directory<S2SV_blank>%s\\n"" , dirname ) ) ; return ( - 1 ) ; }
","<S2SV_ModStart> dirname ) { <S2SV_ModEnd> const char * <S2SV_ModStart> , i ; <S2SV_ModEnd> DEBUGMSGTL ( ( <S2SV_ModStart> ) ) ; <S2SV_ModEnd> filename_count = scan_directory <S2SV_ModStart> 0 ) { <S2SV_ModEnd> for ( i <S2SV_ModStart> , '/' ) <S2SV_ModEnd> ) == 0 <S2SV_ModStart> File = oldFile <S2SV_ModEnd> ; free (
"
641,"CWE-119 static ssize_t wdm_read ( struct file * file , char __user * buffer , size_t count , loff_t * ppos ) { int rv , cntr ; int i = 0 ; struct wdm_device * desc = file -> private_data ; rv = mutex_lock_interruptible ( & desc -> rlock ) ; if ( rv < 0 ) return - ERESTARTSYS ; cntr = ACCESS_ONCE ( desc -> length ) ; if ( cntr == 0 ) { desc -> read = 0 ; retry : if ( test_bit ( WDM_DISCONNECTING , & desc -> flags ) ) { rv = - ENODEV ; goto err ; } <S2SV_StartBug> i ++ ; <S2SV_EndBug> if ( file -> f_flags & O_NONBLOCK ) { if ( ! test_bit ( WDM_READ , & desc -> flags ) ) { rv = cntr ? cntr : - EAGAIN ; goto err ; } rv = 0 ; } else { rv = wait_event_interruptible ( desc -> wait , test_bit ( WDM_READ , & desc -> flags ) ) ; } if ( test_bit ( WDM_DISCONNECTING , & desc -> flags ) ) { rv = - ENODEV ; goto err ; } if ( test_bit ( WDM_RESETTING , & desc -> flags ) ) { rv = - EIO ; goto err ; } usb_mark_last_busy ( interface_to_usbdev ( desc -> intf ) ) ; if ( rv < 0 ) { rv = - ERESTARTSYS ; goto err ; } spin_lock_irq ( & desc -> iuspin ) ; if ( desc -> rerr ) { desc -> rerr = 0 ; spin_unlock_irq ( & desc -> iuspin ) ; rv = - EIO ; goto err ; } if ( ! test_bit ( WDM_READ , & desc -> flags ) ) { spin_unlock_irq ( & desc -> iuspin ) ; goto retry ; } if ( ! desc -> reslength ) { dev_dbg ( & desc -> intf -> dev , ""%s:<S2SV_blank>zero<S2SV_blank>length<S2SV_blank>-<S2SV_blank>clearing<S2SV_blank>WDM_READ\\n"" , __func__ ) ; clear_bit ( WDM_READ , & desc -> flags ) ; spin_unlock_irq ( & desc -> iuspin ) ; goto retry ; } cntr = desc -> length ; spin_unlock_irq ( & desc -> iuspin ) ; } if ( cntr > count ) cntr = count ; rv = copy_to_user ( buffer , desc -> ubuf , cntr ) ; if ( rv > 0 ) { rv = - EFAULT ; goto err ; } spin_lock_irq ( & desc -> iuspin ) ; for ( i = 0 ; i < desc -> length - cntr ; i ++ ) desc -> ubuf [ i ] = desc -> ubuf [ i + cntr ] ; desc -> length -= cntr ; if ( ! desc -> length ) clear_bit ( WDM_READ , & desc -> flags ) ; spin_unlock_irq ( & desc -> iuspin ) ; rv = cntr ; err : mutex_unlock ( & desc -> rlock ) ; return rv ; }
","<S2SV_ModStart> err ; } if ( test_bit ( WDM_OVERFLOW , & desc -> flags ) ) { clear_bit ( WDM_OVERFLOW , & desc -> flags ) ; rv = - ENOBUFS ; goto err ; }
"
642,"CWE-119 static vpx_codec_err_t vp8e_mr_alloc_mem ( const vpx_codec_enc_cfg_t * cfg , void * * mem_loc ) { vpx_codec_err_t res = 0 ; # if CONFIG_MULTI_RES_ENCODING LOWER_RES_FRAME_INFO * shared_mem_loc ; int mb_rows = ( ( cfg -> g_w + 15 ) >> 4 ) ; int mb_cols = ( ( cfg -> g_h + 15 ) >> 4 ) ; shared_mem_loc = calloc ( 1 , sizeof ( LOWER_RES_FRAME_INFO ) ) ; if ( ! shared_mem_loc ) { res = VPX_CODEC_MEM_ERROR ; } shared_mem_loc -> mb_info = calloc ( mb_rows * mb_cols , sizeof ( LOWER_RES_MB_INFO ) ) ; if ( ! ( shared_mem_loc -> mb_info ) ) { res = VPX_CODEC_MEM_ERROR ; } else { * mem_loc = ( void * ) shared_mem_loc ; res = VPX_CODEC_OK ; } <S2SV_StartBug> # endif <S2SV_EndBug> return res ; }
","<S2SV_ModStart> ; } # else ( void ) cfg ; ( void ) mem_loc ; #
"
643,"CWE-20 static int __ip6_append_data ( struct sock * sk , struct flowi6 * fl6 , struct sk_buff_head * queue , struct inet_cork * cork , struct inet6_cork * v6_cork , struct page_frag * pfrag , int getfrag ( void * from , char * to , int offset , int len , int odd , struct sk_buff * skb ) , void * from , int length , int transhdrlen , unsigned int flags , struct ipcm6_cookie * ipc6 , const struct sockcm_cookie * sockc ) { struct sk_buff * skb , * skb_prev = NULL ; unsigned int maxfraglen , fragheaderlen , mtu , orig_mtu ; int exthdrlen = 0 ; int dst_exthdrlen = 0 ; int hh_len ; int copy ; int err ; int offset = 0 ; __u8 tx_flags = 0 ; u32 tskey = 0 ; struct rt6_info * rt = ( struct rt6_info * ) cork -> dst ; struct ipv6_txoptions * opt = v6_cork -> opt ; int csummode = CHECKSUM_NONE ; unsigned int maxnonfragsize , headersize ; skb = skb_peek_tail ( queue ) ; if ( ! skb ) { exthdrlen = opt ? opt -> opt_flen : 0 ; dst_exthdrlen = rt -> dst . header_len - rt -> rt6i_nfheader_len ; } mtu = cork -> fragsize ; orig_mtu = mtu ; hh_len = LL_RESERVED_SPACE ( rt -> dst . dev ) ; fragheaderlen = sizeof ( struct ipv6hdr ) + rt -> rt6i_nfheader_len + ( opt ? opt -> opt_nflen : 0 ) ; maxfraglen = ( ( mtu - fragheaderlen ) & ~ 7 ) + fragheaderlen - sizeof ( struct frag_hdr ) ; headersize = sizeof ( struct ipv6hdr ) + ( opt ? opt -> opt_flen + opt -> opt_nflen : 0 ) + ( dst_allfrag ( & rt -> dst ) ? sizeof ( struct frag_hdr ) : 0 ) + rt -> rt6i_nfheader_len ; if ( cork -> length + length > mtu - headersize && ipc6 -> dontfrag && ( sk -> sk_protocol == IPPROTO_UDP || sk -> sk_protocol == IPPROTO_RAW ) ) { ipv6_local_rxpmtu ( sk , fl6 , mtu - headersize + sizeof ( struct ipv6hdr ) ) ; goto emsgsize ; } if ( ip6_sk_ignore_df ( sk ) ) maxnonfragsize = sizeof ( struct ipv6hdr ) + IPV6_MAXPLEN ; else maxnonfragsize = mtu ; if ( cork -> length + length > maxnonfragsize - headersize ) { emsgsize : ipv6_local_error ( sk , EMSGSIZE , fl6 , mtu - headersize + sizeof ( struct ipv6hdr ) ) ; return - EMSGSIZE ; } if ( transhdrlen && sk -> sk_protocol == IPPROTO_UDP && headersize == sizeof ( struct ipv6hdr ) && length <= mtu - headersize && ! ( flags & MSG_MORE ) && rt -> dst . dev -> features & ( NETIF_F_IPV6_CSUM | NETIF_F_HW_CSUM ) ) csummode = CHECKSUM_PARTIAL ; if ( sk -> sk_type == SOCK_DGRAM || sk -> sk_type == SOCK_RAW ) { sock_tx_timestamp ( sk , sockc -> tsflags , & tx_flags ) ; if ( tx_flags & SKBTX_ANY_SW_TSTAMP && sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_ID ) tskey = sk -> sk_tskey ++ ; } cork -> length += length ; if ( ( ( ( length + fragheaderlen ) > mtu ) || ( skb && skb_is_gso ( skb ) ) ) && ( sk -> sk_protocol == IPPROTO_UDP ) && ( rt -> dst . dev -> features & NETIF_F_UFO ) && ! dst_xfrm ( & rt -> dst ) && ( sk -> sk_type == SOCK_DGRAM ) && ! udp_get_no_check6_tx ( sk ) ) { err = ip6_ufo_append_data ( sk , queue , getfrag , from , length , hh_len , fragheaderlen , exthdrlen , transhdrlen , mtu , flags , fl6 ) ; if ( err ) goto error ; return 0 ; } if ( ! skb ) goto alloc_new_skb ; while ( length > 0 ) { copy = ( cork -> length <= mtu && ! ( cork -> flags & IPCORK_ALLFRAG ) ? mtu : maxfraglen ) - skb -> len ; if ( copy < length ) copy = maxfraglen - skb -> len ; if ( copy <= 0 ) { char * data ; unsigned int datalen ; unsigned int fraglen ; unsigned int fraggap ; unsigned int alloclen ; alloc_new_skb : if ( skb ) fraggap = skb -> len - maxfraglen ; else fraggap = 0 ; if ( ! skb || ! skb_prev ) ip6_append_data_mtu ( & mtu , & maxfraglen , fragheaderlen , skb , rt , orig_mtu ) ; skb_prev = skb ; datalen = length + fraggap ; if ( datalen > ( cork -> length <= mtu && ! ( cork -> flags & IPCORK_ALLFRAG ) ? mtu : maxfraglen ) - fragheaderlen ) datalen = maxfraglen - fragheaderlen - rt -> dst . trailer_len ; if ( ( flags & MSG_MORE ) && ! ( rt -> dst . dev -> features & NETIF_F_SG ) ) alloclen = mtu ; else alloclen = datalen + fragheaderlen ; alloclen += dst_exthdrlen ; if ( datalen != length + fraggap ) { datalen += rt -> dst . trailer_len ; } alloclen += rt -> dst . trailer_len ; fraglen = datalen + fragheaderlen ; alloclen += sizeof ( struct frag_hdr ) ; <S2SV_StartBug> if ( transhdrlen ) { <S2SV_EndBug> skb = sock_alloc_send_skb ( sk , alloclen + hh_len , ( flags & MSG_DONTWAIT ) , & err ) ; } else { skb = NULL ; if ( atomic_read ( & sk -> sk_wmem_alloc ) <= 2 * sk -> sk_sndbuf ) skb = sock_wmalloc ( sk , alloclen + hh_len , 1 , sk -> sk_allocation ) ; if ( unlikely ( ! skb ) ) err = - ENOBUFS ; } if ( ! skb ) goto error ; skb -> protocol = htons ( ETH_P_IPV6 ) ; skb -> ip_summed = csummode ; skb -> csum = 0 ; skb_reserve ( skb , hh_len + sizeof ( struct frag_hdr ) + dst_exthdrlen ) ; skb_shinfo ( skb ) -> tx_flags = tx_flags ; tx_flags = 0 ; skb_shinfo ( skb ) -> tskey = tskey ; tskey = 0 ; data = skb_put ( skb , fraglen ) ; skb_set_network_header ( skb , exthdrlen ) ; data += fragheaderlen ; skb -> transport_header = ( skb -> network_header + fragheaderlen ) ; if ( fraggap ) { skb -> csum = skb_copy_and_csum_bits ( skb_prev , maxfraglen , data + transhdrlen , fraggap , 0 ) ; skb_prev -> csum = csum_sub ( skb_prev -> csum , skb -> csum ) ; data += fraggap ; pskb_trim_unique ( skb_prev , maxfraglen ) ; } <S2SV_StartBug> copy = datalen - transhdrlen - fraggap ; <S2SV_EndBug> if ( copy < 0 ) { err = - EINVAL ; kfree_skb ( skb ) ; goto error ; } else if ( copy > 0 && getfrag ( from , data + transhdrlen , offset , copy , fraggap , skb ) < 0 ) { err = - EFAULT ; kfree_skb ( skb ) ; goto error ; } offset += copy ; length -= datalen - fraggap ; transhdrlen = 0 ; exthdrlen = 0 ; dst_exthdrlen = 0 ; if ( ( flags & MSG_CONFIRM ) && ! skb_prev ) skb_set_dst_pending_confirm ( skb , 1 ) ; __skb_queue_tail ( queue , skb ) ; continue ; } if ( copy > length ) copy = length ; if ( ! ( rt -> dst . dev -> features & NETIF_F_SG ) ) { unsigned int off ; off = skb -> len ; if ( getfrag ( from , skb_put ( skb , copy ) , offset , copy , off , skb ) < 0 ) { __skb_trim ( skb , off ) ; err = - EFAULT ; goto error ; } } else { int i = skb_shinfo ( skb ) -> nr_frags ; err = - ENOMEM ; if ( ! sk_page_frag_refill ( sk , pfrag ) ) goto error ; if ( ! skb_can_coalesce ( skb , i , pfrag -> page , pfrag -> offset ) ) { err = - EMSGSIZE ; if ( i == MAX_SKB_FRAGS ) goto error ; __skb_fill_page_desc ( skb , i , pfrag -> page , pfrag -> offset , 0 ) ; skb_shinfo ( skb ) -> nr_frags = ++ i ; get_page ( pfrag -> page ) ; } copy = min_t ( int , copy , pfrag -> size - pfrag -> offset ) ; if ( getfrag ( from , page_address ( pfrag -> page ) + pfrag -> offset , offset , copy , skb -> len , skb ) < 0 ) goto error_efault ; pfrag -> offset += copy ; skb_frag_size_add ( & skb_shinfo ( skb ) -> frags [ i - 1 ] , copy ) ; skb -> len += copy ; skb -> data_len += copy ; skb -> truesize += copy ; atomic_add ( copy , & sk -> sk_wmem_alloc ) ; } offset += copy ; length -= copy ; } return 0 ; error_efault : err = - EFAULT ; error : cork -> length -= length ; IP6_INC_STATS ( sock_net ( sk ) , rt -> rt6i_idev , IPSTATS_MIB_OUTDISCARDS ) ; return err ; }
","<S2SV_ModStart> frag_hdr ) ; copy = datalen - transhdrlen - fraggap ; if ( copy < 0 ) { err = - EINVAL ; goto error ; } <S2SV_ModStart> ) ; } if ( copy > 0 && getfrag ( from , data + transhdrlen <S2SV_ModEnd> , offset ,
"
644,"CWE-119 static void print_mi_data ( VP9_COMMON * cm , FILE * file , const char * descriptor , size_t member_offset ) { <S2SV_StartBug> int mi_row ; <S2SV_EndBug> int mi_col ; int mi_index = 0 ; <S2SV_StartBug> MODE_INFO * * mi_8x8 = cm -> mi_grid_visible ; <S2SV_EndBug> int rows = cm -> mi_rows ; int cols = cm -> mi_cols ; char prefix = descriptor [ 0 ] ; <S2SV_StartBug> log_frame_info ( cm , descriptor , file ) ; <S2SV_EndBug> mi_index = 0 ; for ( mi_row = 0 ; mi_row < rows ; mi_row ++ ) { fprintf ( file , ""%c<S2SV_blank>"" , prefix ) ; for ( mi_col = 0 ; mi_col < cols ; mi_col ++ ) { fprintf ( file , ""%2d<S2SV_blank>"" , <S2SV_StartBug> * ( ( int * ) ( ( char * ) ( & mi_8x8 [ mi_index ] -> mbmi ) + <S2SV_EndBug> member_offset ) ) ) ; <S2SV_StartBug> mi_index ++ ; <S2SV_EndBug> } fprintf ( file , ""\\n"" ) ; <S2SV_StartBug> mi_index += 8 ; <S2SV_EndBug> } fprintf ( file , ""\\n"" ) ; }
","<S2SV_ModStart> { int mi_row , mi_col <S2SV_ModEnd> ; MODE_INFO * <S2SV_ModStart> MODE_INFO * * mi <S2SV_ModEnd> = cm -> <S2SV_ModStart> , file ) <S2SV_ModEnd> ; for ( <S2SV_ModStart> ) ( & mi [ 0 <S2SV_ModEnd> ] -> mbmi <S2SV_ModStart> ) ) ; mi <S2SV_ModEnd> ++ ; } <S2SV_ModStart> ""\\n"" ) ; mi <S2SV_ModEnd> += 8 ;
"
645,"CWE-119 cJSON * cJSON_CreateNull ( void ) { cJSON * item = cJSON_New_Item ( ) ; if ( item ) item -> type = cJSON_NULL ; return item ; }
","
"
646,"CWE-119 static TEE_Result set_rmem_param ( const struct optee_msg_param_rmem * rmem , struct param_mem * mem ) <S2SV_StartBug> { <S2SV_EndBug> uint64_t shm_ref = READ_ONCE ( rmem -> shm_ref ) ; mem -> mobj = mobj_reg_shm_get_by_cookie ( shm_ref ) ; if ( ! mem -> mobj ) return TEE_ERROR_BAD_PARAMETERS ; mem -> offs = READ_ONCE ( rmem -> offs ) ; mem -> size = READ_ONCE ( rmem -> size ) ; <S2SV_StartBug> return TEE_SUCCESS ; <S2SV_EndBug> }
","<S2SV_ModStart> mem ) { size_t req_size = 0 ; <S2SV_ModStart> size ) ; if ( ADD_OVERFLOW ( mem -> offs , mem -> size , & req_size ) || mem -> mobj -> size < req_size ) return TEE_ERROR_SECURITY ;
"
647,"CWE-20 static int netbk_set_skb_gso ( struct xenvif * vif , struct sk_buff * skb , struct xen_netif_extra_info * gso ) { if ( ! gso -> u . gso . size ) { <S2SV_StartBug> netdev_dbg ( vif -> dev , ""GSO<S2SV_blank>size<S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>zero.\\n"" ) ; <S2SV_EndBug> return - EINVAL ; } if ( gso -> u . gso . type != XEN_NETIF_GSO_TYPE_TCPV4 ) { <S2SV_StartBug> netdev_dbg ( vif -> dev , ""Bad<S2SV_blank>GSO<S2SV_blank>type<S2SV_blank>%d.\\n"" , gso -> u . gso . type ) ; <S2SV_EndBug> return - EINVAL ; } skb_shinfo ( skb ) -> gso_size = gso -> u . gso . size ; skb_shinfo ( skb ) -> gso_type = SKB_GSO_TCPV4 ; skb_shinfo ( skb ) -> gso_type |= SKB_GSO_DODGY ; skb_shinfo ( skb ) -> gso_segs = 0 ; return 0 ; }
","<S2SV_ModStart> size ) { netdev_err <S2SV_ModEnd> ( vif -> <S2SV_ModStart> dev , ""GSO<S2SV_blank>size<S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>zero.\\n"" ) ; netbk_fatal_tx_err ( vif <S2SV_ModStart> XEN_NETIF_GSO_TYPE_TCPV4 ) { netdev_err <S2SV_ModEnd> ( vif -> <S2SV_ModStart> gso . type ) ; netbk_fatal_tx_err ( vif
"
648,"CWE-119 <S2SV_StartBug> static vpx_codec_err_t ctrl_set_svc_layer_id ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> int ctr_id , va_list args ) { vpx_svc_layer_id_t * const data = va_arg ( args , vpx_svc_layer_id_t * ) ; VP9_COMP * const cpi = ( VP9_COMP * ) ctx -> cpi ; SVC * const svc = & cpi -> svc ; svc -> spatial_layer_id = data -> spatial_layer_id ; svc -> temporal_layer_id = data -> temporal_layer_id ; if ( svc -> temporal_layer_id < 0 || svc -> temporal_layer_id >= ( int ) ctx -> cfg . ts_number_layers ) { return VPX_CODEC_INVALID_PARAM ; } if ( svc -> spatial_layer_id < 0 || svc -> spatial_layer_id >= ( int ) ctx -> cfg . ss_number_layers ) { return VPX_CODEC_INVALID_PARAM ; } return VPX_CODEC_OK ; }
","<S2SV_ModStart> vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args
"
649,"CWE-399 static void vhost_net_ubuf_put_and_wait ( struct vhost_net_ubuf_ref * ubufs ) { kref_put ( & ubufs -> kref , vhost_net_zerocopy_done_signal ) ; wait_event ( ubufs -> wait , ! atomic_read ( & ubufs -> kref . refcount ) ) ; <S2SV_StartBug> kfree ( ubufs ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ) ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
"
650,"CWE-284 static int adev_open_output_stream ( struct audio_hw_device * dev , audio_io_handle_t handle , audio_devices_t devices , audio_output_flags_t flags , struct audio_config * config , struct audio_stream_out * * stream_out , const char * address ) { struct a2dp_audio_device * a2dp_dev = ( struct a2dp_audio_device * ) dev ; struct a2dp_stream_out * out ; int ret = 0 ; int i ; UNUSED ( address ) ; UNUSED ( handle ) ; UNUSED ( devices ) ; UNUSED ( flags ) ; INFO ( ""opening<S2SV_blank>output"" ) ; out = ( struct a2dp_stream_out * ) calloc ( 1 , sizeof ( struct a2dp_stream_out ) ) ; if ( ! out ) return - ENOMEM ; out -> stream . common . get_sample_rate = out_get_sample_rate ; out -> stream . common . set_sample_rate = out_set_sample_rate ; out -> stream . common . get_buffer_size = out_get_buffer_size ; out -> stream . common . get_channels = out_get_channels ; out -> stream . common . get_format = out_get_format ; out -> stream . common . set_format = out_set_format ; out -> stream . common . standby = out_standby ; out -> stream . common . dump = out_dump ; out -> stream . common . set_parameters = out_set_parameters ; out -> stream . common . get_parameters = out_get_parameters ; out -> stream . common . add_audio_effect = out_add_audio_effect ; out -> stream . common . remove_audio_effect = out_remove_audio_effect ; out -> stream . get_latency = out_get_latency ; out -> stream . set_volume = out_set_volume ; out -> stream . write = out_write ; out -> stream . get_render_position = out_get_render_position ; out -> stream . get_presentation_position = out_get_presentation_position ; a2dp_stream_common_init ( & out -> common ) ; out -> common . cfg . channel_flags = AUDIO_STREAM_DEFAULT_CHANNEL_FLAG ; out -> common . cfg . format = AUDIO_STREAM_DEFAULT_FORMAT ; out -> common . cfg . rate = AUDIO_STREAM_DEFAULT_RATE ; if ( config ) { config -> format = out_get_format ( ( const struct audio_stream * ) & out -> stream ) ; config -> sample_rate = out_get_sample_rate ( ( const struct audio_stream * ) & out -> stream ) ; config -> channel_mask = out_get_channels ( ( const struct audio_stream * ) & out -> stream ) ; } * stream_out = & out -> stream ; a2dp_dev -> output = out ; a2dp_open_ctrl_path ( & out -> common ) ; if ( out -> common . ctrl_fd == AUDIO_SKT_DISCONNECTED ) { ERROR ( ""ctrl<S2SV_blank>socket<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>connect<S2SV_blank>(%s)"" , strerror ( errno ) ) ; ret = - 1 ; goto err_open ; } DEBUG ( ""success"" ) ; <S2SV_StartBug> usleep ( 250000 ) ; <S2SV_EndBug> return 0 ; err_open : free ( out ) ; * stream_out = NULL ; a2dp_dev -> output = NULL ; ERROR ( ""failed"" ) ; return ret ; }
","<S2SV_ModStart> ""success"" ) ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> usleep ( 250000 )
"
651,"CWE-190 static int burl_normalize_2F_to_slash_fix ( buffer * b , int qs , int i ) { char * const s = b -> ptr ; const int blen = ( int ) buffer_string_length ( b ) ; const int used = qs < 0 ? blen : qs ; int j = i ; for ( ; i < used ; ++ i , ++ j ) { s [ j ] = s [ i ] ; if ( s [ i ] == '%' && s [ i + 1 ] == '2' && s [ i + 2 ] == 'F' ) { s [ j ] = '/' ; i += 2 ; } } if ( qs >= 0 ) { <S2SV_StartBug> memmove ( s + j , s + qs , blen - qs ) ; <S2SV_EndBug> <S2SV_StartBug> j += blen - qs ; <S2SV_EndBug> } buffer_string_set_length ( b , j ) ; return qs ; }
","<S2SV_ModStart> 0 ) { const int qslen = blen - qs ; <S2SV_ModStart> + qs , ( size_t ) qslen ) ; qs = j <S2SV_ModEnd> ; j += <S2SV_ModStart> ; j += qslen <S2SV_ModEnd> ; } buffer_string_set_length
"
652,"CWE-269 void virtio_config_writew ( VirtIODevice * vdev , uint32_t addr , uint32_t data ) { VirtioDeviceClass * k = VIRTIO_DEVICE_GET_CLASS ( vdev ) ; uint16_t val = data ; <S2SV_StartBug> if ( addr > ( vdev -> config_len - sizeof ( val ) ) ) <S2SV_EndBug> return ; stw_p ( vdev -> config + addr , val ) ; if ( k -> set_config ) { k -> set_config ( vdev , vdev -> config ) ; } }
","<S2SV_ModStart> if ( addr + <S2SV_ModEnd> sizeof ( val <S2SV_ModStart> ( val ) > vdev -> config_len ) { return ; } <S2SV_ModEnd> stw_p ( vdev
"
653,"CWE-119 static int store_icy ( URLContext * h , int size ) { HTTPContext * s = h -> priv_data ; <S2SV_StartBug> int remaining = s -> icy_metaint - s -> icy_data_read ; <S2SV_EndBug> if ( remaining < 0 ) return AVERROR_INVALIDDATA ; if ( ! remaining ) { uint8_t ch ; int len = http_read_stream_all ( h , & ch , 1 ) ; if ( len < 0 ) return len ; if ( ch > 0 ) { char data [ 255 * 16 + 1 ] ; int ret ; len = ch * 16 ; ret = http_read_stream_all ( h , data , len ) ; if ( ret < 0 ) return ret ; data [ len + 1 ] = 0 ; if ( ( ret = av_opt_set ( s , ""icy_metadata_packet"" , data , 0 ) ) < 0 ) return ret ; update_metadata ( s , data ) ; } s -> icy_data_read = 0 ; remaining = s -> icy_metaint ; } return FFMIN ( size , remaining ) ; }
","<S2SV_ModStart> -> priv_data ; uint64_t remaining ; if ( s -> icy_metaint < s -> icy_data_read ) return AVERROR_INVALIDDATA ; <S2SV_ModEnd> remaining = s <S2SV_ModStart> s -> icy_data_read <S2SV_ModEnd> ; if (
"
654,"CWE-119 void jshGetPinString ( char * result , Pin pin ) { result [ 0 ] = 0 ; # ifdef PIN_NAMES_DIRECT if ( jshIsPinValid ( pin ) ) { result [ 0 ] = ( char ) ( 'A' + ( pinInfo [ pin ] . port & JSH_PORT_MASK ) - JSH_PORTA ) ; itostr ( pinInfo [ pin ] . pin - JSH_PIN0 , & result [ 1 ] , 10 ) ; # else if ( false ) { # if JSH_PORTA_OFFSET != - 1 } else if ( # if JSH_PORTA_OFFSET != 0 pin >= JSH_PORTA_OFFSET && # endif pin < JSH_PORTA_OFFSET + JSH_PORTA_COUNT ) { result [ 0 ] = 'A' ; itostr ( pin - JSH_PORTA_OFFSET , & result [ 1 ] , 10 ) ; # endif # if JSH_PORTB_OFFSET != - 1 } else if ( pin >= JSH_PORTB_OFFSET && pin < JSH_PORTB_OFFSET + JSH_PORTB_COUNT ) { result [ 0 ] = 'B' ; itostr ( pin - JSH_PORTB_OFFSET , & result [ 1 ] , 10 ) ; # endif # if JSH_PORTC_OFFSET != - 1 } else if ( pin >= JSH_PORTC_OFFSET && pin < JSH_PORTC_OFFSET + JSH_PORTC_COUNT ) { result [ 0 ] = 'C' ; itostr ( pin - JSH_PORTC_OFFSET , & result [ 1 ] , 10 ) ; # endif # if JSH_PORTD_OFFSET != - 1 } else if ( # if JSH_PORTD_OFFSET != 0 pin >= JSH_PORTD_OFFSET && # endif pin < JSH_PORTD_OFFSET + JSH_PORTD_COUNT ) { result [ 0 ] = 'D' ; itostr ( pin - JSH_PORTD_OFFSET , & result [ 1 ] , 10 ) ; # endif # if JSH_PORTE_OFFSET != - 1 } else if ( pin >= JSH_PORTE_OFFSET && pin < JSH_PORTE_OFFSET + JSH_PORTE_COUNT ) { result [ 0 ] = 'E' ; itostr ( pin - JSH_PORTE_OFFSET , & result [ 1 ] , 10 ) ; # endif # if JSH_PORTF_OFFSET != - 1 } else if ( pin >= JSH_PORTF_OFFSET && pin < JSH_PORTF_OFFSET + JSH_PORTF_COUNT ) { result [ 0 ] = 'F' ; itostr ( pin - JSH_PORTF_OFFSET , & result [ 1 ] , 10 ) ; # endif # if JSH_PORTG_OFFSET != - 1 } else if ( pin >= JSH_PORTG_OFFSET && pin < JSH_PORTG_OFFSET + JSH_PORTG_COUNT ) { result [ 0 ] = 'G' ; itostr ( pin - JSH_PORTG_OFFSET , & result [ 1 ] , 10 ) ; # endif # if JSH_PORTH_OFFSET != - 1 } else if ( pin >= JSH_PORTH_OFFSET && pin < JSH_PORTH_OFFSET + JSH_PORTH_COUNT ) { result [ 0 ] = 'H' ; itostr ( pin - JSH_PORTH_OFFSET , & result [ 1 ] , 10 ) ; # endif # if JSH_PORTI_OFFSET != - 1 } else if ( pin >= JSH_PORTI_OFFSET && pin < JSH_PORTI_OFFSET + JSH_PORTI_COUNT ) { result [ 0 ] = 'I' ; itostr ( pin - JSH_PORTI_OFFSET , & result [ 1 ] , 10 ) ; # endif # if JSH_PORTV_OFFSET != - 1 } else if ( pin >= JSH_PORTV_OFFSET && pin < JSH_PORTV_OFFSET + JSH_PORTV_COUNT ) { result [ 0 ] = 'V' ; itostr ( pin - JSH_PORTV_OFFSET , & result [ 1 ] , 10 ) ; # endif # endif } else { <S2SV_StartBug> strncpy ( result , ""undefined"" , 10 ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> } else { strcpy <S2SV_ModEnd> ( result , <S2SV_ModStart> result , ""undefined"" <S2SV_ModEnd> ) ; }
"
655,"CWE-617 krb5_error_code kdc_process_s4u2self_req ( kdc_realm_t * kdc_active_realm , krb5_kdc_req * request , krb5_const_principal client_princ , krb5_const_principal header_srv_princ , krb5_boolean issuing_referral , const krb5_db_entry * server , krb5_keyblock * tgs_subkey , krb5_keyblock * tgs_session , krb5_timestamp kdc_time , krb5_pa_s4u_x509_user * * s4u_x509_user , krb5_db_entry * * princ_ptr , const char * * status ) { krb5_error_code code ; krb5_boolean is_local_tgt ; krb5_pa_data * pa_data ; int flags ; krb5_db_entry * princ ; * princ_ptr = NULL ; pa_data = krb5int_find_pa_data ( kdc_context , request -> padata , KRB5_PADATA_S4U_X509_USER ) ; if ( pa_data != NULL ) { code = kdc_process_s4u_x509_user ( kdc_context , request , pa_data , tgs_subkey , tgs_session , s4u_x509_user , status ) ; if ( code != 0 ) return code ; } else { pa_data = krb5int_find_pa_data ( kdc_context , request -> padata , KRB5_PADATA_FOR_USER ) ; if ( pa_data != NULL ) { code = kdc_process_for_user ( kdc_active_realm , pa_data , tgs_session , s4u_x509_user , status ) ; if ( code != 0 ) return code ; } else return 0 ; } flags = 0 ; switch ( krb5_princ_type ( kdc_context , request -> server ) ) { case KRB5_NT_SRV_HST : if ( krb5_princ_size ( kdc_context , request -> server ) == 2 ) flags |= KRB5_PRINCIPAL_COMPARE_IGNORE_REALM ; break ; case KRB5_NT_ENTERPRISE_PRINCIPAL : flags |= KRB5_PRINCIPAL_COMPARE_ENTERPRISE ; break ; default : break ; } if ( ! krb5_principal_compare_flags ( kdc_context , request -> server , client_princ , flags ) ) { * status = ""INVALID_S4U2SELF_REQUEST"" ; return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; } if ( request -> kdc_options & AS_INVALID_OPTIONS ) { * status = ""INVALID<S2SV_blank>AS<S2SV_blank>OPTIONS"" ; return KRB5KDC_ERR_BADOPTION ; } is_local_tgt = ! is_cross_tgs_principal ( header_srv_princ ) ; if ( is_local_tgt && issuing_referral ) { * status = ""LOOKING_UP_SERVER"" ; return KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN ; } if ( is_local_principal ( kdc_active_realm , ( * s4u_x509_user ) -> user_id . user ) ) { krb5_db_entry no_server ; krb5_pa_data * * e_data = NULL ; if ( ! is_local_tgt && ! issuing_referral ) { * status = ""NOT_CROSS_REALM_REQUEST"" ; return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; } code = krb5_db_get_principal ( kdc_context , ( * s4u_x509_user ) -> user_id . user , KRB5_KDB_FLAG_INCLUDE_PAC , & princ ) ; if ( code == KRB5_KDB_NOENTRY ) { * status = ""UNKNOWN_S4U2SELF_PRINCIPAL"" ; return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; } else if ( code ) { * status = ""LOOKING_UP_S4U2SELF_PRINCIPAL"" ; return code ; } memset ( & no_server , 0 , sizeof ( no_server ) ) ; <S2SV_StartBug> code = validate_as_request ( kdc_active_realm , request , * princ , <S2SV_EndBug> no_server , kdc_time , status , & e_data ) ; if ( code ) { krb5_db_free_principal ( kdc_context , princ ) ; krb5_free_pa_data ( kdc_context , e_data ) ; return code ; } * princ_ptr = princ ; } else if ( is_local_tgt ) { * status = ""S4U2SELF_CLIENT_NOT_OURS"" ; return KRB5KDC_ERR_POLICY ; } return 0 ; }
","<S2SV_ModStart> ) ) ; princ -> pw_expiration = 0 ; clear ( princ -> attributes , KRB5_KDB_REQUIRES_PWCHANGE ) ;
"
656,"CWE-755 int sqlite3WindowRewrite ( Parse * pParse , Select * p ) { int rc = SQLITE_OK ; if ( p -> pWin && p -> pPrior == 0 && ( p -> selFlags & SF_WinRewrite ) == 0 ) { Vdbe * v = sqlite3GetVdbe ( pParse ) ; sqlite3 * db = pParse -> db ; Select * pSub = 0 ; SrcList * pSrc = p -> pSrc ; Expr * pWhere = p -> pWhere ; ExprList * pGroupBy = p -> pGroupBy ; Expr * pHaving = p -> pHaving ; ExprList * pSort = 0 ; ExprList * pSublist = 0 ; Window * pMWin = p -> pWin ; Window * pWin ; Table * pTab ; pTab = sqlite3DbMallocZero ( db , sizeof ( Table ) ) ; if ( pTab == 0 ) { <S2SV_StartBug> return SQLITE_NOMEM ; <S2SV_EndBug> } p -> pSrc = 0 ; p -> pWhere = 0 ; p -> pGroupBy = 0 ; p -> pHaving = 0 ; p -> selFlags &= ~ SF_Aggregate ; p -> selFlags |= SF_WinRewrite ; pSort = sqlite3ExprListDup ( db , pMWin -> pPartition , 0 ) ; pSort = exprListAppendList ( pParse , pSort , pMWin -> pOrderBy , 1 ) ; if ( pSort && p -> pOrderBy && p -> pOrderBy -> nExpr <= pSort -> nExpr ) { int nSave = pSort -> nExpr ; pSort -> nExpr = p -> pOrderBy -> nExpr ; if ( sqlite3ExprListCompare ( pSort , p -> pOrderBy , - 1 ) == 0 ) { sqlite3ExprListDelete ( db , p -> pOrderBy ) ; p -> pOrderBy = 0 ; } pSort -> nExpr = nSave ; } pMWin -> iEphCsr = pParse -> nTab ++ ; pParse -> nTab += 3 ; selectWindowRewriteEList ( pParse , pMWin , pSrc , p -> pEList , pTab , & pSublist ) ; selectWindowRewriteEList ( pParse , pMWin , pSrc , p -> pOrderBy , pTab , & pSublist ) ; pMWin -> nBufferCol = ( pSublist ? pSublist -> nExpr : 0 ) ; pSublist = exprListAppendList ( pParse , pSublist , pMWin -> pPartition , 0 ) ; pSublist = exprListAppendList ( pParse , pSublist , pMWin -> pOrderBy , 0 ) ; for ( pWin = pMWin ; pWin ; pWin = pWin -> pNextWin ) { ExprList * pArgs = pWin -> pOwner -> x . pList ; if ( pWin -> pFunc -> funcFlags & SQLITE_FUNC_SUBTYPE ) { selectWindowRewriteEList ( pParse , pMWin , pSrc , pArgs , pTab , & pSublist ) ; pWin -> iArgCol = ( pSublist ? pSublist -> nExpr : 0 ) ; pWin -> bExprArgs = 1 ; } else { pWin -> iArgCol = ( pSublist ? pSublist -> nExpr : 0 ) ; pSublist = exprListAppendList ( pParse , pSublist , pArgs , 0 ) ; } if ( pWin -> pFilter ) { Expr * pFilter = sqlite3ExprDup ( db , pWin -> pFilter , 0 ) ; pSublist = sqlite3ExprListAppend ( pParse , pSublist , pFilter ) ; } pWin -> regAccum = ++ pParse -> nMem ; pWin -> regResult = ++ pParse -> nMem ; sqlite3VdbeAddOp2 ( v , OP_Null , 0 , pWin -> regAccum ) ; } if ( pSublist == 0 ) { pSublist = sqlite3ExprListAppend ( pParse , 0 , sqlite3Expr ( db , TK_INTEGER , ""0"" ) ) ; } pSub = sqlite3SelectNew ( pParse , pSublist , pSrc , pWhere , pGroupBy , pHaving , pSort , 0 , 0 ) ; p -> pSrc = sqlite3SrcListAppend ( pParse , 0 , 0 , 0 ) ; if ( p -> pSrc ) { Table * pTab2 ; p -> pSrc -> a [ 0 ] . pSelect = pSub ; sqlite3SrcListAssignCursors ( pParse , p -> pSrc ) ; pSub -> selFlags |= SF_Expanded ; pTab2 = sqlite3ResultSetOfSelect ( pParse , pSub , SQLITE_AFF_NONE ) ; if ( pTab2 == 0 ) { rc = SQLITE_NOMEM ; } else { memcpy ( pTab , pTab2 , sizeof ( Table ) ) ; pTab -> tabFlags |= TF_Ephemeral ; p -> pSrc -> a [ 0 ] . pTab = pTab ; pTab = pTab2 ; } sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , pMWin -> iEphCsr , pSublist -> nExpr ) ; sqlite3VdbeAddOp2 ( v , OP_OpenDup , pMWin -> iEphCsr + 1 , pMWin -> iEphCsr ) ; sqlite3VdbeAddOp2 ( v , OP_OpenDup , pMWin -> iEphCsr + 2 , pMWin -> iEphCsr ) ; sqlite3VdbeAddOp2 ( v , OP_OpenDup , pMWin -> iEphCsr + 3 , pMWin -> iEphCsr ) ; } else { sqlite3SelectDelete ( db , pSub ) ; } if ( db -> mallocFailed ) rc = SQLITE_NOMEM ; sqlite3DbFree ( db , pTab ) ; } <S2SV_StartBug> return rc ; <S2SV_EndBug> }
","<S2SV_ModStart> ) { return sqlite3ErrorToParser ( db , SQLITE_NOMEM ) <S2SV_ModEnd> ; } p <S2SV_ModStart> ) ; } if ( rc && pParse -> nErr == 0 ) { assert ( pParse -> db -> mallocFailed ) ; return sqlite3ErrorToParser ( pParse -> db , SQLITE_NOMEM ) ; }
"
657,"CWE-284 int ssl_hook_Access ( request_rec * r ) { SSLDirConfigRec * dc = myDirConfig ( r ) ; SSLSrvConfigRec * sc = mySrvConfig ( r -> server ) ; SSLConnRec * sslconn = myConnConfig ( r -> connection ) ; SSL * ssl = sslconn ? sslconn -> ssl : NULL ; server_rec * handshakeserver = sslconn ? sslconn -> server : NULL ; SSLSrvConfigRec * hssc = handshakeserver ? mySrvConfig ( handshakeserver ) : NULL ; SSL_CTX * ctx = NULL ; apr_array_header_t * requires ; ssl_require_t * ssl_requires ; int ok , i ; BOOL renegotiate = FALSE , renegotiate_quick = FALSE ; X509 * cert ; X509 * peercert ; X509_STORE * cert_store = NULL ; X509_STORE_CTX * cert_store_ctx ; STACK_OF ( SSL_CIPHER ) * cipher_list_old = NULL , * cipher_list = NULL ; const SSL_CIPHER * cipher = NULL ; int depth , verify_old , verify , n , is_slave = 0 ; const char * ncipher_suite ; if ( ! ( sslconn && ssl ) && r -> connection -> master ) { sslconn = myConnConfig ( r -> connection -> master ) ; ssl = sslconn ? sslconn -> ssl : NULL ; handshakeserver = sslconn ? sslconn -> server : NULL ; hssc = handshakeserver ? mySrvConfig ( handshakeserver ) : NULL ; is_slave = 1 ; } if ( ssl ) { if ( ! SSL_is_init_finished ( ssl ) ) { return HTTP_FORBIDDEN ; } ctx = SSL_get_SSL_CTX ( ssl ) ; } if ( dc -> bSSLRequired && ! ssl ) { if ( ( sc -> enabled == SSL_ENABLED_OPTIONAL ) && ! is_slave ) { apr_table_setn ( r -> err_headers_out , ""Upgrade"" , ""TLS/1.0,<S2SV_blank>HTTP/1.1"" ) ; apr_table_setn ( r -> err_headers_out , ""Connection"" , ""Upgrade"" ) ; return HTTP_UPGRADE_REQUIRED ; } ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02219 ) ""access<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>failed,<S2SV_blank>reason:<S2SV_blank>%s"" , r -> filename , ""SSL<S2SV_blank>connection<S2SV_blank>required"" ) ; apr_table_setn ( r -> notes , ""ssl-access-forbidden"" , ""1"" ) ; return HTTP_FORBIDDEN ; } if ( sc -> enabled == SSL_ENABLED_FALSE || ! ssl ) { return DECLINED ; } # ifdef HAVE_SRP if ( SSL_get_srp_username ( ssl ) ) { return DECLINED ; } # endif ncipher_suite = ( dc -> szCipherSuite ? dc -> szCipherSuite : ( r -> server != handshakeserver ) ? sc -> server -> auth . cipher_suite : NULL ) ; if ( ncipher_suite && ( ! sslconn -> cipher_suite || strcmp ( ncipher_suite , sslconn -> cipher_suite ) ) ) { if ( dc -> nOptions & SSL_OPT_OPTRENEGOTIATE ) { cipher = SSL_get_current_cipher ( ssl ) ; } else { cipher_list_old = ( STACK_OF ( SSL_CIPHER ) * ) SSL_get_ciphers ( ssl ) ; if ( cipher_list_old ) { cipher_list_old = sk_SSL_CIPHER_dup ( cipher_list_old ) ; } } if ( is_slave ) { apr_table_setn ( r -> notes , ""ssl-renegotiate-forbidden"" , ""cipher-suite"" ) ; return HTTP_FORBIDDEN ; } if ( ! SSL_set_cipher_list ( ssl , ncipher_suite ) ) { ap_log_rerror ( APLOG_MARK , APLOG_WARNING , 0 , r , APLOGNO ( 02253 ) ""Unable<S2SV_blank>to<S2SV_blank>reconfigure<S2SV_blank>(per-directory)<S2SV_blank>"" ""permitted<S2SV_blank>SSL<S2SV_blank>ciphers"" ) ; ssl_log_ssl_error ( SSLLOG_MARK , APLOG_ERR , r -> server ) ; if ( cipher_list_old ) { sk_SSL_CIPHER_free ( cipher_list_old ) ; } return HTTP_FORBIDDEN ; } cipher_list = ( STACK_OF ( SSL_CIPHER ) * ) SSL_get_ciphers ( ssl ) ; if ( dc -> nOptions & SSL_OPT_OPTRENEGOTIATE ) { if ( ( ! cipher && cipher_list ) || ( cipher && ! cipher_list ) ) { renegotiate = TRUE ; } else if ( cipher && cipher_list && ( sk_SSL_CIPHER_find ( cipher_list , cipher ) < 0 ) ) { renegotiate = TRUE ; } } else { if ( ( ! cipher_list_old && cipher_list ) || ( cipher_list_old && ! cipher_list ) ) { renegotiate = TRUE ; } else if ( cipher_list_old && cipher_list ) { for ( n = 0 ; ! renegotiate && ( n < sk_SSL_CIPHER_num ( cipher_list ) ) ; n ++ ) { const SSL_CIPHER * value = sk_SSL_CIPHER_value ( cipher_list , n ) ; if ( sk_SSL_CIPHER_find ( cipher_list_old , value ) < 0 ) { renegotiate = TRUE ; } } for ( n = 0 ; ! renegotiate && ( n < sk_SSL_CIPHER_num ( cipher_list_old ) ) ; n ++ ) { const SSL_CIPHER * value = sk_SSL_CIPHER_value ( cipher_list_old , n ) ; if ( sk_SSL_CIPHER_find ( cipher_list , value ) < 0 ) { renegotiate = TRUE ; } } } } if ( cipher_list_old ) { sk_SSL_CIPHER_free ( cipher_list_old ) ; } if ( renegotiate ) { if ( is_slave ) { apr_table_setn ( r -> notes , ""ssl-renegotiate-forbidden"" , ""cipher-suite"" ) ; return HTTP_FORBIDDEN ; } # ifdef SSL_OP_CIPHER_SERVER_PREFERENCE if ( sc -> cipher_server_pref == TRUE ) { SSL_set_options ( ssl , SSL_OP_CIPHER_SERVER_PREFERENCE ) ; } # endif ap_log_rerror ( APLOG_MARK , APLOG_DEBUG , 0 , r , APLOGNO ( 02220 ) ""Reconfigured<S2SV_blank>cipher<S2SV_blank>suite<S2SV_blank>will<S2SV_blank>force<S2SV_blank>renegotiation"" ) ; } } if ( ( dc -> nVerifyClient != SSL_CVERIFY_UNSET ) || ( sc -> server -> auth . verify_mode != SSL_CVERIFY_UNSET ) ) { verify_old = SSL_get_verify_mode ( ssl ) ; verify = SSL_VERIFY_NONE ; if ( ( dc -> nVerifyClient == SSL_CVERIFY_REQUIRE ) || ( sc -> server -> auth . verify_mode == SSL_CVERIFY_REQUIRE ) ) { verify |= SSL_VERIFY_PEER_STRICT ; } if ( ( dc -> nVerifyClient == SSL_CVERIFY_OPTIONAL ) || ( dc -> nVerifyClient == SSL_CVERIFY_OPTIONAL_NO_CA ) || ( sc -> server -> auth . verify_mode == SSL_CVERIFY_OPTIONAL ) || ( sc -> server -> auth . verify_mode == SSL_CVERIFY_OPTIONAL_NO_CA ) ) { verify |= SSL_VERIFY_PEER ; } SSL_set_verify ( ssl , verify , ssl_callback_SSLVerify ) ; SSL_set_verify_result ( ssl , X509_V_OK ) ; if ( ! renegotiate && verify != verify_old ) { if ( ( ( verify_old == SSL_VERIFY_NONE ) && ( verify != SSL_VERIFY_NONE ) ) || ( ! ( verify_old & SSL_VERIFY_PEER ) && ( verify & SSL_VERIFY_PEER ) ) || ( ! ( verify_old & SSL_VERIFY_FAIL_IF_NO_PEER_CERT ) && ( verify & SSL_VERIFY_FAIL_IF_NO_PEER_CERT ) ) ) { renegotiate = TRUE ; if ( is_slave ) { apr_table_setn ( r -> notes , ""ssl-renegotiate-forbidden"" , ""verify-client"" ) ; <S2SV_StartBug> return HTTP_FORBIDDEN ; <S2SV_EndBug> } if ( ( dc -> nOptions & SSL_OPT_OPTRENEGOTIATE ) && ( verify_old == SSL_VERIFY_NONE ) && ( ( peercert = SSL_get_peer_certificate ( ssl ) ) != NULL ) ) { renegotiate_quick = TRUE ; X509_free ( peercert ) ; } ap_log_rerror ( APLOG_MARK , APLOG_DEBUG , 0 , r , APLOGNO ( 02255 ) ""Changed<S2SV_blank>client<S2SV_blank>verification<S2SV_blank>type<S2SV_blank>will<S2SV_blank>force<S2SV_blank>"" ""%srenegotiation"" , renegotiate_quick ? ""quick<S2SV_blank>"" : """" ) ; } else if ( verify != SSL_VERIFY_NONE ) { n = ( sslconn -> verify_depth != UNSET ) ? sslconn -> verify_depth : hssc -> server -> auth . verify_depth ; sslconn -> verify_depth = ( dc -> nVerifyDepth != UNSET ) ? dc -> nVerifyDepth : sc -> server -> auth . verify_depth ; if ( sslconn -> verify_depth < n ) { renegotiate = TRUE ; ap_log_rerror ( APLOG_MARK , APLOG_DEBUG , 0 , r , APLOGNO ( 02254 ) ""Reduced<S2SV_blank>client<S2SV_blank>verification<S2SV_blank>depth<S2SV_blank>will<S2SV_blank>"" ""force<S2SV_blank>renegotiation"" ) ; } } } if ( ( r -> server != handshakeserver ) && renegotiate && ( ( verify & SSL_VERIFY_PEER ) || ( verify & SSL_VERIFY_FAIL_IF_NO_PEER_CERT ) ) ) { # define MODSSL_CFG_CA_NE ( f , sc1 , sc2 ) ( sc1 -> server -> auth . f && ( ! sc2 -> server -> auth . f || strNE ( sc1 -> server -> auth . f , sc2 -> server -> auth . f ) ) ) if ( MODSSL_CFG_CA_NE ( ca_cert_file , sc , hssc ) || MODSSL_CFG_CA_NE ( ca_cert_path , sc , hssc ) ) { if ( verify & SSL_VERIFY_FAIL_IF_NO_PEER_CERT ) { ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , APLOGNO ( 02256 ) ""Non-default<S2SV_blank>virtual<S2SV_blank>host<S2SV_blank>with<S2SV_blank>SSLVerify<S2SV_blank>set<S2SV_blank>to<S2SV_blank>"" ""\'require\'<S2SV_blank>and<S2SV_blank>VirtualHost-specific<S2SV_blank>CA<S2SV_blank>certificate<S2SV_blank>"" ""list<S2SV_blank>is<S2SV_blank>only<S2SV_blank>available<S2SV_blank>to<S2SV_blank>clients<S2SV_blank>with<S2SV_blank>TLS<S2SV_blank>server<S2SV_blank>"" ""name<S2SV_blank>indication<S2SV_blank>(SNI)<S2SV_blank>support"" ) ; SSL_set_verify ( ssl , verify_old , NULL ) ; return HTTP_FORBIDDEN ; } else sslconn -> verify_info = ""GENEROUS"" ; } } } if ( renegotiate && ! renegotiate_quick && ( apr_table_get ( r -> headers_in , ""transfer-encoding"" ) || ( apr_table_get ( r -> headers_in , ""content-length"" ) && strcmp ( apr_table_get ( r -> headers_in , ""content-length"" ) , ""0"" ) ) ) && ! r -> expecting_100 ) { int rv ; apr_size_t rsize ; rsize = dc -> nRenegBufferSize == UNSET ? DEFAULT_RENEG_BUFFER_SIZE : dc -> nRenegBufferSize ; if ( rsize > 0 ) { rv = ssl_io_buffer_fill ( r , rsize ) ; } else { rv = HTTP_REQUEST_ENTITY_TOO_LARGE ; } if ( rv ) { ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02257 ) ""could<S2SV_blank>not<S2SV_blank>buffer<S2SV_blank>message<S2SV_blank>body<S2SV_blank>to<S2SV_blank>allow<S2SV_blank>"" ""SSL<S2SV_blank>renegotiation<S2SV_blank>to<S2SV_blank>proceed"" ) ; return rv ; } } if ( renegotiate ) { ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , APLOGNO ( 02221 ) ""Requesting<S2SV_blank>connection<S2SV_blank>re-negotiation"" ) ; if ( renegotiate_quick ) { STACK_OF ( X509 ) * cert_stack ; ap_log_rerror ( APLOG_MARK , APLOG_DEBUG , 0 , r , APLOGNO ( 02258 ) ""Performing<S2SV_blank>quick<S2SV_blank>renegotiation:<S2SV_blank>"" ""just<S2SV_blank>re-verifying<S2SV_blank>the<S2SV_blank>peer"" ) ; cert_stack = ( STACK_OF ( X509 ) * ) SSL_get_peer_cert_chain ( ssl ) ; cert = SSL_get_peer_certificate ( ssl ) ; if ( ! cert_stack && cert ) { cert_stack = sk_X509_new_null ( ) ; sk_X509_push ( cert_stack , cert ) ; } if ( ! cert_stack || ( sk_X509_num ( cert_stack ) == 0 ) ) { ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02222 ) ""Cannot<S2SV_blank>find<S2SV_blank>peer<S2SV_blank>certificate<S2SV_blank>chain"" ) ; return HTTP_FORBIDDEN ; } if ( ! ( cert_store || ( cert_store = SSL_CTX_get_cert_store ( ctx ) ) ) ) { ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02223 ) ""Cannot<S2SV_blank>find<S2SV_blank>certificate<S2SV_blank>storage"" ) ; return HTTP_FORBIDDEN ; } if ( ! cert ) { cert = sk_X509_value ( cert_stack , 0 ) ; } cert_store_ctx = X509_STORE_CTX_new ( ) ; X509_STORE_CTX_init ( cert_store_ctx , cert_store , cert , cert_stack ) ; depth = SSL_get_verify_depth ( ssl ) ; if ( depth >= 0 ) { X509_STORE_CTX_set_depth ( cert_store_ctx , depth ) ; } X509_STORE_CTX_set_ex_data ( cert_store_ctx , SSL_get_ex_data_X509_STORE_CTX_idx ( ) , ( char * ) ssl ) ; if ( ! X509_verify_cert ( cert_store_ctx ) ) { ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02224 ) ""Re-negotiation<S2SV_blank>verification<S2SV_blank>step<S2SV_blank>failed"" ) ; ssl_log_ssl_error ( SSLLOG_MARK , APLOG_ERR , r -> server ) ; } SSL_set_verify_result ( ssl , X509_STORE_CTX_get_error ( cert_store_ctx ) ) ; X509_STORE_CTX_cleanup ( cert_store_ctx ) ; X509_STORE_CTX_free ( cert_store_ctx ) ; if ( cert_stack != SSL_get_peer_cert_chain ( ssl ) ) { sk_X509_pop_free ( cert_stack , X509_free ) ; } } else { char peekbuf [ 1 ] ; const char * reneg_support ; request_rec * id = r -> main ? r -> main : r ; if ( has_buffered_data ( r ) ) { ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02259 ) ""insecure<S2SV_blank>SSL<S2SV_blank>re-negotiation<S2SV_blank>required,<S2SV_blank>but<S2SV_blank>"" ""a<S2SV_blank>pipelined<S2SV_blank>request<S2SV_blank>is<S2SV_blank>present;<S2SV_blank>keepalive<S2SV_blank>"" ""disabled"" ) ; r -> connection -> keepalive = AP_CONN_CLOSE ; } # if defined ( SSL_get_secure_renegotiation_support ) reneg_support = SSL_get_secure_renegotiation_support ( ssl ) ? ""client<S2SV_blank>does"" : ""client<S2SV_blank>does<S2SV_blank>not"" ; # else reneg_support = ""server<S2SV_blank>does<S2SV_blank>not"" ; # endif ap_log_rerror ( APLOG_MARK , APLOG_DEBUG , 0 , r , APLOGNO ( 02260 ) ""Performing<S2SV_blank>full<S2SV_blank>renegotiation:<S2SV_blank>complete<S2SV_blank>handshake<S2SV_blank>"" ""protocol<S2SV_blank>(%s<S2SV_blank>support<S2SV_blank>secure<S2SV_blank>renegotiation)"" , reneg_support ) ; SSL_set_session_id_context ( ssl , ( unsigned char * ) & id , sizeof ( id ) ) ; sslconn -> reneg_state = RENEG_ALLOW ; SSL_renegotiate ( ssl ) ; SSL_do_handshake ( ssl ) ; if ( ! SSL_is_init_finished ( ssl ) ) { ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02225 ) ""Re-negotiation<S2SV_blank>request<S2SV_blank>failed"" ) ; ssl_log_ssl_error ( SSLLOG_MARK , APLOG_ERR , r -> server ) ; r -> connection -> keepalive = AP_CONN_CLOSE ; return HTTP_FORBIDDEN ; } ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , APLOGNO ( 02226 ) ""Awaiting<S2SV_blank>re-negotiation<S2SV_blank>handshake"" ) ; SSL_peek ( ssl , peekbuf , 0 ) ; sslconn -> reneg_state = RENEG_REJECT ; if ( ! SSL_is_init_finished ( ssl ) ) { ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02261 ) ""Re-negotiation<S2SV_blank>handshake<S2SV_blank>failed"" ) ; ssl_log_ssl_error ( SSLLOG_MARK , APLOG_ERR , r -> server ) ; r -> connection -> keepalive = AP_CONN_CLOSE ; return HTTP_FORBIDDEN ; } sslconn -> server = r -> server ; } if ( ( cert = SSL_get_peer_certificate ( ssl ) ) ) { if ( sslconn -> client_cert ) { X509_free ( sslconn -> client_cert ) ; } sslconn -> client_cert = cert ; sslconn -> client_dn = NULL ; } if ( ( dc -> nVerifyClient != SSL_CVERIFY_NONE ) || ( sc -> server -> auth . verify_mode != SSL_CVERIFY_NONE ) ) { BOOL do_verify = ( ( dc -> nVerifyClient == SSL_CVERIFY_REQUIRE ) || ( sc -> server -> auth . verify_mode == SSL_CVERIFY_REQUIRE ) ) ; if ( do_verify && ( SSL_get_verify_result ( ssl ) != X509_V_OK ) ) { ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02262 ) ""Re-negotiation<S2SV_blank>handshake<S2SV_blank>failed:<S2SV_blank>"" ""Client<S2SV_blank>verification<S2SV_blank>failed"" ) ; return HTTP_FORBIDDEN ; } if ( do_verify ) { if ( ( peercert = SSL_get_peer_certificate ( ssl ) ) == NULL ) { ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02263 ) ""Re-negotiation<S2SV_blank>handshake<S2SV_blank>failed:<S2SV_blank>"" ""Client<S2SV_blank>certificate<S2SV_blank>missing"" ) ; return HTTP_FORBIDDEN ; } X509_free ( peercert ) ; } } if ( cipher_list ) { cipher = SSL_get_current_cipher ( ssl ) ; if ( sk_SSL_CIPHER_find ( cipher_list , cipher ) < 0 ) { ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02264 ) ""SSL<S2SV_blank>cipher<S2SV_blank>suite<S2SV_blank>not<S2SV_blank>renegotiated:<S2SV_blank>"" ""access<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>denied<S2SV_blank>using<S2SV_blank>cipher<S2SV_blank>%s"" , r -> filename , SSL_CIPHER_get_name ( cipher ) ) ; return HTTP_FORBIDDEN ; } } if ( ncipher_suite ) { sslconn -> cipher_suite = ncipher_suite ; } } if ( ( dc -> nOptions & SSL_OPT_FAKEBASICAUTH ) == 0 && dc -> szUserName ) { char * val = ssl_var_lookup ( r -> pool , r -> server , r -> connection , r , ( char * ) dc -> szUserName ) ; if ( val && val [ 0 ] ) r -> user = val ; else ap_log_rerror ( APLOG_MARK , APLOG_WARNING , 0 , r , APLOGNO ( 02227 ) ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>r->user<S2SV_blank>to<S2SV_blank>\'%s\'"" , dc -> szUserName ) ; } requires = dc -> aRequirement ; ssl_requires = ( ssl_require_t * ) requires -> elts ; for ( i = 0 ; i < requires -> nelts ; i ++ ) { ssl_require_t * req = & ssl_requires [ i ] ; const char * errstring ; ok = ap_expr_exec ( r , req -> mpExpr , & errstring ) ; if ( ok < 0 ) { ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02265 ) ""access<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>failed,<S2SV_blank>reason:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>execute<S2SV_blank>"" ""SSL<S2SV_blank>requirement<S2SV_blank>expression:<S2SV_blank>%s"" , r -> filename , errstring ) ; apr_table_setn ( r -> notes , ""ssl-access-forbidden"" , ""1"" ) ; return HTTP_FORBIDDEN ; } if ( ok != 1 ) { ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , APLOGNO ( 02266 ) ""Access<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>denied<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>"" ""(requirement<S2SV_blank>expression<S2SV_blank>not<S2SV_blank>fulfilled)"" , r -> filename , r -> useragent_ip ) ; ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , APLOGNO ( 02228 ) ""Failed<S2SV_blank>expression:<S2SV_blank>%s"" , req -> cpExpr ) ; ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02229 ) ""access<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>failed,<S2SV_blank>reason:<S2SV_blank>%s"" , r -> filename , ""SSL<S2SV_blank>requirement<S2SV_blank>expression<S2SV_blank>not<S2SV_blank>fulfilled"" ) ; apr_table_setn ( r -> notes , ""ssl-access-forbidden"" , ""1"" ) ; return HTTP_FORBIDDEN ; } } return DECLINED ; }
","<S2SV_ModStart> ""verify-client"" ) ; SSL_set_verify ( ssl , verify_old , ssl_callback_SSLVerify ) ;
"
658,"CWE-119 void vp9_init_quantizer ( VP9_COMP * cpi ) { VP9_COMMON * const cm = & cpi -> common ; QUANTS * const quants = & cpi -> quants ; int i , q , quant ; for ( q = 0 ; q < QINDEX_RANGE ; q ++ ) { <S2SV_StartBug> const int qzbin_factor = q == 0 ? 64 : ( vp9_dc_quant ( q , 0 ) < 148 ? 84 : 80 ) ; <S2SV_EndBug> const int qrounding_factor = q == 0 ? 64 : 48 ; for ( i = 0 ; i < 2 ; ++ i ) { <S2SV_StartBug> quant = i == 0 ? vp9_dc_quant ( q , cm -> y_dc_delta_q ) <S2SV_EndBug> <S2SV_StartBug> : vp9_ac_quant ( q , 0 ) ; <S2SV_EndBug> invert_quant ( & quants -> y_quant [ q ] [ i ] , & quants -> y_quant_shift [ q ] [ i ] , quant ) ; <S2SV_StartBug> quants -> y_zbin [ q ] [ i ] = ROUND_POWER_OF_TWO ( qzbin_factor * quant , 7 ) ; <S2SV_EndBug> quants -> y_round [ q ] [ i ] = ( qrounding_factor * quant ) >> 7 ; <S2SV_StartBug> cm -> y_dequant [ q ] [ i ] = quant ; <S2SV_EndBug> <S2SV_StartBug> quant = i == 0 ? vp9_dc_quant ( q , cm -> uv_dc_delta_q ) <S2SV_EndBug> <S2SV_StartBug> : vp9_ac_quant ( q , cm -> uv_ac_delta_q ) ; <S2SV_EndBug> invert_quant ( & quants -> uv_quant [ q ] [ i ] , & quants -> uv_quant_shift [ q ] [ i ] , quant ) ; <S2SV_StartBug> quants -> uv_zbin [ q ] [ i ] = ROUND_POWER_OF_TWO ( qzbin_factor * quant , 7 ) ; <S2SV_EndBug> quants -> uv_round [ q ] [ i ] = ( qrounding_factor * quant ) >> 7 ; <S2SV_StartBug> cm -> uv_dequant [ q ] [ i ] = quant ; <S2SV_EndBug> # if CONFIG_ALPHA quant = i == 0 ? vp9_dc_quant ( q , cm -> a_dc_delta_q ) : vp9_ac_quant ( q , cm -> a_ac_delta_q ) ; invert_quant ( & quants -> a_quant [ q ] [ i ] , & quants -> a_quant_shift [ q ] [ i ] , quant ) ; quants -> a_zbin [ q ] [ i ] = ROUND_POWER_OF_TWO ( qzbin_factor * quant , 7 ) ; <S2SV_StartBug> quants -> a_round [ q ] [ i ] = ( qrounding_factor * quant ) >> 7 ; <S2SV_EndBug> <S2SV_StartBug> cm -> a_dequant [ q ] [ i ] = quant ; <S2SV_EndBug> # endif } for ( i = 2 ; i < 8 ; i ++ ) { quants -> y_quant [ q ] [ i ] = quants -> y_quant [ q ] [ 1 ] ; <S2SV_StartBug> quants -> y_quant_shift [ q ] [ i ] = quants -> y_quant_shift [ q ] [ 1 ] ; <S2SV_EndBug> quants -> y_zbin [ q ] [ i ] = quants -> y_zbin [ q ] [ 1 ] ; quants -> y_round [ q ] [ i ] = quants -> y_round [ q ] [ 1 ] ; <S2SV_StartBug> cm -> y_dequant [ q ] [ i ] = cm -> y_dequant [ q ] [ 1 ] ; <S2SV_EndBug> quants -> uv_quant [ q ] [ i ] = quants -> uv_quant [ q ] [ 1 ] ; <S2SV_StartBug> quants -> uv_quant_shift [ q ] [ i ] = quants -> uv_quant_shift [ q ] [ 1 ] ; <S2SV_EndBug> quants -> uv_zbin [ q ] [ i ] = quants -> uv_zbin [ q ] [ 1 ] ; quants -> uv_round [ q ] [ i ] = quants -> uv_round [ q ] [ 1 ] ; <S2SV_StartBug> cm -> uv_dequant [ q ] [ i ] = cm -> uv_dequant [ q ] [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> # if CONFIG_ALPHA <S2SV_EndBug> quants -> a_quant [ q ] [ i ] = quants -> a_quant [ q ] [ 1 ] ; quants -> a_quant_shift [ q ] [ i ] = quants -> a_quant_shift [ q ] [ 1 ] ; quants -> a_zbin [ q ] [ i ] = quants -> a_zbin [ q ] [ 1 ] ; quants -> a_round [ q ] [ i ] = quants -> a_round [ q ] [ 1 ] ; cm -> a_dequant [ q ] [ i ] = cm -> a_dequant [ q ] [ 1 ] ; # endif } } }
","<S2SV_ModStart> int qzbin_factor = get_qzbin_factor ( q , cm -> bit_depth <S2SV_ModEnd> ) ; const <S2SV_ModStart> i ) { int qrounding_factor_fp = i == 0 ? 48 : 42 ; if ( q == 0 ) qrounding_factor_fp = 64 ; <S2SV_ModStart> cm -> y_dc_delta_q , cm -> bit_depth <S2SV_ModStart> q , 0 , cm -> bit_depth <S2SV_ModStart> ; quants -> y_quant_fp [ q ] [ i ] = ( 1 << 16 ) / quant ; quants -> y_round_fp [ q ] [ i ] = ( qrounding_factor_fp <S2SV_ModEnd> * quant ) <S2SV_ModStart> >> 7 ; quants -> y_zbin [ q ] [ i ] = ROUND_POWER_OF_TWO ( qzbin_factor * quant , 7 ) ; quants -> y_round [ q ] [ i ] = ( qrounding_factor * quant ) >> 7 ; cpi <S2SV_ModEnd> -> y_dequant [ <S2SV_ModStart> cm -> uv_dc_delta_q , cm -> bit_depth <S2SV_ModStart> cm -> uv_ac_delta_q , cm -> bit_depth <S2SV_ModStart> ; quants -> uv_quant_fp [ q ] [ i ] = ( 1 << 16 ) / quant ; quants -> uv_round_fp [ q ] [ i ] = ( qrounding_factor_fp <S2SV_ModEnd> * quant ) <S2SV_ModStart> >> 7 ; quants -> uv_zbin <S2SV_ModEnd> [ q ] <S2SV_ModStart> ; quants -> uv_round <S2SV_ModEnd> [ q ] <S2SV_ModStart> >> 7 ; cpi -> uv_dequant [ q ] [ i ] = quant ; <S2SV_ModEnd> } for ( <S2SV_ModStart> ; quants -> y_quant_fp [ q ] [ i ] = quants -> y_quant_fp [ q ] [ 1 ] ; quants -> y_round_fp [ q ] [ i ] = quants -> y_round_fp [ q ] [ 1 ] ; quants -> <S2SV_ModStart> 1 ] ; cpi <S2SV_ModEnd> -> y_dequant [ <S2SV_ModStart> i ] = cpi <S2SV_ModEnd> -> y_dequant [ <S2SV_ModStart> ; quants -> uv_quant_fp [ q ] [ i ] = quants -> uv_quant_fp [ q ] [ 1 ] ; quants -> uv_round_fp [ q ] [ i ] = quants -> uv_round_fp [ q ] [ 1 ] ; quants -> <S2SV_ModStart> 1 ] ; cpi <S2SV_ModEnd> -> uv_dequant [ <S2SV_ModStart> i ] = cpi <S2SV_ModEnd> -> uv_dequant [ <S2SV_ModStart> 1 ] ; <S2SV_ModEnd> } } }
"
659,"CWE-189 BOOL license_read_scope_list ( wStream * s , SCOPE_LIST * scopeList ) { UINT32 i ; UINT32 scopeCount ; if ( Stream_GetRemainingLength ( s ) < 4 ) return FALSE ; <S2SV_StartBug> Stream_Read_UINT32 ( s , scopeCount ) ; <S2SV_EndBug> scopeList -> count = scopeCount ; scopeList -> array = ( LICENSE_BLOB * ) malloc ( sizeof ( LICENSE_BLOB ) * scopeCount ) ; for ( i = 0 ; i < scopeCount ; i ++ ) { scopeList -> array [ i ] . type = BB_SCOPE_BLOB ; if ( ! license_read_binary_blob ( s , & scopeList -> array [ i ] ) ) return FALSE ; } return TRUE ; }
","<S2SV_ModStart> , scopeCount ) ; if ( Stream_GetRemainingLength ( s ) / sizeof ( LICENSE_BLOB ) < scopeCount ) return FALSE
"
660,"CWE-119 static void sum_intra_stats ( FRAME_COUNTS * counts , const MODE_INFO * mi ) { <S2SV_StartBug> const MB_PREDICTION_MODE y_mode = mi -> mbmi . mode ; <S2SV_EndBug> <S2SV_StartBug> const MB_PREDICTION_MODE uv_mode = mi -> mbmi . uv_mode ; <S2SV_EndBug> const BLOCK_SIZE bsize = mi -> mbmi . sb_type ; if ( bsize < BLOCK_8X8 ) { int idx , idy ; const int num_4x4_w = num_4x4_blocks_wide_lookup [ bsize ] ; const int num_4x4_h = num_4x4_blocks_high_lookup [ bsize ] ; for ( idy = 0 ; idy < 2 ; idy += num_4x4_h ) for ( idx = 0 ; idx < 2 ; idx += num_4x4_w ) ++ counts -> y_mode [ 0 ] [ mi -> bmi [ idy * 2 + idx ] . as_mode ] ; } else { ++ counts -> y_mode [ size_group_lookup [ bsize ] ] [ y_mode ] ; } ++ counts -> uv_mode [ y_mode ] [ uv_mode ] ; }
","<S2SV_ModStart> ) { const PREDICTION_MODE <S2SV_ModEnd> y_mode = mi <S2SV_ModStart> mode ; const PREDICTION_MODE <S2SV_ModEnd> uv_mode = mi
"
661,"CWE-400 int do_mathemu ( struct pt_regs * regs , struct fpustate * f ) { unsigned long pc = regs -> tpc ; unsigned long tstate = regs -> tstate ; u32 insn = 0 ; int type = 0 ; # define TYPE ( ftt , r , ru , b , bu , a , au ) type = ( au << 2 ) | ( a << 0 ) | ( bu << 5 ) | ( b << 3 ) | ( ru << 8 ) | ( r << 6 ) | ( ftt << 9 ) int freg ; static u64 zero [ 2 ] = { 0L , 0L } ; int flags ; FP_DECL_EX ; FP_DECL_S ( SA ) ; FP_DECL_S ( SB ) ; FP_DECL_S ( SR ) ; FP_DECL_D ( DA ) ; FP_DECL_D ( DB ) ; FP_DECL_D ( DR ) ; FP_DECL_Q ( QA ) ; FP_DECL_Q ( QB ) ; FP_DECL_Q ( QR ) ; int IR ; long XR , xfsr ; if ( tstate & TSTATE_PRIV ) die_if_kernel ( ""unfinished/unimplemented<S2SV_blank>FPop<S2SV_blank>from<S2SV_blank>kernel"" , regs ) ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <S2SV_EndBug> if ( test_thread_flag ( TIF_32BIT ) ) pc = ( u32 ) pc ; if ( get_user ( insn , ( u32 __user * ) pc ) != - EFAULT ) { if ( ( insn & 0xc1f80000 ) == 0x81a00000 ) { switch ( ( insn >> 5 ) & 0x1ff ) { case FMOVQ : case FNEGQ : case FABSQ : TYPE ( 3 , 3 , 0 , 3 , 0 , 0 , 0 ) ; break ; case FSQRTQ : TYPE ( 3 , 3 , 1 , 3 , 1 , 0 , 0 ) ; break ; case FADDQ : case FSUBQ : case FMULQ : case FDIVQ : TYPE ( 3 , 3 , 1 , 3 , 1 , 3 , 1 ) ; break ; case FDMULQ : TYPE ( 3 , 3 , 1 , 2 , 1 , 2 , 1 ) ; break ; case FQTOX : TYPE ( 3 , 2 , 0 , 3 , 1 , 0 , 0 ) ; break ; case FXTOQ : TYPE ( 3 , 3 , 1 , 2 , 0 , 0 , 0 ) ; break ; case FQTOS : TYPE ( 3 , 1 , 1 , 3 , 1 , 0 , 0 ) ; break ; case FQTOD : TYPE ( 3 , 2 , 1 , 3 , 1 , 0 , 0 ) ; break ; case FITOQ : TYPE ( 3 , 3 , 1 , 1 , 0 , 0 , 0 ) ; break ; case FSTOQ : TYPE ( 3 , 3 , 1 , 1 , 1 , 0 , 0 ) ; break ; case FDTOQ : TYPE ( 3 , 3 , 1 , 2 , 1 , 0 , 0 ) ; break ; case FQTOI : TYPE ( 3 , 1 , 0 , 3 , 1 , 0 , 0 ) ; break ; case FSQRTS : { unsigned long x = current_thread_info ( ) -> xfsr [ 0 ] ; x = ( x >> 14 ) & 0xf ; TYPE ( x , 1 , 1 , 1 , 1 , 0 , 0 ) ; break ; } case FSQRTD : { unsigned long x = current_thread_info ( ) -> xfsr [ 0 ] ; x = ( x >> 14 ) & 0xf ; TYPE ( x , 2 , 1 , 2 , 1 , 0 , 0 ) ; break ; } case FADDD : case FSUBD : case FMULD : case FDIVD : TYPE ( 2 , 2 , 1 , 2 , 1 , 2 , 1 ) ; break ; case FADDS : case FSUBS : case FMULS : case FDIVS : TYPE ( 2 , 1 , 1 , 1 , 1 , 1 , 1 ) ; break ; case FSMULD : TYPE ( 2 , 2 , 1 , 1 , 1 , 1 , 1 ) ; break ; case FSTOX : TYPE ( 2 , 2 , 0 , 1 , 1 , 0 , 0 ) ; break ; case FDTOX : TYPE ( 2 , 2 , 0 , 2 , 1 , 0 , 0 ) ; break ; case FDTOS : TYPE ( 2 , 1 , 1 , 2 , 1 , 0 , 0 ) ; break ; case FSTOD : TYPE ( 2 , 2 , 1 , 1 , 1 , 0 , 0 ) ; break ; case FSTOI : TYPE ( 2 , 1 , 0 , 1 , 1 , 0 , 0 ) ; break ; case FDTOI : TYPE ( 2 , 1 , 0 , 2 , 1 , 0 , 0 ) ; break ; case FXTOS : TYPE ( 2 , 1 , 1 , 2 , 0 , 0 , 0 ) ; break ; case FXTOD : TYPE ( 2 , 2 , 1 , 2 , 0 , 0 , 0 ) ; break ; # if 0 case FITOS : TYPE ( 2 , 1 , 1 , 1 , 0 , 0 , 0 ) ; break ; # endif case FITOD : TYPE ( 2 , 2 , 1 , 1 , 0 , 0 , 0 ) ; break ; } } else if ( ( insn & 0xc1f80000 ) == 0x81a80000 ) { IR = 2 ; switch ( ( insn >> 5 ) & 0x1ff ) { case FCMPQ : TYPE ( 3 , 0 , 0 , 3 , 1 , 3 , 1 ) ; break ; case FCMPEQ : TYPE ( 3 , 0 , 0 , 3 , 1 , 3 , 1 ) ; break ; case FMOVQ0 : case FMOVQ1 : case FMOVQ2 : case FMOVQ3 : if ( ! ( ( insn >> 11 ) & 3 ) ) XR = current_thread_info ( ) -> xfsr [ 0 ] >> 10 ; else XR = current_thread_info ( ) -> xfsr [ 0 ] >> ( 30 + ( ( insn >> 10 ) & 0x6 ) ) ; XR &= 3 ; IR = 0 ; switch ( ( insn >> 14 ) & 0x7 ) { case 1 : if ( XR ) IR = 1 ; break ; case 2 : if ( XR == 1 || XR == 2 ) IR = 1 ; break ; case 3 : if ( XR & 1 ) IR = 1 ; break ; case 4 : if ( XR == 1 ) IR = 1 ; break ; case 5 : if ( XR & 2 ) IR = 1 ; break ; case 6 : if ( XR == 2 ) IR = 1 ; break ; case 7 : if ( XR == 3 ) IR = 1 ; break ; } if ( ( insn >> 14 ) & 8 ) IR ^= 1 ; break ; case FMOVQI : case FMOVQX : XR = regs -> tstate >> 32 ; if ( ( insn >> 5 ) & 0x80 ) XR >>= 4 ; XR &= 0xf ; IR = 0 ; freg = ( ( XR >> 2 ) ^ XR ) & 2 ; switch ( ( insn >> 14 ) & 0x7 ) { case 1 : if ( XR & 4 ) IR = 1 ; break ; case 2 : if ( ( XR & 4 ) || freg ) IR = 1 ; break ; case 3 : if ( freg ) IR = 1 ; break ; case 4 : if ( XR & 5 ) IR = 1 ; break ; case 5 : if ( XR & 1 ) IR = 1 ; break ; case 6 : if ( XR & 8 ) IR = 1 ; break ; case 7 : if ( XR & 2 ) IR = 1 ; break ; } if ( ( insn >> 14 ) & 8 ) IR ^= 1 ; break ; case FMOVQZ : case FMOVQLE : case FMOVQLZ : case FMOVQNZ : case FMOVQGZ : case FMOVQGE : freg = ( insn >> 14 ) & 0x1f ; if ( ! freg ) XR = 0 ; else if ( freg < 16 ) XR = regs -> u_regs [ freg ] ; else if ( test_thread_flag ( TIF_32BIT ) ) { struct reg_window32 __user * win32 ; flushw_user ( ) ; win32 = ( struct reg_window32 __user * ) ( ( unsigned long ) ( ( u32 ) regs -> u_regs [ UREG_FP ] ) ) ; get_user ( XR , & win32 -> locals [ freg - 16 ] ) ; } else { struct reg_window __user * win ; flushw_user ( ) ; win = ( struct reg_window __user * ) ( regs -> u_regs [ UREG_FP ] + STACK_BIAS ) ; get_user ( XR , & win -> locals [ freg - 16 ] ) ; } IR = 0 ; switch ( ( insn >> 10 ) & 3 ) { case 1 : if ( ! XR ) IR = 1 ; break ; case 2 : if ( XR <= 0 ) IR = 1 ; break ; case 3 : if ( XR < 0 ) IR = 1 ; break ; } if ( ( insn >> 10 ) & 4 ) IR ^= 1 ; break ; } if ( IR == 0 ) { current_thread_info ( ) -> xfsr [ 0 ] &= ~ ( FSR_CEXC_MASK ) ; regs -> tpc = regs -> tnpc ; regs -> tnpc += 4 ; return 1 ; } else if ( IR == 1 ) { insn = ( insn & 0x3e00001f ) | 0x81a00060 ; TYPE ( 3 , 3 , 0 , 3 , 0 , 0 , 0 ) ; } } } if ( type ) { argp rs1 = NULL , rs2 = NULL , rd = NULL ; freg = ( current_thread_info ( ) -> xfsr [ 0 ] >> 14 ) & 0xf ; if ( freg != ( type >> 9 ) ) goto err ; current_thread_info ( ) -> xfsr [ 0 ] &= ~ 0x1c000 ; freg = ( ( insn >> 14 ) & 0x1f ) ; switch ( type & 0x3 ) { case 3 : if ( freg & 2 ) { current_thread_info ( ) -> xfsr [ 0 ] |= ( 6 << 14 ) ; goto err ; } case 2 : freg = ( ( freg & 1 ) << 5 ) | ( freg & 0x1e ) ; case 1 : rs1 = ( argp ) & f -> regs [ freg ] ; flags = ( freg < 32 ) ? FPRS_DL : FPRS_DU ; if ( ! ( current_thread_info ( ) -> fpsaved [ 0 ] & flags ) ) rs1 = ( argp ) & zero ; break ; } switch ( type & 0x7 ) { case 7 : FP_UNPACK_QP ( QA , rs1 ) ; break ; case 6 : FP_UNPACK_DP ( DA , rs1 ) ; break ; case 5 : FP_UNPACK_SP ( SA , rs1 ) ; break ; } freg = ( insn & 0x1f ) ; switch ( ( type >> 3 ) & 0x3 ) { case 3 : if ( freg & 2 ) { current_thread_info ( ) -> xfsr [ 0 ] |= ( 6 << 14 ) ; goto err ; } case 2 : freg = ( ( freg & 1 ) << 5 ) | ( freg & 0x1e ) ; case 1 : rs2 = ( argp ) & f -> regs [ freg ] ; flags = ( freg < 32 ) ? FPRS_DL : FPRS_DU ; if ( ! ( current_thread_info ( ) -> fpsaved [ 0 ] & flags ) ) rs2 = ( argp ) & zero ; break ; } switch ( ( type >> 3 ) & 0x7 ) { case 7 : FP_UNPACK_QP ( QB , rs2 ) ; break ; case 6 : FP_UNPACK_DP ( DB , rs2 ) ; break ; case 5 : FP_UNPACK_SP ( SB , rs2 ) ; break ; } freg = ( ( insn >> 25 ) & 0x1f ) ; switch ( ( type >> 6 ) & 0x3 ) { case 3 : if ( freg & 2 ) { current_thread_info ( ) -> xfsr [ 0 ] |= ( 6 << 14 ) ; goto err ; } case 2 : freg = ( ( freg & 1 ) << 5 ) | ( freg & 0x1e ) ; case 1 : rd = ( argp ) & f -> regs [ freg ] ; flags = ( freg < 32 ) ? FPRS_DL : FPRS_DU ; if ( ! ( current_thread_info ( ) -> fpsaved [ 0 ] & FPRS_FEF ) ) { current_thread_info ( ) -> fpsaved [ 0 ] = FPRS_FEF ; current_thread_info ( ) -> gsr [ 0 ] = 0 ; } if ( ! ( current_thread_info ( ) -> fpsaved [ 0 ] & flags ) ) { if ( freg < 32 ) memset ( f -> regs , 0 , 32 * sizeof ( u32 ) ) ; else memset ( f -> regs + 32 , 0 , 32 * sizeof ( u32 ) ) ; } current_thread_info ( ) -> fpsaved [ 0 ] |= flags ; break ; } switch ( ( insn >> 5 ) & 0x1ff ) { case FADDS : FP_ADD_S ( SR , SA , SB ) ; break ; case FADDD : FP_ADD_D ( DR , DA , DB ) ; break ; case FADDQ : FP_ADD_Q ( QR , QA , QB ) ; break ; case FSUBS : FP_SUB_S ( SR , SA , SB ) ; break ; case FSUBD : FP_SUB_D ( DR , DA , DB ) ; break ; case FSUBQ : FP_SUB_Q ( QR , QA , QB ) ; break ; case FMULS : FP_MUL_S ( SR , SA , SB ) ; break ; case FSMULD : FP_CONV ( D , S , 1 , 1 , DA , SA ) ; FP_CONV ( D , S , 1 , 1 , DB , SB ) ; case FMULD : FP_MUL_D ( DR , DA , DB ) ; break ; case FDMULQ : FP_CONV ( Q , D , 2 , 1 , QA , DA ) ; FP_CONV ( Q , D , 2 , 1 , QB , DB ) ; case FMULQ : FP_MUL_Q ( QR , QA , QB ) ; break ; case FDIVS : FP_DIV_S ( SR , SA , SB ) ; break ; case FDIVD : FP_DIV_D ( DR , DA , DB ) ; break ; case FDIVQ : FP_DIV_Q ( QR , QA , QB ) ; break ; case FSQRTS : FP_SQRT_S ( SR , SB ) ; break ; case FSQRTD : FP_SQRT_D ( DR , DB ) ; break ; case FSQRTQ : FP_SQRT_Q ( QR , QB ) ; break ; case FMOVQ : rd -> q [ 0 ] = rs2 -> q [ 0 ] ; rd -> q [ 1 ] = rs2 -> q [ 1 ] ; break ; case FABSQ : rd -> q [ 0 ] = rs2 -> q [ 0 ] & 0x7fffffffffffffffUL ; rd -> q [ 1 ] = rs2 -> q [ 1 ] ; break ; case FNEGQ : rd -> q [ 0 ] = rs2 -> q [ 0 ] ^ 0x8000000000000000UL ; rd -> q [ 1 ] = rs2 -> q [ 1 ] ; break ; case FSTOI : FP_TO_INT_S ( IR , SB , 32 , 1 ) ; break ; case FDTOI : FP_TO_INT_D ( IR , DB , 32 , 1 ) ; break ; case FQTOI : FP_TO_INT_Q ( IR , QB , 32 , 1 ) ; break ; case FSTOX : FP_TO_INT_S ( XR , SB , 64 , 1 ) ; break ; case FDTOX : FP_TO_INT_D ( XR , DB , 64 , 1 ) ; break ; case FQTOX : FP_TO_INT_Q ( XR , QB , 64 , 1 ) ; break ; case FITOQ : IR = rs2 -> s ; FP_FROM_INT_Q ( QR , IR , 32 , int ) ; break ; case FXTOQ : XR = rs2 -> d ; FP_FROM_INT_Q ( QR , XR , 64 , long ) ; break ; case FXTOS : XR = rs2 -> d ; FP_FROM_INT_S ( SR , XR , 64 , long ) ; break ; case FXTOD : XR = rs2 -> d ; FP_FROM_INT_D ( DR , XR , 64 , long ) ; break ; # if 0 case FITOS : IR = rs2 -> s ; FP_FROM_INT_S ( SR , IR , 32 , int ) ; break ; # endif case FITOD : IR = rs2 -> s ; FP_FROM_INT_D ( DR , IR , 32 , int ) ; break ; case FSTOD : FP_CONV ( D , S , 1 , 1 , DR , SB ) ; break ; case FSTOQ : FP_CONV ( Q , S , 2 , 1 , QR , SB ) ; break ; case FDTOQ : FP_CONV ( Q , D , 2 , 1 , QR , DB ) ; break ; case FDTOS : FP_CONV ( S , D , 1 , 1 , SR , DB ) ; break ; case FQTOS : FP_CONV ( S , Q , 1 , 2 , SR , QB ) ; break ; case FQTOD : FP_CONV ( D , Q , 1 , 2 , DR , QB ) ; break ; case FCMPQ : case FCMPEQ : FP_CMP_Q ( XR , QB , QA , 3 ) ; if ( XR == 3 && ( ( ( insn >> 5 ) & 0x1ff ) == FCMPEQ || FP_ISSIGNAN_Q ( QA ) || FP_ISSIGNAN_Q ( QB ) ) ) FP_SET_EXCEPTION ( FP_EX_INVALID ) ; } if ( ! FP_INHIBIT_RESULTS ) { switch ( ( type >> 6 ) & 0x7 ) { case 0 : xfsr = current_thread_info ( ) -> xfsr [ 0 ] ; if ( XR == - 1 ) XR = 2 ; switch ( freg & 3 ) { case 0 : xfsr &= ~ 0xc00 ; xfsr |= ( XR << 10 ) ; break ; case 1 : xfsr &= ~ 0x300000000UL ; xfsr |= ( XR << 32 ) ; break ; case 2 : xfsr &= ~ 0xc00000000UL ; xfsr |= ( XR << 34 ) ; break ; case 3 : xfsr &= ~ 0x3000000000UL ; xfsr |= ( XR << 36 ) ; break ; } current_thread_info ( ) -> xfsr [ 0 ] = xfsr ; break ; case 1 : rd -> s = IR ; break ; case 2 : rd -> d = XR ; break ; case 5 : FP_PACK_SP ( rd , SR ) ; break ; case 6 : FP_PACK_DP ( rd , DR ) ; break ; case 7 : FP_PACK_QP ( rd , QR ) ; break ; } } if ( _fex != 0 ) return record_exception ( regs , _fex ) ; current_thread_info ( ) -> xfsr [ 0 ] &= ~ ( FSR_CEXC_MASK ) ; regs -> tpc = regs -> tnpc ; regs -> tnpc += 4 ; return 1 ; } err : return 0 ; }
","<S2SV_ModStart> PERF_COUNT_SW_EMULATION_FAULTS , 1 <S2SV_ModEnd> , regs ,
"
662,"CWE-399 int do_fpu_inst ( unsigned short inst , struct pt_regs * regs ) { struct task_struct * tsk = current ; struct sh_fpu_soft_struct * fpu = & ( tsk -> thread . xstate -> softfpu ) ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <S2SV_EndBug> if ( ! ( task_thread_info ( tsk ) -> status & TS_USEDFPU ) ) { fpu_init ( fpu ) ; task_thread_info ( tsk ) -> status |= TS_USEDFPU ; } return fpu_emulate ( inst , fpu , regs ) ; }
","<S2SV_ModStart> PERF_COUNT_SW_EMULATION_FAULTS , 1 <S2SV_ModEnd> , regs ,
"
663,"CWE-78 static char_u * do_one_cmd ( char_u * * cmdlinep , int sourcing , # ifdef FEAT_EVAL struct condstack * cstack , # endif char_u * ( * fgetline ) ( int , void * , int ) , void * cookie ) { char_u * p ; linenr_T lnum ; long n ; char * errormsg = NULL ; char_u * after_modifier = NULL ; exarg_T ea ; int save_msg_scroll = msg_scroll ; cmdmod_T save_cmdmod ; int ni ; char_u * cmd ; vim_memset ( & ea , 0 , sizeof ( ea ) ) ; ea . line1 = 1 ; ea . line2 = 1 ; # ifdef FEAT_EVAL ++ ex_nesting_level ; # endif if ( quitmore # ifdef FEAT_EVAL && ! getline_equal ( fgetline , cookie , get_func_line ) # endif && ! getline_equal ( fgetline , cookie , getnextac ) ) -- quitmore ; save_cmdmod = cmdmod ; if ( ( * cmdlinep ) [ 0 ] == '#' && ( * cmdlinep ) [ 1 ] == '!' ) goto doend ; ea . cmd = * cmdlinep ; ea . cmdlinep = cmdlinep ; ea . getline = fgetline ; ea . cookie = cookie ; # ifdef FEAT_EVAL ea . cstack = cstack ; # endif if ( parse_command_modifiers ( & ea , & errormsg , FALSE ) == FAIL ) goto doend ; after_modifier = ea . cmd ; # ifdef FEAT_EVAL ea . skip = did_emsg || got_int || did_throw || ( cstack -> cs_idx >= 0 && ! ( cstack -> cs_flags [ cstack -> cs_idx ] & CSF_ACTIVE ) ) ; # else ea . skip = ( if_level > 0 ) ; # endif cmd = ea . cmd ; ea . cmd = skip_range ( ea . cmd , NULL ) ; if ( * ea . cmd == '*' && vim_strchr ( p_cpo , CPO_STAR ) == NULL ) ea . cmd = skipwhite ( ea . cmd + 1 ) ; p = find_command ( & ea , NULL ) ; # ifdef FEAT_EVAL # ifdef FEAT_PROFILE if ( do_profiling == PROF_YES && ( ! ea . skip || cstack -> cs_idx == 0 || ( cstack -> cs_idx > 0 && ( cstack -> cs_flags [ cstack -> cs_idx - 1 ] & CSF_ACTIVE ) ) ) ) { int skip = did_emsg || got_int || did_throw ; if ( ea . cmdidx == CMD_catch ) skip = ! skip && ! ( cstack -> cs_idx >= 0 && ( cstack -> cs_flags [ cstack -> cs_idx ] & CSF_THROWN ) && ! ( cstack -> cs_flags [ cstack -> cs_idx ] & CSF_CAUGHT ) ) ; else if ( ea . cmdidx == CMD_else || ea . cmdidx == CMD_elseif ) skip = skip || ! ( cstack -> cs_idx >= 0 && ! ( cstack -> cs_flags [ cstack -> cs_idx ] & ( CSF_ACTIVE | CSF_TRUE ) ) ) ; else if ( ea . cmdidx == CMD_finally ) skip = FALSE ; else if ( ea . cmdidx != CMD_endif && ea . cmdidx != CMD_endfor && ea . cmdidx != CMD_endtry && ea . cmdidx != CMD_endwhile ) skip = ea . skip ; if ( ! skip ) { if ( getline_equal ( fgetline , cookie , get_func_line ) ) func_line_exec ( getline_cookie ( fgetline , cookie ) ) ; else if ( getline_equal ( fgetline , cookie , getsourceline ) ) script_line_exec ( ) ; } } # endif dbg_check_breakpoint ( & ea ) ; if ( ! ea . skip && got_int ) { ea . skip = TRUE ; ( void ) do_intthrow ( cstack ) ; } # endif if ( ! IS_USER_CMDIDX ( ea . cmdidx ) ) { if ( ea . cmdidx != CMD_SIZE ) ea . addr_type = cmdnames [ ( int ) ea . cmdidx ] . cmd_addr_type ; else ea . addr_type = ADDR_LINES ; if ( ea . cmdidx == CMD_wincmd && p != NULL ) get_wincmd_addr_type ( skipwhite ( p ) , & ea ) ; } ea . cmd = cmd ; if ( parse_cmd_address ( & ea , & errormsg , FALSE ) == FAIL ) goto doend ; ea . cmd = skipwhite ( ea . cmd ) ; while ( * ea . cmd == ':' ) ea . cmd = skipwhite ( ea . cmd + 1 ) ; if ( * ea . cmd == NUL || * ea . cmd == \'""\' || ( ea . nextcmd = check_nextcmd ( ea . cmd ) ) != NULL ) { if ( ea . skip ) goto doend ; if ( * ea . cmd == '|' || ( exmode_active && ea . line1 != ea . line2 ) ) { ea . cmdidx = CMD_print ; ea . argt = RANGE + COUNT + TRLBAR ; if ( ( errormsg = invalid_range ( & ea ) ) == NULL ) { correct_range ( & ea ) ; ex_print ( & ea ) ; } } else if ( ea . addr_count != 0 ) { if ( ea . line2 > curbuf -> b_ml . ml_line_count ) { if ( vim_strchr ( p_cpo , CPO_MINUS ) != NULL ) ea . line2 = - 1 ; else ea . line2 = curbuf -> b_ml . ml_line_count ; } if ( ea . line2 < 0 ) errormsg = _ ( e_invrange ) ; else { if ( ea . line2 == 0 ) curwin -> w_cursor . lnum = 1 ; else curwin -> w_cursor . lnum = ea . line2 ; beginline ( BL_SOL | BL_FIX ) ; } } goto doend ; } if ( p != NULL && ea . cmdidx == CMD_SIZE && ! ea . skip && ASCII_ISUPPER ( * ea . cmd ) && has_cmdundefined ( ) ) { int ret ; p = ea . cmd ; while ( ASCII_ISALNUM ( * p ) ) ++ p ; p = vim_strnsave ( ea . cmd , ( int ) ( p - ea . cmd ) ) ; ret = apply_autocmds ( EVENT_CMDUNDEFINED , p , p , TRUE , NULL ) ; vim_free ( p ) ; p = ( ret # ifdef FEAT_EVAL && ! aborting ( ) # endif ) ? find_command ( & ea , NULL ) : ea . cmd ; } # ifdef FEAT_USR_CMDS if ( p == NULL ) { if ( ! ea . skip ) errormsg = _ ( ""E464:<S2SV_blank>Ambiguous<S2SV_blank>use<S2SV_blank>of<S2SV_blank>user-defined<S2SV_blank>command"" ) ; goto doend ; } if ( * p == '!' && ea . cmd [ 1 ] == 0151 && ea . cmd [ 0 ] == 78 && ! IS_USER_CMDIDX ( ea . cmdidx ) ) { errormsg = uc_fun_cmd ( ) ; goto doend ; } # endif if ( ea . cmdidx == CMD_SIZE ) { if ( ! ea . skip ) { STRCPY ( IObuff , _ ( ""E492:<S2SV_blank>Not<S2SV_blank>an<S2SV_blank>editor<S2SV_blank>command"" ) ) ; if ( ! sourcing ) { if ( after_modifier != NULL ) append_command ( after_modifier ) ; else append_command ( * cmdlinep ) ; } errormsg = ( char * ) IObuff ; did_emsg_syntax = TRUE ; } goto doend ; } ni = ( ! IS_USER_CMDIDX ( ea . cmdidx ) && ( cmdnames [ ea . cmdidx ] . cmd_func == ex_ni # ifdef HAVE_EX_SCRIPT_NI || cmdnames [ ea . cmdidx ] . cmd_func == ex_script_ni # endif ) ) ; # ifndef FEAT_EVAL if ( ea . cmdidx == CMD_if ) ++ if_level ; if ( if_level ) { if ( ea . cmdidx == CMD_endif ) -- if_level ; goto doend ; } # endif if ( * p == '!' && ea . cmdidx != CMD_substitute && ea . cmdidx != CMD_smagic && ea . cmdidx != CMD_snomagic ) { ++ p ; ea . forceit = TRUE ; } else ea . forceit = FALSE ; if ( ! IS_USER_CMDIDX ( ea . cmdidx ) ) ea . argt = ( long ) cmdnames [ ( int ) ea . cmdidx ] . cmd_argt ; if ( ! ea . skip ) { # ifdef HAVE_SANDBOX if ( sandbox != 0 && ! ( ea . argt & SBOXOK ) ) { errormsg = _ ( e_sandbox ) ; goto doend ; } # endif <S2SV_StartBug> if ( ! curbuf -> b_p_ma && ( ea . argt & MODIFY ) ) <S2SV_EndBug> { errormsg = _ ( e_modifiable ) ; goto doend ; } if ( text_locked ( ) && ! ( ea . argt & CMDWIN ) && ! IS_USER_CMDIDX ( ea . cmdidx ) ) { errormsg = _ ( get_text_locked_msg ( ) ) ; goto doend ; } if ( ! ( ea . argt & CMDWIN ) && ea . cmdidx != CMD_checktime && ea . cmdidx != CMD_edit && ea . cmdidx != CMD_file && ! IS_USER_CMDIDX ( ea . cmdidx ) && curbuf_locked ( ) ) goto doend ; if ( ! ni && ! ( ea . argt & RANGE ) && ea . addr_count > 0 ) { errormsg = _ ( e_norange ) ; goto doend ; } } if ( ! ni && ! ( ea . argt & BANG ) && ea . forceit ) { errormsg = _ ( e_nobang ) ; goto doend ; } if ( ! ea . skip && ! ni ) { if ( ! global_busy && ea . line1 > ea . line2 ) { if ( msg_silent == 0 ) { if ( sourcing || exmode_active ) { errormsg = _ ( ""E493:<S2SV_blank>Backwards<S2SV_blank>range<S2SV_blank>given"" ) ; goto doend ; } if ( ask_yesno ( ( char_u * ) _ ( ""Backwards<S2SV_blank>range<S2SV_blank>given,<S2SV_blank>OK<S2SV_blank>to<S2SV_blank>swap"" ) , FALSE ) != 'y' ) goto doend ; } lnum = ea . line1 ; ea . line1 = ea . line2 ; ea . line2 = lnum ; } if ( ( errormsg = invalid_range ( & ea ) ) != NULL ) goto doend ; } if ( ( ea . argt & NOTADR ) && ea . addr_count == 0 ) ea . line2 = 1 ; correct_range ( & ea ) ; # ifdef FEAT_FOLDING if ( ( ( ea . argt & WHOLEFOLD ) || ea . addr_count >= 2 ) && ! global_busy && ea . addr_type == ADDR_LINES ) { ( void ) hasFolding ( ea . line1 , & ea . line1 , NULL ) ; ( void ) hasFolding ( ea . line2 , NULL , & ea . line2 ) ; } # endif # ifdef FEAT_QUICKFIX p = replace_makeprg ( & ea , p , cmdlinep ) ; if ( p == NULL ) goto doend ; # endif if ( ea . cmdidx == CMD_bang ) ea . arg = p ; else ea . arg = skipwhite ( p ) ; if ( ea . cmdidx == CMD_file && * ea . arg != NUL && curbuf_locked ( ) ) goto doend ; if ( ea . argt & ARGOPT ) while ( ea . arg [ 0 ] == '+' && ea . arg [ 1 ] == '+' ) if ( getargopt ( & ea ) == FAIL && ! ni ) { errormsg = _ ( e_invarg ) ; goto doend ; } if ( ea . cmdidx == CMD_write || ea . cmdidx == CMD_update ) { if ( * ea . arg == '>' ) { if ( * ++ ea . arg != '>' ) { errormsg = _ ( ""E494:<S2SV_blank>Use<S2SV_blank>w<S2SV_blank>or<S2SV_blank>w>>"" ) ; goto doend ; } ea . arg = skipwhite ( ea . arg + 1 ) ; ea . append = TRUE ; } else if ( * ea . arg == '!' && ea . cmdidx == CMD_write ) { ++ ea . arg ; ea . usefilter = TRUE ; } } if ( ea . cmdidx == CMD_read ) { if ( ea . forceit ) { ea . usefilter = TRUE ; ea . forceit = FALSE ; } else if ( * ea . arg == '!' ) { ++ ea . arg ; ea . usefilter = TRUE ; } } if ( ea . cmdidx == CMD_lshift || ea . cmdidx == CMD_rshift ) { ea . amount = 1 ; while ( * ea . arg == * ea . cmd ) { ++ ea . arg ; ++ ea . amount ; } ea . arg = skipwhite ( ea . arg ) ; } if ( ( ea . argt & EDITCMD ) && ! ea . usefilter ) ea . do_ecmd_cmd = getargcmd ( & ea . arg ) ; if ( ( ea . argt & TRLBAR ) && ! ea . usefilter ) separate_nextcmd ( & ea ) ; else if ( ea . cmdidx == CMD_bang || ea . cmdidx == CMD_terminal || ea . cmdidx == CMD_global || ea . cmdidx == CMD_vglobal || ea . usefilter ) { for ( p = ea . arg ; * p ; ++ p ) { if ( * p == '\\\\' && p [ 1 ] == '\\n' ) STRMOVE ( p , p + 1 ) ; else if ( * p == '\\n' ) { ea . nextcmd = p + 1 ; * p = NUL ; break ; } } } if ( ( ea . argt & DFLALL ) && ea . addr_count == 0 ) { buf_T * buf ; ea . line1 = 1 ; switch ( ea . addr_type ) { case ADDR_LINES : ea . line2 = curbuf -> b_ml . ml_line_count ; break ; case ADDR_LOADED_BUFFERS : buf = firstbuf ; while ( buf -> b_next != NULL && buf -> b_ml . ml_mfp == NULL ) buf = buf -> b_next ; ea . line1 = buf -> b_fnum ; buf = lastbuf ; while ( buf -> b_prev != NULL && buf -> b_ml . ml_mfp == NULL ) buf = buf -> b_prev ; ea . line2 = buf -> b_fnum ; break ; case ADDR_BUFFERS : ea . line1 = firstbuf -> b_fnum ; ea . line2 = lastbuf -> b_fnum ; break ; case ADDR_WINDOWS : ea . line2 = LAST_WIN_NR ; break ; case ADDR_TABS : ea . line2 = LAST_TAB_NR ; break ; case ADDR_TABS_RELATIVE : ea . line2 = 1 ; break ; case ADDR_ARGUMENTS : if ( ARGCOUNT == 0 ) ea . line1 = ea . line2 = 0 ; else ea . line2 = ARGCOUNT ; break ; # ifdef FEAT_QUICKFIX case ADDR_QUICKFIX : ea . line2 = qf_get_size ( & ea ) ; if ( ea . line2 == 0 ) ea . line2 = 1 ; break ; # endif } } if ( ( ea . argt & REGSTR ) && * ea . arg != NUL && ( ! IS_USER_CMDIDX ( ea . cmdidx ) || * ea . arg != '=' ) && ! ( ( ea . argt & COUNT ) && VIM_ISDIGIT ( * ea . arg ) ) ) { # ifndef FEAT_CLIPBOARD if ( * ea . arg == '*' || * ea . arg == '+' ) { errormsg = _ ( e_invalidreg ) ; goto doend ; } # endif if ( valid_yank_reg ( * ea . arg , ( ea . cmdidx != CMD_put && ! IS_USER_CMDIDX ( ea . cmdidx ) ) ) ) { ea . regname = * ea . arg ++ ; # ifdef FEAT_EVAL if ( ea . arg [ - 1 ] == '=' && ea . arg [ 0 ] != NUL ) { set_expr_line ( vim_strsave ( ea . arg ) ) ; ea . arg += STRLEN ( ea . arg ) ; } # endif ea . arg = skipwhite ( ea . arg ) ; } } if ( ( ea . argt & COUNT ) && VIM_ISDIGIT ( * ea . arg ) && ( ! ( ea . argt & BUFNAME ) || * ( p = skipdigits ( ea . arg ) ) == NUL || VIM_ISWHITE ( * p ) ) ) { n = getdigits ( & ea . arg ) ; ea . arg = skipwhite ( ea . arg ) ; if ( n <= 0 && ! ni && ( ea . argt & ZEROR ) == 0 ) { errormsg = _ ( e_zerocount ) ; goto doend ; } if ( ea . argt & NOTADR ) { ea . line2 = n ; if ( ea . addr_count == 0 ) ea . addr_count = 1 ; } else { ea . line1 = ea . line2 ; ea . line2 += n - 1 ; ++ ea . addr_count ; if ( ea . addr_type == ADDR_LINES && ea . line2 > curbuf -> b_ml . ml_line_count ) ea . line2 = curbuf -> b_ml . ml_line_count ; } } if ( ea . argt & EXFLAGS ) get_flags ( & ea ) ; if ( ! ni && ! ( ea . argt & EXTRA ) && * ea . arg != NUL && * ea . arg != \'""\' && ( * ea . arg != '|' || ( ea . argt & TRLBAR ) == 0 ) ) { errormsg = _ ( e_trailing ) ; goto doend ; } if ( ! ni && ( ea . argt & NEEDARG ) && * ea . arg == NUL ) { errormsg = _ ( e_argreq ) ; goto doend ; } # ifdef FEAT_EVAL if ( ea . skip ) { switch ( ea . cmdidx ) { case CMD_while : case CMD_endwhile : case CMD_for : case CMD_endfor : case CMD_if : case CMD_elseif : case CMD_else : case CMD_endif : case CMD_try : case CMD_catch : case CMD_finally : case CMD_endtry : case CMD_function : break ; case CMD_aboveleft : case CMD_and : case CMD_belowright : case CMD_botright : case CMD_browse : case CMD_call : case CMD_confirm : case CMD_delfunction : case CMD_djump : case CMD_dlist : case CMD_dsearch : case CMD_dsplit : case CMD_echo : case CMD_echoerr : case CMD_echomsg : case CMD_echon : case CMD_execute : case CMD_filter : case CMD_help : case CMD_hide : case CMD_ijump : case CMD_ilist : case CMD_isearch : case CMD_isplit : case CMD_keepalt : case CMD_keepjumps : case CMD_keepmarks : case CMD_keeppatterns : case CMD_leftabove : case CMD_let : case CMD_lockmarks : case CMD_lua : case CMD_match : case CMD_mzscheme : case CMD_noautocmd : case CMD_noswapfile : case CMD_perl : case CMD_psearch : case CMD_python : case CMD_py3 : case CMD_python3 : case CMD_return : case CMD_rightbelow : case CMD_ruby : case CMD_silent : case CMD_smagic : case CMD_snomagic : case CMD_substitute : case CMD_syntax : case CMD_tab : case CMD_tcl : case CMD_throw : case CMD_tilde : case CMD_topleft : case CMD_unlet : case CMD_verbose : case CMD_vertical : case CMD_wincmd : break ; default : goto doend ; } } # endif if ( ea . argt & XFILE ) { if ( expand_filename ( & ea , cmdlinep , & errormsg ) == FAIL ) goto doend ; } if ( ( ea . argt & BUFNAME ) && * ea . arg != NUL && ea . addr_count == 0 && ! IS_USER_CMDIDX ( ea . cmdidx ) ) { if ( ea . cmdidx == CMD_bdelete || ea . cmdidx == CMD_bwipeout || ea . cmdidx == CMD_bunload ) p = skiptowhite_esc ( ea . arg ) ; else { p = ea . arg + STRLEN ( ea . arg ) ; while ( p > ea . arg && VIM_ISWHITE ( p [ - 1 ] ) ) -- p ; } ea . line2 = buflist_findpat ( ea . arg , p , ( ea . argt & BUFUNL ) != 0 , FALSE , FALSE ) ; if ( ea . line2 < 0 ) goto doend ; ea . addr_count = 1 ; ea . arg = skipwhite ( p ) ; } if ( ea . cmdidx == CMD_try && ea . did_esilent > 0 ) { emsg_silent -= ea . did_esilent ; if ( emsg_silent < 0 ) emsg_silent = 0 ; ea . did_esilent = 0 ; } # ifdef FEAT_USR_CMDS if ( IS_USER_CMDIDX ( ea . cmdidx ) ) { do_ucmd ( & ea ) ; } else # endif { ea . errmsg = NULL ; ( cmdnames [ ea . cmdidx ] . cmd_func ) ( & ea ) ; if ( ea . errmsg != NULL ) errormsg = _ ( ea . errmsg ) ; } # ifdef FEAT_EVAL if ( need_rethrow ) do_throw ( cstack ) ; else if ( check_cstack ) { if ( source_finished ( fgetline , cookie ) ) do_finish ( & ea , TRUE ) ; else if ( getline_equal ( fgetline , cookie , get_func_line ) && current_func_returned ( ) ) do_return ( & ea , TRUE , FALSE , NULL ) ; } need_rethrow = check_cstack = FALSE ; # endif doend : if ( curwin -> w_cursor . lnum == 0 ) { curwin -> w_cursor . lnum = 1 ; curwin -> w_cursor . col = 0 ; } if ( errormsg != NULL && * errormsg != NUL && ! did_emsg ) { if ( sourcing ) { if ( errormsg != ( char * ) IObuff ) { STRCPY ( IObuff , errormsg ) ; errormsg = ( char * ) IObuff ; } append_command ( * cmdlinep ) ; } emsg ( errormsg ) ; } # ifdef FEAT_EVAL do_errthrow ( cstack , ( ea . cmdidx != CMD_SIZE && ! IS_USER_CMDIDX ( ea . cmdidx ) ) ? cmdnames [ ( int ) ea . cmdidx ] . cmd_name : ( char_u * ) NULL ) ; # endif if ( ea . verbose_save >= 0 ) p_verbose = ea . verbose_save ; free_cmdmod ( ) ; cmdmod = save_cmdmod ; if ( ea . save_msg_silent != - 1 ) { if ( ! did_emsg || msg_silent > ea . save_msg_silent ) msg_silent = ea . save_msg_silent ; emsg_silent -= ea . did_esilent ; if ( emsg_silent < 0 ) emsg_silent = 0 ; msg_scroll = save_msg_scroll ; if ( redirecting ( ) ) msg_col = 0 ; } # ifdef HAVE_SANDBOX if ( ea . did_sandbox ) -- sandbox ; # endif if ( ea . nextcmd && * ea . nextcmd == NUL ) ea . nextcmd = NULL ; # ifdef FEAT_EVAL -- ex_nesting_level ; # endif return ea . nextcmd ; }
","<S2SV_ModStart> endif if ( restricted != 0 && ( ea . argt & RESTRICT ) ) { errormsg = _ ( ""E981:<S2SV_blank>Command<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>in<S2SV_blank>rvim"" ) ; goto doend ; } if (
"
664,"CWE-125 static void ttm_put_pages ( struct page * * pages , unsigned npages , int flags , enum ttm_caching_state cstate ) { struct ttm_page_pool * pool = ttm_get_pool ( flags , false , cstate ) ; # ifdef CONFIG_TRANSPARENT_HUGEPAGE struct ttm_page_pool * huge = ttm_get_pool ( flags , true , cstate ) ; # endif unsigned long irq_flags ; unsigned i ; if ( pool == NULL ) { i = 0 ; while ( i < npages ) { # ifdef CONFIG_TRANSPARENT_HUGEPAGE struct page * p = pages [ i ] ; # endif unsigned order = 0 , j ; if ( ! pages [ i ] ) { ++ i ; continue ; } # ifdef CONFIG_TRANSPARENT_HUGEPAGE if ( ! ( flags & TTM_PAGE_FLAG_DMA32 ) && ( npages - i ) >= HPAGE_PMD_NR ) { <S2SV_StartBug> for ( j = 0 ; j < HPAGE_PMD_NR ; ++ j ) <S2SV_EndBug> if ( p ++ != pages [ i + j ] ) break ; if ( j == HPAGE_PMD_NR ) order = HPAGE_PMD_ORDER ; } # endif if ( page_count ( pages [ i ] ) != 1 ) pr_err ( ""Erroneous<S2SV_blank>page<S2SV_blank>count.<S2SV_blank>Leaking<S2SV_blank>pages.\\n"" ) ; __free_pages ( pages [ i ] , order ) ; j = 1 << order ; while ( j ) { pages [ i ++ ] = NULL ; -- j ; } } return ; } i = 0 ; # ifdef CONFIG_TRANSPARENT_HUGEPAGE if ( huge ) { unsigned max_size , n2free ; spin_lock_irqsave ( & huge -> lock , irq_flags ) ; while ( ( npages - i ) >= HPAGE_PMD_NR ) { struct page * p = pages [ i ] ; unsigned j ; if ( ! p ) break ; <S2SV_StartBug> for ( j = 0 ; j < HPAGE_PMD_NR ; ++ j ) <S2SV_EndBug> if ( p ++ != pages [ i + j ] ) break ; if ( j != HPAGE_PMD_NR ) break ; list_add_tail ( & pages [ i ] -> lru , & huge -> list ) ; for ( j = 0 ; j < HPAGE_PMD_NR ; ++ j ) pages [ i ++ ] = NULL ; huge -> npages ++ ; } max_size = _manager -> options . max_size ; max_size /= HPAGE_PMD_NR ; if ( huge -> npages > max_size ) n2free = huge -> npages - max_size ; else n2free = 0 ; spin_unlock_irqrestore ( & huge -> lock , irq_flags ) ; if ( n2free ) ttm_page_pool_free ( huge , n2free , false ) ; } # endif spin_lock_irqsave ( & pool -> lock , irq_flags ) ; while ( i < npages ) { if ( pages [ i ] ) { if ( page_count ( pages [ i ] ) != 1 ) pr_err ( ""Erroneous<S2SV_blank>page<S2SV_blank>count.<S2SV_blank>Leaking<S2SV_blank>pages.\\n"" ) ; list_add_tail ( & pages [ i ] -> lru , & pool -> list ) ; pages [ i ] = NULL ; pool -> npages ++ ; } ++ i ; } npages = 0 ; if ( pool -> npages > _manager -> options . max_size ) { npages = pool -> npages - _manager -> options . max_size ; if ( npages < NUM_PAGES_TO_ALLOC ) npages = NUM_PAGES_TO_ALLOC ; } spin_unlock_irqrestore ( & pool -> lock , irq_flags ) ; if ( npages ) ttm_page_pool_free ( pool , npages , false ) ; }
","<S2SV_ModStart> ( j = 1 <S2SV_ModEnd> ; j < <S2SV_ModStart> ( j = 1 <S2SV_ModEnd> ; j <
"
665,"CWE-119 static vpx_codec_err_t ctrl_get_frame_corrupted ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctrl_id , va_list args ) { <S2SV_EndBug> int * corrupted = va_arg ( args , int * ) ; if ( corrupted ) { <S2SV_StartBug> if ( ctx -> pbi ) <S2SV_EndBug> <S2SV_StartBug> * corrupted = ctx -> pbi -> common . frame_to_show -> corrupted ; <S2SV_EndBug> else return VPX_CODEC_ERROR ; return VPX_CODEC_OK ; } else { <S2SV_StartBug> return VPX_CODEC_INVALID_PARAM ; <S2SV_EndBug> } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> * ctx , <S2SV_ModEnd> va_list args ) <S2SV_ModStart> ( ctx -> frame_workers ) { VPxWorker * const worker = ctx -> frame_workers ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; RefCntBuffer * const frame_bufs = frame_worker_data -> pbi -> common . buffer_pool -> frame_bufs ; if ( frame_worker_data <S2SV_ModEnd> -> pbi -> <S2SV_ModStart> common . frame_to_show == NULL ) return VPX_CODEC_ERROR ; if ( ctx -> last_show_frame >= 0 ) * corrupted = frame_bufs [ ctx -> last_show_frame ] . buf . corrupted <S2SV_ModEnd> ; return VPX_CODEC_OK <S2SV_ModStart> else { return VPX_CODEC_ERROR <S2SV_ModEnd> ; } } <S2SV_ModStart> ; } } return VPX_CODEC_INVALID_PARAM ; }
"
666,"CWE-125 static void get_nb10 ( ut8 * dbg_data , SCV_NB10_HEADER * res ) { const int nb10sz = 16 ; <S2SV_StartBug> memcpy ( res , dbg_data , nb10sz ) ; <S2SV_EndBug> res -> file_name = ( ut8 * ) strdup ( ( const char * ) dbg_data + nb10sz ) ; }
","<S2SV_ModStart> = 16 ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
"
667,"CWE-200 static int proc_connectinfo ( struct usb_dev_state * ps , void __user * arg ) { <S2SV_StartBug> struct usbdevfs_connectinfo ci = { <S2SV_EndBug> <S2SV_StartBug> . devnum = ps -> dev -> devnum , <S2SV_EndBug> . slow = ps -> dev -> speed == USB_SPEED_LOW <S2SV_StartBug> } ; <S2SV_EndBug> if ( copy_to_user ( arg , & ci , sizeof ( ci ) ) ) return - EFAULT ; return 0 ; }
","<S2SV_ModStart> struct usbdevfs_connectinfo ci ; memset ( & ci , 0 , sizeof ( ci ) ) ; ci <S2SV_ModEnd> . devnum = <S2SV_ModStart> dev -> devnum ; ci <S2SV_ModEnd> . slow = <S2SV_ModStart> speed == USB_SPEED_LOW <S2SV_ModEnd> ; if (
"
668,"CWE-125 static int uas_switch_interface ( struct usb_device * udev , struct usb_interface * intf ) { <S2SV_StartBug> int alt ; <S2SV_EndBug> alt = uas_find_uas_alt_setting ( intf ) ; <S2SV_StartBug> if ( alt < 0 ) <S2SV_EndBug> return alt ; return usb_set_interface ( udev , <S2SV_StartBug> intf -> altsetting [ 0 ] . desc . bInterfaceNumber , alt ) ; <S2SV_EndBug> }
","<S2SV_ModStart> intf ) { struct usb_host_interface * <S2SV_ModEnd> alt ; alt <S2SV_ModStart> ; if ( ! alt ) return - ENODEV <S2SV_ModEnd> ; return usb_set_interface <S2SV_ModStart> ( udev , alt -> <S2SV_ModEnd> desc . bInterfaceNumber <S2SV_ModStart> bInterfaceNumber , alt -> desc . bAlternateSetting
"
669,"CWE-310 int ssl3_get_cert_verify ( SSL * s ) { EVP_PKEY * pkey = NULL ; unsigned char * p ; int al , ok , ret = 0 ; long n ; int type = 0 , i , j ; X509 * peer ; const EVP_MD * md = NULL ; EVP_MD_CTX mctx ; EVP_MD_CTX_init ( & mctx ) ; n = s -> method -> ssl_get_message ( s , SSL3_ST_SR_CERT_VRFY_A , SSL3_ST_SR_CERT_VRFY_B , - 1 , SSL3_RT_MAX_PLAIN_LENGTH , & ok ) ; if ( ! ok ) return ( ( int ) n ) ; if ( s -> session -> peer != NULL ) { peer = s -> session -> peer ; pkey = X509_get_pubkey ( peer ) ; type = X509_certificate_type ( peer , pkey ) ; } else { peer = NULL ; pkey = NULL ; } if ( s -> s3 -> tmp . message_type != SSL3_MT_CERTIFICATE_VERIFY ) { s -> s3 -> tmp . reuse_message = 1 ; <S2SV_StartBug> if ( ( peer != NULL ) && ( type & EVP_PKT_SIGN ) ) <S2SV_EndBug> { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , SSL_R_MISSING_VERIFY_MESSAGE ) ; goto f_err ; } ret = 1 ; goto end ; } if ( peer == NULL ) { SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , SSL_R_NO_CLIENT_CERT_RECEIVED ) ; al = SSL_AD_UNEXPECTED_MESSAGE ; goto f_err ; } if ( ! ( type & EVP_PKT_SIGN ) ) { SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , SSL_R_SIGNATURE_FOR_NON_SIGNING_CERTIFICATE ) ; al = SSL_AD_ILLEGAL_PARAMETER ; goto f_err ; } if ( s -> s3 -> change_cipher_spec ) { SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , SSL_R_CCS_RECEIVED_EARLY ) ; al = SSL_AD_UNEXPECTED_MESSAGE ; goto f_err ; } p = ( unsigned char * ) s -> init_msg ; if ( n == 64 && ( pkey -> type == NID_id_GostR3410_94 || pkey -> type == NID_id_GostR3410_2001 ) ) { i = 64 ; } else { if ( SSL_USE_SIGALGS ( s ) ) { int rv = tls12_check_peer_sigalg ( & md , s , p , pkey ) ; if ( rv == - 1 ) { al = SSL_AD_INTERNAL_ERROR ; goto f_err ; } else if ( rv == 0 ) { al = SSL_AD_DECODE_ERROR ; goto f_err ; } # ifdef SSL_DEBUG fprintf ( stderr , ""USING<S2SV_blank>TLSv1.2<S2SV_blank>HASH<S2SV_blank>%s\\n"" , EVP_MD_name ( md ) ) ; # endif p += 2 ; n -= 2 ; } n2s ( p , i ) ; n -= 2 ; if ( i > n ) { SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , SSL_R_LENGTH_MISMATCH ) ; al = SSL_AD_DECODE_ERROR ; goto f_err ; } } j = EVP_PKEY_size ( pkey ) ; if ( ( i > j ) || ( n > j ) || ( n <= 0 ) ) { SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , SSL_R_WRONG_SIGNATURE_SIZE ) ; al = SSL_AD_DECODE_ERROR ; goto f_err ; } if ( SSL_USE_SIGALGS ( s ) ) { long hdatalen = 0 ; void * hdata ; hdatalen = BIO_get_mem_data ( s -> s3 -> handshake_buffer , & hdata ) ; if ( hdatalen <= 0 ) { SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , ERR_R_INTERNAL_ERROR ) ; al = SSL_AD_INTERNAL_ERROR ; goto f_err ; } # ifdef SSL_DEBUG fprintf ( stderr , ""Using<S2SV_blank>TLS<S2SV_blank>1.2<S2SV_blank>with<S2SV_blank>client<S2SV_blank>verify<S2SV_blank>alg<S2SV_blank>%s\\n"" , EVP_MD_name ( md ) ) ; # endif if ( ! EVP_VerifyInit_ex ( & mctx , md , NULL ) || ! EVP_VerifyUpdate ( & mctx , hdata , hdatalen ) ) { SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , ERR_R_EVP_LIB ) ; al = SSL_AD_INTERNAL_ERROR ; goto f_err ; } if ( EVP_VerifyFinal ( & mctx , p , i , pkey ) <= 0 ) { al = SSL_AD_DECRYPT_ERROR ; SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , SSL_R_BAD_SIGNATURE ) ; goto f_err ; } } else # ifndef OPENSSL_NO_RSA if ( pkey -> type == EVP_PKEY_RSA ) { i = RSA_verify ( NID_md5_sha1 , s -> s3 -> tmp . cert_verify_md , MD5_DIGEST_LENGTH + SHA_DIGEST_LENGTH , p , i , pkey -> pkey . rsa ) ; if ( i < 0 ) { al = SSL_AD_DECRYPT_ERROR ; SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , SSL_R_BAD_RSA_DECRYPT ) ; goto f_err ; } if ( i == 0 ) { al = SSL_AD_DECRYPT_ERROR ; SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , SSL_R_BAD_RSA_SIGNATURE ) ; goto f_err ; } } else # endif # ifndef OPENSSL_NO_DSA if ( pkey -> type == EVP_PKEY_DSA ) { j = DSA_verify ( pkey -> save_type , & ( s -> s3 -> tmp . cert_verify_md [ MD5_DIGEST_LENGTH ] ) , SHA_DIGEST_LENGTH , p , i , pkey -> pkey . dsa ) ; if ( j <= 0 ) { al = SSL_AD_DECRYPT_ERROR ; SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , SSL_R_BAD_DSA_SIGNATURE ) ; goto f_err ; } } else # endif # ifndef OPENSSL_NO_ECDSA if ( pkey -> type == EVP_PKEY_EC ) { j = ECDSA_verify ( pkey -> save_type , & ( s -> s3 -> tmp . cert_verify_md [ MD5_DIGEST_LENGTH ] ) , SHA_DIGEST_LENGTH , p , i , pkey -> pkey . ec ) ; if ( j <= 0 ) { al = SSL_AD_DECRYPT_ERROR ; SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , SSL_R_BAD_ECDSA_SIGNATURE ) ; goto f_err ; } } else # endif if ( pkey -> type == NID_id_GostR3410_94 || pkey -> type == NID_id_GostR3410_2001 ) { unsigned char signature [ 64 ] ; int idx ; EVP_PKEY_CTX * pctx = EVP_PKEY_CTX_new ( pkey , NULL ) ; EVP_PKEY_verify_init ( pctx ) ; if ( i != 64 ) { fprintf ( stderr , ""GOST<S2SV_blank>signature<S2SV_blank>length<S2SV_blank>is<S2SV_blank>%d"" , i ) ; } for ( idx = 0 ; idx < 64 ; idx ++ ) { signature [ 63 - idx ] = p [ idx ] ; } j = EVP_PKEY_verify ( pctx , signature , 64 , s -> s3 -> tmp . cert_verify_md , 32 ) ; EVP_PKEY_CTX_free ( pctx ) ; if ( j <= 0 ) { al = SSL_AD_DECRYPT_ERROR ; SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , SSL_R_BAD_ECDSA_SIGNATURE ) ; goto f_err ; } } else { SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , ERR_R_INTERNAL_ERROR ) ; al = SSL_AD_UNSUPPORTED_CERTIFICATE ; goto f_err ; } ret = 1 ; if ( 0 ) { f_err : ssl3_send_alert ( s , SSL3_AL_FATAL , al ) ; } end : if ( s -> s3 -> handshake_buffer ) { BIO_free ( s -> s3 -> handshake_buffer ) ; s -> s3 -> handshake_buffer = NULL ; s -> s3 -> flags &= ~ TLS1_FLAGS_KEEP_HANDSHAKE ; } EVP_MD_CTX_cleanup ( & mctx ) ; EVP_PKEY_free ( pkey ) ; return ( ret ) ; }
","<S2SV_ModStart> ; if ( <S2SV_ModEnd> peer != NULL <S2SV_ModStart> peer != NULL <S2SV_ModEnd> ) { al
"
670,"CWE-20 static gboolean _handle_carbons ( xmpp_stanza_t * const stanza ) { xmpp_stanza_t * carbons = xmpp_stanza_get_child_by_ns ( stanza , STANZA_NS_CARBONS ) ; if ( ! carbons ) { return FALSE ; } const char * name = xmpp_stanza_get_name ( carbons ) ; if ( ! name ) { log_error ( ""Unable<S2SV_blank>to<S2SV_blank>retrieve<S2SV_blank>stanza<S2SV_blank>name<S2SV_blank>for<S2SV_blank>Carbon"" ) ; return TRUE ; } if ( g_strcmp0 ( name , ""private"" ) == 0 ) { log_info ( ""Carbon<S2SV_blank>received<S2SV_blank>with<S2SV_blank>private<S2SV_blank>element."" ) ; return FALSE ; } if ( ( g_strcmp0 ( name , ""received"" ) != 0 ) && ( g_strcmp0 ( name , ""sent"" ) != 0 ) ) { log_warning ( ""Carbon<S2SV_blank>received<S2SV_blank>with<S2SV_blank>unrecognised<S2SV_blank>stanza<S2SV_blank>name:<S2SV_blank>%s"" , name ) ; return TRUE ; } xmpp_stanza_t * forwarded = xmpp_stanza_get_child_by_ns ( carbons , STANZA_NS_FORWARD ) ; if ( ! forwarded ) { log_warning ( ""Carbon<S2SV_blank>received<S2SV_blank>with<S2SV_blank>no<S2SV_blank>forwarded<S2SV_blank>element"" ) ; return TRUE ; } xmpp_stanza_t * message = xmpp_stanza_get_child_by_name ( forwarded , STANZA_NAME_MESSAGE ) ; if ( ! message ) { log_warning ( ""Carbon<S2SV_blank>received<S2SV_blank>with<S2SV_blank>no<S2SV_blank>message<S2SV_blank>element"" ) ; return TRUE ; } char * message_txt = xmpp_message_get_body ( message ) ; if ( ! message_txt ) { log_warning ( ""Carbon<S2SV_blank>received<S2SV_blank>with<S2SV_blank>no<S2SV_blank>message."" ) ; return TRUE ; } <S2SV_StartBug> const gchar * to = xmpp_stanza_get_to ( message ) ; <S2SV_EndBug> const gchar * from = xmpp_stanza_get_from ( message ) ; if ( ! to ) to = from ; Jid * jid_from = jid_create ( from ) ; <S2SV_StartBug> Jid * jid_to = jid_create ( to ) ; <S2SV_EndBug> Jid * my_jid = jid_create ( connection_get_fulljid ( ) ) ; char * enc_message = NULL ; xmpp_stanza_t * x = xmpp_stanza_get_child_by_ns ( message , STANZA_NS_ENCRYPTED ) ; if ( x ) { enc_message = xmpp_stanza_get_text ( x ) ; } if ( g_strcmp0 ( my_jid -> barejid , jid_to -> barejid ) == 0 ) { sv_ev_incoming_carbon ( jid_from -> barejid , jid_from -> resourcepart , message_txt , enc_message ) ; } else { sv_ev_outgoing_carbon ( jid_to -> barejid , message_txt , enc_message ) ; } xmpp_ctx_t * ctx = connection_get_ctx ( ) ; xmpp_free ( ctx , message_txt ) ; xmpp_free ( ctx , enc_message ) ; jid_destroy ( jid_from ) ; jid_destroy ( jid_to ) ; jid_destroy ( my_jid ) ; return TRUE ; }
","<S2SV_ModStart> TRUE ; } Jid * my_jid = jid_create ( connection_get_fulljid ( ) ) ; const char * const stanza_from = xmpp_stanza_get_from ( stanza ) ; Jid * msg_jid = jid_create ( stanza_from ) ; if ( g_strcmp0 ( my_jid -> barejid , msg_jid -> barejid ) != 0 ) { log_warning ( ""Invalid<S2SV_blank>carbon<S2SV_blank>received,<S2SV_blank>from:<S2SV_blank>%s"" , stanza_from ) ; return TRUE ; } <S2SV_ModStart> jid_create ( to <S2SV_ModEnd> ) ; char
"
671,"CWE-20 <S2SV_StartBug> error_t mqttSnClientDisconnect ( MqttSnClientContext * context ) <S2SV_EndBug> { error_t error ; systime_t time ; if ( context == NULL ) return ERROR_INVALID_PARAMETER ; error = NO_ERROR ; while ( ! error ) { time = osGetSystemTime ( ) ; if ( context -> state == MQTT_SN_CLIENT_STATE_ACTIVE ) { context -> startTime = time ; <S2SV_StartBug> error = mqttSnClientSendDisconnect ( context , 0 ) ; <S2SV_EndBug> } else if ( context -> state == MQTT_SN_CLIENT_STATE_SENDING_REQ ) { if ( timeCompare ( time , context -> startTime + context -> timeout ) >= 0 ) { mqttSnClientShutdownConnection ( context ) ; error = ERROR_TIMEOUT ; } else if ( timeCompare ( time , context -> retransmitStartTime + MQTT_SN_CLIENT_RETRY_TIMEOUT ) >= 0 ) { <S2SV_StartBug> error = mqttSnClientSendDisconnect ( context , 0 ) ; <S2SV_EndBug> } else { error = mqttSnClientProcessEvents ( context , MQTT_SN_CLIENT_TICK_INTERVAL ) ; } } else if ( context -> state == MQTT_SN_CLIENT_STATE_DISCONNECTING ) { error = mqttSnClientShutdownConnection ( context ) ; mqttSnClientCloseConnection ( context ) ; context -> state = MQTT_SN_CLIENT_STATE_DISCONNECTED ; } else if ( context -> state == MQTT_SN_CLIENT_STATE_DISCONNECTED ) { break ; } else { error = ERROR_WRONG_STATE ; } } if ( error != NO_ERROR && error != ERROR_WOULD_BLOCK ) { mqttSnClientCloseConnection ( context ) ; context -> state = MQTT_SN_CLIENT_STATE_DISCONNECTED ; } return error ; }
","<S2SV_ModStart> MqttSnClientContext * context , systime_t duration <S2SV_ModStart> ( context , duration / 1000 <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( context , duration / 1000 <S2SV_ModEnd> ) ; }
"
672,"CWE-119 void imap_quote_string ( char * dest , size_t dlen , const char * src , bool quote_backtick ) { const char * quote = ""`\\""\\\\"" ; if ( ! quote_backtick ) quote ++ ; char * pt = dest ; const char * s = src ; * pt ++ = \'""\' ; <S2SV_StartBug> dlen -= 2 ; <S2SV_EndBug> for ( ; * s && dlen ; s ++ ) { if ( strchr ( quote , * s ) ) { if ( dlen < 2 ) break ; dlen -= 2 ; * pt ++ = '\\\\' ; * pt ++ = * s ; } else { * pt ++ = * s ; dlen -- ; } } * pt ++ = \'""\' ; * pt = '\\0' ; }
","<S2SV_ModStart> ; dlen -= 3 <S2SV_ModEnd> ; for (
"
673,"CWE-284 static reactor_status_t run_reactor ( reactor_t * reactor , int iterations ) { assert ( reactor != NULL ) ; reactor -> run_thread = pthread_self ( ) ; reactor -> is_running = true ; struct epoll_event events [ MAX_EVENTS ] ; for ( int i = 0 ; iterations == 0 || i < iterations ; ++ i ) { pthread_mutex_lock ( & reactor -> list_lock ) ; list_clear ( reactor -> invalidation_list ) ; pthread_mutex_unlock ( & reactor -> list_lock ) ; int ret ; do { <S2SV_StartBug> ret = epoll_wait ( reactor -> epoll_fd , events , MAX_EVENTS , - 1 ) ; <S2SV_EndBug> } while ( ret == - 1 && errno == EINTR ) ; if ( ret == - 1 ) { LOG_ERROR ( ""%s<S2SV_blank>error<S2SV_blank>in<S2SV_blank>epoll_wait:<S2SV_blank>%s"" , __func__ , strerror ( errno ) ) ; reactor -> is_running = false ; return REACTOR_STATUS_ERROR ; } for ( int j = 0 ; j < ret ; ++ j ) { if ( events [ j ] . data . ptr == NULL ) { eventfd_t value ; eventfd_read ( reactor -> event_fd , & value ) ; reactor -> is_running = false ; return REACTOR_STATUS_STOP ; } reactor_object_t * object = ( reactor_object_t * ) events [ j ] . data . ptr ; pthread_mutex_lock ( & reactor -> list_lock ) ; if ( list_contains ( reactor -> invalidation_list , object ) ) { pthread_mutex_unlock ( & reactor -> list_lock ) ; continue ; } pthread_mutex_lock ( & object -> lock ) ; pthread_mutex_unlock ( & reactor -> list_lock ) ; reactor -> object_removed = false ; if ( events [ j ] . events & ( EPOLLIN | EPOLLHUP | EPOLLRDHUP | EPOLLERR ) && object -> read_ready ) object -> read_ready ( object -> context ) ; if ( ! reactor -> object_removed && events [ j ] . events & EPOLLOUT && object -> write_ready ) object -> write_ready ( object -> context ) ; pthread_mutex_unlock ( & object -> lock ) ; if ( reactor -> object_removed ) { pthread_mutex_destroy ( & object -> lock ) ; osi_free ( object ) ; } } } reactor -> is_running = false ; return REACTOR_STATUS_DONE ; }
","<S2SV_ModStart> { ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> , - 1 )
"
674,"CWE-119 static int set_register ( pegasus_t * pegasus , __u16 indx , __u8 data ) { <S2SV_StartBug> int ret ; <S2SV_EndBug> ret = usb_control_msg ( pegasus -> usb , usb_sndctrlpipe ( pegasus -> usb , 0 ) , PEGASUS_REQ_SET_REG , PEGASUS_REQT_WRITE , data , <S2SV_StartBug> indx , & data , 1 , 1000 ) ; <S2SV_EndBug> if ( ret < 0 ) netif_dbg ( pegasus , drv , pegasus -> net , ""%s<S2SV_blank>returned<S2SV_blank>%d\\n"" , __func__ , ret ) ; <S2SV_StartBug> return ret ; <S2SV_EndBug> }
","<S2SV_ModStart> data ) { u8 * buf ; int ret ; buf = kmemdup ( & data , 1 , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM <S2SV_ModEnd> ; ret = <S2SV_ModStart> , indx , buf <S2SV_ModEnd> , 1 , <S2SV_ModStart> ret ) ; kfree ( buf ) ;
"
675,"CWE-200 static int rfcomm_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct rfcomm_dlc * d = rfcomm_pi ( sk ) -> dlc ; int len ; if ( test_and_clear_bit ( RFCOMM_DEFER_SETUP , & d -> flags ) ) { <S2SV_StartBug> rfcomm_dlc_accept ( d ) ; <S2SV_EndBug> return 0 ; } len = bt_sock_stream_recvmsg ( iocb , sock , msg , size , flags ) ; lock_sock ( sk ) ; if ( ! ( flags & MSG_PEEK ) && len > 0 ) atomic_sub ( len , & sk -> sk_rmem_alloc ) ; if ( atomic_read ( & sk -> sk_rmem_alloc ) <= ( sk -> sk_rcvbuf >> 2 ) ) rfcomm_dlc_unthrottle ( rfcomm_pi ( sk ) -> dlc ) ; release_sock ( sk ) ; return len ; }
","<S2SV_ModStart> ( d ) ; msg -> msg_namelen = 0
"
676,"CWE-125 int obj2ast_arg ( PyObject * obj , arg_ty * out , PyArena * arena ) { PyObject * tmp = NULL ; identifier arg ; expr_ty annotation ; string type_comment ; int lineno ; int col_offset ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_arg ) ) { <S2SV_EndBug> int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_arg ) ; if ( tmp == NULL ) goto failed ; <S2SV_StartBug> res = obj2ast_identifier ( tmp , & arg , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""arg\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>arg"" ) ; return 1 ; } if ( exists_not_none ( obj , & PyId_annotation ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_annotation ) ; if ( tmp == NULL ) goto failed ; <S2SV_StartBug> res = obj2ast_expr ( tmp , & annotation , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> annotation = NULL ; } if ( exists_not_none ( obj , & PyId_type_comment ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_type_comment ) ; if ( tmp == NULL ) goto failed ; <S2SV_StartBug> res = obj2ast_string ( tmp , & type_comment , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { type_comment = NULL ; } if ( _PyObject_HasAttrId ( obj , & PyId_lineno ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_lineno ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_int ( tmp , & lineno , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""lineno\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>arg"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_col_offset ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_col_offset ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_int ( tmp , & col_offset , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""col_offset\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>arg"" ) ; return 1 ; } * out = arg ( arg , annotation , type_comment , lineno , col_offset , arena ) ; return 0 ; failed : Py_XDECREF ( tmp ) ; return 1 ; }
","<S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_arg , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""arg\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>arg"" ) ; return 1 ; } else { int res ; res = obj2ast_identifier ( tmp , & arg , arena ) ; if ( res != 0 <S2SV_ModEnd> ) goto failed <S2SV_ModStart> goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_annotation , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; annotation = NULL ; } else { int res ; res = obj2ast_expr ( tmp , & annotation <S2SV_ModEnd> , arena ) <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { int res ; res = obj2ast_string ( tmp , & type_comment , arena ) ; if ( res != 0 <S2SV_ModEnd> ) goto failed <S2SV_ModStart> goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_lineno , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""lineno\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>arg"" ) ; return 1 ; } else { int res ; res = obj2ast_int ( tmp , & lineno <S2SV_ModEnd> , arena ) <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_col_offset , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""col_offset\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>arg"" ) ; return 1 ; } else { int res ; res = obj2ast_int ( tmp , & col_offset , arena ) ; if ( res != 0 <S2SV_ModEnd> ) goto failed <S2SV_ModStart> goto failed ; Py_CLEAR ( tmp ) <S2SV_ModEnd> ; } *
"
677,"CWE-326 void device_init ( ) { <S2SV_StartBug> hw_init ( LOW_FREQUENCY ) ; <S2SV_EndBug> if ( ! tsc_sensor_exists ( ) ) { _NFC_status = nfc_init ( ) ; } if ( _NFC_status == NFC_IS_ACTIVE ) { printf1 ( TAG_NFC , ""Have<S2SV_blank>NFC\\r\\n"" ) ; isLowFreq = 1 ; IS_BUTTON_PRESSED = is_physical_button_pressed ; } else { printf1 ( TAG_NFC , ""Have<S2SV_blank>NO<S2SV_blank>NFC\\r\\n"" ) ; hw_init ( HIGH_FREQUENCY ) ; isLowFreq = 0 ; device_init_button ( ) ; } usbhid_init ( ) ; ctaphid_init ( ) ; ctap_init ( ) ; device_migrate ( ) ; <S2SV_StartBug> # if BOOT_TO_DFU <S2SV_EndBug> flash_option_bytes_init ( 1 ) ; # else flash_option_bytes_init ( 0 ) ; # endif }
","<S2SV_ModStart> LOW_FREQUENCY ) ; # if BOOT_TO_DFU flash_option_bytes_init ( 1 ) ; # else flash_option_bytes_init ( 0 ) ; # endif <S2SV_ModStart> ( ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
"
678,"CWE-190 jas_image_t * jp2_decode ( jas_stream_t * in , char * optstr ) { jp2_box_t * box ; int found ; jas_image_t * image ; jp2_dec_t * dec ; bool samedtype ; int dtype ; unsigned int i ; jp2_cmap_t * cmapd ; jp2_pclr_t * pclrd ; jp2_cdef_t * cdefd ; unsigned int channo ; int newcmptno ; int_fast32_t * lutents ; # if 0 jp2_cdefchan_t * cdefent ; int cmptno ; # endif jp2_cmapent_t * cmapent ; jas_icchdr_t icchdr ; jas_iccprof_t * iccprof ; dec = 0 ; box = 0 ; image = 0 ; if ( ! ( dec = jp2_dec_create ( ) ) ) { goto error ; } if ( ! ( box = jp2_box_get ( in ) ) ) { jas_eprintf ( ""error:<S2SV_blank>cannot<S2SV_blank>get<S2SV_blank>box\\n"" ) ; goto error ; } if ( box -> type != JP2_BOX_JP ) { jas_eprintf ( ""error:<S2SV_blank>expecting<S2SV_blank>signature<S2SV_blank>box\\n"" ) ; goto error ; } if ( box -> data . jp . magic != JP2_JP_MAGIC ) { jas_eprintf ( ""incorrect<S2SV_blank>magic<S2SV_blank>number\\n"" ) ; goto error ; } jp2_box_destroy ( box ) ; box = 0 ; if ( ! ( box = jp2_box_get ( in ) ) ) { goto error ; } if ( box -> type != JP2_BOX_FTYP ) { jas_eprintf ( ""expecting<S2SV_blank>file<S2SV_blank>type<S2SV_blank>box\\n"" ) ; goto error ; } jp2_box_destroy ( box ) ; box = 0 ; found = 0 ; while ( ( box = jp2_box_get ( in ) ) ) { if ( jas_getdbglevel ( ) >= 1 ) { jas_eprintf ( ""got<S2SV_blank>box<S2SV_blank>type<S2SV_blank>%s\\n"" , box -> info -> name ) ; } switch ( box -> type ) { case JP2_BOX_JP2C : found = 1 ; break ; case JP2_BOX_IHDR : if ( ! dec -> ihdr ) { dec -> ihdr = box ; box = 0 ; } break ; case JP2_BOX_BPCC : if ( ! dec -> bpcc ) { dec -> bpcc = box ; box = 0 ; } break ; case JP2_BOX_CDEF : if ( ! dec -> cdef ) { dec -> cdef = box ; box = 0 ; } break ; case JP2_BOX_PCLR : if ( ! dec -> pclr ) { dec -> pclr = box ; box = 0 ; } break ; case JP2_BOX_CMAP : if ( ! dec -> cmap ) { dec -> cmap = box ; box = 0 ; } break ; case JP2_BOX_COLR : if ( ! dec -> colr ) { dec -> colr = box ; box = 0 ; } break ; } if ( box ) { jp2_box_destroy ( box ) ; box = 0 ; } if ( found ) { break ; } } if ( ! found ) { jas_eprintf ( ""error:<S2SV_blank>no<S2SV_blank>code<S2SV_blank>stream<S2SV_blank>found\\n"" ) ; goto error ; } if ( ! ( dec -> image = jpc_decode ( in , optstr ) ) ) { jas_eprintf ( ""error:<S2SV_blank>cannot<S2SV_blank>decode<S2SV_blank>code<S2SV_blank>stream\\n"" ) ; goto error ; } if ( ! dec -> ihdr ) { jas_eprintf ( ""error:<S2SV_blank>missing<S2SV_blank>IHDR<S2SV_blank>box\\n"" ) ; goto error ; } <S2SV_StartBug> if ( dec -> ihdr -> data . ihdr . numcmpts != JAS_CAST ( uint , <S2SV_EndBug> jas_image_numcmpts ( dec -> image ) ) ) { jas_eprintf ( ""warning:<S2SV_blank>number<S2SV_blank>of<S2SV_blank>components<S2SV_blank>mismatch\\n"" ) ; } if ( ! jas_image_numcmpts ( dec -> image ) ) { jas_eprintf ( ""error:<S2SV_blank>no<S2SV_blank>components\\n"" ) ; goto error ; } samedtype = true ; dtype = jas_image_cmptdtype ( dec -> image , 0 ) ; <S2SV_StartBug> for ( i = 1 ; i < JAS_CAST ( uint , jas_image_numcmpts ( dec -> image ) ) ; ++ i ) { <S2SV_EndBug> if ( jas_image_cmptdtype ( dec -> image , i ) != dtype ) { samedtype = false ; break ; } } if ( ( samedtype && dec -> ihdr -> data . ihdr . bpc != JP2_DTYPETOBPC ( dtype ) ) || ( ! samedtype && dec -> ihdr -> data . ihdr . bpc != JP2_IHDR_BPCNULL ) ) { jas_eprintf ( ""warning:<S2SV_blank>component<S2SV_blank>data<S2SV_blank>type<S2SV_blank>mismatch\\n"" ) ; } if ( dec -> ihdr -> data . ihdr . comptype != JP2_IHDR_COMPTYPE ) { jas_eprintf ( ""error:<S2SV_blank>unsupported<S2SV_blank>compression<S2SV_blank>type\\n"" ) ; goto error ; } if ( dec -> bpcc ) { <S2SV_StartBug> if ( dec -> bpcc -> data . bpcc . numcmpts != JAS_CAST ( uint , jas_image_numcmpts ( <S2SV_EndBug> dec -> image ) ) ) { jas_eprintf ( ""warning:<S2SV_blank>number<S2SV_blank>of<S2SV_blank>components<S2SV_blank>mismatch\\n"" ) ; } if ( ! samedtype ) { <S2SV_StartBug> for ( i = 0 ; i < JAS_CAST ( uint , jas_image_numcmpts ( dec -> image ) ) ; <S2SV_EndBug> ++ i ) { if ( jas_image_cmptdtype ( dec -> image , i ) != JP2_BPCTODTYPE ( dec -> bpcc -> data . bpcc . bpcs [ i ] ) ) { jas_eprintf ( ""warning:<S2SV_blank>component<S2SV_blank>data<S2SV_blank>type<S2SV_blank>mismatch\\n"" ) ; } } } else { jas_eprintf ( ""warning:<S2SV_blank>superfluous<S2SV_blank>BPCC<S2SV_blank>box\\n"" ) ; } } if ( ! dec -> colr ) { jas_eprintf ( ""error:<S2SV_blank>no<S2SV_blank>COLR<S2SV_blank>box\\n"" ) ; goto error ; } switch ( dec -> colr -> data . colr . method ) { case JP2_COLR_ENUM : jas_image_setclrspc ( dec -> image , jp2_getcs ( & dec -> colr -> data . colr ) ) ; break ; case JP2_COLR_ICC : iccprof = jas_iccprof_createfrombuf ( dec -> colr -> data . colr . iccp , dec -> colr -> data . colr . iccplen ) ; if ( ! iccprof ) { jas_eprintf ( ""error:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>ICC<S2SV_blank>profile\\n"" ) ; goto error ; } jas_iccprof_gethdr ( iccprof , & icchdr ) ; jas_eprintf ( ""ICC<S2SV_blank>Profile<S2SV_blank>CS<S2SV_blank>%08x\\n"" , icchdr . colorspc ) ; jas_image_setclrspc ( dec -> image , fromiccpcs ( icchdr . colorspc ) ) ; dec -> image -> cmprof_ = jas_cmprof_createfromiccprof ( iccprof ) ; assert ( dec -> image -> cmprof_ ) ; jas_iccprof_destroy ( iccprof ) ; break ; } if ( dec -> cmap && ! dec -> pclr ) { jas_eprintf ( ""warning:<S2SV_blank>missing<S2SV_blank>PCLR<S2SV_blank>box<S2SV_blank>or<S2SV_blank>superfluous<S2SV_blank>CMAP<S2SV_blank>box\\n"" ) ; jp2_box_destroy ( dec -> cmap ) ; dec -> cmap = 0 ; } if ( ! dec -> cmap && dec -> pclr ) { jas_eprintf ( ""warning:<S2SV_blank>missing<S2SV_blank>CMAP<S2SV_blank>box<S2SV_blank>or<S2SV_blank>superfluous<S2SV_blank>PCLR<S2SV_blank>box\\n"" ) ; jp2_box_destroy ( dec -> pclr ) ; dec -> pclr = 0 ; } dec -> numchans = dec -> cmap ? dec -> cmap -> data . cmap . numchans : <S2SV_StartBug> JAS_CAST ( uint , jas_image_numcmpts ( dec -> image ) ) ; <S2SV_EndBug> if ( dec -> cmap ) { for ( i = 0 ; i < dec -> numchans ; ++ i ) { <S2SV_StartBug> if ( dec -> cmap -> data . cmap . ents [ i ] . cmptno >= JAS_CAST ( uint , <S2SV_EndBug> jas_image_numcmpts ( dec -> image ) ) ) { jas_eprintf ( ""error:<S2SV_blank>invalid<S2SV_blank>component<S2SV_blank>number<S2SV_blank>in<S2SV_blank>CMAP<S2SV_blank>box\\n"" ) ; goto error ; } if ( dec -> cmap -> data . cmap . ents [ i ] . pcol >= dec -> pclr -> data . pclr . numchans ) { jas_eprintf ( ""error:<S2SV_blank>invalid<S2SV_blank>CMAP<S2SV_blank>LUT<S2SV_blank>index\\n"" ) ; goto error ; } } } if ( ! ( dec -> chantocmptlut = jas_alloc2 ( dec -> numchans , sizeof ( uint_fast16_t ) ) ) ) { jas_eprintf ( ""error:<S2SV_blank>no<S2SV_blank>memory\\n"" ) ; goto error ; } if ( ! dec -> cmap ) { for ( i = 0 ; i < dec -> numchans ; ++ i ) { dec -> chantocmptlut [ i ] = i ; } } else { cmapd = & dec -> cmap -> data . cmap ; pclrd = & dec -> pclr -> data . pclr ; cdefd = & dec -> cdef -> data . cdef ; for ( channo = 0 ; channo < cmapd -> numchans ; ++ channo ) { cmapent = & cmapd -> ents [ channo ] ; if ( cmapent -> map == JP2_CMAP_DIRECT ) { dec -> chantocmptlut [ channo ] = channo ; } else if ( cmapent -> map == JP2_CMAP_PALETTE ) { lutents = jas_alloc2 ( pclrd -> numlutents , sizeof ( int_fast32_t ) ) ; for ( i = 0 ; i < pclrd -> numlutents ; ++ i ) { lutents [ i ] = pclrd -> lutdata [ cmapent -> pcol + i * pclrd -> numchans ] ; } newcmptno = jas_image_numcmpts ( dec -> image ) ; jas_image_depalettize ( dec -> image , cmapent -> cmptno , pclrd -> numlutents , lutents , JP2_BPCTODTYPE ( pclrd -> bpc [ cmapent -> pcol ] ) , newcmptno ) ; dec -> chantocmptlut [ channo ] = newcmptno ; jas_free ( lutents ) ; # if 0 if ( dec -> cdef ) { cdefent = jp2_cdef_lookup ( cdefd , channo ) ; if ( ! cdefent ) { abort ( ) ; } jas_image_setcmpttype ( dec -> image , newcmptno , jp2_getct ( jas_image_clrspc ( dec -> image ) , cdefent -> type , cdefent -> assoc ) ) ; } else { jas_image_setcmpttype ( dec -> image , newcmptno , jp2_getct ( jas_image_clrspc ( dec -> image ) , 0 , channo + 1 ) ) ; } # endif } } } <S2SV_StartBug> for ( i = 0 ; i < JAS_CAST ( uint , jas_image_numcmpts ( dec -> image ) ) ; ++ i ) { <S2SV_EndBug> jas_image_setcmpttype ( dec -> image , i , JAS_IMAGE_CT_UNKNOWN ) ; } if ( dec -> cdef ) { for ( i = 0 ; i < dec -> numchans ; ++ i ) { if ( dec -> cdef -> data . cdef . ents [ i ] . channo >= dec -> numchans ) { jas_eprintf ( ""error:<S2SV_blank>invalid<S2SV_blank>channel<S2SV_blank>number<S2SV_blank>in<S2SV_blank>CDEF<S2SV_blank>box\\n"" ) ; goto error ; } jas_image_setcmpttype ( dec -> image , dec -> chantocmptlut [ dec -> cdef -> data . cdef . ents [ i ] . channo ] , jp2_getct ( jas_image_clrspc ( dec -> image ) , dec -> cdef -> data . cdef . ents [ i ] . type , dec -> cdef -> data . cdef . ents [ i ] . assoc ) ) ; } } else { for ( i = 0 ; i < dec -> numchans ; ++ i ) { jas_image_setcmpttype ( dec -> image , dec -> chantocmptlut [ i ] , jp2_getct ( jas_image_clrspc ( dec -> image ) , 0 , i + 1 ) ) ; } } for ( i = jas_image_numcmpts ( dec -> image ) ; i > 0 ; -- i ) { if ( jas_image_cmpttype ( dec -> image , i - 1 ) == JAS_IMAGE_CT_UNKNOWN ) { jas_image_delcmpt ( dec -> image , i - 1 ) ; } } if ( ! jas_image_numcmpts ( dec -> image ) ) { jas_eprintf ( ""error:<S2SV_blank>no<S2SV_blank>components\\n"" ) ; goto error ; } # if 0 jas_eprintf ( ""no<S2SV_blank>of<S2SV_blank>components<S2SV_blank>is<S2SV_blank>%d\\n"" , jas_image_numcmpts ( dec -> image ) ) ; # endif image = dec -> image ; dec -> image = 0 ; jp2_dec_destroy ( dec ) ; return image ; error : if ( box ) { jp2_box_destroy ( box ) ; } if ( dec ) { jp2_dec_destroy ( dec ) ; } return 0 ; }
","<S2SV_ModStart> != JAS_CAST ( jas_uint <S2SV_ModEnd> , jas_image_numcmpts ( <S2SV_ModStart> < JAS_CAST ( jas_uint <S2SV_ModEnd> , jas_image_numcmpts ( <S2SV_ModStart> != JAS_CAST ( jas_uint <S2SV_ModEnd> , jas_image_numcmpts ( <S2SV_ModStart> < JAS_CAST ( jas_uint <S2SV_ModEnd> , jas_image_numcmpts ( <S2SV_ModStart> : JAS_CAST ( jas_uint <S2SV_ModEnd> , jas_image_numcmpts ( <S2SV_ModStart> >= JAS_CAST ( jas_uint <S2SV_ModEnd> , jas_image_numcmpts ( <S2SV_ModStart> < JAS_CAST ( jas_uint <S2SV_ModEnd> , jas_image_numcmpts (
"
679,"CWE-119 static int http_connect ( URLContext * h , const char * path , const char * local_path , const char * hoststr , const char * auth , const char * proxyauth , int * new_location ) { HTTPContext * s = h -> priv_data ; int post , err ; char headers [ HTTP_HEADERS_SIZE ] = """" ; char * authstr = NULL , * proxyauthstr = NULL ; <S2SV_StartBug> int64_t off = s -> off ; <S2SV_EndBug> int len = 0 ; const char * method ; int send_expect_100 = 0 ; post = h -> flags & AVIO_FLAG_WRITE ; if ( s -> post_data ) { post = 1 ; s -> chunked_post = 0 ; } if ( s -> method ) method = s -> method ; else method = post ? ""POST"" : ""GET"" ; authstr = ff_http_auth_create_response ( & s -> auth_state , auth , local_path , method ) ; proxyauthstr = ff_http_auth_create_response ( & s -> proxy_auth_state , proxyauth , local_path , method ) ; if ( post && ! s -> post_data ) { send_expect_100 = s -> send_expect_100 ; if ( auth && * auth && s -> auth_state . auth_type == HTTP_AUTH_NONE && s -> http_code != 401 ) send_expect_100 = 1 ; } # if FF_API_HTTP_USER_AGENT if ( strcmp ( s -> user_agent_deprecated , DEFAULT_USER_AGENT ) ) { av_log ( s , AV_LOG_WARNING , ""the<S2SV_blank>user-agent<S2SV_blank>option<S2SV_blank>is<S2SV_blank>deprecated,<S2SV_blank>please<S2SV_blank>use<S2SV_blank>user_agent<S2SV_blank>option\\n"" ) ; s -> user_agent = av_strdup ( s -> user_agent_deprecated ) ; } # endif if ( ! has_header ( s -> headers , ""\\r\\nUser-Agent:<S2SV_blank>"" ) ) len += av_strlcatf ( headers + len , sizeof ( headers ) - len , ""User-Agent:<S2SV_blank>%s\\r\\n"" , s -> user_agent ) ; if ( ! has_header ( s -> headers , ""\\r\\nAccept:<S2SV_blank>"" ) ) len += av_strlcpy ( headers + len , ""Accept:<S2SV_blank>*/*\\r\\n"" , sizeof ( headers ) - len ) ; if ( ! has_header ( s -> headers , ""\\r\\nRange:<S2SV_blank>"" ) && ! post && ( s -> off > 0 || s -> end_off || s -> seekable == - 1 ) ) { len += av_strlcatf ( headers + len , sizeof ( headers ) - len , <S2SV_StartBug> ""Range:<S2SV_blank>bytes=%"" PRId64 ""-"" , s -> off ) ; <S2SV_EndBug> if ( s -> end_off ) len += av_strlcatf ( headers + len , sizeof ( headers ) - len , ""%"" PRId64 , s -> end_off - 1 ) ; len += av_strlcpy ( headers + len , ""\\r\\n"" , sizeof ( headers ) - len ) ; } if ( send_expect_100 && ! has_header ( s -> headers , ""\\r\\nExpect:<S2SV_blank>"" ) ) len += av_strlcatf ( headers + len , sizeof ( headers ) - len , ""Expect:<S2SV_blank>100-continue\\r\\n"" ) ; if ( ! has_header ( s -> headers , ""\\r\\nConnection:<S2SV_blank>"" ) ) { if ( s -> multiple_requests ) len += av_strlcpy ( headers + len , ""Connection:<S2SV_blank>keep-alive\\r\\n"" , sizeof ( headers ) - len ) ; else len += av_strlcpy ( headers + len , ""Connection:<S2SV_blank>close\\r\\n"" , sizeof ( headers ) - len ) ; } if ( ! has_header ( s -> headers , ""\\r\\nHost:<S2SV_blank>"" ) ) len += av_strlcatf ( headers + len , sizeof ( headers ) - len , ""Host:<S2SV_blank>%s\\r\\n"" , hoststr ) ; if ( ! has_header ( s -> headers , ""\\r\\nContent-Length:<S2SV_blank>"" ) && s -> post_data ) len += av_strlcatf ( headers + len , sizeof ( headers ) - len , ""Content-Length:<S2SV_blank>%d\\r\\n"" , s -> post_datalen ) ; if ( ! has_header ( s -> headers , ""\\r\\nContent-Type:<S2SV_blank>"" ) && s -> content_type ) len += av_strlcatf ( headers + len , sizeof ( headers ) - len , ""Content-Type:<S2SV_blank>%s\\r\\n"" , s -> content_type ) ; if ( ! has_header ( s -> headers , ""\\r\\nCookie:<S2SV_blank>"" ) && s -> cookies ) { char * cookies = NULL ; if ( ! get_cookies ( s , & cookies , path , hoststr ) && cookies ) { len += av_strlcatf ( headers + len , sizeof ( headers ) - len , ""Cookie:<S2SV_blank>%s\\r\\n"" , cookies ) ; av_free ( cookies ) ; } } if ( ! has_header ( s -> headers , ""\\r\\nIcy-MetaData:<S2SV_blank>"" ) && s -> icy ) len += av_strlcatf ( headers + len , sizeof ( headers ) - len , ""Icy-MetaData:<S2SV_blank>%d\\r\\n"" , 1 ) ; if ( s -> headers ) av_strlcpy ( headers + len , s -> headers , sizeof ( headers ) - len ) ; snprintf ( s -> buffer , sizeof ( s -> buffer ) , ""%s<S2SV_blank>%s<S2SV_blank>HTTP/1.1\\r\\n"" ""%s"" ""%s"" ""%s"" ""%s%s"" ""\\r\\n"" , method , path , post && s -> chunked_post ? ""Transfer-Encoding:<S2SV_blank>chunked\\r\\n"" : """" , headers , authstr ? authstr : """" , proxyauthstr ? ""Proxy-"" : """" , proxyauthstr ? proxyauthstr : """" ) ; av_log ( h , AV_LOG_DEBUG , ""request:<S2SV_blank>%s\\n"" , s -> buffer ) ; if ( ( err = ffurl_write ( s -> hd , s -> buffer , strlen ( s -> buffer ) ) ) < 0 ) goto done ; if ( s -> post_data ) if ( ( err = ffurl_write ( s -> hd , s -> post_data , s -> post_datalen ) ) < 0 ) goto done ; s -> buf_ptr = s -> buffer ; s -> buf_end = s -> buffer ; s -> line_count = 0 ; s -> off = 0 ; s -> icy_data_read = 0 ; <S2SV_StartBug> s -> filesize = - 1 ; <S2SV_EndBug> s -> willclose = 0 ; s -> end_chunked_post = 0 ; s -> end_header = 0 ; if ( post && ! s -> post_data && ! send_expect_100 ) { s -> http_code = 200 ; err = 0 ; goto done ; } err = http_read_header ( h , new_location ) ; if ( err < 0 ) goto done ; if ( * new_location ) s -> off = off ; err = ( off == s -> off ) ? 0 : - 1 ; done : av_freep ( & authstr ) ; av_freep ( & proxyauthstr ) ; return err ; }
","<S2SV_ModStart> = NULL ; uint64_t <S2SV_ModEnd> off = s <S2SV_ModStart> len , ""Range:<S2SV_blank>bytes=%"" PRIu64 <S2SV_ModEnd> ""-"" , s <S2SV_ModStart> -> filesize = UINT64_MAX <S2SV_ModEnd> ; s ->
"
680,"CWE-399 static int fst_get_iface ( struct fst_card_info * card , struct fst_port_info * port , struct ifreq * ifr ) { sync_serial_settings sync ; int i ; switch ( port -> hwif ) { case E1 : ifr -> ifr_settings . type = IF_IFACE_E1 ; break ; case T1 : ifr -> ifr_settings . type = IF_IFACE_T1 ; break ; case V35 : ifr -> ifr_settings . type = IF_IFACE_V35 ; break ; case V24 : ifr -> ifr_settings . type = IF_IFACE_V24 ; break ; case X21D : ifr -> ifr_settings . type = IF_IFACE_X21D ; break ; case X21 : default : ifr -> ifr_settings . type = IF_IFACE_X21 ; break ; } if ( ifr -> ifr_settings . size == 0 ) { return 0 ; } if ( ifr -> ifr_settings . size < sizeof ( sync ) ) { return - ENOMEM ; } i = port -> index ; <S2SV_StartBug> sync . clock_rate = FST_RDL ( card , portConfig [ i ] . lineSpeed ) ; <S2SV_EndBug> sync . clock_type = FST_RDB ( card , portConfig [ i ] . internalClock ) == INTCLK ? CLOCK_INT : CLOCK_EXT ; sync . loopback = 0 ; if ( copy_to_user ( ifr -> ifr_settings . ifs_ifsu . sync , & sync , sizeof ( sync ) ) ) { return - EFAULT ; } ifr -> ifr_settings . size = sizeof ( sync ) ; return 0 ; }
","<S2SV_ModStart> -> index ; memset ( & sync , 0 , sizeof ( sync ) ) ;
"
681,"CWE-787 int main ( int argc , char * * argv ) { char * filein , * str , * tempfile , * prestring , * outprotos , * protostr ; const char * spacestr = ""<S2SV_blank>"" ; <S2SV_StartBug> char buf [ L_BUF_SIZE ] ; <S2SV_EndBug> l_uint8 * allheaders ; l_int32 i , maxindex , in_line , nflags , protos_added , firstfile , len , ret ; size_t nbytes ; L_BYTEA * ba , * ba2 ; SARRAY * sa , * safirst ; static char mainName [ ] = ""xtractprotos"" ; if ( argc == 1 ) { fprintf ( stderr , ""xtractprotos<S2SV_blank>[-prestring=<string>]<S2SV_blank>[-protos=<where>]<S2SV_blank>"" ""[list<S2SV_blank>of<S2SV_blank>C<S2SV_blank>files]\\n"" ""where<S2SV_blank>the<S2SV_blank>prestring<S2SV_blank>is<S2SV_blank>prepended<S2SV_blank>to<S2SV_blank>each<S2SV_blank>prototype,<S2SV_blank>and<S2SV_blank>\\n"" ""protos<S2SV_blank>can<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'inline\'<S2SV_blank>or<S2SV_blank>the<S2SV_blank>name<S2SV_blank>of<S2SV_blank>an<S2SV_blank>output<S2SV_blank>"" ""prototype<S2SV_blank>file\\n"" ) ; return 1 ; } prestring = outprotos = NULL ; in_line = FALSE ; nflags = 0 ; maxindex = L_MIN ( 3 , argc ) ; for ( i = 1 ; i < maxindex ; i ++ ) { if ( argv [ i ] [ 0 ] == '-' ) { if ( ! strncmp ( argv [ i ] , ""-prestring"" , 10 ) ) { nflags ++ ; <S2SV_StartBug> ret = sscanf ( argv [ i ] + 1 , ""prestring=%s"" , buf ) ; <S2SV_EndBug> if ( ret != 1 ) { fprintf ( stderr , ""parse<S2SV_blank>failure<S2SV_blank>for<S2SV_blank>prestring\\n"" ) ; return 1 ; } <S2SV_StartBug> if ( ( len = strlen ( buf ) ) > L_BUF_SIZE - 3 ) { <S2SV_EndBug> L_WARNING ( ""prestring<S2SV_blank>too<S2SV_blank>large;<S2SV_blank>omitting!\\n"" , mainName ) ; } else { buf [ len ] = '<S2SV_blank>' ; buf [ len + 1 ] = '\\0' ; prestring = stringNew ( buf ) ; } } else if ( ! strncmp ( argv [ i ] , ""-protos"" , 7 ) ) { nflags ++ ; <S2SV_StartBug> ret = sscanf ( argv [ i ] + 1 , ""protos=%s"" , buf ) ; <S2SV_EndBug> if ( ret != 1 ) { fprintf ( stderr , ""parse<S2SV_blank>failure<S2SV_blank>for<S2SV_blank>protos\\n"" ) ; return 1 ; } outprotos = stringNew ( buf ) ; if ( ! strncmp ( outprotos , ""inline"" , 7 ) ) in_line = TRUE ; } } } if ( argc - nflags < 2 ) { fprintf ( stderr , ""no<S2SV_blank>files<S2SV_blank>specified!\\n"" ) ; return 1 ; } ba = l_byteaCreate ( 500 ) ; sa = sarrayCreate ( 0 ) ; sarrayAddString ( sa , ( char * ) ""/*"" , L_COPY ) ; <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , <S2SV_EndBug> ""<S2SV_blank>*<S2SV_blank><S2SV_blank>These<S2SV_blank>prototypes<S2SV_blank>were<S2SV_blank>autogen\'d<S2SV_blank>by<S2SV_blank>xtractprotos,<S2SV_blank>v.<S2SV_blank>%s"" , version ) ; sarrayAddString ( sa , buf , L_COPY ) ; sarrayAddString ( sa , ( char * ) ""<S2SV_blank>*/"" , L_COPY ) ; sarrayAddString ( sa , ( char * ) ""#ifdef<S2SV_blank>__cplusplus"" , L_COPY ) ; sarrayAddString ( sa , ( char * ) ""extern<S2SV_blank>\\""C\\""<S2SV_blank>{"" , L_COPY ) ; sarrayAddString ( sa , ( char * ) ""#endif<S2SV_blank><S2SV_blank>/*<S2SV_blank>__cplusplus<S2SV_blank>*/\\n"" , L_COPY ) ; str = sarrayToString ( sa , 1 ) ; l_byteaAppendString ( ba , str ) ; lept_free ( str ) ; sarrayDestroy ( & sa ) ; firstfile = 1 + nflags ; protos_added = FALSE ; if ( ( tempfile = l_makeTempFilename ( ) ) == NULL ) { fprintf ( stderr , ""failure<S2SV_blank>to<S2SV_blank>make<S2SV_blank>a<S2SV_blank>writeable<S2SV_blank>temp<S2SV_blank>file\\n"" ) ; return 1 ; } for ( i = firstfile ; i < argc ; i ++ ) { filein = argv [ i ] ; len = strlen ( filein ) ; if ( filein [ len - 1 ] == 'h' ) continue ; <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""cpp<S2SV_blank>-ansi<S2SV_blank>-DNO_PROTOS<S2SV_blank>%s<S2SV_blank>%s"" , <S2SV_EndBug> filein , tempfile ) ; ret = system ( buf ) ; if ( ret ) { fprintf ( stderr , ""cpp<S2SV_blank>failure<S2SV_blank>for<S2SV_blank>%s;<S2SV_blank>continuing\\n"" , filein ) ; continue ; } if ( ( str = parseForProtos ( tempfile , prestring ) ) == NULL ) { fprintf ( stderr , ""parse<S2SV_blank>failure<S2SV_blank>for<S2SV_blank>%s;<S2SV_blank>continuing\\n"" , filein ) ; continue ; } if ( strlen ( str ) > 1 ) { l_byteaAppendString ( ba , str ) ; protos_added = TRUE ; } lept_free ( str ) ; } lept_rmfile ( tempfile ) ; lept_free ( tempfile ) ; sa = sarrayCreate ( 0 ) ; sarrayAddString ( sa , ( char * ) ""\\n#ifdef<S2SV_blank>__cplusplus"" , L_COPY ) ; sarrayAddString ( sa , ( char * ) ""}"" , L_COPY ) ; sarrayAddString ( sa , ( char * ) ""#endif<S2SV_blank><S2SV_blank>/*<S2SV_blank>__cplusplus<S2SV_blank>*/"" , L_COPY ) ; str = sarrayToString ( sa , 1 ) ; l_byteaAppendString ( ba , str ) ; lept_free ( str ) ; sarrayDestroy ( & sa ) ; protostr = ( char * ) l_byteaCopyData ( ba , & nbytes ) ; l_byteaDestroy ( & ba ) ; if ( ! outprotos ) { fprintf ( stderr , ""%s\\n"" , protostr ) ; lept_free ( protostr ) ; return 0 ; } if ( ! protos_added ) { fprintf ( stderr , ""No<S2SV_blank>protos<S2SV_blank>found\\n"" ) ; lept_free ( protostr ) ; return 1 ; } ba = l_byteaInitFromFile ( ""allheaders_top.txt"" ) ; if ( ! in_line ) { snprintf ( buf , sizeof ( buf ) , ""#include<S2SV_blank>\\""%s\\""\\n"" , outprotos ) ; l_byteaAppendString ( ba , buf ) ; l_binaryWrite ( outprotos , ""w"" , protostr , nbytes ) ; } else { l_byteaAppendString ( ba , protostr ) ; } ba2 = l_byteaInitFromFile ( ""allheaders_bot.txt"" ) ; l_byteaJoin ( ba , & ba2 ) ; l_byteaWrite ( ""allheaders.h"" , ba , 0 , 0 ) ; l_byteaDestroy ( & ba ) ; lept_free ( protostr ) ; return 0 ; }
","<S2SV_ModStart> char buf [ L_BUFSIZE <S2SV_ModEnd> ] ; l_uint8 <S2SV_ModStart> + 1 , ""prestring=%490s"" <S2SV_ModEnd> , buf ) <S2SV_ModStart> ) ) > L_BUFSIZE <S2SV_ModEnd> - 3 ) <S2SV_ModStart> + 1 , ""protos=%490s"" <S2SV_ModEnd> , buf ) <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , ""<S2SV_blank>*<S2SV_blank><S2SV_blank>These<S2SV_blank>prototypes<S2SV_blank>were<S2SV_blank>autogen\'d<S2SV_blank>by<S2SV_blank>xtractprotos,<S2SV_blank>v.<S2SV_blank>%s"" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , ""cpp<S2SV_blank>-ansi<S2SV_blank>-DNO_PROTOS<S2SV_blank>%s<S2SV_blank>%s"" ,
"
682,"CWE-125 static inline unsigned short ReadPropertyUnsignedShort ( const EndianType endian , const unsigned char * buffer ) { unsigned short value ; if ( endian == LSBEndian ) { <S2SV_StartBug> value = ( unsigned short ) ( ( buffer [ 1 ] << 8 ) | buffer [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> return ( ( unsigned short ) ( value & 0xffff ) ) ; <S2SV_EndBug> } <S2SV_StartBug> value = ( unsigned short ) ( ( ( ( unsigned char * ) buffer ) [ 0 ] << 8 ) | <S2SV_EndBug> ( ( unsigned char * ) buffer ) [ 1 ] ) ; <S2SV_StartBug> return ( ( unsigned short ) ( value & 0xffff ) ) ; <S2SV_EndBug> }
","<S2SV_ModStart> unsigned short ) <S2SV_ModEnd> buffer [ 1 <S2SV_ModStart> ] << 8 ; value |= ( unsigned short ) <S2SV_ModEnd> buffer [ 0 <S2SV_ModStart> [ 0 ] <S2SV_ModEnd> ; return ( <S2SV_ModStart> ; return ( <S2SV_ModEnd> value & 0xffff <S2SV_ModStart> value & 0xffff <S2SV_ModEnd> ) ; } <S2SV_ModStart> unsigned short ) buffer <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> ] << 8 ; value |= <S2SV_ModEnd> ( unsigned short <S2SV_ModStart> unsigned short ) buffer [ 1 ] ; return <S2SV_ModStart> & 0xffff ) <S2SV_ModEnd> ; } <S2SV_null>
"
683,"CWE-125 static int <S2SV_StartBug> l_strnstart ( const char * tstr1 , u_int tl1 , const char * str2 , u_int l2 ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> if ( tl1 > l2 ) return 0 ; return ( strncmp ( tstr1 , str2 , tl1 ) == 0 ? 1 : 0 ) ; }
","<S2SV_ModStart> int l_strnstart ( netdissect_options * ndo , <S2SV_ModStart> l2 ) { if ( ! ND_TTEST2 ( * str2 , tl1 ) ) { return 0 ; }
"
684,"CWE-78 static void <S2SV_StartBug> build_config ( char * prefix , struct server * server ) <S2SV_EndBug> { char * path = NULL ; int path_size = strlen ( prefix ) + strlen ( server -> port ) + 20 ; path = ss_malloc ( path_size ) ; snprintf ( path , path_size , ""%s/.shadowsocks_%s.conf"" , prefix , server -> port ) ; FILE * f = fopen ( path , ""w+"" ) ; if ( f == NULL ) { if ( verbose ) { LOGE ( ""unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>config<S2SV_blank>file"" ) ; } ss_free ( path ) ; return ; } fprintf ( f , ""{\\n"" ) ; fprintf ( f , ""\\""server_port\\"":%d,\\n"" , atoi ( server -> port ) ) ; <S2SV_StartBug> fprintf ( f , ""\\""password\\"":\\""%s\\"""" , server -> password ) ; <S2SV_EndBug> if ( server -> fast_open [ 0 ] ) fprintf ( f , "",\\n\\""fast_open\\"":<S2SV_blank>%s"" , server -> fast_open ) ; if ( server -> mode ) fprintf ( f , "",\\n\\""mode\\"":\\""%s\\"""" , server -> mode ) ; <S2SV_StartBug> if ( server -> method ) fprintf ( f , "",\\n\\""method\\"":\\""%s\\"""" , server -> method ) ; <S2SV_EndBug> if ( server -> plugin ) fprintf ( f , "",\\n\\""plugin\\"":\\""%s\\"""" , server -> plugin ) ; if ( server -> plugin_opts ) fprintf ( f , "",\\n\\""plugin_opts\\"":\\""%s\\"""" , server -> plugin_opts ) ; fprintf ( f , ""\\n}\\n"" ) ; fclose ( f ) ; ss_free ( path ) ; }
","<S2SV_ModStart> prefix , struct manager_ctx * manager , struct <S2SV_ModStart> server -> password ) ; if ( server -> method ) fprintf ( f , "",\\n\\""method\\"":\\""%s\\"""" , server -> method ) ; else if ( manager -> method ) fprintf ( f , "",\\n\\""method\\"":\\""%s\\"""" , manager -> method <S2SV_ModStart> ( server -> <S2SV_ModEnd> plugin ) fprintf
"
685,"CWE-667 struct vm_area_struct * find_extend_vma ( struct mm_struct * mm , unsigned long addr ) { struct vm_area_struct * vma ; unsigned long start ; addr &= PAGE_MASK ; vma = find_vma ( mm , addr ) ; if ( ! vma ) return NULL ; if ( vma -> vm_start <= addr ) return vma ; if ( ! ( vma -> vm_flags & VM_GROWSDOWN ) ) return NULL ; <S2SV_StartBug> start = vma -> vm_start ; <S2SV_EndBug> if ( expand_stack ( vma , addr ) ) return NULL ; if ( vma -> vm_flags & VM_LOCKED ) populate_vma_page_range ( vma , addr , start , NULL ) ; return vma ; }
","<S2SV_ModStart> return NULL ; if ( ! mmget_still_valid ( mm ) ) return NULL ;
"
686,"CWE-200 void * vips_tracked_malloc ( size_t size ) { void * buf ; vips_tracked_init ( ) ; size += 16 ; <S2SV_StartBug> if ( ! ( buf = g_try_malloc ( size ) ) ) { <S2SV_EndBug> # ifdef DEBUG g_assert_not_reached ( ) ; # endif vips_error ( ""vips_tracked"" , _ ( ""out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>---<S2SV_blank>size<S2SV_blank>==<S2SV_blank>%dMB"" ) , ( int ) ( size / ( 1024.0 * 1024.0 ) ) ) ; g_warning ( _ ( ""out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>---<S2SV_blank>size<S2SV_blank>==<S2SV_blank>%dMB"" ) , ( int ) ( size / ( 1024.0 * 1024.0 ) ) ) ; return ( NULL ) ; } g_mutex_lock ( vips_tracked_mutex ) ; * ( ( size_t * ) buf ) = size ; buf = ( void * ) ( ( char * ) buf + 16 ) ; vips_tracked_mem += size ; if ( vips_tracked_mem > vips_tracked_mem_highwater ) vips_tracked_mem_highwater = vips_tracked_mem ; vips_tracked_allocs += 1 ; # ifdef DEBUG_VERBOSE printf ( ""vips_tracked_malloc:<S2SV_blank>%p,<S2SV_blank>%zd<S2SV_blank>bytes\\n"" , buf , size ) ; # endif g_mutex_unlock ( vips_tracked_mutex ) ; VIPS_GATE_MALLOC ( size ) ; return ( buf ) ; }
","<S2SV_ModStart> ( buf = g_try_malloc0 <S2SV_ModEnd> ( size )
"
687,"CWE-787 rfbBool InitialiseRFBConnection ( rfbClient * client ) { rfbProtocolVersionMsg pv ; int major , minor ; uint32_t authScheme ; uint32_t subAuthScheme ; rfbClientInitMsg ci ; if ( client -> listenSpecified ) errorMessageOnReadFailure = FALSE ; if ( ! ReadFromRFBServer ( client , pv , sz_rfbProtocolVersionMsg ) ) return FALSE ; pv [ sz_rfbProtocolVersionMsg ] = 0 ; errorMessageOnReadFailure = TRUE ; pv [ sz_rfbProtocolVersionMsg ] = 0 ; if ( sscanf ( pv , rfbProtocolVersionFormat , & major , & minor ) != 2 ) { rfbClientLog ( ""Not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>VNC<S2SV_blank>server<S2SV_blank>(%s)\\n"" , pv ) ; return FALSE ; } DefaultSupportedMessages ( client ) ; client -> major = major ; client -> minor = minor ; if ( ( major == rfbProtocolMajorVersion ) && ( minor > rfbProtocolMinorVersion ) ) client -> minor = rfbProtocolMinorVersion ; if ( major == 3 && ( minor == 4 || minor == 6 ) ) { rfbClientLog ( ""UltraVNC<S2SV_blank>server<S2SV_blank>detected,<S2SV_blank>enabling<S2SV_blank>UltraVNC<S2SV_blank>specific<S2SV_blank>messages\\n"" , pv ) ; DefaultSupportedMessagesUltraVNC ( client ) ; } if ( major == 3 && ( minor == 14 || minor == 16 ) ) { minor = minor - 10 ; client -> minor = minor ; rfbClientLog ( ""UltraVNC<S2SV_blank>Single<S2SV_blank>Click<S2SV_blank>server<S2SV_blank>detected,<S2SV_blank>enabling<S2SV_blank>UltraVNC<S2SV_blank>specific<S2SV_blank>messages\\n"" , pv ) ; DefaultSupportedMessagesUltraVNC ( client ) ; } if ( major == 3 && minor == 5 ) { rfbClientLog ( ""TightVNC<S2SV_blank>server<S2SV_blank>detected,<S2SV_blank>enabling<S2SV_blank>TightVNC<S2SV_blank>specific<S2SV_blank>messages\\n"" , pv ) ; DefaultSupportedMessagesTightVNC ( client ) ; } if ( ( major == 3 && minor > 8 ) || major > 3 ) { client -> major = 3 ; client -> minor = 8 ; } rfbClientLog ( ""VNC<S2SV_blank>server<S2SV_blank>supports<S2SV_blank>protocol<S2SV_blank>version<S2SV_blank>%d.%d<S2SV_blank>(viewer<S2SV_blank>%d.%d)\\n"" , major , minor , rfbProtocolMajorVersion , rfbProtocolMinorVersion ) ; sprintf ( pv , rfbProtocolVersionFormat , client -> major , client -> minor ) ; if ( ! WriteToRFBServer ( client , pv , sz_rfbProtocolVersionMsg ) ) return FALSE ; if ( client -> major == 3 && client -> minor > 6 ) { if ( ! ReadSupportedSecurityType ( client , & authScheme , FALSE ) ) return FALSE ; } else { if ( ! ReadFromRFBServer ( client , ( char * ) & authScheme , 4 ) ) return FALSE ; authScheme = rfbClientSwap32IfLE ( authScheme ) ; } rfbClientLog ( ""Selected<S2SV_blank>Security<S2SV_blank>Scheme<S2SV_blank>%d\\n"" , authScheme ) ; client -> authScheme = authScheme ; switch ( authScheme ) { case rfbConnFailed : ReadReason ( client ) ; return FALSE ; case rfbNoAuth : rfbClientLog ( ""No<S2SV_blank>authentication<S2SV_blank>needed\\n"" ) ; if ( ( client -> major == 3 && client -> minor > 7 ) || client -> major > 3 ) if ( ! rfbHandleAuthResult ( client ) ) return FALSE ; break ; case rfbVncAuth : if ( ! HandleVncAuth ( client ) ) return FALSE ; break ; # ifdef LIBVNCSERVER_HAVE_SASL case rfbSASL : if ( ! HandleSASLAuth ( client ) ) return FALSE ; break ; # endif case rfbMSLogon : if ( ! HandleMSLogonAuth ( client ) ) return FALSE ; break ; case rfbARD : # ifndef LIBVNCSERVER_WITH_CLIENT_GCRYPT rfbClientLog ( ""GCrypt<S2SV_blank>support<S2SV_blank>was<S2SV_blank>not<S2SV_blank>compiled<S2SV_blank>in\\n"" ) ; return FALSE ; # else if ( ! HandleARDAuth ( client ) ) return FALSE ; # endif break ; case rfbTLS : if ( ! HandleAnonTLSAuth ( client ) ) return FALSE ; if ( ! ReadSupportedSecurityType ( client , & subAuthScheme , TRUE ) ) return FALSE ; client -> subAuthScheme = subAuthScheme ; switch ( subAuthScheme ) { case rfbConnFailed : ReadReason ( client ) ; return FALSE ; case rfbNoAuth : rfbClientLog ( ""No<S2SV_blank>sub<S2SV_blank>authentication<S2SV_blank>needed\\n"" ) ; if ( ( client -> major == 3 && client -> minor > 7 ) || client -> major > 3 ) if ( ! rfbHandleAuthResult ( client ) ) return FALSE ; break ; case rfbVncAuth : if ( ! HandleVncAuth ( client ) ) return FALSE ; break ; # ifdef LIBVNCSERVER_HAVE_SASL case rfbSASL : if ( ! HandleSASLAuth ( client ) ) return FALSE ; break ; # endif default : rfbClientLog ( ""Unknown<S2SV_blank>sub<S2SV_blank>authentication<S2SV_blank>scheme<S2SV_blank>from<S2SV_blank>VNC<S2SV_blank>server:<S2SV_blank>%d\\n"" , ( int ) subAuthScheme ) ; return FALSE ; } break ; case rfbVeNCrypt : if ( ! HandleVeNCryptAuth ( client ) ) return FALSE ; switch ( client -> subAuthScheme ) { case rfbVeNCryptTLSNone : case rfbVeNCryptX509None : rfbClientLog ( ""No<S2SV_blank>sub<S2SV_blank>authentication<S2SV_blank>needed\\n"" ) ; if ( ! rfbHandleAuthResult ( client ) ) return FALSE ; break ; case rfbVeNCryptTLSVNC : case rfbVeNCryptX509VNC : if ( ! HandleVncAuth ( client ) ) return FALSE ; break ; case rfbVeNCryptTLSPlain : case rfbVeNCryptX509Plain : if ( ! HandlePlainAuth ( client ) ) return FALSE ; break ; # ifdef LIBVNCSERVER_HAVE_SASL case rfbVeNCryptX509SASL : case rfbVeNCryptTLSSASL : if ( ! HandleSASLAuth ( client ) ) return FALSE ; break ; # endif default : rfbClientLog ( ""Unknown<S2SV_blank>sub<S2SV_blank>authentication<S2SV_blank>scheme<S2SV_blank>from<S2SV_blank>VNC<S2SV_blank>server:<S2SV_blank>%d\\n"" , client -> subAuthScheme ) ; return FALSE ; } break ; default : { rfbBool authHandled = FALSE ; rfbClientProtocolExtension * e ; for ( e = rfbClientExtensions ; e ; e = e -> next ) { uint32_t const * secType ; if ( ! e -> handleAuthentication ) continue ; for ( secType = e -> securityTypes ; secType && * secType ; secType ++ ) { if ( authScheme == * secType ) { if ( ! e -> handleAuthentication ( client , authScheme ) ) return FALSE ; if ( ! rfbHandleAuthResult ( client ) ) return FALSE ; authHandled = TRUE ; } } } if ( authHandled ) break ; } rfbClientLog ( ""Unknown<S2SV_blank>authentication<S2SV_blank>scheme<S2SV_blank>from<S2SV_blank>VNC<S2SV_blank>server:<S2SV_blank>%d\\n"" , ( int ) authScheme ) ; return FALSE ; } ci . shared = ( client -> appData . shareDesktop ? 1 : 0 ) ; if ( ! WriteToRFBServer ( client , ( char * ) & ci , sz_rfbClientInitMsg ) ) return FALSE ; if ( ! ReadFromRFBServer ( client , ( char * ) & client -> si , sz_rfbServerInitMsg ) ) return FALSE ; client -> si . framebufferWidth = rfbClientSwap16IfLE ( client -> si . framebufferWidth ) ; client -> si . framebufferHeight = rfbClientSwap16IfLE ( client -> si . framebufferHeight ) ; client -> si . format . redMax = rfbClientSwap16IfLE ( client -> si . format . redMax ) ; client -> si . format . greenMax = rfbClientSwap16IfLE ( client -> si . format . greenMax ) ; client -> si . format . blueMax = rfbClientSwap16IfLE ( client -> si . format . blueMax ) ; client -> si . nameLength = rfbClientSwap32IfLE ( client -> si . nameLength ) ; <S2SV_StartBug> client -> desktopName = malloc ( ( uint64_t ) client -> si . nameLength + 1 ) ; <S2SV_EndBug> if ( ! client -> desktopName ) { rfbClientLog ( ""Error<S2SV_blank>allocating<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>desktop<S2SV_blank>name,<S2SV_blank>%lu<S2SV_blank>bytes\\n"" , ( unsigned long ) client -> si . nameLength ) ; return FALSE ; } if ( ! ReadFromRFBServer ( client , client -> desktopName , client -> si . nameLength ) ) return FALSE ; client -> desktopName [ client -> si . nameLength ] = 0 ; rfbClientLog ( ""Desktop<S2SV_blank>name<S2SV_blank>\\""%s\\""\\n"" , client -> desktopName ) ; rfbClientLog ( ""Connected<S2SV_blank>to<S2SV_blank>VNC<S2SV_blank>server,<S2SV_blank>using<S2SV_blank>protocol<S2SV_blank>version<S2SV_blank>%d.%d\\n"" , client -> major , client -> minor ) ; rfbClientLog ( ""VNC<S2SV_blank>server<S2SV_blank>default<S2SV_blank>format:\\n"" ) ; PrintPixelFormat ( & client -> si . format ) ; return TRUE ; }
","<S2SV_ModStart> nameLength ) ; if ( client -> si . nameLength > 1 << 20 ) { rfbClientErr ( ""Too<S2SV_blank>big<S2SV_blank>desktop<S2SV_blank>name<S2SV_blank>length<S2SV_blank>sent<S2SV_blank>by<S2SV_blank>server:<S2SV_blank>%u<S2SV_blank>B<S2SV_blank>><S2SV_blank>1<S2SV_blank>MB\\n"" , ( unsigned int ) client -> si . nameLength ) ; return FALSE ; } <S2SV_ModStart> = malloc ( <S2SV_ModEnd> client -> si
"
688,"CWE-119 void jpc_qmfb_split_colres ( jpc_fix_t * a , int numrows , int numcols , int stride , int parity ) { int bufsize = JPC_CEILDIVPOW2 ( numrows , 1 ) ; jpc_fix_t splitbuf [ QMFB_SPLITBUFSIZE * JPC_QMFB_COLGRPSIZE ] ; jpc_fix_t * buf = splitbuf ; jpc_fix_t * srcptr ; jpc_fix_t * dstptr ; register jpc_fix_t * srcptr2 ; register jpc_fix_t * dstptr2 ; register int n ; register int i ; int m ; int hstartcol ; if ( bufsize > QMFB_SPLITBUFSIZE ) { <S2SV_StartBug> if ( ! ( buf = jas_alloc2 ( bufsize , sizeof ( jpc_fix_t ) ) ) ) { <S2SV_EndBug> abort ( ) ; } } if ( numrows >= 2 ) { hstartcol = ( numrows + 1 - parity ) >> 1 ; m = numrows - hstartcol ; n = m ; dstptr = buf ; srcptr = & a [ ( 1 - parity ) * stride ] ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < numcols ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += numcols ; srcptr += stride << 1 ; } dstptr = & a [ ( 1 - parity ) * stride ] ; srcptr = & a [ ( 2 - parity ) * stride ] ; n = numrows - m - ( ! parity ) ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < numcols ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += stride ; srcptr += stride << 1 ; } dstptr = & a [ hstartcol * stride ] ; srcptr = buf ; n = m ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < numcols ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += stride ; srcptr += numcols ; } } if ( buf != splitbuf ) { jas_free ( buf ) ; } }
","<S2SV_ModStart> ( buf = jas_alloc3 ( bufsize , numcols <S2SV_ModEnd> , sizeof (
"
689,"CWE-119 PHP_FUNCTION ( msgfmt_format_message ) { zval * args ; UChar * spattern = NULL ; int spattern_len = 0 ; char * pattern = NULL ; int pattern_len = 0 ; const char * slocale = NULL ; int slocale_len = 0 ; MessageFormatter_object mf = { 0 } ; MessageFormatter_object * mfo = & mf ; if ( zend_parse_method_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , getThis ( ) , ""ssa"" , & slocale , & slocale_len , & pattern , & pattern_len , & args ) == FAILURE ) { intl_error_set ( NULL , U_ILLEGAL_ARGUMENT_ERROR , ""msgfmt_format_message:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>input<S2SV_blank>params"" , 0 TSRMLS_CC ) ; RETURN_FALSE ; <S2SV_StartBug> } <S2SV_EndBug> msgformat_data_init ( & mfo -> mf_data TSRMLS_CC ) ; if ( pattern && pattern_len ) { intl_convert_utf8_to_utf16 ( & spattern , & spattern_len , pattern , pattern_len , & INTL_DATA_ERROR_CODE ( mfo ) ) ; if ( U_FAILURE ( INTL_DATA_ERROR_CODE ( ( mfo ) ) ) ) { intl_error_set ( NULL , U_ILLEGAL_ARGUMENT_ERROR , ""msgfmt_format_message:<S2SV_blank>error<S2SV_blank>converting<S2SV_blank>pattern<S2SV_blank>to<S2SV_blank>UTF-16"" , 0 TSRMLS_CC ) ; RETURN_FALSE ; } } else { spattern_len = 0 ; spattern = NULL ; } if ( slocale_len == 0 ) { slocale = intl_locale_get_default ( TSRMLS_C ) ; } # ifdef MSG_FORMAT_QUOTE_APOS if ( msgformat_fix_quotes ( & spattern , & spattern_len , & INTL_DATA_ERROR_CODE ( mfo ) ) != SUCCESS ) { intl_error_set ( NULL , U_INVALID_FORMAT_ERROR , ""msgfmt_format_message:<S2SV_blank>error<S2SV_blank>converting<S2SV_blank>pattern<S2SV_blank>to<S2SV_blank>quote-friendly<S2SV_blank>format"" , 0 TSRMLS_CC ) ; RETURN_FALSE ; } # endif MSG_FORMAT_OBJECT ( mfo ) = umsg_open ( spattern , spattern_len , slocale , NULL , & INTL_DATA_ERROR_CODE ( mfo ) ) ; if ( spattern && spattern_len ) { efree ( spattern ) ; } INTL_METHOD_CHECK_STATUS ( mfo , ""Creating<S2SV_blank>message<S2SV_blank>formatter<S2SV_blank>failed"" ) ; msgfmt_do_format ( mfo , args , return_value TSRMLS_CC ) ; msgformat_data_free ( & mfo -> mf_data TSRMLS_CC ) ; }
","<S2SV_ModStart> RETURN_FALSE ; } INTL_CHECK_LOCALE_LEN ( slocale_len ) ;
"
690,"CWE-125 int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , <S2SV_StartBug> size_t input_size , <S2SV_EndBug> int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; <S2SV_StartBug> int max_bytes_matched = input_size ; <S2SV_EndBug> input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { int cb_result = callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ; switch ( cb_result ) { case ERROR_INSUFFICIENT_MEMORY : return - 2 ; case ERROR_TOO_MANY_MATCHES : return - 3 ; default : if ( cb_result != ERROR_SUCCESS ) return - 4 ; } break ; } else { return bytes_matched ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } return - 1 ; }
","<S2SV_ModStart> input_data , size_t input_forwards_size , size_t input_backwards_size <S2SV_ModEnd> , int flags <S2SV_ModStart> ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? input_backwards_size : input_forwards_size <S2SV_ModEnd> ; input_incr =
"
691,"CWE-200 <S2SV_StartBug> static void print_bpf_insn ( struct bpf_insn * insn ) <S2SV_EndBug> { u8 class = BPF_CLASS ( insn -> code ) ; if ( class == BPF_ALU || class == BPF_ALU64 ) { if ( BPF_SRC ( insn -> code ) == BPF_X ) verbose ( ""(%02x)<S2SV_blank>%sr%d<S2SV_blank>%s<S2SV_blank>%sr%d\\n"" , insn -> code , class == BPF_ALU ? ""(u32)<S2SV_blank>"" : """" , insn -> dst_reg , bpf_alu_string [ BPF_OP ( insn -> code ) >> 4 ] , class == BPF_ALU ? ""(u32)<S2SV_blank>"" : """" , insn -> src_reg ) ; else verbose ( ""(%02x)<S2SV_blank>%sr%d<S2SV_blank>%s<S2SV_blank>%s%d\\n"" , insn -> code , class == BPF_ALU ? ""(u32)<S2SV_blank>"" : """" , insn -> dst_reg , bpf_alu_string [ BPF_OP ( insn -> code ) >> 4 ] , class == BPF_ALU ? ""(u32)<S2SV_blank>"" : """" , insn -> imm ) ; } else if ( class == BPF_STX ) { if ( BPF_MODE ( insn -> code ) == BPF_MEM ) verbose ( ""(%02x)<S2SV_blank>*(%s<S2SV_blank>*)(r%d<S2SV_blank>%+d)<S2SV_blank>=<S2SV_blank>r%d\\n"" , insn -> code , bpf_ldst_string [ BPF_SIZE ( insn -> code ) >> 3 ] , insn -> dst_reg , insn -> off , insn -> src_reg ) ; else if ( BPF_MODE ( insn -> code ) == BPF_XADD ) verbose ( ""(%02x)<S2SV_blank>lock<S2SV_blank>*(%s<S2SV_blank>*)(r%d<S2SV_blank>%+d)<S2SV_blank>+=<S2SV_blank>r%d\\n"" , insn -> code , bpf_ldst_string [ BPF_SIZE ( insn -> code ) >> 3 ] , insn -> dst_reg , insn -> off , insn -> src_reg ) ; else verbose ( ""BUG_%02x\\n"" , insn -> code ) ; } else if ( class == BPF_ST ) { if ( BPF_MODE ( insn -> code ) != BPF_MEM ) { verbose ( ""BUG_st_%02x\\n"" , insn -> code ) ; return ; } verbose ( ""(%02x)<S2SV_blank>*(%s<S2SV_blank>*)(r%d<S2SV_blank>%+d)<S2SV_blank>=<S2SV_blank>%d\\n"" , insn -> code , bpf_ldst_string [ BPF_SIZE ( insn -> code ) >> 3 ] , insn -> dst_reg , insn -> off , insn -> imm ) ; } else if ( class == BPF_LDX ) { if ( BPF_MODE ( insn -> code ) != BPF_MEM ) { verbose ( ""BUG_ldx_%02x\\n"" , insn -> code ) ; return ; } verbose ( ""(%02x)<S2SV_blank>r%d<S2SV_blank>=<S2SV_blank>*(%s<S2SV_blank>*)(r%d<S2SV_blank>%+d)\\n"" , insn -> code , insn -> dst_reg , bpf_ldst_string [ BPF_SIZE ( insn -> code ) >> 3 ] , insn -> src_reg , insn -> off ) ; } else if ( class == BPF_LD ) { if ( BPF_MODE ( insn -> code ) == BPF_ABS ) { verbose ( ""(%02x)<S2SV_blank>r0<S2SV_blank>=<S2SV_blank>*(%s<S2SV_blank>*)skb[%d]\\n"" , insn -> code , bpf_ldst_string [ BPF_SIZE ( insn -> code ) >> 3 ] , insn -> imm ) ; } else if ( BPF_MODE ( insn -> code ) == BPF_IND ) { verbose ( ""(%02x)<S2SV_blank>r0<S2SV_blank>=<S2SV_blank>*(%s<S2SV_blank>*)skb[r%d<S2SV_blank>+<S2SV_blank>%d]\\n"" , insn -> code , bpf_ldst_string [ BPF_SIZE ( insn -> code ) >> 3 ] , insn -> src_reg , insn -> imm ) ; <S2SV_StartBug> } else if ( BPF_MODE ( insn -> code ) == BPF_IMM ) { <S2SV_EndBug> verbose ( ""(%02x)<S2SV_blank>r%d<S2SV_blank>=<S2SV_blank>0x%x\\n"" , <S2SV_StartBug> insn -> code , insn -> dst_reg , insn -> imm ) ; <S2SV_EndBug> } else { verbose ( ""BUG_ld_%02x\\n"" , insn -> code ) ; return ; } } else if ( class == BPF_JMP ) { u8 opcode = BPF_OP ( insn -> code ) ; if ( opcode == BPF_CALL ) { verbose ( ""(%02x)<S2SV_blank>call<S2SV_blank>%s#%d\\n"" , insn -> code , func_id_name ( insn -> imm ) , insn -> imm ) ; } else if ( insn -> code == ( BPF_JMP | BPF_JA ) ) { verbose ( ""(%02x)<S2SV_blank>goto<S2SV_blank>pc%+d\\n"" , insn -> code , insn -> off ) ; } else if ( insn -> code == ( BPF_JMP | BPF_EXIT ) ) { verbose ( ""(%02x)<S2SV_blank>exit\\n"" , insn -> code ) ; } else if ( BPF_SRC ( insn -> code ) == BPF_X ) { verbose ( ""(%02x)<S2SV_blank>if<S2SV_blank>r%d<S2SV_blank>%s<S2SV_blank>r%d<S2SV_blank>goto<S2SV_blank>pc%+d\\n"" , insn -> code , insn -> dst_reg , bpf_jmp_string [ BPF_OP ( insn -> code ) >> 4 ] , insn -> src_reg , insn -> off ) ; } else { verbose ( ""(%02x)<S2SV_blank>if<S2SV_blank>r%d<S2SV_blank>%s<S2SV_blank>0x%x<S2SV_blank>goto<S2SV_blank>pc%+d\\n"" , insn -> code , insn -> dst_reg , bpf_jmp_string [ BPF_OP ( insn -> code ) >> 4 ] , insn -> imm , insn -> off ) ; } } else { verbose ( ""(%02x)<S2SV_blank>%s\\n"" , insn -> code , bpf_class_string [ class ] ) ; } }
","<S2SV_ModStart> void print_bpf_insn ( const struct bpf_verifier_env * env , const <S2SV_ModStart> ) == BPF_IMM && BPF_SIZE ( insn -> code ) == BPF_DW ) { u64 imm = ( ( u64 ) ( insn + 1 ) -> imm << 32 ) | ( u32 ) insn -> imm ; bool map_ptr = insn -> src_reg == BPF_PSEUDO_MAP_FD ; if ( map_ptr && ! env -> allow_ptr_leaks ) imm = 0 ; verbose ( ""(%02x)<S2SV_blank>r%d<S2SV_blank>=<S2SV_blank>0x%llx\\n"" , insn -> code , <S2SV_ModEnd> insn -> dst_reg <S2SV_ModStart> -> dst_reg , ( unsigned long long ) <S2SV_ModEnd> imm ) ;
"
692,"CWE-119 protected int file_check_mem ( struct magic_set * ms , unsigned int level ) { size_t len ; if ( level >= ms -> c . len ) { <S2SV_StartBug> len = ( ms -> c . len += 20 ) * sizeof ( * ms -> c . li ) ; <S2SV_EndBug> ms -> c . li = CAST ( struct level_info * , ( ms -> c . li == NULL ) ? malloc ( len ) : realloc ( ms -> c . li , len ) ) ; if ( ms -> c . li == NULL ) { file_oomem ( ms , len ) ; return - 1 ; } } ms -> c . li [ level ] . got_match = 0 ; # ifdef ENABLE_CONDITIONALS ms -> c . li [ level ] . last_match = 0 ; ms -> c . li [ level ] . last_cond = COND_NONE ; # endif return 0 ; }
","<S2SV_ModStart> c . len = 20 + level <S2SV_ModEnd> ) * sizeof
"
693,"CWE-476 SYSCALL_DEFINE5 ( add_key , const char __user * , _type , const char __user * , _description , const void __user * , _payload , size_t , plen , key_serial_t , ringid ) { key_ref_t keyring_ref , key_ref ; char type [ 32 ] , * description ; void * payload ; long ret ; ret = - EINVAL ; if ( plen > 1024 * 1024 - 1 ) goto error ; ret = key_get_type_from_user ( type , _type , sizeof ( type ) ) ; if ( ret < 0 ) goto error ; description = NULL ; if ( _description ) { description = strndup_user ( _description , KEY_MAX_DESC_SIZE ) ; if ( IS_ERR ( description ) ) { ret = PTR_ERR ( description ) ; goto error ; } if ( ! * description ) { kfree ( description ) ; description = NULL ; } else if ( ( description [ 0 ] == '.' ) && ( strncmp ( type , ""keyring"" , 7 ) == 0 ) ) { ret = - EPERM ; goto error2 ; } } payload = NULL ; <S2SV_StartBug> if ( _payload ) { <S2SV_EndBug> ret = - ENOMEM ; payload = kvmalloc ( plen , GFP_KERNEL ) ; if ( ! payload ) goto error2 ; ret = - EFAULT ; if ( copy_from_user ( payload , _payload , plen ) != 0 ) goto error3 ; } keyring_ref = lookup_user_key ( ringid , KEY_LOOKUP_CREATE , KEY_NEED_WRITE ) ; if ( IS_ERR ( keyring_ref ) ) { ret = PTR_ERR ( keyring_ref ) ; goto error3 ; } key_ref = key_create_or_update ( keyring_ref , type , description , payload , plen , KEY_PERM_UNDEF , KEY_ALLOC_IN_QUOTA ) ; if ( ! IS_ERR ( key_ref ) ) { ret = key_ref_to_ptr ( key_ref ) -> serial ; key_ref_put ( key_ref ) ; } else { ret = PTR_ERR ( key_ref ) ; } key_ref_put ( keyring_ref ) ; error3 : kvfree ( payload ) ; error2 : kfree ( description ) ; error : return ret ; }
","<S2SV_ModStart> ; if ( plen <S2SV_ModEnd> ) { ret
"
694,"CWE-000 static void usage ( void ) { PRINT_VERSION ; <S2SV_StartBug> puts ( ""Copyright<S2SV_blank>(c)<S2SV_blank>2011,<S2SV_blank>Oracle<S2SV_blank>and/or<S2SV_blank>its<S2SV_blank>affiliates.<S2SV_blank>"" <S2SV_EndBug> ""All<S2SV_blank>rights<S2SV_blank>reserved.\\n"" ) ; puts ( ""Enable<S2SV_blank>or<S2SV_blank>disable<S2SV_blank>plugins."" ) ; printf ( ""\\nUsage:<S2SV_blank>%s<S2SV_blank>[options]<S2SV_blank><plugin><S2SV_blank>ENABLE|DISABLE\\n\\nOptions:\\n"" , my_progname ) ; my_print_help ( my_long_options ) ; puts ( ""\\n"" ) ; }
","<S2SV_ModStart> ; puts ( ""Copyright<S2SV_blank>(c)<S2SV_blank>2011,<S2SV_blank>2015,<S2SV_blank>Oracle<S2SV_blank>and/or<S2SV_blank>its<S2SV_blank>affiliates.<S2SV_blank>"" <S2SV_ModEnd> ""All<S2SV_blank>rights<S2SV_blank>reserved.\\n"" ) ;
"
695,"CWE-264 static int l2tp_ip6_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct sockaddr_l2tpip6 * addr = ( struct sockaddr_l2tpip6 * ) uaddr ; struct net * net = sock_net ( sk ) ; __be32 v4addr = 0 ; int addr_type ; int err ; <S2SV_StartBug> if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) <S2SV_EndBug> return - EINVAL ; if ( addr -> l2tp_family != AF_INET6 ) return - EINVAL ; if ( addr_len < sizeof ( * addr ) ) return - EINVAL ; addr_type = ipv6_addr_type ( & addr -> l2tp_addr ) ; if ( addr_type == IPV6_ADDR_MAPPED ) return - EADDRNOTAVAIL ; if ( addr_type & IPV6_ADDR_MULTICAST ) return - EADDRNOTAVAIL ; err = - EADDRINUSE ; read_lock_bh ( & l2tp_ip6_lock ) ; if ( __l2tp_ip6_bind_lookup ( net , & addr -> l2tp_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip6_lock ) ; lock_sock ( sk ) ; err = - EINVAL ; <S2SV_StartBug> if ( sk -> sk_state != TCP_CLOSE ) <S2SV_EndBug> goto out_unlock ; rcu_read_lock ( ) ; if ( addr_type != IPV6_ADDR_ANY ) { struct net_device * dev = NULL ; if ( addr_type & IPV6_ADDR_LINKLOCAL ) { if ( addr_len >= sizeof ( struct sockaddr_in6 ) && addr -> l2tp_scope_id ) { sk -> sk_bound_dev_if = addr -> l2tp_scope_id ; } if ( ! sk -> sk_bound_dev_if ) goto out_unlock_rcu ; err = - ENODEV ; dev = dev_get_by_index_rcu ( sock_net ( sk ) , sk -> sk_bound_dev_if ) ; if ( ! dev ) goto out_unlock_rcu ; } v4addr = LOOPBACK4_IPV6 ; err = - EADDRNOTAVAIL ; if ( ! ipv6_chk_addr ( sock_net ( sk ) , & addr -> l2tp_addr , dev , 0 ) ) goto out_unlock_rcu ; } rcu_read_unlock ( ) ; inet -> inet_rcv_saddr = inet -> inet_saddr = v4addr ; sk -> sk_v6_rcv_saddr = addr -> l2tp_addr ; np -> saddr = addr -> l2tp_addr ; l2tp_ip6_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip6_lock ) ; sk_add_bind_node ( sk , & l2tp_ip6_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip6_lock ) ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; release_sock ( sk ) ; return 0 ; out_unlock_rcu : rcu_read_unlock ( ) ; out_unlock : release_sock ( sk ) ; return err ; out_in_use : read_unlock_bh ( & l2tp_ip6_lock ) ; return err ; }
","<S2SV_ModStart> ; if ( <S2SV_ModEnd> addr -> l2tp_family <S2SV_ModStart> ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) goto out_unlock ; if (
"
696,"CWE-17 static long ext4_zero_range ( struct file * file , loff_t offset , loff_t len , int mode ) { struct inode * inode = file_inode ( file ) ; handle_t * handle = NULL ; unsigned int max_blocks ; loff_t new_size = 0 ; int ret = 0 ; int flags ; int credits ; int partial_begin , partial_end ; loff_t start , end ; ext4_lblk_t lblk ; struct address_space * mapping = inode -> i_mapping ; unsigned int blkbits = inode -> i_blkbits ; trace_ext4_zero_range ( inode , offset , len , mode ) ; if ( ! S_ISREG ( inode -> i_mode ) ) return - EINVAL ; if ( ext4_should_journal_data ( inode ) ) { ret = ext4_force_commit ( inode -> i_sb ) ; if ( ret ) return ret ; } if ( mapping -> nrpages && mapping_tagged ( mapping , PAGECACHE_TAG_DIRTY ) ) { ret = filemap_write_and_wait_range ( mapping , offset , offset + len - 1 ) ; if ( ret ) return ret ; } start = round_up ( offset , 1 << blkbits ) ; end = round_down ( ( offset + len ) , 1 << blkbits ) ; if ( start < offset || end > offset + len ) return - EINVAL ; partial_begin = offset & ( ( 1 << blkbits ) - 1 ) ; partial_end = ( offset + len ) & ( ( 1 << blkbits ) - 1 ) ; lblk = start >> blkbits ; max_blocks = ( end >> blkbits ) ; if ( max_blocks < lblk ) max_blocks = 0 ; else max_blocks -= lblk ; <S2SV_StartBug> flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT | <S2SV_EndBug> EXT4_GET_BLOCKS_CONVERT_UNWRITTEN | EXT4_EX_NOCACHE ; <S2SV_StartBug> if ( mode & FALLOC_FL_KEEP_SIZE ) <S2SV_EndBug> flags |= EXT4_GET_BLOCKS_KEEP_SIZE ; <S2SV_StartBug> mutex_lock ( & inode -> i_mutex ) ; <S2SV_EndBug> if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) { ret = - EOPNOTSUPP ; goto out_mutex ; } if ( ! ( mode & FALLOC_FL_KEEP_SIZE ) && offset + len > i_size_read ( inode ) ) { new_size = offset + len ; ret = inode_newsize_ok ( inode , new_size ) ; if ( ret ) goto out_mutex ; if ( partial_end ) max_blocks += 1 ; } <S2SV_StartBug> if ( max_blocks > 0 ) { <S2SV_EndBug> truncate_pagecache_range ( inode , start , end - 1 ) ; inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ; ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; ret = ext4_alloc_file_blocks ( file , lblk , max_blocks , new_size , flags , mode ) ; if ( ret ) goto out_dio ; ret = ext4_es_remove_extent ( inode , 0 , EXT_MAX_BLOCKS ) ; if ( ret ) goto out_dio ; } if ( ! partial_begin && ! partial_end ) goto out_dio ; credits = ( 2 * ext4_ext_index_trans_blocks ( inode , 2 ) ) + 1 ; if ( ext4_should_journal_data ( inode ) ) credits += 2 ; handle = ext4_journal_start ( inode , EXT4_HT_MISC , credits ) ; if ( IS_ERR ( handle ) ) { ret = PTR_ERR ( handle ) ; ext4_std_error ( inode -> i_sb , ret ) ; goto out_dio ; } inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ; if ( new_size ) { ext4_update_inode_size ( inode , new_size ) ; } else { if ( ( offset + len ) > i_size_read ( inode ) ) ext4_set_inode_flag ( inode , EXT4_INODE_EOFBLOCKS ) ; } ext4_mark_inode_dirty ( handle , inode ) ; ret = ext4_zero_partial_blocks ( handle , inode , offset , len ) ; if ( file -> f_flags & O_SYNC ) ext4_handle_sync ( handle ) ; ext4_journal_stop ( handle ) ; out_dio : ext4_inode_resume_unlocked_dio ( inode ) ; out_mutex : mutex_unlock ( & inode -> i_mutex ) ; return ret ; }
","<S2SV_ModStart> -= lblk ; mutex_lock ( & inode -> i_mutex ) ; if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) { ret = - EOPNOTSUPP ; goto out_mutex ; } if ( ! <S2SV_ModEnd> ( mode & <S2SV_ModStart> & FALLOC_FL_KEEP_SIZE ) && offset + len > i_size_read ( inode ) ) { new_size = offset + len ; ret = inode_newsize_ok ( inode , new_size ) ; if ( ret ) goto out_mutex ; } flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT ; if ( mode & FALLOC_FL_KEEP_SIZE ) <S2SV_ModStart> |= EXT4_GET_BLOCKS_KEEP_SIZE ; if ( partial_begin || partial_end ) { ret = ext4_alloc_file_blocks ( file , round_down ( offset , 1 << blkbits ) >> blkbits , ( round_up ( ( offset + len ) , 1 << blkbits ) - round_down ( offset , 1 << blkbits ) ) >> blkbits , new_size , flags , mode ) ; if ( ret ) goto out_mutex <S2SV_ModEnd> ; } if <S2SV_ModStart> 0 ) { flags |= ( EXT4_GET_BLOCKS_CONVERT_UNWRITTEN | EXT4_EX_NOCACHE ) ;
"
697,"CWE-125 int ParseDsdiffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int64_t infilesize , total_samples ; DFFFileHeader dff_file_header ; DFFChunkHeader dff_chunk_header ; uint32_t bcount ; infilesize = DoGetFileSize ( infile ) ; memcpy ( & dff_file_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & dff_file_header ) + 4 , sizeof ( DFFFileHeader ) - 4 , & bcount ) || bcount != sizeof ( DFFFileHeader ) - 4 ) || strncmp ( dff_file_header . formType , ""DSD<S2SV_blank>"" , 4 ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & dff_file_header , sizeof ( DFFFileHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } # if 1 WavpackBigEndianToNative ( & dff_file_header , DFFFileHeaderFormat ) ; if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && dff_file_header . ckDataSize && dff_file_header . ckDataSize + 1 && dff_file_header . ckDataSize + 12 != infilesize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file<S2SV_blank>(by<S2SV_blank>total<S2SV_blank>size)!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( ""file<S2SV_blank>header<S2SV_blank>indicated<S2SV_blank>length<S2SV_blank>=<S2SV_blank>%lld"" , dff_file_header . ckDataSize ) ; # endif while ( 1 ) { if ( ! DoReadFile ( infile , & dff_chunk_header , sizeof ( DFFChunkHeader ) , & bcount ) || bcount != sizeof ( DFFChunkHeader ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & dff_chunk_header , sizeof ( DFFChunkHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & dff_chunk_header , DFFChunkHeaderFormat ) ; if ( debug_logging_mode ) error_line ( ""chunk<S2SV_blank>header<S2SV_blank>indicated<S2SV_blank>length<S2SV_blank>=<S2SV_blank>%lld"" , dff_chunk_header . ckDataSize ) ; if ( ! strncmp ( dff_chunk_header . ckID , ""FVER"" , 4 ) ) { uint32_t version ; if ( dff_chunk_header . ckDataSize != sizeof ( version ) || ! DoReadFile ( infile , & version , sizeof ( version ) , & bcount ) || bcount != sizeof ( version ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & version , sizeof ( version ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & version , ""L"" ) ; if ( debug_logging_mode ) error_line ( ""dsdiff<S2SV_blank>file<S2SV_blank>version<S2SV_blank>=<S2SV_blank>0x%08x"" , version ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""PROP"" , 4 ) ) { <S2SV_StartBug> char * prop_chunk = malloc ( ( size_t ) dff_chunk_header . ckDataSize ) ; <S2SV_EndBug> if ( ! DoReadFile ( infile , prop_chunk , ( uint32_t ) dff_chunk_header . ckDataSize , & bcount ) || bcount != dff_chunk_header . ckDataSize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , prop_chunk , ( uint32_t ) dff_chunk_header . ckDataSize ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } if ( ! strncmp ( prop_chunk , ""SND<S2SV_blank>"" , 4 ) ) { char * cptr = prop_chunk + 4 , * eptr = prop_chunk + dff_chunk_header . ckDataSize ; uint16_t numChannels , chansSpecified , chanMask = 0 ; uint32_t sampleRate ; while ( eptr - cptr >= sizeof ( dff_chunk_header ) ) { memcpy ( & dff_chunk_header , cptr , sizeof ( dff_chunk_header ) ) ; cptr += sizeof ( dff_chunk_header ) ; WavpackBigEndianToNative ( & dff_chunk_header , DFFChunkHeaderFormat ) ; if ( eptr - cptr >= dff_chunk_header . ckDataSize ) { if ( ! strncmp ( dff_chunk_header . ckID , ""FS<S2SV_blank><S2SV_blank>"" , 4 ) && dff_chunk_header . ckDataSize == 4 ) { memcpy ( & sampleRate , cptr , sizeof ( sampleRate ) ) ; WavpackBigEndianToNative ( & sampleRate , ""L"" ) ; cptr += dff_chunk_header . ckDataSize ; if ( debug_logging_mode ) error_line ( ""got<S2SV_blank>sample<S2SV_blank>rate<S2SV_blank>of<S2SV_blank>%u<S2SV_blank>Hz"" , sampleRate ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""CHNL"" , 4 ) && dff_chunk_header . ckDataSize >= 2 ) { memcpy ( & numChannels , cptr , sizeof ( numChannels ) ) ; WavpackBigEndianToNative ( & numChannels , ""S"" ) ; cptr += sizeof ( numChannels ) ; chansSpecified = ( int ) ( dff_chunk_header . ckDataSize - sizeof ( numChannels ) ) / 4 ; while ( chansSpecified -- ) { if ( ! strncmp ( cptr , ""SLFT"" , 4 ) || ! strncmp ( cptr , ""MLFT"" , 4 ) ) chanMask |= 0x1 ; else if ( ! strncmp ( cptr , ""SRGT"" , 4 ) || ! strncmp ( cptr , ""MRGT"" , 4 ) ) chanMask |= 0x2 ; else if ( ! strncmp ( cptr , ""LS<S2SV_blank><S2SV_blank>"" , 4 ) ) chanMask |= 0x10 ; else if ( ! strncmp ( cptr , ""RS<S2SV_blank><S2SV_blank>"" , 4 ) ) chanMask |= 0x20 ; else if ( ! strncmp ( cptr , ""C<S2SV_blank><S2SV_blank><S2SV_blank>"" , 4 ) ) chanMask |= 0x4 ; else if ( ! strncmp ( cptr , ""LFE<S2SV_blank>"" , 4 ) ) chanMask |= 0x8 ; else if ( debug_logging_mode ) error_line ( ""undefined<S2SV_blank>channel<S2SV_blank>ID<S2SV_blank>%c%c%c%c"" , cptr [ 0 ] , cptr [ 1 ] , cptr [ 2 ] , cptr [ 3 ] ) ; cptr += 4 ; } if ( debug_logging_mode ) error_line ( ""%d<S2SV_blank>channels,<S2SV_blank>mask<S2SV_blank>=<S2SV_blank>0x%08x"" , numChannels , chanMask ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""CMPR"" , 4 ) && dff_chunk_header . ckDataSize >= 4 ) { if ( strncmp ( cptr , ""DSD<S2SV_blank>"" , 4 ) ) { error_line ( ""DSDIFF<S2SV_blank>files<S2SV_blank>must<S2SV_blank>be<S2SV_blank>uncompressed,<S2SV_blank>not<S2SV_blank>\\""%c%c%c%c\\""!"" , cptr [ 0 ] , cptr [ 1 ] , cptr [ 2 ] , cptr [ 3 ] ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } cptr += dff_chunk_header . ckDataSize ; } else { if ( debug_logging_mode ) error_line ( ""got<S2SV_blank>PROP/SND<S2SV_blank>chunk<S2SV_blank>type<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , dff_chunk_header . ckID [ 0 ] , dff_chunk_header . ckID [ 1 ] , dff_chunk_header . ckID [ 2 ] , dff_chunk_header . ckID [ 3 ] , dff_chunk_header . ckDataSize ) ; cptr += dff_chunk_header . ckDataSize ; } } else { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } } if ( chanMask && ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) ) { error_line ( ""this<S2SV_blank>DSDIFF<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!"" ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } else if ( chanMask ) config -> channel_mask = chanMask ; config -> bits_per_sample = 8 ; config -> bytes_per_sample = 1 ; config -> num_channels = numChannels ; config -> sample_rate = sampleRate / 8 ; config -> qmode |= QMODE_DSD_MSB_FIRST ; } else if ( debug_logging_mode ) error_line ( ""got<S2SV_blank>unknown<S2SV_blank>PROP<S2SV_blank>chunk<S2SV_blank>type<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , prop_chunk [ 0 ] , prop_chunk [ 1 ] , prop_chunk [ 2 ] , prop_chunk [ 3 ] , dff_chunk_header . ckDataSize ) ; free ( prop_chunk ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""DSD<S2SV_blank>"" , 4 ) ) { total_samples = dff_chunk_header . ckDataSize / config -> num_channels ; break ; } else { int bytes_to_copy = ( int ) ( ( ( dff_chunk_header . ckDataSize ) + 1 ) & ~ ( int64_t ) 1 ) ; char * buff = malloc ( bytes_to_copy ) ; if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , dff_chunk_header . ckID [ 0 ] , dff_chunk_header . ckID [ 1 ] , dff_chunk_header . ckID [ 2 ] , dff_chunk_header . ckID [ 3 ] , dff_chunk_header . ckDataSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( debug_logging_mode ) error_line ( ""setting<S2SV_blank>configuration<S2SV_blank>with<S2SV_blank>%lld<S2SV_blank>samples"" , total_samples ) ; if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , NULL ) ) { error_line ( ""%s:<S2SV_blank>%s"" , infilename , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } return WAVPACK_NO_ERROR ; }
","<S2SV_ModStart> { char * prop_chunk ; if ( dff_chunk_header . ckDataSize < 4 || dff_chunk_header . ckDataSize > 1024 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( ""got<S2SV_blank>PROP<S2SV_blank>chunk<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>total"" , ( int ) dff_chunk_header . ckDataSize ) ;
"
698,"CWE-119 void show_object_with_name ( FILE * out , struct object * obj , <S2SV_StartBug> struct strbuf * path , const char * component ) <S2SV_EndBug> { char * name = path_name ( path , component ) ; char * p ; fprintf ( out , ""%s<S2SV_blank>"" , oid_to_hex ( & obj -> oid ) ) ; for ( p = name ; * p && * p != '\\n' ; p ++ ) fputc ( * p , out ) ; fputc ( '\\n' , out ) ; <S2SV_StartBug> free ( name ) ; <S2SV_EndBug> }
","<S2SV_ModStart> * obj , <S2SV_ModEnd> const char * <S2SV_ModStart> const char * name ) { const <S2SV_ModEnd> char * p <S2SV_ModStart> out ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
"
699,"CWE-20 long kvm_arch_vcpu_ioctl ( struct file * filp , unsigned int ioctl , unsigned long arg ) { struct kvm_vcpu * vcpu = filp -> private_data ; void __user * argp = ( void __user * ) arg ; int r ; union { struct kvm_lapic_state * lapic ; struct kvm_xsave * xsave ; struct kvm_xcrs * xcrs ; void * buffer ; } u ; u . buffer = NULL ; switch ( ioctl ) { case KVM_GET_LAPIC : { r = - EINVAL ; if ( ! vcpu -> arch . apic ) goto out ; u . lapic = kzalloc ( sizeof ( struct kvm_lapic_state ) , GFP_KERNEL ) ; r = - ENOMEM ; if ( ! u . lapic ) goto out ; r = kvm_vcpu_ioctl_get_lapic ( vcpu , u . lapic ) ; if ( r ) goto out ; r = - EFAULT ; if ( copy_to_user ( argp , u . lapic , sizeof ( struct kvm_lapic_state ) ) ) goto out ; r = 0 ; break ; } case KVM_SET_LAPIC : { r = - EINVAL ; if ( ! vcpu -> arch . apic ) goto out ; u . lapic = memdup_user ( argp , sizeof ( * u . lapic ) ) ; if ( IS_ERR ( u . lapic ) ) return PTR_ERR ( u . lapic ) ; r = kvm_vcpu_ioctl_set_lapic ( vcpu , u . lapic ) ; break ; } case KVM_INTERRUPT : { struct kvm_interrupt irq ; r = - EFAULT ; if ( copy_from_user ( & irq , argp , sizeof irq ) ) goto out ; r = kvm_vcpu_ioctl_interrupt ( vcpu , & irq ) ; break ; } case KVM_NMI : { r = kvm_vcpu_ioctl_nmi ( vcpu ) ; break ; } case KVM_SET_CPUID : { struct kvm_cpuid __user * cpuid_arg = argp ; struct kvm_cpuid cpuid ; r = - EFAULT ; if ( copy_from_user ( & cpuid , cpuid_arg , sizeof cpuid ) ) goto out ; r = kvm_vcpu_ioctl_set_cpuid ( vcpu , & cpuid , cpuid_arg -> entries ) ; break ; } case KVM_SET_CPUID2 : { struct kvm_cpuid2 __user * cpuid_arg = argp ; struct kvm_cpuid2 cpuid ; r = - EFAULT ; if ( copy_from_user ( & cpuid , cpuid_arg , sizeof cpuid ) ) goto out ; r = kvm_vcpu_ioctl_set_cpuid2 ( vcpu , & cpuid , cpuid_arg -> entries ) ; break ; } case KVM_GET_CPUID2 : { struct kvm_cpuid2 __user * cpuid_arg = argp ; struct kvm_cpuid2 cpuid ; r = - EFAULT ; if ( copy_from_user ( & cpuid , cpuid_arg , sizeof cpuid ) ) goto out ; r = kvm_vcpu_ioctl_get_cpuid2 ( vcpu , & cpuid , cpuid_arg -> entries ) ; if ( r ) goto out ; r = - EFAULT ; if ( copy_to_user ( cpuid_arg , & cpuid , sizeof cpuid ) ) goto out ; r = 0 ; break ; } case KVM_GET_MSRS : r = msr_io ( vcpu , argp , kvm_get_msr , 1 ) ; break ; case KVM_SET_MSRS : r = msr_io ( vcpu , argp , do_set_msr , 0 ) ; break ; case KVM_TPR_ACCESS_REPORTING : { struct kvm_tpr_access_ctl tac ; r = - EFAULT ; if ( copy_from_user ( & tac , argp , sizeof tac ) ) goto out ; r = vcpu_ioctl_tpr_access_reporting ( vcpu , & tac ) ; if ( r ) goto out ; r = - EFAULT ; if ( copy_to_user ( argp , & tac , sizeof tac ) ) goto out ; r = 0 ; break ; } ; case KVM_SET_VAPIC_ADDR : { struct kvm_vapic_addr va ; r = - EINVAL ; if ( ! irqchip_in_kernel ( vcpu -> kvm ) ) goto out ; r = - EFAULT ; if ( copy_from_user ( & va , argp , sizeof va ) ) goto out ; <S2SV_StartBug> r = 0 ; <S2SV_EndBug> kvm_lapic_set_vapic_addr ( vcpu , va . vapic_addr ) ; break ; } case KVM_X86_SETUP_MCE : { u64 mcg_cap ; r = - EFAULT ; if ( copy_from_user ( & mcg_cap , argp , sizeof mcg_cap ) ) goto out ; r = kvm_vcpu_ioctl_x86_setup_mce ( vcpu , mcg_cap ) ; break ; } case KVM_X86_SET_MCE : { struct kvm_x86_mce mce ; r = - EFAULT ; if ( copy_from_user ( & mce , argp , sizeof mce ) ) goto out ; r = kvm_vcpu_ioctl_x86_set_mce ( vcpu , & mce ) ; break ; } case KVM_GET_VCPU_EVENTS : { struct kvm_vcpu_events events ; kvm_vcpu_ioctl_x86_get_vcpu_events ( vcpu , & events ) ; r = - EFAULT ; if ( copy_to_user ( argp , & events , sizeof ( struct kvm_vcpu_events ) ) ) break ; r = 0 ; break ; } case KVM_SET_VCPU_EVENTS : { struct kvm_vcpu_events events ; r = - EFAULT ; if ( copy_from_user ( & events , argp , sizeof ( struct kvm_vcpu_events ) ) ) break ; r = kvm_vcpu_ioctl_x86_set_vcpu_events ( vcpu , & events ) ; break ; } case KVM_GET_DEBUGREGS : { struct kvm_debugregs dbgregs ; kvm_vcpu_ioctl_x86_get_debugregs ( vcpu , & dbgregs ) ; r = - EFAULT ; if ( copy_to_user ( argp , & dbgregs , sizeof ( struct kvm_debugregs ) ) ) break ; r = 0 ; break ; } case KVM_SET_DEBUGREGS : { struct kvm_debugregs dbgregs ; r = - EFAULT ; if ( copy_from_user ( & dbgregs , argp , sizeof ( struct kvm_debugregs ) ) ) break ; r = kvm_vcpu_ioctl_x86_set_debugregs ( vcpu , & dbgregs ) ; break ; } case KVM_GET_XSAVE : { u . xsave = kzalloc ( sizeof ( struct kvm_xsave ) , GFP_KERNEL ) ; r = - ENOMEM ; if ( ! u . xsave ) break ; kvm_vcpu_ioctl_x86_get_xsave ( vcpu , u . xsave ) ; r = - EFAULT ; if ( copy_to_user ( argp , u . xsave , sizeof ( struct kvm_xsave ) ) ) break ; r = 0 ; break ; } case KVM_SET_XSAVE : { u . xsave = memdup_user ( argp , sizeof ( * u . xsave ) ) ; if ( IS_ERR ( u . xsave ) ) return PTR_ERR ( u . xsave ) ; r = kvm_vcpu_ioctl_x86_set_xsave ( vcpu , u . xsave ) ; break ; } case KVM_GET_XCRS : { u . xcrs = kzalloc ( sizeof ( struct kvm_xcrs ) , GFP_KERNEL ) ; r = - ENOMEM ; if ( ! u . xcrs ) break ; kvm_vcpu_ioctl_x86_get_xcrs ( vcpu , u . xcrs ) ; r = - EFAULT ; if ( copy_to_user ( argp , u . xcrs , sizeof ( struct kvm_xcrs ) ) ) break ; r = 0 ; break ; } case KVM_SET_XCRS : { u . xcrs = memdup_user ( argp , sizeof ( * u . xcrs ) ) ; if ( IS_ERR ( u . xcrs ) ) return PTR_ERR ( u . xcrs ) ; r = kvm_vcpu_ioctl_x86_set_xcrs ( vcpu , u . xcrs ) ; break ; } case KVM_SET_TSC_KHZ : { u32 user_tsc_khz ; r = - EINVAL ; user_tsc_khz = ( u32 ) arg ; if ( user_tsc_khz >= kvm_max_guest_tsc_khz ) goto out ; if ( user_tsc_khz == 0 ) user_tsc_khz = tsc_khz ; kvm_set_tsc_khz ( vcpu , user_tsc_khz ) ; r = 0 ; goto out ; } case KVM_GET_TSC_KHZ : { r = vcpu -> arch . virtual_tsc_khz ; goto out ; } case KVM_KVMCLOCK_CTRL : { r = kvm_set_guest_paused ( vcpu ) ; goto out ; } default : r = - EINVAL ; } out : kfree ( u . buffer ) ; return r ; }
","<S2SV_ModStart> ; r = <S2SV_ModEnd> kvm_lapic_set_vapic_addr ( vcpu
"
700,"CWE-787 int mp_pack ( lua_State * L ) { int nargs = lua_gettop ( L ) ; int i ; mp_buf * buf ; if ( nargs == 0 ) <S2SV_StartBug> return luaL_argerror ( L , 0 , ""MessagePack<S2SV_blank>pack<S2SV_blank>needs<S2SV_blank>input."" ) ; <S2SV_EndBug> buf = mp_buf_new ( L ) ; for ( i = 1 ; i <= nargs ; i ++ ) { lua_pushvalue ( L , i ) ; mp_encode_lua_type ( L , buf , 0 ) ; lua_pushlstring ( L , ( char * ) buf -> b , buf -> len ) ; buf -> free += buf -> len ; buf -> len = 0 ; } mp_buf_free ( L , buf ) ; lua_concat ( L , nargs ) ; return 1 ; }
","<S2SV_ModStart> 0 , ""MessagePack<S2SV_blank>pack<S2SV_blank>needs<S2SV_blank>input."" ) ; if ( ! lua_checkstack ( L , nargs ) ) return luaL_argerror ( L , 0 , ""Too<S2SV_blank>many<S2SV_blank>arguments<S2SV_blank>for<S2SV_blank>MessagePack<S2SV_blank>pack.""
"
701,"CWE-200 static int llc_ui_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sockaddr_llc * uaddr = ( struct sockaddr_llc * ) msg -> msg_name ; const int nonblock = flags & MSG_DONTWAIT ; struct sk_buff * skb = NULL ; struct sock * sk = sock -> sk ; struct llc_sock * llc = llc_sk ( sk ) ; unsigned long cpu_flags ; size_t copied = 0 ; u32 peek_seq = 0 ; u32 * seq ; unsigned long used ; int target ; <S2SV_StartBug> long timeo ; <S2SV_EndBug> lock_sock ( sk ) ; copied = - ENOTCONN ; if ( unlikely ( sk -> sk_type == SOCK_STREAM && sk -> sk_state == TCP_LISTEN ) ) goto out ; timeo = sock_rcvtimeo ( sk , nonblock ) ; seq = & llc -> copied_seq ; if ( flags & MSG_PEEK ) { peek_seq = llc -> copied_seq ; seq = & peek_seq ; } target = sock_rcvlowat ( sk , flags & MSG_WAITALL , len ) ; copied = 0 ; do { u32 offset ; if ( signal_pending ( current ) ) { if ( copied ) break ; copied = timeo ? sock_intr_errno ( timeo ) : - EAGAIN ; break ; } skb = skb_peek ( & sk -> sk_receive_queue ) ; if ( skb ) { offset = * seq ; goto found_ok_skb ; } if ( copied >= target && ! sk -> sk_backlog . tail ) break ; if ( copied ) { if ( sk -> sk_err || sk -> sk_state == TCP_CLOSE || ( sk -> sk_shutdown & RCV_SHUTDOWN ) || ! timeo || ( flags & MSG_PEEK ) ) break ; } else { if ( sock_flag ( sk , SOCK_DONE ) ) break ; if ( sk -> sk_err ) { copied = sock_error ( sk ) ; break ; } if ( sk -> sk_shutdown & RCV_SHUTDOWN ) break ; if ( sk -> sk_type == SOCK_STREAM && sk -> sk_state == TCP_CLOSE ) { if ( ! sock_flag ( sk , SOCK_DONE ) ) { copied = - ENOTCONN ; break ; } break ; } if ( ! timeo ) { copied = - EAGAIN ; break ; } } if ( copied >= target ) { release_sock ( sk ) ; lock_sock ( sk ) ; } else sk_wait_data ( sk , & timeo ) ; if ( ( flags & MSG_PEEK ) && peek_seq != llc -> copied_seq ) { net_dbg_ratelimited ( ""LLC(%s:%d):<S2SV_blank>Application<S2SV_blank>bug,<S2SV_blank>race<S2SV_blank>in<S2SV_blank>MSG_PEEK\\n"" , current -> comm , task_pid_nr ( current ) ) ; peek_seq = llc -> copied_seq ; } continue ; found_ok_skb : used = skb -> len - offset ; if ( len < used ) used = len ; if ( ! ( flags & MSG_TRUNC ) ) { int rc = skb_copy_datagram_iovec ( skb , offset , msg -> msg_iov , used ) ; if ( rc ) { if ( ! copied ) copied = - EFAULT ; break ; } } * seq += used ; copied += used ; len -= used ; if ( sk -> sk_type != SOCK_STREAM ) goto copy_uaddr ; if ( ! ( flags & MSG_PEEK ) ) { spin_lock_irqsave ( & sk -> sk_receive_queue . lock , cpu_flags ) ; sk_eat_skb ( sk , skb , false ) ; spin_unlock_irqrestore ( & sk -> sk_receive_queue . lock , cpu_flags ) ; * seq = 0 ; } if ( used + offset < skb -> len ) continue ; } while ( len > 0 ) ; out : release_sock ( sk ) ; return copied ; copy_uaddr : if ( uaddr != NULL && skb != NULL ) { memcpy ( uaddr , llc_ui_skb_cb ( skb ) , sizeof ( * uaddr ) ) ; msg -> msg_namelen = sizeof ( * uaddr ) ; } if ( llc_sk ( sk ) -> cmsg_flags ) llc_cmsg_rcv ( msg , skb ) ; if ( ! ( flags & MSG_PEEK ) ) { spin_lock_irqsave ( & sk -> sk_receive_queue . lock , cpu_flags ) ; sk_eat_skb ( sk , skb , false ) ; spin_unlock_irqrestore ( & sk -> sk_receive_queue . lock , cpu_flags ) ; * seq = 0 ; } goto out ; }
","<S2SV_ModStart> ; long timeo ; msg -> msg_namelen = 0
"
702,"CWE-20 static int nntp_fetch_headers ( struct Context * ctx , void * hc , anum_t first , anum_t last , int restore ) { struct NntpData * nntp_data = ctx -> data ; struct FetchCtx fc ; struct Header * hdr = NULL ; char buf [ HUGE_STRING ] ; int rc = 0 ; int oldmsgcount = ctx -> msgcount ; anum_t current ; anum_t first_over = first ; # ifdef USE_HCACHE void * hdata = NULL ; # endif if ( ! last || first > last ) return 0 ; fc . ctx = ctx ; fc . first = first ; fc . last = last ; fc . restore = restore ; <S2SV_StartBug> fc . messages = mutt_mem_calloc ( last - first + 1 , sizeof ( unsigned char ) ) ; <S2SV_EndBug> # ifdef USE_HCACHE fc . hc = hc ; # endif if ( NntpListgroup && nntp_data -> nserv -> hasLISTGROUP && ! nntp_data -> deleted ) { if ( ! ctx -> quiet ) mutt_message ( _ ( ""Fetching<S2SV_blank>list<S2SV_blank>of<S2SV_blank>articles..."" ) ) ; if ( nntp_data -> nserv -> hasLISTGROUPrange ) snprintf ( buf , sizeof ( buf ) , ""LISTGROUP<S2SV_blank>%s<S2SV_blank>%u-%u\\r\\n"" , nntp_data -> group , first , last ) ; else snprintf ( buf , sizeof ( buf ) , ""LISTGROUP<S2SV_blank>%s\\r\\n"" , nntp_data -> group ) ; rc = nntp_fetch_lines ( nntp_data , buf , sizeof ( buf ) , NULL , fetch_numbers , & fc ) ; if ( rc > 0 ) { mutt_error ( ""LISTGROUP:<S2SV_blank>%s"" , buf ) ; } if ( rc == 0 ) { for ( current = first ; current <= last && rc == 0 ; current ++ ) { if ( fc . messages [ current - first ] ) continue ; snprintf ( buf , sizeof ( buf ) , ""%u"" , current ) ; if ( nntp_data -> bcache ) { mutt_debug ( 2 , ""#1<S2SV_blank>mutt_bcache_del<S2SV_blank>%s\\n"" , buf ) ; mutt_bcache_del ( nntp_data -> bcache , buf ) ; } # ifdef USE_HCACHE if ( fc . hc ) { mutt_debug ( 2 , ""mutt_hcache_delete<S2SV_blank>%s\\n"" , buf ) ; mutt_hcache_delete ( fc . hc , buf , strlen ( buf ) ) ; } # endif } } } else { for ( current = first ; current <= last ; current ++ ) fc . messages [ current - first ] = 1 ; } if ( ! ctx -> quiet ) { mutt_progress_init ( & fc . progress , _ ( ""Fetching<S2SV_blank>message<S2SV_blank>headers..."" ) , MUTT_PROGRESS_MSG , ReadInc , last - first + 1 ) ; } for ( current = first ; current <= last && rc == 0 ; current ++ ) { if ( ! ctx -> quiet ) mutt_progress_update ( & fc . progress , current - first + 1 , - 1 ) ; # ifdef USE_HCACHE snprintf ( buf , sizeof ( buf ) , ""%u"" , current ) ; # endif if ( ! fc . messages [ current - first ] ) continue ; if ( ctx -> msgcount >= ctx -> hdrmax ) mx_alloc_memory ( ctx ) ; # ifdef USE_HCACHE hdata = mutt_hcache_fetch ( fc . hc , buf , strlen ( buf ) ) ; if ( hdata ) { mutt_debug ( 2 , ""mutt_hcache_fetch<S2SV_blank>%s\\n"" , buf ) ; ctx -> hdrs [ ctx -> msgcount ] = hdr = mutt_hcache_restore ( hdata ) ; mutt_hcache_free ( fc . hc , & hdata ) ; hdr -> data = 0 ; if ( hdr -> deleted && ! restore ) { mutt_header_free ( & hdr ) ; if ( nntp_data -> bcache ) { mutt_debug ( 2 , ""#2<S2SV_blank>mutt_bcache_del<S2SV_blank>%s\\n"" , buf ) ; mutt_bcache_del ( nntp_data -> bcache , buf ) ; } continue ; } hdr -> read = false ; hdr -> old = false ; } else # endif if ( nntp_data -> deleted ) continue ; else if ( nntp_data -> nserv -> hasOVER || nntp_data -> nserv -> hasXOVER ) { if ( NntpListgroup && nntp_data -> nserv -> hasLISTGROUP ) break ; else continue ; } else { FILE * fp = mutt_file_mkstemp ( ) ; if ( ! fp ) { mutt_perror ( ""mutt_file_mkstemp()<S2SV_blank>failed!"" ) ; rc = - 1 ; break ; } snprintf ( buf , sizeof ( buf ) , ""HEAD<S2SV_blank>%u\\r\\n"" , current ) ; rc = nntp_fetch_lines ( nntp_data , buf , sizeof ( buf ) , NULL , fetch_tempfile , fp ) ; if ( rc ) { mutt_file_fclose ( & fp ) ; if ( rc < 0 ) break ; if ( mutt_str_strncmp ( ""423"" , buf , 3 ) != 0 ) { mutt_error ( ""HEAD:<S2SV_blank>%s"" , buf ) ; break ; } if ( nntp_data -> bcache ) { snprintf ( buf , sizeof ( buf ) , ""%u"" , current ) ; mutt_debug ( 2 , ""#3<S2SV_blank>mutt_bcache_del<S2SV_blank>%s\\n"" , buf ) ; mutt_bcache_del ( nntp_data -> bcache , buf ) ; } rc = 0 ; continue ; } hdr = ctx -> hdrs [ ctx -> msgcount ] = mutt_header_new ( ) ; hdr -> env = mutt_rfc822_read_header ( fp , hdr , 0 , 0 ) ; hdr -> received = hdr -> date_sent ; mutt_file_fclose ( & fp ) ; } hdr -> index = ctx -> msgcount ++ ; hdr -> read = false ; hdr -> old = false ; hdr -> deleted = false ; hdr -> data = mutt_mem_calloc ( 1 , sizeof ( struct NntpHeaderData ) ) ; NHDR ( hdr ) -> article_num = current ; if ( restore ) hdr -> changed = true ; else { nntp_article_status ( ctx , hdr , NULL , NHDR ( hdr ) -> article_num ) ; if ( ! hdr -> read ) nntp_parse_xref ( ctx , hdr ) ; } if ( current > nntp_data -> last_loaded ) nntp_data -> last_loaded = current ; first_over = current + 1 ; } if ( ! NntpListgroup || ! nntp_data -> nserv -> hasLISTGROUP ) current = first_over ; if ( current <= last && rc == 0 && ! nntp_data -> deleted ) { char * cmd = nntp_data -> nserv -> hasOVER ? ""OVER"" : ""XOVER"" ; snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>%u-%u\\r\\n"" , cmd , current , last ) ; rc = nntp_fetch_lines ( nntp_data , buf , sizeof ( buf ) , NULL , parse_overview_line , & fc ) ; if ( rc > 0 ) { mutt_error ( ""%s:<S2SV_blank>%s"" , cmd , buf ) ; } } if ( ctx -> msgcount > oldmsgcount ) mx_update_context ( ctx , ctx -> msgcount - oldmsgcount ) ; FREE ( & fc . messages ) ; if ( rc != 0 ) return - 1 ; mutt_clear_error ( ) ; return 0 ; }
","<S2SV_ModStart> char ) ) ; if ( fc . messages == NULL ) return - 1
"
703,"CWE-617 static int _lldp_send ( struct lldpd * global , struct lldpd_hardware * hardware , u_int8_t c_id_subtype , char * c_id , int c_id_len , u_int8_t p_id_subtype , char * p_id , int p_id_len , int shutdown ) { struct lldpd_port * port ; struct lldpd_chassis * chassis ; struct lldpd_frame * frame ; int length ; u_int8_t * packet , * pos , * tlv ; struct lldpd_mgmt * mgmt ; int proto ; u_int8_t mcastaddr [ ] = LLDP_MULTICAST_ADDR ; # ifdef ENABLE_DOT1 const u_int8_t dot1 [ ] = LLDP_TLV_ORG_DOT1 ; struct lldpd_vlan * vlan ; struct lldpd_ppvid * ppvid ; struct lldpd_pi * pi ; # endif # ifdef ENABLE_DOT3 const u_int8_t dot3 [ ] = LLDP_TLV_ORG_DOT3 ; # endif # ifdef ENABLE_LLDPMED int i ; const u_int8_t med [ ] = LLDP_TLV_ORG_MED ; # endif # ifdef ENABLE_CUSTOM struct lldpd_custom * custom ; # endif port = & hardware -> h_lport ; chassis = port -> p_chassis ; length = hardware -> h_mtu ; if ( ( packet = ( u_int8_t * ) calloc ( 1 , length ) ) == NULL ) return ENOMEM ; pos = packet ; if ( ! ( POKE_BYTES ( mcastaddr , sizeof ( mcastaddr ) ) && POKE_BYTES ( & hardware -> h_lladdr , ETHER_ADDR_LEN ) && POKE_UINT16 ( ETHERTYPE_LLDP ) ) ) goto toobig ; if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_CHASSIS_ID ) && POKE_UINT8 ( c_id_subtype ) && POKE_BYTES ( c_id , c_id_len ) && POKE_END_LLDP_TLV ) ) goto toobig ; if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_PORT_ID ) && POKE_UINT8 ( p_id_subtype ) && POKE_BYTES ( p_id , p_id_len ) && POKE_END_LLDP_TLV ) ) goto toobig ; if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_TTL ) && POKE_UINT16 ( shutdown ? 0 : chassis -> c_ttl ) && POKE_END_LLDP_TLV ) ) goto toobig ; if ( shutdown ) goto end ; if ( chassis -> c_name && * chassis -> c_name != '\\0' ) { if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_SYSTEM_NAME ) && POKE_BYTES ( chassis -> c_name , strlen ( chassis -> c_name ) ) && POKE_END_LLDP_TLV ) ) goto toobig ; } if ( chassis -> c_descr && * chassis -> c_descr != '\\0' ) { if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_SYSTEM_DESCR ) && POKE_BYTES ( chassis -> c_descr , strlen ( chassis -> c_descr ) ) && POKE_END_LLDP_TLV ) ) goto toobig ; } if ( global -> g_config . c_cap_advertise && chassis -> c_cap_available ) { if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_SYSTEM_CAP ) && POKE_UINT16 ( chassis -> c_cap_available ) && POKE_UINT16 ( chassis -> c_cap_enabled ) && POKE_END_LLDP_TLV ) ) goto toobig ; } TAILQ_FOREACH ( mgmt , & chassis -> c_mgmt , m_entries ) { proto = lldpd_af_to_lldp_proto ( mgmt -> m_family ) ; <S2SV_StartBug> assert ( proto != LLDP_MGMT_ADDR_NONE ) ; <S2SV_EndBug> if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_MGMT_ADDR ) && POKE_UINT8 ( mgmt -> m_addrsize + 1 ) && POKE_UINT8 ( proto ) && POKE_BYTES ( & mgmt -> m_addr , mgmt -> m_addrsize ) ) ) goto toobig ; if ( mgmt -> m_iface == 0 ) { if ( ! ( POKE_UINT8 ( LLDP_MGMT_IFACE_UNKNOWN ) && POKE_UINT32 ( 0 ) ) ) goto toobig ; } else { if ( ! ( POKE_UINT8 ( LLDP_MGMT_IFACE_IFINDEX ) && POKE_UINT32 ( mgmt -> m_iface ) ) ) goto toobig ; } if ( ! ( POKE_UINT8 ( 0 ) && POKE_END_LLDP_TLV ) ) goto toobig ; } if ( port -> p_descr && * port -> p_descr != '\\0' ) { if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_PORT_DESCR ) && POKE_BYTES ( port -> p_descr , strlen ( port -> p_descr ) ) && POKE_END_LLDP_TLV ) ) goto toobig ; } # ifdef ENABLE_DOT1 if ( port -> p_pvid != 0 ) { if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_ORG ) && POKE_BYTES ( dot1 , sizeof ( dot1 ) ) && POKE_UINT8 ( LLDP_TLV_DOT1_PVID ) && POKE_UINT16 ( port -> p_pvid ) && POKE_END_LLDP_TLV ) ) { goto toobig ; } } TAILQ_FOREACH ( ppvid , & port -> p_ppvids , p_entries ) { if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_ORG ) && POKE_BYTES ( dot1 , sizeof ( dot1 ) ) && POKE_UINT8 ( LLDP_TLV_DOT1_PPVID ) && POKE_UINT8 ( ppvid -> p_cap_status ) && POKE_UINT16 ( ppvid -> p_ppvid ) && POKE_END_LLDP_TLV ) ) { goto toobig ; } } TAILQ_FOREACH ( vlan , & port -> p_vlans , v_entries ) { if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_ORG ) && POKE_BYTES ( dot1 , sizeof ( dot1 ) ) && POKE_UINT8 ( LLDP_TLV_DOT1_VLANNAME ) && POKE_UINT16 ( vlan -> v_vid ) && POKE_UINT8 ( strlen ( vlan -> v_name ) ) && POKE_BYTES ( vlan -> v_name , strlen ( vlan -> v_name ) ) && POKE_END_LLDP_TLV ) ) goto toobig ; } TAILQ_FOREACH ( pi , & port -> p_pids , p_entries ) { if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_ORG ) && POKE_BYTES ( dot1 , sizeof ( dot1 ) ) && POKE_UINT8 ( LLDP_TLV_DOT1_PI ) && POKE_UINT8 ( pi -> p_pi_len ) && POKE_BYTES ( pi -> p_pi , pi -> p_pi_len ) && POKE_END_LLDP_TLV ) ) goto toobig ; } # endif # ifdef ENABLE_DOT3 if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_ORG ) && POKE_BYTES ( dot3 , sizeof ( dot3 ) ) && POKE_UINT8 ( LLDP_TLV_DOT3_LA ) && POKE_UINT8 ( ( port -> p_aggregid ) ? 3 : 1 ) && POKE_UINT32 ( port -> p_aggregid ) && POKE_END_LLDP_TLV ) ) goto toobig ; if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_ORG ) && POKE_BYTES ( dot3 , sizeof ( dot3 ) ) && POKE_UINT8 ( LLDP_TLV_DOT3_MAC ) && POKE_UINT8 ( port -> p_macphy . autoneg_support | ( port -> p_macphy . autoneg_enabled << 1 ) ) && POKE_UINT16 ( port -> p_macphy . autoneg_advertised ) && POKE_UINT16 ( port -> p_macphy . mau_type ) && POKE_END_LLDP_TLV ) ) goto toobig ; if ( port -> p_mfs ) { if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_ORG ) && POKE_BYTES ( dot3 , sizeof ( dot3 ) ) && POKE_UINT8 ( LLDP_TLV_DOT3_MFS ) && POKE_UINT16 ( port -> p_mfs ) && POKE_END_LLDP_TLV ) ) goto toobig ; } if ( port -> p_power . devicetype ) { if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_ORG ) && POKE_BYTES ( dot3 , sizeof ( dot3 ) ) && POKE_UINT8 ( LLDP_TLV_DOT3_POWER ) && POKE_UINT8 ( ( ( ( ( 2 - port -> p_power . devicetype ) % ( 1 << 1 ) ) << 0 ) | ( ( port -> p_power . supported % ( 1 << 1 ) ) << 1 ) | ( ( port -> p_power . enabled % ( 1 << 1 ) ) << 2 ) | ( ( port -> p_power . paircontrol % ( 1 << 1 ) ) << 3 ) ) ) && POKE_UINT8 ( port -> p_power . pairs ) && POKE_UINT8 ( port -> p_power . class ) ) ) goto toobig ; if ( port -> p_power . powertype != LLDP_DOT3_POWER_8023AT_OFF ) { if ( ! ( POKE_UINT8 ( ( ( ( ( port -> p_power . powertype == LLDP_DOT3_POWER_8023AT_TYPE1 ) ? 1 : 0 ) << 7 ) | ( ( ( port -> p_power . devicetype == LLDP_DOT3_POWER_PSE ) ? 0 : 1 ) << 6 ) | ( ( port -> p_power . source % ( 1 << 2 ) ) << 4 ) | ( ( port -> p_power . priority % ( 1 << 2 ) ) << 0 ) ) ) && POKE_UINT16 ( port -> p_power . requested ) && POKE_UINT16 ( port -> p_power . allocated ) ) ) goto toobig ; } if ( ! ( POKE_END_LLDP_TLV ) ) goto toobig ; } # endif # ifdef ENABLE_LLDPMED if ( port -> p_med_cap_enabled ) { if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_ORG ) && POKE_BYTES ( med , sizeof ( med ) ) && POKE_UINT8 ( LLDP_TLV_MED_CAP ) && POKE_UINT16 ( chassis -> c_med_cap_available ) && POKE_UINT8 ( chassis -> c_med_type ) && POKE_END_LLDP_TLV ) ) goto toobig ; # define LLDP_INVENTORY ( value , subtype ) if ( value ) { if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_ORG ) && POKE_BYTES ( med , sizeof ( med ) ) && POKE_UINT8 ( subtype ) && POKE_BYTES ( value , ( strlen ( value ) > 32 ) ? 32 : strlen ( value ) ) && POKE_END_LLDP_TLV ) ) goto toobig ; } if ( port -> p_med_cap_enabled & LLDP_MED_CAP_IV ) { LLDP_INVENTORY ( chassis -> c_med_hw , LLDP_TLV_MED_IV_HW ) ; LLDP_INVENTORY ( chassis -> c_med_fw , LLDP_TLV_MED_IV_FW ) ; LLDP_INVENTORY ( chassis -> c_med_sw , LLDP_TLV_MED_IV_SW ) ; LLDP_INVENTORY ( chassis -> c_med_sn , LLDP_TLV_MED_IV_SN ) ; LLDP_INVENTORY ( chassis -> c_med_manuf , LLDP_TLV_MED_IV_MANUF ) ; LLDP_INVENTORY ( chassis -> c_med_model , LLDP_TLV_MED_IV_MODEL ) ; LLDP_INVENTORY ( chassis -> c_med_asset , LLDP_TLV_MED_IV_ASSET ) ; } for ( i = 0 ; i < LLDP_MED_LOCFORMAT_LAST ; i ++ ) { if ( port -> p_med_location [ i ] . format == i + 1 ) { if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_ORG ) && POKE_BYTES ( med , sizeof ( med ) ) && POKE_UINT8 ( LLDP_TLV_MED_LOCATION ) && POKE_UINT8 ( port -> p_med_location [ i ] . format ) && POKE_BYTES ( port -> p_med_location [ i ] . data , port -> p_med_location [ i ] . data_len ) && POKE_END_LLDP_TLV ) ) goto toobig ; } } for ( i = 0 ; i < LLDP_MED_APPTYPE_LAST ; i ++ ) { if ( port -> p_med_policy [ i ] . type == i + 1 ) { if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_ORG ) && POKE_BYTES ( med , sizeof ( med ) ) && POKE_UINT8 ( LLDP_TLV_MED_POLICY ) && POKE_UINT32 ( ( ( ( port -> p_med_policy [ i ] . type % ( 1 << 8 ) ) << 24 ) | ( ( port -> p_med_policy [ i ] . unknown % ( 1 << 1 ) ) << 23 ) | ( ( port -> p_med_policy [ i ] . tagged % ( 1 << 1 ) ) << 22 ) | ( ( port -> p_med_policy [ i ] . vid % ( 1 << 12 ) ) << 9 ) | ( ( port -> p_med_policy [ i ] . priority % ( 1 << 3 ) ) << 6 ) | ( ( port -> p_med_policy [ i ] . dscp % ( 1 << 6 ) ) << 0 ) ) ) && POKE_END_LLDP_TLV ) ) goto toobig ; } } if ( ( port -> p_med_power . devicetype == LLDP_MED_POW_TYPE_PSE ) || ( port -> p_med_power . devicetype == LLDP_MED_POW_TYPE_PD ) ) { int devicetype = 0 , source = 0 ; if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_ORG ) && POKE_BYTES ( med , sizeof ( med ) ) && POKE_UINT8 ( LLDP_TLV_MED_MDI ) ) ) goto toobig ; switch ( port -> p_med_power . devicetype ) { case LLDP_MED_POW_TYPE_PSE : devicetype = 0 ; switch ( port -> p_med_power . source ) { case LLDP_MED_POW_SOURCE_PRIMARY : source = 1 ; break ; case LLDP_MED_POW_SOURCE_BACKUP : source = 2 ; break ; case LLDP_MED_POW_SOURCE_RESERVED : source = 3 ; break ; default : source = 0 ; break ; } break ; case LLDP_MED_POW_TYPE_PD : devicetype = 1 ; switch ( port -> p_med_power . source ) { case LLDP_MED_POW_SOURCE_PSE : source = 1 ; break ; case LLDP_MED_POW_SOURCE_LOCAL : source = 2 ; break ; case LLDP_MED_POW_SOURCE_BOTH : source = 3 ; break ; default : source = 0 ; break ; } break ; } if ( ! ( POKE_UINT8 ( ( ( ( devicetype % ( 1 << 2 ) ) << 6 ) | ( ( source % ( 1 << 2 ) ) << 4 ) | ( ( port -> p_med_power . priority % ( 1 << 4 ) ) << 0 ) ) ) && POKE_UINT16 ( port -> p_med_power . val ) && POKE_END_LLDP_TLV ) ) goto toobig ; } } # endif # ifdef ENABLE_CUSTOM TAILQ_FOREACH ( custom , & port -> p_custom_list , next ) { if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_ORG ) && POKE_BYTES ( custom -> oui , sizeof ( custom -> oui ) ) && POKE_UINT8 ( custom -> subtype ) && POKE_BYTES ( custom -> oui_info , custom -> oui_info_len ) && POKE_END_LLDP_TLV ) ) goto toobig ; } # endif end : if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_END ) && POKE_END_LLDP_TLV ) ) goto toobig ; if ( interfaces_send_helper ( global , hardware , ( char * ) packet , pos - packet ) == - 1 ) { log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>send<S2SV_blank>packet<S2SV_blank>on<S2SV_blank>real<S2SV_blank>device<S2SV_blank>for<S2SV_blank>%s"" , hardware -> h_ifname ) ; free ( packet ) ; return ENETDOWN ; } hardware -> h_tx_cnt ++ ; if ( ! shutdown && ( frame = ( struct lldpd_frame * ) malloc ( sizeof ( int ) + pos - packet ) ) != NULL ) { frame -> size = pos - packet ; memcpy ( & frame -> frame , packet , frame -> size ) ; if ( ( hardware -> h_lport . p_lastframe == NULL ) || ( hardware -> h_lport . p_lastframe -> size != frame -> size ) || ( memcmp ( hardware -> h_lport . p_lastframe -> frame , frame -> frame , frame -> size ) != 0 ) ) { free ( hardware -> h_lport . p_lastframe ) ; hardware -> h_lport . p_lastframe = frame ; hardware -> h_lport . p_lastchange = time ( NULL ) ; } else free ( frame ) ; } free ( packet ) ; return 0 ; toobig : free ( packet ) ; return E2BIG ; }
","<S2SV_ModStart> m_family ) ; if ( proto == LLDP_MGMT_ADDR_NONE ) continue <S2SV_ModEnd> ; if (
"
704,"CWE-264 struct dst_entry * inet6_csk_route_req ( const struct sock * sk , struct flowi6 * fl6 , const struct request_sock * req , u8 proto ) { struct inet_request_sock * ireq = inet_rsk ( req ) ; const struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct in6_addr * final_p , final ; struct dst_entry * dst ; memset ( fl6 , 0 , sizeof ( * fl6 ) ) ; fl6 -> flowi6_proto = proto ; fl6 -> daddr = ireq -> ir_v6_rmt_addr ; <S2SV_StartBug> final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ; <S2SV_EndBug> <S2SV_StartBug> fl6 -> saddr = ireq -> ir_v6_loc_addr ; <S2SV_EndBug> fl6 -> flowi6_oif = ireq -> ir_iif ; fl6 -> flowi6_mark = ireq -> ir_mark ; fl6 -> fl6_dport = ireq -> ir_rmt_port ; fl6 -> fl6_sport = htons ( ireq -> ir_num ) ; security_req_classify_flow ( req , flowi6_to_flowi ( fl6 ) ) ; dst = ip6_dst_lookup_flow ( sk , fl6 , final_p ) ; if ( IS_ERR ( dst ) ) return NULL ; return dst ; }
","<S2SV_ModStart> -> ir_v6_rmt_addr ; rcu_read_lock ( ) ; <S2SV_ModStart> ( fl6 , rcu_dereference ( <S2SV_ModStart> np -> opt ) <S2SV_ModStart> final ) ; rcu_read_unlock ( ) ;
"
705,"CWE-119 SQLWCHAR * _single_string_alloc_and_expand ( LPCSTR in ) { SQLWCHAR * chr ; int len = 0 ; if ( ! in ) { <S2SV_StartBug> return in ; <S2SV_EndBug> } while ( in [ len ] != 0 ) { len ++ ; } chr = malloc ( sizeof ( SQLWCHAR ) * ( len + 1 ) ) ; len = 0 ; while ( in [ len ] != 0 ) { chr [ len ] = in [ len ] ; len ++ ; } chr [ len ++ ] = 0 ; return chr ; }
","<S2SV_ModStart> ) { return NULL <S2SV_ModEnd> ; } while
"
706,"CWE-20 static void activate_desktop_file ( ActivateParameters * parameters , NautilusFile * file ) { ActivateParametersDesktop * parameters_desktop ; char * primary , * secondary , * display_name ; GtkWidget * dialog ; GdkScreen * screen ; char * uri ; screen = gtk_widget_get_screen ( GTK_WIDGET ( parameters -> parent_window ) ) ; if ( ! nautilus_file_is_trusted_link ( file ) ) { parameters_desktop = g_new0 ( ActivateParametersDesktop , 1 ) ; if ( parameters -> parent_window ) { parameters_desktop -> parent_window = parameters -> parent_window ; g_object_add_weak_pointer ( G_OBJECT ( parameters_desktop -> parent_window ) , ( gpointer * ) & parameters_desktop -> parent_window ) ; } parameters_desktop -> file = nautilus_file_ref ( file ) ; primary = _ ( ""Untrusted<S2SV_blank>application<S2SV_blank>launcher"" ) ; display_name = nautilus_file_get_display_name ( file ) ; secondary = g_strdup_printf ( _ ( ""The<S2SV_blank>application<S2SV_blank>launcher<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>not<S2SV_blank>been<S2SV_blank>marked<S2SV_blank>as<S2SV_blank>trusted.<S2SV_blank>"" ""If<S2SV_blank>you<S2SV_blank>do<S2SV_blank>not<S2SV_blank>know<S2SV_blank>the<S2SV_blank>source<S2SV_blank>of<S2SV_blank>this<S2SV_blank>file,<S2SV_blank>launching<S2SV_blank>it<S2SV_blank>may<S2SV_blank>be<S2SV_blank>unsafe."" ) , display_name ) ; dialog = gtk_message_dialog_new ( parameters -> parent_window , 0 , GTK_MESSAGE_WARNING , GTK_BUTTONS_NONE , NULL ) ; g_object_set ( dialog , ""text"" , primary , ""secondary-text"" , secondary , NULL ) ; gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , <S2SV_StartBug> _ ( ""_Launch<S2SV_blank>Anyway"" ) , RESPONSE_RUN ) ; <S2SV_EndBug> if ( nautilus_file_can_set_permissions ( file ) ) { gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , <S2SV_StartBug> _ ( ""Mark<S2SV_blank>as<S2SV_blank>_Trusted"" ) , RESPONSE_MARK_TRUSTED ) ; <S2SV_EndBug> } <S2SV_StartBug> gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , <S2SV_EndBug> _ ( ""_Cancel"" ) , GTK_RESPONSE_CANCEL ) ; gtk_dialog_set_default_response ( GTK_DIALOG ( dialog ) , GTK_RESPONSE_CANCEL ) ; g_signal_connect ( dialog , ""response"" , G_CALLBACK ( untrusted_launcher_response_callback ) , parameters_desktop ) ; gtk_widget_show ( dialog ) ; g_free ( display_name ) ; g_free ( secondary ) ; return ; } uri = nautilus_file_get_uri ( file ) ; DEBUG ( ""Launching<S2SV_blank>trusted<S2SV_blank>launcher<S2SV_blank>%s"" , uri ) ; nautilus_launch_desktop_file ( screen , uri , NULL , parameters -> parent_window ) ; g_free ( uri ) ; }
","<S2SV_ModStart> , _ ( ""_Cancel"" ) , GTK_RESPONSE_CANCEL ) ; gtk_dialog_set_default_response ( GTK_DIALOG ( dialog ) , GTK_RESPONSE_CANCEL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , _ ( ""Trust<S2SV_blank>and<S2SV_blank>_Launch"" ) , GTK_RESPONSE_OK <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> g_signal_connect ( dialog
"
707,"CWE-476 static int whereIndexExprTransColumn ( Walker * p , Expr * pExpr ) { if ( pExpr -> op == TK_COLUMN ) { IdxExprTrans * pX = p -> u . pIdxTrans ; if ( pExpr -> iTable == pX -> iTabCur && pExpr -> iColumn == pX -> iTabCol ) { <S2SV_StartBug> pExpr -> iTable = pX -> iIdxCur ; <S2SV_EndBug> pExpr -> iColumn = pX -> iIdxCol ; pExpr -> y . pTab = 0 ; } } return WRC_Continue ; }
","<S2SV_ModStart> iTabCol ) { assert ( pExpr -> y . pTab != 0 ) ; pExpr -> affExpr = sqlite3TableColumnAffinity ( pExpr -> y . pTab , pExpr -> iColumn ) ;
"
708,"CWE-119 static int DecodeNumberField ( int len , char * str , int fmask , int * tmask , struct tm * tm , fsec_t * fsec , int * is2digits ) { char * cp ; if ( ( cp = strchr ( str , '.' ) ) != NULL ) { # ifdef HAVE_INT64_TIMESTAMP <S2SV_StartBug> char fstr [ MAXDATELEN + 1 ] ; <S2SV_EndBug> strcpy ( fstr , ( cp + 1 ) ) ; strcpy ( fstr + strlen ( fstr ) , ""000000"" ) ; * ( fstr + 6 ) = '\\0' ; * fsec = strtol ( fstr , NULL , 10 ) ; # else * fsec = strtod ( cp , NULL ) ; # endif * cp = '\\0' ; len = strlen ( str ) ; } else if ( ( fmask & DTK_DATE_M ) != DTK_DATE_M ) { if ( len == 8 ) { * tmask = DTK_DATE_M ; tm -> tm_mday = atoi ( str + 6 ) ; * ( str + 6 ) = '\\0' ; tm -> tm_mon = atoi ( str + 4 ) ; * ( str + 4 ) = '\\0' ; tm -> tm_year = atoi ( str + 0 ) ; return DTK_DATE ; } else if ( len == 6 ) { * tmask = DTK_DATE_M ; tm -> tm_mday = atoi ( str + 4 ) ; * ( str + 4 ) = '\\0' ; tm -> tm_mon = atoi ( str + 2 ) ; * ( str + 2 ) = '\\0' ; tm -> tm_year = atoi ( str + 0 ) ; * is2digits = TRUE ; return DTK_DATE ; } else if ( len == 5 ) { * tmask = DTK_DATE_M ; tm -> tm_mday = atoi ( str + 2 ) ; * ( str + 2 ) = '\\0' ; tm -> tm_mon = 1 ; tm -> tm_year = atoi ( str + 0 ) ; * is2digits = TRUE ; return DTK_DATE ; } } if ( ( fmask & DTK_TIME_M ) != DTK_TIME_M ) { if ( len == 6 ) { * tmask = DTK_TIME_M ; tm -> tm_sec = atoi ( str + 4 ) ; * ( str + 4 ) = '\\0' ; tm -> tm_min = atoi ( str + 2 ) ; * ( str + 2 ) = '\\0' ; tm -> tm_hour = atoi ( str + 0 ) ; return DTK_TIME ; } else if ( len == 4 ) { * tmask = DTK_TIME_M ; tm -> tm_sec = 0 ; tm -> tm_min = atoi ( str + 2 ) ; * ( str + 2 ) = '\\0' ; tm -> tm_hour = atoi ( str + 0 ) ; return DTK_TIME ; } } return - 1 ; }
","<S2SV_ModStart> char fstr [ 7 ] ; int i ; cp ++ ; for ( i = 0 ; i < 6 ; i ++ ) fstr [ i ] = * cp != '\\0' ? * cp ++ : '0' ; fstr [ i ] <S2SV_ModEnd> = '\\0' ;
"
709,"CWE-399 static int dissect_spoolss_keybuffer ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep ) { guint32 size ; int end_offset ; if ( di -> conformant_run ) return offset ; offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_keybuffer_size , & size ) ; end_offset = offset + ( size * 2 ) ; if ( end_offset < offset ) { end_offset = tvb_reported_length_remaining ( tvb , offset ) + 1 ; } <S2SV_StartBug> while ( offset < end_offset ) <S2SV_EndBug> offset = dissect_spoolss_uint16uni ( tvb , offset , pinfo , tree , drep , NULL , hf_keybuffer ) ; <S2SV_StartBug> return offset ; <S2SV_EndBug> }
","<S2SV_ModStart> while ( offset > 0 && offset <S2SV_ModStart> < end_offset ) { <S2SV_ModStart> hf_keybuffer ) ; }
"
710,"CWE-200 static long __tun_chr_ioctl ( struct file * file , unsigned int cmd , unsigned long arg , int ifreq_len ) { struct tun_file * tfile = file -> private_data ; struct tun_struct * tun ; void __user * argp = ( void __user * ) arg ; struct sock_fprog fprog ; struct ifreq ifr ; int sndbuf ; int vnet_hdr_sz ; int ret ; <S2SV_StartBug> if ( cmd == TUNSETIFF || _IOC_TYPE ( cmd ) == 0x89 ) <S2SV_EndBug> if ( copy_from_user ( & ifr , argp , ifreq_len ) ) <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> if ( cmd == TUNGETFEATURES ) { return put_user ( IFF_TUN | IFF_TAP | IFF_NO_PI | IFF_ONE_QUEUE | IFF_VNET_HDR , ( unsigned int __user * ) argp ) ; } rtnl_lock ( ) ; tun = __tun_get ( tfile ) ; if ( cmd == TUNSETIFF && ! tun ) { ifr . ifr_name [ IFNAMSIZ - 1 ] = '\\0' ; ret = tun_set_iff ( tfile -> net , file , & ifr ) ; if ( ret ) goto unlock ; if ( copy_to_user ( argp , & ifr , ifreq_len ) ) ret = - EFAULT ; goto unlock ; } ret = - EBADFD ; if ( ! tun ) goto unlock ; tun_debug ( KERN_INFO , tun , ""tun_chr_ioctl<S2SV_blank>cmd<S2SV_blank>%d\\n"" , cmd ) ; ret = 0 ; switch ( cmd ) { case TUNGETIFF : ret = tun_get_iff ( current -> nsproxy -> net_ns , tun , & ifr ) ; if ( ret ) break ; if ( copy_to_user ( argp , & ifr , ifreq_len ) ) ret = - EFAULT ; break ; case TUNSETNOCSUM : tun_debug ( KERN_INFO , tun , ""ignored:<S2SV_blank>set<S2SV_blank>checksum<S2SV_blank>%s\\n"" , arg ? ""disabled"" : ""enabled"" ) ; break ; case TUNSETPERSIST : if ( arg ) tun -> flags |= TUN_PERSIST ; else tun -> flags &= ~ TUN_PERSIST ; tun_debug ( KERN_INFO , tun , ""persist<S2SV_blank>%s\\n"" , arg ? ""enabled"" : ""disabled"" ) ; break ; case TUNSETOWNER : tun -> owner = ( uid_t ) arg ; tun_debug ( KERN_INFO , tun , ""owner<S2SV_blank>set<S2SV_blank>to<S2SV_blank>%d\\n"" , tun -> owner ) ; break ; case TUNSETGROUP : tun -> group = ( gid_t ) arg ; tun_debug ( KERN_INFO , tun , ""group<S2SV_blank>set<S2SV_blank>to<S2SV_blank>%d\\n"" , tun -> group ) ; break ; case TUNSETLINK : if ( tun -> dev -> flags & IFF_UP ) { tun_debug ( KERN_INFO , tun , ""Linktype<S2SV_blank>set<S2SV_blank>failed<S2SV_blank>because<S2SV_blank>interface<S2SV_blank>is<S2SV_blank>up\\n"" ) ; ret = - EBUSY ; } else { tun -> dev -> type = ( int ) arg ; tun_debug ( KERN_INFO , tun , ""linktype<S2SV_blank>set<S2SV_blank>to<S2SV_blank>%d\\n"" , tun -> dev -> type ) ; ret = 0 ; } break ; # ifdef TUN_DEBUG case TUNSETDEBUG : tun -> debug = arg ; break ; # endif case TUNSETOFFLOAD : ret = set_offload ( tun , arg ) ; break ; case TUNSETTXFILTER : ret = - EINVAL ; if ( ( tun -> flags & TUN_TYPE_MASK ) != TUN_TAP_DEV ) break ; ret = update_filter ( & tun -> txflt , ( void __user * ) arg ) ; break ; case SIOCGIFHWADDR : memcpy ( ifr . ifr_hwaddr . sa_data , tun -> dev -> dev_addr , ETH_ALEN ) ; ifr . ifr_hwaddr . sa_family = tun -> dev -> type ; if ( copy_to_user ( argp , & ifr , ifreq_len ) ) ret = - EFAULT ; break ; case SIOCSIFHWADDR : tun_debug ( KERN_DEBUG , tun , ""set<S2SV_blank>hw<S2SV_blank>address:<S2SV_blank>%pM\\n"" , ifr . ifr_hwaddr . sa_data ) ; ret = dev_set_mac_address ( tun -> dev , & ifr . ifr_hwaddr ) ; break ; case TUNGETSNDBUF : sndbuf = tun -> socket . sk -> sk_sndbuf ; if ( copy_to_user ( argp , & sndbuf , sizeof ( sndbuf ) ) ) ret = - EFAULT ; break ; case TUNSETSNDBUF : if ( copy_from_user ( & sndbuf , argp , sizeof ( sndbuf ) ) ) { ret = - EFAULT ; break ; } tun -> socket . sk -> sk_sndbuf = sndbuf ; break ; case TUNGETVNETHDRSZ : vnet_hdr_sz = tun -> vnet_hdr_sz ; if ( copy_to_user ( argp , & vnet_hdr_sz , sizeof ( vnet_hdr_sz ) ) ) ret = - EFAULT ; break ; case TUNSETVNETHDRSZ : if ( copy_from_user ( & vnet_hdr_sz , argp , sizeof ( vnet_hdr_sz ) ) ) { ret = - EFAULT ; break ; } if ( vnet_hdr_sz < ( int ) sizeof ( struct virtio_net_hdr ) ) { ret = - EINVAL ; break ; } tun -> vnet_hdr_sz = vnet_hdr_sz ; break ; case TUNATTACHFILTER : ret = - EINVAL ; if ( ( tun -> flags & TUN_TYPE_MASK ) != TUN_TAP_DEV ) break ; ret = - EFAULT ; if ( copy_from_user ( & fprog , argp , sizeof ( fprog ) ) ) break ; ret = sk_attach_filter ( & fprog , tun -> socket . sk ) ; break ; case TUNDETACHFILTER : ret = - EINVAL ; if ( ( tun -> flags & TUN_TYPE_MASK ) != TUN_TAP_DEV ) break ; ret = sk_detach_filter ( tun -> socket . sk ) ; break ; default : ret = - EINVAL ; break ; } unlock : rtnl_unlock ( ) ; if ( tun ) tun_put ( tun ) ; return ret ; }
","<S2SV_ModStart> == 0x89 ) { <S2SV_ModStart> return - EFAULT ; } else memset ( & ifr , 0 , sizeof ( ifr ) )
"
711,"CWE-399 static int cms_copy_content ( BIO * out , BIO * in , unsigned int flags ) { unsigned char buf [ 4096 ] ; int r = 0 , i ; <S2SV_StartBug> BIO * tmpout = NULL ; <S2SV_EndBug> if ( out == NULL ) tmpout = BIO_new ( BIO_s_null ( ) ) ; else if ( flags & CMS_TEXT ) { <S2SV_StartBug> tmpout = BIO_new ( BIO_s_mem ( ) ) ; <S2SV_EndBug> BIO_set_mem_eof_return ( tmpout , 0 ) ; } else tmpout = out ; if ( ! tmpout ) { CMSerr ( CMS_F_CMS_COPY_CONTENT , ERR_R_MALLOC_FAILURE ) ; goto err ; } for ( ; ; ) { i = BIO_read ( in , buf , sizeof ( buf ) ) ; if ( i <= 0 ) { if ( BIO_method_type ( in ) == BIO_TYPE_CIPHER ) { if ( ! BIO_get_cipher_status ( in ) ) goto err ; } if ( i < 0 ) goto err ; break ; } if ( tmpout && ( BIO_write ( tmpout , buf , i ) != i ) ) goto err ; } if ( flags & CMS_TEXT ) { if ( ! SMIME_text ( tmpout , out ) ) { CMSerr ( CMS_F_CMS_COPY_CONTENT , CMS_R_SMIME_TEXT_ERROR ) ; goto err ; } } r = 1 ; err : if ( tmpout && ( tmpout != out ) ) BIO_free ( tmpout ) ; return r ; }
","<S2SV_ModStart> BIO * tmpout ; tmpout = cms_get_text_bio ( out , flags ) ; if ( ! tmpout ) { CMSerr ( CMS_F_CMS_COPY_CONTENT , ERR_R_MALLOC_FAILURE ) ; goto err ; } for ( ; ; ) { i = BIO_read ( in , buf , sizeof ( buf ) ) ; if ( i <= 0 ) { if ( BIO_method_type ( in ) == BIO_TYPE_CIPHER ) { if ( ! BIO_get_cipher_status ( in ) ) goto err ; } if ( i < 0 ) goto err ; break ; } if ( tmpout && ( BIO_write ( tmpout , buf , i ) != i ) ) goto err ; } <S2SV_ModEnd> if ( flags <S2SV_ModStart> CMS_TEXT ) { <S2SV_ModEnd> if ( !
"
712,"CWE-119 int ParseDateTime ( char * timestr , char * lowstr , char * * field , int * ftype , int * numfields , char * * endstr ) { int nf = 0 ; char * lp = lowstr ; * endstr = timestr ; while ( * ( * endstr ) != '\\0' ) { <S2SV_StartBug> field [ nf ] = lp ; <S2SV_EndBug> if ( isdigit ( ( unsigned char ) * ( * endstr ) ) ) { * lp ++ = * ( * endstr ) ++ ; while ( isdigit ( ( unsigned char ) * ( * endstr ) ) ) * lp ++ = * ( * endstr ) ++ ; if ( * ( * endstr ) == ':' ) { ftype [ nf ] = DTK_TIME ; * lp ++ = * ( * endstr ) ++ ; while ( isdigit ( ( unsigned char ) * ( * endstr ) ) || ( * ( * endstr ) == ':' ) || ( * ( * endstr ) == '.' ) ) * lp ++ = * ( * endstr ) ++ ; } else if ( * ( * endstr ) == '-' || * ( * endstr ) == '/' || * ( * endstr ) == '.' ) { char * dp = ( * endstr ) ; * lp ++ = * ( * endstr ) ++ ; if ( isdigit ( ( unsigned char ) * ( * endstr ) ) ) { ftype [ nf ] = ( * dp == '.' ) ? DTK_NUMBER : DTK_DATE ; while ( isdigit ( ( unsigned char ) * ( * endstr ) ) ) * lp ++ = * ( * endstr ) ++ ; if ( * ( * endstr ) == * dp ) { ftype [ nf ] = DTK_DATE ; * lp ++ = * ( * endstr ) ++ ; while ( isdigit ( ( unsigned char ) * ( * endstr ) ) || ( * ( * endstr ) == * dp ) ) * lp ++ = * ( * endstr ) ++ ; } } else { ftype [ nf ] = DTK_DATE ; while ( isalnum ( ( unsigned char ) * ( * endstr ) ) || ( * ( * endstr ) == * dp ) ) * lp ++ = pg_tolower ( ( unsigned char ) * ( * endstr ) ++ ) ; } } else ftype [ nf ] = DTK_NUMBER ; } else if ( * ( * endstr ) == '.' ) { * lp ++ = * ( * endstr ) ++ ; while ( isdigit ( ( unsigned char ) * ( * endstr ) ) ) * lp ++ = * ( * endstr ) ++ ; ftype [ nf ] = DTK_NUMBER ; } else if ( isalpha ( ( unsigned char ) * ( * endstr ) ) ) { ftype [ nf ] = DTK_STRING ; * lp ++ = pg_tolower ( ( unsigned char ) * ( * endstr ) ++ ) ; while ( isalpha ( ( unsigned char ) * ( * endstr ) ) ) * lp ++ = pg_tolower ( ( unsigned char ) * ( * endstr ) ++ ) ; if ( * ( * endstr ) == '-' || * ( * endstr ) == '/' || * ( * endstr ) == '.' ) { char * dp = ( * endstr ) ; ftype [ nf ] = DTK_DATE ; * lp ++ = * ( * endstr ) ++ ; while ( isdigit ( ( unsigned char ) * ( * endstr ) ) || * ( * endstr ) == * dp ) * lp ++ = * ( * endstr ) ++ ; } } else if ( isspace ( ( unsigned char ) * ( * endstr ) ) ) { ( * endstr ) ++ ; continue ; } else if ( * ( * endstr ) == '+' || * ( * endstr ) == '-' ) { * lp ++ = * ( * endstr ) ++ ; while ( isspace ( ( unsigned char ) * ( * endstr ) ) ) ( * endstr ) ++ ; if ( isdigit ( ( unsigned char ) * ( * endstr ) ) ) { ftype [ nf ] = DTK_TZ ; * lp ++ = * ( * endstr ) ++ ; while ( isdigit ( ( unsigned char ) * ( * endstr ) ) || ( * ( * endstr ) == ':' ) || ( * ( * endstr ) == '.' ) ) * lp ++ = * ( * endstr ) ++ ; } else if ( isalpha ( ( unsigned char ) * ( * endstr ) ) ) { ftype [ nf ] = DTK_SPECIAL ; * lp ++ = pg_tolower ( ( unsigned char ) * ( * endstr ) ++ ) ; while ( isalpha ( ( unsigned char ) * ( * endstr ) ) ) * lp ++ = pg_tolower ( ( unsigned char ) * ( * endstr ) ++ ) ; } else return - 1 ; } else if ( ispunct ( ( unsigned char ) * ( * endstr ) ) ) { ( * endstr ) ++ ; continue ; } else return - 1 ; * lp ++ = '\\0' ; nf ++ ; <S2SV_StartBug> if ( nf > MAXDATEFIELDS ) <S2SV_EndBug> return - 1 ; } * numfields = nf ; return 0 ; }
","<S2SV_ModStart> ] = lp ; if ( nf >= MAXDATEFIELDS ) return - 1 <S2SV_ModStart> nf ++ ; <S2SV_ModEnd> } * numfields
"
713,"CWE-399 static int scm_fp_copy ( struct cmsghdr * cmsg , struct scm_fp_list * * fplp ) { int * fdp = ( int * ) CMSG_DATA ( cmsg ) ; struct scm_fp_list * fpl = * fplp ; struct file * * fpp ; int i , num ; num = ( cmsg -> cmsg_len - CMSG_ALIGN ( sizeof ( struct cmsghdr ) ) ) / sizeof ( int ) ; if ( num <= 0 ) return 0 ; if ( num > SCM_MAX_FD ) return - EINVAL ; if ( ! fpl ) { fpl = kmalloc ( sizeof ( struct scm_fp_list ) , GFP_KERNEL ) ; if ( ! fpl ) return - ENOMEM ; * fplp = fpl ; fpl -> count = 0 ; fpl -> max = SCM_MAX_FD ; <S2SV_StartBug> } <S2SV_EndBug> fpp = & fpl -> fp [ fpl -> count ] ; if ( fpl -> count + num > fpl -> max ) return - EINVAL ; for ( i = 0 ; i < num ; i ++ ) { int fd = fdp [ i ] ; struct file * file ; if ( fd < 0 || ! ( file = fget_raw ( fd ) ) ) return - EBADF ; * fpp ++ = file ; fpl -> count ++ ; } <S2SV_StartBug> return num ; <S2SV_EndBug> }
","<S2SV_ModStart> = SCM_MAX_FD ; fpl -> user = NULL ; <S2SV_ModStart> ++ ; } if ( ! fpl -> user ) fpl -> user = get_uid ( current_user ( ) ) ;
"
714,"CWE-20 void kvm_lapic_sync_to_vapic ( struct kvm_vcpu * vcpu ) { u32 data , tpr ; int max_irr , max_isr ; <S2SV_StartBug> struct kvm_lapic * apic = vcpu -> arch . apic ; <S2SV_EndBug> void * vapic ; apic_sync_pv_eoi_to_guest ( vcpu , apic ) ; if ( ! test_bit ( KVM_APIC_CHECK_VAPIC , & vcpu -> arch . apic_attention ) ) return ; tpr = kvm_apic_get_reg ( apic , APIC_TASKPRI ) & 0xff ; max_irr = apic_find_highest_irr ( apic ) ; if ( max_irr < 0 ) max_irr = 0 ; max_isr = apic_find_highest_isr ( apic ) ; if ( max_isr < 0 ) max_isr = 0 ; data = ( tpr & 0xff ) | ( ( max_isr & 0xf0 ) << 8 ) | ( max_irr << 24 ) ; <S2SV_StartBug> vapic = kmap_atomic ( vcpu -> arch . apic -> vapic_page ) ; <S2SV_EndBug> * ( u32 * ) ( vapic + offset_in_page ( vcpu -> arch . apic -> vapic_addr ) ) = data ; kunmap_atomic ( vapic ) ; }
","<S2SV_ModStart> arch . apic <S2SV_ModEnd> ; apic_sync_pv_eoi_to_guest ( <S2SV_ModStart> 24 ) ; kvm_write_guest_cached ( vcpu -> kvm , & <S2SV_ModEnd> vcpu -> arch <S2SV_ModStart> . apic -> vapic_cache , & data , sizeof ( u32 ) <S2SV_ModEnd> ) ; }
"
715,"CWE-908 static void cmd_anal_esil ( RCore * core , const char * input ) { RAnalEsil * esil = core -> anal -> esil ; ut64 addr = core -> offset ; ut64 adr ; char * n , * n1 ; int off ; int stacksize = r_config_get_i ( core -> config , ""esil.stack.depth"" ) ; int iotrap = r_config_get_i ( core -> config , ""esil.iotrap"" ) ; int romem = r_config_get_i ( core -> config , ""esil.romem"" ) ; int stats = r_config_get_i ( core -> config , ""esil.stats"" ) ; int noNULL = r_config_get_i ( core -> config , ""esil.noNULL"" ) ; ut64 until_addr = UT64_MAX ; unsigned int addrsize = r_config_get_i ( core -> config , ""esil.addr.size"" ) ; const char * until_expr = NULL ; RAnalOp * op ; switch ( input [ 0 ] ) { case 'p' : switch ( input [ 1 ] ) { case 'c' : if ( input [ 2 ] == '<S2SV_blank>' ) { r_core_cmdf ( core , ""ar<S2SV_blank>PC=%s"" , input + 3 ) ; r_core_cmd0 ( core , "".ar*"" ) ; } else { eprintf ( ""Missing<S2SV_blank>argument\\n"" ) ; } break ; case 0 : r_anal_pin_list ( core -> anal ) ; break ; case '-' : if ( input [ 2 ] ) addr = r_num_math ( core -> num , input + 2 ) ; r_anal_pin_unset ( core -> anal , addr ) ; break ; case '<S2SV_blank>' : r_anal_pin ( core -> anal , addr , input + 2 ) ; break ; default : r_core_cmd_help ( core , help_msg_aep ) ; break ; } break ; case 'r' : cmd_anal_reg ( core , input + 1 ) ; break ; case '*' : if ( core -> anal -> esil ) { r_cons_printf ( ""trap:<S2SV_blank>%d\\n"" , core -> anal -> esil -> trap ) ; r_cons_printf ( ""trap-code:<S2SV_blank>%d\\n"" , core -> anal -> esil -> trap_code ) ; } else { eprintf ( ""esil<S2SV_blank>vm<S2SV_blank>not<S2SV_blank>initialized.<S2SV_blank>run<S2SV_blank>`aei`\\n"" ) ; } break ; case '<S2SV_blank>' : if ( ! esil ) { if ( ! ( core -> anal -> esil = esil = r_anal_esil_new ( stacksize , iotrap , addrsize ) ) ) return ; } r_anal_esil_setup ( esil , core -> anal , romem , stats , noNULL ) ; r_anal_esil_set_pc ( esil , core -> offset ) ; r_anal_esil_parse ( esil , input + 1 ) ; r_anal_esil_dumpstack ( esil ) ; r_anal_esil_stack_free ( esil ) ; break ; case 's' : switch ( input [ 1 ] ) { case '?' : eprintf ( ""See:<S2SV_blank>ae?~aes\\n"" ) ; break ; case 'l' : { ut64 pc = r_debug_reg_get ( core -> dbg , ""PC"" ) ; RAnalOp * op = r_core_anal_op ( core , pc ) ; if ( ! op ) { break ; } r_core_esil_step ( core , UT64_MAX , NULL , NULL ) ; r_debug_reg_set ( core -> dbg , ""PC"" , pc + op -> size ) ; r_anal_esil_set_pc ( esil , pc + op -> size ) ; r_core_cmd0 ( core , "".ar*"" ) ; } break ; case 'b' : if ( ! r_core_esil_step_back ( core ) ) { eprintf ( ""cannnot<S2SV_blank>step<S2SV_blank>back\\n"" ) ; } r_core_cmd0 ( core , "".ar*"" ) ; break ; case 'u' : if ( input [ 2 ] == 'e' ) { until_expr = input + 3 ; } else { until_addr = r_num_math ( core -> num , input + 2 ) ; } r_core_esil_step ( core , until_addr , until_expr , NULL ) ; r_core_cmd0 ( core , "".ar*"" ) ; break ; case 'o' : op = r_core_anal_op ( core , r_reg_getv ( core -> anal -> reg , r_reg_get_name ( core -> anal -> reg , R_REG_NAME_PC ) ) ) ; if ( op && op -> type == R_ANAL_OP_TYPE_CALL ) { until_addr = op -> addr + op -> size ; } r_core_esil_step ( core , until_addr , until_expr , NULL ) ; r_anal_op_free ( op ) ; r_core_cmd0 ( core , "".ar*"" ) ; break ; case 'p' : n = strchr ( input , '<S2SV_blank>' ) ; n1 = n ? strchr ( n + 1 , '<S2SV_blank>' ) : NULL ; if ( ( ! n || ! n1 ) || ( ! ( n + 1 ) || ! ( n1 + 1 ) ) ) { eprintf ( ""aesp<S2SV_blank>[offset]<S2SV_blank>[num]\\n"" ) ; break ; } adr = r_num_math ( core -> num , n + 1 ) ; off = r_num_math ( core -> num , n1 + 1 ) ; cmd_aespc ( core , adr , off ) ; break ; case '<S2SV_blank>' : n = strchr ( input , '<S2SV_blank>' ) ; if ( ! ( n + 1 ) ) { r_core_esil_step ( core , until_addr , until_expr , NULL ) ; break ; } off = r_num_math ( core -> num , n + 1 ) ; cmd_aespc ( core , - 1 , off ) ; break ; default : r_core_esil_step ( core , until_addr , until_expr , NULL ) ; r_core_cmd0 ( core , "".ar*"" ) ; break ; } break ; case 'c' : if ( input [ 1 ] == '?' ) { r_core_cmd_help ( core , help_msg_aec ) ; } else if ( input [ 1 ] == 's' ) { const char * pc = r_reg_get_name ( core -> anal -> reg , R_REG_NAME_PC ) ; ut64 newaddr ; int ret ; for ( ; ; ) { op = r_core_anal_op ( core , addr ) ; if ( ! op ) { break ; } if ( op -> type == R_ANAL_OP_TYPE_SWI ) { eprintf ( ""syscall<S2SV_blank>at<S2SV_blank>0x%08"" PFMT64x ""\\n"" , addr ) ; break ; } if ( op -> type == R_ANAL_OP_TYPE_TRAP ) { eprintf ( ""trap<S2SV_blank>at<S2SV_blank>0x%08"" PFMT64x ""\\n"" , addr ) ; break ; } ret = r_core_esil_step ( core , UT64_MAX , NULL , NULL ) ; r_anal_op_free ( op ) ; op = NULL ; if ( core -> anal -> esil -> trap || core -> anal -> esil -> trap_code ) { break ; } if ( ! ret ) break ; r_core_cmd0 ( core , "".ar*"" ) ; newaddr = r_num_get ( core -> num , pc ) ; if ( addr == newaddr ) { addr ++ ; break ; } else { addr = newaddr ; } } if ( op ) { r_anal_op_free ( op ) ; } } else { if ( input [ 1 ] == 'u' && input [ 2 ] == 'e' ) until_expr = input + 3 ; else if ( input [ 1 ] == 'u' ) until_addr = r_num_math ( core -> num , input + 2 ) ; else until_expr = ""0"" ; r_core_esil_step ( core , until_addr , until_expr , NULL ) ; r_core_cmd0 ( core , "".ar*"" ) ; } break ; case 'i' : switch ( input [ 1 ] ) { case 's' : case 'm' : cmd_esil_mem ( core , input + 2 ) ; break ; case 'p' : r_core_cmd0 ( core , ""ar<S2SV_blank>PC=$$"" ) ; break ; case '?' : cmd_esil_mem ( core , ""?"" ) ; break ; case '-' : if ( esil ) { sdb_reset ( esil -> stats ) ; } r_anal_esil_free ( esil ) ; core -> anal -> esil = NULL ; break ; case 0 : r_anal_esil_free ( esil ) ; { const char * pc = r_reg_get_name ( core -> anal -> reg , R_REG_NAME_PC ) ; if ( r_reg_getv ( core -> anal -> reg , pc ) == 0LL ) { r_core_cmd0 ( core , ""ar<S2SV_blank>PC=$$"" ) ; } } if ( ! ( esil = core -> anal -> esil = r_anal_esil_new ( stacksize , iotrap , addrsize ) ) ) { return ; } r_anal_esil_setup ( esil , core -> anal , romem , stats , noNULL ) ; esil -> verbose = ( int ) r_config_get_i ( core -> config , ""esil.verbose"" ) ; { const char * s = r_config_get ( core -> config , ""cmd.esil.intr"" ) ; if ( s ) { char * my = strdup ( s ) ; if ( my ) { r_config_set ( core -> config , ""cmd.esil.intr"" , my ) ; free ( my ) ; } } } break ; } break ; case 'k' : switch ( input [ 1 ] ) { case '\\0' : input = ""123*"" ; case '<S2SV_blank>' : if ( esil && esil -> stats ) { char * out = sdb_querys ( esil -> stats , NULL , 0 , input + 2 ) ; if ( out ) { r_cons_println ( out ) ; free ( out ) ; } } else { eprintf ( ""esil.stats<S2SV_blank>is<S2SV_blank>empty.<S2SV_blank>Run<S2SV_blank>\'aei\'\\n"" ) ; } break ; case '-' : if ( esil ) { sdb_reset ( esil -> stats ) ; } break ; } break ; case 'f' : { RListIter * iter ; RAnalBlock * bb ; RAnalFunction * fcn = r_anal_get_fcn_in ( core -> anal , core -> offset , R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM ) ; if ( fcn ) { r_list_foreach ( fcn -> bbs , iter , bb ) { ut64 pc = bb -> addr ; ut64 end = bb -> addr + bb -> size ; RAnalOp op ; ut8 * buf ; int ret , bbs = end - pc ; if ( bbs < 1 || bbs > 0xfffff ) { eprintf ( ""Invalid<S2SV_blank>block<S2SV_blank>size\\n"" ) ; } buf = calloc ( 1 , bbs + 1 ) ; r_io_read_at ( core -> io , pc , buf , bbs ) ; int left ; while ( pc < end ) { left = R_MIN ( end - pc , 32 ) ; r_asm_set_pc ( core -> assembler , pc ) ; ret = r_anal_op ( core -> anal , & op , addr , buf , left , R_ANAL_OP_MASK_ALL ) ; if ( ret ) { r_reg_set_value_by_role ( core -> anal -> reg , R_REG_NAME_PC , pc ) ; r_anal_esil_parse ( esil , R_STRBUF_SAFEGET ( & op . esil ) ) ; r_anal_esil_dumpstack ( esil ) ; r_anal_esil_stack_free ( esil ) ; pc += op . size ; } else { pc += 4 ; } } } } else { eprintf ( ""Cannot<S2SV_blank>find<S2SV_blank>function<S2SV_blank>at<S2SV_blank>0x%08"" PFMT64x ""\\n"" , core -> offset ) ; } } break ; case 't' : switch ( input [ 1 ] ) { case 'r' : { RAnalEsil * esil = r_anal_esil_new ( stacksize , iotrap , addrsize ) ; <S2SV_StartBug> if ( ! esil ) <S2SV_EndBug> return ; r_anal_esil_to_reil_setup ( esil , core -> anal , romem , stats ) ; r_anal_esil_set_pc ( esil , core -> offset ) ; r_anal_esil_parse ( esil , input + 2 ) ; r_anal_esil_dumpstack ( esil ) ; r_anal_esil_free ( esil ) ; break ; } case 's' : switch ( input [ 2 ] ) { case 0 : r_anal_esil_session_list ( esil ) ; break ; case '+' : r_anal_esil_session_add ( esil ) ; break ; default : r_core_cmd_help ( core , help_msg_aets ) ; break ; } break ; default : eprintf ( ""Unknown<S2SV_blank>command.<S2SV_blank>Use<S2SV_blank>`aetr`.\\n"" ) ; break ; } break ; case 'A' : if ( input [ 1 ] == '?' ) { r_core_cmd_help ( core , help_msg_aea ) ; } else if ( input [ 1 ] == 'r' ) { cmd_aea ( core , 1 + ( 1 << 1 ) , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; } else if ( input [ 1 ] == 'w' ) { cmd_aea ( core , 1 + ( 1 << 2 ) , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; } else if ( input [ 1 ] == 'n' ) { cmd_aea ( core , 1 + ( 1 << 3 ) , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; } else if ( input [ 1 ] == 'j' ) { cmd_aea ( core , 1 + ( 1 << 4 ) , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; } else if ( input [ 1 ] == '*' ) { cmd_aea ( core , 1 + ( 1 << 5 ) , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; } else if ( input [ 1 ] == 'f' ) { RAnalFunction * fcn = r_anal_get_fcn_in ( core -> anal , core -> offset , - 1 ) ; if ( fcn ) { cmd_aea ( core , 1 , fcn -> addr , r_anal_fcn_size ( fcn ) ) ; } } else { cmd_aea ( core , 1 , core -> offset , ( int ) r_num_math ( core -> num , input + 2 ) ) ; } break ; case 'a' : if ( input [ 1 ] == '?' ) { r_core_cmd_help ( core , help_msg_aea ) ; } else if ( input [ 1 ] == 'r' ) { cmd_aea ( core , 1 << 1 , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; } else if ( input [ 1 ] == 'w' ) { cmd_aea ( core , 1 << 2 , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; } else if ( input [ 1 ] == 'n' ) { cmd_aea ( core , 1 << 3 , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; } else if ( input [ 1 ] == 'j' ) { cmd_aea ( core , 1 << 4 , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; } else if ( input [ 1 ] == '*' ) { cmd_aea ( core , 1 << 5 , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; } else if ( input [ 1 ] == 'f' ) { RAnalFunction * fcn = r_anal_get_fcn_in ( core -> anal , core -> offset , - 1 ) ; if ( fcn ) { switch ( input [ 2 ] ) { case 'j' : cmd_aea ( core , 1 << 4 , fcn -> addr , r_anal_fcn_size ( fcn ) ) ; break ; default : cmd_aea ( core , 1 , fcn -> addr , r_anal_fcn_size ( fcn ) ) ; break ; } break ; } } else { const char * arg = input [ 1 ] ? input + 2 : """" ; ut64 len = r_num_math ( core -> num , arg ) ; cmd_aea ( core , 0 , core -> offset , len ) ; } break ; case 'x' : { char * hex ; int ret , bufsz ; input = r_str_trim_ro ( input + 1 ) ; hex = strdup ( input ) ; if ( ! hex ) { break ; } RAnalOp aop = R_EMPTY ; bufsz = r_hex_str2bin ( hex , ( ut8 * ) hex ) ; ret = r_anal_op ( core -> anal , & aop , core -> offset , ( const ut8 * ) hex , bufsz , R_ANAL_OP_MASK_ALL ) ; if ( ret > 0 ) { const char * str = R_STRBUF_SAFEGET ( & aop . esil ) ; char * str2 = r_str_newf ( ""<S2SV_blank>%s"" , str ) ; cmd_anal_esil ( core , str2 ) ; free ( str2 ) ; } r_anal_op_fini ( & aop ) ; break ; } case '?' : if ( input [ 1 ] == '?' ) { r_core_cmd_help ( core , help_detail_ae ) ; break ; } default : r_core_cmd_help ( core , help_msg_ae ) ; break ; } }
","<S2SV_ModStart> ! esil ) { return ; } <S2SV_ModEnd> r_anal_esil_to_reil_setup ( esil
"
716,"CWE-125 int parse_file ( FILE * input_file , char * directory , char * body_filename , char * body_pref , int flags ) { uint32 d ; uint16 key ; Attr * attr = NULL ; File * file = NULL ; int rtf_size = 0 , html_size = 0 ; MessageBody body ; memset ( & body , '\\0' , sizeof ( MessageBody ) ) ; g_flags = flags ; d = geti32 ( input_file ) ; if ( d != TNEF_SIGNATURE ) { fprintf ( stdout , ""Seems<S2SV_blank>not<S2SV_blank>to<S2SV_blank>be<S2SV_blank>a<S2SV_blank>TNEF<S2SV_blank>file\\n"" ) ; return 1 ; } key = geti16 ( input_file ) ; debug_print ( ""TNEF<S2SV_blank>Key:<S2SV_blank>%hx\\n"" , key ) ; while ( data_left ( input_file ) ) { attr = read_object ( input_file ) ; if ( attr == NULL ) break ; if ( attr -> name == attATTACHRENDDATA ) { if ( file ) { file_write ( file , directory ) ; file_free ( file ) ; } else { file = CHECKED_XCALLOC ( File , 1 ) ; } } switch ( attr -> lvl_type ) { case LVL_MESSAGE : if ( attr -> name == attBODY ) { body . text_body = get_text_data ( attr ) ; } else if ( attr -> name == attMAPIPROPS ) { MAPI_Attr * * mapi_attrs = mapi_attr_read ( attr -> len , attr -> buf ) ; if ( mapi_attrs ) { int i ; for ( i = 0 ; mapi_attrs [ i ] ; i ++ ) { MAPI_Attr * a = mapi_attrs [ i ] ; <S2SV_StartBug> if ( a -> name == MAPI_BODY_HTML ) <S2SV_EndBug> { body . html_bodies = get_html_data ( a ) ; html_size = a -> num_values ; } <S2SV_StartBug> else if ( a -> name == MAPI_RTF_COMPRESSED ) <S2SV_EndBug> { body . rtf_bodies = get_rtf_data ( a ) ; rtf_size = a -> num_values ; } } mapi_attr_free_list ( mapi_attrs ) ; XFREE ( mapi_attrs ) ; } } break ; case LVL_ATTACHMENT : file_add_attr ( file , attr ) ; break ; default : fprintf ( stderr , ""Invalid<S2SV_blank>lvl<S2SV_blank>type<S2SV_blank>on<S2SV_blank>attribute:<S2SV_blank>%d\\n"" , attr -> lvl_type ) ; return 1 ; break ; } attr_free ( attr ) ; XFREE ( attr ) ; } if ( file ) { file_write ( file , directory ) ; file_free ( file ) ; XFREE ( file ) ; } if ( flags & SAVEBODY ) { int i = 0 ; int all_flag = 0 ; if ( strcmp ( body_pref , ""all"" ) == 0 ) { all_flag = 1 ; body_pref = ""rht"" ; } for ( ; i < 3 ; i ++ ) { File * * files = get_body_files ( body_filename , body_pref [ i ] , & body ) ; if ( files ) { int j = 0 ; for ( ; files [ j ] ; j ++ ) { file_write ( files [ j ] , directory ) ; file_free ( files [ j ] ) ; XFREE ( files [ j ] ) ; } XFREE ( files ) ; if ( ! all_flag ) break ; } } } if ( body . text_body ) { free_bodies ( body . text_body , 1 ) ; XFREE ( body . text_body ) ; } if ( rtf_size > 0 ) { free_bodies ( body . rtf_bodies , rtf_size ) ; XFREE ( body . rtf_bodies ) ; } if ( html_size > 0 ) { free_bodies ( body . html_bodies , html_size ) ; XFREE ( body . html_bodies ) ; } return 0 ; }
","<S2SV_ModStart> ( a -> type == szMAPI_BINARY && a -> <S2SV_ModStart> else if ( a -> type == szMAPI_BINARY &&
"
717,"CWE-264 static bool caller_is_in_ancestor ( pid_t pid , const char * contrl , const char * cg , char * * nextcg ) { <S2SV_StartBug> char fnam [ PROCLEN ] ; <S2SV_EndBug> FILE * f ; bool answer = false ; <S2SV_StartBug> char * line = NULL ; <S2SV_EndBug> size_t len = 0 ; int ret ; ret = snprintf ( fnam , PROCLEN , ""/proc/%d/cgroup"" , pid ) ; if ( ret < 0 || ret >= PROCLEN ) return false ; if ( ! ( f = fopen ( fnam , ""r"" ) ) ) return false ; while ( getline ( & line , & len , f ) != - 1 ) { char * c1 , * c2 , * linecmp ; if ( ! line [ 0 ] ) continue ; c1 = strchr ( line , ':' ) ; if ( ! c1 ) goto out ; c1 ++ ; c2 = strchr ( c1 , ':' ) ; if ( ! c2 ) <S2SV_StartBug> goto out ; <S2SV_EndBug> * c2 = '\\0' ; if ( strcmp ( c1 , contrl ) != 0 ) continue ; c2 ++ ; stripnewline ( c2 ) ; prune_init_slice ( c2 ) ; linecmp = * cg == '/' ? c2 : c2 + 1 ; if ( strncmp ( linecmp , cg , strlen ( linecmp ) ) != 0 ) { <S2SV_StartBug> if ( nextcg ) <S2SV_EndBug> * nextcg = get_next_cgroup_dir ( linecmp , cg ) ; <S2SV_StartBug> goto out ; <S2SV_EndBug> } answer = true ; <S2SV_StartBug> goto out ; <S2SV_EndBug> } out : fclose ( f ) ; free ( line ) ; return answer ; }
","<S2SV_ModStart> nextcg ) { <S2SV_ModEnd> bool answer = <S2SV_ModStart> ; char * c2 = get_pid_cgroup ( pid , contrl ) ; char * linecmp <S2SV_ModEnd> ; if ( <S2SV_ModStart> ! c2 ) return false <S2SV_ModEnd> ; prune_init_slice ( <S2SV_ModStart> ( nextcg ) { <S2SV_ModStart> cg ) ; } <S2SV_ModStart> = true ; out : free ( c2 <S2SV_ModEnd> ) ; return
"
718,"CWE-476 void migrate_page_copy ( struct page * newpage , struct page * page ) { int cpupid ; if ( PageHuge ( page ) || PageTransHuge ( page ) ) copy_huge_page ( newpage , page ) ; else copy_highpage ( newpage , page ) ; if ( PageError ( page ) ) SetPageError ( newpage ) ; if ( PageReferenced ( page ) ) SetPageReferenced ( newpage ) ; if ( PageUptodate ( page ) ) SetPageUptodate ( newpage ) ; if ( TestClearPageActive ( page ) ) { VM_BUG_ON_PAGE ( PageUnevictable ( page ) , page ) ; SetPageActive ( newpage ) ; } else if ( TestClearPageUnevictable ( page ) ) SetPageUnevictable ( newpage ) ; if ( PageChecked ( page ) ) SetPageChecked ( newpage ) ; if ( PageMappedToDisk ( page ) ) SetPageMappedToDisk ( newpage ) ; <S2SV_StartBug> if ( PageDirty ( page ) ) { <S2SV_EndBug> clear_page_dirty_for_io ( page ) ; if ( PageSwapBacked ( page ) ) SetPageDirty ( newpage ) ; <S2SV_StartBug> else <S2SV_EndBug> __set_page_dirty_nobuffers ( newpage ) ; } if ( page_is_young ( page ) ) set_page_young ( newpage ) ; if ( page_is_idle ( page ) ) set_page_idle ( newpage ) ; cpupid = page_cpupid_xchg_last ( page , - 1 ) ; page_cpupid_xchg_last ( newpage , cpupid ) ; ksm_migrate_page ( newpage , page ) ; if ( PageSwapCache ( page ) ) ClearPageSwapCache ( page ) ; ClearPagePrivate ( page ) ; set_page_private ( page , 0 ) ; if ( PageWriteback ( newpage ) ) end_page_writeback ( newpage ) ; }
","<S2SV_ModStart> page ) ) <S2SV_ModEnd> SetPageDirty ( newpage <S2SV_ModStart> newpage ) ; <S2SV_ModEnd> if ( page_is_young
"
719,"CWE-119 void vp9_rc_get_svc_params ( VP9_COMP * cpi ) { VP9_COMMON * const cm = & cpi -> common ; RATE_CONTROL * const rc = & cpi -> rc ; <S2SV_StartBug> int target = rc -> av_per_frame_bandwidth ; <S2SV_EndBug> if ( ( cm -> current_video_frame == 0 ) || <S2SV_StartBug> ( cm -> frame_flags & FRAMEFLAGS_KEY ) || <S2SV_EndBug> ( cpi -> oxcf . auto_key && ( rc -> frames_since_key % <S2SV_StartBug> cpi -> key_frame_frequency == 0 ) ) ) { <S2SV_EndBug> cm -> frame_type = KEY_FRAME ; rc -> source_alt_ref_active = 0 ; <S2SV_StartBug> if ( cpi -> pass == 0 && cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) { <S2SV_EndBug> target = calc_iframe_target_size_one_pass_cbr ( cpi ) ; } } else { cm -> frame_type = INTER_FRAME ; if ( cpi -> pass == 0 && cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) { target = calc_pframe_target_size_one_pass_cbr ( cpi ) ; } } vp9_rc_set_frame_target ( cpi , target ) ; rc -> frames_till_gf_update_due = INT_MAX ; rc -> baseline_gf_interval = INT_MAX ; }
","<S2SV_ModStart> = rc -> avg_frame_bandwidth ; const int layer = LAYER_IDS_TO_IDX ( cpi -> svc . spatial_layer_id , cpi -> svc . temporal_layer_id , cpi -> svc . number_temporal_layers ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) || ( cpi <S2SV_ModEnd> -> frame_flags & <S2SV_ModStart> % cpi -> oxcf . key_freq <S2SV_ModEnd> == 0 ) <S2SV_ModStart> ; if ( is_two_pass_svc ( cpi ) ) { cpi -> svc . layer_context [ layer ] . is_key_frame = 1 ; cpi -> ref_frame_flags &= ( ~ VP9_LAST_FLAG & ~ VP9_GOLD_FLAG & ~ VP9_ALT_FLAG ) ; } else if ( is_one_pass_cbr_svc ( cpi ) ) { cpi -> svc . layer_context [ layer ] . is_key_frame = 1 ; reset_temporal_layer_to_zero ( cpi ) ; cpi -> ref_frame_flags &= ( ~ VP9_LAST_FLAG & ~ VP9_GOLD_FLAG & ~ VP9_ALT_FLAG ) ; target = calc_iframe_target_size_one_pass_cbr ( cpi ) ; } } else { cm -> frame_type = INTER_FRAME ; if ( is_two_pass_svc ( cpi ) ) { LAYER_CONTEXT * lc = & cpi -> svc . layer_context [ layer ] ; if ( cpi -> svc . spatial_layer_id == 0 ) { lc -> is_key_frame = 0 ; } else { lc -> is_key_frame = cpi -> svc . layer_context [ cpi -> svc . temporal_layer_id ] . is_key_frame ; if ( lc -> is_key_frame ) cpi -> ref_frame_flags &= ( ~ VP9_LAST_FLAG ) ; } cpi -> ref_frame_flags &= ( ~ VP9_ALT_FLAG ) ; } else if ( is_one_pass_cbr_svc ( cpi ) ) { LAYER_CONTEXT * lc = & cpi -> svc . layer_context [ layer ] ; if ( cpi -> svc . spatial_layer_id == 0 ) { lc -> is_key_frame = 0 ; } else { lc -> is_key_frame = cpi -> svc . layer_context [ cpi -> svc . temporal_layer_id ] . is_key_frame ; } target = calc_pframe_target_size_one_pass_cbr ( cpi ) ; } } if ( <S2SV_ModEnd> cpi -> oxcf <S2SV_ModStart> -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) vp9_cyclic_refresh_update_parameters ( cpi ) ; <S2SV_ModEnd> vp9_rc_set_frame_target ( cpi
"
720,"CWE-000 int ssl3_read_n ( SSL * s , int n , int max , int extend ) { int i , len , left ; long align = 0 ; unsigned char * pkt ; SSL3_BUFFER * rb ; if ( n <= 0 ) return n ; rb = & ( s -> s3 -> rbuf ) ; if ( rb -> buf == NULL ) if ( ! ssl3_setup_read_buffer ( s ) ) return - 1 ; left = rb -> left ; # if defined ( SSL3_ALIGN_PAYLOAD ) && SSL3_ALIGN_PAYLOAD != 0 align = ( long ) rb -> buf + SSL3_RT_HEADER_LENGTH ; align = ( - align ) & ( SSL3_ALIGN_PAYLOAD - 1 ) ; # endif if ( ! extend ) { if ( left == 0 ) rb -> offset = align ; else if ( align != 0 && left >= SSL3_RT_HEADER_LENGTH ) { pkt = rb -> buf + rb -> offset ; if ( pkt [ 0 ] == SSL3_RT_APPLICATION_DATA && ( pkt [ 3 ] << 8 | pkt [ 4 ] ) >= 128 ) { memmove ( rb -> buf + align , pkt , left ) ; rb -> offset = align ; } } s -> packet = rb -> buf + rb -> offset ; s -> packet_length = 0 ; } if ( SSL_IS_DTLS ( s ) ) { <S2SV_StartBug> if ( left > 0 && n > left ) <S2SV_EndBug> n = left ; } if ( left >= n ) { s -> packet_length += n ; rb -> left = left - n ; rb -> offset += n ; return ( n ) ; } len = s -> packet_length ; pkt = rb -> buf + align ; if ( s -> packet != pkt ) { memmove ( pkt , s -> packet , len + left ) ; s -> packet = pkt ; rb -> offset = len + align ; } if ( n > ( int ) ( rb -> len - rb -> offset ) ) { SSLerr ( SSL_F_SSL3_READ_N , ERR_R_INTERNAL_ERROR ) ; return - 1 ; } if ( ! s -> read_ahead ) max = n ; else { if ( max < n ) max = n ; if ( max > ( int ) ( rb -> len - rb -> offset ) ) max = rb -> len - rb -> offset ; } while ( left < n ) { clear_sys_error ( ) ; if ( s -> rbio != NULL ) { s -> rwstate = SSL_READING ; i = BIO_read ( s -> rbio , pkt + len + left , max - left ) ; } else { SSLerr ( SSL_F_SSL3_READ_N , SSL_R_READ_BIO_NOT_SET ) ; i = - 1 ; } if ( i <= 0 ) { rb -> left = left ; if ( s -> mode & SSL_MODE_RELEASE_BUFFERS && ! SSL_IS_DTLS ( s ) ) if ( len + left == 0 ) ssl3_release_read_buffer ( s ) ; return ( i ) ; } left += i ; if ( SSL_IS_DTLS ( s ) ) { if ( n > left ) n = left ; } } rb -> offset += n ; rb -> left = left - n ; s -> packet_length += n ; s -> rwstate = SSL_NOTHING ; return ( n ) ; }
","<S2SV_ModStart> if ( left == 0 && extend ) return 0 ; if ( left
"
721,"CWE-119 static int newkeys_from_blob ( struct sshbuf * m , struct ssh * ssh , int mode ) { struct sshbuf * b = NULL ; struct sshcomp * comp ; struct sshenc * enc ; struct sshmac * mac ; struct newkeys * newkey = NULL ; size_t keylen , ivlen , maclen ; int r ; if ( ( newkey = calloc ( 1 , sizeof ( * newkey ) ) ) == NULL ) { r = SSH_ERR_ALLOC_FAIL ; goto out ; } if ( ( r = sshbuf_froms ( m , & b ) ) != 0 ) goto out ; # ifdef DEBUG_PK sshbuf_dump ( b , stderr ) ; # endif enc = & newkey -> enc ; mac = & newkey -> mac ; comp = & newkey -> comp ; if ( ( r = sshbuf_get_cstring ( b , & enc -> name , NULL ) ) != 0 || ( r = sshbuf_get ( b , & enc -> cipher , sizeof ( enc -> cipher ) ) ) != 0 || ( r = sshbuf_get_u32 ( b , ( u_int * ) & enc -> enabled ) ) != 0 || ( r = sshbuf_get_u32 ( b , & enc -> block_size ) ) != 0 || ( r = sshbuf_get_string ( b , & enc -> key , & keylen ) ) != 0 || ( r = sshbuf_get_string ( b , & enc -> iv , & ivlen ) ) != 0 ) goto out ; if ( cipher_authlen ( enc -> cipher ) == 0 ) { if ( ( r = sshbuf_get_cstring ( b , & mac -> name , NULL ) ) != 0 ) goto out ; if ( ( r = mac_setup ( mac , mac -> name ) ) != 0 ) goto out ; if ( ( r = sshbuf_get_u32 ( b , ( u_int * ) & mac -> enabled ) ) != 0 || ( r = sshbuf_get_string ( b , & mac -> key , & maclen ) ) != 0 ) goto out ; if ( maclen > mac -> key_len ) { r = SSH_ERR_INVALID_FORMAT ; goto out ; } mac -> key_len = maclen ; } <S2SV_StartBug> if ( ( r = sshbuf_get_u32 ( b , & comp -> type ) ) != 0 || <S2SV_EndBug> ( r = sshbuf_get_u32 ( b , ( u_int * ) & comp -> enabled ) ) != 0 || ( r = sshbuf_get_cstring ( b , & comp -> name , NULL ) ) != 0 ) goto out ; if ( enc -> name == NULL || cipher_by_name ( enc -> name ) != enc -> cipher ) { r = SSH_ERR_INVALID_FORMAT ; goto out ; } if ( sshbuf_len ( b ) != 0 ) { r = SSH_ERR_INVALID_FORMAT ; goto out ; } enc -> key_len = keylen ; enc -> iv_len = ivlen ; ssh -> kex -> newkeys [ mode ] = newkey ; newkey = NULL ; r = 0 ; out : free ( newkey ) ; sshbuf_free ( b ) ; return r ; }
","<S2SV_ModStart> comp -> type <S2SV_ModEnd> ) ) !=
"
722,"CWE-284 static int netlink_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct netlink_sock * nlk = nlk_sk ( sk ) ; struct sockaddr_nl * addr = msg -> msg_name ; u32 dst_pid ; u32 dst_group ; struct sk_buff * skb ; int err ; struct scm_cookie scm ; if ( msg -> msg_flags & MSG_OOB ) return - EOPNOTSUPP ; if ( NULL == siocb -> scm ) siocb -> scm = & scm ; err = scm_send ( sock , msg , siocb -> scm , true ) ; if ( err < 0 ) return err ; if ( msg -> msg_namelen ) { err = - EINVAL ; if ( addr -> nl_family != AF_NETLINK ) goto out ; dst_pid = addr -> nl_pid ; dst_group = ffs ( addr -> nl_groups ) ; err = - EPERM ; <S2SV_StartBug> if ( dst_group && ! netlink_capable ( sock , NL_NONROOT_SEND ) ) <S2SV_EndBug> goto out ; } else { dst_pid = nlk -> dst_pid ; dst_group = nlk -> dst_group ; } if ( ! nlk -> pid ) { err = netlink_autobind ( sock ) ; if ( err ) goto out ; } err = - EMSGSIZE ; if ( len > sk -> sk_sndbuf - 32 ) goto out ; err = - ENOBUFS ; skb = alloc_skb ( len , GFP_KERNEL ) ; if ( skb == NULL ) goto out ; NETLINK_CB ( skb ) . pid = nlk -> pid ; NETLINK_CB ( skb ) . dst_group = dst_group ; memcpy ( NETLINK_CREDS ( skb ) , & siocb -> scm -> creds , sizeof ( struct ucred ) ) ; err = - EFAULT ; if ( memcpy_fromiovec ( skb_put ( skb , len ) , msg -> msg_iov , len ) ) { kfree_skb ( skb ) ; goto out ; } err = security_netlink_send ( sk , skb ) ; if ( err ) { kfree_skb ( skb ) ; goto out ; } if ( dst_group ) { atomic_inc ( & skb -> users ) ; netlink_broadcast ( sk , skb , dst_pid , dst_group , GFP_KERNEL ) ; } err = netlink_unicast ( sk , skb , dst_pid , msg -> msg_flags & MSG_DONTWAIT ) ; out : scm_destroy ( siocb -> scm ) ; return err ; }
","<S2SV_ModStart> ; if ( ( dst_group || dst_pid ) <S2SV_ModEnd> && ! netlink_capable
"
723,"CWE-287 int oidc_oauth_check_userid ( request_rec * r , oidc_cfg * c ) { if ( ! ap_is_initial_req ( r ) ) { if ( r -> main != NULL ) r -> user = r -> main -> user ; else if ( r -> prev != NULL ) r -> user = r -> prev -> user ; if ( r -> user != NULL ) { oidc_debug ( r , ""recycling<S2SV_blank>user<S2SV_blank>\'%s\'<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>request<S2SV_blank>for<S2SV_blank>sub-request"" , r -> user ) ; return OK ; } } else if ( ( c -> redirect_uri != NULL ) && ( oidc_util_request_matches_url ( r , c -> redirect_uri ) ) ) { if ( oidc_util_request_has_parameter ( r , ""jwks"" ) ) { return oidc_handle_jwks ( r , c ) ; } } const char * access_token = NULL ; if ( oidc_oauth_get_bearer_token ( r , & access_token ) == FALSE ) return oidc_oauth_return_www_authenticate ( r , ""invalid_request"" , ""No<S2SV_blank>bearer<S2SV_blank>token<S2SV_blank>found<S2SV_blank>in<S2SV_blank>the<S2SV_blank>request"" ) ; json_t * token = NULL ; char * s_token = NULL ; if ( c -> oauth . introspection_endpoint_url != NULL ) { if ( oidc_oauth_resolve_access_token ( r , c , access_token , & token , & s_token ) == FALSE ) return oidc_oauth_return_www_authenticate ( r , ""invalid_token"" , ""Reference<S2SV_blank>token<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>introspected"" ) ; } else { if ( oidc_oauth_validate_jwt_access_token ( r , c , access_token , & token , & s_token ) == FALSE ) return oidc_oauth_return_www_authenticate ( r , ""invalid_token"" , ""JWT<S2SV_blank>token<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>validated"" ) ; } if ( token == NULL ) { oidc_error ( r , ""could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>claims<S2SV_blank>(token<S2SV_blank>==<S2SV_blank>NULL)"" ) ; return oidc_oauth_return_www_authenticate ( r , ""invalid_token"" , ""No<S2SV_blank>claims<S2SV_blank>could<S2SV_blank>be<S2SV_blank>parsed<S2SV_blank>from<S2SV_blank>the<S2SV_blank>token"" ) ; } oidc_request_state_set ( r , OIDC_CLAIMS_SESSION_KEY , ( const char * ) s_token ) ; if ( oidc_oauth_set_remote_user ( r , c , token ) == FALSE ) { oidc_error ( r , ""remote<S2SV_blank>user<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>set,<S2SV_blank>aborting<S2SV_blank>with<S2SV_blank>HTTP_UNAUTHORIZED"" ) ; return oidc_oauth_return_www_authenticate ( r , ""invalid_token"" , ""Could<S2SV_blank>not<S2SV_blank>set<S2SV_blank>remote<S2SV_blank>user"" ) ; } <S2SV_StartBug> char * authn_header = oidc_cfg_dir_authn_header ( r ) ; <S2SV_EndBug> int pass_headers = oidc_cfg_dir_pass_info_in_headers ( r ) ; int pass_envvars = oidc_cfg_dir_pass_info_in_envvars ( r ) ; if ( ( r -> user != NULL ) && ( authn_header != NULL ) ) { oidc_debug ( r , ""setting<S2SV_blank>authn<S2SV_blank>header<S2SV_blank>(%s)<S2SV_blank>to:<S2SV_blank>%s"" , authn_header , r -> user ) ; apr_table_set ( r -> headers_in , authn_header , r -> user ) ; } oidc_util_set_app_infos ( r , token , c -> claim_prefix , c -> claim_delimiter , pass_headers , pass_envvars ) ; if ( access_token != NULL ) { oidc_util_set_app_info ( r , ""access_token"" , access_token , OIDC_DEFAULT_HEADER_PREFIX , pass_headers , pass_envvars ) ; } json_decref ( token ) ; return OK ; }
","<S2SV_ModStart> ) ; } oidc_scrub_headers ( r ) ;
"
724,"CWE-119 static int sd_e_h ( GWindow gw , GEvent * event ) { struct sd_data * sd = GDrawGetUserData ( gw ) ; if ( sd == NULL ) return ( true ) ; if ( event -> type == et_close ) { SD_DoCancel ( sd ) ; <S2SV_StartBug> } else if ( event -> type == et_char ) { <S2SV_EndBug> if ( event -> u . chr . keysym == GK_F1 || event -> u . chr . keysym == GK_Help ) { help ( ""scripting.html"" ) ; return ( true ) ; } return ( false ) ; } else if ( event -> type == et_map ) GDrawRaise ( gw ) ; else if ( event -> type == et_resize ) GDrawRequestExpose ( gw , NULL , false ) ; return ( true ) ; }
","<S2SV_ModStart> -> type == et_controlevent && event -> u . control . subtype == et_textchanged ) { sd -> fv -> script_unsaved = ! GTextFieldIsEmpty ( GWidgetGetControl ( sd -> gw , CID_Script ) ) ; } else if ( event -> type == et_controlevent && event -> u . control . subtype == et_save ) { sd -> fv -> script_unsaved = false ; } else if ( event -> type ==
"
725,"CWE-787 char * gf_text_get_utf8_line ( char * szLine , u32 lineSize , FILE * txt_in , s32 unicode_type ) { u32 i , j , len ; char * sOK ; char szLineConv [ 1024 ] ; unsigned short * sptr ; memset ( szLine , 0 , sizeof ( char ) * lineSize ) ; sOK = fgets ( szLine , lineSize , txt_in ) ; if ( ! sOK ) return NULL ; if ( unicode_type <= 1 ) { j = 0 ; len = ( u32 ) strlen ( szLine ) ; <S2SV_StartBug> for ( i = 0 ; i < len ; i ++ ) { <S2SV_EndBug> if ( ! unicode_type && ( szLine [ i ] & 0x80 ) ) { if ( ( szLine [ i + 1 ] & 0xc0 ) != 0x80 ) { <S2SV_StartBug> szLineConv [ j ] = 0xc0 | ( ( szLine [ i ] >> 6 ) & 0x3 ) ; <S2SV_EndBug> j ++ ; szLine [ i ] &= 0xbf ; } <S2SV_StartBug> else if ( ( szLine [ i ] & 0xe0 ) == 0xc0 ) { <S2SV_EndBug> <S2SV_StartBug> szLineConv [ j ] = szLine [ i ] ; <S2SV_EndBug> i ++ ; j ++ ; } else if ( ( szLine [ i ] & 0xf0 ) == 0xe0 ) { <S2SV_StartBug> szLineConv [ j ] = szLine [ i ] ; <S2SV_EndBug> i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else if ( ( szLine [ i ] & 0xf8 ) == 0xf0 ) { <S2SV_StartBug> szLineConv [ j ] = szLine [ i ] ; <S2SV_EndBug> i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else { i += 1 ; continue ; } } <S2SV_StartBug> szLineConv [ j ] = szLine [ i ] ; <S2SV_EndBug> j ++ ; } szLineConv [ j ] = 0 ; strcpy ( szLine , szLineConv ) ; return sOK ; } # ifdef GPAC_BIG_ENDIAN if ( unicode_type == 3 ) { # else if ( unicode_type == 2 ) { # endif i = 0 ; while ( 1 ) { char c ; if ( ! szLine [ i ] && ! szLine [ i + 1 ] ) break ; c = szLine [ i + 1 ] ; szLine [ i + 1 ] = szLine [ i ] ; szLine [ i ] = c ; i += 2 ; } } sptr = ( u16 * ) szLine ; i = ( u32 ) gf_utf8_wcstombs ( szLineConv , 1024 , ( const unsigned short * * ) & sptr ) ; if ( i >= ( u32 ) ARRAY_LENGTH ( szLineConv ) ) return NULL ; szLineConv [ i ] = 0 ; strcpy ( szLine , szLineConv ) ; if ( unicode_type == 3 ) fgetc ( txt_in ) ; return sOK ; }
","<S2SV_ModStart> i < len && j < sizeof ( szLineConv ) - 1 ; i ++ , j <S2SV_ModEnd> ++ ) { <S2SV_ModStart> 0x80 ) { if ( j + 1 < sizeof ( szLineConv ) - 1 ) { <S2SV_ModStart> ; } else break ; } else <S2SV_ModStart> 0xc0 ) { if ( j + 1 < sizeof ( szLineConv ) - 1 && i + 1 < len ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else { break ; } <S2SV_ModEnd> } else if <S2SV_ModStart> 0xe0 ) { if ( j + 2 < sizeof ( szLineConv ) - 1 && i + 2 < len ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else { break ; } <S2SV_ModEnd> } else if <S2SV_ModStart> 0xf0 ) { if ( j + 3 < sizeof ( szLineConv ) - 1 && i + 3 < len ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else { break ; } <S2SV_ModEnd> } else { <S2SV_ModStart> ; } } if ( j < sizeof ( szLineConv ) - 1 && i < len ) szLineConv [ j ] = szLine [ i ] ; } if ( j >= sizeof ( szLineConv ) ) szLineConv [ sizeof ( szLineConv ) - 1 ] = 0 ; else <S2SV_ModEnd> szLineConv [ j
"
726,"CWE-20 int main ( void ) { int fd , len , sock_opt ; int error ; struct cn_msg * message ; struct pollfd pfd ; struct nlmsghdr * incoming_msg ; struct cn_msg * incoming_cn_msg ; struct hv_kvp_msg * hv_msg ; char * p ; char * key_value ; char * key_name ; daemon ( 1 , 0 ) ; openlog ( ""KVP"" , 0 , LOG_USER ) ; syslog ( LOG_INFO , ""KVP<S2SV_blank>starting;<S2SV_blank>pid<S2SV_blank>is:%d"" , getpid ( ) ) ; kvp_get_os_info ( ) ; if ( kvp_file_init ( ) ) { syslog ( LOG_ERR , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>the<S2SV_blank>pools"" ) ; exit ( - 1 ) ; } fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ) ; if ( fd < 0 ) { syslog ( LOG_ERR , ""netlink<S2SV_blank>socket<S2SV_blank>creation<S2SV_blank>failed;<S2SV_blank>error:%d"" , fd ) ; exit ( - 1 ) ; } addr . nl_family = AF_NETLINK ; addr . nl_pad = 0 ; addr . nl_pid = 0 ; addr . nl_groups = CN_KVP_IDX ; error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ) ; if ( error < 0 ) { syslog ( LOG_ERR , ""bind<S2SV_blank>failed;<S2SV_blank>error:%d"" , error ) ; close ( fd ) ; exit ( - 1 ) ; } sock_opt = addr . nl_groups ; setsockopt ( fd , 270 , 1 , & sock_opt , sizeof ( sock_opt ) ) ; message = ( struct cn_msg * ) kvp_send_buffer ; message -> id . idx = CN_KVP_IDX ; message -> id . val = CN_KVP_VAL ; hv_msg = ( struct hv_kvp_msg * ) message -> data ; hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER ; message -> ack = 0 ; message -> len = sizeof ( struct hv_kvp_msg ) ; len = netlink_send ( fd , message ) ; if ( len < 0 ) { syslog ( LOG_ERR , ""netlink_send<S2SV_blank>failed;<S2SV_blank>error:%d"" , len ) ; close ( fd ) ; exit ( - 1 ) ; } pfd . fd = fd ; while ( 1 ) { <S2SV_StartBug> pfd . events = POLLIN ; <S2SV_EndBug> pfd . revents = 0 ; poll ( & pfd , 1 , - 1 ) ; <S2SV_StartBug> len = recv ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( len < 0 ) { <S2SV_EndBug> <S2SV_StartBug> syslog ( LOG_ERR , ""recv<S2SV_blank>failed;<S2SV_blank>error:%d"" , len ) ; <S2SV_EndBug> close ( fd ) ; return - 1 ; } incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer ; incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ) ; hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data ; switch ( hv_msg -> kvp_hdr . operation ) { case KVP_OP_REGISTER : p = ( char * ) hv_msg -> body . kvp_register . version ; lic_version = malloc ( strlen ( p ) + 1 ) ; if ( lic_version ) { strcpy ( lic_version , p ) ; syslog ( LOG_INFO , ""KVP<S2SV_blank>LIC<S2SV_blank>Version:<S2SV_blank>%s"" , lic_version ) ; } else { syslog ( LOG_ERR , ""malloc<S2SV_blank>failed"" ) ; } continue ; case KVP_OP_SET : if ( kvp_key_add_or_modify ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) ) strcpy ( hv_msg -> body . kvp_set . data . key , """" ) ; break ; case KVP_OP_GET : if ( kvp_get_value ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) ) strcpy ( hv_msg -> body . kvp_set . data . key , """" ) ; break ; case KVP_OP_DELETE : if ( kvp_key_delete ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) ) strcpy ( hv_msg -> body . kvp_delete . key , """" ) ; break ; default : break ; } if ( hv_msg -> kvp_hdr . operation != KVP_OP_ENUMERATE ) goto kvp_done ; if ( hv_msg -> kvp_hdr . pool != KVP_POOL_AUTO ) { kvp_pool_enumerate ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) ; goto kvp_done ; } hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data ; key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key ; key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value ; switch ( hv_msg -> body . kvp_enum_data . index ) { case FullyQualifiedDomainName : kvp_get_domain_name ( key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) ; strcpy ( key_name , ""FullyQualifiedDomainName"" ) ; break ; case IntegrationServicesVersion : strcpy ( key_name , ""IntegrationServicesVersion"" ) ; strcpy ( key_value , lic_version ) ; break ; case NetworkAddressIPv4 : kvp_get_ip_address ( AF_INET , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) ; strcpy ( key_name , ""NetworkAddressIPv4"" ) ; break ; case NetworkAddressIPv6 : kvp_get_ip_address ( AF_INET6 , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) ; strcpy ( key_name , ""NetworkAddressIPv6"" ) ; break ; case OSBuildNumber : strcpy ( key_value , os_build ) ; strcpy ( key_name , ""OSBuildNumber"" ) ; break ; case OSName : strcpy ( key_value , os_name ) ; strcpy ( key_name , ""OSName"" ) ; break ; case OSMajorVersion : strcpy ( key_value , os_major ) ; strcpy ( key_name , ""OSMajorVersion"" ) ; break ; case OSMinorVersion : strcpy ( key_value , os_minor ) ; strcpy ( key_name , ""OSMinorVersion"" ) ; break ; case OSVersion : strcpy ( key_value , os_build ) ; strcpy ( key_name , ""OSVersion"" ) ; break ; case ProcessorArchitecture : strcpy ( key_value , processor_arch ) ; strcpy ( key_name , ""ProcessorArchitecture"" ) ; break ; default : strcpy ( key_value , ""Unknown<S2SV_blank>Key"" ) ; strcpy ( key_name , """" ) ; break ; } kvp_done : incoming_cn_msg -> id . idx = CN_KVP_IDX ; incoming_cn_msg -> id . val = CN_KVP_VAL ; incoming_cn_msg -> ack = 0 ; incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ) ; len = netlink_send ( fd , incoming_cn_msg ) ; if ( len < 0 ) { syslog ( LOG_ERR , ""net_link<S2SV_blank>send<S2SV_blank>failed;<S2SV_blank>error:%d"" , len ) ; exit ( - 1 ) ; } } }
","<S2SV_ModStart> 1 ) { struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; socklen_t addr_l = sizeof ( addr ) ; <S2SV_ModStart> ; len = recvfrom <S2SV_ModEnd> ( fd , <S2SV_ModStart> ) , 0 , addr_p , & addr_l <S2SV_ModStart> len < 0 || addr . nl_pid <S2SV_ModStart> ( LOG_ERR , ""recvfrom<S2SV_blank>failed;<S2SV_blank>pid:%u<S2SV_blank>error:%d<S2SV_blank>%s"" , addr . nl_pid , errno , strerror ( errno ) <S2SV_ModEnd> ) ; close
"
727,"CWE-119 <S2SV_StartBug> static void send ( node_t * node , node_t * child , byte * fout ) { <S2SV_EndBug> if ( node -> parent ) { <S2SV_StartBug> send ( node -> parent , node , fout ) ; <S2SV_EndBug> } <S2SV_StartBug> if ( child ) { <S2SV_EndBug> if ( node -> right == child ) { add_bit ( 1 , fout ) ; } else { add_bit ( 0 , fout ) ; } } }
","<S2SV_ModStart> byte * fout , int maxoffset <S2SV_ModStart> node , fout , maxoffset <S2SV_ModStart> child ) { if ( bloc >= maxoffset ) { bloc = maxoffset + 1 ; return ; }
"
728,"CWE-125 mod_ty PyAST_FromNodeObject ( const node * n , PyCompilerFlags * flags , PyObject * filename , PyArena * arena ) { int i , j , k , num ; asdl_seq * stmts = NULL ; <S2SV_StartBug> stmt_ty s ; <S2SV_EndBug> node * ch ; struct compiling c ; <S2SV_StartBug> mod_ty res = NULL ; <S2SV_EndBug> c . c_arena = arena ; c . c_filename = filename ; c . c_normalize = NULL ; if ( TYPE ( n ) == encoding_decl ) n = CHILD ( n , 0 ) ; k = 0 ; switch ( TYPE ( n ) ) { case file_input : stmts = _Py_asdl_seq_new ( num_stmts ( n ) , arena ) ; if ( ! stmts ) goto out ; for ( i = 0 ; i < NCH ( n ) - 1 ; i ++ ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == NEWLINE ) continue ; REQ ( ch , stmt ) ; num = num_stmts ( ch ) ; if ( num == 1 ) { s = ast_for_stmt ( & c , ch ) ; if ( ! s ) goto out ; asdl_seq_SET ( stmts , k ++ , s ) ; } else { ch = CHILD ( ch , 0 ) ; REQ ( ch , simple_stmt ) ; for ( j = 0 ; j < num ; j ++ ) { s = ast_for_stmt ( & c , CHILD ( ch , j * 2 ) ) ; if ( ! s ) goto out ; asdl_seq_SET ( stmts , k ++ , s ) ; } } } <S2SV_StartBug> res = Module ( stmts , arena ) ; <S2SV_EndBug> break ; case eval_input : { expr_ty testlist_ast ; testlist_ast = ast_for_testlist ( & c , CHILD ( n , 0 ) ) ; if ( ! testlist_ast ) goto out ; res = Expression ( testlist_ast , arena ) ; break ; } case single_input : if ( TYPE ( CHILD ( n , 0 ) ) == NEWLINE ) { stmts = _Py_asdl_seq_new ( 1 , arena ) ; if ( ! stmts ) goto out ; asdl_seq_SET ( stmts , 0 , Pass ( n -> n_lineno , n -> n_col_offset , n -> n_end_lineno , n -> n_end_col_offset , arena ) ) ; if ( ! asdl_seq_GET ( stmts , 0 ) ) goto out ; res = Interactive ( stmts , arena ) ; } else { n = CHILD ( n , 0 ) ; num = num_stmts ( n ) ; stmts = _Py_asdl_seq_new ( num , arena ) ; if ( ! stmts ) goto out ; if ( num == 1 ) { s = ast_for_stmt ( & c , n ) ; if ( ! s ) goto out ; asdl_seq_SET ( stmts , 0 , s ) ; } else { REQ ( n , simple_stmt ) ; for ( i = 0 ; i < NCH ( n ) ; i += 2 ) { if ( TYPE ( CHILD ( n , i ) ) == NEWLINE ) break ; s = ast_for_stmt ( & c , CHILD ( n , i ) ) ; if ( ! s ) goto out ; asdl_seq_SET ( stmts , i / 2 , s ) ; } } res = Interactive ( stmts , arena ) ; } break ; <S2SV_StartBug> default : <S2SV_EndBug> PyErr_Format ( PyExc_SystemError , ""invalid<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>PyAST_FromNode"" , TYPE ( n ) ) ; goto out ; } out : if ( c . c_normalize ) { Py_DECREF ( c . c_normalize ) ; } return res ; }
","<S2SV_ModStart> = NULL ; asdl_seq * type_ignores = NULL ; <S2SV_ModStart> res = NULL ; asdl_seq * argtypes = NULL ; expr_ty ret , arg <S2SV_ModStart> } } } ch = CHILD ( n , NCH ( n ) - 1 ) ; REQ ( ch , ENDMARKER ) ; num = NCH ( ch ) ; type_ignores = _Py_asdl_seq_new ( num , arena ) ; if ( ! type_ignores ) goto out ; for ( i = 0 ; i < num ; i ++ ) { type_ignore_ty ti = TypeIgnore ( LINENO ( CHILD ( ch , i ) ) , arena ) ; if ( ! ti ) goto out ; asdl_seq_SET ( type_ignores , i , ti ) ; } <S2SV_ModStart> Module ( stmts , type_ignores <S2SV_ModStart> } break ; case func_type_input : n = CHILD ( n , 0 ) ; REQ ( n , func_type ) ; if ( TYPE ( CHILD ( n , 1 ) ) == typelist ) { ch = CHILD ( n , 1 ) ; num = 0 ; for ( i = 0 ; i < NCH ( ch ) ; i ++ ) { if ( TYPE ( CHILD ( ch , i ) ) == test ) { num ++ ; } } argtypes = _Py_asdl_seq_new ( num , arena ) ; if ( ! argtypes ) goto out ; j = 0 ; for ( i = 0 ; i < NCH ( ch ) ; i ++ ) { if ( TYPE ( CHILD ( ch , i ) ) == test ) { arg = ast_for_expr ( & c , CHILD ( ch , i ) ) ; if ( ! arg ) goto out ; asdl_seq_SET ( argtypes , j ++ , arg ) ; } } } else { argtypes = _Py_asdl_seq_new ( 0 , arena ) ; if ( ! argtypes ) goto out ; } ret = ast_for_expr ( & c , CHILD ( n , NCH ( n ) - 1 ) ) ; if ( ! ret ) goto out ; res = FunctionType ( argtypes , ret , arena ) ; break ;
"
729,"CWE-682 static int find_low_bit ( unsigned int x ) { int i ; for ( i = 0 ; i <= 31 ; i ++ ) { <S2SV_StartBug> if ( x & ( 1 << i ) ) return i ; <S2SV_EndBug> } return 0 ; }
","<S2SV_ModStart> x & ( 1U << ( unsigned int ) <S2SV_ModEnd> i ) )
"
730,"CWE-000 int config__parse_args ( struct mosquitto_db * db , struct mosquitto__config * config , int argc , char * argv [ ] ) { int i ; int port_tmp ; for ( i = 1 ; i < argc ; i ++ ) { if ( ! strcmp ( argv [ i ] , ""-c"" ) || ! strcmp ( argv [ i ] , ""--config-file"" ) ) { if ( i < argc - 1 ) { db -> config_file = argv [ i + 1 ] ; if ( config__read ( db , config , false ) ) { log__printf ( NULL , MOSQ_LOG_ERR , ""Error:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>configuration<S2SV_blank>file."" ) ; return MOSQ_ERR_INVAL ; } } else { log__printf ( NULL , MOSQ_LOG_ERR , ""Error:<S2SV_blank>-c<S2SV_blank>argument<S2SV_blank>given,<S2SV_blank>but<S2SV_blank>no<S2SV_blank>config<S2SV_blank>file<S2SV_blank>specified."" ) ; return MOSQ_ERR_INVAL ; } i ++ ; } else if ( ! strcmp ( argv [ i ] , ""-d"" ) || ! strcmp ( argv [ i ] , ""--daemon"" ) ) { config -> daemon = true ; } else if ( ! strcmp ( argv [ i ] , ""-h"" ) || ! strcmp ( argv [ i ] , ""--help"" ) ) { print_usage ( ) ; return MOSQ_ERR_INVAL ; } else if ( ! strcmp ( argv [ i ] , ""-p"" ) || ! strcmp ( argv [ i ] , ""--port"" ) ) { if ( i < argc - 1 ) { port_tmp = atoi ( argv [ i + 1 ] ) ; if ( port_tmp < 1 || port_tmp > 65535 ) { log__printf ( NULL , MOSQ_LOG_ERR , ""Error:<S2SV_blank>Invalid<S2SV_blank>port<S2SV_blank>specified<S2SV_blank>(%d)."" , port_tmp ) ; return MOSQ_ERR_INVAL ; } else { if ( config -> default_listener . port ) { log__printf ( NULL , MOSQ_LOG_WARNING , ""Warning:<S2SV_blank>Default<S2SV_blank>listener<S2SV_blank>port<S2SV_blank>specified<S2SV_blank>multiple<S2SV_blank>times.<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>latest<S2SV_blank>will<S2SV_blank>be<S2SV_blank>used."" ) ; } config -> default_listener . port = port_tmp ; } } else { log__printf ( NULL , MOSQ_LOG_ERR , ""Error:<S2SV_blank>-p<S2SV_blank>argument<S2SV_blank>given,<S2SV_blank>but<S2SV_blank>no<S2SV_blank>port<S2SV_blank>specified."" ) ; return MOSQ_ERR_INVAL ; } i ++ ; } else if ( ! strcmp ( argv [ i ] , ""-v"" ) || ! strcmp ( argv [ i ] , ""--verbose"" ) ) { db -> verbose = true ; } else { fprintf ( stderr , ""Error:<S2SV_blank>Unknown<S2SV_blank>option<S2SV_blank>\'%s\'.\\n"" , argv [ i ] ) ; print_usage ( ) ; return MOSQ_ERR_INVAL ; } } if ( config -> listener_count == 0 # ifdef WITH_TLS || config -> default_listener . cafile || config -> default_listener . capath || config -> default_listener . certfile || config -> default_listener . keyfile || config -> default_listener . ciphers || config -> default_listener . psk_hint || config -> default_listener . require_certificate || config -> default_listener . crlfile || config -> default_listener . use_identity_as_username || config -> default_listener . use_subject_as_username # endif || config -> default_listener . use_username_as_clientid || config -> default_listener . host || config -> default_listener . port || config -> default_listener . max_connections != - 1 || config -> default_listener . mount_point || config -> default_listener . protocol != mp_mqtt || config -> default_listener . socket_domain || config -> default_listener . security_options . password_file || config -> default_listener . security_options . psk_file || config -> default_listener . security_options . auth_plugin_config_count || config -> default_listener . security_options . allow_anonymous != - 1 ) { config -> listener_count ++ ; config -> listeners = mosquitto__realloc ( config -> listeners , sizeof ( struct mosquitto__listener ) * config -> listener_count ) ; if ( ! config -> listeners ) { log__printf ( NULL , MOSQ_LOG_ERR , ""Error:<S2SV_blank>Out<S2SV_blank>of<S2SV_blank>memory."" ) ; return MOSQ_ERR_NOMEM ; } memset ( & config -> listeners [ config -> listener_count - 1 ] , 0 , sizeof ( struct mosquitto__listener ) ) ; if ( config -> default_listener . port ) { config -> listeners [ config -> listener_count - 1 ] . port = config -> default_listener . port ; } else { config -> listeners [ config -> listener_count - 1 ] . port = 1883 ; } if ( config -> default_listener . host ) { config -> listeners [ config -> listener_count - 1 ] . host = config -> default_listener . host ; } else { config -> listeners [ config -> listener_count - 1 ] . host = NULL ; } if ( config -> default_listener . mount_point ) { config -> listeners [ config -> listener_count - 1 ] . mount_point = config -> default_listener . mount_point ; } else { config -> listeners [ config -> listener_count - 1 ] . mount_point = NULL ; } config -> listeners [ config -> listener_count - 1 ] . max_connections = config -> default_listener . max_connections ; config -> listeners [ config -> listener_count - 1 ] . protocol = config -> default_listener . protocol ; config -> listeners [ config -> listener_count - 1 ] . socket_domain = config -> default_listener . socket_domain ; config -> listeners [ config -> listener_count - 1 ] . client_count = 0 ; config -> listeners [ config -> listener_count - 1 ] . socks = NULL ; config -> listeners [ config -> listener_count - 1 ] . sock_count = 0 ; config -> listeners [ config -> listener_count - 1 ] . client_count = 0 ; config -> listeners [ config -> listener_count - 1 ] . use_username_as_clientid = config -> default_listener . use_username_as_clientid ; # ifdef WITH_TLS config -> listeners [ config -> listener_count - 1 ] . tls_version = config -> default_listener . tls_version ; config -> listeners [ config -> listener_count - 1 ] . cafile = config -> default_listener . cafile ; config -> listeners [ config -> listener_count - 1 ] . capath = config -> default_listener . capath ; config -> listeners [ config -> listener_count - 1 ] . certfile = config -> default_listener . certfile ; config -> listeners [ config -> listener_count - 1 ] . keyfile = config -> default_listener . keyfile ; config -> listeners [ config -> listener_count - 1 ] . ciphers = config -> default_listener . ciphers ; config -> listeners [ config -> listener_count - 1 ] . psk_hint = config -> default_listener . psk_hint ; config -> listeners [ config -> listener_count - 1 ] . require_certificate = config -> default_listener . require_certificate ; config -> listeners [ config -> listener_count - 1 ] . ssl_ctx = NULL ; config -> listeners [ config -> listener_count - 1 ] . crlfile = config -> default_listener . crlfile ; config -> listeners [ config -> listener_count - 1 ] . use_identity_as_username = config -> default_listener . use_identity_as_username ; config -> listeners [ config -> listener_count - 1 ] . use_subject_as_username = config -> default_listener . use_subject_as_username ; # endif <S2SV_StartBug> config -> listeners [ config -> listener_count - 1 ] . security_options . password_file = config -> default_listener . security_options . password_file ; <S2SV_EndBug> config -> listeners [ config -> listener_count - 1 ] . security_options . psk_file = config -> default_listener . security_options . psk_file ; config -> listeners [ config -> listener_count - 1 ] . security_options . auth_plugin_configs = config -> default_listener . security_options . auth_plugin_configs ; config -> listeners [ config -> listener_count - 1 ] . security_options . auth_plugin_config_count = config -> default_listener . security_options . auth_plugin_config_count ; config -> listeners [ config -> listener_count - 1 ] . security_options . allow_anonymous = config -> default_listener . security_options . allow_anonymous ; } if ( ! config -> user ) { config -> user = ""mosquitto"" ; } if ( db -> verbose ) { config -> log_type = INT_MAX ; } return config__check ( config ) ; }
","<S2SV_ModStart> . security_options . acl_file = config -> default_listener . security_options . acl_file ; config -> listeners [ config -> listener_count - 1 ] . security_options .
"
731,"CWE-125 static int ext4_fill_super ( struct super_block * sb , void * data , int silent ) { char * orig_data = kstrdup ( data , GFP_KERNEL ) ; struct buffer_head * bh ; struct ext4_super_block * es = NULL ; struct ext4_sb_info * sbi = kzalloc ( sizeof ( * sbi ) , GFP_KERNEL ) ; ext4_fsblk_t block ; ext4_fsblk_t sb_block = get_sb_block ( & data ) ; ext4_fsblk_t logical_sb_block ; unsigned long offset = 0 ; unsigned long journal_devnum = 0 ; unsigned long def_mount_opts ; struct inode * root ; const char * descr ; int ret = - ENOMEM ; int blocksize , clustersize ; unsigned int db_count ; unsigned int i ; int needs_recovery , has_huge_files , has_bigalloc ; __u64 blocks_count ; int err = 0 ; unsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO ; ext4_group_t first_not_zeroed ; if ( ( data && ! orig_data ) || ! sbi ) goto out_free_base ; sbi -> s_blockgroup_lock = kzalloc ( sizeof ( struct blockgroup_lock ) , GFP_KERNEL ) ; if ( ! sbi -> s_blockgroup_lock ) goto out_free_base ; sb -> s_fs_info = sbi ; sbi -> s_sb = sb ; sbi -> s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS ; sbi -> s_sb_block = sb_block ; if ( sb -> s_bdev -> bd_part ) sbi -> s_sectors_written_start = part_stat_read ( sb -> s_bdev -> bd_part , sectors [ 1 ] ) ; strreplace ( sb -> s_id , '/' , '!' ) ; ret = - EINVAL ; blocksize = sb_min_blocksize ( sb , EXT4_MIN_BLOCK_SIZE ) ; if ( ! blocksize ) { ext4_msg ( sb , KERN_ERR , ""unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>blocksize"" ) ; goto out_fail ; } if ( blocksize != EXT4_MIN_BLOCK_SIZE ) { logical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE ; offset = do_div ( logical_sb_block , blocksize ) ; } else { logical_sb_block = sb_block ; } if ( ! ( bh = sb_bread_unmovable ( sb , logical_sb_block ) ) ) { ext4_msg ( sb , KERN_ERR , ""unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>superblock"" ) ; goto out_fail ; } es = ( struct ext4_super_block * ) ( bh -> b_data + offset ) ; sbi -> s_es = es ; sb -> s_magic = le16_to_cpu ( es -> s_magic ) ; if ( sb -> s_magic != EXT4_SUPER_MAGIC ) goto cantfind_ext4 ; sbi -> s_kbytes_written = le64_to_cpu ( es -> s_kbytes_written ) ; if ( ext4_has_feature_metadata_csum ( sb ) && ext4_has_feature_gdt_csum ( sb ) ) ext4_warning ( sb , ""metadata_csum<S2SV_blank>and<S2SV_blank>uninit_bg<S2SV_blank>are<S2SV_blank>"" ""redundant<S2SV_blank>flags;<S2SV_blank>please<S2SV_blank>run<S2SV_blank>fsck."" ) ; if ( ! ext4_verify_csum_type ( sb , es ) ) { ext4_msg ( sb , KERN_ERR , ""VFS:<S2SV_blank>Found<S2SV_blank>ext4<S2SV_blank>filesystem<S2SV_blank>with<S2SV_blank>"" ""unknown<S2SV_blank>checksum<S2SV_blank>algorithm."" ) ; silent = 1 ; goto cantfind_ext4 ; } if ( ext4_has_feature_metadata_csum ( sb ) ) { sbi -> s_chksum_driver = crypto_alloc_shash ( ""crc32c"" , 0 , 0 ) ; if ( IS_ERR ( sbi -> s_chksum_driver ) ) { ext4_msg ( sb , KERN_ERR , ""Cannot<S2SV_blank>load<S2SV_blank>crc32c<S2SV_blank>driver."" ) ; ret = PTR_ERR ( sbi -> s_chksum_driver ) ; sbi -> s_chksum_driver = NULL ; goto failed_mount ; } } if ( ! ext4_superblock_csum_verify ( sb , es ) ) { ext4_msg ( sb , KERN_ERR , ""VFS:<S2SV_blank>Found<S2SV_blank>ext4<S2SV_blank>filesystem<S2SV_blank>with<S2SV_blank>"" ""invalid<S2SV_blank>superblock<S2SV_blank>checksum.<S2SV_blank><S2SV_blank>Run<S2SV_blank>e2fsck?"" ) ; silent = 1 ; ret = - EFSBADCRC ; goto cantfind_ext4 ; } if ( ext4_has_feature_csum_seed ( sb ) ) sbi -> s_csum_seed = le32_to_cpu ( es -> s_checksum_seed ) ; else if ( ext4_has_metadata_csum ( sb ) ) sbi -> s_csum_seed = ext4_chksum ( sbi , ~ 0 , es -> s_uuid , sizeof ( es -> s_uuid ) ) ; def_mount_opts = le32_to_cpu ( es -> s_default_mount_opts ) ; set_opt ( sb , INIT_INODE_TABLE ) ; if ( def_mount_opts & EXT4_DEFM_DEBUG ) set_opt ( sb , DEBUG ) ; if ( def_mount_opts & EXT4_DEFM_BSDGROUPS ) set_opt ( sb , GRPID ) ; if ( def_mount_opts & EXT4_DEFM_UID16 ) set_opt ( sb , NO_UID32 ) ; set_opt ( sb , XATTR_USER ) ; # ifdef CONFIG_EXT4_FS_POSIX_ACL set_opt ( sb , POSIX_ACL ) ; # endif if ( ext4_has_metadata_csum ( sb ) ) set_opt ( sb , JOURNAL_CHECKSUM ) ; if ( ( def_mount_opts & EXT4_DEFM_JMODE ) == EXT4_DEFM_JMODE_DATA ) set_opt ( sb , JOURNAL_DATA ) ; else if ( ( def_mount_opts & EXT4_DEFM_JMODE ) == EXT4_DEFM_JMODE_ORDERED ) set_opt ( sb , ORDERED_DATA ) ; else if ( ( def_mount_opts & EXT4_DEFM_JMODE ) == EXT4_DEFM_JMODE_WBACK ) set_opt ( sb , WRITEBACK_DATA ) ; if ( le16_to_cpu ( sbi -> s_es -> s_errors ) == EXT4_ERRORS_PANIC ) set_opt ( sb , ERRORS_PANIC ) ; else if ( le16_to_cpu ( sbi -> s_es -> s_errors ) == EXT4_ERRORS_CONTINUE ) set_opt ( sb , ERRORS_CONT ) ; else set_opt ( sb , ERRORS_RO ) ; set_opt ( sb , BLOCK_VALIDITY ) ; if ( def_mount_opts & EXT4_DEFM_DISCARD ) set_opt ( sb , DISCARD ) ; sbi -> s_resuid = make_kuid ( & init_user_ns , le16_to_cpu ( es -> s_def_resuid ) ) ; sbi -> s_resgid = make_kgid ( & init_user_ns , le16_to_cpu ( es -> s_def_resgid ) ) ; sbi -> s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ ; sbi -> s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME ; sbi -> s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME ; if ( ( def_mount_opts & EXT4_DEFM_NOBARRIER ) == 0 ) set_opt ( sb , BARRIER ) ; if ( ! IS_EXT3_SB ( sb ) && ! IS_EXT2_SB ( sb ) && ( ( def_mount_opts & EXT4_DEFM_NODELALLOC ) == 0 ) ) set_opt ( sb , DELALLOC ) ; sbi -> s_li_wait_mult = EXT4_DEF_LI_WAIT_MULT ; if ( sbi -> s_es -> s_mount_opts [ 0 ] ) { char * s_mount_opts = kstrndup ( sbi -> s_es -> s_mount_opts , sizeof ( sbi -> s_es -> s_mount_opts ) , GFP_KERNEL ) ; if ( ! s_mount_opts ) goto failed_mount ; if ( ! parse_options ( s_mount_opts , sb , & journal_devnum , & journal_ioprio , 0 ) ) { ext4_msg ( sb , KERN_WARNING , ""failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>options<S2SV_blank>in<S2SV_blank>superblock:<S2SV_blank>%s"" , s_mount_opts ) ; } kfree ( s_mount_opts ) ; } sbi -> s_def_mount_opt = sbi -> s_mount_opt ; if ( ! parse_options ( ( char * ) data , sb , & journal_devnum , & journal_ioprio , 0 ) ) goto failed_mount ; if ( test_opt ( sb , DATA_FLAGS ) == EXT4_MOUNT_JOURNAL_DATA ) { printk_once ( KERN_WARNING ""EXT4-fs:<S2SV_blank>Warning:<S2SV_blank>mounting<S2SV_blank>"" ""with<S2SV_blank>data=journal<S2SV_blank>disables<S2SV_blank>delayed<S2SV_blank>"" ""allocation<S2SV_blank>and<S2SV_blank>O_DIRECT<S2SV_blank>support!\\n"" ) ; if ( test_opt2 ( sb , EXPLICIT_DELALLOC ) ) { ext4_msg ( sb , KERN_ERR , ""can\'t<S2SV_blank>mount<S2SV_blank>with<S2SV_blank>"" ""both<S2SV_blank>data=journal<S2SV_blank>and<S2SV_blank>delalloc"" ) ; goto failed_mount ; } if ( test_opt ( sb , DIOREAD_NOLOCK ) ) { ext4_msg ( sb , KERN_ERR , ""can\'t<S2SV_blank>mount<S2SV_blank>with<S2SV_blank>"" ""both<S2SV_blank>data=journal<S2SV_blank>and<S2SV_blank>dioread_nolock"" ) ; goto failed_mount ; } if ( test_opt ( sb , DAX ) ) { ext4_msg ( sb , KERN_ERR , ""can\'t<S2SV_blank>mount<S2SV_blank>with<S2SV_blank>"" ""both<S2SV_blank>data=journal<S2SV_blank>and<S2SV_blank>dax"" ) ; goto failed_mount ; } if ( test_opt ( sb , DELALLOC ) ) clear_opt ( sb , DELALLOC ) ; } else { sb -> s_iflags |= SB_I_CGROUPWB ; } sb -> s_flags = ( sb -> s_flags & ~ MS_POSIXACL ) | ( test_opt ( sb , POSIX_ACL ) ? MS_POSIXACL : 0 ) ; if ( le32_to_cpu ( es -> s_rev_level ) == EXT4_GOOD_OLD_REV && ( ext4_has_compat_features ( sb ) || ext4_has_ro_compat_features ( sb ) || ext4_has_incompat_features ( sb ) ) ) ext4_msg ( sb , KERN_WARNING , ""feature<S2SV_blank>flags<S2SV_blank>set<S2SV_blank>on<S2SV_blank>rev<S2SV_blank>0<S2SV_blank>fs,<S2SV_blank>"" ""running<S2SV_blank>e2fsck<S2SV_blank>is<S2SV_blank>recommended"" ) ; if ( es -> s_creator_os == cpu_to_le32 ( EXT4_OS_HURD ) ) { set_opt2 ( sb , HURD_COMPAT ) ; if ( ext4_has_feature_64bit ( sb ) ) { ext4_msg ( sb , KERN_ERR , ""The<S2SV_blank>Hurd<S2SV_blank>can\'t<S2SV_blank>support<S2SV_blank>64-bit<S2SV_blank>file<S2SV_blank>systems"" ) ; goto failed_mount ; } } if ( IS_EXT2_SB ( sb ) ) { if ( ext2_feature_set_ok ( sb ) ) ext4_msg ( sb , KERN_INFO , ""mounting<S2SV_blank>ext2<S2SV_blank>file<S2SV_blank>system<S2SV_blank>"" ""using<S2SV_blank>the<S2SV_blank>ext4<S2SV_blank>subsystem"" ) ; else { ext4_msg ( sb , KERN_ERR , ""couldn\'t<S2SV_blank>mount<S2SV_blank>as<S2SV_blank>ext2<S2SV_blank>due<S2SV_blank>"" ""to<S2SV_blank>feature<S2SV_blank>incompatibilities"" ) ; goto failed_mount ; } } if ( IS_EXT3_SB ( sb ) ) { if ( ext3_feature_set_ok ( sb ) ) ext4_msg ( sb , KERN_INFO , ""mounting<S2SV_blank>ext3<S2SV_blank>file<S2SV_blank>system<S2SV_blank>"" ""using<S2SV_blank>the<S2SV_blank>ext4<S2SV_blank>subsystem"" ) ; else { ext4_msg ( sb , KERN_ERR , ""couldn\'t<S2SV_blank>mount<S2SV_blank>as<S2SV_blank>ext3<S2SV_blank>due<S2SV_blank>"" ""to<S2SV_blank>feature<S2SV_blank>incompatibilities"" ) ; goto failed_mount ; } } if ( ! ext4_feature_set_ok ( sb , ( sb -> s_flags & MS_RDONLY ) ) ) goto failed_mount ; blocksize = BLOCK_SIZE << le32_to_cpu ( es -> s_log_block_size ) ; if ( blocksize < EXT4_MIN_BLOCK_SIZE || blocksize > EXT4_MAX_BLOCK_SIZE ) { ext4_msg ( sb , KERN_ERR , ""Unsupported<S2SV_blank>filesystem<S2SV_blank>blocksize<S2SV_blank>%d<S2SV_blank>(%d<S2SV_blank>log_block_size)"" , blocksize , le32_to_cpu ( es -> s_log_block_size ) ) ; goto failed_mount ; } if ( le32_to_cpu ( es -> s_log_block_size ) > ( EXT4_MAX_BLOCK_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE ) ) { ext4_msg ( sb , KERN_ERR , ""Invalid<S2SV_blank>log<S2SV_blank>block<S2SV_blank>size:<S2SV_blank>%u"" , le32_to_cpu ( es -> s_log_block_size ) ) ; goto failed_mount ; } if ( le16_to_cpu ( sbi -> s_es -> s_reserved_gdt_blocks ) > ( blocksize / 4 ) ) { ext4_msg ( sb , KERN_ERR , ""Number<S2SV_blank>of<S2SV_blank>reserved<S2SV_blank>GDT<S2SV_blank>blocks<S2SV_blank>insanely<S2SV_blank>large:<S2SV_blank>%d"" , le16_to_cpu ( sbi -> s_es -> s_reserved_gdt_blocks ) ) ; goto failed_mount ; } if ( sbi -> s_mount_opt & EXT4_MOUNT_DAX ) { err = bdev_dax_supported ( sb , blocksize ) ; if ( err ) goto failed_mount ; } if ( ext4_has_feature_encrypt ( sb ) && es -> s_encryption_level ) { ext4_msg ( sb , KERN_ERR , ""Unsupported<S2SV_blank>encryption<S2SV_blank>level<S2SV_blank>%d"" , es -> s_encryption_level ) ; goto failed_mount ; } if ( sb -> s_blocksize != blocksize ) { if ( ! sb_set_blocksize ( sb , blocksize ) ) { ext4_msg ( sb , KERN_ERR , ""bad<S2SV_blank>block<S2SV_blank>size<S2SV_blank>%d"" , blocksize ) ; goto failed_mount ; } brelse ( bh ) ; logical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE ; offset = do_div ( logical_sb_block , blocksize ) ; bh = sb_bread_unmovable ( sb , logical_sb_block ) ; if ( ! bh ) { ext4_msg ( sb , KERN_ERR , ""Can\'t<S2SV_blank>read<S2SV_blank>superblock<S2SV_blank>on<S2SV_blank>2nd<S2SV_blank>try"" ) ; goto failed_mount ; } es = ( struct ext4_super_block * ) ( bh -> b_data + offset ) ; sbi -> s_es = es ; if ( es -> s_magic != cpu_to_le16 ( EXT4_SUPER_MAGIC ) ) { ext4_msg ( sb , KERN_ERR , ""Magic<S2SV_blank>mismatch,<S2SV_blank>very<S2SV_blank>weird!"" ) ; goto failed_mount ; } } has_huge_files = ext4_has_feature_huge_file ( sb ) ; sbi -> s_bitmap_maxbytes = ext4_max_bitmap_size ( sb -> s_blocksize_bits , has_huge_files ) ; sb -> s_maxbytes = ext4_max_size ( sb -> s_blocksize_bits , has_huge_files ) ; if ( le32_to_cpu ( es -> s_rev_level ) == EXT4_GOOD_OLD_REV ) { sbi -> s_inode_size = EXT4_GOOD_OLD_INODE_SIZE ; sbi -> s_first_ino = EXT4_GOOD_OLD_FIRST_INO ; } else { sbi -> s_inode_size = le16_to_cpu ( es -> s_inode_size ) ; sbi -> s_first_ino = le32_to_cpu ( es -> s_first_ino ) ; if ( ( sbi -> s_inode_size < EXT4_GOOD_OLD_INODE_SIZE ) || ( ! is_power_of_2 ( sbi -> s_inode_size ) ) || ( sbi -> s_inode_size > blocksize ) ) { ext4_msg ( sb , KERN_ERR , ""unsupported<S2SV_blank>inode<S2SV_blank>size:<S2SV_blank>%d"" , sbi -> s_inode_size ) ; goto failed_mount ; } if ( sbi -> s_inode_size > EXT4_GOOD_OLD_INODE_SIZE ) sb -> s_time_gran = 1 << ( EXT4_EPOCH_BITS - 2 ) ; } sbi -> s_desc_size = le16_to_cpu ( es -> s_desc_size ) ; if ( ext4_has_feature_64bit ( sb ) ) { if ( sbi -> s_desc_size < EXT4_MIN_DESC_SIZE_64BIT || sbi -> s_desc_size > EXT4_MAX_DESC_SIZE || ! is_power_of_2 ( sbi -> s_desc_size ) ) { ext4_msg ( sb , KERN_ERR , ""unsupported<S2SV_blank>descriptor<S2SV_blank>size<S2SV_blank>%lu"" , sbi -> s_desc_size ) ; goto failed_mount ; } } else sbi -> s_desc_size = EXT4_MIN_DESC_SIZE ; sbi -> s_blocks_per_group = le32_to_cpu ( es -> s_blocks_per_group ) ; sbi -> s_inodes_per_group = le32_to_cpu ( es -> s_inodes_per_group ) ; sbi -> s_inodes_per_block = blocksize / EXT4_INODE_SIZE ( sb ) ; if ( sbi -> s_inodes_per_block == 0 ) goto cantfind_ext4 ; if ( sbi -> s_inodes_per_group < sbi -> s_inodes_per_block || sbi -> s_inodes_per_group > blocksize * 8 ) { ext4_msg ( sb , KERN_ERR , ""invalid<S2SV_blank>inodes<S2SV_blank>per<S2SV_blank>group:<S2SV_blank>%lu\\n"" , sbi -> s_blocks_per_group ) ; goto failed_mount ; } sbi -> s_itb_per_group = sbi -> s_inodes_per_group / sbi -> s_inodes_per_block ; sbi -> s_desc_per_block = blocksize / EXT4_DESC_SIZE ( sb ) ; sbi -> s_sbh = bh ; sbi -> s_mount_state = le16_to_cpu ( es -> s_state ) ; sbi -> s_addr_per_block_bits = ilog2 ( EXT4_ADDR_PER_BLOCK ( sb ) ) ; sbi -> s_desc_per_block_bits = ilog2 ( EXT4_DESC_PER_BLOCK ( sb ) ) ; for ( i = 0 ; i < 4 ; i ++ ) sbi -> s_hash_seed [ i ] = le32_to_cpu ( es -> s_hash_seed [ i ] ) ; sbi -> s_def_hash_version = es -> s_def_hash_version ; if ( ext4_has_feature_dir_index ( sb ) ) { i = le32_to_cpu ( es -> s_flags ) ; if ( i & EXT2_FLAGS_UNSIGNED_HASH ) sbi -> s_hash_unsigned = 3 ; else if ( ( i & EXT2_FLAGS_SIGNED_HASH ) == 0 ) { # ifdef __CHAR_UNSIGNED__ if ( ! ( sb -> s_flags & MS_RDONLY ) ) es -> s_flags |= cpu_to_le32 ( EXT2_FLAGS_UNSIGNED_HASH ) ; sbi -> s_hash_unsigned = 3 ; # else if ( ! ( sb -> s_flags & MS_RDONLY ) ) es -> s_flags |= cpu_to_le32 ( EXT2_FLAGS_SIGNED_HASH ) ; # endif } } clustersize = BLOCK_SIZE << le32_to_cpu ( es -> s_log_cluster_size ) ; has_bigalloc = ext4_has_feature_bigalloc ( sb ) ; if ( has_bigalloc ) { if ( clustersize < blocksize ) { ext4_msg ( sb , KERN_ERR , ""cluster<S2SV_blank>size<S2SV_blank>(%d)<S2SV_blank>smaller<S2SV_blank>than<S2SV_blank>"" ""block<S2SV_blank>size<S2SV_blank>(%d)"" , clustersize , blocksize ) ; goto failed_mount ; } if ( le32_to_cpu ( es -> s_log_cluster_size ) > ( EXT4_MAX_CLUSTER_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE ) ) { ext4_msg ( sb , KERN_ERR , ""Invalid<S2SV_blank>log<S2SV_blank>cluster<S2SV_blank>size:<S2SV_blank>%u"" , le32_to_cpu ( es -> s_log_cluster_size ) ) ; goto failed_mount ; } sbi -> s_cluster_bits = le32_to_cpu ( es -> s_log_cluster_size ) - le32_to_cpu ( es -> s_log_block_size ) ; sbi -> s_clusters_per_group = le32_to_cpu ( es -> s_clusters_per_group ) ; if ( sbi -> s_clusters_per_group > blocksize * 8 ) { ext4_msg ( sb , KERN_ERR , ""#clusters<S2SV_blank>per<S2SV_blank>group<S2SV_blank>too<S2SV_blank>big:<S2SV_blank>%lu"" , sbi -> s_clusters_per_group ) ; goto failed_mount ; } if ( sbi -> s_blocks_per_group != ( sbi -> s_clusters_per_group * ( clustersize / blocksize ) ) ) { ext4_msg ( sb , KERN_ERR , ""blocks<S2SV_blank>per<S2SV_blank>group<S2SV_blank>(%lu)<S2SV_blank>and<S2SV_blank>"" ""clusters<S2SV_blank>per<S2SV_blank>group<S2SV_blank>(%lu)<S2SV_blank>inconsistent"" , sbi -> s_blocks_per_group , sbi -> s_clusters_per_group ) ; goto failed_mount ; } } else { if ( clustersize != blocksize ) { ext4_warning ( sb , ""fragment/cluster<S2SV_blank>size<S2SV_blank>(%d)<S2SV_blank>!=<S2SV_blank>"" ""block<S2SV_blank>size<S2SV_blank>(%d)"" , clustersize , blocksize ) ; clustersize = blocksize ; } if ( sbi -> s_blocks_per_group > blocksize * 8 ) { ext4_msg ( sb , KERN_ERR , ""#blocks<S2SV_blank>per<S2SV_blank>group<S2SV_blank>too<S2SV_blank>big:<S2SV_blank>%lu"" , sbi -> s_blocks_per_group ) ; goto failed_mount ; } sbi -> s_clusters_per_group = sbi -> s_blocks_per_group ; sbi -> s_cluster_bits = 0 ; } sbi -> s_cluster_ratio = clustersize / blocksize ; if ( sbi -> s_blocks_per_group == clustersize << 3 ) set_opt2 ( sb , STD_GROUP_SIZE ) ; err = generic_check_addressable ( sb -> s_blocksize_bits , ext4_blocks_count ( es ) ) ; if ( err ) { ext4_msg ( sb , KERN_ERR , ""filesystem"" ""<S2SV_blank>too<S2SV_blank>large<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>safely<S2SV_blank>on<S2SV_blank>this<S2SV_blank>system"" ) ; if ( sizeof ( sector_t ) < 8 ) ext4_msg ( sb , KERN_WARNING , ""CONFIG_LBDAF<S2SV_blank>not<S2SV_blank>enabled"" ) ; goto failed_mount ; } if ( EXT4_BLOCKS_PER_GROUP ( sb ) == 0 ) goto cantfind_ext4 ; blocks_count = sb -> s_bdev -> bd_inode -> i_size >> sb -> s_blocksize_bits ; if ( blocks_count && ext4_blocks_count ( es ) > blocks_count ) { ext4_msg ( sb , KERN_WARNING , ""bad<S2SV_blank>geometry:<S2SV_blank>block<S2SV_blank>count<S2SV_blank>%llu<S2SV_blank>"" ""exceeds<S2SV_blank>size<S2SV_blank>of<S2SV_blank>device<S2SV_blank>(%llu<S2SV_blank>blocks)"" , ext4_blocks_count ( es ) , blocks_count ) ; goto failed_mount ; } if ( le32_to_cpu ( es -> s_first_data_block ) >= ext4_blocks_count ( es ) ) { ext4_msg ( sb , KERN_WARNING , ""bad<S2SV_blank>geometry:<S2SV_blank>first<S2SV_blank>data<S2SV_blank>"" ""block<S2SV_blank>%u<S2SV_blank>is<S2SV_blank>beyond<S2SV_blank>end<S2SV_blank>of<S2SV_blank>filesystem<S2SV_blank>(%llu)"" , le32_to_cpu ( es -> s_first_data_block ) , ext4_blocks_count ( es ) ) ; goto failed_mount ; } blocks_count = ( ext4_blocks_count ( es ) - le32_to_cpu ( es -> s_first_data_block ) + EXT4_BLOCKS_PER_GROUP ( sb ) - 1 ) ; do_div ( blocks_count , EXT4_BLOCKS_PER_GROUP ( sb ) ) ; if ( blocks_count > ( ( uint64_t ) 1 << 32 ) - EXT4_DESC_PER_BLOCK ( sb ) ) { ext4_msg ( sb , KERN_WARNING , ""groups<S2SV_blank>count<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%u<S2SV_blank>"" ""(block<S2SV_blank>count<S2SV_blank>%llu,<S2SV_blank>first<S2SV_blank>data<S2SV_blank>block<S2SV_blank>%u,<S2SV_blank>"" ""blocks<S2SV_blank>per<S2SV_blank>group<S2SV_blank>%lu)"" , sbi -> s_groups_count , ext4_blocks_count ( es ) , le32_to_cpu ( es -> s_first_data_block ) , EXT4_BLOCKS_PER_GROUP ( sb ) ) ; goto failed_mount ; } sbi -> s_groups_count = blocks_count ; sbi -> s_blockfile_groups = min_t ( ext4_group_t , sbi -> s_groups_count , ( EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP ( sb ) ) ) ; db_count = ( sbi -> s_groups_count + EXT4_DESC_PER_BLOCK ( sb ) - 1 ) / <S2SV_StartBug> EXT4_DESC_PER_BLOCK ( sb ) ; <S2SV_EndBug> sbi -> s_group_desc = ext4_kvmalloc ( db_count * sizeof ( struct buffer_head * ) , GFP_KERNEL ) ; if ( sbi -> s_group_desc == NULL ) { ext4_msg ( sb , KERN_ERR , ""not<S2SV_blank>enough<S2SV_blank>memory"" ) ; ret = - ENOMEM ; goto failed_mount ; } bgl_lock_init ( sbi -> s_blockgroup_lock ) ; for ( i = 0 ; i < db_count ; i ++ ) { block = descriptor_loc ( sb , logical_sb_block , i ) ; sbi -> s_group_desc [ i ] = sb_bread_unmovable ( sb , block ) ; if ( ! sbi -> s_group_desc [ i ] ) { ext4_msg ( sb , KERN_ERR , ""can\'t<S2SV_blank>read<S2SV_blank>group<S2SV_blank>descriptor<S2SV_blank>%d"" , i ) ; db_count = i ; goto failed_mount2 ; } } if ( ! ext4_check_descriptors ( sb , logical_sb_block , & first_not_zeroed ) ) { ext4_msg ( sb , KERN_ERR , ""group<S2SV_blank>descriptors<S2SV_blank>corrupted!"" ) ; ret = - EFSCORRUPTED ; goto failed_mount2 ; } sbi -> s_gdb_count = db_count ; get_random_bytes ( & sbi -> s_next_generation , sizeof ( u32 ) ) ; spin_lock_init ( & sbi -> s_next_gen_lock ) ; setup_timer ( & sbi -> s_err_report , print_daily_error_info , ( unsigned long ) sb ) ; if ( ext4_es_register_shrinker ( sbi ) ) goto failed_mount3 ; sbi -> s_stripe = ext4_get_stripe_size ( sbi ) ; sbi -> s_extent_max_zeroout_kb = 32 ; sb -> s_op = & ext4_sops ; sb -> s_export_op = & ext4_export_ops ; sb -> s_xattr = ext4_xattr_handlers ; sb -> s_cop = & ext4_cryptops ; # ifdef CONFIG_QUOTA sb -> dq_op = & ext4_quota_operations ; if ( ext4_has_feature_quota ( sb ) ) sb -> s_qcop = & dquot_quotactl_sysfile_ops ; else sb -> s_qcop = & ext4_qctl_operations ; sb -> s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP | QTYPE_MASK_PRJ ; # endif memcpy ( sb -> s_uuid , es -> s_uuid , sizeof ( es -> s_uuid ) ) ; INIT_LIST_HEAD ( & sbi -> s_orphan ) ; mutex_init ( & sbi -> s_orphan_lock ) ; sb -> s_root = NULL ; needs_recovery = ( es -> s_last_orphan != 0 || ext4_has_feature_journal_needs_recovery ( sb ) ) ; if ( ext4_has_feature_mmp ( sb ) && ! ( sb -> s_flags & MS_RDONLY ) ) if ( ext4_multi_mount_protect ( sb , le64_to_cpu ( es -> s_mmp_block ) ) ) goto failed_mount3a ; if ( ! test_opt ( sb , NOLOAD ) && ext4_has_feature_journal ( sb ) ) { if ( ext4_load_journal ( sb , es , journal_devnum ) ) goto failed_mount3a ; } else if ( test_opt ( sb , NOLOAD ) && ! ( sb -> s_flags & MS_RDONLY ) && ext4_has_feature_journal_needs_recovery ( sb ) ) { ext4_msg ( sb , KERN_ERR , ""required<S2SV_blank>journal<S2SV_blank>recovery<S2SV_blank>"" ""suppressed<S2SV_blank>and<S2SV_blank>not<S2SV_blank>mounted<S2SV_blank>read-only"" ) ; goto failed_mount_wq ; } else { if ( test_opt2 ( sb , EXPLICIT_JOURNAL_CHECKSUM ) ) { ext4_msg ( sb , KERN_ERR , ""can\'t<S2SV_blank>mount<S2SV_blank>with<S2SV_blank>"" ""journal_checksum,<S2SV_blank>fs<S2SV_blank>mounted<S2SV_blank>w/o<S2SV_blank>journal"" ) ; goto failed_mount_wq ; } if ( test_opt ( sb , JOURNAL_ASYNC_COMMIT ) ) { ext4_msg ( sb , KERN_ERR , ""can\'t<S2SV_blank>mount<S2SV_blank>with<S2SV_blank>"" ""journal_async_commit,<S2SV_blank>fs<S2SV_blank>mounted<S2SV_blank>w/o<S2SV_blank>journal"" ) ; goto failed_mount_wq ; } if ( sbi -> s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE * HZ ) { ext4_msg ( sb , KERN_ERR , ""can\'t<S2SV_blank>mount<S2SV_blank>with<S2SV_blank>"" ""commit=%lu,<S2SV_blank>fs<S2SV_blank>mounted<S2SV_blank>w/o<S2SV_blank>journal"" , sbi -> s_commit_interval / HZ ) ; goto failed_mount_wq ; } if ( EXT4_MOUNT_DATA_FLAGS & ( sbi -> s_mount_opt ^ sbi -> s_def_mount_opt ) ) { ext4_msg ( sb , KERN_ERR , ""can\'t<S2SV_blank>mount<S2SV_blank>with<S2SV_blank>"" ""data=,<S2SV_blank>fs<S2SV_blank>mounted<S2SV_blank>w/o<S2SV_blank>journal"" ) ; goto failed_mount_wq ; } sbi -> s_def_mount_opt &= EXT4_MOUNT_JOURNAL_CHECKSUM ; clear_opt ( sb , JOURNAL_CHECKSUM ) ; clear_opt ( sb , DATA_FLAGS ) ; sbi -> s_journal = NULL ; needs_recovery = 0 ; goto no_journal ; } if ( ext4_has_feature_64bit ( sb ) && ! jbd2_journal_set_features ( EXT4_SB ( sb ) -> s_journal , 0 , 0 , JBD2_FEATURE_INCOMPAT_64BIT ) ) { ext4_msg ( sb , KERN_ERR , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>64-bit<S2SV_blank>journal<S2SV_blank>feature"" ) ; goto failed_mount_wq ; } if ( ! set_journal_csum_feature_set ( sb ) ) { ext4_msg ( sb , KERN_ERR , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>journal<S2SV_blank>checksum<S2SV_blank>"" ""feature<S2SV_blank>set"" ) ; goto failed_mount_wq ; } switch ( test_opt ( sb , DATA_FLAGS ) ) { case 0 : if ( jbd2_journal_check_available_features ( sbi -> s_journal , 0 , 0 , JBD2_FEATURE_INCOMPAT_REVOKE ) ) set_opt ( sb , ORDERED_DATA ) ; else set_opt ( sb , JOURNAL_DATA ) ; break ; case EXT4_MOUNT_ORDERED_DATA : case EXT4_MOUNT_WRITEBACK_DATA : if ( ! jbd2_journal_check_available_features ( sbi -> s_journal , 0 , 0 , JBD2_FEATURE_INCOMPAT_REVOKE ) ) { ext4_msg ( sb , KERN_ERR , ""Journal<S2SV_blank>does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>"" ""requested<S2SV_blank>data<S2SV_blank>journaling<S2SV_blank>mode"" ) ; goto failed_mount_wq ; } default : break ; } set_task_ioprio ( sbi -> s_journal -> j_task , journal_ioprio ) ; sbi -> s_journal -> j_commit_callback = ext4_journal_commit_callback ; no_journal : sbi -> s_mb_cache = ext4_xattr_create_cache ( ) ; if ( ! sbi -> s_mb_cache ) { ext4_msg ( sb , KERN_ERR , ""Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>an<S2SV_blank>mb_cache"" ) ; goto failed_mount_wq ; } if ( ( DUMMY_ENCRYPTION_ENABLED ( sbi ) || ext4_has_feature_encrypt ( sb ) ) && ( blocksize != PAGE_SIZE ) ) { ext4_msg ( sb , KERN_ERR , ""Unsupported<S2SV_blank>blocksize<S2SV_blank>for<S2SV_blank>fs<S2SV_blank>encryption"" ) ; goto failed_mount_wq ; } if ( DUMMY_ENCRYPTION_ENABLED ( sbi ) && ! ( sb -> s_flags & MS_RDONLY ) && ! ext4_has_feature_encrypt ( sb ) ) { ext4_set_feature_encrypt ( sb ) ; ext4_commit_super ( sb , 1 ) ; } if ( es -> s_overhead_clusters ) sbi -> s_overhead = le32_to_cpu ( es -> s_overhead_clusters ) ; else { err = ext4_calculate_overhead ( sb ) ; if ( err ) goto failed_mount_wq ; } EXT4_SB ( sb ) -> rsv_conversion_wq = alloc_workqueue ( ""ext4-rsv-conversion"" , WQ_MEM_RECLAIM | WQ_UNBOUND , 1 ) ; if ( ! EXT4_SB ( sb ) -> rsv_conversion_wq ) { printk ( KERN_ERR ""EXT4-fs:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>workqueue\\n"" ) ; ret = - ENOMEM ; goto failed_mount4 ; } root = ext4_iget ( sb , EXT4_ROOT_INO ) ; if ( IS_ERR ( root ) ) { ext4_msg ( sb , KERN_ERR , ""get<S2SV_blank>root<S2SV_blank>inode<S2SV_blank>failed"" ) ; ret = PTR_ERR ( root ) ; root = NULL ; goto failed_mount4 ; } if ( ! S_ISDIR ( root -> i_mode ) || ! root -> i_blocks || ! root -> i_size ) { ext4_msg ( sb , KERN_ERR , ""corrupt<S2SV_blank>root<S2SV_blank>inode,<S2SV_blank>run<S2SV_blank>e2fsck"" ) ; iput ( root ) ; goto failed_mount4 ; } sb -> s_root = d_make_root ( root ) ; if ( ! sb -> s_root ) { ext4_msg ( sb , KERN_ERR , ""get<S2SV_blank>root<S2SV_blank>dentry<S2SV_blank>failed"" ) ; ret = - ENOMEM ; goto failed_mount4 ; } if ( ext4_setup_super ( sb , es , sb -> s_flags & MS_RDONLY ) ) sb -> s_flags |= MS_RDONLY ; if ( sbi -> s_inode_size > EXT4_GOOD_OLD_INODE_SIZE ) { sbi -> s_want_extra_isize = sizeof ( struct ext4_inode ) - EXT4_GOOD_OLD_INODE_SIZE ; if ( ext4_has_feature_extra_isize ( sb ) ) { if ( sbi -> s_want_extra_isize < le16_to_cpu ( es -> s_want_extra_isize ) ) sbi -> s_want_extra_isize = le16_to_cpu ( es -> s_want_extra_isize ) ; if ( sbi -> s_want_extra_isize < le16_to_cpu ( es -> s_min_extra_isize ) ) sbi -> s_want_extra_isize = le16_to_cpu ( es -> s_min_extra_isize ) ; } } if ( EXT4_GOOD_OLD_INODE_SIZE + sbi -> s_want_extra_isize > sbi -> s_inode_size ) { sbi -> s_want_extra_isize = sizeof ( struct ext4_inode ) - EXT4_GOOD_OLD_INODE_SIZE ; ext4_msg ( sb , KERN_INFO , ""required<S2SV_blank>extra<S2SV_blank>inode<S2SV_blank>space<S2SV_blank>not"" ""available"" ) ; } ext4_set_resv_clusters ( sb ) ; err = ext4_setup_system_zone ( sb ) ; if ( err ) { ext4_msg ( sb , KERN_ERR , ""failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>system<S2SV_blank>"" ""zone<S2SV_blank>(%d)"" , err ) ; goto failed_mount4a ; } ext4_ext_init ( sb ) ; err = ext4_mb_init ( sb ) ; if ( err ) { ext4_msg ( sb , KERN_ERR , ""failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>mballoc<S2SV_blank>(%d)"" , err ) ; goto failed_mount5 ; } block = ext4_count_free_clusters ( sb ) ; ext4_free_blocks_count_set ( sbi -> s_es , EXT4_C2B ( sbi , block ) ) ; err = percpu_counter_init ( & sbi -> s_freeclusters_counter , block , GFP_KERNEL ) ; if ( ! err ) { unsigned long freei = ext4_count_free_inodes ( sb ) ; sbi -> s_es -> s_free_inodes_count = cpu_to_le32 ( freei ) ; err = percpu_counter_init ( & sbi -> s_freeinodes_counter , freei , GFP_KERNEL ) ; } if ( ! err ) err = percpu_counter_init ( & sbi -> s_dirs_counter , ext4_count_dirs ( sb ) , GFP_KERNEL ) ; if ( ! err ) err = percpu_counter_init ( & sbi -> s_dirtyclusters_counter , 0 , GFP_KERNEL ) ; if ( ! err ) err = percpu_init_rwsem ( & sbi -> s_journal_flag_rwsem ) ; if ( err ) { ext4_msg ( sb , KERN_ERR , ""insufficient<S2SV_blank>memory"" ) ; goto failed_mount6 ; } if ( ext4_has_feature_flex_bg ( sb ) ) if ( ! ext4_fill_flex_info ( sb ) ) { ext4_msg ( sb , KERN_ERR , ""unable<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>"" ""flex_bg<S2SV_blank>meta<S2SV_blank>info!"" ) ; goto failed_mount6 ; } err = ext4_register_li_request ( sb , first_not_zeroed ) ; if ( err ) goto failed_mount6 ; err = ext4_register_sysfs ( sb ) ; if ( err ) goto failed_mount7 ; # ifdef CONFIG_QUOTA if ( ext4_has_feature_quota ( sb ) && ! ( sb -> s_flags & MS_RDONLY ) ) { err = ext4_enable_quotas ( sb ) ; if ( err ) goto failed_mount8 ; } # endif EXT4_SB ( sb ) -> s_mount_state |= EXT4_ORPHAN_FS ; ext4_orphan_cleanup ( sb , es ) ; EXT4_SB ( sb ) -> s_mount_state &= ~ EXT4_ORPHAN_FS ; if ( needs_recovery ) { ext4_msg ( sb , KERN_INFO , ""recovery<S2SV_blank>complete"" ) ; ext4_mark_recovery_complete ( sb , es ) ; } if ( EXT4_SB ( sb ) -> s_journal ) { if ( test_opt ( sb , DATA_FLAGS ) == EXT4_MOUNT_JOURNAL_DATA ) descr = ""<S2SV_blank>journalled<S2SV_blank>data<S2SV_blank>mode"" ; else if ( test_opt ( sb , DATA_FLAGS ) == EXT4_MOUNT_ORDERED_DATA ) descr = ""<S2SV_blank>ordered<S2SV_blank>data<S2SV_blank>mode"" ; else descr = ""<S2SV_blank>writeback<S2SV_blank>data<S2SV_blank>mode"" ; } else descr = ""out<S2SV_blank>journal"" ; if ( test_opt ( sb , DISCARD ) ) { struct request_queue * q = bdev_get_queue ( sb -> s_bdev ) ; if ( ! blk_queue_discard ( q ) ) ext4_msg ( sb , KERN_WARNING , ""mounting<S2SV_blank>with<S2SV_blank>\\""discard\\""<S2SV_blank>option,<S2SV_blank>but<S2SV_blank>"" ""the<S2SV_blank>device<S2SV_blank>does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>discard"" ) ; } if ( ___ratelimit ( & ext4_mount_msg_ratelimit , ""EXT4-fs<S2SV_blank>mount"" ) ) ext4_msg ( sb , KERN_INFO , ""mounted<S2SV_blank>filesystem<S2SV_blank>with%s.<S2SV_blank>"" ""Opts:<S2SV_blank>%.*s%s%s"" , descr , ( int ) sizeof ( sbi -> s_es -> s_mount_opts ) , sbi -> s_es -> s_mount_opts , * sbi -> s_es -> s_mount_opts ? "";<S2SV_blank>"" : """" , orig_data ) ; if ( es -> s_error_count ) mod_timer ( & sbi -> s_err_report , jiffies + 300 * HZ ) ; ratelimit_state_init ( & sbi -> s_err_ratelimit_state , 5 * HZ , 10 ) ; ratelimit_state_init ( & sbi -> s_warning_ratelimit_state , 5 * HZ , 10 ) ; ratelimit_state_init ( & sbi -> s_msg_ratelimit_state , 5 * HZ , 10 ) ; kfree ( orig_data ) ; # ifdef CONFIG_EXT4_FS_ENCRYPTION memcpy ( sbi -> key_prefix , EXT4_KEY_DESC_PREFIX , EXT4_KEY_DESC_PREFIX_SIZE ) ; sbi -> key_prefix_size = EXT4_KEY_DESC_PREFIX_SIZE ; # endif return 0 ; cantfind_ext4 : if ( ! silent ) ext4_msg ( sb , KERN_ERR , ""VFS:<S2SV_blank>Can\'t<S2SV_blank>find<S2SV_blank>ext4<S2SV_blank>filesystem"" ) ; goto failed_mount ; # ifdef CONFIG_QUOTA failed_mount8 : ext4_unregister_sysfs ( sb ) ; # endif failed_mount7 : ext4_unregister_li_request ( sb ) ; failed_mount6 : ext4_mb_release ( sb ) ; if ( sbi -> s_flex_groups ) kvfree ( sbi -> s_flex_groups ) ; percpu_counter_destroy ( & sbi -> s_freeclusters_counter ) ; percpu_counter_destroy ( & sbi -> s_freeinodes_counter ) ; percpu_counter_destroy ( & sbi -> s_dirs_counter ) ; percpu_counter_destroy ( & sbi -> s_dirtyclusters_counter ) ; failed_mount5 : ext4_ext_release ( sb ) ; ext4_release_system_zone ( sb ) ; failed_mount4a : dput ( sb -> s_root ) ; sb -> s_root = NULL ; failed_mount4 : ext4_msg ( sb , KERN_ERR , ""mount<S2SV_blank>failed"" ) ; if ( EXT4_SB ( sb ) -> rsv_conversion_wq ) destroy_workqueue ( EXT4_SB ( sb ) -> rsv_conversion_wq ) ; failed_mount_wq : if ( sbi -> s_mb_cache ) { ext4_xattr_destroy_cache ( sbi -> s_mb_cache ) ; sbi -> s_mb_cache = NULL ; } if ( sbi -> s_journal ) { jbd2_journal_destroy ( sbi -> s_journal ) ; sbi -> s_journal = NULL ; } failed_mount3a : ext4_es_unregister_shrinker ( sbi ) ; failed_mount3 : del_timer_sync ( & sbi -> s_err_report ) ; if ( sbi -> s_mmp_tsk ) kthread_stop ( sbi -> s_mmp_tsk ) ; failed_mount2 : for ( i = 0 ; i < db_count ; i ++ ) brelse ( sbi -> s_group_desc [ i ] ) ; kvfree ( sbi -> s_group_desc ) ; failed_mount : if ( sbi -> s_chksum_driver ) crypto_free_shash ( sbi -> s_chksum_driver ) ; # ifdef CONFIG_QUOTA for ( i = 0 ; i < EXT4_MAXQUOTAS ; i ++ ) kfree ( sbi -> s_qf_names [ i ] ) ; # endif ext4_blkdev_remove ( sbi ) ; brelse ( bh ) ; out_fail : sb -> s_fs_info = NULL ; kfree ( sbi -> s_blockgroup_lock ) ; out_free_base : kfree ( sbi ) ; kfree ( orig_data ) ; return err ? err : ret ; }
","<S2SV_ModStart> sb ) ; if ( ext4_has_feature_meta_bg ( sb ) ) { if ( le32_to_cpu ( es -> s_first_meta_bg ) >= db_count ) { ext4_msg ( sb , KERN_WARNING , ""first<S2SV_blank>meta<S2SV_blank>block<S2SV_blank>group<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%u<S2SV_blank>"" ""(group<S2SV_blank>descriptor<S2SV_blank>block<S2SV_blank>count<S2SV_blank>%u)"" , le32_to_cpu ( es -> s_first_meta_bg ) , db_count ) ; goto failed_mount ; } }
"
732,"CWE-19 static int nft_flush_table ( struct nft_ctx * ctx ) { int err ; struct nft_chain * chain , * nc ; struct nft_set * set , * ns ; <S2SV_StartBug> list_for_each_entry_safe ( chain , nc , & ctx -> table -> chains , list ) { <S2SV_EndBug> ctx -> chain = chain ; err = nft_delrule_by_chain ( ctx ) ; if ( err < 0 ) goto out ; <S2SV_StartBug> err = nft_delchain ( ctx ) ; <S2SV_EndBug> if ( err < 0 ) goto out ; } <S2SV_StartBug> list_for_each_entry_safe ( set , ns , & ctx -> table -> sets , list ) { <S2SV_EndBug> <S2SV_StartBug> if ( set -> flags & NFT_SET_ANONYMOUS && <S2SV_EndBug> ! list_empty ( & set -> bindings ) ) continue ; err = nft_delset ( ctx , set ) ; if ( err < 0 ) goto out ; } err = nft_deltable ( ctx ) ; out : return err ; }
","<S2SV_ModStart> * ns ; list_for_each_entry ( chain <S2SV_ModEnd> , & ctx <S2SV_ModStart> goto out ; } list_for_each_entry_safe ( set , ns , & ctx -> table -> sets , list ) { if ( set -> flags & NFT_SET_ANONYMOUS && ! list_empty ( & set -> bindings ) ) continue ; err = nft_delset ( ctx , set <S2SV_ModEnd> ) ; if <S2SV_ModStart> } list_for_each_entry_safe ( chain , nc <S2SV_ModEnd> , & ctx <S2SV_ModStart> -> table -> chains <S2SV_ModEnd> , list ) <S2SV_ModStart> list ) { ctx -> chain = chain ; err = nft_delchain ( ctx <S2SV_ModEnd> ) ; if
"
733,"CWE-404 static void lockd_down_net ( struct svc_serv * serv , struct net * net ) { struct lockd_net * ln = net_generic ( net , lockd_net_id ) ; if ( ln -> nlmsvc_users ) { if ( -- ln -> nlmsvc_users == 0 ) { nlm_shutdown_hosts_net ( net ) ; <S2SV_StartBug> cancel_delayed_work_sync ( & ln -> grace_period_end ) ; <S2SV_EndBug> locks_end_grace ( & ln -> lockd_manager ) ; svc_shutdown_net ( serv , net ) ; dprintk ( ""lockd_down_net:<S2SV_blank>per-net<S2SV_blank>data<S2SV_blank>destroyed;<S2SV_blank>net=%p\\n"" , net ) ; } } else { printk ( KERN_ERR ""lockd_down_net:<S2SV_blank>no<S2SV_blank>users!<S2SV_blank>task=%p,<S2SV_blank>net=%p\\n"" , nlmsvc_task , net ) ; BUG ( ) ; } }
","<S2SV_ModStart> net ) ; <S2SV_ModEnd> svc_shutdown_net ( serv
"
734,"CWE-17 static ssize_t <S2SV_StartBug> pipe_write ( struct kiocb * iocb , const struct iovec * _iov , <S2SV_EndBug> unsigned long nr_segs , loff_t ppos ) { struct file * filp = iocb -> ki_filp ; struct pipe_inode_info * pipe = filp -> private_data ; <S2SV_StartBug> ssize_t ret ; <S2SV_EndBug> <S2SV_StartBug> int do_wakeup ; <S2SV_EndBug> struct iovec * iov = ( struct iovec * ) _iov ; <S2SV_StartBug> size_t total_len ; <S2SV_EndBug> ssize_t chars ; <S2SV_StartBug> total_len = iov_length ( iov , nr_segs ) ; <S2SV_EndBug> if ( unlikely ( total_len == 0 ) ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> do_wakeup = 0 ; ret = 0 ; __pipe_lock ( pipe ) ; if ( ! pipe -> readers ) { send_sig ( SIGPIPE , current , 0 ) ; ret = - EPIPE ; goto out ; } chars = total_len & ( PAGE_SIZE - 1 ) ; if ( pipe -> nrbufs && chars != 0 ) { int lastbuf = ( pipe -> curbuf + pipe -> nrbufs - 1 ) & ( pipe -> buffers - 1 ) ; struct pipe_buffer * buf = pipe -> bufs + lastbuf ; const struct pipe_buf_operations * ops = buf -> ops ; int offset = buf -> offset + buf -> len ; if ( ops -> can_merge && offset + chars <= PAGE_SIZE ) { <S2SV_StartBug> int error , atomic = 1 ; <S2SV_EndBug> void * addr ; error = ops -> confirm ( pipe , buf ) ; if ( error ) goto out ; <S2SV_StartBug> iov_fault_in_pages_read ( iov , chars ) ; <S2SV_EndBug> redo1 : if ( atomic ) addr = kmap_atomic ( buf -> page ) ; else addr = kmap ( buf -> page ) ; error = pipe_iov_copy_from_user ( offset + addr , iov , chars , atomic ) ; if ( atomic ) kunmap_atomic ( addr ) ; else kunmap ( buf -> page ) ; ret = error ; do_wakeup = 1 ; if ( error ) { if ( atomic ) { atomic = 0 ; goto redo1 ; } goto out ; <S2SV_StartBug> } <S2SV_EndBug> buf -> len += chars ; <S2SV_StartBug> total_len -= chars ; <S2SV_EndBug> ret = chars ; if ( ! total_len ) goto out ; } } for ( ; ; ) { int bufs ; if ( ! pipe -> readers ) { send_sig ( SIGPIPE , current , 0 ) ; if ( ! ret ) ret = - EPIPE ; break ; } bufs = pipe -> nrbufs ; if ( bufs < pipe -> buffers ) { int newbuf = ( pipe -> curbuf + bufs ) & ( pipe -> buffers - 1 ) ; struct pipe_buffer * buf = pipe -> bufs + newbuf ; struct page * page = pipe -> tmp_page ; <S2SV_StartBug> char * src ; <S2SV_EndBug> int error , atomic = 1 ; if ( ! page ) { page = alloc_page ( GFP_HIGHUSER ) ; if ( unlikely ( ! page ) ) { ret = ret ? : - ENOMEM ; break ; } pipe -> tmp_page = page ; } do_wakeup = 1 ; <S2SV_StartBug> chars = PAGE_SIZE ; <S2SV_EndBug> if ( chars > total_len ) chars = total_len ; iov_fault_in_pages_read ( iov , chars ) ; redo2 : if ( atomic ) src = kmap_atomic ( page ) ; else src = kmap ( page ) ; error = pipe_iov_copy_from_user ( src , iov , chars , atomic ) ; if ( atomic ) kunmap_atomic ( src ) ; else kunmap ( page ) ; <S2SV_StartBug> if ( unlikely ( error ) ) { <S2SV_EndBug> if ( atomic ) { atomic = 0 ; goto redo2 ; } if ( ! ret ) ret = error ; break ; } <S2SV_StartBug> ret += chars ; <S2SV_EndBug> buf -> page = page ; buf -> ops = & anon_pipe_buf_ops ; buf -> offset = 0 ; <S2SV_StartBug> buf -> len = chars ; <S2SV_EndBug> buf -> flags = 0 ; if ( is_packetized ( filp ) ) { buf -> ops = & packet_pipe_buf_ops ; buf -> flags = PIPE_BUF_FLAG_PACKET ; } pipe -> nrbufs = ++ bufs ; pipe -> tmp_page = NULL ; <S2SV_StartBug> total_len -= chars ; <S2SV_EndBug> if ( ! total_len ) break ; } if ( bufs < pipe -> buffers ) continue ; if ( filp -> f_flags & O_NONBLOCK ) { if ( ! ret ) ret = - EAGAIN ; break ; } if ( signal_pending ( current ) ) { if ( ! ret ) ret = - ERESTARTSYS ; break ; } if ( do_wakeup ) { wake_up_interruptible_sync_poll ( & pipe -> wait , POLLIN | POLLRDNORM ) ; kill_fasync ( & pipe -> fasync_readers , SIGIO , POLL_IN ) ; do_wakeup = 0 ; } pipe -> waiting_writers ++ ; pipe_wait ( pipe ) ; pipe -> waiting_writers -- ; } out : __pipe_unlock ( pipe ) ; if ( do_wakeup ) { wake_up_interruptible_sync_poll ( & pipe -> wait , POLLIN | POLLRDNORM ) ; kill_fasync ( & pipe -> fasync_readers , SIGIO , POLL_IN ) ; } if ( ret > 0 && sb_start_write_trylock ( file_inode ( filp ) -> i_sb ) ) { int err = file_update_time ( filp ) ; if ( err ) ret = err ; sb_end_write ( file_inode ( filp ) -> i_sb ) ; } return ret ; }
","<S2SV_ModStart> * iocb , struct iov_iter * from <S2SV_ModEnd> ) { struct <S2SV_ModStart> ; ssize_t ret = 0 <S2SV_ModStart> ; int do_wakeup = 0 <S2SV_ModEnd> ; size_t total_len <S2SV_ModStart> ; size_t total_len = iov_iter_count ( from ) <S2SV_ModStart> ssize_t chars ; <S2SV_ModEnd> if ( unlikely <S2SV_ModStart> ) ) return <S2SV_ModEnd> 0 ; __pipe_lock <S2SV_ModStart> { int error <S2SV_ModEnd> = ops -> <S2SV_ModStart> goto out ; ret = copy_page_from_iter ( buf -> page , offset , chars , from ) ; if ( unlikely ( ret < chars ) ) { error = - EFAULT ; <S2SV_ModEnd> goto out ; <S2SV_ModStart> out ; } do_wakeup = 1 ; <S2SV_ModStart> += chars ; ret = chars ; if ( ! iov_iter_count ( from ) <S2SV_ModEnd> ) goto out <S2SV_ModStart> -> tmp_page ; int copied <S2SV_ModEnd> ; if ( <S2SV_ModStart> = 1 ; copied = copy_page_from_iter ( page , 0 , PAGE_SIZE , from <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( unlikely ( copied < PAGE_SIZE && iov_iter_count ( from ) ) ) { if ( ! ret ) ret = - EFAULT <S2SV_ModEnd> ; break ; <S2SV_ModStart> } ret += copied <S2SV_ModEnd> ; buf -> <S2SV_ModStart> -> len = copied <S2SV_ModEnd> ; buf -> <S2SV_ModStart> = NULL ; if ( ! iov_iter_count ( from ) <S2SV_ModEnd> ) break ;
"
735,"CWE-22 int main ( int argc , char * argv [ ] ) { struct mschm_decompressor * chmd ; struct mschmd_header * chm ; struct mschmd_file * file , * * f ; unsigned int numf , i ; setbuf ( stdout , NULL ) ; setbuf ( stderr , NULL ) ; user_umask = umask ( 0 ) ; umask ( user_umask ) ; MSPACK_SYS_SELFTEST ( i ) ; if ( i ) return 0 ; if ( ( chmd = mspack_create_chm_decompressor ( NULL ) ) ) { for ( argv ++ ; * argv ; argv ++ ) { printf ( ""%s\\n"" , * argv ) ; if ( ( chm = chmd -> open ( chmd , * argv ) ) ) { for ( numf = 0 , file = chm -> files ; file ; file = file -> next ) numf ++ ; if ( ( f = ( struct mschmd_file * * ) calloc ( numf , sizeof ( struct mschmd_file * ) ) ) ) { for ( i = 0 , file = chm -> files ; file ; file = file -> next ) f [ i ++ ] = file ; qsort ( f , numf , sizeof ( struct mschmd_file * ) , & sortfunc ) ; for ( i = 0 ; i < numf ; i ++ ) { <S2SV_StartBug> char * outname = create_output_name ( ( unsigned char * ) f [ i ] -> filename , NULL , 0 , 1 , 0 ) ; <S2SV_EndBug> printf ( ""Extracting<S2SV_blank>%s\\n"" , outname ) ; ensure_filepath ( outname ) ; if ( chmd -> extract ( chmd , f [ i ] , outname ) ) { printf ( ""%s:<S2SV_blank>extract<S2SV_blank>error<S2SV_blank>on<S2SV_blank>\\""%s\\"":<S2SV_blank>%s\\n"" , * argv , f [ i ] -> filename , ERROR ( chmd ) ) ; } free ( outname ) ; } free ( f ) ; } chmd -> close ( chmd , chm ) ; } else { printf ( ""%s:<S2SV_blank>can\'t<S2SV_blank>open<S2SV_blank>--<S2SV_blank>%s\\n"" , * argv , ERROR ( chmd ) ) ; } } mspack_destroy_chm_decompressor ( chmd ) ; } return 0 ; }
","<S2SV_ModStart> = create_output_name ( <S2SV_ModEnd> f [ i <S2SV_ModStart> ] -> filename <S2SV_ModEnd> ) ; printf
"
736,"CWE-200 int ping_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct inet_sock * isk = inet_sk ( sk ) ; <S2SV_StartBug> int family = sk -> sk_family ; <S2SV_EndBug> struct sockaddr_in * sin ; struct sockaddr_in6 * sin6 ; struct sk_buff * skb ; int copied , err ; pr_debug ( ""ping_recvmsg(sk=%p,sk->num=%u)\\n"" , isk , isk -> inet_num ) ; err = - EOPNOTSUPP ; if ( flags & MSG_OOB ) goto out ; <S2SV_StartBug> if ( addr_len ) { <S2SV_EndBug> if ( family == AF_INET ) * addr_len = sizeof ( * sin ) ; else if ( family == AF_INET6 && addr_len ) * addr_len = sizeof ( * sin6 ) ; } if ( flags & MSG_ERRQUEUE ) { if ( family == AF_INET ) { return ip_recv_error ( sk , msg , len ) ; # if IS_ENABLED ( CONFIG_IPV6 ) } else if ( family == AF_INET6 ) { return pingv6_ops . ipv6_recv_error ( sk , msg , len ) ; # endif } } skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) goto out ; copied = skb -> len ; if ( copied > len ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto done ; sock_recv_timestamp ( msg , sk , skb ) ; if ( family == AF_INET ) { <S2SV_StartBug> sin = ( struct sockaddr_in * ) msg -> msg_name ; <S2SV_EndBug> sin -> sin_family = AF_INET ; sin -> sin_port = 0 ; sin -> sin_addr . s_addr = ip_hdr ( skb ) -> saddr ; memset ( sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ; <S2SV_StartBug> if ( isk -> cmsg_flags ) <S2SV_EndBug> ip_cmsg_recv ( msg , skb ) ; # if IS_ENABLED ( CONFIG_IPV6 ) } else if ( family == AF_INET6 ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct ipv6hdr * ip6 = ipv6_hdr ( skb ) ; <S2SV_StartBug> sin6 = ( struct sockaddr_in6 * ) msg -> msg_name ; <S2SV_EndBug> sin6 -> sin6_family = AF_INET6 ; sin6 -> sin6_port = 0 ; sin6 -> sin6_addr = ip6 -> saddr ; sin6 -> sin6_flowinfo = 0 ; if ( np -> sndflow ) sin6 -> sin6_flowinfo = ip6_flowinfo ( ip6 ) ; sin6 -> sin6_scope_id = ipv6_iface_scope_id ( & sin6 -> sin6_addr , <S2SV_StartBug> IP6CB ( skb ) -> iif ) ; <S2SV_EndBug> if ( inet6_sk ( sk ) -> rxopt . all ) pingv6_ops . ip6_datagram_recv_ctl ( sk , msg , skb ) ; # endif } else { BUG ( ) ; } err = copied ; done : skb_free_datagram ( sk , skb ) ; out : pr_debug ( ""ping_recvmsg<S2SV_blank>-><S2SV_blank>%d\\n"" , err ) ; return err ; }
","<S2SV_ModStart> sk -> sk_family <S2SV_ModEnd> ; struct sk_buff <S2SV_ModStart> goto out ; <S2SV_ModEnd> if ( flags <S2SV_ModStart> AF_INET ) { struct sockaddr_in * <S2SV_ModStart> ) ) ; * addr_len = sizeof ( * sin ) ; <S2SV_ModStart> skb ) ; <S2SV_ModEnd> struct sockaddr_in6 * <S2SV_ModStart> struct sockaddr_in6 * sin6 = ( struct sockaddr_in6 * <S2SV_ModStart> ) -> iif ) ; * addr_len = sizeof ( * sin6
"
737,"CWE-119 int encode_msg ( struct sip_msg * msg , char * payload , int len ) { int i , j , k , u , request ; unsigned short int h ; struct hdr_field * hf ; struct msg_start * ms ; struct sip_uri miuri ; char * myerror = NULL ; ptrdiff_t diff ; if ( len < MAX_ENCODED_MSG + MAX_MESSAGE_LEN ) return - 1 ; if ( parse_headers ( msg , HDR_EOH_F , 0 ) < 0 ) { myerror = ""in<S2SV_blank>parse_headers"" ; goto error ; } memset ( payload , 0 , len ) ; ms = & msg -> first_line ; if ( ms -> type == SIP_REQUEST ) request = 1 ; else if ( ms -> type == SIP_REPLY ) request = 0 ; else { myerror = ""message<S2SV_blank>is<S2SV_blank>neither<S2SV_blank>request<S2SV_blank>nor<S2SV_blank>response"" ; goto error ; } if ( request ) { for ( h = 0 ; h < 32 ; j = ( 0x01 << h ) , h ++ ) if ( j & ms -> u . request . method_value ) break ; } else { h = ( unsigned short ) ( ms -> u . reply . statuscode ) ; } if ( h == 32 ) { myerror = ""unknown<S2SV_blank>message<S2SV_blank>type\\n"" ; goto error ; } h = htons ( h ) ; memcpy ( payload , & h , 2 ) ; h = htons ( ( unsigned short int ) msg -> len ) ; memcpy ( & payload [ MSG_LEN_IDX ] , & h , 2 ) ; if ( 0 > ( diff = ( get_body ( msg ) - ( msg -> buf ) ) ) ) { myerror = ""body<S2SV_blank>starts<S2SV_blank>before<S2SV_blank>the<S2SV_blank>message<S2SV_blank>(uh<S2SV_blank>?)"" ; goto error ; } else h = htons ( ( unsigned short int ) diff ) ; memcpy ( payload + CONTENT_IDX , & h , 2 ) ; payload [ METHOD_CODE_IDX ] = ( unsigned char ) ( request ? ( ms -> u . request . method . s - msg -> buf ) : ( ms -> u . reply . status . s - msg -> buf ) ) ; payload [ METHOD_CODE_IDX + 1 ] = ( unsigned char ) ( request ? ( ms -> u . request . method . len ) : ( ms -> u . reply . status . len ) ) ; payload [ URI_REASON_IDX ] = ( unsigned char ) ( request ? ( ms -> u . request . uri . s - msg -> buf ) : ( ms -> u . reply . reason . s - msg -> buf ) ) ; payload [ URI_REASON_IDX + 1 ] = ( unsigned char ) ( request ? ( ms -> u . request . uri . len ) : ( ms -> u . reply . reason . len ) ) ; payload [ VERSION_IDX ] = ( unsigned char ) ( request ? ( ms -> u . request . version . s - msg -> buf ) : ( ms -> u . reply . version . s - msg -> buf ) ) ; if ( request ) { if ( parse_uri ( ms -> u . request . uri . s , ms -> u . request . uri . len , & miuri ) < 0 ) { LM_ERR ( ""<%.*s>\\n"" , ms -> u . request . uri . len , ms -> u . request . uri . s ) ; myerror = ""while<S2SV_blank>parsing<S2SV_blank>the<S2SV_blank>R-URI"" ; goto error ; } if ( 0 > ( j = encode_uri2 ( msg -> buf , ms -> u . request . method . s - msg -> buf + ms -> len , ms -> u . request . uri , & miuri , ( unsigned char * ) & payload [ REQUEST_URI_IDX + 1 ] ) ) ) { myerror = ""ENCODE_MSG:<S2SV_blank>ERROR<S2SV_blank>while<S2SV_blank>encoding<S2SV_blank>the<S2SV_blank>R-URI"" ; goto error ; } payload [ REQUEST_URI_IDX ] = ( unsigned char ) j ; k = REQUEST_URI_IDX + 1 + j ; } else k = REQUEST_URI_IDX ; u = k ; k ++ ; for ( i = 0 , hf = msg -> headers ; hf ; hf = hf -> next , i ++ ) ; i ++ ; j = k + 3 * i ; for ( i = 0 , hf = msg -> headers ; hf ; hf = hf -> next , k += 3 ) { payload [ k ] = ( unsigned char ) ( hf -> type & 0xFF ) ; h = htons ( j ) ; memcpy ( & payload [ k + 1 ] , & h , 2 ) ; if ( 0 > ( i = encode_header ( msg , hf , ( unsigned char * ) ( payload + j ) , MAX_ENCODED_MSG + MAX_MESSAGE_LEN - j ) ) ) { LM_ERR ( ""encoding<S2SV_blank>header<S2SV_blank>%.*s\\n"" , hf -> name . len , hf -> name . s ) ; goto error ; k -= 3 ; continue ; } j += ( unsigned short int ) i ; } payload [ u ] = ( unsigned char ) ( ( k - u - 1 ) / 3 ) ; j = htons ( j ) ; memcpy ( & payload [ k + 1 ] , & j , 2 ) ; k += 3 ; j = ntohs ( j ) ; <S2SV_StartBug> memcpy ( & payload [ j ] , msg -> buf , msg -> len ) ; <S2SV_EndBug> LM_DBG ( ""msglen<S2SV_blank>=<S2SV_blank>%d,msg<S2SV_blank>starts<S2SV_blank>at<S2SV_blank>%d\\n"" , msg -> len , j ) ; j = htons ( j ) ; memcpy ( & payload [ MSG_START_IDX ] , & j , 2 ) ; return GET_PAY_SIZE ( payload ) ; error : LM_ERR ( ""%s\\n"" , myerror ) ; return - 1 ; }
","<S2SV_ModStart> j ) ; if ( len < j + msg -> len + 1 ) { LM_ERR ( ""not<S2SV_blank>enough<S2SV_blank>space<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>sip<S2SV_blank>message\\n"" ) ; return - 1 ; }
"
738,"CWE-88 static int fsck_gitmodules_fn ( const char * var , const char * value , void * vdata ) { struct fsck_gitmodules_data * data = vdata ; const char * subsection , * key ; int subsection_len ; char * name ; if ( parse_config_key ( var , ""submodule"" , & subsection , & subsection_len , & key ) < 0 || ! subsection ) return 0 ; name = xmemdupz ( subsection , subsection_len ) ; if ( check_submodule_name ( name ) < 0 ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_NAME , ""disallowed<S2SV_blank>submodule<S2SV_blank>name:<S2SV_blank>%s"" , name ) ; <S2SV_StartBug> free ( name ) ; <S2SV_EndBug> return 0 ; }
","<S2SV_ModStart> name ) ; if ( ! strcmp ( key , ""url"" ) && value && looks_like_command_line_option ( value ) ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_URL , ""disallowed<S2SV_blank>submodule<S2SV_blank>url:<S2SV_blank>%s"" , value ) ;
"
739,"CWE-189 struct timespec ns_to_timespec ( const s64 nsec ) { <S2SV_StartBug> struct timespec ts ; <S2SV_EndBug> if ( ! nsec ) return ( struct timespec ) { 0 , 0 } ; <S2SV_StartBug> ts . tv_sec = div_long_long_rem_signed ( nsec , NSEC_PER_SEC , & ts . tv_nsec ) ; <S2SV_EndBug> <S2SV_StartBug> if ( unlikely ( nsec < 0 ) ) <S2SV_EndBug> <S2SV_StartBug> set_normalized_timespec ( & ts , ts . tv_sec , ts . tv_nsec ) ; <S2SV_EndBug> return ts ; }
","<S2SV_ModStart> struct timespec ts ; s32 rem <S2SV_ModStart> . tv_sec = div_s64_rem <S2SV_ModEnd> ( nsec , <S2SV_ModStart> NSEC_PER_SEC , & rem <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( unlikely ( rem <S2SV_ModEnd> < 0 ) <S2SV_ModStart> 0 ) ) { <S2SV_ModEnd> ts . tv_sec <S2SV_ModStart> ts . tv_sec -- ; rem += NSEC_PER_SEC ; } <S2SV_ModEnd> ts . tv_nsec <S2SV_ModStart> ts . tv_nsec = rem <S2SV_ModEnd> ; return ts
"
740,"CWE-264 static inline int ip6_ufo_append_data ( struct sock * sk , int getfrag ( void * from , char * to , int offset , int len , int odd , struct sk_buff * skb ) , void * from , int length , int hh_len , int fragheaderlen , int transhdrlen , int mtu , unsigned int flags , struct rt6_info * rt ) { struct sk_buff * skb ; <S2SV_StartBug> int err ; <S2SV_EndBug> if ( ( skb = skb_peek_tail ( & sk -> sk_write_queue ) ) == NULL ) { <S2SV_StartBug> struct frag_hdr fhdr ; <S2SV_EndBug> skb = sock_alloc_send_skb ( sk , hh_len + fragheaderlen + transhdrlen + 20 , ( flags & MSG_DONTWAIT ) , & err ) ; if ( skb == NULL ) return err ; skb_reserve ( skb , hh_len ) ; skb_put ( skb , fragheaderlen + transhdrlen ) ; skb_reset_network_header ( skb ) ; skb -> transport_header = skb -> network_header + fragheaderlen ; skb -> protocol = htons ( ETH_P_IPV6 ) ; <S2SV_StartBug> skb -> ip_summed = CHECKSUM_PARTIAL ; <S2SV_EndBug> skb -> csum = 0 ; skb_shinfo ( skb ) -> gso_size = ( mtu - fragheaderlen - sizeof ( struct frag_hdr ) ) & ~ 7 ; skb_shinfo ( skb ) -> gso_type = SKB_GSO_UDP ; ipv6_select_ident ( & fhdr , rt ) ; skb_shinfo ( skb ) -> ip6_frag_id = fhdr . identification ; <S2SV_StartBug> __skb_queue_tail ( & sk -> sk_write_queue , skb ) ; <S2SV_EndBug> } return skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) ; }
","<S2SV_ModStart> * skb ; struct frag_hdr fhdr ; <S2SV_ModStart> NULL ) { <S2SV_ModEnd> skb = sock_alloc_send_skb <S2SV_ModStart> ; skb -> csum = 0 ; __skb_queue_tail ( & sk -> sk_write_queue , skb ) ; } else if ( skb_is_gso ( skb ) ) { goto append ; } skb -> <S2SV_ModStart> ip_summed = CHECKSUM_PARTIAL <S2SV_ModEnd> ; skb_shinfo ( <S2SV_ModStart> . identification ; append : <S2SV_ModEnd> return skb_append_datato_frags (
"
741,"CWE-352 static void doGet ( HttpRequest req , HttpResponse res ) { set_content_type ( res , ""text/html"" ) ; if ( ACTION ( HOME ) ) { LOCK ( Run . mutex ) do_home ( res ) ; END_LOCK ; <S2SV_StartBug> } else if ( ACTION ( RUN ) ) { <S2SV_EndBug> <S2SV_StartBug> handle_run ( req , res ) ; <S2SV_EndBug> } else if ( ACTION ( TEST ) ) { <S2SV_StartBug> is_monit_running ( res ) ; <S2SV_EndBug> } else if ( ACTION ( VIEWLOG ) ) { do_viewlog ( req , res ) ; } else if ( ACTION ( ABOUT ) ) { do_about ( res ) ; } else if ( ACTION ( FAVICON ) ) { printFavicon ( res ) ; } else if ( ACTION ( PING ) ) { do_ping ( res ) ; } else if ( ACTION ( GETID ) ) { do_getid ( res ) ; <S2SV_StartBug> } else if ( ACTION ( STATUS ) ) { <S2SV_EndBug> print_status ( req , res , 1 ) ; } else if ( ACTION ( STATUS2 ) ) { print_status ( req , res , 2 ) ; } else if ( ACTION ( SUMMARY ) ) { print_summary ( req , res ) ; } else if ( ACTION ( REPORT ) ) { _printReport ( req , res ) ; } else if ( ACTION ( DOACTION ) ) { handle_do_action ( req , res ) ; } else { handle_action ( req , res ) ; } }
","<S2SV_ModStart> ( ACTION ( RUNTIME <S2SV_ModEnd> ) ) { <S2SV_ModStart> ) ) { handle_runtime <S2SV_ModEnd> ( req , <S2SV_ModStart> { is_monit_running ( <S2SV_ModEnd> res ) ; <S2SV_ModStart> ; } else { handle_service <S2SV_ModEnd> ( req ,
"
742,"CWE-189 TSQuery QTN2QT ( QTNode * in ) { TSQuery out ; int len ; int sumlen = 0 , nnode = 0 ; QTN2QTState state ; <S2SV_StartBug> cntsize ( in , & sumlen , & nnode ) ; <S2SV_EndBug> len = COMPUTESIZE ( nnode , sumlen ) ; out = ( TSQuery ) palloc0 ( len ) ; SET_VARSIZE ( out , len ) ; out -> size = nnode ; state . curitem = GETQUERY ( out ) ; state . operand = state . curoperand = GETOPERAND ( out ) ; fillQT ( & state , in ) ; return out ; }
","<S2SV_ModStart> , & nnode ) ; if ( TSQUERY_TOO_BIG ( nnode , sumlen ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""tsquery<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large"" ) )
"
743,"CWE-125 static int rsvp_obj_print ( netdissect_options * ndo , const u_char * pptr , u_int plen , const u_char * tptr , const char * ident , u_int tlen , const struct rsvp_common_header * rsvp_com_header ) { const struct rsvp_object_header * rsvp_obj_header ; const u_char * obj_tptr ; union { const struct rsvp_obj_integrity_t * rsvp_obj_integrity ; const struct rsvp_obj_frr_t * rsvp_obj_frr ; } obj_ptr ; u_short rsvp_obj_len , rsvp_obj_ctype , obj_tlen , intserv_serv_tlen ; int hexdump , processed , padbytes , error_code , error_value , i , sigcheck ; union { float f ; uint32_t i ; } bw ; uint8_t namelen ; u_int action , subchannel ; while ( tlen >= sizeof ( struct rsvp_object_header ) ) { ND_TCHECK2 ( * tptr , sizeof ( struct rsvp_object_header ) ) ; rsvp_obj_header = ( const struct rsvp_object_header * ) tptr ; rsvp_obj_len = EXTRACT_16BITS ( rsvp_obj_header -> length ) ; rsvp_obj_ctype = rsvp_obj_header -> ctype ; if ( rsvp_obj_len % 4 ) { ND_PRINT ( ( ndo , ""%sERROR:<S2SV_blank>object<S2SV_blank>header<S2SV_blank>size<S2SV_blank>%u<S2SV_blank>not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4"" , ident , rsvp_obj_len ) ) ; return - 1 ; } if ( rsvp_obj_len < sizeof ( struct rsvp_object_header ) ) { ND_PRINT ( ( ndo , ""%sERROR:<S2SV_blank>object<S2SV_blank>header<S2SV_blank>too<S2SV_blank>short<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%lu"" , ident , rsvp_obj_len , ( unsigned long ) sizeof ( const struct rsvp_object_header ) ) ) ; return - 1 ; } ND_PRINT ( ( ndo , ""%s%s<S2SV_blank>Object<S2SV_blank>(%u)<S2SV_blank>Flags:<S2SV_blank>[%s"" , ident , tok2str ( rsvp_obj_values , ""Unknown"" , rsvp_obj_header -> class_num ) , rsvp_obj_header -> class_num , ( ( rsvp_obj_header -> class_num ) & 0x80 ) ? ""ignore"" : ""reject"" ) ) ; if ( rsvp_obj_header -> class_num > 128 ) ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , ( ( rsvp_obj_header -> class_num ) & 0x40 ) ? ""and<S2SV_blank>forward"" : ""silently"" ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>if<S2SV_blank>unknown],<S2SV_blank>Class-Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( rsvp_ctype_values , ""Unknown"" , ( ( rsvp_obj_header -> class_num ) << 8 ) + rsvp_obj_ctype ) , rsvp_obj_ctype , rsvp_obj_len ) ) ; if ( tlen < rsvp_obj_len ) { ND_PRINT ( ( ndo , ""%sERROR:<S2SV_blank>object<S2SV_blank>goes<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>objects<S2SV_blank>TLV"" , ident ) ) ; return - 1 ; } obj_tptr = tptr + sizeof ( struct rsvp_object_header ) ; obj_tlen = rsvp_obj_len - sizeof ( struct rsvp_object_header ) ; if ( ! ND_TTEST2 ( * tptr , rsvp_obj_len ) ) return - 1 ; hexdump = FALSE ; switch ( rsvp_obj_header -> class_num ) { case RSVP_OBJ_SESSION : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>DestAddress:<S2SV_blank>%s,<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>0x%02x"" , ident , ipaddr_string ( ndo , obj_tptr ) , * ( obj_tptr + sizeof ( struct in_addr ) ) ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[0x%02x],<S2SV_blank>DestPort<S2SV_blank>%u"" , ident , * ( obj_tptr + 5 ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>DestAddress:<S2SV_blank>%s,<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>0x%02x"" , ident , ip6addr_string ( ndo , obj_tptr ) , * ( obj_tptr + sizeof ( struct in6_addr ) ) ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[0x%02x],<S2SV_blank>DestPort<S2SV_blank>%u"" , ident , * ( obj_tptr + sizeof ( struct in6_addr ) + 1 ) , EXTRACT_16BITS ( obj_tptr + sizeof ( struct in6_addr ) + 2 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_TUNNEL_IPV6 : if ( obj_tlen < 36 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Tunnel<S2SV_blank>EndPoint:<S2SV_blank>%s,<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>0x%04x,<S2SV_blank>Extended<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>%s"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) , ip6addr_string ( ndo , obj_tptr + 20 ) ) ) ; obj_tlen -= 36 ; obj_tptr += 36 ; break ; case RSVP_CTYPE_14 : if ( obj_tlen < 26 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>P2MP<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>0x%08x,<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>0x%04x,<S2SV_blank>Extended<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>%s"" , ident , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ip6addr_string ( ndo , obj_tptr + 8 ) ) ) ; obj_tlen -= 26 ; obj_tptr += 26 ; break ; case RSVP_CTYPE_13 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>P2MP<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>%s,<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>0x%04x,<S2SV_blank>Extended<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>%s"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ipaddr_string ( ndo , obj_tptr + 8 ) ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; case RSVP_CTYPE_TUNNEL_IPV4 : case RSVP_CTYPE_UNI_IPV4 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Tunnel<S2SV_blank>EndPoint:<S2SV_blank>%s,<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>0x%04x,<S2SV_blank>Extended<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>%s"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ipaddr_string ( ndo , obj_tptr + 8 ) ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_CONFIRM : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < sizeof ( struct in_addr ) ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Receiver<S2SV_blank>Address:<S2SV_blank>%s"" , ident , ipaddr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= sizeof ( struct in_addr ) ; obj_tptr += sizeof ( struct in_addr ) ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < sizeof ( struct in6_addr ) ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Receiver<S2SV_blank>Address:<S2SV_blank>%s"" , ident , ip6addr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= sizeof ( struct in6_addr ) ; obj_tptr += sizeof ( struct in6_addr ) ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_NOTIFY_REQ : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < sizeof ( struct in_addr ) ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Notify<S2SV_blank>Node<S2SV_blank>Address:<S2SV_blank>%s"" , ident , ipaddr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= sizeof ( struct in_addr ) ; obj_tptr += sizeof ( struct in_addr ) ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < sizeof ( struct in6_addr ) ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Notify<S2SV_blank>Node<S2SV_blank>Address:<S2SV_blank>%s"" , ident , ip6addr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= sizeof ( struct in6_addr ) ; obj_tptr += sizeof ( struct in6_addr ) ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SUGGESTED_LABEL : case RSVP_OBJ_UPSTREAM_LABEL : case RSVP_OBJ_RECOVERY_LABEL : case RSVP_OBJ_LABEL : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : while ( obj_tlen >= 4 ) { ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Label:<S2SV_blank>%u"" , ident , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; } break ; case RSVP_CTYPE_2 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Generalized<S2SV_blank>Label:<S2SV_blank>%u"" , ident , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; case RSVP_CTYPE_3 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Waveband<S2SV_blank>ID:<S2SV_blank>%u%s<S2SV_blank><S2SV_blank>Start<S2SV_blank>Label:<S2SV_blank>%u,<S2SV_blank>Stop<S2SV_blank>Label:<S2SV_blank>%u"" , ident , EXTRACT_32BITS ( obj_tptr ) , ident , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_STYLE : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Reservation<S2SV_blank>Style:<S2SV_blank>%s,<S2SV_blank>Flags:<S2SV_blank>[0x%02x]"" , ident , tok2str ( rsvp_resstyle_values , ""Unknown"" , EXTRACT_24BITS ( obj_tptr + 1 ) ) , * ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SENDER_TEMPLATE : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Source<S2SV_blank>Port:<S2SV_blank>%u"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Source<S2SV_blank>Port:<S2SV_blank>%u"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_13 : if ( obj_tlen < 40 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Tunnel<S2SV_blank>Sender<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>0x%04x"" ""%s<S2SV_blank><S2SV_blank>Sub-Group<S2SV_blank>Originator<S2SV_blank>ID:<S2SV_blank>%s,<S2SV_blank>Sub-Group<S2SV_blank>ID:<S2SV_blank>0x%04x"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) , ident , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_16BITS ( obj_tptr + 38 ) ) ) ; obj_tlen -= 40 ; obj_tptr += 40 ; break ; case RSVP_CTYPE_TUNNEL_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Tunnel<S2SV_blank>Sender<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP-ID:<S2SV_blank>0x%04x"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_12 : if ( obj_tlen < 16 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Tunnel<S2SV_blank>Sender<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>0x%04x"" ""%s<S2SV_blank><S2SV_blank>Sub-Group<S2SV_blank>Originator<S2SV_blank>ID:<S2SV_blank>%s,<S2SV_blank>Sub-Group<S2SV_blank>ID:<S2SV_blank>0x%04x"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ident , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_16BITS ( obj_tptr + 12 ) ) ) ; obj_tlen -= 16 ; obj_tptr += 16 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_LABEL_REQ : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : while ( obj_tlen >= 4 ) { ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>L3<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>%s"" , ident , tok2str ( ethertype_values , ""Unknown<S2SV_blank>Protocol<S2SV_blank>(0x%04x)"" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; } break ; case RSVP_CTYPE_2 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>L3<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>%s"" , ident , tok2str ( ethertype_values , ""Unknown<S2SV_blank>Protocol<S2SV_blank>(0x%04x)"" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ) ; ND_PRINT ( ( ndo , "",%s<S2SV_blank>merge<S2SV_blank>capability"" , ( ( * ( obj_tptr + 4 ) ) & 0x80 ) ? ""no"" : """" ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Minimum<S2SV_blank>VPI/VCI:<S2SV_blank>%u/%u"" , ident , ( EXTRACT_16BITS ( obj_tptr + 4 ) ) & 0xfff , ( EXTRACT_16BITS ( obj_tptr + 6 ) ) & 0xfff ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Maximum<S2SV_blank>VPI/VCI:<S2SV_blank>%u/%u"" , ident , ( EXTRACT_16BITS ( obj_tptr + 8 ) ) & 0xfff , ( EXTRACT_16BITS ( obj_tptr + 10 ) ) & 0xfff ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; case RSVP_CTYPE_3 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>L3<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>%s"" , ident , tok2str ( ethertype_values , ""Unknown<S2SV_blank>Protocol<S2SV_blank>(0x%04x)"" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Minimum/Maximum<S2SV_blank>DLCI:<S2SV_blank>%u/%u,<S2SV_blank>%s%s<S2SV_blank>bit<S2SV_blank>DLCI"" , ident , ( EXTRACT_32BITS ( obj_tptr + 4 ) ) & 0x7fffff , ( EXTRACT_32BITS ( obj_tptr + 8 ) ) & 0x7fffff , ( ( ( EXTRACT_16BITS ( obj_tptr + 4 ) >> 7 ) & 3 ) == 0 ) ? ""10"" : """" , ( ( ( EXTRACT_16BITS ( obj_tptr + 4 ) >> 7 ) & 3 ) == 2 ) ? ""23"" : """" ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; case RSVP_CTYPE_4 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>LSP<S2SV_blank>Encoding<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)"" , ident , tok2str ( gmpls_encoding_values , ""Unknown"" , * obj_tptr ) , * obj_tptr ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Switching<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Payload<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%04x)"" , ident , tok2str ( gmpls_switch_cap_values , ""Unknown"" , * ( obj_tptr + 1 ) ) , * ( obj_tptr + 1 ) , tok2str ( gmpls_payload_values , ""Unknown"" , EXTRACT_16BITS ( obj_tptr + 2 ) ) , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_RRO : case RSVP_OBJ_ERO : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : while ( obj_tlen >= 4 ) { u_char length ; ND_TCHECK2 ( * obj_tptr , 4 ) ; length = * ( obj_tptr + 1 ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Subobject<S2SV_blank>Type:<S2SV_blank>%s,<S2SV_blank>length<S2SV_blank>%u"" , ident , tok2str ( rsvp_obj_xro_values , ""Unknown<S2SV_blank>%u"" , RSVP_OBJ_XRO_MASK_SUBOBJ ( * obj_tptr ) ) , length ) ) ; if ( length == 0 ) { ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>ERROR:<S2SV_blank>zero<S2SV_blank>length<S2SV_blank>ERO<S2SV_blank>subtype"" , ident ) ) ; break ; } switch ( RSVP_OBJ_XRO_MASK_SUBOBJ ( * obj_tptr ) ) { u_char prefix_length ; case RSVP_OBJ_XRO_IPV4 : if ( length != 8 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>ERROR:<S2SV_blank>length<S2SV_blank>!=<S2SV_blank>8"" ) ) ; goto invalid ; } ND_TCHECK2 ( * obj_tptr , 8 ) ; prefix_length = * ( obj_tptr + 6 ) ; if ( prefix_length != 32 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>ERROR:<S2SV_blank>Prefix<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>32"" , prefix_length ) ) ; goto invalid ; } ND_PRINT ( ( ndo , "",<S2SV_blank>%s,<S2SV_blank>%s/%u,<S2SV_blank>Flags:<S2SV_blank>[%s]"" , RSVP_OBJ_XRO_MASK_LOOSE ( * obj_tptr ) ? ""Loose"" : ""Strict"" , ipaddr_string ( ndo , obj_tptr + 2 ) , * ( obj_tptr + 6 ) , bittok2str ( rsvp_obj_rro_flag_values , ""none"" , * ( obj_tptr + 7 ) ) ) ) ; break ; case RSVP_OBJ_XRO_LABEL : if ( length != 8 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>ERROR:<S2SV_blank>length<S2SV_blank>!=<S2SV_blank>8"" ) ) ; goto invalid ; } ND_TCHECK2 ( * obj_tptr , 8 ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>Flags:<S2SV_blank>[%s]<S2SV_blank>(%#x),<S2SV_blank>Class-Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%u"" , bittok2str ( rsvp_obj_rro_label_flag_values , ""none"" , * ( obj_tptr + 2 ) ) , * ( obj_tptr + 2 ) , tok2str ( rsvp_ctype_values , ""Unknown"" , * ( obj_tptr + 3 ) + 256 * RSVP_OBJ_RRO ) , * ( obj_tptr + 3 ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; } obj_tlen -= * ( obj_tptr + 1 ) ; obj_tptr += * ( obj_tptr + 1 ) ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_HELLO : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : case RSVP_CTYPE_2 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Instance:<S2SV_blank>0x%08x,<S2SV_blank>Destination<S2SV_blank>Instance:<S2SV_blank>0x%08x"" , ident , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_RESTART_CAPABILITY : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Restart<S2SV_blank><S2SV_blank>Time:<S2SV_blank>%ums,<S2SV_blank>Recovery<S2SV_blank>Time:<S2SV_blank>%ums"" , ident , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SESSION_ATTRIBUTE : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_TUNNEL_IPV4 : if ( obj_tlen < 4 ) return - 1 ; namelen = * ( obj_tptr + 3 ) ; if ( obj_tlen < 4 + namelen ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Session<S2SV_blank>Name:<S2SV_blank>"" , ident ) ) ; for ( i = 0 ; i < namelen ; i ++ ) safeputchar ( ndo , * ( obj_tptr + 4 + i ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Setup<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Holding<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Flags:<S2SV_blank>[%s]<S2SV_blank>(%#x)"" , ident , ( int ) * obj_tptr , ( int ) * ( obj_tptr + 1 ) , bittok2str ( rsvp_session_attribute_flag_values , ""none"" , * ( obj_tptr + 2 ) ) , * ( obj_tptr + 2 ) ) ) ; obj_tlen -= 4 + * ( obj_tptr + 3 ) ; obj_tptr += 4 + * ( obj_tptr + 3 ) ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_GENERALIZED_UNI : switch ( rsvp_obj_ctype ) { int subobj_type , af , subobj_len , total_subobj_len ; case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; total_subobj_len = obj_tlen ; while ( total_subobj_len > 0 ) { <S2SV_StartBug> subobj_len = EXTRACT_16BITS ( obj_tptr ) ; <S2SV_EndBug> subobj_type = ( EXTRACT_16BITS ( obj_tptr + 2 ) ) >> 8 ; af = ( EXTRACT_16BITS ( obj_tptr + 2 ) ) & 0x00FF ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Subobject<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>AF:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u"" , ident , tok2str ( rsvp_obj_generalized_uni_values , ""Unknown"" , subobj_type ) , subobj_type , tok2str ( af_values , ""Unknown"" , af ) , af , subobj_len ) ) ; <S2SV_StartBug> if ( subobj_len == 0 ) <S2SV_EndBug> goto invalid ; switch ( subobj_type ) { case RSVP_GEN_UNI_SUBOBJ_SOURCE_TNA_ADDRESS : case RSVP_GEN_UNI_SUBOBJ_DESTINATION_TNA_ADDRESS : switch ( af ) { case AFNUM_INET : if ( subobj_len < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>UNI<S2SV_blank>IPv4<S2SV_blank>TNA<S2SV_blank>address:<S2SV_blank>%s"" , ident , ipaddr_string ( ndo , obj_tptr + 4 ) ) ) ; break ; case AFNUM_INET6 : if ( subobj_len < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>UNI<S2SV_blank>IPv6<S2SV_blank>TNA<S2SV_blank>address:<S2SV_blank>%s"" , ident , ip6addr_string ( ndo , obj_tptr + 4 ) ) ) ; break ; case AFNUM_NSAP : if ( subobj_len ) { hexdump = TRUE ; } break ; } break ; case RSVP_GEN_UNI_SUBOBJ_DIVERSITY : if ( subobj_len ) { hexdump = TRUE ; } break ; case RSVP_GEN_UNI_SUBOBJ_EGRESS_LABEL : if ( subobj_len < 16 ) { return - 1 ; } ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>U-bit:<S2SV_blank>%x,<S2SV_blank>Label<S2SV_blank>type:<S2SV_blank>%u,<S2SV_blank>Logical<S2SV_blank>port<S2SV_blank>id:<S2SV_blank>%u,<S2SV_blank>Label:<S2SV_blank>%u"" , ident , ( ( EXTRACT_32BITS ( obj_tptr + 4 ) ) >> 31 ) , ( ( EXTRACT_32BITS ( obj_tptr + 4 ) ) & 0xFF ) , EXTRACT_32BITS ( obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 12 ) ) ) ; break ; case RSVP_GEN_UNI_SUBOBJ_SERVICE_LEVEL : if ( subobj_len < 8 ) { return - 1 ; } ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Service<S2SV_blank>level:<S2SV_blank>%u"" , ident , ( EXTRACT_32BITS ( obj_tptr + 4 ) ) >> 24 ) ) ; break ; default : hexdump = TRUE ; break ; } total_subobj_len -= subobj_len ; obj_tptr += subobj_len ; obj_tlen += subobj_len ; } if ( total_subobj_len ) { hexdump = TRUE ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_RSVP_HOP : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_3 : case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Previous/Next<S2SV_blank>Interface:<S2SV_blank>%s,<S2SV_blank>Logical<S2SV_blank>Interface<S2SV_blank>Handle:<S2SV_blank>0x%08x"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; if ( obj_tlen ) hexdump = TRUE ; break ; case RSVP_CTYPE_4 : case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Previous/Next<S2SV_blank>Interface:<S2SV_blank>%s,<S2SV_blank>Logical<S2SV_blank>Interface<S2SV_blank>Handle:<S2SV_blank>0x%08x"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 16 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; hexdump = TRUE ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_TIME_VALUES : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Refresh<S2SV_blank>Period:<S2SV_blank>%ums"" , ident , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SENDER_TSPEC : case RSVP_OBJ_ADSPEC : case RSVP_OBJ_FLOWSPEC : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_2 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Msg-Version:<S2SV_blank>%u,<S2SV_blank>length:<S2SV_blank>%u"" , ident , ( * obj_tptr & 0xf0 ) >> 4 , EXTRACT_16BITS ( obj_tptr + 2 ) << 2 ) ) ; obj_tptr += 4 ; obj_tlen -= 4 ; while ( obj_tlen >= 4 ) { intserv_serv_tlen = EXTRACT_16BITS ( obj_tptr + 2 ) << 2 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Service<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>break<S2SV_blank>bit<S2SV_blank>%s<S2SV_blank>set,<S2SV_blank>Service<S2SV_blank>length:<S2SV_blank>%u"" , ident , tok2str ( rsvp_intserv_service_type_values , ""unknown"" , * ( obj_tptr ) ) , * ( obj_tptr ) , ( * ( obj_tptr + 1 ) & 0x80 ) ? """" : ""not"" , intserv_serv_tlen ) ) ; obj_tptr += 4 ; obj_tlen -= 4 ; while ( intserv_serv_tlen >= 4 ) { processed = rsvp_intserv_print ( ndo , obj_tptr , obj_tlen ) ; if ( processed == 0 ) break ; obj_tlen -= processed ; intserv_serv_tlen -= processed ; obj_tptr += processed ; } } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_FILTERSPEC : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Source<S2SV_blank>Port:<S2SV_blank>%u"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Source<S2SV_blank>Port:<S2SV_blank>%u"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_3 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Flow<S2SV_blank>Label:<S2SV_blank>%u"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_24BITS ( obj_tptr + 17 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_TUNNEL_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP-ID:<S2SV_blank>0x%04x"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_13 : if ( obj_tlen < 40 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Tunnel<S2SV_blank>Sender<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>0x%04x"" ""%s<S2SV_blank><S2SV_blank>Sub-Group<S2SV_blank>Originator<S2SV_blank>ID:<S2SV_blank>%s,<S2SV_blank>Sub-Group<S2SV_blank>ID:<S2SV_blank>0x%04x"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) , ident , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_16BITS ( obj_tptr + 38 ) ) ) ; obj_tlen -= 40 ; obj_tptr += 40 ; break ; case RSVP_CTYPE_TUNNEL_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP-ID:<S2SV_blank>0x%04x"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_12 : if ( obj_tlen < 16 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Tunnel<S2SV_blank>Sender<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>0x%04x"" ""%s<S2SV_blank><S2SV_blank>Sub-Group<S2SV_blank>Originator<S2SV_blank>ID:<S2SV_blank>%s,<S2SV_blank>Sub-Group<S2SV_blank>ID:<S2SV_blank>0x%04x"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ident , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_16BITS ( obj_tptr + 12 ) ) ) ; obj_tlen -= 16 ; obj_tptr += 16 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_FASTREROUTE : obj_ptr . rsvp_obj_frr = ( const struct rsvp_obj_frr_t * ) obj_tptr ; switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < sizeof ( struct rsvp_obj_frr_t ) ) return - 1 ; bw . i = EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Setup<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Holding<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Hop-limit:<S2SV_blank>%u,<S2SV_blank>Bandwidth:<S2SV_blank>%.10g<S2SV_blank>Mbps"" , ident , ( int ) obj_ptr . rsvp_obj_frr -> setup_prio , ( int ) obj_ptr . rsvp_obj_frr -> hold_prio , ( int ) obj_ptr . rsvp_obj_frr -> hop_limit , bw . f * 8 / 1000000 ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Include-any:<S2SV_blank>0x%08x,<S2SV_blank>Exclude-any:<S2SV_blank>0x%08x,<S2SV_blank>Include-all:<S2SV_blank>0x%08x"" , ident , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> include_any ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> exclude_any ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> include_all ) ) ) ; obj_tlen -= sizeof ( struct rsvp_obj_frr_t ) ; obj_tptr += sizeof ( struct rsvp_obj_frr_t ) ; break ; case RSVP_CTYPE_TUNNEL_IPV4 : if ( obj_tlen < 16 ) return - 1 ; bw . i = EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Setup<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Holding<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Hop-limit:<S2SV_blank>%u,<S2SV_blank>Bandwidth:<S2SV_blank>%.10g<S2SV_blank>Mbps"" , ident , ( int ) obj_ptr . rsvp_obj_frr -> setup_prio , ( int ) obj_ptr . rsvp_obj_frr -> hold_prio , ( int ) obj_ptr . rsvp_obj_frr -> hop_limit , bw . f * 8 / 1000000 ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Include<S2SV_blank>Colors:<S2SV_blank>0x%08x,<S2SV_blank>Exclude<S2SV_blank>Colors:<S2SV_blank>0x%08x"" , ident , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> include_any ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> exclude_any ) ) ) ; obj_tlen -= 16 ; obj_tptr += 16 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_DETOUR : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_TUNNEL_IPV4 : while ( obj_tlen >= 8 ) { ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>PLR-ID:<S2SV_blank>%s,<S2SV_blank>Avoid-Node-ID:<S2SV_blank>%s"" , ident , ipaddr_string ( ndo , obj_tptr ) , ipaddr_string ( ndo , obj_tptr + 4 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_CLASSTYPE : case RSVP_OBJ_CLASSTYPE_OLD : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>CT:<S2SV_blank>%u"" , ident , EXTRACT_32BITS ( obj_tptr ) & 0x7 ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_ERROR_SPEC : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_3 : case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; error_code = * ( obj_tptr + 5 ) ; error_value = EXTRACT_16BITS ( obj_tptr + 6 ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Error<S2SV_blank>Node<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Flags:<S2SV_blank>[0x%02x]%s<S2SV_blank><S2SV_blank>Error<S2SV_blank>Code:<S2SV_blank>%s<S2SV_blank>(%u)"" , ident , ipaddr_string ( ndo , obj_tptr ) , * ( obj_tptr + 4 ) , ident , tok2str ( rsvp_obj_error_code_values , ""unknown"" , error_code ) , error_code ) ) ; switch ( error_code ) { case RSVP_OBJ_ERROR_SPEC_CODE_ROUTING : ND_PRINT ( ( ndo , "",<S2SV_blank>Error<S2SV_blank>Value:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( rsvp_obj_error_code_routing_values , ""unknown"" , error_value ) , error_value ) ) ; break ; case RSVP_OBJ_ERROR_SPEC_CODE_DIFFSERV_TE : case RSVP_OBJ_ERROR_SPEC_CODE_DIFFSERV_TE_OLD : ND_PRINT ( ( ndo , "",<S2SV_blank>Error<S2SV_blank>Value:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( rsvp_obj_error_code_diffserv_te_values , ""unknown"" , error_value ) , error_value ) ) ; break ; default : ND_PRINT ( ( ndo , "",<S2SV_blank>Unknown<S2SV_blank>Error<S2SV_blank>Value<S2SV_blank>(%u)"" , error_value ) ) ; break ; } obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_4 : case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; error_code = * ( obj_tptr + 17 ) ; error_value = EXTRACT_16BITS ( obj_tptr + 18 ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Error<S2SV_blank>Node<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Flags:<S2SV_blank>[0x%02x]%s<S2SV_blank><S2SV_blank>Error<S2SV_blank>Code:<S2SV_blank>%s<S2SV_blank>(%u)"" , ident , ip6addr_string ( ndo , obj_tptr ) , * ( obj_tptr + 16 ) , ident , tok2str ( rsvp_obj_error_code_values , ""unknown"" , error_code ) , error_code ) ) ; switch ( error_code ) { case RSVP_OBJ_ERROR_SPEC_CODE_ROUTING : ND_PRINT ( ( ndo , "",<S2SV_blank>Error<S2SV_blank>Value:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( rsvp_obj_error_code_routing_values , ""unknown"" , error_value ) , error_value ) ) ; break ; default : break ; } obj_tlen -= 20 ; obj_tptr += 20 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_PROPERTIES : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; padbytes = EXTRACT_16BITS ( obj_tptr + 2 ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>TLV<S2SV_blank>count:<S2SV_blank>%u,<S2SV_blank>padding<S2SV_blank>bytes:<S2SV_blank>%u"" , ident , EXTRACT_16BITS ( obj_tptr ) , padbytes ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; while ( obj_tlen >= 2 + padbytes ) { ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>TLV<S2SV_blank>(0x%02x),<S2SV_blank>length:<S2SV_blank>%u"" , ident , tok2str ( rsvp_obj_prop_tlv_values , ""unknown"" , * obj_tptr ) , * obj_tptr , * ( obj_tptr + 1 ) ) ) ; if ( obj_tlen < * ( obj_tptr + 1 ) ) return - 1 ; if ( * ( obj_tptr + 1 ) < 2 ) return - 1 ; print_unknown_data ( ndo , obj_tptr + 2 , ""\\n\\t\\t"" , * ( obj_tptr + 1 ) - 2 ) ; obj_tlen -= * ( obj_tptr + 1 ) ; obj_tptr += * ( obj_tptr + 1 ) ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_MESSAGE_ID : case RSVP_OBJ_MESSAGE_ID_ACK : case RSVP_OBJ_MESSAGE_ID_LIST : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : case RSVP_CTYPE_2 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Flags<S2SV_blank>[0x%02x],<S2SV_blank>epoch:<S2SV_blank>%u"" , ident , * obj_tptr , EXTRACT_24BITS ( obj_tptr + 1 ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; while ( obj_tlen >= 4 ) { ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Message-ID<S2SV_blank>0x%08x<S2SV_blank>(%u)"" , ident , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_INTEGRITY : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < sizeof ( struct rsvp_obj_integrity_t ) ) return - 1 ; obj_ptr . rsvp_obj_integrity = ( const struct rsvp_obj_integrity_t * ) obj_tptr ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Key-ID<S2SV_blank>0x%04x%08x,<S2SV_blank>Sequence<S2SV_blank>0x%08x%08x,<S2SV_blank>Flags<S2SV_blank>[%s]"" , ident , EXTRACT_16BITS ( obj_ptr . rsvp_obj_integrity -> key_id ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> key_id + 2 ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> sequence ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> sequence + 4 ) , bittok2str ( rsvp_obj_integrity_flag_values , ""none"" , obj_ptr . rsvp_obj_integrity -> flags ) ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>MD5-sum<S2SV_blank>0x%08x%08x%08x%08x<S2SV_blank>"" , ident , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> digest ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> digest + 4 ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> digest + 8 ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> digest + 12 ) ) ) ; sigcheck = signature_verify ( ndo , pptr , plen , obj_ptr . rsvp_obj_integrity -> digest , rsvp_clear_checksum , rsvp_com_header ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>(%s)"" , tok2str ( signature_check_values , ""Unknown"" , sigcheck ) ) ) ; obj_tlen += sizeof ( struct rsvp_obj_integrity_t ) ; obj_tptr += sizeof ( struct rsvp_obj_integrity_t ) ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_ADMIN_STATUS : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Flags<S2SV_blank>[%s]"" , ident , bittok2str ( rsvp_obj_admin_status_flag_values , ""none"" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_LABEL_SET : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; action = ( EXTRACT_16BITS ( obj_tptr ) >> 8 ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Action:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Label<S2SV_blank>type:<S2SV_blank>%u"" , ident , tok2str ( rsvp_obj_label_set_action_values , ""Unknown"" , action ) , action , ( ( EXTRACT_32BITS ( obj_tptr ) & 0x7F ) ) ) ) ; switch ( action ) { case LABEL_SET_INCLUSIVE_RANGE : case LABEL_SET_EXCLUSIVE_RANGE : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Start<S2SV_blank>range:<S2SV_blank>%u,<S2SV_blank>End<S2SV_blank>range:<S2SV_blank>%u"" , ident , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; default : obj_tlen -= 4 ; obj_tptr += 4 ; subchannel = 1 ; while ( obj_tlen >= 4 ) { ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Subchannel<S2SV_blank>#%u:<S2SV_blank>%u"" , ident , subchannel , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tptr += 4 ; obj_tlen -= 4 ; subchannel ++ ; } break ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_S2L : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Sub-LSP<S2SV_blank>destination<S2SV_blank>address:<S2SV_blank>%s"" , ident , ipaddr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < 16 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Sub-LSP<S2SV_blank>destination<S2SV_blank>address:<S2SV_blank>%s"" , ident , ip6addr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= 16 ; obj_tptr += 16 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SCOPE : case RSVP_OBJ_POLICY_DATA : case RSVP_OBJ_ACCEPT_LABEL_SET : case RSVP_OBJ_PROTECTION : default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , obj_tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , obj_tlen ) ; break ; } if ( ndo -> ndo_vflag > 1 || hexdump == TRUE ) print_unknown_data ( ndo , tptr + sizeof ( struct rsvp_object_header ) , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , rsvp_obj_len - sizeof ( struct rsvp_object_header ) ) ; tptr += rsvp_obj_len ; tlen -= rsvp_obj_len ; } return 0 ; invalid : ND_PRINT ( ( ndo , ""%s"" , istr ) ) ; return - 1 ; trunc : ND_PRINT ( ( ndo , ""\\n\\t\\t"" ) ) ; ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return - 1 ; }
","<S2SV_ModStart> 0 ) { if ( total_subobj_len < 4 ) goto invalid ; <S2SV_ModStart> if ( subobj_len < 4 || subobj_len > total_subobj_len <S2SV_ModEnd> ) goto invalid
"
744,"CWE-787 static OPJ_BOOL opj_j2k_write_sod ( opj_j2k_t * p_j2k , opj_tcd_t * p_tile_coder , OPJ_BYTE * p_data , OPJ_UINT32 * p_data_written , OPJ_UINT32 p_total_data_size , const opj_stream_private_t * p_stream , opj_event_mgr_t * p_manager ) { opj_codestream_info_t * l_cstr_info = 00 ; OPJ_UINT32 l_remaining_data ; assert ( p_j2k != 00 ) ; assert ( p_manager != 00 ) ; assert ( p_stream != 00 ) ; OPJ_UNUSED ( p_stream ) ; <S2SV_StartBug> opj_write_bytes ( p_data , J2K_MS_SOD , <S2SV_EndBug> 2 ) ; p_data += 2 ; l_remaining_data = p_total_data_size - 4 ; p_tile_coder -> tp_num = p_j2k -> m_specific_param . m_encoder . m_current_poc_tile_part_number ; p_tile_coder -> cur_tp_num = p_j2k -> m_specific_param . m_encoder . m_current_tile_part_number ; # ifdef USE_JPWL assert ( 0 && ""TODO"" ) ; # endif if ( p_j2k -> m_specific_param . m_encoder . m_current_tile_part_number == 0 ) { p_tile_coder -> tcd_image -> tiles -> packno = 0 ; if ( l_cstr_info ) { l_cstr_info -> packno = 0 ; } } * p_data_written = 0 ; if ( ! opj_tcd_encode_tile ( p_tile_coder , p_j2k -> m_current_tile_number , p_data , p_data_written , l_remaining_data , l_cstr_info , p_manager ) ) { opj_event_msg ( p_manager , EVT_ERROR , ""Cannot<S2SV_blank>encode<S2SV_blank>tile\\n"" ) ; return OPJ_FALSE ; } * p_data_written += 2 ; return OPJ_TRUE ; }
","<S2SV_ModStart> p_stream ) ; if ( p_total_data_size < 4 ) { opj_event_msg ( p_manager , EVT_ERROR , ""Not<S2SV_blank>enough<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>output<S2SV_blank>buffer<S2SV_blank>to<S2SV_blank>write<S2SV_blank>SOD<S2SV_blank>marker\\n"" ) ; return OPJ_FALSE ; }
"
745,"CWE-476 static int i8042_start ( struct serio * serio ) { struct i8042_port * port = serio -> port_data ; <S2SV_StartBug> port -> exists = true ; <S2SV_EndBug> <S2SV_StartBug> mb ( ) ; <S2SV_EndBug> return 0 ; }
","<S2SV_ModStart> -> port_data ; spin_lock_irq ( & i8042_lock ) ; <S2SV_ModStart> = true ; spin_unlock_irq ( & i8042_lock <S2SV_ModEnd> ) ; return
"
746,"CWE-20 int read_xattrs_from_disk ( int fd , struct squashfs_super_block * sBlk , int flag , long long * table_start ) { <S2SV_StartBug> int res , bytes , i , indexes , index_bytes , ids ; <S2SV_EndBug> long long * index , start , end ; struct squashfs_xattr_table id_table ; TRACE ( ""read_xattrs_from_disk\\n"" ) ; if ( sBlk -> xattr_id_table_start == SQUASHFS_INVALID_BLK ) return SQUASHFS_INVALID_BLK ; res = read_fs_bytes ( fd , sBlk -> xattr_id_table_start , sizeof ( id_table ) , & id_table ) ; if ( res == 0 ) return 0 ; SQUASHFS_INSWAP_XATTR_TABLE ( & id_table ) ; <S2SV_StartBug> if ( flag ) { <S2SV_EndBug> * table_start = id_table . xattr_table_start ; <S2SV_StartBug> return id_table . xattr_ids ; <S2SV_EndBug> } ids = id_table . xattr_ids ; xattr_table_start = id_table . xattr_table_start ; index_bytes = SQUASHFS_XATTR_BLOCK_BYTES ( ids ) ; indexes = SQUASHFS_XATTR_BLOCKS ( ids ) ; index = malloc ( index_bytes ) ; if ( index == NULL ) MEM_ERROR ( ) ; <S2SV_StartBug> res = read_fs_bytes ( fd , sBlk -> xattr_id_table_start + sizeof ( id_table ) , <S2SV_EndBug> index_bytes , index ) ; if ( res == 0 ) goto failed1 ; SQUASHFS_INSWAP_LONG_LONGS ( index , indexes ) ; <S2SV_StartBug> bytes = SQUASHFS_XATTR_BYTES ( ids ) ; <S2SV_EndBug> xattr_ids = malloc ( bytes ) ; if ( xattr_ids == NULL ) MEM_ERROR ( ) ; for ( i = 0 ; i < indexes ; i ++ ) { int expected = ( i + 1 ) != indexes ? SQUASHFS_METADATA_SIZE : bytes & ( SQUASHFS_METADATA_SIZE - 1 ) ; int length = read_block ( fd , index [ i ] , NULL , expected , ( ( unsigned char * ) xattr_ids ) + <S2SV_StartBug> ( i * SQUASHFS_METADATA_SIZE ) ) ; <S2SV_EndBug> TRACE ( ""Read<S2SV_blank>xattr<S2SV_blank>id<S2SV_blank>table<S2SV_blank>block<S2SV_blank>%d,<S2SV_blank>from<S2SV_blank>0x%llx,<S2SV_blank>length<S2SV_blank>"" ""%d\\n"" , i , index [ i ] , length ) ; if ( length == 0 ) { ERROR ( ""Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>xattr<S2SV_blank>id<S2SV_blank>table<S2SV_blank>block<S2SV_blank>%d,<S2SV_blank>"" ""from<S2SV_blank>0x%llx,<S2SV_blank>length<S2SV_blank>%d\\n"" , i , index [ i ] , length ) ; goto failed2 ; } } start = xattr_table_start ; end = index [ 0 ] ; for ( i = 0 ; start < end ; i ++ ) { int length ; xattrs = realloc ( xattrs , ( i + 1 ) * SQUASHFS_METADATA_SIZE ) ; if ( xattrs == NULL ) MEM_ERROR ( ) ; save_xattr_block ( start , i * SQUASHFS_METADATA_SIZE ) ; length = read_block ( fd , start , & start , 0 , ( ( unsigned char * ) xattrs ) + ( i * SQUASHFS_METADATA_SIZE ) ) ; TRACE ( ""Read<S2SV_blank>xattr<S2SV_blank>block<S2SV_blank>%d,<S2SV_blank>length<S2SV_blank>%d\\n"" , i , length ) ; if ( length == 0 ) { ERROR ( ""Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>xattr<S2SV_blank>block<S2SV_blank>%d\\n"" , i ) ; goto failed3 ; } if ( start != end && length != SQUASHFS_METADATA_SIZE ) { ERROR ( ""Xattr<S2SV_blank>block<S2SV_blank>%d<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>length,<S2SV_blank>"" ""it<S2SV_blank>is<S2SV_blank>%d<S2SV_blank>bytes\\n"" , i , SQUASHFS_METADATA_SIZE , length ) ; goto failed3 ; } } for ( i = 0 ; i < ids ; i ++ ) SQUASHFS_INSWAP_XATTR_ID ( & xattr_ids [ i ] ) ; free ( index ) ; return ids ; failed3 : free ( xattrs ) ; failed2 : free ( xattr_ids ) ; failed1 : free ( index ) ; return 0 ; }
","<S2SV_ModStart> int res , i , indexes , index_bytes ; unsigned int ids ; long long bytes <S2SV_ModEnd> ; long long <S2SV_ModStart> id_table ) ; ids = id_table . xattr_ids ; xattr_table_start <S2SV_ModEnd> = id_table . <S2SV_ModStart> . xattr_table_start ; index_bytes = SQUASHFS_XATTR_BLOCK_BYTES ( ( long long ) ids ) ; indexes = SQUASHFS_XATTR_BLOCKS ( ( long long ) ids ) ; if ( index_bytes != ( sBlk -> bytes_used - ( <S2SV_ModEnd> sBlk -> xattr_id_table_start <S2SV_ModStart> ( id_table ) ) ) ) { ERROR ( ""read_xattrs_from_disk:<S2SV_blank>Bad<S2SV_blank>xattr_ids<S2SV_blank>count<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; return 0 ; } if ( table_start != NULL ) * table_start = id_table . xattr_table_start ; if ( flag ) return id_table . xattr_ids ; index = malloc ( index_bytes ) ; if ( index == NULL ) MEM_ERROR ( ) ; res = read_fs_bytes ( fd , sBlk -> xattr_id_table_start + sizeof ( id_table ) <S2SV_ModStart> = SQUASHFS_XATTR_BYTES ( ( long long ) <S2SV_ModStart> ) + ( ( long long )
"
747,"CWE-125 u_int mfr_print ( netdissect_options * ndo , register const u_char * p , u_int length ) { u_int tlen , idx , hdr_len = 0 ; uint16_t sequence_num ; uint8_t ie_type , ie_len ; const uint8_t * tptr ; ND_TCHECK2 ( * p , 4 ) ; if ( ( p [ 0 ] & MFR_BEC_MASK ) == MFR_CTRL_FRAME && p [ 1 ] == 0 ) { ND_PRINT ( ( ndo , ""FRF.16<S2SV_blank>Control,<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>%s,<S2SV_blank>length<S2SV_blank>%u"" , bittok2str ( frf_flag_values , ""none"" , ( p [ 0 ] & MFR_BEC_MASK ) ) , tok2str ( mfr_ctrl_msg_values , ""Unknown<S2SV_blank>Message<S2SV_blank>(0x%02x)"" , p [ 2 ] ) , length ) ) ; tptr = p + 3 ; tlen = length - 3 ; hdr_len = 3 ; if ( ! ndo -> ndo_vflag ) return hdr_len ; while ( tlen > sizeof ( struct ie_tlv_header_t ) ) { ND_TCHECK2 ( * tptr , sizeof ( struct ie_tlv_header_t ) ) ; ie_type = tptr [ 0 ] ; ie_len = tptr [ 1 ] ; ND_PRINT ( ( ndo , ""\\n\\tIE<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length<S2SV_blank>%u:<S2SV_blank>"" , tok2str ( mfr_ctrl_ie_values , ""Unknown"" , ie_type ) , ie_type , ie_len ) ) ; if ( ie_type == 0 || ie_len <= sizeof ( struct ie_tlv_header_t ) ) return hdr_len ; ND_TCHECK2 ( * tptr , ie_len ) ; tptr += sizeof ( struct ie_tlv_header_t ) ; ie_len -= sizeof ( struct ie_tlv_header_t ) ; tlen -= sizeof ( struct ie_tlv_header_t ) ; switch ( ie_type ) { <S2SV_StartBug> case MFR_CTRL_IE_MAGIC_NUM : <S2SV_EndBug> ND_PRINT ( ( ndo , ""0x%08x"" , EXTRACT_32BITS ( tptr ) ) ) ; break ; case MFR_CTRL_IE_BUNDLE_ID : case MFR_CTRL_IE_LINK_ID : for ( idx = 0 ; idx < ie_len && idx < MFR_ID_STRING_MAXLEN ; idx ++ ) { if ( * ( tptr + idx ) != 0 ) safeputchar ( ndo , * ( tptr + idx ) ) ; else break ; } break ; case MFR_CTRL_IE_TIMESTAMP : if ( ie_len == sizeof ( struct timeval ) ) { ts_print ( ndo , ( const struct timeval * ) tptr ) ; break ; } case MFR_CTRL_IE_VENDOR_EXT : case MFR_CTRL_IE_CAUSE : default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank>"" , ie_len ) ; break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank>"" , ie_len ) ; tlen -= ie_len ; tptr += ie_len ; } return hdr_len ; } sequence_num = ( p [ 0 ] & 0x1e ) << 7 | p [ 1 ] ; if ( ( p [ 0 ] & MFR_BEC_MASK ) == MFR_FRAG_FRAME || ( p [ 0 ] & MFR_BEC_MASK ) == MFR_B_BIT ) { ND_PRINT ( ( ndo , ""FRF.16<S2SV_blank>Frag,<S2SV_blank>seq<S2SV_blank>%u,<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>"" , sequence_num , bittok2str ( frf_flag_values , ""none"" , ( p [ 0 ] & MFR_BEC_MASK ) ) ) ) ; hdr_len = 2 ; fr_print ( ndo , p + hdr_len , length - hdr_len ) ; return hdr_len ; } ND_PRINT ( ( ndo , ""FRF.16<S2SV_blank>Frag,<S2SV_blank>seq<S2SV_blank>%u,<S2SV_blank>Flags<S2SV_blank>[%s]"" , sequence_num , bittok2str ( frf_flag_values , ""none"" , ( p [ 0 ] & MFR_BEC_MASK ) ) ) ) ; print_unknown_data ( ndo , p , ""\\n\\t"" , length ) ; return hdr_len ; trunc : ND_PRINT ( ( ndo , ""[|mfr]"" ) ) ; return length ; }
","<S2SV_ModStart> case MFR_CTRL_IE_MAGIC_NUM : if ( ie_len != 4 ) { ND_PRINT ( ( ndo , ""(invalid<S2SV_blank>length)"" ) ) ; break ; }
"
748,"CWE-125 static stmt_ty ast_for_async_stmt ( struct compiling * c , const node * n ) { REQ ( n , async_stmt ) ; <S2SV_StartBug> REQ ( CHILD ( n , 0 ) , ASYNC ) ; <S2SV_EndBug> switch ( TYPE ( CHILD ( n , 1 ) ) ) { case funcdef : <S2SV_StartBug> return ast_for_funcdef_impl ( c , CHILD ( n , 1 ) , NULL , <S2SV_EndBug> <S2SV_StartBug> 1 ) ; <S2SV_EndBug> case with_stmt : <S2SV_StartBug> return ast_for_with_stmt ( c , CHILD ( n , 1 ) , <S2SV_EndBug> 1 ) ; case for_stmt : <S2SV_StartBug> return ast_for_for_stmt ( c , CHILD ( n , 1 ) , <S2SV_EndBug> 1 ) ; default : PyErr_Format ( PyExc_SystemError , ""invalid<S2SV_blank>async<S2SV_blank>stament:<S2SV_blank>%s"" , STR ( CHILD ( n , 1 ) ) ) ; return NULL ; } }
","<S2SV_ModStart> 0 ) , NAME ) ; assert ( strcmp ( STR ( CHILD ( n , 0 ) ) , ""async"" ) == 0 <S2SV_ModEnd> ) ; switch <S2SV_ModStart> ( c , n <S2SV_ModEnd> , NULL , <S2SV_ModStart> , NULL , true <S2SV_ModEnd> ) ; case <S2SV_ModStart> ( c , n , true <S2SV_ModEnd> ) ; case <S2SV_ModStart> ( c , n , true <S2SV_ModEnd> ) ; default
"
749,"CWE-415 static Image * ReadTGAImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; PixelInfo pixel ; Quantum index ; register Quantum * q ; register ssize_t i , x ; size_t base , flag , offset , real , skip ; ssize_t count , y ; TGAInfo tga_info ; unsigned char j , k , pixels [ 4 ] , runlength ; unsigned int alpha_bits ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } count = ReadBlob ( image , 1 , & tga_info . id_length ) ; tga_info . colormap_type = ( unsigned char ) ReadBlobByte ( image ) ; tga_info . image_type = ( TGAImageType ) ReadBlobByte ( image ) ; if ( ( count != 1 ) || ( ( tga_info . image_type != TGAColormap ) && ( tga_info . image_type != TGARGB ) && ( tga_info . image_type != TGAMonochrome ) && ( tga_info . image_type != TGARLEColormap ) && ( tga_info . image_type != TGARLERGB ) && ( tga_info . image_type != TGARLEMonochrome ) ) || ( ( ( tga_info . image_type == TGAColormap ) || ( tga_info . image_type == TGARLEColormap ) ) && ( tga_info . colormap_type == 0 ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; tga_info . colormap_index = ReadBlobLSBShort ( image ) ; tga_info . colormap_length = ReadBlobLSBShort ( image ) ; tga_info . colormap_size = ( unsigned char ) ReadBlobByte ( image ) ; tga_info . x_origin = ReadBlobLSBShort ( image ) ; tga_info . y_origin = ReadBlobLSBShort ( image ) ; tga_info . width = ( unsigned short ) ReadBlobLSBShort ( image ) ; tga_info . height = ( unsigned short ) ReadBlobLSBShort ( image ) ; tga_info . bits_per_pixel = ( unsigned char ) ReadBlobByte ( image ) ; tga_info . attributes = ( unsigned char ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; if ( ( ( ( tga_info . bits_per_pixel <= 1 ) || ( tga_info . bits_per_pixel >= 17 ) ) && ( tga_info . bits_per_pixel != 24 ) && ( tga_info . bits_per_pixel != 32 ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> columns = tga_info . width ; image -> rows = tga_info . height ; alpha_bits = ( tga_info . attributes & 0x0FU ) ; image -> alpha_trait = ( alpha_bits > 0 ) || ( tga_info . bits_per_pixel == 32 ) || ( tga_info . colormap_size == 32 ) ? BlendPixelTrait : UndefinedPixelTrait ; if ( ( tga_info . image_type != TGAColormap ) && ( tga_info . image_type != TGARLEColormap ) ) image -> depth = ( size_t ) ( ( tga_info . bits_per_pixel <= 8 ) ? 8 : ( tga_info . bits_per_pixel <= 16 ) ? 5 : ( tga_info . bits_per_pixel == 24 ) ? 8 : ( tga_info . bits_per_pixel == 32 ) ? 8 : 8 ) ; else image -> depth = ( size_t ) ( ( tga_info . colormap_size <= 8 ) ? 8 : ( tga_info . colormap_size <= 16 ) ? 5 : ( tga_info . colormap_size == 24 ) ? 8 : ( tga_info . colormap_size == 32 ) ? 8 : 8 ) ; if ( ( tga_info . image_type == TGAColormap ) || ( tga_info . image_type == TGAMonochrome ) || ( tga_info . image_type == TGARLEColormap ) || ( tga_info . image_type == TGARLEMonochrome ) ) image -> storage_class = PseudoClass ; image -> compression = NoCompression ; if ( ( tga_info . image_type == TGARLEColormap ) || ( tga_info . image_type == TGARLEMonochrome ) || ( tga_info . image_type == TGARLERGB ) ) image -> compression = RLECompression ; if ( image -> storage_class == PseudoClass ) { if ( tga_info . colormap_type != 0 ) image -> colors = tga_info . colormap_index + tga_info . colormap_length ; else { size_t one ; one = 1 ; image -> colors = one << tga_info . bits_per_pixel ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } } if ( tga_info . id_length != 0 ) { char * comment ; size_t length ; length = ( size_t ) tga_info . id_length ; comment = ( char * ) NULL ; if ( ~ length >= ( MagickPathExtent - 1 ) ) comment = ( char * ) AcquireQuantumMemory ( length + MagickPathExtent , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , tga_info . id_length , ( unsigned char * ) comment ) ; comment [ tga_info . id_length ] = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment , exception ) ; comment = DestroyString ( comment ) ; } if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( image ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; ( void ) ResetMagickMemory ( & pixel , 0 , sizeof ( pixel ) ) ; pixel . alpha = ( MagickRealType ) OpaqueAlpha ; if ( tga_info . colormap_type != 0 ) <S2SV_StartBug> { <S2SV_EndBug> if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) tga_info . colormap_index ; i ++ ) image -> colormap [ i ] = pixel ; for ( ; i < ( ssize_t ) image -> colors ; i ++ ) { switch ( tga_info . colormap_size ) { case 8 : default : { pixel . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; pixel . green = pixel . red ; pixel . blue = pixel . red ; break ; } case 15 : case 16 : { QuantumAny range ; j = ( unsigned char ) ReadBlobByte ( image ) ; k = ( unsigned char ) ReadBlobByte ( image ) ; range = GetQuantumRange ( 5UL ) ; pixel . red = ( MagickRealType ) ScaleAnyToQuantum ( 1UL * ( k & 0x7c ) >> 2 , range ) ; pixel . green = ( MagickRealType ) ScaleAnyToQuantum ( ( 1UL * ( k & 0x03 ) << 3 ) + ( 1UL * ( j & 0xe0 ) >> 5 ) , range ) ; pixel . blue = ( MagickRealType ) ScaleAnyToQuantum ( 1UL * ( j & 0x1f ) , range ) ; break ; } case 24 : { pixel . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; pixel . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; pixel . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; break ; } case 32 : { pixel . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; pixel . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; pixel . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; pixel . alpha = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; break ; } } image -> colormap [ i ] = pixel ; } } base = 0 ; flag = 0 ; skip = MagickFalse ; real = 0 ; index = 0 ; runlength = 0 ; offset = 0 ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { real = offset ; if ( ( ( unsigned char ) ( tga_info . attributes & 0x20 ) >> 5 ) == 0 ) real = image -> rows - real - 1 ; q = QueueAuthenticPixels ( image , 0 , ( ssize_t ) real , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( ( tga_info . image_type == TGARLEColormap ) || ( tga_info . image_type == TGARLERGB ) || ( tga_info . image_type == TGARLEMonochrome ) ) { if ( runlength != 0 ) { runlength -- ; skip = flag != 0 ; } else { count = ReadBlob ( image , 1 , & runlength ) ; if ( count != 1 ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; flag = runlength & 0x80 ; if ( flag != 0 ) runlength -= 128 ; skip = MagickFalse ; } } if ( skip == MagickFalse ) switch ( tga_info . bits_per_pixel ) { case 8 : default : { index = ( Quantum ) ReadBlobByte ( image ) ; if ( tga_info . colormap_type != 0 ) pixel = image -> colormap [ ( ssize_t ) ConstrainColormapIndex ( image , ( ssize_t ) index , exception ) ] ; else { pixel . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) index ) ; pixel . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) index ) ; pixel . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) index ) ; } break ; } case 15 : case 16 : { QuantumAny range ; if ( ReadBlob ( image , 2 , pixels ) != 2 ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; j = pixels [ 0 ] ; k = pixels [ 1 ] ; range = GetQuantumRange ( 5UL ) ; pixel . red = ( MagickRealType ) ScaleAnyToQuantum ( 1UL * ( k & 0x7c ) >> 2 , range ) ; pixel . green = ( MagickRealType ) ScaleAnyToQuantum ( ( 1UL * ( k & 0x03 ) << 3 ) + ( 1UL * ( j & 0xe0 ) >> 5 ) , range ) ; pixel . blue = ( MagickRealType ) ScaleAnyToQuantum ( 1UL * ( j & 0x1f ) , range ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) pixel . alpha = ( MagickRealType ) ( ( k & 0x80 ) == 0 ? ( Quantum ) TransparentAlpha : ( Quantum ) OpaqueAlpha ) ; if ( image -> storage_class == PseudoClass ) index = ( Quantum ) ConstrainColormapIndex ( image , ( ( ssize_t ) ( k << 8 ) ) + j , exception ) ; break ; } case 24 : { if ( ReadBlob ( image , 3 , pixels ) != 3 ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; pixel . blue = ( MagickRealType ) ScaleCharToQuantum ( pixels [ 0 ] ) ; pixel . green = ( MagickRealType ) ScaleCharToQuantum ( pixels [ 1 ] ) ; pixel . red = ( MagickRealType ) ScaleCharToQuantum ( pixels [ 2 ] ) ; break ; } case 32 : { if ( ReadBlob ( image , 4 , pixels ) != 4 ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; pixel . blue = ( MagickRealType ) ScaleCharToQuantum ( pixels [ 0 ] ) ; pixel . green = ( MagickRealType ) ScaleCharToQuantum ( pixels [ 1 ] ) ; pixel . red = ( MagickRealType ) ScaleCharToQuantum ( pixels [ 2 ] ) ; pixel . alpha = ( MagickRealType ) ScaleCharToQuantum ( pixels [ 3 ] ) ; break ; } } if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; if ( image -> storage_class == PseudoClass ) SetPixelIndex ( image , index , q ) ; SetPixelRed ( image , ClampToQuantum ( pixel . red ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( pixel . green ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( pixel . blue ) , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ClampToQuantum ( pixel . alpha ) , q ) ; q += GetPixelChannels ( image ) ; } if ( ( ( unsigned char ) ( tga_info . attributes & 0xc0 ) >> 6 ) == 2 ) offset += 2 ; else offset ++ ; if ( offset >= image -> rows ) { base ++ ; offset = base ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> 0 ) { if ( image -> colors < tga_info . colormap_index ) image -> colors = tga_info . colormap_index ;
"
750,"CWE-399 static Image * ReadVIFFImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define VFF_CM_genericRGB 15 # define VFF_CM_ntscRGB 1 # define VFF_CM_NONE 0 # define VFF_DEP_DECORDER 0x4 # define VFF_DEP_NSORDER 0x8 # define VFF_DES_RAW 0 # define VFF_LOC_IMPLICIT 1 # define VFF_MAPTYP_NONE 0 # define VFF_MAPTYP_1_BYTE 1 # define VFF_MAPTYP_2_BYTE 2 # define VFF_MAPTYP_4_BYTE 4 # define VFF_MAPTYP_FLOAT 5 # define VFF_MAPTYP_DOUBLE 7 # define VFF_MS_NONE 0 # define VFF_MS_ONEPERBAND 1 # define VFF_MS_SHARED 3 # define VFF_TYP_BIT 0 # define VFF_TYP_1_BYTE 1 # define VFF_TYP_2_BYTE 2 # define VFF_TYP_4_BYTE 4 # define VFF_TYP_FLOAT 5 # define VFF_TYP_DOUBLE 9 typedef struct _ViffInfo { unsigned char identifier , file_type , release , version , machine_dependency , reserve [ 3 ] ; char comment [ 512 ] ; unsigned int rows , columns , subrows ; int x_offset , y_offset ; float x_bits_per_pixel , y_bits_per_pixel ; unsigned int location_type , location_dimension , number_of_images , number_data_bands , data_storage_type , data_encode_scheme , map_scheme , map_storage_type , map_rows , map_columns , map_subrows , map_enable , maps_per_cycle , color_space_model ; } ViffInfo ; double min_value , scale_factor , value ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register ssize_t x ; register Quantum * q ; register ssize_t i ; register unsigned char * p ; size_t bytes_per_pixel , max_packets , quantum ; ssize_t count , y ; unsigned char * pixels ; unsigned long lsb_first ; ViffInfo viff_info ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } count = ReadBlob ( image , 1 , & viff_info . identifier ) ; do { if ( ( count != 1 ) || ( ( unsigned char ) viff_info . identifier != 0xab ) ) ThrowReaderException ( CorruptImageError , ""NotAVIFFImage"" ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . file_type ) , & viff_info . file_type ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . release ) , & viff_info . release ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . version ) , & viff_info . version ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . machine_dependency ) , & viff_info . machine_dependency ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . reserve ) , viff_info . reserve ) ; count = ReadBlob ( image , 512 , ( unsigned char * ) viff_info . comment ) ; if ( count != 512 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; viff_info . comment [ 511 ] = '\\0' ; if ( strlen ( viff_info . comment ) > 4 ) ( void ) SetImageProperty ( image , ""comment"" , viff_info . comment , exception ) ; if ( ( viff_info . machine_dependency == VFF_DEP_DECORDER ) || ( viff_info . machine_dependency == VFF_DEP_NSORDER ) ) image -> endian = LSBEndian ; else image -> endian = MSBEndian ; viff_info . rows = ReadBlobLong ( image ) ; viff_info . columns = ReadBlobLong ( image ) ; viff_info . subrows = ReadBlobLong ( image ) ; viff_info . x_offset = ReadBlobSignedLong ( image ) ; viff_info . y_offset = ReadBlobSignedLong ( image ) ; viff_info . x_bits_per_pixel = ( float ) ReadBlobLong ( image ) ; viff_info . y_bits_per_pixel = ( float ) ReadBlobLong ( image ) ; viff_info . location_type = ReadBlobLong ( image ) ; viff_info . location_dimension = ReadBlobLong ( image ) ; viff_info . number_of_images = ReadBlobLong ( image ) ; viff_info . number_data_bands = ReadBlobLong ( image ) ; viff_info . data_storage_type = ReadBlobLong ( image ) ; viff_info . data_encode_scheme = ReadBlobLong ( image ) ; viff_info . map_scheme = ReadBlobLong ( image ) ; viff_info . map_storage_type = ReadBlobLong ( image ) ; viff_info . map_rows = ReadBlobLong ( image ) ; viff_info . map_columns = ReadBlobLong ( image ) ; viff_info . map_subrows = ReadBlobLong ( image ) ; viff_info . map_enable = ReadBlobLong ( image ) ; viff_info . maps_per_cycle = ReadBlobLong ( image ) ; viff_info . color_space_model = ReadBlobLong ( image ) ; for ( i = 0 ; i < 420 ; i ++ ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; number_pixels = ( MagickSizeType ) viff_info . columns * viff_info . rows ; if ( number_pixels > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( number_pixels != ( size_t ) number_pixels ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( number_pixels == 0 ) ThrowReaderException ( CoderError , ""ImageColumnOrRowSizeIsNotSupported"" ) ; image -> columns = viff_info . rows ; image -> rows = viff_info . columns ; image -> depth = viff_info . x_bits_per_pixel <= 8 ? 8UL : MAGICKCORE_QUANTUM_DEPTH ; image -> alpha_trait = viff_info . number_data_bands == 4 ? BlendPixelTrait : UndefinedPixelTrait ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; ( void ) SetImageBackgroundColor ( image , exception ) ; if ( ( viff_info . number_data_bands < 1 ) || ( viff_info . number_data_bands > 4 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( viff_info . data_storage_type != VFF_TYP_BIT ) && ( viff_info . data_storage_type != VFF_TYP_1_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_2_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_4_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_FLOAT ) && ( viff_info . data_storage_type != VFF_TYP_DOUBLE ) ) ThrowReaderException ( CoderError , ""DataStorageTypeIsNotSupported"" ) ; if ( viff_info . data_encode_scheme != VFF_DES_RAW ) ThrowReaderException ( CoderError , ""DataEncodingSchemeIsNotSupported"" ) ; if ( ( viff_info . map_storage_type != VFF_MAPTYP_NONE ) && ( viff_info . map_storage_type != VFF_MAPTYP_1_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_2_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_4_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_FLOAT ) && ( viff_info . map_storage_type != VFF_MAPTYP_DOUBLE ) ) ThrowReaderException ( CoderError , ""MapStorageTypeIsNotSupported"" ) ; if ( ( viff_info . color_space_model != VFF_CM_NONE ) && ( viff_info . color_space_model != VFF_CM_ntscRGB ) && ( viff_info . color_space_model != VFF_CM_genericRGB ) ) ThrowReaderException ( CoderError , ""ColorspaceModelIsNotSupported"" ) ; if ( viff_info . location_type != VFF_LOC_IMPLICIT ) ThrowReaderException ( CoderError , ""LocationTypeIsNotSupported"" ) ; if ( viff_info . number_of_images != 1 ) ThrowReaderException ( CoderError , ""NumberOfImagesIsNotSupported"" ) ; if ( viff_info . map_rows == 0 ) viff_info . map_scheme = VFF_MS_NONE ; switch ( ( int ) viff_info . map_scheme ) { case VFF_MS_NONE : { if ( viff_info . number_data_bands < 3 ) { if ( viff_info . data_storage_type == VFF_TYP_BIT ) image -> colors = 2 ; else if ( viff_info . data_storage_type == VFF_MAPTYP_1_BYTE ) image -> colors = 256UL ; else image -> colors = image -> depth <= 8 ? 256UL : 65536UL ; status = AcquireImageColormap ( image , image -> colors , exception ) ; if ( status == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } break ; } case VFF_MS_ONEPERBAND : case VFF_MS_SHARED : { unsigned char * viff_colormap ; switch ( ( int ) viff_info . map_storage_type ) { case VFF_MAPTYP_1_BYTE : bytes_per_pixel = 1 ; break ; case VFF_MAPTYP_2_BYTE : bytes_per_pixel = 2 ; break ; case VFF_MAPTYP_4_BYTE : bytes_per_pixel = 4 ; break ; case VFF_MAPTYP_FLOAT : bytes_per_pixel = 4 ; break ; case VFF_MAPTYP_DOUBLE : bytes_per_pixel = 8 ; break ; default : bytes_per_pixel = 1 ; break ; } image -> colors = viff_info . map_columns ; if ( ( MagickSizeType ) ( viff_info . map_rows * image -> colors ) > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( ( MagickSizeType ) viff_info . map_rows > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( ( MagickSizeType ) viff_info . map_rows > ( viff_info . map_rows * bytes_per_pixel * sizeof ( * viff_colormap ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; viff_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , viff_info . map_rows * bytes_per_pixel * sizeof ( * viff_colormap ) ) ; if ( viff_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , bytes_per_pixel * image -> colors * viff_info . map_rows , viff_colormap ) ; lsb_first = 1 ; if ( * ( char * ) & lsb_first && ( ( viff_info . machine_dependency != VFF_DEP_DECORDER ) && ( viff_info . machine_dependency != VFF_DEP_NSORDER ) ) ) switch ( ( int ) viff_info . map_storage_type ) { case VFF_MAPTYP_2_BYTE : { MSBOrderShort ( viff_colormap , ( bytes_per_pixel * image -> colors * viff_info . map_rows ) ) ; break ; } case VFF_MAPTYP_4_BYTE : case VFF_MAPTYP_FLOAT : { MSBOrderLong ( viff_colormap , ( bytes_per_pixel * image -> colors * viff_info . map_rows ) ) ; break ; } default : break ; } for ( i = 0 ; i < ( ssize_t ) ( viff_info . map_rows * image -> colors ) ; i ++ ) { switch ( ( int ) viff_info . map_storage_type ) { case VFF_MAPTYP_2_BYTE : value = 1.0 * ( ( short * ) viff_colormap ) [ i ] ; break ; case VFF_MAPTYP_4_BYTE : value = 1.0 * ( ( int * ) viff_colormap ) [ i ] ; break ; case VFF_MAPTYP_FLOAT : value = ( ( float * ) viff_colormap ) [ i ] ; break ; case VFF_MAPTYP_DOUBLE : value = ( ( double * ) viff_colormap ) [ i ] ; break ; default : value = 1.0 * viff_colormap [ i ] ; break ; } if ( i < ( ssize_t ) image -> colors ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) value ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) value ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) value ) ; } else if ( i < ( ssize_t ) ( 2 * image -> colors ) ) image -> colormap [ i % image -> colors ] . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) value ) ; else if ( i < ( ssize_t ) ( 3 * image -> colors ) ) image -> colormap [ i % image -> colors ] . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) value ) ; } viff_colormap = ( unsigned char * ) RelinquishMagickMemory ( viff_colormap ) ; break ; } default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( viff_info . data_storage_type == VFF_TYP_BIT ) { image -> colors = 2 ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; image -> colorspace = GRAYColorspace ; } switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : bytes_per_pixel = 2 ; break ; case VFF_TYP_4_BYTE : bytes_per_pixel = 4 ; break ; case VFF_TYP_FLOAT : bytes_per_pixel = 4 ; break ; case VFF_TYP_DOUBLE : bytes_per_pixel = 8 ; break ; default : bytes_per_pixel = 1 ; break ; } if ( viff_info . data_storage_type == VFF_TYP_BIT ) { if ( HeapOverflowSanityCheck ( ( image -> columns + 7UL ) >> 3UL , image -> rows ) != MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; max_packets = ( ( image -> columns + 7UL ) >> 3UL ) * image -> rows ; } else { if ( HeapOverflowSanityCheck ( ( size_t ) number_pixels , viff_info . number_data_bands ) != MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; max_packets = ( size_t ) ( number_pixels * viff_info . number_data_bands ) ; } if ( ( MagickSizeType ) ( bytes_per_pixel * max_packets ) > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; pixels = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( number_pixels , max_packets ) , bytes_per_pixel * sizeof ( * pixels ) ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( pixels , 0 , MagickMax ( number_pixels , max_packets ) * bytes_per_pixel * sizeof ( * pixels ) ) ; count = ReadBlob ( image , bytes_per_pixel * max_packets , pixels ) ; lsb_first = 1 ; if ( * ( char * ) & lsb_first && ( ( viff_info . machine_dependency != VFF_DEP_DECORDER ) && ( viff_info . machine_dependency != VFF_DEP_NSORDER ) ) ) switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : { MSBOrderShort ( pixels , bytes_per_pixel * max_packets ) ; break ; } case VFF_TYP_4_BYTE : case VFF_TYP_FLOAT : { MSBOrderLong ( pixels , bytes_per_pixel * max_packets ) ; break ; } default : break ; } min_value = 0.0 ; scale_factor = 1.0 ; if ( ( viff_info . data_storage_type != VFF_TYP_1_BYTE ) && ( viff_info . map_scheme == VFF_MS_NONE ) ) { double max_value ; switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : value = 1.0 * ( ( short * ) pixels ) [ 0 ] ; break ; case VFF_TYP_4_BYTE : value = 1.0 * ( ( int * ) pixels ) [ 0 ] ; break ; case VFF_TYP_FLOAT : value = ( ( float * ) pixels ) [ 0 ] ; break ; case VFF_TYP_DOUBLE : value = ( ( double * ) pixels ) [ 0 ] ; break ; default : value = 1.0 * pixels [ 0 ] ; break ; } max_value = value ; min_value = value ; for ( i = 0 ; i < ( ssize_t ) max_packets ; i ++ ) { switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : value = 1.0 * ( ( short * ) pixels ) [ i ] ; break ; case VFF_TYP_4_BYTE : value = 1.0 * ( ( int * ) pixels ) [ i ] ; break ; case VFF_TYP_FLOAT : value = ( ( float * ) pixels ) [ i ] ; break ; case VFF_TYP_DOUBLE : value = ( ( double * ) pixels ) [ i ] ; break ; default : value = 1.0 * pixels [ i ] ; break ; } if ( value > max_value ) max_value = value ; else if ( value < min_value ) min_value = value ; } if ( ( min_value == 0 ) && ( max_value == 0 ) ) scale_factor = 0 ; else if ( min_value == max_value ) { scale_factor = ( double ) QuantumRange / min_value ; min_value = 0 ; } else scale_factor = ( double ) QuantumRange / ( max_value - min_value ) ; } p = ( unsigned char * ) pixels ; for ( i = 0 ; i < ( ssize_t ) max_packets ; i ++ ) { switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : value = 1.0 * ( ( short * ) pixels ) [ i ] ; break ; case VFF_TYP_4_BYTE : value = 1.0 * ( ( int * ) pixels ) [ i ] ; break ; case VFF_TYP_FLOAT : value = ( ( float * ) pixels ) [ i ] ; break ; case VFF_TYP_DOUBLE : value = ( ( double * ) pixels ) [ i ] ; break ; default : value = 1.0 * pixels [ i ] ; break ; } if ( viff_info . map_scheme == VFF_MS_NONE ) { value = ( value - min_value ) * scale_factor ; if ( value > QuantumRange ) value = QuantumRange ; else if ( value < 0 ) value = 0 ; } * p = ( unsigned char ) ( ( Quantum ) value ) ; p ++ ; } p = ( unsigned char * ) pixels ; if ( viff_info . data_storage_type == VFF_TYP_BIT ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) ( image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { quantum = ( size_t ) ( ( * p ) & ( 0x01 << bit ) ? 0 : 1 ) ; SetPixelRed ( image , quantum == 0 ? 0 : QuantumRange , q ) ; SetPixelGreen ( image , quantum == 0 ? 0 : QuantumRange , q ) ; SetPixelBlue ( image , quantum == 0 ? 0 : QuantumRange , q ) ; if ( image -> storage_class == PseudoClass ) SetPixelIndex ( image , ( Quantum ) quantum , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( int ) ( image -> columns % 8 ) ; bit ++ ) { quantum = ( size_t ) ( ( * p ) & ( 0x01 << bit ) ? 0 : 1 ) ; SetPixelRed ( image , quantum == 0 ? 0 : QuantumRange , q ) ; SetPixelGreen ( image , quantum == 0 ? 0 : QuantumRange , q ) ; SetPixelBlue ( image , quantum == 0 ? 0 : QuantumRange , q ) ; if ( image -> storage_class == PseudoClass ) SetPixelIndex ( image , ( Quantum ) quantum , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else if ( image -> storage_class == PseudoClass ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } else { number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * ( p + number_pixels ) ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * ( p + 2 * number_pixels ) ) , q ) ; if ( image -> colors != 0 ) { ssize_t index ; index = ( ssize_t ) GetPixelRed ( image , q ) ; SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ConstrainColormapIndex ( image , index , exception ) ] . red ) , q ) ; index = ( ssize_t ) GetPixelGreen ( image , q ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ConstrainColormapIndex ( image , index , exception ) ] . green ) , q ) ; index = ( ssize_t ) GetPixelBlue ( image , q ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ConstrainColormapIndex ( image , index , exception ) ] . blue ) , q ) ; } SetPixelAlpha ( image , image -> alpha_trait != UndefinedPixelTrait ? ScaleCharToQuantum ( * ( p + number_pixels * 3 ) ) : OpaqueAlpha , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image , exception ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; count = ReadBlob ( image , 1 , & viff_info . identifier ) ; if ( ( count == 1 ) && ( viff_info . identifier == 0xab ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { <S2SV_StartBug> image = DestroyImageList ( image ) ; <S2SV_EndBug> return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( viff_info . identifier == 0xab ) ) ; ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> NULL ) { status = MagickFalse ; break <S2SV_ModEnd> ; } image
"
751,"CWE-119 static __u8 * nci_extract_rf_params_nfcf_passive_poll ( struct nci_dev * ndev , struct rf_tech_specific_params_nfcf_poll * nfcf_poll , __u8 * data ) { nfcf_poll -> bit_rate = * data ++ ; <S2SV_StartBug> nfcf_poll -> sensf_res_len = * data ++ ; <S2SV_EndBug> pr_debug ( ""bit_rate<S2SV_blank>%d,<S2SV_blank>sensf_res_len<S2SV_blank>%d\\n"" , nfcf_poll -> bit_rate , nfcf_poll -> sensf_res_len ) ; memcpy ( nfcf_poll -> sensf_res , data , nfcf_poll -> sensf_res_len ) ; data += nfcf_poll -> sensf_res_len ; return data ; }
","<S2SV_ModStart> -> sensf_res_len = min_t ( __u8 , <S2SV_ModStart> * data ++ , NFC_SENSF_RES_MAXSIZE )
"
752,"CWE-20 static Image * ReadCALSImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char filename [ MagickPathExtent ] , header [ MagickPathExtent ] , message [ MagickPathExtent ] ; FILE * file ; Image * image ; ImageInfo * read_info ; int c , unique_file ; MagickBooleanType status ; register ssize_t i ; unsigned long density , direction , height , orientation , pel_path , type , width ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) memset ( header , 0 , sizeof ( header ) ) ; density = 0 ; direction = 0 ; orientation = 1 ; pel_path = 0 ; type = 1 ; width = 0 ; height = 0 ; for ( i = 0 ; i < 16 ; i ++ ) { if ( ReadBlob ( image , 128 , ( unsigned char * ) header ) != 128 ) break ; switch ( * header ) { case 'R' : case 'r' : { if ( LocaleNCompare ( header , ""rdensty:"" , 8 ) == 0 ) { ( void ) sscanf ( header + 8 , ""%lu"" , & density ) ; break ; } if ( LocaleNCompare ( header , ""rpelcnt:"" , 8 ) == 0 ) { ( void ) sscanf ( header + 8 , ""%lu,%lu"" , & width , & height ) ; break ; } if ( LocaleNCompare ( header , ""rorient:"" , 8 ) == 0 ) { ( void ) sscanf ( header + 8 , ""%lu,%lu"" , & pel_path , & direction ) ; if ( pel_path == 90 ) orientation = 5 ; else if ( pel_path == 180 ) orientation = 3 ; else if ( pel_path == 270 ) orientation = 7 ; if ( direction == 90 ) orientation ++ ; break ; } if ( LocaleNCompare ( header , ""rtype:"" , 6 ) == 0 ) { ( void ) sscanf ( header + 6 , ""%lu"" , & type ) ; break ; } break ; } } } file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ; if ( ( unique_file == - 1 ) || ( file == ( FILE * ) NULL ) ) ThrowImageException ( FileOpenError , ""UnableToCreateTemporaryFile"" ) ; while ( ( c = ReadBlobByte ( image ) ) != EOF ) <S2SV_StartBug> ( void ) fputc ( c , file ) ; <S2SV_EndBug> ( void ) fclose ( file ) ; ( void ) CloseBlob ( image ) ; image = DestroyImage ( image ) ; read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , ""group4:%s"" , filename ) ; ( void ) FormatLocaleString ( message , MagickPathExtent , ""%lux%lu"" , width , height ) ; ( void ) CloneString ( & read_info -> size , message ) ; ( void ) FormatLocaleString ( message , MagickPathExtent , ""%lu"" , density ) ; ( void ) CloneString ( & read_info -> density , message ) ; read_info -> orientation = ( OrientationType ) orientation ; image = ReadImage ( read_info , exception ) ; if ( image != ( Image * ) NULL ) { ( void ) CopyMagickString ( image -> filename , image_info -> filename , MagickPathExtent ) ; ( void ) CopyMagickString ( image -> magick_filename , image_info -> filename , MagickPathExtent ) ; ( void ) CopyMagickString ( image -> magick , ""CALS"" , MagickPathExtent ) ; } read_info = DestroyImageInfo ( read_info ) ; ( void ) RelinquishUniqueFileResource ( filename ) ; return ( image ) ; }
","<S2SV_ModStart> != EOF ) if ( <S2SV_ModEnd> fputc ( c <S2SV_ModStart> , file ) != c ) break
"
753,"CWE-908 static int ext4_ext_grow_indepth ( handle_t * handle , struct inode * inode , unsigned int flags ) { struct ext4_extent_header * neh ; struct buffer_head * bh ; ext4_fsblk_t newblock , goal = 0 ; struct ext4_super_block * es = EXT4_SB ( inode -> i_sb ) -> s_es ; int err = 0 ; <S2SV_StartBug> if ( ext_depth ( inode ) ) <S2SV_EndBug> goal = ext4_idx_pblock ( EXT_FIRST_INDEX ( ext_inode_hdr ( inode ) ) ) ; if ( goal > le32_to_cpu ( es -> s_first_data_block ) ) { flags |= EXT4_MB_HINT_TRY_GOAL ; goal -- ; } else goal = ext4_inode_to_goal_block ( inode ) ; newblock = ext4_new_meta_blocks ( handle , inode , goal , flags , NULL , & err ) ; if ( newblock == 0 ) return err ; bh = sb_getblk_gfp ( inode -> i_sb , newblock , __GFP_MOVABLE | GFP_NOFS ) ; if ( unlikely ( ! bh ) ) return - ENOMEM ; lock_buffer ( bh ) ; err = ext4_journal_get_create_access ( handle , bh ) ; if ( err ) { unlock_buffer ( bh ) ; goto out ; } <S2SV_StartBug> memmove ( bh -> b_data , EXT4_I ( inode ) -> i_data , <S2SV_EndBug> <S2SV_StartBug> sizeof ( EXT4_I ( inode ) -> i_data ) ) ; <S2SV_EndBug> neh = ext_block_hdr ( bh ) ; if ( ext_depth ( inode ) ) neh -> eh_max = cpu_to_le16 ( ext4_ext_space_block_idx ( inode , 0 ) ) ; else neh -> eh_max = cpu_to_le16 ( ext4_ext_space_block ( inode , 0 ) ) ; neh -> eh_magic = EXT4_EXT_MAGIC ; ext4_extent_block_csum_set ( inode , neh ) ; set_buffer_uptodate ( bh ) ; unlock_buffer ( bh ) ; err = ext4_handle_dirty_metadata ( handle , inode , bh ) ; if ( err ) goto out ; neh = ext_inode_hdr ( inode ) ; neh -> eh_entries = cpu_to_le16 ( 1 ) ; ext4_idx_store_pblock ( EXT_FIRST_INDEX ( neh ) , newblock ) ; if ( neh -> eh_depth == 0 ) { neh -> eh_max = cpu_to_le16 ( ext4_ext_space_root_idx ( inode , 0 ) ) ; EXT_FIRST_INDEX ( neh ) -> ei_block = EXT_FIRST_EXTENT ( neh ) -> ee_block ; } ext_debug ( ""new<S2SV_blank>root:<S2SV_blank>num<S2SV_blank>%d(%d),<S2SV_blank>lblock<S2SV_blank>%d,<S2SV_blank>ptr<S2SV_blank>%llu\\n"" , le16_to_cpu ( neh -> eh_entries ) , le16_to_cpu ( neh -> eh_max ) , le32_to_cpu ( EXT_FIRST_INDEX ( neh ) -> ei_block ) , ext4_idx_pblock ( EXT_FIRST_INDEX ( neh ) ) ) ; le16_add_cpu ( & neh -> eh_depth , 1 ) ; ext4_mark_inode_dirty ( handle , inode ) ; out : brelse ( bh ) ; return err ; }
","<S2SV_ModStart> = 0 ; size_t ext_size = 0 ; <S2SV_ModStart> out ; } ext_size = sizeof ( EXT4_I ( inode ) -> i_data ) ; <S2SV_ModStart> -> i_data , ext_size ) ; memset ( bh -> b_data + ext_size , 0 , inode -> i_sb -> s_blocksize - ext_size <S2SV_ModEnd> ) ; neh
"
754,"CWE-20 static struct dst_entry * ip6_sk_dst_check ( struct sock * sk , struct dst_entry * dst , const struct flowi6 * fl6 ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; <S2SV_StartBug> struct rt6_info * rt = ( struct rt6_info * ) dst ; <S2SV_EndBug> if ( ! dst ) <S2SV_StartBug> goto out ; <S2SV_EndBug> if ( ip6_rt_check ( & rt -> rt6i_dst , & fl6 -> daddr , np -> daddr_cache ) || # ifdef CONFIG_IPV6_SUBTREES ip6_rt_check ( & rt -> rt6i_src , & fl6 -> saddr , np -> saddr_cache ) || # endif ( fl6 -> flowi6_oif && fl6 -> flowi6_oif != dst -> dev -> ifindex ) ) { dst_release ( dst ) ; dst = NULL ; } out : return dst ; }
","<S2SV_ModStart> rt6_info * rt <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) goto out ; if ( dst -> ops -> family != AF_INET6 ) { dst_release ( dst ) ; return NULL ; } rt = ( struct rt6_info * ) dst
"
755,"CWE-264 static void vmx_refresh_apicv_exec_ctrl ( struct kvm_vcpu * vcpu ) { struct vcpu_vmx * vmx = to_vmx ( vcpu ) ; vmcs_write32 ( PIN_BASED_VM_EXEC_CONTROL , vmx_pin_based_exec_ctrl ( vmx ) ) ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> ) ) ; if ( cpu_has_secondary_exec_ctrls ( ) ) { if ( kvm_vcpu_apicv_active ( vcpu ) ) vmcs_set_bits ( SECONDARY_VM_EXEC_CONTROL , SECONDARY_EXEC_APIC_REGISTER_VIRT | SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY ) ; else vmcs_clear_bits ( SECONDARY_VM_EXEC_CONTROL , SECONDARY_EXEC_APIC_REGISTER_VIRT | SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY ) ; } if ( cpu_has_vmx_msr_bitmap ( ) ) vmx_set_msr_bitmap ( vcpu ) ;
"
756,"CWE-362 static void init_once ( void * foo ) { struct ext4_inode_info * ei = ( struct ext4_inode_info * ) foo ; INIT_LIST_HEAD ( & ei -> i_orphan ) ; init_rwsem ( & ei -> xattr_sem ) ; init_rwsem ( & ei -> i_data_sem ) ; <S2SV_StartBug> inode_init_once ( & ei -> vfs_inode ) ; <S2SV_EndBug> }
","<S2SV_ModStart> i_data_sem ) ; init_rwsem ( & ei -> i_mmap_sem ) ;
"
757,"CWE-119 void cJSON_ReplaceItemInArray ( cJSON * array , int which , cJSON * newitem ) { cJSON * c = array -> child ; <S2SV_StartBug> while ( c && which > 0 ) { <S2SV_EndBug> <S2SV_StartBug> c = c -> next ; <S2SV_EndBug> -- which ; } if ( ! c ) return ; newitem -> next = c -> next ; newitem -> prev = c -> prev ; if ( newitem -> next ) newitem -> next -> prev = newitem ; if ( c == array -> child ) array -> child = newitem ; else newitem -> prev -> next = newitem ; c -> next = c -> prev = 0 ; cJSON_Delete ( c ) ; }
","<S2SV_ModStart> > 0 ) <S2SV_ModEnd> c = c <S2SV_ModStart> c -> next , which -- ; <S2SV_ModEnd> if ( !
"
758,"CWE-835 static int resp_get_length ( netdissect_options * ndo , register const u_char * bp , int len , const u_char * * endp ) { int result ; u_char c ; int saw_digit ; int neg ; int too_large ; if ( len == 0 ) goto trunc ; ND_TCHECK ( * bp ) ; too_large = 0 ; neg = 0 ; if ( * bp == '-' ) { neg = 1 ; bp ++ ; len -- ; } result = 0 ; saw_digit = 0 ; for ( ; ; ) { if ( len == 0 ) goto trunc ; ND_TCHECK ( * bp ) ; c = * bp ; if ( ! ( c >= '0' && c <= '9' ) ) { <S2SV_StartBug> if ( ! saw_digit ) <S2SV_EndBug> <S2SV_StartBug> goto invalid ; <S2SV_EndBug> break ; } c -= '0' ; if ( result > ( INT_MAX / 10 ) ) { too_large = 1 ; } else { result *= 10 ; if ( result == INT_MAX && c > ( INT_MAX % 10 ) ) { too_large = 1 ; } else result += c ; } bp ++ ; len -- ; saw_digit = 1 ; } if ( ! saw_digit ) goto invalid ; if ( len == 0 ) goto trunc ; ND_TCHECK ( * bp ) ; <S2SV_StartBug> if ( * bp != '\\r' ) <S2SV_EndBug> <S2SV_StartBug> goto invalid ; <S2SV_EndBug> bp ++ ; len -- ; if ( len == 0 ) goto trunc ; ND_TCHECK ( * bp ) ; <S2SV_StartBug> if ( * bp != '\\n' ) <S2SV_EndBug> <S2SV_StartBug> goto invalid ; <S2SV_EndBug> bp ++ ; len -- ; * endp = bp ; if ( neg ) { if ( too_large || result != 1 ) return ( - 4 ) ; result = - 1 ; } return ( too_large ? - 3 : result ) ; trunc : <S2SV_StartBug> return ( - 2 ) ; <S2SV_EndBug> invalid : <S2SV_StartBug> return ( - 5 ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ! saw_digit ) { bp ++ ; <S2SV_ModStart> goto invalid ; } <S2SV_ModStart> != '\\r' ) { bp ++ ; <S2SV_ModStart> goto invalid ; } <S2SV_ModStart> != '\\n' ) { bp ++ ; <S2SV_ModStart> goto invalid ; } <S2SV_ModStart> ; trunc : * endp = bp ; <S2SV_ModStart> ; invalid : * endp = bp ;
"
759,"CWE-119 void test_base64_lengths ( void ) { const char * in = ""FuseMuse"" ; char out1 [ 32 ] ; char out2 [ 32 ] ; size_t enclen ; int declen ; enclen = mutt_b64_encode ( out1 , in , 0 , 32 ) ; if ( ! TEST_CHECK ( enclen == 0 ) ) { TEST_MSG ( ""Expected:<S2SV_blank>%zu"" , 0 ) ; TEST_MSG ( ""Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%zu"" , enclen ) ; } out1 [ 0 ] = '\\0' ; <S2SV_StartBug> declen = mutt_b64_decode ( out2 , out1 ) ; <S2SV_EndBug> if ( ! TEST_CHECK ( declen == - 1 ) ) { TEST_MSG ( ""Expected:<S2SV_blank>%zu"" , - 1 ) ; TEST_MSG ( ""Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%zu"" , declen ) ; } for ( size_t i = 1 ; i <= 8 ; ++ i ) { enclen = mutt_b64_encode ( out1 , in , i , 32 ) ; size_t exp = ( ( i + 2 ) / 3 ) << 2 ; if ( ! TEST_CHECK ( enclen == exp ) ) { TEST_MSG ( ""Expected:<S2SV_blank>%zu"" , exp ) ; TEST_MSG ( ""Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%zu"" , enclen ) ; } <S2SV_StartBug> declen = mutt_b64_decode ( out2 , out1 ) ; <S2SV_EndBug> if ( ! TEST_CHECK ( declen == i ) ) { TEST_MSG ( ""Expected:<S2SV_blank>%zu"" , i ) ; TEST_MSG ( ""Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%zu"" , declen ) ; } out2 [ declen ] = '\\0' ; if ( ! TEST_CHECK ( strncmp ( out2 , in , i ) == 0 ) ) { TEST_MSG ( ""Expected:<S2SV_blank>%s"" , in ) ; TEST_MSG ( ""Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%s"" , out2 ) ; } } }
","<S2SV_ModStart> out2 , out1 , sizeof ( out2 ) <S2SV_ModStart> out2 , out1 , sizeof ( out2 )
"
760,"CWE-125 static int snd_usb_create_streams ( struct snd_usb_audio * chip , int ctrlif ) { struct usb_device * dev = chip -> dev ; struct usb_host_interface * host_iface ; struct usb_interface_descriptor * altsd ; void * control_header ; <S2SV_StartBug> int i , protocol ; <S2SV_EndBug> host_iface = & usb_ifnum_to_if ( dev , ctrlif ) -> altsetting [ 0 ] ; control_header = snd_usb_find_csint_desc ( host_iface -> extra , host_iface -> extralen , NULL , UAC_HEADER ) ; altsd = get_iface_desc ( host_iface ) ; protocol = altsd -> bInterfaceProtocol ; if ( ! control_header ) { dev_err ( & dev -> dev , ""cannot<S2SV_blank>find<S2SV_blank>UAC_HEADER\\n"" ) ; return - EINVAL ; } <S2SV_StartBug> switch ( protocol ) { <S2SV_EndBug> default : dev_warn ( & dev -> dev , ""unknown<S2SV_blank>interface<S2SV_blank>protocol<S2SV_blank>%#02x,<S2SV_blank>assuming<S2SV_blank>v1\\n"" , protocol ) ; case UAC_VERSION_1 : { struct uac1_ac_header_descriptor * h1 = control_header ; <S2SV_StartBug> if ( ! h1 -> bInCollection ) { <S2SV_EndBug> <S2SV_StartBug> dev_info ( & dev -> dev , ""skipping<S2SV_blank>empty<S2SV_blank>audio<S2SV_blank>interface<S2SV_blank>(v1)\\n"" ) ; <S2SV_EndBug> return - EINVAL ; } if ( h1 -> bLength < sizeof ( * h1 ) + h1 -> bInCollection ) { dev_err ( & dev -> dev , ""invalid<S2SV_blank>UAC_HEADER<S2SV_blank>(v1)\\n"" ) ; return - EINVAL ; } for ( i = 0 ; i < h1 -> bInCollection ; i ++ ) snd_usb_create_stream ( chip , ctrlif , h1 -> baInterfaceNr [ i ] ) ; break ; } case UAC_VERSION_2 : { struct usb_interface_assoc_descriptor * assoc = usb_ifnum_to_if ( dev , ctrlif ) -> intf_assoc ; if ( ! assoc ) { struct usb_interface * iface = usb_ifnum_to_if ( dev , ctrlif + 1 ) ; if ( iface && iface -> intf_assoc && iface -> intf_assoc -> bFunctionClass == USB_CLASS_AUDIO && iface -> intf_assoc -> bFunctionProtocol == UAC_VERSION_2 ) assoc = iface -> intf_assoc ; } if ( ! assoc ) { dev_err ( & dev -> dev , ""Audio<S2SV_blank>class<S2SV_blank>v2<S2SV_blank>interfaces<S2SV_blank>need<S2SV_blank>an<S2SV_blank>interface<S2SV_blank>association\\n"" ) ; return - EINVAL ; } for ( i = 0 ; i < assoc -> bInterfaceCount ; i ++ ) { int intf = assoc -> bFirstInterface + i ; if ( intf != ctrlif ) snd_usb_create_stream ( chip , ctrlif , intf ) ; } break ; } } return 0 ; }
","<S2SV_ModStart> i , protocol ; int rest_bytes <S2SV_ModStart> EINVAL ; } rest_bytes = ( void * ) ( host_iface -> extra + host_iface -> extralen ) - control_header ; if ( rest_bytes <= 0 ) { dev_err ( & dev -> dev , ""invalid<S2SV_blank>control<S2SV_blank>header\\n"" ) ; return - EINVAL ; } <S2SV_ModStart> ; if ( rest_bytes < sizeof ( * h1 ) ) { dev_err ( & dev -> dev , ""too<S2SV_blank>short<S2SV_blank>v1<S2SV_blank>buffer<S2SV_blank>descriptor\\n"" ) ; return - EINVAL ; } if ( <S2SV_ModStart> dev , ""skipping<S2SV_blank>empty<S2SV_blank>audio<S2SV_blank>interface<S2SV_blank>(v1)\\n"" ) ; return - EINVAL ; } if ( rest_bytes < h1 -> bLength ) { dev_err ( & dev -> dev , ""invalid<S2SV_blank>buffer<S2SV_blank>length<S2SV_blank>(v1)\\n""
"
761,"CWE-125 static inline signed int ReadPropertyMSBLong ( const unsigned char * * p , size_t * length ) { union { unsigned int unsigned_value ; signed int signed_value ; } quantum ; int c ; register ssize_t i ; unsigned char buffer [ 4 ] ; <S2SV_StartBug> size_t <S2SV_EndBug> value ; if ( * length < 4 ) return ( - 1 ) ; for ( i = 0 ; i < 4 ; i ++ ) { c = ( int ) ( * ( * p ) ++ ) ; ( * length ) -- ; buffer [ i ] = ( unsigned char ) c ; } <S2SV_StartBug> value = ( size_t ) ( buffer [ 0 ] << 24 ) ; <S2SV_EndBug> <S2SV_StartBug> value |= buffer [ 1 ] << 16 ; <S2SV_EndBug> <S2SV_StartBug> value |= buffer [ 2 ] << 8 ; <S2SV_EndBug> <S2SV_StartBug> value |= buffer [ 3 ] ; <S2SV_EndBug> <S2SV_StartBug> quantum . unsigned_value = ( value & 0xffffffff ) ; <S2SV_EndBug> return ( quantum . signed_value ) ; }
","<S2SV_ModStart> 4 ] ; unsigned int <S2SV_ModEnd> value ; if <S2SV_ModStart> value = ( unsigned int ) <S2SV_ModEnd> buffer [ 0 <S2SV_ModStart> ] << 24 <S2SV_ModEnd> ; value |= <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModStart> . unsigned_value = <S2SV_ModEnd> value & 0xffffffff <S2SV_ModStart> value & 0xffffffff <S2SV_ModEnd> ; return (
"
762,"CWE-20 static int netlink_recvmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct scm_cookie scm ; struct sock * sk = sock -> sk ; struct netlink_sock * nlk = nlk_sk ( sk ) ; int noblock = flags & MSG_DONTWAIT ; size_t copied ; struct sk_buff * skb , * data_skb ; int err , ret ; if ( flags & MSG_OOB ) return - EOPNOTSUPP ; copied = 0 ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( skb == NULL ) goto out ; data_skb = skb ; # ifdef CONFIG_COMPAT_NETLINK_MESSAGES if ( unlikely ( skb_shinfo ( skb ) -> frag_list ) ) { if ( flags & MSG_CMSG_COMPAT ) data_skb = skb_shinfo ( skb ) -> frag_list ; } # endif <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> copied = data_skb -> len ; if ( len < copied ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } skb_reset_transport_header ( data_skb ) ; err = skb_copy_datagram_iovec ( data_skb , 0 , msg -> msg_iov , copied ) ; if ( msg -> msg_name ) { struct sockaddr_nl * addr = ( struct sockaddr_nl * ) msg -> msg_name ; addr -> nl_family = AF_NETLINK ; addr -> nl_pad = 0 ; addr -> nl_pid = NETLINK_CB ( skb ) . portid ; addr -> nl_groups = netlink_group_mask ( NETLINK_CB ( skb ) . dst_group ) ; msg -> msg_namelen = sizeof ( * addr ) ; } if ( nlk -> flags & NETLINK_RECV_PKTINFO ) netlink_cmsg_recv_pktinfo ( msg , skb ) ; if ( NULL == siocb -> scm ) { memset ( & scm , 0 , sizeof ( scm ) ) ; siocb -> scm = & scm ; } siocb -> scm -> creds = * NETLINK_CREDS ( skb ) ; if ( flags & MSG_TRUNC ) copied = data_skb -> len ; skb_free_datagram ( sk , skb ) ; if ( nlk -> cb_running && atomic_read ( & sk -> sk_rmem_alloc ) <= sk -> sk_rcvbuf / 2 ) { ret = netlink_dump ( sk ) ; if ( ret ) { sk -> sk_err = ret ; sk -> sk_error_report ( sk ) ; } } scm_recv ( sock , msg , siocb -> scm , flags ) ; out : netlink_rcv_wake ( sk ) ; return err ? : copied ; }
","<S2SV_ModStart> } # endif <S2SV_ModEnd> copied = data_skb
"
763,"CWE-400 asmlinkage void kernel_unaligned_trap ( struct pt_regs * regs , unsigned int insn ) { enum direction dir = decode_direction ( insn ) ; int size = decode_access_size ( regs , insn ) ; int orig_asi , asi ; current_thread_info ( ) -> kern_una_regs = regs ; current_thread_info ( ) -> kern_una_insn = insn ; orig_asi = asi = decode_asi ( insn , regs ) ; if ( asi == ASI_AIUS ) { kernel_mna_trap_fault ( 0 ) ; return ; } log_unaligned ( regs ) ; if ( ! ok_for_kernel ( insn ) || dir == both ) { printk ( ""Unsupported<S2SV_blank>unaligned<S2SV_blank>load/store<S2SV_blank>trap<S2SV_blank>for<S2SV_blank>kernel<S2SV_blank>"" ""at<S2SV_blank><%016lx>.\\n"" , regs -> tpc ) ; unaligned_panic ( ""Kernel<S2SV_blank>does<S2SV_blank>fpu/atomic<S2SV_blank>"" ""unaligned<S2SV_blank>load/store."" , regs ) ; kernel_mna_trap_fault ( 0 ) ; } else { unsigned long addr , * reg_addr ; int err ; addr = compute_effective_address ( regs , insn , ( ( insn >> 25 ) & 0x1f ) ) ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , addr ) ; <S2SV_EndBug> switch ( asi ) { case ASI_NL : case ASI_AIUPL : case ASI_AIUSL : case ASI_PL : case ASI_SL : case ASI_PNFL : case ASI_SNFL : asi &= ~ 0x08 ; break ; } switch ( dir ) { case load : reg_addr = fetch_reg_addr ( ( ( insn >> 25 ) & 0x1f ) , regs ) ; err = do_int_load ( reg_addr , size , ( unsigned long * ) addr , decode_signedness ( insn ) , asi ) ; if ( likely ( ! err ) && unlikely ( asi != orig_asi ) ) { unsigned long val_in = * reg_addr ; switch ( size ) { case 2 : val_in = swab16 ( val_in ) ; break ; case 4 : val_in = swab32 ( val_in ) ; break ; case 8 : val_in = swab64 ( val_in ) ; break ; case 16 : default : BUG ( ) ; break ; } * reg_addr = val_in ; } break ; case store : err = do_int_store ( ( ( insn >> 25 ) & 0x1f ) , size , ( unsigned long * ) addr , regs , asi , orig_asi ) ; break ; default : panic ( ""Impossible<S2SV_blank>kernel<S2SV_blank>unaligned<S2SV_blank>trap."" ) ; } if ( unlikely ( err ) ) kernel_mna_trap_fault ( 1 ) ; else advance ( regs ) ; } }
","<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , addr
"
764,"CWE-667 static void userfaultfd_event_wait_completion ( struct userfaultfd_ctx * ctx , struct userfaultfd_wait_queue * ewq ) { struct userfaultfd_ctx * release_new_ctx ; if ( WARN_ON_ONCE ( current -> flags & PF_EXITING ) ) goto out ; ewq -> ctx = ctx ; init_waitqueue_entry ( & ewq -> wq , current ) ; release_new_ctx = NULL ; spin_lock ( & ctx -> event_wqh . lock ) ; __add_wait_queue ( & ctx -> event_wqh , & ewq -> wq ) ; for ( ; ; ) { set_current_state ( TASK_KILLABLE ) ; if ( ewq -> msg . event == 0 ) break ; if ( READ_ONCE ( ctx -> released ) || fatal_signal_pending ( current ) ) { __remove_wait_queue ( & ctx -> event_wqh , & ewq -> wq ) ; if ( ewq -> msg . event == UFFD_EVENT_FORK ) { struct userfaultfd_ctx * new ; new = ( struct userfaultfd_ctx * ) ( unsigned long ) ewq -> msg . arg . reserved . reserved1 ; release_new_ctx = new ; } break ; } spin_unlock ( & ctx -> event_wqh . lock ) ; wake_up_poll ( & ctx -> fd_wqh , EPOLLIN ) ; schedule ( ) ; spin_lock ( & ctx -> event_wqh . lock ) ; } __set_current_state ( TASK_RUNNING ) ; spin_unlock ( & ctx -> event_wqh . lock ) ; if ( release_new_ctx ) { struct vm_area_struct * vma ; struct mm_struct * mm = release_new_ctx -> mm ; down_write ( & mm -> mmap_sem ) ; <S2SV_StartBug> for ( vma = mm -> mmap ; vma ; vma = vma -> vm_next ) <S2SV_EndBug> if ( vma -> vm_userfaultfd_ctx . ctx == release_new_ctx ) { vma -> vm_userfaultfd_ctx = NULL_VM_UFFD_CTX ; vma -> vm_flags &= ~ ( VM_UFFD_WP | VM_UFFD_MISSING ) ; } up_write ( & mm -> mmap_sem ) ; userfaultfd_ctx_put ( release_new_ctx ) ; } out : WRITE_ONCE ( ctx -> mmap_changing , false ) ; userfaultfd_ctx_put ( ctx ) ; }
","<S2SV_ModStart> mmap_sem ) ; VM_WARN_ON ( ! mmget_still_valid ( mm ) ) ;
"
765,"CWE-119 <S2SV_StartBug> static void super_block_uvrd ( const VP9_COMP * cpi , MACROBLOCK * x , <S2SV_EndBug> int * rate , int64_t * distortion , int * skippable , int64_t * sse , BLOCK_SIZE bsize , int64_t ref_best_rd ) { MACROBLOCKD * const xd = & x -> e_mbd ; MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ; <S2SV_StartBug> TX_SIZE uv_txfm_size = get_uv_tx_size ( mbmi ) ; <S2SV_EndBug> int plane ; int pnrate = 0 , pnskip = 1 ; int64_t pndist = 0 , pnsse = 0 ; <S2SV_StartBug> if ( ref_best_rd < 0 ) <S2SV_EndBug> <S2SV_StartBug> goto term ; <S2SV_EndBug> <S2SV_StartBug> if ( is_inter_block ( mbmi ) ) { <S2SV_EndBug> int plane ; for ( plane = 1 ; plane < MAX_MB_PLANE ; ++ plane ) vp9_subtract_plane ( x , bsize , plane ) ; } * rate = 0 ; * distortion = 0 ; * sse = 0 ; * skippable = 1 ; for ( plane = 1 ; plane < MAX_MB_PLANE ; ++ plane ) { txfm_rd_in_plane ( x , & pnrate , & pndist , & pnskip , & pnsse , <S2SV_StartBug> ref_best_rd , plane , bsize , uv_txfm_size , <S2SV_EndBug> cpi -> sf . use_fast_coef_costing ) ; if ( pnrate == INT_MAX ) <S2SV_StartBug> goto term ; <S2SV_EndBug> * rate += pnrate ; * distortion += pndist ; * sse += pnsse ; * skippable &= pnskip ; } <S2SV_StartBug> return ; <S2SV_EndBug> term : * rate = INT_MAX ; * distortion = INT64_MAX ; * sse = INT64_MAX ; * skippable = 0 ; return ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> super_block_uvrd ( const <S2SV_ModStart> -> mbmi ; const TX_SIZE uv_tx_size <S2SV_ModEnd> = get_uv_tx_size ( <S2SV_ModStart> get_uv_tx_size ( mbmi , & xd -> plane [ 1 ] <S2SV_ModStart> = 0 ; int is_cost_valid = 1 ; <S2SV_ModStart> < 0 ) is_cost_valid = 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( mbmi ) && is_cost_valid <S2SV_ModStart> , bsize , uv_tx_size <S2SV_ModEnd> , cpi -> <S2SV_ModStart> == INT_MAX ) { is_cost_valid = 0 ; break ; } <S2SV_ModEnd> * rate += <S2SV_ModStart> pnskip ; } if ( ! is_cost_valid ) { * rate = INT_MAX ; * distortion = INT64_MAX ; * sse = INT64_MAX ; * skippable = 0 ; } return is_cost_valid <S2SV_ModEnd> ; } <S2SV_null>
"
766,"CWE-476 int read_escaped_char ( yyscan_t yyscanner , uint8_t * escaped_char ) { char text [ 4 ] = { 0 , 0 , 0 , 0 } ; text [ 0 ] = '\\\\' ; text [ 1 ] = RE_YY_INPUT ( yyscanner ) ; <S2SV_StartBug> if ( text [ 1 ] == EOF ) <S2SV_EndBug> return 0 ; if ( text [ 1 ] == 'x' ) { text [ 2 ] = RE_YY_INPUT ( yyscanner ) ; <S2SV_StartBug> if ( text [ 2 ] == EOF ) <S2SV_EndBug> return 0 ; text [ 3 ] = RE_YY_INPUT ( yyscanner ) ; <S2SV_StartBug> if ( text [ 3 ] == EOF ) <S2SV_EndBug> return 0 ; } * escaped_char = escaped_char_value ( text ) ; return 1 ; }
","<S2SV_ModStart> ] == EOF || text [ 1 ] == 0 <S2SV_ModStart> ; if ( ! isxdigit ( <S2SV_ModStart> [ 2 ] ) <S2SV_ModEnd> ) return 0 <S2SV_ModStart> ; if ( ! isxdigit ( <S2SV_ModStart> [ 3 ] ) <S2SV_ModEnd> ) return 0
"
767,"CWE-000 static void dump_completed_IO ( struct inode * inode ) { # ifdef EXT4_DEBUG struct list_head * cur , * before , * after ; ext4_io_end_t * io , * io0 , * io1 ; <S2SV_StartBug> if ( list_empty ( & EXT4_I ( inode ) -> i_completed_io_list ) ) { <S2SV_EndBug> ext4_debug ( ""inode<S2SV_blank>%lu<S2SV_blank>completed_io<S2SV_blank>list<S2SV_blank>is<S2SV_blank>empty\\n"" , inode -> i_ino ) ; return ; } <S2SV_StartBug> ext4_debug ( ""Dump<S2SV_blank>inode<S2SV_blank>%lu<S2SV_blank>completed_io<S2SV_blank>list<S2SV_blank>\\n"" , inode -> i_ino ) ; <S2SV_EndBug> list_for_each_entry ( io , & EXT4_I ( inode ) -> i_completed_io_list , list ) { cur = & io -> list ; before = cur -> prev ; io0 = container_of ( before , ext4_io_end_t , list ) ; after = cur -> next ; io1 = container_of ( after , ext4_io_end_t , list ) ; ext4_debug ( ""io<S2SV_blank>0x%p<S2SV_blank>from<S2SV_blank>inode<S2SV_blank>%lu,prev<S2SV_blank>0x%p,next<S2SV_blank>0x%p\\n"" , io , inode -> i_ino , io0 , io1 ) ; } <S2SV_StartBug> # endif <S2SV_EndBug> }
","<S2SV_ModStart> * io1 ; unsigned long flags ; <S2SV_ModStart> inode -> i_ino ) ; spin_lock_irqsave ( & EXT4_I ( inode ) -> i_completed_io_lock , flags <S2SV_ModStart> ) ; } spin_unlock_irqrestore ( & EXT4_I ( inode ) -> i_completed_io_lock , flags ) ;
"
768,"CWE-326 static VALUE ossl_cipher_set_key ( VALUE self , VALUE key ) { EVP_CIPHER_CTX * ctx ; int key_len ; StringValue ( key ) ; GetCipher ( self , ctx ) ; key_len = EVP_CIPHER_CTX_key_length ( ctx ) ; if ( RSTRING_LEN ( key ) != key_len ) ossl_raise ( rb_eArgError , ""key<S2SV_blank>must<S2SV_blank>be<S2SV_blank>%d<S2SV_blank>bytes"" , key_len ) ; if ( EVP_CipherInit_ex ( ctx , NULL , NULL , ( unsigned char * ) RSTRING_PTR ( key ) , NULL , - 1 ) != 1 ) ossl_raise ( eCipherError , NULL ) ; <S2SV_StartBug> return key ; <S2SV_EndBug> }
","<S2SV_ModStart> NULL ) ; rb_ivar_set ( self , id_key_set , Qtrue ) ;
"
769,"CWE-399 int cib_remote_perform_op ( cib_t * cib , const char * op , const char * host , const char * section , xmlNode * data , xmlNode * * output_data , int call_options , const char * name ) { int rc = pcmk_ok ; <S2SV_StartBug> xmlNode * op_msg = NULL ; <S2SV_EndBug> xmlNode * op_reply = NULL ; cib_remote_opaque_t * private = cib -> variant_opaque ; <S2SV_StartBug> if ( sync_timer == NULL ) { <S2SV_EndBug> sync_timer = calloc ( 1 , sizeof ( struct timer_rec_s ) ) ; } if ( cib -> state == cib_disconnected ) { return - ENOTCONN ; } if ( output_data != NULL ) { * output_data = NULL ; } if ( op == NULL ) { crm_err ( ""No<S2SV_blank>operation<S2SV_blank>specified"" ) ; return - EINVAL ; } cib -> call_id ++ ; if ( cib -> call_id < 1 ) { cib -> call_id = 1 ; } op_msg = cib_create_op ( cib -> call_id , private -> callback . token , op , host , section , data , call_options , NULL ) ; if ( op_msg == NULL ) { return - EPROTO ; } crm_trace ( ""Sending<S2SV_blank>%s<S2SV_blank>message<S2SV_blank>to<S2SV_blank>CIB<S2SV_blank>service"" , op ) ; <S2SV_StartBug> crm_send_remote_msg ( private -> command . session , op_msg , private -> command . encrypted ) ; <S2SV_EndBug> free_xml ( op_msg ) ; if ( ( call_options & cib_discard_reply ) ) { crm_trace ( ""Discarding<S2SV_blank>reply"" ) ; return pcmk_ok ; } else if ( ! ( call_options & cib_sync_call ) ) { return cib -> call_id ; } crm_trace ( ""Waiting<S2SV_blank>for<S2SV_blank>a<S2SV_blank>syncronous<S2SV_blank>reply"" ) ; <S2SV_StartBug> if ( cib -> call_timeout > 0 ) { <S2SV_EndBug> timer_expired = FALSE ; sync_timer -> call_id = cib -> call_id ; sync_timer -> timeout = cib -> call_timeout * 1000 ; sync_timer -> ref = g_timeout_add ( sync_timer -> timeout , cib_timeout_handler , sync_timer ) ; } while ( timer_expired == FALSE ) { int reply_id = - 1 ; int msg_id = cib -> call_id ; <S2SV_StartBug> op_reply = crm_recv_remote_msg ( private -> command . session , private -> command . encrypted ) ; <S2SV_EndBug> if ( op_reply == NULL ) { break ; } <S2SV_StartBug> crm_element_value_int ( op_reply , F_CIB_CALLID , & reply_id ) ; <S2SV_EndBug> CRM_CHECK ( reply_id > 0 , free_xml ( op_reply ) ; if ( sync_timer -> ref > 0 ) { g_source_remove ( sync_timer -> ref ) ; sync_timer -> ref = 0 ; } return - ENOMSG ) ; if ( reply_id == msg_id ) { break ; } else if ( reply_id < msg_id ) { crm_debug ( ""Received<S2SV_blank>old<S2SV_blank>reply:<S2SV_blank>%d<S2SV_blank>(wanted<S2SV_blank>%d)"" , reply_id , msg_id ) ; crm_log_xml_trace ( op_reply , ""Old<S2SV_blank>reply"" ) ; } else if ( ( reply_id - 10000 ) > msg_id ) { crm_debug ( ""Received<S2SV_blank>old<S2SV_blank>reply:<S2SV_blank>%d<S2SV_blank>(wanted<S2SV_blank>%d)"" , reply_id , msg_id ) ; crm_log_xml_trace ( op_reply , ""Old<S2SV_blank>reply"" ) ; } else { crm_err ( ""Received<S2SV_blank>a<S2SV_blank>__future__<S2SV_blank>reply:"" ""<S2SV_blank>%d<S2SV_blank>(wanted<S2SV_blank>%d)"" , reply_id , msg_id ) ; } free_xml ( op_reply ) ; op_reply = NULL ; <S2SV_StartBug> } <S2SV_EndBug> if ( sync_timer -> ref > 0 ) { g_source_remove ( sync_timer -> ref ) ; sync_timer -> ref = 0 ; } if ( timer_expired ) { return - ETIME ; } if ( op_reply == NULL ) { crm_err ( ""No<S2SV_blank>reply<S2SV_blank>message<S2SV_blank>-<S2SV_blank>empty"" ) ; return - ENOMSG ; } crm_trace ( ""Syncronous<S2SV_blank>reply<S2SV_blank>received"" ) ; if ( crm_element_value_int ( op_reply , F_CIB_RC , & rc ) != 0 ) { rc = - EPROTO ; } if ( rc == - pcmk_err_diff_resync ) { rc = pcmk_ok ; } if ( rc == pcmk_ok || rc == - EPERM ) { crm_log_xml_debug ( op_reply , ""passed"" ) ; } else { crm_err ( ""Call<S2SV_blank>failed:<S2SV_blank>%s"" , pcmk_strerror ( rc ) ) ; crm_log_xml_warn ( op_reply , ""failed"" ) ; } if ( output_data == NULL ) { } else if ( ! ( call_options & cib_discard_reply ) ) { xmlNode * tmp = get_message_xml ( op_reply , F_CIB_CALLDATA ) ; if ( tmp == NULL ) { crm_trace ( ""No<S2SV_blank>output<S2SV_blank>in<S2SV_blank>reply<S2SV_blank>to<S2SV_blank>\\""%s\\""<S2SV_blank>command<S2SV_blank>%d"" , op , cib -> call_id - 1 ) ; } else { * output_data = copy_xml ( tmp ) ; } } free_xml ( op_reply ) ; return rc ; }
","<S2SV_ModStart> = pcmk_ok ; int disconnected = 0 ; int remaining_time = 0 ; time_t start_time ; <S2SV_ModStart> -> variant_opaque ; <S2SV_ModEnd> if ( cib <S2SV_ModStart> op ) ; if ( ! ( call_options & cib_sync_call ) ) { <S2SV_ModStart> ( private -> callback . session , op_msg , private -> command . encrypted ) ; } else { crm_send_remote_msg ( private -> command . <S2SV_ModEnd> session , op_msg <S2SV_ModStart> encrypted ) ; } <S2SV_ModStart> ""Waiting<S2SV_blank>for<S2SV_blank>a<S2SV_blank>syncronous<S2SV_blank>reply"" ) ; start_time = time ( NULL ) ; remaining_time = <S2SV_ModEnd> cib -> call_timeout <S2SV_ModStart> cib -> call_timeout ? cib -> call_timeout : 60 ; while ( remaining_time > 0 && ! disconnected <S2SV_ModEnd> ) { int <S2SV_ModStart> -> call_id ; <S2SV_ModEnd> crm_recv_remote_msg ( private <S2SV_ModStart> . session , & <S2SV_ModStart> -> command . recv_buf , private -> command . encrypted , remaining_time * 1000 , & disconnected ) ; op_reply = crm_parse_remote_buffer ( & private -> command . recv_buf ) ; if ( ! op_reply <S2SV_ModEnd> ) { break <S2SV_ModStart> , & reply_id <S2SV_ModEnd> ) ; if <S2SV_ModStart> = NULL ; remaining_time = time ( NULL ) - start_time ; } if ( disconnected ) { crm_err ( ""Disconnected<S2SV_blank>while<S2SV_blank>waiting<S2SV_blank>for<S2SV_blank>reply."" ) ; return - ENOTCONN ; } else <S2SV_ModEnd> if ( op_reply
"
770,"CWE-119 static int evaluate_inter_mode_rd ( int mdcounts [ 4 ] , RATE_DISTORTION * rd , int * disable_skip , VP8_COMP * cpi , MACROBLOCK * x ) { MB_PREDICTION_MODE this_mode = x -> e_mbd . mode_info_context -> mbmi . mode ; BLOCK * b = & x -> block [ 0 ] ; MACROBLOCKD * xd = & x -> e_mbd ; int distortion ; vp8_build_inter16x16_predictors_mby ( & x -> e_mbd , x -> e_mbd . predictor , 16 ) ; if ( cpi -> active_map_enabled && x -> active_ptr [ 0 ] == 0 ) { x -> skip = 1 ; } else if ( x -> encode_breakout ) { unsigned int sse ; unsigned int var ; unsigned int threshold = ( xd -> block [ 0 ] . dequant [ 1 ] * xd -> block [ 0 ] . dequant [ 1 ] >> 4 ) ; if ( threshold < x -> encode_breakout ) threshold = x -> encode_breakout ; <S2SV_StartBug> var = vp8_variance16x16 <S2SV_EndBug> ( * ( b -> base_src ) , b -> src_stride , x -> e_mbd . predictor , 16 , & sse ) ; if ( sse < threshold ) { unsigned int q2dc = xd -> block [ 24 ] . dequant [ 0 ] ; if ( ( sse - var < q2dc * q2dc >> 4 ) || ( sse / 2 > var && sse - var < 64 ) ) { unsigned int sse2 = VP8_UVSSE ( x ) ; if ( sse2 * 2 < threshold ) { x -> skip = 1 ; rd -> distortion2 = sse + sse2 ; rd -> rate2 = 500 ; rd -> rate_uv = 0 ; rd -> distortion_uv = sse2 ; * disable_skip = 1 ; return RDCOST ( x -> rdmult , x -> rddiv , rd -> rate2 , rd -> distortion2 ) ; } } } } rd -> rate2 += vp8_cost_mv_ref ( this_mode , mdcounts ) ; macro_block_yrd ( x , & rd -> rate_y , & distortion ) ; rd -> rate2 += rd -> rate_y ; rd -> distortion2 += distortion ; rd_inter16x16_uv ( cpi , x , & rd -> rate_uv , & rd -> distortion_uv , cpi -> common . full_pixel ) ; rd -> rate2 += rd -> rate_uv ; rd -> distortion2 += rd -> distortion_uv ; return INT_MAX ; }
","<S2SV_ModStart> ; var = vpx_variance16x16 <S2SV_ModEnd> ( * (
"
771,"CWE-125 static void l2tp_q931_cc_print ( netdissect_options * ndo , const u_char * dat , u_int length ) <S2SV_StartBug> { <S2SV_EndBug> print_16bits_val ( ndo , ( const uint16_t * ) dat ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>%02x"" , dat [ 2 ] ) ) ; <S2SV_StartBug> if ( length > 3 ) { <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; <S2SV_StartBug> print_string ( ndo , dat + 3 , length - 3 ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> length ) { if ( length < 3 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } <S2SV_ModStart> ) ) ; dat += 3 ; length -= 3 ; <S2SV_ModStart> if ( length != 0 <S2SV_ModEnd> ) { ND_PRINT <S2SV_ModStart> ndo , dat , length <S2SV_ModEnd> ) ; }
"
772,"CWE-125 static int print_ipcp_config_options ( netdissect_options * ndo , const u_char * p , int length ) { int len , opt ; u_int compproto , ipcomp_subopttotallen , ipcomp_subopt , ipcomp_suboptlen ; if ( length < 2 ) return 0 ; ND_TCHECK2 ( * p , 2 ) ; len = p [ 1 ] ; opt = p [ 0 ] ; if ( length < len ) return 0 ; if ( len < 2 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>2)"" , tok2str ( ipcpopt_values , ""unknown"" , opt ) , opt , len ) ) ; return 0 ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( ipcpopt_values , ""unknown"" , opt ) , opt , len ) ) ; switch ( opt ) { case IPCPOPT_2ADDR : if ( len != 10 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>10)"" ) ) ; return len ; } ND_TCHECK2 ( * ( p + 6 ) , 4 ) ; ND_PRINT ( ( ndo , "":<S2SV_blank>src<S2SV_blank>%s,<S2SV_blank>dst<S2SV_blank>%s"" , ipaddr_string ( ndo , p + 2 ) , ipaddr_string ( ndo , p + 6 ) ) ) ; break ; case IPCPOPT_IPCOMP : if ( len < 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>4)"" ) ) ; return 0 ; } <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <S2SV_EndBug> compproto = EXTRACT_16BITS ( p + 2 ) ; ND_PRINT ( ( ndo , "":<S2SV_blank>%s<S2SV_blank>(0x%02x):"" , tok2str ( ipcpopt_compproto_values , ""Unknown"" , compproto ) , compproto ) ) ; switch ( compproto ) { case PPP_VJC : break ; case IPCPOPT_IPCOMP_HDRCOMP : if ( len < IPCPOPT_IPCOMP_MINLEN ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>%u)"" , IPCPOPT_IPCOMP_MINLEN ) ) ; return 0 ; } ND_TCHECK2 ( * ( p + 2 ) , IPCPOPT_IPCOMP_MINLEN ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>TCP<S2SV_blank>Space<S2SV_blank>%u,<S2SV_blank>non-TCP<S2SV_blank>Space<S2SV_blank>%u"" "",<S2SV_blank>maxPeriod<S2SV_blank>%u,<S2SV_blank>maxTime<S2SV_blank>%u,<S2SV_blank>maxHdr<S2SV_blank>%u"" , EXTRACT_16BITS ( p + 4 ) , EXTRACT_16BITS ( p + 6 ) , EXTRACT_16BITS ( p + 8 ) , EXTRACT_16BITS ( p + 10 ) , EXTRACT_16BITS ( p + 12 ) ) ) ; if ( len > IPCPOPT_IPCOMP_MINLEN ) { ipcomp_subopttotallen = len - IPCPOPT_IPCOMP_MINLEN ; p += IPCPOPT_IPCOMP_MINLEN ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Suboptions,<S2SV_blank>length<S2SV_blank>%u"" , ipcomp_subopttotallen ) ) ; while ( ipcomp_subopttotallen >= 2 ) { ND_TCHECK2 ( * p , 2 ) ; ipcomp_subopt = * p ; ipcomp_suboptlen = * ( p + 1 ) ; if ( ipcomp_subopt == 0 || ipcomp_suboptlen == 0 ) break ; ND_PRINT ( ( ndo , ""\\n\\t\\t%s<S2SV_blank>Suboption<S2SV_blank>#%u,<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( ipcpopt_compproto_subopt_values , ""Unknown"" , ipcomp_subopt ) , ipcomp_subopt , ipcomp_suboptlen ) ) ; ipcomp_subopttotallen -= ipcomp_suboptlen ; p += ipcomp_suboptlen ; } } break ; default : break ; } break ; case IPCPOPT_ADDR : case IPCPOPT_MOBILE4 : case IPCPOPT_PRIDNS : case IPCPOPT_PRINBNS : case IPCPOPT_SECDNS : case IPCPOPT_SECNBNS : if ( len != 6 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>6)"" ) ) ; return 0 ; } ND_TCHECK2 ( * ( p + 2 ) , 4 ) ; ND_PRINT ( ( ndo , "":<S2SV_blank>%s"" , ipaddr_string ( ndo , p + 2 ) ) ) ; break ; default : if ( ndo -> ndo_vflag < 2 ) print_unknown_data ( ndo , & p [ 2 ] , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len - 2 ) ; break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , & p [ 2 ] , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len - 2 ) ; return len ; trunc : ND_PRINT ( ( ndo , ""[|ipcp]"" ) ) ; return 0 ; }
","<S2SV_ModStart> 0 ; } ND_TCHECK_16BITS ( p + <S2SV_ModEnd> 2 ) ;
"
773,"CWE-125 static void wrap_lines_smart ( ASS_Renderer * render_priv , double max_text_width ) { int i ; GlyphInfo * cur , * s1 , * e1 , * s2 , * s3 ; int last_space ; int break_type ; int exit ; double pen_shift_x ; double pen_shift_y ; int cur_line ; int run_offset ; TextInfo * text_info = & render_priv -> text_info ; last_space = - 1 ; text_info -> n_lines = 1 ; break_type = 0 ; s1 = text_info -> glyphs ; for ( i = 0 ; i < text_info -> length ; ++ i ) { int break_at = - 1 ; double s_offset , len ; cur = text_info -> glyphs + i ; s_offset = d6_to_double ( s1 -> bbox . xMin + s1 -> pos . x ) ; len = d6_to_double ( cur -> bbox . xMax + cur -> pos . x ) - s_offset ; if ( cur -> symbol == '\\n' ) { break_type = 2 ; break_at = i ; ass_msg ( render_priv -> library , MSGL_DBG2 , ""forced<S2SV_blank>line<S2SV_blank>break<S2SV_blank>at<S2SV_blank>%d"" , break_at ) ; } else if ( cur -> symbol == '<S2SV_blank>' ) { last_space = i ; } else if ( len >= max_text_width && ( render_priv -> state . wrap_style != 2 ) ) { break_type = 1 ; break_at = last_space ; if ( break_at >= 0 ) ass_msg ( render_priv -> library , MSGL_DBG2 , ""line<S2SV_blank>break<S2SV_blank>at<S2SV_blank>%d"" , break_at ) ; } if ( break_at != - 1 ) { int lead = break_at + 1 ; if ( text_info -> n_lines >= text_info -> max_lines ) { text_info -> max_lines *= 2 ; text_info -> lines = realloc ( text_info -> lines , sizeof ( LineInfo ) * text_info -> max_lines ) ; } if ( lead < text_info -> length ) { text_info -> glyphs [ lead ] . linebreak = break_type ; last_space = - 1 ; s1 = text_info -> glyphs + lead ; text_info -> n_lines ++ ; } } } # define DIFF ( x , y ) ( ( ( x ) < ( y ) ) ? ( y - x ) : ( x - y ) ) exit = 0 ; while ( ! exit && render_priv -> state . wrap_style != 1 ) { exit = 1 ; s3 = text_info -> glyphs ; s1 = s2 = 0 ; for ( i = 0 ; i <= text_info -> length ; ++ i ) { cur = text_info -> glyphs + i ; if ( ( i == text_info -> length ) || cur -> linebreak ) { s1 = s2 ; s2 = s3 ; s3 = cur ; if ( s1 && ( s2 -> linebreak == 1 ) ) { double l1 , l2 , l1_new , l2_new ; GlyphInfo * w = s2 ; do { -- w ; } while ( ( w > s1 ) && ( w -> symbol == '<S2SV_blank>' ) ) ; while ( ( w > s1 ) && ( w -> symbol != '<S2SV_blank>' ) ) { -- w ; } e1 = w ; while ( ( e1 > s1 ) && ( e1 -> symbol == '<S2SV_blank>' ) ) { -- e1 ; } if ( w -> symbol == '<S2SV_blank>' ) ++ w ; l1 = d6_to_double ( ( ( s2 - 1 ) -> bbox . xMax + ( s2 - 1 ) -> pos . x ) - ( s1 -> bbox . xMin + s1 -> pos . x ) ) ; l2 = d6_to_double ( ( ( s3 - 1 ) -> bbox . xMax + ( s3 - 1 ) -> pos . x ) - ( s2 -> bbox . xMin + s2 -> pos . x ) ) ; l1_new = d6_to_double ( ( e1 -> bbox . xMax + e1 -> pos . x ) - ( s1 -> bbox . xMin + s1 -> pos . x ) ) ; l2_new = d6_to_double ( ( ( s3 - 1 ) -> bbox . xMax + ( s3 - 1 ) -> pos . x ) - ( w -> bbox . xMin + w -> pos . x ) ) ; if ( DIFF ( l1_new , l2_new ) < DIFF ( l1 , l2 ) ) { <S2SV_StartBug> w -> linebreak = 1 ; <S2SV_EndBug> s2 -> linebreak = 0 ; exit = 0 ; } } } if ( i == text_info -> length ) break ; } } assert ( text_info -> n_lines >= 1 ) ; # undef DIFF measure_text ( render_priv ) ; trim_whitespace ( render_priv ) ; cur_line = 1 ; run_offset = 0 ; i = 0 ; cur = text_info -> glyphs + i ; while ( i < text_info -> length && cur -> skip ) cur = text_info -> glyphs + ++ i ; pen_shift_x = d6_to_double ( - cur -> pos . x ) ; pen_shift_y = 0. ; for ( i = 0 ; i < text_info -> length ; ++ i ) { cur = text_info -> glyphs + i ; if ( cur -> linebreak ) { while ( i < text_info -> length && cur -> skip && cur -> symbol != '\\n' ) cur = text_info -> glyphs + ++ i ; double height = text_info -> lines [ cur_line - 1 ] . desc + text_info -> lines [ cur_line ] . asc ; text_info -> lines [ cur_line - 1 ] . len = i - text_info -> lines [ cur_line - 1 ] . offset ; text_info -> lines [ cur_line ] . offset = i ; cur_line ++ ; run_offset ++ ; pen_shift_x = d6_to_double ( - cur -> pos . x ) ; pen_shift_y += height + render_priv -> settings . line_spacing ; } cur -> pos . x += double_to_d6 ( pen_shift_x ) ; cur -> pos . y += double_to_d6 ( pen_shift_y ) ; } text_info -> lines [ cur_line - 1 ] . len = text_info -> length - text_info -> lines [ cur_line - 1 ] . offset ; # if 0 for ( i = 0 ; i < text_info -> n_lines ; i ++ ) { printf ( ""line<S2SV_blank>%d<S2SV_blank>offset<S2SV_blank>%d<S2SV_blank>length<S2SV_blank>%d\\n"" , i , text_info -> lines [ i ] . offset , text_info -> lines [ i ] . len ) ; } # endif }
","<S2SV_ModStart> ) ) { if ( w -> linebreak || w == text_info -> glyphs ) text_info -> n_lines -- ; if ( w != text_info -> glyphs )
"
774,"CWE-264 static int cg_opendir ( const char * path , struct fuse_file_info * fi ) { struct fuse_context * fc = fuse_get_context ( ) ; const char * cgroup ; struct file_info * dir_info ; char * controller = NULL ; if ( ! fc ) return - EIO ; if ( strcmp ( path , ""/cgroup"" ) == 0 ) { cgroup = NULL ; controller = NULL ; } else { controller = pick_controller_from_path ( fc , path ) ; if ( ! controller ) return - EIO ; cgroup = find_cgroup_in_path ( path ) ; if ( ! cgroup ) { cgroup = ""/"" ; } } <S2SV_StartBug> if ( cgroup && ! fc_may_access ( fc , controller , cgroup , NULL , O_RDONLY ) ) { <S2SV_EndBug> return - EACCES ; } dir_info = malloc ( sizeof ( * dir_info ) ) ; if ( ! dir_info ) return - ENOMEM ; dir_info -> controller = must_copy_string ( controller ) ; dir_info -> cgroup = must_copy_string ( cgroup ) ; dir_info -> type = LXC_TYPE_CGDIR ; dir_info -> buf = NULL ; dir_info -> file = NULL ; dir_info -> buflen = 0 ; fi -> fh = ( unsigned long ) dir_info ; return 0 ; }
","<S2SV_ModStart> if ( cgroup ) { if ( ! caller_may_see_dir ( fc -> pid , controller , cgroup ) ) return - ENOENT ; if ( <S2SV_ModEnd> ! fc_may_access ( <S2SV_ModStart> O_RDONLY ) ) <S2SV_ModEnd> return - EACCES
"
775,"CWE-119 static void ppp_hdlc ( netdissect_options * ndo , const u_char * p , int length ) { <S2SV_StartBug> u_char * b , * s , * t , c ; <S2SV_EndBug> int i , proto ; const void * se ; if ( length <= 0 ) return ; <S2SV_StartBug> b = ( uint8_t * ) malloc ( length ) ; <S2SV_EndBug> if ( b == NULL ) return ; <S2SV_StartBug> for ( s = ( u_char * ) p , t = b , i = length ; i > 0 ; i -- ) { <S2SV_EndBug> c = * s ++ ; if ( c == 0x7d ) { <S2SV_StartBug> if ( i > 1 ) { <S2SV_EndBug> i -- ; <S2SV_StartBug> c = * s ++ ^ 0x20 ; <S2SV_EndBug> } else continue ; } * t ++ = c ; } se = ndo -> ndo_snapend ; ndo -> ndo_snapend = t ; length = t - b ; if ( length < 1 ) goto trunc ; proto = * b ; switch ( proto ) { case PPP_IP : ip_print ( ndo , b + 1 , length - 1 ) ; goto cleanup ; case PPP_IPV6 : ip6_print ( ndo , b + 1 , length - 1 ) ; goto cleanup ; default : break ; } if ( length < 2 ) goto trunc ; proto = EXTRACT_16BITS ( b ) ; switch ( proto ) { case ( PPP_ADDRESS << 8 | PPP_CONTROL ) : if ( length < 4 ) goto trunc ; proto = EXTRACT_16BITS ( b + 2 ) ; handle_ppp ( ndo , proto , b + 4 , length - 4 ) ; break ; default : handle_ppp ( ndo , proto , b + 2 , length - 2 ) ; break ; } cleanup : ndo -> ndo_snapend = se ; free ( b ) ; return ; trunc : ndo -> ndo_snapend = se ; free ( b ) ; ND_PRINT ( ( ndo , ""[|ppp]"" ) ) ; }
","<S2SV_ModStart> b , * <S2SV_ModEnd> t , c <S2SV_ModStart> t , c ; const u_char * s <S2SV_ModStart> b = ( u_char <S2SV_ModEnd> * ) malloc <S2SV_ModStart> ( s = <S2SV_ModEnd> p , t <S2SV_ModStart> i > 0 && ND_TTEST ( * s ) <S2SV_ModStart> if ( i <= 1 || ! ND_TTEST ( * s ) ) break ; <S2SV_ModEnd> i -- ; <S2SV_ModStart> ++ ^ 0x20 <S2SV_ModEnd> ; } *
"
776,"CWE-415 const char * util_acl_to_str ( const sc_acl_entry_t * e ) { static char line [ 80 ] , buf [ 20 ] ; unsigned int acl ; if ( e == NULL ) return ""N/A"" ; line [ 0 ] = 0 ; while ( e != NULL ) { acl = e -> method ; switch ( acl ) { case SC_AC_UNKNOWN : return ""N/A"" ; case SC_AC_NEVER : return ""NEVR"" ; case SC_AC_NONE : return ""NONE"" ; case SC_AC_CHV : strcpy ( buf , ""CHV"" ) ; if ( e -> key_ref != SC_AC_KEY_REF_NONE ) sprintf ( buf + 3 , ""%d"" , e -> key_ref ) ; break ; case SC_AC_TERM : strcpy ( buf , ""TERM"" ) ; break ; case SC_AC_PRO : strcpy ( buf , ""PROT"" ) ; break ; case SC_AC_AUT : strcpy ( buf , ""AUTH"" ) ; if ( e -> key_ref != SC_AC_KEY_REF_NONE ) sprintf ( buf + 4 , ""%d"" , e -> key_ref ) ; break ; case SC_AC_SEN : strcpy ( buf , ""Sec.Env.<S2SV_blank>"" ) ; if ( e -> key_ref != SC_AC_KEY_REF_NONE ) sprintf ( buf + 3 , ""#%d"" , e -> key_ref ) ; break ; case SC_AC_SCB : strcpy ( buf , ""Sec.ControlByte<S2SV_blank>"" ) ; if ( e -> key_ref != SC_AC_KEY_REF_NONE ) sprintf ( buf + 3 , ""Ox%X"" , e -> key_ref ) ; break ; case SC_AC_IDA : strcpy ( buf , ""PKCS#15<S2SV_blank>AuthID<S2SV_blank>"" ) ; if ( e -> key_ref != SC_AC_KEY_REF_NONE ) sprintf ( buf + 3 , ""#%d"" , e -> key_ref ) ; break ; default : strcpy ( buf , ""????"" ) ; break ; } <S2SV_StartBug> strcat ( line , buf ) ; <S2SV_EndBug> <S2SV_StartBug> strcat ( line , ""<S2SV_blank>"" ) ; <S2SV_EndBug> e = e -> next ; } <S2SV_StartBug> line [ strlen ( line ) - 1 ] = 0 ; <S2SV_EndBug> return line ; }
","<S2SV_ModStart> break ; } strncat ( line , buf , sizeof line ) ; strncat <S2SV_ModEnd> ( line , <S2SV_ModStart> line , ""<S2SV_blank>"" , sizeof line <S2SV_ModStart> } line [ ( sizeof <S2SV_ModEnd> line ) - <S2SV_ModStart> 1 ] = '\\0' ; line [ strlen ( line ) - 1 ] =
"
777,"CWE-284 static int http_connect ( http_subtransport * t ) { int error ; char * proxy_url ; if ( t -> connected && http_should_keep_alive ( & t -> parser ) && t -> parse_finished ) return 0 ; if ( t -> io ) { git_stream_close ( t -> io ) ; git_stream_free ( t -> io ) ; t -> io = NULL ; t -> connected = 0 ; } if ( t -> connection_data . use_ssl ) { error = git_tls_stream_new ( & t -> io , t -> connection_data . host , t -> connection_data . port ) ; } else { # ifdef GIT_CURL error = git_curl_stream_new ( & t -> io , t -> connection_data . host , t -> connection_data . port ) ; # else error = git_socket_stream_new ( & t -> io , t -> connection_data . host , t -> connection_data . port ) ; # endif } if ( error < 0 ) return error ; GITERR_CHECK_VERSION ( t -> io , GIT_STREAM_VERSION , ""git_stream"" ) ; if ( git_stream_supports_proxy ( t -> io ) && ! git_remote__get_http_proxy ( t -> owner -> owner , ! ! t -> connection_data . use_ssl , & proxy_url ) ) { error = git_stream_set_proxy ( t -> io , proxy_url ) ; git__free ( proxy_url ) ; if ( error < 0 ) return error ; } error = git_stream_connect ( t -> io ) ; # if defined ( GIT_OPENSSL ) || defined ( GIT_SECURE_TRANSPORT ) || defined ( GIT_CURL ) if ( ( ! error || error == GIT_ECERTIFICATE ) && t -> owner -> certificate_check_cb != NULL && git_stream_is_encrypted ( t -> io ) ) { git_cert * cert ; <S2SV_StartBug> int is_valid ; <S2SV_EndBug> if ( ( error = git_stream_certificate ( & cert , t -> io ) ) < 0 ) return error ; <S2SV_StartBug> giterr_clear ( ) ; <S2SV_EndBug> is_valid = error != GIT_ECERTIFICATE ; error = t -> owner -> certificate_check_cb ( cert , is_valid , t -> connection_data . host , t -> owner -> message_cb_payload ) ; if ( error < 0 ) { if ( ! giterr_last ( ) ) giterr_set ( GITERR_NET , ""user<S2SV_blank>cancelled<S2SV_blank>certificate<S2SV_blank>check"" ) ; return error ; } } # endif if ( error < 0 ) return error ; t -> connected = 1 ; return 0 ; }
","<S2SV_ModStart> ; int is_valid = ( error == GIT_OK ) <S2SV_ModStart> giterr_clear ( ) <S2SV_ModEnd> ; error =
"
778,"CWE-416 struct sk_buff * skb_segment ( struct sk_buff * head_skb , netdev_features_t features ) { struct sk_buff * segs = NULL ; struct sk_buff * tail = NULL ; struct sk_buff * list_skb = skb_shinfo ( head_skb ) -> frag_list ; skb_frag_t * frag = skb_shinfo ( head_skb ) -> frags ; unsigned int mss = skb_shinfo ( head_skb ) -> gso_size ; <S2SV_StartBug> unsigned int doffset = head_skb -> data - skb_mac_header ( head_skb ) ; <S2SV_EndBug> unsigned int offset = doffset ; unsigned int tnl_hlen = skb_tnl_header_len ( head_skb ) ; unsigned int headroom ; unsigned int len ; __be16 proto ; bool csum ; int sg = ! ! ( features & NETIF_F_SG ) ; int nfrags = skb_shinfo ( head_skb ) -> nr_frags ; int err = - ENOMEM ; int i = 0 ; int pos ; proto = skb_network_protocol ( head_skb ) ; if ( unlikely ( ! proto ) ) return ERR_PTR ( - EINVAL ) ; csum = ! ! can_checksum_protocol ( features , proto ) ; __skb_push ( head_skb , doffset ) ; headroom = skb_headroom ( head_skb ) ; pos = skb_headlen ( head_skb ) ; do { struct sk_buff * nskb ; skb_frag_t * nskb_frag ; int hsize ; int size ; len = head_skb -> len - offset ; if ( len > mss ) len = mss ; hsize = skb_headlen ( head_skb ) - offset ; if ( hsize < 0 ) hsize = 0 ; if ( hsize > len || ! sg ) hsize = len ; if ( ! hsize && i >= nfrags && skb_headlen ( list_skb ) && ( skb_headlen ( list_skb ) == len || sg ) ) { BUG_ON ( skb_headlen ( list_skb ) > len ) ; i = 0 ; nfrags = skb_shinfo ( list_skb ) -> nr_frags ; frag = skb_shinfo ( list_skb ) -> frags ; <S2SV_StartBug> pos += skb_headlen ( list_skb ) ; <S2SV_EndBug> while ( pos < offset + len ) { BUG_ON ( i >= nfrags ) ; size = skb_frag_size ( frag ) ; if ( pos + size > offset + len ) break ; i ++ ; pos += size ; frag ++ ; } nskb = skb_clone ( list_skb , GFP_ATOMIC ) ; list_skb = list_skb -> next ; if ( unlikely ( ! nskb ) ) goto err ; if ( unlikely ( pskb_trim ( nskb , len ) ) ) { kfree_skb ( nskb ) ; goto err ; } hsize = skb_end_offset ( nskb ) ; if ( skb_cow_head ( nskb , doffset + headroom ) ) { kfree_skb ( nskb ) ; goto err ; } nskb -> truesize += skb_end_offset ( nskb ) - hsize ; skb_release_head_state ( nskb ) ; __skb_push ( nskb , doffset ) ; } else { nskb = __alloc_skb ( hsize + doffset + headroom , GFP_ATOMIC , skb_alloc_rx_flag ( head_skb ) , NUMA_NO_NODE ) ; if ( unlikely ( ! nskb ) ) goto err ; skb_reserve ( nskb , headroom ) ; __skb_put ( nskb , doffset ) ; } if ( segs ) tail -> next = nskb ; else segs = nskb ; tail = nskb ; __copy_skb_header ( nskb , head_skb ) ; nskb -> mac_len = head_skb -> mac_len ; skb_headers_offset_update ( nskb , skb_headroom ( nskb ) - headroom ) ; skb_copy_from_linear_data_offset ( head_skb , - tnl_hlen , nskb -> data - tnl_hlen , doffset + tnl_hlen ) ; if ( nskb -> len == len + doffset ) goto perform_csum_check ; if ( ! sg ) { nskb -> ip_summed = CHECKSUM_NONE ; nskb -> csum = skb_copy_and_csum_bits ( head_skb , offset , skb_put ( nskb , len ) , len , 0 ) ; continue ; } nskb_frag = skb_shinfo ( nskb ) -> frags ; skb_copy_from_linear_data_offset ( head_skb , offset , skb_put ( nskb , hsize ) , hsize ) ; skb_shinfo ( nskb ) -> tx_flags = skb_shinfo ( head_skb ) -> tx_flags & SKBTX_SHARED_FRAG ; while ( pos < offset + len ) { if ( i >= nfrags ) { BUG_ON ( skb_headlen ( list_skb ) ) ; i = 0 ; nfrags = skb_shinfo ( list_skb ) -> nr_frags ; frag = skb_shinfo ( list_skb ) -> frags ; <S2SV_StartBug> BUG_ON ( ! nfrags ) ; <S2SV_EndBug> list_skb = list_skb -> next ; } if ( unlikely ( skb_shinfo ( nskb ) -> nr_frags >= MAX_SKB_FRAGS ) ) { net_warn_ratelimited ( ""skb_segment:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>frags:<S2SV_blank>%u<S2SV_blank>%u\\n"" , pos , mss ) ; goto err ; } <S2SV_StartBug> * nskb_frag = * frag ; <S2SV_EndBug> __skb_frag_ref ( nskb_frag ) ; size = skb_frag_size ( nskb_frag ) ; if ( pos < offset ) { nskb_frag -> page_offset += offset - pos ; skb_frag_size_sub ( nskb_frag , offset - pos ) ; } skb_shinfo ( nskb ) -> nr_frags ++ ; if ( pos + size <= offset + len ) { i ++ ; frag ++ ; pos += size ; } else { skb_frag_size_sub ( nskb_frag , pos + size - ( offset + len ) ) ; goto skip_fraglist ; } nskb_frag ++ ; } skip_fraglist : nskb -> data_len = len - hsize ; nskb -> len += nskb -> data_len ; nskb -> truesize += nskb -> data_len ; perform_csum_check : if ( ! csum ) { nskb -> csum = skb_checksum ( nskb , doffset , nskb -> len - doffset , 0 ) ; nskb -> ip_summed = CHECKSUM_NONE ; } } while ( ( offset += len ) < head_skb -> len ) ; return segs ; err : kfree_skb_list ( segs ) ; return ERR_PTR ( err ) ; }
","<S2SV_ModStart> ( head_skb ) ; struct sk_buff * frag_skb = head_skb <S2SV_ModStart> -> frags ; frag_skb = list_skb ; <S2SV_ModStart> -> frags ; frag_skb = list_skb ; <S2SV_ModStart> err ; } if ( unlikely ( skb_orphan_frags ( frag_skb , GFP_ATOMIC ) ) ) goto err ;
"
779,"CWE-119 static void * load_bytes ( RBinFile * arch , const ut8 * buf , ut64 sz , ut64 loaddr , Sdb * sdb ) { if ( ! buf || ! sz || sz == UT64_MAX ) { return NULL ; } RBuffer * tbuf = r_buf_new ( ) ; <S2SV_StartBug> r_buf_set_bytes ( tbuf , buf , sz ) ; <S2SV_EndBug> struct r_bin_bflt_obj * res = r_bin_bflt_new_buf ( tbuf ) ; r_buf_free ( tbuf ) ; return res ? res : NULL ; }
","<S2SV_ModStart> ( ) ; if ( ! tbuf ) { return NULL ; }
"
780,"CWE-119 <S2SV_StartBug> static INLINE void read_mv ( vp9_reader * r , MV * mv , const MV * ref , <S2SV_EndBug> const nmv_context * ctx , nmv_context_counts * counts , int allow_hp ) { const MV_JOINT_TYPE joint_type = <S2SV_StartBug> ( MV_JOINT_TYPE ) vp9_read_tree ( r , vp9_mv_joint_tree , ctx -> joints ) ; <S2SV_EndBug> const int use_hp = allow_hp && vp9_use_mv_hp ( ref ) ; MV diff = { 0 , 0 } ; if ( mv_joint_vertical ( joint_type ) ) diff . row = read_mv_component ( r , & ctx -> comps [ 0 ] , use_hp ) ; if ( mv_joint_horizontal ( joint_type ) ) diff . col = read_mv_component ( r , & ctx -> comps [ 1 ] , use_hp ) ; vp9_inc_mv ( & diff , counts ) ; mv -> row = ref -> row + diff . row ; mv -> col = ref -> col + diff . col ; }
","<S2SV_ModStart> void read_mv ( vpx_reader <S2SV_ModEnd> * r , <S2SV_ModStart> ( MV_JOINT_TYPE ) vpx_read_tree <S2SV_ModEnd> ( r ,
"
781,"CWE-119 static int check_line_charstring ( void ) { char * p = line ; <S2SV_StartBug> while ( isspace ( * p ) ) <S2SV_EndBug> p ++ ; return ( * p == '/' || ( p [ 0 ] == 'd' && p [ 1 ] == 'u' && p [ 2 ] == 'p' ) ) ; }
","<S2SV_ModStart> ( isspace ( ( unsigned char )
"
782,"CWE-416 static ssize_t bsg_write ( struct file * file , const char __user * buf , size_t count , loff_t * ppos ) { struct bsg_device * bd = file -> private_data ; ssize_t bytes_written ; int ret ; <S2SV_StartBug> dprintk ( ""%s:<S2SV_blank>write<S2SV_blank>%Zd<S2SV_blank>bytes\\n"" , bd -> name , count ) ; <S2SV_EndBug> bsg_set_block ( bd , file ) ; bytes_written = 0 ; ret = __bsg_write ( bd , buf , count , & bytes_written , file -> f_mode & FMODE_WRITE ) ; * ppos = bytes_written ; if ( ! bytes_written || err_block_err ( ret ) ) bytes_written = ret ; dprintk ( ""%s:<S2SV_blank>returning<S2SV_blank>%Zd\\n"" , bd -> name , bytes_written ) ; return bytes_written ; }
","<S2SV_ModStart> , count ) ; if ( unlikely ( segment_eq ( get_fs ( ) , KERNEL_DS ) ) ) return - EINVAL
"
783,"CWE-20 int key_update ( key_ref_t key_ref , const void * payload , size_t plen ) { struct key_preparsed_payload prep ; struct key * key = key_ref_to_ptr ( key_ref ) ; int ret ; key_check ( key ) ; ret = key_permission ( key_ref , KEY_NEED_WRITE ) ; if ( ret < 0 ) return ret ; if ( ! key -> type -> update ) return - EOPNOTSUPP ; memset ( & prep , 0 , sizeof ( prep ) ) ; prep . data = payload ; prep . datalen = plen ; prep . quotalen = key -> type -> def_datalen ; prep . expiry = TIME_T_MAX ; if ( key -> type -> preparse ) { ret = key -> type -> preparse ( & prep ) ; if ( ret < 0 ) goto error ; } down_write ( & key -> sem ) ; ret = key -> type -> update ( key , & prep ) ; if ( ret == 0 ) <S2SV_StartBug> clear_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ; <S2SV_EndBug> up_write ( & key -> sem ) ; error : if ( key -> type -> preparse ) key -> type -> free_preparse ( & prep ) ; return ret ; }
","<S2SV_ModStart> == 0 ) mark_key_instantiated ( key , 0 <S2SV_ModEnd> ) ; up_write
"
784,"CWE-399 static void do_free_upto ( BIO * f , BIO * upto ) { if ( upto ) { BIO * tbio ; do { tbio = BIO_pop ( f ) ; BIO_free ( f ) ; f = tbio ; } <S2SV_StartBug> while ( f != upto ) ; <S2SV_EndBug> } else BIO_free_all ( f ) ; }
","<S2SV_ModStart> while ( f && f
"
785,"CWE-264 static ssize_t ib_uverbs_write ( struct file * filp , const char __user * buf , size_t count , loff_t * pos ) { struct ib_uverbs_file * file = filp -> private_data ; struct ib_device * ib_dev ; struct ib_uverbs_cmd_hdr hdr ; __u32 command ; __u32 flags ; int srcu_key ; ssize_t ret ; <S2SV_StartBug> if ( count < sizeof hdr ) <S2SV_EndBug> return - EINVAL ; if ( copy_from_user ( & hdr , buf , sizeof hdr ) ) return - EFAULT ; srcu_key = srcu_read_lock ( & file -> device -> disassociate_srcu ) ; ib_dev = srcu_dereference ( file -> device -> ib_dev , & file -> device -> disassociate_srcu ) ; if ( ! ib_dev ) { ret = - EIO ; goto out ; } if ( hdr . command & ~ ( __u32 ) ( IB_USER_VERBS_CMD_FLAGS_MASK | IB_USER_VERBS_CMD_COMMAND_MASK ) ) { ret = - EINVAL ; goto out ; } command = hdr . command & IB_USER_VERBS_CMD_COMMAND_MASK ; if ( verify_command_mask ( ib_dev , command ) ) { ret = - EOPNOTSUPP ; goto out ; } if ( ! file -> ucontext && command != IB_USER_VERBS_CMD_GET_CONTEXT ) { ret = - EINVAL ; goto out ; } flags = ( hdr . command & IB_USER_VERBS_CMD_FLAGS_MASK ) >> IB_USER_VERBS_CMD_FLAGS_SHIFT ; if ( ! flags ) { if ( command >= ARRAY_SIZE ( uverbs_cmd_table ) || ! uverbs_cmd_table [ command ] ) { ret = - EINVAL ; goto out ; } if ( hdr . in_words * 4 != count ) { ret = - EINVAL ; goto out ; } ret = uverbs_cmd_table [ command ] ( file , ib_dev , buf + sizeof ( hdr ) , hdr . in_words * 4 , hdr . out_words * 4 ) ; } else if ( flags == IB_USER_VERBS_CMD_FLAG_EXTENDED ) { struct ib_uverbs_ex_cmd_hdr ex_hdr ; struct ib_udata ucore ; struct ib_udata uhw ; size_t written_count = count ; if ( command >= ARRAY_SIZE ( uverbs_ex_cmd_table ) || ! uverbs_ex_cmd_table [ command ] ) { ret = - ENOSYS ; goto out ; } if ( ! file -> ucontext ) { ret = - EINVAL ; goto out ; } if ( count < ( sizeof ( hdr ) + sizeof ( ex_hdr ) ) ) { ret = - EINVAL ; goto out ; } if ( copy_from_user ( & ex_hdr , buf + sizeof ( hdr ) , sizeof ( ex_hdr ) ) ) { ret = - EFAULT ; goto out ; } count -= sizeof ( hdr ) + sizeof ( ex_hdr ) ; buf += sizeof ( hdr ) + sizeof ( ex_hdr ) ; if ( ( hdr . in_words + ex_hdr . provider_in_words ) * 8 != count ) { ret = - EINVAL ; goto out ; } if ( ex_hdr . cmd_hdr_reserved ) { ret = - EINVAL ; goto out ; } if ( ex_hdr . response ) { if ( ! hdr . out_words && ! ex_hdr . provider_out_words ) { ret = - EINVAL ; goto out ; } if ( ! access_ok ( VERIFY_WRITE , ( void __user * ) ( unsigned long ) ex_hdr . response , ( hdr . out_words + ex_hdr . provider_out_words ) * 8 ) ) { ret = - EFAULT ; goto out ; } } else { if ( hdr . out_words || ex_hdr . provider_out_words ) { ret = - EINVAL ; goto out ; } } INIT_UDATA_BUF_OR_NULL ( & ucore , buf , ( unsigned long ) ex_hdr . response , hdr . in_words * 8 , hdr . out_words * 8 ) ; INIT_UDATA_BUF_OR_NULL ( & uhw , buf + ucore . inlen , ( unsigned long ) ex_hdr . response + ucore . outlen , ex_hdr . provider_in_words * 8 , ex_hdr . provider_out_words * 8 ) ; ret = uverbs_ex_cmd_table [ command ] ( file , ib_dev , & ucore , & uhw ) ; if ( ! ret ) ret = written_count ; } else { ret = - ENOSYS ; } out : srcu_read_unlock ( & file -> device -> disassociate_srcu , srcu_key ) ; return ret ; }
","<S2SV_ModStart> ; if ( WARN_ON_ONCE ( ! ib_safe_file_access ( filp ) ) ) return - EACCES ; if (
"
786,"CWE-200 unsigned paravirt_patch_jmp ( void * insnbuf , const void * target , unsigned long addr , unsigned len ) { struct branch * b = insnbuf ; unsigned long delta = ( unsigned long ) target - ( addr + 5 ) ; <S2SV_StartBug> if ( len < 5 ) <S2SV_EndBug> <S2SV_StartBug> return len ; <S2SV_EndBug> b -> opcode = 0xe9 ; b -> delta = delta ; return 5 ; }
","<S2SV_ModStart> < 5 ) { # ifdef CONFIG_RETPOLINE WARN_ONCE ( ""Failing<S2SV_blank>to<S2SV_blank>patch<S2SV_blank>indirect<S2SV_blank>JMP<S2SV_blank>in<S2SV_blank>%ps\\n"" , ( void * ) addr ) ; # endif <S2SV_ModStart> return len ; }
"
787,"CWE-190 <S2SV_StartBug> int mongo_env_read_socket ( mongo * conn , void * buf , int len ) { <S2SV_EndBug> char * cbuf = buf ; while ( len ) { <S2SV_StartBug> int sent = recv ( conn -> sock , cbuf , len , 0 ) ; <S2SV_EndBug> if ( sent == 0 || sent == - 1 ) { __mongo_set_error ( conn , MONGO_IO_ERROR , strerror ( errno ) , errno ) ; return MONGO_ERROR ; } cbuf += sent ; len -= sent ; } return MONGO_OK ; }
","<S2SV_ModStart> * buf , size_t <S2SV_ModEnd> len ) { <S2SV_ModStart> len ) { size_t <S2SV_ModEnd> sent = recv
"
788,"CWE-189 int do_adjtimex ( struct timex * txc ) { <S2SV_StartBug> long mtemp , save_adjust , rem ; <S2SV_EndBug> s64 freq_adj ; int result ; if ( txc -> modes && ! capable ( CAP_SYS_TIME ) ) return - EPERM ; if ( ( txc -> modes & ADJ_OFFSET_SINGLESHOT ) == ADJ_OFFSET_SINGLESHOT ) { if ( txc -> modes != ADJ_OFFSET_SINGLESHOT && txc -> modes != ADJ_OFFSET_SS_READ ) return - EINVAL ; } if ( txc -> modes != ADJ_OFFSET_SINGLESHOT && ( txc -> modes & ADJ_OFFSET ) ) if ( txc -> offset <= - MAXPHASE || txc -> offset >= MAXPHASE ) return - EINVAL ; if ( txc -> modes & ADJ_TICK ) if ( txc -> tick < 900000 / USER_HZ || txc -> tick > 1100000 / USER_HZ ) return - EINVAL ; write_seqlock_irq ( & xtime_lock ) ; result = time_state ; save_adjust = time_adjust ; # if 0 time_status &= ~ STA_CLOCKERR ; # endif if ( txc -> modes ) { if ( txc -> modes & ADJ_STATUS ) time_status = ( txc -> status & ~ STA_RONLY ) | ( time_status & STA_RONLY ) ; if ( txc -> modes & ADJ_FREQUENCY ) { if ( txc -> freq > MAXFREQ || txc -> freq < - MAXFREQ ) { result = - EINVAL ; goto leave ; } time_freq = ( ( s64 ) txc -> freq * NSEC_PER_USEC ) >> ( SHIFT_USEC - SHIFT_NSEC ) ; } if ( txc -> modes & ADJ_MAXERROR ) { if ( txc -> maxerror < 0 || txc -> maxerror >= NTP_PHASE_LIMIT ) { result = - EINVAL ; goto leave ; } time_maxerror = txc -> maxerror ; } if ( txc -> modes & ADJ_ESTERROR ) { if ( txc -> esterror < 0 || txc -> esterror >= NTP_PHASE_LIMIT ) { result = - EINVAL ; goto leave ; } time_esterror = txc -> esterror ; } if ( txc -> modes & ADJ_TIMECONST ) { if ( txc -> constant < 0 ) { result = - EINVAL ; goto leave ; } time_constant = min ( txc -> constant + 4 , ( long ) MAXTC ) ; } if ( txc -> modes & ADJ_OFFSET ) { if ( txc -> modes == ADJ_OFFSET_SINGLESHOT ) { time_adjust = txc -> offset ; } else if ( time_status & STA_PLL ) { time_offset = txc -> offset * NSEC_PER_USEC ; time_offset = min ( time_offset , ( s64 ) MAXPHASE * NSEC_PER_USEC ) ; time_offset = max ( time_offset , ( s64 ) - MAXPHASE * NSEC_PER_USEC ) ; if ( time_status & STA_FREQHOLD || time_reftime == 0 ) time_reftime = xtime . tv_sec ; mtemp = xtime . tv_sec - time_reftime ; time_reftime = xtime . tv_sec ; freq_adj = time_offset * mtemp ; freq_adj = shift_right ( freq_adj , time_constant * 2 + ( SHIFT_PLL + 2 ) * 2 - SHIFT_NSEC ) ; if ( mtemp >= MINSEC && ( time_status & STA_FLL || mtemp > MAXSEC ) ) freq_adj += div_s64 ( time_offset << ( SHIFT_NSEC - SHIFT_FLL ) , mtemp ) ; freq_adj += time_freq ; freq_adj = min ( freq_adj , ( s64 ) MAXFREQ_NSEC ) ; time_freq = max ( freq_adj , ( s64 ) - MAXFREQ_NSEC ) ; <S2SV_StartBug> time_offset = div_long_long_rem_signed ( time_offset , <S2SV_EndBug> <S2SV_StartBug> NTP_INTERVAL_FREQ , <S2SV_EndBug> & rem ) ; time_offset <<= SHIFT_UPDATE ; } } if ( txc -> modes & ADJ_TICK ) tick_usec = txc -> tick ; if ( txc -> modes & ( ADJ_TICK | ADJ_FREQUENCY | ADJ_OFFSET ) ) ntp_update_frequency ( ) ; } leave : if ( ( time_status & ( STA_UNSYNC | STA_CLOCKERR ) ) != 0 ) result = TIME_ERROR ; if ( ( txc -> modes == ADJ_OFFSET_SINGLESHOT ) || ( txc -> modes == ADJ_OFFSET_SS_READ ) ) txc -> offset = save_adjust ; else txc -> offset = ( ( long ) shift_right ( time_offset , SHIFT_UPDATE ) ) * NTP_INTERVAL_FREQ / 1000 ; txc -> freq = ( time_freq / NSEC_PER_USEC ) << ( SHIFT_USEC - SHIFT_NSEC ) ; txc -> maxerror = time_maxerror ; txc -> esterror = time_esterror ; txc -> status = time_status ; txc -> constant = time_constant ; txc -> precision = 1 ; txc -> tolerance = MAXFREQ ; txc -> tick = tick_usec ; txc -> ppsfreq = 0 ; txc -> jitter = 0 ; txc -> shift = 0 ; txc -> stabil = 0 ; txc -> jitcnt = 0 ; txc -> calcnt = 0 ; txc -> errcnt = 0 ; txc -> stbcnt = 0 ; write_sequnlock_irq ( & xtime_lock ) ; do_gettimeofday ( & txc -> time ) ; notify_cmos_timer ( ) ; return ( result ) ; }
","<S2SV_ModStart> mtemp , save_adjust <S2SV_ModEnd> ; s64 freq_adj <S2SV_ModStart> ; time_offset = div_s64 <S2SV_ModEnd> ( time_offset , <S2SV_ModStart> time_offset , NTP_INTERVAL_FREQ <S2SV_ModEnd> ) ; time_offset
"
789,"CWE-476 static int pcd_detect ( void ) { char id [ 18 ] ; int k , unit ; struct pcd_unit * cd ; printk ( ""%s:<S2SV_blank>%s<S2SV_blank>version<S2SV_blank>%s,<S2SV_blank>major<S2SV_blank>%d,<S2SV_blank>nice<S2SV_blank>%d\\n"" , name , name , PCD_VERSION , major , nice ) ; par_drv = pi_register_driver ( name ) ; if ( ! par_drv ) { pr_err ( ""failed<S2SV_blank>to<S2SV_blank>register<S2SV_blank>%s<S2SV_blank>driver\\n"" , name ) ; return - 1 ; } k = 0 ; if ( pcd_drive_count == 0 ) { cd = pcd ; if ( pi_init ( cd -> pi , 1 , - 1 , - 1 , - 1 , - 1 , - 1 , pcd_buffer , PI_PCD , verbose , cd -> name ) ) { if ( ! pcd_probe ( cd , - 1 , id ) && cd -> disk ) { cd -> present = 1 ; k ++ ; } else pi_release ( cd -> pi ) ; } } else { for ( unit = 0 , cd = pcd ; unit < PCD_UNITS ; unit ++ , cd ++ ) { int * conf = * drives [ unit ] ; if ( ! conf [ D_PRT ] ) continue ; if ( ! pi_init ( cd -> pi , 0 , conf [ D_PRT ] , conf [ D_MOD ] , conf [ D_UNI ] , conf [ D_PRO ] , conf [ D_DLY ] , pcd_buffer , PI_PCD , verbose , cd -> name ) ) continue ; if ( ! pcd_probe ( cd , conf [ D_SLV ] , id ) && cd -> disk ) { cd -> present = 1 ; k ++ ; } else pi_release ( cd -> pi ) ; } } if ( k ) return 0 ; printk ( ""%s:<S2SV_blank>No<S2SV_blank>CD-ROM<S2SV_blank>drive<S2SV_blank>found\\n"" , name ) ; for ( unit = 0 , cd = pcd ; unit < PCD_UNITS ; unit ++ , cd ++ ) { <S2SV_StartBug> blk_cleanup_queue ( cd -> disk -> queue ) ; <S2SV_EndBug> cd -> disk -> queue = NULL ; blk_mq_free_tag_set ( & cd -> tag_set ) ; put_disk ( cd -> disk ) ; } pi_unregister_driver ( par_drv ) ; return - 1 ; }
","<S2SV_ModStart> ++ ) { if ( ! cd -> disk ) continue ;
"
790,"CWE-399 static void xsltCompileLocationPathPattern ( xsltParserContextPtr ctxt , int novar ) { SKIP_BLANKS ; if ( ( CUR == '/' ) && ( NXT ( 1 ) == '/' ) ) { NEXT ; NEXT ; ctxt -> comp -> priority = 0.5 ; xsltCompileRelativePathPattern ( ctxt , NULL , novar ) ; } else if ( CUR == '/' ) { NEXT ; SKIP_BLANKS ; PUSH ( XSLT_OP_ROOT , NULL , NULL , novar ) ; if ( ( CUR != 0 ) && ( CUR != '|' ) ) { PUSH ( XSLT_OP_PARENT , NULL , NULL , novar ) ; xsltCompileRelativePathPattern ( ctxt , NULL , novar ) ; } } else if ( CUR == '*' ) { xsltCompileRelativePathPattern ( ctxt , NULL , novar ) ; } else if ( CUR == '@' ) { xsltCompileRelativePathPattern ( ctxt , NULL , novar ) ; } else { xmlChar * name ; name = xsltScanNCName ( ctxt ) ; if ( name == NULL ) { xsltTransformError ( NULL , NULL , NULL , ""xsltCompileLocationPathPattern<S2SV_blank>:<S2SV_blank>Name<S2SV_blank>expected\\n"" ) ; ctxt -> error = 1 ; return ; } SKIP_BLANKS ; if ( ( CUR == '(' ) && ! xmlXPathIsNodeType ( name ) ) { xsltCompileIdKeyPattern ( ctxt , name , 1 , novar , 0 ) ; <S2SV_StartBug> if ( ( CUR == '/' ) && ( NXT ( 1 ) == '/' ) ) { <S2SV_EndBug> PUSH ( XSLT_OP_ANCESTOR , NULL , NULL , novar ) ; NEXT ; NEXT ; SKIP_BLANKS ; xsltCompileRelativePathPattern ( ctxt , NULL , novar ) ; } else if ( CUR == '/' ) { PUSH ( XSLT_OP_PARENT , NULL , NULL , novar ) ; NEXT ; SKIP_BLANKS ; xsltCompileRelativePathPattern ( ctxt , NULL , novar ) ; } return ; } xsltCompileRelativePathPattern ( ctxt , name , novar ) ; } error : return ; }
","<S2SV_ModStart> ; if ( ctxt -> error ) return ; if (
"
791,"CWE-20 static int flashsv_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) { int buf_size = avpkt -> size ; FlashSVContext * s = avctx -> priv_data ; int h_blocks , v_blocks , h_part , v_part , i , j , ret ; GetBitContext gb ; int last_blockwidth = s -> block_width ; int last_blockheight = s -> block_height ; if ( buf_size == 0 ) return 0 ; if ( buf_size < 4 ) return - 1 ; init_get_bits ( & gb , avpkt -> data , buf_size * 8 ) ; s -> block_width = 16 * ( get_bits ( & gb , 4 ) + 1 ) ; s -> image_width = get_bits ( & gb , 12 ) ; s -> block_height = 16 * ( get_bits ( & gb , 4 ) + 1 ) ; s -> image_height = get_bits ( & gb , 12 ) ; if ( last_blockwidth != s -> block_width || last_blockheight != s -> block_height ) av_freep ( & s -> blocks ) ; if ( s -> ver == 2 ) { skip_bits ( & gb , 6 ) ; if ( get_bits1 ( & gb ) ) { avpriv_request_sample ( avctx , ""iframe"" ) ; return AVERROR_PATCHWELCOME ; } if ( get_bits1 ( & gb ) ) { avpriv_request_sample ( avctx , ""Custom<S2SV_blank>palette"" ) ; return AVERROR_PATCHWELCOME ; } } h_blocks = s -> image_width / s -> block_width ; h_part = s -> image_width % s -> block_width ; v_blocks = s -> image_height / s -> block_height ; v_part = s -> image_height % s -> block_height ; if ( s -> block_size < s -> block_width * s -> block_height ) { int tmpblock_size = 3 * s -> block_width * s -> block_height ; s -> tmpblock = av_realloc ( s -> tmpblock , tmpblock_size ) ; if ( ! s -> tmpblock ) { av_log ( avctx , AV_LOG_ERROR , ""Can\'t<S2SV_blank>allocate<S2SV_blank>decompression<S2SV_blank>buffer.\\n"" ) ; return AVERROR ( ENOMEM ) ; } if ( s -> ver == 2 ) { s -> deflate_block_size = calc_deflate_block_size ( tmpblock_size ) ; if ( s -> deflate_block_size <= 0 ) { av_log ( avctx , AV_LOG_ERROR , ""Can\'t<S2SV_blank>determine<S2SV_blank>deflate<S2SV_blank>buffer<S2SV_blank>size.\\n"" ) ; return - 1 ; } s -> deflate_block = av_realloc ( s -> deflate_block , s -> deflate_block_size ) ; if ( ! s -> deflate_block ) { av_log ( avctx , AV_LOG_ERROR , ""Can\'t<S2SV_blank>allocate<S2SV_blank>deflate<S2SV_blank>buffer.\\n"" ) ; return AVERROR ( ENOMEM ) ; } } } s -> block_size = s -> block_width * s -> block_height ; if ( avctx -> width == 0 && avctx -> height == 0 ) { avcodec_set_dimensions ( avctx , s -> image_width , s -> image_height ) ; } if ( avctx -> width != s -> image_width || avctx -> height != s -> image_height ) { av_log ( avctx , AV_LOG_ERROR , ""Frame<S2SV_blank>width<S2SV_blank>or<S2SV_blank>height<S2SV_blank>differs<S2SV_blank>from<S2SV_blank>first<S2SV_blank>frame!\\n"" ) ; av_log ( avctx , AV_LOG_ERROR , ""fh<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>fv<S2SV_blank>%d<S2SV_blank><S2SV_blank>vs<S2SV_blank><S2SV_blank>ch<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>cv<S2SV_blank>=<S2SV_blank>%d\\n"" , avctx -> height , avctx -> width , s -> image_height , s -> image_width ) ; return AVERROR_INVALIDDATA ; } s -> is_keyframe = ( avpkt -> flags & AV_PKT_FLAG_KEY ) && ( s -> ver == 2 ) ; if ( s -> is_keyframe ) { s -> keyframedata = av_realloc ( s -> keyframedata , avpkt -> size ) ; memcpy ( s -> keyframedata , avpkt -> data , avpkt -> size ) ; } if ( s -> ver == 2 && ! s -> blocks ) s -> blocks = av_mallocz ( ( v_blocks + ! ! v_part ) * ( h_blocks + ! ! h_part ) * sizeof ( s -> blocks [ 0 ] ) ) ; av_dlog ( avctx , ""image:<S2SV_blank>%dx%d<S2SV_blank>block:<S2SV_blank>%dx%d<S2SV_blank>num:<S2SV_blank>%dx%d<S2SV_blank>part:<S2SV_blank>%dx%d\\n"" , s -> image_width , s -> image_height , s -> block_width , s -> block_height , h_blocks , v_blocks , h_part , v_part ) ; if ( ( ret = ff_reget_buffer ( avctx , & s -> frame ) ) < 0 ) return ret ; for ( j = 0 ; j < v_blocks + ( v_part ? 1 : 0 ) ; j ++ ) { int y_pos = j * s -> block_height ; int cur_blk_height = ( j < v_blocks ) ? s -> block_height : v_part ; for ( i = 0 ; i < h_blocks + ( h_part ? 1 : 0 ) ; i ++ ) { int x_pos = i * s -> block_width ; int cur_blk_width = ( i < h_blocks ) ? s -> block_width : h_part ; int has_diff = 0 ; int size = get_bits ( & gb , 16 ) ; s -> color_depth = 0 ; s -> zlibprime_curr = 0 ; s -> zlibprime_prev = 0 ; s -> diff_start = 0 ; s -> diff_height = cur_blk_height ; if ( 8 * size > get_bits_left ( & gb ) ) { av_frame_unref ( & s -> frame ) ; return AVERROR_INVALIDDATA ; } if ( s -> ver == 2 && size ) { skip_bits ( & gb , 3 ) ; s -> color_depth = get_bits ( & gb , 2 ) ; has_diff = get_bits1 ( & gb ) ; s -> zlibprime_curr = get_bits1 ( & gb ) ; s -> zlibprime_prev = get_bits1 ( & gb ) ; if ( s -> color_depth != 0 && s -> color_depth != 2 ) { av_log ( avctx , AV_LOG_ERROR , ""%dx%d<S2SV_blank>invalid<S2SV_blank>color<S2SV_blank>depth<S2SV_blank>%d\\n"" , i , j , s -> color_depth ) ; return AVERROR_INVALIDDATA ; } if ( has_diff ) { if ( ! s -> keyframe ) { av_log ( avctx , AV_LOG_ERROR , ""inter<S2SV_blank>frame<S2SV_blank>without<S2SV_blank>keyframe\\n"" ) ; return AVERROR_INVALIDDATA ; } s -> diff_start = get_bits ( & gb , 8 ) ; s -> diff_height = get_bits ( & gb , 8 ) ; <S2SV_StartBug> av_log ( avctx , AV_LOG_DEBUG , <S2SV_EndBug> ""%dx%d<S2SV_blank>diff<S2SV_blank>start<S2SV_blank>%d<S2SV_blank>height<S2SV_blank>%d\\n"" , i , j , s -> diff_start , s -> diff_height ) ; size -= 2 ; } if ( s -> zlibprime_prev ) av_log ( avctx , AV_LOG_DEBUG , ""%dx%d<S2SV_blank>zlibprime_prev\\n"" , i , j ) ; if ( s -> zlibprime_curr ) { int col = get_bits ( & gb , 8 ) ; int row = get_bits ( & gb , 8 ) ; av_log ( avctx , AV_LOG_DEBUG , ""%dx%d<S2SV_blank>zlibprime_curr<S2SV_blank>%dx%d\\n"" , i , j , col , row ) ; size -= 2 ; avpriv_request_sample ( avctx , ""zlibprime_curr"" ) ; return AVERROR_PATCHWELCOME ; } if ( ! s -> blocks && ( s -> zlibprime_curr || s -> zlibprime_prev ) ) { av_log ( avctx , AV_LOG_ERROR , ""no<S2SV_blank>data<S2SV_blank>available<S2SV_blank>for<S2SV_blank>zlib<S2SV_blank>"" ""priming\\n"" ) ; return AVERROR_INVALIDDATA ; } size -- ; } if ( has_diff ) { int k ; int off = ( s -> image_height - y_pos - 1 ) * s -> frame . linesize [ 0 ] ; for ( k = 0 ; k < cur_blk_height ; k ++ ) memcpy ( s -> frame . data [ 0 ] + off - k * s -> frame . linesize [ 0 ] + x_pos * 3 , s -> keyframe + off - k * s -> frame . linesize [ 0 ] + x_pos * 3 , cur_blk_width * 3 ) ; } if ( size ) { if ( flashsv_decode_block ( avctx , avpkt , & gb , size , cur_blk_width , cur_blk_height , x_pos , y_pos , i + j * ( h_blocks + ! ! h_part ) ) ) av_log ( avctx , AV_LOG_ERROR , ""error<S2SV_blank>in<S2SV_blank>decompression<S2SV_blank>of<S2SV_blank>block<S2SV_blank>%dx%d\\n"" , i , j ) ; } } } if ( s -> is_keyframe && s -> ver == 2 ) { if ( ! s -> keyframe ) { s -> keyframe = av_malloc ( s -> frame . linesize [ 0 ] * avctx -> height ) ; if ( ! s -> keyframe ) { av_log ( avctx , AV_LOG_ERROR , ""Cannot<S2SV_blank>allocate<S2SV_blank>image<S2SV_blank>data\\n"" ) ; return AVERROR ( ENOMEM ) ; } } memcpy ( s -> keyframe , s -> frame . data [ 0 ] , s -> frame . linesize [ 0 ] * avctx -> height ) ; } if ( ( ret = av_frame_ref ( data , & s -> frame ) ) < 0 ) return ret ; * got_frame = 1 ; if ( ( get_bits_count ( & gb ) / 8 ) != buf_size ) av_log ( avctx , AV_LOG_ERROR , ""buffer<S2SV_blank>not<S2SV_blank>fully<S2SV_blank>consumed<S2SV_blank>(%d<S2SV_blank>!=<S2SV_blank>%d)\\n"" , buf_size , ( get_bits_count ( & gb ) / 8 ) ) ; return buf_size ; }
","<S2SV_ModStart> 8 ) ; if ( s -> diff_start + s -> diff_height > cur_blk_height ) { av_log ( avctx , AV_LOG_ERROR , ""Block<S2SV_blank>parameters<S2SV_blank>invalid\\n"" ) ; return AVERROR_INVALIDDATA ; }
"
792,"CWE-552 static long _syscall ( long num , long arg1 , long arg2 , long arg3 , long arg4 , long arg5 , long arg6 ) { long ret = - 1 ; oe_errno = 0 ; switch ( num ) { # if defined ( OE_SYS_creat ) case OE_SYS_creat : { const char * pathname = ( const char * ) arg1 ; oe_mode_t mode = ( oe_mode_t ) arg2 ; int flags = ( OE_O_CREAT | OE_O_WRONLY | OE_O_TRUNC ) ; ret = oe_open ( pathname , flags , mode ) ; if ( oe_errno == OE_ENOENT ) { oe_errno = OE_ENOSYS ; goto done ; } goto done ; } # endif # if defined ( OE_SYS_open ) case OE_SYS_open : { const char * pathname = ( const char * ) arg1 ; int flags = ( int ) arg2 ; uint32_t mode = ( uint32_t ) arg3 ; ret = oe_open ( pathname , flags , mode ) ; if ( ret < 0 && oe_errno == OE_ENOENT ) goto done ; goto done ; } # endif case OE_SYS_openat : { int dirfd = ( int ) arg1 ; const char * pathname = ( const char * ) arg2 ; int flags = ( int ) arg3 ; uint32_t mode = ( uint32_t ) arg4 ; if ( dirfd != OE_AT_FDCWD ) { oe_errno = OE_EBADF ; goto done ; } ret = oe_open ( pathname , flags , mode ) ; if ( ret < 0 && oe_errno == OE_ENOENT ) goto done ; goto done ; } case OE_SYS_lseek : { int fd = ( int ) arg1 ; ssize_t off = ( ssize_t ) arg2 ; int whence = ( int ) arg3 ; ret = oe_lseek ( fd , off , whence ) ; goto done ; } case OE_SYS_pread64 : { const int fd = ( int ) arg1 ; void * const buf = ( void * ) arg2 ; const size_t count = ( size_t ) arg3 ; const oe_off_t offset = ( oe_off_t ) arg4 ; ret = oe_pread ( fd , buf , count , offset ) ; goto done ; } case OE_SYS_pwrite64 : { const int fd = ( int ) arg1 ; const void * const buf = ( void * ) arg2 ; const size_t count = ( size_t ) arg3 ; const oe_off_t offset = ( oe_off_t ) arg4 ; ret = oe_pwrite ( fd , buf , count , offset ) ; goto done ; } case OE_SYS_readv : { int fd = ( int ) arg1 ; const struct oe_iovec * iov = ( const struct oe_iovec * ) arg2 ; int iovcnt = ( int ) arg3 ; ret = oe_readv ( fd , iov , iovcnt ) ; goto done ; } case OE_SYS_writev : { int fd = ( int ) arg1 ; const struct oe_iovec * iov = ( const struct oe_iovec * ) arg2 ; int iovcnt = ( int ) arg3 ; ret = oe_writev ( fd , iov , iovcnt ) ; goto done ; } case OE_SYS_read : { int fd = ( int ) arg1 ; void * buf = ( void * ) arg2 ; size_t count = ( size_t ) arg3 ; ret = oe_read ( fd , buf , count ) ; goto done ; } case OE_SYS_write : { int fd = ( int ) arg1 ; const void * buf = ( void * ) arg2 ; size_t count = ( size_t ) arg3 ; ret = oe_write ( fd , buf , count ) ; goto done ; } case OE_SYS_close : { int fd = ( int ) arg1 ; ret = oe_close ( fd ) ; goto done ; } case OE_SYS_dup : { int fd = ( int ) arg1 ; ret = oe_dup ( fd ) ; goto done ; } case OE_SYS_flock : { int fd = ( int ) arg1 ; int operation = ( int ) arg2 ; ret = oe_flock ( fd , operation ) ; goto done ; } case OE_SYS_fsync : { const int fd = ( int ) arg1 ; ret = oe_fsync ( fd ) ; goto done ; } case OE_SYS_fdatasync : { const int fd = ( int ) arg1 ; ret = oe_fdatasync ( fd ) ; goto done ; } # if defined ( OE_SYS_dup2 ) case OE_SYS_dup2 : { int oldfd = ( int ) arg1 ; int newfd = ( int ) arg2 ; ret = oe_dup2 ( oldfd , newfd ) ; goto done ; } # endif case OE_SYS_dup3 : { int oldfd = ( int ) arg1 ; int newfd = ( int ) arg2 ; int flags = ( int ) arg3 ; if ( flags != 0 ) { oe_errno = OE_EINVAL ; goto done ; } ret = oe_dup2 ( oldfd , newfd ) ; goto done ; } # if defined ( OE_SYS_stat ) case OE_SYS_stat : { const char * pathname = ( const char * ) arg1 ; struct oe_stat_t * buf = ( struct oe_stat_t * ) arg2 ; ret = oe_stat ( pathname , buf ) ; goto done ; } # endif case OE_SYS_newfstatat : { int dirfd = ( int ) arg1 ; const char * pathname = ( const char * ) arg2 ; struct oe_stat_t * buf = ( struct oe_stat_t * ) arg3 ; int flags = ( int ) arg4 ; if ( dirfd != OE_AT_FDCWD ) { oe_errno = OE_EBADF ; goto done ; } if ( flags != 0 ) { oe_errno = OE_EINVAL ; goto done ; } ret = oe_stat ( pathname , buf ) ; goto done ; } case OE_SYS_fstat : { const int fd = ( int ) arg1 ; struct oe_stat_t * const buf = ( struct oe_stat_t * ) arg2 ; ret = oe_fstat ( fd , buf ) ; goto done ; } # if defined ( OE_SYS_link ) case OE_SYS_link : { const char * oldpath = ( const char * ) arg1 ; const char * newpath = ( const char * ) arg2 ; ret = oe_link ( oldpath , newpath ) ; goto done ; } # endif case OE_SYS_linkat : { int olddirfd = ( int ) arg1 ; const char * oldpath = ( const char * ) arg2 ; int newdirfd = ( int ) arg3 ; const char * newpath = ( const char * ) arg4 ; int flags = ( int ) arg5 ; if ( olddirfd != OE_AT_FDCWD ) { oe_errno = OE_EBADF ; goto done ; } if ( newdirfd != OE_AT_FDCWD ) { oe_errno = OE_EBADF ; goto done ; } if ( flags != 0 ) { oe_errno = OE_EINVAL ; goto done ; } ret = oe_link ( oldpath , newpath ) ; goto done ; } # if defined ( OE_SYS_unlink ) case OE_SYS_unlink : { const char * pathname = ( const char * ) arg1 ; ret = oe_unlink ( pathname ) ; goto done ; } # endif case OE_SYS_unlinkat : { int dirfd = ( int ) arg1 ; const char * pathname = ( const char * ) arg2 ; int flags = ( int ) arg3 ; if ( dirfd != OE_AT_FDCWD ) { oe_errno = OE_EBADF ; goto done ; } if ( flags != OE_AT_REMOVEDIR && flags != 0 ) { oe_errno = OE_EINVAL ; goto done ; } if ( flags == OE_AT_REMOVEDIR ) ret = oe_rmdir ( pathname ) ; else ret = oe_unlink ( pathname ) ; goto done ; } # if defined ( OE_SYS_rename ) case OE_SYS_rename : { const char * oldpath = ( const char * ) arg1 ; const char * newpath = ( const char * ) arg2 ; ret = oe_rename ( oldpath , newpath ) ; goto done ; } # endif case OE_SYS_renameat : { int olddirfd = ( int ) arg1 ; const char * oldpath = ( const char * ) arg2 ; int newdirfd = ( int ) arg3 ; const char * newpath = ( const char * ) arg4 ; int flags = ( int ) arg5 ; if ( olddirfd != OE_AT_FDCWD ) { oe_errno = OE_EBADF ; goto done ; } if ( newdirfd != OE_AT_FDCWD ) { oe_errno = OE_EBADF ; goto done ; } if ( flags != 0 ) { oe_errno = OE_EINVAL ; goto done ; } ret = oe_rename ( oldpath , newpath ) ; goto done ; } case OE_SYS_truncate : { const char * path = ( const char * ) arg1 ; ssize_t length = ( ssize_t ) arg2 ; ret = oe_truncate ( path , length ) ; goto done ; } # if defined ( OE_SYS_mkdir ) case OE_SYS_mkdir : { const char * pathname = ( const char * ) arg1 ; uint32_t mode = ( uint32_t ) arg2 ; ret = oe_mkdir ( pathname , mode ) ; goto done ; } # endif case OE_SYS_mkdirat : { int dirfd = ( int ) arg1 ; const char * pathname = ( const char * ) arg2 ; uint32_t mode = ( uint32_t ) arg3 ; if ( dirfd != OE_AT_FDCWD ) { oe_errno = OE_EBADF ; goto done ; } ret = oe_mkdir ( pathname , mode ) ; goto done ; } # if defined ( OE_SYS_rmdir ) case OE_SYS_rmdir : { const char * pathname = ( const char * ) arg1 ; ret = oe_rmdir ( pathname ) ; goto done ; } # endif # if defined ( OE_SYS_access ) case OE_SYS_access : { const char * pathname = ( const char * ) arg1 ; int mode = ( int ) arg2 ; ret = oe_access ( pathname , mode ) ; goto done ; } # endif case OE_SYS_faccessat : { int dirfd = ( int ) arg1 ; const char * pathname = ( const char * ) arg2 ; int mode = ( int ) arg3 ; int flags = ( int ) arg4 ; if ( dirfd != OE_AT_FDCWD ) { oe_errno = OE_EBADF ; goto done ; } if ( flags != 0 ) { oe_errno = OE_EINVAL ; goto done ; } ret = oe_access ( pathname , mode ) ; goto done ; } case OE_SYS_getdents64 : { unsigned int fd = ( unsigned int ) arg1 ; struct oe_dirent * ent = ( struct oe_dirent * ) arg2 ; unsigned int count = ( unsigned int ) arg3 ; ret = oe_getdents64 ( fd , ent , count ) ; goto done ; } case OE_SYS_ioctl : { int fd = ( int ) arg1 ; unsigned long request = ( unsigned long ) arg2 ; long p1 = arg3 ; long p2 = arg4 ; long p3 = arg5 ; long p4 = arg6 ; ret = oe_ioctl ( fd , request , p1 , p2 , p3 , p4 ) ; goto done ; } case OE_SYS_fcntl : { int fd = ( int ) arg1 ; int cmd = ( int ) arg2 ; uint64_t arg = ( uint64_t ) arg3 ; ret = oe_fcntl ( fd , cmd , arg ) ; goto done ; } case OE_SYS_mount : { const char * source = ( const char * ) arg1 ; const char * target = ( const char * ) arg2 ; const char * fstype = ( const char * ) arg3 ; unsigned long flags = ( unsigned long ) arg4 ; void * data = ( void * ) arg5 ; ret = oe_mount ( source , target , fstype , flags , data ) ; goto done ; } case OE_SYS_umount2 : { const char * target = ( const char * ) arg1 ; int flags = ( int ) arg2 ; ( void ) flags ; ret = oe_umount ( target ) ; goto done ; } case OE_SYS_getcwd : { char * buf = ( char * ) arg1 ; size_t size = ( size_t ) arg2 ; if ( ! oe_getcwd ( buf , size ) ) { ret = - 1 ; } else { ret = ( long ) size ; } goto done ; } case OE_SYS_chdir : { char * path = ( char * ) arg1 ; ret = oe_chdir ( path ) ; goto done ; } case OE_SYS_socket : { int domain = ( int ) arg1 ; int type = ( int ) arg2 ; int protocol = ( int ) arg3 ; ret = oe_socket ( domain , type , protocol ) ; goto done ; } case OE_SYS_connect : { int sd = ( int ) arg1 ; const struct oe_sockaddr * addr = ( const struct oe_sockaddr * ) arg2 ; oe_socklen_t addrlen = ( oe_socklen_t ) arg3 ; ret = oe_connect ( sd , addr , addrlen ) ; goto done ; } case OE_SYS_setsockopt : { int sockfd = ( int ) arg1 ; int level = ( int ) arg2 ; int optname = ( int ) arg3 ; void * optval = ( void * ) arg4 ; oe_socklen_t optlen = ( oe_socklen_t ) arg5 ; ret = oe_setsockopt ( sockfd , level , optname , optval , optlen ) ; goto done ; } case OE_SYS_getsockopt : { int sockfd = ( int ) arg1 ; int level = ( int ) arg2 ; int optname = ( int ) arg3 ; void * optval = ( void * ) arg4 ; oe_socklen_t * optlen = ( oe_socklen_t * ) arg5 ; ret = oe_getsockopt ( sockfd , level , optname , optval , optlen ) ; goto done ; } case OE_SYS_getpeername : { int sockfd = ( int ) arg1 ; struct sockaddr * addr = ( struct sockaddr * ) arg2 ; oe_socklen_t * addrlen = ( oe_socklen_t * ) arg3 ; ret = oe_getpeername ( sockfd , ( struct oe_sockaddr * ) addr , addrlen ) ; goto done ; } case OE_SYS_getsockname : { int sockfd = ( int ) arg1 ; struct sockaddr * addr = ( struct sockaddr * ) arg2 ; oe_socklen_t * addrlen = ( oe_socklen_t * ) arg3 ; ret = oe_getsockname ( sockfd , ( struct oe_sockaddr * ) addr , addrlen ) ; goto done ; } case OE_SYS_bind : { int sockfd = ( int ) arg1 ; struct oe_sockaddr * addr = ( struct oe_sockaddr * ) arg2 ; oe_socklen_t addrlen = ( oe_socklen_t ) arg3 ; ret = oe_bind ( sockfd , addr , addrlen ) ; goto done ; } case OE_SYS_listen : { int sockfd = ( int ) arg1 ; int backlog = ( int ) arg2 ; ret = oe_listen ( sockfd , backlog ) ; goto done ; } case OE_SYS_accept : { int sockfd = ( int ) arg1 ; struct oe_sockaddr * addr = ( struct oe_sockaddr * ) arg2 ; oe_socklen_t * addrlen = ( oe_socklen_t * ) arg3 ; ret = oe_accept ( sockfd , addr , addrlen ) ; goto done ; } case OE_SYS_sendto : { int sockfd = ( int ) arg1 ; const void * buf = ( void * ) arg2 ; size_t len = ( size_t ) arg3 ; int flags = ( int ) arg4 ; const struct oe_sockaddr * dest_add = ( const struct oe_sockaddr * ) arg5 ; oe_socklen_t addrlen = ( oe_socklen_t ) arg6 ; ret = oe_sendto ( sockfd , buf , len , flags , dest_add , addrlen ) ; goto done ; } case OE_SYS_recvfrom : { int sockfd = ( int ) arg1 ; void * buf = ( void * ) arg2 ; size_t len = ( size_t ) arg3 ; int flags = ( int ) arg4 ; <S2SV_StartBug> const struct oe_sockaddr * dest_add = <S2SV_EndBug> <S2SV_StartBug> ( const struct oe_sockaddr * ) arg5 ; <S2SV_EndBug> oe_socklen_t * addrlen = ( oe_socklen_t * ) arg6 ; ret = oe_recvfrom ( sockfd , buf , len , flags , dest_add , addrlen ) ; goto done ; } case OE_SYS_sendmsg : { int sockfd = ( int ) arg1 ; struct msghdr * buf = ( struct msghdr * ) arg2 ; int flags = ( int ) arg3 ; ret = oe_sendmsg ( sockfd , ( struct oe_msghdr * ) buf , flags ) ; goto done ; } case OE_SYS_recvmsg : { int sockfd = ( int ) arg1 ; struct msghdr * buf = ( struct msghdr * ) arg2 ; int flags = ( int ) arg3 ; ret = oe_recvmsg ( sockfd , ( struct oe_msghdr * ) buf , flags ) ; goto done ; } case OE_SYS_socketpair : { int domain = ( int ) arg1 ; int type = ( int ) arg2 ; int protocol = ( int ) arg3 ; int * sv = ( int * ) arg4 ; ret = oe_socketpair ( domain , type , protocol , sv ) ; goto done ; } case OE_SYS_shutdown : { int sockfd = ( int ) arg1 ; int how = ( int ) arg2 ; ret = oe_shutdown ( sockfd , how ) ; goto done ; } case OE_SYS_uname : { struct oe_utsname * buf = ( struct oe_utsname * ) arg1 ; ret = oe_uname ( buf ) ; goto done ; } # if defined ( OE_SYS_select ) case OE_SYS_select : { int nfds = ( int ) arg1 ; oe_fd_set * readfds = ( oe_fd_set * ) arg2 ; oe_fd_set * writefds = ( oe_fd_set * ) arg3 ; oe_fd_set * efds = ( oe_fd_set * ) arg4 ; struct oe_timeval * timeout = ( struct oe_timeval * ) arg5 ; ret = oe_select ( nfds , readfds , writefds , efds , timeout ) ; goto done ; } # endif case OE_SYS_pselect6 : { int nfds = ( int ) arg1 ; oe_fd_set * readfds = ( oe_fd_set * ) arg2 ; oe_fd_set * writefds = ( oe_fd_set * ) arg3 ; oe_fd_set * exceptfds = ( oe_fd_set * ) arg4 ; struct oe_timespec * ts = ( struct oe_timespec * ) arg5 ; struct oe_timeval buf ; struct oe_timeval * tv = NULL ; if ( ts ) { tv = & buf ; tv -> tv_sec = ts -> tv_sec ; tv -> tv_usec = ts -> tv_nsec / 1000 ; } ret = oe_select ( nfds , readfds , writefds , exceptfds , tv ) ; goto done ; } # if defined ( OE_SYS_poll ) case OE_SYS_poll : { struct oe_pollfd * fds = ( struct oe_pollfd * ) arg1 ; oe_nfds_t nfds = ( oe_nfds_t ) arg2 ; int millis = ( int ) arg3 ; ret = oe_poll ( fds , nfds , millis ) ; goto done ; } # endif case OE_SYS_ppoll : { struct oe_pollfd * fds = ( struct oe_pollfd * ) arg1 ; oe_nfds_t nfds = ( oe_nfds_t ) arg2 ; struct oe_timespec * ts = ( struct oe_timespec * ) arg3 ; void * sigmask = ( void * ) arg4 ; int timeout = - 1 ; if ( sigmask != NULL ) { oe_errno = OE_EINVAL ; goto done ; } if ( ts ) { int64_t mul ; int64_t div ; int64_t sum ; if ( oe_safe_mul_s64 ( ts -> tv_sec , 1000 , & mul ) != OE_OK ) { oe_errno = OE_EINVAL ; goto done ; } div = ts -> tv_nsec / 1000000 ; if ( oe_safe_add_s64 ( mul , div , & sum ) != OE_OK ) { oe_errno = OE_EINVAL ; goto done ; } if ( sum < OE_INT_MIN || sum > OE_INT_MAX ) { oe_errno = OE_EINVAL ; goto done ; } timeout = ( int ) sum ; } ret = oe_poll ( fds , nfds , timeout ) ; goto done ; } # if defined ( OE_SYS_epoll_create ) case OE_SYS_epoll_create : { int size = ( int ) arg1 ; ret = oe_epoll_create ( size ) ; goto done ; } # endif case OE_SYS_epoll_create1 : { int flags = ( int ) arg1 ; ret = oe_epoll_create1 ( flags ) ; goto done ; } # if defined ( OE_SYS_epoll_wait ) case OE_SYS_epoll_wait : { int epfd = ( int ) arg1 ; struct oe_epoll_event * events = ( struct oe_epoll_event * ) arg2 ; int maxevents = ( int ) arg3 ; int timeout = ( int ) arg4 ; ret = oe_epoll_wait ( epfd , events , maxevents , timeout ) ; goto done ; } # endif case OE_SYS_epoll_pwait : { int epfd = ( int ) arg1 ; struct oe_epoll_event * events = ( struct oe_epoll_event * ) arg2 ; int maxevents = ( int ) arg3 ; int timeout = ( int ) arg4 ; const oe_sigset_t * sigmask = ( const oe_sigset_t * ) arg5 ; ret = oe_epoll_pwait ( epfd , events , maxevents , timeout , sigmask ) ; goto done ; } case OE_SYS_epoll_ctl : { int epfd = ( int ) arg1 ; int op = ( int ) arg2 ; int fd = ( int ) arg3 ; struct oe_epoll_event * event = ( struct oe_epoll_event * ) arg4 ; ret = oe_epoll_ctl ( epfd , op , fd , event ) ; goto done ; } case OE_SYS_exit_group : { ret = 0 ; goto done ; } case OE_SYS_exit : { int status = ( int ) arg1 ; oe_exit ( status ) ; goto done ; } case OE_SYS_getpid : { ret = ( long ) oe_getpid ( ) ; goto done ; } case OE_SYS_getuid : { ret = ( long ) oe_getuid ( ) ; goto done ; } case OE_SYS_geteuid : { ret = ( long ) oe_geteuid ( ) ; goto done ; } case OE_SYS_getgid : { ret = ( long ) oe_getgid ( ) ; goto done ; } case OE_SYS_getpgid : { int pid = ( int ) arg1 ; ret = ( long ) oe_getpgid ( pid ) ; goto done ; } case OE_SYS_getgroups : { int size = ( int ) arg1 ; oe_gid_t * list = ( oe_gid_t * ) arg2 ; ret = ( long ) oe_getgroups ( size , list ) ; goto done ; } case OE_SYS_getegid : { ret = ( long ) oe_getegid ( ) ; goto done ; } case OE_SYS_getppid : { ret = ( long ) oe_getppid ( ) ; goto done ; } # if defined ( OE_SYS_getpgrp ) case OE_SYS_getpgrp : { ret = ( long ) oe_getpgrp ( ) ; goto done ; } # endif case OE_SYS_nanosleep : { struct oe_timespec * req = ( struct oe_timespec * ) arg1 ; struct oe_timespec * rem = ( struct oe_timespec * ) arg2 ; ret = ( long ) oe_nanosleep ( req , rem ) ; goto done ; } default : { oe_errno = OE_ENOSYS ; OE_TRACE_WARNING ( ""syscall<S2SV_blank>num=%ld<S2SV_blank>not<S2SV_blank>handled"" , num ) ; goto done ; } } done : return ret ; }
","<S2SV_ModStart> ) arg4 ; <S2SV_ModEnd> struct oe_sockaddr * <S2SV_ModStart> * dest_add = ( <S2SV_ModEnd> struct oe_sockaddr *
"
793,"CWE-200 static void slc_bump ( struct slcan * sl ) { struct sk_buff * skb ; struct can_frame cf ; int i , tmp ; u32 tmpid ; char * cmd = sl -> rbuff ; <S2SV_StartBug> cf . can_id = 0 ; <S2SV_EndBug> switch ( * cmd ) { case 'r' : cf . can_id = CAN_RTR_FLAG ; case 't' : cf . can_dlc = sl -> rbuff [ SLC_CMD_LEN + SLC_SFF_ID_LEN ] ; sl -> rbuff [ SLC_CMD_LEN + SLC_SFF_ID_LEN ] = 0 ; cmd += SLC_CMD_LEN + SLC_SFF_ID_LEN + 1 ; break ; case 'R' : cf . can_id = CAN_RTR_FLAG ; case 'T' : cf . can_id |= CAN_EFF_FLAG ; cf . can_dlc = sl -> rbuff [ SLC_CMD_LEN + SLC_EFF_ID_LEN ] ; sl -> rbuff [ SLC_CMD_LEN + SLC_EFF_ID_LEN ] = 0 ; cmd += SLC_CMD_LEN + SLC_EFF_ID_LEN + 1 ; break ; default : return ; } if ( kstrtou32 ( sl -> rbuff + SLC_CMD_LEN , 16 , & tmpid ) ) return ; cf . can_id |= tmpid ; if ( cf . can_dlc >= '0' && cf . can_dlc < '9' ) cf . can_dlc -= '0' ; else return ; <S2SV_StartBug> * ( u64 * ) ( & cf . data ) = 0 ; <S2SV_EndBug> if ( ! ( cf . can_id & CAN_RTR_FLAG ) ) { for ( i = 0 ; i < cf . can_dlc ; i ++ ) { tmp = hex_to_bin ( * cmd ++ ) ; if ( tmp < 0 ) return ; cf . data [ i ] = ( tmp << 4 ) ; tmp = hex_to_bin ( * cmd ++ ) ; if ( tmp < 0 ) return ; cf . data [ i ] |= tmp ; } } skb = dev_alloc_skb ( sizeof ( struct can_frame ) + sizeof ( struct can_skb_priv ) ) ; if ( ! skb ) return ; skb -> dev = sl -> dev ; skb -> protocol = htons ( ETH_P_CAN ) ; skb -> pkt_type = PACKET_BROADCAST ; skb -> ip_summed = CHECKSUM_UNNECESSARY ; can_skb_reserve ( skb ) ; can_skb_prv ( skb ) -> ifindex = sl -> dev -> ifindex ; can_skb_prv ( skb ) -> skbcnt = 0 ; skb_put_data ( skb , & cf , sizeof ( struct can_frame ) ) ; sl -> dev -> stats . rx_packets ++ ; sl -> dev -> stats . rx_bytes += cf . can_dlc ; netif_rx_ni ( skb ) ; }
","<S2SV_ModStart> -> rbuff ; memset ( & cf , 0 , sizeof ( cf ) ) <S2SV_ModEnd> ; switch ( <S2SV_ModStart> else return ; <S2SV_ModEnd> if ( !
"
794,"CWE-125 <S2SV_StartBug> static void <S2SV_EndBug> ip_printts ( netdissect_options * ndo , register const u_char * cp , u_int length ) { register u_int ptr ; register u_int len ; int hoplen ; const char * type ; if ( length < 4 ) { ND_PRINT ( ( ndo , ""[bad<S2SV_blank>length<S2SV_blank>%u]"" , length ) ) ; <S2SV_StartBug> return ; <S2SV_EndBug> } ND_PRINT ( ( ndo , ""<S2SV_blank>TS{"" ) ) ; hoplen = ( ( cp [ 3 ] & 0xF ) != IPOPT_TS_TSONLY ) ? 8 : 4 ; if ( ( length - 4 ) & ( hoplen - 1 ) ) ND_PRINT ( ( ndo , ""[bad<S2SV_blank>length<S2SV_blank>%u]"" , length ) ) ; <S2SV_StartBug> ptr = cp [ 2 ] - 1 ; <S2SV_EndBug> len = 0 ; if ( ptr < 4 || ( ( ptr - 4 ) & ( hoplen - 1 ) ) || ptr > length + 1 ) ND_PRINT ( ( ndo , ""[bad<S2SV_blank>ptr<S2SV_blank>%u]"" , cp [ 2 ] ) ) ; <S2SV_StartBug> switch ( cp [ 3 ] & 0xF ) { <S2SV_EndBug> case IPOPT_TS_TSONLY : ND_PRINT ( ( ndo , ""TSONLY"" ) ) ; break ; case IPOPT_TS_TSANDADDR : ND_PRINT ( ( ndo , ""TS+ADDR"" ) ) ; break ; case 2 : ND_PRINT ( ( ndo , ""PRESPEC2.0"" ) ) ; break ; case 3 : ND_PRINT ( ( ndo , ""PRESPEC"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""[bad<S2SV_blank>ts<S2SV_blank>type<S2SV_blank>%d]"" , cp [ 3 ] & 0xF ) ) ; goto done ; } type = ""<S2SV_blank>"" ; for ( len = 4 ; len < length ; len += hoplen ) { if ( ptr == len ) <S2SV_StartBug> type = ""<S2SV_blank>^<S2SV_blank>"" ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""%s%d@%s"" , type , EXTRACT_32BITS ( & cp [ len + hoplen - 4 ] ) , hoplen != 8 ? """" : ipaddr_string ( ndo , & cp [ len ] ) ) ) ; type = ""<S2SV_blank>"" ; } done : ND_PRINT ( ( ndo , ""%s"" , ptr == len ? ""<S2SV_blank>^<S2SV_blank>"" : """" ) ) ; if ( cp [ 3 ] >> 4 ) ND_PRINT ( ( ndo , ""<S2SV_blank>[%d<S2SV_blank>hops<S2SV_blank>not<S2SV_blank>recorded]}<S2SV_blank>"" , cp [ 3 ] >> 4 ) ) ; else ND_PRINT ( ( ndo , ""}"" ) ) ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> ip_printts ( netdissect_options <S2SV_ModStart> ) ; return ( 0 ) <S2SV_ModStart> ) ) ; ND_TCHECK ( cp [ 2 ] ) ; <S2SV_ModStart> ) ) ; ND_TCHECK ( cp [ 3 ] ) ; <S2SV_ModStart> type = ""<S2SV_blank>^<S2SV_blank>"" ; ND_TCHECK2 ( cp [ len ] , hoplen ) <S2SV_ModStart> ) ) ; return ( 0 ) ; trunc : return ( - 1 ) ;
"
795,"CWE-200 static void ParseCommon ( map_string_t * settings , const char * conf_filename ) { const char * value ; value = get_map_string_item_or_NULL ( settings , ""WatchCrashdumpArchiveDir"" ) ; if ( value ) { g_settings_sWatchCrashdumpArchiveDir = xstrdup ( value ) ; remove_map_string_item ( settings , ""WatchCrashdumpArchiveDir"" ) ; } value = get_map_string_item_or_NULL ( settings , ""MaxCrashReportsSize"" ) ; if ( value ) { char * end ; errno = 0 ; unsigned long ul = strtoul ( value , & end , 10 ) ; if ( errno || end == value || * end != '\\0' || ul > INT_MAX ) error_msg ( ""Error<S2SV_blank>parsing<S2SV_blank>%s<S2SV_blank>setting:<S2SV_blank>\'%s\'"" , ""MaxCrashReportsSize"" , value ) ; else g_settings_nMaxCrashReportsSize = ul ; remove_map_string_item ( settings , ""MaxCrashReportsSize"" ) ; } value = get_map_string_item_or_NULL ( settings , ""DumpLocation"" ) ; if ( value ) { g_settings_dump_location = xstrdup ( value ) ; remove_map_string_item ( settings , ""DumpLocation"" ) ; } else g_settings_dump_location = xstrdup ( DEFAULT_DUMP_LOCATION ) ; value = get_map_string_item_or_NULL ( settings , ""DeleteUploaded"" ) ; if ( value ) { g_settings_delete_uploaded = string_to_bool ( value ) ; remove_map_string_item ( settings , ""DeleteUploaded"" ) ; } value = get_map_string_item_or_NULL ( settings , ""AutoreportingEnabled"" ) ; if ( value ) { g_settings_autoreporting = string_to_bool ( value ) ; remove_map_string_item ( settings , ""AutoreportingEnabled"" ) ; } value = get_map_string_item_or_NULL ( settings , ""AutoreportingEvent"" ) ; if ( value ) { g_settings_autoreporting_event = xstrdup ( value ) ; remove_map_string_item ( settings , ""AutoreportingEvent"" ) ; } else g_settings_autoreporting_event = xstrdup ( ""report_uReport"" ) ; value = get_map_string_item_or_NULL ( settings , ""ShortenedReporting"" ) ; if ( value ) { g_settings_shortenedreporting = string_to_bool ( value ) ; remove_map_string_item ( settings , ""ShortenedReporting"" ) ; } else g_settings_shortenedreporting = 0 ; <S2SV_StartBug> GHashTableIter iter ; <S2SV_EndBug> const char * name ; init_map_string_iter ( & iter , settings ) ; while ( next_map_string_iter ( & iter , & name , & value ) ) { error_msg ( ""Unrecognized<S2SV_blank>variable<S2SV_blank>\'%s\'<S2SV_blank>in<S2SV_blank>\'%s\'"" , name , conf_filename ) ; } }
","<S2SV_ModStart> = 0 ; value = get_map_string_item_or_NULL ( settings , ""PrivateReports"" ) ; if ( value ) { g_settings_privatereports = string_to_bool ( value ) ; remove_map_string_item ( settings , ""PrivateReports"" ) ; }
"
796,"CWE-22 char * compose_path ( ctrl_t * ctrl , char * path ) { struct stat st ; static char rpath [ PATH_MAX ] ; char * name , * ptr ; char dir [ PATH_MAX ] = { 0 } ; strlcpy ( dir , ctrl -> cwd , sizeof ( dir ) ) ; DBG ( ""Compose<S2SV_blank>path<S2SV_blank>from<S2SV_blank>cwd:<S2SV_blank>%s,<S2SV_blank>arg:<S2SV_blank>%s"" , ctrl -> cwd , path ? : """" ) ; if ( ! path || ! strlen ( path ) ) goto check ; if ( path ) { if ( path [ 0 ] != '/' ) { if ( dir [ strlen ( dir ) - 1 ] != '/' ) strlcat ( dir , ""/"" , sizeof ( dir ) ) ; } strlcat ( dir , path , sizeof ( dir ) ) ; } check : while ( ( ptr = strstr ( dir , ""//"" ) ) ) memmove ( ptr , & ptr [ 1 ] , strlen ( & ptr [ 1 ] ) + 1 ) ; if ( ! chrooted ) { size_t len = strlen ( home ) ; DBG ( ""Server<S2SV_blank>path<S2SV_blank>from<S2SV_blank>CWD:<S2SV_blank>%s"" , dir ) ; if ( len > 0 && home [ len - 1 ] == '/' ) len -- ; memmove ( dir + len , dir , strlen ( dir ) + 1 ) ; memcpy ( dir , home , len ) ; DBG ( ""Resulting<S2SV_blank>non-chroot<S2SV_blank>path:<S2SV_blank>%s"" , dir ) ; } if ( ! stat ( dir , & st ) && S_ISDIR ( st . st_mode ) ) { if ( ! realpath ( dir , rpath ) ) return NULL ; } else { name = basename ( path ) ; ptr = dirname ( dir ) ; memset ( rpath , 0 , sizeof ( rpath ) ) ; if ( ! realpath ( ptr , rpath ) ) { INFO ( ""Failed<S2SV_blank>realpath(%s):<S2SV_blank>%m"" , ptr ) ; return NULL ; } if ( rpath [ 1 ] != 0 ) strlcat ( rpath , ""/"" , sizeof ( rpath ) ) ; strlcat ( rpath , name , sizeof ( rpath ) ) ; } <S2SV_StartBug> if ( ! chrooted && strncmp ( dir , home , strlen ( home ) ) ) { <S2SV_EndBug> DBG ( ""Failed<S2SV_blank>non-chroot<S2SV_blank>dir:%s<S2SV_blank>vs<S2SV_blank>home:%s"" , dir , home ) ; return NULL ; } return rpath ; }
","<S2SV_ModStart> && strncmp ( rpath <S2SV_ModEnd> , home ,
"
797,"CWE-119 static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07 char magick [ 12 ] ; Image * image ; IndexPacket index ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; register IndexPacket * indexes ; register ssize_t x ; register PixelPacket * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , offset , pixel_info_length ; ssize_t count , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 2 ) || ( memcmp ( magick , ""\\122\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { image -> page . x = ReadBlobLSBShort ( image ) ; image -> page . y = ReadBlobLSBShort ( image ) ; image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlobByte ( image ) ; image -> matte = flags & 0x04 ? MagickTrue : MagickFalse ; number_planes = ( size_t ) ReadBlobByte ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; number_colormaps = ( size_t ) ReadBlobByte ( image ) ; map_length = ( unsigned char ) ReadBlobByte ( image ) ; if ( map_length >= 32 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; one = 1 ; map_length = one << map_length ; if ( ( number_planes == 0 ) || ( number_planes == 2 ) || ( ( flags & 0x04 ) && ( number_colormaps > 254 ) ) || ( bits_per_pixel != 8 ) || ( image -> columns == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( flags & 0x02 ) { for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) background_color [ i ] = 0 ; ( void ) ReadBlobByte ( image ) ; } else { p = background_color ; for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) * p ++ = ( unsigned char ) ReadBlobByte ( image ) ; } if ( ( number_planes & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } colormap = ( unsigned char * ) NULL ; if ( number_colormaps != 0 ) { colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps , 3 * map_length * sizeof ( * colormap ) ) ; if ( colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ ) * p ++ = ( unsigned char ) ScaleShortToQuantum ( ReadBlobLSBShort ( image ) ) ; } if ( ( flags & 0x08 ) != 0 ) { char * comment ; size_t length ; length = ReadBlobLSBShort ( image ) ; if ( length != 0 ) { comment = ( char * ) AcquireQuantumMemory ( length , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) ReadBlob ( image , length - 1 , ( unsigned char * ) comment ) ; comment [ length - 1 ] = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment ) ; comment = DestroyString ( comment ) ; if ( ( length & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; } } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } if ( image -> matte != MagickFalse ) number_planes ++ ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows * <S2SV_StartBug> number_planes_filled * sizeof ( * pixels ) ) ; <S2SV_EndBug> if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_StartBug> pixel_info_length = image -> columns * image -> rows * number_planes_filled ; <S2SV_EndBug> pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) { ssize_t j ; p = pixels ; for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( image -> matte == MagickFalse ) for ( j = 0 ; j < ( ssize_t ) number_planes ; j ++ ) * p ++ = background_color [ j ] ; else { for ( j = 0 ; j < ( ssize_t ) ( number_planes - 1 ) ; j ++ ) * p ++ = background_color [ j ] ; * p ++ = 0 ; } } } plane = 0 ; x = 0 ; y = 0 ; opcode = ReadBlobByte ( image ) ; do { switch ( opcode & 0x3f ) { case SkipLinesOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; x = 0 ; y += operand ; break ; } case SetColorOp : { operand = ReadBlobByte ( image ) ; plane = ( unsigned char ) operand ; if ( plane == 255 ) plane = ( unsigned char ) ( number_planes - 1 ) ; x = 0 ; break ; } case SkipPixelsOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; x += operand ; break ; } case ByteDataOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * number_planes + plane ; operand ++ ; if ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } if ( operand & 0x01 ) ( void ) ReadBlobByte ( image ) ; x += operand ; break ; } case RunDataOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; pixel = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) ReadBlobByte ( image ) ; operand ++ ; offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * number_planes + plane ; p = pixels + offset ; if ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } x += operand ; break ; } default : break ; } opcode = ReadBlobByte ( image ) ; } while ( ( ( opcode & 0x3f ) != EOFOp ) && ( opcode != EOF ) ) ; if ( number_colormaps != 0 ) { MagickStatusType mask ; mask = ( MagickStatusType ) ( map_length - 1 ) ; p = pixels ; x = ( ssize_t ) number_planes ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( IsValidColormapIndex ( image , * p & mask , & index , exception ) == MagickFalse ) break ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } else if ( ( number_planes >= 3 ) && ( number_colormaps >= 3 ) ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) for ( x = 0 ; x < ( ssize_t ) number_planes ; x ++ ) { if ( IsValidColormapIndex ( image , ( size_t ) ( x * map_length + ( * p & mask ) ) , & index , exception ) == MagickFalse ) break ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } if ( ( i < ( ssize_t ) number_pixels ) || ( x < ( ssize_t ) number_planes ) ) { colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } } if ( number_planes >= 3 ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; if ( image -> matte != MagickFalse ) SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( number_colormaps == 0 ) map_length = 256 ; if ( AcquireImageColormap ( image , map_length ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) i ) ; } else if ( number_colormaps > 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( * p ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( * ( p + map_length ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( * ( p + map_length * 2 ) ) ; p ++ ; } p = pixels ; if ( image -> matte == MagickFalse ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) SetPixelIndex ( indexes + x , * p ++ ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image ) ; } else { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) == MagickFalse ) break ; SetPixelRed ( q , image -> colormap [ ( ssize_t ) index ] . red ) ; if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) == MagickFalse ) break ; SetPixelGreen ( q , image -> colormap [ ( ssize_t ) index ] . green ) ; if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) == MagickFalse ) break ; SetPixelBlue ( q , image -> colormap [ ( ssize_t ) index ] . blue ) ; SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } image -> colormap = ( PixelPacket * ) RelinquishMagickMemory ( image -> colormap ) ; image -> storage_class = DirectClass ; image -> colors = 0 ; } } if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; ( void ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> -> rows * MagickMax ( number_planes_filled , 4 ) <S2SV_ModEnd> * sizeof ( <S2SV_ModStart> -> rows * MagickMax ( number_planes_filled , 4 ) <S2SV_ModEnd> ; pixels =
"
798,"CWE-264 SYSCALL_DEFINE2 ( osf_getdomainname , char __user * , name , int , namelen ) { unsigned len ; int i ; if ( ! access_ok ( VERIFY_WRITE , name , namelen ) ) return - EFAULT ; len = namelen ; <S2SV_StartBug> if ( namelen > 32 ) <S2SV_EndBug> len = 32 ; down_read ( & uts_sem ) ; for ( i = 0 ; i < len ; ++ i ) { __put_user ( utsname ( ) -> domainname [ i ] , name + i ) ; if ( utsname ( ) -> domainname [ i ] == '\\0' ) break ; } up_read ( & uts_sem ) ; return 0 ; }
","<S2SV_ModStart> ; if ( len <S2SV_ModEnd> > 32 )
"
799,"CWE-285 int jffs2_set_acl ( struct inode * inode , struct posix_acl * acl , int type ) { int rc , xprefix ; switch ( type ) { case ACL_TYPE_ACCESS : xprefix = JFFS2_XPREFIX_ACL_ACCESS ; if ( acl ) { <S2SV_StartBug> umode_t mode = inode -> i_mode ; <S2SV_EndBug> <S2SV_StartBug> rc = posix_acl_equiv_mode ( acl , & mode ) ; <S2SV_EndBug> if ( rc < 0 ) return rc ; if ( inode -> i_mode != mode ) { struct iattr attr ; attr . ia_valid = ATTR_MODE | ATTR_CTIME ; attr . ia_mode = mode ; attr . ia_ctime = CURRENT_TIME_SEC ; rc = jffs2_do_setattr ( inode , & attr ) ; if ( rc < 0 ) return rc ; } <S2SV_StartBug> if ( rc == 0 ) <S2SV_EndBug> acl = NULL ; } break ; case ACL_TYPE_DEFAULT : xprefix = JFFS2_XPREFIX_ACL_DEFAULT ; if ( ! S_ISDIR ( inode -> i_mode ) ) return acl ? - EACCES : 0 ; break ; default : return - EINVAL ; } rc = __jffs2_set_acl ( inode , xprefix , acl ) ; if ( ! rc ) set_cached_acl ( inode , type , acl ) ; return rc ; }
","<S2SV_ModStart> { umode_t mode ; rc = posix_acl_update_mode ( inode <S2SV_ModEnd> , & mode <S2SV_ModStart> , & mode , & acl ) ; if ( rc <S2SV_ModEnd> ) return rc <S2SV_ModStart> rc ; } <S2SV_ModEnd> } break ;
"
800,"CWE-190 <S2SV_StartBug> jas_matrix_t * jas_seq2d_create ( int xstart , int ystart , int xend , int yend ) <S2SV_EndBug> { jas_matrix_t * matrix ; assert ( xstart <= xend && ystart <= yend ) ; if ( ! ( matrix = jas_matrix_create ( yend - ystart , xend - xstart ) ) ) { return 0 ; } matrix -> xstart_ = xstart ; matrix -> ystart_ = ystart ; matrix -> xend_ = xend ; matrix -> yend_ = yend ; return matrix ; }
","<S2SV_ModStart> * jas_seq2d_create ( jas_matind_t xstart , jas_matind_t ystart , jas_matind_t xend , jas_matind_t <S2SV_ModEnd> yend ) {
"
801,"CWE-119 void vp8_yv12_copy_frame_c ( const YV12_BUFFER_CONFIG * src_ybc , YV12_BUFFER_CONFIG * dst_ybc ) { int row ; const uint8_t * src = src_ybc -> y_buffer ; uint8_t * dst = dst_ybc -> y_buffer ; # if 0 assert ( src_ybc -> y_width == dst_ybc -> y_width ) ; assert ( src_ybc -> y_height == dst_ybc -> y_height ) ; # endif <S2SV_StartBug> for ( row = 0 ; row < src_ybc -> y_height ; ++ row ) { <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( dst , src , src_ybc -> y_width ) ; <S2SV_EndBug> src += src_ybc -> y_stride ; dst += dst_ybc -> y_stride ; } src = src_ybc -> u_buffer ; dst = dst_ybc -> u_buffer ; for ( row = 0 ; row < src_ybc -> uv_height ; ++ row ) { <S2SV_StartBug> vpx_memcpy ( dst , src , src_ybc -> uv_width ) ; <S2SV_EndBug> src += src_ybc -> uv_stride ; dst += dst_ybc -> uv_stride ; } src = src_ybc -> v_buffer ; dst = dst_ybc -> v_buffer ; for ( row = 0 ; row < src_ybc -> uv_height ; ++ row ) { <S2SV_StartBug> vpx_memcpy ( dst , src , src_ybc -> uv_width ) ; <S2SV_EndBug> src += src_ybc -> uv_stride ; dst += dst_ybc -> uv_stride ; } vp8_yv12_extend_frame_borders_c ( dst_ybc ) ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> ; # endif # if CONFIG_VP9_HIGHBITDEPTH if ( src_ybc -> flags & YV12_FLAG_HIGHBITDEPTH ) { assert ( dst_ybc -> flags & YV12_FLAG_HIGHBITDEPTH ) ; <S2SV_ModStart> row ) { memcpy_short_addr <S2SV_ModEnd> ( dst , <S2SV_ModStart> row ) { memcpy_short_addr <S2SV_ModEnd> ( dst , <S2SV_ModStart> row ) { memcpy_short_addr <S2SV_ModEnd> ( dst , <S2SV_ModStart> dst_ybc ) ; return ; } else { assert ( ! ( dst_ybc -> flags & YV12_FLAG_HIGHBITDEPTH ) ) ; } # endif for ( row = 0 ; row < src_ybc -> y_height ; ++ row ) { memcpy ( dst , src , src_ybc -> y_width ) ; src += src_ybc -> y_stride ; dst += dst_ybc -> y_stride ; } src = src_ybc -> u_buffer ; dst = dst_ybc -> u_buffer ; for ( row = 0 ; row < src_ybc -> uv_height ; ++ row ) { memcpy ( dst , src , src_ybc -> uv_width ) ; src += src_ybc -> uv_stride ; dst += dst_ybc -> uv_stride ; } src = src_ybc -> v_buffer ; dst = dst_ybc -> v_buffer ; for ( row = 0 ; row < src_ybc -> uv_height ; ++ row ) { memcpy ( dst , src , src_ybc -> uv_width ) ; src += src_ybc -> uv_stride ; dst += dst_ybc -> uv_stride ; } vp8_yv12_extend_frame_borders_c ( dst_ybc ) ;
"
802,"CWE-119 <S2SV_StartBug> static void <S2SV_EndBug> swabHorDiff32 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { uint32 * wp = ( uint32 * ) cp0 ; tmsize_t wc = cc / 4 ; <S2SV_StartBug> horDiff32 ( tif , cp0 , cc ) ; <S2SV_EndBug> TIFFSwabArrayOfLong ( wp , wc ) ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> swabHorDiff32 ( TIFF <S2SV_ModStart> / 4 ; if ( ! <S2SV_ModStart> , cc ) ) return 0 <S2SV_ModStart> wc ) ; return 1 ;
"
803,"CWE-20 static int get_core_reg ( struct kvm_vcpu * vcpu , const struct kvm_one_reg * reg ) { __u32 __user * uaddr = ( __u32 __user * ) ( unsigned long ) reg -> addr ; struct kvm_regs * regs = vcpu_gp_regs ( vcpu ) ; int nr_regs = sizeof ( * regs ) / sizeof ( __u32 ) ; u32 off ; off = core_reg_offset_from_id ( reg -> id ) ; if ( off >= nr_regs || ( off + ( KVM_REG_SIZE ( reg -> id ) / sizeof ( __u32 ) ) ) >= nr_regs ) return - ENOENT ; <S2SV_StartBug> if ( copy_to_user ( uaddr , ( ( u32 * ) regs ) + off , KVM_REG_SIZE ( reg -> id ) ) ) <S2SV_EndBug> return - EFAULT ; return 0 ; }
","<S2SV_ModStart> ; if ( validate_core_offset ( reg ) ) return - EINVAL ; if (
"
804,"CWE-772 static Image * ReadDCMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { <S2SV_StartBug> # define ThrowDCMException ( exception , message ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( stream_info != ( DCMStreamInfo * ) NULL ) stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> char explicit_vr [ MaxTextExtent ] , implicit_vr [ MaxTextExtent ] , magick [ MaxTextExtent ] , photometric [ MaxTextExtent ] ; DCMInfo info ; DCMStreamInfo * stream_info ; Image * image ; int * bluemap , datum , * greenmap , * graymap , * redmap ; MagickBooleanType explicit_file , explicit_retry , sequence , use_explicit ; MagickOffsetType offset ; register unsigned char * p ; register ssize_t i ; size_t colors , height , length , number_scenes , quantum , status , width ; ssize_t count , scene ; unsigned char * data ; unsigned short group , element ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> depth = 8UL ; image -> endian = LSBEndian ; data = ( unsigned char * ) NULL ; stream_info = ( DCMStreamInfo * ) AcquireMagickMemory ( sizeof ( * stream_info ) ) ; if ( stream_info == ( DCMStreamInfo * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) ResetMagickMemory ( stream_info , 0 , sizeof ( * stream_info ) ) ; count = ReadBlob ( image , 128 , ( unsigned char * ) magick ) ; if ( count != 128 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; count = ReadBlob ( image , 4 , ( unsigned char * ) magick ) ; if ( ( count != 4 ) || ( LocaleNCompare ( magick , ""DICM"" , 4 ) != 0 ) ) { offset = SeekBlob ( image , 0L , SEEK_SET ) ; if ( offset < 0 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } ( void ) CopyMagickString ( photometric , ""MONOCHROME1<S2SV_blank>"" , MaxTextExtent ) ; info . polarity = MagickFalse ; info . scale = ( Quantum * ) NULL ; info . bits_allocated = 8 ; info . bytes_per_pixel = 1 ; info . depth = 8 ; info . mask = 0xffff ; info . max_value = 255UL ; info . samples_per_pixel = 1 ; info . signed_data = ( ~ 0UL ) ; info . significant_bits = 0 ; info . rescale = MagickFalse ; info . rescale_intercept = 0.0 ; info . rescale_slope = 1.0 ; info . window_center = 0.0 ; info . window_width = 0.0 ; data = ( unsigned char * ) NULL ; element = 0 ; explicit_vr [ 2 ] = '\\0' ; explicit_file = MagickFalse ; colors = 0 ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; graymap = ( int * ) NULL ; height = 0 ; number_scenes = 1 ; sequence = MagickFalse ; use_explicit = MagickFalse ; explicit_retry = MagickFalse ; width = 0 ; for ( group = 0 ; ( group != 0x7FE0 ) || ( element != 0x0010 ) || ( sequence != MagickFalse ) ; ) { image -> offset = ( ssize_t ) TellBlob ( image ) ; group = ReadBlobLSBShort ( image ) ; element = ReadBlobLSBShort ( image ) ; if ( ( group != 0x0002 ) && ( image -> endian == MSBEndian ) ) { group = ( unsigned short ) ( ( group << 8 ) | ( ( group >> 8 ) & 0xFF ) ) ; element = ( unsigned short ) ( ( element << 8 ) | ( ( element >> 8 ) & 0xFF ) ) ; } quantum = 0 ; for ( i = 0 ; dicom_info [ i ] . group < 0xffff ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) CopyMagickString ( implicit_vr , dicom_info [ i ] . vr , MaxTextExtent ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) explicit_vr ) ; if ( count != 2 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( explicit_file == MagickFalse ) && ( group != 0x0002 ) ) explicit_file = ( isupper ( ( unsigned char ) * explicit_vr ) != MagickFalse ) && ( isupper ( ( unsigned char ) * ( explicit_vr + 1 ) ) != MagickFalse ) ? MagickTrue : MagickFalse ; use_explicit = ( ( group == 0x0002 ) && ( explicit_retry == MagickFalse ) ) || ( explicit_file != MagickFalse ) ? MagickTrue : MagickFalse ; if ( ( use_explicit != MagickFalse ) && ( strncmp ( implicit_vr , ""xs"" , 2 ) == 0 ) ) ( void ) CopyMagickString ( implicit_vr , explicit_vr , MaxTextExtent ) ; if ( ( use_explicit == MagickFalse ) || ( strncmp ( implicit_vr , ""!!"" , 2 ) == 0 ) ) { offset = SeekBlob ( image , ( MagickOffsetType ) - 2 , SEEK_CUR ) ; if ( offset < 0 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; quantum = 4 ; } else { quantum = 2 ; if ( ( strncmp ( explicit_vr , ""OB"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""UN"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""OW"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""SQ"" , 2 ) == 0 ) ) { ( void ) ReadBlobLSBShort ( image ) ; quantum = 4 ; } } datum = 0 ; if ( quantum == 4 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( quantum == 2 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } quantum = 0 ; length = 1 ; if ( datum != 0 ) { if ( ( strncmp ( implicit_vr , ""SS"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""US"" , 2 ) == 0 ) ) quantum = 2 ; else if ( ( strncmp ( implicit_vr , ""UL"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""SL"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""FL"" , 2 ) == 0 ) ) quantum = 4 ; else if ( strncmp ( implicit_vr , ""FD"" , 2 ) != 0 ) quantum = 1 ; else quantum = 8 ; if ( datum != ~ 0 ) length = ( size_t ) datum / quantum ; else { quantum = 0 ; length = 0 ; } } if ( image_info -> verbose != MagickFalse ) { if ( use_explicit == MagickFalse ) explicit_vr [ 0 ] = '\\0' ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) FormatLocaleFile ( stdout , ""0x%04lX<S2SV_blank>%4ld<S2SV_blank>%s-%s<S2SV_blank>(0x%04lx,0x%04lx)"" , ( unsigned long ) image -> offset , ( long ) length , implicit_vr , explicit_vr , ( unsigned long ) group , ( unsigned long ) element ) ; if ( dicom_info [ i ] . description != ( char * ) NULL ) ( void ) FormatLocaleFile ( stdout , ""<S2SV_blank>%s"" , dicom_info [ i ] . description ) ; ( void ) FormatLocaleFile ( stdout , "":<S2SV_blank>"" ) ; } if ( ( sequence == MagickFalse ) && ( group == 0x7FE0 ) && ( element == 0x0010 ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""\\n"" ) ; break ; } data = ( unsigned char * ) NULL ; if ( ( length == 1 ) && ( quantum == 1 ) ) datum = ReadBlobByte ( image ) ; else if ( ( length == 1 ) && ( quantum == 2 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } else if ( ( length == 1 ) && ( quantum == 4 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( ( quantum != 0 ) && ( length != 0 ) ) { if ( length > GetBlobSize ( image ) ) <S2SV_StartBug> ThrowReaderException ( CorruptImageError , <S2SV_EndBug> ""InsufficientImageDataInFile"" ) ; if ( ~ length >= 1 ) data = ( unsigned char * ) AcquireQuantumMemory ( length + 1 , quantum * sizeof ( * data ) ) ; if ( data == ( unsigned char * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , ( size_t ) quantum * length , data ) ; if ( count != ( ssize_t ) ( quantum * length ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""count=%d<S2SV_blank>quantum=%d<S2SV_blank>"" ""length=%d<S2SV_blank>group=%d\\n"" , ( int ) count , ( int ) quantum , ( int ) length , ( int ) group ) ; ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } data [ length * quantum ] = '\\0' ; } else if ( ( unsigned int ) datum == 0xFFFFFFFFU ) { sequence = MagickTrue ; continue ; } if ( ( unsigned int ) ( ( group << 16 ) | element ) == 0xFFFEE0DD ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; sequence = MagickFalse ; continue ; } if ( sequence != MagickFalse ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; continue ; } switch ( group ) { case 0x0002 : { switch ( element ) { case 0x0010 : { char transfer_syntax [ MaxTextExtent ] ; if ( ( datum == 0 ) && ( explicit_retry == MagickFalse ) ) { explicit_retry = MagickTrue ; ( void ) SeekBlob ( image , ( MagickOffsetType ) 0 , SEEK_SET ) ; group = 0 ; element = 0 ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""Corrupted<S2SV_blank>image<S2SV_blank>-<S2SV_blank>trying<S2SV_blank>explicit<S2SV_blank>format\\n"" ) ; break ; } * transfer_syntax = '\\0' ; if ( data != ( unsigned char * ) NULL ) ( void ) CopyMagickString ( transfer_syntax , ( char * ) data , MaxTextExtent ) ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""transfer_syntax=%s\\n"" , ( const char * ) transfer_syntax ) ; if ( strncmp ( transfer_syntax , ""1.2.840.10008.1.2"" , 17 ) == 0 ) { int count , subtype , type ; type = 1 ; subtype = 0 ; if ( strlen ( transfer_syntax ) > 17 ) { count = sscanf ( transfer_syntax + 17 , "".%d.%d"" , & type , & subtype ) ; if ( count < 1 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } switch ( type ) { case 1 : { image -> endian = LSBEndian ; break ; } case 2 : { image -> endian = MSBEndian ; break ; } case 4 : { if ( ( subtype >= 80 ) && ( subtype <= 81 ) ) image -> compression = JPEGCompression ; else if ( ( subtype >= 90 ) && ( subtype <= 93 ) ) image -> compression = JPEG2000Compression ; else image -> compression = JPEGCompression ; break ; } case 5 : { image -> compression = RLECompression ; break ; } } } break ; } default : break ; } break ; } case 0x0028 : { switch ( element ) { case 0x0002 : { info . samples_per_pixel = ( size_t ) datum ; break ; } case 0x0004 : { if ( data == ( unsigned char * ) NULL ) break ; for ( i = 0 ; i < ( ssize_t ) MagickMin ( length , MaxTextExtent - 1 ) ; i ++ ) photometric [ i ] = ( char ) data [ i ] ; photometric [ i ] = '\\0' ; info . polarity = LocaleCompare ( photometric , ""MONOCHROME1<S2SV_blank>"" ) == 0 ? MagickTrue : MagickFalse ; break ; } case 0x0006 : { if ( datum == 1 ) image -> interlace = PlaneInterlace ; break ; } case 0x0008 : { if ( data == ( unsigned char * ) NULL ) break ; number_scenes = StringToUnsignedLong ( ( char * ) data ) ; break ; } case 0x0010 : { height = ( size_t ) datum ; break ; } case 0x0011 : { width = ( size_t ) datum ; break ; } case 0x0100 : { info . bits_allocated = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( datum > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . bits_allocated ; if ( info . depth > 32 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; info . max_value = ( 1UL << info . bits_allocated ) - 1 ; image -> depth = info . depth ; break ; } case 0x0101 : { info . significant_bits = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( info . significant_bits > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . significant_bits ; if ( info . depth > 32 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; info . max_value = ( 1UL << info . significant_bits ) - 1 ; info . mask = ( size_t ) GetQuantumRange ( info . significant_bits ) ; image -> depth = info . depth ; break ; } case 0x0102 : { break ; } case 0x0103 : { info . signed_data = ( size_t ) datum ; break ; } case 0x1050 : { if ( data != ( unsigned char * ) NULL ) info . window_center = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1051 : { if ( data != ( unsigned char * ) NULL ) info . window_width = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1052 : { if ( data != ( unsigned char * ) NULL ) info . rescale_intercept = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1053 : { if ( data != ( unsigned char * ) NULL ) info . rescale_slope = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1200 : case 0x3006 : { if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / info . bytes_per_pixel ) ; datum = ( int ) colors ; graymap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * graymap ) ) ; if ( graymap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) if ( info . bytes_per_pixel == 1 ) graymap [ i ] = ( int ) data [ i ] ; else graymap [ i ] = ( int ) ( ( short * ) data ) [ i ] ; break ; } case 0x1201 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; redmap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * redmap ) ) ; if ( redmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; redmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1202 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; greenmap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * greenmap ) ) ; if ( greenmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; greenmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1203 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; bluemap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * bluemap ) ) ; if ( bluemap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; bluemap [ i ] = ( int ) index ; p += 2 ; } break ; } default : break ; } break ; } case 0x2050 : { switch ( element ) { case 0x0020 : { if ( ( data != ( unsigned char * ) NULL ) && ( strncmp ( ( char * ) data , ""INVERSE"" , 7 ) == 0 ) ) info . polarity = MagickTrue ; break ; } default : break ; } break ; } default : break ; } if ( data != ( unsigned char * ) NULL ) { char * attribute ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; if ( dicom_info [ i ] . description != ( char * ) NULL ) { attribute = AcquireString ( ""dcm:"" ) ; ( void ) ConcatenateString ( & attribute , dicom_info [ i ] . description ) ; for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i == ( ssize_t ) length ) || ( length > 4 ) ) { ( void ) SubstituteString ( & attribute , ""<S2SV_blank>"" , """" ) ; ( void ) SetImageProperty ( image , attribute , ( char * ) data ) ; } attribute = DestroyString ( attribute ) ; } } if ( image_info -> verbose != MagickFalse ) { if ( data == ( unsigned char * ) NULL ) ( void ) FormatLocaleFile ( stdout , ""%d\\n"" , datum ) ; else { for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i != ( ssize_t ) length ) && ( length <= 4 ) ) { ssize_t j ; datum = 0 ; for ( j = ( ssize_t ) length - 1 ; j >= 0 ; j -- ) datum = ( 256 * datum + data [ j ] ) ; ( void ) FormatLocaleFile ( stdout , ""%d"" , datum ) ; } else for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) if ( isprint ( ( int ) data [ i ] ) != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""%c"" , data [ i ] ) ; else ( void ) FormatLocaleFile ( stdout , ""%c"" , '.' ) ; ( void ) FormatLocaleFile ( stdout , ""\\n"" ) ; } } if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } if ( ( width == 0 ) || ( height == 0 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; if ( info . signed_data == 0xffff ) info . signed_data = ( size_t ) ( info . significant_bits == 16 ? 1 : 0 ) ; if ( ( image -> compression == JPEGCompression ) || ( image -> compression == JPEG2000Compression ) ) { Image * images ; ImageInfo * read_info ; int c ; size_t length ; unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) ( void ) ReadBlobByte ( image ) ; tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; ( void ) tag ; length = ( size_t ) ReadBlobLSBLong ( image ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { MagickOffsetType offset ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; offset = TellBlob ( image ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; images = NewImageList ( ) ; for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { char filename [ MaxTextExtent ] ; const char * property ; FILE * file ; Image * jpeg_image ; int unique_file ; unsigned int tag ; tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( tag == 0xFFFEE0DD ) break ; if ( tag != 0xFFFEE000 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ; if ( file == ( FILE * ) NULL ) { ( void ) RelinquishUniqueFileResource ( filename ) ; ThrowFileException ( exception , FileOpenError , ""UnableToCreateTemporaryFile"" , filename ) ; break ; } for ( ; length != 0 ; length -- ) { c = ReadBlobByte ( image ) ; if ( c == EOF ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } ( void ) fputc ( c , file ) ; } ( void ) fclose ( file ) ; ( void ) FormatLocaleString ( read_info -> filename , MaxTextExtent , ""jpeg:%s"" , filename ) ; if ( image -> compression == JPEG2000Compression ) ( void ) FormatLocaleString ( read_info -> filename , MaxTextExtent , ""j2k:%s"" , filename ) ; jpeg_image = ReadImage ( read_info , exception ) ; if ( jpeg_image != ( Image * ) NULL ) { ResetImagePropertyIterator ( image ) ; property = GetNextImageProperty ( image ) ; while ( property != ( const char * ) NULL ) { ( void ) SetImageProperty ( jpeg_image , property , GetImageProperty ( image , property ) ) ; property = GetNextImageProperty ( image ) ; } AppendImageToList ( & images , jpeg_image ) ; } ( void ) RelinquishUniqueFileResource ( filename ) ; } read_info = DestroyImageInfo ( read_info ) ; image = DestroyImage ( image ) ; return ( GetFirstImageInList ( images ) ) ; } if ( info . depth != ( 1UL * MAGICKCORE_QUANTUM_DEPTH ) ) { QuantumAny range ; size_t length ; length = ( size_t ) ( GetQuantumRange ( info . depth ) + 1 ) ; info . scale = ( Quantum * ) AcquireQuantumMemory ( length , sizeof ( * info . scale ) ) ; if ( info . scale == ( Quantum * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; range = GetQuantumRange ( info . depth ) ; for ( i = 0 ; i <= ( ssize_t ) GetQuantumRange ( info . depth ) ; i ++ ) info . scale [ i ] = ScaleAnyToQuantum ( ( size_t ) i , range ) ; } if ( image -> compression == RLECompression ) { size_t length ; unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) ( void ) ReadBlobByte ( image ) ; tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; ( void ) tag ; length = ( size_t ) ReadBlobLSBLong ( image ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { MagickOffsetType offset ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; offset = TellBlob ( image ) + 8 ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } } for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { if ( image_info -> ping != MagickFalse ) break ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; image -> depth = info . depth ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; break ; } image -> colorspace = RGBColorspace ; if ( ( image -> colormap == ( PixelPacket * ) NULL ) && ( info . samples_per_pixel == 1 ) ) { int index ; size_t one ; one = 1 ; if ( colors == 0 ) colors = one << info . depth ; if ( AcquireImageColormap ( image , colors ) == MagickFalse ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( redmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = redmap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( Quantum ) index ; } if ( greenmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = greenmap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . green = ( Quantum ) index ; } if ( bluemap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = bluemap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . blue = ( Quantum ) index ; } if ( graymap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = graymap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( Quantum ) index ; image -> colormap [ i ] . green = ( Quantum ) index ; image -> colormap [ i ] . blue = ( Quantum ) index ; } } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) ( void ) ReadBlobByte ( image ) ; tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; stream_info -> remaining = ( size_t ) ReadBlobLSBLong ( image ) ; if ( ( tag != 0xFFFEE000 ) || ( stream_info -> remaining <= 64 ) || ( EOFBlob ( image ) != MagickFalse ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; stream_info -> count = 0 ; stream_info -> segment_count = ReadBlobLSBLong ( image ) ; for ( i = 0 ; i < 15 ; i ++ ) stream_info -> segments [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; stream_info -> remaining -= 64 ; if ( stream_info -> segment_count > 1 ) { info . bytes_per_pixel = 1 ; info . depth = 8 ; if ( stream_info -> offset_count > 0 ) ( void ) SeekBlob ( image , stream_info -> offsets [ 0 ] + stream_info -> segments [ 0 ] , SEEK_SET ) ; } } if ( ( info . samples_per_pixel > 1 ) && ( image -> interlace == PlaneInterlace ) ) { register ssize_t x ; register PixelPacket * q ; ssize_t y ; for ( i = 0 ; i < ( ssize_t ) info . samples_per_pixel ; i ++ ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { switch ( ( int ) i ) { case 0 : { SetPixelRed ( q , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) ) ; break ; } case 1 : { SetPixelGreen ( q , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) ) ; break ; } case 2 : { SetPixelBlue ( q , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) ) ; break ; } case 3 : { SetPixelAlpha ( q , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) ) ; break ; } default : break ; } q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } } else { const char * option ; option = GetImageOption ( image_info , ""dcm:display-range"" ) ; if ( option != ( const char * ) NULL ) { if ( LocaleCompare ( option , ""reset"" ) == 0 ) info . window_width = 0 ; } option = GetImageOption ( image_info , ""dcm:window"" ) ; if ( option != ( char * ) NULL ) { GeometryInfo geometry_info ; MagickStatusType flags ; flags = ParseGeometry ( option , & geometry_info ) ; if ( flags & RhoValue ) info . window_center = geometry_info . rho ; if ( flags & SigmaValue ) info . window_width = geometry_info . sigma ; info . rescale = MagickTrue ; } option = GetImageOption ( image_info , ""dcm:rescale"" ) ; if ( option != ( char * ) NULL ) info . rescale = IsStringTrue ( option ) ; if ( ( info . window_center != 0 ) && ( info . window_width == 0 ) ) info . window_width = info . window_center ; status = ReadDCMPixels ( image , & info , stream_info , MagickTrue , exception ) ; if ( ( status != MagickFalse ) && ( stream_info -> segment_count > 1 ) ) { if ( stream_info -> offset_count > 0 ) ( void ) SeekBlob ( image , stream_info -> offsets [ 0 ] + stream_info -> segments [ 1 ] , SEEK_SET ) ; ( void ) ReadDCMPixels ( image , & info , stream_info , MagickFalse , exception ) ; } } if ( SetImageGray ( image , exception ) != MagickFalse ) ( void ) SetImageColorspace ( image , GRAYColorspace ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( scene < ( ssize_t ) ( number_scenes - 1 ) ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> , message ) \\\n{ <S2SV_ModEnd> if ( data <S2SV_ModStart> ) ) ; \\\n} <S2SV_ModEnd> char explicit_vr [ <S2SV_ModStart> image ) ) ThrowDCMException <S2SV_ModEnd> ( CorruptImageError ,
"
805,"CWE-119 int main ( int argc , char * * argv ) { FILE * infile = NULL ; <S2SV_StartBug> vpx_codec_ctx_t codec = { 0 } ; <S2SV_EndBug> <S2SV_StartBug> vpx_codec_enc_cfg_t cfg = { 0 } ; <S2SV_EndBug> int frame_count = 0 ; <S2SV_StartBug> vpx_image_t raw = { 0 } ; <S2SV_EndBug> vpx_codec_err_t res ; <S2SV_StartBug> VpxVideoInfo info = { 0 } ; <S2SV_EndBug> VpxVideoWriter * writer = NULL ; const VpxInterface * encoder = NULL ; const int fps = 2 ; const double bits_per_pixel_per_frame = 0.067 ; exec_name = argv [ 0 ] ; if ( argc != 6 ) die ( ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments"" ) ; <S2SV_StartBug> encoder = get_vpx_encoder_by_name ( argv [ 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! encoder ) <S2SV_EndBug> <S2SV_StartBug> die ( ""Unsupported<S2SV_blank>codec."" ) ; <S2SV_EndBug> info . codec_fourcc = encoder -> fourcc ; info . frame_width = strtol ( argv [ 2 ] , NULL , 0 ) ; info . frame_height = strtol ( argv [ 3 ] , NULL , 0 ) ; info . time_base . numerator = 1 ; info . time_base . denominator = fps ; if ( info . frame_width <= 0 || info . frame_height <= 0 || ( info . frame_width % 2 ) != 0 || ( info . frame_height % 2 ) != 0 ) { die ( ""Invalid<S2SV_blank>frame<S2SV_blank>size:<S2SV_blank>%dx%d"" , info . frame_width , info . frame_height ) ; } if ( ! vpx_img_alloc ( & raw , VPX_IMG_FMT_I420 , info . frame_width , info . frame_height , 1 ) ) { die ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>image."" ) ; } <S2SV_StartBug> printf ( ""Using<S2SV_blank>%s\\n"" , vpx_codec_iface_name ( encoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> res = vpx_codec_enc_config_default ( encoder -> interface ( ) , & cfg , 0 ) ; <S2SV_EndBug> if ( res ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>default<S2SV_blank>codec<S2SV_blank>config."" ) ; cfg . g_w = info . frame_width ; cfg . g_h = info . frame_height ; cfg . g_timebase . num = info . time_base . numerator ; cfg . g_timebase . den = info . time_base . denominator ; cfg . rc_target_bitrate = ( unsigned int ) ( bits_per_pixel_per_frame * cfg . g_w * cfg . g_h * fps / 1000 ) ; cfg . g_lag_in_frames = 0 ; writer = vpx_video_writer_open ( argv [ 5 ] , kContainerIVF , & info ) ; if ( ! writer ) die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing."" , argv [ 5 ] ) ; if ( ! ( infile = fopen ( argv [ 4 ] , ""rb"" ) ) ) die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading."" , argv [ 4 ] ) ; <S2SV_StartBug> if ( vpx_codec_enc_init ( & codec , encoder -> interface ( ) , & cfg , 0 ) ) <S2SV_EndBug> die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>encoder"" ) ; while ( vpx_img_read ( & raw , infile ) ) { ++ frame_count ; if ( frame_count == 22 && encoder -> fourcc == VP8_FOURCC ) { set_roi_map ( & cfg , & codec ) ; } else if ( frame_count == 33 ) { set_active_map ( & cfg , & codec ) ; } else if ( frame_count == 44 ) { unset_active_map ( & cfg , & codec ) ; } encode_frame ( & codec , & raw , frame_count , writer ) ; } <S2SV_StartBug> encode_frame ( & codec , NULL , - 1 , writer ) ; <S2SV_EndBug> printf ( ""\\n"" ) ; fclose ( infile ) ; printf ( ""Processed<S2SV_blank>%d<S2SV_blank>frames.\\n"" , frame_count ) ; vpx_img_free ( & raw ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec."" ) ; vpx_video_writer_close ( writer ) ; return EXIT_SUCCESS ; }
","<S2SV_ModStart> ; vpx_codec_ctx_t codec <S2SV_ModEnd> ; vpx_codec_enc_cfg_t cfg <S2SV_ModStart> ; vpx_codec_enc_cfg_t cfg <S2SV_ModEnd> ; int frame_count <S2SV_ModStart> ; vpx_image_t raw <S2SV_ModEnd> ; vpx_codec_err_t res <S2SV_ModStart> ; VpxVideoInfo info <S2SV_ModEnd> ; VpxVideoWriter * <S2SV_ModStart> ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments"" ) ; memset ( & info , 0 , sizeof ( info ) ) ; <S2SV_ModStart> ; if ( encoder == NULL ) { <S2SV_ModEnd> die ( ""Unsupported<S2SV_blank>codec."" <S2SV_ModStart> die ( ""Unsupported<S2SV_blank>codec."" ) ; } assert ( encoder != NULL <S2SV_ModStart> ( encoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> ( encoder -> codec_interface <S2SV_ModEnd> ( ) , <S2SV_ModStart> , encoder -> codec_interface <S2SV_ModEnd> ( ) , <S2SV_ModStart> ) ; } while ( <S2SV_ModStart> , writer ) ) { } <S2SV_ModEnd> printf ( ""\\n""
"
806,"CWE-362 static int <S2SV_StartBug> mptctl_fw_download ( unsigned long arg ) <S2SV_EndBug> { struct mpt_fw_xfer __user * ufwdl = ( void __user * ) arg ; struct mpt_fw_xfer kfwdl ; if ( copy_from_user ( & kfwdl , ufwdl , sizeof ( struct mpt_fw_xfer ) ) ) { printk ( KERN_ERR MYNAM ""%s@%d::_ioctl_fwdl<S2SV_blank>-<S2SV_blank>"" ""Unable<S2SV_blank>to<S2SV_blank>copy<S2SV_blank>mpt_fw_xfer<S2SV_blank>struct<S2SV_blank>@<S2SV_blank>%p\\n"" , __FILE__ , __LINE__ , ufwdl ) ; return - EFAULT ; } <S2SV_StartBug> return mptctl_do_fw_download ( kfwdl . iocnum , kfwdl . bufp , kfwdl . fwlen ) ; <S2SV_EndBug> }
","<S2SV_ModStart> int mptctl_fw_download ( MPT_ADAPTER * iocp , <S2SV_ModStart> return mptctl_do_fw_download ( iocp <S2SV_ModEnd> , kfwdl .
"
807,"CWE-399 static int swp_handler ( struct pt_regs * regs , unsigned int instr ) { unsigned int address , destreg , data , type ; unsigned int res = 0 ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , regs -> ARM_pc ) ; <S2SV_EndBug> if ( current -> pid != previous_pid ) { pr_debug ( ""\\""%s\\""<S2SV_blank>(%ld)<S2SV_blank>uses<S2SV_blank>deprecated<S2SV_blank>SWP{B}<S2SV_blank>instruction\\n"" , current -> comm , ( unsigned long ) current -> pid ) ; previous_pid = current -> pid ; } address = regs -> uregs [ EXTRACT_REG_NUM ( instr , RN_OFFSET ) ] ; data = regs -> uregs [ EXTRACT_REG_NUM ( instr , RT2_OFFSET ) ] ; destreg = EXTRACT_REG_NUM ( instr , RT_OFFSET ) ; type = instr & TYPE_SWPB ; pr_debug ( ""addr<S2SV_blank>in<S2SV_blank>r%d->0x%08x,<S2SV_blank>dest<S2SV_blank>is<S2SV_blank>r%d,<S2SV_blank>source<S2SV_blank>in<S2SV_blank>r%d->0x%08x)\\n"" , EXTRACT_REG_NUM ( instr , RN_OFFSET ) , address , destreg , EXTRACT_REG_NUM ( instr , RT2_OFFSET ) , data ) ; if ( ! access_ok ( VERIFY_WRITE , ( address & ~ 3 ) , 4 ) ) { pr_debug ( ""SWP{B}<S2SV_blank>emulation:<S2SV_blank>access<S2SV_blank>to<S2SV_blank>%p<S2SV_blank>not<S2SV_blank>allowed!\\n"" , ( void * ) address ) ; res = - EFAULT ; } else { res = emulate_swpX ( address , & data , type ) ; } if ( res == 0 ) { regs -> ARM_pc += 4 ; regs -> uregs [ destreg ] = data ; } else if ( res == - EFAULT ) { set_segfault ( regs , address ) ; } return 0 ; }
","<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , regs
"
808,"CWE-129 int snmp_version ( void * context , size_t hdrlen , unsigned char tag , const void * data , size_t datalen ) { <S2SV_StartBug> if ( * ( unsigned char * ) data > 1 ) <S2SV_EndBug> return - ENOTSUPP ; return 1 ; }
","<S2SV_ModStart> { if ( datalen != 1 ) return - EINVAL ; if (
"
809,"CWE-119 <S2SV_StartBug> void vp9_iht4x4_add ( TX_TYPE tx_type , const int16_t * input , uint8_t * dest , <S2SV_EndBug> int stride , int eob ) { if ( tx_type == DCT_DCT ) vp9_idct4x4_add ( input , dest , stride , eob ) ; else vp9_iht4x4_16_add ( input , dest , stride , tx_type ) ; }
","<S2SV_ModStart> tx_type , const tran_low_t <S2SV_ModEnd> * input ,
"
810,"CWE-125 void cfm_print ( netdissect_options * ndo , register const u_char * pptr , register u_int length ) { const struct cfm_common_header_t * cfm_common_header ; const struct cfm_tlv_header_t * cfm_tlv_header ; const uint8_t * tptr , * tlv_ptr ; const uint8_t * namesp ; u_int names_data_remaining ; uint8_t md_nameformat , md_namelength ; const uint8_t * md_name ; uint8_t ma_nameformat , ma_namelength ; const uint8_t * ma_name ; u_int hexdump , tlen , cfm_tlv_len , cfm_tlv_type , ccm_interval ; union { const struct cfm_ccm_t * cfm_ccm ; const struct cfm_lbm_t * cfm_lbm ; const struct cfm_ltm_t * cfm_ltm ; const struct cfm_ltr_t * cfm_ltr ; } msg_ptr ; tptr = pptr ; cfm_common_header = ( const struct cfm_common_header_t * ) pptr ; if ( length < sizeof ( * cfm_common_header ) ) goto tooshort ; ND_TCHECK ( * cfm_common_header ) ; if ( CFM_EXTRACT_VERSION ( cfm_common_header -> mdlevel_version ) != CFM_VERSION ) { ND_PRINT ( ( ndo , ""CFMv%u<S2SV_blank>not<S2SV_blank>supported,<S2SV_blank>length<S2SV_blank>%u"" , CFM_EXTRACT_VERSION ( cfm_common_header -> mdlevel_version ) , length ) ) ; return ; } ND_PRINT ( ( ndo , ""CFMv%u<S2SV_blank>%s,<S2SV_blank>MD<S2SV_blank>Level<S2SV_blank>%u,<S2SV_blank>length<S2SV_blank>%u"" , CFM_EXTRACT_VERSION ( cfm_common_header -> mdlevel_version ) , tok2str ( cfm_opcode_values , ""unknown<S2SV_blank>(%u)"" , cfm_common_header -> opcode ) , CFM_EXTRACT_MD_LEVEL ( cfm_common_header -> mdlevel_version ) , length ) ) ; if ( ndo -> ndo_vflag < 1 ) { return ; } ND_PRINT ( ( ndo , ""\\n\\tFirst<S2SV_blank>TLV<S2SV_blank>offset<S2SV_blank>%u"" , cfm_common_header -> first_tlv_offset ) ) ; tptr += sizeof ( const struct cfm_common_header_t ) ; tlen = length - sizeof ( struct cfm_common_header_t ) ; if ( cfm_common_header -> first_tlv_offset > tlen ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>large,<S2SV_blank>must<S2SV_blank>be<S2SV_blank><=<S2SV_blank>%u)"" , tlen ) ) ; return ; } switch ( cfm_common_header -> opcode ) { case CFM_OPCODE_CCM : msg_ptr . cfm_ccm = ( const struct cfm_ccm_t * ) tptr ; if ( cfm_common_header -> first_tlv_offset < sizeof ( * msg_ptr . cfm_ccm ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>small<S2SV_blank>1,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>%lu)"" , ( unsigned long ) sizeof ( * msg_ptr . cfm_ccm ) ) ) ; return ; } if ( tlen < sizeof ( * msg_ptr . cfm_ccm ) ) goto tooshort ; ND_TCHECK ( * msg_ptr . cfm_ccm ) ; ccm_interval = CFM_EXTRACT_CCM_INTERVAL ( cfm_common_header -> flags ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[CCM<S2SV_blank>Interval<S2SV_blank>%u%s]"" , ccm_interval , cfm_common_header -> flags & CFM_CCM_RDI_FLAG ? "",<S2SV_blank>RDI"" : """" ) ) ; if ( ccm_interval ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>CCM<S2SV_blank>Interval<S2SV_blank>%.3fs"" "",<S2SV_blank>min<S2SV_blank>CCM<S2SV_blank>Lifetime<S2SV_blank>%.3fs,<S2SV_blank>max<S2SV_blank>CCM<S2SV_blank>Lifetime<S2SV_blank>%.3fs"" , ccm_interval_base [ ccm_interval ] , ccm_interval_base [ ccm_interval ] * CCM_INTERVAL_MIN_MULTIPLIER , ccm_interval_base [ ccm_interval ] * CCM_INTERVAL_MAX_MULTIPLIER ) ) ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Sequence<S2SV_blank>Number<S2SV_blank>0x%08x,<S2SV_blank>MA-End-Point-ID<S2SV_blank>0x%04x"" , EXTRACT_32BITS ( msg_ptr . cfm_ccm -> sequence ) , EXTRACT_16BITS ( msg_ptr . cfm_ccm -> ma_epi ) ) ) ; namesp = msg_ptr . cfm_ccm -> names ; names_data_remaining = sizeof ( msg_ptr . cfm_ccm -> names ) ; md_nameformat = * namesp ; namesp ++ ; names_data_remaining -- ; if ( md_nameformat != CFM_CCM_MD_FORMAT_NONE ) { md_namelength = * namesp ; namesp ++ ; names_data_remaining -- ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>MD<S2SV_blank>Name<S2SV_blank>Format<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>MD<S2SV_blank>Name<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( cfm_md_nameformat_values , ""Unknown"" , md_nameformat ) , md_nameformat , md_namelength ) ) ; if ( md_namelength > names_data_remaining - 3 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>large,<S2SV_blank>must<S2SV_blank>be<S2SV_blank><=<S2SV_blank>%u)"" , names_data_remaining - 2 ) ) ; return ; } md_name = namesp ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>MD<S2SV_blank>Name:<S2SV_blank>"" ) ) ; switch ( md_nameformat ) { case CFM_CCM_MD_FORMAT_DNS : case CFM_CCM_MD_FORMAT_CHAR : safeputs ( ndo , md_name , md_namelength ) ; break ; case CFM_CCM_MD_FORMAT_MAC : if ( md_namelength == 6 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>MAC<S2SV_blank>%s"" , etheraddr_string ( ndo , md_name ) ) ) ; } else { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>MAC<S2SV_blank>(length<S2SV_blank>invalid)"" ) ) ; } break ; case CFM_CCM_MA_FORMAT_8021 : default : print_unknown_data ( ndo , md_name , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , md_namelength ) ; } namesp += md_namelength ; names_data_remaining -= md_namelength ; } else { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>MD<S2SV_blank>Name<S2SV_blank>Format<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( cfm_md_nameformat_values , ""Unknown"" , md_nameformat ) , md_nameformat ) ) ; } ma_nameformat = * namesp ; namesp ++ ; names_data_remaining -- ; ma_namelength = * namesp ; namesp ++ ; names_data_remaining -- ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>MA<S2SV_blank>Name-Format<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>MA<S2SV_blank>name<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( cfm_ma_nameformat_values , ""Unknown"" , ma_nameformat ) , ma_nameformat , ma_namelength ) ) ; if ( ma_namelength > names_data_remaining ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>large,<S2SV_blank>must<S2SV_blank>be<S2SV_blank><=<S2SV_blank>%u)"" , names_data_remaining ) ) ; return ; } ma_name = namesp ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>MA<S2SV_blank>Name:<S2SV_blank>"" ) ) ; switch ( ma_nameformat ) { case CFM_CCM_MA_FORMAT_CHAR : safeputs ( ndo , ma_name , ma_namelength ) ; break ; case CFM_CCM_MA_FORMAT_8021 : case CFM_CCM_MA_FORMAT_VID : case CFM_CCM_MA_FORMAT_INT : case CFM_CCM_MA_FORMAT_VPN : default : print_unknown_data ( ndo , ma_name , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , ma_namelength ) ; } break ; case CFM_OPCODE_LTM : msg_ptr . cfm_ltm = ( const struct cfm_ltm_t * ) tptr ; if ( cfm_common_header -> first_tlv_offset < sizeof ( * msg_ptr . cfm_ltm ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>small<S2SV_blank>4,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>%lu)"" , ( unsigned long ) sizeof ( * msg_ptr . cfm_ltm ) ) ) ; return ; } if ( tlen < sizeof ( * msg_ptr . cfm_ltm ) ) goto tooshort ; ND_TCHECK ( * msg_ptr . cfm_ltm ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s]"" , bittok2str ( cfm_ltm_flag_values , ""none"" , cfm_common_header -> flags ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Transaction-ID<S2SV_blank>0x%08x,<S2SV_blank>ttl<S2SV_blank>%u"" , EXTRACT_32BITS ( msg_ptr . cfm_ltm -> transaction_id ) , msg_ptr . cfm_ltm -> ttl ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Original-MAC<S2SV_blank>%s,<S2SV_blank>Target-MAC<S2SV_blank>%s"" , etheraddr_string ( ndo , msg_ptr . cfm_ltm -> original_mac ) , etheraddr_string ( ndo , msg_ptr . cfm_ltm -> target_mac ) ) ) ; break ; case CFM_OPCODE_LTR : msg_ptr . cfm_ltr = ( const struct cfm_ltr_t * ) tptr ; if ( cfm_common_header -> first_tlv_offset < sizeof ( * msg_ptr . cfm_ltr ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>small<S2SV_blank>5,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>%lu)"" , ( unsigned long ) sizeof ( * msg_ptr . cfm_ltr ) ) ) ; return ; } if ( tlen < sizeof ( * msg_ptr . cfm_ltr ) ) goto tooshort ; ND_TCHECK ( * msg_ptr . cfm_ltr ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s]"" , bittok2str ( cfm_ltr_flag_values , ""none"" , cfm_common_header -> flags ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Transaction-ID<S2SV_blank>0x%08x,<S2SV_blank>ttl<S2SV_blank>%u"" , EXTRACT_32BITS ( msg_ptr . cfm_ltr -> transaction_id ) , msg_ptr . cfm_ltr -> ttl ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Replay-Action<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( cfm_ltr_replay_action_values , ""Unknown"" , msg_ptr . cfm_ltr -> replay_action ) , msg_ptr . cfm_ltr -> replay_action ) ) ; break ; case CFM_OPCODE_LBR : case CFM_OPCODE_LBM : default : print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank>"" , tlen - cfm_common_header -> first_tlv_offset ) ; break ; } tptr += cfm_common_header -> first_tlv_offset ; tlen -= cfm_common_header -> first_tlv_offset ; while ( tlen > 0 ) { cfm_tlv_header = ( const struct cfm_tlv_header_t * ) tptr ; ND_TCHECK2 ( * tptr , 1 ) ; cfm_tlv_type = cfm_tlv_header -> type ; ND_PRINT ( ( ndo , ""\\n\\t%s<S2SV_blank>TLV<S2SV_blank>(0x%02x)"" , tok2str ( cfm_tlv_values , ""Unknown"" , cfm_tlv_type ) , cfm_tlv_type ) ) ; if ( cfm_tlv_type == CFM_TLV_END ) { return ; } if ( tlen < sizeof ( struct cfm_tlv_header_t ) ) goto tooshort ; ND_TCHECK2 ( * tptr , sizeof ( struct cfm_tlv_header_t ) ) ; cfm_tlv_len = EXTRACT_16BITS ( & cfm_tlv_header -> length ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>length<S2SV_blank>%u"" , cfm_tlv_len ) ) ; tptr += sizeof ( struct cfm_tlv_header_t ) ; tlen -= sizeof ( struct cfm_tlv_header_t ) ; tlv_ptr = tptr ; if ( tlen < cfm_tlv_len ) goto tooshort ; ND_TCHECK2 ( * tptr , cfm_tlv_len ) ; hexdump = FALSE ; switch ( cfm_tlv_type ) { case CFM_TLV_PORT_STATUS : if ( cfm_tlv_len < 1 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>1)"" ) ) ; return ; } ND_PRINT ( ( ndo , "",<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( cfm_tlv_port_status_values , ""Unknown"" , * tptr ) , * tptr ) ) ; break ; case CFM_TLV_INTERFACE_STATUS : if ( cfm_tlv_len < 1 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>1)"" ) ) ; return ; } ND_PRINT ( ( ndo , "",<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( cfm_tlv_interface_status_values , ""Unknown"" , * tptr ) , * tptr ) ) ; break ; case CFM_TLV_PRIVATE : if ( cfm_tlv_len < 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>4)"" ) ) ; return ; } ND_PRINT ( ( ndo , "",<S2SV_blank>Vendor:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Sub-Type<S2SV_blank>%u"" , tok2str ( oui_values , ""Unknown"" , EXTRACT_24BITS ( tptr ) ) , EXTRACT_24BITS ( tptr ) , * ( tptr + 3 ) ) ) ; hexdump = TRUE ; break ; case CFM_TLV_SENDER_ID : { u_int chassis_id_type , chassis_id_length ; u_int mgmt_addr_length ; if ( cfm_tlv_len < 1 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>1)"" ) ) ; <S2SV_StartBug> return ; <S2SV_EndBug> } chassis_id_length = * tptr ; tptr ++ ; tlen -- ; cfm_tlv_len -- ; if ( chassis_id_length ) { if ( cfm_tlv_len < 1 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>(TLV<S2SV_blank>too<S2SV_blank>short)"" ) ) ; <S2SV_StartBug> return ; <S2SV_EndBug> } chassis_id_type = * tptr ; cfm_tlv_len -- ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Chassis-ID<S2SV_blank>Type<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Chassis-ID<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( cfm_tlv_senderid_chassisid_values , ""Unknown"" , chassis_id_type ) , chassis_id_type , chassis_id_length ) ) ; if ( cfm_tlv_len < chassis_id_length ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>(TLV<S2SV_blank>too<S2SV_blank>short)"" ) ) ; <S2SV_StartBug> return ; <S2SV_EndBug> } switch ( chassis_id_type ) { <S2SV_StartBug> case CFM_CHASSIS_ID_MAC_ADDRESS : <S2SV_EndBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>MAC<S2SV_blank>%s"" , etheraddr_string ( ndo , tptr + 1 ) ) ) ; break ; case CFM_CHASSIS_ID_NETWORK_ADDRESS : <S2SV_StartBug> hexdump |= cfm_network_addr_print ( ndo , tptr ) ; <S2SV_EndBug> break ; case CFM_CHASSIS_ID_INTERFACE_NAME : case CFM_CHASSIS_ID_INTERFACE_ALIAS : case CFM_CHASSIS_ID_LOCAL : case CFM_CHASSIS_ID_CHASSIS_COMPONENT : case CFM_CHASSIS_ID_PORT_COMPONENT : safeputs ( ndo , tptr + 1 , chassis_id_length ) ; break ; default : hexdump = TRUE ; break ; } cfm_tlv_len -= chassis_id_length ; tptr += 1 + chassis_id_length ; tlen -= 1 + chassis_id_length ; } if ( cfm_tlv_len == 0 ) { <S2SV_StartBug> return ; <S2SV_EndBug> } mgmt_addr_length = * tptr ; tptr ++ ; tlen -- ; cfm_tlv_len -- ; <S2SV_StartBug> if ( mgmt_addr_length ) { <S2SV_EndBug> if ( cfm_tlv_len < mgmt_addr_length ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>(TLV<S2SV_blank>too<S2SV_blank>short)"" ) ) ; <S2SV_StartBug> return ; <S2SV_EndBug> } <S2SV_StartBug> cfm_tlv_len -= mgmt_addr_length ; <S2SV_EndBug> tptr += mgmt_addr_length ; tlen -= mgmt_addr_length ; if ( cfm_tlv_len < 1 ) { <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>(TLV<S2SV_blank>too<S2SV_blank>short)"" ) ) ; <S2SV_EndBug> return ; } mgmt_addr_length = * tptr ; tptr ++ ; tlen -- ; cfm_tlv_len -- ; <S2SV_StartBug> if ( mgmt_addr_length ) { <S2SV_EndBug> if ( cfm_tlv_len < mgmt_addr_length ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>(TLV<S2SV_blank>too<S2SV_blank>short)"" ) ) ; return ; } <S2SV_StartBug> cfm_tlv_len -= mgmt_addr_length ; <S2SV_EndBug> tptr += mgmt_addr_length ; tlen -= mgmt_addr_length ; } } break ; } case CFM_TLV_DATA : case CFM_TLV_REPLY_INGRESS : case CFM_TLV_REPLY_EGRESS : default : hexdump = TRUE ; break ; } if ( hexdump || ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , tlv_ptr , ""\\n\\t<S2SV_blank><S2SV_blank>"" , cfm_tlv_len ) ; <S2SV_StartBug> tptr += cfm_tlv_len ; <S2SV_EndBug> tlen -= cfm_tlv_len ; } return ; tooshort : ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank>packet<S2SV_blank>is<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; trunc : ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank>packet<S2SV_blank>exceeded<S2SV_blank>snapshot"" ) ) ; }
","<S2SV_ModStart> ) ) ; goto next_tlv <S2SV_ModEnd> ; } chassis_id_length <S2SV_ModStart> ) ) ; goto next_tlv <S2SV_ModEnd> ; } chassis_id_type <S2SV_ModStart> ) ) ; goto next_tlv <S2SV_ModEnd> ; } switch <S2SV_ModStart> case CFM_CHASSIS_ID_MAC_ADDRESS : if ( chassis_id_length != ETHER_ADDR_LEN ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(invalid<S2SV_blank>MAC<S2SV_blank>address<S2SV_blank>length)"" ) ) ; hexdump = TRUE ; break ; } <S2SV_ModStart> ndo , tptr + 1 , chassis_id_length <S2SV_ModStart> 0 ) { break <S2SV_ModEnd> ; } mgmt_addr_length <S2SV_ModStart> cfm_tlv_len -- ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Management<S2SV_blank>Address<S2SV_blank>Domain<S2SV_blank>Length<S2SV_blank>%u"" , mgmt_addr_length ) ) ; <S2SV_ModStart> ) ) ; goto next_tlv <S2SV_ModEnd> ; } cfm_tlv_len <S2SV_ModStart> cfm_tlv_len -= mgmt_addr_length ; hex_print ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Management<S2SV_blank>Address<S2SV_blank>Domain:<S2SV_blank>"" , tptr , mgmt_addr_length ) <S2SV_ModStart> ( ndo , ""<S2SV_blank>(Management<S2SV_blank>Address<S2SV_blank>Length<S2SV_blank>is<S2SV_blank>missing)"" ) ) ; hexdump = TRUE ; break <S2SV_ModEnd> ; } mgmt_addr_length <S2SV_ModStart> cfm_tlv_len -- ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Management<S2SV_blank>Address<S2SV_blank>Length<S2SV_blank>%u"" , mgmt_addr_length ) ) ; <S2SV_ModStart> cfm_tlv_len -= mgmt_addr_length ; hex_print ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Management<S2SV_blank>Address:<S2SV_blank>"" , tptr , mgmt_addr_length ) <S2SV_ModStart> cfm_tlv_len ) ; next_tlv :
"
811,"CWE-617 static Image * ReadMPCImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char cache_filename [ MagickPathExtent ] , id [ MagickPathExtent ] , keyword [ MagickPathExtent ] , * options ; const unsigned char * p ; GeometryInfo geometry_info ; Image * image ; int c ; LinkedListInfo * profiles ; MagickBooleanType status ; MagickOffsetType offset ; MagickStatusType flags ; register ssize_t i ; size_t depth , length ; ssize_t count ; StringInfo * profile ; unsigned int signature ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) CopyMagickString ( cache_filename , image -> filename , MagickPathExtent ) ; AppendImageFormat ( ""cache"" , cache_filename ) ; c = ReadBlobByte ( image ) ; if ( c == EOF ) { image = DestroyImage ( image ) ; return ( ( Image * ) NULL ) ; } * id = '\\0' ; ( void ) ResetMagickMemory ( keyword , 0 , sizeof ( keyword ) ) ; offset = 0 ; do { profiles = ( LinkedListInfo * ) NULL ; length = MagickPathExtent ; options = AcquireString ( ( char * ) NULL ) ; signature = GetMagickSignature ( ( const StringInfo * ) NULL ) ; image -> depth = 8 ; image -> compression = NoCompression ; while ( ( isgraph ( c ) != MagickFalse ) && ( c != ( int ) ':' ) ) { register char * p ; if ( c == ( int ) '{' ) { char * comment ; length = MagickPathExtent ; comment = AcquireString ( ( char * ) NULL ) ; for ( p = comment ; comment != ( char * ) NULL ; p ++ ) { c = ReadBlobByte ( image ) ; if ( c == ( int ) '\\\\' ) c = ReadBlobByte ( image ) ; else if ( ( c == EOF ) || ( c == ( int ) '}' ) ) break ; if ( ( size_t ) ( p - comment + 1 ) >= length ) { * p = '\\0' ; length <<= 1 ; comment = ( char * ) ResizeQuantumMemory ( comment , length + MagickPathExtent , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) break ; p = comment + strlen ( comment ) ; } * p = ( char ) c ; } if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; * p = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment , exception ) ; comment = DestroyString ( comment ) ; c = ReadBlobByte ( image ) ; } else if ( isalnum ( c ) != MagickFalse ) { length = MagickPathExtent ; p = keyword ; do { if ( c == ( int ) '=' ) break ; if ( ( size_t ) ( p - keyword ) < ( MagickPathExtent - 1 ) ) * p ++ = ( char ) c ; c = ReadBlobByte ( image ) ; } while ( c != EOF ) ; * p = '\\0' ; p = options ; while ( isspace ( ( int ) ( ( unsigned char ) c ) ) != 0 ) c = ReadBlobByte ( image ) ; if ( c == ( int ) '=' ) { c = ReadBlobByte ( image ) ; while ( ( c != ( int ) '}' ) && ( c != EOF ) ) { if ( ( size_t ) ( p - options + 1 ) >= length ) { * p = '\\0' ; length <<= 1 ; options = ( char * ) ResizeQuantumMemory ( options , length + MagickPathExtent , sizeof ( * options ) ) ; if ( options == ( char * ) NULL ) break ; p = options + strlen ( options ) ; } * p ++ = ( char ) c ; c = ReadBlobByte ( image ) ; if ( c == '\\\\' ) { c = ReadBlobByte ( image ) ; if ( c == ( int ) '}' ) { * p ++ = ( char ) c ; c = ReadBlobByte ( image ) ; } } if ( * options != '{' ) if ( isspace ( ( int ) ( ( unsigned char ) c ) ) != 0 ) break ; } if ( options == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } * p = '\\0' ; if ( * options == '{' ) ( void ) CopyMagickString ( options , options + 1 , strlen ( options ) ) ; switch ( * keyword ) { case 'a' : case 'A' : { if ( LocaleCompare ( keyword , ""alpha-trait"" ) == 0 ) { ssize_t alpha_trait ; alpha_trait = ParseCommandOption ( MagickPixelTraitOptions , MagickFalse , options ) ; if ( alpha_trait < 0 ) break ; image -> alpha_trait = ( PixelTrait ) alpha_trait ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'b' : case 'B' : { if ( LocaleCompare ( keyword , ""background-color"" ) == 0 ) { ( void ) QueryColorCompliance ( options , AllCompliance , & image -> background_color , exception ) ; break ; } if ( LocaleCompare ( keyword , ""blue-primary"" ) == 0 ) { flags = ParseGeometry ( options , & geometry_info ) ; image -> chromaticity . blue_primary . x = geometry_info . rho ; image -> chromaticity . blue_primary . y = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> chromaticity . blue_primary . y = image -> chromaticity . blue_primary . x ; break ; } if ( LocaleCompare ( keyword , ""border-color"" ) == 0 ) { ( void ) QueryColorCompliance ( options , AllCompliance , & image -> border_color , exception ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'c' : case 'C' : { if ( LocaleCompare ( keyword , ""class"" ) == 0 ) { ssize_t storage_class ; storage_class = ParseCommandOption ( MagickClassOptions , MagickFalse , options ) ; if ( storage_class < 0 ) break ; image -> storage_class = ( ClassType ) storage_class ; break ; } if ( LocaleCompare ( keyword , ""colors"" ) == 0 ) { image -> colors = StringToUnsignedLong ( options ) ; break ; } if ( LocaleCompare ( keyword , ""colorspace"" ) == 0 ) { ssize_t colorspace ; colorspace = ParseCommandOption ( MagickColorspaceOptions , MagickFalse , options ) ; if ( colorspace < 0 ) break ; image -> colorspace = ( ColorspaceType ) colorspace ; break ; } if ( LocaleCompare ( keyword , ""compression"" ) == 0 ) { ssize_t compression ; compression = ParseCommandOption ( MagickCompressOptions , MagickFalse , options ) ; if ( compression < 0 ) break ; image -> compression = ( CompressionType ) compression ; break ; } if ( LocaleCompare ( keyword , ""columns"" ) == 0 ) { image -> columns = StringToUnsignedLong ( options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'd' : case 'D' : { if ( LocaleCompare ( keyword , ""delay"" ) == 0 ) { image -> delay = StringToUnsignedLong ( options ) ; break ; } if ( LocaleCompare ( keyword , ""depth"" ) == 0 ) { image -> depth = StringToUnsignedLong ( options ) ; break ; } if ( LocaleCompare ( keyword , ""dispose"" ) == 0 ) { ssize_t dispose ; dispose = ParseCommandOption ( MagickDisposeOptions , MagickFalse , options ) ; if ( dispose < 0 ) break ; image -> dispose = ( DisposeType ) dispose ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'e' : case 'E' : { if ( LocaleCompare ( keyword , ""endian"" ) == 0 ) { ssize_t endian ; endian = ParseCommandOption ( MagickEndianOptions , MagickFalse , options ) ; if ( endian < 0 ) break ; image -> endian = ( EndianType ) endian ; break ; } if ( LocaleCompare ( keyword , ""error"" ) == 0 ) { image -> error . mean_error_per_pixel = StringToDouble ( options , ( char * * ) NULL ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'g' : case 'G' : { if ( LocaleCompare ( keyword , ""gamma"" ) == 0 ) { image -> gamma = StringToDouble ( options , ( char * * ) NULL ) ; break ; } if ( LocaleCompare ( keyword , ""green-primary"" ) == 0 ) { flags = ParseGeometry ( options , & geometry_info ) ; image -> chromaticity . green_primary . x = geometry_info . rho ; image -> chromaticity . green_primary . y = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> chromaticity . green_primary . y = image -> chromaticity . green_primary . x ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'i' : case 'I' : { if ( LocaleCompare ( keyword , ""id"" ) == 0 ) { ( void ) CopyMagickString ( id , options , MagickPathExtent ) ; break ; } if ( LocaleCompare ( keyword , ""iterations"" ) == 0 ) { image -> iterations = StringToUnsignedLong ( options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'm' : case 'M' : { if ( LocaleCompare ( keyword , ""magick-signature"" ) == 0 ) { signature = ( unsigned int ) StringToUnsignedLong ( options ) ; break ; } if ( LocaleCompare ( keyword , ""mattecolor"" ) == 0 ) { ( void ) QueryColorCompliance ( options , AllCompliance , & image -> matte_color , exception ) ; break ; } if ( LocaleCompare ( keyword , ""maximum-error"" ) == 0 ) { image -> error . normalized_maximum_error = StringToDouble ( options , ( char * * ) NULL ) ; break ; } if ( LocaleCompare ( keyword , ""mean-error"" ) == 0 ) { image -> error . normalized_mean_error = StringToDouble ( options , ( char * * ) NULL ) ; break ; } if ( LocaleCompare ( keyword , ""montage"" ) == 0 ) { ( void ) CloneString ( & image -> montage , options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'n' : case 'N' : { if ( LocaleCompare ( keyword , ""number-channels"" ) == 0 ) { image -> number_channels = StringToUnsignedLong ( options ) ; break ; } if ( LocaleCompare ( keyword , ""number-meta-channels"" ) == 0 ) { image -> number_meta_channels = StringToUnsignedLong ( options ) ; <S2SV_StartBug> break ; <S2SV_EndBug> } break ; } case 'o' : case 'O' : { if ( LocaleCompare ( keyword , ""orientation"" ) == 0 ) { ssize_t orientation ; orientation = ParseCommandOption ( MagickOrientationOptions , MagickFalse , options ) ; if ( orientation < 0 ) break ; image -> orientation = ( OrientationType ) orientation ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'p' : case 'P' : { if ( LocaleCompare ( keyword , ""page"" ) == 0 ) { char * geometry ; geometry = GetPageGeometry ( options ) ; ( void ) ParseAbsoluteGeometry ( geometry , & image -> page ) ; geometry = DestroyString ( geometry ) ; break ; } if ( LocaleCompare ( keyword , ""pixel-intensity"" ) == 0 ) { ssize_t intensity ; intensity = ParseCommandOption ( MagickPixelIntensityOptions , MagickFalse , options ) ; if ( intensity < 0 ) break ; image -> intensity = ( PixelIntensityMethod ) intensity ; break ; } if ( ( LocaleNCompare ( keyword , ""profile:"" , 8 ) == 0 ) || ( LocaleNCompare ( keyword , ""profile-"" , 8 ) == 0 ) ) { if ( profiles == ( LinkedListInfo * ) NULL ) profiles = NewLinkedList ( 0 ) ; ( void ) AppendValueToLinkedList ( profiles , AcquireString ( keyword + 8 ) ) ; profile = BlobToStringInfo ( ( const void * ) NULL , ( size_t ) StringToLong ( options ) ) ; if ( profile == ( StringInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) SetImageProfile ( image , keyword + 8 , profile , exception ) ; profile = DestroyStringInfo ( profile ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'q' : case 'Q' : { if ( LocaleCompare ( keyword , ""quality"" ) == 0 ) { image -> quality = StringToUnsignedLong ( options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'r' : case 'R' : { if ( LocaleCompare ( keyword , ""red-primary"" ) == 0 ) { flags = ParseGeometry ( options , & geometry_info ) ; image -> chromaticity . red_primary . x = geometry_info . rho ; if ( ( flags & SigmaValue ) != 0 ) image -> chromaticity . red_primary . y = geometry_info . sigma ; break ; } if ( LocaleCompare ( keyword , ""rendering-intent"" ) == 0 ) { ssize_t rendering_intent ; rendering_intent = ParseCommandOption ( MagickIntentOptions , MagickFalse , options ) ; if ( rendering_intent < 0 ) break ; image -> rendering_intent = ( RenderingIntent ) rendering_intent ; break ; } if ( LocaleCompare ( keyword , ""resolution"" ) == 0 ) { flags = ParseGeometry ( options , & geometry_info ) ; image -> resolution . x = geometry_info . rho ; image -> resolution . y = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> resolution . y = image -> resolution . x ; break ; } if ( LocaleCompare ( keyword , ""rows"" ) == 0 ) { image -> rows = StringToUnsignedLong ( options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 's' : case 'S' : { if ( LocaleCompare ( keyword , ""scene"" ) == 0 ) { image -> scene = StringToUnsignedLong ( options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 't' : case 'T' : { if ( LocaleCompare ( keyword , ""ticks-per-second"" ) == 0 ) { image -> ticks_per_second = ( ssize_t ) StringToLong ( options ) ; break ; } if ( LocaleCompare ( keyword , ""tile-offset"" ) == 0 ) { char * geometry ; geometry = GetPageGeometry ( options ) ; ( void ) ParseAbsoluteGeometry ( geometry , & image -> tile_offset ) ; geometry = DestroyString ( geometry ) ; } if ( LocaleCompare ( keyword , ""type"" ) == 0 ) { ssize_t type ; type = ParseCommandOption ( MagickTypeOptions , MagickFalse , options ) ; if ( type < 0 ) break ; image -> type = ( ImageType ) type ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'u' : case 'U' : { if ( LocaleCompare ( keyword , ""units"" ) == 0 ) { ssize_t units ; units = ParseCommandOption ( MagickResolutionOptions , MagickFalse , options ) ; if ( units < 0 ) break ; image -> units = ( ResolutionType ) units ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'w' : case 'W' : { if ( LocaleCompare ( keyword , ""white-point"" ) == 0 ) { flags = ParseGeometry ( options , & geometry_info ) ; image -> chromaticity . white_point . x = geometry_info . rho ; image -> chromaticity . white_point . y = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> chromaticity . white_point . y = image -> chromaticity . white_point . x ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } default : { ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } } } else c = ReadBlobByte ( image ) ; while ( isspace ( ( int ) ( ( unsigned char ) c ) ) != 0 ) c = ReadBlobByte ( image ) ; } options = DestroyString ( options ) ; ( void ) ReadBlobByte ( image ) ; if ( ( LocaleCompare ( id , ""MagickCache"" ) != 0 ) || ( image -> storage_class == UndefinedClass ) || ( image -> compression == UndefinedCompression ) || ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( signature != GetMagickSignature ( ( const StringInfo * ) NULL ) ) ThrowReaderException ( CacheError , ""IncompatibleAPI"" ) ; if ( image -> montage != ( char * ) NULL ) { register char * p ; length = MagickPathExtent ; image -> directory = AcquireString ( ( char * ) NULL ) ; p = image -> directory ; do { * p = '\\0' ; if ( ( strlen ( image -> directory ) + MagickPathExtent ) >= length ) { length <<= 1 ; image -> directory = ( char * ) ResizeQuantumMemory ( image -> directory , length + MagickPathExtent , sizeof ( * image -> directory ) ) ; if ( image -> directory == ( char * ) NULL ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; p = image -> directory + strlen ( image -> directory ) ; } c = ReadBlobByte ( image ) ; * p ++ = ( char ) c ; } while ( c != ( int ) '\\0' ) ; } if ( profiles != ( LinkedListInfo * ) NULL ) { const char * name ; const StringInfo * profile ; register unsigned char * p ; ResetLinkedListIterator ( profiles ) ; name = ( const char * ) GetNextValueInLinkedList ( profiles ) ; while ( name != ( const char * ) NULL ) { profile = GetImageProfile ( image , name ) ; if ( profile != ( StringInfo * ) NULL ) { p = GetStringInfoDatum ( profile ) ; count = ReadBlob ( image , GetStringInfoLength ( profile ) , p ) ; } name = ( const char * ) GetNextValueInLinkedList ( profiles ) ; } profiles = DestroyLinkedList ( profiles , RelinquishMagickMemory ) ; } depth = GetImageQuantumDepth ( image , MagickFalse ) ; if ( image -> storage_class == PseudoClass ) { image -> colormap = ( PixelInfo * ) AcquireQuantumMemory ( image -> colors + 1 , sizeof ( * image -> colormap ) ) ; if ( image -> colormap == ( PixelInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( image -> colors != 0 ) { size_t packet_size ; unsigned char * colormap ; packet_size = ( size_t ) ( 3UL * depth / 8UL ) ; colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , packet_size * sizeof ( * colormap ) ) ; if ( colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , packet_size * image -> colors , colormap ) ; if ( count != ( ssize_t ) ( packet_size * image -> colors ) ) { colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } p = colormap ; switch ( depth ) { default : colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; ThrowReaderException ( CorruptImageError , ""ImageDepthNotSupported"" ) ; case 8 : { unsigned char pixel ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { p = PushCharPixel ( p , & pixel ) ; image -> colormap [ i ] . red = ScaleCharToQuantum ( pixel ) ; p = PushCharPixel ( p , & pixel ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( pixel ) ; p = PushCharPixel ( p , & pixel ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( pixel ) ; } break ; } case 16 : { unsigned short pixel ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { p = PushShortPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . red = ScaleShortToQuantum ( pixel ) ; p = PushShortPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . green = ScaleShortToQuantum ( pixel ) ; p = PushShortPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . blue = ScaleShortToQuantum ( pixel ) ; } break ; } case 32 : { unsigned int pixel ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { p = PushLongPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . red = ScaleLongToQuantum ( pixel ) ; p = PushLongPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . green = ScaleLongToQuantum ( pixel ) ; p = PushLongPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . blue = ScaleLongToQuantum ( pixel ) ; } break ; } } colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; } } if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( ( AcquireMagickResource ( WidthResource , image -> columns ) == MagickFalse ) || ( AcquireMagickResource ( HeightResource , image -> rows ) == MagickFalse ) ) ThrowReaderException ( ImageError , ""WidthOrHeightExceedsLimit"" ) ; status = PersistPixelCache ( image , cache_filename , MagickTrue , & offset , exception ) ; if ( status == MagickFalse ) ThrowReaderException ( CacheError , ""UnableToPersistPixelCache"" ) ; do { c = ReadBlobByte ( image ) ; } while ( ( isgraph ( c ) == MagickFalse ) && ( c != EOF ) ) ; if ( c != EOF ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( c != EOF ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> options ) ; if ( image -> number_meta_channels > MaxPixelChannels ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;
"
812,"CWE-125 void isakmp_rfc3948_print ( netdissect_options * ndo , const u_char * bp , u_int length , const u_char * bp2 ) { <S2SV_StartBug> if ( length == 1 && bp [ 0 ] == 0xff ) { <S2SV_EndBug> ND_PRINT ( ( ndo , ""isakmp-nat-keep-alive"" ) ) ; return ; } if ( length < 4 ) { goto trunc ; <S2SV_StartBug> } <S2SV_EndBug> if ( bp [ 0 ] == 0 && bp [ 1 ] == 0 && bp [ 2 ] == 0 && bp [ 3 ] == 0 ) { ND_PRINT ( ( ndo , ""NONESP-encap:<S2SV_blank>"" ) ) ; isakmp_print ( ndo , bp + 4 , length - 4 , bp2 ) ; return ; } { int nh , enh , padlen ; int advance ; ND_PRINT ( ( ndo , ""UDP-encap:<S2SV_blank>"" ) ) ; advance = esp_print ( ndo , bp , length , bp2 , & enh , & padlen ) ; if ( advance <= 0 ) return ; bp += advance ; length -= advance + padlen ; nh = enh & 0xff ; ip_print_inner ( ndo , bp , length , nh , bp2 ) ; return ; } trunc : ND_PRINT ( ( ndo , ""[|isakmp]"" ) ) ; return ; }
","<S2SV_ModStart> bp2 ) { ND_TCHECK ( bp [ 0 ] ) ; <S2SV_ModStart> trunc ; } ND_TCHECK ( bp [ 3 ] ) ;
"
813,"CWE-125 static RList * r_bin_wasm_get_global_entries ( RBinWasmObj * bin , RBinWasmSection * sec ) { RList * ret = NULL ; RBinWasmGlobalEntry * ptr = NULL ; <S2SV_StartBug> int buflen = bin -> buf -> length ; <S2SV_EndBug> if ( sec -> payload_data + 32 > buflen ) { return NULL ; } if ( ! ( ret = r_list_newf ( ( RListFree ) free ) ) ) { return NULL ; } ut8 * buf = bin -> buf -> buf + ( ut32 ) sec -> payload_data ; ut32 len = sec -> payload_len ; ut32 count = sec -> count ; ut32 i = 0 , r = 0 ; while ( i < len && len < buflen && r < count ) { if ( ! ( ptr = R_NEW0 ( RBinWasmGlobalEntry ) ) ) { return ret ; } if ( len + 8 > buflen || ! ( consume_u8 ( buf + i , buf + len , ( ut8 * ) & ptr -> content_type , & i ) ) ) { goto beach ; } if ( len + 8 > buflen || ! ( consume_u8 ( buf + i , buf + len , & ptr -> mutability , & i ) ) ) { goto beach ; } if ( len + 8 > buflen || ! ( consume_init_expr ( buf + i , buf + len , R_BIN_WASM_END_OF_CODE , NULL , & i ) ) ) { goto beach ; } r_list_append ( ret , ptr ) ; r ++ ; } return ret ; beach : free ( ptr ) ; return ret ; }
","<S2SV_ModStart> = NULL ; if ( ! ( ret = r_list_newf ( ( RListFree ) free ) ) ) { return NULL ; } ut8 * buf = bin -> buf -> buf + ( ut32 ) sec -> payload_data ; <S2SV_ModStart> buf -> length - <S2SV_ModEnd> ( ut32 )
"
814,"CWE-200 static __net_init int setup_net ( struct net * net , struct user_namespace * user_ns ) { const struct pernet_operations * ops , * saved_ops ; int error = 0 ; LIST_HEAD ( net_exit_list ) ; refcount_set ( & net -> count , 1 ) ; refcount_set ( & net -> passive , 1 ) ; <S2SV_StartBug> net -> dev_base_seq = 1 ; <S2SV_EndBug> net -> user_ns = user_ns ; idr_init ( & net -> netns_ids ) ; spin_lock_init ( & net -> nsid_lock ) ; mutex_init ( & net -> ipv4 . ra_mutex ) ; list_for_each_entry ( ops , & pernet_list , list ) { error = ops_init ( ops , net ) ; if ( error < 0 ) goto out_undo ; } down_write ( & net_rwsem ) ; list_add_tail_rcu ( & net -> list , & net_namespace_list ) ; up_write ( & net_rwsem ) ; out : return error ; out_undo : list_add ( & net -> exit_list , & net_exit_list ) ; saved_ops = ops ; list_for_each_entry_continue_reverse ( ops , & pernet_list , list ) ops_exit_list ( ops , & net_exit_list ) ; ops = saved_ops ; list_for_each_entry_continue_reverse ( ops , & pernet_list , list ) ops_free_list ( ops , & net_exit_list ) ; rcu_barrier ( ) ; goto out ; }
","<S2SV_ModStart> 1 ) ; get_random_bytes ( & net -> hash_mix , sizeof ( u32 ) ) ;
"
815,"CWE-79 static int php_handler ( request_rec * r ) { php_struct * volatile ctx ; void * conf ; apr_bucket_brigade * volatile brigade ; apr_bucket * bucket ; apr_status_t rv ; request_rec * volatile parent_req = NULL ; TSRMLS_FETCH ( ) ; # define PHPAP_INI_OFF php_apache_ini_dtor ( r , parent_req TSRMLS_CC ) ; conf = ap_get_module_config ( r -> per_dir_config , & php5_module ) ; ctx = SG ( server_context ) ; if ( ctx == NULL || ( ctx && ctx -> request_processed && ! strcmp ( r -> protocol , ""INCLUDED"" ) ) ) { normal : ctx = SG ( server_context ) = apr_pcalloc ( r -> pool , sizeof ( * ctx ) ) ; apr_pool_cleanup_register ( r -> pool , ( void * ) & SG ( server_context ) , php_server_context_cleanup , apr_pool_cleanup_null ) ; ctx -> r = r ; ctx = NULL ; } else { parent_req = ctx -> r ; ctx -> r = r ; } apply_config ( conf ) ; if ( strcmp ( r -> handler , PHP_MAGIC_TYPE ) && strcmp ( r -> handler , PHP_SOURCE_MAGIC_TYPE ) && strcmp ( r -> handler , PHP_SCRIPT ) ) { if ( ! AP2 ( xbithack ) || strcmp ( r -> handler , ""text/html"" ) || ! ( r -> finfo . protection & APR_UEXECUTE ) ) { PHPAP_INI_OFF ; return DECLINED ; } } if ( r -> used_path_info == AP_REQ_REJECT_PATH_INFO && r -> path_info && r -> path_info [ 0 ] ) { PHPAP_INI_OFF ; return HTTP_NOT_FOUND ; } if ( ! AP2 ( engine ) ) { PHPAP_INI_OFF ; return DECLINED ; } if ( r -> finfo . filetype == 0 ) { php_apache_sapi_log_message_ex ( ""script<S2SV_blank>\'%s\'<S2SV_blank>not<S2SV_blank>found<S2SV_blank>or<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>stat"" , r TSRMLS_CC ) ; PHPAP_INI_OFF ; return HTTP_NOT_FOUND ; } if ( r -> finfo . filetype == APR_DIR ) { php_apache_sapi_log_message_ex ( ""attempt<S2SV_blank>to<S2SV_blank>invoke<S2SV_blank>directory<S2SV_blank>\'%s\'<S2SV_blank>as<S2SV_blank>script"" , r TSRMLS_CC ) ; PHPAP_INI_OFF ; return HTTP_FORBIDDEN ; } if ( r -> main == NULL || r -> subprocess_env != r -> main -> subprocess_env ) { ap_add_common_vars ( r ) ; ap_add_cgi_vars ( r ) ; } zend_first_try { if ( ctx == NULL ) { brigade = apr_brigade_create ( r -> pool , r -> connection -> bucket_alloc ) ; ctx = SG ( server_context ) ; ctx -> brigade = brigade ; if ( php_apache_request_ctor ( r , ctx TSRMLS_CC ) != SUCCESS ) { zend_bailout ( ) ; } } else { if ( ! parent_req ) { parent_req = ctx -> r ; } if ( parent_req && parent_req -> handler && strcmp ( parent_req -> handler , PHP_MAGIC_TYPE ) && strcmp ( parent_req -> handler , PHP_SOURCE_MAGIC_TYPE ) && strcmp ( parent_req -> handler , PHP_SCRIPT ) ) { if ( php_apache_request_ctor ( r , ctx TSRMLS_CC ) != SUCCESS ) { zend_bailout ( ) ; } } if ( parent_req && parent_req -> status != HTTP_OK && parent_req -> status != 413 && strcmp ( r -> protocol , ""INCLUDED"" ) ) { parent_req = NULL ; goto normal ; } ctx -> r = r ; brigade = ctx -> brigade ; } if ( AP2 ( last_modified ) ) { ap_update_mtime ( r , r -> finfo . mtime ) ; ap_set_last_modified ( r ) ; } if ( strncmp ( r -> handler , PHP_SOURCE_MAGIC_TYPE , sizeof ( PHP_SOURCE_MAGIC_TYPE ) - 1 ) == 0 ) { zend_syntax_highlighter_ini syntax_highlighter_ini ; php_get_highlight_struct ( & syntax_highlighter_ini ) ; highlight_file ( ( char * ) r -> filename , & syntax_highlighter_ini TSRMLS_CC ) ; } else { zend_file_handle zfd ; zfd . type = ZEND_HANDLE_FILENAME ; zfd . filename = ( char * ) r -> filename ; zfd . free_filename = 0 ; zfd . opened_path = NULL ; if ( ! parent_req ) { php_execute_script ( & zfd TSRMLS_CC ) ; } else { zend_execute_scripts ( ZEND_INCLUDE TSRMLS_CC , NULL , 1 , & zfd ) ; } apr_table_set ( r -> notes , ""mod_php_memory_usage"" , apr_psprintf ( ctx -> r -> pool , ""%"" APR_SIZE_T_FMT , zend_memory_peak_usage ( 1 TSRMLS_CC ) ) ) ; } } zend_end_try ( ) ; if ( ! parent_req ) { php_apache_request_dtor ( r TSRMLS_CC ) ; ctx -> request_processed = 1 ; <S2SV_StartBug> bucket = apr_bucket_eos_create ( r -> connection -> bucket_alloc ) ; <S2SV_EndBug> APR_BRIGADE_INSERT_TAIL ( brigade , bucket ) ; rv = ap_pass_brigade ( r -> output_filters , brigade ) ; if ( rv != APR_SUCCESS || r -> connection -> aborted ) { zend_first_try { php_handle_aborted_connection ( ) ; } zend_end_try ( ) ; } apr_brigade_cleanup ( brigade ) ; apr_pool_cleanup_run ( r -> pool , ( void * ) & SG ( server_context ) , php_server_context_cleanup ) ; } else { ctx -> r = parent_req ; } return OK ; }
","<S2SV_ModStart> = 1 ; apr_brigade_cleanup ( brigade ) ;
"
816,"CWE-835 static void feed_table_block_tag ( struct table * tbl , char * line , struct table_mode * mode , int indent , int cmd ) { int offset ; if ( mode -> indent_level <= 0 && indent == - 1 ) return ; if ( mode -> indent_level >= CHAR_MAX && indent == 1 ) return ; setwidth ( tbl , mode ) ; feed_table_inline_tag ( tbl , line , mode , - 1 ) ; clearcontentssize ( tbl , mode ) ; if ( indent == 1 ) { mode -> indent_level ++ ; if ( mode -> indent_level <= MAX_INDENT_LEVEL ) tbl -> indent += INDENT_INCR ; } else if ( indent == - 1 ) { mode -> indent_level -- ; if ( mode -> indent_level < MAX_INDENT_LEVEL ) tbl -> indent -= INDENT_INCR ; } <S2SV_StartBug> offset = tbl -> indent ; <S2SV_EndBug> if ( cmd == HTML_DT ) { if ( mode -> indent_level > 0 && mode -> indent_level <= MAX_INDENT_LEVEL ) offset -= INDENT_INCR ; <S2SV_StartBug> } <S2SV_EndBug> if ( tbl -> indent > 0 ) { check_minimum0 ( tbl , 0 ) ; addcontentssize ( tbl , offset ) ; } }
","<S2SV_ModStart> INDENT_INCR ; } if ( tbl -> indent < 0 ) tbl -> indent = 0 ; <S2SV_ModStart> -= INDENT_INCR ; if ( offset < 0 ) offset = 0 ;
"
817,"CWE-399 int kex_input_kexinit ( int type , u_int32_t seq , void * ctxt ) { struct ssh * ssh = ctxt ; struct kex * kex = ssh -> kex ; const u_char * ptr ; u_int i ; size_t dlen ; int r ; debug ( ""SSH2_MSG_KEXINIT<S2SV_blank>received"" ) ; if ( kex == NULL ) return SSH_ERR_INVALID_ARGUMENT ; <S2SV_StartBug> ptr = sshpkt_ptr ( ssh , & dlen ) ; <S2SV_EndBug> if ( ( r = sshbuf_put ( kex -> peer , ptr , dlen ) ) != 0 ) return r ; for ( i = 0 ; i < KEX_COOKIE_LEN ; i ++ ) if ( ( r = sshpkt_get_u8 ( ssh , NULL ) ) != 0 ) return r ; for ( i = 0 ; i < PROPOSAL_MAX ; i ++ ) if ( ( r = sshpkt_get_string ( ssh , NULL , NULL ) ) != 0 ) return r ; if ( ( r = sshpkt_get_u8 ( ssh , NULL ) ) != 0 || ( r = sshpkt_get_u32 ( ssh , NULL ) ) != 0 || ( r = sshpkt_get_end ( ssh ) ) != 0 ) return r ; if ( ! ( kex -> flags & KEX_INIT_SENT ) ) if ( ( r = kex_send_kexinit ( ssh ) ) != 0 ) return r ; if ( ( r = kex_choose_conf ( ssh ) ) != 0 ) return r ; if ( kex -> kex_type < KEX_MAX && kex -> kex [ kex -> kex_type ] != NULL ) return ( kex -> kex [ kex -> kex_type ] ) ( ssh ) ; return SSH_ERR_INTERNAL_ERROR ; }
","<S2SV_ModStart> return SSH_ERR_INVALID_ARGUMENT ; ssh_dispatch_set ( ssh , SSH2_MSG_KEXINIT , NULL ) ;
"
818,"CWE-255 static int find_source_vc ( char * * ret_path , unsigned * ret_idx ) { _cleanup_free_ char * path = NULL ; int r , err = 0 ; unsigned i ; path = new ( char , sizeof ( ""/dev/tty63"" ) ) ; if ( ! path ) return log_oom ( ) ; for ( i = 1 ; i <= 63 ; i ++ ) { _cleanup_close_ int fd = - 1 ; r = verify_vc_allocation ( i ) ; if ( r < 0 ) { if ( ! err ) err = - r ; continue ; } sprintf ( path , ""/dev/tty%u"" , i ) ; fd = open_terminal ( path , O_RDWR | O_CLOEXEC | O_NOCTTY ) ; if ( fd < 0 ) { if ( ! err ) err = - fd ; continue ; } <S2SV_StartBug> r = verify_vc_kbmode ( fd ) ; <S2SV_EndBug> if ( r < 0 ) { if ( ! err ) err = - r ; continue ; } * ret_idx = i ; * ret_path = TAKE_PTR ( path ) ; return TAKE_FD ( fd ) ; } return log_error_errno ( err , ""No<S2SV_blank>usable<S2SV_blank>source<S2SV_blank>console<S2SV_blank>found:<S2SV_blank>%m"" ) ; }
","<S2SV_ModStart> } r = vt_verify_kbmode <S2SV_ModEnd> ( fd )
"
819,"CWE-119 static int ssh_packet_set_postauth ( struct ssh * ssh ) { <S2SV_StartBug> struct sshcomp * comp ; <S2SV_EndBug> int r , mode ; debug ( ""%s:<S2SV_blank>called"" , __func__ ) ; ssh -> state -> after_authentication = 1 ; ssh -> state -> rekeying = 0 ; <S2SV_StartBug> for ( mode = 0 ; mode < MODE_MAX ; mode ++ ) { <S2SV_EndBug> if ( ssh -> state -> newkeys [ mode ] == NULL ) continue ; comp = & ssh -> state -> newkeys [ mode ] -> comp ; if ( comp && comp -> enabled && <S2SV_StartBug> ( r = ssh_packet_init_compression ( ssh ) ) != 0 ) <S2SV_EndBug> return r ; <S2SV_StartBug> } <S2SV_EndBug> return 0 ; }
","<S2SV_ModStart> ssh ) { int r <S2SV_ModEnd> ; debug ( <S2SV_ModStart> = 0 ; if ( <S2SV_ModEnd> ( r = <S2SV_ModStart> ( r = ssh_packet_enable_delayed_compress <S2SV_ModEnd> ( ssh ) <S2SV_ModStart> return r ; <S2SV_ModEnd> return 0 ;
"
820,"CWE-119 static int check_entry_size_and_hooks ( struct ipt_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct ipt_entry ) != 0 || ( unsigned char * ) e + sizeof ( struct ipt_entry ) >= limit || ( unsigned char * ) e + e -> next_offset > limit ) { duprintf ( ""Bad<S2SV_blank>offset<S2SV_blank>%p\\n"" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct ipt_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\n"" , e , e -> next_offset ) ; return - EINVAL ; } err = check_entry ( e ) ; if ( err ) return err ; for ( h = 0 ; h < NF_INET_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) { <S2SV_StartBug> pr_err ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>"" <S2SV_EndBug> ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"" ""ACCEPT/DROP\\n"" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows [ h ] ; } } e -> counters = ( ( struct xt_counters ) { 0 , 0 } ) ; e -> comefrom = 0 ; return 0 ; }
","<S2SV_ModStart> ) ) { pr_debug <S2SV_ModEnd> ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>"" ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>""
"
821,"CWE-189 STATIC struct posix_acl * xfs_acl_from_disk ( struct xfs_acl * aclp ) { struct posix_acl_entry * acl_e ; struct posix_acl * acl ; struct xfs_acl_entry * ace ; <S2SV_StartBug> int count , i ; <S2SV_EndBug> count = be32_to_cpu ( aclp -> acl_cnt ) ; if ( count > XFS_ACL_MAX_ENTRIES ) return ERR_PTR ( - EFSCORRUPTED ) ; acl = posix_acl_alloc ( count , GFP_KERNEL ) ; if ( ! acl ) return ERR_PTR ( - ENOMEM ) ; for ( i = 0 ; i < count ; i ++ ) { acl_e = & acl -> a_entries [ i ] ; ace = & aclp -> acl_entry [ i ] ; acl_e -> e_tag = be32_to_cpu ( ace -> ae_tag ) ; acl_e -> e_perm = be16_to_cpu ( ace -> ae_perm ) ; switch ( acl_e -> e_tag ) { case ACL_USER : case ACL_GROUP : acl_e -> e_id = be32_to_cpu ( ace -> ae_id ) ; break ; case ACL_USER_OBJ : case ACL_GROUP_OBJ : case ACL_MASK : case ACL_OTHER : acl_e -> e_id = ACL_UNDEFINED_ID ; break ; default : goto fail ; } } return acl ; fail : posix_acl_release ( acl ) ; return ERR_PTR ( - EINVAL ) ; }
","<S2SV_ModStart> * ace ; unsigned
"
822,"CWE-399 static void xen_netbk_fill_frags ( struct xen_netbk * netbk , struct sk_buff * skb ) { struct skb_shared_info * shinfo = skb_shinfo ( skb ) ; int nr_frags = shinfo -> nr_frags ; int i ; for ( i = 0 ; i < nr_frags ; i ++ ) { skb_frag_t * frag = shinfo -> frags + i ; struct xen_netif_tx_request * txp ; struct page * page ; u16 pending_idx ; pending_idx = frag_get_pending_idx ( frag ) ; txp = & netbk -> pending_tx_info [ pending_idx ] . req ; page = virt_to_page ( idx_to_kaddr ( netbk , pending_idx ) ) ; __skb_fill_page_desc ( skb , i , page , txp -> offset , txp -> size ) ; skb -> len += txp -> size ; skb -> data_len += txp -> size ; skb -> truesize += txp -> size ; get_page ( netbk -> mmap_pages [ pending_idx ] ) ; <S2SV_StartBug> xen_netbk_idx_release ( netbk , pending_idx ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> netbk , pending_idx , XEN_NETIF_RSP_OKAY
"
823,"CWE-401 int htc_connect_service ( struct htc_target * target , struct htc_service_connreq * service_connreq , enum htc_endpoint_id * conn_rsp_epid ) { struct sk_buff * skb ; struct htc_endpoint * endpoint ; struct htc_conn_svc_msg * conn_msg ; int ret ; unsigned long time_left ; endpoint = get_next_avail_ep ( target -> endpoint ) ; if ( ! endpoint ) { dev_err ( target -> dev , ""Endpoint<S2SV_blank>is<S2SV_blank>not<S2SV_blank>available<S2SV_blank>for<S2SV_blank>service<S2SV_blank>%d\\n"" , service_connreq -> service_id ) ; return - EINVAL ; } endpoint -> service_id = service_connreq -> service_id ; endpoint -> max_txqdepth = service_connreq -> max_send_qdepth ; endpoint -> ul_pipeid = service_to_ulpipe ( service_connreq -> service_id ) ; endpoint -> dl_pipeid = service_to_dlpipe ( service_connreq -> service_id ) ; endpoint -> ep_callbacks = service_connreq -> ep_callbacks ; skb = alloc_skb ( sizeof ( struct htc_conn_svc_msg ) + sizeof ( struct htc_frame_hdr ) , GFP_ATOMIC ) ; if ( ! skb ) { dev_err ( target -> dev , ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>buf<S2SV_blank>to<S2SV_blank>send"" ""service<S2SV_blank>connect<S2SV_blank>req\\n"" ) ; return - ENOMEM ; } skb_reserve ( skb , sizeof ( struct htc_frame_hdr ) ) ; conn_msg = skb_put ( skb , sizeof ( struct htc_conn_svc_msg ) ) ; conn_msg -> service_id = cpu_to_be16 ( service_connreq -> service_id ) ; conn_msg -> msg_id = cpu_to_be16 ( HTC_MSG_CONNECT_SERVICE_ID ) ; conn_msg -> con_flags = cpu_to_be16 ( service_connreq -> con_flags ) ; conn_msg -> dl_pipeid = endpoint -> dl_pipeid ; conn_msg -> ul_pipeid = endpoint -> ul_pipeid ; ret = htc_issue_send ( target , skb , skb -> len , 0 , ENDPOINT0 ) ; if ( ret ) goto err ; time_left = wait_for_completion_timeout ( & target -> cmd_wait , HZ ) ; if ( ! time_left ) { dev_err ( target -> dev , ""Service<S2SV_blank>connection<S2SV_blank>timeout<S2SV_blank>for:<S2SV_blank>%d\\n"" , service_connreq -> service_id ) ; <S2SV_StartBug> return - ETIMEDOUT ; <S2SV_EndBug> } * conn_rsp_epid = target -> conn_rsp_epid ; return 0 ; err : kfree_skb ( skb ) ; return ret ; }
","<S2SV_ModStart> service_id ) ; kfree_skb ( skb ) ;
"
824,"CWE-190 STATIC struct posix_acl * xfs_acl_from_disk ( struct xfs_acl * aclp ) { struct posix_acl_entry * acl_e ; struct posix_acl * acl ; struct xfs_acl_entry * ace ; int count , i ; <S2SV_StartBug> count = be32_to_cpu ( aclp -> acl_cnt ) ; <S2SV_EndBug> acl = posix_acl_alloc ( count , GFP_KERNEL ) ; if ( ! acl ) return ERR_PTR ( - ENOMEM ) ; for ( i = 0 ; i < count ; i ++ ) { acl_e = & acl -> a_entries [ i ] ; ace = & aclp -> acl_entry [ i ] ; acl_e -> e_tag = be32_to_cpu ( ace -> ae_tag ) ; acl_e -> e_perm = be16_to_cpu ( ace -> ae_perm ) ; switch ( acl_e -> e_tag ) { case ACL_USER : case ACL_GROUP : acl_e -> e_id = be32_to_cpu ( ace -> ae_id ) ; break ; case ACL_USER_OBJ : case ACL_GROUP_OBJ : case ACL_MASK : case ACL_OTHER : acl_e -> e_id = ACL_UNDEFINED_ID ; break ; default : goto fail ; } } return acl ; fail : posix_acl_release ( acl ) ; return ERR_PTR ( - EINVAL ) ; }
","<S2SV_ModStart> aclp -> acl_cnt ) ; if ( count > XFS_ACL_MAX_ENTRIES ) return ERR_PTR ( - EFSCORRUPTED
"
825,"CWE-617 static int pci_emul_alloc_resource ( uint64_t * baseptr , uint64_t limit , uint64_t size , uint64_t * addr ) { uint64_t base ; <S2SV_StartBug> assert ( ( size & ( size - 1 ) ) == 0 ) ; <S2SV_EndBug> base = roundup2 ( * baseptr , size ) ; if ( base + size <= limit ) { * addr = base ; * baseptr = base + size ; return 0 ; } else return - 1 ; }
","<S2SV_ModStart> uint64_t base ; if <S2SV_ModEnd> ( ( size <S2SV_ModStart> 1 ) ) != 0 ) { pr_err ( ""%s:<S2SV_blank>Cannot<S2SV_blank>alloc<S2SV_blank>invalid<S2SV_blank>size<S2SV_blank>%lld<S2SV_blank>resource\\n"" , __func__ , size ) ; return - 1 ; } <S2SV_ModEnd> base = roundup2
"
826,"CWE-400 static void record_and_restart ( struct perf_event * event , unsigned long val , <S2SV_StartBug> struct pt_regs * regs , int nmi ) <S2SV_EndBug> { u64 period = event -> hw . sample_period ; s64 prev , delta , left ; int record = 0 ; if ( event -> hw . state & PERF_HES_STOPPED ) { write_pmc ( event -> hw . idx , 0 ) ; return ; } prev = local64_read ( & event -> hw . prev_count ) ; delta = ( val - prev ) & 0xfffffffful ; local64_add ( delta , & event -> count ) ; val = 0 ; left = local64_read ( & event -> hw . period_left ) - delta ; if ( period ) { if ( left <= 0 ) { left += period ; if ( left <= 0 ) left = period ; record = 1 ; event -> hw . last_period = event -> hw . sample_period ; } if ( left < 0x80000000LL ) val = 0x80000000LL - left ; } write_pmc ( event -> hw . idx , val ) ; local64_set ( & event -> hw . prev_count , val ) ; local64_set ( & event -> hw . period_left , left ) ; perf_event_update_userpage ( event ) ; if ( record ) { struct perf_sample_data data ; perf_sample_data_init ( & data , 0 ) ; data . period = event -> hw . last_period ; <S2SV_StartBug> if ( perf_event_overflow ( event , nmi , & data , regs ) ) <S2SV_EndBug> fsl_emb_pmu_stop ( event , 0 ) ; } }
","<S2SV_ModStart> pt_regs * regs <S2SV_ModEnd> ) { u64 <S2SV_ModStart> ( event , <S2SV_ModEnd> & data ,
"
827,"CWE-264 <S2SV_StartBug> static bool do_write_pids ( pid_t tpid , const char * contrl , const char * cg , const char * file , const char * buf ) <S2SV_EndBug> { int sock [ 2 ] = { - 1 , - 1 } ; pid_t qpid , cpid = - 1 ; FILE * pids_file = NULL ; bool answer = false , fail = false ; pids_file = open_pids_file ( contrl , cg ) ; if ( ! pids_file ) return false ; if ( socketpair ( AF_UNIX , SOCK_DGRAM , 0 , sock ) < 0 ) { perror ( ""socketpair"" ) ; goto out ; } cpid = fork ( ) ; if ( cpid == - 1 ) goto out ; if ( ! cpid ) { fclose ( pids_file ) ; pid_from_ns_wrapper ( sock [ 1 ] , tpid ) ; } const char * ptr = buf ; while ( sscanf ( ptr , ""%d"" , & qpid ) == 1 ) { struct ucred cred ; char v ; if ( write ( sock [ 0 ] , & qpid , sizeof ( qpid ) ) != sizeof ( qpid ) ) { fprintf ( stderr , ""%s:<S2SV_blank>error<S2SV_blank>writing<S2SV_blank>pid<S2SV_blank>to<S2SV_blank>child:<S2SV_blank>%s\\n"" , __func__ , strerror ( errno ) ) ; goto out ; } if ( recv_creds ( sock [ 0 ] , & cred , & v ) ) { if ( v == '0' ) { <S2SV_StartBug> if ( fprintf ( pids_file , ""%d"" , ( int ) cred . pid ) < 0 ) <S2SV_EndBug> fail = true ; } } ptr = strchr ( ptr , '\\n' ) ; if ( ! ptr ) break ; ptr ++ ; } qpid = - 1 ; if ( write ( sock [ 0 ] , & qpid , sizeof ( qpid ) ) != sizeof ( qpid ) ) fprintf ( stderr , ""Warning:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ask<S2SV_blank>child<S2SV_blank>to<S2SV_blank>exit\\n"" ) ; if ( ! fail ) answer = true ; out : if ( cpid != - 1 ) wait_for_pid ( cpid ) ; if ( sock [ 0 ] != - 1 ) { close ( sock [ 0 ] ) ; close ( sock [ 1 ] ) ; } if ( pids_file ) { if ( fclose ( pids_file ) != 0 ) answer = false ; } return answer ; }
","<S2SV_ModStart> pid_t tpid , uid_t tuid , <S2SV_ModStart> { if ( ! may_move_pid ( tpid , tuid , <S2SV_ModEnd> cred . pid <S2SV_ModStart> . pid ) ) { fail = true ; break ; } if ( fprintf ( pids_file , ""%d"" , ( int ) cred . pid )
"
828,"CWE-000 void tcp_sack_option ( struct tcpcb * tp , struct tcphdr * th , u_char * cp , int optlen ) { int tmp_olen ; u_char * tmp_cp ; struct sackhole * cur , * p , * temp ; if ( ! tp -> sack_enable ) return ; if ( ( th -> th_flags & TH_ACK ) == 0 ) return ; if ( SEQ_LT ( th -> th_ack , tp -> snd_una ) || SEQ_GT ( th -> th_ack , tp -> snd_max ) ) return ; if ( optlen <= 2 || ( optlen - 2 ) % TCPOLEN_SACK != 0 ) return ; tmp_cp = cp + 2 ; tmp_olen = optlen - 2 ; tcpstat_inc ( tcps_sack_rcv_opts ) ; if ( tp -> snd_numholes < 0 ) tp -> snd_numholes = 0 ; if ( tp -> t_maxseg == 0 ) panic ( ""tcp_sack_option"" ) ; while ( tmp_olen > 0 ) { struct sackblk sack ; memcpy ( & sack . start , tmp_cp , sizeof ( tcp_seq ) ) ; sack . start = ntohl ( sack . start ) ; memcpy ( & sack . end , tmp_cp + sizeof ( tcp_seq ) , sizeof ( tcp_seq ) ) ; sack . end = ntohl ( sack . end ) ; tmp_olen -= TCPOLEN_SACK ; tmp_cp += TCPOLEN_SACK ; if ( SEQ_LEQ ( sack . end , sack . start ) ) continue ; if ( SEQ_LEQ ( sack . end , tp -> snd_una ) ) continue ; if ( SEQ_GT ( th -> th_ack , tp -> snd_una ) ) { if ( SEQ_LT ( sack . start , th -> th_ack ) ) continue ; } if ( SEQ_GT ( sack . end , tp -> snd_max ) ) continue ; if ( tp -> snd_holes == NULL ) { tp -> snd_holes = ( struct sackhole * ) pool_get ( & sackhl_pool , PR_NOWAIT ) ; if ( tp -> snd_holes == NULL ) { goto done ; } cur = tp -> snd_holes ; cur -> start = th -> th_ack ; cur -> end = sack . start ; cur -> rxmit = cur -> start ; cur -> next = NULL ; tp -> snd_numholes = 1 ; tp -> rcv_lastsack = sack . end ; cur -> dups = min ( tcprexmtthresh , ( ( sack . end - cur -> end ) / tp -> t_maxseg ) ) ; if ( cur -> dups < 1 ) cur -> dups = 1 ; continue ; } p = cur = tp -> snd_holes ; while ( cur ) { if ( SEQ_LEQ ( sack . end , cur -> start ) ) break ; if ( SEQ_GEQ ( sack . start , cur -> end ) ) { cur -> dups ++ ; if ( ( ( sack . end - cur -> end ) / tp -> t_maxseg ) >= tcprexmtthresh ) cur -> dups = tcprexmtthresh ; p = cur ; cur = cur -> next ; continue ; } if ( SEQ_LEQ ( sack . start , cur -> start ) ) { if ( SEQ_GEQ ( sack . end , cur -> end ) ) { if ( p != cur ) { p -> next = cur -> next ; pool_put ( & sackhl_pool , cur ) ; cur = p -> next ; } else { cur = cur -> next ; pool_put ( & sackhl_pool , p ) ; p = cur ; tp -> snd_holes = p ; } tp -> snd_numholes -- ; continue ; } cur -> start = sack . end ; cur -> rxmit = SEQ_MAX ( cur -> rxmit , cur -> start ) ; p = cur ; cur = cur -> next ; continue ; } if ( SEQ_GEQ ( sack . end , cur -> end ) ) { cur -> end = sack . start ; cur -> rxmit = SEQ_MIN ( cur -> rxmit , cur -> end ) ; cur -> dups ++ ; if ( ( ( sack . end - cur -> end ) / tp -> t_maxseg ) >= tcprexmtthresh ) cur -> dups = tcprexmtthresh ; p = cur ; cur = cur -> next ; continue ; } if ( SEQ_LT ( cur -> start , sack . start ) && SEQ_GT ( cur -> end , sack . end ) ) { <S2SV_StartBug> temp = ( struct sackhole * ) <S2SV_EndBug> pool_get ( & sackhl_pool , PR_NOWAIT ) ; if ( temp == NULL ) goto done ; temp -> next = cur -> next ; temp -> start = sack . end ; temp -> end = cur -> end ; temp -> dups = cur -> dups ; temp -> rxmit = SEQ_MAX ( cur -> rxmit , temp -> start ) ; cur -> end = sack . start ; cur -> rxmit = SEQ_MIN ( cur -> rxmit , cur -> end ) ; cur -> dups ++ ; if ( ( ( sack . end - cur -> end ) / tp -> t_maxseg ) >= tcprexmtthresh ) cur -> dups = tcprexmtthresh ; cur -> next = temp ; p = temp ; cur = p -> next ; tp -> snd_numholes ++ ; } } if ( SEQ_LT ( tp -> rcv_lastsack , sack . start ) ) { <S2SV_StartBug> temp = ( struct sackhole * ) <S2SV_EndBug> pool_get ( & sackhl_pool , PR_NOWAIT ) ; if ( temp == NULL ) goto done ; temp -> start = tp -> rcv_lastsack ; temp -> end = sack . start ; temp -> dups = min ( tcprexmtthresh , ( ( sack . end - sack . start ) / tp -> t_maxseg ) ) ; if ( temp -> dups < 1 ) temp -> dups = 1 ; temp -> rxmit = temp -> start ; temp -> next = 0 ; p -> next = temp ; tp -> rcv_lastsack = sack . end ; tp -> snd_numholes ++ ; } } done : return ; }
","<S2SV_ModStart> ) ) { if ( tp -> snd_numholes >= TCP_SACKHOLE_LIMIT ) goto done ; <S2SV_ModStart> ) ) { if ( tp -> snd_numholes >= TCP_SACKHOLE_LIMIT ) goto done ;
"
829,"CWE-476 static int jp2_bpcc_getdata ( jp2_box_t * box , jas_stream_t * in ) { jp2_bpcc_t * bpcc = & box -> data . bpcc ; <S2SV_StartBug> unsigned int i ; <S2SV_EndBug> bpcc -> numcmpts = box -> datalen ; if ( ! ( bpcc -> bpcs = jas_alloc2 ( bpcc -> numcmpts , sizeof ( uint_fast8_t ) ) ) ) { return - 1 ; } for ( i = 0 ; i < bpcc -> numcmpts ; ++ i ) { if ( jp2_getuint8 ( in , & bpcc -> bpcs [ i ] ) ) { return - 1 ; } } return 0 ; }
","<S2SV_ModStart> unsigned int i ; bpcc -> bpcs = 0
"
830,"CWE-476 RCMS * r_pkcs7_parse_cms ( const ut8 * buffer , ut32 length ) { RASN1Object * object ; RCMS * container ; if ( ! buffer || ! length ) { return NULL ; } container = R_NEW0 ( RCMS ) ; if ( ! container ) { return NULL ; } object = r_asn1_create_object ( buffer , length ) ; <S2SV_StartBug> if ( ! object || object -> list . length != 2 || ! object -> list . objects [ 0 ] || object -> list . objects [ 1 ] -> list . length != 1 ) { <S2SV_EndBug> r_asn1_free_object ( object ) ; free ( container ) ; return NULL ; } container -> contentType = r_asn1_stringify_oid ( object -> list . objects [ 0 ] -> sector , object -> list . objects [ 0 ] -> length ) ; r_pkcs7_parse_signeddata ( & container -> signedData , object -> list . objects [ 1 ] -> list . objects [ 0 ] ) ; r_asn1_free_object ( object ) ; return container ; }
","<S2SV_ModStart> list . objects || ! object -> list . objects [ 0 ] || ! object -> list . objects [ 1 ] || <S2SV_ModEnd> object -> list
"
831,"CWE-285 int orangefs_set_acl ( struct inode * inode , struct posix_acl * acl , int type ) { struct orangefs_inode_s * orangefs_inode = ORANGEFS_I ( inode ) ; int error = 0 ; void * value = NULL ; size_t size = 0 ; const char * name = NULL ; switch ( type ) { case ACL_TYPE_ACCESS : name = XATTR_NAME_POSIX_ACL_ACCESS ; if ( acl ) { <S2SV_StartBug> umode_t mode = inode -> i_mode ; <S2SV_EndBug> <S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & mode ) ; <S2SV_EndBug> if ( error < 0 ) { <S2SV_StartBug> gossip_err ( ""%s:<S2SV_blank>posix_acl_equiv_mode<S2SV_blank>err:<S2SV_blank>%d\\n"" , <S2SV_EndBug> __func__ , error ) ; return error ; } if ( inode -> i_mode != mode ) SetModeFlag ( orangefs_inode ) ; inode -> i_mode = mode ; mark_inode_dirty_sync ( inode ) ; <S2SV_StartBug> if ( error == 0 ) <S2SV_EndBug> acl = NULL ; } break ; case ACL_TYPE_DEFAULT : name = XATTR_NAME_POSIX_ACL_DEFAULT ; break ; default : gossip_err ( ""%s:<S2SV_blank>invalid<S2SV_blank>type<S2SV_blank>%d!\\n"" , __func__ , type ) ; return - EINVAL ; } gossip_debug ( GOSSIP_ACL_DEBUG , ""%s:<S2SV_blank>inode<S2SV_blank>%pU,<S2SV_blank>key<S2SV_blank>%s<S2SV_blank>type<S2SV_blank>%d\\n"" , __func__ , get_khandle_from_ino ( inode ) , name , type ) ; if ( acl ) { size = posix_acl_xattr_size ( acl -> a_count ) ; value = kmalloc ( size , GFP_KERNEL ) ; if ( ! value ) return - ENOMEM ; error = posix_acl_to_xattr ( & init_user_ns , acl , value , size ) ; if ( error < 0 ) goto out ; } gossip_debug ( GOSSIP_ACL_DEBUG , ""%s:<S2SV_blank>name<S2SV_blank>%s,<S2SV_blank>value<S2SV_blank>%p,<S2SV_blank>size<S2SV_blank>%zd,<S2SV_blank>acl<S2SV_blank>%p\\n"" , __func__ , name , value , size , acl ) ; error = orangefs_inode_setxattr ( inode , name , value , size , 0 ) ; out : kfree ( value ) ; if ( ! error ) set_cached_acl ( inode , type , acl ) ; return error ; }
","<S2SV_ModStart> { umode_t mode ; error = posix_acl_update_mode ( inode <S2SV_ModEnd> , & mode <S2SV_ModStart> , & mode , & acl ) ; if ( error <S2SV_ModEnd> ) { gossip_err <S2SV_ModStart> { gossip_err ( ""%s:<S2SV_blank>posix_acl_update_mode<S2SV_blank>err:<S2SV_blank>%d\\n"" <S2SV_ModEnd> , __func__ , <S2SV_ModStart> inode ) ; <S2SV_ModEnd> } break ;
"
832,"CWE-362 static struct sock * dccp_v6_request_recv_sock ( struct sock * sk , struct sk_buff * skb , struct request_sock * req , struct dst_entry * dst ) { struct inet6_request_sock * ireq6 = inet6_rsk ( req ) ; struct ipv6_pinfo * newnp , * np = inet6_sk ( sk ) ; struct inet_sock * newinet ; struct dccp6_sock * newdp6 ; struct sock * newsk ; struct ipv6_txoptions * opt ; if ( skb -> protocol == htons ( ETH_P_IP ) ) { newsk = dccp_v4_request_recv_sock ( sk , skb , req , dst ) ; if ( newsk == NULL ) return NULL ; newdp6 = ( struct dccp6_sock * ) newsk ; newinet = inet_sk ( newsk ) ; newinet -> pinet6 = & newdp6 -> inet6 ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; ipv6_addr_set_v4mapped ( newinet -> inet_daddr , & newnp -> daddr ) ; ipv6_addr_set_v4mapped ( newinet -> inet_saddr , & newnp -> saddr ) ; ipv6_addr_copy ( & newnp -> rcv_saddr , & newnp -> saddr ) ; inet_csk ( newsk ) -> icsk_af_ops = & dccp_ipv6_mapped ; newsk -> sk_backlog_rcv = dccp_v4_do_rcv ; newnp -> pktoptions = NULL ; newnp -> opt = NULL ; newnp -> mcast_oif = inet6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; dccp_sync_mss ( newsk , inet_csk ( newsk ) -> icsk_pmtu_cookie ) ; return newsk ; } opt = np -> opt ; if ( sk_acceptq_is_full ( sk ) ) goto out_overflow ; if ( dst == NULL ) { struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = IPPROTO_DCCP ; ipv6_addr_copy ( & fl6 . daddr , & ireq6 -> rmt_addr ) ; final_p = fl6_update_dst ( & fl6 , opt , & final ) ; ipv6_addr_copy ( & fl6 . saddr , & ireq6 -> loc_addr ) ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . fl6_dport = inet_rsk ( req ) -> rmt_port ; fl6 . fl6_sport = inet_rsk ( req ) -> loc_port ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p , false ) ; if ( IS_ERR ( dst ) ) goto out ; } newsk = dccp_create_openreq_child ( sk , req , skb ) ; if ( newsk == NULL ) goto out_nonewsk ; __ip6_dst_store ( newsk , dst , NULL , NULL ) ; newsk -> sk_route_caps = dst -> dev -> features & ~ ( NETIF_F_IP_CSUM | NETIF_F_TSO ) ; newdp6 = ( struct dccp6_sock * ) newsk ; newinet = inet_sk ( newsk ) ; newinet -> pinet6 = & newdp6 -> inet6 ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; ipv6_addr_copy ( & newnp -> daddr , & ireq6 -> rmt_addr ) ; ipv6_addr_copy ( & newnp -> saddr , & ireq6 -> loc_addr ) ; ipv6_addr_copy ( & newnp -> rcv_saddr , & ireq6 -> loc_addr ) ; newsk -> sk_bound_dev_if = ireq6 -> iif ; <S2SV_StartBug> newinet -> opt = NULL ; <S2SV_EndBug> newnp -> rxopt . all = np -> rxopt . all ; newnp -> pktoptions = NULL ; if ( ireq6 -> pktopts != NULL ) { newnp -> pktoptions = skb_clone ( ireq6 -> pktopts , GFP_ATOMIC ) ; kfree_skb ( ireq6 -> pktopts ) ; ireq6 -> pktopts = NULL ; if ( newnp -> pktoptions ) skb_set_owner_r ( newnp -> pktoptions , newsk ) ; } newnp -> opt = NULL ; newnp -> mcast_oif = inet6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; if ( opt != NULL ) { newnp -> opt = ipv6_dup_options ( newsk , opt ) ; if ( opt != np -> opt ) sock_kfree_s ( sk , opt , opt -> tot_len ) ; } inet_csk ( newsk ) -> icsk_ext_hdr_len = 0 ; if ( newnp -> opt != NULL ) inet_csk ( newsk ) -> icsk_ext_hdr_len = ( newnp -> opt -> opt_nflen + newnp -> opt -> opt_flen ) ; dccp_sync_mss ( newsk , dst_mtu ( dst ) ) ; newinet -> inet_daddr = newinet -> inet_saddr = LOOPBACK4_IPV6 ; newinet -> inet_rcv_saddr = LOOPBACK4_IPV6 ; if ( __inet_inherit_port ( sk , newsk ) < 0 ) { sock_put ( newsk ) ; goto out ; } __inet6_hash ( newsk , NULL ) ; return newsk ; out_overflow : NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_LISTENOVERFLOWS ) ; out_nonewsk : dst_release ( dst ) ; out : NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_LISTENDROPS ) ; if ( opt != NULL && opt != np -> opt ) sock_kfree_s ( sk , opt , opt -> tot_len ) ; return NULL ; }
","<S2SV_ModStart> ; newinet -> inet_opt <S2SV_ModEnd> = NULL ;
"
833,"CWE-189 static int __dwc3_gadget_kick_transfer ( struct dwc3_ep * dep ) { struct dwc3_gadget_ep_cmd_params params ; struct dwc3_request * req ; int starting ; int ret ; u32 cmd ; if ( ! dwc3_calc_trbs_left ( dep ) ) return 0 ; starting = ! ( dep -> flags & DWC3_EP_BUSY ) ; dwc3_prepare_trbs ( dep ) ; req = next_request ( & dep -> started_list ) ; if ( ! req ) { dep -> flags |= DWC3_EP_PENDING_REQUEST ; return 0 ; } memset ( & params , 0 , sizeof ( params ) ) ; if ( starting ) { params . param0 = upper_32_bits ( req -> trb_dma ) ; params . param1 = lower_32_bits ( req -> trb_dma ) ; cmd = DWC3_DEPCMD_STARTTRANSFER ; if ( usb_endpoint_xfer_isoc ( dep -> endpoint . desc ) ) cmd |= DWC3_DEPCMD_PARAM ( dep -> frame_number ) ; } else { cmd = DWC3_DEPCMD_UPDATETRANSFER | DWC3_DEPCMD_PARAM ( dep -> resource_index ) ; } ret = dwc3_send_gadget_ep_cmd ( dep , cmd , & params ) ; if ( ret < 0 ) { if ( req -> trb ) memset ( req -> trb , 0 , sizeof ( struct dwc3_trb ) ) ; dep -> queued_requests -- ; <S2SV_StartBug> dwc3_gadget_giveback ( dep , req , ret ) ; <S2SV_EndBug> return ret ; } dep -> flags |= DWC3_EP_BUSY ; if ( starting ) { dep -> resource_index = dwc3_gadget_ep_get_transfer_index ( dep ) ; WARN_ON_ONCE ( ! dep -> resource_index ) ; } return 0 ; }
","<S2SV_ModStart> queued_requests -- ; dwc3_gadget_del_and_unmap_request <S2SV_ModEnd> ( dep ,
"
834,"CWE-252 static Image * ReadDCMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { <S2SV_StartBug> # define ThrowDCMException ( exception , message ) { if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; if ( stream_info != ( DCMStreamInfo * ) NULL ) stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> char explicit_vr [ MagickPathExtent ] , implicit_vr [ MagickPathExtent ] , magick [ MagickPathExtent ] , photometric [ MagickPathExtent ] ; DCMInfo info ; DCMStreamInfo * stream_info ; Image * image ; int * bluemap , datum , * greenmap , * graymap , * redmap ; MagickBooleanType explicit_file , explicit_retry , use_explicit ; MagickOffsetType offset ; register unsigned char * p ; register ssize_t i ; size_t colors , height , length , number_scenes , quantum , status , width ; ssize_t count , scene ; unsigned char * data ; unsigned short group , element ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> depth = 8UL ; image -> endian = LSBEndian ; ( void ) memset ( & info , 0 , sizeof ( info ) ) ; data = ( unsigned char * ) NULL ; graymap = ( int * ) NULL ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; stream_info = ( DCMStreamInfo * ) AcquireMagickMemory ( sizeof ( * stream_info ) ) ; if ( stream_info == ( DCMStreamInfo * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( stream_info , 0 , sizeof ( * stream_info ) ) ; count = ReadBlob ( image , 128 , ( unsigned char * ) magick ) ; if ( count != 128 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; count = ReadBlob ( image , 4 , ( unsigned char * ) magick ) ; if ( ( count != 4 ) || ( LocaleNCompare ( magick , ""DICM"" , 4 ) != 0 ) ) { offset = SeekBlob ( image , 0L , SEEK_SET ) ; if ( offset < 0 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } ( void ) CopyMagickString ( photometric , ""MONOCHROME1<S2SV_blank>"" , MagickPathExtent ) ; info . bits_allocated = 8 ; info . bytes_per_pixel = 1 ; info . depth = 8 ; info . mask = 0xffff ; info . max_value = 255UL ; info . samples_per_pixel = 1 ; info . signed_data = ( ~ 0UL ) ; info . rescale_slope = 1.0 ; data = ( unsigned char * ) NULL ; element = 0 ; explicit_vr [ 2 ] = '\\0' ; explicit_file = MagickFalse ; colors = 0 ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; graymap = ( int * ) NULL ; height = 0 ; number_scenes = 1 ; use_explicit = MagickFalse ; explicit_retry = MagickFalse ; width = 0 ; while ( TellBlob ( image ) < ( MagickOffsetType ) GetBlobSize ( image ) ) { for ( group = 0 ; ( group != 0x7FE0 ) || ( element != 0x0010 ) ; ) { image -> offset = ( ssize_t ) TellBlob ( image ) ; group = ReadBlobLSBShort ( image ) ; element = ReadBlobLSBShort ( image ) ; if ( ( group == 0xfffc ) && ( element == 0xfffc ) ) break ; if ( ( group != 0x0002 ) && ( image -> endian == MSBEndian ) ) { group = ( unsigned short ) ( ( group << 8 ) | ( ( group >> 8 ) & 0xFF ) ) ; element = ( unsigned short ) ( ( element << 8 ) | ( ( element >> 8 ) & 0xFF ) ) ; } quantum = 0 ; for ( i = 0 ; dicom_info [ i ] . group < 0xffff ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) CopyMagickString ( implicit_vr , dicom_info [ i ] . vr , MagickPathExtent ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) explicit_vr ) ; if ( count != 2 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( explicit_file == MagickFalse ) && ( group != 0x0002 ) ) explicit_file = ( isupper ( ( unsigned char ) * explicit_vr ) != MagickFalse ) && ( isupper ( ( unsigned char ) * ( explicit_vr + 1 ) ) != MagickFalse ) ? MagickTrue : MagickFalse ; use_explicit = ( ( group == 0x0002 ) && ( explicit_retry == MagickFalse ) ) || ( explicit_file != MagickFalse ) ? MagickTrue : MagickFalse ; if ( ( use_explicit != MagickFalse ) && ( strncmp ( implicit_vr , ""xs"" , 2 ) == 0 ) ) ( void ) CopyMagickString ( implicit_vr , explicit_vr , MagickPathExtent ) ; if ( ( use_explicit == MagickFalse ) || ( strncmp ( implicit_vr , ""!!"" , 2 ) == 0 ) ) { offset = SeekBlob ( image , ( MagickOffsetType ) - 2 , SEEK_CUR ) ; if ( offset < 0 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; quantum = 4 ; } else { quantum = 2 ; if ( ( strncmp ( explicit_vr , ""OB"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""UN"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""OW"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""SQ"" , 2 ) == 0 ) ) { ( void ) ReadBlobLSBShort ( image ) ; quantum = 4 ; } } datum = 0 ; if ( quantum == 4 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( quantum == 2 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } quantum = 0 ; length = 1 ; if ( datum != 0 ) { if ( ( strncmp ( implicit_vr , ""OW"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""SS"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""US"" , 2 ) == 0 ) ) quantum = 2 ; else if ( ( strncmp ( implicit_vr , ""FL"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""OF"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""SL"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""UL"" , 2 ) == 0 ) ) quantum = 4 ; else if ( strncmp ( implicit_vr , ""FD"" , 2 ) == 0 ) quantum = 8 ; else quantum = 1 ; if ( datum != ~ 0 ) length = ( size_t ) datum / quantum ; else { quantum = 0 ; length = 0 ; } } if ( image_info -> verbose != MagickFalse ) { if ( use_explicit == MagickFalse ) explicit_vr [ 0 ] = '\\0' ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) FormatLocaleFile ( stdout , ""0x%04lX<S2SV_blank>%4ld<S2SV_blank>%s-%s<S2SV_blank>(0x%04lx,0x%04lx)"" , ( unsigned long ) image -> offset , ( long ) length , implicit_vr , explicit_vr , ( unsigned long ) group , ( unsigned long ) element ) ; if ( dicom_info [ i ] . description != ( char * ) NULL ) ( void ) FormatLocaleFile ( stdout , ""<S2SV_blank>%s"" , dicom_info [ i ] . description ) ; ( void ) FormatLocaleFile ( stdout , "":<S2SV_blank>"" ) ; } if ( ( group == 0x7FE0 ) && ( element == 0x0010 ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""\\n"" ) ; break ; } data = ( unsigned char * ) NULL ; if ( ( length == 1 ) && ( quantum == 1 ) ) datum = ReadBlobByte ( image ) ; else if ( ( length == 1 ) && ( quantum == 2 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } else if ( ( length == 1 ) && ( quantum == 4 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( ( quantum != 0 ) && ( length != 0 ) ) { if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( ~ length >= 1 ) data = ( unsigned char * ) AcquireQuantumMemory ( length + 1 , quantum * sizeof ( * data ) ) ; if ( data == ( unsigned char * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , ( size_t ) quantum * length , data ) ; if ( count != ( ssize_t ) ( quantum * length ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""count=%d<S2SV_blank>quantum=%d<S2SV_blank>"" ""length=%d<S2SV_blank>group=%d\\n"" , ( int ) count , ( int ) quantum , ( int ) length , ( int ) group ) ; ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } data [ length * quantum ] = '\\0' ; } if ( ( ( ( unsigned int ) group << 16 ) | element ) == 0xFFFEE0DD ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; continue ; } switch ( group ) { case 0x0002 : { switch ( element ) { case 0x0010 : { char transfer_syntax [ MagickPathExtent ] ; if ( ( datum == 0 ) && ( explicit_retry == MagickFalse ) ) { explicit_retry = MagickTrue ; ( void ) SeekBlob ( image , ( MagickOffsetType ) 0 , SEEK_SET ) ; group = 0 ; element = 0 ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""Corrupted<S2SV_blank>image<S2SV_blank>-<S2SV_blank>trying<S2SV_blank>explicit<S2SV_blank>format\\n"" ) ; break ; } * transfer_syntax = '\\0' ; if ( data != ( unsigned char * ) NULL ) ( void ) CopyMagickString ( transfer_syntax , ( char * ) data , MagickPathExtent ) ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""transfer_syntax=%s\\n"" , ( const char * ) transfer_syntax ) ; if ( strncmp ( transfer_syntax , ""1.2.840.10008.1.2"" , 17 ) == 0 ) { int subtype , type ; type = 1 ; subtype = 0 ; if ( strlen ( transfer_syntax ) > 17 ) { count = ( ssize_t ) sscanf ( transfer_syntax + 17 , "".%d.%d"" , & type , & subtype ) ; if ( count < 1 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } switch ( type ) { case 1 : { image -> endian = LSBEndian ; break ; } case 2 : { image -> endian = MSBEndian ; break ; } case 4 : { if ( ( subtype >= 80 ) && ( subtype <= 81 ) ) image -> compression = JPEGCompression ; else if ( ( subtype >= 90 ) && ( subtype <= 93 ) ) image -> compression = JPEG2000Compression ; else image -> compression = JPEGCompression ; break ; } case 5 : { image -> compression = RLECompression ; break ; } } } break ; } default : break ; } break ; } case 0x0028 : { switch ( element ) { case 0x0002 : { info . samples_per_pixel = ( size_t ) datum ; if ( ( info . samples_per_pixel == 0 ) || ( info . samples_per_pixel > 4 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; break ; } case 0x0004 : { if ( data == ( unsigned char * ) NULL ) break ; for ( i = 0 ; i < ( ssize_t ) MagickMin ( length , MagickPathExtent - 1 ) ; i ++ ) photometric [ i ] = ( char ) data [ i ] ; photometric [ i ] = '\\0' ; info . polarity = LocaleCompare ( photometric , ""MONOCHROME1<S2SV_blank>"" ) == 0 ? MagickTrue : MagickFalse ; break ; } case 0x0006 : { if ( datum == 1 ) image -> interlace = PlaneInterlace ; break ; } case 0x0008 : { if ( data == ( unsigned char * ) NULL ) break ; number_scenes = StringToUnsignedLong ( ( char * ) data ) ; break ; } case 0x0010 : { height = ( size_t ) datum ; break ; } case 0x0011 : { width = ( size_t ) datum ; break ; } case 0x0100 : { info . bits_allocated = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( datum > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . bits_allocated ; if ( ( info . depth == 0 ) || ( info . depth > 32 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; info . max_value = ( 1UL << info . bits_allocated ) - 1 ; image -> depth = info . depth ; break ; } case 0x0101 : { info . significant_bits = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( info . significant_bits > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . significant_bits ; if ( ( info . depth == 0 ) || ( info . depth > 16 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; info . max_value = ( 1UL << info . significant_bits ) - 1 ; info . mask = ( size_t ) GetQuantumRange ( info . significant_bits ) ; image -> depth = info . depth ; break ; } case 0x0102 : { break ; } case 0x0103 : { info . signed_data = ( size_t ) datum ; break ; } case 0x1050 : { if ( data != ( unsigned char * ) NULL ) info . window_center = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1051 : { if ( data != ( unsigned char * ) NULL ) info . window_width = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1052 : { if ( data != ( unsigned char * ) NULL ) info . rescale_intercept = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1053 : { if ( data != ( unsigned char * ) NULL ) info . rescale_slope = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1200 : case 0x3006 : { if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / info . bytes_per_pixel ) ; datum = ( int ) colors ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; graymap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * graymap ) ) ; if ( graymap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( graymap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * graymap ) ) ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) if ( info . bytes_per_pixel == 1 ) graymap [ i ] = ( int ) data [ i ] ; else graymap [ i ] = ( int ) ( ( short * ) data ) [ i ] ; break ; } case 0x1201 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; redmap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * redmap ) ) ; if ( redmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( redmap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * redmap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; redmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1202 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; greenmap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * greenmap ) ) ; if ( greenmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( greenmap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * greenmap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; greenmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1203 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; bluemap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * bluemap ) ) ; if ( bluemap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( bluemap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * bluemap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; bluemap [ i ] = ( int ) index ; p += 2 ; } break ; } default : break ; } break ; } case 0x2050 : { switch ( element ) { case 0x0020 : { if ( ( data != ( unsigned char * ) NULL ) && ( strncmp ( ( char * ) data , ""INVERSE"" , 7 ) == 0 ) ) info . polarity = MagickTrue ; break ; } default : break ; } break ; } default : break ; } if ( data != ( unsigned char * ) NULL ) { char * attribute ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; if ( dicom_info [ i ] . description != ( char * ) NULL ) { attribute = AcquireString ( ""dcm:"" ) ; ( void ) ConcatenateString ( & attribute , dicom_info [ i ] . description ) ; for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i == ( ssize_t ) length ) || ( length > 4 ) ) { ( void ) SubstituteString ( & attribute , ""<S2SV_blank>"" , """" ) ; ( void ) SetImageProperty ( image , attribute , ( char * ) data , exception ) ; } attribute = DestroyString ( attribute ) ; } } if ( image_info -> verbose != MagickFalse ) { if ( data == ( unsigned char * ) NULL ) ( void ) FormatLocaleFile ( stdout , ""%d\\n"" , datum ) ; else { for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i != ( ssize_t ) length ) && ( length <= 4 ) ) { ssize_t j ; datum = 0 ; for ( j = ( ssize_t ) length - 1 ; j >= 0 ; j -- ) datum = ( 256 * datum + data [ j ] ) ; ( void ) FormatLocaleFile ( stdout , ""%d"" , datum ) ; } else for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) if ( isprint ( ( int ) data [ i ] ) != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""%c"" , data [ i ] ) ; else ( void ) FormatLocaleFile ( stdout , ""%c"" , '.' ) ; ( void ) FormatLocaleFile ( stdout , ""\\n"" ) ; } } if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } if ( ( group == 0xfffc ) && ( element == 0xfffc ) ) { Image * last ; last = RemoveLastImageFromList ( & image ) ; if ( last != ( Image * ) NULL ) last = DestroyImage ( last ) ; break ; } if ( ( width == 0 ) || ( height == 0 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; if ( info . signed_data == 0xffff ) info . signed_data = ( size_t ) ( info . significant_bits == 16 ? 1 : 0 ) ; if ( ( image -> compression == JPEGCompression ) || ( image -> compression == JPEG2000Compression ) ) { Image * images ; ImageInfo * read_info ; int c ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; ( void ) ( ( ( ssize_t ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; offset = TellBlob ( image ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; images = NewImageList ( ) ; for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { char filename [ MagickPathExtent ] ; const char * property ; FILE * file ; Image * jpeg_image ; int unique_file ; unsigned int tag ; tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( tag == 0xFFFEE0DD ) break ; if ( tag != 0xFFFEE000 ) { read_info = DestroyImageInfo ( read_info ) ; ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ; if ( file == ( FILE * ) NULL ) { ( void ) RelinquishUniqueFileResource ( filename ) ; ThrowFileException ( exception , FileOpenError , ""UnableToCreateTemporaryFile"" , filename ) ; break ; } for ( c = EOF ; length != 0 ; length -- ) { c = ReadBlobByte ( image ) ; if ( c == EOF ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } <S2SV_StartBug> ( void ) fputc ( c , file ) ; <S2SV_EndBug> } ( void ) fclose ( file ) ; if ( c == EOF ) break ; ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , ""jpeg:%s"" , filename ) ; if ( image -> compression == JPEG2000Compression ) ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , ""j2k:%s"" , filename ) ; jpeg_image = ReadImage ( read_info , exception ) ; if ( jpeg_image != ( Image * ) NULL ) { ResetImagePropertyIterator ( image ) ; property = GetNextImageProperty ( image ) ; while ( property != ( const char * ) NULL ) { ( void ) SetImageProperty ( jpeg_image , property , GetImageProperty ( image , property , exception ) , exception ) ; property = GetNextImageProperty ( image ) ; } AppendImageToList ( & images , jpeg_image ) ; } ( void ) RelinquishUniqueFileResource ( filename ) ; } read_info = DestroyImageInfo ( read_info ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; image = DestroyImageList ( image ) ; return ( GetFirstImageInList ( images ) ) ; } if ( info . depth != ( 1UL * MAGICKCORE_QUANTUM_DEPTH ) ) { QuantumAny range ; length = ( size_t ) ( GetQuantumRange ( info . depth ) + 1 ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; info . scale = ( Quantum * ) AcquireQuantumMemory ( MagickMax ( length , 256 ) , sizeof ( * info . scale ) ) ; if ( info . scale == ( Quantum * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( info . scale , 0 , MagickMax ( length , 256 ) * sizeof ( * info . scale ) ) ; range = GetQuantumRange ( info . depth ) ; for ( i = 0 ; i <= ( ssize_t ) GetQuantumRange ( info . depth ) ; i ++ ) info . scale [ i ] = ScaleAnyToQuantum ( ( size_t ) i , range ) ; } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; ( void ) tag ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) { stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; } offset = TellBlob ( image ) + 8 ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } } for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { if ( image_info -> ping != MagickFalse ) break ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; image -> depth = info . depth ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break ; image -> colorspace = RGBColorspace ; ( void ) SetImageBackgroundColor ( image , exception ) ; if ( ( image -> colormap == ( PixelInfo * ) NULL ) && ( info . samples_per_pixel == 1 ) ) { int index ; size_t one ; one = 1 ; if ( colors == 0 ) colors = one << info . depth ; if ( AcquireImageColormap ( image , colors , exception ) == MagickFalse ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( redmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = redmap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; } if ( greenmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = greenmap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . green = ( MagickRealType ) index ; } if ( bluemap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = bluemap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } if ( graymap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = graymap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; image -> colormap [ i ] . green = ( MagickRealType ) index ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; stream_info -> remaining = ( size_t ) ReadBlobLSBLong ( image ) ; if ( ( tag != 0xFFFEE000 ) || ( stream_info -> remaining <= 64 ) || ( EOFBlob ( image ) != MagickFalse ) ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } stream_info -> count = 0 ; stream_info -> segment_count = ReadBlobLSBLong ( image ) ; for ( i = 0 ; i < 15 ; i ++ ) stream_info -> segments [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; stream_info -> remaining -= 64 ; if ( stream_info -> segment_count > 1 ) { info . bytes_per_pixel = 1 ; info . depth = 8 ; if ( stream_info -> offset_count > 0 ) ( void ) SeekBlob ( image , ( MagickOffsetType ) stream_info -> offsets [ 0 ] + stream_info -> segments [ 0 ] , SEEK_SET ) ; } } if ( ( info . samples_per_pixel > 1 ) && ( image -> interlace == PlaneInterlace ) ) { register ssize_t x ; register Quantum * q ; ssize_t y ; for ( i = 0 ; i < ( ssize_t ) info . samples_per_pixel ; i ++ ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { switch ( ( int ) i ) { case 0 : { SetPixelRed ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 1 : { SetPixelGreen ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 2 : { SetPixelBlue ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 3 : { SetPixelAlpha ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } default : break ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } } else { const char * option ; option = GetImageOption ( image_info , ""dcm:display-range"" ) ; if ( option != ( const char * ) NULL ) { if ( LocaleCompare ( option , ""reset"" ) == 0 ) info . window_width = 0 ; } option = GetImageOption ( image_info , ""dcm:window"" ) ; if ( option != ( char * ) NULL ) { GeometryInfo geometry_info ; MagickStatusType flags ; flags = ParseGeometry ( option , & geometry_info ) ; if ( flags & RhoValue ) info . window_center = geometry_info . rho ; if ( flags & SigmaValue ) info . window_width = geometry_info . sigma ; info . rescale = MagickTrue ; } option = GetImageOption ( image_info , ""dcm:rescale"" ) ; if ( option != ( char * ) NULL ) info . rescale = IsStringTrue ( option ) ; if ( ( info . window_center != 0 ) && ( info . window_width == 0 ) ) info . window_width = info . window_center ; status = ReadDCMPixels ( image , & info , stream_info , MagickTrue , exception ) ; if ( ( status != MagickFalse ) && ( stream_info -> segment_count > 1 ) ) { if ( stream_info -> offset_count > 0 ) ( void ) SeekBlob ( image , ( MagickOffsetType ) stream_info -> offsets [ 0 ] + stream_info -> segments [ 1 ] , SEEK_SET ) ; ( void ) ReadDCMPixels ( image , & info , stream_info , MagickFalse , exception ) ; } } if ( SetImageGray ( image , exception ) != MagickFalse ) ( void ) SetImageColorspace ( image , GRAYColorspace , exception ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( scene < ( ssize_t ) ( number_scenes - 1 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( TellBlob ( image ) < ( MagickOffsetType ) GetBlobSize ( image ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> , message ) \\\n{ <S2SV_ModEnd> if ( info <S2SV_ModStart> ) ) ; \\\n} <S2SV_ModEnd> char explicit_vr [ <S2SV_ModStart> break ; } if ( <S2SV_ModEnd> fputc ( c <S2SV_ModStart> , file ) != c ) break
"
835,"CWE-125 opj_pi_iterator_t * opj_pi_create_decode ( opj_image_t * p_image , opj_cp_t * p_cp , OPJ_UINT32 p_tile_no ) { OPJ_UINT32 pino ; OPJ_UINT32 compno , resno ; OPJ_UINT32 * l_tmp_data ; OPJ_UINT32 * * l_tmp_ptr ; OPJ_UINT32 l_max_res ; OPJ_UINT32 l_max_prec ; OPJ_INT32 l_tx0 , l_tx1 , l_ty0 , l_ty1 ; OPJ_UINT32 l_dx_min , l_dy_min ; OPJ_UINT32 l_bound ; OPJ_UINT32 l_step_p , l_step_c , l_step_r , l_step_l ; OPJ_UINT32 l_data_stride ; opj_pi_iterator_t * l_pi = 00 ; opj_tcp_t * l_tcp = 00 ; const opj_tccp_t * l_tccp = 00 ; opj_pi_comp_t * l_current_comp = 00 ; opj_image_comp_t * l_img_comp = 00 ; opj_pi_iterator_t * l_current_pi = 00 ; OPJ_UINT32 * l_encoding_value_ptr = 00 ; assert ( p_cp != 00 ) ; assert ( p_image != 00 ) ; assert ( p_tile_no < p_cp -> tw * p_cp -> th ) ; l_tcp = & p_cp -> tcps [ p_tile_no ] ; l_bound = l_tcp -> numpocs + 1 ; l_data_stride = 4 * OPJ_J2K_MAXRLVLS ; l_tmp_data = ( OPJ_UINT32 * ) opj_malloc ( l_data_stride * p_image -> numcomps * sizeof ( OPJ_UINT32 ) ) ; if ( ! l_tmp_data ) { return 00 ; } l_tmp_ptr = ( OPJ_UINT32 * * ) opj_malloc ( p_image -> numcomps * sizeof ( OPJ_UINT32 * ) ) ; if ( ! l_tmp_ptr ) { opj_free ( l_tmp_data ) ; return 00 ; } l_pi = opj_pi_create ( p_image , p_cp , p_tile_no ) ; if ( ! l_pi ) { opj_free ( l_tmp_data ) ; opj_free ( l_tmp_ptr ) ; return 00 ; } l_encoding_value_ptr = l_tmp_data ; for ( compno = 0 ; compno < p_image -> numcomps ; ++ compno ) { l_tmp_ptr [ compno ] = l_encoding_value_ptr ; l_encoding_value_ptr += l_data_stride ; } opj_get_all_encoding_parameters ( p_image , p_cp , p_tile_no , & l_tx0 , & l_tx1 , & l_ty0 , & l_ty1 , & l_dx_min , & l_dy_min , & l_max_prec , & l_max_res , l_tmp_ptr ) ; l_step_p = 1 ; l_step_c = l_max_prec * l_step_p ; l_step_r = p_image -> numcomps * l_step_c ; l_step_l = l_max_res * l_step_r ; l_current_pi = l_pi ; l_current_pi -> include = 00 ; if ( l_step_l <= ( SIZE_MAX / ( l_tcp -> numlayers + 1U ) ) ) { <S2SV_StartBug> l_current_pi -> include = ( OPJ_INT16 * ) opj_calloc ( ( l_tcp -> numlayers + 1 ) * l_step_l , sizeof ( OPJ_INT16 ) ) ; <S2SV_EndBug> } if ( ! l_current_pi -> include ) { opj_free ( l_tmp_data ) ; opj_free ( l_tmp_ptr ) ; opj_pi_destroy ( l_pi , l_bound ) ; return 00 ; } l_current_comp = l_current_pi -> comps ; l_img_comp = p_image -> comps ; l_tccp = l_tcp -> tccps ; l_current_pi -> tx0 = l_tx0 ; l_current_pi -> ty0 = l_ty0 ; l_current_pi -> tx1 = l_tx1 ; l_current_pi -> ty1 = l_ty1 ; l_current_pi -> step_p = l_step_p ; l_current_pi -> step_c = l_step_c ; l_current_pi -> step_r = l_step_r ; l_current_pi -> step_l = l_step_l ; for ( compno = 0 ; compno < l_current_pi -> numcomps ; ++ compno ) { opj_pi_resolution_t * l_res = l_current_comp -> resolutions ; l_encoding_value_ptr = l_tmp_ptr [ compno ] ; l_current_comp -> dx = l_img_comp -> dx ; l_current_comp -> dy = l_img_comp -> dy ; for ( resno = 0 ; resno < l_current_comp -> numresolutions ; resno ++ ) { l_res -> pdx = * ( l_encoding_value_ptr ++ ) ; l_res -> pdy = * ( l_encoding_value_ptr ++ ) ; l_res -> pw = * ( l_encoding_value_ptr ++ ) ; l_res -> ph = * ( l_encoding_value_ptr ++ ) ; ++ l_res ; } ++ l_current_comp ; ++ l_img_comp ; ++ l_tccp ; } ++ l_current_pi ; for ( pino = 1 ; pino < l_bound ; ++ pino ) { l_current_comp = l_current_pi -> comps ; l_img_comp = p_image -> comps ; l_tccp = l_tcp -> tccps ; l_current_pi -> tx0 = l_tx0 ; l_current_pi -> ty0 = l_ty0 ; l_current_pi -> tx1 = l_tx1 ; l_current_pi -> ty1 = l_ty1 ; l_current_pi -> step_p = l_step_p ; l_current_pi -> step_c = l_step_c ; l_current_pi -> step_r = l_step_r ; l_current_pi -> step_l = l_step_l ; for ( compno = 0 ; compno < l_current_pi -> numcomps ; ++ compno ) { opj_pi_resolution_t * l_res = l_current_comp -> resolutions ; l_encoding_value_ptr = l_tmp_ptr [ compno ] ; l_current_comp -> dx = l_img_comp -> dx ; l_current_comp -> dy = l_img_comp -> dy ; for ( resno = 0 ; resno < l_current_comp -> numresolutions ; resno ++ ) { l_res -> pdx = * ( l_encoding_value_ptr ++ ) ; l_res -> pdy = * ( l_encoding_value_ptr ++ ) ; l_res -> pw = * ( l_encoding_value_ptr ++ ) ; l_res -> ph = * ( l_encoding_value_ptr ++ ) ; ++ l_res ; } ++ l_current_comp ; ++ l_img_comp ; ++ l_tccp ; } l_current_pi -> include = ( l_current_pi - 1 ) -> include ; ++ l_current_pi ; } opj_free ( l_tmp_data ) ; l_tmp_data = 00 ; opj_free ( l_tmp_ptr ) ; l_tmp_ptr = 00 ; if ( l_tcp -> POC ) { opj_pi_update_decode_poc ( l_pi , l_tcp , l_max_prec , l_max_res ) ; } else { opj_pi_update_decode_not_poc ( l_pi , l_tcp , l_max_prec , l_max_res ) ; } return l_pi ; }
","<S2SV_ModStart> opj_calloc ( ( size_t ) ( <S2SV_ModStart> -> numlayers + 1U <S2SV_ModEnd> ) * l_step_l
"
836,"CWE-119 void traverse_commit_list ( struct rev_info * revs , show_commit_fn show_commit , show_object_fn show_object , void * data ) { int i ; struct commit * commit ; struct strbuf base ; strbuf_init ( & base , PATH_MAX ) ; while ( ( commit = get_revision ( revs ) ) != NULL ) { if ( commit -> tree ) add_pending_tree ( revs , commit -> tree ) ; show_commit ( commit , data ) ; } for ( i = 0 ; i < revs -> pending . nr ; i ++ ) { struct object_array_entry * pending = revs -> pending . objects + i ; struct object * obj = pending -> item ; const char * name = pending -> name ; const char * path = pending -> path ; if ( obj -> flags & ( UNINTERESTING | SEEN ) ) continue ; if ( obj -> type == OBJ_TAG ) { obj -> flags |= SEEN ; <S2SV_StartBug> show_object ( obj , NULL , name , data ) ; <S2SV_EndBug> continue ; } if ( ! path ) path = """" ; if ( obj -> type == OBJ_TREE ) { process_tree ( revs , ( struct tree * ) obj , show_object , & base , path , data ) ; continue ; } if ( obj -> type == OBJ_BLOB ) { process_blob ( revs , ( struct blob * ) obj , show_object , <S2SV_StartBug> NULL , path , data ) ; <S2SV_EndBug> continue ; } die ( ""unknown<S2SV_blank>pending<S2SV_blank>object<S2SV_blank>%s<S2SV_blank>(%s)"" , oid_to_hex ( & obj -> oid ) , name ) ; } object_array_clear ( & revs -> pending ) ; strbuf_release ( & base ) ; }
","<S2SV_ModStart> ( obj , <S2SV_ModEnd> name , data <S2SV_ModStart> , show_object , & base <S2SV_ModEnd> , path ,
"
837,"CWE-264 static int ovl_fill_super ( struct super_block * sb , void * data , int silent ) { struct path lowerpath ; struct path upperpath ; struct path workpath ; struct inode * root_inode ; struct dentry * root_dentry ; struct ovl_entry * oe ; struct ovl_fs * ufs ; struct kstatfs statfs ; int err ; err = - ENOMEM ; ufs = kzalloc ( sizeof ( struct ovl_fs ) , GFP_KERNEL ) ; if ( ! ufs ) goto out ; err = ovl_parse_opt ( ( char * ) data , & ufs -> config ) ; if ( err ) goto out_free_config ; err = - EINVAL ; if ( ! ufs -> config . upperdir || ! ufs -> config . lowerdir || ! ufs -> config . workdir ) { pr_err ( ""overlayfs:<S2SV_blank>missing<S2SV_blank>upperdir<S2SV_blank>or<S2SV_blank>lowerdir<S2SV_blank>or<S2SV_blank>workdir\\n"" ) ; goto out_free_config ; } err = - ENOMEM ; oe = ovl_alloc_entry ( ) ; if ( oe == NULL ) goto out_free_config ; err = ovl_mount_dir ( ufs -> config . upperdir , & upperpath ) ; if ( err ) goto out_free_oe ; err = ovl_mount_dir ( ufs -> config . lowerdir , & lowerpath ) ; if ( err ) goto out_put_upperpath ; err = ovl_mount_dir ( ufs -> config . workdir , & workpath ) ; if ( err ) goto out_put_lowerpath ; err = - EINVAL ; if ( ! S_ISDIR ( upperpath . dentry -> d_inode -> i_mode ) || ! S_ISDIR ( lowerpath . dentry -> d_inode -> i_mode ) || ! S_ISDIR ( workpath . dentry -> d_inode -> i_mode ) ) { pr_err ( ""overlayfs:<S2SV_blank>upperdir<S2SV_blank>or<S2SV_blank>lowerdir<S2SV_blank>or<S2SV_blank>workdir<S2SV_blank>not<S2SV_blank>a<S2SV_blank>directory\\n"" ) ; goto out_put_workpath ; } if ( upperpath . mnt != workpath . mnt ) { pr_err ( ""overlayfs:<S2SV_blank>workdir<S2SV_blank>and<S2SV_blank>upperdir<S2SV_blank>must<S2SV_blank>reside<S2SV_blank>under<S2SV_blank>the<S2SV_blank>same<S2SV_blank>mount\\n"" ) ; goto out_put_workpath ; } if ( ! ovl_workdir_ok ( workpath . dentry , upperpath . dentry ) ) { pr_err ( ""overlayfs:<S2SV_blank>workdir<S2SV_blank>and<S2SV_blank>upperdir<S2SV_blank>must<S2SV_blank>be<S2SV_blank>separate<S2SV_blank>subtrees\\n"" ) ; goto out_put_workpath ; } if ( ! ovl_is_allowed_fs_type ( upperpath . dentry ) ) { pr_err ( ""overlayfs:<S2SV_blank>filesystem<S2SV_blank>of<S2SV_blank>upperdir<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported\\n"" ) ; goto out_put_workpath ; } if ( ! ovl_is_allowed_fs_type ( lowerpath . dentry ) ) { pr_err ( ""overlayfs:<S2SV_blank>filesystem<S2SV_blank>of<S2SV_blank>lowerdir<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported\\n"" ) ; goto out_put_workpath ; } err = vfs_statfs ( & lowerpath , & statfs ) ; if ( err ) { pr_err ( ""overlayfs:<S2SV_blank>statfs<S2SV_blank>failed<S2SV_blank>on<S2SV_blank>lowerpath\\n"" ) ; goto out_put_workpath ; } ufs -> lower_namelen = statfs . f_namelen ; <S2SV_StartBug> ufs -> upper_mnt = clone_private_mount ( & upperpath ) ; <S2SV_EndBug> err = PTR_ERR ( ufs -> upper_mnt ) ; if ( IS_ERR ( ufs -> upper_mnt ) ) { pr_err ( ""overlayfs:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>clone<S2SV_blank>upperpath\\n"" ) ; goto out_put_workpath ; } ufs -> lower_mnt = clone_private_mount ( & lowerpath ) ; err = PTR_ERR ( ufs -> lower_mnt ) ; if ( IS_ERR ( ufs -> lower_mnt ) ) { pr_err ( ""overlayfs:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>clone<S2SV_blank>lowerpath\\n"" ) ; goto out_put_upper_mnt ; } ufs -> workdir = ovl_workdir_create ( ufs -> upper_mnt , workpath . dentry ) ; err = PTR_ERR ( ufs -> workdir ) ; if ( IS_ERR ( ufs -> workdir ) ) { pr_err ( ""overlayfs:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>directory<S2SV_blank>%s/%s\\n"" , ufs -> config . workdir , OVL_WORKDIR_NAME ) ; goto out_put_lower_mnt ; } ufs -> lower_mnt -> mnt_flags |= MNT_READONLY ; if ( ufs -> upper_mnt -> mnt_sb -> s_flags & MS_RDONLY ) sb -> s_flags |= MS_RDONLY ; sb -> s_d_op = & ovl_dentry_operations ; err = - ENOMEM ; root_inode = ovl_new_inode ( sb , S_IFDIR , oe ) ; if ( ! root_inode ) goto out_put_workdir ; root_dentry = d_make_root ( root_inode ) ; if ( ! root_dentry ) goto out_put_workdir ; mntput ( upperpath . mnt ) ; mntput ( lowerpath . mnt ) ; path_put ( & workpath ) ; oe -> __upperdentry = upperpath . dentry ; oe -> lowerdentry = lowerpath . dentry ; root_dentry -> d_fsdata = oe ; sb -> s_magic = OVERLAYFS_SUPER_MAGIC ; sb -> s_op = & ovl_super_operations ; sb -> s_root = root_dentry ; sb -> s_fs_info = ufs ; return 0 ; out_put_workdir : dput ( ufs -> workdir ) ; out_put_lower_mnt : mntput ( ufs -> lower_mnt ) ; out_put_upper_mnt : mntput ( ufs -> upper_mnt ) ; out_put_workpath : path_put ( & workpath ) ; out_put_lowerpath : path_put ( & lowerpath ) ; out_put_upperpath : path_put ( & upperpath ) ; out_free_oe : kfree ( oe ) ; out_free_config : kfree ( ufs -> config . lowerdir ) ; kfree ( ufs -> config . upperdir ) ; kfree ( ufs -> config . workdir ) ; kfree ( ufs ) ; out : return err ; }
","<S2SV_ModStart> . f_namelen ; sb -> s_stack_depth = max ( upperpath . mnt -> mnt_sb -> s_stack_depth , lowerpath . mnt -> mnt_sb -> s_stack_depth ) + 1 ; err = - EINVAL ; if ( sb -> s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH ) { pr_err ( ""overlayfs:<S2SV_blank>maximum<S2SV_blank>fs<S2SV_blank>stacking<S2SV_blank>depth<S2SV_blank>exceeded\\n"" ) ; goto out_put_workpath ; }
"
838,"CWE-19 static int ext4_xattr_block_list ( struct dentry * dentry , char * buffer , size_t buffer_size ) { struct inode * inode = d_inode ( dentry ) ; struct buffer_head * bh = NULL ; int error ; <S2SV_StartBug> struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ; <S2SV_EndBug> ea_idebug ( inode , ""buffer=%p,<S2SV_blank>buffer_size=%ld"" , buffer , ( long ) buffer_size ) ; error = 0 ; if ( ! EXT4_I ( inode ) -> i_file_acl ) goto cleanup ; ea_idebug ( inode , ""reading<S2SV_blank>block<S2SV_blank>%llu"" , ( unsigned long long ) EXT4_I ( inode ) -> i_file_acl ) ; bh = sb_bread ( inode -> i_sb , EXT4_I ( inode ) -> i_file_acl ) ; error = - EIO ; if ( ! bh ) goto cleanup ; ea_bdebug ( bh , ""b_count=%d,<S2SV_blank>refcount=%d"" , atomic_read ( & ( bh -> b_count ) ) , le32_to_cpu ( BHDR ( bh ) -> h_refcount ) ) ; if ( ext4_xattr_check_block ( inode , bh ) ) { EXT4_ERROR_INODE ( inode , ""bad<S2SV_blank>block<S2SV_blank>%llu"" , EXT4_I ( inode ) -> i_file_acl ) ; error = - EFSCORRUPTED ; goto cleanup ; } ext4_xattr_cache_insert ( ext4_mb_cache , bh ) ; error = ext4_xattr_list_entries ( dentry , BFIRST ( bh ) , buffer , buffer_size ) ; cleanup : brelse ( bh ) ; return error ; }
","<S2SV_ModStart> error ; struct mb2_cache <S2SV_ModEnd> * ext4_mb_cache =
"
839,"CWE-347 void pointZZ_pDouble ( PointZZ_p * rop , const PointZZ_p * op , const CurveZZ_p * curve ) { <S2SV_StartBug> mpz_t numer , denom , lambda ; <S2SV_EndBug> mpz_inits ( numer , denom , lambda , NULL ) ; mpz_mul ( numer , op -> x , op -> x ) ; mpz_mul_ui ( numer , numer , 3 ) ; mpz_add ( numer , numer , curve -> a ) ; mpz_mul_ui ( denom , op -> y , 2 ) ; mpz_invert ( denom , denom , curve -> p ) ; mpz_mul ( lambda , numer , denom ) ; mpz_mod ( lambda , lambda , curve -> p ) ; mpz_mul ( rop -> x , lambda , lambda ) ; mpz_sub ( rop -> x , rop -> x , op -> x ) ; mpz_sub ( rop -> x , rop -> x , op -> x ) ; mpz_mod ( rop -> x , rop -> x , curve -> p ) ; mpz_sub ( rop -> y , op -> x , rop -> x ) ; mpz_mul ( rop -> y , lambda , rop -> y ) ; mpz_sub ( rop -> y , rop -> y , op -> y ) ; mpz_mod ( rop -> y , rop -> y , curve -> p ) ; mpz_clears ( numer , denom , lambda , NULL ) ; }
","<S2SV_ModStart> curve ) { if ( pointZZ_pIsIdentityElement ( op ) ) { return pointZZ_pSetToIdentityElement ( rop ) ; }
"
840,"CWE-284 int x86_decode_insn ( struct x86_emulate_ctxt * ctxt , void * insn , int insn_len ) { int rc = X86EMUL_CONTINUE ; int mode = ctxt -> mode ; int def_op_bytes , def_ad_bytes , goffset , simd_prefix ; bool op_prefix = false ; bool has_seg_override = false ; struct opcode opcode ; ctxt -> memop . type = OP_NONE ; ctxt -> memopp = NULL ; ctxt -> _eip = ctxt -> eip ; ctxt -> fetch . ptr = ctxt -> fetch . data ; ctxt -> fetch . end = ctxt -> fetch . data + insn_len ; ctxt -> opcode_len = 1 ; if ( insn_len > 0 ) memcpy ( ctxt -> fetch . data , insn , insn_len ) ; else { rc = __do_insn_fetch_bytes ( ctxt , 1 ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; } switch ( mode ) { case X86EMUL_MODE_REAL : case X86EMUL_MODE_VM86 : case X86EMUL_MODE_PROT16 : def_op_bytes = def_ad_bytes = 2 ; break ; case X86EMUL_MODE_PROT32 : def_op_bytes = def_ad_bytes = 4 ; break ; # ifdef CONFIG_X86_64 case X86EMUL_MODE_PROT64 : def_op_bytes = 4 ; def_ad_bytes = 8 ; break ; # endif default : return EMULATION_FAILED ; } ctxt -> op_bytes = def_op_bytes ; ctxt -> ad_bytes = def_ad_bytes ; for ( ; ; ) { switch ( ctxt -> b = insn_fetch ( u8 , ctxt ) ) { case 0x66 : op_prefix = true ; ctxt -> op_bytes = def_op_bytes ^ 6 ; break ; case 0x67 : if ( mode == X86EMUL_MODE_PROT64 ) ctxt -> ad_bytes = def_ad_bytes ^ 12 ; else ctxt -> ad_bytes = def_ad_bytes ^ 6 ; break ; case 0x26 : case 0x2e : case 0x36 : case 0x3e : has_seg_override = true ; ctxt -> seg_override = ( ctxt -> b >> 3 ) & 3 ; break ; case 0x64 : case 0x65 : has_seg_override = true ; ctxt -> seg_override = ctxt -> b & 7 ; break ; case 0x40 ... 0x4f : if ( mode != X86EMUL_MODE_PROT64 ) goto done_prefixes ; ctxt -> rex_prefix = ctxt -> b ; continue ; case 0xf0 : ctxt -> lock_prefix = 1 ; break ; case 0xf2 : case 0xf3 : ctxt -> rep_prefix = ctxt -> b ; break ; default : goto done_prefixes ; } ctxt -> rex_prefix = 0 ; } done_prefixes : if ( ctxt -> rex_prefix & 8 ) ctxt -> op_bytes = 8 ; opcode = opcode_table [ ctxt -> b ] ; if ( ctxt -> b == 0x0f ) { ctxt -> opcode_len = 2 ; ctxt -> b = insn_fetch ( u8 , ctxt ) ; opcode = twobyte_table [ ctxt -> b ] ; if ( ctxt -> b == 0x38 ) { ctxt -> opcode_len = 3 ; ctxt -> b = insn_fetch ( u8 , ctxt ) ; opcode = opcode_map_0f_38 [ ctxt -> b ] ; } } ctxt -> d = opcode . flags ; if ( ctxt -> d & ModRM ) ctxt -> modrm = insn_fetch ( u8 , ctxt ) ; if ( ctxt -> opcode_len == 1 && ( ctxt -> b == 0xc5 || ctxt -> b == 0xc4 ) && ( mode == X86EMUL_MODE_PROT64 || ( ctxt -> modrm & 0xc0 ) == 0xc0 ) ) { ctxt -> d = NotImpl ; } while ( ctxt -> d & GroupMask ) { switch ( ctxt -> d & GroupMask ) { case Group : goffset = ( ctxt -> modrm >> 3 ) & 7 ; opcode = opcode . u . group [ goffset ] ; break ; case GroupDual : goffset = ( ctxt -> modrm >> 3 ) & 7 ; if ( ( ctxt -> modrm >> 6 ) == 3 ) opcode = opcode . u . gdual -> mod3 [ goffset ] ; else opcode = opcode . u . gdual -> mod012 [ goffset ] ; break ; case RMExt : goffset = ctxt -> modrm & 7 ; opcode = opcode . u . group [ goffset ] ; break ; case Prefix : if ( ctxt -> rep_prefix && op_prefix ) return EMULATION_FAILED ; simd_prefix = op_prefix ? 0x66 : ctxt -> rep_prefix ; switch ( simd_prefix ) { case 0x00 : opcode = opcode . u . gprefix -> pfx_no ; break ; case 0x66 : opcode = opcode . u . gprefix -> pfx_66 ; break ; case 0xf2 : opcode = opcode . u . gprefix -> pfx_f2 ; break ; case 0xf3 : opcode = opcode . u . gprefix -> pfx_f3 ; break ; } break ; case Escape : if ( ctxt -> modrm > 0xbf ) opcode = opcode . u . esc -> high [ ctxt -> modrm - 0xc0 ] ; else opcode = opcode . u . esc -> op [ ( ctxt -> modrm >> 3 ) & 7 ] ; break ; case InstrDual : if ( ( ctxt -> modrm >> 6 ) == 3 ) opcode = opcode . u . idual -> mod3 ; else opcode = opcode . u . idual -> mod012 ; break ; case ModeDual : if ( ctxt -> mode == X86EMUL_MODE_PROT64 ) opcode = opcode . u . mdual -> mode64 ; else opcode = opcode . u . mdual -> mode32 ; break ; default : return EMULATION_FAILED ; } ctxt -> d &= ~ ( u64 ) GroupMask ; ctxt -> d |= opcode . flags ; } if ( ctxt -> d == 0 ) return EMULATION_FAILED ; ctxt -> execute = opcode . u . execute ; if ( unlikely ( ctxt -> ud ) && likely ( ! ( ctxt -> d & EmulateOnUD ) ) ) return EMULATION_FAILED ; if ( unlikely ( ctxt -> d & ( NotImpl | Stack | Op3264 | Sse | Mmx | Intercept | CheckPerm | NearBranch | No16 ) ) ) { ctxt -> check_perm = opcode . check_perm ; ctxt -> intercept = opcode . intercept ; if ( ctxt -> d & NotImpl ) return EMULATION_FAILED ; if ( mode == X86EMUL_MODE_PROT64 ) { if ( ctxt -> op_bytes == 4 && ( ctxt -> d & Stack ) ) ctxt -> op_bytes = 8 ; else if ( ctxt -> d & NearBranch ) ctxt -> op_bytes = 8 ; } if ( ctxt -> d & Op3264 ) { if ( mode == X86EMUL_MODE_PROT64 ) ctxt -> op_bytes = 8 ; else ctxt -> op_bytes = 4 ; } if ( ( ctxt -> d & No16 ) && ctxt -> op_bytes == 2 ) ctxt -> op_bytes = 4 ; if ( ctxt -> d & Sse ) ctxt -> op_bytes = 16 ; else if ( ctxt -> d & Mmx ) ctxt -> op_bytes = 8 ; } if ( ctxt -> d & ModRM ) { rc = decode_modrm ( ctxt , & ctxt -> memop ) ; if ( ! has_seg_override ) { has_seg_override = true ; ctxt -> seg_override = ctxt -> modrm_seg ; } } else if ( ctxt -> d & MemAbs ) rc = decode_abs ( ctxt , & ctxt -> memop ) ; if ( rc != X86EMUL_CONTINUE ) goto done ; if ( ! has_seg_override ) ctxt -> seg_override = VCPU_SREG_DS ; ctxt -> memop . addr . mem . seg = ctxt -> seg_override ; rc = decode_operand ( ctxt , & ctxt -> src , ( ctxt -> d >> SrcShift ) & OpMask ) ; if ( rc != X86EMUL_CONTINUE ) goto done ; rc = decode_operand ( ctxt , & ctxt -> src2 , ( ctxt -> d >> Src2Shift ) & OpMask ) ; if ( rc != X86EMUL_CONTINUE ) goto done ; rc = decode_operand ( ctxt , & ctxt -> dst , ( ctxt -> d >> DstShift ) & OpMask ) ; <S2SV_StartBug> if ( ctxt -> rip_relative ) <S2SV_EndBug> ctxt -> memopp -> addr . mem . ea = address_mask ( ctxt , ctxt -> memopp -> addr . mem . ea + ctxt -> _eip ) ; done : return ( rc != X86EMUL_CONTINUE ) ? EMULATION_FAILED : EMULATION_OK ; }
","<S2SV_ModStart> ctxt -> rip_relative && likely ( ctxt -> memopp )
"
841,"CWE-119 static Sdb * store_versioninfo_gnu_verneed ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { ut8 * end , * need = NULL ; const char * section_name = """" ; Elf_ ( Shdr ) * link_shdr = NULL ; const char * link_section_name = """" ; Sdb * sdb_vernaux = NULL ; Sdb * sdb_version = NULL ; Sdb * sdb = NULL ; int i , cnt ; if ( ! bin || ! bin -> dynstr ) { return NULL ; } if ( shdr -> sh_link > bin -> ehdr . e_shnum ) { return NULL ; } <S2SV_StartBug> if ( shdr -> sh_size < 1 ) { <S2SV_EndBug> return NULL ; } sdb = sdb_new0 ( ) ; if ( ! sdb ) { return NULL ; } link_shdr = & bin -> shdr [ shdr -> sh_link ] ; if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) { section_name = & bin -> shstrtab [ shdr -> sh_name ] ; } if ( bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) { link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ; } if ( ! ( need = ( ut8 * ) calloc ( R_MAX ( 1 , shdr -> sh_size ) , sizeof ( ut8 ) ) ) ) { bprintf ( ""Warning:<S2SV_blank>Cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>Elf_(Verneed)\\n"" ) ; goto beach ; } end = need + shdr -> sh_size ; sdb_set ( sdb , ""section_name"" , section_name , 0 ) ; sdb_num_set ( sdb , ""num_entries"" , shdr -> sh_info , 0 ) ; sdb_num_set ( sdb , ""addr"" , shdr -> sh_addr , 0 ) ; sdb_num_set ( sdb , ""offset"" , shdr -> sh_offset , 0 ) ; sdb_num_set ( sdb , ""link"" , shdr -> sh_link , 0 ) ; sdb_set ( sdb , ""link_section_name"" , link_section_name , 0 ) ; if ( shdr -> sh_offset > bin -> size || shdr -> sh_offset + shdr -> sh_size > bin -> size ) { goto beach ; } if ( shdr -> sh_offset + shdr -> sh_size < shdr -> sh_size ) { goto beach ; } i = r_buf_read_at ( bin -> b , shdr -> sh_offset , need , shdr -> sh_size ) ; if ( i < 0 ) goto beach ; for ( i = 0 , cnt = 0 ; cnt < shdr -> sh_info ; ++ cnt ) { int j , isum ; ut8 * vstart = need + i ; Elf_ ( Verneed ) vvn = { 0 } ; if ( vstart + sizeof ( Elf_ ( Verneed ) ) > end ) { goto beach ; } Elf_ ( Verneed ) * entry = & vvn ; char key [ 32 ] = { 0 } ; sdb_version = sdb_new0 ( ) ; if ( ! sdb_version ) { goto beach ; } j = 0 ; vvn . vn_version = READ16 ( vstart , j ) vvn . vn_cnt = READ16 ( vstart , j ) vvn . vn_file = READ32 ( vstart , j ) vvn . vn_aux = READ32 ( vstart , j ) vvn . vn_next = READ32 ( vstart , j ) sdb_num_set ( sdb_version , ""vn_version"" , entry -> vn_version , 0 ) ; sdb_num_set ( sdb_version , ""idx"" , i , 0 ) ; if ( entry -> vn_file > bin -> dynstr_size ) { goto beach ; } { char * s = r_str_ndup ( & bin -> dynstr [ entry -> vn_file ] , 16 ) ; sdb_set ( sdb_version , ""file_name"" , s , 0 ) ; free ( s ) ; } sdb_num_set ( sdb_version , ""cnt"" , entry -> vn_cnt , 0 ) ; st32 vnaux = entry -> vn_aux ; if ( vnaux < 1 ) { goto beach ; } vstart += vnaux ; for ( j = 0 , isum = i + entry -> vn_aux ; j < entry -> vn_cnt && vstart + sizeof ( Elf_ ( Vernaux ) ) <= end ; ++ j ) { int k ; Elf_ ( Vernaux ) * aux = NULL ; Elf_ ( Vernaux ) vaux = { 0 } ; sdb_vernaux = sdb_new0 ( ) ; if ( ! sdb_vernaux ) { goto beach ; } aux = ( Elf_ ( Vernaux ) * ) & vaux ; k = 0 ; vaux . vna_hash = READ32 ( vstart , k ) vaux . vna_flags = READ16 ( vstart , k ) vaux . vna_other = READ16 ( vstart , k ) vaux . vna_name = READ32 ( vstart , k ) vaux . vna_next = READ32 ( vstart , k ) if ( aux -> vna_name > bin -> dynstr_size ) { goto beach ; } sdb_num_set ( sdb_vernaux , ""idx"" , isum , 0 ) ; if ( aux -> vna_name > 0 && aux -> vna_name + 8 < bin -> dynstr_size ) { char name [ 16 ] ; strncpy ( name , & bin -> dynstr [ aux -> vna_name ] , sizeof ( name ) - 1 ) ; name [ sizeof ( name ) - 1 ] = 0 ; sdb_set ( sdb_vernaux , ""name"" , name , 0 ) ; } sdb_set ( sdb_vernaux , ""flags"" , get_ver_flags ( aux -> vna_flags ) , 0 ) ; sdb_num_set ( sdb_vernaux , ""version"" , aux -> vna_other , 0 ) ; isum += aux -> vna_next ; vstart += aux -> vna_next ; snprintf ( key , sizeof ( key ) , ""vernaux%d"" , j ) ; sdb_ns_set ( sdb_version , key , sdb_vernaux ) ; } if ( ( int ) entry -> vn_next < 0 ) { bprintf ( ""Invalid<S2SV_blank>vn_next\\n"" ) ; break ; } i += entry -> vn_next ; snprintf ( key , sizeof ( key ) , ""version%d"" , cnt ) ; sdb_ns_set ( sdb , key , sdb_version ) ; if ( ! entry -> vn_next ) { break ; } } free ( need ) ; return sdb ; beach : free ( need ) ; sdb_free ( sdb_vernaux ) ; sdb_free ( sdb_version ) ; sdb_free ( sdb ) ; return NULL ; }
","<S2SV_ModStart> sh_size < 1 || shdr -> sh_size > SIZE_MAX
"
842,"CWE-119 static av_always_inline int vp78_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt , int is_vp7 ) { VP8Context * s = avctx -> priv_data ; int ret , i , referenced , num_jobs ; enum AVDiscard skip_thresh ; <S2SV_StartBug> VP8Frame * av_uninit ( curframe ) , * prev_frame ; <S2SV_EndBug> if ( is_vp7 ) ret = vp7_decode_frame_header ( s , avpkt -> data , avpkt -> size ) ; else ret = vp8_decode_frame_header ( s , avpkt -> data , avpkt -> size ) ; if ( ret < 0 ) goto err ; prev_frame = s -> framep [ VP56_FRAME_CURRENT ] ; referenced = s -> update_last || s -> update_golden == VP56_FRAME_CURRENT || s -> update_altref == VP56_FRAME_CURRENT ; skip_thresh = ! referenced ? AVDISCARD_NONREF : ! s -> keyframe ? AVDISCARD_NONKEY : AVDISCARD_ALL ; if ( avctx -> skip_frame >= skip_thresh ) { s -> invisible = 1 ; memcpy ( & s -> next_framep [ 0 ] , & s -> framep [ 0 ] , sizeof ( s -> framep [ 0 ] ) * 4 ) ; goto skip_decode ; } s -> deblock_filter = s -> filter . level && avctx -> skip_loop_filter < skip_thresh ; for ( i = 0 ; i < 5 ; i ++ ) if ( s -> frames [ i ] . tf . f -> data [ 0 ] && & s -> frames [ i ] != prev_frame && & s -> frames [ i ] != s -> framep [ VP56_FRAME_PREVIOUS ] && & s -> frames [ i ] != s -> framep [ VP56_FRAME_GOLDEN ] && & s -> frames [ i ] != s -> framep [ VP56_FRAME_GOLDEN2 ] ) vp8_release_frame ( s , & s -> frames [ i ] ) ; curframe = s -> framep [ VP56_FRAME_CURRENT ] = vp8_find_free_buffer ( s ) ; if ( ! s -> colorspace ) avctx -> colorspace = AVCOL_SPC_BT470BG ; if ( s -> fullrange ) avctx -> color_range = AVCOL_RANGE_JPEG ; else avctx -> color_range = AVCOL_RANGE_MPEG ; if ( ! s -> keyframe && ( ! s -> framep [ VP56_FRAME_PREVIOUS ] || ! s -> framep [ VP56_FRAME_GOLDEN ] || ! s -> framep [ VP56_FRAME_GOLDEN2 ] ) ) { av_log ( avctx , AV_LOG_WARNING , ""Discarding<S2SV_blank>interframe<S2SV_blank>without<S2SV_blank>a<S2SV_blank>prior<S2SV_blank>keyframe!\\n"" ) ; ret = AVERROR_INVALIDDATA ; goto err ; } curframe -> tf . f -> key_frame = s -> keyframe ; curframe -> tf . f -> pict_type = s -> keyframe ? AV_PICTURE_TYPE_I : AV_PICTURE_TYPE_P ; if ( ( ret = vp8_alloc_frame ( s , curframe , referenced ) ) < 0 ) goto err ; if ( s -> update_altref != VP56_FRAME_NONE ) s -> next_framep [ VP56_FRAME_GOLDEN2 ] = s -> framep [ s -> update_altref ] ; else s -> next_framep [ VP56_FRAME_GOLDEN2 ] = s -> framep [ VP56_FRAME_GOLDEN2 ] ; if ( s -> update_golden != VP56_FRAME_NONE ) s -> next_framep [ VP56_FRAME_GOLDEN ] = s -> framep [ s -> update_golden ] ; else s -> next_framep [ VP56_FRAME_GOLDEN ] = s -> framep [ VP56_FRAME_GOLDEN ] ; if ( s -> update_last ) s -> next_framep [ VP56_FRAME_PREVIOUS ] = curframe ; else s -> next_framep [ VP56_FRAME_PREVIOUS ] = s -> framep [ VP56_FRAME_PREVIOUS ] ; s -> next_framep [ VP56_FRAME_CURRENT ] = curframe ; if ( avctx -> codec -> update_thread_context ) ff_thread_finish_setup ( avctx ) ; s -> linesize = curframe -> tf . f -> linesize [ 0 ] ; s -> uvlinesize = curframe -> tf . f -> linesize [ 1 ] ; memset ( s -> top_nnz , 0 , s -> mb_width * sizeof ( * s -> top_nnz ) ) ; if ( ! s -> mb_layout ) memset ( s -> macroblocks + s -> mb_height * 2 - 1 , 0 , ( s -> mb_width + 1 ) * sizeof ( * s -> macroblocks ) ) ; if ( ! s -> mb_layout && s -> keyframe ) memset ( s -> intra4x4_pred_mode_top , DC_PRED , s -> mb_width * 4 ) ; memset ( s -> ref_count , 0 , sizeof ( s -> ref_count ) ) ; if ( s -> mb_layout == 1 ) { if ( prev_frame && s -> segmentation . enabled && ! s -> segmentation . update_map ) ff_thread_await_progress ( & prev_frame -> tf , 1 , 0 ) ; if ( is_vp7 ) vp7_decode_mv_mb_modes ( avctx , curframe , prev_frame ) ; else vp8_decode_mv_mb_modes ( avctx , curframe , prev_frame ) ; } if ( avctx -> active_thread_type == FF_THREAD_FRAME ) num_jobs = 1 ; else num_jobs = FFMIN ( s -> num_coeff_partitions , avctx -> thread_count ) ; s -> num_jobs = num_jobs ; s -> curframe = curframe ; s -> prev_frame = prev_frame ; s -> mv_bounds . mv_min . y = - MARGIN ; s -> mv_bounds . mv_max . y = ( ( s -> mb_height - 1 ) << 6 ) + MARGIN ; for ( i = 0 ; i < MAX_THREADS ; i ++ ) { VP8ThreadData * td = & s -> thread_data [ i ] ; atomic_init ( & td -> thread_mb_pos , 0 ) ; atomic_init ( & td -> wait_mb_pos , INT_MAX ) ; } if ( is_vp7 ) avctx -> execute2 ( avctx , vp7_decode_mb_row_sliced , s -> thread_data , NULL , num_jobs ) ; else avctx -> execute2 ( avctx , vp8_decode_mb_row_sliced , s -> thread_data , NULL , num_jobs ) ; ff_thread_report_progress ( & curframe -> tf , INT_MAX , 0 ) ; memcpy ( & s -> framep [ 0 ] , & s -> next_framep [ 0 ] , sizeof ( s -> framep [ 0 ] ) * 4 ) ; skip_decode : if ( ! s -> update_probabilities ) s -> prob [ 0 ] = s -> prob [ 1 ] ; if ( ! s -> invisible ) { if ( ( ret = av_frame_ref ( data , curframe -> tf . f ) ) < 0 ) return ret ; * got_frame = 1 ; } return avpkt -> size ; err : memcpy ( & s -> next_framep [ 0 ] , & s -> framep [ 0 ] , sizeof ( s -> framep [ 0 ] ) * 4 ) ; return ret ; }
","<S2SV_ModStart> , * prev_frame ; av_assert0 ( avctx -> pix_fmt == AV_PIX_FMT_YUVA420P || avctx -> pix_fmt == AV_PIX_FMT_YUV420P )
"
843,"CWE-119 static long vop_ioctl ( struct file * f , unsigned int cmd , unsigned long arg ) { struct vop_vdev * vdev = f -> private_data ; struct vop_info * vi = vdev -> vi ; void __user * argp = ( void __user * ) arg ; int ret ; switch ( cmd ) { case MIC_VIRTIO_ADD_DEVICE : { struct mic_device_desc dd , * dd_config ; if ( copy_from_user ( & dd , argp , sizeof ( dd ) ) ) return - EFAULT ; if ( mic_aligned_desc_size ( & dd ) > MIC_MAX_DESC_BLK_SIZE || dd . num_vq > MIC_MAX_VRINGS ) return - EINVAL ; dd_config = kzalloc ( mic_desc_size ( & dd ) , GFP_KERNEL ) ; if ( ! dd_config ) return - ENOMEM ; if ( copy_from_user ( dd_config , argp , mic_desc_size ( & dd ) ) ) { ret = - EFAULT ; goto free_ret ; } <S2SV_StartBug> mutex_lock ( & vdev -> vdev_mutex ) ; <S2SV_EndBug> mutex_lock ( & vi -> vop_mutex ) ; ret = vop_virtio_add_device ( vdev , dd_config ) ; if ( ret ) goto unlock_ret ; list_add_tail ( & vdev -> list , & vi -> vdev_list ) ; unlock_ret : mutex_unlock ( & vi -> vop_mutex ) ; mutex_unlock ( & vdev -> vdev_mutex ) ; free_ret : kfree ( dd_config ) ; return ret ; } case MIC_VIRTIO_COPY_DESC : { struct mic_copy_desc copy ; mutex_lock ( & vdev -> vdev_mutex ) ; ret = vop_vdev_inited ( vdev ) ; if ( ret ) goto _unlock_ret ; if ( copy_from_user ( & copy , argp , sizeof ( copy ) ) ) { ret = - EFAULT ; goto _unlock_ret ; } ret = vop_virtio_copy_desc ( vdev , & copy ) ; if ( ret < 0 ) goto _unlock_ret ; if ( copy_to_user ( & ( ( struct mic_copy_desc __user * ) argp ) -> out_len , & copy . out_len , sizeof ( copy . out_len ) ) ) ret = - EFAULT ; _unlock_ret : mutex_unlock ( & vdev -> vdev_mutex ) ; return ret ; } case MIC_VIRTIO_CONFIG_CHANGE : { void * buf ; mutex_lock ( & vdev -> vdev_mutex ) ; ret = vop_vdev_inited ( vdev ) ; if ( ret ) goto __unlock_ret ; buf = kzalloc ( vdev -> dd -> config_len , GFP_KERNEL ) ; if ( ! buf ) { ret = - ENOMEM ; goto __unlock_ret ; } if ( copy_from_user ( buf , argp , vdev -> dd -> config_len ) ) { ret = - EFAULT ; goto done ; } ret = vop_virtio_config_change ( vdev , buf ) ; done : kfree ( buf ) ; __unlock_ret : mutex_unlock ( & vdev -> vdev_mutex ) ; return ret ; } default : return - ENOIOCTLCMD ; } ; return 0 ; }
","<S2SV_ModStart> free_ret ; } if ( memcmp ( & dd , dd_config , sizeof ( dd ) ) ) { ret = - EINVAL ; goto free_ret ; }
"
844,"CWE-20 static void ikev2_parent_inR1outI2_continue ( struct pluto_crypto_req_cont * pcrc , struct pluto_crypto_req * r , err_t ugh ) { struct dh_continuation * dh = ( struct dh_continuation * ) pcrc ; struct msg_digest * md = dh -> md ; struct state * const st = md -> st ; stf_status e ; DBG ( DBG_CONTROLMORE , DBG_log ( ""ikev2<S2SV_blank>parent<S2SV_blank>inR1outI2:<S2SV_blank>calculating<S2SV_blank>g^{xy},<S2SV_blank>sending<S2SV_blank>I2"" ) ) ; if ( st == NULL ) { loglog ( RC_LOG_SERIOUS , ""%s:<S2SV_blank>Request<S2SV_blank>was<S2SV_blank>disconnected<S2SV_blank>from<S2SV_blank>state"" , __FUNCTION__ ) ; if ( dh -> md ) release_md ( dh -> md ) ; return ; } passert ( ugh == NULL ) ; passert ( cur_state == NULL ) ; passert ( st != NULL ) ; passert ( st -> st_suspended_md == dh -> md ) ; set_suspended ( st , NULL ) ; set_cur_state ( st ) ; st -> st_calculating = FALSE ; e = ikev2_parent_inR1outI2_tail ( pcrc , r ) ; if ( dh -> md != NULL ) { complete_v2_state_transition ( & dh -> md , e ) ; if ( dh -> md ) release_md ( dh -> md ) ; } reset_globals ( ) ; <S2SV_StartBug> passert ( GLOBALS_ARE_RESET ( ) ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ( ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
"
845,"CWE-119 static TEE_Result set_rmem_param ( const struct optee_msg_param_rmem * rmem , struct param_mem * mem ) <S2SV_StartBug> { <S2SV_EndBug> uint64_t shm_ref = READ_ONCE ( rmem -> shm_ref ) ; mem -> mobj = mobj_reg_shm_get_by_cookie ( shm_ref ) ; if ( ! mem -> mobj ) return TEE_ERROR_BAD_PARAMETERS ; mem -> offs = READ_ONCE ( rmem -> offs ) ; mem -> size = READ_ONCE ( rmem -> size ) ; <S2SV_StartBug> return TEE_SUCCESS ; <S2SV_EndBug> }
","<S2SV_ModStart> mem ) { size_t req_size = 0 ; <S2SV_ModStart> size ) ; if ( ADD_OVERFLOW ( mem -> offs , mem -> size , & req_size ) || mem -> mobj -> size < req_size ) return TEE_ERROR_SECURITY ;
"
846,"CWE-200 static int vsock_stream_recvmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk ; struct vsock_sock * vsk ; int err ; size_t target ; ssize_t copied ; long timeout ; struct vsock_transport_recv_notify_data recv_data ; DEFINE_WAIT ( wait ) ; sk = sock -> sk ; vsk = vsock_sk ( sk ) ; err = 0 ; <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> if ( sk -> sk_state != SS_CONNECTED ) { if ( sock_flag ( sk , SOCK_DONE ) ) err = 0 ; else err = - ENOTCONN ; goto out ; } if ( flags & MSG_OOB ) { err = - EOPNOTSUPP ; goto out ; } if ( sk -> sk_shutdown & RCV_SHUTDOWN ) { err = 0 ; goto out ; } if ( ! len ) { err = 0 ; goto out ; } target = sock_rcvlowat ( sk , flags & MSG_WAITALL , len ) ; if ( target >= transport -> stream_rcvhiwat ( vsk ) ) { err = - ENOMEM ; goto out ; } timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; copied = 0 ; err = transport -> notify_recv_init ( vsk , target , & recv_data ) ; if ( err < 0 ) goto out ; prepare_to_wait ( sk_sleep ( sk ) , & wait , TASK_INTERRUPTIBLE ) ; while ( 1 ) { s64 ready = vsock_stream_has_data ( vsk ) ; if ( ready < 0 ) { err = - ENOMEM ; goto out_wait ; } else if ( ready > 0 ) { ssize_t read ; err = transport -> notify_recv_pre_dequeue ( vsk , target , & recv_data ) ; if ( err < 0 ) break ; read = transport -> stream_dequeue ( vsk , msg -> msg_iov , len - copied , flags ) ; if ( read < 0 ) { err = - ENOMEM ; break ; } copied += read ; err = transport -> notify_recv_post_dequeue ( vsk , target , read , ! ( flags & MSG_PEEK ) , & recv_data ) ; if ( err < 0 ) goto out_wait ; if ( read >= target || flags & MSG_PEEK ) break ; target -= read ; } else { if ( sk -> sk_err != 0 || ( sk -> sk_shutdown & RCV_SHUTDOWN ) || ( vsk -> peer_shutdown & SEND_SHUTDOWN ) ) { break ; } if ( timeout == 0 ) { err = - EAGAIN ; break ; } err = transport -> notify_recv_pre_block ( vsk , target , & recv_data ) ; if ( err < 0 ) break ; release_sock ( sk ) ; timeout = schedule_timeout ( timeout ) ; lock_sock ( sk ) ; if ( signal_pending ( current ) ) { err = sock_intr_errno ( timeout ) ; break ; } else if ( timeout == 0 ) { err = - EAGAIN ; break ; } prepare_to_wait ( sk_sleep ( sk ) , & wait , TASK_INTERRUPTIBLE ) ; } } if ( sk -> sk_err ) err = - sk -> sk_err ; else if ( sk -> sk_shutdown & RCV_SHUTDOWN ) err = 0 ; if ( copied > 0 ) { if ( ! ( flags & MSG_PEEK ) ) { if ( vsk -> peer_shutdown & SEND_SHUTDOWN ) { if ( vsock_stream_has_data ( vsk ) <= 0 ) { sk -> sk_state = SS_UNCONNECTED ; sock_set_flag ( sk , SOCK_DONE ) ; sk -> sk_state_change ( sk ) ; } } } err = copied ; } out_wait : finish_wait ( sk_sleep ( sk ) , & wait ) ; out : release_sock ( sk ) ; return err ; }
","<S2SV_ModStart> = 0 ; msg -> msg_namelen = 0 ;
"
847,"CWE-119 static int format8BIM ( Image * ifile , Image * ofile ) { char temp [ MagickPathExtent ] ; unsigned int foundOSType ; int ID , resCount , i , c ; ssize_t count ; unsigned char * PString , * str ; resCount = 0 ; foundOSType = 0 ; ( void ) foundOSType ; c = ReadBlobByte ( ifile ) ; while ( c != EOF ) { if ( c == '8' ) { unsigned char buffer [ 5 ] ; buffer [ 0 ] = ( unsigned char ) c ; for ( i = 1 ; i < 4 ; i ++ ) { c = ReadBlobByte ( ifile ) ; if ( c == EOF ) return ( - 1 ) ; buffer [ i ] = ( unsigned char ) c ; } buffer [ 4 ] = 0 ; if ( strcmp ( ( const char * ) buffer , ""8BIM"" ) == 0 ) foundOSType = 1 ; else continue ; } else { c = ReadBlobByte ( ifile ) ; continue ; } ID = ReadBlobMSBSignedShort ( ifile ) ; if ( ID < 0 ) return ( - 1 ) ; { unsigned char plen ; c = ReadBlobByte ( ifile ) ; if ( c == EOF ) return ( - 1 ) ; plen = ( unsigned char ) c ; PString = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( plen + MagickPathExtent ) , sizeof ( * PString ) ) ; if ( PString == ( unsigned char * ) NULL ) return 0 ; for ( i = 0 ; i < plen ; i ++ ) { c = ReadBlobByte ( ifile ) ; if ( c == EOF ) { PString = ( unsigned char * ) RelinquishMagickMemory ( PString ) ; return - 1 ; } PString [ i ] = ( unsigned char ) c ; } PString [ plen ] = 0 ; if ( ( plen & 0x01 ) == 0 ) { c = ReadBlobByte ( ifile ) ; if ( c == EOF ) { PString = ( unsigned char * ) RelinquishMagickMemory ( PString ) ; return - 1 ; } } } count = ( ssize_t ) ReadBlobMSBSignedLong ( ifile ) ; if ( ( count < 0 ) || ( count > GetBlobSize ( ifile ) ) ) { PString = ( unsigned char * ) RelinquishMagickMemory ( PString ) ; return - 1 ; } <S2SV_StartBug> str = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) count , sizeof ( * str ) ) ; <S2SV_EndBug> if ( str == ( unsigned char * ) NULL ) { PString = ( unsigned char * ) RelinquishMagickMemory ( PString ) ; return 0 ; } for ( i = 0 ; i < ( ssize_t ) count ; i ++ ) { c = ReadBlobByte ( ifile ) ; if ( c == EOF ) { str = ( unsigned char * ) RelinquishMagickMemory ( str ) ; PString = ( unsigned char * ) RelinquishMagickMemory ( PString ) ; return - 1 ; } str [ i ] = ( unsigned char ) c ; } if ( ID != THUMBNAIL_ID ) { if ( strlen ( ( const char * ) PString ) > 0 ) ( void ) FormatLocaleString ( temp , MagickPathExtent , ""8BIM#%d#%s="" , ID , PString ) ; else ( void ) FormatLocaleString ( temp , MagickPathExtent , ""8BIM#%d="" , ID ) ; ( void ) WriteBlobString ( ofile , temp ) ; if ( ID == IPTC_ID ) { formatString ( ofile , ""IPTC"" , 4 ) ; formatIPTCfromBuffer ( ofile , ( char * ) str , ( ssize_t ) count ) ; } else formatString ( ofile , ( char * ) str , ( ssize_t ) count ) ; } str = ( unsigned char * ) RelinquishMagickMemory ( str ) ; PString = ( unsigned char * ) RelinquishMagickMemory ( PString ) ; resCount ++ ; c = ReadBlobByte ( ifile ) ; } return resCount ; }
","<S2SV_ModStart> size_t ) count + 1
"
848,"CWE-119 static int calc_partial_ssl_err ( YV12_BUFFER_CONFIG * source , YV12_BUFFER_CONFIG * dest ) { int i , j ; int Total = 0 ; int srcoffset , dstoffset ; unsigned char * src = source -> y_buffer ; unsigned char * dst = dest -> y_buffer ; int linestocopy ; linestocopy = ( source -> y_height >> 4 ) / PARTIAL_FRAME_FRACTION ; linestocopy = linestocopy ? linestocopy << 4 : 16 ; srcoffset = source -> y_stride * ( ( dest -> y_height >> 5 ) * 16 ) ; dstoffset = dest -> y_stride * ( ( dest -> y_height >> 5 ) * 16 ) ; src += srcoffset ; dst += dstoffset ; for ( i = 0 ; i < linestocopy ; i += 16 ) { for ( j = 0 ; j < source -> y_width ; j += 16 ) { unsigned int sse ; <S2SV_StartBug> Total += vp8_mse16x16 ( src + j , source -> y_stride , <S2SV_EndBug> dst + j , dest -> y_stride , & sse ) ; } src += 16 * source -> y_stride ; dst += 16 * dest -> y_stride ; } return Total ; }
","<S2SV_ModStart> ; Total += vpx_mse16x16 <S2SV_ModEnd> ( src +
"
849,"CWE-189 static int udf_read_inode ( struct inode * inode , bool hidden_inode ) { struct buffer_head * bh = NULL ; struct fileEntry * fe ; struct extendedFileEntry * efe ; uint16_t ident ; struct udf_inode_info * iinfo = UDF_I ( inode ) ; struct udf_sb_info * sbi = UDF_SB ( inode -> i_sb ) ; struct kernel_lb_addr * iloc = & iinfo -> i_location ; unsigned int link_count ; unsigned int indirections = 0 ; int bs = inode -> i_sb -> s_blocksize ; int ret = - EIO ; reread : if ( iloc -> logicalBlockNum >= sbi -> s_partmaps [ iloc -> partitionReferenceNum ] . s_partition_len ) { udf_debug ( ""block=%d,<S2SV_blank>partition=%d<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range\\n"" , iloc -> logicalBlockNum , iloc -> partitionReferenceNum ) ; return - EIO ; } bh = udf_read_ptagged ( inode -> i_sb , iloc , 0 , & ident ) ; if ( ! bh ) { udf_err ( inode -> i_sb , ""(ino<S2SV_blank>%ld)<S2SV_blank>failed<S2SV_blank>!bh\\n"" , inode -> i_ino ) ; return - EIO ; } if ( ident != TAG_IDENT_FE && ident != TAG_IDENT_EFE && ident != TAG_IDENT_USE ) { udf_err ( inode -> i_sb , ""(ino<S2SV_blank>%ld)<S2SV_blank>failed<S2SV_blank>ident=%d\\n"" , inode -> i_ino , ident ) ; goto out ; } fe = ( struct fileEntry * ) bh -> b_data ; efe = ( struct extendedFileEntry * ) bh -> b_data ; if ( fe -> icbTag . strategyType == cpu_to_le16 ( 4096 ) ) { struct buffer_head * ibh ; ibh = udf_read_ptagged ( inode -> i_sb , iloc , 1 , & ident ) ; if ( ident == TAG_IDENT_IE && ibh ) { struct kernel_lb_addr loc ; struct indirectEntry * ie ; ie = ( struct indirectEntry * ) ibh -> b_data ; loc = lelb_to_cpu ( ie -> indirectICB . extLocation ) ; if ( ie -> indirectICB . extLength ) { brelse ( ibh ) ; memcpy ( & iinfo -> i_location , & loc , sizeof ( struct kernel_lb_addr ) ) ; if ( ++ indirections > UDF_MAX_ICB_NESTING ) { udf_err ( inode -> i_sb , ""too<S2SV_blank>many<S2SV_blank>ICBs<S2SV_blank>in<S2SV_blank>ICB<S2SV_blank>hierarchy"" ""<S2SV_blank>(max<S2SV_blank>%d<S2SV_blank>supported)\\n"" , UDF_MAX_ICB_NESTING ) ; goto out ; } brelse ( bh ) ; goto reread ; } } brelse ( ibh ) ; } else if ( fe -> icbTag . strategyType != cpu_to_le16 ( 4 ) ) { udf_err ( inode -> i_sb , ""unsupported<S2SV_blank>strategy<S2SV_blank>type:<S2SV_blank>%d\\n"" , le16_to_cpu ( fe -> icbTag . strategyType ) ) ; goto out ; } if ( fe -> icbTag . strategyType == cpu_to_le16 ( 4 ) ) iinfo -> i_strat4096 = 0 ; else iinfo -> i_strat4096 = 1 ; iinfo -> i_alloc_type = le16_to_cpu ( fe -> icbTag . flags ) & ICBTAG_FLAG_AD_MASK ; iinfo -> i_unique = 0 ; iinfo -> i_lenEAttr = 0 ; iinfo -> i_lenExtents = 0 ; iinfo -> i_lenAlloc = 0 ; iinfo -> i_next_alloc_block = 0 ; iinfo -> i_next_alloc_goal = 0 ; if ( fe -> descTag . tagIdent == cpu_to_le16 ( TAG_IDENT_EFE ) ) { iinfo -> i_efe = 1 ; iinfo -> i_use = 0 ; ret = udf_alloc_i_data ( inode , bs - sizeof ( struct extendedFileEntry ) ) ; if ( ret ) goto out ; memcpy ( iinfo -> i_ext . i_data , bh -> b_data + sizeof ( struct extendedFileEntry ) , bs - sizeof ( struct extendedFileEntry ) ) ; } else if ( fe -> descTag . tagIdent == cpu_to_le16 ( TAG_IDENT_FE ) ) { iinfo -> i_efe = 0 ; iinfo -> i_use = 0 ; ret = udf_alloc_i_data ( inode , bs - sizeof ( struct fileEntry ) ) ; if ( ret ) goto out ; memcpy ( iinfo -> i_ext . i_data , bh -> b_data + sizeof ( struct fileEntry ) , bs - sizeof ( struct fileEntry ) ) ; } else if ( fe -> descTag . tagIdent == cpu_to_le16 ( TAG_IDENT_USE ) ) { iinfo -> i_efe = 0 ; iinfo -> i_use = 1 ; iinfo -> i_lenAlloc = le32_to_cpu ( ( ( struct unallocSpaceEntry * ) bh -> b_data ) -> lengthAllocDescs ) ; ret = udf_alloc_i_data ( inode , bs - sizeof ( struct unallocSpaceEntry ) ) ; if ( ret ) goto out ; memcpy ( iinfo -> i_ext . i_data , bh -> b_data + sizeof ( struct unallocSpaceEntry ) , bs - sizeof ( struct unallocSpaceEntry ) ) ; return 0 ; } ret = - EIO ; read_lock ( & sbi -> s_cred_lock ) ; i_uid_write ( inode , le32_to_cpu ( fe -> uid ) ) ; if ( ! uid_valid ( inode -> i_uid ) || UDF_QUERY_FLAG ( inode -> i_sb , UDF_FLAG_UID_IGNORE ) || UDF_QUERY_FLAG ( inode -> i_sb , UDF_FLAG_UID_SET ) ) inode -> i_uid = UDF_SB ( inode -> i_sb ) -> s_uid ; i_gid_write ( inode , le32_to_cpu ( fe -> gid ) ) ; if ( ! gid_valid ( inode -> i_gid ) || UDF_QUERY_FLAG ( inode -> i_sb , UDF_FLAG_GID_IGNORE ) || UDF_QUERY_FLAG ( inode -> i_sb , UDF_FLAG_GID_SET ) ) inode -> i_gid = UDF_SB ( inode -> i_sb ) -> s_gid ; if ( fe -> icbTag . fileType != ICBTAG_FILE_TYPE_DIRECTORY && sbi -> s_fmode != UDF_INVALID_MODE ) inode -> i_mode = sbi -> s_fmode ; else if ( fe -> icbTag . fileType == ICBTAG_FILE_TYPE_DIRECTORY && sbi -> s_dmode != UDF_INVALID_MODE ) inode -> i_mode = sbi -> s_dmode ; else inode -> i_mode = udf_convert_permissions ( fe ) ; inode -> i_mode &= ~ sbi -> s_umask ; read_unlock ( & sbi -> s_cred_lock ) ; link_count = le16_to_cpu ( fe -> fileLinkCount ) ; if ( ! link_count ) { if ( ! hidden_inode ) { ret = - ESTALE ; goto out ; } link_count = 1 ; } set_nlink ( inode , link_count ) ; inode -> i_size = le64_to_cpu ( fe -> informationLength ) ; iinfo -> i_lenExtents = inode -> i_size ; if ( iinfo -> i_efe == 0 ) { inode -> i_blocks = le64_to_cpu ( fe -> logicalBlocksRecorded ) << ( inode -> i_sb -> s_blocksize_bits - 9 ) ; if ( ! udf_disk_stamp_to_time ( & inode -> i_atime , fe -> accessTime ) ) inode -> i_atime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & inode -> i_mtime , fe -> modificationTime ) ) inode -> i_mtime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & inode -> i_ctime , fe -> attrTime ) ) inode -> i_ctime = sbi -> s_record_time ; iinfo -> i_unique = le64_to_cpu ( fe -> uniqueID ) ; iinfo -> i_lenEAttr = le32_to_cpu ( fe -> lengthExtendedAttr ) ; iinfo -> i_lenAlloc = le32_to_cpu ( fe -> lengthAllocDescs ) ; iinfo -> i_checkpoint = le32_to_cpu ( fe -> checkpoint ) ; } else { inode -> i_blocks = le64_to_cpu ( efe -> logicalBlocksRecorded ) << ( inode -> i_sb -> s_blocksize_bits - 9 ) ; if ( ! udf_disk_stamp_to_time ( & inode -> i_atime , efe -> accessTime ) ) inode -> i_atime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & inode -> i_mtime , efe -> modificationTime ) ) inode -> i_mtime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & iinfo -> i_crtime , efe -> createTime ) ) iinfo -> i_crtime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & inode -> i_ctime , efe -> attrTime ) ) inode -> i_ctime = sbi -> s_record_time ; iinfo -> i_unique = le64_to_cpu ( efe -> uniqueID ) ; iinfo -> i_lenEAttr = le32_to_cpu ( efe -> lengthExtendedAttr ) ; iinfo -> i_lenAlloc = le32_to_cpu ( efe -> lengthAllocDescs ) ; iinfo -> i_checkpoint = le32_to_cpu ( efe -> checkpoint ) ; } inode -> i_generation = iinfo -> i_unique ; <S2SV_StartBug> if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ) { <S2SV_EndBug> if ( iinfo -> i_lenAlloc != inode -> i_size ) goto out ; if ( inode -> i_size > bs - udf_file_entry_alloc_offset ( inode ) ) goto out ; } switch ( fe -> icbTag . fileType ) { case ICBTAG_FILE_TYPE_DIRECTORY : inode -> i_op = & udf_dir_inode_operations ; inode -> i_fop = & udf_dir_operations ; inode -> i_mode |= S_IFDIR ; inc_nlink ( inode ) ; break ; case ICBTAG_FILE_TYPE_REALTIME : case ICBTAG_FILE_TYPE_REGULAR : case ICBTAG_FILE_TYPE_UNDEF : case ICBTAG_FILE_TYPE_VAT20 : if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ) inode -> i_data . a_ops = & udf_adinicb_aops ; else inode -> i_data . a_ops = & udf_aops ; inode -> i_op = & udf_file_inode_operations ; inode -> i_fop = & udf_file_operations ; inode -> i_mode |= S_IFREG ; break ; case ICBTAG_FILE_TYPE_BLOCK : inode -> i_mode |= S_IFBLK ; break ; case ICBTAG_FILE_TYPE_CHAR : inode -> i_mode |= S_IFCHR ; break ; case ICBTAG_FILE_TYPE_FIFO : init_special_inode ( inode , inode -> i_mode | S_IFIFO , 0 ) ; break ; case ICBTAG_FILE_TYPE_SOCKET : init_special_inode ( inode , inode -> i_mode | S_IFSOCK , 0 ) ; break ; case ICBTAG_FILE_TYPE_SYMLINK : inode -> i_data . a_ops = & udf_symlink_aops ; inode -> i_op = & udf_symlink_inode_operations ; inode -> i_mode = S_IFLNK | S_IRWXUGO ; break ; case ICBTAG_FILE_TYPE_MAIN : udf_debug ( ""METADATA<S2SV_blank>FILE-----\\n"" ) ; break ; case ICBTAG_FILE_TYPE_MIRROR : udf_debug ( ""METADATA<S2SV_blank>MIRROR<S2SV_blank>FILE-----\\n"" ) ; break ; case ICBTAG_FILE_TYPE_BITMAP : udf_debug ( ""METADATA<S2SV_blank>BITMAP<S2SV_blank>FILE-----\\n"" ) ; break ; default : udf_err ( inode -> i_sb , ""(ino<S2SV_blank>%ld)<S2SV_blank>failed<S2SV_blank>unknown<S2SV_blank>file<S2SV_blank>type=%d\\n"" , inode -> i_ino , fe -> icbTag . fileType ) ; goto out ; } if ( S_ISCHR ( inode -> i_mode ) || S_ISBLK ( inode -> i_mode ) ) { struct deviceSpec * dsea = ( struct deviceSpec * ) udf_get_extendedattr ( inode , 12 , 1 ) ; if ( dsea ) { init_special_inode ( inode , inode -> i_mode , MKDEV ( le32_to_cpu ( dsea -> majorDeviceIdent ) , le32_to_cpu ( dsea -> minorDeviceIdent ) ) ) ; } else goto out ; } ret = 0 ; out : brelse ( bh ) ; return ret ; }
","<S2SV_ModStart> ( iinfo -> i_lenEAttr > bs || iinfo -> i_lenAlloc > bs ) goto out ; if ( udf_file_entry_alloc_offset ( inode ) + iinfo -> i_lenAlloc > bs ) goto out ; if ( iinfo ->
"
850,"CWE-17 static int rt_fill_info ( struct net * net , __be32 dst , __be32 src , struct flowi4 * fl4 , struct sk_buff * skb , u32 portid , u32 seq , int event , int nowait , unsigned int flags ) { struct rtable * rt = skb_rtable ( skb ) ; struct rtmsg * r ; struct nlmsghdr * nlh ; unsigned long expires = 0 ; u32 error ; u32 metrics [ RTAX_MAX ] ; nlh = nlmsg_put ( skb , portid , seq , event , sizeof ( * r ) , flags ) ; if ( nlh == NULL ) return - EMSGSIZE ; r = nlmsg_data ( nlh ) ; r -> rtm_family = AF_INET ; r -> rtm_dst_len = 32 ; r -> rtm_src_len = 0 ; r -> rtm_tos = fl4 -> flowi4_tos ; r -> rtm_table = RT_TABLE_MAIN ; if ( nla_put_u32 ( skb , RTA_TABLE , RT_TABLE_MAIN ) ) goto nla_put_failure ; r -> rtm_type = rt -> rt_type ; r -> rtm_scope = RT_SCOPE_UNIVERSE ; r -> rtm_protocol = RTPROT_UNSPEC ; r -> rtm_flags = ( rt -> rt_flags & ~ 0xFFFF ) | RTM_F_CLONED ; if ( rt -> rt_flags & RTCF_NOTIFY ) <S2SV_StartBug> r -> rtm_flags |= RTM_F_NOTIFY ; <S2SV_EndBug> if ( nla_put_be32 ( skb , RTA_DST , dst ) ) goto nla_put_failure ; if ( src ) { r -> rtm_src_len = 32 ; if ( nla_put_be32 ( skb , RTA_SRC , src ) ) goto nla_put_failure ; } if ( rt -> dst . dev && nla_put_u32 ( skb , RTA_OIF , rt -> dst . dev -> ifindex ) ) goto nla_put_failure ; # ifdef CONFIG_IP_ROUTE_CLASSID if ( rt -> dst . tclassid && nla_put_u32 ( skb , RTA_FLOW , rt -> dst . tclassid ) ) goto nla_put_failure ; # endif if ( ! rt_is_input_route ( rt ) && fl4 -> saddr != src ) { if ( nla_put_be32 ( skb , RTA_PREFSRC , fl4 -> saddr ) ) goto nla_put_failure ; } if ( rt -> rt_uses_gateway && nla_put_be32 ( skb , RTA_GATEWAY , rt -> rt_gateway ) ) goto nla_put_failure ; expires = rt -> dst . expires ; if ( expires ) { unsigned long now = jiffies ; if ( time_before ( now , expires ) ) expires -= now ; else expires = 0 ; } memcpy ( metrics , dst_metrics_ptr ( & rt -> dst ) , sizeof ( metrics ) ) ; if ( rt -> rt_pmtu && expires ) metrics [ RTAX_MTU - 1 ] = rt -> rt_pmtu ; if ( rtnetlink_put_metrics ( skb , metrics ) < 0 ) goto nla_put_failure ; if ( fl4 -> flowi4_mark && nla_put_u32 ( skb , RTA_MARK , fl4 -> flowi4_mark ) ) goto nla_put_failure ; error = rt -> dst . error ; if ( rt_is_input_route ( rt ) ) { # ifdef CONFIG_IP_MROUTE if ( ipv4_is_multicast ( dst ) && ! ipv4_is_local_multicast ( dst ) && IPV4_DEVCONF_ALL ( net , MC_FORWARDING ) ) { int err = ipmr_get_route ( net , skb , fl4 -> saddr , fl4 -> daddr , r , nowait ) ; if ( err <= 0 ) { if ( ! nowait ) { if ( err == 0 ) return 0 ; goto nla_put_failure ; } else { if ( err == - EMSGSIZE ) goto nla_put_failure ; error = err ; } } } else # endif if ( nla_put_u32 ( skb , RTA_IIF , skb -> dev -> ifindex ) ) goto nla_put_failure ; } if ( rtnl_put_cacheinfo ( skb , & rt -> dst , 0 , expires , error ) < 0 ) goto nla_put_failure ; return nlmsg_end ( skb , nlh ) ; nla_put_failure : nlmsg_cancel ( skb , nlh ) ; return - EMSGSIZE ; }
","<S2SV_ModStart> rtm_flags |= RTM_F_NOTIFY ; if ( IPCB ( skb ) -> flags & IPSKB_DOREDIRECT ) r -> rtm_flags |= RTCF_DOREDIRECT
"
851,"CWE-476 void build_ntlmssp_negotiate_blob ( unsigned char * pbuffer , struct cifs_ses * ses ) { NEGOTIATE_MESSAGE * sec_blob = ( NEGOTIATE_MESSAGE * ) pbuffer ; __u32 flags ; memset ( pbuffer , 0 , sizeof ( NEGOTIATE_MESSAGE ) ) ; memcpy ( sec_blob -> Signature , NTLMSSP_SIGNATURE , 8 ) ; sec_blob -> MessageType = NtLmNegotiate ; flags = NTLMSSP_NEGOTIATE_56 | NTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE | <S2SV_StartBug> NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC ; <S2SV_EndBug> <S2SV_StartBug> if ( ses -> server -> sign ) { <S2SV_EndBug> flags |= NTLMSSP_NEGOTIATE_SIGN ; if ( ! ses -> server -> session_estab || ses -> ntlmssp -> sesskey_per_smbsess ) flags |= NTLMSSP_NEGOTIATE_KEY_XCH ; <S2SV_StartBug> } <S2SV_EndBug> sec_blob -> NegotiateFlags = cpu_to_le32 ( flags ) ; sec_blob -> WorkstationName . BufferOffset = 0 ; sec_blob -> WorkstationName . Length = 0 ; sec_blob -> WorkstationName . MaximumLength = 0 ; sec_blob -> DomainName . BufferOffset = 0 ; sec_blob -> DomainName . Length = 0 ; sec_blob -> DomainName . MaximumLength = 0 ; }
","<S2SV_ModStart> NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC | NTLMSSP_NEGOTIATE_SEAL <S2SV_ModStart> -> sign ) <S2SV_ModEnd> flags |= NTLMSSP_NEGOTIATE_SIGN <S2SV_ModStart> |= NTLMSSP_NEGOTIATE_KEY_XCH ; <S2SV_ModEnd> sec_blob -> NegotiateFlags
"
852,"CWE-200 static int recv_stream ( struct kiocb * iocb , struct socket * sock , struct msghdr * m , size_t buf_len , int flags ) { struct sock * sk = sock -> sk ; struct tipc_port * tport = tipc_sk_port ( sk ) ; struct sk_buff * buf ; struct tipc_msg * msg ; long timeout ; unsigned int sz ; int sz_to_copy , target , needed ; int sz_copied = 0 ; u32 err ; int res = 0 ; if ( unlikely ( ! buf_len ) ) return - EINVAL ; lock_sock ( sk ) ; if ( unlikely ( ( sock -> state == SS_UNCONNECTED ) || ( sock -> state == SS_CONNECTING ) ) ) { res = - ENOTCONN ; goto exit ; <S2SV_StartBug> } <S2SV_EndBug> target = sock_rcvlowat ( sk , flags & MSG_WAITALL , buf_len ) ; timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; restart : while ( skb_queue_empty ( & sk -> sk_receive_queue ) ) { if ( sock -> state == SS_DISCONNECTING ) { res = - ENOTCONN ; goto exit ; } if ( timeout <= 0L ) { res = timeout ? timeout : - EWOULDBLOCK ; goto exit ; } release_sock ( sk ) ; timeout = wait_event_interruptible_timeout ( * sk_sleep ( sk ) , tipc_rx_ready ( sock ) , timeout ) ; lock_sock ( sk ) ; } buf = skb_peek ( & sk -> sk_receive_queue ) ; msg = buf_msg ( buf ) ; sz = msg_data_sz ( msg ) ; err = msg_errcode ( msg ) ; if ( ( ! sz ) && ( ! err ) ) { advance_rx_queue ( sk ) ; goto restart ; } if ( sz_copied == 0 ) { set_orig_addr ( m , msg ) ; res = anc_data_recv ( m , msg , tport ) ; if ( res ) goto exit ; } if ( ! err ) { u32 offset = ( u32 ) ( unsigned long ) ( TIPC_SKB_CB ( buf ) -> handle ) ; sz -= offset ; needed = ( buf_len - sz_copied ) ; sz_to_copy = ( sz <= needed ) ? sz : needed ; res = skb_copy_datagram_iovec ( buf , msg_hdr_sz ( msg ) + offset , m -> msg_iov , sz_to_copy ) ; if ( res ) goto exit ; sz_copied += sz_to_copy ; if ( sz_to_copy < sz ) { if ( ! ( flags & MSG_PEEK ) ) TIPC_SKB_CB ( buf ) -> handle = ( void * ) ( unsigned long ) ( offset + sz_to_copy ) ; goto exit ; } } else { if ( sz_copied != 0 ) goto exit ; if ( ( err == TIPC_CONN_SHUTDOWN ) || m -> msg_control ) res = 0 ; else res = - ECONNRESET ; } if ( likely ( ! ( flags & MSG_PEEK ) ) ) { if ( unlikely ( ++ tport -> conn_unacked >= TIPC_FLOW_CONTROL_WIN ) ) tipc_acknowledge ( tport -> ref , tport -> conn_unacked ) ; advance_rx_queue ( sk ) ; } if ( ( sz_copied < buf_len ) && ( ! skb_queue_empty ( & sk -> sk_receive_queue ) || ( sz_copied < target ) ) && ( ! ( flags & MSG_PEEK ) ) && ( ! err ) ) goto restart ; exit : release_sock ( sk ) ; return sz_copied ? sz_copied : res ; }
","<S2SV_ModStart> exit ; } m -> msg_namelen = 0 ;
"
853,"CWE-189 void * ipc_rcu_alloc ( int size ) { void * out ; if ( rcu_use_vmalloc ( size ) ) { out = vmalloc ( HDRLEN_VMALLOC + size ) ; <S2SV_StartBug> if ( out ) { <S2SV_EndBug> out += HDRLEN_VMALLOC ; container_of ( out , struct ipc_rcu_hdr , data ) -> is_vmalloc = 1 ; <S2SV_StartBug> container_of ( out , struct ipc_rcu_hdr , data ) -> refcount = 1 ; <S2SV_EndBug> } } else { out = kmalloc ( HDRLEN_KMALLOC + size , GFP_KERNEL ) ; <S2SV_StartBug> if ( out ) { <S2SV_EndBug> out += HDRLEN_KMALLOC ; container_of ( out , struct ipc_rcu_hdr , data ) -> is_vmalloc = 0 ; <S2SV_StartBug> container_of ( out , struct ipc_rcu_hdr , data ) -> refcount = 1 ; <S2SV_EndBug> } } return out ; }
","<S2SV_ModStart> ; if ( ! out ) goto done ; <S2SV_ModEnd> out += HDRLEN_VMALLOC <S2SV_ModStart> = 1 ; <S2SV_ModEnd> } else { <S2SV_ModStart> ; if ( ! out ) goto done ; <S2SV_ModEnd> out += HDRLEN_KMALLOC <S2SV_ModStart> = 0 ; } atomic_set ( & <S2SV_ModStart> ) -> refcount , 1 ) ; done : <S2SV_ModEnd> return out ;
"
854,"CWE-119 static inline int ip6_ufo_append_data ( struct sock * sk , int getfrag ( void * from , char * to , int offset , int len , int odd , struct sk_buff * skb ) , void * from , int length , int hh_len , int fragheaderlen , int transhdrlen , int mtu , unsigned int flags , struct rt6_info * rt ) { struct sk_buff * skb ; int err ; if ( ( skb = skb_peek_tail ( & sk -> sk_write_queue ) ) == NULL ) { <S2SV_StartBug> skb = sock_alloc_send_skb ( sk , <S2SV_EndBug> hh_len + fragheaderlen + transhdrlen + 20 , ( flags & MSG_DONTWAIT ) , & err ) ; if ( skb == NULL ) return err ; skb_reserve ( skb , hh_len ) ; skb_put ( skb , fragheaderlen + transhdrlen ) ; skb_reset_network_header ( skb ) ; skb -> transport_header = skb -> network_header + fragheaderlen ; skb -> protocol = htons ( ETH_P_IPV6 ) ; skb -> ip_summed = CHECKSUM_PARTIAL ; <S2SV_StartBug> skb -> csum = 0 ; <S2SV_EndBug> } err = skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) ; if ( ! err ) { struct frag_hdr fhdr ; skb_shinfo ( skb ) -> gso_size = ( mtu - fragheaderlen - sizeof ( struct frag_hdr ) ) & ~ 7 ; skb_shinfo ( skb ) -> gso_type = SKB_GSO_UDP ; ipv6_select_ident ( & fhdr , rt ) ; skb_shinfo ( skb ) -> ip6_frag_id = fhdr . identification ; __skb_queue_tail ( & sk -> sk_write_queue , skb ) ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> } kfree_skb ( skb ) ; return err ; }
","<S2SV_ModStart> NULL ) { struct frag_hdr fhdr ; <S2SV_ModStart> csum = 0 <S2SV_ModEnd> ; skb_shinfo ( <S2SV_ModStart> skb ) ; } return skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) <S2SV_ModEnd> ; } <S2SV_null>
"
855,"CWE-125 <S2SV_StartBug> void ntlm_write_message_header ( wStream * s , NTLM_MESSAGE_HEADER * header ) <S2SV_EndBug> { Stream_Write ( s , header -> Signature , sizeof ( NTLM_SIGNATURE ) ) ; Stream_Write_UINT32 ( s , header -> MessageType ) ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
"
856,"CWE-000 static void sas_unregister_devs_sas_addr ( struct domain_device * parent , int phy_id , bool last ) { struct expander_device * ex_dev = & parent -> ex_dev ; struct ex_phy * phy = & ex_dev -> ex_phy [ phy_id ] ; struct domain_device * child , * n , * found = NULL ; if ( last ) { list_for_each_entry_safe ( child , n , & ex_dev -> children , siblings ) { if ( SAS_ADDR ( child -> sas_addr ) == SAS_ADDR ( phy -> attached_sas_addr ) ) { set_bit ( SAS_DEV_GONE , & child -> state ) ; if ( child -> dev_type == SAS_EDGE_EXPANDER_DEVICE || child -> dev_type == SAS_FANOUT_EXPANDER_DEVICE ) sas_unregister_ex_tree ( parent -> port , child ) ; else sas_unregister_dev ( parent -> port , child ) ; found = child ; break ; } } sas_disable_routing ( parent , phy -> attached_sas_addr ) ; } memset ( phy -> attached_sas_addr , 0 , SAS_ADDR_SIZE ) ; if ( phy -> port ) { sas_port_delete_phy ( phy -> port , phy -> phy ) ; sas_device_set_phy ( found , phy -> port ) ; if ( phy -> port -> num_phys == 0 ) <S2SV_StartBug> sas_port_delete ( phy -> port ) ; <S2SV_EndBug> phy -> port = NULL ; } }
","<S2SV_ModStart> == 0 ) list_add_tail ( & phy -> port -> del_list , & parent -> port -> sas_port_del_list <S2SV_ModEnd> ) ; phy
"
857,"CWE-326 void flash_option_bytes_init ( int boot_from_dfu ) { uint32_t val = 0xfffff8aa ; if ( boot_from_dfu ) { val &= ~ ( 1 << 27 ) ; } else { if ( solo_is_locked ( ) ) { val = 0xfffff8cc ; } } val &= ~ ( 1 << 26 ) ; val &= ~ ( 1 << 25 ) ; val &= ~ ( 1 << 24 ) ; if ( FLASH -> OPTR == val ) { return ; } __disable_irq ( ) ; while ( FLASH -> SR & ( 1 << 16 ) ) ; flash_unlock ( ) ; if ( FLASH -> CR & ( 1 << 30 ) ) { FLASH -> OPTKEYR = 0x08192A3B ; FLASH -> OPTKEYR = 0x4C5D6E7F ; } FLASH -> OPTR = val ; FLASH -> CR |= ( 1 << 17 ) ; while ( FLASH -> SR & ( 1 << 16 ) ) ; flash_lock ( ) ; <S2SV_StartBug> __enable_irq ( ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ( ) ; FLASH -> CR |= FLASH_CR_OBL_LAUNCH ; while ( true <S2SV_ModEnd> ) ; }
"
858,"CWE-190 static int PyMemoTable_Set ( PyMemoTable * self , PyObject * key , Py_ssize_t value ) { PyMemoEntry * entry ; assert ( key != NULL ) ; entry = _PyMemoTable_Lookup ( self , key ) ; if ( entry -> me_key != NULL ) { entry -> me_value = value ; return 0 ; } Py_INCREF ( key ) ; entry -> me_key = key ; entry -> me_value = value ; self -> mt_used ++ ; <S2SV_StartBug> if ( ! ( self -> mt_used * 3 >= ( self -> mt_mask + 1 ) * 2 ) ) <S2SV_EndBug> return 0 ; <S2SV_StartBug> return _PyMemoTable_ResizeTable ( self , <S2SV_EndBug> <S2SV_StartBug> ( self -> mt_used > 50000 ? 2 : 4 ) * self -> mt_used ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ; if ( SIZE_MAX / 3 >= self -> mt_used && <S2SV_ModEnd> self -> mt_used <S2SV_ModStart> mt_used * 3 < self -> mt_allocated <S2SV_ModEnd> * 2 ) <S2SV_ModStart> * 2 ) { <S2SV_ModEnd> return 0 ; <S2SV_ModStart> return 0 ; } size_t desired_size = <S2SV_ModEnd> ( self -> <S2SV_ModStart> self -> mt_used ; return _PyMemoTable_ResizeTable ( self , desired_size
"
859,"CWE-401 static int acp_hw_init ( void * handle ) { int r , i ; uint64_t acp_base ; u32 val = 0 ; u32 count = 0 ; struct device * dev ; <S2SV_StartBug> struct i2s_platform_data * i2s_pdata ; <S2SV_EndBug> struct amdgpu_device * adev = ( struct amdgpu_device * ) handle ; const struct amdgpu_ip_block * ip_block = amdgpu_device_ip_get_ip_block ( adev , AMD_IP_BLOCK_TYPE_ACP ) ; if ( ! ip_block ) return - EINVAL ; r = amd_acp_hw_init ( adev -> acp . cgs_device , ip_block -> version -> major , ip_block -> version -> minor ) ; if ( r == - ENODEV ) { amdgpu_dpm_set_powergating_by_smu ( adev , AMD_IP_BLOCK_TYPE_ACP , true ) ; return 0 ; } else if ( r ) { return r ; } if ( adev -> rmmio_size == 0 || adev -> rmmio_size < 0x5289 ) return - EINVAL ; acp_base = adev -> rmmio_base ; adev -> acp . acp_genpd = kzalloc ( sizeof ( struct acp_pm_domain ) , GFP_KERNEL ) ; if ( adev -> acp . acp_genpd == NULL ) return - ENOMEM ; adev -> acp . acp_genpd -> gpd . name = ""ACP_AUDIO"" ; adev -> acp . acp_genpd -> gpd . power_off = acp_poweroff ; adev -> acp . acp_genpd -> gpd . power_on = acp_poweron ; adev -> acp . acp_genpd -> adev = adev ; pm_genpd_init ( & adev -> acp . acp_genpd -> gpd , NULL , false ) ; adev -> acp . acp_cell = kcalloc ( ACP_DEVS , sizeof ( struct mfd_cell ) , GFP_KERNEL ) ; if ( adev -> acp . acp_cell == NULL ) <S2SV_StartBug> return - ENOMEM ; <S2SV_EndBug> <S2SV_StartBug> adev -> acp . acp_res = kcalloc ( 5 , sizeof ( struct resource ) , GFP_KERNEL ) ; <S2SV_EndBug> if ( adev -> acp . acp_res == NULL ) { <S2SV_StartBug> kfree ( adev -> acp . acp_cell ) ; <S2SV_EndBug> return - ENOMEM ; <S2SV_StartBug> } <S2SV_EndBug> i2s_pdata = kcalloc ( 3 , sizeof ( struct i2s_platform_data ) , GFP_KERNEL ) ; if ( i2s_pdata == NULL ) { <S2SV_StartBug> kfree ( adev -> acp . acp_res ) ; <S2SV_EndBug> kfree ( adev -> acp . acp_cell ) ; return - ENOMEM ; } switch ( adev -> asic_type ) { case CHIP_STONEY : i2s_pdata [ 0 ] . quirks = DW_I2S_QUIRK_COMP_REG_OFFSET | DW_I2S_QUIRK_16BIT_IDX_OVERRIDE ; break ; default : i2s_pdata [ 0 ] . quirks = DW_I2S_QUIRK_COMP_REG_OFFSET ; } i2s_pdata [ 0 ] . cap = DWC_I2S_PLAY ; i2s_pdata [ 0 ] . snd_rates = SNDRV_PCM_RATE_8000_96000 ; i2s_pdata [ 0 ] . i2s_reg_comp1 = ACP_I2S_COMP1_PLAY_REG_OFFSET ; i2s_pdata [ 0 ] . i2s_reg_comp2 = ACP_I2S_COMP2_PLAY_REG_OFFSET ; switch ( adev -> asic_type ) { case CHIP_STONEY : i2s_pdata [ 1 ] . quirks = DW_I2S_QUIRK_COMP_REG_OFFSET | DW_I2S_QUIRK_COMP_PARAM1 | DW_I2S_QUIRK_16BIT_IDX_OVERRIDE ; break ; default : i2s_pdata [ 1 ] . quirks = DW_I2S_QUIRK_COMP_REG_OFFSET | DW_I2S_QUIRK_COMP_PARAM1 ; } i2s_pdata [ 1 ] . cap = DWC_I2S_RECORD ; i2s_pdata [ 1 ] . snd_rates = SNDRV_PCM_RATE_8000_96000 ; i2s_pdata [ 1 ] . i2s_reg_comp1 = ACP_I2S_COMP1_CAP_REG_OFFSET ; i2s_pdata [ 1 ] . i2s_reg_comp2 = ACP_I2S_COMP2_CAP_REG_OFFSET ; i2s_pdata [ 2 ] . quirks = DW_I2S_QUIRK_COMP_REG_OFFSET ; switch ( adev -> asic_type ) { case CHIP_STONEY : i2s_pdata [ 2 ] . quirks |= DW_I2S_QUIRK_16BIT_IDX_OVERRIDE ; break ; default : break ; } i2s_pdata [ 2 ] . cap = DWC_I2S_PLAY | DWC_I2S_RECORD ; i2s_pdata [ 2 ] . snd_rates = SNDRV_PCM_RATE_8000_96000 ; i2s_pdata [ 2 ] . i2s_reg_comp1 = ACP_BT_COMP1_REG_OFFSET ; i2s_pdata [ 2 ] . i2s_reg_comp2 = ACP_BT_COMP2_REG_OFFSET ; adev -> acp . acp_res [ 0 ] . name = ""acp2x_dma"" ; adev -> acp . acp_res [ 0 ] . flags = IORESOURCE_MEM ; adev -> acp . acp_res [ 0 ] . start = acp_base ; adev -> acp . acp_res [ 0 ] . end = acp_base + ACP_DMA_REGS_END ; adev -> acp . acp_res [ 1 ] . name = ""acp2x_dw_i2s_play"" ; adev -> acp . acp_res [ 1 ] . flags = IORESOURCE_MEM ; adev -> acp . acp_res [ 1 ] . start = acp_base + ACP_I2S_PLAY_REGS_START ; adev -> acp . acp_res [ 1 ] . end = acp_base + ACP_I2S_PLAY_REGS_END ; adev -> acp . acp_res [ 2 ] . name = ""acp2x_dw_i2s_cap"" ; adev -> acp . acp_res [ 2 ] . flags = IORESOURCE_MEM ; adev -> acp . acp_res [ 2 ] . start = acp_base + ACP_I2S_CAP_REGS_START ; adev -> acp . acp_res [ 2 ] . end = acp_base + ACP_I2S_CAP_REGS_END ; adev -> acp . acp_res [ 3 ] . name = ""acp2x_dw_bt_i2s_play_cap"" ; adev -> acp . acp_res [ 3 ] . flags = IORESOURCE_MEM ; adev -> acp . acp_res [ 3 ] . start = acp_base + ACP_BT_PLAY_REGS_START ; adev -> acp . acp_res [ 3 ] . end = acp_base + ACP_BT_PLAY_REGS_END ; adev -> acp . acp_res [ 4 ] . name = ""acp2x_dma_irq"" ; adev -> acp . acp_res [ 4 ] . flags = IORESOURCE_IRQ ; adev -> acp . acp_res [ 4 ] . start = amdgpu_irq_create_mapping ( adev , 162 ) ; adev -> acp . acp_res [ 4 ] . end = adev -> acp . acp_res [ 4 ] . start ; adev -> acp . acp_cell [ 0 ] . name = ""acp_audio_dma"" ; adev -> acp . acp_cell [ 0 ] . num_resources = 5 ; adev -> acp . acp_cell [ 0 ] . resources = & adev -> acp . acp_res [ 0 ] ; adev -> acp . acp_cell [ 0 ] . platform_data = & adev -> asic_type ; adev -> acp . acp_cell [ 0 ] . pdata_size = sizeof ( adev -> asic_type ) ; adev -> acp . acp_cell [ 1 ] . name = ""designware-i2s"" ; adev -> acp . acp_cell [ 1 ] . num_resources = 1 ; adev -> acp . acp_cell [ 1 ] . resources = & adev -> acp . acp_res [ 1 ] ; adev -> acp . acp_cell [ 1 ] . platform_data = & i2s_pdata [ 0 ] ; adev -> acp . acp_cell [ 1 ] . pdata_size = sizeof ( struct i2s_platform_data ) ; adev -> acp . acp_cell [ 2 ] . name = ""designware-i2s"" ; adev -> acp . acp_cell [ 2 ] . num_resources = 1 ; adev -> acp . acp_cell [ 2 ] . resources = & adev -> acp . acp_res [ 2 ] ; adev -> acp . acp_cell [ 2 ] . platform_data = & i2s_pdata [ 1 ] ; adev -> acp . acp_cell [ 2 ] . pdata_size = sizeof ( struct i2s_platform_data ) ; adev -> acp . acp_cell [ 3 ] . name = ""designware-i2s"" ; adev -> acp . acp_cell [ 3 ] . num_resources = 1 ; adev -> acp . acp_cell [ 3 ] . resources = & adev -> acp . acp_res [ 3 ] ; adev -> acp . acp_cell [ 3 ] . platform_data = & i2s_pdata [ 2 ] ; adev -> acp . acp_cell [ 3 ] . pdata_size = sizeof ( struct i2s_platform_data ) ; r = mfd_add_hotplug_devices ( adev -> acp . parent , adev -> acp . acp_cell , ACP_DEVS ) ; if ( r ) <S2SV_StartBug> return r ; <S2SV_EndBug> for ( i = 0 ; i < ACP_DEVS ; i ++ ) { dev = get_mfd_cell_dev ( adev -> acp . acp_cell [ i ] . name , i ) ; r = pm_genpd_add_device ( & adev -> acp . acp_genpd -> gpd , dev ) ; if ( r ) { dev_err ( dev , ""Failed<S2SV_blank>to<S2SV_blank>add<S2SV_blank>dev<S2SV_blank>to<S2SV_blank>genpd\\n"" ) ; <S2SV_StartBug> return r ; <S2SV_EndBug> } } val = cgs_read_register ( adev -> acp . cgs_device , mmACP_SOFT_RESET ) ; val |= ACP_SOFT_RESET__SoftResetAud_MASK ; cgs_write_register ( adev -> acp . cgs_device , mmACP_SOFT_RESET , val ) ; count = ACP_SOFT_RESET_DONE_TIME_OUT_VALUE ; while ( true ) { val = cgs_read_register ( adev -> acp . cgs_device , mmACP_SOFT_RESET ) ; if ( ACP_SOFT_RESET__SoftResetAudDone_MASK == ( val & ACP_SOFT_RESET__SoftResetAudDone_MASK ) ) break ; if ( -- count == 0 ) { dev_err ( & adev -> pdev -> dev , ""Failed<S2SV_blank>to<S2SV_blank>reset<S2SV_blank>ACP\\n"" ) ; <S2SV_StartBug> return - ETIMEDOUT ; <S2SV_EndBug> } udelay ( 100 ) ; } val = cgs_read_register ( adev -> acp . cgs_device , mmACP_CONTROL ) ; val = val | ACP_CONTROL__ClkEn_MASK ; cgs_write_register ( adev -> acp . cgs_device , mmACP_CONTROL , val ) ; count = ACP_CLOCK_EN_TIME_OUT_VALUE ; while ( true ) { val = cgs_read_register ( adev -> acp . cgs_device , mmACP_STATUS ) ; if ( val & ( u32 ) 0x1 ) break ; if ( -- count == 0 ) { dev_err ( & adev -> pdev -> dev , ""Failed<S2SV_blank>to<S2SV_blank>reset<S2SV_blank>ACP\\n"" ) ; <S2SV_StartBug> return - ETIMEDOUT ; <S2SV_EndBug> } udelay ( 100 ) ; } val = cgs_read_register ( adev -> acp . cgs_device , mmACP_SOFT_RESET ) ; val &= ~ ACP_SOFT_RESET__SoftResetAud_MASK ; cgs_write_register ( adev -> acp . cgs_device , mmACP_SOFT_RESET , val ) ; return 0 ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> i2s_platform_data * i2s_pdata = NULL <S2SV_ModStart> == NULL ) { r = <S2SV_ModEnd> - ENOMEM ; <S2SV_ModStart> - ENOMEM ; goto failure ; } <S2SV_ModStart> NULL ) { r = <S2SV_ModEnd> - ENOMEM ; <S2SV_ModStart> - ENOMEM ; goto failure ; <S2SV_ModStart> NULL ) { r = - ENOMEM ; goto failure <S2SV_ModEnd> ; } switch <S2SV_ModStart> ( r ) goto failure <S2SV_ModEnd> ; for ( <S2SV_ModStart> ""Failed<S2SV_blank>to<S2SV_blank>add<S2SV_blank>dev<S2SV_blank>to<S2SV_blank>genpd\\n"" ) ; goto failure <S2SV_ModEnd> ; } } <S2SV_ModStart> ""Failed<S2SV_blank>to<S2SV_blank>reset<S2SV_blank>ACP\\n"" ) ; r = - ETIMEDOUT ; goto failure <S2SV_ModEnd> ; } udelay <S2SV_ModStart> ""Failed<S2SV_blank>to<S2SV_blank>reset<S2SV_blank>ACP\\n"" ) ; r = - ETIMEDOUT ; goto failure <S2SV_ModEnd> ; } udelay <S2SV_ModStart> return 0 ; failure : kfree ( i2s_pdata ) ; kfree ( adev -> acp . acp_res ) ; kfree ( adev -> acp . acp_cell ) ; kfree ( adev -> acp . acp_genpd ) ; return r ;
"
860,"CWE-119 <S2SV_StartBug> void vp9_idct16x16_add ( const int16_t * input , uint8_t * dest , int stride , <S2SV_EndBug> int eob ) { if ( eob == 1 ) <S2SV_StartBug> vp9_idct16x16_1_add ( input , dest , stride ) ; <S2SV_EndBug> else if ( eob <= 10 ) <S2SV_StartBug> vp9_idct16x16_10_add ( input , dest , stride ) ; <S2SV_EndBug> else <S2SV_StartBug> vp9_idct16x16_256_add ( input , dest , stride ) ; <S2SV_EndBug> }
","<S2SV_ModStart> vp9_idct16x16_add ( const tran_low_t <S2SV_ModEnd> * input , <S2SV_ModStart> == 1 ) vpx_idct16x16_1_add <S2SV_ModEnd> ( input , <S2SV_ModStart> <= 10 ) vpx_idct16x16_10_add <S2SV_ModEnd> ( input , <S2SV_ModStart> ) ; else vpx_idct16x16_256_add <S2SV_ModEnd> ( input ,
"
861,"CWE-119 int ParseRiffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int is_rf64 = ! strncmp ( fourcc , ""RF64"" , 4 ) , got_ds64 = 0 ; int64_t total_samples = 0 , infilesize ; RiffChunkHeader riff_chunk_header ; ChunkHeader chunk_header ; WaveHeader WaveHeader ; DS64Chunk ds64_chunk ; uint32_t bcount ; CLEAR ( WaveHeader ) ; CLEAR ( ds64_chunk ) ; infilesize = DoGetFileSize ( infile ) ; if ( ! is_rf64 && infilesize >= 4294967296LL && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) ) { error_line ( ""can\'t<S2SV_blank>handle<S2SV_blank>.WAV<S2SV_blank>files<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>4<S2SV_blank>GB<S2SV_blank>(non-standard)!"" ) ; return WAVPACK_SOFT_ERROR ; } memcpy ( & riff_chunk_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & riff_chunk_header ) + 4 , sizeof ( RiffChunkHeader ) - 4 , & bcount ) || bcount != sizeof ( RiffChunkHeader ) - 4 || strncmp ( riff_chunk_header . formType , ""WAVE"" , 4 ) ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & riff_chunk_header , sizeof ( RiffChunkHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } while ( 1 ) { if ( ! DoReadFile ( infile , & chunk_header , sizeof ( ChunkHeader ) , & bcount ) || bcount != sizeof ( ChunkHeader ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & chunk_header , sizeof ( ChunkHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackLittleEndianToNative ( & chunk_header , ChunkHeaderFormat ) ; if ( ! strncmp ( chunk_header . ckID , ""ds64"" , 4 ) ) { if ( chunk_header . ckSize < sizeof ( DS64Chunk ) || <S2SV_StartBug> ! DoReadFile ( infile , & ds64_chunk , chunk_header . ckSize , & bcount ) || <S2SV_EndBug> <S2SV_StartBug> bcount != chunk_header . ckSize ) { <S2SV_EndBug> error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && <S2SV_StartBug> ! WavpackAddWrapper ( wpc , & ds64_chunk , chunk_header . ckSize ) ) { <S2SV_EndBug> error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } got_ds64 = 1 ; WavpackLittleEndianToNative ( & ds64_chunk , DS64ChunkFormat ) ; if ( debug_logging_mode ) error_line ( ""DS64:<S2SV_blank>riffSize<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>dataSize<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>sampleCount<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>table_length<S2SV_blank>=<S2SV_blank>%d"" , ( long long ) ds64_chunk . riffSize64 , ( long long ) ds64_chunk . dataSize64 , ( long long ) ds64_chunk . sampleCount64 , ds64_chunk . tableLength ) ; if ( ds64_chunk . tableLength * sizeof ( CS64Chunk ) != chunk_header . ckSize - sizeof ( DS64Chunk ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } while ( ds64_chunk . tableLength -- ) { CS64Chunk cs64_chunk ; if ( ! DoReadFile ( infile , & cs64_chunk , sizeof ( CS64Chunk ) , & bcount ) || bcount != sizeof ( CS64Chunk ) || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & cs64_chunk , sizeof ( CS64Chunk ) ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } } } else if ( ! strncmp ( chunk_header . ckID , ""fmt<S2SV_blank>"" , 4 ) ) { int supported = TRUE , format ; if ( chunk_header . ckSize < 16 || chunk_header . ckSize > sizeof ( WaveHeader ) || ! DoReadFile ( infile , & WaveHeader , chunk_header . ckSize , & bcount ) || bcount != chunk_header . ckSize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & WaveHeader , chunk_header . ckSize ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackLittleEndianToNative ( & WaveHeader , WaveHeaderFormat ) ; if ( debug_logging_mode ) { error_line ( ""format<S2SV_blank>tag<S2SV_blank>size<S2SV_blank>=<S2SV_blank>%d"" , chunk_header . ckSize ) ; error_line ( ""FormatTag<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>NumChannels<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>BitsPerSample<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . FormatTag , WaveHeader . NumChannels , WaveHeader . BitsPerSample ) ; error_line ( ""BlockAlign<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>SampleRate<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>BytesPerSecond<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . BlockAlign , WaveHeader . SampleRate , WaveHeader . BytesPerSecond ) ; if ( chunk_header . ckSize > 16 ) error_line ( ""cbSize<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>ValidBitsPerSample<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . cbSize , WaveHeader . ValidBitsPerSample ) ; if ( chunk_header . ckSize > 20 ) error_line ( ""ChannelMask<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>SubFormat<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . ChannelMask , WaveHeader . SubFormat ) ; } if ( chunk_header . ckSize > 16 && WaveHeader . cbSize == 2 ) config -> qmode |= QMODE_ADOBE_MODE ; format = ( WaveHeader . FormatTag == 0xfffe && chunk_header . ckSize == 40 ) ? WaveHeader . SubFormat : WaveHeader . FormatTag ; config -> bits_per_sample = ( chunk_header . ckSize == 40 && WaveHeader . ValidBitsPerSample ) ? WaveHeader . ValidBitsPerSample : WaveHeader . BitsPerSample ; if ( format != 1 && format != 3 ) supported = FALSE ; if ( format == 3 && config -> bits_per_sample != 32 ) supported = FALSE ; if ( ! WaveHeader . NumChannels || WaveHeader . NumChannels > 256 || WaveHeader . BlockAlign / WaveHeader . NumChannels < ( config -> bits_per_sample + 7 ) / 8 || WaveHeader . BlockAlign / WaveHeader . NumChannels > 4 || WaveHeader . BlockAlign % WaveHeader . NumChannels ) supported = FALSE ; if ( config -> bits_per_sample < 1 || config -> bits_per_sample > 32 ) supported = FALSE ; if ( ! supported ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>an<S2SV_blank>unsupported<S2SV_blank>.WAV<S2SV_blank>format!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( chunk_header . ckSize < 40 ) { if ( ! config -> channel_mask && ! ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) { if ( WaveHeader . NumChannels <= 2 ) config -> channel_mask = 0x5 - WaveHeader . NumChannels ; else if ( WaveHeader . NumChannels <= 18 ) config -> channel_mask = ( 1 << WaveHeader . NumChannels ) - 1 ; else config -> channel_mask = 0x3ffff ; } } else if ( WaveHeader . ChannelMask && ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) ) { error_line ( ""this<S2SV_blank>WAV<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!"" ) ; return WAVPACK_SOFT_ERROR ; } else if ( WaveHeader . ChannelMask ) config -> channel_mask = WaveHeader . ChannelMask ; if ( format == 3 ) config -> float_norm_exp = 127 ; else if ( ( config -> qmode & QMODE_ADOBE_MODE ) && WaveHeader . BlockAlign / WaveHeader . NumChannels == 4 ) { if ( WaveHeader . BitsPerSample == 24 ) config -> float_norm_exp = 127 + 23 ; else if ( WaveHeader . BitsPerSample == 32 ) config -> float_norm_exp = 127 + 15 ; } if ( debug_logging_mode ) { if ( config -> float_norm_exp == 127 ) error_line ( ""data<S2SV_blank>format:<S2SV_blank>normalized<S2SV_blank>32-bit<S2SV_blank>floating<S2SV_blank>point"" ) ; else if ( config -> float_norm_exp ) error_line ( ""data<S2SV_blank>format:<S2SV_blank>32-bit<S2SV_blank>floating<S2SV_blank>point<S2SV_blank>(Audition<S2SV_blank>%d:%d<S2SV_blank>float<S2SV_blank>type<S2SV_blank>1)"" , config -> float_norm_exp - 126 , 150 - config -> float_norm_exp ) ; else error_line ( ""data<S2SV_blank>format:<S2SV_blank>%d-bit<S2SV_blank>integers<S2SV_blank>stored<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>byte(s)"" , config -> bits_per_sample , WaveHeader . BlockAlign / WaveHeader . NumChannels ) ; } } else if ( ! strncmp ( chunk_header . ckID , ""data"" , 4 ) ) { int64_t data_chunk_size = ( got_ds64 && chunk_header . ckSize == ( uint32_t ) - 1 ) ? ds64_chunk . dataSize64 : chunk_header . ckSize ; if ( ! WaveHeader . NumChannels || ( is_rf64 && ! got_ds64 ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && infilesize - data_chunk_size > 16777216 ) { error_line ( ""this<S2SV_blank>.WAV<S2SV_blank>file<S2SV_blank>has<S2SV_blank>over<S2SV_blank>16<S2SV_blank>MB<S2SV_blank>of<S2SV_blank>extra<S2SV_blank>RIFF<S2SV_blank>data,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" ) ; return WAVPACK_SOFT_ERROR ; } if ( config -> qmode & QMODE_IGNORE_LENGTH ) { if ( infilesize && DoGetFilePosition ( infile ) != - 1 ) total_samples = ( infilesize - DoGetFilePosition ( infile ) ) / WaveHeader . BlockAlign ; else total_samples = - 1 ; } else { total_samples = data_chunk_size / WaveHeader . BlockAlign ; if ( got_ds64 && total_samples != ds64_chunk . sampleCount64 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( ! total_samples ) { error_line ( ""this<S2SV_blank>.WAV<S2SV_blank>file<S2SV_blank>has<S2SV_blank>no<S2SV_blank>audio<S2SV_blank>samples,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" ) ; return WAVPACK_SOFT_ERROR ; } if ( total_samples > MAX_WAVPACK_SAMPLES ) { error_line ( ""%s<S2SV_blank>has<S2SV_blank>too<S2SV_blank>many<S2SV_blank>samples<S2SV_blank>for<S2SV_blank>WavPack!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } } config -> bytes_per_sample = WaveHeader . BlockAlign / WaveHeader . NumChannels ; config -> num_channels = WaveHeader . NumChannels ; config -> sample_rate = WaveHeader . SampleRate ; break ; } else { int bytes_to_copy = ( chunk_header . ckSize + 1 ) & ~ 1L ; char * buff = malloc ( bytes_to_copy ) ; if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , chunk_header . ckID [ 0 ] , chunk_header . ckID [ 1 ] , chunk_header . ckID [ 2 ] , chunk_header . ckID [ 3 ] , chunk_header . ckSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , NULL ) ) { error_line ( ""%s:<S2SV_blank>%s"" , infilename , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } return WAVPACK_NO_ERROR ; }
","<S2SV_ModStart> & ds64_chunk , sizeof ( DS64Chunk ) <S2SV_ModEnd> , & bcount <S2SV_ModStart> || bcount != sizeof ( DS64Chunk ) <S2SV_ModEnd> ) { error_line <S2SV_ModStart> & ds64_chunk , sizeof ( DS64Chunk ) <S2SV_ModEnd> ) ) {
"
862,"CWE-284 int tcp_v4_rcv ( struct sk_buff * skb ) { struct net * net = dev_net ( skb -> dev ) ; const struct iphdr * iph ; const struct tcphdr * th ; bool refcounted ; struct sock * sk ; int ret ; if ( skb -> pkt_type != PACKET_HOST ) goto discard_it ; __TCP_INC_STATS ( net , TCP_MIB_INSEGS ) ; if ( ! pskb_may_pull ( skb , sizeof ( struct tcphdr ) ) ) goto discard_it ; th = ( const struct tcphdr * ) skb -> data ; if ( unlikely ( th -> doff < sizeof ( struct tcphdr ) / 4 ) ) goto bad_packet ; if ( ! pskb_may_pull ( skb , th -> doff * 4 ) ) goto discard_it ; if ( skb_checksum_init ( skb , IPPROTO_TCP , inet_compute_pseudo ) ) goto csum_error ; th = ( const struct tcphdr * ) skb -> data ; iph = ip_hdr ( skb ) ; memmove ( & TCP_SKB_CB ( skb ) -> header . h4 , IPCB ( skb ) , sizeof ( struct inet_skb_parm ) ) ; barrier ( ) ; TCP_SKB_CB ( skb ) -> seq = ntohl ( th -> seq ) ; TCP_SKB_CB ( skb ) -> end_seq = ( TCP_SKB_CB ( skb ) -> seq + th -> syn + th -> fin + skb -> len - th -> doff * 4 ) ; TCP_SKB_CB ( skb ) -> ack_seq = ntohl ( th -> ack_seq ) ; TCP_SKB_CB ( skb ) -> tcp_flags = tcp_flag_byte ( th ) ; TCP_SKB_CB ( skb ) -> tcp_tw_isn = 0 ; TCP_SKB_CB ( skb ) -> ip_dsfield = ipv4_get_dsfield ( iph ) ; TCP_SKB_CB ( skb ) -> sacked = 0 ; lookup : sk = __inet_lookup_skb ( & tcp_hashinfo , skb , __tcp_hdrlen ( th ) , th -> source , th -> dest , & refcounted ) ; if ( ! sk ) goto no_tcp_socket ; process : if ( sk -> sk_state == TCP_TIME_WAIT ) goto do_time_wait ; if ( sk -> sk_state == TCP_NEW_SYN_RECV ) { struct request_sock * req = inet_reqsk ( sk ) ; struct sock * nsk ; sk = req -> rsk_listener ; if ( unlikely ( tcp_v4_inbound_md5_hash ( sk , skb ) ) ) { sk_drops_add ( sk , skb ) ; reqsk_put ( req ) ; goto discard_it ; } if ( unlikely ( sk -> sk_state != TCP_LISTEN ) ) { inet_csk_reqsk_queue_drop_and_put ( sk , req ) ; goto lookup ; } sock_hold ( sk ) ; refcounted = true ; nsk = tcp_check_req ( sk , skb , req , false ) ; if ( ! nsk ) { reqsk_put ( req ) ; goto discard_and_relse ; } if ( nsk == sk ) { reqsk_put ( req ) ; } else if ( tcp_child_process ( sk , nsk , skb ) ) { tcp_v4_send_reset ( nsk , skb ) ; goto discard_and_relse ; } else { sock_put ( sk ) ; return 0 ; } } if ( unlikely ( iph -> ttl < inet_sk ( sk ) -> min_ttl ) ) { __NET_INC_STATS ( net , LINUX_MIB_TCPMINTTLDROP ) ; goto discard_and_relse ; } if ( ! xfrm4_policy_check ( sk , XFRM_POLICY_IN , skb ) ) goto discard_and_relse ; if ( tcp_v4_inbound_md5_hash ( sk , skb ) ) goto discard_and_relse ; nf_reset ( skb ) ; <S2SV_StartBug> if ( sk_filter ( sk , skb ) ) <S2SV_EndBug> <S2SV_StartBug> goto discard_and_relse ; <S2SV_EndBug> skb -> dev = NULL ; if ( sk -> sk_state == TCP_LISTEN ) { ret = tcp_v4_do_rcv ( sk , skb ) ; goto put_and_return ; } sk_incoming_cpu_update ( sk ) ; bh_lock_sock_nested ( sk ) ; tcp_segs_in ( tcp_sk ( sk ) , skb ) ; ret = 0 ; if ( ! sock_owned_by_user ( sk ) ) { if ( ! tcp_prequeue ( sk , skb ) ) ret = tcp_v4_do_rcv ( sk , skb ) ; } else if ( tcp_add_backlog ( sk , skb ) ) { goto discard_and_relse ; } bh_unlock_sock ( sk ) ; put_and_return : if ( refcounted ) sock_put ( sk ) ; return ret ; no_tcp_socket : if ( ! xfrm4_policy_check ( NULL , XFRM_POLICY_IN , skb ) ) goto discard_it ; if ( tcp_checksum_complete ( skb ) ) { csum_error : __TCP_INC_STATS ( net , TCP_MIB_CSUMERRORS ) ; bad_packet : __TCP_INC_STATS ( net , TCP_MIB_INERRS ) ; } else { tcp_v4_send_reset ( NULL , skb ) ; } discard_it : kfree_skb ( skb ) ; return 0 ; discard_and_relse : sk_drops_add ( sk , skb ) ; if ( refcounted ) sock_put ( sk ) ; goto discard_it ; do_time_wait : if ( ! xfrm4_policy_check ( NULL , XFRM_POLICY_IN , skb ) ) { inet_twsk_put ( inet_twsk ( sk ) ) ; goto discard_it ; } if ( tcp_checksum_complete ( skb ) ) { inet_twsk_put ( inet_twsk ( sk ) ) ; goto csum_error ; } switch ( tcp_timewait_state_process ( inet_twsk ( sk ) , skb , th ) ) { case TCP_TW_SYN : { struct sock * sk2 = inet_lookup_listener ( dev_net ( skb -> dev ) , & tcp_hashinfo , skb , __tcp_hdrlen ( th ) , iph -> saddr , th -> source , iph -> daddr , th -> dest , inet_iif ( skb ) ) ; if ( sk2 ) { inet_twsk_deschedule_put ( inet_twsk ( sk ) ) ; sk = sk2 ; refcounted = false ; goto process ; } } case TCP_TW_ACK : tcp_v4_timewait_ack ( sk , skb ) ; break ; case TCP_TW_RST : tcp_v4_send_reset ( sk , skb ) ; inet_twsk_deschedule_put ( inet_twsk ( sk ) ) ; goto discard_it ; case TCP_TW_SUCCESS : ; } goto discard_it ; }
","<S2SV_ModStart> ; if ( tcp_filter <S2SV_ModEnd> ( sk , <S2SV_ModStart> ) goto discard_and_relse ; th = ( const struct tcphdr * ) skb -> data ; iph = ip_hdr ( skb )
"
863,"CWE-674 static krb5_error_code get_tag ( const uint8_t * asn1 , size_t len , taginfo * tag_out , const uint8_t * * contents_out , size_t * clen_out , <S2SV_StartBug> const uint8_t * * remainder_out , size_t * rlen_out ) <S2SV_EndBug> { krb5_error_code ret ; uint8_t o ; const uint8_t * c , * p , * tag_start = asn1 ; size_t clen , llen , i ; taginfo t ; * contents_out = * remainder_out = NULL ; * clen_out = * rlen_out = 0 ; if ( len == 0 ) return ASN1_OVERRUN ; o = * asn1 ++ ; len -- ; tag_out -> asn1class = o & 0xC0 ; tag_out -> construction = o & 0x20 ; if ( ( o & 0x1F ) != 0x1F ) { tag_out -> tagnum = o & 0x1F ; } else { tag_out -> tagnum = 0 ; do { if ( len == 0 ) return ASN1_OVERRUN ; o = * asn1 ++ ; len -- ; tag_out -> tagnum = ( tag_out -> tagnum << 7 ) | ( o & 0x7F ) ; } while ( o & 0x80 ) ; } if ( len == 0 ) return ASN1_OVERRUN ; o = * asn1 ++ ; len -- ; if ( o == 0x80 ) { if ( tag_out -> construction != CONSTRUCTED ) return ASN1_MISMATCH_INDEF ; <S2SV_StartBug> p = asn1 ; <S2SV_EndBug> while ( ! ( len >= 2 && p [ 0 ] == 0 && p [ 1 ] == 0 ) ) { <S2SV_StartBug> ret = get_tag ( p , len , & t , & c , & clen , & p , & len ) ; <S2SV_EndBug> if ( ret ) return ret ; } tag_out -> tag_end_len = 2 ; * contents_out = asn1 ; * clen_out = p - asn1 ; * remainder_out = p + 2 ; * rlen_out = len - 2 ; } else if ( ( o & 0x80 ) == 0 ) { if ( o > len ) return ASN1_OVERRUN ; tag_out -> tag_end_len = 0 ; * contents_out = asn1 ; * clen_out = o ; * remainder_out = asn1 + * clen_out ; * rlen_out = len - ( * remainder_out - asn1 ) ; } else { llen = o & 0x7F ; if ( llen > len ) return ASN1_OVERRUN ; if ( llen > sizeof ( * clen_out ) ) return ASN1_OVERFLOW ; for ( i = 0 , clen = 0 ; i < llen ; i ++ ) clen = ( clen << 8 ) | asn1 [ i ] ; if ( clen > len - llen ) return ASN1_OVERRUN ; tag_out -> tag_end_len = 0 ; * contents_out = asn1 + llen ; * clen_out = clen ; * remainder_out = * contents_out + clen ; * rlen_out = len - ( * remainder_out - asn1 ) ; } tag_out -> tag_len = * contents_out - tag_start ; return 0 ; }
","<S2SV_ModStart> size_t * rlen_out , int recursion <S2SV_ModStart> return ASN1_MISMATCH_INDEF ; if ( recursion >= 32 ) return ASN1_OVERFLOW ; <S2SV_ModStart> , & len , recursion + 1
"
864,"CWE-20 void kvm_lapic_sync_to_vapic ( struct kvm_vcpu * vcpu ) { u32 data , tpr ; int max_irr , max_isr ; <S2SV_StartBug> struct kvm_lapic * apic = vcpu -> arch . apic ; <S2SV_EndBug> void * vapic ; apic_sync_pv_eoi_to_guest ( vcpu , apic ) ; if ( ! test_bit ( KVM_APIC_CHECK_VAPIC , & vcpu -> arch . apic_attention ) ) return ; tpr = kvm_apic_get_reg ( apic , APIC_TASKPRI ) & 0xff ; max_irr = apic_find_highest_irr ( apic ) ; if ( max_irr < 0 ) max_irr = 0 ; max_isr = apic_find_highest_isr ( apic ) ; if ( max_isr < 0 ) max_isr = 0 ; data = ( tpr & 0xff ) | ( ( max_isr & 0xf0 ) << 8 ) | ( max_irr << 24 ) ; <S2SV_StartBug> vapic = kmap_atomic ( vcpu -> arch . apic -> vapic_page ) ; <S2SV_EndBug> * ( u32 * ) ( vapic + offset_in_page ( vcpu -> arch . apic -> vapic_addr ) ) = data ; kunmap_atomic ( vapic ) ; }
","<S2SV_ModStart> arch . apic <S2SV_ModEnd> ; apic_sync_pv_eoi_to_guest ( <S2SV_ModStart> 24 ) ; kvm_write_guest_cached ( vcpu -> kvm , & <S2SV_ModEnd> vcpu -> arch <S2SV_ModStart> . apic -> vapic_cache , & data , sizeof ( u32 ) <S2SV_ModEnd> ) ; }
"
865,"CWE-119 char * logger_get_mask_expanded ( struct t_gui_buffer * buffer , const char * mask ) { <S2SV_StartBug> char * mask2 , * mask_decoded , * mask_decoded2 , * mask_decoded3 , * mask_decoded4 ; <S2SV_EndBug> char * mask_decoded5 ; const char * dir_separator ; int length ; time_t seconds ; struct tm * date_tmp ; mask2 = NULL ; <S2SV_StartBug> mask_decoded = NULL ; <S2SV_EndBug> mask_decoded2 = NULL ; mask_decoded3 = NULL ; mask_decoded4 = NULL ; mask_decoded5 = NULL ; dir_separator = weechat_info_get ( ""dir_separator"" , """" ) ; if ( ! dir_separator ) return NULL ; <S2SV_StartBug> mask2 = weechat_string_replace ( mask , dir_separator , ""\\01"" ) ; <S2SV_EndBug> if ( ! mask2 ) goto end ; mask_decoded = weechat_buffer_string_replace_local_var ( buffer , mask2 ) ; if ( ! mask_decoded ) goto end ; mask_decoded2 = weechat_string_replace ( mask_decoded , dir_separator , weechat_config_string ( logger_config_file_replacement_char ) ) ; if ( ! mask_decoded2 ) goto end ; # ifdef __CYGWIN__ mask_decoded3 = weechat_string_replace ( mask_decoded2 , ""\\\\"" , weechat_config_string ( logger_config_file_replacement_char ) ) ; # else mask_decoded3 = strdup ( mask_decoded2 ) ; # endif if ( ! mask_decoded3 ) goto end ; mask_decoded4 = weechat_string_replace ( mask_decoded3 , ""\\01"" , dir_separator ) ; if ( ! mask_decoded4 ) goto end ; length = strlen ( mask_decoded4 ) + 256 + 1 ; <S2SV_StartBug> mask_decoded5 = malloc ( length ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! mask_decoded5 ) <S2SV_EndBug> goto end ; seconds = time ( NULL ) ; date_tmp = localtime ( & seconds ) ; <S2SV_StartBug> mask_decoded5 [ 0 ] = '\\0' ; <S2SV_EndBug> <S2SV_StartBug> strftime ( mask_decoded5 , length - 1 , mask_decoded4 , date_tmp ) ; <S2SV_EndBug> if ( weechat_config_boolean ( logger_config_file_name_lower_case ) ) <S2SV_StartBug> weechat_string_tolower ( mask_decoded5 ) ; <S2SV_EndBug> if ( weechat_logger_plugin -> debug ) { weechat_printf_date_tags ( NULL , 0 , ""no_log"" , ""%s:<S2SV_blank>buffer<S2SV_blank>=<S2SV_blank>\\""%s\\"",<S2SV_blank>mask<S2SV_blank>=<S2SV_blank>\\""%s\\"",<S2SV_blank>"" ""decoded<S2SV_blank>mask<S2SV_blank>=<S2SV_blank>\\""%s\\"""" , LOGGER_PLUGIN_NAME , weechat_buffer_get_string ( buffer , ""name"" ) , <S2SV_StartBug> mask , mask_decoded5 ) ; <S2SV_EndBug> } end : if ( mask2 ) free ( mask2 ) ; <S2SV_StartBug> if ( mask_decoded ) <S2SV_EndBug> <S2SV_StartBug> free ( mask_decoded ) ; <S2SV_EndBug> if ( mask_decoded2 ) <S2SV_StartBug> free ( mask_decoded2 ) ; <S2SV_EndBug> if ( mask_decoded3 ) <S2SV_StartBug> free ( mask_decoded3 ) ; <S2SV_EndBug> if ( mask_decoded4 ) <S2SV_StartBug> free ( mask_decoded4 ) ; <S2SV_EndBug> <S2SV_StartBug> return mask_decoded5 ; <S2SV_EndBug> }
","<S2SV_ModStart> mask2 , * mask3 , * mask4 , * mask5 , * mask6 , * mask7 <S2SV_ModEnd> ; const char <S2SV_ModStart> = NULL ; mask3 = NULL ; mask4 = NULL ; mask5 = NULL ; mask6 = NULL ; mask7 <S2SV_ModEnd> = NULL ; <S2SV_ModStart> return NULL ; length = strlen ( mask <S2SV_ModEnd> ) + 256 <S2SV_ModStart> + 1 ; mask2 <S2SV_ModEnd> = malloc ( <S2SV_ModStart> if ( ! mask2 <S2SV_ModEnd> ) goto end <S2SV_ModStart> seconds ) ; mask2 <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = '\\0' ; if ( strftime ( mask2 <S2SV_ModEnd> , length - <S2SV_ModStart> - 1 , mask <S2SV_ModEnd> , date_tmp ) <S2SV_ModStart> , date_tmp ) == 0 ) mask2 [ 0 ] = '\\0' ; mask3 = weechat_string_replace ( mask2 , dir_separator , ""\\01"" ) ; if ( ! mask3 ) goto end ; mask4 = weechat_buffer_string_replace_local_var ( buffer , mask3 ) ; if ( ! mask4 ) goto end ; mask5 = weechat_string_replace ( mask4 , dir_separator , weechat_config_string ( logger_config_file_replacement_char ) ) ; if ( ! mask5 ) goto end ; # ifdef __CYGWIN__ mask6 = weechat_string_replace ( mask5 , ""\\\\"" , weechat_config_string ( logger_config_file_replacement_char ) ) ; # else mask6 = strdup ( mask5 ) ; # endif if ( ! mask6 ) goto end ; mask7 = weechat_string_replace ( mask6 , ""\\01"" , dir_separator ) ; if ( ! mask7 ) goto end <S2SV_ModStart> ) weechat_string_tolower ( mask7 <S2SV_ModEnd> ) ; if <S2SV_ModStart> , mask , mask7 <S2SV_ModEnd> ) ; } <S2SV_ModStart> ; if ( mask3 <S2SV_ModEnd> ) free ( <S2SV_ModStart> ) free ( mask3 ) ; if ( mask4 <S2SV_ModEnd> ) free ( <S2SV_ModStart> ) free ( mask4 ) ; if ( mask5 <S2SV_ModEnd> ) free ( <S2SV_ModStart> ) free ( mask5 ) ; if ( mask6 <S2SV_ModEnd> ) free ( <S2SV_ModStart> ) free ( mask6 <S2SV_ModEnd> ) ; return <S2SV_ModStart> ) ; return mask7 <S2SV_ModEnd> ; } <S2SV_null>
"
866,"CWE-119 static long gfs2_fallocate ( struct file * file , int mode , loff_t offset , loff_t len ) { struct inode * inode = file -> f_path . dentry -> d_inode ; struct gfs2_sbd * sdp = GFS2_SB ( inode ) ; struct gfs2_inode * ip = GFS2_I ( inode ) ; unsigned int data_blocks = 0 , ind_blocks = 0 , rblocks ; loff_t bytes , max_bytes ; struct gfs2_alloc * al ; int error ; loff_t bsize_mask = ~ ( ( loff_t ) sdp -> sd_sb . sb_bsize - 1 ) ; loff_t next = ( offset + len - 1 ) >> sdp -> sd_sb . sb_bsize_shift ; <S2SV_StartBug> next = ( next + 1 ) << sdp -> sd_sb . sb_bsize_shift ; <S2SV_EndBug> if ( mode & ~ FALLOC_FL_KEEP_SIZE ) return - EOPNOTSUPP ; offset &= bsize_mask ; len = next - offset ; bytes = sdp -> sd_max_rg_data * sdp -> sd_sb . sb_bsize / 2 ; if ( ! bytes ) bytes = UINT_MAX ; bytes &= bsize_mask ; if ( bytes == 0 ) bytes = sdp -> sd_sb . sb_bsize ; gfs2_holder_init ( ip -> i_gl , LM_ST_EXCLUSIVE , 0 , & ip -> i_gh ) ; error = gfs2_glock_nq ( & ip -> i_gh ) ; if ( unlikely ( error ) ) goto out_uninit ; if ( ! gfs2_write_alloc_required ( ip , offset , len ) ) goto out_unlock ; while ( len > 0 ) { if ( len < bytes ) bytes = len ; al = gfs2_alloc_get ( ip ) ; if ( ! al ) { error = - ENOMEM ; goto out_unlock ; } error = gfs2_quota_lock_check ( ip ) ; if ( error ) goto out_alloc_put ; retry : gfs2_write_calc_reserv ( ip , bytes , & data_blocks , & ind_blocks ) ; al -> al_requested = data_blocks + ind_blocks ; error = gfs2_inplace_reserve ( ip ) ; if ( error ) { if ( error == - ENOSPC && bytes > sdp -> sd_sb . sb_bsize ) { bytes >>= 1 ; bytes &= bsize_mask ; if ( bytes == 0 ) bytes = sdp -> sd_sb . sb_bsize ; goto retry ; } goto out_qunlock ; } max_bytes = bytes ; <S2SV_StartBug> calc_max_reserv ( ip , len , & max_bytes , & data_blocks , & ind_blocks ) ; <S2SV_EndBug> al -> al_requested = data_blocks + ind_blocks ; rblocks = RES_DINODE + ind_blocks + RES_STATFS + RES_QUOTA + RES_RG_HDR + gfs2_rg_blocks ( ip ) ; if ( gfs2_is_jdata ( ip ) ) rblocks += data_blocks ? data_blocks : 1 ; error = gfs2_trans_begin ( sdp , rblocks , PAGE_CACHE_SIZE / sdp -> sd_sb . sb_bsize ) ; if ( error ) goto out_trans_fail ; error = fallocate_chunk ( inode , offset , max_bytes , mode ) ; gfs2_trans_end ( sdp ) ; if ( error ) goto out_trans_fail ; len -= max_bytes ; offset += max_bytes ; gfs2_inplace_release ( ip ) ; gfs2_quota_unlock ( ip ) ; gfs2_alloc_put ( ip ) ; } goto out_unlock ; out_trans_fail : gfs2_inplace_release ( ip ) ; out_qunlock : gfs2_quota_unlock ( ip ) ; out_alloc_put : gfs2_alloc_put ( ip ) ; out_unlock : gfs2_glock_dq ( & ip -> i_gh ) ; out_uninit : gfs2_holder_uninit ( & ip -> i_gh ) ; return error ; }
","<S2SV_ModStart> . sb_bsize_shift ; loff_t max_chunk_size = UINT_MAX & bsize_mask ; <S2SV_ModStart> ( ip , ( len > max_chunk_size ) ? max_chunk_size : len , <S2SV_ModEnd> & max_bytes ,
"
867,"CWE-310 static noinline int btrfs_mksubvol ( struct path * parent , char * name , int namelen , struct btrfs_root * snap_src , u64 * async_transid , bool readonly , struct btrfs_qgroup_inherit * * inherit ) { struct inode * dir = parent -> dentry -> d_inode ; struct dentry * dentry ; int error ; mutex_lock_nested ( & dir -> i_mutex , I_MUTEX_PARENT ) ; dentry = lookup_one_len ( name , parent -> dentry , namelen ) ; error = PTR_ERR ( dentry ) ; if ( IS_ERR ( dentry ) ) goto out_unlock ; error = - EEXIST ; if ( dentry -> d_inode ) goto out_dput ; error = btrfs_may_create ( dir , dentry ) ; if ( error ) goto out_dput ; <S2SV_StartBug> down_read ( & BTRFS_I ( dir ) -> root -> fs_info -> subvol_sem ) ; <S2SV_EndBug> if ( btrfs_root_refs ( & BTRFS_I ( dir ) -> root -> root_item ) == 0 ) goto out_up_read ; if ( snap_src ) { error = create_snapshot ( snap_src , dentry , name , namelen , async_transid , readonly , inherit ) ; } else { error = create_subvol ( BTRFS_I ( dir ) -> root , dentry , name , namelen , async_transid , inherit ) ; } if ( ! error ) fsnotify_mkdir ( dir , dentry ) ; out_up_read : up_read ( & BTRFS_I ( dir ) -> root -> fs_info -> subvol_sem ) ; out_dput : dput ( dentry ) ; out_unlock : mutex_unlock ( & dir -> i_mutex ) ; return error ; }
","<S2SV_ModStart> goto out_dput ; error = btrfs_check_dir_item_collision ( BTRFS_I ( dir ) -> root , dir -> i_ino , name , namelen ) ; if ( error ) goto out_dput ;
"
868,"CWE-119 EAS_BOOL WT_CheckSampleEnd ( S_WT_VOICE * pWTVoice , S_WT_INT_FRAME * pWTIntFrame , EAS_BOOL update ) { EAS_U32 endPhaseAccum ; EAS_U32 endPhaseFrac ; EAS_I32 numSamples ; EAS_BOOL done = EAS_FALSE ; endPhaseFrac = pWTVoice -> phaseFrac + ( pWTIntFrame -> frame . phaseIncrement << SYNTH_UPDATE_PERIOD_IN_BITS ) ; endPhaseAccum = pWTVoice -> phaseAccum + GET_PHASE_INT_PART ( endPhaseFrac ) ; if ( endPhaseAccum >= pWTVoice -> loopEnd ) { numSamples = ( EAS_I32 ) ( pWTVoice -> loopEnd - pWTVoice -> phaseAccum ) ; numSamples = ( EAS_I32 ) ( ( numSamples << NUM_PHASE_FRAC_BITS ) - pWTVoice -> phaseFrac ) ; if ( pWTIntFrame -> frame . phaseIncrement ) { pWTIntFrame -> numSamples = 1 + ( numSamples / pWTIntFrame -> frame . phaseIncrement ) ; } else { pWTIntFrame -> numSamples = numSamples ; } if ( pWTIntFrame -> numSamples < 0 ) { ALOGE ( ""b/26366256"" ) ; <S2SV_StartBug> pWTIntFrame -> numSamples = 0 ; <S2SV_EndBug> } done = EAS_TRUE ; } if ( update ) { pWTVoice -> phaseFrac = endPhaseFrac ; pWTVoice -> phaseAccum = endPhaseAccum ; } return done ; }
","<S2SV_ModStart> ""b/26366256"" ) ; android_errorWriteLog ( 0x534e4554 , ""26366256"" ) ;
"
869,"CWE-20 error_t ftpClientParseDirEntry ( char_t * line , FtpDirEntry * dirEntry ) { uint_t i ; size_t n ; char_t * p ; char_t * token ; static const char_t months [ 13 ] [ 4 ] = { ""<S2SV_blank><S2SV_blank><S2SV_blank>"" , ""Jan"" , ""Feb"" , ""Mar"" , ""Apr"" , ""May"" , ""Jun"" , ""Jul"" , ""Aug"" , ""Sep"" , ""Oct"" , ""Nov"" , ""Dec"" } ; token = osStrtok_r ( line , ""<S2SV_blank>\\t"" , & p ) ; if ( token == NULL ) return ERROR_INVALID_SYNTAX ; if ( osIsdigit ( token [ 0 ] ) ) { if ( osStrlen ( token ) == 8 && token [ 2 ] == '-' && token [ 5 ] == '-' ) { dirEntry -> modified . month = ( uint8_t ) osStrtoul ( token , NULL , 10 ) ; dirEntry -> modified . day = ( uint8_t ) osStrtoul ( token + 3 , NULL , 10 ) ; dirEntry -> modified . year = ( uint16_t ) osStrtoul ( token + 6 , NULL , 10 ) + 2000 ; } else if ( osStrlen ( token ) == 10 && token [ 2 ] == '/' && token [ 5 ] == '/' ) { dirEntry -> modified . month = ( uint8_t ) osStrtoul ( token , NULL , 10 ) ; dirEntry -> modified . day = ( uint8_t ) osStrtoul ( token + 3 , NULL , 10 ) ; dirEntry -> modified . year = ( uint16_t ) osStrtoul ( token + 6 , NULL , 10 ) ; } else { return ERROR_INVALID_SYNTAX ; } token = osStrtok_r ( NULL , ""<S2SV_blank>"" , & p ) ; if ( token == NULL ) return ERROR_INVALID_SYNTAX ; if ( osStrlen ( token ) >= 5 && token [ 2 ] == ':' ) { dirEntry -> modified . hours = ( uint8_t ) osStrtoul ( token , NULL , 10 ) ; dirEntry -> modified . minutes = ( uint8_t ) osStrtoul ( token + 3 , NULL , 10 ) ; <S2SV_StartBug> if ( strstr ( token , ""PM"" ) != NULL ) <S2SV_EndBug> dirEntry -> modified . hours += 12 ; } <S2SV_StartBug> else <S2SV_EndBug> { return ERROR_INVALID_SYNTAX ; } token = osStrtok_r ( NULL , ""<S2SV_blank>"" , & p ) ; if ( token == NULL ) return ERROR_INVALID_SYNTAX ; if ( ! osStrcmp ( token , ""<DIR>"" ) ) { dirEntry -> attributes |= FTP_FILE_ATTR_DIRECTORY ; } else { dirEntry -> size = osStrtoul ( token , NULL , 10 ) ; } token = osStrtok_r ( NULL , ""<S2SV_blank>\\r\\n"" , & p ) ; if ( token == NULL ) return ERROR_INVALID_SYNTAX ; n = osStrlen ( token ) ; n = MIN ( n , FTP_CLIENT_MAX_FILENAME_LEN ) ; osStrncpy ( dirEntry -> name , token , n ) ; dirEntry -> name [ n ] = '\\0' ; } else { <S2SV_StartBug> if ( strchr ( token , 'd' ) != NULL ) <S2SV_EndBug> dirEntry -> attributes |= FTP_FILE_ATTR_DIRECTORY ; <S2SV_StartBug> if ( strchr ( token , 'w' ) == NULL ) <S2SV_EndBug> dirEntry -> attributes |= FTP_FILE_ATTR_READ_ONLY ; <S2SV_StartBug> token = osStrtok_r ( NULL , ""<S2SV_blank>"" , & p ) ; <S2SV_EndBug> if ( token == NULL ) return ERROR_INVALID_SYNTAX ; token = osStrtok_r ( NULL , ""<S2SV_blank>"" , & p ) ; if ( token == NULL ) return ERROR_INVALID_SYNTAX ; token = osStrtok_r ( NULL , ""<S2SV_blank>"" , & p ) ; if ( token == NULL ) return ERROR_INVALID_SYNTAX ; token = osStrtok_r ( NULL , ""<S2SV_blank>"" , & p ) ; if ( token == NULL ) return ERROR_INVALID_SYNTAX ; dirEntry -> size = osStrtoul ( token , NULL , 10 ) ; token = osStrtok_r ( NULL , ""<S2SV_blank>"" , & p ) ; if ( token == NULL ) return ERROR_INVALID_SYNTAX ; for ( i = 1 ; i <= 12 ; i ++ ) { if ( ! osStrcmp ( token , months [ i ] ) ) { dirEntry -> modified . month = i ; break ; } } token = osStrtok_r ( NULL , ""<S2SV_blank>"" , & p ) ; if ( token == NULL ) return ERROR_INVALID_SYNTAX ; dirEntry -> modified . day = ( uint8_t ) osStrtoul ( token , NULL , 10 ) ; token = osStrtok_r ( NULL , ""<S2SV_blank>"" , & p ) ; if ( token == NULL ) return ERROR_INVALID_SYNTAX ; if ( osStrlen ( token ) == 4 ) { dirEntry -> modified . year = ( uint16_t ) osStrtoul ( token , NULL , 10 ) ; } else if ( osStrlen ( token ) == 5 ) { token [ 2 ] = '\\0' ; dirEntry -> modified . hours = ( uint8_t ) osStrtoul ( token , NULL , 10 ) ; dirEntry -> modified . minutes = ( uint8_t ) osStrtoul ( token + 3 , NULL , 10 ) ; } else { return ERROR_INVALID_SYNTAX ; } token = osStrtok_r ( NULL , ""<S2SV_blank>\\r\\n"" , & p ) ; if ( token == NULL ) return ERROR_INVALID_SYNTAX ; n = osStrlen ( token ) ; n = MIN ( n , FTP_CLIENT_MAX_FILENAME_LEN ) ; osStrncpy ( dirEntry -> name , token , n ) ; dirEntry -> name [ n ] = '\\0' ; } return NO_ERROR ; }
","<S2SV_ModStart> ; if ( osStrstr <S2SV_ModEnd> ( token , <S2SV_ModStart> != NULL ) { <S2SV_ModStart> 12 ; } } <S2SV_ModStart> { if ( osStrchr <S2SV_ModEnd> ( token , <S2SV_ModStart> != NULL ) { <S2SV_ModStart> |= FTP_FILE_ATTR_DIRECTORY ; } if ( osStrchr <S2SV_ModEnd> ( token , <S2SV_ModStart> == NULL ) { <S2SV_ModStart> |= FTP_FILE_ATTR_READ_ONLY ; }
"
870,"CWE-125 static x86newTokenType getToken ( const char * str , size_t * begin , size_t * end ) { <S2SV_StartBug> while ( begin && isspace ( ( ut8 ) str [ * begin ] ) ) { <S2SV_EndBug> ++ ( * begin ) ; } if ( ! str [ * begin ] ) { * end = * begin ; return TT_EOF ; <S2SV_StartBug> } else if ( isalpha ( ( ut8 ) str [ * begin ] ) ) { <S2SV_EndBug> * end = * begin ; <S2SV_StartBug> while ( end && isalnum ( ( ut8 ) str [ * end ] ) ) { <S2SV_EndBug> ++ ( * end ) ; } return TT_WORD ; <S2SV_StartBug> } else if ( isdigit ( ( ut8 ) str [ * begin ] ) ) { <S2SV_EndBug> * end = * begin ; while ( end && isalnum ( ( ut8 ) str [ * end ] ) ) { ++ ( * end ) ; } return TT_NUMBER ; } else { * end = * begin + 1 ; return TT_SPECIAL ; } }
","<S2SV_ModStart> end ) { if ( * begin > strlen ( str ) ) { return TT_EOF ; } <S2SV_ModStart> ( begin && str [ * begin ] && <S2SV_ModStart> TT_EOF ; } <S2SV_ModEnd> if ( isalpha <S2SV_ModStart> ( end && str [ * end ] && <S2SV_ModStart> TT_WORD ; } <S2SV_ModEnd> if ( isdigit
"
871,"CWE-20 int main ( int argc , char * * argv ) { int c ; bool lock_memory = false ; bool do_daemonize = false ; bool preallocate = false ; int maxcore = 0 ; char * username = NULL ; char * pid_file = NULL ; struct passwd * pw ; struct rlimit rlim ; char * buf ; char unit = '\\0' ; int size_max = 0 ; int retval = EXIT_SUCCESS ; static int * l_socket = NULL ; static int * u_socket = NULL ; bool protocol_specified = false ; bool tcp_specified = false ; bool udp_specified = false ; bool start_lru_maintainer = true ; bool start_lru_crawler = true ; bool start_assoc_maint = true ; enum hashfunc_type hash_type = MURMUR3_HASH ; uint32_t tocrawl ; uint32_t slab_sizes [ MAX_NUMBER_OF_SLAB_CLASSES ] ; bool use_slab_sizes = false ; char * slab_sizes_unparsed = NULL ; bool slab_chunk_size_changed = false ; # ifdef EXTSTORE void * storage = NULL ; char * storage_file = NULL ; struct extstore_conf ext_cf ; # endif char * subopts , * subopts_orig ; char * subopts_value ; enum { MAXCONNS_FAST = 0 , HASHPOWER_INIT , NO_HASHEXPAND , SLAB_REASSIGN , SLAB_AUTOMOVE , SLAB_AUTOMOVE_RATIO , SLAB_AUTOMOVE_WINDOW , TAIL_REPAIR_TIME , HASH_ALGORITHM , LRU_CRAWLER , LRU_CRAWLER_SLEEP , LRU_CRAWLER_TOCRAWL , LRU_MAINTAINER , HOT_LRU_PCT , WARM_LRU_PCT , HOT_MAX_FACTOR , WARM_MAX_FACTOR , TEMPORARY_TTL , IDLE_TIMEOUT , WATCHER_LOGBUF_SIZE , WORKER_LOGBUF_SIZE , SLAB_SIZES , SLAB_CHUNK_MAX , TRACK_SIZES , NO_INLINE_ASCII_RESP , MODERN , NO_MODERN , NO_CHUNKED_ITEMS , NO_SLAB_REASSIGN , NO_SLAB_AUTOMOVE , NO_MAXCONNS_FAST , INLINE_ASCII_RESP , NO_LRU_CRAWLER , NO_LRU_MAINTAINER , NO_DROP_PRIVILEGES , # ifdef MEMCACHED_DEBUG RELAXED_PRIVILEGES , # endif # ifdef EXTSTORE EXT_PAGE_SIZE , EXT_PAGE_COUNT , EXT_WBUF_SIZE , EXT_THREADS , EXT_IO_DEPTH , EXT_PATH , EXT_ITEM_SIZE , EXT_ITEM_AGE , EXT_LOW_TTL , EXT_RECACHE_RATE , EXT_COMPACT_UNDER , EXT_DROP_UNDER , EXT_MAX_FRAG , EXT_DROP_UNREAD , SLAB_AUTOMOVE_FREERATIO , # endif } ; char * const subopts_tokens [ ] = { [ MAXCONNS_FAST ] = ""maxconns_fast"" , [ HASHPOWER_INIT ] = ""hashpower"" , [ NO_HASHEXPAND ] = ""no_hashexpand"" , [ SLAB_REASSIGN ] = ""slab_reassign"" , [ SLAB_AUTOMOVE ] = ""slab_automove"" , [ SLAB_AUTOMOVE_RATIO ] = ""slab_automove_ratio"" , [ SLAB_AUTOMOVE_WINDOW ] = ""slab_automove_window"" , [ TAIL_REPAIR_TIME ] = ""tail_repair_time"" , [ HASH_ALGORITHM ] = ""hash_algorithm"" , [ LRU_CRAWLER ] = ""lru_crawler"" , [ LRU_CRAWLER_SLEEP ] = ""lru_crawler_sleep"" , [ LRU_CRAWLER_TOCRAWL ] = ""lru_crawler_tocrawl"" , [ LRU_MAINTAINER ] = ""lru_maintainer"" , [ HOT_LRU_PCT ] = ""hot_lru_pct"" , [ WARM_LRU_PCT ] = ""warm_lru_pct"" , [ HOT_MAX_FACTOR ] = ""hot_max_factor"" , [ WARM_MAX_FACTOR ] = ""warm_max_factor"" , [ TEMPORARY_TTL ] = ""temporary_ttl"" , [ IDLE_TIMEOUT ] = ""idle_timeout"" , [ WATCHER_LOGBUF_SIZE ] = ""watcher_logbuf_size"" , [ WORKER_LOGBUF_SIZE ] = ""worker_logbuf_size"" , [ SLAB_SIZES ] = ""slab_sizes"" , [ SLAB_CHUNK_MAX ] = ""slab_chunk_max"" , [ TRACK_SIZES ] = ""track_sizes"" , [ NO_INLINE_ASCII_RESP ] = ""no_inline_ascii_resp"" , [ MODERN ] = ""modern"" , [ NO_MODERN ] = ""no_modern"" , [ NO_CHUNKED_ITEMS ] = ""no_chunked_items"" , [ NO_SLAB_REASSIGN ] = ""no_slab_reassign"" , [ NO_SLAB_AUTOMOVE ] = ""no_slab_automove"" , [ NO_MAXCONNS_FAST ] = ""no_maxconns_fast"" , [ INLINE_ASCII_RESP ] = ""inline_ascii_resp"" , [ NO_LRU_CRAWLER ] = ""no_lru_crawler"" , [ NO_LRU_MAINTAINER ] = ""no_lru_maintainer"" , [ NO_DROP_PRIVILEGES ] = ""no_drop_privileges"" , # ifdef MEMCACHED_DEBUG [ RELAXED_PRIVILEGES ] = ""relaxed_privileges"" , # endif # ifdef EXTSTORE [ EXT_PAGE_SIZE ] = ""ext_page_size"" , [ EXT_PAGE_COUNT ] = ""ext_page_count"" , [ EXT_WBUF_SIZE ] = ""ext_wbuf_size"" , [ EXT_THREADS ] = ""ext_threads"" , [ EXT_IO_DEPTH ] = ""ext_io_depth"" , [ EXT_PATH ] = ""ext_path"" , [ EXT_ITEM_SIZE ] = ""ext_item_size"" , [ EXT_ITEM_AGE ] = ""ext_item_age"" , [ EXT_LOW_TTL ] = ""ext_low_ttl"" , [ EXT_RECACHE_RATE ] = ""ext_recache_rate"" , [ EXT_COMPACT_UNDER ] = ""ext_compact_under"" , [ EXT_DROP_UNDER ] = ""ext_drop_under"" , [ EXT_MAX_FRAG ] = ""ext_max_frag"" , [ EXT_DROP_UNREAD ] = ""ext_drop_unread"" , [ SLAB_AUTOMOVE_FREERATIO ] = ""slab_automove_freeratio"" , # endif NULL } ; if ( ! sanitycheck ( ) ) { return EX_OSERR ; } signal ( SIGINT , sig_handler ) ; signal ( SIGTERM , sig_handler ) ; settings_init ( ) ; # ifdef EXTSTORE settings . ext_item_size = 512 ; settings . ext_item_age = UINT_MAX ; settings . ext_low_ttl = 0 ; settings . ext_recache_rate = 2000 ; settings . ext_max_frag = 0.8 ; settings . ext_drop_unread = false ; settings . ext_wbuf_size = 1024 * 1024 * 4 ; settings . ext_compact_under = 0 ; settings . ext_drop_under = 0 ; settings . slab_automove_freeratio = 0.01 ; ext_cf . page_size = 1024 * 1024 * 64 ; ext_cf . page_count = 64 ; ext_cf . wbuf_size = settings . ext_wbuf_size ; ext_cf . io_threadcount = 1 ; ext_cf . io_depth = 1 ; ext_cf . page_buckets = 4 ; ext_cf . wbuf_count = ext_cf . page_buckets ; # endif init_lru_maintainer ( ) ; setbuf ( stderr , NULL ) ; char * shortopts = ""a:"" ""A"" ""p:"" ""s:"" ""U:"" ""m:"" ""M"" ""c:"" ""k"" ""hiV"" ""r"" ""v"" ""d"" ""l:"" ""u:"" ""P:"" ""f:"" ""n:"" ""t:"" ""D:"" ""L"" ""R:"" ""C"" ""b:"" ""B:"" ""I:"" ""S"" ""F"" ""X"" ""o:"" ; # ifdef HAVE_GETOPT_LONG const struct option longopts [ ] = { { ""unix-mask"" , required_argument , 0 , 'a' } , { ""enable-shutdown"" , no_argument , 0 , 'A' } , { ""port"" , required_argument , 0 , 'p' } , { ""unix-socket"" , required_argument , 0 , 's' } , { ""udp-port"" , required_argument , 0 , 'U' } , { ""memory-limit"" , required_argument , 0 , 'm' } , { ""disable-evictions"" , no_argument , 0 , 'M' } , { ""conn-limit"" , required_argument , 0 , 'c' } , { ""lock-memory"" , no_argument , 0 , 'k' } , { ""help"" , no_argument , 0 , 'h' } , { ""license"" , no_argument , 0 , 'i' } , { ""version"" , no_argument , 0 , 'V' } , { ""enable-coredumps"" , no_argument , 0 , 'r' } , { ""verbose"" , optional_argument , 0 , 'v' } , { ""daemon"" , no_argument , 0 , 'd' } , { ""listen"" , required_argument , 0 , 'l' } , { ""user"" , required_argument , 0 , 'u' } , { ""pidfile"" , required_argument , 0 , 'P' } , { ""slab-growth-factor"" , required_argument , 0 , 'f' } , { ""slab-min-size"" , required_argument , 0 , 'n' } , { ""threads"" , required_argument , 0 , 't' } , { ""enable-largepages"" , no_argument , 0 , 'L' } , { ""max-reqs-per-event"" , required_argument , 0 , 'R' } , { ""disable-cas"" , no_argument , 0 , 'C' } , { ""listen-backlog"" , required_argument , 0 , 'b' } , { ""protocol"" , required_argument , 0 , 'B' } , { ""max-item-size"" , required_argument , 0 , 'I' } , { ""enable-sasl"" , no_argument , 0 , 'S' } , { ""disable-flush-all"" , no_argument , 0 , 'F' } , { ""disable-dumping"" , no_argument , 0 , 'X' } , { ""extended"" , required_argument , 0 , 'o' } , { 0 , 0 , 0 , 0 } } ; int optindex ; while ( - 1 != ( c = getopt_long ( argc , argv , shortopts , longopts , & optindex ) ) ) { # else while ( - 1 != ( c = getopt ( argc , argv , shortopts ) ) ) { # endif switch ( c ) { case 'A' : settings . shutdown_command = true ; break ; case 'a' : settings . access = strtol ( optarg , NULL , 8 ) ; break ; case 'U' : settings . udpport = atoi ( optarg ) ; udp_specified = true ; break ; case 'p' : settings . port = atoi ( optarg ) ; tcp_specified = true ; break ; case 's' : settings . socketpath = optarg ; break ; case 'm' : settings . maxbytes = ( ( size_t ) atoi ( optarg ) ) * 1024 * 1024 ; break ; case 'M' : settings . evict_to_free = 0 ; break ; case 'c' : settings . maxconns = atoi ( optarg ) ; if ( settings . maxconns <= 0 ) { fprintf ( stderr , ""Maximum<S2SV_blank>connections<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0\\n"" ) ; return 1 ; } break ; case 'h' : usage ( ) ; exit ( EXIT_SUCCESS ) ; case 'i' : usage_license ( ) ; exit ( EXIT_SUCCESS ) ; case 'V' : printf ( PACKAGE ""<S2SV_blank>"" VERSION ""\\n"" ) ; exit ( EXIT_SUCCESS ) ; case 'k' : lock_memory = true ; break ; case 'v' : settings . verbose ++ ; break ; case 'l' : if ( settings . inter != NULL ) { if ( strstr ( settings . inter , optarg ) != NULL ) { break ; } size_t len = strlen ( settings . inter ) + strlen ( optarg ) + 2 ; char * p = malloc ( len ) ; if ( p == NULL ) { fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory\\n"" ) ; return 1 ; } snprintf ( p , len , ""%s,%s"" , settings . inter , optarg ) ; free ( settings . inter ) ; settings . inter = p ; } else { settings . inter = strdup ( optarg ) ; } break ; case 'd' : do_daemonize = true ; break ; case 'r' : maxcore = 1 ; break ; case 'R' : settings . reqs_per_event = atoi ( optarg ) ; if ( settings . reqs_per_event == 0 ) { fprintf ( stderr , ""Number<S2SV_blank>of<S2SV_blank>requests<S2SV_blank>per<S2SV_blank>event<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0\\n"" ) ; return 1 ; } break ; case 'u' : username = optarg ; break ; case 'P' : pid_file = optarg ; break ; case 'f' : settings . factor = atof ( optarg ) ; if ( settings . factor <= 1.0 ) { fprintf ( stderr , ""Factor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>1\\n"" ) ; return 1 ; } break ; case 'n' : settings . chunk_size = atoi ( optarg ) ; if ( settings . chunk_size == 0 ) { fprintf ( stderr , ""Chunk<S2SV_blank>size<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0\\n"" ) ; return 1 ; } break ; case 't' : settings . num_threads = atoi ( optarg ) ; if ( settings . num_threads <= 0 ) { fprintf ( stderr , ""Number<S2SV_blank>of<S2SV_blank>threads<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0\\n"" ) ; return 1 ; } if ( settings . num_threads > 64 ) { fprintf ( stderr , ""WARNING:<S2SV_blank>Setting<S2SV_blank>a<S2SV_blank>high<S2SV_blank>number<S2SV_blank>of<S2SV_blank>worker"" ""threads<S2SV_blank>is<S2SV_blank>not<S2SV_blank>recommended.\\n"" ""<S2SV_blank>Set<S2SV_blank>this<S2SV_blank>value<S2SV_blank>to<S2SV_blank>the<S2SV_blank>number<S2SV_blank>of<S2SV_blank>cores<S2SV_blank>in"" ""<S2SV_blank>your<S2SV_blank>machine<S2SV_blank>or<S2SV_blank>less.\\n"" ) ; } break ; case 'D' : if ( ! optarg || ! optarg [ 0 ] ) { fprintf ( stderr , ""No<S2SV_blank>delimiter<S2SV_blank>specified\\n"" ) ; return 1 ; } settings . prefix_delimiter = optarg [ 0 ] ; settings . detail_enabled = 1 ; break ; case 'L' : if ( enable_large_pages ( ) == 0 ) { preallocate = true ; } else { fprintf ( stderr , ""Cannot<S2SV_blank>enable<S2SV_blank>large<S2SV_blank>pages<S2SV_blank>on<S2SV_blank>this<S2SV_blank>system\\n"" ""(There<S2SV_blank>is<S2SV_blank>no<S2SV_blank>Linux<S2SV_blank>support<S2SV_blank>as<S2SV_blank>of<S2SV_blank>this<S2SV_blank>version)\\n"" ) ; return 1 ; } break ; case 'C' : settings . use_cas = false ; break ; case 'b' : settings . backlog = atoi ( optarg ) ; break ; case 'B' : protocol_specified = true ; if ( strcmp ( optarg , ""auto"" ) == 0 ) { settings . binding_protocol = negotiating_prot ; } else if ( strcmp ( optarg , ""binary"" ) == 0 ) { settings . binding_protocol = binary_prot ; } else if ( strcmp ( optarg , ""ascii"" ) == 0 ) { settings . binding_protocol = ascii_prot ; } else { fprintf ( stderr , ""Invalid<S2SV_blank>value<S2SV_blank>for<S2SV_blank>binding<S2SV_blank>protocol:<S2SV_blank>%s\\n"" ""<S2SV_blank>--<S2SV_blank>should<S2SV_blank>be<S2SV_blank>one<S2SV_blank>of<S2SV_blank>auto,<S2SV_blank>binary,<S2SV_blank>or<S2SV_blank>ascii\\n"" , optarg ) ; exit ( EX_USAGE ) ; } break ; case 'I' : buf = strdup ( optarg ) ; unit = buf [ strlen ( buf ) - 1 ] ; if ( unit == 'k' || unit == 'm' || unit == 'K' || unit == 'M' ) { buf [ strlen ( buf ) - 1 ] = '\\0' ; size_max = atoi ( buf ) ; if ( unit == 'k' || unit == 'K' ) size_max *= 1024 ; if ( unit == 'm' || unit == 'M' ) size_max *= 1024 * 1024 ; settings . item_size_max = size_max ; } else { settings . item_size_max = atoi ( buf ) ; } free ( buf ) ; break ; case 'S' : # ifndef ENABLE_SASL fprintf ( stderr , ""This<S2SV_blank>server<S2SV_blank>is<S2SV_blank>not<S2SV_blank>built<S2SV_blank>with<S2SV_blank>SASL<S2SV_blank>support.\\n"" ) ; exit ( EX_USAGE ) ; # endif settings . sasl = true ; break ; case 'F' : settings . flush_enabled = false ; break ; case 'X' : settings . dump_enabled = false ; break ; case 'o' : subopts_orig = subopts = strdup ( optarg ) ; while ( * subopts != '\\0' ) { switch ( getsubopt ( & subopts , subopts_tokens , & subopts_value ) ) { case MAXCONNS_FAST : settings . maxconns_fast = true ; break ; case HASHPOWER_INIT : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>numeric<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>hashpower\\n"" ) ; return 1 ; } settings . hashpower_init = atoi ( subopts_value ) ; if ( settings . hashpower_init < 12 ) { fprintf ( stderr , ""Initial<S2SV_blank>hashtable<S2SV_blank>multiplier<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>low\\n"" , settings . hashpower_init ) ; return 1 ; } else if ( settings . hashpower_init > 32 ) { fprintf ( stderr , ""Initial<S2SV_blank>hashtable<S2SV_blank>multiplier<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>high\\n"" ""Choose<S2SV_blank>a<S2SV_blank>value<S2SV_blank>based<S2SV_blank>on<S2SV_blank>\\""STAT<S2SV_blank>hash_power_level\\""<S2SV_blank>from<S2SV_blank>a<S2SV_blank>running<S2SV_blank>instance\\n"" , settings . hashpower_init ) ; return 1 ; } break ; case NO_HASHEXPAND : start_assoc_maint = false ; break ; case SLAB_REASSIGN : settings . slab_reassign = true ; break ; case SLAB_AUTOMOVE : if ( subopts_value == NULL ) { settings . slab_automove = 1 ; break ; } settings . slab_automove = atoi ( subopts_value ) ; if ( settings . slab_automove < 0 || settings . slab_automove > 2 ) { fprintf ( stderr , ""slab_automove<S2SV_blank>must<S2SV_blank>be<S2SV_blank>between<S2SV_blank>0<S2SV_blank>and<S2SV_blank>2\\n"" ) ; return 1 ; } break ; case SLAB_AUTOMOVE_RATIO : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>slab_automove_ratio<S2SV_blank>argument\\n"" ) ; return 1 ; } settings . slab_automove_ratio = atof ( subopts_value ) ; if ( settings . slab_automove_ratio <= 0 || settings . slab_automove_ratio > 1 ) { fprintf ( stderr , ""slab_automove_ratio<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0<S2SV_blank>and<S2SV_blank><<S2SV_blank>1\\n"" ) ; return 1 ; } break ; case SLAB_AUTOMOVE_WINDOW : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>slab_automove_window<S2SV_blank>argument\\n"" ) ; return 1 ; } settings . slab_automove_window = atoi ( subopts_value ) ; if ( settings . slab_automove_window < 3 ) { fprintf ( stderr , ""slab_automove_window<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>2\\n"" ) ; return 1 ; } break ; case TAIL_REPAIR_TIME : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>numeric<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>tail_repair_time\\n"" ) ; return 1 ; } settings . tail_repair_time = atoi ( subopts_value ) ; if ( settings . tail_repair_time < 10 ) { fprintf ( stderr , ""Cannot<S2SV_blank>set<S2SV_blank>tail_repair_time<S2SV_blank>to<S2SV_blank>less<S2SV_blank>than<S2SV_blank>10<S2SV_blank>seconds\\n"" ) ; return 1 ; } break ; case HASH_ALGORITHM : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>hash_algorithm<S2SV_blank>argument\\n"" ) ; return 1 ; } ; if ( strcmp ( subopts_value , ""jenkins"" ) == 0 ) { hash_type = JENKINS_HASH ; } else if ( strcmp ( subopts_value , ""murmur3"" ) == 0 ) { hash_type = MURMUR3_HASH ; } else { fprintf ( stderr , ""Unknown<S2SV_blank>hash_algorithm<S2SV_blank>option<S2SV_blank>(jenkins,<S2SV_blank>murmur3)\\n"" ) ; return 1 ; } break ; case LRU_CRAWLER : start_lru_crawler = true ; break ; case LRU_CRAWLER_SLEEP : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>lru_crawler_sleep<S2SV_blank>value\\n"" ) ; return 1 ; } settings . lru_crawler_sleep = atoi ( subopts_value ) ; if ( settings . lru_crawler_sleep > 1000000 || settings . lru_crawler_sleep < 0 ) { fprintf ( stderr , ""LRU<S2SV_blank>crawler<S2SV_blank>sleep<S2SV_blank>must<S2SV_blank>be<S2SV_blank>between<S2SV_blank>0<S2SV_blank>and<S2SV_blank>1<S2SV_blank>second\\n"" ) ; return 1 ; } break ; case LRU_CRAWLER_TOCRAWL : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>lru_crawler_tocrawl<S2SV_blank>value\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & tocrawl ) ) { fprintf ( stderr , ""lru_crawler_tocrawl<S2SV_blank>takes<S2SV_blank>a<S2SV_blank>numeric<S2SV_blank>32bit<S2SV_blank>value\\n"" ) ; return 1 ; } settings . lru_crawler_tocrawl = tocrawl ; break ; case LRU_MAINTAINER : start_lru_maintainer = true ; settings . lru_segmented = true ; break ; case HOT_LRU_PCT : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>hot_lru_pct<S2SV_blank>argument\\n"" ) ; return 1 ; } settings . hot_lru_pct = atoi ( subopts_value ) ; if ( settings . hot_lru_pct < 1 || settings . hot_lru_pct >= 80 ) { fprintf ( stderr , ""hot_lru_pct<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>1<S2SV_blank>and<S2SV_blank><<S2SV_blank>80\\n"" ) ; return 1 ; } break ; case WARM_LRU_PCT : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>warm_lru_pct<S2SV_blank>argument\\n"" ) ; return 1 ; } settings . warm_lru_pct = atoi ( subopts_value ) ; if ( settings . warm_lru_pct < 1 || settings . warm_lru_pct >= 80 ) { fprintf ( stderr , ""warm_lru_pct<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>1<S2SV_blank>and<S2SV_blank><<S2SV_blank>80\\n"" ) ; return 1 ; } break ; case HOT_MAX_FACTOR : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>hot_max_factor<S2SV_blank>argument\\n"" ) ; return 1 ; } settings . hot_max_factor = atof ( subopts_value ) ; if ( settings . hot_max_factor <= 0 ) { fprintf ( stderr , ""hot_max_factor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0\\n"" ) ; return 1 ; } break ; case WARM_MAX_FACTOR : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>warm_max_factor<S2SV_blank>argument\\n"" ) ; return 1 ; } settings . warm_max_factor = atof ( subopts_value ) ; if ( settings . warm_max_factor <= 0 ) { fprintf ( stderr , ""warm_max_factor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0\\n"" ) ; return 1 ; } break ; case TEMPORARY_TTL : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>temporary_ttl<S2SV_blank>argument\\n"" ) ; return 1 ; } settings . temp_lru = true ; settings . temporary_ttl = atoi ( subopts_value ) ; break ; case IDLE_TIMEOUT : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>numeric<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>idle_timeout\\n"" ) ; return 1 ; } settings . idle_timeout = atoi ( subopts_value ) ; break ; case WATCHER_LOGBUF_SIZE : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>watcher_logbuf_size<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . logger_watcher_buf_size ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>watcher_logbuf_size\\n"" ) ; return 1 ; } settings . logger_watcher_buf_size *= 1024 ; break ; case WORKER_LOGBUF_SIZE : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>worker_logbuf_size<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . logger_buf_size ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>worker_logbuf_size\\n"" ) ; return 1 ; } settings . logger_buf_size *= 1024 ; case SLAB_SIZES : slab_sizes_unparsed = subopts_value ; break ; case SLAB_CHUNK_MAX : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>slab_chunk_max<S2SV_blank>argument\\n"" ) ; } if ( ! safe_strtol ( subopts_value , & settings . slab_chunk_size_max ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>slab_chunk_max\\n"" ) ; } slab_chunk_size_changed = true ; break ; case TRACK_SIZES : item_stats_sizes_init ( ) ; break ; case NO_INLINE_ASCII_RESP : settings . inline_ascii_response = false ; break ; case INLINE_ASCII_RESP : settings . inline_ascii_response = true ; break ; case NO_CHUNKED_ITEMS : settings . slab_chunk_size_max = settings . slab_page_size ; break ; case NO_SLAB_REASSIGN : settings . slab_reassign = false ; break ; case NO_SLAB_AUTOMOVE : settings . slab_automove = 0 ; break ; case NO_MAXCONNS_FAST : settings . maxconns_fast = false ; break ; case NO_LRU_CRAWLER : settings . lru_crawler = false ; start_lru_crawler = false ; break ; case NO_LRU_MAINTAINER : start_lru_maintainer = false ; settings . lru_segmented = false ; break ; # ifdef EXTSTORE case EXT_PAGE_SIZE : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_page_size<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & ext_cf . page_size ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_page_size\\n"" ) ; return 1 ; } ext_cf . page_size *= 1024 * 1024 ; break ; case EXT_PAGE_COUNT : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_page_count<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & ext_cf . page_count ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_page_count\\n"" ) ; return 1 ; } break ; case EXT_WBUF_SIZE : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_wbuf_size<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & ext_cf . wbuf_size ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_wbuf_size\\n"" ) ; return 1 ; } ext_cf . wbuf_size *= 1024 * 1024 ; settings . ext_wbuf_size = ext_cf . wbuf_size ; break ; case EXT_THREADS : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_threads<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & ext_cf . io_threadcount ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_threads\\n"" ) ; return 1 ; } break ; case EXT_IO_DEPTH : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_io_depth<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & ext_cf . io_depth ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_io_depth\\n"" ) ; return 1 ; } break ; case EXT_ITEM_SIZE : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_item_size<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . ext_item_size ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_item_size\\n"" ) ; return 1 ; } break ; case EXT_ITEM_AGE : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_item_age<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . ext_item_age ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_item_age\\n"" ) ; return 1 ; } break ; case EXT_LOW_TTL : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_low_ttl<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . ext_low_ttl ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_low_ttl\\n"" ) ; return 1 ; } break ; case EXT_RECACHE_RATE : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_recache_rate<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . ext_recache_rate ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_recache_rate\\n"" ) ; return 1 ; } break ; case EXT_COMPACT_UNDER : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_compact_under<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . ext_compact_under ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_compact_under\\n"" ) ; return 1 ; } break ; case EXT_DROP_UNDER : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_drop_under<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . ext_drop_under ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_drop_under\\n"" ) ; return 1 ; } break ; case EXT_MAX_FRAG : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_max_frag<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtod ( subopts_value , & settings . ext_max_frag ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_max_frag\\n"" ) ; return 1 ; } break ; case SLAB_AUTOMOVE_FREERATIO : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>slab_automove_freeratio<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtod ( subopts_value , & settings . slab_automove_freeratio ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>slab_automove_freeratio\\n"" ) ; return 1 ; } break ; case EXT_DROP_UNREAD : settings . ext_drop_unread = true ; break ; case EXT_PATH : storage_file = strdup ( subopts_value ) ; break ; # endif case MODERN : break ; case NO_MODERN : if ( ! slab_chunk_size_changed ) { settings . slab_chunk_size_max = settings . slab_page_size ; } settings . slab_reassign = false ; settings . slab_automove = 0 ; settings . maxconns_fast = false ; settings . inline_ascii_response = true ; settings . lru_segmented = false ; hash_type = JENKINS_HASH ; start_lru_crawler = false ; start_lru_maintainer = false ; break ; case NO_DROP_PRIVILEGES : settings . drop_privileges = false ; break ; # ifdef MEMCACHED_DEBUG case RELAXED_PRIVILEGES : settings . relaxed_privileges = true ; break ; # endif default : printf ( ""Illegal<S2SV_blank>suboption<S2SV_blank>\\""%s\\""\\n"" , subopts_value ) ; return 1 ; } } free ( subopts_orig ) ; break ; default : fprintf ( stderr , ""Illegal<S2SV_blank>argument<S2SV_blank>\\""%c\\""\\n"" , c ) ; return 1 ; } } if ( settings . item_size_max < 1024 ) { fprintf ( stderr , ""Item<S2SV_blank>max<S2SV_blank>size<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>less<S2SV_blank>than<S2SV_blank>1024<S2SV_blank>bytes.\\n"" ) ; exit ( EX_USAGE ) ; } if ( settings . item_size_max > ( settings . maxbytes / 2 ) ) { fprintf ( stderr , ""Cannot<S2SV_blank>set<S2SV_blank>item<S2SV_blank>size<S2SV_blank>limit<S2SV_blank>higher<S2SV_blank>than<S2SV_blank>1/2<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>max.\\n"" ) ; exit ( EX_USAGE ) ; } if ( settings . item_size_max > ( 1024 * 1024 * 1024 ) ) { fprintf ( stderr , ""Cannot<S2SV_blank>set<S2SV_blank>item<S2SV_blank>size<S2SV_blank>limit<S2SV_blank>higher<S2SV_blank>than<S2SV_blank>a<S2SV_blank>gigabyte.\\n"" ) ; exit ( EX_USAGE ) ; } if ( settings . item_size_max > 1024 * 1024 ) { if ( ! slab_chunk_size_changed ) { settings . slab_chunk_size_max = settings . slab_page_size / 2 ; } } if ( settings . slab_chunk_size_max > settings . item_size_max ) { fprintf ( stderr , ""slab_chunk_max<S2SV_blank>(bytes:<S2SV_blank>%d)<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>-I<S2SV_blank>(item_size_max<S2SV_blank>%d)\\n"" , settings . slab_chunk_size_max , settings . item_size_max ) ; exit ( EX_USAGE ) ; } if ( settings . item_size_max % settings . slab_chunk_size_max != 0 ) { fprintf ( stderr , ""-I<S2SV_blank>(item_size_max:<S2SV_blank>%d)<S2SV_blank>must<S2SV_blank>be<S2SV_blank>evenly<S2SV_blank>divisible<S2SV_blank>by<S2SV_blank>slab_chunk_max<S2SV_blank>(bytes:<S2SV_blank>%d)\\n"" , settings . item_size_max , settings . slab_chunk_size_max ) ; exit ( EX_USAGE ) ; } if ( settings . slab_page_size % settings . slab_chunk_size_max != 0 ) { fprintf ( stderr , ""slab_chunk_max<S2SV_blank>(bytes:<S2SV_blank>%d)<S2SV_blank>must<S2SV_blank>divide<S2SV_blank>evenly<S2SV_blank>into<S2SV_blank>%d<S2SV_blank>(slab_page_size)\\n"" , settings . slab_chunk_size_max , settings . slab_page_size ) ; exit ( EX_USAGE ) ; } # ifdef EXTSTORE if ( storage_file ) { if ( settings . item_size_max > ext_cf . wbuf_size ) { fprintf ( stderr , ""-I<S2SV_blank>(item_size_max:<S2SV_blank>%d)<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>ext_wbuf_size:<S2SV_blank>%d\\n"" , settings . item_size_max , ext_cf . wbuf_size ) ; exit ( EX_USAGE ) ; } if ( settings . inline_ascii_response ) { fprintf ( stderr , ""Cannot<S2SV_blank>use<S2SV_blank>inline_ascii_response<S2SV_blank>with<S2SV_blank>extstore<S2SV_blank>enabled\\n"" ) ; exit ( EX_USAGE ) ; } if ( settings . udpport ) { fprintf ( stderr , ""Cannot<S2SV_blank>use<S2SV_blank>UDP<S2SV_blank>with<S2SV_blank>extstore<S2SV_blank>enabled<S2SV_blank>(-U<S2SV_blank>0<S2SV_blank>to<S2SV_blank>disable)\\n"" ) ; exit ( EX_USAGE ) ; } } # endif if ( slab_sizes_unparsed != NULL ) { if ( _parse_slab_sizes ( slab_sizes_unparsed , slab_sizes ) ) { use_slab_sizes = true ; } else { exit ( EX_USAGE ) ; } } if ( settings . hot_lru_pct + settings . warm_lru_pct > 80 ) { fprintf ( stderr , ""hot_lru_pct<S2SV_blank>+<S2SV_blank>warm_lru_pct<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>more<S2SV_blank>than<S2SV_blank>80%%<S2SV_blank>combined\\n"" ) ; exit ( EX_USAGE ) ; } if ( settings . temp_lru && ! start_lru_maintainer ) { fprintf ( stderr , ""temporary_ttl<S2SV_blank>requires<S2SV_blank>lru_maintainer<S2SV_blank>to<S2SV_blank>be<S2SV_blank>enabled\\n"" ) ; exit ( EX_USAGE ) ; } if ( hash_init ( hash_type ) != 0 ) { fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>hash_algorithm!\\n"" ) ; exit ( EX_USAGE ) ; } if ( settings . inter != NULL && strchr ( settings . inter , ',' ) ) { settings . num_threads_per_udp = 1 ; } else { settings . num_threads_per_udp = settings . num_threads ; } if ( settings . sasl ) { if ( ! protocol_specified ) { settings . binding_protocol = binary_prot ; } else { if ( settings . binding_protocol != binary_prot ) { fprintf ( stderr , ""ERROR:<S2SV_blank>You<S2SV_blank>cannot<S2SV_blank>allow<S2SV_blank>the<S2SV_blank>ASCII<S2SV_blank>protocol<S2SV_blank>while<S2SV_blank>using<S2SV_blank>SASL.\\n"" ) ; exit ( EX_USAGE ) ; } } } <S2SV_StartBug> if ( tcp_specified && settings . port != 0 && ! udp_specified ) { <S2SV_EndBug> settings . udpport = settings . port ; } else if ( udp_specified && settings . udpport != 0 && ! tcp_specified ) { settings . port = settings . udpport ; } if ( maxcore != 0 ) { struct rlimit rlim_new ; if ( getrlimit ( RLIMIT_CORE , & rlim ) == 0 ) { rlim_new . rlim_cur = rlim_new . rlim_max = RLIM_INFINITY ; if ( setrlimit ( RLIMIT_CORE , & rlim_new ) != 0 ) { rlim_new . rlim_cur = rlim_new . rlim_max = rlim . rlim_max ; ( void ) setrlimit ( RLIMIT_CORE , & rlim_new ) ; } } if ( ( getrlimit ( RLIMIT_CORE , & rlim ) != 0 ) || rlim . rlim_cur == 0 ) { fprintf ( stderr , ""failed<S2SV_blank>to<S2SV_blank>ensure<S2SV_blank>corefile<S2SV_blank>creation\\n"" ) ; exit ( EX_OSERR ) ; } } if ( getrlimit ( RLIMIT_NOFILE , & rlim ) != 0 ) { fprintf ( stderr , ""failed<S2SV_blank>to<S2SV_blank>getrlimit<S2SV_blank>number<S2SV_blank>of<S2SV_blank>files\\n"" ) ; exit ( EX_OSERR ) ; } else { rlim . rlim_cur = settings . maxconns ; rlim . rlim_max = settings . maxconns ; if ( setrlimit ( RLIMIT_NOFILE , & rlim ) != 0 ) { fprintf ( stderr , ""failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>rlimit<S2SV_blank>for<S2SV_blank>open<S2SV_blank>files.<S2SV_blank>Try<S2SV_blank>starting<S2SV_blank>as<S2SV_blank>root<S2SV_blank>or<S2SV_blank>requesting<S2SV_blank>smaller<S2SV_blank>maxconns<S2SV_blank>value.\\n"" ) ; exit ( EX_OSERR ) ; } } if ( getuid ( ) == 0 || geteuid ( ) == 0 ) { if ( username == 0 || * username == '\\0' ) { fprintf ( stderr , ""can\'t<S2SV_blank>run<S2SV_blank>as<S2SV_blank>root<S2SV_blank>without<S2SV_blank>the<S2SV_blank>-u<S2SV_blank>switch\\n"" ) ; exit ( EX_USAGE ) ; } if ( ( pw = getpwnam ( username ) ) == 0 ) { fprintf ( stderr , ""can\'t<S2SV_blank>find<S2SV_blank>the<S2SV_blank>user<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>to\\n"" , username ) ; exit ( EX_NOUSER ) ; } if ( setgid ( pw -> pw_gid ) < 0 || setuid ( pw -> pw_uid ) < 0 ) { fprintf ( stderr , ""failed<S2SV_blank>to<S2SV_blank>assume<S2SV_blank>identity<S2SV_blank>of<S2SV_blank>user<S2SV_blank>%s\\n"" , username ) ; exit ( EX_OSERR ) ; } } if ( settings . sasl ) { init_sasl ( ) ; } if ( do_daemonize ) { if ( sigignore ( SIGHUP ) == - 1 ) { perror ( ""Failed<S2SV_blank>to<S2SV_blank>ignore<S2SV_blank>SIGHUP"" ) ; } if ( daemonize ( maxcore , settings . verbose ) == - 1 ) { fprintf ( stderr , ""failed<S2SV_blank>to<S2SV_blank>daemon()<S2SV_blank>in<S2SV_blank>order<S2SV_blank>to<S2SV_blank>daemonize\\n"" ) ; exit ( EXIT_FAILURE ) ; } } if ( lock_memory ) { # ifdef HAVE_MLOCKALL int res = mlockall ( MCL_CURRENT | MCL_FUTURE ) ; if ( res != 0 ) { fprintf ( stderr , ""warning:<S2SV_blank>-k<S2SV_blank>invalid,<S2SV_blank>mlockall()<S2SV_blank>failed:<S2SV_blank>%s\\n"" , strerror ( errno ) ) ; } # else fprintf ( stderr , ""warning:<S2SV_blank>-k<S2SV_blank>invalid,<S2SV_blank>mlockall()<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>on<S2SV_blank>this<S2SV_blank>platform.<S2SV_blank><S2SV_blank>proceeding<S2SV_blank>without.\\n"" ) ; # endif } # if defined ( LIBEVENT_VERSION_NUMBER ) && LIBEVENT_VERSION_NUMBER >= 0x02000101 struct event_config * ev_config ; ev_config = event_config_new ( ) ; event_config_set_flag ( ev_config , EVENT_BASE_FLAG_NOLOCK ) ; main_base = event_base_new_with_config ( ev_config ) ; event_config_free ( ev_config ) ; # else main_base = event_init ( ) ; # endif logger_init ( ) ; stats_init ( ) ; assoc_init ( settings . hashpower_init ) ; conn_init ( ) ; slabs_init ( settings . maxbytes , settings . factor , preallocate , use_slab_sizes ? slab_sizes : NULL ) ; # ifdef EXTSTORE if ( storage_file ) { enum extstore_res eres ; if ( settings . ext_compact_under == 0 ) { settings . ext_compact_under = ext_cf . page_count / 4 ; settings . ext_drop_under = ext_cf . page_count / 4 ; } crc32c_init ( ) ; for ( int x = 0 ; x < MAX_NUMBER_OF_SLAB_CLASSES ; x ++ ) { settings . ext_free_memchunks [ x ] = 0 ; } storage = extstore_init ( storage_file , & ext_cf , & eres ) ; if ( storage == NULL ) { fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>external<S2SV_blank>storage:<S2SV_blank>%s\\n"" , extstore_err ( eres ) ) ; if ( eres == EXTSTORE_INIT_OPEN_FAIL ) { perror ( ""extstore<S2SV_blank>open"" ) ; } exit ( EXIT_FAILURE ) ; } ext_storage = storage ; slabs_prefill_global ( ) ; } # endif if ( sigignore ( SIGPIPE ) == - 1 ) { perror ( ""failed<S2SV_blank>to<S2SV_blank>ignore<S2SV_blank>SIGPIPE;<S2SV_blank>sigaction"" ) ; exit ( EX_OSERR ) ; } # ifdef EXTSTORE slabs_set_storage ( storage ) ; memcached_thread_init ( settings . num_threads , storage ) ; init_lru_crawler ( storage ) ; # else memcached_thread_init ( settings . num_threads , NULL ) ; init_lru_crawler ( NULL ) ; # endif if ( start_assoc_maint && start_assoc_maintenance_thread ( ) == - 1 ) { exit ( EXIT_FAILURE ) ; } if ( start_lru_crawler && start_item_crawler_thread ( ) != 0 ) { fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>enable<S2SV_blank>LRU<S2SV_blank>crawler<S2SV_blank>thread\\n"" ) ; exit ( EXIT_FAILURE ) ; } # ifdef EXTSTORE if ( storage && start_storage_compact_thread ( storage ) != 0 ) { fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>start<S2SV_blank>storage<S2SV_blank>compaction<S2SV_blank>thread\\n"" ) ; exit ( EXIT_FAILURE ) ; } if ( start_lru_maintainer && start_lru_maintainer_thread ( storage ) != 0 ) { # else if ( start_lru_maintainer && start_lru_maintainer_thread ( NULL ) != 0 ) { # endif fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>enable<S2SV_blank>LRU<S2SV_blank>maintainer<S2SV_blank>thread\\n"" ) ; return 1 ; } if ( settings . slab_reassign && start_slab_maintenance_thread ( ) == - 1 ) { exit ( EXIT_FAILURE ) ; } if ( settings . idle_timeout && start_conn_timeout_thread ( ) == - 1 ) { exit ( EXIT_FAILURE ) ; } clock_handler ( 0 , 0 , 0 ) ; if ( settings . socketpath != NULL ) { errno = 0 ; if ( server_socket_unix ( settings . socketpath , settings . access ) ) { vperror ( ""failed<S2SV_blank>to<S2SV_blank>listen<S2SV_blank>on<S2SV_blank>UNIX<S2SV_blank>socket:<S2SV_blank>%s"" , settings . socketpath ) ; exit ( EX_OSERR ) ; } } if ( settings . socketpath == NULL ) { const char * portnumber_filename = getenv ( ""MEMCACHED_PORT_FILENAME"" ) ; char * temp_portnumber_filename = NULL ; size_t len ; FILE * portnumber_file = NULL ; if ( portnumber_filename != NULL ) { len = strlen ( portnumber_filename ) + 4 + 1 ; temp_portnumber_filename = malloc ( len ) ; snprintf ( temp_portnumber_filename , len , ""%s.lck"" , portnumber_filename ) ; portnumber_file = fopen ( temp_portnumber_filename , ""a"" ) ; if ( portnumber_file == NULL ) { fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>\\""%s\\"":<S2SV_blank>%s\\n"" , temp_portnumber_filename , strerror ( errno ) ) ; } } errno = 0 ; if ( settings . port && server_sockets ( settings . port , tcp_transport , portnumber_file ) ) { vperror ( ""failed<S2SV_blank>to<S2SV_blank>listen<S2SV_blank>on<S2SV_blank>TCP<S2SV_blank>port<S2SV_blank>%d"" , settings . port ) ; exit ( EX_OSERR ) ; } errno = 0 ; if ( settings . udpport && server_sockets ( settings . udpport , udp_transport , portnumber_file ) ) { vperror ( ""failed<S2SV_blank>to<S2SV_blank>listen<S2SV_blank>on<S2SV_blank>UDP<S2SV_blank>port<S2SV_blank>%d"" , settings . udpport ) ; exit ( EX_OSERR ) ; } if ( portnumber_file ) { fclose ( portnumber_file ) ; rename ( temp_portnumber_filename , portnumber_filename ) ; } if ( temp_portnumber_filename ) free ( temp_portnumber_filename ) ; } usleep ( 1000 ) ; if ( stats_state . curr_conns + stats_state . reserved_fds >= settings . maxconns - 1 ) { fprintf ( stderr , ""Maxconns<S2SV_blank>setting<S2SV_blank>is<S2SV_blank>too<S2SV_blank>low,<S2SV_blank>use<S2SV_blank>-c<S2SV_blank>to<S2SV_blank>increase.\\n"" ) ; exit ( EXIT_FAILURE ) ; } if ( pid_file != NULL ) { save_pid ( pid_file ) ; } if ( settings . drop_privileges ) { drop_privileges ( ) ; } uriencode_init ( ) ; if ( event_base_loop ( main_base , 0 ) != 0 ) { retval = EXIT_FAILURE ; } stop_assoc_maintenance_thread ( ) ; if ( do_daemonize ) remove_pidfile ( pid_file ) ; if ( settings . inter ) free ( settings . inter ) ; if ( l_socket ) free ( l_socket ) ; if ( u_socket ) free ( u_socket ) ; event_base_free ( main_base ) ; return retval ; }
","<S2SV_ModStart> } if ( <S2SV_ModEnd> udp_specified && settings
"
872,"CWE-190 static int vdbePmaReadBlob ( PmaReader * p , int nByte , u8 * * ppOut ) { int iBuf ; int nAvail ; if ( p -> aMap ) { * ppOut = & p -> aMap [ p -> iReadOff ] ; p -> iReadOff += nByte ; return SQLITE_OK ; } assert ( p -> aBuffer ) ; iBuf = p -> iReadOff % p -> nBuffer ; if ( iBuf == 0 ) { int nRead ; int rc ; if ( ( p -> iEof - p -> iReadOff ) > ( i64 ) p -> nBuffer ) { nRead = p -> nBuffer ; } else { nRead = ( int ) ( p -> iEof - p -> iReadOff ) ; } assert ( nRead > 0 ) ; rc = sqlite3OsRead ( p -> pFd , p -> aBuffer , nRead , p -> iReadOff ) ; assert ( rc != SQLITE_IOERR_SHORT_READ ) ; if ( rc != SQLITE_OK ) return rc ; } nAvail = p -> nBuffer - iBuf ; if ( nByte <= nAvail ) { * ppOut = & p -> aBuffer [ iBuf ] ; p -> iReadOff += nByte ; } else { int nRem ; if ( p -> nAlloc < nByte ) { u8 * aNew ; <S2SV_StartBug> int nNew = MAX ( 128 , p -> nAlloc * 2 ) ; <S2SV_EndBug> while ( nByte > nNew ) nNew = nNew * 2 ; aNew = sqlite3Realloc ( p -> aAlloc , nNew ) ; if ( ! aNew ) return SQLITE_NOMEM_BKPT ; p -> nAlloc = nNew ; p -> aAlloc = aNew ; } memcpy ( p -> aAlloc , & p -> aBuffer [ iBuf ] , nAvail ) ; p -> iReadOff += nAvail ; nRem = nByte - nAvail ; while ( nRem > 0 ) { int rc ; int nCopy ; u8 * aNext ; nCopy = nRem ; if ( nRem > p -> nBuffer ) nCopy = p -> nBuffer ; rc = vdbePmaReadBlob ( p , nCopy , & aNext ) ; if ( rc != SQLITE_OK ) return rc ; assert ( aNext != p -> aAlloc ) ; memcpy ( & p -> aAlloc [ nByte - nRem ] , aNext , nCopy ) ; nRem -= nCopy ; } * ppOut = p -> aAlloc ; } return SQLITE_OK ; }
","<S2SV_ModStart> * aNew ; sqlite3_int64 <S2SV_ModEnd> nNew = MAX <S2SV_ModStart> ( 128 , 2 * ( sqlite3_int64 ) <S2SV_ModStart> p -> nAlloc <S2SV_ModEnd> ) ; while
"
873,"CWE-119 int wasm_dis ( WasmOp * op , const unsigned char * buf , int buf_len ) { op -> len = 1 ; op -> op = buf [ 0 ] ; if ( op -> op > 0xbf ) { return 1 ; } WasmOpDef * opdef = & opcodes [ op -> op ] ; switch ( op -> op ) { case WASM_OP_TRAP : case WASM_OP_NOP : case WASM_OP_ELSE : case WASM_OP_RETURN : case WASM_OP_DROP : case WASM_OP_SELECT : case WASM_OP_I32EQZ : case WASM_OP_I32EQ : case WASM_OP_I32NE : case WASM_OP_I32LTS : case WASM_OP_I32LTU : case WASM_OP_I32GTS : case WASM_OP_I32GTU : case WASM_OP_I32LES : case WASM_OP_I32LEU : case WASM_OP_I32GES : case WASM_OP_I32GEU : case WASM_OP_I64EQZ : case WASM_OP_I64EQ : case WASM_OP_I64NE : case WASM_OP_I64LTS : case WASM_OP_I64LTU : case WASM_OP_I64GTS : case WASM_OP_I64GTU : case WASM_OP_I64LES : case WASM_OP_I64LEU : case WASM_OP_I64GES : case WASM_OP_I64GEU : case WASM_OP_F32EQ : case WASM_OP_F32NE : case WASM_OP_F32LT : case WASM_OP_F32GT : case WASM_OP_F32LE : case WASM_OP_F32GE : case WASM_OP_F64EQ : case WASM_OP_F64NE : case WASM_OP_F64LT : case WASM_OP_F64GT : case WASM_OP_F64LE : case WASM_OP_F64GE : case WASM_OP_I32CLZ : case WASM_OP_I32CTZ : case WASM_OP_I32POPCNT : case WASM_OP_I32ADD : case WASM_OP_I32SUB : case WASM_OP_I32MUL : case WASM_OP_I32DIVS : case WASM_OP_I32DIVU : case WASM_OP_I32REMS : case WASM_OP_I32REMU : case WASM_OP_I32AND : case WASM_OP_I32OR : case WASM_OP_I32XOR : case WASM_OP_I32SHL : case WASM_OP_I32SHRS : case WASM_OP_I32SHRU : case WASM_OP_I32ROTL : case WASM_OP_I32ROTR : case WASM_OP_I64CLZ : case WASM_OP_I64CTZ : case WASM_OP_I64POPCNT : case WASM_OP_I64ADD : case WASM_OP_I64SUB : case WASM_OP_I64MUL : case WASM_OP_I64DIVS : case WASM_OP_I64DIVU : case WASM_OP_I64REMS : case WASM_OP_I64REMU : case WASM_OP_I64AND : case WASM_OP_I64OR : case WASM_OP_I64XOR : case WASM_OP_I64SHL : case WASM_OP_I64SHRS : case WASM_OP_I64SHRU : case WASM_OP_I64ROTL : case WASM_OP_I64ROTR : case WASM_OP_F32ABS : case WASM_OP_F32NEG : case WASM_OP_F32CEIL : case WASM_OP_F32FLOOR : case WASM_OP_F32TRUNC : case WASM_OP_F32NEAREST : case WASM_OP_F32SQRT : case WASM_OP_F32ADD : case WASM_OP_F32SUB : case WASM_OP_F32MUL : case WASM_OP_F32DIV : case WASM_OP_F32MIN : case WASM_OP_F32MAX : case WASM_OP_F32COPYSIGN : case WASM_OP_F64ABS : case WASM_OP_F64NEG : case WASM_OP_F64CEIL : case WASM_OP_F64FLOOR : case WASM_OP_F64TRUNC : case WASM_OP_F64NEAREST : case WASM_OP_F64SQRT : case WASM_OP_F64ADD : case WASM_OP_F64SUB : case WASM_OP_F64MUL : case WASM_OP_F64DIV : case WASM_OP_F64MIN : case WASM_OP_F64MAX : case WASM_OP_F64COPYSIGN : case WASM_OP_I32WRAPI64 : case WASM_OP_I32TRUNCSF32 : case WASM_OP_I32TRUNCUF32 : case WASM_OP_I32TRUNCSF64 : case WASM_OP_I32TRUNCUF64 : case WASM_OP_I64EXTENDSI32 : case WASM_OP_I64EXTENDUI32 : case WASM_OP_I64TRUNCSF32 : case WASM_OP_I64TRUNCUF32 : case WASM_OP_I64TRUNCSF64 : case WASM_OP_I64TRUNCUF64 : case WASM_OP_F32CONVERTSI32 : case WASM_OP_F32CONVERTUI32 : case WASM_OP_F32CONVERTSI64 : case WASM_OP_F32CONVERTUI64 : case WASM_OP_F32DEMOTEF64 : case WASM_OP_F64CONVERTSI32 : case WASM_OP_F64CONVERTUI32 : case WASM_OP_F64CONVERTSI64 : case WASM_OP_F64CONVERTUI64 : case WASM_OP_F64PROMOTEF32 : case WASM_OP_I32REINTERPRETF32 : case WASM_OP_I64REINTERPRETF64 : case WASM_OP_F32REINTERPRETI32 : case WASM_OP_F64REINTERPRETI64 : case WASM_OP_END : { snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s"" , opdef -> txt ) ; } break ; case WASM_OP_BLOCK : case WASM_OP_LOOP : case WASM_OP_IF : { st32 val = 0 ; size_t n = read_i32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; switch ( 0x80 - val ) { case R_BIN_WASM_VALUETYPE_EMPTY : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s"" , opdef -> txt ) ; break ; case R_BIN_WASM_VALUETYPE_i32 : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>(result<S2SV_blank>i32)"" , opdef -> txt ) ; break ; case R_BIN_WASM_VALUETYPE_i64 : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>(result<S2SV_blank>i64)"" , opdef -> txt ) ; break ; case R_BIN_WASM_VALUETYPE_f32 : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>(result<S2SV_blank>f32)"" , opdef -> txt ) ; break ; case R_BIN_WASM_VALUETYPE_f64 : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>(result<S2SV_blank>f64)"" , opdef -> txt ) ; break ; default : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>(result<S2SV_blank>?)"" , opdef -> txt ) ; break ; } op -> len += n ; } break ; case WASM_OP_BR : case WASM_OP_BRIF : case WASM_OP_CALL : { ut32 val = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%d"" , opdef -> txt , val ) ; op -> len += n ; } break ; case WASM_OP_BRTABLE : { ut32 count = 0 , * table = NULL , def = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & count ) ; if ( ! ( n > 0 && n < buf_len ) ) { goto err ; } if ( ! ( table = calloc ( count , sizeof ( ut32 ) ) ) ) { goto err ; } int i = 0 ; op -> len += n ; for ( i = 0 ; i < count ; i ++ ) { n = read_u32_leb128 ( buf + op -> len , buf + buf_len , & table [ i ] ) ; if ( ! ( op -> len + n <= buf_len ) ) { goto beach ; } op -> len += n ; } n = read_u32_leb128 ( buf + op -> len , buf + buf_len , & def ) ; if ( ! ( n > 0 && n + op -> len < buf_len ) ) { goto beach ; } op -> len += n ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%d<S2SV_blank>"" , opdef -> txt , count ) ; <S2SV_StartBug> for ( i = 0 ; i < count && strlen ( op -> txt ) + 10 < R_ASM_BUFSIZE ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> int optxtlen = strlen ( op -> txt ) ; <S2SV_EndBug> snprintf ( op -> txt + optxtlen , R_ASM_BUFSIZE - optxtlen , ""%d<S2SV_blank>"" , table [ i ] ) ; <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> snprintf ( op -> txt + strlen ( op -> txt ) , R_ASM_BUFSIZE , ""%d"" , def ) ; <S2SV_EndBug> free ( table ) ; break ; beach : free ( table ) ; goto err ; } break ; case WASM_OP_CALLINDIRECT : { ut32 val = 0 , reserved = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; op -> len += n ; n = read_u32_leb128 ( buf + op -> len , buf + buf_len , & reserved ) ; if ( ! ( n == 1 && op -> len + n <= buf_len ) ) goto err ; reserved &= 0x1 ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%d<S2SV_blank>%d"" , opdef -> txt , val , reserved ) ; op -> len += n ; } break ; case WASM_OP_GETLOCAL : case WASM_OP_SETLOCAL : case WASM_OP_TEELOCAL : case WASM_OP_GETGLOBAL : case WASM_OP_SETGLOBAL : { ut32 val = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%d"" , opdef -> txt , val ) ; op -> len += n ; } break ; case WASM_OP_I32LOAD : case WASM_OP_I64LOAD : case WASM_OP_F32LOAD : case WASM_OP_F64LOAD : case WASM_OP_I32LOAD8S : case WASM_OP_I32LOAD8U : case WASM_OP_I32LOAD16S : case WASM_OP_I32LOAD16U : case WASM_OP_I64LOAD8S : case WASM_OP_I64LOAD8U : case WASM_OP_I64LOAD16S : case WASM_OP_I64LOAD16U : case WASM_OP_I64LOAD32S : case WASM_OP_I64LOAD32U : case WASM_OP_I32STORE : case WASM_OP_I64STORE : case WASM_OP_F32STORE : case WASM_OP_F64STORE : case WASM_OP_I32STORE8 : case WASM_OP_I32STORE16 : case WASM_OP_I64STORE8 : case WASM_OP_I64STORE16 : case WASM_OP_I64STORE32 : { ut32 flag = 0 , offset = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & flag ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; op -> len += n ; n = read_u32_leb128 ( buf + op -> len , buf + buf_len , & offset ) ; if ( ! ( n > 0 && op -> len + n <= buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%d<S2SV_blank>%d"" , opdef -> txt , flag , offset ) ; op -> len += n ; } break ; case WASM_OP_CURRENTMEMORY : case WASM_OP_GROWMEMORY : { ut32 reserved = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & reserved ) ; if ( ! ( n == 1 && n < buf_len ) ) goto err ; reserved &= 0x1 ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%d"" , opdef -> txt , reserved ) ; op -> len += n ; } break ; case WASM_OP_I32CONST : { st32 val = 0 ; size_t n = read_i32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%"" PFMT32d , opdef -> txt , val ) ; op -> len += n ; } break ; case WASM_OP_I64CONST : { st64 val = 0 ; size_t n = read_i64_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%"" PFMT64d , opdef -> txt , val ) ; op -> len += n ; } break ; case WASM_OP_F32CONST : { ut32 val = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; long double d = ( long double ) val ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%"" LDBLFMT , opdef -> txt , d ) ; op -> len += n ; } break ; case WASM_OP_F64CONST : { ut64 val = 0 ; size_t n = read_u64_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; long double d = ( long double ) val ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%"" LDBLFMT , opdef -> txt , d ) ; op -> len += n ; } break ; default : goto err ; } return op -> len ; err : op -> len = 1 ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""invalid"" ) ; return op -> len ; }
","<S2SV_ModStart> count ) ; char * txt = op -> txt ; int txtLen = strlen ( op -> txt ) ; int txtLeft = R_ASM_BUFSIZE - txtLen ; txt += txtLen ; <S2SV_ModStart> < count && txtLen <S2SV_ModEnd> + 10 < <S2SV_ModStart> ++ ) { snprintf ( txt , txtLeft <S2SV_ModEnd> , ""%d<S2SV_blank>"" , <S2SV_ModStart> ] ) ; txtLen = strlen ( txt ) ; txt += txtLen ; txtLeft -= txtLen ; <S2SV_ModStart> } snprintf ( txt , txtLeft - 1 <S2SV_ModEnd> , ""%d"" ,
"
874,"CWE-20 static int set_core_reg ( struct kvm_vcpu * vcpu , const struct kvm_one_reg * reg ) { __u32 __user * uaddr = ( __u32 __user * ) ( unsigned long ) reg -> addr ; struct kvm_regs * regs = vcpu_gp_regs ( vcpu ) ; int nr_regs = sizeof ( * regs ) / sizeof ( __u32 ) ; __uint128_t tmp ; void * valp = & tmp ; u64 off ; int err = 0 ; off = core_reg_offset_from_id ( reg -> id ) ; if ( off >= nr_regs || ( off + ( KVM_REG_SIZE ( reg -> id ) / sizeof ( __u32 ) ) ) >= nr_regs ) return - ENOENT ; if ( validate_core_offset ( reg ) ) return - EINVAL ; if ( KVM_REG_SIZE ( reg -> id ) > sizeof ( tmp ) ) return - EINVAL ; if ( copy_from_user ( valp , uaddr , KVM_REG_SIZE ( reg -> id ) ) ) { err = - EFAULT ; goto out ; } if ( off == KVM_REG_ARM_CORE_REG ( regs . pstate ) ) { <S2SV_StartBug> u32 mode = ( * ( u32 * ) valp ) & PSR_AA32_MODE_MASK ; <S2SV_EndBug> switch ( mode ) { case PSR_AA32_MODE_USR : <S2SV_StartBug> case PSR_AA32_MODE_FIQ : <S2SV_EndBug> case PSR_AA32_MODE_IRQ : case PSR_AA32_MODE_SVC : case PSR_AA32_MODE_ABT : case PSR_AA32_MODE_UND : <S2SV_StartBug> case PSR_MODE_EL0t : <S2SV_EndBug> case PSR_MODE_EL1t : <S2SV_StartBug> case PSR_MODE_EL1h : <S2SV_EndBug> break ; default : err = - EINVAL ; goto out ; } } memcpy ( ( u32 * ) regs + off , valp , KVM_REG_SIZE ( reg -> id ) ) ; out : return err ; }
","<S2SV_ModStart> ) ) { u64 <S2SV_ModEnd> mode = ( <S2SV_ModStart> ( * ( u64 <S2SV_ModEnd> * ) valp <S2SV_ModStart> case PSR_AA32_MODE_USR : if ( ! system_supports_32bit_el0 ( ) ) return - EINVAL ; break ; <S2SV_ModStart> case PSR_AA32_MODE_UND : if ( ! vcpu_el1_is_32bit ( vcpu ) ) return - EINVAL ; break ; <S2SV_ModStart> case PSR_MODE_EL1h : if ( vcpu_el1_is_32bit ( vcpu ) ) return - EINVAL ;
"
875,"CWE-399 void serveloop ( GArray * servers ) { struct sockaddr_storage addrin ; socklen_t addrinlen = sizeof ( addrin ) ; int i ; int max ; fd_set mset ; fd_set rset ; max = 0 ; FD_ZERO ( & mset ) ; for ( i = 0 ; i < servers -> len ; i ++ ) { int sock ; if ( ( sock = ( g_array_index ( servers , SERVER , i ) ) . socket ) >= 0 ) { FD_SET ( sock , & mset ) ; max = sock > max ? sock : max ; } } for ( i = 0 ; i < modernsocks -> len ; i ++ ) { int sock = g_array_index ( modernsocks , int , i ) ; FD_SET ( sock , & mset ) ; max = sock > max ? sock : max ; } for ( ; ; ) { if ( is_sighup_caught ) { int n ; GError * gerror = NULL ; msg ( LOG_INFO , ""reconfiguration<S2SV_blank>request<S2SV_blank>received"" ) ; is_sighup_caught = 0 ; n = append_new_servers ( servers , & gerror ) ; if ( n == - 1 ) msg ( LOG_ERR , ""failed<S2SV_blank>to<S2SV_blank>append<S2SV_blank>new<S2SV_blank>servers:<S2SV_blank>%s"" , gerror -> message ) ; for ( i = servers -> len - n ; i < servers -> len ; ++ i ) { const SERVER server = g_array_index ( servers , SERVER , i ) ; if ( server . socket >= 0 ) { FD_SET ( server . socket , & mset ) ; max = server . socket > max ? server . socket : max ; } msg ( LOG_INFO , ""reconfigured<S2SV_blank>new<S2SV_blank>server:<S2SV_blank>%s"" , server . servename ) ; } } memcpy ( & rset , & mset , sizeof ( fd_set ) ) ; if ( select ( max + 1 , & rset , NULL , NULL , NULL ) > 0 ) { <S2SV_StartBug> int net ; <S2SV_EndBug> DEBUG ( ""accept,<S2SV_blank>"" ) ; for ( i = 0 ; i < modernsocks -> len ; i ++ ) { int sock = g_array_index ( modernsocks , int , i ) ; if ( ! FD_ISSET ( sock , & rset ) ) { continue ; } <S2SV_StartBug> CLIENT * client ; <S2SV_EndBug> <S2SV_StartBug> if ( ( net = accept ( sock , ( struct sockaddr * ) & addrin , & addrinlen ) ) < 0 ) { <S2SV_EndBug> err_nonfatal ( ""accept:<S2SV_blank>%m"" ) ; continue ; } <S2SV_StartBug> client = negotiate ( net , NULL , servers , NEG_INIT | NEG_MODERN ) ; <S2SV_EndBug> if ( ! client ) { close ( net ) ; continue ; } handle_connection ( servers , net , client -> server , client ) ; } for ( i = 0 ; i < servers -> len ; i ++ ) { SERVER * serve ; serve = & ( g_array_index ( servers , SERVER , i ) ) ; if ( serve -> socket < 0 ) { continue ; } if ( FD_ISSET ( serve -> socket , & rset ) ) { if ( ( net = accept ( serve -> socket , ( struct sockaddr * ) & addrin , & addrinlen ) ) < 0 ) { err_nonfatal ( ""accept:<S2SV_blank>%m"" ) ; continue ; } handle_connection ( servers , net , serve , NULL ) ; } } } } }
","<S2SV_ModStart> 0 ) { <S2SV_ModEnd> DEBUG ( ""accept,<S2SV_blank>"" <S2SV_ModStart> continue ; } handle_modern_connection ( servers , sock ) ; } for ( i = 0 ; i < servers -> len ; i ++ ) { int net ; SERVER * serve ; serve = & ( g_array_index ( servers , SERVER , i ) ) ; if ( serve -> socket < 0 ) { continue ; } if ( FD_ISSET ( serve -> socket , & rset ) ) { <S2SV_ModEnd> if ( ( <S2SV_ModStart> = accept ( serve -> socket <S2SV_ModEnd> , ( struct <S2SV_ModStart> continue ; } handle_connection ( servers , net , serve , NULL <S2SV_ModEnd> ) ; }
"
876,"CWE-399 <S2SV_StartBug> void <S2SV_EndBug> crm_send_remote_msg ( void * session , xmlNode * msg , gboolean encrypted ) { <S2SV_StartBug> if ( encrypted ) { <S2SV_EndBug> # ifdef HAVE_GNUTLS_GNUTLS_H cib_send_tls ( session , msg ) ; <S2SV_StartBug> # else <S2SV_EndBug> CRM_ASSERT ( encrypted == FALSE ) ; # endif } else { <S2SV_StartBug> cib_send_plaintext ( GPOINTER_TO_INT ( session ) , msg ) ; <S2SV_EndBug> } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> int <S2SV_ModEnd> crm_send_remote_msg ( void <S2SV_ModStart> encrypted ) { int rc = - 1 ; char * xml_text = NULL ; int len = 0 ; xml_text = dump_xml_unformatted ( <S2SV_ModEnd> msg ) ; <S2SV_ModStart> msg ) ; if ( xml_text ) { len = strlen ( xml_text ) ; <S2SV_ModEnd> } else { <S2SV_ModStart> } else { crm_err ( ""Invalid<S2SV_blank>XML,<S2SV_blank>can<S2SV_blank>not<S2SV_blank>send<S2SV_blank>msg"" ) ; return - 1 ; } rc = crm_send_remote_msg_raw ( session , xml_text , len , encrypted ) ; if ( rc < 0 ) { goto done ; } rc = crm_send_remote_msg_raw ( session , REMOTE_MSG_TERMINATOR , strlen ( REMOTE_MSG_TERMINATOR ) , encrypted ) ; done : if ( rc < 0 ) { crm_err ( ""Failed<S2SV_blank>to<S2SV_blank>send<S2SV_blank>remote<S2SV_blank>msg,<S2SV_blank>rc<S2SV_blank>=<S2SV_blank>%d"" , rc <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } free ( xml_text ) ; return rc ;
"
877,"CWE-189 static void nfs4_xdr_enc_getacl ( struct rpc_rqst * req , struct xdr_stream * xdr , struct nfs_getaclargs * args ) { struct compound_hdr hdr = { . minorversion = nfs4_xdr_minorversion ( & args -> seq_args ) , } ; uint32_t replen ; encode_compound_hdr ( xdr , req , & hdr ) ; encode_sequence ( xdr , & args -> seq_args , & hdr ) ; encode_putfh ( xdr , args -> fh , & hdr ) ; <S2SV_StartBug> replen = hdr . replen + op_decode_hdr_maxsz + nfs4_fattr_bitmap_maxsz + 1 ; <S2SV_EndBug> encode_getattr_two ( xdr , FATTR4_WORD0_ACL , 0 , & hdr ) ; xdr_inline_pages ( & req -> rq_rcv_buf , replen << 2 , args -> acl_pages , args -> acl_pgbase , args -> acl_len ) ; <S2SV_StartBug> encode_nops ( & hdr ) ; <S2SV_EndBug> }
","<S2SV_ModStart> + op_decode_hdr_maxsz + <S2SV_ModEnd> 1 ; encode_getattr_two <S2SV_ModStart> acl_len ) ; xdr_set_scratch_buffer ( xdr , page_address ( args -> acl_scratch ) , PAGE_SIZE ) ;
"
878,"CWE-000 int simple_set_acl ( struct inode * inode , struct posix_acl * acl , int type ) { int error ; if ( type == ACL_TYPE_ACCESS ) { <S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> <S2SV_StartBug> if ( error < 0 ) <S2SV_EndBug> return 0 ; if ( error == 0 ) acl = NULL ; } inode -> i_ctime = current_time ( inode ) ; set_cached_acl ( inode , type , acl ) ; return 0 ; }
","<S2SV_ModStart> { error = posix_acl_update_mode ( inode <S2SV_ModEnd> , & inode <S2SV_ModStart> inode -> i_mode , & acl <S2SV_ModStart> if ( error ) return error <S2SV_ModEnd> ; } inode
"
879,"CWE-74 PS_SERIALIZER_DECODE_FUNC ( php_binary ) { const char * p ; char * name ; const char * endptr = val + vallen ; zval * current ; int namelen ; int has_value ; php_unserialize_data_t var_hash ; <S2SV_StartBug> PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; <S2SV_EndBug> for ( p = val ; p < endptr ; ) { <S2SV_StartBug> zval * * tmp ; <S2SV_EndBug> namelen = ( ( unsigned char ) ( * p ) ) & ( ~ PS_BIN_UNDEF ) ; if ( namelen < 0 || namelen > PS_BIN_MAX || ( p + namelen ) >= endptr ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; return FAILURE ; } has_value = * p & PS_BIN_UNDEF ? 0 : 1 ; name = estrndup ( p + 1 , namelen ) ; p += namelen + 1 ; if ( zend_hash_find ( & EG ( symbol_table ) , name , namelen + 1 , ( void * * ) & tmp ) == SUCCESS ) { if ( ( Z_TYPE_PP ( tmp ) == IS_ARRAY && Z_ARRVAL_PP ( tmp ) == & EG ( symbol_table ) ) || * tmp == PS ( http_session_vars ) ) { <S2SV_StartBug> efree ( name ) ; <S2SV_EndBug> continue ; } } if ( has_value ) { ALLOC_INIT_ZVAL ( current ) ; if ( php_var_unserialize ( & current , ( const unsigned char * * ) & p , ( const unsigned char * ) endptr , & var_hash TSRMLS_CC ) ) { <S2SV_StartBug> php_set_session_var ( name , namelen , current , & var_hash TSRMLS_CC ) ; <S2SV_EndBug> } else { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; return FAILURE ; } var_push_dtor_no_addref ( & var_hash , & current ) ; } <S2SV_StartBug> PS_ADD_VARL ( name , namelen ) ; <S2SV_EndBug> efree ( name ) ; } PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; return SUCCESS ; }
","<S2SV_ModStart> php_unserialize_data_t var_hash ; int skip = 0 ; <S2SV_ModStart> * * tmp ; skip = 0 <S2SV_ModStart> ) ) { skip = 1 <S2SV_ModEnd> ; } } <S2SV_ModStart> ) ) { if ( ! skip ) { <S2SV_ModStart> TSRMLS_CC ) ; } <S2SV_ModStart> ) ; } if ( ! skip ) { <S2SV_ModStart> namelen ) ; }
"
880,"CWE-269 static int __poke_user ( struct task_struct * child , addr_t addr , addr_t data ) { struct user * dummy = NULL ; addr_t offset ; if ( addr < ( addr_t ) & dummy -> regs . acrs ) { if ( addr == ( addr_t ) & dummy -> regs . psw . mask ) { unsigned long mask = PSW_MASK_USER ; mask |= is_ri_task ( child ) ? PSW_MASK_RI : 0 ; <S2SV_StartBug> if ( ( data & ~ mask ) != PSW_USER_BITS ) <S2SV_EndBug> return - EINVAL ; if ( ( data & PSW_MASK_EA ) && ! ( data & PSW_MASK_BA ) ) return - EINVAL ; } * ( addr_t * ) ( ( addr_t ) & task_pt_regs ( child ) -> psw + addr ) = data ; } else if ( addr < ( addr_t ) ( & dummy -> regs . orig_gpr2 ) ) { offset = addr - ( addr_t ) & dummy -> regs . acrs ; # ifdef CONFIG_64BIT if ( addr == ( addr_t ) & dummy -> regs . acrs [ 15 ] ) child -> thread . acrs [ 15 ] = ( unsigned int ) ( data >> 32 ) ; else # endif * ( addr_t * ) ( ( addr_t ) & child -> thread . acrs + offset ) = data ; } else if ( addr == ( addr_t ) & dummy -> regs . orig_gpr2 ) { task_pt_regs ( child ) -> orig_gpr2 = data ; } else if ( addr < ( addr_t ) & dummy -> regs . fp_regs ) { return 0 ; } else if ( addr < ( addr_t ) ( & dummy -> regs . fp_regs + 1 ) ) { if ( addr == ( addr_t ) & dummy -> regs . fp_regs . fpc ) if ( ( unsigned int ) data != 0 || test_fp_ctl ( data >> ( BITS_PER_LONG - 32 ) ) ) return - EINVAL ; offset = addr - ( addr_t ) & dummy -> regs . fp_regs ; * ( addr_t * ) ( ( addr_t ) & child -> thread . fp_regs + offset ) = data ; } else if ( addr < ( addr_t ) ( & dummy -> regs . per_info + 1 ) ) { addr -= ( addr_t ) & dummy -> regs . per_info ; __poke_user_per ( child , addr , data ) ; } return 0 ; }
","<S2SV_ModStart> ( ( data ^ PSW_USER_BITS ) <S2SV_ModStart> ~ mask ) return - EINVAL ; if ( ( data & PSW_MASK_ASC ) == PSW_ASC_HOME <S2SV_ModEnd> ) return -
"
881,"CWE-787 STREAM sec_recv ( RD_BOOL * is_fastpath ) { uint8 fastpath_hdr , fastpath_flags ; uint16 sec_flags ; uint16 channel ; STREAM s ; <S2SV_StartBug> while ( ( s = mcs_recv ( & channel , is_fastpath , & fastpath_hdr ) ) != NULL ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> if ( * is_fastpath == True ) { fastpath_flags = ( fastpath_hdr & 0xC0 ) >> 6 ; if ( fastpath_flags & FASTPATH_OUTPUT_ENCRYPTED ) <S2SV_StartBug> { <S2SV_EndBug> in_uint8s ( s , 8 ) ; sec_decrypt ( s -> p , s -> end - s -> p ) ; } return s ; } if ( g_encryption || ( ! g_licence_issued && ! g_licence_error_result ) ) { in_uint16_le ( s , sec_flags ) ; in_uint8s ( s , 2 ) ; if ( g_encryption ) { if ( sec_flags & SEC_ENCRYPT ) { <S2SV_StartBug> in_uint8s ( s , 8 ) ; <S2SV_EndBug> sec_decrypt ( s -> p , s -> end - s -> p ) ; } if ( sec_flags & SEC_LICENSE_PKT ) { licence_process ( s ) ; continue ; } if ( sec_flags & SEC_REDIRECTION_PKT ) { <S2SV_StartBug> uint8 swapbyte ; <S2SV_EndBug> in_uint8s ( s , 8 ) ; sec_decrypt ( s -> p , s -> end - s -> p ) ; if ( s -> p [ 0 ] == 0 && s -> p [ 1 ] == 4 ) { swapbyte = s -> p [ 0 ] ; s -> p [ 0 ] = s -> p [ 2 ] ; s -> p [ 2 ] = swapbyte ; swapbyte = s -> p [ 1 ] ; s -> p [ 1 ] = s -> p [ 3 ] ; s -> p [ 3 ] = swapbyte ; swapbyte = s -> p [ 2 ] ; s -> p [ 2 ] = s -> p [ 3 ] ; s -> p [ 3 ] = swapbyte ; } } } else { if ( sec_flags & SEC_LICENSE_PKT ) { licence_process ( s ) ; continue ; } s -> p -= 4 ; } } if ( channel != MCS_GLOBAL_CHANNEL ) { channel_process ( s , channel ) ; continue ; } return s ; } return NULL ; }
","<S2SV_ModStart> STREAM s ; struct stream packet ; <S2SV_ModStart> NULL ) { packet = * s ; <S2SV_ModStart> FASTPATH_OUTPUT_ENCRYPTED ) { if ( ! s_check_rem ( s , 8 ) ) { rdp_protocol_error ( ""sec_recv(),<S2SV_blank>consume<S2SV_blank>fastpath<S2SV_blank>signature<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ; } <S2SV_ModStart> SEC_ENCRYPT ) { if ( ! s_check_rem ( s , 8 ) ) { rdp_protocol_error ( ""sec_recv(),<S2SV_blank>consume<S2SV_blank>encrypt<S2SV_blank>signature<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ; } <S2SV_ModStart> uint8 swapbyte ; if ( ! s_check_rem ( s , 8 ) ) { rdp_protocol_error ( ""sec_recv(),<S2SV_blank>consume<S2SV_blank>redirect<S2SV_blank>signature<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ; }
"
882,"CWE-125 static int str_lower_case_match ( OnigEncoding enc , int case_fold_flag , const UChar * t , const UChar * tend , const UChar * p , const UChar * end ) { int lowlen ; UChar * q , lowbuf [ ONIGENC_MBC_CASE_FOLD_MAXLEN ] ; while ( t < tend ) { lowlen = ONIGENC_MBC_CASE_FOLD ( enc , case_fold_flag , & p , end , lowbuf ) ; q = lowbuf ; while ( lowlen > 0 ) { <S2SV_StartBug> if ( * t ++ != * q ++ ) return 0 ; <S2SV_EndBug> lowlen -- ; } } return 1 ; }
","<S2SV_ModStart> { if ( t >= tend ) return 0 ; if (
"
883,"CWE-119 ssize_t cdf_read_sector ( const cdf_info_t * info , void * buf , size_t offs , size_t len , const cdf_header_t * h , cdf_secid_t id ) { <S2SV_StartBug> assert ( ( size_t ) CDF_SEC_SIZE ( h ) == len ) ; <S2SV_EndBug> <S2SV_StartBug> return cdf_read ( info , ( off_t ) CDF_SEC_POS ( h , id ) , <S2SV_EndBug> ( ( char * ) buf ) + offs , len ) ; }
","<S2SV_ModStart> id ) { size_t ss = <S2SV_ModEnd> CDF_SEC_SIZE ( h <S2SV_ModStart> ( h ) ; size_t pos = CDF_SEC_POS ( h , id ) ; assert ( ss <S2SV_ModStart> ( off_t ) pos , <S2SV_ModEnd> ( ( char
"
884,"CWE-200 static int load_script ( struct linux_binprm * bprm ) { const char * i_arg , * i_name ; char * cp ; struct file * file ; char interp [ BINPRM_BUF_SIZE ] ; int retval ; if ( ( bprm -> buf [ 0 ] != '#' ) || ( bprm -> buf [ 1 ] != '!' ) ) return - ENOEXEC ; allow_write_access ( bprm -> file ) ; fput ( bprm -> file ) ; bprm -> file = NULL ; bprm -> buf [ BINPRM_BUF_SIZE - 1 ] = '\\0' ; if ( ( cp = strchr ( bprm -> buf , '\\n' ) ) == NULL ) cp = bprm -> buf + BINPRM_BUF_SIZE - 1 ; * cp = '\\0' ; while ( cp > bprm -> buf ) { cp -- ; if ( ( * cp == '<S2SV_blank>' ) || ( * cp == '\\t' ) ) * cp = '\\0' ; else break ; } for ( cp = bprm -> buf + 2 ; ( * cp == '<S2SV_blank>' ) || ( * cp == '\\t' ) ; cp ++ ) ; if ( * cp == '\\0' ) return - ENOEXEC ; i_name = cp ; i_arg = NULL ; for ( ; * cp && ( * cp != '<S2SV_blank>' ) && ( * cp != '\\t' ) ; cp ++ ) ; while ( ( * cp == '<S2SV_blank>' ) || ( * cp == '\\t' ) ) * cp ++ = '\\0' ; if ( * cp ) i_arg = cp ; strcpy ( interp , i_name ) ; retval = remove_arg_zero ( bprm ) ; if ( retval ) return retval ; retval = copy_strings_kernel ( 1 , & bprm -> interp , bprm ) ; if ( retval < 0 ) return retval ; bprm -> argc ++ ; if ( i_arg ) { retval = copy_strings_kernel ( 1 , & i_arg , bprm ) ; if ( retval < 0 ) return retval ; bprm -> argc ++ ; } retval = copy_strings_kernel ( 1 , & i_name , bprm ) ; if ( retval ) return retval ; bprm -> argc ++ ; <S2SV_StartBug> bprm -> interp = interp ; <S2SV_EndBug> file = open_exec ( interp ) ; if ( IS_ERR ( file ) ) return PTR_ERR ( file ) ; bprm -> file = file ; retval = prepare_binprm ( bprm ) ; if ( retval < 0 ) return retval ; <S2SV_StartBug> return search_binary_handler ( bprm ) ; <S2SV_EndBug> }
","<S2SV_ModStart> argc ++ ; retval = bprm_change_interp ( interp , <S2SV_ModEnd> bprm ) ; <S2SV_ModStart> return retval ; file = open_exec ( interp ) ; if ( IS_ERR ( file ) ) return PTR_ERR ( file ) ; bprm -> file = file ; retval = prepare_binprm ( bprm ) ; if ( retval < 0 ) return retval ;
"
885,"CWE-119 static int su3000_i2c_transfer ( struct i2c_adapter * adap , struct i2c_msg msg [ ] , int num ) { struct dvb_usb_device * d = i2c_get_adapdata ( adap ) ; <S2SV_StartBug> u8 obuf [ 0x40 ] , ibuf [ 0x40 ] ; <S2SV_EndBug> if ( ! d ) return - ENODEV ; <S2SV_StartBug> if ( mutex_lock_interruptible ( & d -> i2c_mutex ) < 0 ) <S2SV_EndBug> return - EAGAIN ; <S2SV_StartBug> switch ( num ) { <S2SV_EndBug> case 1 : switch ( msg [ 0 ] . addr ) { case SU3000_STREAM_CTRL : <S2SV_StartBug> obuf [ 0 ] = msg [ 0 ] . buf [ 0 ] + 0x36 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = 3 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 0 , 0 ) < 0 ) <S2SV_EndBug> err ( ""i2c<S2SV_blank>transfer<S2SV_blank>failed."" ) ; break ; case DW2102_RC_QUERY : <S2SV_StartBug> obuf [ 0 ] = 0x10 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 1 , ibuf , 2 , 0 ) < 0 ) <S2SV_EndBug> err ( ""i2c<S2SV_blank>transfer<S2SV_blank>failed."" ) ; <S2SV_StartBug> msg [ 0 ] . buf [ 1 ] = ibuf [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> msg [ 0 ] . buf [ 0 ] = ibuf [ 1 ] ; <S2SV_EndBug> break ; default : <S2SV_StartBug> obuf [ 0 ] = 0x08 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = msg [ 0 ] . addr ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = msg [ 0 ] . len ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & obuf [ 3 ] , msg [ 0 ] . buf , msg [ 0 ] . len ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , msg [ 0 ] . len + 3 , <S2SV_EndBug> <S2SV_StartBug> ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> err ( ""i2c<S2SV_blank>transfer<S2SV_blank>failed."" ) ; } break ; case 2 : <S2SV_StartBug> obuf [ 0 ] = 0x09 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = msg [ 0 ] . len ; <S2SV_EndBug> obuf [ 2 ] = msg [ 1 ] . len ; <S2SV_StartBug> obuf [ 3 ] = msg [ 0 ] . addr ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & obuf [ 4 ] , msg [ 0 ] . buf , msg [ 0 ] . len ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , msg [ 0 ] . len + 4 , <S2SV_EndBug> <S2SV_StartBug> ibuf , msg [ 1 ] . len + 1 , 0 ) < 0 ) <S2SV_EndBug> err ( ""i2c<S2SV_blank>transfer<S2SV_blank>failed."" ) ; <S2SV_StartBug> memcpy ( msg [ 1 ] . buf , & ibuf [ 1 ] , msg [ 1 ] . len ) ; <S2SV_EndBug> break ; default : warn ( ""more<S2SV_blank>than<S2SV_blank>2<S2SV_blank>i2c<S2SV_blank>messages<S2SV_blank>at<S2SV_blank>a<S2SV_blank>time<S2SV_blank>is<S2SV_blank>not<S2SV_blank>handled<S2SV_blank>yet."" ) ; break ; } <S2SV_StartBug> mutex_unlock ( & d -> i2c_mutex ) ; <S2SV_EndBug> return num ; }
","<S2SV_ModStart> adap ) ; struct dw2102_state * state <S2SV_ModEnd> ; if ( <S2SV_ModStart> - ENODEV ; state = d -> priv ; <S2SV_ModStart> - EAGAIN ; if ( mutex_lock_interruptible ( & d -> data_mutex ) < 0 ) { mutex_unlock ( & d -> i2c_mutex ) ; return - EAGAIN ; } <S2SV_ModStart> case SU3000_STREAM_CTRL : state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> + 0x36 ; state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> = 3 ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 0 , <S2SV_ModStart> case DW2102_RC_QUERY : state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> ( d , state -> data , 1 , state -> data <S2SV_ModEnd> , 2 , <S2SV_ModStart> 1 ] = state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> 0 ] = state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> ; default : state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0x08 ; state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> . addr ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> memcpy ( & state -> data <S2SV_ModEnd> [ 3 ] <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , msg [ <S2SV_ModStart> + 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> case 2 : state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0x09 ; state -> data [ 1 ] = msg [ 0 ] . len ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> . len ; state -> data <S2SV_ModEnd> [ 3 ] <S2SV_ModStart> memcpy ( & state -> data <S2SV_ModEnd> [ 4 ] <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , msg [ <S2SV_ModStart> + 4 , state -> data <S2SV_ModEnd> , msg [ <S2SV_ModStart> buf , & state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> & d -> data_mutex ) ; mutex_unlock ( & d ->
"
886,"CWE-20 static void br_multicast_del_pg ( struct net_bridge * br , struct net_bridge_port_group * pg ) { struct net_bridge_mdb_htable * mdb ; struct net_bridge_mdb_entry * mp ; struct net_bridge_port_group * p ; struct net_bridge_port_group __rcu * * pp ; mdb = mlock_dereference ( br -> mdb , br ) ; mp = br_mdb_ip_get ( mdb , & pg -> addr ) ; if ( WARN_ON ( ! mp ) ) return ; for ( pp = & mp -> ports ; ( p = mlock_dereference ( * pp , br ) ) != NULL ; pp = & p -> next ) { if ( p != pg ) continue ; rcu_assign_pointer ( * pp , p -> next ) ; hlist_del_init ( & p -> mglist ) ; del_timer ( & p -> timer ) ; call_rcu_bh ( & p -> rcu , br_multicast_free_pg ) ; <S2SV_StartBug> if ( ! mp -> ports && ! mp -> mglist && <S2SV_EndBug> netif_running ( br -> dev ) ) mod_timer ( & mp -> timer , jiffies ) ; return ; } WARN_ON ( 1 ) ; }
","<S2SV_ModStart> -> mglist && mp -> timer_armed &&
"
887,"CWE-000 static HB_Bool myanmar_shape_syllable ( HB_Bool openType , HB_ShaperItem * item , HB_Bool invalid ) { # ifndef NO_OPENTYPE const int availableGlyphs = item -> num_glyphs ; # endif const HB_UChar16 * uc = item -> string + item -> item . pos ; int vowel_e = - 1 ; int kinzi = - 1 ; int medial_ra = - 1 ; int base = - 1 ; int i ; int len = 0 ; unsigned short reordered [ 32 ] ; unsigned char properties [ 32 ] ; enum { AboveForm = 0x01 , PreForm = 0x02 , PostForm = 0x04 , BelowForm = 0x08 } ; HB_Bool lastWasVirama = FALSE ; int basePos = - 1 ; memset ( properties , 0 , 32 * sizeof ( unsigned char ) ) ; assert ( item -> item . length < 32 ) ; # ifdef MYANMAR_DEBUG printf ( ""original:"" ) ; for ( i = 0 ; i < ( int ) item -> item . length ; i ++ ) { printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d:<S2SV_blank>%4x"" , i , uc [ i ] ) ; } # endif for ( i = 0 ; i < ( int ) item -> item . length ; ++ i ) { HB_UChar16 chr = uc [ i ] ; if ( chr == Mymr_C_VOWEL_E ) { vowel_e = i ; continue ; } if ( i == 0 && chr == Mymr_C_NGA && i + 2 < ( int ) item -> item . length && uc [ i + 1 ] == Mymr_C_VIRAMA ) { int mc = getMyanmarCharClass ( uc [ i + 2 ] ) ; if ( ( mc & Mymr_CF_CONSONANT ) == Mymr_CF_CONSONANT ) { kinzi = i ; continue ; } } if ( base >= 0 && chr == Mymr_C_VIRAMA && i + 1 < ( int ) item -> item . length && uc [ i + 1 ] == Mymr_C_RA ) { medial_ra = i ; continue ; } if ( base < 0 ) base = i ; } MMDEBUG ( ""\\n<S2SV_blank><S2SV_blank>base=%d,<S2SV_blank>vowel_e=%d,<S2SV_blank>kinzi=%d,<S2SV_blank>medial_ra=%d"" , base , vowel_e , kinzi , medial_ra ) ; if ( vowel_e >= 0 ) { reordered [ 0 ] = Mymr_C_VOWEL_E ; len = 1 ; } if ( medial_ra >= 0 ) { reordered [ len ] = Mymr_C_VIRAMA ; reordered [ len + 1 ] = Mymr_C_RA ; properties [ len ] = PreForm ; properties [ len + 1 ] = PreForm ; len += 2 ; } if ( invalid ) { reordered [ len ] = C_DOTTED_CIRCLE ; ++ len ; } for ( i = 0 ; i < ( int ) item -> item . length ; ++ i ) { hb_uint16 chr = uc [ i ] ; MymrCharClass cc ; if ( i == vowel_e ) continue ; if ( i == medial_ra || i == kinzi ) { ++ i ; continue ; } cc = getMyanmarCharClass ( uc [ i ] ) ; if ( kinzi >= 0 && i > base && ( cc & Mymr_CF_AFTER_KINZI ) ) { reordered [ len ] = Mymr_C_NGA ; <S2SV_StartBug> reordered [ len + 1 ] = Mymr_C_VIRAMA ; <S2SV_EndBug> properties [ len - 1 ] = AboveForm ; properties [ len ] = AboveForm ; len += 2 ; kinzi = - 1 ; } if ( lastWasVirama ) { int prop = 0 ; switch ( cc & Mymr_CF_POS_MASK ) { case Mymr_CF_POS_BEFORE : prop = PreForm ; break ; case Mymr_CF_POS_BELOW : prop = BelowForm ; break ; case Mymr_CF_POS_ABOVE : prop = AboveForm ; break ; case Mymr_CF_POS_AFTER : prop = PostForm ; break ; default : break ; } properties [ len - 1 ] = prop ; properties [ len ] = prop ; if ( basePos >= 0 && basePos == len - 2 ) properties [ len - 2 ] = prop ; } lastWasVirama = ( chr == Mymr_C_VIRAMA ) ; if ( i == base ) basePos = len ; if ( ( chr != Mymr_C_SIGN_ZWNJ && chr != Mymr_C_SIGN_ZWJ ) || ! len ) { reordered [ len ] = chr ; ++ len ; } } if ( kinzi >= 0 ) { reordered [ len ] = Mymr_C_NGA ; reordered [ len + 1 ] = Mymr_C_VIRAMA ; properties [ len ] = AboveForm ; properties [ len + 1 ] = AboveForm ; len += 2 ; } if ( ! item -> font -> klass -> convertStringToGlyphIndices ( item -> font , reordered , len , item -> glyphs , & item -> num_glyphs , item -> item . bidiLevel % 2 ) ) return FALSE ; MMDEBUG ( ""after<S2SV_blank>shaping:<S2SV_blank>len=%d"" , len ) ; for ( i = 0 ; i < len ; i ++ ) { item -> attributes [ i ] . mark = FALSE ; item -> attributes [ i ] . clusterStart = FALSE ; item -> attributes [ i ] . justification = 0 ; item -> attributes [ i ] . zeroWidth = FALSE ; MMDEBUG ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d:<S2SV_blank>%4x<S2SV_blank>property=%x"" , i , reordered [ i ] , properties [ i ] ) ; } # ifndef NO_OPENTYPE if ( openType ) { hb_uint32 where [ 32 ] ; for ( i = 0 ; i < len ; ++ i ) { where [ i ] = ~ ( PreSubstProperty | BelowSubstProperty | AboveSubstProperty | PostSubstProperty | CligProperty | PositioningProperties ) ; if ( properties [ i ] & PreForm ) where [ i ] &= ~ PreFormProperty ; if ( properties [ i ] & BelowForm ) where [ i ] &= ~ BelowFormProperty ; if ( properties [ i ] & AboveForm ) where [ i ] &= ~ AboveFormProperty ; if ( properties [ i ] & PostForm ) where [ i ] &= ~ PostFormProperty ; } HB_OpenTypeShape ( item , where ) ; if ( ! HB_OpenTypePosition ( item , availableGlyphs , FALSE ) ) return FALSE ; } else # endif { MMDEBUG ( ""Not<S2SV_blank>using<S2SV_blank>openType"" ) ; HB_HeuristicPosition ( item ) ; } item -> attributes [ 0 ] . clusterStart = TRUE ; return TRUE ; }
","<S2SV_ModStart> = Mymr_C_VIRAMA ; if ( len > 0 )
"
888,"CWE-000 static int iowarrior_probe ( struct usb_interface * interface , const struct usb_device_id * id ) { struct usb_device * udev = interface_to_usbdev ( interface ) ; struct iowarrior * dev = NULL ; struct usb_host_interface * iface_desc ; struct usb_endpoint_descriptor * endpoint ; int i ; int retval = - ENOMEM ; dev = kzalloc ( sizeof ( struct iowarrior ) , GFP_KERNEL ) ; if ( dev == NULL ) { dev_err ( & interface -> dev , ""Out<S2SV_blank>of<S2SV_blank>memory\\n"" ) ; return retval ; } mutex_init ( & dev -> mutex ) ; atomic_set ( & dev -> intr_idx , 0 ) ; atomic_set ( & dev -> read_idx , 0 ) ; spin_lock_init ( & dev -> intr_idx_lock ) ; atomic_set ( & dev -> overflow_flag , 0 ) ; init_waitqueue_head ( & dev -> read_wait ) ; atomic_set ( & dev -> write_busy , 0 ) ; init_waitqueue_head ( & dev -> write_wait ) ; dev -> udev = udev ; dev -> interface = interface ; iface_desc = interface -> cur_altsetting ; <S2SV_StartBug> dev -> product_id = le16_to_cpu ( udev -> descriptor . idProduct ) ; <S2SV_EndBug> for ( i = 0 ; i < iface_desc -> desc . bNumEndpoints ; ++ i ) { endpoint = & iface_desc -> endpoint [ i ] . desc ; if ( usb_endpoint_is_int_in ( endpoint ) ) dev -> int_in_endpoint = endpoint ; if ( usb_endpoint_is_int_out ( endpoint ) ) dev -> int_out_endpoint = endpoint ; } dev -> report_size = usb_endpoint_maxp ( dev -> int_in_endpoint ) ; if ( ( dev -> interface -> cur_altsetting -> desc . bInterfaceNumber == 0 ) && ( dev -> product_id == USB_DEVICE_ID_CODEMERCS_IOW56 ) ) dev -> report_size = 7 ; dev -> int_in_urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! dev -> int_in_urb ) { dev_err ( & interface -> dev , ""Couldn\'t<S2SV_blank>allocate<S2SV_blank>interrupt_in_urb\\n"" ) ; goto error ; } dev -> int_in_buffer = kmalloc ( dev -> report_size , GFP_KERNEL ) ; if ( ! dev -> int_in_buffer ) { dev_err ( & interface -> dev , ""Couldn\'t<S2SV_blank>allocate<S2SV_blank>int_in_buffer\\n"" ) ; goto error ; } usb_fill_int_urb ( dev -> int_in_urb , dev -> udev , usb_rcvintpipe ( dev -> udev , dev -> int_in_endpoint -> bEndpointAddress ) , dev -> int_in_buffer , dev -> report_size , iowarrior_callback , dev , dev -> int_in_endpoint -> bInterval ) ; dev -> read_queue = kmalloc ( ( ( dev -> report_size + 1 ) * MAX_INTERRUPT_BUFFER ) , GFP_KERNEL ) ; if ( ! dev -> read_queue ) { dev_err ( & interface -> dev , ""Couldn\'t<S2SV_blank>allocate<S2SV_blank>read_queue\\n"" ) ; goto error ; } memset ( dev -> chip_serial , 0x00 , sizeof ( dev -> chip_serial ) ) ; usb_string ( udev , udev -> descriptor . iSerialNumber , dev -> chip_serial , sizeof ( dev -> chip_serial ) ) ; if ( strlen ( dev -> chip_serial ) != 8 ) memset ( dev -> chip_serial , 0x00 , sizeof ( dev -> chip_serial ) ) ; if ( dev -> interface -> cur_altsetting -> desc . bInterfaceNumber == 0 ) { usb_control_msg ( udev , usb_sndctrlpipe ( udev , 0 ) , 0x0A , USB_TYPE_CLASS | USB_RECIP_INTERFACE , 0 , 0 , NULL , 0 , USB_CTRL_SET_TIMEOUT ) ; } dev -> present = 1 ; usb_set_intfdata ( interface , dev ) ; retval = usb_register_dev ( interface , & iowarrior_class ) ; if ( retval ) { dev_err ( & interface -> dev , ""Not<S2SV_blank>able<S2SV_blank>to<S2SV_blank>get<S2SV_blank>a<S2SV_blank>minor<S2SV_blank>for<S2SV_blank>this<S2SV_blank>device.\\n"" ) ; usb_set_intfdata ( interface , NULL ) ; goto error ; } dev -> minor = interface -> minor ; dev_info ( & interface -> dev , ""IOWarrior<S2SV_blank>product=0x%x,<S2SV_blank>serial=%s<S2SV_blank>interface=%d<S2SV_blank>"" ""now<S2SV_blank>attached<S2SV_blank>to<S2SV_blank>iowarrior%d\\n"" , dev -> product_id , dev -> chip_serial , iface_desc -> desc . bInterfaceNumber , dev -> minor - IOWARRIOR_MINOR_BASE ) ; return retval ; error : iowarrior_delete ( dev ) ; return retval ; }
","<S2SV_ModStart> idProduct ) ; if ( iface_desc -> desc . bNumEndpoints < 1 ) { dev_err ( & interface -> dev , ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>endpoints\\n"" ) ; retval = - EINVAL ; goto error ; }
"
889,"CWE-190 static int b_unpack ( lua_State * L ) { Header h ; const char * fmt = luaL_checkstring ( L , 1 ) ; size_t ld ; const char * data = luaL_checklstring ( L , 2 , & ld ) ; size_t pos = luaL_optinteger ( L , 3 , 1 ) - 1 ; <S2SV_StartBug> defaultoptions ( & h ) ; <S2SV_EndBug> lua_settop ( L , 2 ) ; while ( * fmt ) { int opt = * fmt ++ ; size_t size = optsize ( L , opt , & fmt ) ; pos += gettoalign ( pos , & h , opt , size ) ; luaL_argcheck ( L , pos + size <= ld , 2 , ""data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short"" ) ; <S2SV_StartBug> luaL_checkstack ( L , 1 , ""too<S2SV_blank>many<S2SV_blank>results"" ) ; <S2SV_EndBug> switch ( opt ) { case 'b' : case 'B' : case 'h' : case 'H' : case 'l' : case 'L' : case 'T' : case 'i' : case 'I' : { int issigned = islower ( opt ) ; lua_Number res = getinteger ( data + pos , h . endian , issigned , size ) ; <S2SV_StartBug> lua_pushnumber ( L , res ) ; <S2SV_EndBug> break ; } case 'x' : { break ; } case 'f' : { float f ; memcpy ( & f , data + pos , size ) ; correctbytes ( ( char * ) & f , sizeof ( f ) , h . endian ) ; <S2SV_StartBug> lua_pushnumber ( L , f ) ; <S2SV_EndBug> break ; } case 'd' : { double d ; memcpy ( & d , data + pos , size ) ; correctbytes ( ( char * ) & d , sizeof ( d ) , h . endian ) ; <S2SV_StartBug> lua_pushnumber ( L , d ) ; <S2SV_EndBug> break ; } case 'c' : { if ( size == 0 ) { <S2SV_StartBug> if ( ! lua_isnumber ( L , - 1 ) ) <S2SV_EndBug> <S2SV_StartBug> luaL_error ( L , ""format<S2SV_blank>`c0\'<S2SV_blank>needs<S2SV_blank>a<S2SV_blank>previous<S2SV_blank>size"" ) ; <S2SV_EndBug> size = lua_tonumber ( L , - 1 ) ; <S2SV_StartBug> lua_pop ( L , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> luaL_argcheck ( L , pos + size <= ld , 2 , ""data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short"" ) ; <S2SV_EndBug> } <S2SV_StartBug> lua_pushlstring ( L , data + pos , size ) ; <S2SV_EndBug> break ; } case 's' : { const char * e = ( const char * ) memchr ( data + pos , '\\0' , ld - pos ) ; if ( e == NULL ) luaL_error ( L , ""unfinished<S2SV_blank>string<S2SV_blank>in<S2SV_blank>data"" ) ; size = ( e - ( data + pos ) ) + 1 ; <S2SV_StartBug> lua_pushlstring ( L , data + pos , size - 1 ) ; <S2SV_EndBug> break ; } default : controloptions ( L , opt , & fmt , & h ) ; } pos += size ; } lua_pushinteger ( L , pos + 1 ) ; <S2SV_StartBug> return lua_gettop ( L ) - 2 ; <S2SV_EndBug> }
","<S2SV_ModStart> - 1 ; int n = 0 ; <S2SV_ModStart> ( & h <S2SV_ModEnd> ) ; while <S2SV_ModStart> ( L , 2 <S2SV_ModEnd> , ""too<S2SV_blank>many<S2SV_blank>results"" ) <S2SV_ModStart> res ) ; n ++ ; <S2SV_ModStart> f ) ; n ++ ; <S2SV_ModStart> d ) ; n ++ ; <S2SV_ModStart> { if ( n == 0 || <S2SV_ModStart> ( L , ""format<S2SV_blank>\'c0\'<S2SV_blank>needs<S2SV_blank>a<S2SV_blank>previous<S2SV_blank>size"" <S2SV_ModEnd> ) ; size <S2SV_ModStart> 1 ) ; n -- ; <S2SV_ModStart> ( L , <S2SV_ModEnd> size <= ld <S2SV_ModStart> size <= ld && pos <= ld - size , <S2SV_ModEnd> 2 , ""data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short"" <S2SV_ModStart> , size ) ; n ++ <S2SV_ModStart> 1 ) ; n ++ ; <S2SV_ModStart> ) ; return n + 1 <S2SV_ModEnd> ; } <S2SV_null>
"
890,"CWE-358 int udpv6_recvmsg ( struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct inet_sock * inet = inet_sk ( sk ) ; struct sk_buff * skb ; unsigned int ulen , copied ; int peeked , off = 0 ; int err ; <S2SV_StartBug> int is_udplite = IS_UDPLITE ( sk ) ; <S2SV_EndBug> int is_udp4 ; bool slow ; if ( flags & MSG_ERRQUEUE ) return ipv6_recv_error ( sk , msg , len , addr_len ) ; if ( np -> rxpmtu && np -> rxopt . bits . rxpmtu ) return ipv6_recv_rxpmtu ( sk , msg , len , addr_len ) ; try_again : skb = __skb_recv_datagram ( sk , flags | ( noblock ? MSG_DONTWAIT : 0 ) , & peeked , & off , & err ) ; if ( ! skb ) goto out ; ulen = skb -> len - sizeof ( struct udphdr ) ; copied = len ; if ( copied > ulen ) copied = ulen ; else if ( copied < ulen ) msg -> msg_flags |= MSG_TRUNC ; is_udp4 = ( skb -> protocol == htons ( ETH_P_IP ) ) ; if ( copied < ulen || UDP_SKB_CB ( skb ) -> partial_cov ) { <S2SV_StartBug> if ( udp_lib_checksum_complete ( skb ) ) <S2SV_EndBug> goto csum_copy_err ; } <S2SV_StartBug> if ( skb_csum_unnecessary ( skb ) ) <S2SV_EndBug> err = skb_copy_datagram_msg ( skb , sizeof ( struct udphdr ) , msg , copied ) ; else { err = skb_copy_and_csum_datagram_msg ( skb , sizeof ( struct udphdr ) , msg ) ; if ( err == - EINVAL ) goto csum_copy_err ; } if ( unlikely ( err ) ) { trace_kfree_skb ( skb , udpv6_recvmsg ) ; if ( ! peeked ) { atomic_inc ( & sk -> sk_drops ) ; if ( is_udp4 ) UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; else UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } goto out_free ; } if ( ! peeked ) { if ( is_udp4 ) UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INDATAGRAMS , is_udplite ) ; else UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INDATAGRAMS , is_udplite ) ; } sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( msg -> msg_name ) { DECLARE_SOCKADDR ( struct sockaddr_in6 * , sin6 , msg -> msg_name ) ; sin6 -> sin6_family = AF_INET6 ; sin6 -> sin6_port = udp_hdr ( skb ) -> source ; sin6 -> sin6_flowinfo = 0 ; if ( is_udp4 ) { ipv6_addr_set_v4mapped ( ip_hdr ( skb ) -> saddr , & sin6 -> sin6_addr ) ; sin6 -> sin6_scope_id = 0 ; } else { sin6 -> sin6_addr = ipv6_hdr ( skb ) -> saddr ; sin6 -> sin6_scope_id = ipv6_iface_scope_id ( & sin6 -> sin6_addr , inet6_iif ( skb ) ) ; } * addr_len = sizeof ( * sin6 ) ; } if ( np -> rxopt . all ) ip6_datagram_recv_common_ctl ( sk , msg , skb ) ; if ( is_udp4 ) { if ( inet -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ; } else { if ( np -> rxopt . all ) ip6_datagram_recv_specific_ctl ( sk , msg , skb ) ; } err = copied ; if ( flags & MSG_TRUNC ) err = ulen ; out_free : skb_free_datagram_locked ( sk , skb ) ; out : return err ; csum_copy_err : slow = lock_sock_fast ( sk ) ; if ( ! skb_kill_datagram ( sk , skb , flags ) ) { if ( is_udp4 ) { UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_CSUMERRORS , is_udplite ) ; UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } else { UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_CSUMERRORS , is_udplite ) ; UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } } unlock_sock_fast ( sk , slow ) ; cond_resched ( ) ; msg -> msg_flags &= ~ MSG_TRUNC ; goto try_again ; }
","<S2SV_ModStart> ( sk ) ; bool checksum_valid = false <S2SV_ModStart> partial_cov ) { checksum_valid = ! <S2SV_ModEnd> udp_lib_checksum_complete ( skb <S2SV_ModStart> ( skb ) ; if ( ! checksum_valid <S2SV_ModStart> } if ( checksum_valid ||
"
891,"CWE-200 long vorbis_book_decodev_set ( codebook * book , ogg_int32_t * a , oggpack_buffer * b , int n , int point ) { if ( book -> used_entries > 0 ) { ogg_int32_t * v = book -> dec_buf ; int i , j ; if ( ! v ) return - 1 ; for ( i = 0 ; i < n ; ) { if ( decode_map ( book , b , v , point ) ) return - 1 ; <S2SV_StartBug> for ( j = 0 ; j < book -> dim ; j ++ ) <S2SV_EndBug> a [ i ++ ] = v [ j ] ; } } else { int i , j ; for ( i = 0 ; i < n ; ) { <S2SV_StartBug> for ( j = 0 ; j < book -> dim ; j ++ ) <S2SV_EndBug> a [ i ++ ] = 0 ; } } return 0 ; }
","<S2SV_ModStart> book -> dim && i < n <S2SV_ModStart> book -> dim && i < n
"
892,"CWE-416 static OPJ_BOOL opj_j2k_write_mco ( opj_j2k_t * p_j2k , struct opj_stream_private * p_stream , struct opj_event_mgr * p_manager ) { OPJ_BYTE * l_current_data = 00 ; OPJ_UINT32 l_mco_size ; opj_tcp_t * l_tcp = 00 ; opj_simple_mcc_decorrelation_data_t * l_mcc_record ; OPJ_UINT32 i ; assert ( p_j2k != 00 ) ; assert ( p_manager != 00 ) ; assert ( p_stream != 00 ) ; l_tcp = & ( p_j2k -> m_cp . tcps [ p_j2k -> m_current_tile_number ] ) ; <S2SV_StartBug> l_current_data = p_j2k -> m_specific_param . m_encoder . m_header_tile_data ; <S2SV_EndBug> l_mco_size = 5 + l_tcp -> m_nb_mcc_records ; if ( l_mco_size > p_j2k -> m_specific_param . m_encoder . m_header_tile_data_size ) { OPJ_BYTE * new_header_tile_data = ( OPJ_BYTE * ) opj_realloc ( p_j2k -> m_specific_param . m_encoder . m_header_tile_data , l_mco_size ) ; if ( ! new_header_tile_data ) { opj_free ( p_j2k -> m_specific_param . m_encoder . m_header_tile_data ) ; p_j2k -> m_specific_param . m_encoder . m_header_tile_data = NULL ; p_j2k -> m_specific_param . m_encoder . m_header_tile_data_size = 0 ; opj_event_msg ( p_manager , EVT_ERROR , ""Not<S2SV_blank>enough<S2SV_blank>memory<S2SV_blank>to<S2SV_blank>write<S2SV_blank>MCO<S2SV_blank>marker\\n"" ) ; return OPJ_FALSE ; } p_j2k -> m_specific_param . m_encoder . m_header_tile_data = new_header_tile_data ; p_j2k -> m_specific_param . m_encoder . m_header_tile_data_size = l_mco_size ; } <S2SV_StartBug> opj_write_bytes ( l_current_data , J2K_MS_MCO , 2 ) ; <S2SV_EndBug> l_current_data += 2 ; opj_write_bytes ( l_current_data , l_mco_size - 2 , 2 ) ; l_current_data += 2 ; opj_write_bytes ( l_current_data , l_tcp -> m_nb_mcc_records , 1 ) ; ++ l_current_data ; l_mcc_record = l_tcp -> m_mcc_records ; for ( i = 0 ; i < l_tcp -> m_nb_mcc_records ; ++ i ) { opj_write_bytes ( l_current_data , l_mcc_record -> m_index , 1 ) ; ++ l_current_data ; ++ l_mcc_record ; } if ( opj_stream_write_data ( p_stream , p_j2k -> m_specific_param . m_encoder . m_header_tile_data , l_mco_size , p_manager ) != l_mco_size ) { return OPJ_FALSE ; } return OPJ_TRUE ; }
","<S2SV_ModStart> ] ) ; <S2SV_ModEnd> l_mco_size = 5 <S2SV_ModStart> l_mco_size ; } l_current_data = p_j2k -> m_specific_param . m_encoder . m_header_tile_data ;
"
893,"CWE-20 static int __sock_diag_rcv_msg ( struct sk_buff * skb , struct nlmsghdr * nlh ) { int err ; struct sock_diag_req * req = nlmsg_data ( nlh ) ; const struct sock_diag_handler * hndl ; if ( nlmsg_len ( nlh ) < sizeof ( * req ) ) return - EINVAL ; <S2SV_StartBug> hndl = sock_diag_lock_handler ( req -> sdiag_family ) ; <S2SV_EndBug> if ( hndl == NULL ) err = - ENOENT ; else err = hndl -> dump ( skb , nlh ) ; sock_diag_unlock_handler ( hndl ) ; return err ; }
","<S2SV_ModStart> - EINVAL ; if ( req -> sdiag_family >= AF_MAX ) return - EINVAL ;
"
894,"CWE-125 static int adjust_scalar_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , struct bpf_reg_state * dst_reg , struct bpf_reg_state src_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; bool src_known , dst_known ; s64 smin_val , smax_val ; u64 umin_val , umax_val ; <S2SV_StartBug> u64 insn_bitness = ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) ? 64 : 32 ; <S2SV_EndBug> smin_val = src_reg . smin_value ; smax_val = src_reg . smax_value ; umin_val = src_reg . umin_value ; umax_val = src_reg . umax_value ; src_known = tnum_is_const ( src_reg . var_off ) ; dst_known = tnum_is_const ( dst_reg -> var_off ) ; if ( ( src_known && ( smin_val != smax_val || umin_val != umax_val ) ) || smin_val > smax_val || umin_val > umax_val ) { __mark_reg_unknown ( dst_reg ) ; return 0 ; } if ( ! src_known && opcode != BPF_ADD && opcode != BPF_SUB && opcode != BPF_AND ) { __mark_reg_unknown ( dst_reg ) ; return 0 ; } switch ( opcode ) { case BPF_ADD : if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value += smin_val ; dst_reg -> smax_value += smax_val ; } if ( dst_reg -> umin_value + umin_val < umin_val || dst_reg -> umax_value + umax_val < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value += umin_val ; dst_reg -> umax_value += umax_val ; } dst_reg -> var_off = tnum_add ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_SUB : if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value -= smax_val ; dst_reg -> smax_value -= smin_val ; } if ( dst_reg -> umin_value < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value -= umax_val ; dst_reg -> umax_value -= umin_val ; } dst_reg -> var_off = tnum_sub ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_MUL : dst_reg -> var_off = tnum_mul ( dst_reg -> var_off , src_reg . var_off ) ; if ( smin_val < 0 || dst_reg -> smin_value < 0 ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } if ( umax_val > U32_MAX || dst_reg -> umax_value > U32_MAX ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } dst_reg -> umin_value *= umin_val ; dst_reg -> umax_value *= umax_val ; if ( dst_reg -> umax_value > S64_MAX ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } break ; case BPF_AND : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value & src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_and ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = dst_reg -> var_off . value ; dst_reg -> umax_value = min ( dst_reg -> umax_value , umax_val ) ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_OR : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value | src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_or ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = max ( dst_reg -> umin_value , umin_val ) ; dst_reg -> umax_value = dst_reg -> var_off . value | dst_reg -> var_off . mask ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_LSH : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( dst_reg -> umax_value > 1ULL << ( 63 - umax_val ) ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value <<= umin_val ; dst_reg -> umax_value <<= umax_val ; } dst_reg -> var_off = tnum_lshift ( dst_reg -> var_off , umin_val ) ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_RSH : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; dst_reg -> var_off = tnum_rshift ( dst_reg -> var_off , umin_val ) ; dst_reg -> umin_value >>= umax_val ; dst_reg -> umax_value >>= umin_val ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_ARSH : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value >>= umin_val ; dst_reg -> smax_value >>= umin_val ; dst_reg -> var_off = tnum_arshift ( dst_reg -> var_off , umin_val ) ; dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; __update_reg_bounds ( dst_reg ) ; break ; default : mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { coerce_reg_to_size ( dst_reg , 4 ) ; <S2SV_StartBug> coerce_reg_to_size ( & src_reg , 4 ) ; <S2SV_EndBug> } __reg_deduce_bounds ( dst_reg ) ; __reg_bound_offset ( dst_reg ) ; return 0 ; }
","<S2SV_ModStart> : 32 ; if ( insn_bitness == 32 ) { coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size ( & src_reg , 4 ) ; } <S2SV_ModStart> 4 ) ; <S2SV_ModEnd> } __reg_deduce_bounds (
"
895,"CWE-119 tsize_t t2p_readwrite_pdf_image ( T2P * t2p , TIFF * input , TIFF * output ) { tsize_t written = 0 ; unsigned char * buffer = NULL ; unsigned char * samplebuffer = NULL ; tsize_t bufferoffset = 0 ; tsize_t samplebufferoffset = 0 ; tsize_t read = 0 ; tstrip_t i = 0 ; tstrip_t j = 0 ; tstrip_t stripcount = 0 ; tsize_t stripsize = 0 ; tsize_t sepstripcount = 0 ; tsize_t sepstripsize = 0 ; # ifdef OJPEG_SUPPORT toff_t inputoffset = 0 ; uint16 h_samp = 1 ; uint16 v_samp = 1 ; uint16 ri = 1 ; uint32 rows = 0 ; # endif # ifdef JPEG_SUPPORT unsigned char * jpt ; float * xfloatp ; uint64 * sbc ; unsigned char * stripbuffer ; tsize_t striplength = 0 ; uint32 max_striplength = 0 ; # endif if ( t2p -> t2p_error != T2P_ERR_OK ) return ( 0 ) ; if ( t2p -> pdf_transcode == T2P_TRANSCODE_RAW ) { # ifdef CCITT_SUPPORT if ( t2p -> pdf_compression == T2P_COMPRESS_G4 ) { buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>"" ""t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } TIFFReadRawStrip ( input , 0 , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; if ( t2p -> tiff_fillorder == FILLORDER_LSB2MSB ) { TIFFReverseBits ( buffer , t2p -> tiff_datasize ) ; } t2pWriteFile ( output , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; _TIFFfree ( buffer ) ; return ( t2p -> tiff_datasize ) ; } # endif # ifdef ZIP_SUPPORT if ( t2p -> pdf_compression == T2P_COMPRESS_ZIP ) { buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; TIFFReadRawStrip ( input , 0 , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; if ( t2p -> tiff_fillorder == FILLORDER_LSB2MSB ) { TIFFReverseBits ( buffer , t2p -> tiff_datasize ) ; } t2pWriteFile ( output , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; _TIFFfree ( buffer ) ; return ( t2p -> tiff_datasize ) ; } # endif # ifdef OJPEG_SUPPORT if ( t2p -> tiff_compression == COMPRESSION_OJPEG ) { if ( t2p -> tiff_dataoffset != 0 ) { buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; if ( t2p -> pdf_ojpegiflength == 0 ) { inputoffset = t2pSeekFile ( input , 0 , SEEK_CUR ) ; t2pSeekFile ( input , t2p -> tiff_dataoffset , SEEK_SET ) ; t2pReadFile ( input , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; t2pSeekFile ( input , inputoffset , SEEK_SET ) ; t2pWriteFile ( output , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; _TIFFfree ( buffer ) ; return ( t2p -> tiff_datasize ) ; } else { inputoffset = t2pSeekFile ( input , 0 , SEEK_CUR ) ; t2pSeekFile ( input , t2p -> tiff_dataoffset , SEEK_SET ) ; bufferoffset = t2pReadFile ( input , ( tdata_t ) buffer , t2p -> pdf_ojpegiflength ) ; t2p -> pdf_ojpegiflength = 0 ; t2pSeekFile ( input , inputoffset , SEEK_SET ) ; TIFFGetField ( input , TIFFTAG_YCBCRSUBSAMPLING , & h_samp , & v_samp ) ; buffer [ bufferoffset ++ ] = 0xff ; buffer [ bufferoffset ++ ] = 0xdd ; buffer [ bufferoffset ++ ] = 0x00 ; buffer [ bufferoffset ++ ] = 0x04 ; h_samp *= 8 ; v_samp *= 8 ; ri = ( t2p -> tiff_width + h_samp - 1 ) / h_samp ; TIFFGetField ( input , TIFFTAG_ROWSPERSTRIP , & rows ) ; ri *= ( rows + v_samp - 1 ) / v_samp ; buffer [ bufferoffset ++ ] = ( ri >> 8 ) & 0xff ; buffer [ bufferoffset ++ ] = ri & 0xff ; stripcount = TIFFNumberOfStrips ( input ) ; for ( i = 0 ; i < stripcount ; i ++ ) { if ( i != 0 ) { buffer [ bufferoffset ++ ] = 0xff ; buffer [ bufferoffset ++ ] = ( 0xd0 | ( ( i - 1 ) % 8 ) ) ; } bufferoffset += TIFFReadRawStrip ( input , i , ( tdata_t ) & ( ( ( unsigned char * ) buffer ) [ bufferoffset ] ) , - 1 ) ; } t2pWriteFile ( output , ( tdata_t ) buffer , bufferoffset ) ; _TIFFfree ( buffer ) ; return ( bufferoffset ) ; } } else { if ( ! t2p -> pdf_ojpegdata ) { TIFFError ( TIFF2PDF_MODULE , ""No<S2SV_blank>support<S2SV_blank>for<S2SV_blank>OJPEG<S2SV_blank>image<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>bad<S2SV_blank>tables"" , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; _TIFFmemcpy ( buffer , t2p -> pdf_ojpegdata , t2p -> pdf_ojpegdatalength ) ; bufferoffset = t2p -> pdf_ojpegdatalength ; stripcount = TIFFNumberOfStrips ( input ) ; for ( i = 0 ; i < stripcount ; i ++ ) { if ( i != 0 ) { buffer [ bufferoffset ++ ] = 0xff ; buffer [ bufferoffset ++ ] = ( 0xd0 | ( ( i - 1 ) % 8 ) ) ; } bufferoffset += TIFFReadRawStrip ( input , i , ( tdata_t ) & ( ( ( unsigned char * ) buffer ) [ bufferoffset ] ) , - 1 ) ; } if ( ! ( ( buffer [ bufferoffset - 1 ] == 0xd9 ) && ( buffer [ bufferoffset - 2 ] == 0xff ) ) ) { buffer [ bufferoffset ++ ] = 0xff ; buffer [ bufferoffset ++ ] = 0xd9 ; } t2pWriteFile ( output , ( tdata_t ) buffer , bufferoffset ) ; _TIFFfree ( buffer ) ; return ( bufferoffset ) ; # if 0 TIFFError ( TIFF2PDF_MODULE , ""No<S2SV_blank>support<S2SV_blank>for<S2SV_blank>OJPEG<S2SV_blank>image<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>no<S2SV_blank>JPEG<S2SV_blank>File<S2SV_blank>Interchange<S2SV_blank>offset"" , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; # endif } } # endif # ifdef JPEG_SUPPORT if ( t2p -> tiff_compression == COMPRESSION_JPEG ) { uint32 count = 0 ; buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; if ( TIFFGetField ( input , TIFFTAG_JPEGTABLES , & count , & jpt ) != 0 ) { if ( count > 4 ) { _TIFFmemcpy ( buffer , jpt , count ) ; bufferoffset += count - 2 ; } } stripcount = TIFFNumberOfStrips ( input ) ; TIFFGetField ( input , TIFFTAG_STRIPBYTECOUNTS , & sbc ) ; for ( i = 0 ; i < stripcount ; i ++ ) { if ( sbc [ i ] > max_striplength ) max_striplength = sbc [ i ] ; } stripbuffer = ( unsigned char * ) _TIFFmalloc ( max_striplength ) ; if ( stripbuffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , max_striplength , TIFFFileName ( input ) ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } for ( i = 0 ; i < stripcount ; i ++ ) { striplength = TIFFReadRawStrip ( input , i , ( tdata_t ) stripbuffer , - 1 ) ; if ( ! t2p_process_jpeg_strip ( stripbuffer , & striplength , buffer , <S2SV_StartBug> & bufferoffset , <S2SV_EndBug> i , t2p -> tiff_length ) ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>process<S2SV_blank>JPEG<S2SV_blank>data<S2SV_blank>in<S2SV_blank>input<S2SV_blank>file<S2SV_blank>%s"" , TIFFFileName ( input ) ) ; _TIFFfree ( samplebuffer ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } } buffer [ bufferoffset ++ ] = 0xff ; buffer [ bufferoffset ++ ] = 0xd9 ; t2pWriteFile ( output , ( tdata_t ) buffer , bufferoffset ) ; _TIFFfree ( stripbuffer ) ; _TIFFfree ( buffer ) ; return ( bufferoffset ) ; } # endif ( void ) 0 ; } if ( t2p -> pdf_sample == T2P_SAMPLE_NOTHING ) { buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; stripsize = TIFFStripSize ( input ) ; stripcount = TIFFNumberOfStrips ( input ) ; for ( i = 0 ; i < stripcount ; i ++ ) { read = TIFFReadEncodedStrip ( input , i , ( tdata_t ) & buffer [ bufferoffset ] , TIFFmin ( stripsize , t2p -> tiff_datasize - bufferoffset ) ) ; if ( read == - 1 ) { TIFFError ( TIFF2PDF_MODULE , ""Error<S2SV_blank>on<S2SV_blank>decoding<S2SV_blank>strip<S2SV_blank>%u<S2SV_blank>of<S2SV_blank>%s"" , i , TIFFFileName ( input ) ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } bufferoffset += read ; } } else { if ( t2p -> pdf_sample & T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG ) { sepstripsize = TIFFStripSize ( input ) ; sepstripcount = TIFFNumberOfStrips ( input ) ; stripsize = sepstripsize * t2p -> tiff_samplesperpixel ; stripcount = sepstripcount / t2p -> tiff_samplesperpixel ; buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; samplebuffer = ( unsigned char * ) _TIFFmalloc ( stripsize ) ; if ( samplebuffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; _TIFFfree ( buffer ) ; return ( 0 ) ; } for ( i = 0 ; i < stripcount ; i ++ ) { samplebufferoffset = 0 ; for ( j = 0 ; j < t2p -> tiff_samplesperpixel ; j ++ ) { read = TIFFReadEncodedStrip ( input , i + j * stripcount , ( tdata_t ) & ( samplebuffer [ samplebufferoffset ] ) , TIFFmin ( sepstripsize , stripsize - samplebufferoffset ) ) ; if ( read == - 1 ) { TIFFError ( TIFF2PDF_MODULE , ""Error<S2SV_blank>on<S2SV_blank>decoding<S2SV_blank>strip<S2SV_blank>%u<S2SV_blank>of<S2SV_blank>%s"" , i + j * stripcount , TIFFFileName ( input ) ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } samplebufferoffset += read ; } t2p_sample_planar_separate_to_contig ( t2p , & ( buffer [ bufferoffset ] ) , samplebuffer , samplebufferoffset ) ; bufferoffset += samplebufferoffset ; } _TIFFfree ( samplebuffer ) ; goto dataready ; } buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; stripsize = TIFFStripSize ( input ) ; stripcount = TIFFNumberOfStrips ( input ) ; for ( i = 0 ; i < stripcount ; i ++ ) { read = TIFFReadEncodedStrip ( input , i , ( tdata_t ) & buffer [ bufferoffset ] , TIFFmin ( stripsize , t2p -> tiff_datasize - bufferoffset ) ) ; if ( read == - 1 ) { TIFFError ( TIFF2PDF_MODULE , ""Error<S2SV_blank>on<S2SV_blank>decoding<S2SV_blank>strip<S2SV_blank>%u<S2SV_blank>of<S2SV_blank>%s"" , i , TIFFFileName ( input ) ) ; _TIFFfree ( samplebuffer ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } bufferoffset += read ; } if ( t2p -> pdf_sample & T2P_SAMPLE_REALIZE_PALETTE ) { samplebuffer = ( unsigned char * ) _TIFFrealloc ( ( tdata_t ) buffer , t2p -> tiff_datasize * t2p -> tiff_samplesperpixel ) ; if ( samplebuffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; _TIFFfree ( buffer ) ; return ( 0 ) ; } else { buffer = samplebuffer ; t2p -> tiff_datasize *= t2p -> tiff_samplesperpixel ; } t2p_sample_realize_palette ( t2p , buffer ) ; } if ( t2p -> pdf_sample & T2P_SAMPLE_RGBA_TO_RGB ) { t2p -> tiff_datasize = t2p_sample_rgba_to_rgb ( ( tdata_t ) buffer , t2p -> tiff_width * t2p -> tiff_length ) ; } if ( t2p -> pdf_sample & T2P_SAMPLE_RGBAA_TO_RGB ) { t2p -> tiff_datasize = t2p_sample_rgbaa_to_rgb ( ( tdata_t ) buffer , t2p -> tiff_width * t2p -> tiff_length ) ; } if ( t2p -> pdf_sample & T2P_SAMPLE_YCBCR_TO_RGB ) { samplebuffer = ( unsigned char * ) _TIFFrealloc ( ( tdata_t ) buffer , t2p -> tiff_width * t2p -> tiff_length * 4 ) ; if ( samplebuffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; _TIFFfree ( buffer ) ; return ( 0 ) ; } else { buffer = samplebuffer ; } if ( ! TIFFReadRGBAImageOriented ( input , t2p -> tiff_width , t2p -> tiff_length , ( uint32 * ) buffer , ORIENTATION_TOPLEFT , 0 ) ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>use<S2SV_blank>TIFFReadRGBAImageOriented<S2SV_blank>to<S2SV_blank>extract<S2SV_blank>RGB<S2SV_blank>image<S2SV_blank>from<S2SV_blank>%s"" , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } t2p -> tiff_datasize = t2p_sample_abgr_to_rgb ( ( tdata_t ) buffer , t2p -> tiff_width * t2p -> tiff_length ) ; } if ( t2p -> pdf_sample & T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED ) { t2p -> tiff_datasize = t2p_sample_lab_signed_to_unsigned ( ( tdata_t ) buffer , t2p -> tiff_width * t2p -> tiff_length ) ; } } dataready : t2p_disable ( output ) ; TIFFSetField ( output , TIFFTAG_PHOTOMETRIC , t2p -> tiff_photometric ) ; TIFFSetField ( output , TIFFTAG_BITSPERSAMPLE , t2p -> tiff_bitspersample ) ; TIFFSetField ( output , TIFFTAG_SAMPLESPERPIXEL , t2p -> tiff_samplesperpixel ) ; TIFFSetField ( output , TIFFTAG_IMAGEWIDTH , t2p -> tiff_width ) ; TIFFSetField ( output , TIFFTAG_IMAGELENGTH , t2p -> tiff_length ) ; TIFFSetField ( output , TIFFTAG_ROWSPERSTRIP , t2p -> tiff_length ) ; TIFFSetField ( output , TIFFTAG_PLANARCONFIG , PLANARCONFIG_CONTIG ) ; TIFFSetField ( output , TIFFTAG_FILLORDER , FILLORDER_MSB2LSB ) ; switch ( t2p -> pdf_compression ) { case T2P_COMPRESS_NONE : TIFFSetField ( output , TIFFTAG_COMPRESSION , COMPRESSION_NONE ) ; break ; # ifdef CCITT_SUPPORT case T2P_COMPRESS_G4 : TIFFSetField ( output , TIFFTAG_COMPRESSION , COMPRESSION_CCITTFAX4 ) ; break ; # endif # ifdef JPEG_SUPPORT case T2P_COMPRESS_JPEG : if ( t2p -> tiff_photometric == PHOTOMETRIC_YCBCR ) { uint16 hor = 0 , ver = 0 ; if ( TIFFGetField ( input , TIFFTAG_YCBCRSUBSAMPLING , & hor , & ver ) != 0 ) { if ( hor != 0 && ver != 0 ) { TIFFSetField ( output , TIFFTAG_YCBCRSUBSAMPLING , hor , ver ) ; } } if ( TIFFGetField ( input , TIFFTAG_REFERENCEBLACKWHITE , & xfloatp ) != 0 ) { TIFFSetField ( output , TIFFTAG_REFERENCEBLACKWHITE , xfloatp ) ; } } if ( TIFFSetField ( output , TIFFTAG_COMPRESSION , COMPRESSION_JPEG ) == 0 ) { TIFFError ( TIFF2PDF_MODULE , ""Unable<S2SV_blank>to<S2SV_blank>use<S2SV_blank>JPEG<S2SV_blank>compression<S2SV_blank>for<S2SV_blank>input<S2SV_blank>%s<S2SV_blank>and<S2SV_blank>output<S2SV_blank>%s"" , TIFFFileName ( input ) , TIFFFileName ( output ) ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } TIFFSetField ( output , TIFFTAG_JPEGTABLESMODE , 0 ) ; if ( t2p -> pdf_colorspace & ( T2P_CS_RGB | T2P_CS_LAB ) ) { TIFFSetField ( output , TIFFTAG_PHOTOMETRIC , PHOTOMETRIC_YCBCR ) ; if ( t2p -> tiff_photometric != PHOTOMETRIC_YCBCR ) { TIFFSetField ( output , TIFFTAG_JPEGCOLORMODE , JPEGCOLORMODE_RGB ) ; } else { TIFFSetField ( output , TIFFTAG_JPEGCOLORMODE , JPEGCOLORMODE_RAW ) ; } } if ( t2p -> pdf_colorspace & T2P_CS_GRAY ) { ( void ) 0 ; } if ( t2p -> pdf_colorspace & T2P_CS_CMYK ) { ( void ) 0 ; } if ( t2p -> pdf_defaultcompressionquality != 0 ) { TIFFSetField ( output , TIFFTAG_JPEGQUALITY , t2p -> pdf_defaultcompressionquality ) ; } break ; # endif # ifdef ZIP_SUPPORT case T2P_COMPRESS_ZIP : TIFFSetField ( output , TIFFTAG_COMPRESSION , COMPRESSION_DEFLATE ) ; if ( t2p -> pdf_defaultcompressionquality % 100 != 0 ) { TIFFSetField ( output , TIFFTAG_PREDICTOR , t2p -> pdf_defaultcompressionquality % 100 ) ; } if ( t2p -> pdf_defaultcompressionquality / 100 != 0 ) { TIFFSetField ( output , TIFFTAG_ZIPQUALITY , ( t2p -> pdf_defaultcompressionquality / 100 ) ) ; } break ; # endif default : break ; } t2p_enable ( output ) ; t2p -> outputwritten = 0 ; # ifdef JPEG_SUPPORT if ( t2p -> pdf_compression == T2P_COMPRESS_JPEG && t2p -> tiff_photometric == PHOTOMETRIC_YCBCR ) { bufferoffset = TIFFWriteEncodedStrip ( output , ( tstrip_t ) 0 , buffer , stripsize * stripcount ) ; } else # endif { bufferoffset = TIFFWriteEncodedStrip ( output , ( tstrip_t ) 0 , buffer , t2p -> tiff_datasize ) ; } if ( buffer != NULL ) { _TIFFfree ( buffer ) ; buffer = NULL ; } if ( bufferoffset == ( tsize_t ) - 1 ) { TIFFError ( TIFF2PDF_MODULE , ""Error<S2SV_blank>writing<S2SV_blank>encoded<S2SV_blank>strip<S2SV_blank>to<S2SV_blank>output<S2SV_blank>PDF<S2SV_blank>%s"" , TIFFFileName ( output ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } written = t2p -> outputwritten ; return ( written ) ; }
","<S2SV_ModStart> , buffer , t2p -> tiff_datasize ,
"
896,"CWE-000 int pam_sm_authenticate ( pam_handle_t * pamh , int flags , int argc , const char * * argv ) { struct passwd * pw = NULL , pw_s ; const char * user = NULL ; cfg_t cfg_st ; cfg_t * cfg = & cfg_st ; char buffer [ BUFSIZE ] ; char * buf = NULL ; char * authfile_dir ; size_t authfile_dir_len ; int pgu_ret , gpn_ret ; int retval = PAM_IGNORE ; device_t * devices = NULL ; unsigned n_devices = 0 ; int openasuser ; int should_free_origin = 0 ; int should_free_appid = 0 ; int should_free_auth_file = 0 ; int should_free_authpending_file = 0 ; parse_cfg ( flags , argc , argv , cfg ) ; if ( ! cfg -> origin ) { strcpy ( buffer , DEFAULT_ORIGIN_PREFIX ) ; if ( gethostname ( buffer + strlen ( DEFAULT_ORIGIN_PREFIX ) , BUFSIZE - strlen ( DEFAULT_ORIGIN_PREFIX ) ) == - 1 ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>host<S2SV_blank>name"" ) ; goto done ; } DBG ( ""Origin<S2SV_blank>not<S2SV_blank>specified,<S2SV_blank>using<S2SV_blank>\\""%s\\"""" , buffer ) ; cfg -> origin = strdup ( buffer ) ; if ( ! cfg -> origin ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto done ; } else { should_free_origin = 1 ; } } if ( ! cfg -> appid ) { DBG ( ""Appid<S2SV_blank>not<S2SV_blank>specified,<S2SV_blank>using<S2SV_blank>the<S2SV_blank>same<S2SV_blank>value<S2SV_blank>of<S2SV_blank>origin<S2SV_blank>(%s)"" , cfg -> origin ) ; cfg -> appid = strdup ( cfg -> origin ) ; if ( ! cfg -> appid ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory"" ) goto done ; } else { should_free_appid = 1 ; } } if ( cfg -> max_devs == 0 ) { DBG ( ""Maximum<S2SV_blank>devices<S2SV_blank>number<S2SV_blank>not<S2SV_blank>set.<S2SV_blank>Using<S2SV_blank>default<S2SV_blank>(%d)"" , MAX_DEVS ) ; cfg -> max_devs = MAX_DEVS ; } devices = malloc ( sizeof ( device_t ) * cfg -> max_devs ) ; if ( ! devices ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory"" ) ; retval = PAM_IGNORE ; goto done ; } pgu_ret = pam_get_user ( pamh , & user , NULL ) ; if ( pgu_ret != PAM_SUCCESS || user == NULL ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>access<S2SV_blank>user<S2SV_blank>%s"" , user ) ; retval = PAM_CONV_ERR ; goto done ; } DBG ( ""Requesting<S2SV_blank>authentication<S2SV_blank>for<S2SV_blank>user<S2SV_blank>%s"" , user ) ; gpn_ret = getpwnam_r ( user , & pw_s , buffer , sizeof ( buffer ) , & pw ) ; if ( gpn_ret != 0 || pw == NULL || pw -> pw_dir == NULL || pw -> pw_dir [ 0 ] != '/' ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>retrieve<S2SV_blank>credentials<S2SV_blank>for<S2SV_blank>user<S2SV_blank>%s,<S2SV_blank>(%s)"" , user , strerror ( errno ) ) ; retval = PAM_USER_UNKNOWN ; goto done ; } DBG ( ""Found<S2SV_blank>user<S2SV_blank>%s"" , user ) ; DBG ( ""Home<S2SV_blank>directory<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>%s"" , user , pw -> pw_dir ) ; if ( ! cfg -> auth_file ) { buf = NULL ; authfile_dir = secure_getenv ( DEFAULT_AUTHFILE_DIR_VAR ) ; if ( ! authfile_dir ) { DBG ( ""Variable<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>set.<S2SV_blank>Using<S2SV_blank>default<S2SV_blank>value<S2SV_blank>($HOME/.config/)"" , DEFAULT_AUTHFILE_DIR_VAR ) ; authfile_dir_len = strlen ( pw -> pw_dir ) + strlen ( ""/.config"" ) + strlen ( DEFAULT_AUTHFILE ) + 1 ; buf = malloc ( sizeof ( char ) * ( authfile_dir_len ) ) ; if ( ! buf ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory"" ) ; retval = PAM_IGNORE ; goto done ; } snprintf ( buf , authfile_dir_len , ""%s/.config%s"" , pw -> pw_dir , DEFAULT_AUTHFILE ) ; } else { DBG ( ""Variable<S2SV_blank>%s<S2SV_blank>set<S2SV_blank>to<S2SV_blank>%s"" , DEFAULT_AUTHFILE_DIR_VAR , authfile_dir ) ; authfile_dir_len = strlen ( authfile_dir ) + strlen ( DEFAULT_AUTHFILE ) + 1 ; buf = malloc ( sizeof ( char ) * ( authfile_dir_len ) ) ; if ( ! buf ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory"" ) ; retval = PAM_IGNORE ; goto done ; } snprintf ( buf , authfile_dir_len , ""%s%s"" , authfile_dir , DEFAULT_AUTHFILE ) ; } DBG ( ""Using<S2SV_blank>default<S2SV_blank>authentication<S2SV_blank>file<S2SV_blank>%s"" , buf ) ; cfg -> auth_file = buf ; should_free_auth_file = 1 ; buf = NULL ; } else { DBG ( ""Using<S2SV_blank>authentication<S2SV_blank>file<S2SV_blank>%s"" , cfg -> auth_file ) ; } openasuser = geteuid ( ) == 0 && cfg -> openasuser ; if ( openasuser ) { if ( seteuid ( pw_s . pw_uid ) ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>user<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>%i"" , pw_s . pw_uid ) ; retval = PAM_IGNORE ; goto done ; } DBG ( ""Switched<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>%i"" , pw_s . pw_uid ) ; } retval = get_devices_from_authfile ( cfg -> auth_file , user , cfg -> max_devs , cfg -> debug , cfg -> debug_file , devices , & n_devices ) ; if ( openasuser ) { if ( seteuid ( 0 ) ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>back<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>0"" ) ; retval = PAM_IGNORE ; goto done ; } DBG ( ""Switched<S2SV_blank>back<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>0"" ) ; } if ( retval != 1 ) { n_devices = 0 ; } if ( n_devices == 0 ) { if ( cfg -> nouserok ) { DBG ( ""Found<S2SV_blank>no<S2SV_blank>devices<S2SV_blank>but<S2SV_blank>nouserok<S2SV_blank>specified.<S2SV_blank>Skipping<S2SV_blank>authentication"" ) ; retval = PAM_SUCCESS ; goto done ; } else if ( retval != 1 ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>devices<S2SV_blank>from<S2SV_blank>file<S2SV_blank>%s"" , cfg -> auth_file ) ; retval = PAM_AUTHINFO_UNAVAIL ; goto done ; } else { DBG ( ""Found<S2SV_blank>no<S2SV_blank>devices.<S2SV_blank>Aborting."" ) ; retval = PAM_AUTHINFO_UNAVAIL ; goto done ; } } if ( ! cfg -> authpending_file ) { int actual_size = snprintf ( buffer , BUFSIZE , DEFAULT_AUTHPENDING_FILE_PATH , getuid ( ) ) ; if ( actual_size >= 0 && actual_size < BUFSIZE ) { cfg -> authpending_file = strdup ( buffer ) ; } if ( ! cfg -> authpending_file ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>the<S2SV_blank>authpending_file,<S2SV_blank>touch<S2SV_blank>request<S2SV_blank>notifications<S2SV_blank>will<S2SV_blank>not<S2SV_blank>be<S2SV_blank>emitted"" ) ; } else { should_free_authpending_file = 1 ; } } else { if ( strlen ( cfg -> authpending_file ) == 0 ) { DBG ( ""authpending_file<S2SV_blank>is<S2SV_blank>set<S2SV_blank>to<S2SV_blank>an<S2SV_blank>empty<S2SV_blank>value,<S2SV_blank>touch<S2SV_blank>request<S2SV_blank>notifications<S2SV_blank>will<S2SV_blank>be<S2SV_blank>disabled"" ) ; cfg -> authpending_file = NULL ; } } int authpending_file_descriptor = - 1 ; if ( cfg -> authpending_file ) { DBG ( ""Using<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>for<S2SV_blank>emitting<S2SV_blank>touch<S2SV_blank>request<S2SV_blank>notifications"" , cfg -> authpending_file ) ; <S2SV_StartBug> authpending_file_descriptor = open ( cfg -> authpending_file , O_RDONLY | O_CREAT , 0664 ) ; <S2SV_EndBug> if ( authpending_file_descriptor < 0 ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>emit<S2SV_blank>\'authentication<S2SV_blank>started\'<S2SV_blank>notification<S2SV_blank>by<S2SV_blank>opening<S2SV_blank>the<S2SV_blank>file<S2SV_blank>\'%s\',<S2SV_blank>(%s)"" , cfg -> authpending_file , strerror ( errno ) ) ; } } if ( cfg -> manual == 0 ) { if ( cfg -> interactive ) { converse ( pamh , PAM_PROMPT_ECHO_ON , cfg -> prompt != NULL ? cfg -> prompt : DEFAULT_PROMPT ) ; } retval = do_authentication ( cfg , devices , n_devices , pamh ) ; } else { retval = do_manual_authentication ( cfg , devices , n_devices , pamh ) ; } if ( authpending_file_descriptor >= 0 ) { if ( close ( authpending_file_descriptor ) < 0 ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>emit<S2SV_blank>\'authentication<S2SV_blank>stopped\'<S2SV_blank>notification<S2SV_blank>by<S2SV_blank>closing<S2SV_blank>the<S2SV_blank>file<S2SV_blank>\'%s\',<S2SV_blank>(%s)"" , cfg -> authpending_file , strerror ( errno ) ) ; } } if ( retval != 1 ) { DBG ( ""do_authentication<S2SV_blank>returned<S2SV_blank>%d"" , retval ) ; retval = PAM_AUTH_ERR ; goto done ; } retval = PAM_SUCCESS ; done : free_devices ( devices , n_devices ) ; if ( buf ) { free ( buf ) ; buf = NULL ; } if ( should_free_origin ) { free ( ( char * ) cfg -> origin ) ; cfg -> origin = NULL ; } if ( should_free_appid ) { free ( ( char * ) cfg -> appid ) ; cfg -> appid = NULL ; } if ( should_free_auth_file ) { free ( ( char * ) cfg -> auth_file ) ; cfg -> auth_file = NULL ; } if ( should_free_authpending_file ) { free ( ( char * ) cfg -> authpending_file ) ; cfg -> authpending_file = NULL ; } if ( cfg -> alwaysok && retval != PAM_SUCCESS ) { DBG ( ""alwaysok<S2SV_blank>needed<S2SV_blank>(otherwise<S2SV_blank>return<S2SV_blank>with<S2SV_blank>%d)"" , retval ) ; retval = PAM_SUCCESS ; } DBG ( ""done.<S2SV_blank>[%s]"" , pam_strerror ( pamh , retval ) ) ; <S2SV_StartBug> return retval ; <S2SV_EndBug> }
","<S2SV_ModStart> O_RDONLY | O_CREAT | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY <S2SV_ModStart> ) ) ; if ( cfg -> is_custom_debug_file ) { fclose ( cfg -> debug_file ) ; }
"
897,"CWE-617 int pci_emul_alloc_pbar ( struct pci_vdev * pdi , int idx , uint64_t hostbase , enum pcibar_type type , uint64_t size ) { int error ; uint64_t * baseptr , limit , addr , mask , lobits , bar ; <S2SV_StartBug> assert ( idx >= 0 && idx <= PCI_BARMAX ) ; <S2SV_EndBug> if ( ( size & ( size - 1 ) ) != 0 ) size = 1UL << flsl ( size ) ; if ( type == PCIBAR_IO ) { if ( size < 4 ) size = 4 ; } else { if ( size < 16 ) size = 16 ; } switch ( type ) { case PCIBAR_NONE : baseptr = NULL ; addr = mask = lobits = 0 ; break ; case PCIBAR_IO : baseptr = & pci_emul_iobase ; limit = PCI_EMUL_IOLIMIT ; mask = PCIM_BAR_IO_BASE ; lobits = PCIM_BAR_IO_SPACE ; break ; <S2SV_StartBug> case PCIBAR_MEM64 : <S2SV_EndBug> if ( ! skip_pci_mem64bar_workaround && ( size <= 32 * 1024 * 1024 ) ) { baseptr = & pci_emul_membase32 ; limit = PCI_EMUL_MEMLIMIT32 ; mask = PCIM_BAR_MEM_BASE ; lobits = PCIM_BAR_MEM_SPACE | PCIM_BAR_MEM_64 ; break ; } if ( size == 0x100000000UL ) baseptr = & hostbase ; else baseptr = & pci_emul_membase64 ; limit = PCI_EMUL_MEMLIMIT64 ; mask = PCIM_BAR_MEM_BASE ; lobits = PCIM_BAR_MEM_SPACE | PCIM_BAR_MEM_64 | PCIM_BAR_MEM_PREFETCH ; break ; case PCIBAR_MEM32 : baseptr = & pci_emul_membase32 ; limit = PCI_EMUL_MEMLIMIT32 ; mask = PCIM_BAR_MEM_BASE ; lobits = PCIM_BAR_MEM_SPACE | PCIM_BAR_MEM_32 ; break ; default : <S2SV_StartBug> printf ( ""%s:<S2SV_blank>invalid<S2SV_blank>bar<S2SV_blank>type<S2SV_blank>%d\\n"" , __func__ , type ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( 0 ) ; <S2SV_EndBug> } if ( baseptr != NULL ) { error = pci_emul_alloc_resource ( baseptr , limit , size , & addr ) ; if ( error != 0 ) return error ; } pdi -> bar [ idx ] . type = type ; pdi -> bar [ idx ] . addr = addr ; pdi -> bar [ idx ] . size = size ; bar = ( addr & mask ) | lobits ; pci_set_cfgdata32 ( pdi , PCIR_BAR ( idx ) , bar ) ; if ( type == PCIBAR_MEM64 ) { <S2SV_StartBug> assert ( idx + 1 <= PCI_BARMAX ) ; <S2SV_EndBug> pdi -> bar [ idx + 1 ] . type = PCIBAR_MEMHI64 ; pci_set_cfgdata32 ( pdi , PCIR_BAR ( idx + 1 ) , bar >> 32 ) ; } register_bar ( pdi , idx ) ; return 0 ; }
","<S2SV_ModStart> , bar ; <S2SV_ModEnd> if ( ( <S2SV_ModStart> case PCIBAR_MEM64 : if ( idx + 1 > PCI_BARMAX ) { pr_err ( ""%s:<S2SV_blank>invalid<S2SV_blank>bar<S2SV_blank>number<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>MEM64<S2SV_blank>type\\n"" , __func__ , idx ) ; return - 1 ; } <S2SV_ModStart> ; default : pr_err <S2SV_ModEnd> ( ""%s:<S2SV_blank>invalid<S2SV_blank>bar<S2SV_blank>type<S2SV_blank>%d\\n"" , <S2SV_ModStart> type ) ; return - 1 <S2SV_ModEnd> ; } if <S2SV_ModStart> PCIBAR_MEM64 ) { <S2SV_ModEnd> pdi -> bar
"
898,"CWE-125 int nego_recv ( rdpTransport * transport , wStream * s , void * extra ) { BYTE li ; BYTE type ; UINT16 length ; rdpNego * nego = ( rdpNego * ) extra ; if ( ! tpkt_read_header ( s , & length ) ) return - 1 ; if ( ! tpdu_read_connection_confirm ( s , & li , length ) ) return - 1 ; if ( li > 6 ) { Stream_Read_UINT8 ( s , type ) ; switch ( type ) { case TYPE_RDP_NEG_RSP : <S2SV_StartBug> nego_process_negotiation_response ( nego , s ) ; <S2SV_EndBug> WLog_DBG ( TAG , ""selected_protocol:<S2SV_blank>%"" PRIu32 """" , nego -> SelectedProtocol ) ; if ( nego -> SelectedProtocol ) { if ( ( nego -> SelectedProtocol == PROTOCOL_HYBRID ) && ( ! nego -> EnabledProtocols [ PROTOCOL_HYBRID ] ) ) { nego -> state = NEGO_STATE_FAIL ; } if ( ( nego -> SelectedProtocol == PROTOCOL_SSL ) && ( ! nego -> EnabledProtocols [ PROTOCOL_SSL ] ) ) { nego -> state = NEGO_STATE_FAIL ; } } else if ( ! nego -> EnabledProtocols [ PROTOCOL_RDP ] ) { nego -> state = NEGO_STATE_FAIL ; } break ; case TYPE_RDP_NEG_FAILURE : <S2SV_StartBug> nego_process_negotiation_failure ( nego , s ) ; <S2SV_EndBug> break ; } } else if ( li == 6 ) { WLog_DBG ( TAG , ""no<S2SV_blank>rdpNegData"" ) ; if ( ! nego -> EnabledProtocols [ PROTOCOL_RDP ] ) nego -> state = NEGO_STATE_FAIL ; else nego -> state = NEGO_STATE_FINAL ; } else { WLog_ERR ( TAG , ""invalid<S2SV_blank>negotiation<S2SV_blank>response"" ) ; nego -> state = NEGO_STATE_FAIL ; } if ( ! tpkt_ensure_stream_consumed ( s , length ) ) return - 1 ; return 0 ; }
","<S2SV_ModStart> case TYPE_RDP_NEG_RSP : if ( ! <S2SV_ModStart> , s ) ) return - 1 <S2SV_ModStart> case TYPE_RDP_NEG_FAILURE : if ( ! <S2SV_ModStart> , s ) ) return - 1
"
899,"CWE-000 static int sd2_parse_rsrc_fork ( SF_PRIVATE * psf ) { SD2_RSRC rsrc ; int k , marker , error = 0 ; psf_use_rsrc ( psf , SF_TRUE ) ; memset ( & rsrc , 0 , sizeof ( rsrc ) ) ; rsrc . rsrc_len = psf_get_filelen ( psf ) ; psf_log_printf ( psf , ""Resource<S2SV_blank>length<S2SV_blank>:<S2SV_blank>%d<S2SV_blank>(0x%04X)\\n"" , rsrc . rsrc_len , rsrc . rsrc_len ) ; if ( rsrc . rsrc_len > SIGNED_SIZEOF ( psf -> header ) ) { rsrc . rsrc_data = calloc ( 1 , rsrc . rsrc_len ) ; rsrc . need_to_free_rsrc_data = SF_TRUE ; } else { rsrc . rsrc_data = psf -> header ; rsrc . need_to_free_rsrc_data = SF_FALSE ; } ; psf_fread ( rsrc . rsrc_data , rsrc . rsrc_len , 1 , psf ) ; psf -> headindex = psf -> headend = rsrc . rsrc_len ; rsrc . data_offset = read_rsrc_int ( & rsrc , 0 ) ; rsrc . map_offset = read_rsrc_int ( & rsrc , 4 ) ; rsrc . data_length = read_rsrc_int ( & rsrc , 8 ) ; rsrc . map_length = read_rsrc_int ( & rsrc , 12 ) ; if ( rsrc . data_offset == 0x51607 && rsrc . map_offset == 0x20000 ) { psf_log_printf ( psf , ""Trying<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>0x52<S2SV_blank>bytes.\\n"" ) ; rsrc . data_offset = read_rsrc_int ( & rsrc , 0x52 + 0 ) + 0x52 ; rsrc . map_offset = read_rsrc_int ( & rsrc , 0x52 + 4 ) + 0x52 ; rsrc . data_length = read_rsrc_int ( & rsrc , 0x52 + 8 ) ; rsrc . map_length = read_rsrc_int ( & rsrc , 0x52 + 12 ) ; } ; psf_log_printf ( psf , ""<S2SV_blank><S2SV_blank>data<S2SV_blank>offset<S2SV_blank>:<S2SV_blank>0x%04X\\n<S2SV_blank><S2SV_blank>map<S2SV_blank><S2SV_blank>offset<S2SV_blank>:<S2SV_blank>0x%04X\\n"" ""<S2SV_blank><S2SV_blank>data<S2SV_blank>length<S2SV_blank>:<S2SV_blank>0x%04X\\n<S2SV_blank><S2SV_blank>map<S2SV_blank><S2SV_blank>length<S2SV_blank>:<S2SV_blank>0x%04X\\n"" , rsrc . data_offset , rsrc . map_offset , rsrc . data_length , rsrc . map_length ) ; if ( rsrc . data_offset > rsrc . rsrc_len ) { psf_log_printf ( psf , ""Error<S2SV_blank>:<S2SV_blank>rsrc.data_offset<S2SV_blank>(%d,<S2SV_blank>0x%x)<S2SV_blank>><S2SV_blank>len\\n"" , rsrc . data_offset , rsrc . data_offset ) ; error = SFE_SD2_BAD_DATA_OFFSET ; goto parse_rsrc_fork_cleanup ; } ; if ( rsrc . map_offset > rsrc . rsrc_len ) { psf_log_printf ( psf , ""Error<S2SV_blank>:<S2SV_blank>rsrc.map_offset<S2SV_blank>><S2SV_blank>len\\n"" ) ; error = SFE_SD2_BAD_MAP_OFFSET ; goto parse_rsrc_fork_cleanup ; } ; if ( rsrc . data_length > rsrc . rsrc_len ) { psf_log_printf ( psf , ""Error<S2SV_blank>:<S2SV_blank>rsrc.data_length<S2SV_blank>><S2SV_blank>len\\n"" ) ; error = SFE_SD2_BAD_DATA_LENGTH ; goto parse_rsrc_fork_cleanup ; } ; if ( rsrc . map_length > rsrc . rsrc_len ) { psf_log_printf ( psf , ""Error<S2SV_blank>:<S2SV_blank>rsrc.map_length<S2SV_blank>><S2SV_blank>len\\n"" ) ; error = SFE_SD2_BAD_MAP_LENGTH ; goto parse_rsrc_fork_cleanup ; } ; if ( rsrc . data_offset + rsrc . data_length != rsrc . map_offset || rsrc . map_offset + rsrc . map_length != rsrc . rsrc_len ) { psf_log_printf ( psf , ""Error<S2SV_blank>:<S2SV_blank>This<S2SV_blank>does<S2SV_blank>not<S2SV_blank>look<S2SV_blank>like<S2SV_blank>a<S2SV_blank>MacOSX<S2SV_blank>resource<S2SV_blank>fork.\\n"" ) ; error = SFE_SD2_BAD_RSRC ; goto parse_rsrc_fork_cleanup ; } ; if ( rsrc . map_offset + 28 >= rsrc . rsrc_len ) { psf_log_printf ( psf , ""Bad<S2SV_blank>map<S2SV_blank>offset<S2SV_blank>(%d<S2SV_blank>+<S2SV_blank>28<S2SV_blank>><S2SV_blank>%d).\\n"" , rsrc . map_offset , rsrc . rsrc_len ) ; error = SFE_SD2_BAD_RSRC ; goto parse_rsrc_fork_cleanup ; } ; rsrc . string_offset = rsrc . map_offset + read_rsrc_short ( & rsrc , rsrc . map_offset + 26 ) ; if ( rsrc . string_offset > rsrc . rsrc_len ) { psf_log_printf ( psf , ""Bad<S2SV_blank>string<S2SV_blank>offset<S2SV_blank>(%d).\\n"" , rsrc . string_offset ) ; error = SFE_SD2_BAD_RSRC ; goto parse_rsrc_fork_cleanup ; } ; rsrc . type_offset = rsrc . map_offset + 30 ; <S2SV_StartBug> rsrc . type_count = read_rsrc_short ( & rsrc , rsrc . map_offset + 28 ) + 1 ; <S2SV_EndBug> if ( rsrc . type_count < 1 ) { psf_log_printf ( psf , ""Bad<S2SV_blank>type<S2SV_blank>count.\\n"" ) ; error = SFE_SD2_BAD_RSRC ; goto parse_rsrc_fork_cleanup ; } ; rsrc . item_offset = rsrc . type_offset + rsrc . type_count * 8 ; if ( rsrc . item_offset < 0 || rsrc . item_offset > rsrc . rsrc_len ) { psf_log_printf ( psf , ""Bad<S2SV_blank>item<S2SV_blank>offset<S2SV_blank>(%d).\\n"" , rsrc . item_offset ) ; error = SFE_SD2_BAD_RSRC ; goto parse_rsrc_fork_cleanup ; } ; rsrc . str_index = - 1 ; for ( k = 0 ; k < rsrc . type_count ; k ++ ) <S2SV_StartBug> { marker = read_rsrc_marker ( & rsrc , rsrc . type_offset + k * 8 ) ; <S2SV_EndBug> if ( marker == STR_MARKER ) { rsrc . str_index = k ; rsrc . str_count = read_rsrc_short ( & rsrc , rsrc . type_offset + k * 8 + 4 ) + 1 ; error = parse_str_rsrc ( psf , & rsrc ) ; goto parse_rsrc_fork_cleanup ; } ; } ; psf_log_printf ( psf , ""No<S2SV_blank>\'STR<S2SV_blank>\'<S2SV_blank>resource.\\n"" ) ; error = SFE_SD2_BAD_RSRC ; parse_rsrc_fork_cleanup : psf_use_rsrc ( psf , SF_FALSE ) ; if ( rsrc . need_to_free_rsrc_data ) free ( rsrc . rsrc_data ) ; return error ; }
","<S2SV_ModStart> + 30 ; if ( rsrc . map_offset + 28 > rsrc . rsrc_len ) { psf_log_printf ( psf , ""Bad<S2SV_blank>map<S2SV_blank>offset.\\n"" ) ; goto parse_rsrc_fork_cleanup ; } ; <S2SV_ModStart> ++ ) { if ( <S2SV_ModEnd> rsrc . type_offset <S2SV_ModStart> k * 8 > rsrc . rsrc_len ) { psf_log_printf ( psf , ""Bad<S2SV_blank>rsrc<S2SV_blank>marker.\\n"" ) ; goto parse_rsrc_fork_cleanup ; } ; marker = read_rsrc_marker ( & rsrc , rsrc . type_offset + k * 8
"
900,"CWE-399 void br_mdb_notify ( struct net_device * dev , struct net_bridge_port * port , struct br_ip * group , int type ) { <S2SV_StartBug> struct br_mdb_entry entry ; <S2SV_EndBug> entry . ifindex = port -> dev -> ifindex ; entry . addr . proto = group -> proto ; entry . addr . u . ip4 = group -> u . ip4 ; # if IS_ENABLED ( CONFIG_IPV6 ) entry . addr . u . ip6 = group -> u . ip6 ; # endif __br_mdb_notify ( dev , & entry , type ) ; }
","<S2SV_ModStart> struct br_mdb_entry entry ; memset ( & entry , 0 , sizeof ( entry ) )
"
901,"CWE-125 static int name_parse ( u8 * packet , int length , int * idx , char * name_out , int name_out_len ) { int name_end = - 1 ; int j = * idx ; int ptr_count = 0 ; # define GET32 ( x ) do { if ( j + 4 > length ) goto err ; memcpy ( & t32_ , packet + j , 4 ) ; j += 4 ; x = ntohl ( t32_ ) ; } while ( 0 ) # define GET16 ( x ) do { if ( j + 2 > length ) goto err ; memcpy ( & t_ , packet + j , 2 ) ; j += 2 ; x = ntohs ( t_ ) ; } while ( 0 ) # define GET8 ( x ) do { if ( j >= length ) goto err ; x = packet [ j ++ ] ; } while ( 0 ) char * cp = name_out ; const char * const end = name_out + name_out_len ; for ( ; ; ) { u8 label_len ; <S2SV_StartBug> if ( j >= length ) return - 1 ; <S2SV_EndBug> GET8 ( label_len ) ; if ( ! label_len ) break ; if ( label_len & 0xc0 ) { u8 ptr_low ; GET8 ( ptr_low ) ; if ( name_end < 0 ) name_end = j ; j = ( ( ( int ) label_len & 0x3f ) << 8 ) + ptr_low ; if ( j < 0 || j >= length ) return - 1 ; if ( ++ ptr_count > length ) return - 1 ; continue ; } if ( label_len > 63 ) return - 1 ; if ( cp != name_out ) { if ( cp + 1 >= end ) return - 1 ; * cp ++ = '.' ; } if ( cp + label_len >= end ) return - 1 ; <S2SV_StartBug> memcpy ( cp , packet + j , label_len ) ; <S2SV_EndBug> cp += label_len ; j += label_len ; } if ( cp >= end ) return - 1 ; * cp = '\\0' ; if ( name_end < 0 ) * idx = j ; else * idx = name_end ; return 0 ; err : return - 1 ; }
","<S2SV_ModStart> u8 label_len ; <S2SV_ModEnd> GET8 ( label_len <S2SV_ModStart> - 1 ; if ( j + label_len > length ) return - 1 ;
"
902,"CWE-20 int bpf_check ( struct bpf_prog * * prog , union bpf_attr * attr ) { struct bpf_verifier_env * env ; struct bpf_verifer_log * log ; int ret = - EINVAL ; if ( ARRAY_SIZE ( bpf_verifier_ops ) == 0 ) return - EINVAL ; env = kzalloc ( sizeof ( struct bpf_verifier_env ) , GFP_KERNEL ) ; if ( ! env ) return - ENOMEM ; log = & env -> log ; env -> insn_aux_data = vzalloc ( sizeof ( struct bpf_insn_aux_data ) * ( * prog ) -> len ) ; ret = - ENOMEM ; if ( ! env -> insn_aux_data ) goto err_free_env ; env -> prog = * prog ; env -> ops = bpf_verifier_ops [ env -> prog -> type ] ; mutex_lock ( & bpf_verifier_lock ) ; if ( attr -> log_level || attr -> log_buf || attr -> log_size ) { log -> level = attr -> log_level ; log -> ubuf = ( char __user * ) ( unsigned long ) attr -> log_buf ; log -> len_total = attr -> log_size ; ret = - EINVAL ; if ( log -> len_total < 128 || log -> len_total > UINT_MAX >> 8 || ! log -> level || ! log -> ubuf ) goto err_unlock ; } env -> strict_alignment = ! ! ( attr -> prog_flags & BPF_F_STRICT_ALIGNMENT ) ; if ( ! IS_ENABLED ( CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS ) ) env -> strict_alignment = true ; if ( env -> prog -> aux -> offload ) { ret = bpf_prog_offload_verifier_prep ( env ) ; if ( ret ) goto err_unlock ; } ret = replace_map_fd_with_map_ptr ( env ) ; if ( ret < 0 ) goto skip_full_check ; env -> explored_states = kcalloc ( env -> prog -> len , sizeof ( struct bpf_verifier_state_list * ) , GFP_USER ) ; ret = - ENOMEM ; if ( ! env -> explored_states ) goto skip_full_check ; ret = check_cfg ( env ) ; if ( ret < 0 ) goto skip_full_check ; env -> allow_ptr_leaks = capable ( CAP_SYS_ADMIN ) ; ret = do_check ( env ) ; if ( env -> cur_state ) { free_verifier_state ( env -> cur_state , true ) ; env -> cur_state = NULL ; } skip_full_check : while ( ! pop_stack ( env , NULL , NULL ) ) ; free_states ( env ) ; if ( ret == 0 ) <S2SV_StartBug> ret = convert_ctx_accesses ( env ) ; <S2SV_EndBug> if ( ret == 0 ) ret = fixup_bpf_calls ( env ) ; if ( log -> level && bpf_verifier_log_full ( log ) ) ret = - ENOSPC ; if ( log -> level && ! log -> ubuf ) { ret = - EFAULT ; goto err_release_maps ; } if ( ret == 0 && env -> used_map_cnt ) { env -> prog -> aux -> used_maps = kmalloc_array ( env -> used_map_cnt , sizeof ( env -> used_maps [ 0 ] ) , GFP_KERNEL ) ; if ( ! env -> prog -> aux -> used_maps ) { ret = - ENOMEM ; goto err_release_maps ; } memcpy ( env -> prog -> aux -> used_maps , env -> used_maps , sizeof ( env -> used_maps [ 0 ] ) * env -> used_map_cnt ) ; env -> prog -> aux -> used_map_cnt = env -> used_map_cnt ; convert_pseudo_ld_imm64 ( env ) ; } err_release_maps : if ( ! env -> prog -> aux -> used_maps ) release_maps ( env ) ; * prog = env -> prog ; err_unlock : mutex_unlock ( & bpf_verifier_lock ) ; vfree ( env -> insn_aux_data ) ; err_free_env : kfree ( env ) ; return ret ; }
","<S2SV_ModStart> == 0 ) sanitize_dead_code ( env ) ; if ( ret == 0 )
"
903,"CWE-362 static int <S2SV_StartBug> mptctl_eventreport ( unsigned long arg ) <S2SV_EndBug> { struct mpt_ioctl_eventreport __user * uarg = ( void __user * ) arg ; struct mpt_ioctl_eventreport karg ; <S2SV_StartBug> MPT_ADAPTER * ioc ; <S2SV_EndBug> int iocnum ; int numBytes , maxEvents , max ; if ( copy_from_user ( & karg , uarg , sizeof ( struct mpt_ioctl_eventreport ) ) ) { printk ( KERN_ERR MYNAM ""%s@%d::mptctl_eventreport<S2SV_blank>-<S2SV_blank>"" ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>mpt_ioctl_eventreport<S2SV_blank>struct<S2SV_blank>@<S2SV_blank>%p\\n"" , __FILE__ , __LINE__ , uarg ) ; <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> } if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || ( ioc == NULL ) ) { printk ( KERN_DEBUG MYNAM ""%s::mptctl_eventreport()<S2SV_blank>@%d<S2SV_blank>-<S2SV_blank>ioc%d<S2SV_blank>not<S2SV_blank>found!\\n"" , __FILE__ , __LINE__ , iocnum ) ; return - ENODEV ; } dctlprintk ( ioc , printk ( MYIOC_s_DEBUG_FMT ""mptctl_eventreport<S2SV_blank>called.\\n"" , ioc -> name ) ) ; numBytes = karg . hdr . maxDataSize - sizeof ( mpt_ioctl_header ) ; maxEvents = numBytes / sizeof ( MPT_IOCTL_EVENTS ) ; max = MPTCTL_EVENT_LOG_SIZE < maxEvents ? MPTCTL_EVENT_LOG_SIZE : maxEvents ; if ( ( max < 1 ) || ! ioc -> events ) return - ENODATA ; ioc -> aen_event_read_flag = 0 ; numBytes = max * sizeof ( MPT_IOCTL_EVENTS ) ; if ( copy_to_user ( uarg -> eventData , ioc -> events , numBytes ) ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_eventreport<S2SV_blank>-<S2SV_blank>"" ""Unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>out<S2SV_blank>mpt_ioctl_eventreport<S2SV_blank>struct<S2SV_blank>@<S2SV_blank>%p\\n"" , ioc -> name , __FILE__ , __LINE__ , ioc -> events ) ; return - EFAULT ; } return 0 ; }
","<S2SV_ModStart> int mptctl_eventreport ( MPT_ADAPTER * ioc , <S2SV_ModStart> mpt_ioctl_eventreport karg ; <S2SV_ModEnd> int numBytes , <S2SV_ModStart> return - EFAULT <S2SV_ModEnd> ; } dctlprintk
"
904,"CWE-125 static inline LineContribType * _gdContributionsCalc ( unsigned int line_size , unsigned int src_size , double scale_d , const interpolation_method pFilter ) { double width_d ; double scale_f_d = 1.0 ; const double filter_width_d = DEFAULT_BOX_RADIUS ; int windows_size ; unsigned int u ; LineContribType * res ; if ( scale_d < 1.0 ) { width_d = filter_width_d / scale_d ; scale_f_d = scale_d ; } else { width_d = filter_width_d ; } windows_size = 2 * ( int ) ceil ( width_d ) + 1 ; res = _gdContributionsAlloc ( line_size , windows_size ) ; for ( u = 0 ; u < line_size ; u ++ ) { const double dCenter = ( double ) u / scale_d ; register int iLeft = MAX ( 0 , ( int ) floor ( dCenter - width_d ) ) ; int iRight = MIN ( ( int ) ceil ( dCenter + width_d ) , ( int ) src_size - 1 ) ; double dTotalWeight = 0.0 ; <S2SV_StartBug> int iSrc ; <S2SV_EndBug> res -> ContribRow [ u ] . Left = iLeft ; res -> ContribRow [ u ] . Right = iRight ; if ( iRight - iLeft + 1 > windows_size ) { if ( iLeft < ( ( int ) src_size - 1 / 2 ) ) { iLeft ++ ; } else { iRight -- ; } } <S2SV_StartBug> for ( iSrc = iLeft ; iSrc <= iRight ; iSrc ++ ) { <S2SV_EndBug> <S2SV_StartBug> dTotalWeight += ( res -> ContribRow [ u ] . Weights [ iSrc - iLeft ] = scale_f_d * ( * pFilter ) ( scale_f_d * ( dCenter - ( double ) iSrc ) ) ) ; <S2SV_EndBug> } if ( dTotalWeight < 0.0 ) { _gdContributionsFree ( res ) ; return NULL ; } if ( dTotalWeight > 0.0 ) { for ( iSrc = iLeft ; iSrc <= iRight ; iSrc ++ ) { res -> ContribRow [ u ] . Weights [ iSrc - iLeft ] /= dTotalWeight ; } } } return res ; }
","<S2SV_ModStart> ; int iSrc <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; } } <S2SV_ModEnd> res -> ContribRow <S2SV_ModStart> u ] . Left = iLeft ; res -> ContribRow [ u ] . Right = iRight ; for ( iSrc = iLeft ; iSrc <= iRight ; iSrc ++ ) { dTotalWeight += ( res -> ContribRow [ u ] .
"
905,"CWE-617 static krb5_error_code s4u_identify_user ( krb5_context context , krb5_creds * in_creds , krb5_data * subject_cert , krb5_principal * canon_user ) { krb5_error_code code ; krb5_preauthtype ptypes [ 1 ] = { KRB5_PADATA_S4U_X509_USER } ; krb5_creds creds ; int use_master = 0 ; krb5_get_init_creds_opt * opts = NULL ; krb5_principal_data client ; krb5_s4u_userid userid ; * canon_user = NULL ; if ( in_creds -> client == NULL && subject_cert == NULL ) { return EINVAL ; } if ( in_creds -> client != NULL && in_creds -> client -> type != KRB5_NT_ENTERPRISE_PRINCIPAL ) { int anonymous ; anonymous = krb5_principal_compare ( context , in_creds -> client , krb5_anonymous_principal ( ) ) ; return krb5_copy_principal ( context , anonymous ? in_creds -> server : in_creds -> client , canon_user ) ; } memset ( & creds , 0 , sizeof ( creds ) ) ; memset ( & userid , 0 , sizeof ( userid ) ) ; if ( subject_cert != NULL ) userid . subject_cert = * subject_cert ; code = krb5_get_init_creds_opt_alloc ( context , & opts ) ; if ( code != 0 ) goto cleanup ; krb5_get_init_creds_opt_set_tkt_life ( opts , 15 ) ; krb5_get_init_creds_opt_set_renew_life ( opts , 0 ) ; krb5_get_init_creds_opt_set_forwardable ( opts , 0 ) ; krb5_get_init_creds_opt_set_proxiable ( opts , 0 ) ; krb5_get_init_creds_opt_set_canonicalize ( opts , 1 ) ; krb5_get_init_creds_opt_set_preauth_list ( opts , ptypes , 1 ) ; if ( in_creds -> client != NULL ) { client = * in_creds -> client ; client . realm = in_creds -> server -> realm ; } else { client . magic = KV5M_PRINCIPAL ; client . realm = in_creds -> server -> realm ; client . data = NULL ; client . length = 0 ; client . type = KRB5_NT_ENTERPRISE_PRINCIPAL ; } code = k5_get_init_creds ( context , & creds , & client , NULL , NULL , 0 , NULL , opts , krb5_get_as_key_noop , & userid , & use_master , NULL ) ; <S2SV_StartBug> if ( code == 0 || code == KRB5_PREAUTH_FAILED ) { <S2SV_EndBug> * canon_user = userid . user ; userid . user = NULL ; code = 0 ; } cleanup : krb5_free_cred_contents ( context , & creds ) ; if ( opts != NULL ) krb5_get_init_creds_opt_free ( context , opts ) ; if ( userid . user != NULL ) krb5_free_principal ( context , userid . user ) ; return code ; }
","<S2SV_ModStart> ; if ( ! code <S2SV_ModEnd> || code == <S2SV_ModStart> code == KRB5_PREAUTH_FAILED || code == KRB5KDC_ERR_KEY_EXP
"
906,"CWE-399 int tcp_rcv_state_process ( struct sock * sk , struct sk_buff * skb , const struct tcphdr * th , unsigned int len ) { struct tcp_sock * tp = tcp_sk ( sk ) ; struct inet_connection_sock * icsk = inet_csk ( sk ) ; int queued = 0 ; int res ; tp -> rx_opt . saw_tstamp = 0 ; switch ( sk -> sk_state ) { case TCP_CLOSE : goto discard ; case TCP_LISTEN : if ( th -> ack ) return 1 ; if ( th -> rst ) goto discard ; if ( th -> syn ) { <S2SV_StartBug> if ( icsk -> icsk_af_ops -> conn_request ( sk , skb ) < 0 ) <S2SV_EndBug> return 1 ; kfree_skb ( skb ) ; return 0 ; } goto discard ; case TCP_SYN_SENT : queued = tcp_rcv_synsent_state_process ( sk , skb , th , len ) ; if ( queued >= 0 ) return queued ; tcp_urg ( sk , skb , th ) ; __kfree_skb ( skb ) ; tcp_data_snd_check ( sk ) ; return 0 ; } res = tcp_validate_incoming ( sk , skb , th , 0 ) ; if ( res <= 0 ) return - res ; if ( th -> ack ) { int acceptable = tcp_ack ( sk , skb , FLAG_SLOWPATH ) > 0 ; switch ( sk -> sk_state ) { case TCP_SYN_RECV : if ( acceptable ) { tp -> copied_seq = tp -> rcv_nxt ; smp_mb ( ) ; tcp_set_state ( sk , TCP_ESTABLISHED ) ; sk -> sk_state_change ( sk ) ; if ( sk -> sk_socket ) sk_wake_async ( sk , SOCK_WAKE_IO , POLL_OUT ) ; tp -> snd_una = TCP_SKB_CB ( skb ) -> ack_seq ; tp -> snd_wnd = ntohs ( th -> window ) << tp -> rx_opt . snd_wscale ; tcp_init_wl ( tp , TCP_SKB_CB ( skb ) -> seq ) ; if ( tp -> rx_opt . tstamp_ok ) tp -> advmss -= TCPOLEN_TSTAMP_ALIGNED ; icsk -> icsk_af_ops -> rebuild_header ( sk ) ; tcp_init_metrics ( sk ) ; tcp_init_congestion_control ( sk ) ; tp -> lsndtime = tcp_time_stamp ; tcp_mtup_init ( sk ) ; tcp_initialize_rcv_mss ( sk ) ; tcp_init_buffer_space ( sk ) ; tcp_fast_path_on ( tp ) ; } else { return 1 ; } break ; case TCP_FIN_WAIT1 : if ( tp -> snd_una == tp -> write_seq ) { tcp_set_state ( sk , TCP_FIN_WAIT2 ) ; sk -> sk_shutdown |= SEND_SHUTDOWN ; dst_confirm ( __sk_dst_get ( sk ) ) ; if ( ! sock_flag ( sk , SOCK_DEAD ) ) sk -> sk_state_change ( sk ) ; else { int tmo ; if ( tp -> linger2 < 0 || ( TCP_SKB_CB ( skb ) -> end_seq != TCP_SKB_CB ( skb ) -> seq && after ( TCP_SKB_CB ( skb ) -> end_seq - th -> fin , tp -> rcv_nxt ) ) ) { tcp_done ( sk ) ; NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_TCPABORTONDATA ) ; return 1 ; } tmo = tcp_fin_time ( sk ) ; if ( tmo > TCP_TIMEWAIT_LEN ) { inet_csk_reset_keepalive_timer ( sk , tmo - TCP_TIMEWAIT_LEN ) ; } else if ( th -> fin || sock_owned_by_user ( sk ) ) { inet_csk_reset_keepalive_timer ( sk , tmo ) ; } else { tcp_time_wait ( sk , TCP_FIN_WAIT2 , tmo ) ; goto discard ; } } } break ; case TCP_CLOSING : if ( tp -> snd_una == tp -> write_seq ) { tcp_time_wait ( sk , TCP_TIME_WAIT , 0 ) ; goto discard ; } break ; case TCP_LAST_ACK : if ( tp -> snd_una == tp -> write_seq ) { tcp_update_metrics ( sk ) ; tcp_done ( sk ) ; goto discard ; } break ; } } else goto discard ; tcp_urg ( sk , skb , th ) ; switch ( sk -> sk_state ) { case TCP_CLOSE_WAIT : case TCP_CLOSING : case TCP_LAST_ACK : if ( ! before ( TCP_SKB_CB ( skb ) -> seq , tp -> rcv_nxt ) ) break ; case TCP_FIN_WAIT1 : case TCP_FIN_WAIT2 : if ( sk -> sk_shutdown & RCV_SHUTDOWN ) { if ( TCP_SKB_CB ( skb ) -> end_seq != TCP_SKB_CB ( skb ) -> seq && after ( TCP_SKB_CB ( skb ) -> end_seq - th -> fin , tp -> rcv_nxt ) ) { NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_TCPABORTONDATA ) ; tcp_reset ( sk ) ; return 1 ; } } case TCP_ESTABLISHED : tcp_data_queue ( sk , skb ) ; queued = 1 ; break ; } if ( sk -> sk_state != TCP_CLOSE ) { tcp_data_snd_check ( sk ) ; tcp_ack_snd_check ( sk ) ; } if ( ! queued ) { discard : __kfree_skb ( skb ) ; } return 0 ; }
","<S2SV_ModStart> { if ( th -> fin ) goto discard ; if (
"
907,"CWE-476 static int jp2_cmap_getdata ( jp2_box_t * box , jas_stream_t * in ) { jp2_cmap_t * cmap = & box -> data . cmap ; jp2_cmapent_t * ent ; <S2SV_StartBug> unsigned int i ; <S2SV_EndBug> cmap -> numchans = ( box -> datalen ) / 4 ; if ( ! ( cmap -> ents = jas_alloc2 ( cmap -> numchans , sizeof ( jp2_cmapent_t ) ) ) ) { return - 1 ; } for ( i = 0 ; i < cmap -> numchans ; ++ i ) { ent = & cmap -> ents [ i ] ; if ( jp2_getuint16 ( in , & ent -> cmptno ) || jp2_getuint8 ( in , & ent -> map ) || jp2_getuint8 ( in , & ent -> pcol ) ) { return - 1 ; } } return 0 ; }
","<S2SV_ModStart> unsigned int i ; cmap -> ents = 0
"
908,"CWE-494 const char * WinPKIErrorString ( void ) { static char error_string [ 64 ] ; DWORD error_code = GetLastError ( ) ; <S2SV_StartBug> if ( ( error_code >> 16 ) != 0x8009 ) <S2SV_EndBug> return WindowsErrorString ( ) ; switch ( error_code ) { case NTE_BAD_UID : return ""Bad<S2SV_blank>UID."" ; case CRYPT_E_MSG_ERROR : return ""An<S2SV_blank>error<S2SV_blank>occurred<S2SV_blank>while<S2SV_blank>performing<S2SV_blank>an<S2SV_blank>operation<S2SV_blank>on<S2SV_blank>a<S2SV_blank>cryptographic<S2SV_blank>message."" ; case CRYPT_E_UNKNOWN_ALGO : return ""Unknown<S2SV_blank>cryptographic<S2SV_blank>algorithm."" ; case CRYPT_E_INVALID_MSG_TYPE : return ""Invalid<S2SV_blank>cryptographic<S2SV_blank>message<S2SV_blank>type."" ; case CRYPT_E_HASH_VALUE : return ""The<S2SV_blank>hash<S2SV_blank>value<S2SV_blank>is<S2SV_blank>not<S2SV_blank>correct"" ; case CRYPT_E_ISSUER_SERIALNUMBER : return ""Invalid<S2SV_blank>issuer<S2SV_blank>and/or<S2SV_blank>serial<S2SV_blank>number."" ; case CRYPT_E_BAD_LEN : return ""The<S2SV_blank>length<S2SV_blank>specified<S2SV_blank>for<S2SV_blank>the<S2SV_blank>output<S2SV_blank>data<S2SV_blank>was<S2SV_blank>insufficient."" ; case CRYPT_E_BAD_ENCODE : return ""An<S2SV_blank>error<S2SV_blank>occurred<S2SV_blank>during<S2SV_blank>encode<S2SV_blank>or<S2SV_blank>decode<S2SV_blank>operation."" ; case CRYPT_E_FILE_ERROR : return ""An<S2SV_blank>error<S2SV_blank>occurred<S2SV_blank>while<S2SV_blank>reading<S2SV_blank>or<S2SV_blank>writing<S2SV_blank>to<S2SV_blank>a<S2SV_blank>file."" ; case CRYPT_E_NOT_FOUND : return ""Cannot<S2SV_blank>find<S2SV_blank>object<S2SV_blank>or<S2SV_blank>property."" ; case CRYPT_E_EXISTS : return ""The<S2SV_blank>object<S2SV_blank>or<S2SV_blank>property<S2SV_blank>already<S2SV_blank>exists."" ; case CRYPT_E_NO_PROVIDER : return ""No<S2SV_blank>provider<S2SV_blank>was<S2SV_blank>specified<S2SV_blank>for<S2SV_blank>the<S2SV_blank>store<S2SV_blank>or<S2SV_blank>object."" ; case CRYPT_E_DELETED_PREV : return ""The<S2SV_blank>previous<S2SV_blank>certificate<S2SV_blank>or<S2SV_blank>CRL<S2SV_blank>context<S2SV_blank>was<S2SV_blank>deleted."" ; case CRYPT_E_NO_MATCH : return ""Cannot<S2SV_blank>find<S2SV_blank>the<S2SV_blank>requested<S2SV_blank>object."" ; case CRYPT_E_UNEXPECTED_MSG_TYPE : case CRYPT_E_NO_KEY_PROPERTY : case CRYPT_E_NO_DECRYPT_CERT : return ""Private<S2SV_blank>key<S2SV_blank>or<S2SV_blank>certificate<S2SV_blank>issue"" ; case CRYPT_E_BAD_MSG : return ""Not<S2SV_blank>a<S2SV_blank>cryptographic<S2SV_blank>message."" ; case CRYPT_E_NO_SIGNER : return ""The<S2SV_blank>signed<S2SV_blank>cryptographic<S2SV_blank>message<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>a<S2SV_blank>signer<S2SV_blank>for<S2SV_blank>the<S2SV_blank>specified<S2SV_blank>signer<S2SV_blank>index."" ; case CRYPT_E_REVOKED : return ""The<S2SV_blank>certificate<S2SV_blank>is<S2SV_blank>revoked."" ; case CRYPT_E_NO_REVOCATION_DLL : case CRYPT_E_NO_REVOCATION_CHECK : case CRYPT_E_REVOCATION_OFFLINE : case CRYPT_E_NOT_IN_REVOCATION_DATABASE : return ""Cannot<S2SV_blank>check<S2SV_blank>certificate<S2SV_blank>revocation."" ; case CRYPT_E_INVALID_NUMERIC_STRING : case CRYPT_E_INVALID_PRINTABLE_STRING : case CRYPT_E_INVALID_IA5_STRING : case CRYPT_E_INVALID_X500_STRING : case CRYPT_E_NOT_CHAR_STRING : return ""Invalid<S2SV_blank>string."" ; case CRYPT_E_SECURITY_SETTINGS : return ""The<S2SV_blank>cryptographic<S2SV_blank>operation<S2SV_blank>failed<S2SV_blank>due<S2SV_blank>to<S2SV_blank>a<S2SV_blank>local<S2SV_blank>security<S2SV_blank>option<S2SV_blank>setting."" ; case CRYPT_E_NO_VERIFY_USAGE_CHECK : case CRYPT_E_VERIFY_USAGE_OFFLINE : return ""Cannot<S2SV_blank>complete<S2SV_blank>usage<S2SV_blank>check."" ; case CRYPT_E_NO_TRUSTED_SIGNER : <S2SV_StartBug> return ""None<S2SV_blank>of<S2SV_blank>the<S2SV_blank>signers<S2SV_blank>of<S2SV_blank>the<S2SV_blank>cryptographic<S2SV_blank>message<S2SV_blank>or<S2SV_blank>certificate<S2SV_blank>trust<S2SV_blank>list<S2SV_blank>is<S2SV_blank>trusted."" ; <S2SV_EndBug> default : static_sprintf ( error_string , ""Unknown<S2SV_blank>PKI<S2SV_blank>error<S2SV_blank>0x%08lX"" , error_code ) ; return error_string ; } }
","<S2SV_ModStart> if ( ( ( <S2SV_ModStart> != 0x8009 ) && ( ( error_code >> 16 ) != 0x800B ) ) <S2SV_ModStart> : return ""None<S2SV_blank>of<S2SV_blank>the<S2SV_blank>signers<S2SV_blank>of<S2SV_blank>the<S2SV_blank>cryptographic<S2SV_blank>message<S2SV_blank>or<S2SV_blank>certificate<S2SV_blank>trust<S2SV_blank>list<S2SV_blank>is<S2SV_blank>trusted."" ; case CERT_E_UNTRUSTEDROOT : return ""The<S2SV_blank>root<S2SV_blank>certificate<S2SV_blank>is<S2SV_blank>not<S2SV_blank>trusted."" ; case TRUST_E_NOSIGNATURE : return ""Not<S2SV_blank>digitally<S2SV_blank>signed."" ; case TRUST_E_EXPLICIT_DISTRUST : return ""One<S2SV_blank>of<S2SV_blank>the<S2SV_blank>certificates<S2SV_blank>used<S2SV_blank>was<S2SV_blank>marked<S2SV_blank>as<S2SV_blank>untrusted<S2SV_blank>by<S2SV_blank>the<S2SV_blank>user.""
"
909,"CWE-522 static TPM_RC StartAuthSession ( TSS2_SYS_CONTEXT * sapi_context , SESSION * session ) { TPM_RC rval ; TPM2B_ENCRYPTED_SECRET key ; char label [ ] = ""ATH"" ; UINT16 bytes ; int i ; key . t . size = 0 ; if ( session -> nonceOlder . t . size == 0 ) { session -> nonceOlder . t . size = GetDigestSize ( TPM_ALG_SHA1 ) ; for ( i = 0 ; i < session -> nonceOlder . t . size ; i ++ ) session -> nonceOlder . t . buffer [ i ] = 0 ; } session -> nonceNewer . t . size = session -> nonceOlder . t . size ; rval = Tss2_Sys_StartAuthSession ( sapi_context , session -> tpmKey , session -> bind , 0 , & ( session -> nonceOlder ) , & ( session -> encryptedSalt ) , session -> sessionType , & ( session -> symmetric ) , session -> authHash , & ( session -> sessionHandle ) , & ( session -> nonceNewer ) , 0 ) ; if ( rval == TPM_RC_SUCCESS ) { if ( session -> tpmKey == TPM_RH_NULL ) session -> salt . t . size = 0 ; if ( session -> bind == TPM_RH_NULL ) session -> authValueBind . t . size = 0 ; if ( session -> tpmKey == TPM_RH_NULL && session -> bind == TPM_RH_NULL ) { session -> sessionKey . b . size = 0 ; } else { bool result = string_bytes_concat_buffer ( ( TPM2B_MAX_BUFFER * ) & key , & ( session -> authValueBind . b ) ) ; if ( ! result ) { return TSS2_SYS_RC_BAD_VALUE ; } result = string_bytes_concat_buffer ( ( TPM2B_MAX_BUFFER * ) & key , & ( session -> salt . b ) ) ; if ( ! result ) { return TSS2_SYS_RC_BAD_VALUE ; } bytes = GetDigestSize ( session -> authHash ) ; if ( key . t . size == 0 ) { session -> sessionKey . t . size = 0 ; } else { <S2SV_StartBug> rval = tpm_kdfa ( sapi_context , session -> authHash , & ( key . b ) , label , & ( session -> nonceNewer . b ) , <S2SV_EndBug> & ( session -> nonceOlder . b ) , bytes * 8 , ( TPM2B_MAX_BUFFER * ) & ( session -> sessionKey ) ) ; } if ( rval != TPM_RC_SUCCESS ) { return ( TSS2_APP_RC_CREATE_SESSION_KEY_FAILED ) ; } } session -> nonceTpmDecrypt . b . size = 0 ; session -> nonceTpmEncrypt . b . size = 0 ; session -> nvNameChanged = 0 ; } return rval ; }
","<S2SV_ModStart> = tpm_kdfa ( <S2SV_ModEnd> session -> authHash
"
910,"CWE-189 static ssize_t __nfs4_get_acl_uncached ( struct inode * inode , void * buf , size_t buflen ) { struct page * pages [ NFS4ACL_MAXPAGES ] = { NULL , } ; struct nfs_getaclargs args = { . fh = NFS_FH ( inode ) , . acl_pages = pages , . acl_len = buflen , } ; struct nfs_getaclres res = { . acl_len = buflen , } ; void * resp_buf ; struct rpc_message msg = { . rpc_proc = & nfs4_procedures [ NFSPROC4_CLNT_GETACL ] , . rpc_argp = & args , . rpc_resp = & res , } ; int ret = - ENOMEM , npages , i , acl_len = 0 ; npages = ( buflen + PAGE_SIZE - 1 ) >> PAGE_SHIFT ; if ( npages == 0 ) npages = 1 ; for ( i = 0 ; i < npages ; i ++ ) { pages [ i ] = alloc_page ( GFP_KERNEL ) ; if ( ! pages [ i ] ) goto out_free ; } if ( npages > 1 ) { res . acl_scratch = alloc_page ( GFP_KERNEL ) ; if ( ! res . acl_scratch ) goto out_free ; } args . acl_len = npages * PAGE_SIZE ; args . acl_pgbase = 0 ; if ( buf == NULL ) res . acl_flags |= NFS4_ACL_LEN_REQUEST ; resp_buf = page_address ( pages [ 0 ] ) ; dprintk ( ""%s<S2SV_blank><S2SV_blank>buf<S2SV_blank>%p<S2SV_blank>buflen<S2SV_blank>%zu<S2SV_blank>npages<S2SV_blank>%d<S2SV_blank>args.acl_len<S2SV_blank>%zu\\n"" , __func__ , buf , buflen , npages , args . acl_len ) ; ret = nfs4_call_sync ( NFS_SERVER ( inode ) -> client , NFS_SERVER ( inode ) , & msg , & args . seq_args , & res . seq_res , 0 ) ; if ( ret ) goto out_free ; acl_len = res . acl_len - res . acl_data_offset ; if ( acl_len > args . acl_len ) nfs4_write_cached_acl ( inode , NULL , acl_len ) ; else nfs4_write_cached_acl ( inode , resp_buf + res . acl_data_offset , acl_len ) ; if ( buf ) { ret = - ERANGE ; if ( acl_len > buflen ) goto out_free ; _copy_from_pages ( buf , pages , res . acl_data_offset , <S2SV_StartBug> res . acl_len ) ; <S2SV_EndBug> } ret = acl_len ; out_free : for ( i = 0 ; i < npages ; i ++ ) if ( pages [ i ] ) __free_page ( pages [ i ] ) ; if ( res . acl_scratch ) __free_page ( res . acl_scratch ) ; return ret ; }
","<S2SV_ModStart> . acl_data_offset , <S2SV_ModEnd> acl_len ) ;
"
911,"CWE-000 static void bgp_packet_mpattr_tea ( struct bgp * bgp , struct peer * peer , struct stream * s , struct attr * attr , uint8_t attrtype ) { unsigned int attrlenfield = 0 ; unsigned int attrhdrlen = 0 ; struct bgp_attr_encap_subtlv * subtlvs ; struct bgp_attr_encap_subtlv * st ; const char * attrname ; if ( ! attr || ( attrtype == BGP_ATTR_ENCAP && ( ! attr -> encap_tunneltype || attr -> encap_tunneltype == BGP_ENCAP_TYPE_MPLS ) ) ) return ; switch ( attrtype ) { case BGP_ATTR_ENCAP : attrname = ""Tunnel<S2SV_blank>Encap"" ; subtlvs = attr -> encap_subtlvs ; if ( subtlvs == NULL ) return ; attrlenfield = 2 + 2 ; attrhdrlen = 1 + 1 ; break ; <S2SV_StartBug> # if ENABLE_BGP_VNC <S2SV_EndBug> case BGP_ATTR_VNC : attrname = ""VNC"" ; subtlvs = attr -> vnc_subtlvs ; if ( subtlvs == NULL ) return ; attrlenfield = 0 ; attrhdrlen = 2 + 2 ; break ; # endif default : assert ( 0 ) ; } for ( st = subtlvs ; st ; st = st -> next ) { attrlenfield += ( attrhdrlen + st -> length ) ; } if ( attrlenfield > 0xffff ) { zlog_info ( ""%s<S2SV_blank>attribute<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long<S2SV_blank>(length=%d),<S2SV_blank>can\'t<S2SV_blank>send<S2SV_blank>it"" , attrname , attrlenfield ) ; return ; } if ( attrlenfield > 0xff ) { stream_putc ( s , BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_EXTLEN ) ; stream_putc ( s , attrtype ) ; stream_putw ( s , attrlenfield & 0xffff ) ; } else { stream_putc ( s , BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_OPTIONAL ) ; stream_putc ( s , attrtype ) ; stream_putc ( s , attrlenfield & 0xff ) ; } if ( attrtype == BGP_ATTR_ENCAP ) { stream_putw ( s , attr -> encap_tunneltype ) ; stream_putw ( s , attrlenfield - 4 ) ; } for ( st = subtlvs ; st ; st = st -> next ) { if ( attrtype == BGP_ATTR_ENCAP ) { stream_putc ( s , st -> type ) ; stream_putc ( s , st -> length ) ; # if ENABLE_BGP_VNC } else { stream_putw ( s , st -> type ) ; stream_putw ( s , st -> length ) ; # endif } stream_put ( s , st -> value , st -> length ) ; } }
","<S2SV_ModStart> ; # if ENABLE_BGP_VNC_ATTR <S2SV_ModEnd> case BGP_ATTR_VNC :
"
912,"CWE-119 static int nl80211_trigger_scan ( struct sk_buff * skb , struct genl_info * info ) { struct cfg80211_registered_device * rdev = info -> user_ptr [ 0 ] ; struct net_device * dev = info -> user_ptr [ 1 ] ; struct cfg80211_scan_request * request ; struct nlattr * attr ; struct wiphy * wiphy ; int err , tmp , n_ssids = 0 , n_channels , i ; enum ieee80211_band band ; size_t ie_len ; if ( ! is_valid_ie_attr ( info -> attrs [ NL80211_ATTR_IE ] ) ) return - EINVAL ; wiphy = & rdev -> wiphy ; if ( ! rdev -> ops -> scan ) return - EOPNOTSUPP ; if ( rdev -> scan_req ) return - EBUSY ; if ( info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] ) { n_channels = validate_scan_freqs ( info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] ) ; if ( ! n_channels ) return - EINVAL ; } else { n_channels = 0 ; for ( band = 0 ; band < IEEE80211_NUM_BANDS ; band ++ ) if ( wiphy -> bands [ band ] ) n_channels += wiphy -> bands [ band ] -> n_channels ; } if ( info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] ) nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] , tmp ) n_ssids ++ ; if ( n_ssids > wiphy -> max_scan_ssids ) return - EINVAL ; if ( info -> attrs [ NL80211_ATTR_IE ] ) ie_len = nla_len ( info -> attrs [ NL80211_ATTR_IE ] ) ; else ie_len = 0 ; if ( ie_len > wiphy -> max_scan_ie_len ) return - EINVAL ; request = kzalloc ( sizeof ( * request ) + sizeof ( * request -> ssids ) * n_ssids + sizeof ( * request -> channels ) * n_channels + ie_len , GFP_KERNEL ) ; if ( ! request ) return - ENOMEM ; if ( n_ssids ) request -> ssids = ( void * ) & request -> channels [ n_channels ] ; request -> n_ssids = n_ssids ; if ( ie_len ) { if ( request -> ssids ) request -> ie = ( void * ) ( request -> ssids + n_ssids ) ; else request -> ie = ( void * ) ( request -> channels + n_channels ) ; } i = 0 ; if ( info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] ) { nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] , tmp ) { struct ieee80211_channel * chan ; chan = ieee80211_get_channel ( wiphy , nla_get_u32 ( attr ) ) ; if ( ! chan ) { err = - EINVAL ; goto out_free ; } if ( chan -> flags & IEEE80211_CHAN_DISABLED ) continue ; request -> channels [ i ] = chan ; i ++ ; } } else { for ( band = 0 ; band < IEEE80211_NUM_BANDS ; band ++ ) { int j ; if ( ! wiphy -> bands [ band ] ) continue ; for ( j = 0 ; j < wiphy -> bands [ band ] -> n_channels ; j ++ ) { struct ieee80211_channel * chan ; chan = & wiphy -> bands [ band ] -> channels [ j ] ; if ( chan -> flags & IEEE80211_CHAN_DISABLED ) continue ; request -> channels [ i ] = chan ; i ++ ; } } } if ( ! i ) { err = - EINVAL ; goto out_free ; } request -> n_channels = i ; i = 0 ; if ( info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] ) { <S2SV_StartBug> nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] , tmp ) { <S2SV_EndBug> if ( request -> ssids [ i ] . ssid_len > IEEE80211_MAX_SSID_LEN ) { err = - EINVAL ; goto out_free ; } memcpy ( request -> ssids [ i ] . ssid , nla_data ( attr ) , nla_len ( attr ) ) ; <S2SV_StartBug> request -> ssids [ i ] . ssid_len = nla_len ( attr ) ; <S2SV_EndBug> i ++ ; } } if ( info -> attrs [ NL80211_ATTR_IE ] ) { request -> ie_len = nla_len ( info -> attrs [ NL80211_ATTR_IE ] ) ; memcpy ( ( void * ) request -> ie , nla_data ( info -> attrs [ NL80211_ATTR_IE ] ) , request -> ie_len ) ; } request -> dev = dev ; request -> wiphy = & rdev -> wiphy ; rdev -> scan_req = request ; err = rdev -> ops -> scan ( & rdev -> wiphy , dev , request ) ; if ( ! err ) { nl80211_send_scan_start ( rdev , dev ) ; dev_hold ( dev ) ; } else { out_free : rdev -> scan_req = NULL ; kfree ( request ) ; } return err ; }
","<S2SV_ModStart> tmp ) { request -> ssids [ i ] . ssid_len = nla_len ( attr ) ; <S2SV_ModStart> ) ) ; <S2SV_ModEnd> i ++ ;
"
913,"CWE-400 bool ExprResolveBoolean ( struct xkb_context * ctx , const ExprDef * expr , bool * set_rtrn ) { bool ok = false ; const char * ident ; switch ( expr -> expr . op ) { case EXPR_VALUE : if ( expr -> expr . value_type != EXPR_TYPE_BOOLEAN ) { log_err ( ctx , ""Found<S2SV_blank>constant<S2SV_blank>of<S2SV_blank>type<S2SV_blank>%s<S2SV_blank>where<S2SV_blank>boolean<S2SV_blank>was<S2SV_blank>expected\\n"" , expr_value_type_to_string ( expr -> expr . value_type ) ) ; return false ; } * set_rtrn = expr -> boolean . set ; return true ; case EXPR_IDENT : ident = xkb_atom_text ( ctx , expr -> ident . ident ) ; if ( ident ) { if ( istreq ( ident , ""true"" ) || istreq ( ident , ""yes"" ) || istreq ( ident , ""on"" ) ) { * set_rtrn = true ; return true ; } else if ( istreq ( ident , ""false"" ) || istreq ( ident , ""no"" ) || istreq ( ident , ""off"" ) ) { * set_rtrn = false ; return true ; } } log_err ( ctx , ""Identifier<S2SV_blank>\\""%s\\""<S2SV_blank>of<S2SV_blank>type<S2SV_blank>boolean<S2SV_blank>is<S2SV_blank>unknown\\n"" , ident ) ; return false ; case EXPR_FIELD_REF : log_err ( ctx , ""Default<S2SV_blank>\\""%s.%s\\""<S2SV_blank>of<S2SV_blank>type<S2SV_blank>boolean<S2SV_blank>is<S2SV_blank>unknown\\n"" , xkb_atom_text ( ctx , expr -> field_ref . element ) , xkb_atom_text ( ctx , expr -> field_ref . field ) ) ; return false ; case EXPR_INVERT : case EXPR_NOT : <S2SV_StartBug> ok = ExprResolveBoolean ( ctx , expr , set_rtrn ) ; <S2SV_EndBug> if ( ok ) * set_rtrn = ! * set_rtrn ; return ok ; case EXPR_ADD : case EXPR_SUBTRACT : case EXPR_MULTIPLY : case EXPR_DIVIDE : case EXPR_ASSIGN : case EXPR_NEGATE : case EXPR_UNARY_PLUS : log_err ( ctx , ""%s<S2SV_blank>of<S2SV_blank>boolean<S2SV_blank>values<S2SV_blank>not<S2SV_blank>permitted\\n"" , expr_op_type_to_string ( expr -> expr . op ) ) ; break ; default : log_wsgo ( ctx , ""Unknown<S2SV_blank>operator<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>ResolveBoolean\\n"" , expr -> expr . op ) ; break ; } return false ; }
","<S2SV_ModStart> ctx , expr -> unary . child
"
914,"CWE-476 int migrate_page_move_mapping ( struct address_space * mapping , struct page * newpage , struct page * page , struct buffer_head * head , enum migrate_mode mode , int extra_count ) { <S2SV_StartBug> int expected_count = 1 + extra_count ; <S2SV_EndBug> void * * pslot ; if ( ! mapping ) { if ( page_count ( page ) != expected_count ) return - EAGAIN ; set_page_memcg ( newpage , page_memcg ( page ) ) ; newpage -> index = page -> index ; newpage -> mapping = page -> mapping ; if ( PageSwapBacked ( page ) ) SetPageSwapBacked ( newpage ) ; return MIGRATEPAGE_SUCCESS ; <S2SV_StartBug> } <S2SV_EndBug> spin_lock_irq ( & mapping -> tree_lock ) ; pslot = radix_tree_lookup_slot ( & mapping -> page_tree , page_index ( page ) ) ; expected_count += 1 + page_has_private ( page ) ; if ( page_count ( page ) != expected_count || radix_tree_deref_slot_protected ( pslot , & mapping -> tree_lock ) != page ) { spin_unlock_irq ( & mapping -> tree_lock ) ; return - EAGAIN ; } if ( ! page_freeze_refs ( page , expected_count ) ) { spin_unlock_irq ( & mapping -> tree_lock ) ; return - EAGAIN ; } if ( mode == MIGRATE_ASYNC && head && ! buffer_migrate_lock_buffers ( head , mode ) ) { page_unfreeze_refs ( page , expected_count ) ; spin_unlock_irq ( & mapping -> tree_lock ) ; return - EAGAIN ; } set_page_memcg ( newpage , page_memcg ( page ) ) ; newpage -> index = page -> index ; newpage -> mapping = page -> mapping ; if ( PageSwapBacked ( page ) ) SetPageSwapBacked ( newpage ) ; get_page ( newpage ) ; if ( PageSwapCache ( page ) ) { SetPageSwapCache ( newpage ) ; set_page_private ( newpage , page_private ( page ) ) ; } <S2SV_StartBug> radix_tree_replace_slot ( pslot , newpage ) ; <S2SV_EndBug> page_unfreeze_refs ( page , expected_count - 1 ) ; <S2SV_StartBug> __dec_zone_page_state ( page , NR_FILE_PAGES ) ; <S2SV_EndBug> <S2SV_StartBug> __inc_zone_page_state ( newpage , NR_FILE_PAGES ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! PageSwapCache ( page ) && PageSwapBacked ( page ) ) { <S2SV_EndBug> __dec_zone_page_state ( page , NR_SHMEM ) ; __inc_zone_page_state ( newpage , NR_SHMEM ) ; } spin_unlock_irq ( & mapping -> tree_lock ) ; return MIGRATEPAGE_SUCCESS ; }
","<S2SV_ModStart> extra_count ) { struct zone * oldzone , * newzone ; int dirty ; <S2SV_ModStart> MIGRATEPAGE_SUCCESS ; } oldzone = page_zone ( page ) ; newzone = page_zone ( newpage ) ; <S2SV_ModStart> ) ; } dirty = PageDirty ( page ) ; if ( dirty ) { ClearPageDirty ( page ) ; SetPageDirty ( newpage ) ; } <S2SV_ModStart> 1 ) ; spin_unlock ( & mapping -> tree_lock ) ; if ( newzone != oldzone ) { __dec_zone_state ( oldzone <S2SV_ModEnd> , NR_FILE_PAGES ) <S2SV_ModStart> NR_FILE_PAGES ) ; __inc_zone_state ( newzone <S2SV_ModEnd> , NR_FILE_PAGES ) <S2SV_ModStart> ; if ( PageSwapBacked ( page ) && <S2SV_ModStart> ( page ) ) { __dec_zone_state ( oldzone , NR_SHMEM ) ; __inc_zone_state ( newzone , NR_SHMEM ) ; } if ( dirty && mapping_cap_account_dirty ( mapping ) ) { __dec_zone_state ( oldzone , NR_FILE_DIRTY ) ; __inc_zone_state ( newzone , NR_FILE_DIRTY ) ; } } local_irq_enable ( <S2SV_ModEnd> ) ; return
"
915,"CWE-119 static void write_interp_filter ( INTERP_FILTER filter , <S2SV_StartBug> struct vp9_write_bit_buffer * wb ) { <S2SV_EndBug> const int filter_to_literal [ ] = { 1 , 0 , 2 , 3 } ; <S2SV_StartBug> vp9_wb_write_bit ( wb , filter == SWITCHABLE ) ; <S2SV_EndBug> if ( filter != SWITCHABLE ) <S2SV_StartBug> vp9_wb_write_literal ( wb , filter_to_literal [ filter ] , 2 ) ; <S2SV_EndBug> }
","<S2SV_ModStart> filter , struct vpx_write_bit_buffer <S2SV_ModEnd> * wb ) <S2SV_ModStart> 3 } ; vpx_wb_write_bit <S2SV_ModEnd> ( wb , <S2SV_ModStart> != SWITCHABLE ) vpx_wb_write_literal <S2SV_ModEnd> ( wb ,
"
916,"CWE-78 int imap_subscribe ( char * path , bool subscribe ) { struct ImapData * idata = NULL ; char buf [ LONG_STRING ] ; char mbox [ LONG_STRING ] ; char errstr [ STRING ] ; struct Buffer err , token ; struct ImapMbox mx ; <S2SV_StartBug> if ( ! mx_is_imap ( path ) || imap_parse_path ( path , & mx ) || ! mx . mbox ) <S2SV_EndBug> { mutt_error ( _ ( ""Bad<S2SV_blank>mailbox<S2SV_blank>name"" ) ) ; return - 1 ; } idata = imap_conn_find ( & ( mx . account ) , 0 ) ; if ( ! idata ) goto fail ; imap_fix_path ( idata , mx . mbox , buf , sizeof ( buf ) ) ; if ( ! * buf ) mutt_str_strfcpy ( buf , ""INBOX"" , sizeof ( buf ) ) ; if ( ImapCheckSubscribed ) { mutt_buffer_init ( & token ) ; mutt_buffer_init ( & err ) ; err . data = errstr ; err . dsize = sizeof ( errstr ) ; <S2SV_StartBug> snprintf ( mbox , sizeof ( mbox ) , ""%smailboxes<S2SV_blank>\\""%s\\"""" , subscribe ? """" : ""un"" , path ) ; <S2SV_EndBug> if ( mutt_parse_rc_line ( mbox , & token , & err ) ) mutt_debug ( 1 , ""Error<S2SV_blank>adding<S2SV_blank>subscribed<S2SV_blank>mailbox:<S2SV_blank>%s\\n"" , errstr ) ; FREE ( & token . data ) ; } if ( subscribe ) mutt_message ( _ ( ""Subscribing<S2SV_blank>to<S2SV_blank>%s..."" ) , buf ) ; else mutt_message ( _ ( ""Unsubscribing<S2SV_blank>from<S2SV_blank>%s..."" ) , buf ) ; imap_munge_mbox_name ( idata , mbox , sizeof ( mbox ) , buf ) ; snprintf ( buf , sizeof ( buf ) , ""%sSUBSCRIBE<S2SV_blank>%s"" , subscribe ? """" : ""UN"" , mbox ) ; if ( imap_exec ( idata , buf , 0 ) < 0 ) goto fail ; imap_unmunge_mbox_name ( idata , mx . mbox ) ; if ( subscribe ) mutt_message ( _ ( ""Subscribed<S2SV_blank>to<S2SV_blank>%s"" ) , mx . mbox ) ; else mutt_message ( _ ( ""Unsubscribed<S2SV_blank>from<S2SV_blank>%s"" ) , mx . mbox ) ; FREE ( & mx . mbox ) ; return 0 ; fail : FREE ( & mx . mbox ) ; return - 1 ; }
","<S2SV_ModStart> ImapMbox mx ; size_t len = 0 ; <S2SV_ModStart> errstr ) ; len = <S2SV_ModStart> mbox ) , ""%smailboxes<S2SV_blank>"" <S2SV_ModEnd> , subscribe ? <S2SV_ModStart> """" : ""un"" ) ; imap_quote_string ( mbox + len , sizeof ( mbox ) - len , path , true <S2SV_ModEnd> ) ; if
"
917,"CWE-119 <S2SV_StartBug> void open_input_file ( struct VpxInputContext * input ) { <S2SV_EndBug> input -> file = strcmp ( input -> filename , ""-"" ) ? fopen ( input -> filename , ""rb"" ) : set_binary_mode ( stdin ) ; if ( ! input -> file ) fatal ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>input<S2SV_blank>file"" ) ; if ( ! fseeko ( input -> file , 0 , SEEK_END ) ) { input -> length = ftello ( input -> file ) ; rewind ( input -> file ) ; } <S2SV_StartBug> input -> detect . buf_read = fread ( input -> detect . buf , 1 , 4 , input -> file ) ; <S2SV_EndBug> input -> detect . position = 0 ; if ( input -> detect . buf_read == 4 && file_is_y4m ( input -> detect . buf ) ) { if ( y4m_input_open ( & input -> y4m , input -> file , input -> detect . buf , 4 , input -> only_i420 ) >= 0 ) { input -> file_type = FILE_TYPE_Y4M ; input -> width = input -> y4m . pic_w ; input -> height = input -> y4m . pic_h ; <S2SV_StartBug> input -> framerate . numerator = input -> y4m . fps_n ; <S2SV_EndBug> input -> framerate . denominator = input -> y4m . fps_d ; <S2SV_StartBug> input -> use_i420 = 0 ; <S2SV_EndBug> } else fatal ( ""Unsupported<S2SV_blank>Y4M<S2SV_blank>stream."" ) ; } else if ( input -> detect . buf_read == 4 && fourcc_is_ivf ( input -> detect . buf ) ) { fatal ( ""IVF<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>as<S2SV_blank>input."" ) ; } else { input -> file_type = FILE_TYPE_RAW ; } }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> } input -> pixel_aspect_ratio . numerator = 1 ; input -> pixel_aspect_ratio . denominator = 1 ; input -> <S2SV_ModStart> ; input -> pixel_aspect_ratio . numerator = input -> y4m . par_n ; input -> pixel_aspect_ratio . denominator = input -> y4m . par_d ; input -> <S2SV_ModStart> ; input -> fmt = input -> y4m . vpx_fmt ; input -> bit_depth = input -> y4m . bit_depth <S2SV_ModEnd> ; } else
"
918,"CWE-125 static void pimv2_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , const u_char * bp2 ) { register const u_char * ep ; register const struct pim * pim = ( const struct pim * ) bp ; int advance ; enum checksum_status cksum_status ; ep = ( const u_char * ) ndo -> ndo_snapend ; if ( bp >= ep ) return ; if ( ep > bp + len ) ep = bp + len ; ND_TCHECK ( pim -> pim_rsv ) ; pimv2_addr_len = pim -> pim_rsv ; if ( pimv2_addr_len != 0 ) ND_PRINT ( ( ndo , "",<S2SV_blank>RFC2117-encoding"" ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>cksum<S2SV_blank>0x%04x<S2SV_blank>"" , EXTRACT_16BITS ( & pim -> pim_cksum ) ) ) ; if ( EXTRACT_16BITS ( & pim -> pim_cksum ) == 0 ) { ND_PRINT ( ( ndo , ""(unverified)"" ) ) ; } else { if ( PIM_TYPE ( pim -> pim_typever ) == PIMV2_TYPE_REGISTER ) { cksum_status = pimv2_check_checksum ( ndo , bp , bp2 , 8 ) ; if ( cksum_status == INCORRECT ) { cksum_status = pimv2_check_checksum ( ndo , bp , bp2 , len ) ; } } else { cksum_status = pimv2_check_checksum ( ndo , bp , bp2 , len ) ; } switch ( cksum_status ) { case CORRECT : ND_PRINT ( ( ndo , ""(correct)"" ) ) ; break ; case INCORRECT : ND_PRINT ( ( ndo , ""(incorrect)"" ) ) ; break ; case UNVERIFIED : ND_PRINT ( ( ndo , ""(unverified)"" ) ) ; break ; } } switch ( PIM_TYPE ( pim -> pim_typever ) ) { case PIMV2_TYPE_HELLO : { uint16_t otype , olen ; bp += 4 ; while ( bp < ep ) { ND_TCHECK2 ( bp [ 0 ] , 4 ) ; otype = EXTRACT_16BITS ( & bp [ 0 ] ) ; olen = EXTRACT_16BITS ( & bp [ 2 ] ) ; ND_TCHECK2 ( bp [ 0 ] , 4 + olen ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(%u),<S2SV_blank>length<S2SV_blank>%u,<S2SV_blank>Value:<S2SV_blank>"" , tok2str ( pimv2_hello_option_values , ""Unknown"" , otype ) , otype , olen ) ) ; bp += 4 ; switch ( otype ) { case PIMV2_HELLO_OPTION_HOLDTIME : <S2SV_StartBug> unsigned_relts_print ( ndo , EXTRACT_16BITS ( bp ) ) ; <S2SV_EndBug> break ; case PIMV2_HELLO_OPTION_LANPRUNEDELAY : if ( olen != 4 ) { ND_PRINT ( ( ndo , ""ERROR:<S2SV_blank>Option<S2SV_blank>Length<S2SV_blank>!=<S2SV_blank>4<S2SV_blank>Bytes<S2SV_blank>(%u)"" , olen ) ) ; } else { char t_bit ; uint16_t lan_delay , override_interval ; lan_delay = EXTRACT_16BITS ( bp ) ; override_interval = EXTRACT_16BITS ( bp + 2 ) ; t_bit = ( lan_delay & 0x8000 ) ? 1 : 0 ; lan_delay &= ~ 0x8000 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>T-bit=%d,<S2SV_blank>LAN<S2SV_blank>delay<S2SV_blank>%dms,<S2SV_blank>Override<S2SV_blank>interval<S2SV_blank>%dms"" , t_bit , lan_delay , override_interval ) ) ; } break ; case PIMV2_HELLO_OPTION_DR_PRIORITY_OLD : case PIMV2_HELLO_OPTION_DR_PRIORITY : switch ( olen ) { case 0 : ND_PRINT ( ( ndo , ""Bi-Directional<S2SV_blank>Capability<S2SV_blank>(Old)"" ) ) ; break ; case 4 : ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( bp ) ) ) ; break ; default : ND_PRINT ( ( ndo , ""ERROR:<S2SV_blank>Option<S2SV_blank>Length<S2SV_blank>!=<S2SV_blank>4<S2SV_blank>Bytes<S2SV_blank>(%u)"" , olen ) ) ; break ; } break ; case PIMV2_HELLO_OPTION_GENID : <S2SV_StartBug> ND_PRINT ( ( ndo , ""0x%08x"" , EXTRACT_32BITS ( bp ) ) ) ; <S2SV_EndBug> break ; case PIMV2_HELLO_OPTION_REFRESH_CAP : <S2SV_StartBug> ND_PRINT ( ( ndo , ""v%d"" , * bp ) ) ; <S2SV_EndBug> if ( * ( bp + 1 ) != 0 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>interval<S2SV_blank>"" ) ) ; unsigned_relts_print ( ndo , * ( bp + 1 ) ) ; } if ( EXTRACT_16BITS ( bp + 2 ) != 0 ) { <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>?0x%04x?"" , EXTRACT_16BITS ( bp + 2 ) ) ) ; <S2SV_EndBug> } break ; case PIMV2_HELLO_OPTION_BIDIR_CAP : break ; case PIMV2_HELLO_OPTION_ADDRESS_LIST_OLD : case PIMV2_HELLO_OPTION_ADDRESS_LIST : if ( ndo -> ndo_vflag > 1 ) { const u_char * ptr = bp ; while ( ptr < ( bp + olen ) ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ) ) ; advance = pimv2_addr_print ( ndo , ptr , pimv2_unicast , 0 ) ; if ( advance < 0 ) { ND_PRINT ( ( ndo , ""..."" ) ) ; break ; } ptr += advance ; } } break ; default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , bp , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , olen ) ; break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , bp , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , olen ) ; bp += olen ; } break ; } case PIMV2_TYPE_REGISTER : { const struct ip * ip ; ND_TCHECK2 ( * ( bp + 4 ) , PIMV2_REGISTER_FLAG_LEN ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[<S2SV_blank>%s<S2SV_blank>]\\n\\t"" , tok2str ( pimv2_register_flag_values , ""none"" , EXTRACT_32BITS ( bp + 4 ) ) ) ) ; bp += 8 ; len -= 8 ; ip = ( const struct ip * ) bp ; switch ( IP_V ( ip ) ) { case 0 : ND_PRINT ( ( ndo , ""IP-Null-header<S2SV_blank>%s<S2SV_blank>><S2SV_blank>%s"" , ipaddr_string ( ndo , & ip -> ip_src ) , ipaddr_string ( ndo , & ip -> ip_dst ) ) ) ; break ; case 4 : ip_print ( ndo , bp , len ) ; break ; case 6 : ip6_print ( ndo , bp , len ) ; break ; default : ND_PRINT ( ( ndo , ""IP<S2SV_blank>ver<S2SV_blank>%d"" , IP_V ( ip ) ) ) ; break ; } break ; } case PIMV2_TYPE_REGISTER_STOP : bp += 4 ; len -= 4 ; if ( bp >= ep ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>group="" ) ) ; if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_group , 0 ) ) < 0 ) { ND_PRINT ( ( ndo , ""..."" ) ) ; break ; } bp += advance ; len -= advance ; if ( bp >= ep ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>source="" ) ) ; if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) { ND_PRINT ( ( ndo , ""..."" ) ) ; break ; } bp += advance ; len -= advance ; break ; case PIMV2_TYPE_JOIN_PRUNE : case PIMV2_TYPE_GRAFT : case PIMV2_TYPE_GRAFT_ACK : { uint8_t ngroup ; uint16_t holdtime ; uint16_t njoin ; uint16_t nprune ; int i , j ; bp += 4 ; len -= 4 ; if ( PIM_TYPE ( pim -> pim_typever ) != 7 ) { if ( bp >= ep ) break ; ND_PRINT ( ( ndo , "",<S2SV_blank>upstream-neighbor:<S2SV_blank>"" ) ) ; if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) { ND_PRINT ( ( ndo , ""..."" ) ) ; break ; } bp += advance ; len -= advance ; } if ( bp + 4 > ep ) break ; ngroup = bp [ 1 ] ; holdtime = EXTRACT_16BITS ( & bp [ 2 ] ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%u<S2SV_blank>group(s)"" , ngroup ) ) ; if ( PIM_TYPE ( pim -> pim_typever ) != 7 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>holdtime:<S2SV_blank>"" ) ) ; if ( holdtime == 0xffff ) ND_PRINT ( ( ndo , ""infinite"" ) ) ; else unsigned_relts_print ( ndo , holdtime ) ; } bp += 4 ; len -= 4 ; for ( i = 0 ; i < ngroup ; i ++ ) { if ( bp >= ep ) goto jp_done ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>group<S2SV_blank>#%u:<S2SV_blank>"" , i + 1 ) ) ; if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_group , 0 ) ) < 0 ) { ND_PRINT ( ( ndo , ""...)"" ) ) ; goto jp_done ; } bp += advance ; len -= advance ; if ( bp + 4 > ep ) { ND_PRINT ( ( ndo , ""...)"" ) ) ; goto jp_done ; } njoin = EXTRACT_16BITS ( & bp [ 0 ] ) ; nprune = EXTRACT_16BITS ( & bp [ 2 ] ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>joined<S2SV_blank>sources:<S2SV_blank>%u,<S2SV_blank>pruned<S2SV_blank>sources:<S2SV_blank>%u"" , njoin , nprune ) ) ; bp += 4 ; len -= 4 ; for ( j = 0 ; j < njoin ; j ++ ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>joined<S2SV_blank>source<S2SV_blank>#%u:<S2SV_blank>"" , j + 1 ) ) ; if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_source , 0 ) ) < 0 ) { ND_PRINT ( ( ndo , ""...)"" ) ) ; goto jp_done ; } bp += advance ; len -= advance ; } for ( j = 0 ; j < nprune ; j ++ ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>pruned<S2SV_blank>source<S2SV_blank>#%u:<S2SV_blank>"" , j + 1 ) ) ; if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_source , 0 ) ) < 0 ) { ND_PRINT ( ( ndo , ""...)"" ) ) ; goto jp_done ; } bp += advance ; len -= advance ; } } jp_done : break ; } case PIMV2_TYPE_BOOTSTRAP : { int i , j , frpcnt ; bp += 4 ; if ( bp + sizeof ( uint16_t ) >= ep ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>tag=%x"" , EXTRACT_16BITS ( bp ) ) ) ; bp += sizeof ( uint16_t ) ; if ( bp >= ep ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>hashmlen=%d"" , bp [ 0 ] ) ) ; if ( bp + 1 >= ep ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>BSRprio=%d"" , bp [ 1 ] ) ) ; bp += 2 ; if ( bp >= ep ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>BSR="" ) ) ; if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) { ND_PRINT ( ( ndo , ""..."" ) ) ; break ; } bp += advance ; for ( i = 0 ; bp < ep ; i ++ ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(group%d:<S2SV_blank>"" , i ) ) ; if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_group , 0 ) ) < 0 ) { ND_PRINT ( ( ndo , ""...)"" ) ) ; goto bs_done ; } bp += advance ; if ( bp >= ep ) { ND_PRINT ( ( ndo , ""...)"" ) ) ; goto bs_done ; } ND_PRINT ( ( ndo , ""<S2SV_blank>RPcnt=%d"" , bp [ 0 ] ) ) ; if ( bp + 1 >= ep ) { ND_PRINT ( ( ndo , ""...)"" ) ) ; goto bs_done ; } ND_PRINT ( ( ndo , ""<S2SV_blank>FRPcnt=%d"" , frpcnt = bp [ 1 ] ) ) ; bp += 4 ; for ( j = 0 ; j < frpcnt && bp < ep ; j ++ ) { ND_PRINT ( ( ndo , ""<S2SV_blank>RP%d="" , j ) ) ; if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) { ND_PRINT ( ( ndo , ""...)"" ) ) ; goto bs_done ; } bp += advance ; if ( bp + 1 >= ep ) { ND_PRINT ( ( ndo , ""...)"" ) ) ; goto bs_done ; } ND_PRINT ( ( ndo , "",holdtime="" ) ) ; unsigned_relts_print ( ndo , EXTRACT_16BITS ( bp ) ) ; if ( bp + 2 >= ep ) { ND_PRINT ( ( ndo , ""...)"" ) ) ; goto bs_done ; } ND_PRINT ( ( ndo , "",prio=%d"" , bp [ 2 ] ) ) ; bp += 4 ; } ND_PRINT ( ( ndo , "")"" ) ) ; } bs_done : break ; } case PIMV2_TYPE_ASSERT : bp += 4 ; len -= 4 ; if ( bp >= ep ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>group="" ) ) ; if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_group , 0 ) ) < 0 ) { ND_PRINT ( ( ndo , ""..."" ) ) ; break ; } bp += advance ; len -= advance ; if ( bp >= ep ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>src="" ) ) ; if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) { ND_PRINT ( ( ndo , ""..."" ) ) ; break ; } bp += advance ; len -= advance ; if ( bp + 8 > ep ) break ; if ( bp [ 0 ] & 0x80 ) ND_PRINT ( ( ndo , ""<S2SV_blank>RPT"" ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>pref=%u"" , EXTRACT_32BITS ( & bp [ 0 ] ) & 0x7fffffff ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>metric=%u"" , EXTRACT_32BITS ( & bp [ 4 ] ) ) ) ; break ; case PIMV2_TYPE_CANDIDATE_RP : { int i , pfxcnt ; bp += 4 ; if ( bp >= ep ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>prefix-cnt=%d"" , bp [ 0 ] ) ) ; pfxcnt = bp [ 0 ] ; if ( bp + 1 >= ep ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>prio=%d"" , bp [ 1 ] ) ) ; if ( bp + 3 >= ep ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>holdtime="" ) ) ; unsigned_relts_print ( ndo , EXTRACT_16BITS ( & bp [ 2 ] ) ) ; bp += 4 ; if ( bp >= ep ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>RP="" ) ) ; if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) { ND_PRINT ( ( ndo , ""..."" ) ) ; break ; } bp += advance ; for ( i = 0 ; i < pfxcnt && bp < ep ; i ++ ) { ND_PRINT ( ( ndo , ""<S2SV_blank>Group%d="" , i ) ) ; if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_group , 0 ) ) < 0 ) { ND_PRINT ( ( ndo , ""..."" ) ) ; break ; } bp += advance ; } break ; } case PIMV2_TYPE_PRUNE_REFRESH : ND_PRINT ( ( ndo , ""<S2SV_blank>src="" ) ) ; if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) { ND_PRINT ( ( ndo , ""..."" ) ) ; break ; } bp += advance ; ND_PRINT ( ( ndo , ""<S2SV_blank>grp="" ) ) ; if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_group , 0 ) ) < 0 ) { ND_PRINT ( ( ndo , ""..."" ) ) ; break ; } bp += advance ; ND_PRINT ( ( ndo , ""<S2SV_blank>forwarder="" ) ) ; if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) { ND_PRINT ( ( ndo , ""..."" ) ) ; break ; } bp += advance ; ND_TCHECK2 ( bp [ 0 ] , 2 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>TUNR<S2SV_blank>"" ) ) ; unsigned_relts_print ( ndo , EXTRACT_16BITS ( bp ) ) ; break ; default : ND_PRINT ( ( ndo , ""<S2SV_blank>[type<S2SV_blank>%d]"" , PIM_TYPE ( pim -> pim_typever ) ) ) ; break ; } return ; trunc : ND_PRINT ( ( ndo , ""[|pim]"" ) ) ; }
","<S2SV_ModStart> case PIMV2_HELLO_OPTION_HOLDTIME : if ( olen != 2 ) { ND_PRINT ( ( ndo , ""ERROR:<S2SV_blank>Option<S2SV_blank>Length<S2SV_blank>!=<S2SV_blank>2<S2SV_blank>Bytes<S2SV_blank>(%u)"" , olen ) ) ; } else { <S2SV_ModStart> ) ) ; } <S2SV_ModStart> case PIMV2_HELLO_OPTION_GENID : if ( olen != 4 ) { ND_PRINT ( ( ndo , ""ERROR:<S2SV_blank>Option<S2SV_blank>Length<S2SV_blank>!=<S2SV_blank>4<S2SV_blank>Bytes<S2SV_blank>(%u)"" , olen ) ) ; } else { <S2SV_ModStart> ) ) ; } <S2SV_ModStart> case PIMV2_HELLO_OPTION_REFRESH_CAP : if ( olen != 4 ) { ND_PRINT ( ( ndo , ""ERROR:<S2SV_blank>Option<S2SV_blank>Length<S2SV_blank>!=<S2SV_blank>4<S2SV_blank>Bytes<S2SV_blank>(%u)"" , olen ) ) ; } else { <S2SV_ModStart> ) ) ; }
"
919,"CWE-354 static void recovery_abort ( void ) { if ( ! dry_run ) { storage_reset ( ) ; <S2SV_StartBug> } <S2SV_EndBug> awaiting_character = false ; memzero ( mnemonic , sizeof ( mnemonic ) ) ; memzero ( cipher , sizeof ( cipher ) ) ; }
","<S2SV_ModStart> ) ; } recovery_started = false ;
"
920,"CWE-77 static int parse_token ( char * * name , char * * value , char * * cp ) { char * end ; if ( ! name || ! value || ! cp ) return - BLKID_ERR_PARAM ; if ( ! ( * value = strchr ( * cp , '=' ) ) ) return 0 ; * * value = '\\0' ; * name = strip_line ( * cp ) ; * value = skip_over_blank ( * value + 1 ) ; if ( * * value == \'""\' ) { <S2SV_StartBug> end = strchr ( * value + 1 , \'""\' ) ; <S2SV_EndBug> if ( ! end ) { DBG ( READ , ul_debug ( ""unbalanced<S2SV_blank>quotes<S2SV_blank>at:<S2SV_blank>%s"" , * value ) ) ; * cp = * value ; return - BLKID_ERR_CACHE ; } ( * value ) ++ ; * end = '\\0' ; <S2SV_StartBug> end ++ ; <S2SV_EndBug> } else { end = skip_over_word ( * value ) ; if ( * end ) { * end = '\\0' ; end ++ ; } } * cp = end ; return 1 ; }
","<S2SV_ModStart> \'""\' ) { char * p = end = <S2SV_ModEnd> * value + <S2SV_ModStart> value + 1 ; while ( * p ) { if ( * p == '\\\\' ) { p ++ ; * end = * p ; } else { * end = * p ; if ( * p == \'""\' ) break ; } p ++ ; end ++ ; } if ( * end != \'""\' <S2SV_ModEnd> ) { DBG <S2SV_ModStart> '\\0' ; end = ++ p <S2SV_ModEnd> ; } else
"
921,"CWE-835 static int lldp_private_8021_print ( netdissect_options * ndo , const u_char * tptr , u_int tlv_len ) { int subtype , hexdump = FALSE ; u_int sublen ; u_int tval ; <S2SV_StartBug> uint8_t i ; <S2SV_EndBug> if ( tlv_len < 4 ) { return hexdump ; } subtype = * ( tptr + 3 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Subtype<S2SV_blank>(%u)"" , tok2str ( lldp_8021_subtype_values , ""unknown"" , subtype ) , subtype ) ) ; switch ( subtype ) { case LLDP_PRIVATE_8021_SUBTYPE_PORT_VLAN_ID : if ( tlv_len < 6 ) { return hexdump ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>port<S2SV_blank>vlan<S2SV_blank>id<S2SV_blank>(PVID):<S2SV_blank>%u"" , EXTRACT_16BITS ( tptr + 4 ) ) ) ; break ; case LLDP_PRIVATE_8021_SUBTYPE_PROTOCOL_VLAN_ID : if ( tlv_len < 7 ) { return hexdump ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>port<S2SV_blank>and<S2SV_blank>protocol<S2SV_blank>vlan<S2SV_blank>id<S2SV_blank>(PPVID):<S2SV_blank>%u,<S2SV_blank>flags<S2SV_blank>[%s]<S2SV_blank>(0x%02x)"" , EXTRACT_16BITS ( tptr + 5 ) , bittok2str ( lldp_8021_port_protocol_id_values , ""none"" , * ( tptr + 4 ) ) , * ( tptr + 4 ) ) ) ; break ; case LLDP_PRIVATE_8021_SUBTYPE_VLAN_NAME : if ( tlv_len < 6 ) { return hexdump ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>vlan<S2SV_blank>id<S2SV_blank>(VID):<S2SV_blank>%u"" , EXTRACT_16BITS ( tptr + 4 ) ) ) ; if ( tlv_len < 7 ) { return hexdump ; } sublen = * ( tptr + 6 ) ; if ( tlv_len < 7 + sublen ) { return hexdump ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>vlan<S2SV_blank>name:<S2SV_blank>"" ) ) ; safeputs ( ndo , tptr + 7 , sublen ) ; break ; case LLDP_PRIVATE_8021_SUBTYPE_PROTOCOL_IDENTITY : if ( tlv_len < 5 ) { return hexdump ; } sublen = * ( tptr + 4 ) ; if ( tlv_len < 5 + sublen ) { return hexdump ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>protocol<S2SV_blank>identity:<S2SV_blank>"" ) ) ; safeputs ( ndo , tptr + 5 , sublen ) ; break ; case LLDP_PRIVATE_8021_SUBTYPE_CONGESTION_NOTIFICATION : if ( tlv_len < LLDP_PRIVATE_8021_SUBTYPE_CONGESTION_NOTIFICATION_LENGTH ) { return hexdump ; } tval = * ( tptr + 4 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Pre-Priority<S2SV_blank>CNPV<S2SV_blank>Indicator"" ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Priority<S2SV_blank>:<S2SV_blank>0<S2SV_blank><S2SV_blank>1<S2SV_blank><S2SV_blank>2<S2SV_blank><S2SV_blank>3<S2SV_blank><S2SV_blank>4<S2SV_blank><S2SV_blank>5<S2SV_blank><S2SV_blank>6<S2SV_blank><S2SV_blank>7"" ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Value<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>:<S2SV_blank>"" ) ) ; for ( i = 0 ; i < NO_OF_BITS ; i ++ ) ND_PRINT ( ( ndo , ""%-2d<S2SV_blank>"" , ( tval >> i ) & 0x01 ) ) ; tval = * ( tptr + 5 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Pre-Priority<S2SV_blank>Ready<S2SV_blank>Indicator"" ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Priority<S2SV_blank>:<S2SV_blank>0<S2SV_blank><S2SV_blank>1<S2SV_blank><S2SV_blank>2<S2SV_blank><S2SV_blank>3<S2SV_blank><S2SV_blank>4<S2SV_blank><S2SV_blank>5<S2SV_blank><S2SV_blank>6<S2SV_blank><S2SV_blank>7"" ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Value<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>:<S2SV_blank>"" ) ) ; for ( i = 0 ; i < NO_OF_BITS ; i ++ ) ND_PRINT ( ( ndo , ""%-2d<S2SV_blank>"" , ( tval >> i ) & 0x01 ) ) ; break ; case LLDP_PRIVATE_8021_SUBTYPE_ETS_CONFIGURATION : if ( tlv_len < LLDP_PRIVATE_8021_SUBTYPE_ETS_CONFIGURATION_LENGTH ) { return hexdump ; } tval = * ( tptr + 4 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Willing:%d,<S2SV_blank>CBS:%d,<S2SV_blank>RES:%d,<S2SV_blank>Max<S2SV_blank>TCs:%d"" , tval >> 7 , ( tval >> 6 ) & 0x02 , ( tval >> 3 ) & 0x07 , tval & 0x07 ) ) ; print_ets_priority_assignment_table ( ndo , tptr + 5 ) ; print_tc_bandwidth_table ( ndo , tptr + 9 ) ; print_tsa_assignment_table ( ndo , tptr + 17 ) ; break ; case LLDP_PRIVATE_8021_SUBTYPE_ETS_RECOMMENDATION : if ( tlv_len < LLDP_PRIVATE_8021_SUBTYPE_ETS_RECOMMENDATION_LENGTH ) { return hexdump ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>RES:<S2SV_blank>%d"" , * ( tptr + 4 ) ) ) ; print_ets_priority_assignment_table ( ndo , tptr + 5 ) ; print_tc_bandwidth_table ( ndo , tptr + 9 ) ; print_tsa_assignment_table ( ndo , tptr + 17 ) ; break ; case LLDP_PRIVATE_8021_SUBTYPE_PFC_CONFIGURATION : if ( tlv_len < LLDP_PRIVATE_8021_SUBTYPE_PFC_CONFIGURATION_LENGTH ) { return hexdump ; } tval = * ( tptr + 4 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Willing:<S2SV_blank>%d,<S2SV_blank>MBC:<S2SV_blank>%d,<S2SV_blank>RES:<S2SV_blank>%d,<S2SV_blank>PFC<S2SV_blank>cap:%d<S2SV_blank>"" , tval >> 7 , ( tval >> 6 ) & 0x01 , ( tval >> 4 ) & 0x03 , ( tval & 0x0f ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>PFC<S2SV_blank>Enable"" ) ) ; tval = * ( tptr + 5 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Priority<S2SV_blank>:<S2SV_blank>0<S2SV_blank><S2SV_blank>1<S2SV_blank><S2SV_blank>2<S2SV_blank><S2SV_blank>3<S2SV_blank><S2SV_blank>4<S2SV_blank><S2SV_blank>5<S2SV_blank><S2SV_blank>6<S2SV_blank><S2SV_blank>7"" ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Value<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>:<S2SV_blank>"" ) ) ; for ( i = 0 ; i < NO_OF_BITS ; i ++ ) ND_PRINT ( ( ndo , ""%-2d<S2SV_blank>"" , ( tval >> i ) & 0x01 ) ) ; break ; case LLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY : if ( tlv_len < LLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY_MIN_LENGTH ) { return hexdump ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>RES:<S2SV_blank>%d"" , * ( tptr + 4 ) ) ) ; if ( tlv_len <= LLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY_MIN_LENGTH ) { return hexdump ; } sublen = tlv_len - 5 ; if ( sublen % 3 != 0 ) { return hexdump ; } i = 0 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Application<S2SV_blank>Priority<S2SV_blank>Table"" ) ) ; while ( i < sublen ) { tval = * ( tptr + i + 5 ) ; <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Priority:<S2SV_blank>%d,<S2SV_blank>RES:<S2SV_blank>%d,<S2SV_blank>Sel:<S2SV_blank>%d"" , <S2SV_EndBug> <S2SV_StartBug> tval >> 5 , ( tval >> 3 ) & 0x03 , ( tval & 0x07 ) ) ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""Protocol<S2SV_blank>ID:<S2SV_blank>%d"" , EXTRACT_16BITS ( tptr + i + 5 ) ) ) ; i = i + 3 ; } break ; case LLDP_PRIVATE_8021_SUBTYPE_EVB : if ( tlv_len < LLDP_PRIVATE_8021_SUBTYPE_EVB_LENGTH ) { return hexdump ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>EVB<S2SV_blank>Bridge<S2SV_blank>Status"" ) ) ; tval = * ( tptr + 4 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>RES:<S2SV_blank>%d,<S2SV_blank>BGID:<S2SV_blank>%d,<S2SV_blank>RRCAP:<S2SV_blank>%d,<S2SV_blank>RRCTR:<S2SV_blank>%d"" , tval >> 3 , ( tval >> 2 ) & 0x01 , ( tval >> 1 ) & 0x01 , tval & 0x01 ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>EVB<S2SV_blank>Station<S2SV_blank>Status"" ) ) ; tval = * ( tptr + 5 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>RES:<S2SV_blank>%d,<S2SV_blank>SGID:<S2SV_blank>%d,<S2SV_blank>RRREQ:<S2SV_blank>%d,RRSTAT:<S2SV_blank>%d"" , tval >> 4 , ( tval >> 3 ) & 0x01 , ( tval >> 2 ) & 0x01 , tval & 0x03 ) ) ; tval = * ( tptr + 6 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>R:<S2SV_blank>%d,<S2SV_blank>RTE:<S2SV_blank>%d,<S2SV_blank>"" , tval >> 5 , tval & 0x1f ) ) ; tval = * ( tptr + 7 ) ; ND_PRINT ( ( ndo , ""EVB<S2SV_blank>Mode:<S2SV_blank>%s<S2SV_blank>[%d]"" , tok2str ( lldp_evb_mode_values , ""unknown"" , tval >> 6 ) , tval >> 6 ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>ROL:<S2SV_blank>%d,<S2SV_blank>RWD:<S2SV_blank>%d,<S2SV_blank>"" , ( tval >> 5 ) & 0x01 , tval & 0x1f ) ) ; tval = * ( tptr + 8 ) ; ND_PRINT ( ( ndo , ""RES:<S2SV_blank>%d,<S2SV_blank>ROL:<S2SV_blank>%d,<S2SV_blank>RKA:<S2SV_blank>%d"" , tval >> 6 , ( tval >> 5 ) & 0x01 , tval & 0x1f ) ) ; break ; case LLDP_PRIVATE_8021_SUBTYPE_CDCP : if ( tlv_len < LLDP_PRIVATE_8021_SUBTYPE_CDCP_MIN_LENGTH ) { return hexdump ; } tval = * ( tptr + 4 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Role:<S2SV_blank>%d,<S2SV_blank>RES:<S2SV_blank>%d,<S2SV_blank>Scomp:<S2SV_blank>%d<S2SV_blank>"" , tval >> 7 , ( tval >> 4 ) & 0x07 , ( tval >> 3 ) & 0x01 ) ) ; ND_PRINT ( ( ndo , ""ChnCap:<S2SV_blank>%d"" , EXTRACT_16BITS ( tptr + 6 ) & 0x0fff ) ) ; sublen = tlv_len - 8 ; if ( sublen % 3 != 0 ) { return hexdump ; } i = 0 ; while ( i < sublen ) { tval = EXTRACT_24BITS ( tptr + i + 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>SCID:<S2SV_blank>%d,<S2SV_blank>SVID:<S2SV_blank>%d"" , tval >> 12 , tval & 0x000fff ) ) ; i = i + 3 ; } break ; default : hexdump = TRUE ; break ; } return hexdump ; }
","<S2SV_ModStart> u_int tval ; u_int <S2SV_ModEnd> i ; if <S2SV_ModStart> ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>RES:<S2SV_blank>%u,<S2SV_blank>Sel:<S2SV_blank>%u,<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>%u"" <S2SV_ModEnd> , tval >> <S2SV_ModStart> & 0x07 ) , <S2SV_ModEnd> EXTRACT_16BITS ( tptr
"
922,"CWE-284 bool btsock_thread_remove_fd_and_close ( int thread_handle , int fd ) { if ( thread_handle < 0 || thread_handle >= MAX_THREAD ) { APPL_TRACE_ERROR ( ""%s<S2SV_blank>invalid<S2SV_blank>thread<S2SV_blank>handle:<S2SV_blank>%d"" , __func__ , thread_handle ) ; return false ; } if ( fd == - 1 ) { APPL_TRACE_ERROR ( ""%s<S2SV_blank>invalid<S2SV_blank>file<S2SV_blank>descriptor."" , __func__ ) ; return false ; } sock_cmd_t cmd = { CMD_REMOVE_FD , fd , 0 , 0 , 0 } ; <S2SV_StartBug> return send ( ts [ thread_handle ] . cmd_fdw , & cmd , sizeof ( cmd ) , 0 ) == sizeof ( cmd ) ; <S2SV_EndBug> }
","<S2SV_ModStart> } ; return TEMP_FAILURE_RETRY ( <S2SV_ModStart> , 0 ) )
"
923,"CWE-399 int kvm_set_msr_common ( struct kvm_vcpu * vcpu , struct msr_data * msr_info ) { bool pr = false ; u32 msr = msr_info -> index ; u64 data = msr_info -> data ; switch ( msr ) { case MSR_AMD64_NB_CFG : case MSR_IA32_UCODE_REV : case MSR_IA32_UCODE_WRITE : case MSR_VM_HSAVE_PA : case MSR_AMD64_PATCH_LOADER : case MSR_AMD64_BU_CFG2 : break ; case MSR_EFER : return set_efer ( vcpu , data ) ; case MSR_K7_HWCR : data &= ~ ( u64 ) 0x40 ; data &= ~ ( u64 ) 0x100 ; data &= ~ ( u64 ) 0x8 ; if ( data != 0 ) { vcpu_unimpl ( vcpu , ""unimplemented<S2SV_blank>HWCR<S2SV_blank>wrmsr:<S2SV_blank>0x%llx\\n"" , data ) ; return 1 ; } break ; case MSR_FAM10H_MMIO_CONF_BASE : if ( data != 0 ) { vcpu_unimpl ( vcpu , ""unimplemented<S2SV_blank>MMIO_CONF_BASE<S2SV_blank>wrmsr:<S2SV_blank>"" ""0x%llx\\n"" , data ) ; return 1 ; } break ; case MSR_IA32_DEBUGCTLMSR : if ( ! data ) { break ; } else if ( data & ~ ( DEBUGCTLMSR_LBR | DEBUGCTLMSR_BTF ) ) { return 1 ; } vcpu_unimpl ( vcpu , ""%s:<S2SV_blank>MSR_IA32_DEBUGCTLMSR<S2SV_blank>0x%llx,<S2SV_blank>nop\\n"" , __func__ , data ) ; break ; case 0x200 ... 0x2ff : return set_msr_mtrr ( vcpu , msr , data ) ; case MSR_IA32_APICBASE : kvm_set_apic_base ( vcpu , data ) ; break ; case APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff : return kvm_x2apic_msr_write ( vcpu , msr , data ) ; case MSR_IA32_TSCDEADLINE : kvm_set_lapic_tscdeadline_msr ( vcpu , data ) ; break ; case MSR_IA32_TSC_ADJUST : if ( guest_cpuid_has_tsc_adjust ( vcpu ) ) { if ( ! msr_info -> host_initiated ) { u64 adj = data - vcpu -> arch . ia32_tsc_adjust_msr ; kvm_x86_ops -> adjust_tsc_offset ( vcpu , adj , true ) ; } vcpu -> arch . ia32_tsc_adjust_msr = data ; } break ; case MSR_IA32_MISC_ENABLE : vcpu -> arch . ia32_misc_enable_msr = data ; break ; case MSR_KVM_WALL_CLOCK_NEW : case MSR_KVM_WALL_CLOCK : vcpu -> kvm -> arch . wall_clock = data ; kvm_write_wall_clock ( vcpu -> kvm , data ) ; break ; case MSR_KVM_SYSTEM_TIME_NEW : case MSR_KVM_SYSTEM_TIME : { <S2SV_StartBug> kvmclock_reset ( vcpu ) ; <S2SV_EndBug> vcpu -> arch . time = data ; kvm_make_request ( KVM_REQ_CLOCK_UPDATE , vcpu ) ; if ( ! ( data & 1 ) ) break ; <S2SV_StartBug> vcpu -> arch . time_offset = data & ~ ( PAGE_MASK | 1 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vcpu -> arch . time_offset & <S2SV_EndBug> ( sizeof ( struct pvclock_vcpu_time_info ) - 1 ) ) break ; <S2SV_StartBug> vcpu -> arch . time_page = <S2SV_EndBug> <S2SV_StartBug> gfn_to_page ( vcpu -> kvm , data >> PAGE_SHIFT ) ; <S2SV_EndBug> if ( is_error_page ( vcpu -> arch . time_page ) ) vcpu -> arch . time_page = NULL ; break ; } case MSR_KVM_ASYNC_PF_EN : if ( kvm_pv_enable_async_pf ( vcpu , data ) ) return 1 ; break ; case MSR_KVM_STEAL_TIME : if ( unlikely ( ! sched_info_on ( ) ) ) return 1 ; if ( data & KVM_STEAL_RESERVED_MASK ) return 1 ; if ( kvm_gfn_to_hva_cache_init ( vcpu -> kvm , & vcpu -> arch . st . stime , data & KVM_STEAL_VALID_BITS ) ) return 1 ; vcpu -> arch . st . msr_val = data ; if ( ! ( data & KVM_MSR_ENABLED ) ) break ; vcpu -> arch . st . last_steal = current -> sched_info . run_delay ; preempt_disable ( ) ; accumulate_steal_time ( vcpu ) ; preempt_enable ( ) ; kvm_make_request ( KVM_REQ_STEAL_UPDATE , vcpu ) ; break ; case MSR_KVM_PV_EOI_EN : if ( kvm_lapic_enable_pv_eoi ( vcpu , data ) ) return 1 ; break ; case MSR_IA32_MCG_CTL : case MSR_IA32_MCG_STATUS : case MSR_IA32_MC0_CTL ... MSR_IA32_MC0_CTL + 4 * KVM_MAX_MCE_BANKS - 1 : return set_msr_mce ( vcpu , msr , data ) ; case MSR_K7_EVNTSEL0 : case MSR_K7_EVNTSEL1 : case MSR_K7_EVNTSEL2 : case MSR_K7_EVNTSEL3 : if ( data != 0 ) vcpu_unimpl ( vcpu , ""unimplemented<S2SV_blank>perfctr<S2SV_blank>wrmsr:<S2SV_blank>"" ""0x%x<S2SV_blank>data<S2SV_blank>0x%llx\\n"" , msr , data ) ; break ; case MSR_K7_PERFCTR0 : case MSR_K7_PERFCTR1 : case MSR_K7_PERFCTR2 : case MSR_K7_PERFCTR3 : vcpu_unimpl ( vcpu , ""unimplemented<S2SV_blank>perfctr<S2SV_blank>wrmsr:<S2SV_blank>"" ""0x%x<S2SV_blank>data<S2SV_blank>0x%llx\\n"" , msr , data ) ; break ; case MSR_P6_PERFCTR0 : case MSR_P6_PERFCTR1 : pr = true ; case MSR_P6_EVNTSEL0 : case MSR_P6_EVNTSEL1 : if ( kvm_pmu_msr ( vcpu , msr ) ) return kvm_pmu_set_msr ( vcpu , msr , data ) ; if ( pr || data != 0 ) vcpu_unimpl ( vcpu , ""disabled<S2SV_blank>perfctr<S2SV_blank>wrmsr:<S2SV_blank>"" ""0x%x<S2SV_blank>data<S2SV_blank>0x%llx\\n"" , msr , data ) ; break ; case MSR_K7_CLK_CTL : break ; case HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15 : if ( kvm_hv_msr_partition_wide ( msr ) ) { int r ; mutex_lock ( & vcpu -> kvm -> lock ) ; r = set_msr_hyperv_pw ( vcpu , msr , data ) ; mutex_unlock ( & vcpu -> kvm -> lock ) ; return r ; } else return set_msr_hyperv ( vcpu , msr , data ) ; break ; case MSR_IA32_BBL_CR_CTL3 : vcpu_unimpl ( vcpu , ""ignored<S2SV_blank>wrmsr:<S2SV_blank>0x%x<S2SV_blank>data<S2SV_blank>%llx\\n"" , msr , data ) ; break ; case MSR_AMD64_OSVW_ID_LENGTH : if ( ! guest_cpuid_has_osvw ( vcpu ) ) return 1 ; vcpu -> arch . osvw . length = data ; break ; case MSR_AMD64_OSVW_STATUS : if ( ! guest_cpuid_has_osvw ( vcpu ) ) return 1 ; vcpu -> arch . osvw . status = data ; break ; default : if ( msr && ( msr == vcpu -> kvm -> arch . xen_hvm_config . msr ) ) return xen_hvm_config ( vcpu , data ) ; if ( kvm_pmu_msr ( vcpu , msr ) ) return kvm_pmu_set_msr ( vcpu , msr , data ) ; if ( ! ignore_msrs ) { vcpu_unimpl ( vcpu , ""unhandled<S2SV_blank>wrmsr:<S2SV_blank>0x%x<S2SV_blank>data<S2SV_blank>%llx\\n"" , msr , data ) ; return 1 ; } else { vcpu_unimpl ( vcpu , ""ignored<S2SV_blank>wrmsr:<S2SV_blank>0x%x<S2SV_blank>data<S2SV_blank>%llx\\n"" , msr , data ) ; break ; } } return 0 ; }
","<S2SV_ModStart> MSR_KVM_SYSTEM_TIME : { u64 gpa_offset ; <S2SV_ModStart> ) break ; gpa_offset <S2SV_ModEnd> = data & <S2SV_ModStart> ; if ( gpa_offset <S2SV_ModEnd> & ( sizeof <S2SV_ModStart> ) break ; if ( kvm_gfn_to_hva_cache_init <S2SV_ModEnd> ( vcpu -> <S2SV_ModStart> -> kvm , & vcpu -> arch . pv_time , data & ~ 1ULL ) ) vcpu -> arch . pv_time_enabled = false ; else vcpu -> arch . pv_time_enabled = true <S2SV_ModEnd> ; break ;
"
924,"CWE-787 opj_image_t * tgatoimage ( const char * filename , opj_cparameters_t * parameters ) { FILE * f ; opj_image_t * image ; unsigned int image_width , image_height , pixel_bit_depth ; unsigned int x , y ; int flip_image = 0 ; opj_image_cmptparm_t cmptparm [ 4 ] ; int numcomps ; OPJ_COLOR_SPACE color_space ; OPJ_BOOL mono ; OPJ_BOOL save_alpha ; int subsampling_dx , subsampling_dy ; int i ; f = fopen ( filename , ""rb"" ) ; if ( ! f ) { fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading<S2SV_blank>!!\\n"" , filename ) ; return 0 ; } if ( ! tga_readheader ( f , & pixel_bit_depth , & image_width , & image_height , & flip_image ) ) { fclose ( f ) ; return NULL ; } if ( ! ( ( pixel_bit_depth == 24 ) || ( pixel_bit_depth == 32 ) ) ) { fclose ( f ) ; return NULL ; } memset ( & cmptparm [ 0 ] , 0 , 4 * sizeof ( opj_image_cmptparm_t ) ) ; mono = ( pixel_bit_depth == 8 ) || ( pixel_bit_depth == 16 ) ; save_alpha = ( pixel_bit_depth == 16 ) || ( pixel_bit_depth == 32 ) ; if ( mono ) { color_space = OPJ_CLRSPC_GRAY ; numcomps = save_alpha ? 2 : 1 ; } else { numcomps = save_alpha ? 4 : 3 ; color_space = OPJ_CLRSPC_SRGB ; } <S2SV_StartBug> subsampling_dx = parameters -> subsampling_dx ; <S2SV_EndBug> subsampling_dy = parameters -> subsampling_dy ; for ( i = 0 ; i < numcomps ; i ++ ) { cmptparm [ i ] . prec = 8 ; cmptparm [ i ] . bpp = 8 ; cmptparm [ i ] . sgnd = 0 ; cmptparm [ i ] . dx = ( OPJ_UINT32 ) subsampling_dx ; cmptparm [ i ] . dy = ( OPJ_UINT32 ) subsampling_dy ; cmptparm [ i ] . w = image_width ; cmptparm [ i ] . h = image_height ; } image = opj_image_create ( ( OPJ_UINT32 ) numcomps , & cmptparm [ 0 ] , color_space ) ; if ( ! image ) { fclose ( f ) ; return NULL ; } image -> x0 = ( OPJ_UINT32 ) parameters -> image_offset_x0 ; image -> y0 = ( OPJ_UINT32 ) parameters -> image_offset_y0 ; image -> x1 = ! image -> x0 ? ( OPJ_UINT32 ) ( image_width - 1 ) * ( OPJ_UINT32 ) subsampling_dx + 1 : image -> x0 + ( OPJ_UINT32 ) ( image_width - 1 ) * ( OPJ_UINT32 ) subsampling_dx + 1 ; image -> y1 = ! image -> y0 ? ( OPJ_UINT32 ) ( image_height - 1 ) * ( OPJ_UINT32 ) subsampling_dy + 1 : image -> y0 + ( OPJ_UINT32 ) ( image_height - 1 ) * ( OPJ_UINT32 ) subsampling_dy + 1 ; for ( y = 0 ; y < image_height ; y ++ ) { int index ; if ( flip_image ) { index = ( int ) ( ( image_height - y - 1 ) * image_width ) ; } else { index = ( int ) ( y * image_width ) ; } if ( numcomps == 3 ) { for ( x = 0 ; x < image_width ; x ++ ) { unsigned char r , g , b ; if ( ! fread ( & b , 1 , 1 , f ) ) { fprintf ( stderr , ""\\nError:<S2SV_blank>fread<S2SV_blank>return<S2SV_blank>a<S2SV_blank>number<S2SV_blank>of<S2SV_blank>element<S2SV_blank>different<S2SV_blank>from<S2SV_blank>the<S2SV_blank>expected.\\n"" ) ; opj_image_destroy ( image ) ; fclose ( f ) ; return NULL ; } if ( ! fread ( & g , 1 , 1 , f ) ) { fprintf ( stderr , ""\\nError:<S2SV_blank>fread<S2SV_blank>return<S2SV_blank>a<S2SV_blank>number<S2SV_blank>of<S2SV_blank>element<S2SV_blank>different<S2SV_blank>from<S2SV_blank>the<S2SV_blank>expected.\\n"" ) ; opj_image_destroy ( image ) ; fclose ( f ) ; return NULL ; } if ( ! fread ( & r , 1 , 1 , f ) ) { fprintf ( stderr , ""\\nError:<S2SV_blank>fread<S2SV_blank>return<S2SV_blank>a<S2SV_blank>number<S2SV_blank>of<S2SV_blank>element<S2SV_blank>different<S2SV_blank>from<S2SV_blank>the<S2SV_blank>expected.\\n"" ) ; opj_image_destroy ( image ) ; fclose ( f ) ; return NULL ; } image -> comps [ 0 ] . data [ index ] = r ; image -> comps [ 1 ] . data [ index ] = g ; image -> comps [ 2 ] . data [ index ] = b ; index ++ ; } } else if ( numcomps == 4 ) { for ( x = 0 ; x < image_width ; x ++ ) { unsigned char r , g , b , a ; if ( ! fread ( & b , 1 , 1 , f ) ) { fprintf ( stderr , ""\\nError:<S2SV_blank>fread<S2SV_blank>return<S2SV_blank>a<S2SV_blank>number<S2SV_blank>of<S2SV_blank>element<S2SV_blank>different<S2SV_blank>from<S2SV_blank>the<S2SV_blank>expected.\\n"" ) ; opj_image_destroy ( image ) ; fclose ( f ) ; return NULL ; } if ( ! fread ( & g , 1 , 1 , f ) ) { fprintf ( stderr , ""\\nError:<S2SV_blank>fread<S2SV_blank>return<S2SV_blank>a<S2SV_blank>number<S2SV_blank>of<S2SV_blank>element<S2SV_blank>different<S2SV_blank>from<S2SV_blank>the<S2SV_blank>expected.\\n"" ) ; opj_image_destroy ( image ) ; fclose ( f ) ; return NULL ; } if ( ! fread ( & r , 1 , 1 , f ) ) { fprintf ( stderr , ""\\nError:<S2SV_blank>fread<S2SV_blank>return<S2SV_blank>a<S2SV_blank>number<S2SV_blank>of<S2SV_blank>element<S2SV_blank>different<S2SV_blank>from<S2SV_blank>the<S2SV_blank>expected.\\n"" ) ; opj_image_destroy ( image ) ; fclose ( f ) ; return NULL ; } if ( ! fread ( & a , 1 , 1 , f ) ) { fprintf ( stderr , ""\\nError:<S2SV_blank>fread<S2SV_blank>return<S2SV_blank>a<S2SV_blank>number<S2SV_blank>of<S2SV_blank>element<S2SV_blank>different<S2SV_blank>from<S2SV_blank>the<S2SV_blank>expected.\\n"" ) ; opj_image_destroy ( image ) ; fclose ( f ) ; return NULL ; } image -> comps [ 0 ] . data [ index ] = r ; image -> comps [ 1 ] . data [ index ] = g ; image -> comps [ 2 ] . data [ index ] = b ; image -> comps [ 3 ] . data [ index ] = a ; index ++ ; } } else { fprintf ( stderr , ""Currently<S2SV_blank>unsupported<S2SV_blank>bit<S2SV_blank>depth<S2SV_blank>:<S2SV_blank>%s\\n"" , filename ) ; } } fclose ( f ) ; return image ; }
","<S2SV_ModStart> OPJ_CLRSPC_SRGB ; } if ( image_height != 0 && image_width > 10000000 / image_height / numcomps ) { char ch ; OPJ_UINT64 expected_file_size = ( OPJ_UINT64 ) image_width * image_height * numcomps ; long curpos = ftell ( f ) ; if ( expected_file_size > ( OPJ_UINT64 ) INT_MAX ) { expected_file_size = ( OPJ_UINT64 ) INT_MAX ; } fseek ( f , ( long ) expected_file_size - 1 , SEEK_SET ) ; if ( fread ( & ch , 1 , 1 , f ) != 1 ) { fclose ( f ) ; return NULL ; } fseek ( f , curpos , SEEK_SET ) ; }
"
925,"CWE-119 int nntp_add_group ( char * line , void * data ) { struct NntpServer * nserv = data ; struct NntpData * nntp_data = NULL ; <S2SV_StartBug> char group [ LONG_STRING ] ; <S2SV_EndBug> char desc [ HUGE_STRING ] = """" ; char mod ; anum_t first , last ; if ( ! nserv || ! line ) return 0 ; <S2SV_StartBug> if ( sscanf ( line , ""%s<S2SV_blank>"" ANUM ""<S2SV_blank>"" ANUM ""<S2SV_blank>%c<S2SV_blank>%[^\\n]"" , group , & last , & first , & mod , desc ) < 4 ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> nntp_data = nntp_data_find ( nserv , group ) ; nntp_data -> deleted = false ; nntp_data -> first_message = first ; nntp_data -> last_message = last ; nntp_data -> allowed = ( mod == 'y' ) || ( mod == 'm' ) ; mutt_str_replace ( & nntp_data -> desc , desc ) ; if ( nntp_data -> newsrc_ent || nntp_data -> last_cached ) nntp_group_unread_stat ( nntp_data ) ; else if ( nntp_data -> last_message && nntp_data -> first_message <= nntp_data -> last_message ) nntp_data -> unread = nntp_data -> last_message - nntp_data -> first_message + 1 ; else nntp_data -> unread = 0 ; return 0 ; }
","<S2SV_ModStart> [ LONG_STRING ] = """" <S2SV_ModStart> ( line , ""%1023s<S2SV_blank>"" <S2SV_ModEnd> ANUM ""<S2SV_blank>"" ANUM <S2SV_ModStart> ANUM ""<S2SV_blank>"" ANUM ""<S2SV_blank>%c<S2SV_blank>%8191[^\\n]"" <S2SV_ModEnd> , group , <S2SV_ModStart> < 4 ) { mutt_debug ( 4 , ""Cannot<S2SV_blank>parse<S2SV_blank>server<S2SV_blank>line:<S2SV_blank>%s\\n"" , line ) ; <S2SV_ModStart> return 0 ; }
"
926,"CWE-20 int bnep_add_connection ( struct bnep_connadd_req * req , struct socket * sock ) { struct net_device * dev ; struct bnep_session * s , * ss ; u8 dst [ ETH_ALEN ] , src [ ETH_ALEN ] ; int err ; BT_DBG ( """" ) ; <S2SV_StartBug> baswap ( ( void * ) dst , & l2cap_pi ( sock -> sk ) -> chan -> dst ) ; <S2SV_EndBug> baswap ( ( void * ) src , & l2cap_pi ( sock -> sk ) -> chan -> src ) ; dev = alloc_netdev ( sizeof ( struct bnep_session ) , ( * req -> device ) ? req -> device : ""bnep%d"" , NET_NAME_UNKNOWN , bnep_net_setup ) ; if ( ! dev ) return - ENOMEM ; down_write ( & bnep_session_sem ) ; ss = __bnep_get_session ( dst ) ; if ( ss && ss -> state == BT_CONNECTED ) { err = - EEXIST ; goto failed ; } s = netdev_priv ( dev ) ; memcpy ( s -> eh . h_dest , & src , ETH_ALEN ) ; memcpy ( s -> eh . h_source , & dst , ETH_ALEN ) ; memcpy ( dev -> dev_addr , s -> eh . h_dest , ETH_ALEN ) ; s -> dev = dev ; s -> sock = sock ; s -> role = req -> role ; s -> state = BT_CONNECTED ; s -> msg . msg_flags = MSG_NOSIGNAL ; # ifdef CONFIG_BT_BNEP_MC_FILTER set_bit ( bnep_mc_hash ( dev -> broadcast ) , ( ulong * ) & s -> mc_filter ) ; # endif # ifdef CONFIG_BT_BNEP_PROTO_FILTER bnep_set_default_proto_filter ( s ) ; # endif SET_NETDEV_DEV ( dev , bnep_get_device ( s ) ) ; SET_NETDEV_DEVTYPE ( dev , & bnep_type ) ; err = register_netdev ( dev ) ; if ( err ) goto failed ; __bnep_link_session ( s ) ; __module_get ( THIS_MODULE ) ; s -> task = kthread_run ( bnep_session , s , ""kbnepd<S2SV_blank>%s"" , dev -> name ) ; if ( IS_ERR ( s -> task ) ) { module_put ( THIS_MODULE ) ; unregister_netdev ( dev ) ; __bnep_unlink_session ( s ) ; err = PTR_ERR ( s -> task ) ; goto failed ; } up_write ( & bnep_session_sem ) ; strcpy ( req -> device , dev -> name ) ; return 0 ; failed : up_write ( & bnep_session_sem ) ; free_netdev ( dev ) ; return err ; }
","<S2SV_ModStart> """" ) ; if ( ! l2cap_is_socket ( sock ) ) return - EBADFD ;
"
927,"CWE-119 gboolean _pango_emoji_iter_next ( PangoEmojiIter * iter ) { PangoEmojiType current_emoji_type = PANGO_EMOJI_TYPE_INVALID ; if ( iter -> end == iter -> text_end ) return FALSE ; iter -> start = iter -> end ; for ( ; iter -> end < iter -> text_end ; iter -> end = g_utf8_next_char ( iter -> end ) ) { gunichar ch = g_utf8_get_char ( iter -> end ) ; if ( ( ! ( ch == kZeroWidthJoinerCharacter && ! iter -> is_emoji ) && ch != kVariationSelector15Character && ch != kVariationSelector16Character && ch != kCombiningEnclosingCircleBackslashCharacter && ! _pango_Is_Regional_Indicator ( ch ) && ! ( ( ch == kLeftSpeechBubbleCharacter || ch == kRainbowCharacter || ch == kMaleSignCharacter || ch == kFemaleSignCharacter || ch == kStaffOfAesculapiusCharacter ) && ! iter -> is_emoji ) ) || current_emoji_type == PANGO_EMOJI_TYPE_INVALID ) { current_emoji_type = _pango_get_emoji_type ( ch ) ; } if ( g_utf8_next_char ( iter -> end ) < iter -> text_end ) { gunichar peek_char = g_utf8_get_char ( g_utf8_next_char ( iter -> end ) ) ; if ( current_emoji_type == PANGO_EMOJI_TYPE_EMOJI_EMOJI && peek_char == kVariationSelector15Character ) { current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_TEXT ; } if ( ( current_emoji_type == PANGO_EMOJI_TYPE_EMOJI_TEXT || _pango_Is_Emoji_Keycap_Base ( ch ) ) && peek_char == kVariationSelector16Character ) { current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI ; } if ( _pango_Is_Emoji_Keycap_Base ( ch ) && peek_char == kCombiningEnclosingKeycapCharacter ) { current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI ; } ; if ( _pango_Is_Regional_Indicator ( ch ) && _pango_Is_Regional_Indicator ( peek_char ) ) { current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI ; } if ( ( ch == kEyeCharacter || ch == kWavingWhiteFlagCharacter ) && peek_char == kZeroWidthJoinerCharacter ) { current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI ; } } if ( iter -> is_emoji == ( gboolean ) 2 ) iter -> is_emoji = ! PANGO_EMOJI_TYPE_IS_EMOJI ( current_emoji_type ) ; if ( iter -> is_emoji == PANGO_EMOJI_TYPE_IS_EMOJI ( current_emoji_type ) ) { iter -> is_emoji = ! PANGO_EMOJI_TYPE_IS_EMOJI ( current_emoji_type ) ; <S2SV_StartBug> return TRUE ; <S2SV_EndBug> } } iter -> is_emoji = PANGO_EMOJI_TYPE_IS_EMOJI ( current_emoji_type ) ; return TRUE ; }
","<S2SV_ModStart> current_emoji_type ) ; if ( iter -> start == iter -> end ) iter -> end = g_utf8_next_char ( iter -> end ) ;
"
928,"CWE-476 av_cold void ff_idctdsp_init ( IDCTDSPContext * c , AVCodecContext * avctx ) { const unsigned high_bit_depth = avctx -> bits_per_raw_sample > 8 ; if ( avctx -> lowres == 1 ) { c -> idct_put = ff_jref_idct4_put ; c -> idct_add = ff_jref_idct4_add ; c -> idct = ff_j_rev_dct4 ; c -> perm_type = FF_IDCT_PERM_NONE ; } else if ( avctx -> lowres == 2 ) { c -> idct_put = ff_jref_idct2_put ; c -> idct_add = ff_jref_idct2_add ; c -> idct = ff_j_rev_dct2 ; c -> perm_type = FF_IDCT_PERM_NONE ; } else if ( avctx -> lowres == 3 ) { c -> idct_put = ff_jref_idct1_put ; c -> idct_add = ff_jref_idct1_add ; c -> idct = ff_j_rev_dct1 ; c -> perm_type = FF_IDCT_PERM_NONE ; } else { if ( avctx -> bits_per_raw_sample == 10 || avctx -> bits_per_raw_sample == 9 ) { <S2SV_StartBug> if ( avctx -> codec_id == AV_CODEC_ID_MPEG4 && avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) <S2SV_EndBug> c -> idct_put = ff_simple_idct_put_int32_10bit ; else { c -> idct_put = ff_simple_idct_put_int16_10bit ; c -> idct_add = ff_simple_idct_add_int16_10bit ; c -> idct = ff_simple_idct_int16_10bit ; } c -> perm_type = FF_IDCT_PERM_NONE ; } else if ( avctx -> bits_per_raw_sample == 12 ) { c -> idct_put = ff_simple_idct_put_int16_12bit ; c -> idct_add = ff_simple_idct_add_int16_12bit ; c -> idct = ff_simple_idct_int16_12bit ; c -> perm_type = FF_IDCT_PERM_NONE ; } else { if ( avctx -> idct_algo == FF_IDCT_INT ) { c -> idct_put = ff_jref_idct_put ; c -> idct_add = ff_jref_idct_add ; c -> idct = ff_j_rev_dct ; c -> perm_type = FF_IDCT_PERM_LIBMPEG2 ; # if CONFIG_FAANIDCT } else if ( avctx -> idct_algo == FF_IDCT_FAAN ) { c -> idct_put = ff_faanidct_put ; c -> idct_add = ff_faanidct_add ; c -> idct = ff_faanidct ; c -> perm_type = FF_IDCT_PERM_NONE ; # endif } else { c -> idct_put = ff_simple_idct_put_int16_8bit ; c -> idct_add = ff_simple_idct_add_int16_8bit ; c -> idct = ff_simple_idct_int16_8bit ; c -> perm_type = FF_IDCT_PERM_NONE ; } } } c -> put_pixels_clamped = ff_put_pixels_clamped_c ; c -> put_signed_pixels_clamped = put_signed_pixels_clamped_c ; c -> add_pixels_clamped = ff_add_pixels_clamped_c ; if ( CONFIG_MPEG4_DECODER && avctx -> idct_algo == FF_IDCT_XVID ) ff_xvid_idct_init ( c , avctx ) ; if ( ARCH_AARCH64 ) ff_idctdsp_init_aarch64 ( c , avctx , high_bit_depth ) ; if ( ARCH_ALPHA ) ff_idctdsp_init_alpha ( c , avctx , high_bit_depth ) ; if ( ARCH_ARM ) ff_idctdsp_init_arm ( c , avctx , high_bit_depth ) ; if ( ARCH_PPC ) ff_idctdsp_init_ppc ( c , avctx , high_bit_depth ) ; if ( ARCH_X86 ) ff_idctdsp_init_x86 ( c , avctx , high_bit_depth ) ; if ( ARCH_MIPS ) ff_idctdsp_init_mips ( c , avctx , high_bit_depth ) ; ff_init_scantable_permutation ( c -> idct_permutation , c -> perm_type ) ; }
","<S2SV_ModStart> { if ( c -> mpeg4_studio_profile <S2SV_ModEnd> ) c ->
"
929,"CWE-399 static int kvm_guest_time_update ( struct kvm_vcpu * v ) { unsigned long flags , this_tsc_khz ; struct kvm_vcpu_arch * vcpu = & v -> arch ; struct kvm_arch * ka = & v -> kvm -> arch ; <S2SV_StartBug> void * shared_kaddr ; <S2SV_EndBug> s64 kernel_ns , max_kernel_ns ; u64 tsc_timestamp , host_tsc ; <S2SV_StartBug> struct pvclock_vcpu_time_info * guest_hv_clock ; <S2SV_EndBug> u8 pvclock_flags ; bool use_master_clock ; kernel_ns = 0 ; host_tsc = 0 ; spin_lock ( & ka -> pvclock_gtod_sync_lock ) ; use_master_clock = ka -> use_master_clock ; if ( use_master_clock ) { host_tsc = ka -> master_cycle_now ; kernel_ns = ka -> master_kernel_ns ; } spin_unlock ( & ka -> pvclock_gtod_sync_lock ) ; local_irq_save ( flags ) ; this_tsc_khz = __get_cpu_var ( cpu_tsc_khz ) ; if ( unlikely ( this_tsc_khz == 0 ) ) { local_irq_restore ( flags ) ; kvm_make_request ( KVM_REQ_CLOCK_UPDATE , v ) ; return 1 ; } if ( ! use_master_clock ) { host_tsc = native_read_tsc ( ) ; kernel_ns = get_kernel_ns ( ) ; } tsc_timestamp = kvm_x86_ops -> read_l1_tsc ( v , host_tsc ) ; if ( vcpu -> tsc_catchup ) { u64 tsc = compute_guest_tsc ( v , kernel_ns ) ; if ( tsc > tsc_timestamp ) { adjust_tsc_offset_guest ( v , tsc - tsc_timestamp ) ; tsc_timestamp = tsc ; } } local_irq_restore ( flags ) ; <S2SV_StartBug> if ( ! vcpu -> time_page ) <S2SV_EndBug> return 0 ; max_kernel_ns = 0 ; if ( vcpu -> hv_clock . tsc_timestamp ) { max_kernel_ns = vcpu -> last_guest_tsc - vcpu -> hv_clock . tsc_timestamp ; max_kernel_ns = pvclock_scale_delta ( max_kernel_ns , vcpu -> hv_clock . tsc_to_system_mul , vcpu -> hv_clock . tsc_shift ) ; max_kernel_ns += vcpu -> last_kernel_ns ; } if ( unlikely ( vcpu -> hw_tsc_khz != this_tsc_khz ) ) { kvm_get_time_scale ( NSEC_PER_SEC / 1000 , this_tsc_khz , & vcpu -> hv_clock . tsc_shift , & vcpu -> hv_clock . tsc_to_system_mul ) ; vcpu -> hw_tsc_khz = this_tsc_khz ; } if ( ! use_master_clock ) { if ( max_kernel_ns > kernel_ns ) kernel_ns = max_kernel_ns ; } vcpu -> hv_clock . tsc_timestamp = tsc_timestamp ; vcpu -> hv_clock . system_time = kernel_ns + v -> kvm -> arch . kvmclock_offset ; vcpu -> last_kernel_ns = kernel_ns ; vcpu -> last_guest_tsc = tsc_timestamp ; vcpu -> hv_clock . version += 2 ; <S2SV_StartBug> shared_kaddr = kmap_atomic ( vcpu -> time_page ) ; <S2SV_EndBug> guest_hv_clock = shared_kaddr + vcpu -> time_offset ; <S2SV_StartBug> pvclock_flags = ( guest_hv_clock -> flags & PVCLOCK_GUEST_STOPPED ) ; <S2SV_EndBug> if ( vcpu -> pvclock_set_guest_stopped_request ) { pvclock_flags |= PVCLOCK_GUEST_STOPPED ; vcpu -> pvclock_set_guest_stopped_request = false ; } if ( use_master_clock ) pvclock_flags |= PVCLOCK_TSC_STABLE_BIT ; vcpu -> hv_clock . flags = pvclock_flags ; <S2SV_StartBug> memcpy ( shared_kaddr + vcpu -> time_offset , & vcpu -> hv_clock , <S2SV_EndBug> sizeof ( vcpu -> hv_clock ) ) ; <S2SV_StartBug> kunmap_atomic ( shared_kaddr ) ; <S2SV_EndBug> mark_page_dirty ( v -> kvm , vcpu -> time >> PAGE_SHIFT ) ; return 0 ; }
","<S2SV_ModStart> -> arch ; <S2SV_ModEnd> s64 kernel_ns , <S2SV_ModStart> ; struct pvclock_vcpu_time_info <S2SV_ModEnd> guest_hv_clock ; u8 <S2SV_ModStart> ! vcpu -> pv_time_enabled <S2SV_ModEnd> ) return 0 <S2SV_ModStart> += 2 ; if ( unlikely ( kvm_read_guest_cached ( v -> kvm , & vcpu -> pv_time , & guest_hv_clock , sizeof ( guest_hv_clock ) ) ) ) return 0 <S2SV_ModEnd> ; pvclock_flags = <S2SV_ModStart> = ( guest_hv_clock . <S2SV_ModEnd> flags & PVCLOCK_GUEST_STOPPED <S2SV_ModStart> = pvclock_flags ; kvm_write_guest_cached ( v -> kvm , & vcpu -> pv_time , <S2SV_ModEnd> & vcpu -> <S2SV_ModStart> ) ) ; <S2SV_ModEnd> return 0 ;
"
930,"CWE-000 int snd_ctl_add ( struct snd_card * card , struct snd_kcontrol * kcontrol ) { struct snd_ctl_elem_id id ; unsigned int idx ; <S2SV_StartBug> int err = - EINVAL ; <S2SV_EndBug> if ( ! kcontrol ) return err ; if ( snd_BUG_ON ( ! card || ! kcontrol -> info ) ) goto error ; id = kcontrol -> id ; down_write ( & card -> controls_rwsem ) ; if ( snd_ctl_find_id ( card , & id ) ) { up_write ( & card -> controls_rwsem ) ; dev_err ( card -> dev , ""control<S2SV_blank>%i:%i:%i:%s:%i<S2SV_blank>is<S2SV_blank>already<S2SV_blank>present\\n"" , id . iface , id . device , id . subdevice , id . name , id . index ) ; err = - EBUSY ; goto error ; } if ( snd_ctl_find_hole ( card , kcontrol -> count ) < 0 ) { up_write ( & card -> controls_rwsem ) ; err = - ENOMEM ; goto error ; } list_add_tail ( & kcontrol -> list , & card -> controls ) ; card -> controls_count += kcontrol -> count ; kcontrol -> id . numid = card -> last_numid + 1 ; card -> last_numid += kcontrol -> count ; <S2SV_StartBug> up_write ( & card -> controls_rwsem ) ; <S2SV_EndBug> <S2SV_StartBug> for ( idx = 0 ; idx < kcontrol -> count ; idx ++ , id . index ++ , id . numid ++ ) <S2SV_EndBug> snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_ADD , & id ) ; return 0 ; error : snd_ctl_free_one ( kcontrol ) ; return err ; }
","<S2SV_ModStart> int idx ; unsigned int count ; <S2SV_ModStart> -> count ; count = kcontrol -> count ; <S2SV_ModStart> ; idx < <S2SV_ModEnd> count ; idx
"
931,"CWE-416 struct net * get_net_ns_by_id ( struct net * net , int id ) { struct net * peer ; if ( id < 0 ) return NULL ; rcu_read_lock ( ) ; spin_lock_bh ( & net -> nsid_lock ) ; peer = idr_find ( & net -> netns_ids , id ) ; if ( peer ) <S2SV_StartBug> get_net ( peer ) ; <S2SV_EndBug> spin_unlock_bh ( & net -> nsid_lock ) ; rcu_read_unlock ( ) ; return peer ; }
","<S2SV_ModStart> ( peer ) peer = maybe_get_net <S2SV_ModEnd> ( peer )
"
932,"CWE-369 static void setup_format_params ( int track ) { int n ; int il ; int count ; int head_shift ; int track_shift ; struct fparm { unsigned char track , head , sect , size ; } * here = ( struct fparm * ) floppy_track_buffer ; raw_cmd = & default_raw_cmd ; raw_cmd -> track = track ; raw_cmd -> flags = ( FD_RAW_WRITE | FD_RAW_INTR | FD_RAW_SPIN | FD_RAW_NEED_DISK | FD_RAW_NEED_SEEK ) ; raw_cmd -> rate = _floppy -> rate & 0x43 ; raw_cmd -> cmd_count = NR_F ; COMMAND = FM_MODE ( _floppy , FD_FORMAT ) ; DR_SELECT = UNIT ( current_drive ) + PH_HEAD ( _floppy , format_req . head ) ; F_SIZECODE = FD_SIZECODE ( _floppy ) ; F_SECT_PER_TRACK = _floppy -> sect << 2 >> F_SIZECODE ; F_GAP = _floppy -> fmt_gap ; F_FILL = FD_FILL_BYTE ; raw_cmd -> kernel_data = floppy_track_buffer ; raw_cmd -> length = 4 * F_SECT_PER_TRACK ; <S2SV_StartBug> head_shift = ( F_SECT_PER_TRACK + 5 ) / 6 ; <S2SV_EndBug> track_shift = 2 * head_shift + 3 ; n = ( track_shift * format_req . track + head_shift * format_req . head ) % F_SECT_PER_TRACK ; il = 1 ; if ( _floppy -> fmt_gap < 0x22 ) il ++ ; for ( count = 0 ; count < F_SECT_PER_TRACK ; ++ count ) { here [ count ] . track = format_req . track ; here [ count ] . head = format_req . head ; here [ count ] . sect = 0 ; here [ count ] . size = F_SIZECODE ; } for ( count = 1 ; count <= F_SECT_PER_TRACK ; ++ count ) { here [ n ] . sect = count ; n = ( n + il ) % F_SECT_PER_TRACK ; if ( here [ n ] . sect ) { ++ n ; if ( n >= F_SECT_PER_TRACK ) { n -= F_SECT_PER_TRACK ; while ( here [ n ] . sect ) ++ n ; } } } if ( _floppy -> stretch & FD_SECTBASEMASK ) { for ( count = 0 ; count < F_SECT_PER_TRACK ; count ++ ) here [ count ] . sect += FD_SECTBASE ( _floppy ) - 1 ; } }
","<S2SV_ModStart> * F_SECT_PER_TRACK ; if ( ! F_SECT_PER_TRACK ) return ;
"
933,"CWE-200 int imap_open_connection ( IMAP_DATA * idata ) { if ( mutt_socket_open ( idata -> conn ) < 0 ) return - 1 ; idata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( idata ) != IMAP_CMD_OK ) { imap_close_connection ( idata ) ; return - 1 ; } if ( ascii_strncasecmp ( ""*<S2SV_blank>OK"" , idata -> buf , 4 ) == 0 ) { if ( ascii_strncasecmp ( ""*<S2SV_blank>OK<S2SV_blank>[CAPABILITY"" , idata -> buf , 16 ) && imap_check_capabilities ( idata ) ) goto bail ; # if defined ( USE_SSL ) if ( ! idata -> conn -> ssf && ( option ( OPTSSLFORCETLS ) || mutt_bit_isset ( idata -> capabilities , STARTTLS ) ) ) { int rc ; if ( option ( OPTSSLFORCETLS ) ) rc = MUTT_YES ; else if ( ( rc = query_quadoption ( OPT_SSLSTARTTLS , _ ( ""Secure<S2SV_blank>connection<S2SV_blank>with<S2SV_blank>TLS?"" ) ) ) == - 1 ) goto err_close_conn ; if ( rc == MUTT_YES ) { if ( ( rc = imap_exec ( idata , ""STARTTLS"" , IMAP_CMD_FAIL_OK ) ) == - 1 ) goto bail ; if ( rc != - 2 ) { if ( mutt_ssl_starttls ( idata -> conn ) ) { mutt_error ( _ ( ""Could<S2SV_blank>not<S2SV_blank>negotiate<S2SV_blank>TLS<S2SV_blank>connection"" ) ) ; mutt_sleep ( 1 ) ; goto err_close_conn ; } else { if ( imap_exec ( idata , ""CAPABILITY"" , 0 ) ) goto bail ; } } } } if ( option ( OPTSSLFORCETLS ) && ! idata -> conn -> ssf ) { mutt_error _ ( ""Encrypted<S2SV_blank>connection<S2SV_blank>unavailable"" ) ; mutt_sleep ( 1 ) ; goto err_close_conn ; } # endif } else if ( ascii_strncasecmp ( ""*<S2SV_blank>PREAUTH"" , idata -> buf , 9 ) == 0 ) { <S2SV_StartBug> idata -> state = IMAP_AUTHENTICATED ; <S2SV_EndBug> if ( imap_check_capabilities ( idata ) != 0 ) goto bail ; FREE ( & idata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , idata -> buf ) ; goto bail ; } return 0 ; # if defined ( USE_SSL ) err_close_conn : imap_close_connection ( idata ) ; # endif bail : FREE ( & idata -> capstr ) ; return - 1 ; }
","<S2SV_ModStart> 0 ) { # if defined ( USE_SSL ) if ( ! idata -> conn -> ssf ) { if ( option ( OPTSSLFORCETLS ) || ( query_quadoption ( OPT_SSLSTARTTLS , _ ( ""Abort<S2SV_blank>unencrypted<S2SV_blank>PREAUTH<S2SV_blank>connection?"" ) ) != MUTT_NO ) ) { mutt_error _ ( ""Encrypted<S2SV_blank>connection<S2SV_blank>unavailable"" ) ; mutt_sleep ( 1 ) ; goto err_close_conn ; } } # endif
"
934,"CWE-399 int kvm_set_msr_common ( struct kvm_vcpu * vcpu , struct msr_data * msr_info ) { bool pr = false ; u32 msr = msr_info -> index ; u64 data = msr_info -> data ; switch ( msr ) { case MSR_AMD64_NB_CFG : case MSR_IA32_UCODE_REV : case MSR_IA32_UCODE_WRITE : case MSR_VM_HSAVE_PA : case MSR_AMD64_PATCH_LOADER : case MSR_AMD64_BU_CFG2 : break ; case MSR_EFER : return set_efer ( vcpu , data ) ; case MSR_K7_HWCR : data &= ~ ( u64 ) 0x40 ; data &= ~ ( u64 ) 0x100 ; data &= ~ ( u64 ) 0x8 ; if ( data != 0 ) { vcpu_unimpl ( vcpu , ""unimplemented<S2SV_blank>HWCR<S2SV_blank>wrmsr:<S2SV_blank>0x%llx\\n"" , data ) ; return 1 ; } break ; case MSR_FAM10H_MMIO_CONF_BASE : if ( data != 0 ) { vcpu_unimpl ( vcpu , ""unimplemented<S2SV_blank>MMIO_CONF_BASE<S2SV_blank>wrmsr:<S2SV_blank>"" ""0x%llx\\n"" , data ) ; return 1 ; } break ; case MSR_IA32_DEBUGCTLMSR : if ( ! data ) { break ; } else if ( data & ~ ( DEBUGCTLMSR_LBR | DEBUGCTLMSR_BTF ) ) { return 1 ; } vcpu_unimpl ( vcpu , ""%s:<S2SV_blank>MSR_IA32_DEBUGCTLMSR<S2SV_blank>0x%llx,<S2SV_blank>nop\\n"" , __func__ , data ) ; break ; case 0x200 ... 0x2ff : return set_msr_mtrr ( vcpu , msr , data ) ; case MSR_IA32_APICBASE : kvm_set_apic_base ( vcpu , data ) ; break ; case APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff : return kvm_x2apic_msr_write ( vcpu , msr , data ) ; case MSR_IA32_TSCDEADLINE : kvm_set_lapic_tscdeadline_msr ( vcpu , data ) ; break ; case MSR_IA32_TSC_ADJUST : if ( guest_cpuid_has_tsc_adjust ( vcpu ) ) { if ( ! msr_info -> host_initiated ) { u64 adj = data - vcpu -> arch . ia32_tsc_adjust_msr ; kvm_x86_ops -> adjust_tsc_offset ( vcpu , adj , true ) ; } vcpu -> arch . ia32_tsc_adjust_msr = data ; } break ; case MSR_IA32_MISC_ENABLE : vcpu -> arch . ia32_misc_enable_msr = data ; break ; case MSR_KVM_WALL_CLOCK_NEW : case MSR_KVM_WALL_CLOCK : vcpu -> kvm -> arch . wall_clock = data ; kvm_write_wall_clock ( vcpu -> kvm , data ) ; break ; case MSR_KVM_SYSTEM_TIME_NEW : case MSR_KVM_SYSTEM_TIME : { <S2SV_StartBug> kvmclock_reset ( vcpu ) ; <S2SV_EndBug> vcpu -> arch . time = data ; kvm_make_request ( KVM_REQ_CLOCK_UPDATE , vcpu ) ; if ( ! ( data & 1 ) ) break ; <S2SV_StartBug> vcpu -> arch . time_offset = data & ~ ( PAGE_MASK | 1 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vcpu -> arch . time_offset & <S2SV_EndBug> ( sizeof ( struct pvclock_vcpu_time_info ) - 1 ) ) break ; <S2SV_StartBug> vcpu -> arch . time_page = <S2SV_EndBug> <S2SV_StartBug> gfn_to_page ( vcpu -> kvm , data >> PAGE_SHIFT ) ; <S2SV_EndBug> if ( is_error_page ( vcpu -> arch . time_page ) ) vcpu -> arch . time_page = NULL ; break ; } case MSR_KVM_ASYNC_PF_EN : if ( kvm_pv_enable_async_pf ( vcpu , data ) ) return 1 ; break ; case MSR_KVM_STEAL_TIME : if ( unlikely ( ! sched_info_on ( ) ) ) return 1 ; if ( data & KVM_STEAL_RESERVED_MASK ) return 1 ; if ( kvm_gfn_to_hva_cache_init ( vcpu -> kvm , & vcpu -> arch . st . stime , data & KVM_STEAL_VALID_BITS ) ) return 1 ; vcpu -> arch . st . msr_val = data ; if ( ! ( data & KVM_MSR_ENABLED ) ) break ; vcpu -> arch . st . last_steal = current -> sched_info . run_delay ; preempt_disable ( ) ; accumulate_steal_time ( vcpu ) ; preempt_enable ( ) ; kvm_make_request ( KVM_REQ_STEAL_UPDATE , vcpu ) ; break ; case MSR_KVM_PV_EOI_EN : if ( kvm_lapic_enable_pv_eoi ( vcpu , data ) ) return 1 ; break ; case MSR_IA32_MCG_CTL : case MSR_IA32_MCG_STATUS : case MSR_IA32_MC0_CTL ... MSR_IA32_MC0_CTL + 4 * KVM_MAX_MCE_BANKS - 1 : return set_msr_mce ( vcpu , msr , data ) ; case MSR_K7_EVNTSEL0 : case MSR_K7_EVNTSEL1 : case MSR_K7_EVNTSEL2 : case MSR_K7_EVNTSEL3 : if ( data != 0 ) vcpu_unimpl ( vcpu , ""unimplemented<S2SV_blank>perfctr<S2SV_blank>wrmsr:<S2SV_blank>"" ""0x%x<S2SV_blank>data<S2SV_blank>0x%llx\\n"" , msr , data ) ; break ; case MSR_K7_PERFCTR0 : case MSR_K7_PERFCTR1 : case MSR_K7_PERFCTR2 : case MSR_K7_PERFCTR3 : vcpu_unimpl ( vcpu , ""unimplemented<S2SV_blank>perfctr<S2SV_blank>wrmsr:<S2SV_blank>"" ""0x%x<S2SV_blank>data<S2SV_blank>0x%llx\\n"" , msr , data ) ; break ; case MSR_P6_PERFCTR0 : case MSR_P6_PERFCTR1 : pr = true ; case MSR_P6_EVNTSEL0 : case MSR_P6_EVNTSEL1 : if ( kvm_pmu_msr ( vcpu , msr ) ) return kvm_pmu_set_msr ( vcpu , msr , data ) ; if ( pr || data != 0 ) vcpu_unimpl ( vcpu , ""disabled<S2SV_blank>perfctr<S2SV_blank>wrmsr:<S2SV_blank>"" ""0x%x<S2SV_blank>data<S2SV_blank>0x%llx\\n"" , msr , data ) ; break ; case MSR_K7_CLK_CTL : break ; case HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15 : if ( kvm_hv_msr_partition_wide ( msr ) ) { int r ; mutex_lock ( & vcpu -> kvm -> lock ) ; r = set_msr_hyperv_pw ( vcpu , msr , data ) ; mutex_unlock ( & vcpu -> kvm -> lock ) ; return r ; } else return set_msr_hyperv ( vcpu , msr , data ) ; break ; case MSR_IA32_BBL_CR_CTL3 : vcpu_unimpl ( vcpu , ""ignored<S2SV_blank>wrmsr:<S2SV_blank>0x%x<S2SV_blank>data<S2SV_blank>%llx\\n"" , msr , data ) ; break ; case MSR_AMD64_OSVW_ID_LENGTH : if ( ! guest_cpuid_has_osvw ( vcpu ) ) return 1 ; vcpu -> arch . osvw . length = data ; break ; case MSR_AMD64_OSVW_STATUS : if ( ! guest_cpuid_has_osvw ( vcpu ) ) return 1 ; vcpu -> arch . osvw . status = data ; break ; default : if ( msr && ( msr == vcpu -> kvm -> arch . xen_hvm_config . msr ) ) return xen_hvm_config ( vcpu , data ) ; if ( kvm_pmu_msr ( vcpu , msr ) ) return kvm_pmu_set_msr ( vcpu , msr , data ) ; if ( ! ignore_msrs ) { vcpu_unimpl ( vcpu , ""unhandled<S2SV_blank>wrmsr:<S2SV_blank>0x%x<S2SV_blank>data<S2SV_blank>%llx\\n"" , msr , data ) ; return 1 ; } else { vcpu_unimpl ( vcpu , ""ignored<S2SV_blank>wrmsr:<S2SV_blank>0x%x<S2SV_blank>data<S2SV_blank>%llx\\n"" , msr , data ) ; break ; } } return 0 ; }
","<S2SV_ModStart> MSR_KVM_SYSTEM_TIME : { u64 gpa_offset ; <S2SV_ModStart> ) break ; gpa_offset <S2SV_ModEnd> = data & <S2SV_ModStart> ; if ( gpa_offset <S2SV_ModEnd> & ( sizeof <S2SV_ModStart> ) break ; if ( kvm_gfn_to_hva_cache_init <S2SV_ModEnd> ( vcpu -> <S2SV_ModStart> -> kvm , & vcpu -> arch . pv_time , data & ~ 1ULL ) ) vcpu -> arch . pv_time_enabled = false ; else vcpu -> arch . pv_time_enabled = true <S2SV_ModEnd> ; break ;
"
935,"CWE-416 <S2SV_StartBug> int hns_nic_net_xmit_hw ( struct net_device * ndev , <S2SV_EndBug> struct sk_buff * skb , struct hns_nic_ring_data * ring_data ) { struct hns_nic_priv * priv = netdev_priv ( ndev ) ; struct hnae_ring * ring = ring_data -> ring ; struct device * dev = ring_to_dev ( ring ) ; struct netdev_queue * dev_queue ; struct skb_frag_struct * frag ; int buf_num ; int seg_num ; dma_addr_t dma ; int size , next_to_use ; int i ; switch ( priv -> ops . maybe_stop_tx ( & skb , & buf_num , ring ) ) { case - EBUSY : ring -> stats . tx_busy ++ ; goto out_net_tx_busy ; case - ENOMEM : ring -> stats . sw_err_cnt ++ ; netdev_err ( ndev , ""no<S2SV_blank>memory<S2SV_blank>to<S2SV_blank>xmit!\\n"" ) ; goto out_err_tx_ok ; default : break ; } seg_num = skb_shinfo ( skb ) -> nr_frags + 1 ; next_to_use = ring -> next_to_use ; size = skb_headlen ( skb ) ; dma = dma_map_single ( dev , skb -> data , size , DMA_TO_DEVICE ) ; if ( dma_mapping_error ( dev , dma ) ) { netdev_err ( ndev , ""TX<S2SV_blank>head<S2SV_blank>DMA<S2SV_blank>map<S2SV_blank>failed\\n"" ) ; ring -> stats . sw_err_cnt ++ ; goto out_err_tx_ok ; } priv -> ops . fill_desc ( ring , skb , size , dma , seg_num == 1 ? 1 : 0 , buf_num , DESC_TYPE_SKB , ndev -> mtu ) ; for ( i = 1 ; i < seg_num ; i ++ ) { frag = & skb_shinfo ( skb ) -> frags [ i - 1 ] ; size = skb_frag_size ( frag ) ; dma = skb_frag_dma_map ( dev , frag , 0 , size , DMA_TO_DEVICE ) ; if ( dma_mapping_error ( dev , dma ) ) { netdev_err ( ndev , ""TX<S2SV_blank>frag(%d)<S2SV_blank>DMA<S2SV_blank>map<S2SV_blank>failed\\n"" , i ) ; ring -> stats . sw_err_cnt ++ ; goto out_map_frag_fail ; } priv -> ops . fill_desc ( ring , skb_frag_page ( frag ) , size , dma , seg_num - 1 == i ? 1 : 0 , buf_num , DESC_TYPE_PAGE , ndev -> mtu ) ; } dev_queue = netdev_get_tx_queue ( ndev , skb -> queue_mapping ) ; netdev_tx_sent_queue ( dev_queue , skb -> len ) ; <S2SV_StartBug> wmb ( ) ; <S2SV_EndBug> assert ( skb -> queue_mapping < priv -> ae_handle -> q_num ) ; hnae_queue_xmit ( priv -> ae_handle -> qs [ skb -> queue_mapping ] , buf_num ) ; ring -> stats . tx_pkts ++ ; ring -> stats . tx_bytes += skb -> len ; return NETDEV_TX_OK ; out_map_frag_fail : while ( ring -> next_to_use != next_to_use ) { unfill_desc ( ring ) ; if ( ring -> next_to_use != next_to_use ) dma_unmap_page ( dev , ring -> desc_cb [ ring -> next_to_use ] . dma , ring -> desc_cb [ ring -> next_to_use ] . length , DMA_TO_DEVICE ) ; else dma_unmap_single ( dev , ring -> desc_cb [ next_to_use ] . dma , ring -> desc_cb [ next_to_use ] . length , DMA_TO_DEVICE ) ; } out_err_tx_ok : dev_kfree_skb_any ( skb ) ; return NETDEV_TX_OK ; out_net_tx_busy : netif_stop_subqueue ( ndev , skb -> queue_mapping ) ; smp_mb ( ) ; return NETDEV_TX_BUSY ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> netdev_tx_t <S2SV_ModEnd> hns_nic_net_xmit_hw ( struct <S2SV_ModStart> len ) ; netif_trans_update ( ndev ) ; ndev -> stats . tx_bytes += skb -> len ; ndev -> stats . tx_packets ++ ;
"
936,"CWE-119 enum ImapAuthRes imap_auth_gss ( struct ImapData * idata , const char * method ) { gss_buffer_desc request_buf , send_token ; gss_buffer_t sec_token ; gss_name_t target_name ; gss_ctx_id_t context ; gss_OID mech_name ; char server_conf_flags ; gss_qop_t quality ; int cflags ; OM_uint32 maj_stat , min_stat ; char buf1 [ GSS_BUFSIZE ] , buf2 [ GSS_BUFSIZE ] ; unsigned long buf_size ; int rc ; if ( ! mutt_bit_isset ( idata -> capabilities , AGSSAPI ) ) return IMAP_AUTH_UNAVAIL ; if ( mutt_account_getuser ( & idata -> conn -> account ) < 0 ) return IMAP_AUTH_FAILURE ; snprintf ( buf1 , sizeof ( buf1 ) , ""imap@%s"" , idata -> conn -> account . host ) ; request_buf . value = buf1 ; request_buf . length = strlen ( buf1 ) ; maj_stat = gss_import_name ( & min_stat , & request_buf , gss_nt_service_name , & target_name ) ; if ( maj_stat != GSS_S_COMPLETE ) { mutt_debug ( 2 , ""Couldn\'t<S2SV_blank>get<S2SV_blank>service<S2SV_blank>name<S2SV_blank>for<S2SV_blank>[%s]\\n"" , buf1 ) ; return IMAP_AUTH_UNAVAIL ; } else if ( DebugLevel >= 2 ) { gss_display_name ( & min_stat , target_name , & request_buf , & mech_name ) ; mutt_debug ( 2 , ""Using<S2SV_blank>service<S2SV_blank>name<S2SV_blank>[%s]\\n"" , ( char * ) request_buf . value ) ; gss_release_buffer ( & min_stat , & request_buf ) ; } sec_token = GSS_C_NO_BUFFER ; context = GSS_C_NO_CONTEXT ; maj_stat = gss_init_sec_context ( & min_stat , GSS_C_NO_CREDENTIAL , & context , target_name , GSS_C_NO_OID , GSS_C_MUTUAL_FLAG | GSS_C_SEQUENCE_FLAG , 0 , GSS_C_NO_CHANNEL_BINDINGS , sec_token , NULL , & send_token , ( unsigned int * ) & cflags , NULL ) ; if ( maj_stat != GSS_S_COMPLETE && maj_stat != GSS_S_CONTINUE_NEEDED ) { print_gss_error ( maj_stat , min_stat ) ; mutt_debug ( 1 , ""Error<S2SV_blank>acquiring<S2SV_blank>credentials<S2SV_blank>-<S2SV_blank>no<S2SV_blank>TGT?\\n"" ) ; gss_release_name ( & min_stat , & target_name ) ; return IMAP_AUTH_UNAVAIL ; } mutt_message ( _ ( ""Authenticating<S2SV_blank>(GSSAPI)..."" ) ) ; imap_cmd_start ( idata , ""AUTHENTICATE<S2SV_blank>GSSAPI"" ) ; do rc = imap_cmd_step ( idata ) ; while ( rc == IMAP_CMD_CONTINUE ) ; if ( rc != IMAP_CMD_RESPOND ) { mutt_debug ( 2 , ""Invalid<S2SV_blank>response<S2SV_blank>from<S2SV_blank>server:<S2SV_blank>%s\\n"" , buf1 ) ; gss_release_name ( & min_stat , & target_name ) ; goto bail ; } mutt_debug ( 2 , ""Sending<S2SV_blank>credentials\\n"" ) ; mutt_b64_encode ( buf1 , send_token . value , send_token . length , sizeof ( buf1 ) - 2 ) ; gss_release_buffer ( & min_stat , & send_token ) ; mutt_str_strcat ( buf1 , sizeof ( buf1 ) , ""\\r\\n"" ) ; mutt_socket_send ( idata -> conn , buf1 ) ; while ( maj_stat == GSS_S_CONTINUE_NEEDED ) { do rc = imap_cmd_step ( idata ) ; while ( rc == IMAP_CMD_CONTINUE ) ; if ( rc != IMAP_CMD_RESPOND ) { mutt_debug ( 1 , ""#1<S2SV_blank>Error<S2SV_blank>receiving<S2SV_blank>server<S2SV_blank>response.\\n"" ) ; gss_release_name ( & min_stat , & target_name ) ; goto bail ; } <S2SV_StartBug> request_buf . length = mutt_b64_decode ( buf2 , idata -> buf + 2 ) ; <S2SV_EndBug> request_buf . value = buf2 ; sec_token = & request_buf ; maj_stat = gss_init_sec_context ( & min_stat , GSS_C_NO_CREDENTIAL , & context , target_name , GSS_C_NO_OID , GSS_C_MUTUAL_FLAG | GSS_C_SEQUENCE_FLAG , 0 , GSS_C_NO_CHANNEL_BINDINGS , sec_token , NULL , & send_token , ( unsigned int * ) & cflags , NULL ) ; if ( maj_stat != GSS_S_COMPLETE && maj_stat != GSS_S_CONTINUE_NEEDED ) { print_gss_error ( maj_stat , min_stat ) ; mutt_debug ( 1 , ""Error<S2SV_blank>exchanging<S2SV_blank>credentials\\n"" ) ; gss_release_name ( & min_stat , & target_name ) ; goto err_abort_cmd ; } mutt_b64_encode ( buf1 , send_token . value , send_token . length , sizeof ( buf1 ) - 2 ) ; gss_release_buffer ( & min_stat , & send_token ) ; mutt_str_strcat ( buf1 , sizeof ( buf1 ) , ""\\r\\n"" ) ; mutt_socket_send ( idata -> conn , buf1 ) ; } gss_release_name ( & min_stat , & target_name ) ; do rc = imap_cmd_step ( idata ) ; while ( rc == IMAP_CMD_CONTINUE ) ; if ( rc != IMAP_CMD_RESPOND ) { mutt_debug ( 1 , ""#2<S2SV_blank>Error<S2SV_blank>receiving<S2SV_blank>server<S2SV_blank>response.\\n"" ) ; goto bail ; } <S2SV_StartBug> request_buf . length = mutt_b64_decode ( buf2 , idata -> buf + 2 ) ; <S2SV_EndBug> request_buf . value = buf2 ; maj_stat = gss_unwrap ( & min_stat , context , & request_buf , & send_token , & cflags , & quality ) ; if ( maj_stat != GSS_S_COMPLETE ) { print_gss_error ( maj_stat , min_stat ) ; mutt_debug ( 2 , ""Couldn\'t<S2SV_blank>unwrap<S2SV_blank>security<S2SV_blank>level<S2SV_blank>data\\n"" ) ; gss_release_buffer ( & min_stat , & send_token ) ; goto err_abort_cmd ; } mutt_debug ( 2 , ""Credential<S2SV_blank>exchange<S2SV_blank>complete\\n"" ) ; server_conf_flags = ( ( char * ) send_token . value ) [ 0 ] ; if ( ! ( ( ( char * ) send_token . value ) [ 0 ] & GSS_AUTH_P_NONE ) ) { mutt_debug ( 2 , ""Server<S2SV_blank>requires<S2SV_blank>integrity<S2SV_blank>or<S2SV_blank>privacy\\n"" ) ; gss_release_buffer ( & min_stat , & send_token ) ; goto err_abort_cmd ; } ( ( char * ) send_token . value ) [ 0 ] = '\\0' ; buf_size = ntohl ( * ( ( long * ) send_token . value ) ) ; gss_release_buffer ( & min_stat , & send_token ) ; mutt_debug ( 2 , ""Unwrapped<S2SV_blank>security<S2SV_blank>level<S2SV_blank>flags:<S2SV_blank>%c%c%c\\n"" , ( server_conf_flags & GSS_AUTH_P_NONE ) ? 'N' : '-' , ( server_conf_flags & GSS_AUTH_P_INTEGRITY ) ? 'I' : '-' , ( server_conf_flags & GSS_AUTH_P_PRIVACY ) ? 'P' : '-' ) ; mutt_debug ( 2 , ""Maximum<S2SV_blank>GSS<S2SV_blank>token<S2SV_blank>size<S2SV_blank>is<S2SV_blank>%ld\\n"" , buf_size ) ; buf_size = htonl ( buf_size ) ; memcpy ( buf1 , & buf_size , 4 ) ; buf1 [ 0 ] = GSS_AUTH_P_NONE ; strncpy ( buf1 + 4 , idata -> conn -> account . user , sizeof ( buf1 ) - 4 ) ; request_buf . value = buf1 ; request_buf . length = 4 + strlen ( idata -> conn -> account . user ) ; maj_stat = gss_wrap ( & min_stat , context , 0 , GSS_C_QOP_DEFAULT , & request_buf , & cflags , & send_token ) ; if ( maj_stat != GSS_S_COMPLETE ) { mutt_debug ( 2 , ""Error<S2SV_blank>creating<S2SV_blank>login<S2SV_blank>request\\n"" ) ; goto err_abort_cmd ; } mutt_b64_encode ( buf1 , send_token . value , send_token . length , sizeof ( buf1 ) - 2 ) ; mutt_debug ( 2 , ""Requesting<S2SV_blank>authorisation<S2SV_blank>as<S2SV_blank>%s\\n"" , idata -> conn -> account . user ) ; mutt_str_strcat ( buf1 , sizeof ( buf1 ) , ""\\r\\n"" ) ; mutt_socket_send ( idata -> conn , buf1 ) ; do rc = imap_cmd_step ( idata ) ; while ( rc == IMAP_CMD_CONTINUE ) ; if ( rc == IMAP_CMD_RESPOND ) { mutt_debug ( 1 , ""Unexpected<S2SV_blank>server<S2SV_blank>continuation<S2SV_blank>request.\\n"" ) ; goto err_abort_cmd ; } if ( imap_code ( idata -> buf ) ) { mutt_debug ( 2 , ""Releasing<S2SV_blank>GSS<S2SV_blank>credentials\\n"" ) ; maj_stat = gss_delete_sec_context ( & min_stat , & context , & send_token ) ; if ( maj_stat != GSS_S_COMPLETE ) mutt_debug ( 1 , ""Error<S2SV_blank>releasing<S2SV_blank>credentials\\n"" ) ; gss_release_buffer ( & min_stat , & send_token ) ; return IMAP_AUTH_SUCCESS ; } else goto bail ; err_abort_cmd : mutt_socket_send ( idata -> conn , ""*\\r\\n"" ) ; do rc = imap_cmd_step ( idata ) ; while ( rc == IMAP_CMD_CONTINUE ) ; bail : mutt_error ( _ ( ""GSSAPI<S2SV_blank>authentication<S2SV_blank>failed."" ) ) ; return IMAP_AUTH_FAILURE ; }
","<S2SV_ModStart> buf + 2 , sizeof ( buf2 ) <S2SV_ModStart> buf + 2 , sizeof ( buf2 )
"
937,"CWE-190 static int do_timer_create ( clockid_t which_clock , struct sigevent * event , timer_t __user * created_timer_id ) { const struct k_clock * kc = clockid_to_kclock ( which_clock ) ; struct k_itimer * new_timer ; int error , new_timer_id ; int it_id_set = IT_ID_NOT_SET ; if ( ! kc ) return - EINVAL ; if ( ! kc -> timer_create ) return - EOPNOTSUPP ; new_timer = alloc_posix_timer ( ) ; if ( unlikely ( ! new_timer ) ) return - EAGAIN ; spin_lock_init ( & new_timer -> it_lock ) ; new_timer_id = posix_timer_add ( new_timer ) ; if ( new_timer_id < 0 ) { error = new_timer_id ; goto out ; } it_id_set = IT_ID_SET ; new_timer -> it_id = ( timer_t ) new_timer_id ; new_timer -> it_clock = which_clock ; new_timer -> kclock = kc ; <S2SV_StartBug> new_timer -> it_overrun = - 1 ; <S2SV_EndBug> if ( event ) { rcu_read_lock ( ) ; new_timer -> it_pid = get_pid ( good_sigevent ( event ) ) ; rcu_read_unlock ( ) ; if ( ! new_timer -> it_pid ) { error = - EINVAL ; goto out ; } new_timer -> it_sigev_notify = event -> sigev_notify ; new_timer -> sigq -> info . si_signo = event -> sigev_signo ; new_timer -> sigq -> info . si_value = event -> sigev_value ; } else { new_timer -> it_sigev_notify = SIGEV_SIGNAL ; new_timer -> sigq -> info . si_signo = SIGALRM ; memset ( & new_timer -> sigq -> info . si_value , 0 , sizeof ( sigval_t ) ) ; new_timer -> sigq -> info . si_value . sival_int = new_timer -> it_id ; new_timer -> it_pid = get_pid ( task_tgid ( current ) ) ; } new_timer -> sigq -> info . si_tid = new_timer -> it_id ; new_timer -> sigq -> info . si_code = SI_TIMER ; if ( copy_to_user ( created_timer_id , & new_timer_id , sizeof ( new_timer_id ) ) ) { error = - EFAULT ; goto out ; } error = kc -> timer_create ( new_timer ) ; if ( error ) goto out ; spin_lock_irq ( & current -> sighand -> siglock ) ; new_timer -> it_signal = current -> signal ; list_add ( & new_timer -> list , & current -> signal -> posix_timers ) ; spin_unlock_irq ( & current -> sighand -> siglock ) ; return 0 ; out : release_posix_timer ( new_timer , it_id_set ) ; return error ; }
","<S2SV_ModStart> it_overrun = - 1LL <S2SV_ModEnd> ; if (
"
938,"CWE-125 <S2SV_StartBug> static void read_quant_matrix_ext ( MpegEncContext * s , GetBitContext * gb ) <S2SV_EndBug> { int i , j , v ; <S2SV_StartBug> if ( get_bits1 ( gb ) ) { <S2SV_EndBug> for ( i = 0 ; i < 64 ; i ++ ) { v = get_bits ( gb , 8 ) ; j = s -> idsp . idct_permutation [ ff_zigzag_direct [ i ] ] ; s -> intra_matrix [ j ] = v ; s -> chroma_intra_matrix [ j ] = v ; } } if ( get_bits1 ( gb ) ) { <S2SV_StartBug> for ( i = 0 ; i < 64 ; i ++ ) { <S2SV_EndBug> get_bits ( gb , 8 ) ; } } <S2SV_StartBug> if ( get_bits1 ( gb ) ) { <S2SV_EndBug> for ( i = 0 ; i < 64 ; i ++ ) { v = get_bits ( gb , 8 ) ; j = s -> idsp . idct_permutation [ ff_zigzag_direct [ i ] ] ; s -> chroma_intra_matrix [ j ] = v ; } } if ( get_bits1 ( gb ) ) { <S2SV_StartBug> for ( i = 0 ; i < 64 ; i ++ ) { <S2SV_EndBug> get_bits ( gb , 8 ) ; } } next_start_code_studio ( gb ) ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> read_quant_matrix_ext ( MpegEncContext <S2SV_ModStart> ) ) { if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> ) ) { if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> ) ) { if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> ) ) { if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> gb ) ; return 0 ;
"
939,"CWE-416 static int do_ipv6_setsockopt ( struct sock * sk , int level , int optname , char __user * optval , unsigned int optlen ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct net * net = sock_net ( sk ) ; int val , valbool ; int retv = - ENOPROTOOPT ; bool needs_rtnl = setsockopt_needs_rtnl ( optname ) ; if ( ! optval ) val = 0 ; else { if ( optlen >= sizeof ( int ) ) { if ( get_user ( val , ( int __user * ) optval ) ) return - EFAULT ; } else val = 0 ; } valbool = ( val != 0 ) ; if ( ip6_mroute_opt ( optname ) ) return ip6_mroute_setsockopt ( sk , optname , optval , optlen ) ; if ( needs_rtnl ) rtnl_lock ( ) ; lock_sock ( sk ) ; switch ( optname ) { case IPV6_ADDRFORM : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val == PF_INET ) { struct ipv6_txoptions * opt ; struct sk_buff * pktopt ; if ( sk -> sk_type == SOCK_RAW ) break ; if ( sk -> sk_protocol == IPPROTO_UDP || sk -> sk_protocol == IPPROTO_UDPLITE ) { struct udp_sock * up = udp_sk ( sk ) ; if ( up -> pending == AF_INET6 ) { retv = - EBUSY ; break ; } } else if ( sk -> sk_protocol != IPPROTO_TCP ) break ; if ( sk -> sk_state != TCP_ESTABLISHED ) { retv = - ENOTCONN ; break ; } if ( ipv6_only_sock ( sk ) || ! ipv6_addr_v4mapped ( & sk -> sk_v6_daddr ) ) { retv = - EADDRNOTAVAIL ; break ; } fl6_free_socklist ( sk ) ; ipv6_sock_mc_close ( sk ) ; sk_refcnt_debug_dec ( sk ) ; if ( sk -> sk_protocol == IPPROTO_TCP ) { struct inet_connection_sock * icsk = inet_csk ( sk ) ; local_bh_disable ( ) ; sock_prot_inuse_add ( net , sk -> sk_prot , - 1 ) ; sock_prot_inuse_add ( net , & tcp_prot , 1 ) ; local_bh_enable ( ) ; sk -> sk_prot = & tcp_prot ; icsk -> icsk_af_ops = & ipv4_specific ; sk -> sk_socket -> ops = & inet_stream_ops ; sk -> sk_family = PF_INET ; tcp_sync_mss ( sk , icsk -> icsk_pmtu_cookie ) ; } else { struct proto * prot = & udp_prot ; if ( sk -> sk_protocol == IPPROTO_UDPLITE ) prot = & udplite_prot ; local_bh_disable ( ) ; sock_prot_inuse_add ( net , sk -> sk_prot , - 1 ) ; sock_prot_inuse_add ( net , prot , 1 ) ; local_bh_enable ( ) ; sk -> sk_prot = prot ; sk -> sk_socket -> ops = & inet_dgram_ops ; sk -> sk_family = PF_INET ; } <S2SV_StartBug> opt = xchg ( & np -> opt , NULL ) ; <S2SV_EndBug> if ( opt ) <S2SV_StartBug> sock_kfree_s ( sk , opt , opt -> tot_len ) ; <S2SV_EndBug> pktopt = xchg ( & np -> pktoptions , NULL ) ; kfree_skb ( pktopt ) ; sk -> sk_destruct = inet_sock_destruct ; sk_refcnt_debug_inc ( sk ) ; module_put ( THIS_MODULE ) ; retv = 0 ; break ; } goto e_inval ; case IPV6_V6ONLY : if ( optlen < sizeof ( int ) || inet_sk ( sk ) -> inet_num ) goto e_inval ; sk -> sk_ipv6only = valbool ; retv = 0 ; break ; case IPV6_RECVPKTINFO : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxinfo = valbool ; retv = 0 ; break ; case IPV6_2292PKTINFO : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxoinfo = valbool ; retv = 0 ; break ; case IPV6_RECVHOPLIMIT : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxhlim = valbool ; retv = 0 ; break ; case IPV6_2292HOPLIMIT : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxohlim = valbool ; retv = 0 ; break ; case IPV6_RECVRTHDR : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . srcrt = valbool ; retv = 0 ; break ; case IPV6_2292RTHDR : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . osrcrt = valbool ; retv = 0 ; break ; case IPV6_RECVHOPOPTS : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . hopopts = valbool ; retv = 0 ; break ; case IPV6_2292HOPOPTS : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . ohopopts = valbool ; retv = 0 ; break ; case IPV6_RECVDSTOPTS : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . dstopts = valbool ; retv = 0 ; break ; case IPV6_2292DSTOPTS : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . odstopts = valbool ; retv = 0 ; break ; case IPV6_TCLASS : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val < - 1 || val > 0xff ) goto e_inval ; if ( val == - 1 ) val = 0 ; np -> tclass = val ; retv = 0 ; break ; case IPV6_RECVTCLASS : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxtclass = valbool ; retv = 0 ; break ; case IPV6_FLOWINFO : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxflow = valbool ; retv = 0 ; break ; case IPV6_RECVPATHMTU : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxpmtu = valbool ; retv = 0 ; break ; case IPV6_TRANSPARENT : if ( valbool && ! ns_capable ( net -> user_ns , CAP_NET_ADMIN ) && ! ns_capable ( net -> user_ns , CAP_NET_RAW ) ) { retv = - EPERM ; break ; } if ( optlen < sizeof ( int ) ) goto e_inval ; inet_sk ( sk ) -> transparent = valbool ; retv = 0 ; break ; case IPV6_RECVORIGDSTADDR : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxorigdstaddr = valbool ; retv = 0 ; break ; case IPV6_HOPOPTS : case IPV6_RTHDRDSTOPTS : case IPV6_RTHDR : case IPV6_DSTOPTS : { struct ipv6_txoptions * opt ; if ( optlen == 0 ) optval = NULL ; else if ( ! optval ) goto e_inval ; else if ( optlen < sizeof ( struct ipv6_opt_hdr ) || optlen & 0x7 || optlen > 8 * 255 ) goto e_inval ; retv = - EPERM ; if ( optname != IPV6_RTHDR && ! ns_capable ( net -> user_ns , CAP_NET_RAW ) ) break ; <S2SV_StartBug> opt = ipv6_renew_options ( sk , np -> opt , optname , <S2SV_EndBug> ( struct ipv6_opt_hdr __user * ) optval , optlen ) ; if ( IS_ERR ( opt ) ) { retv = PTR_ERR ( opt ) ; break ; } retv = - EINVAL ; if ( optname == IPV6_RTHDR && opt && opt -> srcrt ) { struct ipv6_rt_hdr * rthdr = opt -> srcrt ; switch ( rthdr -> type ) { # if IS_ENABLED ( CONFIG_IPV6_MIP6 ) case IPV6_SRCRT_TYPE_2 : if ( rthdr -> hdrlen != 2 || rthdr -> segments_left != 1 ) goto sticky_done ; break ; # endif default : goto sticky_done ; } } retv = 0 ; opt = ipv6_update_options ( sk , opt ) ; sticky_done : if ( opt ) <S2SV_StartBug> sock_kfree_s ( sk , opt , opt -> tot_len ) ; <S2SV_EndBug> break ; } case IPV6_PKTINFO : { struct in6_pktinfo pkt ; if ( optlen == 0 ) goto e_inval ; else if ( optlen < sizeof ( struct in6_pktinfo ) || ! optval ) goto e_inval ; if ( copy_from_user ( & pkt , optval , sizeof ( struct in6_pktinfo ) ) ) { retv = - EFAULT ; break ; } if ( sk -> sk_bound_dev_if && pkt . ipi6_ifindex != sk -> sk_bound_dev_if ) goto e_inval ; np -> sticky_pktinfo . ipi6_ifindex = pkt . ipi6_ifindex ; np -> sticky_pktinfo . ipi6_addr = pkt . ipi6_addr ; retv = 0 ; break ; } case IPV6_2292PKTOPTIONS : { struct ipv6_txoptions * opt = NULL ; struct msghdr msg ; struct flowi6 fl6 ; int junk ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; if ( optlen == 0 ) goto update ; retv = - EINVAL ; if ( optlen > 64 * 1024 ) break ; opt = sock_kmalloc ( sk , sizeof ( * opt ) + optlen , GFP_KERNEL ) ; retv = - ENOBUFS ; if ( ! opt ) break ; memset ( opt , 0 , sizeof ( * opt ) ) ; <S2SV_StartBug> opt -> tot_len = sizeof ( * opt ) + optlen ; <S2SV_EndBug> retv = - EFAULT ; if ( copy_from_user ( opt + 1 , optval , optlen ) ) goto done ; msg . msg_controllen = optlen ; msg . msg_control = ( void * ) ( opt + 1 ) ; retv = ip6_datagram_send_ctl ( net , sk , & msg , & fl6 , opt , & junk , & junk , & junk ) ; if ( retv ) goto done ; update : retv = 0 ; opt = ipv6_update_options ( sk , opt ) ; done : if ( opt ) <S2SV_StartBug> sock_kfree_s ( sk , opt , opt -> tot_len ) ; <S2SV_EndBug> break ; } case IPV6_UNICAST_HOPS : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val > 255 || val < - 1 ) goto e_inval ; np -> hop_limit = val ; retv = 0 ; break ; case IPV6_MULTICAST_HOPS : if ( sk -> sk_type == SOCK_STREAM ) break ; if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val > 255 || val < - 1 ) goto e_inval ; np -> mcast_hops = ( val == - 1 ? IPV6_DEFAULT_MCASTHOPS : val ) ; retv = 0 ; break ; case IPV6_MULTICAST_LOOP : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val != valbool ) goto e_inval ; np -> mc_loop = valbool ; retv = 0 ; break ; case IPV6_UNICAST_IF : { struct net_device * dev = NULL ; int ifindex ; if ( optlen != sizeof ( int ) ) goto e_inval ; ifindex = ( __force int ) ntohl ( ( __force __be32 ) val ) ; if ( ifindex == 0 ) { np -> ucast_oif = 0 ; retv = 0 ; break ; } dev = dev_get_by_index ( net , ifindex ) ; retv = - EADDRNOTAVAIL ; if ( ! dev ) break ; dev_put ( dev ) ; retv = - EINVAL ; if ( sk -> sk_bound_dev_if ) break ; np -> ucast_oif = ifindex ; retv = 0 ; break ; } case IPV6_MULTICAST_IF : if ( sk -> sk_type == SOCK_STREAM ) break ; if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val ) { struct net_device * dev ; if ( sk -> sk_bound_dev_if && sk -> sk_bound_dev_if != val ) goto e_inval ; dev = dev_get_by_index ( net , val ) ; if ( ! dev ) { retv = - ENODEV ; break ; } dev_put ( dev ) ; } np -> mcast_oif = val ; retv = 0 ; break ; case IPV6_ADD_MEMBERSHIP : case IPV6_DROP_MEMBERSHIP : { struct ipv6_mreq mreq ; if ( optlen < sizeof ( struct ipv6_mreq ) ) goto e_inval ; retv = - EPROTO ; if ( inet_sk ( sk ) -> is_icsk ) break ; retv = - EFAULT ; if ( copy_from_user ( & mreq , optval , sizeof ( struct ipv6_mreq ) ) ) break ; if ( optname == IPV6_ADD_MEMBERSHIP ) retv = ipv6_sock_mc_join ( sk , mreq . ipv6mr_ifindex , & mreq . ipv6mr_multiaddr ) ; else retv = ipv6_sock_mc_drop ( sk , mreq . ipv6mr_ifindex , & mreq . ipv6mr_multiaddr ) ; break ; } case IPV6_JOIN_ANYCAST : case IPV6_LEAVE_ANYCAST : { struct ipv6_mreq mreq ; if ( optlen < sizeof ( struct ipv6_mreq ) ) goto e_inval ; retv = - EFAULT ; if ( copy_from_user ( & mreq , optval , sizeof ( struct ipv6_mreq ) ) ) break ; if ( optname == IPV6_JOIN_ANYCAST ) retv = ipv6_sock_ac_join ( sk , mreq . ipv6mr_ifindex , & mreq . ipv6mr_acaddr ) ; else retv = ipv6_sock_ac_drop ( sk , mreq . ipv6mr_ifindex , & mreq . ipv6mr_acaddr ) ; break ; } case MCAST_JOIN_GROUP : case MCAST_LEAVE_GROUP : { struct group_req greq ; struct sockaddr_in6 * psin6 ; if ( optlen < sizeof ( struct group_req ) ) goto e_inval ; retv = - EFAULT ; if ( copy_from_user ( & greq , optval , sizeof ( struct group_req ) ) ) break ; if ( greq . gr_group . ss_family != AF_INET6 ) { retv = - EADDRNOTAVAIL ; break ; } psin6 = ( struct sockaddr_in6 * ) & greq . gr_group ; if ( optname == MCAST_JOIN_GROUP ) retv = ipv6_sock_mc_join ( sk , greq . gr_interface , & psin6 -> sin6_addr ) ; else retv = ipv6_sock_mc_drop ( sk , greq . gr_interface , & psin6 -> sin6_addr ) ; break ; } case MCAST_JOIN_SOURCE_GROUP : case MCAST_LEAVE_SOURCE_GROUP : case MCAST_BLOCK_SOURCE : case MCAST_UNBLOCK_SOURCE : { struct group_source_req greqs ; int omode , add ; if ( optlen < sizeof ( struct group_source_req ) ) goto e_inval ; if ( copy_from_user ( & greqs , optval , sizeof ( greqs ) ) ) { retv = - EFAULT ; break ; } if ( greqs . gsr_group . ss_family != AF_INET6 || greqs . gsr_source . ss_family != AF_INET6 ) { retv = - EADDRNOTAVAIL ; break ; } if ( optname == MCAST_BLOCK_SOURCE ) { omode = MCAST_EXCLUDE ; add = 1 ; } else if ( optname == MCAST_UNBLOCK_SOURCE ) { omode = MCAST_EXCLUDE ; add = 0 ; } else if ( optname == MCAST_JOIN_SOURCE_GROUP ) { struct sockaddr_in6 * psin6 ; psin6 = ( struct sockaddr_in6 * ) & greqs . gsr_group ; retv = ipv6_sock_mc_join ( sk , greqs . gsr_interface , & psin6 -> sin6_addr ) ; if ( retv && retv != - EADDRINUSE ) break ; omode = MCAST_INCLUDE ; add = 1 ; } else { omode = MCAST_INCLUDE ; add = 0 ; } retv = ip6_mc_source ( add , omode , sk , & greqs ) ; break ; } case MCAST_MSFILTER : { struct group_filter * gsf ; if ( optlen < GROUP_FILTER_SIZE ( 0 ) ) goto e_inval ; if ( optlen > sysctl_optmem_max ) { retv = - ENOBUFS ; break ; } gsf = kmalloc ( optlen , GFP_KERNEL ) ; if ( ! gsf ) { retv = - ENOBUFS ; break ; } retv = - EFAULT ; if ( copy_from_user ( gsf , optval , optlen ) ) { kfree ( gsf ) ; break ; } if ( gsf -> gf_numsrc >= 0x1ffffffU || gsf -> gf_numsrc > sysctl_mld_max_msf ) { kfree ( gsf ) ; retv = - ENOBUFS ; break ; } if ( GROUP_FILTER_SIZE ( gsf -> gf_numsrc ) > optlen ) { kfree ( gsf ) ; retv = - EINVAL ; break ; } retv = ip6_mc_msfilter ( sk , gsf ) ; kfree ( gsf ) ; break ; } case IPV6_ROUTER_ALERT : if ( optlen < sizeof ( int ) ) goto e_inval ; retv = ip6_ra_control ( sk , val ) ; break ; case IPV6_MTU_DISCOVER : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val < IPV6_PMTUDISC_DONT || val > IPV6_PMTUDISC_OMIT ) goto e_inval ; np -> pmtudisc = val ; retv = 0 ; break ; case IPV6_MTU : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val && val < IPV6_MIN_MTU ) goto e_inval ; np -> frag_size = val ; retv = 0 ; break ; case IPV6_RECVERR : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> recverr = valbool ; if ( ! val ) skb_queue_purge ( & sk -> sk_error_queue ) ; retv = 0 ; break ; case IPV6_FLOWINFO_SEND : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> sndflow = valbool ; retv = 0 ; break ; case IPV6_FLOWLABEL_MGR : retv = ipv6_flowlabel_opt ( sk , optval , optlen ) ; break ; case IPV6_IPSEC_POLICY : case IPV6_XFRM_POLICY : retv = - EPERM ; if ( ! ns_capable ( net -> user_ns , CAP_NET_ADMIN ) ) break ; retv = xfrm_user_policy ( sk , optname , optval , optlen ) ; break ; case IPV6_ADDR_PREFERENCES : { unsigned int pref = 0 ; unsigned int prefmask = ~ 0 ; if ( optlen < sizeof ( int ) ) goto e_inval ; retv = - EINVAL ; switch ( val & ( IPV6_PREFER_SRC_PUBLIC | IPV6_PREFER_SRC_TMP | IPV6_PREFER_SRC_PUBTMP_DEFAULT ) ) { case IPV6_PREFER_SRC_PUBLIC : pref |= IPV6_PREFER_SRC_PUBLIC ; break ; case IPV6_PREFER_SRC_TMP : pref |= IPV6_PREFER_SRC_TMP ; break ; case IPV6_PREFER_SRC_PUBTMP_DEFAULT : break ; case 0 : goto pref_skip_pubtmp ; default : goto e_inval ; } prefmask &= ~ ( IPV6_PREFER_SRC_PUBLIC | IPV6_PREFER_SRC_TMP ) ; pref_skip_pubtmp : switch ( val & ( IPV6_PREFER_SRC_HOME | IPV6_PREFER_SRC_COA ) ) { case IPV6_PREFER_SRC_HOME : break ; case IPV6_PREFER_SRC_COA : pref |= IPV6_PREFER_SRC_COA ; case 0 : goto pref_skip_coa ; default : goto e_inval ; } prefmask &= ~ IPV6_PREFER_SRC_COA ; pref_skip_coa : switch ( val & ( IPV6_PREFER_SRC_CGA | IPV6_PREFER_SRC_NONCGA ) ) { case IPV6_PREFER_SRC_CGA : case IPV6_PREFER_SRC_NONCGA : case 0 : break ; default : goto e_inval ; } np -> srcprefs = ( np -> srcprefs & prefmask ) | pref ; retv = 0 ; break ; } case IPV6_MINHOPCOUNT : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val < 0 || val > 255 ) goto e_inval ; np -> min_hopcount = val ; retv = 0 ; break ; case IPV6_DONTFRAG : np -> dontfrag = valbool ; retv = 0 ; break ; case IPV6_AUTOFLOWLABEL : np -> autoflowlabel = valbool ; retv = 0 ; break ; } release_sock ( sk ) ; if ( needs_rtnl ) rtnl_unlock ( ) ; return retv ; e_inval : release_sock ( sk ) ; if ( needs_rtnl ) rtnl_unlock ( ) ; return - EINVAL ; }
","<S2SV_ModStart> = xchg ( ( __force struct ipv6_txoptions * * ) <S2SV_ModStart> ( opt ) { atomic_sub ( opt -> tot_len , & sk -> sk_omem_alloc ) ; txopt_put ( opt ) ; } <S2SV_ModEnd> pktopt = xchg <S2SV_ModStart> ; opt = rcu_dereference_protected ( np -> opt , sock_owned_by_user ( sk ) ) ; opt = <S2SV_ModStart> ( sk , <S2SV_ModEnd> opt , optname <S2SV_ModStart> ( opt ) { atomic_sub ( opt -> tot_len , & sk -> sk_omem_alloc ) ; txopt_put ( opt ) ; } <S2SV_ModEnd> break ; } <S2SV_ModStart> ) ) ; atomic_set ( & opt -> refcnt , 1 ) ; <S2SV_ModStart> ( opt ) { atomic_sub ( opt -> tot_len , & sk -> sk_omem_alloc ) ; txopt_put ( opt ) ; } <S2SV_ModEnd> break ; }
"
940,"CWE-125 static stmt_ty ast_for_classdef ( struct compiling * c , const node * n , asdl_seq * decorator_seq ) { PyObject * classname ; asdl_seq * s ; expr_ty call ; REQ ( n , classdef ) ; if ( NCH ( n ) == 4 ) { s = ast_for_suite ( c , CHILD ( n , 3 ) ) ; if ( ! s ) return NULL ; classname = NEW_IDENTIFIER ( CHILD ( n , 1 ) ) ; if ( ! classname ) return NULL ; if ( forbidden_name ( c , classname , CHILD ( n , 3 ) , 0 ) ) return NULL ; return ClassDef ( classname , NULL , NULL , s , decorator_seq , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } if ( TYPE ( CHILD ( n , 3 ) ) == RPAR ) { s = ast_for_suite ( c , CHILD ( n , 5 ) ) ; if ( ! s ) return NULL ; classname = NEW_IDENTIFIER ( CHILD ( n , 1 ) ) ; if ( ! classname ) return NULL ; if ( forbidden_name ( c , classname , CHILD ( n , 3 ) , 0 ) ) return NULL ; return ClassDef ( classname , NULL , NULL , s , decorator_seq , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } { PyObject * dummy_name ; expr_ty dummy ; dummy_name = NEW_IDENTIFIER ( CHILD ( n , 1 ) ) ; if ( ! dummy_name ) return NULL ; dummy = Name ( dummy_name , Load , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; <S2SV_StartBug> call = ast_for_call ( c , CHILD ( n , 3 ) , dummy ) ; <S2SV_EndBug> if ( ! call ) return NULL ; } s = ast_for_suite ( c , CHILD ( n , 6 ) ) ; if ( ! s ) return NULL ; classname = NEW_IDENTIFIER ( CHILD ( n , 1 ) ) ; if ( ! classname ) return NULL ; if ( forbidden_name ( c , classname , CHILD ( n , 1 ) , 0 ) ) return NULL ; return ClassDef ( classname , call -> v . Call . args , call -> v . Call . keywords , s , decorator_seq , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
","<S2SV_ModStart> ) , dummy , false
"
941,"CWE-264 void mm_release ( struct task_struct * tsk , struct mm_struct * mm ) { <S2SV_StartBug> struct completion * vfork_done = tsk -> vfork_done ; <S2SV_EndBug> deactivate_mm ( tsk , mm ) ; if ( vfork_done ) { tsk -> vfork_done = NULL ; complete ( vfork_done ) ; } if ( tsk -> clear_child_tid && ! ( tsk -> flags & PF_SIGNALED ) && atomic_read ( & mm -> mm_users ) > 1 ) { u32 __user * tidptr = tsk -> clear_child_tid ; tsk -> clear_child_tid = NULL ; put_user ( 0 , tidptr ) ; sys_futex ( tidptr , FUTEX_WAKE , 1 , NULL , NULL , 0 ) ; } }
","<S2SV_ModStart> -> vfork_done ; # ifdef CONFIG_FUTEX if ( unlikely ( tsk -> robust_list ) ) exit_robust_list ( tsk ) ; # ifdef CONFIG_COMPAT if ( unlikely ( tsk -> compat_robust_list ) ) compat_exit_robust_list ( tsk ) ; # endif # endif
"
942,"CWE-119 interval * PGTYPESinterval_from_asc ( char * str , char * * endptr ) { interval * result = NULL ; fsec_t fsec ; struct tm tt , * tm = & tt ; int dtype ; int nf ; char * field [ MAXDATEFIELDS ] ; int ftype [ MAXDATEFIELDS ] ; char lowstr [ MAXDATELEN + MAXDATEFIELDS ] ; char * realptr ; char * * ptr = ( endptr != NULL ) ? endptr : & realptr ; tm -> tm_year = 0 ; tm -> tm_mon = 0 ; tm -> tm_mday = 0 ; tm -> tm_hour = 0 ; tm -> tm_min = 0 ; tm -> tm_sec = 0 ; fsec = 0 ; <S2SV_StartBug> if ( strlen ( str ) >= sizeof ( lowstr ) ) <S2SV_EndBug> { errno = PGTYPES_INTVL_BAD_INTERVAL ; <S2SV_StartBug> return NULL ; <S2SV_EndBug> } if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 || ( DecodeInterval ( field , ftype , nf , & dtype , tm , & fsec ) != 0 && DecodeISO8601Interval ( str , & dtype , tm , & fsec ) != 0 ) ) { errno = PGTYPES_INTVL_BAD_INTERVAL ; <S2SV_StartBug> return NULL ; <S2SV_EndBug> } result = ( interval * ) pgtypes_alloc ( sizeof ( interval ) ) ; if ( ! result ) return NULL ; if ( dtype != DTK_DELTA ) { errno = PGTYPES_INTVL_BAD_INTERVAL ; free ( result ) ; return NULL ; } <S2SV_StartBug> if ( tm2interval ( tm , fsec , result ) != 0 ) <S2SV_EndBug> { errno = PGTYPES_INTVL_BAD_INTERVAL ; free ( result ) ; return NULL ; } errno = 0 ; return result ; }
","<S2SV_ModStart> ( str ) > MAXDATELEN ) { errno = PGTYPES_INTVL_BAD_INTERVAL ; return NULL ; } if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 || ( DecodeInterval ( field , ftype , nf , & dtype , tm , & fsec ) != 0 && DecodeISO8601Interval ( str , & dtype , tm , & fsec ) != 0 ) ) { errno = PGTYPES_INTVL_BAD_INTERVAL ; return NULL ; } result = ( interval * ) pgtypes_alloc ( sizeof ( interval ) ) ; if ( ! result ) return NULL ; if ( dtype != DTK_DELTA <S2SV_ModEnd> ) { errno <S2SV_ModStart> = PGTYPES_INTVL_BAD_INTERVAL ; free ( result ) ; return NULL ; } if ( tm2interval ( tm , fsec , result ) != 0 <S2SV_ModEnd> ) { errno <S2SV_ModStart> = PGTYPES_INTVL_BAD_INTERVAL ; <S2SV_ModEnd> free ( result <S2SV_ModStart> NULL ; } <S2SV_ModEnd> errno = 0
"
943,"CWE-119 static int create_qp_common ( struct mlx5_ib_dev * dev , struct ib_pd * pd , struct ib_qp_init_attr * init_attr , struct ib_udata * udata , struct mlx5_ib_qp * qp ) { struct mlx5_ib_resources * devr = & dev -> devr ; int inlen = MLX5_ST_SZ_BYTES ( create_qp_in ) ; struct mlx5_core_dev * mdev = dev -> mdev ; <S2SV_StartBug> struct mlx5_ib_create_qp_resp resp ; <S2SV_EndBug> struct mlx5_ib_cq * send_cq ; struct mlx5_ib_cq * recv_cq ; unsigned long flags ; u32 uidx = MLX5_IB_DEFAULT_UIDX ; struct mlx5_ib_create_qp ucmd ; struct mlx5_ib_qp_base * base ; int mlx5_st ; void * qpc ; u32 * in ; int err ; mutex_init ( & qp -> mutex ) ; spin_lock_init ( & qp -> sq . lock ) ; spin_lock_init ( & qp -> rq . lock ) ; mlx5_st = to_mlx5_st ( init_attr -> qp_type ) ; if ( mlx5_st < 0 ) return - EINVAL ; if ( init_attr -> rwq_ind_tbl ) { if ( ! udata ) return - ENOSYS ; err = create_rss_raw_qp_tir ( dev , qp , pd , init_attr , udata ) ; return err ; } if ( init_attr -> create_flags & IB_QP_CREATE_BLOCK_MULTICAST_LOOPBACK ) { if ( ! MLX5_CAP_GEN ( mdev , block_lb_mc ) ) { mlx5_ib_dbg ( dev , ""block<S2SV_blank>multicast<S2SV_blank>loopback<S2SV_blank>isn\'t<S2SV_blank>supported\\n"" ) ; return - EINVAL ; } else { qp -> flags |= MLX5_IB_QP_BLOCK_MULTICAST_LOOPBACK ; } } if ( init_attr -> create_flags & ( IB_QP_CREATE_CROSS_CHANNEL | IB_QP_CREATE_MANAGED_SEND | IB_QP_CREATE_MANAGED_RECV ) ) { if ( ! MLX5_CAP_GEN ( mdev , cd ) ) { mlx5_ib_dbg ( dev , ""cross-channel<S2SV_blank>isn\'t<S2SV_blank>supported\\n"" ) ; return - EINVAL ; } if ( init_attr -> create_flags & IB_QP_CREATE_CROSS_CHANNEL ) qp -> flags |= MLX5_IB_QP_CROSS_CHANNEL ; if ( init_attr -> create_flags & IB_QP_CREATE_MANAGED_SEND ) qp -> flags |= MLX5_IB_QP_MANAGED_SEND ; if ( init_attr -> create_flags & IB_QP_CREATE_MANAGED_RECV ) qp -> flags |= MLX5_IB_QP_MANAGED_RECV ; } if ( init_attr -> qp_type == IB_QPT_UD && ( init_attr -> create_flags & IB_QP_CREATE_IPOIB_UD_LSO ) ) if ( ! MLX5_CAP_GEN ( mdev , ipoib_basic_offloads ) ) { mlx5_ib_dbg ( dev , ""ipoib<S2SV_blank>UD<S2SV_blank>lso<S2SV_blank>qp<S2SV_blank>isn\'t<S2SV_blank>supported\\n"" ) ; return - EOPNOTSUPP ; } if ( init_attr -> create_flags & IB_QP_CREATE_SCATTER_FCS ) { if ( init_attr -> qp_type != IB_QPT_RAW_PACKET ) { mlx5_ib_dbg ( dev , ""Scatter<S2SV_blank>FCS<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>only<S2SV_blank>for<S2SV_blank>Raw<S2SV_blank>Packet<S2SV_blank>QPs"" ) ; return - EOPNOTSUPP ; } if ( ! MLX5_CAP_GEN ( dev -> mdev , eth_net_offloads ) || ! MLX5_CAP_ETH ( dev -> mdev , scatter_fcs ) ) { mlx5_ib_dbg ( dev , ""Scatter<S2SV_blank>FCS<S2SV_blank>isn\'t<S2SV_blank>supported\\n"" ) ; return - EOPNOTSUPP ; } qp -> flags |= MLX5_IB_QP_CAP_SCATTER_FCS ; } if ( init_attr -> sq_sig_type == IB_SIGNAL_ALL_WR ) qp -> sq_signal_bits = MLX5_WQE_CTRL_CQ_UPDATE ; if ( init_attr -> create_flags & IB_QP_CREATE_CVLAN_STRIPPING ) { if ( ! ( MLX5_CAP_GEN ( dev -> mdev , eth_net_offloads ) && MLX5_CAP_ETH ( dev -> mdev , vlan_cap ) ) || ( init_attr -> qp_type != IB_QPT_RAW_PACKET ) ) return - EOPNOTSUPP ; qp -> flags |= MLX5_IB_QP_CVLAN_STRIPPING ; } if ( pd && pd -> uobject ) { if ( ib_copy_from_udata ( & ucmd , udata , sizeof ( ucmd ) ) ) { mlx5_ib_dbg ( dev , ""copy<S2SV_blank>failed\\n"" ) ; return - EFAULT ; } err = get_qp_user_index ( to_mucontext ( pd -> uobject -> context ) , & ucmd , udata -> inlen , & uidx ) ; if ( err ) return err ; qp -> wq_sig = ! ! ( ucmd . flags & MLX5_QP_FLAG_SIGNATURE ) ; qp -> scat_cqe = ! ! ( ucmd . flags & MLX5_QP_FLAG_SCATTER_CQE ) ; if ( ucmd . flags & MLX5_QP_FLAG_TUNNEL_OFFLOADS ) { if ( init_attr -> qp_type != IB_QPT_RAW_PACKET || ! tunnel_offload_supported ( mdev ) ) { mlx5_ib_dbg ( dev , ""Tunnel<S2SV_blank>offload<S2SV_blank>isn\'t<S2SV_blank>supported\\n"" ) ; return - EOPNOTSUPP ; } qp -> tunnel_offload_en = true ; } if ( init_attr -> create_flags & IB_QP_CREATE_SOURCE_QPN ) { if ( init_attr -> qp_type != IB_QPT_UD || ( MLX5_CAP_GEN ( dev -> mdev , port_type ) != MLX5_CAP_PORT_TYPE_IB ) || ! mlx5_get_flow_namespace ( dev -> mdev , MLX5_FLOW_NAMESPACE_BYPASS ) ) { mlx5_ib_dbg ( dev , ""Source<S2SV_blank>QP<S2SV_blank>option<S2SV_blank>isn\'t<S2SV_blank>supported\\n"" ) ; return - EOPNOTSUPP ; } qp -> flags |= MLX5_IB_QP_UNDERLAY ; qp -> underlay_qpn = init_attr -> source_qpn ; } } else { qp -> wq_sig = ! ! wq_signature ; } base = ( init_attr -> qp_type == IB_QPT_RAW_PACKET || qp -> flags & MLX5_IB_QP_UNDERLAY ) ? & qp -> raw_packet_qp . rq . base : & qp -> trans_qp . base ; qp -> has_rq = qp_has_rq ( init_attr ) ; err = set_rq_size ( dev , & init_attr -> cap , qp -> has_rq , qp , ( pd && pd -> uobject ) ? & ucmd : NULL ) ; if ( err ) { mlx5_ib_dbg ( dev , ""err<S2SV_blank>%d\\n"" , err ) ; return err ; } if ( pd ) { if ( pd -> uobject ) { __u32 max_wqes = 1 << MLX5_CAP_GEN ( mdev , log_max_qp_sz ) ; mlx5_ib_dbg ( dev , ""requested<S2SV_blank>sq_wqe_count<S2SV_blank>(%d)\\n"" , ucmd . sq_wqe_count ) ; if ( ucmd . rq_wqe_shift != qp -> rq . wqe_shift || ucmd . rq_wqe_count != qp -> rq . wqe_cnt ) { mlx5_ib_dbg ( dev , ""invalid<S2SV_blank>rq<S2SV_blank>params\\n"" ) ; return - EINVAL ; } if ( ucmd . sq_wqe_count > max_wqes ) { mlx5_ib_dbg ( dev , ""requested<S2SV_blank>sq_wqe_count<S2SV_blank>(%d)<S2SV_blank>><S2SV_blank>max<S2SV_blank>allowed<S2SV_blank>(%d)\\n"" , ucmd . sq_wqe_count , max_wqes ) ; return - EINVAL ; } if ( init_attr -> create_flags & mlx5_ib_create_qp_sqpn_qp1 ( ) ) { mlx5_ib_dbg ( dev , ""user-space<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>UD<S2SV_blank>QPs<S2SV_blank>spoofing<S2SV_blank>as<S2SV_blank>QP1\\n"" ) ; return - EINVAL ; } err = create_user_qp ( dev , pd , qp , udata , init_attr , & in , & resp , & inlen , base ) ; if ( err ) mlx5_ib_dbg ( dev , ""err<S2SV_blank>%d\\n"" , err ) ; } else { err = create_kernel_qp ( dev , init_attr , qp , & in , & inlen , base ) ; if ( err ) mlx5_ib_dbg ( dev , ""err<S2SV_blank>%d\\n"" , err ) ; } if ( err ) return err ; } else { in = kvzalloc ( inlen , GFP_KERNEL ) ; if ( ! in ) return - ENOMEM ; qp -> create_type = MLX5_QP_EMPTY ; } if ( is_sqp ( init_attr -> qp_type ) ) qp -> port = init_attr -> port_num ; qpc = MLX5_ADDR_OF ( create_qp_in , in , qpc ) ; MLX5_SET ( qpc , qpc , st , mlx5_st ) ; MLX5_SET ( qpc , qpc , pm_state , MLX5_QP_PM_MIGRATED ) ; if ( init_attr -> qp_type != MLX5_IB_QPT_REG_UMR ) MLX5_SET ( qpc , qpc , pd , to_mpd ( pd ? pd : devr -> p0 ) -> pdn ) ; else MLX5_SET ( qpc , qpc , latency_sensitive , 1 ) ; if ( qp -> wq_sig ) MLX5_SET ( qpc , qpc , wq_signature , 1 ) ; if ( qp -> flags & MLX5_IB_QP_BLOCK_MULTICAST_LOOPBACK ) MLX5_SET ( qpc , qpc , block_lb_mc , 1 ) ; if ( qp -> flags & MLX5_IB_QP_CROSS_CHANNEL ) MLX5_SET ( qpc , qpc , cd_master , 1 ) ; if ( qp -> flags & MLX5_IB_QP_MANAGED_SEND ) MLX5_SET ( qpc , qpc , cd_slave_send , 1 ) ; if ( qp -> flags & MLX5_IB_QP_MANAGED_RECV ) MLX5_SET ( qpc , qpc , cd_slave_receive , 1 ) ; if ( qp -> scat_cqe && is_connected ( init_attr -> qp_type ) ) { int rcqe_sz ; int scqe_sz ; rcqe_sz = mlx5_ib_get_cqe_size ( dev , init_attr -> recv_cq ) ; scqe_sz = mlx5_ib_get_cqe_size ( dev , init_attr -> send_cq ) ; if ( rcqe_sz == 128 ) MLX5_SET ( qpc , qpc , cs_res , MLX5_RES_SCAT_DATA64_CQE ) ; else MLX5_SET ( qpc , qpc , cs_res , MLX5_RES_SCAT_DATA32_CQE ) ; if ( init_attr -> sq_sig_type == IB_SIGNAL_ALL_WR ) { if ( scqe_sz == 128 ) MLX5_SET ( qpc , qpc , cs_req , MLX5_REQ_SCAT_DATA64_CQE ) ; else MLX5_SET ( qpc , qpc , cs_req , MLX5_REQ_SCAT_DATA32_CQE ) ; } } if ( qp -> rq . wqe_cnt ) { MLX5_SET ( qpc , qpc , log_rq_stride , qp -> rq . wqe_shift - 4 ) ; MLX5_SET ( qpc , qpc , log_rq_size , ilog2 ( qp -> rq . wqe_cnt ) ) ; } MLX5_SET ( qpc , qpc , rq_type , get_rx_type ( qp , init_attr ) ) ; if ( qp -> sq . wqe_cnt ) { MLX5_SET ( qpc , qpc , log_sq_size , ilog2 ( qp -> sq . wqe_cnt ) ) ; } else { MLX5_SET ( qpc , qpc , no_sq , 1 ) ; if ( init_attr -> srq && init_attr -> srq -> srq_type == IB_SRQT_TM ) MLX5_SET ( qpc , qpc , offload_type , MLX5_QPC_OFFLOAD_TYPE_RNDV ) ; } switch ( init_attr -> qp_type ) { case IB_QPT_XRC_TGT : MLX5_SET ( qpc , qpc , cqn_rcv , to_mcq ( devr -> c0 ) -> mcq . cqn ) ; MLX5_SET ( qpc , qpc , cqn_snd , to_mcq ( devr -> c0 ) -> mcq . cqn ) ; MLX5_SET ( qpc , qpc , srqn_rmpn_xrqn , to_msrq ( devr -> s0 ) -> msrq . srqn ) ; MLX5_SET ( qpc , qpc , xrcd , to_mxrcd ( init_attr -> xrcd ) -> xrcdn ) ; break ; case IB_QPT_XRC_INI : MLX5_SET ( qpc , qpc , cqn_rcv , to_mcq ( devr -> c0 ) -> mcq . cqn ) ; MLX5_SET ( qpc , qpc , xrcd , to_mxrcd ( devr -> x1 ) -> xrcdn ) ; MLX5_SET ( qpc , qpc , srqn_rmpn_xrqn , to_msrq ( devr -> s0 ) -> msrq . srqn ) ; break ; default : if ( init_attr -> srq ) { MLX5_SET ( qpc , qpc , xrcd , to_mxrcd ( devr -> x0 ) -> xrcdn ) ; MLX5_SET ( qpc , qpc , srqn_rmpn_xrqn , to_msrq ( init_attr -> srq ) -> msrq . srqn ) ; } else { MLX5_SET ( qpc , qpc , xrcd , to_mxrcd ( devr -> x1 ) -> xrcdn ) ; MLX5_SET ( qpc , qpc , srqn_rmpn_xrqn , to_msrq ( devr -> s1 ) -> msrq . srqn ) ; } } if ( init_attr -> send_cq ) MLX5_SET ( qpc , qpc , cqn_snd , to_mcq ( init_attr -> send_cq ) -> mcq . cqn ) ; if ( init_attr -> recv_cq ) MLX5_SET ( qpc , qpc , cqn_rcv , to_mcq ( init_attr -> recv_cq ) -> mcq . cqn ) ; MLX5_SET64 ( qpc , qpc , dbr_addr , qp -> db . dma ) ; if ( MLX5_CAP_GEN ( mdev , cqe_version ) == MLX5_CQE_VERSION_V1 ) MLX5_SET ( qpc , qpc , user_index , uidx ) ; if ( init_attr -> qp_type == IB_QPT_UD && ( init_attr -> create_flags & IB_QP_CREATE_IPOIB_UD_LSO ) ) { MLX5_SET ( qpc , qpc , ulp_stateless_offload_mode , 1 ) ; qp -> flags |= MLX5_IB_QP_LSO ; } if ( init_attr -> create_flags & IB_QP_CREATE_PCI_WRITE_END_PADDING ) { if ( ! MLX5_CAP_GEN ( dev -> mdev , end_pad ) ) { mlx5_ib_dbg ( dev , ""scatter<S2SV_blank>end<S2SV_blank>padding<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported\\n"" ) ; err = - EOPNOTSUPP ; goto err ; } else if ( init_attr -> qp_type != IB_QPT_RAW_PACKET ) { MLX5_SET ( qpc , qpc , end_padding_mode , MLX5_WQ_END_PAD_MODE_ALIGN ) ; } else { qp -> flags |= MLX5_IB_QP_PCI_WRITE_END_PADDING ; } } if ( inlen < 0 ) { err = - EINVAL ; goto err ; } if ( init_attr -> qp_type == IB_QPT_RAW_PACKET || qp -> flags & MLX5_IB_QP_UNDERLAY ) { qp -> raw_packet_qp . sq . ubuffer . buf_addr = ucmd . sq_buf_addr ; raw_packet_qp_copy_info ( qp , & qp -> raw_packet_qp ) ; err = create_raw_packet_qp ( dev , qp , in , inlen , pd ) ; } else { err = mlx5_core_create_qp ( dev -> mdev , & base -> mqp , in , inlen ) ; } if ( err ) { mlx5_ib_dbg ( dev , ""create<S2SV_blank>qp<S2SV_blank>failed\\n"" ) ; goto err_create ; } kvfree ( in ) ; base -> container_mibqp = qp ; base -> mqp . event = mlx5_ib_qp_event ; get_cqs ( init_attr -> qp_type , init_attr -> send_cq , init_attr -> recv_cq , & send_cq , & recv_cq ) ; spin_lock_irqsave ( & dev -> reset_flow_resource_lock , flags ) ; mlx5_ib_lock_cqs ( send_cq , recv_cq ) ; list_add_tail ( & qp -> qps_list , & dev -> qp_list ) ; if ( send_cq ) list_add_tail ( & qp -> cq_send_list , & send_cq -> list_send_qp ) ; if ( recv_cq ) list_add_tail ( & qp -> cq_recv_list , & recv_cq -> list_recv_qp ) ; mlx5_ib_unlock_cqs ( send_cq , recv_cq ) ; spin_unlock_irqrestore ( & dev -> reset_flow_resource_lock , flags ) ; return 0 ; err_create : if ( qp -> create_type == MLX5_QP_USER ) destroy_qp_user ( dev , pd , qp , base ) ; else if ( qp -> create_type == MLX5_QP_KERNEL ) destroy_qp_kernel ( dev , qp ) ; err : kvfree ( in ) ; return err ; }
","<S2SV_ModStart> struct mlx5_ib_create_qp_resp resp = { }
"
944,"CWE-476 static const char * escape_xml ( const char * text ) { static char * escaped ; static size_t escaped_size ; char * out ; size_t len ; <S2SV_StartBug> if ( ! strlen ( text ) ) return ""empty<S2SV_blank>string"" ; <S2SV_EndBug> for ( out = escaped , len = 0 ; * text ; ++ len , ++ out , ++ text ) { if ( ( len + 8 ) > escaped_size ) { char * bigger_escaped ; escaped_size += 128 ; bigger_escaped = realloc ( escaped , escaped_size ) ; if ( ! bigger_escaped ) { free ( escaped ) ; escaped = NULL ; escaped_size = 0 ; return "">>><S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank><<<"" ; } out = bigger_escaped + len ; escaped = bigger_escaped ; } switch ( * text ) { case '&' : strcpy ( out , ""&amp;"" ) ; len += strlen ( out ) - 1 ; out = escaped + len ; break ; case '<' : strcpy ( out , ""&lt;"" ) ; len += strlen ( out ) - 1 ; out = escaped + len ; break ; case '>' : strcpy ( out , ""&gt;"" ) ; len += strlen ( out ) - 1 ; out = escaped + len ; break ; default : * out = * text ; break ; } } * out = '\\x0' ; return escaped ; }
","<S2SV_ModStart> ) ) return """" <S2SV_ModEnd> ; for (
"
945,"CWE-119 int dtls1_read_bytes ( SSL * s , int type , unsigned char * buf , int len , int peek ) { int al , i , j , ret ; unsigned int n ; SSL3_RECORD * rr ; void ( * cb ) ( const SSL * ssl , int type2 , int val ) = NULL ; if ( s -> s3 -> rbuf . buf == NULL ) if ( ! ssl3_setup_buffers ( s ) ) return ( - 1 ) ; if ( ( type && ( type != SSL3_RT_APPLICATION_DATA ) && ( type != SSL3_RT_HANDSHAKE ) ) || ( peek && ( type != SSL3_RT_APPLICATION_DATA ) ) ) { SSLerr ( SSL_F_DTLS1_READ_BYTES , ERR_R_INTERNAL_ERROR ) ; return - 1 ; } if ( ( ret = have_handshake_fragment ( s , type , buf , len , peek ) ) ) return ret ; # ifndef OPENSSL_NO_SCTP if ( ( ! s -> in_handshake && SSL_in_init ( s ) ) || ( BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) && ( s -> state == DTLS1_SCTP_ST_SR_READ_SOCK || s -> state == DTLS1_SCTP_ST_CR_READ_SOCK ) && s -> s3 -> in_read_app_data != 2 ) ) # else if ( ! s -> in_handshake && SSL_in_init ( s ) ) # endif { i = s -> handshake_func ( s ) ; if ( i < 0 ) return ( i ) ; if ( i == 0 ) { SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_SSL_HANDSHAKE_FAILURE ) ; return ( - 1 ) ; } } start : s -> rwstate = SSL_NOTHING ; rr = & ( s -> s3 -> rrec ) ; if ( s -> state == SSL_ST_OK && rr -> length == 0 ) { pitem * item ; item = pqueue_pop ( s -> d1 -> buffered_app_data . q ) ; if ( item ) { # ifndef OPENSSL_NO_SCTP if ( BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) ) { DTLS1_RECORD_DATA * rdata = ( DTLS1_RECORD_DATA * ) item -> data ; BIO_ctrl ( SSL_get_rbio ( s ) , BIO_CTRL_DGRAM_SCTP_SET_RCVINFO , sizeof ( rdata -> recordinfo ) , & rdata -> recordinfo ) ; } # endif dtls1_copy_record ( s , item ) ; OPENSSL_free ( item -> data ) ; pitem_free ( item ) ; } } if ( dtls1_handle_timeout ( s ) > 0 ) goto start ; if ( ( rr -> length == 0 ) || ( s -> rstate == SSL_ST_READ_BODY ) ) { ret = dtls1_get_record ( s ) ; if ( ret <= 0 ) { ret = dtls1_read_failed ( s , ret ) ; if ( ret <= 0 ) return ( ret ) ; else goto start ; } } if ( s -> d1 -> listen && rr -> type != SSL3_RT_HANDSHAKE ) { rr -> length = 0 ; goto start ; } if ( s -> s3 -> change_cipher_spec && ( rr -> type != SSL3_RT_HANDSHAKE ) ) { <S2SV_StartBug> dtls1_buffer_record ( s , & ( s -> d1 -> buffered_app_data ) , rr -> seq_num ) ; <S2SV_EndBug> rr -> length = 0 ; goto start ; } if ( s -> shutdown & SSL_RECEIVED_SHUTDOWN ) { rr -> length = 0 ; s -> rwstate = SSL_NOTHING ; return ( 0 ) ; } if ( type == rr -> type ) { if ( SSL_in_init ( s ) && ( type == SSL3_RT_APPLICATION_DATA ) && ( s -> enc_read_ctx == NULL ) ) { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_APP_DATA_IN_HANDSHAKE ) ; goto f_err ; } if ( len <= 0 ) return ( len ) ; if ( ( unsigned int ) len > rr -> length ) n = rr -> length ; else n = ( unsigned int ) len ; memcpy ( buf , & ( rr -> data [ rr -> off ] ) , n ) ; if ( ! peek ) { rr -> length -= n ; rr -> off += n ; if ( rr -> length == 0 ) { s -> rstate = SSL_ST_READ_HEADER ; rr -> off = 0 ; } } # ifndef OPENSSL_NO_SCTP if ( BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) && rr -> type == SSL3_RT_APPLICATION_DATA && ( s -> state == DTLS1_SCTP_ST_SR_READ_SOCK || s -> state == DTLS1_SCTP_ST_CR_READ_SOCK ) ) { s -> rwstate = SSL_READING ; BIO_clear_retry_flags ( SSL_get_rbio ( s ) ) ; BIO_set_retry_read ( SSL_get_rbio ( s ) ) ; } if ( BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) && s -> d1 -> shutdown_received && ! BIO_dgram_sctp_msg_waiting ( SSL_get_rbio ( s ) ) ) { s -> shutdown |= SSL_RECEIVED_SHUTDOWN ; return ( 0 ) ; } # endif return ( n ) ; } { unsigned int k , dest_maxlen = 0 ; unsigned char * dest = NULL ; unsigned int * dest_len = NULL ; if ( rr -> type == SSL3_RT_HANDSHAKE ) { dest_maxlen = sizeof s -> d1 -> handshake_fragment ; dest = s -> d1 -> handshake_fragment ; dest_len = & s -> d1 -> handshake_fragment_len ; } else if ( rr -> type == SSL3_RT_ALERT ) { dest_maxlen = sizeof ( s -> d1 -> alert_fragment ) ; dest = s -> d1 -> alert_fragment ; dest_len = & s -> d1 -> alert_fragment_len ; } # ifndef OPENSSL_NO_HEARTBEATS else if ( rr -> type == TLS1_RT_HEARTBEAT ) { dtls1_process_heartbeat ( s ) ; rr -> length = 0 ; s -> rwstate = SSL_READING ; BIO_clear_retry_flags ( SSL_get_rbio ( s ) ) ; BIO_set_retry_read ( SSL_get_rbio ( s ) ) ; return ( - 1 ) ; } # endif else if ( rr -> type != SSL3_RT_CHANGE_CIPHER_SPEC ) { if ( rr -> type == SSL3_RT_APPLICATION_DATA ) { BIO * bio ; s -> s3 -> in_read_app_data = 2 ; bio = SSL_get_rbio ( s ) ; s -> rwstate = SSL_READING ; BIO_clear_retry_flags ( bio ) ; BIO_set_retry_read ( bio ) ; return ( - 1 ) ; } al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_UNEXPECTED_RECORD ) ; goto f_err ; } if ( dest_maxlen > 0 ) { if ( rr -> length < dest_maxlen ) { # ifdef DTLS1_AD_MISSING_HANDSHAKE_MESSAGE FIX ME # endif s -> rstate = SSL_ST_READ_HEADER ; rr -> length = 0 ; goto start ; } for ( k = 0 ; k < dest_maxlen ; k ++ ) { dest [ k ] = rr -> data [ rr -> off ++ ] ; rr -> length -- ; } * dest_len = dest_maxlen ; } } if ( ( ! s -> server ) && ( s -> d1 -> handshake_fragment_len >= DTLS1_HM_HEADER_LENGTH ) && ( s -> d1 -> handshake_fragment [ 0 ] == SSL3_MT_HELLO_REQUEST ) && ( s -> session != NULL ) && ( s -> session -> cipher != NULL ) ) { s -> d1 -> handshake_fragment_len = 0 ; if ( ( s -> d1 -> handshake_fragment [ 1 ] != 0 ) || ( s -> d1 -> handshake_fragment [ 2 ] != 0 ) || ( s -> d1 -> handshake_fragment [ 3 ] != 0 ) ) { al = SSL_AD_DECODE_ERROR ; SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_BAD_HELLO_REQUEST ) ; goto err ; } if ( s -> msg_callback ) s -> msg_callback ( 0 , s -> version , SSL3_RT_HANDSHAKE , s -> d1 -> handshake_fragment , 4 , s , s -> msg_callback_arg ) ; if ( SSL_is_init_finished ( s ) && ! ( s -> s3 -> flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS ) && ! s -> s3 -> renegotiate ) { s -> d1 -> handshake_read_seq ++ ; s -> new_session = 1 ; ssl3_renegotiate ( s ) ; if ( ssl3_renegotiate_check ( s ) ) { i = s -> handshake_func ( s ) ; if ( i < 0 ) return ( i ) ; if ( i == 0 ) { SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_SSL_HANDSHAKE_FAILURE ) ; return ( - 1 ) ; } if ( ! ( s -> mode & SSL_MODE_AUTO_RETRY ) ) { if ( s -> s3 -> rbuf . left == 0 ) { BIO * bio ; s -> rwstate = SSL_READING ; bio = SSL_get_rbio ( s ) ; BIO_clear_retry_flags ( bio ) ; BIO_set_retry_read ( bio ) ; return ( - 1 ) ; } } } } goto start ; } if ( s -> d1 -> alert_fragment_len >= DTLS1_AL_HEADER_LENGTH ) { int alert_level = s -> d1 -> alert_fragment [ 0 ] ; int alert_descr = s -> d1 -> alert_fragment [ 1 ] ; s -> d1 -> alert_fragment_len = 0 ; if ( s -> msg_callback ) s -> msg_callback ( 0 , s -> version , SSL3_RT_ALERT , s -> d1 -> alert_fragment , 2 , s , s -> msg_callback_arg ) ; if ( s -> info_callback != NULL ) cb = s -> info_callback ; else if ( s -> ctx -> info_callback != NULL ) cb = s -> ctx -> info_callback ; if ( cb != NULL ) { j = ( alert_level << 8 ) | alert_descr ; cb ( s , SSL_CB_READ_ALERT , j ) ; } if ( alert_level == 1 ) { s -> s3 -> warn_alert = alert_descr ; if ( alert_descr == SSL_AD_CLOSE_NOTIFY ) { # ifndef OPENSSL_NO_SCTP if ( BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) && BIO_dgram_sctp_msg_waiting ( SSL_get_rbio ( s ) ) ) { s -> d1 -> shutdown_received = 1 ; s -> rwstate = SSL_READING ; BIO_clear_retry_flags ( SSL_get_rbio ( s ) ) ; BIO_set_retry_read ( SSL_get_rbio ( s ) ) ; return - 1 ; } # endif s -> shutdown |= SSL_RECEIVED_SHUTDOWN ; return ( 0 ) ; } # if 0 if ( alert_descr == DTLS1_AD_MISSING_HANDSHAKE_MESSAGE ) { unsigned short seq ; unsigned int frag_off ; unsigned char * p = & ( s -> d1 -> alert_fragment [ 2 ] ) ; n2s ( p , seq ) ; n2l3 ( p , frag_off ) ; dtls1_retransmit_message ( s , dtls1_get_queue_priority ( frag -> msg_header . seq , 0 ) , frag_off , & found ) ; if ( ! found && SSL_in_init ( s ) ) { ssl3_send_alert ( s , SSL3_AL_WARNING , DTLS1_AD_MISSING_HANDSHAKE_MESSAGE ) ; } } # endif } else if ( alert_level == 2 ) { char tmp [ 16 ] ; s -> rwstate = SSL_NOTHING ; s -> s3 -> fatal_alert = alert_descr ; SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_AD_REASON_OFFSET + alert_descr ) ; BIO_snprintf ( tmp , sizeof tmp , ""%d"" , alert_descr ) ; ERR_add_error_data ( 2 , ""SSL<S2SV_blank>alert<S2SV_blank>number<S2SV_blank>"" , tmp ) ; s -> shutdown |= SSL_RECEIVED_SHUTDOWN ; SSL_CTX_remove_session ( s -> ctx , s -> session ) ; return ( 0 ) ; } else { al = SSL_AD_ILLEGAL_PARAMETER ; SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_UNKNOWN_ALERT_TYPE ) ; goto f_err ; } goto start ; } if ( s -> shutdown & SSL_SENT_SHUTDOWN ) { s -> rwstate = SSL_NOTHING ; rr -> length = 0 ; return ( 0 ) ; } if ( rr -> type == SSL3_RT_CHANGE_CIPHER_SPEC ) { struct ccs_header_st ccs_hdr ; unsigned int ccs_hdr_len = DTLS1_CCS_HEADER_LENGTH ; dtls1_get_ccs_header ( rr -> data , & ccs_hdr ) ; if ( s -> version == DTLS1_BAD_VER ) ccs_hdr_len = 3 ; if ( ( rr -> length != ccs_hdr_len ) || ( rr -> off != 0 ) || ( rr -> data [ 0 ] != SSL3_MT_CCS ) ) { i = SSL_AD_ILLEGAL_PARAMETER ; SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_BAD_CHANGE_CIPHER_SPEC ) ; goto err ; } rr -> length = 0 ; if ( s -> msg_callback ) s -> msg_callback ( 0 , s -> version , SSL3_RT_CHANGE_CIPHER_SPEC , rr -> data , 1 , s , s -> msg_callback_arg ) ; if ( ! s -> d1 -> change_cipher_spec_ok ) { goto start ; } s -> d1 -> change_cipher_spec_ok = 0 ; s -> s3 -> change_cipher_spec = 1 ; if ( ! ssl3_do_change_cipher_spec ( s ) ) goto err ; dtls1_reset_seq_numbers ( s , SSL3_CC_READ ) ; if ( s -> version == DTLS1_BAD_VER ) s -> d1 -> handshake_read_seq ++ ; # ifndef OPENSSL_NO_SCTP BIO_ctrl ( SSL_get_wbio ( s ) , BIO_CTRL_DGRAM_SCTP_AUTH_CCS_RCVD , 1 , NULL ) ; # endif goto start ; } if ( ( s -> d1 -> handshake_fragment_len >= DTLS1_HM_HEADER_LENGTH ) && ! s -> in_handshake ) { struct hm_header_st msg_hdr ; dtls1_get_message_header ( rr -> data , & msg_hdr ) ; if ( rr -> epoch != s -> d1 -> r_epoch ) { rr -> length = 0 ; goto start ; } if ( msg_hdr . type == SSL3_MT_FINISHED ) { if ( dtls1_check_timeout_num ( s ) < 0 ) return - 1 ; dtls1_retransmit_buffered_messages ( s ) ; rr -> length = 0 ; goto start ; } if ( ( ( s -> state & SSL_ST_MASK ) == SSL_ST_OK ) && ! ( s -> s3 -> flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS ) ) { # if 0 s -> state = SSL_ST_BEFORE | ( s -> server ) ? SSL_ST_ACCEPT : SSL_ST_CONNECT ; # else s -> state = s -> server ? SSL_ST_ACCEPT : SSL_ST_CONNECT ; # endif s -> renegotiate = 1 ; s -> new_session = 1 ; } i = s -> handshake_func ( s ) ; if ( i < 0 ) return ( i ) ; if ( i == 0 ) { SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_SSL_HANDSHAKE_FAILURE ) ; return ( - 1 ) ; } if ( ! ( s -> mode & SSL_MODE_AUTO_RETRY ) ) { if ( s -> s3 -> rbuf . left == 0 ) { BIO * bio ; s -> rwstate = SSL_READING ; bio = SSL_get_rbio ( s ) ; BIO_clear_retry_flags ( bio ) ; BIO_set_retry_read ( bio ) ; return ( - 1 ) ; } } goto start ; } switch ( rr -> type ) { default : # ifndef OPENSSL_NO_TLS if ( s -> version == TLS1_VERSION ) { rr -> length = 0 ; goto start ; } # endif al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_UNEXPECTED_RECORD ) ; goto f_err ; case SSL3_RT_CHANGE_CIPHER_SPEC : case SSL3_RT_ALERT : case SSL3_RT_HANDSHAKE : al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_DTLS1_READ_BYTES , ERR_R_INTERNAL_ERROR ) ; goto f_err ; case SSL3_RT_APPLICATION_DATA : if ( s -> s3 -> in_read_app_data && ( s -> s3 -> total_renegotiations != 0 ) && ( ( ( s -> state & SSL_ST_CONNECT ) && ( s -> state >= SSL3_ST_CW_CLNT_HELLO_A ) && ( s -> state <= SSL3_ST_CR_SRVR_HELLO_A ) ) || ( ( s -> state & SSL_ST_ACCEPT ) && ( s -> state <= SSL3_ST_SW_HELLO_REQ_A ) && ( s -> state >= SSL3_ST_SR_CLNT_HELLO_A ) ) ) ) { s -> s3 -> in_read_app_data = 2 ; return ( - 1 ) ; } else { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_UNEXPECTED_RECORD ) ; goto f_err ; } } f_err : ssl3_send_alert ( s , SSL3_AL_FATAL , al ) ; err : return ( - 1 ) ; }
","<S2SV_ModStart> ) ) { if ( <S2SV_ModStart> -> seq_num ) < 0 ) { SSLerr ( SSL_F_DTLS1_READ_BYTES , ERR_R_INTERNAL_ERROR ) ; return - 1 ; } <S2SV_ModEnd> rr -> length
"
946,"CWE-254 void impeg2d_next_code ( dec_state_t * ps_dec , UWORD32 u4_start_code_val ) { stream_t * ps_stream ; ps_stream = & ps_dec -> s_bit_stream ; impeg2d_bit_stream_flush_to_byte_boundary ( ps_stream ) ; <S2SV_StartBug> while ( ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) != u4_start_code_val ) <S2SV_EndBug> <S2SV_StartBug> && ( ps_dec -> s_bit_stream . u4_offset <= ps_dec -> s_bit_stream . u4_max_offset ) ) <S2SV_EndBug> { if ( impeg2d_bit_stream_get ( ps_stream , 8 ) != 0 ) { } } return ; }
","<S2SV_ModStart> != u4_start_code_val ) && <S2SV_ModEnd> ( ps_dec -> <S2SV_ModStart> s_bit_stream . u4_offset < <S2SV_ModEnd> ps_dec -> s_bit_stream
"
947,"CWE-20 WORD32 ih264d_start_of_pic ( dec_struct_t * ps_dec , WORD32 i4_poc , pocstruct_t * ps_temp_poc , UWORD16 u2_frame_num , dec_pic_params_t * ps_pps ) { pocstruct_t * ps_prev_poc = & ps_dec -> s_cur_pic_poc ; pocstruct_t * ps_cur_poc = ps_temp_poc ; pic_buffer_t * pic_buf ; ivd_video_decode_op_t * ps_dec_output = ( ivd_video_decode_op_t * ) ps_dec -> pv_dec_out ; dec_slice_params_t * ps_cur_slice = ps_dec -> ps_cur_slice ; dec_seq_params_t * ps_seq = ps_pps -> ps_sps ; UWORD8 u1_bottom_field_flag = ps_cur_slice -> u1_bottom_field_flag ; UWORD8 u1_field_pic_flag = ps_cur_slice -> u1_field_pic_flag ; high_profile_tools_t s_high_profile ; WORD32 ret ; H264_MUTEX_LOCK ( & ps_dec -> process_disp_mutex ) ; ps_prev_poc -> i4_pic_order_cnt_lsb = ps_cur_poc -> i4_pic_order_cnt_lsb ; ps_prev_poc -> i4_pic_order_cnt_msb = ps_cur_poc -> i4_pic_order_cnt_msb ; ps_prev_poc -> i4_delta_pic_order_cnt_bottom = ps_cur_poc -> i4_delta_pic_order_cnt_bottom ; ps_prev_poc -> i4_delta_pic_order_cnt [ 0 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 0 ] ; ps_prev_poc -> i4_delta_pic_order_cnt [ 1 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 1 ] ; ps_prev_poc -> u1_bot_field = ps_dec -> ps_cur_slice -> u1_bottom_field_flag ; ps_prev_poc -> i4_prev_frame_num_ofst = ps_cur_poc -> i4_prev_frame_num_ofst ; ps_prev_poc -> u2_frame_num = u2_frame_num ; ps_dec -> i1_prev_mb_qp_delta = 0 ; ps_dec -> i1_next_ctxt_idx = 0 ; ps_dec -> u4_nmb_deblk = 0 ; if ( ps_dec -> u4_num_cores == 1 ) ps_dec -> u4_nmb_deblk = 1 ; if ( ps_seq -> u1_mb_aff_flag == 1 ) { ps_dec -> u4_nmb_deblk = 0 ; if ( ps_dec -> u4_num_cores > 2 ) ps_dec -> u4_num_cores = 2 ; } ps_dec -> u4_use_intrapred_line_copy = 0 ; if ( ps_seq -> u1_mb_aff_flag == 0 ) { ps_dec -> u4_use_intrapred_line_copy = 1 ; } ps_dec -> u4_app_disable_deblk_frm = 0 ; if ( ps_dec -> i4_degrade_type && ps_dec -> i4_degrade_pics ) { WORD32 degrade_pic ; ps_dec -> i4_degrade_pic_cnt ++ ; degrade_pic = 0 ; switch ( ps_dec -> i4_degrade_pics ) { case 4 : { degrade_pic = 1 ; break ; } case 3 : { if ( ps_cur_slice -> u1_slice_type != I_SLICE ) degrade_pic = 1 ; break ; } case 2 : { if ( ( ps_cur_slice -> u1_slice_type != I_SLICE ) && ( ps_dec -> i4_degrade_pic_cnt != ps_dec -> i4_nondegrade_interval ) ) degrade_pic = 1 ; break ; } case 1 : { if ( 0 == ps_cur_slice -> u1_nal_ref_idc ) { degrade_pic = 1 ; } break ; } } if ( degrade_pic ) { if ( ps_dec -> i4_degrade_type & 0x2 ) ps_dec -> u4_app_disable_deblk_frm = 1 ; if ( 0 == ps_cur_slice -> u1_nal_ref_idc ) { if ( ps_dec -> i4_degrade_type & 0x4 ) ps_dec -> i4_mv_frac_mask = 0 ; if ( ps_dec -> i4_degrade_type & 0x8 ) ps_dec -> i4_mv_frac_mask = 0 ; } } else ps_dec -> i4_degrade_pic_cnt = 0 ; } { dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status ; if ( ps_dec -> u1_sl_typ_5_9 && ( ( ps_cur_slice -> u1_slice_type == I_SLICE ) || ( ps_cur_slice -> u1_slice_type == SI_SLICE ) ) ) ps_err -> u1_cur_pic_type = PIC_TYPE_I ; else ps_err -> u1_cur_pic_type = PIC_TYPE_UNKNOWN ; if ( ps_err -> u1_pic_aud_i == PIC_TYPE_I ) { ps_err -> u1_cur_pic_type = PIC_TYPE_I ; ps_err -> u1_pic_aud_i = PIC_TYPE_UNKNOWN ; } if ( ps_cur_slice -> u1_nal_unit_type == IDR_SLICE_NAL ) { if ( ps_err -> u1_err_flag ) ih264d_reset_ref_bufs ( ps_dec -> ps_dpb_mgr ) ; ps_err -> u1_err_flag = ACCEPT_ALL_PICS ; } } if ( ps_dec -> u1_init_dec_flag && ps_dec -> s_prev_seq_params . u1_eoseq_pending ) { WORD32 j ; for ( j = 0 ; j < MAX_DISP_BUFS_NEW ; j ++ ) { ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , j , BUF_MGR_REF ) ; ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_mv_buf_mgr , ps_dec -> au1_pic_buf_id_mv_buf_id_map [ j ] , BUF_MGR_REF ) ; ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , j , BUF_MGR_IO ) ; } ps_dec -> u1_second_field = 0 ; ps_dec -> i4_cur_display_seq = 0 ; ps_dec -> s_prev_seq_params . u1_eoseq_pending = 0 ; } ret = ih264d_init_pic ( ps_dec , u2_frame_num , i4_poc , ps_pps ) ; if ( ret != OK ) return ret ; ps_dec -> pv_parse_tu_coeff_data = ps_dec -> pv_pic_tu_coeff_data ; ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_pic_tu_coeff_data ; ps_dec -> ps_nmb_info = ps_dec -> ps_frm_mb_info ; if ( ps_dec -> u1_separate_parse ) { UWORD16 pic_wd ; UWORD16 pic_ht ; UWORD32 num_mbs ; pic_wd = ps_dec -> u2_pic_wd ; pic_ht = ps_dec -> u2_pic_ht ; num_mbs = ( pic_wd * pic_ht ) >> 8 ; if ( ps_dec -> pu1_dec_mb_map ) { memset ( ( void * ) ps_dec -> pu1_dec_mb_map , 0 , num_mbs ) ; } if ( ps_dec -> pu1_recon_mb_map ) { memset ( ( void * ) ps_dec -> pu1_recon_mb_map , 0 , num_mbs ) ; } if ( ps_dec -> pu2_slice_num_map ) { memset ( ( void * ) ps_dec -> pu2_slice_num_map , 0 , ( num_mbs * sizeof ( UWORD16 ) ) ) ; } } ps_dec -> ps_parse_cur_slice = & ( ps_dec -> ps_dec_slice_buf [ 0 ] ) ; ps_dec -> ps_decode_cur_slice = & ( ps_dec -> ps_dec_slice_buf [ 0 ] ) ; ps_dec -> ps_computebs_cur_slice = & ( ps_dec -> ps_dec_slice_buf [ 0 ] ) ; ps_dec -> s_high_profile . u1_scaling_present = 0 ; ps_dec -> s_high_profile . u1_transform8x8_present = 0 ; if ( 1 == ps_dec -> u4_share_disp_buf ) { UWORD32 i ; for ( i = 0 ; i < MAX_DISP_BUFS_NEW ; i ++ ) { if ( 0 == ps_dec -> u4_disp_buf_to_be_freed [ i ] ) continue ; ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , i , BUF_MGR_IO ) ; ps_dec -> u4_disp_buf_to_be_freed [ i ] = 0 ; ps_dec -> u4_disp_buf_mapping [ i ] = 0 ; } } if ( ! ( u1_field_pic_flag && 0 != ps_dec -> u1_top_bottom_decoded ) ) { pic_buffer_t * ps_cur_pic ; WORD32 cur_pic_buf_id , cur_mv_buf_id ; col_mv_buf_t * ps_col_mv ; while ( 1 ) { ps_cur_pic = ( pic_buffer_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , & cur_pic_buf_id ) ; if ( ps_cur_pic == NULL ) { ps_dec -> i4_error_code = ERROR_UNAVAIL_PICBUF_T ; return ERROR_UNAVAIL_PICBUF_T ; } if ( 0 == ps_dec -> u4_disp_buf_mapping [ cur_pic_buf_id ] ) { break ; } } ps_col_mv = ( col_mv_buf_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_mv_buf_mgr , & cur_mv_buf_id ) ; if ( ps_col_mv == NULL ) { ps_dec -> i4_error_code = ERROR_UNAVAIL_MVBUF_T ; return ERROR_UNAVAIL_MVBUF_T ; } ps_dec -> ps_cur_pic = ps_cur_pic ; ps_dec -> u1_pic_buf_id = cur_pic_buf_id ; ps_cur_pic -> u4_ts = ps_dec -> u4_ts ; ps_cur_pic -> u1_mv_buf_id = cur_mv_buf_id ; ps_dec -> au1_pic_buf_id_mv_buf_id_map [ cur_pic_buf_id ] = cur_mv_buf_id ; ps_cur_pic -> pu1_col_zero_flag = ( UWORD8 * ) ps_col_mv -> pv_col_zero_flag ; ps_cur_pic -> ps_mv = ( mv_pred_t * ) ps_col_mv -> pv_mv ; ps_dec -> au1_pic_buf_ref_flag [ cur_pic_buf_id ] = 0 ; if ( ps_dec -> u1_first_slice_in_stream ) { ps_dec -> ps_ref_pic_buf_lx [ 0 ] = ps_dec -> ps_dpb_mgr -> ps_init_dpb [ 0 ] ; * ( ps_dec -> ps_dpb_mgr -> ps_init_dpb [ 0 ] [ 0 ] ) = * ps_cur_pic ; } if ( ! ps_dec -> ps_cur_pic ) { WORD32 j ; H264_DEC_DEBUG_PRINT ( ""-------<S2SV_blank>Display<S2SV_blank>Buffers<S2SV_blank>Reset<S2SV_blank>--------\\n"" ) ; for ( j = 0 ; j < MAX_DISP_BUFS_NEW ; j ++ ) { ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , j , BUF_MGR_REF ) ; ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_mv_buf_mgr , ps_dec -> au1_pic_buf_id_mv_buf_id_map [ j ] , BUF_MGR_REF ) ; ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , j , BUF_MGR_IO ) ; } ps_dec -> i4_cur_display_seq = 0 ; ps_dec -> i4_prev_max_display_seq = 0 ; ps_dec -> i4_max_poc = 0 ; ps_cur_pic = ( pic_buffer_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , & cur_pic_buf_id ) ; if ( ps_cur_pic == NULL ) { ps_dec -> i4_error_code = ERROR_UNAVAIL_PICBUF_T ; return ERROR_UNAVAIL_PICBUF_T ; } ps_col_mv = ( col_mv_buf_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_mv_buf_mgr , & cur_mv_buf_id ) ; if ( ps_col_mv == NULL ) { ps_dec -> i4_error_code = ERROR_UNAVAIL_MVBUF_T ; return ERROR_UNAVAIL_MVBUF_T ; } ps_dec -> ps_cur_pic = ps_cur_pic ; ps_dec -> u1_pic_buf_id = cur_pic_buf_id ; ps_cur_pic -> u4_ts = ps_dec -> u4_ts ; ps_dec -> apv_buf_id_pic_buf_map [ cur_pic_buf_id ] = ( void * ) ps_cur_pic ; ps_cur_pic -> u1_mv_buf_id = cur_mv_buf_id ; ps_dec -> au1_pic_buf_id_mv_buf_id_map [ cur_pic_buf_id ] = cur_mv_buf_id ; ps_cur_pic -> pu1_col_zero_flag = ( UWORD8 * ) ps_col_mv -> pv_col_zero_flag ; ps_cur_pic -> ps_mv = ( mv_pred_t * ) ps_col_mv -> pv_mv ; ps_dec -> au1_pic_buf_ref_flag [ cur_pic_buf_id ] = 0 ; } ps_dec -> ps_cur_pic -> u1_picturetype = u1_field_pic_flag ; ps_dec -> ps_cur_pic -> u4_pack_slc_typ = SKIP_NONE ; H264_DEC_DEBUG_PRINT ( ""got<S2SV_blank>a<S2SV_blank>buffer\\n"" ) ; } else { H264_DEC_DEBUG_PRINT ( ""did<S2SV_blank>not<S2SV_blank>get<S2SV_blank>a<S2SV_blank>buffer\\n"" ) ; } ps_dec -> u4_pic_buf_got = 1 ; ps_dec -> ps_cur_pic -> i4_poc = i4_poc ; ps_dec -> ps_cur_pic -> i4_frame_num = u2_frame_num ; ps_dec -> ps_cur_pic -> i4_pic_num = u2_frame_num ; ps_dec -> ps_cur_pic -> i4_top_field_order_cnt = ps_pps -> i4_top_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt = ps_pps -> i4_bottom_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_avg_poc = ps_pps -> i4_avg_poc ; ps_dec -> ps_cur_pic -> u4_time_stamp = ps_dec -> u4_pts ; ps_dec -> s_cur_pic = * ( ps_dec -> ps_cur_pic ) ; if ( u1_field_pic_flag && u1_bottom_field_flag ) { WORD32 i4_temp_poc ; WORD32 i4_top_field_order_poc , i4_bot_field_order_poc ; ps_dec -> s_cur_pic . pu1_buf1 += ps_dec -> s_cur_pic . u2_frm_wd_y ; ps_dec -> s_cur_pic . pu1_buf2 += ps_dec -> s_cur_pic . u2_frm_wd_uv ; ps_dec -> s_cur_pic . pu1_buf3 += ps_dec -> s_cur_pic . u2_frm_wd_uv ; ps_dec -> s_cur_pic . ps_mv += ( ( ps_dec -> u2_pic_ht * ps_dec -> u2_pic_wd ) >> 5 ) ; ps_dec -> s_cur_pic . pu1_col_zero_flag += ( ( ps_dec -> u2_pic_ht * ps_dec -> u2_pic_wd ) >> 5 ) ; ps_dec -> ps_cur_pic -> u1_picturetype |= BOT_FLD ; i4_top_field_order_poc = ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; i4_bot_field_order_poc = ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; i4_temp_poc = MIN ( i4_top_field_order_poc , i4_bot_field_order_poc ) ; ps_dec -> ps_cur_pic -> i4_avg_poc = i4_temp_poc ; } ps_cur_slice -> u1_mbaff_frame_flag = ps_seq -> u1_mb_aff_flag && ( ! u1_field_pic_flag ) ; ps_dec -> ps_cur_pic -> u1_picturetype |= ( ps_cur_slice -> u1_mbaff_frame_flag << 2 ) ; ps_dec -> ps_cur_mb_row = ps_dec -> ps_nbr_mb_row ; ps_dec -> ps_cur_mb_row += 2 ; ps_dec -> ps_top_mb_row = ps_dec -> ps_nbr_mb_row ; ps_dec -> ps_top_mb_row += ( ( ps_dec -> u2_frm_wd_in_mbs + 2 ) << ( 1 - ps_dec -> ps_cur_sps -> u1_frame_mbs_only_flag ) ) ; ps_dec -> ps_top_mb_row += 2 ; ps_dec -> ps_mv_cur = ps_dec -> s_cur_pic . ps_mv ; ps_dec -> ps_mv_top = ps_dec -> ps_mv_top_p [ 0 ] ; ps_dec -> u1_mv_top_p = 0 ; ps_dec -> u1_mb_idx = 0 ; ps_dec -> ps_mv_left = ps_dec -> s_cur_pic . ps_mv ; ps_dec -> u2_total_mbs_coded = 0 ; ps_dec -> i4_submb_ofst = - ( SUB_BLK_SIZE ) ; ps_dec -> u4_pred_info_idx = 0 ; ps_dec -> u4_pred_info_pkd_idx = 0 ; ps_dec -> u4_dma_buf_idx = 0 ; ps_dec -> ps_mv = ps_dec -> s_cur_pic . ps_mv ; ps_dec -> ps_mv_bank_cur = ps_dec -> s_cur_pic . ps_mv ; ps_dec -> pu1_col_zero_flag = ps_dec -> s_cur_pic . pu1_col_zero_flag ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; ps_dec -> i2_prev_slice_mbx = - 1 ; ps_dec -> i2_prev_slice_mby = 0 ; ps_dec -> u2_mv_2mb [ 0 ] = 0 ; ps_dec -> u2_mv_2mb [ 1 ] = 0 ; ps_dec -> u1_last_pic_not_decoded = 0 ; ps_dec -> u2_cur_slice_num = 0 ; ps_dec -> u2_cur_slice_num_dec_thread = 0 ; ps_dec -> u2_cur_slice_num_bs = 0 ; ps_dec -> u4_intra_pred_line_ofst = 0 ; ps_dec -> pu1_cur_y_intra_pred_line = ps_dec -> pu1_y_intra_pred_line ; ps_dec -> pu1_cur_u_intra_pred_line = ps_dec -> pu1_u_intra_pred_line ; ps_dec -> pu1_cur_v_intra_pred_line = ps_dec -> pu1_v_intra_pred_line ; ps_dec -> pu1_cur_y_intra_pred_line_base = ps_dec -> pu1_y_intra_pred_line ; ps_dec -> pu1_cur_u_intra_pred_line_base = ps_dec -> pu1_u_intra_pred_line ; ps_dec -> pu1_cur_v_intra_pred_line_base = ps_dec -> pu1_v_intra_pred_line ; ps_dec -> pu1_prev_y_intra_pred_line = ps_dec -> pu1_y_intra_pred_line + ( ps_dec -> u2_frm_wd_in_mbs * MB_SIZE ) ; ps_dec -> pu1_prev_u_intra_pred_line = ps_dec -> pu1_u_intra_pred_line + ps_dec -> u2_frm_wd_in_mbs * BLK8x8SIZE * YUV420SP_FACTOR ; ps_dec -> pu1_prev_v_intra_pred_line = ps_dec -> pu1_v_intra_pred_line + ps_dec -> u2_frm_wd_in_mbs * BLK8x8SIZE ; ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic ; { if ( ps_cur_slice -> u1_mbaff_frame_flag ) { ps_dec -> pf_compute_bs = ih264d_compute_bs_mbaff ; ps_dec -> pf_mvpred = ih264d_mvpred_mbaff ; } else { ps_dec -> pf_compute_bs = ih264d_compute_bs_non_mbaff ; ps_dec -> u1_cur_mb_fld_dec_flag = ps_cur_slice -> u1_field_pic_flag ; } } { UWORD8 u1_field_pic_flag = ps_dec -> ps_cur_slice -> u1_field_pic_flag ; UWORD8 u1_mbaff = ps_cur_slice -> u1_mbaff_frame_flag ; UWORD8 uc_lastmbs = ( ( ( ps_dec -> u2_pic_wd ) >> 4 ) % ( ps_dec -> u1_recon_mb_grp >> u1_mbaff ) ) ; UWORD16 ui16_lastmbs_widthY = ( uc_lastmbs ? ( uc_lastmbs << 4 ) : ( ( ps_dec -> u1_recon_mb_grp >> u1_mbaff ) << 4 ) ) ; UWORD16 ui16_lastmbs_widthUV = uc_lastmbs ? ( uc_lastmbs << 3 ) : ( ( ps_dec -> u1_recon_mb_grp >> u1_mbaff ) << 3 ) ; ps_dec -> s_tran_addrecon . pu1_dest_y = ps_dec -> s_cur_pic . pu1_buf1 ; ps_dec -> s_tran_addrecon . pu1_dest_u = ps_dec -> s_cur_pic . pu1_buf2 ; ps_dec -> s_tran_addrecon . pu1_dest_v = ps_dec -> s_cur_pic . pu1_buf3 ; ps_dec -> s_tran_addrecon . u2_frm_wd_y = ps_dec -> u2_frm_wd_y << u1_field_pic_flag ; ps_dec -> s_tran_addrecon . u2_frm_wd_uv = ps_dec -> u2_frm_wd_uv << u1_field_pic_flag ; if ( u1_field_pic_flag ) { ui16_lastmbs_widthY += ps_dec -> u2_frm_wd_y ; ui16_lastmbs_widthUV += ps_dec -> u2_frm_wd_uv ; } ps_dec -> s_tran_addrecon . u4_inc_y [ 0 ] = ( ( ps_dec -> u1_recon_mb_grp << 4 ) >> u1_mbaff ) ; ps_dec -> s_tran_addrecon . u4_inc_uv [ 0 ] = ( ( ps_dec -> u1_recon_mb_grp << 4 ) >> u1_mbaff ) ; ps_dec -> s_tran_addrecon . u4_inc_y [ 1 ] = ( ui16_lastmbs_widthY + ( PAD_LEN_Y_H << 1 ) + ps_dec -> s_tran_addrecon . u2_frm_wd_y * ( ( 15 << u1_mbaff ) + u1_mbaff ) ) ; ps_dec -> s_tran_addrecon . u4_inc_uv [ 1 ] = ( ui16_lastmbs_widthUV + ( PAD_LEN_UV_H << 2 ) + ps_dec -> s_tran_addrecon . u2_frm_wd_uv * ( ( 15 << u1_mbaff ) + u1_mbaff ) ) ; ih264d_assign_pic_num ( ps_dec ) ; ps_dec -> s_tran_addrecon . u2_mv_top_left_inc = ( ps_dec -> u1_recon_mb_grp << 2 ) - 1 - ( u1_mbaff << 2 ) ; ps_dec -> s_tran_addrecon . u2_mv_left_inc = ( ( ps_dec -> u1_recon_mb_grp >> u1_mbaff ) - 1 ) << ( 4 + u1_mbaff ) ; } if ( ps_seq -> u1_profile_idc == HIGH_PROFILE_IDC ) { if ( ( ps_seq -> i4_seq_scaling_matrix_present_flag ) || ( ps_pps -> i4_pic_scaling_matrix_present_flag ) ) { ih264d_form_scaling_matrix_picture ( ps_seq , ps_pps , ps_dec ) ; ps_dec -> s_high_profile . u1_scaling_present = 1 ; } else { ih264d_form_default_scaling_matrix ( ps_dec ) ; } if ( ps_pps -> i4_transform_8x8_mode_flag ) { ps_dec -> s_high_profile . u1_transform8x8_present = 1 ; } } else { ih264d_form_default_scaling_matrix ( ps_dec ) ; } ps_dec -> s_high_profile . u1_direct_8x8_inference_flag = ps_seq -> u1_direct_8x8_inference_flag ; ps_dec -> s_high_profile . s_cavlc_ctxt = ps_dec -> s_cavlc_ctxt ; ps_dec -> i1_recon_in_thread3_flag = 1 ; ps_dec -> ps_frame_buf_ip_recon = & ps_dec -> s_tran_addrecon ; if ( ps_dec -> u1_separate_parse ) { memcpy ( & ps_dec -> s_tran_addrecon_parse , & ps_dec -> s_tran_addrecon , sizeof ( tfr_ctxt_t ) ) ; if ( ps_dec -> u4_num_cores >= 3 && ps_dec -> i1_recon_in_thread3_flag ) { memcpy ( & ps_dec -> s_tran_iprecon , & ps_dec -> s_tran_addrecon , sizeof ( tfr_ctxt_t ) ) ; ps_dec -> ps_frame_buf_ip_recon = & ps_dec -> s_tran_iprecon ; } } ih264d_init_deblk_tfr_ctxt ( ps_dec , & ( ps_dec -> s_pad_mgr ) , & ( ps_dec -> s_tran_addrecon ) , ps_dec -> u2_frm_wd_in_mbs , 0 ) ; ps_dec -> ps_cur_deblk_mb = ps_dec -> ps_deblk_pic ; ps_dec -> u4_cur_deblk_mb_num = 0 ; ps_dec -> u4_deblk_mb_x = 0 ; ps_dec -> u4_deblk_mb_y = 0 ; <S2SV_StartBug> H264_MUTEX_UNLOCK ( & ps_dec -> process_disp_mutex ) ; <S2SV_EndBug> return OK ; }
","<S2SV_ModStart> = 0 ; ps_dec -> pu4_wt_ofsts = ps_dec -> pu4_wts_ofsts_mat ;
"
948,"CWE-119 static int readContigStripsIntoBuffer ( TIFF * in , uint8 * buf ) { uint8 * bufp = buf ; int32 bytes_read = 0 ; uint32 strip , nstrips = TIFFNumberOfStrips ( in ) ; uint32 stripsize = TIFFStripSize ( in ) ; uint32 rows = 0 ; uint32 rps = TIFFGetFieldDefaulted ( in , TIFFTAG_ROWSPERSTRIP , & rps ) ; tsize_t scanline_size = TIFFScanlineSize ( in ) ; if ( scanline_size == 0 ) { TIFFError ( """" , ""TIFF<S2SV_blank>scanline<S2SV_blank>size<S2SV_blank>is<S2SV_blank>zero!"" ) ; return 0 ; } for ( strip = 0 ; strip < nstrips ; strip ++ ) { bytes_read = TIFFReadEncodedStrip ( in , strip , bufp , - 1 ) ; rows = bytes_read / scanline_size ; if ( ( strip < ( nstrips - 1 ) ) && ( bytes_read != ( int32 ) stripsize ) ) TIFFError ( """" , ""Strip<S2SV_blank>%d:<S2SV_blank>read<S2SV_blank>%lu<S2SV_blank>bytes,<S2SV_blank>strip<S2SV_blank>size<S2SV_blank>%lu"" , ( int ) strip + 1 , ( unsigned long ) bytes_read , ( unsigned long ) stripsize ) ; if ( bytes_read < 0 && ! ignore ) { TIFFError ( """" , ""Error<S2SV_blank>reading<S2SV_blank>strip<S2SV_blank>%lu<S2SV_blank>after<S2SV_blank>%lu<S2SV_blank>rows"" , ( unsigned long ) strip , ( unsigned long ) rows ) ; return 0 ; } <S2SV_StartBug> bufp += bytes_read ; <S2SV_EndBug> } return 1 ; }
","<S2SV_ModStart> } bufp += stripsize <S2SV_ModEnd> ; } return
"
949,"CWE-310 static void sctp_v6_get_dst ( struct sctp_transport * t , union sctp_addr * saddr , struct flowi * fl , struct sock * sk ) { struct sctp_association * asoc = t -> asoc ; struct dst_entry * dst = NULL ; struct flowi6 * fl6 = & fl -> u . ip6 ; struct sctp_bind_addr * bp ; <S2SV_StartBug> struct sctp_sockaddr_entry * laddr ; <S2SV_EndBug> union sctp_addr * baddr = NULL ; union sctp_addr * daddr = & t -> ipaddr ; union sctp_addr dst_saddr ; <S2SV_StartBug> __u8 matchlen = 0 ; <S2SV_EndBug> __u8 bmatchlen ; sctp_scope_t scope ; memset ( fl6 , 0 , sizeof ( struct flowi6 ) ) ; fl6 -> daddr = daddr -> v6 . sin6_addr ; fl6 -> fl6_dport = daddr -> v6 . sin6_port ; fl6 -> flowi6_proto = IPPROTO_SCTP ; if ( ipv6_addr_type ( & daddr -> v6 . sin6_addr ) & IPV6_ADDR_LINKLOCAL ) fl6 -> flowi6_oif = daddr -> v6 . sin6_scope_id ; pr_debug ( ""%s:<S2SV_blank>dst=%pI6<S2SV_blank>"" , __func__ , & fl6 -> daddr ) ; if ( asoc ) fl6 -> fl6_sport = htons ( asoc -> base . bind_addr . port ) ; if ( saddr ) { fl6 -> saddr = saddr -> v6 . sin6_addr ; fl6 -> fl6_sport = saddr -> v6 . sin6_port ; pr_debug ( ""src=%pI6<S2SV_blank>-<S2SV_blank>"" , & fl6 -> saddr ) ; } <S2SV_StartBug> dst = ip6_dst_lookup_flow ( sk , fl6 , NULL , false ) ; <S2SV_EndBug> if ( ! asoc || saddr ) goto out ; bp = & asoc -> base . bind_addr ; scope = sctp_scope ( daddr ) ; if ( ! IS_ERR ( dst ) ) { sctp_v6_to_addr ( & dst_saddr , & fl6 -> saddr , htons ( bp -> port ) ) ; rcu_read_lock ( ) ; list_for_each_entry_rcu ( laddr , & bp -> address_list , list ) { if ( ! laddr -> valid || ( laddr -> state != SCTP_ADDR_SRC ) ) continue ; if ( ( laddr -> a . sa . sa_family == AF_INET6 ) && ( sctp_v6_cmp_addr ( & dst_saddr , & laddr -> a ) ) ) { rcu_read_unlock ( ) ; goto out ; } } rcu_read_unlock ( ) ; dst_release ( dst ) ; dst = NULL ; } rcu_read_lock ( ) ; list_for_each_entry_rcu ( laddr , & bp -> address_list , list ) { if ( ! laddr -> valid ) continue ; if ( ( laddr -> state == SCTP_ADDR_SRC ) && ( laddr -> a . sa . sa_family == AF_INET6 ) && ( scope <= sctp_scope ( & laddr -> a ) ) ) { bmatchlen = sctp_v6_addr_match_len ( daddr , & laddr -> a ) ; if ( ! baddr || ( matchlen < bmatchlen ) ) { baddr = & laddr -> a ; matchlen = bmatchlen ; } } } rcu_read_unlock ( ) ; if ( baddr ) { fl6 -> saddr = baddr -> v6 . sin6_addr ; fl6 -> fl6_sport = baddr -> v6 . sin6_port ; <S2SV_StartBug> dst = ip6_dst_lookup_flow ( sk , fl6 , NULL , false ) ; <S2SV_EndBug> } out : if ( ! IS_ERR_OR_NULL ( dst ) ) { struct rt6_info * rt ; rt = ( struct rt6_info * ) dst ; t -> dst = dst ; t -> dst_cookie = rt -> rt6i_node ? rt -> rt6i_node -> fn_sernum : 0 ; pr_debug ( ""rt6_dst:%pI6<S2SV_blank>rt6_src:%pI6\\n"" , & rt -> rt6i_dst . addr , & fl6 -> saddr ) ; } else { t -> dst = NULL ; pr_debug ( ""no<S2SV_blank>route\\n"" ) ; } }
","<S2SV_ModStart> bp ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct <S2SV_ModStart> sctp_addr dst_saddr ; struct in6_addr * final_p , final ; <S2SV_ModStart> ) ; } final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ; <S2SV_ModStart> , fl6 , final_p <S2SV_ModEnd> , false ) <S2SV_ModStart> . sin6_port ; final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ; <S2SV_ModStart> , fl6 , final_p <S2SV_ModEnd> , false )
"
950,"CWE-399 static int simulate_llsc ( struct pt_regs * regs , unsigned int opcode ) { if ( ( opcode & OPCODE ) == LL ) { perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , <S2SV_StartBug> 1 , 0 , regs , 0 ) ; <S2SV_EndBug> return simulate_ll ( regs , opcode ) ; } if ( ( opcode & OPCODE ) == SC ) { perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , <S2SV_StartBug> 1 , 0 , regs , 0 ) ; <S2SV_EndBug> return simulate_sc ( regs , opcode ) ; } return - 1 ; }
","<S2SV_ModStart> PERF_COUNT_SW_EMULATION_FAULTS , 1 <S2SV_ModEnd> , regs , <S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , 0
"
951,"CWE-119 static long gfs2_fallocate ( struct file * file , int mode , loff_t offset , loff_t len ) { struct inode * inode = file -> f_path . dentry -> d_inode ; struct gfs2_sbd * sdp = GFS2_SB ( inode ) ; struct gfs2_inode * ip = GFS2_I ( inode ) ; unsigned int data_blocks = 0 , ind_blocks = 0 , rblocks ; loff_t bytes , max_bytes ; struct gfs2_alloc * al ; int error ; loff_t bsize_mask = ~ ( ( loff_t ) sdp -> sd_sb . sb_bsize - 1 ) ; loff_t next = ( offset + len - 1 ) >> sdp -> sd_sb . sb_bsize_shift ; <S2SV_StartBug> next = ( next + 1 ) << sdp -> sd_sb . sb_bsize_shift ; <S2SV_EndBug> if ( mode & ~ FALLOC_FL_KEEP_SIZE ) return - EOPNOTSUPP ; offset &= bsize_mask ; len = next - offset ; bytes = sdp -> sd_max_rg_data * sdp -> sd_sb . sb_bsize / 2 ; if ( ! bytes ) bytes = UINT_MAX ; bytes &= bsize_mask ; if ( bytes == 0 ) bytes = sdp -> sd_sb . sb_bsize ; gfs2_holder_init ( ip -> i_gl , LM_ST_EXCLUSIVE , 0 , & ip -> i_gh ) ; error = gfs2_glock_nq ( & ip -> i_gh ) ; if ( unlikely ( error ) ) goto out_uninit ; if ( ! gfs2_write_alloc_required ( ip , offset , len ) ) goto out_unlock ; while ( len > 0 ) { if ( len < bytes ) bytes = len ; al = gfs2_alloc_get ( ip ) ; if ( ! al ) { error = - ENOMEM ; goto out_unlock ; } error = gfs2_quota_lock_check ( ip ) ; if ( error ) goto out_alloc_put ; retry : gfs2_write_calc_reserv ( ip , bytes , & data_blocks , & ind_blocks ) ; al -> al_requested = data_blocks + ind_blocks ; error = gfs2_inplace_reserve ( ip ) ; if ( error ) { if ( error == - ENOSPC && bytes > sdp -> sd_sb . sb_bsize ) { bytes >>= 1 ; bytes &= bsize_mask ; if ( bytes == 0 ) bytes = sdp -> sd_sb . sb_bsize ; goto retry ; } goto out_qunlock ; } max_bytes = bytes ; <S2SV_StartBug> calc_max_reserv ( ip , len , & max_bytes , & data_blocks , & ind_blocks ) ; <S2SV_EndBug> al -> al_requested = data_blocks + ind_blocks ; rblocks = RES_DINODE + ind_blocks + RES_STATFS + RES_QUOTA + RES_RG_HDR + gfs2_rg_blocks ( ip ) ; if ( gfs2_is_jdata ( ip ) ) rblocks += data_blocks ? data_blocks : 1 ; error = gfs2_trans_begin ( sdp , rblocks , PAGE_CACHE_SIZE / sdp -> sd_sb . sb_bsize ) ; if ( error ) goto out_trans_fail ; error = fallocate_chunk ( inode , offset , max_bytes , mode ) ; gfs2_trans_end ( sdp ) ; if ( error ) goto out_trans_fail ; len -= max_bytes ; offset += max_bytes ; gfs2_inplace_release ( ip ) ; gfs2_quota_unlock ( ip ) ; gfs2_alloc_put ( ip ) ; } goto out_unlock ; out_trans_fail : gfs2_inplace_release ( ip ) ; out_qunlock : gfs2_quota_unlock ( ip ) ; out_alloc_put : gfs2_alloc_put ( ip ) ; out_unlock : gfs2_glock_dq ( & ip -> i_gh ) ; out_uninit : gfs2_holder_uninit ( & ip -> i_gh ) ; return error ; }
","<S2SV_ModStart> . sb_bsize_shift ; loff_t max_chunk_size = UINT_MAX & bsize_mask ; <S2SV_ModStart> ( ip , ( len > max_chunk_size ) ? max_chunk_size : len , <S2SV_ModEnd> & max_bytes ,
"
952,"CWE-000 static int do_hidp_sock_ioctl ( struct socket * sock , unsigned int cmd , void __user * argp ) { struct hidp_connadd_req ca ; struct hidp_conndel_req cd ; struct hidp_connlist_req cl ; struct hidp_conninfo ci ; struct socket * csock ; struct socket * isock ; int err ; BT_DBG ( ""cmd<S2SV_blank>%x<S2SV_blank>arg<S2SV_blank>%p"" , cmd , argp ) ; switch ( cmd ) { case HIDPCONNADD : if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; if ( copy_from_user ( & ca , argp , sizeof ( ca ) ) ) return - EFAULT ; csock = sockfd_lookup ( ca . ctrl_sock , & err ) ; if ( ! csock ) return err ; isock = sockfd_lookup ( ca . intr_sock , & err ) ; if ( ! isock ) { sockfd_put ( csock ) ; return err ; <S2SV_StartBug> } <S2SV_EndBug> err = hidp_connection_add ( & ca , csock , isock ) ; if ( ! err && copy_to_user ( argp , & ca , sizeof ( ca ) ) ) err = - EFAULT ; sockfd_put ( csock ) ; sockfd_put ( isock ) ; return err ; case HIDPCONNDEL : if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; if ( copy_from_user ( & cd , argp , sizeof ( cd ) ) ) return - EFAULT ; return hidp_connection_del ( & cd ) ; case HIDPGETCONNLIST : if ( copy_from_user ( & cl , argp , sizeof ( cl ) ) ) return - EFAULT ; if ( cl . cnum <= 0 ) return - EINVAL ; err = hidp_get_connlist ( & cl ) ; if ( ! err && copy_to_user ( argp , & cl , sizeof ( cl ) ) ) return - EFAULT ; return err ; case HIDPGETCONNINFO : if ( copy_from_user ( & ci , argp , sizeof ( ci ) ) ) return - EFAULT ; err = hidp_get_conninfo ( & ci ) ; if ( ! err && copy_to_user ( argp , & ci , sizeof ( ci ) ) ) return - EFAULT ; return err ; } return - EINVAL ; }
","<S2SV_ModStart> err ; } ca . name [ sizeof ( ca . name ) - 1 ] = 0 ;
"
953,"CWE-119 void vp8_pack_bitstream ( VP8_COMP * cpi , unsigned char * dest , unsigned char * dest_end , unsigned long * size ) { int i , j ; VP8_HEADER oh ; VP8_COMMON * const pc = & cpi -> common ; vp8_writer * const bc = cpi -> bc ; MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; int extra_bytes_packed = 0 ; unsigned char * cx_data = dest ; unsigned char * cx_data_end = dest_end ; const int * mb_feature_data_bits ; oh . show_frame = ( int ) pc -> show_frame ; oh . type = ( int ) pc -> frame_type ; oh . version = pc -> version ; oh . first_partition_length_in_bytes = 0 ; mb_feature_data_bits = vp8_mb_feature_data_bits ; bc [ 0 ] . error = & pc -> error ; validate_buffer ( cx_data , 3 , cx_data_end , & cpi -> common . error ) ; cx_data += 3 ; # if defined ( SECTIONBITS_OUTPUT ) Sectionbits [ active_section = 1 ] += sizeof ( VP8_HEADER ) * 8 * 256 ; # endif if ( oh . type == KEY_FRAME ) { int v ; validate_buffer ( cx_data , 7 , cx_data_end , & cpi -> common . error ) ; cx_data [ 0 ] = 0x9D ; cx_data [ 1 ] = 0x01 ; cx_data [ 2 ] = 0x2a ; v = ( pc -> horiz_scale << 14 ) | pc -> Width ; cx_data [ 3 ] = v ; cx_data [ 4 ] = v >> 8 ; v = ( pc -> vert_scale << 14 ) | pc -> Height ; cx_data [ 5 ] = v ; cx_data [ 6 ] = v >> 8 ; extra_bytes_packed = 7 ; cx_data += extra_bytes_packed ; vp8_start_encode ( bc , cx_data , cx_data_end ) ; vp8_write_bit ( bc , 0 ) ; vp8_write_bit ( bc , pc -> clamp_type ) ; } else vp8_start_encode ( bc , cx_data , cx_data_end ) ; vp8_write_bit ( bc , xd -> segmentation_enabled ) ; if ( xd -> segmentation_enabled ) { vp8_write_bit ( bc , xd -> update_mb_segmentation_map ) ; vp8_write_bit ( bc , xd -> update_mb_segmentation_data ) ; if ( xd -> update_mb_segmentation_data ) { signed char Data ; vp8_write_bit ( bc , xd -> mb_segement_abs_delta ) ; for ( i = 0 ; i < MB_LVL_MAX ; i ++ ) { for ( j = 0 ; j < MAX_MB_SEGMENTS ; j ++ ) { Data = xd -> segment_feature_data [ i ] [ j ] ; if ( Data ) { vp8_write_bit ( bc , 1 ) ; if ( Data < 0 ) { Data = - Data ; vp8_write_literal ( bc , Data , mb_feature_data_bits [ i ] ) ; vp8_write_bit ( bc , 1 ) ; } else { vp8_write_literal ( bc , Data , mb_feature_data_bits [ i ] ) ; vp8_write_bit ( bc , 0 ) ; } } else vp8_write_bit ( bc , 0 ) ; } } } if ( xd -> update_mb_segmentation_map ) { for ( i = 0 ; i < MB_FEATURE_TREE_PROBS ; i ++ ) { int Data = xd -> mb_segment_tree_probs [ i ] ; if ( Data != 255 ) { vp8_write_bit ( bc , 1 ) ; vp8_write_literal ( bc , Data , 8 ) ; } else vp8_write_bit ( bc , 0 ) ; } } } vp8_write_bit ( bc , pc -> filter_type ) ; vp8_write_literal ( bc , pc -> filter_level , 6 ) ; vp8_write_literal ( bc , pc -> sharpness_level , 3 ) ; vp8_write_bit ( bc , xd -> mode_ref_lf_delta_enabled ) ; if ( xd -> mode_ref_lf_delta_enabled ) { int send_update = xd -> mode_ref_lf_delta_update || cpi -> oxcf . error_resilient_mode ; vp8_write_bit ( bc , send_update ) ; if ( send_update ) { int Data ; for ( i = 0 ; i < MAX_REF_LF_DELTAS ; i ++ ) { Data = xd -> ref_lf_deltas [ i ] ; if ( xd -> ref_lf_deltas [ i ] != xd -> last_ref_lf_deltas [ i ] || cpi -> oxcf . error_resilient_mode ) { xd -> last_ref_lf_deltas [ i ] = xd -> ref_lf_deltas [ i ] ; vp8_write_bit ( bc , 1 ) ; if ( Data > 0 ) { vp8_write_literal ( bc , ( Data & 0x3F ) , 6 ) ; vp8_write_bit ( bc , 0 ) ; } else { Data = - Data ; vp8_write_literal ( bc , ( Data & 0x3F ) , 6 ) ; vp8_write_bit ( bc , 1 ) ; } } else vp8_write_bit ( bc , 0 ) ; } for ( i = 0 ; i < MAX_MODE_LF_DELTAS ; i ++ ) { Data = xd -> mode_lf_deltas [ i ] ; if ( xd -> mode_lf_deltas [ i ] != xd -> last_mode_lf_deltas [ i ] || cpi -> oxcf . error_resilient_mode ) { xd -> last_mode_lf_deltas [ i ] = xd -> mode_lf_deltas [ i ] ; vp8_write_bit ( bc , 1 ) ; if ( Data > 0 ) { vp8_write_literal ( bc , ( Data & 0x3F ) , 6 ) ; vp8_write_bit ( bc , 0 ) ; } else { Data = - Data ; vp8_write_literal ( bc , ( Data & 0x3F ) , 6 ) ; vp8_write_bit ( bc , 1 ) ; } } else vp8_write_bit ( bc , 0 ) ; } } } vp8_write_literal ( bc , pc -> multi_token_partition , 2 ) ; vp8_write_literal ( bc , pc -> base_qindex , 7 ) ; put_delta_q ( bc , pc -> y1dc_delta_q ) ; put_delta_q ( bc , pc -> y2dc_delta_q ) ; put_delta_q ( bc , pc -> y2ac_delta_q ) ; put_delta_q ( bc , pc -> uvdc_delta_q ) ; put_delta_q ( bc , pc -> uvac_delta_q ) ; if ( pc -> frame_type != KEY_FRAME ) { vp8_write_bit ( bc , pc -> refresh_golden_frame ) ; vp8_write_bit ( bc , pc -> refresh_alt_ref_frame ) ; if ( ! pc -> refresh_golden_frame ) vp8_write_literal ( bc , pc -> copy_buffer_to_gf , 2 ) ; if ( ! pc -> refresh_alt_ref_frame ) vp8_write_literal ( bc , pc -> copy_buffer_to_arf , 2 ) ; vp8_write_bit ( bc , pc -> ref_frame_sign_bias [ GOLDEN_FRAME ] ) ; vp8_write_bit ( bc , pc -> ref_frame_sign_bias [ ALTREF_FRAME ] ) ; } # if ! ( CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING ) if ( cpi -> oxcf . error_resilient_mode & VPX_ERROR_RESILIENT_PARTITIONS ) { if ( pc -> frame_type == KEY_FRAME ) pc -> refresh_entropy_probs = 1 ; else pc -> refresh_entropy_probs = 0 ; } # endif vp8_write_bit ( bc , pc -> refresh_entropy_probs ) ; if ( pc -> frame_type != KEY_FRAME ) vp8_write_bit ( bc , pc -> refresh_last_frame ) ; # ifdef VP8_ENTROPY_STATS if ( pc -> frame_type == INTER_FRAME ) active_section = 0 ; else active_section = 7 ; # endif vp8_clear_system_state ( ) ; # if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING pack_coef_probs ( cpi ) ; # else if ( pc -> refresh_entropy_probs == 0 ) { <S2SV_StartBug> vpx_memcpy ( & cpi -> common . lfc , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ; <S2SV_EndBug> } vp8_update_coef_probs ( cpi ) ; # endif # ifdef VP8_ENTROPY_STATS active_section = 2 ; # endif vp8_write_bit ( bc , pc -> mb_no_coeff_skip ) ; if ( pc -> frame_type == KEY_FRAME ) { write_kfmodes ( cpi ) ; # ifdef VP8_ENTROPY_STATS active_section = 8 ; # endif } else { pack_inter_mode_mvs ( cpi ) ; # ifdef VP8_ENTROPY_STATS active_section = 1 ; # endif } vp8_stop_encode ( bc ) ; cx_data += bc -> pos ; oh . first_partition_length_in_bytes = cpi -> bc -> pos ; { int v = ( oh . first_partition_length_in_bytes << 5 ) | ( oh . show_frame << 4 ) | ( oh . version << 1 ) | oh . type ; dest [ 0 ] = v ; dest [ 1 ] = v >> 8 ; dest [ 2 ] = v >> 16 ; } * size = VP8_HEADER_SIZE + extra_bytes_packed + cpi -> bc -> pos ; cpi -> partition_sz [ 0 ] = * size ; # if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING { const int num_part = ( 1 << pc -> multi_token_partition ) ; unsigned char * dp = cpi -> partition_d [ 0 ] + cpi -> partition_sz [ 0 ] ; if ( num_part > 1 ) { validate_buffer ( dp , 3 * ( num_part - 1 ) , cpi -> partition_d_end [ 0 ] , & pc -> error ) ; cpi -> partition_sz [ 0 ] += 3 * ( num_part - 1 ) ; for ( i = 1 ; i < num_part ; i ++ ) { write_partition_size ( dp , cpi -> partition_sz [ i ] ) ; dp += 3 ; } } if ( ! cpi -> output_partition ) { for ( i = 0 ; i < num_part ; i ++ ) { <S2SV_StartBug> vpx_memmove ( dp , cpi -> partition_d [ i + 1 ] , cpi -> partition_sz [ i + 1 ] ) ; <S2SV_EndBug> cpi -> partition_d [ i + 1 ] = dp ; dp += cpi -> partition_sz [ i + 1 ] ; } } * size = 0 ; for ( i = 0 ; i < num_part + 1 ; i ++ ) { * size += cpi -> partition_sz [ i ] ; } } # else if ( pc -> multi_token_partition != ONE_PARTITION ) { int num_part = 1 << pc -> multi_token_partition ; cpi -> partition_sz [ 0 ] += 3 * ( num_part - 1 ) ; * size += 3 * ( num_part - 1 ) ; validate_buffer ( cx_data , 3 * ( num_part - 1 ) , cx_data_end , & pc -> error ) ; for ( i = 1 ; i < num_part + 1 ; i ++ ) { cpi -> bc [ i ] . error = & pc -> error ; } pack_tokens_into_partitions ( cpi , cx_data + 3 * ( num_part - 1 ) , cx_data_end , num_part ) ; for ( i = 1 ; i < num_part ; i ++ ) { cpi -> partition_sz [ i ] = cpi -> bc [ i ] . pos ; write_partition_size ( cx_data , cpi -> partition_sz [ i ] ) ; cx_data += 3 ; * size += cpi -> partition_sz [ i ] ; } cpi -> partition_sz [ i ] = cpi -> bc [ i ] . pos ; * size += cpi -> partition_sz [ i ] ; } else { bc [ 1 ] . error = & pc -> error ; vp8_start_encode ( & cpi -> bc [ 1 ] , cx_data , cx_data_end ) ; # if CONFIG_MULTITHREAD if ( cpi -> b_multi_threaded ) pack_mb_row_tokens ( cpi , & cpi -> bc [ 1 ] ) ; else # endif <S2SV_StartBug> pack_tokens ( & cpi -> bc [ 1 ] , cpi -> tok , cpi -> tok_count ) ; <S2SV_EndBug> vp8_stop_encode ( & cpi -> bc [ 1 ] ) ; * size += cpi -> bc [ 1 ] . pos ; cpi -> partition_sz [ 1 ] = cpi -> bc [ 1 ] . pos ; } # endif }
","<S2SV_ModStart> 0 ) { memcpy <S2SV_ModEnd> ( & cpi <S2SV_ModStart> ++ ) { memmove <S2SV_ModEnd> ( dp , <S2SV_ModStart> else # endif vp8_pack_tokens <S2SV_ModEnd> ( & cpi
"
954,"CWE-119 static ssize_t k90_show_current_profile ( struct device * dev , struct device_attribute * attr , char * buf ) { int ret ; struct usb_interface * usbif = to_usb_interface ( dev -> parent ) ; struct usb_device * usbdev = interface_to_usbdev ( usbif ) ; int current_profile ; <S2SV_StartBug> char data [ 8 ] ; <S2SV_EndBug> ret = usb_control_msg ( usbdev , usb_rcvctrlpipe ( usbdev , 0 ) , K90_REQUEST_STATUS , USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE , 0 , 0 , data , 8 , USB_CTRL_SET_TIMEOUT ) ; if ( ret < 0 ) { dev_warn ( dev , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>K90<S2SV_blank>initial<S2SV_blank>state<S2SV_blank>(error<S2SV_blank>%d).\\n"" , ret ) ; <S2SV_StartBug> return - EIO ; <S2SV_EndBug> } current_profile = data [ 7 ] ; if ( current_profile < 1 || current_profile > 3 ) { dev_warn ( dev , ""Read<S2SV_blank>invalid<S2SV_blank>current<S2SV_blank>profile:<S2SV_blank>%02hhx.\\n"" , data [ 7 ] ) ; <S2SV_StartBug> return - EIO ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> return snprintf ( buf , PAGE_SIZE , ""%d\\n"" , current_profile ) ; }
","<S2SV_ModStart> current_profile ; char * data ; data = kmalloc ( 8 , GFP_KERNEL ) ; if ( ! data ) return - ENOMEM <S2SV_ModEnd> ; ret = <S2SV_ModStart> ret ) ; ret = - EIO ; goto out <S2SV_ModEnd> ; } current_profile <S2SV_ModStart> ] ) ; ret = <S2SV_ModEnd> - EIO ; <S2SV_ModStart> - EIO ; goto out ; } ret = snprintf ( buf , PAGE_SIZE , ""%d\\n"" , current_profile ) ; out : kfree ( data ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
"
955,"CWE-401 struct resource_pool * dce120_create_resource_pool ( uint8_t num_virtual_links , struct dc * dc ) { struct dce110_resource_pool * pool = kzalloc ( sizeof ( struct dce110_resource_pool ) , GFP_KERNEL ) ; if ( ! pool ) return NULL ; if ( construct ( num_virtual_links , dc , pool ) ) return & pool -> base ; <S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug> return NULL ; }
","<S2SV_ModStart> -> base ; kfree ( pool ) ;
"
956,"CWE-119 void jpc_qmfb_join_colgrp ( jpc_fix_t * a , int numrows , int stride , int parity ) { int bufsize = JPC_CEILDIVPOW2 ( numrows , 1 ) ; jpc_fix_t joinbuf [ QMFB_JOINBUFSIZE * JPC_QMFB_COLGRPSIZE ] ; jpc_fix_t * buf = joinbuf ; jpc_fix_t * srcptr ; jpc_fix_t * dstptr ; register jpc_fix_t * srcptr2 ; register jpc_fix_t * dstptr2 ; register int n ; register int i ; int hstartcol ; if ( bufsize > QMFB_JOINBUFSIZE ) { if ( ! ( buf = jas_alloc3 ( bufsize , JPC_QMFB_COLGRPSIZE , sizeof ( jpc_fix_t ) ) ) ) { abort ( ) ; } } hstartcol = ( numrows + 1 - parity ) >> 1 ; n = hstartcol ; srcptr = & a [ 0 ] ; dstptr = buf ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < JPC_QMFB_COLGRPSIZE ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } srcptr += stride ; dstptr += JPC_QMFB_COLGRPSIZE ; } srcptr = & a [ hstartcol * stride ] ; dstptr = & a [ ( 1 - parity ) * stride ] ; n = numrows - hstartcol ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < JPC_QMFB_COLGRPSIZE ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += 2 * stride ; srcptr += stride ; } srcptr = buf ; dstptr = & a [ parity * stride ] ; n = hstartcol ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < JPC_QMFB_COLGRPSIZE ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += 2 * stride ; srcptr += JPC_QMFB_COLGRPSIZE ; } if ( buf != joinbuf ) { jas_free ( buf ) ; } }
","
"
957,"CWE-119 static struct VP8D_COMP * create_decompressor ( VP8D_CONFIG * oxcf ) { VP8D_COMP * pbi = vpx_memalign ( 32 , sizeof ( VP8D_COMP ) ) ; if ( ! pbi ) return NULL ; <S2SV_StartBug> vpx_memset ( pbi , 0 , sizeof ( VP8D_COMP ) ) ; <S2SV_EndBug> if ( setjmp ( pbi -> common . error . jmp ) ) { pbi -> common . error . setjmp = 0 ; remove_decompressor ( pbi ) ; return 0 ; } pbi -> common . error . setjmp = 1 ; vp8_create_common ( & pbi -> common ) ; pbi -> common . current_video_frame = 0 ; pbi -> ready_for_new_data = 1 ; vp8cx_init_de_quantizer ( pbi ) ; vp8_loop_filter_init ( & pbi -> common ) ; pbi -> common . error . setjmp = 0 ; # if CONFIG_ERROR_CONCEALMENT pbi -> ec_enabled = oxcf -> error_concealment ; pbi -> overlaps = NULL ; # else <S2SV_StartBug> pbi -> ec_enabled = 0 ; <S2SV_EndBug> # endif pbi -> ec_active = 0 ; pbi -> decoded_key_frame = 0 ; pbi -> independent_partitions = 0 ; vp8_setup_block_dptrs ( & pbi -> mb ) ; return pbi ; }
","<S2SV_ModStart> return NULL ; memset <S2SV_ModEnd> ( pbi , <S2SV_ModStart> ; # else ( void ) oxcf ;
"
958,"CWE-89 char * curl_easy_escape ( CURL * handle , const char * string , int inlength ) { size_t alloc = ( inlength ? ( size_t ) inlength : strlen ( string ) ) + 1 ; char * ns ; char * testing_ptr = NULL ; unsigned char in ; size_t newlen = alloc ; <S2SV_StartBug> int strindex = 0 ; <S2SV_EndBug> size_t length ; CURLcode res ; ns = malloc ( alloc ) ; if ( ! ns ) return NULL ; length = alloc - 1 ; while ( length -- ) { in = * string ; if ( Curl_isunreserved ( in ) ) ns [ strindex ++ ] = in ; else { newlen += 2 ; if ( newlen > alloc ) { alloc *= 2 ; testing_ptr = realloc ( ns , alloc ) ; if ( ! testing_ptr ) { free ( ns ) ; return NULL ; } else { ns = testing_ptr ; } } res = Curl_convert_to_network ( handle , & in , 1 ) ; if ( res ) { free ( ns ) ; return NULL ; } snprintf ( & ns [ strindex ] , 4 , ""%%%02X"" , in ) ; strindex += 3 ; } string ++ ; } ns [ strindex ] = 0 ; return ns ; }
","<S2SV_ModStart> = alloc ; size_t <S2SV_ModEnd> strindex = 0
"
959,"CWE-119 <S2SV_StartBug> static int try_filter_frame ( const YV12_BUFFER_CONFIG * sd , VP9_COMP * const cpi , <S2SV_EndBug> int filt_level , int partial_frame ) { VP9_COMMON * const cm = & cpi -> common ; <S2SV_StartBug> int filt_err ; <S2SV_EndBug> <S2SV_StartBug> vp9_loop_filter_frame ( cm , & cpi -> mb . e_mbd , filt_level , 1 , partial_frame ) ; <S2SV_EndBug> <S2SV_StartBug> filt_err = vp9_get_y_sse ( sd , cm -> frame_to_show ) ; <S2SV_EndBug> vpx_yv12_copy_y ( & cpi -> last_frame_uf , cm -> frame_to_show ) ; return filt_err ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static int64_t <S2SV_ModEnd> try_filter_frame ( const <S2SV_ModStart> -> common ; int64_t filt_err ; if ( cpi -> num_workers > 1 ) vp9_loop_filter_frame_mt ( cm -> frame_to_show , cm , cpi -> td . mb . e_mbd . plane , filt_level , 1 , partial_frame , cpi -> workers , cpi -> num_workers , & cpi -> lf_row_sync ) ; else vp9_loop_filter_frame ( cm -> frame_to_show , <S2SV_ModEnd> cm , & <S2SV_ModStart> & cpi -> td . <S2SV_ModStart> partial_frame ) ; # if CONFIG_VP9_HIGHBITDEPTH if ( cm -> use_highbitdepth ) { filt_err = vp9_highbd_get_y_sse ( sd , cm -> frame_to_show ) ; } else { <S2SV_ModStart> frame_to_show ) ; } # else filt_err = vp9_get_y_sse ( sd , cm -> frame_to_show ) ; # endif
"
960,"CWE-190 int pgx_validate ( jas_stream_t * in ) { <S2SV_StartBug> uchar buf [ PGX_MAGICLEN ] ; <S2SV_EndBug> uint_fast32_t magic ; int i ; int n ; assert ( JAS_STREAM_MAXPUTBACK >= PGX_MAGICLEN ) ; if ( ( n = jas_stream_read ( in , buf , PGX_MAGICLEN ) ) < 0 ) { return - 1 ; } for ( i = n - 1 ; i >= 0 ; -- i ) { if ( jas_stream_ungetc ( in , buf [ i ] ) == EOF ) { return - 1 ; } } if ( n < PGX_MAGICLEN ) { return - 1 ; } magic = ( buf [ 0 ] << 8 ) | buf [ 1 ] ; if ( magic != PGX_MAGIC ) { return - 1 ; } return 0 ; }
","<S2SV_ModStart> in ) { jas_uchar <S2SV_ModEnd> buf [ PGX_MAGICLEN
"
961,"CWE-200 static long bcm_char_ioctl ( struct file * filp , UINT cmd , ULONG arg ) { struct bcm_tarang_data * pTarang = filp -> private_data ; void __user * argp = ( void __user * ) arg ; struct bcm_mini_adapter * Adapter = pTarang -> Adapter ; INT Status = STATUS_FAILURE ; int timeout = 0 ; struct bcm_ioctl_buffer IoBuffer ; int bytes ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Parameters<S2SV_blank>Passed<S2SV_blank>to<S2SV_blank>control<S2SV_blank>IOCTL<S2SV_blank>cmd=0x%X<S2SV_blank>arg=0x%lX"" , cmd , arg ) ; if ( _IOC_TYPE ( cmd ) != BCM_IOCTL ) return - EFAULT ; if ( _IOC_DIR ( cmd ) & _IOC_READ ) Status = ! access_ok ( VERIFY_WRITE , argp , _IOC_SIZE ( cmd ) ) ; else if ( _IOC_DIR ( cmd ) & _IOC_WRITE ) Status = ! access_ok ( VERIFY_READ , argp , _IOC_SIZE ( cmd ) ) ; else if ( _IOC_NONE == ( _IOC_DIR ( cmd ) & _IOC_NONE ) ) Status = STATUS_SUCCESS ; if ( Status ) return - EFAULT ; if ( Adapter -> device_removed ) return - EFAULT ; if ( FALSE == Adapter -> fw_download_done ) { switch ( cmd ) { case IOCTL_MAC_ADDR_REQ : case IOCTL_LINK_REQ : case IOCTL_CM_REQUEST : case IOCTL_SS_INFO_REQ : case IOCTL_SEND_CONTROL_MESSAGE : case IOCTL_IDLE_REQ : case IOCTL_BCM_GPIO_SET_REQUEST : case IOCTL_BCM_GPIO_STATUS_REQUEST : return - EACCES ; default : break ; } } Status = vendorextnIoctl ( Adapter , cmd , arg ) ; if ( Status != CONTINUE_COMMON_PATH ) return Status ; switch ( cmd ) { case IOCTL_BCM_REGISTER_READ_PRIVATE : { struct bcm_rdm_buffer sRdmBuffer = { 0 } ; PCHAR temp_buff ; UINT Bufflen ; u16 temp_value ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . InputLength > sizeof ( sRdmBuffer ) ) return - EINVAL ; if ( copy_from_user ( & sRdmBuffer , IoBuffer . InputBuffer , IoBuffer . InputLength ) ) return - EFAULT ; if ( IoBuffer . OutputLength > USHRT_MAX || IoBuffer . OutputLength == 0 ) { return - EINVAL ; } Bufflen = IoBuffer . OutputLength ; temp_value = 4 - ( Bufflen % 4 ) ; Bufflen += temp_value % 4 ; temp_buff = kmalloc ( Bufflen , GFP_KERNEL ) ; if ( ! temp_buff ) return - ENOMEM ; bytes = rdmalt ( Adapter , ( UINT ) sRdmBuffer . Register , ( PUINT ) temp_buff , Bufflen ) ; if ( bytes > 0 ) { Status = STATUS_SUCCESS ; if ( copy_to_user ( IoBuffer . OutputBuffer , temp_buff , bytes ) ) { kfree ( temp_buff ) ; return - EFAULT ; } } else { Status = bytes ; } kfree ( temp_buff ) ; break ; } case IOCTL_BCM_REGISTER_WRITE_PRIVATE : { struct bcm_wrm_buffer sWrmBuffer = { 0 } ; UINT uiTempVar = 0 ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . InputLength > sizeof ( sWrmBuffer ) ) return - EINVAL ; if ( copy_from_user ( & sWrmBuffer , IoBuffer . InputBuffer , IoBuffer . InputLength ) ) return - EFAULT ; uiTempVar = sWrmBuffer . Register & EEPROM_REJECT_MASK ; if ( ! ( ( Adapter -> pstargetparams -> m_u32Customize ) & VSG_MODE ) && ( ( uiTempVar == EEPROM_REJECT_REG_1 ) || ( uiTempVar == EEPROM_REJECT_REG_2 ) || ( uiTempVar == EEPROM_REJECT_REG_3 ) || ( uiTempVar == EEPROM_REJECT_REG_4 ) ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""EEPROM<S2SV_blank>Access<S2SV_blank>Denied,<S2SV_blank>not<S2SV_blank>in<S2SV_blank>VSG<S2SV_blank>Mode\\n"" ) ; return - EFAULT ; } Status = wrmalt ( Adapter , ( UINT ) sWrmBuffer . Register , ( PUINT ) sWrmBuffer . Data , sizeof ( ULONG ) ) ; if ( Status == STATUS_SUCCESS ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""WRM<S2SV_blank>Done\\n"" ) ; } else { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""WRM<S2SV_blank>Failed\\n"" ) ; Status = - EFAULT ; } break ; } case IOCTL_BCM_REGISTER_READ : case IOCTL_BCM_EEPROM_REGISTER_READ : { struct bcm_rdm_buffer sRdmBuffer = { 0 } ; PCHAR temp_buff = NULL ; UINT uiTempVar = 0 ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Device<S2SV_blank>in<S2SV_blank>Idle<S2SV_blank>Mode,<S2SV_blank>Blocking<S2SV_blank>Rdms\\n"" ) ; return - EACCES ; } if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . InputLength > sizeof ( sRdmBuffer ) ) return - EINVAL ; if ( copy_from_user ( & sRdmBuffer , IoBuffer . InputBuffer , IoBuffer . InputLength ) ) return - EFAULT ; if ( IoBuffer . OutputLength > USHRT_MAX || IoBuffer . OutputLength == 0 ) { return - EINVAL ; } temp_buff = kmalloc ( IoBuffer . OutputLength , GFP_KERNEL ) ; if ( ! temp_buff ) return STATUS_FAILURE ; if ( ( ( ( ULONG ) sRdmBuffer . Register & 0x0F000000 ) != 0x0F000000 ) || ( ( ULONG ) sRdmBuffer . Register & 0x3 ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""RDM<S2SV_blank>Done<S2SV_blank>On<S2SV_blank>invalid<S2SV_blank>Address<S2SV_blank>:<S2SV_blank>%x<S2SV_blank>Access<S2SV_blank>Denied.\\n"" , ( int ) sRdmBuffer . Register ) ; kfree ( temp_buff ) ; return - EINVAL ; } uiTempVar = sRdmBuffer . Register & EEPROM_REJECT_MASK ; bytes = rdmaltWithLock ( Adapter , ( UINT ) sRdmBuffer . Register , ( PUINT ) temp_buff , IoBuffer . OutputLength ) ; if ( bytes > 0 ) { Status = STATUS_SUCCESS ; if ( copy_to_user ( IoBuffer . OutputBuffer , temp_buff , bytes ) ) { kfree ( temp_buff ) ; return - EFAULT ; } } else { Status = bytes ; } kfree ( temp_buff ) ; break ; } case IOCTL_BCM_REGISTER_WRITE : case IOCTL_BCM_EEPROM_REGISTER_WRITE : { struct bcm_wrm_buffer sWrmBuffer = { 0 } ; UINT uiTempVar = 0 ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Device<S2SV_blank>in<S2SV_blank>Idle<S2SV_blank>Mode,<S2SV_blank>Blocking<S2SV_blank>Wrms\\n"" ) ; return - EACCES ; } if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . InputLength > sizeof ( sWrmBuffer ) ) return - EINVAL ; if ( copy_from_user ( & sWrmBuffer , IoBuffer . InputBuffer , IoBuffer . InputLength ) ) return - EFAULT ; if ( ( ( ( ULONG ) sWrmBuffer . Register & 0x0F000000 ) != 0x0F000000 ) || ( ( ULONG ) sWrmBuffer . Register & 0x3 ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""WRM<S2SV_blank>Done<S2SV_blank>On<S2SV_blank>invalid<S2SV_blank>Address<S2SV_blank>:<S2SV_blank>%x<S2SV_blank>Access<S2SV_blank>Denied.\\n"" , ( int ) sWrmBuffer . Register ) ; return - EINVAL ; } uiTempVar = sWrmBuffer . Register & EEPROM_REJECT_MASK ; if ( ! ( ( Adapter -> pstargetparams -> m_u32Customize ) & VSG_MODE ) && ( ( uiTempVar == EEPROM_REJECT_REG_1 ) || ( uiTempVar == EEPROM_REJECT_REG_2 ) || ( uiTempVar == EEPROM_REJECT_REG_3 ) || ( uiTempVar == EEPROM_REJECT_REG_4 ) ) && ( cmd == IOCTL_BCM_REGISTER_WRITE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""EEPROM<S2SV_blank>Access<S2SV_blank>Denied,<S2SV_blank>not<S2SV_blank>in<S2SV_blank>VSG<S2SV_blank>Mode\\n"" ) ; return - EFAULT ; } Status = wrmaltWithLock ( Adapter , ( UINT ) sWrmBuffer . Register , ( PUINT ) sWrmBuffer . Data , sWrmBuffer . Length ) ; if ( Status == STATUS_SUCCESS ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , OSAL_DBG , DBG_LVL_ALL , ""WRM<S2SV_blank>Done\\n"" ) ; } else { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""WRM<S2SV_blank>Failed\\n"" ) ; Status = - EFAULT ; } break ; } case IOCTL_BCM_GPIO_SET_REQUEST : { UCHAR ucResetValue [ 4 ] ; UINT value = 0 ; UINT uiBit = 0 ; UINT uiOperation = 0 ; struct bcm_gpio_info gpio_info = { 0 } ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""GPIO<S2SV_blank>Can\'t<S2SV_blank>be<S2SV_blank>set/clear<S2SV_blank>in<S2SV_blank>Low<S2SV_blank>power<S2SV_blank>Mode"" ) ; return - EACCES ; } if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . InputLength > sizeof ( gpio_info ) ) return - EINVAL ; if ( copy_from_user ( & gpio_info , IoBuffer . InputBuffer , IoBuffer . InputLength ) ) return - EFAULT ; uiBit = gpio_info . uiGpioNumber ; uiOperation = gpio_info . uiGpioValue ; value = ( 1 << uiBit ) ; if ( IsReqGpioIsLedInNVM ( Adapter , value ) == FALSE ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Sorry,<S2SV_blank>Requested<S2SV_blank>GPIO<0x%X><S2SV_blank>is<S2SV_blank>not<S2SV_blank>correspond<S2SV_blank>to<S2SV_blank>LED<S2SV_blank>!!!"" , value ) ; Status = - EINVAL ; break ; } if ( uiOperation ) { Status = wrmaltWithLock ( Adapter , BCM_GPIO_OUTPUT_SET_REG , ( PUINT ) ( & value ) , sizeof ( UINT ) ) ; if ( Status == STATUS_SUCCESS ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Set<S2SV_blank>the<S2SV_blank>GPIO<S2SV_blank>bit\\n"" ) ; } else { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>the<S2SV_blank>%dth<S2SV_blank>GPIO\\n"" , uiBit ) ; break ; } } else { Status = wrmaltWithLock ( Adapter , BCM_GPIO_OUTPUT_CLR_REG , ( PUINT ) ( & value ) , sizeof ( UINT ) ) ; if ( Status == STATUS_SUCCESS ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Set<S2SV_blank>the<S2SV_blank>GPIO<S2SV_blank>bit\\n"" ) ; } else { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Failed<S2SV_blank>to<S2SV_blank>clear<S2SV_blank>the<S2SV_blank>%dth<S2SV_blank>GPIO\\n"" , uiBit ) ; break ; } } bytes = rdmaltWithLock ( Adapter , ( UINT ) GPIO_MODE_REGISTER , ( PUINT ) ucResetValue , sizeof ( UINT ) ) ; if ( bytes < 0 ) { Status = bytes ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""GPIO_MODE_REGISTER<S2SV_blank>read<S2SV_blank>failed"" ) ; break ; } else { Status = STATUS_SUCCESS ; } * ( UINT * ) ucResetValue |= ( 1 << uiBit ) ; Status = wrmaltWithLock ( Adapter , GPIO_MODE_REGISTER , ( PUINT ) ucResetValue , sizeof ( UINT ) ) ; if ( Status == STATUS_SUCCESS ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Set<S2SV_blank>the<S2SV_blank>GPIO<S2SV_blank>to<S2SV_blank>output<S2SV_blank>Mode\\n"" ) ; } else { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Failed<S2SV_blank>to<S2SV_blank>put<S2SV_blank>GPIO<S2SV_blank>in<S2SV_blank>Output<S2SV_blank>Mode\\n"" ) ; break ; } } break ; case BCM_LED_THREAD_STATE_CHANGE_REQ : { struct bcm_user_thread_req threadReq = { 0 } ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""User<S2SV_blank>made<S2SV_blank>LED<S2SV_blank>thread<S2SV_blank>InActive"" ) ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""GPIO<S2SV_blank>Can\'t<S2SV_blank>be<S2SV_blank>set/clear<S2SV_blank>in<S2SV_blank>Low<S2SV_blank>power<S2SV_blank>Mode"" ) ; Status = - EACCES ; break ; } if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . InputLength > sizeof ( threadReq ) ) return - EINVAL ; if ( copy_from_user ( & threadReq , IoBuffer . InputBuffer , IoBuffer . InputLength ) ) return - EFAULT ; if ( Adapter -> LEDInfo . led_thread_running ) { if ( threadReq . ThreadState == LED_THREAD_ACTIVATION_REQ ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Activating<S2SV_blank>thread<S2SV_blank>req"" ) ; Adapter -> DriverState = LED_THREAD_ACTIVE ; } else { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""DeActivating<S2SV_blank>Thread<S2SV_blank>req....."" ) ; Adapter -> DriverState = LED_THREAD_INACTIVE ; } wake_up ( & Adapter -> LEDInfo . notify_led_event ) ; } } break ; case IOCTL_BCM_GPIO_STATUS_REQUEST : { ULONG uiBit = 0 ; UCHAR ucRead [ 4 ] ; struct bcm_gpio_info gpio_info = { 0 } ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) return - EACCES ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . InputLength > sizeof ( gpio_info ) ) return - EINVAL ; if ( copy_from_user ( & gpio_info , IoBuffer . InputBuffer , IoBuffer . InputLength ) ) return - EFAULT ; uiBit = gpio_info . uiGpioNumber ; bytes = rdmaltWithLock ( Adapter , ( UINT ) GPIO_PIN_STATE_REGISTER , ( PUINT ) ucRead , sizeof ( UINT ) ) ; if ( bytes < 0 ) { Status = bytes ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""RDM<S2SV_blank>Failed\\n"" ) ; return Status ; } else { Status = STATUS_SUCCESS ; } } break ; case IOCTL_BCM_GPIO_MULTI_REQUEST : { UCHAR ucResetValue [ 4 ] ; struct bcm_gpio_multi_info gpio_multi_info [ MAX_IDX ] ; struct bcm_gpio_multi_info * pgpio_multi_info = ( struct bcm_gpio_multi_info * ) gpio_multi_info ; memset ( pgpio_multi_info , 0 , MAX_IDX * sizeof ( struct bcm_gpio_multi_info ) ) ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) return - EINVAL ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . InputLength > sizeof ( gpio_multi_info ) ) return - EINVAL ; if ( copy_from_user ( & gpio_multi_info , IoBuffer . InputBuffer , IoBuffer . InputLength ) ) return - EFAULT ; if ( IsReqGpioIsLedInNVM ( Adapter , pgpio_multi_info [ WIMAX_IDX ] . uiGPIOMask ) == FALSE ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Sorry,<S2SV_blank>Requested<S2SV_blank>GPIO<0x%X><S2SV_blank>is<S2SV_blank>not<S2SV_blank>correspond<S2SV_blank>to<S2SV_blank>NVM<S2SV_blank>LED<S2SV_blank>bit<S2SV_blank>map<0x%X>!!!"" , pgpio_multi_info [ WIMAX_IDX ] . uiGPIOMask , Adapter -> gpioBitMap ) ; Status = - EINVAL ; break ; } if ( ( pgpio_multi_info [ WIMAX_IDX ] . uiGPIOMask ) & ( pgpio_multi_info [ WIMAX_IDX ] . uiGPIOCommand ) ) { * ( UINT * ) ucResetValue = pgpio_multi_info [ WIMAX_IDX ] . uiGPIOMask & pgpio_multi_info [ WIMAX_IDX ] . uiGPIOCommand & pgpio_multi_info [ WIMAX_IDX ] . uiGPIOValue ; if ( * ( UINT * ) ucResetValue ) Status = wrmaltWithLock ( Adapter , BCM_GPIO_OUTPUT_SET_REG , ( PUINT ) ucResetValue , sizeof ( ULONG ) ) ; if ( Status != STATUS_SUCCESS ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""WRM<S2SV_blank>to<S2SV_blank>BCM_GPIO_OUTPUT_SET_REG<S2SV_blank>Failed."" ) ; return Status ; } * ( UINT * ) ucResetValue = ( pgpio_multi_info [ WIMAX_IDX ] . uiGPIOMask & pgpio_multi_info [ WIMAX_IDX ] . uiGPIOCommand & ( ~ ( pgpio_multi_info [ WIMAX_IDX ] . uiGPIOValue ) ) ) ; if ( * ( UINT * ) ucResetValue ) Status = wrmaltWithLock ( Adapter , BCM_GPIO_OUTPUT_CLR_REG , ( PUINT ) ucResetValue , sizeof ( ULONG ) ) ; if ( Status != STATUS_SUCCESS ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""WRM<S2SV_blank>to<S2SV_blank>BCM_GPIO_OUTPUT_CLR_REG<S2SV_blank>Failed."" ) ; return Status ; } } if ( pgpio_multi_info [ WIMAX_IDX ] . uiGPIOMask ) { bytes = rdmaltWithLock ( Adapter , ( UINT ) GPIO_PIN_STATE_REGISTER , ( PUINT ) ucResetValue , sizeof ( UINT ) ) ; if ( bytes < 0 ) { Status = bytes ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""RDM<S2SV_blank>to<S2SV_blank>GPIO_PIN_STATE_REGISTER<S2SV_blank>Failed."" ) ; return Status ; } else { Status = STATUS_SUCCESS ; } pgpio_multi_info [ WIMAX_IDX ] . uiGPIOValue = ( * ( UINT * ) ucResetValue & pgpio_multi_info [ WIMAX_IDX ] . uiGPIOMask ) ; } Status = copy_to_user ( IoBuffer . OutputBuffer , & gpio_multi_info , IoBuffer . OutputLength ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Failed<S2SV_blank>while<S2SV_blank>copying<S2SV_blank>Content<S2SV_blank>to<S2SV_blank>IOBufer<S2SV_blank>for<S2SV_blank>user<S2SV_blank>space<S2SV_blank>err:%d"" , Status ) ; return - EFAULT ; } } break ; case IOCTL_BCM_GPIO_MODE_REQUEST : { UCHAR ucResetValue [ 4 ] ; struct bcm_gpio_multi_mode gpio_multi_mode [ MAX_IDX ] ; struct bcm_gpio_multi_mode * pgpio_multi_mode = ( struct bcm_gpio_multi_mode * ) gpio_multi_mode ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) return - EINVAL ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . InputLength > sizeof ( gpio_multi_mode ) ) return - EINVAL ; if ( copy_from_user ( & gpio_multi_mode , IoBuffer . InputBuffer , IoBuffer . InputLength ) ) return - EFAULT ; bytes = rdmaltWithLock ( Adapter , ( UINT ) GPIO_MODE_REGISTER , ( PUINT ) ucResetValue , sizeof ( UINT ) ) ; if ( bytes < 0 ) { Status = bytes ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Read<S2SV_blank>of<S2SV_blank>GPIO_MODE_REGISTER<S2SV_blank>failed"" ) ; return Status ; } else { Status = STATUS_SUCCESS ; } if ( IsReqGpioIsLedInNVM ( Adapter , pgpio_multi_mode [ WIMAX_IDX ] . uiGPIOMask ) == FALSE ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Sorry,<S2SV_blank>Requested<S2SV_blank>GPIO<0x%X><S2SV_blank>is<S2SV_blank>not<S2SV_blank>correspond<S2SV_blank>to<S2SV_blank>NVM<S2SV_blank>LED<S2SV_blank>bit<S2SV_blank>map<0x%X>!!!"" , pgpio_multi_mode [ WIMAX_IDX ] . uiGPIOMask , Adapter -> gpioBitMap ) ; Status = - EINVAL ; break ; } if ( pgpio_multi_mode [ WIMAX_IDX ] . uiGPIOMask ) { * ( UINT * ) ucResetValue |= ( pgpio_multi_mode [ WIMAX_IDX ] . uiGPIOMode & pgpio_multi_mode [ WIMAX_IDX ] . uiGPIOMask ) ; * ( UINT * ) ucResetValue &= ~ ( ( ~ pgpio_multi_mode [ WIMAX_IDX ] . uiGPIOMode ) & pgpio_multi_mode [ WIMAX_IDX ] . uiGPIOMask ) ; pgpio_multi_mode [ WIMAX_IDX ] . uiGPIOMode = * ( UINT * ) ucResetValue ; Status = wrmaltWithLock ( Adapter , GPIO_MODE_REGISTER , ( PUINT ) ucResetValue , sizeof ( ULONG ) ) ; if ( Status == STATUS_SUCCESS ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""WRM<S2SV_blank>to<S2SV_blank>GPIO_MODE_REGISTER<S2SV_blank>Done"" ) ; } else { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""WRM<S2SV_blank>to<S2SV_blank>GPIO_MODE_REGISTER<S2SV_blank>Failed"" ) ; Status = - EFAULT ; break ; } } else { pgpio_multi_mode [ WIMAX_IDX ] . uiGPIOMode = * ( UINT * ) ucResetValue ; } Status = copy_to_user ( IoBuffer . OutputBuffer , & gpio_multi_mode , IoBuffer . OutputLength ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Failed<S2SV_blank>while<S2SV_blank>copying<S2SV_blank>Content<S2SV_blank>to<S2SV_blank>IOBufer<S2SV_blank>for<S2SV_blank>user<S2SV_blank>space<S2SV_blank>err:%d"" , Status ) ; return - EFAULT ; } } break ; case IOCTL_MAC_ADDR_REQ : case IOCTL_LINK_REQ : case IOCTL_CM_REQUEST : case IOCTL_SS_INFO_REQ : case IOCTL_SEND_CONTROL_MESSAGE : case IOCTL_IDLE_REQ : { PVOID pvBuffer = NULL ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . InputLength < sizeof ( struct bcm_link_request ) ) return - EINVAL ; if ( IoBuffer . InputLength > MAX_CNTL_PKT_SIZE ) return - EINVAL ; pvBuffer = memdup_user ( IoBuffer . InputBuffer , IoBuffer . InputLength ) ; if ( IS_ERR ( pvBuffer ) ) return PTR_ERR ( pvBuffer ) ; down ( & Adapter -> LowPowerModeSync ) ; Status = wait_event_interruptible_timeout ( Adapter -> lowpower_mode_wait_queue , ! Adapter -> bPreparingForLowPowerMode , ( 1 * HZ ) ) ; if ( Status == - ERESTARTSYS ) goto cntrlEnd ; if ( Adapter -> bPreparingForLowPowerMode ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Preparing<S2SV_blank>Idle<S2SV_blank>Mode<S2SV_blank>is<S2SV_blank>still<S2SV_blank>True<S2SV_blank>-<S2SV_blank>Hence<S2SV_blank>Rejecting<S2SV_blank>control<S2SV_blank>message\\n"" ) ; Status = STATUS_FAILURE ; goto cntrlEnd ; } Status = CopyBufferToControlPacket ( Adapter , ( PVOID ) pvBuffer ) ; cntrlEnd : up ( & Adapter -> LowPowerModeSync ) ; kfree ( pvBuffer ) ; break ; } case IOCTL_BCM_BUFFER_DOWNLOAD_START : { if ( down_trylock ( & Adapter -> NVMRdmWrmLock ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""IOCTL_BCM_CHIP_RESET<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>as<S2SV_blank>EEPROM<S2SV_blank>Read/Write<S2SV_blank>is<S2SV_blank>in<S2SV_blank>progress\\n"" ) ; return - EACCES ; } BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Starting<S2SV_blank>the<S2SV_blank>firmware<S2SV_blank>download<S2SV_blank>PID<S2SV_blank>=0x%x!!!!\\n"" , current -> pid ) ; if ( down_trylock ( & Adapter -> fw_download_sema ) ) return - EBUSY ; Adapter -> bBinDownloaded = FALSE ; Adapter -> fw_download_process_pid = current -> pid ; Adapter -> bCfgDownloaded = FALSE ; Adapter -> fw_download_done = FALSE ; netif_carrier_off ( Adapter -> dev ) ; netif_stop_queue ( Adapter -> dev ) ; Status = reset_card_proc ( Adapter ) ; if ( Status ) { pr_err ( PFX ""%s:<S2SV_blank>reset_card_proc<S2SV_blank>Failed!\\n"" , Adapter -> dev -> name ) ; up ( & Adapter -> fw_download_sema ) ; up ( & Adapter -> NVMRdmWrmLock ) ; return Status ; } mdelay ( 10 ) ; up ( & Adapter -> NVMRdmWrmLock ) ; return Status ; } case IOCTL_BCM_BUFFER_DOWNLOAD : { struct bcm_firmware_info * psFwInfo = NULL ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Starting<S2SV_blank>the<S2SV_blank>firmware<S2SV_blank>download<S2SV_blank>PID<S2SV_blank>=0x%x!!!!\\n"" , current -> pid ) ; if ( ! down_trylock ( & Adapter -> fw_download_sema ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Invalid<S2SV_blank>way<S2SV_blank>to<S2SV_blank>download<S2SV_blank>buffer.<S2SV_blank>Use<S2SV_blank>Start<S2SV_blank>and<S2SV_blank>then<S2SV_blank>call<S2SV_blank>this!!!\\n"" ) ; up ( & Adapter -> fw_download_sema ) ; Status = - EINVAL ; return Status ; } if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) { up ( & Adapter -> fw_download_sema ) ; return - EFAULT ; } BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Length<S2SV_blank>for<S2SV_blank>FW<S2SV_blank>DLD<S2SV_blank>is<S2SV_blank>:<S2SV_blank>%lx\\n"" , IoBuffer . InputLength ) ; if ( IoBuffer . InputLength > sizeof ( struct bcm_firmware_info ) ) { up ( & Adapter -> fw_download_sema ) ; return - EINVAL ; } psFwInfo = kmalloc ( sizeof ( * psFwInfo ) , GFP_KERNEL ) ; if ( ! psFwInfo ) { up ( & Adapter -> fw_download_sema ) ; return - ENOMEM ; } if ( copy_from_user ( psFwInfo , IoBuffer . InputBuffer , IoBuffer . InputLength ) ) { up ( & Adapter -> fw_download_sema ) ; kfree ( psFwInfo ) ; return - EFAULT ; } if ( ! psFwInfo -> pvMappedFirmwareAddress || ( psFwInfo -> u32FirmwareLength == 0 ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Something<S2SV_blank>else<S2SV_blank>is<S2SV_blank>wrong<S2SV_blank>%lu\\n"" , psFwInfo -> u32FirmwareLength ) ; up ( & Adapter -> fw_download_sema ) ; kfree ( psFwInfo ) ; Status = - EINVAL ; return Status ; } Status = bcm_ioctl_fw_download ( Adapter , psFwInfo ) ; if ( Status != STATUS_SUCCESS ) { if ( psFwInfo -> u32StartingAddress == CONFIG_BEGIN_ADDR ) BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""IOCTL:<S2SV_blank>Configuration<S2SV_blank>File<S2SV_blank>Upload<S2SV_blank>Failed\\n"" ) ; else BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""IOCTL:<S2SV_blank>Firmware<S2SV_blank>File<S2SV_blank>Upload<S2SV_blank>Failed\\n"" ) ; if ( Adapter -> LEDInfo . led_thread_running & BCM_LED_THREAD_RUNNING_ACTIVELY ) { Adapter -> DriverState = DRIVER_INIT ; Adapter -> LEDInfo . bLedInitDone = FALSE ; wake_up ( & Adapter -> LEDInfo . notify_led_event ) ; } } if ( Status != STATUS_SUCCESS ) up ( & Adapter -> fw_download_sema ) ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , OSAL_DBG , DBG_LVL_ALL , ""IOCTL:<S2SV_blank>Firmware<S2SV_blank>File<S2SV_blank>Uploaded\\n"" ) ; kfree ( psFwInfo ) ; return Status ; } case IOCTL_BCM_BUFFER_DOWNLOAD_STOP : { if ( ! down_trylock ( & Adapter -> fw_download_sema ) ) { up ( & Adapter -> fw_download_sema ) ; return - EINVAL ; } if ( down_trylock ( & Adapter -> NVMRdmWrmLock ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""FW<S2SV_blank>download<S2SV_blank>blocked<S2SV_blank>as<S2SV_blank>EEPROM<S2SV_blank>Read/Write<S2SV_blank>is<S2SV_blank>in<S2SV_blank>progress\\n"" ) ; up ( & Adapter -> fw_download_sema ) ; return - EACCES ; } Adapter -> bBinDownloaded = TRUE ; Adapter -> bCfgDownloaded = TRUE ; atomic_set ( & Adapter -> CurrNumFreeTxDesc , 0 ) ; Adapter -> CurrNumRecvDescs = 0 ; Adapter -> downloadDDR = 0 ; Status = run_card_proc ( Adapter ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Firm<S2SV_blank>Download<S2SV_blank>Failed\\n"" ) ; up ( & Adapter -> fw_download_sema ) ; up ( & Adapter -> NVMRdmWrmLock ) ; return Status ; } else { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Firm<S2SV_blank>Download<S2SV_blank>Over...\\n"" ) ; } mdelay ( 10 ) ; if ( StartInterruptUrb ( ( struct bcm_interface_adapter * ) Adapter -> pvInterfaceAdapter ) ) BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Unable<S2SV_blank>to<S2SV_blank>send<S2SV_blank>interrupt...\\n"" ) ; timeout = 5 * HZ ; Adapter -> waiting_to_fw_download_done = FALSE ; wait_event_timeout ( Adapter -> ioctl_fw_dnld_wait_queue , Adapter -> waiting_to_fw_download_done , timeout ) ; Adapter -> fw_download_process_pid = INVALID_PID ; Adapter -> fw_download_done = TRUE ; atomic_set ( & Adapter -> CurrNumFreeTxDesc , 0 ) ; Adapter -> CurrNumRecvDescs = 0 ; Adapter -> PrevNumRecvDescs = 0 ; atomic_set ( & Adapter -> cntrlpktCnt , 0 ) ; Adapter -> LinkUpStatus = 0 ; Adapter -> LinkStatus = 0 ; if ( Adapter -> LEDInfo . led_thread_running & BCM_LED_THREAD_RUNNING_ACTIVELY ) { Adapter -> DriverState = FW_DOWNLOAD_DONE ; wake_up ( & Adapter -> LEDInfo . notify_led_event ) ; } if ( ! timeout ) Status = - ENODEV ; up ( & Adapter -> fw_download_sema ) ; up ( & Adapter -> NVMRdmWrmLock ) ; return Status ; } case IOCTL_BE_BUCKET_SIZE : Status = 0 ; if ( get_user ( Adapter -> BEBucketSize , ( unsigned long __user * ) arg ) ) Status = - EFAULT ; break ; case IOCTL_RTPS_BUCKET_SIZE : Status = 0 ; if ( get_user ( Adapter -> rtPSBucketSize , ( unsigned long __user * ) arg ) ) Status = - EFAULT ; break ; case IOCTL_CHIP_RESET : { INT NVMAccess = down_trylock ( & Adapter -> NVMRdmWrmLock ) ; if ( NVMAccess ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""<S2SV_blank>IOCTL_BCM_CHIP_RESET<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>as<S2SV_blank>EEPROM<S2SV_blank>Read/Write<S2SV_blank>is<S2SV_blank>in<S2SV_blank>progress\\n"" ) ; return - EACCES ; } down ( & Adapter -> RxAppControlQueuelock ) ; Status = reset_card_proc ( Adapter ) ; flushAllAppQ ( ) ; up ( & Adapter -> RxAppControlQueuelock ) ; up ( & Adapter -> NVMRdmWrmLock ) ; ResetCounters ( Adapter ) ; break ; } case IOCTL_QOS_THRESHOLD : { USHORT uiLoopIndex ; Status = 0 ; for ( uiLoopIndex = 0 ; uiLoopIndex < NO_OF_QUEUES ; uiLoopIndex ++ ) { if ( get_user ( Adapter -> PackInfo [ uiLoopIndex ] . uiThreshold , ( unsigned long __user * ) arg ) ) { Status = - EFAULT ; break ; } } break ; } case IOCTL_DUMP_PACKET_INFO : DumpPackInfo ( Adapter ) ; DumpPhsRules ( & Adapter -> stBCMPhsContext ) ; Status = STATUS_SUCCESS ; break ; case IOCTL_GET_PACK_INFO : if ( copy_to_user ( argp , & Adapter -> PackInfo , sizeof ( struct bcm_packet_info ) * NO_OF_QUEUES ) ) return - EFAULT ; Status = STATUS_SUCCESS ; break ; case IOCTL_BCM_SWITCH_TRANSFER_MODE : { UINT uiData = 0 ; if ( copy_from_user ( & uiData , argp , sizeof ( UINT ) ) ) return - EFAULT ; if ( uiData ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""IOCTL_BCM_SWITCH_TRANSFER_MODE:<S2SV_blank>ETH_PACKET_TUNNELING_MODE\\n"" ) ; Adapter -> TransferMode = ETH_PACKET_TUNNELING_MODE ; } else { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""IOCTL_BCM_SWITCH_TRANSFER_MODE:<S2SV_blank>IP_PACKET_ONLY_MODE\\n"" ) ; Adapter -> TransferMode = IP_PACKET_ONLY_MODE ; } Status = STATUS_SUCCESS ; break ; } case IOCTL_BCM_GET_DRIVER_VERSION : { ulong len ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; len = min_t ( ulong , IoBuffer . OutputLength , strlen ( DRV_VERSION ) + 1 ) ; if ( copy_to_user ( IoBuffer . OutputBuffer , DRV_VERSION , len ) ) return - EFAULT ; Status = STATUS_SUCCESS ; break ; } case IOCTL_BCM_GET_CURRENT_STATUS : { struct bcm_link_state link_state ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""copy_from_user<S2SV_blank>failed..\\n"" ) ; return - EFAULT ; } if ( IoBuffer . OutputLength != sizeof ( link_state ) ) { Status = - EINVAL ; break ; } memset ( & link_state , 0 , sizeof ( link_state ) ) ; link_state . bIdleMode = Adapter -> IdleMode ; link_state . bShutdownMode = Adapter -> bShutStatus ; link_state . ucLinkStatus = Adapter -> LinkStatus ; if ( copy_to_user ( IoBuffer . OutputBuffer , & link_state , min_t ( size_t , sizeof ( link_state ) , IoBuffer . OutputLength ) ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Copy_to_user<S2SV_blank>Failed..\\n"" ) ; return - EFAULT ; } Status = STATUS_SUCCESS ; break ; } case IOCTL_BCM_SET_MAC_TRACING : { UINT tracing_flag ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( copy_from_user ( & tracing_flag , IoBuffer . InputBuffer , sizeof ( UINT ) ) ) return - EFAULT ; if ( tracing_flag ) Adapter -> pTarangs -> MacTracingEnabled = TRUE ; else Adapter -> pTarangs -> MacTracingEnabled = FALSE ; break ; } case IOCTL_BCM_GET_DSX_INDICATION : { ULONG ulSFId = 0 ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . OutputLength < sizeof ( struct bcm_add_indication_alt ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Mismatch<S2SV_blank>req:<S2SV_blank>%lx<S2SV_blank>needed<S2SV_blank>is<S2SV_blank>=0x%zx!!!"" , IoBuffer . OutputLength , sizeof ( struct bcm_add_indication_alt ) ) ; return - EINVAL ; } if ( copy_from_user ( & ulSFId , IoBuffer . InputBuffer , sizeof ( ulSFId ) ) ) return - EFAULT ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Get<S2SV_blank>DSX<S2SV_blank>Data<S2SV_blank>SF<S2SV_blank>ID<S2SV_blank>is<S2SV_blank>=%lx\\n"" , ulSFId ) ; get_dsx_sf_data_to_application ( Adapter , ulSFId , IoBuffer . OutputBuffer ) ; Status = STATUS_SUCCESS ; } break ; case IOCTL_BCM_GET_HOST_MIBS : { PVOID temp_buff ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . OutputLength != sizeof ( struct bcm_host_stats_mibs ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Length<S2SV_blank>Check<S2SV_blank>failed<S2SV_blank>%lu<S2SV_blank>%zd\\n"" , IoBuffer . OutputLength , sizeof ( struct bcm_host_stats_mibs ) ) ; return - EINVAL ; } temp_buff = kzalloc ( sizeof ( struct bcm_host_stats_mibs ) , GFP_KERNEL ) ; if ( ! temp_buff ) return STATUS_FAILURE ; Status = ProcessGetHostMibs ( Adapter , temp_buff ) ; GetDroppedAppCntrlPktMibs ( temp_buff , pTarang ) ; if ( Status != STATUS_FAILURE ) if ( copy_to_user ( IoBuffer . OutputBuffer , temp_buff , sizeof ( struct bcm_host_stats_mibs ) ) ) { kfree ( temp_buff ) ; return - EFAULT ; } kfree ( temp_buff ) ; break ; } case IOCTL_BCM_WAKE_UP_DEVICE_FROM_IDLE : if ( ( FALSE == Adapter -> bTriedToWakeUpFromlowPowerMode ) && ( TRUE == Adapter -> IdleMode ) ) { Adapter -> usIdleModePattern = ABORT_IDLE_MODE ; Adapter -> bWakeUpDevice = TRUE ; wake_up ( & Adapter -> process_rx_cntrlpkt ) ; } Status = STATUS_SUCCESS ; break ; case IOCTL_BCM_BULK_WRM : { struct bcm_bulk_wrm_buffer * pBulkBuffer ; UINT uiTempVar = 0 ; PCHAR pvBuffer = NULL ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Device<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode,<S2SV_blank>Blocking<S2SV_blank>Wrms\\n"" ) ; Status = - EACCES ; break ; } if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . InputLength < sizeof ( ULONG ) * 2 ) return - EINVAL ; pvBuffer = memdup_user ( IoBuffer . InputBuffer , IoBuffer . InputLength ) ; if ( IS_ERR ( pvBuffer ) ) return PTR_ERR ( pvBuffer ) ; pBulkBuffer = ( struct bcm_bulk_wrm_buffer * ) pvBuffer ; if ( ( ( ULONG ) pBulkBuffer -> Register & 0x0F000000 ) != 0x0F000000 || ( ( ULONG ) pBulkBuffer -> Register & 0x3 ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""WRM<S2SV_blank>Done<S2SV_blank>On<S2SV_blank>invalid<S2SV_blank>Address<S2SV_blank>:<S2SV_blank>%x<S2SV_blank>Access<S2SV_blank>Denied.\\n"" , ( int ) pBulkBuffer -> Register ) ; kfree ( pvBuffer ) ; Status = - EINVAL ; break ; } uiTempVar = pBulkBuffer -> Register & EEPROM_REJECT_MASK ; if ( ! ( ( Adapter -> pstargetparams -> m_u32Customize ) & VSG_MODE ) && ( ( uiTempVar == EEPROM_REJECT_REG_1 ) || ( uiTempVar == EEPROM_REJECT_REG_2 ) || ( uiTempVar == EEPROM_REJECT_REG_3 ) || ( uiTempVar == EEPROM_REJECT_REG_4 ) ) && ( cmd == IOCTL_BCM_REGISTER_WRITE ) ) { kfree ( pvBuffer ) ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""EEPROM<S2SV_blank>Access<S2SV_blank>Denied,<S2SV_blank>not<S2SV_blank>in<S2SV_blank>VSG<S2SV_blank>Mode\\n"" ) ; Status = - EFAULT ; break ; } if ( pBulkBuffer -> SwapEndian == FALSE ) Status = wrmWithLock ( Adapter , ( UINT ) pBulkBuffer -> Register , ( PCHAR ) pBulkBuffer -> Values , IoBuffer . InputLength - 2 * sizeof ( ULONG ) ) ; else Status = wrmaltWithLock ( Adapter , ( UINT ) pBulkBuffer -> Register , ( PUINT ) pBulkBuffer -> Values , IoBuffer . InputLength - 2 * sizeof ( ULONG ) ) ; if ( Status != STATUS_SUCCESS ) BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""WRM<S2SV_blank>Failed\\n"" ) ; kfree ( pvBuffer ) ; break ; } case IOCTL_BCM_GET_NVM_SIZE : if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( Adapter -> eNVMType == NVM_EEPROM || Adapter -> eNVMType == NVM_FLASH ) { if ( copy_to_user ( IoBuffer . OutputBuffer , & Adapter -> uiNVMDSDSize , sizeof ( UINT ) ) ) return - EFAULT ; } Status = STATUS_SUCCESS ; break ; case IOCTL_BCM_CAL_INIT : { UINT uiSectorSize = 0 ; if ( Adapter -> eNVMType == NVM_FLASH ) { if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( copy_from_user ( & uiSectorSize , IoBuffer . InputBuffer , sizeof ( UINT ) ) ) return - EFAULT ; if ( ( uiSectorSize < MIN_SECTOR_SIZE ) || ( uiSectorSize > MAX_SECTOR_SIZE ) ) { if ( copy_to_user ( IoBuffer . OutputBuffer , & Adapter -> uiSectorSize , sizeof ( UINT ) ) ) return - EFAULT ; } else { if ( IsFlash2x ( Adapter ) ) { if ( copy_to_user ( IoBuffer . OutputBuffer , & Adapter -> uiSectorSize , sizeof ( UINT ) ) ) return - EFAULT ; } else { if ( ( TRUE == Adapter -> bShutStatus ) || ( TRUE == Adapter -> IdleMode ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n"" ) ; return - EACCES ; } Adapter -> uiSectorSize = uiSectorSize ; BcmUpdateSectorSize ( Adapter , Adapter -> uiSectorSize ) ; } } Status = STATUS_SUCCESS ; } else { Status = STATUS_FAILURE ; } } break ; case IOCTL_BCM_SET_DEBUG : # ifdef DEBUG { struct bcm_user_debug_state sUserDebugState ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""In<S2SV_blank>SET_DEBUG<S2SV_blank>ioctl\\n"" ) ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( copy_from_user ( & sUserDebugState , IoBuffer . InputBuffer , sizeof ( struct bcm_user_debug_state ) ) ) return - EFAULT ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""IOCTL_BCM_SET_DEBUG:<S2SV_blank>OnOff=%d<S2SV_blank>Type<S2SV_blank>=<S2SV_blank>0x%x<S2SV_blank>"" , sUserDebugState . OnOff , sUserDebugState . Type ) ; sUserDebugState . Subtype = 1 << sUserDebugState . Subtype ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""actual<S2SV_blank>Subtype=0x%x\\n"" , sUserDebugState . Subtype ) ; Adapter -> stDebugState . type |= sUserDebugState . Type ; if ( sUserDebugState . OnOff ) Adapter -> stDebugState . subtype [ sUserDebugState . Type ] |= sUserDebugState . Subtype ; else Adapter -> stDebugState . subtype [ sUserDebugState . Type ] &= ~ sUserDebugState . Subtype ; BCM_SHOW_DEBUG_BITMAP ( Adapter ) ; } # endif break ; case IOCTL_BCM_NVM_READ : case IOCTL_BCM_NVM_WRITE : { struct bcm_nvm_readwrite stNVMReadWrite ; PUCHAR pReadData = NULL ; ULONG ulDSDMagicNumInUsrBuff = 0 ; struct timeval tv0 , tv1 ; memset ( & tv0 , 0 , sizeof ( struct timeval ) ) ; memset ( & tv1 , 0 , sizeof ( struct timeval ) ) ; if ( ( Adapter -> eNVMType == NVM_FLASH ) && ( Adapter -> uiFlashLayoutMajorVersion == 0 ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""The<S2SV_blank>Flash<S2SV_blank>Control<S2SV_blank>Section<S2SV_blank>is<S2SV_blank>Corrupted.<S2SV_blank>Hence<S2SV_blank>Rejection<S2SV_blank>on<S2SV_blank>NVM<S2SV_blank>Read/Write\\n"" ) ; return - EFAULT ; } if ( IsFlash2x ( Adapter ) ) { if ( ( Adapter -> eActiveDSD != DSD0 ) && ( Adapter -> eActiveDSD != DSD1 ) && ( Adapter -> eActiveDSD != DSD2 ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""No<S2SV_blank>DSD<S2SV_blank>is<S2SV_blank>active..hence<S2SV_blank>NVM<S2SV_blank>Command<S2SV_blank>is<S2SV_blank>blocked"" ) ; return STATUS_FAILURE ; } } if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( copy_from_user ( & stNVMReadWrite , ( IOCTL_BCM_NVM_READ == cmd ) ? IoBuffer . OutputBuffer : IoBuffer . InputBuffer , sizeof ( struct bcm_nvm_readwrite ) ) ) return - EFAULT ; if ( stNVMReadWrite . uiNumBytes > Adapter -> uiNVMDSDSize ) return STATUS_FAILURE ; if ( stNVMReadWrite . uiOffset > Adapter -> uiNVMDSDSize - stNVMReadWrite . uiNumBytes ) { return STATUS_FAILURE ; } pReadData = memdup_user ( stNVMReadWrite . pBuffer , stNVMReadWrite . uiNumBytes ) ; if ( IS_ERR ( pReadData ) ) return PTR_ERR ( pReadData ) ; do_gettimeofday ( & tv0 ) ; if ( IOCTL_BCM_NVM_READ == cmd ) { down ( & Adapter -> NVMRdmWrmLock ) ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n"" ) ; up ( & Adapter -> NVMRdmWrmLock ) ; kfree ( pReadData ) ; return - EACCES ; } Status = BeceemNVMRead ( Adapter , ( PUINT ) pReadData , stNVMReadWrite . uiOffset , stNVMReadWrite . uiNumBytes ) ; up ( & Adapter -> NVMRdmWrmLock ) ; if ( Status != STATUS_SUCCESS ) { kfree ( pReadData ) ; return Status ; } if ( copy_to_user ( stNVMReadWrite . pBuffer , pReadData , stNVMReadWrite . uiNumBytes ) ) { kfree ( pReadData ) ; return - EFAULT ; } } else { down ( & Adapter -> NVMRdmWrmLock ) ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n"" ) ; up ( & Adapter -> NVMRdmWrmLock ) ; kfree ( pReadData ) ; return - EACCES ; } Adapter -> bHeaderChangeAllowed = TRUE ; if ( IsFlash2x ( Adapter ) ) { Status = BcmFlash2xCorruptSig ( Adapter , Adapter -> eActiveDSD ) ; if ( Status != STATUS_SUCCESS ) { if ( ( ( stNVMReadWrite . uiOffset + stNVMReadWrite . uiNumBytes ) != Adapter -> uiNVMDSDSize ) || ( stNVMReadWrite . uiNumBytes < SIGNATURE_SIZE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""DSD<S2SV_blank>Sig<S2SV_blank>is<S2SV_blank>present<S2SV_blank>neither<S2SV_blank>in<S2SV_blank>Flash<S2SV_blank>nor<S2SV_blank>User<S2SV_blank>provided<S2SV_blank>Input.."" ) ; up ( & Adapter -> NVMRdmWrmLock ) ; kfree ( pReadData ) ; return Status ; } ulDSDMagicNumInUsrBuff = ntohl ( * ( PUINT ) ( pReadData + stNVMReadWrite . uiNumBytes - SIGNATURE_SIZE ) ) ; if ( ulDSDMagicNumInUsrBuff != DSD_IMAGE_MAGIC_NUMBER ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""DSD<S2SV_blank>Sig<S2SV_blank>is<S2SV_blank>present<S2SV_blank>neither<S2SV_blank>in<S2SV_blank>Flash<S2SV_blank>nor<S2SV_blank>User<S2SV_blank>provided<S2SV_blank>Input.."" ) ; up ( & Adapter -> NVMRdmWrmLock ) ; kfree ( pReadData ) ; return Status ; } } } Status = BeceemNVMWrite ( Adapter , ( PUINT ) pReadData , stNVMReadWrite . uiOffset , stNVMReadWrite . uiNumBytes , stNVMReadWrite . bVerify ) ; if ( IsFlash2x ( Adapter ) ) BcmFlash2xWriteSig ( Adapter , Adapter -> eActiveDSD ) ; Adapter -> bHeaderChangeAllowed = FALSE ; up ( & Adapter -> NVMRdmWrmLock ) ; if ( Status != STATUS_SUCCESS ) { kfree ( pReadData ) ; return Status ; } } do_gettimeofday ( & tv1 ) ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""<S2SV_blank>timetaken<S2SV_blank>by<S2SV_blank>Write/read<S2SV_blank>:%ld<S2SV_blank>msec\\n"" , ( tv1 . tv_sec - tv0 . tv_sec ) * 1000 + ( tv1 . tv_usec - tv0 . tv_usec ) / 1000 ) ; kfree ( pReadData ) ; return STATUS_SUCCESS ; } case IOCTL_BCM_FLASH2X_SECTION_READ : { struct bcm_flash2x_readwrite sFlash2xRead = { 0 } ; PUCHAR pReadBuff = NULL ; UINT NOB = 0 ; UINT BuffSize = 0 ; UINT ReadBytes = 0 ; UINT ReadOffset = 0 ; void __user * OutPutBuff ; if ( IsFlash2x ( Adapter ) != TRUE ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Flash<S2SV_blank>Does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>2.x<S2SV_blank>map"" ) ; return - EINVAL ; } BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""IOCTL_BCM_FLASH2X_SECTION_READ<S2SV_blank>Called"" ) ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( copy_from_user ( & sFlash2xRead , IoBuffer . InputBuffer , sizeof ( struct bcm_flash2x_readwrite ) ) ) return - EFAULT ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""\\nsFlash2xRead.Section<S2SV_blank>:%x"" , sFlash2xRead . Section ) ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""\\nsFlash2xRead.offset<S2SV_blank>:%x"" , sFlash2xRead . offset ) ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""\\nsFlash2xRead.numOfBytes<S2SV_blank>:%x"" , sFlash2xRead . numOfBytes ) ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""\\nsFlash2xRead.bVerify<S2SV_blank>:%x\\n"" , sFlash2xRead . bVerify ) ; if ( validateFlash2xReadWrite ( Adapter , & sFlash2xRead ) == FALSE ) return STATUS_FAILURE ; NOB = sFlash2xRead . numOfBytes ; if ( NOB > Adapter -> uiSectorSize ) BuffSize = Adapter -> uiSectorSize ; else BuffSize = NOB ; ReadOffset = sFlash2xRead . offset ; OutPutBuff = IoBuffer . OutputBuffer ; pReadBuff = ( PCHAR ) kzalloc ( BuffSize , GFP_KERNEL ) ; if ( pReadBuff == NULL ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Memory<S2SV_blank>allocation<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>Flash<S2SV_blank>2.x<S2SV_blank>Read<S2SV_blank>Structure"" ) ; return - ENOMEM ; } down ( & Adapter -> NVMRdmWrmLock ) ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n"" ) ; up ( & Adapter -> NVMRdmWrmLock ) ; kfree ( pReadBuff ) ; return - EACCES ; } while ( NOB ) { if ( NOB > Adapter -> uiSectorSize ) ReadBytes = Adapter -> uiSectorSize ; else ReadBytes = NOB ; Status = BcmFlash2xBulkRead ( Adapter , ( PUINT ) pReadBuff , sFlash2xRead . Section , ReadOffset , ReadBytes ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Flash<S2SV_blank>2x<S2SV_blank>read<S2SV_blank>err<S2SV_blank>with<S2SV_blank>Status<S2SV_blank>:%d"" , Status ) ; break ; } BCM_DEBUG_PRINT_BUFFER ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , pReadBuff , ReadBytes ) ; Status = copy_to_user ( OutPutBuff , pReadBuff , ReadBytes ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Copy<S2SV_blank>to<S2SV_blank>use<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>status<S2SV_blank>:%d"" , Status ) ; up ( & Adapter -> NVMRdmWrmLock ) ; kfree ( pReadBuff ) ; return - EFAULT ; } NOB = NOB - ReadBytes ; if ( NOB ) { ReadOffset = ReadOffset + ReadBytes ; OutPutBuff = OutPutBuff + ReadBytes ; } } up ( & Adapter -> NVMRdmWrmLock ) ; kfree ( pReadBuff ) ; } break ; case IOCTL_BCM_FLASH2X_SECTION_WRITE : { struct bcm_flash2x_readwrite sFlash2xWrite = { 0 } ; PUCHAR pWriteBuff ; void __user * InputAddr ; UINT NOB = 0 ; UINT BuffSize = 0 ; UINT WriteOffset = 0 ; UINT WriteBytes = 0 ; if ( IsFlash2x ( Adapter ) != TRUE ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Flash<S2SV_blank>Does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>2.x<S2SV_blank>map"" ) ; return - EINVAL ; } Adapter -> bAllDSDWriteAllow = FALSE ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""IOCTL_BCM_FLASH2X_SECTION_WRITE<S2SV_blank>Called"" ) ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( copy_from_user ( & sFlash2xWrite , IoBuffer . InputBuffer , sizeof ( struct bcm_flash2x_readwrite ) ) ) return - EFAULT ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""\\nsFlash2xRead.Section<S2SV_blank>:%x"" , sFlash2xWrite . Section ) ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""\\nsFlash2xRead.offset<S2SV_blank>:%d"" , sFlash2xWrite . offset ) ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""\\nsFlash2xRead.numOfBytes<S2SV_blank>:%x"" , sFlash2xWrite . numOfBytes ) ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""\\nsFlash2xRead.bVerify<S2SV_blank>:%x\\n"" , sFlash2xWrite . bVerify ) ; if ( ( sFlash2xWrite . Section != VSA0 ) && ( sFlash2xWrite . Section != VSA1 ) && ( sFlash2xWrite . Section != VSA2 ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Only<S2SV_blank>VSA<S2SV_blank>write<S2SV_blank>is<S2SV_blank>allowed"" ) ; return - EINVAL ; } if ( validateFlash2xReadWrite ( Adapter , & sFlash2xWrite ) == FALSE ) return STATUS_FAILURE ; InputAddr = sFlash2xWrite . pDataBuff ; WriteOffset = sFlash2xWrite . offset ; NOB = sFlash2xWrite . numOfBytes ; if ( NOB > Adapter -> uiSectorSize ) BuffSize = Adapter -> uiSectorSize ; else BuffSize = NOB ; pWriteBuff = kmalloc ( BuffSize , GFP_KERNEL ) ; if ( pWriteBuff == NULL ) return - ENOMEM ; WriteBytes = Adapter -> uiSectorSize ; if ( WriteOffset % Adapter -> uiSectorSize ) WriteBytes = Adapter -> uiSectorSize - ( WriteOffset % Adapter -> uiSectorSize ) ; if ( NOB < WriteBytes ) WriteBytes = NOB ; down ( & Adapter -> NVMRdmWrmLock ) ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n"" ) ; up ( & Adapter -> NVMRdmWrmLock ) ; kfree ( pWriteBuff ) ; return - EACCES ; } BcmFlash2xCorruptSig ( Adapter , sFlash2xWrite . Section ) ; do { Status = copy_from_user ( pWriteBuff , InputAddr , WriteBytes ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Copy<S2SV_blank>to<S2SV_blank>user<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>status<S2SV_blank>:%d"" , Status ) ; up ( & Adapter -> NVMRdmWrmLock ) ; kfree ( pWriteBuff ) ; return - EFAULT ; } BCM_DEBUG_PRINT_BUFFER ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , pWriteBuff , WriteBytes ) ; Status = BcmFlash2xBulkWrite ( Adapter , ( PUINT ) pWriteBuff , sFlash2xWrite . Section , WriteOffset , WriteBytes , sFlash2xWrite . bVerify ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Flash<S2SV_blank>2x<S2SV_blank>read<S2SV_blank>err<S2SV_blank>with<S2SV_blank>Status<S2SV_blank>:%d"" , Status ) ; break ; } NOB = NOB - WriteBytes ; if ( NOB ) { WriteOffset = WriteOffset + WriteBytes ; InputAddr = InputAddr + WriteBytes ; if ( NOB > Adapter -> uiSectorSize ) WriteBytes = Adapter -> uiSectorSize ; else WriteBytes = NOB ; } } while ( NOB > 0 ) ; BcmFlash2xWriteSig ( Adapter , sFlash2xWrite . Section ) ; up ( & Adapter -> NVMRdmWrmLock ) ; kfree ( pWriteBuff ) ; } break ; case IOCTL_BCM_GET_FLASH2X_SECTION_BITMAP : { struct bcm_flash2x_bitmap * psFlash2xBitMap ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""IOCTL_BCM_GET_FLASH2X_SECTION_BITMAP<S2SV_blank>Called"" ) ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . OutputLength != sizeof ( struct bcm_flash2x_bitmap ) ) return - EINVAL ; psFlash2xBitMap = kzalloc ( sizeof ( struct bcm_flash2x_bitmap ) , GFP_KERNEL ) ; if ( psFlash2xBitMap == NULL ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Memory<S2SV_blank>is<S2SV_blank>not<S2SV_blank>available"" ) ; return - ENOMEM ; } down ( & Adapter -> NVMRdmWrmLock ) ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n"" ) ; up ( & Adapter -> NVMRdmWrmLock ) ; kfree ( psFlash2xBitMap ) ; return - EACCES ; } BcmGetFlash2xSectionalBitMap ( Adapter , psFlash2xBitMap ) ; up ( & Adapter -> NVMRdmWrmLock ) ; if ( copy_to_user ( IoBuffer . OutputBuffer , psFlash2xBitMap , sizeof ( struct bcm_flash2x_bitmap ) ) ) { kfree ( psFlash2xBitMap ) ; return - EFAULT ; } kfree ( psFlash2xBitMap ) ; } break ; case IOCTL_BCM_SET_ACTIVE_SECTION : { enum bcm_flash2x_section_val eFlash2xSectionVal = 0 ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""IOCTL_BCM_SET_ACTIVE_SECTION<S2SV_blank>Called"" ) ; if ( IsFlash2x ( Adapter ) != TRUE ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Flash<S2SV_blank>Does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>2.x<S2SV_blank>map"" ) ; return - EINVAL ; } Status = copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Copy<S2SV_blank>of<S2SV_blank>IOCTL<S2SV_blank>BUFFER<S2SV_blank>failed"" ) ; return - EFAULT ; } Status = copy_from_user ( & eFlash2xSectionVal , IoBuffer . InputBuffer , sizeof ( INT ) ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Copy<S2SV_blank>of<S2SV_blank>flash<S2SV_blank>section<S2SV_blank>val<S2SV_blank>failed"" ) ; return - EFAULT ; } down ( & Adapter -> NVMRdmWrmLock ) ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n"" ) ; up ( & Adapter -> NVMRdmWrmLock ) ; return - EACCES ; } Status = BcmSetActiveSection ( Adapter , eFlash2xSectionVal ) ; if ( Status ) BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Failed<S2SV_blank>to<S2SV_blank>make<S2SV_blank>it\'s<S2SV_blank>priority<S2SV_blank>Highest.<S2SV_blank>Status<S2SV_blank>%d"" , Status ) ; up ( & Adapter -> NVMRdmWrmLock ) ; } break ; case IOCTL_BCM_IDENTIFY_ACTIVE_SECTION : { Adapter -> bAllDSDWriteAllow = FALSE ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""IOCTL_BCM_IDENTIFY_ACTIVE_SECTION<S2SV_blank>called"" ) ; Status = STATUS_SUCCESS ; } break ; case IOCTL_BCM_COPY_SECTION : { struct bcm_flash2x_copy_section sCopySectStrut = { 0 } ; Status = STATUS_SUCCESS ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""IOCTL_BCM_COPY_SECTION<S2SV_blank><S2SV_blank>Called"" ) ; Adapter -> bAllDSDWriteAllow = FALSE ; if ( IsFlash2x ( Adapter ) != TRUE ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Flash<S2SV_blank>Does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>2.x<S2SV_blank>map"" ) ; return - EINVAL ; } Status = copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Copy<S2SV_blank>of<S2SV_blank>IOCTL<S2SV_blank>BUFFER<S2SV_blank>failed<S2SV_blank>Status<S2SV_blank>:%d"" , Status ) ; return - EFAULT ; } Status = copy_from_user ( & sCopySectStrut , IoBuffer . InputBuffer , sizeof ( struct bcm_flash2x_copy_section ) ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Copy<S2SV_blank>of<S2SV_blank>Copy_Section_Struct<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>Status<S2SV_blank>:%d"" , Status ) ; return - EFAULT ; } BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Source<S2SV_blank>SEction<S2SV_blank>:%x"" , sCopySectStrut . SrcSection ) ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Destination<S2SV_blank>SEction<S2SV_blank>:%x"" , sCopySectStrut . DstSection ) ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""offset<S2SV_blank>:%x"" , sCopySectStrut . offset ) ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""NOB<S2SV_blank>:%x"" , sCopySectStrut . numOfBytes ) ; if ( IsSectionExistInFlash ( Adapter , sCopySectStrut . SrcSection ) == FALSE ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Source<S2SV_blank>Section<%x><S2SV_blank>does<S2SV_blank>not<S2SV_blank>exixt<S2SV_blank>in<S2SV_blank>Flash<S2SV_blank>"" , sCopySectStrut . SrcSection ) ; return - EINVAL ; } if ( IsSectionExistInFlash ( Adapter , sCopySectStrut . DstSection ) == FALSE ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Destinatio<S2SV_blank>Section<%x><S2SV_blank>does<S2SV_blank>not<S2SV_blank>exixt<S2SV_blank>in<S2SV_blank>Flash<S2SV_blank>"" , sCopySectStrut . DstSection ) ; return - EINVAL ; } if ( sCopySectStrut . SrcSection == sCopySectStrut . DstSection ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Source<S2SV_blank>and<S2SV_blank>Destination<S2SV_blank>section<S2SV_blank>should<S2SV_blank>be<S2SV_blank>different"" ) ; return - EINVAL ; } down ( & Adapter -> NVMRdmWrmLock ) ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n"" ) ; up ( & Adapter -> NVMRdmWrmLock ) ; return - EACCES ; } if ( sCopySectStrut . SrcSection == ISO_IMAGE1 || sCopySectStrut . SrcSection == ISO_IMAGE2 ) { if ( IsNonCDLessDevice ( Adapter ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Device<S2SV_blank>is<S2SV_blank>Non-CDLess<S2SV_blank>hence<S2SV_blank>won\'t<S2SV_blank>have<S2SV_blank>ISO<S2SV_blank>!!"" ) ; Status = - EINVAL ; } else if ( sCopySectStrut . numOfBytes == 0 ) { Status = BcmCopyISO ( Adapter , sCopySectStrut ) ; } else { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Partial<S2SV_blank>Copy<S2SV_blank>of<S2SV_blank>ISO<S2SV_blank>section<S2SV_blank>is<S2SV_blank>not<S2SV_blank>Allowed.."" ) ; Status = STATUS_FAILURE ; } up ( & Adapter -> NVMRdmWrmLock ) ; return Status ; } Status = BcmCopySection ( Adapter , sCopySectStrut . SrcSection , sCopySectStrut . DstSection , sCopySectStrut . offset , sCopySectStrut . numOfBytes ) ; up ( & Adapter -> NVMRdmWrmLock ) ; } break ; case IOCTL_BCM_GET_FLASH_CS_INFO : { Status = STATUS_SUCCESS ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""<S2SV_blank>IOCTL_BCM_GET_FLASH_CS_INFO<S2SV_blank>Called"" ) ; Status = copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Copy<S2SV_blank>of<S2SV_blank>IOCTL<S2SV_blank>BUFFER<S2SV_blank>failed"" ) ; return - EFAULT ; } if ( Adapter -> eNVMType != NVM_FLASH ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Connected<S2SV_blank>device<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>flash"" ) ; Status = - EINVAL ; break ; } if ( IsFlash2x ( Adapter ) == TRUE ) { if ( IoBuffer . OutputLength < sizeof ( struct bcm_flash2x_cs_info ) ) return - EINVAL ; if ( copy_to_user ( IoBuffer . OutputBuffer , Adapter -> psFlash2xCSInfo , sizeof ( struct bcm_flash2x_cs_info ) ) ) return - EFAULT ; } else { if ( IoBuffer . OutputLength < sizeof ( struct bcm_flash_cs_info ) ) return - EINVAL ; if ( copy_to_user ( IoBuffer . OutputBuffer , Adapter -> psFlashCSInfo , sizeof ( struct bcm_flash_cs_info ) ) ) return - EFAULT ; } } break ; case IOCTL_BCM_SELECT_DSD : { UINT SectOfset = 0 ; enum bcm_flash2x_section_val eFlash2xSectionVal ; eFlash2xSectionVal = NO_SECTION_VAL ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""IOCTL_BCM_SELECT_DSD<S2SV_blank>Called"" ) ; if ( IsFlash2x ( Adapter ) != TRUE ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Flash<S2SV_blank>Does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>2.x<S2SV_blank>map"" ) ; return - EINVAL ; } Status = copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Copy<S2SV_blank>of<S2SV_blank>IOCTL<S2SV_blank>BUFFER<S2SV_blank>failed"" ) ; return - EFAULT ; } Status = copy_from_user ( & eFlash2xSectionVal , IoBuffer . InputBuffer , sizeof ( INT ) ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Copy<S2SV_blank>of<S2SV_blank>flash<S2SV_blank>section<S2SV_blank>val<S2SV_blank>failed"" ) ; return - EFAULT ; } BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Read<S2SV_blank>Section<S2SV_blank>:%d"" , eFlash2xSectionVal ) ; if ( ( eFlash2xSectionVal != DSD0 ) && ( eFlash2xSectionVal != DSD1 ) && ( eFlash2xSectionVal != DSD2 ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Passed<S2SV_blank>section<%x><S2SV_blank>is<S2SV_blank>not<S2SV_blank>DSD<S2SV_blank>section"" , eFlash2xSectionVal ) ; return STATUS_FAILURE ; } SectOfset = BcmGetSectionValStartOffset ( Adapter , eFlash2xSectionVal ) ; if ( SectOfset == INVALID_OFFSET ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Provided<S2SV_blank>Section<S2SV_blank>val<S2SV_blank><%d><S2SV_blank>does<S2SV_blank>not<S2SV_blank>exixt<S2SV_blank>in<S2SV_blank>Flash<S2SV_blank>2.x"" , eFlash2xSectionVal ) ; return - EINVAL ; } Adapter -> bAllDSDWriteAllow = TRUE ; Adapter -> ulFlashCalStart = SectOfset ; Adapter -> eActiveDSD = eFlash2xSectionVal ; } Status = STATUS_SUCCESS ; break ; case IOCTL_BCM_NVM_RAW_READ : { struct bcm_nvm_readwrite stNVMRead ; INT NOB ; INT BuffSize ; INT ReadOffset = 0 ; UINT ReadBytes = 0 ; PUCHAR pReadBuff ; void __user * OutPutBuff ; if ( Adapter -> eNVMType != NVM_FLASH ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""NVM<S2SV_blank>TYPE<S2SV_blank>is<S2SV_blank>not<S2SV_blank>Flash"" ) ; return - EINVAL ; } if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""copy_from_user<S2SV_blank>1<S2SV_blank>failed\\n"" ) ; return - EFAULT ; } if ( copy_from_user ( & stNVMRead , IoBuffer . OutputBuffer , sizeof ( struct bcm_nvm_readwrite ) ) ) return - EFAULT ; NOB = stNVMRead . uiNumBytes ; if ( NOB > DEFAULT_BUFF_SIZE ) BuffSize = DEFAULT_BUFF_SIZE ; else BuffSize = NOB ; ReadOffset = stNVMRead . uiOffset ; OutPutBuff = stNVMRead . pBuffer ; pReadBuff = kzalloc ( BuffSize , GFP_KERNEL ) ; if ( pReadBuff == NULL ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Memory<S2SV_blank>allocation<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>Flash<S2SV_blank>2.x<S2SV_blank>Read<S2SV_blank>Structure"" ) ; Status = - ENOMEM ; break ; } down ( & Adapter -> NVMRdmWrmLock ) ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n"" ) ; kfree ( pReadBuff ) ; up ( & Adapter -> NVMRdmWrmLock ) ; return - EACCES ; } Adapter -> bFlashRawRead = TRUE ; while ( NOB ) { if ( NOB > DEFAULT_BUFF_SIZE ) ReadBytes = DEFAULT_BUFF_SIZE ; else ReadBytes = NOB ; Status = BeceemNVMRead ( Adapter , ( PUINT ) pReadBuff , ReadOffset , ReadBytes ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Flash<S2SV_blank>2x<S2SV_blank>read<S2SV_blank>err<S2SV_blank>with<S2SV_blank>Status<S2SV_blank>:%d"" , Status ) ; break ; } BCM_DEBUG_PRINT_BUFFER ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , pReadBuff , ReadBytes ) ; Status = copy_to_user ( OutPutBuff , pReadBuff , ReadBytes ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Copy<S2SV_blank>to<S2SV_blank>use<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>status<S2SV_blank>:%d"" , Status ) ; up ( & Adapter -> NVMRdmWrmLock ) ; kfree ( pReadBuff ) ; return - EFAULT ; } NOB = NOB - ReadBytes ; if ( NOB ) { ReadOffset = ReadOffset + ReadBytes ; OutPutBuff = OutPutBuff + ReadBytes ; } } Adapter -> bFlashRawRead = FALSE ; up ( & Adapter -> NVMRdmWrmLock ) ; kfree ( pReadBuff ) ; break ; } case IOCTL_BCM_CNTRLMSG_MASK : { ULONG RxCntrlMsgBitMask = 0 ; Status = copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""copy<S2SV_blank>of<S2SV_blank>Ioctl<S2SV_blank>buffer<S2SV_blank>is<S2SV_blank>failed<S2SV_blank>from<S2SV_blank>user<S2SV_blank>space"" ) ; return - EFAULT ; } if ( IoBuffer . InputLength != sizeof ( unsigned long ) ) { Status = - EINVAL ; break ; } Status = copy_from_user ( & RxCntrlMsgBitMask , IoBuffer . InputBuffer , IoBuffer . InputLength ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""copy<S2SV_blank>of<S2SV_blank>control<S2SV_blank>bit<S2SV_blank>mask<S2SV_blank>failed<S2SV_blank>from<S2SV_blank>user<S2SV_blank>space"" ) ; return - EFAULT ; } BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""\\n<S2SV_blank>Got<S2SV_blank>user<S2SV_blank>defined<S2SV_blank>cntrl<S2SV_blank>msg<S2SV_blank>bit<S2SV_blank>mask<S2SV_blank>:%lx"" , RxCntrlMsgBitMask ) ; pTarang -> RxCntrlMsgBitMask = RxCntrlMsgBitMask ; } break ; case IOCTL_BCM_GET_DEVICE_DRIVER_INFO : { struct bcm_driver_info DevInfo ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Called<S2SV_blank>IOCTL_BCM_GET_DEVICE_DRIVER_INFO\\n"" ) ; <S2SV_StartBug> DevInfo . MaxRDMBufferSize = BUFFER_4K ; <S2SV_EndBug> DevInfo . u32DSDStartOffset = EEPROM_CALPARAM_START ; DevInfo . u32RxAlignmentCorrection = 0 ; DevInfo . u32NVMType = Adapter -> eNVMType ; DevInfo . u32InterfaceType = BCM_USB ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . OutputLength < sizeof ( DevInfo ) ) return - EINVAL ; if ( copy_to_user ( IoBuffer . OutputBuffer , & DevInfo , sizeof ( DevInfo ) ) ) return - EFAULT ; } break ; case IOCTL_BCM_TIME_SINCE_NET_ENTRY : { struct bcm_time_elapsed stTimeElapsedSinceNetEntry = { 0 } ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""IOCTL_BCM_TIME_SINCE_NET_ENTRY<S2SV_blank>called"" ) ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . OutputLength < sizeof ( struct bcm_time_elapsed ) ) return - EINVAL ; stTimeElapsedSinceNetEntry . ul64TimeElapsedSinceNetEntry = get_seconds ( ) - Adapter -> liTimeSinceLastNetEntry ; if ( copy_to_user ( IoBuffer . OutputBuffer , & stTimeElapsedSinceNetEntry , sizeof ( struct bcm_time_elapsed ) ) ) return - EFAULT ; } break ; case IOCTL_CLOSE_NOTIFICATION : BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""IOCTL_CLOSE_NOTIFICATION"" ) ; break ; default : pr_info ( DRV_NAME "":<S2SV_blank>unknown<S2SV_blank>ioctl<S2SV_blank>cmd=%#x\\n"" , cmd ) ; Status = STATUS_FAILURE ; break ; } return Status ; }
","<S2SV_ModStart> ""Called<S2SV_blank>IOCTL_BCM_GET_DEVICE_DRIVER_INFO\\n"" ) ; memset ( & DevInfo , 0 , sizeof ( DevInfo ) ) ;
"
962,"CWE-119 static int decompress_i ( AVCodecContext * avctx , uint32_t * dst , int linesize ) { SCPRContext * s = avctx -> priv_data ; GetByteContext * gb = & s -> gb ; int cx = 0 , cx1 = 0 , k = 0 , clr = 0 ; int run , r , g , b , off , y = 0 , x = 0 , z , ret ; unsigned backstep = linesize - avctx -> width ; const int cxshift = s -> cxshift ; unsigned lx , ly , ptype ; reinit_tables ( s ) ; bytestream2_skip ( gb , 2 ) ; init_rangecoder ( & s -> rc , gb ) ; while ( k < avctx -> width + 1 ) { ret = decode_unit ( s , & s -> pixel_model [ 0 ] [ cx + cx1 ] , 400 , & r ) ; if ( ret < 0 ) return ret ; cx1 = ( cx << 6 ) & 0xFC0 ; cx = r >> cxshift ; ret = decode_unit ( s , & s -> pixel_model [ 1 ] [ cx + cx1 ] , 400 , & g ) ; if ( ret < 0 ) return ret ; cx1 = ( cx << 6 ) & 0xFC0 ; cx = g >> cxshift ; ret = decode_unit ( s , & s -> pixel_model [ 2 ] [ cx + cx1 ] , 400 , & b ) ; if ( ret < 0 ) return ret ; cx1 = ( cx << 6 ) & 0xFC0 ; cx = b >> cxshift ; ret = decode_value ( s , s -> run_model [ 0 ] , 256 , 400 , & run ) ; if ( ret < 0 ) return ret ; clr = ( b << 16 ) + ( g << 8 ) + r ; k += run ; while ( run -- > 0 ) { <S2SV_StartBug> dst [ y * linesize + x ] = clr ; <S2SV_EndBug> lx = x ; ly = y ; x ++ ; if ( x >= avctx -> width ) { x = 0 ; y ++ ; } } } off = - linesize - 1 ; ptype = 0 ; while ( x < avctx -> width && y < avctx -> height ) { ret = decode_value ( s , s -> op_model [ ptype ] , 6 , 1000 , & ptype ) ; if ( ret < 0 ) return ret ; if ( ptype == 0 ) { ret = decode_unit ( s , & s -> pixel_model [ 0 ] [ cx + cx1 ] , 400 , & r ) ; if ( ret < 0 ) return ret ; cx1 = ( cx << 6 ) & 0xFC0 ; cx = r >> cxshift ; ret = decode_unit ( s , & s -> pixel_model [ 1 ] [ cx + cx1 ] , 400 , & g ) ; if ( ret < 0 ) return ret ; cx1 = ( cx << 6 ) & 0xFC0 ; cx = g >> cxshift ; ret = decode_unit ( s , & s -> pixel_model [ 2 ] [ cx + cx1 ] , 400 , & b ) ; if ( ret < 0 ) return ret ; clr = ( b << 16 ) + ( g << 8 ) + r ; } if ( ptype > 5 ) return AVERROR_INVALIDDATA ; ret = decode_value ( s , s -> run_model [ ptype ] , 256 , 400 , & run ) ; if ( ret < 0 ) return ret ; switch ( ptype ) { case 0 : while ( run -- > 0 ) { if ( y >= avctx -> height ) return AVERROR_INVALIDDATA ; dst [ y * linesize + x ] = clr ; lx = x ; ly = y ; x ++ ; if ( x >= avctx -> width ) { x = 0 ; y ++ ; } } break ; case 1 : while ( run -- > 0 ) { if ( y >= avctx -> height ) return AVERROR_INVALIDDATA ; dst [ y * linesize + x ] = dst [ ly * linesize + lx ] ; lx = x ; ly = y ; x ++ ; if ( x >= avctx -> width ) { x = 0 ; y ++ ; } } clr = dst [ ly * linesize + lx ] ; break ; case 2 : while ( run -- > 0 ) { if ( y < 1 || y >= avctx -> height ) return AVERROR_INVALIDDATA ; clr = dst [ y * linesize + x + off + 1 ] ; dst [ y * linesize + x ] = clr ; lx = x ; ly = y ; x ++ ; if ( x >= avctx -> width ) { x = 0 ; y ++ ; } } break ; case 4 : while ( run -- > 0 ) { uint8_t * odst = ( uint8_t * ) dst ; if ( y < 1 || y >= avctx -> height || ( y == 1 && x == 0 ) ) return AVERROR_INVALIDDATA ; if ( x == 0 ) { z = backstep ; } else { z = 0 ; } r = odst [ ( ly * linesize + lx ) * 4 ] + odst [ ( ( y * linesize + x ) + off - z ) * 4 + 4 ] - odst [ ( ( y * linesize + x ) + off - z ) * 4 ] ; g = odst [ ( ly * linesize + lx ) * 4 + 1 ] + odst [ ( ( y * linesize + x ) + off - z ) * 4 + 5 ] - odst [ ( ( y * linesize + x ) + off - z ) * 4 + 1 ] ; b = odst [ ( ly * linesize + lx ) * 4 + 2 ] + odst [ ( ( y * linesize + x ) + off - z ) * 4 + 6 ] - odst [ ( ( y * linesize + x ) + off - z ) * 4 + 2 ] ; clr = ( ( b & 0xFF ) << 16 ) + ( ( g & 0xFF ) << 8 ) + ( r & 0xFF ) ; dst [ y * linesize + x ] = clr ; lx = x ; ly = y ; x ++ ; if ( x >= avctx -> width ) { x = 0 ; y ++ ; } } break ; case 5 : while ( run -- > 0 ) { if ( y < 1 || y >= avctx -> height || ( y == 1 && x == 0 ) ) return AVERROR_INVALIDDATA ; if ( x == 0 ) { z = backstep ; } else { z = 0 ; } clr = dst [ y * linesize + x + off - z ] ; dst [ y * linesize + x ] = clr ; lx = x ; ly = y ; x ++ ; if ( x >= avctx -> width ) { x = 0 ; y ++ ; } } break ; } if ( avctx -> bits_per_coded_sample == 16 ) { cx1 = ( clr & 0x3F00 ) >> 2 ; cx = ( clr & 0xFFFFFF ) >> 16 ; } else { cx1 = ( clr & 0xFC00 ) >> 4 ; cx = ( clr & 0xFFFFFF ) >> 18 ; } } return 0 ; }
","<S2SV_ModStart> 0 ) { if ( y >= avctx -> height ) return AVERROR_INVALIDDATA ;
"
963,"CWE-20 static int net_ctl_permissions ( struct ctl_table_header * head , struct ctl_table * table ) { struct net * net = container_of ( head -> set , struct net , sysctls ) ; kuid_t root_uid = make_kuid ( net -> user_ns , 0 ) ; kgid_t root_gid = make_kgid ( net -> user_ns , 0 ) ; if ( ns_capable ( net -> user_ns , CAP_NET_ADMIN ) || <S2SV_StartBug> uid_eq ( root_uid , current_uid ( ) ) ) { <S2SV_EndBug> int mode = ( table -> mode >> 6 ) & 7 ; return ( mode << 6 ) | ( mode << 3 ) | mode ; } <S2SV_StartBug> if ( gid_eq ( root_gid , current_gid ( ) ) ) { <S2SV_EndBug> int mode = ( table -> mode >> 3 ) & 7 ; return ( mode << 3 ) | mode ; } return table -> mode ; }
","<S2SV_ModStart> ( root_uid , current_euid <S2SV_ModEnd> ( ) ) <S2SV_ModStart> } if ( in_egroup_p ( root_gid <S2SV_ModEnd> ) ) {
"
964,"CWE-119 static int xpm_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) { XPMDecContext * x = avctx -> priv_data ; AVFrame * p = data ; <S2SV_StartBug> const uint8_t * end , * ptr = avpkt -> data ; <S2SV_EndBug> int ncolors , cpp , ret , i , j ; int64_t size ; uint32_t * dst ; avctx -> pix_fmt = AV_PIX_FMT_BGRA ; <S2SV_StartBug> end = avpkt -> data + avpkt -> size ; <S2SV_EndBug> <S2SV_StartBug> while ( memcmp ( ptr , ""/*<S2SV_blank>XPM<S2SV_blank>*/"" , 9 ) && ptr < end - 9 ) <S2SV_EndBug> ptr ++ ; if ( ptr >= end ) { av_log ( avctx , AV_LOG_ERROR , ""missing<S2SV_blank>signature\\n"" ) ; return AVERROR_INVALIDDATA ; } ptr += mod_strcspn ( ptr , ""\\"""" ) ; if ( sscanf ( ptr , ""\\""%u<S2SV_blank>%u<S2SV_blank>%u<S2SV_blank>%u\\"","" , & avctx -> width , & avctx -> height , & ncolors , & cpp ) != 4 ) { av_log ( avctx , AV_LOG_ERROR , ""missing<S2SV_blank>image<S2SV_blank>parameters\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( ( ret = ff_set_dimensions ( avctx , avctx -> width , avctx -> height ) ) < 0 ) return ret ; if ( ( ret = ff_get_buffer ( avctx , p , 0 ) ) < 0 ) return ret ; if ( cpp <= 0 || cpp >= 5 ) { av_log ( avctx , AV_LOG_ERROR , ""unsupported/invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>chars<S2SV_blank>per<S2SV_blank>pixel:<S2SV_blank>%d\\n"" , cpp ) ; return AVERROR_INVALIDDATA ; } size = 1 ; for ( i = 0 ; i < cpp ; i ++ ) <S2SV_StartBug> size *= 94 ; <S2SV_EndBug> if ( ncolors <= 0 || ncolors > size ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>colors:<S2SV_blank>%d\\n"" , ncolors ) ; return AVERROR_INVALIDDATA ; } size *= 4 ; av_fast_padded_malloc ( & x -> pixels , & x -> pixels_size , size ) ; if ( ! x -> pixels ) return AVERROR ( ENOMEM ) ; ptr += mod_strcspn ( ptr , "","" ) + 1 ; <S2SV_StartBug> for ( i = 0 ; i < ncolors ; i ++ ) { <S2SV_EndBug> const uint8_t * index ; int len ; ptr += mod_strcspn ( ptr , ""\\"""" ) + 1 ; <S2SV_StartBug> if ( ptr + cpp > end ) <S2SV_EndBug> return AVERROR_INVALIDDATA ; index = ptr ; ptr += cpp ; ptr = strstr ( ptr , ""c<S2SV_blank>"" ) ; if ( ptr ) { ptr += 2 ; } else { return AVERROR_INVALIDDATA ; } len = strcspn ( ptr , ""\\""<S2SV_blank>"" ) ; if ( ( ret = ascii2index ( index , cpp ) ) < 0 ) return ret ; x -> pixels [ ret ] = color_string_to_rgba ( ptr , len ) ; ptr += mod_strcspn ( ptr , "","" ) + 1 ; <S2SV_StartBug> } <S2SV_EndBug> for ( i = 0 ; i < avctx -> height ; i ++ ) { dst = ( uint32_t * ) ( p -> data [ 0 ] + i * p -> linesize [ 0 ] ) ; <S2SV_StartBug> ptr += mod_strcspn ( ptr , ""\\"""" ) + 1 ; <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < avctx -> width ; j ++ ) { <S2SV_EndBug> <S2SV_StartBug> if ( ptr + cpp > end ) <S2SV_EndBug> return AVERROR_INVALIDDATA ; if ( ( ret = ascii2index ( ptr , cpp ) ) < 0 ) return ret ; * dst ++ = x -> pixels [ ret ] ; ptr += cpp ; } ptr += mod_strcspn ( ptr , "","" ) + 1 ; } p -> key_frame = 1 ; p -> pict_type = AV_PICTURE_TYPE_I ; * got_frame = 1 ; return avpkt -> size ; }
","<S2SV_ModStart> , * ptr <S2SV_ModEnd> ; int ncolors <S2SV_ModStart> = AV_PIX_FMT_BGRA ; av_fast_padded_malloc ( & x -> buf , & x -> buf_size , avpkt -> size ) ; if ( ! x -> buf ) return AVERROR ( ENOMEM ) ; memcpy ( x -> buf , avpkt -> data , avpkt -> size ) ; x -> buf [ avpkt -> size ] = 0 ; ptr = x -> buf ; end = x -> buf <S2SV_ModEnd> + avpkt -> <S2SV_ModStart> ; while ( end - ptr > 9 && <S2SV_ModStart> , 9 ) ) ptr ++ ; if ( end - ptr <= 9 <S2SV_ModEnd> ) { av_log <S2SV_ModStart> ) size *= 95 <S2SV_ModEnd> ; if ( <S2SV_ModStart> + 1 ; if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> ; if ( end - ptr < cpp <S2SV_ModEnd> ) return AVERROR_INVALIDDATA <S2SV_ModStart> + 1 ; if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> ] ) ; if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> + 1 ; if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> { if ( end - ptr < cpp <S2SV_ModEnd> ) return AVERROR_INVALIDDATA
"
965,"CWE-119 void monitor_apply_keystate ( struct monitor * pmonitor ) { struct ssh * ssh = active_state ; struct kex * kex ; int r ; debug3 ( ""%s:<S2SV_blank>packet_set_state"" , __func__ ) ; if ( ( r = ssh_packet_set_state ( ssh , child_state ) ) != 0 ) fatal ( ""%s:<S2SV_blank>packet_set_state:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; sshbuf_free ( child_state ) ; child_state = NULL ; if ( ( kex = ssh -> kex ) != NULL ) { # ifdef WITH_OPENSSL kex -> kex [ KEX_DH_GRP1_SHA1 ] = kexdh_server ; kex -> kex [ KEX_DH_GRP14_SHA1 ] = kexdh_server ; kex -> kex [ KEX_DH_GRP14_SHA256 ] = kexdh_server ; kex -> kex [ KEX_DH_GRP16_SHA512 ] = kexdh_server ; kex -> kex [ KEX_DH_GRP18_SHA512 ] = kexdh_server ; kex -> kex [ KEX_DH_GEX_SHA1 ] = kexgex_server ; kex -> kex [ KEX_DH_GEX_SHA256 ] = kexgex_server ; kex -> kex [ KEX_ECDH_SHA2 ] = kexecdh_server ; # endif kex -> kex [ KEX_C25519_SHA256 ] = kexc25519_server ; kex -> load_host_public_key = & get_hostkey_public_by_type ; kex -> load_host_private_key = & get_hostkey_private_by_type ; kex -> host_key_index = & get_hostkey_index ; kex -> sign = sshd_hostkey_sign ; } <S2SV_StartBug> if ( options . compression ) { <S2SV_EndBug> ssh_packet_set_compress_hooks ( ssh , pmonitor -> m_zlib , ( ssh_packet_comp_alloc_func * ) mm_zalloc , ( ssh_packet_comp_free_func * ) mm_zfree ) ; } }
","<S2SV_ModStart> sshd_hostkey_sign ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
"
966,"CWE-401 static Image * ReadBMPImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { BMPInfo bmp_info ; Image * image ; MagickBooleanType status ; MagickOffsetType offset , profile_data , profile_size , start_position ; MemoryInfo * pixel_info ; Quantum index ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bit , bytes_per_line , length ; ssize_t count , y ; unsigned char magick [ 12 ] , * pixels ; unsigned int blue , green , offset_bits , red ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) memset ( & bmp_info , 0 , sizeof ( bmp_info ) ) ; bmp_info . ba_offset = 0 ; start_position = 0 ; offset_bits = 0 ; count = ReadBlob ( image , 2 , magick ) ; if ( count != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { PixelInfo quantum_bits ; PixelPacket shift ; start_position = TellBlob ( image ) - 2 ; bmp_info . ba_offset = 0 ; while ( LocaleNCompare ( ( char * ) magick , ""BA"" , 2 ) == 0 ) { bmp_info . file_size = ReadBlobLSBLong ( image ) ; bmp_info . ba_offset = ReadBlobLSBLong ( image ) ; bmp_info . offset_bits = ReadBlobLSBLong ( image ) ; count = ReadBlob ( image , 2 , magick ) ; if ( count != 2 ) break ; } if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Magick:<S2SV_blank>%c%c"" , magick [ 0 ] , magick [ 1 ] ) ; if ( ( count != 2 ) || ( ( LocaleNCompare ( ( char * ) magick , ""BM"" , 2 ) != 0 ) && ( LocaleNCompare ( ( char * ) magick , ""CI"" , 2 ) != 0 ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; bmp_info . file_size = ReadBlobLSBLong ( image ) ; ( void ) ReadBlobLSBLong ( image ) ; bmp_info . offset_bits = ReadBlobLSBLong ( image ) ; bmp_info . size = ReadBlobLSBLong ( image ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>BMP<S2SV_blank>size:<S2SV_blank>%u"" , bmp_info . size ) ; profile_data = 0 ; profile_size = 0 ; if ( bmp_info . size == 12 ) { ( void ) CopyMagickString ( image -> magick , ""BMP2"" , MagickPathExtent ) ; bmp_info . width = ( ssize_t ) ( ( short ) ReadBlobLSBShort ( image ) ) ; bmp_info . height = ( ssize_t ) ( ( short ) ReadBlobLSBShort ( image ) ) ; bmp_info . planes = ReadBlobLSBShort ( image ) ; bmp_info . bits_per_pixel = ReadBlobLSBShort ( image ) ; bmp_info . x_pixels = 0 ; bmp_info . y_pixels = 0 ; bmp_info . number_colors = 0 ; bmp_info . compression = BI_RGB ; bmp_info . image_size = 0 ; bmp_info . alpha_mask = 0 ; if ( image -> debug != MagickFalse ) { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Format:<S2SV_blank>OS/2<S2SV_blank>Bitmap"" ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Geometry:<S2SV_blank>%.20gx%.20g"" , ( double ) bmp_info . width , ( double ) bmp_info . height ) ; } } else { if ( bmp_info . size < 40 ) ThrowReaderException ( CorruptImageError , ""NonOS2HeaderSizeError"" ) ; bmp_info . width = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; bmp_info . height = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; bmp_info . planes = ReadBlobLSBShort ( image ) ; bmp_info . bits_per_pixel = ReadBlobLSBShort ( image ) ; bmp_info . compression = ReadBlobLSBLong ( image ) ; bmp_info . image_size = ReadBlobLSBLong ( image ) ; bmp_info . x_pixels = ReadBlobLSBLong ( image ) ; bmp_info . y_pixels = ReadBlobLSBLong ( image ) ; bmp_info . number_colors = ReadBlobLSBLong ( image ) ; if ( ( MagickSizeType ) bmp_info . number_colors > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; bmp_info . colors_important = ReadBlobLSBLong ( image ) ; if ( image -> debug != MagickFalse ) { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Format:<S2SV_blank>MS<S2SV_blank>Windows<S2SV_blank>bitmap"" ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Geometry:<S2SV_blank>%.20gx%.20g"" , ( double ) bmp_info . width , ( double ) bmp_info . height ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Bits<S2SV_blank>per<S2SV_blank>pixel:<S2SV_blank>%.20g"" , ( double ) bmp_info . bits_per_pixel ) ; switch ( bmp_info . compression ) { case BI_RGB : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RGB"" ) ; break ; } case BI_RLE4 : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RLE4"" ) ; break ; } case BI_RLE8 : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RLE8"" ) ; break ; } case BI_BITFIELDS : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_BITFIELDS"" ) ; break ; } case BI_PNG : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_PNG"" ) ; break ; } case BI_JPEG : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_JPEG"" ) ; break ; } default : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>UNKNOWN<S2SV_blank>(%u)"" , bmp_info . compression ) ; } } ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Number<S2SV_blank>of<S2SV_blank>colors:<S2SV_blank>%u"" , bmp_info . number_colors ) ; } bmp_info . red_mask = ReadBlobLSBLong ( image ) ; bmp_info . green_mask = ReadBlobLSBLong ( image ) ; bmp_info . blue_mask = ReadBlobLSBLong ( image ) ; if ( bmp_info . size > 40 ) { double gamma ; bmp_info . alpha_mask = ReadBlobLSBLong ( image ) ; bmp_info . colorspace = ReadBlobLSBSignedLong ( image ) ; # define BMP_DENOM ( ( double ) 0x40000000 ) bmp_info . red_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . red_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . red_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . green_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . green_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . green_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . blue_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . blue_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . blue_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; gamma = bmp_info . red_primary . x + bmp_info . red_primary . y + bmp_info . red_primary . z ; gamma = PerceptibleReciprocal ( gamma ) ; bmp_info . red_primary . x *= gamma ; bmp_info . red_primary . y *= gamma ; image -> chromaticity . red_primary . x = bmp_info . red_primary . x ; image -> chromaticity . red_primary . y = bmp_info . red_primary . y ; gamma = bmp_info . green_primary . x + bmp_info . green_primary . y + bmp_info . green_primary . z ; gamma = PerceptibleReciprocal ( gamma ) ; bmp_info . green_primary . x *= gamma ; bmp_info . green_primary . y *= gamma ; image -> chromaticity . green_primary . x = bmp_info . green_primary . x ; image -> chromaticity . green_primary . y = bmp_info . green_primary . y ; gamma = bmp_info . blue_primary . x + bmp_info . blue_primary . y + bmp_info . blue_primary . z ; gamma = PerceptibleReciprocal ( gamma ) ; bmp_info . blue_primary . x *= gamma ; bmp_info . blue_primary . y *= gamma ; image -> chromaticity . blue_primary . x = bmp_info . blue_primary . x ; image -> chromaticity . blue_primary . y = bmp_info . blue_primary . y ; bmp_info . gamma_scale . x = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; bmp_info . gamma_scale . y = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; bmp_info . gamma_scale . z = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; image -> gamma = ( bmp_info . gamma_scale . x + bmp_info . gamma_scale . y + bmp_info . gamma_scale . z ) / 3.0 ; } else ( void ) CopyMagickString ( image -> magick , ""BMP3"" , MagickPathExtent ) ; if ( bmp_info . size > 108 ) { size_t intent ; intent = ReadBlobLSBLong ( image ) ; switch ( ( int ) intent ) { case LCS_GM_BUSINESS : { image -> rendering_intent = SaturationIntent ; break ; } case LCS_GM_GRAPHICS : { image -> rendering_intent = RelativeIntent ; break ; } case LCS_GM_IMAGES : { image -> rendering_intent = PerceptualIntent ; break ; } case LCS_GM_ABS_COLORIMETRIC : { image -> rendering_intent = AbsoluteIntent ; break ; } } profile_data = ( MagickOffsetType ) ReadBlobLSBLong ( image ) ; profile_size = ( MagickOffsetType ) ReadBlobLSBLong ( image ) ; ( void ) ReadBlobLSBLong ( image ) ; } } if ( ( MagickSizeType ) bmp_info . file_size > GetBlobSize ( image ) ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageError , ""LengthAndFilesizeDoNotMatch"" , ""`%s\'"" , image -> filename ) ; else if ( ( MagickSizeType ) bmp_info . file_size < GetBlobSize ( image ) ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageWarning , ""LengthAndFilesizeDoNotMatch"" , ""`%s\'"" , image -> filename ) ; if ( bmp_info . width <= 0 ) ThrowReaderException ( CorruptImageError , ""NegativeOrZeroImageSize"" ) ; if ( bmp_info . height == 0 ) ThrowReaderException ( CorruptImageError , ""NegativeOrZeroImageSize"" ) ; if ( bmp_info . planes != 1 ) ThrowReaderException ( CorruptImageError , ""StaticPlanesValueNotEqualToOne"" ) ; if ( ( bmp_info . bits_per_pixel != 1 ) && ( bmp_info . bits_per_pixel != 4 ) && ( bmp_info . bits_per_pixel != 8 ) && ( bmp_info . bits_per_pixel != 16 ) && ( bmp_info . bits_per_pixel != 24 ) && ( bmp_info . bits_per_pixel != 32 ) ) ThrowReaderException ( CorruptImageError , ""UnsupportedBitsPerPixel"" ) ; if ( bmp_info . bits_per_pixel < 16 && bmp_info . number_colors > ( 1U << bmp_info . bits_per_pixel ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedNumberOfColors"" ) ; if ( ( bmp_info . compression == 1 ) && ( bmp_info . bits_per_pixel != 8 ) ) ThrowReaderException ( CorruptImageError , ""UnsupportedBitsPerPixel"" ) ; if ( ( bmp_info . compression == 2 ) && ( bmp_info . bits_per_pixel != 4 ) ) ThrowReaderException ( CorruptImageError , ""UnsupportedBitsPerPixel"" ) ; if ( ( bmp_info . compression == 3 ) && ( bmp_info . bits_per_pixel < 16 ) ) ThrowReaderException ( CorruptImageError , ""UnsupportedBitsPerPixel"" ) ; switch ( bmp_info . compression ) { case BI_RGB : image -> compression = NoCompression ; break ; case BI_RLE8 : case BI_RLE4 : image -> compression = RLECompression ; break ; case BI_BITFIELDS : break ; case BI_JPEG : ThrowReaderException ( CoderError , ""JPEGCompressNotSupported"" ) ; case BI_PNG : ThrowReaderException ( CoderError , ""PNGCompressNotSupported"" ) ; default : ThrowReaderException ( CorruptImageError , ""UnrecognizedImageCompression"" ) ; } image -> columns = ( size_t ) MagickAbsoluteValue ( bmp_info . width ) ; image -> rows = ( size_t ) MagickAbsoluteValue ( bmp_info . height ) ; image -> depth = bmp_info . bits_per_pixel <= 8 ? bmp_info . bits_per_pixel : 8 ; image -> alpha_trait = ( ( bmp_info . alpha_mask != 0 ) && ( bmp_info . compression == BI_BITFIELDS ) ) ? BlendPixelTrait : UndefinedPixelTrait ; if ( bmp_info . bits_per_pixel < 16 ) { size_t one ; image -> storage_class = PseudoClass ; image -> colors = bmp_info . number_colors ; one = 1 ; if ( image -> colors == 0 ) image -> colors = one << bmp_info . bits_per_pixel ; } image -> resolution . x = ( double ) bmp_info . x_pixels / 100.0 ; image -> resolution . y = ( double ) bmp_info . y_pixels / 100.0 ; image -> units = PixelsPerCentimeterResolution ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( image -> storage_class == PseudoClass ) { unsigned char * bmp_colormap ; size_t packet_size ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Reading<S2SV_blank>colormap<S2SV_blank>of<S2SV_blank>%.20g<S2SV_blank>colors"" , ( double ) image -> colors ) ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; bmp_colormap = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) image -> colors , 4 * sizeof ( * bmp_colormap ) ) ; if ( bmp_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( ( bmp_info . size == 12 ) || ( bmp_info . size == 64 ) ) packet_size = 3 ; else packet_size = 4 ; offset = SeekBlob ( image , start_position + 14 + bmp_info . size , SEEK_SET ) ; if ( offset < 0 ) { bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ; ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } count = ReadBlob ( image , packet_size * image -> colors , bmp_colormap ) ; if ( count != ( ssize_t ) ( packet_size * image -> colors ) ) { bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ; ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } p = bmp_colormap ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ; if ( packet_size == 4 ) p ++ ; } bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ; } if ( bmp_info . offset_bits == offset_bits ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; offset_bits = bmp_info . offset_bits ; offset = SeekBlob ( image , start_position + bmp_info . offset_bits , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( bmp_info . compression == BI_RLE4 ) bmp_info . bits_per_pixel <<= 1 ; bytes_per_line = 4 * ( ( image -> columns * bmp_info . bits_per_pixel + 31 ) / 32 ) ; length = ( size_t ) bytes_per_line * image -> rows ; if ( ( MagickSizeType ) ( length / 256 ) > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( ( bmp_info . compression == BI_RGB ) || ( bmp_info . compression == BI_BITFIELDS ) ) { pixel_info = AcquireVirtualMemory ( image -> rows , MagickMax ( bytes_per_line , image -> columns + 256UL ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Reading<S2SV_blank>pixels<S2SV_blank>(%.20g<S2SV_blank>bytes)"" , ( double ) length ) ; count = ReadBlob ( image , length , pixels ) ; if ( count != ( ssize_t ) length ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } } else { pixel_info = AcquireVirtualMemory ( image -> rows , MagickMax ( bytes_per_line , image -> columns + 256UL ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; status = DecodeImage ( image , bmp_info . compression , pixels , image -> columns * image -> rows ) ; if ( status == MagickFalse ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToRunlengthDecodeImage"" ) ; } } if ( bmp_info . compression == BI_RGB ) { if ( ( image -> alpha_trait == UndefinedPixelTrait ) && ( bmp_info . size == 40 ) && ( bmp_info . bits_per_pixel == 32 ) ) { bytes_per_line = 4 * ( image -> columns ) ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( * ( p + 3 ) != 0 ) { image -> alpha_trait = BlendPixelTrait ; y = - 1 ; break ; } p += 4 ; } } } bmp_info . alpha_mask = image -> alpha_trait != UndefinedPixelTrait ? 0xff000000U : 0U ; bmp_info . red_mask = 0x00ff0000U ; bmp_info . green_mask = 0x0000ff00U ; bmp_info . blue_mask = 0x000000ffU ; if ( bmp_info . bits_per_pixel == 16 ) { bmp_info . red_mask = 0x00007c00U ; bmp_info . green_mask = 0x000003e0U ; bmp_info . blue_mask = 0x0000001fU ; } } ( void ) memset ( & shift , 0 , sizeof ( shift ) ) ; ( void ) memset ( & quantum_bits , 0 , sizeof ( quantum_bits ) ) ; if ( ( bmp_info . bits_per_pixel == 16 ) || ( bmp_info . bits_per_pixel == 32 ) ) { register unsigned int sample ; if ( bmp_info . red_mask != 0 ) while ( ( ( bmp_info . red_mask << shift . red ) & 0x80000000UL ) == 0 ) { shift . red ++ ; if ( shift . red >= 32U ) break ; } if ( bmp_info . green_mask != 0 ) while ( ( ( bmp_info . green_mask << shift . green ) & 0x80000000UL ) == 0 ) { shift . green ++ ; if ( shift . green >= 32U ) break ; } if ( bmp_info . blue_mask != 0 ) while ( ( ( bmp_info . blue_mask << shift . blue ) & 0x80000000UL ) == 0 ) { shift . blue ++ ; if ( shift . blue >= 32U ) break ; } if ( bmp_info . alpha_mask != 0 ) while ( ( ( bmp_info . alpha_mask << shift . alpha ) & 0x80000000UL ) == 0 ) { shift . alpha ++ ; if ( shift . alpha >= 32U ) break ; } sample = shift . red ; while ( ( ( bmp_info . red_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . red = ( MagickRealType ) ( sample - shift . red ) ; sample = shift . green ; while ( ( ( bmp_info . green_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . green = ( MagickRealType ) ( sample - shift . green ) ; sample = shift . blue ; while ( ( ( bmp_info . blue_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . blue = ( MagickRealType ) ( sample - shift . blue ) ; sample = shift . alpha ; while ( ( ( bmp_info . alpha_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . alpha = ( MagickRealType ) ( sample - shift . alpha ) ; } switch ( bmp_info . bits_per_pixel ) { case 1 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { index = ( Quantum ) ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ? 0x01 : 0x00 ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( image -> columns % 8 ) ; bit ++ ) { index = ( Quantum ) ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ? 0x01 : 0x00 ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; break ; } case 4 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { ValidateColormapValue ( image , ( ssize_t ) ( ( * p >> 4 ) & 0x0f ) , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; ValidateColormapValue ( image , ( ssize_t ) ( * p & 0x0f ) , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; } if ( ( image -> columns % 2 ) != 0 ) { ValidateColormapValue ( image , ( ssize_t ) ( ( * p >> 4 ) & 0xf ) , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; x ++ ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; break ; } case 8 : { if ( ( bmp_info . compression == BI_RLE8 ) || ( bmp_info . compression == BI_RLE4 ) ) bytes_per_line = image -> columns ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = ( ssize_t ) image -> columns ; x != 0 ; -- x ) { ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; break ; } case 16 : { unsigned int alpha , pixel ; if ( ( bmp_info . compression != BI_RGB ) && ( bmp_info . compression != BI_BITFIELDS ) ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnrecognizedImageCompression"" ) ; } bytes_per_line = 2 * ( image -> columns + image -> columns % 2 ) ; image -> storage_class = DirectClass ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { pixel = ( unsigned int ) ( * p ++ ) ; pixel |= ( * p ++ ) << 8 ; red = ( ( pixel & bmp_info . red_mask ) << shift . red ) >> 16 ; if ( quantum_bits . red == 5 ) red |= ( ( red & 0xe000 ) >> 5 ) ; if ( quantum_bits . red <= 8 ) red |= ( ( red & 0xff00 ) >> 8 ) ; green = ( ( pixel & bmp_info . green_mask ) << shift . green ) >> 16 ; if ( quantum_bits . green == 5 ) green |= ( ( green & 0xe000 ) >> 5 ) ; if ( quantum_bits . green == 6 ) green |= ( ( green & 0xc000 ) >> 6 ) ; if ( quantum_bits . green <= 8 ) green |= ( ( green & 0xff00 ) >> 8 ) ; blue = ( ( pixel & bmp_info . blue_mask ) << shift . blue ) >> 16 ; if ( quantum_bits . blue == 5 ) blue |= ( ( blue & 0xe000 ) >> 5 ) ; if ( quantum_bits . blue <= 8 ) blue |= ( ( blue & 0xff00 ) >> 8 ) ; SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) red ) , q ) ; SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) green ) , q ) ; SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) blue ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) { alpha = ( ( pixel & bmp_info . alpha_mask ) << shift . alpha ) >> 16 ; if ( quantum_bits . alpha <= 8 ) alpha |= ( ( alpha & 0xff00 ) >> 8 ) ; SetPixelAlpha ( image , ScaleShortToQuantum ( ( unsigned short ) alpha ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 24 : { bytes_per_line = 4 * ( ( image -> columns * 24 + 31 ) / 32 ) ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 32 : { if ( ( bmp_info . compression != BI_RGB ) && ( bmp_info . compression != BI_BITFIELDS ) ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnrecognizedImageCompression"" ) ; } bytes_per_line = 4 * ( image -> columns ) ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { unsigned int alpha , pixel ; p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { pixel = ( unsigned int ) ( * p ++ ) ; pixel |= ( ( unsigned int ) * p ++ << 8 ) ; pixel |= ( ( unsigned int ) * p ++ << 16 ) ; pixel |= ( ( unsigned int ) * p ++ << 24 ) ; red = ( ( pixel & bmp_info . red_mask ) << shift . red ) >> 16 ; if ( quantum_bits . red == 8 ) red |= ( red >> 8 ) ; green = ( ( pixel & bmp_info . green_mask ) << shift . green ) >> 16 ; if ( quantum_bits . green == 8 ) green |= ( green >> 8 ) ; blue = ( ( pixel & bmp_info . blue_mask ) << shift . blue ) >> 16 ; if ( quantum_bits . blue == 8 ) blue |= ( blue >> 8 ) ; SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) red ) , q ) ; SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) green ) , q ) ; SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) blue ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) { alpha = ( ( pixel & bmp_info . alpha_mask ) << shift . alpha ) >> 16 ; if ( quantum_bits . alpha == 8 ) alpha |= ( alpha >> 8 ) ; SetPixelAlpha ( image , ScaleShortToQuantum ( ( unsigned short ) alpha ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } default : { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } } pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( y > 0 ) break ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( bmp_info . height < 0 ) { Image * flipped_image ; flipped_image = FlipImage ( image , exception ) ; if ( flipped_image != ( Image * ) NULL ) { DuplicateBlob ( flipped_image , image ) ; ReplaceImageInList ( & image , flipped_image ) ; image = flipped_image ; } } if ( ( bmp_info . colorspace == 0x4D424544L ) && ( profile_data > 0 ) && ( profile_size > 0 ) ) { StringInfo * profile ; unsigned char * datum ; offset = start_position + 14 + profile_data ; if ( ( offset < TellBlob ( image ) ) || ( SeekBlob ( image , offset , SEEK_SET ) != offset ) || ( GetBlobSize ( image ) < ( MagickSizeType ) ( offset + profile_size ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; profile = AcquireStringInfo ( ( size_t ) profile_size ) ; if ( profile == ( StringInfo * ) NULL ) ThrowReaderException ( CorruptImageError , ""MemoryAllocationFailed"" ) ; datum = GetStringInfoDatum ( profile ) ; if ( ReadBlob ( image , ( size_t ) profile_size , datum ) == ( ssize_t ) profile_size ) { MagickOffsetType profile_size_orig ; profile_size_orig = ( MagickOffsetType ) datum [ 0 ] << 24 ; profile_size_orig |= ( MagickOffsetType ) datum [ 1 ] << 16 ; profile_size_orig |= ( MagickOffsetType ) datum [ 2 ] << 8 ; profile_size_orig |= ( MagickOffsetType ) datum [ 3 ] ; if ( profile_size_orig < profile_size ) SetStringInfoLength ( profile , ( size_t ) profile_size_orig ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""Profile:<S2SV_blank>ICC,<S2SV_blank>%u<S2SV_blank>bytes"" , ( unsigned int ) profile_size_orig ) ; ( void ) SetImageProfile ( image , ""icc"" , profile , exception ) ; } profile = DestroyStringInfo ( profile ) ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; offset = ( MagickOffsetType ) bmp_info . ba_offset ; if ( offset != 0 ) if ( ( offset < TellBlob ( image ) ) || ( SeekBlob ( image , offset , SEEK_SET ) != offset ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; * magick = '\\0' ; count = ReadBlob ( image , 2 , magick ) ; if ( ( count == 2 ) && ( IsBMP ( magick , 2 ) != MagickFalse ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; <S2SV_StartBug> return ( ( Image * ) NULL ) ; <S2SV_EndBug> } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( IsBMP ( magick , 2 ) != MagickFalse ) ; ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> = MagickFalse ; break <S2SV_ModEnd> ; } image
"
967,"CWE-763 static OM_uint32 acc_ctx_hints ( OM_uint32 * minor_status , gss_ctx_id_t * ctx , spnego_gss_cred_id_t spcred , gss_buffer_t * mechListMIC , OM_uint32 * negState , send_token_flag * return_token ) { OM_uint32 tmpmin , ret ; gss_OID_set supported_mechSet ; spnego_gss_ctx_id_t sc = NULL ; * mechListMIC = GSS_C_NO_BUFFER ; supported_mechSet = GSS_C_NO_OID_SET ; * return_token = NO_TOKEN_SEND ; * negState = REJECT ; * minor_status = 0 ; if ( * ctx != GSS_C_NO_CONTEXT ) return GSS_S_DEFECTIVE_TOKEN ; ret = get_negotiable_mechs ( minor_status , spcred , GSS_C_ACCEPT , & supported_mechSet ) ; if ( ret != GSS_S_COMPLETE ) goto cleanup ; ret = make_NegHints ( minor_status , mechListMIC ) ; if ( ret != GSS_S_COMPLETE ) goto cleanup ; <S2SV_StartBug> sc = create_spnego_ctx ( ) ; <S2SV_EndBug> if ( sc == NULL ) { ret = GSS_S_FAILURE ; goto cleanup ; } if ( put_mech_set ( supported_mechSet , & sc -> DER_mechTypes ) < 0 ) { ret = GSS_S_FAILURE ; goto cleanup ; } sc -> internal_mech = GSS_C_NO_OID ; * negState = ACCEPT_INCOMPLETE ; * return_token = INIT_TOKEN_SEND ; sc -> firstpass = 1 ; * ctx = ( gss_ctx_id_t ) sc ; sc = NULL ; ret = GSS_S_COMPLETE ; cleanup : release_spnego_ctx ( & sc ) ; gss_release_oid_set ( & tmpmin , & supported_mechSet ) ; return ret ; }
","<S2SV_ModStart> = create_spnego_ctx ( 0
"
968,"CWE-20 static int llc_ui_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sockaddr_llc * uaddr = ( struct sockaddr_llc * ) msg -> msg_name ; const int nonblock = flags & MSG_DONTWAIT ; struct sk_buff * skb = NULL ; struct sock * sk = sock -> sk ; struct llc_sock * llc = llc_sk ( sk ) ; unsigned long cpu_flags ; size_t copied = 0 ; u32 peek_seq = 0 ; u32 * seq ; unsigned long used ; int target ; <S2SV_StartBug> long timeo ; <S2SV_EndBug> msg -> msg_namelen = 0 ; lock_sock ( sk ) ; copied = - ENOTCONN ; if ( unlikely ( sk -> sk_type == SOCK_STREAM && sk -> sk_state == TCP_LISTEN ) ) goto out ; timeo = sock_rcvtimeo ( sk , nonblock ) ; seq = & llc -> copied_seq ; if ( flags & MSG_PEEK ) { peek_seq = llc -> copied_seq ; seq = & peek_seq ; } target = sock_rcvlowat ( sk , flags & MSG_WAITALL , len ) ; copied = 0 ; do { u32 offset ; if ( signal_pending ( current ) ) { if ( copied ) break ; copied = timeo ? sock_intr_errno ( timeo ) : - EAGAIN ; break ; } skb = skb_peek ( & sk -> sk_receive_queue ) ; if ( skb ) { offset = * seq ; goto found_ok_skb ; } if ( copied >= target && ! sk -> sk_backlog . tail ) break ; if ( copied ) { if ( sk -> sk_err || sk -> sk_state == TCP_CLOSE || ( sk -> sk_shutdown & RCV_SHUTDOWN ) || ! timeo || ( flags & MSG_PEEK ) ) break ; } else { if ( sock_flag ( sk , SOCK_DONE ) ) break ; if ( sk -> sk_err ) { copied = sock_error ( sk ) ; break ; } if ( sk -> sk_shutdown & RCV_SHUTDOWN ) break ; if ( sk -> sk_type == SOCK_STREAM && sk -> sk_state == TCP_CLOSE ) { if ( ! sock_flag ( sk , SOCK_DONE ) ) { copied = - ENOTCONN ; break ; } break ; } if ( ! timeo ) { copied = - EAGAIN ; break ; } } if ( copied >= target ) { release_sock ( sk ) ; lock_sock ( sk ) ; } else sk_wait_data ( sk , & timeo ) ; if ( ( flags & MSG_PEEK ) && peek_seq != llc -> copied_seq ) { net_dbg_ratelimited ( ""LLC(%s:%d):<S2SV_blank>Application<S2SV_blank>bug,<S2SV_blank>race<S2SV_blank>in<S2SV_blank>MSG_PEEK\\n"" , current -> comm , task_pid_nr ( current ) ) ; peek_seq = llc -> copied_seq ; } continue ; found_ok_skb : used = skb -> len - offset ; if ( len < used ) used = len ; if ( ! ( flags & MSG_TRUNC ) ) { int rc = skb_copy_datagram_iovec ( skb , offset , msg -> msg_iov , used ) ; if ( rc ) { if ( ! copied ) copied = - EFAULT ; break ; } } * seq += used ; copied += used ; len -= used ; if ( sk -> sk_type != SOCK_STREAM ) goto copy_uaddr ; if ( ! ( flags & MSG_PEEK ) ) { spin_lock_irqsave ( & sk -> sk_receive_queue . lock , cpu_flags ) ; sk_eat_skb ( sk , skb , false ) ; spin_unlock_irqrestore ( & sk -> sk_receive_queue . lock , cpu_flags ) ; * seq = 0 ; } if ( used + offset < skb -> len ) continue ; } while ( len > 0 ) ; out : release_sock ( sk ) ; return copied ; copy_uaddr : if ( uaddr != NULL && skb != NULL ) { memcpy ( uaddr , llc_ui_skb_cb ( skb ) , sizeof ( * uaddr ) ) ; msg -> msg_namelen = sizeof ( * uaddr ) ; } if ( llc_sk ( sk ) -> cmsg_flags ) llc_cmsg_rcv ( msg , skb ) ; if ( ! ( flags & MSG_PEEK ) ) { spin_lock_irqsave ( & sk -> sk_receive_queue . lock , cpu_flags ) ; sk_eat_skb ( sk , skb , false ) ; spin_unlock_irqrestore ( & sk -> sk_receive_queue . lock , cpu_flags ) ; * seq = 0 ; } goto out ; }
","<S2SV_ModStart> ; long timeo <S2SV_ModEnd> ; lock_sock (
"
969,"CWE-617 static void pci_lintr_route ( struct pci_vdev * dev ) { struct businfo * bi ; struct intxinfo * ii ; if ( dev -> lintr . pin == 0 ) return ; bi = pci_businfo [ dev -> bus ] ; <S2SV_StartBug> assert ( bi != NULL ) ; <S2SV_EndBug> ii = & bi -> slotinfo [ dev -> slot ] . si_intpins [ dev -> lintr . pin - 1 ] ; if ( ii -> ii_ioapic_irq == 0 ) ii -> ii_ioapic_irq = ioapic_pci_alloc_irq ( dev ) ; <S2SV_StartBug> assert ( ii -> ii_ioapic_irq > 0 ) ; <S2SV_EndBug> if ( ii -> ii_pirq_pin == 0 ) <S2SV_StartBug> ii -> ii_pirq_pin = pirq_alloc_pin ( dev ) ; <S2SV_EndBug> assert ( ii -> ii_pirq_pin > 0 ) ; dev -> lintr . ioapic_irq = ii -> ii_ioapic_irq ; dev -> lintr . pirq_pin = ii -> ii_pirq_pin ; pci_set_cfgdata8 ( dev , PCIR_INTLINE , pirq_irq ( ii -> ii_pirq_pin ) ) ; }
","<S2SV_ModStart> bus ] ; if ( bi == NULL ) { pr_err ( ""%s:<S2SV_blank>pci<S2SV_blank>[%s]<S2SV_blank>has<S2SV_blank>wrong<S2SV_blank>bus<S2SV_blank>%d<S2SV_blank>info!\\n"" , __func__ , dev -> name , dev -> bus ) ; return ; } <S2SV_ModEnd> ii = & <S2SV_ModStart> dev ) ; <S2SV_ModEnd> if ( ii <S2SV_ModStart> pirq_alloc_pin ( dev <S2SV_ModEnd> ) ; dev
"
970,"CWE-119 SQLWCHAR * _multi_string_alloc_and_expand ( LPCSTR in ) { SQLWCHAR * chr ; int len = 0 ; if ( ! in ) { <S2SV_StartBug> return in ; <S2SV_EndBug> } while ( in [ len ] != 0 || in [ len + 1 ] != 0 ) { len ++ ; } chr = malloc ( sizeof ( SQLWCHAR ) * ( len + 2 ) ) ; len = 0 ; while ( in [ len ] != 0 || in [ len + 1 ] != 0 ) { chr [ len ] = in [ len ] ; len ++ ; } chr [ len ++ ] = 0 ; chr [ len ++ ] = 0 ; return chr ; }
","<S2SV_ModStart> ) { return NULL <S2SV_ModEnd> ; } while
"
971,"CWE-264 static int do_remount ( struct path * path , int flags , int mnt_flags , void * data ) { int err ; struct super_block * sb = path -> mnt -> mnt_sb ; struct mount * mnt = real_mount ( path -> mnt ) ; if ( ! check_mnt ( mnt ) ) return - EINVAL ; if ( path -> dentry != path -> mnt -> mnt_root ) return - EINVAL ; err = security_sb_remount ( sb , data ) ; if ( err ) return err ; down_write ( & sb -> s_umount ) ; if ( flags & MS_BIND ) err = change_mount_flags ( path -> mnt , flags ) ; else if ( ! capable ( CAP_SYS_ADMIN ) ) err = - EPERM ; else err = do_remount_sb ( sb , flags , data , 0 ) ; if ( ! err ) { lock_mount_hash ( ) ; <S2SV_StartBug> mnt_flags |= mnt -> mnt . mnt_flags & MNT_PROPAGATION_MASK ; <S2SV_EndBug> mnt -> mnt . mnt_flags = mnt_flags ; touch_mnt_namespace ( mnt -> mnt_ns ) ; unlock_mount_hash ( ) ; } up_write ( & sb -> s_umount ) ; return err ; }
","<S2SV_ModStart> . mnt_flags & ~ MNT_USER_SETTABLE_MASK <S2SV_ModEnd> ; mnt ->
"
972,"CWE-125 int _yr_scan_verify_re_match ( YR_SCAN_CONTEXT * context , YR_AC_MATCH * ac_match , uint8_t * data , size_t data_size , size_t data_base , size_t offset ) { CALLBACK_ARGS callback_args ; RE_EXEC_FUNC exec ; int forward_matches = - 1 ; int backward_matches = - 1 ; int flags = 0 ; if ( STRING_IS_GREEDY_REGEXP ( ac_match -> string ) ) flags |= RE_FLAGS_GREEDY ; if ( STRING_IS_NO_CASE ( ac_match -> string ) ) flags |= RE_FLAGS_NO_CASE ; if ( STRING_IS_DOT_ALL ( ac_match -> string ) ) flags |= RE_FLAGS_DOT_ALL ; if ( STRING_IS_FAST_REGEXP ( ac_match -> string ) ) exec = yr_re_fast_exec ; else exec = yr_re_exec ; if ( STRING_IS_ASCII ( ac_match -> string ) ) { forward_matches = exec ( ac_match -> forward_code , data + offset , data_size - offset , <S2SV_StartBug> offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags , <S2SV_EndBug> NULL , NULL ) ; } if ( STRING_IS_WIDE ( ac_match -> string ) && forward_matches == - 1 ) { flags |= RE_FLAGS_WIDE ; forward_matches = exec ( ac_match -> forward_code , data + offset , data_size - offset , <S2SV_StartBug> offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags , <S2SV_EndBug> NULL , NULL ) ; } switch ( forward_matches ) { case - 1 : return ERROR_SUCCESS ; case - 2 : return ERROR_INSUFFICIENT_MEMORY ; case - 3 : return ERROR_TOO_MANY_MATCHES ; case - 4 : return ERROR_TOO_MANY_RE_FIBERS ; case - 5 : return ERROR_INTERNAL_FATAL_ERROR ; } if ( forward_matches == 0 && ac_match -> backward_code == NULL ) return ERROR_SUCCESS ; callback_args . string = ac_match -> string ; callback_args . context = context ; callback_args . data = data ; callback_args . data_size = data_size ; callback_args . data_base = data_base ; callback_args . forward_matches = forward_matches ; callback_args . full_word = STRING_IS_FULL_WORD ( ac_match -> string ) ; if ( ac_match -> backward_code != NULL ) { backward_matches = exec ( ac_match -> backward_code , <S2SV_StartBug> data + offset , <S2SV_EndBug> offset , flags | RE_FLAGS_BACKWARDS | RE_FLAGS_EXHAUSTIVE , _yr_scan_match_callback , ( void * ) & callback_args ) ; switch ( backward_matches ) { case - 2 : return ERROR_INSUFFICIENT_MEMORY ; case - 3 : return ERROR_TOO_MANY_MATCHES ; case - 4 : return ERROR_TOO_MANY_RE_FIBERS ; case - 5 : return ERROR_INTERNAL_FATAL_ERROR ; } } else { FAIL_ON_ERROR ( _yr_scan_match_callback ( data + offset , 0 , flags , & callback_args ) ) ; } return ERROR_SUCCESS ; }
","<S2SV_ModStart> offset , offset , <S2SV_ModEnd> flags , NULL <S2SV_ModStart> offset , offset , <S2SV_ModEnd> flags , NULL <S2SV_ModStart> , data + offset , data_size -
"
973,"CWE-125 void bit_write_UMC ( Bit_Chain * dat , BITCODE_UMC val ) { int i , j ; int negative ; unsigned char byte [ 5 ] ; BITCODE_UMC mask ; BITCODE_UMC value ; value = val ; mask = 0x0000007f ; for ( i = 4 , j = 0 ; i >= 0 ; i -- , j += 7 ) { byte [ i ] = ( unsigned char ) ( ( value & mask ) >> j ) ; byte [ i ] |= 0x80 ; mask = mask << 7 ; } for ( i = 0 ; i < 4 ; i ++ ) if ( byte [ i ] & 0x7f ) break ; <S2SV_StartBug> if ( byte [ i ] & 0x40 ) <S2SV_EndBug> i -- ; byte [ i ] &= 0x7f ; for ( j = 4 ; j >= i ; j -- ) bit_write_RC ( dat , byte [ j ] ) ; }
","<S2SV_ModStart> ] & 0x40 && i > 0
"
974,"CWE-125 l_int32 main ( int argc , char * * argv ) { L_DEWARP * dew1 , * dew2 ; L_DEWARPA * dewa ; PIX * pixs , * pixn , * pixg , * pixb , * pixd , * pixt1 , * pixt2 ; PIX * pixs2 , * pixn2 , * pixg2 , * pixb2 , * pixd2 ; setLeptDebugOK ( 1 ) ; lept_mkdir ( ""lept/model"" ) ; <S2SV_StartBug> pixs = pixRead ( ""cat.035.jpg"" ) ; <S2SV_EndBug> pixn = pixBackgroundNormSimple ( pixs , NULL , NULL ) ; pixg = pixConvertRGBToGray ( pixn , 0.5 , 0.3 , 0.2 ) ; pixb = pixThresholdToBinary ( pixg , 130 ) ; dewa = dewarpaCreate ( 2 , 30 , 1 , 10 , 30 ) ; dewarpaUseBothArrays ( dewa , 1 ) ; dew1 = dewarpCreate ( pixb , 35 ) ; dewarpaInsertDewarp ( dewa , dew1 ) ; dewarpBuildPageModel ( dew1 , ""/tmp/lept/model/dewarp_model1.pdf"" ) ; dewarpaApplyDisparity ( dewa , 35 , pixg , 200 , 0 , 0 , & pixd , ""/tmp/lept/model/dewarp_apply1.pdf"" ) ; lept_rmdir ( ""lept/dewtest"" ) ; lept_mkdir ( ""lept/dewtest"" ) ; pixWrite ( ""/tmp/lept/dewtest/001.jpg"" , pixs , IFF_JFIF_JPEG ) ; pixWrite ( ""/tmp/lept/dewtest/002.jpg"" , pixn , IFF_JFIF_JPEG ) ; pixWrite ( ""/tmp/lept/dewtest/003.jpg"" , pixg , IFF_JFIF_JPEG ) ; pixWrite ( ""/tmp/lept/dewtest/004.png"" , pixb , IFF_TIFF_G4 ) ; pixWrite ( ""/tmp/lept/dewtest/005.jpg"" , pixd , IFF_JFIF_JPEG ) ; pixt1 = pixRead ( ""/tmp/lept/dewmod/0020.png"" ) ; pixWrite ( ""/tmp/lept/dewtest/006.png"" , pixt1 , IFF_PNG ) ; pixDestroy ( & pixt1 ) ; pixt1 = pixRead ( ""/tmp/lept/dewmod/0030.png"" ) ; pixWrite ( ""/tmp/lept/dewtest/007.png"" , pixt1 , IFF_PNG ) ; pixDestroy ( & pixt1 ) ; pixt1 = pixRead ( ""/tmp/lept/dewmod/0060.png"" ) ; pixWrite ( ""/tmp/lept/dewtest/008.png"" , pixt1 , IFF_PNG ) ; pixDestroy ( & pixt1 ) ; pixt1 = pixRead ( ""/tmp/lept/dewmod/0070.png"" ) ; pixWrite ( ""/tmp/lept/dewtest/009.png"" , pixt1 , IFF_PNG ) ; pixDestroy ( & pixt1 ) ; pixt1 = pixRead ( ""/tmp/lept/dewapply/002.png"" ) ; pixWrite ( ""/tmp/lept/dewtest/010.png"" , pixt1 , IFF_PNG ) ; pixDestroy ( & pixt1 ) ; pixt1 = pixRead ( ""/tmp/lept/dewapply/003.png"" ) ; pixWrite ( ""/tmp/lept/dewtest/011.png"" , pixt1 , IFF_PNG ) ; pixt2 = pixThresholdToBinary ( pixt1 , 130 ) ; pixWrite ( ""/tmp/lept/dewtest/012.png"" , pixt2 , IFF_TIFF_G4 ) ; pixDestroy ( & pixt1 ) ; pixDestroy ( & pixt2 ) ; pixt1 = pixRead ( ""/tmp/lept/dewmod/0041.png"" ) ; pixWrite ( ""/tmp/lept/dewtest/013.png"" , pixt1 , IFF_PNG ) ; pixDestroy ( & pixt1 ) ; pixt1 = pixRead ( ""/tmp/lept/dewmod/0042.png"" ) ; pixWrite ( ""/tmp/lept/dewtest/014.png"" , pixt1 , IFF_PNG ) ; pixDestroy ( & pixt1 ) ; pixt1 = pixRead ( ""/tmp/lept/dewmod/0051.png"" ) ; pixWrite ( ""/tmp/lept/dewtest/015.png"" , pixt1 , IFF_PNG ) ; pixDestroy ( & pixt1 ) ; pixt1 = pixRead ( ""/tmp/lept/dewmod/0052.png"" ) ; pixWrite ( ""/tmp/lept/dewtest/016.png"" , pixt1 , IFF_PNG ) ; pixDestroy ( & pixt1 ) ; pixs2 = pixRead ( ""cat.007.jpg"" ) ; pixn2 = pixBackgroundNormSimple ( pixs2 , NULL , NULL ) ; pixg2 = pixConvertRGBToGray ( pixn2 , 0.5 , 0.3 , 0.2 ) ; pixb2 = pixThresholdToBinary ( pixg2 , 130 ) ; dew2 = dewarpCreate ( pixb2 , 7 ) ; dewarpaInsertDewarp ( dewa , dew2 ) ; dewarpaInsertRefModels ( dewa , 0 , 1 ) ; dewarpaInfo ( stderr , dewa ) ; dewarpaApplyDisparity ( dewa , 7 , pixg2 , 200 , 0 , 0 , & pixd2 , ""/tmp/lept/model/dewarp_apply2.pdf"" ) ; dewarpaDestroy ( & dewa ) ; pixWrite ( ""/tmp/lept/dewtest/017.jpg"" , pixs2 , IFF_JFIF_JPEG ) ; pixWrite ( ""/tmp/lept/dewtest/018.jpg"" , pixg2 , IFF_JFIF_JPEG ) ; pixWrite ( ""/tmp/lept/dewtest/019.png"" , pixb2 , IFF_TIFF_G4 ) ; pixWrite ( ""/tmp/lept/dewtest/020.jpg"" , pixd2 , IFF_JFIF_JPEG ) ; pixt1 = pixRead ( ""/tmp/lept/dewmod/0060.png"" ) ; pixWrite ( ""/tmp/lept/dewtest/021.png"" , pixt1 , IFF_PNG ) ; pixDestroy ( & pixt1 ) ; pixt1 = pixRead ( ""/tmp/lept/dewapply/002.png"" ) ; pixWrite ( ""/tmp/lept/dewtest/022.png"" , pixt1 , IFF_PNG ) ; pixt2 = pixThresholdToBinary ( pixt1 , 130 ) ; pixWrite ( ""/tmp/lept/dewtest/023.png"" , pixt2 , IFF_TIFF_G4 ) ; pixDestroy ( & pixt1 ) ; pixDestroy ( & pixt2 ) ; pixt1 = pixRead ( ""/tmp/lept/dewmod/0070.png"" ) ; pixWrite ( ""/tmp/lept/dewtest/024.png"" , pixt1 , IFF_PNG ) ; pixDestroy ( & pixt1 ) ; pixt1 = pixRead ( ""/tmp/lept/dewapply/003.png"" ) ; pixWrite ( ""/tmp/lept/dewtest/025.png"" , pixt1 , IFF_PNG ) ; pixt2 = pixThresholdToBinary ( pixt1 , 130 ) ; pixWrite ( ""/tmp/lept/dewtest/026.png"" , pixt2 , IFF_TIFF_G4 ) ; pixDestroy ( & pixt1 ) ; pixDestroy ( & pixt2 ) ; convertFilesToPdf ( ""/tmp/lept/dewtest"" , NULL , 135 , 1.0 , 0 , 0 , ""Dewarp<S2SV_blank>Test"" , ""/tmp/lept/dewarptest1.pdf"" ) ; <S2SV_StartBug> lept_stderr ( ""pdf<S2SV_blank>file<S2SV_blank>made:<S2SV_blank>/tmp/lept/model/dewarptest1.pdf\\n"" ) ; <S2SV_EndBug> lept_rmdir ( ""lept/dewmod"" ) ; lept_rmdir ( ""lept/dewtest"" ) ; pixDestroy ( & pixs ) ; pixDestroy ( & pixn ) ; pixDestroy ( & pixg ) ; pixDestroy ( & pixb ) ; pixDestroy ( & pixd ) ; pixDestroy ( & pixs2 ) ; pixDestroy ( & pixn2 ) ; pixDestroy ( & pixg2 ) ; pixDestroy ( & pixb2 ) ; pixDestroy ( & pixd2 ) ; return 0 ; }
","<S2SV_ModStart> ""lept/model"" ) ; lept_rmdir ( ""lept/dewmod"" ) ; lept_mkdir ( ""lept/dewmod"" ) ; <S2SV_ModStart> lept_stderr ( ""pdf<S2SV_blank>file<S2SV_blank>made:<S2SV_blank>/tmp/lept/model/dewarptest1.pdf\\n"" <S2SV_ModEnd> ) ; pixDestroy
"
975,"CWE-787 static int kwajd_read_headers ( struct mspack_system * sys , struct mspack_file * fh , struct mskwajd_header * hdr ) { unsigned char buf [ 16 ] ; int i ; if ( sys -> read ( fh , & buf [ 0 ] , kwajh_SIZEOF ) != kwajh_SIZEOF ) { return MSPACK_ERR_READ ; } if ( ( ( unsigned int ) EndGetI32 ( & buf [ kwajh_Signature1 ] ) != 0x4A41574B ) || ( ( unsigned int ) EndGetI32 ( & buf [ kwajh_Signature2 ] ) != 0xD127F088 ) ) { return MSPACK_ERR_SIGNATURE ; } hdr -> comp_type = EndGetI16 ( & buf [ kwajh_CompMethod ] ) ; hdr -> data_offset = EndGetI16 ( & buf [ kwajh_DataOffset ] ) ; hdr -> headers = EndGetI16 ( & buf [ kwajh_Flags ] ) ; hdr -> length = 0 ; hdr -> filename = NULL ; hdr -> extra = NULL ; hdr -> extra_length = 0 ; if ( hdr -> headers & MSKWAJ_HDR_HASLENGTH ) { if ( sys -> read ( fh , & buf [ 0 ] , 4 ) != 4 ) return MSPACK_ERR_READ ; hdr -> length = EndGetI32 ( & buf [ 0 ] ) ; } if ( hdr -> headers & MSKWAJ_HDR_HASUNKNOWN1 ) { if ( sys -> read ( fh , & buf [ 0 ] , 2 ) != 2 ) return MSPACK_ERR_READ ; } if ( hdr -> headers & MSKWAJ_HDR_HASUNKNOWN2 ) { if ( sys -> read ( fh , & buf [ 0 ] , 2 ) != 2 ) return MSPACK_ERR_READ ; i = EndGetI16 ( & buf [ 0 ] ) ; if ( sys -> seek ( fh , ( off_t ) i , MSPACK_SYS_SEEK_CUR ) ) return MSPACK_ERR_SEEK ; } if ( hdr -> headers & ( MSKWAJ_HDR_HASFILENAME | MSKWAJ_HDR_HASFILEEXT ) ) { <S2SV_StartBug> off_t pos = sys -> tell ( fh ) ; <S2SV_EndBug> char * fn = ( char * ) sys -> alloc ( sys , ( size_t ) 13 ) ; <S2SV_StartBug> if ( ! fn ) return MSPACK_ERR_NOMEMORY ; <S2SV_EndBug> <S2SV_StartBug> hdr -> filename = fn ; <S2SV_EndBug> if ( hdr -> headers & MSKWAJ_HDR_HASFILENAME ) { <S2SV_StartBug> if ( sys -> read ( fh , & buf [ 0 ] , 9 ) != 9 ) return MSPACK_ERR_READ ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < 9 ; i ++ , fn ++ ) if ( ! ( * fn = buf [ i ] ) ) break ; <S2SV_EndBug> <S2SV_StartBug> pos += ( i < 9 ) ? i + 1 : 9 ; <S2SV_EndBug> if ( sys -> seek ( fh , pos , MSPACK_SYS_SEEK_START ) ) <S2SV_StartBug> return MSPACK_ERR_SEEK ; <S2SV_EndBug> } if ( hdr -> headers & MSKWAJ_HDR_HASFILEEXT ) { * fn ++ = '.' ; <S2SV_StartBug> if ( sys -> read ( fh , & buf [ 0 ] , 4 ) != 4 ) return MSPACK_ERR_READ ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < 4 ; i ++ , fn ++ ) if ( ! ( * fn = buf [ i ] ) ) break ; <S2SV_EndBug> <S2SV_StartBug> pos += ( i < 4 ) ? i + 1 : 4 ; <S2SV_EndBug> if ( sys -> seek ( fh , pos , MSPACK_SYS_SEEK_START ) ) <S2SV_StartBug> return MSPACK_ERR_SEEK ; <S2SV_EndBug> } * fn = '\\0' ; } if ( hdr -> headers & MSKWAJ_HDR_HASEXTRATEXT ) { if ( sys -> read ( fh , & buf [ 0 ] , 2 ) != 2 ) return MSPACK_ERR_READ ; i = EndGetI16 ( & buf [ 0 ] ) ; hdr -> extra = ( char * ) sys -> alloc ( sys , ( size_t ) i + 1 ) ; if ( ! hdr -> extra ) return MSPACK_ERR_NOMEMORY ; if ( sys -> read ( fh , hdr -> extra , i ) != i ) return MSPACK_ERR_READ ; hdr -> extra [ i ] = '\\0' ; hdr -> extra_length = i ; } return MSPACK_ERR_OK ; }
","<S2SV_ModStart> ) ) { int len <S2SV_ModEnd> ; char * <S2SV_ModStart> if ( ! ( hdr -> filename = fn ) ) <S2SV_ModEnd> return MSPACK_ERR_NOMEMORY ; <S2SV_ModStart> return MSPACK_ERR_NOMEMORY ; <S2SV_ModEnd> if ( hdr <S2SV_ModStart> { if ( ( len = <S2SV_ModStart> , 9 ) ) < 2 <S2SV_ModEnd> ) return MSPACK_ERR_READ <S2SV_ModStart> ; i < len <S2SV_ModEnd> ; i ++ <S2SV_ModStart> ; i ++ ) if ( ! ( * fn ++ <S2SV_ModEnd> = buf [ <S2SV_ModStart> ) break ; if ( i == 9 && buf [ 8 ] != '\\0' ) return MSPACK_ERR_DATAFORMAT ; if ( sys -> seek ( fh , ( off_t ) ( <S2SV_ModEnd> i + 1 <S2SV_ModStart> i + 1 - len ) , MSPACK_SYS_SEEK_CUR <S2SV_ModEnd> ) ) return <S2SV_ModStart> ) return MSPACK_ERR_SEEK ; fn -- <S2SV_ModStart> ; if ( ( len = <S2SV_ModStart> , 4 ) ) < 2 <S2SV_ModEnd> ) return MSPACK_ERR_READ <S2SV_ModStart> ; i < len <S2SV_ModEnd> ; i ++ <S2SV_ModStart> ; i ++ ) if ( ! ( * fn ++ <S2SV_ModEnd> = buf [ <S2SV_ModStart> ) break ; if ( i == 4 && buf [ 3 ] != '\\0' ) return MSPACK_ERR_DATAFORMAT ; if ( sys -> seek ( fh , ( off_t ) ( <S2SV_ModEnd> i + 1 <S2SV_ModStart> i + 1 - len ) , MSPACK_SYS_SEEK_CUR <S2SV_ModEnd> ) ) return <S2SV_ModStart> ) return MSPACK_ERR_SEEK ; fn --
"
976,"CWE-264 int kvm_set_msr ( struct kvm_vcpu * vcpu , struct msr_data * msr ) { <S2SV_StartBug> return kvm_x86_ops -> set_msr ( vcpu , msr ) ; <S2SV_EndBug> }
","<S2SV_ModStart> msr ) { switch ( msr -> index ) { case MSR_FS_BASE : case MSR_GS_BASE : case MSR_KERNEL_GS_BASE : case MSR_CSTAR : case MSR_LSTAR : if ( is_noncanonical_address ( msr -> data ) ) return 1 ; break ; case MSR_IA32_SYSENTER_EIP : case MSR_IA32_SYSENTER_ESP : msr -> data = get_canonical ( msr -> data ) ; }
"
977,"CWE-119 GF_Err cat_multiple_files ( GF_ISOFile * dest , char * fileName , u32 import_flags , Double force_fps , u32 frames_per_sample , char * tmp_dir , Bool force_cat , Bool align_timelines , Bool allow_add_in_command ) { CATEnum cat_enum ; char * sep ; cat_enum . dest = dest ; cat_enum . import_flags = import_flags ; cat_enum . force_fps = force_fps ; cat_enum . frames_per_sample = frames_per_sample ; cat_enum . tmp_dir = tmp_dir ; cat_enum . force_cat = force_cat ; cat_enum . align_timelines = align_timelines ; cat_enum . allow_add_in_command = allow_add_in_command ; <S2SV_StartBug> strcpy ( cat_enum . szPath , fileName ) ; <S2SV_EndBug> sep = strrchr ( cat_enum . szPath , GF_PATH_SEPARATOR ) ; if ( ! sep ) sep = strrchr ( cat_enum . szPath , '/' ) ; if ( ! sep ) { strcpy ( cat_enum . szPath , ""."" ) ; <S2SV_StartBug> strcpy ( cat_enum . szRad1 , fileName ) ; <S2SV_EndBug> } else { <S2SV_StartBug> strcpy ( cat_enum . szRad1 , sep + 1 ) ; <S2SV_EndBug> sep [ 0 ] = 0 ; } <S2SV_StartBug> sep = strchr ( cat_enum . szRad1 , '*' ) ; <S2SV_EndBug> <S2SV_StartBug> strcpy ( cat_enum . szRad2 , sep + 1 ) ; <S2SV_EndBug> sep [ 0 ] = 0 ; <S2SV_StartBug> sep = strchr ( cat_enum . szRad2 , '%' ) ; <S2SV_EndBug> if ( ! sep ) sep = strchr ( cat_enum . szRad2 , '#' ) ; if ( ! sep ) sep = strchr ( cat_enum . szRad2 , ':' ) ; strcpy ( cat_enum . szOpt , """" ) ; <S2SV_StartBug> if ( sep ) { <S2SV_EndBug> strcpy ( cat_enum . szOpt , sep ) ; sep [ 0 ] = 0 ; } return gf_enum_directory ( cat_enum . szPath , 0 , cat_enumerate , & cat_enum , NULL ) ; }
","<S2SV_ModStart> = allow_add_in_command ; if ( strlen ( fileName ) >= sizeof <S2SV_ModEnd> ( cat_enum . <S2SV_ModStart> cat_enum . szPath ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""File<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\n"" , fileName ) ) ; return GF_NOT_SUPPORTED ; } strcpy ( cat_enum . szPath <S2SV_ModStart> ""."" ) ; if ( strlen ( fileName ) >= sizeof <S2SV_ModEnd> ( cat_enum . <S2SV_ModStart> cat_enum . szRad1 ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""File<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\n"" , fileName ) ) ; return GF_NOT_SUPPORTED ; } strcpy ( cat_enum . szRad1 <S2SV_ModStart> } else { if ( strlen ( <S2SV_ModEnd> sep + 1 <S2SV_ModStart> + 1 ) >= sizeof <S2SV_ModEnd> ( cat_enum . <S2SV_ModStart> cat_enum . szRad1 ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""File<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\n"" , ( <S2SV_ModEnd> sep + 1 <S2SV_ModStart> + 1 ) ) ) ; return GF_NOT_SUPPORTED ; } strcpy ( cat_enum . szRad1 , sep + 1 ) <S2SV_ModStart> = 0 ; } <S2SV_ModStart> ( cat_enum . szRad1 , '*' ) ; if ( strlen ( sep + 1 ) >= sizeof ( cat_enum . szRad2 ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""File<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\n"" , ( sep + 1 ) ) ) ; return GF_NOT_SUPPORTED ; } strcpy ( cat_enum . szRad2 , sep + 1 ) ; sep [ 0 ] = 0 ; sep = strchr ( cat_enum . szRad2 <S2SV_ModEnd> , '%' ) <S2SV_ModStart> sep ) { if ( strlen ( sep ) >= sizeof ( cat_enum . szOpt ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""Invalid<S2SV_blank>option:<S2SV_blank>%s.\\n"" , sep ) ) ; return GF_NOT_SUPPORTED ; }
"
978,"CWE-125 static int parse_elements ( netdissect_options * ndo , struct mgmt_body_t * pbody , const u_char * p , int offset , u_int length ) { u_int elementlen ; struct ssid_t ssid ; struct challenge_t challenge ; struct rates_t rates ; struct ds_t ds ; struct cf_t cf ; struct tim_t tim ; pbody -> challenge_present = 0 ; pbody -> ssid_present = 0 ; pbody -> rates_present = 0 ; pbody -> ds_present = 0 ; pbody -> cf_present = 0 ; pbody -> tim_present = 0 ; while ( length != 0 ) { if ( ! ND_TTEST2 ( * ( p + offset ) , 2 ) ) return 0 ; if ( length < 2 ) return 0 ; elementlen = * ( p + offset + 1 ) ; if ( ! ND_TTEST2 ( * ( p + offset + 2 ) , elementlen ) ) return 0 ; if ( length < elementlen + 2 ) return 0 ; switch ( * ( p + offset ) ) { case E_SSID : memcpy ( & ssid , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( ssid . length != 0 ) { if ( ssid . length > sizeof ( ssid . ssid ) - 1 ) return 0 ; <S2SV_StartBug> if ( ! ND_TTEST2 ( * ( p + offset ) , ssid . length ) ) <S2SV_EndBug> return 0 ; if ( length < ssid . length ) return 0 ; memcpy ( & ssid . ssid , p + offset , ssid . length ) ; offset += ssid . length ; length -= ssid . length ; } ssid . ssid [ ssid . length ] = '\\0' ; if ( ! pbody -> ssid_present ) { pbody -> ssid = ssid ; pbody -> ssid_present = 1 ; } break ; case E_CHALLENGE : memcpy ( & challenge , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( challenge . length != 0 ) { if ( challenge . length > sizeof ( challenge . text ) - 1 ) return 0 ; <S2SV_StartBug> if ( ! ND_TTEST2 ( * ( p + offset ) , challenge . length ) ) <S2SV_EndBug> return 0 ; if ( length < challenge . length ) return 0 ; memcpy ( & challenge . text , p + offset , challenge . length ) ; offset += challenge . length ; length -= challenge . length ; } challenge . text [ challenge . length ] = '\\0' ; if ( ! pbody -> challenge_present ) { pbody -> challenge = challenge ; pbody -> challenge_present = 1 ; } break ; case E_RATES : memcpy ( & rates , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( rates . length != 0 ) { if ( rates . length > sizeof rates . rate ) return 0 ; <S2SV_StartBug> if ( ! ND_TTEST2 ( * ( p + offset ) , rates . length ) ) <S2SV_EndBug> return 0 ; if ( length < rates . length ) return 0 ; memcpy ( & rates . rate , p + offset , rates . length ) ; offset += rates . length ; length -= rates . length ; } if ( ! pbody -> rates_present && rates . length != 0 ) { pbody -> rates = rates ; pbody -> rates_present = 1 ; } break ; case E_DS : memcpy ( & ds , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( ds . length != 1 ) { offset += ds . length ; length -= ds . length ; break ; } ds . channel = * ( p + offset ) ; offset += 1 ; length -= 1 ; if ( ! pbody -> ds_present ) { pbody -> ds = ds ; pbody -> ds_present = 1 ; } break ; case E_CF : memcpy ( & cf , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( cf . length != 6 ) { offset += cf . length ; length -= cf . length ; break ; } memcpy ( & cf . count , p + offset , 6 ) ; offset += 6 ; length -= 6 ; if ( ! pbody -> cf_present ) { pbody -> cf = cf ; pbody -> cf_present = 1 ; } break ; case E_TIM : memcpy ( & tim , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( tim . length <= 3 ) { offset += tim . length ; length -= tim . length ; break ; } if ( tim . length - 3 > ( int ) sizeof tim . bitmap ) return 0 ; memcpy ( & tim . count , p + offset , 3 ) ; offset += 3 ; length -= 3 ; <S2SV_StartBug> memcpy ( tim . bitmap , p + offset + 3 , tim . length - 3 ) ; <S2SV_EndBug> offset += tim . length - 3 ; length -= tim . length - 3 ; if ( ! pbody -> tim_present ) { pbody -> tim = tim ; pbody -> tim_present = 1 ; } break ; default : # if 0 ND_PRINT ( ( ndo , ""(1)<S2SV_blank>unhandled<S2SV_blank>element_id<S2SV_blank>(%d)<S2SV_blank><S2SV_blank>"" , * ( p + offset ) ) ) ; # endif offset += 2 + elementlen ; length -= 2 + elementlen ; break ; } } return 1 ; }
","<S2SV_ModStart> return 0 ; <S2SV_ModEnd> memcpy ( & <S2SV_ModStart> return 0 ; <S2SV_ModEnd> memcpy ( & <S2SV_ModStart> return 0 ; <S2SV_ModEnd> memcpy ( & <S2SV_ModStart> p + offset <S2SV_ModEnd> , tim .
"
979,"CWE-125 <S2SV_StartBug> void ntlm_write_message_fields ( wStream * s , NTLM_MESSAGE_FIELDS * fields ) <S2SV_EndBug> { if ( fields -> MaxLen < 1 ) fields -> MaxLen = fields -> Len ; Stream_Write_UINT16 ( s , fields -> Len ) ; Stream_Write_UINT16 ( s , fields -> MaxLen ) ; Stream_Write_UINT32 ( s , fields -> BufferOffset ) ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
"
980,"CWE-000 static int parse_options ( char * options , struct super_block * sb , unsigned long * journal_devnum , unsigned int * journal_ioprio , ext4_fsblk_t * n_blocks_count , int is_remount ) { struct ext4_sb_info * sbi = EXT4_SB ( sb ) ; char * p ; substring_t args [ MAX_OPT_ARGS ] ; int data_opt = 0 ; int option ; # ifdef CONFIG_QUOTA int qfmt ; # endif if ( ! options ) return 1 ; while ( ( p = strsep ( & options , "","" ) ) != NULL ) { int token ; if ( ! * p ) continue ; args [ 0 ] . to = args [ 0 ] . from = 0 ; token = match_token ( p , tokens , args ) ; switch ( token ) { case Opt_bsd_df : ext4_msg ( sb , KERN_WARNING , deprecated_msg , p , ""2.6.38"" ) ; clear_opt ( sbi -> s_mount_opt , MINIX_DF ) ; break ; case Opt_minix_df : ext4_msg ( sb , KERN_WARNING , deprecated_msg , p , ""2.6.38"" ) ; set_opt ( sbi -> s_mount_opt , MINIX_DF ) ; break ; case Opt_grpid : ext4_msg ( sb , KERN_WARNING , deprecated_msg , p , ""2.6.38"" ) ; set_opt ( sbi -> s_mount_opt , GRPID ) ; break ; case Opt_nogrpid : ext4_msg ( sb , KERN_WARNING , deprecated_msg , p , ""2.6.38"" ) ; clear_opt ( sbi -> s_mount_opt , GRPID ) ; break ; case Opt_resuid : if ( match_int ( & args [ 0 ] , & option ) ) return 0 ; sbi -> s_resuid = option ; break ; case Opt_resgid : if ( match_int ( & args [ 0 ] , & option ) ) return 0 ; sbi -> s_resgid = option ; break ; case Opt_sb : break ; case Opt_err_panic : clear_opt ( sbi -> s_mount_opt , ERRORS_CONT ) ; clear_opt ( sbi -> s_mount_opt , ERRORS_RO ) ; set_opt ( sbi -> s_mount_opt , ERRORS_PANIC ) ; break ; case Opt_err_ro : clear_opt ( sbi -> s_mount_opt , ERRORS_CONT ) ; clear_opt ( sbi -> s_mount_opt , ERRORS_PANIC ) ; set_opt ( sbi -> s_mount_opt , ERRORS_RO ) ; break ; case Opt_err_cont : clear_opt ( sbi -> s_mount_opt , ERRORS_RO ) ; clear_opt ( sbi -> s_mount_opt , ERRORS_PANIC ) ; set_opt ( sbi -> s_mount_opt , ERRORS_CONT ) ; break ; case Opt_nouid32 : set_opt ( sbi -> s_mount_opt , NO_UID32 ) ; break ; case Opt_debug : set_opt ( sbi -> s_mount_opt , DEBUG ) ; break ; case Opt_oldalloc : set_opt ( sbi -> s_mount_opt , OLDALLOC ) ; break ; case Opt_orlov : clear_opt ( sbi -> s_mount_opt , OLDALLOC ) ; break ; # ifdef CONFIG_EXT4_FS_XATTR case Opt_user_xattr : set_opt ( sbi -> s_mount_opt , XATTR_USER ) ; break ; case Opt_nouser_xattr : clear_opt ( sbi -> s_mount_opt , XATTR_USER ) ; break ; # else case Opt_user_xattr : case Opt_nouser_xattr : ext4_msg ( sb , KERN_ERR , ""(no)user_xattr<S2SV_blank>options<S2SV_blank>not<S2SV_blank>supported"" ) ; break ; # endif # ifdef CONFIG_EXT4_FS_POSIX_ACL case Opt_acl : set_opt ( sbi -> s_mount_opt , POSIX_ACL ) ; break ; case Opt_noacl : clear_opt ( sbi -> s_mount_opt , POSIX_ACL ) ; break ; # else case Opt_acl : case Opt_noacl : ext4_msg ( sb , KERN_ERR , ""(no)acl<S2SV_blank>options<S2SV_blank>not<S2SV_blank>supported"" ) ; break ; # endif case Opt_journal_update : if ( is_remount ) { ext4_msg ( sb , KERN_ERR , ""Cannot<S2SV_blank>specify<S2SV_blank>journal<S2SV_blank>on<S2SV_blank>remount"" ) ; return 0 ; } set_opt ( sbi -> s_mount_opt , UPDATE_JOURNAL ) ; break ; case Opt_journal_dev : if ( is_remount ) { ext4_msg ( sb , KERN_ERR , ""Cannot<S2SV_blank>specify<S2SV_blank>journal<S2SV_blank>on<S2SV_blank>remount"" ) ; return 0 ; } if ( match_int ( & args [ 0 ] , & option ) ) return 0 ; * journal_devnum = option ; break ; case Opt_journal_checksum : set_opt ( sbi -> s_mount_opt , JOURNAL_CHECKSUM ) ; break ; case Opt_journal_async_commit : set_opt ( sbi -> s_mount_opt , JOURNAL_ASYNC_COMMIT ) ; set_opt ( sbi -> s_mount_opt , JOURNAL_CHECKSUM ) ; break ; case Opt_noload : set_opt ( sbi -> s_mount_opt , NOLOAD ) ; break ; case Opt_commit : if ( match_int ( & args [ 0 ] , & option ) ) return 0 ; if ( option < 0 ) return 0 ; if ( option == 0 ) option = JBD2_DEFAULT_MAX_COMMIT_AGE ; sbi -> s_commit_interval = HZ * option ; break ; case Opt_max_batch_time : if ( match_int ( & args [ 0 ] , & option ) ) return 0 ; if ( option < 0 ) return 0 ; if ( option == 0 ) option = EXT4_DEF_MAX_BATCH_TIME ; sbi -> s_max_batch_time = option ; break ; case Opt_min_batch_time : if ( match_int ( & args [ 0 ] , & option ) ) return 0 ; if ( option < 0 ) return 0 ; sbi -> s_min_batch_time = option ; break ; case Opt_data_journal : data_opt = EXT4_MOUNT_JOURNAL_DATA ; goto datacheck ; case Opt_data_ordered : data_opt = EXT4_MOUNT_ORDERED_DATA ; goto datacheck ; case Opt_data_writeback : data_opt = EXT4_MOUNT_WRITEBACK_DATA ; datacheck : if ( is_remount ) { if ( test_opt ( sb , DATA_FLAGS ) != data_opt ) { ext4_msg ( sb , KERN_ERR , ""Cannot<S2SV_blank>change<S2SV_blank>data<S2SV_blank>mode<S2SV_blank>on<S2SV_blank>remount"" ) ; return 0 ; } } else { clear_opt ( sbi -> s_mount_opt , DATA_FLAGS ) ; sbi -> s_mount_opt |= data_opt ; } break ; case Opt_data_err_abort : set_opt ( sbi -> s_mount_opt , DATA_ERR_ABORT ) ; break ; case Opt_data_err_ignore : clear_opt ( sbi -> s_mount_opt , DATA_ERR_ABORT ) ; break ; # ifdef CONFIG_QUOTA case Opt_usrjquota : if ( ! set_qf_name ( sb , USRQUOTA , & args [ 0 ] ) ) return 0 ; break ; case Opt_grpjquota : if ( ! set_qf_name ( sb , GRPQUOTA , & args [ 0 ] ) ) return 0 ; break ; case Opt_offusrjquota : if ( ! clear_qf_name ( sb , USRQUOTA ) ) return 0 ; break ; case Opt_offgrpjquota : if ( ! clear_qf_name ( sb , GRPQUOTA ) ) return 0 ; break ; case Opt_jqfmt_vfsold : qfmt = QFMT_VFS_OLD ; goto set_qf_format ; case Opt_jqfmt_vfsv0 : qfmt = QFMT_VFS_V0 ; goto set_qf_format ; case Opt_jqfmt_vfsv1 : qfmt = QFMT_VFS_V1 ; set_qf_format : if ( sb_any_quota_loaded ( sb ) && sbi -> s_jquota_fmt != qfmt ) { ext4_msg ( sb , KERN_ERR , ""Cannot<S2SV_blank>change<S2SV_blank>"" ""journaled<S2SV_blank>quota<S2SV_blank>options<S2SV_blank>when<S2SV_blank>"" ""quota<S2SV_blank>turned<S2SV_blank>on"" ) ; return 0 ; } sbi -> s_jquota_fmt = qfmt ; break ; case Opt_quota : case Opt_usrquota : set_opt ( sbi -> s_mount_opt , QUOTA ) ; set_opt ( sbi -> s_mount_opt , USRQUOTA ) ; break ; case Opt_grpquota : set_opt ( sbi -> s_mount_opt , QUOTA ) ; set_opt ( sbi -> s_mount_opt , GRPQUOTA ) ; break ; case Opt_noquota : if ( sb_any_quota_loaded ( sb ) ) { ext4_msg ( sb , KERN_ERR , ""Cannot<S2SV_blank>change<S2SV_blank>quota<S2SV_blank>"" ""options<S2SV_blank>when<S2SV_blank>quota<S2SV_blank>turned<S2SV_blank>on"" ) ; return 0 ; } clear_opt ( sbi -> s_mount_opt , QUOTA ) ; clear_opt ( sbi -> s_mount_opt , USRQUOTA ) ; clear_opt ( sbi -> s_mount_opt , GRPQUOTA ) ; break ; # else case Opt_quota : case Opt_usrquota : case Opt_grpquota : ext4_msg ( sb , KERN_ERR , ""quota<S2SV_blank>options<S2SV_blank>not<S2SV_blank>supported"" ) ; break ; case Opt_usrjquota : case Opt_grpjquota : case Opt_offusrjquota : case Opt_offgrpjquota : case Opt_jqfmt_vfsold : case Opt_jqfmt_vfsv0 : case Opt_jqfmt_vfsv1 : ext4_msg ( sb , KERN_ERR , ""journaled<S2SV_blank>quota<S2SV_blank>options<S2SV_blank>not<S2SV_blank>supported"" ) ; break ; case Opt_noquota : break ; # endif case Opt_abort : sbi -> s_mount_flags |= EXT4_MF_FS_ABORTED ; break ; case Opt_nobarrier : clear_opt ( sbi -> s_mount_opt , BARRIER ) ; break ; case Opt_barrier : if ( args [ 0 ] . from ) { if ( match_int ( & args [ 0 ] , & option ) ) return 0 ; } else option = 1 ; if ( option ) set_opt ( sbi -> s_mount_opt , BARRIER ) ; else clear_opt ( sbi -> s_mount_opt , BARRIER ) ; break ; case Opt_ignore : break ; case Opt_resize : if ( ! is_remount ) { ext4_msg ( sb , KERN_ERR , ""resize<S2SV_blank>option<S2SV_blank>only<S2SV_blank>available<S2SV_blank>"" ""for<S2SV_blank>remount"" ) ; return 0 ; } if ( match_int ( & args [ 0 ] , & option ) != 0 ) return 0 ; * n_blocks_count = option ; break ; case Opt_nobh : set_opt ( sbi -> s_mount_opt , NOBH ) ; break ; case Opt_bh : clear_opt ( sbi -> s_mount_opt , NOBH ) ; break ; case Opt_i_version : set_opt ( sbi -> s_mount_opt , I_VERSION ) ; sb -> s_flags |= MS_I_VERSION ; break ; case Opt_nodelalloc : clear_opt ( sbi -> s_mount_opt , DELALLOC ) ; break ; case Opt_stripe : if ( match_int ( & args [ 0 ] , & option ) ) return 0 ; if ( option < 0 ) return 0 ; sbi -> s_stripe = option ; break ; case Opt_delalloc : set_opt ( sbi -> s_mount_opt , DELALLOC ) ; break ; case Opt_block_validity : set_opt ( sbi -> s_mount_opt , BLOCK_VALIDITY ) ; break ; case Opt_noblock_validity : clear_opt ( sbi -> s_mount_opt , BLOCK_VALIDITY ) ; break ; case Opt_inode_readahead_blks : if ( match_int ( & args [ 0 ] , & option ) ) return 0 ; if ( option < 0 || option > ( 1 << 30 ) ) return 0 ; if ( ! is_power_of_2 ( option ) ) { ext4_msg ( sb , KERN_ERR , ""EXT4-fs:<S2SV_blank>inode_readahead_blks"" ""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>power<S2SV_blank>of<S2SV_blank>2"" ) ; return 0 ; } sbi -> s_inode_readahead_blks = option ; break ; case Opt_journal_ioprio : if ( match_int ( & args [ 0 ] , & option ) ) return 0 ; if ( option < 0 || option > 7 ) break ; * journal_ioprio = IOPRIO_PRIO_VALUE ( IOPRIO_CLASS_BE , option ) ; break ; case Opt_noauto_da_alloc : set_opt ( sbi -> s_mount_opt , NO_AUTO_DA_ALLOC ) ; break ; case Opt_auto_da_alloc : if ( args [ 0 ] . from ) { if ( match_int ( & args [ 0 ] , & option ) ) return 0 ; } else option = 1 ; if ( option ) clear_opt ( sbi -> s_mount_opt , NO_AUTO_DA_ALLOC ) ; else set_opt ( sbi -> s_mount_opt , NO_AUTO_DA_ALLOC ) ; break ; case Opt_discard : set_opt ( sbi -> s_mount_opt , DISCARD ) ; break ; case Opt_nodiscard : clear_opt ( sbi -> s_mount_opt , DISCARD ) ; break ; <S2SV_StartBug> default : <S2SV_EndBug> ext4_msg ( sb , KERN_ERR , ""Unrecognized<S2SV_blank>mount<S2SV_blank>option<S2SV_blank>\\""%s\\""<S2SV_blank>"" ""or<S2SV_blank>missing<S2SV_blank>value"" , p ) ; return 0 ; } } # ifdef CONFIG_QUOTA if ( sbi -> s_qf_names [ USRQUOTA ] || sbi -> s_qf_names [ GRPQUOTA ] ) { if ( test_opt ( sb , USRQUOTA ) && sbi -> s_qf_names [ USRQUOTA ] ) clear_opt ( sbi -> s_mount_opt , USRQUOTA ) ; if ( test_opt ( sb , GRPQUOTA ) && sbi -> s_qf_names [ GRPQUOTA ] ) clear_opt ( sbi -> s_mount_opt , GRPQUOTA ) ; if ( test_opt ( sb , GRPQUOTA ) || test_opt ( sb , USRQUOTA ) ) { ext4_msg ( sb , KERN_ERR , ""old<S2SV_blank>and<S2SV_blank>new<S2SV_blank>quota<S2SV_blank>"" ""format<S2SV_blank>mixing"" ) ; return 0 ; } if ( ! sbi -> s_jquota_fmt ) { ext4_msg ( sb , KERN_ERR , ""journaled<S2SV_blank>quota<S2SV_blank>format<S2SV_blank>"" ""not<S2SV_blank>specified"" ) ; return 0 ; } } else { if ( sbi -> s_jquota_fmt ) { ext4_msg ( sb , KERN_ERR , ""journaled<S2SV_blank>quota<S2SV_blank>format<S2SV_blank>"" ""specified<S2SV_blank>with<S2SV_blank>no<S2SV_blank>journaling<S2SV_blank>"" ""enabled"" ) ; return 0 ; } } # endif return 1 ; }
","<S2SV_ModStart> ; break ; case Opt_dioread_nolock : set_opt ( sbi -> s_mount_opt , DIOREAD_NOLOCK ) ; break ; case Opt_dioread_lock : clear_opt ( sbi -> s_mount_opt , DIOREAD_NOLOCK ) ; break ;
"
981,"CWE-119 <S2SV_StartBug> static vpx_codec_err_t vp8e_set_roi_map ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> int ctr_id , va_list args ) { vpx_roi_map_t * data = va_arg ( args , vpx_roi_map_t * ) ; if ( data ) { vpx_roi_map_t * roi = ( vpx_roi_map_t * ) data ; if ( ! vp8_set_roimap ( ctx -> cpi , roi -> roi_map , roi -> rows , roi -> cols , roi -> delta_q , roi -> delta_lf , roi -> static_threshold ) ) return VPX_CODEC_OK ; else return VPX_CODEC_INVALID_PARAM ; } else return VPX_CODEC_INVALID_PARAM ; }
","<S2SV_ModStart> vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args
"
982,"CWE-787 int ParseWave64HeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int64_t total_samples = 0 , infilesize ; Wave64ChunkHeader chunk_header ; Wave64FileHeader filehdr ; WaveHeader WaveHeader ; uint32_t bcount ; infilesize = DoGetFileSize ( infile ) ; memcpy ( & filehdr , fourcc , 4 ) ; if ( ! DoReadFile ( infile , ( ( char * ) & filehdr ) + 4 , sizeof ( Wave64FileHeader ) - 4 , & bcount ) || bcount != sizeof ( Wave64FileHeader ) - 4 || memcmp ( filehdr . ckID , riff_guid , sizeof ( riff_guid ) ) || memcmp ( filehdr . formType , wave_guid , sizeof ( wave_guid ) ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & filehdr , sizeof ( filehdr ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } # if 1 WavpackLittleEndianToNative ( & filehdr , Wave64ChunkHeaderFormat ) ; if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && filehdr . ckSize && filehdr . ckSize + 1 && filehdr . ckSize != infilesize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } # endif while ( 1 ) { if ( ! DoReadFile ( infile , & chunk_header , sizeof ( Wave64ChunkHeader ) , & bcount ) || bcount != sizeof ( Wave64ChunkHeader ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & chunk_header , sizeof ( Wave64ChunkHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackLittleEndianToNative ( & chunk_header , Wave64ChunkHeaderFormat ) ; chunk_header . ckSize -= sizeof ( chunk_header ) ; if ( ! memcmp ( chunk_header . ckID , fmt_guid , sizeof ( fmt_guid ) ) ) { int supported = TRUE , format ; chunk_header . ckSize = ( chunk_header . ckSize + 7 ) & ~ 7L ; if ( chunk_header . ckSize < 16 || chunk_header . ckSize > sizeof ( WaveHeader ) || ! DoReadFile ( infile , & WaveHeader , ( uint32_t ) chunk_header . ckSize , & bcount ) || bcount != chunk_header . ckSize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & WaveHeader , ( uint32_t ) chunk_header . ckSize ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackLittleEndianToNative ( & WaveHeader , WaveHeaderFormat ) ; if ( debug_logging_mode ) { error_line ( ""format<S2SV_blank>tag<S2SV_blank>size<S2SV_blank>=<S2SV_blank>%d"" , chunk_header . ckSize ) ; error_line ( ""FormatTag<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>NumChannels<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>BitsPerSample<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . FormatTag , WaveHeader . NumChannels , WaveHeader . BitsPerSample ) ; error_line ( ""BlockAlign<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>SampleRate<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>BytesPerSecond<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . BlockAlign , WaveHeader . SampleRate , WaveHeader . BytesPerSecond ) ; if ( chunk_header . ckSize > 16 ) error_line ( ""cbSize<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>ValidBitsPerSample<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . cbSize , WaveHeader . ValidBitsPerSample ) ; if ( chunk_header . ckSize > 20 ) error_line ( ""ChannelMask<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>SubFormat<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . ChannelMask , WaveHeader . SubFormat ) ; } if ( chunk_header . ckSize > 16 && WaveHeader . cbSize == 2 ) config -> qmode |= QMODE_ADOBE_MODE ; format = ( WaveHeader . FormatTag == 0xfffe && chunk_header . ckSize == 40 ) ? WaveHeader . SubFormat : WaveHeader . FormatTag ; config -> bits_per_sample = ( chunk_header . ckSize == 40 && WaveHeader . ValidBitsPerSample ) ? WaveHeader . ValidBitsPerSample : WaveHeader . BitsPerSample ; if ( format != 1 && format != 3 ) supported = FALSE ; if ( format == 3 && config -> bits_per_sample != 32 ) supported = FALSE ; if ( ! WaveHeader . NumChannels || WaveHeader . NumChannels > 256 || WaveHeader . BlockAlign / WaveHeader . NumChannels < ( config -> bits_per_sample + 7 ) / 8 || WaveHeader . BlockAlign / WaveHeader . NumChannels > 4 || WaveHeader . BlockAlign % WaveHeader . NumChannels ) supported = FALSE ; if ( config -> bits_per_sample < 1 || config -> bits_per_sample > 32 ) supported = FALSE ; if ( ! supported ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>an<S2SV_blank>unsupported<S2SV_blank>.W64<S2SV_blank>format!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( chunk_header . ckSize < 40 ) { if ( ! config -> channel_mask && ! ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) { if ( WaveHeader . NumChannels <= 2 ) config -> channel_mask = 0x5 - WaveHeader . NumChannels ; else if ( WaveHeader . NumChannels <= 18 ) config -> channel_mask = ( 1 << WaveHeader . NumChannels ) - 1 ; else config -> channel_mask = 0x3ffff ; } } else if ( WaveHeader . ChannelMask && ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) ) { error_line ( ""this<S2SV_blank>W64<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!"" ) ; return WAVPACK_SOFT_ERROR ; } else if ( WaveHeader . ChannelMask ) config -> channel_mask = WaveHeader . ChannelMask ; if ( format == 3 ) config -> float_norm_exp = 127 ; else if ( ( config -> qmode & QMODE_ADOBE_MODE ) && WaveHeader . BlockAlign / WaveHeader . NumChannels == 4 ) { if ( WaveHeader . BitsPerSample == 24 ) config -> float_norm_exp = 127 + 23 ; else if ( WaveHeader . BitsPerSample == 32 ) config -> float_norm_exp = 127 + 15 ; } if ( debug_logging_mode ) { if ( config -> float_norm_exp == 127 ) error_line ( ""data<S2SV_blank>format:<S2SV_blank>normalized<S2SV_blank>32-bit<S2SV_blank>floating<S2SV_blank>point"" ) ; else error_line ( ""data<S2SV_blank>format:<S2SV_blank>%d-bit<S2SV_blank>integers<S2SV_blank>stored<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>byte(s)"" , config -> bits_per_sample , WaveHeader . BlockAlign / WaveHeader . NumChannels ) ; } } else if ( ! memcmp ( chunk_header . ckID , data_guid , sizeof ( data_guid ) ) ) { if ( ! WaveHeader . NumChannels ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( ( config -> qmode & QMODE_IGNORE_LENGTH ) || chunk_header . ckSize <= 0 ) { config -> qmode |= QMODE_IGNORE_LENGTH ; if ( infilesize && DoGetFilePosition ( infile ) != - 1 ) total_samples = ( infilesize - DoGetFilePosition ( infile ) ) / WaveHeader . BlockAlign ; else total_samples = - 1 ; } else { if ( infilesize && infilesize - chunk_header . ckSize > 16777216 ) { error_line ( ""this<S2SV_blank>.W64<S2SV_blank>file<S2SV_blank>has<S2SV_blank>over<S2SV_blank>16<S2SV_blank>MB<S2SV_blank>of<S2SV_blank>extra<S2SV_blank>RIFF<S2SV_blank>data,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" ) ; return WAVPACK_SOFT_ERROR ; } total_samples = chunk_header . ckSize / WaveHeader . BlockAlign ; if ( ! total_samples ) { error_line ( ""this<S2SV_blank>.W64<S2SV_blank>file<S2SV_blank>has<S2SV_blank>no<S2SV_blank>audio<S2SV_blank>samples,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" ) ; return WAVPACK_SOFT_ERROR ; } if ( total_samples > MAX_WAVPACK_SAMPLES ) { error_line ( ""%s<S2SV_blank>has<S2SV_blank>too<S2SV_blank>many<S2SV_blank>samples<S2SV_blank>for<S2SV_blank>WavPack!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } } config -> bytes_per_sample = WaveHeader . BlockAlign / WaveHeader . NumChannels ; config -> num_channels = WaveHeader . NumChannels ; config -> sample_rate = WaveHeader . SampleRate ; break ; } else { int bytes_to_copy = ( chunk_header . ckSize + 7 ) & ~ 7L ; <S2SV_StartBug> char * buff = malloc ( bytes_to_copy ) ; <S2SV_EndBug> if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , chunk_header . ckID [ 0 ] , chunk_header . ckID [ 1 ] , chunk_header . ckID [ 2 ] , chunk_header . ckID [ 3 ] , chunk_header . ckSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , NULL ) ) { error_line ( ""%s:<S2SV_blank>%s"" , infilename , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } return WAVPACK_NO_ERROR ; }
","<S2SV_ModStart> ; char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; }
"
983,"CWE-125 PyObject * ast2obj_slice ( void * _o ) { slice_ty o = ( slice_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { <S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug> return Py_None ; } switch ( o -> kind ) { case Slice_kind : result = PyType_GenericNew ( Slice_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Slice . lower ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_lower , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . Slice . upper ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_upper , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . Slice . step ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_step , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case ExtSlice_kind : result = PyType_GenericNew ( ExtSlice_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . ExtSlice . dims , ast2obj_slice ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_dims , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Index_kind : result = PyType_GenericNew ( Index_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Index . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; } return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }
","<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } switch
"
984,"CWE-20 static int atalk_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { <S2SV_StartBug> struct sock * sk = sock -> sk ; <S2SV_EndBug> struct sockaddr_at * sat = ( struct sockaddr_at * ) msg -> msg_name ; struct ddpehdr * ddp ; int copied = 0 ; int offset = 0 ; int err = 0 ; struct sk_buff * skb ; skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & err ) ; lock_sock ( sk ) ; if ( ! skb ) goto out ; ddp = ddp_hdr ( skb ) ; copied = ntohs ( ddp -> deh_len_hops ) & 1023 ; if ( sk -> sk_type != SOCK_RAW ) { offset = sizeof ( * ddp ) ; copied -= offset ; } if ( copied > size ) { copied = size ; msg -> msg_flags |= MSG_TRUNC ; } err = skb_copy_datagram_iovec ( skb , offset , msg -> msg_iov , copied ) ; <S2SV_StartBug> if ( ! err ) { <S2SV_EndBug> if ( sat ) { sat -> sat_family = AF_APPLETALK ; sat -> sat_port = ddp -> deh_sport ; sat -> sat_addr . s_node = ddp -> deh_snode ; sat -> sat_addr . s_net = ddp -> deh_snet ; <S2SV_StartBug> } <S2SV_EndBug> msg -> msg_namelen = sizeof ( * sat ) ; } skb_free_datagram ( sk , skb ) ; out : release_sock ( sk ) ; return err ? : copied ; }
","<S2SV_ModStart> sock -> sk <S2SV_ModEnd> ; struct ddpehdr <S2SV_ModStart> ( ! err && msg -> msg_name ) { struct sockaddr_at * sat = msg -> msg_name ; <S2SV_ModEnd> sat -> sat_family <S2SV_ModStart> -> deh_snet ; <S2SV_ModEnd> msg -> msg_namelen
"
985,"CWE-125 static void printFlow ( u_int16_t id , struct ndpi_flow_info * flow , u_int16_t thread_id ) { FILE * out = results_file ? results_file : stdout ; u_int8_t known_tls ; char buf [ 32 ] , buf1 [ 64 ] ; u_int i ; double dos_ge_score ; double dos_slow_score ; double dos_hulk_score ; double ddos_score ; double hearthbleed_score ; double ftp_patator_score ; double ssh_patator_score ; double inf_score ; if ( csv_fp != NULL ) { float data_ratio = ndpi_data_ratio ( flow -> src2dst_bytes , flow -> dst2src_bytes ) ; double f = ( double ) flow -> first_seen , l = ( double ) flow -> last_seen ; dos_ge_score = Dos_goldeneye_score ( flow ) ; dos_slow_score = Dos_slow_score ( flow ) ; dos_hulk_score = Dos_hulk_score ( flow ) ; ddos_score = Ddos_score ( flow ) ; hearthbleed_score = Hearthbleed_score ( flow ) ; ftp_patator_score = Ftp_patator_score ( flow ) ; ssh_patator_score = Ssh_patator_score ( flow ) ; inf_score = Infiltration_score ( flow ) ; double benign_score = dos_ge_score < 1 && dos_slow_score < 1 && dos_hulk_score < 1 && ddos_score < 1 && hearthbleed_score < 1 && ftp_patator_score < 1 && ssh_patator_score < 1 && inf_score < 1 ? 1.1 : 0 ; fprintf ( csv_fp , ""%u,%u,%.3f,%.3f,%.3f,%s,%u,%s,%u,"" , flow -> flow_id , flow -> protocol , f / 1000.0 , l / 1000.0 , ( l - f ) / 1000.0 , flow -> src_name , ntohs ( flow -> src_port ) , flow -> dst_name , ntohs ( flow -> dst_port ) ) ; fprintf ( csv_fp , ""%s,"" , ndpi_protocol2id ( ndpi_thread_info [ thread_id ] . workflow -> ndpi_struct , flow -> detected_protocol , buf , sizeof ( buf ) ) ) ; fprintf ( csv_fp , ""%s,%s,"" , ndpi_protocol2name ( ndpi_thread_info [ thread_id ] . workflow -> ndpi_struct , flow -> detected_protocol , buf , sizeof ( buf ) ) , flow -> host_server_name ) ; fprintf ( csv_fp , ""%.4lf,%.4lf,%.4lf,%.4lf,%.4lf,%.4lf,%.4lf,%.4lf,%.4lf,"" , benign_score , dos_slow_score , dos_ge_score , dos_hulk_score , ddos_score , hearthbleed_score , ftp_patator_score , ssh_patator_score , inf_score ) ; fprintf ( csv_fp , ""%u,%llu,%llu,"" , flow -> src2dst_packets , ( long long unsigned int ) flow -> src2dst_bytes , ( long long unsigned int ) flow -> src2dst_goodput_bytes ) ; fprintf ( csv_fp , ""%u,%llu,%llu,"" , flow -> dst2src_packets , ( long long unsigned int ) flow -> dst2src_bytes , ( long long unsigned int ) flow -> dst2src_goodput_bytes ) ; fprintf ( csv_fp , ""%.3f,%s,"" , data_ratio , ndpi_data_ratio2str ( data_ratio ) ) ; fprintf ( csv_fp , ""%.1f,%.1f,"" , 100.0 * ( ( float ) flow -> src2dst_goodput_bytes / ( float ) ( flow -> src2dst_bytes + 1 ) ) , 100.0 * ( ( float ) flow -> dst2src_goodput_bytes / ( float ) ( flow -> dst2src_bytes + 1 ) ) ) ; fprintf ( csv_fp , ""%u,%.1f,%u,%.1f,"" , ndpi_data_min ( flow -> iat_flow ) , ndpi_data_average ( flow -> iat_flow ) , ndpi_data_max ( flow -> iat_flow ) , ndpi_data_stddev ( flow -> iat_flow ) ) ; fprintf ( csv_fp , ""%u,%.1f,%u,%.1f,%u,%.1f,%u,%.1f,"" , ndpi_data_min ( flow -> iat_c_to_s ) , ndpi_data_average ( flow -> iat_c_to_s ) , ndpi_data_max ( flow -> iat_c_to_s ) , ndpi_data_stddev ( flow -> iat_c_to_s ) , ndpi_data_min ( flow -> iat_s_to_c ) , ndpi_data_average ( flow -> iat_s_to_c ) , ndpi_data_max ( flow -> iat_s_to_c ) , ndpi_data_stddev ( flow -> iat_s_to_c ) ) ; fprintf ( csv_fp , ""%u,%.1f,%u,%.1f,%u,%.1f,%u,%.1f,"" , ndpi_data_min ( flow -> pktlen_c_to_s ) , ndpi_data_average ( flow -> pktlen_c_to_s ) , ndpi_data_max ( flow -> pktlen_c_to_s ) , ndpi_data_stddev ( flow -> pktlen_c_to_s ) , ndpi_data_min ( flow -> pktlen_s_to_c ) , ndpi_data_average ( flow -> pktlen_s_to_c ) , ndpi_data_max ( flow -> pktlen_s_to_c ) , ndpi_data_stddev ( flow -> pktlen_s_to_c ) ) ; fprintf ( csv_fp , ""%d,%d,%d,%d,%d,%d,%d,%d,"" , flow -> cwr_count , flow -> ece_count , flow -> urg_count , flow -> ack_count , flow -> psh_count , flow -> rst_count , flow -> syn_count , flow -> fin_count ) ; fprintf ( csv_fp , ""%d,%d,%d,%d,%d,%d,%d,%d,"" , flow -> src2dst_cwr_count , flow -> src2dst_ece_count , flow -> src2dst_urg_count , flow -> src2dst_ack_count , flow -> src2dst_psh_count , flow -> src2dst_rst_count , flow -> src2dst_syn_count , flow -> src2dst_fin_count ) ; fprintf ( csv_fp , ""%d,%d,%d,%d,%d,%d,%d,%d,"" , flow -> dst2src_cwr_count , flow -> ece_count , flow -> urg_count , flow -> ack_count , flow -> psh_count , flow -> rst_count , flow -> syn_count , flow -> fin_count ) ; fprintf ( csv_fp , ""%u,%u,"" , flow -> c_to_s_init_win , flow -> s_to_c_init_win ) ; fprintf ( csv_fp , ""%s,%s,"" , ( flow -> ssh_tls . client_requested_server_name [ 0 ] != '\\0' ) ? flow -> ssh_tls . client_requested_server_name : """" , ( flow -> ssh_tls . server_info [ 0 ] != '\\0' ) ? flow -> ssh_tls . server_info : """" ) ; fprintf ( csv_fp , ""%s,%s,%s,%s,%s,"" , ( flow -> ssh_tls . ssl_version != 0 ) ? ndpi_ssl_version2str ( flow -> ssh_tls . ssl_version , & known_tls ) : ""0"" , ( flow -> ssh_tls . ja3_client [ 0 ] != '\\0' ) ? flow -> ssh_tls . ja3_client : """" , ( flow -> ssh_tls . ja3_client [ 0 ] != '\\0' ) ? is_unsafe_cipher ( flow -> ssh_tls . client_unsafe_cipher ) : ""0"" , ( flow -> ssh_tls . ja3_server [ 0 ] != '\\0' ) ? flow -> ssh_tls . ja3_server : """" , ( flow -> ssh_tls . ja3_server [ 0 ] != '\\0' ) ? is_unsafe_cipher ( flow -> ssh_tls . server_unsafe_cipher ) : ""0"" ) ; fprintf ( csv_fp , ""%s,%s,"" , flow -> ssh_tls . tls_alpn ? flow -> ssh_tls . tls_alpn : """" , flow -> ssh_tls . tls_supported_versions ? flow -> ssh_tls . tls_supported_versions : """" ) ; fprintf ( csv_fp , ""%s,%s,"" , flow -> ssh_tls . tls_issuerDN ? flow -> ssh_tls . tls_issuerDN : """" , flow -> ssh_tls . tls_subjectDN ? flow -> ssh_tls . tls_subjectDN : """" ) ; fprintf ( csv_fp , ""%s,%s"" , ( flow -> ssh_tls . client_hassh [ 0 ] != '\\0' ) ? flow -> ssh_tls . client_hassh : """" , ( flow -> ssh_tls . server_hassh [ 0 ] != '\\0' ) ? flow -> ssh_tls . server_hassh : """" ) ; fprintf ( csv_fp , "",%s"" , flow -> info ) ; } if ( ( verbose != 1 ) && ( verbose != 2 ) ) { if ( csv_fp && enable_joy_stats ) { flowGetBDMeanandVariance ( flow ) ; } if ( csv_fp ) fprintf ( csv_fp , ""\\n"" ) ; return ; } if ( csv_fp || ( verbose > 1 ) ) { # if 1 fprintf ( out , ""\\t%u"" , id ) ; # else fprintf ( out , ""\\t%u(%u)"" , id , flow -> flow_id ) ; # endif fprintf ( out , ""\\t%s<S2SV_blank>"" , ipProto2Name ( flow -> protocol ) ) ; fprintf ( out , ""%s%s%s:%u<S2SV_blank>%s<S2SV_blank>%s%s%s:%u<S2SV_blank>"" , ( flow -> ip_version == 6 ) ? ""["" : """" , flow -> src_name , ( flow -> ip_version == 6 ) ? ""]"" : """" , ntohs ( flow -> src_port ) , flow -> bidirectional ? ""<->"" : ""->"" , ( flow -> ip_version == 6 ) ? ""["" : """" , flow -> dst_name , ( flow -> ip_version == 6 ) ? ""]"" : """" , ntohs ( flow -> dst_port ) ) ; if ( flow -> vlan_id > 0 ) fprintf ( out , ""[VLAN:<S2SV_blank>%u]"" , flow -> vlan_id ) ; if ( enable_payload_analyzer ) fprintf ( out , ""[flowId:<S2SV_blank>%u]"" , flow -> flow_id ) ; } if ( enable_joy_stats ) { flowGetBDMeanandVariance ( flow ) ; fflush ( out ) ; fprintf ( out , ""[score:<S2SV_blank>%.4f]"" , flow -> entropy . score ) ; } if ( csv_fp ) fprintf ( csv_fp , ""\\n"" ) ; fprintf ( out , ""[proto:<S2SV_blank>"" ) ; if ( flow -> tunnel_type != ndpi_no_tunnel ) fprintf ( out , ""%s:"" , ndpi_tunnel2str ( flow -> tunnel_type ) ) ; fprintf ( out , ""%s/%s]"" , ndpi_protocol2id ( ndpi_thread_info [ thread_id ] . workflow -> ndpi_struct , flow -> detected_protocol , buf , sizeof ( buf ) ) , ndpi_protocol2name ( ndpi_thread_info [ thread_id ] . workflow -> ndpi_struct , flow -> detected_protocol , buf1 , sizeof ( buf1 ) ) ) ; if ( flow -> detected_protocol . category != 0 ) fprintf ( out , ""[cat:<S2SV_blank>%s/%u]"" , ndpi_category_get_name ( ndpi_thread_info [ thread_id ] . workflow -> ndpi_struct , flow -> detected_protocol . category ) , ( unsigned int ) flow -> detected_protocol . category ) ; fprintf ( out , ""[%u<S2SV_blank>pkts/%llu<S2SV_blank>bytes<S2SV_blank>"" , flow -> src2dst_packets , ( long long unsigned int ) flow -> src2dst_bytes ) ; fprintf ( out , ""%s<S2SV_blank>%u<S2SV_blank>pkts/%llu<S2SV_blank>bytes]"" , ( flow -> dst2src_packets > 0 ) ? ""<->"" : ""->"" , flow -> dst2src_packets , ( long long unsigned int ) flow -> dst2src_bytes ) ; fprintf ( out , ""[Goodput<S2SV_blank>ratio:<S2SV_blank>%.0f/%.0f]"" , 100.0 * ( ( float ) flow -> src2dst_goodput_bytes / ( float ) ( flow -> src2dst_bytes + 1 ) ) , 100.0 * ( ( float ) flow -> dst2src_goodput_bytes / ( float ) ( flow -> dst2src_bytes + 1 ) ) ) ; if ( flow -> last_seen > flow -> first_seen ) fprintf ( out , ""[%.2f<S2SV_blank>sec]"" , ( ( float ) ( flow -> last_seen - flow -> first_seen ) ) / ( float ) 1000 ) ; else fprintf ( out , ""[<<S2SV_blank>1<S2SV_blank>sec]"" ) ; if ( flow -> telnet . username [ 0 ] != '\\0' ) fprintf ( out , ""[Username:<S2SV_blank>%s]"" , flow -> telnet . username ) ; if ( flow -> telnet . password [ 0 ] != '\\0' ) fprintf ( out , ""[Password:<S2SV_blank>%s]"" , flow -> telnet . password ) ; if ( flow -> host_server_name [ 0 ] != '\\0' ) fprintf ( out , ""[Host:<S2SV_blank>%s]"" , flow -> host_server_name ) ; if ( flow -> info [ 0 ] != '\\0' ) fprintf ( out , ""[%s]"" , flow -> info ) ; if ( flow -> flow_extra_info [ 0 ] != '\\0' ) fprintf ( out , ""[%s]"" , flow -> flow_extra_info ) ; if ( ( flow -> src2dst_packets + flow -> dst2src_packets ) > 5 ) { if ( flow -> iat_c_to_s && flow -> iat_s_to_c ) { float data_ratio = ndpi_data_ratio ( flow -> src2dst_bytes , flow -> dst2src_bytes ) ; fprintf ( out , ""[bytes<S2SV_blank>ratio:<S2SV_blank>%.3f<S2SV_blank>(%s)]"" , data_ratio , ndpi_data_ratio2str ( data_ratio ) ) ; fprintf ( out , ""[IAT<S2SV_blank>c2s/s2c<S2SV_blank>min/avg/max/stddev:<S2SV_blank>%u/%u<S2SV_blank>%.0f/%.0f<S2SV_blank>%u/%u<S2SV_blank>%.0f/%.0f]"" , ndpi_data_min ( flow -> iat_c_to_s ) , ndpi_data_min ( flow -> iat_s_to_c ) , ( float ) ndpi_data_average ( flow -> iat_c_to_s ) , ( float ) ndpi_data_average ( flow -> iat_s_to_c ) , ndpi_data_max ( flow -> iat_c_to_s ) , ndpi_data_max ( flow -> iat_s_to_c ) , ( float ) ndpi_data_stddev ( flow -> iat_c_to_s ) , ( float ) ndpi_data_stddev ( flow -> iat_s_to_c ) ) ; fprintf ( out , ""[Pkt<S2SV_blank>Len<S2SV_blank>c2s/s2c<S2SV_blank>min/avg/max/stddev:<S2SV_blank>%u/%u<S2SV_blank>%.0f/%.0f<S2SV_blank>%u/%u<S2SV_blank>%.0f/%.0f]"" , ndpi_data_min ( flow -> pktlen_c_to_s ) , ndpi_data_min ( flow -> pktlen_s_to_c ) , ndpi_data_average ( flow -> pktlen_c_to_s ) , ndpi_data_average ( flow -> pktlen_s_to_c ) , ndpi_data_max ( flow -> pktlen_c_to_s ) , ndpi_data_max ( flow -> pktlen_s_to_c ) , ndpi_data_stddev ( flow -> pktlen_c_to_s ) , ndpi_data_stddev ( flow -> pktlen_s_to_c ) ) ; } } if ( flow -> http . url [ 0 ] != '\\0' ) { ndpi_risk_enum risk = ndpi_validate_url ( flow -> http . url ) ; if ( risk != NDPI_NO_RISK ) NDPI_SET_BIT ( flow -> risk , risk ) ; <S2SV_StartBug> fprintf ( out , ""[URL:<S2SV_blank>%s[StatusCode:<S2SV_blank>%u]"" , <S2SV_EndBug> flow -> http . url , flow -> http . response_status_code ) ; if ( flow -> http . content_type [ 0 ] != '\\0' ) <S2SV_StartBug> fprintf ( out , ""[ContentType:<S2SV_blank>%s]"" , flow -> http . content_type ) ; <S2SV_EndBug> if ( flow -> http . user_agent [ 0 ] != '\\0' ) <S2SV_StartBug> fprintf ( out , ""[UserAgent:<S2SV_blank>%s]"" , flow -> http . user_agent ) ; <S2SV_EndBug> } if ( flow -> risk ) { u_int i ; fprintf ( out , ""[Risk:<S2SV_blank>"" ) ; for ( i = 0 ; i < NDPI_MAX_RISK ; i ++ ) if ( NDPI_ISSET_BIT ( flow -> risk , i ) ) fprintf ( out , ""**<S2SV_blank>%s<S2SV_blank>**"" , ndpi_risk2str ( i ) ) ; fprintf ( out , ""]"" ) ; } if ( flow -> ssh_tls . ssl_version != 0 ) fprintf ( out , ""[%s]"" , ndpi_ssl_version2str ( flow -> ssh_tls . ssl_version , & known_tls ) ) ; if ( flow -> ssh_tls . client_requested_server_name [ 0 ] != '\\0' ) fprintf ( out , ""[Client:<S2SV_blank>%s]"" , flow -> ssh_tls . client_requested_server_name ) ; if ( flow -> ssh_tls . client_hassh [ 0 ] != '\\0' ) fprintf ( out , ""[HASSH-C:<S2SV_blank>%s]"" , flow -> ssh_tls . client_hassh ) ; if ( flow -> ssh_tls . ja3_client [ 0 ] != '\\0' ) fprintf ( out , ""[JA3C:<S2SV_blank>%s%s]"" , flow -> ssh_tls . ja3_client , print_cipher ( flow -> ssh_tls . client_unsafe_cipher ) ) ; if ( flow -> ssh_tls . server_info [ 0 ] != '\\0' ) fprintf ( out , ""[Server:<S2SV_blank>%s]"" , flow -> ssh_tls . server_info ) ; if ( flow -> ssh_tls . server_names ) fprintf ( out , ""[ServerNames:<S2SV_blank>%s]"" , flow -> ssh_tls . server_names ) ; if ( flow -> ssh_tls . server_hassh [ 0 ] != '\\0' ) fprintf ( out , ""[HASSH-S:<S2SV_blank>%s]"" , flow -> ssh_tls . server_hassh ) ; if ( flow -> ssh_tls . ja3_server [ 0 ] != '\\0' ) fprintf ( out , ""[JA3S:<S2SV_blank>%s%s]"" , flow -> ssh_tls . ja3_server , print_cipher ( flow -> ssh_tls . server_unsafe_cipher ) ) ; if ( flow -> ssh_tls . tls_issuerDN ) fprintf ( out , ""[Issuer:<S2SV_blank>%s]"" , flow -> ssh_tls . tls_issuerDN ) ; if ( flow -> ssh_tls . tls_subjectDN ) fprintf ( out , ""[Subject:<S2SV_blank>%s]"" , flow -> ssh_tls . tls_subjectDN ) ; if ( ( flow -> detected_protocol . master_protocol == NDPI_PROTOCOL_TLS ) || ( flow -> detected_protocol . app_protocol == NDPI_PROTOCOL_TLS ) ) { if ( flow -> ssh_tls . sha1_cert_fingerprint_set ) { fprintf ( out , ""[Certificate<S2SV_blank>SHA-1:<S2SV_blank>"" ) ; for ( i = 0 ; i < 20 ; i ++ ) fprintf ( out , ""%s%02X"" , ( i > 0 ) ? "":"" : """" , flow -> ssh_tls . sha1_cert_fingerprint [ i ] & 0xFF ) ; fprintf ( out , ""]"" ) ; } } if ( flow -> ssh_tls . notBefore && flow -> ssh_tls . notAfter ) { char notBefore [ 32 ] , notAfter [ 32 ] ; struct tm a , b ; struct tm * before = gmtime_r ( & flow -> ssh_tls . notBefore , & a ) ; struct tm * after = gmtime_r ( & flow -> ssh_tls . notAfter , & b ) ; strftime ( notBefore , sizeof ( notBefore ) , ""%F<S2SV_blank>%T"" , before ) ; strftime ( notAfter , sizeof ( notAfter ) , ""%F<S2SV_blank>%T"" , after ) ; fprintf ( out , ""[Validity:<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>%s]"" , notBefore , notAfter ) ; } if ( flow -> ssh_tls . server_cipher != '\\0' ) fprintf ( out , ""[Cipher:<S2SV_blank>%s]"" , ndpi_cipher2str ( flow -> ssh_tls . server_cipher ) ) ; if ( flow -> bittorent_hash [ 0 ] != '\\0' ) fprintf ( out , ""[BT<S2SV_blank>Hash:<S2SV_blank>%s]"" , flow -> bittorent_hash ) ; if ( flow -> dhcp_fingerprint [ 0 ] != '\\0' ) fprintf ( out , ""[DHCP<S2SV_blank>Fingerprint:<S2SV_blank>%s]"" , flow -> dhcp_fingerprint ) ; if ( flow -> has_human_readeable_strings ) fprintf ( out , ""[PLAIN<S2SV_blank>TEXT<S2SV_blank>(%s)]"" , flow -> human_readeable_string_buffer ) ; fprintf ( out , ""\\n"" ) ; }
","<S2SV_ModStart> ( out , ""[URL:<S2SV_blank>%s][StatusCode:<S2SV_blank>%u]"" <S2SV_ModEnd> , flow -> <S2SV_ModStart> ( out , ""[Content-Type:<S2SV_blank>%s]"" <S2SV_ModEnd> , flow -> <S2SV_ModStart> ( out , ""[User-Agent:<S2SV_blank>%s]"" <S2SV_ModEnd> , flow ->
"
986,"CWE-200 int udp_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_in * sin = ( struct sockaddr_in * ) msg -> msg_name ; struct sk_buff * skb ; unsigned int ulen , copied ; int peeked , off = 0 ; int err ; int is_udplite = IS_UDPLITE ( sk ) ; <S2SV_StartBug> bool slow ; <S2SV_EndBug> if ( addr_len ) * addr_len = sizeof ( * sin ) ; if ( flags & MSG_ERRQUEUE ) return ip_recv_error ( sk , msg , len ) ; try_again : skb = __skb_recv_datagram ( sk , flags | ( noblock ? MSG_DONTWAIT : 0 ) , & peeked , & off , & err ) ; if ( ! skb ) goto out ; ulen = skb -> len - sizeof ( struct udphdr ) ; copied = len ; if ( copied > ulen ) copied = ulen ; else if ( copied < ulen ) msg -> msg_flags |= MSG_TRUNC ; if ( copied < ulen || UDP_SKB_CB ( skb ) -> partial_cov ) { if ( udp_lib_checksum_complete ( skb ) ) goto csum_copy_err ; } if ( skb_csum_unnecessary ( skb ) ) err = skb_copy_datagram_iovec ( skb , sizeof ( struct udphdr ) , msg -> msg_iov , copied ) ; else { err = skb_copy_and_csum_datagram_iovec ( skb , sizeof ( struct udphdr ) , msg -> msg_iov ) ; if ( err == - EINVAL ) goto csum_copy_err ; } if ( unlikely ( err ) ) { trace_kfree_skb ( skb , udp_recvmsg ) ; if ( ! peeked ) { atomic_inc ( & sk -> sk_drops ) ; UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } goto out_free ; } if ( ! peeked ) UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INDATAGRAMS , is_udplite ) ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( sin ) { sin -> sin_family = AF_INET ; sin -> sin_port = udp_hdr ( skb ) -> source ; sin -> sin_addr . s_addr = ip_hdr ( skb ) -> saddr ; memset ( sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( inet -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ; err = copied ; if ( flags & MSG_TRUNC ) err = ulen ; out_free : skb_free_datagram_locked ( sk , skb ) ; out : return err ; csum_copy_err : slow = lock_sock_fast ( sk ) ; if ( ! skb_kill_datagram ( sk , skb , flags ) ) { UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_CSUMERRORS , is_udplite ) ; UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } unlock_sock_fast ( sk , slow ) ; if ( noblock ) return - EAGAIN ; msg -> msg_flags &= ~ MSG_TRUNC ; goto try_again ; }
","<S2SV_ModStart> ; bool slow <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) ; * addr_len = sizeof ( * sin ) ;
"
987,"CWE-399 int udpv6_recvmsg ( struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct inet_sock * inet = inet_sk ( sk ) ; struct sk_buff * skb ; unsigned int ulen , copied ; int peeked , off = 0 ; int err ; int is_udplite = IS_UDPLITE ( sk ) ; int is_udp4 ; bool slow ; if ( flags & MSG_ERRQUEUE ) return ipv6_recv_error ( sk , msg , len , addr_len ) ; if ( np -> rxpmtu && np -> rxopt . bits . rxpmtu ) return ipv6_recv_rxpmtu ( sk , msg , len , addr_len ) ; try_again : skb = __skb_recv_datagram ( sk , flags | ( noblock ? MSG_DONTWAIT : 0 ) , & peeked , & off , & err ) ; if ( ! skb ) goto out ; ulen = skb -> len - sizeof ( struct udphdr ) ; copied = len ; if ( copied > ulen ) copied = ulen ; else if ( copied < ulen ) msg -> msg_flags |= MSG_TRUNC ; is_udp4 = ( skb -> protocol == htons ( ETH_P_IP ) ) ; if ( copied < ulen || UDP_SKB_CB ( skb ) -> partial_cov ) { if ( udp_lib_checksum_complete ( skb ) ) goto csum_copy_err ; } if ( skb_csum_unnecessary ( skb ) ) err = skb_copy_datagram_msg ( skb , sizeof ( struct udphdr ) , msg , copied ) ; else { err = skb_copy_and_csum_datagram_msg ( skb , sizeof ( struct udphdr ) , msg ) ; if ( err == - EINVAL ) goto csum_copy_err ; } if ( unlikely ( err ) ) { trace_kfree_skb ( skb , udpv6_recvmsg ) ; if ( ! peeked ) { atomic_inc ( & sk -> sk_drops ) ; if ( is_udp4 ) UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; else UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } goto out_free ; } if ( ! peeked ) { if ( is_udp4 ) UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INDATAGRAMS , is_udplite ) ; else UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INDATAGRAMS , is_udplite ) ; } sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( msg -> msg_name ) { DECLARE_SOCKADDR ( struct sockaddr_in6 * , sin6 , msg -> msg_name ) ; sin6 -> sin6_family = AF_INET6 ; sin6 -> sin6_port = udp_hdr ( skb ) -> source ; sin6 -> sin6_flowinfo = 0 ; if ( is_udp4 ) { ipv6_addr_set_v4mapped ( ip_hdr ( skb ) -> saddr , & sin6 -> sin6_addr ) ; sin6 -> sin6_scope_id = 0 ; } else { sin6 -> sin6_addr = ipv6_hdr ( skb ) -> saddr ; sin6 -> sin6_scope_id = ipv6_iface_scope_id ( & sin6 -> sin6_addr , inet6_iif ( skb ) ) ; } * addr_len = sizeof ( * sin6 ) ; } if ( np -> rxopt . all ) ip6_datagram_recv_common_ctl ( sk , msg , skb ) ; if ( is_udp4 ) { if ( inet -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ; } else { if ( np -> rxopt . all ) ip6_datagram_recv_specific_ctl ( sk , msg , skb ) ; } err = copied ; if ( flags & MSG_TRUNC ) err = ulen ; out_free : skb_free_datagram_locked ( sk , skb ) ; out : return err ; csum_copy_err : slow = lock_sock_fast ( sk ) ; if ( ! skb_kill_datagram ( sk , skb , flags ) ) { if ( is_udp4 ) { UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_CSUMERRORS , is_udplite ) ; UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } else { UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_CSUMERRORS , is_udplite ) ; UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } } unlock_sock_fast ( sk , slow ) ; <S2SV_StartBug> if ( noblock ) <S2SV_EndBug> return - EAGAIN ; msg -> msg_flags &= ~ MSG_TRUNC ; goto try_again ; }
","<S2SV_ModStart> slow ) ; cond_resched ( ) <S2SV_ModEnd> ; msg ->
"
988,"CWE-119 <S2SV_StartBug> static void encode_sb_rt ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_EndBug> TOKENEXTRA * * tp , int mi_row , int mi_col , <S2SV_StartBug> int output_enabled , BLOCK_SIZE bsize ) { <S2SV_EndBug> VP9_COMMON * const cm = & cpi -> common ; <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> MACROBLOCKD * const xd = & x -> e_mbd ; <S2SV_StartBug> const int bsl = b_width_log2 ( bsize ) , hbs = ( 1 << bsl ) / 4 ; <S2SV_EndBug> int ctx ; PARTITION_TYPE partition ; BLOCK_SIZE subsize ; if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) return ; if ( bsize >= BLOCK_8X8 ) { <S2SV_StartBug> MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; <S2SV_EndBug> const int idx_str = xd -> mi_stride * mi_row + mi_col ; MODE_INFO * * mi_8x8 = cm -> mi_grid_visible + idx_str ; ctx = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; subsize = mi_8x8 [ 0 ] -> mbmi . sb_type ; } else { ctx = 0 ; subsize = BLOCK_4X4 ; } partition = partition_lookup [ bsl ] [ subsize ] ; <S2SV_StartBug> switch ( partition ) { <S2SV_EndBug> case PARTITION_NONE : <S2SV_StartBug> if ( output_enabled && bsize >= BLOCK_8X8 ) <S2SV_EndBug> cm -> counts . partition [ ctx ] [ PARTITION_NONE ] ++ ; <S2SV_StartBug> encode_b_rt ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ; <S2SV_EndBug> break ; case PARTITION_VERT : <S2SV_StartBug> if ( output_enabled ) <S2SV_EndBug> cm -> counts . partition [ ctx ] [ PARTITION_VERT ] ++ ; * get_sb_index ( x , subsize ) = 0 ; encode_b_rt ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ; <S2SV_StartBug> if ( mi_col + hbs < cm -> mi_cols ) { <S2SV_EndBug> * get_sb_index ( x , subsize ) = 1 ; encode_b_rt ( cpi , tile , tp , mi_row , mi_col + hbs , output_enabled , subsize ) ; } break ; case PARTITION_HORZ : <S2SV_StartBug> if ( output_enabled ) <S2SV_EndBug> cm -> counts . partition [ ctx ] [ PARTITION_HORZ ] ++ ; * get_sb_index ( x , subsize ) = 0 ; encode_b_rt ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ; <S2SV_StartBug> if ( mi_row + hbs < cm -> mi_rows ) { <S2SV_EndBug> * get_sb_index ( x , subsize ) = 1 ; encode_b_rt ( cpi , tile , tp , mi_row + hbs , mi_col , output_enabled , subsize ) ; } break ; case PARTITION_SPLIT : subsize = get_subsize ( bsize , PARTITION_SPLIT ) ; <S2SV_StartBug> if ( output_enabled ) <S2SV_EndBug> cm -> counts . partition [ ctx ] [ PARTITION_SPLIT ] ++ ; * get_sb_index ( x , subsize ) = 0 ; <S2SV_StartBug> encode_sb_rt ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ; <S2SV_EndBug> * get_sb_index ( x , subsize ) = 1 ; <S2SV_StartBug> encode_sb_rt ( cpi , tile , tp , mi_row , mi_col + hbs , output_enabled , <S2SV_EndBug> subsize ) ; * get_sb_index ( x , subsize ) = 2 ; <S2SV_StartBug> encode_sb_rt ( cpi , tile , tp , mi_row + hbs , mi_col , output_enabled , <S2SV_EndBug> subsize ) ; * get_sb_index ( x , subsize ) = 3 ; encode_sb_rt ( cpi , tile , tp , mi_row + hbs , mi_col + hbs , output_enabled , subsize ) ; break ; default : <S2SV_StartBug> assert ( ""Invalid<S2SV_blank>partition<S2SV_blank>type."" ) ; <S2SV_EndBug> } if ( partition != PARTITION_SPLIT || bsize == BLOCK_8X8 ) update_partition_context ( xd , mi_row , mi_col , subsize , bsize ) ; }
","<S2SV_ModStart> * cpi , ThreadData * td , <S2SV_ModStart> , BLOCK_SIZE bsize , PC_TREE * pc_tree <S2SV_ModStart> x = & td <S2SV_ModEnd> -> mb ; <S2SV_ModStart> int bsl = b_width_log2_lookup [ bsize ] <S2SV_ModEnd> , hbs = <S2SV_ModStart> BLOCK_8X8 ) { <S2SV_ModEnd> const int idx_str <S2SV_ModStart> subsize ] ; if ( output_enabled && bsize != BLOCK_4X4 ) td -> counts -> partition [ ctx ] [ partition ] ++ ; <S2SV_ModStart> case PARTITION_NONE : <S2SV_ModEnd> encode_b_rt ( cpi <S2SV_ModStart> ( cpi , td , tile , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> none <S2SV_ModEnd> ) ; break <S2SV_ModStart> case PARTITION_VERT : encode_b_rt ( cpi , td , tile , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> vertical [ 0 ] <S2SV_ModEnd> ) ; if <S2SV_ModStart> cm -> mi_cols && bsize > BLOCK_8X8 ) { encode_b_rt ( cpi , td , tile , tp , mi_row , mi_col + hbs , output_enabled , subsize , & pc_tree -> vertical [ 1 ] <S2SV_ModEnd> ) ; } <S2SV_ModStart> case PARTITION_HORZ : encode_b_rt ( cpi , td , tile , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> horizontal [ 0 ] <S2SV_ModEnd> ) ; if <S2SV_ModStart> cm -> mi_rows && bsize > BLOCK_8X8 ) { encode_b_rt ( cpi , td , tile , tp , mi_row + hbs , mi_col , output_enabled , subsize , & pc_tree -> horizontal [ 1 ] <S2SV_ModEnd> ) ; } <S2SV_ModStart> PARTITION_SPLIT ) ; encode_sb_rt ( cpi , td , tile , tp , mi_row , mi_col , output_enabled , subsize , pc_tree -> split [ 0 ] ) <S2SV_ModEnd> ; encode_sb_rt ( <S2SV_ModStart> ( cpi , td , tile , tp , mi_row , mi_col + hbs , output_enabled , subsize , pc_tree -> split [ 1 ] ) <S2SV_ModEnd> ; encode_sb_rt ( <S2SV_ModStart> ( cpi , td , tile , tp , mi_row + hbs , mi_col , output_enabled , subsize , pc_tree -> split [ 2 ] ) <S2SV_ModEnd> ; encode_sb_rt ( <S2SV_ModStart> ( cpi , td , tile , tp , mi_row + hbs , mi_col + hbs , output_enabled , subsize , pc_tree -> split [ 3 ] <S2SV_ModEnd> ) ; break <S2SV_ModStart> : assert ( 0 && ""Invalid<S2SV_blank>partition<S2SV_blank>type."" ) ; break <S2SV_ModEnd> ; } if
"
989,"CWE-000 apr_status_t modsecurity_tx_init ( modsec_rec * msr ) { const char * s = NULL ; const apr_array_header_t * arr ; char * semicolon = NULL ; char * comma = NULL ; apr_table_entry_t * te ; int i ; apr_pool_cleanup_register ( msr -> mp , msr , modsecurity_tx_cleanup , apr_pool_cleanup_null ) ; msr -> request_content_length = - 1 ; s = apr_table_get ( msr -> request_headers , ""Content-Length"" ) ; if ( s != NULL ) { msr -> request_content_length = strtol ( s , NULL , 10 ) ; } msr -> reqbody_chunked = 0 ; msr -> reqbody_should_exist = 0 ; if ( msr -> request_content_length == - 1 ) { char * transfer_encoding = ( char * ) apr_table_get ( msr -> request_headers , ""Transfer-Encoding"" ) ; <S2SV_StartBug> if ( ( transfer_encoding != NULL ) && ( strstr ( transfer_encoding , ""chunked"" ) != NULL ) ) { <S2SV_EndBug> msr -> reqbody_should_exist = 1 ; msr -> reqbody_chunked = 1 ; } } else { msr -> reqbody_should_exist = 1 ; } msr -> request_content_type = NULL ; s = apr_table_get ( msr -> request_headers , ""Content-Type"" ) ; if ( s != NULL ) msr -> request_content_type = s ; if ( ( msr -> request_content_type != NULL ) && ( strncasecmp ( msr -> request_content_type , ""application/x-www-form-urlencoded"" , 33 ) == 0 ) ) { msr -> msc_reqbody_storage = MSC_REQBODY_MEMORY ; msr -> msc_reqbody_spilltodisk = 0 ; msr -> msc_reqbody_processor = ""URLENCODED"" ; } else { if ( ( msr -> request_content_length != - 1 ) && ( msr -> request_content_length > msr -> txcfg -> reqbody_inmemory_limit ) ) { msr -> msc_reqbody_storage = MSC_REQBODY_DISK ; } msr -> msc_reqbody_storage = MSC_REQBODY_MEMORY ; msr -> msc_reqbody_spilltodisk = 1 ; if ( msr -> request_content_type != NULL ) { if ( strncasecmp ( msr -> request_content_type , ""multipart/form-data"" , 19 ) == 0 ) { msr -> msc_reqbody_processor = ""MULTIPART"" ; } } } if ( msr -> txcfg -> reqbody_buffering != REQUEST_BODY_FORCEBUF_OFF ) { msr -> msc_reqbody_storage = MSC_REQBODY_MEMORY ; msr -> msc_reqbody_spilltodisk = 0 ; } msr -> arguments = apr_table_make ( msr -> mp , 32 ) ; if ( msr -> arguments == NULL ) return - 1 ; if ( msr -> query_string != NULL ) { int invalid_count = 0 ; if ( parse_arguments ( msr , msr -> query_string , strlen ( msr -> query_string ) , msr -> txcfg -> argument_separator , ""QUERY_STRING"" , msr -> arguments , & invalid_count ) < 0 ) { msr_log ( msr , 1 , ""Initialisation:<S2SV_blank>Error<S2SV_blank>occurred<S2SV_blank>while<S2SV_blank>parsing<S2SV_blank>QUERY_STRING<S2SV_blank>arguments."" ) ; return - 1 ; } if ( invalid_count ) { msr -> urlencoded_error = 1 ; } } msr -> arguments_to_sanitize = apr_table_make ( msr -> mp , 16 ) ; if ( msr -> arguments_to_sanitize == NULL ) return - 1 ; msr -> request_headers_to_sanitize = apr_table_make ( msr -> mp , 16 ) ; if ( msr -> request_headers_to_sanitize == NULL ) return - 1 ; msr -> response_headers_to_sanitize = apr_table_make ( msr -> mp , 16 ) ; if ( msr -> response_headers_to_sanitize == NULL ) return - 1 ; msr -> pattern_to_sanitize = apr_table_make ( msr -> mp , 32 ) ; if ( msr -> pattern_to_sanitize == NULL ) return - 1 ; msr -> removed_targets = apr_table_make ( msr -> mp , 16 ) ; if ( msr -> removed_targets == NULL ) return - 1 ; msr -> request_cookies = apr_table_make ( msr -> mp , 16 ) ; if ( msr -> request_cookies == NULL ) return - 1 ; msr -> matched_vars = apr_table_make ( msr -> mp , 8 ) ; if ( msr -> matched_vars == NULL ) return - 1 ; apr_table_clear ( msr -> matched_vars ) ; msr -> perf_rules = apr_table_make ( msr -> mp , 8 ) ; if ( msr -> perf_rules == NULL ) return - 1 ; apr_table_clear ( msr -> perf_rules ) ; arr = apr_table_elts ( msr -> request_headers ) ; te = ( apr_table_entry_t * ) arr -> elts ; for ( i = 0 ; i < arr -> nelts ; i ++ ) { if ( strcasecmp ( te [ i ] . key , ""Cookie"" ) == 0 ) { if ( msr -> txcfg -> cookie_format == COOKIES_V0 ) { semicolon = apr_pstrdup ( msr -> mp , te [ i ] . val ) ; while ( ( * semicolon != 0 ) && ( * semicolon != ';' ) ) semicolon ++ ; if ( * semicolon == ';' ) { parse_cookies_v0 ( msr , te [ i ] . val , msr -> request_cookies , "";"" ) ; } else { comma = apr_pstrdup ( msr -> mp , te [ i ] . val ) ; while ( ( * comma != 0 ) && ( * comma != ',' ) ) comma ++ ; if ( * comma == ',' ) { comma ++ ; if ( * comma == 0x20 ) { if ( msr -> txcfg -> debuglog_level >= 5 ) { msr_log ( msr , 5 , ""Cookie<S2SV_blank>v0<S2SV_blank>parser:<S2SV_blank>Using<S2SV_blank>comma<S2SV_blank>as<S2SV_blank>a<S2SV_blank>separator.<S2SV_blank>Semi-colon<S2SV_blank>was<S2SV_blank>not<S2SV_blank>identified!"" ) ; } parse_cookies_v0 ( msr , te [ i ] . val , msr -> request_cookies , "","" ) ; } else { parse_cookies_v0 ( msr , te [ i ] . val , msr -> request_cookies , "";"" ) ; } } else { parse_cookies_v0 ( msr , te [ i ] . val , msr -> request_cookies , "";"" ) ; } } } else { parse_cookies_v1 ( msr , te [ i ] . val , msr -> request_cookies ) ; } } } msr -> tx_vars = apr_table_make ( msr -> mp , 32 ) ; if ( msr -> tx_vars == NULL ) return - 1 ; msr -> geo_vars = apr_table_make ( msr -> mp , 8 ) ; if ( msr -> geo_vars == NULL ) return - 1 ; msr -> collections_original = apr_table_make ( msr -> mp , 8 ) ; if ( msr -> collections_original == NULL ) return - 1 ; msr -> collections = apr_table_make ( msr -> mp , 8 ) ; if ( msr -> collections == NULL ) return - 1 ; msr -> collections_dirty = apr_table_make ( msr -> mp , 8 ) ; if ( msr -> collections_dirty == NULL ) return - 1 ; msr -> tcache = NULL ; msr -> tcache_items = 0 ; msr -> matched_rules = apr_array_make ( msr -> mp , 16 , sizeof ( void * ) ) ; if ( msr -> matched_rules == NULL ) return - 1 ; msr -> matched_var = ( msc_string * ) apr_pcalloc ( msr -> mp , sizeof ( msc_string ) ) ; if ( msr -> matched_var == NULL ) return - 1 ; msr -> highest_severity = 255 ; msr -> removed_rules = apr_array_make ( msr -> mp , 16 , sizeof ( char * ) ) ; if ( msr -> removed_rules == NULL ) return - 1 ; msr -> removed_rules_tag = apr_array_make ( msr -> mp , 16 , sizeof ( char * ) ) ; if ( msr -> removed_rules_tag == NULL ) return - 1 ; msr -> removed_rules_msg = apr_array_make ( msr -> mp , 16 , sizeof ( char * ) ) ; if ( msr -> removed_rules_msg == NULL ) return - 1 ; return 1 ; }
","<S2SV_ModStart> ) && ( m_strcasestr <S2SV_ModEnd> ( transfer_encoding ,
"
990,"CWE-119 <S2SV_StartBug> static void utee_param_to_param ( struct tee_ta_param * p , struct utee_params * up ) <S2SV_EndBug> { size_t n ; uint32_t types = up -> types ; p -> types = types ; for ( n = 0 ; n < TEE_NUM_PARAMS ; n ++ ) { uintptr_t a = up -> vals [ n * 2 ] ; size_t b = up -> vals [ n * 2 + 1 ] ; <S2SV_StartBug> switch ( TEE_PARAM_TYPE_GET ( types , n ) ) { <S2SV_EndBug> <S2SV_StartBug> case TEE_PARAM_TYPE_MEMREF_INPUT : <S2SV_EndBug> case TEE_PARAM_TYPE_MEMREF_OUTPUT : case TEE_PARAM_TYPE_MEMREF_INOUT : p -> u [ n ] . mem . mobj = & mobj_virt ; p -> u [ n ] . mem . offs = a ; p -> u [ n ] . mem . size = b ; <S2SV_StartBug> break ; <S2SV_EndBug> case TEE_PARAM_TYPE_VALUE_INPUT : case TEE_PARAM_TYPE_VALUE_INOUT : p -> u [ n ] . val . a = a ; p -> u [ n ] . val . b = b ; break ; default : memset ( & p -> u [ n ] , 0 , sizeof ( p -> u [ n ] ) ) ; break ; } <S2SV_StartBug> } <S2SV_EndBug> }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static TEE_Result utee_param_to_param ( struct user_ta_ctx * utc , <S2SV_ModEnd> struct tee_ta_param * <S2SV_ModStart> 1 ] ; uint32_t flags = TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER ; <S2SV_ModStart> ) { case TEE_PARAM_TYPE_MEMREF_OUTPUT : case TEE_PARAM_TYPE_MEMREF_INOUT : flags |= TEE_MEMORY_ACCESS_WRITE ; case TEE_PARAM_TYPE_MEMREF_INPUT <S2SV_ModEnd> : p -> <S2SV_ModStart> = b ; if ( tee_mmu_check_access_rights ( utc , flags , a , b ) ) return TEE_ERROR_ACCESS_DENIED ; <S2SV_ModStart> ; } } return TEE_SUCCESS ;
"
991,"CWE-200 int raptor_turtle_writer_set_option ( raptor_turtle_writer * turtle_writer , raptor_option option , int value ) { if ( value < 0 || ! raptor_option_is_valid_for_area ( option , RAPTOR_OPTION_AREA_TURTLE_WRITER ) ) return 1 ; switch ( option ) { case RAPTOR_OPTION_WRITER_AUTO_INDENT : if ( value ) turtle_writer -> flags |= TURTLE_WRITER_AUTO_INDENT ; else turtle_writer -> flags &= ~ TURTLE_WRITER_AUTO_INDENT ; break ; case RAPTOR_OPTION_WRITER_INDENT_WIDTH : turtle_writer -> indent = value ; break ; case RAPTOR_OPTION_WRITER_AUTO_EMPTY : case RAPTOR_OPTION_WRITER_XML_VERSION : case RAPTOR_OPTION_WRITER_XML_DECLARATION : break ; case RAPTOR_OPTION_SCANNING : case RAPTOR_OPTION_ALLOW_NON_NS_ATTRIBUTES : case RAPTOR_OPTION_ALLOW_OTHER_PARSETYPES : case RAPTOR_OPTION_ALLOW_BAGID : case RAPTOR_OPTION_ALLOW_RDF_TYPE_RDF_LIST : case RAPTOR_OPTION_NORMALIZE_LANGUAGE : case RAPTOR_OPTION_NON_NFC_FATAL : case RAPTOR_OPTION_WARN_OTHER_PARSETYPES : case RAPTOR_OPTION_CHECK_RDF_ID : case RAPTOR_OPTION_HTML_TAG_SOUP : case RAPTOR_OPTION_MICROFORMATS : case RAPTOR_OPTION_HTML_LINK : case RAPTOR_OPTION_WWW_TIMEOUT : case RAPTOR_OPTION_STRICT : case RAPTOR_OPTION_NO_NET : case RAPTOR_OPTION_NO_FILE : <S2SV_StartBug> case RAPTOR_OPTION_RELATIVE_URIS : <S2SV_EndBug> case RAPTOR_OPTION_RESOURCE_BORDER : case RAPTOR_OPTION_LITERAL_BORDER : case RAPTOR_OPTION_BNODE_BORDER : case RAPTOR_OPTION_RESOURCE_FILL : case RAPTOR_OPTION_LITERAL_FILL : case RAPTOR_OPTION_BNODE_FILL : case RAPTOR_OPTION_JSON_CALLBACK : case RAPTOR_OPTION_JSON_EXTRA_DATA : case RAPTOR_OPTION_RSS_TRIPLES : case RAPTOR_OPTION_ATOM_ENTRY_URI : case RAPTOR_OPTION_PREFIX_ELEMENTS : case RAPTOR_OPTION_WRITE_BASE_URI : case RAPTOR_OPTION_WWW_HTTP_CACHE_CONTROL : case RAPTOR_OPTION_WWW_HTTP_USER_AGENT : case RAPTOR_OPTION_WWW_CERT_FILENAME : case RAPTOR_OPTION_WWW_CERT_TYPE : case RAPTOR_OPTION_WWW_CERT_PASSPHRASE : case RAPTOR_OPTION_WWW_SSL_VERIFY_PEER : case RAPTOR_OPTION_WWW_SSL_VERIFY_HOST : default : return - 1 ; break ; } return 0 ; }
","<S2SV_ModStart> RAPTOR_OPTION_NO_FILE : case RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES : case
"
992,"CWE-119 static float * get_window ( vorb * f , int len ) { len <<= 1 ; if ( len == f -> blocksize_0 ) return f -> window [ 0 ] ; if ( len == f -> blocksize_1 ) return f -> window [ 1 ] ; <S2SV_StartBug> assert ( 0 ) ; <S2SV_EndBug> return NULL ; }
","<S2SV_ModStart> 1 ] ; <S2SV_ModEnd> return NULL ;
"
993,"CWE-399 int CMS_verify ( CMS_ContentInfo * cms , STACK_OF ( X509 ) * certs , X509_STORE * store , BIO * dcont , BIO * out , unsigned int flags ) { CMS_SignerInfo * si ; STACK_OF ( CMS_SignerInfo ) * sinfos ; STACK_OF ( X509 ) * cms_certs = NULL ; STACK_OF ( X509_CRL ) * crls = NULL ; X509 * signer ; int i , scount = 0 , ret = 0 ; <S2SV_StartBug> BIO * cmsbio = NULL , * tmpin = NULL ; <S2SV_EndBug> if ( ! dcont && ! check_content ( cms ) ) return 0 ; sinfos = CMS_get0_SignerInfos ( cms ) ; if ( sk_CMS_SignerInfo_num ( sinfos ) <= 0 ) { CMSerr ( CMS_F_CMS_VERIFY , CMS_R_NO_SIGNERS ) ; goto err ; } for ( i = 0 ; i < sk_CMS_SignerInfo_num ( sinfos ) ; i ++ ) { si = sk_CMS_SignerInfo_value ( sinfos , i ) ; CMS_SignerInfo_get0_algs ( si , NULL , & signer , NULL , NULL ) ; if ( signer ) scount ++ ; } if ( scount != sk_CMS_SignerInfo_num ( sinfos ) ) scount += CMS_set1_signers_certs ( cms , certs , flags ) ; if ( scount != sk_CMS_SignerInfo_num ( sinfos ) ) { CMSerr ( CMS_F_CMS_VERIFY , CMS_R_SIGNER_CERTIFICATE_NOT_FOUND ) ; goto err ; } if ( ! ( flags & CMS_NO_SIGNER_CERT_VERIFY ) ) { cms_certs = CMS_get1_certs ( cms ) ; if ( ! ( flags & CMS_NOCRL ) ) crls = CMS_get1_crls ( cms ) ; for ( i = 0 ; i < sk_CMS_SignerInfo_num ( sinfos ) ; i ++ ) { si = sk_CMS_SignerInfo_value ( sinfos , i ) ; if ( ! cms_signerinfo_verify_cert ( si , store , cms_certs , crls , flags ) ) goto err ; } } if ( ! ( flags & CMS_NO_ATTR_VERIFY ) ) { for ( i = 0 ; i < sk_CMS_SignerInfo_num ( sinfos ) ; i ++ ) { si = sk_CMS_SignerInfo_value ( sinfos , i ) ; if ( CMS_signed_get_attr_count ( si ) < 0 ) continue ; if ( CMS_SignerInfo_verify ( si ) <= 0 ) goto err ; } } if ( dcont && ( BIO_method_type ( dcont ) == BIO_TYPE_MEM ) ) { char * ptr ; long len ; len = BIO_get_mem_data ( dcont , & ptr ) ; tmpin = BIO_new_mem_buf ( ptr , len ) ; if ( tmpin == NULL ) { CMSerr ( CMS_F_CMS_VERIFY , ERR_R_MALLOC_FAILURE ) ; return 0 ; } } else tmpin = dcont ; <S2SV_StartBug> cmsbio = CMS_dataInit ( cms , tmpin ) ; <S2SV_EndBug> if ( ! cmsbio ) goto err ; if ( ! cms_copy_content ( out , cmsbio , flags ) ) <S2SV_StartBug> goto err ; <S2SV_EndBug> if ( ! ( flags & CMS_NO_CONTENT_VERIFY ) ) { for ( i = 0 ; i < sk_CMS_SignerInfo_num ( sinfos ) ; i ++ ) { si = sk_CMS_SignerInfo_value ( sinfos , i ) ; if ( CMS_SignerInfo_verify_content ( si , cmsbio ) <= 0 ) { CMSerr ( CMS_F_CMS_VERIFY , CMS_R_CONTENT_VERIFY_ERROR ) ; goto err ; } } } ret = 1 ; err : <S2SV_StartBug> if ( dcont && ( tmpin == dcont ) ) <S2SV_EndBug> do_free_upto ( cmsbio , dcont ) ; else BIO_free_all ( cmsbio ) ; <S2SV_StartBug> if ( cms_certs ) <S2SV_EndBug> sk_X509_pop_free ( cms_certs , X509_free ) ; if ( crls ) sk_X509_CRL_pop_free ( crls , X509_CRL_free ) ; return ret ; }
","<S2SV_ModStart> , * tmpin = NULL , * tmpout <S2SV_ModStart> = dcont ; if ( ! ( flags & SMIME_BINARY ) && dcont ) { tmpout = cms_get_text_bio ( out , flags ) ; if ( ! tmpout ) { CMSerr ( CMS_F_CMS_VERIFY , ERR_R_MALLOC_FAILURE ) ; goto err ; } <S2SV_ModStart> ( cms , tmpout ) ; if ( ! cmsbio ) goto err ; SMIME_crlf_copy ( dcont , cmsbio , flags & ~ SMIME_TEXT ) ; if ( flags & CMS_TEXT ) { if ( ! SMIME_text ( tmpout , out ) ) { CMSerr ( CMS_F_CMS_VERIFY , CMS_R_SMIME_TEXT_ERROR ) ; goto err ; } } } else { cmsbio = CMS_dataInit ( cms , <S2SV_ModStart> goto err ; } <S2SV_ModStart> : if ( ! ( flags & SMIME_BINARY ) && dcont ) { do_free_upto ( cmsbio , tmpout ) ; if ( tmpin != dcont ) BIO_free ( tmpin ) ; } else { if ( <S2SV_ModStart> cmsbio ) ; } if ( tmpout && out != tmpout ) BIO_free_all ( tmpout ) ;
"
994,"CWE-399 static int dcbnl_cee_fill ( struct sk_buff * skb , struct net_device * netdev ) { struct nlattr * cee , * app ; struct dcb_app_type * itr ; const struct dcbnl_rtnl_ops * ops = netdev -> dcbnl_ops ; int dcbx , i , err = - EMSGSIZE ; u8 value ; if ( nla_put_string ( skb , DCB_ATTR_IFNAME , netdev -> name ) ) goto nla_put_failure ; cee = nla_nest_start ( skb , DCB_ATTR_CEE ) ; if ( ! cee ) goto nla_put_failure ; if ( ops -> getpgtccfgtx && ops -> getpgbwgcfgtx ) { err = dcbnl_cee_pg_fill ( skb , netdev , 1 ) ; if ( err ) goto nla_put_failure ; } if ( ops -> getpgtccfgrx && ops -> getpgbwgcfgrx ) { err = dcbnl_cee_pg_fill ( skb , netdev , 0 ) ; if ( err ) goto nla_put_failure ; } if ( ops -> getpfccfg ) { struct nlattr * pfc_nest = nla_nest_start ( skb , DCB_ATTR_CEE_PFC ) ; if ( ! pfc_nest ) goto nla_put_failure ; for ( i = DCB_PFC_UP_ATTR_0 ; i <= DCB_PFC_UP_ATTR_7 ; i ++ ) { ops -> getpfccfg ( netdev , i - DCB_PFC_UP_ATTR_0 , & value ) ; if ( nla_put_u8 ( skb , i , value ) ) goto nla_put_failure ; } nla_nest_end ( skb , pfc_nest ) ; } spin_lock ( & dcb_lock ) ; app = nla_nest_start ( skb , DCB_ATTR_CEE_APP_TABLE ) ; if ( ! app ) goto dcb_unlock ; list_for_each_entry ( itr , & dcb_app_list , list ) { if ( itr -> ifindex == netdev -> ifindex ) { struct nlattr * app_nest = nla_nest_start ( skb , DCB_ATTR_APP ) ; if ( ! app_nest ) goto dcb_unlock ; err = nla_put_u8 ( skb , DCB_APP_ATTR_IDTYPE , itr -> app . selector ) ; if ( err ) goto dcb_unlock ; err = nla_put_u16 ( skb , DCB_APP_ATTR_ID , itr -> app . protocol ) ; if ( err ) goto dcb_unlock ; err = nla_put_u8 ( skb , DCB_APP_ATTR_PRIORITY , itr -> app . priority ) ; if ( err ) goto dcb_unlock ; nla_nest_end ( skb , app_nest ) ; } } nla_nest_end ( skb , app ) ; if ( netdev -> dcbnl_ops -> getdcbx ) dcbx = netdev -> dcbnl_ops -> getdcbx ( netdev ) ; else dcbx = - EOPNOTSUPP ; spin_unlock ( & dcb_lock ) ; if ( ops -> getfeatcfg ) { struct nlattr * feat = nla_nest_start ( skb , DCB_ATTR_CEE_FEAT ) ; if ( ! feat ) goto nla_put_failure ; for ( i = DCB_FEATCFG_ATTR_ALL + 1 ; i <= DCB_FEATCFG_ATTR_MAX ; i ++ ) if ( ! ops -> getfeatcfg ( netdev , i , & value ) && nla_put_u8 ( skb , i , value ) ) goto nla_put_failure ; nla_nest_end ( skb , feat ) ; } if ( ops -> cee_peer_getpg ) { struct cee_pg pg ; <S2SV_StartBug> err = ops -> cee_peer_getpg ( netdev , & pg ) ; <S2SV_EndBug> if ( ! err && nla_put ( skb , DCB_ATTR_CEE_PEER_PG , sizeof ( pg ) , & pg ) ) goto nla_put_failure ; } if ( ops -> cee_peer_getpfc ) { <S2SV_StartBug> struct cee_pfc pfc ; <S2SV_EndBug> err = ops -> cee_peer_getpfc ( netdev , & pfc ) ; if ( ! err && nla_put ( skb , DCB_ATTR_CEE_PEER_PFC , sizeof ( pfc ) , & pfc ) ) goto nla_put_failure ; } if ( ops -> peer_getappinfo && ops -> peer_getapptable ) { err = dcbnl_build_peer_app ( netdev , skb , DCB_ATTR_CEE_PEER_APP_TABLE , DCB_ATTR_CEE_PEER_APP_INFO , DCB_ATTR_CEE_PEER_APP ) ; if ( err ) goto nla_put_failure ; } nla_nest_end ( skb , cee ) ; if ( dcbx >= 0 ) { err = nla_put_u8 ( skb , DCB_ATTR_DCBX , dcbx ) ; if ( err ) goto nla_put_failure ; } return 0 ; dcb_unlock : spin_unlock ( & dcb_lock ) ; nla_put_failure : return err ; }
","<S2SV_ModStart> cee_pg pg ; memset ( & pg , 0 , sizeof ( pg ) ) ; <S2SV_ModStart> struct cee_pfc pfc ; memset ( & pfc , 0 , sizeof ( pfc ) )
"
995,"CWE-772 chrand_ret * chrand_principal_2_svc ( chrand_arg * arg , struct svc_req * rqstp ) { static chrand_ret ret ; krb5_keyblock * k ; int nkeys ; char * prime_arg , * funcname ; <S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_chrand_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; funcname = ""kadm5_randkey_principal"" ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> princ , & prime_arg ) ) { ret . code = KADM5_BAD_PRINCIPAL ; goto exit_func ; } if ( cmp_gss_krb5_name ( handle , rqst2name ( rqstp ) , arg -> princ ) ) { ret . code = randkey_principal_wrapper_3 ( ( void * ) handle , arg -> princ , FALSE , 0 , NULL , & k , & nkeys ) ; } else if ( ! ( CHANGEPW_SERVICE ( rqstp ) ) && kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_CHANGEPW , arg -> princ , NULL ) ) { ret . code = kadm5_randkey_principal ( ( void * ) handle , arg -> princ , & k , & nkeys ) ; } else { log_unauth ( funcname , prime_arg , & client_name , & service_name , rqstp ) ; ret . code = KADM5_AUTH_CHANGEPW ; } if ( ret . code == KADM5_OK ) { ret . keys = k ; ret . n_keys = nkeys ; } if ( ret . code != KADM5_AUTH_CHANGEPW ) { if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( funcname , prime_arg , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } free ( prime_arg ) ; <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> gss_release_buffer ( & minor_stat , & service_name ) ; exit_func : free_server_handle ( handle ) ; return & ret ; }
","<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> prime_arg ) ; exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
"
996,"CWE-190 void * jas_realloc ( void * ptr , size_t size ) { void * result ; <S2SV_StartBug> JAS_DBGLOG ( 101 , ( ""jas_realloc<S2SV_blank>called<S2SV_blank>with<S2SV_blank>%x,%zu\\n"" , ptr , size ) ) ; <S2SV_EndBug> result = realloc ( ptr , size ) ; JAS_DBGLOG ( 100 , ( ""jas_realloc(%p,<S2SV_blank>%zu)<S2SV_blank>-><S2SV_blank>%p\\n"" , ptr , size , result ) ) ; return result ; }
","<S2SV_ModStart> 101 , ( ""jas_realloc(%x,<S2SV_blank>%zu)\\n"" <S2SV_ModEnd> , ptr ,
"
997,"CWE-000 int av_reallocp_array ( void * ptr , size_t nmemb , size_t size ) { void * * ptrptr = ptr ; * ptrptr = av_realloc_f ( * ptrptr , nmemb , size ) ; <S2SV_StartBug> if ( ! * ptrptr && ! ( nmemb && size ) ) <S2SV_EndBug> return AVERROR ( ENOMEM ) ; return 0 ; }
","<S2SV_ModStart> * ptrptr && <S2SV_ModEnd> nmemb && size <S2SV_ModStart> nmemb && size <S2SV_ModEnd> ) return AVERROR
"
998,"CWE-125 static void * Type_MLU_Read ( struct _cms_typehandler_struct * self , cmsIOHANDLER * io , cmsUInt32Number * nItems , cmsUInt32Number SizeOfTag ) { cmsMLU * mlu ; cmsUInt32Number Count , RecLen , NumOfWchar ; cmsUInt32Number SizeOfHeader ; cmsUInt32Number Len , Offset ; cmsUInt32Number i ; wchar_t * Block ; cmsUInt32Number BeginOfThisString , EndOfThisString , LargestPosition ; * nItems = 0 ; if ( ! _cmsReadUInt32Number ( io , & Count ) ) return NULL ; if ( ! _cmsReadUInt32Number ( io , & RecLen ) ) return NULL ; if ( RecLen != 12 ) { cmsSignalError ( self -> ContextID , cmsERROR_UNKNOWN_EXTENSION , ""multiLocalizedUnicodeType<S2SV_blank>of<S2SV_blank>len<S2SV_blank>!=<S2SV_blank>12<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported."" ) ; return NULL ; } mlu = cmsMLUalloc ( self -> ContextID , Count ) ; if ( mlu == NULL ) return NULL ; mlu -> UsedEntries = Count ; SizeOfHeader = 12 * Count + sizeof ( _cmsTagBase ) ; LargestPosition = 0 ; for ( i = 0 ; i < Count ; i ++ ) { if ( ! _cmsReadUInt16Number ( io , & mlu -> Entries [ i ] . Language ) ) goto Error ; if ( ! _cmsReadUInt16Number ( io , & mlu -> Entries [ i ] . Country ) ) goto Error ; if ( ! _cmsReadUInt32Number ( io , & Len ) ) goto Error ; if ( ! _cmsReadUInt32Number ( io , & Offset ) ) goto Error ; <S2SV_StartBug> if ( Offset < ( SizeOfHeader + 8 ) ) goto Error ; <S2SV_EndBug> BeginOfThisString = Offset - SizeOfHeader - 8 ; mlu -> Entries [ i ] . Len = ( Len * sizeof ( wchar_t ) ) / sizeof ( cmsUInt16Number ) ; mlu -> Entries [ i ] . StrW = ( BeginOfThisString * sizeof ( wchar_t ) ) / sizeof ( cmsUInt16Number ) ; EndOfThisString = BeginOfThisString + Len ; if ( EndOfThisString > LargestPosition ) LargestPosition = EndOfThisString ; } SizeOfTag = ( LargestPosition * sizeof ( wchar_t ) ) / sizeof ( cmsUInt16Number ) ; if ( SizeOfTag == 0 ) { Block = NULL ; NumOfWchar = 0 ; } else { Block = ( wchar_t * ) _cmsMalloc ( self -> ContextID , SizeOfTag ) ; if ( Block == NULL ) goto Error ; NumOfWchar = SizeOfTag / sizeof ( wchar_t ) ; if ( ! _cmsReadWCharArray ( io , NumOfWchar , Block ) ) goto Error ; } mlu -> MemPool = Block ; mlu -> PoolSize = SizeOfTag ; mlu -> PoolUsed = SizeOfTag ; * nItems = 1 ; return ( void * ) mlu ; Error : if ( mlu ) cmsMLUfree ( mlu ) ; return NULL ; }
","<S2SV_ModStart> + 8 ) ) goto Error ; if ( ( Offset + Len ) > SizeOfTag + 8
"
999,"CWE-119 int exfat_mount ( struct exfat * ef , const char * spec , const char * options ) { int rc ; enum exfat_mode mode ; exfat_tzset ( ) ; memset ( ef , 0 , sizeof ( struct exfat ) ) ; parse_options ( ef , options ) ; if ( match_option ( options , ""ro"" ) ) mode = EXFAT_MODE_RO ; else if ( match_option ( options , ""ro_fallback"" ) ) mode = EXFAT_MODE_ANY ; else mode = EXFAT_MODE_RW ; ef -> dev = exfat_open ( spec , mode ) ; if ( ef -> dev == NULL ) return - EIO ; if ( exfat_get_mode ( ef -> dev ) == EXFAT_MODE_RO ) { if ( mode == EXFAT_MODE_ANY ) ef -> ro = - 1 ; else ef -> ro = 1 ; } ef -> sb = malloc ( sizeof ( struct exfat_super_block ) ) ; if ( ef -> sb == NULL ) { exfat_close ( ef -> dev ) ; exfat_error ( ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>the<S2SV_blank>super<S2SV_blank>block"" ) ; return - ENOMEM ; } memset ( ef -> sb , 0 , sizeof ( struct exfat_super_block ) ) ; if ( exfat_pread ( ef -> dev , ef -> sb , sizeof ( struct exfat_super_block ) , 0 ) < 0 ) { exfat_close ( ef -> dev ) ; free ( ef -> sb ) ; exfat_error ( ""failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>boot<S2SV_blank>sector"" ) ; return - EIO ; } if ( memcmp ( ef -> sb -> oem_name , ""EXFAT<S2SV_blank><S2SV_blank><S2SV_blank>"" , 8 ) != 0 ) { exfat_close ( ef -> dev ) ; free ( ef -> sb ) ; <S2SV_StartBug> exfat_error ( ""exFAT<S2SV_blank>file<S2SV_blank>system<S2SV_blank>is<S2SV_blank>not<S2SV_blank>found"" ) ; <S2SV_EndBug> return - EIO ; } ef -> zero_cluster = malloc ( CLUSTER_SIZE ( * ef -> sb ) ) ; if ( ef -> zero_cluster == NULL ) { exfat_close ( ef -> dev ) ; free ( ef -> sb ) ; exfat_error ( ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>zero<S2SV_blank>sector"" ) ; return - ENOMEM ; } if ( ! verify_vbr_checksum ( ef -> dev , ef -> zero_cluster , SECTOR_SIZE ( * ef -> sb ) ) ) { free ( ef -> zero_cluster ) ; exfat_close ( ef -> dev ) ; free ( ef -> sb ) ; return - EIO ; } memset ( ef -> zero_cluster , 0 , CLUSTER_SIZE ( * ef -> sb ) ) ; if ( ef -> sb -> version . major != 1 || ef -> sb -> version . minor != 0 ) { free ( ef -> zero_cluster ) ; exfat_close ( ef -> dev ) ; exfat_error ( ""unsupported<S2SV_blank>exFAT<S2SV_blank>version:<S2SV_blank>%hhu.%hhu"" , ef -> sb -> version . major , ef -> sb -> version . minor ) ; free ( ef -> sb ) ; return - EIO ; } if ( ef -> sb -> fat_count != 1 ) { free ( ef -> zero_cluster ) ; exfat_close ( ef -> dev ) ; exfat_error ( ""unsupported<S2SV_blank>FAT<S2SV_blank>count:<S2SV_blank>%hhu"" , ef -> sb -> fat_count ) ; free ( ef -> sb ) ; return - EIO ; } <S2SV_StartBug> if ( ( int ) ef -> sb -> sector_bits + ( int ) ef -> sb -> spc_bits > 25 ) <S2SV_EndBug> { free ( ef -> zero_cluster ) ; exfat_close ( ef -> dev ) ; exfat_error ( ""too<S2SV_blank>big<S2SV_blank>cluster<S2SV_blank>size:<S2SV_blank>2^%d"" , ( int ) ef -> sb -> sector_bits + ( int ) ef -> sb -> spc_bits ) ; free ( ef -> sb ) ; return - EIO ; } if ( le64_to_cpu ( ef -> sb -> sector_count ) * SECTOR_SIZE ( * ef -> sb ) > exfat_get_size ( ef -> dev ) ) { exfat_warn ( ""file<S2SV_blank>system<S2SV_blank>is<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>underlying<S2SV_blank>device:<S2SV_blank>"" ""%"" PRIu64 ""<S2SV_blank>><S2SV_blank>%"" PRIu64 , le64_to_cpu ( ef -> sb -> sector_count ) * SECTOR_SIZE ( * ef -> sb ) , exfat_get_size ( ef -> dev ) ) ; } ef -> root = malloc ( sizeof ( struct exfat_node ) ) ; if ( ef -> root == NULL ) { free ( ef -> zero_cluster ) ; exfat_close ( ef -> dev ) ; free ( ef -> sb ) ; exfat_error ( ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>root<S2SV_blank>node"" ) ; return - ENOMEM ; } memset ( ef -> root , 0 , sizeof ( struct exfat_node ) ) ; ef -> root -> flags = EXFAT_ATTRIB_DIR ; ef -> root -> start_cluster = le32_to_cpu ( ef -> sb -> rootdir_cluster ) ; ef -> root -> fptr_cluster = ef -> root -> start_cluster ; ef -> root -> name [ 0 ] = cpu_to_le16 ( '\\0' ) ; ef -> root -> size = rootdir_size ( ef ) ; if ( ef -> root -> size == 0 ) { free ( ef -> root ) ; free ( ef -> zero_cluster ) ; exfat_close ( ef -> dev ) ; free ( ef -> sb ) ; return - EIO ; } ef -> root -> mtime = 0 ; ef -> root -> atime = 0 ; exfat_get_node ( ef -> root ) ; rc = exfat_cache_directory ( ef , ef -> root ) ; if ( rc != 0 ) goto error ; if ( ef -> upcase == NULL ) { exfat_error ( ""upcase<S2SV_blank>table<S2SV_blank>is<S2SV_blank>not<S2SV_blank>found"" ) ; goto error ; } if ( ef -> cmap . chunk == NULL ) { exfat_error ( ""clusters<S2SV_blank>bitmap<S2SV_blank>is<S2SV_blank>not<S2SV_blank>found"" ) ; goto error ; } if ( prepare_super_block ( ef ) != 0 ) goto error ; return 0 ; error : exfat_put_node ( ef , ef -> root ) ; exfat_reset_cache ( ef ) ; free ( ef -> root ) ; free ( ef -> zero_cluster ) ; exfat_close ( ef -> dev ) ; free ( ef -> sb ) ; return - EIO ; }
","<S2SV_ModStart> exfat_error ( ""exFAT<S2SV_blank>file<S2SV_blank>system<S2SV_blank>is<S2SV_blank>not<S2SV_blank>found"" ) ; return - EIO ; } if ( ef -> sb -> sector_bits < 9 ) { exfat_close ( ef -> dev ) ; exfat_error ( ""too<S2SV_blank>small<S2SV_blank>sector<S2SV_blank>size:<S2SV_blank>2^%hhd"" , ef -> sb -> sector_bits ) ; free ( ef -> sb ) ; return - EIO ; } if ( ( int ) ef -> sb -> sector_bits + ( int ) ef -> sb -> spc_bits > 25 ) { exfat_close ( ef -> dev ) ; exfat_error ( ""too<S2SV_blank>big<S2SV_blank>cluster<S2SV_blank>size:<S2SV_blank>2^(%hhd+%hhd)"" , ef -> sb -> sector_bits , ef -> sb -> spc_bits ) ; free ( ef -> sb <S2SV_ModStart> } if ( <S2SV_ModEnd> le64_to_cpu ( ef
"
1000,"CWE-125 static const u_char * ikev1_n_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi0 _U_ , uint32_t proto0 _U_ , int depth _U_ ) { const struct ikev1_pl_n * p ; struct ikev1_pl_n n ; const u_char * cp ; const u_char * ep2 ; uint32_t doi ; uint32_t proto ; static const char * notify_error_str [ ] = { NULL , ""INVALID-PAYLOAD-TYPE"" , ""DOI-NOT-SUPPORTED"" , ""SITUATION-NOT-SUPPORTED"" , ""INVALID-COOKIE"" , ""INVALID-MAJOR-VERSION"" , ""INVALID-MINOR-VERSION"" , ""INVALID-EXCHANGE-TYPE"" , ""INVALID-FLAGS"" , ""INVALID-MESSAGE-ID"" , ""INVALID-PROTOCOL-ID"" , ""INVALID-SPI"" , ""INVALID-TRANSFORM-ID"" , ""ATTRIBUTES-NOT-SUPPORTED"" , ""NO-PROPOSAL-CHOSEN"" , ""BAD-PROPOSAL-SYNTAX"" , ""PAYLOAD-MALFORMED"" , ""INVALID-KEY-INFORMATION"" , ""INVALID-ID-INFORMATION"" , ""INVALID-CERT-ENCODING"" , ""INVALID-CERTIFICATE"" , ""CERT-TYPE-UNSUPPORTED"" , ""INVALID-CERT-AUTHORITY"" , ""INVALID-HASH-INFORMATION"" , ""AUTHENTICATION-FAILED"" , ""INVALID-SIGNATURE"" , ""ADDRESS-NOTIFICATION"" , ""NOTIFY-SA-LIFETIME"" , ""CERTIFICATE-UNAVAILABLE"" , ""UNSUPPORTED-EXCHANGE-TYPE"" , ""UNEQUAL-PAYLOAD-LENGTHS"" , } ; static const char * ipsec_notify_error_str [ ] = { ""RESERVED"" , } ; static const char * notify_status_str [ ] = { ""CONNECTED"" , } ; static const char * ipsec_notify_status_str [ ] = { ""RESPONDER-LIFETIME"" , ""REPLAY-STATUS"" , ""INITIAL-CONTACT"" , } ; # define NOTIFY_ERROR_STR ( x ) STR_OR_ID ( ( x ) , notify_error_str ) # define IPSEC_NOTIFY_ERROR_STR ( x ) STR_OR_ID ( ( u_int ) ( ( x ) - 8192 ) , ipsec_notify_error_str ) # define NOTIFY_STATUS_STR ( x ) STR_OR_ID ( ( u_int ) ( ( x ) - 16384 ) , notify_status_str ) # define IPSEC_NOTIFY_STATUS_STR ( x ) STR_OR_ID ( ( u_int ) ( ( x ) - 24576 ) , ipsec_notify_status_str ) ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_N ) ) ) ; p = ( const struct ikev1_pl_n * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & n , ext , sizeof ( n ) ) ; doi = ntohl ( n . doi ) ; proto = n . prot_id ; if ( doi != 1 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>doi=%d"" , doi ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>proto=%d"" , proto ) ) ; if ( ntohs ( n . type ) < 8192 ) ND_PRINT ( ( ndo , ""<S2SV_blank>type=%s"" , NOTIFY_ERROR_STR ( ntohs ( n . type ) ) ) ) ; else if ( ntohs ( n . type ) < 16384 ) ND_PRINT ( ( ndo , ""<S2SV_blank>type=%s"" , numstr ( ntohs ( n . type ) ) ) ) ; else if ( ntohs ( n . type ) < 24576 ) ND_PRINT ( ( ndo , ""<S2SV_blank>type=%s"" , NOTIFY_STATUS_STR ( ntohs ( n . type ) ) ) ) ; else ND_PRINT ( ( ndo , ""<S2SV_blank>type=%s"" , numstr ( ntohs ( n . type ) ) ) ) ; if ( n . spi_size ) { ND_PRINT ( ( ndo , ""<S2SV_blank>spi="" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( p + 1 ) , n . spi_size ) ) goto trunc ; } return ( const u_char * ) ( p + 1 ) + n . spi_size ; } ND_PRINT ( ( ndo , ""<S2SV_blank>doi=ipsec"" ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>proto=%s"" , PROTOIDSTR ( proto ) ) ) ; if ( ntohs ( n . type ) < 8192 ) ND_PRINT ( ( ndo , ""<S2SV_blank>type=%s"" , NOTIFY_ERROR_STR ( ntohs ( n . type ) ) ) ) ; else if ( ntohs ( n . type ) < 16384 ) ND_PRINT ( ( ndo , ""<S2SV_blank>type=%s"" , IPSEC_NOTIFY_ERROR_STR ( ntohs ( n . type ) ) ) ) ; else if ( ntohs ( n . type ) < 24576 ) ND_PRINT ( ( ndo , ""<S2SV_blank>type=%s"" , NOTIFY_STATUS_STR ( ntohs ( n . type ) ) ) ) ; else if ( ntohs ( n . type ) < 32768 ) ND_PRINT ( ( ndo , ""<S2SV_blank>type=%s"" , IPSEC_NOTIFY_STATUS_STR ( ntohs ( n . type ) ) ) ) ; else ND_PRINT ( ( ndo , ""<S2SV_blank>type=%s"" , numstr ( ntohs ( n . type ) ) ) ) ; if ( n . spi_size ) { ND_PRINT ( ( ndo , ""<S2SV_blank>spi="" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( p + 1 ) , n . spi_size ) ) goto trunc ; } cp = ( const u_char * ) ( p + 1 ) + n . spi_size ; ep2 = ( const u_char * ) p + item_len ; if ( cp < ep ) { switch ( ntohs ( n . type ) ) { case IPSECDOI_NTYPE_RESPONDER_LIFETIME : { const struct attrmap * map = oakley_t_map ; size_t nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>attrs=("" ) ) ; while ( cp < ep && cp < ep2 ) { cp = ikev1_attrmap_print ( ndo , cp , <S2SV_StartBug> ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; <S2SV_EndBug> } ND_PRINT ( ( ndo , "")"" ) ) ; break ; } case IPSECDOI_NTYPE_REPLAY_STATUS : ND_PRINT ( ( ndo , ""<S2SV_blank>status=("" ) ) ; ND_PRINT ( ( ndo , ""replay<S2SV_blank>detection<S2SV_blank>%sabled"" , EXTRACT_32BITS ( cp ) ? ""en"" : ""dis"" ) ) ; ND_PRINT ( ( ndo , "")"" ) ) ; break ; default : if ( ndo -> ndo_vflag > 3 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>data=("" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( cp ) , ep - cp ) ) goto trunc ; ND_PRINT ( ( ndo , "")"" ) ) ; } else { if ( ! ike_show_somedata ( ndo , cp , ep ) ) goto trunc ; } break ; } } return ( const u_char * ) ext + item_len ; trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|%s]"" , NPSTR ( ISAKMP_NPTYPE_N ) ) ) ; return NULL ; }
","<S2SV_ModStart> , cp , ep2 <S2SV_ModEnd> , map , <S2SV_ModStart> nmap ) ; if ( cp == NULL ) { ND_PRINT ( ( ndo , "")"" ) ) ; goto trunc ; }
"
1001,"CWE-20 void mk_request_free ( struct session_request * sr ) { if ( sr -> fd_file > 0 ) { <S2SV_StartBug> mk_vhost_close ( sr ) ; <S2SV_EndBug> } if ( sr -> headers . location ) { mk_mem_free ( sr -> headers . location ) ; } if ( sr -> uri_processed . data != sr -> uri . data ) { mk_ptr_free ( & sr -> uri_processed ) ; } if ( sr -> real_path . data != sr -> real_path_static ) { mk_ptr_free ( & sr -> real_path ) ; } }
","<S2SV_ModStart> 0 ) { if ( sr -> fd_is_fdt == MK_TRUE ) { <S2SV_ModStart> sr ) ; } else { close ( sr -> fd_file ) ; }
"
1002,"CWE-20 static int kvm_vm_ioctl_create_vcpu ( struct kvm * kvm , u32 id ) { int r ; struct kvm_vcpu * vcpu , * v ; <S2SV_StartBug> vcpu = kvm_arch_vcpu_create ( kvm , id ) ; <S2SV_EndBug> if ( IS_ERR ( vcpu ) ) return PTR_ERR ( vcpu ) ; preempt_notifier_init ( & vcpu -> preempt_notifier , & kvm_preempt_ops ) ; r = kvm_arch_vcpu_setup ( vcpu ) ; if ( r ) goto vcpu_destroy ; mutex_lock ( & kvm -> lock ) ; if ( ! kvm_vcpu_compatible ( vcpu ) ) { r = - EINVAL ; goto unlock_vcpu_destroy ; } if ( atomic_read ( & kvm -> online_vcpus ) == KVM_MAX_VCPUS ) { r = - EINVAL ; goto unlock_vcpu_destroy ; } kvm_for_each_vcpu ( r , v , kvm ) if ( v -> vcpu_id == id ) { r = - EEXIST ; goto unlock_vcpu_destroy ; } BUG_ON ( kvm -> vcpus [ atomic_read ( & kvm -> online_vcpus ) ] ) ; kvm_get_kvm ( kvm ) ; r = create_vcpu_fd ( vcpu ) ; if ( r < 0 ) { kvm_put_kvm ( kvm ) ; goto unlock_vcpu_destroy ; } kvm -> vcpus [ atomic_read ( & kvm -> online_vcpus ) ] = vcpu ; smp_wmb ( ) ; atomic_inc ( & kvm -> online_vcpus ) ; mutex_unlock ( & kvm -> lock ) ; kvm_arch_vcpu_postcreate ( vcpu ) ; return r ; unlock_vcpu_destroy : mutex_unlock ( & kvm -> lock ) ; vcpu_destroy : kvm_arch_vcpu_destroy ( vcpu ) ; return r ; }
","<S2SV_ModStart> * v ; if ( id >= KVM_MAX_VCPUS ) return - EINVAL ;
"
1003,"CWE-834 static Image * ReadPSImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define BoundingBox ""BoundingBox:"" # define BeginDocument ""BeginDocument:"" # define BeginXMPPacket ""<?xpacket<S2SV_blank>begin="" # define EndXMPPacket ""<?xpacket<S2SV_blank>end="" # define ICCProfile ""BeginICCProfile:"" # define CMYKCustomColor ""CMYKCustomColor:"" # define CMYKProcessColor ""CMYKProcessColor:"" # define DocumentMedia ""DocumentMedia:"" # define DocumentCustomColors ""DocumentCustomColors:"" # define DocumentProcessColors ""DocumentProcessColors:"" # define EndDocument ""EndDocument:"" # define HiResBoundingBox ""HiResBoundingBox:"" # define ImageData ""ImageData:"" # define PageBoundingBox ""PageBoundingBox:"" # define LanguageLevel ""LanguageLevel:"" # define PageMedia ""PageMedia:"" # define Pages ""Pages:"" # define PhotoshopProfile ""BeginPhotoshop:"" # define PostscriptLevel ""!PS-"" # define RenderPostscriptText ""<S2SV_blank><S2SV_blank>Rendering<S2SV_blank>Postscript...<S2SV_blank><S2SV_blank>"" # define SpotColor ""+<S2SV_blank>"" char command [ MaxTextExtent ] , * density , filename [ MaxTextExtent ] , geometry [ MaxTextExtent ] , input_filename [ MaxTextExtent ] , message [ MaxTextExtent ] , * options , postscript_filename [ MaxTextExtent ] ; const char * option ; const DelegateInfo * delegate_info ; GeometryInfo geometry_info ; Image * image , * next , * postscript_image ; ImageInfo * read_info ; int c , file ; MagickBooleanType cmyk , fitPage , skip , status ; MagickStatusType flags ; PointInfo delta , resolution ; RectangleInfo page ; register char * p ; register ssize_t i ; SegmentInfo bounds , hires_bounds ; short int hex_digits [ 256 ] ; size_t length , priority ; ssize_t count ; StringInfo * profile ; unsigned long columns , extent , language_level , pages , rows , scene , spotcolor ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } status = AcquireUniqueSymbolicLink ( image_info -> filename , input_filename ) ; if ( status == MagickFalse ) { ThrowFileException ( exception , FileOpenError , ""UnableToCreateTemporaryFile"" , image_info -> filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( hex_digits , 0 , sizeof ( hex_digits ) ) ; hex_digits [ ( int ) '0' ] = 0 ; hex_digits [ ( int ) '1' ] = 1 ; hex_digits [ ( int ) '2' ] = 2 ; hex_digits [ ( int ) '3' ] = 3 ; hex_digits [ ( int ) '4' ] = 4 ; hex_digits [ ( int ) '5' ] = 5 ; hex_digits [ ( int ) '6' ] = 6 ; hex_digits [ ( int ) '7' ] = 7 ; hex_digits [ ( int ) '8' ] = 8 ; hex_digits [ ( int ) '9' ] = 9 ; hex_digits [ ( int ) 'a' ] = 10 ; hex_digits [ ( int ) 'b' ] = 11 ; hex_digits [ ( int ) 'c' ] = 12 ; hex_digits [ ( int ) 'd' ] = 13 ; hex_digits [ ( int ) 'e' ] = 14 ; hex_digits [ ( int ) 'f' ] = 15 ; hex_digits [ ( int ) 'A' ] = 10 ; hex_digits [ ( int ) 'B' ] = 11 ; hex_digits [ ( int ) 'C' ] = 12 ; hex_digits [ ( int ) 'D' ] = 13 ; hex_digits [ ( int ) 'E' ] = 14 ; hex_digits [ ( int ) 'F' ] = 15 ; delta . x = DefaultResolution ; delta . y = DefaultResolution ; if ( ( image -> x_resolution == 0.0 ) || ( image -> y_resolution == 0.0 ) ) { flags = ParseGeometry ( PSDensityGeometry , & geometry_info ) ; image -> x_resolution = geometry_info . rho ; image -> y_resolution = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> y_resolution = image -> x_resolution ; } if ( image_info -> density != ( char * ) NULL ) { flags = ParseGeometry ( image_info -> density , & geometry_info ) ; image -> x_resolution = geometry_info . rho ; image -> y_resolution = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> y_resolution = image -> x_resolution ; } ( void ) ParseAbsoluteGeometry ( PSPageGeometry , & page ) ; if ( image_info -> page != ( char * ) NULL ) ( void ) ParseAbsoluteGeometry ( image_info -> page , & page ) ; resolution . x = image -> x_resolution ; resolution . y = image -> y_resolution ; page . width = ( size_t ) ceil ( ( double ) ( page . width * resolution . x / delta . x ) - 0.5 ) ; page . height = ( size_t ) ceil ( ( double ) ( page . height * resolution . y / delta . y ) - 0.5 ) ; ( void ) ResetMagickMemory ( & bounds , 0 , sizeof ( bounds ) ) ; ( void ) ResetMagickMemory ( command , 0 , sizeof ( command ) ) ; cmyk = image_info -> colorspace == CMYKColorspace ? MagickTrue : MagickFalse ; ( void ) ResetMagickMemory ( & hires_bounds , 0 , sizeof ( hires_bounds ) ) ; priority = 0 ; columns = 0 ; rows = 0 ; extent = 0 ; spotcolor = 0 ; language_level = 1 ; skip = MagickFalse ; pages = ( ~ 0UL ) ; p = command ; for ( c = ReadBlobByte ( image ) ; c != EOF ; c = ReadBlobByte ( image ) ) { * p ++ = ( char ) c ; if ( ( strchr ( ""\\n\\r%"" , c ) == ( char * ) NULL ) && ( ( size_t ) ( p - command ) < ( MaxTextExtent - 1 ) ) ) continue ; * p = '\\0' ; p = command ; if ( LocaleNCompare ( BeginDocument , command , strlen ( BeginDocument ) ) == 0 ) skip = MagickTrue ; if ( LocaleNCompare ( EndDocument , command , strlen ( EndDocument ) ) == 0 ) skip = MagickFalse ; if ( skip != MagickFalse ) continue ; if ( LocaleNCompare ( PostscriptLevel , command , strlen ( PostscriptLevel ) ) == 0 ) { ( void ) SetImageProperty ( image , ""ps:Level"" , command + 4 ) ; if ( GlobExpression ( command , ""*EPSF-*"" , MagickTrue ) != MagickFalse ) pages = 1 ; } if ( LocaleNCompare ( LanguageLevel , command , strlen ( LanguageLevel ) ) == 0 ) ( void ) sscanf ( command , LanguageLevel ""<S2SV_blank>%lu"" , & language_level ) ; if ( LocaleNCompare ( Pages , command , strlen ( Pages ) ) == 0 ) ( void ) sscanf ( command , Pages ""<S2SV_blank>%lu"" , & pages ) ; if ( LocaleNCompare ( ImageData , command , strlen ( ImageData ) ) == 0 ) ( void ) sscanf ( command , ImageData ""<S2SV_blank>%lu<S2SV_blank>%lu"" , & columns , & rows ) ; if ( LocaleNCompare ( ICCProfile , command , strlen ( ICCProfile ) ) == 0 ) { unsigned char * datum ; profile = AcquireStringInfo ( MaxTextExtent ) ; datum = GetStringInfoDatum ( profile ) ; for ( i = 0 ; ( c = ProfileInteger ( image , hex_digits ) ) != EOF ; i ++ ) { if ( i >= ( ssize_t ) GetStringInfoLength ( profile ) ) { SetStringInfoLength ( profile , ( size_t ) i << 1 ) ; datum = GetStringInfoDatum ( profile ) ; } datum [ i ] = ( unsigned char ) c ; } SetStringInfoLength ( profile , ( size_t ) i + 1 ) ; ( void ) SetImageProfile ( image , ""icc"" , profile ) ; profile = DestroyStringInfo ( profile ) ; continue ; } if ( LocaleNCompare ( PhotoshopProfile , command , strlen ( PhotoshopProfile ) ) == 0 ) { unsigned char * p ; count = ( ssize_t ) sscanf ( command , PhotoshopProfile ""<S2SV_blank>%lu"" , & extent ) ; if ( count != 1 ) continue ; <S2SV_StartBug> length = extent ; <S2SV_EndBug> profile = BlobToStringInfo ( ( const void * ) NULL , length ) ; if ( profile != ( StringInfo * ) NULL ) { p = GetStringInfoDatum ( profile ) ; for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) * p ++ = ( unsigned char ) ProfileInteger ( image , hex_digits ) ; ( void ) SetImageProfile ( image , ""8bim"" , profile ) ; profile = DestroyStringInfo ( profile ) ; } continue ; } if ( LocaleNCompare ( BeginXMPPacket , command , strlen ( BeginXMPPacket ) ) == 0 ) { register size_t i ; p = command ; profile = StringToStringInfo ( command ) ; for ( i = GetStringInfoLength ( profile ) - 1 ; c != EOF ; i ++ ) { SetStringInfoLength ( profile , i + 1 ) ; c = ReadBlobByte ( image ) ; GetStringInfoDatum ( profile ) [ i ] = ( unsigned char ) c ; * p ++ = ( char ) c ; if ( ( strchr ( ""\\n\\r%"" , c ) == ( char * ) NULL ) && ( ( size_t ) ( p - command ) < ( MaxTextExtent - 1 ) ) ) continue ; * p = '\\0' ; p = command ; if ( LocaleNCompare ( EndXMPPacket , command , strlen ( EndXMPPacket ) ) == 0 ) break ; } SetStringInfoLength ( profile , i ) ; ( void ) SetImageProfile ( image , ""xmp"" , profile ) ; profile = DestroyStringInfo ( profile ) ; continue ; } length = strlen ( DocumentProcessColors ) ; if ( LocaleNCompare ( DocumentProcessColors , command , length ) == 0 ) { if ( ( GlobExpression ( command , ""*Cyan*"" , MagickTrue ) != MagickFalse ) || ( GlobExpression ( command , ""*Magenta*"" , MagickTrue ) != MagickFalse ) || ( GlobExpression ( command , ""*Yellow*"" , MagickTrue ) != MagickFalse ) ) cmyk = MagickTrue ; } if ( LocaleNCompare ( CMYKCustomColor , command , strlen ( CMYKCustomColor ) ) == 0 ) cmyk = MagickTrue ; if ( LocaleNCompare ( CMYKProcessColor , command , strlen ( CMYKProcessColor ) ) == 0 ) cmyk = MagickTrue ; length = strlen ( DocumentCustomColors ) ; if ( ( LocaleNCompare ( DocumentCustomColors , command , length ) == 0 ) || ( LocaleNCompare ( CMYKCustomColor , command , strlen ( CMYKCustomColor ) ) == 0 ) || ( LocaleNCompare ( SpotColor , command , strlen ( SpotColor ) ) == 0 ) ) { char property [ MaxTextExtent ] , * value ; register char * p ; ( void ) FormatLocaleString ( property , MaxTextExtent , ""ps:SpotColor-%.20g"" , ( double ) ( spotcolor ++ ) ) ; for ( p = command ; * p != '\\0' ; p ++ ) if ( isspace ( ( int ) ( unsigned char ) * p ) != 0 ) break ; value = AcquireString ( p ) ; ( void ) SubstituteString ( & value , ""("" , """" ) ; ( void ) SubstituteString ( & value , "")"" , """" ) ; ( void ) StripString ( value ) ; ( void ) SetImageProperty ( image , property , value ) ; value = DestroyString ( value ) ; continue ; } if ( image_info -> page != ( char * ) NULL ) continue ; count = 0 ; i = 0 ; if ( LocaleNCompare ( BoundingBox , command , strlen ( BoundingBox ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , BoundingBox ""<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf"" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 2 ; } if ( LocaleNCompare ( DocumentMedia , command , strlen ( DocumentMedia ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , DocumentMedia ""<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf"" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 1 ; } if ( LocaleNCompare ( HiResBoundingBox , command , strlen ( HiResBoundingBox ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , HiResBoundingBox ""<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf"" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 3 ; } if ( LocaleNCompare ( PageBoundingBox , command , strlen ( PageBoundingBox ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , PageBoundingBox ""<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf"" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 1 ; } if ( LocaleNCompare ( PageMedia , command , strlen ( PageMedia ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , PageMedia ""<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf"" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 1 ; } if ( ( count != 4 ) || ( i < ( ssize_t ) priority ) ) continue ; if ( ( fabs ( bounds . x2 - bounds . x1 ) <= fabs ( hires_bounds . x2 - hires_bounds . x1 ) ) || ( fabs ( bounds . y2 - bounds . y1 ) <= fabs ( hires_bounds . y2 - hires_bounds . y1 ) ) ) if ( i == ( ssize_t ) priority ) continue ; hires_bounds = bounds ; priority = i ; } if ( ( fabs ( hires_bounds . x2 - hires_bounds . x1 ) >= MagickEpsilon ) && ( fabs ( hires_bounds . y2 - hires_bounds . y1 ) >= MagickEpsilon ) ) { ( void ) FormatLocaleString ( geometry , MaxTextExtent , ""%gx%g%+.15g%+.15g"" , hires_bounds . x2 - hires_bounds . x1 , hires_bounds . y2 - hires_bounds . y1 , hires_bounds . x1 , hires_bounds . y1 ) ; ( void ) SetImageProperty ( image , ""ps:HiResBoundingBox"" , geometry ) ; page . width = ( size_t ) ceil ( ( double ) ( ( hires_bounds . x2 - hires_bounds . x1 ) * resolution . x / delta . x ) - 0.5 ) ; page . height = ( size_t ) ceil ( ( double ) ( ( hires_bounds . y2 - hires_bounds . y1 ) * resolution . y / delta . y ) - 0.5 ) ; } fitPage = MagickFalse ; option = GetImageOption ( image_info , ""eps:fit-page"" ) ; if ( option != ( char * ) NULL ) { char * geometry ; MagickStatusType flags ; geometry = GetPageGeometry ( option ) ; flags = ParseMetaGeometry ( geometry , & page . x , & page . y , & page . width , & page . height ) ; if ( flags == NoValue ) { ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , OptionError , ""InvalidGeometry"" , ""`%s\'"" , option ) ; image = DestroyImage ( image ) ; return ( ( Image * ) NULL ) ; } page . width = ( size_t ) ceil ( ( double ) ( page . width * image -> x_resolution / delta . x ) - 0.5 ) ; page . height = ( size_t ) ceil ( ( double ) ( page . height * image -> y_resolution / delta . y ) - 0.5 ) ; geometry = DestroyString ( geometry ) ; fitPage = MagickTrue ; } ( void ) CloseBlob ( image ) ; if ( IssRGBCompatibleColorspace ( image_info -> colorspace ) != MagickFalse ) cmyk = MagickFalse ; file = AcquireUniqueFileResource ( postscript_filename ) ; if ( file == - 1 ) { ThrowFileException ( & image -> exception , FileOpenError , ""UnableToOpenFile"" , image_info -> filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) CopyMagickString ( command , ""/setpagedevice<S2SV_blank>{pop}<S2SV_blank>bind<S2SV_blank>1<S2SV_blank>index<S2SV_blank>where<S2SV_blank>{"" ""dup<S2SV_blank>wcheck<S2SV_blank>{3<S2SV_blank>1<S2SV_blank>roll<S2SV_blank>put}<S2SV_blank>{pop<S2SV_blank>def}<S2SV_blank>ifelse}<S2SV_blank>{def}<S2SV_blank>ifelse\\n"" ""<</UseCIEColor<S2SV_blank>true>>setpagedevice\\n"" , MaxTextExtent ) ; count = write ( file , command , ( unsigned int ) strlen ( command ) ) ; if ( image_info -> page == ( char * ) NULL ) { char translate_geometry [ MaxTextExtent ] ; ( void ) FormatLocaleString ( translate_geometry , MaxTextExtent , ""%g<S2SV_blank>%g<S2SV_blank>translate\\n"" , - hires_bounds . x1 , - hires_bounds . y1 ) ; count = write ( file , translate_geometry , ( unsigned int ) strlen ( translate_geometry ) ) ; } file = close ( file ) - 1 ; if ( image_info -> monochrome != MagickFalse ) delegate_info = GetDelegateInfo ( ""ps:mono"" , ( char * ) NULL , exception ) ; else if ( cmyk != MagickFalse ) delegate_info = GetDelegateInfo ( ""ps:cmyk"" , ( char * ) NULL , exception ) ; else delegate_info = GetDelegateInfo ( ""ps:alpha"" , ( char * ) NULL , exception ) ; if ( delegate_info == ( const DelegateInfo * ) NULL ) { ( void ) RelinquishUniqueFileResource ( postscript_filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } density = AcquireString ( """" ) ; options = AcquireString ( """" ) ; ( void ) FormatLocaleString ( density , MaxTextExtent , ""%gx%g"" , resolution . x , resolution . y ) ; ( void ) FormatLocaleString ( options , MaxTextExtent , ""-g%.20gx%.20g<S2SV_blank>"" , ( double ) page . width , ( double ) page . height ) ; read_info = CloneImageInfo ( image_info ) ; * read_info -> magick = '\\0' ; if ( read_info -> number_scenes != 0 ) { char pages [ MaxTextExtent ] ; ( void ) FormatLocaleString ( pages , MaxTextExtent , ""-dFirstPage=%.20g<S2SV_blank>"" ""-dLastPage=%.20g<S2SV_blank>"" , ( double ) read_info -> scene + 1 , ( double ) ( read_info -> scene + read_info -> number_scenes ) ) ; ( void ) ConcatenateMagickString ( options , pages , MaxTextExtent ) ; read_info -> number_scenes = 0 ; if ( read_info -> scenes != ( char * ) NULL ) * read_info -> scenes = '\\0' ; } if ( * image_info -> magick == 'E' ) { option = GetImageOption ( image_info , ""eps:use-cropbox"" ) ; if ( ( option == ( const char * ) NULL ) || ( IsStringTrue ( option ) != MagickFalse ) ) ( void ) ConcatenateMagickString ( options , ""-dEPSCrop<S2SV_blank>"" , MaxTextExtent ) ; if ( fitPage != MagickFalse ) ( void ) ConcatenateMagickString ( options , ""-dEPSFitPage<S2SV_blank>"" , MaxTextExtent ) ; } ( void ) CopyMagickString ( filename , read_info -> filename , MaxTextExtent ) ; ( void ) AcquireUniqueFilename ( filename ) ; ( void ) RelinquishUniqueFileResource ( filename ) ; ( void ) ConcatenateMagickString ( filename , ""%d"" , MaxTextExtent ) ; ( void ) FormatLocaleString ( command , MaxTextExtent , GetDelegateCommands ( delegate_info ) , read_info -> antialias != MagickFalse ? 4 : 1 , read_info -> antialias != MagickFalse ? 4 : 1 , density , options , filename , postscript_filename , input_filename ) ; options = DestroyString ( options ) ; density = DestroyString ( density ) ; * message = '\\0' ; status = InvokePostscriptDelegate ( read_info -> verbose , command , message , exception ) ; ( void ) InterpretImageFilename ( image_info , image , filename , 1 , read_info -> filename ) ; if ( ( status == MagickFalse ) || ( IsPostscriptRendered ( read_info -> filename ) == MagickFalse ) ) { ( void ) ConcatenateMagickString ( command , ""<S2SV_blank>-c<S2SV_blank>showpage"" , MaxTextExtent ) ; status = InvokePostscriptDelegate ( read_info -> verbose , command , message , exception ) ; } ( void ) RelinquishUniqueFileResource ( postscript_filename ) ; ( void ) RelinquishUniqueFileResource ( input_filename ) ; postscript_image = ( Image * ) NULL ; if ( status == MagickFalse ) for ( i = 1 ; ; i ++ ) { ( void ) InterpretImageFilename ( image_info , image , filename , ( int ) i , read_info -> filename ) ; if ( IsPostscriptRendered ( read_info -> filename ) == MagickFalse ) break ; ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; } else for ( i = 1 ; ; i ++ ) { ( void ) InterpretImageFilename ( image_info , image , filename , ( int ) i , read_info -> filename ) ; if ( IsPostscriptRendered ( read_info -> filename ) == MagickFalse ) break ; read_info -> blob = NULL ; read_info -> length = 0 ; next = ReadImage ( read_info , exception ) ; ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; if ( next == ( Image * ) NULL ) break ; AppendImageToList ( & postscript_image , next ) ; } ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; read_info = DestroyImageInfo ( read_info ) ; if ( postscript_image == ( Image * ) NULL ) { if ( * message != '\\0' ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , DelegateError , ""PostscriptDelegateFailed"" , ""`%s\'"" , message ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( LocaleCompare ( postscript_image -> magick , ""BMP"" ) == 0 ) { Image * cmyk_image ; cmyk_image = ConsolidateCMYKImages ( postscript_image , exception ) ; if ( cmyk_image != ( Image * ) NULL ) { postscript_image = DestroyImageList ( postscript_image ) ; postscript_image = cmyk_image ; } } if ( image_info -> number_scenes != 0 ) { Image * clone_image ; register ssize_t i ; for ( i = 0 ; i < ( ssize_t ) image_info -> scene ; i ++ ) { clone_image = CloneImage ( postscript_image , 1 , 1 , MagickTrue , exception ) ; if ( clone_image != ( Image * ) NULL ) PrependImageToList ( & postscript_image , clone_image ) ; } } do { ( void ) CopyMagickString ( postscript_image -> filename , filename , MaxTextExtent ) ; ( void ) CopyMagickString ( postscript_image -> magick , image -> magick , MaxTextExtent ) ; if ( columns != 0 ) postscript_image -> magick_columns = columns ; if ( rows != 0 ) postscript_image -> magick_rows = rows ; postscript_image -> page = page ; ( void ) CloneImageProfiles ( postscript_image , image ) ; ( void ) CloneImageProperties ( postscript_image , image ) ; next = SyncNextImageInList ( postscript_image ) ; if ( next != ( Image * ) NULL ) postscript_image = next ; } while ( next != ( Image * ) NULL ) ; image = DestroyImageList ( image ) ; scene = 0 ; for ( next = GetFirstImageInList ( postscript_image ) ; next != ( Image * ) NULL ; ) { next -> scene = scene ++ ; next = GetNextImageInList ( next ) ; } return ( GetFirstImageInList ( postscript_image ) ) ; }
","<S2SV_ModStart> length = extent ; if ( length > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" )
"
1004,"CWE-22 void wiki_handle_http_request ( HttpRequest * req ) { HttpResponse * res = http_response_new ( req ) ; char * page = http_request_get_path_info ( req ) ; char * command = http_request_get_query_string ( req ) ; char * wikitext = """" ; util_dehttpize ( page ) ; if ( ! strcmp ( page , ""/"" ) ) { if ( access ( ""WikiHome"" , R_OK ) != 0 ) wiki_redirect ( res , ""/WikiHome?create"" ) ; page = ""/WikiHome"" ; } if ( ! strcmp ( page , ""/styles.css"" ) ) { http_response_set_content_type ( res , ""text/css"" ) ; http_response_printf ( res , ""%s"" , CssData ) ; http_response_send ( res ) ; exit ( 0 ) ; } if ( ! strcmp ( page , ""/favicon.ico"" ) ) { http_response_set_content_type ( res , ""image/ico"" ) ; http_response_set_data ( res , FaviconData , FaviconDataLen ) ; http_response_send ( res ) ; exit ( 0 ) ; } page = page + 1 ; if ( ! strncmp ( page , ""api/"" , 4 ) ) { char * p ; page += 4 ; for ( p = page ; * p != '\\0' ; p ++ ) if ( * p == '?' ) { * p = '\\0' ; break ; } wiki_handle_rest_call ( req , res , page ) ; exit ( 0 ) ; } <S2SV_StartBug> if ( strchr ( page , '/' ) ) <S2SV_EndBug> { http_response_set_status ( res , 404 , ""Not<S2SV_blank>Found"" ) ; http_response_printf ( res , ""<html><body>404<S2SV_blank>Not<S2SV_blank>Found</body></html>\\n"" ) ; http_response_send ( res ) ; exit ( 0 ) ; } if ( ! strcmp ( page , ""Changes"" ) ) { wiki_show_changes_page ( res ) ; } else if ( ! strcmp ( page , ""ChangesRss"" ) ) { wiki_show_changes_page_rss ( res ) ; } else if ( ! strcmp ( page , ""Search"" ) ) { wiki_show_search_results_page ( res , http_request_param_get ( req , ""expr"" ) ) ; } else if ( ! strcmp ( page , ""Create"" ) ) { if ( ( wikitext = http_request_param_get ( req , ""title"" ) ) != NULL ) { wiki_redirect ( res , http_request_param_get ( req , ""title"" ) ) ; } else { wiki_show_create_page ( res ) ; } } else { if ( ( wikitext = http_request_param_get ( req , ""wikitext"" ) ) != NULL ) { file_write ( page , wikitext ) ; } if ( access ( page , R_OK ) == 0 ) { wikitext = file_read ( page ) ; if ( ! strcmp ( command , ""edit"" ) ) { wiki_show_edit_page ( res , wikitext , page ) ; } else { wiki_show_page ( res , wikitext , page ) ; } } else { if ( ! strcmp ( command , ""create"" ) ) { wiki_show_edit_page ( res , NULL , page ) ; } else { char buf [ 1024 ] ; snprintf ( buf , 1024 , ""%s?create"" , page ) ; wiki_redirect ( res , buf ) ; } } } }
","<S2SV_ModStart> } if ( ! page_name_is_good ( page <S2SV_ModEnd> ) ) {
"
1005,"CWE-476 static void i8042_stop ( struct serio * serio ) { struct i8042_port * port = serio -> port_data ; <S2SV_StartBug> port -> exists = false ; <S2SV_EndBug> synchronize_irq ( I8042_AUX_IRQ ) ; synchronize_irq ( I8042_KBD_IRQ ) ; <S2SV_StartBug> port -> serio = NULL ; <S2SV_EndBug> }
","<S2SV_ModStart> -> port_data ; spin_lock_irq ( & i8042_lock ) ; <S2SV_ModStart> exists = false ; port -> serio = NULL ; spin_unlock_irq ( & i8042_lock ) <S2SV_ModStart> I8042_KBD_IRQ ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
"
1006,"CWE-264 NORET_TYPE void do_exit ( long code ) { struct task_struct * tsk = current ; int group_dead ; profile_task_exit ( tsk ) ; WARN_ON ( atomic_read ( & tsk -> fs_excl ) ) ; if ( unlikely ( in_interrupt ( ) ) ) panic ( ""Aiee,<S2SV_blank>killing<S2SV_blank>interrupt<S2SV_blank>handler!"" ) ; if ( unlikely ( ! tsk -> pid ) ) panic ( ""Attempted<S2SV_blank>to<S2SV_blank>kill<S2SV_blank>the<S2SV_blank>idle<S2SV_blank>task!"" ) ; tracehook_report_exit ( & code ) ; if ( unlikely ( tsk -> flags & PF_EXITING ) ) { printk ( KERN_ALERT ""Fixing<S2SV_blank>recursive<S2SV_blank>fault<S2SV_blank>but<S2SV_blank>reboot<S2SV_blank>is<S2SV_blank>needed!\\n"" ) ; tsk -> flags |= PF_EXITPIDONE ; if ( tsk -> io_context ) exit_io_context ( ) ; set_current_state ( TASK_UNINTERRUPTIBLE ) ; schedule ( ) ; } exit_signals ( tsk ) ; smp_mb ( ) ; spin_unlock_wait ( & tsk -> pi_lock ) ; if ( unlikely ( in_atomic ( ) ) ) printk ( KERN_INFO ""note:<S2SV_blank>%s[%d]<S2SV_blank>exited<S2SV_blank>with<S2SV_blank>preempt_count<S2SV_blank>%d\\n"" , current -> comm , task_pid_nr ( current ) , preempt_count ( ) ) ; acct_update_integrals ( tsk ) ; if ( tsk -> mm ) { update_hiwater_rss ( tsk -> mm ) ; update_hiwater_vm ( tsk -> mm ) ; } group_dead = atomic_dec_and_test ( & tsk -> signal -> live ) ; if ( group_dead ) { hrtimer_cancel ( & tsk -> signal -> real_timer ) ; exit_itimers ( tsk -> signal ) ; } acct_collect ( code , group_dead ) ; <S2SV_StartBug> # ifdef CONFIG_FUTEX <S2SV_EndBug> <S2SV_StartBug> if ( unlikely ( tsk -> robust_list ) ) <S2SV_EndBug> exit_robust_list ( tsk ) ; # ifdef CONFIG_COMPAT if ( unlikely ( tsk -> compat_robust_list ) ) compat_exit_robust_list ( tsk ) ; # endif # endif if ( group_dead ) tty_audit_exit ( ) ; if ( unlikely ( tsk -> audit_context ) ) audit_free ( tsk ) ; tsk -> exit_code = code ; taskstats_exit ( tsk , group_dead ) ; exit_mm ( tsk ) ; if ( group_dead ) acct_process ( ) ; trace_sched_process_exit ( tsk ) ; exit_sem ( tsk ) ; exit_files ( tsk ) ; exit_fs ( tsk ) ; check_stack_usage ( ) ; exit_thread ( ) ; cgroup_exit ( tsk , 1 ) ; exit_keys ( tsk ) ; if ( group_dead && tsk -> signal -> leader ) disassociate_ctty ( 1 ) ; module_put ( task_thread_info ( tsk ) -> exec_domain -> module ) ; if ( tsk -> binfmt ) module_put ( tsk -> binfmt -> module ) ; proc_exit_connector ( tsk ) ; exit_notify ( tsk , group_dead ) ; # ifdef CONFIG_NUMA mpol_put ( tsk -> mempolicy ) ; tsk -> mempolicy = NULL ; # endif # ifdef CONFIG_FUTEX if ( unlikely ( ! list_empty ( & tsk -> pi_state_list ) ) ) exit_pi_state_list ( tsk ) ; if ( unlikely ( current -> pi_state_cache ) ) kfree ( current -> pi_state_cache ) ; # endif debug_check_no_locks_held ( tsk ) ; tsk -> flags |= PF_EXITPIDONE ; if ( tsk -> io_context ) exit_io_context ( ) ; if ( tsk -> splice_pipe ) __free_pipe_info ( tsk -> splice_pipe ) ; preempt_disable ( ) ; tsk -> state = TASK_DEAD ; schedule ( ) ; BUG ( ) ; for ( ; ; ) cpu_relax ( ) ; }
","<S2SV_ModStart> group_dead ) ; if ( group_dead ) tty_audit_exit ( ) ; if ( unlikely ( tsk -> audit_context ) ) audit_free ( tsk ) ; tsk -> exit_code = code ; taskstats_exit ( tsk , group_dead ) ; exit_mm ( tsk ) ; if ( group_dead ) acct_process ( ) ; trace_sched_process_exit ( tsk ) ; exit_sem ( tsk ) ; exit_files ( tsk ) ; exit_fs ( tsk ) ; check_stack_usage ( ) ; exit_thread ( ) ; cgroup_exit ( tsk , 1 ) ; exit_keys ( tsk ) ; if ( group_dead && tsk -> signal -> leader ) disassociate_ctty ( 1 ) ; module_put ( task_thread_info ( tsk ) -> exec_domain -> module ) ; if ( tsk -> binfmt ) module_put ( tsk -> binfmt -> module ) ; proc_exit_connector ( tsk ) ; exit_notify ( tsk , group_dead ) ; # ifdef CONFIG_NUMA mpol_put ( tsk -> mempolicy ) ; tsk -> mempolicy = NULL ; # endif <S2SV_ModStart> ( unlikely ( <S2SV_ModEnd> ! list_empty (
"
1007,"CWE-476 static int ghash_update ( struct shash_desc * desc , const u8 * src , unsigned int srclen ) { struct ghash_desc_ctx * dctx = shash_desc_ctx ( desc ) ; struct ghash_ctx * ctx = crypto_shash_ctx ( desc -> tfm ) ; u8 * dst = dctx -> buffer ; <S2SV_StartBug> if ( dctx -> bytes ) { <S2SV_EndBug> int n = min ( srclen , dctx -> bytes ) ; u8 * pos = dst + ( GHASH_BLOCK_SIZE - dctx -> bytes ) ; dctx -> bytes -= n ; srclen -= n ; while ( n -- ) * pos ++ ^= * src ++ ; if ( ! dctx -> bytes ) gf128mul_4k_lle ( ( be128 * ) dst , ctx -> gf128 ) ; } while ( srclen >= GHASH_BLOCK_SIZE ) { crypto_xor ( dst , src , GHASH_BLOCK_SIZE ) ; gf128mul_4k_lle ( ( be128 * ) dst , ctx -> gf128 ) ; src += GHASH_BLOCK_SIZE ; srclen -= GHASH_BLOCK_SIZE ; } if ( srclen ) { dctx -> bytes = GHASH_BLOCK_SIZE - srclen ; while ( srclen -- ) * dst ++ ^= * src ++ ; } return 0 ; }
","<S2SV_ModStart> ; if ( ! ctx -> gf128 ) return - ENOKEY ; if (
"
1008,"CWE-772 generic_ret * chpass_principal3_2_svc ( chpass3_arg * arg , struct svc_req * rqstp ) { static generic_ret ret ; char * prime_arg ; <S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_generic_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> princ , & prime_arg ) ) { ret . code = KADM5_BAD_PRINCIPAL ; goto exit_func ; } if ( cmp_gss_krb5_name ( handle , rqst2name ( rqstp ) , arg -> princ ) ) { ret . code = chpass_principal_wrapper_3 ( ( void * ) handle , arg -> princ , arg -> keepold , arg -> n_ks_tuple , arg -> ks_tuple , arg -> pass ) ; } else if ( ! ( CHANGEPW_SERVICE ( rqstp ) ) && kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_CHANGEPW , arg -> princ , NULL ) ) { ret . code = kadm5_chpass_principal_3 ( ( void * ) handle , arg -> princ , arg -> keepold , arg -> n_ks_tuple , arg -> ks_tuple , arg -> pass ) ; } else { log_unauth ( ""kadm5_chpass_principal"" , prime_arg , & client_name , & service_name , rqstp ) ; ret . code = KADM5_AUTH_CHANGEPW ; } if ( ret . code != KADM5_AUTH_CHANGEPW ) { if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( ""kadm5_chpass_principal"" , prime_arg , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } free ( prime_arg ) ; <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> gss_release_buffer ( & minor_stat , & service_name ) ; exit_func : free_server_handle ( handle ) ; return & ret ; }
","<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> prime_arg ) ; exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
"
1009,"CWE-119 static grub_err_t read_foo ( struct grub_disk * disk , grub_disk_addr_t sector , grub_size_t size , char * buf ) { <S2SV_StartBug> if ( disk != NULL ) { <S2SV_EndBug> <S2SV_StartBug> const int blocksize = 512 ; <S2SV_EndBug> int ret ; RIOBind * iob = disk -> data ; <S2SV_StartBug> if ( bio ) iob = bio ; <S2SV_EndBug> <S2SV_StartBug> ret = iob -> read_at ( iob -> io , delta + ( blocksize * sector ) , <S2SV_EndBug> <S2SV_StartBug> ( ut8 * ) buf , size * blocksize ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ret == - 1 ) <S2SV_EndBug> return 1 ; <S2SV_StartBug> } else eprintf ( ""oops.<S2SV_blank>no<S2SV_blank>disk\\n"" ) ; <S2SV_EndBug> return 0 ; }
","<S2SV_ModStart> { if ( ! disk ) { eprintf ( ""oops.<S2SV_blank>no<S2SV_blank>disk\\n"" ) ; return 1 ; } <S2SV_ModEnd> const int blocksize <S2SV_ModStart> blocksize = 512 <S2SV_ModEnd> ; RIOBind * <S2SV_ModStart> ( bio ) { <S2SV_ModStart> = bio ; } if ( <S2SV_ModEnd> iob -> read_at <S2SV_ModStart> * blocksize ) <S2SV_ModEnd> == - 1 <S2SV_ModStart> - 1 ) { <S2SV_ModStart> 1 ; } <S2SV_ModEnd> return 0 ;
"
1010,"CWE-125 PyObject * ast2obj_comprehension ( void * _o ) { comprehension_ty o = ( comprehension_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { <S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug> return Py_None ; } result = PyType_GenericNew ( comprehension_type , NULL , NULL ) ; if ( ! result ) return NULL ; value = ast2obj_expr ( o -> target ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_target , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> iter ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_iter , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> ifs , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_ifs , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> is_async ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_is_async , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }
","<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } result
"
1011,"CWE-502 static int php_var_unserialize_internal ( UNSERIALIZE_PARAMETER ) { const unsigned char * cursor , * limit , * marker , * start ; zval * rval_ref ; limit = max ; cursor = * p ; if ( YYCURSOR >= YYLIMIT ) { return 0 ; } if ( var_hash && ( * p ) [ 0 ] != 'R' ) { var_push ( var_hash , rval ) ; } start = cursor ; # line 554 ""ext/standard/var_unserializer.c"" { YYCTYPE yych ; static const unsigned char yybm [ ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 128 , 128 , 128 , 128 , 128 , 128 , 128 , 128 , 128 , 128 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , } ; if ( ( YYLIMIT - YYCURSOR ) < 7 ) YYFILL ( 7 ) ; yych = * YYCURSOR ; switch ( yych ) { case 'C' : case 'O' : goto yy13 ; case 'N' : goto yy5 ; case 'R' : goto yy2 ; case 'S' : goto yy10 ; case 'a' : goto yy11 ; case 'b' : goto yy6 ; case 'd' : goto yy8 ; case 'i' : goto yy7 ; case 'o' : goto yy12 ; case 'r' : goto yy4 ; case 's' : goto yy9 ; case '}' : goto yy14 ; default : goto yy16 ; } yy2 : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy95 ; yy3 : # line 884 ""ext/standard/var_unserializer.re"" { return 0 ; } # line 580 ""ext/standard/var_unserializer.c"" yy4 : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy89 ; goto yy3 ; yy5 : yych = * ++ YYCURSOR ; if ( yych == ';' ) goto yy87 ; goto yy3 ; yy6 : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy83 ; goto yy3 ; yy7 : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy77 ; goto yy3 ; yy8 : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy53 ; goto yy3 ; yy9 : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy46 ; goto yy3 ; yy10 : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy39 ; goto yy3 ; yy11 : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy32 ; goto yy3 ; yy12 : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy25 ; goto yy3 ; yy13 : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy17 ; goto yy3 ; yy14 : ++ YYCURSOR ; # line 878 ""ext/standard/var_unserializer.re"" { php_error_docref ( NULL , E_NOTICE , ""Unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>serialized<S2SV_blank>data"" ) ; return 0 ; } # line 629 ""ext/standard/var_unserializer.c"" yy16 : yych = * ++ YYCURSOR ; goto yy3 ; yy17 : yych = * ++ YYCURSOR ; if ( yybm [ 0 + yych ] & 128 ) { goto yy20 ; } if ( yych == '+' ) goto yy19 ; yy18 : YYCURSOR = YYMARKER ; goto yy3 ; yy19 : yych = * ++ YYCURSOR ; if ( yybm [ 0 + yych ] & 128 ) { goto yy20 ; } goto yy18 ; yy20 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ; yych = * YYCURSOR ; if ( yybm [ 0 + yych ] & 128 ) { goto yy20 ; } <S2SV_StartBug> if ( yych != ':' ) goto yy18 ; <S2SV_EndBug> yych = * ++ YYCURSOR ; if ( yych != \'""\' ) goto yy18 ; ++ YYCURSOR ; # line 733 ""ext/standard/var_unserializer.re"" { size_t len , len2 , len3 , maxlen ; zend_long elements ; char * str ; zend_string * class_name ; zend_class_entry * ce ; int incomplete_class = 0 ; int custom_object = 0 ; zval user_func ; zval retval ; zval args [ 1 ] ; if ( ! var_hash ) return 0 ; if ( * start == 'C' ) { custom_object = 1 ; } len2 = len = parse_uiv ( start + 2 ) ; maxlen = max - YYCURSOR ; if ( maxlen < len || len == 0 ) { * p = start + 2 ; return 0 ; } str = ( char * ) YYCURSOR ; YYCURSOR += len ; if ( * ( YYCURSOR ) != \'""\' ) { * p = YYCURSOR ; return 0 ; } if ( * ( YYCURSOR + 1 ) != ':' ) { * p = YYCURSOR + 1 ; return 0 ; } len3 = strspn ( str , ""0123456789_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\177\\200\\201\\202\\203\\204\\205\\206\\207\\210\\211\\212\\213\\214\\215\\216\\217\\220\\221\\222\\223\\224\\225\\226\\227\\230\\231\\232\\233\\234\\235\\236\\237\\240\\241\\242\\243\\244\\245\\246\\247\\250\\251\\252\\253\\254\\255\\256\\257\\260\\261\\262\\263\\264\\265\\266\\267\\270\\271\\272\\273\\274\\275\\276\\277\\300\\301\\302\\303\\304\\305\\306\\307\\310\\311\\312\\313\\314\\315\\316\\317\\320\\321\\322\\323\\324\\325\\326\\327\\330\\331\\332\\333\\334\\335\\336\\337\\340\\341\\342\\343\\344\\345\\346\\347\\350\\351\\352\\353\\354\\355\\356\\357\\360\\361\\362\\363\\364\\365\\366\\367\\370\\371\\372\\373\\374\\375\\376\\377\\\\"" ) ; if ( len3 != len ) { * p = YYCURSOR + len3 - len ; return 0 ; } class_name = zend_string_init ( str , len , 0 ) ; do { if ( ! unserialize_allowed_class ( class_name , classes ) ) { incomplete_class = 1 ; ce = PHP_IC_ENTRY ; break ; } BG ( serialize_lock ) ++ ; ce = zend_lookup_class ( class_name ) ; if ( ce ) { BG ( serialize_lock ) -- ; if ( EG ( exception ) ) { zend_string_release ( class_name ) ; return 0 ; } break ; } BG ( serialize_lock ) -- ; if ( EG ( exception ) ) { zend_string_release ( class_name ) ; return 0 ; } if ( ( PG ( unserialize_callback_func ) == NULL ) || ( PG ( unserialize_callback_func ) [ 0 ] == '\\0' ) ) { incomplete_class = 1 ; ce = PHP_IC_ENTRY ; break ; } ZVAL_STRING ( & user_func , PG ( unserialize_callback_func ) ) ; ZVAL_STR_COPY ( & args [ 0 ] , class_name ) ; BG ( serialize_lock ) ++ ; if ( call_user_function_ex ( CG ( function_table ) , NULL , & user_func , & retval , 1 , args , 0 , NULL ) != SUCCESS ) { BG ( serialize_lock ) -- ; if ( EG ( exception ) ) { zend_string_release ( class_name ) ; zval_ptr_dtor ( & user_func ) ; zval_ptr_dtor ( & args [ 0 ] ) ; return 0 ; } php_error_docref ( NULL , E_WARNING , ""defined<S2SV_blank>(%s)<S2SV_blank>but<S2SV_blank>not<S2SV_blank>found"" , Z_STRVAL ( user_func ) ) ; incomplete_class = 1 ; ce = PHP_IC_ENTRY ; zval_ptr_dtor ( & user_func ) ; zval_ptr_dtor ( & args [ 0 ] ) ; break ; } BG ( serialize_lock ) -- ; zval_ptr_dtor ( & retval ) ; if ( EG ( exception ) ) { zend_string_release ( class_name ) ; zval_ptr_dtor ( & user_func ) ; zval_ptr_dtor ( & args [ 0 ] ) ; return 0 ; } if ( ( ce = zend_lookup_class ( class_name ) ) == NULL ) { php_error_docref ( NULL , E_WARNING , ""Function<S2SV_blank>%s()<S2SV_blank>hasn\'t<S2SV_blank>defined<S2SV_blank>the<S2SV_blank>class<S2SV_blank>it<S2SV_blank>was<S2SV_blank>called<S2SV_blank>for"" , Z_STRVAL ( user_func ) ) ; incomplete_class = 1 ; ce = PHP_IC_ENTRY ; } zval_ptr_dtor ( & user_func ) ; zval_ptr_dtor ( & args [ 0 ] ) ; break ; } while ( 1 ) ; * p = YYCURSOR ; if ( custom_object ) { int ret ; ret = object_custom ( UNSERIALIZE_PASSTHRU , ce ) ; if ( ret && incomplete_class ) { php_store_class_name ( rval , ZSTR_VAL ( class_name ) , len2 ) ; } zend_string_release ( class_name ) ; return ret ; } elements = object_common1 ( UNSERIALIZE_PASSTHRU , ce ) ; if ( incomplete_class ) { php_store_class_name ( rval , ZSTR_VAL ( class_name ) , len2 ) ; } zend_string_release ( class_name ) ; return object_common2 ( UNSERIALIZE_PASSTHRU , elements ) ; } <S2SV_StartBug> # line 804 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> yy25 : yych = * ++ YYCURSOR ; if ( yych <= ',' ) { if ( yych != '+' ) goto yy18 ; } else { if ( yych <= '-' ) goto yy26 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy27 ; goto yy18 ; } yy26 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy27 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy27 ; if ( yych >= ';' ) goto yy18 ; yych = * ++ YYCURSOR ; if ( yych != \'""\' ) goto yy18 ; ++ YYCURSOR ; # line 726 ""ext/standard/var_unserializer.re"" { if ( ! var_hash ) return 0 ; return object_common2 ( UNSERIALIZE_PASSTHRU , object_common1 ( UNSERIALIZE_PASSTHRU , ZEND_STANDARD_CLASS_DEF_PTR ) ) ; } <S2SV_StartBug> # line 836 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> yy32 : yych = * ++ YYCURSOR ; if ( yych == '+' ) goto yy33 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy34 ; goto yy18 ; yy33 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy34 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy34 ; if ( yych >= ';' ) goto yy18 ; yych = * ++ YYCURSOR ; if ( yych != '{' ) goto yy18 ; ++ YYCURSOR ; # line 702 ""ext/standard/var_unserializer.re"" { zend_long elements = parse_iv ( start + 2 ) ; * p = YYCURSOR ; if ( ! var_hash ) return 0 ; if ( elements < 0 ) { return 0 ; } array_init_size ( rval , elements ) ; if ( elements ) { zend_hash_real_init ( Z_ARRVAL_P ( rval ) , 0 ) ; } if ( ! process_nested_data ( UNSERIALIZE_PASSTHRU , Z_ARRVAL_P ( rval ) , elements , 0 ) ) { return 0 ; } return finish_nested_data ( UNSERIALIZE_PASSTHRU ) ; } <S2SV_StartBug> # line 881 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> yy39 : yych = * ++ YYCURSOR ; if ( yych == '+' ) goto yy40 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy41 ; goto yy18 ; yy40 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy41 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy41 ; if ( yych >= ';' ) goto yy18 ; yych = * ++ YYCURSOR ; if ( yych != \'""\' ) goto yy18 ; ++ YYCURSOR ; # line 668 ""ext/standard/var_unserializer.re"" { size_t len , maxlen ; zend_string * str ; len = parse_uiv ( start + 2 ) ; maxlen = max - YYCURSOR ; if ( maxlen < len ) { * p = start + 2 ; return 0 ; } if ( ( str = unserialize_str ( & YYCURSOR , len , maxlen ) ) == NULL ) { return 0 ; } if ( * ( YYCURSOR ) != \'""\' ) { zend_string_free ( str ) ; * p = YYCURSOR ; return 0 ; } if ( * ( YYCURSOR + 1 ) != ';' ) { efree ( str ) ; * p = YYCURSOR + 1 ; return 0 ; } YYCURSOR += 2 ; * p = YYCURSOR ; ZVAL_STR ( rval , str ) ; return 1 ; } <S2SV_StartBug> # line 936 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> yy46 : yych = * ++ YYCURSOR ; if ( yych == '+' ) goto yy47 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy48 ; goto yy18 ; yy47 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy48 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy48 ; if ( yych >= ';' ) goto yy18 ; yych = * ++ YYCURSOR ; if ( yych != \'""\' ) goto yy18 ; ++ YYCURSOR ; # line 636 ""ext/standard/var_unserializer.re"" { size_t len , maxlen ; char * str ; len = parse_uiv ( start + 2 ) ; maxlen = max - YYCURSOR ; if ( maxlen < len ) { * p = start + 2 ; return 0 ; } str = ( char * ) YYCURSOR ; YYCURSOR += len ; if ( * ( YYCURSOR ) != \'""\' ) { * p = YYCURSOR ; return 0 ; } if ( * ( YYCURSOR + 1 ) != ';' ) { * p = YYCURSOR + 1 ; return 0 ; } YYCURSOR += 2 ; * p = YYCURSOR ; ZVAL_STRINGL ( rval , str , len ) ; return 1 ; } <S2SV_StartBug> # line 989 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> yy53 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) { if ( yych <= ',' ) { if ( yych == '+' ) goto yy57 ; goto yy18 ; } else { if ( yych <= '-' ) goto yy55 ; if ( yych <= '.' ) goto yy60 ; goto yy18 ; } } else { if ( yych <= 'I' ) { if ( yych <= '9' ) goto yy58 ; if ( yych <= 'H' ) goto yy18 ; goto yy56 ; } else { if ( yych != 'N' ) goto yy18 ; } } yych = * ++ YYCURSOR ; if ( yych == 'A' ) goto yy76 ; goto yy18 ; yy55 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) { if ( yych == '.' ) goto yy60 ; goto yy18 ; } else { if ( yych <= '9' ) goto yy58 ; if ( yych != 'I' ) goto yy18 ; } yy56 : yych = * ++ YYCURSOR ; if ( yych == 'N' ) goto yy72 ; goto yy18 ; yy57 : yych = * ++ YYCURSOR ; if ( yych == '.' ) goto yy60 ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy58 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 4 ) YYFILL ( 4 ) ; yych = * YYCURSOR ; if ( yych <= ':' ) { if ( yych <= '.' ) { if ( yych <= '-' ) goto yy18 ; goto yy70 ; } else { if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy58 ; goto yy18 ; } } else { if ( yych <= 'E' ) { if ( yych <= ';' ) goto yy63 ; if ( yych <= 'D' ) goto yy18 ; goto yy65 ; } else { if ( yych == 'e' ) goto yy65 ; goto yy18 ; } } yy60 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy61 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 4 ) YYFILL ( 4 ) ; yych = * YYCURSOR ; if ( yych <= ';' ) { if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy61 ; if ( yych <= ':' ) goto yy18 ; } else { if ( yych <= 'E' ) { if ( yych <= 'D' ) goto yy18 ; goto yy65 ; } else { if ( yych == 'e' ) goto yy65 ; goto yy18 ; } } yy63 : ++ YYCURSOR ; # line 627 ""ext/standard/var_unserializer.re"" { # if SIZEOF_ZEND_LONG == 4 use_double : # endif * p = YYCURSOR ; ZVAL_DOUBLE ( rval , zend_strtod ( ( const char * ) start + 2 , NULL ) ) ; return 1 ; } <S2SV_StartBug> # line 1086 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> yy65 : yych = * ++ YYCURSOR ; if ( yych <= ',' ) { if ( yych != '+' ) goto yy18 ; } else { if ( yych <= '-' ) goto yy66 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy67 ; goto yy18 ; } yy66 : yych = * ++ YYCURSOR ; if ( yych <= ',' ) { if ( yych == '+' ) goto yy69 ; goto yy18 ; } else { if ( yych <= '-' ) goto yy69 ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; } yy67 : ++ YYCURSOR ; if ( YYLIMIT <= YYCURSOR ) YYFILL ( 1 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy67 ; if ( yych == ';' ) goto yy63 ; goto yy18 ; yy69 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy67 ; goto yy18 ; yy70 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 4 ) YYFILL ( 4 ) ; yych = * YYCURSOR ; if ( yych <= ';' ) { if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy70 ; if ( yych <= ':' ) goto yy18 ; goto yy63 ; } else { if ( yych <= 'E' ) { if ( yych <= 'D' ) goto yy18 ; goto yy65 ; } else { if ( yych == 'e' ) goto yy65 ; goto yy18 ; } } yy72 : yych = * ++ YYCURSOR ; if ( yych != 'F' ) goto yy18 ; yy73 : yych = * ++ YYCURSOR ; if ( yych != ';' ) goto yy18 ; ++ YYCURSOR ; # line 611 ""ext/standard/var_unserializer.re"" { * p = YYCURSOR ; if ( ! strncmp ( ( char * ) start + 2 , ""NAN"" , 3 ) ) { ZVAL_DOUBLE ( rval , php_get_nan ( ) ) ; } else if ( ! strncmp ( ( char * ) start + 2 , ""INF"" , 3 ) ) { ZVAL_DOUBLE ( rval , php_get_inf ( ) ) ; } else if ( ! strncmp ( ( char * ) start + 2 , ""-INF"" , 4 ) ) { ZVAL_DOUBLE ( rval , - php_get_inf ( ) ) ; } else { ZVAL_NULL ( rval ) ; } return 1 ; } <S2SV_StartBug> # line 1161 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> yy76 : yych = * ++ YYCURSOR ; if ( yych == 'N' ) goto yy73 ; goto yy18 ; yy77 : yych = * ++ YYCURSOR ; if ( yych <= ',' ) { if ( yych != '+' ) goto yy18 ; } else { if ( yych <= '-' ) goto yy78 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy79 ; goto yy18 ; } yy78 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy79 : ++ YYCURSOR ; if ( YYLIMIT <= YYCURSOR ) YYFILL ( 1 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy79 ; if ( yych != ';' ) goto yy18 ; ++ YYCURSOR ; # line 585 ""ext/standard/var_unserializer.re"" { # if SIZEOF_ZEND_LONG == 4 int digits = YYCURSOR - start - 3 ; if ( start [ 2 ] == '-' || start [ 2 ] == '+' ) { digits -- ; } if ( digits >= MAX_LENGTH_OF_LONG - 1 ) { if ( digits == MAX_LENGTH_OF_LONG - 1 ) { int cmp = strncmp ( ( char * ) YYCURSOR - MAX_LENGTH_OF_LONG , long_min_digits , MAX_LENGTH_OF_LONG - 1 ) ; if ( ! ( cmp < 0 || ( cmp == 0 && start [ 2 ] == '-' ) ) ) { goto use_double ; } } else { goto use_double ; } } # endif * p = YYCURSOR ; ZVAL_LONG ( rval , parse_iv ( start + 2 ) ) ; return 1 ; } <S2SV_StartBug> # line 1214 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> yy83 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= '2' ) goto yy18 ; yych = * ++ YYCURSOR ; if ( yych != ';' ) goto yy18 ; ++ YYCURSOR ; # line 579 ""ext/standard/var_unserializer.re"" { * p = YYCURSOR ; ZVAL_BOOL ( rval , parse_iv ( start + 2 ) ) ; return 1 ; } <S2SV_StartBug> # line 1228 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> yy87 : ++ YYCURSOR ; # line 573 ""ext/standard/var_unserializer.re"" { * p = YYCURSOR ; ZVAL_NULL ( rval ) ; return 1 ; } <S2SV_StartBug> # line 1237 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> yy89 : yych = * ++ YYCURSOR ; if ( yych <= ',' ) { if ( yych != '+' ) goto yy18 ; } else { if ( yych <= '-' ) goto yy90 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy91 ; goto yy18 ; } yy90 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy91 : ++ YYCURSOR ; if ( YYLIMIT <= YYCURSOR ) YYFILL ( 1 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy91 ; if ( yych != ';' ) goto yy18 ; ++ YYCURSOR ; # line 548 ""ext/standard/var_unserializer.re"" { zend_long id ; * p = YYCURSOR ; if ( ! var_hash ) return 0 ; id = parse_iv ( start + 2 ) - 1 ; if ( id == - 1 || ( rval_ref = var_access ( var_hash , id ) ) == NULL ) { return 0 ; } if ( rval_ref == rval ) { return 0 ; } if ( Z_ISUNDEF_P ( rval_ref ) || ( Z_ISREF_P ( rval_ref ) && Z_ISUNDEF_P ( Z_REFVAL_P ( rval_ref ) ) ) ) { ZVAL_UNDEF ( rval ) ; return 1 ; } ZVAL_COPY ( rval , rval_ref ) ; return 1 ; } <S2SV_StartBug> # line 1285 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> yy95 : yych = * ++ YYCURSOR ; if ( yych <= ',' ) { if ( yych != '+' ) goto yy18 ; } else { if ( yych <= '-' ) goto yy96 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy97 ; goto yy18 ; } yy96 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy97 : ++ YYCURSOR ; if ( YYLIMIT <= YYCURSOR ) YYFILL ( 1 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy97 ; if ( yych != ';' ) goto yy18 ; ++ YYCURSOR ; # line 522 ""ext/standard/var_unserializer.re"" { zend_long id ; * p = YYCURSOR ; if ( ! var_hash ) return 0 ; id = parse_iv ( start + 2 ) - 1 ; if ( id == - 1 || ( rval_ref = var_access ( var_hash , id ) ) == NULL ) { return 0 ; } zval_ptr_dtor ( rval ) ; if ( Z_ISUNDEF_P ( rval_ref ) || ( Z_ISREF_P ( rval_ref ) && Z_ISUNDEF_P ( Z_REFVAL_P ( rval_ref ) ) ) ) { ZVAL_UNDEF ( rval ) ; return 1 ; } if ( Z_ISREF_P ( rval_ref ) ) { ZVAL_COPY ( rval , rval_ref ) ; } else { ZVAL_NEW_REF ( rval_ref , rval_ref ) ; ZVAL_COPY ( rval , rval_ref ) ; } return 1 ; } <S2SV_StartBug> # line 1334 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> } # line 886 ""ext/standard/var_unserializer.re"" return 0 ; }
","<S2SV_ModStart> if ( yych <= '/' ) goto yy18 ; if ( yych >= ';' <S2SV_ModEnd> ) goto yy18 <S2SV_ModStart> } # line 805 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" yy25 : <S2SV_ModStart> } # line 837 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" yy32 : <S2SV_ModStart> } # line 882 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" yy39 : <S2SV_ModStart> } # line 937 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" yy46 : <S2SV_ModStart> } # line 990 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" yy53 : <S2SV_ModStart> } # line 1087 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" yy65 : <S2SV_ModStart> } # line 1162 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" yy76 : <S2SV_ModStart> } # line 1215 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" yy83 : <S2SV_ModStart> } # line 1229 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" yy87 : <S2SV_ModStart> } # line 1238 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" yy89 : <S2SV_ModStart> } # line 1286 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" yy95 : <S2SV_ModStart> } # line 1335 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" } #
"
1012,"CWE-399 static Image * ReadLABELImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char geometry [ MaxTextExtent ] , * property ; const char * label ; DrawInfo * draw_info ; Image * image ; MagickBooleanType status ; TypeMetric metrics ; size_t height , width ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; ( void ) ResetImagePage ( image , ""0x0+0+0"" ) ; property = InterpretImageProperties ( image_info , image , image_info -> filename ) ; ( void ) SetImageProperty ( image , ""label"" , property ) ; property = DestroyString ( property ) ; label = GetImageProperty ( image , ""label"" ) ; draw_info = CloneDrawInfo ( image_info , ( DrawInfo * ) NULL ) ; draw_info -> text = ConstantString ( label ) ; metrics . width = 0 ; metrics . ascent = 0.0 ; status = GetMultilineTypeMetrics ( image , draw_info , & metrics ) ; if ( ( image -> columns == 0 ) && ( image -> rows == 0 ) ) { image -> columns = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ; image -> rows = ( size_t ) floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ; } else if ( ( strlen ( label ) > 0 ) && ( ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) || ( fabs ( image_info -> pointsize ) < MagickEpsilon ) ) ) { double high , low ; for ( ; ; draw_info -> pointsize *= 2.0 ) { ( void ) FormatLocaleString ( geometry , MaxTextExtent , ""%+g%+g"" , - metrics . bounds . x1 , metrics . ascent ) ; if ( draw_info -> gravity == UndefinedGravity ) ( void ) CloneString ( & draw_info -> geometry , geometry ) ; ( void ) GetMultilineTypeMetrics ( image , draw_info , & metrics ) ; width = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ; height = ( size_t ) floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ; if ( ( image -> columns != 0 ) && ( image -> rows != 0 ) ) { if ( ( width >= image -> columns ) && ( height >= image -> rows ) ) break ; } else if ( ( ( image -> columns != 0 ) && ( width >= image -> columns ) ) || ( ( image -> rows != 0 ) && ( height >= image -> rows ) ) ) break ; } high = draw_info -> pointsize ; for ( low = 1.0 ; ( high - low ) > 0.5 ; ) { draw_info -> pointsize = ( low + high ) / 2.0 ; ( void ) FormatLocaleString ( geometry , MaxTextExtent , ""%+g%+g"" , - metrics . bounds . x1 , metrics . ascent ) ; if ( draw_info -> gravity == UndefinedGravity ) ( void ) CloneString ( & draw_info -> geometry , geometry ) ; ( void ) GetMultilineTypeMetrics ( image , draw_info , & metrics ) ; width = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ; height = ( size_t ) floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ; if ( ( image -> columns != 0 ) && ( image -> rows != 0 ) ) { if ( ( width < image -> columns ) && ( height < image -> rows ) ) low = draw_info -> pointsize + 0.5 ; else high = draw_info -> pointsize - 0.5 ; } else if ( ( ( image -> columns != 0 ) && ( width < image -> columns ) ) || ( ( image -> rows != 0 ) && ( height < image -> rows ) ) ) low = draw_info -> pointsize + 0.5 ; else high = draw_info -> pointsize - 0.5 ; } draw_info -> pointsize = ( low + high ) / 2.0 - 0.5 ; } status = GetMultilineTypeMetrics ( image , draw_info , & metrics ) ; if ( status == MagickFalse ) { draw_info = DestroyDrawInfo ( draw_info ) ; InheritException ( exception , & image -> exception ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( image -> columns == 0 ) image -> columns = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ; if ( image -> columns == 0 ) image -> columns = ( size_t ) floor ( draw_info -> pointsize + draw_info -> stroke_width + 0.5 ) ; if ( image -> rows == 0 ) image -> rows = ( size_t ) floor ( metrics . ascent - metrics . descent + draw_info -> stroke_width + 0.5 ) ; if ( image -> rows == 0 ) image -> rows = ( size_t ) floor ( draw_info -> pointsize + draw_info -> stroke_width + 0.5 ) ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { draw_info = DestroyDrawInfo ( draw_info ) ; InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } if ( SetImageBackgroundColor ( image ) == MagickFalse ) { draw_info = DestroyDrawInfo ( draw_info ) ; InheritException ( exception , & image -> exception ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) FormatLocaleString ( geometry , MaxTextExtent , ""%+g%+g"" , draw_info -> direction == RightToLeftDirection ? image -> columns - metrics . bounds . x2 : 0.0 , draw_info -> gravity == UndefinedGravity ? metrics . ascent : 0.0 ) ; <S2SV_StartBug> draw_info -> geometry = AcquireString ( geometry ) ; <S2SV_EndBug> status = AnnotateImage ( image , draw_info ) ; if ( image_info -> pointsize == 0.0 ) { char pointsize [ MaxTextExtent ] ; ( void ) FormatLocaleString ( pointsize , MaxTextExtent , ""%.20g"" , draw_info -> pointsize ) ; ( void ) SetImageProperty ( image , ""label:pointsize"" , pointsize ) ; } draw_info = DestroyDrawInfo ( draw_info ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> 0.0 ) ; ( void ) CloneString ( & <S2SV_ModStart> draw_info -> geometry , <S2SV_ModEnd> geometry ) ;
"
1013,"CWE-191 int rad_packet_recv ( int fd , struct rad_packet_t * * p , struct sockaddr_in * addr ) { struct rad_packet_t * pack ; struct rad_attr_t * attr ; struct rad_dict_attr_t * da ; struct rad_dict_vendor_t * vendor ; uint8_t * ptr ; int n , id , len , vendor_id ; socklen_t addr_len = sizeof ( * addr ) ; * p = NULL ; pack = rad_packet_alloc ( 0 ) ; if ( ! pack ) return 0 ; ptr = mempool_alloc ( buf_pool ) ; if ( ptr == MAP_FAILED ) { log_emerg ( ""radius:packet:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory\\n"" ) ; goto out_err ; } pack -> buf = ptr ; clock_gettime ( CLOCK_MONOTONIC , & pack -> tv ) ; while ( 1 ) { if ( addr ) n = recvfrom ( fd , pack -> buf , REQ_LENGTH_MAX , 0 , addr , & addr_len ) ; else n = read ( fd , pack -> buf , REQ_LENGTH_MAX ) ; if ( n < 0 ) { rad_packet_free ( pack ) ; if ( errno == EAGAIN ) return 1 ; if ( errno != ECONNREFUSED ) log_ppp_error ( ""radius:packet:read:<S2SV_blank>%s\\n"" , strerror ( errno ) ) ; return - 1 ; } break ; } if ( n < 20 ) { log_ppp_warn ( ""radius:packet:<S2SV_blank>short<S2SV_blank>packed<S2SV_blank>received<S2SV_blank>(%i)\\n"" , n ) ; goto out_err ; } pack -> code = * ptr ; ptr ++ ; pack -> id = * ptr ; ptr ++ ; pack -> len = ntohs ( * ( uint16_t * ) ptr ) ; ptr += 2 ; if ( pack -> len > n ) { log_ppp_warn ( ""radius:packet:<S2SV_blank>short<S2SV_blank>packet<S2SV_blank>received<S2SV_blank>%i,<S2SV_blank>expected<S2SV_blank>%i\\n"" , pack -> len , n ) ; goto out_err ; } ptr += 16 ; n -= 20 ; while ( n > 0 ) { id = * ptr ; ptr ++ ; len = * ptr - 2 ; ptr ++ ; if ( len < 0 ) { log_ppp_warn ( ""radius:packet<S2SV_blank>short<S2SV_blank>attribute<S2SV_blank>len<S2SV_blank>received\\n"" ) ; goto out_err ; } if ( 2 + len > n ) { log_ppp_warn ( ""radius:packet:<S2SV_blank>too<S2SV_blank>long<S2SV_blank>attribute<S2SV_blank>received<S2SV_blank>(%i,<S2SV_blank>%i)\\n"" , id , len ) ; goto out_err ; } if ( id == 26 ) { vendor_id = ntohl ( * ( uint32_t * ) ptr ) ; vendor = rad_dict_find_vendor_id ( vendor_id ) ; if ( vendor ) { ptr += 4 ; if ( vendor -> tag == 2 ) id = ( uint16_t ) ntohs ( * ( uint16_t * ) ptr ) ; else id = * ptr ; ptr += vendor -> tag ; if ( vendor -> len == 2 ) len = ( uint16_t ) ntohs ( * ( uint16_t * ) ptr ) ; else len = * ptr ; ptr += vendor -> len ; len -= vendor -> tag + vendor -> len ; n -= 4 + vendor -> tag + vendor -> len ; <S2SV_StartBug> } else <S2SV_EndBug> log_ppp_warn ( ""radius:packet:<S2SV_blank>vendor<S2SV_blank>%i<S2SV_blank>not<S2SV_blank>found\\n"" , id ) ; } else vendor = NULL ; da = rad_dict_find_attr_id ( vendor , id ) ; if ( da ) { attr = mempool_alloc ( attr_pool ) ; if ( ! attr ) { log_emerg ( ""radius:packet:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory\\n"" ) ; goto out_err ; } memset ( attr , 0 , sizeof ( * attr ) ) ; attr -> vendor = vendor ; attr -> attr = da ; attr -> len = len ; attr -> raw = ptr ; if ( ! da -> array ) { switch ( da -> type ) { case ATTR_TYPE_STRING : attr -> alloc = 1 ; attr -> val . string = _malloc ( len + 1 ) ; memcpy ( attr -> val . string , ptr , len ) ; attr -> val . string [ len ] = 0 ; break ; case ATTR_TYPE_OCTETS : case ATTR_TYPE_ETHER : case ATTR_TYPE_TLV : attr -> val . octets = ptr ; break ; case ATTR_TYPE_INTEGER : if ( len != da -> size ) log_ppp_warn ( ""radius:packet:<S2SV_blank>attribute<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>invalid<S2SV_blank>length<S2SV_blank>%i<S2SV_blank>(must<S2SV_blank>be<S2SV_blank>%i)\\n"" , da -> name , len , da -> size ) ; case ATTR_TYPE_DATE : if ( len == 4 ) attr -> val . integer = ntohl ( * ( uint32_t * ) ptr ) ; else if ( len == 2 ) attr -> val . integer = ntohs ( * ( uint16_t * ) ptr ) ; else if ( len == 1 ) attr -> val . integer = * ptr ; break ; case ATTR_TYPE_IPADDR : case ATTR_TYPE_IFID : case ATTR_TYPE_IPV6ADDR : memcpy ( & attr -> val . integer , ptr , len ) ; break ; case ATTR_TYPE_IPV6PREFIX : attr -> val . ipv6prefix . len = ptr [ 1 ] ; memset ( & attr -> val . ipv6prefix . prefix , 0 , sizeof ( attr -> val . ipv6prefix . prefix ) ) ; memcpy ( & attr -> val . ipv6prefix . prefix , ptr + 2 , len - 2 ) ; break ; } } list_add_tail ( & attr -> entry , & pack -> attrs ) ; } else log_ppp_warn ( ""radius:packet:<S2SV_blank>unknown<S2SV_blank>attribute<S2SV_blank>received<S2SV_blank>(%i,%i)\\n"" , vendor ? vendor -> id : 0 , id ) ; ptr += len ; n -= 2 + len ; } * p = pack ; return 0 ; out_err : rad_packet_free ( pack ) ; return 1 ; }
","<S2SV_ModStart> -> len ; if ( len < 0 ) { log_ppp_warn ( ""radius:packet<S2SV_blank>invalid<S2SV_blank>vendor<S2SV_blank>attribute<S2SV_blank>len<S2SV_blank>received\\n"" ) ; goto out_err ; } if ( 2 + len > n ) { log_ppp_warn ( ""radius:packet:<S2SV_blank>too<S2SV_blank>long<S2SV_blank>vendor<S2SV_blank>attribute<S2SV_blank>received<S2SV_blank>(%i,<S2SV_blank>%i)\\n"" , id , len ) ; goto out_err ; }
"
1014,"CWE-119 <S2SV_StartBug> void vp9_iht8x8_64_add_c ( const int16_t * input , uint8_t * dest , int stride , <S2SV_EndBug> int tx_type ) { int i , j ; <S2SV_StartBug> int16_t out [ 8 * 8 ] ; <S2SV_EndBug> <S2SV_StartBug> int16_t * outptr = out ; <S2SV_EndBug> <S2SV_StartBug> int16_t temp_in [ 8 ] , temp_out [ 8 ] ; <S2SV_EndBug> const transform_2d ht = IHT_8 [ tx_type ] ; for ( i = 0 ; i < 8 ; ++ i ) { ht . rows ( input , outptr ) ; input += 8 ; outptr += 8 ; } for ( i = 0 ; i < 8 ; ++ i ) { for ( j = 0 ; j < 8 ; ++ j ) temp_in [ j ] = out [ j * 8 + i ] ; ht . cols ( temp_in , temp_out ) ; <S2SV_StartBug> for ( j = 0 ; j < 8 ; ++ j ) <S2SV_EndBug> <S2SV_StartBug> dest [ j * stride + i ] = clip_pixel ( ROUND_POWER_OF_TWO ( temp_out [ j ] , 5 ) <S2SV_EndBug> <S2SV_StartBug> + dest [ j * stride + i ] ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> vp9_iht8x8_64_add_c ( const tran_low_t <S2SV_ModEnd> * input , <S2SV_ModStart> , j ; tran_low_t <S2SV_ModEnd> out [ 8 <S2SV_ModStart> 8 ] ; tran_low_t <S2SV_ModEnd> * outptr = <S2SV_ModStart> = out ; tran_low_t <S2SV_ModEnd> temp_in [ 8 <S2SV_ModStart> ++ j ) { <S2SV_ModStart> i ] = clip_pixel_add ( <S2SV_ModEnd> dest [ j <S2SV_ModStart> + i ] , ROUND_POWER_OF_TWO ( temp_out [ j ] , 5 ) ) ; } <S2SV_ModEnd> } } <S2SV_null>
"
1015,"CWE-000 SYSCALL_DEFINE3 ( rt_sigqueueinfo , pid_t , pid , int , sig , siginfo_t __user * , uinfo ) { siginfo_t info ; if ( copy_from_user ( & info , uinfo , sizeof ( siginfo_t ) ) ) return - EFAULT ; <S2SV_StartBug> if ( info . si_code >= 0 ) <S2SV_EndBug> <S2SV_StartBug> return - EPERM ; <S2SV_EndBug> info . si_signo = sig ; return kill_proc_info ( sig , & info , pid ) ; }
","<S2SV_ModStart> info . si_code != SI_QUEUE ) { WARN_ON_ONCE ( info . si_code < 0 ) ; <S2SV_ModEnd> return - EPERM <S2SV_ModStart> - EPERM ; }
"
1016,"CWE-362 static int do_setxattr ( struct btrfs_trans_handle * trans , struct inode * inode , const char * name , const void * value , size_t size , int flags ) { <S2SV_StartBug> struct btrfs_dir_item * di ; <S2SV_EndBug> struct btrfs_root * root = BTRFS_I ( inode ) -> root ; struct btrfs_path * path ; size_t name_len = strlen ( name ) ; int ret = 0 ; if ( name_len + size > BTRFS_MAX_XATTR_SIZE ( root ) ) return - ENOSPC ; path = btrfs_alloc_path ( ) ; if ( ! path ) return - ENOMEM ; <S2SV_StartBug> if ( flags & XATTR_REPLACE ) { <S2SV_EndBug> <S2SV_StartBug> di = btrfs_lookup_xattr ( trans , root , path , btrfs_ino ( inode ) , name , <S2SV_EndBug> name_len , - 1 ) ; if ( IS_ERR ( di ) ) { ret = PTR_ERR ( di ) ; goto out ; <S2SV_StartBug> } else if ( ! di ) { <S2SV_EndBug> ret = - ENODATA ; goto out ; } <S2SV_StartBug> ret = btrfs_delete_one_dir_name ( trans , root , path , di ) ; <S2SV_EndBug> if ( ret ) goto out ; <S2SV_StartBug> btrfs_release_path ( path ) ; <S2SV_EndBug> if ( ! value ) goto out ; <S2SV_StartBug> } else { <S2SV_EndBug> di = btrfs_lookup_xattr ( NULL , root , path , btrfs_ino ( inode ) , name , name_len , 0 ) ; if ( IS_ERR ( di ) ) { ret = PTR_ERR ( di ) ; goto out ; } if ( ! di && ! value ) goto out ; btrfs_release_path ( path ) ; } again : ret = btrfs_insert_xattr_item ( trans , root , path , btrfs_ino ( inode ) , name , name_len , value , size ) ; if ( ret == - EOVERFLOW ) ret = - EEXIST ; if ( ret == - EEXIST ) { <S2SV_StartBug> if ( flags & XATTR_CREATE ) <S2SV_EndBug> goto out ; <S2SV_StartBug> btrfs_release_path ( path ) ; <S2SV_EndBug> di = btrfs_lookup_xattr ( trans , root , path , btrfs_ino ( inode ) , name , name_len , - 1 ) ; if ( IS_ERR ( di ) ) { ret = PTR_ERR ( di ) ; goto out ; <S2SV_StartBug> } else if ( ! di ) { <S2SV_EndBug> btrfs_release_path ( path ) ; goto again ; } ret = btrfs_delete_one_dir_name ( trans , root , path , di ) ; if ( ret ) goto out ; <S2SV_StartBug> if ( value ) { <S2SV_EndBug> btrfs_release_path ( path ) ; goto again ; } } out : btrfs_free_path ( path ) ; return ret ; }
","<S2SV_ModStart> btrfs_dir_item * di = NULL <S2SV_ModStart> - ENOMEM ; path -> skip_release_on_error = 1 ; if ( ! value ) { di = btrfs_lookup_xattr ( trans , root , path , btrfs_ino ( inode ) , name , name_len , - 1 ) ; if ( ! di && <S2SV_ModEnd> ( flags & <S2SV_ModStart> & XATTR_REPLACE ) ) ret = - ENODATA ; else if ( di ) ret = btrfs_delete_one_dir_name <S2SV_ModEnd> ( trans , <S2SV_ModStart> , path , <S2SV_ModEnd> di ) ; <S2SV_ModStart> out ; } if ( flags & XATTR_REPLACE ) { ASSERT ( mutex_is_locked ( & inode -> i_mutex ) ) ; di = btrfs_lookup_xattr ( NULL , root , path , btrfs_ino ( inode ) , name , name_len , 0 ) ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> out ; } btrfs_release_path ( path ) ; di = NULL ; } ret = btrfs_insert_xattr_item <S2SV_ModEnd> ( trans , <S2SV_ModStart> , path , btrfs_ino ( inode ) , name , name_len , value , size ) ; if ( ret == - EOVERFLOW ) { ret = 0 ; btrfs_assert_tree_locked ( path -> nodes [ 0 ] ) ; di = btrfs_match_dir_item_name ( root , path , name , name_len ) ; if ( ! di && ! ( flags & XATTR_REPLACE ) ) { ret = - ENOSPC ; <S2SV_ModEnd> goto out ; <S2SV_ModStart> goto out ; } } else if ( ret == - EEXIST ) { ret = 0 ; di = btrfs_match_dir_item_name ( root , path , name , name_len ) ; ASSERT ( di ) ; } else if ( ret ) { <S2SV_ModEnd> goto out ; <S2SV_ModStart> out ; } if ( di && <S2SV_ModEnd> ( flags & <S2SV_ModStart> & XATTR_CREATE ) ) { ret = - EEXIST ; <S2SV_ModStart> goto out ; } if ( di ) { const int slot = path -> slots [ 0 ] ; struct extent_buffer * leaf = path -> nodes [ 0 ] ; const u16 old_data_len = btrfs_dir_data_len ( leaf , di ) ; const u32 item_size = btrfs_item_size_nr ( leaf , slot ) ; const u32 data_size = sizeof ( * di ) + name_len + size ; struct btrfs_item * item ; unsigned long data_ptr ; char * ptr ; if ( size > old_data_len ) { if ( btrfs_leaf_free_space ( root , leaf ) < ( size - old_data_len ) ) { ret = - ENOSPC <S2SV_ModEnd> ; goto out <S2SV_ModStart> out ; } } if ( old_data_len + name_len + sizeof ( * di ) == item_size ) { if ( size > old_data_len ) btrfs_extend_item ( root , path , size - old_data_len ) ; <S2SV_ModStart> else if ( size < old_data_len ) btrfs_truncate_item ( root , path , data_size , 1 ) ; } else { <S2SV_ModEnd> ret = btrfs_delete_one_dir_name <S2SV_ModStart> goto out ; btrfs_extend_item ( root , path , data_size ) ; } item = btrfs_item_nr ( slot ) ; ptr = btrfs_item_ptr ( leaf , slot , char ) ; ptr += btrfs_item_size ( leaf , item ) - data_size ; di = ( struct btrfs_dir_item * ) ptr ; btrfs_set_dir_data_len ( leaf , di , size ) ; data_ptr = ( ( unsigned long ) ( di + 1 ) ) + name_len ; write_extent_buffer ( leaf , value , data_ptr , size ) ; btrfs_mark_buffer_dirty ( leaf ) ; } else { <S2SV_ModEnd> } out :
"
1017,"CWE-59 void vrrp_print_data ( void ) { <S2SV_StartBug> FILE * file = fopen ( dump_file , ""w"" ) ; <S2SV_EndBug> if ( ! file ) { log_message ( LOG_INFO , ""Can\'t<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>(%d:<S2SV_blank>%s)"" , dump_file , errno , strerror ( errno ) ) ; return ; } dump_data_vrrp ( file ) ; fclose ( file ) ; }
","<S2SV_ModStart> * file = fopen_safe <S2SV_ModEnd> ( dump_file ,
"
1018,"CWE-399 static int unix_attach_fds ( struct scm_cookie * scm , struct sk_buff * skb ) { int i ; unsigned char max_level = 0 ; int unix_sock_count = 0 ; if ( too_many_unix_fds ( current ) ) return - ETOOMANYREFS ; for ( i = scm -> fp -> count - 1 ; i >= 0 ; i -- ) { struct sock * sk = unix_get_socket ( scm -> fp -> fp [ i ] ) ; if ( sk ) { unix_sock_count ++ ; max_level = max ( max_level , unix_sk ( sk ) -> recursion_level ) ; } } if ( unlikely ( max_level > MAX_RECURSION_LEVEL ) ) return - ETOOMANYREFS ; UNIXCB ( skb ) . fp = scm_fp_dup ( scm -> fp ) ; if ( ! UNIXCB ( skb ) . fp ) return - ENOMEM ; for ( i = scm -> fp -> count - 1 ; i >= 0 ; i -- ) <S2SV_StartBug> unix_inflight ( scm -> fp -> fp [ i ] ) ; <S2SV_EndBug> return max_level ; }
","<S2SV_ModStart> -> fp -> user , scm -> fp ->
"
1019,"CWE-000 static int orinoco_ioctl_set_auth ( struct net_device * dev , struct iw_request_info * info , union iwreq_data * wrqu , char * extra ) { struct orinoco_private * priv = ndev_priv ( dev ) ; hermes_t * hw = & priv -> hw ; struct iw_param * param = & wrqu -> param ; unsigned long flags ; int ret = - EINPROGRESS ; if ( orinoco_lock ( priv , & flags ) != 0 ) return - EBUSY ; switch ( param -> flags & IW_AUTH_INDEX ) { case IW_AUTH_WPA_VERSION : case IW_AUTH_CIPHER_PAIRWISE : case IW_AUTH_CIPHER_GROUP : case IW_AUTH_RX_UNENCRYPTED_EAPOL : case IW_AUTH_PRIVACY_INVOKED : case IW_AUTH_DROP_UNENCRYPTED : break ; case IW_AUTH_KEY_MGMT : priv -> key_mgmt = param -> value ; break ; case IW_AUTH_TKIP_COUNTERMEASURES : if ( param -> value ) { priv -> tkip_cm_active = 1 ; <S2SV_StartBug> ret = hermes_enable_port ( hw , 0 ) ; <S2SV_EndBug> } else { priv -> tkip_cm_active = 0 ; ret = hermes_disable_port ( hw , 0 ) ; } break ; case IW_AUTH_80211_AUTH_ALG : if ( param -> value & IW_AUTH_ALG_SHARED_KEY ) priv -> wep_restrict = 1 ; else if ( param -> value & IW_AUTH_ALG_OPEN_SYSTEM ) priv -> wep_restrict = 0 ; else ret = - EINVAL ; break ; case IW_AUTH_WPA_ENABLED : if ( priv -> has_wpa ) { priv -> wpa_enabled = param -> value ? 1 : 0 ; } else { if ( param -> value ) ret = - EOPNOTSUPP ; priv -> wpa_enabled = 0 ; } break ; default : ret = - EOPNOTSUPP ; } orinoco_unlock ( priv , & flags ) ; return ret ; }
","<S2SV_ModStart> ; ret = hermes_disable_port ( hw , 0 ) ; } else { priv -> tkip_cm_active = 0 ; ret = hermes_enable_port <S2SV_ModEnd> ( hw ,
"
1020,"CWE-20 sctp_disposition_t sctp_sf_do_5_1D_ce ( struct net * net , const struct sctp_endpoint * ep , const struct sctp_association * asoc , const sctp_subtype_t type , void * arg , sctp_cmd_seq_t * commands ) { struct sctp_chunk * chunk = arg ; struct sctp_association * new_asoc ; sctp_init_chunk_t * peer_init ; struct sctp_chunk * repl ; struct sctp_ulpevent * ev , * ai_ev = NULL ; int error = 0 ; struct sctp_chunk * err_chk_p ; struct sock * sk ; if ( ep == sctp_sk ( net -> sctp . ctl_sock ) -> ep ) { SCTP_INC_STATS ( net , SCTP_MIB_OUTOFBLUES ) ; return sctp_sf_tabort_8_4_8 ( net , ep , asoc , type , arg , commands ) ; } if ( ! sctp_chunk_length_valid ( chunk , sizeof ( sctp_chunkhdr_t ) ) ) return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; sk = ep -> base . sk ; if ( ! sctp_sstate ( sk , LISTENING ) || ( sctp_style ( sk , TCP ) && sk_acceptq_is_full ( sk ) ) ) return sctp_sf_tabort_8_4_8 ( net , ep , asoc , type , arg , commands ) ; chunk -> subh . cookie_hdr = ( struct sctp_signed_cookie * ) chunk -> skb -> data ; if ( ! pskb_pull ( chunk -> skb , ntohs ( chunk -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ) ) goto nomem ; new_asoc = sctp_unpack_cookie ( ep , asoc , chunk , GFP_ATOMIC , & error , & err_chk_p ) ; if ( ! new_asoc ) { switch ( error ) { case - SCTP_IERROR_NOMEM : goto nomem ; case - SCTP_IERROR_STALE_COOKIE : sctp_send_stale_cookie_err ( net , ep , asoc , chunk , commands , err_chk_p ) ; return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; case - SCTP_IERROR_BAD_SIG : default : return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; } } peer_init = & chunk -> subh . cookie_hdr -> c . peer_init [ 0 ] ; if ( ! sctp_process_init ( new_asoc , chunk , & chunk -> subh . cookie_hdr -> c . peer_addr , peer_init , GFP_ATOMIC ) ) goto nomem_init ; error = sctp_auth_asoc_init_active_key ( new_asoc , GFP_ATOMIC ) ; if ( error ) goto nomem_init ; if ( chunk -> auth_chunk ) { struct sctp_chunk auth ; sctp_ierror_t ret ; <S2SV_StartBug> auth . skb = chunk -> auth_chunk ; <S2SV_EndBug> auth . asoc = chunk -> asoc ; auth . sctp_hdr = chunk -> sctp_hdr ; auth . chunk_hdr = ( sctp_chunkhdr_t * ) skb_push ( chunk -> auth_chunk , sizeof ( sctp_chunkhdr_t ) ) ; skb_pull ( chunk -> auth_chunk , sizeof ( sctp_chunkhdr_t ) ) ; auth . transport = chunk -> transport ; ret = sctp_sf_authenticate ( net , ep , new_asoc , type , & auth ) ; kfree_skb ( chunk -> auth_chunk ) ; if ( ret != SCTP_IERROR_NO_ERROR ) { sctp_association_free ( new_asoc ) ; return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; } } repl = sctp_make_cookie_ack ( new_asoc , chunk ) ; if ( ! repl ) goto nomem_init ; ev = sctp_ulpevent_make_assoc_change ( new_asoc , 0 , SCTP_COMM_UP , 0 , new_asoc -> c . sinit_num_ostreams , new_asoc -> c . sinit_max_instreams , NULL , GFP_ATOMIC ) ; if ( ! ev ) goto nomem_ev ; if ( new_asoc -> peer . adaptation_ind ) { ai_ev = sctp_ulpevent_make_adaptation_indication ( new_asoc , GFP_ATOMIC ) ; if ( ! ai_ev ) goto nomem_aiev ; } sctp_add_cmd_sf ( commands , SCTP_CMD_NEW_ASOC , SCTP_ASOC ( new_asoc ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_NEW_STATE , SCTP_STATE ( SCTP_STATE_ESTABLISHED ) ) ; SCTP_INC_STATS ( net , SCTP_MIB_CURRESTAB ) ; SCTP_INC_STATS ( net , SCTP_MIB_PASSIVEESTABS ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_HB_TIMERS_START , SCTP_NULL ( ) ) ; if ( new_asoc -> timeouts [ SCTP_EVENT_TIMEOUT_AUTOCLOSE ] ) sctp_add_cmd_sf ( commands , SCTP_CMD_TIMER_START , SCTP_TO ( SCTP_EVENT_TIMEOUT_AUTOCLOSE ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_REPLY , SCTP_CHUNK ( repl ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_EVENT_ULP , SCTP_ULPEVENT ( ev ) ) ; if ( ai_ev ) sctp_add_cmd_sf ( commands , SCTP_CMD_EVENT_ULP , SCTP_ULPEVENT ( ai_ev ) ) ; return SCTP_DISPOSITION_CONSUME ; nomem_aiev : sctp_ulpevent_free ( ev ) ; nomem_ev : sctp_chunk_free ( repl ) ; nomem_init : sctp_association_free ( new_asoc ) ; nomem : return SCTP_DISPOSITION_NOMEM ; }
","<S2SV_ModStart> sctp_ierror_t ret ; if ( ! net -> sctp . auth_enable || ! new_asoc -> peer . auth_capable ) { kfree_skb ( chunk -> auth_chunk ) ; sctp_association_free ( new_asoc ) ; return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; }
"
1021,"CWE-494 const char * WinPKIErrorString ( void ) { static char error_string [ 64 ] ; DWORD error_code = GetLastError ( ) ; <S2SV_StartBug> if ( ( error_code >> 16 ) != 0x8009 ) <S2SV_EndBug> return WindowsErrorString ( ) ; switch ( error_code ) { case NTE_BAD_UID : return ""Bad<S2SV_blank>UID."" ; case CRYPT_E_MSG_ERROR : return ""An<S2SV_blank>error<S2SV_blank>occurred<S2SV_blank>while<S2SV_blank>performing<S2SV_blank>an<S2SV_blank>operation<S2SV_blank>on<S2SV_blank>a<S2SV_blank>cryptographic<S2SV_blank>message."" ; case CRYPT_E_UNKNOWN_ALGO : return ""Unknown<S2SV_blank>cryptographic<S2SV_blank>algorithm."" ; case CRYPT_E_INVALID_MSG_TYPE : return ""Invalid<S2SV_blank>cryptographic<S2SV_blank>message<S2SV_blank>type."" ; case CRYPT_E_HASH_VALUE : return ""The<S2SV_blank>hash<S2SV_blank>value<S2SV_blank>is<S2SV_blank>not<S2SV_blank>correct"" ; case CRYPT_E_ISSUER_SERIALNUMBER : return ""Invalid<S2SV_blank>issuer<S2SV_blank>and/or<S2SV_blank>serial<S2SV_blank>number."" ; case CRYPT_E_BAD_LEN : return ""The<S2SV_blank>length<S2SV_blank>specified<S2SV_blank>for<S2SV_blank>the<S2SV_blank>output<S2SV_blank>data<S2SV_blank>was<S2SV_blank>insufficient."" ; case CRYPT_E_BAD_ENCODE : return ""An<S2SV_blank>error<S2SV_blank>occurred<S2SV_blank>during<S2SV_blank>encode<S2SV_blank>or<S2SV_blank>decode<S2SV_blank>operation."" ; case CRYPT_E_FILE_ERROR : return ""An<S2SV_blank>error<S2SV_blank>occurred<S2SV_blank>while<S2SV_blank>reading<S2SV_blank>or<S2SV_blank>writing<S2SV_blank>to<S2SV_blank>a<S2SV_blank>file."" ; case CRYPT_E_NOT_FOUND : return ""Cannot<S2SV_blank>find<S2SV_blank>object<S2SV_blank>or<S2SV_blank>property."" ; case CRYPT_E_EXISTS : return ""The<S2SV_blank>object<S2SV_blank>or<S2SV_blank>property<S2SV_blank>already<S2SV_blank>exists."" ; case CRYPT_E_NO_PROVIDER : return ""No<S2SV_blank>provider<S2SV_blank>was<S2SV_blank>specified<S2SV_blank>for<S2SV_blank>the<S2SV_blank>store<S2SV_blank>or<S2SV_blank>object."" ; case CRYPT_E_DELETED_PREV : return ""The<S2SV_blank>previous<S2SV_blank>certificate<S2SV_blank>or<S2SV_blank>CRL<S2SV_blank>context<S2SV_blank>was<S2SV_blank>deleted."" ; case CRYPT_E_NO_MATCH : return ""Cannot<S2SV_blank>find<S2SV_blank>the<S2SV_blank>requested<S2SV_blank>object."" ; case CRYPT_E_UNEXPECTED_MSG_TYPE : case CRYPT_E_NO_KEY_PROPERTY : case CRYPT_E_NO_DECRYPT_CERT : return ""Private<S2SV_blank>key<S2SV_blank>or<S2SV_blank>certificate<S2SV_blank>issue"" ; case CRYPT_E_BAD_MSG : return ""Not<S2SV_blank>a<S2SV_blank>cryptographic<S2SV_blank>message."" ; case CRYPT_E_NO_SIGNER : return ""The<S2SV_blank>signed<S2SV_blank>cryptographic<S2SV_blank>message<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>a<S2SV_blank>signer<S2SV_blank>for<S2SV_blank>the<S2SV_blank>specified<S2SV_blank>signer<S2SV_blank>index."" ; case CRYPT_E_REVOKED : return ""The<S2SV_blank>certificate<S2SV_blank>is<S2SV_blank>revoked."" ; case CRYPT_E_NO_REVOCATION_DLL : case CRYPT_E_NO_REVOCATION_CHECK : case CRYPT_E_REVOCATION_OFFLINE : case CRYPT_E_NOT_IN_REVOCATION_DATABASE : return ""Cannot<S2SV_blank>check<S2SV_blank>certificate<S2SV_blank>revocation."" ; case CRYPT_E_INVALID_NUMERIC_STRING : case CRYPT_E_INVALID_PRINTABLE_STRING : case CRYPT_E_INVALID_IA5_STRING : case CRYPT_E_INVALID_X500_STRING : case CRYPT_E_NOT_CHAR_STRING : return ""Invalid<S2SV_blank>string."" ; case CRYPT_E_SECURITY_SETTINGS : return ""The<S2SV_blank>cryptographic<S2SV_blank>operation<S2SV_blank>failed<S2SV_blank>due<S2SV_blank>to<S2SV_blank>a<S2SV_blank>local<S2SV_blank>security<S2SV_blank>option<S2SV_blank>setting."" ; case CRYPT_E_NO_VERIFY_USAGE_CHECK : case CRYPT_E_VERIFY_USAGE_OFFLINE : return ""Cannot<S2SV_blank>complete<S2SV_blank>usage<S2SV_blank>check."" ; case CRYPT_E_NO_TRUSTED_SIGNER : <S2SV_StartBug> return ""None<S2SV_blank>of<S2SV_blank>the<S2SV_blank>signers<S2SV_blank>of<S2SV_blank>the<S2SV_blank>cryptographic<S2SV_blank>message<S2SV_blank>or<S2SV_blank>certificate<S2SV_blank>trust<S2SV_blank>list<S2SV_blank>is<S2SV_blank>trusted."" ; <S2SV_EndBug> default : static_sprintf ( error_string , ""Unknown<S2SV_blank>PKI<S2SV_blank>error<S2SV_blank>0x%08lX"" , error_code ) ; return error_string ; } }
","<S2SV_ModStart> if ( ( ( <S2SV_ModStart> != 0x8009 ) && ( ( error_code >> 16 ) != 0x800B ) ) <S2SV_ModStart> : return ""None<S2SV_blank>of<S2SV_blank>the<S2SV_blank>signers<S2SV_blank>of<S2SV_blank>the<S2SV_blank>cryptographic<S2SV_blank>message<S2SV_blank>or<S2SV_blank>certificate<S2SV_blank>trust<S2SV_blank>list<S2SV_blank>is<S2SV_blank>trusted."" ; case CERT_E_UNTRUSTEDROOT : return ""The<S2SV_blank>root<S2SV_blank>certificate<S2SV_blank>is<S2SV_blank>not<S2SV_blank>trusted."" ; case TRUST_E_NOSIGNATURE : return ""Not<S2SV_blank>digitally<S2SV_blank>signed."" ; case TRUST_E_EXPLICIT_DISTRUST : return ""One<S2SV_blank>of<S2SV_blank>the<S2SV_blank>certificates<S2SV_blank>used<S2SV_blank>was<S2SV_blank>marked<S2SV_blank>as<S2SV_blank>untrusted<S2SV_blank>by<S2SV_blank>the<S2SV_blank>user.""
"
1022,"CWE-20 static int cmd_handle_untagged ( struct ImapData * idata ) { unsigned int count = 0 ; char * s = imap_next_word ( idata -> buf ) ; char * pn = imap_next_word ( s ) ; if ( ( idata -> state >= IMAP_SELECTED ) && isdigit ( ( unsigned char ) * s ) ) { pn = s ; s = imap_next_word ( s ) ; if ( mutt_str_strncasecmp ( ""EXISTS"" , s , 6 ) == 0 ) { mutt_debug ( 2 , ""Handling<S2SV_blank>EXISTS\\n"" ) ; if ( mutt_str_atoui ( pn , & count ) < 0 ) { mutt_debug ( 1 , ""Malformed<S2SV_blank>EXISTS:<S2SV_blank>\'%s\'\\n"" , pn ) ; } if ( ! ( idata -> reopen & IMAP_EXPUNGE_PENDING ) && count < idata -> max_msn ) { mutt_debug ( 1 , ""Message<S2SV_blank>count<S2SV_blank>is<S2SV_blank>out<S2SV_blank>of<S2SV_blank>sync\\n"" ) ; return 0 ; } else if ( count == idata -> max_msn ) mutt_debug ( 3 , ""superfluous<S2SV_blank>EXISTS<S2SV_blank>message.\\n"" ) ; else { if ( ! ( idata -> reopen & IMAP_EXPUNGE_PENDING ) ) { mutt_debug ( 2 , ""New<S2SV_blank>mail<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>%d<S2SV_blank>messages<S2SV_blank>total.\\n"" , idata -> mailbox , count ) ; idata -> reopen |= IMAP_NEWMAIL_PENDING ; } idata -> new_mail_count = count ; } } else if ( mutt_str_strncasecmp ( ""EXPUNGE"" , s , 7 ) == 0 ) cmd_parse_expunge ( idata , pn ) ; else if ( mutt_str_strncasecmp ( ""FETCH"" , s , 5 ) == 0 ) cmd_parse_fetch ( idata , pn ) ; } else if ( mutt_str_strncasecmp ( ""CAPABILITY"" , s , 10 ) == 0 ) cmd_parse_capability ( idata , s ) ; else if ( mutt_str_strncasecmp ( ""OK<S2SV_blank>[CAPABILITY"" , s , 14 ) == 0 ) cmd_parse_capability ( idata , pn ) ; else if ( mutt_str_strncasecmp ( ""OK<S2SV_blank>[CAPABILITY"" , pn , 14 ) == 0 ) cmd_parse_capability ( idata , imap_next_word ( pn ) ) ; else if ( mutt_str_strncasecmp ( ""LIST"" , s , 4 ) == 0 ) cmd_parse_list ( idata , s ) ; else if ( mutt_str_strncasecmp ( ""LSUB"" , s , 4 ) == 0 ) cmd_parse_lsub ( idata , s ) ; else if ( mutt_str_strncasecmp ( ""MYRIGHTS"" , s , 8 ) == 0 ) cmd_parse_myrights ( idata , s ) ; else if ( mutt_str_strncasecmp ( ""SEARCH"" , s , 6 ) == 0 ) cmd_parse_search ( idata , s ) ; else if ( mutt_str_strncasecmp ( ""STATUS"" , s , 6 ) == 0 ) cmd_parse_status ( idata , s ) ; else if ( mutt_str_strncasecmp ( ""ENABLED"" , s , 7 ) == 0 ) cmd_parse_enabled ( idata , s ) ; else if ( mutt_str_strncasecmp ( ""BYE"" , s , 3 ) == 0 ) { mutt_debug ( 2 , ""Handling<S2SV_blank>BYE\\n"" ) ; if ( idata -> status == IMAP_BYE ) return 0 ; s += 3 ; SKIPWS ( s ) ; mutt_error ( ""%s"" , s ) ; cmd_handle_fatal ( idata ) ; return - 1 ; } else if ( ImapServernoise && ( mutt_str_strncasecmp ( ""NO"" , s , 2 ) == 0 ) ) { mutt_debug ( 2 , ""Handling<S2SV_blank>untagged<S2SV_blank>NO\\n"" ) ; <S2SV_StartBug> mutt_error ( ""%s"" , s + 3 ) ; <S2SV_EndBug> } return 0 ; }
","<S2SV_ModStart> , s + 2 <S2SV_ModEnd> ) ; }
"
1023,"CWE-125 static void print_attr_string ( netdissect_options * ndo , register const u_char * data , u_int length , u_short attr_code ) { register u_int i ; ND_TCHECK2 ( data [ 0 ] , length ) ; switch ( attr_code ) { case TUNNEL_PASS : if ( length < 3 ) <S2SV_StartBug> { <S2SV_EndBug> ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return ; } if ( * data && ( * data <= 0x1F ) ) ND_PRINT ( ( ndo , ""Tag[%u]<S2SV_blank>"" , * data ) ) ; else ND_PRINT ( ( ndo , ""Tag[Unused]<S2SV_blank>"" ) ) ; data ++ ; length -- ; ND_PRINT ( ( ndo , ""Salt<S2SV_blank>%u<S2SV_blank>"" , EXTRACT_16BITS ( data ) ) ) ; data += 2 ; length -= 2 ; break ; case TUNNEL_CLIENT_END : case TUNNEL_SERVER_END : case TUNNEL_PRIV_GROUP : case TUNNEL_ASSIGN_ID : case TUNNEL_CLIENT_AUTH : case TUNNEL_SERVER_AUTH : if ( * data <= 0x1F ) { if ( length < 1 ) <S2SV_StartBug> { <S2SV_EndBug> ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return ; } if ( * data ) ND_PRINT ( ( ndo , ""Tag[%u]<S2SV_blank>"" , * data ) ) ; else ND_PRINT ( ( ndo , ""Tag[Unused]<S2SV_blank>"" ) ) ; data ++ ; length -- ; } break ; <S2SV_StartBug> case EGRESS_VLAN_NAME : <S2SV_EndBug> ND_PRINT ( ( ndo , ""%s<S2SV_blank>(0x%02x)<S2SV_blank>"" , tok2str ( rfc4675_tagged , ""Unknown<S2SV_blank>tag"" , * data ) , * data ) ) ; data ++ ; length -- ; break ; } <S2SV_StartBug> for ( i = 0 ; * data && i < length ; i ++ , data ++ ) <S2SV_EndBug> ND_PRINT ( ( ndo , ""%c"" , ( * data < 32 || * data > 126 ) ? '.' : * data ) ) ; return ; trunc : ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; }
","<S2SV_ModStart> < 3 ) goto trunc ; <S2SV_ModEnd> if ( * <S2SV_ModStart> < 1 ) goto trunc ; if ( * data ) ND_PRINT ( ( ndo , ""Tag[%u]<S2SV_blank>"" , * data ) ) ; else ND_PRINT ( ( ndo , ""Tag[Unused]<S2SV_blank>"" ) ) ; data ++ ; length -- ; } <S2SV_ModEnd> break ; case <S2SV_ModStart> case EGRESS_VLAN_NAME : if ( length < 1 ) goto trunc ; <S2SV_ModStart> = 0 ; i < length && * data <S2SV_ModEnd> ; i ++
"
1024,"CWE-000 static inline int xfrm_replay_verify_len ( struct xfrm_replay_state_esn * replay_esn , struct nlattr * rp ) { struct xfrm_replay_state_esn * up ; int ulen ; if ( ! replay_esn || ! rp ) return 0 ; up = nla_data ( rp ) ; ulen = xfrm_replay_state_esn_len ( up ) ; if ( nla_len ( rp ) < ulen || xfrm_replay_state_esn_len ( replay_esn ) != ulen ) return - EINVAL ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
","<S2SV_ModStart> - EINVAL ; if ( up -> replay_window > up -> bmp_len * sizeof ( __u32 ) * 8 ) return - EINVAL ;
"
1025,"CWE-125 static void <S2SV_StartBug> l2tp_proxy_auth_type_print ( netdissect_options * ndo , const u_char * dat ) <S2SV_EndBug> { <S2SV_StartBug> const uint16_t * ptr = ( const uint16_t * ) dat ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""%s"" , tok2str ( l2tp_authentype2str , ""AuthType-#%u"" , EXTRACT_16BITS ( ptr ) ) ) ) ; }
","<S2SV_ModStart> u_char * dat , u_int length <S2SV_ModStart> ) dat ; if ( length < 2 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; }
"
1026,"CWE-20 static int x25_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct x25_sock * x25 = x25_sk ( sk ) ; struct sockaddr_x25 * sx25 = ( struct sockaddr_x25 * ) msg -> msg_name ; size_t copied ; int qbit , header_len ; struct sk_buff * skb ; unsigned char * asmptr ; int rc = - ENOTCONN ; lock_sock ( sk ) ; if ( x25 -> neighbour == NULL ) goto out ; header_len = x25 -> neighbour -> extended ? X25_EXT_MIN_LEN : X25_STD_MIN_LEN ; if ( sk -> sk_state != TCP_ESTABLISHED ) goto out ; if ( flags & MSG_OOB ) { rc = - EINVAL ; if ( sock_flag ( sk , SOCK_URGINLINE ) || ! skb_peek ( & x25 -> interrupt_in_queue ) ) goto out ; skb = skb_dequeue ( & x25 -> interrupt_in_queue ) ; if ( ! pskb_may_pull ( skb , X25_STD_MIN_LEN ) ) goto out_free_dgram ; skb_pull ( skb , X25_STD_MIN_LEN ) ; if ( test_bit ( X25_Q_BIT_FLAG , & x25 -> flags ) ) { asmptr = skb_push ( skb , 1 ) ; * asmptr = 0x00 ; } msg -> msg_flags |= MSG_OOB ; } else { release_sock ( sk ) ; skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & rc ) ; lock_sock ( sk ) ; if ( ! skb ) goto out ; if ( ! pskb_may_pull ( skb , header_len ) ) goto out_free_dgram ; qbit = ( skb -> data [ 0 ] & X25_Q_BIT ) == X25_Q_BIT ; skb_pull ( skb , header_len ) ; if ( test_bit ( X25_Q_BIT_FLAG , & x25 -> flags ) ) { asmptr = skb_push ( skb , 1 ) ; * asmptr = qbit ; } } skb_reset_transport_header ( skb ) ; copied = skb -> len ; if ( copied > size ) { copied = size ; msg -> msg_flags |= MSG_TRUNC ; } msg -> msg_flags |= MSG_EOR ; rc = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( rc ) goto out_free_dgram ; if ( sx25 ) { sx25 -> sx25_family = AF_X25 ; sx25 -> sx25_addr = x25 -> dest_addr ; <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> msg -> msg_namelen = sizeof ( struct sockaddr_x25 ) ; <S2SV_EndBug> x25_check_rbuf ( sk ) ; rc = copied ; out_free_dgram : skb_free_datagram ( sk , skb ) ; out : release_sock ( sk ) ; return rc ; }
","<S2SV_ModStart> -> dest_addr ; <S2SV_ModEnd> msg -> msg_namelen <S2SV_ModStart> = sizeof ( * sx25 ) ; } <S2SV_ModEnd> x25_check_rbuf ( sk
"
1027,"CWE-200 int sbusfb_ioctl_helper ( unsigned long cmd , unsigned long arg , struct fb_info * info , int type , int fb_depth , unsigned long fb_size ) { switch ( cmd ) { case FBIOGTYPE : { struct fbtype __user * f = ( struct fbtype __user * ) arg ; if ( put_user ( type , & f -> fb_type ) || __put_user ( info -> var . yres , & f -> fb_height ) || __put_user ( info -> var . xres , & f -> fb_width ) || __put_user ( fb_depth , & f -> fb_depth ) || __put_user ( 0 , & f -> fb_cmsize ) || __put_user ( fb_size , & f -> fb_cmsize ) ) return - EFAULT ; return 0 ; } case FBIOPUTCMAP_SPARC : { struct fbcmap __user * c = ( struct fbcmap __user * ) arg ; struct fb_cmap cmap ; u16 red , green , blue ; u8 red8 , green8 , blue8 ; unsigned char __user * ured ; unsigned char __user * ugreen ; unsigned char __user * ublue ; <S2SV_StartBug> int index , count , i ; <S2SV_EndBug> if ( get_user ( index , & c -> index ) || __get_user ( count , & c -> count ) || __get_user ( ured , & c -> red ) || __get_user ( ugreen , & c -> green ) || __get_user ( ublue , & c -> blue ) ) return - EFAULT ; cmap . len = 1 ; cmap . red = & red ; cmap . green = & green ; cmap . blue = & blue ; cmap . transp = NULL ; for ( i = 0 ; i < count ; i ++ ) { int err ; if ( get_user ( red8 , & ured [ i ] ) || get_user ( green8 , & ugreen [ i ] ) || get_user ( blue8 , & ublue [ i ] ) ) return - EFAULT ; red = red8 << 8 ; green = green8 << 8 ; blue = blue8 << 8 ; cmap . start = index + i ; err = fb_set_cmap ( & cmap , info ) ; if ( err ) return err ; } return 0 ; } case FBIOGETCMAP_SPARC : { struct fbcmap __user * c = ( struct fbcmap __user * ) arg ; unsigned char __user * ured ; unsigned char __user * ugreen ; unsigned char __user * ublue ; struct fb_cmap * cmap = & info -> cmap ; <S2SV_StartBug> int index , count , i ; <S2SV_EndBug> u8 red , green , blue ; if ( get_user ( index , & c -> index ) || __get_user ( count , & c -> count ) || __get_user ( ured , & c -> red ) || __get_user ( ugreen , & c -> green ) || __get_user ( ublue , & c -> blue ) ) return - EFAULT ; if ( index + count > cmap -> len ) return - EINVAL ; for ( i = 0 ; i < count ; i ++ ) { red = cmap -> red [ index + i ] >> 8 ; green = cmap -> green [ index + i ] >> 8 ; blue = cmap -> blue [ index + i ] >> 8 ; if ( put_user ( red , & ured [ i ] ) || put_user ( green , & ugreen [ i ] ) || put_user ( blue , & ublue [ i ] ) ) return - EFAULT ; } return 0 ; } default : return - EINVAL ; } }
","<S2SV_ModStart> * ublue ; unsigned <S2SV_ModStart> -> cmap ; unsigned
"
1028,"CWE-755 void AcpiNsTerminate ( void ) { ACPI_STATUS Status ; <S2SV_StartBug> ACPI_FUNCTION_TRACE ( NsTerminate ) ; <S2SV_EndBug> # ifdef ACPI_EXEC_APP { ACPI_OPERAND_OBJECT * Prev ; <S2SV_StartBug> ACPI_OPERAND_OBJECT * Next ; <S2SV_EndBug> Next = AcpiGbl_ModuleCodeList ; while ( Next ) { Prev = Next ; Next = Next -> Method . Mutex ; Prev -> Method . Mutex = NULL ; AcpiUtRemoveReference ( Prev ) ; } <S2SV_StartBug> } <S2SV_EndBug> # endif AcpiNsDeleteNamespaceSubtree ( AcpiGbl_RootNode ) ; Status = AcpiUtAcquireMutex ( ACPI_MTX_NAMESPACE ) ; if ( ACPI_FAILURE ( Status ) ) { return_VOID ; } AcpiNsDeleteNode ( AcpiGbl_RootNode ) ; ( void ) AcpiUtReleaseMutex ( ACPI_MTX_NAMESPACE ) ; ACPI_DEBUG_PRINT ( ( ACPI_DB_INFO , ""Namespace<S2SV_blank>freed\\n"" ) ) ; return_VOID ; }
","<S2SV_ModStart> ACPI_STATUS Status ; <S2SV_ModEnd> ACPI_OPERAND_OBJECT * Prev <S2SV_ModStart> ACPI_OPERAND_OBJECT * Next ; ACPI_FUNCTION_TRACE ( NsTerminate ) <S2SV_ModStart> ) ; } <S2SV_ModEnd> AcpiNsDeleteNamespaceSubtree ( AcpiGbl_RootNode
"
1029,"CWE-119 <S2SV_StartBug> int read_frame ( struct VpxInputContext * input_ctx , vpx_image_t * img ) { <S2SV_EndBug> FILE * f = input_ctx -> file ; y4m_input * y4m = & input_ctx -> y4m ; int shortread = 0 ; if ( input_ctx -> file_type == FILE_TYPE_Y4M ) { if ( y4m_input_fetch_frame ( y4m , f , img ) < 1 ) return 0 ; } else { shortread = read_yuv_frame ( input_ctx , img ) ; } return ! shortread ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
"
1030,"CWE-119 static __u8 * nci_extract_rf_params_nfcb_passive_poll ( struct nci_dev * ndev , struct rf_tech_specific_params_nfcb_poll * nfcb_poll , __u8 * data ) { <S2SV_StartBug> nfcb_poll -> sensb_res_len = * data ++ ; <S2SV_EndBug> pr_debug ( ""sensb_res_len<S2SV_blank>%d\\n"" , nfcb_poll -> sensb_res_len ) ; memcpy ( nfcb_poll -> sensb_res , data , nfcb_poll -> sensb_res_len ) ; data += nfcb_poll -> sensb_res_len ; return data ; }
","<S2SV_ModStart> -> sensb_res_len = min_t ( __u8 , <S2SV_ModStart> * data ++ , NFC_SENSB_RES_MAXSIZE )
"
1031,"CWE-119 int cdf_read_property_info ( const cdf_stream_t * sst , const cdf_header_t * h , uint32_t offs , cdf_property_info_t * * info , size_t * count , size_t * maxcount ) { const cdf_section_header_t * shp ; cdf_section_header_t sh ; const uint8_t * p , * q , * e ; int16_t s16 ; int32_t s32 ; uint32_t u32 ; int64_t s64 ; uint64_t u64 ; cdf_timestamp_t tp ; size_t i , o , o4 , nelements , j ; cdf_property_info_t * inp ; if ( offs > UINT32_MAX / 4 ) { errno = EFTYPE ; goto out ; } shp = CAST ( const cdf_section_header_t * , ( const void * ) ( ( const char * ) sst -> sst_tab + offs ) ) ; if ( cdf_check_stream_offset ( sst , h , shp , sizeof ( * shp ) , __LINE__ ) == - 1 ) goto out ; sh . sh_len = CDF_TOLE4 ( shp -> sh_len ) ; # define CDF_SHLEN_LIMIT ( UINT32_MAX / 8 ) if ( sh . sh_len > CDF_SHLEN_LIMIT ) { errno = EFTYPE ; goto out ; } sh . sh_properties = CDF_TOLE4 ( shp -> sh_properties ) ; # define CDF_PROP_LIMIT ( UINT32_MAX / ( 4 * sizeof ( * inp ) ) ) if ( sh . sh_properties > CDF_PROP_LIMIT ) goto out ; DPRINTF ( ( ""section<S2SV_blank>len:<S2SV_blank>%u<S2SV_blank>properties<S2SV_blank>%u\\n"" , sh . sh_len , sh . sh_properties ) ) ; if ( * maxcount ) { if ( * maxcount > CDF_PROP_LIMIT ) goto out ; * maxcount += sh . sh_properties ; inp = CAST ( cdf_property_info_t * , realloc ( * info , * maxcount * sizeof ( * inp ) ) ) ; } else { * maxcount = sh . sh_properties ; inp = CAST ( cdf_property_info_t * , malloc ( * maxcount * sizeof ( * inp ) ) ) ; } if ( inp == NULL ) goto out ; * info = inp ; inp += * count ; * count += sh . sh_properties ; p = CAST ( const uint8_t * , ( const void * ) ( ( const char * ) ( const void * ) sst -> sst_tab + offs + sizeof ( sh ) ) ) ; e = CAST ( const uint8_t * , ( const void * ) ( ( ( const char * ) ( const void * ) shp ) + sh . sh_len ) ) ; if ( cdf_check_stream_offset ( sst , h , e , 0 , __LINE__ ) == - 1 ) goto out ; for ( i = 0 ; i < sh . sh_properties ; i ++ ) { q = ( const uint8_t * ) ( const void * ) ( ( const char * ) ( const void * ) p + CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ) - 2 * sizeof ( uint32_t ) ; if ( q > e ) { DPRINTF ( ( ""Ran<S2SV_blank>of<S2SV_blank>the<S2SV_blank>end<S2SV_blank>%p<S2SV_blank>><S2SV_blank>%p\\n"" , q , e ) ) ; goto out ; } inp [ i ] . pi_id = CDF_GETUINT32 ( p , i << 1 ) ; inp [ i ] . pi_type = CDF_GETUINT32 ( q , 0 ) ; DPRINTF ( ( ""%d)<S2SV_blank>id=%x<S2SV_blank>type=%x<S2SV_blank>offs=%x,%d\\n"" , i , inp [ i ] . pi_id , inp [ i ] . pi_type , q - p , CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ) ) ; if ( inp [ i ] . pi_type & CDF_VECTOR ) { nelements = CDF_GETUINT32 ( q , 1 ) ; o = 2 ; } else { nelements = 1 ; o = 1 ; } o4 = o * sizeof ( uint32_t ) ; if ( inp [ i ] . pi_type & ( CDF_ARRAY | CDF_BYREF | CDF_RESERVED ) ) goto unknown ; switch ( inp [ i ] . pi_type & CDF_TYPEMASK ) { case CDF_NULL : case CDF_EMPTY : break ; case CDF_SIGNED16 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s16 , & q [ o4 ] , sizeof ( s16 ) ) ; inp [ i ] . pi_s16 = CDF_TOLE2 ( s16 ) ; break ; case CDF_SIGNED32 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s32 , & q [ o4 ] , sizeof ( s32 ) ) ; inp [ i ] . pi_s32 = CDF_TOLE4 ( ( uint32_t ) s32 ) ; break ; case CDF_BOOL : case CDF_UNSIGNED32 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u32 , & q [ o4 ] , sizeof ( u32 ) ) ; inp [ i ] . pi_u32 = CDF_TOLE4 ( u32 ) ; break ; case CDF_SIGNED64 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s64 , & q [ o4 ] , sizeof ( s64 ) ) ; inp [ i ] . pi_s64 = CDF_TOLE8 ( ( uint64_t ) s64 ) ; break ; case CDF_UNSIGNED64 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u64 , & q [ o4 ] , sizeof ( u64 ) ) ; inp [ i ] . pi_u64 = CDF_TOLE8 ( ( uint64_t ) u64 ) ; break ; case CDF_LENGTH32_STRING : case CDF_LENGTH32_WSTRING : if ( nelements > 1 ) { size_t nelem = inp - * info ; if ( * maxcount > CDF_PROP_LIMIT || nelements > CDF_PROP_LIMIT ) goto out ; * maxcount += nelements ; inp = CAST ( cdf_property_info_t * , realloc ( * info , * maxcount * sizeof ( * inp ) ) ) ; if ( inp == NULL ) goto out ; * info = inp ; inp = * info + nelem ; } DPRINTF ( ( ""nelements<S2SV_blank>=<S2SV_blank>%d\\n"" , nelements ) ) ; for ( j = 0 ; j < nelements ; j ++ , i ++ ) { uint32_t l = CDF_GETUINT32 ( q , o ) ; inp [ i ] . pi_str . s_len = l ; inp [ i ] . pi_str . s_buf = ( const char * ) ( const void * ) ( & q [ o4 + sizeof ( l ) ] ) ; DPRINTF ( ( ""l<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>r<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>s<S2SV_blank>=<S2SV_blank>%s\\n"" , l , CDF_ROUND ( l , sizeof ( l ) ) , inp [ i ] . pi_str . s_buf ) ) ; l = 4 + ( uint32_t ) CDF_ROUND ( l , sizeof ( l ) ) ; o += l >> 2 ; <S2SV_StartBug> o4 = o * sizeof ( uint32_t ) ; <S2SV_EndBug> } i -- ; break ; case CDF_FILETIME : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & tp , & q [ o4 ] , sizeof ( tp ) ) ; inp [ i ] . pi_tp = CDF_TOLE8 ( ( uint64_t ) tp ) ; break ; case CDF_CLIPBOARD : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; break ; default : unknown : DPRINTF ( ( ""Don\'t<S2SV_blank>know<S2SV_blank>how<S2SV_blank>to<S2SV_blank>deal<S2SV_blank>with<S2SV_blank>%x\\n"" , inp [ i ] . pi_type ) ) ; goto out ; } } return 0 ; out : free ( * info ) ; return - 1 ; }
","<S2SV_ModStart> >> 2 ; if ( q + o >= e ) goto out ;
"
1032,"CWE-77 enum ImapAuthRes imap_auth_login ( struct ImapData * idata , const char * method ) { char q_user [ SHORT_STRING ] , q_pass [ SHORT_STRING ] ; char buf [ STRING ] ; int rc ; if ( mutt_bit_isset ( idata -> capabilities , LOGINDISABLED ) ) { mutt_message ( _ ( ""LOGIN<S2SV_blank>disabled<S2SV_blank>on<S2SV_blank>this<S2SV_blank>server."" ) ) ; return IMAP_AUTH_UNAVAIL ; } if ( mutt_account_getuser ( & idata -> conn -> account ) < 0 ) return IMAP_AUTH_FAILURE ; if ( mutt_account_getpass ( & idata -> conn -> account ) < 0 ) return IMAP_AUTH_FAILURE ; mutt_message ( _ ( ""Logging<S2SV_blank>in..."" ) ) ; <S2SV_StartBug> imap_quote_string ( q_user , sizeof ( q_user ) , idata -> conn -> account . user ) ; <S2SV_EndBug> <S2SV_StartBug> imap_quote_string ( q_pass , sizeof ( q_pass ) , idata -> conn -> account . pass ) ; <S2SV_EndBug> if ( DebugLevel < IMAP_LOG_PASS ) mutt_debug ( 2 , ""Sending<S2SV_blank>LOGIN<S2SV_blank>command<S2SV_blank>for<S2SV_blank>%s...\\n"" , idata -> conn -> account . user ) ; snprintf ( buf , sizeof ( buf ) , ""LOGIN<S2SV_blank>%s<S2SV_blank>%s"" , q_user , q_pass ) ; rc = imap_exec ( idata , buf , IMAP_CMD_FAIL_OK | IMAP_CMD_PASS ) ; if ( ! rc ) { mutt_clear_error ( ) ; return IMAP_AUTH_SUCCESS ; } mutt_error ( _ ( ""Login<S2SV_blank>failed."" ) ) ; return IMAP_AUTH_FAILURE ; }
","<S2SV_ModStart> account . user , false <S2SV_ModStart> account . pass , false
"
1033,"CWE-415 zip_int64_t _zip_dirent_read ( zip_dirent_t * zde , zip_source_t * src , zip_buffer_t * buffer , bool local , zip_error_t * error ) { zip_uint8_t buf [ CDENTRYSIZE ] ; zip_uint16_t dostime , dosdate ; zip_uint32_t size , variable_size ; zip_uint16_t filename_len , comment_len , ef_len ; bool from_buffer = ( buffer != NULL ) ; size = local ? LENTRYSIZE : CDENTRYSIZE ; if ( buffer ) { if ( _zip_buffer_left ( buffer ) < size ) { zip_error_set ( error , ZIP_ER_NOZIP , 0 ) ; return - 1 ; } } else { if ( ( buffer = _zip_buffer_new_from_source ( src , size , buf , error ) ) == NULL ) { return - 1 ; } } if ( memcmp ( _zip_buffer_get ( buffer , 4 ) , ( local ? LOCAL_MAGIC : CENTRAL_MAGIC ) , 4 ) != 0 ) { zip_error_set ( error , ZIP_ER_NOZIP , 0 ) ; if ( ! from_buffer ) { _zip_buffer_free ( buffer ) ; } return - 1 ; } _zip_dirent_init ( zde ) ; if ( ! local ) zde -> version_madeby = _zip_buffer_get_16 ( buffer ) ; else zde -> version_madeby = 0 ; zde -> version_needed = _zip_buffer_get_16 ( buffer ) ; zde -> bitflags = _zip_buffer_get_16 ( buffer ) ; zde -> comp_method = _zip_buffer_get_16 ( buffer ) ; dostime = _zip_buffer_get_16 ( buffer ) ; dosdate = _zip_buffer_get_16 ( buffer ) ; zde -> last_mod = _zip_d2u_time ( dostime , dosdate ) ; zde -> crc = _zip_buffer_get_32 ( buffer ) ; zde -> comp_size = _zip_buffer_get_32 ( buffer ) ; zde -> uncomp_size = _zip_buffer_get_32 ( buffer ) ; filename_len = _zip_buffer_get_16 ( buffer ) ; ef_len = _zip_buffer_get_16 ( buffer ) ; if ( local ) { comment_len = 0 ; zde -> disk_number = 0 ; zde -> int_attrib = 0 ; zde -> ext_attrib = 0 ; zde -> offset = 0 ; } else { comment_len = _zip_buffer_get_16 ( buffer ) ; zde -> disk_number = _zip_buffer_get_16 ( buffer ) ; zde -> int_attrib = _zip_buffer_get_16 ( buffer ) ; zde -> ext_attrib = _zip_buffer_get_32 ( buffer ) ; zde -> offset = _zip_buffer_get_32 ( buffer ) ; } if ( ! _zip_buffer_ok ( buffer ) ) { zip_error_set ( error , ZIP_ER_INTERNAL , 0 ) ; if ( ! from_buffer ) { _zip_buffer_free ( buffer ) ; } return - 1 ; } if ( zde -> bitflags & ZIP_GPBF_ENCRYPTED ) { if ( zde -> bitflags & ZIP_GPBF_STRONG_ENCRYPTION ) { zde -> encryption_method = ZIP_EM_UNKNOWN ; } else { zde -> encryption_method = ZIP_EM_TRAD_PKWARE ; } } else { zde -> encryption_method = ZIP_EM_NONE ; } zde -> filename = NULL ; zde -> extra_fields = NULL ; zde -> comment = NULL ; variable_size = ( zip_uint32_t ) filename_len + ( zip_uint32_t ) ef_len + ( zip_uint32_t ) comment_len ; if ( from_buffer ) { if ( _zip_buffer_left ( buffer ) < variable_size ) { zip_error_set ( error , ZIP_ER_INCONS , 0 ) ; return - 1 ; } } else { _zip_buffer_free ( buffer ) ; if ( ( buffer = _zip_buffer_new_from_source ( src , variable_size , NULL , error ) ) == NULL ) { return - 1 ; } } if ( filename_len ) { zde -> filename = _zip_read_string ( buffer , src , filename_len , 1 , error ) ; if ( ! zde -> filename ) { if ( zip_error_code_zip ( error ) == ZIP_ER_EOF ) { zip_error_set ( error , ZIP_ER_INCONS , 0 ) ; } if ( ! from_buffer ) { _zip_buffer_free ( buffer ) ; } return - 1 ; } if ( zde -> bitflags & ZIP_GPBF_ENCODING_UTF_8 ) { if ( _zip_guess_encoding ( zde -> filename , ZIP_ENCODING_UTF8_KNOWN ) == ZIP_ENCODING_ERROR ) { zip_error_set ( error , ZIP_ER_INCONS , 0 ) ; if ( ! from_buffer ) { _zip_buffer_free ( buffer ) ; } return - 1 ; } } } if ( ef_len ) { zip_uint8_t * ef = _zip_read_data ( buffer , src , ef_len , 0 , error ) ; if ( ef == NULL ) { if ( ! from_buffer ) { _zip_buffer_free ( buffer ) ; } return - 1 ; } if ( ! _zip_ef_parse ( ef , ef_len , local ? ZIP_EF_LOCAL : ZIP_EF_CENTRAL , & zde -> extra_fields , error ) ) { free ( ef ) ; if ( ! from_buffer ) { _zip_buffer_free ( buffer ) ; } return - 1 ; } free ( ef ) ; if ( local ) zde -> local_extra_fields_read = 1 ; } if ( comment_len ) { zde -> comment = _zip_read_string ( buffer , src , comment_len , 0 , error ) ; if ( ! zde -> comment ) { if ( ! from_buffer ) { _zip_buffer_free ( buffer ) ; } return - 1 ; } if ( zde -> bitflags & ZIP_GPBF_ENCODING_UTF_8 ) { if ( _zip_guess_encoding ( zde -> comment , ZIP_ENCODING_UTF8_KNOWN ) == ZIP_ENCODING_ERROR ) { zip_error_set ( error , ZIP_ER_INCONS , 0 ) ; if ( ! from_buffer ) { _zip_buffer_free ( buffer ) ; } return - 1 ; } } } zde -> filename = _zip_dirent_process_ef_utf_8 ( zde , ZIP_EF_UTF_8_NAME , zde -> filename ) ; zde -> comment = _zip_dirent_process_ef_utf_8 ( zde , ZIP_EF_UTF_8_COMMENT , zde -> comment ) ; if ( zde -> uncomp_size == ZIP_UINT32_MAX || zde -> comp_size == ZIP_UINT32_MAX || zde -> offset == ZIP_UINT32_MAX ) { zip_uint16_t got_len ; zip_buffer_t * ef_buffer ; const zip_uint8_t * ef = _zip_ef_get_by_id ( zde -> extra_fields , & got_len , ZIP_EF_ZIP64 , 0 , local ? ZIP_EF_LOCAL : ZIP_EF_CENTRAL , error ) ; if ( ef == NULL ) { if ( ! from_buffer ) { _zip_buffer_free ( buffer ) ; } return - 1 ; } if ( ( ef_buffer = _zip_buffer_new ( ( zip_uint8_t * ) ef , got_len ) ) == NULL ) { zip_error_set ( error , ZIP_ER_MEMORY , 0 ) ; if ( ! from_buffer ) { _zip_buffer_free ( buffer ) ; } return - 1 ; } if ( zde -> uncomp_size == ZIP_UINT32_MAX ) zde -> uncomp_size = _zip_buffer_get_64 ( ef_buffer ) ; else if ( local ) { ( void ) _zip_buffer_skip ( ef_buffer , 8 ) ; } if ( zde -> comp_size == ZIP_UINT32_MAX ) zde -> comp_size = _zip_buffer_get_64 ( ef_buffer ) ; if ( ! local ) { if ( zde -> offset == ZIP_UINT32_MAX ) zde -> offset = _zip_buffer_get_64 ( ef_buffer ) ; if ( zde -> disk_number == ZIP_UINT16_MAX ) zde -> disk_number = _zip_buffer_get_32 ( buffer ) ; } if ( ! _zip_buffer_eof ( ef_buffer ) ) { zip_error_set ( error , ZIP_ER_INCONS , 0 ) ; _zip_buffer_free ( ef_buffer ) ; if ( ! from_buffer ) { _zip_buffer_free ( buffer ) ; } return - 1 ; } _zip_buffer_free ( ef_buffer ) ; } if ( ! _zip_buffer_ok ( buffer ) ) { zip_error_set ( error , ZIP_ER_INTERNAL , 0 ) ; if ( ! from_buffer ) { _zip_buffer_free ( buffer ) ; } return - 1 ; } if ( ! from_buffer ) { _zip_buffer_free ( buffer ) ; } if ( zde -> offset > ZIP_INT64_MAX ) { zip_error_set ( error , ZIP_ER_SEEK , EFBIG ) ; return - 1 ; } if ( ! _zip_dirent_process_winzip_aes ( zde , error ) ) { <S2SV_StartBug> if ( ! from_buffer ) { <S2SV_EndBug> _zip_buffer_free ( buffer ) ; } return - 1 ; } zde -> extra_fields = _zip_ef_remove_internal ( zde -> extra_fields ) ; return ( zip_int64_t ) ( size + variable_size ) ; }
","<S2SV_ModStart> ) ) { <S2SV_ModEnd> return - 1
"
1034,"CWE-434 static int zipfileUpdate ( sqlite3_vtab * pVtab , int nVal , sqlite3_value * * apVal , sqlite_int64 * pRowid ) { ZipfileTab * pTab = ( ZipfileTab * ) pVtab ; int rc = SQLITE_OK ; ZipfileEntry * pNew = 0 ; u32 mode = 0 ; u32 mTime = 0 ; i64 sz = 0 ; const char * zPath = 0 ; int nPath = 0 ; const u8 * pData = 0 ; int nData = 0 ; int iMethod = 0 ; u8 * pFree = 0 ; char * zFree = 0 ; ZipfileEntry * pOld = 0 ; ZipfileEntry * pOld2 = 0 ; int bUpdate = 0 ; int bIsDir = 0 ; u32 iCrc32 = 0 ; if ( pTab -> pWriteFd == 0 ) { rc = zipfileBegin ( pVtab ) ; if ( rc != SQLITE_OK ) return rc ; } if ( sqlite3_value_type ( apVal [ 0 ] ) != SQLITE_NULL ) { const char * zDelete = ( const char * ) sqlite3_value_text ( apVal [ 0 ] ) ; int nDelete = ( int ) strlen ( zDelete ) ; if ( nVal > 1 ) { const char * zUpdate = ( const char * ) sqlite3_value_text ( apVal [ 1 ] ) ; if ( zUpdate && zipfileComparePath ( zUpdate , zDelete , nDelete ) != 0 ) { bUpdate = 1 ; } } for ( pOld = pTab -> pFirstEntry ; 1 ; pOld = pOld -> pNext ) { if ( zipfileComparePath ( pOld -> cds . zFile , zDelete , nDelete ) == 0 ) { break ; } assert ( pOld -> pNext ) ; } } if ( nVal > 1 ) { if ( sqlite3_value_type ( apVal [ 5 ] ) != SQLITE_NULL ) { zipfileTableErr ( pTab , ""sz<S2SV_blank>must<S2SV_blank>be<S2SV_blank>NULL"" ) ; rc = SQLITE_CONSTRAINT ; } if ( sqlite3_value_type ( apVal [ 6 ] ) != SQLITE_NULL ) { zipfileTableErr ( pTab , ""rawdata<S2SV_blank>must<S2SV_blank>be<S2SV_blank>NULL"" ) ; rc = SQLITE_CONSTRAINT ; } if ( rc == SQLITE_OK ) { if ( sqlite3_value_type ( apVal [ 7 ] ) == SQLITE_NULL ) { bIsDir = 1 ; } else { const u8 * aIn = sqlite3_value_blob ( apVal [ 7 ] ) ; int nIn = sqlite3_value_bytes ( apVal [ 7 ] ) ; int bAuto = sqlite3_value_type ( apVal [ 8 ] ) == SQLITE_NULL ; iMethod = sqlite3_value_int ( apVal [ 8 ] ) ; sz = nIn ; pData = aIn ; nData = nIn ; if ( iMethod != 0 && iMethod != 8 ) { zipfileTableErr ( pTab , ""unknown<S2SV_blank>compression<S2SV_blank>method:<S2SV_blank>%d"" , iMethod ) ; rc = SQLITE_CONSTRAINT ; } else { if ( bAuto || iMethod ) { int nCmp ; rc = zipfileDeflate ( aIn , nIn , & pFree , & nCmp , & pTab -> base . zErrMsg ) ; if ( rc == SQLITE_OK ) { if ( iMethod || nCmp < nIn ) { iMethod = 8 ; pData = pFree ; nData = nCmp ; } } } iCrc32 = crc32 ( 0 , aIn , nIn ) ; } } } if ( rc == SQLITE_OK ) { rc = zipfileGetMode ( apVal [ 3 ] , bIsDir , & mode , & pTab -> base . zErrMsg ) ; } if ( rc == SQLITE_OK ) { zPath = ( const char * ) sqlite3_value_text ( apVal [ 2 ] ) ; <S2SV_StartBug> nPath = ( int ) strlen ( zPath ) ; <S2SV_EndBug> mTime = zipfileGetTime ( apVal [ 4 ] ) ; } if ( rc == SQLITE_OK && bIsDir ) { if ( zPath [ nPath - 1 ] != '/' ) { zFree = sqlite3_mprintf ( ""%s/"" , zPath ) ; if ( zFree == 0 ) { rc = SQLITE_NOMEM ; } zPath = ( const char * ) zFree ; nPath ++ ; } } if ( ( pOld == 0 || bUpdate ) && rc == SQLITE_OK ) { ZipfileEntry * p ; for ( p = pTab -> pFirstEntry ; p ; p = p -> pNext ) { if ( zipfileComparePath ( p -> cds . zFile , zPath , nPath ) == 0 ) { switch ( sqlite3_vtab_on_conflict ( pTab -> db ) ) { case SQLITE_IGNORE : { goto zipfile_update_done ; } case SQLITE_REPLACE : { pOld2 = p ; break ; } default : { zipfileTableErr ( pTab , ""duplicate<S2SV_blank>name:<S2SV_blank>\\""%s\\"""" , zPath ) ; rc = SQLITE_CONSTRAINT ; break ; } } break ; } } } if ( rc == SQLITE_OK ) { pNew = zipfileNewEntry ( zPath ) ; if ( pNew == 0 ) { rc = SQLITE_NOMEM ; } else { pNew -> cds . iVersionMadeBy = ZIPFILE_NEWENTRY_MADEBY ; pNew -> cds . iVersionExtract = ZIPFILE_NEWENTRY_REQUIRED ; pNew -> cds . flags = ZIPFILE_NEWENTRY_FLAGS ; pNew -> cds . iCompression = ( u16 ) iMethod ; zipfileMtimeToDos ( & pNew -> cds , mTime ) ; pNew -> cds . crc32 = iCrc32 ; pNew -> cds . szCompressed = nData ; pNew -> cds . szUncompressed = ( u32 ) sz ; pNew -> cds . iExternalAttr = ( mode << 16 ) ; pNew -> cds . iOffset = ( u32 ) pTab -> szCurrent ; pNew -> cds . nFile = ( u16 ) nPath ; pNew -> mUnixTime = ( u32 ) mTime ; rc = zipfileAppendEntry ( pTab , pNew , pData , nData ) ; zipfileAddEntry ( pTab , pOld , pNew ) ; } } } if ( rc == SQLITE_OK && ( pOld || pOld2 ) ) { ZipfileCsr * pCsr ; for ( pCsr = pTab -> pCsrList ; pCsr ; pCsr = pCsr -> pCsrNext ) { if ( pCsr -> pCurrent && ( pCsr -> pCurrent == pOld || pCsr -> pCurrent == pOld2 ) ) { pCsr -> pCurrent = pCsr -> pCurrent -> pNext ; pCsr -> bNoop = 1 ; } } zipfileRemoveEntryFromList ( pTab , pOld ) ; zipfileRemoveEntryFromList ( pTab , pOld2 ) ; } zipfile_update_done : sqlite3_free ( pFree ) ; sqlite3_free ( zFree ) ; return rc ; }
","<S2SV_ModStart> ] ) ; if ( zPath == 0 ) zPath = """" ;
"
1035,"CWE-119 static int put_chars ( u32 vtermno , const char * buf , int count ) { struct port * port ; <S2SV_StartBug> struct scatterlist sg [ 1 ] ; <S2SV_EndBug> if ( unlikely ( early_put_chars ) ) return early_put_chars ( vtermno , buf , count ) ; port = find_port_by_vtermno ( vtermno ) ; if ( ! port ) return - EPIPE ; <S2SV_StartBug> sg_init_one ( sg , buf , count ) ; <S2SV_EndBug> <S2SV_StartBug> return __send_to_port ( port , sg , 1 , count , ( void * ) buf , false ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> [ 1 ] ; void * data ; int ret <S2SV_ModStart> - EPIPE ; data = kmemdup ( buf , count , GFP_ATOMIC ) ; if ( ! data ) return - ENOMEM ; <S2SV_ModStart> ( sg , data <S2SV_ModEnd> , count ) <S2SV_ModStart> count ) ; ret = <S2SV_ModEnd> __send_to_port ( port <S2SV_ModStart> , count , data <S2SV_ModEnd> , false ) <S2SV_ModStart> false ) ; kfree ( data ) ; return ret ;
"
1036,"CWE-190 static int b_unpack ( lua_State * L ) { Header h ; const char * fmt = luaL_checkstring ( L , 1 ) ; size_t ld ; const char * data = luaL_checklstring ( L , 2 , & ld ) ; <S2SV_StartBug> size_t pos = luaL_optinteger ( L , 3 , 1 ) - 1 ; <S2SV_EndBug> int n = 0 ; defaultoptions ( & h ) ; while ( * fmt ) { int opt = * fmt ++ ; size_t size = optsize ( L , opt , & fmt ) ; pos += gettoalign ( pos , & h , opt , size ) ; <S2SV_StartBug> luaL_argcheck ( L , pos + size <= ld , 2 , ""data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short"" ) ; <S2SV_EndBug> luaL_checkstack ( L , 2 , ""too<S2SV_blank>many<S2SV_blank>results"" ) ; switch ( opt ) { case 'b' : case 'B' : case 'h' : case 'H' : case 'l' : case 'L' : case 'T' : case 'i' : case 'I' : { int issigned = islower ( opt ) ; lua_Number res = getinteger ( data + pos , h . endian , issigned , size ) ; lua_pushnumber ( L , res ) ; n ++ ; break ; } case 'x' : { break ; } case 'f' : { float f ; memcpy ( & f , data + pos , size ) ; correctbytes ( ( char * ) & f , sizeof ( f ) , h . endian ) ; lua_pushnumber ( L , f ) ; n ++ ; break ; } case 'd' : { double d ; memcpy ( & d , data + pos , size ) ; correctbytes ( ( char * ) & d , sizeof ( d ) , h . endian ) ; lua_pushnumber ( L , d ) ; n ++ ; break ; } case 'c' : { if ( size == 0 ) { if ( n == 0 || ! lua_isnumber ( L , - 1 ) ) luaL_error ( L , ""format<S2SV_blank>\'c0\'<S2SV_blank>needs<S2SV_blank>a<S2SV_blank>previous<S2SV_blank>size"" ) ; size = lua_tonumber ( L , - 1 ) ; lua_pop ( L , 1 ) ; n -- ; luaL_argcheck ( L , size <= ld && pos <= ld - size , 2 , ""data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short"" ) ; } lua_pushlstring ( L , data + pos , size ) ; n ++ ; break ; } case 's' : { const char * e = ( const char * ) memchr ( data + pos , '\\0' , ld - pos ) ; if ( e == NULL ) luaL_error ( L , ""unfinished<S2SV_blank>string<S2SV_blank>in<S2SV_blank>data"" ) ; size = ( e - ( data + pos ) ) + 1 ; lua_pushlstring ( L , data + pos , size - 1 ) ; n ++ ; break ; } default : controloptions ( L , opt , & fmt , & h ) ; } pos += size ; } lua_pushinteger ( L , pos + 1 ) ; return n + 1 ; }
","<S2SV_ModStart> , 1 ) ; luaL_argcheck ( L , pos > 0 , 3 , ""offset<S2SV_blank>must<S2SV_blank>be<S2SV_blank>1<S2SV_blank>or<S2SV_blank>greater"" ) ; pos -- <S2SV_ModEnd> ; int n <S2SV_ModStart> ( L , <S2SV_ModEnd> size <= ld <S2SV_ModStart> size <= ld && pos <= ld - size , <S2SV_ModEnd> 2 , ""data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short""
"
1037,"CWE-119 static int futex_wait ( u32 __user * uaddr , int fshared , u32 val , ktime_t * abs_time , u32 bitset , int clockrt ) { struct hrtimer_sleeper timeout , * to = NULL ; struct restart_block * restart ; struct futex_hash_bucket * hb ; struct futex_q q ; int ret ; if ( ! bitset ) return - EINVAL ; q . pi_state = NULL ; q . bitset = bitset ; q . rt_waiter = NULL ; q . requeue_pi_key = NULL ; if ( abs_time ) { to = & timeout ; hrtimer_init_on_stack ( & to -> timer , clockrt ? CLOCK_REALTIME : CLOCK_MONOTONIC , HRTIMER_MODE_ABS ) ; hrtimer_init_sleeper ( to , current ) ; hrtimer_set_expires_range_ns ( & to -> timer , * abs_time , current -> timer_slack_ns ) ; } retry : ret = futex_wait_setup ( uaddr , val , fshared , & q , & hb ) ; if ( ret ) goto out ; futex_wait_queue_me ( hb , & q , to ) ; ret = 0 ; if ( ! unqueue_me ( & q ) ) <S2SV_StartBug> goto out_put_key ; <S2SV_EndBug> ret = - ETIMEDOUT ; if ( to && ! to -> task ) <S2SV_StartBug> goto out_put_key ; <S2SV_EndBug> <S2SV_StartBug> if ( ! signal_pending ( current ) ) { <S2SV_EndBug> put_futex_key ( fshared , & q . key ) ; goto retry ; <S2SV_StartBug> } <S2SV_EndBug> ret = - ERESTARTSYS ; if ( ! abs_time ) <S2SV_StartBug> goto out_put_key ; <S2SV_EndBug> restart = & current_thread_info ( ) -> restart_block ; restart -> fn = futex_wait_restart ; restart -> futex . uaddr = ( u32 * ) uaddr ; restart -> futex . val = val ; restart -> futex . time = abs_time -> tv64 ; restart -> futex . bitset = bitset ; restart -> futex . flags = FLAGS_HAS_TIMEOUT ; if ( fshared ) restart -> futex . flags |= FLAGS_SHARED ; if ( clockrt ) restart -> futex . flags |= FLAGS_CLOCKRT ; ret = - ERESTART_RESTARTBLOCK ; <S2SV_StartBug> out_put_key : <S2SV_EndBug> put_futex_key ( fshared , & q . key ) ; out : if ( to ) { hrtimer_cancel ( & to -> timer ) ; destroy_hrtimer_on_stack ( & to -> timer ) ; } return ret ; }
","<S2SV_ModStart> ) ) goto out <S2SV_ModEnd> ; ret = <S2SV_ModStart> task ) goto out <S2SV_ModEnd> ; if ( <S2SV_ModStart> current ) ) <S2SV_ModEnd> goto retry ; <S2SV_ModStart> goto retry ; <S2SV_ModEnd> ret = - <S2SV_ModStart> abs_time ) goto out <S2SV_ModEnd> ; restart = <S2SV_ModStart> - ERESTART_RESTARTBLOCK ; <S2SV_ModEnd> out : if
"
1038,"CWE-787 static int gtStripContig ( TIFFRGBAImage * img , uint32 * raster , uint32 w , uint32 h ) { TIFF * tif = img -> tif ; tileContigRoutine put = img -> put . contig ; uint32 row , y , nrow , nrowsub , rowstoread ; tmsize_t pos ; unsigned char * buf = NULL ; uint32 rowsperstrip ; uint16 subsamplinghor , subsamplingver ; uint32 imagewidth = img -> width ; tmsize_t scanline ; int32 fromskew , toskew ; int ret = 1 , flip ; tmsize_t maxstripsize ; TIFFGetFieldDefaulted ( tif , TIFFTAG_YCBCRSUBSAMPLING , & subsamplinghor , & subsamplingver ) ; if ( subsamplingver == 0 ) { TIFFErrorExt ( tif -> tif_clientdata , TIFFFileName ( tif ) , ""Invalid<S2SV_blank>vertical<S2SV_blank>YCbCr<S2SV_blank>subsampling"" ) ; return ( 0 ) ; } maxstripsize = TIFFStripSize ( tif ) ; flip = setorientation ( img ) ; if ( flip & FLIP_VERTICALLY ) { y = h - 1 ; toskew = - ( int32 ) ( w + w ) ; } else { y = 0 ; toskew = - ( int32 ) ( w - w ) ; } TIFFGetFieldDefaulted ( tif , TIFFTAG_ROWSPERSTRIP , & rowsperstrip ) ; scanline = TIFFScanlineSize ( tif ) ; fromskew = ( w < imagewidth ? imagewidth - w : 0 ) ; for ( row = 0 ; row < h ; row += nrow ) <S2SV_StartBug> { <S2SV_EndBug> rowstoread = rowsperstrip - ( row + img -> row_offset ) % rowsperstrip ; nrow = ( row + rowstoread > h ? h - row : rowstoread ) ; nrowsub = nrow ; if ( ( nrowsub % subsamplingver ) != 0 ) nrowsub += subsamplingver - nrowsub % subsamplingver ; <S2SV_StartBug> if ( _TIFFReadEncodedStripAndAllocBuffer ( tif , <S2SV_EndBug> TIFFComputeStrip ( tif , row + img -> row_offset , 0 ) , ( void * * ) ( & buf ) , maxstripsize , <S2SV_StartBug> ( ( row + img -> row_offset ) % rowsperstrip + nrowsub ) * scanline ) == ( tmsize_t ) ( - 1 ) <S2SV_EndBug> && ( buf == NULL || img -> stoponerr ) ) { ret = 0 ; break ; } pos = ( ( row + img -> row_offset ) % rowsperstrip ) * scanline + ( ( tmsize_t ) img -> col_offset * img -> samplesperpixel ) ; ( * put ) ( img , raster + y * w , 0 , y , w , nrow , fromskew , toskew , buf + pos ) ; y += ( ( flip & FLIP_VERTICALLY ) ? - ( int32 ) nrow : ( int32 ) nrow ) ; } if ( flip & FLIP_HORIZONTALLY ) { uint32 line ; for ( line = 0 ; line < h ; line ++ ) { uint32 * left = raster + ( line * w ) ; uint32 * right = left + w - 1 ; while ( left < right ) { uint32 temp = * left ; * left = * right ; * right = temp ; left ++ ; right -- ; } } } _TIFFfree ( buf ) ; return ( ret ) ; }
","<S2SV_ModStart> nrow ) { uint32 temp ; <S2SV_ModStart> % subsamplingver ; temp = ( row + img -> row_offset ) % rowsperstrip + nrowsub ; if ( scanline > 0 && temp > ( size_t ) ( TIFF_TMSIZE_T_MAX / scanline ) ) { TIFFErrorExt ( tif -> tif_clientdata , TIFFFileName ( tif ) , ""Integer<S2SV_blank>overflow<S2SV_blank>in<S2SV_blank>gtStripContig"" ) ; return 0 ; } <S2SV_ModStart> , maxstripsize , temp <S2SV_ModEnd> * scanline )
"
1039,"CWE-119 <S2SV_StartBug> static int read_frame_stats ( const struct twopass_rc * p , <S2SV_EndBug> FIRSTPASS_STATS * frame_stats , int offset ) { <S2SV_StartBug> const FIRSTPASS_STATS * fps_ptr = p -> stats_in ; <S2SV_EndBug> <S2SV_StartBug> if ( offset >= 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( & fps_ptr [ offset ] >= p -> stats_in_end ) <S2SV_EndBug> return EOF ; <S2SV_StartBug> } else if ( offset < 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( & fps_ptr [ offset ] < p -> stats_in_start ) <S2SV_EndBug> return EOF ; } * frame_stats = fps_ptr [ offset ] ; <S2SV_StartBug> return 1 ; <S2SV_EndBug> }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static const FIRSTPASS_STATS * <S2SV_ModEnd> read_frame_stats ( const <S2SV_ModStart> read_frame_stats ( const TWO_PASS * p <S2SV_ModEnd> , int offset <S2SV_ModStart> offset ) { if ( <S2SV_ModEnd> ( offset >= <S2SV_ModStart> offset >= 0 && p -> stats_in + offset <S2SV_ModEnd> >= p -> <S2SV_ModStart> -> stats_in_end ) || <S2SV_ModEnd> ( offset < <S2SV_ModStart> offset < 0 && p -> stats_in + offset <S2SV_ModEnd> < p -> <S2SV_ModStart> -> stats_in_start ) ) { return NULL ; } return & p -> stats_in <S2SV_ModEnd> [ offset ] <S2SV_ModStart> offset ] ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
"
1040,"CWE-125 static arguments_ty ast_for_arguments ( struct compiling * c , const node * n ) { int i , j , k , nposargs = 0 , nkwonlyargs = 0 ; int nposdefaults = 0 , found_default = 0 ; asdl_seq * posargs , * posdefaults , * kwonlyargs , * kwdefaults ; arg_ty vararg = NULL , kwarg = NULL ; arg_ty arg ; node * ch ; if ( TYPE ( n ) == parameters ) { if ( NCH ( n ) == 2 ) return arguments ( NULL , NULL , NULL , NULL , NULL , NULL , c -> c_arena ) ; n = CHILD ( n , 1 ) ; } assert ( TYPE ( n ) == typedargslist || TYPE ( n ) == varargslist ) ; for ( i = 0 ; i < NCH ( n ) ; i ++ ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == STAR ) { i ++ ; if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { i ++ ; } break ; } if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == vfpdef || TYPE ( ch ) == tfpdef ) nposargs ++ ; if ( TYPE ( ch ) == EQUAL ) nposdefaults ++ ; } for ( ; i < NCH ( n ) ; ++ i ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) nkwonlyargs ++ ; } posargs = ( nposargs ? _Ta3_asdl_seq_new ( nposargs , c -> c_arena ) : NULL ) ; if ( ! posargs && nposargs ) return NULL ; kwonlyargs = ( nkwonlyargs ? _Ta3_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ; if ( ! kwonlyargs && nkwonlyargs ) return NULL ; posdefaults = ( nposdefaults ? _Ta3_asdl_seq_new ( nposdefaults , c -> c_arena ) : NULL ) ; if ( ! posdefaults && nposdefaults ) return NULL ; kwdefaults = ( nkwonlyargs ? _Ta3_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ; if ( ! kwdefaults && nkwonlyargs ) return NULL ; <S2SV_StartBug> if ( nposargs + nkwonlyargs > 255 ) { <S2SV_EndBug> ast_error ( c , n , ""more<S2SV_blank>than<S2SV_blank>255<S2SV_blank>arguments"" ) ; return NULL ; } i = 0 ; j = 0 ; k = 0 ; while ( i < NCH ( n ) ) { ch = CHILD ( n , i ) ; switch ( TYPE ( ch ) ) { case tfpdef : case vfpdef : if ( i + 1 < NCH ( n ) && TYPE ( CHILD ( n , i + 1 ) ) == EQUAL ) { expr_ty expression = ast_for_expr ( c , CHILD ( n , i + 2 ) ) ; if ( ! expression ) return NULL ; assert ( posdefaults != NULL ) ; asdl_seq_SET ( posdefaults , j ++ , expression ) ; i += 2 ; found_default = 1 ; } else if ( found_default ) { ast_error ( c , n , ""non-default<S2SV_blank>argument<S2SV_blank>follows<S2SV_blank>default<S2SV_blank>argument"" ) ; return NULL ; } arg = ast_for_arg ( c , ch ) ; if ( ! arg ) return NULL ; asdl_seq_SET ( posargs , k ++ , arg ) ; i += 1 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; break ; case STAR : if ( i + 1 >= NCH ( n ) || ( i + 2 == NCH ( n ) && ( TYPE ( CHILD ( n , i + 1 ) ) == COMMA || TYPE ( CHILD ( n , i + 1 ) ) == TYPE_COMMENT ) ) ) { ast_error ( c , CHILD ( n , i ) , ""named<S2SV_blank>arguments<S2SV_blank>must<S2SV_blank>follow<S2SV_blank>bare<S2SV_blank>*"" ) ; return NULL ; } ch = CHILD ( n , i + 1 ) ; if ( TYPE ( ch ) == COMMA ) { int res = 0 ; i += 2 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { <S2SV_EndBug> ast_error ( c , CHILD ( n , i ) , ""bare<S2SV_blank>*<S2SV_blank>has<S2SV_blank>associated<S2SV_blank>type<S2SV_blank>comment"" ) ; return NULL ; } res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } else { vararg = ast_for_arg ( c , ch ) ; if ( ! vararg ) return NULL ; i += 2 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { <S2SV_EndBug> vararg -> type_comment = NEW_TYPE_COMMENT ( CHILD ( n , i ) ) ; i += 1 ; } if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { int res = 0 ; res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } } break ; case DOUBLESTAR : ch = CHILD ( n , i + 1 ) ; assert ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) ; kwarg = ast_for_arg ( c , ch ) ; if ( ! kwarg ) return NULL ; i += 2 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; break ; case TYPE_COMMENT : assert ( i ) ; if ( kwarg ) arg = kwarg ; arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; i += 1 ; break ; default : PyErr_Format ( PyExc_SystemError , ""unexpected<S2SV_blank>node<S2SV_blank>in<S2SV_blank>varargslist:<S2SV_blank>%d<S2SV_blank>@<S2SV_blank>%d"" , TYPE ( ch ) , i ) ; return NULL ; } } return arguments ( posargs , vararg , kwonlyargs , kwdefaults , kwarg , posdefaults , c -> c_arena ) ; }
","<S2SV_ModStart> return NULL ; <S2SV_ModEnd> i = 0 <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD
"
1041,"CWE-119 static int iscsi_add_notunderstood_response ( char * key , char * value , struct iscsi_param_list * param_list ) { struct iscsi_extra_response * extra_response ; if ( strlen ( value ) > VALUE_MAXLEN ) { pr_err ( ""Value<S2SV_blank>for<S2SV_blank>notunderstood<S2SV_blank>key<S2SV_blank>\\""%s\\""<S2SV_blank>exceeds<S2SV_blank>%d,"" ""<S2SV_blank>protocol<S2SV_blank>error.\\n"" , key , VALUE_MAXLEN ) ; return - 1 ; } extra_response = kzalloc ( sizeof ( struct iscsi_extra_response ) , GFP_KERNEL ) ; if ( ! extra_response ) { pr_err ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for"" ""<S2SV_blank>struct<S2SV_blank>iscsi_extra_response.\\n"" ) ; return - 1 ; } INIT_LIST_HEAD ( & extra_response -> er_list ) ; <S2SV_StartBug> strncpy ( extra_response -> key , key , strlen ( key ) + 1 ) ; <S2SV_EndBug> strncpy ( extra_response -> value , NOTUNDERSTOOD , <S2SV_StartBug> strlen ( NOTUNDERSTOOD ) + 1 ) ; <S2SV_EndBug> list_add_tail ( & extra_response -> er_list , & param_list -> extra_response_list ) ; return 0 ; }
","<S2SV_ModStart> er_list ) ; strlcpy <S2SV_ModEnd> ( extra_response -> <S2SV_ModStart> , key , sizeof ( extra_response -> key ) ) ; strlcpy <S2SV_ModEnd> ( extra_response -> <S2SV_ModStart> , NOTUNDERSTOOD , sizeof ( extra_response -> value ) <S2SV_ModEnd> ) ; list_add_tail
"
1042,"CWE-399 void hugetlb_unreserve_pages ( struct inode * inode , long offset , long freed ) { struct hstate * h = hstate_inode ( inode ) ; long chg = region_truncate ( & inode -> i_mapping -> private_list , offset ) ; <S2SV_StartBug> spin_lock ( & inode -> i_lock ) ; <S2SV_EndBug> inode -> i_blocks -= ( blocks_per_huge_page ( h ) * freed ) ; spin_unlock ( & inode -> i_lock ) ; <S2SV_StartBug> hugetlb_put_quota ( inode -> i_mapping , ( chg - freed ) ) ; <S2SV_EndBug> hugetlb_acct_memory ( h , - ( chg - freed ) ) ; }
","<S2SV_ModStart> offset ) ; struct hugepage_subpool * spool = subpool_inode ( inode ) ; <S2SV_ModStart> i_lock ) ; hugepage_subpool_put_pages ( spool <S2SV_ModEnd> , ( chg
"
1043,"CWE-000 void bnep_net_setup ( struct net_device * dev ) { memset ( dev -> broadcast , 0xff , ETH_ALEN ) ; dev -> addr_len = ETH_ALEN ; ether_setup ( dev ) ; <S2SV_StartBug> dev -> netdev_ops = & bnep_netdev_ops ; <S2SV_EndBug> dev -> watchdog_timeo = HZ * 2 ; }
","<S2SV_ModStart> ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev ->
"
1044,"CWE-119 static inline void schedule_debug ( struct task_struct * prev ) { # ifdef CONFIG_SCHED_STACK_END_CHECK <S2SV_StartBug> BUG_ON ( task_stack_end_corrupted ( prev ) ) ; <S2SV_EndBug> # endif if ( unlikely ( in_atomic_preempt_off ( ) ) ) { __schedule_bug ( prev ) ; preempt_count_set ( PREEMPT_DISABLED ) ; } rcu_sleep_check ( ) ; profile_hit ( SCHED_PROFILING , __builtin_return_address ( 0 ) ) ; schedstat_inc ( this_rq ( ) , sched_count ) ; }
","<S2SV_ModStart> # ifdef CONFIG_SCHED_STACK_END_CHECK if <S2SV_ModEnd> ( task_stack_end_corrupted ( <S2SV_ModStart> ( prev ) ) panic ( ""corrupted<S2SV_blank>stack<S2SV_blank>end<S2SV_blank>detected<S2SV_blank>inside<S2SV_blank>scheduler\\n""
"
1045,"CWE-119 static Image * ReadFITSImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { typedef struct _FITSInfo { MagickBooleanType extend , simple ; int bits_per_pixel , columns , rows , number_axes , number_planes ; double min_data , max_data , zero , scale ; EndianType endian ; } FITSInfo ; char * comment , keyword [ 9 ] , property [ MaxTextExtent ] , value [ 73 ] ; double pixel , scale ; FITSInfo fits_info ; Image * image ; int c ; MagickBooleanType status ; MagickSizeType number_pixels ; register ssize_t i , x ; register PixelPacket * q ; ssize_t count , scene , y ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & fits_info , 0 , sizeof ( fits_info ) ) ; fits_info . extend = MagickFalse ; fits_info . simple = MagickFalse ; fits_info . bits_per_pixel = 8 ; fits_info . columns = 1 ; fits_info . rows = 1 ; fits_info . rows = 1 ; fits_info . number_planes = 1 ; fits_info . min_data = 0.0 ; fits_info . max_data = 0.0 ; fits_info . zero = 0.0 ; fits_info . scale = 1.0 ; fits_info . endian = MSBEndian ; for ( comment = ( char * ) NULL ; EOFBlob ( image ) == MagickFalse ; ) { for ( ; EOFBlob ( image ) == MagickFalse ; ) { register char * p ; count = ReadBlob ( image , 8 , ( unsigned char * ) keyword ) ; if ( count != 8 ) break ; for ( i = 0 ; i < 8 ; i ++ ) { if ( isspace ( ( int ) ( ( unsigned char ) keyword [ i ] ) ) != 0 ) break ; keyword [ i ] = tolower ( ( int ) ( ( unsigned char ) keyword [ i ] ) ) ; } keyword [ i ] = '\\0' ; count = ReadBlob ( image , 72 , ( unsigned char * ) value ) ; value [ 72 ] = '\\0' ; if ( count != 72 ) break ; p = value ; if ( * p == '=' ) { p += 2 ; while ( isspace ( ( int ) ( ( unsigned char ) * p ) ) != 0 ) p ++ ; } if ( LocaleCompare ( keyword , ""end"" ) == 0 ) break ; if ( LocaleCompare ( keyword , ""extend"" ) == 0 ) fits_info . extend = ( * p == 'T' ) || ( * p == 't' ) ? MagickTrue : MagickFalse ; if ( LocaleCompare ( keyword , ""simple"" ) == 0 ) fits_info . simple = ( * p == 'T' ) || ( * p == 't' ) ? MagickTrue : MagickFalse ; if ( LocaleCompare ( keyword , ""bitpix"" ) == 0 ) fits_info . bits_per_pixel = StringToLong ( p ) ; if ( LocaleCompare ( keyword , ""naxis"" ) == 0 ) fits_info . number_axes = StringToLong ( p ) ; if ( LocaleCompare ( keyword , ""naxis1"" ) == 0 ) fits_info . columns = StringToLong ( p ) ; if ( LocaleCompare ( keyword , ""naxis2"" ) == 0 ) fits_info . rows = StringToLong ( p ) ; if ( LocaleCompare ( keyword , ""naxis3"" ) == 0 ) fits_info . number_planes = StringToLong ( p ) ; if ( LocaleCompare ( keyword , ""datamax"" ) == 0 ) fits_info . max_data = StringToDouble ( p , ( char * * ) NULL ) ; if ( LocaleCompare ( keyword , ""datamin"" ) == 0 ) fits_info . min_data = StringToDouble ( p , ( char * * ) NULL ) ; if ( LocaleCompare ( keyword , ""bzero"" ) == 0 ) fits_info . zero = StringToDouble ( p , ( char * * ) NULL ) ; if ( LocaleCompare ( keyword , ""bscale"" ) == 0 ) fits_info . scale = StringToDouble ( p , ( char * * ) NULL ) ; if ( LocaleCompare ( keyword , ""comment"" ) == 0 ) { if ( comment == ( char * ) NULL ) comment = ConstantString ( p ) ; else ( void ) ConcatenateString ( & comment , p ) ; } if ( LocaleCompare ( keyword , ""xendian"" ) == 0 ) { if ( LocaleNCompare ( p , ""big"" , 3 ) == 0 ) fits_info . endian = MSBEndian ; else fits_info . endian = LSBEndian ; } ( void ) FormatLocaleString ( property , MaxTextExtent , ""fits:%s"" , keyword ) ; ( void ) SetImageProperty ( image , property , p ) ; } c = 0 ; while ( ( ( TellBlob ( image ) % FITSBlocksize ) != 0 ) && ( c != EOF ) ) c = ReadBlobByte ( image ) ; if ( fits_info . extend == MagickFalse ) break ; number_pixels = ( MagickSizeType ) fits_info . columns * fits_info . rows ; if ( ( fits_info . simple != MagickFalse ) && ( fits_info . number_axes >= 1 ) && ( fits_info . number_axes <= 4 ) && ( number_pixels != 0 ) ) break ; } if ( comment != ( char * ) NULL ) { ( void ) SetImageProperty ( image , ""comment"" , comment ) ; comment = DestroyString ( comment ) ; } if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; number_pixels = ( MagickSizeType ) fits_info . columns * fits_info . rows ; if ( ( fits_info . simple == MagickFalse ) || ( fits_info . number_axes < 1 ) || ( fits_info . number_axes > 4 ) || ( number_pixels == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImageTypeNotSupported"" ) ; for ( scene = 0 ; scene < ( ssize_t ) fits_info . number_planes ; scene ++ ) { image -> columns = ( size_t ) fits_info . columns ; image -> rows = ( size_t ) fits_info . rows ; image -> depth = ( size_t ) ( fits_info . bits_per_pixel < 0 ? - 1 : 1 ) * fits_info . bits_per_pixel ; image -> endian = fits_info . endian ; image -> scene = ( size_t ) scene ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; <S2SV_StartBug> ( void ) SetImageColorspace ( image , GRAYColorspace ) ; <S2SV_EndBug> if ( ( fits_info . min_data == 0.0 ) && ( fits_info . max_data == 0.0 ) ) { if ( fits_info . zero == 0.0 ) ( void ) GetFITSPixelExtrema ( image , fits_info . bits_per_pixel , & fits_info . min_data , & fits_info . max_data ) ; else fits_info . max_data = GetFITSPixelRange ( ( size_t ) fits_info . bits_per_pixel ) ; } else fits_info . max_data = GetFITSPixelRange ( ( size_t ) fits_info . bits_per_pixel ) ; scale = QuantumRange / ( fits_info . max_data - fits_info . min_data ) ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { pixel = GetFITSPixel ( image , fits_info . bits_per_pixel ) ; if ( ( image -> depth == 16 ) || ( image -> depth == 32 ) || ( image -> depth == 64 ) ) SetFITSUnsignedPixels ( 1 , image -> depth , image -> endian , ( unsigned char * ) & pixel ) ; SetPixelRed ( q , ClampToQuantum ( scale * ( fits_info . scale * ( pixel - fits_info . min_data ) + fits_info . zero ) ) ) ; SetPixelGreen ( q , GetPixelRed ( q ) ) ; SetPixelBlue ( q , GetPixelRed ( q ) ) ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( scene < ( ssize_t ) ( fits_info . number_planes - 1 ) ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
"
1046,"CWE-119 static BOOL rdp_read_font_capability_set ( wStream * s , UINT16 length , rdpSettings * settings ) { WINPR_UNUSED ( settings ) ; <S2SV_StartBug> if ( length > 4 ) <S2SV_EndBug> Stream_Seek_UINT16 ( s ) ; <S2SV_StartBug> if ( length > 6 ) <S2SV_EndBug> Stream_Seek_UINT16 ( s ) ; return TRUE ; }
","<S2SV_ModStart> ( length > 5 <S2SV_ModEnd> ) Stream_Seek_UINT16 ( <S2SV_ModStart> ( length > 7 <S2SV_ModEnd> ) Stream_Seek_UINT16 (
"
1047,"CWE-190 static BOOL gdi_Bitmap_Decompress ( rdpContext * context , rdpBitmap * bitmap , const BYTE * pSrcData , UINT32 DstWidth , UINT32 DstHeight , UINT32 bpp , UINT32 length , BOOL compressed , UINT32 codecId ) { UINT32 SrcSize = length ; rdpGdi * gdi = context -> gdi ; <S2SV_StartBug> bitmap -> compressed = FALSE ; <S2SV_EndBug> bitmap -> format = gdi -> dstFormat ; <S2SV_StartBug> bitmap -> length = DstWidth * DstHeight * GetBytesPerPixel ( bitmap -> format ) ; <S2SV_EndBug> bitmap -> data = ( BYTE * ) _aligned_malloc ( bitmap -> length , 16 ) ; if ( ! bitmap -> data ) return FALSE ; if ( compressed ) { if ( bpp < 32 ) { if ( ! interleaved_decompress ( context -> codecs -> interleaved , pSrcData , SrcSize , DstWidth , DstHeight , bpp , bitmap -> data , bitmap -> format , 0 , 0 , 0 , DstWidth , DstHeight , & gdi -> palette ) ) return FALSE ; } else { if ( ! planar_decompress ( context -> codecs -> planar , pSrcData , SrcSize , DstWidth , DstHeight , bitmap -> data , bitmap -> format , 0 , 0 , 0 , DstWidth , DstHeight , TRUE ) ) return FALSE ; } } else { const UINT32 SrcFormat = gdi_get_pixel_format ( bpp ) ; const size_t sbpp = GetBytesPerPixel ( SrcFormat ) ; const size_t dbpp = GetBytesPerPixel ( bitmap -> format ) ; if ( ( sbpp == 0 ) || ( dbpp == 0 ) ) return FALSE ; else { const size_t dstSize = SrcSize * dbpp / sbpp ; if ( dstSize < bitmap -> length ) return FALSE ; } if ( ! freerdp_image_copy ( bitmap -> data , bitmap -> format , 0 , 0 , 0 , DstWidth , DstHeight , pSrcData , SrcFormat , 0 , 0 , 0 , & gdi -> palette , FREERDP_FLIP_VERTICAL ) ) return FALSE ; } return TRUE ; }
","<S2SV_ModStart> -> gdi ; UINT32 size = DstWidth * DstHeight ; <S2SV_ModStart> -> dstFormat ; if ( ( GetBytesPerPixel ( bitmap -> format ) == 0 ) || ( DstWidth == 0 ) || ( DstHeight == 0 ) || ( DstWidth > UINT32_MAX / DstHeight ) || ( size > ( UINT32_MAX / GetBytesPerPixel ( bitmap -> format ) ) ) ) return FALSE ; size *= GetBytesPerPixel ( bitmap -> format ) ; <S2SV_ModStart> -> length = size <S2SV_ModEnd> ; bitmap ->
"
1048,"CWE-119 void vp9_encode_sb ( MACROBLOCK * x , BLOCK_SIZE bsize ) { MACROBLOCKD * const xd = & x -> e_mbd ; struct optimize_ctx ctx ; MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ; struct encode_b_args arg = { x , & ctx , & mbmi -> skip } ; int plane ; <S2SV_StartBug> for ( plane = 0 ; plane < MAX_MB_PLANE ; ++ plane ) { <S2SV_EndBug> if ( ! x -> skip_recode ) vp9_subtract_plane ( x , bsize , plane ) ; if ( x -> optimize && ( ! x -> skip_recode || ! x -> skip_optimize ) ) { const struct macroblockd_plane * const pd = & xd -> plane [ plane ] ; <S2SV_StartBug> const TX_SIZE tx_size = plane ? get_uv_tx_size ( mbmi ) : mbmi -> tx_size ; <S2SV_EndBug> vp9_get_entropy_contexts ( bsize , tx_size , pd , ctx . ta [ plane ] , ctx . tl [ plane ] ) ; } vp9_foreach_transformed_block_in_plane ( xd , bsize , plane , encode_block , & arg ) ; } }
","<S2SV_ModStart> int plane ; mbmi -> skip = 1 ; if ( x -> skip ) return ; <S2SV_ModStart> get_uv_tx_size ( mbmi , pd
"
1049,"CWE-125 static int ape_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) { AVFrame * frame = data ; const uint8_t * buf = avpkt -> data ; APEContext * s = avctx -> priv_data ; uint8_t * sample8 ; int16_t * sample16 ; int32_t * sample24 ; int i , ch , ret ; <S2SV_StartBug> int blockstodecode ; <S2SV_EndBug> av_assert0 ( s -> samples >= 0 ) ; if ( ! s -> samples ) { uint32_t nblocks , offset ; int buf_size ; if ( ! avpkt -> size ) { * got_frame_ptr = 0 ; return 0 ; } if ( avpkt -> size < 8 ) { av_log ( avctx , AV_LOG_ERROR , ""Packet<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small\\n"" ) ; return AVERROR_INVALIDDATA ; } buf_size = avpkt -> size & ~ 3 ; if ( buf_size != avpkt -> size ) { av_log ( avctx , AV_LOG_WARNING , ""packet<S2SV_blank>size<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4.<S2SV_blank>"" ""extra<S2SV_blank>bytes<S2SV_blank>at<S2SV_blank>the<S2SV_blank>end<S2SV_blank>will<S2SV_blank>be<S2SV_blank>skipped.\\n"" ) ; } if ( s -> fileversion < 3950 ) buf_size += 2 ; av_fast_padded_malloc ( & s -> data , & s -> data_size , buf_size ) ; if ( ! s -> data ) return AVERROR ( ENOMEM ) ; s -> bdsp . bswap_buf ( ( uint32_t * ) s -> data , ( const uint32_t * ) buf , buf_size >> 2 ) ; memset ( s -> data + ( buf_size & ~ 3 ) , 0 , buf_size & 3 ) ; s -> ptr = s -> data ; s -> data_end = s -> data + buf_size ; nblocks = bytestream_get_be32 ( & s -> ptr ) ; offset = bytestream_get_be32 ( & s -> ptr ) ; if ( s -> fileversion >= 3900 ) { if ( offset > 3 ) { av_log ( avctx , AV_LOG_ERROR , ""Incorrect<S2SV_blank>offset<S2SV_blank>passed\\n"" ) ; s -> data = NULL ; return AVERROR_INVALIDDATA ; } if ( s -> data_end - s -> ptr < offset ) { av_log ( avctx , AV_LOG_ERROR , ""Packet<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small\\n"" ) ; return AVERROR_INVALIDDATA ; } s -> ptr += offset ; } else { if ( ( ret = init_get_bits8 ( & s -> gb , s -> ptr , s -> data_end - s -> ptr ) ) < 0 ) return ret ; if ( s -> fileversion > 3800 ) skip_bits_long ( & s -> gb , offset * 8 ) ; else skip_bits_long ( & s -> gb , offset ) ; } <S2SV_StartBug> if ( ! nblocks || nblocks > INT_MAX ) { <S2SV_EndBug> av_log ( avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>sample<S2SV_blank>count:<S2SV_blank>%"" PRIu32 "".\\n"" , nblocks ) ; return AVERROR_INVALIDDATA ; } if ( init_frame_decoder ( s ) < 0 ) { av_log ( avctx , AV_LOG_ERROR , ""Error<S2SV_blank>reading<S2SV_blank>frame<S2SV_blank>header\\n"" ) ; return AVERROR_INVALIDDATA ; } s -> samples = nblocks ; } if ( ! s -> data ) { * got_frame_ptr = 0 ; return avpkt -> size ; } blockstodecode = FFMIN ( s -> blocks_per_loop , s -> samples ) ; if ( s -> fileversion < 3930 ) blockstodecode = s -> samples ; <S2SV_StartBug> av_fast_malloc ( & s -> decoded_buffer , & s -> decoded_size , <S2SV_EndBug> <S2SV_StartBug> 2 * FFALIGN ( blockstodecode , 8 ) * sizeof ( * s -> decoded_buffer ) ) ; <S2SV_EndBug> if ( ! s -> decoded_buffer ) return AVERROR ( ENOMEM ) ; memset ( s -> decoded_buffer , 0 , s -> decoded_size ) ; s -> decoded [ 0 ] = s -> decoded_buffer ; s -> decoded [ 1 ] = s -> decoded_buffer + FFALIGN ( blockstodecode , 8 ) ; frame -> nb_samples = blockstodecode ; if ( ( ret = ff_get_buffer ( avctx , frame , 0 ) ) < 0 ) return ret ; s -> error = 0 ; if ( ( s -> channels == 1 ) || ( s -> frameflags & APE_FRAMECODE_PSEUDO_STEREO ) ) ape_unpack_mono ( s , blockstodecode ) ; else ape_unpack_stereo ( s , blockstodecode ) ; emms_c ( ) ; if ( s -> error ) { s -> samples = 0 ; av_log ( avctx , AV_LOG_ERROR , ""Error<S2SV_blank>decoding<S2SV_blank>frame\\n"" ) ; return AVERROR_INVALIDDATA ; } switch ( s -> bps ) { case 8 : for ( ch = 0 ; ch < s -> channels ; ch ++ ) { sample8 = ( uint8_t * ) frame -> data [ ch ] ; for ( i = 0 ; i < blockstodecode ; i ++ ) * sample8 ++ = ( s -> decoded [ ch ] [ i ] + 0x80 ) & 0xff ; } break ; case 16 : for ( ch = 0 ; ch < s -> channels ; ch ++ ) { sample16 = ( int16_t * ) frame -> data [ ch ] ; for ( i = 0 ; i < blockstodecode ; i ++ ) * sample16 ++ = s -> decoded [ ch ] [ i ] ; } break ; case 24 : for ( ch = 0 ; ch < s -> channels ; ch ++ ) { sample24 = ( int32_t * ) frame -> data [ ch ] ; for ( i = 0 ; i < blockstodecode ; i ++ ) * sample24 ++ = s -> decoded [ ch ] [ i ] << 8 ; } break ; } s -> samples -= blockstodecode ; * got_frame_ptr = 1 ; return ! s -> samples ? avpkt -> size : 0 ; }
","<S2SV_ModStart> ; int blockstodecode ; uint64_t decoded_buffer_size <S2SV_ModStart> nblocks > INT_MAX / 2 / sizeof ( * s -> decoded_buffer ) - 8 <S2SV_ModStart> -> samples ; decoded_buffer_size = 2LL * FFALIGN ( blockstodecode , 8 ) * sizeof ( * s -> decoded_buffer ) ; av_assert0 ( decoded_buffer_size <= INT_MAX ) ; <S2SV_ModStart> -> decoded_size , decoded_buffer_size <S2SV_ModEnd> ) ; if
"
1050,"CWE-20 void init_util ( void ) { filegen_register ( statsdir , ""peerstats"" , & peerstats ) ; filegen_register ( statsdir , ""loopstats"" , & loopstats ) ; filegen_register ( statsdir , ""clockstats"" , & clockstats ) ; filegen_register ( statsdir , ""rawstats"" , & rawstats ) ; filegen_register ( statsdir , ""sysstats"" , & sysstats ) ; filegen_register ( statsdir , ""protostats"" , & protostats ) ; <S2SV_StartBug> # ifdef AUTOKEY <S2SV_EndBug> filegen_register ( statsdir , ""cryptostats"" , & cryptostats ) ; <S2SV_StartBug> # endif <S2SV_EndBug> # ifdef DEBUG_TIMING filegen_register ( statsdir , ""timingstats"" , & timingstats ) ; <S2SV_StartBug> # endif <S2SV_EndBug> step_callback = & ntpd_time_stepped ; # ifdef DEBUG atexit ( & uninit_util ) ; # endif }
","<S2SV_ModStart> protostats ) ; <S2SV_ModEnd> filegen_register ( statsdir <S2SV_ModStart> cryptostats ) ; <S2SV_ModEnd> filegen_register ( statsdir <S2SV_ModStart> timingstats ) ; <S2SV_ModEnd> step_callback = &
"
1051,"CWE-125 static INT AirPDcapDecryptWPABroadcastKey ( const EAPOL_RSN_KEY * pEAPKey , guint8 * decryption_key , PAIRPDCAP_SEC_ASSOCIATION sa , guint eapol_len ) { guint8 key_version ; guint8 * key_data ; guint8 * szEncryptedKey ; guint16 key_bytes_len = 0 ; guint16 key_len ; static AIRPDCAP_KEY_ITEM dummy_key ; AIRPDCAP_SEC_ASSOCIATION * tmp_sa ; key_version = AIRPDCAP_EAP_KEY_DESCR_VER ( pEAPKey -> key_information [ 1 ] ) ; if ( key_version == AIRPDCAP_WPA_KEY_VER_NOT_CCMP ) { key_bytes_len = pntoh16 ( pEAPKey -> key_length ) ; } else if ( key_version == AIRPDCAP_WPA_KEY_VER_AES_CCMP ) { key_bytes_len = pntoh16 ( pEAPKey -> key_data_len ) ; if ( key_bytes_len < 16 ) { return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } } <S2SV_StartBug> if ( key_bytes_len < GROUP_KEY_MIN_LEN || key_bytes_len > eapol_len - sizeof ( EAPOL_RSN_KEY ) ) { <S2SV_EndBug> return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } key_data = ( guint8 * ) pEAPKey + sizeof ( EAPOL_RSN_KEY ) ; szEncryptedKey = ( guint8 * ) g_memdup ( key_data , key_bytes_len ) ; DEBUG_DUMP ( ""Encrypted<S2SV_blank>Broadcast<S2SV_blank>key:"" , szEncryptedKey , key_bytes_len ) ; DEBUG_DUMP ( ""KeyIV:"" , pEAPKey -> key_iv , 16 ) ; DEBUG_DUMP ( ""decryption_key:"" , decryption_key , 16 ) ; tmp_sa = ( AIRPDCAP_SEC_ASSOCIATION * ) g_malloc ( sizeof ( AIRPDCAP_SEC_ASSOCIATION ) ) ; memcpy ( tmp_sa , sa , sizeof ( AIRPDCAP_SEC_ASSOCIATION ) ) ; sa -> next = tmp_sa ; if ( key_version == AIRPDCAP_WPA_KEY_VER_NOT_CCMP ) { guint8 new_key [ 32 ] ; guint8 dummy [ 256 ] ; rc4_state_struct rc4_state ; sa -> wpa . key_ver = ( key_bytes_len >= TKIP_GROUP_KEY_LEN ) ? AIRPDCAP_WPA_KEY_VER_NOT_CCMP : AIRPDCAP_WPA_KEY_VER_AES_CCMP ; memcpy ( new_key , pEAPKey -> key_iv , 16 ) ; memcpy ( new_key + 16 , decryption_key , 16 ) ; DEBUG_DUMP ( ""FullDecrKey:"" , new_key , 32 ) ; crypt_rc4_init ( & rc4_state , new_key , sizeof ( new_key ) ) ; crypt_rc4 ( & rc4_state , dummy , 256 ) ; crypt_rc4 ( & rc4_state , szEncryptedKey , key_bytes_len ) ; } else if ( key_version == AIRPDCAP_WPA_KEY_VER_AES_CCMP ) { guint8 key_found ; guint8 key_length ; guint16 key_index ; guint8 * decrypted_data ; decrypted_data = AES_unwrap ( decryption_key , 16 , szEncryptedKey , key_bytes_len ) ; key_found = FALSE ; key_index = 0 ; while ( key_index < ( key_bytes_len - 6 ) && ! key_found ) { guint8 rsn_id ; guint32 type ; rsn_id = decrypted_data [ key_index ] ; type = ( ( decrypted_data [ key_index + 2 ] << 24 ) + ( decrypted_data [ key_index + 3 ] << 16 ) + ( decrypted_data [ key_index + 4 ] << 8 ) + ( decrypted_data [ key_index + 5 ] ) ) ; if ( rsn_id == 0xdd && type == 0x000fac01 ) { key_found = TRUE ; } else { key_index += decrypted_data [ key_index + 1 ] + 2 ; } } if ( key_found ) { key_length = decrypted_data [ key_index + 1 ] - 6 ; if ( key_index + 8 >= key_bytes_len || key_length > key_bytes_len - key_index - 8 ) { g_free ( decrypted_data ) ; g_free ( szEncryptedKey ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } memcpy ( szEncryptedKey , decrypted_data + key_index + 8 , key_length ) ; } else { g_free ( decrypted_data ) ; g_free ( szEncryptedKey ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } if ( key_length == TKIP_GROUP_KEY_LEN ) sa -> wpa . key_ver = AIRPDCAP_WPA_KEY_VER_NOT_CCMP ; else sa -> wpa . key_ver = AIRPDCAP_WPA_KEY_VER_AES_CCMP ; g_free ( decrypted_data ) ; } key_len = ( sa -> wpa . key_ver == AIRPDCAP_WPA_KEY_VER_NOT_CCMP ) ? TKIP_GROUP_KEY_LEN : CCMP_GROUP_KEY_LEN ; if ( key_len > key_bytes_len ) { g_free ( szEncryptedKey ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } DEBUG_DUMP ( ""Broadcast<S2SV_blank>key:"" , szEncryptedKey , key_len ) ; sa -> key = & dummy_key ; sa -> validKey = TRUE ; memset ( sa -> wpa . ptk , 0 , sizeof ( sa -> wpa . ptk ) ) ; memcpy ( sa -> wpa . ptk + 32 , szEncryptedKey , key_len ) ; g_free ( szEncryptedKey ) ; return AIRPDCAP_RET_SUCCESS_HANDSHAKE ; }
","<S2SV_ModStart> } if ( ( <S2SV_ModStart> key_bytes_len < GROUP_KEY_MIN_LEN ) || ( eapol_len < sizeof ( EAPOL_RSN_KEY ) ) || ( <S2SV_ModEnd> key_bytes_len > eapol_len <S2SV_ModStart> sizeof ( EAPOL_RSN_KEY )
"
1052,"CWE-000 int main ( int argc , char * argv [ ] ) { OM_uint32 minor , major ; gss_ctx_id_t context ; gss_union_ctx_id_desc uctx ; krb5_gss_ctx_id_rec kgctx ; krb5_key k1 , k2 ; krb5_keyblock kb1 , kb2 ; gss_buffer_desc in , out ; unsigned char k1buf [ 32 ] , k2buf [ 32 ] , outbuf [ 44 ] ; size_t i ; context = ( gss_ctx_id_t ) & uctx ; uctx . mech_type = & mech_krb5 ; uctx . internal_ctx_id = ( gss_ctx_id_t ) & kgctx ; kgctx . k5_context = NULL ; <S2SV_StartBug> kgctx . have_acceptor_subkey = 1 ; <S2SV_EndBug> kb1 . contents = k1buf ; kb2 . contents = k2buf ; for ( i = 0 ; i < sizeof ( tests ) / sizeof ( * tests ) ; i ++ ) { kb1 . enctype = tests [ i ] . enctype ; kb1 . length = fromhex ( tests [ i ] . key1 , k1buf ) ; check_k5err ( NULL , ""create_key"" , krb5_k_create_key ( NULL , & kb1 , & k1 ) ) ; kgctx . subkey = k1 ; kb2 . enctype = tests [ i ] . enctype ; kb2 . length = fromhex ( tests [ i ] . key2 , k2buf ) ; check_k5err ( NULL , ""create_key"" , krb5_k_create_key ( NULL , & kb2 , & k2 ) ) ; kgctx . acceptor_subkey = k2 ; in . length = 0 ; in . value = NULL ; major = gss_pseudo_random ( & minor , context , GSS_C_PRF_KEY_PARTIAL , & in , 44 , & out ) ; check_gsserr ( ""gss_pseudo_random"" , major , minor ) ; ( void ) fromhex ( tests [ i ] . out1 , outbuf ) ; assert ( out . length == 44 && memcmp ( out . value , outbuf , 44 ) == 0 ) ; ( void ) gss_release_buffer ( & minor , & out ) ; in . length = strlen ( inputstr ) ; in . value = ( char * ) inputstr ; major = gss_pseudo_random ( & minor , context , GSS_C_PRF_KEY_FULL , & in , 44 , & out ) ; check_gsserr ( ""gss_pseudo_random"" , major , minor ) ; ( void ) fromhex ( tests [ i ] . out2 , outbuf ) ; assert ( out . length == 44 && memcmp ( out . value , outbuf , 44 ) == 0 ) ; ( void ) gss_release_buffer ( & minor , & out ) ; major = gss_pseudo_random ( & minor , context , GSS_C_PRF_KEY_FULL , & in , 0 , & out ) ; check_gsserr ( ""gss_pseudo_random"" , major , minor ) ; assert ( out . length == 0 ) ; ( void ) gss_release_buffer ( & minor , & out ) ; krb5_k_free_key ( NULL , k1 ) ; krb5_k_free_key ( NULL , k2 ) ; } return 0 ; }
","<S2SV_ModStart> ; kgctx . established = 1 ; kgctx .
"
1053,"CWE-416 static struct page * follow_pmd_mask ( struct vm_area_struct * vma , unsigned long address , pud_t * pudp , unsigned int flags , struct follow_page_context * ctx ) { pmd_t * pmd , pmdval ; spinlock_t * ptl ; struct page * page ; struct mm_struct * mm = vma -> vm_mm ; pmd = pmd_offset ( pudp , address ) ; pmdval = READ_ONCE ( * pmd ) ; if ( pmd_none ( pmdval ) ) return no_page_table ( vma , flags ) ; if ( pmd_huge ( pmdval ) && vma -> vm_flags & VM_HUGETLB ) { page = follow_huge_pmd ( mm , address , pmd , flags ) ; if ( page ) return page ; return no_page_table ( vma , flags ) ; } if ( is_hugepd ( __hugepd ( pmd_val ( pmdval ) ) ) ) { page = follow_huge_pd ( vma , address , __hugepd ( pmd_val ( pmdval ) ) , flags , PMD_SHIFT ) ; if ( page ) return page ; return no_page_table ( vma , flags ) ; } retry : if ( ! pmd_present ( pmdval ) ) { if ( likely ( ! ( flags & FOLL_MIGRATION ) ) ) return no_page_table ( vma , flags ) ; VM_BUG_ON ( thp_migration_supported ( ) && ! is_pmd_migration_entry ( pmdval ) ) ; if ( is_pmd_migration_entry ( pmdval ) ) pmd_migration_entry_wait ( mm , pmd ) ; pmdval = READ_ONCE ( * pmd ) ; if ( pmd_none ( pmdval ) ) return no_page_table ( vma , flags ) ; goto retry ; } if ( pmd_devmap ( pmdval ) ) { ptl = pmd_lock ( mm , pmd ) ; page = follow_devmap_pmd ( vma , address , pmd , flags , & ctx -> pgmap ) ; spin_unlock ( ptl ) ; if ( page ) return page ; } if ( likely ( ! pmd_trans_huge ( pmdval ) ) ) return follow_page_pte ( vma , address , pmd , flags , & ctx -> pgmap ) ; if ( ( flags & FOLL_NUMA ) && pmd_protnone ( pmdval ) ) return no_page_table ( vma , flags ) ; retry_locked : ptl = pmd_lock ( mm , pmd ) ; if ( unlikely ( pmd_none ( * pmd ) ) ) { spin_unlock ( ptl ) ; return no_page_table ( vma , flags ) ; } if ( unlikely ( ! pmd_present ( * pmd ) ) ) { spin_unlock ( ptl ) ; if ( likely ( ! ( flags & FOLL_MIGRATION ) ) ) return no_page_table ( vma , flags ) ; pmd_migration_entry_wait ( mm , pmd ) ; goto retry_locked ; } if ( unlikely ( ! pmd_trans_huge ( * pmd ) ) ) { spin_unlock ( ptl ) ; return follow_page_pte ( vma , address , pmd , flags , & ctx -> pgmap ) ; } if ( flags & FOLL_SPLIT ) { int ret ; page = pmd_page ( * pmd ) ; if ( is_huge_zero_page ( page ) ) { spin_unlock ( ptl ) ; ret = 0 ; split_huge_pmd ( vma , pmd , address ) ; if ( pmd_trans_unstable ( pmd ) ) ret = - EBUSY ; } else { <S2SV_StartBug> get_page ( page ) ; <S2SV_EndBug> spin_unlock ( ptl ) ; lock_page ( page ) ; ret = split_huge_page ( page ) ; unlock_page ( page ) ; put_page ( page ) ; if ( pmd_none ( * pmd ) ) return no_page_table ( vma , flags ) ; } return ret ? ERR_PTR ( ret ) : follow_page_pte ( vma , address , pmd , flags , & ctx -> pgmap ) ; } page = follow_trans_huge_pmd ( vma , address , pmd , flags ) ; spin_unlock ( ptl ) ; ctx -> page_mask = HPAGE_PMD_NR - 1 ; return page ; }
","<S2SV_ModStart> } else { if ( unlikely ( ! try_get_page ( page ) ) ) { spin_unlock ( ptl ) ; return ERR_PTR ( - ENOMEM ) ; } <S2SV_ModEnd> spin_unlock ( ptl
"
1054,"CWE-22 PHYSICALPATH_FUNC ( mod_alias_physical_handler ) { plugin_data * p = p_d ; int uri_len , basedir_len ; char * uri_ptr ; size_t k ; if ( buffer_is_empty ( con -> physical . path ) ) return HANDLER_GO_ON ; mod_alias_patch_connection ( srv , con , p ) ; basedir_len = buffer_string_length ( con -> physical . basedir ) ; if ( '/' == con -> physical . basedir -> ptr [ basedir_len - 1 ] ) -- basedir_len ; uri_len = buffer_string_length ( con -> physical . path ) - basedir_len ; uri_ptr = con -> physical . path -> ptr + basedir_len ; for ( k = 0 ; k < p -> conf . alias -> used ; k ++ ) { data_string * ds = ( data_string * ) p -> conf . alias -> data [ k ] ; int alias_len = buffer_string_length ( ds -> key ) ; if ( alias_len > uri_len ) continue ; if ( buffer_is_empty ( ds -> key ) ) continue ; if ( 0 == ( con -> conf . force_lowercase_filenames ? strncasecmp ( uri_ptr , ds -> key -> ptr , alias_len ) : strncmp ( uri_ptr , ds -> key -> ptr , alias_len ) ) ) { <S2SV_StartBug> buffer_copy_buffer ( con -> physical . basedir , ds -> value ) ; <S2SV_EndBug> buffer_copy_buffer ( srv -> tmp_buf , ds -> value ) ; buffer_append_string ( srv -> tmp_buf , uri_ptr + alias_len ) ; buffer_copy_buffer ( con -> physical . path , srv -> tmp_buf ) ; return HANDLER_GO_ON ; } } return HANDLER_GO_ON ; }
","<S2SV_ModStart> ) ) { if ( uri_ptr [ alias_len ] == '.' ) { char * s = uri_ptr + alias_len + 1 ; if ( * s == '.' ) ++ s ; if ( * s == '/' || * s == '\\0' ) { size_t vlen = buffer_string_length ( ds -> value ) ; if ( 0 != alias_len && ds -> key -> ptr [ alias_len - 1 ] != '/' && 0 != vlen && ds -> value -> ptr [ vlen - 1 ] == '/' ) { con -> http_status = 403 ; return HANDLER_FINISHED ; } } }
"
1055,"CWE-399 struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { <S2SV_StartBug> sctp_addiphdr_t * hdr ; <S2SV_EndBug> union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; <S2SV_StartBug> int all_param_pass = 1 ; <S2SV_EndBug> chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; <S2SV_StartBug> while ( chunk_len > 0 ) { <S2SV_EndBug> err_code = sctp_process_asconf_param ( asoc , asconf , <S2SV_StartBug> asconf_param ) ; <S2SV_EndBug> if ( SCTP_ERROR_NO_ERROR != err_code ) <S2SV_StartBug> all_param_pass = 0 ; <S2SV_EndBug> if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , <S2SV_StartBug> asconf_param -> crr_id , err_code , <S2SV_EndBug> asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; <S2SV_StartBug> length = ntohs ( asconf_param -> param_hdr . length ) ; <S2SV_EndBug> asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
","<S2SV_ModStart> asconf ) { sctp_addip_chunk_t * addip = ( sctp_addip_chunk_t * ) asconf -> chunk_hdr ; bool all_param_pass = true ; union sctp_params param ; <S2SV_ModStart> __u32 serial ; <S2SV_ModEnd> chunk_len = ntohs <S2SV_ModStart> goto done ; sctp_walk_params ( param , addip , addip_hdr . params ) { if ( param . p -> type == SCTP_PARAM_IPV4_ADDRESS || param . p -> type == SCTP_PARAM_IPV6_ADDRESS ) continue ; <S2SV_ModEnd> err_code = sctp_process_asconf_param <S2SV_ModStart> , asconf , param . addip ) ; if ( err_code != SCTP_ERROR_NO_ERROR <S2SV_ModEnd> ) all_param_pass = <S2SV_ModStart> ) all_param_pass = false <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( asconf_ack , param . addip <S2SV_ModEnd> -> crr_id , <S2SV_ModStart> -> crr_id , err_code , param . addip ) ; if ( err_code == SCTP_ERROR_RSRC_LOW <S2SV_ModEnd> ) goto done <S2SV_ModStart> goto done ; <S2SV_ModEnd> } done :
"
1056,"CWE-000 <S2SV_StartBug> static int _nfs4_do_open ( struct inode * dir , struct path * path , int flags , struct iattr * sattr , struct rpc_cred * cred , struct nfs4_state * * res ) <S2SV_EndBug> { struct nfs4_state_owner * sp ; struct nfs4_state * state = NULL ; struct nfs_server * server = NFS_SERVER ( dir ) ; struct nfs4_opendata * opendata ; int status ; status = - ENOMEM ; if ( ! ( sp = nfs4_get_state_owner ( server , cred ) ) ) { dprintk ( ""nfs4_do_open:<S2SV_blank>nfs4_get_state_owner<S2SV_blank>failed!\\n"" ) ; goto out_err ; } status = nfs4_recover_expired_lease ( server ) ; if ( status != 0 ) goto err_put_state_owner ; if ( path -> dentry -> d_inode != NULL ) <S2SV_StartBug> nfs4_return_incompatible_delegation ( path -> dentry -> d_inode , flags & ( FMODE_READ | FMODE_WRITE ) ) ; <S2SV_EndBug> status = - ENOMEM ; <S2SV_StartBug> opendata = nfs4_opendata_alloc ( path , sp , flags , sattr ) ; <S2SV_EndBug> if ( opendata == NULL ) goto err_put_state_owner ; if ( path -> dentry -> d_inode != NULL ) opendata -> state = nfs4_get_open_state ( path -> dentry -> d_inode , sp ) ; status = _nfs4_proc_open ( opendata ) ; if ( status != 0 ) goto err_opendata_put ; if ( opendata -> o_arg . open_flags & O_EXCL ) nfs4_exclusive_attrset ( opendata , sattr ) ; state = nfs4_opendata_to_nfs4_state ( opendata ) ; status = PTR_ERR ( state ) ; if ( IS_ERR ( state ) ) goto err_opendata_put ; nfs4_opendata_put ( opendata ) ; nfs4_put_state_owner ( sp ) ; * res = state ; return 0 ; err_opendata_put : nfs4_opendata_put ( opendata ) ; err_put_state_owner : nfs4_put_state_owner ( sp ) ; out_err : * res = NULL ; return status ; }
","<S2SV_ModStart> * path , fmode_t fmode , <S2SV_ModStart> -> d_inode , fmode <S2SV_ModEnd> ) ; status <S2SV_ModStart> path , sp , fmode
"
1057,"CWE-400 static inline int do_exception ( struct pt_regs * regs , int access , unsigned long trans_exc_code ) { struct task_struct * tsk ; struct mm_struct * mm ; struct vm_area_struct * vma ; unsigned long address ; unsigned int flags ; int fault ; if ( notify_page_fault ( regs ) ) return 0 ; tsk = current ; mm = tsk -> mm ; fault = VM_FAULT_BADCONTEXT ; if ( unlikely ( ! user_space_fault ( trans_exc_code ) || in_atomic ( ) || ! mm ) ) goto out ; address = trans_exc_code & __FAIL_ADDR_MASK ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , 0 , regs , address ) ; <S2SV_EndBug> flags = FAULT_FLAG_ALLOW_RETRY ; if ( access == VM_WRITE || ( trans_exc_code & store_indication ) == 0x400 ) flags |= FAULT_FLAG_WRITE ; retry : down_read ( & mm -> mmap_sem ) ; fault = VM_FAULT_BADMAP ; vma = find_vma ( mm , address ) ; if ( ! vma ) goto out_up ; if ( unlikely ( vma -> vm_start > address ) ) { if ( ! ( vma -> vm_flags & VM_GROWSDOWN ) ) goto out_up ; if ( expand_stack ( vma , address ) ) goto out_up ; } fault = VM_FAULT_BADACCESS ; if ( unlikely ( ! ( vma -> vm_flags & access ) ) ) goto out_up ; if ( is_vm_hugetlb_page ( vma ) ) address &= HPAGE_MASK ; fault = handle_mm_fault ( mm , vma , address , flags ) ; if ( unlikely ( fault & VM_FAULT_ERROR ) ) goto out_up ; if ( flags & FAULT_FLAG_ALLOW_RETRY ) { if ( fault & VM_FAULT_MAJOR ) { tsk -> maj_flt ++ ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MAJ , 1 , 0 , <S2SV_EndBug> regs , address ) ; } else { tsk -> min_flt ++ ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 , 0 , <S2SV_EndBug> regs , address ) ; } if ( fault & VM_FAULT_RETRY ) { flags &= ~ FAULT_FLAG_ALLOW_RETRY ; goto retry ; } } clear_tsk_thread_flag ( tsk , TIF_PER_TRAP ) ; fault = 0 ; out_up : up_read ( & mm -> mmap_sem ) ; out : return fault ; }
","<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address <S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address <S2SV_ModStart> PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 <S2SV_ModEnd> , regs ,
"
1058,"CWE-295 <S2SV_StartBug> int bind_ports ( void ) { <S2SV_EndBug> SERVICE_OPTIONS * opt ; int listening_section ; # ifdef USE_LIBWRAP libwrap_init ( ) ; # endif s_poll_init ( fds , 1 ) ; for ( opt = service_options . next ; opt ; opt = opt -> next ) { unsigned i ; for ( i = 0 ; i < opt -> local_addr . num ; ++ i ) opt -> local_fd [ i ] = INVALID_SOCKET ; } listening_section = 0 ; for ( opt = service_options . next ; opt ; opt = opt -> next ) { opt -> bound_ports = 0 ; if ( opt -> local_addr . num ) { unsigned i ; s_log ( LOG_DEBUG , ""Binding<S2SV_blank>service<S2SV_blank>[%s]"" , opt -> servname ) ; for ( i = 0 ; i < opt -> local_addr . num ; ++ i ) { SOCKET fd ; fd = bind_port ( opt , listening_section , i ) ; opt -> local_fd [ i ] = fd ; if ( fd != INVALID_SOCKET ) { s_poll_add ( fds , fd , 1 , 0 ) ; ++ opt -> bound_ports ; } } if ( ! opt -> bound_ports ) { s_log ( LOG_ERR , ""Binding<S2SV_blank>service<S2SV_blank>[%s]<S2SV_blank>failed"" , opt -> servname ) ; return 1 ; } ++ listening_section ; } else if ( opt -> exec_name && opt -> connect_addr . names ) { s_log ( LOG_DEBUG , ""Skipped<S2SV_blank>exec+connect<S2SV_blank>service<S2SV_blank>[%s]"" , opt -> servname ) ; # ifndef OPENSSL_NO_TLSEXT } else if ( ! opt -> option . client && opt -> sni ) { s_log ( LOG_DEBUG , ""Skipped<S2SV_blank>SNI<S2SV_blank>slave<S2SV_blank>service<S2SV_blank>[%s]"" , opt -> servname ) ; # endif } else { s_log ( LOG_ERR , ""Invalid<S2SV_blank>service<S2SV_blank>[%s]"" , opt -> servname ) ; return 1 ; } } if ( listening_section < systemd_fds ) { s_log ( LOG_ERR , ""Too<S2SV_blank>many<S2SV_blank>listening<S2SV_blank>file<S2SV_blank>descriptors<S2SV_blank>received<S2SV_blank>from<S2SV_blank>systemd,<S2SV_blank>got<S2SV_blank>%d"" , systemd_fds ) ; return 1 ; } return 0 ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> NOEXPORT
"
1059,"CWE-119 static void adapt_coef_probs ( VP9_COMMON * cm , TX_SIZE tx_size , unsigned int count_sat , unsigned int update_factor ) { const FRAME_CONTEXT * pre_fc = & cm -> frame_contexts [ cm -> frame_context_idx ] ; <S2SV_StartBug> vp9_coeff_probs_model * const probs = cm -> fc . coef_probs [ tx_size ] ; <S2SV_EndBug> const vp9_coeff_probs_model * const pre_probs = pre_fc -> coef_probs [ tx_size ] ; vp9_coeff_count_model * counts = cm -> counts . coef [ tx_size ] ; unsigned int ( * eob_counts ) [ REF_TYPES ] [ COEF_BANDS ] [ COEFF_CONTEXTS ] = cm -> counts . eob_branch [ tx_size ] ; int i , j , k , l , m ; for ( i = 0 ; i < PLANE_TYPES ; ++ i ) for ( j = 0 ; j < REF_TYPES ; ++ j ) for ( k = 0 ; k < COEF_BANDS ; ++ k ) for ( l = 0 ; l < BAND_COEFF_CONTEXTS ( k ) ; ++ l ) { const int n0 = counts [ i ] [ j ] [ k ] [ l ] [ ZERO_TOKEN ] ; const int n1 = counts [ i ] [ j ] [ k ] [ l ] [ ONE_TOKEN ] ; const int n2 = counts [ i ] [ j ] [ k ] [ l ] [ TWO_TOKEN ] ; const int neob = counts [ i ] [ j ] [ k ] [ l ] [ EOB_MODEL_TOKEN ] ; const unsigned int branch_ct [ UNCONSTRAINED_NODES ] [ 2 ] = { { neob , eob_counts [ i ] [ j ] [ k ] [ l ] - neob } , { n0 , n1 + n2 } , { n1 , n2 } } ; for ( m = 0 ; m < UNCONSTRAINED_NODES ; ++ m ) probs [ i ] [ j ] [ k ] [ l ] [ m ] = merge_probs ( pre_probs [ i ] [ j ] [ k ] [ l ] [ m ] , branch_ct [ m ] , count_sat , update_factor ) ; } }
","<S2SV_ModStart> cm -> fc -> <S2SV_ModEnd> coef_probs [ tx_size
"
1060,"CWE-476 static gint dissect_ac_if_hdr_body ( tvbuff_t * tvb , gint offset , packet_info * pinfo _U_ , proto_tree * tree , usb_conv_info_t * usb_conv_info ) { gint offset_start ; guint16 bcdADC ; guint8 ver_major ; double ver ; guint8 if_in_collection , i ; audio_conv_info_t * audio_conv_info ; offset_start = offset ; bcdADC = tvb_get_letohs ( tvb , offset ) ; ver_major = USB_AUDIO_BCD44_TO_DEC ( bcdADC >> 8 ) ; ver = ver_major + USB_AUDIO_BCD44_TO_DEC ( bcdADC & 0xFF ) / 100.0 ; proto_tree_add_double_format_value ( tree , hf_ac_if_hdr_ver , tvb , offset , 2 , ver , ""%2.2f"" , ver ) ; audio_conv_info = ( audio_conv_info_t * ) usb_conv_info -> class_data ; if ( ! audio_conv_info ) { audio_conv_info = wmem_new ( wmem_file_scope ( ) , audio_conv_info_t ) ; usb_conv_info -> class_data = audio_conv_info ; <S2SV_StartBug> } <S2SV_EndBug> audio_conv_info -> ver_major = ver_major ; offset += 2 ; if ( ver_major == 1 ) { proto_tree_add_item ( tree , hf_ac_if_hdr_total_len , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ; offset += 2 ; if_in_collection = tvb_get_guint8 ( tvb , offset ) ; proto_tree_add_item ( tree , hf_ac_if_hdr_bInCollection , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; offset ++ ; for ( i = 0 ; i < if_in_collection ; i ++ ) { proto_tree_add_item ( tree , hf_ac_if_hdr_if_num , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; offset ++ ; } } return offset - offset_start ; }
","<S2SV_ModStart> = audio_conv_info ; usb_conv_info -> class_data_type = USB_CONV_AUDIO ; } else if ( usb_conv_info -> class_data_type != USB_CONV_AUDIO ) { return 0 ;
"
1061,"CWE-617 static krb5_error_code s4u_identify_user ( krb5_context context , krb5_creds * in_creds , krb5_data * subject_cert , krb5_principal * canon_user ) { krb5_error_code code ; krb5_preauthtype ptypes [ 1 ] = { KRB5_PADATA_S4U_X509_USER } ; krb5_creds creds ; int use_master = 0 ; krb5_get_init_creds_opt * opts = NULL ; krb5_principal_data client ; krb5_s4u_userid userid ; * canon_user = NULL ; if ( in_creds -> client == NULL && subject_cert == NULL ) { return EINVAL ; } if ( in_creds -> client != NULL && in_creds -> client -> type != KRB5_NT_ENTERPRISE_PRINCIPAL ) { int anonymous ; anonymous = krb5_principal_compare ( context , in_creds -> client , krb5_anonymous_principal ( ) ) ; return krb5_copy_principal ( context , anonymous ? in_creds -> server : in_creds -> client , canon_user ) ; } memset ( & creds , 0 , sizeof ( creds ) ) ; memset ( & userid , 0 , sizeof ( userid ) ) ; if ( subject_cert != NULL ) userid . subject_cert = * subject_cert ; code = krb5_get_init_creds_opt_alloc ( context , & opts ) ; if ( code != 0 ) goto cleanup ; krb5_get_init_creds_opt_set_tkt_life ( opts , 15 ) ; krb5_get_init_creds_opt_set_renew_life ( opts , 0 ) ; krb5_get_init_creds_opt_set_forwardable ( opts , 0 ) ; krb5_get_init_creds_opt_set_proxiable ( opts , 0 ) ; krb5_get_init_creds_opt_set_canonicalize ( opts , 1 ) ; krb5_get_init_creds_opt_set_preauth_list ( opts , ptypes , 1 ) ; if ( in_creds -> client != NULL ) { client = * in_creds -> client ; client . realm = in_creds -> server -> realm ; } else { client . magic = KV5M_PRINCIPAL ; client . realm = in_creds -> server -> realm ; client . data = NULL ; client . length = 0 ; client . type = KRB5_NT_ENTERPRISE_PRINCIPAL ; } code = k5_get_init_creds ( context , & creds , & client , NULL , NULL , 0 , NULL , opts , krb5_get_as_key_noop , & userid , & use_master , NULL ) ; <S2SV_StartBug> if ( code == 0 || code == KRB5_PREAUTH_FAILED ) { <S2SV_EndBug> * canon_user = userid . user ; userid . user = NULL ; code = 0 ; } cleanup : krb5_free_cred_contents ( context , & creds ) ; if ( opts != NULL ) krb5_get_init_creds_opt_free ( context , opts ) ; if ( userid . user != NULL ) krb5_free_principal ( context , userid . user ) ; return code ; }
","<S2SV_ModStart> ; if ( ! code <S2SV_ModEnd> || code == <S2SV_ModStart> code == KRB5_PREAUTH_FAILED || code == KRB5KDC_ERR_KEY_EXP
"
1062,"CWE-190 static int vc4_get_bcl ( struct drm_device * dev , struct vc4_exec_info * exec ) { struct drm_vc4_submit_cl * args = exec -> args ; void * temp = NULL ; void * bin ; int ret = 0 ; uint32_t bin_offset = 0 ; uint32_t shader_rec_offset = roundup ( bin_offset + args -> bin_cl_size , 16 ) ; uint32_t uniforms_offset = shader_rec_offset + args -> shader_rec_size ; uint32_t exec_size = uniforms_offset + args -> uniforms_size ; uint32_t temp_size = exec_size + ( sizeof ( struct vc4_shader_state ) * args -> shader_rec_count ) ; struct vc4_bo * bo ; <S2SV_StartBug> if ( uniforms_offset < shader_rec_offset || <S2SV_EndBug> exec_size < uniforms_offset || args -> shader_rec_count >= ( UINT_MAX / sizeof ( struct vc4_shader_state ) ) || temp_size < exec_size ) { DRM_ERROR ( ""overflow<S2SV_blank>in<S2SV_blank>exec<S2SV_blank>arguments\\n"" ) ; goto fail ; } temp = drm_malloc_ab ( temp_size , 1 ) ; if ( ! temp ) { DRM_ERROR ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>storage<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>"" ""in<S2SV_blank>bin/render<S2SV_blank>CLs.\\n"" ) ; ret = - ENOMEM ; goto fail ; } bin = temp + bin_offset ; exec -> shader_rec_u = temp + shader_rec_offset ; exec -> uniforms_u = temp + uniforms_offset ; exec -> shader_state = temp + exec_size ; exec -> shader_state_size = args -> shader_rec_count ; if ( copy_from_user ( bin , ( void __user * ) ( uintptr_t ) args -> bin_cl , args -> bin_cl_size ) ) { ret = - EFAULT ; goto fail ; } if ( copy_from_user ( exec -> shader_rec_u , ( void __user * ) ( uintptr_t ) args -> shader_rec , args -> shader_rec_size ) ) { ret = - EFAULT ; goto fail ; } if ( copy_from_user ( exec -> uniforms_u , ( void __user * ) ( uintptr_t ) args -> uniforms , args -> uniforms_size ) ) { ret = - EFAULT ; goto fail ; } bo = vc4_bo_create ( dev , exec_size , true ) ; if ( IS_ERR ( bo ) ) { DRM_ERROR ( ""Couldn\'t<S2SV_blank>allocate<S2SV_blank>BO<S2SV_blank>for<S2SV_blank>binning\\n"" ) ; ret = PTR_ERR ( bo ) ; goto fail ; } exec -> exec_bo = & bo -> base ; list_add_tail ( & to_vc4_bo ( & exec -> exec_bo -> base ) -> unref_head , & exec -> unref_list ) ; exec -> ct0ca = exec -> exec_bo -> paddr + bin_offset ; exec -> bin_u = bin ; exec -> shader_rec_v = exec -> exec_bo -> vaddr + shader_rec_offset ; exec -> shader_rec_p = exec -> exec_bo -> paddr + shader_rec_offset ; exec -> shader_rec_size = args -> shader_rec_size ; exec -> uniforms_v = exec -> exec_bo -> vaddr + uniforms_offset ; exec -> uniforms_p = exec -> exec_bo -> paddr + uniforms_offset ; exec -> uniforms_size = args -> uniforms_size ; ret = vc4_validate_bin_cl ( dev , exec -> exec_bo -> vaddr + bin_offset , bin , exec ) ; if ( ret ) goto fail ; ret = vc4_validate_shader_recs ( dev , exec ) ; if ( ret ) goto fail ; ret = vc4_wait_for_seqno ( dev , exec -> bin_dep_seqno , ~ 0ull , true ) ; fail : drm_free_large ( temp ) ; return ret ; }
","<S2SV_ModStart> ; if ( shader_rec_offset < args -> bin_cl_size ||
"
1063,"CWE-476 static apr_status_t modsecurity_request_body_store_memory ( modsec_rec * msr , const char * data , apr_size_t length , char * * error_msg ) { * error_msg = NULL ; <S2SV_StartBug> if ( ( msr -> msc_reqbody_spilltodisk ) <S2SV_EndBug> && ( msr -> msc_reqbody_length + length > ( apr_size_t ) msr -> txcfg -> reqbody_inmemory_limit ) ) { msc_data_chunk * * chunks ; unsigned int disklen = 0 ; int i ; msr_log ( msr , 4 , ""Input<S2SV_blank>filter:<S2SV_blank>Request<S2SV_blank>too<S2SV_blank>large<S2SV_blank>to<S2SV_blank>store<S2SV_blank>in<S2SV_blank>memory,<S2SV_blank>switching<S2SV_blank>to<S2SV_blank>disk."" ) ; msr -> msc_reqbody_storage = MSC_REQBODY_DISK ; if ( modsecurity_request_body_start_init ( msr , error_msg ) < 0 ) return - 1 ; chunks = ( msc_data_chunk * * ) msr -> msc_reqbody_chunks -> elts ; for ( i = 0 ; i < msr -> msc_reqbody_chunks -> nelts ; i ++ ) { disklen += chunks [ i ] -> length ; if ( modsecurity_request_body_store_disk ( msr , chunks [ i ] -> data , chunks [ i ] -> length , error_msg ) < 0 ) { return - 1 ; } free ( chunks [ i ] -> data ) ; chunks [ i ] -> data = NULL ; } msr -> msc_reqbody_chunks = NULL ; apr_pool_clear ( msr -> msc_reqbody_mp ) ; msr_log ( msr , 4 , ""Input<S2SV_blank>filter:<S2SV_blank>Wrote<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>from<S2SV_blank>memory<S2SV_blank>to<S2SV_blank>disk."" , disklen ) ; return modsecurity_request_body_store_disk ( msr , data , length , error_msg ) ; } { unsigned long int bucket_offset , bucket_left ; bucket_offset = 0 ; bucket_left = length ; while ( bucket_left > 0 ) { if ( msr -> msc_reqbody_chunk_current == NULL ) { msr -> msc_reqbody_chunk_current = ( msc_data_chunk * ) apr_pcalloc ( msr -> msc_reqbody_mp , sizeof ( msc_data_chunk ) ) ; if ( msr -> msc_reqbody_chunk_current == NULL ) { * error_msg = apr_psprintf ( msr -> mp , ""Input<S2SV_blank>filter:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>"" ""for<S2SV_blank>request<S2SV_blank>body<S2SV_blank>chunk."" , ( unsigned long ) sizeof ( msc_data_chunk ) ) ; return - 1 ; } msr -> msc_reqbody_chunk_current -> data = malloc ( CHUNK_CAPACITY ) ; if ( msr -> msc_reqbody_chunk_current -> data == NULL ) { * error_msg = apr_psprintf ( msr -> mp , ""Input<S2SV_blank>filter:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>"" ""for<S2SV_blank>request<S2SV_blank>body<S2SV_blank>chunk<S2SV_blank>data."" , CHUNK_CAPACITY ) ; return - 1 ; } msr -> msc_reqbody_chunk_current -> length = 0 ; msr -> msc_reqbody_chunk_current -> is_permanent = 1 ; * ( const msc_data_chunk * * ) apr_array_push ( msr -> msc_reqbody_chunks ) = msr -> msc_reqbody_chunk_current ; } if ( bucket_left < ( CHUNK_CAPACITY - msr -> msc_reqbody_chunk_current -> length ) ) { memcpy ( msr -> msc_reqbody_chunk_current -> data + msr -> msc_reqbody_chunk_current -> length , data + bucket_offset , bucket_left ) ; msr -> msc_reqbody_chunk_current -> length += bucket_left ; bucket_left = 0 ; } else { unsigned long int copy_length = CHUNK_CAPACITY - msr -> msc_reqbody_chunk_current -> length ; memcpy ( msr -> msc_reqbody_chunk_current -> data + msr -> msc_reqbody_chunk_current -> length , data + bucket_offset , copy_length ) ; bucket_offset += copy_length ; bucket_left -= copy_length ; msr -> msc_reqbody_chunk_current -> length += copy_length ; msr -> msc_reqbody_chunk_current = NULL ; } } msr -> msc_reqbody_length += length ; } return 1 ; }
","<S2SV_ModStart> msr -> msc_reqbody_spilltodisk ) && ( msr -> txcfg -> reqbody_buffering != REQUEST_BODY_FORCEBUF_ON
"
1064,"CWE-190 SYSCALL_DEFINE1 ( timer_getoverrun , timer_t , timer_id ) { struct k_itimer * timr ; int overrun ; unsigned long flags ; timr = lock_timer ( timer_id , & flags ) ; if ( ! timr ) return - EINVAL ; <S2SV_StartBug> overrun = timr -> it_overrun_last ; <S2SV_EndBug> unlock_timer ( timr , flags ) ; return overrun ; }
","<S2SV_ModStart> ; overrun = timer_overrun_to_int ( timr , 0 ) <S2SV_ModEnd> ; unlock_timer (
"
1065,"CWE-476 static int skcipher_accept_parent ( void * private , struct sock * sk ) { struct skcipher_ctx * ctx ; struct alg_sock * ask = alg_sk ( sk ) ; <S2SV_StartBug> unsigned int len = sizeof ( * ctx ) + crypto_skcipher_reqsize ( private ) ; <S2SV_EndBug> ctx = sock_kmalloc ( sk , len , GFP_KERNEL ) ; if ( ! ctx ) return - ENOMEM ; <S2SV_StartBug> ctx -> iv = sock_kmalloc ( sk , crypto_skcipher_ivsize ( private ) , <S2SV_EndBug> GFP_KERNEL ) ; if ( ! ctx -> iv ) { sock_kfree_s ( sk , ctx , len ) ; return - ENOMEM ; } <S2SV_StartBug> memset ( ctx -> iv , 0 , crypto_skcipher_ivsize ( private ) ) ; <S2SV_EndBug> INIT_LIST_HEAD ( & ctx -> tsgl ) ; ctx -> len = len ; ctx -> used = 0 ; ctx -> more = 0 ; ctx -> merge = 0 ; ctx -> enc = 0 ; atomic_set ( & ctx -> inflight , 0 ) ; af_alg_init_completion ( & ctx -> completion ) ; ask -> private = ctx ; <S2SV_StartBug> skcipher_request_set_tfm ( & ctx -> req , private ) ; <S2SV_EndBug> skcipher_request_set_callback ( & ctx -> req , CRYPTO_TFM_REQ_MAY_BACKLOG , af_alg_complete , & ctx -> completion ) ; sk -> sk_destruct = skcipher_sock_destruct ; return 0 ; }
","<S2SV_ModStart> sk ) ; struct skcipher_tfm * tfm = private ; struct crypto_skcipher * skcipher = tfm -> skcipher ; <S2SV_ModStart> + crypto_skcipher_reqsize ( skcipher ) ; if ( ! tfm -> has_key ) return - ENOKEY <S2SV_ModEnd> ; ctx = <S2SV_ModStart> , crypto_skcipher_ivsize ( skcipher <S2SV_ModEnd> ) , GFP_KERNEL <S2SV_ModStart> , crypto_skcipher_ivsize ( skcipher ) ) ; INIT_LIST_HEAD ( & ctx -> tsgl ) ; ctx -> len = len ; ctx -> used = 0 ; ctx -> more = 0 ; ctx -> merge = 0 ; ctx -> enc = 0 ; atomic_set ( & ctx -> inflight , 0 ) ; af_alg_init_completion ( & ctx -> completion ) ; ask -> private <S2SV_ModEnd> = ctx ; <S2SV_ModStart> -> req , skcipher <S2SV_ModEnd> ) ; skcipher_request_set_callback
"
1066,"CWE-264 static unsigned long randomize_stack_top ( unsigned long stack_top ) { <S2SV_StartBug> unsigned int random_variable = 0 ; <S2SV_EndBug> if ( ( current -> flags & PF_RANDOMIZE ) && ! ( current -> personality & ADDR_NO_RANDOMIZE ) ) { <S2SV_StartBug> random_variable = get_random_int ( ) & STACK_RND_MASK ; <S2SV_EndBug> random_variable <<= PAGE_SHIFT ; } # ifdef CONFIG_STACK_GROWSUP return PAGE_ALIGN ( stack_top ) + random_variable ; # else return PAGE_ALIGN ( stack_top ) - random_variable ; # endif }
","<S2SV_ModStart> ) { unsigned long <S2SV_ModEnd> random_variable = 0 <S2SV_ModStart> { random_variable = ( unsigned long ) <S2SV_ModStart> get_random_int ( ) ; random_variable &= <S2SV_ModEnd> STACK_RND_MASK ; random_variable
"
1067,"CWE-119 WORD32 ih264d_mark_err_slice_skip ( dec_struct_t * ps_dec , WORD32 num_mb_skip , UWORD8 u1_is_idr_slice , UWORD16 u2_frame_num , pocstruct_t * ps_cur_poc , WORD32 prev_slice_err ) { WORD32 i2_cur_mb_addr ; UWORD32 u1_num_mbs , u1_num_mbsNby2 ; UWORD32 u1_mb_idx = ps_dec -> u1_mb_idx ; UWORD32 i2_mb_skip_run ; UWORD32 u1_num_mbs_next , u1_end_of_row ; const UWORD32 i2_pic_wdin_mbs = ps_dec -> u2_frm_wd_in_mbs ; UWORD32 u1_slice_end ; UWORD32 u1_tfr_n_mb ; UWORD32 u1_decode_nmb ; dec_bit_stream_t * const ps_bitstrm = ps_dec -> ps_bitstrm ; dec_slice_params_t * ps_slice = ps_dec -> ps_cur_slice ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; deblk_mb_t * ps_cur_deblk_mb ; dec_mb_info_t * ps_cur_mb_info ; parse_pmbarams_t * ps_parse_mb_data ; UWORD32 u1_inter_mb_type ; UWORD32 u1_deblk_mb_type ; UWORD16 u2_total_mbs_coded ; UWORD32 u1_mbaff = ps_slice -> u1_mbaff_frame_flag ; parse_part_params_t * ps_part_info ; WORD32 ret ; if ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) { ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; return 0 ; } ps_dec -> ps_dpb_cmds -> u1_long_term_reference_flag = 0 ; if ( prev_slice_err == 1 ) { ps_dec -> ps_cur_slice -> u2_frame_num = u2_frame_num ; if ( ! ps_dec -> u1_first_slice_in_stream ) { ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , ps_dec -> ps_cur_slice -> u2_frame_num ) ; ps_dec -> s_cur_pic_poc . u2_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ; } { WORD32 i , j , poc = 0 ; ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = 0 ; ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaff ; ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_bp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_bp ; if ( ps_dec -> ps_cur_pic != NULL ) poc = ps_dec -> ps_cur_pic -> i4_poc + 2 ; j = 0 ; for ( i = 0 ; i < MAX_NUM_PIC_PARAMS ; i ++ ) if ( ps_dec -> ps_pps [ i ] . u1_is_valid == TRUE ) j = i ; { ps_dec -> ps_cur_slice -> u1_slice_type = P_SLICE ; ps_dec -> ps_cur_slice -> u1_nal_ref_idc = 1 ; ps_dec -> ps_cur_slice -> u1_nal_unit_type = 1 ; ret = ih264d_start_of_pic ( ps_dec , poc , ps_cur_poc , ps_dec -> ps_cur_slice -> u2_frame_num , & ps_dec -> ps_pps [ j ] ) ; if ( ret != OK ) { return ret ; } } ps_dec -> ps_ref_pic_buf_lx [ 0 ] [ 0 ] -> u1_pic_buf_id = 0 ; ps_dec -> u4_output_present = 0 ; { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 != ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = ps_dec -> s_disp_frame_info . u4_y_ht ; } else ps_dec -> u4_output_present = 1 ; } if ( ps_dec -> u1_separate_parse == 1 ) { if ( ps_dec -> u4_dec_thread_created == 0 ) { ithread_create ( ps_dec -> pv_dec_thread_handle , NULL , ( void * ) ih264d_decode_picture_thread , ( void * ) ps_dec ) ; ps_dec -> u4_dec_thread_created = 1 ; } if ( ( ps_dec -> u4_num_cores == 3 ) && ( ( ps_dec -> u4_app_disable_deblk_frm == 0 ) || ps_dec -> i1_recon_in_thread3_flag ) && ( ps_dec -> u4_bs_deblk_thread_created == 0 ) ) { ps_dec -> u4_start_recon_deblk = 0 ; ithread_create ( ps_dec -> pv_bs_deblk_thread_handle , NULL , ( void * ) ih264d_recon_deblk_thread , ( void * ) ps_dec ) ; ps_dec -> u4_bs_deblk_thread_created = 1 ; } } } <S2SV_StartBug> } <S2SV_EndBug> else { dec_slice_struct_t * ps_parse_cur_slice ; ps_parse_cur_slice = ps_dec -> ps_dec_slice_buf + ps_dec -> u2_cur_slice_num ; if ( ps_dec -> u1_slice_header_done && ps_parse_cur_slice == ps_dec -> ps_parse_cur_slice ) { u1_num_mbs = ps_dec -> u4_num_mbs_cur_nmb ; if ( u1_num_mbs ) { ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs - 1 ; } else { if ( ps_dec -> u1_separate_parse ) { ps_cur_mb_info = ps_dec -> ps_nmb_info - 1 ; } else { ps_cur_mb_info = ps_dec -> ps_nmb_info + ps_dec -> u4_num_mbs_prev_nmb - 1 ; } } ps_dec -> u2_mby = ps_cur_mb_info -> u2_mby ; ps_dec -> u2_mbx = ps_cur_mb_info -> u2_mbx ; ps_dec -> u1_mb_ngbr_availablity = ps_cur_mb_info -> u1_mb_ngbr_availablity ; ps_dec -> pv_parse_tu_coeff_data = ps_dec -> pv_prev_mb_parse_tu_coeff_data ; ps_dec -> u2_cur_mb_addr -- ; ps_dec -> i4_submb_ofst -= SUB_BLK_SIZE ; if ( u1_num_mbs ) { if ( ps_dec -> u1_pr_sl_type == P_SLICE || ps_dec -> u1_pr_sl_type == B_SLICE ) { ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; } u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_slice_end = 1 ; u1_tfr_n_mb = 1 ; ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ; ps_dec -> u1_mb_idx = 0 ; ps_dec -> u4_num_mbs_cur_nmb = 0 ; } if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_pic_decode_done = 1 ; return 0 ; } ps_dec -> u2_cur_slice_num ++ ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; ps_dec -> ps_parse_cur_slice ++ ; } else { ps_dec -> ps_parse_cur_slice = ps_dec -> ps_dec_slice_buf + ps_dec -> u2_cur_slice_num ; } } { WORD32 num_entries ; WORD32 size ; UWORD8 * pu1_buf ; num_entries = MAX_FRAMES ; if ( ( 1 >= ps_dec -> ps_cur_sps -> u1_num_ref_frames ) && ( 0 == ps_dec -> i4_display_delay ) ) { num_entries = 1 ; } num_entries = ( ( 2 * num_entries ) + 1 ) ; if ( BASE_PROFILE_IDC != ps_dec -> ps_cur_sps -> u1_profile_idc ) { num_entries *= 2 ; } size = num_entries * sizeof ( void * ) ; size += PAD_MAP_IDX_POC * sizeof ( void * ) ; pu1_buf = ( UWORD8 * ) ps_dec -> pv_map_ref_idx_to_poc_buf ; pu1_buf += size * ps_dec -> u2_cur_slice_num ; ps_dec -> ps_parse_cur_slice -> ppv_map_ref_idx_to_poc = ( volatile void * * ) pu1_buf ; } ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = ps_dec -> u2_total_mbs_coded << u1_mbaff ; ps_dec -> ps_cur_slice -> i1_slice_alpha_c0_offset = 0 ; ps_dec -> ps_cur_slice -> i1_slice_beta_offset = 0 ; if ( ps_dec -> ps_cur_slice -> u1_field_pic_flag ) ps_dec -> u2_prv_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ; ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice = ps_dec -> u2_total_mbs_coded << u1_mbaff ; ps_dec -> ps_parse_cur_slice -> u2_log2Y_crwd = ps_dec -> ps_cur_slice -> u2_log2Y_crwd ; if ( ps_dec -> u1_separate_parse ) { ps_dec -> ps_parse_cur_slice -> pv_tu_coeff_data_start = ps_dec -> pv_parse_tu_coeff_data ; } else { ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; } u1_inter_mb_type = P_MB ; u1_deblk_mb_type = D_INTER_MB ; ps_dec -> ps_cur_slice -> u1_slice_type = P_SLICE ; ps_dec -> ps_parse_cur_slice -> slice_type = P_SLICE ; ps_dec -> pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; ps_dec -> u1_slice_header_done = 2 ; ps_dec -> u1_qp = ps_slice -> u1_slice_qp ; ih264d_update_qp ( ps_dec , 0 ) ; u1_mb_idx = ps_dec -> u1_mb_idx ; ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; u1_num_mbs = u1_mb_idx ; u1_slice_end = 0 ; u1_tfr_n_mb = 0 ; u1_decode_nmb = 0 ; u1_num_mbsNby2 = 0 ; i2_cur_mb_addr = ps_dec -> u2_total_mbs_coded ; i2_mb_skip_run = num_mb_skip ; while ( ! u1_slice_end ) { UWORD8 u1_mb_type ; if ( i2_cur_mb_addr > ps_dec -> ps_cur_sps -> u2_max_mb_addr ) break ; ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs ; ps_dec -> u4_num_mbs_cur_nmb = u1_num_mbs ; ps_cur_mb_info -> u1_Mux = 0 ; ps_dec -> u4_num_pmbair = ( u1_num_mbs >> u1_mbaff ) ; ps_cur_deblk_mb = ps_dec -> ps_deblk_mbn + u1_num_mbs ; ps_cur_mb_info -> u1_end_of_slice = 0 ; ps_parse_mb_data -> u1_num_part = 1 ; ps_parse_mb_data -> u1_isI_mb = 0 ; if ( u1_mbaff ) ih264d_get_mb_info_cavlc_mbaff ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , i2_mb_skip_run ) ; else ih264d_get_mb_info_cavlc_nonmbaff ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , i2_mb_skip_run ) ; if ( ps_dec -> u4_app_disable_deblk_frm == 0 ) { ih264d_set_deblocking_parameters ( ps_cur_deblk_mb , ps_slice , ps_dec -> u1_mb_ngbr_availablity , ps_dec -> u1_cur_mb_fld_dec_flag ) ; } ps_dec -> i1_prev_mb_qp_delta = 0 ; ps_dec -> u1_sub_mb_num = 0 ; ps_cur_mb_info -> u1_mb_type = MB_SKIP ; ps_cur_mb_info -> u1_mb_mc_mode = PRED_16x16 ; ps_cur_mb_info -> u1_cbp = 0 ; ps_part_info = ps_dec -> ps_part ; ps_part_info -> u1_is_direct = PART_DIRECT_16x16 ; ps_part_info -> u1_sub_mb_num = 0 ; ps_dec -> ps_part ++ ; ih264d_update_nnz_for_skipmb ( ps_dec , ps_cur_mb_info , CAVLC ) ; ps_cur_mb_info -> ps_curmb -> u1_mb_type = u1_inter_mb_type ; ps_cur_deblk_mb -> u1_mb_type |= u1_deblk_mb_type ; i2_mb_skip_run -- ; ps_cur_deblk_mb -> u1_mb_qp = ps_dec -> u1_qp ; if ( u1_mbaff ) { ih264d_update_mbaff_left_nnz ( ps_dec , ps_cur_mb_info ) ; } i2_cur_mb_addr ++ ; u1_num_mbs ++ ; u1_num_mbsNby2 ++ ; ps_parse_mb_data ++ ; u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_slice_end = ! i2_mb_skip_run ; u1_tfr_n_mb = ( u1_num_mbs == ps_dec -> u1_recon_mb_grp ) || u1_end_of_row || u1_slice_end ; u1_decode_nmb = u1_tfr_n_mb || u1_slice_end ; ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; if ( u1_decode_nmb ) { ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; u1_num_mbsNby2 = 0 ; ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ; if ( u1_tfr_n_mb ) u1_num_mbs = 0 ; u1_mb_idx = u1_num_mbs ; ps_dec -> u1_mb_idx = u1_num_mbs ; } } ps_dec -> u4_num_mbs_cur_nmb = 0 ; ps_dec -> ps_cur_slice -> u4_mbs_in_slice = i2_cur_mb_addr - ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice ; H264_DEC_DEBUG_PRINT ( ""Mbs<S2SV_blank>in<S2SV_blank>slice:<S2SV_blank>%d\\n"" , ps_dec -> ps_cur_slice -> u4_mbs_in_slice ) ; <S2SV_StartBug> ps_dec -> u2_cur_slice_num ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( ps_dec -> u4_first_slice_in_pic != 0 ) <S2SV_EndBug> ps_dec -> ps_parse_cur_slice ++ ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_pic_decode_done = 1 ; } return 0 ; }
","<S2SV_ModStart> } } } ps_dec -> u4_first_slice_in_pic = 0 ; <S2SV_ModStart> u4_mbs_in_slice ) ; if ( ps_dec -> u4_first_slice_in_pic != 0 ) { ps_dec -> ps_parse_cur_slice ++ ; <S2SV_ModStart> u2_cur_slice_num ++ ; } <S2SV_ModEnd> ps_dec -> i2_prev_slice_mbx
"
1068,"CWE-119 static void GTextFieldSave ( GTextField * gt , int utf8 ) { unichar_t * ret ; char * cret ; FILE * file ; unichar_t * pt ; if ( _ggadget_use_gettext ) { char * temp = GWidgetOpenFile8 ( _ ( ""Save"" ) , NULL , ""*.{txt,py}"" , NULL , NULL ) ; ret = utf82u_copy ( temp ) ; free ( temp ) ; } else ret = GWidgetSaveAsFile ( GStringGetResource ( _STR_Save , NULL ) , NULL , txt , NULL , NULL ) ; if ( ret == NULL ) return ; cret = u2def_copy ( ret ) ; free ( ret ) ; file = fopen ( cret , ""w"" ) ; if ( file == NULL ) { if ( _ggadget_use_gettext ) GWidgetError8 ( _ ( ""Could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>file"" ) , _ ( ""Could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>%.100s"" ) , cret ) ; else GWidgetError ( errort , error , cret ) ; free ( cret ) ; return ; } free ( cret ) ; if ( utf8 ) { putc ( 0xef , file ) ; putc ( 0xbb , file ) ; putc ( 0xbf , file ) ; for ( pt = gt -> text ; * pt ; ++ pt ) { if ( * pt < 0x80 ) putc ( * pt , file ) ; else if ( * pt < 0x800 ) { putc ( 0xc0 | ( * pt >> 6 ) , file ) ; putc ( 0x80 | ( * pt & 0x3f ) , file ) ; } else if ( * pt >= 0xd800 && * pt < 0xdc00 && pt [ 1 ] >= 0xdc00 && pt [ 1 ] < 0xe000 ) { int u = ( ( * pt >> 6 ) & 0xf ) + 1 , y = ( ( * pt & 3 ) << 4 ) | ( ( pt [ 1 ] >> 6 ) & 0xf ) ; putc ( 0xf0 | ( u >> 2 ) , file ) ; putc ( 0x80 | ( ( u & 3 ) << 4 ) | ( ( * pt >> 2 ) & 0xf ) , file ) ; putc ( 0x80 | y , file ) ; putc ( 0x80 | ( pt [ 1 ] & 0x3f ) , file ) ; } else { putc ( 0xe0 | ( * pt >> 12 ) , file ) ; putc ( 0x80 | ( ( * pt >> 6 ) & 0x3f ) , file ) ; putc ( 0x80 | ( * pt & 0x3f ) , file ) ; } } } else { putc ( 0xfeff >> 8 , file ) ; putc ( 0xfeff & 0xff , file ) ; for ( pt = gt -> text ; * pt ; ++ pt ) { putc ( * pt >> 8 , file ) ; putc ( * pt & 0xff , file ) ; } } fclose ( file ) ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> file ) ; GTextFieldSaved ( gt ) ;
"
1069,"CWE-119 <S2SV_StartBug> static double get_rate_correction_factor ( const VP9_COMP * cpi ) { <S2SV_EndBug> if ( cpi -> common . frame_type == KEY_FRAME ) { <S2SV_StartBug> return cpi -> rc . key_frame_rate_correction_factor ; <S2SV_EndBug> } else { if ( ( cpi -> refresh_alt_ref_frame || cpi -> refresh_golden_frame ) && <S2SV_StartBug> ! cpi -> rc . is_src_frame_alt_ref && <S2SV_EndBug> <S2SV_StartBug> ! ( cpi -> use_svc && cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) ) <S2SV_EndBug> return cpi -> rc . gf_rate_correction_factor ; else return cpi -> rc . rate_correction_factor ; } }
","<S2SV_ModStart> cpi ) { const RATE_CONTROL * const rc = & cpi -> rc ; double rcf ; <S2SV_ModStart> KEY_FRAME ) { rcf = rc -> rate_correction_factors [ KF_STD ] ; } else if ( cpi -> oxcf . pass == 2 ) { RATE_FACTOR_LEVEL rf_lvl = cpi -> twopass . gf_group . rf_level [ cpi -> twopass . gf_group . index ] ; rcf = rc -> rate_correction_factors [ rf_lvl ] <S2SV_ModEnd> ; } else <S2SV_ModStart> ) && ! rc -> <S2SV_ModEnd> is_src_frame_alt_ref && ! <S2SV_ModStart> is_src_frame_alt_ref && ! <S2SV_ModEnd> cpi -> use_svc <S2SV_ModStart> -> use_svc && ( <S2SV_ModStart> -> oxcf . rc_mode != VPX_CBR || cpi -> oxcf . gf_cbr_boost_pct > 20 ) ) rcf = rc -> rate_correction_factors [ GF_ARF_STD ] ; else rcf = rc -> rate_correction_factors [ INTER_NORMAL ] ; } rcf *= rcf_mult [ rc -> frame_size_selector ] ; return fclamp ( rcf , MIN_BPB_FACTOR , MAX_BPB_FACTOR ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
"
1070,"CWE-20 void mk_request_free ( struct session_request * sr ) { if ( sr -> fd_file > 0 ) { <S2SV_StartBug> mk_vhost_close ( sr ) ; <S2SV_EndBug> } if ( sr -> headers . location ) { mk_mem_free ( sr -> headers . location ) ; } if ( sr -> uri_processed . data != sr -> uri . data ) { mk_ptr_free ( & sr -> uri_processed ) ; } if ( sr -> real_path . data != sr -> real_path_static ) { mk_ptr_free ( & sr -> real_path ) ; } }
","<S2SV_ModStart> 0 ) { if ( sr -> fd_is_fdt == MK_TRUE ) { <S2SV_ModStart> sr ) ; } else { close ( sr -> fd_file ) ; }
"
1071,"CWE-269 qboolean S_AL_Init ( soundInterface_t * si ) { # ifdef USE_OPENAL const char * device = NULL ; const char * inputdevice = NULL ; int i ; if ( ! si ) { return qfalse ; } for ( i = 0 ; i < MAX_RAW_STREAMS ; i ++ ) { streamSourceHandles [ i ] = - 1 ; streamPlaying [ i ] = qfalse ; streamSources [ i ] = 0 ; streamNumBuffers [ i ] = 0 ; streamBufIndex [ i ] = 0 ; } s_alPrecache = Cvar_Get ( ""s_alPrecache"" , ""1"" , CVAR_ARCHIVE ) ; s_alGain = Cvar_Get ( ""s_alGain"" , ""1.0"" , CVAR_ARCHIVE ) ; s_alSources = Cvar_Get ( ""s_alSources"" , ""128"" , CVAR_ARCHIVE ) ; s_alDopplerFactor = Cvar_Get ( ""s_alDopplerFactor"" , ""1.0"" , CVAR_ARCHIVE ) ; s_alDopplerSpeed = Cvar_Get ( ""s_alDopplerSpeed"" , ""9000"" , CVAR_ARCHIVE ) ; s_alMinDistance = Cvar_Get ( ""s_alMinDistance"" , ""120"" , CVAR_CHEAT ) ; s_alMaxDistance = Cvar_Get ( ""s_alMaxDistance"" , ""1024"" , CVAR_CHEAT ) ; s_alRolloff = Cvar_Get ( ""s_alRolloff"" , ""2"" , CVAR_CHEAT ) ; s_alGraceDistance = Cvar_Get ( ""s_alGraceDistance"" , ""512"" , CVAR_CHEAT ) ; <S2SV_StartBug> s_alDriver = Cvar_Get ( ""s_alDriver"" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_EndBug> s_alInputDevice = Cvar_Get ( ""s_alInputDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_StartBug> s_alDevice = Cvar_Get ( ""s_alDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_EndBug> if ( ! QAL_Init ( s_alDriver -> string ) ) { # if defined ( _WIN32 ) if ( ! Q_stricmp ( s_alDriver -> string , ALDRIVER_DEFAULT ) && ! QAL_Init ( ""OpenAL64.dll"" ) ) { # elif defined ( __APPLE__ ) if ( ! Q_stricmp ( s_alDriver -> string , ALDRIVER_DEFAULT ) && ! QAL_Init ( ""/System/Library/Frameworks/OpenAL.framework/OpenAL"" ) ) { # else if ( ! Q_stricmp ( s_alDriver -> string , ALDRIVER_DEFAULT ) || ! QAL_Init ( ALDRIVER_DEFAULT ) ) { # endif return qfalse ; } } device = s_alDevice -> string ; if ( device && ! * device ) device = NULL ; inputdevice = s_alInputDevice -> string ; if ( inputdevice && ! * inputdevice ) inputdevice = NULL ; enumeration_all_ext = qalcIsExtensionPresent ( NULL , ""ALC_ENUMERATE_ALL_EXT"" ) ; enumeration_ext = qalcIsExtensionPresent ( NULL , ""ALC_ENUMERATION_EXT"" ) ; if ( enumeration_ext || enumeration_all_ext ) { char devicenames [ 16384 ] = """" ; const char * devicelist ; # ifdef _WIN32 const char * defaultdevice ; # endif int curlen ; if ( enumeration_all_ext ) { devicelist = qalcGetString ( NULL , ALC_ALL_DEVICES_SPECIFIER ) ; # ifdef _WIN32 defaultdevice = qalcGetString ( NULL , ALC_DEFAULT_ALL_DEVICES_SPECIFIER ) ; # endif } else { devicelist = qalcGetString ( NULL , ALC_DEVICE_SPECIFIER ) ; # ifdef _WIN32 defaultdevice = qalcGetString ( NULL , ALC_DEFAULT_DEVICE_SPECIFIER ) ; # endif enumeration_ext = qtrue ; } # ifdef _WIN32 if ( ! device && defaultdevice && ! strcmp ( defaultdevice , ""Generic<S2SV_blank>Hardware"" ) ) device = ""Generic<S2SV_blank>Software"" ; # endif if ( devicelist ) { while ( ( curlen = strlen ( devicelist ) ) ) { Q_strcat ( devicenames , sizeof ( devicenames ) , devicelist ) ; Q_strcat ( devicenames , sizeof ( devicenames ) , ""\\n"" ) ; devicelist += curlen + 1 ; } } s_alAvailableDevices = Cvar_Get ( ""s_alAvailableDevices"" , devicenames , CVAR_ROM | CVAR_NORESTART ) ; } alDevice = qalcOpenDevice ( device ) ; if ( ! alDevice && device ) { Com_Printf ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>OpenAL<S2SV_blank>device<S2SV_blank>\'%s\',<S2SV_blank>trying<S2SV_blank>default.\\n"" , device ) ; alDevice = qalcOpenDevice ( NULL ) ; } if ( ! alDevice ) { QAL_Shutdown ( ) ; Com_Printf ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>OpenAL<S2SV_blank>device.\\n"" ) ; return qfalse ; } alContext = qalcCreateContext ( alDevice , NULL ) ; if ( ! alContext ) { QAL_Shutdown ( ) ; qalcCloseDevice ( alDevice ) ; Com_Printf ( ""Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>OpenAL<S2SV_blank>context.\\n"" ) ; return qfalse ; } qalcMakeContextCurrent ( alContext ) ; S_AL_BufferInit ( ) ; S_AL_SrcInit ( ) ; Com_Printf ( ""Allocated<S2SV_blank>%d<S2SV_blank>sources.\\n"" , srcCount ) ; qalDistanceModel ( AL_INVERSE_DISTANCE_CLAMPED ) ; qalDopplerFactor ( s_alDopplerFactor -> value ) ; qalSpeedOfSound ( s_alDopplerSpeed -> value ) ; # ifdef USE_VOIP s_alCapture = Cvar_Get ( ""s_alCapture"" , ""1"" , CVAR_ARCHIVE | CVAR_LATCH ) ; if ( ! s_alCapture -> integer ) { Com_Printf ( ""OpenAL<S2SV_blank>capture<S2SV_blank>support<S2SV_blank>disabled<S2SV_blank>by<S2SV_blank>user<S2SV_blank>(\'+set<S2SV_blank>s_alCapture<S2SV_blank>1\'<S2SV_blank>to<S2SV_blank>enable)\\n"" ) ; } # if USE_MUMBLE else if ( cl_useMumble -> integer ) { Com_Printf ( ""OpenAL<S2SV_blank>capture<S2SV_blank>support<S2SV_blank>disabled<S2SV_blank>for<S2SV_blank>Mumble<S2SV_blank>support\\n"" ) ; } # endif else { # ifdef __APPLE__ if ( qalcCaptureOpenDevice == NULL ) # else if ( ! qalcIsExtensionPresent ( NULL , ""ALC_EXT_capture"" ) ) # endif { Com_Printf ( ""No<S2SV_blank>ALC_EXT_capture<S2SV_blank>support,<S2SV_blank>can\'t<S2SV_blank>record<S2SV_blank>audio.\\n"" ) ; } else { char inputdevicenames [ 16384 ] = """" ; const char * inputdevicelist ; const char * defaultinputdevice ; int curlen ; capture_ext = qtrue ; inputdevicelist = qalcGetString ( NULL , ALC_CAPTURE_DEVICE_SPECIFIER ) ; defaultinputdevice = qalcGetString ( NULL , ALC_CAPTURE_DEFAULT_DEVICE_SPECIFIER ) ; if ( inputdevicelist ) { while ( ( curlen = strlen ( inputdevicelist ) ) ) { Q_strcat ( inputdevicenames , sizeof ( inputdevicenames ) , inputdevicelist ) ; Q_strcat ( inputdevicenames , sizeof ( inputdevicenames ) , ""\\n"" ) ; inputdevicelist += curlen + 1 ; } } s_alAvailableInputDevices = Cvar_Get ( ""s_alAvailableInputDevices"" , inputdevicenames , CVAR_ROM | CVAR_NORESTART ) ; Com_Printf ( ""OpenAL<S2SV_blank>default<S2SV_blank>capture<S2SV_blank>device<S2SV_blank>is<S2SV_blank>\'%s\'\\n"" , defaultinputdevice ? defaultinputdevice : ""none"" ) ; alCaptureDevice = qalcCaptureOpenDevice ( inputdevice , 48000 , AL_FORMAT_MONO16 , VOIP_MAX_PACKET_SAMPLES * 4 ) ; if ( ! alCaptureDevice && inputdevice ) { Com_Printf ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>OpenAL<S2SV_blank>Input<S2SV_blank>device<S2SV_blank>\'%s\',<S2SV_blank>trying<S2SV_blank>default.\\n"" , inputdevice ) ; alCaptureDevice = qalcCaptureOpenDevice ( NULL , 48000 , AL_FORMAT_MONO16 , VOIP_MAX_PACKET_SAMPLES * 4 ) ; } Com_Printf ( ""OpenAL<S2SV_blank>capture<S2SV_blank>device<S2SV_blank>%s.\\n"" , ( alCaptureDevice == NULL ) ? ""failed<S2SV_blank>to<S2SV_blank>open"" : ""opened"" ) ; } } # endif si -> Shutdown = S_AL_Shutdown ; si -> StartSound = S_AL_StartSound ; si -> StartSoundEx = S_AL_StartSoundEx ; si -> StartLocalSound = S_AL_StartLocalSound ; si -> StartBackgroundTrack = S_AL_StartBackgroundTrack ; si -> StopBackgroundTrack = S_AL_StopBackgroundTrack ; si -> StartStreamingSound = S_AL_StartStreamingSound ; si -> GetVoiceAmplitude = S_AL_GetVoiceAmplitude ; si -> RawSamples = S_AL_RawSamples ; si -> StopAllSounds = S_AL_StopAllSounds ; si -> ClearLoopingSounds = S_AL_ClearLoopingSounds ; si -> AddLoopingSound = S_AL_AddLoopingSound ; si -> AddRealLoopingSound = S_AL_AddRealLoopingSound ; si -> StopLoopingSound = S_AL_StopLoopingSound ; si -> Respatialize = S_AL_Respatialize ; si -> UpdateEntityPosition = S_AL_UpdateEntityPosition ; si -> Update = S_AL_Update ; si -> DisableSounds = S_AL_DisableSounds ; si -> BeginRegistration = S_AL_BeginRegistration ; si -> RegisterSound = S_AL_RegisterSound ; si -> ClearSoundBuffer = S_AL_ClearSoundBuffer ; si -> SoundInfo = S_AL_SoundInfo ; si -> SoundList = S_AL_SoundList ; # ifdef USE_VOIP si -> StartCapture = S_AL_StartCapture ; si -> AvailableCaptureSamples = S_AL_AvailableCaptureSamples ; si -> Capture = S_AL_Capture ; si -> StopCapture = S_AL_StopCapture ; si -> MasterGain = S_AL_MasterGain ; # endif return qtrue ; # else return qfalse ; # endif }
","<S2SV_ModStart> CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED <S2SV_ModStart> CVAR_LATCH ) ; if ( COM_CompareExtension ( s_alDriver -> string , "".pk3"" ) ) { Com_Printf ( ""Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\""%s\\"""" , s_alDriver -> string ) ; return qfalse ; }
"
1072,"CWE-125 int archive_wstring_append_from_mbs ( struct archive_wstring * dest , const char * p , size_t len ) { size_t r ; int ret_val = 0 ; <S2SV_StartBug> size_t wcs_length = len ; <S2SV_EndBug> size_t mbs_length = len ; const char * mbs = p ; wchar_t * wcs ; # if HAVE_MBRTOWC mbstate_t shift_state ; memset ( & shift_state , 0 , sizeof ( shift_state ) ) ; # endif <S2SV_StartBug> if ( NULL == archive_wstring_ensure ( dest , dest -> length + wcs_length + 1 ) ) <S2SV_EndBug> return ( - 1 ) ; wcs = dest -> s + dest -> length ; while ( * mbs && mbs_length > 0 ) { <S2SV_StartBug> if ( wcs_length == 0 ) { <S2SV_EndBug> dest -> length = wcs - dest -> s ; dest -> s [ dest -> length ] = L'\\0' ; <S2SV_StartBug> wcs_length = mbs_length ; <S2SV_EndBug> if ( NULL == archive_wstring_ensure ( dest , dest -> length + wcs_length + 1 ) ) return ( - 1 ) ; wcs = dest -> s + dest -> length ; } # if HAVE_MBRTOWC r = mbrtowc ( wcs , mbs , wcs_length , & shift_state ) ; # else r = mbtowc ( wcs , mbs , wcs_length ) ; # endif if ( r == ( size_t ) - 1 || r == ( size_t ) - 2 ) { ret_val = - 1 ; if ( errno == EILSEQ ) { ++ mbs ; -- mbs_length ; continue ; } else break ; } if ( r == 0 || r > mbs_length ) break ; wcs ++ ; wcs_length -- ; mbs += r ; mbs_length -= r ; } dest -> length = wcs - dest -> s ; dest -> s [ dest -> length ] = L'\\0' ; return ( ret_val ) ; }
","<S2SV_ModStart> 0 ; size_t <S2SV_ModEnd> mbs_length = len <S2SV_ModStart> -> length + len <S2SV_ModEnd> + 1 ) <S2SV_ModStart> 0 ) { # if HAVE_MBRTOWC r = mbrtowc ( wcs , mbs , mbs_length , & shift_state ) ; # else r = mbtowc ( wcs , mbs , mbs_length ) ; # endif if ( r == ( size_t ) - 1 || r == ( size_t ) - 2 ) { ret_val = - 1 ; break ; } if ( r == 0 || r > mbs_length ) break ; wcs ++ ; mbs += r ; mbs_length -= r ; } <S2SV_ModEnd> dest -> length <S2SV_ModStart> = L'\\0' ; <S2SV_ModEnd> return ( ret_val
"
1073,"CWE-125 static void get_nb10 ( ut8 * dbg_data , SCV_NB10_HEADER * res ) { const int nb10sz = 16 ; <S2SV_StartBug> memcpy ( res , dbg_data , nb10sz ) ; <S2SV_EndBug> res -> file_name = ( ut8 * ) strdup ( ( const char * ) dbg_data + nb10sz ) ; }
","<S2SV_ModStart> = 16 ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
"
1074,"CWE-200 int main ( int argc , char * * argv ) { int fd = xopen ( ""/dev/null"" , O_RDWR ) ; while ( fd < 2 ) fd = xdup ( fd ) ; if ( fd > 2 ) close ( fd ) ; if ( argc < 8 ) { error_msg_and_die ( ""Usage:<S2SV_blank>%s<S2SV_blank>SIGNO<S2SV_blank>CORE_SIZE_LIMIT<S2SV_blank>PID<S2SV_blank>UID<S2SV_blank>GID<S2SV_blank>TIME<S2SV_blank>BINARY_NAME<S2SV_blank>[HOSTNAME]"" , argv [ 0 ] ) ; } if ( strchr ( argv [ 1 ] , '<S2SV_blank>' ) ) { int i ; for ( i = 1 ; argv [ i ] ; i ++ ) { strchrnul ( argv [ i ] , '<S2SV_blank>' ) [ 0 ] = '\\0' ; } } logmode = LOGMODE_JOURNAL ; load_abrt_conf ( ) ; bool setting_MakeCompatCore ; bool setting_SaveBinaryImage ; { map_string_t * settings = new_map_string ( ) ; load_abrt_plugin_conf_file ( ""CCpp.conf"" , settings ) ; const char * value ; value = get_map_string_item_or_NULL ( settings , ""MakeCompatCore"" ) ; setting_MakeCompatCore = value && string_to_bool ( value ) ; value = get_map_string_item_or_NULL ( settings , ""SaveBinaryImage"" ) ; setting_SaveBinaryImage = value && string_to_bool ( value ) ; value = get_map_string_item_or_NULL ( settings , ""VerboseLog"" ) ; if ( value ) g_verbose = xatoi_positive ( value ) ; free_map_string ( settings ) ; } errno = 0 ; const char * signal_str = argv [ 1 ] ; int signal_no = xatoi_positive ( signal_str ) ; off_t ulimit_c = strtoull ( argv [ 2 ] , NULL , 10 ) ; if ( ulimit_c < 0 ) { ulimit_c = ~ ( ( off_t ) 1 << ( sizeof ( off_t ) * 8 - 1 ) ) ; } const char * pid_str = argv [ 3 ] ; pid_t pid = xatoi_positive ( argv [ 3 ] ) ; uid_t uid = xatoi_positive ( argv [ 4 ] ) ; if ( errno || pid <= 0 ) { perror_msg_and_die ( ""PID<S2SV_blank>\'%s\'<S2SV_blank>or<S2SV_blank>limit<S2SV_blank>\'%s\'<S2SV_blank>is<S2SV_blank>bogus"" , argv [ 3 ] , argv [ 2 ] ) ; } { char * s = xmalloc_fopen_fgetline_fclose ( VAR_RUN ""/abrt/saved_core_pattern"" ) ; if ( s && s [ 0 ] != '|' ) core_basename = s ; else free ( s ) ; } struct utsname uts ; if ( ! argv [ 8 ] ) { uname ( & uts ) ; argv [ 8 ] = uts . nodename ; } char path [ PATH_MAX ] ; int src_fd_binary = - 1 ; char * executable = get_executable ( pid , setting_SaveBinaryImage ? & src_fd_binary : NULL ) ; if ( executable && strstr ( executable , ""/abrt-hook-ccpp"" ) ) { error_msg_and_die ( ""PID<S2SV_blank>%lu<S2SV_blank>is<S2SV_blank>\'%s\',<S2SV_blank>not<S2SV_blank>dumping<S2SV_blank>it<S2SV_blank>to<S2SV_blank>avoid<S2SV_blank>recursion"" , ( long ) pid , executable ) ; } user_pwd = get_cwd ( pid ) ; log_notice ( ""user_pwd:\'%s\'"" , user_pwd ) ; sprintf ( path , ""/proc/%lu/status"" , ( long ) pid ) ; proc_pid_status = xmalloc_xopen_read_close ( path , NULL ) ; uid_t fsuid = uid ; uid_t tmp_fsuid = get_fsuid ( ) ; int suid_policy = dump_suid_policy ( ) ; if ( tmp_fsuid != uid ) { fsuid = 0 ; if ( suid_policy == DUMP_SUID_UNSAFE ) fsuid = tmp_fsuid ; else { g_user_core_flags = O_EXCL ; g_need_nonrelative = 1 ; } } <S2SV_StartBug> if ( setting_MakeCompatCore && ulimit_c != 0 ) <S2SV_EndBug> user_core_fd = open_user_core ( uid , fsuid , pid , & argv [ 1 ] ) ; if ( executable == NULL ) { error_msg ( ""Can\'t<S2SV_blank>read<S2SV_blank>/proc/%lu/exe<S2SV_blank>link"" , ( long ) pid ) ; goto create_user_core ; } const char * signame = NULL ; switch ( signal_no ) { case SIGILL : signame = ""ILL"" ; break ; case SIGFPE : signame = ""FPE"" ; break ; case SIGSEGV : signame = ""SEGV"" ; break ; case SIGBUS : signame = ""BUS"" ; break ; case SIGABRT : signame = ""ABRT"" ; break ; case SIGTRAP : signame = ""TRAP"" ; break ; default : goto create_user_core ; } if ( ! daemon_is_ok ( ) ) { log ( ""abrtd<S2SV_blank>is<S2SV_blank>not<S2SV_blank>running.<S2SV_blank>If<S2SV_blank>it<S2SV_blank>crashed,<S2SV_blank>"" ""/proc/sys/kernel/core_pattern<S2SV_blank>contains<S2SV_blank>a<S2SV_blank>stale<S2SV_blank>value,<S2SV_blank>"" ""consider<S2SV_blank>resetting<S2SV_blank>it<S2SV_blank>to<S2SV_blank>\'core\'"" ) ; goto create_user_core ; } if ( g_settings_nMaxCrashReportsSize > 0 ) { if ( low_free_space ( g_settings_nMaxCrashReportsSize , g_settings_dump_location ) ) goto create_user_core ; } snprintf ( path , sizeof ( path ) , ""%s/last-ccpp"" , g_settings_dump_location ) ; if ( check_recent_crash_file ( path , executable ) ) { goto create_user_core ; } const char * last_slash = strrchr ( executable , '/' ) ; if ( last_slash && strncmp ( ++ last_slash , ""abrt"" , 4 ) == 0 ) { if ( snprintf ( path , sizeof ( path ) , ""%s/%s-coredump"" , g_settings_dump_location , last_slash ) >= sizeof ( path ) ) error_msg_and_die ( ""Error<S2SV_blank>saving<S2SV_blank>\'%s\':<S2SV_blank>truncated<S2SV_blank>long<S2SV_blank>file<S2SV_blank>path"" , path ) ; int abrt_core_fd = xopen3 ( path , O_WRONLY | O_CREAT | O_TRUNC , 0600 ) ; off_t core_size = copyfd_eof ( STDIN_FILENO , abrt_core_fd , COPYFD_SPARSE ) ; if ( core_size < 0 || fsync ( abrt_core_fd ) != 0 ) { unlink ( path ) ; error_msg_and_die ( ""Error<S2SV_blank>saving<S2SV_blank>\'%s\'"" , path ) ; } log ( ""Saved<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>%lu<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>(%llu<S2SV_blank>bytes)"" , ( long ) pid , executable , path , ( long long ) core_size ) ; if ( proc_cwd != NULL ) closedir ( proc_cwd ) ; return 0 ; } unsigned path_len = snprintf ( path , sizeof ( path ) , ""%s/ccpp-%s-%lu.new"" , g_settings_dump_location , iso_date_string ( NULL ) , ( long ) pid ) ; if ( path_len >= ( sizeof ( path ) - sizeof ( ""/"" FILENAME_COREDUMP ) ) ) { goto create_user_core ; } <S2SV_StartBug> dd = dd_create_skeleton ( path , fsuid , DEFAULT_DUMP_DIR_MODE , 0 ) ; <S2SV_EndBug> if ( dd ) { char * rootdir = get_rootdir ( pid ) ; dd_create_basic_files ( dd , fsuid , NULL ) ; char source_filename [ sizeof ( ""/proc/%lu/somewhat_long_name"" ) + sizeof ( long ) * 3 ] ; int source_base_ofs = sprintf ( source_filename , ""/proc/%lu/smaps"" , ( long ) pid ) ; source_base_ofs -= strlen ( ""smaps"" ) ; char * dest_filename = concat_path_file ( dd -> dd_dirname , ""also_somewhat_longish_name"" ) ; char * dest_base = strrchr ( dest_filename , '/' ) + 1 ; strcpy ( source_filename + source_base_ofs , ""maps"" ) ; strcpy ( dest_base , FILENAME_MAPS ) ; copy_file_ext ( source_filename , dest_filename , 0640 , dd -> dd_uid , dd -> dd_gid , O_RDONLY , O_WRONLY | O_CREAT | O_TRUNC | O_EXCL ) ; strcpy ( source_filename + source_base_ofs , ""limits"" ) ; strcpy ( dest_base , FILENAME_LIMITS ) ; copy_file_ext ( source_filename , dest_filename , 0640 , dd -> dd_uid , dd -> dd_gid , O_RDONLY , O_WRONLY | O_CREAT | O_TRUNC | O_EXCL ) ; strcpy ( source_filename + source_base_ofs , ""cgroup"" ) ; strcpy ( dest_base , FILENAME_CGROUP ) ; copy_file_ext ( source_filename , dest_filename , 0640 , dd -> dd_uid , dd -> dd_gid , O_RDONLY , O_WRONLY | O_CREAT | O_TRUNC | O_EXCL ) ; strcpy ( dest_base , FILENAME_OPEN_FDS ) ; dump_fd_info ( dest_filename , source_filename , source_base_ofs , dd -> dd_uid , dd -> dd_gid ) ; free ( dest_filename ) ; dd_save_text ( dd , FILENAME_ANALYZER , ""CCpp"" ) ; dd_save_text ( dd , FILENAME_TYPE , ""CCpp"" ) ; dd_save_text ( dd , FILENAME_EXECUTABLE , executable ) ; dd_save_text ( dd , FILENAME_PID , pid_str ) ; dd_save_text ( dd , FILENAME_PROC_PID_STATUS , proc_pid_status ) ; if ( user_pwd ) dd_save_text ( dd , FILENAME_PWD , user_pwd ) ; if ( rootdir ) { if ( strcmp ( rootdir , ""/"" ) != 0 ) dd_save_text ( dd , FILENAME_ROOTDIR , rootdir ) ; } char * reason = xasprintf ( ""%s<S2SV_blank>killed<S2SV_blank>by<S2SV_blank>SIG%s"" , last_slash , signame ? signame : signal_str ) ; dd_save_text ( dd , FILENAME_REASON , reason ) ; free ( reason ) ; char * cmdline = get_cmdline ( pid ) ; dd_save_text ( dd , FILENAME_CMDLINE , cmdline ? : """" ) ; free ( cmdline ) ; char * environ = get_environ ( pid ) ; dd_save_text ( dd , FILENAME_ENVIRON , environ ? : """" ) ; free ( environ ) ; char * fips_enabled = xmalloc_fopen_fgetline_fclose ( ""/proc/sys/crypto/fips_enabled"" ) ; if ( fips_enabled ) { if ( strcmp ( fips_enabled , ""0"" ) != 0 ) dd_save_text ( dd , ""fips_enabled"" , fips_enabled ) ; free ( fips_enabled ) ; } dd_save_text ( dd , FILENAME_ABRT_VERSION , VERSION ) ; if ( src_fd_binary > 0 ) { strcpy ( path + path_len , ""/"" FILENAME_BINARY ) ; int dst_fd = create_or_die ( path ) ; off_t sz = copyfd_eof ( src_fd_binary , dst_fd , COPYFD_SPARSE ) ; if ( fsync ( dst_fd ) != 0 || close ( dst_fd ) != 0 || sz < 0 ) { dd_delete ( dd ) ; error_msg_and_die ( ""Error<S2SV_blank>saving<S2SV_blank>\'%s\'"" , path ) ; } close ( src_fd_binary ) ; } strcpy ( path + path_len , ""/"" FILENAME_COREDUMP ) ; int abrt_core_fd = create_or_die ( path ) ; off_t core_size = copyfd_sparse ( STDIN_FILENO , abrt_core_fd , user_core_fd , ulimit_c ) ; if ( fsync ( abrt_core_fd ) != 0 || close ( abrt_core_fd ) != 0 || core_size < 0 ) { unlink ( path ) ; dd_delete ( dd ) ; if ( user_core_fd >= 0 ) unlinkat ( dirfd ( proc_cwd ) , core_basename , 0 ) ; error_msg_and_die ( ""Error<S2SV_blank>writing<S2SV_blank>\'%s\'"" , path ) ; } if ( user_core_fd >= 0 && ( fsync ( user_core_fd ) != 0 || close ( user_core_fd ) != 0 || ( ulimit_c == 0 || core_size > ulimit_c ) ) ) { unlinkat ( dirfd ( proc_cwd ) , core_basename , 0 ) ; } # if 0 { char * java_log = xasprintf ( ""/tmp/jvm-%lu/hs_error.log"" , ( long ) pid ) ; int src_fd = open ( java_log , O_RDONLY ) ; free ( java_log ) ; if ( src_fd < 0 ) { java_log = xasprintf ( ""%s/hs_err_pid%lu.log"" , user_pwd , ( long ) pid ) ; src_fd = open ( java_log , O_RDONLY ) ; free ( java_log ) ; } if ( src_fd >= 0 ) { strcpy ( path + path_len , ""/hs_err.log"" ) ; int dst_fd = create_or_die ( path ) ; off_t sz = copyfd_eof ( src_fd , dst_fd , COPYFD_SPARSE ) ; if ( close ( dst_fd ) != 0 || sz < 0 ) { dd_delete ( dd ) ; error_msg_and_die ( ""Error<S2SV_blank>saving<S2SV_blank>\'%s\'"" , path ) ; } close ( src_fd ) ; } } # endif dd_reset_ownership ( dd ) ; dd_close ( dd ) ; path [ path_len ] = '\\0' ; char * newpath = xstrndup ( path , path_len - ( sizeof ( "".new"" ) - 1 ) ) ; if ( rename ( path , newpath ) == 0 ) strcpy ( path , newpath ) ; free ( newpath ) ; log ( ""Saved<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>%lu<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>(%llu<S2SV_blank>bytes)"" , ( long ) pid , executable , path , ( long long ) core_size ) ; notify_new_path ( path ) ; if ( g_settings_nMaxCrashReportsSize > 0 ) { unsigned maxsize = g_settings_nMaxCrashReportsSize + g_settings_nMaxCrashReportsSize / 4 ; maxsize |= 63 ; trim_problem_dirs ( g_settings_dump_location , maxsize * ( double ) ( 1024 * 1024 ) , path ) ; } free ( rootdir ) ; if ( proc_cwd != NULL ) closedir ( proc_cwd ) ; return 0 ; } create_user_core : if ( user_core_fd >= 0 ) { off_t core_size = copyfd_size ( STDIN_FILENO , user_core_fd , ulimit_c , COPYFD_SPARSE ) ; if ( fsync ( user_core_fd ) != 0 || close ( user_core_fd ) != 0 || core_size < 0 ) { perror_msg ( ""Error<S2SV_blank>writing<S2SV_blank>\'%s\'<S2SV_blank>at<S2SV_blank>\'%s\'"" , core_basename , user_pwd ) ; unlinkat ( dirfd ( proc_cwd ) , core_basename , 0 ) ; if ( proc_cwd != NULL ) closedir ( proc_cwd ) ; return 1 ; } if ( ulimit_c == 0 || core_size > ulimit_c ) { unlinkat ( dirfd ( proc_cwd ) , core_basename , 0 ) ; if ( proc_cwd != NULL ) closedir ( proc_cwd ) ; return 1 ; } log ( ""Saved<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>%lu<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>at<S2SV_blank>%s<S2SV_blank>(%llu<S2SV_blank>bytes)"" , ( long ) pid , core_basename , user_pwd , ( long long ) core_size ) ; } if ( proc_cwd != NULL ) closedir ( proc_cwd ) ; return 0 ; }
","<S2SV_ModStart> ; } } const uid_t dduid = g_settings_privatereports ? 0 : fsuid ; <S2SV_ModStart> ( path , dduid <S2SV_ModEnd> , DEFAULT_DUMP_DIR_MODE ,
"
1075,"CWE-000 <S2SV_StartBug> static ext4_io_end_t * ext4_init_io_end ( struct inode * inode ) <S2SV_EndBug> { ext4_io_end_t * io = NULL ; <S2SV_StartBug> io = kmalloc ( sizeof ( * io ) , GFP_NOFS ) ; <S2SV_EndBug> if ( io ) { igrab ( inode ) ; io -> inode = inode ; io -> flag = 0 ; io -> offset = 0 ; io -> size = 0 ; <S2SV_StartBug> io -> error = 0 ; <S2SV_EndBug> INIT_WORK ( & io -> work , ext4_end_io_work ) ; INIT_LIST_HEAD ( & io -> list ) ; } return io ; }
","<S2SV_ModStart> inode * inode , gfp_t flags <S2SV_ModStart> io ) , flags <S2SV_ModEnd> ) ; if <S2SV_ModStart> ; io -> page = NULL <S2SV_ModEnd> ; INIT_WORK (
"
1076,"CWE-200 static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
","<S2SV_ModStart> ( sk ) ; msg -> msg_namelen = 0
"
1077,"CWE-119 static int tt_s2_4600_frontend_attach ( struct dvb_usb_adapter * adap ) { struct dvb_usb_device * d = adap -> dev ; <S2SV_StartBug> struct dw2102_state * state = d -> priv ; <S2SV_EndBug> u8 obuf [ 3 ] = { 0xe , 0x80 , 0 } ; u8 ibuf [ ] = { 0 } ; struct i2c_adapter * i2c_adapter ; struct i2c_client * client ; struct i2c_board_info board_info ; struct m88ds3103_platform_data m88ds3103_pdata = { } ; struct ts2020_config ts2020_config = { } ; <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ; <S2SV_StartBug> obuf [ 0 ] = 0xe ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = 0x02 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ; msleep ( 300 ) ; <S2SV_StartBug> obuf [ 0 ] = 0xe ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = 0x83 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ; <S2SV_StartBug> obuf [ 0 ] = 0xe ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = 0x83 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ; <S2SV_StartBug> obuf [ 0 ] = 0x51 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 1 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> err ( ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ; <S2SV_EndBug> m88ds3103_pdata . clk = 27000000 ; m88ds3103_pdata . i2c_wr_max = 33 ; m88ds3103_pdata . ts_mode = M88DS3103_TS_CI ; m88ds3103_pdata . ts_clk = 16000 ; m88ds3103_pdata . ts_clk_pol = 0 ; m88ds3103_pdata . spec_inv = 0 ; m88ds3103_pdata . agc = 0x99 ; m88ds3103_pdata . agc_inv = 0 ; m88ds3103_pdata . clk_out = M88DS3103_CLOCK_OUT_ENABLED ; m88ds3103_pdata . envelope_mode = 0 ; m88ds3103_pdata . lnb_hv_pol = 1 ; m88ds3103_pdata . lnb_en_pol = 0 ; memset ( & board_info , 0 , sizeof ( board_info ) ) ; strlcpy ( board_info . type , ""m88ds3103"" , I2C_NAME_SIZE ) ; board_info . addr = 0x68 ; board_info . platform_data = & m88ds3103_pdata ; request_module ( ""m88ds3103"" ) ; client = i2c_new_device ( & d -> i2c_adap , & board_info ) ; if ( client == NULL || client -> dev . driver == NULL ) return - ENODEV ; if ( ! try_module_get ( client -> dev . driver -> owner ) ) { i2c_unregister_device ( client ) ; return - ENODEV ; } adap -> fe_adap [ 0 ] . fe = m88ds3103_pdata . get_dvb_frontend ( client ) ; i2c_adapter = m88ds3103_pdata . get_i2c_adapter ( client ) ; state -> i2c_client_demod = client ; ts2020_config . fe = adap -> fe_adap [ 0 ] . fe ; memset ( & board_info , 0 , sizeof ( board_info ) ) ; strlcpy ( board_info . type , ""ts2022"" , I2C_NAME_SIZE ) ; board_info . addr = 0x60 ; board_info . platform_data = & ts2020_config ; request_module ( ""ts2020"" ) ; client = i2c_new_device ( i2c_adapter , & board_info ) ; if ( client == NULL || client -> dev . driver == NULL ) { dvb_frontend_detach ( adap -> fe_adap [ 0 ] . fe ) ; return - ENODEV ; } if ( ! try_module_get ( client -> dev . driver -> owner ) ) { i2c_unregister_device ( client ) ; dvb_frontend_detach ( adap -> fe_adap [ 0 ] . fe ) ; return - ENODEV ; } adap -> fe_adap [ 0 ] . fe -> ops . read_signal_strength = adap -> fe_adap [ 0 ] . fe -> ops . tuner_ops . get_rf_strength ; state -> i2c_client_tuner = client ; state -> fe_read_status = adap -> fe_adap [ 0 ] . fe -> ops . read_status ; adap -> fe_adap [ 0 ] . fe -> ops . read_status = tt_s2_4600_read_status ; state -> last_lock = 0 ; return 0 ; }
","<S2SV_ModStart> d -> priv <S2SV_ModEnd> ; struct i2c_adapter <S2SV_ModStart> { } ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x80 ; state -> data [ 2 ] = 0x0 ; <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0xe ; state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> = 0x02 ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> 300 ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0xe ; state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> = 0x83 ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0xe ; state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> = 0x83 ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> ( d , state -> data , 1 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> err ( ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ; mutex_unlock ( & d -> data_mutex
"
1078,"CWE-000 int nfs4_open_revalidate ( struct inode * dir , struct dentry * dentry , int openflags , struct nameidata * nd ) { struct path path = { . mnt = nd -> path . mnt , . dentry = dentry , } ; struct rpc_cred * cred ; struct nfs4_state * state ; <S2SV_StartBug> cred = rpc_lookup_cred ( ) ; <S2SV_EndBug> if ( IS_ERR ( cred ) ) return PTR_ERR ( cred ) ; <S2SV_StartBug> state = nfs4_do_open ( dir , & path , openflags , NULL , cred ) ; <S2SV_EndBug> put_rpccred ( cred ) ; if ( IS_ERR ( state ) ) { switch ( PTR_ERR ( state ) ) { case - EPERM : case - EACCES : case - EDQUOT : case - ENOSPC : case - EROFS : lookup_instantiate_filp ( nd , ( struct dentry * ) state , NULL ) ; return 1 ; default : goto out_drop ; } } if ( state -> inode == dentry -> d_inode ) { nfs_set_verifier ( dentry , nfs_save_change_attribute ( dir ) ) ; <S2SV_StartBug> nfs4_intent_set_file ( nd , & path , state ) ; <S2SV_EndBug> return 1 ; } <S2SV_StartBug> nfs4_close_sync ( & path , state , openflags ) ; <S2SV_EndBug> out_drop : d_drop ( dentry ) ; return 0 ; }
","<S2SV_ModStart> * state ; fmode_t fmode = openflags & ( FMODE_READ | FMODE_WRITE ) ; <S2SV_ModStart> , & path , fmode <S2SV_ModStart> path , state , fmode <S2SV_ModStart> , state , fmode <S2SV_ModEnd> ) ; out_drop
"
1079,"CWE-125 static void <S2SV_StartBug> l2tp_msgtype_print ( netdissect_options * ndo , const u_char * dat ) <S2SV_EndBug> { <S2SV_StartBug> const uint16_t * ptr = ( const uint16_t * ) dat ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""%s"" , tok2str ( l2tp_msgtype2str , ""MSGTYPE-#%u"" , EXTRACT_16BITS ( ptr ) ) ) ) ; }
","<S2SV_ModStart> u_char * dat , u_int length <S2SV_ModStart> ) dat ; if ( length < 2 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; }
"
1080,"CWE-125 static int opmov ( RAsm * a , ut8 * data , const Opcode * op ) { int l = 0 ; st64 offset = 0 ; int mod = 0 ; int base = 0 ; int rex = 0 ; ut64 immediate = 0 ; if ( op -> operands [ 1 ] . type & OT_CONSTANT ) { if ( ! op -> operands [ 1 ] . is_good_flag ) { return - 1 ; } if ( op -> operands [ 1 ] . immediate == - 1 ) { return - 1 ; } immediate = op -> operands [ 1 ] . immediate * op -> operands [ 1 ] . sign ; if ( op -> operands [ 0 ] . type & OT_GPREG && ! ( op -> operands [ 0 ] . type & OT_MEMORY ) ) { if ( a -> bits == 64 && ( ( op -> operands [ 0 ] . type & OT_QWORD ) | ( op -> operands [ 1 ] . type & OT_QWORD ) ) ) { if ( ! ( op -> operands [ 1 ] . type & OT_CONSTANT ) && op -> operands [ 1 ] . extended ) { data [ l ++ ] = 0x49 ; } else { data [ l ++ ] = 0x48 ; } } else if ( op -> operands [ 0 ] . extended ) { data [ l ++ ] = 0x41 ; } if ( op -> operands [ 0 ] . type & OT_WORD ) { if ( a -> bits > 16 ) { data [ l ++ ] = 0x66 ; } } if ( op -> operands [ 0 ] . type & OT_BYTE ) { data [ l ++ ] = 0xb0 | op -> operands [ 0 ] . reg ; data [ l ++ ] = immediate ; } else { if ( a -> bits == 64 && ( ( op -> operands [ 0 ] . type & OT_QWORD ) | ( op -> operands [ 1 ] . type & OT_QWORD ) ) && immediate < UT32_MAX ) { data [ l ++ ] = 0xc7 ; data [ l ++ ] = 0xc0 | op -> operands [ 0 ] . reg ; } else { data [ l ++ ] = 0xb8 | op -> operands [ 0 ] . reg ; } data [ l ++ ] = immediate ; data [ l ++ ] = immediate >> 8 ; if ( ! ( op -> operands [ 0 ] . type & OT_WORD ) ) { data [ l ++ ] = immediate >> 16 ; data [ l ++ ] = immediate >> 24 ; } if ( a -> bits == 64 && immediate > UT32_MAX ) { data [ l ++ ] = immediate >> 32 ; data [ l ++ ] = immediate >> 40 ; data [ l ++ ] = immediate >> 48 ; data [ l ++ ] = immediate >> 56 ; } } } else if ( op -> operands [ 0 ] . type & OT_MEMORY ) { if ( ! op -> operands [ 0 ] . explicit_size ) { if ( op -> operands [ 0 ] . type & OT_GPREG ) { ( ( Opcode * ) op ) -> operands [ 0 ] . dest_size = op -> operands [ 0 ] . reg_size ; } else { return - 1 ; } } int dest_bits = 8 * ( ( op -> operands [ 0 ] . dest_size & ALL_SIZE ) >> OPSIZE_SHIFT ) ; int reg_bits = 8 * ( ( op -> operands [ 0 ] . reg_size & ALL_SIZE ) >> OPSIZE_SHIFT ) ; int offset = op -> operands [ 0 ] . offset * op -> operands [ 0 ] . offset_sign ; bool use_aso = false ; if ( reg_bits < a -> bits ) { use_aso = true ; } bool use_oso = false ; if ( dest_bits == 16 ) { use_oso = true ; } bool rip_rel = op -> operands [ 0 ] . regs [ 0 ] == X86R_RIP ; int rex = 1 << 6 ; bool use_rex = false ; if ( dest_bits == 64 ) { use_rex = true ; rex |= 1 << 3 ; } if ( op -> operands [ 0 ] . extended ) { use_rex = true ; rex |= 1 ; } int opcode ; if ( dest_bits == 8 ) { opcode = 0xc6 ; } else { opcode = 0xc7 ; } int modrm = 0 ; int mod ; int reg = 0 ; int rm ; bool use_sib = false ; int sib ; if ( offset == 0 ) { mod = 0 ; } else if ( offset < 128 && offset > - 129 ) { mod = 1 ; } else { mod = 2 ; } if ( reg_bits == 16 ) { if ( op -> operands [ 0 ] . regs [ 0 ] == X86R_BX && op -> operands [ 0 ] . regs [ 1 ] == X86R_SI ) { rm = B0000 ; } else if ( op -> operands [ 0 ] . regs [ 0 ] == X86R_BX && op -> operands [ 0 ] . regs [ 1 ] == X86R_DI ) { rm = B0001 ; } else if ( op -> operands [ 0 ] . regs [ 0 ] == X86R_BP && op -> operands [ 0 ] . regs [ 1 ] == X86R_SI ) { rm = B0010 ; } else if ( op -> operands [ 0 ] . regs [ 0 ] == X86R_BP && op -> operands [ 0 ] . regs [ 1 ] == X86R_DI ) { rm = B0011 ; } else if ( op -> operands [ 0 ] . regs [ 0 ] == X86R_SI && op -> operands [ 0 ] . regs [ 1 ] == - 1 ) { rm = B0100 ; } else if ( op -> operands [ 0 ] . regs [ 0 ] == X86R_DI && op -> operands [ 0 ] . regs [ 1 ] == - 1 ) { rm = B0101 ; } else if ( op -> operands [ 0 ] . regs [ 0 ] == X86R_BX && op -> operands [ 0 ] . regs [ 1 ] == - 1 ) { rm = B0111 ; } else { return - 1 ; } modrm = ( mod << 6 ) | ( reg << 3 ) | rm ; } else { if ( op -> operands [ 0 ] . extended ) { rm = op -> operands [ 0 ] . reg ; } else { rm = op -> operands [ 0 ] . regs [ 0 ] ; } if ( rm == 5 && mod == 0 ) { mod = 1 ; } int index = op -> operands [ 0 ] . regs [ 1 ] ; int scale = getsib ( op -> operands [ 0 ] . scale [ 1 ] ) ; if ( index != - 1 ) { use_sib = true ; sib = ( scale << 6 ) | ( index << 3 ) | rm ; } else if ( rm == 4 ) { use_sib = true ; sib = 0x24 ; } if ( use_sib ) { rm = B0100 ; } if ( rip_rel ) { modrm = ( B0000 << 6 ) | ( reg << 3 ) | B0101 ; sib = ( scale << 6 ) | ( B0100 << 3 ) | B0101 ; } else { modrm = ( mod << 6 ) | ( reg << 3 ) | rm ; } } if ( use_aso ) { data [ l ++ ] = 0x67 ; } if ( use_oso ) { data [ l ++ ] = 0x66 ; } if ( use_rex ) { data [ l ++ ] = rex ; } data [ l ++ ] = opcode ; data [ l ++ ] = modrm ; if ( use_sib ) { data [ l ++ ] = sib ; } if ( mod == 1 ) { data [ l ++ ] = offset ; } else if ( reg_bits == 16 && mod == 2 ) { data [ l ++ ] = offset ; data [ l ++ ] = offset >> 8 ; } else if ( mod == 2 || rip_rel ) { data [ l ++ ] = offset ; data [ l ++ ] = offset >> 8 ; data [ l ++ ] = offset >> 16 ; data [ l ++ ] = offset >> 24 ; } int byte ; for ( byte = 0 ; byte < dest_bits && byte < 32 ; byte += 8 ) { data [ l ++ ] = ( immediate >> byte ) ; } } } else if ( op -> operands [ 1 ] . type & OT_REGALL && ! ( op -> operands [ 1 ] . type & OT_MEMORY ) ) { if ( op -> operands [ 0 ] . type & OT_CONSTANT ) { return - 1 ; } if ( op -> operands [ 0 ] . type & OT_REGTYPE & OT_SEGMENTREG && op -> operands [ 1 ] . type & OT_REGTYPE & OT_SEGMENTREG ) { return - 1 ; } if ( op -> operands [ 0 ] . type & OT_REGTYPE && op -> operands [ 1 ] . type & OT_REGTYPE ) { if ( ! ( ( op -> operands [ 0 ] . type & ALL_SIZE ) & ( op -> operands [ 1 ] . type & ALL_SIZE ) ) ) { return - 1 ; } } if ( a -> bits == 64 ) { if ( op -> operands [ 0 ] . extended ) { rex = 1 ; } if ( op -> operands [ 1 ] . extended ) { rex += 4 ; } if ( op -> operands [ 1 ] . type & OT_QWORD ) { if ( ! ( op -> operands [ 0 ] . type & OT_QWORD ) ) { data [ l ++ ] = 0x67 ; data [ l ++ ] = 0x48 ; } } if ( op -> operands [ 1 ] . type & OT_QWORD && op -> operands [ 0 ] . type & OT_QWORD ) { data [ l ++ ] = 0x48 | rex ; } if ( op -> operands [ 1 ] . type & OT_DWORD && op -> operands [ 0 ] . type & OT_DWORD ) { data [ l ++ ] = 0x40 | rex ; } } else if ( op -> operands [ 0 ] . extended && op -> operands [ 1 ] . extended ) { data [ l ++ ] = 0x45 ; } offset = op -> operands [ 0 ] . offset * op -> operands [ 0 ] . offset_sign ; if ( op -> operands [ 1 ] . type & OT_REGTYPE & OT_SEGMENTREG ) { data [ l ++ ] = 0x8c ; } else { if ( op -> operands [ 0 ] . type & OT_WORD ) { data [ l ++ ] = 0x66 ; } data [ l ++ ] = ( op -> operands [ 0 ] . type & OT_BYTE ) ? 0x88 : 0x89 ; } if ( op -> operands [ 0 ] . scale [ 0 ] > 1 ) { data [ l ++ ] = op -> operands [ 1 ] . reg << 3 | 4 ; data [ l ++ ] = getsib ( op -> operands [ 0 ] . scale [ 0 ] ) << 6 | op -> operands [ 0 ] . regs [ 0 ] << 3 | 5 ; data [ l ++ ] = offset ; data [ l ++ ] = offset >> 8 ; data [ l ++ ] = offset >> 16 ; data [ l ++ ] = offset >> 24 ; return l ; } if ( ! ( op -> operands [ 0 ] . type & OT_MEMORY ) ) { if ( op -> operands [ 0 ] . reg == X86R_UNDEFINED || op -> operands [ 1 ] . reg == X86R_UNDEFINED ) { return - 1 ; } mod = 0x3 ; data [ l ++ ] = mod << 6 | op -> operands [ 1 ] . reg << 3 | op -> operands [ 0 ] . reg ; } else if ( op -> operands [ 0 ] . regs [ 0 ] == X86R_UNDEFINED ) { data [ l ++ ] = op -> operands [ 1 ] . reg << 3 | 0x5 ; data [ l ++ ] = offset ; data [ l ++ ] = offset >> 8 ; data [ l ++ ] = offset >> 16 ; data [ l ++ ] = offset >> 24 ; } else { if ( op -> operands [ 0 ] . type & OT_MEMORY ) { if ( op -> operands [ 0 ] . regs [ 1 ] != X86R_UNDEFINED ) { data [ l ++ ] = op -> operands [ 1 ] . reg << 3 | 0x4 ; data [ l ++ ] = op -> operands [ 0 ] . regs [ 1 ] << 3 | op -> operands [ 0 ] . regs [ 0 ] ; return l ; } if ( offset ) { mod = ( offset > 128 || offset < - 129 ) ? 0x2 : 0x1 ; } if ( op -> operands [ 0 ] . regs [ 0 ] == X86R_EBP ) { mod = 0x2 ; } data [ l ++ ] = mod << 6 | op -> operands [ 1 ] . reg << 3 | op -> operands [ 0 ] . regs [ 0 ] ; if ( op -> operands [ 0 ] . regs [ 0 ] == X86R_ESP ) { data [ l ++ ] = 0x24 ; } if ( offset ) { data [ l ++ ] = offset ; } if ( mod == 2 ) { data [ l ++ ] = offset >> 8 ; data [ l ++ ] = offset >> 16 ; data [ l ++ ] = offset >> 24 ; } } } } else if ( op -> operands [ 1 ] . type & OT_MEMORY ) { if ( op -> operands [ 0 ] . type & OT_MEMORY ) { return - 1 ; } offset = op -> operands [ 1 ] . offset * op -> operands [ 1 ] . offset_sign ; if ( op -> operands [ 0 ] . reg == X86R_EAX && op -> operands [ 1 ] . regs [ 0 ] == X86R_UNDEFINED ) { if ( a -> bits == 64 ) { data [ l ++ ] = 0x48 ; } if ( op -> operands [ 0 ] . type & OT_BYTE ) { data [ l ++ ] = 0xa0 ; } else { data [ l ++ ] = 0xa1 ; } data [ l ++ ] = offset ; data [ l ++ ] = offset >> 8 ; data [ l ++ ] = offset >> 16 ; data [ l ++ ] = offset >> 24 ; if ( a -> bits == 64 ) { data [ l ++ ] = offset >> 32 ; data [ l ++ ] = offset >> 40 ; data [ l ++ ] = offset >> 48 ; data [ l ++ ] = offset >> 54 ; } return l ; } if ( op -> operands [ 0 ] . type & OT_BYTE && a -> bits == 64 && op -> operands [ 1 ] . regs [ 0 ] ) { if ( op -> operands [ 1 ] . regs [ 0 ] >= X86R_R8 && op -> operands [ 0 ] . reg < 4 ) { data [ l ++ ] = 0x41 ; data [ l ++ ] = 0x8a ; data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | ( op -> operands [ 1 ] . regs [ 0 ] - 8 ) ; return l ; } return - 1 ; } if ( op -> operands [ 1 ] . type & OT_REGTYPE & OT_SEGMENTREG ) { if ( op -> operands [ 1 ] . scale [ 0 ] == 0 ) { return - 1 ; } <S2SV_StartBug> data [ l ++ ] = SEG_REG_PREFIXES [ op -> operands [ 1 ] . regs [ 0 ] ] ; <S2SV_EndBug> <S2SV_StartBug> data [ l ++ ] = 0x8b ; <S2SV_EndBug> data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 0x5 ; <S2SV_StartBug> data [ l ++ ] = offset ; <S2SV_EndBug> data [ l ++ ] = offset >> 8 ; data [ l ++ ] = offset >> 16 ; data [ l ++ ] = offset >> 24 ; <S2SV_StartBug> return l ; <S2SV_EndBug> } <S2SV_StartBug> if ( a -> bits == 64 ) { <S2SV_EndBug> if ( op -> operands [ 0 ] . type & OT_QWORD ) { if ( ! ( op -> operands [ 1 ] . type & OT_QWORD ) ) { if ( op -> operands [ 1 ] . regs [ 0 ] != - 1 ) { data [ l ++ ] = 0x67 ; } data [ l ++ ] = 0x48 ; } } else if ( op -> operands [ 1 ] . type & OT_DWORD ) { data [ l ++ ] = 0x44 ; } else if ( ! ( op -> operands [ 1 ] . type & OT_QWORD ) ) { data [ l ++ ] = 0x67 ; } if ( op -> operands [ 1 ] . type & OT_QWORD && op -> operands [ 0 ] . type & OT_QWORD ) { data [ l ++ ] = 0x48 ; } } if ( op -> operands [ 0 ] . type & OT_WORD ) { data [ l ++ ] = 0x66 ; data [ l ++ ] = op -> operands [ 1 ] . type & OT_BYTE ? 0x8a : 0x8b ; } else { data [ l ++ ] = ( op -> operands [ 1 ] . type & OT_BYTE || op -> operands [ 0 ] . type & OT_BYTE ) ? 0x8a : 0x8b ; } if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_UNDEFINED ) { if ( a -> bits == 64 ) { data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 0x4 ; <S2SV_StartBug> data [ l ++ ] = 0x25 ; <S2SV_EndBug> } else { <S2SV_StartBug> data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 0x5 ; <S2SV_EndBug> } data [ l ++ ] = offset ; data [ l ++ ] = offset >> 8 ; data [ l ++ ] = offset >> 16 ; data [ l ++ ] = offset >> 24 ; } else { <S2SV_StartBug> if ( op -> operands [ 1 ] . scale [ 0 ] > 1 ) { <S2SV_EndBug> <S2SV_StartBug> data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 4 ; <S2SV_EndBug> if ( op -> operands [ 1 ] . scale [ 0 ] >= 2 ) { base = 5 ; } if ( base ) { data [ l ++ ] = getsib ( op -> operands [ 1 ] . scale [ 0 ] ) << 6 | op -> operands [ 1 ] . regs [ 0 ] << 3 | base ; } else { data [ l ++ ] = getsib ( op -> operands [ 1 ] . scale [ 0 ] ) << 3 | op -> operands [ 1 ] . regs [ 0 ] ; } if ( offset || base ) { data [ l ++ ] = offset ; data [ l ++ ] = offset >> 8 ; data [ l ++ ] = offset >> 16 ; data [ l ++ ] = offset >> 24 ; } return l ; } if ( op -> operands [ 1 ] . regs [ 1 ] != X86R_UNDEFINED ) { data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 0x4 ; data [ l ++ ] = op -> operands [ 1 ] . regs [ 1 ] << 3 | op -> operands [ 1 ] . regs [ 0 ] ; return l ; } if ( offset || op -> operands [ 1 ] . regs [ 0 ] == X86R_EBP ) { mod = 0x2 ; if ( op -> operands [ 1 ] . offset > 127 ) { mod = 0x4 ; } } if ( a -> bits == 64 && offset && op -> operands [ 0 ] . type & OT_QWORD ) { if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_RIP ) { data [ l ++ ] = 0x5 ; } else { if ( op -> operands [ 1 ] . offset > 127 ) { data [ l ++ ] = 0x80 | op -> operands [ 0 ] . reg << 3 | op -> operands [ 1 ] . regs [ 0 ] ; } else { data [ l ++ ] = 0x40 | op -> operands [ 1 ] . regs [ 0 ] ; } } if ( op -> operands [ 1 ] . offset > 127 ) { mod = 0x1 ; } } else { if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_EIP && ( op -> operands [ 0 ] . type & OT_DWORD ) ) { data [ l ++ ] = 0x0d ; } else if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_RIP && ( op -> operands [ 0 ] . type & OT_QWORD ) ) { data [ l ++ ] = 0x05 ; } else { data [ l ++ ] = mod << 5 | op -> operands [ 0 ] . reg << 3 | op -> operands [ 1 ] . regs [ 0 ] ; } } if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_ESP ) { data [ l ++ ] = 0x24 ; } if ( mod >= 0x2 ) { data [ l ++ ] = offset ; if ( op -> operands [ 1 ] . offset > 128 || op -> operands [ 1 ] . regs [ 0 ] == X86R_EIP ) { data [ l ++ ] = offset >> 8 ; data [ l ++ ] = offset >> 16 ; data [ l ++ ] = offset >> 24 ; } } else if ( a -> bits == 64 && ( offset || op -> operands [ 1 ] . regs [ 0 ] == X86R_RIP ) ) { data [ l ++ ] = offset ; if ( op -> operands [ 1 ] . offset > 127 || op -> operands [ 1 ] . regs [ 0 ] == X86R_RIP ) { data [ l ++ ] = offset >> 8 ; data [ l ++ ] = offset >> 16 ; data [ l ++ ] = offset >> 24 ; } } } } return l ; }
","<S2SV_ModStart> [ 0 ] % 6 <S2SV_ModStart> = 0x8b ; data [ l ++ ] = ( ( ( ut32 ) op -> operands [ 0 ] . reg ) << 3 ) | 0x5 ; data [ l ++ ] = offset ; data [ l ++ ] = offset >> 8 ; data [ l ++ ] = offset >> 16 ; data [ l ++ ] = offset >> 24 ; return l ; } if ( a -> bits == 64 ) { if ( op -> operands [ 0 ] . type & OT_QWORD ) { if ( ! ( op -> operands [ 1 ] . type & OT_QWORD ) ) { if ( op -> operands [ 1 ] . regs [ 0 ] != - 1 ) { data [ l ++ ] = 0x67 ; } data [ l ++ ] = 0x48 ; } } else if ( op -> operands [ 1 ] . type & OT_DWORD ) { data [ l ++ ] = 0x44 ; } else if ( ! ( op -> operands [ 1 ] . type & OT_QWORD ) ) { data [ l ++ ] = 0x67 ; } if ( op -> operands [ 1 ] . type & OT_QWORD && op -> operands [ 0 ] . type & OT_QWORD ) { data [ l ++ ] = 0x48 ; } } if ( op -> operands [ 0 ] . type & OT_WORD ) { data [ l ++ ] = 0x66 ; data [ l ++ ] = op -> operands [ 1 ] . type & OT_BYTE ? 0x8a : 0x8b ; } else { data [ l ++ ] = ( op -> operands [ 1 ] . type & OT_BYTE || op -> operands [ 0 ] . type & OT_BYTE ) ? 0x8a : 0x8b ; } if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_UNDEFINED ) { if ( a -> bits == 64 ) { data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 0x4 ; data [ l ++ ] = 0x25 ; } else { <S2SV_ModStart> | 0x5 ; } <S2SV_ModStart> >> 24 ; } else { if ( op -> operands [ 1 ] . scale [ 0 ] > 1 ) { data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 4 ; if ( op -> operands [ 1 ] . scale [ 0 ] >= 2 ) { base = 5 ; } if ( base ) { data [ l ++ ] = getsib ( op -> operands [ 1 ] . scale [ 0 ] ) << 6 | op -> operands [ 1 ] . regs [ 0 ] << 3 | base ; } else { data [ l ++ ] = getsib ( op -> operands [ 1 ] . scale [ 0 ] ) << 3 | op -> operands [ 1 ] . regs [ 0 ] ; } if ( offset || base ) { data [ l ++ ] = offset ; data [ l ++ ] = offset >> 8 ; data [ l ++ ] = offset >> 16 ; data [ l ++ ] = offset >> 24 ; } <S2SV_ModStart> } if ( op -> operands [ 1 ] . regs [ 1 ] != X86R_UNDEFINED <S2SV_ModEnd> ) { data <S2SV_ModStart> ++ ] = op -> operands [ 1 ] . regs [ 1 ] << 3 | op -> operands [ 1 ] . regs [ 0 ] ; return l ; } if ( offset || op -> operands [ 1 ] . regs [ 0 ] == X86R_EBP ) { mod = 0x2 ; if ( op -> operands [ 1 ] . offset > 127 ) { mod = 0x4 ; } } if ( a -> bits == 64 && offset && op -> operands [ 0 ] . type & OT_QWORD ) { if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_RIP ) { data [ l ++ ] = 0x5 <S2SV_ModEnd> ; } else <S2SV_ModStart> } else { if ( op -> operands [ 1 ] . offset > 127 ) { data [ l ++ ] = 0x80 | <S2SV_ModEnd> op -> operands <S2SV_ModStart> << 3 | op -> operands [ 1 ] . regs [ 0 ] <S2SV_ModEnd> ; } else <S2SV_ModStart> } else { data [ l ++ ] = 0x40 | op -> operands [ 1 ] . regs [ 0 ] ; } } if ( op -> operands [ 1 ] . offset > 127 ) { mod = 0x1 ; } } else { if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_EIP && ( op -> operands [ 0 ] . type & OT_DWORD ) ) { data [ l ++ ] = 0x0d ; } else if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_RIP && ( op -> operands [ 0 ] . type & OT_QWORD ) ) { data [ l ++ ] = 0x05 ; } else { data [ l ++ ] = mod << 5 | <S2SV_ModEnd> op -> operands <S2SV_ModStart> << 3 | <S2SV_ModEnd> op -> operands
"
1081,"CWE-119 int copy_creds ( struct task_struct * p , unsigned long clone_flags ) { # ifdef CONFIG_KEYS struct thread_group_cred * tgcred ; # endif struct cred * new ; int ret ; <S2SV_StartBug> if ( <S2SV_EndBug> # ifdef CONFIG_KEYS ! p -> cred -> thread_keyring && # endif clone_flags & CLONE_THREAD ) { p -> real_cred = get_cred ( p -> cred ) ; get_cred ( p -> cred ) ; alter_cred_subscribers ( p -> cred , 2 ) ; kdebug ( ""share_creds(%p{%d,%d})"" , p -> cred , atomic_read ( & p -> cred -> usage ) , read_cred_subscribers ( p -> cred ) ) ; atomic_inc ( & p -> cred -> user -> processes ) ; return 0 ; } new = prepare_creds ( ) ; if ( ! new ) return - ENOMEM ; if ( clone_flags & CLONE_NEWUSER ) { ret = create_user_ns ( new ) ; if ( ret < 0 ) goto error_put ; } new -> user_ns = new -> user -> user_ns ; # ifdef CONFIG_KEYS if ( new -> thread_keyring ) { key_put ( new -> thread_keyring ) ; new -> thread_keyring = NULL ; if ( clone_flags & CLONE_THREAD ) install_thread_keyring_to_cred ( new ) ; } if ( ! ( clone_flags & CLONE_THREAD ) ) { tgcred = kmalloc ( sizeof ( * tgcred ) , GFP_KERNEL ) ; if ( ! tgcred ) { ret = - ENOMEM ; goto error_put ; } atomic_set ( & tgcred -> usage , 1 ) ; spin_lock_init ( & tgcred -> lock ) ; tgcred -> process_keyring = NULL ; tgcred -> session_keyring = key_get ( new -> tgcred -> session_keyring ) ; release_tgcred ( new ) ; new -> tgcred = tgcred ; } # endif atomic_inc ( & new -> user -> processes ) ; p -> cred = p -> real_cred = get_cred ( new ) ; alter_cred_subscribers ( new , 2 ) ; validate_creds ( new ) ; return 0 ; error_put : put_cred ( new ) ; return ret ; }
","<S2SV_ModStart> int ret ; p -> replacement_session_keyring = NULL ;
"
1082,"CWE-119 static void update_mbgraph_mb_stats ( VP9_COMP * cpi , MBGRAPH_MB_STATS * stats , YV12_BUFFER_CONFIG * buf , int mb_y_offset , YV12_BUFFER_CONFIG * golden_ref , <S2SV_StartBug> int_mv * prev_golden_ref_mv , <S2SV_EndBug> YV12_BUFFER_CONFIG * alt_ref , int mb_row , int mb_col ) { <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> MACROBLOCKD * const xd = & x -> e_mbd ; int intra_error ; VP9_COMMON * cm = & cpi -> common ; x -> plane [ 0 ] . src . buf = buf -> y_buffer + mb_y_offset ; x -> plane [ 0 ] . src . stride = buf -> y_stride ; xd -> plane [ 0 ] . dst . buf = get_frame_new_buffer ( cm ) -> y_buffer + mb_y_offset ; xd -> plane [ 0 ] . dst . stride = get_frame_new_buffer ( cm ) -> y_stride ; intra_error = find_best_16x16_intra ( cpi , & stats -> ref [ INTRA_FRAME ] . m . mode ) ; if ( intra_error <= 0 ) intra_error = 1 ; stats -> ref [ INTRA_FRAME ] . err = intra_error ; if ( golden_ref ) { int g_motion_error ; xd -> plane [ 0 ] . pre [ 0 ] . buf = golden_ref -> y_buffer + mb_y_offset ; xd -> plane [ 0 ] . pre [ 0 ] . stride = golden_ref -> y_stride ; g_motion_error = do_16x16_motion_search ( cpi , prev_golden_ref_mv , & stats -> ref [ GOLDEN_FRAME ] . m . mv , mb_row , mb_col ) ; stats -> ref [ GOLDEN_FRAME ] . err = g_motion_error ; } else { stats -> ref [ GOLDEN_FRAME ] . err = INT_MAX ; stats -> ref [ GOLDEN_FRAME ] . m . mv . as_int = 0 ; } if ( alt_ref ) { int a_motion_error ; xd -> plane [ 0 ] . pre [ 0 ] . buf = alt_ref -> y_buffer + mb_y_offset ; xd -> plane [ 0 ] . pre [ 0 ] . stride = alt_ref -> y_stride ; a_motion_error = do_16x16_zerozero_search ( cpi , & stats -> ref [ ALTREF_FRAME ] . m . mv ) ; stats -> ref [ ALTREF_FRAME ] . err = a_motion_error ; } else { stats -> ref [ ALTREF_FRAME ] . err = INT_MAX ; stats -> ref [ ALTREF_FRAME ] . m . mv . as_int = 0 ; } }
","<S2SV_ModStart> * golden_ref , const MV <S2SV_ModEnd> * prev_golden_ref_mv , <S2SV_ModStart> & cpi -> td .
"
1083,"CWE-264 static __init int hardware_setup ( void ) { int r = - ENOMEM , i , msr ; rdmsrl_safe ( MSR_EFER , & host_efer ) ; for ( i = 0 ; i < ARRAY_SIZE ( vmx_msr_index ) ; ++ i ) kvm_define_shared_msr ( i , vmx_msr_index [ i ] ) ; vmx_io_bitmap_a = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_io_bitmap_a ) return r ; vmx_io_bitmap_b = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_io_bitmap_b ) goto out ; vmx_msr_bitmap_legacy = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_msr_bitmap_legacy ) goto out1 ; vmx_msr_bitmap_legacy_x2apic = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_msr_bitmap_legacy_x2apic ) goto out2 ; vmx_msr_bitmap_longmode = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_msr_bitmap_longmode ) goto out3 ; vmx_msr_bitmap_longmode_x2apic = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_msr_bitmap_longmode_x2apic ) goto out4 ; if ( nested ) { vmx_msr_bitmap_nested = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_msr_bitmap_nested ) goto out5 ; } vmx_vmread_bitmap = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_vmread_bitmap ) goto out6 ; vmx_vmwrite_bitmap = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_vmwrite_bitmap ) goto out7 ; memset ( vmx_vmread_bitmap , 0xff , PAGE_SIZE ) ; memset ( vmx_vmwrite_bitmap , 0xff , PAGE_SIZE ) ; memset ( vmx_io_bitmap_a , 0xff , PAGE_SIZE ) ; clear_bit ( 0x80 , vmx_io_bitmap_a ) ; memset ( vmx_io_bitmap_b , 0xff , PAGE_SIZE ) ; memset ( vmx_msr_bitmap_legacy , 0xff , PAGE_SIZE ) ; memset ( vmx_msr_bitmap_longmode , 0xff , PAGE_SIZE ) ; if ( nested ) memset ( vmx_msr_bitmap_nested , 0xff , PAGE_SIZE ) ; if ( setup_vmcs_config ( & vmcs_config ) < 0 ) { r = - EIO ; goto out8 ; } if ( boot_cpu_has ( X86_FEATURE_NX ) ) kvm_enable_efer_bits ( EFER_NX ) ; if ( ! cpu_has_vmx_vpid ( ) ) enable_vpid = 0 ; if ( ! cpu_has_vmx_shadow_vmcs ( ) ) enable_shadow_vmcs = 0 ; if ( enable_shadow_vmcs ) init_vmcs_shadow_fields ( ) ; if ( ! cpu_has_vmx_ept ( ) || ! cpu_has_vmx_ept_4levels ( ) ) { enable_ept = 0 ; enable_unrestricted_guest = 0 ; enable_ept_ad_bits = 0 ; } if ( ! cpu_has_vmx_ept_ad_bits ( ) ) enable_ept_ad_bits = 0 ; if ( ! cpu_has_vmx_unrestricted_guest ( ) ) enable_unrestricted_guest = 0 ; if ( ! cpu_has_vmx_flexpriority ( ) ) flexpriority_enabled = 0 ; if ( ! flexpriority_enabled ) kvm_x86_ops -> set_apic_access_page_addr = NULL ; if ( ! cpu_has_vmx_tpr_shadow ( ) ) kvm_x86_ops -> update_cr8_intercept = NULL ; if ( enable_ept && ! cpu_has_vmx_ept_2m_page ( ) ) kvm_disable_largepages ( ) ; if ( ! cpu_has_vmx_ple ( ) ) ple_gap = 0 ; if ( ! cpu_has_vmx_apicv ( ) ) enable_apicv = 0 ; if ( cpu_has_vmx_tsc_scaling ( ) ) { kvm_has_tsc_control = true ; kvm_max_tsc_scaling_ratio = KVM_VMX_TSC_MULTIPLIER_MAX ; kvm_tsc_scaling_ratio_frac_bits = 48 ; } vmx_disable_intercept_for_msr ( MSR_FS_BASE , false ) ; vmx_disable_intercept_for_msr ( MSR_GS_BASE , false ) ; vmx_disable_intercept_for_msr ( MSR_KERNEL_GS_BASE , true ) ; vmx_disable_intercept_for_msr ( MSR_IA32_SYSENTER_CS , false ) ; vmx_disable_intercept_for_msr ( MSR_IA32_SYSENTER_ESP , false ) ; vmx_disable_intercept_for_msr ( MSR_IA32_SYSENTER_EIP , false ) ; vmx_disable_intercept_for_msr ( MSR_IA32_BNDCFGS , true ) ; memcpy ( vmx_msr_bitmap_legacy_x2apic , vmx_msr_bitmap_legacy , PAGE_SIZE ) ; memcpy ( vmx_msr_bitmap_longmode_x2apic , vmx_msr_bitmap_longmode , PAGE_SIZE ) ; set_bit ( 0 , vmx_vpid_bitmap ) ; <S2SV_StartBug> if ( enable_apicv ) { <S2SV_EndBug> for ( msr = 0x800 ; msr <= 0x8ff ; msr ++ ) vmx_disable_intercept_msr_read_x2apic ( msr ) ; vmx_enable_intercept_msr_read_x2apic ( 0x802 ) ; vmx_enable_intercept_msr_read_x2apic ( 0x839 ) ; vmx_disable_intercept_msr_write_x2apic ( 0x808 ) ; vmx_disable_intercept_msr_write_x2apic ( 0x80b ) ; vmx_disable_intercept_msr_write_x2apic ( 0x83f ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( enable_ept ) { kvm_mmu_set_mask_ptes ( 0ull , ( enable_ept_ad_bits ) ? VMX_EPT_ACCESS_BIT : 0ull , ( enable_ept_ad_bits ) ? VMX_EPT_DIRTY_BIT : 0ull , 0ull , VMX_EPT_EXECUTABLE_MASK ) ; ept_set_mmio_spte_mask ( ) ; kvm_enable_tdp ( ) ; } else kvm_disable_tdp ( ) ; update_ple_window_actual_max ( ) ; if ( ! enable_ept || ! enable_ept_ad_bits || ! cpu_has_vmx_pml ( ) ) enable_pml = 0 ; if ( ! enable_pml ) { kvm_x86_ops -> slot_enable_log_dirty = NULL ; kvm_x86_ops -> slot_disable_log_dirty = NULL ; kvm_x86_ops -> flush_log_dirty = NULL ; kvm_x86_ops -> enable_log_dirty_pt_masked = NULL ; } kvm_set_posted_intr_wakeup_handler ( wakeup_handler ) ; return alloc_kvm_area ( ) ; out8 : free_page ( ( unsigned long ) vmx_vmwrite_bitmap ) ; out7 : free_page ( ( unsigned long ) vmx_vmread_bitmap ) ; out6 : if ( nested ) free_page ( ( unsigned long ) vmx_msr_bitmap_nested ) ; out5 : free_page ( ( unsigned long ) vmx_msr_bitmap_longmode_x2apic ) ; out4 : free_page ( ( unsigned long ) vmx_msr_bitmap_longmode ) ; out3 : free_page ( ( unsigned long ) vmx_msr_bitmap_legacy_x2apic ) ; out2 : free_page ( ( unsigned long ) vmx_msr_bitmap_legacy ) ; out1 : free_page ( ( unsigned long ) vmx_io_bitmap_b ) ; out : free_page ( ( unsigned long ) vmx_io_bitmap_a ) ; return r ; }
","<S2SV_ModStart> vmx_vpid_bitmap ) ; <S2SV_ModEnd> for ( msr <S2SV_ModStart> 0x83f ) ; <S2SV_ModEnd> if ( enable_ept
"
1084,"CWE-119 static int g2m_init_buffers ( G2MContext * c ) { int aligned_height ; if ( ! c -> framebuf || c -> old_width < c -> width || c -> old_height < c -> height ) { <S2SV_StartBug> c -> framebuf_stride = FFALIGN ( c -> width * 3 , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> aligned_height = FFALIGN ( c -> height , 16 ) ; <S2SV_EndBug> av_free ( c -> framebuf ) ; c -> framebuf = av_mallocz ( c -> framebuf_stride * aligned_height ) ; if ( ! c -> framebuf ) return AVERROR ( ENOMEM ) ; } if ( ! c -> synth_tile || ! c -> jpeg_tile || c -> old_tile_w < c -> tile_width || c -> old_tile_h < c -> tile_height ) { c -> tile_stride = FFALIGN ( c -> tile_width , 16 ) * 3 ; aligned_height = FFALIGN ( c -> tile_height , 16 ) ; av_free ( c -> synth_tile ) ; av_free ( c -> jpeg_tile ) ; av_free ( c -> kempf_buf ) ; av_free ( c -> kempf_flags ) ; c -> synth_tile = av_mallocz ( c -> tile_stride * aligned_height ) ; c -> jpeg_tile = av_mallocz ( c -> tile_stride * aligned_height ) ; c -> kempf_buf = av_mallocz ( ( c -> tile_width + 1 ) * aligned_height + FF_INPUT_BUFFER_PADDING_SIZE ) ; c -> kempf_flags = av_mallocz ( c -> tile_width * aligned_height ) ; if ( ! c -> synth_tile || ! c -> jpeg_tile || ! c -> kempf_buf || ! c -> kempf_flags ) return AVERROR ( ENOMEM ) ; } return 0 ; }
","<S2SV_ModStart> c -> width + 15 <S2SV_ModEnd> , 16 ) <S2SV_ModStart> , 16 ) * 3 ; aligned_height = <S2SV_ModEnd> c -> height <S2SV_ModStart> c -> height + 15 <S2SV_ModEnd> ; av_free (
"
1085,"CWE-119 <S2SV_StartBug> static void predict_and_reconstruct_intra_block ( int plane , int block , <S2SV_EndBug> BLOCK_SIZE plane_bsize , <S2SV_StartBug> TX_SIZE tx_size , void * arg ) { <S2SV_EndBug> struct intra_args * const args = ( struct intra_args * ) arg ; VP9_COMMON * const cm = args -> cm ; MACROBLOCKD * const xd = args -> xd ; struct macroblockd_plane * const pd = & xd -> plane [ plane ] ; <S2SV_StartBug> MODE_INFO * const mi = xd -> mi [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> const MB_PREDICTION_MODE mode = ( plane == 0 ) ? get_y_mode ( mi , block ) <S2SV_EndBug> : mi -> mbmi . uv_mode ; int x , y ; uint8_t * dst ; <S2SV_StartBug> txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & x , & y ) ; <S2SV_EndBug> <S2SV_StartBug> dst = & pd -> dst . buf [ 4 * y * pd -> dst . stride + 4 * x ] ; <S2SV_EndBug> <S2SV_StartBug> vp9_predict_intra_block ( xd , block >> ( tx_size << 1 ) , <S2SV_EndBug> b_width_log2 ( plane_bsize ) , tx_size , mode , dst , pd -> dst . stride , dst , pd -> dst . stride , x , y , plane ) ; <S2SV_StartBug> if ( ! mi -> mbmi . skip ) { <S2SV_EndBug> <S2SV_StartBug> const int eob = vp9_decode_block_tokens ( cm , xd , plane , block , <S2SV_EndBug> plane_bsize , x , y , tx_size , args -> r ) ; inverse_transform_block ( xd , plane , block , tx_size , dst , pd -> dst . stride , eob ) ; } }
","<S2SV_ModStart> void predict_and_reconstruct_intra_block ( MACROBLOCKD * const xd , vpx_reader * r , MB_MODE_INFO * const mbmi , int plane , int row , int col <S2SV_ModEnd> , TX_SIZE tx_size <S2SV_ModStart> , TX_SIZE tx_size ) { <S2SV_ModEnd> struct macroblockd_plane * <S2SV_ModStart> plane ] ; PREDICTION_MODE <S2SV_ModEnd> mode = ( <S2SV_ModStart> 0 ) ? mbmi -> mode : mbmi -> uv_mode ; <S2SV_ModEnd> uint8_t * dst <S2SV_ModStart> * dst ; <S2SV_ModEnd> dst = & <S2SV_ModStart> [ 4 * row <S2SV_ModEnd> * pd -> <S2SV_ModStart> + 4 * col ] ; if ( mbmi -> sb_type < BLOCK_8X8 ) if ( plane == 0 ) mode = xd -> mi [ 0 ] -> bmi [ ( row <S2SV_ModEnd> << 1 ) <S2SV_ModStart> << 1 ) + col ] . as_mode ; vp9_predict_intra_block ( xd , pd -> n4_wl , tx_size , mode , dst , pd -> dst . stride , dst , pd -> dst . stride , col , row <S2SV_ModEnd> , plane ) <S2SV_ModStart> if ( ! mbmi -> <S2SV_ModEnd> skip ) { <S2SV_ModStart> ) { const TX_TYPE tx_type = ( plane || xd -> lossless ) ? DCT_DCT : intra_mode_to_tx_type_lookup [ mode ] ; const scan_order * sc = ( plane || xd -> lossless ) ? & vp9_default_scan_orders [ tx_size ] : & vp9_scan_orders [ tx_size ] [ tx_type ] ; const <S2SV_ModStart> = vp9_decode_block_tokens ( xd , plane , sc , col , row , tx_size , r , mbmi -> segment_id ) ; inverse_transform_block_intra ( xd , plane , tx_type , tx_size , dst , pd -> dst . stride , <S2SV_ModEnd> eob ) ;
"
1086,"CWE-476 static int stv06xx_isoc_init ( struct gspca_dev * gspca_dev ) <S2SV_StartBug> { <S2SV_EndBug> struct usb_host_interface * alt ; struct sd * sd = ( struct sd * ) gspca_dev ; <S2SV_StartBug> alt = & gspca_dev -> dev -> actconfig -> intf_cache [ 0 ] -> altsetting [ 1 ] ; <S2SV_EndBug> alt -> endpoint [ 0 ] . desc . wMaxPacketSize = cpu_to_le16 ( sd -> sensor -> max_packet_size [ gspca_dev -> curr_mode ] ) ; return 0 ; }
","<S2SV_ModStart> gspca_dev ) { struct usb_interface_cache * intfc ; <S2SV_ModStart> ) gspca_dev ; intfc = <S2SV_ModEnd> gspca_dev -> dev <S2SV_ModStart> [ 0 ] ; if ( intfc -> num_altsetting < 2 ) return - ENODEV ; alt = & intfc <S2SV_ModStart> [ 1 ] ; if ( alt -> desc . bNumEndpoints < 1 ) return - ENODEV
"
1087,"CWE-476 av_cold void ff_idctdsp_init ( IDCTDSPContext * c , AVCodecContext * avctx ) { const unsigned high_bit_depth = avctx -> bits_per_raw_sample > 8 ; if ( avctx -> lowres == 1 ) { c -> idct_put = ff_jref_idct4_put ; c -> idct_add = ff_jref_idct4_add ; c -> idct = ff_j_rev_dct4 ; c -> perm_type = FF_IDCT_PERM_NONE ; } else if ( avctx -> lowres == 2 ) { c -> idct_put = ff_jref_idct2_put ; c -> idct_add = ff_jref_idct2_add ; c -> idct = ff_j_rev_dct2 ; c -> perm_type = FF_IDCT_PERM_NONE ; } else if ( avctx -> lowres == 3 ) { c -> idct_put = ff_jref_idct1_put ; c -> idct_add = ff_jref_idct1_add ; c -> idct = ff_j_rev_dct1 ; c -> perm_type = FF_IDCT_PERM_NONE ; } else { if ( avctx -> bits_per_raw_sample == 10 || avctx -> bits_per_raw_sample == 9 ) { <S2SV_StartBug> if ( avctx -> codec_id == AV_CODEC_ID_MPEG4 && avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) <S2SV_EndBug> c -> idct_put = ff_simple_idct_put_int32_10bit ; else { c -> idct_put = ff_simple_idct_put_int16_10bit ; c -> idct_add = ff_simple_idct_add_int16_10bit ; c -> idct = ff_simple_idct_int16_10bit ; } c -> perm_type = FF_IDCT_PERM_NONE ; } else if ( avctx -> bits_per_raw_sample == 12 ) { c -> idct_put = ff_simple_idct_put_int16_12bit ; c -> idct_add = ff_simple_idct_add_int16_12bit ; c -> idct = ff_simple_idct_int16_12bit ; c -> perm_type = FF_IDCT_PERM_NONE ; } else { if ( avctx -> idct_algo == FF_IDCT_INT ) { c -> idct_put = ff_jref_idct_put ; c -> idct_add = ff_jref_idct_add ; c -> idct = ff_j_rev_dct ; c -> perm_type = FF_IDCT_PERM_LIBMPEG2 ; # if CONFIG_FAANIDCT } else if ( avctx -> idct_algo == FF_IDCT_FAAN ) { c -> idct_put = ff_faanidct_put ; c -> idct_add = ff_faanidct_add ; c -> idct = ff_faanidct ; c -> perm_type = FF_IDCT_PERM_NONE ; # endif } else { c -> idct_put = ff_simple_idct_put_int16_8bit ; c -> idct_add = ff_simple_idct_add_int16_8bit ; c -> idct = ff_simple_idct_int16_8bit ; c -> perm_type = FF_IDCT_PERM_NONE ; } } } c -> put_pixels_clamped = ff_put_pixels_clamped_c ; c -> put_signed_pixels_clamped = put_signed_pixels_clamped_c ; c -> add_pixels_clamped = ff_add_pixels_clamped_c ; if ( CONFIG_MPEG4_DECODER && avctx -> idct_algo == FF_IDCT_XVID ) ff_xvid_idct_init ( c , avctx ) ; if ( ARCH_AARCH64 ) ff_idctdsp_init_aarch64 ( c , avctx , high_bit_depth ) ; if ( ARCH_ALPHA ) ff_idctdsp_init_alpha ( c , avctx , high_bit_depth ) ; if ( ARCH_ARM ) ff_idctdsp_init_arm ( c , avctx , high_bit_depth ) ; if ( ARCH_PPC ) ff_idctdsp_init_ppc ( c , avctx , high_bit_depth ) ; if ( ARCH_X86 ) ff_idctdsp_init_x86 ( c , avctx , high_bit_depth ) ; if ( ARCH_MIPS ) ff_idctdsp_init_mips ( c , avctx , high_bit_depth ) ; ff_init_scantable_permutation ( c -> idct_permutation , c -> perm_type ) ; }
","<S2SV_ModStart> { if ( c -> mpeg4_studio_profile <S2SV_ModEnd> ) c ->
"
1088,"CWE-119 int main ( int argc , char * * argv ) { FILE * infile , * outfile [ NUM_ENCODERS ] ; <S2SV_StartBug> vpx_codec_ctx_t codec [ NUM_ENCODERS ] ; <S2SV_EndBug> vpx_codec_enc_cfg_t cfg [ NUM_ENCODERS ] ; <S2SV_StartBug> vpx_codec_pts_t frame_cnt = 0 ; <S2SV_EndBug> vpx_image_t raw [ NUM_ENCODERS ] ; vpx_codec_err_t res [ NUM_ENCODERS ] ; int i ; long width ; long height ; <S2SV_StartBug> int frame_avail ; <S2SV_EndBug> int got_data ; int flags = 0 ; <S2SV_StartBug> int arg_deadline = VPX_DL_REALTIME ; <S2SV_EndBug> int show_psnr = 0 ; <S2SV_StartBug> uint64_t psnr_sse_total [ NUM_ENCODERS ] = { 0 } ; <S2SV_EndBug> uint64_t psnr_samples_total [ NUM_ENCODERS ] = { 0 } ; double psnr_totals [ NUM_ENCODERS ] [ 4 ] = { { 0 , 0 } } ; <S2SV_StartBug> int psnr_count [ NUM_ENCODERS ] = { 0 } ; <S2SV_EndBug> unsigned int target_bitrate [ NUM_ENCODERS ] = { 1000 , 500 , 100 } ; int framerate = 30 ; vpx_rational_t dsf [ NUM_ENCODERS ] = { { 2 , 1 } , { 2 , 1 } , { 1 , 1 } } ; <S2SV_StartBug> if ( argc != ( 5 + NUM_ENCODERS ) ) <S2SV_EndBug> <S2SV_StartBug> die ( ""Usage:<S2SV_blank>%s<S2SV_blank><width><S2SV_blank><height><S2SV_blank><infile><S2SV_blank><outfile(s)><S2SV_blank><output<S2SV_blank>psnr?>\\n"" , <S2SV_EndBug> argv [ 0 ] ) ; printf ( ""Using<S2SV_blank>%s\\n"" , vpx_codec_iface_name ( interface ) ) ; width = strtol ( argv [ 1 ] , NULL , 0 ) ; <S2SV_StartBug> height = strtol ( argv [ 2 ] , NULL , 0 ) ; <S2SV_EndBug> if ( width < 16 || width % 2 || height < 16 || height % 2 ) die ( ""Invalid<S2SV_blank>resolution:<S2SV_blank>%ldx%ld"" , width , height ) ; <S2SV_StartBug> if ( ! ( infile = fopen ( argv [ 3 ] , ""rb"" ) ) ) <S2SV_EndBug> <S2SV_StartBug> die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading"" , argv [ 3 ] ) ; <S2SV_EndBug> for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) { if ( ! target_bitrate [ i ] ) { outfile [ i ] = NULL ; continue ; } <S2SV_StartBug> if ( ! ( outfile [ i ] = fopen ( argv [ i + 4 ] , ""wb"" ) ) ) <S2SV_EndBug> die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing"" , argv [ i + 4 ] ) ; } <S2SV_StartBug> show_psnr = strtol ( argv [ NUM_ENCODERS + 4 ] , NULL , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) <S2SV_EndBug> { <S2SV_StartBug> res [ i ] = vpx_codec_enc_config_default ( interface , & cfg [ i ] , 0 ) ; <S2SV_EndBug> if ( res [ i ] ) { printf ( ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>config:<S2SV_blank>%s\\n"" , vpx_codec_err_to_string ( res [ i ] ) ) ; return EXIT_FAILURE ; } <S2SV_StartBug> } <S2SV_EndBug> cfg [ 0 ] . g_w = width ; cfg [ 0 ] . g_h = height ; <S2SV_StartBug> cfg [ 0 ] . g_threads = 1 ; <S2SV_EndBug> cfg [ 0 ] . rc_dropframe_thresh = 30 ; cfg [ 0 ] . rc_end_usage = VPX_CBR ; cfg [ 0 ] . rc_resize_allowed = 0 ; <S2SV_StartBug> cfg [ 0 ] . rc_min_quantizer = 4 ; <S2SV_EndBug> cfg [ 0 ] . rc_max_quantizer = 56 ; <S2SV_StartBug> cfg [ 0 ] . rc_undershoot_pct = 98 ; <S2SV_EndBug> <S2SV_StartBug> cfg [ 0 ] . rc_overshoot_pct = 100 ; <S2SV_EndBug> cfg [ 0 ] . rc_buf_initial_sz = 500 ; cfg [ 0 ] . rc_buf_optimal_sz = 600 ; cfg [ 0 ] . rc_buf_sz = 1000 ; cfg [ 0 ] . g_error_resilient = 1 ; cfg [ 0 ] . g_lag_in_frames = 0 ; cfg [ 0 ] . kf_mode = VPX_KF_AUTO ; cfg [ 0 ] . kf_min_dist = 3000 ; cfg [ 0 ] . kf_max_dist = 3000 ; cfg [ 0 ] . rc_target_bitrate = target_bitrate [ 0 ] ; cfg [ 0 ] . g_timebase . num = 1 ; cfg [ 0 ] . g_timebase . den = framerate ; for ( i = 1 ; i < NUM_ENCODERS ; i ++ ) { <S2SV_StartBug> memcpy ( & cfg [ i ] , & cfg [ 0 ] , sizeof ( vpx_codec_enc_cfg_t ) ) ; <S2SV_EndBug> cfg [ i ] . g_threads = 1 ; cfg [ i ] . rc_target_bitrate = target_bitrate [ i ] ; { unsigned int iw = cfg [ i - 1 ] . g_w * dsf [ i - 1 ] . den + dsf [ i - 1 ] . num - 1 ; unsigned int ih = cfg [ i - 1 ] . g_h * dsf [ i - 1 ] . den + dsf [ i - 1 ] . num - 1 ; cfg [ i ] . g_w = iw / dsf [ i - 1 ] . num ; cfg [ i ] . g_h = ih / dsf [ i - 1 ] . num ; } if ( ( cfg [ i ] . g_w ) % 2 ) cfg [ i ] . g_w ++ ; if ( ( cfg [ i ] . g_h ) % 2 ) cfg [ i ] . g_h ++ ; } <S2SV_StartBug> for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) <S2SV_EndBug> if ( ! vpx_img_alloc ( & raw [ i ] , VPX_IMG_FMT_I420 , cfg [ i ] . g_w , cfg [ i ] . g_h , 32 ) ) die ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>image"" , cfg [ i ] . g_w , cfg [ i ] . g_h ) ; if ( raw [ 0 ] . stride [ VPX_PLANE_Y ] == raw [ 0 ] . d_w ) read_frame_p = read_frame ; else read_frame_p = read_frame_by_row ; for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) if ( outfile [ i ] ) <S2SV_StartBug> write_ivf_file_header ( outfile [ i ] , & cfg [ i ] , 0 ) ; <S2SV_EndBug> if ( vpx_codec_enc_init_multi ( & codec [ 0 ] , interface , & cfg [ 0 ] , NUM_ENCODERS , ( show_psnr ? VPX_CODEC_USE_PSNR : 0 ) , & dsf [ 0 ] ) ) die_codec ( & codec [ 0 ] , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>encoder"" ) ; for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) { int speed = - 6 ; <S2SV_StartBug> if ( vpx_codec_control ( & codec [ i ] , VP8E_SET_CPUUSED , speed ) ) <S2SV_EndBug> <S2SV_StartBug> die_codec ( & codec [ i ] , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>cpu_used"" ) ; <S2SV_EndBug> } for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) { <S2SV_StartBug> unsigned int static_thresh = 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_control ( & codec [ i ] , VP8E_SET_STATIC_THRESHOLD , static_thresh ) ) <S2SV_EndBug> <S2SV_StartBug> die_codec ( & codec [ i ] , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>static<S2SV_blank>threshold"" ) ; <S2SV_EndBug> } if ( vpx_codec_control ( & codec [ 0 ] , VP8E_SET_NOISE_SENSITIVITY , 1 ) ) die_codec ( & codec [ 0 ] , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>noise_sensitivity"" ) ; for ( i = 1 ; i < NUM_ENCODERS ; i ++ ) { if ( vpx_codec_control ( & codec [ i ] , VP8E_SET_NOISE_SENSITIVITY , 0 ) ) die_codec ( & codec [ i ] , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>noise_sensitivity"" ) ; } frame_avail = 1 ; got_data = 0 ; while ( frame_avail || got_data ) { vpx_codec_iter_t iter [ NUM_ENCODERS ] = { NULL } ; const vpx_codec_cx_pkt_t * pkt [ NUM_ENCODERS ] ; flags = 0 ; frame_avail = read_frame_p ( infile , & raw [ 0 ] ) ; if ( frame_avail ) { for ( i = 1 ; i < NUM_ENCODERS ; i ++ ) { I420Scale ( raw [ i - 1 ] . planes [ VPX_PLANE_Y ] , raw [ i - 1 ] . stride [ VPX_PLANE_Y ] , raw [ i - 1 ] . planes [ VPX_PLANE_U ] , raw [ i - 1 ] . stride [ VPX_PLANE_U ] , raw [ i - 1 ] . planes [ VPX_PLANE_V ] , raw [ i - 1 ] . stride [ VPX_PLANE_V ] , raw [ i - 1 ] . d_w , raw [ i - 1 ] . d_h , raw [ i ] . planes [ VPX_PLANE_Y ] , raw [ i ] . stride [ VPX_PLANE_Y ] , raw [ i ] . planes [ VPX_PLANE_U ] , raw [ i ] . stride [ VPX_PLANE_U ] , raw [ i ] . planes [ VPX_PLANE_V ] , raw [ i ] . stride [ VPX_PLANE_V ] , raw [ i ] . d_w , raw [ i ] . d_h , 1 ) ; <S2SV_StartBug> } <S2SV_EndBug> } if ( vpx_codec_encode ( & codec [ 0 ] , frame_avail ? & raw [ 0 ] : NULL , <S2SV_StartBug> frame_cnt , 1 , flags , arg_deadline ) ) <S2SV_EndBug> <S2SV_StartBug> die_codec ( & codec [ 0 ] , ""Failed<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>frame"" ) ; <S2SV_EndBug> for ( i = NUM_ENCODERS - 1 ; i >= 0 ; i -- ) { got_data = 0 ; while ( ( pkt [ i ] = vpx_codec_get_cx_data ( & codec [ i ] , & iter [ i ] ) ) ) { got_data = 1 ; switch ( pkt [ i ] -> kind ) { case VPX_CODEC_CX_FRAME_PKT : write_ivf_frame_header ( outfile [ i ] , pkt [ i ] ) ; ( void ) fwrite ( pkt [ i ] -> data . frame . buf , 1 , pkt [ i ] -> data . frame . sz , outfile [ i ] ) ; break ; case VPX_CODEC_PSNR_PKT : if ( show_psnr ) { int j ; psnr_sse_total [ i ] += pkt [ i ] -> data . psnr . sse [ 0 ] ; psnr_samples_total [ i ] += pkt [ i ] -> data . psnr . samples [ 0 ] ; for ( j = 0 ; j < 4 ; j ++ ) { psnr_totals [ i ] [ j ] += pkt [ i ] -> data . psnr . psnr [ j ] ; } psnr_count [ i ] ++ ; } break ; default : break ; } printf ( pkt [ i ] -> kind == VPX_CODEC_CX_FRAME_PKT <S2SV_StartBug> && ( pkt [ i ] -> data . frame . flags & VPX_FRAME_IS_KEY ) ? ""K"" : ""."" ) ; <S2SV_EndBug> fflush ( stdout ) ; } } frame_cnt ++ ; } <S2SV_StartBug> printf ( ""\\n"" ) ; <S2SV_EndBug> fclose ( infile ) ; printf ( ""Processed<S2SV_blank>%ld<S2SV_blank>frames.\\n"" , ( long int ) frame_cnt - 1 ) ; for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) { if ( ( show_psnr ) && ( psnr_count [ i ] > 0 ) ) { int j ; double ovpsnr = sse_to_psnr ( psnr_samples_total [ i ] , 255.0 , psnr_sse_total [ i ] ) ; fprintf ( stderr , ""\\n<S2SV_blank>ENC%d<S2SV_blank>PSNR<S2SV_blank>(Overall/Avg/Y/U/V)"" , i ) ; fprintf ( stderr , ""<S2SV_blank>%.3lf"" , ovpsnr ) ; for ( j = 0 ; j < 4 ; j ++ ) { fprintf ( stderr , ""<S2SV_blank>%.3lf"" , psnr_totals [ i ] [ j ] / psnr_count [ i ] ) ; } } if ( vpx_codec_destroy ( & codec [ i ] ) ) die_codec ( & codec [ i ] , ""Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec"" ) ; vpx_img_free ( & raw [ i ] ) ; if ( ! outfile [ i ] ) continue ; if ( ! fseek ( outfile [ i ] , 0 , SEEK_SET ) ) write_ivf_file_header ( outfile [ i ] , & cfg [ i ] , frame_cnt - 1 ) ; fclose ( outfile [ i ] ) ; } printf ( ""\\n"" ) ; return EXIT_SUCCESS ; }
","<S2SV_ModStart> NUM_ENCODERS ] ; FILE * downsampled_input [ NUM_ENCODERS - 1 ] ; char filename [ 50 ] ; <S2SV_ModStart> NUM_ENCODERS ] ; int <S2SV_ModEnd> frame_cnt = 0 <S2SV_ModStart> height ; int length_frame ; int <S2SV_ModStart> 0 ; int layer_id = 0 ; int layer_flags [ VPX_TS_MAX_PERIODICITY * NUM_ENCODERS ] = { 0 } ; int flag_periodicity ; int <S2SV_ModStart> = 0 ; int key_frame_insert = 0 ; <S2SV_ModStart> { 0 } ; double cx_time = 0 ; struct timeval tv1 , tv2 , difftv <S2SV_ModStart> } } ; unsigned int num_temporal_layers [ NUM_ENCODERS ] = { 3 , 3 , 3 } ; <S2SV_ModStart> argc != ( 7 + 3 * <S2SV_ModEnd> NUM_ENCODERS ) ) <S2SV_ModStart> ) die ( ""Usage:<S2SV_blank>%s<S2SV_blank><width><S2SV_blank><height><S2SV_blank><frame_rate><S2SV_blank><S2SV_blank><infile><S2SV_blank><outfile(s)><S2SV_blank>"" ""<rate_encoder(s)><S2SV_blank><temporal_layer(s)><S2SV_blank><key_frame_insert><S2SV_blank><output<S2SV_blank>psnr?><S2SV_blank>\\n"" <S2SV_ModEnd> , argv [ <S2SV_ModStart> argv [ 2 ] , NULL , 0 ) ; framerate = strtol ( argv [ 3 <S2SV_ModStart> ( argv [ 4 <S2SV_ModEnd> ] , ""rb"" <S2SV_ModStart> , argv [ 4 <S2SV_ModEnd> ] ) ; <S2SV_ModStart> [ i + 5 <S2SV_ModEnd> ] , ""wb"" <S2SV_ModStart> ) ; } for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) { target_bitrate [ i ] <S2SV_ModEnd> = strtol ( <S2SV_ModStart> [ NUM_ENCODERS + 5 + i <S2SV_ModEnd> ] , NULL <S2SV_ModStart> 0 ) ; } <S2SV_ModStart> ++ ) { num_temporal_layers [ i ] = strtol ( argv [ 2 * NUM_ENCODERS + 5 + i ] , NULL , 0 ) ; if ( num_temporal_layers [ i ] < 1 || num_temporal_layers [ i ] > 3 ) die ( ""Invalid<S2SV_blank>temporal<S2SV_blank>layers:<S2SV_blank>%d,<S2SV_blank>Must<S2SV_blank>be<S2SV_blank>1,<S2SV_blank>2,<S2SV_blank>or<S2SV_blank>3.<S2SV_blank>\\n"" , num_temporal_layers ) ; } for ( i = 0 ; i < NUM_ENCODERS - 1 ; i ++ ) { if ( sprintf ( filename , ""ds%d.yuv"" , NUM_ENCODERS - i ) < 0 ) { <S2SV_ModEnd> return EXIT_FAILURE ; <S2SV_ModStart> EXIT_FAILURE ; } downsampled_input [ i ] = fopen ( filename , ""wb"" ) ; } key_frame_insert = strtol ( argv [ 3 * NUM_ENCODERS + 5 ] , NULL , 0 ) ; show_psnr = strtol ( argv [ 3 * NUM_ENCODERS + 6 ] , NULL , 0 ) ; for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) { res [ i ] = vpx_codec_enc_config_default ( interface , & cfg [ i ] , 0 ) ; if ( res [ i ] ) { printf ( ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>config:<S2SV_blank>%s\\n"" , vpx_codec_err_to_string ( res [ i ] ) ) ; return EXIT_FAILURE ; } <S2SV_ModStart> 0 ] . rc_dropframe_thresh = 0 <S2SV_ModEnd> ; cfg [ <S2SV_ModStart> . rc_min_quantizer = 2 <S2SV_ModEnd> ; cfg [ <S2SV_ModStart> . rc_undershoot_pct = 100 <S2SV_ModEnd> ; cfg [ <S2SV_ModStart> . rc_overshoot_pct = 15 <S2SV_ModEnd> ; cfg [ <S2SV_ModStart> vpx_codec_enc_cfg_t ) ) <S2SV_ModEnd> ; cfg [ <S2SV_ModStart> ++ ; } cfg [ 0 ] . g_threads = 2 ; cfg [ 1 ] . g_threads = 1 ; cfg [ 2 ] . g_threads = 1 ; <S2SV_ModStart> 0 ) ; for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) { set_temporal_layer_pattern ( num_temporal_layers [ i ] , & cfg [ i ] , cfg [ i ] . rc_target_bitrate , & layer_flags [ i * VPX_TS_MAX_PERIODICITY ] ) ; } <S2SV_ModStart> ; if ( i == NUM_ENCODERS - 1 ) speed = - 4 ; if ( <S2SV_ModStart> ] , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>cpu_used"" ) ; } for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) { if ( vpx_codec_control ( & codec [ i ] , VP8E_SET_STATIC_THRESHOLD , 1 ) ) die_codec ( & codec [ i ] , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>static<S2SV_blank>threshold"" ) ; } if ( vpx_codec_control ( & codec [ 0 ] , VP8E_SET_NOISE_SENSITIVITY , 1 ) ) die_codec ( & codec [ 0 ] , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>noise_sensitivity"" ) ; for ( i = 1 ; i < NUM_ENCODERS ; i ++ ) { if ( vpx_codec_control ( & codec [ i ] , VP8E_SET_NOISE_SENSITIVITY , 0 ) ) die_codec ( & codec [ i ] , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>noise_sensitivity"" ) ; } for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) { if ( vpx_codec_control ( & codec [ i ] , VP8E_SET_TOKEN_PARTITIONS , 1 ) ) die_codec ( & codec [ i ] , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>static<S2SV_blank>threshold"" <S2SV_ModStart> { unsigned int max_intra_size_pct = ( int ) ( ( ( double ) cfg [ 0 ] . rc_buf_optimal_sz * 0.5 ) * framerate / 10 ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> i ] , VP8E_SET_MAX_INTRA_BITRATE_PCT , max_intra_size_pct <S2SV_ModEnd> ) ) die_codec <S2SV_ModStart> ] , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>static<S2SV_blank>threshold"" <S2SV_ModEnd> ) ; } <S2SV_ModStart> 1 ) ; length_frame = cfg [ i ] . g_w * cfg [ i ] . g_h * 3 / 2 ; if ( fwrite ( raw [ i ] . planes [ 0 ] , 1 , length_frame , downsampled_input [ NUM_ENCODERS - i - 1 ] ) != length_frame ) { return EXIT_FAILURE ; } } } for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) { layer_id = cfg [ i ] . ts_layer_id [ frame_cnt % cfg [ i ] . ts_periodicity ] ; flags = 0 ; flag_periodicity = periodicity_to_num_layers [ num_temporal_layers [ i ] - 1 ] ; flags = layer_flags [ i * VPX_TS_MAX_PERIODICITY + frame_cnt % flag_periodicity ] ; if ( frame_cnt == 0 ) { flags |= VPX_EFLAG_FORCE_KF ; } if ( frame_cnt > 0 && frame_cnt == key_frame_insert ) { flags = VPX_EFLAG_FORCE_KF ; } vpx_codec_control ( & codec [ i ] , VP8E_SET_FRAME_FLAGS , flags ) ; vpx_codec_control ( & codec [ i ] , VP8E_SET_TEMPORAL_LAYER_ID , layer_id ) ; } gettimeofday ( & tv1 , NULL ) ; <S2SV_ModEnd> if ( vpx_codec_encode <S2SV_ModStart> , 1 , 0 <S2SV_ModEnd> , arg_deadline ) <S2SV_ModStart> arg_deadline ) ) { <S2SV_ModStart> ] , ""Failed<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>frame"" ) ; } gettimeofday ( & tv2 , NULL ) ; timersub ( & tv2 , & tv1 , & difftv ) ; cx_time += ( double ) ( difftv . tv_sec * 1000000 + difftv . tv_usec <S2SV_ModStart> ? ""K"" : """" <S2SV_ModEnd> ) ; fflush <S2SV_ModStart> printf ( ""\\n"" ) ; printf ( ""FPS<S2SV_blank>for<S2SV_blank>encoding<S2SV_blank>%d<S2SV_blank>%f<S2SV_blank>%f<S2SV_blank>\\n"" , frame_cnt , ( float ) cx_time / 1000000 , 1000000 * ( double ) frame_cnt / ( double ) cx_time
"
1089,"CWE-617 static void finish_process_as_req ( struct as_req_state * state , krb5_error_code errcode ) { krb5_key_data * server_key ; krb5_keyblock * as_encrypting_key = NULL ; krb5_data * response = NULL ; const char * emsg = 0 ; int did_log = 0 ; loop_respond_fn oldrespond ; void * oldarg ; kdc_realm_t * kdc_active_realm = state -> active_realm ; krb5_audit_state * au_state = state -> au_state ; assert ( state ) ; oldrespond = state -> respond ; oldarg = state -> arg ; if ( errcode ) goto egress ; au_state -> stage = ENCR_REP ; if ( ( errcode = validate_forwardable ( state -> request , * state -> client , * state -> server , state -> kdc_time , & state -> status ) ) ) { errcode += ERROR_TABLE_BASE_krb5 ; goto egress ; } errcode = check_indicators ( kdc_context , state -> server , state -> auth_indicators ) ; if ( errcode ) { state -> status = ""HIGHER_AUTHENTICATION_REQUIRED"" ; goto egress ; } state -> ticket_reply . enc_part2 = & state -> enc_tkt_reply ; if ( ( errcode = krb5_dbe_find_enctype ( kdc_context , state -> server , - 1 , - 1 , 0 , & server_key ) ) ) { state -> status = ""FINDING_SERVER_KEY"" ; goto egress ; } if ( ( errcode = krb5_dbe_decrypt_key_data ( kdc_context , NULL , server_key , & state -> server_keyblock , NULL ) ) ) { state -> status = ""DECRYPT_SERVER_KEY"" ; goto egress ; } state -> reply . msg_type = KRB5_AS_REP ; state -> reply . client = state -> enc_tkt_reply . client ; state -> reply . ticket = & state -> ticket_reply ; state -> reply_encpart . session = & state -> session_key ; if ( ( errcode = fetch_last_req_info ( state -> client , & state -> reply_encpart . last_req ) ) ) { state -> status = ""FETCH_LAST_REQ"" ; goto egress ; } state -> reply_encpart . nonce = state -> request -> nonce ; state -> reply_encpart . key_exp = get_key_exp ( state -> client ) ; state -> reply_encpart . flags = state -> enc_tkt_reply . flags ; state -> reply_encpart . server = state -> ticket_reply . server ; state -> reply_encpart . times = state -> enc_tkt_reply . times ; state -> reply_encpart . times . authtime = state -> authtime = state -> kdc_time ; state -> reply_encpart . caddrs = state -> enc_tkt_reply . caddrs ; state -> reply_encpart . enc_padata = NULL ; errcode = return_padata ( kdc_context , & state -> rock , state -> req_pkt , state -> request , & state -> reply , & state -> client_keyblock , & state -> pa_context ) ; if ( errcode ) { state -> status = ""KDC_RETURN_PADATA"" ; goto egress ; } if ( state -> client_keyblock . enctype == ENCTYPE_NULL ) { state -> status = ""CANT_FIND_CLIENT_KEY"" ; errcode = KRB5KDC_ERR_ETYPE_NOSUPP ; goto egress ; } errcode = handle_authdata ( kdc_context , state -> c_flags , state -> client , state -> server , NULL , state -> local_tgt , & state -> client_keyblock , & state -> server_keyblock , NULL , state -> req_pkt , state -> request , NULL , NULL , state -> auth_indicators , & state -> enc_tkt_reply ) ; if ( errcode ) { krb5_klog_syslog ( LOG_INFO , _ ( ""AS_REQ<S2SV_blank>:<S2SV_blank>handle_authdata<S2SV_blank>(%d)"" ) , errcode ) ; state -> status = ""HANDLE_AUTHDATA"" ; goto egress ; } errcode = krb5_encrypt_tkt_part ( kdc_context , & state -> server_keyblock , & state -> ticket_reply ) ; if ( errcode ) { state -> status = ""ENCRYPT_TICKET"" ; goto egress ; } errcode = kau_make_tkt_id ( kdc_context , & state -> ticket_reply , & au_state -> tkt_out_id ) ; if ( errcode ) { state -> status = ""GENERATE_TICKET_ID"" ; goto egress ; } state -> ticket_reply . enc_part . kvno = server_key -> key_data_kvno ; errcode = kdc_fast_response_handle_padata ( state -> rstate , state -> request , & state -> reply , state -> client_keyblock . enctype ) ; if ( errcode ) { state -> status = ""MAKE_FAST_RESPONSE"" ; goto egress ; } state -> reply . enc_part . enctype = state -> client_keyblock . enctype ; errcode = kdc_fast_handle_reply_key ( state -> rstate , & state -> client_keyblock , & as_encrypting_key ) ; if ( errcode ) { state -> status = ""MAKE_FAST_REPLY_KEY"" ; goto egress ; } errcode = return_enc_padata ( kdc_context , state -> req_pkt , state -> request , as_encrypting_key , state -> server , & state -> reply_encpart , FALSE ) ; if ( errcode ) { state -> status = ""KDC_RETURN_ENC_PADATA"" ; goto egress ; } if ( kdc_fast_hide_client ( state -> rstate ) ) state -> reply . client = ( krb5_principal ) krb5_anonymous_principal ( ) ; errcode = krb5_encode_kdc_rep ( kdc_context , KRB5_AS_REP , & state -> reply_encpart , 0 , as_encrypting_key , & state -> reply , & response ) ; if ( state -> client_key != NULL ) state -> reply . enc_part . kvno = state -> client_key -> key_data_kvno ; if ( errcode ) { state -> status = ""ENCODE_KDC_REP"" ; goto egress ; } memset ( state -> reply . enc_part . ciphertext . data , 0 , state -> reply . enc_part . ciphertext . length ) ; free ( state -> reply . enc_part . ciphertext . data ) ; log_as_req ( kdc_context , state -> local_addr , state -> remote_addr , state -> request , & state -> reply , state -> client , state -> cname , state -> server , state -> sname , state -> authtime , 0 , 0 , 0 ) ; did_log = 1 ; egress : <S2SV_StartBug> if ( errcode != 0 ) <S2SV_EndBug> assert ( state -> status != 0 ) ; au_state -> status = state -> status ; au_state -> reply = & state -> reply ; kau_as_req ( kdc_context , ( errcode || state -> preauth_err ) ? FALSE : TRUE , au_state ) ; kau_free_kdc_req ( au_state ) ; free_padata_context ( kdc_context , state -> pa_context ) ; if ( as_encrypting_key ) krb5_free_keyblock ( kdc_context , as_encrypting_key ) ; if ( errcode ) emsg = krb5_get_error_message ( kdc_context , errcode ) ; if ( state -> status ) { log_as_req ( kdc_context , state -> local_addr , state -> remote_addr , state -> request , & state -> reply , state -> client , state -> cname , state -> server , state -> sname , state -> authtime , state -> status , errcode , emsg ) ; did_log = 1 ; } if ( errcode ) { if ( state -> status == 0 ) { state -> status = emsg ; } if ( errcode != KRB5KDC_ERR_DISCARD ) { errcode -= ERROR_TABLE_BASE_krb5 ; if ( errcode < 0 || errcode > KRB_ERR_MAX ) errcode = KRB_ERR_GENERIC ; errcode = prepare_error_as ( state -> rstate , state -> request , state -> local_tgt , errcode , state -> e_data , state -> typed_e_data , ( ( state -> client != NULL ) ? state -> client -> princ : NULL ) , & response , state -> status ) ; state -> status = 0 ; } } if ( emsg ) krb5_free_error_message ( kdc_context , emsg ) ; if ( state -> enc_tkt_reply . authorization_data != NULL ) krb5_free_authdata ( kdc_context , state -> enc_tkt_reply . authorization_data ) ; if ( state -> server_keyblock . contents != NULL ) krb5_free_keyblock_contents ( kdc_context , & state -> server_keyblock ) ; if ( state -> client_keyblock . contents != NULL ) krb5_free_keyblock_contents ( kdc_context , & state -> client_keyblock ) ; if ( state -> reply . padata != NULL ) krb5_free_pa_data ( kdc_context , state -> reply . padata ) ; if ( state -> reply_encpart . enc_padata ) krb5_free_pa_data ( kdc_context , state -> reply_encpart . enc_padata ) ; if ( state -> cname != NULL ) free ( state -> cname ) ; if ( state -> sname != NULL ) free ( state -> sname ) ; krb5_db_free_principal ( kdc_context , state -> client ) ; krb5_db_free_principal ( kdc_context , state -> server ) ; krb5_db_free_principal ( kdc_context , state -> local_tgt_storage ) ; if ( state -> session_key . contents != NULL ) krb5_free_keyblock_contents ( kdc_context , & state -> session_key ) ; if ( state -> ticket_reply . enc_part . ciphertext . data != NULL ) { memset ( state -> ticket_reply . enc_part . ciphertext . data , 0 , state -> ticket_reply . enc_part . ciphertext . length ) ; free ( state -> ticket_reply . enc_part . ciphertext . data ) ; } krb5_free_pa_data ( kdc_context , state -> e_data ) ; krb5_free_data ( kdc_context , state -> inner_body ) ; kdc_free_rstate ( state -> rstate ) ; krb5_free_kdc_req ( kdc_context , state -> request ) ; k5_free_data_ptr_list ( state -> auth_indicators ) ; assert ( did_log != 0 ) ; free ( state ) ; ( * oldrespond ) ( oldarg , errcode , response ) ; }
","<S2SV_ModStart> errcode != 0 && state -> status == NULL ) state -> status = ""UNKNOWN_REASON"" <S2SV_ModEnd> ; au_state ->
"
1090,"CWE-000 OM_uint32 kg_unseal_iov ( OM_uint32 * minor_status , gss_ctx_id_t context_handle , int * conf_state , gss_qop_t * qop_state , gss_iov_buffer_desc * iov , int iov_count , int toktype ) { krb5_gss_ctx_id_rec * ctx ; OM_uint32 code ; ctx = ( krb5_gss_ctx_id_rec * ) context_handle ; <S2SV_StartBug> if ( ! ctx -> established ) { <S2SV_EndBug> * minor_status = KG_CTX_INCOMPLETE ; return GSS_S_NO_CONTEXT ; } if ( kg_locate_iov ( iov , iov_count , GSS_IOV_BUFFER_TYPE_STREAM ) != NULL ) { code = kg_unseal_stream_iov ( minor_status , ctx , conf_state , qop_state , iov , iov_count , toktype ) ; } else { code = kg_unseal_iov_token ( minor_status , ctx , conf_state , qop_state , iov , iov_count , toktype ) ; } return code ; }
","<S2SV_ModStart> ; if ( ctx -> terminated ||
"
1091,"CWE-400 int srs_timestamp_check ( srs_t * srs , const char * stamp ) { const char * sp ; char * bp ; int off ; time_t now ; <S2SV_StartBug> time_t then ; <S2SV_EndBug> then = 0 ; for ( sp = stamp ; * sp ; sp ++ ) { bp = strchr ( SRS_TIME_BASECHARS , toupper ( * sp ) ) ; if ( bp == NULL ) return SRS_EBADTIMESTAMPCHAR ; off = bp - SRS_TIME_BASECHARS ; then = ( then << SRS_TIME_BASEBITS ) | off ; } time ( & now ) ; now = ( now / SRS_TIME_PRECISION ) % SRS_TIME_SLOTS ; while ( now < then ) now = now + SRS_TIME_SLOTS ; if ( now <= then + srs -> maxage ) return SRS_SUCCESS ; return SRS_ETIMESTAMPOUTOFDATE ; }
","<S2SV_ModStart> ; time_t then ; if ( strlen ( stamp ) != 2 ) return SRS_ETIMESTAMPOUTOFDATE
"
1092,"CWE-119 static Image * ReadSUNImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define RMT_EQUAL_RGB 1 # define RMT_NONE 0 # define RMT_RAW 2 # define RT_STANDARD 1 # define RT_ENCODED 2 # define RT_FORMAT_RGB 3 typedef struct _SUNInfo { unsigned int magic , width , height , depth , length , type , maptype , maplength ; } SUNInfo ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bytes_per_line , extent , length ; ssize_t count , y ; SUNInfo sun_info ; unsigned char * sun_data , * sun_pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & sun_info , 0 , sizeof ( sun_info ) ) ; sun_info . magic = ReadBlobMSBLong ( image ) ; do { if ( sun_info . magic != 0x59a66a95 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; sun_info . width = ReadBlobMSBLong ( image ) ; sun_info . height = ReadBlobMSBLong ( image ) ; sun_info . depth = ReadBlobMSBLong ( image ) ; sun_info . length = ReadBlobMSBLong ( image ) ; sun_info . type = ReadBlobMSBLong ( image ) ; sun_info . maptype = ReadBlobMSBLong ( image ) ; sun_info . maplength = ReadBlobMSBLong ( image ) ; extent = sun_info . height * sun_info . width ; if ( ( sun_info . height != 0 ) && ( sun_info . width != extent / sun_info . height ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . type != RT_STANDARD ) && ( sun_info . type != RT_ENCODED ) && ( sun_info . type != RT_FORMAT_RGB ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype == RMT_NONE ) && ( sun_info . maplength != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . depth == 0 ) || ( sun_info . depth > 32 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype != RMT_NONE ) && ( sun_info . maptype != RMT_EQUAL_RGB ) && ( sun_info . maptype != RMT_RAW ) ) ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; image -> depth = sun_info . depth <= 8 ? sun_info . depth : MAGICKCORE_QUANTUM_DEPTH ; if ( sun_info . depth < 24 ) { size_t one ; image -> colors = sun_info . maplength ; one = 1 ; if ( sun_info . maptype == RMT_NONE ) image -> colors = one << sun_info . depth ; if ( sun_info . maptype == RMT_EQUAL_RGB ) image -> colors = sun_info . maplength / 3 ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } switch ( sun_info . maptype ) <S2SV_StartBug> { <S2SV_EndBug> case RMT_EQUAL_RGB : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } case RMT_RAW : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( sun_info . maplength , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , sun_info . maplength , sun_colormap ) ; if ( count != ( ssize_t ) sun_info . maplength ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; } image -> alpha_trait = sun_info . depth == 32 ? BlendPixelTrait : UndefinedPixelTrait ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( ( sun_info . length * sizeof ( * sun_data ) ) / sizeof ( * sun_data ) != sun_info . length || ! sun_info . length ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; if ( ( sun_info . type != RT_ENCODED ) && ( sun_info . depth >= 8 ) && ( ( number_pixels * ( ( sun_info . depth + 7 ) / 8 ) ) > sun_info . length ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; bytes_per_line = sun_info . width * sun_info . depth ; sun_data = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( sun_info . length , bytes_per_line * sun_info . width ) , sizeof ( * sun_data ) ) ; if ( sun_data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ( ssize_t ) ReadBlob ( image , sun_info . length , sun_data ) ; if ( count != ( ssize_t ) sun_info . length ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; sun_pixels = sun_data ; bytes_per_line = 0 ; if ( sun_info . type == RT_ENCODED ) { size_t height ; height = sun_info . height ; if ( ( height == 0 ) || ( sun_info . width == 0 ) || ( sun_info . depth == 0 ) || ( ( bytes_per_line / sun_info . depth ) != sun_info . width ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; bytes_per_line += 15 ; bytes_per_line <<= 1 ; if ( ( bytes_per_line >> 1 ) != ( sun_info . width * sun_info . depth + 15 ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; bytes_per_line >>= 4 ; sun_pixels = ( unsigned char * ) AcquireQuantumMemory ( height , bytes_per_line * sizeof ( * sun_pixels ) ) ; if ( sun_pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line * height ) ; sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ; } p = sun_pixels ; if ( sun_info . depth == 1 ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 7 ; bit >= 0 ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 7 ; bit >= ( int ) ( 8 - ( image -> columns % 8 ) ) ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( ( ( image -> columns / 8 ) + ( image -> columns % 8 ? 1 : 0 ) ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } else if ( image -> storage_class == PseudoClass ) { if ( bytes_per_line == 0 ) bytes_per_line = image -> columns ; length = image -> rows * ( image -> columns + image -> columns % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( ( image -> columns % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { size_t bytes_per_pixel ; bytes_per_pixel = 3 ; if ( image -> alpha_trait != UndefinedPixelTrait ) bytes_per_pixel ++ ; if ( bytes_per_line == 0 ) bytes_per_line = bytes_per_pixel * image -> columns ; length = image -> rows * ( bytes_per_line + image -> columns % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( sun_info . type == RT_STANDARD ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } else { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } if ( image -> colors != 0 ) { SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelRed ( image , q ) ] . red ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelGreen ( image , q ) ] . green ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelBlue ( image , q ) ] . blue ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( ( ( bytes_per_pixel * image -> columns ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image , exception ) ; sun_pixels = ( unsigned char * ) RelinquishMagickMemory ( sun_pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; sun_info . magic = ReadBlobMSBLong ( image ) ; if ( sun_info . magic == 0x59a66a95 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( sun_info . magic == 0x59a66a95 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> maptype ) { case RMT_NONE : break ;
"
1093,"CWE-000 static int treo_attach ( struct usb_serial * serial ) { struct usb_serial_port * swap_port ; if ( ! ( ( le16_to_cpu ( serial -> dev -> descriptor . idVendor ) == HANDSPRING_VENDOR_ID ) || ( le16_to_cpu ( serial -> dev -> descriptor . idVendor ) == KYOCERA_VENDOR_ID ) ) || ( serial -> num_interrupt_in == 0 ) ) return 0 ; <S2SV_StartBug> # define COPY_PORT ( dest , src ) do { int i ; for ( i = 0 ; i < ARRAY_SIZE ( src -> read_urbs ) ; ++ i ) { dest -> read_urbs [ i ] = src -> read_urbs [ i ] ; dest -> read_urbs [ i ] -> context = dest ; dest -> bulk_in_buffers [ i ] = src -> bulk_in_buffers [ i ] ; } dest -> read_urb = src -> read_urb ; dest -> bulk_in_endpointAddress = src -> bulk_in_endpointAddress ; dest -> bulk_in_buffer = src -> bulk_in_buffer ; dest -> bulk_in_size = src -> bulk_in_size ; dest -> interrupt_in_urb = src -> interrupt_in_urb ; dest -> interrupt_in_urb -> context = dest ; dest -> interrupt_in_endpointAddress = src -> interrupt_in_endpointAddress ; dest -> interrupt_in_buffer = src -> interrupt_in_buffer ; } while ( 0 ) ; <S2SV_EndBug> swap_port = kmalloc ( sizeof ( * swap_port ) , GFP_KERNEL ) ; if ( ! swap_port ) return - ENOMEM ; COPY_PORT ( swap_port , serial -> port [ 0 ] ) ; COPY_PORT ( serial -> port [ 0 ] , serial -> port [ 1 ] ) ; COPY_PORT ( serial -> port [ 1 ] , swap_port ) ; kfree ( swap_port ) ; return 0 ; }
","<S2SV_ModStart> return 0 ; if ( serial -> num_bulk_in < 2 || serial -> num_interrupt_in < 2 ) { dev_err ( & serial -> interface -> dev , ""missing<S2SV_blank>endpoints\\n"" ) ; return - ENODEV ; }
"
1094,"CWE-119 int lzo1x_decompress_safe ( const unsigned char * in , size_t in_len , unsigned char * out , size_t * out_len ) { unsigned char * op ; const unsigned char * ip ; size_t t , next ; size_t state = 0 ; const unsigned char * m_pos ; const unsigned char * const ip_end = in + in_len ; unsigned char * const op_end = out + * out_len ; op = out ; ip = in ; if ( unlikely ( in_len < 3 ) ) goto input_overrun ; if ( * ip > 17 ) { t = * ip ++ - 17 ; if ( t < 4 ) { next = t ; goto match_next ; } goto copy_literal_run ; } for ( ; ; ) { t = * ip ++ ; if ( t < 16 ) { if ( likely ( state == 0 ) ) { if ( unlikely ( t == 0 ) ) { while ( unlikely ( * ip == 0 ) ) { t += 255 ; ip ++ ; <S2SV_StartBug> NEED_IP ( 1 ) ; <S2SV_EndBug> } t += 15 + * ip ++ ; } t += 3 ; copy_literal_run : # if defined ( CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS ) <S2SV_StartBug> if ( likely ( HAVE_IP ( t + 15 ) && HAVE_OP ( t + 15 ) ) ) { <S2SV_EndBug> const unsigned char * ie = ip + t ; unsigned char * oe = op + t ; do { COPY8 ( op , ip ) ; op += 8 ; ip += 8 ; COPY8 ( op , ip ) ; op += 8 ; ip += 8 ; } while ( ip < ie ) ; ip = ie ; op = oe ; } else # endif { <S2SV_StartBug> NEED_OP ( t ) ; <S2SV_EndBug> <S2SV_StartBug> NEED_IP ( t + 3 ) ; <S2SV_EndBug> do { * op ++ = * ip ++ ; } while ( -- t > 0 ) ; } state = 4 ; continue ; } else if ( state != 4 ) { next = t & 3 ; m_pos = op - 1 ; m_pos -= t >> 2 ; m_pos -= * ip ++ << 2 ; TEST_LB ( m_pos ) ; <S2SV_StartBug> NEED_OP ( 2 ) ; <S2SV_EndBug> op [ 0 ] = m_pos [ 0 ] ; op [ 1 ] = m_pos [ 1 ] ; op += 2 ; goto match_next ; } else { next = t & 3 ; m_pos = op - ( 1 + M2_MAX_OFFSET ) ; m_pos -= t >> 2 ; m_pos -= * ip ++ << 2 ; t = 3 ; } } else if ( t >= 64 ) { next = t & 3 ; m_pos = op - 1 ; m_pos -= ( t >> 2 ) & 7 ; m_pos -= * ip ++ << 3 ; t = ( t >> 5 ) - 1 + ( 3 - 1 ) ; } else if ( t >= 32 ) { t = ( t & 31 ) + ( 3 - 1 ) ; if ( unlikely ( t == 2 ) ) { while ( unlikely ( * ip == 0 ) ) { t += 255 ; ip ++ ; <S2SV_StartBug> NEED_IP ( 1 ) ; <S2SV_EndBug> } t += 31 + * ip ++ ; <S2SV_StartBug> NEED_IP ( 2 ) ; <S2SV_EndBug> } m_pos = op - 1 ; next = get_unaligned_le16 ( ip ) ; ip += 2 ; m_pos -= next >> 2 ; next &= 3 ; } else { m_pos = op ; m_pos -= ( t & 8 ) << 11 ; t = ( t & 7 ) + ( 3 - 1 ) ; if ( unlikely ( t == 2 ) ) { while ( unlikely ( * ip == 0 ) ) { t += 255 ; ip ++ ; <S2SV_StartBug> NEED_IP ( 1 ) ; <S2SV_EndBug> } t += 7 + * ip ++ ; <S2SV_StartBug> NEED_IP ( 2 ) ; <S2SV_EndBug> } next = get_unaligned_le16 ( ip ) ; ip += 2 ; m_pos -= next >> 2 ; next &= 3 ; if ( m_pos == op ) goto eof_found ; m_pos -= 0x4000 ; } TEST_LB ( m_pos ) ; # if defined ( CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS ) if ( op - m_pos >= 8 ) { unsigned char * oe = op + t ; <S2SV_StartBug> if ( likely ( HAVE_OP ( t + 15 ) ) ) { <S2SV_EndBug> do { COPY8 ( op , m_pos ) ; op += 8 ; m_pos += 8 ; COPY8 ( op , m_pos ) ; op += 8 ; m_pos += 8 ; } while ( op < oe ) ; op = oe ; <S2SV_StartBug> if ( HAVE_IP ( 6 ) ) { <S2SV_EndBug> state = next ; COPY4 ( op , ip ) ; op += next ; ip += next ; continue ; } } else { <S2SV_StartBug> NEED_OP ( t ) ; <S2SV_EndBug> do { * op ++ = * m_pos ++ ; } while ( op < oe ) ; } } else # endif { unsigned char * oe = op + t ; <S2SV_StartBug> NEED_OP ( t ) ; <S2SV_EndBug> op [ 0 ] = m_pos [ 0 ] ; op [ 1 ] = m_pos [ 1 ] ; op += 2 ; m_pos += 2 ; do { * op ++ = * m_pos ++ ; } while ( op < oe ) ; } match_next : state = next ; t = next ; # if defined ( CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS ) <S2SV_StartBug> if ( likely ( HAVE_IP ( 6 ) && HAVE_OP ( 4 ) ) ) { <S2SV_EndBug> COPY4 ( op , ip ) ; op += t ; ip += t ; } else # endif { <S2SV_StartBug> NEED_IP ( t + 3 ) ; <S2SV_EndBug> <S2SV_StartBug> NEED_OP ( t ) ; <S2SV_EndBug> while ( t > 0 ) { * op ++ = * ip ++ ; t -- ; } } } eof_found : * out_len = op - out ; return ( t != 3 ? LZO_E_ERROR : ip == ip_end ? LZO_E_OK : ip < ip_end ? LZO_E_INPUT_NOT_CONSUMED : LZO_E_INPUT_OVERRUN ) ; input_overrun : * out_len = op - out ; return LZO_E_INPUT_OVERRUN ; output_overrun : * out_len = op - out ; return LZO_E_OUTPUT_OVERRUN ; lookbehind_overrun : * out_len = op - out ; return LZO_E_LOOKBEHIND_OVERRUN ; }
","<S2SV_ModStart> NEED_IP ( 1 , 0 <S2SV_ModStart> HAVE_IP ( t , <S2SV_ModEnd> 15 ) && <S2SV_ModStart> HAVE_OP ( t , <S2SV_ModEnd> 15 ) ) <S2SV_ModStart> NEED_OP ( t , 0 <S2SV_ModStart> NEED_IP ( t , <S2SV_ModEnd> 3 ) ; <S2SV_ModStart> NEED_OP ( 2 , 0 <S2SV_ModStart> NEED_IP ( 1 , 0 <S2SV_ModStart> NEED_IP ( 2 , 0 <S2SV_ModStart> NEED_IP ( 1 , 0 <S2SV_ModStart> NEED_IP ( 2 , 0 <S2SV_ModStart> HAVE_OP ( t , <S2SV_ModEnd> 15 ) ) <S2SV_ModStart> HAVE_IP ( 6 , 0 <S2SV_ModStart> NEED_OP ( t , 0 <S2SV_ModStart> NEED_OP ( t , 0 <S2SV_ModStart> HAVE_IP ( 6 , 0 <S2SV_ModStart> HAVE_OP ( 4 , 0 <S2SV_ModStart> NEED_IP ( t , <S2SV_ModEnd> 3 ) ; <S2SV_ModStart> NEED_OP ( t , 0
"
1095,"CWE-000 void ngx_gmtime ( time_t t , ngx_tm_t * tp ) { ngx_int_t yday ; <S2SV_StartBug> ngx_uint_t n , sec , min , hour , mday , mon , year , wday , days , leap ; <S2SV_EndBug> <S2SV_StartBug> n = ( ngx_uint_t ) t ; <S2SV_EndBug> days = n / 86400 ; <S2SV_StartBug> wday = ( 4 + days ) % 7 ; <S2SV_EndBug> <S2SV_StartBug> n %= 86400 ; <S2SV_EndBug> hour = n / 3600 ; <S2SV_StartBug> n %= 3600 ; <S2SV_EndBug> <S2SV_StartBug> min = n / 60 ; <S2SV_EndBug> <S2SV_StartBug> sec = n % 60 ; <S2SV_EndBug> days = days - ( 31 + 28 ) + 719527 ; year = ( days + 2 ) * 400 / ( 365 * 400 + 100 - 4 + 1 ) ; yday = days - ( 365 * year + year / 4 - year / 100 + year / 400 ) ; if ( yday < 0 ) { leap = ( year % 4 == 0 ) && ( year % 100 || ( year % 400 == 0 ) ) ; yday = 365 + leap + yday ; year -- ; } mon = ( yday + 31 ) * 10 / 306 ; mday = yday - ( 367 * mon / 12 - 30 ) + 1 ; if ( yday >= 306 ) { year ++ ; mon -= 10 ; } else { mon += 2 ; } tp -> ngx_tm_sec = ( ngx_tm_sec_t ) sec ; tp -> ngx_tm_min = ( ngx_tm_min_t ) min ; tp -> ngx_tm_hour = ( ngx_tm_hour_t ) hour ; tp -> ngx_tm_mday = ( ngx_tm_mday_t ) mday ; tp -> ngx_tm_mon = ( ngx_tm_mon_t ) mon ; tp -> ngx_tm_year = ( ngx_tm_year_t ) year ; tp -> ngx_tm_wday = ( ngx_tm_wday_t ) wday ; }
","<S2SV_ModStart> yday ; ngx_uint_t <S2SV_ModEnd> sec , min <S2SV_ModStart> , leap ; if ( t < 0 ) { t = 0 ; } days = t <S2SV_ModEnd> / 86400 ; <S2SV_ModStart> / 86400 ; sec = t % 86400 ; <S2SV_ModStart> % 7 ; hour = sec <S2SV_ModEnd> / 3600 ; <S2SV_ModStart> / 3600 ; sec <S2SV_ModEnd> %= 3600 ; <S2SV_ModStart> ; min = sec <S2SV_ModEnd> / 60 ; <S2SV_ModStart> 60 ; sec %= <S2SV_ModEnd> 60 ; days
"
1096,"CWE-20 static int trusted_update ( struct key * key , struct key_preparsed_payload * prep ) { struct trusted_key_payload * p ; struct trusted_key_payload * new_p ; struct trusted_key_options * new_o ; size_t datalen = prep -> datalen ; char * datablob ; int ret = 0 ; <S2SV_StartBug> if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) <S2SV_EndBug> return - ENOKEY ; p = key -> payload . data [ 0 ] ; if ( ! p -> migratable ) return - EPERM ; if ( datalen <= 0 || datalen > 32767 || ! prep -> data ) return - EINVAL ; datablob = kmalloc ( datalen + 1 , GFP_KERNEL ) ; if ( ! datablob ) return - ENOMEM ; new_o = trusted_options_alloc ( ) ; if ( ! new_o ) { ret = - ENOMEM ; goto out ; } new_p = trusted_payload_alloc ( key ) ; if ( ! new_p ) { ret = - ENOMEM ; goto out ; } memcpy ( datablob , prep -> data , datalen ) ; datablob [ datalen ] = '\\0' ; ret = datablob_parse ( datablob , new_p , new_o ) ; if ( ret != Opt_update ) { ret = - EINVAL ; kzfree ( new_p ) ; goto out ; } if ( ! new_o -> keyhandle ) { ret = - EINVAL ; kzfree ( new_p ) ; goto out ; } new_p -> migratable = p -> migratable ; new_p -> key_len = p -> key_len ; memcpy ( new_p -> key , p -> key , p -> key_len ) ; dump_payload ( p ) ; dump_payload ( new_p ) ; ret = key_seal ( new_p , new_o ) ; if ( ret < 0 ) { pr_info ( ""trusted_key:<S2SV_blank>key_seal<S2SV_blank>failed<S2SV_blank>(%d)\\n"" , ret ) ; kzfree ( new_p ) ; goto out ; } if ( new_o -> pcrlock ) { ret = pcrlock ( new_o -> pcrlock ) ; if ( ret < 0 ) { pr_info ( ""trusted_key:<S2SV_blank>pcrlock<S2SV_blank>failed<S2SV_blank>(%d)\\n"" , ret ) ; kzfree ( new_p ) ; goto out ; } } rcu_assign_keypointer ( key , new_p ) ; call_rcu ( & p -> rcu , trusted_rcu_free ) ; out : kzfree ( datablob ) ; kzfree ( new_o ) ; return ret ; }
","<S2SV_ModStart> ; if ( key_is_negative ( key <S2SV_ModEnd> ) ) return
"
1097,"CWE-416 static zend_always_inline int process_nested_data ( UNSERIALIZE_PARAMETER , HashTable * ht , zend_long elements , int objprops ) { while ( elements -- > 0 ) { zval key , * data , d , * old_data ; zend_ulong idx ; ZVAL_UNDEF ( & key ) ; if ( ! php_var_unserialize_internal ( & key , p , max , NULL , classes ) ) { zval_dtor ( & key ) ; return 0 ; } data = NULL ; ZVAL_UNDEF ( & d ) ; if ( ! objprops ) { if ( Z_TYPE ( key ) == IS_LONG ) { idx = Z_LVAL ( key ) ; numeric_key : if ( UNEXPECTED ( ( old_data = zend_hash_index_find ( ht , idx ) ) != NULL ) ) { var_push_dtor ( var_hash , old_data ) ; data = zend_hash_index_update ( ht , idx , & d ) ; } else { data = zend_hash_index_add_new ( ht , idx , & d ) ; } } else if ( Z_TYPE ( key ) == IS_STRING ) { if ( UNEXPECTED ( ZEND_HANDLE_NUMERIC ( Z_STR ( key ) , idx ) ) ) { goto numeric_key ; } if ( UNEXPECTED ( ( old_data = zend_hash_find ( ht , Z_STR ( key ) ) ) != NULL ) ) { var_push_dtor ( var_hash , old_data ) ; data = zend_hash_update ( ht , Z_STR ( key ) , & d ) ; } else { data = zend_hash_add_new ( ht , Z_STR ( key ) , & d ) ; } } else { zval_dtor ( & key ) ; return 0 ; } } else { if ( EXPECTED ( Z_TYPE ( key ) == IS_STRING ) ) { string_key : if ( ( old_data = zend_hash_find ( ht , Z_STR ( key ) ) ) != NULL ) { if ( Z_TYPE_P ( old_data ) == IS_INDIRECT ) { old_data = Z_INDIRECT_P ( old_data ) ; } var_push_dtor ( var_hash , old_data ) ; data = zend_hash_update_ind ( ht , Z_STR ( key ) , & d ) ; } else { data = zend_hash_add_new ( ht , Z_STR ( key ) , & d ) ; } } else if ( Z_TYPE ( key ) == IS_LONG ) { convert_to_string ( & key ) ; goto string_key ; } else { zval_dtor ( & key ) ; return 0 ; } } if ( ! php_var_unserialize_internal ( data , p , max , var_hash , classes ) ) { zval_dtor ( & key ) ; return 0 ; } <S2SV_StartBug> if ( UNEXPECTED ( Z_ISUNDEF_P ( data ) ) ) { <S2SV_EndBug> if ( Z_TYPE ( key ) == IS_LONG ) { zend_hash_index_del ( ht , Z_LVAL ( key ) ) ; } else { zend_hash_del_ind ( ht , Z_STR ( key ) ) ; } } else { var_push_dtor ( var_hash , data ) ; <S2SV_StartBug> } <S2SV_EndBug> zval_dtor ( & key ) ; if ( elements && * ( * p - 1 ) != ';' && * ( * p - 1 ) != '}' ) { ( * p ) -- ; return 0 ; } } return 1 ; }
","<S2SV_ModStart> 0 ; } <S2SV_ModEnd> var_push_dtor ( var_hash <S2SV_ModStart> data ) ; <S2SV_ModEnd> zval_dtor ( &
"
1098,"CWE-399 public int magic_setparam ( struct magic_set * ms , int param , const void * val ) { switch ( param ) { case MAGIC_PARAM_INDIR_MAX : ms -> indir_max = * ( const size_t * ) val ; return 0 ; case MAGIC_PARAM_NAME_MAX : ms -> name_max = * ( const size_t * ) val ; return 0 ; case MAGIC_PARAM_ELF_PHNUM_MAX : ms -> elf_phnum_max = * ( const size_t * ) val ; return 0 ; case MAGIC_PARAM_ELF_SHNUM_MAX : ms -> elf_shnum_max = * ( const size_t * ) val ; return 0 ; <S2SV_StartBug> default : <S2SV_EndBug> errno = EINVAL ; return - 1 ; } }
","<S2SV_ModStart> return 0 ; case MAGIC_PARAM_ELF_NOTES_MAX : ms -> elf_notes_max = * ( const size_t * ) val ; return 0 ;
"
1099,"CWE-125 int cli_scanxar ( cli_ctx * ctx ) { int rc = CL_SUCCESS ; unsigned int cksum_fails = 0 ; unsigned int extract_errors = 0 ; # if HAVE_LIBXML2 int fd = - 1 ; struct xar_header hdr ; fmap_t * map = * ctx -> fmap ; <S2SV_StartBug> long length , offset , size , at ; <S2SV_EndBug> int encoding ; z_stream strm ; char * toc , * tmpname ; xmlTextReaderPtr reader = NULL ; int a_hash , e_hash ; unsigned char * a_cksum = NULL , * e_cksum = NULL ; void * a_hash_ctx = NULL , * e_hash_ctx = NULL ; char result [ SHA1_HASH_SIZE ] ; memset ( & strm , 0x00 , sizeof ( z_stream ) ) ; if ( fmap_readn ( * ctx -> fmap , & hdr , 0 , sizeof ( hdr ) ) != sizeof ( hdr ) ) { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>Invalid<S2SV_blank>header,<S2SV_blank>too<S2SV_blank>short.\\n"" ) ; return CL_EFORMAT ; } hdr . magic = be32_to_host ( hdr . magic ) ; if ( hdr . magic == XAR_HEADER_MAGIC ) { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>Matched<S2SV_blank>magic\\n"" ) ; } else { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>Invalid<S2SV_blank>magic\\n"" ) ; return CL_EFORMAT ; } hdr . size = be16_to_host ( hdr . size ) ; hdr . version = be16_to_host ( hdr . version ) ; hdr . toc_length_compressed = be64_to_host ( hdr . toc_length_compressed ) ; hdr . toc_length_decompressed = be64_to_host ( hdr . toc_length_decompressed ) ; hdr . chksum_alg = be32_to_host ( hdr . chksum_alg ) ; strm . next_in = ( unsigned char * ) fmap_need_off_once ( * ctx -> fmap , hdr . size , hdr . toc_length_compressed ) ; if ( strm . next_in == NULL ) { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>fmap_need_off_once<S2SV_blank>fails<S2SV_blank>on<S2SV_blank>TOC.\\n"" ) ; return CL_EREAD ; } strm . avail_in = hdr . toc_length_compressed ; toc = cli_malloc ( hdr . toc_length_decompressed + 1 ) ; if ( toc == NULL ) { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>cli_malloc<S2SV_blank>fails<S2SV_blank>on<S2SV_blank>TOC<S2SV_blank>decompress<S2SV_blank>buffer.\\n"" ) ; return CL_EMEM ; } toc [ hdr . toc_length_decompressed ] = '\\0' ; strm . avail_out = hdr . toc_length_decompressed ; strm . next_out = ( unsigned char * ) toc ; rc = inflateInit ( & strm ) ; if ( rc != Z_OK ) { cli_dbgmsg ( ""cli_scanxar:inflateInit<S2SV_blank>error<S2SV_blank>%i<S2SV_blank>\\n"" , rc ) ; rc = CL_EFORMAT ; goto exit_toc ; } rc = inflate ( & strm , Z_SYNC_FLUSH ) ; if ( rc != Z_OK && rc != Z_STREAM_END ) { cli_dbgmsg ( ""cli_scanxar:inflate<S2SV_blank>error<S2SV_blank>%i<S2SV_blank>\\n"" , rc ) ; rc = CL_EFORMAT ; goto exit_toc ; } rc = inflateEnd ( & strm ) ; if ( rc != Z_OK ) { cli_dbgmsg ( ""cli_scanxar:inflateEnd<S2SV_blank>error<S2SV_blank>%i<S2SV_blank>\\n"" , rc ) ; rc = CL_EFORMAT ; <S2SV_StartBug> goto exit_toc ; <S2SV_EndBug> } cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>scanning<S2SV_blank>xar<S2SV_blank>TOC<S2SV_blank>xml<S2SV_blank>in<S2SV_blank>memory.\\n"" ) ; rc = cli_mem_scandesc ( toc , hdr . toc_length_decompressed , ctx ) ; if ( rc != CL_SUCCESS ) { if ( rc != CL_VIRUS || ! SCAN_ALL ) goto exit_toc ; } if ( ctx -> engine -> keeptmp ) { if ( ( rc = cli_gentempfd ( ctx -> engine -> tmpdir , & tmpname , & fd ) ) != CL_SUCCESS ) { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>Can\'t<S2SV_blank>create<S2SV_blank>temporary<S2SV_blank>file<S2SV_blank>for<S2SV_blank>TOC.\\n"" ) ; goto exit_toc ; } if ( cli_writen ( fd , toc , hdr . toc_length_decompressed ) < 0 ) { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>cli_writen<S2SV_blank>error<S2SV_blank>writing<S2SV_blank>TOC.\\n"" ) ; rc = CL_EWRITE ; xar_cleanup_temp_file ( ctx , fd , tmpname ) ; goto exit_toc ; } rc = xar_cleanup_temp_file ( ctx , fd , tmpname ) ; if ( rc != CL_SUCCESS ) goto exit_toc ; } reader = xmlReaderForMemory ( toc , hdr . toc_length_decompressed , ""noname.xml"" , NULL , CLAMAV_MIN_XMLREADER_FLAGS ) ; if ( reader == NULL ) { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>xmlReaderForMemory<S2SV_blank>error<S2SV_blank>for<S2SV_blank>TOC\\n"" ) ; goto exit_toc ; } rc = xar_scan_subdocuments ( reader , ctx ) ; if ( rc != CL_SUCCESS ) { cli_dbgmsg ( ""xar_scan_subdocuments<S2SV_blank>returns<S2SV_blank>%i.\\n"" , rc ) ; goto exit_reader ; } fd = - 1 ; tmpname = NULL ; while ( CL_SUCCESS == ( rc = xar_get_toc_data_values ( reader , & length , & offset , & size , & encoding , & a_cksum , & a_hash , & e_cksum , & e_hash ) ) ) { int do_extract_cksum = 1 ; unsigned char * blockp ; void * a_sc , * e_sc ; void * a_mc , * e_mc ; char * expected ; if ( fd > - 1 && tmpname ) { rc = xar_cleanup_temp_file ( ctx , fd , tmpname ) ; if ( rc != CL_SUCCESS ) goto exit_reader ; } at = offset + hdr . toc_length_compressed + hdr . size ; if ( ( rc = cli_gentempfd ( ctx -> engine -> tmpdir , & tmpname , & fd ) ) != CL_SUCCESS ) { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>Can\'t<S2SV_blank>generate<S2SV_blank>temporary<S2SV_blank>file.\\n"" ) ; goto exit_reader ; } <S2SV_StartBug> cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>decompress<S2SV_blank>into<S2SV_blank>temp<S2SV_blank>file:\\n%s,<S2SV_blank>size<S2SV_blank>%li,\\n"" <S2SV_EndBug> ""from<S2SV_blank>xar<S2SV_blank>heap<S2SV_blank>offset<S2SV_blank>%li<S2SV_blank>length<S2SV_blank>%li\\n"" , tmpname , size , offset , length ) ; a_hash_ctx = xar_hash_init ( a_hash , & a_sc , & a_mc ) ; e_hash_ctx = xar_hash_init ( e_hash , & e_sc , & e_mc ) ; switch ( encoding ) { case CL_TYPE_GZ : memset ( & strm , 0 , sizeof ( strm ) ) ; if ( ( rc = inflateInit ( & strm ) ) != Z_OK ) { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>InflateInit<S2SV_blank>failed:<S2SV_blank>%d\\n"" , rc ) ; rc = CL_EFORMAT ; extract_errors ++ ; break ; } while ( ( size_t ) at < map -> len && ( unsigned long ) at < offset + hdr . toc_length_compressed + hdr . size + length ) { unsigned long avail_in ; void * next_in ; unsigned int bytes = MIN ( map -> len - at , map -> pgsz ) ; bytes = MIN ( length , bytes ) ; if ( ! ( strm . next_in = next_in = ( void * ) fmap_need_off_once ( map , at , bytes ) ) ) { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%lu.\\n"" , bytes , ( long unsigned ) at ) ; inflateEnd ( & strm ) ; rc = CL_EREAD ; goto exit_tmpfile ; } at += bytes ; strm . avail_in = avail_in = bytes ; do { int inf , outsize = 0 ; unsigned char buff [ FILEBUFF ] ; strm . avail_out = sizeof ( buff ) ; strm . next_out = buff ; inf = inflate ( & strm , Z_SYNC_FLUSH ) ; if ( inf != Z_OK && inf != Z_STREAM_END && inf != Z_BUF_ERROR ) { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>inflate<S2SV_blank>error<S2SV_blank>%i<S2SV_blank>%s.\\n"" , inf , strm . msg ? strm . msg : """" ) ; rc = CL_EFORMAT ; extract_errors ++ ; break ; } bytes = sizeof ( buff ) - strm . avail_out ; if ( e_hash_ctx != NULL ) xar_hash_update ( e_hash_ctx , buff , bytes , e_hash ) ; if ( cli_writen ( fd , buff , bytes ) < 0 ) { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>cli_writen<S2SV_blank>error<S2SV_blank>file<S2SV_blank>%s.\\n"" , tmpname ) ; inflateEnd ( & strm ) ; rc = CL_EWRITE ; goto exit_tmpfile ; } outsize += sizeof ( buff ) - strm . avail_out ; if ( cli_checklimits ( ""cli_scanxar"" , ctx , outsize , 0 , 0 ) != CL_CLEAN ) { break ; } if ( inf == Z_STREAM_END ) { break ; } } while ( strm . avail_out == 0 ) ; if ( rc != CL_SUCCESS ) break ; avail_in -= strm . avail_in ; if ( a_hash_ctx != NULL ) xar_hash_update ( a_hash_ctx , next_in , avail_in , a_hash ) ; } inflateEnd ( & strm ) ; break ; case CL_TYPE_7Z : # define CLI_LZMA_OBUF_SIZE 1024 * 1024 # define CLI_LZMA_HDR_SIZE LZMA_PROPS_SIZE + 8 # define CLI_LZMA_IBUF_SIZE CLI_LZMA_OBUF_SIZE >> 2 { struct CLI_LZMA lz ; <S2SV_StartBug> unsigned long in_remaining = length ; <S2SV_EndBug> unsigned long out_size = 0 ; unsigned char * buff = __lzma_wrap_alloc ( NULL , CLI_LZMA_OBUF_SIZE ) ; <S2SV_StartBug> int lret ; <S2SV_EndBug> memset ( & lz , 0 , sizeof ( lz ) ) ; if ( buff == NULL ) { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>memory<S2SV_blank>request<S2SV_blank>for<S2SV_blank>lzma<S2SV_blank>decompression<S2SV_blank>buffer<S2SV_blank>fails.\\n"" ) ; rc = CL_EMEM ; goto exit_tmpfile ; } blockp = ( void * ) fmap_need_off_once ( map , at , CLI_LZMA_HDR_SIZE ) ; if ( blockp == NULL ) { char errbuff [ 128 ] ; cli_strerror ( errno , errbuff , sizeof ( errbuff ) ) ; <S2SV_StartBug> cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>%li<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%li,<S2SV_blank>errno:%s.\\n"" , <S2SV_EndBug> length , at , errbuff ) ; rc = CL_EREAD ; __lzma_wrap_free ( NULL , buff ) ; goto exit_tmpfile ; } lz . next_in = blockp ; lz . avail_in = CLI_LZMA_HDR_SIZE ; if ( a_hash_ctx != NULL ) xar_hash_update ( a_hash_ctx , blockp , CLI_LZMA_HDR_SIZE , a_hash ) ; lret = cli_LzmaInit ( & lz , 0 ) ; if ( lret != LZMA_RESULT_OK ) { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>cli_LzmaInit()<S2SV_blank>fails:<S2SV_blank>%i.\\n"" , lret ) ; rc = CL_EFORMAT ; __lzma_wrap_free ( NULL , buff ) ; extract_errors ++ ; break ; } at += CLI_LZMA_HDR_SIZE ; in_remaining -= CLI_LZMA_HDR_SIZE ; while ( ( size_t ) at < map -> len && ( unsigned long ) at < offset + hdr . toc_length_compressed + hdr . size + length ) { SizeT avail_in ; SizeT avail_out ; void * next_in ; unsigned long in_consumed ; lz . next_out = buff ; lz . avail_out = CLI_LZMA_OBUF_SIZE ; lz . avail_in = avail_in = MIN ( CLI_LZMA_IBUF_SIZE , in_remaining ) ; lz . next_in = next_in = ( void * ) fmap_need_off_once ( map , at , lz . avail_in ) ; if ( lz . next_in == NULL ) { char errbuff [ 128 ] ; cli_strerror ( errno , errbuff , sizeof ( errbuff ) ) ; cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>%li<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%li,<S2SV_blank>errno:<S2SV_blank>%s.\\n"" , <S2SV_StartBug> length , at , errbuff ) ; <S2SV_EndBug> rc = CL_EREAD ; __lzma_wrap_free ( NULL , buff ) ; cli_LzmaShutdown ( & lz ) ; goto exit_tmpfile ; } lret = cli_LzmaDecode ( & lz ) ; if ( lret != LZMA_RESULT_OK && lret != LZMA_STREAM_END ) { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>cli_LzmaDecode()<S2SV_blank>fails:<S2SV_blank>%i.\\n"" , lret ) ; rc = CL_EFORMAT ; extract_errors ++ ; break ; } in_consumed = avail_in - lz . avail_in ; in_remaining -= in_consumed ; at += in_consumed ; avail_out = CLI_LZMA_OBUF_SIZE - lz . avail_out ; if ( avail_out == 0 ) cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>cli_LzmaDecode()<S2SV_blank>produces<S2SV_blank>no<S2SV_blank>output<S2SV_blank>for<S2SV_blank>"" ""avail_in<S2SV_blank>%llu,<S2SV_blank>avail_out<S2SV_blank>%llu.\\n"" , ( long long unsigned ) avail_in , ( long long unsigned ) avail_out ) ; if ( a_hash_ctx != NULL ) xar_hash_update ( a_hash_ctx , next_in , in_consumed , a_hash ) ; if ( e_hash_ctx != NULL ) xar_hash_update ( e_hash_ctx , buff , avail_out , e_hash ) ; if ( cli_writen ( fd , buff , avail_out ) < 0 ) { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>cli_writen<S2SV_blank>error<S2SV_blank>writing<S2SV_blank>lzma<S2SV_blank>temp<S2SV_blank>file<S2SV_blank>for<S2SV_blank>%llu<S2SV_blank>bytes.\\n"" , ( long long unsigned ) avail_out ) ; __lzma_wrap_free ( NULL , buff ) ; cli_LzmaShutdown ( & lz ) ; rc = CL_EWRITE ; goto exit_tmpfile ; } out_size += avail_out ; if ( cli_checklimits ( ""cli_scanxar"" , ctx , out_size , 0 , 0 ) != CL_CLEAN ) { break ; } if ( lret == LZMA_STREAM_END ) break ; } cli_LzmaShutdown ( & lz ) ; __lzma_wrap_free ( NULL , buff ) ; } break ; case CL_TYPE_ANY : default : case CL_TYPE_BZ : case CL_TYPE_XZ : do_extract_cksum = 0 ; { <S2SV_StartBug> unsigned long write_len ; <S2SV_EndBug> if ( ctx -> engine -> maxfilesize ) <S2SV_StartBug> write_len = MIN ( ( size_t ) ( ctx -> engine -> maxfilesize ) , ( size_t ) length ) ; <S2SV_EndBug> else write_len = length ; <S2SV_StartBug> if ( ! ( blockp = ( void * ) fmap_need_off_once ( map , at , length ) ) ) { <S2SV_EndBug> char errbuff [ 128 ] ; cli_strerror ( errno , errbuff , sizeof ( errbuff ) ) ; <S2SV_StartBug> cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>%li<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%li,<S2SV_blank>errno:%s.\\n"" , <S2SV_EndBug> length , at , errbuff ) ; rc = CL_EREAD ; goto exit_tmpfile ; } if ( a_hash_ctx != NULL ) <S2SV_StartBug> xar_hash_update ( a_hash_ctx , blockp , length , a_hash ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cli_writen ( fd , blockp , write_len ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>cli_writen<S2SV_blank>error<S2SV_blank>%li<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%li.\\n"" , length , at ) ; <S2SV_EndBug> rc = CL_EWRITE ; goto exit_tmpfile ; } } } if ( rc == CL_SUCCESS ) { if ( a_hash_ctx != NULL ) { xar_hash_final ( a_hash_ctx , result , a_hash ) ; a_hash_ctx = NULL ; } else { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>archived-checksum<S2SV_blank>missing.\\n"" ) ; cksum_fails ++ ; } if ( a_cksum != NULL ) { expected = cli_hex2str ( ( char * ) a_cksum ) ; if ( xar_hash_check ( a_hash , result , expected ) != 0 ) { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>archived-checksum<S2SV_blank>mismatch.\\n"" ) ; cksum_fails ++ ; } else { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>archived-checksum<S2SV_blank>matched.\\n"" ) ; } free ( expected ) ; } if ( e_hash_ctx != NULL ) { xar_hash_final ( e_hash_ctx , result , e_hash ) ; e_hash_ctx = NULL ; } else { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>extracted-checksum(unarchived-checksum)<S2SV_blank>missing.\\n"" ) ; cksum_fails ++ ; } if ( e_cksum != NULL ) { if ( do_extract_cksum ) { expected = cli_hex2str ( ( char * ) e_cksum ) ; if ( xar_hash_check ( e_hash , result , expected ) != 0 ) { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>extracted-checksum<S2SV_blank>mismatch.\\n"" ) ; cksum_fails ++ ; } else { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>extracted-checksum<S2SV_blank>matched.\\n"" ) ; } free ( expected ) ; } } rc = cli_magic_scandesc ( fd , ctx ) ; if ( rc != CL_SUCCESS ) { if ( rc == CL_VIRUS ) { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>Infected<S2SV_blank>with<S2SV_blank>%s\\n"" , cli_get_last_virus ( ctx ) ) ; if ( ! SCAN_ALL ) goto exit_tmpfile ; } else if ( rc != CL_BREAK ) { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>cli_magic_scandesc<S2SV_blank>error<S2SV_blank>%i\\n"" , rc ) ; goto exit_tmpfile ; } } } if ( a_cksum != NULL ) { xmlFree ( a_cksum ) ; a_cksum = NULL ; } if ( e_cksum != NULL ) { xmlFree ( e_cksum ) ; e_cksum = NULL ; } } exit_tmpfile : xar_cleanup_temp_file ( ctx , fd , tmpname ) ; if ( a_hash_ctx != NULL ) xar_hash_final ( a_hash_ctx , result , a_hash ) ; if ( e_hash_ctx != NULL ) xar_hash_final ( e_hash_ctx , result , e_hash ) ; exit_reader : if ( a_cksum != NULL ) xmlFree ( a_cksum ) ; if ( e_cksum != NULL ) xmlFree ( e_cksum ) ; xmlTextReaderClose ( reader ) ; xmlFreeTextReader ( reader ) ; exit_toc : free ( toc ) ; if ( rc == CL_BREAK ) rc = CL_SUCCESS ; # else cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>can\'t<S2SV_blank>scan<S2SV_blank>xar<S2SV_blank>files,<S2SV_blank>need<S2SV_blank>libxml2.\\n"" ) ; # endif if ( cksum_fails + extract_errors != 0 ) { <S2SV_StartBug> cli_warnmsg ( ""cli_scanxar:<S2SV_blank>%u<S2SV_blank>checksum<S2SV_blank>errors<S2SV_blank>and<S2SV_blank>%u<S2SV_blank>extraction<S2SV_blank>errors,<S2SV_blank>use<S2SV_blank>--debug<S2SV_blank>for<S2SV_blank>more<S2SV_blank>info.\\n"" , <S2SV_EndBug> cksum_fails , extract_errors ) ; } return rc ; }
","<S2SV_ModStart> -> fmap ; size_t <S2SV_ModEnd> length , offset <S2SV_ModStart> ; goto exit_toc ; } if ( hdr . toc_length_decompressed != strm . total_out ) { cli_dbgmsg ( ""TOC<S2SV_blank>decompress<S2SV_blank>length<S2SV_blank>%"" PRIu64 ""<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>amount<S2SV_blank>decompressed<S2SV_blank>%lu\\n"" , hdr . toc_length_decompressed , strm . total_out ) ; toc [ strm . total_out ] = '\\0' ; hdr . toc_length_decompressed = strm . total_out <S2SV_ModStart> } cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>decompress<S2SV_blank>into<S2SV_blank>temp<S2SV_blank>file:\\n%s,<S2SV_blank>size<S2SV_blank>%zu,\\n"" ""from<S2SV_blank>xar<S2SV_blank>heap<S2SV_blank>offset<S2SV_blank>%zu<S2SV_blank>length<S2SV_blank>%zu\\n"" <S2SV_ModEnd> , tmpname , <S2SV_ModStart> long in_remaining = MIN ( length , map -> len - at ) <S2SV_ModEnd> ; unsigned long <S2SV_ModStart> ; int lret ; if ( length > in_remaining ) length = in_remaining <S2SV_ModStart> ; cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>%i<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%li,<S2SV_blank>errno:%s.\\n"" , CLI_LZMA_HDR_SIZE <S2SV_ModEnd> , at , <S2SV_ModStart> ( ""cli_scanxar:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>%li<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%li,<S2SV_blank>errno:<S2SV_blank>%s.\\n"" , lz . avail_in <S2SV_ModEnd> , at , <S2SV_ModStart> 0 ; { size_t writelen = MIN ( map -> len - at , length ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> -> maxfilesize ) writelen <S2SV_ModEnd> = MIN ( <S2SV_ModStart> maxfilesize ) , writelen ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> , at , writelen <S2SV_ModEnd> ) ) ) <S2SV_ModStart> ; cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>%zu<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%zu,<S2SV_blank>errno:%s.\\n"" , writelen <S2SV_ModEnd> , at , <S2SV_ModStart> , blockp , writelen <S2SV_ModEnd> , a_hash ) <S2SV_ModStart> , blockp , writelen <S2SV_ModEnd> ) < 0 <S2SV_ModStart> { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>cli_writen<S2SV_blank>error<S2SV_blank>%zu<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%li.\\n"" , writelen <S2SV_ModEnd> , at ) <S2SV_ModStart> 0 ) { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>%u<S2SV_blank>checksum<S2SV_blank>errors<S2SV_blank>and<S2SV_blank>%u<S2SV_blank>extraction<S2SV_blank>errors.\\n"" <S2SV_ModEnd> , cksum_fails ,
"
1100,"CWE-119 <S2SV_StartBug> static LAYER_CONTEXT * get_layer_context ( SVC * svc ) { <S2SV_EndBug> <S2SV_StartBug> return svc -> number_temporal_layers > 1 ? <S2SV_EndBug> & svc -> layer_context [ svc -> temporal_layer_id ] : <S2SV_StartBug> & svc -> layer_context [ svc -> spatial_layer_id ] ; <S2SV_EndBug> }
","<S2SV_ModStart> * get_layer_context ( VP9_COMP * const cpi ) { if ( is_one_pass_cbr_svc ( cpi ) ) return & cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id * cpi -> svc . number_temporal_layers + cpi -> svc . temporal_layer_id ] ; else return ( cpi -> svc . <S2SV_ModEnd> number_temporal_layers > 1 <S2SV_ModStart> number_temporal_layers > 1 && cpi -> oxcf . rc_mode == VPX_CBR ) ? & cpi -> svc . layer_context [ cpi -> svc . <S2SV_ModEnd> temporal_layer_id ] : <S2SV_ModStart> ] : & cpi -> svc . layer_context [ cpi -> svc . <S2SV_ModEnd> spatial_layer_id ] ;
"
1101,"CWE-369 void * _TIFFmalloc ( tmsize_t s ) <S2SV_StartBug> { <S2SV_EndBug> return ( malloc ( ( size_t ) s ) ) ; }
","<S2SV_ModStart> s ) { if ( s == 0 ) return ( ( void * ) NULL ) ;
"
1102,"CWE-20 error_t dm9000Init ( NetInterface * interface ) { uint_t i ; uint16_t vendorId ; uint16_t productId ; <S2SV_StartBug> uint8_t chipRevision ; <S2SV_EndBug> Dm9000Context * context ; TRACE_INFO ( ""Initializing<S2SV_blank>DM9000<S2SV_blank>Ethernet<S2SV_blank>controller...\\r\\n"" ) ; interface -> extIntDriver -> init ( ) ; context = ( Dm9000Context * ) interface -> nicContext ; context -> queuedPackets = 0 ; context -> txBuffer = memPoolAlloc ( ETH_MAX_FRAME_SIZE ) ; context -> rxBuffer = memPoolAlloc ( ETH_MAX_FRAME_SIZE ) ; if ( context -> txBuffer == NULL || context -> rxBuffer == NULL ) { memPoolFree ( context -> txBuffer ) ; memPoolFree ( context -> rxBuffer ) ; return ERROR_OUT_OF_MEMORY ; } <S2SV_StartBug> vendorId = ( dm9000ReadReg ( DM9000_REG_VIDH ) << 8 ) | dm9000ReadReg ( DM9000_REG_VIDL ) ; <S2SV_EndBug> <S2SV_StartBug> productId = ( dm9000ReadReg ( DM9000_REG_PIDH ) << 8 ) | dm9000ReadReg ( DM9000_REG_PIDL ) ; <S2SV_EndBug> <S2SV_StartBug> chipRevision = dm9000ReadReg ( DM9000_REG_CHIPR ) ; <S2SV_EndBug> if ( vendorId != DM9000_VID || productId != DM9000_PID ) { return ERROR_WRONG_IDENTIFIER ; } <S2SV_StartBug> if ( chipRevision != DM9000A_CHIP_REV && chipRevision != DM9000B_CHIP_REV ) <S2SV_EndBug> { return ERROR_WRONG_IDENTIFIER ; } <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_GPR , 0x00 ) ; <S2SV_EndBug> sleep ( 10 ) ; <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_NCR , NCR_RST ) ; <S2SV_EndBug> <S2SV_StartBug> while ( ( dm9000ReadReg ( DM9000_REG_NCR ) & NCR_RST ) != 0 ) <S2SV_EndBug> { } <S2SV_StartBug> dm9000WritePhyReg ( DM9000_PHY_REG_BMCR , BMCR_RST ) ; <S2SV_EndBug> <S2SV_StartBug> while ( ( dm9000ReadPhyReg ( DM9000_PHY_REG_BMCR ) & BMCR_RST ) != 0 ) <S2SV_EndBug> { } TRACE_INFO ( ""<S2SV_blank><S2SV_blank>VID<S2SV_blank>=<S2SV_blank>0x%04"" PRIX16 ""\\r\\n"" , vendorId ) ; TRACE_INFO ( ""<S2SV_blank><S2SV_blank>PID<S2SV_blank>=<S2SV_blank>0x%04"" PRIX16 ""\\r\\n"" , productId ) ; <S2SV_StartBug> TRACE_INFO ( ""<S2SV_blank><S2SV_blank>CHIPR<S2SV_blank>=<S2SV_blank>0x%02"" PRIX8 ""\\r\\n"" , chipRevision ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_INFO ( ""<S2SV_blank><S2SV_blank>PHYIDR1<S2SV_blank>=<S2SV_blank>0x%04"" PRIX16 ""\\r\\n"" , dm9000ReadPhyReg ( DM9000_PHY_REG_PHYIDR1 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_INFO ( ""<S2SV_blank><S2SV_blank>PHYIDR2<S2SV_blank>=<S2SV_blank>0x%04"" PRIX16 ""\\r\\n"" , dm9000ReadPhyReg ( DM9000_PHY_REG_PHYIDR2 ) ) ; <S2SV_EndBug> # if ( DM9000_LOOPBACK_MODE == ENABLED ) <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_NCR , DM9000_LBK_PHY ) ; <S2SV_EndBug> <S2SV_StartBug> dm9000WritePhyReg ( DM9000_PHY_REG_BMCR , BMCR_LOOPBACK | BMCR_SPEED_SEL | BMCR_AN_EN | BMCR_DUPLEX_MODE ) ; <S2SV_EndBug> # endif for ( i = 0 ; i < 6 ; i ++ ) { <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_PAR0 + i , interface -> macAddr . b [ i ] ) ; <S2SV_EndBug> } for ( i = 0 ; i < 8 ; i ++ ) { <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_MAR0 + i , 0x00 ) ; <S2SV_EndBug> } <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_MAR7 , 0x80 ) ; <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_IMR , IMR_PAR ) ; <S2SV_EndBug> dm9000WriteReg ( DM9000_REG_NSR , NSR_WAKEST | NSR_TX2END | NSR_TX1END ) ; dm9000WriteReg ( DM9000_REG_ISR , ISR_LNKCHG | ISR_UDRUN | ISR_ROO | ISR_ROS | ISR_PT | ISR_PR ) ; dm9000WriteReg ( DM9000_REG_IMR , IMR_PAR | IMR_LNKCHGI | IMR_PTI | IMR_PRI ) ; dm9000WriteReg ( DM9000_REG_RCR , RCR_DIS_LONG | RCR_DIS_CRC | RCR_RXEN ) ; osSetEvent ( & interface -> nicTxEvent ) ; interface -> nicEvent = TRUE ; osSetEvent ( & netEvent ) ; return NO_ERROR ; }
","<S2SV_ModStart> productId ; uint8_t chipRev <S2SV_ModEnd> ; Dm9000Context * <S2SV_ModStart> ( dm9000ReadReg ( DM9000_VIDH <S2SV_ModEnd> ) << 8 <S2SV_ModStart> | dm9000ReadReg ( DM9000_VIDL <S2SV_ModEnd> ) ; productId <S2SV_ModStart> ( dm9000ReadReg ( DM9000_PIDH <S2SV_ModEnd> ) << 8 <S2SV_ModStart> | dm9000ReadReg ( DM9000_PIDL ) ; chipRev <S2SV_ModEnd> = dm9000ReadReg ( <S2SV_ModStart> = dm9000ReadReg ( DM9000_CHIPR <S2SV_ModEnd> ) ; if <S2SV_ModStart> } if ( chipRev != DM9000_CHIPR_REV_A && chipRev != DM9000_CHIPR_REV_B <S2SV_ModEnd> ) { return <S2SV_ModStart> } dm9000WriteReg ( DM9000_GPR <S2SV_ModEnd> , 0x00 ) <S2SV_ModStart> ; dm9000WriteReg ( DM9000_NCR , DM9000_NCR_RST <S2SV_ModEnd> ) ; while <S2SV_ModStart> ( dm9000ReadReg ( DM9000_NCR ) & DM9000_NCR_RST <S2SV_ModEnd> ) != 0 <S2SV_ModStart> } dm9000WritePhyReg ( DM9000_BMCR , DM9000_BMCR_RST <S2SV_ModEnd> ) ; while <S2SV_ModStart> ( dm9000ReadPhyReg ( DM9000_BMCR ) & DM9000_BMCR_RST <S2SV_ModEnd> ) != 0 <S2SV_ModStart> PRIX8 ""\\r\\n"" , chipRev <S2SV_ModEnd> ) ; TRACE_INFO <S2SV_ModStart> , dm9000ReadPhyReg ( DM9000_PHYIDR1 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> , dm9000ReadPhyReg ( DM9000_PHYIDR2 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ) dm9000WriteReg ( DM9000_NCR , DM9000_NCR_LBK_PHY <S2SV_ModEnd> ) ; dm9000WritePhyReg <S2SV_ModStart> ; dm9000WritePhyReg ( DM9000_BMCR , DM9000_BMCR_LOOPBACK | DM9000_BMCR_SPEED_SEL | DM9000_BMCR_AN_EN | DM9000_BMCR_DUPLEX_MODE <S2SV_ModEnd> ) ; # <S2SV_ModStart> { dm9000WriteReg ( DM9000_PAR0 <S2SV_ModEnd> + i , <S2SV_ModStart> { dm9000WriteReg ( DM9000_MAR0 <S2SV_ModEnd> + i , <S2SV_ModStart> } dm9000WriteReg ( DM9000_MAR7 <S2SV_ModEnd> , 0x80 ) <S2SV_ModStart> ; dm9000WriteReg ( DM9000_IMR , DM9000_IMR_PAR ) ; dm9000WriteReg ( DM9000_NSR , DM9000_NSR_WAKEST | DM9000_NSR_TX2END | DM9000_NSR_TX1END ) ; dm9000WriteReg ( DM9000_ISR , DM9000_ISR_LNKCHG | DM9000_ISR_UDRUN | DM9000_ISR_ROO | DM9000_ISR_ROS | DM9000_ISR_PT | DM9000_ISR_PR ) ; dm9000WriteReg ( DM9000_IMR , DM9000_IMR_PAR | DM9000_IMR_LNKCHGI | DM9000_IMR_PTI | DM9000_IMR_PRI ) ; dm9000WriteReg ( DM9000_RCR , DM9000_RCR_DIS_LONG | DM9000_RCR_DIS_CRC | DM9000_RCR_RXEN <S2SV_ModEnd> ) ; osSetEvent
"
1103,"CWE-189 static ssize_t _archive_write_data ( struct archive * _a , const void * buff , size_t s ) { struct archive_write * a = ( struct archive_write * ) _a ; <S2SV_StartBug> archive_check_magic ( & a -> archive , ARCHIVE_WRITE_MAGIC , <S2SV_EndBug> <S2SV_StartBug> ARCHIVE_STATE_DATA , ""archive_write_data"" ) ; <S2SV_EndBug> archive_clear_error ( & a -> archive ) ; return ( ( a -> format_write_data ) ( a , buff , s ) ) ; }
","<S2SV_ModStart> ) _a ; const size_t max_write = INT_MAX ; <S2SV_ModStart> , ""archive_write_data"" ) ; if ( s > max_write ) s = max_write
"
1104,"CWE-20 error_t httpClientSetMethod ( HttpClientContext * context , const char_t * method ) { size_t m ; size_t n ; char_t * p ; if ( context == NULL || method == NULL ) return ERROR_INVALID_PARAMETER ; n = osStrlen ( method ) ; if ( n == 0 || n > HTTP_CLIENT_MAX_METHOD_LEN ) return ERROR_INVALID_LENGTH ; if ( context -> bufferLen > HTTP_CLIENT_BUFFER_SIZE ) return ERROR_INVALID_SYNTAX ; context -> buffer [ context -> bufferLen ] = '\\0' ; <S2SV_StartBug> p = strchr ( context -> buffer , '<S2SV_blank>' ) ; <S2SV_EndBug> if ( p == NULL ) return ERROR_INVALID_SYNTAX ; m = p - context -> buffer ; if ( ( context -> bufferLen + n - m ) > HTTP_CLIENT_BUFFER_SIZE ) return ERROR_BUFFER_OVERFLOW ; osMemmove ( context -> buffer + n , p , context -> bufferLen + 1 - m ) ; osStrncpy ( context -> buffer , method , n ) ; context -> bufferLen = context -> bufferLen + n - m ; osStrcpy ( context -> method , method ) ; return NO_ERROR ; }
","<S2SV_ModStart> ; p = osStrchr <S2SV_ModEnd> ( context ->
"
1105,"CWE-254 int bzrtp_packetParser ( bzrtpContext_t * zrtpContext , bzrtpChannelContext_t * zrtpChannelContext , const uint8_t * input , uint16_t inputLength , bzrtpPacket_t * zrtpPacket ) { int i ; uint8_t * messageContent = ( uint8_t * ) ( input + ZRTP_PACKET_HEADER_LENGTH + ZRTP_MESSAGE_HEADER_LENGTH ) ; switch ( zrtpPacket -> messageType ) { case MSGTYPE_HELLO : { bzrtpHelloMessage_t * messageData ; messageData = ( bzrtpHelloMessage_t * ) malloc ( sizeof ( bzrtpHelloMessage_t ) ) ; memcpy ( messageData -> version , messageContent , 4 ) ; messageContent += 4 ; memcpy ( messageData -> clientIdentifier , messageContent , 16 ) ; messageContent += 16 ; memcpy ( messageData -> H3 , messageContent , 32 ) ; messageContent += 32 ; memcpy ( messageData -> ZID , messageContent , 12 ) ; messageContent += 12 ; messageData -> S = ( ( * messageContent ) >> 6 ) & 0x01 ; messageData -> M = ( ( * messageContent ) >> 5 ) & 0x01 ; messageData -> P = ( ( * messageContent ) >> 4 ) & 0x01 ; messageContent += 1 ; messageData -> hc = MIN ( ( * messageContent ) & 0x0F , 7 ) ; messageContent += 1 ; messageData -> cc = MIN ( ( ( * messageContent ) >> 4 ) & 0x0F , 7 ) ; messageData -> ac = MIN ( ( * messageContent ) & 0x0F , 7 ) ; messageContent += 1 ; messageData -> kc = MIN ( ( ( * messageContent ) >> 4 ) & 0x0F , 7 ) ; messageData -> sc = MIN ( ( * messageContent ) & 0x0F , 7 ) ; messageContent += 1 ; if ( zrtpPacket -> messageLength != ZRTP_HELLOMESSAGE_FIXED_LENGTH + 4 * ( ( uint16_t ) ( messageData -> hc ) + ( uint16_t ) ( messageData -> cc ) + ( uint16_t ) ( messageData -> ac ) + ( uint16_t ) ( messageData -> kc ) + ( uint16_t ) ( messageData -> sc ) ) ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_INVALIDMESSAGE ; } for ( i = 0 ; i < messageData -> hc ; i ++ ) { messageData -> supportedHash [ i ] = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_HASH_TYPE ) ; messageContent += 4 ; } for ( i = 0 ; i < messageData -> cc ; i ++ ) { messageData -> supportedCipher [ i ] = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_CIPHERBLOCK_TYPE ) ; messageContent += 4 ; } for ( i = 0 ; i < messageData -> ac ; i ++ ) { messageData -> supportedAuthTag [ i ] = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_AUTHTAG_TYPE ) ; messageContent += 4 ; } for ( i = 0 ; i < messageData -> kc ; i ++ ) { messageData -> supportedKeyAgreement [ i ] = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_KEYAGREEMENT_TYPE ) ; messageContent += 4 ; } for ( i = 0 ; i < messageData -> sc ; i ++ ) { messageData -> supportedSas [ i ] = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_SAS_TYPE ) ; messageContent += 4 ; } addMandatoryCryptoTypesIfNeeded ( ZRTP_HASH_TYPE , messageData -> supportedHash , & messageData -> hc ) ; addMandatoryCryptoTypesIfNeeded ( ZRTP_CIPHERBLOCK_TYPE , messageData -> supportedCipher , & messageData -> cc ) ; addMandatoryCryptoTypesIfNeeded ( ZRTP_AUTHTAG_TYPE , messageData -> supportedAuthTag , & messageData -> ac ) ; addMandatoryCryptoTypesIfNeeded ( ZRTP_KEYAGREEMENT_TYPE , messageData -> supportedKeyAgreement , & messageData -> kc ) ; addMandatoryCryptoTypesIfNeeded ( ZRTP_SAS_TYPE , messageData -> supportedSas , & messageData -> sc ) ; memcpy ( messageData -> MAC , messageContent , 8 ) ; zrtpPacket -> messageData = ( void * ) messageData ; zrtpPacket -> packetString = ( uint8_t * ) malloc ( inputLength * sizeof ( uint8_t ) ) ; memcpy ( zrtpPacket -> packetString , input , inputLength ) ; } break ; case MSGTYPE_HELLOACK : { if ( zrtpPacket -> messageLength != ZRTP_HELLOACKMESSAGE_FIXED_LENGTH ) { return BZRTP_PARSER_ERROR_INVALIDMESSAGE ; } } break ; case MSGTYPE_COMMIT : { uint8_t checkH3 [ 32 ] ; uint8_t checkMAC [ 32 ] ; bzrtpHelloMessage_t * peerHelloMessageData ; uint16_t variableLength = 0 ; bzrtpCommitMessage_t * messageData ; messageData = ( bzrtpCommitMessage_t * ) malloc ( sizeof ( bzrtpCommitMessage_t ) ) ; memcpy ( messageData -> H2 , messageContent , 32 ) ; messageContent += 32 ; if ( zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] == NULL ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE ; } peerHelloMessageData = ( bzrtpHelloMessage_t * ) zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> messageData ; bctoolbox_sha256 ( messageData -> H2 , 32 , 32 , checkH3 ) ; if ( memcmp ( checkH3 , peerHelloMessageData -> H3 , 32 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN ; } bctoolbox_hmacSha256 ( messageData -> H2 , 32 , zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> messageLength - 8 , 8 , checkMAC ) ; if ( memcmp ( checkMAC , peerHelloMessageData -> MAC , 8 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGMAC ; } memcpy ( messageData -> ZID , messageContent , 12 ) ; messageContent += 12 ; messageData -> hashAlgo = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_HASH_TYPE ) ; messageContent += 4 ; messageData -> cipherAlgo = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_CIPHERBLOCK_TYPE ) ; messageContent += 4 ; messageData -> authTagAlgo = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_AUTHTAG_TYPE ) ; messageContent += 4 ; messageData -> keyAgreementAlgo = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_KEYAGREEMENT_TYPE ) ; messageContent += 4 ; switch ( messageData -> keyAgreementAlgo ) { case ZRTP_KEYAGREEMENT_DH2k : case ZRTP_KEYAGREEMENT_EC25 : case ZRTP_KEYAGREEMENT_DH3k : case ZRTP_KEYAGREEMENT_EC38 : case ZRTP_KEYAGREEMENT_EC52 : variableLength = 32 ; break ; case ZRTP_KEYAGREEMENT_Prsh : variableLength = 24 ; break ; case ZRTP_KEYAGREEMENT_Mult : variableLength = 16 ; break ; default : free ( messageData ) ; return BZRTP_PARSER_ERROR_INVALIDMESSAGE ; } if ( zrtpPacket -> messageLength != ZRTP_COMMITMESSAGE_FIXED_LENGTH + variableLength ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_INVALIDMESSAGE ; } messageData -> sasAlgo = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_SAS_TYPE ) ; messageContent += 4 ; if ( ( messageData -> keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh ) || ( messageData -> keyAgreementAlgo == ZRTP_KEYAGREEMENT_Mult ) ) { memcpy ( messageData -> nonce , messageContent , 16 ) ; messageContent += 16 ; if ( messageData -> keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh ) { memcpy ( messageData -> keyID , messageContent , 8 ) ; messageContent += 8 ; } } else { memcpy ( messageData -> hvi , messageContent , 32 ) ; messageContent += 32 ; } memcpy ( messageData -> MAC , messageContent , 8 ) ; zrtpPacket -> messageData = ( void * ) messageData ; zrtpPacket -> packetString = ( uint8_t * ) malloc ( inputLength * sizeof ( uint8_t ) ) ; memcpy ( zrtpPacket -> packetString , input , inputLength ) ; } break ; case MSGTYPE_DHPART1 : case MSGTYPE_DHPART2 : { bzrtpDHPartMessage_t * messageData ; uint16_t pvLength = computeKeyAgreementPrivateValueLength ( zrtpChannelContext -> keyAgreementAlgo ) ; if ( pvLength == 0 ) { return BZRTP_PARSER_ERROR_INVALIDCONTEXT ; } if ( zrtpPacket -> messageLength != ZRTP_DHPARTMESSAGE_FIXED_LENGTH + pvLength ) { return BZRTP_PARSER_ERROR_INVALIDMESSAGE ; } messageData = ( bzrtpDHPartMessage_t * ) malloc ( sizeof ( bzrtpDHPartMessage_t ) ) ; messageData -> pv = ( uint8_t * ) malloc ( pvLength * sizeof ( uint8_t ) ) ; memcpy ( messageData -> H1 , messageContent , 32 ) ; messageContent += 32 ; if ( zrtpChannelContext -> role == RESPONDER ) { uint8_t checkH2 [ 32 ] ; uint8_t checkMAC [ 32 ] ; bzrtpCommitMessage_t * peerCommitMessageData ; if ( zrtpChannelContext -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] == NULL ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE ; } peerCommitMessageData = ( bzrtpCommitMessage_t * ) zrtpChannelContext -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] -> messageData ; bctoolbox_sha256 ( messageData -> H1 , 32 , 32 , checkH2 ) ; if ( memcmp ( checkH2 , peerCommitMessageData -> H2 , 32 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN ; } bctoolbox_hmacSha256 ( messageData -> H1 , 32 , zrtpChannelContext -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , zrtpChannelContext -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] -> messageLength - 8 , 8 , checkMAC ) ; if ( memcmp ( checkMAC , peerCommitMessageData -> MAC , 8 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGMAC ; } <S2SV_StartBug> } else { <S2SV_EndBug> uint8_t checkH2 [ 32 ] ; uint8_t checkH3 [ 32 ] ; uint8_t checkMAC [ 32 ] ; bzrtpHelloMessage_t * peerHelloMessageData ; if ( zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] == NULL ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE ; } peerHelloMessageData = ( bzrtpHelloMessage_t * ) zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> messageData ; bctoolbox_sha256 ( messageData -> H1 , 32 , 32 , checkH2 ) ; bctoolbox_sha256 ( checkH2 , 32 , 32 , checkH3 ) ; if ( memcmp ( checkH3 , peerHelloMessageData -> H3 , 32 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN ; } bctoolbox_hmacSha256 ( checkH2 , 32 , zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> messageLength - 8 , 8 , checkMAC ) ; if ( memcmp ( checkMAC , peerHelloMessageData -> MAC , 8 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGMAC ; } } memcpy ( messageData -> rs1ID , messageContent , 8 ) ; messageContent += 8 ; memcpy ( messageData -> rs2ID , messageContent , 8 ) ; messageContent += 8 ; memcpy ( messageData -> auxsecretID , messageContent , 8 ) ; messageContent += 8 ; memcpy ( messageData -> pbxsecretID , messageContent , 8 ) ; messageContent += 8 ; memcpy ( messageData -> pv , messageContent , pvLength ) ; messageContent += pvLength ; memcpy ( messageData -> MAC , messageContent , 8 ) ; zrtpPacket -> messageData = ( void * ) messageData ; zrtpPacket -> packetString = ( uint8_t * ) malloc ( inputLength * sizeof ( uint8_t ) ) ; memcpy ( zrtpPacket -> packetString , input , inputLength ) ; } break ; case MSGTYPE_CONFIRM1 : case MSGTYPE_CONFIRM2 : { uint8_t * confirmMessageKey = NULL ; uint8_t * confirmMessageMacKey = NULL ; bzrtpConfirmMessage_t * messageData ; uint16_t cipherTextLength ; uint8_t computedHmac [ 8 ] ; uint8_t * confirmPlainMessageBuffer ; uint8_t * confirmPlainMessage ; if ( zrtpChannelContext -> role == RESPONDER ) { if ( ( zrtpChannelContext -> zrtpkeyi == NULL ) || ( zrtpChannelContext -> mackeyi == NULL ) ) { return BZRTP_PARSER_ERROR_INVALIDCONTEXT ; } confirmMessageKey = zrtpChannelContext -> zrtpkeyi ; confirmMessageMacKey = zrtpChannelContext -> mackeyi ; } if ( zrtpChannelContext -> role == INITIATOR ) { if ( ( zrtpChannelContext -> zrtpkeyr == NULL ) || ( zrtpChannelContext -> mackeyr == NULL ) ) { return BZRTP_PARSER_ERROR_INVALIDCONTEXT ; } confirmMessageKey = zrtpChannelContext -> zrtpkeyr ; confirmMessageMacKey = zrtpChannelContext -> mackeyr ; } messageData = ( bzrtpConfirmMessage_t * ) malloc ( sizeof ( bzrtpConfirmMessage_t ) ) ; memcpy ( messageData -> confirm_mac , messageContent , 8 ) ; messageContent += 8 ; memcpy ( messageData -> CFBIV , messageContent , 16 ) ; messageContent += 16 ; cipherTextLength = zrtpPacket -> messageLength - ZRTP_MESSAGE_HEADER_LENGTH - 24 ; zrtpChannelContext -> hmacFunction ( confirmMessageMacKey , zrtpChannelContext -> hashLength , messageContent , cipherTextLength , 8 , computedHmac ) ; if ( memcmp ( computedHmac , messageData -> confirm_mac , 8 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGCONFIRMMAC ; } confirmPlainMessageBuffer = ( uint8_t * ) malloc ( cipherTextLength * sizeof ( uint8_t ) ) ; zrtpChannelContext -> cipherDecryptionFunction ( confirmMessageKey , messageData -> CFBIV , messageContent , cipherTextLength , confirmPlainMessageBuffer ) ; confirmPlainMessage = confirmPlainMessageBuffer ; memcpy ( messageData -> H0 , confirmPlainMessage , 32 ) ; confirmPlainMessage += 33 ; if ( zrtpChannelContext -> keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh || zrtpChannelContext -> keyAgreementAlgo == ZRTP_KEYAGREEMENT_Mult ) { uint8_t checkH1 [ 32 ] ; bctoolbox_sha256 ( messageData -> H0 , 32 , 32 , checkH1 ) ; if ( zrtpChannelContext -> role == RESPONDER ) { uint8_t checkH2 [ 32 ] ; uint8_t checkMAC [ 32 ] ; bzrtpCommitMessage_t * peerCommitMessageData ; if ( zrtpChannelContext -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] == NULL ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE ; } peerCommitMessageData = ( bzrtpCommitMessage_t * ) zrtpChannelContext -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] -> messageData ; bctoolbox_sha256 ( checkH1 , 32 , 32 , checkH2 ) ; if ( memcmp ( checkH2 , peerCommitMessageData -> H2 , 32 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN ; } bctoolbox_hmacSha256 ( checkH1 , 32 , zrtpChannelContext -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , zrtpChannelContext -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] -> messageLength - 8 , 8 , checkMAC ) ; if ( memcmp ( checkMAC , peerCommitMessageData -> MAC , 8 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGMAC ; } } else { uint8_t checkH2 [ 32 ] ; uint8_t checkH3 [ 32 ] ; uint8_t checkMAC [ 32 ] ; bzrtpHelloMessage_t * peerHelloMessageData ; if ( zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] == NULL ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE ; } peerHelloMessageData = ( bzrtpHelloMessage_t * ) zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> messageData ; bctoolbox_sha256 ( checkH1 , 32 , 32 , checkH2 ) ; bctoolbox_sha256 ( checkH2 , 32 , 32 , checkH3 ) ; if ( memcmp ( checkH3 , peerHelloMessageData -> H3 , 32 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN ; } bctoolbox_hmacSha256 ( checkH2 , 32 , zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> messageLength - 8 , 8 , checkMAC ) ; if ( memcmp ( checkMAC , peerHelloMessageData -> MAC , 8 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGMAC ; } } } else { uint8_t checkH1 [ 32 ] ; uint8_t checkMAC [ 32 ] ; bzrtpDHPartMessage_t * peerDHPartMessageData ; if ( zrtpChannelContext -> peerPackets [ DHPART_MESSAGE_STORE_ID ] == NULL ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE ; } peerDHPartMessageData = ( bzrtpDHPartMessage_t * ) zrtpChannelContext -> peerPackets [ DHPART_MESSAGE_STORE_ID ] -> messageData ; bctoolbox_sha256 ( messageData -> H0 , 32 , 32 , checkH1 ) ; if ( memcmp ( checkH1 , peerDHPartMessageData -> H1 , 32 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN ; } bctoolbox_hmacSha256 ( messageData -> H0 , 32 , zrtpChannelContext -> peerPackets [ DHPART_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , zrtpChannelContext -> peerPackets [ DHPART_MESSAGE_STORE_ID ] -> messageLength - 8 , 8 , checkMAC ) ; if ( memcmp ( checkMAC , peerDHPartMessageData -> MAC , 8 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGMAC ; } } messageData -> sig_len = ( ( uint16_t ) ( confirmPlainMessage [ 0 ] & 0x01 ) ) << 8 | ( ( ( uint16_t ) confirmPlainMessage [ 1 ] ) & 0x00FF ) ; confirmPlainMessage += 2 ; messageData -> E = ( ( * confirmPlainMessage ) & 0x08 ) >> 3 ; messageData -> V = ( ( * confirmPlainMessage ) & 0x04 ) >> 2 ; messageData -> A = ( ( * confirmPlainMessage ) & 0x02 ) >> 1 ; messageData -> D = ( * confirmPlainMessage ) & 0x01 ; confirmPlainMessage += 1 ; messageData -> cacheExpirationInterval = ( ( ( uint32_t ) confirmPlainMessage [ 0 ] ) << 24 ) | ( ( ( uint32_t ) confirmPlainMessage [ 1 ] ) << 16 ) | ( ( ( uint32_t ) confirmPlainMessage [ 2 ] ) << 8 ) | ( ( uint32_t ) confirmPlainMessage [ 3 ] ) ; confirmPlainMessage += 4 ; if ( messageData -> sig_len > 0 ) { memcpy ( messageData -> signatureBlockType , confirmPlainMessage , 4 ) ; confirmPlainMessage += 4 ; messageData -> signatureBlock = ( uint8_t * ) malloc ( 4 * ( messageData -> sig_len - 1 ) * sizeof ( uint8_t ) ) ; memcpy ( messageData -> signatureBlock , confirmPlainMessage , 4 * ( messageData -> sig_len - 1 ) ) ; } else { messageData -> signatureBlock = NULL ; } free ( confirmPlainMessageBuffer ) ; zrtpPacket -> packetString = ( uint8_t * ) malloc ( inputLength * sizeof ( uint8_t ) ) ; memcpy ( zrtpPacket -> packetString , input , inputLength ) ; zrtpPacket -> messageData = ( void * ) messageData ; } break ; case MSGTYPE_CONF2ACK : break ; case MSGTYPE_PING : { bzrtpPingMessage_t * messageData ; messageData = ( bzrtpPingMessage_t * ) malloc ( sizeof ( bzrtpPingMessage_t ) ) ; memcpy ( messageData -> version , messageContent , 4 ) ; messageContent += 4 ; memcpy ( messageData -> endpointHash , messageContent , 8 ) ; zrtpPacket -> messageData = ( void * ) messageData ; } break ; } return 0 ; }
","<S2SV_ModStart> BZRTP_PARSER_ERROR_UNMATCHINGMAC ; } { uint8_t computedHvi [ 32 ] ; uint16_t HelloMessageLength = zrtpChannelContext -> selfPackets [ HELLO_MESSAGE_STORE_ID ] -> messageLength ; uint16_t DHPartHelloMessageStringLength = zrtpPacket -> messageLength + HelloMessageLength ; uint8_t * DHPartHelloMessageString = ( uint8_t * ) malloc ( DHPartHelloMessageStringLength * sizeof ( uint8_t ) ) ; memcpy ( DHPartHelloMessageString , input + ZRTP_PACKET_HEADER_LENGTH , zrtpPacket -> messageLength ) ; memcpy ( DHPartHelloMessageString + zrtpPacket -> messageLength , zrtpChannelContext -> selfPackets [ HELLO_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , HelloMessageLength ) ; zrtpChannelContext -> hashFunction ( DHPartHelloMessageString , DHPartHelloMessageStringLength , 32 , computedHvi ) ; free ( DHPartHelloMessageString ) ; if ( memcmp ( computedHvi , peerCommitMessageData -> hvi , 32 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGHVI ; } }
"
1106,"CWE-787 TEE_Result tee_mmu_check_access_rights ( const struct user_ta_ctx * utc , uint32_t flags , uaddr_t uaddr , size_t len ) { uaddr_t a ; <S2SV_StartBug> size_t addr_incr = MIN ( CORE_MMU_USER_CODE_SIZE , <S2SV_EndBug> CORE_MMU_USER_PARAM_SIZE ) ; <S2SV_StartBug> if ( ADD_OVERFLOW ( uaddr , len , & a ) ) <S2SV_EndBug> return TEE_ERROR_ACCESS_DENIED ; if ( ( flags & TEE_MEMORY_ACCESS_NONSECURE ) && ( flags & TEE_MEMORY_ACCESS_SECURE ) ) return TEE_ERROR_ACCESS_DENIED ; if ( ! ( flags & TEE_MEMORY_ACCESS_ANY_OWNER ) && ! tee_mmu_is_vbuf_inside_ta_private ( utc , ( void * ) uaddr , len ) ) return TEE_ERROR_ACCESS_DENIED ; <S2SV_StartBug> for ( a = uaddr ; a < ( uaddr + len ) ; a += addr_incr ) { <S2SV_EndBug> uint32_t attr ; TEE_Result res ; res = tee_mmu_user_va2pa_attr ( utc , ( void * ) a , NULL , & attr ) ; if ( res != TEE_SUCCESS ) return res ; if ( ( flags & TEE_MEMORY_ACCESS_NONSECURE ) && ( attr & TEE_MATTR_SECURE ) ) return TEE_ERROR_ACCESS_DENIED ; if ( ( flags & TEE_MEMORY_ACCESS_SECURE ) && ! ( attr & TEE_MATTR_SECURE ) ) return TEE_ERROR_ACCESS_DENIED ; if ( ( flags & TEE_MEMORY_ACCESS_WRITE ) && ! ( attr & TEE_MATTR_UW ) ) return TEE_ERROR_ACCESS_DENIED ; if ( ( flags & TEE_MEMORY_ACCESS_READ ) && ! ( attr & TEE_MATTR_UR ) ) return TEE_ERROR_ACCESS_DENIED ; } return TEE_SUCCESS ; }
","<S2SV_ModStart> uaddr_t a ; uaddr_t end_addr = 0 ; <S2SV_ModStart> len , & end_addr <S2SV_ModEnd> ) ) return <S2SV_ModStart> ( a = ROUNDDOWN ( uaddr , addr_incr ) <S2SV_ModEnd> ; a < <S2SV_ModStart> ; a < end_addr <S2SV_ModEnd> ; a +=
"
1107,"CWE-20 void freeClient ( redisClient * c ) { listNode * ln ; sdsfree ( c -> querybuf ) ; c -> querybuf = NULL ; if ( c -> flags & REDIS_BLOCKED ) unblockClientWaitingData ( c ) ; unwatchAllKeys ( c ) ; listRelease ( c -> watched_keys ) ; pubsubUnsubscribeAllChannels ( c , 0 ) ; pubsubUnsubscribeAllPatterns ( c , 0 ) ; dictRelease ( c -> pubsub_channels ) ; listRelease ( c -> pubsub_patterns ) ; aeDeleteFileEvent ( server . el , c -> fd , AE_READABLE ) ; aeDeleteFileEvent ( server . el , c -> fd , AE_WRITABLE ) ; listRelease ( c -> reply ) ; freeClientArgv ( c ) ; close ( c -> fd ) ; ln = listSearchKey ( server . clients , c ) ; redisAssert ( ln != NULL ) ; listDelNode ( server . clients , ln ) ; if ( c -> flags & REDIS_IO_WAIT ) { <S2SV_StartBug> redisAssert ( server . vm_enabled ) ; <S2SV_EndBug> if ( listLength ( c -> io_keys ) == 0 ) { ln = listSearchKey ( server . io_ready_clients , c ) ; redisAssert ( ln != NULL ) ; listDelNode ( server . io_ready_clients , ln ) ; } else { while ( listLength ( c -> io_keys ) ) { ln = listFirst ( c -> io_keys ) ; dontWaitForSwappedKey ( c , ln -> value ) ; } } <S2SV_StartBug> server . vm_blocked_clients -- ; <S2SV_EndBug> } listRelease ( c -> io_keys ) ; if ( c -> flags & REDIS_SLAVE ) { if ( c -> replstate == REDIS_REPL_SEND_BULK && c -> repldbfd != - 1 ) close ( c -> repldbfd ) ; list * l = ( c -> flags & REDIS_MONITOR ) ? server . monitors : server . slaves ; ln = listSearchKey ( l , c ) ; redisAssert ( ln != NULL ) ; listDelNode ( l , ln ) ; } if ( c -> flags & REDIS_MASTER ) { server . master = NULL ; server . replstate = REDIS_REPL_CONNECT ; while ( listLength ( server . slaves ) ) { ln = listFirst ( server . slaves ) ; freeClient ( ( redisClient * ) ln -> value ) ; } } zfree ( c -> argv ) ; freeClientMultiState ( c ) ; zfree ( c ) ; }
","<S2SV_ModStart> ( server . ds_enabled <S2SV_ModEnd> ) ; if <S2SV_ModStart> } server . cache_blocked_clients <S2SV_ModEnd> -- ; }
"
1108,"CWE-20 static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d:<S2SV_blank>Client<S2SV_blank>using<S2SV_blank>the<S2SV_blank>%s<S2SV_blank>protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d:<S2SV_blank>Realign<S2SV_blank>input<S2SV_blank>buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d<S2SV_blank>Read<S2SV_blank>binary<S2SV_blank>protocol<S2SV_blank>data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d<S2SV_blank><S2SV_blank><S2SV_blank>"" , c -> sfd ) ; } fprintf ( stderr , ""<S2SV_blank>0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid<S2SV_blank>magic:<S2SV_blank><S2SV_blank>%x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; <S2SV_StartBug> if ( ! el ) <S2SV_EndBug> return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
","<S2SV_ModStart> ! el ) { if ( c -> rbytes > 1024 ) { char * ptr = c -> rcurr ; while ( * ptr == '<S2SV_blank>' ) { ++ ptr ; } if ( strcmp ( ptr , ""get<S2SV_blank>"" ) && strcmp ( ptr , ""gets<S2SV_blank>"" ) ) { conn_set_state ( c , conn_closing ) ; return 1 ; } } return 0 ; } <S2SV_ModEnd> cont = el
"
1109,"CWE-000 static int iwch_l2t_send ( struct t3cdev * tdev , struct sk_buff * skb , struct l2t_entry * l2e ) { int error = 0 ; struct cxio_rdev * rdev ; rdev = ( struct cxio_rdev * ) tdev -> ulp ; if ( cxio_fatal_error ( rdev ) ) { kfree_skb ( skb ) ; return - EIO ; } error = l2t_send ( tdev , skb , l2e ) ; if ( error < 0 ) kfree_skb ( skb ) ; <S2SV_StartBug> return error ; <S2SV_EndBug> }
","<S2SV_ModStart> ; return error < 0 ? error : 0
"
1110,"CWE-476 int fscrypt_get_encryption_info ( struct inode * inode ) { <S2SV_StartBug> struct fscrypt_info * ci = inode -> i_crypt_info ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ci || <S2SV_EndBug> ( ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ) return fscrypt_get_crypt_info ( inode ) ; return 0 ; }
","<S2SV_ModStart> struct fscrypt_info * crypt_info ; struct fscrypt_context ctx ; struct crypto_skcipher * ctfm ; const char * cipher_str ; int keysize ; u8 * raw_key = NULL ; int res ; if ( <S2SV_ModEnd> inode -> i_crypt_info <S2SV_ModStart> inode -> i_crypt_info ) return 0 ; res = fscrypt_initialize ( inode -> i_sb -> s_cop -> flags ) ; if ( res ) return res <S2SV_ModStart> if ( ! inode -> i_sb -> s_cop -> get_context ) return - EOPNOTSUPP ; res = inode -> i_sb -> s_cop -> get_context ( inode , & ctx , sizeof ( ctx ) ) ; if ( res < 0 ) { if ( ! fscrypt_dummy_context_enabled ( inode ) || inode -> i_sb -> s_cop -> is_encrypted ( inode ) ) return res ; memset ( & ctx , 0 , sizeof ( ctx ) ) ; ctx . format = FS_ENCRYPTION_CONTEXT_FORMAT_V1 ; ctx . contents_encryption_mode = FS_ENCRYPTION_MODE_AES_256_XTS ; ctx . filenames_encryption_mode = FS_ENCRYPTION_MODE_AES_256_CTS ; memset ( ctx . master_key_descriptor , 0x42 , FS_KEY_DESCRIPTOR_SIZE ) ; } else if ( res != sizeof ( ctx ) ) { return - EINVAL ; } if ( ctx . format != FS_ENCRYPTION_CONTEXT_FORMAT_V1 ) return - EINVAL ; if ( ctx . flags & ~ FS_POLICY_FLAGS_VALID ) return - EINVAL ; crypt_info = kmem_cache_alloc ( fscrypt_info_cachep , GFP_NOFS ) ; if ( ! crypt_info ) return - ENOMEM ; crypt_info -> ci_flags = ctx . flags ; crypt_info -> ci_data_mode = ctx . contents_encryption_mode ; crypt_info -> ci_filename_mode = ctx . filenames_encryption_mode ; crypt_info -> ci_ctfm = NULL ; memcpy ( crypt_info -> ci_master_key , ctx . master_key_descriptor , sizeof ( crypt_info -> ci_master_key ) ) ; res = determine_cipher_type ( crypt_info , inode , & cipher_str , & keysize ) ; if ( res ) goto out ; res = - ENOMEM ; raw_key = kmalloc ( FS_MAX_KEY_SIZE , GFP_NOFS ) ; if ( ! raw_key ) goto out ; res = validate_user_key ( crypt_info , & ctx , raw_key , FS_KEY_DESC_PREFIX ) ; if ( res && inode -> i_sb -> s_cop -> key_prefix ) { int res2 = validate_user_key ( crypt_info , & ctx , raw_key , inode -> i_sb -> s_cop -> key_prefix ) ; if ( res2 ) { if ( res2 == - ENOKEY ) res = - ENOKEY ; goto out ; } } else if ( res ) { goto out ; } ctfm = crypto_alloc_skcipher ( cipher_str , 0 , 0 ) ; if ( ! ctfm || IS_ERR ( ctfm ) ) { res = ctfm ? PTR_ERR ( ctfm ) : - ENOMEM ; printk ( KERN_DEBUG ""%s:<S2SV_blank>error<S2SV_blank>%d<S2SV_blank>(inode<S2SV_blank>%u)<S2SV_blank>allocating<S2SV_blank>crypto<S2SV_blank>tfm\\n"" , __func__ , res , ( unsigned ) inode -> i_ino ) ; goto out ; } crypt_info -> ci_ctfm = ctfm ; crypto_skcipher_clear_flags ( ctfm , ~ 0 ) ; crypto_skcipher_set_flags ( ctfm , CRYPTO_TFM_REQ_WEAK_KEY ) ; res = crypto_skcipher_setkey ( ctfm , raw_key , keysize ) ; if ( res ) goto out ; if ( cmpxchg ( & inode -> i_crypt_info , NULL , crypt_info ) == NULL ) crypt_info = NULL ; out : if ( res == - ENOKEY ) res = 0 ; put_crypt_info ( crypt_info ) ; kzfree ( raw_key ) ; return res <S2SV_ModEnd> ; } <S2SV_null>
"
1111,"CWE-476 static OM_uint32 acc_ctx_cont ( OM_uint32 * minstat , gss_buffer_t buf , gss_ctx_id_t * ctx , gss_buffer_t * responseToken , gss_buffer_t * mechListMIC , OM_uint32 * negState , send_token_flag * return_token ) { OM_uint32 ret , tmpmin ; gss_OID supportedMech ; spnego_gss_ctx_id_t sc ; unsigned int len ; unsigned char * ptr , * bufstart ; sc = ( spnego_gss_ctx_id_t ) * ctx ; ret = GSS_S_DEFECTIVE_TOKEN ; * negState = REJECT ; * minstat = 0 ; supportedMech = GSS_C_NO_OID ; * return_token = ERROR_TOKEN_SEND ; * responseToken = * mechListMIC = GSS_C_NO_BUFFER ; ptr = bufstart = buf -> value ; # define REMAIN ( buf -> length - ( ptr - bufstart ) ) <S2SV_StartBug> if ( REMAIN > INT_MAX ) <S2SV_EndBug> return GSS_S_DEFECTIVE_TOKEN ; if ( * ptr == HEADER_ID ) { ret = g_verify_token_header ( gss_mech_spnego , & len , & ptr , 0 , REMAIN ) ; if ( ret ) { * minstat = ret ; return GSS_S_DEFECTIVE_TOKEN ; } } if ( * ptr != ( CONTEXT | 0x01 ) ) { return GSS_S_DEFECTIVE_TOKEN ; } ret = get_negTokenResp ( minstat , ptr , REMAIN , negState , & supportedMech , responseToken , mechListMIC ) ; if ( ret != GSS_S_COMPLETE ) goto cleanup ; if ( * responseToken == GSS_C_NO_BUFFER && * mechListMIC == GSS_C_NO_BUFFER ) { ret = GSS_S_DEFECTIVE_TOKEN ; goto cleanup ; } if ( supportedMech != GSS_C_NO_OID ) { ret = GSS_S_DEFECTIVE_TOKEN ; goto cleanup ; } sc -> firstpass = 0 ; * negState = ACCEPT_INCOMPLETE ; * return_token = CONT_TOKEN_SEND ; cleanup : if ( supportedMech != GSS_C_NO_OID ) { generic_gss_release_oid ( & tmpmin , & supportedMech ) ; } return ret ; # undef REMAIN }
","<S2SV_ModStart> if ( REMAIN == 0 || REMAIN
"
1112,"CWE-863 static ssize_t map_write ( struct file * file , const char __user * buf , size_t count , loff_t * ppos , int cap_setid , struct uid_gid_map * map , struct uid_gid_map * parent_map ) { struct seq_file * seq = file -> private_data ; struct user_namespace * ns = seq -> private ; struct uid_gid_map new_map ; unsigned idx ; struct uid_gid_extent extent ; char * kbuf = NULL , * pos , * next_line ; ssize_t ret ; if ( ( * ppos != 0 ) || ( count >= PAGE_SIZE ) ) return - EINVAL ; kbuf = memdup_user_nul ( buf , count ) ; if ( IS_ERR ( kbuf ) ) return PTR_ERR ( kbuf ) ; mutex_lock ( & userns_state_mutex ) ; memset ( & new_map , 0 , sizeof ( struct uid_gid_map ) ) ; ret = - EPERM ; if ( map -> nr_extents != 0 ) goto out ; if ( cap_valid ( cap_setid ) && ! file_ns_capable ( file , ns , CAP_SYS_ADMIN ) ) goto out ; ret = - EINVAL ; pos = kbuf ; for ( ; pos ; pos = next_line ) { next_line = strchr ( pos , '\\n' ) ; if ( next_line ) { * next_line = '\\0' ; next_line ++ ; if ( * next_line == '\\0' ) next_line = NULL ; } pos = skip_spaces ( pos ) ; extent . first = simple_strtoul ( pos , & pos , 10 ) ; if ( ! isspace ( * pos ) ) goto out ; pos = skip_spaces ( pos ) ; extent . lower_first = simple_strtoul ( pos , & pos , 10 ) ; if ( ! isspace ( * pos ) ) goto out ; pos = skip_spaces ( pos ) ; extent . count = simple_strtoul ( pos , & pos , 10 ) ; if ( * pos && ! isspace ( * pos ) ) goto out ; pos = skip_spaces ( pos ) ; if ( * pos != '\\0' ) goto out ; if ( ( extent . first == ( u32 ) - 1 ) || ( extent . lower_first == ( u32 ) - 1 ) ) goto out ; if ( ( extent . first + extent . count ) <= extent . first ) goto out ; if ( ( extent . lower_first + extent . count ) <= extent . lower_first ) goto out ; if ( mappings_overlap ( & new_map , & extent ) ) goto out ; if ( ( new_map . nr_extents + 1 ) == UID_GID_MAP_MAX_EXTENTS && ( next_line != NULL ) ) goto out ; ret = insert_extent ( & new_map , & extent ) ; if ( ret < 0 ) goto out ; ret = - EINVAL ; } if ( new_map . nr_extents == 0 ) goto out ; ret = - EPERM ; <S2SV_StartBug> if ( ! new_idmap_permitted ( file , ns , cap_setid , & new_map ) ) <S2SV_EndBug> goto out ; ret = sort_idmaps ( & new_map ) ; if ( ret < 0 ) goto out ; ret = - EPERM ; for ( idx = 0 ; idx < new_map . nr_extents ; idx ++ ) { struct uid_gid_extent * e ; u32 lower_first ; if ( new_map . nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS ) e = & new_map . extent [ idx ] ; else e = & new_map . forward [ idx ] ; lower_first = map_id_range_down ( parent_map , e -> lower_first , e -> count ) ; if ( lower_first == ( u32 ) - 1 ) goto out ; e -> lower_first = lower_first ; } <S2SV_StartBug> if ( new_map . nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS ) { <S2SV_EndBug> memcpy ( map -> extent , new_map . extent , new_map . nr_extents * sizeof ( new_map . extent [ 0 ] ) ) ; } else { map -> forward = new_map . forward ; map -> reverse = new_map . reverse ; } smp_wmb ( ) ; map -> nr_extents = new_map . nr_extents ; * ppos = count ; ret = count ; out : if ( ret < 0 && new_map . nr_extents > UID_GID_MAP_MAX_BASE_EXTENTS ) { kfree ( new_map . forward ) ; kfree ( new_map . reverse ) ; map -> forward = NULL ; map -> reverse = NULL ; map -> nr_extents = 0 ; } mutex_unlock ( & userns_state_mutex ) ; kfree ( kbuf ) ; return ret ; }
","<S2SV_ModStart> & new_map ) <S2SV_ModEnd> ) goto out <S2SV_ModStart> lower_first ; } ret = sort_idmaps ( & new_map ) ; if ( ret < 0 ) goto out ;
"
1113,"CWE-264 int lxc_attach ( const char * name , const char * lxcpath , lxc_attach_exec_t exec_function , void * exec_payload , lxc_attach_options_t * options , pid_t * attached_process ) { int ret , status ; pid_t init_pid , pid , attached_pid , expected ; struct lxc_proc_context_info * init_ctx ; char * cwd ; char * new_cwd ; int ipc_sockets [ 2 ] ; <S2SV_StartBug> int procfd ; <S2SV_EndBug> signed long personality ; if ( ! options ) options = & attach_static_default_options ; init_pid = lxc_cmd_get_init_pid ( name , lxcpath ) ; if ( init_pid < 0 ) { ERROR ( ""failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>the<S2SV_blank>init<S2SV_blank>pid"" ) ; return - 1 ; } init_ctx = lxc_proc_get_context_info ( init_pid ) ; if ( ! init_ctx ) { ERROR ( ""failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>context<S2SV_blank>of<S2SV_blank>the<S2SV_blank>init<S2SV_blank>process,<S2SV_blank>pid<S2SV_blank>=<S2SV_blank>%ld"" , ( long ) init_pid ) ; return - 1 ; } personality = get_personality ( name , lxcpath ) ; if ( init_ctx -> personality < 0 ) { ERROR ( ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>personality<S2SV_blank>of<S2SV_blank>the<S2SV_blank>container"" ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } init_ctx -> personality = personality ; init_ctx -> container = lxc_container_new ( name , lxcpath ) ; if ( ! init_ctx -> container ) return - 1 ; if ( ! fetch_seccomp ( init_ctx -> container , options ) ) WARN ( ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>seccomp<S2SV_blank>policy"" ) ; if ( ! no_new_privs ( init_ctx -> container , options ) ) WARN ( ""Could<S2SV_blank>not<S2SV_blank>determine<S2SV_blank>whether<S2SV_blank>PR_SET_NO_NEW_PRIVS<S2SV_blank>is<S2SV_blank>set."" ) ; cwd = getcwd ( NULL , 0 ) ; if ( options -> namespaces == - 1 ) { options -> namespaces = lxc_cmd_get_clone_flags ( name , lxcpath ) ; if ( options -> namespaces == - 1 ) { ERROR ( ""failed<S2SV_blank>to<S2SV_blank>automatically<S2SV_blank>determine<S2SV_blank>the<S2SV_blank>"" ""namespaces<S2SV_blank>which<S2SV_blank>the<S2SV_blank>container<S2SV_blank>unshared"" ) ; free ( cwd ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } } ret = socketpair ( PF_LOCAL , SOCK_STREAM | SOCK_CLOEXEC , 0 , ipc_sockets ) ; if ( ret < 0 ) { SYSERROR ( ""could<S2SV_blank>not<S2SV_blank>set<S2SV_blank>up<S2SV_blank>required<S2SV_blank>IPC<S2SV_blank>mechanism<S2SV_blank>for<S2SV_blank>attaching"" ) ; free ( cwd ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } pid = fork ( ) ; if ( pid < 0 ) { SYSERROR ( ""failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>first<S2SV_blank>subprocess"" ) ; free ( cwd ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } if ( pid ) { <S2SV_StartBug> pid_t to_cleanup_pid = pid ; <S2SV_EndBug> close ( ipc_sockets [ 1 ] ) ; free ( cwd ) ; if ( options -> attach_flags & LXC_ATTACH_MOVE_TO_CGROUP ) { if ( ! cgroup_attach ( name , lxcpath , pid ) ) goto cleanup_error ; } <S2SV_StartBug> status = 0 ; <S2SV_EndBug> ret = lxc_write_nointr ( ipc_sockets [ 0 ] , & status , sizeof ( status ) ) ; if ( ret <= 0 ) { ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(0)"" ) ; goto cleanup_error ; } <S2SV_StartBug> ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & attached_pid , sizeof ( attached_pid ) , NULL ) ; <S2SV_EndBug> if ( ret <= 0 ) { <S2SV_StartBug> if ( ret != 0 ) <S2SV_EndBug> ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>pid<S2SV_blank>of<S2SV_blank>attached<S2SV_blank>process"" ) ; goto cleanup_error ; } <S2SV_StartBug> if ( options -> stdin_fd == 0 ) { <S2SV_EndBug> signal ( SIGINT , SIG_IGN ) ; signal ( SIGQUIT , SIG_IGN ) ; } ret = wait_for_pid ( pid ) ; if ( ret < 0 ) goto cleanup_error ; to_cleanup_pid = attached_pid ; status = 0 ; ret = lxc_write_nointr ( ipc_sockets [ 0 ] , & status , sizeof ( status ) ) ; if ( ret <= 0 ) { ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(0)"" ) ; goto cleanup_error ; } expected = 1 ; ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) { if ( ret != 0 ) <S2SV_StartBug> ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>(1)"" ) ; <S2SV_EndBug> goto cleanup_error ; } status = 2 ; ret = lxc_write_nointr ( ipc_sockets [ 0 ] , & status , sizeof ( status ) ) ; if ( ret <= 0 ) { <S2SV_StartBug> ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(2)"" ) ; <S2SV_EndBug> goto cleanup_error ; } <S2SV_StartBug> shutdown ( ipc_sockets [ 0 ] , SHUT_RDWR ) ; <S2SV_EndBug> close ( ipc_sockets [ 0 ] ) ; lxc_proc_put_context_info ( init_ctx ) ; * attached_process = attached_pid ; return 0 ; <S2SV_StartBug> cleanup_error : <S2SV_EndBug> shutdown ( ipc_sockets [ 0 ] , SHUT_RDWR ) ; close ( ipc_sockets [ 0 ] ) ; if ( to_cleanup_pid ) ( void ) wait_for_pid ( to_cleanup_pid ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } close ( ipc_sockets [ 0 ] ) ; expected = 0 ; status = - 1 ; ret = lxc_read_nointr_expect ( ipc_sockets [ 1 ] , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) { ERROR ( ""error<S2SV_blank>communicating<S2SV_blank>with<S2SV_blank>child<S2SV_blank>process"" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } if ( ( options -> attach_flags & LXC_ATTACH_MOVE_TO_CGROUP ) && cgns_supported ( ) ) options -> namespaces |= CLONE_NEWCGROUP ; <S2SV_StartBug> procfd = open ( ""/proc"" , O_DIRECTORY | O_RDONLY ) ; <S2SV_EndBug> if ( procfd < 0 ) { SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>/proc"" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } ret = lxc_attach_to_ns ( init_pid , options -> namespaces ) ; if ( ret < 0 ) { ERROR ( ""failed<S2SV_blank>to<S2SV_blank>enter<S2SV_blank>the<S2SV_blank>namespace"" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } if ( options -> initial_cwd ) new_cwd = options -> initial_cwd ; else new_cwd = cwd ; ret = chdir ( new_cwd ) ; if ( ret < 0 ) WARN ( ""could<S2SV_blank>not<S2SV_blank>change<S2SV_blank>directory<S2SV_blank>to<S2SV_blank>\'%s\'"" , new_cwd ) ; free ( cwd ) ; { struct attach_clone_payload payload = { . ipc_socket = ipc_sockets [ 1 ] , . options = options , . init_ctx = init_ctx , . exec_function = exec_function , . exec_payload = exec_payload , <S2SV_StartBug> . procfd = procfd <S2SV_EndBug> } ; pid = lxc_clone ( attach_child_main , & payload , CLONE_PARENT ) ; } if ( pid <= 0 ) { SYSERROR ( ""failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>subprocess"" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } ret = lxc_write_nointr ( ipc_sockets [ 1 ] , & pid , sizeof ( pid ) ) ; if ( ret != sizeof ( pid ) ) { ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>main<S2SV_blank>process<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>of<S2SV_blank>the<S2SV_blank>attached<S2SV_blank>process"" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } rexit ( 0 ) ; }
","<S2SV_ModStart> 2 ] ; <S2SV_ModEnd> signed long personality <S2SV_ModStart> pid ) { int procfd = - 1 ; <S2SV_ModStart> cleanup_error ; } procfd = open ( ""/proc"" , O_DIRECTORY | O_RDONLY | O_CLOEXEC ) ; if ( procfd < 0 ) { SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>/proc."" <S2SV_ModEnd> ) ; goto <S2SV_ModStart> cleanup_error ; } status = 0 ; ret = lxc_write_nointr ( ipc_sockets [ 0 ] , & status <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> , sizeof ( status ) <S2SV_ModEnd> ) ; if <S2SV_ModStart> 0 ) { ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(0)"" <S2SV_ModEnd> ) ; goto <S2SV_ModStart> cleanup_error ; } ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & attached_pid , sizeof ( attached_pid ) , NULL ) ; if ( ret <= 0 ) { if ( ret != 0 ) ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>pid<S2SV_blank>of<S2SV_blank>attached<S2SV_blank>process"" ) ; goto cleanup_error ; } <S2SV_ModStart> ) ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>"" ""from<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>(1)"" <S2SV_ModEnd> ) ; goto <S2SV_ModStart> { ERROR ( ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>"" ""initialization<S2SV_blank>(2):<S2SV_blank>%s."" , strerror ( errno ) <S2SV_ModEnd> ) ; goto <S2SV_ModStart> cleanup_error ; } expected = 3 ; ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) { ERROR ( ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>for<S2SV_blank>the<S2SV_blank>child<S2SV_blank>to<S2SV_blank>tell<S2SV_blank>us<S2SV_blank>to<S2SV_blank>open<S2SV_blank>LSM<S2SV_blank>fd<S2SV_blank>(3):<S2SV_blank>%s."" , strerror ( errno ) ) ; goto cleanup_error ; } if ( ( options -> namespaces & CLONE_NEWNS ) && ( options -> attach_flags & LXC_ATTACH_LSM ) && init_ctx -> lsm_label ) { int on_exec , labelfd ; on_exec = options -> attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0 ; labelfd = lsm_openat ( procfd , attached_pid , on_exec ) ; if ( labelfd < 0 ) goto cleanup_error ; ret = lxc_abstract_unix_send_fd ( ipc_sockets [ 0 ] , labelfd , NULL , 0 ) ; if ( ret <= 0 ) { ERROR ( ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>send<S2SV_blank>child<S2SV_blank>LSM<S2SV_blank>fd<S2SV_blank>(4):<S2SV_blank>%s."" , strerror ( errno ) ) ; goto cleanup_error ; } } <S2SV_ModStart> ; cleanup_error : if ( procfd >= 0 ) close ( procfd ) ; <S2SV_ModStart> |= CLONE_NEWCGROUP ; <S2SV_ModEnd> ret = lxc_attach_to_ns <S2SV_ModStart> = exec_payload , <S2SV_ModEnd> } ; pid
"
1114,"CWE-000 static int ims_pcu_parse_cdc_data ( struct usb_interface * intf , struct ims_pcu * pcu ) { const struct usb_cdc_union_desc * union_desc ; struct usb_host_interface * alt ; union_desc = ims_pcu_get_cdc_union_desc ( intf ) ; if ( ! union_desc ) return - EINVAL ; pcu -> ctrl_intf = usb_ifnum_to_if ( pcu -> udev , union_desc -> bMasterInterface0 ) ; <S2SV_StartBug> alt = pcu -> ctrl_intf -> cur_altsetting ; <S2SV_EndBug> pcu -> ep_ctrl = & alt -> endpoint [ 0 ] . desc ; pcu -> max_ctrl_size = usb_endpoint_maxp ( pcu -> ep_ctrl ) ; pcu -> data_intf = usb_ifnum_to_if ( pcu -> udev , union_desc -> bSlaveInterface0 ) ; <S2SV_StartBug> alt = pcu -> data_intf -> cur_altsetting ; <S2SV_EndBug> if ( alt -> desc . bNumEndpoints != 2 ) { dev_err ( pcu -> dev , ""Incorrect<S2SV_blank>number<S2SV_blank>of<S2SV_blank>endpoints<S2SV_blank>on<S2SV_blank>data<S2SV_blank>interface<S2SV_blank>(%d)\\n"" , alt -> desc . bNumEndpoints ) ; return - EINVAL ; } pcu -> ep_out = & alt -> endpoint [ 0 ] . desc ; if ( ! usb_endpoint_is_bulk_out ( pcu -> ep_out ) ) { dev_err ( pcu -> dev , ""First<S2SV_blank>endpoint<S2SV_blank>on<S2SV_blank>data<S2SV_blank>interface<S2SV_blank>is<S2SV_blank>not<S2SV_blank>BULK<S2SV_blank>OUT\\n"" ) ; return - EINVAL ; } pcu -> max_out_size = usb_endpoint_maxp ( pcu -> ep_out ) ; if ( pcu -> max_out_size < 8 ) { dev_err ( pcu -> dev , ""Max<S2SV_blank>OUT<S2SV_blank>packet<S2SV_blank>size<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>(%zd)\\n"" , pcu -> max_out_size ) ; return - EINVAL ; } pcu -> ep_in = & alt -> endpoint [ 1 ] . desc ; if ( ! usb_endpoint_is_bulk_in ( pcu -> ep_in ) ) { dev_err ( pcu -> dev , ""Second<S2SV_blank>endpoint<S2SV_blank>on<S2SV_blank>data<S2SV_blank>interface<S2SV_blank>is<S2SV_blank>not<S2SV_blank>BULK<S2SV_blank>IN\\n"" ) ; return - EINVAL ; } pcu -> max_in_size = usb_endpoint_maxp ( pcu -> ep_in ) ; if ( pcu -> max_in_size < 8 ) { dev_err ( pcu -> dev , ""Max<S2SV_blank>IN<S2SV_blank>packet<S2SV_blank>size<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>(%zd)\\n"" , pcu -> max_in_size ) ; return - EINVAL ; } return 0 ; }
","<S2SV_ModStart> bMasterInterface0 ) ; if ( ! pcu -> ctrl_intf ) return - EINVAL ; <S2SV_ModStart> bSlaveInterface0 ) ; if ( ! pcu -> data_intf ) return - EINVAL ;
"
1115,"CWE-125 int rt6_print ( netdissect_options * ndo , register const u_char * bp , const u_char * bp2 _U_ ) { register const struct ip6_rthdr * dp ; register const struct ip6_rthdr0 * dp0 ; register const u_char * ep ; int i , len ; register const struct in6_addr * addr ; dp = ( const struct ip6_rthdr * ) bp ; <S2SV_StartBug> len = dp -> ip6r_len ; <S2SV_EndBug> ep = ndo -> ndo_snapend ; ND_TCHECK ( dp -> ip6r_segleft ) ; ND_PRINT ( ( ndo , ""srcrt<S2SV_blank>(len=%d"" , dp -> ip6r_len ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>type=%d"" , dp -> ip6r_type ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>segleft=%d"" , dp -> ip6r_segleft ) ) ; switch ( dp -> ip6r_type ) { case IPV6_RTHDR_TYPE_0 : case IPV6_RTHDR_TYPE_2 : dp0 = ( const struct ip6_rthdr0 * ) dp ; ND_TCHECK ( dp0 -> ip6r0_reserved ) ; if ( dp0 -> ip6r0_reserved || ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , "",<S2SV_blank>rsv=0x%0x"" , EXTRACT_32BITS ( & dp0 -> ip6r0_reserved ) ) ) ; } if ( len % 2 == 1 ) goto trunc ; len >>= 1 ; addr = & dp0 -> ip6r0_addr [ 0 ] ; for ( i = 0 ; i < len ; i ++ ) { if ( ( const u_char * ) ( addr + 1 ) > ep ) goto trunc ; ND_PRINT ( ( ndo , "",<S2SV_blank>[%d]%s"" , i , ip6addr_string ( ndo , addr ) ) ) ; addr ++ ; } ND_PRINT ( ( ndo , "")<S2SV_blank>"" ) ) ; return ( ( dp0 -> ip6r0_len + 1 ) << 3 ) ; break ; default : goto trunc ; break ; } trunc : ND_PRINT ( ( ndo , ""[|srcrt]"" ) ) ; return - 1 ; }
","<S2SV_ModStart> ) bp ; ep = ndo -> ndo_snapend ; ND_TCHECK ( dp -> ip6r_segleft ) ; <S2SV_ModStart> dp -> ip6r_len <S2SV_ModEnd> ; ND_PRINT (
"
1116,"CWE-125 static int add_ast_fields ( void ) { PyObject * empty_tuple , * d ; if ( PyType_Ready ( & AST_type ) < 0 ) return - 1 ; d = AST_type . tp_dict ; empty_tuple = PyTuple_New ( 0 ) ; if ( ! empty_tuple || <S2SV_StartBug> PyDict_SetItemString ( d , ""_fields"" , empty_tuple ) < 0 || <S2SV_EndBug> <S2SV_StartBug> PyDict_SetItemString ( d , ""_attributes"" , empty_tuple ) < 0 ) { <S2SV_EndBug> Py_XDECREF ( empty_tuple ) ; return - 1 ; } Py_DECREF ( empty_tuple ) ; return 0 ; }
","<S2SV_ModStart> ! empty_tuple || _PyDict_SetItemId <S2SV_ModEnd> ( d , <S2SV_ModStart> ( d , & PyId__fields <S2SV_ModEnd> , empty_tuple ) <S2SV_ModStart> < 0 || _PyDict_SetItemId <S2SV_ModEnd> ( d , <S2SV_ModStart> ( d , & PyId__attributes <S2SV_ModEnd> , empty_tuple )
"
1117,"CWE-254 int main ( int argc , char * argv [ ] ) { int i , fails_count = 0 ; CU_pSuite cryptoUtilsTestSuite , parserTestSuite ; CU_pSuite * suites [ ] = { & cryptoUtilsTestSuite , & parserTestSuite , NULL } ; if ( argc > 1 ) { if ( argv [ 1 ] [ 0 ] == '-' ) { if ( strcmp ( argv [ 1 ] , ""-verbose"" ) == 0 ) { verbose = 1 ; } else { printf ( ""Usage:\\n<S2SV_blank>%s<S2SV_blank>[-verbose]<S2SV_blank>to<S2SV_blank>enable<S2SV_blank>extensive<S2SV_blank>logging\\n"" , argv [ 0 ] ) ; return 1 ; } } else { printf ( ""Usage:\\n<S2SV_blank>%s<S2SV_blank>[-verbose]<S2SV_blank>to<S2SV_blank>enable<S2SV_blank>extensive<S2SV_blank>logging\\n"" , argv [ 0 ] ) ; return 1 ; } } # ifdef HAVE_LIBXML2 xmlInitParser ( ) ; # endif if ( CUE_SUCCESS != CU_initialize_registry ( ) ) { return CU_get_error ( ) ; } cryptoUtilsTestSuite = CU_add_suite ( ""Bzrtp<S2SV_blank>Crypto<S2SV_blank>Utils"" , NULL , NULL ) ; CU_add_test ( cryptoUtilsTestSuite , ""zrtpKDF"" , test_zrtpKDF ) ; CU_add_test ( cryptoUtilsTestSuite , ""CRC32"" , test_CRC32 ) ; CU_add_test ( cryptoUtilsTestSuite , ""algo<S2SV_blank>agreement"" , test_algoAgreement ) ; CU_add_test ( cryptoUtilsTestSuite , ""context<S2SV_blank>algo<S2SV_blank>setter<S2SV_blank>and<S2SV_blank>getter"" , test_algoSetterGetter ) ; CU_add_test ( cryptoUtilsTestSuite , ""adding<S2SV_blank>mandatory<S2SV_blank>crypto<S2SV_blank>algorithms<S2SV_blank>if<S2SV_blank>needed"" , test_addMandatoryCryptoTypesIfNeeded ) ; parserTestSuite = CU_add_suite ( ""Bzrtp<S2SV_blank>ZRTP<S2SV_blank>Packet<S2SV_blank>Parser"" , NULL , NULL ) ; CU_add_test ( parserTestSuite , ""Parse"" , test_parser ) ; <S2SV_StartBug> CU_add_test ( parserTestSuite , ""Parse<S2SV_blank>Exchange"" , test_parserComplete ) ; <S2SV_EndBug> CU_add_test ( parserTestSuite , ""State<S2SV_blank>machine"" , test_stateMachine ) ; for ( i = 0 ; suites [ i ] ; i ++ ) { CU_basic_run_suite ( * suites [ i ] ) ; fails_count += CU_get_number_of_tests_failed ( ) ; } CU_cleanup_registry ( ) ; # ifdef HAVE_LIBXML2 xmlCleanupParser ( ) ; # endif return ( fails_count == 0 ? 0 : 1 ) ; }
","<S2SV_ModStart> ( parserTestSuite , ""Parse<S2SV_blank>hvi<S2SV_blank>check<S2SV_blank>fail"" , test_parser_hvi ) ; CU_add_test ( parserTestSuite ,
"
1118,"CWE-125 static void process_constructors ( RBinFile * bf , RList * ret , int bits ) { RList * secs = sections ( bf ) ; RListIter * iter ; RBinSection * sec ; int i , type ; r_list_foreach ( secs , iter , sec ) { type = - 1 ; if ( ! strcmp ( sec -> name , "".fini_array"" ) ) { type = R_BIN_ENTRY_TYPE_FINI ; } else if ( ! strcmp ( sec -> name , "".init_array"" ) ) { type = R_BIN_ENTRY_TYPE_INIT ; } else if ( ! strcmp ( sec -> name , "".preinit_array"" ) ) { type = R_BIN_ENTRY_TYPE_PREINIT ; } if ( type != - 1 ) { ut8 * buf = calloc ( sec -> size , 1 ) ; if ( ! buf ) { continue ; } ( void ) r_buf_read_at ( bf -> buf , sec -> paddr , buf , sec -> size ) ; if ( bits == 32 ) { <S2SV_StartBug> for ( i = 0 ; i < sec -> size ; i += 4 ) { <S2SV_EndBug> ut32 addr32 = r_read_le32 ( buf + i ) ; if ( addr32 ) { RBinAddr * ba = newEntry ( sec -> paddr + i , ( ut64 ) addr32 , type , bits ) ; r_list_append ( ret , ba ) ; } } } else { <S2SV_StartBug> for ( i = 0 ; i < sec -> size ; i += 8 ) { <S2SV_EndBug> ut64 addr64 = r_read_le64 ( buf + i ) ; if ( addr64 ) { RBinAddr * ba = newEntry ( sec -> paddr + i , addr64 , type , bits ) ; r_list_append ( ret , ba ) ; } } } free ( buf ) ; } } r_list_free ( secs ) ; }
","<S2SV_ModStart> = 0 ; ( i + 3 ) <S2SV_ModEnd> < sec -> <S2SV_ModStart> = 0 ; ( i + 7 ) <S2SV_ModEnd> < sec ->
"
1119,"CWE-119 int ip6_append_data ( struct sock * sk , int getfrag ( void * from , char * to , int offset , int len , int odd , struct sk_buff * skb ) , void * from , int length , int transhdrlen , int hlimit , int tclass , struct ipv6_txoptions * opt , struct flowi6 * fl6 , struct rt6_info * rt , unsigned int flags , int dontfrag ) { struct inet_sock * inet = inet_sk ( sk ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct inet_cork * cork ; struct sk_buff * skb , * skb_prev = NULL ; unsigned int maxfraglen , fragheaderlen , mtu ; int exthdrlen ; int dst_exthdrlen ; int hh_len ; int copy ; int err ; int offset = 0 ; __u8 tx_flags = 0 ; if ( flags & MSG_PROBE ) return 0 ; cork = & inet -> cork . base ; if ( skb_queue_empty ( & sk -> sk_write_queue ) ) { if ( opt ) { if ( WARN_ON ( np -> cork . opt ) ) return - EINVAL ; np -> cork . opt = kzalloc ( opt -> tot_len , sk -> sk_allocation ) ; if ( unlikely ( np -> cork . opt == NULL ) ) return - ENOBUFS ; np -> cork . opt -> tot_len = opt -> tot_len ; np -> cork . opt -> opt_flen = opt -> opt_flen ; np -> cork . opt -> opt_nflen = opt -> opt_nflen ; np -> cork . opt -> dst0opt = ip6_opt_dup ( opt -> dst0opt , sk -> sk_allocation ) ; if ( opt -> dst0opt && ! np -> cork . opt -> dst0opt ) return - ENOBUFS ; np -> cork . opt -> dst1opt = ip6_opt_dup ( opt -> dst1opt , sk -> sk_allocation ) ; if ( opt -> dst1opt && ! np -> cork . opt -> dst1opt ) return - ENOBUFS ; np -> cork . opt -> hopopt = ip6_opt_dup ( opt -> hopopt , sk -> sk_allocation ) ; if ( opt -> hopopt && ! np -> cork . opt -> hopopt ) return - ENOBUFS ; np -> cork . opt -> srcrt = ip6_rthdr_dup ( opt -> srcrt , sk -> sk_allocation ) ; if ( opt -> srcrt && ! np -> cork . opt -> srcrt ) return - ENOBUFS ; } dst_hold ( & rt -> dst ) ; cork -> dst = & rt -> dst ; inet -> cork . fl . u . ip6 = * fl6 ; np -> cork . hop_limit = hlimit ; np -> cork . tclass = tclass ; if ( rt -> dst . flags & DST_XFRM_TUNNEL ) mtu = np -> pmtudisc == IPV6_PMTUDISC_PROBE ? rt -> dst . dev -> mtu : dst_mtu ( & rt -> dst ) ; else mtu = np -> pmtudisc == IPV6_PMTUDISC_PROBE ? rt -> dst . dev -> mtu : dst_mtu ( rt -> dst . path ) ; if ( np -> frag_size < mtu ) { if ( np -> frag_size ) mtu = np -> frag_size ; } cork -> fragsize = mtu ; if ( dst_allfrag ( rt -> dst . path ) ) cork -> flags |= IPCORK_ALLFRAG ; cork -> length = 0 ; exthdrlen = ( opt ? opt -> opt_flen : 0 ) ; length += exthdrlen ; transhdrlen += exthdrlen ; dst_exthdrlen = rt -> dst . header_len - rt -> rt6i_nfheader_len ; } else { rt = ( struct rt6_info * ) cork -> dst ; fl6 = & inet -> cork . fl . u . ip6 ; opt = np -> cork . opt ; transhdrlen = 0 ; exthdrlen = 0 ; dst_exthdrlen = 0 ; mtu = cork -> fragsize ; } hh_len = LL_RESERVED_SPACE ( rt -> dst . dev ) ; fragheaderlen = sizeof ( struct ipv6hdr ) + rt -> rt6i_nfheader_len + ( opt ? opt -> opt_nflen : 0 ) ; maxfraglen = ( ( mtu - fragheaderlen ) & ~ 7 ) + fragheaderlen - sizeof ( struct frag_hdr ) ; if ( mtu <= sizeof ( struct ipv6hdr ) + IPV6_MAXPLEN ) { if ( cork -> length + length > sizeof ( struct ipv6hdr ) + IPV6_MAXPLEN - fragheaderlen ) { ipv6_local_error ( sk , EMSGSIZE , fl6 , mtu - exthdrlen ) ; return - EMSGSIZE ; } } if ( sk -> sk_type == SOCK_DGRAM ) sock_tx_timestamp ( sk , & tx_flags ) ; <S2SV_StartBug> cork -> length += length ; <S2SV_EndBug> <S2SV_StartBug> if ( length > mtu ) { <S2SV_EndBug> int proto = sk -> sk_protocol ; <S2SV_StartBug> if ( dontfrag && ( proto == IPPROTO_UDP || proto == IPPROTO_RAW ) ) { <S2SV_EndBug> ipv6_local_rxpmtu ( sk , fl6 , mtu - exthdrlen ) ; return - EMSGSIZE ; } <S2SV_StartBug> if ( proto == IPPROTO_UDP && <S2SV_EndBug> ( rt -> dst . dev -> features & NETIF_F_UFO ) ) { err = ip6_ufo_append_data ( sk , getfrag , from , length , hh_len , fragheaderlen , transhdrlen , mtu , flags , rt ) ; if ( err ) goto error ; return 0 ; } <S2SV_StartBug> } <S2SV_EndBug> if ( ( skb = skb_peek_tail ( & sk -> sk_write_queue ) ) == NULL ) goto alloc_new_skb ; while ( length > 0 ) { copy = ( cork -> length <= mtu && ! ( cork -> flags & IPCORK_ALLFRAG ) ? mtu : maxfraglen ) - skb -> len ; if ( copy < length ) copy = maxfraglen - skb -> len ; if ( copy <= 0 ) { char * data ; unsigned int datalen ; unsigned int fraglen ; unsigned int fraggap ; unsigned int alloclen ; alloc_new_skb : if ( skb ) fraggap = skb -> len - maxfraglen ; else fraggap = 0 ; if ( skb == NULL || skb_prev == NULL ) ip6_append_data_mtu ( & mtu , & maxfraglen , fragheaderlen , skb , rt , np -> pmtudisc == IPV6_PMTUDISC_PROBE ) ; skb_prev = skb ; datalen = length + fraggap ; if ( datalen > ( cork -> length <= mtu && ! ( cork -> flags & IPCORK_ALLFRAG ) ? mtu : maxfraglen ) - fragheaderlen ) datalen = maxfraglen - fragheaderlen - rt -> dst . trailer_len ; if ( ( flags & MSG_MORE ) && ! ( rt -> dst . dev -> features & NETIF_F_SG ) ) alloclen = mtu ; else alloclen = datalen + fragheaderlen ; alloclen += dst_exthdrlen ; if ( datalen != length + fraggap ) { datalen += rt -> dst . trailer_len ; } alloclen += rt -> dst . trailer_len ; fraglen = datalen + fragheaderlen ; alloclen += sizeof ( struct frag_hdr ) ; if ( transhdrlen ) { skb = sock_alloc_send_skb ( sk , alloclen + hh_len , ( flags & MSG_DONTWAIT ) , & err ) ; } else { skb = NULL ; if ( atomic_read ( & sk -> sk_wmem_alloc ) <= 2 * sk -> sk_sndbuf ) skb = sock_wmalloc ( sk , alloclen + hh_len , 1 , sk -> sk_allocation ) ; if ( unlikely ( skb == NULL ) ) err = - ENOBUFS ; else { tx_flags = 0 ; } } if ( skb == NULL ) goto error ; skb -> protocol = htons ( ETH_P_IPV6 ) ; skb -> ip_summed = CHECKSUM_NONE ; skb -> csum = 0 ; skb_reserve ( skb , hh_len + sizeof ( struct frag_hdr ) + dst_exthdrlen ) ; if ( sk -> sk_type == SOCK_DGRAM ) skb_shinfo ( skb ) -> tx_flags = tx_flags ; data = skb_put ( skb , fraglen ) ; skb_set_network_header ( skb , exthdrlen ) ; data += fragheaderlen ; skb -> transport_header = ( skb -> network_header + fragheaderlen ) ; if ( fraggap ) { skb -> csum = skb_copy_and_csum_bits ( skb_prev , maxfraglen , data + transhdrlen , fraggap , 0 ) ; skb_prev -> csum = csum_sub ( skb_prev -> csum , skb -> csum ) ; data += fraggap ; pskb_trim_unique ( skb_prev , maxfraglen ) ; } copy = datalen - transhdrlen - fraggap ; if ( copy < 0 ) { err = - EINVAL ; kfree_skb ( skb ) ; goto error ; } else if ( copy > 0 && getfrag ( from , data + transhdrlen , offset , copy , fraggap , skb ) < 0 ) { err = - EFAULT ; kfree_skb ( skb ) ; goto error ; } offset += copy ; length -= datalen - fraggap ; transhdrlen = 0 ; exthdrlen = 0 ; dst_exthdrlen = 0 ; __skb_queue_tail ( & sk -> sk_write_queue , skb ) ; continue ; } if ( copy > length ) copy = length ; if ( ! ( rt -> dst . dev -> features & NETIF_F_SG ) ) { unsigned int off ; off = skb -> len ; if ( getfrag ( from , skb_put ( skb , copy ) , offset , copy , off , skb ) < 0 ) { __skb_trim ( skb , off ) ; err = - EFAULT ; goto error ; } } else { int i = skb_shinfo ( skb ) -> nr_frags ; struct page_frag * pfrag = sk_page_frag ( sk ) ; err = - ENOMEM ; if ( ! sk_page_frag_refill ( sk , pfrag ) ) goto error ; if ( ! skb_can_coalesce ( skb , i , pfrag -> page , pfrag -> offset ) ) { err = - EMSGSIZE ; if ( i == MAX_SKB_FRAGS ) goto error ; __skb_fill_page_desc ( skb , i , pfrag -> page , pfrag -> offset , 0 ) ; skb_shinfo ( skb ) -> nr_frags = ++ i ; get_page ( pfrag -> page ) ; } copy = min_t ( int , copy , pfrag -> size - pfrag -> offset ) ; if ( getfrag ( from , page_address ( pfrag -> page ) + pfrag -> offset , offset , copy , skb -> len , skb ) < 0 ) goto error_efault ; pfrag -> offset += copy ; skb_frag_size_add ( & skb_shinfo ( skb ) -> frags [ i - 1 ] , copy ) ; skb -> len += copy ; skb -> data_len += copy ; skb -> truesize += copy ; atomic_add ( copy , & sk -> sk_wmem_alloc ) ; } offset += copy ; length -= copy ; } return 0 ; error_efault : err = - EFAULT ; error : cork -> length -= length ; IP6_INC_STATS ( sock_net ( sk ) , rt -> rt6i_idev , IPSTATS_MIB_OUTDISCARDS ) ; return err ; }
","<S2SV_ModStart> tx_flags ) ; if ( <S2SV_ModEnd> ( length > <S2SV_ModStart> > mtu ) && <S2SV_ModEnd> dontfrag && ( <S2SV_ModStart> dontfrag && ( sk -> sk_protocol <S2SV_ModEnd> == IPPROTO_UDP || <S2SV_ModStart> == IPPROTO_UDP || sk -> sk_protocol <S2SV_ModEnd> == IPPROTO_RAW ) <S2SV_ModStart> EMSGSIZE ; } skb = skb_peek_tail ( & sk -> sk_write_queue ) ; cork -> length += length ; if ( ( ( length > mtu ) || ( skb && skb_is_gso ( skb ) ) ) && ( sk -> sk_protocol == IPPROTO_UDP ) <S2SV_ModEnd> && ( rt <S2SV_ModStart> 0 ; } if ( ! skb <S2SV_ModEnd> ) goto alloc_new_skb
"
1120,"CWE-119 static void GTextFieldSave ( GTextField * gt , int utf8 ) { unichar_t * ret ; char * cret ; FILE * file ; unichar_t * pt ; if ( _ggadget_use_gettext ) { char * temp = GWidgetOpenFile8 ( _ ( ""Save"" ) , NULL , ""*.{txt,py}"" , NULL , NULL ) ; ret = utf82u_copy ( temp ) ; free ( temp ) ; } else ret = GWidgetSaveAsFile ( GStringGetResource ( _STR_Save , NULL ) , NULL , txt , NULL , NULL ) ; if ( ret == NULL ) return ; cret = u2def_copy ( ret ) ; free ( ret ) ; file = fopen ( cret , ""w"" ) ; if ( file == NULL ) { if ( _ggadget_use_gettext ) GWidgetError8 ( _ ( ""Could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>file"" ) , _ ( ""Could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>%.100s"" ) , cret ) ; else GWidgetError ( errort , error , cret ) ; free ( cret ) ; return ; } free ( cret ) ; if ( utf8 ) { putc ( 0xef , file ) ; putc ( 0xbb , file ) ; putc ( 0xbf , file ) ; for ( pt = gt -> text ; * pt ; ++ pt ) { if ( * pt < 0x80 ) putc ( * pt , file ) ; else if ( * pt < 0x800 ) { putc ( 0xc0 | ( * pt >> 6 ) , file ) ; putc ( 0x80 | ( * pt & 0x3f ) , file ) ; } else if ( * pt >= 0xd800 && * pt < 0xdc00 && pt [ 1 ] >= 0xdc00 && pt [ 1 ] < 0xe000 ) { int u = ( ( * pt >> 6 ) & 0xf ) + 1 , y = ( ( * pt & 3 ) << 4 ) | ( ( pt [ 1 ] >> 6 ) & 0xf ) ; putc ( 0xf0 | ( u >> 2 ) , file ) ; putc ( 0x80 | ( ( u & 3 ) << 4 ) | ( ( * pt >> 2 ) & 0xf ) , file ) ; putc ( 0x80 | y , file ) ; putc ( 0x80 | ( pt [ 1 ] & 0x3f ) , file ) ; } else { putc ( 0xe0 | ( * pt >> 12 ) , file ) ; putc ( 0x80 | ( ( * pt >> 6 ) & 0x3f ) , file ) ; putc ( 0x80 | ( * pt & 0x3f ) , file ) ; } } } else { putc ( 0xfeff >> 8 , file ) ; putc ( 0xfeff & 0xff , file ) ; for ( pt = gt -> text ; * pt ; ++ pt ) { putc ( * pt >> 8 , file ) ; putc ( * pt & 0xff , file ) ; } } fclose ( file ) ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> file ) ; GTextFieldSaved ( gt ) ;
"
1121,"CWE-119 <S2SV_StartBug> static char * print_number ( cJSON * item ) <S2SV_EndBug> { char * str ; double f , f2 ; int64_t i ; str = ( char * ) cJSON_malloc ( 64 ) ; if ( str ) { <S2SV_StartBug> f = item -> valuefloat ; <S2SV_EndBug> i = f ; f2 = i ; <S2SV_StartBug> if ( f2 == f && item -> valueint >= LLONG_MIN && item -> valueint <= LLONG_MAX ) <S2SV_EndBug> sprintf ( str , ""%lld"" , ( long long ) item -> valueint ) ; else sprintf ( str , ""%g"" , item -> valuefloat ) ; } return str ; }
","<S2SV_ModStart> cJSON * item , printbuffer * p ) { char * str = 0 ; double d <S2SV_ModEnd> = item -> <S2SV_ModStart> = item -> valuedouble ; if ( d == 0 ) { if ( p ) str = ensure ( p , 2 ) ; else str = ( char * ) cJSON_malloc ( 2 ) ; if ( str ) strcpy ( str , ""0"" ) ; } else if ( fabs ( ( ( double ) <S2SV_ModEnd> item -> valueint <S2SV_ModStart> item -> valueint ) - d ) <= DBL_EPSILON && d <= LLONG_MAX && d >= LLONG_MIN ) { if ( p ) str = ensure ( p , 64 ) ; else str = ( char * ) cJSON_malloc ( 64 ) ; if ( str ) sprintf ( str , ""%lld"" , ( long long ) <S2SV_ModEnd> item -> valueint <S2SV_ModStart> item -> valueint ) ; } else { if ( p ) str = ensure ( p , 64 ) ; else str = ( char * ) cJSON_malloc ( 64 ) ; if ( str ) { if ( fpclassify ( d ) != FP_ZERO && ! isnormal ( d ) ) sprintf ( str , ""null"" ) ; else if ( fabs ( floor ( d ) - d ) <= DBL_EPSILON && fabs ( d ) < 1.0e60 ) sprintf ( str , ""%.0f"" , d ) ; else if ( fabs ( d ) < 1.0e-6 || fabs ( d ) > 1.0e9 ) sprintf ( str , ""%e"" , d ) ; else sprintf ( str , ""%f"" , d ) ; } <S2SV_ModEnd> } return str
"
1122,"CWE-125 static RList * r_bin_wasm_get_element_entries ( RBinWasmObj * bin , RBinWasmSection * sec ) { RList * ret = NULL ; RBinWasmElementEntry * ptr = NULL ; if ( ! ( ret = r_list_newf ( ( RListFree ) free ) ) ) { return NULL ; } ut8 * buf = bin -> buf -> buf + ( ut32 ) sec -> payload_data ; <S2SV_StartBug> ut32 len = sec -> payload_len ; <S2SV_EndBug> ut32 count = sec -> count ; ut32 i = 0 , r = 0 ; <S2SV_StartBug> while ( i < len && r < count ) { <S2SV_EndBug> if ( ! ( ptr = R_NEW0 ( RBinWasmElementEntry ) ) ) { return ret ; } if ( ! ( consume_u32 ( buf + i , buf + len , & ptr -> index , & i ) ) ) { <S2SV_StartBug> free ( ptr ) ; <S2SV_EndBug> return ret ; } if ( ! ( consume_init_expr ( buf + i , buf + len , R_BIN_WASM_END_OF_CODE , NULL , & i ) ) ) { <S2SV_StartBug> free ( ptr ) ; <S2SV_EndBug> return ret ; } if ( ! ( consume_u32 ( buf + i , buf + len , & ptr -> num_elem , & i ) ) ) { <S2SV_StartBug> free ( ptr ) ; <S2SV_EndBug> return ret ; } ut32 j = 0 ; while ( i < len && j < ptr -> num_elem ) { ut32 e ; if ( ! ( consume_u32 ( buf + i , buf + len , & e , & i ) ) ) { free ( ptr ) ; return ret ; } } r_list_append ( ret , ptr ) ; r += 1 ; } return ret ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> -> payload_data ; int buflen = bin -> buf -> length - ( ut32 ) sec -> payload_data ; <S2SV_ModStart> i < len && len < buflen <S2SV_ModStart> ) ) { goto beach <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ) { goto beach <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ) { goto beach <S2SV_ModEnd> ; } ut32 <S2SV_ModStart> return ret ; beach : free ( ptr ) ; return ret ;
"
1123,"CWE-119 static int PredictorDecodeRow ( TIFF * tif , uint8 * op0 , tmsize_t occ0 , uint16 s ) { TIFFPredictorState * sp = PredictorState ( tif ) ; assert ( sp != NULL ) ; assert ( sp -> decoderow != NULL ) ; assert ( sp -> decodepfunc != NULL ) ; if ( ( * sp -> decoderow ) ( tif , op0 , occ0 , s ) ) { <S2SV_StartBug> ( * sp -> decodepfunc ) ( tif , op0 , occ0 ) ; <S2SV_EndBug> <S2SV_StartBug> return 1 ; <S2SV_EndBug> } else return 0 ; }
","<S2SV_ModStart> ) ) { return <S2SV_ModStart> occ0 ) ; <S2SV_ModEnd> } else return
"
1124,"CWE-119 void vp8_dequant_idct_add_uv_block_mmx ( short * q , short * dq , unsigned char * dstu , unsigned char * dstv , int stride , char * eobs ) { int i ; for ( i = 0 ; i < 2 ; i ++ ) { if ( eobs [ 0 ] > 1 ) vp8_dequant_idct_add_mmx ( q , dq , dstu , stride ) ; else if ( eobs [ 0 ] == 1 ) { vp8_dc_only_idct_add_mmx ( q [ 0 ] * dq [ 0 ] , dstu , stride , dstu , stride ) ; <S2SV_StartBug> vpx_memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <S2SV_EndBug> } if ( eobs [ 1 ] > 1 ) vp8_dequant_idct_add_mmx ( q + 16 , dq , dstu + 4 , stride ) ; else if ( eobs [ 1 ] == 1 ) { vp8_dc_only_idct_add_mmx ( q [ 16 ] * dq [ 0 ] , dstu + 4 , stride , dstu + 4 , stride ) ; <S2SV_StartBug> vpx_memset ( q + 16 , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <S2SV_EndBug> } q += 32 ; dstu += 4 * stride ; eobs += 2 ; } for ( i = 0 ; i < 2 ; i ++ ) { if ( eobs [ 0 ] > 1 ) vp8_dequant_idct_add_mmx ( q , dq , dstv , stride ) ; else if ( eobs [ 0 ] == 1 ) { vp8_dc_only_idct_add_mmx ( q [ 0 ] * dq [ 0 ] , dstv , stride , dstv , stride ) ; <S2SV_StartBug> vpx_memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <S2SV_EndBug> } if ( eobs [ 1 ] > 1 ) vp8_dequant_idct_add_mmx ( q + 16 , dq , dstv + 4 , stride ) ; else if ( eobs [ 1 ] == 1 ) { vp8_dc_only_idct_add_mmx ( q [ 16 ] * dq [ 0 ] , dstv + 4 , stride , dstv + 4 , stride ) ; <S2SV_StartBug> vpx_memset ( q + 16 , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <S2SV_EndBug> } q += 32 ; dstv += 4 * stride ; eobs += 2 ; } }
","<S2SV_ModStart> stride ) ; memset <S2SV_ModEnd> ( q , <S2SV_ModStart> stride ) ; memset <S2SV_ModEnd> ( q + <S2SV_ModStart> stride ) ; memset <S2SV_ModEnd> ( q , <S2SV_ModStart> stride ) ; memset <S2SV_ModEnd> ( q +
"
1125,"CWE-119 void vp8_build_intra_predictors_mbuv_s_c ( MACROBLOCKD * x , unsigned char * uabove_row , unsigned char * vabove_row , unsigned char * uleft , unsigned char * vleft , int left_stride , unsigned char * upred_ptr , unsigned char * vpred_ptr , int pred_stride ) { unsigned char uleft_col [ 8 ] ; unsigned char utop_left = uabove_row [ - 1 ] ; unsigned char vleft_col [ 8 ] ; unsigned char vtop_left = vabove_row [ - 1 ] ; int i , j ; for ( i = 0 ; i < 8 ; i ++ ) { uleft_col [ i ] = uleft [ i * left_stride ] ; vleft_col [ i ] = vleft [ i * left_stride ] ; } switch ( x -> mode_info_context -> mbmi . uv_mode ) { case DC_PRED : { int expected_udc ; int expected_vdc ; int shift ; int Uaverage = 0 ; int Vaverage = 0 ; if ( x -> up_available ) { for ( i = 0 ; i < 8 ; i ++ ) { Uaverage += uabove_row [ i ] ; Vaverage += vabove_row [ i ] ; } } if ( x -> left_available ) { for ( i = 0 ; i < 8 ; i ++ ) { Uaverage += uleft_col [ i ] ; Vaverage += vleft_col [ i ] ; } } if ( ! x -> up_available && ! x -> left_available ) { expected_udc = 128 ; expected_vdc = 128 ; } else { shift = 2 + x -> up_available + x -> left_available ; expected_udc = ( Uaverage + ( 1 << ( shift - 1 ) ) ) >> shift ; expected_vdc = ( Vaverage + ( 1 << ( shift - 1 ) ) ) >> shift ; } for ( i = 0 ; i < 8 ; i ++ ) { <S2SV_StartBug> vpx_memset ( upred_ptr , expected_udc , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( vpred_ptr , expected_vdc , 8 ) ; <S2SV_EndBug> upred_ptr += pred_stride ; vpred_ptr += pred_stride ; } } break ; case V_PRED : { for ( i = 0 ; i < 8 ; i ++ ) { <S2SV_StartBug> vpx_memcpy ( upred_ptr , uabove_row , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( vpred_ptr , vabove_row , 8 ) ; <S2SV_EndBug> upred_ptr += pred_stride ; vpred_ptr += pred_stride ; } } break ; case H_PRED : { for ( i = 0 ; i < 8 ; i ++ ) { <S2SV_StartBug> vpx_memset ( upred_ptr , uleft_col [ i ] , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( vpred_ptr , vleft_col [ i ] , 8 ) ; <S2SV_EndBug> upred_ptr += pred_stride ; vpred_ptr += pred_stride ; } } break ; case TM_PRED : { for ( i = 0 ; i < 8 ; i ++ ) { for ( j = 0 ; j < 8 ; j ++ ) { int predu = uleft_col [ i ] + uabove_row [ j ] - utop_left ; int predv = vleft_col [ i ] + vabove_row [ j ] - vtop_left ; if ( predu < 0 ) predu = 0 ; if ( predu > 255 ) predu = 255 ; if ( predv < 0 ) predv = 0 ; if ( predv > 255 ) predv = 255 ; upred_ptr [ j ] = predu ; vpred_ptr [ j ] = predv ; } upred_ptr += pred_stride ; vpred_ptr += pred_stride ; } } break ; case B_PRED : case NEARESTMV : case NEARMV : case ZEROMV : case NEWMV : case SPLITMV : case MB_MODE_COUNT : break ; } }
","<S2SV_ModStart> ++ ) { memset <S2SV_ModEnd> ( upred_ptr , <S2SV_ModStart> 8 ) ; memset <S2SV_ModEnd> ( vpred_ptr , <S2SV_ModStart> ++ ) { memcpy <S2SV_ModEnd> ( upred_ptr , <S2SV_ModStart> 8 ) ; memcpy <S2SV_ModEnd> ( vpred_ptr , <S2SV_ModStart> ++ ) { memset <S2SV_ModEnd> ( upred_ptr , <S2SV_ModStart> 8 ) ; memset <S2SV_ModEnd> ( vpred_ptr ,
"
1126,"CWE-200 char * url_decode_r ( char * to , char * url , size_t size ) { char * s = url , * d = to , * e = & to [ size - 1 ] ; while ( * s && d < e ) { if ( unlikely ( * s == '%' ) ) { if ( likely ( s [ 1 ] && s [ 2 ] ) ) { <S2SV_StartBug> * d ++ = from_hex ( s [ 1 ] ) << 4 | from_hex ( s [ 2 ] ) ; <S2SV_EndBug> s += 2 ; } } else if ( unlikely ( * s == '+' ) ) * d ++ = '<S2SV_blank>' ; else * d ++ = * s ; s ++ ; } * d = '\\0' ; return to ; }
","<S2SV_ModStart> ) ) { char t <S2SV_ModEnd> = from_hex ( <S2SV_ModStart> [ 2 ] ) ; * d ++ = ( char ) ( ( isprint ( t ) ) ? t : '<S2SV_blank>'
"
1127,"CWE-125 static int mp_capable_print ( netdissect_options * ndo , const u_char * opt , u_int opt_len , u_char flags ) { const struct mp_capable * mpc = ( const struct mp_capable * ) opt ; <S2SV_StartBug> if ( ! ( opt_len == 12 && flags & TH_SYN ) && <S2SV_EndBug> ! ( opt_len == 20 && ( flags & ( TH_SYN | TH_ACK ) ) == TH_ACK ) ) return 0 ; if ( MP_CAPABLE_OPT_VERSION ( mpc -> sub_ver ) != 0 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>Unknown<S2SV_blank>Version<S2SV_blank>(%d)"" , MP_CAPABLE_OPT_VERSION ( mpc -> sub_ver ) ) ) ; return 1 ; } if ( mpc -> flags & MP_CAPABLE_C ) ND_PRINT ( ( ndo , ""<S2SV_blank>csum"" ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>{0x%"" PRIx64 , EXTRACT_64BITS ( mpc -> sender_key ) ) ) ; if ( opt_len == 20 ) ND_PRINT ( ( ndo , "",0x%"" PRIx64 , EXTRACT_64BITS ( mpc -> receiver_key ) ) ) ; ND_PRINT ( ( ndo , ""}"" ) ) ; return 1 ; }
","<S2SV_ModStart> == 12 && ( <S2SV_ModStart> flags & TH_SYN )
"
1128,"CWE-119 static long ioctl_file_dedupe_range ( struct file * file , void __user * arg ) { struct file_dedupe_range __user * argp = arg ; struct file_dedupe_range * same = NULL ; int ret ; unsigned long size ; u16 count ; if ( get_user ( count , & argp -> dest_count ) ) { ret = - EFAULT ; goto out ; } size = offsetof ( struct file_dedupe_range __user , info [ count ] ) ; same = memdup_user ( argp , size ) ; if ( IS_ERR ( same ) ) { ret = PTR_ERR ( same ) ; same = NULL ; goto out ; } <S2SV_StartBug> ret = vfs_dedupe_file_range ( file , same ) ; <S2SV_EndBug> if ( ret ) goto out ; ret = copy_to_user ( argp , same , size ) ; if ( ret ) ret = - EFAULT ; out : kfree ( same ) ; return ret ; }
","<S2SV_ModStart> out ; } same -> dest_count = count ;
"
1129,"CWE-264 static ssize_t ucma_write ( struct file * filp , const char __user * buf , size_t len , loff_t * pos ) { struct ucma_file * file = filp -> private_data ; struct rdma_ucm_cmd_hdr hdr ; <S2SV_StartBug> ssize_t ret ; <S2SV_EndBug> if ( len < sizeof ( hdr ) ) return - EINVAL ; if ( copy_from_user ( & hdr , buf , sizeof ( hdr ) ) ) return - EFAULT ; if ( hdr . cmd >= ARRAY_SIZE ( ucma_cmd_table ) ) return - EINVAL ; if ( hdr . in + sizeof ( hdr ) > len ) return - EINVAL ; if ( ! ucma_cmd_table [ hdr . cmd ] ) return - ENOSYS ; ret = ucma_cmd_table [ hdr . cmd ] ( file , buf + sizeof ( hdr ) , hdr . in , hdr . out ) ; if ( ! ret ) ret = len ; return ret ; }
","<S2SV_ModStart> ; ssize_t ret ; if ( WARN_ON_ONCE ( ! ib_safe_file_access ( filp ) ) ) return - EACCES
"
1130,"CWE-190 int _libssh2_packet_add ( LIBSSH2_SESSION * session , unsigned char * data , size_t datalen , int macstate ) { int rc = 0 ; <S2SV_StartBug> char * message = NULL ; <S2SV_EndBug> <S2SV_StartBug> char * language = NULL ; <S2SV_EndBug> size_t message_len = 0 ; size_t language_len = 0 ; LIBSSH2_CHANNEL * channelp = NULL ; size_t data_head = 0 ; unsigned char msg = data [ 0 ] ; switch ( session -> packAdd_state ) { case libssh2_NB_state_idle : _libssh2_debug ( session , LIBSSH2_TRACE_TRANS , ""Packet<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>received,<S2SV_blank>length=%d"" , ( int ) msg , ( int ) datalen ) ; if ( ( macstate == LIBSSH2_MAC_INVALID ) && ( ! session -> macerror || LIBSSH2_MACERROR ( session , ( char * ) data , datalen ) ) ) { LIBSSH2_FREE ( session , data ) ; return _libssh2_error ( session , LIBSSH2_ERROR_INVALID_MAC , ""Invalid<S2SV_blank>MAC<S2SV_blank>received"" ) ; } session -> packAdd_state = libssh2_NB_state_allocated ; break ; case libssh2_NB_state_jump1 : goto libssh2_packet_add_jump_point1 ; case libssh2_NB_state_jump2 : goto libssh2_packet_add_jump_point2 ; case libssh2_NB_state_jump3 : goto libssh2_packet_add_jump_point3 ; case libssh2_NB_state_jump4 : goto libssh2_packet_add_jump_point4 ; case libssh2_NB_state_jump5 : goto libssh2_packet_add_jump_point5 ; default : break ; } if ( session -> packAdd_state == libssh2_NB_state_allocated ) { switch ( msg ) { case SSH_MSG_DISCONNECT : if ( datalen >= 5 ) { <S2SV_StartBug> size_t reason = _libssh2_ntohu32 ( data + 1 ) ; <S2SV_EndBug> if ( datalen >= 9 ) { message_len = _libssh2_ntohu32 ( data + 5 ) ; if ( message_len < datalen - 13 ) { <S2SV_StartBug> message = ( char * ) data + 9 ; <S2SV_EndBug> language_len = _libssh2_ntohu32 ( data + 9 + message_len ) ; <S2SV_StartBug> language = ( char * ) data + 9 + message_len + 4 ; <S2SV_EndBug> if ( language_len > ( datalen - 13 - message_len ) ) { language = message = NULL ; language_len = message_len = 0 ; } } else message_len = 0 ; } if ( session -> ssh_msg_disconnect ) { LIBSSH2_DISCONNECT ( session , reason , message , message_len , language , language_len ) ; } _libssh2_debug ( session , LIBSSH2_TRACE_TRANS , ""Disconnect(%d):<S2SV_blank>%s(%s)"" , reason , message , language ) ; } LIBSSH2_FREE ( session , data ) ; session -> socket_state = LIBSSH2_SOCKET_DISCONNECTED ; session -> packAdd_state = libssh2_NB_state_idle ; return _libssh2_error ( session , LIBSSH2_ERROR_SOCKET_DISCONNECT , ""socket<S2SV_blank>disconnect"" ) ; case SSH_MSG_IGNORE : if ( datalen >= 2 ) { if ( session -> ssh_msg_ignore ) { LIBSSH2_IGNORE ( session , ( char * ) data + 1 , datalen - 1 ) ; } } else if ( session -> ssh_msg_ignore ) { LIBSSH2_IGNORE ( session , """" , 0 ) ; } LIBSSH2_FREE ( session , data ) ; session -> packAdd_state = libssh2_NB_state_idle ; return 0 ; case SSH_MSG_DEBUG : if ( datalen >= 2 ) { int always_display = data [ 1 ] ; if ( datalen >= 6 ) { <S2SV_StartBug> message_len = _libssh2_ntohu32 ( data + 2 ) ; <S2SV_EndBug> if ( message_len <= ( datalen - 10 ) ) { <S2SV_StartBug> message = ( char * ) data + 6 ; <S2SV_EndBug> language_len = _libssh2_ntohu32 ( data + 6 + message_len ) ; if ( language_len <= ( datalen - 10 - message_len ) ) <S2SV_StartBug> language = ( char * ) data + 10 + message_len ; <S2SV_EndBug> } } if ( session -> ssh_msg_debug ) { LIBSSH2_DEBUG ( session , always_display , message , message_len , language , language_len ) ; } } _libssh2_debug ( session , LIBSSH2_TRACE_TRANS , ""Debug<S2SV_blank>Packet:<S2SV_blank>%s"" , message ) ; LIBSSH2_FREE ( session , data ) ; session -> packAdd_state = libssh2_NB_state_idle ; return 0 ; case SSH_MSG_GLOBAL_REQUEST : if ( datalen >= 5 ) { uint32_t len = 0 ; unsigned char want_reply = 0 ; len = _libssh2_ntohu32 ( data + 1 ) ; <S2SV_StartBug> if ( datalen >= ( 6 + len ) ) { <S2SV_EndBug> want_reply = data [ 5 + len ] ; _libssh2_debug ( session , LIBSSH2_TRACE_CONN , ""Received<S2SV_blank>global<S2SV_blank>request<S2SV_blank>type<S2SV_blank>%.*s<S2SV_blank>(wr<S2SV_blank>%X)"" , len , data + 5 , want_reply ) ; } if ( want_reply ) { static const unsigned char packet = SSH_MSG_REQUEST_FAILURE ; libssh2_packet_add_jump_point5 : session -> packAdd_state = libssh2_NB_state_jump5 ; rc = _libssh2_transport_send ( session , & packet , 1 , NULL , 0 ) ; if ( rc == LIBSSH2_ERROR_EAGAIN ) return rc ; } } LIBSSH2_FREE ( session , data ) ; session -> packAdd_state = libssh2_NB_state_idle ; return 0 ; case SSH_MSG_CHANNEL_EXTENDED_DATA : data_head += 4 ; case SSH_MSG_CHANNEL_DATA : data_head += 9 ; if ( datalen >= data_head ) channelp = _libssh2_channel_locate ( session , _libssh2_ntohu32 ( data + 1 ) ) ; if ( ! channelp ) { _libssh2_error ( session , LIBSSH2_ERROR_CHANNEL_UNKNOWN , ""Packet<S2SV_blank>received<S2SV_blank>for<S2SV_blank>unknown<S2SV_blank>channel"" ) ; LIBSSH2_FREE ( session , data ) ; session -> packAdd_state = libssh2_NB_state_idle ; return 0 ; } # ifdef LIBSSH2DEBUG { uint32_t stream_id = 0 ; if ( msg == SSH_MSG_CHANNEL_EXTENDED_DATA ) stream_id = _libssh2_ntohu32 ( data + 5 ) ; _libssh2_debug ( session , LIBSSH2_TRACE_CONN , ""%d<S2SV_blank>bytes<S2SV_blank>packet_add()<S2SV_blank>for<S2SV_blank>%lu/%lu/%lu"" , ( int ) ( datalen - data_head ) , channelp -> local . id , channelp -> remote . id , stream_id ) ; } # endif if ( ( channelp -> remote . extended_data_ignore_mode == LIBSSH2_CHANNEL_EXTENDED_DATA_IGNORE ) && ( msg == SSH_MSG_CHANNEL_EXTENDED_DATA ) ) { LIBSSH2_FREE ( session , data ) ; _libssh2_debug ( session , LIBSSH2_TRACE_CONN , ""Ignoring<S2SV_blank>extended<S2SV_blank>data<S2SV_blank>and<S2SV_blank>refunding<S2SV_blank>%d<S2SV_blank>bytes"" , ( int ) ( datalen - 13 ) ) ; if ( channelp -> read_avail + datalen - data_head >= channelp -> remote . window_size ) datalen = channelp -> remote . window_size - channelp -> read_avail + data_head ; channelp -> remote . window_size -= datalen - data_head ; _libssh2_debug ( session , LIBSSH2_TRACE_CONN , ""shrinking<S2SV_blank>window<S2SV_blank>size<S2SV_blank>by<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>to<S2SV_blank>%lu,<S2SV_blank>"" ""read_avail<S2SV_blank>%lu"" , datalen - data_head , channelp -> remote . window_size , channelp -> read_avail ) ; session -> packAdd_channelp = channelp ; libssh2_packet_add_jump_point1 : session -> packAdd_state = libssh2_NB_state_jump1 ; rc = _libssh2_channel_receive_window_adjust ( session -> packAdd_channelp , datalen - 13 , 1 , NULL ) ; if ( rc == LIBSSH2_ERROR_EAGAIN ) return rc ; session -> packAdd_state = libssh2_NB_state_idle ; return 0 ; } if ( channelp -> remote . packet_size < ( datalen - data_head ) ) { _libssh2_error ( session , LIBSSH2_ERROR_CHANNEL_PACKET_EXCEEDED , ""Packet<S2SV_blank>contains<S2SV_blank>more<S2SV_blank>data<S2SV_blank>than<S2SV_blank>we<S2SV_blank>offered"" ""<S2SV_blank>to<S2SV_blank>receive,<S2SV_blank>truncating"" ) ; datalen = channelp -> remote . packet_size + data_head ; } if ( channelp -> remote . window_size <= channelp -> read_avail ) { _libssh2_error ( session , LIBSSH2_ERROR_CHANNEL_WINDOW_EXCEEDED , ""The<S2SV_blank>current<S2SV_blank>receive<S2SV_blank>window<S2SV_blank>is<S2SV_blank>full,"" ""<S2SV_blank>data<S2SV_blank>ignored"" ) ; LIBSSH2_FREE ( session , data ) ; session -> packAdd_state = libssh2_NB_state_idle ; return 0 ; } channelp -> remote . eof = 0 ; if ( channelp -> read_avail + datalen - data_head > channelp -> remote . window_size ) { _libssh2_error ( session , LIBSSH2_ERROR_CHANNEL_WINDOW_EXCEEDED , ""Remote<S2SV_blank>sent<S2SV_blank>more<S2SV_blank>data<S2SV_blank>than<S2SV_blank>current<S2SV_blank>"" ""window<S2SV_blank>allows,<S2SV_blank>truncating"" ) ; datalen = channelp -> remote . window_size - channelp -> read_avail + data_head ; } channelp -> read_avail += datalen - data_head ; _libssh2_debug ( session , LIBSSH2_TRACE_CONN , ""increasing<S2SV_blank>read_avail<S2SV_blank>by<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>to<S2SV_blank>%lu/%lu"" , ( long ) ( datalen - data_head ) , ( long ) channelp -> read_avail , ( long ) channelp -> remote . window_size ) ; break ; case SSH_MSG_CHANNEL_EOF : if ( datalen >= 5 ) channelp = _libssh2_channel_locate ( session , _libssh2_ntohu32 ( data + 1 ) ) ; if ( ! channelp ) ; else { _libssh2_debug ( session , LIBSSH2_TRACE_CONN , ""EOF<S2SV_blank>received<S2SV_blank>for<S2SV_blank>channel<S2SV_blank>%lu/%lu"" , channelp -> local . id , channelp -> remote . id ) ; channelp -> remote . eof = 1 ; } LIBSSH2_FREE ( session , data ) ; session -> packAdd_state = libssh2_NB_state_idle ; return 0 ; case SSH_MSG_CHANNEL_REQUEST : if ( datalen >= 9 ) { uint32_t channel = _libssh2_ntohu32 ( data + 1 ) ; uint32_t len = _libssh2_ntohu32 ( data + 5 ) ; unsigned char want_reply = 1 ; if ( ( len + 9 ) < datalen ) want_reply = data [ len + 9 ] ; _libssh2_debug ( session , LIBSSH2_TRACE_CONN , ""Channel<S2SV_blank>%d<S2SV_blank>received<S2SV_blank>request<S2SV_blank>type<S2SV_blank>%.*s<S2SV_blank>(wr<S2SV_blank>%X)"" , channel , len , data + 9 , want_reply ) ; if ( len == sizeof ( ""exit-status"" ) - 1 && ( sizeof ( ""exit-status"" ) - 1 + 9 ) <= datalen && ! memcmp ( ""exit-status"" , data + 9 , sizeof ( ""exit-status"" ) - 1 ) ) { if ( datalen >= 20 ) channelp = _libssh2_channel_locate ( session , channel ) ; if ( channelp && ( sizeof ( ""exit-status"" ) + 13 ) <= datalen ) { channelp -> exit_status = _libssh2_ntohu32 ( data + 9 + sizeof ( ""exit-status"" ) ) ; _libssh2_debug ( session , LIBSSH2_TRACE_CONN , ""Exit<S2SV_blank>status<S2SV_blank>%lu<S2SV_blank>received<S2SV_blank>for<S2SV_blank>"" ""channel<S2SV_blank>%lu/%lu"" , channelp -> exit_status , channelp -> local . id , channelp -> remote . id ) ; } } else if ( len == sizeof ( ""exit-signal"" ) - 1 && ( sizeof ( ""exit-signal"" ) - 1 + 9 ) <= datalen && ! memcmp ( ""exit-signal"" , data + 9 , sizeof ( ""exit-signal"" ) - 1 ) ) { if ( datalen >= 20 ) channelp = _libssh2_channel_locate ( session , channel ) ; if ( channelp && ( sizeof ( ""exit-signal"" ) + 13 ) <= datalen ) { uint32_t namelen = _libssh2_ntohu32 ( data + 9 + sizeof ( ""exit-signal"" ) ) ; if ( namelen <= UINT_MAX - 1 ) { channelp -> exit_signal = LIBSSH2_ALLOC ( session , namelen + 1 ) ; } else { channelp -> exit_signal = NULL ; } if ( ! channelp -> exit_signal ) rc = _libssh2_error ( session , LIBSSH2_ERROR_ALLOC , ""memory<S2SV_blank>for<S2SV_blank>signal<S2SV_blank>name"" ) ; else if ( ( sizeof ( ""exit-signal"" ) + 13 + namelen <= datalen ) ) { memcpy ( channelp -> exit_signal , data + 13 + sizeof ( ""exit-signal"" ) , namelen ) ; channelp -> exit_signal [ namelen ] = '\\0' ; _libssh2_debug ( session , LIBSSH2_TRACE_CONN , ""Exit<S2SV_blank>signal<S2SV_blank>%s<S2SV_blank>received<S2SV_blank>for<S2SV_blank>"" ""channel<S2SV_blank>%lu/%lu"" , channelp -> exit_signal , channelp -> local . id , channelp -> remote . id ) ; } } } if ( want_reply ) { unsigned char packet [ 5 ] ; libssh2_packet_add_jump_point4 : session -> packAdd_state = libssh2_NB_state_jump4 ; packet [ 0 ] = SSH_MSG_CHANNEL_FAILURE ; memcpy ( & packet [ 1 ] , data + 1 , 4 ) ; rc = _libssh2_transport_send ( session , packet , 5 , NULL , 0 ) ; if ( rc == LIBSSH2_ERROR_EAGAIN ) return rc ; } } LIBSSH2_FREE ( session , data ) ; session -> packAdd_state = libssh2_NB_state_idle ; return rc ; case SSH_MSG_CHANNEL_CLOSE : if ( datalen >= 5 ) channelp = _libssh2_channel_locate ( session , _libssh2_ntohu32 ( data + 1 ) ) ; if ( ! channelp ) { LIBSSH2_FREE ( session , data ) ; session -> packAdd_state = libssh2_NB_state_idle ; return 0 ; } _libssh2_debug ( session , LIBSSH2_TRACE_CONN , ""Close<S2SV_blank>received<S2SV_blank>for<S2SV_blank>channel<S2SV_blank>%lu/%lu"" , channelp -> local . id , channelp -> remote . id ) ; channelp -> remote . close = 1 ; channelp -> remote . eof = 1 ; LIBSSH2_FREE ( session , data ) ; session -> packAdd_state = libssh2_NB_state_idle ; return 0 ; case SSH_MSG_CHANNEL_OPEN : if ( datalen < 17 ) ; else if ( ( datalen >= ( sizeof ( ""forwarded-tcpip"" ) + 4 ) ) && ( ( sizeof ( ""forwarded-tcpip"" ) - 1 ) == _libssh2_ntohu32 ( data + 1 ) ) && ( memcmp ( data + 5 , ""forwarded-tcpip"" , sizeof ( ""forwarded-tcpip"" ) - 1 ) == 0 ) ) { memset ( & session -> packAdd_Qlstn_state , 0 , sizeof ( session -> packAdd_Qlstn_state ) ) ; libssh2_packet_add_jump_point2 : session -> packAdd_state = libssh2_NB_state_jump2 ; rc = packet_queue_listener ( session , data , datalen , & session -> packAdd_Qlstn_state ) ; } else if ( ( datalen >= ( sizeof ( ""x11"" ) + 4 ) ) && ( ( sizeof ( ""x11"" ) - 1 ) == _libssh2_ntohu32 ( data + 1 ) ) && ( memcmp ( data + 5 , ""x11"" , sizeof ( ""x11"" ) - 1 ) == 0 ) ) { memset ( & session -> packAdd_x11open_state , 0 , sizeof ( session -> packAdd_x11open_state ) ) ; libssh2_packet_add_jump_point3 : session -> packAdd_state = libssh2_NB_state_jump3 ; rc = packet_x11_open ( session , data , datalen , & session -> packAdd_x11open_state ) ; } if ( rc == LIBSSH2_ERROR_EAGAIN ) return rc ; LIBSSH2_FREE ( session , data ) ; session -> packAdd_state = libssh2_NB_state_idle ; return rc ; case SSH_MSG_CHANNEL_WINDOW_ADJUST : if ( datalen < 9 ) ; else { uint32_t bytestoadd = _libssh2_ntohu32 ( data + 5 ) ; channelp = _libssh2_channel_locate ( session , _libssh2_ntohu32 ( data + 1 ) ) ; if ( channelp ) { channelp -> local . window_size += bytestoadd ; _libssh2_debug ( session , LIBSSH2_TRACE_CONN , ""Window<S2SV_blank>adjust<S2SV_blank>for<S2SV_blank>channel<S2SV_blank>%lu/%lu,<S2SV_blank>"" ""adding<S2SV_blank>%lu<S2SV_blank>bytes,<S2SV_blank>new<S2SV_blank>window_size=%lu"" , channelp -> local . id , channelp -> remote . id , bytestoadd , channelp -> local . window_size ) ; } } LIBSSH2_FREE ( session , data ) ; session -> packAdd_state = libssh2_NB_state_idle ; return 0 ; default : break ; } session -> packAdd_state = libssh2_NB_state_sent ; } if ( session -> packAdd_state == libssh2_NB_state_sent ) { LIBSSH2_PACKET * packetp = LIBSSH2_ALLOC ( session , sizeof ( LIBSSH2_PACKET ) ) ; if ( ! packetp ) { _libssh2_debug ( session , LIBSSH2_ERROR_ALLOC , ""memory<S2SV_blank>for<S2SV_blank>packet"" ) ; LIBSSH2_FREE ( session , data ) ; session -> packAdd_state = libssh2_NB_state_idle ; return LIBSSH2_ERROR_ALLOC ; } packetp -> data = data ; packetp -> data_len = datalen ; packetp -> data_head = data_head ; _libssh2_list_add ( & session -> packets , & packetp -> node ) ; session -> packAdd_state = libssh2_NB_state_sent1 ; } if ( ( msg == SSH_MSG_KEXINIT && ! ( session -> state & LIBSSH2_STATE_EXCHANGING_KEYS ) ) || ( session -> packAdd_state == libssh2_NB_state_sent2 ) ) { if ( session -> packAdd_state == libssh2_NB_state_sent1 ) { _libssh2_debug ( session , LIBSSH2_TRACE_TRANS , ""Renegotiating<S2SV_blank>Keys"" ) ; session -> packAdd_state = libssh2_NB_state_sent2 ; } session -> readPack_state = libssh2_NB_state_idle ; session -> packet . total_num = 0 ; session -> packAdd_state = libssh2_NB_state_idle ; session -> fullpacket_state = libssh2_NB_state_idle ; memset ( & session -> startup_key_state , 0 , sizeof ( key_exchange_state_t ) ) ; rc = _libssh2_kex_exchange ( session , 1 , & session -> startup_key_state ) ; if ( rc == LIBSSH2_ERROR_EAGAIN ) return rc ; } session -> packAdd_state = libssh2_NB_state_idle ; return 0 ; }
","<S2SV_ModStart> = 0 ; unsigned <S2SV_ModStart> = NULL ; unsigned <S2SV_ModStart> 5 ) { uint32_t reason = 0 ; struct string_buf buf ; buf . data = ( unsigned <S2SV_ModEnd> char * ) <S2SV_ModStart> * ) data ; buf . dataptr = buf . data ; buf . len = datalen ; buf . dataptr ++ ; _libssh2_get_u32 ( & buf , & reason ) ; _libssh2_get_string ( & buf , & message , & message_len ) ; _libssh2_get_string ( & buf , & language , & language_len ) ; if ( session -> ssh_msg_disconnect ) { LIBSSH2_DISCONNECT ( session , reason , ( const <S2SV_ModEnd> char * ) <S2SV_ModStart> char * ) message , message_len , ( const char * ) language , <S2SV_ModEnd> language_len ) ; <S2SV_ModStart> 6 ) { struct string_buf buf ; buf . data = ( unsigned <S2SV_ModEnd> char * ) <S2SV_ModStart> * ) data ; buf . dataptr = buf . data ; buf . len = datalen ; buf . dataptr += 2 ; _libssh2_get_string ( & buf , & message , & message_len ) ; _libssh2_get_string ( & buf , & language , & language_len ) ; } if ( session -> ssh_msg_debug ) { LIBSSH2_DEBUG ( session , always_display , ( const <S2SV_ModEnd> char * ) <S2SV_ModStart> char * ) message , message_len , ( const char * ) <S2SV_ModEnd> language , language_len <S2SV_ModStart> ; if ( ( len <= ( UINT_MAX - 6 ) ) && ( <S2SV_ModStart> 6 + len )
"
1131,"CWE-119 static Image * ReadHALDImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; size_t cube_size , level ; ssize_t y ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; level = 0 ; if ( * image_info -> filename != '\\0' ) level = StringToUnsignedLong ( image_info -> filename ) ; if ( level < 2 ) level = 8 ; status = MagickTrue ; cube_size = level * level ; image -> columns = ( size_t ) ( level * cube_size ) ; image -> rows = ( size_t ) ( level * cube_size ) ; <S2SV_StartBug> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y += ( ssize_t ) level ) <S2SV_EndBug> { ssize_t blue , green , red ; register PixelPacket * restrict q ; if ( status == MagickFalse ) continue ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , ( size_t ) level , exception ) ; if ( q == ( PixelPacket * ) NULL ) { status = MagickFalse ; continue ; } blue = y / ( ssize_t ) level ; for ( green = 0 ; green < ( ssize_t ) cube_size ; green ++ ) { for ( red = 0 ; red < ( ssize_t ) cube_size ; red ++ ) { SetPixelRed ( q , ClampToQuantum ( ( MagickRealType ) ( QuantumRange * red / ( cube_size - 1.0 ) ) ) ) ; SetPixelGreen ( q , ClampToQuantum ( ( MagickRealType ) ( QuantumRange * green / ( cube_size - 1.0 ) ) ) ) ; SetPixelBlue ( q , ClampToQuantum ( ( MagickRealType ) ( QuantumRange * blue / ( cube_size - 1.0 ) ) ) ) ; SetPixelOpacity ( q , OpaqueOpacity ) ; q ++ ; } } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) status = MagickFalse ; } return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> cube_size ) ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
"
1132,"CWE-20 static struct block_device * ext3_blkdev_get ( dev_t dev , struct super_block * sb ) { struct block_device * bdev ; char b [ BDEVNAME_SIZE ] ; bdev = blkdev_get_by_dev ( dev , FMODE_READ | FMODE_WRITE | FMODE_EXCL , sb ) ; if ( IS_ERR ( bdev ) ) goto fail ; return bdev ; fail : <S2SV_StartBug> ext3_msg ( sb , ""error:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>journal<S2SV_blank>device<S2SV_blank>%s:<S2SV_blank>%ld"" , <S2SV_EndBug> __bdevname ( dev , b ) , PTR_ERR ( bdev ) ) ; return NULL ; }
","<S2SV_ModStart> ( sb , KERN_ERR ,
"
1133,"CWE-189 static int32 makepol ( QPRS_STATE * state ) { int32 val = 0 , type ; int32 lenval = 0 ; char * strval = NULL ; int32 stack [ STACKDEPTH ] ; int32 lenstack = 0 ; uint16 flag = 0 ; <S2SV_StartBug> while ( ( type = gettoken_query ( state , & val , & lenval , & strval , & flag ) ) != END ) <S2SV_EndBug> { switch ( type ) { case VAL : pushval_asis ( state , VAL , strval , lenval , flag ) ; while ( lenstack && ( stack [ lenstack - 1 ] == ( int32 ) '&' || stack [ lenstack - 1 ] == ( int32 ) '!' ) ) { lenstack -- ; pushquery ( state , OPR , stack [ lenstack ] , 0 , 0 , 0 ) ; } break ; case OPR : if ( lenstack && val == ( int32 ) '|' ) pushquery ( state , OPR , val , 0 , 0 , 0 ) ; else { if ( lenstack == STACKDEPTH ) elog ( ERROR , ""stack<S2SV_blank>too<S2SV_blank>short"" ) ; stack [ lenstack ] = val ; lenstack ++ ; } break ; case OPEN : if ( makepol ( state ) == ERR ) return ERR ; while ( lenstack && ( stack [ lenstack - 1 ] == ( int32 ) '&' || stack [ lenstack - 1 ] == ( int32 ) '!' ) ) { lenstack -- ; pushquery ( state , OPR , stack [ lenstack ] , 0 , 0 , 0 ) ; } break ; case CLOSE : while ( lenstack ) { lenstack -- ; pushquery ( state , OPR , stack [ lenstack ] , 0 , 0 , 0 ) ; } ; return END ; break ; case ERR : default : ereport ( ERROR , ( errcode ( ERRCODE_SYNTAX_ERROR ) , errmsg ( ""syntax<S2SV_blank>error"" ) ) ) ; return ERR ; } } while ( lenstack ) { lenstack -- ; pushquery ( state , OPR , stack [ lenstack ] , 0 , 0 , 0 ) ; } ; return END ; }
","<S2SV_ModStart> = 0 ; check_stack_depth ( ) ;
"
1134,"CWE-119 int vp8_regulate_q ( VP8_COMP * cpi , int target_bits_per_frame ) { <S2SV_StartBug> int Q = cpi -> active_worst_quality ; <S2SV_EndBug> cpi -> mb . zbin_over_quant = 0 ; if ( cpi -> oxcf . fixed_q >= 0 ) { Q = cpi -> oxcf . fixed_q ; if ( cpi -> common . frame_type == KEY_FRAME ) { Q = cpi -> oxcf . key_q ; } else if ( cpi -> oxcf . number_of_layers == 1 && cpi -> common . refresh_alt_ref_frame ) { Q = cpi -> oxcf . alt_q ; } else if ( cpi -> oxcf . number_of_layers == 1 && cpi -> common . refresh_golden_frame ) { Q = cpi -> oxcf . gold_q ; } } else { int i ; int last_error = INT_MAX ; int target_bits_per_mb ; int bits_per_mb_at_this_q ; double correction_factor ; if ( cpi -> common . frame_type == KEY_FRAME ) correction_factor = cpi -> key_frame_rate_correction_factor ; else { if ( cpi -> oxcf . number_of_layers == 1 && ( cpi -> common . refresh_alt_ref_frame || cpi -> common . refresh_golden_frame ) ) correction_factor = cpi -> gf_rate_correction_factor ; else correction_factor = cpi -> rate_correction_factor ; } if ( target_bits_per_frame >= ( INT_MAX >> BPER_MB_NORMBITS ) ) target_bits_per_mb = ( target_bits_per_frame / cpi -> common . MBs ) << BPER_MB_NORMBITS ; else target_bits_per_mb = ( target_bits_per_frame << BPER_MB_NORMBITS ) / cpi -> common . MBs ; i = cpi -> active_best_quality ; do { bits_per_mb_at_this_q = ( int ) ( .5 + correction_factor * vp8_bits_per_mb [ cpi -> common . frame_type ] [ i ] ) ; if ( bits_per_mb_at_this_q <= target_bits_per_mb ) { if ( ( target_bits_per_mb - bits_per_mb_at_this_q ) <= last_error ) Q = i ; else Q = i - 1 ; break ; } else last_error = bits_per_mb_at_this_q - target_bits_per_mb ; } while ( ++ i <= cpi -> active_worst_quality ) ; if ( Q >= MAXQ ) { int zbin_oqmax ; double Factor = 0.99 ; double factor_adjustment = 0.01 / 256.0 ; if ( cpi -> common . frame_type == KEY_FRAME ) zbin_oqmax = 0 ; else if ( cpi -> oxcf . number_of_layers == 1 && ( cpi -> common . refresh_alt_ref_frame || ( cpi -> common . refresh_golden_frame && ! cpi -> source_alt_ref_active ) ) ) zbin_oqmax = 16 ; else zbin_oqmax = ZBIN_OQ_MAX ; while ( cpi -> mb . zbin_over_quant < zbin_oqmax ) { cpi -> mb . zbin_over_quant ++ ; if ( cpi -> mb . zbin_over_quant > zbin_oqmax ) cpi -> mb . zbin_over_quant = zbin_oqmax ; bits_per_mb_at_this_q = ( int ) ( Factor * bits_per_mb_at_this_q ) ; Factor += factor_adjustment ; if ( Factor >= 0.999 ) Factor = 0.999 ; if ( bits_per_mb_at_this_q <= target_bits_per_mb ) break ; } } } return Q ; }
","<S2SV_ModStart> -> active_worst_quality ; if ( cpi -> force_maxqp == 1 ) { cpi -> active_worst_quality = cpi -> worst_quality ; return cpi -> worst_quality ; }
"
1135,"CWE-704 static int n_tty_ioctl ( struct tty_struct * tty , struct file * file , unsigned int cmd , unsigned long arg ) { struct n_tty_data * ldata = tty -> disc_data ; int retval ; switch ( cmd ) { case TIOCOUTQ : return put_user ( tty_chars_in_buffer ( tty ) , ( int __user * ) arg ) ; case TIOCINQ : down_write ( & tty -> termios_rwsem ) ; <S2SV_StartBug> if ( L_ICANON ( tty ) ) <S2SV_EndBug> retval = inq_canon ( ldata ) ; else retval = read_cnt ( ldata ) ; up_write ( & tty -> termios_rwsem ) ; return put_user ( retval , ( unsigned int __user * ) arg ) ; default : return n_tty_ioctl_helper ( tty , file , cmd , arg ) ; } }
","<S2SV_ModStart> ( tty ) && ! L_EXTPROC ( tty )
"
1136,"CWE-119 <S2SV_StartBug> void vp9_rc_update_rate_correction_factors ( VP9_COMP * cpi , int damp_var ) { <S2SV_EndBug> const VP9_COMMON * const cm = & cpi -> common ; int correction_factor = 100 ; double rate_correction_factor = get_rate_correction_factor ( cpi ) ; double adjustment_limit ; int projected_size_based_on_q = 0 ; <S2SV_StartBug> vp9_clear_system_state ( ) ; <S2SV_EndBug> projected_size_based_on_q = estimate_bits_at_q ( cm -> frame_type , cm -> base_qindex , cm -> MBs , <S2SV_StartBug> rate_correction_factor ) ; <S2SV_EndBug> <S2SV_StartBug> if ( projected_size_based_on_q > 0 ) <S2SV_EndBug> correction_factor = ( 100 * cpi -> rc . projected_frame_size ) / projected_size_based_on_q ; switch ( damp_var ) { case 0 : adjustment_limit = 0.75 ; break ; case 1 : adjustment_limit = 0.375 ; break ; case 2 : default : adjustment_limit = 0.25 ; break ; } if ( correction_factor > 102 ) { correction_factor = ( int ) ( 100 + ( ( correction_factor - 100 ) * adjustment_limit ) ) ; rate_correction_factor = ( rate_correction_factor * correction_factor ) / 100 ; if ( rate_correction_factor > MAX_BPB_FACTOR ) rate_correction_factor = MAX_BPB_FACTOR ; } else if ( correction_factor < 99 ) { correction_factor = ( int ) ( 100 - ( ( 100 - correction_factor ) * adjustment_limit ) ) ; rate_correction_factor = ( rate_correction_factor * correction_factor ) / 100 ; if ( rate_correction_factor < MIN_BPB_FACTOR ) rate_correction_factor = MIN_BPB_FACTOR ; } set_rate_correction_factor ( cpi , rate_correction_factor ) ; }
","<S2SV_ModStart> VP9_COMP * cpi <S2SV_ModEnd> ) { const <S2SV_ModStart> = 0 ; if ( cpi -> rc . is_src_frame_alt_ref ) return ; vpx_clear_system_state ( ) ; if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cpi -> common . seg . enabled ) { projected_size_based_on_q = vp9_cyclic_refresh_estimate_bits_at_q ( cpi , rate_correction_factor ) ; } else { projected_size_based_on_q = vp9_estimate_bits_at_q ( cpi -> common . <S2SV_ModEnd> frame_type , cm <S2SV_ModStart> MBs , rate_correction_factor , cm -> bit_depth ) ; } <S2SV_ModEnd> if ( projected_size_based_on_q <S2SV_ModStart> ( projected_size_based_on_q > FRAME_OVERHEAD_BITS ) correction_factor = ( int ) ( ( 100 * ( int64_t ) cpi -> rc . projected_frame_size ) / projected_size_based_on_q ) ; adjustment_limit = 0.25 + 0.5 * MIN ( 1 , fabs ( log10 ( 0.01 * correction_factor ) ) ) ; cpi -> rc . q_2_frame = cpi -> rc . q_1_frame ; cpi -> rc . q_1_frame = cm -> base_qindex ; cpi -> rc . rc_2_frame = cpi -> rc . rc_1_frame ; if ( correction_factor > 110 ) cpi -> rc . rc_1_frame = - 1 ; else if ( correction_factor < 90 ) cpi -> rc . rc_1_frame = 1 ; else cpi -> rc . rc_1_frame = 0 ; <S2SV_ModEnd> if ( correction_factor
"
1137,"CWE-119 static int get_registers ( rtl8150_t * dev , u16 indx , u16 size , void * data ) { <S2SV_StartBug> return usb_control_msg ( dev -> udev , usb_rcvctrlpipe ( dev -> udev , 0 ) , <S2SV_EndBug> RTL8150_REQ_GET_REGS , RTL8150_REQT_READ , <S2SV_StartBug> indx , 0 , data , size , 500 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> data ) { void * buf ; int ret ; buf = kmalloc ( size , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM ; ret = <S2SV_ModEnd> usb_control_msg ( dev <S2SV_ModStart> , 0 , buf <S2SV_ModEnd> , size , <S2SV_ModStart> 500 ) ; if ( ret > 0 && ret <= size ) memcpy ( data , buf , ret ) ; kfree ( buf ) ; return ret ;
"
1138,"CWE-362 static void smp_task_timedout ( struct timer_list * t ) { struct sas_task_slow * slow = from_timer ( slow , t , timer ) ; struct sas_task * task = slow -> task ; unsigned long flags ; spin_lock_irqsave ( & task -> task_state_lock , flags ) ; <S2SV_StartBug> if ( ! ( task -> task_state_flags & SAS_TASK_STATE_DONE ) ) <S2SV_EndBug> <S2SV_StartBug> task -> task_state_flags |= SAS_TASK_STATE_ABORTED ; <S2SV_EndBug> spin_unlock_irqrestore ( & task -> task_state_lock , flags ) ; complete ( & task -> slow_task -> completion ) ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> SAS_TASK_STATE_DONE ) ) { <S2SV_ModStart> task_state_flags |= SAS_TASK_STATE_ABORTED <S2SV_ModEnd> ; complete ( <S2SV_ModStart> ) ; } spin_unlock_irqrestore ( & task -> task_state_lock , flags ) ; }
"
1139,"CWE-119 static void define_gf_group ( VP8_COMP * cpi , FIRSTPASS_STATS * this_frame ) { FIRSTPASS_STATS next_frame ; FIRSTPASS_STATS * start_pos ; int i ; double r ; double boost_score = 0.0 ; double old_boost_score = 0.0 ; double gf_group_err = 0.0 ; double gf_first_frame_err = 0.0 ; double mod_frame_err = 0.0 ; double mv_ratio_accumulator = 0.0 ; double decay_accumulator = 1.0 ; double loop_decay_rate = 1.00 ; double this_frame_mv_in_out = 0.0 ; double mv_in_out_accumulator = 0.0 ; double abs_mv_in_out_accumulator = 0.0 ; double mod_err_per_mb_accumulator = 0.0 ; int max_bits = frame_max_bits ( cpi ) ; unsigned int allow_alt_ref = cpi -> oxcf . play_alternate && cpi -> oxcf . lag_in_frames ; int alt_boost = 0 ; int f_boost = 0 ; int b_boost = 0 ; int flash_detected ; cpi -> twopass . gf_group_bits = 0 ; cpi -> twopass . gf_decay_rate = 0 ; vp8_clear_system_state ( ) ; start_pos = cpi -> twopass . stats_in ; <S2SV_StartBug> vpx_memset ( & next_frame , 0 , sizeof ( next_frame ) ) ; <S2SV_EndBug> mod_frame_err = calculate_modified_err ( cpi , this_frame ) ; gf_first_frame_err = mod_frame_err ; if ( cpi -> common . frame_type == KEY_FRAME ) gf_group_err -= gf_first_frame_err ; i = 0 ; while ( ( ( i < cpi -> twopass . static_scene_max_gf_interval ) || ( ( cpi -> twopass . frames_to_key - i ) < MIN_GF_INTERVAL ) ) && ( i < cpi -> twopass . frames_to_key ) ) { i ++ ; mod_frame_err = calculate_modified_err ( cpi , this_frame ) ; gf_group_err += mod_frame_err ; mod_err_per_mb_accumulator += mod_frame_err / DOUBLE_DIVIDE_CHECK ( ( double ) cpi -> common . MBs ) ; if ( EOF == input_stats ( cpi , & next_frame ) ) break ; flash_detected = detect_flash ( cpi , 0 ) ; accumulate_frame_motion_stats ( cpi , & next_frame , & this_frame_mv_in_out , & mv_in_out_accumulator , & abs_mv_in_out_accumulator , & mv_ratio_accumulator ) ; r = calc_frame_boost ( cpi , & next_frame , this_frame_mv_in_out ) ; if ( ! flash_detected ) { loop_decay_rate = get_prediction_decay_rate ( cpi , & next_frame ) ; decay_accumulator = decay_accumulator * loop_decay_rate ; decay_accumulator = decay_accumulator < 0.1 ? 0.1 : decay_accumulator ; } boost_score += ( decay_accumulator * r ) ; if ( detect_transition_to_still ( cpi , i , 5 , loop_decay_rate , decay_accumulator ) ) { allow_alt_ref = 0 ; boost_score = old_boost_score ; break ; } if ( ( i >= cpi -> max_gf_interval && ( decay_accumulator < 0.995 ) ) || ( ( i > MIN_GF_INTERVAL ) && ( ( cpi -> twopass . frames_to_key - i ) >= MIN_GF_INTERVAL ) && ( ( boost_score > 20.0 ) || ( next_frame . pcnt_inter < 0.75 ) ) && ( ! flash_detected ) && ( ( mv_ratio_accumulator > 100.0 ) || ( abs_mv_in_out_accumulator > 3.0 ) || ( mv_in_out_accumulator < - 2.0 ) || ( ( boost_score - old_boost_score ) < 2.0 ) ) ) ) { boost_score = old_boost_score ; break ; } <S2SV_StartBug> vpx_memcpy ( this_frame , & next_frame , sizeof ( * this_frame ) ) ; <S2SV_EndBug> old_boost_score = boost_score ; } cpi -> twopass . gf_decay_rate = ( i > 0 ) ? ( int ) ( 100.0 * ( 1.0 - decay_accumulator ) ) / i : 0 ; if ( cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) { double max_boost ; if ( cpi -> drop_frames_allowed ) { int64_t df_buffer_level = cpi -> oxcf . drop_frames_water_mark * ( cpi -> oxcf . optimal_buffer_level / 100 ) ; if ( cpi -> buffer_level > df_buffer_level ) max_boost = ( ( double ) ( ( cpi -> buffer_level - df_buffer_level ) * 2 / 3 ) * 16.0 ) / DOUBLE_DIVIDE_CHECK ( ( double ) cpi -> av_per_frame_bandwidth ) ; else max_boost = 0.0 ; } else if ( cpi -> buffer_level > 0 ) { max_boost = ( ( double ) ( cpi -> buffer_level * 2 / 3 ) * 16.0 ) / DOUBLE_DIVIDE_CHECK ( ( double ) cpi -> av_per_frame_bandwidth ) ; } else { max_boost = 0.0 ; } if ( boost_score > max_boost ) boost_score = max_boost ; } if ( ( cpi -> twopass . frames_to_key - i ) < MIN_GF_INTERVAL ) { while ( i < cpi -> twopass . frames_to_key ) { i ++ ; if ( EOF == input_stats ( cpi , this_frame ) ) break ; if ( i < cpi -> twopass . frames_to_key ) { mod_frame_err = calculate_modified_err ( cpi , this_frame ) ; gf_group_err += mod_frame_err ; } } } cpi -> gfu_boost = ( int ) ( boost_score * 100.0 ) >> 4 ; # if NEW_BOOST alt_boost = calc_arf_boost ( cpi , 0 , ( i - 1 ) , ( i - 1 ) , & f_boost , & b_boost ) ; # endif if ( allow_alt_ref && ( i >= MIN_GF_INTERVAL ) && ( i <= ( cpi -> twopass . frames_to_key - MIN_GF_INTERVAL ) ) && # if NEW_BOOST ( ( next_frame . pcnt_inter > 0.75 ) || ( next_frame . pcnt_second_ref > 0.5 ) ) && ( ( mv_in_out_accumulator / ( double ) i > - 0.2 ) || ( mv_in_out_accumulator > - 2.0 ) ) && ( b_boost > 100 ) && ( f_boost > 100 ) ) # else ( next_frame . pcnt_inter > 0.75 ) && ( ( mv_in_out_accumulator / ( double ) i > - 0.2 ) || ( mv_in_out_accumulator > - 2.0 ) ) && ( cpi -> gfu_boost > 100 ) && ( cpi -> twopass . gf_decay_rate <= ( ARF_DECAY_THRESH + ( cpi -> gfu_boost / 200 ) ) ) ) # endif { int Boost ; int allocation_chunks ; int Q = ( cpi -> oxcf . fixed_q < 0 ) ? cpi -> last_q [ INTER_FRAME ] : cpi -> oxcf . fixed_q ; int tmp_q ; int arf_frame_bits = 0 ; int group_bits ; # if NEW_BOOST cpi -> gfu_boost = alt_boost ; # endif if ( ( cpi -> twopass . kf_group_bits > 0 ) && ( cpi -> twopass . kf_group_error_left > 0 ) ) { group_bits = ( int ) ( ( double ) cpi -> twopass . kf_group_bits * ( gf_group_err / ( double ) cpi -> twopass . kf_group_error_left ) ) ; } else group_bits = 0 ; # if NEW_BOOST Boost = ( alt_boost * GFQ_ADJUSTMENT ) / 100 ; # else Boost = ( cpi -> gfu_boost * 3 * GFQ_ADJUSTMENT ) / ( 2 * 100 ) ; # endif Boost += ( i * 50 ) ; if ( Boost > ( ( cpi -> baseline_gf_interval + 1 ) * 200 ) ) Boost = ( ( cpi -> baseline_gf_interval + 1 ) * 200 ) ; else if ( Boost < 125 ) Boost = 125 ; allocation_chunks = ( i * 100 ) + Boost ; while ( Boost > 1000 ) { Boost /= 2 ; allocation_chunks /= 2 ; } arf_frame_bits = ( int ) ( ( double ) Boost * ( group_bits / ( double ) allocation_chunks ) ) ; tmp_q = estimate_q ( cpi , mod_frame_err , ( int ) arf_frame_bits ) ; if ( tmp_q < cpi -> worst_quality ) { int half_gf_int ; int frames_after_arf ; int frames_bwd = cpi -> oxcf . arnr_max_frames - 1 ; int frames_fwd = cpi -> oxcf . arnr_max_frames - 1 ; cpi -> source_alt_ref_pending = 1 ; cpi -> baseline_gf_interval = i ; half_gf_int = cpi -> baseline_gf_interval >> 1 ; frames_after_arf = ( int ) ( cpi -> twopass . total_stats . count - this_frame -> frame - 1 ) ; switch ( cpi -> oxcf . arnr_type ) { case 1 : frames_fwd = 0 ; if ( frames_bwd > half_gf_int ) frames_bwd = half_gf_int ; break ; case 2 : if ( frames_fwd > half_gf_int ) frames_fwd = half_gf_int ; if ( frames_fwd > frames_after_arf ) frames_fwd = frames_after_arf ; frames_bwd = 0 ; break ; case 3 : default : frames_fwd >>= 1 ; if ( frames_fwd > frames_after_arf ) frames_fwd = frames_after_arf ; if ( frames_fwd > half_gf_int ) frames_fwd = half_gf_int ; frames_bwd = frames_fwd ; if ( frames_bwd < half_gf_int ) frames_bwd += ( cpi -> oxcf . arnr_max_frames + 1 ) & 0x1 ; break ; } cpi -> active_arnr_frames = frames_bwd + 1 + frames_fwd ; } else { cpi -> source_alt_ref_pending = 0 ; cpi -> baseline_gf_interval = i ; } } else { cpi -> source_alt_ref_pending = 0 ; cpi -> baseline_gf_interval = i ; } if ( cpi -> twopass . frames_to_key >= ( int ) ( cpi -> twopass . total_stats . count - cpi -> common . current_video_frame ) ) { cpi -> twopass . kf_group_bits = ( cpi -> twopass . bits_left > 0 ) ? cpi -> twopass . bits_left : 0 ; } if ( ( cpi -> twopass . kf_group_bits > 0 ) && ( cpi -> twopass . kf_group_error_left > 0 ) ) { cpi -> twopass . gf_group_bits = ( int64_t ) ( cpi -> twopass . kf_group_bits * ( gf_group_err / cpi -> twopass . kf_group_error_left ) ) ; } else cpi -> twopass . gf_group_bits = 0 ; cpi -> twopass . gf_group_bits = ( cpi -> twopass . gf_group_bits < 0 ) ? 0 : ( cpi -> twopass . gf_group_bits > cpi -> twopass . kf_group_bits ) ? cpi -> twopass . kf_group_bits : cpi -> twopass . gf_group_bits ; if ( cpi -> twopass . gf_group_bits > ( int64_t ) max_bits * cpi -> baseline_gf_interval ) cpi -> twopass . gf_group_bits = ( int64_t ) max_bits * cpi -> baseline_gf_interval ; reset_fpf_position ( cpi , start_pos ) ; cpi -> twopass . modified_error_used += gf_group_err ; for ( i = 0 ; i <= ( cpi -> source_alt_ref_pending && cpi -> common . frame_type != KEY_FRAME ) ; i ++ ) { int Boost ; int allocation_chunks ; int Q = ( cpi -> oxcf . fixed_q < 0 ) ? cpi -> last_q [ INTER_FRAME ] : cpi -> oxcf . fixed_q ; int gf_bits ; if ( cpi -> source_alt_ref_pending && i == 0 ) { # if NEW_BOOST Boost = ( alt_boost * GFQ_ADJUSTMENT ) / 100 ; # else Boost = ( cpi -> gfu_boost * 3 * GFQ_ADJUSTMENT ) / ( 2 * 100 ) ; # endif Boost += ( cpi -> baseline_gf_interval * 50 ) ; if ( Boost > ( ( cpi -> baseline_gf_interval + 1 ) * 200 ) ) Boost = ( ( cpi -> baseline_gf_interval + 1 ) * 200 ) ; else if ( Boost < 125 ) Boost = 125 ; allocation_chunks = ( ( cpi -> baseline_gf_interval + 1 ) * 100 ) + Boost ; } else { Boost = ( cpi -> gfu_boost * GFQ_ADJUSTMENT ) / 100 ; if ( Boost > ( cpi -> baseline_gf_interval * 150 ) ) Boost = ( cpi -> baseline_gf_interval * 150 ) ; else if ( Boost < 125 ) Boost = 125 ; allocation_chunks = ( cpi -> baseline_gf_interval * 100 ) + ( Boost - 100 ) ; } while ( Boost > 1000 ) { Boost /= 2 ; allocation_chunks /= 2 ; } gf_bits = ( int ) ( ( double ) Boost * ( cpi -> twopass . gf_group_bits / ( double ) allocation_chunks ) ) ; if ( mod_frame_err < gf_group_err / ( double ) cpi -> baseline_gf_interval ) { double alt_gf_grp_bits ; int alt_gf_bits ; alt_gf_grp_bits = ( double ) cpi -> twopass . kf_group_bits * ( mod_frame_err * ( double ) cpi -> baseline_gf_interval ) / DOUBLE_DIVIDE_CHECK ( ( double ) cpi -> twopass . kf_group_error_left ) ; alt_gf_bits = ( int ) ( ( double ) Boost * ( alt_gf_grp_bits / ( double ) allocation_chunks ) ) ; if ( gf_bits > alt_gf_bits ) { gf_bits = alt_gf_bits ; } } else { int alt_gf_bits = ( int ) ( ( double ) cpi -> twopass . kf_group_bits * mod_frame_err / DOUBLE_DIVIDE_CHECK ( ( double ) cpi -> twopass . kf_group_error_left ) ) ; if ( alt_gf_bits > gf_bits ) { gf_bits = alt_gf_bits ; } } if ( cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) { if ( cpi -> twopass . gf_bits > ( int ) ( cpi -> buffer_level >> 1 ) ) cpi -> twopass . gf_bits = ( int ) ( cpi -> buffer_level >> 1 ) ; } if ( gf_bits < 0 ) gf_bits = 0 ; gf_bits += cpi -> min_frame_bandwidth ; if ( i == 0 ) { cpi -> twopass . gf_bits = gf_bits ; } if ( i == 1 || ( ! cpi -> source_alt_ref_pending && ( cpi -> common . frame_type != KEY_FRAME ) ) ) { cpi -> per_frame_bandwidth = gf_bits ; } } { cpi -> twopass . kf_group_error_left -= ( int64_t ) gf_group_err ; cpi -> twopass . kf_group_bits -= cpi -> twopass . gf_group_bits ; if ( cpi -> twopass . kf_group_bits < 0 ) cpi -> twopass . kf_group_bits = 0 ; if ( ! cpi -> source_alt_ref_pending && cpi -> common . frame_type != KEY_FRAME ) cpi -> twopass . gf_group_error_left = ( int ) ( gf_group_err - gf_first_frame_err ) ; else cpi -> twopass . gf_group_error_left = ( int ) gf_group_err ; cpi -> twopass . gf_group_bits -= cpi -> twopass . gf_bits - cpi -> min_frame_bandwidth ; if ( cpi -> twopass . gf_group_bits < 0 ) cpi -> twopass . gf_group_bits = 0 ; if ( cpi -> baseline_gf_interval >= 3 ) { # if NEW_BOOST int boost = ( cpi -> source_alt_ref_pending ) ? b_boost : cpi -> gfu_boost ; # else int boost = cpi -> gfu_boost ; # endif if ( boost >= 150 ) { int pct_extra ; pct_extra = ( boost - 100 ) / 50 ; pct_extra = ( pct_extra > 20 ) ? 20 : pct_extra ; cpi -> twopass . alt_extra_bits = ( int ) ( cpi -> twopass . gf_group_bits * pct_extra ) / 100 ; cpi -> twopass . gf_group_bits -= cpi -> twopass . alt_extra_bits ; cpi -> twopass . alt_extra_bits /= ( ( cpi -> baseline_gf_interval - 1 ) >> 1 ) ; } else cpi -> twopass . alt_extra_bits = 0 ; } else cpi -> twopass . alt_extra_bits = 0 ; } if ( cpi -> common . frame_type != KEY_FRAME ) { FIRSTPASS_STATS sectionstats ; double Ratio ; zero_stats ( & sectionstats ) ; reset_fpf_position ( cpi , start_pos ) ; for ( i = 0 ; i < cpi -> baseline_gf_interval ; i ++ ) { input_stats ( cpi , & next_frame ) ; accumulate_stats ( & sectionstats , & next_frame ) ; } avg_stats ( & sectionstats ) ; cpi -> twopass . section_intra_rating = ( unsigned int ) ( sectionstats . intra_error / DOUBLE_DIVIDE_CHECK ( sectionstats . coded_error ) ) ; Ratio = sectionstats . intra_error / DOUBLE_DIVIDE_CHECK ( sectionstats . coded_error ) ; cpi -> twopass . section_max_qfactor = 1.0 - ( ( Ratio - 10.0 ) * 0.025 ) ; if ( cpi -> twopass . section_max_qfactor < 0.80 ) cpi -> twopass . section_max_qfactor = 0.80 ; reset_fpf_position ( cpi , start_pos ) ; } }
","<S2SV_ModStart> . stats_in ; memset <S2SV_ModEnd> ( & next_frame <S2SV_ModStart> break ; } memcpy <S2SV_ModEnd> ( this_frame ,
"
1140,"CWE-000 int ip6_fragment ( struct sk_buff * skb , int ( * output ) ( struct sk_buff * ) ) { struct sk_buff * frag ; struct rt6_info * rt = ( struct rt6_info * ) skb_dst ( skb ) ; struct ipv6_pinfo * np = skb -> sk ? inet6_sk ( skb -> sk ) : NULL ; struct ipv6hdr * tmp_hdr ; struct frag_hdr * fh ; unsigned int mtu , hlen , left , len ; __be32 frag_id = 0 ; int ptr , offset = 0 , err = 0 ; u8 * prevhdr , nexthdr = 0 ; struct net * net = dev_net ( skb_dst ( skb ) -> dev ) ; hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; nexthdr = * prevhdr ; mtu = ip6_skb_dst_mtu ( skb ) ; if ( ! skb -> local_df && skb -> len > mtu ) { skb -> dev = skb_dst ( skb ) -> dev ; icmpv6_send ( skb , ICMPV6_PKT_TOOBIG , 0 , mtu ) ; IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGFAILS ) ; kfree_skb ( skb ) ; return - EMSGSIZE ; } if ( np && np -> frag_size < mtu ) { if ( np -> frag_size ) mtu = np -> frag_size ; } mtu -= hlen + sizeof ( struct frag_hdr ) ; if ( skb_has_frag_list ( skb ) ) { int first_len = skb_pagelen ( skb ) ; struct sk_buff * frag2 ; if ( first_len - hlen > mtu || ( ( first_len - hlen ) & 7 ) || skb_cloned ( skb ) ) goto slow_path ; skb_walk_frags ( skb , frag ) { if ( frag -> len > mtu || ( ( frag -> len & 7 ) && frag -> next ) || skb_headroom ( frag ) < hlen ) goto slow_path_clean ; if ( skb_shared ( frag ) ) goto slow_path_clean ; BUG_ON ( frag -> sk ) ; if ( skb -> sk ) { frag -> sk = skb -> sk ; frag -> destructor = sock_wfree ; } skb -> truesize -= frag -> truesize ; } err = 0 ; offset = 0 ; frag = skb_shinfo ( skb ) -> frag_list ; skb_frag_list_init ( skb ) ; * prevhdr = NEXTHDR_FRAGMENT ; tmp_hdr = kmemdup ( skb_network_header ( skb ) , hlen , GFP_ATOMIC ) ; if ( ! tmp_hdr ) { IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGFAILS ) ; return - ENOMEM ; } __skb_pull ( skb , hlen ) ; fh = ( struct frag_hdr * ) __skb_push ( skb , sizeof ( struct frag_hdr ) ) ; __skb_push ( skb , hlen ) ; skb_reset_network_header ( skb ) ; memcpy ( skb_network_header ( skb ) , tmp_hdr , hlen ) ; <S2SV_StartBug> ipv6_select_ident ( fh ) ; <S2SV_EndBug> fh -> nexthdr = nexthdr ; fh -> reserved = 0 ; fh -> frag_off = htons ( IP6_MF ) ; frag_id = fh -> identification ; first_len = skb_pagelen ( skb ) ; skb -> data_len = first_len - skb_headlen ( skb ) ; skb -> len = first_len ; ipv6_hdr ( skb ) -> payload_len = htons ( first_len - sizeof ( struct ipv6hdr ) ) ; dst_hold ( & rt -> dst ) ; for ( ; ; ) { if ( frag ) { frag -> ip_summed = CHECKSUM_NONE ; skb_reset_transport_header ( frag ) ; fh = ( struct frag_hdr * ) __skb_push ( frag , sizeof ( struct frag_hdr ) ) ; __skb_push ( frag , hlen ) ; skb_reset_network_header ( frag ) ; memcpy ( skb_network_header ( frag ) , tmp_hdr , hlen ) ; offset += skb -> len - hlen - sizeof ( struct frag_hdr ) ; fh -> nexthdr = nexthdr ; fh -> reserved = 0 ; fh -> frag_off = htons ( offset ) ; if ( frag -> next != NULL ) fh -> frag_off |= htons ( IP6_MF ) ; fh -> identification = frag_id ; ipv6_hdr ( frag ) -> payload_len = htons ( frag -> len - sizeof ( struct ipv6hdr ) ) ; ip6_copy_metadata ( frag , skb ) ; } err = output ( skb ) ; if ( ! err ) IP6_INC_STATS ( net , ip6_dst_idev ( & rt -> dst ) , IPSTATS_MIB_FRAGCREATES ) ; if ( err || ! frag ) break ; skb = frag ; frag = skb -> next ; skb -> next = NULL ; } kfree ( tmp_hdr ) ; if ( err == 0 ) { IP6_INC_STATS ( net , ip6_dst_idev ( & rt -> dst ) , IPSTATS_MIB_FRAGOKS ) ; dst_release ( & rt -> dst ) ; return 0 ; } while ( frag ) { skb = frag -> next ; kfree_skb ( frag ) ; frag = skb ; } IP6_INC_STATS ( net , ip6_dst_idev ( & rt -> dst ) , IPSTATS_MIB_FRAGFAILS ) ; dst_release ( & rt -> dst ) ; return err ; slow_path_clean : skb_walk_frags ( skb , frag2 ) { if ( frag2 == frag ) break ; frag2 -> sk = NULL ; frag2 -> destructor = NULL ; skb -> truesize += frag2 -> truesize ; } } slow_path : left = skb -> len - hlen ; ptr = hlen ; * prevhdr = NEXTHDR_FRAGMENT ; while ( left > 0 ) { len = left ; if ( len > mtu ) len = mtu ; if ( len < left ) { len &= ~ 7 ; } if ( ( frag = alloc_skb ( len + hlen + sizeof ( struct frag_hdr ) + LL_ALLOCATED_SPACE ( rt -> dst . dev ) , GFP_ATOMIC ) ) == NULL ) { NETDEBUG ( KERN_INFO ""IPv6:<S2SV_blank>frag:<S2SV_blank>no<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>new<S2SV_blank>fragment!\\n"" ) ; IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGFAILS ) ; err = - ENOMEM ; goto fail ; } ip6_copy_metadata ( frag , skb ) ; skb_reserve ( frag , LL_RESERVED_SPACE ( rt -> dst . dev ) ) ; skb_put ( frag , len + hlen + sizeof ( struct frag_hdr ) ) ; skb_reset_network_header ( frag ) ; fh = ( struct frag_hdr * ) ( skb_network_header ( frag ) + hlen ) ; frag -> transport_header = ( frag -> network_header + hlen + sizeof ( struct frag_hdr ) ) ; if ( skb -> sk ) skb_set_owner_w ( frag , skb -> sk ) ; skb_copy_from_linear_data ( skb , skb_network_header ( frag ) , hlen ) ; fh -> nexthdr = nexthdr ; fh -> reserved = 0 ; if ( ! frag_id ) { <S2SV_StartBug> ipv6_select_ident ( fh ) ; <S2SV_EndBug> frag_id = fh -> identification ; } else fh -> identification = frag_id ; if ( skb_copy_bits ( skb , ptr , skb_transport_header ( frag ) , len ) ) BUG ( ) ; left -= len ; fh -> frag_off = htons ( offset ) ; if ( left > 0 ) fh -> frag_off |= htons ( IP6_MF ) ; ipv6_hdr ( frag ) -> payload_len = htons ( frag -> len - sizeof ( struct ipv6hdr ) ) ; ptr += len ; offset += len ; err = output ( frag ) ; if ( err ) goto fail ; IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGCREATES ) ; } IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGOKS ) ; kfree_skb ( skb ) ; return err ; fail : IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGFAILS ) ; kfree_skb ( skb ) ; return err ; }
","<S2SV_ModStart> ipv6_select_ident ( fh , rt <S2SV_ModStart> ipv6_select_ident ( fh , rt
"
1141,"CWE-119 void PNGAPI png_info_init_3 ( png_infopp ptr_ptr , png_size_t png_info_struct_size ) { png_infop info_ptr = * ptr_ptr ; png_debug ( 1 , ""in<S2SV_blank>png_info_init_3"" ) ; if ( info_ptr == NULL ) return ; if ( png_sizeof ( png_info ) > png_info_struct_size ) { png_destroy_struct ( info_ptr ) ; info_ptr = ( png_infop ) png_create_struct ( PNG_STRUCT_INFO ) ; * ptr_ptr = info_ptr ; <S2SV_StartBug> } <S2SV_EndBug> png_memset ( info_ptr , 0 , png_sizeof ( png_info ) ) ; }
","<S2SV_ModStart> = info_ptr ; if ( info_ptr == NULL ) return ;
"
1142,"CWE-362 static ssize_t driver_override_store ( struct device * dev , struct device_attribute * attr , const char * buf , size_t count ) { struct platform_device * pdev = to_platform_device ( dev ) ; <S2SV_StartBug> char * driver_override , * old = pdev -> driver_override , * cp ; <S2SV_EndBug> if ( count > PATH_MAX ) return - EINVAL ; driver_override = kstrndup ( buf , count , GFP_KERNEL ) ; if ( ! driver_override ) return - ENOMEM ; cp = strchr ( driver_override , '\\n' ) ; if ( cp ) * cp = '\\0' ; <S2SV_StartBug> if ( strlen ( driver_override ) ) { <S2SV_EndBug> pdev -> driver_override = driver_override ; } else { kfree ( driver_override ) ; pdev -> driver_override = NULL ; } <S2SV_StartBug> kfree ( old ) ; <S2SV_EndBug> return count ; }
","<S2SV_ModStart> , * old <S2SV_ModEnd> , * cp <S2SV_ModStart> = '\\0' ; device_lock ( dev ) ; old = pdev -> driver_override ; <S2SV_ModStart> NULL ; } device_unlock ( dev ) ;
"
1143,"CWE-20 static int cleanup_pathname ( struct archive_write_disk * a ) { <S2SV_StartBug> char * dest , * src ; <S2SV_EndBug> char separator = '\\0' ; <S2SV_StartBug> dest = src = a -> name ; <S2SV_EndBug> <S2SV_StartBug> if ( * src == '\\0' ) { <S2SV_EndBug> <S2SV_StartBug> archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , <S2SV_EndBug> ""Invalid<S2SV_blank>empty<S2SV_blank>pathname"" ) ; return ( ARCHIVE_FAILED ) ; } <S2SV_StartBug> # if defined ( __CYGWIN__ ) <S2SV_EndBug> cleanup_pathname_win ( a ) ; # endif if ( * src == '/' ) { if ( a -> flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""Path<S2SV_blank>is<S2SV_blank>absolute"" ) ; <S2SV_StartBug> return ( ARCHIVE_FAILED ) ; <S2SV_EndBug> } separator = * src ++ ; } for ( ; ; ) { if ( src [ 0 ] == '\\0' ) { break ; } else if ( src [ 0 ] == '/' ) { src ++ ; continue ; } else if ( src [ 0 ] == '.' ) { if ( src [ 1 ] == '\\0' ) { break ; } else if ( src [ 1 ] == '/' ) { src += 2 ; continue ; } else if ( src [ 1 ] == '.' ) { if ( src [ 2 ] == '/' || src [ 2 ] == '\\0' ) { if ( a -> flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""Path<S2SV_blank>contains<S2SV_blank>\'..\'"" ) ; return ( ARCHIVE_FAILED ) ; } } } } if ( separator ) * dest ++ = '/' ; while ( * src != '\\0' && * src != '/' ) { * dest ++ = * src ++ ; } if ( * src == '\\0' ) break ; separator = * src ++ ; } if ( dest == a -> name ) { if ( separator ) * dest ++ = '/' ; else * dest ++ = '.' ; } * dest = '\\0' ; return ( ARCHIVE_OK ) ; }
","<S2SV_ModStart> a ) { struct archive_string error_string ; int error_number ; int rc ; archive_string_init ( & error_string ) ; rc = cleanup_pathname_fsobj ( <S2SV_ModEnd> a -> name <S2SV_ModStart> a -> name , & error_number , & error_string , a -> flags ) <S2SV_ModStart> ; if ( rc != ARCHIVE_OK <S2SV_ModEnd> ) { archive_set_error <S2SV_ModStart> -> archive , error_number , ""%s"" , error_string . s <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } archive_string_free ( & error_string <S2SV_ModEnd> ) ; return <S2SV_ModStart> ) ; return rc <S2SV_ModEnd> ; } <S2SV_null>
"
1144,"CWE-125 static struct sk_buff * udp6_ufo_fragment ( struct sk_buff * skb , netdev_features_t features ) { struct sk_buff * segs = ERR_PTR ( - EINVAL ) ; unsigned int mss ; unsigned int unfrag_ip6hlen , unfrag_len ; struct frag_hdr * fptr ; u8 * packet_start , * prevhdr ; u8 nexthdr ; u8 frag_hdr_sz = sizeof ( struct frag_hdr ) ; __wsum csum ; int tnl_hlen ; mss = skb_shinfo ( skb ) -> gso_size ; if ( unlikely ( skb -> len <= mss ) ) goto out ; if ( skb_gso_ok ( skb , features | NETIF_F_GSO_ROBUST ) ) { skb_shinfo ( skb ) -> gso_segs = DIV_ROUND_UP ( skb -> len , mss ) ; if ( ! skb_shinfo ( skb ) -> ip6_frag_id ) ipv6_proxy_select_ident ( dev_net ( skb -> dev ) , skb ) ; segs = NULL ; goto out ; } if ( skb -> encapsulation && skb_shinfo ( skb ) -> gso_type & ( SKB_GSO_UDP_TUNNEL | SKB_GSO_UDP_TUNNEL_CSUM ) ) segs = skb_udp_tunnel_segment ( skb , features , true ) ; else { const struct ipv6hdr * ipv6h ; struct udphdr * uh ; if ( ! pskb_may_pull ( skb , sizeof ( struct udphdr ) ) ) goto out ; uh = udp_hdr ( skb ) ; ipv6h = ipv6_hdr ( skb ) ; uh -> check = 0 ; csum = skb_checksum ( skb , 0 , skb -> len , 0 ) ; uh -> check = udp_v6_check ( skb -> len , & ipv6h -> saddr , & ipv6h -> daddr , csum ) ; if ( uh -> check == 0 ) uh -> check = CSUM_MANGLED_0 ; skb -> ip_summed = CHECKSUM_NONE ; if ( ! skb -> encap_hdr_csum ) features |= NETIF_F_HW_CSUM ; tnl_hlen = skb_tnl_header_len ( skb ) ; if ( skb -> mac_header < ( tnl_hlen + frag_hdr_sz ) ) { if ( gso_pskb_expand_head ( skb , tnl_hlen + frag_hdr_sz ) ) goto out ; } unfrag_ip6hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; <S2SV_StartBug> nexthdr = * prevhdr ; <S2SV_EndBug> * prevhdr = NEXTHDR_FRAGMENT ; unfrag_len = ( skb_network_header ( skb ) - skb_mac_header ( skb ) ) + unfrag_ip6hlen + tnl_hlen ; packet_start = ( u8 * ) skb -> head + SKB_GSO_CB ( skb ) -> mac_offset ; memmove ( packet_start - frag_hdr_sz , packet_start , unfrag_len ) ; SKB_GSO_CB ( skb ) -> mac_offset -= frag_hdr_sz ; skb -> mac_header -= frag_hdr_sz ; skb -> network_header -= frag_hdr_sz ; fptr = ( struct frag_hdr * ) ( skb_network_header ( skb ) + unfrag_ip6hlen ) ; fptr -> nexthdr = nexthdr ; fptr -> reserved = 0 ; if ( ! skb_shinfo ( skb ) -> ip6_frag_id ) ipv6_proxy_select_ident ( dev_net ( skb -> dev ) , skb ) ; fptr -> identification = skb_shinfo ( skb ) -> ip6_frag_id ; segs = skb_segment ( skb , features ) ; } out : return segs ; }
","<S2SV_ModStart> prevhdr ) ; if ( unfrag_ip6hlen < 0 ) return ERR_PTR ( unfrag_ip6hlen ) ;
"
1145,"CWE-444 static ngx_int_t <S2SV_StartBug> ngx_http_lua_copy_request_headers ( ngx_http_request_t * sr , ngx_http_request_t * r ) <S2SV_EndBug> { <S2SV_StartBug> ngx_table_elt_t * header ; <S2SV_EndBug> ngx_list_part_t * part ; <S2SV_StartBug> ngx_uint_t i ; <S2SV_EndBug> if ( ngx_list_init ( & sr -> headers_in . headers , sr -> pool , 20 , sizeof ( ngx_table_elt_t ) ) != NGX_OK ) { return NGX_ERROR ; } <S2SV_StartBug> dd ( ""before:<S2SV_blank>parent<S2SV_blank>req<S2SV_blank>headers<S2SV_blank>count:<S2SV_blank>%d"" , <S2SV_EndBug> <S2SV_StartBug> ( int ) r -> headers_in . headers . part . nelts ) ; <S2SV_EndBug> part = & r -> headers_in . headers . part ; header = part -> elts ; for ( i = 0 ; ; i ++ ) { if ( i >= part -> nelts ) { <S2SV_StartBug> if ( part -> next == NULL ) { <S2SV_EndBug> break ; } part = part -> next ; header = part -> elts ; i = 0 ; } dd ( ""setting<S2SV_blank>request<S2SV_blank>header<S2SV_blank>%.*s:<S2SV_blank>%.*s"" , ( int ) header [ i ] . key . len , header [ i ] . key . data , ( int ) header [ i ] . value . len , header [ i ] . value . data ) ; if ( ngx_http_lua_set_input_header ( sr , header [ i ] . key , header [ i ] . value , 0 ) == NGX_ERROR ) { return NGX_ERROR ; } <S2SV_StartBug> } <S2SV_EndBug> dd ( ""after:<S2SV_blank>parent<S2SV_blank>req<S2SV_blank>headers<S2SV_blank>count:<S2SV_blank>%d"" , <S2SV_StartBug> ( int ) r -> headers_in . headers . part . nelts ) ; <S2SV_EndBug> return NGX_OK ; }
","<S2SV_ModStart> , ngx_http_request_t * pr , int pr_not_chunked <S2SV_ModEnd> ) { ngx_table_elt_t <S2SV_ModStart> { ngx_table_elt_t * clh , * <S2SV_ModStart> ; ngx_uint_t i ; u_char * p ; off_t len ; dd ( ""before:<S2SV_blank>parent<S2SV_blank>req<S2SV_blank>headers<S2SV_blank>count:<S2SV_blank>%d"" , ( int ) pr -> headers_in . headers . part . nelts ) <S2SV_ModStart> NGX_ERROR ; } if ( sr -> request_body && ! pr_not_chunked ) { len = sr -> request_body -> buf ? ngx_buf_size ( sr -> request_body -> buf ) : 0 ; clh = ngx_list_push ( & sr <S2SV_ModEnd> -> headers_in . <S2SV_ModStart> headers_in . headers ) ; if ( clh <S2SV_ModEnd> == NULL ) <S2SV_ModStart> == NULL ) <S2SV_ModEnd> { return NGX_ERROR <S2SV_ModStart> NGX_ERROR ; } clh -> hash = ngx_http_lua_content_length_hash ; clh -> key = ngx_http_lua_content_length_header_key ; clh -> lowcase_key = ngx_pnalloc ( sr -> pool , clh -> key . len ) ; if ( clh -> lowcase_key == NULL ) { return NGX_ERROR ; } ngx_strlow ( clh -> lowcase_key , clh -> key . data , clh -> key . len ) ; p = ngx_palloc ( sr -> pool , NGX_OFF_T_LEN ) ; if ( p == NULL ) { return NGX_ERROR ; } clh -> value . data = p ; clh -> value . len = ngx_sprintf ( clh -> value . data , ""%O"" , len ) - clh -> value . data ; sr -> headers_in . content_length = clh ; sr -> headers_in . content_length_n = len ; dd ( ""sr<S2SV_blank>crafted<S2SV_blank>content-length:<S2SV_blank>%.*s"" , ( int ) sr -> headers_in . content_length -> value . len , sr -> headers_in . content_length -> value . data ) ; } part = & pr -> headers_in . headers . part ; header = part -> elts ; for ( i = 0 ; ; i ++ ) { if ( i >= part -> nelts ) { if ( part -> next == NULL ) { break ; } part = part -> next ; header = part -> elts ; i = 0 ; } if ( ! pr_not_chunked && header [ i ] . key . len == sizeof ( ""Content-Length"" ) - 1 && ngx_strncasecmp ( header [ i ] . key . data , ( u_char * ) ""Content-Length"" , sizeof ( ""Content-Length"" ) - 1 ) == 0 ) { continue ; } dd ( ""sr<S2SV_blank>copied<S2SV_blank>req<S2SV_blank>header<S2SV_blank>%.*s:<S2SV_blank>%.*s"" , ( int ) header [ i ] . key . len , header [ i ] . key . data , ( int ) header [ i ] . value . len , header [ i ] . value . data ) ; if ( ngx_http_lua_set_input_header ( sr , header [ i ] . key , header [ i ] . value , 0 ) == NGX_ERROR ) { return NGX_ERROR ; } } dd ( <S2SV_ModEnd> ""after:<S2SV_blank>parent<S2SV_blank>req<S2SV_blank>headers<S2SV_blank>count:<S2SV_blank>%d"" , ( <S2SV_ModStart> ( int ) pr <S2SV_ModEnd> -> headers_in .
"
1146,"CWE-000 static int mct_u232_port_probe ( struct usb_serial_port * port ) { <S2SV_StartBug> struct mct_u232_private * priv ; <S2SV_EndBug> priv = kzalloc ( sizeof ( * priv ) , GFP_KERNEL ) ; if ( ! priv ) return - ENOMEM ; <S2SV_StartBug> priv -> read_urb = port -> serial -> port [ 1 ] -> interrupt_in_urb ; <S2SV_EndBug> priv -> read_urb -> context = port ; spin_lock_init ( & priv -> lock ) ; usb_set_serial_port_data ( port , priv ) ; return 0 ; }
","<S2SV_ModStart> ) { struct usb_serial * serial = port -> serial ; struct <S2SV_ModStart> * priv ; if ( ! serial -> port [ 1 ] || ! serial -> port [ 1 ] -> interrupt_in_urb ) { dev_err ( & port -> dev , ""expected<S2SV_blank>endpoint<S2SV_blank>missing\\n"" ) ; return - ENODEV ; } <S2SV_ModStart> -> read_urb = <S2SV_ModEnd> serial -> port
"
1147,"CWE-667 static int userfaultfd_register ( struct userfaultfd_ctx * ctx , unsigned long arg ) { struct mm_struct * mm = ctx -> mm ; struct vm_area_struct * vma , * prev , * cur ; int ret ; struct uffdio_register uffdio_register ; struct uffdio_register __user * user_uffdio_register ; unsigned long vm_flags , new_flags ; bool found ; bool basic_ioctls ; unsigned long start , end , vma_end ; user_uffdio_register = ( struct uffdio_register __user * ) arg ; ret = - EFAULT ; if ( copy_from_user ( & uffdio_register , user_uffdio_register , sizeof ( uffdio_register ) - sizeof ( __u64 ) ) ) goto out ; ret = - EINVAL ; if ( ! uffdio_register . mode ) goto out ; if ( uffdio_register . mode & ~ ( UFFDIO_REGISTER_MODE_MISSING | UFFDIO_REGISTER_MODE_WP ) ) goto out ; vm_flags = 0 ; if ( uffdio_register . mode & UFFDIO_REGISTER_MODE_MISSING ) vm_flags |= VM_UFFD_MISSING ; if ( uffdio_register . mode & UFFDIO_REGISTER_MODE_WP ) { vm_flags |= VM_UFFD_WP ; ret = - EINVAL ; goto out ; } ret = validate_range ( mm , uffdio_register . range . start , uffdio_register . range . len ) ; if ( ret ) goto out ; start = uffdio_register . range . start ; end = start + uffdio_register . range . len ; ret = - ENOMEM ; if ( ! mmget_not_zero ( mm ) ) goto out ; <S2SV_StartBug> down_write ( & mm -> mmap_sem ) ; <S2SV_EndBug> vma = find_vma_prev ( mm , start , & prev ) ; if ( ! vma ) goto out_unlock ; ret = - EINVAL ; if ( vma -> vm_start >= end ) goto out_unlock ; if ( is_vm_hugetlb_page ( vma ) ) { unsigned long vma_hpagesize = vma_kernel_pagesize ( vma ) ; if ( start & ( vma_hpagesize - 1 ) ) goto out_unlock ; } found = false ; basic_ioctls = false ; for ( cur = vma ; cur && cur -> vm_start < end ; cur = cur -> vm_next ) { cond_resched ( ) ; BUG_ON ( ! ! cur -> vm_userfaultfd_ctx . ctx ^ ! ! ( cur -> vm_flags & ( VM_UFFD_MISSING | VM_UFFD_WP ) ) ) ; ret = - EINVAL ; if ( ! vma_can_userfault ( cur ) ) goto out_unlock ; ret = - EPERM ; if ( unlikely ( ! ( cur -> vm_flags & VM_MAYWRITE ) ) ) goto out_unlock ; if ( is_vm_hugetlb_page ( cur ) && end <= cur -> vm_end && end > cur -> vm_start ) { unsigned long vma_hpagesize = vma_kernel_pagesize ( cur ) ; ret = - EINVAL ; if ( end & ( vma_hpagesize - 1 ) ) goto out_unlock ; } ret = - EBUSY ; if ( cur -> vm_userfaultfd_ctx . ctx && cur -> vm_userfaultfd_ctx . ctx != ctx ) goto out_unlock ; if ( is_vm_hugetlb_page ( cur ) ) basic_ioctls = true ; found = true ; } BUG_ON ( ! found ) ; if ( vma -> vm_start < start ) prev = vma ; ret = 0 ; do { cond_resched ( ) ; BUG_ON ( ! vma_can_userfault ( vma ) ) ; BUG_ON ( vma -> vm_userfaultfd_ctx . ctx && vma -> vm_userfaultfd_ctx . ctx != ctx ) ; WARN_ON ( ! ( vma -> vm_flags & VM_MAYWRITE ) ) ; if ( vma -> vm_userfaultfd_ctx . ctx == ctx && ( vma -> vm_flags & vm_flags ) == vm_flags ) goto skip ; if ( vma -> vm_start > start ) start = vma -> vm_start ; vma_end = min ( end , vma -> vm_end ) ; new_flags = ( vma -> vm_flags & ~ vm_flags ) | vm_flags ; prev = vma_merge ( mm , prev , start , vma_end , new_flags , vma -> anon_vma , vma -> vm_file , vma -> vm_pgoff , vma_policy ( vma ) , ( ( struct vm_userfaultfd_ctx ) { ctx } ) ) ; if ( prev ) { vma = prev ; goto next ; } if ( vma -> vm_start < start ) { ret = split_vma ( mm , vma , start , 1 ) ; if ( ret ) break ; } if ( vma -> vm_end > end ) { ret = split_vma ( mm , vma , end , 0 ) ; if ( ret ) break ; } next : vma -> vm_flags = new_flags ; vma -> vm_userfaultfd_ctx . ctx = ctx ; skip : prev = vma ; start = vma -> vm_end ; vma = vma -> vm_next ; } while ( vma && vma -> vm_start < end ) ; out_unlock : up_write ( & mm -> mmap_sem ) ; mmput ( mm ) ; if ( ! ret ) { if ( put_user ( basic_ioctls ? UFFD_API_RANGE_IOCTLS_BASIC : UFFD_API_RANGE_IOCTLS , & user_uffdio_register -> ioctls ) ) ret = - EFAULT ; } out : return ret ; }
","<S2SV_ModStart> -> mmap_sem ) ; if ( ! mmget_still_valid ( mm ) ) goto out_unlock
"
1148,"CWE-119 MagickBooleanType sixel_decode ( unsigned char * p , unsigned char * * pixels , size_t * pwidth , size_t * pheight , unsigned char * * palette , size_t * ncolors ) { int n , i , r , g , b , sixel_vertical_mask , c ; int posision_x , posision_y ; int max_x , max_y ; int attributed_pan , attributed_pad ; int attributed_ph , attributed_pv ; int repeat_count , color_index , max_color_index = 2 , background_color_index ; int param [ 10 ] ; int sixel_palet [ SIXEL_PALETTE_MAX ] ; unsigned char * imbuf , * dmbuf ; int imsx , imsy ; int dmsx , dmsy ; int y ; posision_x = posision_y = 0 ; max_x = max_y = 0 ; attributed_pan = 2 ; attributed_pad = 1 ; attributed_ph = attributed_pv = 0 ; repeat_count = 1 ; color_index = 0 ; background_color_index = 0 ; imsx = 2048 ; imsy = 2048 ; <S2SV_StartBug> imbuf = ( unsigned char * ) AcquireQuantumMemory ( imsx * imsy , 1 ) ; <S2SV_EndBug> if ( imbuf == NULL ) { return ( MagickFalse ) ; } for ( n = 0 ; n < 16 ; n ++ ) { sixel_palet [ n ] = sixel_default_color_table [ n ] ; } for ( r = 0 ; r < 6 ; r ++ ) { for ( g = 0 ; g < 6 ; g ++ ) { for ( b = 0 ; b < 6 ; b ++ ) { sixel_palet [ n ++ ] = SIXEL_RGB ( r * 51 , g * 51 , b * 51 ) ; } } } for ( i = 0 ; i < 24 ; i ++ ) { sixel_palet [ n ++ ] = SIXEL_RGB ( i * 11 , i * 11 , i * 11 ) ; } for ( ; n < SIXEL_PALETTE_MAX ; n ++ ) { sixel_palet [ n ] = SIXEL_RGB ( 255 , 255 , 255 ) ; } <S2SV_StartBug> ( void ) ResetMagickMemory ( imbuf , background_color_index , imsx * imsy ) ; <S2SV_EndBug> while ( * p != '\\0' ) { if ( ( p [ 0 ] == '\\033' && p [ 1 ] == 'P' ) || * p == 0x90 ) { if ( * p == '\\033' ) { p ++ ; } p = get_params ( ++ p , param , & n ) ; if ( * p == 'q' ) { p ++ ; if ( n > 0 ) { switch ( param [ 0 ] ) { case 0 : case 1 : attributed_pad = 2 ; break ; case 2 : attributed_pad = 5 ; break ; case 3 : attributed_pad = 4 ; break ; case 4 : attributed_pad = 4 ; break ; case 5 : attributed_pad = 3 ; break ; case 6 : attributed_pad = 3 ; break ; case 7 : attributed_pad = 2 ; break ; case 8 : attributed_pad = 2 ; break ; case 9 : attributed_pad = 1 ; break ; } } if ( n > 2 ) { if ( param [ 2 ] == 0 ) { param [ 2 ] = 10 ; } attributed_pan = attributed_pan * param [ 2 ] / 10 ; attributed_pad = attributed_pad * param [ 2 ] / 10 ; if ( attributed_pan <= 0 ) attributed_pan = 1 ; if ( attributed_pad <= 0 ) attributed_pad = 1 ; } } } else if ( ( p [ 0 ] == '\\033' && p [ 1 ] == '\\\\' ) || * p == 0x9C ) { break ; } else if ( * p == \'""\' ) { p = get_params ( ++ p , param , & n ) ; if ( n > 0 ) attributed_pad = param [ 0 ] ; if ( n > 1 ) attributed_pan = param [ 1 ] ; if ( n > 2 && param [ 2 ] > 0 ) attributed_ph = param [ 2 ] ; if ( n > 3 && param [ 3 ] > 0 ) attributed_pv = param [ 3 ] ; if ( attributed_pan <= 0 ) attributed_pan = 1 ; if ( attributed_pad <= 0 ) attributed_pad = 1 ; if ( imsx < attributed_ph || imsy < attributed_pv ) { dmsx = imsx > attributed_ph ? imsx : attributed_ph ; dmsy = imsy > attributed_pv ? imsy : attributed_pv ; <S2SV_StartBug> dmbuf = ( unsigned char * ) AcquireQuantumMemory ( dmsx * dmsy , 1 ) ; <S2SV_EndBug> if ( dmbuf == ( unsigned char * ) NULL ) { imbuf = ( unsigned char * ) RelinquishMagickMemory ( imbuf ) ; return ( MagickFalse ) ; } <S2SV_StartBug> ( void ) ResetMagickMemory ( dmbuf , background_color_index , dmsx * dmsy ) ; <S2SV_EndBug> for ( y = 0 ; y < imsy ; ++ y ) { ( void ) CopyMagickMemory ( dmbuf + dmsx * y , imbuf + imsx * y , imsx ) ; } imbuf = ( unsigned char * ) RelinquishMagickMemory ( imbuf ) ; imsx = dmsx ; imsy = dmsy ; imbuf = dmbuf ; } } else if ( * p == '!' ) { p = get_params ( ++ p , param , & n ) ; if ( n > 0 ) { repeat_count = param [ 0 ] ; } } else if ( * p == '#' ) { p = get_params ( ++ p , param , & n ) ; if ( n > 0 ) { if ( ( color_index = param [ 0 ] ) < 0 ) { color_index = 0 ; } else if ( color_index >= SIXEL_PALETTE_MAX ) { color_index = SIXEL_PALETTE_MAX - 1 ; } } if ( n > 4 ) { if ( param [ 1 ] == 1 ) { if ( param [ 2 ] > 360 ) param [ 2 ] = 360 ; if ( param [ 3 ] > 100 ) param [ 3 ] = 100 ; if ( param [ 4 ] > 100 ) param [ 4 ] = 100 ; sixel_palet [ color_index ] = hls_to_rgb ( param [ 2 ] * 100 / 360 , param [ 3 ] , param [ 4 ] ) ; } else if ( param [ 1 ] == 2 ) { if ( param [ 2 ] > 100 ) param [ 2 ] = 100 ; if ( param [ 3 ] > 100 ) param [ 3 ] = 100 ; if ( param [ 4 ] > 100 ) param [ 4 ] = 100 ; sixel_palet [ color_index ] = SIXEL_XRGB ( param [ 2 ] , param [ 3 ] , param [ 4 ] ) ; } } } else if ( * p == '$' ) { p ++ ; posision_x = 0 ; repeat_count = 1 ; } else if ( * p == '-' ) { p ++ ; posision_x = 0 ; posision_y += 6 ; repeat_count = 1 ; } else if ( * p >= '?' && * p <= '\\177' ) { if ( imsx < ( posision_x + repeat_count ) || imsy < ( posision_y + 6 ) ) { int nx = imsx * 2 ; int ny = imsy * 2 ; while ( nx < ( posision_x + repeat_count ) || ny < ( posision_y + 6 ) ) { nx *= 2 ; ny *= 2 ; } dmsx = nx ; dmsy = ny ; <S2SV_StartBug> dmbuf = ( unsigned char * ) AcquireQuantumMemory ( dmsx * dmsy , 1 ) ; <S2SV_EndBug> if ( dmbuf == ( unsigned char * ) NULL ) { imbuf = ( unsigned char * ) RelinquishMagickMemory ( imbuf ) ; return ( MagickFalse ) ; } <S2SV_StartBug> ( void ) ResetMagickMemory ( dmbuf , background_color_index , dmsx * dmsy ) ; <S2SV_EndBug> for ( y = 0 ; y < imsy ; ++ y ) { ( void ) CopyMagickMemory ( dmbuf + dmsx * y , imbuf + imsx * y , imsx ) ; } imbuf = ( unsigned char * ) RelinquishMagickMemory ( imbuf ) ; imsx = dmsx ; imsy = dmsy ; imbuf = dmbuf ; } if ( color_index > max_color_index ) { max_color_index = color_index ; } if ( ( b = * ( p ++ ) - '?' ) == 0 ) { posision_x += repeat_count ; } else { sixel_vertical_mask = 0x01 ; if ( repeat_count <= 1 ) { for ( i = 0 ; i < 6 ; i ++ ) { if ( ( b & sixel_vertical_mask ) != 0 ) { imbuf [ imsx * ( posision_y + i ) + posision_x ] = color_index ; if ( max_x < posision_x ) { max_x = posision_x ; } if ( max_y < ( posision_y + i ) ) { max_y = posision_y + i ; } } sixel_vertical_mask <<= 1 ; } posision_x += 1 ; } else { for ( i = 0 ; i < 6 ; i ++ ) { if ( ( b & sixel_vertical_mask ) != 0 ) { c = sixel_vertical_mask << 1 ; for ( n = 1 ; ( i + n ) < 6 ; n ++ ) { if ( ( b & c ) == 0 ) { break ; } c <<= 1 ; } for ( y = posision_y + i ; y < posision_y + i + n ; ++ y ) { <S2SV_StartBug> ( void ) ResetMagickMemory ( imbuf + imsx * y + posision_x , color_index , repeat_count ) ; <S2SV_EndBug> } if ( max_x < ( posision_x + repeat_count - 1 ) ) { max_x = posision_x + repeat_count - 1 ; } if ( max_y < ( posision_y + i + n - 1 ) ) { max_y = posision_y + i + n - 1 ; } i += ( n - 1 ) ; sixel_vertical_mask <<= ( n - 1 ) ; } sixel_vertical_mask <<= 1 ; } posision_x += repeat_count ; } } repeat_count = 1 ; } else { p ++ ; } } if ( ++ max_x < attributed_ph ) { max_x = attributed_ph ; } if ( ++ max_y < attributed_pv ) { max_y = attributed_pv ; } if ( imsx > max_x || imsy > max_y ) { dmsx = max_x ; dmsy = max_y ; <S2SV_StartBug> if ( ( dmbuf = ( unsigned char * ) AcquireQuantumMemory ( dmsx * dmsy , 1 ) ) == NULL ) { <S2SV_EndBug> imbuf = ( unsigned char * ) RelinquishMagickMemory ( imbuf ) ; return ( MagickFalse ) ; } for ( y = 0 ; y < dmsy ; ++ y ) { ( void ) CopyMagickMemory ( dmbuf + dmsx * y , imbuf + imsx * y , dmsx ) ; } imbuf = ( unsigned char * ) RelinquishMagickMemory ( imbuf ) ; imsx = dmsx ; imsy = dmsy ; imbuf = dmbuf ; } * pixels = imbuf ; * pwidth = imsx ; * pheight = imsy ; * ncolors = max_color_index + 1 ; * palette = ( unsigned char * ) AcquireQuantumMemory ( * ncolors , 4 ) ; for ( n = 0 ; n < ( ssize_t ) * ncolors ; ++ n ) { ( * palette ) [ n * 4 + 0 ] = sixel_palet [ n ] >> 16 & 0xff ; ( * palette ) [ n * 4 + 1 ] = sixel_palet [ n ] >> 8 & 0xff ; ( * palette ) [ n * 4 + 2 ] = sixel_palet [ n ] & 0xff ; ( * palette ) [ n * 4 + 3 ] = 0xff ; } return ( MagickTrue ) ; }
","<S2SV_ModStart> AcquireQuantumMemory ( imsx , imsy <S2SV_ModEnd> ) ; if <S2SV_ModStart> , background_color_index , ( size_t ) <S2SV_ModStart> AcquireQuantumMemory ( dmsx , dmsy <S2SV_ModEnd> ) ; if <S2SV_ModStart> , background_color_index , ( size_t ) <S2SV_ModStart> AcquireQuantumMemory ( dmsx , dmsy <S2SV_ModEnd> ) ; if <S2SV_ModStart> , background_color_index , ( size_t ) <S2SV_ModStart> ( imbuf + ( size_t ) <S2SV_ModStart> AcquireQuantumMemory ( dmsx , dmsy <S2SV_ModEnd> ) ) ==
"
1149,"CWE-17 static int udf_symlink_filler ( struct file * file , struct page * page ) { struct inode * inode = page -> mapping -> host ; struct buffer_head * bh = NULL ; unsigned char * symlink ; int err ; unsigned char * p = kmap ( page ) ; struct udf_inode_info * iinfo ; uint32_t pos ; if ( inode -> i_size > inode -> i_sb -> s_blocksize ) { err = - ENAMETOOLONG ; goto out_unmap ; } iinfo = UDF_I ( inode ) ; pos = udf_block_map ( inode , 0 ) ; down_read ( & iinfo -> i_data_sem ) ; if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ) { symlink = iinfo -> i_ext . i_data + iinfo -> i_lenEAttr ; } else { bh = sb_bread ( inode -> i_sb , pos ) ; if ( ! bh ) { err = - EIO ; goto out_unlock_inode ; } symlink = bh -> b_data ; } <S2SV_StartBug> udf_pc_to_char ( inode -> i_sb , symlink , inode -> i_size , p ) ; <S2SV_EndBug> <S2SV_StartBug> brelse ( bh ) ; <S2SV_EndBug> up_read ( & iinfo -> i_data_sem ) ; SetPageUptodate ( page ) ; kunmap ( page ) ; unlock_page ( page ) ; return 0 ; out_unlock_inode : up_read ( & iinfo -> i_data_sem ) ; SetPageError ( page ) ; out_unmap : kunmap ( page ) ; unlock_page ( page ) ; return err ; }
","<S2SV_ModStart> b_data ; } err = <S2SV_ModStart> i_size , p , PAGE_SIZE <S2SV_ModStart> ( bh ) ; if ( err ) goto out_unlock_inode
"
1150,"CWE-400 static void vmx_set_constant_host_state ( struct vcpu_vmx * vmx ) { u32 low32 , high32 ; unsigned long tmpl ; struct desc_ptr dt ; <S2SV_StartBug> vmcs_writel ( HOST_CR0 , read_cr0 ( ) & ~ X86_CR0_TS ) ; <S2SV_EndBug> <S2SV_StartBug> vmcs_writel ( HOST_CR4 , read_cr4 ( ) ) ; <S2SV_EndBug> vmcs_writel ( HOST_CR3 , read_cr3 ( ) ) ; vmcs_write16 ( HOST_CS_SELECTOR , __KERNEL_CS ) ; # ifdef CONFIG_X86_64 vmcs_write16 ( HOST_DS_SELECTOR , 0 ) ; vmcs_write16 ( HOST_ES_SELECTOR , 0 ) ; # else vmcs_write16 ( HOST_DS_SELECTOR , __KERNEL_DS ) ; vmcs_write16 ( HOST_ES_SELECTOR , __KERNEL_DS ) ; # endif vmcs_write16 ( HOST_SS_SELECTOR , __KERNEL_DS ) ; vmcs_write16 ( HOST_TR_SELECTOR , GDT_ENTRY_TSS * 8 ) ; native_store_idt ( & dt ) ; vmcs_writel ( HOST_IDTR_BASE , dt . address ) ; vmx -> host_idt_base = dt . address ; vmcs_writel ( HOST_RIP , vmx_return ) ; rdmsr ( MSR_IA32_SYSENTER_CS , low32 , high32 ) ; vmcs_write32 ( HOST_IA32_SYSENTER_CS , low32 ) ; rdmsrl ( MSR_IA32_SYSENTER_EIP , tmpl ) ; vmcs_writel ( HOST_IA32_SYSENTER_EIP , tmpl ) ; if ( vmcs_config . vmexit_ctrl & VM_EXIT_LOAD_IA32_PAT ) { rdmsr ( MSR_IA32_CR_PAT , low32 , high32 ) ; vmcs_write64 ( HOST_IA32_PAT , low32 | ( ( u64 ) high32 << 32 ) ) ; } }
","<S2SV_ModStart> desc_ptr dt ; unsigned long cr4 ; <S2SV_ModStart> ; vmcs_writel ( HOST_CR3 , read_cr3 ( ) ) ; cr4 = read_cr4 ( ) ; vmcs_writel ( HOST_CR4 , cr4 ) ; vmx -> host_state . vmcs_host_cr4 = cr4 <S2SV_ModEnd> ; vmcs_write16 (
"
1151,"CWE-74 static gboolean handle_spawn ( PortalFlatpak * object , GDBusMethodInvocation * invocation , GUnixFDList * fd_list , const gchar * arg_cwd_path , const gchar * const * arg_argv , GVariant * arg_fds , GVariant * arg_envs , guint arg_flags , GVariant * arg_options ) { g_autoptr ( GError ) error = NULL ; ChildSetupData child_setup_data = { NULL } ; GPid pid ; PidData * pid_data ; InstanceIdReadData * instance_id_read_data = NULL ; gsize i , j , n_fds , n_envs ; const gint * fds = NULL ; gint fds_len = 0 ; g_autofree FdMapEntry * fd_map = NULL ; gchar * * env ; gint32 max_fd ; GKeyFile * app_info ; g_autoptr ( GPtrArray ) flatpak_argv = g_ptr_array_new_with_free_func ( g_free ) ; g_autofree char * app_id = NULL ; g_autofree char * branch = NULL ; g_autofree char * arch = NULL ; g_autofree char * app_commit = NULL ; g_autofree char * runtime_ref = NULL ; g_auto ( GStrv ) runtime_parts = NULL ; g_autofree char * runtime_commit = NULL ; g_autofree char * instance_path = NULL ; g_auto ( GStrv ) extra_args = NULL ; g_auto ( GStrv ) shares = NULL ; g_auto ( GStrv ) sockets = NULL ; g_auto ( GStrv ) devices = NULL ; g_auto ( GStrv ) sandbox_expose = NULL ; g_auto ( GStrv ) sandbox_expose_ro = NULL ; g_autoptr ( GVariant ) sandbox_expose_fd = NULL ; g_autoptr ( GVariant ) sandbox_expose_fd_ro = NULL ; g_autoptr ( GOutputStream ) instance_id_out_stream = NULL ; guint sandbox_flags = 0 ; gboolean sandboxed ; gboolean expose_pids ; gboolean share_pids ; gboolean notify_start ; <S2SV_StartBug> gboolean devel ; <S2SV_EndBug> <S2SV_StartBug> child_setup_data . instance_id_fd = - 1 ; <S2SV_EndBug> if ( fd_list != NULL ) fds = g_unix_fd_list_peek_fds ( fd_list , & fds_len ) ; app_info = g_object_get_data ( G_OBJECT ( invocation ) , ""app-info"" ) ; g_assert ( app_info != NULL ) ; app_id = g_key_file_get_string ( app_info , FLATPAK_METADATA_GROUP_APPLICATION , FLATPAK_METADATA_KEY_NAME , NULL ) ; g_assert ( app_id != NULL ) ; g_debug ( ""spawn()<S2SV_blank>called<S2SV_blank>from<S2SV_blank>app:<S2SV_blank>\'%s\'"" , app_id ) ; if ( * app_id == 0 ) { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , ""org.freedesktop.portal.Flatpak.Spawn<S2SV_blank>only<S2SV_blank>works<S2SV_blank>in<S2SV_blank>a<S2SV_blank>flatpak"" ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } if ( * arg_cwd_path == 0 ) arg_cwd_path = NULL ; if ( arg_argv == NULL || * arg_argv == NULL ) { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , ""No<S2SV_blank>command<S2SV_blank>given"" ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } if ( ( arg_flags & ~ FLATPAK_SPAWN_FLAGS_ALL ) != 0 ) { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , ""Unsupported<S2SV_blank>flags<S2SV_blank>enabled:<S2SV_blank>0x%x"" , arg_flags & ~ FLATPAK_SPAWN_FLAGS_ALL ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } runtime_ref = g_key_file_get_string ( app_info , FLATPAK_METADATA_GROUP_APPLICATION , FLATPAK_METADATA_KEY_RUNTIME , NULL ) ; if ( runtime_ref == NULL ) { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , ""No<S2SV_blank>runtime<S2SV_blank>found"" ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } runtime_parts = g_strsplit ( runtime_ref , ""/"" , - 1 ) ; branch = g_key_file_get_string ( app_info , FLATPAK_METADATA_GROUP_INSTANCE , FLATPAK_METADATA_KEY_BRANCH , NULL ) ; instance_path = g_key_file_get_string ( app_info , FLATPAK_METADATA_GROUP_INSTANCE , FLATPAK_METADATA_KEY_INSTANCE_PATH , NULL ) ; arch = g_key_file_get_string ( app_info , FLATPAK_METADATA_GROUP_INSTANCE , FLATPAK_METADATA_KEY_ARCH , NULL ) ; extra_args = g_key_file_get_string_list ( app_info , FLATPAK_METADATA_GROUP_INSTANCE , FLATPAK_METADATA_KEY_EXTRA_ARGS , NULL , NULL ) ; app_commit = g_key_file_get_string ( app_info , FLATPAK_METADATA_GROUP_INSTANCE , FLATPAK_METADATA_KEY_APP_COMMIT , NULL ) ; runtime_commit = g_key_file_get_string ( app_info , FLATPAK_METADATA_GROUP_INSTANCE , FLATPAK_METADATA_KEY_RUNTIME_COMMIT , NULL ) ; shares = g_key_file_get_string_list ( app_info , FLATPAK_METADATA_GROUP_CONTEXT , FLATPAK_METADATA_KEY_SHARED , NULL , NULL ) ; sockets = g_key_file_get_string_list ( app_info , FLATPAK_METADATA_GROUP_CONTEXT , FLATPAK_METADATA_KEY_SOCKETS , NULL , NULL ) ; devices = g_key_file_get_string_list ( app_info , FLATPAK_METADATA_GROUP_CONTEXT , FLATPAK_METADATA_KEY_DEVICES , NULL , NULL ) ; devel = g_key_file_get_boolean ( app_info , FLATPAK_METADATA_GROUP_INSTANCE , FLATPAK_METADATA_KEY_DEVEL , NULL ) ; g_variant_lookup ( arg_options , ""sandbox-expose"" , ""^as"" , & sandbox_expose ) ; g_variant_lookup ( arg_options , ""sandbox-expose-ro"" , ""^as"" , & sandbox_expose_ro ) ; g_variant_lookup ( arg_options , ""sandbox-flags"" , ""u"" , & sandbox_flags ) ; sandbox_expose_fd = g_variant_lookup_value ( arg_options , ""sandbox-expose-fd"" , G_VARIANT_TYPE ( ""ah"" ) ) ; sandbox_expose_fd_ro = g_variant_lookup_value ( arg_options , ""sandbox-expose-fd-ro"" , G_VARIANT_TYPE ( ""ah"" ) ) ; if ( ( sandbox_flags & ~ FLATPAK_SPAWN_SANDBOX_FLAGS_ALL ) != 0 ) { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , ""Unsupported<S2SV_blank>sandbox<S2SV_blank>flags<S2SV_blank>enabled:<S2SV_blank>0x%x"" , arg_flags & ~ FLATPAK_SPAWN_SANDBOX_FLAGS_ALL ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } if ( instance_path == NULL && ( ( sandbox_expose != NULL && sandbox_expose [ 0 ] != NULL ) || ( sandbox_expose_ro != NULL && sandbox_expose_ro [ 0 ] != NULL ) ) ) { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , ""Invalid<S2SV_blank>sandbox<S2SV_blank>expose,<S2SV_blank>caller<S2SV_blank>has<S2SV_blank>no<S2SV_blank>instance<S2SV_blank>path"" ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } for ( i = 0 ; sandbox_expose != NULL && sandbox_expose [ i ] != NULL ; i ++ ) { const char * expose = sandbox_expose [ i ] ; g_debug ( ""exposing<S2SV_blank>%s"" , expose ) ; if ( ! is_valid_expose ( expose , & error ) ) { g_dbus_method_invocation_return_gerror ( invocation , error ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } } for ( i = 0 ; sandbox_expose_ro != NULL && sandbox_expose_ro [ i ] != NULL ; i ++ ) { const char * expose = sandbox_expose_ro [ i ] ; g_debug ( ""exposing<S2SV_blank>%s"" , expose ) ; if ( ! is_valid_expose ( expose , & error ) ) { g_dbus_method_invocation_return_gerror ( invocation , error ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } } g_debug ( ""Running<S2SV_blank>spawn<S2SV_blank>command<S2SV_blank>%s"" , arg_argv [ 0 ] ) ; n_fds = 0 ; if ( fds != NULL ) n_fds = g_variant_n_children ( arg_fds ) ; fd_map = g_new0 ( FdMapEntry , n_fds ) ; child_setup_data . fd_map = fd_map ; child_setup_data . fd_map_len = n_fds ; max_fd = - 1 ; for ( i = 0 ; i < n_fds ; i ++ ) { gint32 handle , dest_fd ; int handle_fd ; g_variant_get_child ( arg_fds , i , ""{uh}"" , & dest_fd , & handle ) ; if ( handle >= fds_len || handle < 0 ) { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , ""No<S2SV_blank>file<S2SV_blank>descriptor<S2SV_blank>for<S2SV_blank>handle<S2SV_blank>%d"" , handle ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } handle_fd = fds [ handle ] ; fd_map [ i ] . to = dest_fd ; fd_map [ i ] . from = handle_fd ; fd_map [ i ] . final = fd_map [ i ] . to ; if ( ( dest_fd == 0 || dest_fd == 1 || dest_fd == 2 ) && ! child_setup_data . set_tty && isatty ( handle_fd ) ) { child_setup_data . set_tty = TRUE ; child_setup_data . tty = handle_fd ; } max_fd = MAX ( max_fd , fd_map [ i ] . to ) ; max_fd = MAX ( max_fd , fd_map [ i ] . from ) ; } for ( i = 0 ; i < n_fds ; i ++ ) { int to_fd = fd_map [ i ] . to ; gboolean conflict = FALSE ; for ( j = i + 1 ; j < n_fds ; j ++ ) { int from_fd = fd_map [ j ] . from ; if ( from_fd == to_fd ) { conflict = TRUE ; break ; } } if ( conflict ) fd_map [ i ] . to = ++ max_fd ; } if ( arg_flags & FLATPAK_SPAWN_FLAGS_CLEAR_ENV ) { char * empty [ ] = { NULL } ; env = g_strdupv ( empty ) ; } else env = g_get_environ ( ) ; n_envs = g_variant_n_children ( arg_envs ) ; for ( i = 0 ; i < n_envs ; i ++ ) { const char * var = NULL ; const char * val = NULL ; g_variant_get_child ( arg_envs , i , ""{&s&s}"" , & var , & val ) ; env = g_environ_setenv ( env , var , val , TRUE ) ; } g_ptr_array_add ( flatpak_argv , g_strdup ( ""flatpak"" ) ) ; g_ptr_array_add ( flatpak_argv , g_strdup ( ""run"" ) ) ; sandboxed = ( arg_flags & FLATPAK_SPAWN_FLAGS_SANDBOX ) != 0 ; if ( sandboxed ) { g_ptr_array_add ( flatpak_argv , g_strdup ( ""--sandbox"" ) ) ; if ( sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_DISPLAY ) { if ( sockets != NULL && g_strv_contains ( ( const char * const * ) sockets , ""wayland"" ) ) g_ptr_array_add ( flatpak_argv , g_strdup ( ""--socket=wayland"" ) ) ; if ( sockets != NULL && g_strv_contains ( ( const char * const * ) sockets , ""fallback-x11"" ) ) g_ptr_array_add ( flatpak_argv , g_strdup ( ""--socket=fallback-x11"" ) ) ; if ( sockets != NULL && g_strv_contains ( ( const char * const * ) sockets , ""x11"" ) ) g_ptr_array_add ( flatpak_argv , g_strdup ( ""--socket=x11"" ) ) ; if ( shares != NULL && g_strv_contains ( ( const char * const * ) shares , ""ipc"" ) && sockets != NULL && ( g_strv_contains ( ( const char * const * ) sockets , ""fallback-x11"" ) || g_strv_contains ( ( const char * const * ) sockets , ""x11"" ) ) ) g_ptr_array_add ( flatpak_argv , g_strdup ( ""--share=ipc"" ) ) ; } if ( sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_SOUND ) { if ( sockets != NULL && g_strv_contains ( ( const char * const * ) sockets , ""pulseaudio"" ) ) g_ptr_array_add ( flatpak_argv , g_strdup ( ""--socket=pulseaudio"" ) ) ; } if ( sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_GPU ) { if ( devices != NULL && ( g_strv_contains ( ( const char * const * ) devices , ""dri"" ) || g_strv_contains ( ( const char * const * ) devices , ""all"" ) ) ) g_ptr_array_add ( flatpak_argv , g_strdup ( ""--device=dri"" ) ) ; } if ( sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_ALLOW_DBUS ) g_ptr_array_add ( flatpak_argv , g_strdup ( ""--session-bus"" ) ) ; if ( sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_ALLOW_A11Y ) g_ptr_array_add ( flatpak_argv , g_strdup ( ""--a11y-bus"" ) ) ; } else { for ( i = 0 ; extra_args != NULL && extra_args [ i ] != NULL ; i ++ ) <S2SV_StartBug> g_ptr_array_add ( flatpak_argv , g_strdup ( extra_args [ i ] ) ) ; <S2SV_EndBug> } expose_pids = ( arg_flags & FLATPAK_SPAWN_FLAGS_EXPOSE_PIDS ) != 0 ; share_pids = ( arg_flags & FLATPAK_SPAWN_FLAGS_SHARE_PIDS ) != 0 ; if ( expose_pids || share_pids ) { g_autofree char * instance_id = NULL ; int sender_pid1 = 0 ; if ( ! ( supports & FLATPAK_SPAWN_SUPPORT_FLAGS_EXPOSE_PIDS ) ) { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_NOT_SUPPORTED , ""Expose<S2SV_blank>pids<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>with<S2SV_blank>setuid<S2SV_blank>bwrap"" ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } instance_id = g_key_file_get_string ( app_info , FLATPAK_METADATA_GROUP_INSTANCE , FLATPAK_METADATA_KEY_INSTANCE_ID , NULL ) ; if ( instance_id ) { g_autoptr ( FlatpakInstance ) instance = flatpak_instance_new_for_id ( instance_id ) ; sender_pid1 = flatpak_instance_get_child_pid ( instance ) ; } if ( sender_pid1 == 0 ) { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , ""Could<S2SV_blank>not<S2SV_blank>find<S2SV_blank>requesting<S2SV_blank>pid"" ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } g_ptr_array_add ( flatpak_argv , g_strdup_printf ( ""--parent-pid=%d"" , sender_pid1 ) ) ; if ( share_pids ) g_ptr_array_add ( flatpak_argv , g_strdup ( ""--parent-share-pids"" ) ) ; else g_ptr_array_add ( flatpak_argv , g_strdup ( ""--parent-expose-pids"" ) ) ; } notify_start = ( arg_flags & FLATPAK_SPAWN_FLAGS_NOTIFY_START ) != 0 ; if ( notify_start ) { int pipe_fds [ 2 ] ; if ( pipe ( pipe_fds ) == - 1 ) { int errsv = errno ; g_dbus_method_invocation_return_error ( invocation , G_IO_ERROR , g_io_error_from_errno ( errsv ) , ""Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>instance<S2SV_blank>ID<S2SV_blank>pipe:<S2SV_blank>%s"" , g_strerror ( errsv ) ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } GInputStream * in_stream = G_INPUT_STREAM ( g_unix_input_stream_new ( pipe_fds [ 0 ] , TRUE ) ) ; instance_id_out_stream = G_OUTPUT_STREAM ( g_unix_output_stream_new ( pipe_fds [ 1 ] , TRUE ) ) ; instance_id_read_data = g_new0 ( InstanceIdReadData , 1 ) ; g_input_stream_read_async ( in_stream , instance_id_read_data -> buffer , INSTANCE_ID_BUFFER_SIZE - 1 , G_PRIORITY_DEFAULT , NULL , instance_id_read_finish , instance_id_read_data ) ; g_ptr_array_add ( flatpak_argv , g_strdup_printf ( ""--instance-id-fd=%d"" , pipe_fds [ 1 ] ) ) ; child_setup_data . instance_id_fd = pipe_fds [ 1 ] ; } if ( devel ) g_ptr_array_add ( flatpak_argv , g_strdup ( ""--devel"" ) ) ; if ( shares != NULL && g_strv_contains ( ( const char * const * ) shares , ""network"" ) && ! ( arg_flags & FLATPAK_SPAWN_FLAGS_NO_NETWORK ) ) g_ptr_array_add ( flatpak_argv , g_strdup ( ""--share=network"" ) ) ; else g_ptr_array_add ( flatpak_argv , g_strdup ( ""--unshare=network"" ) ) ; if ( instance_path ) { for ( i = 0 ; sandbox_expose != NULL && sandbox_expose [ i ] != NULL ; i ++ ) g_ptr_array_add ( flatpak_argv , filesystem_sandbox_arg ( instance_path , sandbox_expose [ i ] , FALSE ) ) ; for ( i = 0 ; sandbox_expose_ro != NULL && sandbox_expose_ro [ i ] != NULL ; i ++ ) g_ptr_array_add ( flatpak_argv , filesystem_sandbox_arg ( instance_path , sandbox_expose_ro [ i ] , TRUE ) ) ; } for ( i = 0 ; sandbox_expose_ro != NULL && sandbox_expose_ro [ i ] != NULL ; i ++ ) { const char * expose = sandbox_expose_ro [ i ] ; g_debug ( ""exposing<S2SV_blank>%s"" , expose ) ; } if ( sandbox_expose_fd != NULL ) { gsize len = g_variant_n_children ( sandbox_expose_fd ) ; for ( i = 0 ; i < len ; i ++ ) { gint32 handle ; g_variant_get_child ( sandbox_expose_fd , i , ""h"" , & handle ) ; if ( handle >= 0 && handle < fds_len ) { int handle_fd = fds [ handle ] ; g_autofree char * path = NULL ; gboolean writable = FALSE ; path = get_path_for_fd ( handle_fd , & writable , & error ) ; if ( path ) { g_ptr_array_add ( flatpak_argv , filesystem_arg ( path , ! writable ) ) ; } else { g_debug ( ""unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>path<S2SV_blank>for<S2SV_blank>sandbox-exposed<S2SV_blank>fd<S2SV_blank>%d,<S2SV_blank>ignoring:<S2SV_blank>%s"" , handle_fd , error -> message ) ; g_clear_error ( & error ) ; } } else { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , ""No<S2SV_blank>file<S2SV_blank>descriptor<S2SV_blank>for<S2SV_blank>handle<S2SV_blank>%d"" , handle ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } } } if ( sandbox_expose_fd_ro != NULL ) { gsize len = g_variant_n_children ( sandbox_expose_fd_ro ) ; for ( i = 0 ; i < len ; i ++ ) { gint32 handle ; g_variant_get_child ( sandbox_expose_fd_ro , i , ""h"" , & handle ) ; if ( handle >= 0 && handle < fds_len ) { int handle_fd = fds [ handle ] ; g_autofree char * path = NULL ; gboolean writable = FALSE ; path = get_path_for_fd ( handle_fd , & writable , & error ) ; if ( path ) { g_ptr_array_add ( flatpak_argv , filesystem_arg ( path , TRUE ) ) ; } else { g_debug ( ""unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>path<S2SV_blank>for<S2SV_blank>sandbox-exposed<S2SV_blank>fd<S2SV_blank>%d,<S2SV_blank>ignoring:<S2SV_blank>%s"" , handle_fd , error -> message ) ; g_clear_error ( & error ) ; } } else { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , ""No<S2SV_blank>file<S2SV_blank>descriptor<S2SV_blank>for<S2SV_blank>handle<S2SV_blank>%d"" , handle ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } } } g_ptr_array_add ( flatpak_argv , g_strdup_printf ( ""--runtime=%s"" , runtime_parts [ 1 ] ) ) ; g_ptr_array_add ( flatpak_argv , g_strdup_printf ( ""--runtime-version=%s"" , runtime_parts [ 3 ] ) ) ; if ( ( arg_flags & FLATPAK_SPAWN_FLAGS_LATEST_VERSION ) == 0 ) { if ( app_commit ) g_ptr_array_add ( flatpak_argv , g_strdup_printf ( ""--commit=%s"" , app_commit ) ) ; if ( runtime_commit ) g_ptr_array_add ( flatpak_argv , g_strdup_printf ( ""--runtime-commit=%s"" , runtime_commit ) ) ; } if ( arg_cwd_path != NULL ) g_ptr_array_add ( flatpak_argv , g_strdup_printf ( ""--cwd=%s"" , arg_cwd_path ) ) ; if ( arg_argv [ 0 ] [ 0 ] != 0 ) g_ptr_array_add ( flatpak_argv , g_strdup_printf ( ""--command=%s"" , arg_argv [ 0 ] ) ) ; g_ptr_array_add ( flatpak_argv , g_strdup_printf ( ""%s/%s/%s"" , app_id , arch ? arch : """" , branch ? branch : """" ) ) ; for ( i = 1 ; arg_argv [ i ] != NULL ; i ++ ) g_ptr_array_add ( flatpak_argv , g_strdup ( arg_argv [ i ] ) ) ; g_ptr_array_add ( flatpak_argv , NULL ) ; if ( opt_verbose ) { g_autoptr ( GString ) cmd = g_string_new ( """" ) ; for ( i = 0 ; flatpak_argv -> pdata [ i ] != NULL ; i ++ ) { if ( i > 0 ) g_string_append ( cmd , ""<S2SV_blank>"" ) ; g_string_append ( cmd , flatpak_argv -> pdata [ i ] ) ; } g_debug ( ""Starting:<S2SV_blank>%s\\n"" , cmd -> str ) ; } if ( ! g_spawn_async_with_pipes ( NULL , ( char * * ) flatpak_argv -> pdata , env , G_SPAWN_SEARCH_PATH | G_SPAWN_DO_NOT_REAP_CHILD | G_SPAWN_LEAVE_DESCRIPTORS_OPEN , child_setup_func , & child_setup_data , & pid , NULL , NULL , NULL , & error ) ) { gint code = G_DBUS_ERROR_FAILED ; if ( g_error_matches ( error , G_SPAWN_ERROR , G_SPAWN_ERROR_ACCES ) ) code = G_DBUS_ERROR_ACCESS_DENIED ; else if ( g_error_matches ( error , G_SPAWN_ERROR , G_SPAWN_ERROR_NOENT ) ) code = G_DBUS_ERROR_FILE_NOT_FOUND ; g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , code , ""Failed<S2SV_blank>to<S2SV_blank>start<S2SV_blank>command:<S2SV_blank>%s"" , error -> message ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } if ( instance_id_read_data ) instance_id_read_data -> pid = pid ; pid_data = g_new0 ( PidData , 1 ) ; pid_data -> pid = pid ; pid_data -> client = g_strdup ( g_dbus_method_invocation_get_sender ( invocation ) ) ; pid_data -> watch_bus = ( arg_flags & FLATPAK_SPAWN_FLAGS_WATCH_BUS ) != 0 ; pid_data -> expose_or_share_pids = ( expose_pids || share_pids ) ; pid_data -> child_watch = g_child_watch_add_full ( G_PRIORITY_DEFAULT , pid , child_watch_died , pid_data , NULL ) ; g_debug ( ""Client<S2SV_blank>Pid<S2SV_blank>is<S2SV_blank>%d"" , pid_data -> pid ) ; g_hash_table_replace ( client_pid_data_hash , GUINT_TO_POINTER ( pid_data -> pid ) , pid_data ) ; portal_flatpak_complete_spawn ( object , invocation , NULL , pid ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; }
","<S2SV_ModStart> ; gboolean devel ; g_autoptr ( GString ) env_string = g_string_new ( """" ) <S2SV_ModStart> child_setup_data . instance_id_fd = - 1 ; child_setup_data . env_fd <S2SV_ModStart> i ++ ) { if ( g_str_has_prefix ( extra_args [ i ] , ""--env="" ) ) { const char * var_val = extra_args [ i ] + strlen ( ""--env="" ) ; if ( var_val [ 0 ] == '\\0' || var_val [ 0 ] == '=' ) { g_warning ( ""Environment<S2SV_blank>variable<S2SV_blank>in<S2SV_blank>extra-args<S2SV_blank>has<S2SV_blank>empty<S2SV_blank>name"" ) ; continue ; } if ( strchr ( var_val , '=' ) == NULL ) { g_warning ( ""Environment<S2SV_blank>variable<S2SV_blank>in<S2SV_blank>extra-args<S2SV_blank>has<S2SV_blank>no<S2SV_blank>value"" ) ; continue ; } g_string_append ( env_string , var_val ) ; g_string_append_c ( env_string , '\\0' ) ; } else { <S2SV_ModStart> [ i ] ) ) ; } } } if ( env_string -> len > 0 ) { g_auto ( GLnxTmpfile ) env_tmpf = { 0 , } ; if ( ! flatpak_buffer_to_sealed_memfd_or_tmpfile ( & env_tmpf , ""environ"" , env_string -> str , env_string -> len , & error ) ) { g_dbus_method_invocation_return_gerror ( invocation , error ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } child_setup_data . env_fd = glnx_steal_fd ( & env_tmpf . fd ) ; g_ptr_array_add ( flatpak_argv , g_strdup_printf ( ""--env-fd=%d"" , child_setup_data . env_fd
"
1152,"CWE-000 static int ghash_update ( struct shash_desc * desc , const u8 * src , unsigned int srclen ) { struct ghash_desc_ctx * dctx = shash_desc_ctx ( desc ) ; struct ghash_ctx * ctx = crypto_shash_ctx ( desc -> tfm ) ; u8 * dst = dctx -> buffer ; <S2SV_StartBug> if ( dctx -> bytes ) { <S2SV_EndBug> int n = min ( srclen , dctx -> bytes ) ; u8 * pos = dst + ( GHASH_BLOCK_SIZE - dctx -> bytes ) ; dctx -> bytes -= n ; srclen -= n ; while ( n -- ) * pos ++ ^= * src ++ ; if ( ! dctx -> bytes ) gf128mul_4k_lle ( ( be128 * ) dst , ctx -> gf128 ) ; } while ( srclen >= GHASH_BLOCK_SIZE ) { crypto_xor ( dst , src , GHASH_BLOCK_SIZE ) ; gf128mul_4k_lle ( ( be128 * ) dst , ctx -> gf128 ) ; src += GHASH_BLOCK_SIZE ; srclen -= GHASH_BLOCK_SIZE ; } if ( srclen ) { dctx -> bytes = GHASH_BLOCK_SIZE - srclen ; while ( srclen -- ) * dst ++ ^= * src ++ ; } return 0 ; }
","<S2SV_ModStart> ; if ( ! ctx -> gf128 ) return - ENOKEY ; if (
"
1153,"CWE-190 void * <S2SV_StartBug> checked_xmalloc ( size_t size ) <S2SV_EndBug> { <S2SV_StartBug> alloc_limit_assert ( ""checked_xmalloc"" , size ) ; <S2SV_EndBug> <S2SV_StartBug> return xmalloc ( size ) ; <S2SV_EndBug> }
","<S2SV_ModStart> checked_xmalloc ( size_t num , size_t <S2SV_ModStart> size ) { size_t res ; if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ; <S2SV_ModStart> ( ""checked_xmalloc"" , res <S2SV_ModEnd> ) ; return <S2SV_ModStart> return xmalloc ( num ,
"
1154,"CWE-119 <S2SV_StartBug> static void send ( node_t * node , node_t * child , byte * fout ) { <S2SV_EndBug> if ( node -> parent ) { <S2SV_StartBug> send ( node -> parent , node , fout ) ; <S2SV_EndBug> } <S2SV_StartBug> if ( child ) { <S2SV_EndBug> if ( node -> right == child ) { add_bit ( 1 , fout ) ; } else { add_bit ( 0 , fout ) ; } } }
","<S2SV_ModStart> byte * fout , int maxoffset <S2SV_ModStart> node , fout , maxoffset <S2SV_ModStart> child ) { if ( bloc >= maxoffset ) { bloc = maxoffset + 1 ; return ; }
"
1155,"CWE-000 static Image * handle_add_command ( GraphicsManager * self , const GraphicsCommand * g , const uint8_t * payload , bool * is_dirty , uint32_t iid ) { # define ABRT ( code , ... ) { set_add_response ( # code , __VA_ARGS__ ) ; self -> loading_image = 0 ; if ( img ) img -> data_loaded = false ; return NULL ; } # define MAX_DATA_SZ ( 4u * 100000000u ) has_add_respose = false ; bool existing , init_img = true ; Image * img = NULL ; unsigned char tt = g -> transmission_type ? g -> transmission_type : 'd' ; enum FORMATS { RGB = 24 , RGBA = 32 , PNG = 100 } ; uint32_t fmt = g -> format ? g -> format : RGBA ; if ( tt == 'd' && self -> loading_image ) init_img = false ; if ( init_img ) { self -> last_init_graphics_command = * g ; self -> last_init_graphics_command . id = iid ; self -> loading_image = 0 ; if ( g -> data_width > 10000 || g -> data_height > 10000 ) ABRT ( EINVAL , ""Image<S2SV_blank>too<S2SV_blank>large"" ) ; remove_images ( self , add_trim_predicate , 0 ) ; img = find_or_create_image ( self , iid , & existing ) ; if ( existing ) { free_load_data ( & img -> load_data ) ; img -> data_loaded = false ; free_refs_data ( img ) ; * is_dirty = true ; self -> layers_dirty = true ; } else { img -> internal_id = internal_id_counter ++ ; img -> client_id = iid ; } img -> atime = monotonic ( ) ; img -> used_storage = 0 ; img -> width = g -> data_width ; img -> height = g -> data_height ; switch ( fmt ) { case PNG : if ( g -> data_sz > MAX_DATA_SZ ) ABRT ( EINVAL , ""PNG<S2SV_blank>data<S2SV_blank>size<S2SV_blank>too<S2SV_blank>large"" ) ; img -> load_data . is_4byte_aligned = true ; img -> load_data . is_opaque = false ; img -> load_data . data_sz = g -> data_sz ? g -> data_sz : 1024 * 100 ; break ; case RGB : case RGBA : img -> load_data . data_sz = ( size_t ) g -> data_width * g -> data_height * ( fmt / 8 ) ; if ( ! img -> load_data . data_sz ) ABRT ( EINVAL , ""Zero<S2SV_blank>width/height<S2SV_blank>not<S2SV_blank>allowed"" ) ; img -> load_data . is_4byte_aligned = fmt == RGBA || ( img -> width % 4 == 0 ) ; img -> load_data . is_opaque = fmt == RGB ; break ; default : ABRT ( EINVAL , ""Unknown<S2SV_blank>image<S2SV_blank>format:<S2SV_blank>%u"" , fmt ) ; } if ( tt == 'd' ) { if ( g -> more ) self -> loading_image = img -> internal_id ; img -> load_data . buf_capacity = img -> load_data . data_sz + ( g -> compressed ? 1024 : 10 ) ; img -> load_data . buf = malloc ( img -> load_data . buf_capacity ) ; img -> load_data . buf_used = 0 ; if ( img -> load_data . buf == NULL ) { ABRT ( ENOMEM , ""Out<S2SV_blank>of<S2SV_blank>memory"" ) ; img -> load_data . buf_capacity = 0 ; img -> load_data . buf_used = 0 ; } } } else { self -> last_init_graphics_command . more = g -> more ; self -> last_init_graphics_command . payload_sz = g -> payload_sz ; g = & self -> last_init_graphics_command ; tt = g -> transmission_type ? g -> transmission_type : 'd' ; fmt = g -> format ? g -> format : RGBA ; img = img_by_internal_id ( self , self -> loading_image ) ; if ( img == NULL ) { self -> loading_image = 0 ; ABRT ( EILSEQ , ""More<S2SV_blank>payload<S2SV_blank>loading<S2SV_blank>refers<S2SV_blank>to<S2SV_blank>non-existent<S2SV_blank>image"" ) ; } } int fd ; static char fname [ 2056 ] = { 0 } ; switch ( tt ) { case 'd' : if ( img -> load_data . buf_capacity - img -> load_data . buf_used < g -> payload_sz ) { if ( img -> load_data . buf_used + g -> payload_sz > MAX_DATA_SZ || fmt != PNG ) ABRT ( EFBIG , ""Too<S2SV_blank>much<S2SV_blank>data"" ) ; img -> load_data . buf_capacity = MIN ( 2 * img -> load_data . buf_capacity , MAX_DATA_SZ ) ; img -> load_data . buf = realloc ( img -> load_data . buf , img -> load_data . buf_capacity ) ; if ( img -> load_data . buf == NULL ) { ABRT ( ENOMEM , ""Out<S2SV_blank>of<S2SV_blank>memory"" ) ; img -> load_data . buf_capacity = 0 ; img -> load_data . buf_used = 0 ; } } memcpy ( img -> load_data . buf + img -> load_data . buf_used , payload , g -> payload_sz ) ; img -> load_data . buf_used += g -> payload_sz ; if ( ! g -> more ) { img -> data_loaded = true ; self -> loading_image = 0 ; } break ; case 'f' : case 't' : case 's' : if ( g -> payload_sz > 2048 ) ABRT ( EINVAL , ""Filename<S2SV_blank>too<S2SV_blank>long"" ) ; snprintf ( fname , sizeof ( fname ) / sizeof ( fname [ 0 ] ) , ""%.*s"" , ( int ) g -> payload_sz , payload ) ; if ( tt == 's' ) fd = shm_open ( fname , O_RDONLY , 0 ) ; else fd = open ( fname , O_CLOEXEC | O_RDONLY ) ; <S2SV_StartBug> if ( fd == - 1 ) ABRT ( EBADF , ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>graphics<S2SV_blank>transmission<S2SV_blank>with<S2SV_blank>error:<S2SV_blank>[%d]<S2SV_blank>%s"" , fname , errno , strerror ( errno ) ) ; <S2SV_EndBug> img -> data_loaded = mmap_img_file ( self , img , fd , g -> data_sz , g -> data_offset ) ; safe_close ( fd , __FILE__ , __LINE__ ) ; if ( tt == 't' ) { if ( global_state . boss ) { call_boss ( safe_delete_temp_file , ""s"" , fname ) ; } else unlink ( fname ) ; } else if ( tt == 's' ) shm_unlink ( fname ) ; break ; default : ABRT ( EINVAL , ""Unknown<S2SV_blank>transmission<S2SV_blank>type:<S2SV_blank>%c"" , g -> transmission_type ) ; } if ( ! img -> data_loaded ) return NULL ; self -> loading_image = 0 ; bool needs_processing = g -> compressed || fmt == PNG ; if ( needs_processing ) { uint8_t * buf ; size_t bufsz ; # define IB { if ( img -> load_data . buf ) { buf = img -> load_data . buf ; bufsz = img -> load_data . buf_used ; } else { buf = img -> load_data . mapped_file ; bufsz = img -> load_data . mapped_file_sz ; } } switch ( g -> compressed ) { case 'z' : IB ; if ( ! inflate_zlib ( self , img , buf , bufsz ) ) { img -> data_loaded = false ; return NULL ; } break ; case 0 : break ; default : ABRT ( EINVAL , ""Unknown<S2SV_blank>image<S2SV_blank>compression:<S2SV_blank>%c"" , g -> compressed ) ; } switch ( fmt ) { case PNG : IB ; if ( ! inflate_png ( self , img , buf , bufsz ) ) { img -> data_loaded = false ; return NULL ; } break ; default : break ; } # undef IB img -> load_data . data = img -> load_data . buf ; if ( img -> load_data . buf_used < img -> load_data . data_sz ) { ABRT ( ENODATA , ""Insufficient<S2SV_blank>image<S2SV_blank>data:<S2SV_blank>%zu<S2SV_blank><<S2SV_blank>%zu"" , img -> load_data . buf_used , img -> load_data . data_sz ) ; } if ( img -> load_data . mapped_file ) { munmap ( img -> load_data . mapped_file , img -> load_data . mapped_file_sz ) ; img -> load_data . mapped_file = NULL ; img -> load_data . mapped_file_sz = 0 ; } } else { if ( tt == 'd' ) { if ( img -> load_data . buf_used < img -> load_data . data_sz ) { ABRT ( ENODATA , ""Insufficient<S2SV_blank>image<S2SV_blank>data:<S2SV_blank>%zu<S2SV_blank><<S2SV_blank>%zu"" , img -> load_data . buf_used , img -> load_data . data_sz ) ; } else img -> load_data . data = img -> load_data . buf ; } else { if ( img -> load_data . mapped_file_sz < img -> load_data . data_sz ) { ABRT ( ENODATA , ""Insufficient<S2SV_blank>image<S2SV_blank>data:<S2SV_blank>%zu<S2SV_blank><<S2SV_blank>%zu"" , img -> load_data . mapped_file_sz , img -> load_data . data_sz ) ; } else img -> load_data . data = img -> load_data . mapped_file ; } } size_t required_sz = ( size_t ) ( img -> load_data . is_opaque ? 3 : 4 ) * img -> width * img -> height ; if ( img -> load_data . data_sz != required_sz ) ABRT ( EINVAL , ""Image<S2SV_blank>dimensions:<S2SV_blank>%ux%u<S2SV_blank>do<S2SV_blank>not<S2SV_blank>match<S2SV_blank>data<S2SV_blank>size:<S2SV_blank>%zu,<S2SV_blank>expected<S2SV_blank>size:<S2SV_blank>%zu"" , img -> width , img -> height , img -> load_data . data_sz , required_sz ) ; if ( LIKELY ( img -> data_loaded && send_to_gpu ) ) { send_image_to_gpu ( & img -> texture_id , img -> load_data . data , img -> width , img -> height , img -> load_data . is_opaque , img -> load_data . is_4byte_aligned , false , REPEAT_CLAMP ) ; free_load_data ( & img -> load_data ) ; self -> used_storage += required_sz ; img -> used_storage = required_sz ; } return img ; # undef MAX_DATA_SZ # undef ABRT }
","<S2SV_ModStart> ( EBADF , ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>file<S2SV_blank>for<S2SV_blank>graphics<S2SV_blank>transmission<S2SV_blank>with<S2SV_blank>error:<S2SV_blank>[%d]<S2SV_blank>%s"" <S2SV_ModEnd> , errno ,
"
1156,"CWE-20 static void unix_copy_addr ( struct msghdr * msg , struct sock * sk ) { <S2SV_StartBug> struct unix_sock * u = unix_sk ( sk ) ; <S2SV_EndBug> msg -> msg_namelen = 0 ; if ( u -> addr ) { msg -> msg_namelen = u -> addr -> len ; memcpy ( msg -> msg_name , u -> addr -> name , u -> addr -> len ) ; } }
","<S2SV_ModStart> ( sk ) <S2SV_ModEnd> ; if (
"
1157,"CWE-200 static ssize_t snd_timer_user_read ( struct file * file , char __user * buffer , size_t count , loff_t * offset ) { struct snd_timer_user * tu ; long result = 0 , unit ; int qhead ; int err = 0 ; tu = file -> private_data ; unit = tu -> tread ? sizeof ( struct snd_timer_tread ) : sizeof ( struct snd_timer_read ) ; <S2SV_StartBug> spin_lock_irq ( & tu -> qlock ) ; <S2SV_EndBug> while ( ( long ) count - result >= unit ) { while ( ! tu -> qused ) { wait_queue_t wait ; if ( ( file -> f_flags & O_NONBLOCK ) != 0 || result > 0 ) { err = - EAGAIN ; goto _error ; } set_current_state ( TASK_INTERRUPTIBLE ) ; init_waitqueue_entry ( & wait , current ) ; add_wait_queue ( & tu -> qchange_sleep , & wait ) ; spin_unlock_irq ( & tu -> qlock ) ; <S2SV_StartBug> schedule ( ) ; <S2SV_EndBug> spin_lock_irq ( & tu -> qlock ) ; remove_wait_queue ( & tu -> qchange_sleep , & wait ) ; if ( tu -> disconnected ) { err = - ENODEV ; goto _error ; } if ( signal_pending ( current ) ) { err = - ERESTARTSYS ; goto _error ; } } qhead = tu -> qhead ++ ; tu -> qhead %= tu -> queue_size ; tu -> qused -- ; spin_unlock_irq ( & tu -> qlock ) ; <S2SV_StartBug> mutex_lock ( & tu -> ioctl_lock ) ; <S2SV_EndBug> if ( tu -> tread ) { if ( copy_to_user ( buffer , & tu -> tqueue [ qhead ] , sizeof ( struct snd_timer_tread ) ) ) err = - EFAULT ; } else { if ( copy_to_user ( buffer , & tu -> queue [ qhead ] , sizeof ( struct snd_timer_read ) ) ) err = - EFAULT ; } <S2SV_StartBug> mutex_unlock ( & tu -> ioctl_lock ) ; <S2SV_EndBug> spin_lock_irq ( & tu -> qlock ) ; if ( err < 0 ) goto _error ; result += unit ; buffer += unit ; } _error : spin_unlock_irq ( & tu -> qlock ) ; <S2SV_StartBug> return result > 0 ? result : err ; <S2SV_EndBug> }
","<S2SV_ModStart> snd_timer_read ) ; mutex_lock ( & tu -> ioctl_lock ) ; <S2SV_ModStart> qlock ) ; mutex_unlock ( & tu -> ioctl_lock ) ; schedule ( ) ; mutex_lock ( & tu -> ioctl_lock <S2SV_ModEnd> ) ; spin_lock_irq <S2SV_ModStart> qlock ) ; <S2SV_ModEnd> if ( tu <S2SV_ModStart> EFAULT ; } <S2SV_ModEnd> spin_lock_irq ( & <S2SV_ModStart> qlock ) ; mutex_unlock ( & tu -> ioctl_lock ) ;
"
1158,"CWE-476 int build_segment_manager ( struct f2fs_sb_info * sbi ) { struct f2fs_super_block * raw_super = F2FS_RAW_SUPER ( sbi ) ; struct f2fs_checkpoint * ckpt = F2FS_CKPT ( sbi ) ; struct f2fs_sm_info * sm_info ; int err ; sm_info = kzalloc ( sizeof ( struct f2fs_sm_info ) , GFP_KERNEL ) ; if ( ! sm_info ) return - ENOMEM ; sbi -> sm_info = sm_info ; sm_info -> seg0_blkaddr = le32_to_cpu ( raw_super -> segment0_blkaddr ) ; sm_info -> main_blkaddr = le32_to_cpu ( raw_super -> main_blkaddr ) ; sm_info -> segment_count = le32_to_cpu ( raw_super -> segment_count ) ; sm_info -> reserved_segments = le32_to_cpu ( ckpt -> rsvd_segment_count ) ; sm_info -> ovp_segments = le32_to_cpu ( ckpt -> overprov_segment_count ) ; sm_info -> main_segments = le32_to_cpu ( raw_super -> segment_count_main ) ; sm_info -> ssa_blkaddr = le32_to_cpu ( raw_super -> ssa_blkaddr ) ; sm_info -> rec_prefree_segments = sm_info -> main_segments * DEF_RECLAIM_PREFREE_SEGMENTS / 100 ; if ( sm_info -> rec_prefree_segments > DEF_MAX_RECLAIM_PREFREE_SEGMENTS ) sm_info -> rec_prefree_segments = DEF_MAX_RECLAIM_PREFREE_SEGMENTS ; if ( ! test_opt ( sbi , LFS ) ) sm_info -> ipu_policy = 1 << F2FS_IPU_FSYNC ; sm_info -> min_ipu_util = DEF_MIN_IPU_UTIL ; sm_info -> min_fsync_blocks = DEF_MIN_FSYNC_BLOCKS ; sm_info -> min_hot_blocks = DEF_MIN_HOT_BLOCKS ; sm_info -> trim_sections = DEF_BATCHED_TRIM_SECTIONS ; INIT_LIST_HEAD ( & sm_info -> sit_entry_set ) ; <S2SV_StartBug> if ( test_opt ( sbi , FLUSH_MERGE ) && ! f2fs_readonly ( sbi -> sb ) ) { <S2SV_EndBug> err = create_flush_cmd_control ( sbi ) ; if ( err ) return err ; } err = create_discard_cmd_control ( sbi ) ; if ( err ) return err ; err = build_sit_info ( sbi ) ; if ( err ) return err ; err = build_free_segmap ( sbi ) ; if ( err ) return err ; err = build_curseg ( sbi ) ; if ( err ) return err ; build_sit_entries ( sbi ) ; init_free_segmap ( sbi ) ; err = build_dirty_segmap ( sbi ) ; if ( err ) return err ; init_min_max_mtime ( sbi ) ; return 0 ; }
","<S2SV_ModStart> ; if ( <S2SV_ModEnd> ! f2fs_readonly (
"
1159,"CWE-20 int wait_for_key_construction ( struct key * key , bool intr ) { int ret ; ret = wait_on_bit ( & key -> flags , KEY_FLAG_USER_CONSTRUCT , intr ? TASK_INTERRUPTIBLE : TASK_UNINTERRUPTIBLE ) ; if ( ret ) return - ERESTARTSYS ; <S2SV_StartBug> if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) { <S2SV_EndBug> smp_rmb ( ) ; return key -> reject_error ; } return key_validate ( key ) ; }
","<S2SV_ModStart> - ERESTARTSYS ; ret = key_read_state ( key ) ; if ( ret < 0 ) return ret ; <S2SV_ModEnd> return key_validate (
"
1160,"CWE-59 rpmVerifyAttrs rpmfilesVerify ( rpmfiles fi , int ix , rpmVerifyAttrs omitMask ) { rpm_mode_t fmode = rpmfilesFMode ( fi , ix ) ; rpmfileAttrs fileAttrs = rpmfilesFFlags ( fi , ix ) ; rpmVerifyAttrs flags = rpmfilesVFlags ( fi , ix ) ; const char * fn = rpmfilesFN ( fi , ix ) ; struct stat sb ; rpmVerifyAttrs vfy = RPMVERIFY_NONE ; switch ( rpmfilesFState ( fi , ix ) ) { case RPMFILE_STATE_NETSHARED : case RPMFILE_STATE_NOTINSTALLED : goto exit ; break ; case RPMFILE_STATE_REPLACED : flags = RPMVERIFY_LSTATFAIL ; break ; case RPMFILE_STATE_WRONGCOLOR : flags &= ~ ( RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE | RPMVERIFY_MTIME | RPMVERIFY_RDEV ) ; break ; case RPMFILE_STATE_NORMAL : case RPMFILE_STATE_MISSING : break ; } if ( fn == NULL || lstat ( fn , & sb ) != 0 ) { vfy |= RPMVERIFY_LSTATFAIL ; goto exit ; } <S2SV_StartBug> if ( S_ISDIR ( fmode ) && S_ISLNK ( sb . st_mode ) && stat ( fn , & sb ) != 0 ) { <S2SV_EndBug> vfy |= RPMVERIFY_LSTATFAIL ; goto exit ; } if ( S_ISLNK ( sb . st_mode ) ) flags &= ~ ( RPMVERIFY_MODE ) ; else flags &= ~ ( RPMVERIFY_LINKTO ) ; if ( ! S_ISREG ( sb . st_mode ) ) flags &= ~ ( RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE | RPMVERIFY_MTIME | RPMVERIFY_CAPS ) ; if ( fileAttrs & RPMFILE_GHOST ) flags &= ~ ( RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE | RPMVERIFY_MTIME | RPMVERIFY_LINKTO ) ; flags &= ~ ( omitMask | RPMVERIFY_FAILURES ) ; if ( flags & RPMVERIFY_FILEDIGEST ) { const unsigned char * digest ; int algo ; size_t diglen ; if ( ( digest = rpmfilesFDigest ( fi , ix , & algo , & diglen ) ) ) { unsigned char fdigest [ diglen ] ; rpm_loff_t fsize ; if ( rpmDoDigest ( algo , fn , 0 , fdigest , & fsize ) ) { vfy |= ( RPMVERIFY_READFAIL | RPMVERIFY_FILEDIGEST ) ; } else { sb . st_size = fsize ; if ( memcmp ( fdigest , digest , diglen ) ) vfy |= RPMVERIFY_FILEDIGEST ; } } else { vfy |= RPMVERIFY_FILEDIGEST ; } } if ( flags & RPMVERIFY_LINKTO ) { char linkto [ 1024 + 1 ] ; int size = 0 ; if ( ( size = readlink ( fn , linkto , sizeof ( linkto ) - 1 ) ) == - 1 ) vfy |= ( RPMVERIFY_READLINKFAIL | RPMVERIFY_LINKTO ) ; else { const char * flink = rpmfilesFLink ( fi , ix ) ; linkto [ size ] = '\\0' ; if ( flink == NULL || ! rstreq ( linkto , flink ) ) vfy |= RPMVERIFY_LINKTO ; } } if ( flags & RPMVERIFY_FILESIZE ) { if ( sb . st_size != rpmfilesFSize ( fi , ix ) ) vfy |= RPMVERIFY_FILESIZE ; } if ( flags & RPMVERIFY_MODE ) { rpm_mode_t metamode = fmode ; rpm_mode_t filemode ; filemode = ( rpm_mode_t ) sb . st_mode ; if ( fileAttrs & RPMFILE_GHOST ) { metamode &= ~ 0xf000 ; filemode &= ~ 0xf000 ; } if ( metamode != filemode ) vfy |= RPMVERIFY_MODE ; # if WITH_ACL acl_t facl = acl_get_file ( fn , ACL_TYPE_ACCESS ) ; if ( facl ) { if ( acl_equiv_mode ( facl , NULL ) == 1 ) { vfy |= RPMVERIFY_MODE ; } acl_free ( facl ) ; } # endif } if ( flags & RPMVERIFY_RDEV ) { if ( S_ISCHR ( fmode ) != S_ISCHR ( sb . st_mode ) || S_ISBLK ( fmode ) != S_ISBLK ( sb . st_mode ) ) { vfy |= RPMVERIFY_RDEV ; } else if ( S_ISDEV ( fmode ) && S_ISDEV ( sb . st_mode ) ) { rpm_rdev_t st_rdev = ( sb . st_rdev & 0xffff ) ; rpm_rdev_t frdev = ( rpmfilesFRdev ( fi , ix ) & 0xffff ) ; if ( st_rdev != frdev ) vfy |= RPMVERIFY_RDEV ; } } # if WITH_CAP if ( flags & RPMVERIFY_CAPS ) { cap_t cap , fcap ; cap = cap_from_text ( rpmfilesFCaps ( fi , ix ) ) ; if ( ! cap ) { cap = cap_from_text ( ""="" ) ; } fcap = cap_get_file ( fn ) ; if ( ! fcap ) { fcap = cap_from_text ( ""="" ) ; } if ( cap_compare ( cap , fcap ) != 0 ) vfy |= RPMVERIFY_CAPS ; cap_free ( fcap ) ; cap_free ( cap ) ; } # endif if ( ( flags & RPMVERIFY_MTIME ) && ( sb . st_mtime != rpmfilesFMtime ( fi , ix ) ) ) { vfy |= RPMVERIFY_MTIME ; } if ( flags & RPMVERIFY_USER ) { const char * name = rpmugUname ( sb . st_uid ) ; const char * fuser = rpmfilesFUser ( fi , ix ) ; uid_t uid ; int namematch = 0 ; int idmatch = 0 ; if ( name && fuser ) namematch = rstreq ( name , fuser ) ; if ( fuser && rpmugUid ( fuser , & uid ) == 0 ) idmatch = ( uid == sb . st_uid ) ; if ( namematch != idmatch ) { rpmlog ( RPMLOG_WARNING , _ ( ""Duplicate<S2SV_blank>username<S2SV_blank>or<S2SV_blank>UID<S2SV_blank>for<S2SV_blank>user<S2SV_blank>%s\\n"" ) , fuser ) ; } if ( ! ( namematch || idmatch ) ) vfy |= RPMVERIFY_USER ; } if ( flags & RPMVERIFY_GROUP ) { const char * name = rpmugGname ( sb . st_gid ) ; const char * fgroup = rpmfilesFGroup ( fi , ix ) ; gid_t gid ; int namematch = 0 ; int idmatch = 0 ; if ( name && fgroup ) namematch = rstreq ( name , fgroup ) ; if ( fgroup && rpmugGid ( fgroup , & gid ) == 0 ) idmatch = ( gid == sb . st_gid ) ; if ( namematch != idmatch ) { rpmlog ( RPMLOG_WARNING , _ ( ""Duplicate<S2SV_blank>groupname<S2SV_blank>or<S2SV_blank>GID<S2SV_blank>for<S2SV_blank>group<S2SV_blank>%s\\n"" ) , fgroup ) ; } if ( ! ( namematch || idmatch ) ) vfy |= RPMVERIFY_GROUP ; } exit : return vfy ; }
","<S2SV_ModStart> . st_mode ) ) { struct stat dsb ; if ( stat ( fn , & dsb ) == 0 && S_ISDIR ( dsb . st_mode ) ) { uid_t fuid ; if ( sb . st_uid == 0 || ( rpmugUid ( rpmfilesFUser ( fi , ix ) , & fuid ) == 0 && sb . st_uid == fuid ) ) { sb = dsb ; } } <S2SV_ModEnd> } if (
"
1161,"CWE-19 int __sys_recvmmsg ( int fd , struct mmsghdr __user * mmsg , unsigned int vlen , unsigned int flags , struct timespec * timeout ) { int fput_needed , err , datagrams ; struct socket * sock ; struct mmsghdr __user * entry ; struct compat_mmsghdr __user * compat_entry ; struct msghdr msg_sys ; struct timespec end_time ; if ( timeout && poll_select_set_timeout ( & end_time , timeout -> tv_sec , timeout -> tv_nsec ) ) return - EINVAL ; datagrams = 0 ; sock = sockfd_lookup_light ( fd , & err , & fput_needed ) ; if ( ! sock ) return err ; err = sock_error ( sock -> sk ) ; if ( err ) goto out_put ; entry = mmsg ; compat_entry = ( struct compat_mmsghdr __user * ) mmsg ; while ( datagrams < vlen ) { if ( MSG_CMSG_COMPAT & flags ) { err = ___sys_recvmsg ( sock , ( struct user_msghdr __user * ) compat_entry , & msg_sys , flags & ~ MSG_WAITFORONE , datagrams ) ; if ( err < 0 ) break ; err = __put_user ( err , & compat_entry -> msg_len ) ; ++ compat_entry ; } else { err = ___sys_recvmsg ( sock , ( struct user_msghdr __user * ) entry , & msg_sys , flags & ~ MSG_WAITFORONE , datagrams ) ; if ( err < 0 ) break ; err = put_user ( err , & entry -> msg_len ) ; ++ entry ; } if ( err ) break ; ++ datagrams ; if ( flags & MSG_WAITFORONE ) flags |= MSG_DONTWAIT ; if ( timeout ) { ktime_get_ts ( timeout ) ; * timeout = timespec_sub ( end_time , * timeout ) ; if ( timeout -> tv_sec < 0 ) { timeout -> tv_sec = timeout -> tv_nsec = 0 ; break ; } if ( timeout -> tv_nsec == 0 && timeout -> tv_sec == 0 ) break ; } if ( msg_sys . msg_flags & MSG_OOB ) break ; cond_resched ( ) ; } <S2SV_StartBug> out_put : <S2SV_EndBug> fput_light ( sock -> file , fput_needed ) ; if ( err == 0 ) <S2SV_StartBug> return datagrams ; <S2SV_EndBug> if ( datagrams != 0 ) { if ( err != - EAGAIN ) { sock -> sk -> sk_err = - err ; } <S2SV_StartBug> return datagrams ; <S2SV_EndBug> } <S2SV_StartBug> return err ; <S2SV_EndBug> }
","<S2SV_ModStart> ) ; } if ( err == 0 ) goto out_put ; if ( datagrams <S2SV_ModEnd> == 0 ) <S2SV_ModStart> == 0 ) { datagrams = err ; goto out_put ; } <S2SV_ModEnd> if ( err <S2SV_ModStart> err ; } out_put : fput_light ( sock -> file , fput_needed ) ; <S2SV_ModStart> datagrams ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
"
1162,"CWE-119 static void copy_and_extend_plane ( unsigned char * s , int sp , unsigned char * d , int dp , int h , int w , int et , int el , int eb , int er ) { int i ; unsigned char * src_ptr1 , * src_ptr2 ; unsigned char * dest_ptr1 , * dest_ptr2 ; int linesize ; src_ptr1 = s ; src_ptr2 = s + w - 1 ; dest_ptr1 = d - el ; dest_ptr2 = d + w ; for ( i = 0 ; i < h ; i ++ ) { <S2SV_StartBug> vpx_memset ( dest_ptr1 , src_ptr1 [ 0 ] , el ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( dest_ptr1 + el , src_ptr1 , w ) ; <S2SV_EndBug> vpx_memset ( dest_ptr2 , src_ptr2 [ 0 ] , er ) ; src_ptr1 += sp ; src_ptr2 += sp ; dest_ptr1 += dp ; dest_ptr2 += dp ; } src_ptr1 = d - el ; src_ptr2 = d + dp * ( h - 1 ) - el ; dest_ptr1 = d + dp * ( - et ) - el ; dest_ptr2 = d + dp * ( h ) - el ; linesize = el + er + w ; for ( i = 0 ; i < et ; i ++ ) { <S2SV_StartBug> vpx_memcpy ( dest_ptr1 , src_ptr1 , linesize ) ; <S2SV_EndBug> dest_ptr1 += dp ; } for ( i = 0 ; i < eb ; i ++ ) { <S2SV_StartBug> vpx_memcpy ( dest_ptr2 , src_ptr2 , linesize ) ; <S2SV_EndBug> dest_ptr2 += dp ; } }
","<S2SV_ModStart> ++ ) { memset <S2SV_ModEnd> ( dest_ptr1 , <S2SV_ModStart> el ) ; memcpy ( dest_ptr1 + el , src_ptr1 , w ) ; memset <S2SV_ModEnd> ( dest_ptr2 , <S2SV_ModStart> ++ ) { memcpy <S2SV_ModEnd> ( dest_ptr1 , <S2SV_ModStart> ++ ) { memcpy <S2SV_ModEnd> ( dest_ptr2 ,
"
1163,"CWE-119 int ff_combine_frame ( ParseContext * pc , int next , const uint8_t * * buf , int * buf_size ) { if ( pc -> overread ) { av_dlog ( NULL , ""overread<S2SV_blank>%d,<S2SV_blank>state:%X<S2SV_blank>next:%d<S2SV_blank>index:%d<S2SV_blank>o_index:%d\\n"" , pc -> overread , pc -> state , next , pc -> index , pc -> overread_index ) ; av_dlog ( NULL , ""%X<S2SV_blank>%X<S2SV_blank>%X<S2SV_blank>%X\\n"" , ( * buf ) [ 0 ] , ( * buf ) [ 1 ] , ( * buf ) [ 2 ] , ( * buf ) [ 3 ] ) ; } for ( ; pc -> overread > 0 ; pc -> overread -- ) { pc -> buffer [ pc -> index ++ ] = pc -> buffer [ pc -> overread_index ++ ] ; } if ( ! * buf_size && next == END_NOT_FOUND ) { next = 0 ; } pc -> last_index = pc -> index ; if ( next == END_NOT_FOUND ) { void * new_buffer = av_fast_realloc ( pc -> buffer , & pc -> buffer_size , ( * buf_size ) + pc -> index + FF_INPUT_BUFFER_PADDING_SIZE ) ; <S2SV_StartBug> if ( ! new_buffer ) <S2SV_EndBug> <S2SV_StartBug> return AVERROR ( ENOMEM ) ; <S2SV_EndBug> pc -> buffer = new_buffer ; memcpy ( & pc -> buffer [ pc -> index ] , * buf , * buf_size ) ; pc -> index += * buf_size ; return - 1 ; } * buf_size = pc -> overread_index = pc -> index + next ; if ( pc -> index ) { void * new_buffer = av_fast_realloc ( pc -> buffer , & pc -> buffer_size , next + pc -> index + FF_INPUT_BUFFER_PADDING_SIZE ) ; <S2SV_StartBug> if ( ! new_buffer ) <S2SV_EndBug> <S2SV_StartBug> return AVERROR ( ENOMEM ) ; <S2SV_EndBug> pc -> buffer = new_buffer ; if ( next > - FF_INPUT_BUFFER_PADDING_SIZE ) memcpy ( & pc -> buffer [ pc -> index ] , * buf , next + FF_INPUT_BUFFER_PADDING_SIZE ) ; pc -> index = 0 ; * buf = pc -> buffer ; } for ( ; next < 0 ; next ++ ) { pc -> state = ( pc -> state << 8 ) | pc -> buffer [ pc -> last_index + next ] ; pc -> state64 = ( pc -> state64 << 8 ) | pc -> buffer [ pc -> last_index + next ] ; pc -> overread ++ ; } if ( pc -> overread ) { av_dlog ( NULL , ""overread<S2SV_blank>%d,<S2SV_blank>state:%X<S2SV_blank>next:%d<S2SV_blank>index:%d<S2SV_blank>o_index:%d\\n"" , pc -> overread , pc -> state , next , pc -> index , pc -> overread_index ) ; av_dlog ( NULL , ""%X<S2SV_blank>%X<S2SV_blank>%X<S2SV_blank>%X\\n"" , ( * buf ) [ 0 ] , ( * buf ) [ 1 ] , ( * buf ) [ 2 ] , ( * buf ) [ 3 ] ) ; } return 0 ; }
","<S2SV_ModStart> ! new_buffer ) { pc -> index = 0 ; <S2SV_ModStart> ENOMEM ) ; } <S2SV_ModStart> ! new_buffer ) { pc -> overread_index = pc -> index = 0 ; <S2SV_ModStart> ENOMEM ) ; }
"
1164,"CWE-22 int set_interface_var ( const char * iface , const char * var , const char * name , uint32_t val ) { FILE * fp ; char spath [ 64 + IFNAMSIZ ] ; <S2SV_StartBug> if ( snprintf ( spath , sizeof ( spath ) , var , iface ) >= sizeof ( spath ) ) <S2SV_EndBug> return - 1 ; if ( access ( spath , F_OK ) != 0 ) return - 1 ; fp = fopen ( spath , ""w"" ) ; if ( ! fp ) { if ( name ) flog ( LOG_ERR , ""failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>%s<S2SV_blank>(%u)<S2SV_blank>for<S2SV_blank>%s:<S2SV_blank>%s"" , name , val , iface , strerror ( errno ) ) ; return - 1 ; } fprintf ( fp , ""%u"" , val ) ; fclose ( fp ) ; return 0 ; }
","<S2SV_ModStart> sizeof ( spath ) ) return - 1 ; if ( strstr ( name , "".."" ) || strchr ( name , '/'
"
1165,"CWE-476 jas_image_t * bmp_decode ( jas_stream_t * in , char * optstr ) { jas_image_t * image ; bmp_hdr_t hdr ; bmp_info_t * info ; uint_fast16_t cmptno ; jas_image_cmptparm_t cmptparms [ 3 ] ; jas_image_cmptparm_t * cmptparm ; uint_fast16_t numcmpts ; long n ; <S2SV_StartBug> if ( optstr ) { <S2SV_EndBug> jas_eprintf ( ""warning:<S2SV_blank>ignoring<S2SV_blank>BMP<S2SV_blank>decoder<S2SV_blank>options\\n"" ) ; } jas_eprintf ( ""THE<S2SV_blank>BMP<S2SV_blank>FORMAT<S2SV_blank>IS<S2SV_blank>NOT<S2SV_blank>FULLY<S2SV_blank>SUPPORTED!\\n"" ""THAT<S2SV_blank>IS,<S2SV_blank>THE<S2SV_blank>JASPER<S2SV_blank>SOFTWARE<S2SV_blank>CANNOT<S2SV_blank>DECODE<S2SV_blank>ALL<S2SV_blank>TYPES<S2SV_blank>OF<S2SV_blank>BMP<S2SV_blank>DATA.\\n"" ""IF<S2SV_blank>YOU<S2SV_blank>HAVE<S2SV_blank>ANY<S2SV_blank>PROBLEMS,<S2SV_blank>PLEASE<S2SV_blank>TRY<S2SV_blank>CONVERTING<S2SV_blank>YOUR<S2SV_blank>IMAGE<S2SV_blank>DATA\\n"" ""TO<S2SV_blank>THE<S2SV_blank>PNM<S2SV_blank>FORMAT,<S2SV_blank>AND<S2SV_blank>USING<S2SV_blank>THIS<S2SV_blank>FORMAT<S2SV_blank>INSTEAD.\\n"" ) ; if ( bmp_gethdr ( in , & hdr ) ) { jas_eprintf ( ""cannot<S2SV_blank>get<S2SV_blank>header\\n"" ) ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> } JAS_DBGLOG ( 1 , ( ""BMP<S2SV_blank>header:<S2SV_blank>magic<S2SV_blank>0x%x;<S2SV_blank>siz<S2SV_blank>%d;<S2SV_blank>res1<S2SV_blank>%d;<S2SV_blank>res2<S2SV_blank>%d;<S2SV_blank>off<S2SV_blank>%d\\n"" , hdr . magic , hdr . siz , hdr . reserved1 , hdr . reserved2 , hdr . off ) ) ; if ( ! ( info = bmp_getinfo ( in ) ) ) { jas_eprintf ( ""cannot<S2SV_blank>get<S2SV_blank>info\\n"" ) ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> } JAS_DBGLOG ( 1 , <S2SV_StartBug> ( ""BMP<S2SV_blank>information:<S2SV_blank>len<S2SV_blank>%d;<S2SV_blank>width<S2SV_blank>%d;<S2SV_blank>height<S2SV_blank>%d;<S2SV_blank>numplanes<S2SV_blank>%d;<S2SV_blank>"" <S2SV_EndBug> ""depth<S2SV_blank>%d;<S2SV_blank>enctype<S2SV_blank>%d;<S2SV_blank>siz<S2SV_blank>%d;<S2SV_blank>hres<S2SV_blank>%d;<S2SV_blank>vres<S2SV_blank>%d;<S2SV_blank>numcolors<S2SV_blank>%d;<S2SV_blank>"" <S2SV_StartBug> ""mincolors<S2SV_blank>%d\\n"" , info -> len , info -> width , info -> height , info -> numplanes , <S2SV_EndBug> <S2SV_StartBug> info -> depth , info -> enctype , info -> siz , info -> hres , info -> vres , <S2SV_EndBug> <S2SV_StartBug> info -> numcolors , info -> mincolors ) ) ; <S2SV_EndBug> if ( ! bmp_issupported ( & hdr , info ) ) { jas_eprintf ( ""error:<S2SV_blank>unsupported<S2SV_blank>BMP<S2SV_blank>encoding\\n"" ) ; <S2SV_StartBug> bmp_info_destroy ( info ) ; <S2SV_EndBug> return 0 ; } if ( ( n = hdr . off - ( BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN ( info ) ) ) < 0 ) { jas_eprintf ( ""error:<S2SV_blank>possibly<S2SV_blank>bad<S2SV_blank>bitmap<S2SV_blank>offset?\\n"" ) ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> } if ( n > 0 ) { jas_eprintf ( ""skipping<S2SV_blank>unknown<S2SV_blank>data<S2SV_blank>in<S2SV_blank>BMP<S2SV_blank>file\\n"" ) ; if ( bmp_gobble ( in , n ) ) { <S2SV_StartBug> bmp_info_destroy ( info ) ; <S2SV_EndBug> return 0 ; } } numcmpts = bmp_numcmpts ( info ) ; for ( cmptno = 0 , cmptparm = cmptparms ; cmptno < numcmpts ; ++ cmptno , ++ cmptparm ) { cmptparm -> tlx = 0 ; cmptparm -> tly = 0 ; cmptparm -> hstep = 1 ; cmptparm -> vstep = 1 ; cmptparm -> width = info -> width ; cmptparm -> height = info -> height ; cmptparm -> prec = 8 ; cmptparm -> sgnd = false ; } if ( ! ( image = jas_image_create ( numcmpts , cmptparms , JAS_CLRSPC_UNKNOWN ) ) ) { <S2SV_StartBug> bmp_info_destroy ( info ) ; <S2SV_EndBug> return 0 ; } if ( numcmpts == 3 ) { jas_image_setclrspc ( image , JAS_CLRSPC_SRGB ) ; jas_image_setcmpttype ( image , 0 , JAS_IMAGE_CT_COLOR ( JAS_CLRSPC_CHANIND_RGB_R ) ) ; jas_image_setcmpttype ( image , 1 , JAS_IMAGE_CT_COLOR ( JAS_CLRSPC_CHANIND_RGB_G ) ) ; jas_image_setcmpttype ( image , 2 , JAS_IMAGE_CT_COLOR ( JAS_CLRSPC_CHANIND_RGB_B ) ) ; } else { jas_image_setclrspc ( image , JAS_CLRSPC_SGRAY ) ; jas_image_setcmpttype ( image , 0 , JAS_IMAGE_CT_COLOR ( JAS_CLRSPC_CHANIND_GRAY_Y ) ) ; } if ( bmp_getdata ( in , info , image ) ) { <S2SV_StartBug> bmp_info_destroy ( info ) ; <S2SV_EndBug> <S2SV_StartBug> jas_image_destroy ( image ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> } <S2SV_StartBug> bmp_info_destroy ( info ) ; <S2SV_EndBug> return image ; }
","<S2SV_ModStart> long n ; image = 0 ; info = 0 ; <S2SV_ModStart> ""cannot<S2SV_blank>get<S2SV_blank>header\\n"" ) ; goto error <S2SV_ModEnd> ; } JAS_DBGLOG <S2SV_ModStart> ""cannot<S2SV_blank>get<S2SV_blank>info\\n"" ) ; goto error <S2SV_ModEnd> ; } JAS_DBGLOG <S2SV_ModStart> 1 , ( ""BMP<S2SV_blank>information:<S2SV_blank>len<S2SV_blank>%ld;<S2SV_blank>width<S2SV_blank>%ld;<S2SV_blank>height<S2SV_blank>%ld;<S2SV_blank>numplanes<S2SV_blank>%d;<S2SV_blank>"" ""depth<S2SV_blank>%d;<S2SV_blank>enctype<S2SV_blank>%ld;<S2SV_blank>siz<S2SV_blank>%ld;<S2SV_blank>hres<S2SV_blank>%ld;<S2SV_blank>vres<S2SV_blank>%ld;<S2SV_blank>numcolors<S2SV_blank>%ld;<S2SV_blank>"" ""mincolors<S2SV_blank>%ld\\n"" , JAS_CAST ( long <S2SV_ModEnd> , info -> <S2SV_ModStart> info -> len ) , JAS_CAST ( long <S2SV_ModStart> info -> width ) , JAS_CAST ( long <S2SV_ModStart> info -> height ) , JAS_CAST ( long <S2SV_ModStart> info -> numplanes ) , JAS_CAST ( long , <S2SV_ModEnd> info -> depth <S2SV_ModStart> info -> depth ) , JAS_CAST ( long <S2SV_ModStart> info -> enctype ) , JAS_CAST ( long <S2SV_ModStart> info -> siz ) , JAS_CAST ( long <S2SV_ModStart> info -> hres ) , JAS_CAST ( long <S2SV_ModStart> info -> vres ) , JAS_CAST ( long , <S2SV_ModEnd> info -> numcolors <S2SV_ModStart> info -> numcolors ) , JAS_CAST ( long <S2SV_ModStart> mincolors ) ) ) ; if ( info -> width < 0 || info -> height < 0 || info -> numplanes < 0 || info -> depth < 0 || info -> siz < 0 || info -> hres < 0 || info -> vres < 0 ) { jas_eprintf ( ""corrupt<S2SV_blank>bit<S2SV_blank>stream\\n"" ) ; goto error ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> ""error:<S2SV_blank>unsupported<S2SV_blank>BMP<S2SV_blank>encoding\\n"" ) ; goto error <S2SV_ModEnd> ; } if <S2SV_ModStart> ""error:<S2SV_blank>possibly<S2SV_blank>bad<S2SV_blank>bitmap<S2SV_blank>offset?\\n"" ) ; goto error <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ) { goto error <S2SV_ModEnd> ; } } <S2SV_ModStart> ) ) { goto error <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ) { goto error ; } <S2SV_ModStart> info ) ; return image ; error : if ( info ) { bmp_info_destroy ( info ) ; } if ( image ) { <S2SV_ModStart> image ) ; } <S2SV_ModStart> 0 ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
"
1166,"CWE-20 static void f2fs_put_super ( struct super_block * sb ) { struct f2fs_sb_info * sbi = F2FS_SB ( sb ) ; int i ; f2fs_quota_off_umount ( sb ) ; mutex_lock ( & sbi -> umount_mutex ) ; if ( is_sbi_flag_set ( sbi , SBI_IS_DIRTY ) || ! is_set_ckpt_flags ( sbi , CP_UMOUNT_FLAG ) ) { struct cp_control cpc = { . reason = CP_UMOUNT , } ; write_checkpoint ( sbi , & cpc ) ; } <S2SV_StartBug> f2fs_wait_discard_bios ( sbi ) ; <S2SV_EndBug> if ( f2fs_discard_en ( sbi ) && ! sbi -> discard_blks ) { struct cp_control cpc = { . reason = CP_UMOUNT | CP_TRIMMED , } ; write_checkpoint ( sbi , & cpc ) ; } f2fs_destroy_stats ( sbi ) ; release_ino_entry ( sbi , true ) ; f2fs_leave_shrinker ( sbi ) ; mutex_unlock ( & sbi -> umount_mutex ) ; f2fs_flush_merged_writes ( sbi ) ; iput ( sbi -> node_inode ) ; iput ( sbi -> meta_inode ) ; destroy_node_manager ( sbi ) ; destroy_segment_manager ( sbi ) ; kfree ( sbi -> ckpt ) ; f2fs_unregister_sysfs ( sbi ) ; sb -> s_fs_info = NULL ; if ( sbi -> s_chksum_driver ) crypto_free_shash ( sbi -> s_chksum_driver ) ; kfree ( sbi -> raw_super ) ; destroy_device_list ( sbi ) ; mempool_destroy ( sbi -> write_io_dummy ) ; # ifdef CONFIG_QUOTA for ( i = 0 ; i < MAXQUOTAS ; i ++ ) kfree ( sbi -> s_qf_names [ i ] ) ; # endif destroy_percpu_info ( sbi ) ; for ( i = 0 ; i < NR_PAGE_TYPE ; i ++ ) kfree ( sbi -> write_io [ i ] ) ; kfree ( sbi ) ; }
","<S2SV_ModStart> f2fs_wait_discard_bios ( sbi , true
"
1167,"CWE-119 static int privsep_preauth ( Authctxt * authctxt ) { int status , r ; pid_t pid ; struct ssh_sandbox * box = NULL ; pmonitor = monitor_init ( ) ; pmonitor -> m_pkex = & active_state -> kex ; if ( use_privsep == PRIVSEP_ON ) box = ssh_sandbox_init ( ) ; pid = fork ( ) ; if ( pid == - 1 ) { fatal ( ""fork<S2SV_blank>of<S2SV_blank>unprivileged<S2SV_blank>child<S2SV_blank>failed"" ) ; } else if ( pid != 0 ) { debug2 ( ""Network<S2SV_blank>child<S2SV_blank>is<S2SV_blank>on<S2SV_blank>pid<S2SV_blank>%ld"" , ( long ) pid ) ; pmonitor -> m_pid = pid ; if ( have_agent ) { r = ssh_get_authentication_socket ( & auth_sock ) ; if ( r != 0 ) { error ( ""Could<S2SV_blank>not<S2SV_blank>get<S2SV_blank>agent<S2SV_blank>socket:<S2SV_blank>%s"" , ssh_err ( r ) ) ; have_agent = 0 ; } } if ( box != NULL ) ssh_sandbox_parent_preauth ( box , pid ) ; monitor_child_preauth ( authctxt , pmonitor ) ; <S2SV_StartBug> monitor_sync ( pmonitor ) ; <S2SV_EndBug> while ( waitpid ( pid , & status , 0 ) < 0 ) { if ( errno == EINTR ) continue ; pmonitor -> m_pid = - 1 ; fatal ( ""%s:<S2SV_blank>waitpid:<S2SV_blank>%s"" , __func__ , strerror ( errno ) ) ; } privsep_is_preauth = 0 ; pmonitor -> m_pid = - 1 ; if ( WIFEXITED ( status ) ) { if ( WEXITSTATUS ( status ) != 0 ) fatal ( ""%s:<S2SV_blank>preauth<S2SV_blank>child<S2SV_blank>exited<S2SV_blank>with<S2SV_blank>status<S2SV_blank>%d"" , __func__ , WEXITSTATUS ( status ) ) ; } else if ( WIFSIGNALED ( status ) ) fatal ( ""%s:<S2SV_blank>preauth<S2SV_blank>child<S2SV_blank>terminated<S2SV_blank>by<S2SV_blank>signal<S2SV_blank>%d"" , __func__ , WTERMSIG ( status ) ) ; if ( box != NULL ) ssh_sandbox_parent_finish ( box ) ; return 1 ; } else { close ( pmonitor -> m_sendfd ) ; close ( pmonitor -> m_log_recvfd ) ; set_log_handler ( mm_log_handler , pmonitor ) ; privsep_preauth_child ( ) ; setproctitle ( ""%s"" , ""[net]"" ) ; if ( box != NULL ) ssh_sandbox_child ( box ) ; return 0 ; } }
","<S2SV_ModStart> pmonitor ) ; <S2SV_ModEnd> while ( waitpid
"
1168,"CWE-000 long join_session_keyring ( const char * name ) { const struct cred * old ; struct cred * new ; struct key * keyring ; long ret , serial ; new = prepare_creds ( ) ; if ( ! new ) return - ENOMEM ; old = current_cred ( ) ; if ( ! name ) { ret = install_session_keyring_to_cred ( new , NULL ) ; if ( ret < 0 ) goto error ; serial = new -> session_keyring -> serial ; ret = commit_creds ( new ) ; if ( ret == 0 ) ret = serial ; goto okay ; } mutex_lock ( & key_session_mutex ) ; keyring = find_keyring_by_name ( name , false ) ; if ( PTR_ERR ( keyring ) == - ENOKEY ) { keyring = keyring_alloc ( name , old -> uid , old -> gid , old , KEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ | KEY_USR_LINK , KEY_ALLOC_IN_QUOTA , NULL ) ; if ( IS_ERR ( keyring ) ) { ret = PTR_ERR ( keyring ) ; goto error2 ; } } else if ( IS_ERR ( keyring ) ) { ret = PTR_ERR ( keyring ) ; goto error2 ; } else if ( keyring == new -> session_keyring ) { <S2SV_StartBug> ret = 0 ; <S2SV_EndBug> goto error2 ; } ret = install_session_keyring_to_cred ( new , keyring ) ; if ( ret < 0 ) goto error2 ; commit_creds ( new ) ; mutex_unlock ( & key_session_mutex ) ; ret = keyring -> serial ; key_put ( keyring ) ; okay : return ret ; error2 : mutex_unlock ( & key_session_mutex ) ; error : abort_creds ( new ) ; return ret ; }
","<S2SV_ModStart> session_keyring ) { key_put ( keyring ) ;
"
1169,"CWE-119 static void process_secondary_order ( STREAM s ) { uint16 length ; uint16 flags ; uint8 type ; uint8 * next_order ; <S2SV_StartBug> in_uint16_le ( s , length ) ; <S2SV_EndBug> in_uint16_le ( s , flags ) ; <S2SV_StartBug> in_uint8 ( s , type ) ; <S2SV_EndBug> next_order = s -> p + ( sint16 ) length + 7 ; switch ( type ) { case RDP_ORDER_RAW_BMPCACHE : process_raw_bmpcache ( s ) ; break ; case RDP_ORDER_COLCACHE : process_colcache ( s ) ; break ; case RDP_ORDER_BMPCACHE : process_bmpcache ( s ) ; break ; case RDP_ORDER_FONTCACHE : process_fontcache ( s ) ; break ; case RDP_ORDER_RAW_BMPCACHE2 : process_bmpcache2 ( s , flags , False ) ; break ; case RDP_ORDER_BMPCACHE2 : process_bmpcache2 ( s , flags , True ) ; break ; case RDP_ORDER_BRUSHCACHE : process_brushcache ( s , flags ) ; break ; default : logger ( Graphics , Warning , ""process_secondary_order(),<S2SV_blank>unhandled<S2SV_blank>secondary<S2SV_blank>order<S2SV_blank>%d"" , type ) ; } s -> p = next_order ; }
","<S2SV_ModStart> * next_order ; struct stream packet = * s ; <S2SV_ModStart> type ) ; if ( ! s_check_rem ( s , length + 7 ) ) { rdp_protocol_error ( ""process_secondary_order(),<S2SV_blank>next<S2SV_blank>order<S2SV_blank>pointer<S2SV_blank>would<S2SV_blank>overrun<S2SV_blank>stream"" , & packet ) ; }
"
1170,"CWE-59 int pidfile_write ( const char * pid_file , int pid ) { FILE * pidfile = NULL ; <S2SV_StartBug> int pidfd = creat ( pid_file , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ; <S2SV_EndBug> if ( pidfd != - 1 ) pidfile = fdopen ( pidfd , ""w"" ) ; if ( ! pidfile ) { log_message ( LOG_INFO , ""pidfile_write<S2SV_blank>:<S2SV_blank>Cannot<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>pidfile"" , pid_file ) ; return 0 ; } fprintf ( pidfile , ""%d\\n"" , pid ) ; fclose ( pidfile ) ; return 1 ; }
","<S2SV_ModStart> int pidfd = open ( pid_file , O_NOFOLLOW | O_CREAT | O_WRONLY | O_TRUNC <S2SV_ModEnd> , S_IRUSR |
"
1171,"CWE-20 static int pppol2tp_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { int err ; struct sk_buff * skb ; struct sock * sk = sock -> sk ; err = - EIO ; if ( sk -> sk_state & PPPOX_BOUND ) <S2SV_StartBug> goto end ; <S2SV_EndBug> msg -> msg_namelen = 0 ; err = 0 ; skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & err ) ; if ( ! skb ) goto end ; if ( len > skb -> len ) len = skb -> len ; else if ( len < skb -> len ) msg -> msg_flags |= MSG_TRUNC ; err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , len ) ; if ( likely ( err == 0 ) ) err = len ; kfree_skb ( skb ) ; end : return err ; }
","<S2SV_ModStart> ) goto end <S2SV_ModEnd> ; err =
"
1172,"CWE-125 int main ( ) { <S2SV_StartBug> gdImagePtr im ; <S2SV_EndBug> char * buffer ; size_t size ; size = read_test_file ( & buffer , ""heap_overflow.tga"" ) ; im = gdImageCreateFromTgaPtr ( size , ( void * ) buffer ) ; gdTestAssert ( im == NULL ) ; free ( buffer ) ; return gdNumFailures ( ) ; }
","<S2SV_ModStart> ( ) { check_file ( ""heap_overflow_1.tga"" ) ; check_file ( ""heap_overflow_2.tga"" <S2SV_ModEnd> ) ; return
"
1173,"CWE-119 void vp8_dequant_idct_add_y_block_mmx ( short * q , short * dq , unsigned char * dst , int stride , char * eobs ) { int i ; for ( i = 0 ; i < 4 ; i ++ ) { if ( eobs [ 0 ] > 1 ) vp8_dequant_idct_add_mmx ( q , dq , dst , stride ) ; else if ( eobs [ 0 ] == 1 ) { vp8_dc_only_idct_add_mmx ( q [ 0 ] * dq [ 0 ] , dst , stride , dst , stride ) ; <S2SV_StartBug> vpx_memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <S2SV_EndBug> } if ( eobs [ 1 ] > 1 ) vp8_dequant_idct_add_mmx ( q + 16 , dq , dst + 4 , stride ) ; else if ( eobs [ 1 ] == 1 ) { vp8_dc_only_idct_add_mmx ( q [ 16 ] * dq [ 0 ] , dst + 4 , stride , dst + 4 , stride ) ; <S2SV_StartBug> vpx_memset ( q + 16 , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <S2SV_EndBug> } if ( eobs [ 2 ] > 1 ) vp8_dequant_idct_add_mmx ( q + 32 , dq , dst + 8 , stride ) ; else if ( eobs [ 2 ] == 1 ) { vp8_dc_only_idct_add_mmx ( q [ 32 ] * dq [ 0 ] , dst + 8 , stride , dst + 8 , stride ) ; <S2SV_StartBug> vpx_memset ( q + 32 , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <S2SV_EndBug> } if ( eobs [ 3 ] > 1 ) vp8_dequant_idct_add_mmx ( q + 48 , dq , dst + 12 , stride ) ; else if ( eobs [ 3 ] == 1 ) { vp8_dc_only_idct_add_mmx ( q [ 48 ] * dq [ 0 ] , dst + 12 , stride , dst + 12 , stride ) ; <S2SV_StartBug> vpx_memset ( q + 48 , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <S2SV_EndBug> } q += 64 ; dst += 4 * stride ; eobs += 4 ; } }
","<S2SV_ModStart> stride ) ; memset <S2SV_ModEnd> ( q , <S2SV_ModStart> stride ) ; memset <S2SV_ModEnd> ( q + <S2SV_ModStart> stride ) ; memset <S2SV_ModEnd> ( q + <S2SV_ModStart> stride ) ; memset <S2SV_ModEnd> ( q +
"
1174,"CWE-190 static int Unpickler_set_memo ( UnpicklerObject * self , PyObject * obj ) { PyObject * * new_memo ; <S2SV_StartBug> Py_ssize_t new_memo_size = 0 ; <S2SV_EndBug> Py_ssize_t i ; if ( obj == NULL ) { PyErr_SetString ( PyExc_TypeError , ""attribute<S2SV_blank>deletion<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported"" ) ; return - 1 ; } if ( Py_TYPE ( obj ) == & UnpicklerMemoProxyType ) { UnpicklerObject * unpickler = ( ( UnpicklerMemoProxyObject * ) obj ) -> unpickler ; new_memo_size = unpickler -> memo_size ; new_memo = _Unpickler_NewMemo ( new_memo_size ) ; if ( new_memo == NULL ) return - 1 ; <S2SV_StartBug> for ( i = 0 ; i < new_memo_size ; i ++ ) { <S2SV_EndBug> Py_XINCREF ( unpickler -> memo [ i ] ) ; new_memo [ i ] = unpickler -> memo [ i ] ; } } else if ( PyDict_Check ( obj ) ) { Py_ssize_t i = 0 ; PyObject * key , * value ; new_memo_size = PyDict_GET_SIZE ( obj ) ; new_memo = _Unpickler_NewMemo ( new_memo_size ) ; if ( new_memo == NULL ) return - 1 ; while ( PyDict_Next ( obj , & i , & key , & value ) ) { Py_ssize_t idx ; if ( ! PyLong_Check ( key ) ) { PyErr_SetString ( PyExc_TypeError , ""memo<S2SV_blank>key<S2SV_blank>must<S2SV_blank>be<S2SV_blank>integers"" ) ; goto error ; } idx = PyLong_AsSsize_t ( key ) ; if ( idx == - 1 && PyErr_Occurred ( ) ) goto error ; if ( idx < 0 ) { PyErr_SetString ( PyExc_ValueError , ""memo<S2SV_blank>key<S2SV_blank>must<S2SV_blank>be<S2SV_blank>positive<S2SV_blank>integers."" ) ; goto error ; } if ( _Unpickler_MemoPut ( self , idx , value ) < 0 ) goto error ; } } else { PyErr_Format ( PyExc_TypeError , ""\'memo\'<S2SV_blank>attribute<S2SV_blank>must<S2SV_blank>be<S2SV_blank>an<S2SV_blank>UnpicklerMemoProxy<S2SV_blank>object"" ""or<S2SV_blank>dict,<S2SV_blank>not<S2SV_blank>%.200s"" , Py_TYPE ( obj ) -> tp_name ) ; return - 1 ; } _Unpickler_MemoCleanup ( self ) ; self -> memo_size = new_memo_size ; self -> memo = new_memo ; return 0 ; error : if ( new_memo_size ) { <S2SV_StartBug> i = new_memo_size ; <S2SV_EndBug> while ( -- i >= 0 ) { Py_XDECREF ( new_memo [ i ] ) ; } PyMem_FREE ( new_memo ) ; } return - 1 ; }
","<S2SV_ModStart> * new_memo ; size_t new_memo_size = 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; for ( size_t <S2SV_ModStart> new_memo_size ) { for ( size_t i = new_memo_size - 1 ; i != SIZE_MAX ; i -- <S2SV_ModEnd> ) { Py_XDECREF
"
1175,"CWE-119 static int filter_frame ( AVFilterLink * inlink , AVFrame * in ) { unsigned x , y ; AVFilterContext * ctx = inlink -> dst ; VignetteContext * s = ctx -> priv ; AVFilterLink * outlink = inlink -> dst -> outputs [ 0 ] ; AVFrame * out ; out = ff_get_video_buffer ( outlink , outlink -> w , outlink -> h ) ; if ( ! out ) { av_frame_free ( & in ) ; return AVERROR ( ENOMEM ) ; } av_frame_copy_props ( out , in ) ; if ( s -> eval_mode == EVAL_MODE_FRAME ) update_context ( s , inlink , in ) ; if ( s -> desc -> flags & AV_PIX_FMT_FLAG_RGB ) { uint8_t * dst = out -> data [ 0 ] ; const uint8_t * src = in -> data [ 0 ] ; const float * fmap = s -> fmap ; const int dst_linesize = out -> linesize [ 0 ] ; const int src_linesize = in -> linesize [ 0 ] ; const int fmap_linesize = s -> fmap_linesize ; for ( y = 0 ; y < inlink -> h ; y ++ ) { uint8_t * dstp = dst ; const uint8_t * srcp = src ; for ( x = 0 ; x < inlink -> w ; x ++ , dstp += 3 , srcp += 3 ) { const float f = fmap [ x ] ; dstp [ 0 ] = av_clip_uint8 ( srcp [ 0 ] * f + get_dither_value ( s ) ) ; dstp [ 1 ] = av_clip_uint8 ( srcp [ 1 ] * f + get_dither_value ( s ) ) ; dstp [ 2 ] = av_clip_uint8 ( srcp [ 2 ] * f + get_dither_value ( s ) ) ; } dst += dst_linesize ; src += src_linesize ; fmap += fmap_linesize ; } } else { int plane ; <S2SV_StartBug> for ( plane = 0 ; plane < 4 && in -> data [ plane ] ; plane ++ ) { <S2SV_EndBug> uint8_t * dst = out -> data [ plane ] ; const uint8_t * src = in -> data [ plane ] ; const float * fmap = s -> fmap ; const int dst_linesize = out -> linesize [ plane ] ; const int src_linesize = in -> linesize [ plane ] ; const int fmap_linesize = s -> fmap_linesize ; const int chroma = plane == 1 || plane == 2 ; const int hsub = chroma ? s -> desc -> log2_chroma_w : 0 ; const int vsub = chroma ? s -> desc -> log2_chroma_h : 0 ; const int w = FF_CEIL_RSHIFT ( inlink -> w , hsub ) ; const int h = FF_CEIL_RSHIFT ( inlink -> h , vsub ) ; for ( y = 0 ; y < h ; y ++ ) { uint8_t * dstp = dst ; const uint8_t * srcp = src ; for ( x = 0 ; x < w ; x ++ ) { const double dv = get_dither_value ( s ) ; if ( chroma ) * dstp ++ = av_clip_uint8 ( fmap [ x << hsub ] * ( * srcp ++ - 127 ) + 127 + dv ) ; else * dstp ++ = av_clip_uint8 ( fmap [ x ] * * srcp ++ + dv ) ; } dst += dst_linesize ; src += src_linesize ; fmap += fmap_linesize << vsub ; } } } return ff_filter_frame ( outlink , out ) ; }
","<S2SV_ModStart> in -> data [ plane ] && in -> linesize
"
1176,"CWE-125 static void icmp6_rrenum_print ( netdissect_options * ndo , const u_char * bp , const u_char * ep ) { const struct icmp6_router_renum * rr6 ; const char * cp ; const struct rr_pco_match * match ; const struct rr_pco_use * use ; char hbuf [ NI_MAXHOST ] ; int n ; if ( ep < bp ) return ; rr6 = ( const struct icmp6_router_renum * ) bp ; cp = ( const char * ) ( rr6 + 1 ) ; ND_TCHECK ( rr6 -> rr_reserved ) ; switch ( rr6 -> rr_code ) { case ICMP6_ROUTER_RENUMBERING_COMMAND : ND_PRINT ( ( ndo , ""router<S2SV_blank>renum:<S2SV_blank>command"" ) ) ; break ; case ICMP6_ROUTER_RENUMBERING_RESULT : ND_PRINT ( ( ndo , ""router<S2SV_blank>renum:<S2SV_blank>result"" ) ) ; break ; case ICMP6_ROUTER_RENUMBERING_SEQNUM_RESET : ND_PRINT ( ( ndo , ""router<S2SV_blank>renum:<S2SV_blank>sequence<S2SV_blank>number<S2SV_blank>reset"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""router<S2SV_blank>renum:<S2SV_blank>code-#%d"" , rr6 -> rr_code ) ) ; break ; } ND_PRINT ( ( ndo , "",<S2SV_blank>seq=%u"" , EXTRACT_32BITS ( & rr6 -> rr_seqnum ) ) ) ; if ( ndo -> ndo_vflag ) { # define F ( x , y ) ( ( rr6 -> rr_flags ) & ( x ) ? ( y ) : """" ) ND_PRINT ( ( ndo , ""["" ) ) ; if ( rr6 -> rr_flags ) { ND_PRINT ( ( ndo , ""%s%s%s%s%s,"" , F ( ICMP6_RR_FLAGS_TEST , ""T"" ) , F ( ICMP6_RR_FLAGS_REQRESULT , ""R"" ) , F ( ICMP6_RR_FLAGS_FORCEAPPLY , ""A"" ) , F ( ICMP6_RR_FLAGS_SPECSITE , ""S"" ) , F ( ICMP6_RR_FLAGS_PREVDONE , ""P"" ) ) ) ; } ND_PRINT ( ( ndo , ""seg=%u,"" , rr6 -> rr_segnum ) ) ; ND_PRINT ( ( ndo , ""maxdelay=%u"" , EXTRACT_16BITS ( & rr6 -> rr_maxdelay ) ) ) ; if ( rr6 -> rr_reserved ) ND_PRINT ( ( ndo , ""rsvd=0x%x"" , EXTRACT_32BITS ( & rr6 -> rr_reserved ) ) ) ; ND_PRINT ( ( ndo , ""]"" ) ) ; # undef F } if ( rr6 -> rr_code == ICMP6_ROUTER_RENUMBERING_COMMAND ) { match = ( const struct rr_pco_match * ) cp ; cp = ( const char * ) ( match + 1 ) ; ND_TCHECK ( match -> rpm_prefix ) ; if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\n\\t"" ) ) ; else ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; ND_PRINT ( ( ndo , ""match("" ) ) ; switch ( match -> rpm_code ) { case RPM_PCO_ADD : ND_PRINT ( ( ndo , ""add"" ) ) ; break ; case RPM_PCO_CHANGE : ND_PRINT ( ( ndo , ""change"" ) ) ; break ; case RPM_PCO_SETGLOBAL : ND_PRINT ( ( ndo , ""setglobal"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""#%u"" , match -> rpm_code ) ) ; break ; } if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , "",ord=%u"" , match -> rpm_ordinal ) ) ; ND_PRINT ( ( ndo , "",min=%u"" , match -> rpm_minlen ) ) ; ND_PRINT ( ( ndo , "",max=%u"" , match -> rpm_maxlen ) ) ; } if ( addrtostr6 ( & match -> rpm_prefix , hbuf , sizeof ( hbuf ) ) ) ND_PRINT ( ( ndo , "",%s/%u"" , hbuf , match -> rpm_matchlen ) ) ; else ND_PRINT ( ( ndo , "",?/%u"" , match -> rpm_matchlen ) ) ; ND_PRINT ( ( ndo , "")"" ) ) ; n = match -> rpm_len - 3 ; if ( n % 4 ) goto trunc ; n /= 4 ; while ( n -- > 0 ) { use = ( const struct rr_pco_use * ) cp ; cp = ( const char * ) ( use + 1 ) ; ND_TCHECK ( use -> rpu_prefix ) ; if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\n\\t"" ) ) ; else ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; ND_PRINT ( ( ndo , ""use("" ) ) ; if ( use -> rpu_flags ) { # define F ( x , y ) ( ( use -> rpu_flags ) & ( x ) ? ( y ) : """" ) ND_PRINT ( ( ndo , ""%s%s,"" , F ( ICMP6_RR_PCOUSE_FLAGS_DECRVLTIME , ""V"" ) , F ( ICMP6_RR_PCOUSE_FLAGS_DECRPLTIME , ""P"" ) ) ) ; # undef F } if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , ""mask=0x%x,"" , use -> rpu_ramask ) ) ; ND_PRINT ( ( ndo , ""raflags=0x%x,"" , use -> rpu_raflags ) ) ; if ( ~ use -> rpu_vltime == 0 ) ND_PRINT ( ( ndo , ""vltime=infty,"" ) ) ; else ND_PRINT ( ( ndo , ""vltime=%u,"" , EXTRACT_32BITS ( & use -> rpu_vltime ) ) ) ; if ( ~ use -> rpu_pltime == 0 ) ND_PRINT ( ( ndo , ""pltime=infty,"" ) ) ; else ND_PRINT ( ( ndo , ""pltime=%u,"" , EXTRACT_32BITS ( & use -> rpu_pltime ) ) ) ; } if ( addrtostr6 ( & use -> rpu_prefix , hbuf , sizeof ( hbuf ) ) ) ND_PRINT ( ( ndo , ""%s/%u/%u"" , hbuf , use -> rpu_uselen , use -> rpu_keeplen ) ) ; else ND_PRINT ( ( ndo , ""?/%u/%u"" , use -> rpu_uselen , use -> rpu_keeplen ) ) ; ND_PRINT ( ( ndo , "")"" ) ) ; } } return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , ""[|icmp6]"" ) ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ( ndo , ""%s"" , icmp6_tstr <S2SV_ModEnd> ) ) ;
"
1177,"CWE-20 void addReply ( redisClient * c , robj * obj ) { if ( _installWriteEvent ( c ) != REDIS_OK ) return ; <S2SV_StartBug> redisAssert ( ! server . vm_enabled || obj -> storage == REDIS_VM_MEMORY ) ; <S2SV_EndBug> if ( obj -> encoding == REDIS_ENCODING_RAW ) { if ( _addReplyToBuffer ( c , obj -> ptr , sdslen ( obj -> ptr ) ) != REDIS_OK ) _addReplyObjectToList ( c , obj ) ; } else { obj = getDecodedObject ( obj ) ; if ( _addReplyToBuffer ( c , obj -> ptr , sdslen ( obj -> ptr ) ) != REDIS_OK ) _addReplyObjectToList ( c , obj ) ; decrRefCount ( obj ) ; } }
","<S2SV_ModStart> ! server . ds_enabled <S2SV_ModEnd> || obj ->
"
1178,"CWE-119 bool initiate_stratum ( struct pool * pool ) { bool ret = false , recvd = false , noresume = false , sockd = false ; char s [ RBUFSIZE ] , * sret = NULL , * nonce1 , * sessionid ; json_t * val = NULL , * res_val , * err_val ; json_error_t err ; int n2size ; resend : if ( ! setup_stratum_socket ( pool ) ) { applog ( LOG_INFO , ""setup_stratum_socket()<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>failed"" , get_pool_name ( pool ) ) ; sockd = false ; goto out ; } sockd = true ; if ( recvd ) { clear_sock ( pool ) ; sprintf ( s , ""{\\""id\\"":<S2SV_blank>%d,<S2SV_blank>\\""method\\"":<S2SV_blank>\\""mining.subscribe\\"",<S2SV_blank>\\""params\\"":<S2SV_blank>[]}"" , swork_id ++ ) ; } else { if ( pool -> sessionid ) sprintf ( s , ""{\\""id\\"":<S2SV_blank>%d,<S2SV_blank>\\""method\\"":<S2SV_blank>\\""mining.subscribe\\"",<S2SV_blank>\\""params\\"":<S2SV_blank>[\\"""" PACKAGE ""/"" VERSION ""\\"",<S2SV_blank>\\""%s\\""]}"" , swork_id ++ , pool -> sessionid ) ; else sprintf ( s , ""{\\""id\\"":<S2SV_blank>%d,<S2SV_blank>\\""method\\"":<S2SV_blank>\\""mining.subscribe\\"",<S2SV_blank>\\""params\\"":<S2SV_blank>[\\"""" PACKAGE ""/"" VERSION ""\\""]}"" , swork_id ++ ) ; } if ( __stratum_send ( pool , s , strlen ( s ) ) != SEND_OK ) { applog ( LOG_DEBUG , ""Failed<S2SV_blank>to<S2SV_blank>send<S2SV_blank>s<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; goto out ; } if ( ! socket_full ( pool , DEFAULT_SOCKWAIT ) ) { applog ( LOG_DEBUG , ""Timed<S2SV_blank>out<S2SV_blank>waiting<S2SV_blank>for<S2SV_blank>response<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; goto out ; } sret = recv_line ( pool ) ; if ( ! sret ) goto out ; recvd = true ; val = JSON_LOADS ( sret , & err ) ; free ( sret ) ; if ( ! val ) { applog ( LOG_INFO , ""JSON<S2SV_blank>decode<S2SV_blank>failed(%d):<S2SV_blank>%s"" , err . line , err . text ) ; goto out ; } res_val = json_object_get ( val , ""result"" ) ; err_val = json_object_get ( val , ""error"" ) ; if ( ! res_val || json_is_null ( res_val ) || ( err_val && ! json_is_null ( err_val ) ) ) { char * ss ; if ( err_val ) ss = json_dumps ( err_val , JSON_INDENT ( 3 ) ) ; else ss = strdup ( ""(unknown<S2SV_blank>reason)"" ) ; applog ( LOG_INFO , ""JSON-RPC<S2SV_blank>decode<S2SV_blank>failed:<S2SV_blank>%s"" , ss ) ; free ( ss ) ; goto out ; } sessionid = get_sessionid ( res_val ) ; if ( ! sessionid ) applog ( LOG_DEBUG , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>sessionid<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; nonce1 = json_array_string ( res_val , 1 ) ; if ( ! nonce1 ) { applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>nonce1<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; free ( sessionid ) ; goto out ; } n2size = json_integer_value ( json_array_get ( res_val , 2 ) ) ; <S2SV_StartBug> if ( ! n2size ) { <S2SV_EndBug> applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; free ( sessionid ) ; free ( nonce1 ) ; goto out ; } cg_wlock ( & pool -> data_lock ) ; pool -> sessionid = sessionid ; pool -> nonce1 = nonce1 ; pool -> n1_len = strlen ( nonce1 ) / 2 ; free ( pool -> nonce1bin ) ; pool -> nonce1bin = ( unsigned char * ) calloc ( pool -> n1_len , 1 ) ; if ( unlikely ( ! pool -> nonce1bin ) ) quithere ( 1 , ""Failed<S2SV_blank>to<S2SV_blank>calloc<S2SV_blank>pool->nonce1bin"" ) ; hex2bin ( pool -> nonce1bin , pool -> nonce1 , pool -> n1_len ) ; pool -> n2size = n2size ; cg_wunlock ( & pool -> data_lock ) ; if ( sessionid ) applog ( LOG_DEBUG , ""%s<S2SV_blank>stratum<S2SV_blank>session<S2SV_blank>id:<S2SV_blank>%s"" , get_pool_name ( pool ) , pool -> sessionid ) ; ret = true ; out : if ( ret ) { if ( ! pool -> stratum_url ) pool -> stratum_url = pool -> sockaddr_url ; pool -> stratum_active = true ; pool -> swork . diff = 1 ; if ( opt_protocol ) { applog ( LOG_DEBUG , ""%s<S2SV_blank>confirmed<S2SV_blank>mining.subscribe<S2SV_blank>with<S2SV_blank>extranonce1<S2SV_blank>%s<S2SV_blank>extran2size<S2SV_blank>%d"" , get_pool_name ( pool ) , pool -> nonce1 , pool -> n2size ) ; } } else { if ( recvd && ! noresume ) { cg_wlock ( & pool -> data_lock ) ; free ( pool -> sessionid ) ; free ( pool -> nonce1 ) ; pool -> sessionid = pool -> nonce1 = NULL ; cg_wunlock ( & pool -> data_lock ) ; applog ( LOG_DEBUG , ""Failed<S2SV_blank>to<S2SV_blank>resume<S2SV_blank>stratum,<S2SV_blank>trying<S2SV_blank>afresh"" ) ; noresume = true ; json_decref ( val ) ; goto resend ; } applog ( LOG_DEBUG , ""Initiating<S2SV_blank>stratum<S2SV_blank>failed<S2SV_blank>on<S2SV_blank>%s"" , get_pool_name ( pool ) ) ; if ( sockd ) { applog ( LOG_DEBUG , ""Suspending<S2SV_blank>stratum<S2SV_blank>on<S2SV_blank>%s"" , get_pool_name ( pool ) ) ; suspend_stratum ( pool ) ; } } json_decref ( val ) ; return ret ; }
","<S2SV_ModStart> ; if ( n2size < 1 ) <S2SV_ModEnd> { applog (
"
1179,"CWE-399 int SMB2_tcon ( const unsigned int xid , struct cifs_ses * ses , const char * tree , struct cifs_tcon * tcon , const struct nls_table * cp ) { struct smb2_tree_connect_req * req ; struct smb2_tree_connect_rsp * rsp = NULL ; struct kvec iov [ 2 ] ; int rc = 0 ; int resp_buftype ; int unc_path_len ; struct TCP_Server_Info * server ; __le16 * unc_path = NULL ; cifs_dbg ( FYI , ""TCON\\n"" ) ; if ( ( ses -> server ) && tree ) server = ses -> server ; else return - EIO ; if ( tcon && tcon -> bad_network_name ) return - ENOENT ; unc_path = kmalloc ( MAX_SHARENAME_LENGTH * 2 , GFP_KERNEL ) ; if ( unc_path == NULL ) return - ENOMEM ; unc_path_len = cifs_strtoUTF16 ( unc_path , tree , strlen ( tree ) , cp ) + 1 ; unc_path_len *= 2 ; if ( unc_path_len < 2 ) { kfree ( unc_path ) ; return - EINVAL ; } rc = small_smb2_init ( SMB2_TREE_CONNECT , tcon , ( void * * ) & req ) ; if ( rc ) { kfree ( unc_path ) ; return rc ; } if ( tcon == NULL ) { req -> hdr . SessionId = ses -> Suid ; } iov [ 0 ] . iov_base = ( char * ) req ; iov [ 0 ] . iov_len = get_rfc1002_length ( req ) + 4 - 1 ; req -> PathOffset = cpu_to_le16 ( sizeof ( struct smb2_tree_connect_req ) - 1 - 4 ) ; req -> PathLength = cpu_to_le16 ( unc_path_len - 2 ) ; iov [ 1 ] . iov_base = unc_path ; iov [ 1 ] . iov_len = unc_path_len ; inc_rfc1001_len ( req , unc_path_len - 1 ) ; rc = SendReceive2 ( xid , ses , iov , 2 , & resp_buftype , 0 ) ; rsp = ( struct smb2_tree_connect_rsp * ) iov [ 0 ] . iov_base ; if ( rc != 0 ) { if ( tcon ) { cifs_stats_fail_inc ( tcon , SMB2_TREE_CONNECT_HE ) ; tcon -> need_reconnect = true ; } goto tcon_error_exit ; } if ( tcon == NULL ) { ses -> ipc_tid = rsp -> hdr . TreeId ; goto tcon_exit ; } if ( rsp -> ShareType & SMB2_SHARE_TYPE_DISK ) cifs_dbg ( FYI , ""connection<S2SV_blank>to<S2SV_blank>disk<S2SV_blank>share\\n"" ) ; else if ( rsp -> ShareType & SMB2_SHARE_TYPE_PIPE ) { tcon -> ipc = true ; cifs_dbg ( FYI , ""connection<S2SV_blank>to<S2SV_blank>pipe<S2SV_blank>share\\n"" ) ; } else if ( rsp -> ShareType & SMB2_SHARE_TYPE_PRINT ) { tcon -> print = true ; cifs_dbg ( FYI , ""connection<S2SV_blank>to<S2SV_blank>printer\\n"" ) ; } else { cifs_dbg ( VFS , ""unknown<S2SV_blank>share<S2SV_blank>type<S2SV_blank>%d\\n"" , rsp -> ShareType ) ; rc = - EOPNOTSUPP ; goto tcon_error_exit ; } tcon -> share_flags = le32_to_cpu ( rsp -> ShareFlags ) ; tcon -> capabilities = rsp -> Capabilities ; tcon -> maximal_access = le32_to_cpu ( rsp -> MaximalAccess ) ; tcon -> tidStatus = CifsGood ; tcon -> need_reconnect = false ; tcon -> tid = rsp -> hdr . TreeId ; strlcpy ( tcon -> treeName , tree , sizeof ( tcon -> treeName ) ) ; if ( ( rsp -> Capabilities & SMB2_SHARE_CAP_DFS ) && ( ( tcon -> share_flags & SHI1005_FLAGS_DFS ) == 0 ) ) cifs_dbg ( VFS , ""DFS<S2SV_blank>capability<S2SV_blank>contradicts<S2SV_blank>DFS<S2SV_blank>flag\\n"" ) ; init_copy_chunk_defaults ( tcon ) ; if ( tcon -> ses -> server -> ops -> validate_negotiate ) rc = tcon -> ses -> server -> ops -> validate_negotiate ( xid , tcon ) ; tcon_exit : free_rsp_buf ( resp_buftype , rsp ) ; kfree ( unc_path ) ; return rc ; tcon_error_exit : if ( rsp -> hdr . Status == STATUS_BAD_NETWORK_NAME ) { cifs_dbg ( VFS , ""BAD_NETWORK_NAME:<S2SV_blank>%s\\n"" , tree ) ; <S2SV_StartBug> tcon -> bad_network_name = true ; <S2SV_EndBug> } goto tcon_exit ; }
","<S2SV_ModStart> tree ) ; if ( tcon )
"
1180,"CWE-119 static int netlbl_cipsov4_add_common ( struct genl_info * info , struct cipso_v4_doi * doi_def ) { struct nlattr * nla ; int nla_rem ; u32 iter = 0 ; doi_def -> doi = nla_get_u32 ( info -> attrs [ NLBL_CIPSOV4_A_DOI ] ) ; if ( nla_validate_nested ( info -> attrs [ NLBL_CIPSOV4_A_TAGLST ] , NLBL_CIPSOV4_A_MAX , netlbl_cipsov4_genl_policy ) != 0 ) return - EINVAL ; nla_for_each_nested ( nla , info -> attrs [ NLBL_CIPSOV4_A_TAGLST ] , nla_rem ) if ( nla -> nla_type == NLBL_CIPSOV4_A_TAG ) { <S2SV_StartBug> if ( iter > CIPSO_V4_TAG_MAXCNT ) <S2SV_EndBug> return - EINVAL ; doi_def -> tags [ iter ++ ] = nla_get_u8 ( nla ) ; } <S2SV_StartBug> if ( iter < CIPSO_V4_TAG_MAXCNT ) <S2SV_EndBug> <S2SV_StartBug> doi_def -> tags [ iter ] = CIPSO_V4_TAG_INVALID ; <S2SV_EndBug> return 0 ; }
","<S2SV_ModStart> if ( iter >= <S2SV_ModEnd> CIPSO_V4_TAG_MAXCNT ) return <S2SV_ModStart> ) ; } while <S2SV_ModEnd> ( iter < <S2SV_ModStart> tags [ iter ++
"
1181,"CWE-200 static int do_devinfo_ioctl ( struct comedi_device * dev , struct comedi_devinfo __user * arg , struct file * file ) { struct comedi_devinfo devinfo ; const unsigned minor = iminor ( file -> f_dentry -> d_inode ) ; struct comedi_device_file_info * dev_file_info = comedi_get_device_file_info ( minor ) ; struct comedi_subdevice * read_subdev = comedi_get_read_subdevice ( dev_file_info ) ; struct comedi_subdevice * write_subdev = comedi_get_write_subdevice ( dev_file_info ) ; memset ( & devinfo , 0 , sizeof ( devinfo ) ) ; devinfo . version_code = COMEDI_VERSION_CODE ; devinfo . n_subdevs = dev -> n_subdevices ; <S2SV_StartBug> memcpy ( devinfo . driver_name , dev -> driver -> driver_name , COMEDI_NAMELEN ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( devinfo . board_name , dev -> board_name , COMEDI_NAMELEN ) ; <S2SV_EndBug> if ( read_subdev ) devinfo . read_subdevice = read_subdev - dev -> subdevices ; else devinfo . read_subdevice = - 1 ; if ( write_subdev ) devinfo . write_subdevice = write_subdev - dev -> subdevices ; else devinfo . write_subdevice = - 1 ; if ( copy_to_user ( arg , & devinfo , sizeof ( struct comedi_devinfo ) ) ) return - EFAULT ; return 0 ; }
","<S2SV_ModStart> -> n_subdevices ; strlcpy <S2SV_ModEnd> ( devinfo . <S2SV_ModStart> COMEDI_NAMELEN ) ; strlcpy <S2SV_ModEnd> ( devinfo .
"
1182,"CWE-20 int rose_parse_facilities ( unsigned char * p , struct rose_facilities_struct * facilities ) { int facilities_len , len ; facilities_len = * p ++ ; if ( facilities_len == 0 ) return 0 ; while ( facilities_len > 0 ) { if ( * p == 0x00 ) { facilities_len -- ; p ++ ; switch ( * p ) { case FAC_NATIONAL : len = rose_parse_national ( p + 1 , facilities , facilities_len - 1 ) ; <S2SV_StartBug> facilities_len -= len + 1 ; <S2SV_EndBug> p += len + 1 ; break ; case FAC_CCITT : len = rose_parse_ccitt ( p + 1 , facilities , facilities_len - 1 ) ; <S2SV_StartBug> facilities_len -= len + 1 ; <S2SV_EndBug> p += len + 1 ; break ; default : printk ( KERN_DEBUG ""ROSE:<S2SV_blank>rose_parse_facilities<S2SV_blank>-<S2SV_blank>unknown<S2SV_blank>facilities<S2SV_blank>family<S2SV_blank>%02X\\n"" , * p ) ; facilities_len -- ; p ++ ; break ; } } else break ; } return 1 ; }
","<S2SV_ModStart> 1 ) ; if ( len < 0 ) return 0 ; <S2SV_ModStart> 1 ) ; if ( len < 0 ) return 0 ;
"
1183,"CWE-284 int btsock_thread_exit ( int h ) { if ( h < 0 || h >= MAX_THREAD ) { APPL_TRACE_ERROR ( ""invalid<S2SV_blank>bt<S2SV_blank>thread<S2SV_blank>handle:%d"" , h ) ; return FALSE ; } if ( ts [ h ] . cmd_fdw == - 1 ) { APPL_TRACE_ERROR ( ""cmd<S2SV_blank>socket<S2SV_blank>is<S2SV_blank>not<S2SV_blank>created"" ) ; return FALSE ; } sock_cmd_t cmd = { CMD_EXIT , 0 , 0 , 0 , 0 } ; <S2SV_StartBug> if ( send ( ts [ h ] . cmd_fdw , & cmd , sizeof ( cmd ) , 0 ) == sizeof ( cmd ) ) <S2SV_EndBug> { pthread_join ( ts [ h ] . thread_id , 0 ) ; pthread_mutex_lock ( & thread_slot_lock ) ; free_thread_slot ( h ) ; pthread_mutex_unlock ( & thread_slot_lock ) ; return TRUE ; } return FALSE ; }
","<S2SV_ModStart> ; if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) , 0 )
"
1184,"CWE-119 static krb5_error_code get_matching_data ( krb5_context context , pkinit_plg_crypto_context plg_cryptoctx , pkinit_req_crypto_context req_cryptoctx , X509 * cert , pkinit_cert_matching_data * * md_out ) { krb5_error_code ret = ENOMEM ; pkinit_cert_matching_data * md = NULL ; krb5_principal * pkinit_sans = NULL , * upn_sans = NULL ; size_t i , j ; <S2SV_StartBug> char buf [ DN_BUF_LEN ] ; <S2SV_EndBug> unsigned int bufsize = sizeof ( buf ) ; * md_out = NULL ; md = calloc ( 1 , sizeof ( * md ) ) ; if ( md == NULL ) goto cleanup ; <S2SV_StartBug> X509_NAME_oneline_ex ( X509_get_subject_name ( cert ) , buf , & bufsize , <S2SV_EndBug> XN_FLAG_SEP_COMMA_PLUS ) ; <S2SV_StartBug> md -> subject_dn = strdup ( buf ) ; <S2SV_EndBug> if ( md -> subject_dn == NULL ) { ret = ENOMEM ; goto cleanup ; } <S2SV_StartBug> X509_NAME_oneline_ex ( X509_get_issuer_name ( cert ) , buf , & bufsize , <S2SV_EndBug> XN_FLAG_SEP_COMMA_PLUS ) ; <S2SV_StartBug> md -> issuer_dn = strdup ( buf ) ; <S2SV_EndBug> if ( md -> issuer_dn == NULL ) { ret = ENOMEM ; goto cleanup ; } ret = crypto_retrieve_X509_sans ( context , plg_cryptoctx , req_cryptoctx , cert , & pkinit_sans , & upn_sans , NULL ) ; if ( ret ) goto cleanup ; j = 0 ; if ( pkinit_sans != NULL ) { for ( i = 0 ; pkinit_sans [ i ] != NULL ; i ++ ) j ++ ; } if ( upn_sans != NULL ) { for ( i = 0 ; upn_sans [ i ] != NULL ; i ++ ) j ++ ; } if ( j != 0 ) { md -> sans = calloc ( ( size_t ) j + 1 , sizeof ( * md -> sans ) ) ; if ( md -> sans == NULL ) { ret = ENOMEM ; goto cleanup ; } j = 0 ; if ( pkinit_sans != NULL ) { for ( i = 0 ; pkinit_sans [ i ] != NULL ; i ++ ) md -> sans [ j ++ ] = pkinit_sans [ i ] ; free ( pkinit_sans ) ; } if ( upn_sans != NULL ) { for ( i = 0 ; upn_sans [ i ] != NULL ; i ++ ) md -> sans [ j ++ ] = upn_sans [ i ] ; free ( upn_sans ) ; } md -> sans [ j ] = NULL ; } else md -> sans = NULL ; ret = crypto_retrieve_X509_key_usage ( context , plg_cryptoctx , req_cryptoctx , cert , & md -> ku_bits , & md -> eku_bits ) ; if ( ret ) goto cleanup ; * md_out = md ; md = NULL ; cleanup : crypto_cert_free_matching_data ( context , md ) ; return ret ; }
","<S2SV_ModStart> , j ; * md_out = NULL ; md = calloc ( 1 , sizeof ( <S2SV_ModEnd> * md ) <S2SV_ModStart> goto cleanup ; ret = rfc2253_name <S2SV_ModEnd> ( X509_get_subject_name ( <S2SV_ModStart> cert ) , & <S2SV_ModEnd> md -> subject_dn <S2SV_ModStart> md -> subject_dn ) ; if ( ret ) goto cleanup ; ret = rfc2253_name <S2SV_ModEnd> ( X509_get_issuer_name ( <S2SV_ModStart> cert ) , & <S2SV_ModEnd> md -> issuer_dn <S2SV_ModStart> md -> issuer_dn ) ; if ( ret ) goto cleanup ; <S2SV_ModEnd> ret = crypto_retrieve_X509_sans
"
1185,"CWE-119 <S2SV_StartBug> static int get_max_filter_level ( VP9_COMP * cpi ) { <S2SV_EndBug> return cpi -> twopass . section_intra_rating > 8 ? MAX_LOOP_FILTER * 3 / 4 : MAX_LOOP_FILTER ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> int get_max_filter_level ( const <S2SV_ModStart> VP9_COMP * cpi ) { if ( cpi -> oxcf . pass == 2 <S2SV_ModStart> MAX_LOOP_FILTER ; } else { return MAX_LOOP_FILTER ; } }
"
1186,"CWE-000 int luaG_traceexec ( lua_State * L , const Instruction * pc ) { CallInfo * ci = L -> ci ; lu_byte mask = L -> hookmask ; <S2SV_StartBug> int counthook ; <S2SV_EndBug> if ( ! ( mask & ( LUA_MASKLINE | LUA_MASKCOUNT ) ) ) { ci -> u . l . trap = 0 ; return 0 ; } pc ++ ; ci -> u . l . savedpc = pc ; counthook = ( -- L -> hookcount == 0 && ( mask & LUA_MASKCOUNT ) ) ; if ( counthook ) resethookcount ( L ) ; else if ( ! ( mask & LUA_MASKLINE ) ) return 1 ; if ( ci -> callstatus & CIST_HOOKYIELD ) { ci -> callstatus &= ~ CIST_HOOKYIELD ; return 1 ; } if ( ! isIT ( * ( ci -> u . l . savedpc - 1 ) ) ) L -> top = ci -> top ; if ( counthook ) luaD_hook ( L , LUA_HOOKCOUNT , - 1 , 0 , 0 ) ; if ( mask & LUA_MASKLINE ) { <S2SV_StartBug> const Proto * p = ci_func ( ci ) -> p ; <S2SV_EndBug> int npci = pcRel ( pc , p ) ; if ( npci == 0 || <S2SV_StartBug> pc <= L -> oldpc || <S2SV_EndBug> <S2SV_StartBug> changedline ( p , pcRel ( L -> oldpc , p ) , npci ) ) { <S2SV_EndBug> int newline = luaG_getfuncline ( p , npci ) ; luaD_hook ( L , LUA_HOOKLINE , newline , 0 , 0 ) ; } <S2SV_StartBug> L -> oldpc = pc ; <S2SV_EndBug> } if ( L -> status == LUA_YIELD ) { if ( counthook ) L -> hookcount = 1 ; ci -> u . l . savedpc -- ; ci -> callstatus |= CIST_HOOKYIELD ; luaD_throw ( L , LUA_YIELD ) ; } return 1 ; }
","<S2SV_ModStart> -> hookmask ; const Proto * p = ci_func ( ci ) -> p ; int counthook ; int oldpc = ( L -> oldpc < p -> sizecode ) ? L -> oldpc : 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> LUA_MASKLINE ) { <S2SV_ModEnd> int npci = <S2SV_ModStart> || pc <= invpcRel ( oldpc , p ) <S2SV_ModEnd> || changedline ( <S2SV_ModStart> ( p , oldpc <S2SV_ModEnd> , npci ) <S2SV_ModStart> -> oldpc = npci <S2SV_ModEnd> ; } if
"
