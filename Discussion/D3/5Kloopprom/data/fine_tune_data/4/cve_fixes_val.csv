,source,target,group
0,"buggy line: resend : if ( ! setup_stratum_socket ( pool ) ) {sockd = false ;goto out ;}sockd = true ;if ( recvd ) {clear_sock ( pool ) ;sprintf ( s , ""{\\\\""id\\\\"":<S2SV_blank>%d,<S2SV_blank>\\\\""method\\\\"":<S2SV_blank>\\\\""mining.subscribe\\\\"",<S2SV_blank>\\\\""params\\\\"":<S2SV_blank>[]}"" , swork_id ++ ) ;}else {if ( pool -> sessionid ) sprintf ( s , ""{\\\\""id\\\\"":<S2SV_blank>%d,<S2SV_blank>\\\\""method\\\\"":<S2SV_blank>\\\\""mining.subscribe\\\\"",<S2SV_blank>\\\\""params\\\\"":<S2SV_blank>[\\\\"""" PACKAGE ""/"" VERSION ""\\\\"",<S2SV_blank>\\\\""%s\\\\""]}"" , swork_id ++ , pool -> sessionid ) ;else sprintf ( s , ""{\\\\""id\\\\"":<S2SV_blank>%d,<S2SV_blank>\\\\""method\\\\"":<S2SV_blank>\\\\""mining.subscribe\\\\"",<S2SV_blank>\\\\""params\\\\"":<S2SV_blank>[\\\\"""" PACKAGE ""/"" VERSION ""\\\\""]}"" , swork_id ++ ) ;}if ( __stratum_send ( pool , s , strlen ( s ) ) != SEND_OK ) {cwe id:CWE-119context: bool initiate_stratum ( struct pool * pool ) { bool ret = false , recvd = false , noresume = false , sockd = false ; char s [ RBUFSIZE ] , * sret = NULL , * nonce1 , * sessionid ; json_t * val = NULL , * res_val , * err_val ; json_error_t err ; int n2size ; resend : if ( ! setup_stratum_socket ( pool ) ) { sockd = false ; goto out ; } sockd = true ; if ( recvd ) { clear_sock ( pool ) ; sprintf ( s , ""{\\""id\\"":<S2SV_blank>%d,<S2SV_blank>\\""method\\"":<S2SV_blank>\\""mining.subscribe\\"",<S2SV_blank>\\""params\\"":<S2SV_blank>[]}"" , swork_id ++ ) ; } else { if ( pool -> sessionid ) sprintf ( s , ""{\\""id\\"":<S2SV_blank>%d,<S2SV_blank>\\""method\\"":<S2SV_blank>\\""mining.subscribe\\"",<S2SV_blank>\\""params\\"":<S2SV_blank>[\\"""" PACKAGE ""/"" VERSION ""\\"",<S2SV_blank>\\""%s\\""]}"" , swork_id ++ , pool -> sessionid ) ; else sprintf ( s , ""{\\""id\\"":<S2SV_blank>%d,<S2SV_blank>\\""method\\"":<S2SV_blank>\\""mining.subscribe\\"",<S2SV_blank>\\""params\\"":<S2SV_blank>[\\"""" PACKAGE ""/"" VERSION ""\\""]}"" , swork_id ++ ) ; } if ( __stratum_send ( pool , s , strlen ( s ) ) != SEND_OK ) { applog ( LOG_DEBUG , ""Failed<S2SV_blank>to<S2SV_blank>send<S2SV_blank>s<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; goto out ; } if ( ! socket_full ( pool , DEFAULT_SOCKWAIT ) ) { applog ( LOG_DEBUG , ""Timed<S2SV_blank>out<S2SV_blank>waiting<S2SV_blank>for<S2SV_blank>response<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; goto out ; } sret = recv_line ( pool ) ; if ( ! sret ) goto out ; recvd = true ; val = JSON_LOADS ( sret , & err ) ; free ( sret ) ; if ( ! val ) { applog ( LOG_INFO , ""JSON<S2SV_blank>decode<S2SV_blank>failed(%d):<S2SV_blank>%s"" , err . line , err . text ) ; goto out ; } res_val = json_object_get ( val , ""result"" ) ; err_val = json_object_get ( val , ""error"" ) ; if ( ! res_val || json_is_null ( res_val ) || ( err_val && ! json_is_null ( err_val ) ) ) { char * ss ; if ( err_val ) ss = json_dumps ( err_val , JSON_INDENT ( 3 ) ) ; else ss = strdup ( ""(unknown<S2SV_blank>reason)"" ) ; applog ( LOG_INFO , ""JSON-RPC<S2SV_blank>decode<S2SV_blank>failed:<S2SV_blank>%s"" , ss ) ; free ( ss ) ; goto out ; } sessionid = get_sessionid ( res_val ) ; if ( ! sessionid ) applog ( LOG_DEBUG , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>sessionid<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; nonce1 = json_array_string ( res_val , 1 ) ;  if ( ! nonce1 ) {   applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>nonce1<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ;  free ( sessionid ) ; goto out ; } n2size = json_integer_value ( json_array_get ( res_val , 2 ) ) ;  if ( ! n2size ) {   applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ;  free ( sessionid ) ; free ( nonce1 ) ; goto out ; } cg_wlock ( & pool -> data_lock ) ; pool -> sessionid = sessionid ; pool -> nonce1 = nonce1 ; pool -> n1_len = strlen ( nonce1 ) / 2 ; free ( pool -> nonce1bin ) ; pool -> nonce1bin = calloc ( pool -> n1_len , 1 ) ; if ( unlikely ( ! pool -> nonce1bin ) ) quithere ( 1 , ""Failed<S2SV_blank>to<S2SV_blank>calloc<S2SV_blank>pool->nonce1bin"" ) ; hex2bin ( pool -> nonce1bin , pool -> nonce1 , pool -> n1_len ) ; pool -> n2size = n2size ; cg_wunlock ( & pool -> data_lock ) ; if ( sessionid ) applog ( LOG_DEBUG , ""Pool<S2SV_blank>%d<S2SV_blank>stratum<S2SV_blank>session<S2SV_blank>id:<S2SV_blank>%s"" , pool -> pool_no , pool -> sessionid ) ; ret = true ; out : if ( ret ) { if ( ! pool -> stratum_url ) pool -> stratum_url = pool -> sockaddr_url ; pool -> stratum_active = true ; pool -> sdiff = 1 ; if ( opt_protocol ) { applog ( LOG_DEBUG , ""Pool<S2SV_blank>%d<S2SV_blank>confirmed<S2SV_blank>mining.subscribe<S2SV_blank>with<S2SV_blank>extranonce1<S2SV_blank>%s<S2SV_blank>extran2size<S2SV_blank>%d"" , pool -> pool_no , pool -> nonce1 , pool -> n2size ) ; } } else { if ( recvd && ! noresume ) { cg_wlock ( & pool -> data_lock ) ; free ( pool -> sessionid ) ; free ( pool -> nonce1 ) ; pool -> sessionid = pool -> nonce1 = NULL ; cg_wunlock ( & pool -> data_lock ) ; applog ( LOG_DEBUG , ""Failed<S2SV_blank>to<S2SV_blank>resume<S2SV_blank>stratum,<S2SV_blank>trying<S2SV_blank>afresh"" ) ; noresume = true ; json_decref ( val ) ; goto resend ; } applog ( LOG_DEBUG , ""Initiate<S2SV_blank>stratum<S2SV_blank>failed"" ) ; if ( sockd ) suspend_stratum ( pool ) ; } json_decref ( val ) ; return ret ; }",resend : if ( ! valid_hex ( nonce1 ) ) {,0
1,"buggy line: applog ( LOG_INFO , ""JSON-RPC<S2SV_blank>decode<S2SV_blank>failed:<S2SV_blank>%s"" , ss ) ;if ( ! sessionid ) applog ( LOG_DEBUG , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>sessionid<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ;nonce1 = json_array_string ( res_val , 1 ) ;if ( ! nonce1 ) {applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>nonce1<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ;free ( sessionid ) ;if ( ! n2size ) {applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ;free ( sessionid ) ;cwe id:CWE-119context: bool initiate_stratum ( struct pool * pool ) { bool ret = false , recvd = false , noresume = false , sockd = false ; char s [ RBUFSIZE ] , * sret = NULL , * nonce1 , * sessionid ; json_t * val = NULL , * res_val , * err_val ; json_error_t err ; int n2size ; resend : if ( ! setup_stratum_socket ( pool ) ) { sockd = false ; goto out ; } sockd = true ; if ( recvd ) { clear_sock ( pool ) ; sprintf ( s , ""{\\""id\\"":<S2SV_blank>%d,<S2SV_blank>\\""method\\"":<S2SV_blank>\\""mining.subscribe\\"",<S2SV_blank>\\""params\\"":<S2SV_blank>[]}"" , swork_id ++ ) ; } else { if ( pool -> sessionid ) sprintf ( s , ""{\\""id\\"":<S2SV_blank>%d,<S2SV_blank>\\""method\\"":<S2SV_blank>\\""mining.subscribe\\"",<S2SV_blank>\\""params\\"":<S2SV_blank>[\\"""" PACKAGE ""/"" VERSION ""\\"",<S2SV_blank>\\""%s\\""]}"" , swork_id ++ , pool -> sessionid ) ; else sprintf ( s , ""{\\""id\\"":<S2SV_blank>%d,<S2SV_blank>\\""method\\"":<S2SV_blank>\\""mining.subscribe\\"",<S2SV_blank>\\""params\\"":<S2SV_blank>[\\"""" PACKAGE ""/"" VERSION ""\\""]}"" , swork_id ++ ) ; } if ( __stratum_send ( pool , s , strlen ( s ) ) != SEND_OK ) { applog ( LOG_DEBUG , ""Failed<S2SV_blank>to<S2SV_blank>send<S2SV_blank>s<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; goto out ; } if ( ! socket_full ( pool , DEFAULT_SOCKWAIT ) ) { applog ( LOG_DEBUG , ""Timed<S2SV_blank>out<S2SV_blank>waiting<S2SV_blank>for<S2SV_blank>response<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; goto out ; } sret = recv_line ( pool ) ; if ( ! sret ) goto out ; recvd = true ; val = JSON_LOADS ( sret , & err ) ; free ( sret ) ; if ( ! val ) { applog ( LOG_INFO , ""JSON<S2SV_blank>decode<S2SV_blank>failed(%d):<S2SV_blank>%s"" , err . line , err . text ) ; goto out ; } res_val = json_object_get ( val , ""result"" ) ; err_val = json_object_get ( val , ""error"" ) ; if ( ! res_val || json_is_null ( res_val ) || ( err_val && ! json_is_null ( err_val ) ) ) { char * ss ; if ( err_val ) ss = json_dumps ( err_val , JSON_INDENT ( 3 ) ) ; else ss = strdup ( ""(unknown<S2SV_blank>reason)"" ) ; applog ( LOG_INFO , ""JSON-RPC<S2SV_blank>decode<S2SV_blank>failed:<S2SV_blank>%s"" , ss ) ; free ( ss ) ; goto out ; } sessionid = get_sessionid ( res_val ) ; if ( ! sessionid ) applog ( LOG_DEBUG , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>sessionid<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; nonce1 = json_array_string ( res_val , 1 ) ;  if ( ! nonce1 ) {   applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>nonce1<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ;  free ( sessionid ) ; goto out ; } n2size = json_integer_value ( json_array_get ( res_val , 2 ) ) ;  if ( ! n2size ) {   applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ;  free ( sessionid ) ; free ( nonce1 ) ; goto out ; } cg_wlock ( & pool -> data_lock ) ; pool -> sessionid = sessionid ; pool -> nonce1 = nonce1 ; pool -> n1_len = strlen ( nonce1 ) / 2 ; free ( pool -> nonce1bin ) ; pool -> nonce1bin = calloc ( pool -> n1_len , 1 ) ; if ( unlikely ( ! pool -> nonce1bin ) ) quithere ( 1 , ""Failed<S2SV_blank>to<S2SV_blank>calloc<S2SV_blank>pool->nonce1bin"" ) ; hex2bin ( pool -> nonce1bin , pool -> nonce1 , pool -> n1_len ) ; pool -> n2size = n2size ; cg_wunlock ( & pool -> data_lock ) ; if ( sessionid ) applog ( LOG_DEBUG , ""Pool<S2SV_blank>%d<S2SV_blank>stratum<S2SV_blank>session<S2SV_blank>id:<S2SV_blank>%s"" , pool -> pool_no , pool -> sessionid ) ; ret = true ; out : if ( ret ) { if ( ! pool -> stratum_url ) pool -> stratum_url = pool -> sockaddr_url ; pool -> stratum_active = true ; pool -> sdiff = 1 ; if ( opt_protocol ) { applog ( LOG_DEBUG , ""Pool<S2SV_blank>%d<S2SV_blank>confirmed<S2SV_blank>mining.subscribe<S2SV_blank>with<S2SV_blank>extranonce1<S2SV_blank>%s<S2SV_blank>extran2size<S2SV_blank>%d"" , pool -> pool_no , pool -> nonce1 , pool -> n2size ) ; } } else { if ( recvd && ! noresume ) { cg_wlock ( & pool -> data_lock ) ; free ( pool -> sessionid ) ; free ( pool -> nonce1 ) ; pool -> sessionid = pool -> nonce1 = NULL ; cg_wunlock ( & pool -> data_lock ) ; applog ( LOG_DEBUG , ""Failed<S2SV_blank>to<S2SV_blank>resume<S2SV_blank>stratum,<S2SV_blank>trying<S2SV_blank>afresh"" ) ; noresume = true ; json_decref ( val ) ; goto resend ; } applog ( LOG_DEBUG , ""Initiate<S2SV_blank>stratum<S2SV_blank>failed"" ) ; if ( sockd ) suspend_stratum ( pool ) ; } json_decref ( val ) ; return ret ; }","applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>valid<S2SV_blank>nonce1<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ;if ( n2size < 2 || n2size > 16 ) {applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>nonce1<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ;free ( sessionid ) ;if ( ! n2size ) {applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>valid<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ;free ( sessionid ) ;",0
2,"buggy line: ND_PRINT ( ( ndo , ""%s<S2SV_blank>(%u)<S2SV_blank>v%u,<S2SV_blank>len<S2SV_blank>%u"" , tok2str ( eap_frame_type_values , ""unknown"" , eap -> type ) , eap -> type , eap -> version , EXTRACT_16BITS ( eap -> length ) ) ) ;tptr += sizeof ( const struct eap_frame_t ) ;tlen -= sizeof ( const struct eap_frame_t ) ;switch ( eap -> type ) {case EAP_FRAME_TYPE_PACKET :  type = * ( tptr ) ;len = EXTRACT_16BITS ( tptr + 2 ) ;subtype = * ( tptr + 4 ) ;ND_PRINT ( ( ndo , ""\\\cwe id:CWE-125context: void eap_print ( netdissect_options * ndo , register const u_char * cp , u_int length ) { const struct eap_frame_t * eap ; const u_char * tptr ; u_int tlen , type , subtype ; int count = 0 , len ; tptr = cp ; tlen = length ; eap = ( const struct eap_frame_t * ) cp ; ND_TCHECK ( * eap ) ; if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , ""%s<S2SV_blank>(%u)<S2SV_blank>v%u,<S2SV_blank>len<S2SV_blank>%u"" , tok2str ( eap_frame_type_values , ""unknown"" , eap -> type ) , eap -> type , eap -> version , EXTRACT_16BITS ( eap -> length ) ) ) ; return ; } ND_PRINT ( ( ndo , ""%s<S2SV_blank>(%u)<S2SV_blank>v%u,<S2SV_blank>len<S2SV_blank>%u"" , tok2str ( eap_frame_type_values , ""unknown"" , eap -> type ) , eap -> type , eap -> version , EXTRACT_16BITS ( eap -> length ) ) ) ; tptr += sizeof ( const struct eap_frame_t ) ; tlen -= sizeof ( const struct eap_frame_t ) ; switch ( eap -> type ) { case EAP_FRAME_TYPE_PACKET :  type = * ( tptr ) ;  len = EXTRACT_16BITS ( tptr + 2 ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>id<S2SV_blank>%u,<S2SV_blank>len<S2SV_blank>%u"" , tok2str ( eap_code_values , ""unknown"" , type ) , type , * ( tptr + 1 ) , len ) ) ; ND_TCHECK2 ( * tptr , len ) ; if ( type <= 2 ) {  subtype = * ( tptr + 4 ) ;  ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank>Type<S2SV_blank>%s<S2SV_blank>(%u)"" ,  tok2str ( eap_type_values , ""unknown"" , * ( tptr + 4 ) ) ,  * ( tptr + 4 ) ) ) ; switch ( subtype ) { case EAP_TYPE_IDENTITY : if ( len - 5 > 0 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>Identity:<S2SV_blank>"" ) ) ; safeputs ( ndo , tptr + 5 , len - 5 ) ; } break ; case EAP_TYPE_NOTIFICATION : if ( len - 5 > 0 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>Notification:<S2SV_blank>"" ) ) ; safeputs ( ndo , tptr + 5 , len - 5 ) ; } break ; case EAP_TYPE_NAK : count = 5 ; while ( count < len ) {  ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>(%u),"" ,  tok2str ( eap_type_values , ""unknown"" , * ( tptr + count ) ) , * ( tptr + count ) ) ) ; count ++ ; } break ; case EAP_TYPE_TTLS :  ND_PRINT ( ( ndo , ""<S2SV_blank>TTLSv%u"" ,  EAP_TTLS_VERSION ( * ( tptr + 5 ) ) ) ) ;  case EAP_TYPE_TLS :  ND_PRINT ( ( ndo , ""<S2SV_blank>flags<S2SV_blank>[%s]<S2SV_blank>0x%02x,"" , bittok2str ( eap_tls_flags_values , ""none"" , * ( tptr + 5 ) ) , * ( tptr + 5 ) ) ) ; if ( EAP_TLS_EXTRACT_BIT_L ( * ( tptr + 5 ) ) ) {  ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr + 6 ) ) ) ;  } break ; case EAP_TYPE_FAST :  ND_PRINT ( ( ndo , ""<S2SV_blank>FASTv%u"" ,  EAP_TTLS_VERSION ( * ( tptr + 5 ) ) ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>flags<S2SV_blank>[%s]<S2SV_blank>0x%02x,"" , bittok2str ( eap_tls_flags_values , ""none"" , * ( tptr + 5 ) ) , * ( tptr + 5 ) ) ) ; if ( EAP_TLS_EXTRACT_BIT_L ( * ( tptr + 5 ) ) ) {  ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr + 6 ) ) ) ;  } break ; case EAP_TYPE_AKA : case EAP_TYPE_SIM :  ND_PRINT ( ( ndo , ""<S2SV_blank>subtype<S2SV_blank>[%s]<S2SV_blank>0x%02x,"" ,  tok2str ( eap_aka_subtype_values , ""unknown"" , * ( tptr + 5 ) ) , * ( tptr + 5 ) ) ) ; break ; case EAP_TYPE_MD5_CHALLENGE : case EAP_TYPE_OTP : case EAP_TYPE_GTC : case EAP_TYPE_EXPANDED_TYPES : case EAP_TYPE_EXPERIMENTAL : default : break ; } } break ; case EAP_FRAME_TYPE_LOGOFF : case EAP_FRAME_TYPE_ENCAP_ASF_ALERT : default : break ; } return ; trunc : ND_PRINT ( ( ndo , ""\\n\\t[|EAP]"" ) ) ; }","ND_PRINT ( ( ndo , ""%s<S2SV_blank>(%u)<S2SV_blank>v%u,<S2SV_blank>len<S2SV_blank>%u"" , tok2str ( eap_frame_type_values , ""unknown"" , subtype ) , subtype ) ) ;ND_TCHECK_8BITS ( tptr + 4 ) ;subtype = * ( tptr + 4 ) ;ND_PRINT ( ( ndo , ""\\\",1
3,"buggy line: ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>(%u),"" ,  tok2str ( eap_type_values , ""unknown"" , * ( tptr + count ) ) , * ( tptr + count ) ) ) ;case EAP_TYPE_TTLS :  ND_PRINT ( ( ndo , ""<S2SV_blank>TTLSv%u"" ,  EAP_TTLS_VERSION ( * ( tptr + 5 ) ) ) ) ;case EAP_TYPE_TLS :  ND_PRINT ( ( ndo , ""<S2SV_blank>flags<S2SV_blank>[%s]<S2SV_blank>0x%02x,"" , bittok2str ( eap_tls_flags_values , ""none"" , * ( tptr + 5 ) ) , * ( tptr + 5 ) ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr + 6 ) ) ) ;}case EAP_TYPE_FAST :  ND_PRINT ( ( ndo , ""<S2SV_blank>FASTv%u"" ,  EAP_TTLS_VERSION ( * ( tptr + 5 ) ) ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr + 6 ) ) ) ;}case EAP_TYPE_AKA : case EAP_TYPE_SIM :  ND_PRINT ( ( ndo , ""<S2SV_blank>subtype<S2SV_blank>[%s]<S2SV_blank>0x%02x,"" ,  tok2str ( eap_aka_subtype_values , ""unknown"" , * ( tptr + 5 ) ) , * ( tptr + 5 ) ) ) ;cwe id:CWE-125context: void eap_print ( netdissect_options * ndo , register const u_char * cp , u_int length ) { const struct eap_frame_t * eap ; const u_char * tptr ; u_int tlen , type , subtype ; int count = 0 , len ; tptr = cp ; tlen = length ; eap = ( const struct eap_frame_t * ) cp ; ND_TCHECK ( * eap ) ; if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , ""%s<S2SV_blank>(%u)<S2SV_blank>v%u,<S2SV_blank>len<S2SV_blank>%u"" , tok2str ( eap_frame_type_values , ""unknown"" , eap -> type ) , eap -> type , eap -> version , EXTRACT_16BITS ( eap -> length ) ) ) ; return ; } ND_PRINT ( ( ndo , ""%s<S2SV_blank>(%u)<S2SV_blank>v%u,<S2SV_blank>len<S2SV_blank>%u"" , tok2str ( eap_frame_type_values , ""unknown"" , eap -> type ) , eap -> type , eap -> version , EXTRACT_16BITS ( eap -> length ) ) ) ; tptr += sizeof ( const struct eap_frame_t ) ; tlen -= sizeof ( const struct eap_frame_t ) ; switch ( eap -> type ) { case EAP_FRAME_TYPE_PACKET :  type = * ( tptr ) ;  len = EXTRACT_16BITS ( tptr + 2 ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>id<S2SV_blank>%u,<S2SV_blank>len<S2SV_blank>%u"" , tok2str ( eap_code_values , ""unknown"" , type ) , type , * ( tptr + 1 ) , len ) ) ; ND_TCHECK2 ( * tptr , len ) ; if ( type <= 2 ) {  subtype = * ( tptr + 4 ) ;  ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank>Type<S2SV_blank>%s<S2SV_blank>(%u)"" ,  tok2str ( eap_type_values , ""unknown"" , * ( tptr + 4 ) ) ,  * ( tptr + 4 ) ) ) ; switch ( subtype ) { case EAP_TYPE_IDENTITY : if ( len - 5 > 0 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>Identity:<S2SV_blank>"" ) ) ; safeputs ( ndo , tptr + 5 , len - 5 ) ; } break ; case EAP_TYPE_NOTIFICATION : if ( len - 5 > 0 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>Notification:<S2SV_blank>"" ) ) ; safeputs ( ndo , tptr + 5 , len - 5 ) ; } break ; case EAP_TYPE_NAK : count = 5 ; while ( count < len ) {  ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>(%u),"" ,  tok2str ( eap_type_values , ""unknown"" , * ( tptr + count ) ) , * ( tptr + count ) ) ) ; count ++ ; } break ; case EAP_TYPE_TTLS :  ND_PRINT ( ( ndo , ""<S2SV_blank>TTLSv%u"" ,  EAP_TTLS_VERSION ( * ( tptr + 5 ) ) ) ) ;  case EAP_TYPE_TLS :  ND_PRINT ( ( ndo , ""<S2SV_blank>flags<S2SV_blank>[%s]<S2SV_blank>0x%02x,"" , bittok2str ( eap_tls_flags_values , ""none"" , * ( tptr + 5 ) ) , * ( tptr + 5 ) ) ) ; if ( EAP_TLS_EXTRACT_BIT_L ( * ( tptr + 5 ) ) ) {  ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr + 6 ) ) ) ;  } break ; case EAP_TYPE_FAST :  ND_PRINT ( ( ndo , ""<S2SV_blank>FASTv%u"" ,  EAP_TTLS_VERSION ( * ( tptr + 5 ) ) ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>flags<S2SV_blank>[%s]<S2SV_blank>0x%02x,"" , bittok2str ( eap_tls_flags_values , ""none"" , * ( tptr + 5 ) ) , * ( tptr + 5 ) ) ) ; if ( EAP_TLS_EXTRACT_BIT_L ( * ( tptr + 5 ) ) ) {  ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr + 6 ) ) ) ;  } break ; case EAP_TYPE_AKA : case EAP_TYPE_SIM :  ND_PRINT ( ( ndo , ""<S2SV_blank>subtype<S2SV_blank>[%s]<S2SV_blank>0x%02x,"" ,  tok2str ( eap_aka_subtype_values , ""unknown"" , * ( tptr + 5 ) ) , * ( tptr + 5 ) ) ) ; break ; case EAP_TYPE_MD5_CHALLENGE : case EAP_TYPE_OTP : case EAP_TYPE_GTC : case EAP_TYPE_EXPANDED_TYPES : case EAP_TYPE_EXPERIMENTAL : default : break ; } } break ; case EAP_FRAME_TYPE_LOGOFF : case EAP_FRAME_TYPE_ENCAP_ASF_ALERT : default : break ; } return ; trunc : ND_PRINT ( ( ndo , ""\\n\\t[|EAP]"" ) ) ; }","ND_TCHECK_8BITS ( tptr + count ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>(%u),"" , tok2str ( eap_type_values , ""unknown"" , * ( tptr + count ) ) , * ( tptr + count ) ) ) ;case EAP_TYPE_TTLS : case EAP_TYPE_TLS : ND_TCHECK_8BITS ( tptr + 5 ) ;if ( subtype == EAP_TYPE_TTLS ) ND_PRINT ( ( ndo , ""<S2SV_blank>TTLSv%u"" , EAP_TTLS_VERSION ( * ( tptr + 5 ) ) ) ) ;case EAP_TYPE_TLS : ND_PRINT ( ( ndo , ""<S2SV_blank>flags<S2SV_blank>[%s]<S2SV_blank>0x%02x,"" , bittok2str ( eap_tls_flags_values , ""none"" , * ( tptr + 5 ) ) , * ( tptr + 5 ) ) ) ;ND_TCHECK_32BITS ( tptr + 6 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr + 6 ) ) ) ;}case EAP_TYPE_FAST : ND_TCHECK_8BITS ( tptr + 5 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>FASTv%u"" , EAP_TTLS_VERSION ( * ( tptr + 5 ) ) ) ) ;ND_TCHECK_32BITS ( tptr + 6 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr + 6 ) ) ) ;}case EAP_TYPE_AKA : case EAP_TYPE_SIM : ND_TCHECK_8BITS ( tptr + 5 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>subtype<S2SV_blank>[%s]<S2SV_blank>0x%02x,"" , tok2str ( eap_aka_subtype_values , ""unknown"" , * ( tptr + 5 ) ) , * ( tptr + 5 ) ) ) ;",1
4,"buggy line: cwe id:CWE-401context: int ath9k_wmi_cmd ( struct wmi * wmi , enum wmi_cmd_id cmd_id , u8 * cmd_buf , u32 cmd_len , u8 * rsp_buf , u32 rsp_len , u32 timeout ) { struct ath_hw * ah = wmi -> drv_priv -> ah ; struct ath_common * common = ath9k_hw_common ( ah ) ; u16 headroom = sizeof ( struct htc_frame_hdr ) + sizeof ( struct wmi_cmd_hdr ) ; struct sk_buff * skb ; unsigned long time_left ; int ret = 0 ; if ( ah -> ah_flags & AH_UNPLUGGED ) return 0 ; skb = alloc_skb ( headroom + cmd_len , GFP_ATOMIC ) ; if ( ! skb ) return - ENOMEM ; skb_reserve ( skb , headroom ) ; if ( cmd_len != 0 && cmd_buf != NULL ) { skb_put_data ( skb , cmd_buf , cmd_len ) ; } mutex_lock ( & wmi -> op_mutex ) ; if ( unlikely ( wmi -> stopped ) ) { ret = - EPROTO ; goto out ; } wmi -> cmd_rsp_buf = rsp_buf ; wmi -> cmd_rsp_len = rsp_len ; ret = ath9k_wmi_cmd_issue ( wmi , skb , cmd_id , cmd_len ) ; if ( ret ) goto out ; time_left = wait_for_completion_timeout ( & wmi -> cmd_wait , timeout ) ; if ( ! time_left ) { ath_dbg ( common , WMI , ""Timeout<S2SV_blank>waiting<S2SV_blank>for<S2SV_blank>WMI<S2SV_blank>command:<S2SV_blank>%s\\n"" , wmi_cmd_to_name ( cmd_id ) ) ; mutex_unlock ( & wmi -> op_mutex ) ;  return - ETIMEDOUT ;  } mutex_unlock ( & wmi -> op_mutex ) ; return 0 ; out : ath_dbg ( common , WMI , ""WMI<S2SV_blank>failure<S2SV_blank>for:<S2SV_blank>%s\\n"" , wmi_cmd_to_name ( cmd_id ) ) ; mutex_unlock ( & wmi -> op_mutex ) ; kfree_skb ( skb ) ; return ret ; }",kfree_skb ( skb ) ;,2
5,"buggy line: return - ETIMEDOUT ;}cwe id:CWE-401context: int ath9k_wmi_cmd ( struct wmi * wmi , enum wmi_cmd_id cmd_id , u8 * cmd_buf , u32 cmd_len , u8 * rsp_buf , u32 rsp_len , u32 timeout ) { struct ath_hw * ah = wmi -> drv_priv -> ah ; struct ath_common * common = ath9k_hw_common ( ah ) ; u16 headroom = sizeof ( struct htc_frame_hdr ) + sizeof ( struct wmi_cmd_hdr ) ; struct sk_buff * skb ; unsigned long time_left ; int ret = 0 ; if ( ah -> ah_flags & AH_UNPLUGGED ) return 0 ; skb = alloc_skb ( headroom + cmd_len , GFP_ATOMIC ) ; if ( ! skb ) return - ENOMEM ; skb_reserve ( skb , headroom ) ; if ( cmd_len != 0 && cmd_buf != NULL ) { skb_put_data ( skb , cmd_buf , cmd_len ) ; } mutex_lock ( & wmi -> op_mutex ) ; if ( unlikely ( wmi -> stopped ) ) { ret = - EPROTO ; goto out ; } wmi -> cmd_rsp_buf = rsp_buf ; wmi -> cmd_rsp_len = rsp_len ; ret = ath9k_wmi_cmd_issue ( wmi , skb , cmd_id , cmd_len ) ; if ( ret ) goto out ; time_left = wait_for_completion_timeout ( & wmi -> cmd_wait , timeout ) ; if ( ! time_left ) { ath_dbg ( common , WMI , ""Timeout<S2SV_blank>waiting<S2SV_blank>for<S2SV_blank>WMI<S2SV_blank>command:<S2SV_blank>%s\\n"" , wmi_cmd_to_name ( cmd_id ) ) ; mutex_unlock ( & wmi -> op_mutex ) ;  return - ETIMEDOUT ;  } mutex_unlock ( & wmi -> op_mutex ) ; return 0 ; out : ath_dbg ( common , WMI , ""WMI<S2SV_blank>failure<S2SV_blank>for:<S2SV_blank>%s\\n"" , wmi_cmd_to_name ( cmd_id ) ) ; mutex_unlock ( & wmi -> op_mutex ) ; kfree_skb ( skb ) ; return ret ; }",return - ETIMEDOUT ;},2
6,"buggy line: case SIOCYAMGCFG :  yi . cfg . mask = 0xffffffff ;yi . cfg . iobase = yp -> iobase ;cwe id:CWE-399context: static int yam_ioctl ( struct net_device * dev , struct ifreq * ifr , int cmd ) { struct yam_port * yp = netdev_priv ( dev ) ; struct yamdrv_ioctl_cfg yi ; struct yamdrv_ioctl_mcs * ym ; int ioctl_cmd ; if ( copy_from_user ( & ioctl_cmd , ifr -> ifr_data , sizeof ( int ) ) ) return - EFAULT ; if ( yp -> magic != YAM_MAGIC ) return - EINVAL ; if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; if ( cmd != SIOCDEVPRIVATE ) return - EINVAL ; switch ( ioctl_cmd ) { case SIOCYAMRESERVED : return - EINVAL ; case SIOCYAMSMCS : if ( netif_running ( dev ) ) return - EINVAL ; if ( ( ym = kmalloc ( sizeof ( struct yamdrv_ioctl_mcs ) , GFP_KERNEL ) ) == NULL ) return - ENOBUFS ; if ( copy_from_user ( ym , ifr -> ifr_data , sizeof ( struct yamdrv_ioctl_mcs ) ) ) { kfree ( ym ) ; return - EFAULT ; } if ( ym -> bitrate > YAM_MAXBITRATE ) { kfree ( ym ) ; return - EINVAL ; } add_mcs ( ym -> bits , ym -> bitrate , 0 ) ; kfree ( ym ) ; break ; case SIOCYAMSCFG : if ( ! capable ( CAP_SYS_RAWIO ) ) return - EPERM ; if ( copy_from_user ( & yi , ifr -> ifr_data , sizeof ( struct yamdrv_ioctl_cfg ) ) ) return - EFAULT ; if ( ( yi . cfg . mask & YAM_IOBASE ) && netif_running ( dev ) ) return - EINVAL ; if ( ( yi . cfg . mask & YAM_IRQ ) && netif_running ( dev ) ) return - EINVAL ; if ( ( yi . cfg . mask & YAM_BITRATE ) && netif_running ( dev ) ) return - EINVAL ; if ( ( yi . cfg . mask & YAM_BAUDRATE ) && netif_running ( dev ) ) return - EINVAL ; if ( yi . cfg . mask & YAM_IOBASE ) { yp -> iobase = yi . cfg . iobase ; dev -> base_addr = yi . cfg . iobase ; } if ( yi . cfg . mask & YAM_IRQ ) { if ( yi . cfg . irq > 15 ) return - EINVAL ; yp -> irq = yi . cfg . irq ; dev -> irq = yi . cfg . irq ; } if ( yi . cfg . mask & YAM_BITRATE ) { if ( yi . cfg . bitrate > YAM_MAXBITRATE ) return - EINVAL ; yp -> bitrate = yi . cfg . bitrate ; } if ( yi . cfg . mask & YAM_BAUDRATE ) { if ( yi . cfg . baudrate > YAM_MAXBAUDRATE ) return - EINVAL ; yp -> baudrate = yi . cfg . baudrate ; } if ( yi . cfg . mask & YAM_MODE ) { if ( yi . cfg . mode > YAM_MAXMODE ) return - EINVAL ; yp -> dupmode = yi . cfg . mode ; } if ( yi . cfg . mask & YAM_HOLDDLY ) { if ( yi . cfg . holddly > YAM_MAXHOLDDLY ) return - EINVAL ; yp -> holdd = yi . cfg . holddly ; } if ( yi . cfg . mask & YAM_TXDELAY ) { if ( yi . cfg . txdelay > YAM_MAXTXDELAY ) return - EINVAL ; yp -> txd = yi . cfg . txdelay ; } if ( yi . cfg . mask & YAM_TXTAIL ) { if ( yi . cfg . txtail > YAM_MAXTXTAIL ) return - EINVAL ; yp -> txtail = yi . cfg . txtail ; } if ( yi . cfg . mask & YAM_PERSIST ) { if ( yi . cfg . persist > YAM_MAXPERSIST ) return - EINVAL ; yp -> pers = yi . cfg . persist ; } if ( yi . cfg . mask & YAM_SLOTTIME ) { if ( yi . cfg . slottime > YAM_MAXSLOTTIME ) return - EINVAL ; yp -> slot = yi . cfg . slottime ; yp -> slotcnt = yp -> slot / 10 ; } break ; case SIOCYAMGCFG :  yi . cfg . mask = 0xffffffff ;  yi . cfg . iobase = yp -> iobase ; yi . cfg . irq = yp -> irq ; yi . cfg . bitrate = yp -> bitrate ; yi . cfg . baudrate = yp -> baudrate ; yi . cfg . mode = yp -> dupmode ; yi . cfg . txdelay = yp -> txd ; yi . cfg . holddly = yp -> holdd ; yi . cfg . txtail = yp -> txtail ; yi . cfg . persist = yp -> pers ; yi . cfg . slottime = yp -> slot ; if ( copy_to_user ( ifr -> ifr_data , & yi , sizeof ( struct yamdrv_ioctl_cfg ) ) ) return - EFAULT ; break ; default : return - EINVAL ; } return 0 ; }","case SIOCYAMGCFG : memset ( & yi , 0 , sizeof ( yi ) ) ;yi . cfg . mask = 0xffffffff ;yi . cfg . iobase = yp -> iobase ;",3
7,"buggy line: if ( unlikely ( skb -> len <= mss ) ) goto out ;if ( skb_gso_ok ( skb , features | NETIF_F_GSO_ROBUST ) ) {int type = skb_shinfo ( skb ) -> gso_type ;if ( unlikely ( type & ~ ( SKB_GSO_UDP | SKB_GSO_DODGY | SKB_GSO_UDP_TUNNEL | SKB_GSO_GRE | SKB_GSO_IPIP | SKB_GSO_SIT | SKB_GSO_MPLS ) || ! ( type & ( SKB_GSO_UDP ) ) ) ) goto out ;skb_shinfo ( skb ) -> gso_segs = DIV_ROUND_UP ( skb -> len , mss ) ;segs = NULL ;goto out ;}if ( skb -> encapsulation && skb_shinfo ( skb ) -> gso_type & SKB_GSO_UDP_TUNNEL ) segs = skb_udp_tunnel_segment ( skb , features ) ;else {offset = skb_checksum_start_offset ( skb ) ;csum = skb_checksum ( skb , offset , skb -> len - offset , 0 ) ;offset += skb -> csum_offset ;* ( __sum16 * ) ( skb -> data + offset ) = csum_fold ( csum ) ;skb -> ip_summed = CHECKSUM_NONE ;tnl_hlen = skb_tnl_header_len ( skb ) ;if ( skb_headroom ( skb ) < ( tnl_hlen + frag_hdr_sz ) ) {if ( gso_pskb_expand_head ( skb , tnl_hlen + frag_hdr_sz ) ) goto out ;cwe id:CWE-189context: static struct sk_buff * udp6_ufo_fragment ( struct sk_buff * skb , netdev_features_t features ) { struct sk_buff * segs = ERR_PTR ( - EINVAL ) ; unsigned int mss ; unsigned int unfrag_ip6hlen , unfrag_len ; struct frag_hdr * fptr ; u8 * packet_start , * prevhdr ; u8 nexthdr ; u8 frag_hdr_sz = sizeof ( struct frag_hdr ) ; int offset ; __wsum csum ; int tnl_hlen ; mss = skb_shinfo ( skb ) -> gso_size ; if ( unlikely ( skb -> len <= mss ) ) goto out ; if ( skb_gso_ok ( skb , features | NETIF_F_GSO_ROBUST ) ) { int type = skb_shinfo ( skb ) -> gso_type ; if ( unlikely ( type & ~ ( SKB_GSO_UDP | SKB_GSO_DODGY | SKB_GSO_UDP_TUNNEL | SKB_GSO_GRE | SKB_GSO_IPIP | SKB_GSO_SIT | SKB_GSO_MPLS ) || ! ( type & ( SKB_GSO_UDP ) ) ) ) goto out ; skb_shinfo ( skb ) -> gso_segs = DIV_ROUND_UP ( skb -> len , mss ) ; segs = NULL ; goto out ; } if ( skb -> encapsulation && skb_shinfo ( skb ) -> gso_type & SKB_GSO_UDP_TUNNEL ) segs = skb_udp_tunnel_segment ( skb , features ) ; else { offset = skb_checksum_start_offset ( skb ) ; csum = skb_checksum ( skb , offset , skb -> len - offset , 0 ) ; offset += skb -> csum_offset ; * ( __sum16 * ) ( skb -> data + offset ) = csum_fold ( csum ) ; skb -> ip_summed = CHECKSUM_NONE ; tnl_hlen = skb_tnl_header_len ( skb ) ;  if ( skb_headroom ( skb ) < ( tnl_hlen + frag_hdr_sz ) ) {  if ( gso_pskb_expand_head ( skb , tnl_hlen + frag_hdr_sz ) ) goto out ; } unfrag_ip6hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; nexthdr = * prevhdr ; * prevhdr = NEXTHDR_FRAGMENT ; unfrag_len = ( skb_network_header ( skb ) - skb_mac_header ( skb ) ) + unfrag_ip6hlen + tnl_hlen ; packet_start = ( u8 * ) skb -> head + SKB_GSO_CB ( skb ) -> mac_offset ; memmove ( packet_start - frag_hdr_sz , packet_start , unfrag_len ) ; SKB_GSO_CB ( skb ) -> mac_offset -= frag_hdr_sz ; skb -> mac_header -= frag_hdr_sz ; skb -> network_header -= frag_hdr_sz ; fptr = ( struct frag_hdr * ) ( skb_network_header ( skb ) + unfrag_ip6hlen ) ; fptr -> nexthdr = nexthdr ; fptr -> reserved = 0 ; ipv6_select_ident ( fptr , ( struct rt6_info * ) skb_dst ( skb ) ) ; segs = skb_segment ( skb , features ) ; } out : return segs ; }","if ( skb -> mac_header < ( tnl_hlen + frag_hdr_sz ) ) {if ( gso_pskb_expand_head ( skb , tnl_hlen + frag_hdr_sz ) ) goto out ;",4
8,"buggy line: int64_t time , offset ;if ( version == 1 ) {cwe id:CWE-834context: static int read_tfra ( MOVContext * mov , AVIOContext * f ) { MOVFragmentIndex * index = NULL ; int version , fieldlength , i , j ; int64_t pos = avio_tell ( f ) ; uint32_t size = avio_rb32 ( f ) ; void * tmp ; if ( avio_rb32 ( f ) != MKBETAG ( 't' , 'f' , 'r' , 'a' ) ) { return 1 ; } av_log ( mov -> fc , AV_LOG_VERBOSE , ""found<S2SV_blank>tfra\\n"" ) ; index = av_mallocz ( sizeof ( MOVFragmentIndex ) ) ; if ( ! index ) { return AVERROR ( ENOMEM ) ; } tmp = av_realloc_array ( mov -> fragment_index_data , mov -> fragment_index_count + 1 , sizeof ( MOVFragmentIndex * ) ) ; if ( ! tmp ) { av_freep ( & index ) ; return AVERROR ( ENOMEM ) ; } mov -> fragment_index_data = tmp ; mov -> fragment_index_data [ mov -> fragment_index_count ++ ] = index ; version = avio_r8 ( f ) ; avio_rb24 ( f ) ; index -> track_id = avio_rb32 ( f ) ; fieldlength = avio_rb32 ( f ) ; index -> item_count = avio_rb32 ( f ) ; index -> items = av_mallocz_array ( index -> item_count , sizeof ( MOVFragmentIndexItem ) ) ; if ( ! index -> items ) { index -> item_count = 0 ; return AVERROR ( ENOMEM ) ; } for ( i = 0 ; i < index -> item_count ; i ++ ) {  int64_t time , offset ;  if ( version == 1 ) { time = avio_rb64 ( f ) ; offset = avio_rb64 ( f ) ; } else { time = avio_rb32 ( f ) ; offset = avio_rb32 ( f ) ; } index -> items [ i ] . time = time ; index -> items [ i ] . moof_offset = offset ; for ( j = 0 ; j < ( ( fieldlength >> 4 ) & 3 ) + 1 ; j ++ ) avio_r8 ( f ) ; for ( j = 0 ; j < ( ( fieldlength >> 2 ) & 3 ) + 1 ; j ++ ) avio_r8 ( f ) ; for ( j = 0 ; j < ( ( fieldlength >> 0 ) & 3 ) + 1 ; j ++ ) avio_r8 ( f ) ; } avio_seek ( f , pos + size , SEEK_SET ) ; return 0 ; }","int64_t time , offset ;if ( avio_feof ( f ) ) {index -> item_count = 0 ;av_freep ( & index -> items ) ;return AVERROR_INVALIDDATA ;}if ( version == 1 ) {",5
9,"buggy line: unsigned long tpgt ;int ret ;if ( strstr ( name , ""tpgt_"" ) != name ) return ERR_PTR ( - EINVAL ) ;if ( kstrtoul ( name + 5 , 10 , & tpgt ) || tpgt > UINT_MAX )  return ERR_PTR ( - EINVAL ) ;cwe id:CWE-119context: static struct se_portal_group * vhost_scsi_make_tpg ( struct se_wwn * wwn , struct config_group * group , const char * name ) { struct vhost_scsi_tport * tport = container_of ( wwn , struct vhost_scsi_tport , tport_wwn ) ; struct vhost_scsi_tpg * tpg ;  unsigned long tpgt ;  int ret ; if ( strstr ( name , ""tpgt_"" ) != name ) return ERR_PTR ( - EINVAL ) ;  if ( kstrtoul ( name + 5 , 10 , & tpgt ) || tpgt > UINT_MAX )  return ERR_PTR ( - EINVAL ) ; tpg = kzalloc ( sizeof ( struct vhost_scsi_tpg ) , GFP_KERNEL ) ; if ( ! tpg ) { pr_err ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>struct<S2SV_blank>vhost_scsi_tpg"" ) ; return ERR_PTR ( - ENOMEM ) ; } mutex_init ( & tpg -> tv_tpg_mutex ) ; INIT_LIST_HEAD ( & tpg -> tv_tpg_list ) ; tpg -> tport = tport ; tpg -> tport_tpgt = tpgt ; ret = core_tpg_register ( & vhost_scsi_fabric_configfs -> tf_ops , wwn , & tpg -> se_tpg , tpg , TRANSPORT_TPG_TYPE_NORMAL ) ; if ( ret < 0 ) { kfree ( tpg ) ; return NULL ; } mutex_lock ( & vhost_scsi_mutex ) ; list_add_tail ( & tpg -> tv_tpg_list , & vhost_scsi_list ) ; mutex_unlock ( & vhost_scsi_mutex ) ; return & tpg -> se_tpg ; }","u16 tpgt ;int ret ;if ( kstrtou16 ( name + 5 , 10 , & tpgt ) || tpgt > UINT_MAX ) return ERR_PTR ( - EINVAL ) ;",6
10,"buggy line: TrackWriter * writer = ( TrackWriter * ) gf_list_get ( writers , 0 ) ;gf_isom_box_del ( writer -> stco ) ;cwe id:CWE-416context: void CleanWriters ( GF_List * writers ) { while ( gf_list_count ( writers ) ) {  TrackWriter * writer = ( TrackWriter * ) gf_list_get ( writers , 0 ) ;  gf_isom_box_del ( writer -> stco ) ; gf_isom_box_del ( ( GF_Box * ) writer -> stsc ) ; gf_free ( writer ) ; gf_list_rem ( writers , 0 ) ; } }","TrackWriter * writer = ( TrackWriter * ) gf_list_get ( writers , 0 ) ;gf_list_del_item ( writer -> stbl -> child_boxes , writer -> stco ) ;gf_list_del_item ( writer -> stbl -> child_boxes , writer -> stsc ) ;gf_isom_box_del ( writer -> stco ) ;",7
11,"buggy line: u32 data ;void * vapic ;vapic = kmap_atomic ( vcpu -> arch . apic -> vapic_page ) ;data = * ( u32 * ) ( vapic + offset_in_page ( vcpu -> arch . apic -> vapic_addr ) ) ;kunmap_atomic ( vapic ) ;cwe id:CWE-20context: void kvm_lapic_sync_from_vapic ( struct kvm_vcpu * vcpu ) {  u32 data ;  void * vapic ; if ( test_bit ( KVM_APIC_PV_EOI_PENDING , & vcpu -> arch . apic_attention ) ) apic_sync_pv_eoi_from_guest ( vcpu , vcpu -> arch . apic ) ; if ( ! test_bit ( KVM_APIC_CHECK_VAPIC , & vcpu -> arch . apic_attention ) ) return ;  vapic = kmap_atomic ( vcpu -> arch . apic -> vapic_page ) ;  data = * ( u32 * ) ( vapic + offset_in_page ( vcpu -> arch . apic -> vapic_addr ) ) ; kunmap_atomic ( vapic ) ; apic_set_tpr ( vcpu -> arch . apic , data & 0xff ) ; }","u32 data ;kvm_read_guest_cached ( vcpu -> kvm , & vcpu -> arch . apic -> vapic_cache , & data , sizeof ( u32 ) ) ;",8
12,"buggy line: * dst = * src ;clear_task_ebb ( dst ) ;cwe id:CWE-20context: int arch_dup_task_struct ( struct task_struct * dst , struct task_struct * src ) { flush_fp_to_thread ( src ) ; flush_altivec_to_thread ( src ) ; flush_vsx_to_thread ( src ) ; flush_spe_to_thread ( src ) ;  * dst = * src ;  clear_task_ebb ( dst ) ; return 0 ; }",__switch_to_tm ( src ) ;tm_recheckpoint_new_task ( src ) ;* dst = * src ;clear_task_ebb ( dst ) ;,9
13,"buggy line: cJSON * c = array -> child ;while ( c && item > 0 ) {-- item ;c = c -> next ;}return c ;cwe id:CWE-119context: cJSON * cJSON_GetArrayItem ( cJSON * array , int item ) {  cJSON * c = array -> child ;   while ( c && item > 0 ) {  -- item ; c = c -> next ;  }  return c ; }","cJSON * c = array ? array -> child : 0 ;while ( c && item > 0 ) item -- , c = c -> next ;}return c ;",10
14,"buggy line: ext3_msg ( sb , ""error:<S2SV_blank>invalid<S2SV_blank>sb<S2SV_blank>specification:<S2SV_blank>%s"" ,  ( char * ) * data ) ;cwe id:CWE-20context: static ext3_fsblk_t get_sb_block ( void * * data , struct super_block * sb ) { ext3_fsblk_t sb_block ; char * options = ( char * ) * data ; if ( ! options || strncmp ( options , ""sb="" , 3 ) != 0 ) return 1 ; options += 3 ; sb_block = simple_strtoul ( options , & options , 0 ) ; if ( * options && * options != ',' ) {  ext3_msg ( sb , ""error:<S2SV_blank>invalid<S2SV_blank>sb<S2SV_blank>specification:<S2SV_blank>%s"" ,  ( char * ) * data ) ; return 1 ; } if ( * options == ',' ) options ++ ; * data = ( void * ) options ; return sb_block ; }","ext3_msg ( sb , KERN_ERR , ""error:<S2SV_blank>invalid<S2SV_blank>sb<S2SV_blank>specification:<S2SV_blank>%s"" , ( char * ) * data ) ;",11
15,"buggy line: ipv6_select_ident ( fptr ) ;segs = skb_segment ( skb , features ) ;cwe id:CWE-000context: static struct sk_buff * udp6_ufo_fragment ( struct sk_buff * skb , u32 features ) { struct sk_buff * segs = ERR_PTR ( - EINVAL ) ; unsigned int mss ; unsigned int unfrag_ip6hlen , unfrag_len ; struct frag_hdr * fptr ; u8 * mac_start , * prevhdr ; u8 nexthdr ; u8 frag_hdr_sz = sizeof ( struct frag_hdr ) ; int offset ; __wsum csum ; mss = skb_shinfo ( skb ) -> gso_size ; if ( unlikely ( skb -> len <= mss ) ) goto out ; if ( skb_gso_ok ( skb , features | NETIF_F_GSO_ROBUST ) ) { int type = skb_shinfo ( skb ) -> gso_type ; if ( unlikely ( type & ~ ( SKB_GSO_UDP | SKB_GSO_DODGY ) || ! ( type & ( SKB_GSO_UDP ) ) ) ) goto out ; skb_shinfo ( skb ) -> gso_segs = DIV_ROUND_UP ( skb -> len , mss ) ; segs = NULL ; goto out ; } offset = skb_checksum_start_offset ( skb ) ; csum = skb_checksum ( skb , offset , skb -> len - offset , 0 ) ; offset += skb -> csum_offset ; * ( __sum16 * ) ( skb -> data + offset ) = csum_fold ( csum ) ; skb -> ip_summed = CHECKSUM_NONE ; if ( ( skb_mac_header ( skb ) < skb -> head + frag_hdr_sz ) && pskb_expand_head ( skb , frag_hdr_sz , 0 , GFP_ATOMIC ) ) goto out ; unfrag_ip6hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; nexthdr = * prevhdr ; * prevhdr = NEXTHDR_FRAGMENT ; unfrag_len = skb_network_header ( skb ) - skb_mac_header ( skb ) + unfrag_ip6hlen ; mac_start = skb_mac_header ( skb ) ; memmove ( mac_start - frag_hdr_sz , mac_start , unfrag_len ) ; skb -> mac_header -= frag_hdr_sz ; skb -> network_header -= frag_hdr_sz ; fptr = ( struct frag_hdr * ) ( skb_network_header ( skb ) + unfrag_ip6hlen ) ; fptr -> nexthdr = nexthdr ; fptr -> reserved = 0 ;  ipv6_select_ident ( fptr ) ;  segs = skb_segment ( skb , features ) ; out : return segs ; }","ipv6_select_ident ( fptr , ( struct rt6_info * ) skb_dst ( skb ) ) ;segs = skb_segment ( skb , features ) ;",12
16,"buggy line: void __perf_sw_event ( u32 event_id , u64 nr , int nmi ,  struct pt_regs * regs , u64 addr ) {do_perf_sw_event ( PERF_TYPE_SOFTWARE , event_id , nr , nmi , & data , regs ) ;perf_swevent_put_recursion_context ( rctx ) ;cwe id:CWE-400context:  void __perf_sw_event ( u32 event_id , u64 nr , int nmi ,  struct pt_regs * regs , u64 addr ) { struct perf_sample_data data ; int rctx ; preempt_disable_notrace ( ) ; rctx = perf_swevent_get_recursion_context ( ) ; if ( rctx < 0 ) return ; perf_sample_data_init ( & data , addr ) ;  do_perf_sw_event ( PERF_TYPE_SOFTWARE , event_id , nr , nmi , & data , regs ) ;  perf_swevent_put_recursion_context ( rctx ) ; preempt_enable_notrace ( ) ; }","void __perf_sw_event ( u32 event_id , u64 nr , struct pt_regs * regs , u64 addr ) {do_perf_sw_event ( PERF_TYPE_SOFTWARE , event_id , nr , & data , regs ) ;perf_swevent_put_recursion_context ( rctx ) ;",13
17,"buggy line: # ifndef _MSC_VER   char buf [ EXT2_BLOCK_SIZE ( data ) ] ;# else char * buf = grub_malloc ( EXT2_BLOCK_SIZE ( data ) ) ;# endif struct grub_ext4_extent_header * leaf ;grub_error ( GRUB_ERR_BAD_FS , ""invalid<S2SV_blank>extent"" ) ;return - 1 ;cwe id:CWE-119context: static grub_disk_addr_t grub_ext2_read_block ( grub_fshelp_node_t node , grub_disk_addr_t fileblock ) { struct grub_ext2_data * data = node -> data ; struct grub_ext2_inode * inode = & node -> inode ; int blknr = - 1 ; unsigned int blksz = EXT2_BLOCK_SIZE ( data ) ; int log2_blksz = LOG2_EXT2_BLOCK_SIZE ( data ) ; if ( grub_le_to_cpu32 ( inode -> flags ) & EXT4_EXTENTS_FLAG ) {  # ifndef _MSC_VER   char buf [ EXT2_BLOCK_SIZE ( data ) ] ;  # else char * buf = grub_malloc ( EXT2_BLOCK_SIZE ( data ) ) ; # endif struct grub_ext4_extent_header * leaf ; struct grub_ext4_extent * ext ; int i ; leaf = grub_ext4_find_leaf ( data , buf , ( struct grub_ext4_extent_header * ) inode -> blocks . dir_blocks , fileblock ) ; if ( ! leaf ) {  grub_error ( GRUB_ERR_BAD_FS , ""invalid<S2SV_blank>extent"" ) ;  return - 1 ; } ext = ( struct grub_ext4_extent * ) ( leaf + 1 ) ; for ( i = 0 ; i < grub_le_to_cpu16 ( leaf -> entries ) ; i ++ ) { if ( fileblock < grub_le_to_cpu32 ( ext [ i ] . block ) ) break ; } if ( -- i >= 0 ) { fileblock -= grub_le_to_cpu32 ( ext [ i ] . block ) ;  if ( fileblock >= grub_le_to_cpu16 ( ext [ i ] . len ) )  return 0 ;  else  { grub_disk_addr_t start ; start = grub_le_to_cpu16 ( ext [ i ] . start_hi ) ; start = ( start << 32 ) + grub_le_to_cpu32 ( ext [ i ] . start ) ;  return fileblock + start ;  } } else { grub_error ( GRUB_ERR_BAD_FS , ""something<S2SV_blank>wrong<S2SV_blank>with<S2SV_blank>extent"" ) ;  return - 1 ;   }  } if ( fileblock < INDIRECT_BLOCKS ) { blknr = grub_le_to_cpu32 ( inode -> blocks . dir_blocks [ fileblock ] ) ; } else if ( fileblock < INDIRECT_BLOCKS + blksz / 4 ) { grub_uint32_t * indir ; indir = grub_malloc ( blksz ) ;  if ( ! indir )   return grub_errno ;  if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . indir_block ) ) << log2_blksz ,  0 , blksz , indir ) )   return grub_errno ;  blknr = grub_le_to_cpu32 ( indir [ fileblock - INDIRECT_BLOCKS ] ) ; grub_free ( indir ) ; } else if ( fileblock < ( grub_disk_addr_t ) ( INDIRECT_BLOCKS + blksz / 4 ) * ( grub_disk_addr_t ) ( blksz / 4 + 1 ) ) { unsigned int perblock = blksz / 4 ; unsigned int rblock = fileblock - ( INDIRECT_BLOCKS + blksz / 4 ) ; grub_uint32_t * indir ; indir = grub_malloc ( blksz ) ;  if ( ! indir )   return grub_errno ;  if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . double_indir_block ) ) << log2_blksz ,  0 , blksz , indir ) )   return grub_errno ;  if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( indir [ rblock / perblock ] ) ) << log2_blksz ,  0 , blksz , indir ) )   return grub_errno ;  blknr = grub_le_to_cpu32 ( indir [ rblock % perblock ] ) ; grub_free ( indir ) ; } else { grub_error ( GRUB_ERR_NOT_IMPLEMENTED_YET , ""ext2fs<S2SV_blank>doesn\'t<S2SV_blank>support<S2SV_blank>triple<S2SV_blank>indirect<S2SV_blank>blocks"" ) ; } return blknr ; }","char * buf = grub_malloc ( EXT2_BLOCK_SIZE ( data ) ] ;# else char * buf = grub_malloc ( EXT2_BLOCK_SIZE ( data ) ) ;if ( ! buf ) {return - 1 ;}struct grub_ext4_extent_header * leaf ;grub_error ( GRUB_ERR_BAD_FS , ""invalid<S2SV_blank>extent"" ) ;free ( buf ) ;return - 1 ;",14
18,"buggy line: if ( fileblock >= grub_le_to_cpu16 ( ext [ i ] . len ) )  return 0 ;else  {return fileblock + start ;}return - 1 ;}}if ( ! indir )   return grub_errno ;if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . indir_block ) ) << log2_blksz ,  0 , blksz , indir ) )   return grub_errno ;blknr = grub_le_to_cpu32 ( indir [ fileblock - INDIRECT_BLOCKS ] ) ;cwe id:CWE-119context: static grub_disk_addr_t grub_ext2_read_block ( grub_fshelp_node_t node , grub_disk_addr_t fileblock ) { struct grub_ext2_data * data = node -> data ; struct grub_ext2_inode * inode = & node -> inode ; int blknr = - 1 ; unsigned int blksz = EXT2_BLOCK_SIZE ( data ) ; int log2_blksz = LOG2_EXT2_BLOCK_SIZE ( data ) ; if ( grub_le_to_cpu32 ( inode -> flags ) & EXT4_EXTENTS_FLAG ) {  # ifndef _MSC_VER   char buf [ EXT2_BLOCK_SIZE ( data ) ] ;  # else char * buf = grub_malloc ( EXT2_BLOCK_SIZE ( data ) ) ; # endif struct grub_ext4_extent_header * leaf ; struct grub_ext4_extent * ext ; int i ; leaf = grub_ext4_find_leaf ( data , buf , ( struct grub_ext4_extent_header * ) inode -> blocks . dir_blocks , fileblock ) ; if ( ! leaf ) {  grub_error ( GRUB_ERR_BAD_FS , ""invalid<S2SV_blank>extent"" ) ;  return - 1 ; } ext = ( struct grub_ext4_extent * ) ( leaf + 1 ) ; for ( i = 0 ; i < grub_le_to_cpu16 ( leaf -> entries ) ; i ++ ) { if ( fileblock < grub_le_to_cpu32 ( ext [ i ] . block ) ) break ; } if ( -- i >= 0 ) { fileblock -= grub_le_to_cpu32 ( ext [ i ] . block ) ;  if ( fileblock >= grub_le_to_cpu16 ( ext [ i ] . len ) )  return 0 ;  else  { grub_disk_addr_t start ; start = grub_le_to_cpu16 ( ext [ i ] . start_hi ) ; start = ( start << 32 ) + grub_le_to_cpu32 ( ext [ i ] . start ) ;  return fileblock + start ;  } } else { grub_error ( GRUB_ERR_BAD_FS , ""something<S2SV_blank>wrong<S2SV_blank>with<S2SV_blank>extent"" ) ;  return - 1 ;   }  } if ( fileblock < INDIRECT_BLOCKS ) { blknr = grub_le_to_cpu32 ( inode -> blocks . dir_blocks [ fileblock ] ) ; } else if ( fileblock < INDIRECT_BLOCKS + blksz / 4 ) { grub_uint32_t * indir ; indir = grub_malloc ( blksz ) ;  if ( ! indir )   return grub_errno ;  if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . indir_block ) ) << log2_blksz ,  0 , blksz , indir ) )   return grub_errno ;  blknr = grub_le_to_cpu32 ( indir [ fileblock - INDIRECT_BLOCKS ] ) ; grub_free ( indir ) ; } else if ( fileblock < ( grub_disk_addr_t ) ( INDIRECT_BLOCKS + blksz / 4 ) * ( grub_disk_addr_t ) ( blksz / 4 + 1 ) ) { unsigned int perblock = blksz / 4 ; unsigned int rblock = fileblock - ( INDIRECT_BLOCKS + blksz / 4 ) ; grub_uint32_t * indir ; indir = grub_malloc ( blksz ) ;  if ( ! indir )   return grub_errno ;  if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . double_indir_block ) ) << log2_blksz ,  0 , blksz , indir ) )   return grub_errno ;  if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( indir [ rblock / perblock ] ) ) << log2_blksz ,  0 , blksz , indir ) )   return grub_errno ;  blknr = grub_le_to_cpu32 ( indir [ rblock % perblock ] ) ; grub_free ( indir ) ; } else { grub_error ( GRUB_ERR_NOT_IMPLEMENTED_YET , ""ext2fs<S2SV_blank>doesn\'t<S2SV_blank>support<S2SV_blank>triple<S2SV_blank>indirect<S2SV_blank>blocks"" ) ; } return blknr ; }","if ( fileblock >= grub_le_to_cpu16 ( ext [ i ] . len ) ) {free ( buf ) ;return 0 ;}else {free ( buf ) ;return fileblock + start ;}free ( buf ) ;return - 1 ;}free ( buf ) ;}if ( ! indir ) {return grub_errno ;}if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . indir_block ) ) << log2_blksz , 0 , blksz , indir ) ) {return grub_errno ;}blknr = grub_le_to_cpu32 ( indir [ fileblock - INDIRECT_BLOCKS ] ) ;",14
19,"buggy line: if ( ! indir )   return grub_errno ;if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . double_indir_block ) ) << log2_blksz ,  0 , blksz , indir ) )   return grub_errno ;if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( indir [ rblock / perblock ] ) ) << log2_blksz ,  0 , blksz , indir ) )   return grub_errno ;blknr = grub_le_to_cpu32 ( indir [ rblock % perblock ] ) ;cwe id:CWE-119context: static grub_disk_addr_t grub_ext2_read_block ( grub_fshelp_node_t node , grub_disk_addr_t fileblock ) { struct grub_ext2_data * data = node -> data ; struct grub_ext2_inode * inode = & node -> inode ; int blknr = - 1 ; unsigned int blksz = EXT2_BLOCK_SIZE ( data ) ; int log2_blksz = LOG2_EXT2_BLOCK_SIZE ( data ) ; if ( grub_le_to_cpu32 ( inode -> flags ) & EXT4_EXTENTS_FLAG ) {  # ifndef _MSC_VER   char buf [ EXT2_BLOCK_SIZE ( data ) ] ;  # else char * buf = grub_malloc ( EXT2_BLOCK_SIZE ( data ) ) ; # endif struct grub_ext4_extent_header * leaf ; struct grub_ext4_extent * ext ; int i ; leaf = grub_ext4_find_leaf ( data , buf , ( struct grub_ext4_extent_header * ) inode -> blocks . dir_blocks , fileblock ) ; if ( ! leaf ) {  grub_error ( GRUB_ERR_BAD_FS , ""invalid<S2SV_blank>extent"" ) ;  return - 1 ; } ext = ( struct grub_ext4_extent * ) ( leaf + 1 ) ; for ( i = 0 ; i < grub_le_to_cpu16 ( leaf -> entries ) ; i ++ ) { if ( fileblock < grub_le_to_cpu32 ( ext [ i ] . block ) ) break ; } if ( -- i >= 0 ) { fileblock -= grub_le_to_cpu32 ( ext [ i ] . block ) ;  if ( fileblock >= grub_le_to_cpu16 ( ext [ i ] . len ) )  return 0 ;  else  { grub_disk_addr_t start ; start = grub_le_to_cpu16 ( ext [ i ] . start_hi ) ; start = ( start << 32 ) + grub_le_to_cpu32 ( ext [ i ] . start ) ;  return fileblock + start ;  } } else { grub_error ( GRUB_ERR_BAD_FS , ""something<S2SV_blank>wrong<S2SV_blank>with<S2SV_blank>extent"" ) ;  return - 1 ;   }  } if ( fileblock < INDIRECT_BLOCKS ) { blknr = grub_le_to_cpu32 ( inode -> blocks . dir_blocks [ fileblock ] ) ; } else if ( fileblock < INDIRECT_BLOCKS + blksz / 4 ) { grub_uint32_t * indir ; indir = grub_malloc ( blksz ) ;  if ( ! indir )   return grub_errno ;  if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . indir_block ) ) << log2_blksz ,  0 , blksz , indir ) )   return grub_errno ;  blknr = grub_le_to_cpu32 ( indir [ fileblock - INDIRECT_BLOCKS ] ) ; grub_free ( indir ) ; } else if ( fileblock < ( grub_disk_addr_t ) ( INDIRECT_BLOCKS + blksz / 4 ) * ( grub_disk_addr_t ) ( blksz / 4 + 1 ) ) { unsigned int perblock = blksz / 4 ; unsigned int rblock = fileblock - ( INDIRECT_BLOCKS + blksz / 4 ) ; grub_uint32_t * indir ; indir = grub_malloc ( blksz ) ;  if ( ! indir )   return grub_errno ;  if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . double_indir_block ) ) << log2_blksz ,  0 , blksz , indir ) )   return grub_errno ;  if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( indir [ rblock / perblock ] ) ) << log2_blksz ,  0 , blksz , indir ) )   return grub_errno ;  blknr = grub_le_to_cpu32 ( indir [ rblock % perblock ] ) ; grub_free ( indir ) ; } else { grub_error ( GRUB_ERR_NOT_IMPLEMENTED_YET , ""ext2fs<S2SV_blank>doesn\'t<S2SV_blank>support<S2SV_blank>triple<S2SV_blank>indirect<S2SV_blank>blocks"" ) ; } return blknr ; }","if ( ! indir ) {return grub_errno ;}if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . double_indir_block ) ) << log2_blksz , 0 , blksz , indir ) ) {return grub_errno ;}if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( indir [ rblock / perblock ] ) ) << log2_blksz , 0 , blksz , indir ) ) {return grub_errno ;}blknr = grub_le_to_cpu32 ( indir [ rblock % perblock ] ) ;",14
20,"buggy line: static void fdct16 ( const int16_t in [ 16 ] , int16_t out [ 16 ] ) {int step1 [ 8 ] ;int step2 [ 8 ] ;int step3 [ 8 ] ;int input [ 8 ] ;int temp1 , temp2 ;input [ 0 ] = in [ 0 ] + in [ 15 ] ;cwe id:CWE-119context:  static void fdct16 ( const int16_t in [ 16 ] , int16_t out [ 16 ] ) {   int step1 [ 8 ] ;   int step2 [ 8 ] ;   int step3 [ 8 ] ;   int input [ 8 ] ;   int temp1 , temp2 ;  input [ 0 ] = in [ 0 ] + in [ 15 ] ; input [ 1 ] = in [ 1 ] + in [ 14 ] ; input [ 2 ] = in [ 2 ] + in [ 13 ] ; input [ 3 ] = in [ 3 ] + in [ 12 ] ; input [ 4 ] = in [ 4 ] + in [ 11 ] ; input [ 5 ] = in [ 5 ] + in [ 10 ] ; input [ 6 ] = in [ 6 ] + in [ 9 ] ; input [ 7 ] = in [ 7 ] + in [ 8 ] ; step1 [ 0 ] = in [ 7 ] - in [ 8 ] ; step1 [ 1 ] = in [ 6 ] - in [ 9 ] ; step1 [ 2 ] = in [ 5 ] - in [ 10 ] ; step1 [ 3 ] = in [ 4 ] - in [ 11 ] ; step1 [ 4 ] = in [ 3 ] - in [ 12 ] ; step1 [ 5 ] = in [ 2 ] - in [ 13 ] ; step1 [ 6 ] = in [ 1 ] - in [ 14 ] ; step1 [ 7 ] = in [ 0 ] - in [ 15 ] ; {  int s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 ;   int t0 , t1 , t2 , t3 ;   int x0 , x1 , x2 , x3 ;  s0 = input [ 0 ] + input [ 7 ] ; s1 = input [ 1 ] + input [ 6 ] ; s2 = input [ 2 ] + input [ 5 ] ; s3 = input [ 3 ] + input [ 4 ] ; s4 = input [ 3 ] - input [ 4 ] ; s5 = input [ 2 ] - input [ 5 ] ; s6 = input [ 1 ] - input [ 6 ] ; s7 = input [ 0 ] - input [ 7 ] ; x0 = s0 + s3 ; x1 = s1 + s2 ; x2 = s1 - s2 ; x3 = s0 - s3 ; t0 = ( x0 + x1 ) * cospi_16_64 ; t1 = ( x0 - x1 ) * cospi_16_64 ; t2 = x3 * cospi_8_64 + x2 * cospi_24_64 ; t3 = x3 * cospi_24_64 - x2 * cospi_8_64 ;  out [ 0 ] = fdct_round_shift ( t0 ) ;   out [ 4 ] = fdct_round_shift ( t2 ) ;   out [ 8 ] = fdct_round_shift ( t1 ) ;   out [ 12 ] = fdct_round_shift ( t3 ) ;  t0 = ( s6 - s5 ) * cospi_16_64 ; t1 = ( s6 + s5 ) * cospi_16_64 ; t2 = fdct_round_shift ( t0 ) ; t3 = fdct_round_shift ( t1 ) ; x0 = s4 + t2 ; x1 = s4 - t2 ; x2 = s7 - t3 ; x3 = s7 + t3 ; t0 = x0 * cospi_28_64 + x3 * cospi_4_64 ; t1 = x1 * cospi_12_64 + x2 * cospi_20_64 ; t2 = x2 * cospi_12_64 + x1 * - cospi_20_64 ; t3 = x3 * cospi_28_64 + x0 * - cospi_4_64 ;  out [ 2 ] = fdct_round_shift ( t0 ) ;   out [ 6 ] = fdct_round_shift ( t2 ) ;   out [ 10 ] = fdct_round_shift ( t1 ) ;   out [ 14 ] = fdct_round_shift ( t3 ) ;  } temp1 = ( step1 [ 5 ] - step1 [ 2 ] ) * cospi_16_64 ; temp2 = ( step1 [ 4 ] - step1 [ 3 ] ) * cospi_16_64 ; step2 [ 2 ] = fdct_round_shift ( temp1 ) ; step2 [ 3 ] = fdct_round_shift ( temp2 ) ; temp1 = ( step1 [ 4 ] + step1 [ 3 ] ) * cospi_16_64 ; temp2 = ( step1 [ 5 ] + step1 [ 2 ] ) * cospi_16_64 ; step2 [ 4 ] = fdct_round_shift ( temp1 ) ; step2 [ 5 ] = fdct_round_shift ( temp2 ) ; step3 [ 0 ] = step1 [ 0 ] + step2 [ 3 ] ; step3 [ 1 ] = step1 [ 1 ] + step2 [ 2 ] ; step3 [ 2 ] = step1 [ 1 ] - step2 [ 2 ] ; step3 [ 3 ] = step1 [ 0 ] - step2 [ 3 ] ; step3 [ 4 ] = step1 [ 7 ] - step2 [ 4 ] ; step3 [ 5 ] = step1 [ 6 ] - step2 [ 5 ] ; step3 [ 6 ] = step1 [ 6 ] + step2 [ 5 ] ; step3 [ 7 ] = step1 [ 7 ] + step2 [ 4 ] ; temp1 = step3 [ 1 ] * - cospi_8_64 + step3 [ 6 ] * cospi_24_64 ;  temp2 = step3 [ 2 ] * - cospi_24_64 - step3 [ 5 ] * cospi_8_64 ;  step2 [ 1 ] = fdct_round_shift ( temp1 ) ; step2 [ 2 ] = fdct_round_shift ( temp2 ) ;  temp1 = step3 [ 2 ] * - cospi_8_64 + step3 [ 5 ] * cospi_24_64 ;  temp2 = step3 [ 1 ] * cospi_24_64 + step3 [ 6 ] * cospi_8_64 ; step2 [ 5 ] = fdct_round_shift ( temp1 ) ; step2 [ 6 ] = fdct_round_shift ( temp2 ) ; step1 [ 0 ] = step3 [ 0 ] + step2 [ 1 ] ; step1 [ 1 ] = step3 [ 0 ] - step2 [ 1 ] ;  step1 [ 2 ] = step3 [ 3 ] - step2 [ 2 ] ;  step1 [ 3 ] = step3 [ 3 ] + step2 [ 2 ] ; step1 [ 4 ] = step3 [ 4 ] + step2 [ 5 ] ; step1 [ 5 ] = step3 [ 4 ] - step2 [ 5 ] ; step1 [ 6 ] = step3 [ 7 ] - step2 [ 6 ] ; step1 [ 7 ] = step3 [ 7 ] + step2 [ 6 ] ; temp1 = step1 [ 0 ] * cospi_30_64 + step1 [ 7 ] * cospi_2_64 ; temp2 = step1 [ 1 ] * cospi_14_64 + step1 [ 6 ] * cospi_18_64 ;  out [ 1 ] = fdct_round_shift ( temp1 ) ;   out [ 9 ] = fdct_round_shift ( temp2 ) ;  temp1 = step1 [ 2 ] * cospi_22_64 + step1 [ 5 ] * cospi_10_64 ; temp2 = step1 [ 3 ] * cospi_6_64 + step1 [ 4 ] * cospi_26_64 ;  out [ 5 ] = fdct_round_shift ( temp1 ) ;   out [ 13 ] = fdct_round_shift ( temp2 ) ;  temp1 = step1 [ 3 ] * - cospi_26_64 + step1 [ 4 ] * cospi_6_64 ; temp2 = step1 [ 2 ] * - cospi_10_64 + step1 [ 5 ] * cospi_22_64 ;  out [ 3 ] = fdct_round_shift ( temp1 ) ;   out [ 11 ] = fdct_round_shift ( temp2 ) ;  temp1 = step1 [ 1 ] * - cospi_18_64 + step1 [ 6 ] * cospi_14_64 ; temp2 = step1 [ 0 ] * - cospi_2_64 + step1 [ 7 ] * cospi_30_64 ;  out [ 7 ] = fdct_round_shift ( temp1 ) ;   out [ 15 ] = fdct_round_shift ( temp2 ) ;  }","static void fdct16 ( const tran_low_t in [ 16 ] , int16_t out [ 16 ] ) {tran_high_t step1 [ 8 ] ;int step2 [ 8 ] ;tran_high_t step3 [ 8 ] ;int input [ 8 ] ;tran_high_t temp1 , temp2 ;input [ 0 ] = in [ 0 ] + in [ 15 ] ;",15
21,"buggy line: int s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 ;int t0 , t1 , t2 , t3 ;int x0 , x1 , x2 , x3 ;s0 = input [ 0 ] + input [ 7 ] ;cwe id:CWE-119context:  static void fdct16 ( const int16_t in [ 16 ] , int16_t out [ 16 ] ) {   int step1 [ 8 ] ;   int step2 [ 8 ] ;   int step3 [ 8 ] ;   int input [ 8 ] ;   int temp1 , temp2 ;  input [ 0 ] = in [ 0 ] + in [ 15 ] ; input [ 1 ] = in [ 1 ] + in [ 14 ] ; input [ 2 ] = in [ 2 ] + in [ 13 ] ; input [ 3 ] = in [ 3 ] + in [ 12 ] ; input [ 4 ] = in [ 4 ] + in [ 11 ] ; input [ 5 ] = in [ 5 ] + in [ 10 ] ; input [ 6 ] = in [ 6 ] + in [ 9 ] ; input [ 7 ] = in [ 7 ] + in [ 8 ] ; step1 [ 0 ] = in [ 7 ] - in [ 8 ] ; step1 [ 1 ] = in [ 6 ] - in [ 9 ] ; step1 [ 2 ] = in [ 5 ] - in [ 10 ] ; step1 [ 3 ] = in [ 4 ] - in [ 11 ] ; step1 [ 4 ] = in [ 3 ] - in [ 12 ] ; step1 [ 5 ] = in [ 2 ] - in [ 13 ] ; step1 [ 6 ] = in [ 1 ] - in [ 14 ] ; step1 [ 7 ] = in [ 0 ] - in [ 15 ] ; {  int s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 ;   int t0 , t1 , t2 , t3 ;   int x0 , x1 , x2 , x3 ;  s0 = input [ 0 ] + input [ 7 ] ; s1 = input [ 1 ] + input [ 6 ] ; s2 = input [ 2 ] + input [ 5 ] ; s3 = input [ 3 ] + input [ 4 ] ; s4 = input [ 3 ] - input [ 4 ] ; s5 = input [ 2 ] - input [ 5 ] ; s6 = input [ 1 ] - input [ 6 ] ; s7 = input [ 0 ] - input [ 7 ] ; x0 = s0 + s3 ; x1 = s1 + s2 ; x2 = s1 - s2 ; x3 = s0 - s3 ; t0 = ( x0 + x1 ) * cospi_16_64 ; t1 = ( x0 - x1 ) * cospi_16_64 ; t2 = x3 * cospi_8_64 + x2 * cospi_24_64 ; t3 = x3 * cospi_24_64 - x2 * cospi_8_64 ;  out [ 0 ] = fdct_round_shift ( t0 ) ;   out [ 4 ] = fdct_round_shift ( t2 ) ;   out [ 8 ] = fdct_round_shift ( t1 ) ;   out [ 12 ] = fdct_round_shift ( t3 ) ;  t0 = ( s6 - s5 ) * cospi_16_64 ; t1 = ( s6 + s5 ) * cospi_16_64 ; t2 = fdct_round_shift ( t0 ) ; t3 = fdct_round_shift ( t1 ) ; x0 = s4 + t2 ; x1 = s4 - t2 ; x2 = s7 - t3 ; x3 = s7 + t3 ; t0 = x0 * cospi_28_64 + x3 * cospi_4_64 ; t1 = x1 * cospi_12_64 + x2 * cospi_20_64 ; t2 = x2 * cospi_12_64 + x1 * - cospi_20_64 ; t3 = x3 * cospi_28_64 + x0 * - cospi_4_64 ;  out [ 2 ] = fdct_round_shift ( t0 ) ;   out [ 6 ] = fdct_round_shift ( t2 ) ;   out [ 10 ] = fdct_round_shift ( t1 ) ;   out [ 14 ] = fdct_round_shift ( t3 ) ;  } temp1 = ( step1 [ 5 ] - step1 [ 2 ] ) * cospi_16_64 ; temp2 = ( step1 [ 4 ] - step1 [ 3 ] ) * cospi_16_64 ; step2 [ 2 ] = fdct_round_shift ( temp1 ) ; step2 [ 3 ] = fdct_round_shift ( temp2 ) ; temp1 = ( step1 [ 4 ] + step1 [ 3 ] ) * cospi_16_64 ; temp2 = ( step1 [ 5 ] + step1 [ 2 ] ) * cospi_16_64 ; step2 [ 4 ] = fdct_round_shift ( temp1 ) ; step2 [ 5 ] = fdct_round_shift ( temp2 ) ; step3 [ 0 ] = step1 [ 0 ] + step2 [ 3 ] ; step3 [ 1 ] = step1 [ 1 ] + step2 [ 2 ] ; step3 [ 2 ] = step1 [ 1 ] - step2 [ 2 ] ; step3 [ 3 ] = step1 [ 0 ] - step2 [ 3 ] ; step3 [ 4 ] = step1 [ 7 ] - step2 [ 4 ] ; step3 [ 5 ] = step1 [ 6 ] - step2 [ 5 ] ; step3 [ 6 ] = step1 [ 6 ] + step2 [ 5 ] ; step3 [ 7 ] = step1 [ 7 ] + step2 [ 4 ] ; temp1 = step3 [ 1 ] * - cospi_8_64 + step3 [ 6 ] * cospi_24_64 ;  temp2 = step3 [ 2 ] * - cospi_24_64 - step3 [ 5 ] * cospi_8_64 ;  step2 [ 1 ] = fdct_round_shift ( temp1 ) ; step2 [ 2 ] = fdct_round_shift ( temp2 ) ;  temp1 = step3 [ 2 ] * - cospi_8_64 + step3 [ 5 ] * cospi_24_64 ;  temp2 = step3 [ 1 ] * cospi_24_64 + step3 [ 6 ] * cospi_8_64 ; step2 [ 5 ] = fdct_round_shift ( temp1 ) ; step2 [ 6 ] = fdct_round_shift ( temp2 ) ; step1 [ 0 ] = step3 [ 0 ] + step2 [ 1 ] ; step1 [ 1 ] = step3 [ 0 ] - step2 [ 1 ] ;  step1 [ 2 ] = step3 [ 3 ] - step2 [ 2 ] ;  step1 [ 3 ] = step3 [ 3 ] + step2 [ 2 ] ; step1 [ 4 ] = step3 [ 4 ] + step2 [ 5 ] ; step1 [ 5 ] = step3 [ 4 ] - step2 [ 5 ] ; step1 [ 6 ] = step3 [ 7 ] - step2 [ 6 ] ; step1 [ 7 ] = step3 [ 7 ] + step2 [ 6 ] ; temp1 = step1 [ 0 ] * cospi_30_64 + step1 [ 7 ] * cospi_2_64 ; temp2 = step1 [ 1 ] * cospi_14_64 + step1 [ 6 ] * cospi_18_64 ;  out [ 1 ] = fdct_round_shift ( temp1 ) ;   out [ 9 ] = fdct_round_shift ( temp2 ) ;  temp1 = step1 [ 2 ] * cospi_22_64 + step1 [ 5 ] * cospi_10_64 ; temp2 = step1 [ 3 ] * cospi_6_64 + step1 [ 4 ] * cospi_26_64 ;  out [ 5 ] = fdct_round_shift ( temp1 ) ;   out [ 13 ] = fdct_round_shift ( temp2 ) ;  temp1 = step1 [ 3 ] * - cospi_26_64 + step1 [ 4 ] * cospi_6_64 ; temp2 = step1 [ 2 ] * - cospi_10_64 + step1 [ 5 ] * cospi_22_64 ;  out [ 3 ] = fdct_round_shift ( temp1 ) ;   out [ 11 ] = fdct_round_shift ( temp2 ) ;  temp1 = step1 [ 1 ] * - cospi_18_64 + step1 [ 6 ] * cospi_14_64 ; temp2 = step1 [ 0 ] * - cospi_2_64 + step1 [ 7 ] * cospi_30_64 ;  out [ 7 ] = fdct_round_shift ( temp1 ) ;   out [ 15 ] = fdct_round_shift ( temp2 ) ;  }","tran_high_t s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 ;tran_high_t t0 , t1 , t2 , t3 ;tran_high_t x0 , x1 , x2 , x3 ;s0 = input [ 0 ] + input [ 7 ] ;",15
22,"buggy line: out [ 0 ] = fdct_round_shift ( t0 ) ;out [ 4 ] = fdct_round_shift ( t2 ) ;out [ 8 ] = fdct_round_shift ( t1 ) ;out [ 12 ] = fdct_round_shift ( t3 ) ;t0 = ( s6 - s5 ) * cospi_16_64 ;cwe id:CWE-119context:  static void fdct16 ( const int16_t in [ 16 ] , int16_t out [ 16 ] ) {   int step1 [ 8 ] ;   int step2 [ 8 ] ;   int step3 [ 8 ] ;   int input [ 8 ] ;   int temp1 , temp2 ;  input [ 0 ] = in [ 0 ] + in [ 15 ] ; input [ 1 ] = in [ 1 ] + in [ 14 ] ; input [ 2 ] = in [ 2 ] + in [ 13 ] ; input [ 3 ] = in [ 3 ] + in [ 12 ] ; input [ 4 ] = in [ 4 ] + in [ 11 ] ; input [ 5 ] = in [ 5 ] + in [ 10 ] ; input [ 6 ] = in [ 6 ] + in [ 9 ] ; input [ 7 ] = in [ 7 ] + in [ 8 ] ; step1 [ 0 ] = in [ 7 ] - in [ 8 ] ; step1 [ 1 ] = in [ 6 ] - in [ 9 ] ; step1 [ 2 ] = in [ 5 ] - in [ 10 ] ; step1 [ 3 ] = in [ 4 ] - in [ 11 ] ; step1 [ 4 ] = in [ 3 ] - in [ 12 ] ; step1 [ 5 ] = in [ 2 ] - in [ 13 ] ; step1 [ 6 ] = in [ 1 ] - in [ 14 ] ; step1 [ 7 ] = in [ 0 ] - in [ 15 ] ; {  int s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 ;   int t0 , t1 , t2 , t3 ;   int x0 , x1 , x2 , x3 ;  s0 = input [ 0 ] + input [ 7 ] ; s1 = input [ 1 ] + input [ 6 ] ; s2 = input [ 2 ] + input [ 5 ] ; s3 = input [ 3 ] + input [ 4 ] ; s4 = input [ 3 ] - input [ 4 ] ; s5 = input [ 2 ] - input [ 5 ] ; s6 = input [ 1 ] - input [ 6 ] ; s7 = input [ 0 ] - input [ 7 ] ; x0 = s0 + s3 ; x1 = s1 + s2 ; x2 = s1 - s2 ; x3 = s0 - s3 ; t0 = ( x0 + x1 ) * cospi_16_64 ; t1 = ( x0 - x1 ) * cospi_16_64 ; t2 = x3 * cospi_8_64 + x2 * cospi_24_64 ; t3 = x3 * cospi_24_64 - x2 * cospi_8_64 ;  out [ 0 ] = fdct_round_shift ( t0 ) ;   out [ 4 ] = fdct_round_shift ( t2 ) ;   out [ 8 ] = fdct_round_shift ( t1 ) ;   out [ 12 ] = fdct_round_shift ( t3 ) ;  t0 = ( s6 - s5 ) * cospi_16_64 ; t1 = ( s6 + s5 ) * cospi_16_64 ; t2 = fdct_round_shift ( t0 ) ; t3 = fdct_round_shift ( t1 ) ; x0 = s4 + t2 ; x1 = s4 - t2 ; x2 = s7 - t3 ; x3 = s7 + t3 ; t0 = x0 * cospi_28_64 + x3 * cospi_4_64 ; t1 = x1 * cospi_12_64 + x2 * cospi_20_64 ; t2 = x2 * cospi_12_64 + x1 * - cospi_20_64 ; t3 = x3 * cospi_28_64 + x0 * - cospi_4_64 ;  out [ 2 ] = fdct_round_shift ( t0 ) ;   out [ 6 ] = fdct_round_shift ( t2 ) ;   out [ 10 ] = fdct_round_shift ( t1 ) ;   out [ 14 ] = fdct_round_shift ( t3 ) ;  } temp1 = ( step1 [ 5 ] - step1 [ 2 ] ) * cospi_16_64 ; temp2 = ( step1 [ 4 ] - step1 [ 3 ] ) * cospi_16_64 ; step2 [ 2 ] = fdct_round_shift ( temp1 ) ; step2 [ 3 ] = fdct_round_shift ( temp2 ) ; temp1 = ( step1 [ 4 ] + step1 [ 3 ] ) * cospi_16_64 ; temp2 = ( step1 [ 5 ] + step1 [ 2 ] ) * cospi_16_64 ; step2 [ 4 ] = fdct_round_shift ( temp1 ) ; step2 [ 5 ] = fdct_round_shift ( temp2 ) ; step3 [ 0 ] = step1 [ 0 ] + step2 [ 3 ] ; step3 [ 1 ] = step1 [ 1 ] + step2 [ 2 ] ; step3 [ 2 ] = step1 [ 1 ] - step2 [ 2 ] ; step3 [ 3 ] = step1 [ 0 ] - step2 [ 3 ] ; step3 [ 4 ] = step1 [ 7 ] - step2 [ 4 ] ; step3 [ 5 ] = step1 [ 6 ] - step2 [ 5 ] ; step3 [ 6 ] = step1 [ 6 ] + step2 [ 5 ] ; step3 [ 7 ] = step1 [ 7 ] + step2 [ 4 ] ; temp1 = step3 [ 1 ] * - cospi_8_64 + step3 [ 6 ] * cospi_24_64 ;  temp2 = step3 [ 2 ] * - cospi_24_64 - step3 [ 5 ] * cospi_8_64 ;  step2 [ 1 ] = fdct_round_shift ( temp1 ) ; step2 [ 2 ] = fdct_round_shift ( temp2 ) ;  temp1 = step3 [ 2 ] * - cospi_8_64 + step3 [ 5 ] * cospi_24_64 ;  temp2 = step3 [ 1 ] * cospi_24_64 + step3 [ 6 ] * cospi_8_64 ; step2 [ 5 ] = fdct_round_shift ( temp1 ) ; step2 [ 6 ] = fdct_round_shift ( temp2 ) ; step1 [ 0 ] = step3 [ 0 ] + step2 [ 1 ] ; step1 [ 1 ] = step3 [ 0 ] - step2 [ 1 ] ;  step1 [ 2 ] = step3 [ 3 ] - step2 [ 2 ] ;  step1 [ 3 ] = step3 [ 3 ] + step2 [ 2 ] ; step1 [ 4 ] = step3 [ 4 ] + step2 [ 5 ] ; step1 [ 5 ] = step3 [ 4 ] - step2 [ 5 ] ; step1 [ 6 ] = step3 [ 7 ] - step2 [ 6 ] ; step1 [ 7 ] = step3 [ 7 ] + step2 [ 6 ] ; temp1 = step1 [ 0 ] * cospi_30_64 + step1 [ 7 ] * cospi_2_64 ; temp2 = step1 [ 1 ] * cospi_14_64 + step1 [ 6 ] * cospi_18_64 ;  out [ 1 ] = fdct_round_shift ( temp1 ) ;   out [ 9 ] = fdct_round_shift ( temp2 ) ;  temp1 = step1 [ 2 ] * cospi_22_64 + step1 [ 5 ] * cospi_10_64 ; temp2 = step1 [ 3 ] * cospi_6_64 + step1 [ 4 ] * cospi_26_64 ;  out [ 5 ] = fdct_round_shift ( temp1 ) ;   out [ 13 ] = fdct_round_shift ( temp2 ) ;  temp1 = step1 [ 3 ] * - cospi_26_64 + step1 [ 4 ] * cospi_6_64 ; temp2 = step1 [ 2 ] * - cospi_10_64 + step1 [ 5 ] * cospi_22_64 ;  out [ 3 ] = fdct_round_shift ( temp1 ) ;   out [ 11 ] = fdct_round_shift ( temp2 ) ;  temp1 = step1 [ 1 ] * - cospi_18_64 + step1 [ 6 ] * cospi_14_64 ; temp2 = step1 [ 0 ] * - cospi_2_64 + step1 [ 7 ] * cospi_30_64 ;  out [ 7 ] = fdct_round_shift ( temp1 ) ;   out [ 15 ] = fdct_round_shift ( temp2 ) ;  }",out [ 0 ] = ( tran_low_t ) fdct_round_shift ( t0 ) ;out [ 4 ] = ( tran_low_t ) fdct_round_shift ( t2 ) ;out [ 8 ] = ( tran_low_t ) fdct_round_shift ( t1 ) ;out [ 12 ] = ( tran_low_t ) fdct_round_shift ( t3 ) ;t0 = ( s6 - s5 ) * cospi_16_64 ;,15
23,"buggy line: out [ 2 ] = fdct_round_shift ( t0 ) ;out [ 6 ] = fdct_round_shift ( t2 ) ;out [ 10 ] = fdct_round_shift ( t1 ) ;out [ 14 ] = fdct_round_shift ( t3 ) ;}cwe id:CWE-119context:  static void fdct16 ( const int16_t in [ 16 ] , int16_t out [ 16 ] ) {   int step1 [ 8 ] ;   int step2 [ 8 ] ;   int step3 [ 8 ] ;   int input [ 8 ] ;   int temp1 , temp2 ;  input [ 0 ] = in [ 0 ] + in [ 15 ] ; input [ 1 ] = in [ 1 ] + in [ 14 ] ; input [ 2 ] = in [ 2 ] + in [ 13 ] ; input [ 3 ] = in [ 3 ] + in [ 12 ] ; input [ 4 ] = in [ 4 ] + in [ 11 ] ; input [ 5 ] = in [ 5 ] + in [ 10 ] ; input [ 6 ] = in [ 6 ] + in [ 9 ] ; input [ 7 ] = in [ 7 ] + in [ 8 ] ; step1 [ 0 ] = in [ 7 ] - in [ 8 ] ; step1 [ 1 ] = in [ 6 ] - in [ 9 ] ; step1 [ 2 ] = in [ 5 ] - in [ 10 ] ; step1 [ 3 ] = in [ 4 ] - in [ 11 ] ; step1 [ 4 ] = in [ 3 ] - in [ 12 ] ; step1 [ 5 ] = in [ 2 ] - in [ 13 ] ; step1 [ 6 ] = in [ 1 ] - in [ 14 ] ; step1 [ 7 ] = in [ 0 ] - in [ 15 ] ; {  int s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 ;   int t0 , t1 , t2 , t3 ;   int x0 , x1 , x2 , x3 ;  s0 = input [ 0 ] + input [ 7 ] ; s1 = input [ 1 ] + input [ 6 ] ; s2 = input [ 2 ] + input [ 5 ] ; s3 = input [ 3 ] + input [ 4 ] ; s4 = input [ 3 ] - input [ 4 ] ; s5 = input [ 2 ] - input [ 5 ] ; s6 = input [ 1 ] - input [ 6 ] ; s7 = input [ 0 ] - input [ 7 ] ; x0 = s0 + s3 ; x1 = s1 + s2 ; x2 = s1 - s2 ; x3 = s0 - s3 ; t0 = ( x0 + x1 ) * cospi_16_64 ; t1 = ( x0 - x1 ) * cospi_16_64 ; t2 = x3 * cospi_8_64 + x2 * cospi_24_64 ; t3 = x3 * cospi_24_64 - x2 * cospi_8_64 ;  out [ 0 ] = fdct_round_shift ( t0 ) ;   out [ 4 ] = fdct_round_shift ( t2 ) ;   out [ 8 ] = fdct_round_shift ( t1 ) ;   out [ 12 ] = fdct_round_shift ( t3 ) ;  t0 = ( s6 - s5 ) * cospi_16_64 ; t1 = ( s6 + s5 ) * cospi_16_64 ; t2 = fdct_round_shift ( t0 ) ; t3 = fdct_round_shift ( t1 ) ; x0 = s4 + t2 ; x1 = s4 - t2 ; x2 = s7 - t3 ; x3 = s7 + t3 ; t0 = x0 * cospi_28_64 + x3 * cospi_4_64 ; t1 = x1 * cospi_12_64 + x2 * cospi_20_64 ; t2 = x2 * cospi_12_64 + x1 * - cospi_20_64 ; t3 = x3 * cospi_28_64 + x0 * - cospi_4_64 ;  out [ 2 ] = fdct_round_shift ( t0 ) ;   out [ 6 ] = fdct_round_shift ( t2 ) ;   out [ 10 ] = fdct_round_shift ( t1 ) ;   out [ 14 ] = fdct_round_shift ( t3 ) ;  } temp1 = ( step1 [ 5 ] - step1 [ 2 ] ) * cospi_16_64 ; temp2 = ( step1 [ 4 ] - step1 [ 3 ] ) * cospi_16_64 ; step2 [ 2 ] = fdct_round_shift ( temp1 ) ; step2 [ 3 ] = fdct_round_shift ( temp2 ) ; temp1 = ( step1 [ 4 ] + step1 [ 3 ] ) * cospi_16_64 ; temp2 = ( step1 [ 5 ] + step1 [ 2 ] ) * cospi_16_64 ; step2 [ 4 ] = fdct_round_shift ( temp1 ) ; step2 [ 5 ] = fdct_round_shift ( temp2 ) ; step3 [ 0 ] = step1 [ 0 ] + step2 [ 3 ] ; step3 [ 1 ] = step1 [ 1 ] + step2 [ 2 ] ; step3 [ 2 ] = step1 [ 1 ] - step2 [ 2 ] ; step3 [ 3 ] = step1 [ 0 ] - step2 [ 3 ] ; step3 [ 4 ] = step1 [ 7 ] - step2 [ 4 ] ; step3 [ 5 ] = step1 [ 6 ] - step2 [ 5 ] ; step3 [ 6 ] = step1 [ 6 ] + step2 [ 5 ] ; step3 [ 7 ] = step1 [ 7 ] + step2 [ 4 ] ; temp1 = step3 [ 1 ] * - cospi_8_64 + step3 [ 6 ] * cospi_24_64 ;  temp2 = step3 [ 2 ] * - cospi_24_64 - step3 [ 5 ] * cospi_8_64 ;  step2 [ 1 ] = fdct_round_shift ( temp1 ) ; step2 [ 2 ] = fdct_round_shift ( temp2 ) ;  temp1 = step3 [ 2 ] * - cospi_8_64 + step3 [ 5 ] * cospi_24_64 ;  temp2 = step3 [ 1 ] * cospi_24_64 + step3 [ 6 ] * cospi_8_64 ; step2 [ 5 ] = fdct_round_shift ( temp1 ) ; step2 [ 6 ] = fdct_round_shift ( temp2 ) ; step1 [ 0 ] = step3 [ 0 ] + step2 [ 1 ] ; step1 [ 1 ] = step3 [ 0 ] - step2 [ 1 ] ;  step1 [ 2 ] = step3 [ 3 ] - step2 [ 2 ] ;  step1 [ 3 ] = step3 [ 3 ] + step2 [ 2 ] ; step1 [ 4 ] = step3 [ 4 ] + step2 [ 5 ] ; step1 [ 5 ] = step3 [ 4 ] - step2 [ 5 ] ; step1 [ 6 ] = step3 [ 7 ] - step2 [ 6 ] ; step1 [ 7 ] = step3 [ 7 ] + step2 [ 6 ] ; temp1 = step1 [ 0 ] * cospi_30_64 + step1 [ 7 ] * cospi_2_64 ; temp2 = step1 [ 1 ] * cospi_14_64 + step1 [ 6 ] * cospi_18_64 ;  out [ 1 ] = fdct_round_shift ( temp1 ) ;   out [ 9 ] = fdct_round_shift ( temp2 ) ;  temp1 = step1 [ 2 ] * cospi_22_64 + step1 [ 5 ] * cospi_10_64 ; temp2 = step1 [ 3 ] * cospi_6_64 + step1 [ 4 ] * cospi_26_64 ;  out [ 5 ] = fdct_round_shift ( temp1 ) ;   out [ 13 ] = fdct_round_shift ( temp2 ) ;  temp1 = step1 [ 3 ] * - cospi_26_64 + step1 [ 4 ] * cospi_6_64 ; temp2 = step1 [ 2 ] * - cospi_10_64 + step1 [ 5 ] * cospi_22_64 ;  out [ 3 ] = fdct_round_shift ( temp1 ) ;   out [ 11 ] = fdct_round_shift ( temp2 ) ;  temp1 = step1 [ 1 ] * - cospi_18_64 + step1 [ 6 ] * cospi_14_64 ; temp2 = step1 [ 0 ] * - cospi_2_64 + step1 [ 7 ] * cospi_30_64 ;  out [ 7 ] = fdct_round_shift ( temp1 ) ;   out [ 15 ] = fdct_round_shift ( temp2 ) ;  }",out [ 2 ] = ( tran_low_t ) fdct_round_shift ( t0 ) ;out [ 6 ] = ( tran_low_t ) fdct_round_shift ( t2 ) ;out [ 10 ] = ( tran_low_t ) fdct_round_shift ( t1 ) ;out [ 14 ] = ( tran_low_t ) fdct_round_shift ( t3 ) ;},15
24,"buggy line: temp2 = step3 [ 2 ] * - cospi_24_64 - step3 [ 5 ] * cospi_8_64 ;step2 [ 1 ] = fdct_round_shift ( temp1 ) ;temp1 = step3 [ 2 ] * - cospi_8_64 + step3 [ 5 ] * cospi_24_64 ;temp2 = step3 [ 1 ] * cospi_24_64 + step3 [ 6 ] * cospi_8_64 ;step1 [ 2 ] = step3 [ 3 ] - step2 [ 2 ] ;step1 [ 3 ] = step3 [ 3 ] + step2 [ 2 ] ;step1 [ 4 ] = step3 [ 4 ] + step2 [ 5 ] ;out [ 1 ] = fdct_round_shift ( temp1 ) ;out [ 9 ] = fdct_round_shift ( temp2 ) ;temp1 = step1 [ 2 ] * cospi_22_64 + step1 [ 5 ] * cospi_10_64 ;out [ 5 ] = fdct_round_shift ( temp1 ) ;out [ 13 ] = fdct_round_shift ( temp2 ) ;temp1 = step1 [ 3 ] * - cospi_26_64 + step1 [ 4 ] * cospi_6_64 ;out [ 3 ] = fdct_round_shift ( temp1 ) ;out [ 11 ] = fdct_round_shift ( temp2 ) ;temp1 = step1 [ 1 ] * - cospi_18_64 + step1 [ 6 ] * cospi_14_64 ;out [ 7 ] = fdct_round_shift ( temp1 ) ;out [ 15 ] = fdct_round_shift ( temp2 ) ;}cwe id:CWE-119context:  static void fdct16 ( const int16_t in [ 16 ] , int16_t out [ 16 ] ) {   int step1 [ 8 ] ;   int step2 [ 8 ] ;   int step3 [ 8 ] ;   int input [ 8 ] ;   int temp1 , temp2 ;  input [ 0 ] = in [ 0 ] + in [ 15 ] ; input [ 1 ] = in [ 1 ] + in [ 14 ] ; input [ 2 ] = in [ 2 ] + in [ 13 ] ; input [ 3 ] = in [ 3 ] + in [ 12 ] ; input [ 4 ] = in [ 4 ] + in [ 11 ] ; input [ 5 ] = in [ 5 ] + in [ 10 ] ; input [ 6 ] = in [ 6 ] + in [ 9 ] ; input [ 7 ] = in [ 7 ] + in [ 8 ] ; step1 [ 0 ] = in [ 7 ] - in [ 8 ] ; step1 [ 1 ] = in [ 6 ] - in [ 9 ] ; step1 [ 2 ] = in [ 5 ] - in [ 10 ] ; step1 [ 3 ] = in [ 4 ] - in [ 11 ] ; step1 [ 4 ] = in [ 3 ] - in [ 12 ] ; step1 [ 5 ] = in [ 2 ] - in [ 13 ] ; step1 [ 6 ] = in [ 1 ] - in [ 14 ] ; step1 [ 7 ] = in [ 0 ] - in [ 15 ] ; {  int s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 ;   int t0 , t1 , t2 , t3 ;   int x0 , x1 , x2 , x3 ;  s0 = input [ 0 ] + input [ 7 ] ; s1 = input [ 1 ] + input [ 6 ] ; s2 = input [ 2 ] + input [ 5 ] ; s3 = input [ 3 ] + input [ 4 ] ; s4 = input [ 3 ] - input [ 4 ] ; s5 = input [ 2 ] - input [ 5 ] ; s6 = input [ 1 ] - input [ 6 ] ; s7 = input [ 0 ] - input [ 7 ] ; x0 = s0 + s3 ; x1 = s1 + s2 ; x2 = s1 - s2 ; x3 = s0 - s3 ; t0 = ( x0 + x1 ) * cospi_16_64 ; t1 = ( x0 - x1 ) * cospi_16_64 ; t2 = x3 * cospi_8_64 + x2 * cospi_24_64 ; t3 = x3 * cospi_24_64 - x2 * cospi_8_64 ;  out [ 0 ] = fdct_round_shift ( t0 ) ;   out [ 4 ] = fdct_round_shift ( t2 ) ;   out [ 8 ] = fdct_round_shift ( t1 ) ;   out [ 12 ] = fdct_round_shift ( t3 ) ;  t0 = ( s6 - s5 ) * cospi_16_64 ; t1 = ( s6 + s5 ) * cospi_16_64 ; t2 = fdct_round_shift ( t0 ) ; t3 = fdct_round_shift ( t1 ) ; x0 = s4 + t2 ; x1 = s4 - t2 ; x2 = s7 - t3 ; x3 = s7 + t3 ; t0 = x0 * cospi_28_64 + x3 * cospi_4_64 ; t1 = x1 * cospi_12_64 + x2 * cospi_20_64 ; t2 = x2 * cospi_12_64 + x1 * - cospi_20_64 ; t3 = x3 * cospi_28_64 + x0 * - cospi_4_64 ;  out [ 2 ] = fdct_round_shift ( t0 ) ;   out [ 6 ] = fdct_round_shift ( t2 ) ;   out [ 10 ] = fdct_round_shift ( t1 ) ;   out [ 14 ] = fdct_round_shift ( t3 ) ;  } temp1 = ( step1 [ 5 ] - step1 [ 2 ] ) * cospi_16_64 ; temp2 = ( step1 [ 4 ] - step1 [ 3 ] ) * cospi_16_64 ; step2 [ 2 ] = fdct_round_shift ( temp1 ) ; step2 [ 3 ] = fdct_round_shift ( temp2 ) ; temp1 = ( step1 [ 4 ] + step1 [ 3 ] ) * cospi_16_64 ; temp2 = ( step1 [ 5 ] + step1 [ 2 ] ) * cospi_16_64 ; step2 [ 4 ] = fdct_round_shift ( temp1 ) ; step2 [ 5 ] = fdct_round_shift ( temp2 ) ; step3 [ 0 ] = step1 [ 0 ] + step2 [ 3 ] ; step3 [ 1 ] = step1 [ 1 ] + step2 [ 2 ] ; step3 [ 2 ] = step1 [ 1 ] - step2 [ 2 ] ; step3 [ 3 ] = step1 [ 0 ] - step2 [ 3 ] ; step3 [ 4 ] = step1 [ 7 ] - step2 [ 4 ] ; step3 [ 5 ] = step1 [ 6 ] - step2 [ 5 ] ; step3 [ 6 ] = step1 [ 6 ] + step2 [ 5 ] ; step3 [ 7 ] = step1 [ 7 ] + step2 [ 4 ] ; temp1 = step3 [ 1 ] * - cospi_8_64 + step3 [ 6 ] * cospi_24_64 ;  temp2 = step3 [ 2 ] * - cospi_24_64 - step3 [ 5 ] * cospi_8_64 ;  step2 [ 1 ] = fdct_round_shift ( temp1 ) ; step2 [ 2 ] = fdct_round_shift ( temp2 ) ;  temp1 = step3 [ 2 ] * - cospi_8_64 + step3 [ 5 ] * cospi_24_64 ;  temp2 = step3 [ 1 ] * cospi_24_64 + step3 [ 6 ] * cospi_8_64 ; step2 [ 5 ] = fdct_round_shift ( temp1 ) ; step2 [ 6 ] = fdct_round_shift ( temp2 ) ; step1 [ 0 ] = step3 [ 0 ] + step2 [ 1 ] ; step1 [ 1 ] = step3 [ 0 ] - step2 [ 1 ] ;  step1 [ 2 ] = step3 [ 3 ] - step2 [ 2 ] ;  step1 [ 3 ] = step3 [ 3 ] + step2 [ 2 ] ; step1 [ 4 ] = step3 [ 4 ] + step2 [ 5 ] ; step1 [ 5 ] = step3 [ 4 ] - step2 [ 5 ] ; step1 [ 6 ] = step3 [ 7 ] - step2 [ 6 ] ; step1 [ 7 ] = step3 [ 7 ] + step2 [ 6 ] ; temp1 = step1 [ 0 ] * cospi_30_64 + step1 [ 7 ] * cospi_2_64 ; temp2 = step1 [ 1 ] * cospi_14_64 + step1 [ 6 ] * cospi_18_64 ;  out [ 1 ] = fdct_round_shift ( temp1 ) ;   out [ 9 ] = fdct_round_shift ( temp2 ) ;  temp1 = step1 [ 2 ] * cospi_22_64 + step1 [ 5 ] * cospi_10_64 ; temp2 = step1 [ 3 ] * cospi_6_64 + step1 [ 4 ] * cospi_26_64 ;  out [ 5 ] = fdct_round_shift ( temp1 ) ;   out [ 13 ] = fdct_round_shift ( temp2 ) ;  temp1 = step1 [ 3 ] * - cospi_26_64 + step1 [ 4 ] * cospi_6_64 ; temp2 = step1 [ 2 ] * - cospi_10_64 + step1 [ 5 ] * cospi_22_64 ;  out [ 3 ] = fdct_round_shift ( temp1 ) ;   out [ 11 ] = fdct_round_shift ( temp2 ) ;  temp1 = step1 [ 1 ] * - cospi_18_64 + step1 [ 6 ] * cospi_14_64 ; temp2 = step1 [ 0 ] * - cospi_2_64 + step1 [ 7 ] * cospi_30_64 ;  out [ 7 ] = fdct_round_shift ( temp1 ) ;   out [ 15 ] = fdct_round_shift ( temp2 ) ;  }",temp2 = step3 [ 2 ] * cospi_24_64 + step3 [ 5 ] * cospi_8_64 ;step2 [ 1 ] = fdct_round_shift ( temp1 ) ;temp1 = step3 [ 2 ] * cospi_8_64 - step3 [ 5 ] * cospi_24_64 ;temp2 = step3 [ 1 ] * cospi_24_64 + step3 [ 6 ] * cospi_8_64 ;step1 [ 2 ] = step3 [ 3 ] + step2 [ 2 ] ;step1 [ 3 ] = step3 [ 3 ] - step2 [ 2 ] ;step1 [ 4 ] = step3 [ 4 ] - step2 [ 5 ] ;step1 [ 5 ] = step3 [ 4 ] + step2 [ 5 ] ;out [ 1 ] = ( tran_low_t ) fdct_round_shift ( temp1 ) ;out [ 9 ] = ( tran_low_t ) fdct_round_shift ( temp2 ) ;temp1 = step1 [ 2 ] * cospi_22_64 + step1 [ 5 ] * cospi_10_64 ;out [ 5 ] = ( tran_low_t ) fdct_round_shift ( temp1 ) ;out [ 13 ] = ( tran_low_t ) fdct_round_shift ( temp2 ) ;temp1 = step1 [ 3 ] * - cospi_26_64 + step1 [ 4 ] * cospi_6_64 ;out [ 3 ] = ( tran_low_t ) fdct_round_shift ( temp1 ) ;out [ 11 ] = ( tran_low_t ) fdct_round_shift ( temp2 ) ;temp1 = step1 [ 1 ] * - cospi_18_64 + step1 [ 6 ] * cospi_14_64 ;out [ 7 ] = ( tran_low_t ) fdct_round_shift ( temp1 ) ;out [ 15 ] = ( tran_low_t ) fdct_round_shift ( temp2 ) ;},15
25,"buggy line: if ( ARRAY_SIZE ( bpf_verifier_ops ) == 0 ) return - EINVAL ;cwe id:CWE-20context: int bpf_check ( struct bpf_prog * * prog , union bpf_attr * attr ) { struct bpf_verifier_env * env ; struct bpf_verifer_log * log ; int ret = - EINVAL ; if ( ARRAY_SIZE ( bpf_verifier_ops ) == 0 ) return - EINVAL ; env = kzalloc ( sizeof ( struct bpf_verifier_env ) , GFP_KERNEL ) ; if ( ! env ) return - ENOMEM ; log = & env -> log ; env -> insn_aux_data = vzalloc ( sizeof ( struct bpf_insn_aux_data ) * ( * prog ) -> len ) ; ret = - ENOMEM ; if ( ! env -> insn_aux_data ) goto err_free_env ; env -> prog = * prog ; env -> ops = bpf_verifier_ops [ env -> prog -> type ] ; mutex_lock ( & bpf_verifier_lock ) ; if ( attr -> log_level || attr -> log_buf || attr -> log_size ) { log -> level = attr -> log_level ; log -> ubuf = ( char __user * ) ( unsigned long ) attr -> log_buf ; log -> len_total = attr -> log_size ; ret = - EINVAL ; if ( log -> len_total < 128 || log -> len_total > UINT_MAX >> 8 || ! log -> level || ! log -> ubuf ) goto err_unlock ; } env -> strict_alignment = ! ! ( attr -> prog_flags & BPF_F_STRICT_ALIGNMENT ) ; if ( ! IS_ENABLED ( CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS ) ) env -> strict_alignment = true ; if ( env -> prog -> aux -> offload ) { ret = bpf_prog_offload_verifier_prep ( env ) ; if ( ret ) goto err_unlock ; } ret = replace_map_fd_with_map_ptr ( env ) ; if ( ret < 0 ) goto skip_full_check ; env -> explored_states = kcalloc ( env -> prog -> len , sizeof ( struct bpf_verifier_state_list * ) , GFP_USER ) ; ret = - ENOMEM ; if ( ! env -> explored_states ) goto skip_full_check ; ret = check_cfg ( env ) ; if ( ret < 0 ) goto skip_full_check ; env -> allow_ptr_leaks = capable ( CAP_SYS_ADMIN ) ; ret = do_check ( env ) ; if ( env -> cur_state ) { free_verifier_state ( env -> cur_state , true ) ; env -> cur_state = NULL ; } skip_full_check : while ( ! pop_stack ( env , NULL , NULL ) ) ; free_states ( env ) ; if ( ret == 0 )  ret = convert_ctx_accesses ( env ) ;  if ( ret == 0 ) ret = fixup_bpf_calls ( env ) ; if ( log -> level && bpf_verifier_log_full ( log ) ) ret = - ENOSPC ; if ( log -> level && ! log -> ubuf ) { ret = - EFAULT ; goto err_release_maps ; } if ( ret == 0 && env -> used_map_cnt ) { env -> prog -> aux -> used_maps = kmalloc_array ( env -> used_map_cnt , sizeof ( env -> used_maps [ 0 ] ) , GFP_KERNEL ) ; if ( ! env -> prog -> aux -> used_maps ) { ret = - ENOMEM ; goto err_release_maps ; } memcpy ( env -> prog -> aux -> used_maps , env -> used_maps , sizeof ( env -> used_maps [ 0 ] ) * env -> used_map_cnt ) ; env -> prog -> aux -> used_map_cnt = env -> used_map_cnt ; convert_pseudo_ld_imm64 ( env ) ; } err_release_maps : if ( ! env -> prog -> aux -> used_maps ) release_maps ( env ) ; * prog = env -> prog ; err_unlock : mutex_unlock ( & bpf_verifier_lock ) ; vfree ( env -> insn_aux_data ) ; err_free_env : kfree ( env ) ; return ret ; }",if ( ARRAY_SIZE ( bpf_verifier_ops ) == 0 ) sanitize_dead_code ( env ) ;if ( ret == 0 ) return - EINVAL ;,16
26,"buggy line: if ( ret == 0 )  ret = convert_ctx_accesses ( env ) ;if ( ret == 0 ) ret = fixup_bpf_calls ( env ) ;cwe id:CWE-20context: int bpf_check ( struct bpf_prog * * prog , union bpf_attr * attr ) { struct bpf_verifier_env * env ; struct bpf_verifer_log * log ; int ret = - EINVAL ; if ( ARRAY_SIZE ( bpf_verifier_ops ) == 0 ) return - EINVAL ; env = kzalloc ( sizeof ( struct bpf_verifier_env ) , GFP_KERNEL ) ; if ( ! env ) return - ENOMEM ; log = & env -> log ; env -> insn_aux_data = vzalloc ( sizeof ( struct bpf_insn_aux_data ) * ( * prog ) -> len ) ; ret = - ENOMEM ; if ( ! env -> insn_aux_data ) goto err_free_env ; env -> prog = * prog ; env -> ops = bpf_verifier_ops [ env -> prog -> type ] ; mutex_lock ( & bpf_verifier_lock ) ; if ( attr -> log_level || attr -> log_buf || attr -> log_size ) { log -> level = attr -> log_level ; log -> ubuf = ( char __user * ) ( unsigned long ) attr -> log_buf ; log -> len_total = attr -> log_size ; ret = - EINVAL ; if ( log -> len_total < 128 || log -> len_total > UINT_MAX >> 8 || ! log -> level || ! log -> ubuf ) goto err_unlock ; } env -> strict_alignment = ! ! ( attr -> prog_flags & BPF_F_STRICT_ALIGNMENT ) ; if ( ! IS_ENABLED ( CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS ) ) env -> strict_alignment = true ; if ( env -> prog -> aux -> offload ) { ret = bpf_prog_offload_verifier_prep ( env ) ; if ( ret ) goto err_unlock ; } ret = replace_map_fd_with_map_ptr ( env ) ; if ( ret < 0 ) goto skip_full_check ; env -> explored_states = kcalloc ( env -> prog -> len , sizeof ( struct bpf_verifier_state_list * ) , GFP_USER ) ; ret = - ENOMEM ; if ( ! env -> explored_states ) goto skip_full_check ; ret = check_cfg ( env ) ; if ( ret < 0 ) goto skip_full_check ; env -> allow_ptr_leaks = capable ( CAP_SYS_ADMIN ) ; ret = do_check ( env ) ; if ( env -> cur_state ) { free_verifier_state ( env -> cur_state , true ) ; env -> cur_state = NULL ; } skip_full_check : while ( ! pop_stack ( env , NULL , NULL ) ) ; free_states ( env ) ; if ( ret == 0 )  ret = convert_ctx_accesses ( env ) ;  if ( ret == 0 ) ret = fixup_bpf_calls ( env ) ; if ( log -> level && bpf_verifier_log_full ( log ) ) ret = - ENOSPC ; if ( log -> level && ! log -> ubuf ) { ret = - EFAULT ; goto err_release_maps ; } if ( ret == 0 && env -> used_map_cnt ) { env -> prog -> aux -> used_maps = kmalloc_array ( env -> used_map_cnt , sizeof ( env -> used_maps [ 0 ] ) , GFP_KERNEL ) ; if ( ! env -> prog -> aux -> used_maps ) { ret = - ENOMEM ; goto err_release_maps ; } memcpy ( env -> prog -> aux -> used_maps , env -> used_maps , sizeof ( env -> used_maps [ 0 ] ) * env -> used_map_cnt ) ; env -> prog -> aux -> used_map_cnt = env -> used_map_cnt ; convert_pseudo_ld_imm64 ( env ) ; } err_release_maps : if ( ! env -> prog -> aux -> used_maps ) release_maps ( env ) ; * prog = env -> prog ; err_unlock : mutex_unlock ( & bpf_verifier_lock ) ; vfree ( env -> insn_aux_data ) ; err_free_env : kfree ( env ) ; return ret ; }",if ( ret == 0 ) ret = convert_ctx_accesses ( env ) ;if ( ret == 0 ) ret = fixup_bpf_calls ( env ) ;,16
27,"buggy line: int i ;wpc -> stream_version = ( config -> flags & CONFIG_COMPATIBLE_WRITE ) ? CUR_STREAM_VERS : MAX_STREAM_VERS ;cwe id:CWE-835context: int WavpackSetConfiguration64 ( WavpackContext * wpc , WavpackConfig * config , int64_t total_samples , const unsigned char * chan_ids ) { uint32_t flags , bps = 0 ; uint32_t chan_mask = config -> channel_mask ; int num_chans = config -> num_channels ;  int i ;  wpc -> stream_version = ( config -> flags & CONFIG_COMPATIBLE_WRITE ) ? CUR_STREAM_VERS : MAX_STREAM_VERS ; if ( ( config -> qmode & QMODE_DSD_AUDIO ) && config -> bytes_per_sample == 1 && config -> bits_per_sample == 8 ) { # ifdef ENABLE_DSD wpc -> dsd_multiplier = 1 ; flags = DSD_FLAG ; for ( i = 14 ; i >= 0 ; -- i ) if ( config -> sample_rate % sample_rates [ i ] == 0 ) { int divisor = config -> sample_rate / sample_rates [ i ] ; if ( divisor && ( divisor & ( divisor - 1 ) ) == 0 ) { config -> sample_rate /= divisor ; wpc -> dsd_multiplier = divisor ; break ; } } if ( config -> flags & CONFIG_HYBRID_FLAG ) { strcpy ( wpc -> error_message , ""hybrid<S2SV_blank>mode<S2SV_blank>not<S2SV_blank>available<S2SV_blank>for<S2SV_blank>DSD!"" ) ; return FALSE ; } config -> flags &= ( CONFIG_HIGH_FLAG | CONFIG_MD5_CHECKSUM | CONFIG_PAIR_UNDEF_CHANS ) ; config -> float_norm_exp = config -> xmode = 0 ; # else strcpy ( wpc -> error_message , ""libwavpack<S2SV_blank>not<S2SV_blank>configured<S2SV_blank>for<S2SV_blank>DSD!"" ) ; return FALSE ; # endif } else flags = config -> bytes_per_sample - 1 ; wpc -> total_samples = total_samples ; wpc -> config . sample_rate = config -> sample_rate ; wpc -> config . num_channels = config -> num_channels ; wpc -> config . channel_mask = config -> channel_mask ; wpc -> config . bits_per_sample = config -> bits_per_sample ; wpc -> config . bytes_per_sample = config -> bytes_per_sample ; wpc -> config . block_samples = config -> block_samples ; wpc -> config . flags = config -> flags ; wpc -> config . qmode = config -> qmode ; if ( config -> flags & CONFIG_VERY_HIGH_FLAG ) wpc -> config . flags |= CONFIG_HIGH_FLAG ; for ( i = 0 ; i < 15 ; ++ i ) if ( wpc -> config . sample_rate == sample_rates [ i ] ) break ; flags |= i << SRATE_LSB ; if ( ! ( flags & DSD_FLAG ) ) { if ( config -> float_norm_exp ) { wpc -> config . float_norm_exp = config -> float_norm_exp ; wpc -> config . flags |= CONFIG_FLOAT_DATA ; flags |= FLOAT_DATA ; } else flags |= ( ( config -> bytes_per_sample * 8 ) - config -> bits_per_sample ) << SHIFT_LSB ; if ( config -> flags & CONFIG_HYBRID_FLAG ) { flags |= HYBRID_FLAG | HYBRID_BITRATE | HYBRID_BALANCE ; if ( ! ( wpc -> config . flags & CONFIG_SHAPE_OVERRIDE ) ) { wpc -> config . flags |= CONFIG_HYBRID_SHAPE | CONFIG_AUTO_SHAPING ; flags |= HYBRID_SHAPE | NEW_SHAPING ; } else if ( wpc -> config . flags & CONFIG_HYBRID_SHAPE ) { wpc -> config . shaping_weight = config -> shaping_weight ; flags |= HYBRID_SHAPE | NEW_SHAPING ; } if ( wpc -> config . flags & ( CONFIG_CROSS_DECORR | CONFIG_OPTIMIZE_WVC ) ) flags |= CROSS_DECORR ; if ( config -> flags & CONFIG_BITRATE_KBPS ) { bps = ( uint32_t ) floor ( config -> bitrate * 256000.0 / config -> sample_rate / config -> num_channels + 0.5 ) ; if ( bps > ( 64 << 8 ) ) bps = 64 << 8 ; } else bps = ( uint32_t ) floor ( config -> bitrate * 256.0 + 0.5 ) ; } else flags |= CROSS_DECORR ; if ( ! ( config -> flags & CONFIG_JOINT_OVERRIDE ) || ( config -> flags & CONFIG_JOINT_STEREO ) ) flags |= JOINT_STEREO ; if ( config -> flags & CONFIG_CREATE_WVC ) wpc -> wvc_flag = TRUE ; } if ( chan_ids ) { int lastchan = 0 , mask_copy = chan_mask ; if ( ( int ) strlen ( ( char * ) chan_ids ) > num_chans ) { strcpy ( wpc -> error_message , ""chan_ids<S2SV_blank>longer<S2SV_blank>than<S2SV_blank>num<S2SV_blank>channels!"" ) ; return FALSE ; } while ( * chan_ids ) if ( * chan_ids <= 32 && * chan_ids > lastchan && ( mask_copy & ( 1 << ( * chan_ids - 1 ) ) ) ) { mask_copy &= ~ ( 1 << ( * chan_ids - 1 ) ) ; lastchan = * chan_ids ++ ; } else break ; for ( i = 0 ; chan_ids [ i ] ; i ++ ) if ( chan_ids [ i ] != 0xff ) { wpc -> channel_identities = ( unsigned char * ) strdup ( ( char * ) chan_ids ) ; break ; } } for ( wpc -> current_stream = 0 ; num_chans ; wpc -> current_stream ++ ) { WavpackStream * wps = malloc ( sizeof ( WavpackStream ) ) ; unsigned char left_chan_id = 0 , right_chan_id = 0 ; int pos , chans = 1 ; wpc -> streams = realloc ( wpc -> streams , ( wpc -> current_stream + 1 ) * sizeof ( wpc -> streams [ 0 ] ) ) ; wpc -> streams [ wpc -> current_stream ] = wps ; CLEAR ( * wps ) ; if ( chan_mask ) for ( pos = 0 ; pos < 32 ; ++ pos ) if ( chan_mask & ( 1 << pos ) ) { if ( left_chan_id ) { right_chan_id = pos + 1 ; break ; } else { chan_mask &= ~ ( 1 << pos ) ; left_chan_id = pos + 1 ; } } while ( ! right_chan_id && chan_ids && * chan_ids ) if ( left_chan_id ) right_chan_id = * chan_ids ; else left_chan_id = * chan_ids ++ ; if ( ! left_chan_id ) left_chan_id = right_chan_id = 0xff ; else if ( ! right_chan_id ) right_chan_id = 0xff ; if ( num_chans >= 2 ) { if ( ( config -> flags & CONFIG_PAIR_UNDEF_CHANS ) && left_chan_id == 0xff && right_chan_id == 0xff ) chans = 2 ; else for ( i = 0 ; i < NUM_STEREO_PAIRS ; ++ i ) if ( ( left_chan_id == stereo_pairs [ i ] . a && right_chan_id == stereo_pairs [ i ] . b ) || ( left_chan_id == stereo_pairs [ i ] . b && right_chan_id == stereo_pairs [ i ] . a ) ) { if ( right_chan_id <= 32 && ( chan_mask & ( 1 << ( right_chan_id - 1 ) ) ) ) chan_mask &= ~ ( 1 << ( right_chan_id - 1 ) ) ; else if ( chan_ids && * chan_ids == right_chan_id ) chan_ids ++ ; chans = 2 ; break ; } } num_chans -= chans ; if ( num_chans && wpc -> current_stream == NEW_MAX_STREAMS - 1 ) break ; memcpy ( wps -> wphdr . ckID , ""wvpk"" , 4 ) ; wps -> wphdr . ckSize = sizeof ( WavpackHeader ) - 8 ; SET_TOTAL_SAMPLES ( wps -> wphdr , wpc -> total_samples ) ; wps -> wphdr . version = wpc -> stream_version ; wps -> wphdr . flags = flags ; wps -> bits = bps ; if ( ! wpc -> current_stream ) wps -> wphdr . flags |= INITIAL_BLOCK ; if ( ! num_chans ) wps -> wphdr . flags |= FINAL_BLOCK ; if ( chans == 1 ) { wps -> wphdr . flags &= ~ ( JOINT_STEREO | CROSS_DECORR | HYBRID_BALANCE ) ; wps -> wphdr . flags |= MONO_FLAG ; } } wpc -> num_streams = wpc -> current_stream ; wpc -> current_stream = 0 ; if ( num_chans ) { strcpy ( wpc -> error_message , ""too<S2SV_blank>many<S2SV_blank>channels!"" ) ; return FALSE ; } if ( config -> flags & CONFIG_EXTRA_MODE ) wpc -> config . xmode = config -> xmode ? config -> xmode : 1 ; return TRUE ; }","int i ;if ( ! config -> sample_rate ) {strcpy ( wpc -> error_message , ""sample<S2SV_blank>rate<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>zero!"" ) ;return FALSE ;}wpc -> stream_version = ( config -> flags & CONFIG_COMPATIBLE_WRITE ) ? CUR_STREAM_VERS : MAX_STREAM_VERS ;",17
28,"buggy line: SDev = cd -> device ;retry : if ( ! scsi_block_when_processing_errors ( SDev ) ) {result = scsi_execute ( SDev , cgc -> cmd , cgc -> data_direction , cgc -> buffer , cgc -> buflen ,  ( unsigned char * ) cgc -> sense , & sshdr ,  cgc -> timeout , IOCTL_RETRIES , 0 , 0 , NULL ) ;cwe id:CWE-787context: int sr_do_ioctl ( Scsi_CD * cd , struct packet_command * cgc ) { struct scsi_device * SDev ; struct scsi_sense_hdr sshdr ; int result , err = 0 , retries = 0 ;  SDev = cd -> device ;  retry : if ( ! scsi_block_when_processing_errors ( SDev ) ) { err = - ENODEV ; goto out ; } result = scsi_execute ( SDev , cgc -> cmd , cgc -> data_direction , cgc -> buffer , cgc -> buflen ,  ( unsigned char * ) cgc -> sense , & sshdr ,  cgc -> timeout , IOCTL_RETRIES , 0 , 0 , NULL ) ; if ( driver_byte ( result ) != 0 ) { switch ( sshdr . sense_key ) { case UNIT_ATTENTION : SDev -> changed = 1 ; if ( ! cgc -> quiet ) sr_printk ( KERN_INFO , cd , ""disc<S2SV_blank>change<S2SV_blank>detected.\\n"" ) ; if ( retries ++ < 10 ) goto retry ; err = - ENOMEDIUM ; break ; case NOT_READY : if ( sshdr . asc == 0x04 && sshdr . ascq == 0x01 ) { if ( ! cgc -> quiet ) sr_printk ( KERN_INFO , cd , ""CDROM<S2SV_blank>not<S2SV_blank>ready<S2SV_blank>yet.\\n"" ) ; if ( retries ++ < 10 ) { ssleep ( 2 ) ; goto retry ; } else { err = - ENOMEDIUM ; break ; } } if ( ! cgc -> quiet ) sr_printk ( KERN_INFO , cd , ""CDROM<S2SV_blank>not<S2SV_blank>ready.<S2SV_blank><S2SV_blank>Make<S2SV_blank>sure<S2SV_blank>there<S2SV_blank>"" ""is<S2SV_blank>a<S2SV_blank>disc<S2SV_blank>in<S2SV_blank>the<S2SV_blank>drive.\\n"" ) ; err = - ENOMEDIUM ; break ; case ILLEGAL_REQUEST : err = - EIO ; if ( sshdr . asc == 0x20 && sshdr . ascq == 0x00 ) err = - EDRIVE_CANT_DO_THIS ; break ; default : err = - EIO ; } } out : cgc -> stat = err ; return err ; }","unsigned char sense_buffer [ SCSI_SENSE_BUFFERSIZE ] , * senseptr = NULL ;SDev = cd -> device ;if ( cgc -> sense ) senseptr = sense_buffer ;retry : if ( ! scsi_block_when_processing_errors ( SDev ) ) {result = scsi_execute ( SDev , cgc -> cmd , cgc -> data_direction , cgc -> buffer , cgc -> buflen , senseptr , & sshdr , cgc -> timeout , IOCTL_RETRIES , 0 , 0 , NULL ) ;if ( cgc -> sense ) ) ;",18
29,"buggy line: if ( get4 ( ) == 0x48454150 )  {# ifdef LIBRAW_LIBRARY_BUILD  imgdata . lens . makernotes . CameraMount = LIBRAW_MOUNT_FixedLens ;imgdata . lens . makernotes . LensMount = LIBRAW_MOUNT_FixedLens ;cwe id:CWE-119context: int CLASS parse_jpeg ( int offset ) { int len , save , hlen , mark ; fseek ( ifp , offset , SEEK_SET ) ; if ( fgetc ( ifp ) != 0xff || fgetc ( ifp ) != 0xd8 ) return 0 ; while ( fgetc ( ifp ) == 0xff && ( mark = fgetc ( ifp ) ) != 0xda ) { order = 0x4d4d ; len = get2 ( ) - 2 ; save = ftell ( ifp ) ; if ( mark == 0xc0 || mark == 0xc3 || mark == 0xc9 ) { fgetc ( ifp ) ; raw_height = get2 ( ) ; raw_width = get2 ( ) ; } order = get2 ( ) ; hlen = get4 ( ) ;  if ( get4 ( ) == 0x48454150 )  { # ifdef LIBRAW_LIBRARY_BUILD  imgdata . lens . makernotes . CameraMount = LIBRAW_MOUNT_FixedLens ;  imgdata . lens . makernotes . LensMount = LIBRAW_MOUNT_FixedLens ; # endif parse_ciff ( save + hlen , len - hlen , 0 ) ; } if ( parse_tiff ( save + 6 ) ) apply_tiff ( ) ; fseek ( ifp , save + len , SEEK_SET ) ; } return 1 ; }",if ( get4 ( ) == 0x48454150 # ifdef LIBRAW_LIBRARY_BUILD && ( save + hlen ) >= 0 && ( save + hlen ) <= ifp -> size ( ) # endif ) {# ifdef LIBRAW_LIBRARY_BUILD imgdata . lens . makernotes . CameraMount = LIBRAW_MOUNT_FixedLens ;imgdata . lens . makernotes . LensMount = LIBRAW_MOUNT_FixedLens ;,19
30,"buggy line: static void search_filter_level ( const YV12_BUFFER_CONFIG * sd , VP9_COMP * cpi ,  int partial_frame ) {VP9_COMMON * const cm = & cpi -> common ;struct loopfilter * const lf = & cm -> lf ;const int min_filter_level = 0 ;int best_err ;int filt_best ;int filt_direction = 0 ;int filt_mid = clamp ( lf -> filter_level , min_filter_level , max_filter_level ) ;int ss_err [ MAX_LOOP_FILTER + 1 ] ;vpx_memset ( ss_err , 0xFF , sizeof ( ss_err ) ) ;vpx_yv12_copy_y ( cm -> frame_to_show , & cpi -> last_frame_uf ) ;int filt_err ;int bias = ( best_err >> ( 15 - ( filt_mid / 8 ) ) ) * filter_step ;if ( cpi -> twopass . section_intra_rating < 20 )   bias = bias * cpi -> twopass . section_intra_rating / 20 ;if ( cm -> tx_mode != ONLY_4X4 ) bias >>= 1 ;filt_err = try_filter_frame ( sd , cpi , filt_low , partial_frame ) ;ss_err [ filt_low ] = filt_err ;}else {filt_err = ss_err [ filt_low ] ;if ( ( filt_err - bias ) < best_err ) {if ( filt_err < best_err )  best_err = filt_err ;if ( ss_err [ filt_high ] < 0 ) {filt_err = try_filter_frame ( sd , cpi , filt_high , partial_frame ) ;ss_err [ filt_high ] = filt_err ;}else {filt_err = ss_err [ filt_high ] ;}if ( filt_err < ( best_err - bias ) ) {best_err = filt_err ;filt_best = filt_high ;cwe id:CWE-119context:  static void search_filter_level ( const YV12_BUFFER_CONFIG * sd , VP9_COMP * cpi ,  int partial_frame ) {  VP9_COMMON * const cm = & cpi -> common ;   struct loopfilter * const lf = & cm -> lf ;  const int min_filter_level = 0 ; const int max_filter_level = get_max_filter_level ( cpi ) ;  int best_err ;  int filt_best ;  int filt_direction = 0 ;  int filt_mid = clamp ( lf -> filter_level , min_filter_level , max_filter_level ) ; int filter_step = filt_mid < 16 ? 4 : filt_mid / 4 ;  int ss_err [ MAX_LOOP_FILTER + 1 ] ;   vpx_memset ( ss_err , 0xFF , sizeof ( ss_err ) ) ;  vpx_yv12_copy_y ( cm -> frame_to_show , & cpi -> last_frame_uf ) ; best_err = try_filter_frame ( sd , cpi , filt_mid , partial_frame ) ; filt_best = filt_mid ; ss_err [ filt_mid ] = best_err ; while ( filter_step > 0 ) { const int filt_high = MIN ( filt_mid + filter_step , max_filter_level ) ; const int filt_low = MAX ( filt_mid - filter_step , min_filter_level ) ;  int filt_err ;  int bias = ( best_err >> ( 15 - ( filt_mid / 8 ) ) ) * filter_step ;  if ( cpi -> twopass . section_intra_rating < 20 )   bias = bias * cpi -> twopass . section_intra_rating / 20 ;  if ( cm -> tx_mode != ONLY_4X4 ) bias >>= 1 ; if ( filt_direction <= 0 && filt_low != filt_mid ) { if ( ss_err [ filt_low ] < 0 ) {  filt_err = try_filter_frame ( sd , cpi , filt_low , partial_frame ) ;   ss_err [ filt_low ] = filt_err ;  } else { filt_err = ss_err [ filt_low ] ; } if ( ( filt_err - bias ) < best_err ) {  if ( filt_err < best_err )  best_err = filt_err ; filt_best = filt_low ; } } if ( filt_direction >= 0 && filt_high != filt_mid ) { if ( ss_err [ filt_high ] < 0 ) {  filt_err = try_filter_frame ( sd , cpi , filt_high , partial_frame ) ;   ss_err [ filt_high ] = filt_err ;  } else { filt_err = ss_err [ filt_high ] ; } if ( filt_err < ( best_err - bias ) ) {  best_err = filt_err ;  filt_best = filt_high ; } } if ( filt_best == filt_mid ) { filter_step /= 2 ; filt_direction = 0 ; } else { filt_direction = ( filt_best < filt_mid ) ? - 1 : 1 ; filt_mid = filt_best ; } }  lf -> filter_level = filt_best ;  }","static int search_filter_level ( const YV12_BUFFER_CONFIG * sd , VP9_COMP * cpi , int partial_frame ) {const VP9_COMMON * const cm = & cpi -> common ;const struct loopfilter * const lf = & cm -> lf ;const int min_filter_level = 0 ;int filt_direction = 0 ;int64_t best_err ;int filt_best ;int filt_mid = clamp ( lf -> filter_level , min_filter_level , max_filter_level ) ;int64_t ss_err [ MAX_LOOP_FILTER + 1 ] ;memset ( ss_err , 0xFF , sizeof ( ss_err ) ) ;vpx_yv12_copy_y ( cm -> frame_to_show , & cpi -> last_frame_uf ) ;int64_t bias = ( best_err >> ( 15 - ( filt_mid / 8 ) ) ) * filter_step ;if ( ( cpi -> oxcf . pass == 2 ) && ( cpi -> twopass . section_intra_rating < 20 ) ) bias = ( bias * cpi -> twopass . section_intra_rating ) / 20 ;if ( cm -> tx_mode != ONLY_4X4 ) bias >>= 1 ;ss_err [ filt_low ] = try_filter_frame ( sd , cpi , filt_low , partial_frame ) ;if ( ( ss_err [ filt_low ] - bias ) < best_err ) {if ( filt_err < best_err ) best_err = filt_err ;if ( ss_err [ filt_low ] < best_err ) best_err = ss_err [ filt_low ] ;filt_best = filt_high ;",20
31,"buggy line: lf -> filter_level = filt_best ;}cwe id:CWE-119context:  static void search_filter_level ( const YV12_BUFFER_CONFIG * sd , VP9_COMP * cpi ,  int partial_frame ) {  VP9_COMMON * const cm = & cpi -> common ;   struct loopfilter * const lf = & cm -> lf ;  const int min_filter_level = 0 ; const int max_filter_level = get_max_filter_level ( cpi ) ;  int best_err ;  int filt_best ;  int filt_direction = 0 ;  int filt_mid = clamp ( lf -> filter_level , min_filter_level , max_filter_level ) ; int filter_step = filt_mid < 16 ? 4 : filt_mid / 4 ;  int ss_err [ MAX_LOOP_FILTER + 1 ] ;   vpx_memset ( ss_err , 0xFF , sizeof ( ss_err ) ) ;  vpx_yv12_copy_y ( cm -> frame_to_show , & cpi -> last_frame_uf ) ; best_err = try_filter_frame ( sd , cpi , filt_mid , partial_frame ) ; filt_best = filt_mid ; ss_err [ filt_mid ] = best_err ; while ( filter_step > 0 ) { const int filt_high = MIN ( filt_mid + filter_step , max_filter_level ) ; const int filt_low = MAX ( filt_mid - filter_step , min_filter_level ) ;  int filt_err ;  int bias = ( best_err >> ( 15 - ( filt_mid / 8 ) ) ) * filter_step ;  if ( cpi -> twopass . section_intra_rating < 20 )   bias = bias * cpi -> twopass . section_intra_rating / 20 ;  if ( cm -> tx_mode != ONLY_4X4 ) bias >>= 1 ; if ( filt_direction <= 0 && filt_low != filt_mid ) { if ( ss_err [ filt_low ] < 0 ) {  filt_err = try_filter_frame ( sd , cpi , filt_low , partial_frame ) ;   ss_err [ filt_low ] = filt_err ;  } else { filt_err = ss_err [ filt_low ] ; } if ( ( filt_err - bias ) < best_err ) {  if ( filt_err < best_err )  best_err = filt_err ; filt_best = filt_low ; } } if ( filt_direction >= 0 && filt_high != filt_mid ) { if ( ss_err [ filt_high ] < 0 ) {  filt_err = try_filter_frame ( sd , cpi , filt_high , partial_frame ) ;   ss_err [ filt_high ] = filt_err ;  } else { filt_err = ss_err [ filt_high ] ; } if ( filt_err < ( best_err - bias ) ) {  best_err = filt_err ;  filt_best = filt_high ; } } if ( filt_best == filt_mid ) { filter_step /= 2 ; filt_direction = 0 ; } else { filt_direction = ( filt_best < filt_mid ) ? - 1 : 1 ; filt_mid = filt_best ; } }  lf -> filter_level = filt_best ;  }",lf -> filter_level = filt_best ;},20
32,"buggy line: lua_pushinteger ( L , c . left == 0 ? - 1 : offset ) ;lua_insert ( L , 2 ) ;cwe id:CWE-787context: int mp_unpack_full ( lua_State * L , int limit , int offset ) { size_t len ; const char * s ; mp_cur c ; int cnt ; int decode_all = ( ! limit && ! offset ) ; s = luaL_checklstring ( L , 1 , & len ) ; if ( offset < 0 || limit < 0 ) return luaL_error ( L , ""Invalid<S2SV_blank>request<S2SV_blank>to<S2SV_blank>unpack<S2SV_blank>with<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>and<S2SV_blank>limit<S2SV_blank>of<S2SV_blank>%d."" , offset , len ) ; else if ( offset > len ) return luaL_error ( L , ""Start<S2SV_blank>offset<S2SV_blank>%d<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>input<S2SV_blank>length<S2SV_blank>%d."" , offset , len ) ; if ( decode_all ) limit = INT_MAX ; mp_cur_init ( & c , ( const unsigned char * ) s + offset , len - offset ) ; for ( cnt = 0 ; c . left > 0 && cnt < limit ; cnt ++ ) { mp_decode_to_lua_type ( L , & c ) ; if ( c . err == MP_CUR_ERROR_EOF ) { return luaL_error ( L , ""Missing<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>input."" ) ; } else if ( c . err == MP_CUR_ERROR_BADFMT ) { return luaL_error ( L , ""Bad<S2SV_blank>data<S2SV_blank>format<S2SV_blank>in<S2SV_blank>input."" ) ; } } if ( ! decode_all ) { int offset = len - c . left ;  lua_pushinteger ( L , c . left == 0 ? - 1 : offset ) ;  lua_insert ( L , 2 ) ; cnt += 1 ; } return cnt ; }","luaL_checkstack ( L , 1 , ""in<S2SV_blank>function<S2SV_blank>mp_unpack_full"" ) ;lua_pushinteger ( L , c . left == 0 ? - 1 : offset ) ;lua_insert ( L , 2 ) ;",21
33,"buggy line: static void encode_mv_component ( vp9_writer * w , int comp ,  const nmv_component * mvcomp , int usehp ) {cwe id:CWE-119context:  static void encode_mv_component ( vp9_writer * w , int comp ,  const nmv_component * mvcomp , int usehp ) { int offset ; const int sign = comp < 0 ; const int mag = sign ? - comp : comp ; const int mv_class = vp9_get_mv_class ( mag - 1 , & offset ) ; const int d = offset >> 3 ; const int fr = ( offset >> 1 ) & 3 ; const int hp = offset & 1 ; assert ( comp != 0 ) ;  vp9_write ( w , sign , mvcomp -> sign ) ;  vp9_write_token ( w , vp9_mv_class_tree , mvcomp -> classes , & mv_class_encodings [ mv_class ] ) ; if ( mv_class == MV_CLASS_0 ) { vp9_write_token ( w , vp9_mv_class0_tree , mvcomp -> class0 , & mv_class0_encodings [ d ] ) ; } else { int i ; const int n = mv_class + CLASS0_BITS - 1 ; for ( i = 0 ; i < n ; ++ i )  vp9_write ( w , ( d >> i ) & 1 , mvcomp -> bits [ i ] ) ;  } vp9_write_token ( w , vp9_mv_fp_tree , mv_class == MV_CLASS_0 ? mvcomp -> class0_fp [ d ] : mvcomp -> fp , & mv_fp_encodings [ fr ] ) ; if ( usehp )  vp9_write ( w , hp ,  mv_class == MV_CLASS_0 ? mvcomp -> class0_hp : mvcomp -> hp ) ; }","static void encode_mv_component ( vpx_writer * w , int comp , const nmv_component * mvcomp , int usehp ) {",22
34,"buggy line: vp9_write ( w , sign , mvcomp -> sign ) ;vp9_write_token ( w , vp9_mv_class_tree , mvcomp -> classes , & mv_class_encodings [ mv_class ] ) ;cwe id:CWE-119context:  static void encode_mv_component ( vp9_writer * w , int comp ,  const nmv_component * mvcomp , int usehp ) { int offset ; const int sign = comp < 0 ; const int mag = sign ? - comp : comp ; const int mv_class = vp9_get_mv_class ( mag - 1 , & offset ) ; const int d = offset >> 3 ; const int fr = ( offset >> 1 ) & 3 ; const int hp = offset & 1 ; assert ( comp != 0 ) ;  vp9_write ( w , sign , mvcomp -> sign ) ;  vp9_write_token ( w , vp9_mv_class_tree , mvcomp -> classes , & mv_class_encodings [ mv_class ] ) ; if ( mv_class == MV_CLASS_0 ) { vp9_write_token ( w , vp9_mv_class0_tree , mvcomp -> class0 , & mv_class0_encodings [ d ] ) ; } else { int i ; const int n = mv_class + CLASS0_BITS - 1 ; for ( i = 0 ; i < n ; ++ i )  vp9_write ( w , ( d >> i ) & 1 , mvcomp -> bits [ i ] ) ;  } vp9_write_token ( w , vp9_mv_fp_tree , mv_class == MV_CLASS_0 ? mvcomp -> class0_fp [ d ] : mvcomp -> fp , & mv_fp_encodings [ fr ] ) ; if ( usehp )  vp9_write ( w , hp ,  mv_class == MV_CLASS_0 ? mvcomp -> class0_hp : mvcomp -> hp ) ; }","vpx_write ( w , sign , mvcomp -> sign ) ;vp9_write_token ( w , vp9_mv_class_tree , mvcomp -> classes , & mv_class_encodings [ mv_class ] ) ;",22
35,"buggy line: ++ i )  vp9_write ( w , ( d >> i ) & 1 , mvcomp -> bits [ i ] ) ;}if ( usehp )  vp9_write ( w , hp ,  mv_class == MV_CLASS_0 ? mvcomp -> class0_hp : mvcomp -> hp ) ;cwe id:CWE-119context:  static void encode_mv_component ( vp9_writer * w , int comp ,  const nmv_component * mvcomp , int usehp ) { int offset ; const int sign = comp < 0 ; const int mag = sign ? - comp : comp ; const int mv_class = vp9_get_mv_class ( mag - 1 , & offset ) ; const int d = offset >> 3 ; const int fr = ( offset >> 1 ) & 3 ; const int hp = offset & 1 ; assert ( comp != 0 ) ;  vp9_write ( w , sign , mvcomp -> sign ) ;  vp9_write_token ( w , vp9_mv_class_tree , mvcomp -> classes , & mv_class_encodings [ mv_class ] ) ; if ( mv_class == MV_CLASS_0 ) { vp9_write_token ( w , vp9_mv_class0_tree , mvcomp -> class0 , & mv_class0_encodings [ d ] ) ; } else { int i ; const int n = mv_class + CLASS0_BITS - 1 ; for ( i = 0 ; i < n ; ++ i )  vp9_write ( w , ( d >> i ) & 1 , mvcomp -> bits [ i ] ) ;  } vp9_write_token ( w , vp9_mv_fp_tree , mv_class == MV_CLASS_0 ? mvcomp -> class0_fp [ d ] : mvcomp -> fp , & mv_fp_encodings [ fr ] ) ; if ( usehp )  vp9_write ( w , hp ,  mv_class == MV_CLASS_0 ? mvcomp -> class0_hp : mvcomp -> hp ) ; }","+ i )  vp9_write ( w , ( d >> i ) & 1 , mvcomp -> bits [ i ] ) ;++ i ) vpx_write ( w , ( d >> i ) & 1 , mvcomp -> bits [ i ] ) ;}if ( usehp ) vpx_write ( w , hp , mv_class == MV_CLASS_0 ? mvcomp -> class0_hp : mvcomp -> hp ) ;",22
36,"buggy line: return alg -> cra_rng . rng_make_random ?  alg -> cra_rng . seedsize : ralg -> seedsize ;cwe id:CWE-476context: static unsigned int seedsize ( struct crypto_alg * alg ) { struct rng_alg * ralg = container_of ( alg , struct rng_alg , base ) ;  return alg -> cra_rng . rng_make_random ?  alg -> cra_rng . seedsize : ralg -> seedsize ; }",return ralg -> seedsize ;,23
37,"buggy line: if ( sp -> sa_protocol != PX_PROTO_PPTP )  return - EINVAL ;cwe id:CWE-200context: static int pptp_connect ( struct socket * sock , struct sockaddr * uservaddr , int sockaddr_len , int flags ) { struct sock * sk = sock -> sk ; struct sockaddr_pppox * sp = ( struct sockaddr_pppox * ) uservaddr ; struct pppox_sock * po = pppox_sk ( sk ) ; struct pptp_opt * opt = & po -> proto . pptp ; struct rtable * rt ; struct flowi4 fl4 ; int error = 0 ;  if ( sp -> sa_protocol != PX_PROTO_PPTP )  return - EINVAL ; if ( lookup_chan_dst ( sp -> sa_addr . pptp . call_id , sp -> sa_addr . pptp . sin_addr . s_addr ) ) return - EALREADY ; lock_sock ( sk ) ; if ( sk -> sk_state & PPPOX_CONNECTED ) { error = - EBUSY ; goto end ; } if ( sk -> sk_state & PPPOX_DEAD ) { error = - EALREADY ; goto end ; } if ( ! opt -> src_addr . sin_addr . s_addr || ! sp -> sa_addr . pptp . sin_addr . s_addr ) { error = - EINVAL ; goto end ; } po -> chan . private = sk ; po -> chan . ops = & pptp_chan_ops ; rt = ip_route_output_ports ( sock_net ( sk ) , & fl4 , sk , opt -> dst_addr . sin_addr . s_addr , opt -> src_addr . sin_addr . s_addr , 0 , 0 , IPPROTO_GRE , RT_CONN_FLAGS ( sk ) , 0 ) ; if ( IS_ERR ( rt ) ) { error = - EHOSTUNREACH ; goto end ; } sk_setup_caps ( sk , & rt -> dst ) ; po -> chan . mtu = dst_mtu ( & rt -> dst ) ; if ( ! po -> chan . mtu ) po -> chan . mtu = PPP_MRU ; ip_rt_put ( rt ) ; po -> chan . mtu -= PPTP_HEADER_OVERHEAD ; po -> chan . hdrlen = 2 + sizeof ( struct pptp_gre_header ) ; error = ppp_register_channel ( & po -> chan ) ; if ( error ) { pr_err ( ""PPTP:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>register<S2SV_blank>PPP<S2SV_blank>channel<S2SV_blank>(%d)\\n"" , error ) ; goto end ; } opt -> dst_addr = sp -> sa_addr . pptp ; sk -> sk_state = PPPOX_CONNECTED ; end : release_sock ( sk ) ; return error ; }",if ( sockaddr_len < sizeof ( struct sockaddr_pppox ) ) return - EINVAL ;if ( sp -> sa_protocol != PX_PROTO_PPTP ) return - EINVAL ;,24
38,"buggy line: if ( blockSize == 16 )  request -> rxBlockSzx = COAP_BLOCK_SIZE_16 ;else if ( blockSize == 32 )   request -> rxBlockSzx = COAP_BLOCK_SIZE_32 ;else if ( blockSize == 64 )   request -> rxBlockSzx = COAP_BLOCK_SIZE_64 ;else if ( blockSize == 128 )   request -> rxBlockSzx = COAP_BLOCK_SIZE_128 ;else if ( blockSize == 256 )   request -> rxBlockSzx = COAP_BLOCK_SIZE_256 ;else if ( blockSize == 512 )   request -> rxBlockSzx = COAP_BLOCK_SIZE_512 ;else   request -> rxBlockSzx = COAP_BLOCK_SIZE_1024 ;if ( request -> rxBlockSzx > coapClientGetMaxBlockSize ( ) )  request -> rxBlockSzx = coapClientGetMaxBlockSize ( ) ;osReleaseMutex ( & request -> context -> mutex ) ;cwe id:CWE-20context: error_t coapClientSetRxBlockSize ( CoapClientRequest * request , uint_t blockSize ) { if ( request == NULL ) return ERROR_INVALID_PARAMETER ; osAcquireMutex ( & request -> context -> mutex ) ; if ( blockSize == 16 )  request -> rxBlockSzx = COAP_BLOCK_SIZE_16 ;   else if ( blockSize == 32 )   request -> rxBlockSzx = COAP_BLOCK_SIZE_32 ;   else if ( blockSize == 64 )   request -> rxBlockSzx = COAP_BLOCK_SIZE_64 ;   else if ( blockSize == 128 )   request -> rxBlockSzx = COAP_BLOCK_SIZE_128 ;   else if ( blockSize == 256 )   request -> rxBlockSzx = COAP_BLOCK_SIZE_256 ;   else if ( blockSize == 512 )   request -> rxBlockSzx = COAP_BLOCK_SIZE_512 ;   else   request -> rxBlockSzx = COAP_BLOCK_SIZE_1024 ;  if ( request -> rxBlockSzx > coapClientGetMaxBlockSize ( ) )  request -> rxBlockSzx = coapClientGetMaxBlockSize ( ) ;  osReleaseMutex ( & request -> context -> mutex ) ; return NO_ERROR ; }",if ( blockSize == 16 ) {request -> rxBlockSzx = COAP_BLOCK_SIZE_16 ;}else if ( blockSize == 32 ) {request -> rxBlockSzx = COAP_BLOCK_SIZE_32 ;}else if ( blockSize == 64 ) {request -> rxBlockSzx = COAP_BLOCK_SIZE_64 ;}else if ( blockSize == 128 ) {request -> rxBlockSzx = COAP_BLOCK_SIZE_128 ;}else if ( blockSize == 256 ) {request -> rxBlockSzx = COAP_BLOCK_SIZE_256 ;}else if ( blockSize == 512 ) {request -> rxBlockSzx = COAP_BLOCK_SIZE_512 ;}else {request -> rxBlockSzx = COAP_BLOCK_SIZE_1024 ;}if ( request -> rxBlockSzx > coapClientGetMaxBlockSize ( ) ) {request -> rxBlockSzx = coapClientGetMaxBlockSize ( ) ;}osReleaseMutex ( & request -> context -> mutex ) ;,25
39,"buggy line: char * fmtname ;if ( jas_init ( ) ) {while ( ( id = jas_getopt ( argc , argv , opts ) ) >= 0 ) {switch ( id ) {case OPT_INFILE :  infile = jas_optarg ;if ( infile ) {if ( ! ( instream = jas_stream_fopen ( infile , ""rb"" ) ) ) {cwe id:CWE-476context: int main ( int argc , char * * argv ) { int fmtid ; int id ; char * infile ; jas_stream_t * instream ; jas_image_t * image ; int width ; int height ; int depth ; int numcmpts ; int verbose ;  char * fmtname ;  if ( jas_init ( ) ) { abort ( ) ; } cmdname = argv [ 0 ] ; infile = 0 ; verbose = 0 ;  while ( ( id = jas_getopt ( argc , argv , opts ) ) >= 0 ) {  switch ( id ) { case OPT_VERBOSE : verbose = 1 ; break ; case OPT_VERSION : printf ( ""%s\\n"" , JAS_VERSION ) ; exit ( EXIT_SUCCESS ) ; break ;  case OPT_INFILE :  infile = jas_optarg ; break ; case OPT_HELP : default : usage ( ) ; break ; } }  if ( infile ) {  if ( ! ( instream = jas_stream_fopen ( infile , ""rb"" ) ) ) { fprintf ( stderr , ""cannot<S2SV_blank>open<S2SV_blank>input<S2SV_blank>image<S2SV_blank>file<S2SV_blank>%s\\n"" , infile ) ; exit ( EXIT_FAILURE ) ; } } else { if ( ! ( instream = jas_stream_fdopen ( 0 , ""rb"" ) ) ) { fprintf ( stderr , ""cannot<S2SV_blank>open<S2SV_blank>standard<S2SV_blank>input\\n"" ) ; exit ( EXIT_FAILURE ) ; } } if ( ( fmtid = jas_image_getfmt ( instream ) ) < 0 ) { fprintf ( stderr , ""unknown<S2SV_blank>image<S2SV_blank>format\\n"" ) ; }  if ( ! ( image = jas_image_decode ( instream , fmtid , 0 ) ) ) {  fprintf ( stderr , ""cannot<S2SV_blank>load<S2SV_blank>image\\n"" ) ; return EXIT_FAILURE ; } jas_stream_close ( instream ) ; numcmpts = jas_image_numcmpts ( image ) ; width = jas_image_cmptwidth ( image , 0 ) ; height = jas_image_cmptheight ( image , 0 ) ; depth = jas_image_cmptprec ( image , 0 ) ; if ( ! ( fmtname = jas_image_fmttostr ( fmtid ) ) ) { abort ( ) ; } printf ( ""%s<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%ld\\n"" , fmtname , numcmpts , width , height , depth , ( long ) jas_image_rawsize ( image ) ) ; jas_image_destroy ( image ) ; jas_image_clearfmts ( ) ; return EXIT_SUCCESS ; }","char * fmtname ;int debug ;if ( jas_init ( ) ) {debug = 0 ;while ( ( id = jas_getopt ( argc , argv , opts ) ) >= 0 ) {switch ( id ) {case OPT_DEBUG : debug = atoi ( jas_optarg ) ;break ;case OPT_INFILE : infile = jas_optarg ;jas_setdbglevel ( debug ) ;if ( infile ) {if ( ! ( instream = jas_stream_fopen ( infile , ""rb"" ) ) ) {jas_stream_close ( instream ) ;",26
40,"buggy line: if ( ! ( image = jas_image_decode ( instream , fmtid , 0 ) ) ) {fprintf ( stderr , ""cannot<S2SV_blank>load<S2SV_blank>image\\\cwe id:CWE-476context: int main ( int argc , char * * argv ) { int fmtid ; int id ; char * infile ; jas_stream_t * instream ; jas_image_t * image ; int width ; int height ; int depth ; int numcmpts ; int verbose ;  char * fmtname ;  if ( jas_init ( ) ) { abort ( ) ; } cmdname = argv [ 0 ] ; infile = 0 ; verbose = 0 ;  while ( ( id = jas_getopt ( argc , argv , opts ) ) >= 0 ) {  switch ( id ) { case OPT_VERBOSE : verbose = 1 ; break ; case OPT_VERSION : printf ( ""%s\\n"" , JAS_VERSION ) ; exit ( EXIT_SUCCESS ) ; break ;  case OPT_INFILE :  infile = jas_optarg ; break ; case OPT_HELP : default : usage ( ) ; break ; } }  if ( infile ) {  if ( ! ( instream = jas_stream_fopen ( infile , ""rb"" ) ) ) { fprintf ( stderr , ""cannot<S2SV_blank>open<S2SV_blank>input<S2SV_blank>image<S2SV_blank>file<S2SV_blank>%s\\n"" , infile ) ; exit ( EXIT_FAILURE ) ; } } else { if ( ! ( instream = jas_stream_fdopen ( 0 , ""rb"" ) ) ) { fprintf ( stderr , ""cannot<S2SV_blank>open<S2SV_blank>standard<S2SV_blank>input\\n"" ) ; exit ( EXIT_FAILURE ) ; } } if ( ( fmtid = jas_image_getfmt ( instream ) ) < 0 ) { fprintf ( stderr , ""unknown<S2SV_blank>image<S2SV_blank>format\\n"" ) ; }  if ( ! ( image = jas_image_decode ( instream , fmtid , 0 ) ) ) {  fprintf ( stderr , ""cannot<S2SV_blank>load<S2SV_blank>image\\n"" ) ; return EXIT_FAILURE ; } jas_stream_close ( instream ) ; numcmpts = jas_image_numcmpts ( image ) ; width = jas_image_cmptwidth ( image , 0 ) ; height = jas_image_cmptheight ( image , 0 ) ; depth = jas_image_cmptprec ( image , 0 ) ; if ( ! ( fmtname = jas_image_fmttostr ( fmtid ) ) ) { abort ( ) ; } printf ( ""%s<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%ld\\n"" , fmtname , numcmpts , width , height , depth , ( long ) jas_image_rawsize ( image ) ) ; jas_image_destroy ( image ) ; jas_image_clearfmts ( ) ; return EXIT_SUCCESS ; }","if ( ! ( image = jas_image_decode ( instream , fmtid , 0 ) ) ) {fprintf ( stderr , ""cannot<S2SV_blank>load<S2SV_blank>image\\\",26
41,"buggy line: asmlinkage void bad_mode ( struct pt_regs * regs , int reason , unsigned int esr )  {console_verbose ( ) ;die ( ""Oops<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>mode"" , regs , 0 ) ;local_irq_disable ( ) ;panic ( ""bad<S2SV_blank>mode"" ) ;cwe id:CWE-000context: asmlinkage void bad_mode ( struct pt_regs * regs , int reason , unsigned int esr )  {  console_verbose ( ) ; pr_crit ( ""Bad<S2SV_blank>mode<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>handler<S2SV_blank>detected,<S2SV_blank>code<S2SV_blank>0x%08x\\n"" , handler [ reason ] , esr ) ;  die ( ""Oops<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>mode"" , regs , 0 ) ;  local_irq_disable ( ) ; panic ( ""bad<S2SV_blank>mode"" ) ; }","asmlinkage void bad_mode ( struct pt_regs * regs , int reason , unsigned int esr ) {siginfo_t info ;void __user * pc = ( void __user * ) instruction_pointer ( regs ) ;console_verbose ( ) ;__show_regs ( regs ) ;info . si_signo = SIGILL ;info . si_errno = 0 ;info . si_code = ILL_ILLOPC ;info . si_addr = pc ;arm64_notify_die ( ""Oops<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>mode"" , regs , & info , 0 ) ;",27
42,"buggy line: ND_PRINT ( ( ndo , ""%04x,<S2SV_blank>"" , EXTRACT_16BITS ( ptr ) ) ) ;ND_PRINT ( ( ndo , ""%04x<S2SV_blank>"" , EXTRACT_16BITS ( ptr ) ) ) ;ND_PRINT ( ( ndo , ""%s"" , tok2str ( l2tp_cc_direction2str ,  ""Direction-#%u"" , * ( ( const u_char * ) ptr ++ ) ) ) ) ;if ( length > 5 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ;print_string ( ndo , ( const u_char * ) ptr , length - 5 ) ;}cwe id:CWE-125context: static void l2tp_ppp_discon_cc_print ( netdissect_options * ndo , const u_char * dat , u_int length ) { const uint16_t * ptr = ( const uint16_t * ) dat ;  ND_PRINT ( ( ndo , ""%04x,<S2SV_blank>"" , EXTRACT_16BITS ( ptr ) ) ) ; ptr ++ ;   ND_PRINT ( ( ndo , ""%04x<S2SV_blank>"" , EXTRACT_16BITS ( ptr ) ) ) ; ptr ++ ;  ND_PRINT ( ( ndo , ""%s"" , tok2str ( l2tp_cc_direction2str ,  ""Direction-#%u"" , * ( ( const u_char * ) ptr ++ ) ) ) ) ;   if ( length > 5 ) {  ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ;  print_string ( ndo , ( const u_char * ) ptr , length - 5 ) ;  } }","if ( length < 5 ) {ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;return ;}ND_PRINT ( ( ndo , ""%04x,<S2SV_blank>"" , EXTRACT_16BITS ( dat ) ) ) ;ND_PRINT ( ( ndo , ""%04x<S2SV_blank>"" , EXTRACT_16BITS ( ptr ) ) ) ;dat += 2 ;length -= 2 ;ND_PRINT ( ( ndo , ""%s"" , tok2str ( l2tp_cc_direction2str , ""Direction-#%u"" , EXTRACT_8BITS ( ptr ) ) ) ) ;length -- ;if ( length != 0 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ;print_string ( ndo , ( const u_char * ) ptr , length ) ;}",28
43,"buggy line: int alt ;alt = uas_find_uas_alt_setting ( intf ) ;if ( alt < 0 )  return alt ;return usb_set_interface ( udev ,  intf -> altsetting [ 0 ] . desc . bInterfaceNumber , alt ) ;}cwe id:CWE-125context: static int uas_switch_interface ( struct usb_device * udev , struct usb_interface * intf ) {  int alt ;  alt = uas_find_uas_alt_setting ( intf ) ;  if ( alt < 0 )  return alt ; return usb_set_interface ( udev ,  intf -> altsetting [ 0 ] . desc . bInterfaceNumber , alt ) ;  }","struct usb_host_interface * alt ;alt = uas_find_uas_alt_setting ( intf ) ;if ( ! alt ) return - ENODEV ;return usb_set_interface ( udev , alt -> desc . bInterfaceNumber , alt -> desc . bAlternateSetting ) ;}",29
44,"buggy line: static void udf_pc_to_char ( struct super_block * sb , unsigned char * from ,   int fromlen , unsigned char * to )  {unsigned char * p = to ;while ( elen < fromlen ) {case 2 :  p = to ;* p ++ = \'/\' ;break ;case 3 : memcpy ( p , ""../"" , 3 ) ;break ;case 4 :  memcpy ( p , ""./"" , 2 ) ;p += 2 ;break ;case 5 :  p += udf_get_filename ( sb , pc -> componentIdent , p ,  pc -> lengthComponentIdent ) ;* p ++ = \'/\' ;break ;}cwe id:CWE-17context:  static void udf_pc_to_char ( struct super_block * sb , unsigned char * from ,   int fromlen , unsigned char * to )  { struct pathComponent * pc ; int elen = 0 ;  unsigned char * p = to ;  while ( elen < fromlen ) { pc = ( struct pathComponent * ) ( from + elen ) ; switch ( pc -> componentType ) { case 1 : if ( pc -> lengthComponentIdent > 0 ) break ; case 2 :  p = to ;  * p ++ = '/' ;  break ;  case 3 : memcpy ( p , ""../"" , 3 ) ; p += 3 ;  break ;  case 4 :  memcpy ( p , ""./"" , 2 ) ;  p += 2 ;  break ;  case 5 :  p += udf_get_filename ( sb , pc -> componentIdent , p ,  pc -> lengthComponentIdent ) ;  * p ++ = '/' ;  break ; } elen += sizeof ( struct pathComponent ) + pc -> lengthComponentIdent ; } if ( p > to + 1 ) p [ - 1 ] = '\\0' ; else p [ 0 ] = '\\0' ;  } ","static int udf_pc_to_char ( struct super_block * sb , unsigned char * from , int fromlen , unsigned char * to , int tolen ) {int comp_len ;unsigned char * p = to ;tolen -- ;while ( elen < fromlen ) {case 2 : if ( tolen == 0 ) return - ENAMETOOLONG ;p = to ;* p ++ = \'/\' ;tolen -- ;break ;case 3 : if ( tolen < 3 ) return - ENAMETOOLONG ;memcpy ( p , ""../"" , 3 ) ;tolen -= 3 ;break ;case 4 : if ( tolen < 2 ) return - ENAMETOOLONG ;memcpy ( p , ""./"" , 2 ) ;p += 2 ;tolen -= 2 ;break ;case 5 : comp_len = udf_get_filename ( sb , pc -> componentIdent , pc -> lengthComponentIdent , p , tolen ) ;p += comp_len ;tolen -= comp_len ;if ( tolen == 0 ) return - ENAMETOOLONG ;* p ++ = \'/\' ;tolen -- ;break ;return 0 ;}",30
45,"buggy line: if ( ( server . protected_mode = yesnotoi ( argv [ 1 ] ) ) == - 1 ) {err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\\\'yes\\\'<S2SV_blank>or<S2SV_blank>\\\'no\\\'"" ;cwe id:CWE-119context: void loadServerConfigFromString ( char * config ) { char * err = NULL ; int linenum = 0 , totlines , i ; int slaveof_linenum = 0 ; sds * lines ; lines = sdssplitlen ( config , strlen ( config ) , ""\\n"" , 1 , & totlines ) ; for ( i = 0 ; i < totlines ; i ++ ) { sds * argv ; int argc ; linenum = i + 1 ; lines [ i ] = sdstrim ( lines [ i ] , ""<S2SV_blank>\\t\\r\\n"" ) ; if ( lines [ i ] [ 0 ] == '#' || lines [ i ] [ 0 ] == '\\0' ) continue ; argv = sdssplitargs ( lines [ i ] , & argc ) ; if ( argv == NULL ) { err = ""Unbalanced<S2SV_blank>quotes<S2SV_blank>in<S2SV_blank>configuration<S2SV_blank>line"" ; goto loaderr ; } if ( argc == 0 ) { sdsfreesplitres ( argv , argc ) ; continue ; } sdstolower ( argv [ 0 ] ) ; if ( ! strcasecmp ( argv [ 0 ] , ""timeout"" ) && argc == 2 ) { server . maxidletime = atoi ( argv [ 1 ] ) ; if ( server . maxidletime < 0 ) { err = ""Invalid<S2SV_blank>timeout<S2SV_blank>value"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""tcp-keepalive"" ) && argc == 2 ) { server . tcpkeepalive = atoi ( argv [ 1 ] ) ; if ( server . tcpkeepalive < 0 ) { err = ""Invalid<S2SV_blank>tcp-keepalive<S2SV_blank>value"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""protected-mode"" ) && argc == 2 ) { if ( ( server . protected_mode = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""port"" ) && argc == 2 ) { server . port = atoi ( argv [ 1 ] ) ; if ( server . port < 0 || server . port > 65535 ) { err = ""Invalid<S2SV_blank>port"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""tcp-backlog"" ) && argc == 2 ) { server . tcp_backlog = atoi ( argv [ 1 ] ) ; if ( server . tcp_backlog < 0 ) { err = ""Invalid<S2SV_blank>backlog<S2SV_blank>value"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""bind"" ) && argc >= 2 ) { int j , addresses = argc - 1 ; if ( addresses > CONFIG_BINDADDR_MAX ) { err = ""Too<S2SV_blank>many<S2SV_blank>bind<S2SV_blank>addresses<S2SV_blank>specified"" ; goto loaderr ; } for ( j = 0 ; j < addresses ; j ++ ) server . bindaddr [ j ] = zstrdup ( argv [ j + 1 ] ) ; server . bindaddr_count = addresses ; } else if ( ! strcasecmp ( argv [ 0 ] , ""unixsocket"" ) && argc == 2 ) { server . unixsocket = zstrdup ( argv [ 1 ] ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""unixsocketperm"" ) && argc == 2 ) { errno = 0 ; server . unixsocketperm = ( mode_t ) strtol ( argv [ 1 ] , NULL , 8 ) ; if ( errno || server . unixsocketperm > 0777 ) { err = ""Invalid<S2SV_blank>socket<S2SV_blank>file<S2SV_blank>permissions"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""save"" ) ) { if ( argc == 3 ) { int seconds = atoi ( argv [ 1 ] ) ; int changes = atoi ( argv [ 2 ] ) ; if ( seconds < 1 || changes < 0 ) { err = ""Invalid<S2SV_blank>save<S2SV_blank>parameters"" ; goto loaderr ; } appendServerSaveParams ( seconds , changes ) ; } else if ( argc == 2 && ! strcasecmp ( argv [ 1 ] , """" ) ) { resetServerSaveParams ( ) ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""dir"" ) && argc == 2 ) { if ( chdir ( argv [ 1 ] ) == - 1 ) { serverLog ( LL_WARNING , ""Can\'t<S2SV_blank>chdir<S2SV_blank>to<S2SV_blank>\'%s\':<S2SV_blank>%s"" , argv [ 1 ] , strerror ( errno ) ) ; exit ( 1 ) ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""loglevel"" ) && argc == 2 ) { server . verbosity = configEnumGetValue ( loglevel_enum , argv [ 1 ] ) ; if ( server . verbosity == INT_MIN ) { err = ""Invalid<S2SV_blank>log<S2SV_blank>level.<S2SV_blank>"" ""Must<S2SV_blank>be<S2SV_blank>one<S2SV_blank>of<S2SV_blank>debug,<S2SV_blank>verbose,<S2SV_blank>notice,<S2SV_blank>warning"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""logfile"" ) && argc == 2 ) { FILE * logfp ; zfree ( server . logfile ) ; server . logfile = zstrdup ( argv [ 1 ] ) ; if ( server . logfile [ 0 ] != '\\0' ) { logfp = fopen ( server . logfile , ""a"" ) ; if ( logfp == NULL ) { err = sdscatprintf ( sdsempty ( ) , ""Can\'t<S2SV_blank>open<S2SV_blank>the<S2SV_blank>log<S2SV_blank>file:<S2SV_blank>%s"" , strerror ( errno ) ) ; goto loaderr ; } fclose ( logfp ) ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""syslog-enabled"" ) && argc == 2 ) { if ( ( server . syslog_enabled = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""syslog-ident"" ) && argc == 2 ) { if ( server . syslog_ident ) zfree ( server . syslog_ident ) ; server . syslog_ident = zstrdup ( argv [ 1 ] ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""syslog-facility"" ) && argc == 2 ) { server . syslog_facility = configEnumGetValue ( syslog_facility_enum , argv [ 1 ] ) ; if ( server . syslog_facility == INT_MIN ) { err = ""Invalid<S2SV_blank>log<S2SV_blank>facility.<S2SV_blank>Must<S2SV_blank>be<S2SV_blank>one<S2SV_blank>of<S2SV_blank>USER<S2SV_blank>or<S2SV_blank>between<S2SV_blank>LOCAL0-LOCAL7"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""databases"" ) && argc == 2 ) { server . dbnum = atoi ( argv [ 1 ] ) ; if ( server . dbnum < 1 ) { err = ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>databases"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""include"" ) && argc == 2 ) { loadServerConfig ( argv [ 1 ] , NULL ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""maxclients"" ) && argc == 2 ) { server . maxclients = atoi ( argv [ 1 ] ) ; if ( server . maxclients < 1 ) { err = ""Invalid<S2SV_blank>max<S2SV_blank>clients<S2SV_blank>limit"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""maxmemory"" ) && argc == 2 ) { server . maxmemory = memtoll ( argv [ 1 ] , NULL ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""maxmemory-policy"" ) && argc == 2 ) { server . maxmemory_policy = configEnumGetValue ( maxmemory_policy_enum , argv [ 1 ] ) ; if ( server . maxmemory_policy == INT_MIN ) { err = ""Invalid<S2SV_blank>maxmemory<S2SV_blank>policy"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""maxmemory-samples"" ) && argc == 2 ) { server . maxmemory_samples = atoi ( argv [ 1 ] ) ; if ( server . maxmemory_samples <= 0 ) { err = ""maxmemory-samples<S2SV_blank>must<S2SV_blank>be<S2SV_blank>1<S2SV_blank>or<S2SV_blank>greater"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""lfu-log-factor"" ) && argc == 2 ) { server . lfu_log_factor = atoi ( argv [ 1 ] ) ; if ( server . maxmemory_samples < 0 ) { err = ""lfu-log-factor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>0<S2SV_blank>or<S2SV_blank>greater"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""lfu-decay-time"" ) && argc == 2 ) { server . lfu_decay_time = atoi ( argv [ 1 ] ) ; if ( server . maxmemory_samples < 1 ) { err = ""lfu-decay-time<S2SV_blank>must<S2SV_blank>be<S2SV_blank>0<S2SV_blank>or<S2SV_blank>greater"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""slaveof"" ) && argc == 3 ) { slaveof_linenum = linenum ; server . masterhost = sdsnew ( argv [ 1 ] ) ; server . masterport = atoi ( argv [ 2 ] ) ; server . repl_state = REPL_STATE_CONNECT ; } else if ( ! strcasecmp ( argv [ 0 ] , ""repl-ping-slave-period"" ) && argc == 2 ) { server . repl_ping_slave_period = atoi ( argv [ 1 ] ) ; if ( server . repl_ping_slave_period <= 0 ) { err = ""repl-ping-slave-period<S2SV_blank>must<S2SV_blank>be<S2SV_blank>1<S2SV_blank>or<S2SV_blank>greater"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""repl-timeout"" ) && argc == 2 ) { server . repl_timeout = atoi ( argv [ 1 ] ) ; if ( server . repl_timeout <= 0 ) { err = ""repl-timeout<S2SV_blank>must<S2SV_blank>be<S2SV_blank>1<S2SV_blank>or<S2SV_blank>greater"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""repl-disable-tcp-nodelay"" ) && argc == 2 ) { if ( ( server . repl_disable_tcp_nodelay = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""repl-diskless-sync"" ) && argc == 2 ) { if ( ( server . repl_diskless_sync = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""repl-diskless-sync-delay"" ) && argc == 2 ) { server . repl_diskless_sync_delay = atoi ( argv [ 1 ] ) ; if ( server . repl_diskless_sync_delay < 0 ) { err = ""repl-diskless-sync-delay<S2SV_blank>can\'t<S2SV_blank>be<S2SV_blank>negative"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""repl-backlog-size"" ) && argc == 2 ) { long long size = memtoll ( argv [ 1 ] , NULL ) ; if ( size <= 0 ) { err = ""repl-backlog-size<S2SV_blank>must<S2SV_blank>be<S2SV_blank>1<S2SV_blank>or<S2SV_blank>greater."" ; goto loaderr ; } resizeReplicationBacklog ( size ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""repl-backlog-ttl"" ) && argc == 2 ) { server . repl_backlog_time_limit = atoi ( argv [ 1 ] ) ; if ( server . repl_backlog_time_limit < 0 ) { err = ""repl-backlog-ttl<S2SV_blank>can\'t<S2SV_blank>be<S2SV_blank>negative<S2SV_blank>"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""masterauth"" ) && argc == 2 ) { zfree ( server . masterauth ) ; server . masterauth = zstrdup ( argv [ 1 ] ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""slave-serve-stale-data"" ) && argc == 2 ) { if ( ( server . repl_serve_stale_data = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""slave-read-only"" ) && argc == 2 ) { if ( ( server . repl_slave_ro = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""rdbcompression"" ) && argc == 2 ) { if ( ( server . rdb_compression = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""rdbchecksum"" ) && argc == 2 ) { if ( ( server . rdb_checksum = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""activerehashing"" ) && argc == 2 ) { if ( ( server . activerehashing = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""lazyfree-lazy-eviction"" ) && argc == 2 ) { if ( ( server . lazyfree_lazy_eviction = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""lazyfree-lazy-expire"" ) && argc == 2 ) { if ( ( server . lazyfree_lazy_expire = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""lazyfree-lazy-server-del"" ) && argc == 2 ) { if ( ( server . lazyfree_lazy_server_del = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""slave-lazy-flush"" ) && argc == 2 ) { if ( ( server . repl_slave_lazy_flush = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""daemonize"" ) && argc == 2 ) { if ( ( server . daemonize = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""hz"" ) && argc == 2 ) { server . hz = atoi ( argv [ 1 ] ) ; if ( server . hz < CONFIG_MIN_HZ ) server . hz = CONFIG_MIN_HZ ; if ( server . hz > CONFIG_MAX_HZ ) server . hz = CONFIG_MAX_HZ ; } else if ( ! strcasecmp ( argv [ 0 ] , ""appendonly"" ) && argc == 2 ) { int yes ; if ( ( yes = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } server . aof_state = yes ? AOF_ON : AOF_OFF ; } else if ( ! strcasecmp ( argv [ 0 ] , ""appendfilename"" ) && argc == 2 ) { if ( ! pathIsBaseName ( argv [ 1 ] ) ) { err = ""appendfilename<S2SV_blank>can\'t<S2SV_blank>be<S2SV_blank>a<S2SV_blank>path,<S2SV_blank>just<S2SV_blank>a<S2SV_blank>filename"" ; goto loaderr ; } zfree ( server . aof_filename ) ; server . aof_filename = zstrdup ( argv [ 1 ] ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""no-appendfsync-on-rewrite"" ) && argc == 2 ) { if ( ( server . aof_no_fsync_on_rewrite = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""appendfsync"" ) && argc == 2 ) { server . aof_fsync = configEnumGetValue ( aof_fsync_enum , argv [ 1 ] ) ; if ( server . aof_fsync == INT_MIN ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'no\',<S2SV_blank>\'always\'<S2SV_blank>or<S2SV_blank>\'everysec\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""auto-aof-rewrite-percentage"" ) && argc == 2 ) { server . aof_rewrite_perc = atoi ( argv [ 1 ] ) ; if ( server . aof_rewrite_perc < 0 ) { err = ""Invalid<S2SV_blank>negative<S2SV_blank>percentage<S2SV_blank>for<S2SV_blank>AOF<S2SV_blank>auto<S2SV_blank>rewrite"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""auto-aof-rewrite-min-size"" ) && argc == 2 ) { server . aof_rewrite_min_size = memtoll ( argv [ 1 ] , NULL ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""aof-rewrite-incremental-fsync"" ) && argc == 2 ) { if ( ( server . aof_rewrite_incremental_fsync = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""aof-load-truncated"" ) && argc == 2 ) { if ( ( server . aof_load_truncated = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""aof-use-rdb-preamble"" ) && argc == 2 ) { if ( ( server . aof_use_rdb_preamble = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""requirepass"" ) && argc == 2 ) { if ( strlen ( argv [ 1 ] ) > CONFIG_AUTHPASS_MAX_LEN ) { err = ""Password<S2SV_blank>is<S2SV_blank>longer<S2SV_blank>than<S2SV_blank>CONFIG_AUTHPASS_MAX_LEN"" ; goto loaderr ; } server . requirepass = zstrdup ( argv [ 1 ] ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""pidfile"" ) && argc == 2 ) { zfree ( server . pidfile ) ; server . pidfile = zstrdup ( argv [ 1 ] ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""dbfilename"" ) && argc == 2 ) { if ( ! pathIsBaseName ( argv [ 1 ] ) ) { err = ""dbfilename<S2SV_blank>can\'t<S2SV_blank>be<S2SV_blank>a<S2SV_blank>path,<S2SV_blank>just<S2SV_blank>a<S2SV_blank>filename"" ; goto loaderr ; } zfree ( server . rdb_filename ) ; server . rdb_filename = zstrdup ( argv [ 1 ] ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""hash-max-ziplist-entries"" ) && argc == 2 ) { server . hash_max_ziplist_entries = memtoll ( argv [ 1 ] , NULL ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""hash-max-ziplist-value"" ) && argc == 2 ) { server . hash_max_ziplist_value = memtoll ( argv [ 1 ] , NULL ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""list-max-ziplist-entries"" ) && argc == 2 ) { } else if ( ! strcasecmp ( argv [ 0 ] , ""list-max-ziplist-value"" ) && argc == 2 ) { } else if ( ! strcasecmp ( argv [ 0 ] , ""list-max-ziplist-size"" ) && argc == 2 ) { server . list_max_ziplist_size = atoi ( argv [ 1 ] ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""list-compress-depth"" ) && argc == 2 ) { server . list_compress_depth = atoi ( argv [ 1 ] ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""set-max-intset-entries"" ) && argc == 2 ) { server . set_max_intset_entries = memtoll ( argv [ 1 ] , NULL ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""zset-max-ziplist-entries"" ) && argc == 2 ) { server . zset_max_ziplist_entries = memtoll ( argv [ 1 ] , NULL ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""zset-max-ziplist-value"" ) && argc == 2 ) { server . zset_max_ziplist_value = memtoll ( argv [ 1 ] , NULL ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""hll-sparse-max-bytes"" ) && argc == 2 ) { server . hll_sparse_max_bytes = memtoll ( argv [ 1 ] , NULL ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""rename-command"" ) && argc == 3 ) { struct redisCommand * cmd = lookupCommand ( argv [ 1 ] ) ; int retval ; if ( ! cmd ) { err = ""No<S2SV_blank>such<S2SV_blank>command<S2SV_blank>in<S2SV_blank>rename-command"" ; goto loaderr ; } retval = dictDelete ( server . commands , argv [ 1 ] ) ; serverAssert ( retval == DICT_OK ) ; if ( sdslen ( argv [ 2 ] ) != 0 ) { sds copy = sdsdup ( argv [ 2 ] ) ; retval = dictAdd ( server . commands , copy , cmd ) ; if ( retval != DICT_OK ) { sdsfree ( copy ) ; err = ""Target<S2SV_blank>command<S2SV_blank>name<S2SV_blank>already<S2SV_blank>exists"" ; goto loaderr ; } } } else if ( ! strcasecmp ( argv [ 0 ] , ""cluster-enabled"" ) && argc == 2 ) { if ( ( server . cluster_enabled = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""cluster-config-file"" ) && argc == 2 ) { zfree ( server . cluster_configfile ) ; server . cluster_configfile = zstrdup ( argv [ 1 ] ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""cluster-announce-ip"" ) && argc == 2 ) { zfree ( server . cluster_announce_ip ) ; server . cluster_announce_ip = zstrdup ( argv [ 1 ] ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""cluster-announce-port"" ) && argc == 2 ) { server . cluster_announce_port = atoi ( argv [ 1 ] ) ; if ( server . cluster_announce_port < 0 || server . cluster_announce_port > 65535 ) { err = ""Invalid<S2SV_blank>port"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""cluster-announce-bus-port"" ) && argc == 2 ) { server . cluster_announce_bus_port = atoi ( argv [ 1 ] ) ; if ( server . cluster_announce_bus_port < 0 || server . cluster_announce_bus_port > 65535 ) { err = ""Invalid<S2SV_blank>port"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""cluster-require-full-coverage"" ) && argc == 2 ) { if ( ( server . cluster_require_full_coverage = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""cluster-node-timeout"" ) && argc == 2 ) { server . cluster_node_timeout = strtoll ( argv [ 1 ] , NULL , 10 ) ; if ( server . cluster_node_timeout <= 0 ) { err = ""cluster<S2SV_blank>node<S2SV_blank>timeout<S2SV_blank>must<S2SV_blank>be<S2SV_blank>1<S2SV_blank>or<S2SV_blank>greater"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""cluster-migration-barrier"" ) && argc == 2 ) { server . cluster_migration_barrier = atoi ( argv [ 1 ] ) ; if ( server . cluster_migration_barrier < 0 ) { err = ""cluster<S2SV_blank>migration<S2SV_blank>barrier<S2SV_blank>must<S2SV_blank>zero<S2SV_blank>or<S2SV_blank>positive"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""cluster-slave-validity-factor"" ) && argc == 2 ) { server . cluster_slave_validity_factor = atoi ( argv [ 1 ] ) ; if ( server . cluster_slave_validity_factor < 0 ) { err = ""cluster<S2SV_blank>slave<S2SV_blank>validity<S2SV_blank>factor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>zero<S2SV_blank>or<S2SV_blank>positive"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""lua-time-limit"" ) && argc == 2 ) { server . lua_time_limit = strtoll ( argv [ 1 ] , NULL , 10 ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""slowlog-log-slower-than"" ) && argc == 2 ) { server . slowlog_log_slower_than = strtoll ( argv [ 1 ] , NULL , 10 ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""latency-monitor-threshold"" ) && argc == 2 ) { server . latency_monitor_threshold = strtoll ( argv [ 1 ] , NULL , 10 ) ; if ( server . latency_monitor_threshold < 0 ) { err = ""The<S2SV_blank>latency<S2SV_blank>threshold<S2SV_blank>can\'t<S2SV_blank>be<S2SV_blank>negative"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""slowlog-max-len"" ) && argc == 2 ) { server . slowlog_max_len = strtoll ( argv [ 1 ] , NULL , 10 ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""client-output-buffer-limit"" ) && argc == 5 ) { int class = getClientTypeByName ( argv [ 1 ] ) ; unsigned long long hard , soft ; int soft_seconds ;  if ( class == - 1 ) {  err = ""Unrecognized<S2SV_blank>client<S2SV_blank>limit<S2SV_blank>class"" ; goto loaderr ; } hard = memtoll ( argv [ 2 ] , NULL ) ; soft = memtoll ( argv [ 3 ] , NULL ) ; soft_seconds = atoi ( argv [ 4 ] ) ; if ( soft_seconds < 0 ) { err = ""Negative<S2SV_blank>number<S2SV_blank>of<S2SV_blank>seconds<S2SV_blank>in<S2SV_blank>soft<S2SV_blank>limit<S2SV_blank>is<S2SV_blank>invalid"" ; goto loaderr ; } server . client_obuf_limits [ class ] . hard_limit_bytes = hard ; server . client_obuf_limits [ class ] . soft_limit_bytes = soft ; server . client_obuf_limits [ class ] . soft_limit_seconds = soft_seconds ; } else if ( ! strcasecmp ( argv [ 0 ] , ""stop-writes-on-bgsave-error"" ) && argc == 2 ) { if ( ( server . stop_writes_on_bgsave_err = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""slave-priority"" ) && argc == 2 ) { server . slave_priority = atoi ( argv [ 1 ] ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""slave-announce-ip"" ) && argc == 2 ) { zfree ( server . slave_announce_ip ) ; server . slave_announce_ip = zstrdup ( argv [ 1 ] ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""slave-announce-port"" ) && argc == 2 ) { server . slave_announce_port = atoi ( argv [ 1 ] ) ; if ( server . slave_announce_port < 0 || server . slave_announce_port > 65535 ) { err = ""Invalid<S2SV_blank>port"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""min-slaves-to-write"" ) && argc == 2 ) { server . repl_min_slaves_to_write = atoi ( argv [ 1 ] ) ; if ( server . repl_min_slaves_to_write < 0 ) { err = ""Invalid<S2SV_blank>value<S2SV_blank>for<S2SV_blank>min-slaves-to-write."" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""min-slaves-max-lag"" ) && argc == 2 ) { server . repl_min_slaves_max_lag = atoi ( argv [ 1 ] ) ; if ( server . repl_min_slaves_max_lag < 0 ) { err = ""Invalid<S2SV_blank>value<S2SV_blank>for<S2SV_blank>min-slaves-max-lag."" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""notify-keyspace-events"" ) && argc == 2 ) { int flags = keyspaceEventsStringToFlags ( argv [ 1 ] ) ; if ( flags == - 1 ) { err = ""Invalid<S2SV_blank>event<S2SV_blank>class<S2SV_blank>character.<S2SV_blank>Use<S2SV_blank>\'g$lshzxeA\'."" ; goto loaderr ; } server . notify_keyspace_events = flags ; } else if ( ! strcasecmp ( argv [ 0 ] , ""supervised"" ) && argc == 2 ) { server . supervised_mode = configEnumGetValue ( supervised_mode_enum , argv [ 1 ] ) ; if ( server . supervised_mode == INT_MIN ) { err = ""Invalid<S2SV_blank>option<S2SV_blank>for<S2SV_blank>\'supervised\'.<S2SV_blank>"" ""Allowed<S2SV_blank>values:<S2SV_blank>\'upstart\',<S2SV_blank>\'systemd\',<S2SV_blank>\'auto\',<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""loadmodule"" ) && argc >= 2 ) { queueLoadModule ( argv [ 1 ] , & argv [ 2 ] , argc - 2 ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""sentinel"" ) ) { if ( argc != 1 ) { if ( ! server . sentinel_mode ) { err = ""sentinel<S2SV_blank>directive<S2SV_blank>while<S2SV_blank>not<S2SV_blank>in<S2SV_blank>sentinel<S2SV_blank>mode"" ; goto loaderr ; } err = sentinelHandleConfiguration ( argv + 1 , argc - 1 ) ; if ( err ) goto loaderr ; } } else { err = ""Bad<S2SV_blank>directive<S2SV_blank>or<S2SV_blank>wrong<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments"" ; goto loaderr ; } sdsfreesplitres ( argv , argc ) ; } if ( server . cluster_enabled && server . masterhost ) { linenum = slaveof_linenum ; i = linenum - 1 ; err = ""slaveof<S2SV_blank>directive<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>in<S2SV_blank>cluster<S2SV_blank>mode"" ; goto loaderr ; } sdsfreesplitres ( lines , totlines ) ; return ; loaderr : fprintf ( stderr , ""\\n***<S2SV_blank>FATAL<S2SV_blank>CONFIG<S2SV_blank>FILE<S2SV_blank>ERROR<S2SV_blank>***\\n"" ) ; fprintf ( stderr , ""Reading<S2SV_blank>the<S2SV_blank>configuration<S2SV_blank>file,<S2SV_blank>at<S2SV_blank>line<S2SV_blank>%d\\n"" , linenum ) ; fprintf ( stderr , "">>><S2SV_blank>\'%s\'\\n"" , lines [ i ] ) ; fprintf ( stderr , ""%s\\n"" , err ) ; exit ( 1 ) ; }","if ( ( server . protected_mode = yesnotoi ( argv [ 1 ] ) ) == - 1 || class == CLIENT_TYPE_MASTER ) {err = ""Unrecognized<S2SV_blank>client<S2SV_blank>limit<S2SV_blank>class:<S2SV_blank>the<S2SV_blank>user<S2SV_blank>specified<S2SV_blank>"" ""an<S2SV_blank>invalid<S2SV_blank>one,<S2SV_blank>or<S2SV_blank>\\\'master\\\'<S2SV_blank>which<S2SV_blank>has<S2SV_blank>no<S2SV_blank>buffer<S2SV_blank>limits."" ;",31
46,"buggy line: if ( class == - 1 ) {err = ""Unrecognized<S2SV_blank>client<S2SV_blank>limit<S2SV_blank>class"" ;cwe id:CWE-119context: void loadServerConfigFromString ( char * config ) { char * err = NULL ; int linenum = 0 , totlines , i ; int slaveof_linenum = 0 ; sds * lines ; lines = sdssplitlen ( config , strlen ( config ) , ""\\n"" , 1 , & totlines ) ; for ( i = 0 ; i < totlines ; i ++ ) { sds * argv ; int argc ; linenum = i + 1 ; lines [ i ] = sdstrim ( lines [ i ] , ""<S2SV_blank>\\t\\r\\n"" ) ; if ( lines [ i ] [ 0 ] == '#' || lines [ i ] [ 0 ] == '\\0' ) continue ; argv = sdssplitargs ( lines [ i ] , & argc ) ; if ( argv == NULL ) { err = ""Unbalanced<S2SV_blank>quotes<S2SV_blank>in<S2SV_blank>configuration<S2SV_blank>line"" ; goto loaderr ; } if ( argc == 0 ) { sdsfreesplitres ( argv , argc ) ; continue ; } sdstolower ( argv [ 0 ] ) ; if ( ! strcasecmp ( argv [ 0 ] , ""timeout"" ) && argc == 2 ) { server . maxidletime = atoi ( argv [ 1 ] ) ; if ( server . maxidletime < 0 ) { err = ""Invalid<S2SV_blank>timeout<S2SV_blank>value"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""tcp-keepalive"" ) && argc == 2 ) { server . tcpkeepalive = atoi ( argv [ 1 ] ) ; if ( server . tcpkeepalive < 0 ) { err = ""Invalid<S2SV_blank>tcp-keepalive<S2SV_blank>value"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""protected-mode"" ) && argc == 2 ) { if ( ( server . protected_mode = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""port"" ) && argc == 2 ) { server . port = atoi ( argv [ 1 ] ) ; if ( server . port < 0 || server . port > 65535 ) { err = ""Invalid<S2SV_blank>port"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""tcp-backlog"" ) && argc == 2 ) { server . tcp_backlog = atoi ( argv [ 1 ] ) ; if ( server . tcp_backlog < 0 ) { err = ""Invalid<S2SV_blank>backlog<S2SV_blank>value"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""bind"" ) && argc >= 2 ) { int j , addresses = argc - 1 ; if ( addresses > CONFIG_BINDADDR_MAX ) { err = ""Too<S2SV_blank>many<S2SV_blank>bind<S2SV_blank>addresses<S2SV_blank>specified"" ; goto loaderr ; } for ( j = 0 ; j < addresses ; j ++ ) server . bindaddr [ j ] = zstrdup ( argv [ j + 1 ] ) ; server . bindaddr_count = addresses ; } else if ( ! strcasecmp ( argv [ 0 ] , ""unixsocket"" ) && argc == 2 ) { server . unixsocket = zstrdup ( argv [ 1 ] ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""unixsocketperm"" ) && argc == 2 ) { errno = 0 ; server . unixsocketperm = ( mode_t ) strtol ( argv [ 1 ] , NULL , 8 ) ; if ( errno || server . unixsocketperm > 0777 ) { err = ""Invalid<S2SV_blank>socket<S2SV_blank>file<S2SV_blank>permissions"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""save"" ) ) { if ( argc == 3 ) { int seconds = atoi ( argv [ 1 ] ) ; int changes = atoi ( argv [ 2 ] ) ; if ( seconds < 1 || changes < 0 ) { err = ""Invalid<S2SV_blank>save<S2SV_blank>parameters"" ; goto loaderr ; } appendServerSaveParams ( seconds , changes ) ; } else if ( argc == 2 && ! strcasecmp ( argv [ 1 ] , """" ) ) { resetServerSaveParams ( ) ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""dir"" ) && argc == 2 ) { if ( chdir ( argv [ 1 ] ) == - 1 ) { serverLog ( LL_WARNING , ""Can\'t<S2SV_blank>chdir<S2SV_blank>to<S2SV_blank>\'%s\':<S2SV_blank>%s"" , argv [ 1 ] , strerror ( errno ) ) ; exit ( 1 ) ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""loglevel"" ) && argc == 2 ) { server . verbosity = configEnumGetValue ( loglevel_enum , argv [ 1 ] ) ; if ( server . verbosity == INT_MIN ) { err = ""Invalid<S2SV_blank>log<S2SV_blank>level.<S2SV_blank>"" ""Must<S2SV_blank>be<S2SV_blank>one<S2SV_blank>of<S2SV_blank>debug,<S2SV_blank>verbose,<S2SV_blank>notice,<S2SV_blank>warning"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""logfile"" ) && argc == 2 ) { FILE * logfp ; zfree ( server . logfile ) ; server . logfile = zstrdup ( argv [ 1 ] ) ; if ( server . logfile [ 0 ] != '\\0' ) { logfp = fopen ( server . logfile , ""a"" ) ; if ( logfp == NULL ) { err = sdscatprintf ( sdsempty ( ) , ""Can\'t<S2SV_blank>open<S2SV_blank>the<S2SV_blank>log<S2SV_blank>file:<S2SV_blank>%s"" , strerror ( errno ) ) ; goto loaderr ; } fclose ( logfp ) ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""syslog-enabled"" ) && argc == 2 ) { if ( ( server . syslog_enabled = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""syslog-ident"" ) && argc == 2 ) { if ( server . syslog_ident ) zfree ( server . syslog_ident ) ; server . syslog_ident = zstrdup ( argv [ 1 ] ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""syslog-facility"" ) && argc == 2 ) { server . syslog_facility = configEnumGetValue ( syslog_facility_enum , argv [ 1 ] ) ; if ( server . syslog_facility == INT_MIN ) { err = ""Invalid<S2SV_blank>log<S2SV_blank>facility.<S2SV_blank>Must<S2SV_blank>be<S2SV_blank>one<S2SV_blank>of<S2SV_blank>USER<S2SV_blank>or<S2SV_blank>between<S2SV_blank>LOCAL0-LOCAL7"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""databases"" ) && argc == 2 ) { server . dbnum = atoi ( argv [ 1 ] ) ; if ( server . dbnum < 1 ) { err = ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>databases"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""include"" ) && argc == 2 ) { loadServerConfig ( argv [ 1 ] , NULL ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""maxclients"" ) && argc == 2 ) { server . maxclients = atoi ( argv [ 1 ] ) ; if ( server . maxclients < 1 ) { err = ""Invalid<S2SV_blank>max<S2SV_blank>clients<S2SV_blank>limit"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""maxmemory"" ) && argc == 2 ) { server . maxmemory = memtoll ( argv [ 1 ] , NULL ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""maxmemory-policy"" ) && argc == 2 ) { server . maxmemory_policy = configEnumGetValue ( maxmemory_policy_enum , argv [ 1 ] ) ; if ( server . maxmemory_policy == INT_MIN ) { err = ""Invalid<S2SV_blank>maxmemory<S2SV_blank>policy"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""maxmemory-samples"" ) && argc == 2 ) { server . maxmemory_samples = atoi ( argv [ 1 ] ) ; if ( server . maxmemory_samples <= 0 ) { err = ""maxmemory-samples<S2SV_blank>must<S2SV_blank>be<S2SV_blank>1<S2SV_blank>or<S2SV_blank>greater"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""lfu-log-factor"" ) && argc == 2 ) { server . lfu_log_factor = atoi ( argv [ 1 ] ) ; if ( server . maxmemory_samples < 0 ) { err = ""lfu-log-factor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>0<S2SV_blank>or<S2SV_blank>greater"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""lfu-decay-time"" ) && argc == 2 ) { server . lfu_decay_time = atoi ( argv [ 1 ] ) ; if ( server . maxmemory_samples < 1 ) { err = ""lfu-decay-time<S2SV_blank>must<S2SV_blank>be<S2SV_blank>0<S2SV_blank>or<S2SV_blank>greater"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""slaveof"" ) && argc == 3 ) { slaveof_linenum = linenum ; server . masterhost = sdsnew ( argv [ 1 ] ) ; server . masterport = atoi ( argv [ 2 ] ) ; server . repl_state = REPL_STATE_CONNECT ; } else if ( ! strcasecmp ( argv [ 0 ] , ""repl-ping-slave-period"" ) && argc == 2 ) { server . repl_ping_slave_period = atoi ( argv [ 1 ] ) ; if ( server . repl_ping_slave_period <= 0 ) { err = ""repl-ping-slave-period<S2SV_blank>must<S2SV_blank>be<S2SV_blank>1<S2SV_blank>or<S2SV_blank>greater"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""repl-timeout"" ) && argc == 2 ) { server . repl_timeout = atoi ( argv [ 1 ] ) ; if ( server . repl_timeout <= 0 ) { err = ""repl-timeout<S2SV_blank>must<S2SV_blank>be<S2SV_blank>1<S2SV_blank>or<S2SV_blank>greater"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""repl-disable-tcp-nodelay"" ) && argc == 2 ) { if ( ( server . repl_disable_tcp_nodelay = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""repl-diskless-sync"" ) && argc == 2 ) { if ( ( server . repl_diskless_sync = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""repl-diskless-sync-delay"" ) && argc == 2 ) { server . repl_diskless_sync_delay = atoi ( argv [ 1 ] ) ; if ( server . repl_diskless_sync_delay < 0 ) { err = ""repl-diskless-sync-delay<S2SV_blank>can\'t<S2SV_blank>be<S2SV_blank>negative"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""repl-backlog-size"" ) && argc == 2 ) { long long size = memtoll ( argv [ 1 ] , NULL ) ; if ( size <= 0 ) { err = ""repl-backlog-size<S2SV_blank>must<S2SV_blank>be<S2SV_blank>1<S2SV_blank>or<S2SV_blank>greater."" ; goto loaderr ; } resizeReplicationBacklog ( size ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""repl-backlog-ttl"" ) && argc == 2 ) { server . repl_backlog_time_limit = atoi ( argv [ 1 ] ) ; if ( server . repl_backlog_time_limit < 0 ) { err = ""repl-backlog-ttl<S2SV_blank>can\'t<S2SV_blank>be<S2SV_blank>negative<S2SV_blank>"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""masterauth"" ) && argc == 2 ) { zfree ( server . masterauth ) ; server . masterauth = zstrdup ( argv [ 1 ] ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""slave-serve-stale-data"" ) && argc == 2 ) { if ( ( server . repl_serve_stale_data = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""slave-read-only"" ) && argc == 2 ) { if ( ( server . repl_slave_ro = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""rdbcompression"" ) && argc == 2 ) { if ( ( server . rdb_compression = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""rdbchecksum"" ) && argc == 2 ) { if ( ( server . rdb_checksum = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""activerehashing"" ) && argc == 2 ) { if ( ( server . activerehashing = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""lazyfree-lazy-eviction"" ) && argc == 2 ) { if ( ( server . lazyfree_lazy_eviction = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""lazyfree-lazy-expire"" ) && argc == 2 ) { if ( ( server . lazyfree_lazy_expire = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""lazyfree-lazy-server-del"" ) && argc == 2 ) { if ( ( server . lazyfree_lazy_server_del = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""slave-lazy-flush"" ) && argc == 2 ) { if ( ( server . repl_slave_lazy_flush = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""daemonize"" ) && argc == 2 ) { if ( ( server . daemonize = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""hz"" ) && argc == 2 ) { server . hz = atoi ( argv [ 1 ] ) ; if ( server . hz < CONFIG_MIN_HZ ) server . hz = CONFIG_MIN_HZ ; if ( server . hz > CONFIG_MAX_HZ ) server . hz = CONFIG_MAX_HZ ; } else if ( ! strcasecmp ( argv [ 0 ] , ""appendonly"" ) && argc == 2 ) { int yes ; if ( ( yes = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } server . aof_state = yes ? AOF_ON : AOF_OFF ; } else if ( ! strcasecmp ( argv [ 0 ] , ""appendfilename"" ) && argc == 2 ) { if ( ! pathIsBaseName ( argv [ 1 ] ) ) { err = ""appendfilename<S2SV_blank>can\'t<S2SV_blank>be<S2SV_blank>a<S2SV_blank>path,<S2SV_blank>just<S2SV_blank>a<S2SV_blank>filename"" ; goto loaderr ; } zfree ( server . aof_filename ) ; server . aof_filename = zstrdup ( argv [ 1 ] ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""no-appendfsync-on-rewrite"" ) && argc == 2 ) { if ( ( server . aof_no_fsync_on_rewrite = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""appendfsync"" ) && argc == 2 ) { server . aof_fsync = configEnumGetValue ( aof_fsync_enum , argv [ 1 ] ) ; if ( server . aof_fsync == INT_MIN ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'no\',<S2SV_blank>\'always\'<S2SV_blank>or<S2SV_blank>\'everysec\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""auto-aof-rewrite-percentage"" ) && argc == 2 ) { server . aof_rewrite_perc = atoi ( argv [ 1 ] ) ; if ( server . aof_rewrite_perc < 0 ) { err = ""Invalid<S2SV_blank>negative<S2SV_blank>percentage<S2SV_blank>for<S2SV_blank>AOF<S2SV_blank>auto<S2SV_blank>rewrite"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""auto-aof-rewrite-min-size"" ) && argc == 2 ) { server . aof_rewrite_min_size = memtoll ( argv [ 1 ] , NULL ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""aof-rewrite-incremental-fsync"" ) && argc == 2 ) { if ( ( server . aof_rewrite_incremental_fsync = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""aof-load-truncated"" ) && argc == 2 ) { if ( ( server . aof_load_truncated = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""aof-use-rdb-preamble"" ) && argc == 2 ) { if ( ( server . aof_use_rdb_preamble = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""requirepass"" ) && argc == 2 ) { if ( strlen ( argv [ 1 ] ) > CONFIG_AUTHPASS_MAX_LEN ) { err = ""Password<S2SV_blank>is<S2SV_blank>longer<S2SV_blank>than<S2SV_blank>CONFIG_AUTHPASS_MAX_LEN"" ; goto loaderr ; } server . requirepass = zstrdup ( argv [ 1 ] ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""pidfile"" ) && argc == 2 ) { zfree ( server . pidfile ) ; server . pidfile = zstrdup ( argv [ 1 ] ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""dbfilename"" ) && argc == 2 ) { if ( ! pathIsBaseName ( argv [ 1 ] ) ) { err = ""dbfilename<S2SV_blank>can\'t<S2SV_blank>be<S2SV_blank>a<S2SV_blank>path,<S2SV_blank>just<S2SV_blank>a<S2SV_blank>filename"" ; goto loaderr ; } zfree ( server . rdb_filename ) ; server . rdb_filename = zstrdup ( argv [ 1 ] ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""hash-max-ziplist-entries"" ) && argc == 2 ) { server . hash_max_ziplist_entries = memtoll ( argv [ 1 ] , NULL ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""hash-max-ziplist-value"" ) && argc == 2 ) { server . hash_max_ziplist_value = memtoll ( argv [ 1 ] , NULL ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""list-max-ziplist-entries"" ) && argc == 2 ) { } else if ( ! strcasecmp ( argv [ 0 ] , ""list-max-ziplist-value"" ) && argc == 2 ) { } else if ( ! strcasecmp ( argv [ 0 ] , ""list-max-ziplist-size"" ) && argc == 2 ) { server . list_max_ziplist_size = atoi ( argv [ 1 ] ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""list-compress-depth"" ) && argc == 2 ) { server . list_compress_depth = atoi ( argv [ 1 ] ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""set-max-intset-entries"" ) && argc == 2 ) { server . set_max_intset_entries = memtoll ( argv [ 1 ] , NULL ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""zset-max-ziplist-entries"" ) && argc == 2 ) { server . zset_max_ziplist_entries = memtoll ( argv [ 1 ] , NULL ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""zset-max-ziplist-value"" ) && argc == 2 ) { server . zset_max_ziplist_value = memtoll ( argv [ 1 ] , NULL ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""hll-sparse-max-bytes"" ) && argc == 2 ) { server . hll_sparse_max_bytes = memtoll ( argv [ 1 ] , NULL ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""rename-command"" ) && argc == 3 ) { struct redisCommand * cmd = lookupCommand ( argv [ 1 ] ) ; int retval ; if ( ! cmd ) { err = ""No<S2SV_blank>such<S2SV_blank>command<S2SV_blank>in<S2SV_blank>rename-command"" ; goto loaderr ; } retval = dictDelete ( server . commands , argv [ 1 ] ) ; serverAssert ( retval == DICT_OK ) ; if ( sdslen ( argv [ 2 ] ) != 0 ) { sds copy = sdsdup ( argv [ 2 ] ) ; retval = dictAdd ( server . commands , copy , cmd ) ; if ( retval != DICT_OK ) { sdsfree ( copy ) ; err = ""Target<S2SV_blank>command<S2SV_blank>name<S2SV_blank>already<S2SV_blank>exists"" ; goto loaderr ; } } } else if ( ! strcasecmp ( argv [ 0 ] , ""cluster-enabled"" ) && argc == 2 ) { if ( ( server . cluster_enabled = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""cluster-config-file"" ) && argc == 2 ) { zfree ( server . cluster_configfile ) ; server . cluster_configfile = zstrdup ( argv [ 1 ] ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""cluster-announce-ip"" ) && argc == 2 ) { zfree ( server . cluster_announce_ip ) ; server . cluster_announce_ip = zstrdup ( argv [ 1 ] ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""cluster-announce-port"" ) && argc == 2 ) { server . cluster_announce_port = atoi ( argv [ 1 ] ) ; if ( server . cluster_announce_port < 0 || server . cluster_announce_port > 65535 ) { err = ""Invalid<S2SV_blank>port"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""cluster-announce-bus-port"" ) && argc == 2 ) { server . cluster_announce_bus_port = atoi ( argv [ 1 ] ) ; if ( server . cluster_announce_bus_port < 0 || server . cluster_announce_bus_port > 65535 ) { err = ""Invalid<S2SV_blank>port"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""cluster-require-full-coverage"" ) && argc == 2 ) { if ( ( server . cluster_require_full_coverage = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""cluster-node-timeout"" ) && argc == 2 ) { server . cluster_node_timeout = strtoll ( argv [ 1 ] , NULL , 10 ) ; if ( server . cluster_node_timeout <= 0 ) { err = ""cluster<S2SV_blank>node<S2SV_blank>timeout<S2SV_blank>must<S2SV_blank>be<S2SV_blank>1<S2SV_blank>or<S2SV_blank>greater"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""cluster-migration-barrier"" ) && argc == 2 ) { server . cluster_migration_barrier = atoi ( argv [ 1 ] ) ; if ( server . cluster_migration_barrier < 0 ) { err = ""cluster<S2SV_blank>migration<S2SV_blank>barrier<S2SV_blank>must<S2SV_blank>zero<S2SV_blank>or<S2SV_blank>positive"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""cluster-slave-validity-factor"" ) && argc == 2 ) { server . cluster_slave_validity_factor = atoi ( argv [ 1 ] ) ; if ( server . cluster_slave_validity_factor < 0 ) { err = ""cluster<S2SV_blank>slave<S2SV_blank>validity<S2SV_blank>factor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>zero<S2SV_blank>or<S2SV_blank>positive"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""lua-time-limit"" ) && argc == 2 ) { server . lua_time_limit = strtoll ( argv [ 1 ] , NULL , 10 ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""slowlog-log-slower-than"" ) && argc == 2 ) { server . slowlog_log_slower_than = strtoll ( argv [ 1 ] , NULL , 10 ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""latency-monitor-threshold"" ) && argc == 2 ) { server . latency_monitor_threshold = strtoll ( argv [ 1 ] , NULL , 10 ) ; if ( server . latency_monitor_threshold < 0 ) { err = ""The<S2SV_blank>latency<S2SV_blank>threshold<S2SV_blank>can\'t<S2SV_blank>be<S2SV_blank>negative"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""slowlog-max-len"" ) && argc == 2 ) { server . slowlog_max_len = strtoll ( argv [ 1 ] , NULL , 10 ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""client-output-buffer-limit"" ) && argc == 5 ) { int class = getClientTypeByName ( argv [ 1 ] ) ; unsigned long long hard , soft ; int soft_seconds ;  if ( class == - 1 ) {  err = ""Unrecognized<S2SV_blank>client<S2SV_blank>limit<S2SV_blank>class"" ; goto loaderr ; } hard = memtoll ( argv [ 2 ] , NULL ) ; soft = memtoll ( argv [ 3 ] , NULL ) ; soft_seconds = atoi ( argv [ 4 ] ) ; if ( soft_seconds < 0 ) { err = ""Negative<S2SV_blank>number<S2SV_blank>of<S2SV_blank>seconds<S2SV_blank>in<S2SV_blank>soft<S2SV_blank>limit<S2SV_blank>is<S2SV_blank>invalid"" ; goto loaderr ; } server . client_obuf_limits [ class ] . hard_limit_bytes = hard ; server . client_obuf_limits [ class ] . soft_limit_bytes = soft ; server . client_obuf_limits [ class ] . soft_limit_seconds = soft_seconds ; } else if ( ! strcasecmp ( argv [ 0 ] , ""stop-writes-on-bgsave-error"" ) && argc == 2 ) { if ( ( server . stop_writes_on_bgsave_err = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""slave-priority"" ) && argc == 2 ) { server . slave_priority = atoi ( argv [ 1 ] ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""slave-announce-ip"" ) && argc == 2 ) { zfree ( server . slave_announce_ip ) ; server . slave_announce_ip = zstrdup ( argv [ 1 ] ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""slave-announce-port"" ) && argc == 2 ) { server . slave_announce_port = atoi ( argv [ 1 ] ) ; if ( server . slave_announce_port < 0 || server . slave_announce_port > 65535 ) { err = ""Invalid<S2SV_blank>port"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""min-slaves-to-write"" ) && argc == 2 ) { server . repl_min_slaves_to_write = atoi ( argv [ 1 ] ) ; if ( server . repl_min_slaves_to_write < 0 ) { err = ""Invalid<S2SV_blank>value<S2SV_blank>for<S2SV_blank>min-slaves-to-write."" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""min-slaves-max-lag"" ) && argc == 2 ) { server . repl_min_slaves_max_lag = atoi ( argv [ 1 ] ) ; if ( server . repl_min_slaves_max_lag < 0 ) { err = ""Invalid<S2SV_blank>value<S2SV_blank>for<S2SV_blank>min-slaves-max-lag."" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""notify-keyspace-events"" ) && argc == 2 ) { int flags = keyspaceEventsStringToFlags ( argv [ 1 ] ) ; if ( flags == - 1 ) { err = ""Invalid<S2SV_blank>event<S2SV_blank>class<S2SV_blank>character.<S2SV_blank>Use<S2SV_blank>\'g$lshzxeA\'."" ; goto loaderr ; } server . notify_keyspace_events = flags ; } else if ( ! strcasecmp ( argv [ 0 ] , ""supervised"" ) && argc == 2 ) { server . supervised_mode = configEnumGetValue ( supervised_mode_enum , argv [ 1 ] ) ; if ( server . supervised_mode == INT_MIN ) { err = ""Invalid<S2SV_blank>option<S2SV_blank>for<S2SV_blank>\'supervised\'.<S2SV_blank>"" ""Allowed<S2SV_blank>values:<S2SV_blank>\'upstart\',<S2SV_blank>\'systemd\',<S2SV_blank>\'auto\',<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""loadmodule"" ) && argc >= 2 ) { queueLoadModule ( argv [ 1 ] , & argv [ 2 ] , argc - 2 ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""sentinel"" ) ) { if ( argc != 1 ) { if ( ! server . sentinel_mode ) { err = ""sentinel<S2SV_blank>directive<S2SV_blank>while<S2SV_blank>not<S2SV_blank>in<S2SV_blank>sentinel<S2SV_blank>mode"" ; goto loaderr ; } err = sentinelHandleConfiguration ( argv + 1 , argc - 1 ) ; if ( err ) goto loaderr ; } } else { err = ""Bad<S2SV_blank>directive<S2SV_blank>or<S2SV_blank>wrong<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments"" ; goto loaderr ; } sdsfreesplitres ( argv , argc ) ; } if ( server . cluster_enabled && server . masterhost ) { linenum = slaveof_linenum ; i = linenum - 1 ; err = ""slaveof<S2SV_blank>directive<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>in<S2SV_blank>cluster<S2SV_blank>mode"" ; goto loaderr ; } sdsfreesplitres ( lines , totlines ) ; return ; loaderr : fprintf ( stderr , ""\\n***<S2SV_blank>FATAL<S2SV_blank>CONFIG<S2SV_blank>FILE<S2SV_blank>ERROR<S2SV_blank>***\\n"" ) ; fprintf ( stderr , ""Reading<S2SV_blank>the<S2SV_blank>configuration<S2SV_blank>file,<S2SV_blank>at<S2SV_blank>line<S2SV_blank>%d\\n"" , linenum ) ; fprintf ( stderr , "">>><S2SV_blank>\'%s\'\\n"" , lines [ i ] ) ; fprintf ( stderr , ""%s\\n"" , err ) ; exit ( 1 ) ; }","if ( class == - 1 ) {err = ""Unrecognized<S2SV_blank>client<S2SV_blank>limit<S2SV_blank>class"" ;",31
47,"buggy line: unsigned long flags ;spin_lock_irqsave ( & tgtport -> lock , flags ) ;cwe id:CWE-119context: static struct nvmet_fc_tgt_queue * nvmet_fc_find_target_queue ( struct nvmet_fc_tgtport * tgtport , u64 connection_id ) { struct nvmet_fc_tgt_assoc * assoc ; struct nvmet_fc_tgt_queue * queue ; u64 association_id = nvmet_fc_getassociationid ( connection_id ) ; u16 qid = nvmet_fc_getqueueid ( connection_id ) ;  unsigned long flags ;  spin_lock_irqsave ( & tgtport -> lock , flags ) ; list_for_each_entry ( assoc , & tgtport -> assoc_list , a_list ) { if ( association_id == assoc -> association_id ) { queue = assoc -> queues [ qid ] ; if ( queue && ( ! atomic_read ( & queue -> connected ) || ! nvmet_fc_tgt_q_get ( queue ) ) ) queue = NULL ; spin_unlock_irqrestore ( & tgtport -> lock , flags ) ; return queue ; } } spin_unlock_irqrestore ( & tgtport -> lock , flags ) ; return NULL ; }","unsigned long flags ;if ( qid > NVMET_NR_QUEUES ) return NULL ;spin_lock_irqsave ( & tgtport -> lock , flags ) ;",32
48,"buggy line: dev -> interrupt_out_interval = interrupt_out_interval ? interrupt_out_interval : dev -> interrupt_out_endpoint -> bInterval ;usb_set_intfdata ( interface , dev ) ;retval = usb_register_dev ( interface , & tower_class ) ;if ( retval ) {dev_err ( idev , ""Not<S2SV_blank>able<S2SV_blank>to<S2SV_blank>get<S2SV_blank>a<S2SV_blank>minor<S2SV_blank>for<S2SV_blank>this<S2SV_blank>device.\\\usb_set_intfdata ( interface , NULL ) ;goto error ;}dev -> minor = interface -> minor ;dev_info ( & interface -> dev , ""LEGO<S2SV_blank>USB<S2SV_blank>Tower<S2SV_blank>#%d<S2SV_blank>now<S2SV_blank>attached<S2SV_blank>to<S2SV_blank>major<S2SV_blank>"" ""%d<S2SV_blank>minor<S2SV_blank>%d\\\cwe id:CWE-476context: static int tower_probe ( struct usb_interface * interface , const struct usb_device_id * id ) { struct device * idev = & interface -> dev ; struct usb_device * udev = interface_to_usbdev ( interface ) ; struct lego_usb_tower * dev = NULL ; struct usb_host_interface * iface_desc ; struct usb_endpoint_descriptor * endpoint ; struct tower_get_version_reply get_version_reply ; int i ; int retval = - ENOMEM ; int result ; dev = kmalloc ( sizeof ( struct lego_usb_tower ) , GFP_KERNEL ) ; if ( ! dev ) goto exit ; mutex_init ( & dev -> lock ) ; dev -> udev = udev ; dev -> open_count = 0 ; dev -> read_buffer = NULL ; dev -> read_buffer_length = 0 ; dev -> read_packet_length = 0 ; spin_lock_init ( & dev -> read_buffer_lock ) ; dev -> packet_timeout_jiffies = msecs_to_jiffies ( packet_timeout ) ; dev -> read_last_arrival = jiffies ; init_waitqueue_head ( & dev -> read_wait ) ; init_waitqueue_head ( & dev -> write_wait ) ; dev -> interrupt_in_buffer = NULL ; dev -> interrupt_in_endpoint = NULL ; dev -> interrupt_in_urb = NULL ; dev -> interrupt_in_running = 0 ; dev -> interrupt_in_done = 0 ; dev -> interrupt_out_buffer = NULL ; dev -> interrupt_out_endpoint = NULL ; dev -> interrupt_out_urb = NULL ; dev -> interrupt_out_busy = 0 ; iface_desc = interface -> cur_altsetting ; for ( i = 0 ; i < iface_desc -> desc . bNumEndpoints ; ++ i ) { endpoint = & iface_desc -> endpoint [ i ] . desc ; if ( usb_endpoint_xfer_int ( endpoint ) ) { if ( usb_endpoint_dir_in ( endpoint ) ) dev -> interrupt_in_endpoint = endpoint ; else dev -> interrupt_out_endpoint = endpoint ; } } if ( dev -> interrupt_in_endpoint == NULL ) { dev_err ( idev , ""interrupt<S2SV_blank>in<S2SV_blank>endpoint<S2SV_blank>not<S2SV_blank>found\\n"" ) ; goto error ; } if ( dev -> interrupt_out_endpoint == NULL ) { dev_err ( idev , ""interrupt<S2SV_blank>out<S2SV_blank>endpoint<S2SV_blank>not<S2SV_blank>found\\n"" ) ; goto error ; } dev -> read_buffer = kmalloc ( read_buffer_size , GFP_KERNEL ) ; if ( ! dev -> read_buffer ) goto error ; dev -> interrupt_in_buffer = kmalloc ( usb_endpoint_maxp ( dev -> interrupt_in_endpoint ) , GFP_KERNEL ) ; if ( ! dev -> interrupt_in_buffer ) goto error ; dev -> interrupt_in_urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! dev -> interrupt_in_urb ) goto error ; dev -> interrupt_out_buffer = kmalloc ( write_buffer_size , GFP_KERNEL ) ; if ( ! dev -> interrupt_out_buffer ) goto error ; dev -> interrupt_out_urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! dev -> interrupt_out_urb ) goto error ; dev -> interrupt_in_interval = interrupt_in_interval ? interrupt_in_interval : dev -> interrupt_in_endpoint -> bInterval ; dev -> interrupt_out_interval = interrupt_out_interval ? interrupt_out_interval : dev -> interrupt_out_endpoint -> bInterval ;  usb_set_intfdata ( interface , dev ) ;  retval = usb_register_dev ( interface , & tower_class ) ; if ( retval ) { dev_err ( idev , ""Not<S2SV_blank>able<S2SV_blank>to<S2SV_blank>get<S2SV_blank>a<S2SV_blank>minor<S2SV_blank>for<S2SV_blank>this<S2SV_blank>device.\\n"" ) ; usb_set_intfdata ( interface , NULL ) ; goto error ; } dev -> minor = interface -> minor ; dev_info ( & interface -> dev , ""LEGO<S2SV_blank>USB<S2SV_blank>Tower<S2SV_blank>#%d<S2SV_blank>now<S2SV_blank>attached<S2SV_blank>to<S2SV_blank>major<S2SV_blank>"" ""%d<S2SV_blank>minor<S2SV_blank>%d\\n"" , ( dev -> minor - LEGO_USB_TOWER_MINOR_BASE ) , USB_MAJOR , dev -> minor ) ; result = usb_control_msg ( udev , usb_rcvctrlpipe ( udev , 0 ) , LEGO_USB_TOWER_REQUEST_GET_VERSION , USB_TYPE_VENDOR | USB_DIR_IN | USB_RECIP_DEVICE , 0 , 0 , & get_version_reply , sizeof ( get_version_reply ) , 1000 ) ; if ( result < 0 ) { dev_err ( idev , ""LEGO<S2SV_blank>USB<S2SV_blank>Tower<S2SV_blank>get<S2SV_blank>version<S2SV_blank>control<S2SV_blank>request<S2SV_blank>failed\\n"" ) ; retval = result ; goto error ; } dev_info ( & interface -> dev , ""LEGO<S2SV_blank>USB<S2SV_blank>Tower<S2SV_blank>firmware<S2SV_blank>version<S2SV_blank>is<S2SV_blank>%d.%d<S2SV_blank>"" ""build<S2SV_blank>%d\\n"" , get_version_reply . major , get_version_reply . minor , le16_to_cpu ( get_version_reply . build_no ) ) ;  exit :  return retval ; error : tower_delete ( dev ) ; return retval ; }","
",33
49,"buggy line: exit :  return retval ;cwe id:CWE-476context: static int tower_probe ( struct usb_interface * interface , const struct usb_device_id * id ) { struct device * idev = & interface -> dev ; struct usb_device * udev = interface_to_usbdev ( interface ) ; struct lego_usb_tower * dev = NULL ; struct usb_host_interface * iface_desc ; struct usb_endpoint_descriptor * endpoint ; struct tower_get_version_reply get_version_reply ; int i ; int retval = - ENOMEM ; int result ; dev = kmalloc ( sizeof ( struct lego_usb_tower ) , GFP_KERNEL ) ; if ( ! dev ) goto exit ; mutex_init ( & dev -> lock ) ; dev -> udev = udev ; dev -> open_count = 0 ; dev -> read_buffer = NULL ; dev -> read_buffer_length = 0 ; dev -> read_packet_length = 0 ; spin_lock_init ( & dev -> read_buffer_lock ) ; dev -> packet_timeout_jiffies = msecs_to_jiffies ( packet_timeout ) ; dev -> read_last_arrival = jiffies ; init_waitqueue_head ( & dev -> read_wait ) ; init_waitqueue_head ( & dev -> write_wait ) ; dev -> interrupt_in_buffer = NULL ; dev -> interrupt_in_endpoint = NULL ; dev -> interrupt_in_urb = NULL ; dev -> interrupt_in_running = 0 ; dev -> interrupt_in_done = 0 ; dev -> interrupt_out_buffer = NULL ; dev -> interrupt_out_endpoint = NULL ; dev -> interrupt_out_urb = NULL ; dev -> interrupt_out_busy = 0 ; iface_desc = interface -> cur_altsetting ; for ( i = 0 ; i < iface_desc -> desc . bNumEndpoints ; ++ i ) { endpoint = & iface_desc -> endpoint [ i ] . desc ; if ( usb_endpoint_xfer_int ( endpoint ) ) { if ( usb_endpoint_dir_in ( endpoint ) ) dev -> interrupt_in_endpoint = endpoint ; else dev -> interrupt_out_endpoint = endpoint ; } } if ( dev -> interrupt_in_endpoint == NULL ) { dev_err ( idev , ""interrupt<S2SV_blank>in<S2SV_blank>endpoint<S2SV_blank>not<S2SV_blank>found\\n"" ) ; goto error ; } if ( dev -> interrupt_out_endpoint == NULL ) { dev_err ( idev , ""interrupt<S2SV_blank>out<S2SV_blank>endpoint<S2SV_blank>not<S2SV_blank>found\\n"" ) ; goto error ; } dev -> read_buffer = kmalloc ( read_buffer_size , GFP_KERNEL ) ; if ( ! dev -> read_buffer ) goto error ; dev -> interrupt_in_buffer = kmalloc ( usb_endpoint_maxp ( dev -> interrupt_in_endpoint ) , GFP_KERNEL ) ; if ( ! dev -> interrupt_in_buffer ) goto error ; dev -> interrupt_in_urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! dev -> interrupt_in_urb ) goto error ; dev -> interrupt_out_buffer = kmalloc ( write_buffer_size , GFP_KERNEL ) ; if ( ! dev -> interrupt_out_buffer ) goto error ; dev -> interrupt_out_urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! dev -> interrupt_out_urb ) goto error ; dev -> interrupt_in_interval = interrupt_in_interval ? interrupt_in_interval : dev -> interrupt_in_endpoint -> bInterval ; dev -> interrupt_out_interval = interrupt_out_interval ? interrupt_out_interval : dev -> interrupt_out_endpoint -> bInterval ;  usb_set_intfdata ( interface , dev ) ;  retval = usb_register_dev ( interface , & tower_class ) ; if ( retval ) { dev_err ( idev , ""Not<S2SV_blank>able<S2SV_blank>to<S2SV_blank>get<S2SV_blank>a<S2SV_blank>minor<S2SV_blank>for<S2SV_blank>this<S2SV_blank>device.\\n"" ) ; usb_set_intfdata ( interface , NULL ) ; goto error ; } dev -> minor = interface -> minor ; dev_info ( & interface -> dev , ""LEGO<S2SV_blank>USB<S2SV_blank>Tower<S2SV_blank>#%d<S2SV_blank>now<S2SV_blank>attached<S2SV_blank>to<S2SV_blank>major<S2SV_blank>"" ""%d<S2SV_blank>minor<S2SV_blank>%d\\n"" , ( dev -> minor - LEGO_USB_TOWER_MINOR_BASE ) , USB_MAJOR , dev -> minor ) ; result = usb_control_msg ( udev , usb_rcvctrlpipe ( udev , 0 ) , LEGO_USB_TOWER_REQUEST_GET_VERSION , USB_TYPE_VENDOR | USB_DIR_IN | USB_RECIP_DEVICE , 0 , 0 , & get_version_reply , sizeof ( get_version_reply ) , 1000 ) ; if ( result < 0 ) { dev_err ( idev , ""LEGO<S2SV_blank>USB<S2SV_blank>Tower<S2SV_blank>get<S2SV_blank>version<S2SV_blank>control<S2SV_blank>request<S2SV_blank>failed\\n"" ) ; retval = result ; goto error ; } dev_info ( & interface -> dev , ""LEGO<S2SV_blank>USB<S2SV_blank>Tower<S2SV_blank>firmware<S2SV_blank>version<S2SV_blank>is<S2SV_blank>%d.%d<S2SV_blank>"" ""build<S2SV_blank>%d\\n"" , get_version_reply . major , get_version_reply . minor , le16_to_cpu ( get_version_reply . build_no ) ) ;  exit :  return retval ; error : tower_delete ( dev ) ; return retval ; }","usb_set_intfdata ( interface , dev ) ;retval = usb_register_dev ( interface , & tower_class ) ;if ( retval ) {dev_err ( idev , ""Not<S2SV_blank>able<S2SV_blank>to<S2SV_blank>get<S2SV_blank>a<S2SV_blank>minor<S2SV_blank>for<S2SV_blank>this<S2SV_blank>device.\\\usb_set_intfdata ( interface , NULL ) ;goto error ;}dev -> minor = interface -> minor ;dev_info ( & interface -> dev , ""LEGO<S2SV_blank>USB<S2SV_blank>Tower<S2SV_blank>#%d<S2SV_blank>now<S2SV_blank>attached<S2SV_blank>to<S2SV_blank>major<S2SV_blank>"" ""%d<S2SV_blank>minor<S2SV_blank>%d\\\exit : return retval ;",33
50,"buggy line: if ( shdr -> sh_size < 1 || shdr -> sh_size > SIZE_MAX ) {return false ;}Elf_ ( Verdef ) * defs = calloc ( shdr -> sh_size , sizeof ( char ) ) ;if ( ! defs ) {return false ;}if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) {section_name = & bin -> shstrtab [ shdr -> sh_name ] ;}if ( link_shdr && bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) {link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ;}if ( ! defs ) {bprintf ( ""Warning:<S2SV_blank>Cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>(Check<S2SV_blank>Elf_(Verdef))\\\return NULL ;}sdb = sdb_new0 ( ) ;end = ( char * ) defs + shdr -> sh_size ;sdb_set ( sdb , ""section_name"" , section_name , 0 ) ;sdb_num_set ( sdb , ""entries"" , shdr -> sh_info , 0 ) ;sdb_num_set ( sdb , ""addr"" , shdr -> sh_addr , 0 ) ;sdb_num_set ( sdb , ""offset"" , shdr -> sh_offset , 0 ) ;sdb_num_set ( sdb , ""link"" , shdr -> sh_link , 0 ) ;sdb_set ( sdb , ""link_section_name"" , link_section_name , 0 ) ;for ( cnt = 0 , i = 0 ;i >= 0 && cnt < shdr -> sh_info && ( end - ( char * ) defs > i ) ;++ cnt ) {Sdb * sdb_verdef = sdb_new0 ( ) ;char * vstart = ( ( char * ) defs ) + i ;char key [ 32 ] = {0 };Elf_ ( Verdef ) * verdef = ( Elf_ ( Verdef ) * ) vstart ;Elf_ ( Verdaux ) aux = {0 };int j = 0 ;int isum = 0 ;r_buf_read_at ( bin -> b , shdr -> sh_offset + i , dfs , sizeof ( Elf_ ( Verdef ) ) ) ;verdef -> vd_version = READ16 ( dfs , j ) verdef -> vd_flags = READ16 ( dfs , j ) verdef -> vd_ndx = READ16 ( dfs , j ) verdef -> vd_cnt = READ16 ( dfs , j ) verdef -> vd_hash = READ32 ( dfs , j ) verdef -> vd_aux = READ32 ( dfs , j ) verdef -> vd_next = READ32 ( dfs , j ) int vdaux = verdef -> vd_aux ;if ( vdaux < 1 || ( char * ) UINTPTR_MAX - vstart < vdaux ) {sdb_free ( sdb_verdef ) ;cwe id:CWE-476context: static Sdb * store_versioninfo_gnu_verdef ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { const char * section_name = """" ; const char * link_section_name = """" ; char * end = NULL ; Elf_ ( Shdr ) * link_shdr = NULL ; ut8 dfs [ sizeof ( Elf_ ( Verdef ) ) ] = { 0 } ; Sdb * sdb ; int cnt , i ; if ( shdr -> sh_link > bin -> ehdr . e_shnum ) { return false ; } link_shdr = & bin -> shdr [ shdr -> sh_link ] ; if ( shdr -> sh_size < 1 || shdr -> sh_size > SIZE_MAX ) { return false ; } Elf_ ( Verdef ) * defs = calloc ( shdr -> sh_size , sizeof ( char ) ) ; if ( ! defs ) { return false ; } if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) { section_name = & bin -> shstrtab [ shdr -> sh_name ] ; } if ( link_shdr && bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) { link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ; } if ( ! defs ) { bprintf ( ""Warning:<S2SV_blank>Cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>(Check<S2SV_blank>Elf_(Verdef))\\n"" ) ; return NULL ; } sdb = sdb_new0 ( ) ; end = ( char * ) defs + shdr -> sh_size ; sdb_set ( sdb , ""section_name"" , section_name , 0 ) ; sdb_num_set ( sdb , ""entries"" , shdr -> sh_info , 0 ) ; sdb_num_set ( sdb , ""addr"" , shdr -> sh_addr , 0 ) ; sdb_num_set ( sdb , ""offset"" , shdr -> sh_offset , 0 ) ; sdb_num_set ( sdb , ""link"" , shdr -> sh_link , 0 ) ; sdb_set ( sdb , ""link_section_name"" , link_section_name , 0 ) ; for ( cnt = 0 , i = 0 ; i >= 0 && cnt < shdr -> sh_info && ( end - ( char * ) defs > i ) ; ++ cnt ) { Sdb * sdb_verdef = sdb_new0 ( ) ; char * vstart = ( ( char * ) defs ) + i ; char key [ 32 ] = { 0 } ; Elf_ ( Verdef ) * verdef = ( Elf_ ( Verdef ) * ) vstart ; Elf_ ( Verdaux ) aux = { 0 } ; int j = 0 ; int isum = 0 ; r_buf_read_at ( bin -> b , shdr -> sh_offset + i , dfs , sizeof ( Elf_ ( Verdef ) ) ) ; verdef -> vd_version = READ16 ( dfs , j ) verdef -> vd_flags = READ16 ( dfs , j ) verdef -> vd_ndx = READ16 ( dfs , j ) verdef -> vd_cnt = READ16 ( dfs , j ) verdef -> vd_hash = READ32 ( dfs , j ) verdef -> vd_aux = READ32 ( dfs , j ) verdef -> vd_next = READ32 ( dfs , j ) int vdaux = verdef -> vd_aux ;  if ( vdaux < 1 || ( char * ) UINTPTR_MAX - vstart < vdaux ) {  sdb_free ( sdb_verdef ) ; goto out_error ; } vstart += vdaux ; if ( vstart > end || end - vstart < sizeof ( Elf_ ( Verdaux ) ) ) { sdb_free ( sdb_verdef ) ; goto out_error ; } j = 0 ; aux . vda_name = READ32 ( vstart , j ) aux . vda_next = READ32 ( vstart , j ) isum = i + verdef -> vd_aux ; if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; goto out_error ; } sdb_num_set ( sdb_verdef , ""idx"" , i , 0 ) ; sdb_num_set ( sdb_verdef , ""vd_version"" , verdef -> vd_version , 0 ) ; sdb_num_set ( sdb_verdef , ""vd_ndx"" , verdef -> vd_ndx , 0 ) ; sdb_num_set ( sdb_verdef , ""vd_cnt"" , verdef -> vd_cnt , 0 ) ; sdb_set ( sdb_verdef , ""vda_name"" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; sdb_set ( sdb_verdef , ""flags"" , get_ver_flags ( verdef -> vd_flags ) , 0 ) ; for ( j = 1 ; j < verdef -> vd_cnt ; ++ j ) { int k ; Sdb * sdb_parent = sdb_new0 ( ) ; isum += aux . vda_next ; vstart += aux . vda_next ; if ( vstart > end || end - vstart < sizeof ( Elf_ ( Verdaux ) ) ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } k = 0 ; aux . vda_name = READ32 ( vstart , k ) aux . vda_next = READ32 ( vstart , k ) if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } sdb_num_set ( sdb_parent , ""idx"" , isum , 0 ) ; sdb_num_set ( sdb_parent , ""parent"" , j , 0 ) ; sdb_set ( sdb_parent , ""vda_name"" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; snprintf ( key , sizeof ( key ) , ""parent%d"" , j - 1 ) ; sdb_ns_set ( sdb_verdef , key , sdb_parent ) ; } snprintf ( key , sizeof ( key ) , ""verdef%d"" , cnt ) ; sdb_ns_set ( sdb , key , sdb_verdef ) ; if ( ! verdef -> vd_next ) { sdb_free ( sdb_verdef ) ; goto out_error ; } if ( ( st32 ) verdef -> vd_next < 1 ) { eprintf ( ""Warning:<S2SV_blank>Invalid<S2SV_blank>vd_next<S2SV_blank>in<S2SV_blank>the<S2SV_blank>ELF<S2SV_blank>version\\n"" ) ; break ; } i += verdef -> vd_next ; } free ( defs ) ; return sdb ; out_error : free ( defs ) ; sdb_free ( sdb ) ; return NULL ; }",+ cnt ) {if ( shdr -> sh_size < 1 || vstart + vdaux < vstart ) {sdb_free ( sdb_verdef ) ;,34
51,"buggy line: static void construct_get_dest_keyring ( struct key * * _dest_keyring )  {kenter ( ""%p"" , dest_keyring ) ;if ( dest_keyring ) {key_get ( dest_keyring ) ;}else {switch ( cred -> jit_keyring ) {case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) {authkey = cred -> request_key_auth ;down_read ( & authkey -> sem ) ;rka = authkey -> payload . data [ 0 ] ;if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ;up_read ( & authkey -> sem ) ;if ( dest_keyring )  break ;}cwe id:CWE-862context:  static void construct_get_dest_keyring ( struct key * * _dest_keyring )  { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ;  kenter ( ""%p"" , dest_keyring ) ;  if ( dest_keyring ) { key_get ( dest_keyring ) ;  } else {  switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring )  break ;  } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; }  }  * _dest_keyring = dest_keyring ; kleave ( ""<S2SV_blank>[dk<S2SV_blank>%d]"" , key_serial ( dest_keyring ) ) ;  return ;  }","static int construct_get_dest_keyring ( struct key * * _dest_keyring ) {int ret ;kenter ( ""%p"" , dest_keyring ) ;if ( dest_keyring ) {do_perm_check = false ;break ;}}",35
52,"buggy line: }* _dest_keyring = dest_keyring ;return ;}cwe id:CWE-862context:  static void construct_get_dest_keyring ( struct key * * _dest_keyring )  { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ;  kenter ( ""%p"" , dest_keyring ) ;  if ( dest_keyring ) { key_get ( dest_keyring ) ;  } else {  switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring )  break ;  } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; }  }  * _dest_keyring = dest_keyring ; kleave ( ""<S2SV_blank>[dk<S2SV_blank>%d]"" , key_serial ( dest_keyring ) ) ;  return ;  }","if ( dest_keyring && do_perm_check ) {ret = key_permission ( make_key_ref ( dest_keyring , 1 ) , KEY_NEED_WRITE ) ;if ( ret ) {key_put ( dest_keyring ) ;return 0 ret ;}}}* _dest_keyring = dest_keyring ;return ;}",35
53,"buggy line: sc = create_spnego_ctx ( ) ;if ( sc == NULL ) return GSS_S_FAILURE ;cwe id:CWE-763context: static OM_uint32 init_ctx_new ( OM_uint32 * minor_status , spnego_gss_cred_id_t spcred , gss_ctx_id_t * ctx , send_token_flag * tokflag ) { OM_uint32 ret ; spnego_gss_ctx_id_t sc = NULL ;  sc = create_spnego_ctx ( ) ;  if ( sc == NULL ) return GSS_S_FAILURE ; ret = get_negotiable_mechs ( minor_status , spcred , GSS_C_INITIATE , & sc -> mech_set ) ; if ( ret != GSS_S_COMPLETE ) goto cleanup ; sc -> internal_mech = & sc -> mech_set -> elements [ 0 ] ; if ( put_mech_set ( sc -> mech_set , & sc -> DER_mechTypes ) < 0 ) { ret = GSS_S_FAILURE ; goto cleanup ; } sc -> ctx_handle = GSS_C_NO_CONTEXT ; * ctx = ( gss_ctx_id_t ) sc ; sc = NULL ; * tokflag = INIT_TOKEN_SEND ; ret = GSS_S_CONTINUE_NEEDED ; cleanup : release_spnego_ctx ( & sc ) ; return ret ; }",sc = create_spnego_ctx ( 1 ) ;if ( sc == NULL ) return GSS_S_FAILURE ;,36
54,"buggy line: if ( ! sock_flag ( sk , SOCK_ZAPPED ) )  return - EINVAL ;if ( addr_len < sizeof ( struct sockaddr_l2tpip ) )  return - EINVAL ;if ( addr -> l2tp_family != AF_INET )  return - EINVAL ;lock_sock ( sk ) ;if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ;cwe id:CWE-416context: static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ;  if ( ! sock_flag ( sk , SOCK_ZAPPED ) )  return - EINVAL ;  if ( addr_len < sizeof ( struct sockaddr_l2tpip ) )  return - EINVAL ;  if ( addr -> l2tp_family != AF_INET )  return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ;  lock_sock ( sk ) ;  if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }","if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ;if ( addr -> l2tp_family != AF_INET ) return - EINVAL ;if ( addr -> l2tp_family != AF_INET ) return - EINVAL ;lock_sock ( sk ) ;if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) goto out ;if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ;",37
55,buggy line: static unsigned int stack_maxrandom_size ( void )  {unsigned int max = 0 ;if ( ( current -> flags & PF_RANDOMIZE ) && ! ( current -> personality & ADDR_NO_RANDOMIZE ) ) {max = ( ( - 1U ) & STACK_RND_MASK ) << PAGE_SHIFT ;}cwe id:CWE-264context:  static unsigned int stack_maxrandom_size ( void )  {  unsigned int max = 0 ;  if ( ( current -> flags & PF_RANDOMIZE ) && ! ( current -> personality & ADDR_NO_RANDOMIZE ) ) {  max = ( ( - 1U ) & STACK_RND_MASK ) << PAGE_SHIFT ;  } return max ; },static unsigned long stack_maxrandom_size ( void ) {unsigned long max = 0 ;if ( ( current -> flags & PF_RANDOMIZE ) && ! ( current -> personality & ADDR_NO_RANDOMIZE ) ) {max = ( ( - 1UL ) & STACK_RND_MASK ) << PAGE_SHIFT ;},38
56,"buggy line: gtk_dialog_add_button ( GTK_DIALOG ( dialog ) ,  _ ( ""_Launch<S2SV_blank>Anyway"" ) , RESPONSE_RUN ) ;if ( nautilus_file_can_set_permissions ( file ) ) {gtk_dialog_add_button ( GTK_DIALOG ( dialog ) ,  _ ( ""Mark<S2SV_blank>as<S2SV_blank>_Trusted"" ) , RESPONSE_MARK_TRUSTED ) ;}gtk_dialog_add_button ( GTK_DIALOG ( dialog ) ,  _ ( ""_Cancel"" ) , GTK_RESPONSE_CANCEL ) ;cwe id:CWE-20context: static void activate_desktop_file ( ActivateParameters * parameters , NautilusFile * file ) { ActivateParametersDesktop * parameters_desktop ; char * primary , * secondary , * display_name ; GtkWidget * dialog ; GdkScreen * screen ; char * uri ; screen = gtk_widget_get_screen ( GTK_WIDGET ( parameters -> parent_window ) ) ; if ( ! nautilus_file_is_trusted_link ( file ) ) { parameters_desktop = g_new0 ( ActivateParametersDesktop , 1 ) ; if ( parameters -> parent_window ) { parameters_desktop -> parent_window = parameters -> parent_window ; g_object_add_weak_pointer ( G_OBJECT ( parameters_desktop -> parent_window ) , ( gpointer * ) & parameters_desktop -> parent_window ) ; } parameters_desktop -> file = nautilus_file_ref ( file ) ; primary = _ ( ""Untrusted<S2SV_blank>application<S2SV_blank>launcher"" ) ; display_name = nautilus_file_get_display_name ( file ) ; secondary = g_strdup_printf ( _ ( ""The<S2SV_blank>application<S2SV_blank>launcher<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>not<S2SV_blank>been<S2SV_blank>marked<S2SV_blank>as<S2SV_blank>trusted.<S2SV_blank>"" ""If<S2SV_blank>you<S2SV_blank>do<S2SV_blank>not<S2SV_blank>know<S2SV_blank>the<S2SV_blank>source<S2SV_blank>of<S2SV_blank>this<S2SV_blank>file,<S2SV_blank>launching<S2SV_blank>it<S2SV_blank>may<S2SV_blank>be<S2SV_blank>unsafe."" ) , display_name ) ; dialog = gtk_message_dialog_new ( parameters -> parent_window , 0 , GTK_MESSAGE_WARNING , GTK_BUTTONS_NONE , NULL ) ; g_object_set ( dialog , ""text"" , primary , ""secondary-text"" , secondary , NULL ) ; gtk_dialog_add_button ( GTK_DIALOG ( dialog ) ,  _ ( ""_Launch<S2SV_blank>Anyway"" ) , RESPONSE_RUN ) ;  if ( nautilus_file_can_set_permissions ( file ) ) { gtk_dialog_add_button ( GTK_DIALOG ( dialog ) ,  _ ( ""Mark<S2SV_blank>as<S2SV_blank>_Trusted"" ) , RESPONSE_MARK_TRUSTED ) ;  }  gtk_dialog_add_button ( GTK_DIALOG ( dialog ) ,  _ ( ""_Cancel"" ) , GTK_RESPONSE_CANCEL ) ; gtk_dialog_set_default_response ( GTK_DIALOG ( dialog ) , GTK_RESPONSE_CANCEL ) ; g_signal_connect ( dialog , ""response"" , G_CALLBACK ( untrusted_launcher_response_callback ) , parameters_desktop ) ; gtk_widget_show ( dialog ) ; g_free ( display_name ) ; g_free ( secondary ) ; return ; } uri = nautilus_file_get_uri ( file ) ; DEBUG ( ""Launching<S2SV_blank>trusted<S2SV_blank>launcher<S2SV_blank>%s"" , uri ) ; nautilus_launch_desktop_file ( screen , uri , NULL , parameters -> parent_window ) ; g_free ( uri ) ; }","gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , _ ( ""_Cancel"" ) , GTK_RESPONSE_CANCEL ) ;gtk_dialog_set_default_response ( GTK_DIALOG ( dialog ) , GTK_RESPONSE_CANCEL ) ;if ( nautilus_file_can_set_permissions ( file ) ) {gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , _ ( ""Trust<S2SV_blank>and<S2SV_blank>_Launch"" ) , GTK_RESPONSE_OK ) ;}gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , _ ( ""_Cancel"" ) , GTK_RESPONSE_CANCEL ) ;",39
57,buggy line: tm = localtime ( & t ) ;str = g_strdup ( asctime ( tm ) ) ;cwe id:CWE-416context: char * my_asctime ( time_t t ) { struct tm * tm ; char * str ; int len ;  tm = localtime ( & t ) ;  str = g_strdup ( asctime ( tm ) ) ; len = strlen ( str ) ; if ( len > 0 ) str [ len - 1 ] = '\\0' ; return str ; },"tm = localtime ( & t ) ;if ( tm == NULL ) return g_strdup ( ""???"" ) ;str = g_strdup ( asctime ( tm ) ) ;",40
58,"buggy line: memcpy ( hashed , password , strlen ( password ) ) ;attr = find_attribute ( request , PW_PASSWORD ) ;cwe id:CWE-787context: static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ;  memcpy ( hashed , password , strlen ( password ) ) ;  attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }","memcpy ( hashed , password , length ) ;attr = find_attribute ( request , PW_PASSWORD ) ;",41
59,"buggy line: static int m88rs2000_frontend_attach ( struct dvb_usb_adapter * d )  {u8 obuf [ ] = {0x51 };u8 ibuf [ ] = {0 };if ( dvb_usb_generic_rw ( d -> dev , obuf , 1 , ibuf , 1 , 0 ) < 0 )  err ( ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ;d -> fe_adap [ 0 ] . fe = dvb_attach ( m88rs2000_attach , & s421_m88rs2000_config ,   & d -> dev -> i2c_adap ) ;if ( d -> fe_adap [ 0 ] . fe == NULL )  return - EIO ;if ( dvb_attach ( ts2020_attach , d -> fe_adap [ 0 ] . fe ,  & dw2104_ts2020_config ,  & d -> dev -> i2c_adap ) ) {info ( ""Attached<S2SV_blank>RS2000/TS2020!"" ) ;cwe id:CWE-119context:  static int m88rs2000_frontend_attach ( struct dvb_usb_adapter * d )  { u8 obuf [ ] = { 0x51 } ; u8 ibuf [ ] = { 0 } ;  if ( dvb_usb_generic_rw ( d -> dev , obuf , 1 , ibuf , 1 , 0 ) < 0 )  err ( ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ;  d -> fe_adap [ 0 ] . fe = dvb_attach ( m88rs2000_attach , & s421_m88rs2000_config ,   & d -> dev -> i2c_adap ) ;   if ( d -> fe_adap [ 0 ] . fe == NULL )  return - EIO ;  if ( dvb_attach ( ts2020_attach , d -> fe_adap [ 0 ] . fe ,  & dw2104_ts2020_config ,  & d -> dev -> i2c_adap ) ) {  info ( ""Attached<S2SV_blank>RS2000/TS2020!"" ) ; return 0 ; } info ( ""Failed<S2SV_blank>to<S2SV_blank>attach<S2SV_blank>RS2000/TS2020!"" ) ; return - EIO ; }","static int m88rs2000_frontend_attach ( struct dvb_usb_adapter * adap ) {struct dvb_usb_device * d = adap -> dev ;struct dw2102_state * state = d -> priv ;mutex_lock ( & d -> data_mutex ) ;state -> data [ 0 ] = 0x51 ;if ( dvb_usb_generic_rw ( d , state -> data , 1 , ibuf , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ;mutex_unlock ( & d -> data_mutex ) ;adap -> fe_adap [ 0 ] . fe = dvb_attach ( m88rs2000_attach , & s421_m88rs2000_config , & d -> i2c_adap ) ;if ( d -> fe_adap [ 0 ] . fe == NULL ) return - EIO ;if ( adap -> fe_adap [ 0 ] . fe , & dw2104_ts2020_config , & d -> i2c_adap ) ) {info ( ""Attached<S2SV_blank>RS2000/TS2020!"" ) ;",42
60,"buggy line: struct net * net = sock_net ( asoc -> base . sk ) ;bh_lock_sock ( asoc -> base . sk ) ;if ( sock_owned_by_user ( asoc -> base . sk ) ) {pr_debug ( ""%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy\\\if ( error )  asoc -> base . sk -> sk_err = - error ;out_unlock :  bh_unlock_sock ( asoc -> base . sk ) ;sctp_transport_put ( transport ) ;cwe id:CWE-362context: void sctp_generate_heartbeat_event ( unsigned long data ) { int error = 0 ; struct sctp_transport * transport = ( struct sctp_transport * ) data ; struct sctp_association * asoc = transport -> asoc ;  struct net * net = sock_net ( asoc -> base . sk ) ;   bh_lock_sock ( asoc -> base . sk ) ;   if ( sock_owned_by_user ( asoc -> base . sk ) ) {  pr_debug ( ""%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy\\n"" , __func__ ) ; if ( ! mod_timer ( & transport -> hb_timer , jiffies + ( HZ / 20 ) ) ) sctp_transport_hold ( transport ) ; goto out_unlock ; } if ( transport -> dead ) goto out_unlock ; error = sctp_do_sm ( net , SCTP_EVENT_T_TIMEOUT , SCTP_ST_TIMEOUT ( SCTP_EVENT_TIMEOUT_HEARTBEAT ) , asoc -> state , asoc -> ep , asoc , transport , GFP_ATOMIC ) ; if ( error )  asoc -> base . sk -> sk_err = - error ;  out_unlock :  bh_unlock_sock ( asoc -> base . sk ) ;  sctp_transport_put ( transport ) ; }","struct sock * sk = asoc -> base . sk ;struct net * net = sock_net ( sk ) ;bh_lock_sock ( asoc -> base . sk ) ;if ( sock_owned_by_user ( sk ) ) {pr_debug ( ""%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy\\\if ( error ) sk -> sk_err = - error ;out_unlock : bh_unlock_sock ( sk ) ;sctp_transport_put ( transport ) ;",43
61,"buggy line: if ( ! chart || ! * chart ) {buffer_sprintf ( w -> response . data , ""No<S2SV_blank>chart<S2SV_blank>id<S2SV_blank>is<S2SV_blank>given<S2SV_blank>at<S2SV_blank>the<S2SV_blank>request."" ) ;cwe id:CWE-200context: inline int web_client_api_request_v1_data ( RRDHOST * host , struct web_client * w , char * url ) { debug ( D_WEB_CLIENT , ""%llu:<S2SV_blank>API<S2SV_blank>v1<S2SV_blank>data<S2SV_blank>with<S2SV_blank>URL<S2SV_blank>\'%s\'"" , w -> id , url ) ; int ret = 400 ; BUFFER * dimensions = NULL ; buffer_flush ( w -> response . data ) ; char * google_version = ""0.6"" , * google_reqId = ""0"" , * google_sig = ""0"" , * google_out = ""json"" , * responseHandler = NULL , * outFileName = NULL ; time_t last_timestamp_in_data = 0 , google_timestamp = 0 ; char * chart = NULL , * before_str = NULL , * after_str = NULL , * group_time_str = NULL , * points_str = NULL ; int group = RRDR_GROUPING_AVERAGE ; uint32_t format = DATASOURCE_JSON ; uint32_t options = 0x00000000 ; while ( url ) { char * value = mystrsep ( & url , ""?&"" ) ; if ( ! value || ! * value ) continue ; char * name = mystrsep ( & value , ""="" ) ; if ( ! name || ! * name ) continue ; if ( ! value || ! * value ) continue ; debug ( D_WEB_CLIENT , ""%llu:<S2SV_blank>API<S2SV_blank>v1<S2SV_blank>data<S2SV_blank>query<S2SV_blank>param<S2SV_blank>\'%s\'<S2SV_blank>with<S2SV_blank>value<S2SV_blank>\'%s\'"" , w -> id , name , value ) ; if ( ! strcmp ( name , ""chart"" ) ) chart = value ; else if ( ! strcmp ( name , ""dimension"" ) || ! strcmp ( name , ""dim"" ) || ! strcmp ( name , ""dimensions"" ) || ! strcmp ( name , ""dims"" ) ) { if ( ! dimensions ) dimensions = buffer_create ( 100 ) ; buffer_strcat ( dimensions , ""|"" ) ; buffer_strcat ( dimensions , value ) ; } else if ( ! strcmp ( name , ""after"" ) ) after_str = value ; else if ( ! strcmp ( name , ""before"" ) ) before_str = value ; else if ( ! strcmp ( name , ""points"" ) ) points_str = value ; else if ( ! strcmp ( name , ""gtime"" ) ) group_time_str = value ; else if ( ! strcmp ( name , ""group"" ) ) { group = web_client_api_request_v1_data_group ( value , RRDR_GROUPING_AVERAGE ) ; } else if ( ! strcmp ( name , ""format"" ) ) { format = web_client_api_request_v1_data_format ( value ) ; } else if ( ! strcmp ( name , ""options"" ) ) { options |= web_client_api_request_v1_data_options ( value ) ; } else if ( ! strcmp ( name , ""callback"" ) ) { responseHandler = value ; } else if ( ! strcmp ( name , ""filename"" ) ) { outFileName = value ; } else if ( ! strcmp ( name , ""tqx"" ) ) { char * tqx_name , * tqx_value ; while ( value ) { tqx_value = mystrsep ( & value , "";"" ) ; if ( ! tqx_value || ! * tqx_value ) continue ; tqx_name = mystrsep ( & tqx_value , "":"" ) ; if ( ! tqx_name || ! * tqx_name ) continue ; if ( ! tqx_value || ! * tqx_value ) continue ; if ( ! strcmp ( tqx_name , ""version"" ) ) google_version = tqx_value ; else if ( ! strcmp ( tqx_name , ""reqId"" ) ) google_reqId = tqx_value ; else if ( ! strcmp ( tqx_name , ""sig"" ) ) { google_sig = tqx_value ; google_timestamp = strtoul ( google_sig , NULL , 0 ) ; } else if ( ! strcmp ( tqx_name , ""out"" ) ) { google_out = tqx_value ; format = web_client_api_request_v1_data_google_format ( google_out ) ; } else if ( ! strcmp ( tqx_name , ""responseHandler"" ) ) responseHandler = tqx_value ; else if ( ! strcmp ( tqx_name , ""outFileName"" ) ) outFileName = tqx_value ; } } }  if ( ! chart || ! * chart ) {  buffer_sprintf ( w -> response . data , ""No<S2SV_blank>chart<S2SV_blank>id<S2SV_blank>is<S2SV_blank>given<S2SV_blank>at<S2SV_blank>the<S2SV_blank>request."" ) ; goto cleanup ; } RRDSET * st = rrdset_find ( host , chart ) ; if ( ! st ) st = rrdset_find_byname ( host , chart ) ; if ( ! st ) { buffer_strcat ( w -> response . data , ""Chart<S2SV_blank>is<S2SV_blank>not<S2SV_blank>found:<S2SV_blank>"" ) ; buffer_strcat_htmlescape ( w -> response . data , chart ) ; ret = 404 ; goto cleanup ; } st -> last_accessed_time = now_realtime_sec ( ) ; long long before = ( before_str && * before_str ) ? str2l ( before_str ) : 0 ; long long after = ( after_str && * after_str ) ? str2l ( after_str ) : 0 ; int points = ( points_str && * points_str ) ? str2i ( points_str ) : 0 ; long group_time = ( group_time_str && * group_time_str ) ? str2l ( group_time_str ) : 0 ; debug ( D_WEB_CLIENT , ""%llu:<S2SV_blank>API<S2SV_blank>command<S2SV_blank>\'data\'<S2SV_blank>for<S2SV_blank>chart<S2SV_blank>\'%s\',<S2SV_blank>dimensions<S2SV_blank>\'%s\',<S2SV_blank>after<S2SV_blank>\'%lld\',<S2SV_blank>before<S2SV_blank>\'%lld\',<S2SV_blank>points<S2SV_blank>\'%d\',<S2SV_blank>group<S2SV_blank>\'%d\',<S2SV_blank>format<S2SV_blank>\'%u\',<S2SV_blank>options<S2SV_blank>\'0x%08x\'"" , w -> id , chart , ( dimensions ) ? buffer_tostring ( dimensions ) : """" , after , before , points , group , format , options ) ; if ( outFileName && * outFileName ) { buffer_sprintf ( w -> response . header , ""Content-Disposition:<S2SV_blank>attachment;<S2SV_blank>filename=\\""%s\\""\\r\\n"" , outFileName ) ; debug ( D_WEB_CLIENT , ""%llu:<S2SV_blank>generating<S2SV_blank>outfilename<S2SV_blank>header:<S2SV_blank>\'%s\'"" , w -> id , outFileName ) ; } if ( format == DATASOURCE_DATATABLE_JSONP ) { if ( responseHandler == NULL ) responseHandler = ""google.visualization.Query.setResponse"" ; debug ( D_WEB_CLIENT_ACCESS , ""%llu:<S2SV_blank>GOOGLE<S2SV_blank>JSON/JSONP:<S2SV_blank>version<S2SV_blank>=<S2SV_blank>\'%s\',<S2SV_blank>reqId<S2SV_blank>=<S2SV_blank>\'%s\',<S2SV_blank>sig<S2SV_blank>=<S2SV_blank>\'%s\',<S2SV_blank>out<S2SV_blank>=<S2SV_blank>\'%s\',<S2SV_blank>responseHandler<S2SV_blank>=<S2SV_blank>\'%s\',<S2SV_blank>outFileName<S2SV_blank>=<S2SV_blank>\'%s\'"" , w -> id , google_version , google_reqId , google_sig , google_out , responseHandler , outFileName ) ; buffer_sprintf ( w -> response . data , ""%s({version:\'%s\',reqId:\'%s\',status:\'ok\',sig:\'%ld\',table:"" , responseHandler , google_version , google_reqId , st -> last_updated . tv_sec ) ; } else if ( format == DATASOURCE_JSONP ) { if ( responseHandler == NULL ) responseHandler = ""callback"" ; buffer_strcat ( w -> response . data , responseHandler ) ; buffer_strcat ( w -> response . data , ""("" ) ; } ret = rrdset2anything_api_v1 ( st , w -> response . data , dimensions , format , points , after , before , group , group_time , options , & last_timestamp_in_data ) ; if ( format == DATASOURCE_DATATABLE_JSONP ) { if ( google_timestamp < last_timestamp_in_data ) buffer_strcat ( w -> response . data , ""});"" ) ; else { buffer_flush ( w -> response . data ) ; buffer_sprintf ( w -> response . data , ""%s({version:\'%s\',reqId:\'%s\',status:\'error\',errors:[{reason:\'not_modified\',message:\'Data<S2SV_blank>not<S2SV_blank>modified\'}]});"" , responseHandler , google_version , google_reqId ) ; } } else if ( format == DATASOURCE_JSONP ) buffer_strcat ( w -> response . data , "");"" ) ; cleanup : buffer_free ( dimensions ) ; return ret ; }","fix_google_param ( google_out ) ;fix_google_param ( google_sig ) ;fix_google_param ( google_reqId ) ;fix_google_param ( google_version ) ;fix_google_param ( responseHandler ) ;fix_google_param ( outFileName ) ;if ( ! chart || ! * chart ) {buffer_sprintf ( w -> response . data , ""No<S2SV_blank>chart<S2SV_blank>id<S2SV_blank>is<S2SV_blank>given<S2SV_blank>at<S2SV_blank>the<S2SV_blank>request."" ) ;",44
62,"buggy line: static void  horAcc8 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {assert ( ( cc % stride ) == 0 ) ;if ( cc > stride ) {cwe id:CWE-119context:  static void  horAcc8 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { tmsize_t stride = PredictorState ( tif ) -> stride ; unsigned char * cp = ( unsigned char * ) cp0 ;  assert ( ( cc % stride ) == 0 ) ;  if ( cc > stride ) { if ( stride == 3 ) { unsigned int cr = cp [ 0 ] ; unsigned int cg = cp [ 1 ] ; unsigned int cb = cp [ 2 ] ; cc -= 3 ; cp += 3 ; while ( cc > 0 ) { cp [ 0 ] = ( unsigned char ) ( ( cr += cp [ 0 ] ) & 0xff ) ; cp [ 1 ] = ( unsigned char ) ( ( cg += cp [ 1 ] ) & 0xff ) ; cp [ 2 ] = ( unsigned char ) ( ( cb += cp [ 2 ] ) & 0xff ) ; cc -= 3 ; cp += 3 ; } } else if ( stride == 4 ) { unsigned int cr = cp [ 0 ] ; unsigned int cg = cp [ 1 ] ; unsigned int cb = cp [ 2 ] ; unsigned int ca = cp [ 3 ] ; cc -= 4 ; cp += 4 ; while ( cc > 0 ) { cp [ 0 ] = ( unsigned char ) ( ( cr += cp [ 0 ] ) & 0xff ) ; cp [ 1 ] = ( unsigned char ) ( ( cg += cp [ 1 ] ) & 0xff ) ; cp [ 2 ] = ( unsigned char ) ( ( cb += cp [ 2 ] ) & 0xff ) ; cp [ 3 ] = ( unsigned char ) ( ( ca += cp [ 3 ] ) & 0xff ) ; cc -= 4 ; cp += 4 ; } } else { cc -= stride ; do { REPEAT4 ( stride , cp [ stride ] = ( unsigned char ) ( ( cp [ stride ] + * cp ) & 0xff ) ; cp ++ ) cc -= stride ; } while ( cc > 0 ) ; } }  } ","static int horAcc8 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {if ( ( cc % stride ) != 0 ) {TIFFErrorExt ( tif -> tif_clientdata , ""horAcc8"" , ""%s"" , ""(cc%stride)!=0"" ) ;return 0 ;}if ( cc > stride ) {",45
63,"buggy line: cwe id:CWE-119context:  static void  horAcc8 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { tmsize_t stride = PredictorState ( tif ) -> stride ; unsigned char * cp = ( unsigned char * ) cp0 ;  assert ( ( cc % stride ) == 0 ) ;  if ( cc > stride ) { if ( stride == 3 ) { unsigned int cr = cp [ 0 ] ; unsigned int cg = cp [ 1 ] ; unsigned int cb = cp [ 2 ] ; cc -= 3 ; cp += 3 ; while ( cc > 0 ) { cp [ 0 ] = ( unsigned char ) ( ( cr += cp [ 0 ] ) & 0xff ) ; cp [ 1 ] = ( unsigned char ) ( ( cg += cp [ 1 ] ) & 0xff ) ; cp [ 2 ] = ( unsigned char ) ( ( cb += cp [ 2 ] ) & 0xff ) ; cc -= 3 ; cp += 3 ; } } else if ( stride == 4 ) { unsigned int cr = cp [ 0 ] ; unsigned int cg = cp [ 1 ] ; unsigned int cb = cp [ 2 ] ; unsigned int ca = cp [ 3 ] ; cc -= 4 ; cp += 4 ; while ( cc > 0 ) { cp [ 0 ] = ( unsigned char ) ( ( cr += cp [ 0 ] ) & 0xff ) ; cp [ 1 ] = ( unsigned char ) ( ( cg += cp [ 1 ] ) & 0xff ) ; cp [ 2 ] = ( unsigned char ) ( ( cb += cp [ 2 ] ) & 0xff ) ; cp [ 3 ] = ( unsigned char ) ( ( ca += cp [ 3 ] ) & 0xff ) ; cc -= 4 ; cp += 4 ; } } else { cc -= stride ; do { REPEAT4 ( stride , cp [ stride ] = ( unsigned char ) ( ( cp [ stride ] + * cp ) & 0xff ) ; cp ++ ) cc -= stride ; } while ( cc > 0 ) ; } }  } ",return 1 ;,45
64,"buggy line: }cwe id:CWE-119context:  static void  horAcc8 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { tmsize_t stride = PredictorState ( tif ) -> stride ; unsigned char * cp = ( unsigned char * ) cp0 ;  assert ( ( cc % stride ) == 0 ) ;  if ( cc > stride ) { if ( stride == 3 ) { unsigned int cr = cp [ 0 ] ; unsigned int cg = cp [ 1 ] ; unsigned int cb = cp [ 2 ] ; cc -= 3 ; cp += 3 ; while ( cc > 0 ) { cp [ 0 ] = ( unsigned char ) ( ( cr += cp [ 0 ] ) & 0xff ) ; cp [ 1 ] = ( unsigned char ) ( ( cg += cp [ 1 ] ) & 0xff ) ; cp [ 2 ] = ( unsigned char ) ( ( cb += cp [ 2 ] ) & 0xff ) ; cc -= 3 ; cp += 3 ; } } else if ( stride == 4 ) { unsigned int cr = cp [ 0 ] ; unsigned int cg = cp [ 1 ] ; unsigned int cb = cp [ 2 ] ; unsigned int ca = cp [ 3 ] ; cc -= 4 ; cp += 4 ; while ( cc > 0 ) { cp [ 0 ] = ( unsigned char ) ( ( cr += cp [ 0 ] ) & 0xff ) ; cp [ 1 ] = ( unsigned char ) ( ( cg += cp [ 1 ] ) & 0xff ) ; cp [ 2 ] = ( unsigned char ) ( ( cb += cp [ 2 ] ) & 0xff ) ; cp [ 3 ] = ( unsigned char ) ( ( ca += cp [ 3 ] ) & 0xff ) ; cc -= 4 ; cp += 4 ; } } else { cc -= stride ; do { REPEAT4 ( stride , cp [ stride ] = ( unsigned char ) ( ( cp [ stride ] + * cp ) & 0xff ) ; cp ++ ) cc -= stride ; } while ( cc > 0 ) ; } }  } ",},45
65,"buggy line: inbuf = _TIFFmalloc ( scanlinesizein ) ;outbuf = _TIFFmalloc ( scanlinesizeout ) ;cwe id:CWE-119context: DECLAREcpFunc ( cpContig2SeparateByRow ) { tsize_t scanlinesizein = TIFFScanlineSize ( in ) ; tsize_t scanlinesizeout = TIFFScanlineSize ( out ) ; tdata_t inbuf ; tdata_t outbuf ; register uint8 * inp , * outp ; register uint32 n ; uint32 row ; tsample_t s ;  inbuf = _TIFFmalloc ( scanlinesizein ) ;  outbuf = _TIFFmalloc ( scanlinesizeout ) ; if ( ! inbuf || ! outbuf ) goto bad ; _TIFFmemset ( inbuf , 0 , scanlinesizein ) ; _TIFFmemset ( outbuf , 0 , scanlinesizeout ) ; for ( s = 0 ; s < spp ; s ++ ) { for ( row = 0 ; row < imagelength ; row ++ ) { if ( TIFFReadScanline ( in , inbuf , row , 0 ) < 0 && ! ignore ) { TIFFError ( TIFFFileName ( in ) , ""Error,<S2SV_blank>can\'t<S2SV_blank>read<S2SV_blank>scanline<S2SV_blank>%lu"" , ( unsigned long ) row ) ; goto bad ; } inp = ( ( uint8 * ) inbuf ) + s ; outp = ( uint8 * ) outbuf ; for ( n = imagewidth ; n -- > 0 ; ) { * outp ++ = * inp ; inp += spp ; } if ( TIFFWriteScanline ( out , outbuf , row , s ) < 0 ) { TIFFError ( TIFFFileName ( out ) , ""Error,<S2SV_blank>can\'t<S2SV_blank>write<S2SV_blank>scanline<S2SV_blank>%lu"" , ( unsigned long ) row ) ; goto bad ; } } } if ( inbuf ) _TIFFfree ( inbuf ) ; if ( outbuf ) _TIFFfree ( outbuf ) ; return 1 ; bad : if ( inbuf ) _TIFFfree ( inbuf ) ; if ( outbuf ) _TIFFfree ( outbuf ) ; return 0 ; }","uint16 bps = 0 ;( void ) TIFFGetField ( in , TIFFTAG_BITSPERSAMPLE , & bps ) ;if ( bps != 8 ) {TIFFError ( TIFFFileName ( in ) , ""Error,<S2SV_blank>can<S2SV_blank>only<S2SV_blank>handle<S2SV_blank>BitsPerSample=8<S2SV_blank>in<S2SV_blank>%s"" , ""cpContig2SeparateByRow"" ) ;return 0 ;}inbuf = _TIFFmalloc ( scanlinesizein ) ;outbuf = _TIFFmalloc ( scanlinesizeout ) ;",46
66,"buggy line: struct address_space * mapping ;mapping = ( struct address_space * ) page_private ( page ) ;if ( h -> surplus_huge_pages_node [ nid ] && huge_page_order ( h ) < MAX_ORDER ) {update_and_free_page ( h , page ) ;h -> surplus_huge_pages -- ;h -> surplus_huge_pages_node [ nid ] -- ;}else {enqueue_huge_page ( h , page ) ;}spin_unlock ( & hugetlb_lock ) ;if ( mapping )  hugetlb_put_quota ( mapping , 1 ) ;cwe id:CWE-399context: static void free_huge_page ( struct page * page ) { struct hstate * h = page_hstate ( page ) ; int nid = page_to_nid ( page ) ;  struct address_space * mapping ;  mapping = ( struct address_space * ) page_private ( page ) ; set_page_private ( page , 0 ) ; page -> mapping = NULL ; BUG_ON ( page_count ( page ) ) ; BUG_ON ( page_mapcount ( page ) ) ; INIT_LIST_HEAD ( & page -> lru ) ; spin_lock ( & hugetlb_lock ) ; if ( h -> surplus_huge_pages_node [ nid ] && huge_page_order ( h ) < MAX_ORDER ) { update_and_free_page ( h , page ) ; h -> surplus_huge_pages -- ; h -> surplus_huge_pages_node [ nid ] -- ; } else { enqueue_huge_page ( h , page ) ; } spin_unlock ( & hugetlb_lock ) ;  if ( mapping )  hugetlb_put_quota ( mapping , 1 ) ; }","struct hugepage_subpool * spool = ( struct hugepage_subpool * ) page_private ( page ) ;hugepage_subpool_put_pages ( spool , 1 ) ;",47
67,"buggy line: cwe id:CWE-835context: static int read_part_of_packet ( AVFormatContext * s , int64_t * pts , int * len , int * strid , int read_packet ) { AVIOContext * pb = s -> pb ; PVAContext * pvactx = s -> priv_data ; int syncword , streamid , reserved , flags , length , pts_flag ; int64_t pva_pts = AV_NOPTS_VALUE , startpos ; int ret ; recover : startpos = avio_tell ( pb ) ; syncword = avio_rb16 ( pb ) ; streamid = avio_r8 ( pb ) ; avio_r8 ( pb ) ; reserved = avio_r8 ( pb ) ; flags = avio_r8 ( pb ) ; length = avio_rb16 ( pb ) ; pts_flag = flags & 0x10 ; if ( syncword != PVA_MAGIC ) { pva_log ( s , AV_LOG_ERROR , ""invalid<S2SV_blank>syncword\\n"" ) ; return AVERROR ( EIO ) ; } if ( streamid != PVA_VIDEO_PAYLOAD && streamid != PVA_AUDIO_PAYLOAD ) { pva_log ( s , AV_LOG_ERROR , ""invalid<S2SV_blank>streamid\\n"" ) ; return AVERROR ( EIO ) ; } if ( reserved != 0x55 ) { pva_log ( s , AV_LOG_WARNING , ""expected<S2SV_blank>reserved<S2SV_blank>byte<S2SV_blank>to<S2SV_blank>be<S2SV_blank>0x55\\n"" ) ; } if ( length > PVA_MAX_PAYLOAD_LENGTH ) { pva_log ( s , AV_LOG_ERROR , ""invalid<S2SV_blank>payload<S2SV_blank>length<S2SV_blank>%u\\n"" , length ) ; return AVERROR ( EIO ) ; } if ( streamid == PVA_VIDEO_PAYLOAD && pts_flag ) { pva_pts = avio_rb32 ( pb ) ; length -= 4 ; } else if ( streamid == PVA_AUDIO_PAYLOAD ) { if ( ! pvactx -> continue_pes ) { int pes_signal , pes_header_data_length , pes_packet_length , pes_flags ; unsigned char pes_header_data [ 256 ] ; pes_signal = avio_rb24 ( pb ) ; avio_r8 ( pb ) ; pes_packet_length = avio_rb16 ( pb ) ; pes_flags = avio_rb16 ( pb ) ; pes_header_data_length = avio_r8 ( pb ) ;  if ( pes_signal != 1 || pes_header_data_length == 0 ) {  pva_log ( s , AV_LOG_WARNING , ""expected<S2SV_blank>non<S2SV_blank>empty<S2SV_blank>signaled<S2SV_blank>PES<S2SV_blank>packet,<S2SV_blank>"" ""trying<S2SV_blank>to<S2SV_blank>recover\\n"" ) ; avio_skip ( pb , length - 9 ) ; if ( ! read_packet ) return AVERROR ( EIO ) ; goto recover ; } ret = avio_read ( pb , pes_header_data , pes_header_data_length ) ; if ( ret != pes_header_data_length ) return ret < 0 ? ret : AVERROR_INVALIDDATA ; length -= 9 + pes_header_data_length ; pes_packet_length -= 3 + pes_header_data_length ; pvactx -> continue_pes = pes_packet_length ; if ( pes_flags & 0x80 && ( pes_header_data [ 0 ] & 0xf0 ) == 0x20 ) { if ( pes_header_data_length < 5 ) { pva_log ( s , AV_LOG_ERROR , ""header<S2SV_blank>too<S2SV_blank>short\\n"" ) ; avio_skip ( pb , length ) ; return AVERROR_INVALIDDATA ; } pva_pts = ff_parse_pes_pts ( pes_header_data ) ; } } pvactx -> continue_pes -= length ; if ( pvactx -> continue_pes < 0 ) { pva_log ( s , AV_LOG_WARNING , ""audio<S2SV_blank>data<S2SV_blank>corruption\\n"" ) ; pvactx -> continue_pes = 0 ; } } if ( pva_pts != AV_NOPTS_VALUE ) av_add_index_entry ( s -> streams [ streamid - 1 ] , startpos , pva_pts , 0 , 0 , AVINDEX_KEYFRAME ) ; * pts = pva_pts ; * len = length ; * strid = streamid ; return 0 ; }",if ( avio_feof ( pb ) ) {return AVERROR_EOF ;},48
68,"buggy line: if ( pes_signal != 1 || pes_header_data_length == 0 ) {pva_log ( s , AV_LOG_WARNING , ""expected<S2SV_blank>non<S2SV_blank>empty<S2SV_blank>signaled<S2SV_blank>PES<S2SV_blank>packet,<S2SV_blank>"" ""trying<S2SV_blank>to<S2SV_blank>recover\\\cwe id:CWE-835context: static int read_part_of_packet ( AVFormatContext * s , int64_t * pts , int * len , int * strid , int read_packet ) { AVIOContext * pb = s -> pb ; PVAContext * pvactx = s -> priv_data ; int syncword , streamid , reserved , flags , length , pts_flag ; int64_t pva_pts = AV_NOPTS_VALUE , startpos ; int ret ; recover : startpos = avio_tell ( pb ) ; syncword = avio_rb16 ( pb ) ; streamid = avio_r8 ( pb ) ; avio_r8 ( pb ) ; reserved = avio_r8 ( pb ) ; flags = avio_r8 ( pb ) ; length = avio_rb16 ( pb ) ; pts_flag = flags & 0x10 ; if ( syncword != PVA_MAGIC ) { pva_log ( s , AV_LOG_ERROR , ""invalid<S2SV_blank>syncword\\n"" ) ; return AVERROR ( EIO ) ; } if ( streamid != PVA_VIDEO_PAYLOAD && streamid != PVA_AUDIO_PAYLOAD ) { pva_log ( s , AV_LOG_ERROR , ""invalid<S2SV_blank>streamid\\n"" ) ; return AVERROR ( EIO ) ; } if ( reserved != 0x55 ) { pva_log ( s , AV_LOG_WARNING , ""expected<S2SV_blank>reserved<S2SV_blank>byte<S2SV_blank>to<S2SV_blank>be<S2SV_blank>0x55\\n"" ) ; } if ( length > PVA_MAX_PAYLOAD_LENGTH ) { pva_log ( s , AV_LOG_ERROR , ""invalid<S2SV_blank>payload<S2SV_blank>length<S2SV_blank>%u\\n"" , length ) ; return AVERROR ( EIO ) ; } if ( streamid == PVA_VIDEO_PAYLOAD && pts_flag ) { pva_pts = avio_rb32 ( pb ) ; length -= 4 ; } else if ( streamid == PVA_AUDIO_PAYLOAD ) { if ( ! pvactx -> continue_pes ) { int pes_signal , pes_header_data_length , pes_packet_length , pes_flags ; unsigned char pes_header_data [ 256 ] ; pes_signal = avio_rb24 ( pb ) ; avio_r8 ( pb ) ; pes_packet_length = avio_rb16 ( pb ) ; pes_flags = avio_rb16 ( pb ) ; pes_header_data_length = avio_r8 ( pb ) ;  if ( pes_signal != 1 || pes_header_data_length == 0 ) {  pva_log ( s , AV_LOG_WARNING , ""expected<S2SV_blank>non<S2SV_blank>empty<S2SV_blank>signaled<S2SV_blank>PES<S2SV_blank>packet,<S2SV_blank>"" ""trying<S2SV_blank>to<S2SV_blank>recover\\n"" ) ; avio_skip ( pb , length - 9 ) ; if ( ! read_packet ) return AVERROR ( EIO ) ; goto recover ; } ret = avio_read ( pb , pes_header_data , pes_header_data_length ) ; if ( ret != pes_header_data_length ) return ret < 0 ? ret : AVERROR_INVALIDDATA ; length -= 9 + pes_header_data_length ; pes_packet_length -= 3 + pes_header_data_length ; pvactx -> continue_pes = pes_packet_length ; if ( pes_flags & 0x80 && ( pes_header_data [ 0 ] & 0xf0 ) == 0x20 ) { if ( pes_header_data_length < 5 ) { pva_log ( s , AV_LOG_ERROR , ""header<S2SV_blank>too<S2SV_blank>short\\n"" ) ; avio_skip ( pb , length ) ; return AVERROR_INVALIDDATA ; } pva_pts = ff_parse_pes_pts ( pes_header_data ) ; } } pvactx -> continue_pes -= length ; if ( pvactx -> continue_pes < 0 ) { pva_log ( s , AV_LOG_WARNING , ""audio<S2SV_blank>data<S2SV_blank>corruption\\n"" ) ; pvactx -> continue_pes = 0 ; } } if ( pva_pts != AV_NOPTS_VALUE ) av_add_index_entry ( s -> streams [ streamid - 1 ] , startpos , pva_pts , 0 , 0 , AVINDEX_KEYFRAME ) ; * pts = pva_pts ; * len = length ; * strid = streamid ; return 0 ; }","if ( pes_signal != 1 || pes_header_data_length == 0 ) {pva_log ( s , AV_LOG_WARNING , ""expected<S2SV_blank>non<S2SV_blank>empty<S2SV_blank>signaled<S2SV_blank>PES<S2SV_blank>packet,<S2SV_blank>"" ""trying<S2SV_blank>to<S2SV_blank>recover\\\",48
69,"buggy line: if ( ! e || e == p )  goto not_found ;cwe id:CWE-119context: enum nss_status _nss_mymachines_getpwnam_r ( const char * name , struct passwd * pwd , char * buffer , size_t buflen , int * errnop ) { _cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL ; _cleanup_bus_message_unref_ sd_bus_message * reply = NULL ; _cleanup_bus_flush_close_unref_ sd_bus * bus = NULL ; const char * p , * e , * machine ; uint32_t mapped ; uid_t uid ; size_t l ; int r ; assert ( name ) ; assert ( pwd ) ; p = startswith ( name , ""vu-"" ) ; if ( ! p ) goto not_found ; e = strrchr ( p , '-' ) ;  if ( ! e || e == p )  goto not_found ; r = parse_uid ( e + 1 , & uid ) ; if ( r < 0 ) goto not_found ; machine = strndupa ( p , e - p ) ; if ( ! machine_name_is_valid ( machine ) ) goto not_found ; r = sd_bus_open_system ( & bus ) ; if ( r < 0 ) goto fail ; r = sd_bus_call_method ( bus , ""org.freedesktop.machine1"" , ""/org/freedesktop/machine1"" , ""org.freedesktop.machine1.Manager"" , ""MapFromMachineUser"" , & error , & reply , ""su"" , machine , ( uint32_t ) uid ) ; if ( r < 0 ) { if ( sd_bus_error_has_name ( & error , BUS_ERROR_NO_SUCH_USER_MAPPING ) ) goto not_found ; goto fail ; } r = sd_bus_message_read ( reply , ""u"" , & mapped ) ; if ( r < 0 ) goto fail ; l = strlen ( name ) ; if ( buflen < l + 1 ) { * errnop = ENOMEM ; return NSS_STATUS_TRYAGAIN ; } memcpy ( buffer , name , l + 1 ) ; pwd -> pw_name = buffer ; pwd -> pw_uid = mapped ; pwd -> pw_gid = 65534 ; pwd -> pw_gecos = buffer ; pwd -> pw_passwd = ( char * ) ""*"" ; pwd -> pw_dir = ( char * ) ""/"" ; pwd -> pw_shell = ( char * ) ""/sbin/nologin"" ; * errnop = 0 ; return NSS_STATUS_SUCCESS ; not_found : * errnop = 0 ; return NSS_STATUS_NOTFOUND ; fail : * errnop = - r ; return NSS_STATUS_UNAVAIL ; }",if ( ! e || e == p ) goto not_found ;if ( e - p > HOST_NAME_MAX - 1 ) goto not_found ;,49
70,"buggy line: void generic_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf )  {get_page ( buf -> page ) ;}cwe id:CWE-416context:  void generic_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf )  {  get_page ( buf -> page ) ;  }","bool generic_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) {return try_get_page ( buf -> page ) ;}",50
71,"buggy line: while ( cp < ep && cp < ep2 ) {if ( map && nmap ) {cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ,  map , nmap ) ;}else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ;}if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ;cwe id:CWE-125context: static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , ""<S2SV_blank>#%u<S2SV_blank>type=%s<S2SV_blank>id=%s<S2SV_blank>"" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , ""<S2SV_blank>#%u<S2SV_blank>type=%s<S2SV_blank>id=%u<S2SV_blank>"" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) {  cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ,  map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }","while ( cp < ep && cp < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ;",51
72,"buggy line: if ( ( ia_valid & ATTR_UID ) && ( ! uid_eq ( current_fsuid ( ) , inode -> i_uid ) || ! uid_eq ( attr -> ia_uid , inode -> i_uid ) ) &&  ! inode_capable ( inode , CAP_CHOWN ) )  return - EPERM ;if ( ( ia_valid & ATTR_GID ) && ( ! uid_eq ( current_fsuid ( ) , inode -> i_uid ) || ( ! in_group_p ( attr -> ia_gid ) && ! gid_eq ( attr -> ia_gid , inode -> i_gid ) ) ) &&  ! inode_capable ( inode , CAP_CHOWN ) )  return - EPERM ;if ( ! in_group_p ( ( ia_valid & ATTR_GID ) ? attr -> ia_gid : inode -> i_gid ) &&  ! inode_capable ( inode , CAP_FSETID ) )  attr -> ia_mode &= ~ S_ISGID ;cwe id:CWE-264context: int inode_change_ok ( const struct inode * inode , struct iattr * attr ) { unsigned int ia_valid = attr -> ia_valid ; if ( ia_valid & ATTR_SIZE ) { int error = inode_newsize_ok ( inode , attr -> ia_size ) ; if ( error ) return error ; } if ( ia_valid & ATTR_FORCE ) return 0 ; if ( ( ia_valid & ATTR_UID ) && ( ! uid_eq ( current_fsuid ( ) , inode -> i_uid ) || ! uid_eq ( attr -> ia_uid , inode -> i_uid ) ) &&  ! inode_capable ( inode , CAP_CHOWN ) )  return - EPERM ; if ( ( ia_valid & ATTR_GID ) && ( ! uid_eq ( current_fsuid ( ) , inode -> i_uid ) || ( ! in_group_p ( attr -> ia_gid ) && ! gid_eq ( attr -> ia_gid , inode -> i_gid ) ) ) &&  ! inode_capable ( inode , CAP_CHOWN ) )  return - EPERM ; if ( ia_valid & ATTR_MODE ) { if ( ! inode_owner_or_capable ( inode ) ) return - EPERM ; if ( ! in_group_p ( ( ia_valid & ATTR_GID ) ? attr -> ia_gid : inode -> i_gid ) &&  ! inode_capable ( inode , CAP_FSETID ) )  attr -> ia_mode &= ~ S_ISGID ; } if ( ia_valid & ( ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET ) ) { if ( ! inode_owner_or_capable ( inode ) ) return - EPERM ; } return 0 ; }","if ( ( ia_valid & ATTR_UID ) && ( ! uid_eq ( current_fsuid ( ) , inode -> i_uid ) || ! uid_eq ( attr -> ia_uid , inode -> i_uid ) ) && ! capable_wrt_inode_uidgid ( inode , CAP_CHOWN ) ) return - EPERM ;if ( ( ia_valid & ATTR_GID ) && ( ! uid_eq ( current_fsuid ( ) , inode -> i_uid ) || ( ! in_group_p ( attr -> ia_gid ) && ! capable_wrt_inode_uidgid ( inode , CAP_CHOWN ) ) return - EPERM ;if ( ! in_group_p ( ( ia_valid & ATTR_GID ) ? attr -> ia_gid : inode -> i_gid ) && ! capable_wrt_inode_uidgid ( inode , CAP_FSETID ) ) attr -> ia_mode &= ~ S_ISGID ;",52
73,"buggy line: timeout . tv_usec = 0 ;select ( reader -> bytes_available_fd + 1 , & read_fds , NULL , NULL , & timeout ) ;return FD_ISSET ( reader -> bytes_available_fd , & read_fds ) ;cwe id:CWE-284context: static bool has_byte ( const eager_reader_t * reader ) { assert ( reader != NULL ) ; fd_set read_fds ; FD_ZERO ( & read_fds ) ; FD_SET ( reader -> bytes_available_fd , & read_fds ) ; struct timeval timeout ; timeout . tv_sec = 0 ; timeout . tv_usec = 0 ;  select ( reader -> bytes_available_fd + 1 , & read_fds , NULL , NULL , & timeout ) ;  return FD_ISSET ( reader -> bytes_available_fd , & read_fds ) ; }","TEMP_FAILURE_RETRY ( timeout . tv_usec = 0 ;select ( reader -> bytes_available_fd + 1 , & read_fds , NULL , NULL , & timeout ) ) ;return FD_ISSET ( reader -> bytes_available_fd , & read_fds ) ;",53
74,"buggy line: fpm_globals . max_requests = wp -> config -> pm_max_requests ;if ( 0 > fpm_stdio_init_child ( wp ) || 0 > fpm_log_init_child ( wp ) || 0 > fpm_status_init_child ( wp ) || 0 > fpm_unix_init_child ( wp ) || 0 > fpm_signals_init_child ( ) || 0 > fpm_env_init_child ( wp ) || 0 > fpm_php_init_child ( wp ) ) {cwe id:CWE-400context: static void fpm_child_init ( struct fpm_worker_pool_s * wp ) {  fpm_globals . max_requests = wp -> config -> pm_max_requests ;  if ( 0 > fpm_stdio_init_child ( wp ) || 0 > fpm_log_init_child ( wp ) || 0 > fpm_status_init_child ( wp ) || 0 > fpm_unix_init_child ( wp ) || 0 > fpm_signals_init_child ( ) || 0 > fpm_env_init_child ( wp ) || 0 > fpm_php_init_child ( wp ) ) { zlog ( ZLOG_ERROR , ""[pool<S2SV_blank>%s]<S2SV_blank>child<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>initialize"" , wp -> config -> name ) ; exit ( FPM_EXIT_SOFTWARE ) ; } }",fpm_globals . max_requests = wp -> config -> pm_max_requests ;fpm_globals . listening_socket = dup ( wp -> listening_socket ) ;if ( 0 > fpm_stdio_init_child ( wp ) || 0 > fpm_log_init_child ( wp ) || 0 > fpm_status_init_child ( wp ) || 0 > fpm_unix_init_child ( wp ) || 0 > fpm_signals_init_child ( ) || 0 > fpm_env_init_child ( wp ) || 0 > fpm_php_init_child ( wp ) ) {,54
75,"buggy line: static int detect_transition_to_still ( struct twopass_rc * twopass ,  int frame_interval , int still_interval , double loop_decay_rate , double last_decay_rate ) {int trans_to_still = 0 ;if ( frame_interval > MIN_GF_INTERVAL &&  loop_decay_rate >= 0.999 && last_decay_rate < 0.9 ) {const FIRSTPASS_STATS * position = twopass -> stats_in ;FIRSTPASS_STATS tmp_next_frame ;if ( EOF == input_stats ( twopass , & tmp_next_frame ) )  break ;if ( tmp_next_frame . pcnt_inter - tmp_next_frame . pcnt_motion < 0.999 )  break ;reset_fpf_position ( twopass , position ) ;if ( j == still_interval )  trans_to_still = 1 ;return trans_to_still ;}cwe id:CWE-119context:  static int detect_transition_to_still ( struct twopass_rc * twopass ,  int frame_interval , int still_interval , double loop_decay_rate , double last_decay_rate ) {  int trans_to_still = 0 ;   if ( frame_interval > MIN_GF_INTERVAL &&  loop_decay_rate >= 0.999 && last_decay_rate < 0.9 ) { int j ;  const FIRSTPASS_STATS * position = twopass -> stats_in ;  FIRSTPASS_STATS tmp_next_frame ; for ( j = 0 ; j < still_interval ; ++ j ) {  if ( EOF == input_stats ( twopass , & tmp_next_frame ) )  break ;  if ( tmp_next_frame . pcnt_inter - tmp_next_frame . pcnt_motion < 0.999 )  break ; }  reset_fpf_position ( twopass , position ) ;   if ( j == still_interval )  trans_to_still = 1 ; }  return trans_to_still ;  }","static int detect_transition_to_still ( VP9_COMP * cpi , int frame_interval , int still_interval , double loop_decay_rate , double last_decay_rate ) {TWO_PASS * const twopass = & cpi -> twopass ;RATE_CONTROL * const rc = & cpi -> rc ;if ( frame_interval > rc -> min_gf_interval && loop_decay_rate >= 0.999 && last_decay_rate < 0.9 ) {if ( EOF == input_stats ( twopass , & tmp_next_frame ) ) break ;if ( stats -> pcnt_inter - stats -> pcnt_motion < 0.999 ) break ;return j == still_interval ) trans_to_still = 1 ;}return 0 ;",55
76,"buggy line: if ( ! handle -> h_transaction ) {err = jbd2_journal_stop ( handle ) ;return handle -> h_err ? handle -> h_err : err ;}sb = handle -> h_transaction -> t_journal -> j_private ;err = handle -> h_err ;cwe id:CWE-416context: int __ext4_journal_stop ( const char * where , unsigned int line , handle_t * handle ) { struct super_block * sb ; int err ; int rc ; if ( ! ext4_handle_valid ( handle ) ) { ext4_put_nojournal ( handle ) ; return 0 ; }  if ( ! handle -> h_transaction ) {   err = jbd2_journal_stop ( handle ) ;   return handle -> h_err ? handle -> h_err : err ;  }  sb = handle -> h_transaction -> t_journal -> j_private ;  err = handle -> h_err ; rc = jbd2_journal_stop ( handle ) ; if ( ! err ) err = rc ; if ( err ) __ext4_std_error ( sb , where , line , err ) ; return err ; }",err = handle -> h_err ;if ( ! handle -> h_transaction ) {rc = jbd2_journal_stop ( handle ) ;return err ? err : rc ;}sb = handle -> h_transaction -> t_journal -> j_private ;,56
77,"buggy line: if ( io -> flag != EXT4_IO_UNWRITTEN ) return ret ;if ( offset + size <= i_size_read ( inode ) )  ret = ext4_convert_unwritten_extents ( inode , offset , size ) ;cwe id:CWE-000context: static int ext4_end_io_nolock ( ext4_io_end_t * io ) { struct inode * inode = io -> inode ; loff_t offset = io -> offset ; ssize_t size = io -> size ; int ret = 0 ; ext4_debug ( ""ext4_end_io_nolock:<S2SV_blank>io<S2SV_blank>0x%p<S2SV_blank>from<S2SV_blank>inode<S2SV_blank>%lu,list->next<S2SV_blank>0x%p,"" ""list->prev<S2SV_blank>0x%p\\n"" , io , inode -> i_ino , io -> list . next , io -> list . prev ) ; if ( list_empty ( & io -> list ) ) return ret ; if ( io -> flag != EXT4_IO_UNWRITTEN ) return ret ;  if ( offset + size <= i_size_read ( inode ) )  ret = ext4_convert_unwritten_extents ( inode , offset , size ) ; if ( ret < 0 ) { printk ( KERN_EMERG ""%s:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>convert<S2SV_blank>unwritten"" ""extents<S2SV_blank>to<S2SV_blank>written<S2SV_blank>extents,<S2SV_blank>error<S2SV_blank>is<S2SV_blank>%d"" ""<S2SV_blank>io<S2SV_blank>is<S2SV_blank>still<S2SV_blank>on<S2SV_blank>inode<S2SV_blank>%lu<S2SV_blank>aio<S2SV_blank>dio<S2SV_blank>list\\n"" , __func__ , ret , inode -> i_ino ) ; return ret ; } io -> flag = 0 ; return ret ; }","ret = ext4_convert_unwritten_extents ( inode , offset , size ) ;",57
78,"buggy line: cwe id:CWE-19context: STATIC int xfs_attr3_leaf_add_work ( struct xfs_buf * bp , struct xfs_attr3_icleaf_hdr * ichdr , struct xfs_da_args * args , int mapindex ) { struct xfs_attr_leafblock * leaf ; struct xfs_attr_leaf_entry * entry ; struct xfs_attr_leaf_name_local * name_loc ; struct xfs_attr_leaf_name_remote * name_rmt ; struct xfs_mount * mp ; int tmp ; int i ; trace_xfs_attr_leaf_add_work ( args ) ; leaf = bp -> b_addr ; ASSERT ( mapindex >= 0 && mapindex < XFS_ATTR_LEAF_MAPSIZE ) ; ASSERT ( args -> index >= 0 && args -> index <= ichdr -> count ) ; entry = & xfs_attr3_leaf_entryp ( leaf ) [ args -> index ] ; if ( args -> index < ichdr -> count ) { tmp = ichdr -> count - args -> index ; tmp *= sizeof ( xfs_attr_leaf_entry_t ) ; memmove ( entry + 1 , entry , tmp ) ; xfs_trans_log_buf ( args -> trans , bp , XFS_DA_LOGRANGE ( leaf , entry , tmp + sizeof ( * entry ) ) ) ; } ichdr -> count ++ ; mp = args -> trans -> t_mountp ; ASSERT ( ichdr -> freemap [ mapindex ] . base < XFS_LBSIZE ( mp ) ) ; ASSERT ( ( ichdr -> freemap [ mapindex ] . base & 0x3 ) == 0 ) ; ASSERT ( ichdr -> freemap [ mapindex ] . size >= xfs_attr_leaf_newentsize ( args -> namelen , args -> valuelen , mp -> m_sb . sb_blocksize , NULL ) ) ; ASSERT ( ichdr -> freemap [ mapindex ] . size < XFS_LBSIZE ( mp ) ) ; ASSERT ( ( ichdr -> freemap [ mapindex ] . size & 0x3 ) == 0 ) ; ichdr -> freemap [ mapindex ] . size -= xfs_attr_leaf_newentsize ( args -> namelen , args -> valuelen , mp -> m_sb . sb_blocksize , & tmp ) ; entry -> nameidx = cpu_to_be16 ( ichdr -> freemap [ mapindex ] . base + ichdr -> freemap [ mapindex ] . size ) ; entry -> hashval = cpu_to_be32 ( args -> hashval ) ; entry -> flags = tmp ? XFS_ATTR_LOCAL : 0 ; entry -> flags |= XFS_ATTR_NSP_ARGS_TO_ONDISK ( args -> flags ) ; if ( args -> op_flags & XFS_DA_OP_RENAME ) { entry -> flags |= XFS_ATTR_INCOMPLETE ; if ( ( args -> blkno2 == args -> blkno ) && ( args -> index2 <= args -> index ) ) { args -> index2 ++ ; } } xfs_trans_log_buf ( args -> trans , bp , XFS_DA_LOGRANGE ( leaf , entry , sizeof ( * entry ) ) ) ; ASSERT ( ( args -> index == 0 ) || ( be32_to_cpu ( entry -> hashval ) >= be32_to_cpu ( ( entry - 1 ) -> hashval ) ) ) ; ASSERT ( ( args -> index == ichdr -> count - 1 ) || ( be32_to_cpu ( entry -> hashval ) <= be32_to_cpu ( ( entry + 1 ) -> hashval ) ) ) ; if ( entry -> flags & XFS_ATTR_LOCAL ) { name_loc = xfs_attr3_leaf_name_local ( leaf , args -> index ) ; name_loc -> namelen = args -> namelen ; name_loc -> valuelen = cpu_to_be16 ( args -> valuelen ) ; memcpy ( ( char * ) name_loc -> nameval , args -> name , args -> namelen ) ; memcpy ( ( char * ) & name_loc -> nameval [ args -> namelen ] , args -> value , be16_to_cpu ( name_loc -> valuelen ) ) ; } else { name_rmt = xfs_attr3_leaf_name_remote ( leaf , args -> index ) ; name_rmt -> namelen = args -> namelen ; memcpy ( ( char * ) name_rmt -> name , args -> name , args -> namelen ) ; entry -> flags |= XFS_ATTR_INCOMPLETE ; name_rmt -> valuelen = 0 ; name_rmt -> valueblk = 0 ; args -> rmtblkno = 1 ; args -> rmtblkcnt = xfs_attr3_rmt_blocks ( mp , args -> valuelen ) ;  }  xfs_trans_log_buf ( args -> trans , bp , XFS_DA_LOGRANGE ( leaf , xfs_attr3_leaf_name ( leaf , args -> index ) , xfs_attr_leaf_entsize ( leaf , args -> index ) ) ) ; if ( be16_to_cpu ( entry -> nameidx ) < ichdr -> firstused ) ichdr -> firstused = be16_to_cpu ( entry -> nameidx ) ; ASSERT ( ichdr -> firstused >= ichdr -> count * sizeof ( xfs_attr_leaf_entry_t ) + xfs_attr3_leaf_hdr_size ( leaf ) ) ; tmp = ( ichdr -> count - 1 ) * sizeof ( xfs_attr_leaf_entry_t ) + xfs_attr3_leaf_hdr_size ( leaf ) ; for ( i = 0 ; i < XFS_ATTR_LEAF_MAPSIZE ; i ++ ) { if ( ichdr -> freemap [ i ] . base == tmp ) { ichdr -> freemap [ i ] . base += sizeof ( xfs_attr_leaf_entry_t ) ; ichdr -> freemap [ i ] . size -= sizeof ( xfs_attr_leaf_entry_t ) ; } } ichdr -> usedbytes += xfs_attr_leaf_entsize ( leaf , args -> index ) ; return 0 ; }",args -> rmtvaluelen = args -> valuelen ;,58
79,"buggy line: }xfs_trans_log_buf ( args -> trans , bp , XFS_DA_LOGRANGE ( leaf , xfs_attr3_leaf_name ( leaf , args -> index ) , xfs_attr_leaf_entsize ( leaf , args -> index ) ) ) ;cwe id:CWE-19context: STATIC int xfs_attr3_leaf_add_work ( struct xfs_buf * bp , struct xfs_attr3_icleaf_hdr * ichdr , struct xfs_da_args * args , int mapindex ) { struct xfs_attr_leafblock * leaf ; struct xfs_attr_leaf_entry * entry ; struct xfs_attr_leaf_name_local * name_loc ; struct xfs_attr_leaf_name_remote * name_rmt ; struct xfs_mount * mp ; int tmp ; int i ; trace_xfs_attr_leaf_add_work ( args ) ; leaf = bp -> b_addr ; ASSERT ( mapindex >= 0 && mapindex < XFS_ATTR_LEAF_MAPSIZE ) ; ASSERT ( args -> index >= 0 && args -> index <= ichdr -> count ) ; entry = & xfs_attr3_leaf_entryp ( leaf ) [ args -> index ] ; if ( args -> index < ichdr -> count ) { tmp = ichdr -> count - args -> index ; tmp *= sizeof ( xfs_attr_leaf_entry_t ) ; memmove ( entry + 1 , entry , tmp ) ; xfs_trans_log_buf ( args -> trans , bp , XFS_DA_LOGRANGE ( leaf , entry , tmp + sizeof ( * entry ) ) ) ; } ichdr -> count ++ ; mp = args -> trans -> t_mountp ; ASSERT ( ichdr -> freemap [ mapindex ] . base < XFS_LBSIZE ( mp ) ) ; ASSERT ( ( ichdr -> freemap [ mapindex ] . base & 0x3 ) == 0 ) ; ASSERT ( ichdr -> freemap [ mapindex ] . size >= xfs_attr_leaf_newentsize ( args -> namelen , args -> valuelen , mp -> m_sb . sb_blocksize , NULL ) ) ; ASSERT ( ichdr -> freemap [ mapindex ] . size < XFS_LBSIZE ( mp ) ) ; ASSERT ( ( ichdr -> freemap [ mapindex ] . size & 0x3 ) == 0 ) ; ichdr -> freemap [ mapindex ] . size -= xfs_attr_leaf_newentsize ( args -> namelen , args -> valuelen , mp -> m_sb . sb_blocksize , & tmp ) ; entry -> nameidx = cpu_to_be16 ( ichdr -> freemap [ mapindex ] . base + ichdr -> freemap [ mapindex ] . size ) ; entry -> hashval = cpu_to_be32 ( args -> hashval ) ; entry -> flags = tmp ? XFS_ATTR_LOCAL : 0 ; entry -> flags |= XFS_ATTR_NSP_ARGS_TO_ONDISK ( args -> flags ) ; if ( args -> op_flags & XFS_DA_OP_RENAME ) { entry -> flags |= XFS_ATTR_INCOMPLETE ; if ( ( args -> blkno2 == args -> blkno ) && ( args -> index2 <= args -> index ) ) { args -> index2 ++ ; } } xfs_trans_log_buf ( args -> trans , bp , XFS_DA_LOGRANGE ( leaf , entry , sizeof ( * entry ) ) ) ; ASSERT ( ( args -> index == 0 ) || ( be32_to_cpu ( entry -> hashval ) >= be32_to_cpu ( ( entry - 1 ) -> hashval ) ) ) ; ASSERT ( ( args -> index == ichdr -> count - 1 ) || ( be32_to_cpu ( entry -> hashval ) <= be32_to_cpu ( ( entry + 1 ) -> hashval ) ) ) ; if ( entry -> flags & XFS_ATTR_LOCAL ) { name_loc = xfs_attr3_leaf_name_local ( leaf , args -> index ) ; name_loc -> namelen = args -> namelen ; name_loc -> valuelen = cpu_to_be16 ( args -> valuelen ) ; memcpy ( ( char * ) name_loc -> nameval , args -> name , args -> namelen ) ; memcpy ( ( char * ) & name_loc -> nameval [ args -> namelen ] , args -> value , be16_to_cpu ( name_loc -> valuelen ) ) ; } else { name_rmt = xfs_attr3_leaf_name_remote ( leaf , args -> index ) ; name_rmt -> namelen = args -> namelen ; memcpy ( ( char * ) name_rmt -> name , args -> name , args -> namelen ) ; entry -> flags |= XFS_ATTR_INCOMPLETE ; name_rmt -> valuelen = 0 ; name_rmt -> valueblk = 0 ; args -> rmtblkno = 1 ; args -> rmtblkcnt = xfs_attr3_rmt_blocks ( mp , args -> valuelen ) ;  }  xfs_trans_log_buf ( args -> trans , bp , XFS_DA_LOGRANGE ( leaf , xfs_attr3_leaf_name ( leaf , args -> index ) , xfs_attr_leaf_entsize ( leaf , args -> index ) ) ) ; if ( be16_to_cpu ( entry -> nameidx ) < ichdr -> firstused ) ichdr -> firstused = be16_to_cpu ( entry -> nameidx ) ; ASSERT ( ichdr -> firstused >= ichdr -> count * sizeof ( xfs_attr_leaf_entry_t ) + xfs_attr3_leaf_hdr_size ( leaf ) ) ; tmp = ( ichdr -> count - 1 ) * sizeof ( xfs_attr_leaf_entry_t ) + xfs_attr3_leaf_hdr_size ( leaf ) ; for ( i = 0 ; i < XFS_ATTR_LEAF_MAPSIZE ; i ++ ) { if ( ichdr -> freemap [ i ] . base == tmp ) { ichdr -> freemap [ i ] . base += sizeof ( xfs_attr_leaf_entry_t ) ; ichdr -> freemap [ i ] . size -= sizeof ( xfs_attr_leaf_entry_t ) ; } } ichdr -> usedbytes += xfs_attr_leaf_entsize ( leaf , args -> index ) ; return 0 ; }","}xfs_trans_log_buf ( args -> trans , bp , XFS_DA_LOGRANGE ( leaf , xfs_attr3_leaf_name ( leaf , args -> index ) , xfs_attr_leaf_entsize ( leaf , args -> index ) ) ) ;",58
80,"buggy line: request_module ( ""%s"" , name ) ;if ( ! ( ( type ^ CRYPTO_ALG_NEED_FALLBACK ) & mask & CRYPTO_ALG_NEED_FALLBACK ) )  request_module ( ""%s-all"" , name ) ;alg = crypto_alg_lookup ( name , type , mask ) ;cwe id:CWE-269context: struct crypto_alg * crypto_larval_lookup ( const char * name , u32 type , u32 mask ) { struct crypto_alg * alg ; if ( ! name ) return ERR_PTR ( - ENOENT ) ; mask &= ~ ( CRYPTO_ALG_LARVAL | CRYPTO_ALG_DEAD ) ; type &= mask ; alg = crypto_alg_lookup ( name , type , mask ) ; if ( ! alg ) {  request_module ( ""%s"" , name ) ;  if ( ! ( ( type ^ CRYPTO_ALG_NEED_FALLBACK ) & mask & CRYPTO_ALG_NEED_FALLBACK ) )  request_module ( ""%s-all"" , name ) ;  alg = crypto_alg_lookup ( name , type , mask ) ; } if ( alg ) return crypto_is_larval ( alg ) ? crypto_larval_wait ( alg ) : alg ; return crypto_larval_add ( name , type , mask ) ; }","request_module ( ""crypto-%s"" , name ) ;if ( ! ( ( type ^ CRYPTO_ALG_NEED_FALLBACK ) & mask & CRYPTO_ALG_NEED_FALLBACK ) ) request_module ( ""crypto-%s-all"" , name ) ;alg = crypto_alg_lookup ( name , type , mask ) ;",59
81,"buggy line: stlv_type = * ( tptr ++ ) ;stlv_len = * ( tptr ++ ) ;len = len - 2 ;switch ( stlv_type ) {case ISIS_SUBTLV_SPB_INSTANCE :  ND_TCHECK2 ( * tptr , ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ) ;ND_PRINT ( ( ndo , ""\\\cwe id:CWE-125context: static int isis_print_mt_capability_subtlv ( netdissect_options * ndo , const uint8_t * tptr , int len ) { int stlv_type , stlv_len , tmp ; while ( len > 2 ) {  stlv_type = * ( tptr ++ ) ;  stlv_len = * ( tptr ++ ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>subTLV<S2SV_blank>#%u,<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( isis_mt_capability_subtlv_values , ""unknown"" , stlv_type ) , stlv_type , stlv_len ) ) ;  len = len - 2 ;  switch ( stlv_type ) { case ISIS_SUBTLV_SPB_INSTANCE :  ND_TCHECK2 ( * tptr , ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ) ;  ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>CIST<S2SV_blank>Root-ID:<S2SV_blank>%08x"" , EXTRACT_32BITS ( tptr ) ) ) ; tptr = tptr + 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>%08x"" , EXTRACT_32BITS ( tptr ) ) ) ; tptr = tptr + 4 ; ND_PRINT ( ( ndo , "",<S2SV_blank>Path<S2SV_blank>Cost:<S2SV_blank>%08x"" , EXTRACT_32BITS ( tptr ) ) ) ; tptr = tptr + 4 ; ND_PRINT ( ( ndo , "",<S2SV_blank>Prio:<S2SV_blank>%d"" , EXTRACT_16BITS ( tptr ) ) ) ; tptr = tptr + 2 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>RES:<S2SV_blank>%d"" , EXTRACT_16BITS ( tptr ) >> 5 ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>V:<S2SV_blank>%d"" , ( EXTRACT_16BITS ( tptr ) >> 4 ) & 0x0001 ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>SPSource-ID:<S2SV_blank>%d"" , ( EXTRACT_32BITS ( tptr ) & 0x000fffff ) ) ) ; tptr = tptr + 4 ; ND_PRINT ( ( ndo , "",<S2SV_blank>No<S2SV_blank>of<S2SV_blank>Trees:<S2SV_blank>%x"" , * ( tptr ) ) ) ; tmp = * ( tptr ++ ) ; len = len - ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ;  while ( tmp )  {  ND_TCHECK2 ( * tptr , ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ) ;  ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>U:%d,<S2SV_blank>M:%d,<S2SV_blank>A:%d,<S2SV_blank>RES:%d"" , * ( tptr ) >> 7 , ( * ( tptr ) >> 6 ) & 0x01 , ( * ( tptr ) >> 5 ) & 0x01 , ( * ( tptr ) & 0x1f ) ) ) ; tptr ++ ; ND_PRINT ( ( ndo , "",<S2SV_blank>ECT:<S2SV_blank>%08x"" , EXTRACT_32BITS ( tptr ) ) ) ; tptr = tptr + 4 ; ND_PRINT ( ( ndo , "",<S2SV_blank>BVID:<S2SV_blank>%d,<S2SV_blank>SPVID:<S2SV_blank>%d"" , ( EXTRACT_24BITS ( tptr ) >> 12 ) & 0x000fff , EXTRACT_24BITS ( tptr ) & 0x000fff ) ) ; tptr = tptr + 3 ;  len = len - ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ;  tmp -- ; } break ; case ISIS_SUBTLV_SPBM_SI :  ND_TCHECK2 ( * tptr , 8 ) ;  ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>BMAC:<S2SV_blank>%08x"" , EXTRACT_32BITS ( tptr ) ) ) ; tptr = tptr + 4 ; ND_PRINT ( ( ndo , ""%04x"" , EXTRACT_16BITS ( tptr ) ) ) ; tptr = tptr + 2 ; ND_PRINT ( ( ndo , "",<S2SV_blank>RES:<S2SV_blank>%d,<S2SV_blank>VID:<S2SV_blank>%d"" , EXTRACT_16BITS ( tptr ) >> 12 , ( EXTRACT_16BITS ( tptr ) ) & 0x0fff ) ) ; tptr = tptr + 2 ; len = len - 8 ; stlv_len = stlv_len - 8 ; while ( stlv_len >= 4 ) { ND_TCHECK2 ( * tptr , 4 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>T:<S2SV_blank>%d,<S2SV_blank>R:<S2SV_blank>%d,<S2SV_blank>RES:<S2SV_blank>%d,<S2SV_blank>ISID:<S2SV_blank>%d"" , ( EXTRACT_32BITS ( tptr ) >> 31 ) , ( EXTRACT_32BITS ( tptr ) >> 30 ) & 0x01 , ( EXTRACT_32BITS ( tptr ) >> 24 ) & 0x03f , ( EXTRACT_32BITS ( tptr ) ) & 0x0ffffff ) ) ; tptr = tptr + 4 ; len = len - 4 ; stlv_len = stlv_len - 4 ; } break ; default : break ; }  }  return 0 ; trunc : ND_PRINT ( ( ndo , ""\\n\\t\\t"" ) ) ; ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return ( 1 ) ; }","ND_TCHECK2 ( * tptr , 2 ) ;stlv_type = * ( tptr ++ ) ;stlv_len = * ( tptr ++ ) ;len = len - 2 ;if ( len < stlv_len ) goto trunc ;ND_TCHECK2 ( * ( tptr ) , stlv_len ) ;switch ( stlv_type ) {case ISIS_SUBTLV_SPB_INSTANCE : if ( stlv_len < ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ) goto trunc ;ND_PRINT ( ( ndo , ""\\\",60
82,"buggy line: while ( tmp )  {ND_TCHECK2 ( * tptr , ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ) ;ND_PRINT ( ( ndo , ""\\\len = len - ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ;tmp -- ;case ISIS_SUBTLV_SPBM_SI :  ND_TCHECK2 ( * tptr , 8 ) ;ND_PRINT ( ( ndo , ""\\\cwe id:CWE-125context: static int isis_print_mt_capability_subtlv ( netdissect_options * ndo , const uint8_t * tptr , int len ) { int stlv_type , stlv_len , tmp ; while ( len > 2 ) {  stlv_type = * ( tptr ++ ) ;  stlv_len = * ( tptr ++ ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>subTLV<S2SV_blank>#%u,<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( isis_mt_capability_subtlv_values , ""unknown"" , stlv_type ) , stlv_type , stlv_len ) ) ;  len = len - 2 ;  switch ( stlv_type ) { case ISIS_SUBTLV_SPB_INSTANCE :  ND_TCHECK2 ( * tptr , ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ) ;  ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>CIST<S2SV_blank>Root-ID:<S2SV_blank>%08x"" , EXTRACT_32BITS ( tptr ) ) ) ; tptr = tptr + 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>%08x"" , EXTRACT_32BITS ( tptr ) ) ) ; tptr = tptr + 4 ; ND_PRINT ( ( ndo , "",<S2SV_blank>Path<S2SV_blank>Cost:<S2SV_blank>%08x"" , EXTRACT_32BITS ( tptr ) ) ) ; tptr = tptr + 4 ; ND_PRINT ( ( ndo , "",<S2SV_blank>Prio:<S2SV_blank>%d"" , EXTRACT_16BITS ( tptr ) ) ) ; tptr = tptr + 2 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>RES:<S2SV_blank>%d"" , EXTRACT_16BITS ( tptr ) >> 5 ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>V:<S2SV_blank>%d"" , ( EXTRACT_16BITS ( tptr ) >> 4 ) & 0x0001 ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>SPSource-ID:<S2SV_blank>%d"" , ( EXTRACT_32BITS ( tptr ) & 0x000fffff ) ) ) ; tptr = tptr + 4 ; ND_PRINT ( ( ndo , "",<S2SV_blank>No<S2SV_blank>of<S2SV_blank>Trees:<S2SV_blank>%x"" , * ( tptr ) ) ) ; tmp = * ( tptr ++ ) ; len = len - ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ;  while ( tmp )  {  ND_TCHECK2 ( * tptr , ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ) ;  ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>U:%d,<S2SV_blank>M:%d,<S2SV_blank>A:%d,<S2SV_blank>RES:%d"" , * ( tptr ) >> 7 , ( * ( tptr ) >> 6 ) & 0x01 , ( * ( tptr ) >> 5 ) & 0x01 , ( * ( tptr ) & 0x1f ) ) ) ; tptr ++ ; ND_PRINT ( ( ndo , "",<S2SV_blank>ECT:<S2SV_blank>%08x"" , EXTRACT_32BITS ( tptr ) ) ) ; tptr = tptr + 4 ; ND_PRINT ( ( ndo , "",<S2SV_blank>BVID:<S2SV_blank>%d,<S2SV_blank>SPVID:<S2SV_blank>%d"" , ( EXTRACT_24BITS ( tptr ) >> 12 ) & 0x000fff , EXTRACT_24BITS ( tptr ) & 0x000fff ) ) ; tptr = tptr + 3 ;  len = len - ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ;  tmp -- ; } break ; case ISIS_SUBTLV_SPBM_SI :  ND_TCHECK2 ( * tptr , 8 ) ;  ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>BMAC:<S2SV_blank>%08x"" , EXTRACT_32BITS ( tptr ) ) ) ; tptr = tptr + 4 ; ND_PRINT ( ( ndo , ""%04x"" , EXTRACT_16BITS ( tptr ) ) ) ; tptr = tptr + 2 ; ND_PRINT ( ( ndo , "",<S2SV_blank>RES:<S2SV_blank>%d,<S2SV_blank>VID:<S2SV_blank>%d"" , EXTRACT_16BITS ( tptr ) >> 12 , ( EXTRACT_16BITS ( tptr ) ) & 0x0fff ) ) ; tptr = tptr + 2 ; len = len - 8 ; stlv_len = stlv_len - 8 ; while ( stlv_len >= 4 ) { ND_TCHECK2 ( * tptr , 4 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>T:<S2SV_blank>%d,<S2SV_blank>R:<S2SV_blank>%d,<S2SV_blank>RES:<S2SV_blank>%d,<S2SV_blank>ISID:<S2SV_blank>%d"" , ( EXTRACT_32BITS ( tptr ) >> 31 ) , ( EXTRACT_32BITS ( tptr ) >> 30 ) & 0x01 , ( EXTRACT_32BITS ( tptr ) >> 24 ) & 0x03f , ( EXTRACT_32BITS ( tptr ) ) & 0x0ffffff ) ) ; tptr = tptr + 4 ; len = len - 4 ; stlv_len = stlv_len - 4 ; } break ; default : break ; }  }  return 0 ; trunc : ND_PRINT ( ( ndo , ""\\n\\t\\t"" ) ) ; ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return ( 1 ) ; }","stlv_len = stlv_len - ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ;while ( tmp ) {if ( stlv_len < ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ) goto trunc ;ND_PRINT ( ( ndo , ""\\\len = len - ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ;stlv_len = stlv_len - ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ;tmp -- ;case ISIS_SUBTLV_SPBM_SI : if ( stlv_len < 8 ) goto trunc ;ND_PRINT ( ( ndo , ""\\\",60
83,"buggy line: }return 0 ;cwe id:CWE-125context: static int isis_print_mt_capability_subtlv ( netdissect_options * ndo , const uint8_t * tptr , int len ) { int stlv_type , stlv_len , tmp ; while ( len > 2 ) {  stlv_type = * ( tptr ++ ) ;  stlv_len = * ( tptr ++ ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>subTLV<S2SV_blank>#%u,<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( isis_mt_capability_subtlv_values , ""unknown"" , stlv_type ) , stlv_type , stlv_len ) ) ;  len = len - 2 ;  switch ( stlv_type ) { case ISIS_SUBTLV_SPB_INSTANCE :  ND_TCHECK2 ( * tptr , ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ) ;  ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>CIST<S2SV_blank>Root-ID:<S2SV_blank>%08x"" , EXTRACT_32BITS ( tptr ) ) ) ; tptr = tptr + 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>%08x"" , EXTRACT_32BITS ( tptr ) ) ) ; tptr = tptr + 4 ; ND_PRINT ( ( ndo , "",<S2SV_blank>Path<S2SV_blank>Cost:<S2SV_blank>%08x"" , EXTRACT_32BITS ( tptr ) ) ) ; tptr = tptr + 4 ; ND_PRINT ( ( ndo , "",<S2SV_blank>Prio:<S2SV_blank>%d"" , EXTRACT_16BITS ( tptr ) ) ) ; tptr = tptr + 2 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>RES:<S2SV_blank>%d"" , EXTRACT_16BITS ( tptr ) >> 5 ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>V:<S2SV_blank>%d"" , ( EXTRACT_16BITS ( tptr ) >> 4 ) & 0x0001 ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>SPSource-ID:<S2SV_blank>%d"" , ( EXTRACT_32BITS ( tptr ) & 0x000fffff ) ) ) ; tptr = tptr + 4 ; ND_PRINT ( ( ndo , "",<S2SV_blank>No<S2SV_blank>of<S2SV_blank>Trees:<S2SV_blank>%x"" , * ( tptr ) ) ) ; tmp = * ( tptr ++ ) ; len = len - ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ;  while ( tmp )  {  ND_TCHECK2 ( * tptr , ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ) ;  ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>U:%d,<S2SV_blank>M:%d,<S2SV_blank>A:%d,<S2SV_blank>RES:%d"" , * ( tptr ) >> 7 , ( * ( tptr ) >> 6 ) & 0x01 , ( * ( tptr ) >> 5 ) & 0x01 , ( * ( tptr ) & 0x1f ) ) ) ; tptr ++ ; ND_PRINT ( ( ndo , "",<S2SV_blank>ECT:<S2SV_blank>%08x"" , EXTRACT_32BITS ( tptr ) ) ) ; tptr = tptr + 4 ; ND_PRINT ( ( ndo , "",<S2SV_blank>BVID:<S2SV_blank>%d,<S2SV_blank>SPVID:<S2SV_blank>%d"" , ( EXTRACT_24BITS ( tptr ) >> 12 ) & 0x000fff , EXTRACT_24BITS ( tptr ) & 0x000fff ) ) ; tptr = tptr + 3 ;  len = len - ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ;  tmp -- ; } break ; case ISIS_SUBTLV_SPBM_SI :  ND_TCHECK2 ( * tptr , 8 ) ;  ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>BMAC:<S2SV_blank>%08x"" , EXTRACT_32BITS ( tptr ) ) ) ; tptr = tptr + 4 ; ND_PRINT ( ( ndo , ""%04x"" , EXTRACT_16BITS ( tptr ) ) ) ; tptr = tptr + 2 ; ND_PRINT ( ( ndo , "",<S2SV_blank>RES:<S2SV_blank>%d,<S2SV_blank>VID:<S2SV_blank>%d"" , EXTRACT_16BITS ( tptr ) >> 12 , ( EXTRACT_16BITS ( tptr ) ) & 0x0fff ) ) ; tptr = tptr + 2 ; len = len - 8 ; stlv_len = stlv_len - 8 ; while ( stlv_len >= 4 ) { ND_TCHECK2 ( * tptr , 4 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>T:<S2SV_blank>%d,<S2SV_blank>R:<S2SV_blank>%d,<S2SV_blank>RES:<S2SV_blank>%d,<S2SV_blank>ISID:<S2SV_blank>%d"" , ( EXTRACT_32BITS ( tptr ) >> 31 ) , ( EXTRACT_32BITS ( tptr ) >> 30 ) & 0x01 , ( EXTRACT_32BITS ( tptr ) >> 24 ) & 0x03f , ( EXTRACT_32BITS ( tptr ) ) & 0x0ffffff ) ) ; tptr = tptr + 4 ; len = len - 4 ; stlv_len = stlv_len - 4 ; } break ; default : break ; }  }  return 0 ; trunc : ND_PRINT ( ( ndo , ""\\n\\t\\t"" ) ) ; ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return ( 1 ) ; }",tptr += stlv_len ;len -= stlv_len ;}return 0 ;,60
84,"buggy line: return reply_msg ( c , MSG_BAD_FORMAT ) ;type = which_cmd ( c ) ;dprintf ( ""got<S2SV_blank>%s<S2SV_blank>command:<S2SV_blank>\\\\""%s\\\\""\\\switch ( type ) {case OP_PUT : r = read_pri ( & pri , c -> cmd + 4 , & delay_buf ) ;if ( r ) return reply_msg ( c , MSG_BAD_FORMAT ) ;r = read_delay ( & delay , delay_buf , & ttr_buf ) ;if ( r ) return reply_msg ( c , MSG_BAD_FORMAT ) ;r = read_ttr ( & ttr , ttr_buf , & size_buf ) ;if ( r ) return reply_msg ( c , MSG_BAD_FORMAT ) ;errno = 0 ;body_size = strtoul ( size_buf , & end_buf , 10 ) ;if ( errno ) return reply_msg ( c , MSG_BAD_FORMAT ) ;if ( body_size > job_data_size_limit ) {return reply_msg ( c , MSG_JOB_TOO_BIG ) ;}cwe id:CWE-000context: static void dispatch_cmd ( conn c ) { int r , i , timeout = - 1 ; size_t z ; unsigned int count ; job j ; unsigned char type ; char * size_buf , * delay_buf , * ttr_buf , * pri_buf , * end_buf , * name ; unsigned int pri , body_size ; usec delay , ttr ; uint64_t id ; tube t = NULL ; c -> cmd [ c -> cmd_len - 2 ] = '\\0' ; if ( strlen ( c -> cmd ) != c -> cmd_len - 2 ) { return reply_msg ( c , MSG_BAD_FORMAT ) ; } type = which_cmd ( c ) ; dprintf ( ""got<S2SV_blank>%s<S2SV_blank>command:<S2SV_blank>\\""%s\\""\\n"" , op_names [ ( int ) type ] , c -> cmd ) ; switch ( type ) { case OP_PUT : r = read_pri ( & pri , c -> cmd + 4 , & delay_buf ) ; if ( r ) return reply_msg ( c , MSG_BAD_FORMAT ) ; r = read_delay ( & delay , delay_buf , & ttr_buf ) ; if ( r ) return reply_msg ( c , MSG_BAD_FORMAT ) ; r = read_ttr ( & ttr , ttr_buf , & size_buf ) ; if ( r ) return reply_msg ( c , MSG_BAD_FORMAT ) ; errno = 0 ; body_size = strtoul ( size_buf , & end_buf , 10 ) ; if ( errno ) return reply_msg ( c , MSG_BAD_FORMAT ) ; if ( body_size > job_data_size_limit ) {  return reply_msg ( c , MSG_JOB_TOO_BIG ) ;  } if ( end_buf [ 0 ] != '\\0' ) return reply_msg ( c , MSG_BAD_FORMAT ) ; conn_set_producer ( c ) ; c -> in_job = make_job ( pri , delay , ttr ? : 1 , body_size + 2 , c -> use ) ; if ( ! c -> in_job ) { twarnx ( ""server<S2SV_blank>error:<S2SV_blank>"" MSG_OUT_OF_MEMORY ) ; return skip ( c , body_size + 2 , MSG_OUT_OF_MEMORY ) ; } fill_extra_data ( c ) ; maybe_enqueue_incoming_job ( c ) ; break ; case OP_PEEK_READY : if ( c -> cmd_len != CMD_PEEK_READY_LEN + 2 ) { return reply_msg ( c , MSG_BAD_FORMAT ) ; } op_ct [ type ] ++ ; j = job_copy ( pq_peek ( & c -> use -> ready ) ) ; if ( ! j ) return reply ( c , MSG_NOTFOUND , MSG_NOTFOUND_LEN , STATE_SENDWORD ) ; reply_job ( c , j , MSG_FOUND ) ; break ; case OP_PEEK_DELAYED : if ( c -> cmd_len != CMD_PEEK_DELAYED_LEN + 2 ) { return reply_msg ( c , MSG_BAD_FORMAT ) ; } op_ct [ type ] ++ ; j = job_copy ( pq_peek ( & c -> use -> delay ) ) ; if ( ! j ) return reply ( c , MSG_NOTFOUND , MSG_NOTFOUND_LEN , STATE_SENDWORD ) ; reply_job ( c , j , MSG_FOUND ) ; break ; case OP_PEEK_BURIED : if ( c -> cmd_len != CMD_PEEK_BURIED_LEN + 2 ) { return reply_msg ( c , MSG_BAD_FORMAT ) ; } op_ct [ type ] ++ ; j = job_copy ( buried_job_p ( c -> use ) ? j = c -> use -> buried . next : NULL ) ; if ( ! j ) return reply ( c , MSG_NOTFOUND , MSG_NOTFOUND_LEN , STATE_SENDWORD ) ; reply_job ( c , j , MSG_FOUND ) ; break ; case OP_PEEKJOB : errno = 0 ; id = strtoull ( c -> cmd + CMD_PEEKJOB_LEN , & end_buf , 10 ) ; if ( errno ) return reply_msg ( c , MSG_BAD_FORMAT ) ; op_ct [ type ] ++ ; j = job_copy ( peek_job ( id ) ) ; if ( ! j ) return reply ( c , MSG_NOTFOUND , MSG_NOTFOUND_LEN , STATE_SENDWORD ) ; reply_job ( c , j , MSG_FOUND ) ; break ; case OP_RESERVE_TIMEOUT : errno = 0 ; timeout = strtol ( c -> cmd + CMD_RESERVE_TIMEOUT_LEN , & end_buf , 10 ) ; if ( errno ) return reply_msg ( c , MSG_BAD_FORMAT ) ; case OP_RESERVE : if ( type == OP_RESERVE && c -> cmd_len != CMD_RESERVE_LEN + 2 ) { return reply_msg ( c , MSG_BAD_FORMAT ) ; } op_ct [ type ] ++ ; conn_set_worker ( c ) ; if ( conn_has_close_deadline ( c ) && ! conn_ready ( c ) ) { return reply_msg ( c , MSG_DEADLINE_SOON ) ; } wait_for_job ( c , timeout ) ; process_queue ( ) ; break ; case OP_DELETE : errno = 0 ; id = strtoull ( c -> cmd + CMD_DELETE_LEN , & end_buf , 10 ) ; if ( errno ) return reply_msg ( c , MSG_BAD_FORMAT ) ; op_ct [ type ] ++ ; j = job_find ( id ) ; j = remove_reserved_job ( c , j ) ? : remove_ready_job ( j ) ? : remove_buried_job ( j ) ; if ( ! j ) return reply ( c , MSG_NOTFOUND , MSG_NOTFOUND_LEN , STATE_SENDWORD ) ; j -> state = JOB_STATE_INVALID ; r = binlog_write_job ( j ) ; job_free ( j ) ; if ( ! r ) return reply_serr ( c , MSG_INTERNAL_ERROR ) ; reply ( c , MSG_DELETED , MSG_DELETED_LEN , STATE_SENDWORD ) ; break ; case OP_RELEASE : errno = 0 ; id = strtoull ( c -> cmd + CMD_RELEASE_LEN , & pri_buf , 10 ) ; if ( errno ) return reply_msg ( c , MSG_BAD_FORMAT ) ; r = read_pri ( & pri , pri_buf , & delay_buf ) ; if ( r ) return reply_msg ( c , MSG_BAD_FORMAT ) ; r = read_delay ( & delay , delay_buf , NULL ) ; if ( r ) return reply_msg ( c , MSG_BAD_FORMAT ) ; op_ct [ type ] ++ ; j = remove_reserved_job ( c , job_find ( id ) ) ; if ( ! j ) return reply ( c , MSG_NOTFOUND , MSG_NOTFOUND_LEN , STATE_SENDWORD ) ; if ( delay ) { z = binlog_reserve_space_update ( j ) ; if ( ! z ) return reply_serr ( c , MSG_OUT_OF_MEMORY ) ; j -> reserved_binlog_space += z ; } j -> pri = pri ; j -> delay = delay ; j -> release_ct ++ ; r = enqueue_job ( j , delay , ! ! delay ) ; if ( r < 0 ) return reply_serr ( c , MSG_INTERNAL_ERROR ) ; if ( r == 1 ) { return reply ( c , MSG_RELEASED , MSG_RELEASED_LEN , STATE_SENDWORD ) ; } bury_job ( j , 0 ) ; reply ( c , MSG_BURIED , MSG_BURIED_LEN , STATE_SENDWORD ) ; break ; case OP_BURY : errno = 0 ; id = strtoull ( c -> cmd + CMD_BURY_LEN , & pri_buf , 10 ) ; if ( errno ) return reply_msg ( c , MSG_BAD_FORMAT ) ; r = read_pri ( & pri , pri_buf , NULL ) ; if ( r ) return reply_msg ( c , MSG_BAD_FORMAT ) ; op_ct [ type ] ++ ; j = remove_reserved_job ( c , job_find ( id ) ) ; if ( ! j ) return reply ( c , MSG_NOTFOUND , MSG_NOTFOUND_LEN , STATE_SENDWORD ) ; j -> pri = pri ; r = bury_job ( j , 1 ) ; if ( ! r ) return reply_serr ( c , MSG_INTERNAL_ERROR ) ; reply ( c , MSG_BURIED , MSG_BURIED_LEN , STATE_SENDWORD ) ; break ; case OP_KICK : errno = 0 ; count = strtoul ( c -> cmd + CMD_KICK_LEN , & end_buf , 10 ) ; if ( end_buf == c -> cmd + CMD_KICK_LEN ) { return reply_msg ( c , MSG_BAD_FORMAT ) ; } if ( errno ) return reply_msg ( c , MSG_BAD_FORMAT ) ; op_ct [ type ] ++ ; i = kick_jobs ( c -> use , count ) ; return reply_line ( c , STATE_SENDWORD , ""KICKED<S2SV_blank>%u\\r\\n"" , i ) ; case OP_TOUCH : errno = 0 ; id = strtoull ( c -> cmd + CMD_TOUCH_LEN , & end_buf , 10 ) ; if ( errno ) return twarn ( ""strtoull"" ) , reply_msg ( c , MSG_BAD_FORMAT ) ; op_ct [ type ] ++ ; j = touch_job ( c , job_find ( id ) ) ; if ( j ) { reply ( c , MSG_TOUCHED , MSG_TOUCHED_LEN , STATE_SENDWORD ) ; } else { return reply ( c , MSG_NOTFOUND , MSG_NOTFOUND_LEN , STATE_SENDWORD ) ; } break ; case OP_STATS : if ( c -> cmd_len != CMD_STATS_LEN + 2 ) { return reply_msg ( c , MSG_BAD_FORMAT ) ; } op_ct [ type ] ++ ; do_stats ( c , fmt_stats , NULL ) ; break ; case OP_JOBSTATS : errno = 0 ; id = strtoull ( c -> cmd + CMD_JOBSTATS_LEN , & end_buf , 10 ) ; if ( errno ) return reply_msg ( c , MSG_BAD_FORMAT ) ; op_ct [ type ] ++ ; j = peek_job ( id ) ; if ( ! j ) return reply ( c , MSG_NOTFOUND , MSG_NOTFOUND_LEN , STATE_SENDWORD ) ; if ( ! j -> tube ) return reply_serr ( c , MSG_INTERNAL_ERROR ) ; do_stats ( c , ( fmt_fn ) fmt_job_stats , j ) ; break ; case OP_STATS_TUBE : name = c -> cmd + CMD_STATS_TUBE_LEN ; if ( ! name_is_ok ( name , 200 ) ) return reply_msg ( c , MSG_BAD_FORMAT ) ; op_ct [ type ] ++ ; t = tube_find ( name ) ; if ( ! t ) return reply_msg ( c , MSG_NOTFOUND ) ; do_stats ( c , ( fmt_fn ) fmt_stats_tube , t ) ; t = NULL ; break ; case OP_LIST_TUBES : if ( c -> cmd_len != CMD_LIST_TUBES_LEN + 2 ) { return reply_msg ( c , MSG_BAD_FORMAT ) ; } op_ct [ type ] ++ ; do_list_tubes ( c , & tubes ) ; break ; case OP_LIST_TUBE_USED : if ( c -> cmd_len != CMD_LIST_TUBE_USED_LEN + 2 ) { return reply_msg ( c , MSG_BAD_FORMAT ) ; } op_ct [ type ] ++ ; reply_line ( c , STATE_SENDWORD , ""USING<S2SV_blank>%s\\r\\n"" , c -> use -> name ) ; break ; case OP_LIST_TUBES_WATCHED : if ( c -> cmd_len != CMD_LIST_TUBES_WATCHED_LEN + 2 ) { return reply_msg ( c , MSG_BAD_FORMAT ) ; } op_ct [ type ] ++ ; do_list_tubes ( c , & c -> watch ) ; break ; case OP_USE : name = c -> cmd + CMD_USE_LEN ; if ( ! name_is_ok ( name , 200 ) ) return reply_msg ( c , MSG_BAD_FORMAT ) ; op_ct [ type ] ++ ; TUBE_ASSIGN ( t , tube_find_or_make ( name ) ) ; if ( ! t ) return reply_serr ( c , MSG_OUT_OF_MEMORY ) ; c -> use -> using_ct -- ; TUBE_ASSIGN ( c -> use , t ) ; TUBE_ASSIGN ( t , NULL ) ; c -> use -> using_ct ++ ; reply_line ( c , STATE_SENDWORD , ""USING<S2SV_blank>%s\\r\\n"" , c -> use -> name ) ; break ; case OP_WATCH : name = c -> cmd + CMD_WATCH_LEN ; if ( ! name_is_ok ( name , 200 ) ) return reply_msg ( c , MSG_BAD_FORMAT ) ; op_ct [ type ] ++ ; TUBE_ASSIGN ( t , tube_find_or_make ( name ) ) ; if ( ! t ) return reply_serr ( c , MSG_OUT_OF_MEMORY ) ; r = 1 ; if ( ! ms_contains ( & c -> watch , t ) ) r = ms_append ( & c -> watch , t ) ; TUBE_ASSIGN ( t , NULL ) ; if ( ! r ) return reply_serr ( c , MSG_OUT_OF_MEMORY ) ; reply_line ( c , STATE_SENDWORD , ""WATCHING<S2SV_blank>%d\\r\\n"" , c -> watch . used ) ; break ; case OP_IGNORE : name = c -> cmd + CMD_IGNORE_LEN ; if ( ! name_is_ok ( name , 200 ) ) return reply_msg ( c , MSG_BAD_FORMAT ) ; op_ct [ type ] ++ ; t = NULL ; for ( i = 0 ; i < c -> watch . used ; i ++ ) { t = c -> watch . items [ i ] ; if ( strncmp ( t -> name , name , MAX_TUBE_NAME_LEN ) == 0 ) break ; t = NULL ; } if ( t && c -> watch . used < 2 ) return reply_msg ( c , MSG_NOT_IGNORED ) ; if ( t ) ms_remove ( & c -> watch , t ) ; t = NULL ; reply_line ( c , STATE_SENDWORD , ""WATCHING<S2SV_blank>%d\\r\\n"" , c -> watch . used ) ; break ; case OP_QUIT : conn_close ( c ) ; break ; case OP_PAUSE_TUBE : op_ct [ type ] ++ ; r = read_tube_name ( & name , c -> cmd + CMD_PAUSE_TUBE_LEN , & delay_buf ) ; if ( r ) return reply_msg ( c , MSG_BAD_FORMAT ) ; r = read_delay ( & delay , delay_buf , NULL ) ; if ( r ) return reply_msg ( c , MSG_BAD_FORMAT ) ; * delay_buf = '\\0' ; t = tube_find ( name ) ; if ( ! t ) return reply_msg ( c , MSG_NOTFOUND ) ; t -> deadline_at = now_usec ( ) + delay ; t -> pause = delay ; t -> stat . pause_ct ++ ; set_main_delay_timeout ( ) ; reply_line ( c , STATE_SENDWORD , ""PAUSED\\r\\n"" ) ; break ; default : return reply_msg ( c , MSG_UNKNOWN_COMMAND ) ; } }","return skip ( c , body_size + 2 , MSG_JOB_TOO_BIG ) ;",61
85,"buggy line: ddi . dinfo_nboards = dgnc_NumBoards ;sprintf ( ddi . dinfo_version , ""%s"" , DG_PART ) ;cwe id:CWE-200context: long dgnc_mgmt_ioctl ( struct file * file , unsigned int cmd , unsigned long arg ) { unsigned long flags ; void __user * uarg = ( void __user * ) arg ; switch ( cmd ) { case DIGI_GETDD : { struct digi_dinfo ddi ; spin_lock_irqsave ( & dgnc_global_lock , flags ) ;  ddi . dinfo_nboards = dgnc_NumBoards ;  sprintf ( ddi . dinfo_version , ""%s"" , DG_PART ) ; spin_unlock_irqrestore ( & dgnc_global_lock , flags ) ; if ( copy_to_user ( uarg , & ddi , sizeof ( ddi ) ) ) return - EFAULT ; break ; } case DIGI_GETBD : { int brd ; struct digi_info di ; if ( copy_from_user ( & brd , uarg , sizeof ( int ) ) ) return - EFAULT ; if ( brd < 0 || brd >= dgnc_NumBoards ) return - ENODEV ; memset ( & di , 0 , sizeof ( di ) ) ; di . info_bdnum = brd ; spin_lock_irqsave ( & dgnc_Board [ brd ] -> bd_lock , flags ) ; di . info_bdtype = dgnc_Board [ brd ] -> dpatype ; di . info_bdstate = dgnc_Board [ brd ] -> dpastatus ; di . info_ioport = 0 ; di . info_physaddr = ( ulong ) dgnc_Board [ brd ] -> membase ; di . info_physsize = ( ulong ) dgnc_Board [ brd ] -> membase - dgnc_Board [ brd ] -> membase_end ; if ( dgnc_Board [ brd ] -> state != BOARD_FAILED ) di . info_nports = dgnc_Board [ brd ] -> nasync ; else di . info_nports = 0 ; spin_unlock_irqrestore ( & dgnc_Board [ brd ] -> bd_lock , flags ) ; if ( copy_to_user ( uarg , & di , sizeof ( di ) ) ) return - EFAULT ; break ; } case DIGI_GET_NI_INFO : { struct channel_t * ch ; struct ni_info ni ; unsigned char mstat = 0 ; uint board = 0 ; uint channel = 0 ; if ( copy_from_user ( & ni , uarg , sizeof ( ni ) ) ) return - EFAULT ; board = ni . board ; channel = ni . channel ; if ( board >= dgnc_NumBoards ) return - ENODEV ; if ( channel >= dgnc_Board [ board ] -> nasync ) return - ENODEV ; ch = dgnc_Board [ board ] -> channels [ channel ] ; if ( ! ch || ch -> magic != DGNC_CHANNEL_MAGIC ) return - ENODEV ; memset ( & ni , 0 , sizeof ( ni ) ) ; ni . board = board ; ni . channel = channel ; spin_lock_irqsave ( & ch -> ch_lock , flags ) ; mstat = ( ch -> ch_mostat | ch -> ch_mistat ) ; if ( mstat & UART_MCR_DTR ) { ni . mstat |= TIOCM_DTR ; ni . dtr = TIOCM_DTR ; } if ( mstat & UART_MCR_RTS ) { ni . mstat |= TIOCM_RTS ; ni . rts = TIOCM_RTS ; } if ( mstat & UART_MSR_CTS ) { ni . mstat |= TIOCM_CTS ; ni . cts = TIOCM_CTS ; } if ( mstat & UART_MSR_RI ) { ni . mstat |= TIOCM_RI ; ni . ri = TIOCM_RI ; } if ( mstat & UART_MSR_DCD ) { ni . mstat |= TIOCM_CD ; ni . dcd = TIOCM_CD ; } if ( mstat & UART_MSR_DSR ) ni . mstat |= TIOCM_DSR ; ni . iflag = ch -> ch_c_iflag ; ni . oflag = ch -> ch_c_oflag ; ni . cflag = ch -> ch_c_cflag ; ni . lflag = ch -> ch_c_lflag ; if ( ch -> ch_digi . digi_flags & CTSPACE || ch -> ch_c_cflag & CRTSCTS ) ni . hflow = 1 ; else ni . hflow = 0 ; if ( ( ch -> ch_flags & CH_STOPI ) || ( ch -> ch_flags & CH_FORCED_STOPI ) ) ni . recv_stopped = 1 ; else ni . recv_stopped = 0 ; if ( ( ch -> ch_flags & CH_STOP ) || ( ch -> ch_flags & CH_FORCED_STOP ) ) ni . xmit_stopped = 1 ; else ni . xmit_stopped = 0 ; ni . curtx = ch -> ch_txcount ; ni . currx = ch -> ch_rxcount ; ni . baud = ch -> ch_old_baud ; spin_unlock_irqrestore ( & ch -> ch_lock , flags ) ; if ( copy_to_user ( uarg , & ni , sizeof ( ni ) ) ) return - EFAULT ; break ; } } return 0 ; }","memset ( & ddi , 0 , sizeof ( ddi ) ) ;ddi . dinfo_nboards = dgnc_NumBoards ;sprintf ( ddi . dinfo_version , ""%s"" , DG_PART ) ;",62
86,"buggy line: if ( ! ( opt_len == 12 && flags & TH_SYN ) &&  ! ( opt_len == 20 && ( flags & ( TH_SYN | TH_ACK ) ) == TH_ACK ) ) return 0 ;cwe id:CWE-125context: static int mp_capable_print ( netdissect_options * ndo , const u_char * opt , u_int opt_len , u_char flags ) { const struct mp_capable * mpc = ( const struct mp_capable * ) opt ;  if ( ! ( opt_len == 12 && flags & TH_SYN ) &&  ! ( opt_len == 20 && ( flags & ( TH_SYN | TH_ACK ) ) == TH_ACK ) ) return 0 ; if ( MP_CAPABLE_OPT_VERSION ( mpc -> sub_ver ) != 0 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>Unknown<S2SV_blank>Version<S2SV_blank>(%d)"" , MP_CAPABLE_OPT_VERSION ( mpc -> sub_ver ) ) ) ; return 1 ; } if ( mpc -> flags & MP_CAPABLE_C ) ND_PRINT ( ( ndo , ""<S2SV_blank>csum"" ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>{0x%"" PRIx64 , EXTRACT_64BITS ( mpc -> sender_key ) ) ) ; if ( opt_len == 20 ) ND_PRINT ( ( ndo , "",0x%"" PRIx64 , EXTRACT_64BITS ( mpc -> receiver_key ) ) ) ; ND_PRINT ( ( ndo , ""}"" ) ) ; return 1 ; }",if ( ! ( opt_len == 12 && ( flags & TH_SYN ) ) && ! ( opt_len == 20 && ( flags & ( TH_SYN | TH_ACK ) ) == TH_ACK ) ) return 0 ;,63
87,"buggy line: int procfd = payload -> procfd ;lxc_attach_options_t * options = payload -> options ;cwe id:CWE-264context: static int attach_child_main ( void * data ) { struct attach_clone_payload * payload = ( struct attach_clone_payload * ) data ; int ipc_socket = payload -> ipc_socket ;  int procfd = payload -> procfd ;  lxc_attach_options_t * options = payload -> options ; struct lxc_proc_context_info * init_ctx = payload -> init_ctx ; # if HAVE_SYS_PERSONALITY_H long new_personality ; # endif int ret ; int status ; int expected ; long flags ; int fd ;  uid_t new_uid ;  gid_t new_gid ; expected = 0 ; status = - 1 ; ret = lxc_read_nointr_expect ( ipc_socket , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) {  ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>(0)"" ) ;  shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } if ( ! ( options -> namespaces & CLONE_NEWNS ) && ( options -> attach_flags & LXC_ATTACH_REMOUNT_PROC_SYS ) ) { ret = lxc_attach_remount_sys_proc ( ) ; if ( ret < 0 ) { shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } # if HAVE_SYS_PERSONALITY_H if ( options -> personality < 0 ) new_personality = init_ctx -> personality ; else new_personality = options -> personality ; if ( options -> attach_flags & LXC_ATTACH_SET_PERSONALITY ) { ret = personality ( new_personality ) ; if ( ret < 0 ) { SYSERROR ( ""could<S2SV_blank>not<S2SV_blank>ensure<S2SV_blank>correct<S2SV_blank>architecture"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } # endif if ( options -> attach_flags & LXC_ATTACH_DROP_CAPABILITIES ) { ret = lxc_attach_drop_privs ( init_ctx ) ; if ( ret < 0 ) { ERROR ( ""could<S2SV_blank>not<S2SV_blank>drop<S2SV_blank>privileges"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } ret = lxc_attach_set_environment ( options -> env_policy , options -> extra_env_vars , options -> extra_keep_env ) ; if ( ret < 0 ) { ERROR ( ""could<S2SV_blank>not<S2SV_blank>set<S2SV_blank>initial<S2SV_blank>environment<S2SV_blank>for<S2SV_blank>attached<S2SV_blank>process"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } new_uid = 0 ; new_gid = 0 ; if ( options -> namespaces & CLONE_NEWUSER ) lxc_attach_get_init_uidgid ( & new_uid , & new_gid ) ; if ( options -> uid != ( uid_t ) - 1 ) new_uid = options -> uid ; if ( options -> gid != ( gid_t ) - 1 ) new_gid = options -> gid ; if ( options -> stdin_fd && isatty ( options -> stdin_fd ) ) { if ( setsid ( ) < 0 ) { SYSERROR ( ""unable<S2SV_blank>to<S2SV_blank>setsid"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } if ( ioctl ( options -> stdin_fd , TIOCSCTTY , ( char * ) NULL ) < 0 ) { SYSERROR ( ""unable<S2SV_blank>to<S2SV_blank>TIOCSTTY"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } if ( ( new_gid != 0 || options -> namespaces & CLONE_NEWUSER ) ) { if ( setgid ( new_gid ) || setgroups ( 0 , NULL ) ) { SYSERROR ( ""switching<S2SV_blank>to<S2SV_blank>container<S2SV_blank>gid"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } if ( ( new_uid != 0 || options -> namespaces & CLONE_NEWUSER ) && setuid ( new_uid ) ) { SYSERROR ( ""switching<S2SV_blank>to<S2SV_blank>container<S2SV_blank>uid"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } status = 1 ; ret = lxc_write_nointr ( ipc_socket , & status , sizeof ( status ) ) ; if ( ret != sizeof ( status ) ) {  ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(1)"" ) ;  shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } expected = 2 ; status = - 1 ; ret = lxc_read_nointr_expect ( ipc_socket , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) {  ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>final<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>(2)"" ) ;  shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } shutdown ( ipc_socket , SHUT_RDWR ) ; close ( ipc_socket ) ; if ( ( init_ctx -> container && init_ctx -> container -> lxc_conf && init_ctx -> container -> lxc_conf -> no_new_privs ) || ( options -> attach_flags & LXC_ATTACH_NO_NEW_PRIVS ) ) { if ( prctl ( PR_SET_NO_NEW_PRIVS , 1 , 0 , 0 , 0 ) < 0 ) { SYSERROR ( ""PR_SET_NO_NEW_PRIVS<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>set.<S2SV_blank>"" ""Process<S2SV_blank>can<S2SV_blank>use<S2SV_blank>execve()<S2SV_blank>gainable<S2SV_blank>"" ""privileges."" ) ;  rexit ( - 1 ) ;  } INFO ( ""PR_SET_NO_NEW_PRIVS<S2SV_blank>is<S2SV_blank>set.<S2SV_blank>Process<S2SV_blank>cannot<S2SV_blank>use<S2SV_blank>execve()<S2SV_blank>""  ""gainable<S2SV_blank>privileges."" ) ;  } if ( ( options -> namespaces & CLONE_NEWNS ) && ( options -> attach_flags & LXC_ATTACH_LSM ) && init_ctx -> lsm_label ) { int on_exec ;  on_exec = options -> attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0 ;   if ( lsm_set_label_at ( procfd , on_exec , init_ctx -> lsm_label ) < 0 ) {   rexit ( - 1 ) ;  } } if ( init_ctx -> container && init_ctx -> container -> lxc_conf && init_ctx -> container -> lxc_conf -> seccomp && ( lxc_seccomp_load ( init_ctx -> container -> lxc_conf ) != 0 ) ) { ERROR ( ""Loading<S2SV_blank>seccomp<S2SV_blank>policy"" ) ;  rexit ( - 1 ) ;  } lxc_proc_put_context_info ( init_ctx ) ; if ( options -> stdin_fd >= 0 && options -> stdin_fd != 0 ) dup2 ( options -> stdin_fd , 0 ) ; if ( options -> stdout_fd >= 0 && options -> stdout_fd != 1 ) dup2 ( options -> stdout_fd , 1 ) ; if ( options -> stderr_fd >= 0 && options -> stderr_fd != 2 ) dup2 ( options -> stderr_fd , 2 ) ; if ( options -> stdin_fd > 2 ) close ( options -> stdin_fd ) ; if ( options -> stdout_fd > 2 ) close ( options -> stdout_fd ) ; if ( options -> stderr_fd > 2 ) close ( options -> stderr_fd ) ; for ( fd = 0 ; fd <= 2 ; fd ++ ) { flags = fcntl ( fd , F_GETFL ) ; if ( flags < 0 ) continue ; if ( flags & FD_CLOEXEC ) if ( fcntl ( fd , F_SETFL , flags & ~ FD_CLOEXEC ) < 0 ) SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>clear<S2SV_blank>CLOEXEC<S2SV_blank>from<S2SV_blank>fd"" ) ; }  close ( procfd ) ;  rexit ( payload -> exec_function ( payload -> exec_payload ) ) ; }",lxc_attach_options_t * options = payload -> options ;,64
88,"buggy line: uid_t new_uid ;gid_t new_gid ;ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>(0)"" ) ;shutdown ( ipc_socket , SHUT_RDWR ) ;cwe id:CWE-264context: static int attach_child_main ( void * data ) { struct attach_clone_payload * payload = ( struct attach_clone_payload * ) data ; int ipc_socket = payload -> ipc_socket ;  int procfd = payload -> procfd ;  lxc_attach_options_t * options = payload -> options ; struct lxc_proc_context_info * init_ctx = payload -> init_ctx ; # if HAVE_SYS_PERSONALITY_H long new_personality ; # endif int ret ; int status ; int expected ; long flags ; int fd ;  uid_t new_uid ;  gid_t new_gid ; expected = 0 ; status = - 1 ; ret = lxc_read_nointr_expect ( ipc_socket , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) {  ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>(0)"" ) ;  shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } if ( ! ( options -> namespaces & CLONE_NEWNS ) && ( options -> attach_flags & LXC_ATTACH_REMOUNT_PROC_SYS ) ) { ret = lxc_attach_remount_sys_proc ( ) ; if ( ret < 0 ) { shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } # if HAVE_SYS_PERSONALITY_H if ( options -> personality < 0 ) new_personality = init_ctx -> personality ; else new_personality = options -> personality ; if ( options -> attach_flags & LXC_ATTACH_SET_PERSONALITY ) { ret = personality ( new_personality ) ; if ( ret < 0 ) { SYSERROR ( ""could<S2SV_blank>not<S2SV_blank>ensure<S2SV_blank>correct<S2SV_blank>architecture"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } # endif if ( options -> attach_flags & LXC_ATTACH_DROP_CAPABILITIES ) { ret = lxc_attach_drop_privs ( init_ctx ) ; if ( ret < 0 ) { ERROR ( ""could<S2SV_blank>not<S2SV_blank>drop<S2SV_blank>privileges"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } ret = lxc_attach_set_environment ( options -> env_policy , options -> extra_env_vars , options -> extra_keep_env ) ; if ( ret < 0 ) { ERROR ( ""could<S2SV_blank>not<S2SV_blank>set<S2SV_blank>initial<S2SV_blank>environment<S2SV_blank>for<S2SV_blank>attached<S2SV_blank>process"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } new_uid = 0 ; new_gid = 0 ; if ( options -> namespaces & CLONE_NEWUSER ) lxc_attach_get_init_uidgid ( & new_uid , & new_gid ) ; if ( options -> uid != ( uid_t ) - 1 ) new_uid = options -> uid ; if ( options -> gid != ( gid_t ) - 1 ) new_gid = options -> gid ; if ( options -> stdin_fd && isatty ( options -> stdin_fd ) ) { if ( setsid ( ) < 0 ) { SYSERROR ( ""unable<S2SV_blank>to<S2SV_blank>setsid"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } if ( ioctl ( options -> stdin_fd , TIOCSCTTY , ( char * ) NULL ) < 0 ) { SYSERROR ( ""unable<S2SV_blank>to<S2SV_blank>TIOCSTTY"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } if ( ( new_gid != 0 || options -> namespaces & CLONE_NEWUSER ) ) { if ( setgid ( new_gid ) || setgroups ( 0 , NULL ) ) { SYSERROR ( ""switching<S2SV_blank>to<S2SV_blank>container<S2SV_blank>gid"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } if ( ( new_uid != 0 || options -> namespaces & CLONE_NEWUSER ) && setuid ( new_uid ) ) { SYSERROR ( ""switching<S2SV_blank>to<S2SV_blank>container<S2SV_blank>uid"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } status = 1 ; ret = lxc_write_nointr ( ipc_socket , & status , sizeof ( status ) ) ; if ( ret != sizeof ( status ) ) {  ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(1)"" ) ;  shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } expected = 2 ; status = - 1 ; ret = lxc_read_nointr_expect ( ipc_socket , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) {  ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>final<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>(2)"" ) ;  shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } shutdown ( ipc_socket , SHUT_RDWR ) ; close ( ipc_socket ) ; if ( ( init_ctx -> container && init_ctx -> container -> lxc_conf && init_ctx -> container -> lxc_conf -> no_new_privs ) || ( options -> attach_flags & LXC_ATTACH_NO_NEW_PRIVS ) ) { if ( prctl ( PR_SET_NO_NEW_PRIVS , 1 , 0 , 0 , 0 ) < 0 ) { SYSERROR ( ""PR_SET_NO_NEW_PRIVS<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>set.<S2SV_blank>"" ""Process<S2SV_blank>can<S2SV_blank>use<S2SV_blank>execve()<S2SV_blank>gainable<S2SV_blank>"" ""privileges."" ) ;  rexit ( - 1 ) ;  } INFO ( ""PR_SET_NO_NEW_PRIVS<S2SV_blank>is<S2SV_blank>set.<S2SV_blank>Process<S2SV_blank>cannot<S2SV_blank>use<S2SV_blank>execve()<S2SV_blank>""  ""gainable<S2SV_blank>privileges."" ) ;  } if ( ( options -> namespaces & CLONE_NEWNS ) && ( options -> attach_flags & LXC_ATTACH_LSM ) && init_ctx -> lsm_label ) { int on_exec ;  on_exec = options -> attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0 ;   if ( lsm_set_label_at ( procfd , on_exec , init_ctx -> lsm_label ) < 0 ) {   rexit ( - 1 ) ;  } } if ( init_ctx -> container && init_ctx -> container -> lxc_conf && init_ctx -> container -> lxc_conf -> seccomp && ( lxc_seccomp_load ( init_ctx -> container -> lxc_conf ) != 0 ) ) { ERROR ( ""Loading<S2SV_blank>seccomp<S2SV_blank>policy"" ) ;  rexit ( - 1 ) ;  } lxc_proc_put_context_info ( init_ctx ) ; if ( options -> stdin_fd >= 0 && options -> stdin_fd != 0 ) dup2 ( options -> stdin_fd , 0 ) ; if ( options -> stdout_fd >= 0 && options -> stdout_fd != 1 ) dup2 ( options -> stdout_fd , 1 ) ; if ( options -> stderr_fd >= 0 && options -> stderr_fd != 2 ) dup2 ( options -> stderr_fd , 2 ) ; if ( options -> stdin_fd > 2 ) close ( options -> stdin_fd ) ; if ( options -> stdout_fd > 2 ) close ( options -> stdout_fd ) ; if ( options -> stderr_fd > 2 ) close ( options -> stderr_fd ) ; for ( fd = 0 ; fd <= 2 ; fd ++ ) { flags = fcntl ( fd , F_GETFL ) ; if ( flags < 0 ) continue ; if ( flags & FD_CLOEXEC ) if ( fcntl ( fd , F_SETFL , flags & ~ FD_CLOEXEC ) < 0 ) SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>clear<S2SV_blank>CLOEXEC<S2SV_blank>from<S2SV_blank>fd"" ) ; }  close ( procfd ) ;  rexit ( payload -> exec_function ( payload -> exec_payload ) ) ; }","int lsm_labelfd ;uid_t new_uid ;gid_t new_gid ;ERROR ( ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>(0):<S2SV_blank>%s."" , strerror ( errno ) ) ;shutdown ( ipc_socket , SHUT_RDWR ) ;",64
89,"buggy line: ERROR ( ""could<S2SV_blank>not<S2SV_blank>drop<S2SV_blank>privileges"" ) ;ERROR ( ""could<S2SV_blank>not<S2SV_blank>set<S2SV_blank>initial<S2SV_blank>environment<S2SV_blank>for<S2SV_blank>attached<S2SV_blank>process"" ) ;shutdown ( ipc_socket , SHUT_RDWR ) ;rexit ( - 1 ) ;}new_uid = 0 ;new_gid = 0 ;if ( options -> namespaces & CLONE_NEWUSER ) lxc_attach_get_init_uidgid ( & new_uid , & new_gid ) ;if ( options -> uid != ( uid_t ) - 1 ) new_uid = options -> uid ;if ( options -> gid != ( gid_t ) - 1 ) new_gid = options -> gid ;if ( options -> stdin_fd && isatty ( options -> stdin_fd ) ) {if ( setsid ( ) < 0 ) {SYSERROR ( ""unable<S2SV_blank>to<S2SV_blank>setsid"" ) ;if ( ioctl ( options -> stdin_fd , TIOCSCTTY , ( char * ) NULL ) < 0 ) {SYSERROR ( ""unable<S2SV_blank>to<S2SV_blank>TIOCSTTY"" ) ;shutdown ( ipc_socket , SHUT_RDWR ) ;rexit ( - 1 ) ;}}cwe id:CWE-264context: static int attach_child_main ( void * data ) { struct attach_clone_payload * payload = ( struct attach_clone_payload * ) data ; int ipc_socket = payload -> ipc_socket ;  int procfd = payload -> procfd ;  lxc_attach_options_t * options = payload -> options ; struct lxc_proc_context_info * init_ctx = payload -> init_ctx ; # if HAVE_SYS_PERSONALITY_H long new_personality ; # endif int ret ; int status ; int expected ; long flags ; int fd ;  uid_t new_uid ;  gid_t new_gid ; expected = 0 ; status = - 1 ; ret = lxc_read_nointr_expect ( ipc_socket , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) {  ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>(0)"" ) ;  shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } if ( ! ( options -> namespaces & CLONE_NEWNS ) && ( options -> attach_flags & LXC_ATTACH_REMOUNT_PROC_SYS ) ) { ret = lxc_attach_remount_sys_proc ( ) ; if ( ret < 0 ) { shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } # if HAVE_SYS_PERSONALITY_H if ( options -> personality < 0 ) new_personality = init_ctx -> personality ; else new_personality = options -> personality ; if ( options -> attach_flags & LXC_ATTACH_SET_PERSONALITY ) { ret = personality ( new_personality ) ; if ( ret < 0 ) { SYSERROR ( ""could<S2SV_blank>not<S2SV_blank>ensure<S2SV_blank>correct<S2SV_blank>architecture"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } # endif if ( options -> attach_flags & LXC_ATTACH_DROP_CAPABILITIES ) { ret = lxc_attach_drop_privs ( init_ctx ) ; if ( ret < 0 ) { ERROR ( ""could<S2SV_blank>not<S2SV_blank>drop<S2SV_blank>privileges"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } ret = lxc_attach_set_environment ( options -> env_policy , options -> extra_env_vars , options -> extra_keep_env ) ; if ( ret < 0 ) { ERROR ( ""could<S2SV_blank>not<S2SV_blank>set<S2SV_blank>initial<S2SV_blank>environment<S2SV_blank>for<S2SV_blank>attached<S2SV_blank>process"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } new_uid = 0 ; new_gid = 0 ; if ( options -> namespaces & CLONE_NEWUSER ) lxc_attach_get_init_uidgid ( & new_uid , & new_gid ) ; if ( options -> uid != ( uid_t ) - 1 ) new_uid = options -> uid ; if ( options -> gid != ( gid_t ) - 1 ) new_gid = options -> gid ; if ( options -> stdin_fd && isatty ( options -> stdin_fd ) ) { if ( setsid ( ) < 0 ) { SYSERROR ( ""unable<S2SV_blank>to<S2SV_blank>setsid"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } if ( ioctl ( options -> stdin_fd , TIOCSCTTY , ( char * ) NULL ) < 0 ) { SYSERROR ( ""unable<S2SV_blank>to<S2SV_blank>TIOCSTTY"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } if ( ( new_gid != 0 || options -> namespaces & CLONE_NEWUSER ) ) { if ( setgid ( new_gid ) || setgroups ( 0 , NULL ) ) { SYSERROR ( ""switching<S2SV_blank>to<S2SV_blank>container<S2SV_blank>gid"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } if ( ( new_uid != 0 || options -> namespaces & CLONE_NEWUSER ) && setuid ( new_uid ) ) { SYSERROR ( ""switching<S2SV_blank>to<S2SV_blank>container<S2SV_blank>uid"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } status = 1 ; ret = lxc_write_nointr ( ipc_socket , & status , sizeof ( status ) ) ; if ( ret != sizeof ( status ) ) {  ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(1)"" ) ;  shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } expected = 2 ; status = - 1 ; ret = lxc_read_nointr_expect ( ipc_socket , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) {  ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>final<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>(2)"" ) ;  shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } shutdown ( ipc_socket , SHUT_RDWR ) ; close ( ipc_socket ) ; if ( ( init_ctx -> container && init_ctx -> container -> lxc_conf && init_ctx -> container -> lxc_conf -> no_new_privs ) || ( options -> attach_flags & LXC_ATTACH_NO_NEW_PRIVS ) ) { if ( prctl ( PR_SET_NO_NEW_PRIVS , 1 , 0 , 0 , 0 ) < 0 ) { SYSERROR ( ""PR_SET_NO_NEW_PRIVS<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>set.<S2SV_blank>"" ""Process<S2SV_blank>can<S2SV_blank>use<S2SV_blank>execve()<S2SV_blank>gainable<S2SV_blank>"" ""privileges."" ) ;  rexit ( - 1 ) ;  } INFO ( ""PR_SET_NO_NEW_PRIVS<S2SV_blank>is<S2SV_blank>set.<S2SV_blank>Process<S2SV_blank>cannot<S2SV_blank>use<S2SV_blank>execve()<S2SV_blank>""  ""gainable<S2SV_blank>privileges."" ) ;  } if ( ( options -> namespaces & CLONE_NEWNS ) && ( options -> attach_flags & LXC_ATTACH_LSM ) && init_ctx -> lsm_label ) { int on_exec ;  on_exec = options -> attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0 ;   if ( lsm_set_label_at ( procfd , on_exec , init_ctx -> lsm_label ) < 0 ) {   rexit ( - 1 ) ;  } } if ( init_ctx -> container && init_ctx -> container -> lxc_conf && init_ctx -> container -> lxc_conf -> seccomp && ( lxc_seccomp_load ( init_ctx -> container -> lxc_conf ) != 0 ) ) { ERROR ( ""Loading<S2SV_blank>seccomp<S2SV_blank>policy"" ) ;  rexit ( - 1 ) ;  } lxc_proc_put_context_info ( init_ctx ) ; if ( options -> stdin_fd >= 0 && options -> stdin_fd != 0 ) dup2 ( options -> stdin_fd , 0 ) ; if ( options -> stdout_fd >= 0 && options -> stdout_fd != 1 ) dup2 ( options -> stdout_fd , 1 ) ; if ( options -> stderr_fd >= 0 && options -> stderr_fd != 2 ) dup2 ( options -> stderr_fd , 2 ) ; if ( options -> stdin_fd > 2 ) close ( options -> stdin_fd ) ; if ( options -> stdout_fd > 2 ) close ( options -> stdout_fd ) ; if ( options -> stderr_fd > 2 ) close ( options -> stderr_fd ) ; for ( fd = 0 ; fd <= 2 ; fd ++ ) { flags = fcntl ( fd , F_GETFL ) ; if ( flags < 0 ) continue ; if ( flags & FD_CLOEXEC ) if ( fcntl ( fd , F_SETFL , flags & ~ FD_CLOEXEC ) < 0 ) SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>clear<S2SV_blank>CLOEXEC<S2SV_blank>from<S2SV_blank>fd"" ) ; }  close ( procfd ) ;  rexit ( payload -> exec_function ( payload -> exec_payload ) ) ; }","ERROR ( ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(1):<S2SV_blank>%s."" , strerror ( errno ) ) ;ERROR ( ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>message<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>"" ""that<S2SV_blank>it<S2SV_blank>is<S2SV_blank>done<S2SV_blank>pre-initializing<S2SV_blank>(2):<S2SV_blank>%s"" , strerror ( errno ) ) ;",64
90,"buggy line: ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(1)"" ) ;shutdown ( ipc_socket , SHUT_RDWR ) ;ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>final<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>(2)"" ) ;shutdown ( ipc_socket , SHUT_RDWR ) ;cwe id:CWE-264context: static int attach_child_main ( void * data ) { struct attach_clone_payload * payload = ( struct attach_clone_payload * ) data ; int ipc_socket = payload -> ipc_socket ;  int procfd = payload -> procfd ;  lxc_attach_options_t * options = payload -> options ; struct lxc_proc_context_info * init_ctx = payload -> init_ctx ; # if HAVE_SYS_PERSONALITY_H long new_personality ; # endif int ret ; int status ; int expected ; long flags ; int fd ;  uid_t new_uid ;  gid_t new_gid ; expected = 0 ; status = - 1 ; ret = lxc_read_nointr_expect ( ipc_socket , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) {  ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>(0)"" ) ;  shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } if ( ! ( options -> namespaces & CLONE_NEWNS ) && ( options -> attach_flags & LXC_ATTACH_REMOUNT_PROC_SYS ) ) { ret = lxc_attach_remount_sys_proc ( ) ; if ( ret < 0 ) { shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } # if HAVE_SYS_PERSONALITY_H if ( options -> personality < 0 ) new_personality = init_ctx -> personality ; else new_personality = options -> personality ; if ( options -> attach_flags & LXC_ATTACH_SET_PERSONALITY ) { ret = personality ( new_personality ) ; if ( ret < 0 ) { SYSERROR ( ""could<S2SV_blank>not<S2SV_blank>ensure<S2SV_blank>correct<S2SV_blank>architecture"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } # endif if ( options -> attach_flags & LXC_ATTACH_DROP_CAPABILITIES ) { ret = lxc_attach_drop_privs ( init_ctx ) ; if ( ret < 0 ) { ERROR ( ""could<S2SV_blank>not<S2SV_blank>drop<S2SV_blank>privileges"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } ret = lxc_attach_set_environment ( options -> env_policy , options -> extra_env_vars , options -> extra_keep_env ) ; if ( ret < 0 ) { ERROR ( ""could<S2SV_blank>not<S2SV_blank>set<S2SV_blank>initial<S2SV_blank>environment<S2SV_blank>for<S2SV_blank>attached<S2SV_blank>process"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } new_uid = 0 ; new_gid = 0 ; if ( options -> namespaces & CLONE_NEWUSER ) lxc_attach_get_init_uidgid ( & new_uid , & new_gid ) ; if ( options -> uid != ( uid_t ) - 1 ) new_uid = options -> uid ; if ( options -> gid != ( gid_t ) - 1 ) new_gid = options -> gid ; if ( options -> stdin_fd && isatty ( options -> stdin_fd ) ) { if ( setsid ( ) < 0 ) { SYSERROR ( ""unable<S2SV_blank>to<S2SV_blank>setsid"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } if ( ioctl ( options -> stdin_fd , TIOCSCTTY , ( char * ) NULL ) < 0 ) { SYSERROR ( ""unable<S2SV_blank>to<S2SV_blank>TIOCSTTY"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } if ( ( new_gid != 0 || options -> namespaces & CLONE_NEWUSER ) ) { if ( setgid ( new_gid ) || setgroups ( 0 , NULL ) ) { SYSERROR ( ""switching<S2SV_blank>to<S2SV_blank>container<S2SV_blank>gid"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } if ( ( new_uid != 0 || options -> namespaces & CLONE_NEWUSER ) && setuid ( new_uid ) ) { SYSERROR ( ""switching<S2SV_blank>to<S2SV_blank>container<S2SV_blank>uid"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } status = 1 ; ret = lxc_write_nointr ( ipc_socket , & status , sizeof ( status ) ) ; if ( ret != sizeof ( status ) ) {  ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(1)"" ) ;  shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } expected = 2 ; status = - 1 ; ret = lxc_read_nointr_expect ( ipc_socket , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) {  ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>final<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>(2)"" ) ;  shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } shutdown ( ipc_socket , SHUT_RDWR ) ; close ( ipc_socket ) ; if ( ( init_ctx -> container && init_ctx -> container -> lxc_conf && init_ctx -> container -> lxc_conf -> no_new_privs ) || ( options -> attach_flags & LXC_ATTACH_NO_NEW_PRIVS ) ) { if ( prctl ( PR_SET_NO_NEW_PRIVS , 1 , 0 , 0 , 0 ) < 0 ) { SYSERROR ( ""PR_SET_NO_NEW_PRIVS<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>set.<S2SV_blank>"" ""Process<S2SV_blank>can<S2SV_blank>use<S2SV_blank>execve()<S2SV_blank>gainable<S2SV_blank>"" ""privileges."" ) ;  rexit ( - 1 ) ;  } INFO ( ""PR_SET_NO_NEW_PRIVS<S2SV_blank>is<S2SV_blank>set.<S2SV_blank>Process<S2SV_blank>cannot<S2SV_blank>use<S2SV_blank>execve()<S2SV_blank>""  ""gainable<S2SV_blank>privileges."" ) ;  } if ( ( options -> namespaces & CLONE_NEWNS ) && ( options -> attach_flags & LXC_ATTACH_LSM ) && init_ctx -> lsm_label ) { int on_exec ;  on_exec = options -> attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0 ;   if ( lsm_set_label_at ( procfd , on_exec , init_ctx -> lsm_label ) < 0 ) {   rexit ( - 1 ) ;  } } if ( init_ctx -> container && init_ctx -> container -> lxc_conf && init_ctx -> container -> lxc_conf -> seccomp && ( lxc_seccomp_load ( init_ctx -> container -> lxc_conf ) != 0 ) ) { ERROR ( ""Loading<S2SV_blank>seccomp<S2SV_blank>policy"" ) ;  rexit ( - 1 ) ;  } lxc_proc_put_context_info ( init_ctx ) ; if ( options -> stdin_fd >= 0 && options -> stdin_fd != 0 ) dup2 ( options -> stdin_fd , 0 ) ; if ( options -> stdout_fd >= 0 && options -> stdout_fd != 1 ) dup2 ( options -> stdout_fd , 1 ) ; if ( options -> stderr_fd >= 0 && options -> stderr_fd != 2 ) dup2 ( options -> stderr_fd , 2 ) ; if ( options -> stdin_fd > 2 ) close ( options -> stdin_fd ) ; if ( options -> stdout_fd > 2 ) close ( options -> stdout_fd ) ; if ( options -> stderr_fd > 2 ) close ( options -> stderr_fd ) ; for ( fd = 0 ; fd <= 2 ; fd ++ ) { flags = fcntl ( fd , F_GETFL ) ; if ( flags < 0 ) continue ; if ( flags & FD_CLOEXEC ) if ( fcntl ( fd , F_SETFL , flags & ~ FD_CLOEXEC ) < 0 ) SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>clear<S2SV_blank>CLOEXEC<S2SV_blank>from<S2SV_blank>fd"" ) ; }  close ( procfd ) ;  rexit ( payload -> exec_function ( payload -> exec_payload ) ) ; }","ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(1)"" ) ;shutdown ( ipc_socket , SHUT_RDWR ) ;ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>final<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>(2)"" ) ;shutdown ( ipc_socket , SHUT_RDWR ) ;",64
91,"buggy line: rexit ( - 1 ) ;}INFO ( ""PR_SET_NO_NEW_PRIVS<S2SV_blank>is<S2SV_blank>set.<S2SV_blank>Process<S2SV_blank>cannot<S2SV_blank>use<S2SV_blank>execve()<S2SV_blank>""  ""gainable<S2SV_blank>privileges."" ) ;}on_exec = options -> attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0 ;if ( lsm_set_label_at ( procfd , on_exec , init_ctx -> lsm_label ) < 0 ) {rexit ( - 1 ) ;}rexit ( - 1 ) ;}lxc_proc_put_context_info ( init_ctx ) ;if ( options -> stdin_fd >= 0 && options -> stdin_fd != 0 ) dup2 ( options -> stdin_fd , 0 ) ;if ( options -> stdout_fd >= 0 && options -> stdout_fd != 1 ) dup2 ( options -> stdout_fd , 1 ) ;if ( options -> stderr_fd >= 0 && options -> stderr_fd != 2 ) dup2 ( options -> stderr_fd , 2 ) ;if ( options -> stdin_fd > 2 ) close ( options -> stdin_fd ) ;if ( options -> stdout_fd > 2 ) close ( options -> stdout_fd ) ;if ( options -> stderr_fd > 2 ) close ( options -> stderr_fd ) ;for ( fd = 0 ;fd <= 2 ;fd ++ ) {flags = fcntl ( fd , F_GETFL ) ;if ( flags < 0 ) continue ;if ( flags & FD_CLOEXEC ) if ( fcntl ( fd , F_SETFL , flags & ~ FD_CLOEXEC ) < 0 ) SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>clear<S2SV_blank>CLOEXEC<S2SV_blank>from<S2SV_blank>fd"" ) ;}close ( procfd ) ;rexit ( payload -> exec_function ( payload -> exec_payload ) ) ;cwe id:CWE-264context: static int attach_child_main ( void * data ) { struct attach_clone_payload * payload = ( struct attach_clone_payload * ) data ; int ipc_socket = payload -> ipc_socket ;  int procfd = payload -> procfd ;  lxc_attach_options_t * options = payload -> options ; struct lxc_proc_context_info * init_ctx = payload -> init_ctx ; # if HAVE_SYS_PERSONALITY_H long new_personality ; # endif int ret ; int status ; int expected ; long flags ; int fd ;  uid_t new_uid ;  gid_t new_gid ; expected = 0 ; status = - 1 ; ret = lxc_read_nointr_expect ( ipc_socket , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) {  ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>(0)"" ) ;  shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } if ( ! ( options -> namespaces & CLONE_NEWNS ) && ( options -> attach_flags & LXC_ATTACH_REMOUNT_PROC_SYS ) ) { ret = lxc_attach_remount_sys_proc ( ) ; if ( ret < 0 ) { shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } # if HAVE_SYS_PERSONALITY_H if ( options -> personality < 0 ) new_personality = init_ctx -> personality ; else new_personality = options -> personality ; if ( options -> attach_flags & LXC_ATTACH_SET_PERSONALITY ) { ret = personality ( new_personality ) ; if ( ret < 0 ) { SYSERROR ( ""could<S2SV_blank>not<S2SV_blank>ensure<S2SV_blank>correct<S2SV_blank>architecture"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } # endif if ( options -> attach_flags & LXC_ATTACH_DROP_CAPABILITIES ) { ret = lxc_attach_drop_privs ( init_ctx ) ; if ( ret < 0 ) { ERROR ( ""could<S2SV_blank>not<S2SV_blank>drop<S2SV_blank>privileges"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } ret = lxc_attach_set_environment ( options -> env_policy , options -> extra_env_vars , options -> extra_keep_env ) ; if ( ret < 0 ) { ERROR ( ""could<S2SV_blank>not<S2SV_blank>set<S2SV_blank>initial<S2SV_blank>environment<S2SV_blank>for<S2SV_blank>attached<S2SV_blank>process"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } new_uid = 0 ; new_gid = 0 ; if ( options -> namespaces & CLONE_NEWUSER ) lxc_attach_get_init_uidgid ( & new_uid , & new_gid ) ; if ( options -> uid != ( uid_t ) - 1 ) new_uid = options -> uid ; if ( options -> gid != ( gid_t ) - 1 ) new_gid = options -> gid ; if ( options -> stdin_fd && isatty ( options -> stdin_fd ) ) { if ( setsid ( ) < 0 ) { SYSERROR ( ""unable<S2SV_blank>to<S2SV_blank>setsid"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } if ( ioctl ( options -> stdin_fd , TIOCSCTTY , ( char * ) NULL ) < 0 ) { SYSERROR ( ""unable<S2SV_blank>to<S2SV_blank>TIOCSTTY"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } if ( ( new_gid != 0 || options -> namespaces & CLONE_NEWUSER ) ) { if ( setgid ( new_gid ) || setgroups ( 0 , NULL ) ) { SYSERROR ( ""switching<S2SV_blank>to<S2SV_blank>container<S2SV_blank>gid"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } if ( ( new_uid != 0 || options -> namespaces & CLONE_NEWUSER ) && setuid ( new_uid ) ) { SYSERROR ( ""switching<S2SV_blank>to<S2SV_blank>container<S2SV_blank>uid"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } status = 1 ; ret = lxc_write_nointr ( ipc_socket , & status , sizeof ( status ) ) ; if ( ret != sizeof ( status ) ) {  ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(1)"" ) ;  shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } expected = 2 ; status = - 1 ; ret = lxc_read_nointr_expect ( ipc_socket , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) {  ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>final<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>(2)"" ) ;  shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } shutdown ( ipc_socket , SHUT_RDWR ) ; close ( ipc_socket ) ; if ( ( init_ctx -> container && init_ctx -> container -> lxc_conf && init_ctx -> container -> lxc_conf -> no_new_privs ) || ( options -> attach_flags & LXC_ATTACH_NO_NEW_PRIVS ) ) { if ( prctl ( PR_SET_NO_NEW_PRIVS , 1 , 0 , 0 , 0 ) < 0 ) { SYSERROR ( ""PR_SET_NO_NEW_PRIVS<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>set.<S2SV_blank>"" ""Process<S2SV_blank>can<S2SV_blank>use<S2SV_blank>execve()<S2SV_blank>gainable<S2SV_blank>"" ""privileges."" ) ;  rexit ( - 1 ) ;  } INFO ( ""PR_SET_NO_NEW_PRIVS<S2SV_blank>is<S2SV_blank>set.<S2SV_blank>Process<S2SV_blank>cannot<S2SV_blank>use<S2SV_blank>execve()<S2SV_blank>""  ""gainable<S2SV_blank>privileges."" ) ;  } if ( ( options -> namespaces & CLONE_NEWNS ) && ( options -> attach_flags & LXC_ATTACH_LSM ) && init_ctx -> lsm_label ) { int on_exec ;  on_exec = options -> attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0 ;   if ( lsm_set_label_at ( procfd , on_exec , init_ctx -> lsm_label ) < 0 ) {   rexit ( - 1 ) ;  } } if ( init_ctx -> container && init_ctx -> container -> lxc_conf && init_ctx -> container -> lxc_conf -> seccomp && ( lxc_seccomp_load ( init_ctx -> container -> lxc_conf ) != 0 ) ) { ERROR ( ""Loading<S2SV_blank>seccomp<S2SV_blank>policy"" ) ;  rexit ( - 1 ) ;  } lxc_proc_put_context_info ( init_ctx ) ; if ( options -> stdin_fd >= 0 && options -> stdin_fd != 0 ) dup2 ( options -> stdin_fd , 0 ) ; if ( options -> stdout_fd >= 0 && options -> stdout_fd != 1 ) dup2 ( options -> stdout_fd , 1 ) ; if ( options -> stderr_fd >= 0 && options -> stderr_fd != 2 ) dup2 ( options -> stderr_fd , 2 ) ; if ( options -> stdin_fd > 2 ) close ( options -> stdin_fd ) ; if ( options -> stdout_fd > 2 ) close ( options -> stdout_fd ) ; if ( options -> stderr_fd > 2 ) close ( options -> stderr_fd ) ; for ( fd = 0 ; fd <= 2 ; fd ++ ) { flags = fcntl ( fd , F_GETFL ) ; if ( flags < 0 ) continue ; if ( flags & FD_CLOEXEC ) if ( fcntl ( fd , F_SETFL , flags & ~ FD_CLOEXEC ) < 0 ) SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>clear<S2SV_blank>CLOEXEC<S2SV_blank>from<S2SV_blank>fd"" ) ; }  close ( procfd ) ;  rexit ( payload -> exec_function ( payload -> exec_payload ) ) ; }","shutdown ( ipc_socket , SHUT_RDWR ) ;rexit ( - 1 ) ;}INFO ( ""PR_SET_NO_NEW_PRIVS<S2SV_blank>is<S2SV_blank>set.<S2SV_blank>Process<S2SV_blank>cannot<S2SV_blank>use<S2SV_blank>execve()<S2SV_blank>"" ""gainable<S2SV_blank>privileges."" ) ;}status = 3 ;ret = lxc_write_nointr ( ipc_socket , & status , sizeof ( status ) ) ;if ( ret <= 0 ) {ERROR ( ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>tell<S2SV_blank>parent<S2SV_blank>to<S2SV_blank>set<S2SV_blank>up<S2SV_blank>LSM<S2SV_blank>labels<S2SV_blank>(3):<S2SV_blank>%s."" , strerror ( errno ) ) ;shutdown ( ipc_socket , SHUT_RDWR ) ;rexit ( - 1 ) ;}ret = lxc_abstract_unix_recv_fd ( ipc_socket , & lsm_labelfd , NULL , 0 ) ;if ( ret <= 0 ) {ERROR ( ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>for<S2SV_blank>parent<S2SV_blank>to<S2SV_blank>tell<S2SV_blank>us<S2SV_blank>LSM<S2SV_blank>label<S2SV_blank>fd<S2SV_blank>(4):<S2SV_blank>%s."" , strerror ( errno ) ) ;shutdown ( ipc_socket , SHUT_RDWR ) ;rexit ( - 1 ) ;}on_exec = options -> attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0 ;if ( lsm_set_label_at ( lsm_labelfd , on_exec , init_ctx -> lsm_label ) < 0 ) {SYSERROR ( ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>LSM<S2SV_blank>label."" ) ;shutdown ( ipc_socket , SHUT_RDWR ) ;close ( lsm_labelfd ) ;rexit ( - 1 ) ;}close ( lsm_labelfd ) ;shutdown ( ipc_socket , SHUT_RDWR ) ;rexit ( - 1 ) ;}rexit ( payload -> exec_function ( payload -> exec_payload ) ) ;",64
92,"buggy line: line += 3 ;if ( ! ( ptr = strchr ( line , '<S2SV_blank>' ) ) )  goto out_err ;line = ptr + 1 ;if ( ! ( ptr = strchr ( line , '\\\cwe id:CWE-125context: static int ng_pkt ( git_pkt * * out , const char * line , size_t len ) { git_pkt_ng * pkt ; const char * ptr ; size_t alloclen ; pkt = git__malloc ( sizeof ( * pkt ) ) ; GITERR_CHECK_ALLOC ( pkt ) ; pkt -> ref = NULL ; pkt -> type = GIT_PKT_NG ;  line += 3 ;   if ( ! ( ptr = strchr ( line , '<S2SV_blank>' ) ) )  goto out_err ; len = ptr - line ; GITERR_CHECK_ALLOC_ADD ( & alloclen , len , 1 ) ; pkt -> ref = git__malloc ( alloclen ) ; GITERR_CHECK_ALLOC ( pkt -> ref ) ; memcpy ( pkt -> ref , line , len ) ; pkt -> ref [ len ] = '\\0' ;  line = ptr + 1 ;   if ( ! ( ptr = strchr ( line , '\\n' ) ) )  goto out_err ; len = ptr - line ; GITERR_CHECK_ALLOC_ADD ( & alloclen , len , 1 ) ; pkt -> msg = git__malloc ( alloclen ) ; GITERR_CHECK_ALLOC ( pkt -> msg ) ; memcpy ( pkt -> msg , line , len ) ; pkt -> msg [ len ] = '\\0' ; * out = ( git_pkt * ) pkt ; return 0 ; out_err : giterr_set ( GITERR_NET , ""invalid<S2SV_blank>packet<S2SV_blank>line"" ) ; git__free ( pkt -> ref ) ; git__free ( pkt ) ; return - 1 ; }","if ( len < 3 ) goto out_err ;line += 3 ;len -= 3 ;if ( ! ( ptr = memchr ( line , '<S2SV_blank>' , len ) ) ) goto out_err ;if ( len < 1 ) goto out_err ;line = ptr + 1 ;len -= 1 ;if ( ! ( ptr = memchr ( line , '\\\",65
93,"buggy line: switch ( header -> biSize ) {cwe id:CWE-119context: static OPJ_BOOL bmp_read_info_header ( FILE * IN , OPJ_BITMAPINFOHEADER * header ) { memset ( header , 0 , sizeof ( * header ) ) ; header -> biSize = ( OPJ_UINT32 ) getc ( IN ) ; header -> biSize |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biSize |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biSize |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; switch ( header -> biSize ) { case 12U : case 40U : case 52U : case 56U : case 108U : case 124U : break ; default : fprintf ( stderr , ""Error,<S2SV_blank>unknown<S2SV_blank>BMP<S2SV_blank>header<S2SV_blank>size<S2SV_blank>%d\\n"" , header -> biSize ) ; return OPJ_FALSE ; } header -> biWidth = ( OPJ_UINT32 ) getc ( IN ) ; header -> biWidth |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biWidth |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biWidth |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; header -> biHeight = ( OPJ_UINT32 ) getc ( IN ) ; header -> biHeight |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biHeight |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biHeight |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; header -> biPlanes = ( OPJ_UINT16 ) getc ( IN ) ; header -> biPlanes |= ( OPJ_UINT16 ) ( ( OPJ_UINT32 ) getc ( IN ) << 8 ) ; header -> biBitCount = ( OPJ_UINT16 ) getc ( IN ) ; header -> biBitCount |= ( OPJ_UINT16 ) ( ( OPJ_UINT32 ) getc ( IN ) << 8 ) ;  if ( header -> biSize >= 40U ) {  header -> biCompression = ( OPJ_UINT32 ) getc ( IN ) ; header -> biCompression |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biCompression |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biCompression |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; header -> biSizeImage = ( OPJ_UINT32 ) getc ( IN ) ; header -> biSizeImage |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biSizeImage |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biSizeImage |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; header -> biXpelsPerMeter = ( OPJ_UINT32 ) getc ( IN ) ; header -> biXpelsPerMeter |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biXpelsPerMeter |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biXpelsPerMeter |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; header -> biYpelsPerMeter = ( OPJ_UINT32 ) getc ( IN ) ; header -> biYpelsPerMeter |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biYpelsPerMeter |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biYpelsPerMeter |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; header -> biClrUsed = ( OPJ_UINT32 ) getc ( IN ) ; header -> biClrUsed |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biClrUsed |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biClrUsed |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; header -> biClrImportant = ( OPJ_UINT32 ) getc ( IN ) ; header -> biClrImportant |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biClrImportant |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biClrImportant |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; } if ( header -> biSize >= 56U ) { header -> biRedMask = ( OPJ_UINT32 ) getc ( IN ) ; header -> biRedMask |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biRedMask |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biRedMask |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; header -> biGreenMask = ( OPJ_UINT32 ) getc ( IN ) ; header -> biGreenMask |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biGreenMask |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biGreenMask |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; header -> biBlueMask = ( OPJ_UINT32 ) getc ( IN ) ; header -> biBlueMask |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biBlueMask |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biBlueMask |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; header -> biAlphaMask = ( OPJ_UINT32 ) getc ( IN ) ; header -> biAlphaMask |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biAlphaMask |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biAlphaMask |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; } if ( header -> biSize >= 108U ) { header -> biColorSpaceType = ( OPJ_UINT32 ) getc ( IN ) ; header -> biColorSpaceType |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biColorSpaceType |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biColorSpaceType |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; if ( fread ( & ( header -> biColorSpaceEP ) , 1U , sizeof ( header -> biColorSpaceEP ) , IN ) != sizeof ( header -> biColorSpaceEP ) ) { fprintf ( stderr , ""Error,<S2SV_blank>can\'t<S2SV_blank><S2SV_blank>read<S2SV_blank>BMP<S2SV_blank>header\\n"" ) ; return OPJ_FALSE ; } header -> biRedGamma = ( OPJ_UINT32 ) getc ( IN ) ; header -> biRedGamma |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biRedGamma |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biRedGamma |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; header -> biGreenGamma = ( OPJ_UINT32 ) getc ( IN ) ; header -> biGreenGamma |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biGreenGamma |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biGreenGamma |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; header -> biBlueGamma = ( OPJ_UINT32 ) getc ( IN ) ; header -> biBlueGamma |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biBlueGamma |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biBlueGamma |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; } if ( header -> biSize >= 124U ) { header -> biIntent = ( OPJ_UINT32 ) getc ( IN ) ; header -> biIntent |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biIntent |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biIntent |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; header -> biIccProfileData = ( OPJ_UINT32 ) getc ( IN ) ; header -> biIccProfileData |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biIccProfileData |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biIccProfileData |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; header -> biIccProfileSize = ( OPJ_UINT32 ) getc ( IN ) ; header -> biIccProfileSize |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biIccProfileSize |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biIccProfileSize |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; header -> biReserved = ( OPJ_UINT32 ) getc ( IN ) ; header -> biReserved |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biReserved |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biReserved |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; } return OPJ_TRUE ; }","switch ( header -> biBitCount == 0 ) {fprintf ( stderr , ""Error,<S2SV_blank>invalid<S2SV_blank>biBitCount<S2SV_blank>%d\\\return OPJ_FALSE ;}if ( header -> biSize ) {",66
94,"buggy line: if ( header -> biSize >= 40U ) {header -> biCompression = ( OPJ_UINT32 ) getc ( IN ) ;cwe id:CWE-119context: static OPJ_BOOL bmp_read_info_header ( FILE * IN , OPJ_BITMAPINFOHEADER * header ) { memset ( header , 0 , sizeof ( * header ) ) ; header -> biSize = ( OPJ_UINT32 ) getc ( IN ) ; header -> biSize |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biSize |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biSize |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; switch ( header -> biSize ) { case 12U : case 40U : case 52U : case 56U : case 108U : case 124U : break ; default : fprintf ( stderr , ""Error,<S2SV_blank>unknown<S2SV_blank>BMP<S2SV_blank>header<S2SV_blank>size<S2SV_blank>%d\\n"" , header -> biSize ) ; return OPJ_FALSE ; } header -> biWidth = ( OPJ_UINT32 ) getc ( IN ) ; header -> biWidth |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biWidth |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biWidth |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; header -> biHeight = ( OPJ_UINT32 ) getc ( IN ) ; header -> biHeight |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biHeight |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biHeight |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; header -> biPlanes = ( OPJ_UINT16 ) getc ( IN ) ; header -> biPlanes |= ( OPJ_UINT16 ) ( ( OPJ_UINT32 ) getc ( IN ) << 8 ) ; header -> biBitCount = ( OPJ_UINT16 ) getc ( IN ) ; header -> biBitCount |= ( OPJ_UINT16 ) ( ( OPJ_UINT32 ) getc ( IN ) << 8 ) ;  if ( header -> biSize >= 40U ) {  header -> biCompression = ( OPJ_UINT32 ) getc ( IN ) ; header -> biCompression |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biCompression |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biCompression |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; header -> biSizeImage = ( OPJ_UINT32 ) getc ( IN ) ; header -> biSizeImage |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biSizeImage |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biSizeImage |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; header -> biXpelsPerMeter = ( OPJ_UINT32 ) getc ( IN ) ; header -> biXpelsPerMeter |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biXpelsPerMeter |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biXpelsPerMeter |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; header -> biYpelsPerMeter = ( OPJ_UINT32 ) getc ( IN ) ; header -> biYpelsPerMeter |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biYpelsPerMeter |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biYpelsPerMeter |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; header -> biClrUsed = ( OPJ_UINT32 ) getc ( IN ) ; header -> biClrUsed |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biClrUsed |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biClrUsed |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; header -> biClrImportant = ( OPJ_UINT32 ) getc ( IN ) ; header -> biClrImportant |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biClrImportant |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biClrImportant |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; } if ( header -> biSize >= 56U ) { header -> biRedMask = ( OPJ_UINT32 ) getc ( IN ) ; header -> biRedMask |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biRedMask |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biRedMask |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; header -> biGreenMask = ( OPJ_UINT32 ) getc ( IN ) ; header -> biGreenMask |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biGreenMask |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biGreenMask |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; header -> biBlueMask = ( OPJ_UINT32 ) getc ( IN ) ; header -> biBlueMask |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biBlueMask |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biBlueMask |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; header -> biAlphaMask = ( OPJ_UINT32 ) getc ( IN ) ; header -> biAlphaMask |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biAlphaMask |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biAlphaMask |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; } if ( header -> biSize >= 108U ) { header -> biColorSpaceType = ( OPJ_UINT32 ) getc ( IN ) ; header -> biColorSpaceType |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biColorSpaceType |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biColorSpaceType |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; if ( fread ( & ( header -> biColorSpaceEP ) , 1U , sizeof ( header -> biColorSpaceEP ) , IN ) != sizeof ( header -> biColorSpaceEP ) ) { fprintf ( stderr , ""Error,<S2SV_blank>can\'t<S2SV_blank><S2SV_blank>read<S2SV_blank>BMP<S2SV_blank>header\\n"" ) ; return OPJ_FALSE ; } header -> biRedGamma = ( OPJ_UINT32 ) getc ( IN ) ; header -> biRedGamma |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biRedGamma |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biRedGamma |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; header -> biGreenGamma = ( OPJ_UINT32 ) getc ( IN ) ; header -> biGreenGamma |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biGreenGamma |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biGreenGamma |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; header -> biBlueGamma = ( OPJ_UINT32 ) getc ( IN ) ; header -> biBlueGamma |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biBlueGamma |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biBlueGamma |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; } if ( header -> biSize >= 124U ) { header -> biIntent = ( OPJ_UINT32 ) getc ( IN ) ; header -> biIntent |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biIntent |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biIntent |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; header -> biIccProfileData = ( OPJ_UINT32 ) getc ( IN ) ; header -> biIccProfileData |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biIccProfileData |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biIccProfileData |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; header -> biIccProfileSize = ( OPJ_UINT32 ) getc ( IN ) ; header -> biIccProfileSize |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biIccProfileSize |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biIccProfileSize |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; header -> biReserved = ( OPJ_UINT32 ) getc ( IN ) ; header -> biReserved |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biReserved |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biReserved |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; } return OPJ_TRUE ; }",if ( header -> biSize >= 40U ) {header -> biCompression = ( OPJ_UINT32 ) getc ( IN ) ;,66
95,"buggy line: SAS_DPRINTK ( ""DONE<S2SV_blank>DISCOVERY<S2SV_blank>on<S2SV_blank>port<S2SV_blank>%d,<S2SV_blank>pid:%d,<S2SV_blank>result:%d\\\cwe id:CWE-000context: static void sas_discover_domain ( struct work_struct * work ) { struct domain_device * dev ; int error = 0 ; struct sas_discovery_event * ev = to_sas_discovery_event ( work ) ; struct asd_sas_port * port = ev -> port ; clear_bit ( DISCE_DISCOVER_DOMAIN , & port -> disc . pending ) ; if ( port -> port_dev ) return ; error = sas_get_port_device ( port ) ; if ( error ) return ; dev = port -> port_dev ; SAS_DPRINTK ( ""DOING<S2SV_blank>DISCOVERY<S2SV_blank>on<S2SV_blank>port<S2SV_blank>%d,<S2SV_blank>pid:%d\\n"" , port -> id , task_pid_nr ( current ) ) ; switch ( dev -> dev_type ) { case SAS_END_DEVICE : error = sas_discover_end_dev ( dev ) ; break ; case SAS_EDGE_EXPANDER_DEVICE : case SAS_FANOUT_EXPANDER_DEVICE : error = sas_discover_root_expander ( dev ) ; break ; case SAS_SATA_DEV : case SAS_SATA_PM : # ifdef CONFIG_SCSI_SAS_ATA error = sas_discover_sata ( dev ) ; break ; # else SAS_DPRINTK ( ""ATA<S2SV_blank>device<S2SV_blank>seen<S2SV_blank>but<S2SV_blank>CONFIG_SCSI_SAS_ATA=N<S2SV_blank>so<S2SV_blank>cannot<S2SV_blank>attach\\n"" ) ; # endif default : error = - ENXIO ; SAS_DPRINTK ( ""unhandled<S2SV_blank>device<S2SV_blank>%d\\n"" , dev -> dev_type ) ; break ; } if ( error ) { sas_rphy_free ( dev -> rphy ) ; list_del_init ( & dev -> disco_list_node ) ; spin_lock_irq ( & port -> dev_list_lock ) ; list_del_init ( & dev -> dev_list_node ) ; spin_unlock_irq ( & port -> dev_list_lock ) ; sas_put_device ( dev ) ; port -> port_dev = NULL ; }  SAS_DPRINTK ( ""DONE<S2SV_blank>DISCOVERY<S2SV_blank>on<S2SV_blank>port<S2SV_blank>%d,<S2SV_blank>pid:%d,<S2SV_blank>result:%d\\n"" , port -> id ,  task_pid_nr ( current ) , error ) ; }","sas_probe_devices ( port ) ;SAS_DPRINTK ( ""DONE<S2SV_blank>DISCOVERY<S2SV_blank>on<S2SV_blank>port<S2SV_blank>%d,<S2SV_blank>pid:%d,<S2SV_blank>result:%d\\\",67
96,"buggy line: cwe id:CWE-415context: static Image * ReadTGAImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; PixelInfo pixel ; Quantum index ; register Quantum * q ; register ssize_t i , x ; size_t base , flag , offset , real , skip ; ssize_t count , y ; TGAInfo tga_info ; unsigned char j , k , pixels [ 4 ] , runlength ; unsigned int alpha_bits ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } count = ReadBlob ( image , 1 , & tga_info . id_length ) ; tga_info . colormap_type = ( unsigned char ) ReadBlobByte ( image ) ; tga_info . image_type = ( TGAImageType ) ReadBlobByte ( image ) ; if ( ( count != 1 ) || ( ( tga_info . image_type != TGAColormap ) && ( tga_info . image_type != TGARGB ) && ( tga_info . image_type != TGAMonochrome ) && ( tga_info . image_type != TGARLEColormap ) && ( tga_info . image_type != TGARLERGB ) && ( tga_info . image_type != TGARLEMonochrome ) ) || ( ( ( tga_info . image_type == TGAColormap ) || ( tga_info . image_type == TGARLEColormap ) ) && ( tga_info . colormap_type == 0 ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; tga_info . colormap_index = ReadBlobLSBShort ( image ) ; tga_info . colormap_length = ReadBlobLSBShort ( image ) ; tga_info . colormap_size = ( unsigned char ) ReadBlobByte ( image ) ; tga_info . x_origin = ReadBlobLSBShort ( image ) ; tga_info . y_origin = ReadBlobLSBShort ( image ) ; tga_info . width = ( unsigned short ) ReadBlobLSBShort ( image ) ; tga_info . height = ( unsigned short ) ReadBlobLSBShort ( image ) ; tga_info . bits_per_pixel = ( unsigned char ) ReadBlobByte ( image ) ; tga_info . attributes = ( unsigned char ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; if ( ( ( ( tga_info . bits_per_pixel <= 1 ) || ( tga_info . bits_per_pixel >= 17 ) ) && ( tga_info . bits_per_pixel != 24 ) && ( tga_info . bits_per_pixel != 32 ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> columns = tga_info . width ; image -> rows = tga_info . height ; alpha_bits = ( tga_info . attributes & 0x0FU ) ; image -> alpha_trait = ( alpha_bits > 0 ) || ( tga_info . bits_per_pixel == 32 ) || ( tga_info . colormap_size == 32 ) ? BlendPixelTrait : UndefinedPixelTrait ; if ( ( tga_info . image_type != TGAColormap ) && ( tga_info . image_type != TGARLEColormap ) ) image -> depth = ( size_t ) ( ( tga_info . bits_per_pixel <= 8 ) ? 8 : ( tga_info . bits_per_pixel <= 16 ) ? 5 : ( tga_info . bits_per_pixel == 24 ) ? 8 : ( tga_info . bits_per_pixel == 32 ) ? 8 : 8 ) ; else image -> depth = ( size_t ) ( ( tga_info . colormap_size <= 8 ) ? 8 : ( tga_info . colormap_size <= 16 ) ? 5 : ( tga_info . colormap_size == 24 ) ? 8 : ( tga_info . colormap_size == 32 ) ? 8 : 8 ) ; if ( ( tga_info . image_type == TGAColormap ) || ( tga_info . image_type == TGAMonochrome ) || ( tga_info . image_type == TGARLEColormap ) || ( tga_info . image_type == TGARLEMonochrome ) ) image -> storage_class = PseudoClass ; image -> compression = NoCompression ; if ( ( tga_info . image_type == TGARLEColormap ) || ( tga_info . image_type == TGARLEMonochrome ) || ( tga_info . image_type == TGARLERGB ) ) image -> compression = RLECompression ; if ( image -> storage_class == PseudoClass ) { if ( tga_info . colormap_type != 0 ) image -> colors = tga_info . colormap_index + tga_info . colormap_length ; else { size_t one ; one = 1 ; image -> colors = one << tga_info . bits_per_pixel ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } } if ( tga_info . id_length != 0 ) { char * comment ; size_t length ; length = ( size_t ) tga_info . id_length ; comment = ( char * ) NULL ; if ( ~ length >= ( MagickPathExtent - 1 ) ) comment = ( char * ) AcquireQuantumMemory ( length + MagickPathExtent , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , tga_info . id_length , ( unsigned char * ) comment ) ; comment [ tga_info . id_length ] = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment , exception ) ; comment = DestroyString ( comment ) ; } if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( image ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; ( void ) ResetMagickMemory ( & pixel , 0 , sizeof ( pixel ) ) ; pixel . alpha = ( MagickRealType ) OpaqueAlpha ; if ( tga_info . colormap_type != 0 )  {  if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) tga_info . colormap_index ; i ++ ) image -> colormap [ i ] = pixel ; for ( ; i < ( ssize_t ) image -> colors ; i ++ ) { switch ( tga_info . colormap_size ) { case 8 : default : { pixel . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; pixel . green = pixel . red ; pixel . blue = pixel . red ; break ; } case 15 : case 16 : { QuantumAny range ; j = ( unsigned char ) ReadBlobByte ( image ) ; k = ( unsigned char ) ReadBlobByte ( image ) ; range = GetQuantumRange ( 5UL ) ; pixel . red = ( MagickRealType ) ScaleAnyToQuantum ( 1UL * ( k & 0x7c ) >> 2 , range ) ; pixel . green = ( MagickRealType ) ScaleAnyToQuantum ( ( 1UL * ( k & 0x03 ) << 3 ) + ( 1UL * ( j & 0xe0 ) >> 5 ) , range ) ; pixel . blue = ( MagickRealType ) ScaleAnyToQuantum ( 1UL * ( j & 0x1f ) , range ) ; break ; } case 24 : { pixel . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; pixel . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; pixel . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; break ; } case 32 : { pixel . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; pixel . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; pixel . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; pixel . alpha = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; break ; } } image -> colormap [ i ] = pixel ; } } base = 0 ; flag = 0 ; skip = MagickFalse ; real = 0 ; index = 0 ; runlength = 0 ; offset = 0 ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { real = offset ; if ( ( ( unsigned char ) ( tga_info . attributes & 0x20 ) >> 5 ) == 0 ) real = image -> rows - real - 1 ; q = QueueAuthenticPixels ( image , 0 , ( ssize_t ) real , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( ( tga_info . image_type == TGARLEColormap ) || ( tga_info . image_type == TGARLERGB ) || ( tga_info . image_type == TGARLEMonochrome ) ) { if ( runlength != 0 ) { runlength -- ; skip = flag != 0 ; } else { count = ReadBlob ( image , 1 , & runlength ) ; if ( count != 1 ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; flag = runlength & 0x80 ; if ( flag != 0 ) runlength -= 128 ; skip = MagickFalse ; } } if ( skip == MagickFalse ) switch ( tga_info . bits_per_pixel ) { case 8 : default : { index = ( Quantum ) ReadBlobByte ( image ) ; if ( tga_info . colormap_type != 0 ) pixel = image -> colormap [ ( ssize_t ) ConstrainColormapIndex ( image , ( ssize_t ) index , exception ) ] ; else { pixel . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) index ) ; pixel . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) index ) ; pixel . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) index ) ; } break ; } case 15 : case 16 : { QuantumAny range ; if ( ReadBlob ( image , 2 , pixels ) != 2 ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; j = pixels [ 0 ] ; k = pixels [ 1 ] ; range = GetQuantumRange ( 5UL ) ; pixel . red = ( MagickRealType ) ScaleAnyToQuantum ( 1UL * ( k & 0x7c ) >> 2 , range ) ; pixel . green = ( MagickRealType ) ScaleAnyToQuantum ( ( 1UL * ( k & 0x03 ) << 3 ) + ( 1UL * ( j & 0xe0 ) >> 5 ) , range ) ; pixel . blue = ( MagickRealType ) ScaleAnyToQuantum ( 1UL * ( j & 0x1f ) , range ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) pixel . alpha = ( MagickRealType ) ( ( k & 0x80 ) == 0 ? ( Quantum ) TransparentAlpha : ( Quantum ) OpaqueAlpha ) ; if ( image -> storage_class == PseudoClass ) index = ( Quantum ) ConstrainColormapIndex ( image , ( ( ssize_t ) ( k << 8 ) ) + j , exception ) ; break ; } case 24 : { if ( ReadBlob ( image , 3 , pixels ) != 3 ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; pixel . blue = ( MagickRealType ) ScaleCharToQuantum ( pixels [ 0 ] ) ; pixel . green = ( MagickRealType ) ScaleCharToQuantum ( pixels [ 1 ] ) ; pixel . red = ( MagickRealType ) ScaleCharToQuantum ( pixels [ 2 ] ) ; break ; } case 32 : { if ( ReadBlob ( image , 4 , pixels ) != 4 ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; pixel . blue = ( MagickRealType ) ScaleCharToQuantum ( pixels [ 0 ] ) ; pixel . green = ( MagickRealType ) ScaleCharToQuantum ( pixels [ 1 ] ) ; pixel . red = ( MagickRealType ) ScaleCharToQuantum ( pixels [ 2 ] ) ; pixel . alpha = ( MagickRealType ) ScaleCharToQuantum ( pixels [ 3 ] ) ; break ; } } if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; if ( image -> storage_class == PseudoClass ) SetPixelIndex ( image , index , q ) ; SetPixelRed ( image , ClampToQuantum ( pixel . red ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( pixel . green ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( pixel . blue ) , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ClampToQuantum ( pixel . alpha ) , q ) ; q += GetPixelChannels ( image ) ; } if ( ( ( unsigned char ) ( tga_info . attributes & 0xc0 ) >> 6 ) == 2 ) offset += 2 ; else offset ++ ; if ( offset >= image -> rows ) { base ++ ; offset = base ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }",if ( image -> colors < tga_info . colormap_index ) image -> colors = tga_info . colormap_index ;,68
97,"buggy line: if ( tga_info . colormap_type != 0 )  {if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;cwe id:CWE-415context: static Image * ReadTGAImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; PixelInfo pixel ; Quantum index ; register Quantum * q ; register ssize_t i , x ; size_t base , flag , offset , real , skip ; ssize_t count , y ; TGAInfo tga_info ; unsigned char j , k , pixels [ 4 ] , runlength ; unsigned int alpha_bits ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } count = ReadBlob ( image , 1 , & tga_info . id_length ) ; tga_info . colormap_type = ( unsigned char ) ReadBlobByte ( image ) ; tga_info . image_type = ( TGAImageType ) ReadBlobByte ( image ) ; if ( ( count != 1 ) || ( ( tga_info . image_type != TGAColormap ) && ( tga_info . image_type != TGARGB ) && ( tga_info . image_type != TGAMonochrome ) && ( tga_info . image_type != TGARLEColormap ) && ( tga_info . image_type != TGARLERGB ) && ( tga_info . image_type != TGARLEMonochrome ) ) || ( ( ( tga_info . image_type == TGAColormap ) || ( tga_info . image_type == TGARLEColormap ) ) && ( tga_info . colormap_type == 0 ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; tga_info . colormap_index = ReadBlobLSBShort ( image ) ; tga_info . colormap_length = ReadBlobLSBShort ( image ) ; tga_info . colormap_size = ( unsigned char ) ReadBlobByte ( image ) ; tga_info . x_origin = ReadBlobLSBShort ( image ) ; tga_info . y_origin = ReadBlobLSBShort ( image ) ; tga_info . width = ( unsigned short ) ReadBlobLSBShort ( image ) ; tga_info . height = ( unsigned short ) ReadBlobLSBShort ( image ) ; tga_info . bits_per_pixel = ( unsigned char ) ReadBlobByte ( image ) ; tga_info . attributes = ( unsigned char ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; if ( ( ( ( tga_info . bits_per_pixel <= 1 ) || ( tga_info . bits_per_pixel >= 17 ) ) && ( tga_info . bits_per_pixel != 24 ) && ( tga_info . bits_per_pixel != 32 ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> columns = tga_info . width ; image -> rows = tga_info . height ; alpha_bits = ( tga_info . attributes & 0x0FU ) ; image -> alpha_trait = ( alpha_bits > 0 ) || ( tga_info . bits_per_pixel == 32 ) || ( tga_info . colormap_size == 32 ) ? BlendPixelTrait : UndefinedPixelTrait ; if ( ( tga_info . image_type != TGAColormap ) && ( tga_info . image_type != TGARLEColormap ) ) image -> depth = ( size_t ) ( ( tga_info . bits_per_pixel <= 8 ) ? 8 : ( tga_info . bits_per_pixel <= 16 ) ? 5 : ( tga_info . bits_per_pixel == 24 ) ? 8 : ( tga_info . bits_per_pixel == 32 ) ? 8 : 8 ) ; else image -> depth = ( size_t ) ( ( tga_info . colormap_size <= 8 ) ? 8 : ( tga_info . colormap_size <= 16 ) ? 5 : ( tga_info . colormap_size == 24 ) ? 8 : ( tga_info . colormap_size == 32 ) ? 8 : 8 ) ; if ( ( tga_info . image_type == TGAColormap ) || ( tga_info . image_type == TGAMonochrome ) || ( tga_info . image_type == TGARLEColormap ) || ( tga_info . image_type == TGARLEMonochrome ) ) image -> storage_class = PseudoClass ; image -> compression = NoCompression ; if ( ( tga_info . image_type == TGARLEColormap ) || ( tga_info . image_type == TGARLEMonochrome ) || ( tga_info . image_type == TGARLERGB ) ) image -> compression = RLECompression ; if ( image -> storage_class == PseudoClass ) { if ( tga_info . colormap_type != 0 ) image -> colors = tga_info . colormap_index + tga_info . colormap_length ; else { size_t one ; one = 1 ; image -> colors = one << tga_info . bits_per_pixel ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } } if ( tga_info . id_length != 0 ) { char * comment ; size_t length ; length = ( size_t ) tga_info . id_length ; comment = ( char * ) NULL ; if ( ~ length >= ( MagickPathExtent - 1 ) ) comment = ( char * ) AcquireQuantumMemory ( length + MagickPathExtent , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , tga_info . id_length , ( unsigned char * ) comment ) ; comment [ tga_info . id_length ] = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment , exception ) ; comment = DestroyString ( comment ) ; } if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( image ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; ( void ) ResetMagickMemory ( & pixel , 0 , sizeof ( pixel ) ) ; pixel . alpha = ( MagickRealType ) OpaqueAlpha ; if ( tga_info . colormap_type != 0 )  {  if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) tga_info . colormap_index ; i ++ ) image -> colormap [ i ] = pixel ; for ( ; i < ( ssize_t ) image -> colors ; i ++ ) { switch ( tga_info . colormap_size ) { case 8 : default : { pixel . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; pixel . green = pixel . red ; pixel . blue = pixel . red ; break ; } case 15 : case 16 : { QuantumAny range ; j = ( unsigned char ) ReadBlobByte ( image ) ; k = ( unsigned char ) ReadBlobByte ( image ) ; range = GetQuantumRange ( 5UL ) ; pixel . red = ( MagickRealType ) ScaleAnyToQuantum ( 1UL * ( k & 0x7c ) >> 2 , range ) ; pixel . green = ( MagickRealType ) ScaleAnyToQuantum ( ( 1UL * ( k & 0x03 ) << 3 ) + ( 1UL * ( j & 0xe0 ) >> 5 ) , range ) ; pixel . blue = ( MagickRealType ) ScaleAnyToQuantum ( 1UL * ( j & 0x1f ) , range ) ; break ; } case 24 : { pixel . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; pixel . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; pixel . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; break ; } case 32 : { pixel . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; pixel . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; pixel . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; pixel . alpha = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; break ; } } image -> colormap [ i ] = pixel ; } } base = 0 ; flag = 0 ; skip = MagickFalse ; real = 0 ; index = 0 ; runlength = 0 ; offset = 0 ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { real = offset ; if ( ( ( unsigned char ) ( tga_info . attributes & 0x20 ) >> 5 ) == 0 ) real = image -> rows - real - 1 ; q = QueueAuthenticPixels ( image , 0 , ( ssize_t ) real , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( ( tga_info . image_type == TGARLEColormap ) || ( tga_info . image_type == TGARLERGB ) || ( tga_info . image_type == TGARLEMonochrome ) ) { if ( runlength != 0 ) { runlength -- ; skip = flag != 0 ; } else { count = ReadBlob ( image , 1 , & runlength ) ; if ( count != 1 ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; flag = runlength & 0x80 ; if ( flag != 0 ) runlength -= 128 ; skip = MagickFalse ; } } if ( skip == MagickFalse ) switch ( tga_info . bits_per_pixel ) { case 8 : default : { index = ( Quantum ) ReadBlobByte ( image ) ; if ( tga_info . colormap_type != 0 ) pixel = image -> colormap [ ( ssize_t ) ConstrainColormapIndex ( image , ( ssize_t ) index , exception ) ] ; else { pixel . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) index ) ; pixel . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) index ) ; pixel . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) index ) ; } break ; } case 15 : case 16 : { QuantumAny range ; if ( ReadBlob ( image , 2 , pixels ) != 2 ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; j = pixels [ 0 ] ; k = pixels [ 1 ] ; range = GetQuantumRange ( 5UL ) ; pixel . red = ( MagickRealType ) ScaleAnyToQuantum ( 1UL * ( k & 0x7c ) >> 2 , range ) ; pixel . green = ( MagickRealType ) ScaleAnyToQuantum ( ( 1UL * ( k & 0x03 ) << 3 ) + ( 1UL * ( j & 0xe0 ) >> 5 ) , range ) ; pixel . blue = ( MagickRealType ) ScaleAnyToQuantum ( 1UL * ( j & 0x1f ) , range ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) pixel . alpha = ( MagickRealType ) ( ( k & 0x80 ) == 0 ? ( Quantum ) TransparentAlpha : ( Quantum ) OpaqueAlpha ) ; if ( image -> storage_class == PseudoClass ) index = ( Quantum ) ConstrainColormapIndex ( image , ( ( ssize_t ) ( k << 8 ) ) + j , exception ) ; break ; } case 24 : { if ( ReadBlob ( image , 3 , pixels ) != 3 ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; pixel . blue = ( MagickRealType ) ScaleCharToQuantum ( pixels [ 0 ] ) ; pixel . green = ( MagickRealType ) ScaleCharToQuantum ( pixels [ 1 ] ) ; pixel . red = ( MagickRealType ) ScaleCharToQuantum ( pixels [ 2 ] ) ; break ; } case 32 : { if ( ReadBlob ( image , 4 , pixels ) != 4 ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; pixel . blue = ( MagickRealType ) ScaleCharToQuantum ( pixels [ 0 ] ) ; pixel . green = ( MagickRealType ) ScaleCharToQuantum ( pixels [ 1 ] ) ; pixel . red = ( MagickRealType ) ScaleCharToQuantum ( pixels [ 2 ] ) ; pixel . alpha = ( MagickRealType ) ScaleCharToQuantum ( pixels [ 3 ] ) ; break ; } } if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; if ( image -> storage_class == PseudoClass ) SetPixelIndex ( image , index , q ) ; SetPixelRed ( image , ClampToQuantum ( pixel . red ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( pixel . green ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( pixel . blue ) , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ClampToQuantum ( pixel . alpha ) , q ) ; q += GetPixelChannels ( image ) ; } if ( ( ( unsigned char ) ( tga_info . attributes & 0xc0 ) >> 6 ) == 2 ) offset += 2 ; else offset ++ ; if ( offset >= image -> rows ) { base ++ ; offset = base ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","if ( tga_info . colormap_type != 0 ) {if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;",68
98,"buggy line: ulonglong tmp ;if ( jas_iccgetuint ( in , 4 , & tmp ) ) return - 1 ;cwe id:CWE-190context: static int jas_iccgetuint32 ( jas_stream_t * in , jas_iccuint32_t * val ) {  ulonglong tmp ;  if ( jas_iccgetuint ( in , 4 , & tmp ) ) return - 1 ; * val = tmp ; return 0 ; }","jas_ulonglong tmp ;if ( jas_iccgetuint ( in , 4 , & tmp ) ) return - 1 ;",69
99,"buggy line: }line . clock_type = get_status ( port ) -> clocking ;cwe id:CWE-399context: static int wanxl_ioctl ( struct net_device * dev , struct ifreq * ifr , int cmd ) { const size_t size = sizeof ( sync_serial_settings ) ; sync_serial_settings line ; port_t * port = dev_to_port ( dev ) ; if ( cmd != SIOCWANDEV ) return hdlc_ioctl ( dev , ifr , cmd ) ; switch ( ifr -> ifr_settings . type ) { case IF_GET_IFACE : ifr -> ifr_settings . type = IF_IFACE_SYNC_SERIAL ; if ( ifr -> ifr_settings . size < size ) { ifr -> ifr_settings . size = size ; return - ENOBUFS ;  }  line . clock_type = get_status ( port ) -> clocking ; line . clock_rate = 0 ; line . loopback = 0 ; if ( copy_to_user ( ifr -> ifr_settings . ifs_ifsu . sync , & line , size ) ) return - EFAULT ; return 0 ; case IF_IFACE_SYNC_SERIAL : if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; if ( dev -> flags & IFF_UP ) return - EBUSY ; if ( copy_from_user ( & line , ifr -> ifr_settings . ifs_ifsu . sync , size ) ) return - EFAULT ; if ( line . clock_type != CLOCK_EXT && line . clock_type != CLOCK_TXFROMRX ) return - EINVAL ; if ( line . loopback != 0 ) return - EINVAL ; get_status ( port ) -> clocking = line . clock_type ; return 0 ; default : return hdlc_ioctl ( dev , ifr , cmd ) ; } }","}memset ( & line , 0 , sizeof ( line ) ) ;line . clock_type = get_status ( port ) -> clocking ;",70
100,"buggy line: return scsi_cmd_ioctl ( bd -> bd_disk -> queue , bd -> bd_disk , mode , cmd , arg ) ;}cwe id:CWE-264context: int scsi_cmd_blk_ioctl ( struct block_device * bd , fmode_t mode , unsigned int cmd , void __user * arg ) {  return scsi_cmd_ioctl ( bd -> bd_disk -> queue , bd -> bd_disk , mode , cmd , arg ) ;  }","int ret ;ret = scsi_verify_blk_ioctl ( bd , cmd ) ;if ( ret < 0 ) return ret ;return scsi_cmd_ioctl ( bd -> bd_disk -> queue , bd -> bd_disk , mode , cmd , arg ) ;}",71
101,"buggy line: void nego_process_negotiation_request ( rdpNego * nego , wStream * s )  {UINT16 length ;Stream_Read_UINT8 ( s , flags ) ;}cwe id:CWE-125context:  void nego_process_negotiation_request ( rdpNego * nego , wStream * s )  { BYTE flags ;  UINT16 length ;  Stream_Read_UINT8 ( s , flags ) ; Stream_Read_UINT16 ( s , length ) ; Stream_Read_UINT32 ( s , nego -> RequestedProtocols ) ; WLog_DBG ( TAG , ""RDP_NEG_REQ:<S2SV_blank>RequestedProtocol:<S2SV_blank>0x%08"" PRIX32 """" , nego -> RequestedProtocols ) ; nego -> state = NEGO_STATE_FINAL ;  } ","BOOL nego_process_negotiation_request ( rdpNego * nego , wStream * s ) {UINT16 length ;if ( Stream_GetRemainingLength ( s ) < 7 ) return FALSE ;Stream_Read_UINT8 ( s , flags ) ;return TRUE ;}",72
102,"buggy line: int req_len ;struct qeth_arp_query_info qinfo = {cwe id:CWE-119context: int qeth_snmp_command ( struct qeth_card * card , char __user * udata ) { struct qeth_cmd_buffer * iob ; struct qeth_ipa_cmd * cmd ; struct qeth_snmp_ureq * ureq ;  int req_len ;  struct qeth_arp_query_info qinfo = { 0 , } ; int rc = 0 ; QETH_CARD_TEXT ( card , 3 , ""snmpcmd"" ) ; if ( card -> info . guestlan ) return - EOPNOTSUPP ; if ( ( ! qeth_adp_supported ( card , IPA_SETADP_SET_SNMP_CONTROL ) ) && ( ! card -> options . layer2 ) ) { return - EOPNOTSUPP ; } if ( copy_from_user ( & req_len , udata + sizeof ( int ) , sizeof ( int ) ) )  return - EFAULT ;  ureq = memdup_user ( udata , req_len + sizeof ( struct qeth_snmp_ureq_hdr ) ) ; if ( IS_ERR ( ureq ) ) { QETH_CARD_TEXT ( card , 2 , ""snmpnome"" ) ; return PTR_ERR ( ureq ) ; } qinfo . udata_len = ureq -> hdr . data_len ; qinfo . udata = kzalloc ( qinfo . udata_len , GFP_KERNEL ) ; if ( ! qinfo . udata ) { kfree ( ureq ) ; return - ENOMEM ; } qinfo . udata_offset = sizeof ( struct qeth_snmp_ureq_hdr ) ; iob = qeth_get_adapter_cmd ( card , IPA_SETADP_SET_SNMP_CONTROL , QETH_SNMP_SETADP_CMDLENGTH + req_len ) ; cmd = ( struct qeth_ipa_cmd * ) ( iob -> data + IPA_PDU_HEADER_SIZE ) ; memcpy ( & cmd -> data . setadapterparms . data . snmp , & ureq -> cmd , req_len ) ; rc = qeth_send_ipa_snmp_cmd ( card , iob , QETH_SETADP_BASE_LEN + req_len , qeth_snmp_command_cb , ( void * ) & qinfo ) ; if ( rc ) QETH_DBF_MESSAGE ( 2 , ""SNMP<S2SV_blank>command<S2SV_blank>failed<S2SV_blank>on<S2SV_blank>%s:<S2SV_blank>(0x%x)\\n"" , QETH_CARD_IFNAME ( card ) , rc ) ; else { if ( copy_to_user ( udata , qinfo . udata , qinfo . udata_len ) ) rc = - EFAULT ; } kfree ( ureq ) ; kfree ( qinfo . udata ) ; return rc ; }",unsigned int req_len ;struct qeth_arp_query_info qinfo = {,73
103,"buggy line: if ( copy_from_user ( & req_len , udata + sizeof ( int ) , sizeof ( int ) ) )  return - EFAULT ;ureq = memdup_user ( udata , req_len + sizeof ( struct qeth_snmp_ureq_hdr ) ) ;cwe id:CWE-119context: int qeth_snmp_command ( struct qeth_card * card , char __user * udata ) { struct qeth_cmd_buffer * iob ; struct qeth_ipa_cmd * cmd ; struct qeth_snmp_ureq * ureq ;  int req_len ;  struct qeth_arp_query_info qinfo = { 0 , } ; int rc = 0 ; QETH_CARD_TEXT ( card , 3 , ""snmpcmd"" ) ; if ( card -> info . guestlan ) return - EOPNOTSUPP ; if ( ( ! qeth_adp_supported ( card , IPA_SETADP_SET_SNMP_CONTROL ) ) && ( ! card -> options . layer2 ) ) { return - EOPNOTSUPP ; } if ( copy_from_user ( & req_len , udata + sizeof ( int ) , sizeof ( int ) ) )  return - EFAULT ;  ureq = memdup_user ( udata , req_len + sizeof ( struct qeth_snmp_ureq_hdr ) ) ; if ( IS_ERR ( ureq ) ) { QETH_CARD_TEXT ( card , 2 , ""snmpnome"" ) ; return PTR_ERR ( ureq ) ; } qinfo . udata_len = ureq -> hdr . data_len ; qinfo . udata = kzalloc ( qinfo . udata_len , GFP_KERNEL ) ; if ( ! qinfo . udata ) { kfree ( ureq ) ; return - ENOMEM ; } qinfo . udata_offset = sizeof ( struct qeth_snmp_ureq_hdr ) ; iob = qeth_get_adapter_cmd ( card , IPA_SETADP_SET_SNMP_CONTROL , QETH_SNMP_SETADP_CMDLENGTH + req_len ) ; cmd = ( struct qeth_ipa_cmd * ) ( iob -> data + IPA_PDU_HEADER_SIZE ) ; memcpy ( & cmd -> data . setadapterparms . data . snmp , & ureq -> cmd , req_len ) ; rc = qeth_send_ipa_snmp_cmd ( card , iob , QETH_SETADP_BASE_LEN + req_len , qeth_snmp_command_cb , ( void * ) & qinfo ) ; if ( rc ) QETH_DBF_MESSAGE ( 2 , ""SNMP<S2SV_blank>command<S2SV_blank>failed<S2SV_blank>on<S2SV_blank>%s:<S2SV_blank>(0x%x)\\n"" , QETH_CARD_IFNAME ( card ) , rc ) ; else { if ( copy_to_user ( udata , qinfo . udata , qinfo . udata_len ) ) rc = - EFAULT ; } kfree ( ureq ) ; kfree ( qinfo . udata ) ; return rc ; }","if ( copy_from_user ( & req_len , udata + sizeof ( int ) , sizeof ( int ) ) ) return - EFAULT ;if ( req_len > ( QETH_BUFSIZE - IPA_PDU_HEADER_SIZE - sizeof ( struct qeth_ipacmd_hdr ) - sizeof ( struct qeth_ipacmd_setadpparms_hdr ) ) ) return - EINVAL ;ureq = memdup_user ( udata , req_len + sizeof ( struct qeth_snmp_ureq_hdr ) ) ;",73
104,"buggy line: int m ;m = n ;cwe id:CWE-190context: int jas_stream_pad ( jas_stream_t * stream , int n , int c ) {  int m ;  m = n ; for ( m = n ; m > 0 ; -- m ) { if ( jas_stream_putc ( stream , c ) == EOF ) return n - m ; } return n ; }","int m ;if ( n < 0 ) {jas_deprecated ( ""negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_pad"" ) ;}m = n ;",74
105,"buggy line: int xd_size = 0 ;int data_len [ 256 ] ;cwe id:CWE-787context: static int track_header ( VividasDemuxContext * viv , AVFormatContext * s , uint8_t * buf , int size ) { int i , j , ret ; int64_t off ; int val_1 ; int num_video ; AVIOContext pb0 , * pb = & pb0 ; ffio_init_context ( pb , buf , size , 0 , NULL , NULL , NULL , NULL ) ; ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; val_1 = ffio_read_varlen ( pb ) ; for ( i = 0 ; i < val_1 ; i ++ ) { int c = avio_r8 ( pb ) ; if ( avio_feof ( pb ) ) return AVERROR_EOF ; for ( j = 0 ; j < c ; j ++ ) { if ( avio_feof ( pb ) ) return AVERROR_EOF ; avio_r8 ( pb ) ; avio_r8 ( pb ) ; } } avio_r8 ( pb ) ; off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; num_video = avio_r8 ( pb ) ; avio_seek ( pb , off , SEEK_SET ) ; if ( num_video != 1 ) { av_log ( s , AV_LOG_ERROR , ""number<S2SV_blank>of<S2SV_blank>video<S2SV_blank>tracks<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>1\\n"" , num_video ) ; return AVERROR_PATCHWELCOME ; } for ( i = 0 ; i < num_video ; i ++ ) { AVStream * st = avformat_new_stream ( s , NULL ) ; int num , den ; if ( ! st ) return AVERROR ( ENOMEM ) ; st -> id = i ; st -> codecpar -> codec_type = AVMEDIA_TYPE_VIDEO ; st -> codecpar -> codec_id = AV_CODEC_ID_VP6 ; off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; avio_r8 ( pb ) ; num = avio_rl32 ( pb ) ; den = avio_rl32 ( pb ) ; avpriv_set_pts_info ( st , 64 , num , den ) ; st -> nb_frames = avio_rl32 ( pb ) ; st -> codecpar -> width = avio_rl16 ( pb ) ; st -> codecpar -> height = avio_rl16 ( pb ) ; avio_r8 ( pb ) ; avio_rl32 ( pb ) ; avio_seek ( pb , off , SEEK_SET ) ; } off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; viv -> num_audio = avio_r8 ( pb ) ; avio_seek ( pb , off , SEEK_SET ) ; if ( viv -> num_audio != 1 ) av_log ( s , AV_LOG_WARNING , ""number<S2SV_blank>of<S2SV_blank>audio<S2SV_blank>tracks<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>1\\n"" , viv -> num_audio ) ; for ( i = 0 ; i < viv -> num_audio ; i ++ ) { int q ; AVStream * st = avformat_new_stream ( s , NULL ) ; if ( ! st ) return AVERROR ( ENOMEM ) ; st -> id = num_video + i ; st -> codecpar -> codec_type = AVMEDIA_TYPE_AUDIO ; st -> codecpar -> codec_id = AV_CODEC_ID_VORBIS ; off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; avio_r8 ( pb ) ; avio_rl16 ( pb ) ; st -> codecpar -> channels = avio_rl16 ( pb ) ; st -> codecpar -> sample_rate = avio_rl32 ( pb ) ; avio_seek ( pb , 10 , SEEK_CUR ) ; q = avio_r8 ( pb ) ; avio_seek ( pb , q , SEEK_CUR ) ; avio_r8 ( pb ) ; if ( avio_tell ( pb ) < off ) { int num_data ;  int xd_size = 0 ;  int data_len [ 256 ] ; int offset = 1 ; uint8_t * p ; ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; ffio_read_varlen ( pb ) ; num_data = avio_r8 ( pb ) ; for ( j = 0 ; j < num_data ; j ++ ) { uint64_t len = ffio_read_varlen ( pb ) ; if ( len > INT_MAX / 2 - xd_size ) { return AVERROR_INVALIDDATA ; } data_len [ j ] = len ;  xd_size += len ;  } ret = ff_alloc_extradata ( st -> codecpar , 64 + xd_size + xd_size / 255 ) ; if ( ret < 0 ) return ret ; p = st -> codecpar -> extradata ; p [ 0 ] = 2 ; for ( j = 0 ; j < num_data - 1 ; j ++ ) { unsigned delta = av_xiphlacing ( & p [ offset ] , data_len [ j ] ) ;  if ( delta > data_len [ j ] ) {  return AVERROR_INVALIDDATA ; } offset += delta ; } for ( j = 0 ; j < num_data ; j ++ ) { int ret = avio_read ( pb , & p [ offset ] , data_len [ j ] ) ; if ( ret < data_len [ j ] ) { st -> codecpar -> extradata_size = 0 ; av_freep ( & st -> codecpar -> extradata ) ; break ; }  offset += data_len [ j ] ;  } if ( offset < st -> codecpar -> extradata_size ) st -> codecpar -> extradata_size = offset ; } } return 0 ; }",int xd_size = 1 ;int data_len [ 256 ] ;,75
106,"buggy line: xd_size += len ;}ret = ff_alloc_extradata ( st -> codecpar , 64 + xd_size + xd_size / 255 ) ;cwe id:CWE-787context: static int track_header ( VividasDemuxContext * viv , AVFormatContext * s , uint8_t * buf , int size ) { int i , j , ret ; int64_t off ; int val_1 ; int num_video ; AVIOContext pb0 , * pb = & pb0 ; ffio_init_context ( pb , buf , size , 0 , NULL , NULL , NULL , NULL ) ; ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; val_1 = ffio_read_varlen ( pb ) ; for ( i = 0 ; i < val_1 ; i ++ ) { int c = avio_r8 ( pb ) ; if ( avio_feof ( pb ) ) return AVERROR_EOF ; for ( j = 0 ; j < c ; j ++ ) { if ( avio_feof ( pb ) ) return AVERROR_EOF ; avio_r8 ( pb ) ; avio_r8 ( pb ) ; } } avio_r8 ( pb ) ; off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; num_video = avio_r8 ( pb ) ; avio_seek ( pb , off , SEEK_SET ) ; if ( num_video != 1 ) { av_log ( s , AV_LOG_ERROR , ""number<S2SV_blank>of<S2SV_blank>video<S2SV_blank>tracks<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>1\\n"" , num_video ) ; return AVERROR_PATCHWELCOME ; } for ( i = 0 ; i < num_video ; i ++ ) { AVStream * st = avformat_new_stream ( s , NULL ) ; int num , den ; if ( ! st ) return AVERROR ( ENOMEM ) ; st -> id = i ; st -> codecpar -> codec_type = AVMEDIA_TYPE_VIDEO ; st -> codecpar -> codec_id = AV_CODEC_ID_VP6 ; off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; avio_r8 ( pb ) ; num = avio_rl32 ( pb ) ; den = avio_rl32 ( pb ) ; avpriv_set_pts_info ( st , 64 , num , den ) ; st -> nb_frames = avio_rl32 ( pb ) ; st -> codecpar -> width = avio_rl16 ( pb ) ; st -> codecpar -> height = avio_rl16 ( pb ) ; avio_r8 ( pb ) ; avio_rl32 ( pb ) ; avio_seek ( pb , off , SEEK_SET ) ; } off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; viv -> num_audio = avio_r8 ( pb ) ; avio_seek ( pb , off , SEEK_SET ) ; if ( viv -> num_audio != 1 ) av_log ( s , AV_LOG_WARNING , ""number<S2SV_blank>of<S2SV_blank>audio<S2SV_blank>tracks<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>1\\n"" , viv -> num_audio ) ; for ( i = 0 ; i < viv -> num_audio ; i ++ ) { int q ; AVStream * st = avformat_new_stream ( s , NULL ) ; if ( ! st ) return AVERROR ( ENOMEM ) ; st -> id = num_video + i ; st -> codecpar -> codec_type = AVMEDIA_TYPE_AUDIO ; st -> codecpar -> codec_id = AV_CODEC_ID_VORBIS ; off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; avio_r8 ( pb ) ; avio_rl16 ( pb ) ; st -> codecpar -> channels = avio_rl16 ( pb ) ; st -> codecpar -> sample_rate = avio_rl32 ( pb ) ; avio_seek ( pb , 10 , SEEK_CUR ) ; q = avio_r8 ( pb ) ; avio_seek ( pb , q , SEEK_CUR ) ; avio_r8 ( pb ) ; if ( avio_tell ( pb ) < off ) { int num_data ;  int xd_size = 0 ;  int data_len [ 256 ] ; int offset = 1 ; uint8_t * p ; ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; ffio_read_varlen ( pb ) ; num_data = avio_r8 ( pb ) ; for ( j = 0 ; j < num_data ; j ++ ) { uint64_t len = ffio_read_varlen ( pb ) ; if ( len > INT_MAX / 2 - xd_size ) { return AVERROR_INVALIDDATA ; } data_len [ j ] = len ;  xd_size += len ;  } ret = ff_alloc_extradata ( st -> codecpar , 64 + xd_size + xd_size / 255 ) ; if ( ret < 0 ) return ret ; p = st -> codecpar -> extradata ; p [ 0 ] = 2 ; for ( j = 0 ; j < num_data - 1 ; j ++ ) { unsigned delta = av_xiphlacing ( & p [ offset ] , data_len [ j ] ) ;  if ( delta > data_len [ j ] ) {  return AVERROR_INVALIDDATA ; } offset += delta ; } for ( j = 0 ; j < num_data ; j ++ ) { int ret = avio_read ( pb , & p [ offset ] , data_len [ j ] ) ; if ( ret < data_len [ j ] ) { st -> codecpar -> extradata_size = 0 ; av_freep ( & st -> codecpar -> extradata ) ; break ; }  offset += data_len [ j ] ;  } if ( offset < st -> codecpar -> extradata_size ) st -> codecpar -> extradata_size = offset ; } } return 0 ; }","xd_size += len + 1 + len / 255 ;}ret = ff_alloc_extradata ( st -> codecpar , xd_size ) ;",75
107,"buggy line: if ( delta > data_len [ j ] ) {return AVERROR_INVALIDDATA ;}cwe id:CWE-787context: static int track_header ( VividasDemuxContext * viv , AVFormatContext * s , uint8_t * buf , int size ) { int i , j , ret ; int64_t off ; int val_1 ; int num_video ; AVIOContext pb0 , * pb = & pb0 ; ffio_init_context ( pb , buf , size , 0 , NULL , NULL , NULL , NULL ) ; ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; val_1 = ffio_read_varlen ( pb ) ; for ( i = 0 ; i < val_1 ; i ++ ) { int c = avio_r8 ( pb ) ; if ( avio_feof ( pb ) ) return AVERROR_EOF ; for ( j = 0 ; j < c ; j ++ ) { if ( avio_feof ( pb ) ) return AVERROR_EOF ; avio_r8 ( pb ) ; avio_r8 ( pb ) ; } } avio_r8 ( pb ) ; off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; num_video = avio_r8 ( pb ) ; avio_seek ( pb , off , SEEK_SET ) ; if ( num_video != 1 ) { av_log ( s , AV_LOG_ERROR , ""number<S2SV_blank>of<S2SV_blank>video<S2SV_blank>tracks<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>1\\n"" , num_video ) ; return AVERROR_PATCHWELCOME ; } for ( i = 0 ; i < num_video ; i ++ ) { AVStream * st = avformat_new_stream ( s , NULL ) ; int num , den ; if ( ! st ) return AVERROR ( ENOMEM ) ; st -> id = i ; st -> codecpar -> codec_type = AVMEDIA_TYPE_VIDEO ; st -> codecpar -> codec_id = AV_CODEC_ID_VP6 ; off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; avio_r8 ( pb ) ; num = avio_rl32 ( pb ) ; den = avio_rl32 ( pb ) ; avpriv_set_pts_info ( st , 64 , num , den ) ; st -> nb_frames = avio_rl32 ( pb ) ; st -> codecpar -> width = avio_rl16 ( pb ) ; st -> codecpar -> height = avio_rl16 ( pb ) ; avio_r8 ( pb ) ; avio_rl32 ( pb ) ; avio_seek ( pb , off , SEEK_SET ) ; } off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; viv -> num_audio = avio_r8 ( pb ) ; avio_seek ( pb , off , SEEK_SET ) ; if ( viv -> num_audio != 1 ) av_log ( s , AV_LOG_WARNING , ""number<S2SV_blank>of<S2SV_blank>audio<S2SV_blank>tracks<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>1\\n"" , viv -> num_audio ) ; for ( i = 0 ; i < viv -> num_audio ; i ++ ) { int q ; AVStream * st = avformat_new_stream ( s , NULL ) ; if ( ! st ) return AVERROR ( ENOMEM ) ; st -> id = num_video + i ; st -> codecpar -> codec_type = AVMEDIA_TYPE_AUDIO ; st -> codecpar -> codec_id = AV_CODEC_ID_VORBIS ; off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; avio_r8 ( pb ) ; avio_rl16 ( pb ) ; st -> codecpar -> channels = avio_rl16 ( pb ) ; st -> codecpar -> sample_rate = avio_rl32 ( pb ) ; avio_seek ( pb , 10 , SEEK_CUR ) ; q = avio_r8 ( pb ) ; avio_seek ( pb , q , SEEK_CUR ) ; avio_r8 ( pb ) ; if ( avio_tell ( pb ) < off ) { int num_data ;  int xd_size = 0 ;  int data_len [ 256 ] ; int offset = 1 ; uint8_t * p ; ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; ffio_read_varlen ( pb ) ; num_data = avio_r8 ( pb ) ; for ( j = 0 ; j < num_data ; j ++ ) { uint64_t len = ffio_read_varlen ( pb ) ; if ( len > INT_MAX / 2 - xd_size ) { return AVERROR_INVALIDDATA ; } data_len [ j ] = len ;  xd_size += len ;  } ret = ff_alloc_extradata ( st -> codecpar , 64 + xd_size + xd_size / 255 ) ; if ( ret < 0 ) return ret ; p = st -> codecpar -> extradata ; p [ 0 ] = 2 ; for ( j = 0 ; j < num_data - 1 ; j ++ ) { unsigned delta = av_xiphlacing ( & p [ offset ] , data_len [ j ] ) ;  if ( delta > data_len [ j ] ) {  return AVERROR_INVALIDDATA ; } offset += delta ; } for ( j = 0 ; j < num_data ; j ++ ) { int ret = avio_read ( pb , & p [ offset ] , data_len [ j ] ) ; if ( ret < data_len [ j ] ) { st -> codecpar -> extradata_size = 0 ; av_freep ( & st -> codecpar -> extradata ) ; break ; }  offset += data_len [ j ] ;  } if ( offset < st -> codecpar -> extradata_size ) st -> codecpar -> extradata_size = offset ; } } return 0 ; }",av_assert0 ( delta <= xd_size - offset ) ;,75
108,"buggy line: offset += data_len [ j ] ;}cwe id:CWE-787context: static int track_header ( VividasDemuxContext * viv , AVFormatContext * s , uint8_t * buf , int size ) { int i , j , ret ; int64_t off ; int val_1 ; int num_video ; AVIOContext pb0 , * pb = & pb0 ; ffio_init_context ( pb , buf , size , 0 , NULL , NULL , NULL , NULL ) ; ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; val_1 = ffio_read_varlen ( pb ) ; for ( i = 0 ; i < val_1 ; i ++ ) { int c = avio_r8 ( pb ) ; if ( avio_feof ( pb ) ) return AVERROR_EOF ; for ( j = 0 ; j < c ; j ++ ) { if ( avio_feof ( pb ) ) return AVERROR_EOF ; avio_r8 ( pb ) ; avio_r8 ( pb ) ; } } avio_r8 ( pb ) ; off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; num_video = avio_r8 ( pb ) ; avio_seek ( pb , off , SEEK_SET ) ; if ( num_video != 1 ) { av_log ( s , AV_LOG_ERROR , ""number<S2SV_blank>of<S2SV_blank>video<S2SV_blank>tracks<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>1\\n"" , num_video ) ; return AVERROR_PATCHWELCOME ; } for ( i = 0 ; i < num_video ; i ++ ) { AVStream * st = avformat_new_stream ( s , NULL ) ; int num , den ; if ( ! st ) return AVERROR ( ENOMEM ) ; st -> id = i ; st -> codecpar -> codec_type = AVMEDIA_TYPE_VIDEO ; st -> codecpar -> codec_id = AV_CODEC_ID_VP6 ; off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; avio_r8 ( pb ) ; num = avio_rl32 ( pb ) ; den = avio_rl32 ( pb ) ; avpriv_set_pts_info ( st , 64 , num , den ) ; st -> nb_frames = avio_rl32 ( pb ) ; st -> codecpar -> width = avio_rl16 ( pb ) ; st -> codecpar -> height = avio_rl16 ( pb ) ; avio_r8 ( pb ) ; avio_rl32 ( pb ) ; avio_seek ( pb , off , SEEK_SET ) ; } off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; viv -> num_audio = avio_r8 ( pb ) ; avio_seek ( pb , off , SEEK_SET ) ; if ( viv -> num_audio != 1 ) av_log ( s , AV_LOG_WARNING , ""number<S2SV_blank>of<S2SV_blank>audio<S2SV_blank>tracks<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>1\\n"" , viv -> num_audio ) ; for ( i = 0 ; i < viv -> num_audio ; i ++ ) { int q ; AVStream * st = avformat_new_stream ( s , NULL ) ; if ( ! st ) return AVERROR ( ENOMEM ) ; st -> id = num_video + i ; st -> codecpar -> codec_type = AVMEDIA_TYPE_AUDIO ; st -> codecpar -> codec_id = AV_CODEC_ID_VORBIS ; off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; avio_r8 ( pb ) ; avio_rl16 ( pb ) ; st -> codecpar -> channels = avio_rl16 ( pb ) ; st -> codecpar -> sample_rate = avio_rl32 ( pb ) ; avio_seek ( pb , 10 , SEEK_CUR ) ; q = avio_r8 ( pb ) ; avio_seek ( pb , q , SEEK_CUR ) ; avio_r8 ( pb ) ; if ( avio_tell ( pb ) < off ) { int num_data ;  int xd_size = 0 ;  int data_len [ 256 ] ; int offset = 1 ; uint8_t * p ; ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; ffio_read_varlen ( pb ) ; num_data = avio_r8 ( pb ) ; for ( j = 0 ; j < num_data ; j ++ ) { uint64_t len = ffio_read_varlen ( pb ) ; if ( len > INT_MAX / 2 - xd_size ) { return AVERROR_INVALIDDATA ; } data_len [ j ] = len ;  xd_size += len ;  } ret = ff_alloc_extradata ( st -> codecpar , 64 + xd_size + xd_size / 255 ) ; if ( ret < 0 ) return ret ; p = st -> codecpar -> extradata ; p [ 0 ] = 2 ; for ( j = 0 ; j < num_data - 1 ; j ++ ) { unsigned delta = av_xiphlacing ( & p [ offset ] , data_len [ j ] ) ;  if ( delta > data_len [ j ] ) {  return AVERROR_INVALIDDATA ; } offset += delta ; } for ( j = 0 ; j < num_data ; j ++ ) { int ret = avio_read ( pb , & p [ offset ] , data_len [ j ] ) ; if ( ret < data_len [ j ] ) { st -> codecpar -> extradata_size = 0 ; av_freep ( & st -> codecpar -> extradata ) ; break ; }  offset += data_len [ j ] ;  } if ( offset < st -> codecpar -> extradata_size ) st -> codecpar -> extradata_size = offset ; } } return 0 ; }",av_assert0 ( data_len [ j ] <= xd_size - offset ) ;offset += data_len [ j ] ;},75
109,"buggy line: av_log ( mxf -> fc , AV_LOG_TRACE , ""metadata<S2SV_blank>sets<S2SV_blank>count<S2SV_blank>%d\\\cwe id:CWE-125context: static int mxf_parse_structural_metadata ( MXFContext * mxf ) { MXFPackage * material_package = NULL ; int i , j , k , ret ; av_log ( mxf -> fc , AV_LOG_TRACE , ""metadata<S2SV_blank>sets<S2SV_blank>count<S2SV_blank>%d\\n"" , mxf -> metadata_sets_count ) ; for ( i = 0 ; i < mxf -> packages_count ; i ++ ) { material_package = mxf_resolve_strong_ref ( mxf , & mxf -> packages_refs [ i ] , MaterialPackage ) ; if ( material_package ) break ; } if ( ! material_package ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""no<S2SV_blank>material<S2SV_blank>package<S2SV_blank>found\\n"" ) ; return AVERROR_INVALIDDATA ; } mxf_add_umid_metadata ( & mxf -> fc -> metadata , ""material_package_umid"" , material_package ) ; if ( material_package -> name && material_package -> name [ 0 ] ) av_dict_set ( & mxf -> fc -> metadata , ""material_package_name"" , material_package -> name , 0 ) ; mxf_parse_package_comments ( mxf , & mxf -> fc -> metadata , material_package ) ; for ( i = 0 ; i < material_package -> tracks_count ; i ++ ) { MXFPackage * source_package = NULL ; MXFTrack * material_track = NULL ; MXFTrack * source_track = NULL ; MXFTrack * temp_track = NULL ; MXFDescriptor * descriptor = NULL ; MXFStructuralComponent * component = NULL ; MXFTimecodeComponent * mxf_tc = NULL ; UID * essence_container_ul = NULL ; const MXFCodecUL * codec_ul = NULL ; const MXFCodecUL * container_ul = NULL ; const MXFCodecUL * pix_fmt_ul = NULL ; AVStream * st ; AVTimecode tc ; int flags ; if ( ! ( material_track = mxf_resolve_strong_ref ( mxf , & material_package -> tracks_refs [ i ] , Track ) ) ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>material<S2SV_blank>track<S2SV_blank>strong<S2SV_blank>ref\\n"" ) ; continue ; } if ( ( component = mxf_resolve_strong_ref ( mxf , & material_track -> sequence_ref , TimecodeComponent ) ) ) { mxf_tc = ( MXFTimecodeComponent * ) component ; flags = mxf_tc -> drop_frame == 1 ? AV_TIMECODE_FLAG_DROPFRAME : 0 ; if ( av_timecode_init ( & tc , mxf_tc -> rate , flags , mxf_tc -> start_frame , mxf -> fc ) == 0 ) { mxf_add_timecode_metadata ( & mxf -> fc -> metadata , ""timecode"" , & tc ) ; } } if ( ! ( material_track -> sequence = mxf_resolve_strong_ref ( mxf , & material_track -> sequence_ref , Sequence ) ) ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>material<S2SV_blank>track<S2SV_blank>sequence<S2SV_blank>strong<S2SV_blank>ref\\n"" ) ; continue ; } for ( j = 0 ; j < material_track -> sequence -> structural_components_count ; j ++ ) { component = mxf_resolve_strong_ref ( mxf , & material_track -> sequence -> structural_components_refs [ j ] , TimecodeComponent ) ; if ( ! component ) continue ; mxf_tc = ( MXFTimecodeComponent * ) component ; flags = mxf_tc -> drop_frame == 1 ? AV_TIMECODE_FLAG_DROPFRAME : 0 ; if ( av_timecode_init ( & tc , mxf_tc -> rate , flags , mxf_tc -> start_frame , mxf -> fc ) == 0 ) { mxf_add_timecode_metadata ( & mxf -> fc -> metadata , ""timecode"" , & tc ) ; break ; } } if ( material_track -> sequence -> structural_components_count > 1 ) av_log ( mxf -> fc , AV_LOG_WARNING , ""material<S2SV_blank>track<S2SV_blank>%d:<S2SV_blank>has<S2SV_blank>%d<S2SV_blank>components\\n"" , material_track -> track_id , material_track -> sequence -> structural_components_count ) ; for ( j = 0 ; j < material_track -> sequence -> structural_components_count ; j ++ ) { component = mxf_resolve_sourceclip ( mxf , & material_track -> sequence -> structural_components_refs [ j ] ) ; if ( ! component ) continue ; source_package = mxf_resolve_source_package ( mxf , component -> source_package_ul , component -> source_package_uid ) ; if ( ! source_package ) { av_log ( mxf -> fc , AV_LOG_TRACE , ""material<S2SV_blank>track<S2SV_blank>%d:<S2SV_blank>no<S2SV_blank>corresponding<S2SV_blank>source<S2SV_blank>package<S2SV_blank>found\\n"" , material_track -> track_id ) ; continue ; } for ( k = 0 ; k < source_package -> tracks_count ; k ++ ) { if ( ! ( temp_track = mxf_resolve_strong_ref ( mxf , & source_package -> tracks_refs [ k ] , Track ) ) ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>source<S2SV_blank>track<S2SV_blank>strong<S2SV_blank>ref\\n"" ) ; ret = AVERROR_INVALIDDATA ; goto fail_and_free ; } if ( temp_track -> track_id == component -> source_track_id ) { source_track = temp_track ; break ; } } if ( ! source_track ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""material<S2SV_blank>track<S2SV_blank>%d:<S2SV_blank>no<S2SV_blank>corresponding<S2SV_blank>source<S2SV_blank>track<S2SV_blank>found\\n"" , material_track -> track_id ) ; break ; } for ( k = 0 ; k < mxf -> essence_container_data_count ; k ++ ) { MXFEssenceContainerData * essence_data ; if ( ! ( essence_data = mxf_resolve_strong_ref ( mxf , & mxf -> essence_container_data_refs [ k ] , EssenceContainerData ) ) ) {  av_log ( mxf , AV_LOG_TRACE , ""could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>essence<S2SV_blank>container<S2SV_blank>data<S2SV_blank>strong<S2SV_blank>ref\\n"" ) ;  continue ; } if ( ! memcmp ( component -> source_package_ul , essence_data -> package_ul , sizeof ( UID ) ) && ! memcmp ( component -> source_package_uid , essence_data -> package_uid , sizeof ( UID ) ) ) { source_track -> body_sid = essence_data -> body_sid ; source_track -> index_sid = essence_data -> index_sid ; break ; } } if ( source_track && component ) break ; } if ( ! source_track || ! component || ! source_package ) { if ( ( ret = mxf_add_metadata_stream ( mxf , material_track ) ) ) goto fail_and_free ; continue ; } if ( ! ( source_track -> sequence = mxf_resolve_strong_ref ( mxf , & source_track -> sequence_ref , Sequence ) ) ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>source<S2SV_blank>track<S2SV_blank>sequence<S2SV_blank>strong<S2SV_blank>ref\\n"" ) ; ret = AVERROR_INVALIDDATA ; goto fail_and_free ; } if ( memcmp ( material_track -> sequence -> data_definition_ul , source_track -> sequence -> data_definition_ul , 16 ) ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""material<S2SV_blank>track<S2SV_blank>%d:<S2SV_blank>DataDefinition<S2SV_blank>mismatch\\n"" , material_track -> track_id ) ; continue ; } st = avformat_new_stream ( mxf -> fc , NULL ) ; if ( ! st ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>stream\\n"" ) ; ret = AVERROR ( ENOMEM ) ; goto fail_and_free ; } st -> id = material_track -> track_id ; st -> priv_data = source_track ; source_package -> descriptor = mxf_resolve_strong_ref ( mxf , & source_package -> descriptor_ref , AnyType ) ; descriptor = mxf_resolve_multidescriptor ( mxf , source_package -> descriptor , source_track -> track_id ) ; if ( descriptor && descriptor -> duration != AV_NOPTS_VALUE ) source_track -> original_duration = st -> duration = FFMIN ( descriptor -> duration , component -> duration ) ; else source_track -> original_duration = st -> duration = component -> duration ; if ( st -> duration == - 1 ) st -> duration = AV_NOPTS_VALUE ; st -> start_time = component -> start_position ; if ( material_track -> edit_rate . num <= 0 || material_track -> edit_rate . den <= 0 ) { av_log ( mxf -> fc , AV_LOG_WARNING , ""Invalid<S2SV_blank>edit<S2SV_blank>rate<S2SV_blank>(%d/%d)<S2SV_blank>found<S2SV_blank>on<S2SV_blank>stream<S2SV_blank>#%d,<S2SV_blank>"" ""defaulting<S2SV_blank>to<S2SV_blank>25/1\\n"" , material_track -> edit_rate . num , material_track -> edit_rate . den , st -> index ) ; material_track -> edit_rate = ( AVRational ) { 25 , 1 } ; } avpriv_set_pts_info ( st , 64 , material_track -> edit_rate . den , material_track -> edit_rate . num ) ; source_track -> edit_rate = material_track -> edit_rate ; PRINT_KEY ( mxf -> fc , ""data<S2SV_blank>definition<S2SV_blank><S2SV_blank><S2SV_blank>ul"" , source_track -> sequence -> data_definition_ul ) ; codec_ul = mxf_get_codec_ul ( ff_mxf_data_definition_uls , & source_track -> sequence -> data_definition_ul ) ; st -> codecpar -> codec_type = codec_ul -> id ; if ( ! descriptor ) { av_log ( mxf -> fc , AV_LOG_INFO , ""source<S2SV_blank>track<S2SV_blank>%d:<S2SV_blank>stream<S2SV_blank>%d,<S2SV_blank>no<S2SV_blank>descriptor<S2SV_blank>found\\n"" , source_track -> track_id , st -> index ) ; continue ; } PRINT_KEY ( mxf -> fc , ""essence<S2SV_blank>codec<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>ul"" , descriptor -> essence_codec_ul ) ; PRINT_KEY ( mxf -> fc , ""essence<S2SV_blank>container<S2SV_blank>ul"" , descriptor -> essence_container_ul ) ; essence_container_ul = & descriptor -> essence_container_ul ; source_track -> wrapping = ( mxf -> op == OPAtom ) ? ClipWrapped : mxf_get_wrapping_kind ( essence_container_ul ) ; if ( source_track -> wrapping == UnknownWrapped ) av_log ( mxf -> fc , AV_LOG_INFO , ""wrapping<S2SV_blank>of<S2SV_blank>stream<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>unknown\\n"" , st -> index ) ; if ( IS_KLV_KEY ( essence_container_ul , mxf_encrypted_essence_container ) ) { av_log ( mxf -> fc , AV_LOG_INFO , ""broken<S2SV_blank>encrypted<S2SV_blank>mxf<S2SV_blank>file\\n"" ) ; for ( k = 0 ; k < mxf -> metadata_sets_count ; k ++ ) { MXFMetadataSet * metadata = mxf -> metadata_sets [ k ] ; if ( metadata -> type == CryptoContext ) { essence_container_ul = & ( ( MXFCryptoContext * ) metadata ) -> source_container_ul ; break ; } } } codec_ul = mxf_get_codec_ul ( ff_mxf_codec_uls , & descriptor -> essence_codec_ul ) ; st -> codecpar -> codec_id = ( enum AVCodecID ) codec_ul -> id ; if ( st -> codecpar -> codec_id == AV_CODEC_ID_NONE ) { codec_ul = mxf_get_codec_ul ( ff_mxf_codec_uls , & descriptor -> codec_ul ) ; st -> codecpar -> codec_id = ( enum AVCodecID ) codec_ul -> id ; } av_log ( mxf -> fc , AV_LOG_VERBOSE , ""%s:<S2SV_blank>Universal<S2SV_blank>Label:<S2SV_blank>"" , avcodec_get_name ( st -> codecpar -> codec_id ) ) ; for ( k = 0 ; k < 16 ; k ++ ) { av_log ( mxf -> fc , AV_LOG_VERBOSE , ""%.2x"" , descriptor -> essence_codec_ul [ k ] ) ; if ( ! ( k + 1 & 19 ) || k == 5 ) av_log ( mxf -> fc , AV_LOG_VERBOSE , ""."" ) ; } av_log ( mxf -> fc , AV_LOG_VERBOSE , ""\\n"" ) ; mxf_add_umid_metadata ( & st -> metadata , ""file_package_umid"" , source_package ) ; if ( source_package -> name && source_package -> name [ 0 ] ) av_dict_set ( & st -> metadata , ""file_package_name"" , source_package -> name , 0 ) ; if ( material_track -> name && material_track -> name [ 0 ] ) av_dict_set ( & st -> metadata , ""track_name"" , material_track -> name , 0 ) ; mxf_parse_physical_source_package ( mxf , source_track , st ) ; if ( st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO ) { source_track -> intra_only = mxf_is_intra_only ( descriptor ) ; container_ul = mxf_get_codec_ul ( mxf_picture_essence_container_uls , essence_container_ul ) ; if ( st -> codecpar -> codec_id == AV_CODEC_ID_NONE ) st -> codecpar -> codec_id = container_ul -> id ; st -> codecpar -> width = descriptor -> width ; st -> codecpar -> height = descriptor -> height ; switch ( descriptor -> frame_layout ) { case FullFrame : st -> codecpar -> field_order = AV_FIELD_PROGRESSIVE ; break ; case OneField : av_log ( mxf -> fc , AV_LOG_INFO , ""OneField<S2SV_blank>frame<S2SV_blank>layout<S2SV_blank>isn\'t<S2SV_blank>currently<S2SV_blank>supported\\n"" ) ; break ; case MixedFields : break ; case SegmentedFrame : st -> codecpar -> field_order = AV_FIELD_PROGRESSIVE ; case SeparateFields : av_log ( mxf -> fc , AV_LOG_DEBUG , ""video_line_map:<S2SV_blank>(%d,<S2SV_blank>%d),<S2SV_blank>field_dominance:<S2SV_blank>%d\\n"" , descriptor -> video_line_map [ 0 ] , descriptor -> video_line_map [ 1 ] , descriptor -> field_dominance ) ; if ( ( descriptor -> video_line_map [ 0 ] > 0 ) && ( descriptor -> video_line_map [ 1 ] > 0 ) ) { if ( ( descriptor -> video_line_map [ 0 ] + descriptor -> video_line_map [ 1 ] ) % 2 ) { switch ( descriptor -> field_dominance ) { case MXF_FIELD_DOMINANCE_DEFAULT : case MXF_FIELD_DOMINANCE_FF : st -> codecpar -> field_order = AV_FIELD_TT ; break ; case MXF_FIELD_DOMINANCE_FL : st -> codecpar -> field_order = AV_FIELD_TB ; break ; default : avpriv_request_sample ( mxf -> fc , ""Field<S2SV_blank>dominance<S2SV_blank>%d<S2SV_blank>support"" , descriptor -> field_dominance ) ; } } else { switch ( descriptor -> field_dominance ) { case MXF_FIELD_DOMINANCE_DEFAULT : case MXF_FIELD_DOMINANCE_FF : st -> codecpar -> field_order = AV_FIELD_BB ; break ; case MXF_FIELD_DOMINANCE_FL : st -> codecpar -> field_order = AV_FIELD_BT ; break ; default : avpriv_request_sample ( mxf -> fc , ""Field<S2SV_blank>dominance<S2SV_blank>%d<S2SV_blank>support"" , descriptor -> field_dominance ) ; } } } st -> codecpar -> height *= 2 ; break ; default : av_log ( mxf -> fc , AV_LOG_INFO , ""Unknown<S2SV_blank>frame<S2SV_blank>layout<S2SV_blank>type:<S2SV_blank>%d\\n"" , descriptor -> frame_layout ) ; } if ( st -> codecpar -> codec_id == AV_CODEC_ID_RAWVIDEO ) { st -> codecpar -> format = descriptor -> pix_fmt ; if ( st -> codecpar -> format == AV_PIX_FMT_NONE ) { pix_fmt_ul = mxf_get_codec_ul ( ff_mxf_pixel_format_uls , & descriptor -> essence_codec_ul ) ; st -> codecpar -> format = ( enum AVPixelFormat ) pix_fmt_ul -> id ; if ( st -> codecpar -> format == AV_PIX_FMT_NONE ) { st -> codecpar -> codec_tag = mxf_get_codec_ul ( ff_mxf_codec_tag_uls , & descriptor -> essence_codec_ul ) -> id ; if ( ! st -> codecpar -> codec_tag ) { if ( descriptor -> horiz_subsampling == 2 && descriptor -> vert_subsampling == 1 && descriptor -> component_depth == 8 ) { st -> codecpar -> format = AV_PIX_FMT_UYVY422 ; } } } } } st -> need_parsing = AVSTREAM_PARSE_HEADERS ; if ( material_track -> sequence -> origin ) { av_dict_set_int ( & st -> metadata , ""material_track_origin"" , material_track -> sequence -> origin , 0 ) ; } if ( source_track -> sequence -> origin ) { av_dict_set_int ( & st -> metadata , ""source_track_origin"" , source_track -> sequence -> origin , 0 ) ; } if ( descriptor -> aspect_ratio . num && descriptor -> aspect_ratio . den ) st -> display_aspect_ratio = descriptor -> aspect_ratio ; } else if ( st -> codecpar -> codec_type == AVMEDIA_TYPE_AUDIO ) { container_ul = mxf_get_codec_ul ( mxf_sound_essence_container_uls , essence_container_ul ) ; if ( st -> codecpar -> codec_id == AV_CODEC_ID_NONE || ( st -> codecpar -> codec_id == AV_CODEC_ID_PCM_ALAW && ( enum AVCodecID ) container_ul -> id != AV_CODEC_ID_NONE ) ) st -> codecpar -> codec_id = ( enum AVCodecID ) container_ul -> id ; st -> codecpar -> channels = descriptor -> channels ; st -> codecpar -> bits_per_coded_sample = descriptor -> bits_per_sample ; if ( descriptor -> sample_rate . den > 0 ) { st -> codecpar -> sample_rate = descriptor -> sample_rate . num / descriptor -> sample_rate . den ; avpriv_set_pts_info ( st , 64 , descriptor -> sample_rate . den , descriptor -> sample_rate . num ) ; } else { av_log ( mxf -> fc , AV_LOG_WARNING , ""invalid<S2SV_blank>sample<S2SV_blank>rate<S2SV_blank>(%d/%d)<S2SV_blank>"" ""found<S2SV_blank>for<S2SV_blank>stream<S2SV_blank>#%d,<S2SV_blank>time<S2SV_blank>base<S2SV_blank>forced<S2SV_blank>to<S2SV_blank>1/48000\\n"" , descriptor -> sample_rate . num , descriptor -> sample_rate . den , st -> index ) ; avpriv_set_pts_info ( st , 64 , 1 , 48000 ) ; } if ( st -> duration != AV_NOPTS_VALUE ) st -> duration = av_rescale_q ( st -> duration , av_inv_q ( material_track -> edit_rate ) , st -> time_base ) ; if ( st -> codecpar -> codec_id == AV_CODEC_ID_PCM_S16LE ) { if ( descriptor -> bits_per_sample > 16 && descriptor -> bits_per_sample <= 24 ) st -> codecpar -> codec_id = AV_CODEC_ID_PCM_S24LE ; else if ( descriptor -> bits_per_sample == 32 ) st -> codecpar -> codec_id = AV_CODEC_ID_PCM_S32LE ; } else if ( st -> codecpar -> codec_id == AV_CODEC_ID_PCM_S16BE ) { if ( descriptor -> bits_per_sample > 16 && descriptor -> bits_per_sample <= 24 ) st -> codecpar -> codec_id = AV_CODEC_ID_PCM_S24BE ; else if ( descriptor -> bits_per_sample == 32 ) st -> codecpar -> codec_id = AV_CODEC_ID_PCM_S32BE ; } else if ( st -> codecpar -> codec_id == AV_CODEC_ID_MP2 ) { st -> need_parsing = AVSTREAM_PARSE_FULL ; } } else if ( st -> codecpar -> codec_type == AVMEDIA_TYPE_DATA ) { enum AVMediaType type ; container_ul = mxf_get_codec_ul ( mxf_data_essence_container_uls , essence_container_ul ) ; if ( st -> codecpar -> codec_id == AV_CODEC_ID_NONE ) st -> codecpar -> codec_id = container_ul -> id ; type = avcodec_get_type ( st -> codecpar -> codec_id ) ; if ( type == AVMEDIA_TYPE_SUBTITLE ) st -> codecpar -> codec_type = type ; if ( container_ul -> desc ) av_dict_set ( & st -> metadata , ""data_type"" , container_ul -> desc , 0 ) ; } if ( descriptor -> extradata ) { if ( ! ff_alloc_extradata ( st -> codecpar , descriptor -> extradata_size ) ) { memcpy ( st -> codecpar -> extradata , descriptor -> extradata , descriptor -> extradata_size ) ; } } else if ( st -> codecpar -> codec_id == AV_CODEC_ID_H264 ) { int coded_width = mxf_get_codec_ul ( mxf_intra_only_picture_coded_width , & descriptor -> essence_codec_ul ) -> id ; if ( coded_width ) st -> codecpar -> width = coded_width ; ret = ff_generate_avci_extradata ( st ) ; if ( ret < 0 ) return ret ; } if ( st -> codecpar -> codec_type != AVMEDIA_TYPE_DATA && source_track -> wrapping != FrameWrapped ) { st -> need_parsing = AVSTREAM_PARSE_TIMESTAMPS ; } } ret = 0 ; fail_and_free : return ret ; }","av_log ( mxf -> fc -> fc , AV_LOG_TRACE , ""metadata<S2SV_blank>sets<S2SV_blank>count<S2SV_blank>%d\\\",76
110,"buggy line: av_log ( mxf , AV_LOG_TRACE , ""could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>essence<S2SV_blank>container<S2SV_blank>data<S2SV_blank>strong<S2SV_blank>ref\\\continue ;cwe id:CWE-125context: static int mxf_parse_structural_metadata ( MXFContext * mxf ) { MXFPackage * material_package = NULL ; int i , j , k , ret ; av_log ( mxf -> fc , AV_LOG_TRACE , ""metadata<S2SV_blank>sets<S2SV_blank>count<S2SV_blank>%d\\n"" , mxf -> metadata_sets_count ) ; for ( i = 0 ; i < mxf -> packages_count ; i ++ ) { material_package = mxf_resolve_strong_ref ( mxf , & mxf -> packages_refs [ i ] , MaterialPackage ) ; if ( material_package ) break ; } if ( ! material_package ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""no<S2SV_blank>material<S2SV_blank>package<S2SV_blank>found\\n"" ) ; return AVERROR_INVALIDDATA ; } mxf_add_umid_metadata ( & mxf -> fc -> metadata , ""material_package_umid"" , material_package ) ; if ( material_package -> name && material_package -> name [ 0 ] ) av_dict_set ( & mxf -> fc -> metadata , ""material_package_name"" , material_package -> name , 0 ) ; mxf_parse_package_comments ( mxf , & mxf -> fc -> metadata , material_package ) ; for ( i = 0 ; i < material_package -> tracks_count ; i ++ ) { MXFPackage * source_package = NULL ; MXFTrack * material_track = NULL ; MXFTrack * source_track = NULL ; MXFTrack * temp_track = NULL ; MXFDescriptor * descriptor = NULL ; MXFStructuralComponent * component = NULL ; MXFTimecodeComponent * mxf_tc = NULL ; UID * essence_container_ul = NULL ; const MXFCodecUL * codec_ul = NULL ; const MXFCodecUL * container_ul = NULL ; const MXFCodecUL * pix_fmt_ul = NULL ; AVStream * st ; AVTimecode tc ; int flags ; if ( ! ( material_track = mxf_resolve_strong_ref ( mxf , & material_package -> tracks_refs [ i ] , Track ) ) ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>material<S2SV_blank>track<S2SV_blank>strong<S2SV_blank>ref\\n"" ) ; continue ; } if ( ( component = mxf_resolve_strong_ref ( mxf , & material_track -> sequence_ref , TimecodeComponent ) ) ) { mxf_tc = ( MXFTimecodeComponent * ) component ; flags = mxf_tc -> drop_frame == 1 ? AV_TIMECODE_FLAG_DROPFRAME : 0 ; if ( av_timecode_init ( & tc , mxf_tc -> rate , flags , mxf_tc -> start_frame , mxf -> fc ) == 0 ) { mxf_add_timecode_metadata ( & mxf -> fc -> metadata , ""timecode"" , & tc ) ; } } if ( ! ( material_track -> sequence = mxf_resolve_strong_ref ( mxf , & material_track -> sequence_ref , Sequence ) ) ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>material<S2SV_blank>track<S2SV_blank>sequence<S2SV_blank>strong<S2SV_blank>ref\\n"" ) ; continue ; } for ( j = 0 ; j < material_track -> sequence -> structural_components_count ; j ++ ) { component = mxf_resolve_strong_ref ( mxf , & material_track -> sequence -> structural_components_refs [ j ] , TimecodeComponent ) ; if ( ! component ) continue ; mxf_tc = ( MXFTimecodeComponent * ) component ; flags = mxf_tc -> drop_frame == 1 ? AV_TIMECODE_FLAG_DROPFRAME : 0 ; if ( av_timecode_init ( & tc , mxf_tc -> rate , flags , mxf_tc -> start_frame , mxf -> fc ) == 0 ) { mxf_add_timecode_metadata ( & mxf -> fc -> metadata , ""timecode"" , & tc ) ; break ; } } if ( material_track -> sequence -> structural_components_count > 1 ) av_log ( mxf -> fc , AV_LOG_WARNING , ""material<S2SV_blank>track<S2SV_blank>%d:<S2SV_blank>has<S2SV_blank>%d<S2SV_blank>components\\n"" , material_track -> track_id , material_track -> sequence -> structural_components_count ) ; for ( j = 0 ; j < material_track -> sequence -> structural_components_count ; j ++ ) { component = mxf_resolve_sourceclip ( mxf , & material_track -> sequence -> structural_components_refs [ j ] ) ; if ( ! component ) continue ; source_package = mxf_resolve_source_package ( mxf , component -> source_package_ul , component -> source_package_uid ) ; if ( ! source_package ) { av_log ( mxf -> fc , AV_LOG_TRACE , ""material<S2SV_blank>track<S2SV_blank>%d:<S2SV_blank>no<S2SV_blank>corresponding<S2SV_blank>source<S2SV_blank>package<S2SV_blank>found\\n"" , material_track -> track_id ) ; continue ; } for ( k = 0 ; k < source_package -> tracks_count ; k ++ ) { if ( ! ( temp_track = mxf_resolve_strong_ref ( mxf , & source_package -> tracks_refs [ k ] , Track ) ) ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>source<S2SV_blank>track<S2SV_blank>strong<S2SV_blank>ref\\n"" ) ; ret = AVERROR_INVALIDDATA ; goto fail_and_free ; } if ( temp_track -> track_id == component -> source_track_id ) { source_track = temp_track ; break ; } } if ( ! source_track ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""material<S2SV_blank>track<S2SV_blank>%d:<S2SV_blank>no<S2SV_blank>corresponding<S2SV_blank>source<S2SV_blank>track<S2SV_blank>found\\n"" , material_track -> track_id ) ; break ; } for ( k = 0 ; k < mxf -> essence_container_data_count ; k ++ ) { MXFEssenceContainerData * essence_data ; if ( ! ( essence_data = mxf_resolve_strong_ref ( mxf , & mxf -> essence_container_data_refs [ k ] , EssenceContainerData ) ) ) {  av_log ( mxf , AV_LOG_TRACE , ""could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>essence<S2SV_blank>container<S2SV_blank>data<S2SV_blank>strong<S2SV_blank>ref\\n"" ) ;  continue ; } if ( ! memcmp ( component -> source_package_ul , essence_data -> package_ul , sizeof ( UID ) ) && ! memcmp ( component -> source_package_uid , essence_data -> package_uid , sizeof ( UID ) ) ) { source_track -> body_sid = essence_data -> body_sid ; source_track -> index_sid = essence_data -> index_sid ; break ; } } if ( source_track && component ) break ; } if ( ! source_track || ! component || ! source_package ) { if ( ( ret = mxf_add_metadata_stream ( mxf , material_track ) ) ) goto fail_and_free ; continue ; } if ( ! ( source_track -> sequence = mxf_resolve_strong_ref ( mxf , & source_track -> sequence_ref , Sequence ) ) ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>source<S2SV_blank>track<S2SV_blank>sequence<S2SV_blank>strong<S2SV_blank>ref\\n"" ) ; ret = AVERROR_INVALIDDATA ; goto fail_and_free ; } if ( memcmp ( material_track -> sequence -> data_definition_ul , source_track -> sequence -> data_definition_ul , 16 ) ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""material<S2SV_blank>track<S2SV_blank>%d:<S2SV_blank>DataDefinition<S2SV_blank>mismatch\\n"" , material_track -> track_id ) ; continue ; } st = avformat_new_stream ( mxf -> fc , NULL ) ; if ( ! st ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>stream\\n"" ) ; ret = AVERROR ( ENOMEM ) ; goto fail_and_free ; } st -> id = material_track -> track_id ; st -> priv_data = source_track ; source_package -> descriptor = mxf_resolve_strong_ref ( mxf , & source_package -> descriptor_ref , AnyType ) ; descriptor = mxf_resolve_multidescriptor ( mxf , source_package -> descriptor , source_track -> track_id ) ; if ( descriptor && descriptor -> duration != AV_NOPTS_VALUE ) source_track -> original_duration = st -> duration = FFMIN ( descriptor -> duration , component -> duration ) ; else source_track -> original_duration = st -> duration = component -> duration ; if ( st -> duration == - 1 ) st -> duration = AV_NOPTS_VALUE ; st -> start_time = component -> start_position ; if ( material_track -> edit_rate . num <= 0 || material_track -> edit_rate . den <= 0 ) { av_log ( mxf -> fc , AV_LOG_WARNING , ""Invalid<S2SV_blank>edit<S2SV_blank>rate<S2SV_blank>(%d/%d)<S2SV_blank>found<S2SV_blank>on<S2SV_blank>stream<S2SV_blank>#%d,<S2SV_blank>"" ""defaulting<S2SV_blank>to<S2SV_blank>25/1\\n"" , material_track -> edit_rate . num , material_track -> edit_rate . den , st -> index ) ; material_track -> edit_rate = ( AVRational ) { 25 , 1 } ; } avpriv_set_pts_info ( st , 64 , material_track -> edit_rate . den , material_track -> edit_rate . num ) ; source_track -> edit_rate = material_track -> edit_rate ; PRINT_KEY ( mxf -> fc , ""data<S2SV_blank>definition<S2SV_blank><S2SV_blank><S2SV_blank>ul"" , source_track -> sequence -> data_definition_ul ) ; codec_ul = mxf_get_codec_ul ( ff_mxf_data_definition_uls , & source_track -> sequence -> data_definition_ul ) ; st -> codecpar -> codec_type = codec_ul -> id ; if ( ! descriptor ) { av_log ( mxf -> fc , AV_LOG_INFO , ""source<S2SV_blank>track<S2SV_blank>%d:<S2SV_blank>stream<S2SV_blank>%d,<S2SV_blank>no<S2SV_blank>descriptor<S2SV_blank>found\\n"" , source_track -> track_id , st -> index ) ; continue ; } PRINT_KEY ( mxf -> fc , ""essence<S2SV_blank>codec<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>ul"" , descriptor -> essence_codec_ul ) ; PRINT_KEY ( mxf -> fc , ""essence<S2SV_blank>container<S2SV_blank>ul"" , descriptor -> essence_container_ul ) ; essence_container_ul = & descriptor -> essence_container_ul ; source_track -> wrapping = ( mxf -> op == OPAtom ) ? ClipWrapped : mxf_get_wrapping_kind ( essence_container_ul ) ; if ( source_track -> wrapping == UnknownWrapped ) av_log ( mxf -> fc , AV_LOG_INFO , ""wrapping<S2SV_blank>of<S2SV_blank>stream<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>unknown\\n"" , st -> index ) ; if ( IS_KLV_KEY ( essence_container_ul , mxf_encrypted_essence_container ) ) { av_log ( mxf -> fc , AV_LOG_INFO , ""broken<S2SV_blank>encrypted<S2SV_blank>mxf<S2SV_blank>file\\n"" ) ; for ( k = 0 ; k < mxf -> metadata_sets_count ; k ++ ) { MXFMetadataSet * metadata = mxf -> metadata_sets [ k ] ; if ( metadata -> type == CryptoContext ) { essence_container_ul = & ( ( MXFCryptoContext * ) metadata ) -> source_container_ul ; break ; } } } codec_ul = mxf_get_codec_ul ( ff_mxf_codec_uls , & descriptor -> essence_codec_ul ) ; st -> codecpar -> codec_id = ( enum AVCodecID ) codec_ul -> id ; if ( st -> codecpar -> codec_id == AV_CODEC_ID_NONE ) { codec_ul = mxf_get_codec_ul ( ff_mxf_codec_uls , & descriptor -> codec_ul ) ; st -> codecpar -> codec_id = ( enum AVCodecID ) codec_ul -> id ; } av_log ( mxf -> fc , AV_LOG_VERBOSE , ""%s:<S2SV_blank>Universal<S2SV_blank>Label:<S2SV_blank>"" , avcodec_get_name ( st -> codecpar -> codec_id ) ) ; for ( k = 0 ; k < 16 ; k ++ ) { av_log ( mxf -> fc , AV_LOG_VERBOSE , ""%.2x"" , descriptor -> essence_codec_ul [ k ] ) ; if ( ! ( k + 1 & 19 ) || k == 5 ) av_log ( mxf -> fc , AV_LOG_VERBOSE , ""."" ) ; } av_log ( mxf -> fc , AV_LOG_VERBOSE , ""\\n"" ) ; mxf_add_umid_metadata ( & st -> metadata , ""file_package_umid"" , source_package ) ; if ( source_package -> name && source_package -> name [ 0 ] ) av_dict_set ( & st -> metadata , ""file_package_name"" , source_package -> name , 0 ) ; if ( material_track -> name && material_track -> name [ 0 ] ) av_dict_set ( & st -> metadata , ""track_name"" , material_track -> name , 0 ) ; mxf_parse_physical_source_package ( mxf , source_track , st ) ; if ( st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO ) { source_track -> intra_only = mxf_is_intra_only ( descriptor ) ; container_ul = mxf_get_codec_ul ( mxf_picture_essence_container_uls , essence_container_ul ) ; if ( st -> codecpar -> codec_id == AV_CODEC_ID_NONE ) st -> codecpar -> codec_id = container_ul -> id ; st -> codecpar -> width = descriptor -> width ; st -> codecpar -> height = descriptor -> height ; switch ( descriptor -> frame_layout ) { case FullFrame : st -> codecpar -> field_order = AV_FIELD_PROGRESSIVE ; break ; case OneField : av_log ( mxf -> fc , AV_LOG_INFO , ""OneField<S2SV_blank>frame<S2SV_blank>layout<S2SV_blank>isn\'t<S2SV_blank>currently<S2SV_blank>supported\\n"" ) ; break ; case MixedFields : break ; case SegmentedFrame : st -> codecpar -> field_order = AV_FIELD_PROGRESSIVE ; case SeparateFields : av_log ( mxf -> fc , AV_LOG_DEBUG , ""video_line_map:<S2SV_blank>(%d,<S2SV_blank>%d),<S2SV_blank>field_dominance:<S2SV_blank>%d\\n"" , descriptor -> video_line_map [ 0 ] , descriptor -> video_line_map [ 1 ] , descriptor -> field_dominance ) ; if ( ( descriptor -> video_line_map [ 0 ] > 0 ) && ( descriptor -> video_line_map [ 1 ] > 0 ) ) { if ( ( descriptor -> video_line_map [ 0 ] + descriptor -> video_line_map [ 1 ] ) % 2 ) { switch ( descriptor -> field_dominance ) { case MXF_FIELD_DOMINANCE_DEFAULT : case MXF_FIELD_DOMINANCE_FF : st -> codecpar -> field_order = AV_FIELD_TT ; break ; case MXF_FIELD_DOMINANCE_FL : st -> codecpar -> field_order = AV_FIELD_TB ; break ; default : avpriv_request_sample ( mxf -> fc , ""Field<S2SV_blank>dominance<S2SV_blank>%d<S2SV_blank>support"" , descriptor -> field_dominance ) ; } } else { switch ( descriptor -> field_dominance ) { case MXF_FIELD_DOMINANCE_DEFAULT : case MXF_FIELD_DOMINANCE_FF : st -> codecpar -> field_order = AV_FIELD_BB ; break ; case MXF_FIELD_DOMINANCE_FL : st -> codecpar -> field_order = AV_FIELD_BT ; break ; default : avpriv_request_sample ( mxf -> fc , ""Field<S2SV_blank>dominance<S2SV_blank>%d<S2SV_blank>support"" , descriptor -> field_dominance ) ; } } } st -> codecpar -> height *= 2 ; break ; default : av_log ( mxf -> fc , AV_LOG_INFO , ""Unknown<S2SV_blank>frame<S2SV_blank>layout<S2SV_blank>type:<S2SV_blank>%d\\n"" , descriptor -> frame_layout ) ; } if ( st -> codecpar -> codec_id == AV_CODEC_ID_RAWVIDEO ) { st -> codecpar -> format = descriptor -> pix_fmt ; if ( st -> codecpar -> format == AV_PIX_FMT_NONE ) { pix_fmt_ul = mxf_get_codec_ul ( ff_mxf_pixel_format_uls , & descriptor -> essence_codec_ul ) ; st -> codecpar -> format = ( enum AVPixelFormat ) pix_fmt_ul -> id ; if ( st -> codecpar -> format == AV_PIX_FMT_NONE ) { st -> codecpar -> codec_tag = mxf_get_codec_ul ( ff_mxf_codec_tag_uls , & descriptor -> essence_codec_ul ) -> id ; if ( ! st -> codecpar -> codec_tag ) { if ( descriptor -> horiz_subsampling == 2 && descriptor -> vert_subsampling == 1 && descriptor -> component_depth == 8 ) { st -> codecpar -> format = AV_PIX_FMT_UYVY422 ; } } } } } st -> need_parsing = AVSTREAM_PARSE_HEADERS ; if ( material_track -> sequence -> origin ) { av_dict_set_int ( & st -> metadata , ""material_track_origin"" , material_track -> sequence -> origin , 0 ) ; } if ( source_track -> sequence -> origin ) { av_dict_set_int ( & st -> metadata , ""source_track_origin"" , source_track -> sequence -> origin , 0 ) ; } if ( descriptor -> aspect_ratio . num && descriptor -> aspect_ratio . den ) st -> display_aspect_ratio = descriptor -> aspect_ratio ; } else if ( st -> codecpar -> codec_type == AVMEDIA_TYPE_AUDIO ) { container_ul = mxf_get_codec_ul ( mxf_sound_essence_container_uls , essence_container_ul ) ; if ( st -> codecpar -> codec_id == AV_CODEC_ID_NONE || ( st -> codecpar -> codec_id == AV_CODEC_ID_PCM_ALAW && ( enum AVCodecID ) container_ul -> id != AV_CODEC_ID_NONE ) ) st -> codecpar -> codec_id = ( enum AVCodecID ) container_ul -> id ; st -> codecpar -> channels = descriptor -> channels ; st -> codecpar -> bits_per_coded_sample = descriptor -> bits_per_sample ; if ( descriptor -> sample_rate . den > 0 ) { st -> codecpar -> sample_rate = descriptor -> sample_rate . num / descriptor -> sample_rate . den ; avpriv_set_pts_info ( st , 64 , descriptor -> sample_rate . den , descriptor -> sample_rate . num ) ; } else { av_log ( mxf -> fc , AV_LOG_WARNING , ""invalid<S2SV_blank>sample<S2SV_blank>rate<S2SV_blank>(%d/%d)<S2SV_blank>"" ""found<S2SV_blank>for<S2SV_blank>stream<S2SV_blank>#%d,<S2SV_blank>time<S2SV_blank>base<S2SV_blank>forced<S2SV_blank>to<S2SV_blank>1/48000\\n"" , descriptor -> sample_rate . num , descriptor -> sample_rate . den , st -> index ) ; avpriv_set_pts_info ( st , 64 , 1 , 48000 ) ; } if ( st -> duration != AV_NOPTS_VALUE ) st -> duration = av_rescale_q ( st -> duration , av_inv_q ( material_track -> edit_rate ) , st -> time_base ) ; if ( st -> codecpar -> codec_id == AV_CODEC_ID_PCM_S16LE ) { if ( descriptor -> bits_per_sample > 16 && descriptor -> bits_per_sample <= 24 ) st -> codecpar -> codec_id = AV_CODEC_ID_PCM_S24LE ; else if ( descriptor -> bits_per_sample == 32 ) st -> codecpar -> codec_id = AV_CODEC_ID_PCM_S32LE ; } else if ( st -> codecpar -> codec_id == AV_CODEC_ID_PCM_S16BE ) { if ( descriptor -> bits_per_sample > 16 && descriptor -> bits_per_sample <= 24 ) st -> codecpar -> codec_id = AV_CODEC_ID_PCM_S24BE ; else if ( descriptor -> bits_per_sample == 32 ) st -> codecpar -> codec_id = AV_CODEC_ID_PCM_S32BE ; } else if ( st -> codecpar -> codec_id == AV_CODEC_ID_MP2 ) { st -> need_parsing = AVSTREAM_PARSE_FULL ; } } else if ( st -> codecpar -> codec_type == AVMEDIA_TYPE_DATA ) { enum AVMediaType type ; container_ul = mxf_get_codec_ul ( mxf_data_essence_container_uls , essence_container_ul ) ; if ( st -> codecpar -> codec_id == AV_CODEC_ID_NONE ) st -> codecpar -> codec_id = container_ul -> id ; type = avcodec_get_type ( st -> codecpar -> codec_id ) ; if ( type == AVMEDIA_TYPE_SUBTITLE ) st -> codecpar -> codec_type = type ; if ( container_ul -> desc ) av_dict_set ( & st -> metadata , ""data_type"" , container_ul -> desc , 0 ) ; } if ( descriptor -> extradata ) { if ( ! ff_alloc_extradata ( st -> codecpar , descriptor -> extradata_size ) ) { memcpy ( st -> codecpar -> extradata , descriptor -> extradata , descriptor -> extradata_size ) ; } } else if ( st -> codecpar -> codec_id == AV_CODEC_ID_H264 ) { int coded_width = mxf_get_codec_ul ( mxf_intra_only_picture_coded_width , & descriptor -> essence_codec_ul ) -> id ; if ( coded_width ) st -> codecpar -> width = coded_width ; ret = ff_generate_avci_extradata ( st ) ; if ( ret < 0 ) return ret ; } if ( st -> codecpar -> codec_type != AVMEDIA_TYPE_DATA && source_track -> wrapping != FrameWrapped ) { st -> need_parsing = AVSTREAM_PARSE_TIMESTAMPS ; } } ret = 0 ; fail_and_free : return ret ; }","av_log ( mxf , AV_LOG_TRACE , ""could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>essence<S2SV_blank>container<S2SV_blank>data<S2SV_blank>strong<S2SV_blank>ref\\\continue ;",76
111,"buggy line: return mount_entry_on_generic ( mntent , path ) ;}cwe id:CWE-59context: static int mount_entry_on_relative_rootfs ( struct mntent * mntent , const char * rootfs ) { char path [ MAXPATHLEN ] ; int ret ; ret = snprintf ( path , sizeof ( path ) , ""%s/%s"" , rootfs , mntent -> mnt_dir ) ; if ( ret >= sizeof ( path ) ) { ERROR ( ""path<S2SV_blank>name<S2SV_blank>too<S2SV_blank>long"" ) ; return - 1 ; }  return mount_entry_on_generic ( mntent , path ) ;  }","return mount_entry_on_generic ( mntent , path , rootfs ) ;}",77
112,"buggy line: -------------------\\\psf_binheader_readf ( psf , ""p"" , psf -> fileoffset ) ;return 1 ;return 0 ;}cwe id:CWE-119context: int id3_skip ( SF_PRIVATE * psf ) { unsigned char buf [ 10 ] ; memset ( buf , 0 , sizeof ( buf ) ) ; psf_binheader_readf ( psf , ""pb"" , 0 , buf , 10 ) ; if ( buf [ 0 ] == 'I' && buf [ 1 ] == 'D' && buf [ 2 ] == '3' ) { int offset = buf [ 6 ] & 0x7f ; offset = ( offset << 7 ) | ( buf [ 7 ] & 0x7f ) ; offset = ( offset << 7 ) | ( buf [ 8 ] & 0x7f ) ; offset = ( offset << 7 ) | ( buf [ 9 ] & 0x7f ) ; psf_log_printf ( psf , ""ID3<S2SV_blank>length<S2SV_blank>:<S2SV_blank>%d\\n--------------------\\n"" , offset ) ; if ( offset < 0 ) return 0 ; psf -> fileoffset += offset + 10 ;  psf_binheader_readf ( psf , ""p"" , psf -> fileoffset ) ;  return 1 ; } ;  return 0 ;  }","if ( psf -> fileoffset < psf -> filelength ) {psf_binheader_readf ( psf , ""p"" , psf -> fileoffset ) ;return 1 ;};return 0 ;}",78
113,"buggy line: cwe id:CWE-125context: static int juniper_parse_header ( netdissect_options * ndo , const u_char * p , const struct pcap_pkthdr * h , struct juniper_l2info_t * l2info ) { const struct juniper_cookie_table_t * lp = juniper_cookie_table ; u_int idx , jnx_ext_len , jnx_header_len = 0 ; uint8_t tlv_type , tlv_len ; uint32_t control_word ; int tlv_value ; const u_char * tptr ; l2info -> header_len = 0 ; l2info -> cookie_len = 0 ; l2info -> proto = 0 ; l2info -> length = h -> len ; l2info -> caplen = h -> caplen ; ND_TCHECK2 ( p [ 0 ] , 4 ) ; l2info -> flags = p [ 3 ] ; l2info -> direction = p [ 3 ] & JUNIPER_BPF_PKT_IN ; if ( EXTRACT_24BITS ( p ) != JUNIPER_MGC_NUMBER ) { ND_PRINT ( ( ndo , ""no<S2SV_blank>magic-number<S2SV_blank>found!"" ) ) ; return 0 ; } if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""%3s<S2SV_blank>"" , tok2str ( juniper_direction_values , ""---"" , l2info -> direction ) ) ) ; jnx_header_len = 4 ; if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\n\\tJuniper<S2SV_blank>PCAP<S2SV_blank>Flags<S2SV_blank>[%s]"" , bittok2str ( jnx_flag_values , ""none"" , l2info -> flags ) ) ) ; if ( ( l2info -> flags & JUNIPER_BPF_EXT ) == JUNIPER_BPF_EXT ) { tptr = p + jnx_header_len ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; jnx_ext_len = EXTRACT_16BITS ( tptr ) ; jnx_header_len += 2 ; tptr += 2 ; jnx_header_len += jnx_ext_len ; if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , "",<S2SV_blank>PCAP<S2SV_blank>Extension(s)<S2SV_blank>total<S2SV_blank>length<S2SV_blank>%u"" , jnx_ext_len ) ) ; ND_TCHECK2 ( tptr [ 0 ] , jnx_ext_len ) ; while ( jnx_ext_len > JUNIPER_EXT_TLV_OVERHEAD ) { tlv_type = * ( tptr ++ ) ; tlv_len = * ( tptr ++ ) ; tlv_value = 0 ; if ( tlv_type == 0 || tlv_len == 0 ) break ; if ( tlv_len + JUNIPER_EXT_TLV_OVERHEAD > jnx_ext_len ) goto trunc ; if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Extension<S2SV_blank>TLV<S2SV_blank>#%u,<S2SV_blank>length<S2SV_blank>%u,<S2SV_blank>value<S2SV_blank>"" , tok2str ( jnx_ext_tlv_values , ""Unknown"" , tlv_type ) , tlv_type , tlv_len ) ) ; tlv_value = juniper_read_tlv_value ( tptr , tlv_type , tlv_len ) ; switch ( tlv_type ) { case JUNIPER_EXT_TLV_IFD_NAME : break ; case JUNIPER_EXT_TLV_IFD_MEDIATYPE : case JUNIPER_EXT_TLV_TTP_IFD_MEDIATYPE : if ( tlv_value != - 1 ) { if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""%s<S2SV_blank>(%u)"" , tok2str ( juniper_ifmt_values , ""Unknown"" , tlv_value ) , tlv_value ) ) ; } break ; case JUNIPER_EXT_TLV_IFL_ENCAPS : case JUNIPER_EXT_TLV_TTP_IFL_ENCAPS : if ( tlv_value != - 1 ) { if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""%s<S2SV_blank>(%u)"" , tok2str ( juniper_ifle_values , ""Unknown"" , tlv_value ) , tlv_value ) ) ; } break ; case JUNIPER_EXT_TLV_IFL_IDX : case JUNIPER_EXT_TLV_IFL_UNIT : case JUNIPER_EXT_TLV_IFD_IDX : default : if ( tlv_value != - 1 ) { if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""%u"" , tlv_value ) ) ; } break ; } tptr += tlv_len ; jnx_ext_len -= tlv_len + JUNIPER_EXT_TLV_OVERHEAD ; } if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\n\\t-----original<S2SV_blank>packet-----\\n\\t"" ) ) ; } if ( ( l2info -> flags & JUNIPER_BPF_NO_L2 ) == JUNIPER_BPF_NO_L2 ) { if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""no-L2-hdr,<S2SV_blank>"" ) ) ; ND_TCHECK2 ( p [ jnx_header_len + 4 ] , 1 ) ; if ( ip_heuristic_guess ( ndo , p + jnx_header_len + 4 , l2info -> length - ( jnx_header_len + 4 ) ) == 0 ) ND_PRINT ( ( ndo , ""no<S2SV_blank>IP-hdr<S2SV_blank>found!"" ) ) ; l2info -> header_len = jnx_header_len + 4 ; return 0 ; } l2info -> header_len = jnx_header_len ; p += l2info -> header_len ; l2info -> length -= l2info -> header_len ; l2info -> caplen -= l2info -> header_len ; ND_TCHECK ( p [ 0 ] ) ; while ( lp -> s != NULL ) { if ( lp -> pictype == l2info -> pictype ) { l2info -> cookie_len += lp -> cookie_len ; switch ( p [ 0 ] ) { case LS_COOKIE_ID : l2info -> cookie_type = LS_COOKIE_ID ; l2info -> cookie_len += 2 ; break ; case AS_COOKIE_ID : l2info -> cookie_type = AS_COOKIE_ID ; l2info -> cookie_len = 8 ; break ; default : l2info -> bundle = l2info -> cookie [ 0 ] ; break ; } # ifdef DLT_JUNIPER_MFR if ( l2info -> pictype == DLT_JUNIPER_MFR && ( p [ 0 ] & MFR_BE_MASK ) == MFR_BE_MASK ) { l2info -> cookie_len = 0 ; } # endif l2info -> header_len += l2info -> cookie_len ; l2info -> length -= l2info -> cookie_len ; l2info -> caplen -= l2info -> cookie_len ; if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""%s-PIC,<S2SV_blank>cookie-len<S2SV_blank>%u"" , lp -> s , l2info -> cookie_len ) ) ; if ( l2info -> cookie_len > 0 ) { ND_TCHECK2 ( p [ 0 ] , l2info -> cookie_len ) ; if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>cookie<S2SV_blank>0x"" ) ) ; for ( idx = 0 ; idx < l2info -> cookie_len ; idx ++ ) { l2info -> cookie [ idx ] = p [ idx ] ; if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""%02x"" , p [ idx ] ) ) ; } } if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , "":<S2SV_blank>"" ) ) ;  l2info -> proto = EXTRACT_16BITS ( p + l2info -> cookie_len ) ;  break ; } ++ lp ; } p += l2info -> cookie_len ; switch ( l2info -> pictype ) { # ifdef DLT_JUNIPER_MLPPP case DLT_JUNIPER_MLPPP : switch ( l2info -> cookie_type ) { case LS_COOKIE_ID : l2info -> bundle = l2info -> cookie [ 1 ] ; break ; case AS_COOKIE_ID : l2info -> bundle = ( EXTRACT_16BITS ( & l2info -> cookie [ 6 ] ) >> 3 ) & 0xfff ; l2info -> proto = ( l2info -> cookie [ 5 ] ) & JUNIPER_LSQ_L3_PROTO_MASK ; break ; default : l2info -> bundle = l2info -> cookie [ 0 ] ; break ; } break ; # endif # ifdef DLT_JUNIPER_MLFR case DLT_JUNIPER_MLFR : switch ( l2info -> cookie_type ) { case LS_COOKIE_ID : ND_TCHECK2 ( p [ 0 ] , 2 ) ; l2info -> bundle = l2info -> cookie [ 1 ] ; l2info -> proto = EXTRACT_16BITS ( p ) ; l2info -> header_len += 2 ; l2info -> length -= 2 ; l2info -> caplen -= 2 ; break ; case AS_COOKIE_ID : l2info -> bundle = ( EXTRACT_16BITS ( & l2info -> cookie [ 6 ] ) >> 3 ) & 0xfff ; l2info -> proto = ( l2info -> cookie [ 5 ] ) & JUNIPER_LSQ_L3_PROTO_MASK ; break ; default : l2info -> bundle = l2info -> cookie [ 0 ] ; l2info -> header_len += 2 ; l2info -> length -= 2 ; l2info -> caplen -= 2 ; break ; } break ; # endif # ifdef DLT_JUNIPER_MFR case DLT_JUNIPER_MFR : switch ( l2info -> cookie_type ) { case LS_COOKIE_ID : ND_TCHECK2 ( p [ 0 ] , 2 ) ; l2info -> bundle = l2info -> cookie [ 1 ] ; l2info -> proto = EXTRACT_16BITS ( p ) ; l2info -> header_len += 2 ; l2info -> length -= 2 ; l2info -> caplen -= 2 ; break ; case AS_COOKIE_ID : l2info -> bundle = ( EXTRACT_16BITS ( & l2info -> cookie [ 6 ] ) >> 3 ) & 0xfff ; l2info -> proto = ( l2info -> cookie [ 5 ] ) & JUNIPER_LSQ_L3_PROTO_MASK ; break ; default : l2info -> bundle = l2info -> cookie [ 0 ] ; break ; } break ; # endif # ifdef DLT_JUNIPER_ATM2 case DLT_JUNIPER_ATM2 : ND_TCHECK2 ( p [ 0 ] , 4 ) ; if ( l2info -> cookie [ 7 ] & ATM2_PKT_TYPE_MASK ) { control_word = EXTRACT_32BITS ( p ) ; switch ( control_word ) { case 0 : case 0x08000000 : case 0x08380000 : l2info -> header_len += 4 ; break ; default : break ; } if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""control-word<S2SV_blank>0x%08x<S2SV_blank>"" , control_word ) ) ; } break ; # endif # ifdef DLT_JUNIPER_GGSN case DLT_JUNIPER_GGSN : break ; # endif # ifdef DLT_JUNIPER_ATM1 case DLT_JUNIPER_ATM1 : break ; # endif # ifdef DLT_JUNIPER_PPP case DLT_JUNIPER_PPP : break ; # endif # ifdef DLT_JUNIPER_CHDLC case DLT_JUNIPER_CHDLC : break ; # endif # ifdef DLT_JUNIPER_ETHER case DLT_JUNIPER_ETHER : break ; # endif # ifdef DLT_JUNIPER_FRELAY case DLT_JUNIPER_FRELAY : break ; # endif default : ND_PRINT ( ( ndo , ""Unknown<S2SV_blank>Juniper<S2SV_blank>DLT_<S2SV_blank>type<S2SV_blank>%u:<S2SV_blank>"" , l2info -> pictype ) ) ; break ; } if ( ndo -> ndo_eflag > 1 ) ND_PRINT ( ( ndo , ""hlen<S2SV_blank>%u,<S2SV_blank>proto<S2SV_blank>0x%04x,<S2SV_blank>"" , l2info -> header_len , l2info -> proto ) ) ; return 1 ; trunc : ND_PRINT ( ( ndo , ""[|juniper_hdr],<S2SV_blank>length<S2SV_blank>%u"" , h -> len ) ) ; return 0 ; }",ND_TCHECK_16BITS ( p + l2info -> cookie_len ) ;,79
114,"buggy line: l2info -> proto = EXTRACT_16BITS ( p + l2info -> cookie_len ) ;break ;cwe id:CWE-125context: static int juniper_parse_header ( netdissect_options * ndo , const u_char * p , const struct pcap_pkthdr * h , struct juniper_l2info_t * l2info ) { const struct juniper_cookie_table_t * lp = juniper_cookie_table ; u_int idx , jnx_ext_len , jnx_header_len = 0 ; uint8_t tlv_type , tlv_len ; uint32_t control_word ; int tlv_value ; const u_char * tptr ; l2info -> header_len = 0 ; l2info -> cookie_len = 0 ; l2info -> proto = 0 ; l2info -> length = h -> len ; l2info -> caplen = h -> caplen ; ND_TCHECK2 ( p [ 0 ] , 4 ) ; l2info -> flags = p [ 3 ] ; l2info -> direction = p [ 3 ] & JUNIPER_BPF_PKT_IN ; if ( EXTRACT_24BITS ( p ) != JUNIPER_MGC_NUMBER ) { ND_PRINT ( ( ndo , ""no<S2SV_blank>magic-number<S2SV_blank>found!"" ) ) ; return 0 ; } if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""%3s<S2SV_blank>"" , tok2str ( juniper_direction_values , ""---"" , l2info -> direction ) ) ) ; jnx_header_len = 4 ; if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\n\\tJuniper<S2SV_blank>PCAP<S2SV_blank>Flags<S2SV_blank>[%s]"" , bittok2str ( jnx_flag_values , ""none"" , l2info -> flags ) ) ) ; if ( ( l2info -> flags & JUNIPER_BPF_EXT ) == JUNIPER_BPF_EXT ) { tptr = p + jnx_header_len ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; jnx_ext_len = EXTRACT_16BITS ( tptr ) ; jnx_header_len += 2 ; tptr += 2 ; jnx_header_len += jnx_ext_len ; if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , "",<S2SV_blank>PCAP<S2SV_blank>Extension(s)<S2SV_blank>total<S2SV_blank>length<S2SV_blank>%u"" , jnx_ext_len ) ) ; ND_TCHECK2 ( tptr [ 0 ] , jnx_ext_len ) ; while ( jnx_ext_len > JUNIPER_EXT_TLV_OVERHEAD ) { tlv_type = * ( tptr ++ ) ; tlv_len = * ( tptr ++ ) ; tlv_value = 0 ; if ( tlv_type == 0 || tlv_len == 0 ) break ; if ( tlv_len + JUNIPER_EXT_TLV_OVERHEAD > jnx_ext_len ) goto trunc ; if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Extension<S2SV_blank>TLV<S2SV_blank>#%u,<S2SV_blank>length<S2SV_blank>%u,<S2SV_blank>value<S2SV_blank>"" , tok2str ( jnx_ext_tlv_values , ""Unknown"" , tlv_type ) , tlv_type , tlv_len ) ) ; tlv_value = juniper_read_tlv_value ( tptr , tlv_type , tlv_len ) ; switch ( tlv_type ) { case JUNIPER_EXT_TLV_IFD_NAME : break ; case JUNIPER_EXT_TLV_IFD_MEDIATYPE : case JUNIPER_EXT_TLV_TTP_IFD_MEDIATYPE : if ( tlv_value != - 1 ) { if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""%s<S2SV_blank>(%u)"" , tok2str ( juniper_ifmt_values , ""Unknown"" , tlv_value ) , tlv_value ) ) ; } break ; case JUNIPER_EXT_TLV_IFL_ENCAPS : case JUNIPER_EXT_TLV_TTP_IFL_ENCAPS : if ( tlv_value != - 1 ) { if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""%s<S2SV_blank>(%u)"" , tok2str ( juniper_ifle_values , ""Unknown"" , tlv_value ) , tlv_value ) ) ; } break ; case JUNIPER_EXT_TLV_IFL_IDX : case JUNIPER_EXT_TLV_IFL_UNIT : case JUNIPER_EXT_TLV_IFD_IDX : default : if ( tlv_value != - 1 ) { if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""%u"" , tlv_value ) ) ; } break ; } tptr += tlv_len ; jnx_ext_len -= tlv_len + JUNIPER_EXT_TLV_OVERHEAD ; } if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\n\\t-----original<S2SV_blank>packet-----\\n\\t"" ) ) ; } if ( ( l2info -> flags & JUNIPER_BPF_NO_L2 ) == JUNIPER_BPF_NO_L2 ) { if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""no-L2-hdr,<S2SV_blank>"" ) ) ; ND_TCHECK2 ( p [ jnx_header_len + 4 ] , 1 ) ; if ( ip_heuristic_guess ( ndo , p + jnx_header_len + 4 , l2info -> length - ( jnx_header_len + 4 ) ) == 0 ) ND_PRINT ( ( ndo , ""no<S2SV_blank>IP-hdr<S2SV_blank>found!"" ) ) ; l2info -> header_len = jnx_header_len + 4 ; return 0 ; } l2info -> header_len = jnx_header_len ; p += l2info -> header_len ; l2info -> length -= l2info -> header_len ; l2info -> caplen -= l2info -> header_len ; ND_TCHECK ( p [ 0 ] ) ; while ( lp -> s != NULL ) { if ( lp -> pictype == l2info -> pictype ) { l2info -> cookie_len += lp -> cookie_len ; switch ( p [ 0 ] ) { case LS_COOKIE_ID : l2info -> cookie_type = LS_COOKIE_ID ; l2info -> cookie_len += 2 ; break ; case AS_COOKIE_ID : l2info -> cookie_type = AS_COOKIE_ID ; l2info -> cookie_len = 8 ; break ; default : l2info -> bundle = l2info -> cookie [ 0 ] ; break ; } # ifdef DLT_JUNIPER_MFR if ( l2info -> pictype == DLT_JUNIPER_MFR && ( p [ 0 ] & MFR_BE_MASK ) == MFR_BE_MASK ) { l2info -> cookie_len = 0 ; } # endif l2info -> header_len += l2info -> cookie_len ; l2info -> length -= l2info -> cookie_len ; l2info -> caplen -= l2info -> cookie_len ; if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""%s-PIC,<S2SV_blank>cookie-len<S2SV_blank>%u"" , lp -> s , l2info -> cookie_len ) ) ; if ( l2info -> cookie_len > 0 ) { ND_TCHECK2 ( p [ 0 ] , l2info -> cookie_len ) ; if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>cookie<S2SV_blank>0x"" ) ) ; for ( idx = 0 ; idx < l2info -> cookie_len ; idx ++ ) { l2info -> cookie [ idx ] = p [ idx ] ; if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""%02x"" , p [ idx ] ) ) ; } } if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , "":<S2SV_blank>"" ) ) ;  l2info -> proto = EXTRACT_16BITS ( p + l2info -> cookie_len ) ;  break ; } ++ lp ; } p += l2info -> cookie_len ; switch ( l2info -> pictype ) { # ifdef DLT_JUNIPER_MLPPP case DLT_JUNIPER_MLPPP : switch ( l2info -> cookie_type ) { case LS_COOKIE_ID : l2info -> bundle = l2info -> cookie [ 1 ] ; break ; case AS_COOKIE_ID : l2info -> bundle = ( EXTRACT_16BITS ( & l2info -> cookie [ 6 ] ) >> 3 ) & 0xfff ; l2info -> proto = ( l2info -> cookie [ 5 ] ) & JUNIPER_LSQ_L3_PROTO_MASK ; break ; default : l2info -> bundle = l2info -> cookie [ 0 ] ; break ; } break ; # endif # ifdef DLT_JUNIPER_MLFR case DLT_JUNIPER_MLFR : switch ( l2info -> cookie_type ) { case LS_COOKIE_ID : ND_TCHECK2 ( p [ 0 ] , 2 ) ; l2info -> bundle = l2info -> cookie [ 1 ] ; l2info -> proto = EXTRACT_16BITS ( p ) ; l2info -> header_len += 2 ; l2info -> length -= 2 ; l2info -> caplen -= 2 ; break ; case AS_COOKIE_ID : l2info -> bundle = ( EXTRACT_16BITS ( & l2info -> cookie [ 6 ] ) >> 3 ) & 0xfff ; l2info -> proto = ( l2info -> cookie [ 5 ] ) & JUNIPER_LSQ_L3_PROTO_MASK ; break ; default : l2info -> bundle = l2info -> cookie [ 0 ] ; l2info -> header_len += 2 ; l2info -> length -= 2 ; l2info -> caplen -= 2 ; break ; } break ; # endif # ifdef DLT_JUNIPER_MFR case DLT_JUNIPER_MFR : switch ( l2info -> cookie_type ) { case LS_COOKIE_ID : ND_TCHECK2 ( p [ 0 ] , 2 ) ; l2info -> bundle = l2info -> cookie [ 1 ] ; l2info -> proto = EXTRACT_16BITS ( p ) ; l2info -> header_len += 2 ; l2info -> length -= 2 ; l2info -> caplen -= 2 ; break ; case AS_COOKIE_ID : l2info -> bundle = ( EXTRACT_16BITS ( & l2info -> cookie [ 6 ] ) >> 3 ) & 0xfff ; l2info -> proto = ( l2info -> cookie [ 5 ] ) & JUNIPER_LSQ_L3_PROTO_MASK ; break ; default : l2info -> bundle = l2info -> cookie [ 0 ] ; break ; } break ; # endif # ifdef DLT_JUNIPER_ATM2 case DLT_JUNIPER_ATM2 : ND_TCHECK2 ( p [ 0 ] , 4 ) ; if ( l2info -> cookie [ 7 ] & ATM2_PKT_TYPE_MASK ) { control_word = EXTRACT_32BITS ( p ) ; switch ( control_word ) { case 0 : case 0x08000000 : case 0x08380000 : l2info -> header_len += 4 ; break ; default : break ; } if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""control-word<S2SV_blank>0x%08x<S2SV_blank>"" , control_word ) ) ; } break ; # endif # ifdef DLT_JUNIPER_GGSN case DLT_JUNIPER_GGSN : break ; # endif # ifdef DLT_JUNIPER_ATM1 case DLT_JUNIPER_ATM1 : break ; # endif # ifdef DLT_JUNIPER_PPP case DLT_JUNIPER_PPP : break ; # endif # ifdef DLT_JUNIPER_CHDLC case DLT_JUNIPER_CHDLC : break ; # endif # ifdef DLT_JUNIPER_ETHER case DLT_JUNIPER_ETHER : break ; # endif # ifdef DLT_JUNIPER_FRELAY case DLT_JUNIPER_FRELAY : break ; # endif default : ND_PRINT ( ( ndo , ""Unknown<S2SV_blank>Juniper<S2SV_blank>DLT_<S2SV_blank>type<S2SV_blank>%u:<S2SV_blank>"" , l2info -> pictype ) ) ; break ; } if ( ndo -> ndo_eflag > 1 ) ND_PRINT ( ( ndo , ""hlen<S2SV_blank>%u,<S2SV_blank>proto<S2SV_blank>0x%04x,<S2SV_blank>"" , l2info -> header_len , l2info -> proto ) ) ; return 1 ; trunc : ND_PRINT ( ( ndo , ""[|juniper_hdr],<S2SV_blank>length<S2SV_blank>%u"" , h -> len ) ) ; return 0 ; }",l2info -> proto = EXTRACT_16BITS ( p + l2info -> cookie_len ) ;break ;,79
115,"buggy line: return NF_ACCEPT ;}cwe id:CWE-787context: static unsigned int ipv6_defrag ( void * priv , struct sk_buff * skb , const struct nf_hook_state * state ) { int err ; # if IS_ENABLED ( CONFIG_NF_CONNTRACK ) if ( skb -> nfct && ! nf_ct_is_template ( ( struct nf_conn * ) skb -> nfct ) ) return NF_ACCEPT ; # endif err = nf_ct_frag6_gather ( state -> net , skb , nf_ct6_defrag_user ( state -> hook , skb ) ) ; if ( err == - EINPROGRESS ) return NF_STOLEN ;  return NF_ACCEPT ;  }",return err == 0 ? NF_ACCEPT : NF_DROP ;},80
116,"buggy line: if ( ! rta )  return 0 ;p = kmemdup ( up , xfrm_replay_state_esn_len ( up ) , GFP_KERNEL ) ;if ( ! p ) return - ENOMEM ;pp = kmemdup ( up , xfrm_replay_state_esn_len ( up ) , GFP_KERNEL ) ;if ( ! pp ) {* replay_esn = p ;* preplay_esn = pp ;cwe id:CWE-200context: static int xfrm_alloc_replay_state_esn ( struct xfrm_replay_state_esn * * replay_esn , struct xfrm_replay_state_esn * * preplay_esn , struct nlattr * rta ) { struct xfrm_replay_state_esn * p , * pp , * up ;  if ( ! rta )  return 0 ; up = nla_data ( rta ) ;  p = kmemdup ( up , xfrm_replay_state_esn_len ( up ) , GFP_KERNEL ) ;  if ( ! p ) return - ENOMEM ;  pp = kmemdup ( up , xfrm_replay_state_esn_len ( up ) , GFP_KERNEL ) ;  if ( ! pp ) { kfree ( p ) ; return - ENOMEM ; }  * replay_esn = p ;  * preplay_esn = pp ; return 0 ; }","int klen , ulen ;if ( ! rta ) return 0 ;klen = xfrm_replay_state_esn_len ( up ) ;ulen = nla_len ( rta ) >= klen ? klen : sizeof ( * up ) ;p = kzalloc ( klen , GFP_KERNEL ) ;if ( ! p ) return - ENOMEM ;pp = kzalloc ( klen , GFP_KERNEL ) ;if ( ! pp ) {memcpy ( p , up , ulen ) ;memcpy ( pp , up , ulen ) ;* replay_esn = p ;* preplay_esn = pp ;",81
117,"buggy line: io -> io_cleanup = mem_cleanup ;switch ( io -> regsize ) {cwe id:CWE-416context: int ipmi_si_mem_setup ( struct si_sm_io * io ) { unsigned long addr = io -> addr_data ; int mapsize , idx ; if ( ! addr ) return - ENODEV ;  io -> io_cleanup = mem_cleanup ;  switch ( io -> regsize ) { case 1 : io -> inputb = intf_mem_inb ; io -> outputb = intf_mem_outb ; break ; case 2 : io -> inputb = intf_mem_inw ; io -> outputb = intf_mem_outw ; break ; case 4 : io -> inputb = intf_mem_inl ; io -> outputb = intf_mem_outl ; break ; # ifdef readq case 8 : io -> inputb = mem_inq ; io -> outputb = mem_outq ; break ; # endif default : dev_warn ( io -> dev , ""Invalid<S2SV_blank>register<S2SV_blank>size:<S2SV_blank>%d\\n"" , io -> regsize ) ; return - EINVAL ; } for ( idx = 0 ; idx < io -> io_size ; idx ++ ) { if ( request_mem_region ( addr + idx * io -> regspacing , io -> regsize , DEVICE_NAME ) == NULL ) { mem_region_cleanup ( io , idx ) ; return - EIO ; } } mapsize = ( ( io -> io_size * io -> regspacing ) - ( io -> regspacing - io -> regsize ) ) ; io -> addr = ioremap ( addr , mapsize ) ; if ( io -> addr == NULL ) { mem_region_cleanup ( io , io -> io_size ) ; return - EIO ; }  return 0 ;  }",switch ( io -> regsize ) {,82
118,"buggy line: cwe id:CWE-416context: int ipmi_si_mem_setup ( struct si_sm_io * io ) { unsigned long addr = io -> addr_data ; int mapsize , idx ; if ( ! addr ) return - ENODEV ;  io -> io_cleanup = mem_cleanup ;  switch ( io -> regsize ) { case 1 : io -> inputb = intf_mem_inb ; io -> outputb = intf_mem_outb ; break ; case 2 : io -> inputb = intf_mem_inw ; io -> outputb = intf_mem_outw ; break ; case 4 : io -> inputb = intf_mem_inl ; io -> outputb = intf_mem_outl ; break ; # ifdef readq case 8 : io -> inputb = mem_inq ; io -> outputb = mem_outq ; break ; # endif default : dev_warn ( io -> dev , ""Invalid<S2SV_blank>register<S2SV_blank>size:<S2SV_blank>%d\\n"" , io -> regsize ) ; return - EINVAL ; } for ( idx = 0 ; idx < io -> io_size ; idx ++ ) { if ( request_mem_region ( addr + idx * io -> regspacing , io -> regsize , DEVICE_NAME ) == NULL ) { mem_region_cleanup ( io , idx ) ; return - EIO ; } } mapsize = ( ( io -> io_size * io -> regspacing ) - ( io -> regspacing - io -> regsize ) ) ; io -> addr = ioremap ( addr , mapsize ) ; if ( io -> addr == NULL ) { mem_region_cleanup ( io , io -> io_size ) ; return - EIO ; }  return 0 ;  }",io -> io_cleanup = mem_cleanup ;,82
119,"buggy line: return 0 ;}cwe id:CWE-416context: int ipmi_si_mem_setup ( struct si_sm_io * io ) { unsigned long addr = io -> addr_data ; int mapsize , idx ; if ( ! addr ) return - ENODEV ;  io -> io_cleanup = mem_cleanup ;  switch ( io -> regsize ) { case 1 : io -> inputb = intf_mem_inb ; io -> outputb = intf_mem_outb ; break ; case 2 : io -> inputb = intf_mem_inw ; io -> outputb = intf_mem_outw ; break ; case 4 : io -> inputb = intf_mem_inl ; io -> outputb = intf_mem_outl ; break ; # ifdef readq case 8 : io -> inputb = mem_inq ; io -> outputb = mem_outq ; break ; # endif default : dev_warn ( io -> dev , ""Invalid<S2SV_blank>register<S2SV_blank>size:<S2SV_blank>%d\\n"" , io -> regsize ) ; return - EINVAL ; } for ( idx = 0 ; idx < io -> io_size ; idx ++ ) { if ( request_mem_region ( addr + idx * io -> regspacing , io -> regsize , DEVICE_NAME ) == NULL ) { mem_region_cleanup ( io , idx ) ; return - EIO ; } } mapsize = ( ( io -> io_size * io -> regspacing ) - ( io -> regspacing - io -> regsize ) ) ; io -> addr = ioremap ( addr , mapsize ) ; if ( io -> addr == NULL ) { mem_region_cleanup ( io , io -> io_size ) ; return - EIO ; }  return 0 ;  }",return 0 ;},82
120,"buggy line: result = ( MagickRealType ) ( ( size_t ) pixel & ( size_t ) ( value + 0.5 ) ) ;break ;cwe id:CWE-190context: static MagickRealType ApplyEvaluateOperator ( RandomInfo * random_info , const Quantum pixel , const MagickEvaluateOperator op , const MagickRealType value ) { MagickRealType result ; result = 0.0 ; switch ( op ) { case UndefinedEvaluateOperator : break ; case AbsEvaluateOperator : { result = ( MagickRealType ) fabs ( ( double ) ( pixel + value ) ) ; break ; } case AddEvaluateOperator : { result = ( MagickRealType ) ( pixel + value ) ; break ; } case AddModulusEvaluateOperator : { result = pixel + value ; result -= ( QuantumRange + 1.0 ) * floor ( ( double ) result / ( QuantumRange + 1.0 ) ) ; break ; } case AndEvaluateOperator : {  result = ( MagickRealType ) ( ( size_t ) pixel & ( size_t ) ( value + 0.5 ) ) ;  break ; } case CosineEvaluateOperator : { result = ( MagickRealType ) ( QuantumRange * ( 0.5 * cos ( ( double ) ( 2.0 * MagickPI * QuantumScale * pixel * value ) ) + 0.5 ) ) ; break ; } case DivideEvaluateOperator : { result = pixel / ( value == 0.0 ? 1.0 : value ) ; break ; } case ExponentialEvaluateOperator : { result = ( MagickRealType ) ( QuantumRange * exp ( ( double ) ( value * QuantumScale * pixel ) ) ) ; break ; } case GaussianNoiseEvaluateOperator : { result = ( MagickRealType ) GenerateDifferentialNoise ( random_info , pixel , GaussianNoise , value ) ; break ; } case ImpulseNoiseEvaluateOperator : { result = ( MagickRealType ) GenerateDifferentialNoise ( random_info , pixel , ImpulseNoise , value ) ; break ; } case LaplacianNoiseEvaluateOperator : { result = ( MagickRealType ) GenerateDifferentialNoise ( random_info , pixel , LaplacianNoise , value ) ; break ; } case LeftShiftEvaluateOperator : {  result = ( MagickRealType ) ( ( size_t ) pixel << ( size_t ) ( value + 0.5 ) ) ;  break ; } case LogEvaluateOperator : { if ( ( QuantumScale * pixel ) >= MagickEpsilon ) result = ( MagickRealType ) ( QuantumRange * log ( ( double ) ( QuantumScale * value * pixel + 1.0 ) ) / log ( ( double ) ( value + 1.0 ) ) ) ; break ; } case MaxEvaluateOperator : { result = ( MagickRealType ) EvaluateMax ( ( double ) pixel , value ) ; break ; } case MeanEvaluateOperator : { result = ( MagickRealType ) ( pixel + value ) ; break ; } case MedianEvaluateOperator : { result = ( MagickRealType ) ( pixel + value ) ; break ; } case MinEvaluateOperator : { result = ( MagickRealType ) MagickMin ( ( double ) pixel , value ) ; break ; } case MultiplicativeNoiseEvaluateOperator : { result = ( MagickRealType ) GenerateDifferentialNoise ( random_info , pixel , MultiplicativeGaussianNoise , value ) ; break ; } case MultiplyEvaluateOperator : { result = ( MagickRealType ) ( value * pixel ) ; break ; } case OrEvaluateOperator : {  result = ( MagickRealType ) ( ( size_t ) pixel | ( size_t ) ( value + 0.5 ) ) ;  break ; } case PoissonNoiseEvaluateOperator : { result = ( MagickRealType ) GenerateDifferentialNoise ( random_info , pixel , PoissonNoise , value ) ; break ; } case PowEvaluateOperator : { result = ( MagickRealType ) ( QuantumRange * pow ( ( double ) ( QuantumScale * pixel ) , ( double ) value ) ) ; break ; } case RightShiftEvaluateOperator : {  result = ( MagickRealType ) ( ( size_t ) pixel >> ( size_t ) ( value + 0.5 ) ) ;  break ; } case RootMeanSquareEvaluateOperator : { result = ( MagickRealType ) ( pixel * pixel + value ) ; break ; } case SetEvaluateOperator : { result = value ; break ; } case SineEvaluateOperator : { result = ( MagickRealType ) ( QuantumRange * ( 0.5 * sin ( ( double ) ( 2.0 * MagickPI * QuantumScale * pixel * value ) ) + 0.5 ) ) ; break ; } case SubtractEvaluateOperator : { result = ( MagickRealType ) ( pixel - value ) ; break ; } case SumEvaluateOperator : { result = ( MagickRealType ) ( pixel + value ) ; break ; } case ThresholdEvaluateOperator : { result = ( MagickRealType ) ( ( ( MagickRealType ) pixel <= value ) ? 0 : QuantumRange ) ; break ; } case ThresholdBlackEvaluateOperator : { result = ( MagickRealType ) ( ( ( MagickRealType ) pixel <= value ) ? 0 : pixel ) ; break ; } case ThresholdWhiteEvaluateOperator : { result = ( MagickRealType ) ( ( ( MagickRealType ) pixel > value ) ? QuantumRange : pixel ) ; break ; } case UniformNoiseEvaluateOperator : { result = ( MagickRealType ) GenerateDifferentialNoise ( random_info , pixel , UniformNoise , value ) ; break ; } case XorEvaluateOperator : {  result = ( MagickRealType ) ( ( size_t ) pixel ^ ( size_t ) ( value + 0.5 ) ) ;  break ; } } return ( result ) ; }",result = ( MagickRealType ) ( ( ssize_t ) pixel & ( size_t ) ( value + 0.5 ) ) ;break ;,83
121,"buggy line: result = ( MagickRealType ) ( ( size_t ) pixel << ( size_t ) ( value + 0.5 ) ) ;break ;cwe id:CWE-190context: static MagickRealType ApplyEvaluateOperator ( RandomInfo * random_info , const Quantum pixel , const MagickEvaluateOperator op , const MagickRealType value ) { MagickRealType result ; result = 0.0 ; switch ( op ) { case UndefinedEvaluateOperator : break ; case AbsEvaluateOperator : { result = ( MagickRealType ) fabs ( ( double ) ( pixel + value ) ) ; break ; } case AddEvaluateOperator : { result = ( MagickRealType ) ( pixel + value ) ; break ; } case AddModulusEvaluateOperator : { result = pixel + value ; result -= ( QuantumRange + 1.0 ) * floor ( ( double ) result / ( QuantumRange + 1.0 ) ) ; break ; } case AndEvaluateOperator : {  result = ( MagickRealType ) ( ( size_t ) pixel & ( size_t ) ( value + 0.5 ) ) ;  break ; } case CosineEvaluateOperator : { result = ( MagickRealType ) ( QuantumRange * ( 0.5 * cos ( ( double ) ( 2.0 * MagickPI * QuantumScale * pixel * value ) ) + 0.5 ) ) ; break ; } case DivideEvaluateOperator : { result = pixel / ( value == 0.0 ? 1.0 : value ) ; break ; } case ExponentialEvaluateOperator : { result = ( MagickRealType ) ( QuantumRange * exp ( ( double ) ( value * QuantumScale * pixel ) ) ) ; break ; } case GaussianNoiseEvaluateOperator : { result = ( MagickRealType ) GenerateDifferentialNoise ( random_info , pixel , GaussianNoise , value ) ; break ; } case ImpulseNoiseEvaluateOperator : { result = ( MagickRealType ) GenerateDifferentialNoise ( random_info , pixel , ImpulseNoise , value ) ; break ; } case LaplacianNoiseEvaluateOperator : { result = ( MagickRealType ) GenerateDifferentialNoise ( random_info , pixel , LaplacianNoise , value ) ; break ; } case LeftShiftEvaluateOperator : {  result = ( MagickRealType ) ( ( size_t ) pixel << ( size_t ) ( value + 0.5 ) ) ;  break ; } case LogEvaluateOperator : { if ( ( QuantumScale * pixel ) >= MagickEpsilon ) result = ( MagickRealType ) ( QuantumRange * log ( ( double ) ( QuantumScale * value * pixel + 1.0 ) ) / log ( ( double ) ( value + 1.0 ) ) ) ; break ; } case MaxEvaluateOperator : { result = ( MagickRealType ) EvaluateMax ( ( double ) pixel , value ) ; break ; } case MeanEvaluateOperator : { result = ( MagickRealType ) ( pixel + value ) ; break ; } case MedianEvaluateOperator : { result = ( MagickRealType ) ( pixel + value ) ; break ; } case MinEvaluateOperator : { result = ( MagickRealType ) MagickMin ( ( double ) pixel , value ) ; break ; } case MultiplicativeNoiseEvaluateOperator : { result = ( MagickRealType ) GenerateDifferentialNoise ( random_info , pixel , MultiplicativeGaussianNoise , value ) ; break ; } case MultiplyEvaluateOperator : { result = ( MagickRealType ) ( value * pixel ) ; break ; } case OrEvaluateOperator : {  result = ( MagickRealType ) ( ( size_t ) pixel | ( size_t ) ( value + 0.5 ) ) ;  break ; } case PoissonNoiseEvaluateOperator : { result = ( MagickRealType ) GenerateDifferentialNoise ( random_info , pixel , PoissonNoise , value ) ; break ; } case PowEvaluateOperator : { result = ( MagickRealType ) ( QuantumRange * pow ( ( double ) ( QuantumScale * pixel ) , ( double ) value ) ) ; break ; } case RightShiftEvaluateOperator : {  result = ( MagickRealType ) ( ( size_t ) pixel >> ( size_t ) ( value + 0.5 ) ) ;  break ; } case RootMeanSquareEvaluateOperator : { result = ( MagickRealType ) ( pixel * pixel + value ) ; break ; } case SetEvaluateOperator : { result = value ; break ; } case SineEvaluateOperator : { result = ( MagickRealType ) ( QuantumRange * ( 0.5 * sin ( ( double ) ( 2.0 * MagickPI * QuantumScale * pixel * value ) ) + 0.5 ) ) ; break ; } case SubtractEvaluateOperator : { result = ( MagickRealType ) ( pixel - value ) ; break ; } case SumEvaluateOperator : { result = ( MagickRealType ) ( pixel + value ) ; break ; } case ThresholdEvaluateOperator : { result = ( MagickRealType ) ( ( ( MagickRealType ) pixel <= value ) ? 0 : QuantumRange ) ; break ; } case ThresholdBlackEvaluateOperator : { result = ( MagickRealType ) ( ( ( MagickRealType ) pixel <= value ) ? 0 : pixel ) ; break ; } case ThresholdWhiteEvaluateOperator : { result = ( MagickRealType ) ( ( ( MagickRealType ) pixel > value ) ? QuantumRange : pixel ) ; break ; } case UniformNoiseEvaluateOperator : { result = ( MagickRealType ) GenerateDifferentialNoise ( random_info , pixel , UniformNoise , value ) ; break ; } case XorEvaluateOperator : {  result = ( MagickRealType ) ( ( size_t ) pixel ^ ( size_t ) ( value + 0.5 ) ) ;  break ; } } return ( result ) ; }",result = ( MagickRealType ) ( ( ssize_t ) pixel << ( size_t ) ( value + 0.5 ) ) ;break ;,83
122,"buggy line: result = ( MagickRealType ) ( ( size_t ) pixel | ( size_t ) ( value + 0.5 ) ) ;break ;cwe id:CWE-190context: static MagickRealType ApplyEvaluateOperator ( RandomInfo * random_info , const Quantum pixel , const MagickEvaluateOperator op , const MagickRealType value ) { MagickRealType result ; result = 0.0 ; switch ( op ) { case UndefinedEvaluateOperator : break ; case AbsEvaluateOperator : { result = ( MagickRealType ) fabs ( ( double ) ( pixel + value ) ) ; break ; } case AddEvaluateOperator : { result = ( MagickRealType ) ( pixel + value ) ; break ; } case AddModulusEvaluateOperator : { result = pixel + value ; result -= ( QuantumRange + 1.0 ) * floor ( ( double ) result / ( QuantumRange + 1.0 ) ) ; break ; } case AndEvaluateOperator : {  result = ( MagickRealType ) ( ( size_t ) pixel & ( size_t ) ( value + 0.5 ) ) ;  break ; } case CosineEvaluateOperator : { result = ( MagickRealType ) ( QuantumRange * ( 0.5 * cos ( ( double ) ( 2.0 * MagickPI * QuantumScale * pixel * value ) ) + 0.5 ) ) ; break ; } case DivideEvaluateOperator : { result = pixel / ( value == 0.0 ? 1.0 : value ) ; break ; } case ExponentialEvaluateOperator : { result = ( MagickRealType ) ( QuantumRange * exp ( ( double ) ( value * QuantumScale * pixel ) ) ) ; break ; } case GaussianNoiseEvaluateOperator : { result = ( MagickRealType ) GenerateDifferentialNoise ( random_info , pixel , GaussianNoise , value ) ; break ; } case ImpulseNoiseEvaluateOperator : { result = ( MagickRealType ) GenerateDifferentialNoise ( random_info , pixel , ImpulseNoise , value ) ; break ; } case LaplacianNoiseEvaluateOperator : { result = ( MagickRealType ) GenerateDifferentialNoise ( random_info , pixel , LaplacianNoise , value ) ; break ; } case LeftShiftEvaluateOperator : {  result = ( MagickRealType ) ( ( size_t ) pixel << ( size_t ) ( value + 0.5 ) ) ;  break ; } case LogEvaluateOperator : { if ( ( QuantumScale * pixel ) >= MagickEpsilon ) result = ( MagickRealType ) ( QuantumRange * log ( ( double ) ( QuantumScale * value * pixel + 1.0 ) ) / log ( ( double ) ( value + 1.0 ) ) ) ; break ; } case MaxEvaluateOperator : { result = ( MagickRealType ) EvaluateMax ( ( double ) pixel , value ) ; break ; } case MeanEvaluateOperator : { result = ( MagickRealType ) ( pixel + value ) ; break ; } case MedianEvaluateOperator : { result = ( MagickRealType ) ( pixel + value ) ; break ; } case MinEvaluateOperator : { result = ( MagickRealType ) MagickMin ( ( double ) pixel , value ) ; break ; } case MultiplicativeNoiseEvaluateOperator : { result = ( MagickRealType ) GenerateDifferentialNoise ( random_info , pixel , MultiplicativeGaussianNoise , value ) ; break ; } case MultiplyEvaluateOperator : { result = ( MagickRealType ) ( value * pixel ) ; break ; } case OrEvaluateOperator : {  result = ( MagickRealType ) ( ( size_t ) pixel | ( size_t ) ( value + 0.5 ) ) ;  break ; } case PoissonNoiseEvaluateOperator : { result = ( MagickRealType ) GenerateDifferentialNoise ( random_info , pixel , PoissonNoise , value ) ; break ; } case PowEvaluateOperator : { result = ( MagickRealType ) ( QuantumRange * pow ( ( double ) ( QuantumScale * pixel ) , ( double ) value ) ) ; break ; } case RightShiftEvaluateOperator : {  result = ( MagickRealType ) ( ( size_t ) pixel >> ( size_t ) ( value + 0.5 ) ) ;  break ; } case RootMeanSquareEvaluateOperator : { result = ( MagickRealType ) ( pixel * pixel + value ) ; break ; } case SetEvaluateOperator : { result = value ; break ; } case SineEvaluateOperator : { result = ( MagickRealType ) ( QuantumRange * ( 0.5 * sin ( ( double ) ( 2.0 * MagickPI * QuantumScale * pixel * value ) ) + 0.5 ) ) ; break ; } case SubtractEvaluateOperator : { result = ( MagickRealType ) ( pixel - value ) ; break ; } case SumEvaluateOperator : { result = ( MagickRealType ) ( pixel + value ) ; break ; } case ThresholdEvaluateOperator : { result = ( MagickRealType ) ( ( ( MagickRealType ) pixel <= value ) ? 0 : QuantumRange ) ; break ; } case ThresholdBlackEvaluateOperator : { result = ( MagickRealType ) ( ( ( MagickRealType ) pixel <= value ) ? 0 : pixel ) ; break ; } case ThresholdWhiteEvaluateOperator : { result = ( MagickRealType ) ( ( ( MagickRealType ) pixel > value ) ? QuantumRange : pixel ) ; break ; } case UniformNoiseEvaluateOperator : { result = ( MagickRealType ) GenerateDifferentialNoise ( random_info , pixel , UniformNoise , value ) ; break ; } case XorEvaluateOperator : {  result = ( MagickRealType ) ( ( size_t ) pixel ^ ( size_t ) ( value + 0.5 ) ) ;  break ; } } return ( result ) ; }",result = ( MagickRealType ) ( ( ssize_t ) pixel | ( size_t ) ( value + 0.5 ) ) ;break ;,83
123,"buggy line: result = ( MagickRealType ) ( ( size_t ) pixel >> ( size_t ) ( value + 0.5 ) ) ;break ;cwe id:CWE-190context: static MagickRealType ApplyEvaluateOperator ( RandomInfo * random_info , const Quantum pixel , const MagickEvaluateOperator op , const MagickRealType value ) { MagickRealType result ; result = 0.0 ; switch ( op ) { case UndefinedEvaluateOperator : break ; case AbsEvaluateOperator : { result = ( MagickRealType ) fabs ( ( double ) ( pixel + value ) ) ; break ; } case AddEvaluateOperator : { result = ( MagickRealType ) ( pixel + value ) ; break ; } case AddModulusEvaluateOperator : { result = pixel + value ; result -= ( QuantumRange + 1.0 ) * floor ( ( double ) result / ( QuantumRange + 1.0 ) ) ; break ; } case AndEvaluateOperator : {  result = ( MagickRealType ) ( ( size_t ) pixel & ( size_t ) ( value + 0.5 ) ) ;  break ; } case CosineEvaluateOperator : { result = ( MagickRealType ) ( QuantumRange * ( 0.5 * cos ( ( double ) ( 2.0 * MagickPI * QuantumScale * pixel * value ) ) + 0.5 ) ) ; break ; } case DivideEvaluateOperator : { result = pixel / ( value == 0.0 ? 1.0 : value ) ; break ; } case ExponentialEvaluateOperator : { result = ( MagickRealType ) ( QuantumRange * exp ( ( double ) ( value * QuantumScale * pixel ) ) ) ; break ; } case GaussianNoiseEvaluateOperator : { result = ( MagickRealType ) GenerateDifferentialNoise ( random_info , pixel , GaussianNoise , value ) ; break ; } case ImpulseNoiseEvaluateOperator : { result = ( MagickRealType ) GenerateDifferentialNoise ( random_info , pixel , ImpulseNoise , value ) ; break ; } case LaplacianNoiseEvaluateOperator : { result = ( MagickRealType ) GenerateDifferentialNoise ( random_info , pixel , LaplacianNoise , value ) ; break ; } case LeftShiftEvaluateOperator : {  result = ( MagickRealType ) ( ( size_t ) pixel << ( size_t ) ( value + 0.5 ) ) ;  break ; } case LogEvaluateOperator : { if ( ( QuantumScale * pixel ) >= MagickEpsilon ) result = ( MagickRealType ) ( QuantumRange * log ( ( double ) ( QuantumScale * value * pixel + 1.0 ) ) / log ( ( double ) ( value + 1.0 ) ) ) ; break ; } case MaxEvaluateOperator : { result = ( MagickRealType ) EvaluateMax ( ( double ) pixel , value ) ; break ; } case MeanEvaluateOperator : { result = ( MagickRealType ) ( pixel + value ) ; break ; } case MedianEvaluateOperator : { result = ( MagickRealType ) ( pixel + value ) ; break ; } case MinEvaluateOperator : { result = ( MagickRealType ) MagickMin ( ( double ) pixel , value ) ; break ; } case MultiplicativeNoiseEvaluateOperator : { result = ( MagickRealType ) GenerateDifferentialNoise ( random_info , pixel , MultiplicativeGaussianNoise , value ) ; break ; } case MultiplyEvaluateOperator : { result = ( MagickRealType ) ( value * pixel ) ; break ; } case OrEvaluateOperator : {  result = ( MagickRealType ) ( ( size_t ) pixel | ( size_t ) ( value + 0.5 ) ) ;  break ; } case PoissonNoiseEvaluateOperator : { result = ( MagickRealType ) GenerateDifferentialNoise ( random_info , pixel , PoissonNoise , value ) ; break ; } case PowEvaluateOperator : { result = ( MagickRealType ) ( QuantumRange * pow ( ( double ) ( QuantumScale * pixel ) , ( double ) value ) ) ; break ; } case RightShiftEvaluateOperator : {  result = ( MagickRealType ) ( ( size_t ) pixel >> ( size_t ) ( value + 0.5 ) ) ;  break ; } case RootMeanSquareEvaluateOperator : { result = ( MagickRealType ) ( pixel * pixel + value ) ; break ; } case SetEvaluateOperator : { result = value ; break ; } case SineEvaluateOperator : { result = ( MagickRealType ) ( QuantumRange * ( 0.5 * sin ( ( double ) ( 2.0 * MagickPI * QuantumScale * pixel * value ) ) + 0.5 ) ) ; break ; } case SubtractEvaluateOperator : { result = ( MagickRealType ) ( pixel - value ) ; break ; } case SumEvaluateOperator : { result = ( MagickRealType ) ( pixel + value ) ; break ; } case ThresholdEvaluateOperator : { result = ( MagickRealType ) ( ( ( MagickRealType ) pixel <= value ) ? 0 : QuantumRange ) ; break ; } case ThresholdBlackEvaluateOperator : { result = ( MagickRealType ) ( ( ( MagickRealType ) pixel <= value ) ? 0 : pixel ) ; break ; } case ThresholdWhiteEvaluateOperator : { result = ( MagickRealType ) ( ( ( MagickRealType ) pixel > value ) ? QuantumRange : pixel ) ; break ; } case UniformNoiseEvaluateOperator : { result = ( MagickRealType ) GenerateDifferentialNoise ( random_info , pixel , UniformNoise , value ) ; break ; } case XorEvaluateOperator : {  result = ( MagickRealType ) ( ( size_t ) pixel ^ ( size_t ) ( value + 0.5 ) ) ;  break ; } } return ( result ) ; }",result = ( MagickRealType ) ( ( ssize_t ) pixel >> ( size_t ) ( value + 0.5 ) ) ;break ;,83
124,"buggy line: result = ( MagickRealType ) ( ( ( MagickRealType ) pixel <= value ) ? 0 : QuantumRange ) ;break ;}case ThresholdBlackEvaluateOperator : {result = ( MagickRealType ) ( ( ( MagickRealType ) pixel <= value ) ? 0 : pixel ) ;case ThresholdWhiteEvaluateOperator : {result = ( MagickRealType ) ( ( ( MagickRealType ) pixel > value ) ? QuantumRange : pixel ) ;break ;}case UniformNoiseEvaluateOperator : {result = ( MagickRealType ) GenerateDifferentialNoise ( random_info , pixel , UniformNoise , value ) ;break ;}case XorEvaluateOperator : {result = ( MagickRealType ) ( ( size_t ) pixel ^ ( size_t ) ( value + 0.5 ) ) ;break ;}cwe id:CWE-190context: static MagickRealType ApplyEvaluateOperator ( RandomInfo * random_info , const Quantum pixel , const MagickEvaluateOperator op , const MagickRealType value ) { MagickRealType result ; result = 0.0 ; switch ( op ) { case UndefinedEvaluateOperator : break ; case AbsEvaluateOperator : { result = ( MagickRealType ) fabs ( ( double ) ( pixel + value ) ) ; break ; } case AddEvaluateOperator : { result = ( MagickRealType ) ( pixel + value ) ; break ; } case AddModulusEvaluateOperator : { result = pixel + value ; result -= ( QuantumRange + 1.0 ) * floor ( ( double ) result / ( QuantumRange + 1.0 ) ) ; break ; } case AndEvaluateOperator : {  result = ( MagickRealType ) ( ( size_t ) pixel & ( size_t ) ( value + 0.5 ) ) ;  break ; } case CosineEvaluateOperator : { result = ( MagickRealType ) ( QuantumRange * ( 0.5 * cos ( ( double ) ( 2.0 * MagickPI * QuantumScale * pixel * value ) ) + 0.5 ) ) ; break ; } case DivideEvaluateOperator : { result = pixel / ( value == 0.0 ? 1.0 : value ) ; break ; } case ExponentialEvaluateOperator : { result = ( MagickRealType ) ( QuantumRange * exp ( ( double ) ( value * QuantumScale * pixel ) ) ) ; break ; } case GaussianNoiseEvaluateOperator : { result = ( MagickRealType ) GenerateDifferentialNoise ( random_info , pixel , GaussianNoise , value ) ; break ; } case ImpulseNoiseEvaluateOperator : { result = ( MagickRealType ) GenerateDifferentialNoise ( random_info , pixel , ImpulseNoise , value ) ; break ; } case LaplacianNoiseEvaluateOperator : { result = ( MagickRealType ) GenerateDifferentialNoise ( random_info , pixel , LaplacianNoise , value ) ; break ; } case LeftShiftEvaluateOperator : {  result = ( MagickRealType ) ( ( size_t ) pixel << ( size_t ) ( value + 0.5 ) ) ;  break ; } case LogEvaluateOperator : { if ( ( QuantumScale * pixel ) >= MagickEpsilon ) result = ( MagickRealType ) ( QuantumRange * log ( ( double ) ( QuantumScale * value * pixel + 1.0 ) ) / log ( ( double ) ( value + 1.0 ) ) ) ; break ; } case MaxEvaluateOperator : { result = ( MagickRealType ) EvaluateMax ( ( double ) pixel , value ) ; break ; } case MeanEvaluateOperator : { result = ( MagickRealType ) ( pixel + value ) ; break ; } case MedianEvaluateOperator : { result = ( MagickRealType ) ( pixel + value ) ; break ; } case MinEvaluateOperator : { result = ( MagickRealType ) MagickMin ( ( double ) pixel , value ) ; break ; } case MultiplicativeNoiseEvaluateOperator : { result = ( MagickRealType ) GenerateDifferentialNoise ( random_info , pixel , MultiplicativeGaussianNoise , value ) ; break ; } case MultiplyEvaluateOperator : { result = ( MagickRealType ) ( value * pixel ) ; break ; } case OrEvaluateOperator : {  result = ( MagickRealType ) ( ( size_t ) pixel | ( size_t ) ( value + 0.5 ) ) ;  break ; } case PoissonNoiseEvaluateOperator : { result = ( MagickRealType ) GenerateDifferentialNoise ( random_info , pixel , PoissonNoise , value ) ; break ; } case PowEvaluateOperator : { result = ( MagickRealType ) ( QuantumRange * pow ( ( double ) ( QuantumScale * pixel ) , ( double ) value ) ) ; break ; } case RightShiftEvaluateOperator : {  result = ( MagickRealType ) ( ( size_t ) pixel >> ( size_t ) ( value + 0.5 ) ) ;  break ; } case RootMeanSquareEvaluateOperator : { result = ( MagickRealType ) ( pixel * pixel + value ) ; break ; } case SetEvaluateOperator : { result = value ; break ; } case SineEvaluateOperator : { result = ( MagickRealType ) ( QuantumRange * ( 0.5 * sin ( ( double ) ( 2.0 * MagickPI * QuantumScale * pixel * value ) ) + 0.5 ) ) ; break ; } case SubtractEvaluateOperator : { result = ( MagickRealType ) ( pixel - value ) ; break ; } case SumEvaluateOperator : { result = ( MagickRealType ) ( pixel + value ) ; break ; } case ThresholdEvaluateOperator : { result = ( MagickRealType ) ( ( ( MagickRealType ) pixel <= value ) ? 0 : QuantumRange ) ; break ; } case ThresholdBlackEvaluateOperator : { result = ( MagickRealType ) ( ( ( MagickRealType ) pixel <= value ) ? 0 : pixel ) ; break ; } case ThresholdWhiteEvaluateOperator : { result = ( MagickRealType ) ( ( ( MagickRealType ) pixel > value ) ? QuantumRange : pixel ) ; break ; } case UniformNoiseEvaluateOperator : { result = ( MagickRealType ) GenerateDifferentialNoise ( random_info , pixel , UniformNoise , value ) ; break ; } case XorEvaluateOperator : {  result = ( MagickRealType ) ( ( size_t ) pixel ^ ( size_t ) ( value + 0.5 ) ) ;  break ; } } return ( result ) ; }",result = ( MagickRealType ) ( ( ssize_t ) pixel ^ ( size_t ) ( value + 0.5 ) ) ;,83
125,"buggy line: btif_config_flush ( ) ;return ret ? BT_STATUS_SUCCESS : BT_STATUS_FAIL ;cwe id:CWE-20context: bt_status_t btif_storage_add_bonded_device ( bt_bdaddr_t * remote_bd_addr , LINK_KEY link_key , uint8_t key_type , uint8_t pin_length ) { bdstr_t bdstr ; bdaddr_to_string ( remote_bd_addr , bdstr , sizeof ( bdstr ) ) ; int ret = btif_config_set_int ( bdstr , ""LinkKeyType"" , ( int ) key_type ) ; ret &= btif_config_set_int ( bdstr , ""PinLength"" , ( int ) pin_length ) ; ret &= btif_config_set_bin ( bdstr , ""LinkKey"" , link_key , sizeof ( LINK_KEY ) ) ;  btif_config_flush ( ) ;  return ret ? BT_STATUS_SUCCESS : BT_STATUS_FAIL ; }","if ( is_restricted_mode ( ) ) {BTIF_TRACE_WARNING ( ""%s:<S2SV_blank>\\\'%s\\\'<S2SV_blank>pairing<S2SV_blank>will<S2SV_blank>be<S2SV_blank>removed<S2SV_blank>if<S2SV_blank>unrestricted"" , __func__ , bdstr ) ;btif_config_set_int ( bdstr , ""Restricted"" , 1 ) ;}btif_config_flush ( ) ;return ret ? BT_STATUS_SUCCESS : BT_STATUS_FAIL ;",84
126,"buggy line: if ( ! ( buf = jas_alloc2 ( bufsize , sizeof ( jpc_fix_t ) ) ) ) {abort ( ) ;cwe id:CWE-119context: void jpc_qmfb_split_colres ( jpc_fix_t * a , int numrows , int numcols , int stride , int parity ) { int bufsize = JPC_CEILDIVPOW2 ( numrows , 1 ) ; jpc_fix_t splitbuf [ QMFB_SPLITBUFSIZE * JPC_QMFB_COLGRPSIZE ] ; jpc_fix_t * buf = splitbuf ; jpc_fix_t * srcptr ; jpc_fix_t * dstptr ; register jpc_fix_t * srcptr2 ; register jpc_fix_t * dstptr2 ; register int n ; register int i ; int m ; int hstartcol ; if ( bufsize > QMFB_SPLITBUFSIZE ) {  if ( ! ( buf = jas_alloc2 ( bufsize , sizeof ( jpc_fix_t ) ) ) ) {  abort ( ) ; } } if ( numrows >= 2 ) { hstartcol = ( numrows + 1 - parity ) >> 1 ; m = numrows - hstartcol ; n = m ; dstptr = buf ; srcptr = & a [ ( 1 - parity ) * stride ] ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < numcols ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += numcols ; srcptr += stride << 1 ; } dstptr = & a [ ( 1 - parity ) * stride ] ; srcptr = & a [ ( 2 - parity ) * stride ] ; n = numrows - m - ( ! parity ) ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < numcols ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += stride ; srcptr += stride << 1 ; } dstptr = & a [ hstartcol * stride ] ; srcptr = buf ; n = m ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < numcols ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += stride ; srcptr += numcols ; } } if ( buf != splitbuf ) { jas_free ( buf ) ; } }","if ( ! ( buf = jas_alloc3 ( bufsize , numcols , sizeof ( jpc_fix_t ) ) ) ) {abort ( ) ;",85
127,"buggy line: vpx_codec_enc_cfg_map_t * map ;if ( ! iface || ! cfg || usage > INT_MAX ) res = VPX_CODEC_INVALID_PARAM ;for ( map = iface -> enc . cfg_maps ;map -> usage >= 0 ;map ++ ) {if ( map -> usage == ( int ) usage ) {cwe id:CWE-119context: vpx_codec_err_t vpx_codec_enc_config_default ( vpx_codec_iface_t * iface , vpx_codec_enc_cfg_t * cfg , unsigned int usage ) { vpx_codec_err_t res ;  vpx_codec_enc_cfg_map_t * map ;  if ( ! iface || ! cfg || usage > INT_MAX ) res = VPX_CODEC_INVALID_PARAM ; else if ( ! ( iface -> caps & VPX_CODEC_CAP_ENCODER ) ) res = VPX_CODEC_INCAPABLE ; else { res = VPX_CODEC_INVALID_PARAM ;  for ( map = iface -> enc . cfg_maps ; map -> usage >= 0 ; map ++ ) {  if ( map -> usage == ( int ) usage ) { * cfg = map -> cfg ; cfg -> g_usage = usage ; res = VPX_CODEC_OK ; break ; } } } return res ; }",vpx_codec_enc_cfg_map_t * map ;int i ;if ( ! iface || ! cfg || usage > INT_MAX ) res = VPX_CODEC_INVALID_PARAM ;for ( i = 0 ;i < iface -> enc . cfg_map_count ;++ i ) {map = iface -> enc . cfg_maps + i ;if ( map -> usage == ( int ) usage ) {,86
128,"buggy line: netdev_dbg ( vif -> dev , ""GSO<S2SV_blank>size<S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>zero.\\\return - EINVAL ;netdev_dbg ( vif -> dev , ""Bad<S2SV_blank>GSO<S2SV_blank>type<S2SV_blank>%d.\\\return - EINVAL ;cwe id:CWE-20context: static int netbk_set_skb_gso ( struct xenvif * vif , struct sk_buff * skb , struct xen_netif_extra_info * gso ) { if ( ! gso -> u . gso . size ) {  netdev_dbg ( vif -> dev , ""GSO<S2SV_blank>size<S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>zero.\\n"" ) ;  return - EINVAL ; } if ( gso -> u . gso . type != XEN_NETIF_GSO_TYPE_TCPV4 ) {  netdev_dbg ( vif -> dev , ""Bad<S2SV_blank>GSO<S2SV_blank>type<S2SV_blank>%d.\\n"" , gso -> u . gso . type ) ;  return - EINVAL ; } skb_shinfo ( skb ) -> gso_size = gso -> u . gso . size ; skb_shinfo ( skb ) -> gso_type = SKB_GSO_TCPV4 ; skb_shinfo ( skb ) -> gso_type |= SKB_GSO_DODGY ; skb_shinfo ( skb ) -> gso_segs = 0 ; return 0 ; }","netdev_err ( vif -> dev , ""GSO<S2SV_blank>size<S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>zero.\\\netbk_fatal_tx_err ( vif ) ;return - EINVAL ;netdev_err ( vif -> dev , ""Bad<S2SV_blank>GSO<S2SV_blank>type<S2SV_blank>%d.\\\netbk_fatal_tx_err ( vif ) ;return - EINVAL ;",87
129,"buggy line: static void show_object ( struct object * object , struct strbuf * path ,   const char * last , void * data )  {if ( bitmap_pos < 0 ) {char * name = path_name ( path , last ) ;bitmap_pos = ext_index_add_object ( object , name ) ;free ( name ) ;}cwe id:CWE-119context:  static void show_object ( struct object * object , struct strbuf * path ,   const char * last , void * data )  { struct bitmap * base = data ; int bitmap_pos ; bitmap_pos = bitmap_position ( object -> oid . hash ) ;  if ( bitmap_pos < 0 ) {  char * name = path_name ( path , last ) ; bitmap_pos = ext_index_add_object ( object , name ) ;  free ( name ) ;  } bitmap_set ( base , bitmap_pos ) ; }","static void show_object ( struct object * object , const char * last , void * data ) {if ( bitmap_pos < 0 ) bitmap_pos = ext_index_add_object ( object , name ) ;free ( name ) ;}",88
130,"buggy line: run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;free ( fname ) ;cwe id:CWE-77context: int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n***<S2SV_blank>pulse<S2SV_blank>DTR<S2SV_blank>***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""***<S2SV_blank>FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n***<S2SV_blank>DTR:<S2SV_blank>%s<S2SV_blank>***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n***<S2SV_blank>baud:<S2SV_blank>%d<S2SV_blank>(%d)<S2SV_blank>***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n***<S2SV_blank>baud:<S2SV_blank>%d<S2SV_blank>***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n***<S2SV_blank>flow:<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n***<S2SV_blank>flow:<S2SV_blank>%s<S2SV_blank>***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n***<S2SV_blank>parity:<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n***<S2SV_blank>parity:<S2SV_blank>%s<S2SV_blank>***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n***<S2SV_blank>databits:<S2SV_blank>%d<S2SV_blank>(%d)<S2SV_blank>***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n***<S2SV_blank>databits:<S2SV_blank>%d<S2SV_blank>***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n***<S2SV_blank>local<S2SV_blank>echo:<S2SV_blank>%s<S2SV_blank>***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n***<S2SV_blank>command<S2SV_blank>disabled<S2SV_blank>***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""***<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>filename<S2SV_blank>***\\r\\n"" ) ; break ; }  run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;  free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n***<S2SV_blank>break<S2SV_blank>sent<S2SV_blank>***\\r\\n"" ) ; break ; default : break ; } return 0 ; }","run_cmd ( tty_fd , xfr_cmd , fname ) ;free ( fname ) ;",89
131,buggy line: static void snd_usb_mixer_free ( struct usb_mixer_interface * mixer )  {kfree ( mixer -> id_elems ) ;cwe id:CWE-416context: static void snd_usb_mixer_free ( struct usb_mixer_interface * mixer )  {  kfree ( mixer -> id_elems ) ; if ( mixer -> urb ) { kfree ( mixer -> urb -> transfer_buffer ) ; usb_free_urb ( mixer -> urb ) ; } usb_free_urb ( mixer -> rc_urb ) ; kfree ( mixer -> rc_setup_packet ) ; kfree ( mixer ) ; },static void snd_usb_mixer_free ( struct usb_mixer_interface * mixer ) {snd_usb_mixer_disconnect ( mixer ) ;kfree ( mixer -> id_elems ) ;,90
132,"buggy line: struct packet_sock * po = pkt_sk ( sk ) ;struct packet_fanout * f , * match ;cwe id:CWE-416context: static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) {  struct packet_sock * po = pkt_sk ( sk ) ;  struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; }  if ( ! po -> running )   return - EINVAL ;  if ( po -> fanout )  return - EALREADY ;  if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) {  po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ;   if ( ! po -> rollover )  return - ENOMEM ;  atomic_long_set ( & po -> rollover -> num , 0 ) ;   atomic_long_set ( & po -> rollover -> num_huge , 0 ) ;   atomic_long_set ( & po -> rollover -> num_failed , 0 ) ;   }  mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out :  mutex_unlock ( & fanout_mutex ) ;   if ( err ) {  kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }","struct packet_rollover * rollover = NULL ;struct packet_sock * po = pkt_sk ( sk ) ;struct packet_fanout * f , * match ;",91
133,"buggy line: if ( ! po -> running )   return - EINVAL ;if ( po -> fanout )  return - EALREADY ;if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) {po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ;if ( ! po -> rollover )  return - ENOMEM ;atomic_long_set ( & po -> rollover -> num , 0 ) ;atomic_long_set ( & po -> rollover -> num_huge , 0 ) ;atomic_long_set ( & po -> rollover -> num_failed , 0 ) ;}mutex_lock ( & fanout_mutex ) ;match = NULL ;list_for_each_entry ( f , & fanout_list , list ) {if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) {match = f ;break ;}}if ( match && match -> flags != flags ) goto out ;if ( ! match ) {match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ;if ( ! match ) goto out ;write_pnet ( & match -> net , sock_net ( sk ) ) ;match -> id = id ;match -> type = type ;match -> flags = flags ;INIT_LIST_HEAD ( & match -> list ) ;spin_lock_init ( & match -> lock ) ;atomic_set ( & match -> sk_ref , 0 ) ;fanout_init_data ( match ) ;match -> prot_hook . type = po -> prot_hook . type ;match -> prot_hook . dev = po -> prot_hook . dev ;match -> prot_hook . func = packet_rcv_fanout ;match -> prot_hook . af_packet_priv = match ;match -> prot_hook . id_match = match_fanout_group ;dev_add_pack ( & match -> prot_hook ) ;list_add ( & match -> list , & fanout_list ) ;}err = - EINVAL ;if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) {err = - ENOSPC ;if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) {__dev_remove_pack ( & po -> prot_hook ) ;po -> fanout = match ;atomic_inc ( & match -> sk_ref ) ;__fanout_link ( sk , po ) ;err = 0 ;}}out :  mutex_unlock ( & fanout_mutex ) ;if ( err ) {kfree ( po -> rollover ) ;po -> rollover = NULL ;cwe id:CWE-416context: static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) {  struct packet_sock * po = pkt_sk ( sk ) ;  struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; }  if ( ! po -> running )   return - EINVAL ;  if ( po -> fanout )  return - EALREADY ;  if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) {  po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ;   if ( ! po -> rollover )  return - ENOMEM ;  atomic_long_set ( & po -> rollover -> num , 0 ) ;   atomic_long_set ( & po -> rollover -> num_huge , 0 ) ;   atomic_long_set ( & po -> rollover -> num_failed , 0 ) ;   }  mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out :  mutex_unlock ( & fanout_mutex ) ;   if ( err ) {  kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }","mutex_lock ( & fanout_mutex ) ;if ( ! po -> running ) goto out ;err = - EALREADY ;if ( po -> fanout ) goto out ;if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) {rollover = kzalloc ( sizeof ( * rollover ) , GFP_KERNEL ) ;if ( ! rollover ) goto out ;atomic_long_set ( & po -> rollover -> num , 0 ) ;atomic_long_set ( & rollover -> num_huge , 0 ) ;atomic_long_set ( & rollover -> num_failed , 0 ) ;mutex_lock ( & fanout_mutex ) ;",91
134,"buggy line: memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ;rcu_read_lock ( ) ;cwe id:CWE-000context: static struct sock * sctp_v6_create_accept_sk ( struct sock * sk , struct sctp_association * asoc , bool kern ) { struct sock * newsk ; struct ipv6_pinfo * newnp , * np = inet6_sk ( sk ) ; struct sctp6_sock * newsctp6sk ; struct ipv6_txoptions * opt ; newsk = sk_alloc ( sock_net ( sk ) , PF_INET6 , GFP_KERNEL , sk -> sk_prot , kern ) ; if ( ! newsk ) goto out ; sock_init_data ( NULL , newsk ) ; sctp_copy_sock ( newsk , sk , asoc ) ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; newsctp6sk = ( struct sctp6_sock * ) newsk ; inet_sk ( newsk ) -> pinet6 = & newsctp6sk -> inet6 ; sctp_sk ( newsk ) -> v4mapped = sctp_sk ( sk ) -> v4mapped ; newnp = inet6_sk ( newsk ) ;  memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ;  rcu_read_lock ( ) ; opt = rcu_dereference ( np -> opt ) ; if ( opt ) opt = ipv6_dup_options ( newsk , opt ) ; RCU_INIT_POINTER ( newnp -> opt , opt ) ; rcu_read_unlock ( ) ; sctp_v6_to_sk_daddr ( & asoc -> peer . primary_addr , newsk ) ; newsk -> sk_v6_rcv_saddr = sk -> sk_v6_rcv_saddr ; sk_refcnt_debug_inc ( newsk ) ; if ( newsk -> sk_prot -> init ( newsk ) ) { sk_common_release ( newsk ) ; newsk = NULL ; } out : return newsk ; }","memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ;newnp -> ipv6_mc_list = NULL ;newnp -> ipv6_ac_list = NULL ;newnp -> ipv6_fl_list = NULL ;rcu_read_lock ( ) ;",92
135,"buggy line: return NULL ;}cwe id:CWE-401context: static struct scatterlist * alloc_sgtable ( int size ) { int alloc_size , nents , i ; struct page * new_page ; struct scatterlist * iter ; struct scatterlist * table ; nents = DIV_ROUND_UP ( size , PAGE_SIZE ) ; table = kcalloc ( nents , sizeof ( * table ) , GFP_KERNEL ) ; if ( ! table ) return NULL ; sg_init_table ( table , nents ) ; iter = table ; for_each_sg ( table , iter , sg_nents ( table ) , i ) { new_page = alloc_page ( GFP_KERNEL ) ; if ( ! new_page ) { iter = table ; for_each_sg ( table , iter , sg_nents ( table ) , i ) { new_page = sg_page ( iter ) ; if ( new_page ) __free_page ( new_page ) ; }  return NULL ;  } alloc_size = min_t ( int , size , PAGE_SIZE ) ; size -= PAGE_SIZE ; sg_set_page ( iter , new_page , alloc_size , 0 ) ; } return table ; }",kfree ( table ) ;return NULL ;},93
136,"buggy line: void show_progress ( int frame_in , int frame_out , uint64_t dx_time ) {fprintf ( stderr , ""%d<S2SV_blank>decoded<S2SV_blank>frames/%d<S2SV_blank>showed<S2SV_blank>frames<S2SV_blank>in<S2SV_blank>%"" PRId64 ""<S2SV_blank>us<S2SV_blank>(%.2f<S2SV_blank>fps)\\\\r"" , frame_in , frame_out , dx_time , ( double ) frame_out * 1000000.0 / ( double ) dx_time ) ;cwe id:CWE-119context:  void show_progress ( int frame_in , int frame_out , uint64_t dx_time ) {  fprintf ( stderr , ""%d<S2SV_blank>decoded<S2SV_blank>frames/%d<S2SV_blank>showed<S2SV_blank>frames<S2SV_blank>in<S2SV_blank>%"" PRId64 ""<S2SV_blank>us<S2SV_blank>(%.2f<S2SV_blank>fps)\\r"" , frame_in , frame_out , dx_time , ( double ) frame_out * 1000000.0 / ( double ) dx_time ) ; }","static void show_progress ( int frame_in , int frame_out , uint64_t dx_time ) {fprintf ( stderr , ""%d<S2SV_blank>decoded<S2SV_blank>frames/%d<S2SV_blank>showed<S2SV_blank>frames<S2SV_blank>in<S2SV_blank>%"" PRId64 ""<S2SV_blank>us<S2SV_blank>(%.2f<S2SV_blank>fps)\\\\r"" , frame_in , frame_out , dx_time , ( double ) frame_out * 1000000.0 / ( double ) dx_time ) ;",94
137,"buggy line: buffer -> buffer_length = fbh -> length ;buffer -> buffer = ( char * ) fbh -> data ;if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) {cwe id:CWE-416context: AV * dbd_st_fetch ( SV * sth , imp_sth_t * imp_sth ) { dTHX ; int num_fields , ChopBlanks , i , rc ; unsigned long * lengths ; AV * av ; int av_length , av_readonly ; MYSQL_ROW cols ; D_imp_dbh_from_sth ; MYSQL * svsock = imp_dbh -> pmysql ; imp_sth_fbh_t * fbh ; D_imp_xxh ( sth ) ; # if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION MYSQL_BIND * buffer ; # endif MYSQL_FIELD * fields ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t-><S2SV_blank>dbd_st_fetch\\n"" ) ; # if MYSQL_ASYNC if ( imp_dbh -> async_query_in_flight ) { if ( mysql_db_async_result ( sth , & imp_sth -> result ) <= 0 ) { return Nullav ; } } # endif # if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION if ( imp_sth -> use_server_side_prepare ) { if ( ! DBIc_ACTIVE ( imp_sth ) ) { do_error ( sth , JW_ERR_SEQUENCE , ""no<S2SV_blank>statement<S2SV_blank>executing\\n"" , NULL ) ; return Nullav ; } if ( imp_sth -> fetch_done ) { do_error ( sth , JW_ERR_SEQUENCE , ""fetch()<S2SV_blank>but<S2SV_blank>fetch<S2SV_blank>already<S2SV_blank>done"" , NULL ) ; return Nullav ; } if ( ! imp_sth -> done_desc ) { if ( ! dbd_describe ( sth , imp_sth ) ) { do_error ( sth , JW_ERR_SEQUENCE , ""Error<S2SV_blank>while<S2SV_blank>describe<S2SV_blank>result<S2SV_blank>set."" , NULL ) ; return Nullav ; } } } # endif ChopBlanks = DBIc_is ( imp_sth , DBIcf_ChopBlanks ) ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tdbd_st_fetch<S2SV_blank>for<S2SV_blank>%p,<S2SV_blank>chopblanks<S2SV_blank>%d\\n"" , sth , ChopBlanks ) ; if ( ! imp_sth -> result ) { do_error ( sth , JW_ERR_SEQUENCE , ""fetch()<S2SV_blank>without<S2SV_blank>execute()"" , NULL ) ; return Nullav ; } imp_dbh -> pmysql -> net . last_errno = 0 ; # if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION if ( imp_sth -> use_server_side_prepare ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tdbd_st_fetch<S2SV_blank>calling<S2SV_blank>mysql_fetch\\n"" ) ; if ( ( rc = mysql_stmt_fetch ( imp_sth -> stmt ) ) ) { if ( rc == 1 ) do_error ( sth , mysql_stmt_errno ( imp_sth -> stmt ) , mysql_stmt_error ( imp_sth -> stmt ) , mysql_stmt_sqlstate ( imp_sth -> stmt ) ) ; # if MYSQL_VERSION_ID >= MYSQL_VERSION_5_0 if ( rc == MYSQL_DATA_TRUNCATED ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tdbd_st_fetch<S2SV_blank>data<S2SV_blank>truncated\\n"" ) ; goto process ; } # endif if ( rc == MYSQL_NO_DATA ) { imp_sth -> row_num = mysql_stmt_affected_rows ( imp_sth -> stmt ) ; imp_sth -> fetch_done = 1 ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tdbd_st_fetch<S2SV_blank>no<S2SV_blank>data\\n"" ) ; } dbd_st_finish ( sth , imp_sth ) ; return Nullav ; } process : imp_sth -> currow ++ ; av = DBIc_DBISTATE ( imp_sth ) -> get_fbav ( imp_sth ) ; num_fields = mysql_stmt_field_count ( imp_sth -> stmt ) ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tdbd_st_fetch<S2SV_blank>called<S2SV_blank>mysql_fetch,<S2SV_blank>rc<S2SV_blank>%d<S2SV_blank>num_fields<S2SV_blank>%d\\n"" , rc , num_fields ) ; for ( buffer = imp_sth -> buffer , fbh = imp_sth -> fbh , i = 0 ; i < num_fields ; i ++ , fbh ++ , buffer ++ ) { SV * sv = AvARRAY ( av ) [ i ] ; STRLEN len ; if ( fbh -> is_null ) ( void ) SvOK_off ( sv ) ; else { if ( fbh -> length > buffer -> buffer_length || fbh -> error ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tRefetch<S2SV_blank>BLOB/TEXT<S2SV_blank>column:<S2SV_blank>%d,<S2SV_blank>length:<S2SV_blank>%lu,<S2SV_blank>error:<S2SV_blank>%d\\n"" , i , fbh -> length , fbh -> error ) ; Renew ( fbh -> data , fbh -> length , char ) ; buffer -> buffer_length = fbh -> length ;  buffer -> buffer = ( char * ) fbh -> data ;  if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) { int j ; int m = MIN ( * buffer -> length , buffer -> buffer_length ) ; char * ptr = ( char * ) buffer -> buffer ; PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tbefore<S2SV_blank>buffer->buffer:<S2SV_blank>"" ) ; for ( j = 0 ; j < m ; j ++ ) { PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""%c"" , * ptr ++ ) ; } PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\n"" ) ; } if ( mysql_stmt_fetch_column ( imp_sth -> stmt , buffer , i , 0 ) ) do_error ( sth , mysql_stmt_errno ( imp_sth -> stmt ) , mysql_stmt_error ( imp_sth -> stmt ) , mysql_stmt_sqlstate ( imp_sth -> stmt ) ) ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) { int j ; int m = MIN ( * buffer -> length , buffer -> buffer_length ) ; char * ptr = ( char * ) buffer -> buffer ; PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tafter<S2SV_blank>buffer->buffer:<S2SV_blank>"" ) ; for ( j = 0 ; j < m ; j ++ ) { PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""%c"" , * ptr ++ ) ; } PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\n"" ) ; } } switch ( buffer -> buffer_type ) { case MYSQL_TYPE_DOUBLE : if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tst_fetch<S2SV_blank>double<S2SV_blank>data<S2SV_blank>%f\\n"" , fbh -> ddata ) ; sv_setnv ( sv , fbh -> ddata ) ; break ; case MYSQL_TYPE_LONG : case MYSQL_TYPE_LONGLONG : if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tst_fetch<S2SV_blank>int<S2SV_blank>data<S2SV_blank>%"" IVdf "",<S2SV_blank>unsigned?<S2SV_blank>%d\\n"" , fbh -> ldata , buffer -> is_unsigned ) ; if ( buffer -> is_unsigned ) sv_setuv ( sv , fbh -> ldata ) ; else sv_setiv ( sv , fbh -> ldata ) ; break ; case MYSQL_TYPE_BIT : sv_setpvn ( sv , fbh -> data , fbh -> length ) ; break ; default : if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tERROR<S2SV_blank>IN<S2SV_blank>st_fetch_string"" ) ; len = fbh -> length ; if ( ChopBlanks ) { if ( fbh -> charsetnr != 63 ) while ( len && fbh -> data [ len - 1 ] == '<S2SV_blank>' ) { -- len ; } } sv_setpvn ( sv , fbh -> data , len ) ; # if defined ( sv_utf8_decode ) && MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION # if MYSQL_VERSION_ID >= FIELD_CHARSETNR_VERSION if ( ( imp_dbh -> enable_utf8 || imp_dbh -> enable_utf8mb4 ) && fbh -> charsetnr != 63 ) # else if ( ( imp_dbh -> enable_utf8 || imp_dbh -> enable_utf8mb4 ) && ! ( fbh -> flags & BINARY_FLAG ) ) # endif sv_utf8_decode ( sv ) ; # endif break ; } } } if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t<-<S2SV_blank>dbd_st_fetch,<S2SV_blank>%d<S2SV_blank>cols\\n"" , num_fields ) ; return av ; } else { # endif imp_sth -> currow ++ ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) { PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\tdbd_st_fetch<S2SV_blank>result<S2SV_blank>set<S2SV_blank>details\\n"" ) ; PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\timp_sth->result=%p\\n"" , imp_sth -> result ) ; PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\tmysql_num_fields=%u\\n"" , mysql_num_fields ( imp_sth -> result ) ) ; PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\tmysql_num_rows=%llu\\n"" , mysql_num_rows ( imp_sth -> result ) ) ; PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\tmysql_affected_rows=%llu\\n"" , mysql_affected_rows ( imp_dbh -> pmysql ) ) ; PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\tdbd_st_fetch<S2SV_blank>for<S2SV_blank>%p,<S2SV_blank>currow=<S2SV_blank>%d\\n"" , sth , imp_sth -> currow ) ; } if ( ! ( cols = mysql_fetch_row ( imp_sth -> result ) ) ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) { PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\tdbd_st_fetch,<S2SV_blank>no<S2SV_blank>more<S2SV_blank>rows<S2SV_blank>to<S2SV_blank>fetch"" ) ; } if ( mysql_errno ( imp_dbh -> pmysql ) ) do_error ( sth , mysql_errno ( imp_dbh -> pmysql ) , mysql_error ( imp_dbh -> pmysql ) , mysql_sqlstate ( imp_dbh -> pmysql ) ) ; # if MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION if ( ! mysql_more_results ( svsock ) ) # endif dbd_st_finish ( sth , imp_sth ) ; return Nullav ; } num_fields = mysql_num_fields ( imp_sth -> result ) ; fields = mysql_fetch_fields ( imp_sth -> result ) ; lengths = mysql_fetch_lengths ( imp_sth -> result ) ; if ( ( av = DBIc_FIELDS_AV ( imp_sth ) ) != Nullav ) { av_length = av_len ( av ) + 1 ; if ( av_length != num_fields ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t<-<S2SV_blank>dbd_st_fetch,<S2SV_blank>size<S2SV_blank>of<S2SV_blank>results<S2SV_blank>array(%d)<S2SV_blank>!=<S2SV_blank>num_fields(%d)\\n"" , av_length , num_fields ) ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t<-<S2SV_blank>dbd_st_fetch,<S2SV_blank>result<S2SV_blank>fields(%d)\\n"" , DBIc_NUM_FIELDS ( imp_sth ) ) ; av_readonly = SvREADONLY ( av ) ; if ( av_readonly ) SvREADONLY_off ( av ) ; while ( av_length < num_fields ) { av_store ( av , av_length ++ , newSV ( 0 ) ) ; } while ( av_length > num_fields ) { SvREFCNT_dec ( av_pop ( av ) ) ; av_length -- ; } if ( av_readonly ) SvREADONLY_on ( av ) ; } } av = DBIc_DBISTATE ( imp_sth ) -> get_fbav ( imp_sth ) ; for ( i = 0 ; i < num_fields ; ++ i ) { char * col = cols [ i ] ; SV * sv = AvARRAY ( av ) [ i ] ; if ( col ) { STRLEN len = lengths [ i ] ; if ( ChopBlanks ) { while ( len && col [ len - 1 ] == '<S2SV_blank>' ) { -- len ; } } sv_setpvn ( sv , col , len ) ; switch ( mysql_to_perl_type ( fields [ i ] . type ) ) { case MYSQL_TYPE_DOUBLE : ( void ) SvNV ( sv ) ; SvNOK_only ( sv ) ; break ; case MYSQL_TYPE_LONG : case MYSQL_TYPE_LONGLONG : if ( fields [ i ] . flags & UNSIGNED_FLAG ) { ( void ) SvUV ( sv ) ; SvIOK_only_UV ( sv ) ; } else { ( void ) SvIV ( sv ) ; SvIOK_only ( sv ) ; } break ; # if MYSQL_VERSION_ID > NEW_DATATYPE_VERSION case MYSQL_TYPE_BIT : break ; # endif default : # if defined ( sv_utf8_decode ) && MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION if ( ( imp_dbh -> enable_utf8 || imp_dbh -> enable_utf8mb4 ) && fields [ i ] . charsetnr != 63 ) sv_utf8_decode ( sv ) ; # endif break ; } } else ( void ) SvOK_off ( sv ) ; } if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t<-<S2SV_blank>dbd_st_fetch,<S2SV_blank>%d<S2SV_blank>cols\\n"" , num_fields ) ; return av ; # if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION } # endif }",buffer -> buffer = ( char * ) fbh -> data ;imp_sth -> stmt -> bind [ i ] . buffer_length = fbh -> length ;imp_sth -> stmt -> bind [ i ] . buffer_length = fbh -> length ;buffer -> buffer = ( char * ) fbh -> data ;if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) {,95
138,"buggy line: enc28j60SetBit ( interface , ENC28J60_REG_ECON1 , ECON1_TXRST ) ;enc28j60ClearBit ( interface , ENC28J60_REG_ECON1 , ECON1_TXRST ) ;enc28j60ClearBit ( interface , ENC28J60_REG_EIR , EIR_TXIF | EIR_TXERIF ) ;enc28j60WriteReg ( interface , ENC28J60_REG_ETXSTL , LSB ( ENC28J60_TX_BUFFER_START ) ) ;enc28j60WriteReg ( interface , ENC28J60_REG_ETXSTH , MSB ( ENC28J60_TX_BUFFER_START ) ) ;enc28j60WriteReg ( interface , ENC28J60_REG_EWRPTL , LSB ( ENC28J60_TX_BUFFER_START ) ) ;enc28j60WriteReg ( interface , ENC28J60_REG_EWRPTH , MSB ( ENC28J60_TX_BUFFER_START ) ) ;enc28j60WriteBuffer ( interface , buffer , offset ) ;enc28j60WriteReg ( interface , ENC28J60_REG_ETXNDL , LSB ( ENC28J60_TX_BUFFER_START + length ) ) ;enc28j60WriteReg ( interface , ENC28J60_REG_ETXNDH , MSB ( ENC28J60_TX_BUFFER_START + length ) ) ;enc28j60SetBit ( interface , ENC28J60_REG_ECON1 , ECON1_TXRTS ) ;return NO_ERROR ;cwe id:CWE-20context: error_t enc28j60SendPacket ( NetInterface * interface , const NetBuffer * buffer , size_t offset , NetTxAncillary * ancillary ) { size_t length ; length = netBufferGetLength ( buffer ) - offset ; if ( length > 1536 ) { osSetEvent ( & interface -> nicTxEvent ) ; return ERROR_INVALID_LENGTH ; } if ( ! interface -> linkState ) { osSetEvent ( & interface -> nicTxEvent ) ; return NO_ERROR ; }  enc28j60SetBit ( interface , ENC28J60_REG_ECON1 , ECON1_TXRST ) ;   enc28j60ClearBit ( interface , ENC28J60_REG_ECON1 , ECON1_TXRST ) ;   enc28j60ClearBit ( interface , ENC28J60_REG_EIR , EIR_TXIF | EIR_TXERIF ) ;  enc28j60WriteReg ( interface , ENC28J60_REG_ETXSTL , LSB ( ENC28J60_TX_BUFFER_START ) ) ;  enc28j60WriteReg ( interface , ENC28J60_REG_ETXSTH , MSB ( ENC28J60_TX_BUFFER_START ) ) ;   enc28j60WriteReg ( interface , ENC28J60_REG_EWRPTL , LSB ( ENC28J60_TX_BUFFER_START ) ) ;   enc28j60WriteReg ( interface , ENC28J60_REG_EWRPTH , MSB ( ENC28J60_TX_BUFFER_START ) ) ;  enc28j60WriteBuffer ( interface , buffer , offset ) ;  enc28j60WriteReg ( interface , ENC28J60_REG_ETXNDL , LSB ( ENC28J60_TX_BUFFER_START + length ) ) ;   enc28j60WriteReg ( interface , ENC28J60_REG_ETXNDH , MSB ( ENC28J60_TX_BUFFER_START + length ) ) ;   enc28j60SetBit ( interface , ENC28J60_REG_ECON1 , ECON1_TXRTS ) ;  return NO_ERROR ; }","enc28j60SetBit ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_TXRST ) ;enc28j60ClearBit ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_TXRST ) ;enc28j60ClearBit ( interface , ENC28J60_EIR , ENC28J60_EIR_TXIF | ENC28J60_EIR_TXERIF ) ;enc28j60WriteReg ( interface , ENC28J60_ETXSTL , LSB ( ENC28J60_TX_BUFFER_START ) ) ;enc28j60WriteReg ( interface , ENC28J60_ETXSTH , MSB ( ENC28J60_TX_BUFFER_START ) ) ;enc28j60WriteReg ( interface , ENC28J60_EWRPTL , LSB ( ENC28J60_TX_BUFFER_START ) ) ;enc28j60WriteReg ( interface , ENC28J60_EWRPTH , MSB ( ENC28J60_TX_BUFFER_START ) ) ;enc28j60WriteBuffer ( interface , ENC28J60_ETXNDL , LSB ( ENC28J60_TX_BUFFER_START + length ) ) ;enc28j60WriteReg ( interface , ENC28J60_REG_ETXNDH , MSB ( ENC28J60_TX_BUFFER_START + length ) ) ;enc28j60SetBit ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_TXRTS ) ;return NO_ERROR ;",96
139,"buggy line: cwe id:CWE-125context: PyObject * ast2obj_arg ( void * _o ) { arg_ty o = ( arg_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { Py_RETURN_NONE ; } result = PyType_GenericNew ( arg_type , NULL , NULL ) ; if ( ! result ) return NULL ; value = ast2obj_identifier ( o -> arg ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_arg , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> annotation ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_annotation , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ;  value = ast2obj_int ( o -> lineno ) ;  if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_lineno , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> col_offset ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_col_offset , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> end_lineno ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_end_lineno , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> end_col_offset ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_end_col_offset , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }","value = ast2obj_string ( o -> type_comment ) ;if ( ! value ) goto failed ;if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ;Py_DECREF ( value ) ;",97
140,"buggy line: value = ast2obj_int ( o -> lineno ) ;if ( ! value ) goto failed ;cwe id:CWE-125context: PyObject * ast2obj_arg ( void * _o ) { arg_ty o = ( arg_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { Py_RETURN_NONE ; } result = PyType_GenericNew ( arg_type , NULL , NULL ) ; if ( ! result ) return NULL ; value = ast2obj_identifier ( o -> arg ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_arg , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> annotation ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_annotation , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ;  value = ast2obj_int ( o -> lineno ) ;  if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_lineno , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> col_offset ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_col_offset , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> end_lineno ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_end_lineno , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> end_col_offset ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_end_col_offset , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }",value = ast2obj_int ( o -> lineno ) ;if ( ! value ) goto failed ;,97
141,"buggy line: if ( page && ( access ( page , R_OK ) == 0 ) )  {file_write ( page , wikitext ) ;http_response_printf ( res , ""success"" ) ;return ;}if ( page && ( unlink ( page ) > 0 ) )  {cwe id:CWE-22context: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ;  if ( page && ( access ( page , R_OK ) == 0 ) )  { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) {  file_write ( page , wikitext ) ;  http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ;  return ;  } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ;  if ( page && ( unlink ( page ) > 0 ) )  { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ;  if ( page && ( access ( page , R_OK ) == 0 ) )  { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d<S2SV_blank>%H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }","if ( page && page_name_is_good ( page ) && ( access ( page , R_OK ) == 0 ) ) {if ( page_name_is_good ( page ) ) {}file_write ( page , wikitext ) ;http_response_printf ( res , ""success"" ) ;return ;}if ( page && page_name_is_good ( page ) && ( unlink ( page ) > 0 ) ) {",98
142,"buggy line: if ( page == NULL ) page = http_request_get_query_string ( req ) ;if ( page && ( access ( page , R_OK ) == 0 ) )  {cwe id:CWE-22context: void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ;  if ( page && ( access ( page , R_OK ) == 0 ) )  { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) {  file_write ( page , wikitext ) ;  http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ;  return ;  } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ;  if ( page && ( unlink ( page ) > 0 ) )  { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ;  if ( page && ( access ( page , R_OK ) == 0 ) )  { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d<S2SV_blank>%H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }","if ( page && page_name_is_good ( page ) == NULL ) page = http_request_get_query_string ( req ) ;if ( page && ( access ( page , R_OK ) == 0 ) ) {",98
143,"buggy line: if ( flags == EXT4_GET_BLOCKS_PRE_IO ) {ret = ext4_split_unwritten_extents ( handle , inode , path , iblock , max_blocks , flags ) ;else  ext4_set_inode_state ( inode , EXT4_STATE_DIO_UNWRITTEN ) ;goto out ;if ( flags == EXT4_GET_BLOCKS_CONVERT ) {ret = ext4_convert_unwritten_extents_endio ( handle , inode , path ) ;cwe id:CWE-000context: static int ext4_ext_handle_uninitialized_extents ( handle_t * handle , struct inode * inode , ext4_lblk_t iblock , unsigned int max_blocks , struct ext4_ext_path * path , int flags , unsigned int allocated , struct buffer_head * bh_result , ext4_fsblk_t newblock ) { int ret = 0 ; int err = 0 ; ext4_io_end_t * io = EXT4_I ( inode ) -> cur_aio_dio ; ext_debug ( ""ext4_ext_handle_uninitialized_extents:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>logical"" ""block<S2SV_blank>%llu,<S2SV_blank>max_blocks<S2SV_blank>%u,<S2SV_blank>flags<S2SV_blank>%d,<S2SV_blank>allocated<S2SV_blank>%u"" , inode -> i_ino , ( unsigned long long ) iblock , max_blocks , flags , allocated ) ; ext4_ext_show_leaf ( inode , path ) ;  if ( flags == EXT4_GET_BLOCKS_PRE_IO ) {  ret = ext4_split_unwritten_extents ( handle , inode , path , iblock , max_blocks , flags ) ; if ( io ) io -> flag = EXT4_IO_UNWRITTEN ; else  ext4_set_inode_state ( inode , EXT4_STATE_DIO_UNWRITTEN ) ;  goto out ; }  if ( flags == EXT4_GET_BLOCKS_CONVERT ) {  ret = ext4_convert_unwritten_extents_endio ( handle , inode , path ) ; if ( ret >= 0 ) ext4_update_inode_fsync_trans ( handle , inode , 1 ) ; goto out2 ; } if ( flags & EXT4_GET_BLOCKS_UNINIT_EXT ) goto map_out ; if ( ( flags & EXT4_GET_BLOCKS_CREATE ) == 0 ) { set_buffer_unwritten ( bh_result ) ; goto out1 ; } ret = ext4_ext_convert_to_initialized ( handle , inode , path , iblock , max_blocks ) ; if ( ret >= 0 ) ext4_update_inode_fsync_trans ( handle , inode , 1 ) ; out : if ( ret <= 0 ) { err = ret ; goto out2 ; } else allocated = ret ; set_buffer_new ( bh_result ) ; if ( allocated > max_blocks ) { unmap_underlying_metadata_blocks ( inode -> i_sb -> s_bdev , newblock + max_blocks , allocated - max_blocks ) ; allocated = max_blocks ; } if ( flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE ) ext4_da_update_reserve_space ( inode , allocated , 0 ) ; map_out : set_buffer_mapped ( bh_result ) ; out1 : if ( allocated > max_blocks ) allocated = max_blocks ; ext4_ext_show_leaf ( inode , path ) ; bh_result -> b_bdev = inode -> i_sb -> s_bdev ; bh_result -> b_blocknr = newblock ; out2 : if ( path ) { ext4_ext_drop_refs ( path ) ; kfree ( path ) ; } return err ? err : allocated ; }","if ( ( flags & EXT4_GET_BLOCKS_PRE_IO ) ) {ret = ext4_split_unwritten_extents ( handle , inode , path , iblock , max_blocks , flags ) ;else ext4_set_inode_state ( inode , EXT4_STATE_DIO_UNWRITTEN ) ;if ( ext4_should_dioread_nolock ( inode ) ) set_buffer_uninit ( bh_result ) ;goto out ;if ( ( flags & EXT4_GET_BLOCKS_CONVERT ) ) {ret = ext4_convert_unwritten_extents_endio ( handle , inode , path ) ;",99
144,"buggy line: ND_PRINT ( ( ndo , ""\\\switch ( opt ) {case IPCPOPT_2ADDR : if ( len != 10 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>10)"" ) ) ;return len ;}ND_TCHECK2 ( * ( p + 6 ) , 4 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>src<S2SV_blank>%s,<S2SV_blank>dst<S2SV_blank>%s"" , ipaddr_string ( ndo , p + 2 ) , ipaddr_string ( ndo , p + 6 ) ) ) ;break ;case IPCPOPT_IPCOMP : if ( len < 4 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>4)"" ) ) ;return 0 ;}ND_TCHECK2 ( * ( p + 2 ) , 2 ) ;compproto = EXTRACT_16BITS ( p + 2 ) ;cwe id:CWE-125context: static int print_ipcp_config_options ( netdissect_options * ndo , const u_char * p , int length ) { int len , opt ; u_int compproto , ipcomp_subopttotallen , ipcomp_subopt , ipcomp_suboptlen ; if ( length < 2 ) return 0 ; ND_TCHECK2 ( * p , 2 ) ; len = p [ 1 ] ; opt = p [ 0 ] ; if ( length < len ) return 0 ; if ( len < 2 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>2)"" , tok2str ( ipcpopt_values , ""unknown"" , opt ) , opt , len ) ) ; return 0 ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( ipcpopt_values , ""unknown"" , opt ) , opt , len ) ) ; switch ( opt ) { case IPCPOPT_2ADDR : if ( len != 10 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>10)"" ) ) ; return len ; } ND_TCHECK2 ( * ( p + 6 ) , 4 ) ; ND_PRINT ( ( ndo , "":<S2SV_blank>src<S2SV_blank>%s,<S2SV_blank>dst<S2SV_blank>%s"" , ipaddr_string ( ndo , p + 2 ) , ipaddr_string ( ndo , p + 6 ) ) ) ; break ; case IPCPOPT_IPCOMP : if ( len < 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>4)"" ) ) ; return 0 ; }  ND_TCHECK2 ( * ( p + 2 ) , 2 ) ;  compproto = EXTRACT_16BITS ( p + 2 ) ; ND_PRINT ( ( ndo , "":<S2SV_blank>%s<S2SV_blank>(0x%02x):"" , tok2str ( ipcpopt_compproto_values , ""Unknown"" , compproto ) , compproto ) ) ; switch ( compproto ) { case PPP_VJC : break ; case IPCPOPT_IPCOMP_HDRCOMP : if ( len < IPCPOPT_IPCOMP_MINLEN ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>%u)"" , IPCPOPT_IPCOMP_MINLEN ) ) ; return 0 ; } ND_TCHECK2 ( * ( p + 2 ) , IPCPOPT_IPCOMP_MINLEN ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>TCP<S2SV_blank>Space<S2SV_blank>%u,<S2SV_blank>non-TCP<S2SV_blank>Space<S2SV_blank>%u"" "",<S2SV_blank>maxPeriod<S2SV_blank>%u,<S2SV_blank>maxTime<S2SV_blank>%u,<S2SV_blank>maxHdr<S2SV_blank>%u"" , EXTRACT_16BITS ( p + 4 ) , EXTRACT_16BITS ( p + 6 ) , EXTRACT_16BITS ( p + 8 ) , EXTRACT_16BITS ( p + 10 ) , EXTRACT_16BITS ( p + 12 ) ) ) ; if ( len > IPCPOPT_IPCOMP_MINLEN ) { ipcomp_subopttotallen = len - IPCPOPT_IPCOMP_MINLEN ; p += IPCPOPT_IPCOMP_MINLEN ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Suboptions,<S2SV_blank>length<S2SV_blank>%u"" , ipcomp_subopttotallen ) ) ; while ( ipcomp_subopttotallen >= 2 ) { ND_TCHECK2 ( * p , 2 ) ; ipcomp_subopt = * p ; ipcomp_suboptlen = * ( p + 1 ) ; if ( ipcomp_subopt == 0 || ipcomp_suboptlen == 0 ) break ; ND_PRINT ( ( ndo , ""\\n\\t\\t%s<S2SV_blank>Suboption<S2SV_blank>#%u,<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( ipcpopt_compproto_subopt_values , ""Unknown"" , ipcomp_subopt ) , ipcomp_subopt , ipcomp_suboptlen ) ) ; ipcomp_subopttotallen -= ipcomp_suboptlen ; p += ipcomp_suboptlen ; } } break ; default : break ; } break ; case IPCPOPT_ADDR : case IPCPOPT_MOBILE4 : case IPCPOPT_PRIDNS : case IPCPOPT_PRINBNS : case IPCPOPT_SECDNS : case IPCPOPT_SECNBNS : if ( len != 6 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>6)"" ) ) ; return 0 ; } ND_TCHECK2 ( * ( p + 2 ) , 4 ) ; ND_PRINT ( ( ndo , "":<S2SV_blank>%s"" , ipaddr_string ( ndo , p + 2 ) ) ) ; break ; default : if ( ndo -> ndo_vflag < 2 ) print_unknown_data ( ndo , & p [ 2 ] , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len - 2 ) ; break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , & p [ 2 ] , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len - 2 ) ; return len ; trunc : ND_PRINT ( ( ndo , ""[|ipcp]"" ) ) ; return 0 ; }",ND_TCHECK_16BITS ( p + 2 ) ;compproto = EXTRACT_16BITS ( p + 2 ) ;,100
145,"buggy line: cwe id:CWE-264context: static int cg_getattr ( const char * path , struct stat * sb ) { struct timespec now ; struct fuse_context * fc = fuse_get_context ( ) ; char * cgdir = NULL ; char * fpath = NULL , * path1 , * path2 ; struct cgfs_files * k = NULL ; const char * cgroup ; const char * controller = NULL ; int ret = - ENOENT ; if ( ! fc ) return - EIO ; memset ( sb , 0 , sizeof ( struct stat ) ) ; if ( clock_gettime ( CLOCK_REALTIME , & now ) < 0 ) return - EINVAL ; sb -> st_uid = sb -> st_gid = 0 ; sb -> st_atim = sb -> st_mtim = sb -> st_ctim = now ; sb -> st_size = 0 ; if ( strcmp ( path , ""/cgroup"" ) == 0 ) { sb -> st_mode = S_IFDIR | 00755 ; sb -> st_nlink = 2 ; return 0 ; } controller = pick_controller_from_path ( fc , path ) ; if ( ! controller ) return - EIO ; cgroup = find_cgroup_in_path ( path ) ; if ( ! cgroup ) { sb -> st_mode = S_IFDIR | 00755 ; sb -> st_nlink = 2 ; return 0 ; } get_cgdir_and_path ( cgroup , & cgdir , & fpath ) ; if ( ! fpath ) { path1 = ""/"" ; path2 = cgdir ; } else { path1 = cgdir ; path2 = fpath ; } if ( is_child_cgroup ( controller , path1 , path2 ) ) {  if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) {  sb -> st_mode = S_IFDIR | 00555 ; sb -> st_nlink = 2 ; ret = 0 ; goto out ; } if ( ! fc_may_access ( fc , controller , cgroup , NULL , O_RDONLY ) ) { ret = - EACCES ; goto out ; } sb -> st_mode = S_IFDIR | 00755 ; k = cgfs_get_key ( controller , cgroup , ""tasks"" ) ; if ( ! k ) { sb -> st_uid = sb -> st_gid = 0 ; } else { sb -> st_uid = k -> uid ; sb -> st_gid = k -> gid ; } free_key ( k ) ; sb -> st_nlink = 2 ; ret = 0 ; goto out ; } if ( ( k = cgfs_get_key ( controller , path1 , path2 ) ) != NULL ) { sb -> st_mode = S_IFREG | k -> mode ; sb -> st_nlink = 1 ; sb -> st_uid = k -> uid ; sb -> st_gid = k -> gid ; sb -> st_size = 0 ; free_key ( k ) ; if ( ! caller_is_in_ancestor ( fc -> pid , controller , path1 , NULL ) ) { ret = - ENOENT ; goto out ; } if ( ! fc_may_access ( fc , controller , path1 , path2 , O_RDONLY ) ) { ret = - EACCES ; goto out ; } ret = 0 ; } out : free ( cgdir ) ; return ret ; }","if ( ! caller_may_see_dir ( fc -> pid , controller , cgroup ) ) {ret = - ENOENT ;goto out ;}",101
146,"buggy line: if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) {sb -> st_mode = S_IFDIR | 00555 ;cwe id:CWE-264context: static int cg_getattr ( const char * path , struct stat * sb ) { struct timespec now ; struct fuse_context * fc = fuse_get_context ( ) ; char * cgdir = NULL ; char * fpath = NULL , * path1 , * path2 ; struct cgfs_files * k = NULL ; const char * cgroup ; const char * controller = NULL ; int ret = - ENOENT ; if ( ! fc ) return - EIO ; memset ( sb , 0 , sizeof ( struct stat ) ) ; if ( clock_gettime ( CLOCK_REALTIME , & now ) < 0 ) return - EINVAL ; sb -> st_uid = sb -> st_gid = 0 ; sb -> st_atim = sb -> st_mtim = sb -> st_ctim = now ; sb -> st_size = 0 ; if ( strcmp ( path , ""/cgroup"" ) == 0 ) { sb -> st_mode = S_IFDIR | 00755 ; sb -> st_nlink = 2 ; return 0 ; } controller = pick_controller_from_path ( fc , path ) ; if ( ! controller ) return - EIO ; cgroup = find_cgroup_in_path ( path ) ; if ( ! cgroup ) { sb -> st_mode = S_IFDIR | 00755 ; sb -> st_nlink = 2 ; return 0 ; } get_cgdir_and_path ( cgroup , & cgdir , & fpath ) ; if ( ! fpath ) { path1 = ""/"" ; path2 = cgdir ; } else { path1 = cgdir ; path2 = fpath ; } if ( is_child_cgroup ( controller , path1 , path2 ) ) {  if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) {  sb -> st_mode = S_IFDIR | 00555 ; sb -> st_nlink = 2 ; ret = 0 ; goto out ; } if ( ! fc_may_access ( fc , controller , cgroup , NULL , O_RDONLY ) ) { ret = - EACCES ; goto out ; } sb -> st_mode = S_IFDIR | 00755 ; k = cgfs_get_key ( controller , cgroup , ""tasks"" ) ; if ( ! k ) { sb -> st_uid = sb -> st_gid = 0 ; } else { sb -> st_uid = k -> uid ; sb -> st_gid = k -> gid ; } free_key ( k ) ; sb -> st_nlink = 2 ; ret = 0 ; goto out ; } if ( ( k = cgfs_get_key ( controller , path1 , path2 ) ) != NULL ) { sb -> st_mode = S_IFREG | k -> mode ; sb -> st_nlink = 1 ; sb -> st_uid = k -> uid ; sb -> st_gid = k -> gid ; sb -> st_size = 0 ; free_key ( k ) ; if ( ! caller_is_in_ancestor ( fc -> pid , controller , path1 , NULL ) ) { ret = - ENOENT ; goto out ; } if ( ! fc_may_access ( fc , controller , path1 , path2 , O_RDONLY ) ) { ret = - EACCES ; goto out ; } ret = 0 ; } out : free ( cgdir ) ; return ret ; }","if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) {sb -> st_mode = S_IFDIR | 00555 ;",101
147,"buggy line: void vp8_de_noise ( VP8_COMMON * cm , YV12_BUFFER_CONFIG * source , YV12_BUFFER_CONFIG * post , int q , int low_var_thresh ,  int flag )  {int mb_rows = source -> y_width >> 4 ;int mb_cols = source -> y_height >> 4 ;unsigned char * limits = cm -> pp_limits_buffer ;int mbr , mbc ;( void ) post ;vpx_memset ( limits , ( unsigned char ) ppl , 16 * mb_cols ) ;for ( mbr = 0 ;vp8_post_proc_down_and_across_mb_row (  source -> u_buffer + 8 * mbr * source -> uv_stride , source -> u_buffer + 8 * mbr * source -> uv_stride , source -> uv_stride , source -> uv_stride , source -> uv_width , limits , 8 ) ;vp8_post_proc_down_and_across_mb_row ( source -> v_buffer + 8 * mbr * source -> uv_stride , source -> v_buffer + 8 * mbr * source -> uv_stride ,  source -> uv_stride , source -> uv_stride , source -> uv_width , limits , 8 ) ;}cwe id:CWE-119context: void vp8_de_noise ( VP8_COMMON * cm , YV12_BUFFER_CONFIG * source , YV12_BUFFER_CONFIG * post , int q , int low_var_thresh ,  int flag )  { double level = 6.0e-05 * q * q * q - .0067 * q * q + .306 * q + .0065 ; int ppl = ( int ) ( level + .5 ) ;  int mb_rows = source -> y_width >> 4 ;   int mb_cols = source -> y_height >> 4 ;  unsigned char * limits = cm -> pp_limits_buffer ; ;  int mbr , mbc ;  ( void ) post ; ( void ) low_var_thresh ; ( void ) flag ;  vpx_memset ( limits , ( unsigned char ) ppl , 16 * mb_cols ) ;  for ( mbr = 0 ; mbr < mb_rows ; mbr ++ ) { vp8_post_proc_down_and_across_mb_row ( source -> y_buffer + 16 * mbr * source -> y_stride , source -> y_buffer + 16 * mbr * source -> y_stride , source -> y_stride , source -> y_stride , source -> y_width , limits , 16 ) ;  vp8_post_proc_down_and_across_mb_row (  source -> u_buffer + 8 * mbr * source -> uv_stride , source -> u_buffer + 8 * mbr * source -> uv_stride , source -> uv_stride , source -> uv_stride , source -> uv_width , limits , 8 ) ; vp8_post_proc_down_and_across_mb_row ( source -> v_buffer + 8 * mbr * source -> uv_stride , source -> v_buffer + 8 * mbr * source -> uv_stride ,  source -> uv_stride , source -> uv_stride , source -> uv_width , limits , 8 ) ;  } }","void vp8_de_noise ( VP8_COMMON * cm , YV12_BUFFER_CONFIG * source , YV12_BUFFER_CONFIG * post , int q , int low_var_thresh , int flag , int uvfilter ) {int mbr ;int mb_rows = cm -> mb_rows ;int mb_cols = source -> y_height >> 4 ;unsigned char * limits = cm -> pp_limits_buffer ;( void ) post ;memset ( limits , ( unsigned char ) ppl , 16 * mb_cols ) ;for ( mbr = 0 ;if ( uvfilter == 1 ) {vp8_post_proc_down_and_across_mb_row ( source -> u_buffer + 8 * mbr * source -> uv_stride , source -> u_buffer + 8 * mbr * source -> uv_stride , source -> uv_stride , source -> uv_stride , source -> uv_width , limits , 8 ) ;}}",102
148,"buggy line: ret = copy_to_user ( param , ptr , sizeof ( * ptr ) ) ;if ( ret ) return - EFAULT ;cwe id:CWE-264context: static int raw_cmd_copyout ( int cmd , void __user * param , struct floppy_raw_cmd * ptr ) { int ret ; while ( ptr ) {  ret = copy_to_user ( param , ptr , sizeof ( * ptr ) ) ;  if ( ret ) return - EFAULT ; param += sizeof ( struct floppy_raw_cmd ) ; if ( ( ptr -> flags & FD_RAW_READ ) && ptr -> buffer_length ) { if ( ptr -> length >= 0 && ptr -> length <= ptr -> buffer_length ) { long length = ptr -> buffer_length - ptr -> length ; ret = fd_copyout ( ptr -> data , ptr -> kernel_data , length ) ; if ( ret ) return ret ; } } ptr = ptr -> next ; } return 0 ; }","struct floppy_raw_cmd cmd = * ptr ;cmd . next = NULL ;cmd . kernel_data = NULL ;ret = copy_to_user ( param , & cmd , sizeof ( * ptr ) ) ;if ( ret ) return - EFAULT ;",103
149,"buggy line: skip :  if ( ( new -> euid != old -> uid ||  new -> egid != old -> gid || ! cap_issubset ( new -> cap_permitted , old -> cap_permitted ) ) && bprm -> unsafe & ~ LSM_UNSAFE_PTRACE_CAP ) {cwe id:CWE-264context: int cap_bprm_set_creds ( struct linux_binprm * bprm ) { const struct cred * old = current_cred ( ) ; struct cred * new = bprm -> cred ; bool effective , has_cap = false ; int ret ; effective = false ; ret = get_file_caps ( bprm , & effective , & has_cap ) ; if ( ret < 0 ) return ret ; if ( ! issecure ( SECURE_NOROOT ) ) { if ( has_cap && new -> uid != 0 && new -> euid == 0 ) { warn_setuid_and_fcaps_mixed ( bprm -> filename ) ; goto skip ; } if ( new -> euid == 0 || new -> uid == 0 ) { new -> cap_permitted = cap_combine ( old -> cap_bset , old -> cap_inheritable ) ; } if ( new -> euid == 0 ) effective = true ; } skip :  if ( ( new -> euid != old -> uid ||  new -> egid != old -> gid || ! cap_issubset ( new -> cap_permitted , old -> cap_permitted ) ) && bprm -> unsafe & ~ LSM_UNSAFE_PTRACE_CAP ) { if ( ! capable ( CAP_SETUID ) ) { new -> euid = new -> uid ; new -> egid = new -> gid ; } new -> cap_permitted = cap_intersect ( new -> cap_permitted , old -> cap_permitted ) ; } new -> suid = new -> fsuid = new -> euid ; new -> sgid = new -> fsgid = new -> egid ; if ( effective ) new -> cap_effective = new -> cap_permitted ; else cap_clear ( new -> cap_effective ) ; bprm -> cap_effective = effective ; if ( ! cap_isclear ( new -> cap_effective ) ) { if ( ! cap_issubset ( CAP_FULL_SET , new -> cap_effective ) || new -> euid != 0 || new -> uid != 0 || issecure ( SECURE_NOROOT ) ) { ret = audit_log_bprm_fcaps ( bprm , new , old ) ; if ( ret < 0 ) return ret ; } } new -> securebits &= ~ issecure_mask ( SECURE_KEEP_CAPS ) ; return 0 ; }","skip : if ( ! cap_issubset ( new -> cap_permitted , old -> cap_permitted ) ) bprm -> per_clear |= PER_CLEAR_ON_SETID ;if ( ( new -> euid != old -> uid || new -> egid != old -> gid || ! cap_issubset ( new -> cap_permitted , old -> cap_permitted ) ) && bprm -> unsafe & ~ LSM_UNSAFE_PTRACE_CAP ) {",104
150,"buggy line: static void  ext4_xattr_cache_insert ( struct mb_cache * ext4_mb_cache , struct buffer_head * bh )  {struct mb_cache_entry * ce ;int error ;ce = mb_cache_entry_alloc ( ext4_mb_cache , GFP_NOFS ) ;if ( ! ce ) {error = mb_cache_entry_insert ( ce , bh -> b_bdev , bh -> b_blocknr , hash ) ;if ( error ) {mb_cache_entry_free ( ce ) ;if ( error == - EBUSY ) {ea_bdebug ( bh , ""already<S2SV_blank>in<S2SV_blank>cache"" ) ;error = 0 ;}else {ea_bdebug ( bh , ""inserting<S2SV_blank>[%x]"" , ( int ) hash ) ;mb_cache_entry_release ( ce ) ;}cwe id:CWE-19context: static void  ext4_xattr_cache_insert ( struct mb_cache * ext4_mb_cache , struct buffer_head * bh )  { __u32 hash = le32_to_cpu ( BHDR ( bh ) -> h_hash ) ;  struct mb_cache_entry * ce ;  int error ;  ce = mb_cache_entry_alloc ( ext4_mb_cache , GFP_NOFS ) ;  if ( ! ce ) { ea_bdebug ( bh , ""out<S2SV_blank>of<S2SV_blank>memory"" ) ; return ; }  error = mb_cache_entry_insert ( ce , bh -> b_bdev , bh -> b_blocknr , hash ) ;  if ( error ) {  mb_cache_entry_free ( ce ) ;   if ( error == - EBUSY ) {  ea_bdebug ( bh , ""already<S2SV_blank>in<S2SV_blank>cache"" ) ;  error = 0 ;  } } else { ea_bdebug ( bh , ""inserting<S2SV_blank>[%x]"" , ( int ) hash ) ;  mb_cache_entry_release ( ce ) ;  } }","static void ext4_xattr_cache_insert ( struct mb2_cache * ext4_mb_cache , struct buffer_head * bh ) {int error ;ce = mb_cache_entry_alloc ( ext4_mb_cache , GFP_NOFS ) ;if ( ! ce ) {error = mb_cache_entry_insert ( ce , bh -> b_bdev , bh -> b_blocknr ) ;if ( error ) {mb_cache_entry_free ( ce ) ;if ( error == - EBUSY ) ea_bdebug ( bh , ""already<S2SV_blank>in<S2SV_blank>cache"" ) ;else ea_bdebug ( bh , ""inserting<S2SV_blank>[%x]"" , ( int ) hash ) ;",105
151,"buggy line: return NULL ;}host += 3 ;char * port = strchr ( host , \':\' ) ;if ( ! port ) {port = ( ssl ) ? ""443"" : ""80"" ;}else {* port ++ = 0 ;}char * path = strchr ( host , \'/\' ) ;if ( ! path ) {path = """" ;}else {* path ++ = 0 ;}s = r_socket_new ( ssl ) ;if ( ! s ) {printf ( ""Cannot<S2SV_blank>create<S2SV_blank>socket\\\free ( uri ) ;return NULL ;}if ( ! r_socket_connect_tcp ( s , host , port , 0 ) ) {cwe id:CWE-78context: R_API char * r_socket_http_post ( const char * url , const char * data , int * code , int * rlen ) { RSocket * s ; bool ssl = r_str_startswith ( url , ""https://"" ) ; char * uri = strdup ( url ) ; if ( ! uri ) { return NULL ; } char * host = strstr ( uri , ""://"" ) ; if ( ! host ) { free ( uri ) ; printf ( ""Invalid<S2SV_blank>URI"" ) ; return NULL ; } host += 3 ; char * port = strchr ( host , ':' ) ; if ( ! port ) { port = ( ssl ) ? ""443"" : ""80"" ; } else { * port ++ = 0 ; } char * path = strchr ( host , '/' ) ; if ( ! path ) { path = """" ; } else { * path ++ = 0 ; } s = r_socket_new ( ssl ) ; if ( ! s ) { printf ( ""Cannot<S2SV_blank>create<S2SV_blank>socket\\n"" ) ; free ( uri ) ; return NULL ; } if ( ! r_socket_connect_tcp ( s , host , port , 0 ) ) { eprintf ( ""Cannot<S2SV_blank>connect<S2SV_blank>to<S2SV_blank>%s:%s\\n"" , host , port ) ; free ( uri ) ; return NULL ; } r_socket_printf ( s , ""POST<S2SV_blank>/%s<S2SV_blank>HTTP/1.0\\r\\n"" ""User-Agent:<S2SV_blank>radare2<S2SV_blank>"" R2_VERSION ""\\r\\n"" ""Accept:<S2SV_blank>*/*\\r\\n"" ""Host:<S2SV_blank>%s\\r\\n"" ""Content-Length:<S2SV_blank>%i\\r\\n"" ""Content-Type:<S2SV_blank>application/x-www-form-urlencoded\\r\\n"" ""\\r\\n"" , path , host , ( int ) strlen ( data ) ) ; free ( uri ) ; r_socket_write ( s , ( void * ) data , strlen ( data ) ) ;  return r_socket_http_answer ( s , code , rlen ) ;  }","return socket_http_answer ( s , host , port , 0 ) ) {",106
152,"buggy line: return r_socket_http_answer ( s , code , rlen ) ;}cwe id:CWE-78context: R_API char * r_socket_http_post ( const char * url , const char * data , int * code , int * rlen ) { RSocket * s ; bool ssl = r_str_startswith ( url , ""https://"" ) ; char * uri = strdup ( url ) ; if ( ! uri ) { return NULL ; } char * host = strstr ( uri , ""://"" ) ; if ( ! host ) { free ( uri ) ; printf ( ""Invalid<S2SV_blank>URI"" ) ; return NULL ; } host += 3 ; char * port = strchr ( host , ':' ) ; if ( ! port ) { port = ( ssl ) ? ""443"" : ""80"" ; } else { * port ++ = 0 ; } char * path = strchr ( host , '/' ) ; if ( ! path ) { path = """" ; } else { * path ++ = 0 ; } s = r_socket_new ( ssl ) ; if ( ! s ) { printf ( ""Cannot<S2SV_blank>create<S2SV_blank>socket\\n"" ) ; free ( uri ) ; return NULL ; } if ( ! r_socket_connect_tcp ( s , host , port , 0 ) ) { eprintf ( ""Cannot<S2SV_blank>connect<S2SV_blank>to<S2SV_blank>%s:%s\\n"" , host , port ) ; free ( uri ) ; return NULL ; } r_socket_printf ( s , ""POST<S2SV_blank>/%s<S2SV_blank>HTTP/1.0\\r\\n"" ""User-Agent:<S2SV_blank>radare2<S2SV_blank>"" R2_VERSION ""\\r\\n"" ""Accept:<S2SV_blank>*/*\\r\\n"" ""Host:<S2SV_blank>%s\\r\\n"" ""Content-Length:<S2SV_blank>%i\\r\\n"" ""Content-Type:<S2SV_blank>application/x-www-form-urlencoded\\r\\n"" ""\\r\\n"" , path , host , ( int ) strlen ( data ) ) ; free ( uri ) ; r_socket_write ( s , ( void * ) data , strlen ( data ) ) ;  return r_socket_http_answer ( s , code , rlen ) ;  }","return r_socket_http_answer ( s , code , rlen , 0 ) ;}",106
153,"buggy line: tf = ( ( c == LUA_SIGNATURE [ 0 ] ) ? luaU_undump : luaY_parser ) ( L , p -> z ,  & p -> buff , p -> name ) ;cwe id:CWE-17context: static void f_parser ( lua_State * L , void * ud ) { int i ; Proto * tf ; Closure * cl ; struct SParser * p = cast ( struct SParser * , ud ) ; int c = luaZ_lookahead ( p -> z ) ; luaC_checkGC ( L ) ;  tf = ( ( c == LUA_SIGNATURE [ 0 ] ) ? luaU_undump : luaY_parser ) ( L , p -> z ,  & p -> buff , p -> name ) ; cl = luaF_newLclosure ( L , tf -> nups , hvalue ( gt ( L ) ) ) ; cl -> l . p = tf ; for ( i = 0 ; i < tf -> nups ; i ++ ) cl -> l . upvals [ i ] = luaF_newupval ( L ) ; setclvalue ( L , L -> top , cl ) ; incr_top ( L ) ; }","tf = ( luaY_parser ) ( L , p -> z , & p -> buff , p -> name ) ;",107
154,"buggy line: int err ;sock -> state = SS_UNCONNECTED ;cwe id:CWE-000context: static int inet_create ( struct net * net , struct socket * sock , int protocol , int kern ) { struct sock * sk ; struct inet_protosw * answer ; struct inet_sock * inet ; struct proto * answer_prot ; unsigned char answer_flags ; int try_loading_module = 0 ;  int err ;  sock -> state = SS_UNCONNECTED ; lookup_protocol : err = - ESOCKTNOSUPPORT ; rcu_read_lock ( ) ; list_for_each_entry_rcu ( answer , & inetsw [ sock -> type ] , list ) { err = 0 ; if ( protocol == answer -> protocol ) { if ( protocol != IPPROTO_IP ) break ; } else { if ( IPPROTO_IP == protocol ) { protocol = answer -> protocol ; break ; } if ( IPPROTO_IP == answer -> protocol ) break ; } err = - EPROTONOSUPPORT ; } if ( unlikely ( err ) ) { if ( try_loading_module < 2 ) { rcu_read_unlock ( ) ; if ( ++ try_loading_module == 1 ) request_module ( ""net-pf-%d-proto-%d-type-%d"" , PF_INET , protocol , sock -> type ) ; else request_module ( ""net-pf-%d-proto-%d"" , PF_INET , protocol ) ; goto lookup_protocol ; } else goto out_rcu_unlock ; } err = - EPERM ; if ( sock -> type == SOCK_RAW && ! kern && ! ns_capable ( net -> user_ns , CAP_NET_RAW ) ) goto out_rcu_unlock ; sock -> ops = answer -> ops ; answer_prot = answer -> prot ; answer_flags = answer -> flags ; rcu_read_unlock ( ) ; WARN_ON ( ! answer_prot -> slab ) ; err = - ENOBUFS ; sk = sk_alloc ( net , PF_INET , GFP_KERNEL , answer_prot , kern ) ; if ( ! sk ) goto out ; err = 0 ; if ( INET_PROTOSW_REUSE & answer_flags ) sk -> sk_reuse = SK_CAN_REUSE ; inet = inet_sk ( sk ) ; inet -> is_icsk = ( INET_PROTOSW_ICSK & answer_flags ) != 0 ; inet -> nodefrag = 0 ; if ( SOCK_RAW == sock -> type ) { inet -> inet_num = protocol ; if ( IPPROTO_RAW == protocol ) inet -> hdrincl = 1 ; } if ( net -> ipv4 . sysctl_ip_no_pmtu_disc ) inet -> pmtudisc = IP_PMTUDISC_DONT ; else inet -> pmtudisc = IP_PMTUDISC_WANT ; inet -> inet_id = 0 ; sock_init_data ( sock , sk ) ; sk -> sk_destruct = inet_sock_destruct ; sk -> sk_protocol = protocol ; sk -> sk_backlog_rcv = sk -> sk_prot -> backlog_rcv ; inet -> uc_ttl = - 1 ; inet -> mc_loop = 1 ; inet -> mc_ttl = 1 ; inet -> mc_all = 1 ; inet -> mc_index = 0 ; inet -> mc_list = NULL ; inet -> rcv_tos = 0 ; sk_refcnt_debug_inc ( sk ) ; if ( inet -> inet_num ) { inet -> inet_sport = htons ( inet -> inet_num ) ; sk -> sk_prot -> hash ( sk ) ; } if ( sk -> sk_prot -> init ) { err = sk -> sk_prot -> init ( sk ) ; if ( err ) sk_common_release ( sk ) ; } out : return err ; out_rcu_unlock : rcu_read_unlock ( ) ; goto out ; }",int err ;if ( protocol < 0 || protocol >= IPPROTO_MAX ) return - EINVAL ;sock -> state = SS_UNCONNECTED ;,108
155,"buggy line: int ip_options_get_from_user ( struct net * net , struct ip_options * * optp ,  unsigned char __user * data , int optlen ) {struct ip_options * opt = ip_options_get_alloc ( optlen ) ;if ( ! opt ) return - ENOMEM ;if ( optlen && copy_from_user ( opt -> __data , data , optlen ) ) {kfree ( opt ) ;cwe id:CWE-362context:  int ip_options_get_from_user ( struct net * net , struct ip_options * * optp ,  unsigned char __user * data , int optlen ) {  struct ip_options * opt = ip_options_get_alloc ( optlen ) ;  if ( ! opt ) return - ENOMEM ;  if ( optlen && copy_from_user ( opt -> __data , data , optlen ) ) {  kfree ( opt ) ; return - EFAULT ; } return ip_options_get_finish ( net , optp , opt , optlen ) ; }","int ip_options_get_from_user ( struct net * net , struct ip_options_rcu * * optp , unsigned char __user * data , int optlen ) {struct ip_options_rcu * opt = ip_options_get_alloc ( optlen ) ;if ( ! opt ) return - ENOMEM ;if ( optlen && copy_from_user ( opt -> opt . __data , data , optlen ) ) {kfree ( opt ) ;",109
156,"buggy line: dl = kmalloc ( size , GFP_KERNEL ) ;if ( ! dl ) return - ENOMEM ;cwe id:CWE-200context: static int rfcomm_get_dev_list ( void __user * arg ) { struct rfcomm_dev * dev ; struct rfcomm_dev_list_req * dl ; struct rfcomm_dev_info * di ; int n = 0 , size , err ; u16 dev_num ; BT_DBG ( """" ) ; if ( get_user ( dev_num , ( u16 __user * ) arg ) ) return - EFAULT ; if ( ! dev_num || dev_num > ( PAGE_SIZE * 4 ) / sizeof ( * di ) ) return - EINVAL ; size = sizeof ( * dl ) + dev_num * sizeof ( * di ) ;  dl = kmalloc ( size , GFP_KERNEL ) ;  if ( ! dl ) return - ENOMEM ; di = dl -> dev_info ; spin_lock ( & rfcomm_dev_lock ) ; list_for_each_entry ( dev , & rfcomm_dev_list , list ) { if ( test_bit ( RFCOMM_TTY_RELEASED , & dev -> flags ) ) continue ; ( di + n ) -> id = dev -> id ; ( di + n ) -> flags = dev -> flags ; ( di + n ) -> state = dev -> dlc -> state ; ( di + n ) -> channel = dev -> channel ; bacpy ( & ( di + n ) -> src , & dev -> src ) ; bacpy ( & ( di + n ) -> dst , & dev -> dst ) ; if ( ++ n >= dev_num ) break ; } spin_unlock ( & rfcomm_dev_lock ) ; dl -> dev_num = n ; size = sizeof ( * dl ) + n * sizeof ( * di ) ; err = copy_to_user ( arg , dl , size ) ; kfree ( dl ) ; return err ? - EFAULT : 0 ; }","dl = kzalloc ( size , GFP_KERNEL ) ;if ( ! dl ) return - ENOMEM ;",110
157,"buggy line: dagid_str = ip6addr_string ( ndo , dio -> rpl_dagid ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>[dagid:%s,seq:%u,instance:%u,rank:%u,%smop:%s,prf:%u]"" , dagid_str , dio -> rpl_dtsn , dio -> rpl_instanceid , EXTRACT_16BITS ( & dio -> rpl_dagrank ) , RPL_DIO_GROUNDED ( dio -> rpl_mopprf ) ? ""grounded,"" : """" , tok2str ( rpl_mop_values , ""mop%u"" , RPL_DIO_MOP ( dio -> rpl_mopprf ) ) , RPL_DIO_PRF ( dio -> rpl_mopprf ) ) ) ;trunc :  ND_PRINT ( ( ndo , ""<S2SV_blank>[|truncated]"" ) ) ;return ;cwe id:CWE-125context: static void rpl_dio_print ( netdissect_options * ndo , const u_char * bp , u_int length ) { const struct nd_rpl_dio * dio = ( const struct nd_rpl_dio * ) bp ; const char * dagid_str ; ND_TCHECK ( * dio ) ; dagid_str = ip6addr_string ( ndo , dio -> rpl_dagid ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>[dagid:%s,seq:%u,instance:%u,rank:%u,%smop:%s,prf:%u]"" , dagid_str , dio -> rpl_dtsn , dio -> rpl_instanceid , EXTRACT_16BITS ( & dio -> rpl_dagrank ) , RPL_DIO_GROUNDED ( dio -> rpl_mopprf ) ? ""grounded,"" : """" , tok2str ( rpl_mop_values , ""mop%u"" , RPL_DIO_MOP ( dio -> rpl_mopprf ) ) , RPL_DIO_PRF ( dio -> rpl_mopprf ) ) ) ; if ( ndo -> ndo_vflag > 1 ) { const struct rpl_dio_genoption * opt = ( const struct rpl_dio_genoption * ) & dio [ 1 ] ; rpl_dio_printopt ( ndo , opt , length ) ; } return ; trunc :  ND_PRINT ( ( ndo , ""<S2SV_blank>[|truncated]"" ) ) ;  return ; }","dagid_str = ip6addr_string ( ndo , ""%s"" , rpl_tstr ) ) ;trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|truncated]"" ) ) ;return ;",111
158,"buggy line: static int   rpki_rtr_pdu_print ( netdissect_options * ndo , const u_char * tptr , u_int indent )  {pdu_header = ( const rpki_rtr_pdu * ) tptr ;pdu_type = pdu_header -> pdu_type ;ND_TCHECK2 ( * tptr , pdu_len ) ;hexdump = FALSE ;ND_PRINT ( ( ndo , ""%sRPKI-RTRv%u,<S2SV_blank>%s<S2SV_blank>PDU<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u"" , indent_string ( 8 ) , pdu_header -> version , tok2str ( rpki_rtr_pdu_values , ""Unknown"" , pdu_type ) ,  pdu_type , pdu_len ) ) ;switch ( pdu_type ) {case RPKI_RTR_SERIAL_NOTIFY_PDU : case RPKI_RTR_SERIAL_QUERY_PDU :  case RPKI_RTR_END_OF_DATA_PDU :  msg = ( const u_char * ) ( pdu_header + 1 ) ;case RPKI_RTR_RESET_QUERY_PDU : case RPKI_RTR_CACHE_RESET_PDU :  break ;case RPKI_RTR_CACHE_RESPONSE_PDU :  ND_PRINT ( ( ndo , ""%sSession<S2SV_blank>ID:<S2SV_blank>0x%04x"" , indent_string ( indent + 2 ) , EXTRACT_16BITS ( pdu_header -> u . session_id ) ) ) ;pdu = ( const rpki_rtr_pdu_ipv4_prefix * ) tptr ;ND_PRINT ( ( ndo , ""%sIPv4<S2SV_blank>Prefix<S2SV_blank>%s/%u-%u,<S2SV_blank>origin-as<S2SV_blank>%u,<S2SV_blank>flags<S2SV_blank>0x%02x"" , indent_string ( indent + 2 ) , ipaddr_string ( ndo , pdu -> prefix ) , pdu -> prefix_length , pdu -> max_length , EXTRACT_32BITS ( pdu -> as ) , pdu -> flags ) ) ;pdu = ( const rpki_rtr_pdu_ipv6_prefix * ) tptr ;ND_PRINT ( ( ndo , ""%sIPv6<S2SV_blank>Prefix<S2SV_blank>%s/%u-%u,<S2SV_blank>origin-as<S2SV_blank>%u,<S2SV_blank>flags<S2SV_blank>0x%02x"" , indent_string ( indent + 2 ) , ip6addr_string ( ndo , pdu -> prefix ) , pdu -> prefix_length , pdu -> max_length , EXTRACT_32BITS ( pdu -> as ) , pdu -> flags ) ) ;pdu = ( const rpki_rtr_pdu_error_report * ) tptr ;encapsulated_pdu_length = EXTRACT_32BITS ( pdu -> encapsulated_pdu_length ) ;ND_TCHECK2 ( * tptr , encapsulated_pdu_length ) ;tlen = pdu_len ;tptr += sizeof ( * pdu ) ;tlen -= sizeof ( * pdu ) ;if ( encapsulated_pdu_length &&  ( encapsulated_pdu_length <= tlen ) ) {if ( rpki_rtr_pdu_print ( ndo , tptr , indent + 2 ) )  goto trunc ;tptr += encapsulated_pdu_length ;tlen -= encapsulated_pdu_length ;text_length = 0 ;if ( tlen > 4 ) {text_length = EXTRACT_32BITS ( tptr ) ;tptr += 4 ;tlen -= 4 ;}ND_TCHECK2 ( * tptr , text_length ) ;if ( text_length && ( text_length <= tlen ) ) {ND_PRINT ( ( ndo , ""%sError<S2SV_blank>text:<S2SV_blank>"" , indent_string ( indent + 2 ) ) ) ;if ( fn_printn ( ndo , tptr , text_length , ndo -> ndo_snapend ) ) goto trunc ;}break ;default : hexdump = TRUE ;return 0 ;trunc :  return 1 ;}cwe id:CWE-125context:  static int   rpki_rtr_pdu_print ( netdissect_options * ndo , const u_char * tptr , u_int indent )  { const rpki_rtr_pdu * pdu_header ; u_int pdu_type , pdu_len , hexdump ; const u_char * msg ;  pdu_header = ( const rpki_rtr_pdu * ) tptr ;  pdu_type = pdu_header -> pdu_type ; pdu_len = EXTRACT_32BITS ( pdu_header -> length ) ;  ND_TCHECK2 ( * tptr , pdu_len ) ;  hexdump = FALSE ; ND_PRINT ( ( ndo , ""%sRPKI-RTRv%u,<S2SV_blank>%s<S2SV_blank>PDU<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u"" , indent_string ( 8 ) , pdu_header -> version , tok2str ( rpki_rtr_pdu_values , ""Unknown"" , pdu_type ) ,  pdu_type , pdu_len ) ) ;  switch ( pdu_type ) { case RPKI_RTR_SERIAL_NOTIFY_PDU : case RPKI_RTR_SERIAL_QUERY_PDU :  case RPKI_RTR_END_OF_DATA_PDU :  msg = ( const u_char * ) ( pdu_header + 1 ) ; ND_PRINT ( ( ndo , ""%sSession<S2SV_blank>ID:<S2SV_blank>0x%04x,<S2SV_blank>Serial:<S2SV_blank>%u"" , indent_string ( indent + 2 ) , EXTRACT_16BITS ( pdu_header -> u . session_id ) , EXTRACT_32BITS ( msg ) ) ) ; break ; case RPKI_RTR_RESET_QUERY_PDU : case RPKI_RTR_CACHE_RESET_PDU :  break ;   case RPKI_RTR_CACHE_RESPONSE_PDU :  ND_PRINT ( ( ndo , ""%sSession<S2SV_blank>ID:<S2SV_blank>0x%04x"" , indent_string ( indent + 2 ) , EXTRACT_16BITS ( pdu_header -> u . session_id ) ) ) ; break ; case RPKI_RTR_IPV4_PREFIX_PDU : { const rpki_rtr_pdu_ipv4_prefix * pdu ;  pdu = ( const rpki_rtr_pdu_ipv4_prefix * ) tptr ;  ND_PRINT ( ( ndo , ""%sIPv4<S2SV_blank>Prefix<S2SV_blank>%s/%u-%u,<S2SV_blank>origin-as<S2SV_blank>%u,<S2SV_blank>flags<S2SV_blank>0x%02x"" , indent_string ( indent + 2 ) , ipaddr_string ( ndo , pdu -> prefix ) , pdu -> prefix_length , pdu -> max_length , EXTRACT_32BITS ( pdu -> as ) , pdu -> flags ) ) ; } break ; case RPKI_RTR_IPV6_PREFIX_PDU : { const rpki_rtr_pdu_ipv6_prefix * pdu ;  pdu = ( const rpki_rtr_pdu_ipv6_prefix * ) tptr ;  ND_PRINT ( ( ndo , ""%sIPv6<S2SV_blank>Prefix<S2SV_blank>%s/%u-%u,<S2SV_blank>origin-as<S2SV_blank>%u,<S2SV_blank>flags<S2SV_blank>0x%02x"" , indent_string ( indent + 2 ) , ip6addr_string ( ndo , pdu -> prefix ) , pdu -> prefix_length , pdu -> max_length , EXTRACT_32BITS ( pdu -> as ) , pdu -> flags ) ) ; } break ; case RPKI_RTR_ERROR_REPORT_PDU : { const rpki_rtr_pdu_error_report * pdu ; u_int encapsulated_pdu_length , text_length , tlen , error_code ;  pdu = ( const rpki_rtr_pdu_error_report * ) tptr ;  encapsulated_pdu_length = EXTRACT_32BITS ( pdu -> encapsulated_pdu_length ) ;  ND_TCHECK2 ( * tptr , encapsulated_pdu_length ) ;  tlen = pdu_len ; error_code = EXTRACT_16BITS ( pdu -> pdu_header . u . error_code ) ; ND_PRINT ( ( ndo , ""%sError<S2SV_blank>code:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Encapsulated<S2SV_blank>PDU<S2SV_blank>length:<S2SV_blank>%u"" , indent_string ( indent + 2 ) , tok2str ( rpki_rtr_error_codes , ""Unknown"" , error_code ) , error_code , encapsulated_pdu_length ) ) ;  tptr += sizeof ( * pdu ) ;  tlen -= sizeof ( * pdu ) ;  if ( encapsulated_pdu_length &&  ( encapsulated_pdu_length <= tlen ) ) { ND_PRINT ( ( ndo , ""%s-----encapsulated<S2SV_blank>PDU-----"" , indent_string ( indent + 4 ) ) ) ;  if ( rpki_rtr_pdu_print ( ndo , tptr , indent + 2 ) )  goto trunc ; } tptr += encapsulated_pdu_length ;  tlen -= encapsulated_pdu_length ;   text_length = 0 ;  if ( tlen > 4 ) {  text_length = EXTRACT_32BITS ( tptr ) ;  tptr += 4 ;  tlen -= 4 ;  }  ND_TCHECK2 ( * tptr , text_length ) ;  if ( text_length && ( text_length <= tlen ) ) { ND_PRINT ( ( ndo , ""%sError<S2SV_blank>text:<S2SV_blank>"" , indent_string ( indent + 2 ) ) ) ; if ( fn_printn ( ndo , tptr , text_length , ndo -> ndo_snapend ) ) goto trunc ; } } break ; default : hexdump = TRUE ; } if ( ndo -> ndo_vflag > 1 || ( ndo -> ndo_vflag && hexdump ) ) { print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank>"" , pdu_len ) ; }  return 0 ;  trunc :  return 1 ;  }","static u_int rpki_rtr_pdu_print ( netdissect_options * ndo , const u_char * tptr , const u_int len , const u_char recurse , const u_int indent ) {ND_TCHECK_8BITS ( tptr ) ;if ( * tptr != 0 ) {ND_PRINT ( ( ndo , ""%sRPKI-RTRv%u<S2SV_blank>(unknown)"" , indent_string ( 8 ) , * tptr ) ) ;return len ;}if ( len < sizeof ( rpki_rtr_pdu ) ) {ND_PRINT ( ( ndo , ""(%u<S2SV_blank>bytes<S2SV_blank>is<S2SV_blank>too<S2SV_blank>few<S2SV_blank>to<S2SV_blank>decode)"" , len ) ) ;goto invalid ;}ND_TCHECK2 ( * tptr , sizeof ( rpki_rtr_pdu ) ) ;pdu_header = ( const rpki_rtr_pdu * ) tptr ;pdu_type = pdu_header -> pdu_type ;hexdump = FALSE ;ND_PRINT ( ( ndo , ""%sRPKI-RTRv%u,<S2SV_blank>%s<S2SV_blank>PDU<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u"" , indent_string ( 8 ) , pdu_header -> version , tok2str ( rpki_rtr_pdu_values , ""Unknown"" , pdu_type ) , pdu_type , pdu_len ) ) ;if ( pdu_len < sizeof ( rpki_rtr_pdu ) || pdu_len > len ) goto invalid ;switch ( pdu_type ) {case RPKI_RTR_SERIAL_NOTIFY_PDU : case RPKI_RTR_SERIAL_QUERY_PDU : case RPKI_RTR_END_OF_DATA_PDU : if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 4 ) goto invalid ;ND_TCHECK2 ( * tptr , pdu_len ) ;msg = ( const u_char * ) ( pdu_header + 1 ) ;case RPKI_RTR_RESET_QUERY_PDU : case RPKI_RTR_CACHE_RESET_PDU : if ( pdu_len != sizeof ( rpki_rtr_pdu ) ) goto invalid ;break ;case RPKI_RTR_CACHE_RESPONSE_PDU : if ( pdu_len != sizeof ( rpki_rtr_pdu ) ) goto invalid ;ND_PRINT ( ( ndo , ""%sSession<S2SV_blank>ID:<S2SV_blank>0x%04x"" , indent_string ( indent + 2 ) , EXTRACT_16BITS ( pdu_header -> u . session_id ) ) ) ;if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 12 ) goto invalid ;ND_TCHECK2 ( * tptr , pdu_len ) ;pdu = ( const rpki_rtr_pdu_ipv4_prefix * ) tptr ;ND_PRINT ( ( ndo , ""%sIPv4<S2SV_blank>Prefix<S2SV_blank>%s/%u-%u,<S2SV_blank>origin-as<S2SV_blank>%u,<S2SV_blank>flags<S2SV_blank>0x%02x"" , indent_string ( indent + 2 ) , ipaddr_string ( ndo , pdu -> prefix ) , pdu -> prefix_length , pdu -> max_length , EXTRACT_32BITS ( pdu -> as ) , pdu -> flags ) ) ;if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 24 ) goto invalid ;ND_TCHECK2 ( * tptr , pdu_len ) ;pdu = ( const rpki_rtr_pdu_ipv6_prefix * ) tptr ;ND_PRINT ( ( ndo , ""%sIPv6<S2SV_blank>Prefix<S2SV_blank>%s/%u-%u,<S2SV_blank>origin-as<S2SV_blank>%u,<S2SV_blank>flags<S2SV_blank>0x%02x"" , indent_string ( indent + 2 ) , ip6addr_string ( ndo , pdu -> prefix ) , pdu -> prefix_length , pdu -> max_length , EXTRACT_32BITS ( pdu -> as ) , pdu -> flags ) ) ;tlen = sizeof ( rpki_rtr_pdu ) ;if ( pdu_len < tlen + 4 ) goto invalid ;ND_TCHECK2 ( * tptr , tlen + 4 ) ;pdu = ( const rpki_rtr_pdu_error_report * ) tptr ;encapsulated_pdu_length = EXTRACT_32BITS ( pdu -> encapsulated_pdu_length ) ;tlen += 4 ;if ( encapsulated_pdu_length && ( encapsulated_pdu_length <= tlen ) ) {rpki_rtr_pdu_print ( ndo , tptr + tlen , encapsulated_pdu_length , 0 , indent + 2 ) ;tlen += encapsulated_pdu_length ;tlen -= encapsulated_pdu_length ;text_length = EXTRACT_32BITS ( tptr ) ;tptr += 4 ;tlen -= 4 ;ND_TCHECK2 ( * tptr , pdu_len ) ;hexdump = TRUE ;return 0 ;trunc : ND_PRINT ( ( ndo , ""\\\return len ;}",112
159,"buggy line: int n , len ;skb -> sk = NULL ;memset ( & facilities , 0x00 , sizeof ( struct rose_facilities_struct ) ) ;len = ( ( ( skb -> data [ 3 ] >> 4 ) & 0x0F ) + 1 ) >> 1 ;len += ( ( ( skb -> data [ 3 ] >> 0 ) & 0x0F ) + 1 ) >> 1 ;if ( ! rose_parse_facilities ( skb -> data + len + 4 , & facilities ) ) {rose_transmit_clear_request ( neigh , lci , ROSE_INVALID_FACILITY , 76 ) ;cwe id:CWE-20context: int rose_rx_call_request ( struct sk_buff * skb , struct net_device * dev , struct rose_neigh * neigh , unsigned int lci ) { struct sock * sk ; struct sock * make ; struct rose_sock * make_rose ; struct rose_facilities_struct facilities ;  int n , len ;  skb -> sk = NULL ;  memset ( & facilities , 0x00 , sizeof ( struct rose_facilities_struct ) ) ;  len = ( ( ( skb -> data [ 3 ] >> 4 ) & 0x0F ) + 1 ) >> 1 ; len += ( ( ( skb -> data [ 3 ] >> 0 ) & 0x0F ) + 1 ) >> 1 ;  if ( ! rose_parse_facilities ( skb -> data + len + 4 , & facilities ) ) {  rose_transmit_clear_request ( neigh , lci , ROSE_INVALID_FACILITY , 76 ) ; return 0 ; } sk = rose_find_listener ( & facilities . source_addr , & facilities . source_call ) ; if ( sk == NULL || sk_acceptq_is_full ( sk ) || ( make = rose_make_new ( sk ) ) == NULL ) { rose_transmit_clear_request ( neigh , lci , ROSE_NETWORK_CONGESTION , 120 ) ; return 0 ; } skb -> sk = make ; make -> sk_state = TCP_ESTABLISHED ; make_rose = rose_sk ( make ) ; make_rose -> lci = lci ; make_rose -> dest_addr = facilities . dest_addr ; make_rose -> dest_call = facilities . dest_call ; make_rose -> dest_ndigis = facilities . dest_ndigis ; for ( n = 0 ; n < facilities . dest_ndigis ; n ++ ) make_rose -> dest_digis [ n ] = facilities . dest_digis [ n ] ; make_rose -> source_addr = facilities . source_addr ; make_rose -> source_call = facilities . source_call ; make_rose -> source_ndigis = facilities . source_ndigis ; for ( n = 0 ; n < facilities . source_ndigis ; n ++ ) make_rose -> source_digis [ n ] = facilities . source_digis [ n ] ; make_rose -> neighbour = neigh ; make_rose -> device = dev ; make_rose -> facilities = facilities ; make_rose -> neighbour -> use ++ ; if ( rose_sk ( sk ) -> defer ) { make_rose -> state = ROSE_STATE_5 ; } else { rose_write_internal ( make , ROSE_CALL_ACCEPTED ) ; make_rose -> state = ROSE_STATE_3 ; rose_start_idletimer ( make ) ; } make_rose -> condition = 0x00 ; make_rose -> vs = 0 ; make_rose -> va = 0 ; make_rose -> vr = 0 ; make_rose -> vl = 0 ; sk -> sk_ack_backlog ++ ; rose_insert_socket ( make ) ; skb_queue_head ( & sk -> sk_receive_queue , skb ) ; rose_start_heartbeat ( make ) ; if ( ! sock_flag ( sk , SOCK_DEAD ) ) sk -> sk_data_ready ( sk , skb -> len ) ; return 1 ; }","int n ;skb -> sk = NULL ;memset ( & facilities , 0x00 , sizeof ( struct rose_facilities_struct ) ) ;if ( ! rose_parse_facilities ( skb -> data + len + 4 , & facilities ) ) {rose_transmit_clear_request ( neigh , lci , ROSE_INVALID_FACILITY , 76 ) ;",113
160,"buggy line: addr . sin_addr . s_addr = htonl ( INADDR_ANY ) ;addr . sin_port = htons ( port ) ;cwe id:CWE-284context: int socket_accept ( int fd , uint16_t port ) { # ifdef WIN32 int addr_len ; # else socklen_t addr_len ; # endif int result ; struct sockaddr_in addr ; memset ( & addr , 0 , sizeof ( addr ) ) ; addr . sin_family = AF_INET ;  addr . sin_addr . s_addr = htonl ( INADDR_ANY ) ;  addr . sin_port = htons ( port ) ; addr_len = sizeof ( addr ) ; result = accept ( fd , ( struct sockaddr * ) & addr , & addr_len ) ; return result ; }",addr . sin_addr . s_addr = htonl ( INADDR_LOOPBACK ) ;addr . sin_port = htons ( port ) ;,114
161,"buggy line: # endif # ifdef FEAT_KEYMAP else if ( varp == & curbuf -> b_p_keymap )  {errmsg = keymap_init ( ) ;cwe id:CWE-20context: static char_u * did_set_string_option ( int opt_idx , char_u * * varp , int new_value_alloced , char_u * oldval , char_u * errbuf , int opt_flags ) { char_u * errmsg = NULL ; char_u * s , * p ; int did_chartab = FALSE ; char_u * * gvarp ; long_u free_oldval = ( options [ opt_idx ] . flags & P_ALLOCED ) ; # ifdef FEAT_GUI int redraw_gui_only = FALSE ; # endif gvarp = ( char_u * * ) get_varp_scope ( & ( options [ opt_idx ] ) , OPT_GLOBAL ) ; if ( ( secure # ifdef HAVE_SANDBOX || sandbox != 0 # endif ) && ( options [ opt_idx ] . flags & P_SECURE ) ) { errmsg = e_secure ; } else if ( ( options [ opt_idx ] . flags & P_NFNAME ) && vim_strpbrk ( * varp , ( char_u * ) ""/\\\\*?[|<>"" ) != NULL ) { errmsg = e_invarg ; } else if ( varp == & T_NAME ) { if ( T_NAME [ 0 ] == NUL ) errmsg = ( char_u * ) N_ ( ""E529:<S2SV_blank>Cannot<S2SV_blank>set<S2SV_blank>\'term\'<S2SV_blank>to<S2SV_blank>empty<S2SV_blank>string"" ) ; # ifdef FEAT_GUI if ( gui . in_use ) errmsg = ( char_u * ) N_ ( ""E530:<S2SV_blank>Cannot<S2SV_blank>change<S2SV_blank>term<S2SV_blank>in<S2SV_blank>GUI"" ) ; else if ( term_is_gui ( T_NAME ) ) errmsg = ( char_u * ) N_ ( ""E531:<S2SV_blank>Use<S2SV_blank>\\"":gui\\""<S2SV_blank>to<S2SV_blank>start<S2SV_blank>the<S2SV_blank>GUI"" ) ; # endif else if ( set_termname ( T_NAME ) == FAIL ) errmsg = ( char_u * ) N_ ( ""E522:<S2SV_blank>Not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>termcap"" ) ; else redraw_later_clear ( ) ; } else if ( gvarp == & p_bkc ) { char_u * bkc = p_bkc ; unsigned int * flags = & bkc_flags ; if ( opt_flags & OPT_LOCAL ) { bkc = curbuf -> b_p_bkc ; flags = & curbuf -> b_bkc_flags ; } if ( ( opt_flags & OPT_LOCAL ) && * bkc == NUL ) * flags = 0 ; else { if ( opt_strings_flags ( bkc , p_bkc_values , flags , TRUE ) != OK ) errmsg = e_invarg ; if ( ( ( ( int ) * flags & BKC_AUTO ) != 0 ) + ( ( ( int ) * flags & BKC_YES ) != 0 ) + ( ( ( int ) * flags & BKC_NO ) != 0 ) != 1 ) { ( void ) opt_strings_flags ( oldval , p_bkc_values , flags , TRUE ) ; errmsg = e_invarg ; } } } else if ( varp == & p_bex || varp == & p_pm ) { if ( STRCMP ( * p_bex == '.' ? p_bex + 1 : p_bex , * p_pm == '.' ? p_pm + 1 : p_pm ) == 0 ) errmsg = ( char_u * ) N_ ( ""E589:<S2SV_blank>\'backupext\'<S2SV_blank>and<S2SV_blank>\'patchmode\'<S2SV_blank>are<S2SV_blank>equal"" ) ; } # ifdef FEAT_LINEBREAK else if ( varp == & curwin -> w_p_briopt ) { if ( briopt_check ( curwin ) == FAIL ) errmsg = e_invarg ; } # endif else if ( varp == & p_isi || varp == & ( curbuf -> b_p_isk ) || varp == & p_isp || varp == & p_isf ) { if ( init_chartab ( ) == FAIL ) { did_chartab = TRUE ; errmsg = e_invarg ; } } else if ( varp == & p_hf ) { if ( didset_vim ) { vim_setenv ( ( char_u * ) ""VIM"" , ( char_u * ) """" ) ; didset_vim = FALSE ; } if ( didset_vimruntime ) { vim_setenv ( ( char_u * ) ""VIMRUNTIME"" , ( char_u * ) """" ) ; didset_vimruntime = FALSE ; } } # ifdef FEAT_SYN_HL else if ( varp == & curwin -> w_p_cc ) errmsg = check_colorcolumn ( curwin ) ; # endif # ifdef FEAT_MULTI_LANG else if ( varp == & p_hlg ) { for ( s = p_hlg ; * s != NUL ; s += 3 ) { if ( s [ 1 ] == NUL || ( ( s [ 2 ] != ',' || s [ 3 ] == NUL ) && s [ 2 ] != NUL ) ) { errmsg = e_invarg ; break ; } if ( s [ 2 ] == NUL ) break ; } } # endif else if ( varp == & p_hl ) { if ( highlight_changed ( ) == FAIL ) errmsg = e_invarg ; } else if ( gvarp == & p_nf ) { if ( check_opt_strings ( * varp , p_nf_values , TRUE ) != OK ) errmsg = e_invarg ; } # ifdef FEAT_SESSION else if ( varp == & p_ssop ) { if ( opt_strings_flags ( p_ssop , p_ssop_values , & ssop_flags , TRUE ) != OK ) errmsg = e_invarg ; if ( ( ssop_flags & SSOP_CURDIR ) && ( ssop_flags & SSOP_SESDIR ) ) { ( void ) opt_strings_flags ( oldval , p_ssop_values , & ssop_flags , TRUE ) ; errmsg = e_invarg ; } } else if ( varp == & p_vop ) { if ( opt_strings_flags ( p_vop , p_ssop_values , & vop_flags , TRUE ) != OK ) errmsg = e_invarg ; } # endif # ifdef FEAT_SCROLLBIND else if ( varp == & p_sbo ) { if ( check_opt_strings ( p_sbo , p_scbopt_values , TRUE ) != OK ) errmsg = e_invarg ; } # endif # ifdef FEAT_MBYTE else if ( varp == & p_ambw || varp == & p_emoji ) { if ( check_opt_strings ( p_ambw , p_ambw_values , FALSE ) != OK ) errmsg = e_invarg ; else if ( set_chars_option ( & p_lcs ) != NULL ) errmsg = ( char_u * ) _ ( ""E834:<S2SV_blank>Conflicts<S2SV_blank>with<S2SV_blank>value<S2SV_blank>of<S2SV_blank>\'listchars\'"" ) ; # if defined ( FEAT_WINDOWS ) || defined ( FEAT_FOLDING ) else if ( set_chars_option ( & p_fcs ) != NULL ) errmsg = ( char_u * ) _ ( ""E835:<S2SV_blank>Conflicts<S2SV_blank>with<S2SV_blank>value<S2SV_blank>of<S2SV_blank>\'fillchars\'"" ) ; # endif } # endif else if ( varp == & p_bg ) { if ( check_opt_strings ( p_bg , p_bg_values , FALSE ) == OK ) { # ifdef FEAT_EVAL int dark = ( * p_bg == 'd' ) ; # endif init_highlight ( FALSE , FALSE ) ; # ifdef FEAT_EVAL if ( dark != ( * p_bg == 'd' ) && get_var_value ( ( char_u * ) ""g:colors_name"" ) != NULL ) { do_unlet ( ( char_u * ) ""g:colors_name"" , TRUE ) ; free_string_option ( p_bg ) ; p_bg = vim_strsave ( ( char_u * ) ( dark ? ""dark"" : ""light"" ) ) ; check_string_option ( & p_bg ) ; init_highlight ( FALSE , FALSE ) ; } # endif } else errmsg = e_invarg ; } else if ( varp == & p_wim ) { if ( check_opt_wim ( ) == FAIL ) errmsg = e_invarg ; } # ifdef FEAT_CMDL_COMPL else if ( varp == & p_wop ) { if ( check_opt_strings ( p_wop , p_wop_values , TRUE ) != OK ) errmsg = e_invarg ; } # endif # ifdef FEAT_WAK else if ( varp == & p_wak ) { if ( * p_wak == NUL || check_opt_strings ( p_wak , p_wak_values , FALSE ) != OK ) errmsg = e_invarg ; # ifdef FEAT_MENU # ifdef FEAT_GUI_MOTIF else if ( gui . in_use ) gui_motif_set_mnemonics ( p_wak [ 0 ] == 'y' || p_wak [ 0 ] == 'm' ) ; # else # ifdef FEAT_GUI_GTK else if ( gui . in_use ) gui_gtk_set_mnemonics ( p_wak [ 0 ] == 'y' || p_wak [ 0 ] == 'm' ) ; # endif # endif # endif } # endif # ifdef FEAT_AUTOCMD else if ( varp == & p_ei ) { if ( check_ei ( ) == FAIL ) errmsg = e_invarg ; } # endif # ifdef FEAT_MBYTE else if ( varp == & p_enc || gvarp == & p_fenc || varp == & p_tenc ) { if ( gvarp == & p_fenc ) { if ( ! curbuf -> b_p_ma && opt_flags != OPT_GLOBAL ) errmsg = e_modifiable ; else if ( vim_strchr ( * varp , ',' ) != NULL ) errmsg = e_invarg ; else { # ifdef FEAT_TITLE redraw_titles ( ) ; # endif ml_setflags ( curbuf ) ; } } if ( errmsg == NULL ) { p = enc_canonize ( * varp ) ; if ( p != NULL ) { vim_free ( * varp ) ; * varp = p ; } if ( varp == & p_enc ) { errmsg = mb_init ( ) ; # ifdef FEAT_TITLE redraw_titles ( ) ; # endif } } # if defined ( FEAT_GUI_GTK ) if ( errmsg == NULL && varp == & p_tenc && gui . in_use ) { if ( STRCMP ( p_tenc , ""utf-8"" ) != 0 ) errmsg = ( char_u * ) N_ ( ""E617:<S2SV_blank>Cannot<S2SV_blank>be<S2SV_blank>changed<S2SV_blank>in<S2SV_blank>the<S2SV_blank>GTK+<S2SV_blank>2<S2SV_blank>GUI"" ) ; } # endif if ( errmsg == NULL ) { # ifdef FEAT_KEYMAP if ( varp == & p_enc && * curbuf -> b_p_keymap != NUL ) ( void ) keymap_init ( ) ; # endif if ( ( ( varp == & p_enc && * p_tenc != NUL ) || varp == & p_tenc ) ) { convert_setup ( & input_conv , p_tenc , p_enc ) ; convert_setup ( & output_conv , p_enc , p_tenc ) ; } # if defined ( WIN3264 ) && defined ( FEAT_MBYTE ) if ( varp == & p_enc ) init_homedir ( ) ; # endif } } # endif # if defined ( FEAT_POSTSCRIPT ) else if ( varp == & p_penc ) { p = enc_canonize ( p_penc ) ; if ( p != NULL ) { vim_free ( p_penc ) ; p_penc = p ; } else { for ( s = p_penc ; * s != NUL ; s ++ ) { if ( * s == '_' ) * s = '-' ; else * s = TOLOWER_ASC ( * s ) ; } } } # endif # if defined ( FEAT_XIM ) && defined ( FEAT_GUI_GTK ) else if ( varp == & p_imak ) { if ( gui . in_use && ! im_xim_isvalid_imactivate ( ) ) errmsg = e_invarg ; } # endif # ifdef FEAT_KEYMAP else if ( varp == & curbuf -> b_p_keymap )  {  errmsg = keymap_init ( ) ; if ( errmsg == NULL ) { if ( * curbuf -> b_p_keymap != NUL ) { curbuf -> b_p_iminsert = B_IMODE_LMAP ; if ( curbuf -> b_p_imsearch != B_IMODE_USE_INSERT ) curbuf -> b_p_imsearch = B_IMODE_LMAP ; } else { if ( curbuf -> b_p_iminsert == B_IMODE_LMAP ) curbuf -> b_p_iminsert = B_IMODE_NONE ; if ( curbuf -> b_p_imsearch == B_IMODE_LMAP ) curbuf -> b_p_imsearch = B_IMODE_USE_INSERT ; } if ( ( opt_flags & OPT_LOCAL ) == 0 ) { set_iminsert_global ( ) ; set_imsearch_global ( ) ; } # ifdef FEAT_WINDOWS status_redraw_curbuf ( ) ; # endif } } # endif else if ( gvarp == & p_ff ) { if ( ! curbuf -> b_p_ma && ! ( opt_flags & OPT_GLOBAL ) ) errmsg = e_modifiable ; else if ( check_opt_strings ( * varp , p_ff_values , FALSE ) != OK ) errmsg = e_invarg ; else { if ( get_fileformat ( curbuf ) == EOL_DOS ) curbuf -> b_p_tx = TRUE ; else curbuf -> b_p_tx = FALSE ; # ifdef FEAT_TITLE redraw_titles ( ) ; # endif ml_setflags ( curbuf ) ; if ( get_fileformat ( curbuf ) == EOL_MAC || * oldval == 'm' ) redraw_curbuf_later ( NOT_VALID ) ; } } else if ( varp == & p_ffs ) { if ( check_opt_strings ( p_ffs , p_ff_values , TRUE ) != OK ) errmsg = e_invarg ; else { if ( * p_ffs == NUL ) p_ta = FALSE ; else p_ta = TRUE ; } } # if defined ( FEAT_CRYPT ) else if ( gvarp == & p_key ) { # if defined ( FEAT_CMDHIST ) remove_key_from_history ( ) ; # endif if ( STRCMP ( curbuf -> b_p_key , oldval ) != 0 ) ml_set_crypt_key ( curbuf , oldval , * curbuf -> b_p_cm == NUL ? p_cm : curbuf -> b_p_cm ) ; } else if ( gvarp == & p_cm ) { if ( opt_flags & OPT_LOCAL ) p = curbuf -> b_p_cm ; else p = p_cm ; if ( check_opt_strings ( p , p_cm_values , TRUE ) != OK ) errmsg = e_invarg ; else if ( crypt_self_test ( ) == FAIL ) errmsg = e_invarg ; else { if ( * p_cm == NUL ) { if ( new_value_alloced ) free_string_option ( p_cm ) ; p_cm = vim_strsave ( ( char_u * ) ""zip"" ) ; new_value_alloced = TRUE ; } if ( ( opt_flags & ( OPT_LOCAL | OPT_GLOBAL ) ) == 0 ) { free_string_option ( curbuf -> b_p_cm ) ; curbuf -> b_p_cm = empty_option ; } if ( ( opt_flags & OPT_LOCAL ) && * oldval == NUL ) s = p_cm ; else s = oldval ; if ( * curbuf -> b_p_cm == NUL ) p = p_cm ; else p = curbuf -> b_p_cm ; if ( STRCMP ( s , p ) != 0 ) ml_set_crypt_key ( curbuf , curbuf -> b_p_key , s ) ; if ( ( opt_flags & OPT_GLOBAL ) && STRCMP ( p_cm , oldval ) != 0 ) { buf_T * buf ; FOR_ALL_BUFFERS ( buf ) if ( buf != curbuf && * buf -> b_p_cm == NUL ) ml_set_crypt_key ( buf , buf -> b_p_key , oldval ) ; } } } # endif else if ( gvarp == & p_mps ) { # ifdef FEAT_MBYTE if ( has_mbyte ) { for ( p = * varp ; * p != NUL ; ++ p ) { int x2 = - 1 ; int x3 = - 1 ; if ( * p != NUL ) p += mb_ptr2len ( p ) ; if ( * p != NUL ) x2 = * p ++ ; if ( * p != NUL ) { x3 = mb_ptr2char ( p ) ; p += mb_ptr2len ( p ) ; } if ( x2 != ':' || x3 == - 1 || ( * p != NUL && * p != ',' ) ) { errmsg = e_invarg ; break ; } if ( * p == NUL ) break ; } } else # endif { for ( p = * varp ; * p != NUL ; p += 4 ) { if ( p [ 1 ] != ':' || p [ 2 ] == NUL || ( p [ 3 ] != NUL && p [ 3 ] != ',' ) ) { errmsg = e_invarg ; break ; } if ( p [ 3 ] == NUL ) break ; } } } # ifdef FEAT_COMMENTS else if ( gvarp == & p_com ) { for ( s = * varp ; * s ; ) { while ( * s && * s != ':' ) { if ( vim_strchr ( ( char_u * ) COM_ALL , * s ) == NULL && ! VIM_ISDIGIT ( * s ) && * s != '-' ) { errmsg = illegal_char ( errbuf , * s ) ; break ; } ++ s ; } if ( * s ++ == NUL ) errmsg = ( char_u * ) N_ ( ""E524:<S2SV_blank>Missing<S2SV_blank>colon"" ) ; else if ( * s == ',' || * s == NUL ) errmsg = ( char_u * ) N_ ( ""E525:<S2SV_blank>Zero<S2SV_blank>length<S2SV_blank>string"" ) ; if ( errmsg != NULL ) break ; while ( * s && * s != ',' ) { if ( * s == '\\\\' && s [ 1 ] != NUL ) ++ s ; ++ s ; } s = skip_to_option_part ( s ) ; } } # endif else if ( varp == & p_lcs ) { errmsg = set_chars_option ( varp ) ; } # if defined ( FEAT_WINDOWS ) || defined ( FEAT_FOLDING ) else if ( varp == & p_fcs ) { errmsg = set_chars_option ( varp ) ; } # endif # ifdef FEAT_CMDWIN else if ( varp == & p_cedit ) { errmsg = check_cedit ( ) ; } # endif else if ( varp == & p_vfile ) { verbose_stop ( ) ; if ( * p_vfile != NUL && verbose_open ( ) == FAIL ) errmsg = e_invarg ; } # ifdef FEAT_VIMINFO else if ( varp == & p_viminfo ) { for ( s = p_viminfo ; * s ; ) { if ( vim_strchr ( ( char_u * ) ""!\\""%\'/:<@cfhnrs"" , * s ) == NULL ) { errmsg = illegal_char ( errbuf , * s ) ; break ; } if ( * s == 'n' ) { break ; } else if ( * s == 'r' ) { while ( * ++ s && * s != ',' ) ; } else if ( * s == '%' ) { while ( vim_isdigit ( * ++ s ) ) ; } else if ( * s == '!' || * s == 'h' || * s == 'c' ) ++ s ; else { while ( vim_isdigit ( * ++ s ) ) ; if ( ! VIM_ISDIGIT ( * ( s - 1 ) ) ) { if ( errbuf != NULL ) { sprintf ( ( char * ) errbuf , _ ( ""E526:<S2SV_blank>Missing<S2SV_blank>number<S2SV_blank>after<S2SV_blank><%s>"" ) , transchar_byte ( * ( s - 1 ) ) ) ; errmsg = errbuf ; } else errmsg = ( char_u * ) """" ; break ; } } if ( * s == ',' ) ++ s ; else if ( * s ) { if ( errbuf != NULL ) errmsg = ( char_u * ) N_ ( ""E527:<S2SV_blank>Missing<S2SV_blank>comma"" ) ; else errmsg = ( char_u * ) """" ; break ; } } if ( * p_viminfo && errmsg == NULL && get_viminfo_parameter ( '\\'' ) < 0 ) errmsg = ( char_u * ) N_ ( ""E528:<S2SV_blank>Must<S2SV_blank>specify<S2SV_blank>a<S2SV_blank>\'<S2SV_blank>value"" ) ; } # endif else if ( istermoption ( & options [ opt_idx ] ) && full_screen ) { if ( varp == & T_CCO ) { int colors = atoi ( ( char * ) T_CCO ) ; if ( colors != t_colors ) { t_colors = colors ; if ( t_colors <= 1 ) { if ( new_value_alloced ) vim_free ( T_CCO ) ; T_CCO = empty_option ; } init_highlight ( TRUE , FALSE ) ; } } ttest ( FALSE ) ; if ( varp == & T_ME ) { out_str ( T_ME ) ; redraw_later ( CLEAR ) ; # if defined ( WIN3264 ) && ! defined ( FEAT_GUI_W32 ) mch_set_normal_colors ( ) ; # endif } } # ifdef FEAT_LINEBREAK else if ( varp == & p_sbr ) { for ( s = p_sbr ; * s ; ) { if ( ptr2cells ( s ) != 1 ) errmsg = ( char_u * ) N_ ( ""E595:<S2SV_blank>contains<S2SV_blank>unprintable<S2SV_blank>or<S2SV_blank>wide<S2SV_blank>character"" ) ; mb_ptr_adv ( s ) ; } } # endif # ifdef FEAT_GUI else if ( varp == & p_guifont ) { if ( gui . in_use ) { p = p_guifont ; # if defined ( FEAT_GUI_GTK ) if ( STRCMP ( p , ""*"" ) == 0 ) { p = gui_mch_font_dialog ( oldval ) ; if ( new_value_alloced ) free_string_option ( p_guifont ) ; p_guifont = ( p != NULL ) ? p : vim_strsave ( oldval ) ; new_value_alloced = TRUE ; } # endif if ( p != NULL && gui_init_font ( p_guifont , FALSE ) != OK ) { # if defined ( FEAT_GUI_MSWIN ) || defined ( FEAT_GUI_PHOTON ) if ( STRCMP ( p_guifont , ""*"" ) == 0 ) { if ( new_value_alloced ) free_string_option ( p_guifont ) ; p_guifont = vim_strsave ( oldval ) ; new_value_alloced = TRUE ; } else # endif errmsg = ( char_u * ) N_ ( ""E596:<S2SV_blank>Invalid<S2SV_blank>font(s)"" ) ; } } redraw_gui_only = TRUE ; } # ifdef FEAT_XFONTSET else if ( varp == & p_guifontset ) { if ( STRCMP ( p_guifontset , ""*"" ) == 0 ) errmsg = ( char_u * ) N_ ( ""E597:<S2SV_blank>can\'t<S2SV_blank>select<S2SV_blank>fontset"" ) ; else if ( gui . in_use && gui_init_font ( p_guifontset , TRUE ) != OK ) errmsg = ( char_u * ) N_ ( ""E598:<S2SV_blank>Invalid<S2SV_blank>fontset"" ) ; redraw_gui_only = TRUE ; } # endif # ifdef FEAT_MBYTE else if ( varp == & p_guifontwide ) { if ( STRCMP ( p_guifontwide , ""*"" ) == 0 ) errmsg = ( char_u * ) N_ ( ""E533:<S2SV_blank>can\'t<S2SV_blank>select<S2SV_blank>wide<S2SV_blank>font"" ) ; else if ( gui_get_wide_font ( ) == FAIL ) errmsg = ( char_u * ) N_ ( ""E534:<S2SV_blank>Invalid<S2SV_blank>wide<S2SV_blank>font"" ) ; redraw_gui_only = TRUE ; } # endif # endif # ifdef CURSOR_SHAPE else if ( varp == & p_guicursor ) errmsg = parse_shape_opt ( SHAPE_CURSOR ) ; # endif # ifdef FEAT_MOUSESHAPE else if ( varp == & p_mouseshape ) { errmsg = parse_shape_opt ( SHAPE_MOUSE ) ; update_mouseshape ( - 1 ) ; } # endif # ifdef FEAT_PRINTER else if ( varp == & p_popt ) errmsg = parse_printoptions ( ) ; # if defined ( FEAT_MBYTE ) && defined ( FEAT_POSTSCRIPT ) else if ( varp == & p_pmfn ) errmsg = parse_printmbfont ( ) ; # endif # endif # ifdef FEAT_LANGMAP else if ( varp == & p_langmap ) langmap_set ( ) ; # endif # ifdef FEAT_LINEBREAK else if ( varp == & p_breakat ) fill_breakat_flags ( ) ; # endif # ifdef FEAT_TITLE else if ( varp == & p_titlestring || varp == & p_iconstring ) { # ifdef FEAT_STL_OPT int flagval = ( varp == & p_titlestring ) ? STL_IN_TITLE : STL_IN_ICON ; if ( vim_strchr ( * varp , '%' ) && check_stl_option ( * varp ) == NULL ) stl_syntax |= flagval ; else stl_syntax &= ~ flagval ; # endif did_set_title ( varp == & p_iconstring ) ; } # endif # ifdef FEAT_GUI else if ( varp == & p_go ) { gui_init_which_components ( oldval ) ; redraw_gui_only = TRUE ; } # endif # if defined ( FEAT_GUI_TABLINE ) else if ( varp == & p_gtl ) { redraw_tabline = TRUE ; redraw_gui_only = TRUE ; } else if ( varp == & p_gtt ) { redraw_gui_only = TRUE ; } # endif # if defined ( FEAT_MOUSE_TTY ) && ( defined ( UNIX ) || defined ( VMS ) ) else if ( varp == & p_ttym ) { mch_setmouse ( FALSE ) ; if ( opt_strings_flags ( p_ttym , p_ttym_values , & ttym_flags , FALSE ) != OK ) errmsg = e_invarg ; else check_mouse_termcode ( ) ; if ( termcap_active ) setmouse ( ) ; } # endif else if ( varp == & p_sel ) { if ( * p_sel == NUL || check_opt_strings ( p_sel , p_sel_values , FALSE ) != OK ) errmsg = e_invarg ; } else if ( varp == & p_slm ) { if ( check_opt_strings ( p_slm , p_slm_values , TRUE ) != OK ) errmsg = e_invarg ; } # ifdef FEAT_BROWSE else if ( varp == & p_bsdir ) { if ( check_opt_strings ( p_bsdir , p_bsdir_values , FALSE ) != OK && ! mch_isdir ( p_bsdir ) ) errmsg = e_invarg ; } # endif else if ( varp == & p_km ) { if ( check_opt_strings ( p_km , p_km_values , TRUE ) != OK ) errmsg = e_invarg ; else { km_stopsel = ( vim_strchr ( p_km , 'o' ) != NULL ) ; km_startsel = ( vim_strchr ( p_km , 'a' ) != NULL ) ; } } else if ( varp == & p_mousem ) { if ( check_opt_strings ( p_mousem , p_mousem_values , FALSE ) != OK ) errmsg = e_invarg ; # if defined ( FEAT_GUI_MOTIF ) && defined ( FEAT_MENU ) && ( XmVersion <= 1002 ) else if ( * p_mousem != * oldval ) gui_motif_update_mousemodel ( root_menu ) ; # endif } else if ( varp == & p_swb ) { if ( opt_strings_flags ( p_swb , p_swb_values , & swb_flags , TRUE ) != OK ) errmsg = e_invarg ; } else if ( varp == & p_debug ) { if ( check_opt_strings ( p_debug , p_debug_values , TRUE ) != OK ) errmsg = e_invarg ; } else if ( varp == & p_dy ) { if ( opt_strings_flags ( p_dy , p_dy_values , & dy_flags , TRUE ) != OK ) errmsg = e_invarg ; else ( void ) init_chartab ( ) ; } # ifdef FEAT_WINDOWS else if ( varp == & p_ead ) { if ( check_opt_strings ( p_ead , p_ead_values , FALSE ) != OK ) errmsg = e_invarg ; } # endif # ifdef FEAT_CLIPBOARD else if ( varp == & p_cb ) errmsg = check_clipboard_option ( ) ; # endif # ifdef FEAT_SPELL else if ( varp == & ( curwin -> w_s -> b_p_spl ) || varp == & ( curwin -> w_s -> b_p_spf ) ) { errmsg = did_set_spell_option ( varp == & ( curwin -> w_s -> b_p_spf ) ) ; } else if ( varp == & ( curwin -> w_s -> b_p_spc ) ) { errmsg = compile_cap_prog ( curwin -> w_s ) ; } else if ( varp == & p_sps ) { if ( spell_check_sps ( ) != OK ) errmsg = e_invarg ; } else if ( varp == & p_msm ) { if ( spell_check_msm ( ) != OK ) errmsg = e_invarg ; } # endif # ifdef FEAT_QUICKFIX else if ( gvarp == & p_bh ) { if ( check_opt_strings ( curbuf -> b_p_bh , p_bufhidden_values , FALSE ) != OK ) errmsg = e_invarg ; } else if ( gvarp == & p_bt ) { if ( check_opt_strings ( curbuf -> b_p_bt , p_buftype_values , FALSE ) != OK ) errmsg = e_invarg ; else { # ifdef FEAT_WINDOWS if ( curwin -> w_status_height ) { curwin -> w_redr_status = TRUE ; redraw_later ( VALID ) ; } # endif curbuf -> b_help = ( curbuf -> b_p_bt [ 0 ] == 'h' ) ; # ifdef FEAT_TITLE redraw_titles ( ) ; # endif } } # endif # ifdef FEAT_STL_OPT else if ( gvarp == & p_stl || varp == & p_ruf ) { int wid ; if ( varp == & p_ruf ) ru_wid = 0 ; s = * varp ; if ( varp == & p_ruf && * s == '%' ) { if ( * ++ s == '-' ) s ++ ; wid = getdigits ( & s ) ; if ( wid && * s == '(' && ( errmsg = check_stl_option ( p_ruf ) ) == NULL ) ru_wid = wid ; else errmsg = check_stl_option ( p_ruf ) ; } else if ( varp == & p_ruf || s [ 0 ] != '%' || s [ 1 ] != '!' ) errmsg = check_stl_option ( s ) ; if ( varp == & p_ruf && errmsg == NULL ) comp_col ( ) ; } # endif # ifdef FEAT_INS_EXPAND else if ( gvarp == & p_cpt ) { for ( s = * varp ; * s ; ) { while ( * s == ',' || * s == '<S2SV_blank>' ) s ++ ; if ( ! * s ) break ; if ( vim_strchr ( ( char_u * ) "".wbuksid]tU"" , * s ) == NULL ) { errmsg = illegal_char ( errbuf , * s ) ; break ; } if ( * ++ s != NUL && * s != ',' && * s != '<S2SV_blank>' ) { if ( s [ - 1 ] == 'k' || s [ - 1 ] == 's' ) { while ( * s && * s != ',' && * s != '<S2SV_blank>' ) { if ( * s == '\\\\' ) ++ s ; ++ s ; } } else { if ( errbuf != NULL ) { sprintf ( ( char * ) errbuf , _ ( ""E535:<S2SV_blank>Illegal<S2SV_blank>character<S2SV_blank>after<S2SV_blank><%c>"" ) , * -- s ) ; errmsg = errbuf ; } else errmsg = ( char_u * ) """" ; break ; } } } } else if ( varp == & p_cot ) { if ( check_opt_strings ( p_cot , p_cot_values , TRUE ) != OK ) errmsg = e_invarg ; else completeopt_was_set ( ) ; } # endif # ifdef FEAT_SIGNS else if ( varp == & curwin -> w_p_scl ) { if ( check_opt_strings ( * varp , p_scl_values , FALSE ) != OK ) errmsg = e_invarg ; } # endif # if defined ( FEAT_TOOLBAR ) && ! defined ( FEAT_GUI_W32 ) else if ( varp == & p_toolbar ) { if ( opt_strings_flags ( p_toolbar , p_toolbar_values , & toolbar_flags , TRUE ) != OK ) errmsg = e_invarg ; else { out_flush ( ) ; gui_mch_show_toolbar ( ( toolbar_flags & ( TOOLBAR_TEXT | TOOLBAR_ICONS ) ) != 0 ) ; } } # endif # if defined ( FEAT_TOOLBAR ) && defined ( FEAT_GUI_GTK ) else if ( varp == & p_tbis ) { if ( opt_strings_flags ( p_tbis , p_tbis_values , & tbis_flags , FALSE ) != OK ) errmsg = e_invarg ; else { out_flush ( ) ; gui_mch_show_toolbar ( ( toolbar_flags & ( TOOLBAR_TEXT | TOOLBAR_ICONS ) ) != 0 ) ; } } # endif else if ( varp == & p_pt ) { if ( * p_pt ) { ( void ) replace_termcodes ( p_pt , & p , TRUE , TRUE , FALSE ) ; if ( p != NULL ) { if ( new_value_alloced ) free_string_option ( p_pt ) ; p_pt = p ; new_value_alloced = TRUE ; } } } else if ( varp == & p_bs ) { if ( VIM_ISDIGIT ( * p_bs ) ) { if ( * p_bs > '2' || p_bs [ 1 ] != NUL ) errmsg = e_invarg ; } else if ( check_opt_strings ( p_bs , p_bs_values , TRUE ) != OK ) errmsg = e_invarg ; } else if ( varp == & p_bo ) { if ( opt_strings_flags ( p_bo , p_bo_values , & bo_flags , TRUE ) != OK ) errmsg = e_invarg ; } else if ( gvarp == & p_tc ) { unsigned int * flags ; if ( opt_flags & OPT_LOCAL ) { p = curbuf -> b_p_tc ; flags = & curbuf -> b_tc_flags ; } else { p = p_tc ; flags = & tc_flags ; } if ( ( opt_flags & OPT_LOCAL ) && * p == NUL ) * flags = 0 ; else if ( * p == NUL || opt_strings_flags ( p , p_tc_values , flags , FALSE ) != OK ) errmsg = e_invarg ; } # ifdef FEAT_MBYTE else if ( varp == & p_cmp ) { if ( opt_strings_flags ( p_cmp , p_cmp_values , & cmp_flags , TRUE ) != OK ) errmsg = e_invarg ; } # endif # ifdef FEAT_DIFF else if ( varp == & p_dip ) { if ( diffopt_changed ( ) == FAIL ) errmsg = e_invarg ; } # endif # ifdef FEAT_FOLDING else if ( gvarp == & curwin -> w_allbuf_opt . wo_fdm ) { if ( check_opt_strings ( * varp , p_fdm_values , FALSE ) != OK || * curwin -> w_p_fdm == NUL ) errmsg = e_invarg ; else { foldUpdateAll ( curwin ) ; if ( foldmethodIsDiff ( curwin ) ) newFoldLevel ( ) ; } } # ifdef FEAT_EVAL else if ( varp == & curwin -> w_p_fde ) { if ( foldmethodIsExpr ( curwin ) ) foldUpdateAll ( curwin ) ; } # endif else if ( gvarp == & curwin -> w_allbuf_opt . wo_fmr ) { p = vim_strchr ( * varp , ',' ) ; if ( p == NULL ) errmsg = ( char_u * ) N_ ( ""E536:<S2SV_blank>comma<S2SV_blank>required"" ) ; else if ( p == * varp || p [ 1 ] == NUL ) errmsg = e_invarg ; else if ( foldmethodIsMarker ( curwin ) ) foldUpdateAll ( curwin ) ; } else if ( gvarp == & p_cms ) { if ( * * varp != NUL && strstr ( ( char * ) * varp , ""%s"" ) == NULL ) errmsg = ( char_u * ) N_ ( ""E537:<S2SV_blank>\'commentstring\'<S2SV_blank>must<S2SV_blank>be<S2SV_blank>empty<S2SV_blank>or<S2SV_blank>contain<S2SV_blank>%s"" ) ; } else if ( varp == & p_fdo ) { if ( opt_strings_flags ( p_fdo , p_fdo_values , & fdo_flags , TRUE ) != OK ) errmsg = e_invarg ; } else if ( varp == & p_fcl ) { if ( check_opt_strings ( p_fcl , p_fcl_values , TRUE ) != OK ) errmsg = e_invarg ; } else if ( gvarp == & curwin -> w_allbuf_opt . wo_fdi ) { if ( foldmethodIsIndent ( curwin ) ) foldUpdateAll ( curwin ) ; } # endif # ifdef FEAT_VIRTUALEDIT else if ( varp == & p_ve ) { if ( opt_strings_flags ( p_ve , p_ve_values , & ve_flags , TRUE ) != OK ) errmsg = e_invarg ; else if ( STRCMP ( p_ve , oldval ) != 0 ) { validate_virtcol ( ) ; coladvance ( curwin -> w_virtcol ) ; } } # endif # if defined ( FEAT_CSCOPE ) && defined ( FEAT_QUICKFIX ) else if ( varp == & p_csqf ) { if ( p_csqf != NULL ) { p = p_csqf ; while ( * p != NUL ) { if ( vim_strchr ( ( char_u * ) CSQF_CMDS , * p ) == NULL || p [ 1 ] == NUL || vim_strchr ( ( char_u * ) CSQF_FLAGS , p [ 1 ] ) == NULL || ( p [ 2 ] != NUL && p [ 2 ] != ',' ) ) { errmsg = e_invarg ; break ; } else if ( p [ 2 ] == NUL ) break ; else p += 3 ; } } } # endif # ifdef FEAT_CINDENT else if ( gvarp == & p_cino ) { parse_cino ( curbuf ) ; } # endif # if defined ( FEAT_RENDER_OPTIONS ) else if ( varp == & p_rop && gui . in_use ) {  if ( ! gui_mch_set_rendering_options ( p_rop ) )  errmsg = e_invarg ; } # endif else { p = NULL ; if ( varp == & p_ww ) p = ( char_u * ) WW_ALL ; if ( varp == & p_shm ) p = ( char_u * ) SHM_ALL ; else if ( varp == & ( p_cpo ) ) p = ( char_u * ) CPO_ALL ; else if ( varp == & ( curbuf -> b_p_fo ) ) p = ( char_u * ) FO_ALL ; # ifdef FEAT_CONCEAL else if ( varp == & curwin -> w_p_cocu ) p = ( char_u * ) COCU_ALL ; # endif else if ( varp == & p_mouse ) { # ifdef FEAT_MOUSE p = ( char_u * ) MOUSE_ALL ; # else if ( * p_mouse != NUL ) errmsg = ( char_u * ) N_ ( ""E538:<S2SV_blank>No<S2SV_blank>mouse<S2SV_blank>support"" ) ; # endif } # if defined ( FEAT_GUI ) else if ( varp == & p_go ) p = ( char_u * ) GO_ALL ; # endif if ( p != NULL ) { for ( s = * varp ; * s ; ++ s ) if ( vim_strchr ( p , * s ) == NULL ) { errmsg = illegal_char ( errbuf , * s ) ; break ; } } } if ( errmsg != NULL ) { if ( new_value_alloced ) free_string_option ( * varp ) ; * varp = oldval ; if ( did_chartab ) ( void ) init_chartab ( ) ; if ( varp == & p_hl ) ( void ) highlight_changed ( ) ; } else { # ifdef FEAT_EVAL set_option_scriptID_idx ( opt_idx , opt_flags , current_SID ) ; # endif if ( free_oldval ) free_string_option ( oldval ) ; if ( new_value_alloced ) options [ opt_idx ] . flags |= P_ALLOCED ; else options [ opt_idx ] . flags &= ~ P_ALLOCED ; if ( ( opt_flags & ( OPT_LOCAL | OPT_GLOBAL ) ) == 0 && ( ( int ) options [ opt_idx ] . indir & PV_BOTH ) ) { p = get_varp_scope ( & ( options [ opt_idx ] ) , OPT_LOCAL ) ; free_string_option ( * ( char_u * * ) p ) ; * ( char_u * * ) p = empty_option ; } else if ( ! ( opt_flags & OPT_LOCAL ) && opt_flags != OPT_GLOBAL ) set_string_option_global ( opt_idx , varp ) ; # ifdef FEAT_AUTOCMD # ifdef FEAT_SYN_HL if ( varp == & ( curbuf -> b_p_syn ) ) { apply_autocmds ( EVENT_SYNTAX , curbuf -> b_p_syn , curbuf -> b_fname , TRUE , curbuf ) ; } # endif else if ( varp == & ( curbuf -> b_p_ft ) ) { did_filetype = TRUE ; apply_autocmds ( EVENT_FILETYPE , curbuf -> b_p_ft , curbuf -> b_fname , TRUE , curbuf ) ; } # endif # ifdef FEAT_SPELL if ( varp == & ( curwin -> w_s -> b_p_spl ) ) { char_u fname [ 200 ] ; char_u * q = curwin -> w_s -> b_p_spl ; if ( STRNCMP ( q , ""cjk,"" , 4 ) == 0 ) q += 4 ; for ( p = q ; * p != NUL ; ++ p ) if ( vim_strchr ( ( char_u * ) ""_.,"" , * p ) != NULL ) break ; vim_snprintf ( ( char * ) fname , 200 , ""spell/%.*s.vim"" , ( int ) ( p - q ) , q ) ; source_runtime ( fname , DIP_ALL ) ; } # endif } # ifdef FEAT_MOUSE if ( varp == & p_mouse ) { # ifdef FEAT_MOUSE_TTY if ( * p_mouse == NUL ) mch_setmouse ( FALSE ) ; else # endif setmouse ( ) ; } # endif if ( curwin -> w_curswant != MAXCOL && ( options [ opt_idx ] . flags & ( P_CURSWANT | P_RALL ) ) != 0 ) curwin -> w_set_curswant = TRUE ; # ifdef FEAT_GUI if ( ! redraw_gui_only || gui . in_use ) # endif check_redraw ( options [ opt_idx ] . flags ) ; return errmsg ; }",# endif # ifdef FEAT_KEYMAP else if ( varp == & curbuf -> b_p_keymap ) {if ( ! valid_filetype ( * varp ) ) errmsg = e_invarg ;else errmsg = keymap_init ( ) ;,115
162,"buggy line: if ( ! gui_mch_set_rendering_options ( p_rop ) )  errmsg = e_invarg ;cwe id:CWE-20context: static char_u * did_set_string_option ( int opt_idx , char_u * * varp , int new_value_alloced , char_u * oldval , char_u * errbuf , int opt_flags ) { char_u * errmsg = NULL ; char_u * s , * p ; int did_chartab = FALSE ; char_u * * gvarp ; long_u free_oldval = ( options [ opt_idx ] . flags & P_ALLOCED ) ; # ifdef FEAT_GUI int redraw_gui_only = FALSE ; # endif gvarp = ( char_u * * ) get_varp_scope ( & ( options [ opt_idx ] ) , OPT_GLOBAL ) ; if ( ( secure # ifdef HAVE_SANDBOX || sandbox != 0 # endif ) && ( options [ opt_idx ] . flags & P_SECURE ) ) { errmsg = e_secure ; } else if ( ( options [ opt_idx ] . flags & P_NFNAME ) && vim_strpbrk ( * varp , ( char_u * ) ""/\\\\*?[|<>"" ) != NULL ) { errmsg = e_invarg ; } else if ( varp == & T_NAME ) { if ( T_NAME [ 0 ] == NUL ) errmsg = ( char_u * ) N_ ( ""E529:<S2SV_blank>Cannot<S2SV_blank>set<S2SV_blank>\'term\'<S2SV_blank>to<S2SV_blank>empty<S2SV_blank>string"" ) ; # ifdef FEAT_GUI if ( gui . in_use ) errmsg = ( char_u * ) N_ ( ""E530:<S2SV_blank>Cannot<S2SV_blank>change<S2SV_blank>term<S2SV_blank>in<S2SV_blank>GUI"" ) ; else if ( term_is_gui ( T_NAME ) ) errmsg = ( char_u * ) N_ ( ""E531:<S2SV_blank>Use<S2SV_blank>\\"":gui\\""<S2SV_blank>to<S2SV_blank>start<S2SV_blank>the<S2SV_blank>GUI"" ) ; # endif else if ( set_termname ( T_NAME ) == FAIL ) errmsg = ( char_u * ) N_ ( ""E522:<S2SV_blank>Not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>termcap"" ) ; else redraw_later_clear ( ) ; } else if ( gvarp == & p_bkc ) { char_u * bkc = p_bkc ; unsigned int * flags = & bkc_flags ; if ( opt_flags & OPT_LOCAL ) { bkc = curbuf -> b_p_bkc ; flags = & curbuf -> b_bkc_flags ; } if ( ( opt_flags & OPT_LOCAL ) && * bkc == NUL ) * flags = 0 ; else { if ( opt_strings_flags ( bkc , p_bkc_values , flags , TRUE ) != OK ) errmsg = e_invarg ; if ( ( ( ( int ) * flags & BKC_AUTO ) != 0 ) + ( ( ( int ) * flags & BKC_YES ) != 0 ) + ( ( ( int ) * flags & BKC_NO ) != 0 ) != 1 ) { ( void ) opt_strings_flags ( oldval , p_bkc_values , flags , TRUE ) ; errmsg = e_invarg ; } } } else if ( varp == & p_bex || varp == & p_pm ) { if ( STRCMP ( * p_bex == '.' ? p_bex + 1 : p_bex , * p_pm == '.' ? p_pm + 1 : p_pm ) == 0 ) errmsg = ( char_u * ) N_ ( ""E589:<S2SV_blank>\'backupext\'<S2SV_blank>and<S2SV_blank>\'patchmode\'<S2SV_blank>are<S2SV_blank>equal"" ) ; } # ifdef FEAT_LINEBREAK else if ( varp == & curwin -> w_p_briopt ) { if ( briopt_check ( curwin ) == FAIL ) errmsg = e_invarg ; } # endif else if ( varp == & p_isi || varp == & ( curbuf -> b_p_isk ) || varp == & p_isp || varp == & p_isf ) { if ( init_chartab ( ) == FAIL ) { did_chartab = TRUE ; errmsg = e_invarg ; } } else if ( varp == & p_hf ) { if ( didset_vim ) { vim_setenv ( ( char_u * ) ""VIM"" , ( char_u * ) """" ) ; didset_vim = FALSE ; } if ( didset_vimruntime ) { vim_setenv ( ( char_u * ) ""VIMRUNTIME"" , ( char_u * ) """" ) ; didset_vimruntime = FALSE ; } } # ifdef FEAT_SYN_HL else if ( varp == & curwin -> w_p_cc ) errmsg = check_colorcolumn ( curwin ) ; # endif # ifdef FEAT_MULTI_LANG else if ( varp == & p_hlg ) { for ( s = p_hlg ; * s != NUL ; s += 3 ) { if ( s [ 1 ] == NUL || ( ( s [ 2 ] != ',' || s [ 3 ] == NUL ) && s [ 2 ] != NUL ) ) { errmsg = e_invarg ; break ; } if ( s [ 2 ] == NUL ) break ; } } # endif else if ( varp == & p_hl ) { if ( highlight_changed ( ) == FAIL ) errmsg = e_invarg ; } else if ( gvarp == & p_nf ) { if ( check_opt_strings ( * varp , p_nf_values , TRUE ) != OK ) errmsg = e_invarg ; } # ifdef FEAT_SESSION else if ( varp == & p_ssop ) { if ( opt_strings_flags ( p_ssop , p_ssop_values , & ssop_flags , TRUE ) != OK ) errmsg = e_invarg ; if ( ( ssop_flags & SSOP_CURDIR ) && ( ssop_flags & SSOP_SESDIR ) ) { ( void ) opt_strings_flags ( oldval , p_ssop_values , & ssop_flags , TRUE ) ; errmsg = e_invarg ; } } else if ( varp == & p_vop ) { if ( opt_strings_flags ( p_vop , p_ssop_values , & vop_flags , TRUE ) != OK ) errmsg = e_invarg ; } # endif # ifdef FEAT_SCROLLBIND else if ( varp == & p_sbo ) { if ( check_opt_strings ( p_sbo , p_scbopt_values , TRUE ) != OK ) errmsg = e_invarg ; } # endif # ifdef FEAT_MBYTE else if ( varp == & p_ambw || varp == & p_emoji ) { if ( check_opt_strings ( p_ambw , p_ambw_values , FALSE ) != OK ) errmsg = e_invarg ; else if ( set_chars_option ( & p_lcs ) != NULL ) errmsg = ( char_u * ) _ ( ""E834:<S2SV_blank>Conflicts<S2SV_blank>with<S2SV_blank>value<S2SV_blank>of<S2SV_blank>\'listchars\'"" ) ; # if defined ( FEAT_WINDOWS ) || defined ( FEAT_FOLDING ) else if ( set_chars_option ( & p_fcs ) != NULL ) errmsg = ( char_u * ) _ ( ""E835:<S2SV_blank>Conflicts<S2SV_blank>with<S2SV_blank>value<S2SV_blank>of<S2SV_blank>\'fillchars\'"" ) ; # endif } # endif else if ( varp == & p_bg ) { if ( check_opt_strings ( p_bg , p_bg_values , FALSE ) == OK ) { # ifdef FEAT_EVAL int dark = ( * p_bg == 'd' ) ; # endif init_highlight ( FALSE , FALSE ) ; # ifdef FEAT_EVAL if ( dark != ( * p_bg == 'd' ) && get_var_value ( ( char_u * ) ""g:colors_name"" ) != NULL ) { do_unlet ( ( char_u * ) ""g:colors_name"" , TRUE ) ; free_string_option ( p_bg ) ; p_bg = vim_strsave ( ( char_u * ) ( dark ? ""dark"" : ""light"" ) ) ; check_string_option ( & p_bg ) ; init_highlight ( FALSE , FALSE ) ; } # endif } else errmsg = e_invarg ; } else if ( varp == & p_wim ) { if ( check_opt_wim ( ) == FAIL ) errmsg = e_invarg ; } # ifdef FEAT_CMDL_COMPL else if ( varp == & p_wop ) { if ( check_opt_strings ( p_wop , p_wop_values , TRUE ) != OK ) errmsg = e_invarg ; } # endif # ifdef FEAT_WAK else if ( varp == & p_wak ) { if ( * p_wak == NUL || check_opt_strings ( p_wak , p_wak_values , FALSE ) != OK ) errmsg = e_invarg ; # ifdef FEAT_MENU # ifdef FEAT_GUI_MOTIF else if ( gui . in_use ) gui_motif_set_mnemonics ( p_wak [ 0 ] == 'y' || p_wak [ 0 ] == 'm' ) ; # else # ifdef FEAT_GUI_GTK else if ( gui . in_use ) gui_gtk_set_mnemonics ( p_wak [ 0 ] == 'y' || p_wak [ 0 ] == 'm' ) ; # endif # endif # endif } # endif # ifdef FEAT_AUTOCMD else if ( varp == & p_ei ) { if ( check_ei ( ) == FAIL ) errmsg = e_invarg ; } # endif # ifdef FEAT_MBYTE else if ( varp == & p_enc || gvarp == & p_fenc || varp == & p_tenc ) { if ( gvarp == & p_fenc ) { if ( ! curbuf -> b_p_ma && opt_flags != OPT_GLOBAL ) errmsg = e_modifiable ; else if ( vim_strchr ( * varp , ',' ) != NULL ) errmsg = e_invarg ; else { # ifdef FEAT_TITLE redraw_titles ( ) ; # endif ml_setflags ( curbuf ) ; } } if ( errmsg == NULL ) { p = enc_canonize ( * varp ) ; if ( p != NULL ) { vim_free ( * varp ) ; * varp = p ; } if ( varp == & p_enc ) { errmsg = mb_init ( ) ; # ifdef FEAT_TITLE redraw_titles ( ) ; # endif } } # if defined ( FEAT_GUI_GTK ) if ( errmsg == NULL && varp == & p_tenc && gui . in_use ) { if ( STRCMP ( p_tenc , ""utf-8"" ) != 0 ) errmsg = ( char_u * ) N_ ( ""E617:<S2SV_blank>Cannot<S2SV_blank>be<S2SV_blank>changed<S2SV_blank>in<S2SV_blank>the<S2SV_blank>GTK+<S2SV_blank>2<S2SV_blank>GUI"" ) ; } # endif if ( errmsg == NULL ) { # ifdef FEAT_KEYMAP if ( varp == & p_enc && * curbuf -> b_p_keymap != NUL ) ( void ) keymap_init ( ) ; # endif if ( ( ( varp == & p_enc && * p_tenc != NUL ) || varp == & p_tenc ) ) { convert_setup ( & input_conv , p_tenc , p_enc ) ; convert_setup ( & output_conv , p_enc , p_tenc ) ; } # if defined ( WIN3264 ) && defined ( FEAT_MBYTE ) if ( varp == & p_enc ) init_homedir ( ) ; # endif } } # endif # if defined ( FEAT_POSTSCRIPT ) else if ( varp == & p_penc ) { p = enc_canonize ( p_penc ) ; if ( p != NULL ) { vim_free ( p_penc ) ; p_penc = p ; } else { for ( s = p_penc ; * s != NUL ; s ++ ) { if ( * s == '_' ) * s = '-' ; else * s = TOLOWER_ASC ( * s ) ; } } } # endif # if defined ( FEAT_XIM ) && defined ( FEAT_GUI_GTK ) else if ( varp == & p_imak ) { if ( gui . in_use && ! im_xim_isvalid_imactivate ( ) ) errmsg = e_invarg ; } # endif # ifdef FEAT_KEYMAP else if ( varp == & curbuf -> b_p_keymap )  {  errmsg = keymap_init ( ) ; if ( errmsg == NULL ) { if ( * curbuf -> b_p_keymap != NUL ) { curbuf -> b_p_iminsert = B_IMODE_LMAP ; if ( curbuf -> b_p_imsearch != B_IMODE_USE_INSERT ) curbuf -> b_p_imsearch = B_IMODE_LMAP ; } else { if ( curbuf -> b_p_iminsert == B_IMODE_LMAP ) curbuf -> b_p_iminsert = B_IMODE_NONE ; if ( curbuf -> b_p_imsearch == B_IMODE_LMAP ) curbuf -> b_p_imsearch = B_IMODE_USE_INSERT ; } if ( ( opt_flags & OPT_LOCAL ) == 0 ) { set_iminsert_global ( ) ; set_imsearch_global ( ) ; } # ifdef FEAT_WINDOWS status_redraw_curbuf ( ) ; # endif } } # endif else if ( gvarp == & p_ff ) { if ( ! curbuf -> b_p_ma && ! ( opt_flags & OPT_GLOBAL ) ) errmsg = e_modifiable ; else if ( check_opt_strings ( * varp , p_ff_values , FALSE ) != OK ) errmsg = e_invarg ; else { if ( get_fileformat ( curbuf ) == EOL_DOS ) curbuf -> b_p_tx = TRUE ; else curbuf -> b_p_tx = FALSE ; # ifdef FEAT_TITLE redraw_titles ( ) ; # endif ml_setflags ( curbuf ) ; if ( get_fileformat ( curbuf ) == EOL_MAC || * oldval == 'm' ) redraw_curbuf_later ( NOT_VALID ) ; } } else if ( varp == & p_ffs ) { if ( check_opt_strings ( p_ffs , p_ff_values , TRUE ) != OK ) errmsg = e_invarg ; else { if ( * p_ffs == NUL ) p_ta = FALSE ; else p_ta = TRUE ; } } # if defined ( FEAT_CRYPT ) else if ( gvarp == & p_key ) { # if defined ( FEAT_CMDHIST ) remove_key_from_history ( ) ; # endif if ( STRCMP ( curbuf -> b_p_key , oldval ) != 0 ) ml_set_crypt_key ( curbuf , oldval , * curbuf -> b_p_cm == NUL ? p_cm : curbuf -> b_p_cm ) ; } else if ( gvarp == & p_cm ) { if ( opt_flags & OPT_LOCAL ) p = curbuf -> b_p_cm ; else p = p_cm ; if ( check_opt_strings ( p , p_cm_values , TRUE ) != OK ) errmsg = e_invarg ; else if ( crypt_self_test ( ) == FAIL ) errmsg = e_invarg ; else { if ( * p_cm == NUL ) { if ( new_value_alloced ) free_string_option ( p_cm ) ; p_cm = vim_strsave ( ( char_u * ) ""zip"" ) ; new_value_alloced = TRUE ; } if ( ( opt_flags & ( OPT_LOCAL | OPT_GLOBAL ) ) == 0 ) { free_string_option ( curbuf -> b_p_cm ) ; curbuf -> b_p_cm = empty_option ; } if ( ( opt_flags & OPT_LOCAL ) && * oldval == NUL ) s = p_cm ; else s = oldval ; if ( * curbuf -> b_p_cm == NUL ) p = p_cm ; else p = curbuf -> b_p_cm ; if ( STRCMP ( s , p ) != 0 ) ml_set_crypt_key ( curbuf , curbuf -> b_p_key , s ) ; if ( ( opt_flags & OPT_GLOBAL ) && STRCMP ( p_cm , oldval ) != 0 ) { buf_T * buf ; FOR_ALL_BUFFERS ( buf ) if ( buf != curbuf && * buf -> b_p_cm == NUL ) ml_set_crypt_key ( buf , buf -> b_p_key , oldval ) ; } } } # endif else if ( gvarp == & p_mps ) { # ifdef FEAT_MBYTE if ( has_mbyte ) { for ( p = * varp ; * p != NUL ; ++ p ) { int x2 = - 1 ; int x3 = - 1 ; if ( * p != NUL ) p += mb_ptr2len ( p ) ; if ( * p != NUL ) x2 = * p ++ ; if ( * p != NUL ) { x3 = mb_ptr2char ( p ) ; p += mb_ptr2len ( p ) ; } if ( x2 != ':' || x3 == - 1 || ( * p != NUL && * p != ',' ) ) { errmsg = e_invarg ; break ; } if ( * p == NUL ) break ; } } else # endif { for ( p = * varp ; * p != NUL ; p += 4 ) { if ( p [ 1 ] != ':' || p [ 2 ] == NUL || ( p [ 3 ] != NUL && p [ 3 ] != ',' ) ) { errmsg = e_invarg ; break ; } if ( p [ 3 ] == NUL ) break ; } } } # ifdef FEAT_COMMENTS else if ( gvarp == & p_com ) { for ( s = * varp ; * s ; ) { while ( * s && * s != ':' ) { if ( vim_strchr ( ( char_u * ) COM_ALL , * s ) == NULL && ! VIM_ISDIGIT ( * s ) && * s != '-' ) { errmsg = illegal_char ( errbuf , * s ) ; break ; } ++ s ; } if ( * s ++ == NUL ) errmsg = ( char_u * ) N_ ( ""E524:<S2SV_blank>Missing<S2SV_blank>colon"" ) ; else if ( * s == ',' || * s == NUL ) errmsg = ( char_u * ) N_ ( ""E525:<S2SV_blank>Zero<S2SV_blank>length<S2SV_blank>string"" ) ; if ( errmsg != NULL ) break ; while ( * s && * s != ',' ) { if ( * s == '\\\\' && s [ 1 ] != NUL ) ++ s ; ++ s ; } s = skip_to_option_part ( s ) ; } } # endif else if ( varp == & p_lcs ) { errmsg = set_chars_option ( varp ) ; } # if defined ( FEAT_WINDOWS ) || defined ( FEAT_FOLDING ) else if ( varp == & p_fcs ) { errmsg = set_chars_option ( varp ) ; } # endif # ifdef FEAT_CMDWIN else if ( varp == & p_cedit ) { errmsg = check_cedit ( ) ; } # endif else if ( varp == & p_vfile ) { verbose_stop ( ) ; if ( * p_vfile != NUL && verbose_open ( ) == FAIL ) errmsg = e_invarg ; } # ifdef FEAT_VIMINFO else if ( varp == & p_viminfo ) { for ( s = p_viminfo ; * s ; ) { if ( vim_strchr ( ( char_u * ) ""!\\""%\'/:<@cfhnrs"" , * s ) == NULL ) { errmsg = illegal_char ( errbuf , * s ) ; break ; } if ( * s == 'n' ) { break ; } else if ( * s == 'r' ) { while ( * ++ s && * s != ',' ) ; } else if ( * s == '%' ) { while ( vim_isdigit ( * ++ s ) ) ; } else if ( * s == '!' || * s == 'h' || * s == 'c' ) ++ s ; else { while ( vim_isdigit ( * ++ s ) ) ; if ( ! VIM_ISDIGIT ( * ( s - 1 ) ) ) { if ( errbuf != NULL ) { sprintf ( ( char * ) errbuf , _ ( ""E526:<S2SV_blank>Missing<S2SV_blank>number<S2SV_blank>after<S2SV_blank><%s>"" ) , transchar_byte ( * ( s - 1 ) ) ) ; errmsg = errbuf ; } else errmsg = ( char_u * ) """" ; break ; } } if ( * s == ',' ) ++ s ; else if ( * s ) { if ( errbuf != NULL ) errmsg = ( char_u * ) N_ ( ""E527:<S2SV_blank>Missing<S2SV_blank>comma"" ) ; else errmsg = ( char_u * ) """" ; break ; } } if ( * p_viminfo && errmsg == NULL && get_viminfo_parameter ( '\\'' ) < 0 ) errmsg = ( char_u * ) N_ ( ""E528:<S2SV_blank>Must<S2SV_blank>specify<S2SV_blank>a<S2SV_blank>\'<S2SV_blank>value"" ) ; } # endif else if ( istermoption ( & options [ opt_idx ] ) && full_screen ) { if ( varp == & T_CCO ) { int colors = atoi ( ( char * ) T_CCO ) ; if ( colors != t_colors ) { t_colors = colors ; if ( t_colors <= 1 ) { if ( new_value_alloced ) vim_free ( T_CCO ) ; T_CCO = empty_option ; } init_highlight ( TRUE , FALSE ) ; } } ttest ( FALSE ) ; if ( varp == & T_ME ) { out_str ( T_ME ) ; redraw_later ( CLEAR ) ; # if defined ( WIN3264 ) && ! defined ( FEAT_GUI_W32 ) mch_set_normal_colors ( ) ; # endif } } # ifdef FEAT_LINEBREAK else if ( varp == & p_sbr ) { for ( s = p_sbr ; * s ; ) { if ( ptr2cells ( s ) != 1 ) errmsg = ( char_u * ) N_ ( ""E595:<S2SV_blank>contains<S2SV_blank>unprintable<S2SV_blank>or<S2SV_blank>wide<S2SV_blank>character"" ) ; mb_ptr_adv ( s ) ; } } # endif # ifdef FEAT_GUI else if ( varp == & p_guifont ) { if ( gui . in_use ) { p = p_guifont ; # if defined ( FEAT_GUI_GTK ) if ( STRCMP ( p , ""*"" ) == 0 ) { p = gui_mch_font_dialog ( oldval ) ; if ( new_value_alloced ) free_string_option ( p_guifont ) ; p_guifont = ( p != NULL ) ? p : vim_strsave ( oldval ) ; new_value_alloced = TRUE ; } # endif if ( p != NULL && gui_init_font ( p_guifont , FALSE ) != OK ) { # if defined ( FEAT_GUI_MSWIN ) || defined ( FEAT_GUI_PHOTON ) if ( STRCMP ( p_guifont , ""*"" ) == 0 ) { if ( new_value_alloced ) free_string_option ( p_guifont ) ; p_guifont = vim_strsave ( oldval ) ; new_value_alloced = TRUE ; } else # endif errmsg = ( char_u * ) N_ ( ""E596:<S2SV_blank>Invalid<S2SV_blank>font(s)"" ) ; } } redraw_gui_only = TRUE ; } # ifdef FEAT_XFONTSET else if ( varp == & p_guifontset ) { if ( STRCMP ( p_guifontset , ""*"" ) == 0 ) errmsg = ( char_u * ) N_ ( ""E597:<S2SV_blank>can\'t<S2SV_blank>select<S2SV_blank>fontset"" ) ; else if ( gui . in_use && gui_init_font ( p_guifontset , TRUE ) != OK ) errmsg = ( char_u * ) N_ ( ""E598:<S2SV_blank>Invalid<S2SV_blank>fontset"" ) ; redraw_gui_only = TRUE ; } # endif # ifdef FEAT_MBYTE else if ( varp == & p_guifontwide ) { if ( STRCMP ( p_guifontwide , ""*"" ) == 0 ) errmsg = ( char_u * ) N_ ( ""E533:<S2SV_blank>can\'t<S2SV_blank>select<S2SV_blank>wide<S2SV_blank>font"" ) ; else if ( gui_get_wide_font ( ) == FAIL ) errmsg = ( char_u * ) N_ ( ""E534:<S2SV_blank>Invalid<S2SV_blank>wide<S2SV_blank>font"" ) ; redraw_gui_only = TRUE ; } # endif # endif # ifdef CURSOR_SHAPE else if ( varp == & p_guicursor ) errmsg = parse_shape_opt ( SHAPE_CURSOR ) ; # endif # ifdef FEAT_MOUSESHAPE else if ( varp == & p_mouseshape ) { errmsg = parse_shape_opt ( SHAPE_MOUSE ) ; update_mouseshape ( - 1 ) ; } # endif # ifdef FEAT_PRINTER else if ( varp == & p_popt ) errmsg = parse_printoptions ( ) ; # if defined ( FEAT_MBYTE ) && defined ( FEAT_POSTSCRIPT ) else if ( varp == & p_pmfn ) errmsg = parse_printmbfont ( ) ; # endif # endif # ifdef FEAT_LANGMAP else if ( varp == & p_langmap ) langmap_set ( ) ; # endif # ifdef FEAT_LINEBREAK else if ( varp == & p_breakat ) fill_breakat_flags ( ) ; # endif # ifdef FEAT_TITLE else if ( varp == & p_titlestring || varp == & p_iconstring ) { # ifdef FEAT_STL_OPT int flagval = ( varp == & p_titlestring ) ? STL_IN_TITLE : STL_IN_ICON ; if ( vim_strchr ( * varp , '%' ) && check_stl_option ( * varp ) == NULL ) stl_syntax |= flagval ; else stl_syntax &= ~ flagval ; # endif did_set_title ( varp == & p_iconstring ) ; } # endif # ifdef FEAT_GUI else if ( varp == & p_go ) { gui_init_which_components ( oldval ) ; redraw_gui_only = TRUE ; } # endif # if defined ( FEAT_GUI_TABLINE ) else if ( varp == & p_gtl ) { redraw_tabline = TRUE ; redraw_gui_only = TRUE ; } else if ( varp == & p_gtt ) { redraw_gui_only = TRUE ; } # endif # if defined ( FEAT_MOUSE_TTY ) && ( defined ( UNIX ) || defined ( VMS ) ) else if ( varp == & p_ttym ) { mch_setmouse ( FALSE ) ; if ( opt_strings_flags ( p_ttym , p_ttym_values , & ttym_flags , FALSE ) != OK ) errmsg = e_invarg ; else check_mouse_termcode ( ) ; if ( termcap_active ) setmouse ( ) ; } # endif else if ( varp == & p_sel ) { if ( * p_sel == NUL || check_opt_strings ( p_sel , p_sel_values , FALSE ) != OK ) errmsg = e_invarg ; } else if ( varp == & p_slm ) { if ( check_opt_strings ( p_slm , p_slm_values , TRUE ) != OK ) errmsg = e_invarg ; } # ifdef FEAT_BROWSE else if ( varp == & p_bsdir ) { if ( check_opt_strings ( p_bsdir , p_bsdir_values , FALSE ) != OK && ! mch_isdir ( p_bsdir ) ) errmsg = e_invarg ; } # endif else if ( varp == & p_km ) { if ( check_opt_strings ( p_km , p_km_values , TRUE ) != OK ) errmsg = e_invarg ; else { km_stopsel = ( vim_strchr ( p_km , 'o' ) != NULL ) ; km_startsel = ( vim_strchr ( p_km , 'a' ) != NULL ) ; } } else if ( varp == & p_mousem ) { if ( check_opt_strings ( p_mousem , p_mousem_values , FALSE ) != OK ) errmsg = e_invarg ; # if defined ( FEAT_GUI_MOTIF ) && defined ( FEAT_MENU ) && ( XmVersion <= 1002 ) else if ( * p_mousem != * oldval ) gui_motif_update_mousemodel ( root_menu ) ; # endif } else if ( varp == & p_swb ) { if ( opt_strings_flags ( p_swb , p_swb_values , & swb_flags , TRUE ) != OK ) errmsg = e_invarg ; } else if ( varp == & p_debug ) { if ( check_opt_strings ( p_debug , p_debug_values , TRUE ) != OK ) errmsg = e_invarg ; } else if ( varp == & p_dy ) { if ( opt_strings_flags ( p_dy , p_dy_values , & dy_flags , TRUE ) != OK ) errmsg = e_invarg ; else ( void ) init_chartab ( ) ; } # ifdef FEAT_WINDOWS else if ( varp == & p_ead ) { if ( check_opt_strings ( p_ead , p_ead_values , FALSE ) != OK ) errmsg = e_invarg ; } # endif # ifdef FEAT_CLIPBOARD else if ( varp == & p_cb ) errmsg = check_clipboard_option ( ) ; # endif # ifdef FEAT_SPELL else if ( varp == & ( curwin -> w_s -> b_p_spl ) || varp == & ( curwin -> w_s -> b_p_spf ) ) { errmsg = did_set_spell_option ( varp == & ( curwin -> w_s -> b_p_spf ) ) ; } else if ( varp == & ( curwin -> w_s -> b_p_spc ) ) { errmsg = compile_cap_prog ( curwin -> w_s ) ; } else if ( varp == & p_sps ) { if ( spell_check_sps ( ) != OK ) errmsg = e_invarg ; } else if ( varp == & p_msm ) { if ( spell_check_msm ( ) != OK ) errmsg = e_invarg ; } # endif # ifdef FEAT_QUICKFIX else if ( gvarp == & p_bh ) { if ( check_opt_strings ( curbuf -> b_p_bh , p_bufhidden_values , FALSE ) != OK ) errmsg = e_invarg ; } else if ( gvarp == & p_bt ) { if ( check_opt_strings ( curbuf -> b_p_bt , p_buftype_values , FALSE ) != OK ) errmsg = e_invarg ; else { # ifdef FEAT_WINDOWS if ( curwin -> w_status_height ) { curwin -> w_redr_status = TRUE ; redraw_later ( VALID ) ; } # endif curbuf -> b_help = ( curbuf -> b_p_bt [ 0 ] == 'h' ) ; # ifdef FEAT_TITLE redraw_titles ( ) ; # endif } } # endif # ifdef FEAT_STL_OPT else if ( gvarp == & p_stl || varp == & p_ruf ) { int wid ; if ( varp == & p_ruf ) ru_wid = 0 ; s = * varp ; if ( varp == & p_ruf && * s == '%' ) { if ( * ++ s == '-' ) s ++ ; wid = getdigits ( & s ) ; if ( wid && * s == '(' && ( errmsg = check_stl_option ( p_ruf ) ) == NULL ) ru_wid = wid ; else errmsg = check_stl_option ( p_ruf ) ; } else if ( varp == & p_ruf || s [ 0 ] != '%' || s [ 1 ] != '!' ) errmsg = check_stl_option ( s ) ; if ( varp == & p_ruf && errmsg == NULL ) comp_col ( ) ; } # endif # ifdef FEAT_INS_EXPAND else if ( gvarp == & p_cpt ) { for ( s = * varp ; * s ; ) { while ( * s == ',' || * s == '<S2SV_blank>' ) s ++ ; if ( ! * s ) break ; if ( vim_strchr ( ( char_u * ) "".wbuksid]tU"" , * s ) == NULL ) { errmsg = illegal_char ( errbuf , * s ) ; break ; } if ( * ++ s != NUL && * s != ',' && * s != '<S2SV_blank>' ) { if ( s [ - 1 ] == 'k' || s [ - 1 ] == 's' ) { while ( * s && * s != ',' && * s != '<S2SV_blank>' ) { if ( * s == '\\\\' ) ++ s ; ++ s ; } } else { if ( errbuf != NULL ) { sprintf ( ( char * ) errbuf , _ ( ""E535:<S2SV_blank>Illegal<S2SV_blank>character<S2SV_blank>after<S2SV_blank><%c>"" ) , * -- s ) ; errmsg = errbuf ; } else errmsg = ( char_u * ) """" ; break ; } } } } else if ( varp == & p_cot ) { if ( check_opt_strings ( p_cot , p_cot_values , TRUE ) != OK ) errmsg = e_invarg ; else completeopt_was_set ( ) ; } # endif # ifdef FEAT_SIGNS else if ( varp == & curwin -> w_p_scl ) { if ( check_opt_strings ( * varp , p_scl_values , FALSE ) != OK ) errmsg = e_invarg ; } # endif # if defined ( FEAT_TOOLBAR ) && ! defined ( FEAT_GUI_W32 ) else if ( varp == & p_toolbar ) { if ( opt_strings_flags ( p_toolbar , p_toolbar_values , & toolbar_flags , TRUE ) != OK ) errmsg = e_invarg ; else { out_flush ( ) ; gui_mch_show_toolbar ( ( toolbar_flags & ( TOOLBAR_TEXT | TOOLBAR_ICONS ) ) != 0 ) ; } } # endif # if defined ( FEAT_TOOLBAR ) && defined ( FEAT_GUI_GTK ) else if ( varp == & p_tbis ) { if ( opt_strings_flags ( p_tbis , p_tbis_values , & tbis_flags , FALSE ) != OK ) errmsg = e_invarg ; else { out_flush ( ) ; gui_mch_show_toolbar ( ( toolbar_flags & ( TOOLBAR_TEXT | TOOLBAR_ICONS ) ) != 0 ) ; } } # endif else if ( varp == & p_pt ) { if ( * p_pt ) { ( void ) replace_termcodes ( p_pt , & p , TRUE , TRUE , FALSE ) ; if ( p != NULL ) { if ( new_value_alloced ) free_string_option ( p_pt ) ; p_pt = p ; new_value_alloced = TRUE ; } } } else if ( varp == & p_bs ) { if ( VIM_ISDIGIT ( * p_bs ) ) { if ( * p_bs > '2' || p_bs [ 1 ] != NUL ) errmsg = e_invarg ; } else if ( check_opt_strings ( p_bs , p_bs_values , TRUE ) != OK ) errmsg = e_invarg ; } else if ( varp == & p_bo ) { if ( opt_strings_flags ( p_bo , p_bo_values , & bo_flags , TRUE ) != OK ) errmsg = e_invarg ; } else if ( gvarp == & p_tc ) { unsigned int * flags ; if ( opt_flags & OPT_LOCAL ) { p = curbuf -> b_p_tc ; flags = & curbuf -> b_tc_flags ; } else { p = p_tc ; flags = & tc_flags ; } if ( ( opt_flags & OPT_LOCAL ) && * p == NUL ) * flags = 0 ; else if ( * p == NUL || opt_strings_flags ( p , p_tc_values , flags , FALSE ) != OK ) errmsg = e_invarg ; } # ifdef FEAT_MBYTE else if ( varp == & p_cmp ) { if ( opt_strings_flags ( p_cmp , p_cmp_values , & cmp_flags , TRUE ) != OK ) errmsg = e_invarg ; } # endif # ifdef FEAT_DIFF else if ( varp == & p_dip ) { if ( diffopt_changed ( ) == FAIL ) errmsg = e_invarg ; } # endif # ifdef FEAT_FOLDING else if ( gvarp == & curwin -> w_allbuf_opt . wo_fdm ) { if ( check_opt_strings ( * varp , p_fdm_values , FALSE ) != OK || * curwin -> w_p_fdm == NUL ) errmsg = e_invarg ; else { foldUpdateAll ( curwin ) ; if ( foldmethodIsDiff ( curwin ) ) newFoldLevel ( ) ; } } # ifdef FEAT_EVAL else if ( varp == & curwin -> w_p_fde ) { if ( foldmethodIsExpr ( curwin ) ) foldUpdateAll ( curwin ) ; } # endif else if ( gvarp == & curwin -> w_allbuf_opt . wo_fmr ) { p = vim_strchr ( * varp , ',' ) ; if ( p == NULL ) errmsg = ( char_u * ) N_ ( ""E536:<S2SV_blank>comma<S2SV_blank>required"" ) ; else if ( p == * varp || p [ 1 ] == NUL ) errmsg = e_invarg ; else if ( foldmethodIsMarker ( curwin ) ) foldUpdateAll ( curwin ) ; } else if ( gvarp == & p_cms ) { if ( * * varp != NUL && strstr ( ( char * ) * varp , ""%s"" ) == NULL ) errmsg = ( char_u * ) N_ ( ""E537:<S2SV_blank>\'commentstring\'<S2SV_blank>must<S2SV_blank>be<S2SV_blank>empty<S2SV_blank>or<S2SV_blank>contain<S2SV_blank>%s"" ) ; } else if ( varp == & p_fdo ) { if ( opt_strings_flags ( p_fdo , p_fdo_values , & fdo_flags , TRUE ) != OK ) errmsg = e_invarg ; } else if ( varp == & p_fcl ) { if ( check_opt_strings ( p_fcl , p_fcl_values , TRUE ) != OK ) errmsg = e_invarg ; } else if ( gvarp == & curwin -> w_allbuf_opt . wo_fdi ) { if ( foldmethodIsIndent ( curwin ) ) foldUpdateAll ( curwin ) ; } # endif # ifdef FEAT_VIRTUALEDIT else if ( varp == & p_ve ) { if ( opt_strings_flags ( p_ve , p_ve_values , & ve_flags , TRUE ) != OK ) errmsg = e_invarg ; else if ( STRCMP ( p_ve , oldval ) != 0 ) { validate_virtcol ( ) ; coladvance ( curwin -> w_virtcol ) ; } } # endif # if defined ( FEAT_CSCOPE ) && defined ( FEAT_QUICKFIX ) else if ( varp == & p_csqf ) { if ( p_csqf != NULL ) { p = p_csqf ; while ( * p != NUL ) { if ( vim_strchr ( ( char_u * ) CSQF_CMDS , * p ) == NULL || p [ 1 ] == NUL || vim_strchr ( ( char_u * ) CSQF_FLAGS , p [ 1 ] ) == NULL || ( p [ 2 ] != NUL && p [ 2 ] != ',' ) ) { errmsg = e_invarg ; break ; } else if ( p [ 2 ] == NUL ) break ; else p += 3 ; } } } # endif # ifdef FEAT_CINDENT else if ( gvarp == & p_cino ) { parse_cino ( curbuf ) ; } # endif # if defined ( FEAT_RENDER_OPTIONS ) else if ( varp == & p_rop && gui . in_use ) {  if ( ! gui_mch_set_rendering_options ( p_rop ) )  errmsg = e_invarg ; } # endif else { p = NULL ; if ( varp == & p_ww ) p = ( char_u * ) WW_ALL ; if ( varp == & p_shm ) p = ( char_u * ) SHM_ALL ; else if ( varp == & ( p_cpo ) ) p = ( char_u * ) CPO_ALL ; else if ( varp == & ( curbuf -> b_p_fo ) ) p = ( char_u * ) FO_ALL ; # ifdef FEAT_CONCEAL else if ( varp == & curwin -> w_p_cocu ) p = ( char_u * ) COCU_ALL ; # endif else if ( varp == & p_mouse ) { # ifdef FEAT_MOUSE p = ( char_u * ) MOUSE_ALL ; # else if ( * p_mouse != NUL ) errmsg = ( char_u * ) N_ ( ""E538:<S2SV_blank>No<S2SV_blank>mouse<S2SV_blank>support"" ) ; # endif } # if defined ( FEAT_GUI ) else if ( varp == & p_go ) p = ( char_u * ) GO_ALL ; # endif if ( p != NULL ) { for ( s = * varp ; * s ; ++ s ) if ( vim_strchr ( p , * s ) == NULL ) { errmsg = illegal_char ( errbuf , * s ) ; break ; } } } if ( errmsg != NULL ) { if ( new_value_alloced ) free_string_option ( * varp ) ; * varp = oldval ; if ( did_chartab ) ( void ) init_chartab ( ) ; if ( varp == & p_hl ) ( void ) highlight_changed ( ) ; } else { # ifdef FEAT_EVAL set_option_scriptID_idx ( opt_idx , opt_flags , current_SID ) ; # endif if ( free_oldval ) free_string_option ( oldval ) ; if ( new_value_alloced ) options [ opt_idx ] . flags |= P_ALLOCED ; else options [ opt_idx ] . flags &= ~ P_ALLOCED ; if ( ( opt_flags & ( OPT_LOCAL | OPT_GLOBAL ) ) == 0 && ( ( int ) options [ opt_idx ] . indir & PV_BOTH ) ) { p = get_varp_scope ( & ( options [ opt_idx ] ) , OPT_LOCAL ) ; free_string_option ( * ( char_u * * ) p ) ; * ( char_u * * ) p = empty_option ; } else if ( ! ( opt_flags & OPT_LOCAL ) && opt_flags != OPT_GLOBAL ) set_string_option_global ( opt_idx , varp ) ; # ifdef FEAT_AUTOCMD # ifdef FEAT_SYN_HL if ( varp == & ( curbuf -> b_p_syn ) ) { apply_autocmds ( EVENT_SYNTAX , curbuf -> b_p_syn , curbuf -> b_fname , TRUE , curbuf ) ; } # endif else if ( varp == & ( curbuf -> b_p_ft ) ) { did_filetype = TRUE ; apply_autocmds ( EVENT_FILETYPE , curbuf -> b_p_ft , curbuf -> b_fname , TRUE , curbuf ) ; } # endif # ifdef FEAT_SPELL if ( varp == & ( curwin -> w_s -> b_p_spl ) ) { char_u fname [ 200 ] ; char_u * q = curwin -> w_s -> b_p_spl ; if ( STRNCMP ( q , ""cjk,"" , 4 ) == 0 ) q += 4 ; for ( p = q ; * p != NUL ; ++ p ) if ( vim_strchr ( ( char_u * ) ""_.,"" , * p ) != NULL ) break ; vim_snprintf ( ( char * ) fname , 200 , ""spell/%.*s.vim"" , ( int ) ( p - q ) , q ) ; source_runtime ( fname , DIP_ALL ) ; } # endif } # ifdef FEAT_MOUSE if ( varp == & p_mouse ) { # ifdef FEAT_MOUSE_TTY if ( * p_mouse == NUL ) mch_setmouse ( FALSE ) ; else # endif setmouse ( ) ; } # endif if ( curwin -> w_curswant != MAXCOL && ( options [ opt_idx ] . flags & ( P_CURSWANT | P_RALL ) ) != 0 ) curwin -> w_set_curswant = TRUE ; # ifdef FEAT_GUI if ( ! redraw_gui_only || gui . in_use ) # endif check_redraw ( options [ opt_idx ] . flags ) ; return errmsg ; }",if ( ! gui_mch_set_rendering_options ( p_rop ) ) errmsg = e_invarg ;}# endif # ifdef FEAT_AUTOCMD else if ( gvarp == & p_ft ) {if ( ! valid_filetype ( * varp ) ) errmsg = e_invarg ;}# endif # ifdef FEAT_SYN_HL else if ( gvarp == & p_syn ) {if ( ! valid_filetype ( * varp ) ) errmsg = e_invarg ;,115
163,"buggy line: ret = posix_acl_equiv_mode ( acl , & new_mode ) ;if ( ret < 0 ) goto out ;if ( ret == 0 ) acl = NULL ;cwe id:CWE-285context: int ceph_set_acl ( struct inode * inode , struct posix_acl * acl , int type ) { int ret = 0 , size = 0 ; const char * name = NULL ; char * value = NULL ; struct iattr newattrs ; umode_t new_mode = inode -> i_mode , old_mode = inode -> i_mode ; switch ( type ) { case ACL_TYPE_ACCESS : name = XATTR_NAME_POSIX_ACL_ACCESS ; if ( acl ) {  ret = posix_acl_equiv_mode ( acl , & new_mode ) ;  if ( ret < 0 ) goto out ; if ( ret == 0 ) acl = NULL ; } break ; case ACL_TYPE_DEFAULT : if ( ! S_ISDIR ( inode -> i_mode ) ) { ret = acl ? - EINVAL : 0 ; goto out ; } name = XATTR_NAME_POSIX_ACL_DEFAULT ; break ; default : ret = - EINVAL ; goto out ; } if ( acl ) { size = posix_acl_xattr_size ( acl -> a_count ) ; value = kmalloc ( size , GFP_NOFS ) ; if ( ! value ) { ret = - ENOMEM ; goto out ; } ret = posix_acl_to_xattr ( & init_user_ns , acl , value , size ) ; if ( ret < 0 ) goto out_free ; } if ( new_mode != old_mode ) { newattrs . ia_mode = new_mode ; newattrs . ia_valid = ATTR_MODE ; ret = __ceph_setattr ( inode , & newattrs ) ; if ( ret ) goto out_free ; } ret = __ceph_setxattr ( inode , name , value , size , 0 ) ; if ( ret ) { if ( new_mode != old_mode ) { newattrs . ia_mode = old_mode ; newattrs . ia_valid = ATTR_MODE ; __ceph_setattr ( inode , & newattrs ) ; } goto out_free ; } ceph_set_cached_acl ( inode , type , acl ) ; out_free : kfree ( value ) ; out : return ret ; }","ret = posix_acl_update_mode ( inode , & new_mode , & acl ) ;if ( ret ) goto out ;",116
164,"buggy line: struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ;int ret , i ;cwe id:CWE-476context: static ssize_t o2nm_node_ipv4_address_store ( struct config_item * item , const char * page , size_t count ) { struct o2nm_node * node = to_o2nm_node ( item ) ;  struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ;  int ret , i ; struct rb_node * * p , * parent ; unsigned int octets [ 4 ] ; __be32 ipv4_addr = 0 ; ret = sscanf ( page , ""%3u.%3u.%3u.%3u"" , & octets [ 3 ] , & octets [ 2 ] , & octets [ 1 ] , & octets [ 0 ] ) ; if ( ret != 4 ) return - EINVAL ; for ( i = 0 ; i < ARRAY_SIZE ( octets ) ; i ++ ) { if ( octets [ i ] > 255 ) return - ERANGE ; be32_add_cpu ( & ipv4_addr , octets [ i ] << ( i * 8 ) ) ; }  ret = 0 ;  write_lock ( & cluster -> cl_nodes_lock ) ; if ( o2nm_node_ip_tree_lookup ( cluster , ipv4_addr , & p , & parent ) ) ret = - EEXIST ; else if ( test_and_set_bit ( O2NM_NODE_ATTR_ADDRESS , & node -> nd_set_attributes ) ) ret = - EBUSY ; else { rb_link_node ( & node -> nd_ip_node , parent , p ) ; rb_insert_color ( & node -> nd_ip_node , & cluster -> cl_node_ip_tree ) ; } write_unlock ( & cluster -> cl_nodes_lock ) ;  if ( ret )  return ret ; memcpy ( & node -> nd_ipv4_address , & ipv4_addr , sizeof ( ipv4_addr ) ) ; return count ; }","struct o2nm_cluster * cluster ;int ret , i ;",117
165,"buggy line: ret = 0 ;write_lock ( & cluster -> cl_nodes_lock ) ;cwe id:CWE-476context: static ssize_t o2nm_node_ipv4_address_store ( struct config_item * item , const char * page , size_t count ) { struct o2nm_node * node = to_o2nm_node ( item ) ;  struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ;  int ret , i ; struct rb_node * * p , * parent ; unsigned int octets [ 4 ] ; __be32 ipv4_addr = 0 ; ret = sscanf ( page , ""%3u.%3u.%3u.%3u"" , & octets [ 3 ] , & octets [ 2 ] , & octets [ 1 ] , & octets [ 0 ] ) ; if ( ret != 4 ) return - EINVAL ; for ( i = 0 ; i < ARRAY_SIZE ( octets ) ; i ++ ) { if ( octets [ i ] > 255 ) return - ERANGE ; be32_add_cpu ( & ipv4_addr , octets [ i ] << ( i * 8 ) ) ; }  ret = 0 ;  write_lock ( & cluster -> cl_nodes_lock ) ; if ( o2nm_node_ip_tree_lookup ( cluster , ipv4_addr , & p , & parent ) ) ret = - EEXIST ; else if ( test_and_set_bit ( O2NM_NODE_ATTR_ADDRESS , & node -> nd_set_attributes ) ) ret = - EBUSY ; else { rb_link_node ( & node -> nd_ip_node , parent , p ) ; rb_insert_color ( & node -> nd_ip_node , & cluster -> cl_node_ip_tree ) ; } write_unlock ( & cluster -> cl_nodes_lock ) ;  if ( ret )  return ret ; memcpy ( & node -> nd_ipv4_address , & ipv4_addr , sizeof ( ipv4_addr ) ) ; return count ; }",o2nm_lock_subsystem ( ) ;cluster = to_o2nm_cluster_from_node ( node ) ;if ( ! cluster ) {o2nm_unlock_subsystem ( ) ;return - EINVAL ;}ret = 0 ;write_lock ( & cluster -> cl_nodes_lock ) ;o2nm_unlock_subsystem ( ) ;,117
166,"buggy line: if ( ret )  return ret ;cwe id:CWE-476context: static ssize_t o2nm_node_ipv4_address_store ( struct config_item * item , const char * page , size_t count ) { struct o2nm_node * node = to_o2nm_node ( item ) ;  struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ;  int ret , i ; struct rb_node * * p , * parent ; unsigned int octets [ 4 ] ; __be32 ipv4_addr = 0 ; ret = sscanf ( page , ""%3u.%3u.%3u.%3u"" , & octets [ 3 ] , & octets [ 2 ] , & octets [ 1 ] , & octets [ 0 ] ) ; if ( ret != 4 ) return - EINVAL ; for ( i = 0 ; i < ARRAY_SIZE ( octets ) ; i ++ ) { if ( octets [ i ] > 255 ) return - ERANGE ; be32_add_cpu ( & ipv4_addr , octets [ i ] << ( i * 8 ) ) ; }  ret = 0 ;  write_lock ( & cluster -> cl_nodes_lock ) ; if ( o2nm_node_ip_tree_lookup ( cluster , ipv4_addr , & p , & parent ) ) ret = - EEXIST ; else if ( test_and_set_bit ( O2NM_NODE_ATTR_ADDRESS , & node -> nd_set_attributes ) ) ret = - EBUSY ; else { rb_link_node ( & node -> nd_ip_node , parent , p ) ; rb_insert_color ( & node -> nd_ip_node , & cluster -> cl_node_ip_tree ) ; } write_unlock ( & cluster -> cl_nodes_lock ) ;  if ( ret )  return ret ; memcpy ( & node -> nd_ipv4_address , & ipv4_addr , sizeof ( ipv4_addr ) ) ; return count ; }",if ( ret ) return ret ;,117
167,"buggy line: case BSD_AFNUM_ISO :  isoclns_print ( ndo , p , length , caplen ) ;break ;cwe id:CWE-125context: u_int null_if_print ( netdissect_options * ndo , const struct pcap_pkthdr * h , const u_char * p ) { u_int length = h -> len ; u_int caplen = h -> caplen ; u_int family ; if ( caplen < NULL_HDRLEN ) { ND_PRINT ( ( ndo , ""[|null]"" ) ) ; return ( NULL_HDRLEN ) ; } memcpy ( ( char * ) & family , ( const char * ) p , sizeof ( family ) ) ; if ( ( family & 0xFFFF0000 ) != 0 ) family = SWAPLONG ( family ) ; if ( ndo -> ndo_eflag ) null_hdr_print ( ndo , family , length ) ; length -= NULL_HDRLEN ; caplen -= NULL_HDRLEN ; p += NULL_HDRLEN ; switch ( family ) { case BSD_AFNUM_INET : ip_print ( ndo , p , length ) ; break ; case BSD_AFNUM_INET6_BSD : case BSD_AFNUM_INET6_FREEBSD : case BSD_AFNUM_INET6_DARWIN : ip6_print ( ndo , p , length ) ; break ; case BSD_AFNUM_ISO :  isoclns_print ( ndo , p , length , caplen ) ;  break ; case BSD_AFNUM_APPLETALK : atalk_print ( ndo , p , length ) ; break ; case BSD_AFNUM_IPX : ipx_print ( ndo , p , length ) ; break ; default : if ( ! ndo -> ndo_eflag ) null_hdr_print ( ndo , family , length + NULL_HDRLEN ) ; if ( ! ndo -> ndo_suppress_default_print ) ND_DEFAULTPRINT ( p , caplen ) ; } return ( NULL_HDRLEN ) ; }","case BSD_AFNUM_ISO : isoclns_print ( ndo , p , length , caplen ) ;break ;",118
168,"buggy line: # endif if ( * src == \'/\' )  separator = * src ++ ;for ( ;cwe id:CWE-22context: static int cleanup_pathname ( struct archive_write_disk * a ) { char * dest , * src ; char separator = '\\0' ; dest = src = a -> name ; if ( * src == '\\0' ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""Invalid<S2SV_blank>empty<S2SV_blank>pathname"" ) ; return ( ARCHIVE_FAILED ) ; } # if defined ( __CYGWIN__ ) cleanup_pathname_win ( a ) ; # endif if ( * src == '/' )  separator = * src ++ ;  for ( ; ; ) { if ( src [ 0 ] == '\\0' ) { break ; } else if ( src [ 0 ] == '/' ) { src ++ ; continue ; } else if ( src [ 0 ] == '.' ) { if ( src [ 1 ] == '\\0' ) { break ; } else if ( src [ 1 ] == '/' ) { src += 2 ; continue ; } else if ( src [ 1 ] == '.' ) { if ( src [ 2 ] == '/' || src [ 2 ] == '\\0' ) { if ( a -> flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""Path<S2SV_blank>contains<S2SV_blank>\'..\'"" ) ; return ( ARCHIVE_FAILED ) ; } } } } if ( separator ) * dest ++ = '/' ; while ( * src != '\\0' && * src != '/' ) { * dest ++ = * src ++ ; } if ( * src == '\\0' ) break ; separator = * src ++ ; } if ( dest == a -> name ) { if ( separator ) * dest ++ = '/' ; else * dest ++ = '.' ; } * dest = '\\0' ; return ( ARCHIVE_OK ) ; }","# endif if ( * src == \'/\' ) {if ( a -> flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ) {archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""Path<S2SV_blank>is<S2SV_blank>absolute"" ) ;return ( ARCHIVE_FAILED ) ;}separator = * src ++ ;}for ( ;",119
169,"buggy line: TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg ,  TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) {TPM2B_DIGEST tmpResult ;TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ;TPM_RC rval ;int i , j ;cwe id:CWE-522context:  TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg ,  TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) {  TPM2B_DIGEST tmpResult ;  TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ;  TPM_RC rval ;  int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ;  while ( resultKey -> t . size < bytes )  {  i_Swizzled = string_bytes_endian_convert_32 ( i ) ;  * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ;  bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;   rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ;   if ( rval != TPM_RC_SUCCESS )  { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) {  return TSS2_SYS_RC_BAD_VALUE ;  } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }","TPM_RC tpm_kdfa ( TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) {TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ;TPM_RC rval = TPM_RC_SUCCESS ;int i , j ;",120
170,"buggy line: while ( resultKey -> t . size < bytes )  {i_Swizzled = string_bytes_endian_convert_32 ( i ) ;* ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ;bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ;bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ;bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ;bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ;bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ;bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ;if ( rval != TPM_RC_SUCCESS )  {return ( rval ) ;return TSS2_SYS_RC_BAD_VALUE ;}return TPM_RC_SUCCESS ;cwe id:CWE-522context:  TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg ,  TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) {  TPM2B_DIGEST tmpResult ;  TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ;  TPM_RC rval ;  int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ;  while ( resultKey -> t . size < bytes )  {  i_Swizzled = string_bytes_endian_convert_32 ( i ) ;  * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ;  bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;   rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ;   if ( rval != TPM_RC_SUCCESS )  { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) {  return TSS2_SYS_RC_BAD_VALUE ;  } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }","const EVP_MD * md = tpm_algorithm_to_openssl_digest ( hashAlg ) ;if ( ! md ) {LOG_ERR ( ""Algorithm<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>for<S2SV_blank>hmac:<S2SV_blank>%x"" , hashAlg ) ;return TPM_RC_HASH ;}HMAC_CTX ctx ;HMAC_CTX_init ( & ctx ) ;int rc = HMAC_Init_ex ( & ctx , key -> buffer , key -> size , md , NULL ) ;if ( ! rc ) {LOG_ERR ( ""HMAC<S2SV_blank>Init<S2SV_blank>failed:<S2SV_blank>%s"" , ERR_error_string ( rc , NULL ) ) ;return TPM_RC_MEMORY ;}while ( resultKey -> t . size < bytes ) {TPM2B_DIGEST tmpResult ;i_Swizzled = string_bytes_endian_convert_32 ( i ) ;* ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ;bufferList [ j ] = ( TPM2B_DIGEST * ) 0 ;int c ;for ( c = 0 ;c < j ;c ++ ) {TPM2B_DIGEST * digest = bufferList [ c ] ;int rc = HMAC_Update ( & ctx , digest -> b . buffer , digest -> b . size ) ;if ( ! rc ) {LOG_ERR ( ""HMAC<S2SV_blank>Update<S2SV_blank>failed:<S2SV_blank>%s"" , ERR_error_string ( rc , NULL ) ) ;rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ;if ( ! rc ) {LOG_ERR ( ""HMAC<S2SV_blank>Final<S2SV_blank>failed:<S2SV_blank>%s"" , ERR_error_string ( rc , NULL ) ) ;rval = TPM_RC_MEMORY ;goto err ;tmpResult . t . size = size ;rval = TSS2_SYS_RC_BAD_VALUE ;goto err ;}err : HMAC_CTX_cleanup ( & ctx ) ;return rval ;",120
171,"buggy line: cmpt = 0 ;if ( width < 0 || height < 0 || hstep <= 0 || vstep <= 0 ) {if ( ! jas_safe_intfast32_add ( tlx , width , 0 ) ||  ! jas_safe_intfast32_add ( tly , height , 0 ) ) {goto error ;}if ( ! ( cmpt = jas_malloc ( sizeof ( jas_image_cmpt_t ) ) ) ) {goto error ;}cmpt -> type_ = JAS_IMAGE_CT_UNKNOWN ;cmpt -> tlx_ = tlx ;cmpt -> tly_ = tly ;cmpt -> hstep_ = hstep ;cmpt -> vstep_ = vstep ;cmpt -> width_ = width ;cmpt -> height_ = height ;cmpt -> prec_ = depth ;cmpt -> sgnd_ = sgnd ;cmpt -> stream_ = 0 ;cmpt -> cps_ = ( depth + 7 ) / 8 ;if ( ! jas_safe_size_mul ( cmpt -> width_ , cmpt -> height_ , & size ) ||  ! jas_safe_size_mul ( size , cmpt -> cps_ , & size ) ) {cwe id:CWE-190context: static jas_image_cmpt_t * jas_image_cmpt_create ( int_fast32_t tlx , int_fast32_t tly , int_fast32_t hstep , int_fast32_t vstep , int_fast32_t width , int_fast32_t height , uint_fast16_t depth , bool sgnd , uint_fast32_t inmem ) { jas_image_cmpt_t * cmpt ; size_t size ;  cmpt = 0 ;  if ( width < 0 || height < 0 || hstep <= 0 || vstep <= 0 ) { goto error ; } if ( ! jas_safe_intfast32_add ( tlx , width , 0 ) ||  ! jas_safe_intfast32_add ( tly , height , 0 ) ) {  goto error ; } if ( ! ( cmpt = jas_malloc ( sizeof ( jas_image_cmpt_t ) ) ) ) { goto error ; } cmpt -> type_ = JAS_IMAGE_CT_UNKNOWN ; cmpt -> tlx_ = tlx ; cmpt -> tly_ = tly ; cmpt -> hstep_ = hstep ; cmpt -> vstep_ = vstep ; cmpt -> width_ = width ; cmpt -> height_ = height ; cmpt -> prec_ = depth ; cmpt -> sgnd_ = sgnd ; cmpt -> stream_ = 0 ; cmpt -> cps_ = ( depth + 7 ) / 8 ;  if ( ! jas_safe_size_mul ( cmpt -> width_ , cmpt -> height_ , & size ) ||  ! jas_safe_size_mul ( size , cmpt -> cps_ , & size ) ) { goto error ; } cmpt -> stream_ = ( inmem ) ? jas_stream_memopen2 ( 0 , size ) : jas_stream_tmpfile ( ) ; if ( ! cmpt -> stream_ ) { goto error ; } if ( size > 0 ) { if ( size - 1 > LONG_MAX ) { goto error ; } if ( jas_stream_seek ( cmpt -> stream_ , size - 1 , SEEK_SET ) < 0 || jas_stream_putc ( cmpt -> stream_ , 0 ) == EOF || jas_stream_seek ( cmpt -> stream_ , 0 , SEEK_SET ) < 0 ) { goto error ; } } return cmpt ; error : if ( cmpt ) { jas_image_cmpt_destroy ( cmpt ) ; } return 0 ; }","JAS_DBGLOG ( 100 , ( ""jas_image_cmpt_create(%ld,<S2SV_blank>%ld,<S2SV_blank>%ld,<S2SV_blank>%ld,<S2SV_blank>%ld,<S2SV_blank>%ld,<S2SV_blank>%d,<S2SV_blank>%d,<S2SV_blank>%d)\\\cmpt = 0 ;if ( width < 0 || height < 0 || hstep <= 0 || vstep <= 0 ) {if ( ! jas_safe_size_mul3 ( cmpt -> width_ , cmpt -> height_ , & size ) || ! jas_safe_size_mul ( size , cmpt -> cps_ , & size ) ) {",121
172,buggy line: tdata_t _TIFFmalloc ( tsize_t s )  {return ( malloc ( ( size_t ) s ) ) ;cwe id:CWE-369context: tdata_t _TIFFmalloc ( tsize_t s )  {  return ( malloc ( ( size_t ) s ) ) ; },tdata_t _TIFFmalloc ( tsize_t s ) {if ( s == 0 ) return ( ( void * ) NULL ) ;return ( malloc ( ( size_t ) s ) ) ;,122
173,"buggy line: if ( count < sizeof ( cmd . type ) ) {ret = - EINVAL ;cwe id:CWE-264context: static ssize_t qib_write ( struct file * fp , const char __user * data , size_t count , loff_t * off ) { const struct qib_cmd __user * ucmd ; struct qib_ctxtdata * rcd ; const void __user * src ; size_t consumed , copy = 0 ; struct qib_cmd cmd ; ssize_t ret = 0 ; void * dest ;  if ( count < sizeof ( cmd . type ) ) {  ret = - EINVAL ; goto bail ; } ucmd = ( const struct qib_cmd __user * ) data ; if ( copy_from_user ( & cmd . type , & ucmd -> type , sizeof ( cmd . type ) ) ) { ret = - EFAULT ; goto bail ; } consumed = sizeof ( cmd . type ) ; switch ( cmd . type ) { case QIB_CMD_ASSIGN_CTXT : case QIB_CMD_USER_INIT : copy = sizeof ( cmd . cmd . user_info ) ; dest = & cmd . cmd . user_info ; src = & ucmd -> cmd . user_info ; break ; case QIB_CMD_RECV_CTRL : copy = sizeof ( cmd . cmd . recv_ctrl ) ; dest = & cmd . cmd . recv_ctrl ; src = & ucmd -> cmd . recv_ctrl ; break ; case QIB_CMD_CTXT_INFO : copy = sizeof ( cmd . cmd . ctxt_info ) ; dest = & cmd . cmd . ctxt_info ; src = & ucmd -> cmd . ctxt_info ; break ; case QIB_CMD_TID_UPDATE : case QIB_CMD_TID_FREE : copy = sizeof ( cmd . cmd . tid_info ) ; dest = & cmd . cmd . tid_info ; src = & ucmd -> cmd . tid_info ; break ; case QIB_CMD_SET_PART_KEY : copy = sizeof ( cmd . cmd . part_key ) ; dest = & cmd . cmd . part_key ; src = & ucmd -> cmd . part_key ; break ; case QIB_CMD_DISARM_BUFS : case QIB_CMD_PIOAVAILUPD : copy = 0 ; src = NULL ; dest = NULL ; break ; case QIB_CMD_POLL_TYPE : copy = sizeof ( cmd . cmd . poll_type ) ; dest = & cmd . cmd . poll_type ; src = & ucmd -> cmd . poll_type ; break ; case QIB_CMD_ARMLAUNCH_CTRL : copy = sizeof ( cmd . cmd . armlaunch_ctrl ) ; dest = & cmd . cmd . armlaunch_ctrl ; src = & ucmd -> cmd . armlaunch_ctrl ; break ; case QIB_CMD_SDMA_INFLIGHT : copy = sizeof ( cmd . cmd . sdma_inflight ) ; dest = & cmd . cmd . sdma_inflight ; src = & ucmd -> cmd . sdma_inflight ; break ; case QIB_CMD_SDMA_COMPLETE : copy = sizeof ( cmd . cmd . sdma_complete ) ; dest = & cmd . cmd . sdma_complete ; src = & ucmd -> cmd . sdma_complete ; break ; case QIB_CMD_ACK_EVENT : copy = sizeof ( cmd . cmd . event_mask ) ; dest = & cmd . cmd . event_mask ; src = & ucmd -> cmd . event_mask ; break ; default : ret = - EINVAL ; goto bail ; } if ( copy ) { if ( ( count - consumed ) < copy ) { ret = - EINVAL ; goto bail ; } if ( copy_from_user ( dest , src , copy ) ) { ret = - EFAULT ; goto bail ; } consumed += copy ; } rcd = ctxt_fp ( fp ) ; if ( ! rcd && cmd . type != QIB_CMD_ASSIGN_CTXT ) { ret = - EINVAL ; goto bail ; } switch ( cmd . type ) { case QIB_CMD_ASSIGN_CTXT : ret = qib_assign_ctxt ( fp , & cmd . cmd . user_info ) ; if ( ret ) goto bail ; break ; case QIB_CMD_USER_INIT : ret = qib_do_user_init ( fp , & cmd . cmd . user_info ) ; if ( ret ) goto bail ; ret = qib_get_base_info ( fp , ( void __user * ) ( unsigned long ) cmd . cmd . user_info . spu_base_info , cmd . cmd . user_info . spu_base_info_size ) ; break ; case QIB_CMD_RECV_CTRL : ret = qib_manage_rcvq ( rcd , subctxt_fp ( fp ) , cmd . cmd . recv_ctrl ) ; break ; case QIB_CMD_CTXT_INFO : ret = qib_ctxt_info ( fp , ( struct qib_ctxt_info __user * ) ( unsigned long ) cmd . cmd . ctxt_info ) ; break ; case QIB_CMD_TID_UPDATE : ret = qib_tid_update ( rcd , fp , & cmd . cmd . tid_info ) ; break ; case QIB_CMD_TID_FREE : ret = qib_tid_free ( rcd , subctxt_fp ( fp ) , & cmd . cmd . tid_info ) ; break ; case QIB_CMD_SET_PART_KEY : ret = qib_set_part_key ( rcd , cmd . cmd . part_key ) ; break ; case QIB_CMD_DISARM_BUFS : ( void ) qib_disarm_piobufs_ifneeded ( rcd ) ; ret = disarm_req_delay ( rcd ) ; break ; case QIB_CMD_PIOAVAILUPD : qib_force_pio_avail_update ( rcd -> dd ) ; break ; case QIB_CMD_POLL_TYPE : rcd -> poll_type = cmd . cmd . poll_type ; break ; case QIB_CMD_ARMLAUNCH_CTRL : rcd -> dd -> f_set_armlaunch ( rcd -> dd , cmd . cmd . armlaunch_ctrl ) ; break ; case QIB_CMD_SDMA_INFLIGHT : ret = qib_sdma_get_inflight ( user_sdma_queue_fp ( fp ) , ( u32 __user * ) ( unsigned long ) cmd . cmd . sdma_inflight ) ; break ; case QIB_CMD_SDMA_COMPLETE : ret = qib_sdma_get_complete ( rcd -> ppd , user_sdma_queue_fp ( fp ) , ( u32 __user * ) ( unsigned long ) cmd . cmd . sdma_complete ) ; break ; case QIB_CMD_ACK_EVENT : ret = qib_user_event_ack ( rcd , subctxt_fp ( fp ) , cmd . cmd . event_mask ) ; break ; } if ( ret >= 0 ) ret = consumed ; bail : return ret ; }",if ( WARN_ON_ONCE ( ! ib_safe_file_access ( fp ) ) ) return - EACCES ;if ( count < sizeof ( cmd . type ) ) {ret = - EINVAL ;,123
174,"buggy line: cwe id:CWE-200context: static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; register Quantum * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } clone_info = CloneImageInfo ( image_info ) ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) != 0 ) { image2 = ReadMATImageV4 ( image_info , image , exception ) ; if ( image2 == NULL ) goto MATLAB_KO ; image = image2 ; goto END_OF_READING ; } MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c"" , MATLAB_HDR . EndianIndicator [ 0 ] , MATLAB_HDR . EndianIndicator [ 1 ] ) ; if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""IM"" , 2 ) ) { ReadBlobXXXLong = ReadBlobLSBLong ; ReadBlobXXXShort = ReadBlobLSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesLSB ; ReadBlobFloatsXXX = ReadBlobFloatsLSB ; image -> endian = LSBEndian ; } else if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""MI"" , 2 ) ) { ReadBlobXXXLong = ReadBlobMSBLong ; ReadBlobXXXShort = ReadBlobMSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesMSB ; ReadBlobFloatsXXX = ReadBlobFloatsMSB ; image -> endian = MSBEndian ; } else goto MATLAB_KO ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) ) MATLAB_KO : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; filepos = TellBlob ( image ) ; while ( ! EOFBlob ( image ) ) { Frames = 1 ; ( void ) SeekBlob ( image , filepos , SEEK_SET ) ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; filepos += MATLAB_HDR . ObjectSize + 4 + 4 ; image2 = image ; # if defined ( MAGICKCORE_ZLIB_DELEGATE ) if ( MATLAB_HDR . DataType == miCOMPRESSED ) { image2 = DecompressBlock ( image , MATLAB_HDR . ObjectSize , clone_info , exception ) ; if ( image2 == NULL ) continue ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image2 ) ; } # endif if ( MATLAB_HDR . DataType != miMATRIX ) continue ; MATLAB_HDR . unknown1 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown2 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown5 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . StructureClass = MATLAB_HDR . unknown5 & 0xFF ; MATLAB_HDR . StructureFlag = ( MATLAB_HDR . unknown5 >> 8 ) & 0xFF ; MATLAB_HDR . unknown3 = ReadBlobXXXLong ( image2 ) ; if ( image != image2 ) MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . DimFlag = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeX = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeY = ReadBlobXXXLong ( image2 ) ; switch ( MATLAB_HDR . DimFlag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = ReadBlobXXXLong ( image2 ) ; ( void ) ReadBlobXXXLong ( image2 ) ; if ( z != 3 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; break ; case 16 : z2 = z = ReadBlobXXXLong ( image2 ) ; if ( z != 3 && z != 1 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; Frames = ReadBlobXXXLong ( image2 ) ; if ( Frames == 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; break ; default : ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; } MATLAB_HDR . Flag1 = ReadBlobXXXShort ( image2 ) ; MATLAB_HDR . NameFlag = ReadBlobXXXShort ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.StructureClass<S2SV_blank>%d"" , MATLAB_HDR . StructureClass ) ; if ( MATLAB_HDR . StructureClass != mxCHAR_CLASS && MATLAB_HDR . StructureClass != mxSINGLE_CLASS && MATLAB_HDR . StructureClass != mxDOUBLE_CLASS && MATLAB_HDR . StructureClass != mxINT8_CLASS && MATLAB_HDR . StructureClass != mxUINT8_CLASS && MATLAB_HDR . StructureClass != mxINT16_CLASS && MATLAB_HDR . StructureClass != mxUINT16_CLASS && MATLAB_HDR . StructureClass != mxINT32_CLASS && MATLAB_HDR . StructureClass != mxUINT32_CLASS && MATLAB_HDR . StructureClass != mxINT64_CLASS && MATLAB_HDR . StructureClass != mxUINT64_CLASS ) ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; switch ( MATLAB_HDR . NameFlag ) { case 0 : size = ReadBlobXXXLong ( image2 ) ; size = 4 * ( ssize_t ) ( ( size + 3 + 1 ) / 4 ) ; ( void ) SeekBlob ( image2 , size , SEEK_CUR ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto MATLAB_KO ; } CellType = ReadBlobXXXLong ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.CellType:<S2SV_blank>%.20g"" , ( double ) CellType ) ; ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; NEXT_FRAME : switch ( CellType ) { case miINT8 : case miUINT8 : sample_size = 8 ; if ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) MATLAB_HDR . SizeX ; break ; case miINT16 : case miUINT16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * MATLAB_HDR . SizeX ) ; break ; case miINT32 : case miUINT32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miINT64 : case miUINT64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; case miSINGLE : sample_size = 32 ; image -> depth = 32 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miDOUBLE : sample_size = 64 ; image -> depth = 64 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; DisableMSCWarning ( 4127 ) if ( sizeof ( double ) != 8 ) RestoreMSCWarning ThrowReaderException ( CoderError , ""IncompatibleSizeOfDouble"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; default : ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; } ( void ) sample_size ; image -> columns = MATLAB_HDR . SizeX ; image -> rows = MATLAB_HDR . SizeY ; quantum_info = AcquireQuantumInfo ( clone_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; one = 1 ; image -> colors = one << image -> depth ; if ( image -> columns == 0 || image -> rows == 0 ) goto MATLAB_KO ; if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) { image -> type = GrayscaleType ; SetImageColorspace ( image , GRAYColorspace , exception ) ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( double ) ) ; if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;  MinVal = 0 ;  MaxVal = 0 ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { q = GetAuthenticPixels ( image , 0 , MATLAB_HDR . SizeY - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto done_reading ; } if ( ReadBlob ( image2 , ldblk , ( unsigned char * ) BImgBuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } if ( ( CellType == miINT8 || CellType == miUINT8 ) && ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) ) { FixLogical ( ( unsigned char * ) BImgBuff , ldblk ) ; if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) { ImportQuantumPixelsFailed : if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; break ; } } else { if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) goto ImportQuantumPixelsFailed ; if ( z <= 1 && ( CellType == miINT8 || CellType == miINT16 || CellType == miINT32 || CellType == miINT64 ) ) FixSignedValues ( image , q , MATLAB_HDR . SizeX ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } } } while ( z -- >= 2 ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ; ExitLoop : if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { CellType = ReadBlobXXXLong ( image2 ) ; i = ReadBlobXXXLong ( image2 ) ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & MinVal , & MaxVal ) ; } if ( CellType == miDOUBLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobDoublesXXX ( image2 , ldblk , ( double * ) BImgBuff ) ; InsertComplexDoubleRow ( image , ( double * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } if ( CellType == miSINGLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobFloatsXXX ( image2 , ldblk , ( float * ) BImgBuff ) ; InsertComplexFloatRow ( image , ( float * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } } if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) image -> type = GrayscaleType ; if ( image -> depth == 1 ) image -> type = BilevelType ; if ( image2 == image ) image2 = NULL ; rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; blob = rotated_image -> blob ; rotated_image -> blob = image -> blob ; rotated_image -> colors = image -> colors ; image -> blob = blob ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } done_reading : if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } AcquireNextImage ( image_info , image , exception ) ; if ( image -> next == ( Image * ) NULL ) break ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; RelinquishMagickMemory ( BImgBuff ) ; BImgBuff = NULL ; if ( -- Frames > 0 ) { z = z2 ; if ( image2 == NULL ) image2 = image ; goto NEXT_FRAME ; } if ( ( image2 != NULL ) && ( image2 != image ) ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } } RelinquishMagickMemory ( BImgBuff ) ; END_OF_READING : clone_info = DestroyImageInfo ( clone_info ) ; CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != NULL ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } DestroyImageInfo ( clone_info ) ; clone_info = NULL ; } if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""return"" ) ; if ( image == NULL ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; return ( image ) ; }","( void ) ResetMagickMemory ( BImgBuff , 0 , ldblk * sizeof ( double ) ) ;",124
175,"buggy line: MinVal = 0 ;MaxVal = 0 ;cwe id:CWE-200context: static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; register Quantum * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } clone_info = CloneImageInfo ( image_info ) ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) != 0 ) { image2 = ReadMATImageV4 ( image_info , image , exception ) ; if ( image2 == NULL ) goto MATLAB_KO ; image = image2 ; goto END_OF_READING ; } MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c"" , MATLAB_HDR . EndianIndicator [ 0 ] , MATLAB_HDR . EndianIndicator [ 1 ] ) ; if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""IM"" , 2 ) ) { ReadBlobXXXLong = ReadBlobLSBLong ; ReadBlobXXXShort = ReadBlobLSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesLSB ; ReadBlobFloatsXXX = ReadBlobFloatsLSB ; image -> endian = LSBEndian ; } else if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""MI"" , 2 ) ) { ReadBlobXXXLong = ReadBlobMSBLong ; ReadBlobXXXShort = ReadBlobMSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesMSB ; ReadBlobFloatsXXX = ReadBlobFloatsMSB ; image -> endian = MSBEndian ; } else goto MATLAB_KO ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) ) MATLAB_KO : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; filepos = TellBlob ( image ) ; while ( ! EOFBlob ( image ) ) { Frames = 1 ; ( void ) SeekBlob ( image , filepos , SEEK_SET ) ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; filepos += MATLAB_HDR . ObjectSize + 4 + 4 ; image2 = image ; # if defined ( MAGICKCORE_ZLIB_DELEGATE ) if ( MATLAB_HDR . DataType == miCOMPRESSED ) { image2 = DecompressBlock ( image , MATLAB_HDR . ObjectSize , clone_info , exception ) ; if ( image2 == NULL ) continue ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image2 ) ; } # endif if ( MATLAB_HDR . DataType != miMATRIX ) continue ; MATLAB_HDR . unknown1 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown2 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown5 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . StructureClass = MATLAB_HDR . unknown5 & 0xFF ; MATLAB_HDR . StructureFlag = ( MATLAB_HDR . unknown5 >> 8 ) & 0xFF ; MATLAB_HDR . unknown3 = ReadBlobXXXLong ( image2 ) ; if ( image != image2 ) MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . DimFlag = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeX = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeY = ReadBlobXXXLong ( image2 ) ; switch ( MATLAB_HDR . DimFlag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = ReadBlobXXXLong ( image2 ) ; ( void ) ReadBlobXXXLong ( image2 ) ; if ( z != 3 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; break ; case 16 : z2 = z = ReadBlobXXXLong ( image2 ) ; if ( z != 3 && z != 1 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; Frames = ReadBlobXXXLong ( image2 ) ; if ( Frames == 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; break ; default : ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; } MATLAB_HDR . Flag1 = ReadBlobXXXShort ( image2 ) ; MATLAB_HDR . NameFlag = ReadBlobXXXShort ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.StructureClass<S2SV_blank>%d"" , MATLAB_HDR . StructureClass ) ; if ( MATLAB_HDR . StructureClass != mxCHAR_CLASS && MATLAB_HDR . StructureClass != mxSINGLE_CLASS && MATLAB_HDR . StructureClass != mxDOUBLE_CLASS && MATLAB_HDR . StructureClass != mxINT8_CLASS && MATLAB_HDR . StructureClass != mxUINT8_CLASS && MATLAB_HDR . StructureClass != mxINT16_CLASS && MATLAB_HDR . StructureClass != mxUINT16_CLASS && MATLAB_HDR . StructureClass != mxINT32_CLASS && MATLAB_HDR . StructureClass != mxUINT32_CLASS && MATLAB_HDR . StructureClass != mxINT64_CLASS && MATLAB_HDR . StructureClass != mxUINT64_CLASS ) ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; switch ( MATLAB_HDR . NameFlag ) { case 0 : size = ReadBlobXXXLong ( image2 ) ; size = 4 * ( ssize_t ) ( ( size + 3 + 1 ) / 4 ) ; ( void ) SeekBlob ( image2 , size , SEEK_CUR ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto MATLAB_KO ; } CellType = ReadBlobXXXLong ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.CellType:<S2SV_blank>%.20g"" , ( double ) CellType ) ; ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; NEXT_FRAME : switch ( CellType ) { case miINT8 : case miUINT8 : sample_size = 8 ; if ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) MATLAB_HDR . SizeX ; break ; case miINT16 : case miUINT16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * MATLAB_HDR . SizeX ) ; break ; case miINT32 : case miUINT32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miINT64 : case miUINT64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; case miSINGLE : sample_size = 32 ; image -> depth = 32 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miDOUBLE : sample_size = 64 ; image -> depth = 64 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; DisableMSCWarning ( 4127 ) if ( sizeof ( double ) != 8 ) RestoreMSCWarning ThrowReaderException ( CoderError , ""IncompatibleSizeOfDouble"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; default : ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; } ( void ) sample_size ; image -> columns = MATLAB_HDR . SizeX ; image -> rows = MATLAB_HDR . SizeY ; quantum_info = AcquireQuantumInfo ( clone_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; one = 1 ; image -> colors = one << image -> depth ; if ( image -> columns == 0 || image -> rows == 0 ) goto MATLAB_KO ; if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) { image -> type = GrayscaleType ; SetImageColorspace ( image , GRAYColorspace , exception ) ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( double ) ) ; if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;  MinVal = 0 ;  MaxVal = 0 ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { q = GetAuthenticPixels ( image , 0 , MATLAB_HDR . SizeY - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto done_reading ; } if ( ReadBlob ( image2 , ldblk , ( unsigned char * ) BImgBuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } if ( ( CellType == miINT8 || CellType == miUINT8 ) && ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) ) { FixLogical ( ( unsigned char * ) BImgBuff , ldblk ) ; if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) { ImportQuantumPixelsFailed : if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; break ; } } else { if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) goto ImportQuantumPixelsFailed ; if ( z <= 1 && ( CellType == miINT8 || CellType == miINT16 || CellType == miINT32 || CellType == miINT64 ) ) FixSignedValues ( image , q , MATLAB_HDR . SizeX ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } } } while ( z -- >= 2 ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ; ExitLoop : if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { CellType = ReadBlobXXXLong ( image2 ) ; i = ReadBlobXXXLong ( image2 ) ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & MinVal , & MaxVal ) ; } if ( CellType == miDOUBLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobDoublesXXX ( image2 , ldblk , ( double * ) BImgBuff ) ; InsertComplexDoubleRow ( image , ( double * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } if ( CellType == miSINGLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobFloatsXXX ( image2 , ldblk , ( float * ) BImgBuff ) ; InsertComplexFloatRow ( image , ( float * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } } if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) image -> type = GrayscaleType ; if ( image -> depth == 1 ) image -> type = BilevelType ; if ( image2 == image ) image2 = NULL ; rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; blob = rotated_image -> blob ; rotated_image -> blob = image -> blob ; rotated_image -> colors = image -> colors ; image -> blob = blob ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } done_reading : if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } AcquireNextImage ( image_info , image , exception ) ; if ( image -> next == ( Image * ) NULL ) break ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; RelinquishMagickMemory ( BImgBuff ) ; BImgBuff = NULL ; if ( -- Frames > 0 ) { z = z2 ; if ( image2 == NULL ) image2 = image ; goto NEXT_FRAME ; } if ( ( image2 != NULL ) && ( image2 != image ) ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } } RelinquishMagickMemory ( BImgBuff ) ; END_OF_READING : clone_info = DestroyImageInfo ( clone_info ) ; CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != NULL ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } DestroyImageInfo ( clone_info ) ; clone_info = NULL ; } if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""return"" ) ; if ( image == NULL ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; return ( image ) ; }",MinVal = 0 ;MaxVal = 0 ;,124
176,"buggy line: if ( peer )  get_net ( peer ) ;spin_unlock_bh ( & net -> nsid_lock ) ;cwe id:CWE-416context: struct net * get_net_ns_by_id ( struct net * net , int id ) { struct net * peer ; if ( id < 0 ) return NULL ; rcu_read_lock ( ) ; spin_lock_bh ( & net -> nsid_lock ) ; peer = idr_find ( & net -> netns_ids , id ) ; if ( peer )  get_net ( peer ) ;  spin_unlock_bh ( & net -> nsid_lock ) ; rcu_read_unlock ( ) ; return peer ; }",if ( peer ) peer = maybe_get_net ( peer ) ;spin_unlock_bh ( & net -> nsid_lock ) ;,125
177,"buggy line: while ( header_buf [ i ] == '\\\\r' || header_buf [ i ] == '\\\cwe id:CWE-000context: void * getHTTPResponse ( int s , int * size ) { char buf [ 2048 ] ; int n ; int endofheaders = 0 ; int chunked = 0 ; int content_length = - 1 ; unsigned int chunksize = 0 ; unsigned int bytestocopy = 0 ; char * header_buf ; unsigned int header_buf_len = 2048 ; unsigned int header_buf_used = 0 ; char * content_buf ; unsigned int content_buf_len = 2048 ; unsigned int content_buf_used = 0 ; char chunksize_buf [ 32 ] ; unsigned int chunksize_buf_index ; header_buf = malloc ( header_buf_len ) ; content_buf = malloc ( content_buf_len ) ; chunksize_buf [ 0 ] = '\\0' ; chunksize_buf_index = 0 ; while ( ( n = receivedata ( s , buf , 2048 , 5000 , NULL ) ) > 0 ) { if ( endofheaders == 0 ) { int i ; int linestart = 0 ; int colon = 0 ; int valuestart = 0 ; if ( header_buf_used + n > header_buf_len ) { header_buf = realloc ( header_buf , header_buf_used + n ) ; header_buf_len = header_buf_used + n ; } memcpy ( header_buf + header_buf_used , buf , n ) ; header_buf_used += n ; i = 0 ; while ( i < ( ( int ) header_buf_used - 1 ) && ( endofheaders == 0 ) ) { if ( header_buf [ i ] == '\\r' ) { i ++ ; if ( header_buf [ i ] == '\\n' ) { i ++ ; if ( i < ( int ) header_buf_used && header_buf [ i ] == '\\r' ) { i ++ ; if ( i < ( int ) header_buf_used && header_buf [ i ] == '\\n' ) { endofheaders = i + 1 ; } } } } else if ( header_buf [ i ] == '\\n' ) { i ++ ; if ( header_buf [ i ] == '\\n' ) { endofheaders = i + 1 ; } } i ++ ; } if ( endofheaders == 0 ) continue ; for ( i = 0 ; i < endofheaders - 1 ; i ++ ) { if ( colon <= linestart && header_buf [ i ] == ':' ) { colon = i ; while ( i < ( endofheaders - 1 ) && ( header_buf [ i + 1 ] == '<S2SV_blank>' || header_buf [ i + 1 ] == '\\t' ) ) i ++ ; valuestart = i + 1 ; } else if ( header_buf [ i ] == '\\r' || header_buf [ i ] == '\\n' ) { if ( colon > linestart && valuestart > colon ) { # ifdef DEBUG printf ( ""header=\'%.*s\',<S2SV_blank>value=\'%.*s\'\\n"" , colon - linestart , header_buf + linestart , i - valuestart , header_buf + valuestart ) ; # endif if ( 0 == strncasecmp ( header_buf + linestart , ""content-length"" , colon - linestart ) ) { content_length = atoi ( header_buf + valuestart ) ; # ifdef DEBUG printf ( ""Content-Length:<S2SV_blank>%d\\n"" , content_length ) ; # endif } else if ( 0 == strncasecmp ( header_buf + linestart , ""transfer-encoding"" , colon - linestart ) && 0 == strncasecmp ( header_buf + valuestart , ""chunked"" , 7 ) ) { # ifdef DEBUG printf ( ""chunked<S2SV_blank>transfer-encoding!\\n"" ) ; # endif chunked = 1 ; } }  while ( header_buf [ i ] == '\\r' || header_buf [ i ] == '\\n' )  i ++ ; linestart = i ; colon = linestart ; valuestart = 0 ; } } n = header_buf_used - endofheaders ; memcpy ( buf , header_buf + endofheaders , n ) ; } if ( endofheaders ) { if ( chunked ) { int i = 0 ; while ( i < n ) { if ( chunksize == 0 ) { if ( chunksize_buf_index == 0 ) { if ( i < n && buf [ i ] == '\\r' ) i ++ ; if ( i < n && buf [ i ] == '\\n' ) i ++ ; } while ( i < n && isxdigit ( buf [ i ] ) && chunksize_buf_index < ( sizeof ( chunksize_buf ) - 1 ) ) { chunksize_buf [ chunksize_buf_index ++ ] = buf [ i ] ; chunksize_buf [ chunksize_buf_index ] = '\\0' ; i ++ ; } while ( i < n && buf [ i ] != '\\r' && buf [ i ] != '\\n' ) i ++ ; if ( i < n && buf [ i ] == '\\r' ) i ++ ; if ( i < n && buf [ i ] == '\\n' ) { unsigned int j ; for ( j = 0 ; j < chunksize_buf_index ; j ++ ) { if ( chunksize_buf [ j ] >= '0' && chunksize_buf [ j ] <= '9' ) chunksize = ( chunksize << 4 ) + ( chunksize_buf [ j ] - '0' ) ; else chunksize = ( chunksize << 4 ) + ( ( chunksize_buf [ j ] | 32 ) - 'a' + 10 ) ; } chunksize_buf [ 0 ] = '\\0' ; chunksize_buf_index = 0 ; i ++ ; } else { continue ; } # ifdef DEBUG printf ( ""chunksize<S2SV_blank>=<S2SV_blank>%u<S2SV_blank>(%x)\\n"" , chunksize , chunksize ) ; # endif if ( chunksize == 0 ) { # ifdef DEBUG printf ( ""end<S2SV_blank>of<S2SV_blank>HTTP<S2SV_blank>content<S2SV_blank>-<S2SV_blank>%d<S2SV_blank>%d\\n"" , i , n ) ; # endif goto end_of_stream ; } } bytestocopy = ( ( int ) chunksize < ( n - i ) ) ? chunksize : ( unsigned int ) ( n - i ) ; if ( ( content_buf_used + bytestocopy ) > content_buf_len ) { if ( content_length >= ( int ) ( content_buf_used + bytestocopy ) ) { content_buf_len = content_length ; } else { content_buf_len = content_buf_used + bytestocopy ; } content_buf = ( char * ) realloc ( ( void * ) content_buf , content_buf_len ) ; } memcpy ( content_buf + content_buf_used , buf + i , bytestocopy ) ; content_buf_used += bytestocopy ; i += bytestocopy ; chunksize -= bytestocopy ; } } else { if ( content_length > 0 && ( int ) ( content_buf_used + n ) > content_length ) { n = content_length - content_buf_used ; } if ( content_buf_used + n > content_buf_len ) { if ( content_length >= ( int ) ( content_buf_used + n ) ) { content_buf_len = content_length ; } else { content_buf_len = content_buf_used + n ; } content_buf = ( char * ) realloc ( ( void * ) content_buf , content_buf_len ) ; } memcpy ( content_buf + content_buf_used , buf , n ) ; content_buf_used += n ; } } if ( content_length > 0 && ( int ) content_buf_used >= content_length ) { # ifdef DEBUG printf ( ""End<S2SV_blank>of<S2SV_blank>HTTP<S2SV_blank>content\\n"" ) ; # endif break ; } } end_of_stream : free ( header_buf ) ; header_buf = NULL ; * size = content_buf_used ; if ( content_buf_used == 0 ) { free ( content_buf ) ; content_buf = NULL ; } return content_buf ; }",while ( ( i < ( int ) header_buf_used ) && ( header_buf [ i ] == '\\\\r' || header_buf [ i ] == '\\\,126
178,"buggy line: assert ( proto != LLDP_MGMT_ADDR_NONE ) ;if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_MGMT_ADDR ) && POKE_UINT8 ( mgmt -> m_addrsize + 1 ) && POKE_UINT8 ( proto ) && POKE_BYTES ( & mgmt -> m_addr , mgmt -> m_addrsize ) ) ) goto toobig ;cwe id:CWE-617context: static int _lldp_send ( struct lldpd * global , struct lldpd_hardware * hardware , u_int8_t c_id_subtype , char * c_id , int c_id_len , u_int8_t p_id_subtype , char * p_id , int p_id_len , int shutdown ) { struct lldpd_port * port ; struct lldpd_chassis * chassis ; struct lldpd_frame * frame ; int length ; u_int8_t * packet , * pos , * tlv ; struct lldpd_mgmt * mgmt ; int proto ; u_int8_t mcastaddr [ ] = LLDP_MULTICAST_ADDR ; # ifdef ENABLE_DOT1 const u_int8_t dot1 [ ] = LLDP_TLV_ORG_DOT1 ; struct lldpd_vlan * vlan ; struct lldpd_ppvid * ppvid ; struct lldpd_pi * pi ; # endif # ifdef ENABLE_DOT3 const u_int8_t dot3 [ ] = LLDP_TLV_ORG_DOT3 ; # endif # ifdef ENABLE_LLDPMED int i ; const u_int8_t med [ ] = LLDP_TLV_ORG_MED ; # endif # ifdef ENABLE_CUSTOM struct lldpd_custom * custom ; # endif port = & hardware -> h_lport ; chassis = port -> p_chassis ; length = hardware -> h_mtu ; if ( ( packet = ( u_int8_t * ) calloc ( 1 , length ) ) == NULL ) return ENOMEM ; pos = packet ; if ( ! ( POKE_BYTES ( mcastaddr , sizeof ( mcastaddr ) ) && POKE_BYTES ( & hardware -> h_lladdr , ETHER_ADDR_LEN ) && POKE_UINT16 ( ETHERTYPE_LLDP ) ) ) goto toobig ; if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_CHASSIS_ID ) && POKE_UINT8 ( c_id_subtype ) && POKE_BYTES ( c_id , c_id_len ) && POKE_END_LLDP_TLV ) ) goto toobig ; if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_PORT_ID ) && POKE_UINT8 ( p_id_subtype ) && POKE_BYTES ( p_id , p_id_len ) && POKE_END_LLDP_TLV ) ) goto toobig ; if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_TTL ) && POKE_UINT16 ( shutdown ? 0 : chassis -> c_ttl ) && POKE_END_LLDP_TLV ) ) goto toobig ; if ( shutdown ) goto end ; if ( chassis -> c_name && * chassis -> c_name != '\\0' ) { if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_SYSTEM_NAME ) && POKE_BYTES ( chassis -> c_name , strlen ( chassis -> c_name ) ) && POKE_END_LLDP_TLV ) ) goto toobig ; } if ( chassis -> c_descr && * chassis -> c_descr != '\\0' ) { if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_SYSTEM_DESCR ) && POKE_BYTES ( chassis -> c_descr , strlen ( chassis -> c_descr ) ) && POKE_END_LLDP_TLV ) ) goto toobig ; } if ( global -> g_config . c_cap_advertise && chassis -> c_cap_available ) { if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_SYSTEM_CAP ) && POKE_UINT16 ( chassis -> c_cap_available ) && POKE_UINT16 ( chassis -> c_cap_enabled ) && POKE_END_LLDP_TLV ) ) goto toobig ; } TAILQ_FOREACH ( mgmt , & chassis -> c_mgmt , m_entries ) { proto = lldpd_af_to_lldp_proto ( mgmt -> m_family ) ;  assert ( proto != LLDP_MGMT_ADDR_NONE ) ;  if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_MGMT_ADDR ) && POKE_UINT8 ( mgmt -> m_addrsize + 1 ) && POKE_UINT8 ( proto ) && POKE_BYTES ( & mgmt -> m_addr , mgmt -> m_addrsize ) ) ) goto toobig ; if ( mgmt -> m_iface == 0 ) { if ( ! ( POKE_UINT8 ( LLDP_MGMT_IFACE_UNKNOWN ) && POKE_UINT32 ( 0 ) ) ) goto toobig ; } else { if ( ! ( POKE_UINT8 ( LLDP_MGMT_IFACE_IFINDEX ) && POKE_UINT32 ( mgmt -> m_iface ) ) ) goto toobig ; } if ( ! ( POKE_UINT8 ( 0 ) && POKE_END_LLDP_TLV ) ) goto toobig ; } if ( port -> p_descr && * port -> p_descr != '\\0' ) { if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_PORT_DESCR ) && POKE_BYTES ( port -> p_descr , strlen ( port -> p_descr ) ) && POKE_END_LLDP_TLV ) ) goto toobig ; } # ifdef ENABLE_DOT1 if ( port -> p_pvid != 0 ) { if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_ORG ) && POKE_BYTES ( dot1 , sizeof ( dot1 ) ) && POKE_UINT8 ( LLDP_TLV_DOT1_PVID ) && POKE_UINT16 ( port -> p_pvid ) && POKE_END_LLDP_TLV ) ) { goto toobig ; } } TAILQ_FOREACH ( ppvid , & port -> p_ppvids , p_entries ) { if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_ORG ) && POKE_BYTES ( dot1 , sizeof ( dot1 ) ) && POKE_UINT8 ( LLDP_TLV_DOT1_PPVID ) && POKE_UINT8 ( ppvid -> p_cap_status ) && POKE_UINT16 ( ppvid -> p_ppvid ) && POKE_END_LLDP_TLV ) ) { goto toobig ; } } TAILQ_FOREACH ( vlan , & port -> p_vlans , v_entries ) { if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_ORG ) && POKE_BYTES ( dot1 , sizeof ( dot1 ) ) && POKE_UINT8 ( LLDP_TLV_DOT1_VLANNAME ) && POKE_UINT16 ( vlan -> v_vid ) && POKE_UINT8 ( strlen ( vlan -> v_name ) ) && POKE_BYTES ( vlan -> v_name , strlen ( vlan -> v_name ) ) && POKE_END_LLDP_TLV ) ) goto toobig ; } TAILQ_FOREACH ( pi , & port -> p_pids , p_entries ) { if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_ORG ) && POKE_BYTES ( dot1 , sizeof ( dot1 ) ) && POKE_UINT8 ( LLDP_TLV_DOT1_PI ) && POKE_UINT8 ( pi -> p_pi_len ) && POKE_BYTES ( pi -> p_pi , pi -> p_pi_len ) && POKE_END_LLDP_TLV ) ) goto toobig ; } # endif # ifdef ENABLE_DOT3 if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_ORG ) && POKE_BYTES ( dot3 , sizeof ( dot3 ) ) && POKE_UINT8 ( LLDP_TLV_DOT3_LA ) && POKE_UINT8 ( ( port -> p_aggregid ) ? 3 : 1 ) && POKE_UINT32 ( port -> p_aggregid ) && POKE_END_LLDP_TLV ) ) goto toobig ; if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_ORG ) && POKE_BYTES ( dot3 , sizeof ( dot3 ) ) && POKE_UINT8 ( LLDP_TLV_DOT3_MAC ) && POKE_UINT8 ( port -> p_macphy . autoneg_support | ( port -> p_macphy . autoneg_enabled << 1 ) ) && POKE_UINT16 ( port -> p_macphy . autoneg_advertised ) && POKE_UINT16 ( port -> p_macphy . mau_type ) && POKE_END_LLDP_TLV ) ) goto toobig ; if ( port -> p_mfs ) { if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_ORG ) && POKE_BYTES ( dot3 , sizeof ( dot3 ) ) && POKE_UINT8 ( LLDP_TLV_DOT3_MFS ) && POKE_UINT16 ( port -> p_mfs ) && POKE_END_LLDP_TLV ) ) goto toobig ; } if ( port -> p_power . devicetype ) { if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_ORG ) && POKE_BYTES ( dot3 , sizeof ( dot3 ) ) && POKE_UINT8 ( LLDP_TLV_DOT3_POWER ) && POKE_UINT8 ( ( ( ( ( 2 - port -> p_power . devicetype ) % ( 1 << 1 ) ) << 0 ) | ( ( port -> p_power . supported % ( 1 << 1 ) ) << 1 ) | ( ( port -> p_power . enabled % ( 1 << 1 ) ) << 2 ) | ( ( port -> p_power . paircontrol % ( 1 << 1 ) ) << 3 ) ) ) && POKE_UINT8 ( port -> p_power . pairs ) && POKE_UINT8 ( port -> p_power . class ) ) ) goto toobig ; if ( port -> p_power . powertype != LLDP_DOT3_POWER_8023AT_OFF ) { if ( ! ( POKE_UINT8 ( ( ( ( ( port -> p_power . powertype == LLDP_DOT3_POWER_8023AT_TYPE1 ) ? 1 : 0 ) << 7 ) | ( ( ( port -> p_power . devicetype == LLDP_DOT3_POWER_PSE ) ? 0 : 1 ) << 6 ) | ( ( port -> p_power . source % ( 1 << 2 ) ) << 4 ) | ( ( port -> p_power . priority % ( 1 << 2 ) ) << 0 ) ) ) && POKE_UINT16 ( port -> p_power . requested ) && POKE_UINT16 ( port -> p_power . allocated ) ) ) goto toobig ; } if ( ! ( POKE_END_LLDP_TLV ) ) goto toobig ; } # endif # ifdef ENABLE_LLDPMED if ( port -> p_med_cap_enabled ) { if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_ORG ) && POKE_BYTES ( med , sizeof ( med ) ) && POKE_UINT8 ( LLDP_TLV_MED_CAP ) && POKE_UINT16 ( chassis -> c_med_cap_available ) && POKE_UINT8 ( chassis -> c_med_type ) && POKE_END_LLDP_TLV ) ) goto toobig ; # define LLDP_INVENTORY ( value , subtype ) if ( value ) { if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_ORG ) && POKE_BYTES ( med , sizeof ( med ) ) && POKE_UINT8 ( subtype ) && POKE_BYTES ( value , ( strlen ( value ) > 32 ) ? 32 : strlen ( value ) ) && POKE_END_LLDP_TLV ) ) goto toobig ; } if ( port -> p_med_cap_enabled & LLDP_MED_CAP_IV ) { LLDP_INVENTORY ( chassis -> c_med_hw , LLDP_TLV_MED_IV_HW ) ; LLDP_INVENTORY ( chassis -> c_med_fw , LLDP_TLV_MED_IV_FW ) ; LLDP_INVENTORY ( chassis -> c_med_sw , LLDP_TLV_MED_IV_SW ) ; LLDP_INVENTORY ( chassis -> c_med_sn , LLDP_TLV_MED_IV_SN ) ; LLDP_INVENTORY ( chassis -> c_med_manuf , LLDP_TLV_MED_IV_MANUF ) ; LLDP_INVENTORY ( chassis -> c_med_model , LLDP_TLV_MED_IV_MODEL ) ; LLDP_INVENTORY ( chassis -> c_med_asset , LLDP_TLV_MED_IV_ASSET ) ; } for ( i = 0 ; i < LLDP_MED_LOCFORMAT_LAST ; i ++ ) { if ( port -> p_med_location [ i ] . format == i + 1 ) { if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_ORG ) && POKE_BYTES ( med , sizeof ( med ) ) && POKE_UINT8 ( LLDP_TLV_MED_LOCATION ) && POKE_UINT8 ( port -> p_med_location [ i ] . format ) && POKE_BYTES ( port -> p_med_location [ i ] . data , port -> p_med_location [ i ] . data_len ) && POKE_END_LLDP_TLV ) ) goto toobig ; } } for ( i = 0 ; i < LLDP_MED_APPTYPE_LAST ; i ++ ) { if ( port -> p_med_policy [ i ] . type == i + 1 ) { if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_ORG ) && POKE_BYTES ( med , sizeof ( med ) ) && POKE_UINT8 ( LLDP_TLV_MED_POLICY ) && POKE_UINT32 ( ( ( ( port -> p_med_policy [ i ] . type % ( 1 << 8 ) ) << 24 ) | ( ( port -> p_med_policy [ i ] . unknown % ( 1 << 1 ) ) << 23 ) | ( ( port -> p_med_policy [ i ] . tagged % ( 1 << 1 ) ) << 22 ) | ( ( port -> p_med_policy [ i ] . vid % ( 1 << 12 ) ) << 9 ) | ( ( port -> p_med_policy [ i ] . priority % ( 1 << 3 ) ) << 6 ) | ( ( port -> p_med_policy [ i ] . dscp % ( 1 << 6 ) ) << 0 ) ) ) && POKE_END_LLDP_TLV ) ) goto toobig ; } } if ( ( port -> p_med_power . devicetype == LLDP_MED_POW_TYPE_PSE ) || ( port -> p_med_power . devicetype == LLDP_MED_POW_TYPE_PD ) ) { int devicetype = 0 , source = 0 ; if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_ORG ) && POKE_BYTES ( med , sizeof ( med ) ) && POKE_UINT8 ( LLDP_TLV_MED_MDI ) ) ) goto toobig ; switch ( port -> p_med_power . devicetype ) { case LLDP_MED_POW_TYPE_PSE : devicetype = 0 ; switch ( port -> p_med_power . source ) { case LLDP_MED_POW_SOURCE_PRIMARY : source = 1 ; break ; case LLDP_MED_POW_SOURCE_BACKUP : source = 2 ; break ; case LLDP_MED_POW_SOURCE_RESERVED : source = 3 ; break ; default : source = 0 ; break ; } break ; case LLDP_MED_POW_TYPE_PD : devicetype = 1 ; switch ( port -> p_med_power . source ) { case LLDP_MED_POW_SOURCE_PSE : source = 1 ; break ; case LLDP_MED_POW_SOURCE_LOCAL : source = 2 ; break ; case LLDP_MED_POW_SOURCE_BOTH : source = 3 ; break ; default : source = 0 ; break ; } break ; } if ( ! ( POKE_UINT8 ( ( ( ( devicetype % ( 1 << 2 ) ) << 6 ) | ( ( source % ( 1 << 2 ) ) << 4 ) | ( ( port -> p_med_power . priority % ( 1 << 4 ) ) << 0 ) ) ) && POKE_UINT16 ( port -> p_med_power . val ) && POKE_END_LLDP_TLV ) ) goto toobig ; } } # endif # ifdef ENABLE_CUSTOM TAILQ_FOREACH ( custom , & port -> p_custom_list , next ) { if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_ORG ) && POKE_BYTES ( custom -> oui , sizeof ( custom -> oui ) ) && POKE_UINT8 ( custom -> subtype ) && POKE_BYTES ( custom -> oui_info , custom -> oui_info_len ) && POKE_END_LLDP_TLV ) ) goto toobig ; } # endif end : if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_END ) && POKE_END_LLDP_TLV ) ) goto toobig ; if ( interfaces_send_helper ( global , hardware , ( char * ) packet , pos - packet ) == - 1 ) { log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>send<S2SV_blank>packet<S2SV_blank>on<S2SV_blank>real<S2SV_blank>device<S2SV_blank>for<S2SV_blank>%s"" , hardware -> h_ifname ) ; free ( packet ) ; return ENETDOWN ; } hardware -> h_tx_cnt ++ ; if ( ! shutdown && ( frame = ( struct lldpd_frame * ) malloc ( sizeof ( int ) + pos - packet ) ) != NULL ) { frame -> size = pos - packet ; memcpy ( & frame -> frame , packet , frame -> size ) ; if ( ( hardware -> h_lport . p_lastframe == NULL ) || ( hardware -> h_lport . p_lastframe -> size != frame -> size ) || ( memcmp ( hardware -> h_lport . p_lastframe -> frame , frame -> frame , frame -> size ) != 0 ) ) { free ( hardware -> h_lport . p_lastframe ) ; hardware -> h_lport . p_lastframe = frame ; hardware -> h_lport . p_lastchange = time ( NULL ) ; } else free ( frame ) ; } free ( packet ) ; return 0 ; toobig : free ( packet ) ; return E2BIG ; }","if ( proto == LLDP_MGMT_ADDR_NONE ) continue ;if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_MGMT_ADDR ) && POKE_UINT8 ( mgmt -> m_addrsize + 1 ) && POKE_UINT8 ( proto ) && POKE_BYTES ( & mgmt -> m_addr , mgmt -> m_addrsize ) ) ) goto toobig ;",127
179,"buggy line: if ( ( op & ASN1_OP_MATCH__COND && flags & FLAG_MATCHED ) ||  dp == datalen ) {flags &= ~ FLAG_LAST_MATCHED ;cwe id:CWE-310context: int asn1_ber_decoder ( const struct asn1_decoder * decoder , void * context , const unsigned char * data , size_t datalen ) { const unsigned char * machine = decoder -> machine ; const asn1_action_t * actions = decoder -> actions ; size_t machlen = decoder -> machlen ; enum asn1_opcode op ; unsigned char tag = 0 , csp = 0 , jsp = 0 , optag = 0 , hdr = 0 ; const char * errmsg ; size_t pc = 0 , dp = 0 , tdp = 0 , len = 0 ; int ret ; unsigned char flags = 0 ; # define FLAG_INDEFINITE_LENGTH 0x01 # define FLAG_MATCHED 0x02 # define FLAG_LAST_MATCHED 0x04 # define FLAG_CONS 0x20 # define NR_CONS_STACK 10 unsigned short cons_dp_stack [ NR_CONS_STACK ] ; unsigned short cons_datalen_stack [ NR_CONS_STACK ] ; unsigned char cons_hdrlen_stack [ NR_CONS_STACK ] ; # define NR_JUMP_STACK 10 unsigned char jump_stack [ NR_JUMP_STACK ] ; if ( datalen > 65535 ) return - EMSGSIZE ; next_op : pr_debug ( ""next_op:<S2SV_blank>pc=\\e[32m%zu\\e[m/%zu<S2SV_blank>dp=\\e[33m%zu\\e[m/%zu<S2SV_blank>C=%d<S2SV_blank>J=%d\\n"" , pc , machlen , dp , datalen , csp , jsp ) ; if ( unlikely ( pc >= machlen ) ) goto machine_overrun_error ; op = machine [ pc ] ; if ( unlikely ( pc + asn1_op_lengths [ op ] > machlen ) ) goto machine_overrun_error ; if ( op <= ASN1_OP__MATCHES_TAG ) { unsigned char tmp ; if ( ( op & ASN1_OP_MATCH__COND && flags & FLAG_MATCHED ) ||  dp == datalen ) {  flags &= ~ FLAG_LAST_MATCHED ; pc += asn1_op_lengths [ op ] ; goto next_op ; } flags = 0 ; hdr = 2 ; if ( unlikely ( dp >= datalen - 1 ) ) goto data_overrun_error ; tag = data [ dp ++ ] ; if ( unlikely ( ( tag & 0x1f ) == ASN1_LONG_TAG ) ) goto long_tag_not_supported ; if ( op & ASN1_OP_MATCH__ANY ) { pr_debug ( ""-<S2SV_blank>any<S2SV_blank>%02x\\n"" , tag ) ; } else { optag = machine [ pc + 1 ] ; flags |= optag & FLAG_CONS ; tmp = optag ^ tag ; tmp &= ~ ( optag & ASN1_CONS_BIT ) ; pr_debug ( ""-<S2SV_blank>match?<S2SV_blank>%02x<S2SV_blank>%02x<S2SV_blank>%02x\\n"" , tag , optag , tmp ) ; if ( tmp != 0 ) { if ( op & ASN1_OP_MATCH__SKIP ) { pc += asn1_op_lengths [ op ] ; dp -- ; goto next_op ; } goto tag_mismatch ; } } flags |= FLAG_MATCHED ; len = data [ dp ++ ] ; if ( len > 0x7f ) { if ( unlikely ( len == ASN1_INDEFINITE_LENGTH ) ) { if ( unlikely ( ! ( tag & ASN1_CONS_BIT ) ) ) goto indefinite_len_primitive ; flags |= FLAG_INDEFINITE_LENGTH ; if ( unlikely ( 2 > datalen - dp ) ) goto data_overrun_error ; } else { int n = len - 0x80 ; if ( unlikely ( n > 2 ) ) goto length_too_long ; if ( unlikely ( dp >= datalen - n ) ) goto data_overrun_error ; hdr += n ; for ( len = 0 ; n > 0 ; n -- ) { len <<= 8 ; len |= data [ dp ++ ] ; } if ( unlikely ( len > datalen - dp ) ) goto data_overrun_error ; } } if ( flags & FLAG_CONS ) { if ( unlikely ( csp >= NR_CONS_STACK ) ) goto cons_stack_overflow ; cons_dp_stack [ csp ] = dp ; cons_hdrlen_stack [ csp ] = hdr ; if ( ! ( flags & FLAG_INDEFINITE_LENGTH ) ) { cons_datalen_stack [ csp ] = datalen ; datalen = dp + len ; } else { cons_datalen_stack [ csp ] = 0 ; } csp ++ ; } pr_debug ( ""-<S2SV_blank>TAG:<S2SV_blank>%02x<S2SV_blank>%zu%s\\n"" , tag , len , flags & FLAG_CONS ? ""<S2SV_blank>CONS"" : """" ) ; tdp = dp ; } switch ( op ) { case ASN1_OP_MATCH_ANY_ACT : case ASN1_OP_COND_MATCH_ANY_ACT : ret = actions [ machine [ pc + 1 ] ] ( context , hdr , tag , data + dp , len ) ; if ( ret < 0 ) return ret ; goto skip_data ; case ASN1_OP_MATCH_ACT : case ASN1_OP_MATCH_ACT_OR_SKIP : case ASN1_OP_COND_MATCH_ACT_OR_SKIP : ret = actions [ machine [ pc + 2 ] ] ( context , hdr , tag , data + dp , len ) ; if ( ret < 0 ) return ret ; goto skip_data ; case ASN1_OP_MATCH : case ASN1_OP_MATCH_OR_SKIP : case ASN1_OP_MATCH_ANY : case ASN1_OP_COND_MATCH_OR_SKIP : case ASN1_OP_COND_MATCH_ANY : skip_data : if ( ! ( flags & FLAG_CONS ) ) { if ( flags & FLAG_INDEFINITE_LENGTH ) { ret = asn1_find_indefinite_length ( data , datalen , & dp , & len , & errmsg ) ; if ( ret < 0 ) goto error ; } else { dp += len ; } pr_debug ( ""-<S2SV_blank>LEAF:<S2SV_blank>%zu\\n"" , len ) ; } pc += asn1_op_lengths [ op ] ; goto next_op ; case ASN1_OP_MATCH_JUMP : case ASN1_OP_MATCH_JUMP_OR_SKIP : case ASN1_OP_COND_MATCH_JUMP_OR_SKIP : pr_debug ( ""-<S2SV_blank>MATCH_JUMP\\n"" ) ; if ( unlikely ( jsp == NR_JUMP_STACK ) ) goto jump_stack_overflow ; jump_stack [ jsp ++ ] = pc + asn1_op_lengths [ op ] ; pc = machine [ pc + 2 ] ; goto next_op ; case ASN1_OP_COND_FAIL : if ( unlikely ( ! ( flags & FLAG_MATCHED ) ) ) goto tag_mismatch ; pc += asn1_op_lengths [ op ] ; goto next_op ; case ASN1_OP_COMPLETE : if ( unlikely ( jsp != 0 || csp != 0 ) ) { pr_err ( ""ASN.1<S2SV_blank>decoder<S2SV_blank>error:<S2SV_blank>Stacks<S2SV_blank>not<S2SV_blank>empty<S2SV_blank>at<S2SV_blank>completion<S2SV_blank>(%u,<S2SV_blank>%u)\\n"" , jsp , csp ) ; return - EBADMSG ; } return 0 ; case ASN1_OP_END_SET : case ASN1_OP_END_SET_ACT : if ( unlikely ( ! ( flags & FLAG_MATCHED ) ) ) goto tag_mismatch ; case ASN1_OP_END_SEQ : case ASN1_OP_END_SET_OF : case ASN1_OP_END_SEQ_OF : case ASN1_OP_END_SEQ_ACT : case ASN1_OP_END_SET_OF_ACT : case ASN1_OP_END_SEQ_OF_ACT : if ( unlikely ( csp <= 0 ) ) goto cons_stack_underflow ; csp -- ; tdp = cons_dp_stack [ csp ] ; hdr = cons_hdrlen_stack [ csp ] ; len = datalen ; datalen = cons_datalen_stack [ csp ] ; pr_debug ( ""-<S2SV_blank>end<S2SV_blank>cons<S2SV_blank>t=%zu<S2SV_blank>dp=%zu<S2SV_blank>l=%zu/%zu\\n"" , tdp , dp , len , datalen ) ; if ( datalen == 0 ) { datalen = len ; if ( unlikely ( datalen - dp < 2 ) ) goto data_overrun_error ; if ( data [ dp ++ ] != 0 ) { if ( op & ASN1_OP_END__OF ) { dp -- ; csp ++ ; pc = machine [ pc + 1 ] ; pr_debug ( ""-<S2SV_blank>continue\\n"" ) ; goto next_op ; } goto missing_eoc ; } if ( data [ dp ++ ] != 0 ) goto invalid_eoc ; len = dp - tdp - 2 ; } else { if ( dp < len && ( op & ASN1_OP_END__OF ) ) { datalen = len ; csp ++ ; pc = machine [ pc + 1 ] ; pr_debug ( ""-<S2SV_blank>continue\\n"" ) ; goto next_op ; } if ( dp != len ) goto cons_length_error ; len -= tdp ; pr_debug ( ""-<S2SV_blank>cons<S2SV_blank>len<S2SV_blank>l=%zu<S2SV_blank>d=%zu\\n"" , len , dp - tdp ) ; } if ( op & ASN1_OP_END__ACT ) { unsigned char act ; if ( op & ASN1_OP_END__OF ) act = machine [ pc + 2 ] ; else act = machine [ pc + 1 ] ; ret = actions [ act ] ( context , hdr , 0 , data + tdp , len ) ; } pc += asn1_op_lengths [ op ] ; goto next_op ; case ASN1_OP_MAYBE_ACT : if ( ! ( flags & FLAG_LAST_MATCHED ) ) { pc += asn1_op_lengths [ op ] ; goto next_op ; } case ASN1_OP_ACT : ret = actions [ machine [ pc + 1 ] ] ( context , hdr , tag , data + tdp , len ) ; if ( ret < 0 ) return ret ; pc += asn1_op_lengths [ op ] ; goto next_op ; case ASN1_OP_RETURN : if ( unlikely ( jsp <= 0 ) ) goto jump_stack_underflow ; pc = jump_stack [ -- jsp ] ; flags |= FLAG_MATCHED | FLAG_LAST_MATCHED ; goto next_op ; default : break ; } pr_err ( ""ASN.1<S2SV_blank>decoder<S2SV_blank>error:<S2SV_blank>Found<S2SV_blank>reserved<S2SV_blank>opcode<S2SV_blank>(%u)<S2SV_blank>pc=%zu\\n"" , op , pc ) ; return - EBADMSG ; data_overrun_error : errmsg = ""Data<S2SV_blank>overrun<S2SV_blank>error"" ; goto error ; machine_overrun_error : errmsg = ""Machine<S2SV_blank>overrun<S2SV_blank>error"" ; goto error ; jump_stack_underflow : errmsg = ""Jump<S2SV_blank>stack<S2SV_blank>underflow"" ; goto error ; jump_stack_overflow : errmsg = ""Jump<S2SV_blank>stack<S2SV_blank>overflow"" ; goto error ; cons_stack_underflow : errmsg = ""Cons<S2SV_blank>stack<S2SV_blank>underflow"" ; goto error ; cons_stack_overflow : errmsg = ""Cons<S2SV_blank>stack<S2SV_blank>overflow"" ; goto error ; cons_length_error : errmsg = ""Cons<S2SV_blank>length<S2SV_blank>error"" ; goto error ; missing_eoc : errmsg = ""Missing<S2SV_blank>EOC<S2SV_blank>in<S2SV_blank>indefinite<S2SV_blank>len<S2SV_blank>cons"" ; goto error ; invalid_eoc : errmsg = ""Invalid<S2SV_blank>length<S2SV_blank>EOC"" ; goto error ; length_too_long : errmsg = ""Unsupported<S2SV_blank>length"" ; goto error ; indefinite_len_primitive : errmsg = ""Indefinite<S2SV_blank>len<S2SV_blank>primitive<S2SV_blank>not<S2SV_blank>permitted"" ; goto error ; tag_mismatch : errmsg = ""Unexpected<S2SV_blank>tag"" ; goto error ; long_tag_not_supported : errmsg = ""Long<S2SV_blank>tag<S2SV_blank>not<S2SV_blank>supported"" ; error : pr_debug ( ""\\nASN1:<S2SV_blank>%s<S2SV_blank>[m=%zu<S2SV_blank>d=%zu<S2SV_blank>ot=%02x<S2SV_blank>t=%02x<S2SV_blank>l=%zu]\\n"" , errmsg , pc , dp , optag , tag , len ) ; return - EBADMSG ; }",if ( ( op & ASN1_OP_MATCH__COND && flags & FLAG_MATCHED ) || ( op & ASN1_OP_MATCH__SKIP && dp == datalen ) ) {flags &= ~ FLAG_LAST_MATCHED ;,128
180,"buggy line: list_add_tail ( & sp -> auto_asconf_list ,  & net -> sctp . auto_asconf_splist ) ;sp -> do_auto_asconf = 1 ;}else   sp -> do_auto_asconf = 0 ;local_bh_enable ( ) ;cwe id:CWE-362context: static int sctp_init_sock ( struct sock * sk ) { struct net * net = sock_net ( sk ) ; struct sctp_sock * sp ; pr_debug ( ""%s:<S2SV_blank>sk:%p\\n"" , __func__ , sk ) ; sp = sctp_sk ( sk ) ; switch ( sk -> sk_type ) { case SOCK_SEQPACKET : sp -> type = SCTP_SOCKET_UDP ; break ; case SOCK_STREAM : sp -> type = SCTP_SOCKET_TCP ; break ; default : return - ESOCKTNOSUPPORT ; } sp -> default_stream = 0 ; sp -> default_ppid = 0 ; sp -> default_flags = 0 ; sp -> default_context = 0 ; sp -> default_timetolive = 0 ; sp -> default_rcv_context = 0 ; sp -> max_burst = net -> sctp . max_burst ; sp -> sctp_hmac_alg = net -> sctp . sctp_hmac_alg ; sp -> initmsg . sinit_num_ostreams = sctp_max_outstreams ; sp -> initmsg . sinit_max_instreams = sctp_max_instreams ; sp -> initmsg . sinit_max_attempts = net -> sctp . max_retrans_init ; sp -> initmsg . sinit_max_init_timeo = net -> sctp . rto_max ; sp -> rtoinfo . srto_initial = net -> sctp . rto_initial ; sp -> rtoinfo . srto_max = net -> sctp . rto_max ; sp -> rtoinfo . srto_min = net -> sctp . rto_min ; sp -> assocparams . sasoc_asocmaxrxt = net -> sctp . max_retrans_association ; sp -> assocparams . sasoc_number_peer_destinations = 0 ; sp -> assocparams . sasoc_peer_rwnd = 0 ; sp -> assocparams . sasoc_local_rwnd = 0 ; sp -> assocparams . sasoc_cookie_life = net -> sctp . valid_cookie_life ; memset ( & sp -> subscribe , 0 , sizeof ( struct sctp_event_subscribe ) ) ; sp -> hbinterval = net -> sctp . hb_interval ; sp -> pathmaxrxt = net -> sctp . max_retrans_path ; sp -> pathmtu = 0 ; sp -> sackdelay = net -> sctp . sack_timeout ; sp -> sackfreq = 2 ; sp -> param_flags = SPP_HB_ENABLE | SPP_PMTUD_ENABLE | SPP_SACKDELAY_ENABLE ; sp -> disable_fragments = 0 ; sp -> nodelay = 0 ; sp -> recvrcvinfo = 0 ; sp -> recvnxtinfo = 0 ; sp -> v4mapped = 1 ; sp -> autoclose = 0 ; sp -> user_frag = 0 ; sp -> adaptation_ind = 0 ; sp -> pf = sctp_get_pf_specific ( sk -> sk_family ) ; atomic_set ( & sp -> pd_mode , 0 ) ; skb_queue_head_init ( & sp -> pd_lobby ) ; sp -> frag_interleave = 0 ; sp -> ep = sctp_endpoint_new ( sk , GFP_KERNEL ) ; if ( ! sp -> ep ) return - ENOMEM ; sp -> hmac = NULL ; sk -> sk_destruct = sctp_destruct_sock ; SCTP_DBG_OBJCNT_INC ( sock ) ; local_bh_disable ( ) ; percpu_counter_inc ( & sctp_sockets_allocated ) ; sock_prot_inuse_add ( net , sk -> sk_prot , 1 ) ; if ( net -> sctp . default_auto_asconf ) {  list_add_tail ( & sp -> auto_asconf_list ,  & net -> sctp . auto_asconf_splist ) ;  sp -> do_auto_asconf = 1 ;   } else   sp -> do_auto_asconf = 0 ;  local_bh_enable ( ) ; return 0 ; }","spin_lock ( & sock_net ( sk ) -> sctp . addr_wq_lock ) ;list_add_tail ( & sp -> auto_asconf_list , & net -> sctp . auto_asconf_splist ) ;sp -> do_auto_asconf = 1 ;spin_unlock ( & sock_net ( sk ) -> sctp . addr_wq_lock ) ;}else {sp -> do_auto_asconf = 0 ;}local_bh_enable ( ) ;",129
181,"buggy line: static int mpeg4_decode_profile_level ( MpegEncContext * s , GetBitContext * gb )  {s -> avctx -> profile = get_bits ( gb , 4 ) ;s -> avctx -> level = get_bits ( gb , 4 ) ;if ( s -> avctx -> profile == 0 && s -> avctx -> level == 8 ) {s -> avctx -> level = 0 ;}cwe id:CWE-476context:  static int mpeg4_decode_profile_level ( MpegEncContext * s , GetBitContext * gb )  { s -> avctx -> profile = get_bits ( gb , 4 ) ;  s -> avctx -> level = get_bits ( gb , 4 ) ;   if ( s -> avctx -> profile == 0 && s -> avctx -> level == 8 ) {   s -> avctx -> level = 0 ;  } return 0 ; }","static int mpeg4_decode_profile_level ( MpegEncContext * s , GetBitContext * gb , int * profile , int * level ) {* profile = get_bits ( gb , 4 ) ;* level = get_bits ( gb , 4 ) ;if ( * profile == 0 && s -> avctx -> level == 8 ) {* level = 0 ;}",130
182,"buggy line: spin_lock_irqsave ( & mpu -> input_lock , flags ) ;while ( readw ( mpu -> dev -> MIDQ + JQS_wTail ) !=  readw ( mpu -> dev -> MIDQ + JQS_wHead ) ) {u16 wTmp , val ;val = readw ( pwMIDQData + 2 * readw ( mpu -> dev -> MIDQ + JQS_wHead ) ) ;if ( test_bit ( MSNDMIDI_MODE_BIT_INPUT_TRIGGER , & mpu -> mode ) ) snd_rawmidi_receive ( mpu -> substream_input , ( unsigned char * ) & val , 1 ) ;wTmp = readw ( mpu -> dev -> MIDQ + JQS_wHead ) + 1 ;if ( wTmp > readw ( mpu -> dev -> MIDQ + JQS_wSize ) ) writew ( 0 , mpu -> dev -> MIDQ + JQS_wHead ) ;else writew ( wTmp , mpu -> dev -> MIDQ + JQS_wHead ) ;spin_unlock_irqrestore ( & mpu -> input_lock , flags ) ;cwe id:CWE-125context: void snd_msndmidi_input_read ( void * mpuv ) { unsigned long flags ; struct snd_msndmidi * mpu = mpuv ; void * pwMIDQData = mpu -> dev -> mappedbase + MIDQ_DATA_BUFF ;  spin_lock_irqsave ( & mpu -> input_lock , flags ) ;   while ( readw ( mpu -> dev -> MIDQ + JQS_wTail ) !=  readw ( mpu -> dev -> MIDQ + JQS_wHead ) ) { u16 wTmp , val ; val = readw ( pwMIDQData + 2 * readw ( mpu -> dev -> MIDQ + JQS_wHead ) ) ; if ( test_bit ( MSNDMIDI_MODE_BIT_INPUT_TRIGGER , & mpu -> mode ) ) snd_rawmidi_receive ( mpu -> substream_input , ( unsigned char * ) & val , 1 ) ;  wTmp = readw ( mpu -> dev -> MIDQ + JQS_wHead ) + 1 ;  if ( wTmp > readw ( mpu -> dev -> MIDQ + JQS_wSize ) ) writew ( 0 , mpu -> dev -> MIDQ + JQS_wHead ) ; else writew ( wTmp , mpu -> dev -> MIDQ + JQS_wHead ) ; } spin_unlock_irqrestore ( & mpu -> input_lock , flags ) ; }","u16 head , tail , size ;spin_lock_irqsave ( & mpu -> input_lock , flags ) ;head = readw ( mpu -> dev -> MIDQ + JQS_wHead ) ;tail = readw ( mpu -> dev -> MIDQ + JQS_wTail ) ;size = readw ( mpu -> dev -> MIDQ + JQS_wSize ) ;if ( head > size || tail > size ) goto out ;while ( head != tail ) {unsigned char val = readw ( pwMIDQData + 2 * head ) ;if ( test_bit ( MSNDMIDI_MODE_BIT_INPUT_TRIGGER , & mpu -> mode ) ) snd_rawmidi_receive ( mpu -> substream_input , & val , 1 ) ;if ( ++ head > size ) head = 0 ;writew ( head , mpu -> dev -> MIDQ + JQS_wHead ) ;out : spin_unlock_irqrestore ( & mpu -> input_lock , flags ) ;",131
183,"buggy line: return result ;}cwe id:CWE-264context: static int ima_lsm_rule_init ( struct ima_measure_rule_entry * entry , char * args , int lsm_rule , int audit_type ) { int result ; if ( entry -> lsm [ lsm_rule ] . rule ) return - EINVAL ; entry -> lsm [ lsm_rule ] . type = audit_type ; result = security_filter_rule_init ( entry -> lsm [ lsm_rule ] . type , Audit_equal , args , & entry -> lsm [ lsm_rule ] . rule ) ;  return result ;  }",if ( ! entry -> lsm [ lsm_rule ] . rule ) return - EINVAL ;return result ;},132
184,buggy line: file_sb_list_del ( file ) ;file_free ( file ) ;cwe id:CWE-17context: void put_filp ( struct file * file ) { if ( atomic_long_dec_and_test ( & file -> f_count ) ) { security_file_free ( file ) ;  file_sb_list_del ( file ) ;  file_free ( file ) ; } },file_free ( file ) ;,133
185,"buggy line: passert ( GLOBALS_ARE_RESET ( ) ) ;}cwe id:CWE-20context: static void ikev2_parent_inI1outR1_continue ( struct pluto_crypto_req_cont * pcrc , struct pluto_crypto_req * r , err_t ugh ) { struct ke_continuation * ke = ( struct ke_continuation * ) pcrc ; struct msg_digest * md = ke -> md ; struct state * const st = md -> st ; stf_status e ; DBG ( DBG_CONTROLMORE , DBG_log ( ""ikev2<S2SV_blank>parent<S2SV_blank>inI1outR1:<S2SV_blank>calculated<S2SV_blank>ke+nonce,<S2SV_blank>sending<S2SV_blank>R1"" ) ) ; if ( st == NULL ) { loglog ( RC_LOG_SERIOUS , ""%s:<S2SV_blank>Request<S2SV_blank>was<S2SV_blank>disconnected<S2SV_blank>from<S2SV_blank>state"" , __FUNCTION__ ) ; if ( ke -> md ) release_md ( ke -> md ) ; return ; } passert ( ugh == NULL ) ; passert ( cur_state == NULL ) ; passert ( st != NULL ) ; passert ( st -> st_suspended_md == ke -> md ) ; set_suspended ( st , NULL ) ; set_cur_state ( st ) ; st -> st_calculating = FALSE ; e = ikev2_parent_inI1outR1_tail ( pcrc , r ) ; if ( ke -> md != NULL ) { complete_v2_state_transition ( & ke -> md , e ) ; if ( ke -> md ) release_md ( ke -> md ) ; } reset_globals ( ) ;  passert ( GLOBALS_ARE_RESET ( ) ) ;  }",},134
186,"buggy line: \\\\\\cwe id:CWE-79context: static int oidc_handle_session_management_iframe_rp ( request_rec * r , oidc_cfg * c , oidc_session_t * session , const char * client_id , const char * check_session_iframe ) { oidc_debug ( r , ""enter"" ) ; const char * java_script = ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><script<S2SV_blank>type=\\""text/javascript\\"">\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>targetOrigin<S2SV_blank><S2SV_blank>=<S2SV_blank>\'%s\';\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>message<S2SV_blank>=<S2SV_blank>\'%s\'<S2SV_blank>+<S2SV_blank>\'<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>\'%s\';\\n"" ""\t<S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>timerID;\\n"" ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>checkSession()<S2SV_blank>{\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>console.debug(\'checkSession:<S2SV_blank>posting<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>message<S2SV_blank>+<S2SV_blank>\'<S2SV_blank>to<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>targetOrigin);\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>win<S2SV_blank>=<S2SV_blank>window.parent.document.getElementById(\'%s\').contentWindow;\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>win.postMessage(<S2SV_blank>message,<S2SV_blank>targetOrigin);\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>setTimer()<S2SV_blank>{\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>checkSession();\\n""  ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>timerID<S2SV_blank>=<S2SV_blank>setInterval(\'checkSession()\',<S2SV_blank>%s);\\n""  ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>receiveMessage(e)<S2SV_blank>{\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>console.debug(\'receiveMessage:<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>e.data<S2SV_blank>+<S2SV_blank>\'<S2SV_blank>from<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>e.origin);\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>if<S2SV_blank>(e.origin<S2SV_blank>!==<S2SV_blank>targetOrigin<S2SV_blank>)<S2SV_blank>{\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>console.debug(\'receiveMessage:<S2SV_blank>cross-site<S2SV_blank>scripting<S2SV_blank>attack?\');\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>return;\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>if<S2SV_blank>(e.data<S2SV_blank>!=<S2SV_blank>\'unchanged\')<S2SV_blank>{\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>clearInterval(timerID);\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>if<S2SV_blank>(e.data<S2SV_blank>==<S2SV_blank>\'changed\')<S2SV_blank>{\\n"" ""\t\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>window.location.href<S2SV_blank>=<S2SV_blank>\'%s?session=check\';\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}<S2SV_blank>else<S2SV_blank>{\\n"" ""\t\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>window.location.href<S2SV_blank>=<S2SV_blank>\'%s?session=logout\';\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>window.addEventListener(\'message\',<S2SV_blank>receiveMessage,<S2SV_blank>false);\\n"" ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank></script>\\n"" ; char * origin = apr_pstrdup ( r -> pool , check_session_iframe ) ; apr_uri_t uri ; apr_uri_parse ( r -> pool , check_session_iframe , & uri ) ; char * p = strstr ( origin , uri . path ) ; * p = '\\0' ; const char * op_iframe_id = ""openidc-op"" ; const char * session_state = oidc_session_get_session_state ( r , session ) ; if ( session_state == NULL ) { oidc_warn ( r , ""no<S2SV_blank>session_state<S2SV_blank>found<S2SV_blank>in<S2SV_blank>the<S2SV_blank>session;<S2SV_blank>the<S2SV_blank>OP<S2SV_blank>does<S2SV_blank>probably<S2SV_blank>not<S2SV_blank>support<S2SV_blank>session<S2SV_blank>management!?"" ) ; return DONE ; } char * s_poll_interval = NULL ; oidc_util_get_request_parameter ( r , ""poll"" , & s_poll_interval ) ;  if ( s_poll_interval == NULL )  s_poll_interval = ""3000"" ; const char * redirect_uri = oidc_get_redirect_uri ( r , c ) ; java_script = apr_psprintf ( r -> pool , java_script , origin , client_id ,  session_state , op_iframe_id , s_poll_interval , redirect_uri ,  redirect_uri ) ; return oidc_util_html_send ( r , NULL , java_script , ""setTimer"" , NULL , DONE ) ; }",\\\\\\,135
187,"buggy line: if ( s_poll_interval == NULL )  s_poll_interval = ""3000"" ;java_script = apr_psprintf ( r -> pool , java_script , origin , client_id ,  session_state , op_iframe_id , s_poll_interval , redirect_uri ,  redirect_uri ) ;cwe id:CWE-79context: static int oidc_handle_session_management_iframe_rp ( request_rec * r , oidc_cfg * c , oidc_session_t * session , const char * client_id , const char * check_session_iframe ) { oidc_debug ( r , ""enter"" ) ; const char * java_script = ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><script<S2SV_blank>type=\\""text/javascript\\"">\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>targetOrigin<S2SV_blank><S2SV_blank>=<S2SV_blank>\'%s\';\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>message<S2SV_blank>=<S2SV_blank>\'%s\'<S2SV_blank>+<S2SV_blank>\'<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>\'%s\';\\n"" ""\t<S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>timerID;\\n"" ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>checkSession()<S2SV_blank>{\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>console.debug(\'checkSession:<S2SV_blank>posting<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>message<S2SV_blank>+<S2SV_blank>\'<S2SV_blank>to<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>targetOrigin);\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>win<S2SV_blank>=<S2SV_blank>window.parent.document.getElementById(\'%s\').contentWindow;\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>win.postMessage(<S2SV_blank>message,<S2SV_blank>targetOrigin);\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>setTimer()<S2SV_blank>{\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>checkSession();\\n""  ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>timerID<S2SV_blank>=<S2SV_blank>setInterval(\'checkSession()\',<S2SV_blank>%s);\\n""  ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>receiveMessage(e)<S2SV_blank>{\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>console.debug(\'receiveMessage:<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>e.data<S2SV_blank>+<S2SV_blank>\'<S2SV_blank>from<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>e.origin);\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>if<S2SV_blank>(e.origin<S2SV_blank>!==<S2SV_blank>targetOrigin<S2SV_blank>)<S2SV_blank>{\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>console.debug(\'receiveMessage:<S2SV_blank>cross-site<S2SV_blank>scripting<S2SV_blank>attack?\');\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>return;\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>if<S2SV_blank>(e.data<S2SV_blank>!=<S2SV_blank>\'unchanged\')<S2SV_blank>{\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>clearInterval(timerID);\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>if<S2SV_blank>(e.data<S2SV_blank>==<S2SV_blank>\'changed\')<S2SV_blank>{\\n"" ""\t\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>window.location.href<S2SV_blank>=<S2SV_blank>\'%s?session=check\';\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}<S2SV_blank>else<S2SV_blank>{\\n"" ""\t\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>window.location.href<S2SV_blank>=<S2SV_blank>\'%s?session=logout\';\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>window.addEventListener(\'message\',<S2SV_blank>receiveMessage,<S2SV_blank>false);\\n"" ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank></script>\\n"" ; char * origin = apr_pstrdup ( r -> pool , check_session_iframe ) ; apr_uri_t uri ; apr_uri_parse ( r -> pool , check_session_iframe , & uri ) ; char * p = strstr ( origin , uri . path ) ; * p = '\\0' ; const char * op_iframe_id = ""openidc-op"" ; const char * session_state = oidc_session_get_session_state ( r , session ) ; if ( session_state == NULL ) { oidc_warn ( r , ""no<S2SV_blank>session_state<S2SV_blank>found<S2SV_blank>in<S2SV_blank>the<S2SV_blank>session;<S2SV_blank>the<S2SV_blank>OP<S2SV_blank>does<S2SV_blank>probably<S2SV_blank>not<S2SV_blank>support<S2SV_blank>session<S2SV_blank>management!?"" ) ; return DONE ; } char * s_poll_interval = NULL ; oidc_util_get_request_parameter ( r , ""poll"" , & s_poll_interval ) ;  if ( s_poll_interval == NULL )  s_poll_interval = ""3000"" ; const char * redirect_uri = oidc_get_redirect_uri ( r , c ) ; java_script = apr_psprintf ( r -> pool , java_script , origin , client_id ,  session_state , op_iframe_id , s_poll_interval , redirect_uri ,  redirect_uri ) ; return oidc_util_html_send ( r , NULL , java_script , ""setTimer"" , NULL , DONE ) ; }","int poll_interval = s_poll_interval ? strtol ( s_poll_interval , NULL , 10 ) : 0 ;if ( ( poll_interval <= 0 ) || ( poll_interval > 3600 * 24 ) ) poll_interval = 3000 ;java_script = apr_psprintf ( r -> pool , java_script , origin , client_id , session_state , op_iframe_id , poll_interval , redirect_uri , redirect_uri ) ;",135
188,"buggy line: static int decode_getacl ( struct xdr_stream * xdr , struct rpc_rqst * req ,  size_t * acl_len )  {__be32 * savep ;uint32_t attrlen , bitmap [ 3 ] = {* acl_len = 0 ;if ( ( status = decode_op_hdr ( xdr , OP_GETATTR ) ) != 0 )  goto out ;if ( ( status = decode_attr_bitmap ( xdr , bitmap ) ) != 0 ) goto out ;hdrlen = ( u8 * ) xdr -> p - ( u8 * ) iov -> iov_base ;recvd = req -> rq_rcv_buf . len - hdrlen ;dprintk ( ""NFS:<S2SV_blank>server<S2SV_blank>cheating<S2SV_blank>in<S2SV_blank>getattr""  ""<S2SV_blank>acl<S2SV_blank>reply:<S2SV_blank>attrlen<S2SV_blank>%u<S2SV_blank>><S2SV_blank>recvd<S2SV_blank>%u\\\* acl_len = attrlen ;}cwe id:CWE-189context: static int decode_getacl ( struct xdr_stream * xdr , struct rpc_rqst * req ,  size_t * acl_len )  {  __be32 * savep ;  uint32_t attrlen , bitmap [ 3 ] = { 0 } ; struct kvec * iov = req -> rq_rcv_buf . head ; int status ;  * acl_len = 0 ;  if ( ( status = decode_op_hdr ( xdr , OP_GETATTR ) ) != 0 )  goto out ;  if ( ( status = decode_attr_bitmap ( xdr , bitmap ) ) != 0 ) goto out ; if ( ( status = decode_attr_length ( xdr , & attrlen , & savep ) ) != 0 ) goto out ; if ( unlikely ( bitmap [ 0 ] & ( FATTR4_WORD0_ACL - 1U ) ) ) return - EIO ; if ( likely ( bitmap [ 0 ] & FATTR4_WORD0_ACL ) ) { size_t hdrlen ; u32 recvd ;  hdrlen = ( u8 * ) xdr -> p - ( u8 * ) iov -> iov_base ;  recvd = req -> rq_rcv_buf . len - hdrlen ; if ( attrlen > recvd ) {  dprintk ( ""NFS:<S2SV_blank>server<S2SV_blank>cheating<S2SV_blank>in<S2SV_blank>getattr""  ""<S2SV_blank>acl<S2SV_blank>reply:<S2SV_blank>attrlen<S2SV_blank>%u<S2SV_blank>><S2SV_blank>recvd<S2SV_blank>%u\\n"" , attrlen , recvd ) ; return - EINVAL ; } xdr_read_pages ( xdr , attrlen ) ;  * acl_len = attrlen ;  } else status = - EOPNOTSUPP ; out : return status ; }","static int decode_getacl ( struct xdr_stream * xdr , struct rpc_rqst * req , struct nfs_getaclres * res ) {__be32 * savep , * bm_p ;uint32_t attrlen , bitmap [ 3 ] = {res -> acl_len = 0 ;if ( ( status = decode_op_hdr ( xdr , OP_GETATTR ) ) != 0 ) goto out ;bm_p = xdr -> p ;if ( ( status = decode_attr_bitmap ( xdr , bitmap ) ) != 0 ) goto out ;xdr -> p = bm_p ;res -> acl_data_offset = be32_to_cpup ( bm_p ) + 2 ;res -> acl_data_offset <<= 2 ;hdrlen = ( u8 * ) xdr -> p - ( u8 * ) iov -> iov_base ;attrlen += res -> acl_data_offset ;recvd = req -> rq_rcv_buf . len - hdrlen ;if ( res -> acl_flags & NFS4_ACL_LEN_REQUEST ) {res -> acl_len = attrlen ;goto out ;}dprintk ( ""NFS:<S2SV_blank>acl<S2SV_blank>reply:<S2SV_blank>attrlen<S2SV_blank>%u<S2SV_blank>><S2SV_blank>recvd<S2SV_blank>%u\\\res -> acl_len = attrlen ;}",136
189,"buggy line: nexthdr = * prevhdr ;* prevhdr = NEXTHDR_FRAGMENT ;cwe id:CWE-125context: static struct sk_buff * udp6_ufo_fragment ( struct sk_buff * skb , netdev_features_t features ) { struct sk_buff * segs = ERR_PTR ( - EINVAL ) ; unsigned int mss ; unsigned int unfrag_ip6hlen , unfrag_len ; struct frag_hdr * fptr ; u8 * packet_start , * prevhdr ; u8 nexthdr ; u8 frag_hdr_sz = sizeof ( struct frag_hdr ) ; __wsum csum ; int tnl_hlen ; mss = skb_shinfo ( skb ) -> gso_size ; if ( unlikely ( skb -> len <= mss ) ) goto out ; if ( skb_gso_ok ( skb , features | NETIF_F_GSO_ROBUST ) ) { skb_shinfo ( skb ) -> gso_segs = DIV_ROUND_UP ( skb -> len , mss ) ; if ( ! skb_shinfo ( skb ) -> ip6_frag_id ) ipv6_proxy_select_ident ( dev_net ( skb -> dev ) , skb ) ; segs = NULL ; goto out ; } if ( skb -> encapsulation && skb_shinfo ( skb ) -> gso_type & ( SKB_GSO_UDP_TUNNEL | SKB_GSO_UDP_TUNNEL_CSUM ) ) segs = skb_udp_tunnel_segment ( skb , features , true ) ; else { const struct ipv6hdr * ipv6h ; struct udphdr * uh ; if ( ! pskb_may_pull ( skb , sizeof ( struct udphdr ) ) ) goto out ; uh = udp_hdr ( skb ) ; ipv6h = ipv6_hdr ( skb ) ; uh -> check = 0 ; csum = skb_checksum ( skb , 0 , skb -> len , 0 ) ; uh -> check = udp_v6_check ( skb -> len , & ipv6h -> saddr , & ipv6h -> daddr , csum ) ; if ( uh -> check == 0 ) uh -> check = CSUM_MANGLED_0 ; skb -> ip_summed = CHECKSUM_NONE ; if ( ! skb -> encap_hdr_csum ) features |= NETIF_F_HW_CSUM ; tnl_hlen = skb_tnl_header_len ( skb ) ; if ( skb -> mac_header < ( tnl_hlen + frag_hdr_sz ) ) { if ( gso_pskb_expand_head ( skb , tnl_hlen + frag_hdr_sz ) ) goto out ; } unfrag_ip6hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ;  nexthdr = * prevhdr ;  * prevhdr = NEXTHDR_FRAGMENT ; unfrag_len = ( skb_network_header ( skb ) - skb_mac_header ( skb ) ) + unfrag_ip6hlen + tnl_hlen ; packet_start = ( u8 * ) skb -> head + SKB_GSO_CB ( skb ) -> mac_offset ; memmove ( packet_start - frag_hdr_sz , packet_start , unfrag_len ) ; SKB_GSO_CB ( skb ) -> mac_offset -= frag_hdr_sz ; skb -> mac_header -= frag_hdr_sz ; skb -> network_header -= frag_hdr_sz ; fptr = ( struct frag_hdr * ) ( skb_network_header ( skb ) + unfrag_ip6hlen ) ; fptr -> nexthdr = nexthdr ; fptr -> reserved = 0 ; if ( ! skb_shinfo ( skb ) -> ip6_frag_id ) ipv6_proxy_select_ident ( dev_net ( skb -> dev ) , skb ) ; fptr -> identification = skb_shinfo ( skb ) -> ip6_frag_id ; segs = skb_segment ( skb , features ) ; } out : return segs ; }",if ( unfrag_ip6hlen < 0 ) return ERR_PTR ( unfrag_ip6hlen ) ;nexthdr = * prevhdr ;* prevhdr = NEXTHDR_FRAGMENT ;,137
190,"buggy line: while ( ( tmpName [ i ] != 0 ) && ( i < to_read ) ) {i ++ ;cwe id:CWE-125context: GF_Err urn_Read ( GF_Box * s , GF_BitStream * bs ) { u32 i , to_read ; char * tmpName ; GF_DataEntryURNBox * ptr = ( GF_DataEntryURNBox * ) s ; if ( ! ptr -> size ) return GF_OK ; to_read = ( u32 ) ptr -> size ; tmpName = ( char * ) gf_malloc ( sizeof ( char ) * to_read ) ; if ( ! tmpName ) return GF_OUT_OF_MEM ; gf_bs_read_data ( bs , tmpName , to_read ) ; i = 0 ;  while ( ( tmpName [ i ] != 0 ) && ( i < to_read ) ) {  i ++ ; } if ( i == to_read ) { gf_free ( tmpName ) ; return GF_ISOM_INVALID_FILE ; } if ( i == to_read - 1 ) { ptr -> nameURN = tmpName ; ptr -> location = NULL ; return GF_OK ; } ptr -> nameURN = ( char * ) gf_malloc ( sizeof ( char ) * ( i + 1 ) ) ; if ( ! ptr -> nameURN ) { gf_free ( tmpName ) ; return GF_OUT_OF_MEM ; } ptr -> location = ( char * ) gf_malloc ( sizeof ( char ) * ( to_read - i - 1 ) ) ; if ( ! ptr -> location ) { gf_free ( tmpName ) ; gf_free ( ptr -> nameURN ) ; ptr -> nameURN = NULL ; return GF_OUT_OF_MEM ; } memcpy ( ptr -> nameURN , tmpName , i + 1 ) ; memcpy ( ptr -> location , tmpName + i + 1 , ( to_read - i - 1 ) ) ; gf_free ( tmpName ) ; return GF_OK ; }",while ( ( i < to_read ) && ( tmpName [ i ] != 0 ) ) {i ++ ;,138
191,"buggy line: long rem ;value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & rem ) ;value -> tv_usec = rem / NSEC_PER_USEC ;cwe id:CWE-189context: static inline void jiffies_to_compat_timeval ( unsigned long jiffies , struct compat_timeval * value ) { u64 nsec = ( u64 ) jiffies * TICK_NSEC ;  long rem ;   value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & rem ) ;  value -> tv_usec = rem / NSEC_PER_USEC ; }","u32 rem ;value -> tv_sec = div_u64_rem ( nsec , NSEC_PER_SEC , & rem ) ;value -> tv_usec = rem / NSEC_PER_USEC ;",139
192,"buggy line: for ( plane = 0 ;plane < 4 && in -> data [ plane ] ;const int width = ( plane == 1 || plane == 2 ) ? FF_CEIL_RSHIFT ( inlink -> w , s -> hsub ) : inlink -> w ;cwe id:CWE-119context: static int filter_frame ( AVFilterLink * inlink , AVFrame * in ) { AVFilterContext * ctx = inlink -> dst ; FlipContext * s = ctx -> priv ; AVFilterLink * outlink = ctx -> outputs [ 0 ] ; AVFrame * out ; uint8_t * inrow , * outrow ; int i , j , plane , step ; out = ff_get_video_buffer ( outlink , outlink -> w , outlink -> h ) ; if ( ! out ) { av_frame_free ( & in ) ; return AVERROR ( ENOMEM ) ; } av_frame_copy_props ( out , in ) ; if ( av_pix_fmt_desc_get ( inlink -> format ) -> flags & AV_PIX_FMT_FLAG_PAL ) memcpy ( out -> data [ 1 ] , in -> data [ 1 ] , AVPALETTE_SIZE ) ;  for ( plane = 0 ; plane < 4 && in -> data [ plane ] ; plane ++ ) {  const int width = ( plane == 1 || plane == 2 ) ? FF_CEIL_RSHIFT ( inlink -> w , s -> hsub ) : inlink -> w ; const int height = ( plane == 1 || plane == 2 ) ? FF_CEIL_RSHIFT ( inlink -> h , s -> vsub ) : inlink -> h ; step = s -> max_step [ plane ] ; outrow = out -> data [ plane ] ; inrow = in -> data [ plane ] + ( width - 1 ) * step ; for ( i = 0 ; i < height ; i ++ ) { switch ( step ) { case 1 : for ( j = 0 ; j < width ; j ++ ) outrow [ j ] = inrow [ - j ] ; break ; case 2 : { uint16_t * outrow16 = ( uint16_t * ) outrow ; uint16_t * inrow16 = ( uint16_t * ) inrow ; for ( j = 0 ; j < width ; j ++ ) outrow16 [ j ] = inrow16 [ - j ] ; } break ; case 3 : { uint8_t * in = inrow ; uint8_t * out = outrow ; for ( j = 0 ; j < width ; j ++ , out += 3 , in -= 3 ) { int32_t v = AV_RB24 ( in ) ; AV_WB24 ( out , v ) ; } } break ; case 4 : { uint32_t * outrow32 = ( uint32_t * ) outrow ; uint32_t * inrow32 = ( uint32_t * ) inrow ; for ( j = 0 ; j < width ; j ++ ) outrow32 [ j ] = inrow32 [ - j ] ; } break ; default : for ( j = 0 ; j < width ; j ++ ) memcpy ( outrow + j * step , inrow - j * step , step ) ; } inrow += in -> linesize [ plane ] ; outrow += out -> linesize [ plane ] ; } } av_frame_free ( & in ) ; return ff_filter_frame ( outlink , out ) ; }","for ( plane = 0 ;plane < 4 && in -> data [ plane ] && in -> linesize [ plane ] ;const int width = ( plane == 1 || plane == 2 ) ? FF_CEIL_RSHIFT ( inlink -> w , s -> hsub ) : inlink -> w ;",140
193,"buggy line: strncpy ( szFileName , sizeof ( szFileName ) - 5 , pszFileName ) ;}cwe id:CWE-119context: BOOL SQLWriteFileDSN ( LPCSTR pszFileName , LPCSTR pszAppName , LPCSTR pszKeyName , LPCSTR pszString ) { HINI hIni ; char szFileName [ ODBC_FILENAME_MAX + 1 ] ; if ( pszFileName [ 0 ] == '/' ) {  strncpy ( szFileName , sizeof ( szFileName ) - 5 , pszFileName ) ;  } else { char szPath [ ODBC_FILENAME_MAX + 1 ] ; * szPath = '\\0' ; _odbcinst_FileINI ( szPath ) ; snprintf ( szFileName , sizeof ( szFileName ) - 5 , ""%s/%s"" , szPath , pszFileName ) ; } if ( strlen ( szFileName ) < 4 || strcmp ( szFileName + strlen ( szFileName ) - 4 , "".dsn"" ) ) { strcat ( szFileName , "".dsn"" ) ; } # ifdef __OS2__ if ( iniOpen ( & hIni , szFileName , ""#;"" , '[' , ']' , '=' , TRUE , 0L ) != INI_SUCCESS ) # else if ( iniOpen ( & hIni , szFileName , ""#;"" , '[' , ']' , '=' , TRUE ) != INI_SUCCESS ) # endif { inst_logPushMsg ( __FILE__ , __FILE__ , __LINE__ , LOG_CRITICAL , ODBC_ERROR_INVALID_PATH , """" ) ; return FALSE ; } if ( pszString == NULL && pszKeyName == NULL ) { if ( iniObjectSeek ( hIni , ( char * ) pszAppName ) == INI_SUCCESS ) { iniObjectDelete ( hIni ) ; } } else if ( pszString == NULL ) { if ( iniPropertySeek ( hIni , ( char * ) pszAppName , ( char * ) pszKeyName , """" ) == INI_SUCCESS ) { iniPropertyDelete ( hIni ) ; } } else { if ( iniObjectSeek ( hIni , ( char * ) pszAppName ) != INI_SUCCESS ) { iniObjectInsert ( hIni , ( char * ) pszAppName ) ; } if ( iniPropertySeek ( hIni , ( char * ) pszAppName , ( char * ) pszKeyName , """" ) == INI_SUCCESS ) { iniObjectSeek ( hIni , ( char * ) pszAppName ) ; iniPropertyUpdate ( hIni , ( char * ) pszKeyName , ( char * ) pszString ) ; } else { iniObjectSeek ( hIni , ( char * ) pszAppName ) ; iniPropertyInsert ( hIni , ( char * ) pszKeyName , ( char * ) pszString ) ; } } if ( iniCommit ( hIni ) != INI_SUCCESS ) { iniClose ( hIni ) ; inst_logPushMsg ( __FILE__ , __FILE__ , __LINE__ , LOG_CRITICAL , ODBC_ERROR_REQUEST_FAILED , """" ) ; return FALSE ; } iniClose ( hIni ) ; return TRUE ; }","strncpy ( szFileName , pszFileName , sizeof ( szFileName ) - 5 ) ;}",141
194,"buggy line: owner = stok ( auth , "":"" , & tok ) ;if ( owner && * owner ) {cwe id:CWE-000context: static int makeDirDirective ( MaState * state , cchar * key , cchar * value ) { MprPath info ; char * auth , * dirs , * path , * perms , * tok ; cchar * dir , * group , * owner ; int gid , mode , uid ; if ( ! maTokenize ( state , value , ""%S<S2SV_blank>?*"" , & auth , & dirs ) ) { return MPR_ERR_BAD_SYNTAX ; } uid = gid = 0 ; mode = 0750 ; if ( schr ( auth , ':' ) ) {  owner = stok ( auth , "":"" , & tok ) ;  if ( owner && * owner ) { if ( snumber ( owner ) ) { uid = ( int ) stoi ( owner ) ; } else if ( smatch ( owner , ""APPWEB"" ) ) { uid = HTTP -> uid ; } else { uid = userToID ( owner ) ; } }  group = stok ( tok , "":"" , & perms ) ;  if ( group && * group ) { if ( snumber ( group ) ) { gid = ( int ) stoi ( group ) ; } else if ( smatch ( owner , ""APPWEB"" ) ) { gid = HTTP -> gid ; } else { gid = groupToID ( group ) ; } } if ( perms && snumber ( perms ) ) { mode = ( int ) stoiradix ( perms , - 1 , NULL ) ; } else { mode = 0 ; } if ( gid < 0 || uid < 0 ) { return MPR_ERR_BAD_SYNTAX ; } } else { dirs = auth ; auth = 0 ; } tok = dirs ; for ( tok = sclone ( dirs ) ; ( dir = stok ( tok , "","" , & tok ) ) != 0 ; ) { path = httpMakePath ( state -> route , state -> configDir , dir ) ; if ( mprGetPathInfo ( path , & info ) == 0 && info . isDir ) { continue ; } if ( mprMakeDir ( path , mode , uid , gid , 1 ) < 0 ) { return MPR_ERR_BAD_SYNTAX ; } } return 0 ; }","owner = ssplit ( auth , "":"" , & tok ) ;if ( owner && * owner ) {",142
195,"buggy line: group = stok ( tok , "":"" , & perms ) ;if ( group && * group ) {cwe id:CWE-000context: static int makeDirDirective ( MaState * state , cchar * key , cchar * value ) { MprPath info ; char * auth , * dirs , * path , * perms , * tok ; cchar * dir , * group , * owner ; int gid , mode , uid ; if ( ! maTokenize ( state , value , ""%S<S2SV_blank>?*"" , & auth , & dirs ) ) { return MPR_ERR_BAD_SYNTAX ; } uid = gid = 0 ; mode = 0750 ; if ( schr ( auth , ':' ) ) {  owner = stok ( auth , "":"" , & tok ) ;  if ( owner && * owner ) { if ( snumber ( owner ) ) { uid = ( int ) stoi ( owner ) ; } else if ( smatch ( owner , ""APPWEB"" ) ) { uid = HTTP -> uid ; } else { uid = userToID ( owner ) ; } }  group = stok ( tok , "":"" , & perms ) ;  if ( group && * group ) { if ( snumber ( group ) ) { gid = ( int ) stoi ( group ) ; } else if ( smatch ( owner , ""APPWEB"" ) ) { gid = HTTP -> gid ; } else { gid = groupToID ( group ) ; } } if ( perms && snumber ( perms ) ) { mode = ( int ) stoiradix ( perms , - 1 , NULL ) ; } else { mode = 0 ; } if ( gid < 0 || uid < 0 ) { return MPR_ERR_BAD_SYNTAX ; } } else { dirs = auth ; auth = 0 ; } tok = dirs ; for ( tok = sclone ( dirs ) ; ( dir = stok ( tok , "","" , & tok ) ) != 0 ; ) { path = httpMakePath ( state -> route , state -> configDir , dir ) ; if ( mprGetPathInfo ( path , & info ) == 0 && info . isDir ) { continue ; } if ( mprMakeDir ( path , mode , uid , gid , 1 ) < 0 ) { return MPR_ERR_BAD_SYNTAX ; } } return 0 ; }","group = ssplit ( tok , "":"" , & perms ) ;if ( group && * group ) {",142
196,"buggy line: q = ( const uint8_t * ) ( const void * )  ( ( const char * ) ( const void * ) p +  CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ) - 2 * sizeof ( uint32_t ) ;if ( q > e ) {DPRINTF ( ( ""%"" SIZE_T_FORMAT ""u)<S2SV_blank>id=%x<S2SV_blank>type=%x<S2SV_blank>offs=0x%tx,0x%x\\\if ( inp [ i ] . pi_type & CDF_VECTOR ) {cwe id:CWE-119context: int cdf_read_property_info ( const cdf_stream_t * sst , const cdf_header_t * h , uint32_t offs , cdf_property_info_t * * info , size_t * count , size_t * maxcount ) { const cdf_section_header_t * shp ; cdf_section_header_t sh ; const uint8_t * p , * q , * e ; int16_t s16 ; int32_t s32 ; uint32_t u32 ; int64_t s64 ; uint64_t u64 ; cdf_timestamp_t tp ; size_t i , o , o4 , nelements , j ; cdf_property_info_t * inp ; if ( offs > UINT32_MAX / 4 ) { errno = EFTYPE ; goto out ; } shp = CAST ( const cdf_section_header_t * , ( const void * ) ( ( const char * ) sst -> sst_tab + offs ) ) ; if ( cdf_check_stream_offset ( sst , h , shp , sizeof ( * shp ) , __LINE__ ) == - 1 ) goto out ; sh . sh_len = CDF_TOLE4 ( shp -> sh_len ) ; # define CDF_SHLEN_LIMIT ( UINT32_MAX / 8 ) if ( sh . sh_len > CDF_SHLEN_LIMIT ) { errno = EFTYPE ; goto out ; } sh . sh_properties = CDF_TOLE4 ( shp -> sh_properties ) ; # define CDF_PROP_LIMIT ( UINT32_MAX / ( 4 * sizeof ( * inp ) ) ) if ( sh . sh_properties > CDF_PROP_LIMIT ) goto out ; DPRINTF ( ( ""section<S2SV_blank>len:<S2SV_blank>%u<S2SV_blank>properties<S2SV_blank>%u\\n"" , sh . sh_len , sh . sh_properties ) ) ; if ( * maxcount ) { if ( * maxcount > CDF_PROP_LIMIT ) goto out ; * maxcount += sh . sh_properties ; inp = CAST ( cdf_property_info_t * , realloc ( * info , * maxcount * sizeof ( * inp ) ) ) ; } else { * maxcount = sh . sh_properties ; inp = CAST ( cdf_property_info_t * , malloc ( * maxcount * sizeof ( * inp ) ) ) ; } if ( inp == NULL ) goto out ; * info = inp ; inp += * count ; * count += sh . sh_properties ; p = CAST ( const uint8_t * , ( const void * ) ( ( const char * ) ( const void * ) sst -> sst_tab + offs + sizeof ( sh ) ) ) ; e = CAST ( const uint8_t * , ( const void * ) ( ( ( const char * ) ( const void * ) shp ) + sh . sh_len ) ) ; if ( cdf_check_stream_offset ( sst , h , e , 0 , __LINE__ ) == - 1 ) goto out ; for ( i = 0 ; i < sh . sh_properties ; i ++ ) {  q = ( const uint8_t * ) ( const void * )  ( ( const char * ) ( const void * ) p +  CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ) - 2 * sizeof ( uint32_t ) ;  if ( q > e ) { DPRINTF ( ( ""Ran<S2SV_blank>of<S2SV_blank>the<S2SV_blank>end<S2SV_blank>%p<S2SV_blank>><S2SV_blank>%p\\n"" , q , e ) ) ; goto out ; } inp [ i ] . pi_id = CDF_GETUINT32 ( p , i << 1 ) ; inp [ i ] . pi_type = CDF_GETUINT32 ( q , 0 ) ;  DPRINTF ( ( ""%"" SIZE_T_FORMAT ""u)<S2SV_blank>id=%x<S2SV_blank>type=%x<S2SV_blank>offs=0x%tx,0x%x\\n"" , i ,  inp [ i ] . pi_id , inp [ i ] . pi_type , q - p ,  CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ) ) ;  if ( inp [ i ] . pi_type & CDF_VECTOR ) { nelements = CDF_GETUINT32 ( q , 1 ) ; o = 2 ; } else { nelements = 1 ; o = 1 ; } o4 = o * sizeof ( uint32_t ) ; if ( inp [ i ] . pi_type & ( CDF_ARRAY | CDF_BYREF | CDF_RESERVED ) ) goto unknown ; switch ( inp [ i ] . pi_type & CDF_TYPEMASK ) { case CDF_NULL : case CDF_EMPTY : break ; case CDF_SIGNED16 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s16 , & q [ o4 ] , sizeof ( s16 ) ) ; inp [ i ] . pi_s16 = CDF_TOLE2 ( s16 ) ; break ; case CDF_SIGNED32 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s32 , & q [ o4 ] , sizeof ( s32 ) ) ; inp [ i ] . pi_s32 = CDF_TOLE4 ( ( uint32_t ) s32 ) ; break ; case CDF_BOOL : case CDF_UNSIGNED32 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u32 , & q [ o4 ] , sizeof ( u32 ) ) ; inp [ i ] . pi_u32 = CDF_TOLE4 ( u32 ) ; break ; case CDF_SIGNED64 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s64 , & q [ o4 ] , sizeof ( s64 ) ) ; inp [ i ] . pi_s64 = CDF_TOLE8 ( ( uint64_t ) s64 ) ; break ; case CDF_UNSIGNED64 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u64 , & q [ o4 ] , sizeof ( u64 ) ) ; inp [ i ] . pi_u64 = CDF_TOLE8 ( ( uint64_t ) u64 ) ; break ; case CDF_FLOAT : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u32 , & q [ o4 ] , sizeof ( u32 ) ) ; u32 = CDF_TOLE4 ( u32 ) ; memcpy ( & inp [ i ] . pi_f , & u32 , sizeof ( inp [ i ] . pi_f ) ) ; break ; case CDF_DOUBLE : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u64 , & q [ o4 ] , sizeof ( u64 ) ) ; u64 = CDF_TOLE8 ( ( uint64_t ) u64 ) ; memcpy ( & inp [ i ] . pi_d , & u64 , sizeof ( inp [ i ] . pi_d ) ) ; break ; case CDF_LENGTH32_STRING : case CDF_LENGTH32_WSTRING : if ( nelements > 1 ) { size_t nelem = inp - * info ; if ( * maxcount > CDF_PROP_LIMIT || nelements > CDF_PROP_LIMIT ) goto out ; * maxcount += nelements ; inp = CAST ( cdf_property_info_t * , realloc ( * info , * maxcount * sizeof ( * inp ) ) ) ; if ( inp == NULL ) goto out ; * info = inp ; inp = * info + nelem ; } DPRINTF ( ( ""nelements<S2SV_blank>=<S2SV_blank>%"" SIZE_T_FORMAT ""u\\n"" , nelements ) ) ; for ( j = 0 ; j < nelements ; j ++ , i ++ ) { uint32_t l = CDF_GETUINT32 ( q , o ) ; inp [ i ] . pi_str . s_len = l ; inp [ i ] . pi_str . s_buf = ( const char * ) ( const void * ) ( & q [ o4 + sizeof ( l ) ] ) ; DPRINTF ( ( ""l<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>r<S2SV_blank>=<S2SV_blank>%"" SIZE_T_FORMAT ""u,<S2SV_blank>s<S2SV_blank>=<S2SV_blank>%s\\n"" , l , CDF_ROUND ( l , sizeof ( l ) ) , inp [ i ] . pi_str . s_buf ) ) ; if ( l & 1 ) l ++ ; o += l >> 1 ; if ( q + o >= e ) goto out ; o4 = o * sizeof ( uint32_t ) ; } i -- ; break ; case CDF_FILETIME : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & tp , & q [ o4 ] , sizeof ( tp ) ) ; inp [ i ] . pi_tp = CDF_TOLE8 ( ( uint64_t ) tp ) ; break ; case CDF_CLIPBOARD : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; break ; default : unknown : DPRINTF ( ( ""Don\'t<S2SV_blank>know<S2SV_blank>how<S2SV_blank>to<S2SV_blank>deal<S2SV_blank>with<S2SV_blank>%x\\n"" , inp [ i ] . pi_type ) ) ; break ; } } return 0 ; out : free ( * info ) ; return - 1 ; }","size_t ofs = CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ;q = ( const uint8_t * ) ( const void * ) ( ( const char * ) ( const void * ) p + ofs - 2 * sizeof ( uint32_t ) ) ;if ( q > e ) {DPRINTF ( ( ""%"" SIZE_T_FORMAT ""u)<S2SV_blank>id=%x<S2SV_blank>type=%x<S2SV_blank>offs=0x%tx,0x%x\\\if ( inp [ i ] . pi_type & CDF_VECTOR ) {",143
197,"buggy line: if ( inet -> opt && inet -> opt -> srr )  daddr = inet -> opt -> faddr ;cwe id:CWE-362context: static int inet_sk_reselect_saddr ( struct sock * sk ) { struct inet_sock * inet = inet_sk ( sk ) ; __be32 old_saddr = inet -> inet_saddr ; __be32 daddr = inet -> inet_daddr ; struct flowi4 fl4 ; struct rtable * rt ; __be32 new_saddr ;  if ( inet -> opt && inet -> opt -> srr )  daddr = inet -> opt -> faddr ; rt = ip_route_connect ( & fl4 , daddr , 0 , RT_CONN_FLAGS ( sk ) , sk -> sk_bound_dev_if , sk -> sk_protocol , inet -> inet_sport , inet -> inet_dport , sk , false ) ; if ( IS_ERR ( rt ) ) return PTR_ERR ( rt ) ; sk_setup_caps ( sk , & rt -> dst ) ; new_saddr = rt -> rt_src ; if ( new_saddr == old_saddr ) return 0 ; if ( sysctl_ip_dynaddr > 1 ) { printk ( KERN_INFO ""%s():<S2SV_blank>shifting<S2SV_blank>inet->saddr<S2SV_blank>from<S2SV_blank>%pI4<S2SV_blank>to<S2SV_blank>%pI4\\n"" , __func__ , & old_saddr , & new_saddr ) ; } inet -> inet_saddr = inet -> inet_rcv_saddr = new_saddr ; __sk_prot_rehash ( sk ) ; return 0 ; }","struct ip_options_rcu * inet_opt ;inet_opt = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) ;if ( inet_opt && inet_opt -> opt . srr ) daddr = inet_opt -> opt . faddr ;",144
198,"buggy line: duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\\return - EINVAL ;}err = check_entry ( e ) ;if ( err ) return err ;for ( h = 0 ;h < NF_INET_NUMHOOKS ;h ++ ) {if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ;if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ;if ( ( unsigned char * ) e - base == underflows [ h ] ) {if ( ! check_underflow ( e ) ) {pr_err ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>""  ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"" ""ACCEPT/DROP\\\cwe id:CWE-119context: static int check_entry_size_and_hooks ( struct ipt_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct ipt_entry ) != 0 || ( unsigned char * ) e + sizeof ( struct ipt_entry ) >= limit || ( unsigned char * ) e + e -> next_offset > limit ) { duprintf ( ""Bad<S2SV_blank>offset<S2SV_blank>%p\\n"" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct ipt_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\n"" , e , e -> next_offset ) ; return - EINVAL ; } err = check_entry ( e ) ; if ( err ) return err ; for ( h = 0 ; h < NF_INET_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) {  pr_err ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>""  ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"" ""ACCEPT/DROP\\n"" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows [ h ] ; } } e -> counters = ( ( struct xt_counters ) { 0 , 0 } ) ; e -> comefrom = 0 ; return 0 ; }","pr_debug ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>"" ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"" ""ACCEPT/DROP\\\",145
199,"buggy line: tlen = len - sizeof ( struct eigrp_common_header ) ;ND_PRINT ( ( ndo , ""\\\cwe id:CWE-125context: void eigrp_print ( netdissect_options * ndo , register const u_char * pptr , register u_int len ) { const struct eigrp_common_header * eigrp_com_header ; const struct eigrp_tlv_header * eigrp_tlv_header ; const u_char * tptr , * tlv_tptr ; u_int tlen , eigrp_tlv_len , eigrp_tlv_type , tlv_tlen , byte_length , bit_length ; uint8_t prefix [ 4 ] ; union { const struct eigrp_tlv_general_parm_t * eigrp_tlv_general_parm ; const struct eigrp_tlv_sw_version_t * eigrp_tlv_sw_version ; const struct eigrp_tlv_ip_int_t * eigrp_tlv_ip_int ; const struct eigrp_tlv_ip_ext_t * eigrp_tlv_ip_ext ; const struct eigrp_tlv_at_cable_setup_t * eigrp_tlv_at_cable_setup ; const struct eigrp_tlv_at_int_t * eigrp_tlv_at_int ; const struct eigrp_tlv_at_ext_t * eigrp_tlv_at_ext ; } tlv_ptr ; tptr = pptr ; eigrp_com_header = ( const struct eigrp_common_header * ) pptr ; ND_TCHECK ( * eigrp_com_header ) ; if ( eigrp_com_header -> version != EIGRP_VERSION ) { ND_PRINT ( ( ndo , ""EIGRP<S2SV_blank>version<S2SV_blank>%u<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" , eigrp_com_header -> version ) ) ; return ; } if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , ""EIGRP<S2SV_blank>%s,<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( eigrp_opcode_values , ""unknown<S2SV_blank>(%u)"" , eigrp_com_header -> opcode ) , len ) ) ; return ; }  tlen = len - sizeof ( struct eigrp_common_header ) ;  ND_PRINT ( ( ndo , ""\\n\\tEIGRP<S2SV_blank>v%u,<S2SV_blank>opcode:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>chksum:<S2SV_blank>0x%04x,<S2SV_blank>Flags:<S2SV_blank>[%s]\\n\\tseq:<S2SV_blank>0x%08x,<S2SV_blank>ack:<S2SV_blank>0x%08x,<S2SV_blank>AS:<S2SV_blank>%u,<S2SV_blank>length:<S2SV_blank>%u"" , eigrp_com_header -> version , tok2str ( eigrp_opcode_values , ""unknown,<S2SV_blank>type:<S2SV_blank>%u"" , eigrp_com_header -> opcode ) , eigrp_com_header -> opcode , EXTRACT_16BITS ( & eigrp_com_header -> checksum ) , tok2str ( eigrp_common_header_flag_values , ""none"" , EXTRACT_32BITS ( & eigrp_com_header -> flags ) ) , EXTRACT_32BITS ( & eigrp_com_header -> seq ) , EXTRACT_32BITS ( & eigrp_com_header -> ack ) , EXTRACT_32BITS ( & eigrp_com_header -> asn ) , tlen ) ) ; tptr += sizeof ( const struct eigrp_common_header ) ; while ( tlen > 0 ) { ND_TCHECK2 ( * tptr , sizeof ( struct eigrp_tlv_header ) ) ; eigrp_tlv_header = ( const struct eigrp_tlv_header * ) tptr ; eigrp_tlv_len = EXTRACT_16BITS ( & eigrp_tlv_header -> length ) ; eigrp_tlv_type = EXTRACT_16BITS ( & eigrp_tlv_header -> type ) ; if ( eigrp_tlv_len < sizeof ( struct eigrp_tlv_header ) || eigrp_tlv_len > tlen ) { print_unknown_data ( ndo , tptr + sizeof ( struct eigrp_tlv_header ) , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; return ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>TLV<S2SV_blank>(0x%04x),<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( eigrp_tlv_values , ""Unknown"" , eigrp_tlv_type ) , eigrp_tlv_type , eigrp_tlv_len ) ) ;  tlv_tptr = tptr + sizeof ( struct eigrp_tlv_header ) ;  tlv_tlen = eigrp_tlv_len - sizeof ( struct eigrp_tlv_header ) ; ND_TCHECK2 ( * tptr , eigrp_tlv_len ) ; switch ( eigrp_tlv_type ) { case EIGRP_TLV_GENERAL_PARM : tlv_ptr . eigrp_tlv_general_parm = ( const struct eigrp_tlv_general_parm_t * ) tlv_tptr ;  ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>holdtime:<S2SV_blank>%us,<S2SV_blank>k1<S2SV_blank>%u,<S2SV_blank>k2<S2SV_blank>%u,<S2SV_blank>k3<S2SV_blank>%u,<S2SV_blank>k4<S2SV_blank>%u,<S2SV_blank>k5<S2SV_blank>%u"" ,  EXTRACT_16BITS ( tlv_ptr . eigrp_tlv_general_parm -> holdtime ) , tlv_ptr . eigrp_tlv_general_parm -> k1 , tlv_ptr . eigrp_tlv_general_parm -> k2 , tlv_ptr . eigrp_tlv_general_parm -> k3 , tlv_ptr . eigrp_tlv_general_parm -> k4 , tlv_ptr . eigrp_tlv_general_parm -> k5 ) ) ; break ; case EIGRP_TLV_SW_VERSION : tlv_ptr . eigrp_tlv_sw_version = ( const struct eigrp_tlv_sw_version_t * ) tlv_tptr ;  ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IOS<S2SV_blank>version:<S2SV_blank>%u.%u,<S2SV_blank>EIGRP<S2SV_blank>version<S2SV_blank>%u.%u"" ,  tlv_ptr . eigrp_tlv_sw_version -> ios_major , tlv_ptr . eigrp_tlv_sw_version -> ios_minor , tlv_ptr . eigrp_tlv_sw_version -> eigrp_major , tlv_ptr . eigrp_tlv_sw_version -> eigrp_minor ) ) ; break ; case EIGRP_TLV_IP_INT : tlv_ptr . eigrp_tlv_ip_int = ( const struct eigrp_tlv_ip_int_t * ) tlv_tptr ;  bit_length = tlv_ptr . eigrp_tlv_ip_int -> plen ;  if ( bit_length > 32 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>illegal<S2SV_blank>prefix<S2SV_blank>length<S2SV_blank>%u"" , bit_length ) ) ; break ; } byte_length = ( bit_length + 7 ) / 8 ; memset ( prefix , 0 , 4 ) ; memcpy ( prefix , & tlv_ptr . eigrp_tlv_ip_int -> destination , byte_length ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv4<S2SV_blank>prefix:<S2SV_blank>%15s/%u,<S2SV_blank>nexthop:<S2SV_blank>"" , ipaddr_string ( ndo , prefix ) , bit_length ) ) ; if ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_int -> nexthop ) == 0 ) ND_PRINT ( ( ndo , ""self"" ) ) ; else ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , & tlv_ptr . eigrp_tlv_ip_int -> nexthop ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>delay<S2SV_blank>%u<S2SV_blank>ms,<S2SV_blank>bandwidth<S2SV_blank>%u<S2SV_blank>Kbps,<S2SV_blank>mtu<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u,<S2SV_blank>reliability<S2SV_blank>%u,<S2SV_blank>load<S2SV_blank>%u"" , ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_int -> delay ) / 100 ) , EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_int -> bandwidth ) , EXTRACT_24BITS ( & tlv_ptr . eigrp_tlv_ip_int -> mtu ) , tlv_ptr . eigrp_tlv_ip_int -> hopcount , tlv_ptr . eigrp_tlv_ip_int -> reliability , tlv_ptr . eigrp_tlv_ip_int -> load ) ) ; break ; case EIGRP_TLV_IP_EXT : tlv_ptr . eigrp_tlv_ip_ext = ( const struct eigrp_tlv_ip_ext_t * ) tlv_tptr ;  bit_length = tlv_ptr . eigrp_tlv_ip_ext -> plen ;  if ( bit_length > 32 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>illegal<S2SV_blank>prefix<S2SV_blank>length<S2SV_blank>%u"" , bit_length ) ) ; break ; } byte_length = ( bit_length + 7 ) / 8 ; memset ( prefix , 0 , 4 ) ; memcpy ( prefix , & tlv_ptr . eigrp_tlv_ip_ext -> destination , byte_length ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv4<S2SV_blank>prefix:<S2SV_blank>%15s/%u,<S2SV_blank>nexthop:<S2SV_blank>"" , ipaddr_string ( ndo , prefix ) , bit_length ) ) ; if ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_ext -> nexthop ) == 0 ) ND_PRINT ( ( ndo , ""self"" ) ) ; else ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , & tlv_ptr . eigrp_tlv_ip_ext -> nexthop ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>origin-router<S2SV_blank>%s,<S2SV_blank>origin-as<S2SV_blank>%u,<S2SV_blank>origin-proto<S2SV_blank>%s,<S2SV_blank>flags<S2SV_blank>[0x%02x],<S2SV_blank>tag<S2SV_blank>0x%08x,<S2SV_blank>metric<S2SV_blank>%u"" , ipaddr_string ( ndo , tlv_ptr . eigrp_tlv_ip_ext -> origin_router ) , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_ip_ext -> origin_as ) , tok2str ( eigrp_ext_proto_id_values , ""unknown"" , tlv_ptr . eigrp_tlv_ip_ext -> proto_id ) , tlv_ptr . eigrp_tlv_ip_ext -> flags , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_ip_ext -> tag ) , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_ip_ext -> metric ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>delay<S2SV_blank>%u<S2SV_blank>ms,<S2SV_blank>bandwidth<S2SV_blank>%u<S2SV_blank>Kbps,<S2SV_blank>mtu<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u,<S2SV_blank>reliability<S2SV_blank>%u,<S2SV_blank>load<S2SV_blank>%u"" , ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_ext -> delay ) / 100 ) , EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_ext -> bandwidth ) , EXTRACT_24BITS ( & tlv_ptr . eigrp_tlv_ip_ext -> mtu ) , tlv_ptr . eigrp_tlv_ip_ext -> hopcount , tlv_ptr . eigrp_tlv_ip_ext -> reliability , tlv_ptr . eigrp_tlv_ip_ext -> load ) ) ; break ; case EIGRP_TLV_AT_CABLE_SETUP : tlv_ptr . eigrp_tlv_at_cable_setup = ( const struct eigrp_tlv_at_cable_setup_t * ) tlv_tptr ;  ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Cable-range:<S2SV_blank>%u-%u,<S2SV_blank>Router-ID<S2SV_blank>%u"" ,  EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_cable_setup -> cable_start ) , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_cable_setup -> cable_end ) , EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_cable_setup -> router_id ) ) ) ; break ; case EIGRP_TLV_AT_INT :  tlv_ptr . eigrp_tlv_at_int = ( const struct eigrp_tlv_at_int_t * ) tlv_tptr ;  ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Cable-Range:<S2SV_blank>%u-%u,<S2SV_blank>nexthop:<S2SV_blank>"" , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_int -> cable_start ) , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_int -> cable_end ) ) ) ; if ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_int -> nexthop ) == 0 ) ND_PRINT ( ( ndo , ""self"" ) ) ; else ND_PRINT ( ( ndo , ""%u.%u"" , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_int -> nexthop ) , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_int -> nexthop [ 2 ] ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>delay<S2SV_blank>%u<S2SV_blank>ms,<S2SV_blank>bandwidth<S2SV_blank>%u<S2SV_blank>Kbps,<S2SV_blank>mtu<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u,<S2SV_blank>reliability<S2SV_blank>%u,<S2SV_blank>load<S2SV_blank>%u"" , ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_int -> delay ) / 100 ) , EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_int -> bandwidth ) , EXTRACT_24BITS ( & tlv_ptr . eigrp_tlv_at_int -> mtu ) , tlv_ptr . eigrp_tlv_at_int -> hopcount , tlv_ptr . eigrp_tlv_at_int -> reliability , tlv_ptr . eigrp_tlv_at_int -> load ) ) ; break ; case EIGRP_TLV_AT_EXT : tlv_ptr . eigrp_tlv_at_ext = ( const struct eigrp_tlv_at_ext_t * ) tlv_tptr ;  ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Cable-Range:<S2SV_blank>%u-%u,<S2SV_blank>nexthop:<S2SV_blank>"" ,  EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_ext -> cable_start ) , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_ext -> cable_end ) ) ) ; if ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_ext -> nexthop ) == 0 ) ND_PRINT ( ( ndo , ""self"" ) ) ; else ND_PRINT ( ( ndo , ""%u.%u"" , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_ext -> nexthop ) , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_ext -> nexthop [ 2 ] ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>origin-router<S2SV_blank>%u,<S2SV_blank>origin-as<S2SV_blank>%u,<S2SV_blank>origin-proto<S2SV_blank>%s,<S2SV_blank>flags<S2SV_blank>[0x%02x],<S2SV_blank>tag<S2SV_blank>0x%08x,<S2SV_blank>metric<S2SV_blank>%u"" , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_at_ext -> origin_router ) , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_at_ext -> origin_as ) , tok2str ( eigrp_ext_proto_id_values , ""unknown"" , tlv_ptr . eigrp_tlv_at_ext -> proto_id ) , tlv_ptr . eigrp_tlv_at_ext -> flags , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_at_ext -> tag ) , EXTRACT_16BITS ( tlv_ptr . eigrp_tlv_at_ext -> metric ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>delay<S2SV_blank>%u<S2SV_blank>ms,<S2SV_blank>bandwidth<S2SV_blank>%u<S2SV_blank>Kbps,<S2SV_blank>mtu<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u,<S2SV_blank>reliability<S2SV_blank>%u,<S2SV_blank>load<S2SV_blank>%u"" , ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_ext -> delay ) / 100 ) , EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_ext -> bandwidth ) , EXTRACT_24BITS ( & tlv_ptr . eigrp_tlv_at_ext -> mtu ) , tlv_ptr . eigrp_tlv_at_ext -> hopcount , tlv_ptr . eigrp_tlv_at_ext -> reliability , tlv_ptr . eigrp_tlv_at_ext -> load ) ) ; break ; case EIGRP_TLV_AUTH : case EIGRP_TLV_SEQ : case EIGRP_TLV_MCAST_SEQ : case EIGRP_TLV_IPX_INT : case EIGRP_TLV_IPX_EXT : default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tlv_tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlv_tlen ) ; break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , tptr + sizeof ( struct eigrp_tlv_header ) , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , eigrp_tlv_len - sizeof ( struct eigrp_tlv_header ) ) ; tptr += eigrp_tlv_len ; tlen -= eigrp_tlv_len ; } return ; trunc : ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank>packet<S2SV_blank>exceeded<S2SV_blank>snapshot"" ) ) ; }","if ( len < sizeof ( struct eigrp_common_header ) ) {ND_PRINT ( ( ndo , ""EIGRP<S2SV_blank>%s,<S2SV_blank>length:<S2SV_blank>%u<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , tok2str ( eigrp_opcode_values , ""unknown<S2SV_blank>(%u)"" , eigrp_com_header -> opcode ) , len , ( u_int ) sizeof ( struct eigrp_common_header ) ) ) ;if ( eigrp_tlv_len < sizeof ( struct eigrp_tlv_header ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) sizeof ( struct eigrp_tlv_header ) ) ) ;break ;}return ;}tlen = len - sizeof ( struct eigrp_common_header ) ;ND_PRINT ( ( ndo , ""\\\",146
200,"buggy line: tlv_tptr = tptr + sizeof ( struct eigrp_tlv_header ) ;tlv_tlen = eigrp_tlv_len - sizeof ( struct eigrp_tlv_header ) ;ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\bit_length = tlv_ptr . eigrp_tlv_ip_int -> plen ;if ( bit_length > 32 ) {cwe id:CWE-125context: void eigrp_print ( netdissect_options * ndo , register const u_char * pptr , register u_int len ) { const struct eigrp_common_header * eigrp_com_header ; const struct eigrp_tlv_header * eigrp_tlv_header ; const u_char * tptr , * tlv_tptr ; u_int tlen , eigrp_tlv_len , eigrp_tlv_type , tlv_tlen , byte_length , bit_length ; uint8_t prefix [ 4 ] ; union { const struct eigrp_tlv_general_parm_t * eigrp_tlv_general_parm ; const struct eigrp_tlv_sw_version_t * eigrp_tlv_sw_version ; const struct eigrp_tlv_ip_int_t * eigrp_tlv_ip_int ; const struct eigrp_tlv_ip_ext_t * eigrp_tlv_ip_ext ; const struct eigrp_tlv_at_cable_setup_t * eigrp_tlv_at_cable_setup ; const struct eigrp_tlv_at_int_t * eigrp_tlv_at_int ; const struct eigrp_tlv_at_ext_t * eigrp_tlv_at_ext ; } tlv_ptr ; tptr = pptr ; eigrp_com_header = ( const struct eigrp_common_header * ) pptr ; ND_TCHECK ( * eigrp_com_header ) ; if ( eigrp_com_header -> version != EIGRP_VERSION ) { ND_PRINT ( ( ndo , ""EIGRP<S2SV_blank>version<S2SV_blank>%u<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" , eigrp_com_header -> version ) ) ; return ; } if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , ""EIGRP<S2SV_blank>%s,<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( eigrp_opcode_values , ""unknown<S2SV_blank>(%u)"" , eigrp_com_header -> opcode ) , len ) ) ; return ; }  tlen = len - sizeof ( struct eigrp_common_header ) ;  ND_PRINT ( ( ndo , ""\\n\\tEIGRP<S2SV_blank>v%u,<S2SV_blank>opcode:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>chksum:<S2SV_blank>0x%04x,<S2SV_blank>Flags:<S2SV_blank>[%s]\\n\\tseq:<S2SV_blank>0x%08x,<S2SV_blank>ack:<S2SV_blank>0x%08x,<S2SV_blank>AS:<S2SV_blank>%u,<S2SV_blank>length:<S2SV_blank>%u"" , eigrp_com_header -> version , tok2str ( eigrp_opcode_values , ""unknown,<S2SV_blank>type:<S2SV_blank>%u"" , eigrp_com_header -> opcode ) , eigrp_com_header -> opcode , EXTRACT_16BITS ( & eigrp_com_header -> checksum ) , tok2str ( eigrp_common_header_flag_values , ""none"" , EXTRACT_32BITS ( & eigrp_com_header -> flags ) ) , EXTRACT_32BITS ( & eigrp_com_header -> seq ) , EXTRACT_32BITS ( & eigrp_com_header -> ack ) , EXTRACT_32BITS ( & eigrp_com_header -> asn ) , tlen ) ) ; tptr += sizeof ( const struct eigrp_common_header ) ; while ( tlen > 0 ) { ND_TCHECK2 ( * tptr , sizeof ( struct eigrp_tlv_header ) ) ; eigrp_tlv_header = ( const struct eigrp_tlv_header * ) tptr ; eigrp_tlv_len = EXTRACT_16BITS ( & eigrp_tlv_header -> length ) ; eigrp_tlv_type = EXTRACT_16BITS ( & eigrp_tlv_header -> type ) ; if ( eigrp_tlv_len < sizeof ( struct eigrp_tlv_header ) || eigrp_tlv_len > tlen ) { print_unknown_data ( ndo , tptr + sizeof ( struct eigrp_tlv_header ) , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; return ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>TLV<S2SV_blank>(0x%04x),<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( eigrp_tlv_values , ""Unknown"" , eigrp_tlv_type ) , eigrp_tlv_type , eigrp_tlv_len ) ) ;  tlv_tptr = tptr + sizeof ( struct eigrp_tlv_header ) ;  tlv_tlen = eigrp_tlv_len - sizeof ( struct eigrp_tlv_header ) ; ND_TCHECK2 ( * tptr , eigrp_tlv_len ) ; switch ( eigrp_tlv_type ) { case EIGRP_TLV_GENERAL_PARM : tlv_ptr . eigrp_tlv_general_parm = ( const struct eigrp_tlv_general_parm_t * ) tlv_tptr ;  ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>holdtime:<S2SV_blank>%us,<S2SV_blank>k1<S2SV_blank>%u,<S2SV_blank>k2<S2SV_blank>%u,<S2SV_blank>k3<S2SV_blank>%u,<S2SV_blank>k4<S2SV_blank>%u,<S2SV_blank>k5<S2SV_blank>%u"" ,  EXTRACT_16BITS ( tlv_ptr . eigrp_tlv_general_parm -> holdtime ) , tlv_ptr . eigrp_tlv_general_parm -> k1 , tlv_ptr . eigrp_tlv_general_parm -> k2 , tlv_ptr . eigrp_tlv_general_parm -> k3 , tlv_ptr . eigrp_tlv_general_parm -> k4 , tlv_ptr . eigrp_tlv_general_parm -> k5 ) ) ; break ; case EIGRP_TLV_SW_VERSION : tlv_ptr . eigrp_tlv_sw_version = ( const struct eigrp_tlv_sw_version_t * ) tlv_tptr ;  ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IOS<S2SV_blank>version:<S2SV_blank>%u.%u,<S2SV_blank>EIGRP<S2SV_blank>version<S2SV_blank>%u.%u"" ,  tlv_ptr . eigrp_tlv_sw_version -> ios_major , tlv_ptr . eigrp_tlv_sw_version -> ios_minor , tlv_ptr . eigrp_tlv_sw_version -> eigrp_major , tlv_ptr . eigrp_tlv_sw_version -> eigrp_minor ) ) ; break ; case EIGRP_TLV_IP_INT : tlv_ptr . eigrp_tlv_ip_int = ( const struct eigrp_tlv_ip_int_t * ) tlv_tptr ;  bit_length = tlv_ptr . eigrp_tlv_ip_int -> plen ;  if ( bit_length > 32 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>illegal<S2SV_blank>prefix<S2SV_blank>length<S2SV_blank>%u"" , bit_length ) ) ; break ; } byte_length = ( bit_length + 7 ) / 8 ; memset ( prefix , 0 , 4 ) ; memcpy ( prefix , & tlv_ptr . eigrp_tlv_ip_int -> destination , byte_length ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv4<S2SV_blank>prefix:<S2SV_blank>%15s/%u,<S2SV_blank>nexthop:<S2SV_blank>"" , ipaddr_string ( ndo , prefix ) , bit_length ) ) ; if ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_int -> nexthop ) == 0 ) ND_PRINT ( ( ndo , ""self"" ) ) ; else ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , & tlv_ptr . eigrp_tlv_ip_int -> nexthop ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>delay<S2SV_blank>%u<S2SV_blank>ms,<S2SV_blank>bandwidth<S2SV_blank>%u<S2SV_blank>Kbps,<S2SV_blank>mtu<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u,<S2SV_blank>reliability<S2SV_blank>%u,<S2SV_blank>load<S2SV_blank>%u"" , ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_int -> delay ) / 100 ) , EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_int -> bandwidth ) , EXTRACT_24BITS ( & tlv_ptr . eigrp_tlv_ip_int -> mtu ) , tlv_ptr . eigrp_tlv_ip_int -> hopcount , tlv_ptr . eigrp_tlv_ip_int -> reliability , tlv_ptr . eigrp_tlv_ip_int -> load ) ) ; break ; case EIGRP_TLV_IP_EXT : tlv_ptr . eigrp_tlv_ip_ext = ( const struct eigrp_tlv_ip_ext_t * ) tlv_tptr ;  bit_length = tlv_ptr . eigrp_tlv_ip_ext -> plen ;  if ( bit_length > 32 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>illegal<S2SV_blank>prefix<S2SV_blank>length<S2SV_blank>%u"" , bit_length ) ) ; break ; } byte_length = ( bit_length + 7 ) / 8 ; memset ( prefix , 0 , 4 ) ; memcpy ( prefix , & tlv_ptr . eigrp_tlv_ip_ext -> destination , byte_length ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv4<S2SV_blank>prefix:<S2SV_blank>%15s/%u,<S2SV_blank>nexthop:<S2SV_blank>"" , ipaddr_string ( ndo , prefix ) , bit_length ) ) ; if ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_ext -> nexthop ) == 0 ) ND_PRINT ( ( ndo , ""self"" ) ) ; else ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , & tlv_ptr . eigrp_tlv_ip_ext -> nexthop ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>origin-router<S2SV_blank>%s,<S2SV_blank>origin-as<S2SV_blank>%u,<S2SV_blank>origin-proto<S2SV_blank>%s,<S2SV_blank>flags<S2SV_blank>[0x%02x],<S2SV_blank>tag<S2SV_blank>0x%08x,<S2SV_blank>metric<S2SV_blank>%u"" , ipaddr_string ( ndo , tlv_ptr . eigrp_tlv_ip_ext -> origin_router ) , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_ip_ext -> origin_as ) , tok2str ( eigrp_ext_proto_id_values , ""unknown"" , tlv_ptr . eigrp_tlv_ip_ext -> proto_id ) , tlv_ptr . eigrp_tlv_ip_ext -> flags , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_ip_ext -> tag ) , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_ip_ext -> metric ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>delay<S2SV_blank>%u<S2SV_blank>ms,<S2SV_blank>bandwidth<S2SV_blank>%u<S2SV_blank>Kbps,<S2SV_blank>mtu<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u,<S2SV_blank>reliability<S2SV_blank>%u,<S2SV_blank>load<S2SV_blank>%u"" , ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_ext -> delay ) / 100 ) , EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_ext -> bandwidth ) , EXTRACT_24BITS ( & tlv_ptr . eigrp_tlv_ip_ext -> mtu ) , tlv_ptr . eigrp_tlv_ip_ext -> hopcount , tlv_ptr . eigrp_tlv_ip_ext -> reliability , tlv_ptr . eigrp_tlv_ip_ext -> load ) ) ; break ; case EIGRP_TLV_AT_CABLE_SETUP : tlv_ptr . eigrp_tlv_at_cable_setup = ( const struct eigrp_tlv_at_cable_setup_t * ) tlv_tptr ;  ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Cable-range:<S2SV_blank>%u-%u,<S2SV_blank>Router-ID<S2SV_blank>%u"" ,  EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_cable_setup -> cable_start ) , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_cable_setup -> cable_end ) , EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_cable_setup -> router_id ) ) ) ; break ; case EIGRP_TLV_AT_INT :  tlv_ptr . eigrp_tlv_at_int = ( const struct eigrp_tlv_at_int_t * ) tlv_tptr ;  ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Cable-Range:<S2SV_blank>%u-%u,<S2SV_blank>nexthop:<S2SV_blank>"" , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_int -> cable_start ) , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_int -> cable_end ) ) ) ; if ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_int -> nexthop ) == 0 ) ND_PRINT ( ( ndo , ""self"" ) ) ; else ND_PRINT ( ( ndo , ""%u.%u"" , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_int -> nexthop ) , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_int -> nexthop [ 2 ] ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>delay<S2SV_blank>%u<S2SV_blank>ms,<S2SV_blank>bandwidth<S2SV_blank>%u<S2SV_blank>Kbps,<S2SV_blank>mtu<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u,<S2SV_blank>reliability<S2SV_blank>%u,<S2SV_blank>load<S2SV_blank>%u"" , ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_int -> delay ) / 100 ) , EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_int -> bandwidth ) , EXTRACT_24BITS ( & tlv_ptr . eigrp_tlv_at_int -> mtu ) , tlv_ptr . eigrp_tlv_at_int -> hopcount , tlv_ptr . eigrp_tlv_at_int -> reliability , tlv_ptr . eigrp_tlv_at_int -> load ) ) ; break ; case EIGRP_TLV_AT_EXT : tlv_ptr . eigrp_tlv_at_ext = ( const struct eigrp_tlv_at_ext_t * ) tlv_tptr ;  ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Cable-Range:<S2SV_blank>%u-%u,<S2SV_blank>nexthop:<S2SV_blank>"" ,  EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_ext -> cable_start ) , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_ext -> cable_end ) ) ) ; if ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_ext -> nexthop ) == 0 ) ND_PRINT ( ( ndo , ""self"" ) ) ; else ND_PRINT ( ( ndo , ""%u.%u"" , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_ext -> nexthop ) , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_ext -> nexthop [ 2 ] ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>origin-router<S2SV_blank>%u,<S2SV_blank>origin-as<S2SV_blank>%u,<S2SV_blank>origin-proto<S2SV_blank>%s,<S2SV_blank>flags<S2SV_blank>[0x%02x],<S2SV_blank>tag<S2SV_blank>0x%08x,<S2SV_blank>metric<S2SV_blank>%u"" , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_at_ext -> origin_router ) , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_at_ext -> origin_as ) , tok2str ( eigrp_ext_proto_id_values , ""unknown"" , tlv_ptr . eigrp_tlv_at_ext -> proto_id ) , tlv_ptr . eigrp_tlv_at_ext -> flags , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_at_ext -> tag ) , EXTRACT_16BITS ( tlv_ptr . eigrp_tlv_at_ext -> metric ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>delay<S2SV_blank>%u<S2SV_blank>ms,<S2SV_blank>bandwidth<S2SV_blank>%u<S2SV_blank>Kbps,<S2SV_blank>mtu<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u,<S2SV_blank>reliability<S2SV_blank>%u,<S2SV_blank>load<S2SV_blank>%u"" , ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_ext -> delay ) / 100 ) , EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_ext -> bandwidth ) , EXTRACT_24BITS ( & tlv_ptr . eigrp_tlv_at_ext -> mtu ) , tlv_ptr . eigrp_tlv_at_ext -> hopcount , tlv_ptr . eigrp_tlv_at_ext -> reliability , tlv_ptr . eigrp_tlv_at_ext -> load ) ) ; break ; case EIGRP_TLV_AUTH : case EIGRP_TLV_SEQ : case EIGRP_TLV_MCAST_SEQ : case EIGRP_TLV_IPX_INT : case EIGRP_TLV_IPX_EXT : default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tlv_tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlv_tlen ) ; break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , tptr + sizeof ( struct eigrp_tlv_header ) , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , eigrp_tlv_len - sizeof ( struct eigrp_tlv_header ) ) ; tptr += eigrp_tlv_len ; tlen -= eigrp_tlv_len ; } return ; trunc : ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank>packet<S2SV_blank>exceeded<S2SV_blank>snapshot"" ) ) ; }","tlv_tptr = tptr + sizeof ( struct eigrp_tlv_header ) ;tlv_tlen = eigrp_tlv_len - sizeof ( struct eigrp_tlv_header ) ;if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_general_parm ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_general_parm ) ) ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_sw_version ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_sw_version ) ) ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_ip_int ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_ip_int ) ) ) ) ;break ;}bit_length = tlv_ptr . eigrp_tlv_ip_int -> plen ;if ( bit_length > 32 ) {",146
201,"buggy line: bit_length = tlv_ptr . eigrp_tlv_ip_ext -> plen ;if ( bit_length > 32 ) {cwe id:CWE-125context: void eigrp_print ( netdissect_options * ndo , register const u_char * pptr , register u_int len ) { const struct eigrp_common_header * eigrp_com_header ; const struct eigrp_tlv_header * eigrp_tlv_header ; const u_char * tptr , * tlv_tptr ; u_int tlen , eigrp_tlv_len , eigrp_tlv_type , tlv_tlen , byte_length , bit_length ; uint8_t prefix [ 4 ] ; union { const struct eigrp_tlv_general_parm_t * eigrp_tlv_general_parm ; const struct eigrp_tlv_sw_version_t * eigrp_tlv_sw_version ; const struct eigrp_tlv_ip_int_t * eigrp_tlv_ip_int ; const struct eigrp_tlv_ip_ext_t * eigrp_tlv_ip_ext ; const struct eigrp_tlv_at_cable_setup_t * eigrp_tlv_at_cable_setup ; const struct eigrp_tlv_at_int_t * eigrp_tlv_at_int ; const struct eigrp_tlv_at_ext_t * eigrp_tlv_at_ext ; } tlv_ptr ; tptr = pptr ; eigrp_com_header = ( const struct eigrp_common_header * ) pptr ; ND_TCHECK ( * eigrp_com_header ) ; if ( eigrp_com_header -> version != EIGRP_VERSION ) { ND_PRINT ( ( ndo , ""EIGRP<S2SV_blank>version<S2SV_blank>%u<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" , eigrp_com_header -> version ) ) ; return ; } if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , ""EIGRP<S2SV_blank>%s,<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( eigrp_opcode_values , ""unknown<S2SV_blank>(%u)"" , eigrp_com_header -> opcode ) , len ) ) ; return ; }  tlen = len - sizeof ( struct eigrp_common_header ) ;  ND_PRINT ( ( ndo , ""\\n\\tEIGRP<S2SV_blank>v%u,<S2SV_blank>opcode:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>chksum:<S2SV_blank>0x%04x,<S2SV_blank>Flags:<S2SV_blank>[%s]\\n\\tseq:<S2SV_blank>0x%08x,<S2SV_blank>ack:<S2SV_blank>0x%08x,<S2SV_blank>AS:<S2SV_blank>%u,<S2SV_blank>length:<S2SV_blank>%u"" , eigrp_com_header -> version , tok2str ( eigrp_opcode_values , ""unknown,<S2SV_blank>type:<S2SV_blank>%u"" , eigrp_com_header -> opcode ) , eigrp_com_header -> opcode , EXTRACT_16BITS ( & eigrp_com_header -> checksum ) , tok2str ( eigrp_common_header_flag_values , ""none"" , EXTRACT_32BITS ( & eigrp_com_header -> flags ) ) , EXTRACT_32BITS ( & eigrp_com_header -> seq ) , EXTRACT_32BITS ( & eigrp_com_header -> ack ) , EXTRACT_32BITS ( & eigrp_com_header -> asn ) , tlen ) ) ; tptr += sizeof ( const struct eigrp_common_header ) ; while ( tlen > 0 ) { ND_TCHECK2 ( * tptr , sizeof ( struct eigrp_tlv_header ) ) ; eigrp_tlv_header = ( const struct eigrp_tlv_header * ) tptr ; eigrp_tlv_len = EXTRACT_16BITS ( & eigrp_tlv_header -> length ) ; eigrp_tlv_type = EXTRACT_16BITS ( & eigrp_tlv_header -> type ) ; if ( eigrp_tlv_len < sizeof ( struct eigrp_tlv_header ) || eigrp_tlv_len > tlen ) { print_unknown_data ( ndo , tptr + sizeof ( struct eigrp_tlv_header ) , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; return ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>TLV<S2SV_blank>(0x%04x),<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( eigrp_tlv_values , ""Unknown"" , eigrp_tlv_type ) , eigrp_tlv_type , eigrp_tlv_len ) ) ;  tlv_tptr = tptr + sizeof ( struct eigrp_tlv_header ) ;  tlv_tlen = eigrp_tlv_len - sizeof ( struct eigrp_tlv_header ) ; ND_TCHECK2 ( * tptr , eigrp_tlv_len ) ; switch ( eigrp_tlv_type ) { case EIGRP_TLV_GENERAL_PARM : tlv_ptr . eigrp_tlv_general_parm = ( const struct eigrp_tlv_general_parm_t * ) tlv_tptr ;  ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>holdtime:<S2SV_blank>%us,<S2SV_blank>k1<S2SV_blank>%u,<S2SV_blank>k2<S2SV_blank>%u,<S2SV_blank>k3<S2SV_blank>%u,<S2SV_blank>k4<S2SV_blank>%u,<S2SV_blank>k5<S2SV_blank>%u"" ,  EXTRACT_16BITS ( tlv_ptr . eigrp_tlv_general_parm -> holdtime ) , tlv_ptr . eigrp_tlv_general_parm -> k1 , tlv_ptr . eigrp_tlv_general_parm -> k2 , tlv_ptr . eigrp_tlv_general_parm -> k3 , tlv_ptr . eigrp_tlv_general_parm -> k4 , tlv_ptr . eigrp_tlv_general_parm -> k5 ) ) ; break ; case EIGRP_TLV_SW_VERSION : tlv_ptr . eigrp_tlv_sw_version = ( const struct eigrp_tlv_sw_version_t * ) tlv_tptr ;  ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IOS<S2SV_blank>version:<S2SV_blank>%u.%u,<S2SV_blank>EIGRP<S2SV_blank>version<S2SV_blank>%u.%u"" ,  tlv_ptr . eigrp_tlv_sw_version -> ios_major , tlv_ptr . eigrp_tlv_sw_version -> ios_minor , tlv_ptr . eigrp_tlv_sw_version -> eigrp_major , tlv_ptr . eigrp_tlv_sw_version -> eigrp_minor ) ) ; break ; case EIGRP_TLV_IP_INT : tlv_ptr . eigrp_tlv_ip_int = ( const struct eigrp_tlv_ip_int_t * ) tlv_tptr ;  bit_length = tlv_ptr . eigrp_tlv_ip_int -> plen ;  if ( bit_length > 32 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>illegal<S2SV_blank>prefix<S2SV_blank>length<S2SV_blank>%u"" , bit_length ) ) ; break ; } byte_length = ( bit_length + 7 ) / 8 ; memset ( prefix , 0 , 4 ) ; memcpy ( prefix , & tlv_ptr . eigrp_tlv_ip_int -> destination , byte_length ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv4<S2SV_blank>prefix:<S2SV_blank>%15s/%u,<S2SV_blank>nexthop:<S2SV_blank>"" , ipaddr_string ( ndo , prefix ) , bit_length ) ) ; if ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_int -> nexthop ) == 0 ) ND_PRINT ( ( ndo , ""self"" ) ) ; else ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , & tlv_ptr . eigrp_tlv_ip_int -> nexthop ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>delay<S2SV_blank>%u<S2SV_blank>ms,<S2SV_blank>bandwidth<S2SV_blank>%u<S2SV_blank>Kbps,<S2SV_blank>mtu<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u,<S2SV_blank>reliability<S2SV_blank>%u,<S2SV_blank>load<S2SV_blank>%u"" , ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_int -> delay ) / 100 ) , EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_int -> bandwidth ) , EXTRACT_24BITS ( & tlv_ptr . eigrp_tlv_ip_int -> mtu ) , tlv_ptr . eigrp_tlv_ip_int -> hopcount , tlv_ptr . eigrp_tlv_ip_int -> reliability , tlv_ptr . eigrp_tlv_ip_int -> load ) ) ; break ; case EIGRP_TLV_IP_EXT : tlv_ptr . eigrp_tlv_ip_ext = ( const struct eigrp_tlv_ip_ext_t * ) tlv_tptr ;  bit_length = tlv_ptr . eigrp_tlv_ip_ext -> plen ;  if ( bit_length > 32 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>illegal<S2SV_blank>prefix<S2SV_blank>length<S2SV_blank>%u"" , bit_length ) ) ; break ; } byte_length = ( bit_length + 7 ) / 8 ; memset ( prefix , 0 , 4 ) ; memcpy ( prefix , & tlv_ptr . eigrp_tlv_ip_ext -> destination , byte_length ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv4<S2SV_blank>prefix:<S2SV_blank>%15s/%u,<S2SV_blank>nexthop:<S2SV_blank>"" , ipaddr_string ( ndo , prefix ) , bit_length ) ) ; if ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_ext -> nexthop ) == 0 ) ND_PRINT ( ( ndo , ""self"" ) ) ; else ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , & tlv_ptr . eigrp_tlv_ip_ext -> nexthop ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>origin-router<S2SV_blank>%s,<S2SV_blank>origin-as<S2SV_blank>%u,<S2SV_blank>origin-proto<S2SV_blank>%s,<S2SV_blank>flags<S2SV_blank>[0x%02x],<S2SV_blank>tag<S2SV_blank>0x%08x,<S2SV_blank>metric<S2SV_blank>%u"" , ipaddr_string ( ndo , tlv_ptr . eigrp_tlv_ip_ext -> origin_router ) , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_ip_ext -> origin_as ) , tok2str ( eigrp_ext_proto_id_values , ""unknown"" , tlv_ptr . eigrp_tlv_ip_ext -> proto_id ) , tlv_ptr . eigrp_tlv_ip_ext -> flags , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_ip_ext -> tag ) , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_ip_ext -> metric ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>delay<S2SV_blank>%u<S2SV_blank>ms,<S2SV_blank>bandwidth<S2SV_blank>%u<S2SV_blank>Kbps,<S2SV_blank>mtu<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u,<S2SV_blank>reliability<S2SV_blank>%u,<S2SV_blank>load<S2SV_blank>%u"" , ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_ext -> delay ) / 100 ) , EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_ext -> bandwidth ) , EXTRACT_24BITS ( & tlv_ptr . eigrp_tlv_ip_ext -> mtu ) , tlv_ptr . eigrp_tlv_ip_ext -> hopcount , tlv_ptr . eigrp_tlv_ip_ext -> reliability , tlv_ptr . eigrp_tlv_ip_ext -> load ) ) ; break ; case EIGRP_TLV_AT_CABLE_SETUP : tlv_ptr . eigrp_tlv_at_cable_setup = ( const struct eigrp_tlv_at_cable_setup_t * ) tlv_tptr ;  ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Cable-range:<S2SV_blank>%u-%u,<S2SV_blank>Router-ID<S2SV_blank>%u"" ,  EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_cable_setup -> cable_start ) , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_cable_setup -> cable_end ) , EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_cable_setup -> router_id ) ) ) ; break ; case EIGRP_TLV_AT_INT :  tlv_ptr . eigrp_tlv_at_int = ( const struct eigrp_tlv_at_int_t * ) tlv_tptr ;  ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Cable-Range:<S2SV_blank>%u-%u,<S2SV_blank>nexthop:<S2SV_blank>"" , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_int -> cable_start ) , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_int -> cable_end ) ) ) ; if ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_int -> nexthop ) == 0 ) ND_PRINT ( ( ndo , ""self"" ) ) ; else ND_PRINT ( ( ndo , ""%u.%u"" , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_int -> nexthop ) , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_int -> nexthop [ 2 ] ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>delay<S2SV_blank>%u<S2SV_blank>ms,<S2SV_blank>bandwidth<S2SV_blank>%u<S2SV_blank>Kbps,<S2SV_blank>mtu<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u,<S2SV_blank>reliability<S2SV_blank>%u,<S2SV_blank>load<S2SV_blank>%u"" , ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_int -> delay ) / 100 ) , EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_int -> bandwidth ) , EXTRACT_24BITS ( & tlv_ptr . eigrp_tlv_at_int -> mtu ) , tlv_ptr . eigrp_tlv_at_int -> hopcount , tlv_ptr . eigrp_tlv_at_int -> reliability , tlv_ptr . eigrp_tlv_at_int -> load ) ) ; break ; case EIGRP_TLV_AT_EXT : tlv_ptr . eigrp_tlv_at_ext = ( const struct eigrp_tlv_at_ext_t * ) tlv_tptr ;  ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Cable-Range:<S2SV_blank>%u-%u,<S2SV_blank>nexthop:<S2SV_blank>"" ,  EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_ext -> cable_start ) , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_ext -> cable_end ) ) ) ; if ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_ext -> nexthop ) == 0 ) ND_PRINT ( ( ndo , ""self"" ) ) ; else ND_PRINT ( ( ndo , ""%u.%u"" , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_ext -> nexthop ) , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_ext -> nexthop [ 2 ] ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>origin-router<S2SV_blank>%u,<S2SV_blank>origin-as<S2SV_blank>%u,<S2SV_blank>origin-proto<S2SV_blank>%s,<S2SV_blank>flags<S2SV_blank>[0x%02x],<S2SV_blank>tag<S2SV_blank>0x%08x,<S2SV_blank>metric<S2SV_blank>%u"" , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_at_ext -> origin_router ) , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_at_ext -> origin_as ) , tok2str ( eigrp_ext_proto_id_values , ""unknown"" , tlv_ptr . eigrp_tlv_at_ext -> proto_id ) , tlv_ptr . eigrp_tlv_at_ext -> flags , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_at_ext -> tag ) , EXTRACT_16BITS ( tlv_ptr . eigrp_tlv_at_ext -> metric ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>delay<S2SV_blank>%u<S2SV_blank>ms,<S2SV_blank>bandwidth<S2SV_blank>%u<S2SV_blank>Kbps,<S2SV_blank>mtu<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u,<S2SV_blank>reliability<S2SV_blank>%u,<S2SV_blank>load<S2SV_blank>%u"" , ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_ext -> delay ) / 100 ) , EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_ext -> bandwidth ) , EXTRACT_24BITS ( & tlv_ptr . eigrp_tlv_at_ext -> mtu ) , tlv_ptr . eigrp_tlv_at_ext -> hopcount , tlv_ptr . eigrp_tlv_at_ext -> reliability , tlv_ptr . eigrp_tlv_at_ext -> load ) ) ; break ; case EIGRP_TLV_AUTH : case EIGRP_TLV_SEQ : case EIGRP_TLV_MCAST_SEQ : case EIGRP_TLV_IPX_INT : case EIGRP_TLV_IPX_EXT : default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tlv_tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlv_tlen ) ; break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , tptr + sizeof ( struct eigrp_tlv_header ) , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , eigrp_tlv_len - sizeof ( struct eigrp_tlv_header ) ) ; tptr += eigrp_tlv_len ; tlen -= eigrp_tlv_len ; } return ; trunc : ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank>packet<S2SV_blank>exceeded<S2SV_blank>snapshot"" ) ) ; }","if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_ip_ext ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_ip_ext ) ) ) ) ;break ;}bit_length = tlv_ptr . eigrp_tlv_ip_ext -> plen ;if ( bit_length > 32 ) {",146
202,"buggy line: ND_PRINT ( ( ndo , ""\\\case EIGRP_TLV_AT_INT :  tlv_ptr . eigrp_tlv_at_int = ( const struct eigrp_tlv_at_int_t * ) tlv_tptr ;ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\cwe id:CWE-125context: void eigrp_print ( netdissect_options * ndo , register const u_char * pptr , register u_int len ) { const struct eigrp_common_header * eigrp_com_header ; const struct eigrp_tlv_header * eigrp_tlv_header ; const u_char * tptr , * tlv_tptr ; u_int tlen , eigrp_tlv_len , eigrp_tlv_type , tlv_tlen , byte_length , bit_length ; uint8_t prefix [ 4 ] ; union { const struct eigrp_tlv_general_parm_t * eigrp_tlv_general_parm ; const struct eigrp_tlv_sw_version_t * eigrp_tlv_sw_version ; const struct eigrp_tlv_ip_int_t * eigrp_tlv_ip_int ; const struct eigrp_tlv_ip_ext_t * eigrp_tlv_ip_ext ; const struct eigrp_tlv_at_cable_setup_t * eigrp_tlv_at_cable_setup ; const struct eigrp_tlv_at_int_t * eigrp_tlv_at_int ; const struct eigrp_tlv_at_ext_t * eigrp_tlv_at_ext ; } tlv_ptr ; tptr = pptr ; eigrp_com_header = ( const struct eigrp_common_header * ) pptr ; ND_TCHECK ( * eigrp_com_header ) ; if ( eigrp_com_header -> version != EIGRP_VERSION ) { ND_PRINT ( ( ndo , ""EIGRP<S2SV_blank>version<S2SV_blank>%u<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" , eigrp_com_header -> version ) ) ; return ; } if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , ""EIGRP<S2SV_blank>%s,<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( eigrp_opcode_values , ""unknown<S2SV_blank>(%u)"" , eigrp_com_header -> opcode ) , len ) ) ; return ; }  tlen = len - sizeof ( struct eigrp_common_header ) ;  ND_PRINT ( ( ndo , ""\\n\\tEIGRP<S2SV_blank>v%u,<S2SV_blank>opcode:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>chksum:<S2SV_blank>0x%04x,<S2SV_blank>Flags:<S2SV_blank>[%s]\\n\\tseq:<S2SV_blank>0x%08x,<S2SV_blank>ack:<S2SV_blank>0x%08x,<S2SV_blank>AS:<S2SV_blank>%u,<S2SV_blank>length:<S2SV_blank>%u"" , eigrp_com_header -> version , tok2str ( eigrp_opcode_values , ""unknown,<S2SV_blank>type:<S2SV_blank>%u"" , eigrp_com_header -> opcode ) , eigrp_com_header -> opcode , EXTRACT_16BITS ( & eigrp_com_header -> checksum ) , tok2str ( eigrp_common_header_flag_values , ""none"" , EXTRACT_32BITS ( & eigrp_com_header -> flags ) ) , EXTRACT_32BITS ( & eigrp_com_header -> seq ) , EXTRACT_32BITS ( & eigrp_com_header -> ack ) , EXTRACT_32BITS ( & eigrp_com_header -> asn ) , tlen ) ) ; tptr += sizeof ( const struct eigrp_common_header ) ; while ( tlen > 0 ) { ND_TCHECK2 ( * tptr , sizeof ( struct eigrp_tlv_header ) ) ; eigrp_tlv_header = ( const struct eigrp_tlv_header * ) tptr ; eigrp_tlv_len = EXTRACT_16BITS ( & eigrp_tlv_header -> length ) ; eigrp_tlv_type = EXTRACT_16BITS ( & eigrp_tlv_header -> type ) ; if ( eigrp_tlv_len < sizeof ( struct eigrp_tlv_header ) || eigrp_tlv_len > tlen ) { print_unknown_data ( ndo , tptr + sizeof ( struct eigrp_tlv_header ) , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; return ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>TLV<S2SV_blank>(0x%04x),<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( eigrp_tlv_values , ""Unknown"" , eigrp_tlv_type ) , eigrp_tlv_type , eigrp_tlv_len ) ) ;  tlv_tptr = tptr + sizeof ( struct eigrp_tlv_header ) ;  tlv_tlen = eigrp_tlv_len - sizeof ( struct eigrp_tlv_header ) ; ND_TCHECK2 ( * tptr , eigrp_tlv_len ) ; switch ( eigrp_tlv_type ) { case EIGRP_TLV_GENERAL_PARM : tlv_ptr . eigrp_tlv_general_parm = ( const struct eigrp_tlv_general_parm_t * ) tlv_tptr ;  ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>holdtime:<S2SV_blank>%us,<S2SV_blank>k1<S2SV_blank>%u,<S2SV_blank>k2<S2SV_blank>%u,<S2SV_blank>k3<S2SV_blank>%u,<S2SV_blank>k4<S2SV_blank>%u,<S2SV_blank>k5<S2SV_blank>%u"" ,  EXTRACT_16BITS ( tlv_ptr . eigrp_tlv_general_parm -> holdtime ) , tlv_ptr . eigrp_tlv_general_parm -> k1 , tlv_ptr . eigrp_tlv_general_parm -> k2 , tlv_ptr . eigrp_tlv_general_parm -> k3 , tlv_ptr . eigrp_tlv_general_parm -> k4 , tlv_ptr . eigrp_tlv_general_parm -> k5 ) ) ; break ; case EIGRP_TLV_SW_VERSION : tlv_ptr . eigrp_tlv_sw_version = ( const struct eigrp_tlv_sw_version_t * ) tlv_tptr ;  ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IOS<S2SV_blank>version:<S2SV_blank>%u.%u,<S2SV_blank>EIGRP<S2SV_blank>version<S2SV_blank>%u.%u"" ,  tlv_ptr . eigrp_tlv_sw_version -> ios_major , tlv_ptr . eigrp_tlv_sw_version -> ios_minor , tlv_ptr . eigrp_tlv_sw_version -> eigrp_major , tlv_ptr . eigrp_tlv_sw_version -> eigrp_minor ) ) ; break ; case EIGRP_TLV_IP_INT : tlv_ptr . eigrp_tlv_ip_int = ( const struct eigrp_tlv_ip_int_t * ) tlv_tptr ;  bit_length = tlv_ptr . eigrp_tlv_ip_int -> plen ;  if ( bit_length > 32 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>illegal<S2SV_blank>prefix<S2SV_blank>length<S2SV_blank>%u"" , bit_length ) ) ; break ; } byte_length = ( bit_length + 7 ) / 8 ; memset ( prefix , 0 , 4 ) ; memcpy ( prefix , & tlv_ptr . eigrp_tlv_ip_int -> destination , byte_length ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv4<S2SV_blank>prefix:<S2SV_blank>%15s/%u,<S2SV_blank>nexthop:<S2SV_blank>"" , ipaddr_string ( ndo , prefix ) , bit_length ) ) ; if ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_int -> nexthop ) == 0 ) ND_PRINT ( ( ndo , ""self"" ) ) ; else ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , & tlv_ptr . eigrp_tlv_ip_int -> nexthop ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>delay<S2SV_blank>%u<S2SV_blank>ms,<S2SV_blank>bandwidth<S2SV_blank>%u<S2SV_blank>Kbps,<S2SV_blank>mtu<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u,<S2SV_blank>reliability<S2SV_blank>%u,<S2SV_blank>load<S2SV_blank>%u"" , ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_int -> delay ) / 100 ) , EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_int -> bandwidth ) , EXTRACT_24BITS ( & tlv_ptr . eigrp_tlv_ip_int -> mtu ) , tlv_ptr . eigrp_tlv_ip_int -> hopcount , tlv_ptr . eigrp_tlv_ip_int -> reliability , tlv_ptr . eigrp_tlv_ip_int -> load ) ) ; break ; case EIGRP_TLV_IP_EXT : tlv_ptr . eigrp_tlv_ip_ext = ( const struct eigrp_tlv_ip_ext_t * ) tlv_tptr ;  bit_length = tlv_ptr . eigrp_tlv_ip_ext -> plen ;  if ( bit_length > 32 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>illegal<S2SV_blank>prefix<S2SV_blank>length<S2SV_blank>%u"" , bit_length ) ) ; break ; } byte_length = ( bit_length + 7 ) / 8 ; memset ( prefix , 0 , 4 ) ; memcpy ( prefix , & tlv_ptr . eigrp_tlv_ip_ext -> destination , byte_length ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv4<S2SV_blank>prefix:<S2SV_blank>%15s/%u,<S2SV_blank>nexthop:<S2SV_blank>"" , ipaddr_string ( ndo , prefix ) , bit_length ) ) ; if ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_ext -> nexthop ) == 0 ) ND_PRINT ( ( ndo , ""self"" ) ) ; else ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , & tlv_ptr . eigrp_tlv_ip_ext -> nexthop ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>origin-router<S2SV_blank>%s,<S2SV_blank>origin-as<S2SV_blank>%u,<S2SV_blank>origin-proto<S2SV_blank>%s,<S2SV_blank>flags<S2SV_blank>[0x%02x],<S2SV_blank>tag<S2SV_blank>0x%08x,<S2SV_blank>metric<S2SV_blank>%u"" , ipaddr_string ( ndo , tlv_ptr . eigrp_tlv_ip_ext -> origin_router ) , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_ip_ext -> origin_as ) , tok2str ( eigrp_ext_proto_id_values , ""unknown"" , tlv_ptr . eigrp_tlv_ip_ext -> proto_id ) , tlv_ptr . eigrp_tlv_ip_ext -> flags , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_ip_ext -> tag ) , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_ip_ext -> metric ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>delay<S2SV_blank>%u<S2SV_blank>ms,<S2SV_blank>bandwidth<S2SV_blank>%u<S2SV_blank>Kbps,<S2SV_blank>mtu<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u,<S2SV_blank>reliability<S2SV_blank>%u,<S2SV_blank>load<S2SV_blank>%u"" , ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_ext -> delay ) / 100 ) , EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_ext -> bandwidth ) , EXTRACT_24BITS ( & tlv_ptr . eigrp_tlv_ip_ext -> mtu ) , tlv_ptr . eigrp_tlv_ip_ext -> hopcount , tlv_ptr . eigrp_tlv_ip_ext -> reliability , tlv_ptr . eigrp_tlv_ip_ext -> load ) ) ; break ; case EIGRP_TLV_AT_CABLE_SETUP : tlv_ptr . eigrp_tlv_at_cable_setup = ( const struct eigrp_tlv_at_cable_setup_t * ) tlv_tptr ;  ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Cable-range:<S2SV_blank>%u-%u,<S2SV_blank>Router-ID<S2SV_blank>%u"" ,  EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_cable_setup -> cable_start ) , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_cable_setup -> cable_end ) , EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_cable_setup -> router_id ) ) ) ; break ; case EIGRP_TLV_AT_INT :  tlv_ptr . eigrp_tlv_at_int = ( const struct eigrp_tlv_at_int_t * ) tlv_tptr ;  ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Cable-Range:<S2SV_blank>%u-%u,<S2SV_blank>nexthop:<S2SV_blank>"" , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_int -> cable_start ) , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_int -> cable_end ) ) ) ; if ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_int -> nexthop ) == 0 ) ND_PRINT ( ( ndo , ""self"" ) ) ; else ND_PRINT ( ( ndo , ""%u.%u"" , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_int -> nexthop ) , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_int -> nexthop [ 2 ] ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>delay<S2SV_blank>%u<S2SV_blank>ms,<S2SV_blank>bandwidth<S2SV_blank>%u<S2SV_blank>Kbps,<S2SV_blank>mtu<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u,<S2SV_blank>reliability<S2SV_blank>%u,<S2SV_blank>load<S2SV_blank>%u"" , ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_int -> delay ) / 100 ) , EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_int -> bandwidth ) , EXTRACT_24BITS ( & tlv_ptr . eigrp_tlv_at_int -> mtu ) , tlv_ptr . eigrp_tlv_at_int -> hopcount , tlv_ptr . eigrp_tlv_at_int -> reliability , tlv_ptr . eigrp_tlv_at_int -> load ) ) ; break ; case EIGRP_TLV_AT_EXT : tlv_ptr . eigrp_tlv_at_ext = ( const struct eigrp_tlv_at_ext_t * ) tlv_tptr ;  ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Cable-Range:<S2SV_blank>%u-%u,<S2SV_blank>nexthop:<S2SV_blank>"" ,  EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_ext -> cable_start ) , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_ext -> cable_end ) ) ) ; if ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_ext -> nexthop ) == 0 ) ND_PRINT ( ( ndo , ""self"" ) ) ; else ND_PRINT ( ( ndo , ""%u.%u"" , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_ext -> nexthop ) , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_ext -> nexthop [ 2 ] ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>origin-router<S2SV_blank>%u,<S2SV_blank>origin-as<S2SV_blank>%u,<S2SV_blank>origin-proto<S2SV_blank>%s,<S2SV_blank>flags<S2SV_blank>[0x%02x],<S2SV_blank>tag<S2SV_blank>0x%08x,<S2SV_blank>metric<S2SV_blank>%u"" , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_at_ext -> origin_router ) , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_at_ext -> origin_as ) , tok2str ( eigrp_ext_proto_id_values , ""unknown"" , tlv_ptr . eigrp_tlv_at_ext -> proto_id ) , tlv_ptr . eigrp_tlv_at_ext -> flags , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_at_ext -> tag ) , EXTRACT_16BITS ( tlv_ptr . eigrp_tlv_at_ext -> metric ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>delay<S2SV_blank>%u<S2SV_blank>ms,<S2SV_blank>bandwidth<S2SV_blank>%u<S2SV_blank>Kbps,<S2SV_blank>mtu<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u,<S2SV_blank>reliability<S2SV_blank>%u,<S2SV_blank>load<S2SV_blank>%u"" , ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_ext -> delay ) / 100 ) , EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_ext -> bandwidth ) , EXTRACT_24BITS ( & tlv_ptr . eigrp_tlv_at_ext -> mtu ) , tlv_ptr . eigrp_tlv_at_ext -> hopcount , tlv_ptr . eigrp_tlv_at_ext -> reliability , tlv_ptr . eigrp_tlv_at_ext -> load ) ) ; break ; case EIGRP_TLV_AUTH : case EIGRP_TLV_SEQ : case EIGRP_TLV_MCAST_SEQ : case EIGRP_TLV_IPX_INT : case EIGRP_TLV_IPX_EXT : default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tlv_tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlv_tlen ) ; break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , tptr + sizeof ( struct eigrp_tlv_header ) , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , eigrp_tlv_len - sizeof ( struct eigrp_tlv_header ) ) ; tptr += eigrp_tlv_len ; tlen -= eigrp_tlv_len ; } return ; trunc : ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank>packet<S2SV_blank>exceeded<S2SV_blank>snapshot"" ) ) ; }","if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_cable_setup ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_cable_setup ) ) ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\case EIGRP_TLV_AT_INT : tlv_ptr . eigrp_tlv_at_int = ( const struct eigrp_tlv_at_int_t * ) tlv_tptr ;if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_int ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_int ) ) ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_ext ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_ext ) ) ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\",146
203,"buggy line: # if CONFIG_MEM_MANAGER  int number_aau ;if ( vpx_mm_create_heap_memory ( ) < 0 ) {_P ( printf ( ""[vpx][mm]<S2SV_blank>ERROR<S2SV_blank>vpx_memalign()<S2SV_blank>Couldn\\\'t<S2SV_blank>create<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>Heap.\\\) }number_aau = ( ( size + align - 1 + ADDRESS_STORAGE_SIZE ) >> SHIFT_HMM_ADDR_ALIGN_UNIT ) + 1 ;# endif  if ( addr ) {cwe id:CWE-119context: void * vpx_memalign ( size_t align , size_t size ) { void * addr , * x = NULL ;  # if CONFIG_MEM_MANAGER  int number_aau ; if ( vpx_mm_create_heap_memory ( ) < 0 ) { _P ( printf ( ""[vpx][mm]<S2SV_blank>ERROR<S2SV_blank>vpx_memalign()<S2SV_blank>Couldn\'t<S2SV_blank>create<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>Heap.\\n"" ) ; ) } number_aau = ( ( size + align - 1 + ADDRESS_STORAGE_SIZE ) >> SHIFT_HMM_ADDR_ALIGN_UNIT ) + 1 ; addr = hmm_alloc ( & hmm_d , number_aau ) ; # else addr = VPX_MALLOC_L ( size + align - 1 + ADDRESS_STORAGE_SIZE ) ;  # endif  if ( addr ) { x = align_addr ( ( unsigned char * ) addr + ADDRESS_STORAGE_SIZE , ( int ) align ) ; ( ( size_t * ) x ) [ - 1 ] = ( size_t ) addr ; } return x ; }",addr = malloc ( size + align - 1 + ADDRESS_STORAGE_SIZE ) >> SHIFT_HMM_ADDR_ALIGN_UNIT ) + 1 ;if ( addr ) {,147
204,"buggy line: int indexes = SQUASHFS_LOOKUP_BLOCKS ( sBlk . s . inodes ) ;long long export_index_table [ indexes ] ;res = read_fs_bytes ( fd , sBlk . s . lookup_table_start ,  SQUASHFS_LOOKUP_BLOCK_BYTES ( sBlk . s . inodes ) , export_index_table ) ;cwe id:CWE-20context: static int parse_exports_table ( long long * table_start ) { int res ;  int indexes = SQUASHFS_LOOKUP_BLOCKS ( sBlk . s . inodes ) ;   long long export_index_table [ indexes ] ;   res = read_fs_bytes ( fd , sBlk . s . lookup_table_start ,  SQUASHFS_LOOKUP_BLOCK_BYTES ( sBlk . s . inodes ) , export_index_table ) ; if ( res == FALSE ) { ERROR ( ""parse_exports_table:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>export<S2SV_blank>index<S2SV_blank>table\\n"" ) ; return FALSE ; } SQUASHFS_INSWAP_LOOKUP_BLOCKS ( export_index_table , indexes ) ; * table_start = export_index_table [ 0 ] ; return TRUE ; }","int indexes = SQUASHFS_LOOKUP_BLOCKS ( ( long long ) sBlk . s . inodes ) ;int length = SQUASHFS_LOOKUP_BLOCK_BYTES ( ( long long ) sBlk . s . inodes ) ;long long * export_index_table ;if ( length != ( * table_start - sBlk . s . lookup_table_start ) ) {ERROR ( ""parse_exports_table:<S2SV_blank>Bad<S2SV_blank>inode<S2SV_blank>count<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\\return FALSE ;}export_index_table = alloc_index_table ( indexes ) ;res = read_fs_bytes ( fd , sBlk . s . lookup_table_start , length , export_index_table ) ;",148
205,"buggy line: ptr = strchr ( ptr + 1 , '/' ) + 1 ;rw_exit ( & sdvp -> sdev_contents ) ;cwe id:CWE-000context: static int devzvol_readdir ( struct vnode * dvp , struct uio * uiop , struct cred * cred , int * eofp , caller_context_t * ct_unused , int flags_unused ) { struct sdev_node * sdvp = VTOSDEV ( dvp ) ; char * ptr ; sdcmn_err13 ( ( ""zv<S2SV_blank>readdir<S2SV_blank>of<S2SV_blank>\'%s\'<S2SV_blank>%s\'"" , sdvp -> sdev_path , sdvp -> sdev_name ) ) ; if ( strcmp ( sdvp -> sdev_path , ZVOL_DIR ) == 0 ) { struct vnode * vp ; rw_exit ( & sdvp -> sdev_contents ) ; ( void ) devname_lookup_func ( sdvp , ""dsk"" , & vp , cred , devzvol_create_dir , SDEV_VATTR ) ; VN_RELE ( vp ) ; ( void ) devname_lookup_func ( sdvp , ""rdsk"" , & vp , cred , devzvol_create_dir , SDEV_VATTR ) ; VN_RELE ( vp ) ; rw_enter ( & sdvp -> sdev_contents , RW_READER ) ; return ( devname_readdir_func ( dvp , uiop , cred , eofp , 0 ) ) ; } if ( uiop -> uio_offset == 0 ) devzvol_prunedir ( sdvp ) ; ptr = sdvp -> sdev_path + strlen ( ZVOL_DIR ) ; if ( ( strcmp ( ptr , ""/dsk"" ) == 0 ) || ( strcmp ( ptr , ""/rdsk"" ) == 0 ) ) { rw_exit ( & sdvp -> sdev_contents ) ; devzvol_create_pool_dirs ( dvp ) ; rw_enter ( & sdvp -> sdev_contents , RW_READER ) ; return ( devname_readdir_func ( dvp , uiop , cred , eofp , 0 ) ) ; }  ptr = strchr ( ptr + 1 , '/' ) + 1 ;  rw_exit ( & sdvp -> sdev_contents ) ; sdev_iter_datasets ( dvp , ZFS_IOC_DATASET_LIST_NEXT , ptr ) ; rw_enter ( & sdvp -> sdev_contents , RW_READER ) ; return ( devname_readdir_func ( dvp , uiop , cred , eofp , 0 ) ) ; }","ptr = strchr ( ptr + 1 , '/' ) ;if ( ptr == NULL ) return ( ENOENT ) ;ptr ++ ;rw_exit ( & sdvp -> sdev_contents ) ;",149
206,"buggy line: flags |= EXT4_GET_BLOCKS_PRE_IO ;return ext4_split_extent ( handle , inode , path , map , split_flag , flags ) ;cwe id:CWE-362context: static int ext4_split_unwritten_extents ( handle_t * handle , struct inode * inode , struct ext4_map_blocks * map , struct ext4_ext_path * path , int flags ) { ext4_lblk_t eof_block ; ext4_lblk_t ee_block ; struct ext4_extent * ex ; unsigned int ee_len ; int split_flag = 0 , depth ; ext_debug ( ""ext4_split_unwritten_extents:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>logical"" ""block<S2SV_blank>%llu,<S2SV_blank>max_blocks<S2SV_blank>%u\\n"" , inode -> i_ino , ( unsigned long long ) map -> m_lblk , map -> m_len ) ; eof_block = ( inode -> i_size + inode -> i_sb -> s_blocksize - 1 ) >> inode -> i_sb -> s_blocksize_bits ; if ( eof_block < map -> m_lblk + map -> m_len ) eof_block = map -> m_lblk + map -> m_len ; depth = ext_depth ( inode ) ; ex = path [ depth ] . p_ext ; ee_block = le32_to_cpu ( ex -> ee_block ) ; ee_len = ext4_ext_get_actual_len ( ex ) ; split_flag |= ee_block + ee_len <= eof_block ? EXT4_EXT_MAY_ZEROOUT : 0 ; split_flag |= EXT4_EXT_MARK_UNINIT2 ;  flags |= EXT4_GET_BLOCKS_PRE_IO ;  return ext4_split_extent ( handle , inode , path , map , split_flag , flags ) ; }","if ( flags & EXT4_GET_BLOCKS_CONVERT ) split_flag |= EXT4_EXT_DATA_VALID2 ;flags |= EXT4_GET_BLOCKS_PRE_IO ;return ext4_split_extent ( handle , inode , path , map , split_flag , flags ) ;",150
207,"buggy line: ret = posix_acl_equiv_mode ( acl , & new_mode ) ;if ( ret < 0 ) goto out ;if ( ret == 0 ) acl = NULL ;cwe id:CWE-285context: int ceph_set_acl ( struct inode * inode , struct posix_acl * acl , int type ) { int ret = 0 , size = 0 ; const char * name = NULL ; char * value = NULL ; struct iattr newattrs ; umode_t new_mode = inode -> i_mode , old_mode = inode -> i_mode ; switch ( type ) { case ACL_TYPE_ACCESS : name = XATTR_NAME_POSIX_ACL_ACCESS ; if ( acl ) {  ret = posix_acl_equiv_mode ( acl , & new_mode ) ;  if ( ret < 0 ) goto out ; if ( ret == 0 ) acl = NULL ; } break ; case ACL_TYPE_DEFAULT : if ( ! S_ISDIR ( inode -> i_mode ) ) { ret = acl ? - EINVAL : 0 ; goto out ; } name = XATTR_NAME_POSIX_ACL_DEFAULT ; break ; default : ret = - EINVAL ; goto out ; } if ( acl ) { size = posix_acl_xattr_size ( acl -> a_count ) ; value = kmalloc ( size , GFP_NOFS ) ; if ( ! value ) { ret = - ENOMEM ; goto out ; } ret = posix_acl_to_xattr ( & init_user_ns , acl , value , size ) ; if ( ret < 0 ) goto out_free ; } if ( new_mode != old_mode ) { newattrs . ia_mode = new_mode ; newattrs . ia_valid = ATTR_MODE ; ret = __ceph_setattr ( inode , & newattrs ) ; if ( ret ) goto out_free ; } ret = __ceph_setxattr ( inode , name , value , size , 0 ) ; if ( ret ) { if ( new_mode != old_mode ) { newattrs . ia_mode = old_mode ; newattrs . ia_valid = ATTR_MODE ; __ceph_setattr ( inode , & newattrs ) ; } goto out_free ; } ceph_set_cached_acl ( inode , type , acl ) ; out_free : kfree ( value ) ; out : return ret ; }","ret = posix_acl_update_mode ( inode , & new_mode , & acl ) ;if ( ret ) goto out ;",151
208,"buggy line: else return apr_psprintf ( cmd -> pool , ""ModSecurity:<S2SV_blank>Invalid<S2SV_blank>value<S2SV_blank>for<S2SV_blank>SecRuleEngine:<S2SV_blank>%s"" , p1 ) ;return NULL ;cwe id:CWE-611context: static const char * cmd_hash_engine ( cmd_parms * cmd , void * _dcfg , const char * p1 ) { directory_config * dcfg = ( directory_config * ) _dcfg ; if ( dcfg == NULL ) return NULL ; if ( strcasecmp ( p1 , ""on"" ) == 0 ) { dcfg -> hash_is_enabled = HASH_ENABLED ; dcfg -> hash_enforcement = HASH_ENABLED ; } else if ( strcasecmp ( p1 , ""off"" ) == 0 ) { dcfg -> hash_is_enabled = HASH_DISABLED ; dcfg -> hash_enforcement = HASH_DISABLED ; }  else return apr_psprintf ( cmd -> pool , ""ModSecurity:<S2SV_blank>Invalid<S2SV_blank>value<S2SV_blank>for<S2SV_blank>SecRuleEngine:<S2SV_blank>%s"" , p1 ) ;  return NULL ; }","else return apr_psprintf ( cmd -> pool , ""ModSecurity:<S2SV_blank>Invalid<S2SV_blank>value<S2SV_blank>for<S2SV_blank>SexHashEngine:<S2SV_blank>%s"" , p1 ) ;return NULL ;",152
209,"buggy line: cwe id:CWE-416context: int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ;  final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ;  dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }",rcu_read_lock ( ) ;,153
210,"buggy line: final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ;dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ;cwe id:CWE-416context: int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ;  final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ;  dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }","final_p = fl6_update_dst ( & fl6 , rcu_dereference ( np -> opt ) , & final ) ;rcu_read_unlock ( ) ;dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ;",153
211,"buggy line: uint16 nstrips = 0 , ntiles = 0 , planar = 0 ;uint16 bps = 0 , spp = 0 , res_unit = 0 ;cwe id:CWE-119context: static int loadImage ( TIFF * in , struct image_data * image , struct dump_opts * dump , unsigned char * * read_ptr ) { uint32 i ; float xres = 0.0 , yres = 0.0 ;  uint16 nstrips = 0 , ntiles = 0 , planar = 0 ;  uint16 bps = 0 , spp = 0 , res_unit = 0 ; uint16 orientation = 0 ; uint16 input_compression = 0 , input_photometric = 0 ; uint16 subsampling_horiz , subsampling_vert ; uint32 width = 0 , length = 0 ; uint32 stsize = 0 , tlsize = 0 , buffsize = 0 , scanlinesize = 0 ; uint32 tw = 0 , tl = 0 ; uint32 tile_rowsize = 0 ; unsigned char * read_buff = NULL ; unsigned char * new_buff = NULL ; int readunit = 0 ; static uint32 prev_readsize = 0 ; TIFFGetFieldDefaulted ( in , TIFFTAG_BITSPERSAMPLE , & bps ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_SAMPLESPERPIXEL , & spp ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_PLANARCONFIG , & planar ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_ORIENTATION , & orientation ) ; if ( ! TIFFGetFieldDefaulted ( in , TIFFTAG_PHOTOMETRIC , & input_photometric ) ) TIFFError ( ""loadImage"" , ""Image<S2SV_blank>lacks<S2SV_blank>Photometric<S2SV_blank>interpreation<S2SV_blank>tag"" ) ; if ( ! TIFFGetField ( in , TIFFTAG_IMAGEWIDTH , & width ) ) TIFFError ( ""loadimage"" , ""Image<S2SV_blank>lacks<S2SV_blank>image<S2SV_blank>width<S2SV_blank>tag"" ) ; if ( ! TIFFGetField ( in , TIFFTAG_IMAGELENGTH , & length ) ) TIFFError ( ""loadimage"" , ""Image<S2SV_blank>lacks<S2SV_blank>image<S2SV_blank>length<S2SV_blank>tag"" ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_XRESOLUTION , & xres ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_YRESOLUTION , & yres ) ; if ( ! TIFFGetFieldDefaulted ( in , TIFFTAG_RESOLUTIONUNIT , & res_unit ) ) res_unit = RESUNIT_INCH ; if ( ! TIFFGetField ( in , TIFFTAG_COMPRESSION , & input_compression ) ) input_compression = COMPRESSION_NONE ; # ifdef DEBUG2 char compressionid [ 16 ] ; switch ( input_compression ) { case COMPRESSION_NONE : strcpy ( compressionid , ""None/dump"" ) ; break ; case COMPRESSION_CCITTRLE : strcpy ( compressionid , ""Huffman<S2SV_blank>RLE"" ) ; break ; case COMPRESSION_CCITTFAX3 : strcpy ( compressionid , ""Group3<S2SV_blank>Fax"" ) ; break ; case COMPRESSION_CCITTFAX4 : strcpy ( compressionid , ""Group4<S2SV_blank>Fax"" ) ; break ; case COMPRESSION_LZW : strcpy ( compressionid , ""LZW"" ) ; break ; case COMPRESSION_OJPEG : strcpy ( compressionid , ""Old<S2SV_blank>Jpeg"" ) ; break ; case COMPRESSION_JPEG : strcpy ( compressionid , ""New<S2SV_blank>Jpeg"" ) ; break ; case COMPRESSION_NEXT : strcpy ( compressionid , ""Next<S2SV_blank>RLE"" ) ; break ; case COMPRESSION_CCITTRLEW : strcpy ( compressionid , ""CITTRLEW"" ) ; break ; case COMPRESSION_PACKBITS : strcpy ( compressionid , ""Mac<S2SV_blank>Packbits"" ) ; break ; case COMPRESSION_THUNDERSCAN : strcpy ( compressionid , ""Thunderscan"" ) ; break ; case COMPRESSION_IT8CTPAD : strcpy ( compressionid , ""IT8<S2SV_blank>padded"" ) ; break ; case COMPRESSION_IT8LW : strcpy ( compressionid , ""IT8<S2SV_blank>RLE"" ) ; break ; case COMPRESSION_IT8MP : strcpy ( compressionid , ""IT8<S2SV_blank>mono"" ) ; break ; case COMPRESSION_IT8BL : strcpy ( compressionid , ""IT8<S2SV_blank>lineart"" ) ; break ; case COMPRESSION_PIXARFILM : strcpy ( compressionid , ""Pixar<S2SV_blank>10<S2SV_blank>bit"" ) ; break ; case COMPRESSION_PIXARLOG : strcpy ( compressionid , ""Pixar<S2SV_blank>11bit"" ) ; break ; case COMPRESSION_DEFLATE : strcpy ( compressionid , ""Deflate"" ) ; break ; case COMPRESSION_ADOBE_DEFLATE : strcpy ( compressionid , ""Adobe<S2SV_blank>deflate"" ) ; break ; default : strcpy ( compressionid , ""None/unknown"" ) ; break ; } TIFFError ( ""loadImage"" , ""Input<S2SV_blank>compression<S2SV_blank>%s"" , compressionid ) ; # endif scanlinesize = TIFFScanlineSize ( in ) ; image -> bps = bps ; image -> spp = spp ; image -> planar = planar ; image -> width = width ; image -> length = length ; image -> xres = xres ; image -> yres = yres ; image -> res_unit = res_unit ; image -> compression = input_compression ; image -> photometric = input_photometric ; # ifdef DEBUG2 char photometricid [ 12 ] ; switch ( input_photometric ) { case PHOTOMETRIC_MINISWHITE : strcpy ( photometricid , ""MinIsWhite"" ) ; break ; case PHOTOMETRIC_MINISBLACK : strcpy ( photometricid , ""MinIsBlack"" ) ; break ; case PHOTOMETRIC_RGB : strcpy ( photometricid , ""RGB"" ) ; break ; case PHOTOMETRIC_PALETTE : strcpy ( photometricid , ""Palette"" ) ; break ; case PHOTOMETRIC_MASK : strcpy ( photometricid , ""Mask"" ) ; break ; case PHOTOMETRIC_SEPARATED : strcpy ( photometricid , ""Separated"" ) ; break ; case PHOTOMETRIC_YCBCR : strcpy ( photometricid , ""YCBCR"" ) ; break ; case PHOTOMETRIC_CIELAB : strcpy ( photometricid , ""CIELab"" ) ; break ; case PHOTOMETRIC_ICCLAB : strcpy ( photometricid , ""ICCLab"" ) ; break ; case PHOTOMETRIC_ITULAB : strcpy ( photometricid , ""ITULab"" ) ; break ; case PHOTOMETRIC_LOGL : strcpy ( photometricid , ""LogL"" ) ; break ; case PHOTOMETRIC_LOGLUV : strcpy ( photometricid , ""LOGLuv"" ) ; break ; default : strcpy ( photometricid , ""Unknown"" ) ; break ; } TIFFError ( ""loadImage"" , ""Input<S2SV_blank>photometric<S2SV_blank>interpretation<S2SV_blank>%s"" , photometricid ) ; # endif image -> orientation = orientation ; switch ( orientation ) { case 0 : case ORIENTATION_TOPLEFT : image -> adjustments = 0 ; break ; case ORIENTATION_TOPRIGHT : image -> adjustments = MIRROR_HORIZ ; break ; case ORIENTATION_BOTRIGHT : image -> adjustments = ROTATECW_180 ; break ; case ORIENTATION_BOTLEFT : image -> adjustments = MIRROR_VERT ; break ; case ORIENTATION_LEFTTOP : image -> adjustments = MIRROR_VERT | ROTATECW_90 ; break ; case ORIENTATION_RIGHTTOP : image -> adjustments = ROTATECW_90 ; break ; case ORIENTATION_RIGHTBOT : image -> adjustments = MIRROR_VERT | ROTATECW_270 ; break ; case ORIENTATION_LEFTBOT : image -> adjustments = ROTATECW_270 ; break ; default : image -> adjustments = 0 ; image -> orientation = ORIENTATION_TOPLEFT ; } if ( ( bps == 0 ) || ( spp == 0 ) ) { TIFFError ( ""loadImage"" , ""Invalid<S2SV_blank>samples<S2SV_blank>per<S2SV_blank>pixel<S2SV_blank>(%d)<S2SV_blank>or<S2SV_blank>bits<S2SV_blank>per<S2SV_blank>sample<S2SV_blank>(%d)"" , spp , bps ) ; return ( - 1 ) ; } if ( TIFFIsTiled ( in ) ) { readunit = TILE ; tlsize = TIFFTileSize ( in ) ; ntiles = TIFFNumberOfTiles ( in ) ; TIFFGetField ( in , TIFFTAG_TILEWIDTH , & tw ) ; TIFFGetField ( in , TIFFTAG_TILELENGTH , & tl ) ; tile_rowsize = TIFFTileRowSize ( in ) ; if ( ntiles == 0 || tlsize == 0 || tile_rowsize == 0 ) { TIFFError ( ""loadImage"" , ""File<S2SV_blank>appears<S2SV_blank>to<S2SV_blank>be<S2SV_blank>tiled,<S2SV_blank>but<S2SV_blank>the<S2SV_blank>number<S2SV_blank>of<S2SV_blank>tiles,<S2SV_blank>tile<S2SV_blank>size,<S2SV_blank>or<S2SV_blank>tile<S2SV_blank>rowsize<S2SV_blank>is<S2SV_blank>zero."" ) ; exit ( - 1 ) ; } buffsize = tlsize * ntiles ; if ( tlsize != ( buffsize / ntiles ) ) { TIFFError ( ""loadImage"" , ""Integer<S2SV_blank>overflow<S2SV_blank>when<S2SV_blank>calculating<S2SV_blank>buffer<S2SV_blank>size"" ) ; exit ( - 1 ) ; } if ( buffsize < ( uint32 ) ( ntiles * tl * tile_rowsize ) ) { buffsize = ntiles * tl * tile_rowsize ; if ( ntiles != ( buffsize / tl / tile_rowsize ) ) { TIFFError ( ""loadImage"" , ""Integer<S2SV_blank>overflow<S2SV_blank>when<S2SV_blank>calculating<S2SV_blank>buffer<S2SV_blank>size"" ) ; exit ( - 1 ) ; } # ifdef DEBUG2 TIFFError ( ""loadImage"" , ""Tilesize<S2SV_blank>%u<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small,<S2SV_blank>using<S2SV_blank>ntiles<S2SV_blank>*<S2SV_blank>tilelength<S2SV_blank>*<S2SV_blank>tilerowsize<S2SV_blank>%lu"" , tlsize , ( unsigned long ) buffsize ) ; # endif } if ( dump -> infile != NULL ) dump_info ( dump -> infile , dump -> format , """" , ""Tilesize:<S2SV_blank>%u,<S2SV_blank>Number<S2SV_blank>of<S2SV_blank>Tiles:<S2SV_blank>%u,<S2SV_blank>Tile<S2SV_blank>row<S2SV_blank>size:<S2SV_blank>%u"" , tlsize , ntiles , tile_rowsize ) ; } else { uint32 buffsize_check ; readunit = STRIP ; TIFFGetFieldDefaulted ( in , TIFFTAG_ROWSPERSTRIP , & rowsperstrip ) ; stsize = TIFFStripSize ( in ) ; nstrips = TIFFNumberOfStrips ( in ) ; if ( nstrips == 0 || stsize == 0 ) { TIFFError ( ""loadImage"" , ""File<S2SV_blank>appears<S2SV_blank>to<S2SV_blank>be<S2SV_blank>striped,<S2SV_blank>but<S2SV_blank>the<S2SV_blank>number<S2SV_blank>of<S2SV_blank>stipes<S2SV_blank>or<S2SV_blank>stripe<S2SV_blank>size<S2SV_blank>is<S2SV_blank>zero."" ) ; exit ( - 1 ) ; } buffsize = stsize * nstrips ; if ( stsize != ( buffsize / nstrips ) ) { TIFFError ( ""loadImage"" , ""Integer<S2SV_blank>overflow<S2SV_blank>when<S2SV_blank>calculating<S2SV_blank>buffer<S2SV_blank>size"" ) ; exit ( - 1 ) ; } buffsize_check = ( ( length * width * spp * bps ) + 7 ) ; if ( length != ( ( buffsize_check - 7 ) / width / spp / bps ) ) { TIFFError ( ""loadImage"" , ""Integer<S2SV_blank>overflow<S2SV_blank>detected."" ) ; exit ( - 1 ) ; } if ( buffsize < ( uint32 ) ( ( ( length * width * spp * bps ) + 7 ) / 8 ) ) { buffsize = ( ( length * width * spp * bps ) + 7 ) / 8 ; # ifdef DEBUG2 TIFFError ( ""loadImage"" , ""Stripsize<S2SV_blank>%u<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small,<S2SV_blank>using<S2SV_blank>imagelength<S2SV_blank>*<S2SV_blank>width<S2SV_blank>*<S2SV_blank>spp<S2SV_blank>*<S2SV_blank>bps<S2SV_blank>/<S2SV_blank>8<S2SV_blank>=<S2SV_blank>%lu"" , stsize , ( unsigned long ) buffsize ) ; # endif } if ( dump -> infile != NULL ) dump_info ( dump -> infile , dump -> format , """" , ""Stripsize:<S2SV_blank>%u,<S2SV_blank>Number<S2SV_blank>of<S2SV_blank>Strips:<S2SV_blank>%u,<S2SV_blank>Rows<S2SV_blank>per<S2SV_blank>Strip:<S2SV_blank>%u,<S2SV_blank>Scanline<S2SV_blank>size:<S2SV_blank>%u"" , stsize , nstrips , rowsperstrip , scanlinesize ) ; } if ( input_compression == COMPRESSION_JPEG ) { jpegcolormode = JPEGCOLORMODE_RGB ; TIFFSetField ( in , TIFFTAG_JPEGCOLORMODE , JPEGCOLORMODE_RGB ) ; } else { if ( input_photometric == PHOTOMETRIC_YCBCR ) { TIFFGetFieldDefaulted ( in , TIFFTAG_YCBCRSUBSAMPLING , & subsampling_horiz , & subsampling_vert ) ; if ( subsampling_horiz != 1 || subsampling_vert != 1 ) { TIFFError ( ""loadImage"" , ""Can\'t<S2SV_blank>copy/convert<S2SV_blank>subsampled<S2SV_blank>image<S2SV_blank>with<S2SV_blank>subsampling<S2SV_blank>%d<S2SV_blank>horiz<S2SV_blank>%d<S2SV_blank>vert"" , subsampling_horiz , subsampling_vert ) ; return ( - 1 ) ; } } } read_buff = * read_ptr ; if ( ! read_buff )  read_buff = ( unsigned char * ) _TIFFmalloc ( buffsize + 3 ) ;   else  { if ( prev_readsize < buffsize )  {  new_buff = _TIFFrealloc ( read_buff , buffsize + 3 ) ; if ( ! new_buff ) { free ( read_buff ) ; read_buff = ( unsigned char * ) _TIFFmalloc ( buffsize + 3 ) ; } else read_buff = new_buff ; } } if ( ! read_buff ) { TIFFError ( ""loadImage"" , ""Unable<S2SV_blank>to<S2SV_blank>allocate/reallocate<S2SV_blank>read<S2SV_blank>buffer"" ) ; return ( - 1 ) ; } read_buff [ buffsize ] = 0 ; read_buff [ buffsize + 1 ] = 0 ; read_buff [ buffsize + 2 ] = 0 ; prev_readsize = buffsize ; * read_ptr = read_buff ; switch ( readunit ) { case STRIP : if ( planar == PLANARCONFIG_CONTIG ) { if ( ! ( readContigStripsIntoBuffer ( in , read_buff ) ) ) { TIFFError ( ""loadImage"" , ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>contiguous<S2SV_blank>strips<S2SV_blank>into<S2SV_blank>buffer"" ) ; return ( - 1 ) ; } } else { if ( ! ( readSeparateStripsIntoBuffer ( in , read_buff , length , width , spp , dump ) ) ) { TIFFError ( ""loadImage"" , ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>separate<S2SV_blank>strips<S2SV_blank>into<S2SV_blank>buffer"" ) ; return ( - 1 ) ; } } break ; case TILE : if ( planar == PLANARCONFIG_CONTIG ) { if ( ! ( readContigTilesIntoBuffer ( in , read_buff , length , width , tw , tl , spp , bps ) ) ) { TIFFError ( ""loadImage"" , ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>contiguous<S2SV_blank>tiles<S2SV_blank>into<S2SV_blank>buffer"" ) ; return ( - 1 ) ; } } else { if ( ! ( readSeparateTilesIntoBuffer ( in , read_buff , length , width , tw , tl , spp , bps ) ) ) { TIFFError ( ""loadImage"" , ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>separate<S2SV_blank>tiles<S2SV_blank>into<S2SV_blank>buffer"" ) ; return ( - 1 ) ; } } break ; default : TIFFError ( ""loadImage"" , ""Unsupported<S2SV_blank>image<S2SV_blank>file<S2SV_blank>format"" ) ; return ( - 1 ) ; break ; } if ( ( dump -> infile != NULL ) && ( dump -> level == 2 ) ) { dump_info ( dump -> infile , dump -> format , ""loadImage"" , ""Image<S2SV_blank>width<S2SV_blank>%d,<S2SV_blank>length<S2SV_blank>%d,<S2SV_blank>Raw<S2SV_blank>image<S2SV_blank>data,<S2SV_blank>%4d<S2SV_blank>bytes"" , width , length , buffsize ) ; dump_info ( dump -> infile , dump -> format , """" , ""Bits<S2SV_blank>per<S2SV_blank>sample<S2SV_blank>%d,<S2SV_blank>Samples<S2SV_blank>per<S2SV_blank>pixel<S2SV_blank>%d"" , bps , spp ) ; for ( i = 0 ; i < length ; i ++ ) dump_buffer ( dump -> infile , dump -> format , 1 , scanlinesize , i , read_buff + ( i * scanlinesize ) ) ; } return ( 0 ) ; }","uint32 nstrips = 0 , ntiles = 0 ;uint16 planar = 0 ;uint16 bps = 0 , spp = 0 , res_unit = 0 ;",154
212,"buggy line: if ( ! read_buff )  read_buff = ( unsigned char * ) _TIFFmalloc ( buffsize + 3 ) ;else  {if ( prev_readsize < buffsize )  {new_buff = _TIFFrealloc ( read_buff , buffsize + 3 ) ;cwe id:CWE-119context: static int loadImage ( TIFF * in , struct image_data * image , struct dump_opts * dump , unsigned char * * read_ptr ) { uint32 i ; float xres = 0.0 , yres = 0.0 ;  uint16 nstrips = 0 , ntiles = 0 , planar = 0 ;  uint16 bps = 0 , spp = 0 , res_unit = 0 ; uint16 orientation = 0 ; uint16 input_compression = 0 , input_photometric = 0 ; uint16 subsampling_horiz , subsampling_vert ; uint32 width = 0 , length = 0 ; uint32 stsize = 0 , tlsize = 0 , buffsize = 0 , scanlinesize = 0 ; uint32 tw = 0 , tl = 0 ; uint32 tile_rowsize = 0 ; unsigned char * read_buff = NULL ; unsigned char * new_buff = NULL ; int readunit = 0 ; static uint32 prev_readsize = 0 ; TIFFGetFieldDefaulted ( in , TIFFTAG_BITSPERSAMPLE , & bps ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_SAMPLESPERPIXEL , & spp ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_PLANARCONFIG , & planar ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_ORIENTATION , & orientation ) ; if ( ! TIFFGetFieldDefaulted ( in , TIFFTAG_PHOTOMETRIC , & input_photometric ) ) TIFFError ( ""loadImage"" , ""Image<S2SV_blank>lacks<S2SV_blank>Photometric<S2SV_blank>interpreation<S2SV_blank>tag"" ) ; if ( ! TIFFGetField ( in , TIFFTAG_IMAGEWIDTH , & width ) ) TIFFError ( ""loadimage"" , ""Image<S2SV_blank>lacks<S2SV_blank>image<S2SV_blank>width<S2SV_blank>tag"" ) ; if ( ! TIFFGetField ( in , TIFFTAG_IMAGELENGTH , & length ) ) TIFFError ( ""loadimage"" , ""Image<S2SV_blank>lacks<S2SV_blank>image<S2SV_blank>length<S2SV_blank>tag"" ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_XRESOLUTION , & xres ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_YRESOLUTION , & yres ) ; if ( ! TIFFGetFieldDefaulted ( in , TIFFTAG_RESOLUTIONUNIT , & res_unit ) ) res_unit = RESUNIT_INCH ; if ( ! TIFFGetField ( in , TIFFTAG_COMPRESSION , & input_compression ) ) input_compression = COMPRESSION_NONE ; # ifdef DEBUG2 char compressionid [ 16 ] ; switch ( input_compression ) { case COMPRESSION_NONE : strcpy ( compressionid , ""None/dump"" ) ; break ; case COMPRESSION_CCITTRLE : strcpy ( compressionid , ""Huffman<S2SV_blank>RLE"" ) ; break ; case COMPRESSION_CCITTFAX3 : strcpy ( compressionid , ""Group3<S2SV_blank>Fax"" ) ; break ; case COMPRESSION_CCITTFAX4 : strcpy ( compressionid , ""Group4<S2SV_blank>Fax"" ) ; break ; case COMPRESSION_LZW : strcpy ( compressionid , ""LZW"" ) ; break ; case COMPRESSION_OJPEG : strcpy ( compressionid , ""Old<S2SV_blank>Jpeg"" ) ; break ; case COMPRESSION_JPEG : strcpy ( compressionid , ""New<S2SV_blank>Jpeg"" ) ; break ; case COMPRESSION_NEXT : strcpy ( compressionid , ""Next<S2SV_blank>RLE"" ) ; break ; case COMPRESSION_CCITTRLEW : strcpy ( compressionid , ""CITTRLEW"" ) ; break ; case COMPRESSION_PACKBITS : strcpy ( compressionid , ""Mac<S2SV_blank>Packbits"" ) ; break ; case COMPRESSION_THUNDERSCAN : strcpy ( compressionid , ""Thunderscan"" ) ; break ; case COMPRESSION_IT8CTPAD : strcpy ( compressionid , ""IT8<S2SV_blank>padded"" ) ; break ; case COMPRESSION_IT8LW : strcpy ( compressionid , ""IT8<S2SV_blank>RLE"" ) ; break ; case COMPRESSION_IT8MP : strcpy ( compressionid , ""IT8<S2SV_blank>mono"" ) ; break ; case COMPRESSION_IT8BL : strcpy ( compressionid , ""IT8<S2SV_blank>lineart"" ) ; break ; case COMPRESSION_PIXARFILM : strcpy ( compressionid , ""Pixar<S2SV_blank>10<S2SV_blank>bit"" ) ; break ; case COMPRESSION_PIXARLOG : strcpy ( compressionid , ""Pixar<S2SV_blank>11bit"" ) ; break ; case COMPRESSION_DEFLATE : strcpy ( compressionid , ""Deflate"" ) ; break ; case COMPRESSION_ADOBE_DEFLATE : strcpy ( compressionid , ""Adobe<S2SV_blank>deflate"" ) ; break ; default : strcpy ( compressionid , ""None/unknown"" ) ; break ; } TIFFError ( ""loadImage"" , ""Input<S2SV_blank>compression<S2SV_blank>%s"" , compressionid ) ; # endif scanlinesize = TIFFScanlineSize ( in ) ; image -> bps = bps ; image -> spp = spp ; image -> planar = planar ; image -> width = width ; image -> length = length ; image -> xres = xres ; image -> yres = yres ; image -> res_unit = res_unit ; image -> compression = input_compression ; image -> photometric = input_photometric ; # ifdef DEBUG2 char photometricid [ 12 ] ; switch ( input_photometric ) { case PHOTOMETRIC_MINISWHITE : strcpy ( photometricid , ""MinIsWhite"" ) ; break ; case PHOTOMETRIC_MINISBLACK : strcpy ( photometricid , ""MinIsBlack"" ) ; break ; case PHOTOMETRIC_RGB : strcpy ( photometricid , ""RGB"" ) ; break ; case PHOTOMETRIC_PALETTE : strcpy ( photometricid , ""Palette"" ) ; break ; case PHOTOMETRIC_MASK : strcpy ( photometricid , ""Mask"" ) ; break ; case PHOTOMETRIC_SEPARATED : strcpy ( photometricid , ""Separated"" ) ; break ; case PHOTOMETRIC_YCBCR : strcpy ( photometricid , ""YCBCR"" ) ; break ; case PHOTOMETRIC_CIELAB : strcpy ( photometricid , ""CIELab"" ) ; break ; case PHOTOMETRIC_ICCLAB : strcpy ( photometricid , ""ICCLab"" ) ; break ; case PHOTOMETRIC_ITULAB : strcpy ( photometricid , ""ITULab"" ) ; break ; case PHOTOMETRIC_LOGL : strcpy ( photometricid , ""LogL"" ) ; break ; case PHOTOMETRIC_LOGLUV : strcpy ( photometricid , ""LOGLuv"" ) ; break ; default : strcpy ( photometricid , ""Unknown"" ) ; break ; } TIFFError ( ""loadImage"" , ""Input<S2SV_blank>photometric<S2SV_blank>interpretation<S2SV_blank>%s"" , photometricid ) ; # endif image -> orientation = orientation ; switch ( orientation ) { case 0 : case ORIENTATION_TOPLEFT : image -> adjustments = 0 ; break ; case ORIENTATION_TOPRIGHT : image -> adjustments = MIRROR_HORIZ ; break ; case ORIENTATION_BOTRIGHT : image -> adjustments = ROTATECW_180 ; break ; case ORIENTATION_BOTLEFT : image -> adjustments = MIRROR_VERT ; break ; case ORIENTATION_LEFTTOP : image -> adjustments = MIRROR_VERT | ROTATECW_90 ; break ; case ORIENTATION_RIGHTTOP : image -> adjustments = ROTATECW_90 ; break ; case ORIENTATION_RIGHTBOT : image -> adjustments = MIRROR_VERT | ROTATECW_270 ; break ; case ORIENTATION_LEFTBOT : image -> adjustments = ROTATECW_270 ; break ; default : image -> adjustments = 0 ; image -> orientation = ORIENTATION_TOPLEFT ; } if ( ( bps == 0 ) || ( spp == 0 ) ) { TIFFError ( ""loadImage"" , ""Invalid<S2SV_blank>samples<S2SV_blank>per<S2SV_blank>pixel<S2SV_blank>(%d)<S2SV_blank>or<S2SV_blank>bits<S2SV_blank>per<S2SV_blank>sample<S2SV_blank>(%d)"" , spp , bps ) ; return ( - 1 ) ; } if ( TIFFIsTiled ( in ) ) { readunit = TILE ; tlsize = TIFFTileSize ( in ) ; ntiles = TIFFNumberOfTiles ( in ) ; TIFFGetField ( in , TIFFTAG_TILEWIDTH , & tw ) ; TIFFGetField ( in , TIFFTAG_TILELENGTH , & tl ) ; tile_rowsize = TIFFTileRowSize ( in ) ; if ( ntiles == 0 || tlsize == 0 || tile_rowsize == 0 ) { TIFFError ( ""loadImage"" , ""File<S2SV_blank>appears<S2SV_blank>to<S2SV_blank>be<S2SV_blank>tiled,<S2SV_blank>but<S2SV_blank>the<S2SV_blank>number<S2SV_blank>of<S2SV_blank>tiles,<S2SV_blank>tile<S2SV_blank>size,<S2SV_blank>or<S2SV_blank>tile<S2SV_blank>rowsize<S2SV_blank>is<S2SV_blank>zero."" ) ; exit ( - 1 ) ; } buffsize = tlsize * ntiles ; if ( tlsize != ( buffsize / ntiles ) ) { TIFFError ( ""loadImage"" , ""Integer<S2SV_blank>overflow<S2SV_blank>when<S2SV_blank>calculating<S2SV_blank>buffer<S2SV_blank>size"" ) ; exit ( - 1 ) ; } if ( buffsize < ( uint32 ) ( ntiles * tl * tile_rowsize ) ) { buffsize = ntiles * tl * tile_rowsize ; if ( ntiles != ( buffsize / tl / tile_rowsize ) ) { TIFFError ( ""loadImage"" , ""Integer<S2SV_blank>overflow<S2SV_blank>when<S2SV_blank>calculating<S2SV_blank>buffer<S2SV_blank>size"" ) ; exit ( - 1 ) ; } # ifdef DEBUG2 TIFFError ( ""loadImage"" , ""Tilesize<S2SV_blank>%u<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small,<S2SV_blank>using<S2SV_blank>ntiles<S2SV_blank>*<S2SV_blank>tilelength<S2SV_blank>*<S2SV_blank>tilerowsize<S2SV_blank>%lu"" , tlsize , ( unsigned long ) buffsize ) ; # endif } if ( dump -> infile != NULL ) dump_info ( dump -> infile , dump -> format , """" , ""Tilesize:<S2SV_blank>%u,<S2SV_blank>Number<S2SV_blank>of<S2SV_blank>Tiles:<S2SV_blank>%u,<S2SV_blank>Tile<S2SV_blank>row<S2SV_blank>size:<S2SV_blank>%u"" , tlsize , ntiles , tile_rowsize ) ; } else { uint32 buffsize_check ; readunit = STRIP ; TIFFGetFieldDefaulted ( in , TIFFTAG_ROWSPERSTRIP , & rowsperstrip ) ; stsize = TIFFStripSize ( in ) ; nstrips = TIFFNumberOfStrips ( in ) ; if ( nstrips == 0 || stsize == 0 ) { TIFFError ( ""loadImage"" , ""File<S2SV_blank>appears<S2SV_blank>to<S2SV_blank>be<S2SV_blank>striped,<S2SV_blank>but<S2SV_blank>the<S2SV_blank>number<S2SV_blank>of<S2SV_blank>stipes<S2SV_blank>or<S2SV_blank>stripe<S2SV_blank>size<S2SV_blank>is<S2SV_blank>zero."" ) ; exit ( - 1 ) ; } buffsize = stsize * nstrips ; if ( stsize != ( buffsize / nstrips ) ) { TIFFError ( ""loadImage"" , ""Integer<S2SV_blank>overflow<S2SV_blank>when<S2SV_blank>calculating<S2SV_blank>buffer<S2SV_blank>size"" ) ; exit ( - 1 ) ; } buffsize_check = ( ( length * width * spp * bps ) + 7 ) ; if ( length != ( ( buffsize_check - 7 ) / width / spp / bps ) ) { TIFFError ( ""loadImage"" , ""Integer<S2SV_blank>overflow<S2SV_blank>detected."" ) ; exit ( - 1 ) ; } if ( buffsize < ( uint32 ) ( ( ( length * width * spp * bps ) + 7 ) / 8 ) ) { buffsize = ( ( length * width * spp * bps ) + 7 ) / 8 ; # ifdef DEBUG2 TIFFError ( ""loadImage"" , ""Stripsize<S2SV_blank>%u<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small,<S2SV_blank>using<S2SV_blank>imagelength<S2SV_blank>*<S2SV_blank>width<S2SV_blank>*<S2SV_blank>spp<S2SV_blank>*<S2SV_blank>bps<S2SV_blank>/<S2SV_blank>8<S2SV_blank>=<S2SV_blank>%lu"" , stsize , ( unsigned long ) buffsize ) ; # endif } if ( dump -> infile != NULL ) dump_info ( dump -> infile , dump -> format , """" , ""Stripsize:<S2SV_blank>%u,<S2SV_blank>Number<S2SV_blank>of<S2SV_blank>Strips:<S2SV_blank>%u,<S2SV_blank>Rows<S2SV_blank>per<S2SV_blank>Strip:<S2SV_blank>%u,<S2SV_blank>Scanline<S2SV_blank>size:<S2SV_blank>%u"" , stsize , nstrips , rowsperstrip , scanlinesize ) ; } if ( input_compression == COMPRESSION_JPEG ) { jpegcolormode = JPEGCOLORMODE_RGB ; TIFFSetField ( in , TIFFTAG_JPEGCOLORMODE , JPEGCOLORMODE_RGB ) ; } else { if ( input_photometric == PHOTOMETRIC_YCBCR ) { TIFFGetFieldDefaulted ( in , TIFFTAG_YCBCRSUBSAMPLING , & subsampling_horiz , & subsampling_vert ) ; if ( subsampling_horiz != 1 || subsampling_vert != 1 ) { TIFFError ( ""loadImage"" , ""Can\'t<S2SV_blank>copy/convert<S2SV_blank>subsampled<S2SV_blank>image<S2SV_blank>with<S2SV_blank>subsampling<S2SV_blank>%d<S2SV_blank>horiz<S2SV_blank>%d<S2SV_blank>vert"" , subsampling_horiz , subsampling_vert ) ; return ( - 1 ) ; } } } read_buff = * read_ptr ; if ( ! read_buff )  read_buff = ( unsigned char * ) _TIFFmalloc ( buffsize + 3 ) ;   else  { if ( prev_readsize < buffsize )  {  new_buff = _TIFFrealloc ( read_buff , buffsize + 3 ) ; if ( ! new_buff ) { free ( read_buff ) ; read_buff = ( unsigned char * ) _TIFFmalloc ( buffsize + 3 ) ; } else read_buff = new_buff ; } } if ( ! read_buff ) { TIFFError ( ""loadImage"" , ""Unable<S2SV_blank>to<S2SV_blank>allocate/reallocate<S2SV_blank>read<S2SV_blank>buffer"" ) ; return ( - 1 ) ; } read_buff [ buffsize ] = 0 ; read_buff [ buffsize + 1 ] = 0 ; read_buff [ buffsize + 2 ] = 0 ; prev_readsize = buffsize ; * read_ptr = read_buff ; switch ( readunit ) { case STRIP : if ( planar == PLANARCONFIG_CONTIG ) { if ( ! ( readContigStripsIntoBuffer ( in , read_buff ) ) ) { TIFFError ( ""loadImage"" , ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>contiguous<S2SV_blank>strips<S2SV_blank>into<S2SV_blank>buffer"" ) ; return ( - 1 ) ; } } else { if ( ! ( readSeparateStripsIntoBuffer ( in , read_buff , length , width , spp , dump ) ) ) { TIFFError ( ""loadImage"" , ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>separate<S2SV_blank>strips<S2SV_blank>into<S2SV_blank>buffer"" ) ; return ( - 1 ) ; } } break ; case TILE : if ( planar == PLANARCONFIG_CONTIG ) { if ( ! ( readContigTilesIntoBuffer ( in , read_buff , length , width , tw , tl , spp , bps ) ) ) { TIFFError ( ""loadImage"" , ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>contiguous<S2SV_blank>tiles<S2SV_blank>into<S2SV_blank>buffer"" ) ; return ( - 1 ) ; } } else { if ( ! ( readSeparateTilesIntoBuffer ( in , read_buff , length , width , tw , tl , spp , bps ) ) ) { TIFFError ( ""loadImage"" , ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>separate<S2SV_blank>tiles<S2SV_blank>into<S2SV_blank>buffer"" ) ; return ( - 1 ) ; } } break ; default : TIFFError ( ""loadImage"" , ""Unsupported<S2SV_blank>image<S2SV_blank>file<S2SV_blank>format"" ) ; return ( - 1 ) ; break ; } if ( ( dump -> infile != NULL ) && ( dump -> level == 2 ) ) { dump_info ( dump -> infile , dump -> format , ""loadImage"" , ""Image<S2SV_blank>width<S2SV_blank>%d,<S2SV_blank>length<S2SV_blank>%d,<S2SV_blank>Raw<S2SV_blank>image<S2SV_blank>data,<S2SV_blank>%4d<S2SV_blank>bytes"" , width , length , buffsize ) ; dump_info ( dump -> infile , dump -> format , """" , ""Bits<S2SV_blank>per<S2SV_blank>sample<S2SV_blank>%d,<S2SV_blank>Samples<S2SV_blank>per<S2SV_blank>pixel<S2SV_blank>%d"" , bps , spp ) ; for ( i = 0 ; i < length ; i ++ ) dump_buffer ( dump -> infile , dump -> format , 1 , scanlinesize , i , read_buff + ( i * scanlinesize ) ) ; } return ( 0 ) ; }","if ( ! read_buff ) {if ( buffsize > 0xFFFFFFFFU - 3 ) {TIFFError ( ""loadImage"" , ""Unable<S2SV_blank>to<S2SV_blank>allocate/reallocate<S2SV_blank>read<S2SV_blank>buffer"" ) ;return ( - 1 ) ;}read_buff = ( unsigned char * ) _TIFFmalloc ( buffsize + 3 ) ;}else {if ( prev_readsize < buffsize ) {if ( buffsize > 0xFFFFFFFFU - 3 ) {TIFFError ( ""loadImage"" , ""Unable<S2SV_blank>to<S2SV_blank>allocate/reallocate<S2SV_blank>read<S2SV_blank>buffer"" ) ;return ( - 1 ) ;}new_buff = _TIFFrealloc ( read_buff , buffsize + 3 ) ;",154
213,"buggy line: if ( 0 ) {# if CONFIG_VP8_ENCODER }cwe id:CWE-119context: static int parse_stream_params ( struct VpxEncoderConfig * global , struct stream_state * stream , char * * argv ) { char * * argi , * * argj ; struct arg arg ; static const arg_def_t * * ctrl_args = no_args ; static const int * ctrl_args_map = NULL ; struct stream_config * config = & stream -> config ; int eos_mark_found = 0 ;  if ( 0 ) {  # if CONFIG_VP8_ENCODER } else if ( strcmp ( global -> codec -> name , ""vp8"" ) == 0 ) { ctrl_args = vp8_args ; ctrl_args_map = vp8_arg_ctrl_map ; # endif # if CONFIG_VP9_ENCODER } else if ( strcmp ( global -> codec -> name , ""vp9"" ) == 0 ) { ctrl_args = vp9_args ; ctrl_args_map = vp9_arg_ctrl_map ; # endif  }  for ( argi = argj = argv ; ( * argj = * argi ) ; argi += arg . argv_step ) { arg . argv_step = 1 ; if ( eos_mark_found ) { argj ++ ; continue ; } else if ( ! strcmp ( * argj , ""--"" ) ) { eos_mark_found = 1 ; continue ; }  if ( 0 ) {  } else if ( arg_match ( & arg , & outputfile , argi ) ) { config -> out_fn = arg . val ; } else if ( arg_match ( & arg , & fpf_name , argi ) ) { config -> stats_fn = arg . val ; } else if ( arg_match ( & arg , & use_ivf , argi ) ) { config -> write_webm = 0 ; } else if ( arg_match ( & arg , & threads , argi ) ) { config -> cfg . g_threads = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & profile , argi ) ) { config -> cfg . g_profile = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & width , argi ) ) { config -> cfg . g_w = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & height , argi ) ) { config -> cfg . g_h = arg_parse_uint ( & arg ) ;  } else if ( arg_match ( & arg , & stereo_mode , argi ) ) {   config -> stereo_fmt = arg_parse_enum_or_int ( & arg ) ;  } else if ( arg_match ( & arg , & timebase , argi ) ) { config -> cfg . g_timebase = arg_parse_rational ( & arg ) ; validate_positive_rational ( arg . name , & config -> cfg . g_timebase ) ; } else if ( arg_match ( & arg , & error_resilient , argi ) ) { config -> cfg . g_error_resilient = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & lag_in_frames , argi ) ) { config -> cfg . g_lag_in_frames = arg_parse_uint ( & arg ) ; if ( global -> deadline == VPX_DL_REALTIME && config -> cfg . g_lag_in_frames != 0 ) { warn ( ""non-zero<S2SV_blank>%s<S2SV_blank>option<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>realtime<S2SV_blank>mode.\\n"" , arg . name ) ; config -> cfg . g_lag_in_frames = 0 ; } } else if ( arg_match ( & arg , & dropframe_thresh , argi ) ) { config -> cfg . rc_dropframe_thresh = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & resize_allowed , argi ) ) { config -> cfg . rc_resize_allowed = arg_parse_uint ( & arg ) ;  } else if ( arg_match ( & arg , & resize_up_thresh , argi ) ) {  config -> cfg . rc_resize_up_thresh = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & resize_down_thresh , argi ) ) { config -> cfg . rc_resize_down_thresh = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & end_usage , argi ) ) { config -> cfg . rc_end_usage = arg_parse_enum_or_int ( & arg ) ; } else if ( arg_match ( & arg , & target_bitrate , argi ) ) { config -> cfg . rc_target_bitrate = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & min_quantizer , argi ) ) { config -> cfg . rc_min_quantizer = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & max_quantizer , argi ) ) { config -> cfg . rc_max_quantizer = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & undershoot_pct , argi ) ) { config -> cfg . rc_undershoot_pct = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & overshoot_pct , argi ) ) { config -> cfg . rc_overshoot_pct = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & buf_sz , argi ) ) { config -> cfg . rc_buf_sz = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & buf_initial_sz , argi ) ) { config -> cfg . rc_buf_initial_sz = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & buf_optimal_sz , argi ) ) { config -> cfg . rc_buf_optimal_sz = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & bias_pct , argi ) ) { config -> cfg . rc_2pass_vbr_bias_pct = arg_parse_uint ( & arg ) ; if ( global -> passes < 2 ) warn ( ""option<S2SV_blank>%s<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>one-pass<S2SV_blank>mode.\\n"" , arg . name ) ; } else if ( arg_match ( & arg , & minsection_pct , argi ) ) { config -> cfg . rc_2pass_vbr_minsection_pct = arg_parse_uint ( & arg ) ; if ( global -> passes < 2 ) warn ( ""option<S2SV_blank>%s<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>one-pass<S2SV_blank>mode.\\n"" , arg . name ) ; } else if ( arg_match ( & arg , & maxsection_pct , argi ) ) { config -> cfg . rc_2pass_vbr_maxsection_pct = arg_parse_uint ( & arg ) ; if ( global -> passes < 2 ) warn ( ""option<S2SV_blank>%s<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>one-pass<S2SV_blank>mode.\\n"" , arg . name ) ; } else if ( arg_match ( & arg , & kf_min_dist , argi ) ) { config -> cfg . kf_min_dist = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & kf_max_dist , argi ) ) { config -> cfg . kf_max_dist = arg_parse_uint ( & arg ) ; config -> have_kf_max_dist = 1 ; } else if ( arg_match ( & arg , & kf_disabled , argi ) ) {  config -> cfg . kf_mode = VPX_KF_DISABLED ;  } else { int i , match = 0 ; for ( i = 0 ; ctrl_args [ i ] ; i ++ ) { if ( arg_match ( & arg , ctrl_args [ i ] , argi ) ) { int j ; match = 1 ; for ( j = 0 ; j < config -> arg_ctrl_cnt ; j ++ )  if ( config -> arg_ctrls [ j ] [ 0 ] == ctrl_args_map [ i ] )  break ;  assert ( j < ARG_CTRL_CNT_MAX ) ;   if ( j < ARG_CTRL_CNT_MAX ) {  config -> arg_ctrls [ j ] [ 0 ] = ctrl_args_map [ i ] ; config -> arg_ctrls [ j ] [ 1 ] = arg_parse_enum_or_int ( & arg ) ; if ( j == config -> arg_ctrl_cnt ) config -> arg_ctrl_cnt ++ ; } } } if ( ! match ) argj ++ ; } }  return eos_mark_found ;  }","# if CONFIG_VP9_HIGHBITDEPTH int test_16bit_internal = 0 ;# endif # if CONFIG_VP10_ENCODER }else if ( strcmp ( global -> codec -> name , ""vp10"" ) == 0 ) {ctrl_args = vp10_args ;ctrl_args_map = vp10_arg_ctrl_map ;# endif if ( 0 ) {# if CONFIG_VP8_ENCODER }",155
214,"buggy line: # endif  }for ( argi = argj = argv ;cwe id:CWE-119context: static int parse_stream_params ( struct VpxEncoderConfig * global , struct stream_state * stream , char * * argv ) { char * * argi , * * argj ; struct arg arg ; static const arg_def_t * * ctrl_args = no_args ; static const int * ctrl_args_map = NULL ; struct stream_config * config = & stream -> config ; int eos_mark_found = 0 ;  if ( 0 ) {  # if CONFIG_VP8_ENCODER } else if ( strcmp ( global -> codec -> name , ""vp8"" ) == 0 ) { ctrl_args = vp8_args ; ctrl_args_map = vp8_arg_ctrl_map ; # endif # if CONFIG_VP9_ENCODER } else if ( strcmp ( global -> codec -> name , ""vp9"" ) == 0 ) { ctrl_args = vp9_args ; ctrl_args_map = vp9_arg_ctrl_map ; # endif  }  for ( argi = argj = argv ; ( * argj = * argi ) ; argi += arg . argv_step ) { arg . argv_step = 1 ; if ( eos_mark_found ) { argj ++ ; continue ; } else if ( ! strcmp ( * argj , ""--"" ) ) { eos_mark_found = 1 ; continue ; }  if ( 0 ) {  } else if ( arg_match ( & arg , & outputfile , argi ) ) { config -> out_fn = arg . val ; } else if ( arg_match ( & arg , & fpf_name , argi ) ) { config -> stats_fn = arg . val ; } else if ( arg_match ( & arg , & use_ivf , argi ) ) { config -> write_webm = 0 ; } else if ( arg_match ( & arg , & threads , argi ) ) { config -> cfg . g_threads = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & profile , argi ) ) { config -> cfg . g_profile = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & width , argi ) ) { config -> cfg . g_w = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & height , argi ) ) { config -> cfg . g_h = arg_parse_uint ( & arg ) ;  } else if ( arg_match ( & arg , & stereo_mode , argi ) ) {   config -> stereo_fmt = arg_parse_enum_or_int ( & arg ) ;  } else if ( arg_match ( & arg , & timebase , argi ) ) { config -> cfg . g_timebase = arg_parse_rational ( & arg ) ; validate_positive_rational ( arg . name , & config -> cfg . g_timebase ) ; } else if ( arg_match ( & arg , & error_resilient , argi ) ) { config -> cfg . g_error_resilient = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & lag_in_frames , argi ) ) { config -> cfg . g_lag_in_frames = arg_parse_uint ( & arg ) ; if ( global -> deadline == VPX_DL_REALTIME && config -> cfg . g_lag_in_frames != 0 ) { warn ( ""non-zero<S2SV_blank>%s<S2SV_blank>option<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>realtime<S2SV_blank>mode.\\n"" , arg . name ) ; config -> cfg . g_lag_in_frames = 0 ; } } else if ( arg_match ( & arg , & dropframe_thresh , argi ) ) { config -> cfg . rc_dropframe_thresh = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & resize_allowed , argi ) ) { config -> cfg . rc_resize_allowed = arg_parse_uint ( & arg ) ;  } else if ( arg_match ( & arg , & resize_up_thresh , argi ) ) {  config -> cfg . rc_resize_up_thresh = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & resize_down_thresh , argi ) ) { config -> cfg . rc_resize_down_thresh = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & end_usage , argi ) ) { config -> cfg . rc_end_usage = arg_parse_enum_or_int ( & arg ) ; } else if ( arg_match ( & arg , & target_bitrate , argi ) ) { config -> cfg . rc_target_bitrate = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & min_quantizer , argi ) ) { config -> cfg . rc_min_quantizer = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & max_quantizer , argi ) ) { config -> cfg . rc_max_quantizer = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & undershoot_pct , argi ) ) { config -> cfg . rc_undershoot_pct = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & overshoot_pct , argi ) ) { config -> cfg . rc_overshoot_pct = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & buf_sz , argi ) ) { config -> cfg . rc_buf_sz = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & buf_initial_sz , argi ) ) { config -> cfg . rc_buf_initial_sz = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & buf_optimal_sz , argi ) ) { config -> cfg . rc_buf_optimal_sz = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & bias_pct , argi ) ) { config -> cfg . rc_2pass_vbr_bias_pct = arg_parse_uint ( & arg ) ; if ( global -> passes < 2 ) warn ( ""option<S2SV_blank>%s<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>one-pass<S2SV_blank>mode.\\n"" , arg . name ) ; } else if ( arg_match ( & arg , & minsection_pct , argi ) ) { config -> cfg . rc_2pass_vbr_minsection_pct = arg_parse_uint ( & arg ) ; if ( global -> passes < 2 ) warn ( ""option<S2SV_blank>%s<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>one-pass<S2SV_blank>mode.\\n"" , arg . name ) ; } else if ( arg_match ( & arg , & maxsection_pct , argi ) ) { config -> cfg . rc_2pass_vbr_maxsection_pct = arg_parse_uint ( & arg ) ; if ( global -> passes < 2 ) warn ( ""option<S2SV_blank>%s<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>one-pass<S2SV_blank>mode.\\n"" , arg . name ) ; } else if ( arg_match ( & arg , & kf_min_dist , argi ) ) { config -> cfg . kf_min_dist = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & kf_max_dist , argi ) ) { config -> cfg . kf_max_dist = arg_parse_uint ( & arg ) ; config -> have_kf_max_dist = 1 ; } else if ( arg_match ( & arg , & kf_disabled , argi ) ) {  config -> cfg . kf_mode = VPX_KF_DISABLED ;  } else { int i , match = 0 ; for ( i = 0 ; ctrl_args [ i ] ; i ++ ) { if ( arg_match ( & arg , ctrl_args [ i ] , argi ) ) { int j ; match = 1 ; for ( j = 0 ; j < config -> arg_ctrl_cnt ; j ++ )  if ( config -> arg_ctrls [ j ] [ 0 ] == ctrl_args_map [ i ] )  break ;  assert ( j < ARG_CTRL_CNT_MAX ) ;   if ( j < ARG_CTRL_CNT_MAX ) {  config -> arg_ctrls [ j ] [ 0 ] = ctrl_args_map [ i ] ; config -> arg_ctrls [ j ] [ 1 ] = arg_parse_enum_or_int ( & arg ) ; if ( j == config -> arg_ctrl_cnt ) config -> arg_ctrl_cnt ++ ; } } } if ( ! match ) argj ++ ; } }  return eos_mark_found ;  }",# endif }for ( argi = argj = argv ;,155
215,"buggy line: if ( 0 ) {}else if ( arg_match ( & arg , & outputfile , argi ) ) {}cwe id:CWE-119context: static int parse_stream_params ( struct VpxEncoderConfig * global , struct stream_state * stream , char * * argv ) { char * * argi , * * argj ; struct arg arg ; static const arg_def_t * * ctrl_args = no_args ; static const int * ctrl_args_map = NULL ; struct stream_config * config = & stream -> config ; int eos_mark_found = 0 ;  if ( 0 ) {  # if CONFIG_VP8_ENCODER } else if ( strcmp ( global -> codec -> name , ""vp8"" ) == 0 ) { ctrl_args = vp8_args ; ctrl_args_map = vp8_arg_ctrl_map ; # endif # if CONFIG_VP9_ENCODER } else if ( strcmp ( global -> codec -> name , ""vp9"" ) == 0 ) { ctrl_args = vp9_args ; ctrl_args_map = vp9_arg_ctrl_map ; # endif  }  for ( argi = argj = argv ; ( * argj = * argi ) ; argi += arg . argv_step ) { arg . argv_step = 1 ; if ( eos_mark_found ) { argj ++ ; continue ; } else if ( ! strcmp ( * argj , ""--"" ) ) { eos_mark_found = 1 ; continue ; }  if ( 0 ) {  } else if ( arg_match ( & arg , & outputfile , argi ) ) { config -> out_fn = arg . val ; } else if ( arg_match ( & arg , & fpf_name , argi ) ) { config -> stats_fn = arg . val ; } else if ( arg_match ( & arg , & use_ivf , argi ) ) { config -> write_webm = 0 ; } else if ( arg_match ( & arg , & threads , argi ) ) { config -> cfg . g_threads = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & profile , argi ) ) { config -> cfg . g_profile = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & width , argi ) ) { config -> cfg . g_w = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & height , argi ) ) { config -> cfg . g_h = arg_parse_uint ( & arg ) ;  } else if ( arg_match ( & arg , & stereo_mode , argi ) ) {   config -> stereo_fmt = arg_parse_enum_or_int ( & arg ) ;  } else if ( arg_match ( & arg , & timebase , argi ) ) { config -> cfg . g_timebase = arg_parse_rational ( & arg ) ; validate_positive_rational ( arg . name , & config -> cfg . g_timebase ) ; } else if ( arg_match ( & arg , & error_resilient , argi ) ) { config -> cfg . g_error_resilient = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & lag_in_frames , argi ) ) { config -> cfg . g_lag_in_frames = arg_parse_uint ( & arg ) ; if ( global -> deadline == VPX_DL_REALTIME && config -> cfg . g_lag_in_frames != 0 ) { warn ( ""non-zero<S2SV_blank>%s<S2SV_blank>option<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>realtime<S2SV_blank>mode.\\n"" , arg . name ) ; config -> cfg . g_lag_in_frames = 0 ; } } else if ( arg_match ( & arg , & dropframe_thresh , argi ) ) { config -> cfg . rc_dropframe_thresh = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & resize_allowed , argi ) ) { config -> cfg . rc_resize_allowed = arg_parse_uint ( & arg ) ;  } else if ( arg_match ( & arg , & resize_up_thresh , argi ) ) {  config -> cfg . rc_resize_up_thresh = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & resize_down_thresh , argi ) ) { config -> cfg . rc_resize_down_thresh = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & end_usage , argi ) ) { config -> cfg . rc_end_usage = arg_parse_enum_or_int ( & arg ) ; } else if ( arg_match ( & arg , & target_bitrate , argi ) ) { config -> cfg . rc_target_bitrate = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & min_quantizer , argi ) ) { config -> cfg . rc_min_quantizer = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & max_quantizer , argi ) ) { config -> cfg . rc_max_quantizer = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & undershoot_pct , argi ) ) { config -> cfg . rc_undershoot_pct = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & overshoot_pct , argi ) ) { config -> cfg . rc_overshoot_pct = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & buf_sz , argi ) ) { config -> cfg . rc_buf_sz = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & buf_initial_sz , argi ) ) { config -> cfg . rc_buf_initial_sz = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & buf_optimal_sz , argi ) ) { config -> cfg . rc_buf_optimal_sz = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & bias_pct , argi ) ) { config -> cfg . rc_2pass_vbr_bias_pct = arg_parse_uint ( & arg ) ; if ( global -> passes < 2 ) warn ( ""option<S2SV_blank>%s<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>one-pass<S2SV_blank>mode.\\n"" , arg . name ) ; } else if ( arg_match ( & arg , & minsection_pct , argi ) ) { config -> cfg . rc_2pass_vbr_minsection_pct = arg_parse_uint ( & arg ) ; if ( global -> passes < 2 ) warn ( ""option<S2SV_blank>%s<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>one-pass<S2SV_blank>mode.\\n"" , arg . name ) ; } else if ( arg_match ( & arg , & maxsection_pct , argi ) ) { config -> cfg . rc_2pass_vbr_maxsection_pct = arg_parse_uint ( & arg ) ; if ( global -> passes < 2 ) warn ( ""option<S2SV_blank>%s<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>one-pass<S2SV_blank>mode.\\n"" , arg . name ) ; } else if ( arg_match ( & arg , & kf_min_dist , argi ) ) { config -> cfg . kf_min_dist = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & kf_max_dist , argi ) ) { config -> cfg . kf_max_dist = arg_parse_uint ( & arg ) ; config -> have_kf_max_dist = 1 ; } else if ( arg_match ( & arg , & kf_disabled , argi ) ) {  config -> cfg . kf_mode = VPX_KF_DISABLED ;  } else { int i , match = 0 ; for ( i = 0 ; ctrl_args [ i ] ; i ++ ) { if ( arg_match ( & arg , ctrl_args [ i ] , argi ) ) { int j ; match = 1 ; for ( j = 0 ; j < config -> arg_ctrl_cnt ; j ++ )  if ( config -> arg_ctrls [ j ] [ 0 ] == ctrl_args_map [ i ] )  break ;  assert ( j < ARG_CTRL_CNT_MAX ) ;   if ( j < ARG_CTRL_CNT_MAX ) {  config -> arg_ctrls [ j ] [ 0 ] = ctrl_args_map [ i ] ; config -> arg_ctrls [ j ] [ 1 ] = arg_parse_enum_or_int ( & arg ) ; if ( j == config -> arg_ctrl_cnt ) config -> arg_ctrl_cnt ++ ; } } } if ( ! match ) argj ++ ; } }  return eos_mark_found ;  }","if ( arg_match ( & arg , & outputfile , argi ) ) {# if CONFIG_FP_MB_STATS }else if ( arg_match ( & arg , & fpmbf_name , argi ) ) {config -> fpmb_stats_fn = arg . val ;# endif }else if ( arg_match ( & arg , & use_webm , argi ) ) {# if CONFIG_WEBM_IO config -> write_webm = 1 ;# else die ( ""Error:<S2SV_blank>--webm<S2SV_blank>specified<S2SV_blank>but<S2SV_blank>webm<S2SV_blank>is<S2SV_blank>disabled."" ) ;# endif }else if ( arg_match ( & arg , & use_ivf , argi ) ) {config -> write_webm = 0 ;}else if ( arg_match ( & arg , & fpf_name , argi ) ) {config -> stats_fn = arg . val ;# if CONFIG_VP9_HIGHBITDEPTH }else if ( arg_match ( & arg , & bitdeptharg , argi ) ) {config -> cfg . g_bit_depth = arg_parse_enum_or_int ( & arg ) ;# endif }else if ( arg_match ( & arg , & resize_width , argi ) ) {config -> cfg . rc_scaled_width = arg_parse_uint ( & arg ) ;}else if ( arg_match ( & arg , & resize_height , argi ) ) {config -> cfg . rc_scaled_height = arg_parse_uint ( & arg ) ;}else if ( arg_match ( & arg , & inbitdeptharg , argi ) ) {config -> cfg . g_input_bit_depth = arg_parse_uint ( & arg ) ;# endif # if CONFIG_WEBM_IO }",155
216,"buggy line: }config -> stereo_fmt = arg_parse_enum_or_int ( & arg ) ;}cwe id:CWE-119context: static int parse_stream_params ( struct VpxEncoderConfig * global , struct stream_state * stream , char * * argv ) { char * * argi , * * argj ; struct arg arg ; static const arg_def_t * * ctrl_args = no_args ; static const int * ctrl_args_map = NULL ; struct stream_config * config = & stream -> config ; int eos_mark_found = 0 ;  if ( 0 ) {  # if CONFIG_VP8_ENCODER } else if ( strcmp ( global -> codec -> name , ""vp8"" ) == 0 ) { ctrl_args = vp8_args ; ctrl_args_map = vp8_arg_ctrl_map ; # endif # if CONFIG_VP9_ENCODER } else if ( strcmp ( global -> codec -> name , ""vp9"" ) == 0 ) { ctrl_args = vp9_args ; ctrl_args_map = vp9_arg_ctrl_map ; # endif  }  for ( argi = argj = argv ; ( * argj = * argi ) ; argi += arg . argv_step ) { arg . argv_step = 1 ; if ( eos_mark_found ) { argj ++ ; continue ; } else if ( ! strcmp ( * argj , ""--"" ) ) { eos_mark_found = 1 ; continue ; }  if ( 0 ) {  } else if ( arg_match ( & arg , & outputfile , argi ) ) { config -> out_fn = arg . val ; } else if ( arg_match ( & arg , & fpf_name , argi ) ) { config -> stats_fn = arg . val ; } else if ( arg_match ( & arg , & use_ivf , argi ) ) { config -> write_webm = 0 ; } else if ( arg_match ( & arg , & threads , argi ) ) { config -> cfg . g_threads = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & profile , argi ) ) { config -> cfg . g_profile = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & width , argi ) ) { config -> cfg . g_w = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & height , argi ) ) { config -> cfg . g_h = arg_parse_uint ( & arg ) ;  } else if ( arg_match ( & arg , & stereo_mode , argi ) ) {   config -> stereo_fmt = arg_parse_enum_or_int ( & arg ) ;  } else if ( arg_match ( & arg , & timebase , argi ) ) { config -> cfg . g_timebase = arg_parse_rational ( & arg ) ; validate_positive_rational ( arg . name , & config -> cfg . g_timebase ) ; } else if ( arg_match ( & arg , & error_resilient , argi ) ) { config -> cfg . g_error_resilient = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & lag_in_frames , argi ) ) { config -> cfg . g_lag_in_frames = arg_parse_uint ( & arg ) ; if ( global -> deadline == VPX_DL_REALTIME && config -> cfg . g_lag_in_frames != 0 ) { warn ( ""non-zero<S2SV_blank>%s<S2SV_blank>option<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>realtime<S2SV_blank>mode.\\n"" , arg . name ) ; config -> cfg . g_lag_in_frames = 0 ; } } else if ( arg_match ( & arg , & dropframe_thresh , argi ) ) { config -> cfg . rc_dropframe_thresh = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & resize_allowed , argi ) ) { config -> cfg . rc_resize_allowed = arg_parse_uint ( & arg ) ;  } else if ( arg_match ( & arg , & resize_up_thresh , argi ) ) {  config -> cfg . rc_resize_up_thresh = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & resize_down_thresh , argi ) ) { config -> cfg . rc_resize_down_thresh = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & end_usage , argi ) ) { config -> cfg . rc_end_usage = arg_parse_enum_or_int ( & arg ) ; } else if ( arg_match ( & arg , & target_bitrate , argi ) ) { config -> cfg . rc_target_bitrate = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & min_quantizer , argi ) ) { config -> cfg . rc_min_quantizer = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & max_quantizer , argi ) ) { config -> cfg . rc_max_quantizer = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & undershoot_pct , argi ) ) { config -> cfg . rc_undershoot_pct = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & overshoot_pct , argi ) ) { config -> cfg . rc_overshoot_pct = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & buf_sz , argi ) ) { config -> cfg . rc_buf_sz = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & buf_initial_sz , argi ) ) { config -> cfg . rc_buf_initial_sz = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & buf_optimal_sz , argi ) ) { config -> cfg . rc_buf_optimal_sz = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & bias_pct , argi ) ) { config -> cfg . rc_2pass_vbr_bias_pct = arg_parse_uint ( & arg ) ; if ( global -> passes < 2 ) warn ( ""option<S2SV_blank>%s<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>one-pass<S2SV_blank>mode.\\n"" , arg . name ) ; } else if ( arg_match ( & arg , & minsection_pct , argi ) ) { config -> cfg . rc_2pass_vbr_minsection_pct = arg_parse_uint ( & arg ) ; if ( global -> passes < 2 ) warn ( ""option<S2SV_blank>%s<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>one-pass<S2SV_blank>mode.\\n"" , arg . name ) ; } else if ( arg_match ( & arg , & maxsection_pct , argi ) ) { config -> cfg . rc_2pass_vbr_maxsection_pct = arg_parse_uint ( & arg ) ; if ( global -> passes < 2 ) warn ( ""option<S2SV_blank>%s<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>one-pass<S2SV_blank>mode.\\n"" , arg . name ) ; } else if ( arg_match ( & arg , & kf_min_dist , argi ) ) { config -> cfg . kf_min_dist = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & kf_max_dist , argi ) ) { config -> cfg . kf_max_dist = arg_parse_uint ( & arg ) ; config -> have_kf_max_dist = 1 ; } else if ( arg_match ( & arg , & kf_disabled , argi ) ) {  config -> cfg . kf_mode = VPX_KF_DISABLED ;  } else { int i , match = 0 ; for ( i = 0 ; ctrl_args [ i ] ; i ++ ) { if ( arg_match ( & arg , ctrl_args [ i ] , argi ) ) { int j ; match = 1 ; for ( j = 0 ; j < config -> arg_ctrl_cnt ; j ++ )  if ( config -> arg_ctrls [ j ] [ 0 ] == ctrl_args_map [ i ] )  break ;  assert ( j < ARG_CTRL_CNT_MAX ) ;   if ( j < ARG_CTRL_CNT_MAX ) {  config -> arg_ctrls [ j ] [ 0 ] = ctrl_args_map [ i ] ; config -> arg_ctrls [ j ] [ 1 ] = arg_parse_enum_or_int ( & arg ) ; if ( j == config -> arg_ctrl_cnt ) config -> arg_ctrl_cnt ++ ; } } } if ( ! match ) argj ++ ; } }  return eos_mark_found ;  }",}config -> stereo_fmt = arg_parse_enum_or_int ( & arg ) ;},155
217,"buggy line: if ( global -> deadline == VPX_DL_REALTIME && config -> cfg . g_lag_in_frames != 0 ) {warn ( ""non-zero<S2SV_blank>%s<S2SV_blank>option<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>realtime<S2SV_blank>mode.\\\config -> cfg . g_lag_in_frames = 0 ;}}else if ( arg_match ( & arg , & dropframe_thresh , argi ) ) {config -> cfg . rc_dropframe_thresh = arg_parse_uint ( & arg ) ;}else if ( arg_match ( & arg , & resize_allowed , argi ) ) {config -> cfg . rc_resize_allowed = arg_parse_uint ( & arg ) ;}else if ( arg_match ( & arg , & resize_up_thresh , argi ) ) {config -> cfg . rc_resize_up_thresh = arg_parse_uint ( & arg ) ;}else if ( arg_match ( & arg , & resize_down_thresh , argi ) ) {config -> cfg . rc_resize_down_thresh = arg_parse_uint ( & arg ) ;}else if ( arg_match ( & arg , & end_usage , argi ) ) {config -> cfg . rc_end_usage = arg_parse_enum_or_int ( & arg ) ;}else if ( arg_match ( & arg , & target_bitrate , argi ) ) {config -> cfg . rc_target_bitrate = arg_parse_uint ( & arg ) ;}else if ( arg_match ( & arg , & min_quantizer , argi ) ) {config -> cfg . rc_min_quantizer = arg_parse_uint ( & arg ) ;}else if ( arg_match ( & arg , & max_quantizer , argi ) ) {config -> cfg . rc_max_quantizer = arg_parse_uint ( & arg ) ;}else if ( arg_match ( & arg , & undershoot_pct , argi ) ) {config -> cfg . rc_undershoot_pct = arg_parse_uint ( & arg ) ;}else if ( arg_match ( & arg , & overshoot_pct , argi ) ) {config -> cfg . rc_overshoot_pct = arg_parse_uint ( & arg ) ;}else if ( arg_match ( & arg , & buf_sz , argi ) ) {config -> cfg . rc_buf_sz = arg_parse_uint ( & arg ) ;}else if ( arg_match ( & arg , & buf_initial_sz , argi ) ) {config -> cfg . rc_buf_initial_sz = arg_parse_uint ( & arg ) ;}else if ( arg_match ( & arg , & buf_optimal_sz , argi ) ) {config -> cfg . rc_buf_optimal_sz = arg_parse_uint ( & arg ) ;}else if ( arg_match ( & arg , & bias_pct , argi ) ) {config -> cfg . rc_2pass_vbr_bias_pct = arg_parse_uint ( & arg ) ;if ( global -> passes < 2 ) warn ( ""option<S2SV_blank>%s<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>one-pass<S2SV_blank>mode.\\\}else if ( arg_match ( & arg , & minsection_pct , argi ) ) {config -> cfg . rc_2pass_vbr_minsection_pct = arg_parse_uint ( & arg ) ;if ( global -> passes < 2 ) warn ( ""option<S2SV_blank>%s<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>one-pass<S2SV_blank>mode.\\\}else if ( arg_match ( & arg , & maxsection_pct , argi ) ) {config -> cfg . rc_2pass_vbr_maxsection_pct = arg_parse_uint ( & arg ) ;if ( global -> passes < 2 ) warn ( ""option<S2SV_blank>%s<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>one-pass<S2SV_blank>mode.\\\}else if ( arg_match ( & arg , & kf_min_dist , argi ) ) {config -> cfg . kf_min_dist = arg_parse_uint ( & arg ) ;}else if ( arg_match ( & arg , & kf_max_dist , argi ) ) {config -> cfg . kf_max_dist = arg_parse_uint ( & arg ) ;config -> have_kf_max_dist = 1 ;}else if ( arg_match ( & arg , & kf_disabled , argi ) ) {config -> cfg . kf_mode = VPX_KF_DISABLED ;}else {int i , match = 0 ;for ( i = 0 ;ctrl_args [ i ] ;i ++ ) {if ( arg_match ( & arg , ctrl_args [ i ] , argi ) ) {int j ;match = 1 ;for ( j = 0 ;j < config -> arg_ctrl_cnt ;j ++ )  if ( config -> arg_ctrls [ j ] [ 0 ] == ctrl_args_map [ i ] )  break ;assert ( j < ARG_CTRL_CNT_MAX ) ;if ( j < ARG_CTRL_CNT_MAX ) {config -> arg_ctrls [ j ] [ 0 ] = ctrl_args_map [ i ] ;return eos_mark_found ;}cwe id:CWE-119context: static int parse_stream_params ( struct VpxEncoderConfig * global , struct stream_state * stream , char * * argv ) { char * * argi , * * argj ; struct arg arg ; static const arg_def_t * * ctrl_args = no_args ; static const int * ctrl_args_map = NULL ; struct stream_config * config = & stream -> config ; int eos_mark_found = 0 ;  if ( 0 ) {  # if CONFIG_VP8_ENCODER } else if ( strcmp ( global -> codec -> name , ""vp8"" ) == 0 ) { ctrl_args = vp8_args ; ctrl_args_map = vp8_arg_ctrl_map ; # endif # if CONFIG_VP9_ENCODER } else if ( strcmp ( global -> codec -> name , ""vp9"" ) == 0 ) { ctrl_args = vp9_args ; ctrl_args_map = vp9_arg_ctrl_map ; # endif  }  for ( argi = argj = argv ; ( * argj = * argi ) ; argi += arg . argv_step ) { arg . argv_step = 1 ; if ( eos_mark_found ) { argj ++ ; continue ; } else if ( ! strcmp ( * argj , ""--"" ) ) { eos_mark_found = 1 ; continue ; }  if ( 0 ) {  } else if ( arg_match ( & arg , & outputfile , argi ) ) { config -> out_fn = arg . val ; } else if ( arg_match ( & arg , & fpf_name , argi ) ) { config -> stats_fn = arg . val ; } else if ( arg_match ( & arg , & use_ivf , argi ) ) { config -> write_webm = 0 ; } else if ( arg_match ( & arg , & threads , argi ) ) { config -> cfg . g_threads = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & profile , argi ) ) { config -> cfg . g_profile = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & width , argi ) ) { config -> cfg . g_w = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & height , argi ) ) { config -> cfg . g_h = arg_parse_uint ( & arg ) ;  } else if ( arg_match ( & arg , & stereo_mode , argi ) ) {   config -> stereo_fmt = arg_parse_enum_or_int ( & arg ) ;  } else if ( arg_match ( & arg , & timebase , argi ) ) { config -> cfg . g_timebase = arg_parse_rational ( & arg ) ; validate_positive_rational ( arg . name , & config -> cfg . g_timebase ) ; } else if ( arg_match ( & arg , & error_resilient , argi ) ) { config -> cfg . g_error_resilient = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & lag_in_frames , argi ) ) { config -> cfg . g_lag_in_frames = arg_parse_uint ( & arg ) ; if ( global -> deadline == VPX_DL_REALTIME && config -> cfg . g_lag_in_frames != 0 ) { warn ( ""non-zero<S2SV_blank>%s<S2SV_blank>option<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>realtime<S2SV_blank>mode.\\n"" , arg . name ) ; config -> cfg . g_lag_in_frames = 0 ; } } else if ( arg_match ( & arg , & dropframe_thresh , argi ) ) { config -> cfg . rc_dropframe_thresh = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & resize_allowed , argi ) ) { config -> cfg . rc_resize_allowed = arg_parse_uint ( & arg ) ;  } else if ( arg_match ( & arg , & resize_up_thresh , argi ) ) {  config -> cfg . rc_resize_up_thresh = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & resize_down_thresh , argi ) ) { config -> cfg . rc_resize_down_thresh = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & end_usage , argi ) ) { config -> cfg . rc_end_usage = arg_parse_enum_or_int ( & arg ) ; } else if ( arg_match ( & arg , & target_bitrate , argi ) ) { config -> cfg . rc_target_bitrate = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & min_quantizer , argi ) ) { config -> cfg . rc_min_quantizer = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & max_quantizer , argi ) ) { config -> cfg . rc_max_quantizer = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & undershoot_pct , argi ) ) { config -> cfg . rc_undershoot_pct = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & overshoot_pct , argi ) ) { config -> cfg . rc_overshoot_pct = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & buf_sz , argi ) ) { config -> cfg . rc_buf_sz = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & buf_initial_sz , argi ) ) { config -> cfg . rc_buf_initial_sz = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & buf_optimal_sz , argi ) ) { config -> cfg . rc_buf_optimal_sz = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & bias_pct , argi ) ) { config -> cfg . rc_2pass_vbr_bias_pct = arg_parse_uint ( & arg ) ; if ( global -> passes < 2 ) warn ( ""option<S2SV_blank>%s<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>one-pass<S2SV_blank>mode.\\n"" , arg . name ) ; } else if ( arg_match ( & arg , & minsection_pct , argi ) ) { config -> cfg . rc_2pass_vbr_minsection_pct = arg_parse_uint ( & arg ) ; if ( global -> passes < 2 ) warn ( ""option<S2SV_blank>%s<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>one-pass<S2SV_blank>mode.\\n"" , arg . name ) ; } else if ( arg_match ( & arg , & maxsection_pct , argi ) ) { config -> cfg . rc_2pass_vbr_maxsection_pct = arg_parse_uint ( & arg ) ; if ( global -> passes < 2 ) warn ( ""option<S2SV_blank>%s<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>one-pass<S2SV_blank>mode.\\n"" , arg . name ) ; } else if ( arg_match ( & arg , & kf_min_dist , argi ) ) { config -> cfg . kf_min_dist = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & kf_max_dist , argi ) ) { config -> cfg . kf_max_dist = arg_parse_uint ( & arg ) ; config -> have_kf_max_dist = 1 ; } else if ( arg_match ( & arg , & kf_disabled , argi ) ) {  config -> cfg . kf_mode = VPX_KF_DISABLED ;  } else { int i , match = 0 ; for ( i = 0 ; ctrl_args [ i ] ; i ++ ) { if ( arg_match ( & arg , ctrl_args [ i ] , argi ) ) { int j ; match = 1 ; for ( j = 0 ; j < config -> arg_ctrl_cnt ; j ++ )  if ( config -> arg_ctrls [ j ] [ 0 ] == ctrl_args_map [ i ] )  break ;  assert ( j < ARG_CTRL_CNT_MAX ) ;   if ( j < ARG_CTRL_CNT_MAX ) {  config -> arg_ctrls [ j ] [ 0 ] = ctrl_args_map [ i ] ; config -> arg_ctrls [ j ] [ 1 ] = arg_parse_enum_or_int ( & arg ) ; if ( j == config -> arg_ctrl_cnt ) config -> arg_ctrl_cnt ++ ; } } } if ( ! match ) argj ++ ; } }  return eos_mark_found ;  }","if ( ctrl_args_map != NULL && j < ( int ) ARG_CTRL_CNT_MAX ) {config -> arg_ctrls [ j ] [ 0 ] = ctrl_args_map [ i ] ;# if CONFIG_VP9_HIGHBITDEPTH if ( strcmp ( global -> codec -> name , ""vp9"" ) == 0 || strcmp ( global -> codec -> name , ""vp10"" ) == 0 ) {config -> use_16bit_internal = test_16bit_internal | ( config -> cfg . g_profile > 1 ) ;# endif }return eos_mark_found ;}",155
218,"buggy line: if ( ( options . allow_tcp_forwarding & FORWARD_REMOTE ) == 0 || no_port_forwarding_flag || options . disable_forwarding || ( ! want_reply && fwd . listen_port == 0 ) || ( fwd . listen_port != 0 && ! bind_permitted ( fwd . listen_port , pw -> pw_uid ) ) ) {cwe id:CWE-264context: static int server_input_global_request ( int type , u_int32_t seq , void * ctxt ) { char * rtype ; int want_reply ; int r , success = 0 , allocated_listen_port = 0 ; struct sshbuf * resp = NULL ; rtype = packet_get_string ( NULL ) ; want_reply = packet_get_char ( ) ; debug ( ""server_input_global_request:<S2SV_blank>rtype<S2SV_blank>%s<S2SV_blank>want_reply<S2SV_blank>%d"" , rtype , want_reply ) ; if ( strcmp ( rtype , ""tcpip-forward"" ) == 0 ) { struct passwd * pw ; struct Forward fwd ; pw = the_authctxt -> pw ; if ( pw == NULL || ! the_authctxt -> valid ) fatal ( ""server_input_global_request:<S2SV_blank>no/invalid<S2SV_blank>user"" ) ; memset ( & fwd , 0 , sizeof ( fwd ) ) ; fwd . listen_host = packet_get_string ( NULL ) ; fwd . listen_port = ( u_short ) packet_get_int ( ) ; debug ( ""server_input_global_request:<S2SV_blank>tcpip-forward<S2SV_blank>listen<S2SV_blank>%s<S2SV_blank>port<S2SV_blank>%d"" , fwd . listen_host , fwd . listen_port ) ; if ( ( options . allow_tcp_forwarding & FORWARD_REMOTE ) == 0 || no_port_forwarding_flag || options . disable_forwarding || ( ! want_reply && fwd . listen_port == 0 ) || ( fwd . listen_port != 0 && ! bind_permitted ( fwd . listen_port , pw -> pw_uid ) ) ) { success = 0 ; packet_send_debug ( ""Server<S2SV_blank>has<S2SV_blank>disabled<S2SV_blank>port<S2SV_blank>forwarding."" ) ; } else { success = channel_setup_remote_fwd_listener ( & fwd , & allocated_listen_port , & options . fwd_opts ) ; } free ( fwd . listen_host ) ; if ( ( resp = sshbuf_new ( ) ) == NULL ) fatal ( ""%s:<S2SV_blank>sshbuf_new"" , __func__ ) ; if ( allocated_listen_port != 0 && ( r = sshbuf_put_u32 ( resp , allocated_listen_port ) ) != 0 ) fatal ( ""%s:<S2SV_blank>sshbuf_put_u32:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; } else if ( strcmp ( rtype , ""cancel-tcpip-forward"" ) == 0 ) { struct Forward fwd ; memset ( & fwd , 0 , sizeof ( fwd ) ) ; fwd . listen_host = packet_get_string ( NULL ) ; fwd . listen_port = ( u_short ) packet_get_int ( ) ; debug ( ""%s:<S2SV_blank>cancel-tcpip-forward<S2SV_blank>addr<S2SV_blank>%s<S2SV_blank>port<S2SV_blank>%d"" , __func__ , fwd . listen_host , fwd . listen_port ) ; success = channel_cancel_rport_listener ( & fwd ) ; free ( fwd . listen_host ) ; } else if ( strcmp ( rtype , ""streamlocal-forward@openssh.com"" ) == 0 ) { struct Forward fwd ; memset ( & fwd , 0 , sizeof ( fwd ) ) ; fwd . listen_path = packet_get_string ( NULL ) ; debug ( ""server_input_global_request:<S2SV_blank>streamlocal-forward<S2SV_blank>listen<S2SV_blank>path<S2SV_blank>%s"" , fwd . listen_path ) ; if ( ( options . allow_streamlocal_forwarding & FORWARD_REMOTE ) == 0  || no_port_forwarding_flag || options . disable_forwarding ) {  success = 0 ; packet_send_debug ( ""Server<S2SV_blank>has<S2SV_blank>disabled<S2SV_blank>port<S2SV_blank>forwarding."" ) ; } else { success = channel_setup_remote_fwd_listener ( & fwd , NULL , & options . fwd_opts ) ; } free ( fwd . listen_path ) ; } else if ( strcmp ( rtype , ""cancel-streamlocal-forward@openssh.com"" ) == 0 ) { struct Forward fwd ; memset ( & fwd , 0 , sizeof ( fwd ) ) ; fwd . listen_path = packet_get_string ( NULL ) ; debug ( ""%s:<S2SV_blank>cancel-streamlocal-forward<S2SV_blank>path<S2SV_blank>%s"" , __func__ , fwd . listen_path ) ; success = channel_cancel_rport_listener ( & fwd ) ; free ( fwd . listen_path ) ; } else if ( strcmp ( rtype , ""no-more-sessions@openssh.com"" ) == 0 ) { no_more_sessions = 1 ; success = 1 ; } else if ( strcmp ( rtype , ""hostkeys-prove-00@openssh.com"" ) == 0 ) { success = server_input_hostkeys_prove ( & resp ) ; } if ( want_reply ) { packet_start ( success ? SSH2_MSG_REQUEST_SUCCESS : SSH2_MSG_REQUEST_FAILURE ) ; if ( success && resp != NULL ) ssh_packet_put_raw ( active_state , sshbuf_ptr ( resp ) , sshbuf_len ( resp ) ) ; packet_send ( ) ; packet_write_wait ( ) ; } free ( rtype ) ; sshbuf_free ( resp ) ; return 0 ; }","if ( ( options . allow_tcp_forwarding & FORWARD_REMOTE ) == 0 || no_port_forwarding_flag || options . disable_forwarding || ! use_privsep || ( ! want_reply && fwd . listen_port == 0 ) || ( fwd . listen_port != 0 && ! bind_permitted ( fwd . listen_port , pw -> pw_uid ) ) ) {",156
219,"buggy line: if ( ( options . allow_streamlocal_forwarding & FORWARD_REMOTE ) == 0  || no_port_forwarding_flag || options . disable_forwarding ) {success = 0 ;cwe id:CWE-264context: static int server_input_global_request ( int type , u_int32_t seq , void * ctxt ) { char * rtype ; int want_reply ; int r , success = 0 , allocated_listen_port = 0 ; struct sshbuf * resp = NULL ; rtype = packet_get_string ( NULL ) ; want_reply = packet_get_char ( ) ; debug ( ""server_input_global_request:<S2SV_blank>rtype<S2SV_blank>%s<S2SV_blank>want_reply<S2SV_blank>%d"" , rtype , want_reply ) ; if ( strcmp ( rtype , ""tcpip-forward"" ) == 0 ) { struct passwd * pw ; struct Forward fwd ; pw = the_authctxt -> pw ; if ( pw == NULL || ! the_authctxt -> valid ) fatal ( ""server_input_global_request:<S2SV_blank>no/invalid<S2SV_blank>user"" ) ; memset ( & fwd , 0 , sizeof ( fwd ) ) ; fwd . listen_host = packet_get_string ( NULL ) ; fwd . listen_port = ( u_short ) packet_get_int ( ) ; debug ( ""server_input_global_request:<S2SV_blank>tcpip-forward<S2SV_blank>listen<S2SV_blank>%s<S2SV_blank>port<S2SV_blank>%d"" , fwd . listen_host , fwd . listen_port ) ; if ( ( options . allow_tcp_forwarding & FORWARD_REMOTE ) == 0 || no_port_forwarding_flag || options . disable_forwarding || ( ! want_reply && fwd . listen_port == 0 ) || ( fwd . listen_port != 0 && ! bind_permitted ( fwd . listen_port , pw -> pw_uid ) ) ) { success = 0 ; packet_send_debug ( ""Server<S2SV_blank>has<S2SV_blank>disabled<S2SV_blank>port<S2SV_blank>forwarding."" ) ; } else { success = channel_setup_remote_fwd_listener ( & fwd , & allocated_listen_port , & options . fwd_opts ) ; } free ( fwd . listen_host ) ; if ( ( resp = sshbuf_new ( ) ) == NULL ) fatal ( ""%s:<S2SV_blank>sshbuf_new"" , __func__ ) ; if ( allocated_listen_port != 0 && ( r = sshbuf_put_u32 ( resp , allocated_listen_port ) ) != 0 ) fatal ( ""%s:<S2SV_blank>sshbuf_put_u32:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; } else if ( strcmp ( rtype , ""cancel-tcpip-forward"" ) == 0 ) { struct Forward fwd ; memset ( & fwd , 0 , sizeof ( fwd ) ) ; fwd . listen_host = packet_get_string ( NULL ) ; fwd . listen_port = ( u_short ) packet_get_int ( ) ; debug ( ""%s:<S2SV_blank>cancel-tcpip-forward<S2SV_blank>addr<S2SV_blank>%s<S2SV_blank>port<S2SV_blank>%d"" , __func__ , fwd . listen_host , fwd . listen_port ) ; success = channel_cancel_rport_listener ( & fwd ) ; free ( fwd . listen_host ) ; } else if ( strcmp ( rtype , ""streamlocal-forward@openssh.com"" ) == 0 ) { struct Forward fwd ; memset ( & fwd , 0 , sizeof ( fwd ) ) ; fwd . listen_path = packet_get_string ( NULL ) ; debug ( ""server_input_global_request:<S2SV_blank>streamlocal-forward<S2SV_blank>listen<S2SV_blank>path<S2SV_blank>%s"" , fwd . listen_path ) ; if ( ( options . allow_streamlocal_forwarding & FORWARD_REMOTE ) == 0  || no_port_forwarding_flag || options . disable_forwarding ) {  success = 0 ; packet_send_debug ( ""Server<S2SV_blank>has<S2SV_blank>disabled<S2SV_blank>port<S2SV_blank>forwarding."" ) ; } else { success = channel_setup_remote_fwd_listener ( & fwd , NULL , & options . fwd_opts ) ; } free ( fwd . listen_path ) ; } else if ( strcmp ( rtype , ""cancel-streamlocal-forward@openssh.com"" ) == 0 ) { struct Forward fwd ; memset ( & fwd , 0 , sizeof ( fwd ) ) ; fwd . listen_path = packet_get_string ( NULL ) ; debug ( ""%s:<S2SV_blank>cancel-streamlocal-forward<S2SV_blank>path<S2SV_blank>%s"" , __func__ , fwd . listen_path ) ; success = channel_cancel_rport_listener ( & fwd ) ; free ( fwd . listen_path ) ; } else if ( strcmp ( rtype , ""no-more-sessions@openssh.com"" ) == 0 ) { no_more_sessions = 1 ; success = 1 ; } else if ( strcmp ( rtype , ""hostkeys-prove-00@openssh.com"" ) == 0 ) { success = server_input_hostkeys_prove ( & resp ) ; } if ( want_reply ) { packet_start ( success ? SSH2_MSG_REQUEST_SUCCESS : SSH2_MSG_REQUEST_FAILURE ) ; if ( success && resp != NULL ) ssh_packet_put_raw ( active_state , sshbuf_ptr ( resp ) , sshbuf_len ( resp ) ) ; packet_send ( ) ; packet_write_wait ( ) ; } free ( rtype ) ; sshbuf_free ( resp ) ; return 0 ; }",if ( ( options . allow_streamlocal_forwarding & FORWARD_REMOTE ) == 0 || no_port_forwarding_flag || options . disable_forwarding ) {success = 0 ;,156
220,buggy line: dev -> netdev_ops = & l2tp_eth_netdev_ops ;dev -> destructor = free_netdev ;cwe id:CWE-264context: static void l2tp_eth_dev_setup ( struct net_device * dev ) { ether_setup ( dev ) ;  dev -> netdev_ops = & l2tp_eth_netdev_ops ;  dev -> destructor = free_netdev ; },dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ;dev -> netdev_ops = & l2tp_eth_netdev_ops ;dev -> destructor = free_netdev ;,157
221,"buggy line: cwe id:CWE-400context: static Image * ReadCINImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define MonoColorType 1 # define RGBColorType 3 char property [ MagickPathExtent ] ; CINInfo cin ; const unsigned char * pixels ; Image * image ; MagickBooleanType status ; MagickOffsetType offset ; QuantumInfo * quantum_info ; QuantumType quantum_type ; register ssize_t i ; register Quantum * q ; size_t length ; ssize_t count , y ; unsigned char magick [ 4 ] ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } offset = 0 ; count = ReadBlob ( image , 4 , magick ) ; offset += count ; if ( ( count != 4 ) || ( ( LocaleNCompare ( ( char * ) magick , ""\\200\\052\\137\\327"" , 4 ) != 0 ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; memset ( & cin , 0 , sizeof ( cin ) ) ; image -> endian = ( magick [ 0 ] == 0x80 ) && ( magick [ 1 ] == 0x2a ) && ( magick [ 2 ] == 0x5f ) && ( magick [ 3 ] == 0xd7 ) ? MSBEndian : LSBEndian ; cin . file . image_offset = ReadBlobLong ( image ) ; offset += 4 ; cin . file . generic_length = ReadBlobLong ( image ) ; offset += 4 ; cin . file . industry_length = ReadBlobLong ( image ) ; offset += 4 ; cin . file . user_length = ReadBlobLong ( image ) ; offset += 4 ; cin . file . file_size = ReadBlobLong ( image ) ; offset += 4 ; offset += ReadBlob ( image , sizeof ( cin . file . version ) , ( unsigned char * ) cin . file . version ) ; ( void ) CopyMagickString ( property , cin . file . version , sizeof ( cin . file . version ) ) ; ( void ) SetImageProperty ( image , ""dpx:file.version"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . file . filename ) , ( unsigned char * ) cin . file . filename ) ; ( void ) CopyMagickString ( property , cin . file . filename , sizeof ( cin . file . filename ) ) ; ( void ) SetImageProperty ( image , ""dpx:file.filename"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . file . create_date ) , ( unsigned char * ) cin . file . create_date ) ; ( void ) CopyMagickString ( property , cin . file . create_date , sizeof ( cin . file . create_date ) ) ; ( void ) SetImageProperty ( image , ""dpx:file.create_date"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . file . create_time ) , ( unsigned char * ) cin . file . create_time ) ; ( void ) CopyMagickString ( property , cin . file . create_time , sizeof ( cin . file . create_time ) ) ; ( void ) SetImageProperty ( image , ""dpx:file.create_time"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . file . reserve ) , ( unsigned char * ) cin . file . reserve ) ; cin . image . orientation = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; if ( cin . image . orientation != ( unsigned char ) ( ~ 0 ) ) ( void ) FormatImageProperty ( image , ""dpx:image.orientation"" , ""%d"" , cin . image . orientation ) ; switch ( cin . image . orientation ) { default : case 0 : image -> orientation = TopLeftOrientation ; break ; case 1 : image -> orientation = TopRightOrientation ; break ; case 2 : image -> orientation = BottomLeftOrientation ; break ; case 3 : image -> orientation = BottomRightOrientation ; break ; case 4 : image -> orientation = LeftTopOrientation ; break ; case 5 : image -> orientation = RightTopOrientation ; break ; case 6 : image -> orientation = LeftBottomOrientation ; break ; case 7 : image -> orientation = RightBottomOrientation ; break ; } cin . image . number_channels = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; offset += ReadBlob ( image , sizeof ( cin . image . reserve1 ) , ( unsigned char * ) cin . image . reserve1 ) ; for ( i = 0 ; i < 8 ; i ++ ) { cin . image . channel [ i ] . designator [ 0 ] = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . image . channel [ i ] . designator [ 1 ] = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . image . channel [ i ] . bits_per_pixel = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . image . channel [ i ] . reserve = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . image . channel [ i ] . pixels_per_line = ReadBlobLong ( image ) ; offset += 4 ; cin . image . channel [ i ] . lines_per_image = ReadBlobLong ( image ) ; offset += 4 ; cin . image . channel [ i ] . min_data = ReadBlobFloat ( image ) ; offset += 4 ; cin . image . channel [ i ] . min_quantity = ReadBlobFloat ( image ) ; offset += 4 ; cin . image . channel [ i ] . max_data = ReadBlobFloat ( image ) ; offset += 4 ; cin . image . channel [ i ] . max_quantity = ReadBlobFloat ( image ) ; offset += 4 ; } cin . image . white_point [ 0 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . white_point [ 0 ] ) != MagickFalse ) image -> chromaticity . white_point . x = cin . image . white_point [ 0 ] ; cin . image . white_point [ 1 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . white_point [ 1 ] ) != MagickFalse ) image -> chromaticity . white_point . y = cin . image . white_point [ 1 ] ; cin . image . red_primary_chromaticity [ 0 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . red_primary_chromaticity [ 0 ] ) != MagickFalse ) image -> chromaticity . red_primary . x = cin . image . red_primary_chromaticity [ 0 ] ; cin . image . red_primary_chromaticity [ 1 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . red_primary_chromaticity [ 1 ] ) != MagickFalse ) image -> chromaticity . red_primary . y = cin . image . red_primary_chromaticity [ 1 ] ; cin . image . green_primary_chromaticity [ 0 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . green_primary_chromaticity [ 0 ] ) != MagickFalse ) image -> chromaticity . red_primary . x = cin . image . green_primary_chromaticity [ 0 ] ; cin . image . green_primary_chromaticity [ 1 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . green_primary_chromaticity [ 1 ] ) != MagickFalse ) image -> chromaticity . green_primary . y = cin . image . green_primary_chromaticity [ 1 ] ; cin . image . blue_primary_chromaticity [ 0 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . blue_primary_chromaticity [ 0 ] ) != MagickFalse ) image -> chromaticity . blue_primary . x = cin . image . blue_primary_chromaticity [ 0 ] ; cin . image . blue_primary_chromaticity [ 1 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . blue_primary_chromaticity [ 1 ] ) != MagickFalse ) image -> chromaticity . blue_primary . y = cin . image . blue_primary_chromaticity [ 1 ] ; offset += ReadBlob ( image , sizeof ( cin . image . label ) , ( unsigned char * ) cin . image . label ) ; ( void ) CopyMagickString ( property , cin . image . label , sizeof ( cin . image . label ) ) ; ( void ) SetImageProperty ( image , ""dpx:image.label"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . image . reserve ) , ( unsigned char * ) cin . image . reserve ) ; cin . data_format . interleave = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . data_format . packing = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . data_format . sign = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . data_format . sense = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . data_format . line_pad = ReadBlobLong ( image ) ; offset += 4 ; cin . data_format . channel_pad = ReadBlobLong ( image ) ; offset += 4 ; offset += ReadBlob ( image , sizeof ( cin . data_format . reserve ) , ( unsigned char * ) cin . data_format . reserve ) ; cin . origination . x_offset = ReadBlobSignedLong ( image ) ; offset += 4 ; if ( ( size_t ) cin . origination . x_offset != ~ 0UL ) ( void ) FormatImageProperty ( image , ""dpx:origination.x_offset"" , ""%.20g"" , ( double ) cin . origination . x_offset ) ; cin . origination . y_offset = ( ssize_t ) ReadBlobLong ( image ) ; offset += 4 ; if ( ( size_t ) cin . origination . y_offset != ~ 0UL ) ( void ) FormatImageProperty ( image , ""dpx:origination.y_offset"" , ""%.20g"" , ( double ) cin . origination . y_offset ) ; offset += ReadBlob ( image , sizeof ( cin . origination . filename ) , ( unsigned char * ) cin . origination . filename ) ; ( void ) CopyMagickString ( property , cin . origination . filename , sizeof ( cin . origination . filename ) ) ; ( void ) SetImageProperty ( image , ""dpx:origination.filename"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . origination . create_date ) , ( unsigned char * ) cin . origination . create_date ) ; ( void ) CopyMagickString ( property , cin . origination . create_date , sizeof ( cin . origination . create_date ) ) ; ( void ) SetImageProperty ( image , ""dpx:origination.create_date"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . origination . create_time ) , ( unsigned char * ) cin . origination . create_time ) ; ( void ) CopyMagickString ( property , cin . origination . create_time , sizeof ( cin . origination . create_time ) ) ; ( void ) SetImageProperty ( image , ""dpx:origination.create_time"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . origination . device ) , ( unsigned char * ) cin . origination . device ) ; ( void ) CopyMagickString ( property , cin . origination . device , sizeof ( cin . origination . device ) ) ; ( void ) SetImageProperty ( image , ""dpx:origination.device"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . origination . model ) , ( unsigned char * ) cin . origination . model ) ; ( void ) CopyMagickString ( property , cin . origination . model , sizeof ( cin . origination . model ) ) ; ( void ) SetImageProperty ( image , ""dpx:origination.model"" , property , exception ) ; ( void ) memset ( cin . origination . serial , 0 , sizeof ( cin . origination . serial ) ) ; offset += ReadBlob ( image , sizeof ( cin . origination . serial ) , ( unsigned char * ) cin . origination . serial ) ; ( void ) CopyMagickString ( property , cin . origination . serial , sizeof ( cin . origination . serial ) ) ; ( void ) SetImageProperty ( image , ""dpx:origination.serial"" , property , exception ) ; cin . origination . x_pitch = ReadBlobFloat ( image ) ; offset += 4 ; cin . origination . y_pitch = ReadBlobFloat ( image ) ; offset += 4 ; cin . origination . gamma = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . origination . gamma ) != MagickFalse ) image -> gamma = cin . origination . gamma ; offset += ReadBlob ( image , sizeof ( cin . origination . reserve ) , ( unsigned char * ) cin . origination . reserve ) ; if ( ( cin . file . image_offset > 2048 ) && ( cin . file . user_length != 0 ) ) { int c ; cin . film . id = ReadBlobByte ( image ) ; offset ++ ; c = cin . film . id ; if ( c != ~ 0 ) ( void ) FormatImageProperty ( image , ""dpx:film.id"" , ""%d"" , cin . film . id ) ; cin . film . type = ReadBlobByte ( image ) ; offset ++ ; c = cin . film . type ; if ( c != ~ 0 ) ( void ) FormatImageProperty ( image , ""dpx:film.type"" , ""%d"" , cin . film . type ) ; cin . film . offset = ReadBlobByte ( image ) ; offset ++ ; c = cin . film . offset ; if ( c != ~ 0 ) ( void ) FormatImageProperty ( image , ""dpx:film.offset"" , ""%d"" , cin . film . offset ) ; cin . film . reserve1 = ReadBlobByte ( image ) ; offset ++ ; cin . film . prefix = ReadBlobLong ( image ) ; offset += 4 ; if ( cin . film . prefix != ~ 0UL ) ( void ) FormatImageProperty ( image , ""dpx:film.prefix"" , ""%.20g"" , ( double ) cin . film . prefix ) ; cin . film . count = ReadBlobLong ( image ) ; offset += 4 ; offset += ReadBlob ( image , sizeof ( cin . film . format ) , ( unsigned char * ) cin . film . format ) ; ( void ) CopyMagickString ( property , cin . film . format , sizeof ( cin . film . format ) ) ; ( void ) SetImageProperty ( image , ""dpx:film.format"" , property , exception ) ; cin . film . frame_position = ReadBlobLong ( image ) ; offset += 4 ; if ( cin . film . frame_position != ~ 0UL ) ( void ) FormatImageProperty ( image , ""dpx:film.frame_position"" , ""%.20g"" , ( double ) cin . film . frame_position ) ; cin . film . frame_rate = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . film . frame_rate ) != MagickFalse ) ( void ) FormatImageProperty ( image , ""dpx:film.frame_rate"" , ""%g"" , cin . film . frame_rate ) ; offset += ReadBlob ( image , sizeof ( cin . film . frame_id ) , ( unsigned char * ) cin . film . frame_id ) ; ( void ) CopyMagickString ( property , cin . film . frame_id , sizeof ( cin . film . frame_id ) ) ; ( void ) SetImageProperty ( image , ""dpx:film.frame_id"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . film . slate_info ) , ( unsigned char * ) cin . film . slate_info ) ; ( void ) CopyMagickString ( property , cin . film . slate_info , sizeof ( cin . film . slate_info ) ) ; ( void ) SetImageProperty ( image , ""dpx:film.slate_info"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . film . reserve ) , ( unsigned char * ) cin . film . reserve ) ; } if ( ( cin . file . image_offset > 2048 ) && ( cin . file . user_length != 0 ) ) { StringInfo * profile ; if ( cin . file . user_length > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; profile = BlobToStringInfo ( ( const unsigned char * ) NULL , cin . file . user_length ) ; if ( profile == ( StringInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; offset += ReadBlob ( image , GetStringInfoLength ( profile ) , GetStringInfoDatum ( profile ) ) ; ( void ) SetImageProfile ( image , ""dpx:user.data"" , profile , exception ) ; profile = DestroyStringInfo ( profile ) ; } image -> depth = cin . image . channel [ 0 ] . bits_per_pixel ; image -> columns = cin . image . channel [ 0 ] . pixels_per_line ; image -> rows = cin . image . channel [ 0 ] . lines_per_image ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( image ) ; }  for ( ; offset < ( MagickOffsetType ) cin . file . image_offset ; offset ++ )  { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } if ( offset < ( MagickOffsetType ) cin . file . image_offset ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; ( void ) SetImageBackgroundColor ( image , exception ) ; quantum_info = AcquireQuantumInfo ( image_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; quantum_info -> quantum = 32 ; quantum_info -> pack = MagickFalse ; quantum_type = RGBQuantum ; length = GetQuantumExtent ( image , quantum_info , quantum_type ) ; length = GetBytesPerRow ( image -> columns , 3 , image -> depth , MagickTrue ) ; if ( cin . image . number_channels == 1 ) { quantum_type = GrayQuantum ; length = GetBytesPerRow ( image -> columns , 1 , image -> depth , MagickTrue ) ; } for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; if ( ( size_t ) count != length ) break ; ( void ) ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , quantum_type , pixels , exception ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } SetQuantumImageType ( image , quantum_type ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; SetImageColorspace ( image , LogColorspace , exception ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","if ( ( ( MagickSizeType ) image -> columns * image -> rows ) > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;",158
222,"buggy line: for ( ;offset ++ )  {cwe id:CWE-400context: static Image * ReadCINImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define MonoColorType 1 # define RGBColorType 3 char property [ MagickPathExtent ] ; CINInfo cin ; const unsigned char * pixels ; Image * image ; MagickBooleanType status ; MagickOffsetType offset ; QuantumInfo * quantum_info ; QuantumType quantum_type ; register ssize_t i ; register Quantum * q ; size_t length ; ssize_t count , y ; unsigned char magick [ 4 ] ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } offset = 0 ; count = ReadBlob ( image , 4 , magick ) ; offset += count ; if ( ( count != 4 ) || ( ( LocaleNCompare ( ( char * ) magick , ""\\200\\052\\137\\327"" , 4 ) != 0 ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; memset ( & cin , 0 , sizeof ( cin ) ) ; image -> endian = ( magick [ 0 ] == 0x80 ) && ( magick [ 1 ] == 0x2a ) && ( magick [ 2 ] == 0x5f ) && ( magick [ 3 ] == 0xd7 ) ? MSBEndian : LSBEndian ; cin . file . image_offset = ReadBlobLong ( image ) ; offset += 4 ; cin . file . generic_length = ReadBlobLong ( image ) ; offset += 4 ; cin . file . industry_length = ReadBlobLong ( image ) ; offset += 4 ; cin . file . user_length = ReadBlobLong ( image ) ; offset += 4 ; cin . file . file_size = ReadBlobLong ( image ) ; offset += 4 ; offset += ReadBlob ( image , sizeof ( cin . file . version ) , ( unsigned char * ) cin . file . version ) ; ( void ) CopyMagickString ( property , cin . file . version , sizeof ( cin . file . version ) ) ; ( void ) SetImageProperty ( image , ""dpx:file.version"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . file . filename ) , ( unsigned char * ) cin . file . filename ) ; ( void ) CopyMagickString ( property , cin . file . filename , sizeof ( cin . file . filename ) ) ; ( void ) SetImageProperty ( image , ""dpx:file.filename"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . file . create_date ) , ( unsigned char * ) cin . file . create_date ) ; ( void ) CopyMagickString ( property , cin . file . create_date , sizeof ( cin . file . create_date ) ) ; ( void ) SetImageProperty ( image , ""dpx:file.create_date"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . file . create_time ) , ( unsigned char * ) cin . file . create_time ) ; ( void ) CopyMagickString ( property , cin . file . create_time , sizeof ( cin . file . create_time ) ) ; ( void ) SetImageProperty ( image , ""dpx:file.create_time"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . file . reserve ) , ( unsigned char * ) cin . file . reserve ) ; cin . image . orientation = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; if ( cin . image . orientation != ( unsigned char ) ( ~ 0 ) ) ( void ) FormatImageProperty ( image , ""dpx:image.orientation"" , ""%d"" , cin . image . orientation ) ; switch ( cin . image . orientation ) { default : case 0 : image -> orientation = TopLeftOrientation ; break ; case 1 : image -> orientation = TopRightOrientation ; break ; case 2 : image -> orientation = BottomLeftOrientation ; break ; case 3 : image -> orientation = BottomRightOrientation ; break ; case 4 : image -> orientation = LeftTopOrientation ; break ; case 5 : image -> orientation = RightTopOrientation ; break ; case 6 : image -> orientation = LeftBottomOrientation ; break ; case 7 : image -> orientation = RightBottomOrientation ; break ; } cin . image . number_channels = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; offset += ReadBlob ( image , sizeof ( cin . image . reserve1 ) , ( unsigned char * ) cin . image . reserve1 ) ; for ( i = 0 ; i < 8 ; i ++ ) { cin . image . channel [ i ] . designator [ 0 ] = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . image . channel [ i ] . designator [ 1 ] = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . image . channel [ i ] . bits_per_pixel = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . image . channel [ i ] . reserve = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . image . channel [ i ] . pixels_per_line = ReadBlobLong ( image ) ; offset += 4 ; cin . image . channel [ i ] . lines_per_image = ReadBlobLong ( image ) ; offset += 4 ; cin . image . channel [ i ] . min_data = ReadBlobFloat ( image ) ; offset += 4 ; cin . image . channel [ i ] . min_quantity = ReadBlobFloat ( image ) ; offset += 4 ; cin . image . channel [ i ] . max_data = ReadBlobFloat ( image ) ; offset += 4 ; cin . image . channel [ i ] . max_quantity = ReadBlobFloat ( image ) ; offset += 4 ; } cin . image . white_point [ 0 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . white_point [ 0 ] ) != MagickFalse ) image -> chromaticity . white_point . x = cin . image . white_point [ 0 ] ; cin . image . white_point [ 1 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . white_point [ 1 ] ) != MagickFalse ) image -> chromaticity . white_point . y = cin . image . white_point [ 1 ] ; cin . image . red_primary_chromaticity [ 0 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . red_primary_chromaticity [ 0 ] ) != MagickFalse ) image -> chromaticity . red_primary . x = cin . image . red_primary_chromaticity [ 0 ] ; cin . image . red_primary_chromaticity [ 1 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . red_primary_chromaticity [ 1 ] ) != MagickFalse ) image -> chromaticity . red_primary . y = cin . image . red_primary_chromaticity [ 1 ] ; cin . image . green_primary_chromaticity [ 0 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . green_primary_chromaticity [ 0 ] ) != MagickFalse ) image -> chromaticity . red_primary . x = cin . image . green_primary_chromaticity [ 0 ] ; cin . image . green_primary_chromaticity [ 1 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . green_primary_chromaticity [ 1 ] ) != MagickFalse ) image -> chromaticity . green_primary . y = cin . image . green_primary_chromaticity [ 1 ] ; cin . image . blue_primary_chromaticity [ 0 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . blue_primary_chromaticity [ 0 ] ) != MagickFalse ) image -> chromaticity . blue_primary . x = cin . image . blue_primary_chromaticity [ 0 ] ; cin . image . blue_primary_chromaticity [ 1 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . blue_primary_chromaticity [ 1 ] ) != MagickFalse ) image -> chromaticity . blue_primary . y = cin . image . blue_primary_chromaticity [ 1 ] ; offset += ReadBlob ( image , sizeof ( cin . image . label ) , ( unsigned char * ) cin . image . label ) ; ( void ) CopyMagickString ( property , cin . image . label , sizeof ( cin . image . label ) ) ; ( void ) SetImageProperty ( image , ""dpx:image.label"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . image . reserve ) , ( unsigned char * ) cin . image . reserve ) ; cin . data_format . interleave = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . data_format . packing = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . data_format . sign = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . data_format . sense = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . data_format . line_pad = ReadBlobLong ( image ) ; offset += 4 ; cin . data_format . channel_pad = ReadBlobLong ( image ) ; offset += 4 ; offset += ReadBlob ( image , sizeof ( cin . data_format . reserve ) , ( unsigned char * ) cin . data_format . reserve ) ; cin . origination . x_offset = ReadBlobSignedLong ( image ) ; offset += 4 ; if ( ( size_t ) cin . origination . x_offset != ~ 0UL ) ( void ) FormatImageProperty ( image , ""dpx:origination.x_offset"" , ""%.20g"" , ( double ) cin . origination . x_offset ) ; cin . origination . y_offset = ( ssize_t ) ReadBlobLong ( image ) ; offset += 4 ; if ( ( size_t ) cin . origination . y_offset != ~ 0UL ) ( void ) FormatImageProperty ( image , ""dpx:origination.y_offset"" , ""%.20g"" , ( double ) cin . origination . y_offset ) ; offset += ReadBlob ( image , sizeof ( cin . origination . filename ) , ( unsigned char * ) cin . origination . filename ) ; ( void ) CopyMagickString ( property , cin . origination . filename , sizeof ( cin . origination . filename ) ) ; ( void ) SetImageProperty ( image , ""dpx:origination.filename"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . origination . create_date ) , ( unsigned char * ) cin . origination . create_date ) ; ( void ) CopyMagickString ( property , cin . origination . create_date , sizeof ( cin . origination . create_date ) ) ; ( void ) SetImageProperty ( image , ""dpx:origination.create_date"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . origination . create_time ) , ( unsigned char * ) cin . origination . create_time ) ; ( void ) CopyMagickString ( property , cin . origination . create_time , sizeof ( cin . origination . create_time ) ) ; ( void ) SetImageProperty ( image , ""dpx:origination.create_time"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . origination . device ) , ( unsigned char * ) cin . origination . device ) ; ( void ) CopyMagickString ( property , cin . origination . device , sizeof ( cin . origination . device ) ) ; ( void ) SetImageProperty ( image , ""dpx:origination.device"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . origination . model ) , ( unsigned char * ) cin . origination . model ) ; ( void ) CopyMagickString ( property , cin . origination . model , sizeof ( cin . origination . model ) ) ; ( void ) SetImageProperty ( image , ""dpx:origination.model"" , property , exception ) ; ( void ) memset ( cin . origination . serial , 0 , sizeof ( cin . origination . serial ) ) ; offset += ReadBlob ( image , sizeof ( cin . origination . serial ) , ( unsigned char * ) cin . origination . serial ) ; ( void ) CopyMagickString ( property , cin . origination . serial , sizeof ( cin . origination . serial ) ) ; ( void ) SetImageProperty ( image , ""dpx:origination.serial"" , property , exception ) ; cin . origination . x_pitch = ReadBlobFloat ( image ) ; offset += 4 ; cin . origination . y_pitch = ReadBlobFloat ( image ) ; offset += 4 ; cin . origination . gamma = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . origination . gamma ) != MagickFalse ) image -> gamma = cin . origination . gamma ; offset += ReadBlob ( image , sizeof ( cin . origination . reserve ) , ( unsigned char * ) cin . origination . reserve ) ; if ( ( cin . file . image_offset > 2048 ) && ( cin . file . user_length != 0 ) ) { int c ; cin . film . id = ReadBlobByte ( image ) ; offset ++ ; c = cin . film . id ; if ( c != ~ 0 ) ( void ) FormatImageProperty ( image , ""dpx:film.id"" , ""%d"" , cin . film . id ) ; cin . film . type = ReadBlobByte ( image ) ; offset ++ ; c = cin . film . type ; if ( c != ~ 0 ) ( void ) FormatImageProperty ( image , ""dpx:film.type"" , ""%d"" , cin . film . type ) ; cin . film . offset = ReadBlobByte ( image ) ; offset ++ ; c = cin . film . offset ; if ( c != ~ 0 ) ( void ) FormatImageProperty ( image , ""dpx:film.offset"" , ""%d"" , cin . film . offset ) ; cin . film . reserve1 = ReadBlobByte ( image ) ; offset ++ ; cin . film . prefix = ReadBlobLong ( image ) ; offset += 4 ; if ( cin . film . prefix != ~ 0UL ) ( void ) FormatImageProperty ( image , ""dpx:film.prefix"" , ""%.20g"" , ( double ) cin . film . prefix ) ; cin . film . count = ReadBlobLong ( image ) ; offset += 4 ; offset += ReadBlob ( image , sizeof ( cin . film . format ) , ( unsigned char * ) cin . film . format ) ; ( void ) CopyMagickString ( property , cin . film . format , sizeof ( cin . film . format ) ) ; ( void ) SetImageProperty ( image , ""dpx:film.format"" , property , exception ) ; cin . film . frame_position = ReadBlobLong ( image ) ; offset += 4 ; if ( cin . film . frame_position != ~ 0UL ) ( void ) FormatImageProperty ( image , ""dpx:film.frame_position"" , ""%.20g"" , ( double ) cin . film . frame_position ) ; cin . film . frame_rate = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . film . frame_rate ) != MagickFalse ) ( void ) FormatImageProperty ( image , ""dpx:film.frame_rate"" , ""%g"" , cin . film . frame_rate ) ; offset += ReadBlob ( image , sizeof ( cin . film . frame_id ) , ( unsigned char * ) cin . film . frame_id ) ; ( void ) CopyMagickString ( property , cin . film . frame_id , sizeof ( cin . film . frame_id ) ) ; ( void ) SetImageProperty ( image , ""dpx:film.frame_id"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . film . slate_info ) , ( unsigned char * ) cin . film . slate_info ) ; ( void ) CopyMagickString ( property , cin . film . slate_info , sizeof ( cin . film . slate_info ) ) ; ( void ) SetImageProperty ( image , ""dpx:film.slate_info"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . film . reserve ) , ( unsigned char * ) cin . film . reserve ) ; } if ( ( cin . file . image_offset > 2048 ) && ( cin . file . user_length != 0 ) ) { StringInfo * profile ; if ( cin . file . user_length > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; profile = BlobToStringInfo ( ( const unsigned char * ) NULL , cin . file . user_length ) ; if ( profile == ( StringInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; offset += ReadBlob ( image , GetStringInfoLength ( profile ) , GetStringInfoDatum ( profile ) ) ; ( void ) SetImageProfile ( image , ""dpx:user.data"" , profile , exception ) ; profile = DestroyStringInfo ( profile ) ; } image -> depth = cin . image . channel [ 0 ] . bits_per_pixel ; image -> columns = cin . image . channel [ 0 ] . pixels_per_line ; image -> rows = cin . image . channel [ 0 ] . lines_per_image ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( image ) ; }  for ( ; offset < ( MagickOffsetType ) cin . file . image_offset ; offset ++ )  { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } if ( offset < ( MagickOffsetType ) cin . file . image_offset ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; ( void ) SetImageBackgroundColor ( image , exception ) ; quantum_info = AcquireQuantumInfo ( image_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; quantum_info -> quantum = 32 ; quantum_info -> pack = MagickFalse ; quantum_type = RGBQuantum ; length = GetQuantumExtent ( image , quantum_info , quantum_type ) ; length = GetBytesPerRow ( image -> columns , 3 , image -> depth , MagickTrue ) ; if ( cin . image . number_channels == 1 ) { quantum_type = GrayQuantum ; length = GetBytesPerRow ( image -> columns , 1 , image -> depth , MagickTrue ) ; } for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; if ( ( size_t ) count != length ) break ; ( void ) ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , quantum_type , pixels , exception ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } SetQuantumImageType ( image , quantum_type ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; SetImageColorspace ( image , LogColorspace , exception ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }",for ( ;offset ++ ) {,158
223,"buggy line: if ( ( gr -> gr_ctx . value = mem_alloc ( sizeof ( gss_union_ctx_id_desc ) ) ) == NULL ) {fprintf ( stderr , ""svcauth_gss_accept_context:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory\\\memcpy ( gr -> gr_ctx . value , gd -> ctx , sizeof ( gss_union_ctx_id_desc ) ) ;gr -> gr_ctx . length = sizeof ( gss_union_ctx_id_desc ) ;cwe id:CWE-200context: static bool_t svcauth_gss_accept_sec_context ( struct svc_req * rqst , struct rpc_gss_init_res * gr ) { struct svc_rpc_gss_data * gd ; struct rpc_gss_cred * gc ; gss_buffer_desc recv_tok , seqbuf ; gss_OID mech ; OM_uint32 maj_stat = 0 , min_stat = 0 , ret_flags , seq ; log_debug ( ""in<S2SV_blank>svcauth_gss_accept_context()"" ) ; gd = SVCAUTH_PRIVATE ( rqst -> rq_xprt -> xp_auth ) ; gc = ( struct rpc_gss_cred * ) rqst -> rq_clntcred ; memset ( gr , 0 , sizeof ( * gr ) ) ; memset ( & recv_tok , 0 , sizeof ( recv_tok ) ) ; if ( ! svc_getargs ( rqst -> rq_xprt , xdr_rpc_gss_init_args , ( caddr_t ) & recv_tok ) ) return ( FALSE ) ; gr -> gr_major = gss_accept_sec_context ( & gr -> gr_minor , & gd -> ctx , svcauth_gss_creds , & recv_tok , GSS_C_NO_CHANNEL_BINDINGS , & gd -> client_name , & mech , & gr -> gr_token , & ret_flags , NULL , NULL ) ; svc_freeargs ( rqst -> rq_xprt , xdr_rpc_gss_init_args , ( caddr_t ) & recv_tok ) ; log_status ( ""accept_sec_context"" , gr -> gr_major , gr -> gr_minor ) ; if ( gr -> gr_major != GSS_S_COMPLETE && gr -> gr_major != GSS_S_CONTINUE_NEEDED ) { badauth ( gr -> gr_major , gr -> gr_minor , rqst -> rq_xprt ) ; gd -> ctx = GSS_C_NO_CONTEXT ; goto errout ; }  if ( ( gr -> gr_ctx . value = mem_alloc ( sizeof ( gss_union_ctx_id_desc ) ) ) == NULL ) {  fprintf ( stderr , ""svcauth_gss_accept_context:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory\\n"" ) ; goto errout ; }  memcpy ( gr -> gr_ctx . value , gd -> ctx , sizeof ( gss_union_ctx_id_desc ) ) ;  gr -> gr_ctx . length = sizeof ( gss_union_ctx_id_desc ) ; gr -> gr_win = sizeof ( gd -> seqmask ) * 8 ; gd -> sec . mech = mech ; gd -> sec . qop = GSS_C_QOP_DEFAULT ; gd -> sec . svc = gc -> gc_svc ; gd -> seq = gc -> gc_seq ; gd -> win = gr -> gr_win ; if ( gr -> gr_major == GSS_S_COMPLETE ) { # ifdef SPKM if ( ! g_OID_equal ( gss_mech_spkm3 , mech ) ) { # endif maj_stat = gss_display_name ( & min_stat , gd -> client_name , & gd -> cname , & gd -> sec . mech ) ; # ifdef SPKM } # endif if ( maj_stat != GSS_S_COMPLETE ) { log_status ( ""display_name"" , maj_stat , min_stat ) ; goto errout ; } # ifdef DEBUG # ifdef HAVE_HEIMDAL log_debug ( ""accepted<S2SV_blank>context<S2SV_blank>for<S2SV_blank>%.*s<S2SV_blank>with<S2SV_blank>"" ""<mech<S2SV_blank>{},<S2SV_blank>qop<S2SV_blank>%d,<S2SV_blank>svc<S2SV_blank>%d>"" , gd -> cname . length , ( char * ) gd -> cname . value , gd -> sec . qop , gd -> sec . svc ) ; # else { gss_buffer_desc mechname ; gss_oid_to_str ( & min_stat , mech , & mechname ) ; log_debug ( ""accepted<S2SV_blank>context<S2SV_blank>for<S2SV_blank>%.*s<S2SV_blank>with<S2SV_blank>"" ""<mech<S2SV_blank>%.*s,<S2SV_blank>qop<S2SV_blank>%d,<S2SV_blank>svc<S2SV_blank>%d>"" , gd -> cname . length , ( char * ) gd -> cname . value , mechname . length , ( char * ) mechname . value , gd -> sec . qop , gd -> sec . svc ) ; gss_release_buffer ( & min_stat , & mechname ) ; } # endif # endif seq = htonl ( gr -> gr_win ) ; seqbuf . value = & seq ; seqbuf . length = sizeof ( seq ) ; gss_release_buffer ( & min_stat , & gd -> checksum ) ; maj_stat = gss_sign ( & min_stat , gd -> ctx , GSS_C_QOP_DEFAULT , & seqbuf , & gd -> checksum ) ; if ( maj_stat != GSS_S_COMPLETE ) { goto errout ; } rqst -> rq_xprt -> xp_verf . oa_flavor = RPCSEC_GSS ; rqst -> rq_xprt -> xp_verf . oa_base = gd -> checksum . value ; rqst -> rq_xprt -> xp_verf . oa_length = gd -> checksum . length ; } return ( TRUE ) ; errout : gss_release_buffer ( & min_stat , & gr -> gr_token ) ; return ( FALSE ) ; }","gr -> gr_ctx . value = mem_alloc ( sizeof ( gss_union_ctx_id_desc ) ) ) == NULL ) {fprintf ( stderr , ""svcauth_gss_accept_context:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory\\\memcpy ( gr -> gr_ctx . length = 4 ;gr -> gr_ctx . length = sizeof ( gss_union_ctx_id_desc ) ;",159
224,"buggy line: if ( ext_depth ( inode ) )  goal = ext4_idx_pblock ( EXT_FIRST_INDEX ( ext_inode_hdr ( inode ) ) ) ;cwe id:CWE-200context: static int ext4_ext_grow_indepth ( handle_t * handle , struct inode * inode , unsigned int flags ) { struct ext4_extent_header * neh ; struct buffer_head * bh ; ext4_fsblk_t newblock , goal = 0 ; struct ext4_super_block * es = EXT4_SB ( inode -> i_sb ) -> s_es ; int err = 0 ;  if ( ext_depth ( inode ) )  goal = ext4_idx_pblock ( EXT_FIRST_INDEX ( ext_inode_hdr ( inode ) ) ) ; if ( goal > le32_to_cpu ( es -> s_first_data_block ) ) { flags |= EXT4_MB_HINT_TRY_GOAL ; goal -- ; } else goal = ext4_inode_to_goal_block ( inode ) ; newblock = ext4_new_meta_blocks ( handle , inode , goal , flags , NULL , & err ) ; if ( newblock == 0 ) return err ; bh = sb_getblk_gfp ( inode -> i_sb , newblock , __GFP_MOVABLE | GFP_NOFS ) ; if ( unlikely ( ! bh ) ) return - ENOMEM ; lock_buffer ( bh ) ; err = ext4_journal_get_create_access ( handle , bh ) ; if ( err ) { unlock_buffer ( bh ) ; goto out ; }  memmove ( bh -> b_data , EXT4_I ( inode ) -> i_data ,   sizeof ( EXT4_I ( inode ) -> i_data ) ) ;  neh = ext_block_hdr ( bh ) ; if ( ext_depth ( inode ) ) neh -> eh_max = cpu_to_le16 ( ext4_ext_space_block_idx ( inode , 0 ) ) ; else neh -> eh_max = cpu_to_le16 ( ext4_ext_space_block ( inode , 0 ) ) ; neh -> eh_magic = EXT4_EXT_MAGIC ; ext4_extent_block_csum_set ( inode , neh ) ; set_buffer_uptodate ( bh ) ; unlock_buffer ( bh ) ; err = ext4_handle_dirty_metadata ( handle , inode , bh ) ; if ( err ) goto out ; neh = ext_inode_hdr ( inode ) ; neh -> eh_entries = cpu_to_le16 ( 1 ) ; ext4_idx_store_pblock ( EXT_FIRST_INDEX ( neh ) , newblock ) ; if ( neh -> eh_depth == 0 ) { neh -> eh_max = cpu_to_le16 ( ext4_ext_space_root_idx ( inode , 0 ) ) ; EXT_FIRST_INDEX ( neh ) -> ei_block = EXT_FIRST_EXTENT ( neh ) -> ee_block ; } ext_debug ( ""new<S2SV_blank>root:<S2SV_blank>num<S2SV_blank>%d(%d),<S2SV_blank>lblock<S2SV_blank>%d,<S2SV_blank>ptr<S2SV_blank>%llu\\n"" , le16_to_cpu ( neh -> eh_entries ) , le16_to_cpu ( neh -> eh_max ) , le32_to_cpu ( EXT_FIRST_INDEX ( neh ) -> ei_block ) , ext4_idx_pblock ( EXT_FIRST_INDEX ( neh ) ) ) ; le16_add_cpu ( & neh -> eh_depth , 1 ) ; ext4_mark_inode_dirty ( handle , inode ) ; out : brelse ( bh ) ; return err ; }",size_t ext_size = 0 ;if ( ext_depth ( inode ) ) goal = ext4_idx_pblock ( EXT_FIRST_INDEX ( ext_inode_hdr ( inode ) ) ) ;,160
225,"buggy line: memmove ( bh -> b_data , EXT4_I ( inode ) -> i_data ,   sizeof ( EXT4_I ( inode ) -> i_data ) ) ;neh = ext_block_hdr ( bh ) ;cwe id:CWE-200context: static int ext4_ext_grow_indepth ( handle_t * handle , struct inode * inode , unsigned int flags ) { struct ext4_extent_header * neh ; struct buffer_head * bh ; ext4_fsblk_t newblock , goal = 0 ; struct ext4_super_block * es = EXT4_SB ( inode -> i_sb ) -> s_es ; int err = 0 ;  if ( ext_depth ( inode ) )  goal = ext4_idx_pblock ( EXT_FIRST_INDEX ( ext_inode_hdr ( inode ) ) ) ; if ( goal > le32_to_cpu ( es -> s_first_data_block ) ) { flags |= EXT4_MB_HINT_TRY_GOAL ; goal -- ; } else goal = ext4_inode_to_goal_block ( inode ) ; newblock = ext4_new_meta_blocks ( handle , inode , goal , flags , NULL , & err ) ; if ( newblock == 0 ) return err ; bh = sb_getblk_gfp ( inode -> i_sb , newblock , __GFP_MOVABLE | GFP_NOFS ) ; if ( unlikely ( ! bh ) ) return - ENOMEM ; lock_buffer ( bh ) ; err = ext4_journal_get_create_access ( handle , bh ) ; if ( err ) { unlock_buffer ( bh ) ; goto out ; }  memmove ( bh -> b_data , EXT4_I ( inode ) -> i_data ,   sizeof ( EXT4_I ( inode ) -> i_data ) ) ;  neh = ext_block_hdr ( bh ) ; if ( ext_depth ( inode ) ) neh -> eh_max = cpu_to_le16 ( ext4_ext_space_block_idx ( inode , 0 ) ) ; else neh -> eh_max = cpu_to_le16 ( ext4_ext_space_block ( inode , 0 ) ) ; neh -> eh_magic = EXT4_EXT_MAGIC ; ext4_extent_block_csum_set ( inode , neh ) ; set_buffer_uptodate ( bh ) ; unlock_buffer ( bh ) ; err = ext4_handle_dirty_metadata ( handle , inode , bh ) ; if ( err ) goto out ; neh = ext_inode_hdr ( inode ) ; neh -> eh_entries = cpu_to_le16 ( 1 ) ; ext4_idx_store_pblock ( EXT_FIRST_INDEX ( neh ) , newblock ) ; if ( neh -> eh_depth == 0 ) { neh -> eh_max = cpu_to_le16 ( ext4_ext_space_root_idx ( inode , 0 ) ) ; EXT_FIRST_INDEX ( neh ) -> ei_block = EXT_FIRST_EXTENT ( neh ) -> ee_block ; } ext_debug ( ""new<S2SV_blank>root:<S2SV_blank>num<S2SV_blank>%d(%d),<S2SV_blank>lblock<S2SV_blank>%d,<S2SV_blank>ptr<S2SV_blank>%llu\\n"" , le16_to_cpu ( neh -> eh_entries ) , le16_to_cpu ( neh -> eh_max ) , le32_to_cpu ( EXT_FIRST_INDEX ( neh ) -> ei_block ) , ext4_idx_pblock ( EXT_FIRST_INDEX ( neh ) ) ) ; le16_add_cpu ( & neh -> eh_depth , 1 ) ; ext4_mark_inode_dirty ( handle , inode ) ; out : brelse ( bh ) ; return err ; }","ext_size = sizeof ( EXT4_I ( inode ) -> i_data ) ;memmove ( bh -> b_data , EXT4_I ( inode ) -> i_data , ext_size ) ;memset ( bh -> b_data + ext_size , 0 , inode -> i_sb -> s_blocksize - ext_size ) ;neh = ext_block_hdr ( bh ) ;",160
226,"buggy line: if ( verify_checks ( c , preverify_ok , callback_ctx ) ) {SSL_SESSION * sess = SSL_get1_session ( c -> ssl ) ;int ok = SSL_SESSION_set_ex_data ( sess , index_session_authenticated ,  ( void * ) ( - 1 ) ) ;SSL_SESSION_free ( sess ) ;cwe id:CWE-295context: NOEXPORT int verify_callback ( int preverify_ok , X509_STORE_CTX * callback_ctx ) { SSL * ssl ; CLI * c ; ssl = X509_STORE_CTX_get_ex_data ( callback_ctx , SSL_get_ex_data_X509_STORE_CTX_idx ( ) ) ; c = SSL_get_ex_data ( ssl , index_ssl_cli ) ; if ( ! c -> opt -> option . verify_chain && ! c -> opt -> option . verify_peer ) { s_log ( LOG_INFO , ""Certificate<S2SV_blank>verification<S2SV_blank>disabled"" ) ; return 1 ; }  if ( verify_checks ( c , preverify_ok , callback_ctx ) ) {  SSL_SESSION * sess = SSL_get1_session ( c -> ssl ) ; if ( sess ) { int ok = SSL_SESSION_set_ex_data ( sess , index_session_authenticated ,  ( void * ) ( - 1 ) ) ;  SSL_SESSION_free ( sess ) ; if ( ! ok ) { sslerror ( ""SSL_SESSION_set_ex_data"" ) ; return 0 ; } } return 1 ; }  if ( c -> opt -> option . client || c -> opt -> protocol )  return 0 ;  if ( c -> opt -> redirect_addr . names )  return 1 ; return 0 ; }","if ( verify_checks ( c , preverify_ok , callback_ctx ) ) return 1 ;if ( c -> opt -> option . client || c -> opt -> protocol ) return 0 ;if ( c -> opt -> redirect_addr . names ) {SSL_SESSION * sess = SSL_get1_session ( c -> ssl ) ;int ok = SSL_SESSION_set_ex_data ( sess , index_session_authenticated , NULL ) ;SSL_SESSION_free ( sess ) ;",161
227,"buggy line: if ( c -> opt -> option . client || c -> opt -> protocol )  return 0 ;if ( c -> opt -> redirect_addr . names )  return 1 ;cwe id:CWE-295context: NOEXPORT int verify_callback ( int preverify_ok , X509_STORE_CTX * callback_ctx ) { SSL * ssl ; CLI * c ; ssl = X509_STORE_CTX_get_ex_data ( callback_ctx , SSL_get_ex_data_X509_STORE_CTX_idx ( ) ) ; c = SSL_get_ex_data ( ssl , index_ssl_cli ) ; if ( ! c -> opt -> option . verify_chain && ! c -> opt -> option . verify_peer ) { s_log ( LOG_INFO , ""Certificate<S2SV_blank>verification<S2SV_blank>disabled"" ) ; return 1 ; }  if ( verify_checks ( c , preverify_ok , callback_ctx ) ) {  SSL_SESSION * sess = SSL_get1_session ( c -> ssl ) ; if ( sess ) { int ok = SSL_SESSION_set_ex_data ( sess , index_session_authenticated ,  ( void * ) ( - 1 ) ) ;  SSL_SESSION_free ( sess ) ; if ( ! ok ) { sslerror ( ""SSL_SESSION_set_ex_data"" ) ; return 0 ; } } return 1 ; }  if ( c -> opt -> option . client || c -> opt -> protocol )  return 0 ;  if ( c -> opt -> redirect_addr . names )  return 1 ; return 0 ; }","
",161
228,"buggy line: int ret ;if ( ! kuid_has_mapping ( parent_ns , owner ) || ! kgid_has_mapping ( parent_ns , group ) ) return - EPERM ;cwe id:CWE-264context: int create_user_ns ( struct cred * new ) { struct user_namespace * ns , * parent_ns = new -> user_ns ; kuid_t owner = new -> euid ; kgid_t group = new -> egid ;  int ret ;  if ( ! kuid_has_mapping ( parent_ns , owner ) || ! kgid_has_mapping ( parent_ns , group ) ) return - EPERM ; ns = kmem_cache_zalloc ( user_ns_cachep , GFP_KERNEL ) ; if ( ! ns ) return - ENOMEM ; ret = proc_alloc_inum ( & ns -> proc_inum ) ; if ( ret ) { kmem_cache_free ( user_ns_cachep , ns ) ; return ret ; } atomic_set ( & ns -> count , 1 ) ; ns -> parent = parent_ns ; ns -> owner = owner ; ns -> group = group ; set_cred_user_ns ( new , ns ) ; return 0 ; }","int ret ;if ( current_chrooted ( ) ) return - EPERM ;if ( ! kuid_has_mapping ( parent_ns , owner ) || ! kgid_has_mapping ( parent_ns , group ) ) return - EPERM ;",162
229,"buggy line: if ( is_signed ) {if ( at91_aes_cmac ( data_length , data , computed_cmac , key_size , cmac_key ) ) goto exit ;fixed_length = at91_aes_roundup ( data_length ) ;cmac = ( const unsigned int * ) ( ( char * ) data + fixed_length ) ;if ( memcmp ( cmac , computed_cmac , AT91_AES_BLOCK_SIZE_BYTE ) )  goto exit ;cwe id:CWE-203context: int secure_decrypt ( void * data , unsigned int data_length , int is_signed ) { at91_aes_key_size_t key_size ; unsigned int cmac_key [ 8 ] , cipher_key [ 8 ] ; unsigned int iv [ AT91_AES_IV_SIZE_WORD ] ; unsigned int computed_cmac [ AT91_AES_BLOCK_SIZE_WORD ] ; unsigned int fixed_length ; const unsigned int * cmac ; int rc = - 1 ; init_keys ( & key_size , cipher_key , cmac_key , iv ) ; at91_aes_init ( ) ; if ( is_signed ) { if ( at91_aes_cmac ( data_length , data , computed_cmac , key_size , cmac_key ) ) goto exit ; fixed_length = at91_aes_roundup ( data_length ) ; cmac = ( const unsigned int * ) ( ( char * ) data + fixed_length ) ;  if ( memcmp ( cmac , computed_cmac , AT91_AES_BLOCK_SIZE_BYTE ) )  goto exit ; } if ( at91_aes_cbc ( data_length , data , data , 0 , key_size , cipher_key , iv ) ) goto exit ; rc = 0 ; exit : at91_aes_cleanup ( ) ; memset ( cmac_key , 0 , sizeof ( cmac_key ) ) ; memset ( cipher_key , 0 , sizeof ( cipher_key ) ) ; memset ( iv , 0 , sizeof ( iv ) ) ; return rc ; }","if ( ! consttime_memequal ( cmac , computed_cmac , AT91_AES_BLOCK_SIZE_BYTE ) ) goto exit ;",163
230,"buggy line: c -> nreslevels = bytestream2_get_byteu ( & s -> g ) + 1 ;if ( c -> nreslevels >= JPEG2000_MAX_RESLEVELS ) {av_log ( s -> avctx , AV_LOG_ERROR , ""nreslevels<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>invalid\\\return AVERROR_INVALIDDATA ;}if ( c -> nreslevels < s -> reduction_factor )   c -> nreslevels2decode = 1 ;else c -> nreslevels2decode = c -> nreslevels - s -> reduction_factor ;cwe id:CWE-20context: static int get_cox ( Jpeg2000DecoderContext * s , Jpeg2000CodingStyle * c ) { uint8_t byte ; if ( bytestream2_get_bytes_left ( & s -> g ) < 5 ) return AVERROR_INVALIDDATA ; c -> nreslevels = bytestream2_get_byteu ( & s -> g ) + 1 ; if ( c -> nreslevels >= JPEG2000_MAX_RESLEVELS ) { av_log ( s -> avctx , AV_LOG_ERROR , ""nreslevels<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>invalid\\n"" , c -> nreslevels ) ; return AVERROR_INVALIDDATA ; }  if ( c -> nreslevels < s -> reduction_factor )   c -> nreslevels2decode = 1 ;  else c -> nreslevels2decode = c -> nreslevels - s -> reduction_factor ; c -> log2_cblk_width = ( bytestream2_get_byteu ( & s -> g ) & 15 ) + 2 ; c -> log2_cblk_height = ( bytestream2_get_byteu ( & s -> g ) & 15 ) + 2 ; if ( c -> log2_cblk_width > 10 || c -> log2_cblk_height > 10 || c -> log2_cblk_width + c -> log2_cblk_height > 12 ) { av_log ( s -> avctx , AV_LOG_ERROR , ""cblk<S2SV_blank>size<S2SV_blank>invalid\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( c -> log2_cblk_width > 6 || c -> log2_cblk_height > 6 ) { avpriv_request_sample ( s -> avctx , ""cblk<S2SV_blank>size<S2SV_blank>><S2SV_blank>64"" ) ; return AVERROR_PATCHWELCOME ; } c -> cblk_style = bytestream2_get_byteu ( & s -> g ) ; if ( c -> cblk_style != 0 ) { av_log ( s -> avctx , AV_LOG_WARNING , ""extra<S2SV_blank>cblk<S2SV_blank>styles<S2SV_blank>%X\\n"" , c -> cblk_style ) ; } c -> transform = bytestream2_get_byteu ( & s -> g ) ; if ( ( s -> avctx -> flags & CODEC_FLAG_BITEXACT ) && ( c -> transform == FF_DWT97 ) ) c -> transform = FF_DWT97_INT ; if ( c -> csty & JPEG2000_CSTY_PREC ) { int i ; for ( i = 0 ; i < c -> nreslevels ; i ++ ) { byte = bytestream2_get_byte ( & s -> g ) ; c -> log2_prec_widths [ i ] = byte & 0x0F ; c -> log2_prec_heights [ i ] = ( byte >> 4 ) & 0x0F ; } } else { memset ( c -> log2_prec_widths , 15 , sizeof ( c -> log2_prec_widths ) ) ; memset ( c -> log2_prec_heights , 15 , sizeof ( c -> log2_prec_heights ) ) ; } return 0 ; }",c -> nreslevels <= s -> reduction_factor ) c -> nreslevels2decode = 1 ;else c -> nreslevels2decode = c -> nreslevels - s -> reduction_factor ;,164
231,"buggy line: s_alDriver = Cvar_Get ( ""s_alDriver"" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH ) ;s_alInputDevice = Cvar_Get ( ""s_alInputDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ;s_alDevice = Cvar_Get ( ""s_alDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ;if ( ! QAL_Init ( s_alDriver -> string ) ) {cwe id:CWE-000context: qboolean S_AL_Init ( soundInterface_t * si ) { # ifdef USE_OPENAL const char * device = NULL ; const char * inputdevice = NULL ; int i ; if ( ! si ) { return qfalse ; } for ( i = 0 ; i < MAX_RAW_STREAMS ; i ++ ) { streamSourceHandles [ i ] = - 1 ; streamPlaying [ i ] = qfalse ; streamSources [ i ] = 0 ; streamNumBuffers [ i ] = 0 ; streamBufIndex [ i ] = 0 ; } s_alPrecache = Cvar_Get ( ""s_alPrecache"" , ""1"" , CVAR_ARCHIVE ) ; s_alGain = Cvar_Get ( ""s_alGain"" , ""1.0"" , CVAR_ARCHIVE ) ; s_alSources = Cvar_Get ( ""s_alSources"" , ""128"" , CVAR_ARCHIVE ) ; s_alDopplerFactor = Cvar_Get ( ""s_alDopplerFactor"" , ""1.0"" , CVAR_ARCHIVE ) ; s_alDopplerSpeed = Cvar_Get ( ""s_alDopplerSpeed"" , ""9000"" , CVAR_ARCHIVE ) ; s_alMinDistance = Cvar_Get ( ""s_alMinDistance"" , ""120"" , CVAR_CHEAT ) ; s_alMaxDistance = Cvar_Get ( ""s_alMaxDistance"" , ""1024"" , CVAR_CHEAT ) ; s_alRolloff = Cvar_Get ( ""s_alRolloff"" , ""2"" , CVAR_CHEAT ) ; s_alGraceDistance = Cvar_Get ( ""s_alGraceDistance"" , ""512"" , CVAR_CHEAT ) ;  s_alDriver = Cvar_Get ( ""s_alDriver"" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH ) ;  s_alInputDevice = Cvar_Get ( ""s_alInputDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ;  s_alDevice = Cvar_Get ( ""s_alDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ;  if ( ! QAL_Init ( s_alDriver -> string ) ) { # if defined ( _WIN32 ) if ( ! Q_stricmp ( s_alDriver -> string , ALDRIVER_DEFAULT ) && ! QAL_Init ( ""OpenAL64.dll"" ) ) { # elif defined ( __APPLE__ ) if ( ! Q_stricmp ( s_alDriver -> string , ALDRIVER_DEFAULT ) && ! QAL_Init ( ""/System/Library/Frameworks/OpenAL.framework/OpenAL"" ) ) { # else if ( ! Q_stricmp ( s_alDriver -> string , ALDRIVER_DEFAULT ) || ! QAL_Init ( ALDRIVER_DEFAULT ) ) { # endif return qfalse ; } } device = s_alDevice -> string ; if ( device && ! * device ) device = NULL ; inputdevice = s_alInputDevice -> string ; if ( inputdevice && ! * inputdevice ) inputdevice = NULL ; enumeration_all_ext = qalcIsExtensionPresent ( NULL , ""ALC_ENUMERATE_ALL_EXT"" ) ; enumeration_ext = qalcIsExtensionPresent ( NULL , ""ALC_ENUMERATION_EXT"" ) ; if ( enumeration_ext || enumeration_all_ext ) { char devicenames [ 16384 ] = """" ; const char * devicelist ; # ifdef _WIN32 const char * defaultdevice ; # endif int curlen ; if ( enumeration_all_ext ) { devicelist = qalcGetString ( NULL , ALC_ALL_DEVICES_SPECIFIER ) ; # ifdef _WIN32 defaultdevice = qalcGetString ( NULL , ALC_DEFAULT_ALL_DEVICES_SPECIFIER ) ; # endif } else { devicelist = qalcGetString ( NULL , ALC_DEVICE_SPECIFIER ) ; # ifdef _WIN32 defaultdevice = qalcGetString ( NULL , ALC_DEFAULT_DEVICE_SPECIFIER ) ; # endif enumeration_ext = qtrue ; } # ifdef _WIN32 if ( ! device && defaultdevice && ! strcmp ( defaultdevice , ""Generic<S2SV_blank>Hardware"" ) ) device = ""Generic<S2SV_blank>Software"" ; # endif if ( devicelist ) { while ( ( curlen = strlen ( devicelist ) ) ) { Q_strcat ( devicenames , sizeof ( devicenames ) , devicelist ) ; Q_strcat ( devicenames , sizeof ( devicenames ) , ""\\n"" ) ; devicelist += curlen + 1 ; } } s_alAvailableDevices = Cvar_Get ( ""s_alAvailableDevices"" , devicenames , CVAR_ROM | CVAR_NORESTART ) ; } alDevice = qalcOpenDevice ( device ) ; if ( ! alDevice && device ) { Com_Printf ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>OpenAL<S2SV_blank>device<S2SV_blank>\'%s\',<S2SV_blank>trying<S2SV_blank>default.\\n"" , device ) ; alDevice = qalcOpenDevice ( NULL ) ; } if ( ! alDevice ) { QAL_Shutdown ( ) ; Com_Printf ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>OpenAL<S2SV_blank>device.\\n"" ) ; return qfalse ; } alContext = qalcCreateContext ( alDevice , NULL ) ; if ( ! alContext ) { QAL_Shutdown ( ) ; qalcCloseDevice ( alDevice ) ; Com_Printf ( ""Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>OpenAL<S2SV_blank>context.\\n"" ) ; return qfalse ; } qalcMakeContextCurrent ( alContext ) ; S_AL_BufferInit ( ) ; S_AL_SrcInit ( ) ; Com_Printf ( ""Allocated<S2SV_blank>%d<S2SV_blank>sources.\\n"" , srcCount ) ; qalDistanceModel ( AL_INVERSE_DISTANCE_CLAMPED ) ; qalDopplerFactor ( s_alDopplerFactor -> value ) ; qalSpeedOfSound ( s_alDopplerSpeed -> value ) ; # ifdef USE_VOIP s_alCapture = Cvar_Get ( ""s_alCapture"" , ""1"" , CVAR_ARCHIVE | CVAR_LATCH ) ; if ( ! s_alCapture -> integer ) { Com_Printf ( ""OpenAL<S2SV_blank>capture<S2SV_blank>support<S2SV_blank>disabled<S2SV_blank>by<S2SV_blank>user<S2SV_blank>(\'+set<S2SV_blank>s_alCapture<S2SV_blank>1\'<S2SV_blank>to<S2SV_blank>enable)\\n"" ) ; } # if USE_MUMBLE else if ( cl_useMumble -> integer ) { Com_Printf ( ""OpenAL<S2SV_blank>capture<S2SV_blank>support<S2SV_blank>disabled<S2SV_blank>for<S2SV_blank>Mumble<S2SV_blank>support\\n"" ) ; } # endif else { # ifdef __APPLE__ if ( qalcCaptureOpenDevice == NULL ) # else if ( ! qalcIsExtensionPresent ( NULL , ""ALC_EXT_capture"" ) ) # endif { Com_Printf ( ""No<S2SV_blank>ALC_EXT_capture<S2SV_blank>support,<S2SV_blank>can\'t<S2SV_blank>record<S2SV_blank>audio.\\n"" ) ; } else { char inputdevicenames [ 16384 ] = """" ; const char * inputdevicelist ; const char * defaultinputdevice ; int curlen ; capture_ext = qtrue ; inputdevicelist = qalcGetString ( NULL , ALC_CAPTURE_DEVICE_SPECIFIER ) ; defaultinputdevice = qalcGetString ( NULL , ALC_CAPTURE_DEFAULT_DEVICE_SPECIFIER ) ; if ( inputdevicelist ) { while ( ( curlen = strlen ( inputdevicelist ) ) ) { Q_strcat ( inputdevicenames , sizeof ( inputdevicenames ) , inputdevicelist ) ; Q_strcat ( inputdevicenames , sizeof ( inputdevicenames ) , ""\\n"" ) ; inputdevicelist += curlen + 1 ; } } s_alAvailableInputDevices = Cvar_Get ( ""s_alAvailableInputDevices"" , inputdevicenames , CVAR_ROM | CVAR_NORESTART ) ; Com_Printf ( ""OpenAL<S2SV_blank>default<S2SV_blank>capture<S2SV_blank>device<S2SV_blank>is<S2SV_blank>\'%s\'\\n"" , defaultinputdevice ? defaultinputdevice : ""none"" ) ; alCaptureDevice = qalcCaptureOpenDevice ( inputdevice , 48000 , AL_FORMAT_MONO16 , VOIP_MAX_PACKET_SAMPLES * 4 ) ; if ( ! alCaptureDevice && inputdevice ) { Com_Printf ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>OpenAL<S2SV_blank>Input<S2SV_blank>device<S2SV_blank>\'%s\',<S2SV_blank>trying<S2SV_blank>default.\\n"" , inputdevice ) ; alCaptureDevice = qalcCaptureOpenDevice ( NULL , 48000 , AL_FORMAT_MONO16 , VOIP_MAX_PACKET_SAMPLES * 4 ) ; } Com_Printf ( ""OpenAL<S2SV_blank>capture<S2SV_blank>device<S2SV_blank>%s.\\n"" , ( alCaptureDevice == NULL ) ? ""failed<S2SV_blank>to<S2SV_blank>open"" : ""opened"" ) ; } } # endif si -> Shutdown = S_AL_Shutdown ; si -> StartSound = S_AL_StartSound ; si -> StartSoundEx = S_AL_StartSoundEx ; si -> StartLocalSound = S_AL_StartLocalSound ; si -> StartBackgroundTrack = S_AL_StartBackgroundTrack ; si -> StopBackgroundTrack = S_AL_StopBackgroundTrack ; si -> StartStreamingSound = S_AL_StartStreamingSound ; si -> GetVoiceAmplitude = S_AL_GetVoiceAmplitude ; si -> RawSamples = S_AL_RawSamples ; si -> StopAllSounds = S_AL_StopAllSounds ; si -> ClearLoopingSounds = S_AL_ClearLoopingSounds ; si -> AddLoopingSound = S_AL_AddLoopingSound ; si -> AddRealLoopingSound = S_AL_AddRealLoopingSound ; si -> StopLoopingSound = S_AL_StopLoopingSound ; si -> Respatialize = S_AL_Respatialize ; si -> UpdateEntityPosition = S_AL_UpdateEntityPosition ; si -> Update = S_AL_Update ; si -> DisableSounds = S_AL_DisableSounds ; si -> BeginRegistration = S_AL_BeginRegistration ; si -> RegisterSound = S_AL_RegisterSound ; si -> ClearSoundBuffer = S_AL_ClearSoundBuffer ; si -> SoundInfo = S_AL_SoundInfo ; si -> SoundList = S_AL_SoundList ; # ifdef USE_VOIP si -> StartCapture = S_AL_StartCapture ; si -> AvailableCaptureSamples = S_AL_AvailableCaptureSamples ; si -> Capture = S_AL_Capture ; si -> StopCapture = S_AL_StopCapture ; si -> MasterGain = S_AL_MasterGain ; # endif return qtrue ; # else return qfalse ; # endif }","s_alDriver = Cvar_Get ( ""s_alDriver"" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED ) ;s_alInputDevice = Cvar_Get ( ""s_alInputDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ;if ( COM_CompareExtension ( s_alDriver -> string , "".pk3"" ) ) {Com_Printf ( ""Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\\\""%s\\\\"""" , s_alDriver -> string ) ;return qfalse ;}s_alDevice = Cvar_Get ( ""s_alDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ;if ( ! QAL_Init ( s_alDriver -> string ) ) {",165
232,"buggy line: bool is_drop_n_account = false ;BUILD_BUG_ON ( TPACKET_ALIGN ( sizeof ( * h . h2 ) ) != 32 ) ;if ( skb -> pkt_type == PACKET_LOOPBACK ) goto drop ;sk = pt -> af_packet_priv ;po = pkt_sk ( sk ) ;if ( ! net_eq ( dev_net ( dev ) , sock_net ( sk ) ) ) goto drop ;if ( dev -> header_ops ) {cwe id:CWE-119context: static int tpacket_rcv ( struct sk_buff * skb , struct net_device * dev , struct packet_type * pt , struct net_device * orig_dev ) { struct sock * sk ; struct packet_sock * po ; struct sockaddr_ll * sll ; union tpacket_uhdr h ; u8 * skb_head = skb -> data ; int skb_len = skb -> len ; unsigned int snaplen , res ; unsigned long status = TP_STATUS_USER ; unsigned short macoff , netoff , hdrlen ; struct sk_buff * copy_skb = NULL ; struct timespec ts ; __u32 ts_status ;  bool is_drop_n_account = false ;  BUILD_BUG_ON ( TPACKET_ALIGN ( sizeof ( * h . h2 ) ) != 32 ) ; BUILD_BUG_ON ( TPACKET_ALIGN ( sizeof ( * h . h3 ) ) != 48 ) ; if ( skb -> pkt_type == PACKET_LOOPBACK ) goto drop ; sk = pt -> af_packet_priv ; po = pkt_sk ( sk ) ; if ( ! net_eq ( dev_net ( dev ) , sock_net ( sk ) ) ) goto drop ; if ( dev -> header_ops ) { if ( sk -> sk_type != SOCK_DGRAM ) skb_push ( skb , skb -> data - skb_mac_header ( skb ) ) ; else if ( skb -> pkt_type == PACKET_OUTGOING ) { skb_pull ( skb , skb_network_offset ( skb ) ) ; } } snaplen = skb -> len ; res = run_filter ( skb , sk , snaplen ) ; if ( ! res ) goto drop_n_restore ; if ( skb -> ip_summed == CHECKSUM_PARTIAL ) status |= TP_STATUS_CSUMNOTREADY ; else if ( skb -> pkt_type != PACKET_OUTGOING && ( skb -> ip_summed == CHECKSUM_COMPLETE || skb_csum_unnecessary ( skb ) ) ) status |= TP_STATUS_CSUM_VALID ; if ( snaplen > res ) snaplen = res ; if ( sk -> sk_type == SOCK_DGRAM ) { macoff = netoff = TPACKET_ALIGN ( po -> tp_hdrlen ) + 16 + po -> tp_reserve ; } else { unsigned int maclen = skb_network_offset ( skb ) ; netoff = TPACKET_ALIGN ( po -> tp_hdrlen + ( maclen < 16 ? 16 : maclen ) ) + po -> tp_reserve ;  if ( po -> has_vnet_hdr )  netoff += sizeof ( struct virtio_net_hdr ) ;  macoff = netoff - maclen ;  } if ( po -> tp_version <= TPACKET_V2 ) { if ( macoff + snaplen > po -> rx_ring . frame_size ) { if ( po -> copy_thresh && atomic_read ( & sk -> sk_rmem_alloc ) < sk -> sk_rcvbuf ) { if ( skb_shared ( skb ) ) { copy_skb = skb_clone ( skb , GFP_ATOMIC ) ; } else { copy_skb = skb_get ( skb ) ; skb_head = skb -> data ; } if ( copy_skb ) skb_set_owner_r ( copy_skb , sk ) ; } snaplen = po -> rx_ring . frame_size - macoff ;  if ( ( int ) snaplen < 0 )   snaplen = 0 ;  } } else if ( unlikely ( macoff + snaplen > GET_PBDQC_FROM_RB ( & po -> rx_ring ) -> max_frame_len ) ) { u32 nval ; nval = GET_PBDQC_FROM_RB ( & po -> rx_ring ) -> max_frame_len - macoff ; pr_err_once ( ""tpacket_rcv:<S2SV_blank>packet<S2SV_blank>too<S2SV_blank>big,<S2SV_blank>clamped<S2SV_blank>from<S2SV_blank>%u<S2SV_blank>to<S2SV_blank>%u.<S2SV_blank>macoff=%u\\n"" , snaplen , nval , macoff ) ; snaplen = nval ; if ( unlikely ( ( int ) snaplen < 0 ) ) { snaplen = 0 ; macoff = GET_PBDQC_FROM_RB ( & po -> rx_ring ) -> max_frame_len ;  }  } spin_lock ( & sk -> sk_receive_queue . lock ) ; h . raw = packet_current_rx_frame ( po , skb , TP_STATUS_KERNEL , ( macoff + snaplen ) ) ; if ( ! h . raw ) goto drop_n_account ; if ( po -> tp_version <= TPACKET_V2 ) { packet_increment_rx_head ( po , & po -> rx_ring ) ; if ( po -> stats . stats1 . tp_drops ) status |= TP_STATUS_LOSING ; } po -> stats . stats1 . tp_packets ++ ; if ( copy_skb ) { status |= TP_STATUS_COPY ; __skb_queue_tail ( & sk -> sk_receive_queue , copy_skb ) ; } spin_unlock ( & sk -> sk_receive_queue . lock ) ;  if ( po -> has_vnet_hdr ) {  if ( virtio_net_hdr_from_skb ( skb , h . raw + macoff - sizeof ( struct virtio_net_hdr ) , vio_le ( ) , true ) ) { spin_lock ( & sk -> sk_receive_queue . lock ) ; goto drop_n_account ; } } skb_copy_bits ( skb , 0 , h . raw + macoff , snaplen ) ; if ( ! ( ts_status = tpacket_get_timestamp ( skb , & ts , po -> tp_tstamp ) ) ) getnstimeofday ( & ts ) ; status |= ts_status ; switch ( po -> tp_version ) { case TPACKET_V1 : h . h1 -> tp_len = skb -> len ; h . h1 -> tp_snaplen = snaplen ; h . h1 -> tp_mac = macoff ; h . h1 -> tp_net = netoff ; h . h1 -> tp_sec = ts . tv_sec ; h . h1 -> tp_usec = ts . tv_nsec / NSEC_PER_USEC ; hdrlen = sizeof ( * h . h1 ) ; break ; case TPACKET_V2 : h . h2 -> tp_len = skb -> len ; h . h2 -> tp_snaplen = snaplen ; h . h2 -> tp_mac = macoff ; h . h2 -> tp_net = netoff ; h . h2 -> tp_sec = ts . tv_sec ; h . h2 -> tp_nsec = ts . tv_nsec ; if ( skb_vlan_tag_present ( skb ) ) { h . h2 -> tp_vlan_tci = skb_vlan_tag_get ( skb ) ; h . h2 -> tp_vlan_tpid = ntohs ( skb -> vlan_proto ) ; status |= TP_STATUS_VLAN_VALID | TP_STATUS_VLAN_TPID_VALID ; } else { h . h2 -> tp_vlan_tci = 0 ; h . h2 -> tp_vlan_tpid = 0 ; } memset ( h . h2 -> tp_padding , 0 , sizeof ( h . h2 -> tp_padding ) ) ; hdrlen = sizeof ( * h . h2 ) ; break ; case TPACKET_V3 : h . h3 -> tp_status |= status ; h . h3 -> tp_len = skb -> len ; h . h3 -> tp_snaplen = snaplen ; h . h3 -> tp_mac = macoff ; h . h3 -> tp_net = netoff ; h . h3 -> tp_sec = ts . tv_sec ; h . h3 -> tp_nsec = ts . tv_nsec ; memset ( h . h3 -> tp_padding , 0 , sizeof ( h . h3 -> tp_padding ) ) ; hdrlen = sizeof ( * h . h3 ) ; break ; default : BUG ( ) ; } sll = h . raw + TPACKET_ALIGN ( hdrlen ) ; sll -> sll_halen = dev_parse_header ( skb , sll -> sll_addr ) ; sll -> sll_family = AF_PACKET ; sll -> sll_hatype = dev -> type ; sll -> sll_protocol = skb -> protocol ; sll -> sll_pkttype = skb -> pkt_type ; if ( unlikely ( po -> origdev ) ) sll -> sll_ifindex = orig_dev -> ifindex ; else sll -> sll_ifindex = dev -> ifindex ; smp_mb ( ) ; # if ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE == 1 if ( po -> tp_version <= TPACKET_V2 ) { u8 * start , * end ; end = ( u8 * ) PAGE_ALIGN ( ( unsigned long ) h . raw + macoff + snaplen ) ; for ( start = h . raw ; start < end ; start += PAGE_SIZE ) flush_dcache_page ( pgv_to_page ( start ) ) ; } smp_wmb ( ) ; # endif if ( po -> tp_version <= TPACKET_V2 ) { __packet_set_status ( po , h . raw , status ) ; sk -> sk_data_ready ( sk ) ; } else { prb_clear_blk_fill_status ( & po -> rx_ring ) ; } drop_n_restore : if ( skb_head != skb -> data && skb_shared ( skb ) ) { skb -> data = skb_head ; skb -> len = skb_len ; } drop : if ( ! is_drop_n_account ) consume_skb ( skb ) ; else kfree_skb ( skb ) ; return 0 ; drop_n_account : is_drop_n_account = true ; po -> stats . stats1 . tp_drops ++ ; spin_unlock ( & sk -> sk_receive_queue . lock ) ; sk -> sk_data_ready ( sk ) ; kfree_skb ( copy_skb ) ; goto drop_n_restore ; }",bool is_drop_n_account = false ;bool do_vnet = false ;BUILD_BUG_ON ( TPACKET_ALIGN ( sizeof ( * h . h2 ) ) != 32 ) ;if ( do_vnet ) {,166
233,"buggy line: if ( po -> has_vnet_hdr )  netoff += sizeof ( struct virtio_net_hdr ) ;macoff = netoff - maclen ;}cwe id:CWE-119context: static int tpacket_rcv ( struct sk_buff * skb , struct net_device * dev , struct packet_type * pt , struct net_device * orig_dev ) { struct sock * sk ; struct packet_sock * po ; struct sockaddr_ll * sll ; union tpacket_uhdr h ; u8 * skb_head = skb -> data ; int skb_len = skb -> len ; unsigned int snaplen , res ; unsigned long status = TP_STATUS_USER ; unsigned short macoff , netoff , hdrlen ; struct sk_buff * copy_skb = NULL ; struct timespec ts ; __u32 ts_status ;  bool is_drop_n_account = false ;  BUILD_BUG_ON ( TPACKET_ALIGN ( sizeof ( * h . h2 ) ) != 32 ) ; BUILD_BUG_ON ( TPACKET_ALIGN ( sizeof ( * h . h3 ) ) != 48 ) ; if ( skb -> pkt_type == PACKET_LOOPBACK ) goto drop ; sk = pt -> af_packet_priv ; po = pkt_sk ( sk ) ; if ( ! net_eq ( dev_net ( dev ) , sock_net ( sk ) ) ) goto drop ; if ( dev -> header_ops ) { if ( sk -> sk_type != SOCK_DGRAM ) skb_push ( skb , skb -> data - skb_mac_header ( skb ) ) ; else if ( skb -> pkt_type == PACKET_OUTGOING ) { skb_pull ( skb , skb_network_offset ( skb ) ) ; } } snaplen = skb -> len ; res = run_filter ( skb , sk , snaplen ) ; if ( ! res ) goto drop_n_restore ; if ( skb -> ip_summed == CHECKSUM_PARTIAL ) status |= TP_STATUS_CSUMNOTREADY ; else if ( skb -> pkt_type != PACKET_OUTGOING && ( skb -> ip_summed == CHECKSUM_COMPLETE || skb_csum_unnecessary ( skb ) ) ) status |= TP_STATUS_CSUM_VALID ; if ( snaplen > res ) snaplen = res ; if ( sk -> sk_type == SOCK_DGRAM ) { macoff = netoff = TPACKET_ALIGN ( po -> tp_hdrlen ) + 16 + po -> tp_reserve ; } else { unsigned int maclen = skb_network_offset ( skb ) ; netoff = TPACKET_ALIGN ( po -> tp_hdrlen + ( maclen < 16 ? 16 : maclen ) ) + po -> tp_reserve ;  if ( po -> has_vnet_hdr )  netoff += sizeof ( struct virtio_net_hdr ) ;  macoff = netoff - maclen ;  } if ( po -> tp_version <= TPACKET_V2 ) { if ( macoff + snaplen > po -> rx_ring . frame_size ) { if ( po -> copy_thresh && atomic_read ( & sk -> sk_rmem_alloc ) < sk -> sk_rcvbuf ) { if ( skb_shared ( skb ) ) { copy_skb = skb_clone ( skb , GFP_ATOMIC ) ; } else { copy_skb = skb_get ( skb ) ; skb_head = skb -> data ; } if ( copy_skb ) skb_set_owner_r ( copy_skb , sk ) ; } snaplen = po -> rx_ring . frame_size - macoff ;  if ( ( int ) snaplen < 0 )   snaplen = 0 ;  } } else if ( unlikely ( macoff + snaplen > GET_PBDQC_FROM_RB ( & po -> rx_ring ) -> max_frame_len ) ) { u32 nval ; nval = GET_PBDQC_FROM_RB ( & po -> rx_ring ) -> max_frame_len - macoff ; pr_err_once ( ""tpacket_rcv:<S2SV_blank>packet<S2SV_blank>too<S2SV_blank>big,<S2SV_blank>clamped<S2SV_blank>from<S2SV_blank>%u<S2SV_blank>to<S2SV_blank>%u.<S2SV_blank>macoff=%u\\n"" , snaplen , nval , macoff ) ; snaplen = nval ; if ( unlikely ( ( int ) snaplen < 0 ) ) { snaplen = 0 ; macoff = GET_PBDQC_FROM_RB ( & po -> rx_ring ) -> max_frame_len ;  }  } spin_lock ( & sk -> sk_receive_queue . lock ) ; h . raw = packet_current_rx_frame ( po , skb , TP_STATUS_KERNEL , ( macoff + snaplen ) ) ; if ( ! h . raw ) goto drop_n_account ; if ( po -> tp_version <= TPACKET_V2 ) { packet_increment_rx_head ( po , & po -> rx_ring ) ; if ( po -> stats . stats1 . tp_drops ) status |= TP_STATUS_LOSING ; } po -> stats . stats1 . tp_packets ++ ; if ( copy_skb ) { status |= TP_STATUS_COPY ; __skb_queue_tail ( & sk -> sk_receive_queue , copy_skb ) ; } spin_unlock ( & sk -> sk_receive_queue . lock ) ;  if ( po -> has_vnet_hdr ) {  if ( virtio_net_hdr_from_skb ( skb , h . raw + macoff - sizeof ( struct virtio_net_hdr ) , vio_le ( ) , true ) ) { spin_lock ( & sk -> sk_receive_queue . lock ) ; goto drop_n_account ; } } skb_copy_bits ( skb , 0 , h . raw + macoff , snaplen ) ; if ( ! ( ts_status = tpacket_get_timestamp ( skb , & ts , po -> tp_tstamp ) ) ) getnstimeofday ( & ts ) ; status |= ts_status ; switch ( po -> tp_version ) { case TPACKET_V1 : h . h1 -> tp_len = skb -> len ; h . h1 -> tp_snaplen = snaplen ; h . h1 -> tp_mac = macoff ; h . h1 -> tp_net = netoff ; h . h1 -> tp_sec = ts . tv_sec ; h . h1 -> tp_usec = ts . tv_nsec / NSEC_PER_USEC ; hdrlen = sizeof ( * h . h1 ) ; break ; case TPACKET_V2 : h . h2 -> tp_len = skb -> len ; h . h2 -> tp_snaplen = snaplen ; h . h2 -> tp_mac = macoff ; h . h2 -> tp_net = netoff ; h . h2 -> tp_sec = ts . tv_sec ; h . h2 -> tp_nsec = ts . tv_nsec ; if ( skb_vlan_tag_present ( skb ) ) { h . h2 -> tp_vlan_tci = skb_vlan_tag_get ( skb ) ; h . h2 -> tp_vlan_tpid = ntohs ( skb -> vlan_proto ) ; status |= TP_STATUS_VLAN_VALID | TP_STATUS_VLAN_TPID_VALID ; } else { h . h2 -> tp_vlan_tci = 0 ; h . h2 -> tp_vlan_tpid = 0 ; } memset ( h . h2 -> tp_padding , 0 , sizeof ( h . h2 -> tp_padding ) ) ; hdrlen = sizeof ( * h . h2 ) ; break ; case TPACKET_V3 : h . h3 -> tp_status |= status ; h . h3 -> tp_len = skb -> len ; h . h3 -> tp_snaplen = snaplen ; h . h3 -> tp_mac = macoff ; h . h3 -> tp_net = netoff ; h . h3 -> tp_sec = ts . tv_sec ; h . h3 -> tp_nsec = ts . tv_nsec ; memset ( h . h3 -> tp_padding , 0 , sizeof ( h . h3 -> tp_padding ) ) ; hdrlen = sizeof ( * h . h3 ) ; break ; default : BUG ( ) ; } sll = h . raw + TPACKET_ALIGN ( hdrlen ) ; sll -> sll_halen = dev_parse_header ( skb , sll -> sll_addr ) ; sll -> sll_family = AF_PACKET ; sll -> sll_hatype = dev -> type ; sll -> sll_protocol = skb -> protocol ; sll -> sll_pkttype = skb -> pkt_type ; if ( unlikely ( po -> origdev ) ) sll -> sll_ifindex = orig_dev -> ifindex ; else sll -> sll_ifindex = dev -> ifindex ; smp_mb ( ) ; # if ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE == 1 if ( po -> tp_version <= TPACKET_V2 ) { u8 * start , * end ; end = ( u8 * ) PAGE_ALIGN ( ( unsigned long ) h . raw + macoff + snaplen ) ; for ( start = h . raw ; start < end ; start += PAGE_SIZE ) flush_dcache_page ( pgv_to_page ( start ) ) ; } smp_wmb ( ) ; # endif if ( po -> tp_version <= TPACKET_V2 ) { __packet_set_status ( po , h . raw , status ) ; sk -> sk_data_ready ( sk ) ; } else { prb_clear_blk_fill_status ( & po -> rx_ring ) ; } drop_n_restore : if ( skb_head != skb -> data && skb_shared ( skb ) ) { skb -> data = skb_head ; skb -> len = skb_len ; } drop : if ( ! is_drop_n_account ) consume_skb ( skb ) ; else kfree_skb ( skb ) ; return 0 ; drop_n_account : is_drop_n_account = true ; po -> stats . stats1 . tp_drops ++ ; spin_unlock ( & sk -> sk_receive_queue . lock ) ; sk -> sk_data_ready ( sk ) ; kfree_skb ( copy_skb ) ; goto drop_n_restore ; }",if ( po -> has_vnet_hdr ) {netoff += sizeof ( struct virtio_net_hdr ) ;do_vnet = true ;}macoff = netoff - maclen ;},166
234,"buggy line: if ( ( int ) snaplen < 0 )   snaplen = 0 ;}cwe id:CWE-119context: static int tpacket_rcv ( struct sk_buff * skb , struct net_device * dev , struct packet_type * pt , struct net_device * orig_dev ) { struct sock * sk ; struct packet_sock * po ; struct sockaddr_ll * sll ; union tpacket_uhdr h ; u8 * skb_head = skb -> data ; int skb_len = skb -> len ; unsigned int snaplen , res ; unsigned long status = TP_STATUS_USER ; unsigned short macoff , netoff , hdrlen ; struct sk_buff * copy_skb = NULL ; struct timespec ts ; __u32 ts_status ;  bool is_drop_n_account = false ;  BUILD_BUG_ON ( TPACKET_ALIGN ( sizeof ( * h . h2 ) ) != 32 ) ; BUILD_BUG_ON ( TPACKET_ALIGN ( sizeof ( * h . h3 ) ) != 48 ) ; if ( skb -> pkt_type == PACKET_LOOPBACK ) goto drop ; sk = pt -> af_packet_priv ; po = pkt_sk ( sk ) ; if ( ! net_eq ( dev_net ( dev ) , sock_net ( sk ) ) ) goto drop ; if ( dev -> header_ops ) { if ( sk -> sk_type != SOCK_DGRAM ) skb_push ( skb , skb -> data - skb_mac_header ( skb ) ) ; else if ( skb -> pkt_type == PACKET_OUTGOING ) { skb_pull ( skb , skb_network_offset ( skb ) ) ; } } snaplen = skb -> len ; res = run_filter ( skb , sk , snaplen ) ; if ( ! res ) goto drop_n_restore ; if ( skb -> ip_summed == CHECKSUM_PARTIAL ) status |= TP_STATUS_CSUMNOTREADY ; else if ( skb -> pkt_type != PACKET_OUTGOING && ( skb -> ip_summed == CHECKSUM_COMPLETE || skb_csum_unnecessary ( skb ) ) ) status |= TP_STATUS_CSUM_VALID ; if ( snaplen > res ) snaplen = res ; if ( sk -> sk_type == SOCK_DGRAM ) { macoff = netoff = TPACKET_ALIGN ( po -> tp_hdrlen ) + 16 + po -> tp_reserve ; } else { unsigned int maclen = skb_network_offset ( skb ) ; netoff = TPACKET_ALIGN ( po -> tp_hdrlen + ( maclen < 16 ? 16 : maclen ) ) + po -> tp_reserve ;  if ( po -> has_vnet_hdr )  netoff += sizeof ( struct virtio_net_hdr ) ;  macoff = netoff - maclen ;  } if ( po -> tp_version <= TPACKET_V2 ) { if ( macoff + snaplen > po -> rx_ring . frame_size ) { if ( po -> copy_thresh && atomic_read ( & sk -> sk_rmem_alloc ) < sk -> sk_rcvbuf ) { if ( skb_shared ( skb ) ) { copy_skb = skb_clone ( skb , GFP_ATOMIC ) ; } else { copy_skb = skb_get ( skb ) ; skb_head = skb -> data ; } if ( copy_skb ) skb_set_owner_r ( copy_skb , sk ) ; } snaplen = po -> rx_ring . frame_size - macoff ;  if ( ( int ) snaplen < 0 )   snaplen = 0 ;  } } else if ( unlikely ( macoff + snaplen > GET_PBDQC_FROM_RB ( & po -> rx_ring ) -> max_frame_len ) ) { u32 nval ; nval = GET_PBDQC_FROM_RB ( & po -> rx_ring ) -> max_frame_len - macoff ; pr_err_once ( ""tpacket_rcv:<S2SV_blank>packet<S2SV_blank>too<S2SV_blank>big,<S2SV_blank>clamped<S2SV_blank>from<S2SV_blank>%u<S2SV_blank>to<S2SV_blank>%u.<S2SV_blank>macoff=%u\\n"" , snaplen , nval , macoff ) ; snaplen = nval ; if ( unlikely ( ( int ) snaplen < 0 ) ) { snaplen = 0 ; macoff = GET_PBDQC_FROM_RB ( & po -> rx_ring ) -> max_frame_len ;  }  } spin_lock ( & sk -> sk_receive_queue . lock ) ; h . raw = packet_current_rx_frame ( po , skb , TP_STATUS_KERNEL , ( macoff + snaplen ) ) ; if ( ! h . raw ) goto drop_n_account ; if ( po -> tp_version <= TPACKET_V2 ) { packet_increment_rx_head ( po , & po -> rx_ring ) ; if ( po -> stats . stats1 . tp_drops ) status |= TP_STATUS_LOSING ; } po -> stats . stats1 . tp_packets ++ ; if ( copy_skb ) { status |= TP_STATUS_COPY ; __skb_queue_tail ( & sk -> sk_receive_queue , copy_skb ) ; } spin_unlock ( & sk -> sk_receive_queue . lock ) ;  if ( po -> has_vnet_hdr ) {  if ( virtio_net_hdr_from_skb ( skb , h . raw + macoff - sizeof ( struct virtio_net_hdr ) , vio_le ( ) , true ) ) { spin_lock ( & sk -> sk_receive_queue . lock ) ; goto drop_n_account ; } } skb_copy_bits ( skb , 0 , h . raw + macoff , snaplen ) ; if ( ! ( ts_status = tpacket_get_timestamp ( skb , & ts , po -> tp_tstamp ) ) ) getnstimeofday ( & ts ) ; status |= ts_status ; switch ( po -> tp_version ) { case TPACKET_V1 : h . h1 -> tp_len = skb -> len ; h . h1 -> tp_snaplen = snaplen ; h . h1 -> tp_mac = macoff ; h . h1 -> tp_net = netoff ; h . h1 -> tp_sec = ts . tv_sec ; h . h1 -> tp_usec = ts . tv_nsec / NSEC_PER_USEC ; hdrlen = sizeof ( * h . h1 ) ; break ; case TPACKET_V2 : h . h2 -> tp_len = skb -> len ; h . h2 -> tp_snaplen = snaplen ; h . h2 -> tp_mac = macoff ; h . h2 -> tp_net = netoff ; h . h2 -> tp_sec = ts . tv_sec ; h . h2 -> tp_nsec = ts . tv_nsec ; if ( skb_vlan_tag_present ( skb ) ) { h . h2 -> tp_vlan_tci = skb_vlan_tag_get ( skb ) ; h . h2 -> tp_vlan_tpid = ntohs ( skb -> vlan_proto ) ; status |= TP_STATUS_VLAN_VALID | TP_STATUS_VLAN_TPID_VALID ; } else { h . h2 -> tp_vlan_tci = 0 ; h . h2 -> tp_vlan_tpid = 0 ; } memset ( h . h2 -> tp_padding , 0 , sizeof ( h . h2 -> tp_padding ) ) ; hdrlen = sizeof ( * h . h2 ) ; break ; case TPACKET_V3 : h . h3 -> tp_status |= status ; h . h3 -> tp_len = skb -> len ; h . h3 -> tp_snaplen = snaplen ; h . h3 -> tp_mac = macoff ; h . h3 -> tp_net = netoff ; h . h3 -> tp_sec = ts . tv_sec ; h . h3 -> tp_nsec = ts . tv_nsec ; memset ( h . h3 -> tp_padding , 0 , sizeof ( h . h3 -> tp_padding ) ) ; hdrlen = sizeof ( * h . h3 ) ; break ; default : BUG ( ) ; } sll = h . raw + TPACKET_ALIGN ( hdrlen ) ; sll -> sll_halen = dev_parse_header ( skb , sll -> sll_addr ) ; sll -> sll_family = AF_PACKET ; sll -> sll_hatype = dev -> type ; sll -> sll_protocol = skb -> protocol ; sll -> sll_pkttype = skb -> pkt_type ; if ( unlikely ( po -> origdev ) ) sll -> sll_ifindex = orig_dev -> ifindex ; else sll -> sll_ifindex = dev -> ifindex ; smp_mb ( ) ; # if ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE == 1 if ( po -> tp_version <= TPACKET_V2 ) { u8 * start , * end ; end = ( u8 * ) PAGE_ALIGN ( ( unsigned long ) h . raw + macoff + snaplen ) ; for ( start = h . raw ; start < end ; start += PAGE_SIZE ) flush_dcache_page ( pgv_to_page ( start ) ) ; } smp_wmb ( ) ; # endif if ( po -> tp_version <= TPACKET_V2 ) { __packet_set_status ( po , h . raw , status ) ; sk -> sk_data_ready ( sk ) ; } else { prb_clear_blk_fill_status ( & po -> rx_ring ) ; } drop_n_restore : if ( skb_head != skb -> data && skb_shared ( skb ) ) { skb -> data = skb_head ; skb -> len = skb_len ; } drop : if ( ! is_drop_n_account ) consume_skb ( skb ) ; else kfree_skb ( skb ) ; return 0 ; drop_n_account : is_drop_n_account = true ; po -> stats . stats1 . tp_drops ++ ; spin_unlock ( & sk -> sk_receive_queue . lock ) ; sk -> sk_data_ready ( sk ) ; kfree_skb ( copy_skb ) ; goto drop_n_restore ; }",if ( ( int ) snaplen < 0 ) {snaplen = 0 ;do_vnet = false ;}},166
235,"buggy line: }}cwe id:CWE-119context: static int tpacket_rcv ( struct sk_buff * skb , struct net_device * dev , struct packet_type * pt , struct net_device * orig_dev ) { struct sock * sk ; struct packet_sock * po ; struct sockaddr_ll * sll ; union tpacket_uhdr h ; u8 * skb_head = skb -> data ; int skb_len = skb -> len ; unsigned int snaplen , res ; unsigned long status = TP_STATUS_USER ; unsigned short macoff , netoff , hdrlen ; struct sk_buff * copy_skb = NULL ; struct timespec ts ; __u32 ts_status ;  bool is_drop_n_account = false ;  BUILD_BUG_ON ( TPACKET_ALIGN ( sizeof ( * h . h2 ) ) != 32 ) ; BUILD_BUG_ON ( TPACKET_ALIGN ( sizeof ( * h . h3 ) ) != 48 ) ; if ( skb -> pkt_type == PACKET_LOOPBACK ) goto drop ; sk = pt -> af_packet_priv ; po = pkt_sk ( sk ) ; if ( ! net_eq ( dev_net ( dev ) , sock_net ( sk ) ) ) goto drop ; if ( dev -> header_ops ) { if ( sk -> sk_type != SOCK_DGRAM ) skb_push ( skb , skb -> data - skb_mac_header ( skb ) ) ; else if ( skb -> pkt_type == PACKET_OUTGOING ) { skb_pull ( skb , skb_network_offset ( skb ) ) ; } } snaplen = skb -> len ; res = run_filter ( skb , sk , snaplen ) ; if ( ! res ) goto drop_n_restore ; if ( skb -> ip_summed == CHECKSUM_PARTIAL ) status |= TP_STATUS_CSUMNOTREADY ; else if ( skb -> pkt_type != PACKET_OUTGOING && ( skb -> ip_summed == CHECKSUM_COMPLETE || skb_csum_unnecessary ( skb ) ) ) status |= TP_STATUS_CSUM_VALID ; if ( snaplen > res ) snaplen = res ; if ( sk -> sk_type == SOCK_DGRAM ) { macoff = netoff = TPACKET_ALIGN ( po -> tp_hdrlen ) + 16 + po -> tp_reserve ; } else { unsigned int maclen = skb_network_offset ( skb ) ; netoff = TPACKET_ALIGN ( po -> tp_hdrlen + ( maclen < 16 ? 16 : maclen ) ) + po -> tp_reserve ;  if ( po -> has_vnet_hdr )  netoff += sizeof ( struct virtio_net_hdr ) ;  macoff = netoff - maclen ;  } if ( po -> tp_version <= TPACKET_V2 ) { if ( macoff + snaplen > po -> rx_ring . frame_size ) { if ( po -> copy_thresh && atomic_read ( & sk -> sk_rmem_alloc ) < sk -> sk_rcvbuf ) { if ( skb_shared ( skb ) ) { copy_skb = skb_clone ( skb , GFP_ATOMIC ) ; } else { copy_skb = skb_get ( skb ) ; skb_head = skb -> data ; } if ( copy_skb ) skb_set_owner_r ( copy_skb , sk ) ; } snaplen = po -> rx_ring . frame_size - macoff ;  if ( ( int ) snaplen < 0 )   snaplen = 0 ;  } } else if ( unlikely ( macoff + snaplen > GET_PBDQC_FROM_RB ( & po -> rx_ring ) -> max_frame_len ) ) { u32 nval ; nval = GET_PBDQC_FROM_RB ( & po -> rx_ring ) -> max_frame_len - macoff ; pr_err_once ( ""tpacket_rcv:<S2SV_blank>packet<S2SV_blank>too<S2SV_blank>big,<S2SV_blank>clamped<S2SV_blank>from<S2SV_blank>%u<S2SV_blank>to<S2SV_blank>%u.<S2SV_blank>macoff=%u\\n"" , snaplen , nval , macoff ) ; snaplen = nval ; if ( unlikely ( ( int ) snaplen < 0 ) ) { snaplen = 0 ; macoff = GET_PBDQC_FROM_RB ( & po -> rx_ring ) -> max_frame_len ;  }  } spin_lock ( & sk -> sk_receive_queue . lock ) ; h . raw = packet_current_rx_frame ( po , skb , TP_STATUS_KERNEL , ( macoff + snaplen ) ) ; if ( ! h . raw ) goto drop_n_account ; if ( po -> tp_version <= TPACKET_V2 ) { packet_increment_rx_head ( po , & po -> rx_ring ) ; if ( po -> stats . stats1 . tp_drops ) status |= TP_STATUS_LOSING ; } po -> stats . stats1 . tp_packets ++ ; if ( copy_skb ) { status |= TP_STATUS_COPY ; __skb_queue_tail ( & sk -> sk_receive_queue , copy_skb ) ; } spin_unlock ( & sk -> sk_receive_queue . lock ) ;  if ( po -> has_vnet_hdr ) {  if ( virtio_net_hdr_from_skb ( skb , h . raw + macoff - sizeof ( struct virtio_net_hdr ) , vio_le ( ) , true ) ) { spin_lock ( & sk -> sk_receive_queue . lock ) ; goto drop_n_account ; } } skb_copy_bits ( skb , 0 , h . raw + macoff , snaplen ) ; if ( ! ( ts_status = tpacket_get_timestamp ( skb , & ts , po -> tp_tstamp ) ) ) getnstimeofday ( & ts ) ; status |= ts_status ; switch ( po -> tp_version ) { case TPACKET_V1 : h . h1 -> tp_len = skb -> len ; h . h1 -> tp_snaplen = snaplen ; h . h1 -> tp_mac = macoff ; h . h1 -> tp_net = netoff ; h . h1 -> tp_sec = ts . tv_sec ; h . h1 -> tp_usec = ts . tv_nsec / NSEC_PER_USEC ; hdrlen = sizeof ( * h . h1 ) ; break ; case TPACKET_V2 : h . h2 -> tp_len = skb -> len ; h . h2 -> tp_snaplen = snaplen ; h . h2 -> tp_mac = macoff ; h . h2 -> tp_net = netoff ; h . h2 -> tp_sec = ts . tv_sec ; h . h2 -> tp_nsec = ts . tv_nsec ; if ( skb_vlan_tag_present ( skb ) ) { h . h2 -> tp_vlan_tci = skb_vlan_tag_get ( skb ) ; h . h2 -> tp_vlan_tpid = ntohs ( skb -> vlan_proto ) ; status |= TP_STATUS_VLAN_VALID | TP_STATUS_VLAN_TPID_VALID ; } else { h . h2 -> tp_vlan_tci = 0 ; h . h2 -> tp_vlan_tpid = 0 ; } memset ( h . h2 -> tp_padding , 0 , sizeof ( h . h2 -> tp_padding ) ) ; hdrlen = sizeof ( * h . h2 ) ; break ; case TPACKET_V3 : h . h3 -> tp_status |= status ; h . h3 -> tp_len = skb -> len ; h . h3 -> tp_snaplen = snaplen ; h . h3 -> tp_mac = macoff ; h . h3 -> tp_net = netoff ; h . h3 -> tp_sec = ts . tv_sec ; h . h3 -> tp_nsec = ts . tv_nsec ; memset ( h . h3 -> tp_padding , 0 , sizeof ( h . h3 -> tp_padding ) ) ; hdrlen = sizeof ( * h . h3 ) ; break ; default : BUG ( ) ; } sll = h . raw + TPACKET_ALIGN ( hdrlen ) ; sll -> sll_halen = dev_parse_header ( skb , sll -> sll_addr ) ; sll -> sll_family = AF_PACKET ; sll -> sll_hatype = dev -> type ; sll -> sll_protocol = skb -> protocol ; sll -> sll_pkttype = skb -> pkt_type ; if ( unlikely ( po -> origdev ) ) sll -> sll_ifindex = orig_dev -> ifindex ; else sll -> sll_ifindex = dev -> ifindex ; smp_mb ( ) ; # if ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE == 1 if ( po -> tp_version <= TPACKET_V2 ) { u8 * start , * end ; end = ( u8 * ) PAGE_ALIGN ( ( unsigned long ) h . raw + macoff + snaplen ) ; for ( start = h . raw ; start < end ; start += PAGE_SIZE ) flush_dcache_page ( pgv_to_page ( start ) ) ; } smp_wmb ( ) ; # endif if ( po -> tp_version <= TPACKET_V2 ) { __packet_set_status ( po , h . raw , status ) ; sk -> sk_data_ready ( sk ) ; } else { prb_clear_blk_fill_status ( & po -> rx_ring ) ; } drop_n_restore : if ( skb_head != skb -> data && skb_shared ( skb ) ) { skb -> data = skb_head ; skb -> len = skb_len ; } drop : if ( ! is_drop_n_account ) consume_skb ( skb ) ; else kfree_skb ( skb ) ; return 0 ; drop_n_account : is_drop_n_account = true ; po -> stats . stats1 . tp_drops ++ ; spin_unlock ( & sk -> sk_receive_queue . lock ) ; sk -> sk_data_ready ( sk ) ; kfree_skb ( copy_skb ) ; goto drop_n_restore ; }",do_vnet = false ;}},166
236,"buggy line: if ( po -> has_vnet_hdr ) {if ( virtio_net_hdr_from_skb ( skb , h . raw + macoff - sizeof ( struct virtio_net_hdr ) , vio_le ( ) , true ) ) {cwe id:CWE-119context: static int tpacket_rcv ( struct sk_buff * skb , struct net_device * dev , struct packet_type * pt , struct net_device * orig_dev ) { struct sock * sk ; struct packet_sock * po ; struct sockaddr_ll * sll ; union tpacket_uhdr h ; u8 * skb_head = skb -> data ; int skb_len = skb -> len ; unsigned int snaplen , res ; unsigned long status = TP_STATUS_USER ; unsigned short macoff , netoff , hdrlen ; struct sk_buff * copy_skb = NULL ; struct timespec ts ; __u32 ts_status ;  bool is_drop_n_account = false ;  BUILD_BUG_ON ( TPACKET_ALIGN ( sizeof ( * h . h2 ) ) != 32 ) ; BUILD_BUG_ON ( TPACKET_ALIGN ( sizeof ( * h . h3 ) ) != 48 ) ; if ( skb -> pkt_type == PACKET_LOOPBACK ) goto drop ; sk = pt -> af_packet_priv ; po = pkt_sk ( sk ) ; if ( ! net_eq ( dev_net ( dev ) , sock_net ( sk ) ) ) goto drop ; if ( dev -> header_ops ) { if ( sk -> sk_type != SOCK_DGRAM ) skb_push ( skb , skb -> data - skb_mac_header ( skb ) ) ; else if ( skb -> pkt_type == PACKET_OUTGOING ) { skb_pull ( skb , skb_network_offset ( skb ) ) ; } } snaplen = skb -> len ; res = run_filter ( skb , sk , snaplen ) ; if ( ! res ) goto drop_n_restore ; if ( skb -> ip_summed == CHECKSUM_PARTIAL ) status |= TP_STATUS_CSUMNOTREADY ; else if ( skb -> pkt_type != PACKET_OUTGOING && ( skb -> ip_summed == CHECKSUM_COMPLETE || skb_csum_unnecessary ( skb ) ) ) status |= TP_STATUS_CSUM_VALID ; if ( snaplen > res ) snaplen = res ; if ( sk -> sk_type == SOCK_DGRAM ) { macoff = netoff = TPACKET_ALIGN ( po -> tp_hdrlen ) + 16 + po -> tp_reserve ; } else { unsigned int maclen = skb_network_offset ( skb ) ; netoff = TPACKET_ALIGN ( po -> tp_hdrlen + ( maclen < 16 ? 16 : maclen ) ) + po -> tp_reserve ;  if ( po -> has_vnet_hdr )  netoff += sizeof ( struct virtio_net_hdr ) ;  macoff = netoff - maclen ;  } if ( po -> tp_version <= TPACKET_V2 ) { if ( macoff + snaplen > po -> rx_ring . frame_size ) { if ( po -> copy_thresh && atomic_read ( & sk -> sk_rmem_alloc ) < sk -> sk_rcvbuf ) { if ( skb_shared ( skb ) ) { copy_skb = skb_clone ( skb , GFP_ATOMIC ) ; } else { copy_skb = skb_get ( skb ) ; skb_head = skb -> data ; } if ( copy_skb ) skb_set_owner_r ( copy_skb , sk ) ; } snaplen = po -> rx_ring . frame_size - macoff ;  if ( ( int ) snaplen < 0 )   snaplen = 0 ;  } } else if ( unlikely ( macoff + snaplen > GET_PBDQC_FROM_RB ( & po -> rx_ring ) -> max_frame_len ) ) { u32 nval ; nval = GET_PBDQC_FROM_RB ( & po -> rx_ring ) -> max_frame_len - macoff ; pr_err_once ( ""tpacket_rcv:<S2SV_blank>packet<S2SV_blank>too<S2SV_blank>big,<S2SV_blank>clamped<S2SV_blank>from<S2SV_blank>%u<S2SV_blank>to<S2SV_blank>%u.<S2SV_blank>macoff=%u\\n"" , snaplen , nval , macoff ) ; snaplen = nval ; if ( unlikely ( ( int ) snaplen < 0 ) ) { snaplen = 0 ; macoff = GET_PBDQC_FROM_RB ( & po -> rx_ring ) -> max_frame_len ;  }  } spin_lock ( & sk -> sk_receive_queue . lock ) ; h . raw = packet_current_rx_frame ( po , skb , TP_STATUS_KERNEL , ( macoff + snaplen ) ) ; if ( ! h . raw ) goto drop_n_account ; if ( po -> tp_version <= TPACKET_V2 ) { packet_increment_rx_head ( po , & po -> rx_ring ) ; if ( po -> stats . stats1 . tp_drops ) status |= TP_STATUS_LOSING ; } po -> stats . stats1 . tp_packets ++ ; if ( copy_skb ) { status |= TP_STATUS_COPY ; __skb_queue_tail ( & sk -> sk_receive_queue , copy_skb ) ; } spin_unlock ( & sk -> sk_receive_queue . lock ) ;  if ( po -> has_vnet_hdr ) {  if ( virtio_net_hdr_from_skb ( skb , h . raw + macoff - sizeof ( struct virtio_net_hdr ) , vio_le ( ) , true ) ) { spin_lock ( & sk -> sk_receive_queue . lock ) ; goto drop_n_account ; } } skb_copy_bits ( skb , 0 , h . raw + macoff , snaplen ) ; if ( ! ( ts_status = tpacket_get_timestamp ( skb , & ts , po -> tp_tstamp ) ) ) getnstimeofday ( & ts ) ; status |= ts_status ; switch ( po -> tp_version ) { case TPACKET_V1 : h . h1 -> tp_len = skb -> len ; h . h1 -> tp_snaplen = snaplen ; h . h1 -> tp_mac = macoff ; h . h1 -> tp_net = netoff ; h . h1 -> tp_sec = ts . tv_sec ; h . h1 -> tp_usec = ts . tv_nsec / NSEC_PER_USEC ; hdrlen = sizeof ( * h . h1 ) ; break ; case TPACKET_V2 : h . h2 -> tp_len = skb -> len ; h . h2 -> tp_snaplen = snaplen ; h . h2 -> tp_mac = macoff ; h . h2 -> tp_net = netoff ; h . h2 -> tp_sec = ts . tv_sec ; h . h2 -> tp_nsec = ts . tv_nsec ; if ( skb_vlan_tag_present ( skb ) ) { h . h2 -> tp_vlan_tci = skb_vlan_tag_get ( skb ) ; h . h2 -> tp_vlan_tpid = ntohs ( skb -> vlan_proto ) ; status |= TP_STATUS_VLAN_VALID | TP_STATUS_VLAN_TPID_VALID ; } else { h . h2 -> tp_vlan_tci = 0 ; h . h2 -> tp_vlan_tpid = 0 ; } memset ( h . h2 -> tp_padding , 0 , sizeof ( h . h2 -> tp_padding ) ) ; hdrlen = sizeof ( * h . h2 ) ; break ; case TPACKET_V3 : h . h3 -> tp_status |= status ; h . h3 -> tp_len = skb -> len ; h . h3 -> tp_snaplen = snaplen ; h . h3 -> tp_mac = macoff ; h . h3 -> tp_net = netoff ; h . h3 -> tp_sec = ts . tv_sec ; h . h3 -> tp_nsec = ts . tv_nsec ; memset ( h . h3 -> tp_padding , 0 , sizeof ( h . h3 -> tp_padding ) ) ; hdrlen = sizeof ( * h . h3 ) ; break ; default : BUG ( ) ; } sll = h . raw + TPACKET_ALIGN ( hdrlen ) ; sll -> sll_halen = dev_parse_header ( skb , sll -> sll_addr ) ; sll -> sll_family = AF_PACKET ; sll -> sll_hatype = dev -> type ; sll -> sll_protocol = skb -> protocol ; sll -> sll_pkttype = skb -> pkt_type ; if ( unlikely ( po -> origdev ) ) sll -> sll_ifindex = orig_dev -> ifindex ; else sll -> sll_ifindex = dev -> ifindex ; smp_mb ( ) ; # if ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE == 1 if ( po -> tp_version <= TPACKET_V2 ) { u8 * start , * end ; end = ( u8 * ) PAGE_ALIGN ( ( unsigned long ) h . raw + macoff + snaplen ) ; for ( start = h . raw ; start < end ; start += PAGE_SIZE ) flush_dcache_page ( pgv_to_page ( start ) ) ; } smp_wmb ( ) ; # endif if ( po -> tp_version <= TPACKET_V2 ) { __packet_set_status ( po , h . raw , status ) ; sk -> sk_data_ready ( sk ) ; } else { prb_clear_blk_fill_status ( & po -> rx_ring ) ; } drop_n_restore : if ( skb_head != skb -> data && skb_shared ( skb ) ) { skb -> data = skb_head ; skb -> len = skb_len ; } drop : if ( ! is_drop_n_account ) consume_skb ( skb ) ; else kfree_skb ( skb ) ; return 0 ; drop_n_account : is_drop_n_account = true ; po -> stats . stats1 . tp_drops ++ ; spin_unlock ( & sk -> sk_receive_queue . lock ) ; sk -> sk_data_ready ( sk ) ; kfree_skb ( copy_skb ) ; goto drop_n_restore ; }","if ( po -> has_vnet_hdr ) {if ( virtio_net_hdr_from_skb ( skb , h . raw + macoff - sizeof ( struct virtio_net_hdr ) , vio_le ( ) , true ) ) {",166
237,"buggy line: }if ( ! asoc -> assoc_id ) {sctp_assoc_set_id ( asoc , GFP_ATOMIC ) ;}}kfree ( asoc -> peer . peer_random ) ;asoc -> peer . peer_random = new -> peer . peer_random ;new -> peer . peer_random = NULL ;kfree ( asoc -> peer . peer_chunks ) ;asoc -> peer . peer_chunks = new -> peer . peer_chunks ;new -> peer . peer_chunks = NULL ;kfree ( asoc -> peer . peer_hmacs ) ;asoc -> peer . peer_hmacs = new -> peer . peer_hmacs ;new -> peer . peer_hmacs = NULL ;sctp_auth_key_put ( asoc -> asoc_shared_key ) ;sctp_auth_asoc_init_active_key ( asoc , GFP_ATOMIC ) ;cwe id:CWE-000context: void sctp_assoc_update ( struct sctp_association * asoc , struct sctp_association * new ) { struct sctp_transport * trans ; struct list_head * pos , * temp ; asoc -> c = new -> c ; asoc -> peer . rwnd = new -> peer . rwnd ; asoc -> peer . sack_needed = new -> peer . sack_needed ; asoc -> peer . auth_capable = new -> peer . auth_capable ; asoc -> peer . i = new -> peer . i ; sctp_tsnmap_init ( & asoc -> peer . tsn_map , SCTP_TSN_MAP_INITIAL , asoc -> peer . i . initial_tsn , GFP_ATOMIC ) ; list_for_each_safe ( pos , temp , & asoc -> peer . transport_addr_list ) { trans = list_entry ( pos , struct sctp_transport , transports ) ; if ( ! sctp_assoc_lookup_paddr ( new , & trans -> ipaddr ) ) { sctp_assoc_rm_peer ( asoc , trans ) ; continue ; } if ( asoc -> state >= SCTP_STATE_ESTABLISHED ) sctp_transport_reset ( trans ) ; } if ( asoc -> state >= SCTP_STATE_ESTABLISHED ) { asoc -> next_tsn = new -> next_tsn ; asoc -> ctsn_ack_point = new -> ctsn_ack_point ; asoc -> adv_peer_ack_point = new -> adv_peer_ack_point ; sctp_ssnmap_clear ( asoc -> ssnmap ) ; sctp_ulpq_flush ( & asoc -> ulpq ) ; asoc -> overall_error_count = 0 ; } else { list_for_each_entry ( trans , & new -> peer . transport_addr_list , transports ) { if ( ! sctp_assoc_lookup_paddr ( asoc , & trans -> ipaddr ) ) sctp_assoc_add_peer ( asoc , & trans -> ipaddr , GFP_ATOMIC , trans -> state ) ; } asoc -> ctsn_ack_point = asoc -> next_tsn - 1 ; asoc -> adv_peer_ack_point = asoc -> ctsn_ack_point ; if ( ! asoc -> ssnmap ) { asoc -> ssnmap = new -> ssnmap ; new -> ssnmap = NULL ; } if ( ! asoc -> assoc_id ) { sctp_assoc_set_id ( asoc , GFP_ATOMIC ) ; } } kfree ( asoc -> peer . peer_random ) ; asoc -> peer . peer_random = new -> peer . peer_random ; new -> peer . peer_random = NULL ; kfree ( asoc -> peer . peer_chunks ) ; asoc -> peer . peer_chunks = new -> peer . peer_chunks ; new -> peer . peer_chunks = NULL ; kfree ( asoc -> peer . peer_hmacs ) ; asoc -> peer . peer_hmacs = new -> peer . peer_hmacs ; new -> peer . peer_hmacs = NULL ;  sctp_auth_key_put ( asoc -> asoc_shared_key ) ;  sctp_auth_asoc_init_active_key ( asoc , GFP_ATOMIC ) ; }","sctp_auth_asoc_init_active_key ( asoc , GFP_ATOMIC ) ;",167
238,buggy line: return true ;}cwe id:CWE-284context: static bool ndp_msg_check_valid ( struct ndp_msg * msg ) { size_t len = ndp_msg_payload_len ( msg ) ; enum ndp_msg_type msg_type = ndp_msg_type ( msg ) ; if ( len < ndp_msg_type_info ( msg_type ) -> raw_struct_size ) return false ;  return true ;  },if ( ndp_msg_type_info ( msg_type ) -> addrto_validate ) return ndp_msg_type_info ( msg_type ) -> addrto_validate ( & msg -> addrto ) ;else return true ;},168
239,"buggy line: int lsm_set_label_at ( int procfd , int on_exec , char * lsm_label ) {int labelfd = - 1 ;int ret = 0 ;if ( strcmp ( name , ""nop"" ) == 0 )  goto out ;if ( strcmp ( name , ""none"" ) == 0 )  goto out ;if ( strcmp ( name , ""AppArmor"" ) == 0 ) on_exec = 0 ;if ( on_exec ) {labelfd = openat ( procfd , ""self/attr/exec"" , O_RDWR ) ;}else {labelfd = openat ( procfd , ""self/attr/current"" , O_RDWR ) ;}if ( labelfd < 0 ) {SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>LSM<S2SV_blank>label"" ) ;ret = - 1 ;goto out ;}ret = - 1 ;goto out ;ret = - 1 ;goto out ;}if ( write ( labelfd , command , size + 1 ) < 0 ) {SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>LSM<S2SV_blank>label"" ) ;ret = - 1 ;goto out ;}else if ( strcmp ( name , ""SELinux"" ) == 0 ) {if ( write ( labelfd , lsm_label , strlen ( lsm_label ) + 1 ) < 0 ) {ret = - 1 ;ret = - 1 ;goto out ;if ( labelfd != - 1 )   close ( labelfd ) ;return ret ;}cwe id:CWE-264context:  int lsm_set_label_at ( int procfd , int on_exec , char * lsm_label ) {   int labelfd = - 1 ;  int ret = 0 ; const char * name ; char * command = NULL ; name = lsm_name ( ) ; if ( strcmp ( name , ""nop"" ) == 0 )  goto out ;  if ( strcmp ( name , ""none"" ) == 0 )  goto out ;  if ( strcmp ( name , ""AppArmor"" ) == 0 ) on_exec = 0 ;  if ( on_exec ) {  labelfd = openat ( procfd , ""self/attr/exec"" , O_RDWR ) ; } else { labelfd = openat ( procfd , ""self/attr/current"" , O_RDWR ) ; } if ( labelfd < 0 ) { SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>LSM<S2SV_blank>label"" ) ; ret = - 1 ; goto out ; } if ( strcmp ( name , ""AppArmor"" ) == 0 ) { int size ; command = malloc ( strlen ( lsm_label ) + strlen ( ""changeprofile<S2SV_blank>"" ) + 1 ) ; if ( ! command ) { SYSERROR ( ""Failed<S2SV_blank>to<S2SV_blank>write<S2SV_blank>apparmor<S2SV_blank>profile"" ) ;  ret = - 1 ;  goto out ; } size = sprintf ( command , ""changeprofile<S2SV_blank>%s"" , lsm_label ) ; if ( size < 0 ) { SYSERROR ( ""Failed<S2SV_blank>to<S2SV_blank>write<S2SV_blank>apparmor<S2SV_blank>profile"" ) ;  ret = - 1 ;  goto out ; }  if ( write ( labelfd , command , size + 1 ) < 0 ) {   SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>LSM<S2SV_blank>label"" ) ;   ret = - 1 ;  goto out ; } } else if ( strcmp ( name , ""SELinux"" ) == 0 ) { if ( write ( labelfd , lsm_label , strlen ( lsm_label ) + 1 ) < 0 ) { SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>LSM<S2SV_blank>label"" ) ; ret = - 1 ; goto out ; } } else { ERROR ( ""Unable<S2SV_blank>to<S2SV_blank>restore<S2SV_blank>label<S2SV_blank>for<S2SV_blank>unknown<S2SV_blank>LSM:<S2SV_blank>%s"" , name ) ;  ret = - 1 ;  goto out ; } out : free ( command ) ;  if ( labelfd != - 1 )   close ( labelfd ) ;   return ret ;  }","static int lsm_set_label_at ( int lsm_labelfd , int on_exec , char * lsm_label ) {int fret = - 1 ;int ret = 0 ;if ( strcmp ( name , ""nop"" ) == 0 ) return 0 ;if ( strcmp ( name , ""none"" ) == 0 ) return 0 ;if ( strcmp ( name , ""AppArmor"" ) == 0 ) on_exec = 0 ;ret = - 1 ;goto out ;goto out ;if ( write ( labelfd , command , size + 1 ) < 0 ) {INFO ( ""Set<S2SV_blank>LSM<S2SV_blank>label<S2SV_blank>to:<S2SV_blank>%s."" , lsm_label ) ;ret = - 1 ;goto out ;if ( labelfd != - 1 ) close ( labelfd ) ;return fret ;}",169
240,"buggy line: cwe id:CWE-369context: static OPJ_BOOL opj_pi_next_cprl ( opj_pi_iterator_t * pi ) { opj_pi_comp_t * comp = NULL ; opj_pi_resolution_t * res = NULL ; OPJ_UINT32 index = 0 ; if ( ! pi -> first ) { comp = & pi -> comps [ pi -> compno ] ; goto LABEL_SKIP ; } else { pi -> first = 0 ; } for ( pi -> compno = pi -> poc . compno0 ; pi -> compno < pi -> poc . compno1 ; pi -> compno ++ ) { OPJ_UINT32 resno ; comp = & pi -> comps [ pi -> compno ] ; pi -> dx = 0 ; pi -> dy = 0 ; for ( resno = 0 ; resno < comp -> numresolutions ; resno ++ ) { OPJ_UINT32 dx , dy ; res = & comp -> resolutions [ resno ] ; dx = comp -> dx * ( 1u << ( res -> pdx + comp -> numresolutions - 1 - resno ) ) ; dy = comp -> dy * ( 1u << ( res -> pdy + comp -> numresolutions - 1 - resno ) ) ; pi -> dx = ! pi -> dx ? dx : opj_uint_min ( pi -> dx , dx ) ; pi -> dy = ! pi -> dy ? dy : opj_uint_min ( pi -> dy , dy ) ; } if ( ! pi -> tp_on ) { pi -> poc . ty0 = pi -> ty0 ; pi -> poc . tx0 = pi -> tx0 ; pi -> poc . ty1 = pi -> ty1 ; pi -> poc . tx1 = pi -> tx1 ; } for ( pi -> y = pi -> poc . ty0 ; pi -> y < pi -> poc . ty1 ; pi -> y += ( OPJ_INT32 ) ( pi -> dy - ( OPJ_UINT32 ) ( pi -> y % ( OPJ_INT32 ) pi -> dy ) ) ) { for ( pi -> x = pi -> poc . tx0 ; pi -> x < pi -> poc . tx1 ; pi -> x += ( OPJ_INT32 ) ( pi -> dx - ( OPJ_UINT32 ) ( pi -> x % ( OPJ_INT32 ) pi -> dx ) ) ) { for ( pi -> resno = pi -> poc . resno0 ; pi -> resno < opj_uint_min ( pi -> poc . resno1 , comp -> numresolutions ) ; pi -> resno ++ ) { OPJ_UINT32 levelno ; OPJ_INT32 trx0 , try0 ; OPJ_INT32 trx1 , try1 ; OPJ_UINT32 rpx , rpy ; OPJ_INT32 prci , prcj ; res = & comp -> resolutions [ pi -> resno ] ; levelno = comp -> numresolutions - 1 - pi -> resno ; trx0 = opj_int_ceildiv ( pi -> tx0 , ( OPJ_INT32 ) ( comp -> dx << levelno ) ) ; try0 = opj_int_ceildiv ( pi -> ty0 , ( OPJ_INT32 ) ( comp -> dy << levelno ) ) ; trx1 = opj_int_ceildiv ( pi -> tx1 , ( OPJ_INT32 ) ( comp -> dx << levelno ) ) ; try1 = opj_int_ceildiv ( pi -> ty1 , ( OPJ_INT32 ) ( comp -> dy << levelno ) ) ; rpx = res -> pdx + levelno ; rpy = res -> pdy + levelno ;  if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) &&  ( ( try0 << levelno ) % ( 1 << rpy ) ) ) ) ) { continue ; } if ( ! ( ( pi -> x % ( OPJ_INT32 ) ( comp -> dx << rpx ) == 0 ) || ( ( pi -> x == pi -> tx0 ) && ( ( trx0 << levelno ) % ( 1 << rpx ) ) ) ) ) { continue ; } if ( ( res -> pw == 0 ) || ( res -> ph == 0 ) ) { continue ; } if ( ( trx0 == trx1 ) || ( try0 == try1 ) ) { continue ; } prci = opj_int_floordivpow2 ( opj_int_ceildiv ( pi -> x , ( OPJ_INT32 ) ( comp -> dx << levelno ) ) , ( OPJ_INT32 ) res -> pdx ) - opj_int_floordivpow2 ( trx0 , ( OPJ_INT32 ) res -> pdx ) ; prcj = opj_int_floordivpow2 ( opj_int_ceildiv ( pi -> y , ( OPJ_INT32 ) ( comp -> dy << levelno ) ) , ( OPJ_INT32 ) res -> pdy ) - opj_int_floordivpow2 ( try0 , ( OPJ_INT32 ) res -> pdy ) ; pi -> precno = ( OPJ_UINT32 ) ( prci + prcj * ( OPJ_INT32 ) res -> pw ) ; for ( pi -> layno = pi -> poc . layno0 ; pi -> layno < pi -> poc . layno1 ; pi -> layno ++ ) { index = pi -> layno * pi -> step_l + pi -> resno * pi -> step_r + pi -> compno * pi -> step_c + pi -> precno * pi -> step_p ; if ( ! pi -> include [ index ] ) { pi -> include [ index ] = 1 ; return OPJ_TRUE ; } LABEL_SKIP : ; } } } } } return OPJ_FALSE ; }",if ( rpx >= 31 || ( ( comp -> dx << rpx ) >> rpx ) != comp -> dx || rpy >= 31 || ( ( comp -> dy << rpy ) >> rpy ) != comp -> dy ) {continue ;},170
241,"buggy line: if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) &&  ( ( try0 << levelno ) % ( 1 << rpy ) ) ) ) ) {cwe id:CWE-369context: static OPJ_BOOL opj_pi_next_cprl ( opj_pi_iterator_t * pi ) { opj_pi_comp_t * comp = NULL ; opj_pi_resolution_t * res = NULL ; OPJ_UINT32 index = 0 ; if ( ! pi -> first ) { comp = & pi -> comps [ pi -> compno ] ; goto LABEL_SKIP ; } else { pi -> first = 0 ; } for ( pi -> compno = pi -> poc . compno0 ; pi -> compno < pi -> poc . compno1 ; pi -> compno ++ ) { OPJ_UINT32 resno ; comp = & pi -> comps [ pi -> compno ] ; pi -> dx = 0 ; pi -> dy = 0 ; for ( resno = 0 ; resno < comp -> numresolutions ; resno ++ ) { OPJ_UINT32 dx , dy ; res = & comp -> resolutions [ resno ] ; dx = comp -> dx * ( 1u << ( res -> pdx + comp -> numresolutions - 1 - resno ) ) ; dy = comp -> dy * ( 1u << ( res -> pdy + comp -> numresolutions - 1 - resno ) ) ; pi -> dx = ! pi -> dx ? dx : opj_uint_min ( pi -> dx , dx ) ; pi -> dy = ! pi -> dy ? dy : opj_uint_min ( pi -> dy , dy ) ; } if ( ! pi -> tp_on ) { pi -> poc . ty0 = pi -> ty0 ; pi -> poc . tx0 = pi -> tx0 ; pi -> poc . ty1 = pi -> ty1 ; pi -> poc . tx1 = pi -> tx1 ; } for ( pi -> y = pi -> poc . ty0 ; pi -> y < pi -> poc . ty1 ; pi -> y += ( OPJ_INT32 ) ( pi -> dy - ( OPJ_UINT32 ) ( pi -> y % ( OPJ_INT32 ) pi -> dy ) ) ) { for ( pi -> x = pi -> poc . tx0 ; pi -> x < pi -> poc . tx1 ; pi -> x += ( OPJ_INT32 ) ( pi -> dx - ( OPJ_UINT32 ) ( pi -> x % ( OPJ_INT32 ) pi -> dx ) ) ) { for ( pi -> resno = pi -> poc . resno0 ; pi -> resno < opj_uint_min ( pi -> poc . resno1 , comp -> numresolutions ) ; pi -> resno ++ ) { OPJ_UINT32 levelno ; OPJ_INT32 trx0 , try0 ; OPJ_INT32 trx1 , try1 ; OPJ_UINT32 rpx , rpy ; OPJ_INT32 prci , prcj ; res = & comp -> resolutions [ pi -> resno ] ; levelno = comp -> numresolutions - 1 - pi -> resno ; trx0 = opj_int_ceildiv ( pi -> tx0 , ( OPJ_INT32 ) ( comp -> dx << levelno ) ) ; try0 = opj_int_ceildiv ( pi -> ty0 , ( OPJ_INT32 ) ( comp -> dy << levelno ) ) ; trx1 = opj_int_ceildiv ( pi -> tx1 , ( OPJ_INT32 ) ( comp -> dx << levelno ) ) ; try1 = opj_int_ceildiv ( pi -> ty1 , ( OPJ_INT32 ) ( comp -> dy << levelno ) ) ; rpx = res -> pdx + levelno ; rpy = res -> pdy + levelno ;  if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) &&  ( ( try0 << levelno ) % ( 1 << rpy ) ) ) ) ) { continue ; } if ( ! ( ( pi -> x % ( OPJ_INT32 ) ( comp -> dx << rpx ) == 0 ) || ( ( pi -> x == pi -> tx0 ) && ( ( trx0 << levelno ) % ( 1 << rpx ) ) ) ) ) { continue ; } if ( ( res -> pw == 0 ) || ( res -> ph == 0 ) ) { continue ; } if ( ( trx0 == trx1 ) || ( try0 == try1 ) ) { continue ; } prci = opj_int_floordivpow2 ( opj_int_ceildiv ( pi -> x , ( OPJ_INT32 ) ( comp -> dx << levelno ) ) , ( OPJ_INT32 ) res -> pdx ) - opj_int_floordivpow2 ( trx0 , ( OPJ_INT32 ) res -> pdx ) ; prcj = opj_int_floordivpow2 ( opj_int_ceildiv ( pi -> y , ( OPJ_INT32 ) ( comp -> dy << levelno ) ) , ( OPJ_INT32 ) res -> pdy ) - opj_int_floordivpow2 ( try0 , ( OPJ_INT32 ) res -> pdy ) ; pi -> precno = ( OPJ_UINT32 ) ( prci + prcj * ( OPJ_INT32 ) res -> pw ) ; for ( pi -> layno = pi -> poc . layno0 ; pi -> layno < pi -> poc . layno1 ; pi -> layno ++ ) { index = pi -> layno * pi -> step_l + pi -> resno * pi -> step_r + pi -> compno * pi -> step_c + pi -> precno * pi -> step_p ; if ( ! pi -> include [ index ] ) { pi -> include [ index ] = 1 ; return OPJ_TRUE ; } LABEL_SKIP : ; } } } } } return OPJ_FALSE ; }",if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) && ( ( try0 << levelno ) % ( 1 << rpy ) ) ) ) ) {,170
242,"buggy line: static void record_and_restart ( struct perf_event * event , unsigned long val ,  struct pt_regs * regs , int nmi )  {cwe id:CWE-399context: static void record_and_restart ( struct perf_event * event , unsigned long val ,  struct pt_regs * regs , int nmi )  { u64 period = event -> hw . sample_period ; s64 prev , delta , left ; int record = 0 ; if ( event -> hw . state & PERF_HES_STOPPED ) { write_pmc ( event -> hw . idx , 0 ) ; return ; } prev = local64_read ( & event -> hw . prev_count ) ; delta = check_and_compute_delta ( prev , val ) ; local64_add ( delta , & event -> count ) ; val = 0 ; left = local64_read ( & event -> hw . period_left ) - delta ; if ( period ) { if ( left <= 0 ) { left += period ; if ( left <= 0 ) left = period ; record = 1 ; event -> hw . last_period = event -> hw . sample_period ; } if ( left < 0x80000000LL ) val = 0x80000000LL - left ; } write_pmc ( event -> hw . idx , val ) ; local64_set ( & event -> hw . prev_count , val ) ; local64_set ( & event -> hw . period_left , left ) ; perf_event_update_userpage ( event ) ; if ( record ) { struct perf_sample_data data ; perf_sample_data_init ( & data , ~ 0ULL ) ; data . period = event -> hw . last_period ; if ( event -> attr . sample_type & PERF_SAMPLE_ADDR ) perf_get_data_addr ( regs , & data . addr ) ;  if ( perf_event_overflow ( event , nmi , & data , regs ) )  power_pmu_stop ( event , 0 ) ; } }","static void record_and_restart ( struct perf_event * event , unsigned long val , struct pt_regs * regs ) {",171
243,"buggy line: if ( perf_event_overflow ( event , nmi , & data , regs ) )  power_pmu_stop ( event , 0 ) ;cwe id:CWE-399context: static void record_and_restart ( struct perf_event * event , unsigned long val ,  struct pt_regs * regs , int nmi )  { u64 period = event -> hw . sample_period ; s64 prev , delta , left ; int record = 0 ; if ( event -> hw . state & PERF_HES_STOPPED ) { write_pmc ( event -> hw . idx , 0 ) ; return ; } prev = local64_read ( & event -> hw . prev_count ) ; delta = check_and_compute_delta ( prev , val ) ; local64_add ( delta , & event -> count ) ; val = 0 ; left = local64_read ( & event -> hw . period_left ) - delta ; if ( period ) { if ( left <= 0 ) { left += period ; if ( left <= 0 ) left = period ; record = 1 ; event -> hw . last_period = event -> hw . sample_period ; } if ( left < 0x80000000LL ) val = 0x80000000LL - left ; } write_pmc ( event -> hw . idx , val ) ; local64_set ( & event -> hw . prev_count , val ) ; local64_set ( & event -> hw . period_left , left ) ; perf_event_update_userpage ( event ) ; if ( record ) { struct perf_sample_data data ; perf_sample_data_init ( & data , ~ 0ULL ) ; data . period = event -> hw . last_period ; if ( event -> attr . sample_type & PERF_SAMPLE_ADDR ) perf_get_data_addr ( regs , & data . addr ) ;  if ( perf_event_overflow ( event , nmi , & data , regs ) )  power_pmu_stop ( event , 0 ) ; } }","if ( perf_event_overflow ( event , & data , regs ) ) power_pmu_stop ( event , 0 ) ;",171
244,"buggy line: # ifdef DISABLE_RC_LONG_TERM_MEM  const uint64_t bits_used = cpi -> rc . this_frame_target ;# else const uint64_t bits_used = cpi -> rc . projected_frame_size ;# endif cpi -> twopass . bits_left -= bits_used ;cpi -> twopass . bits_left = MAX ( cpi -> twopass . bits_left , 0 ) ;if ( cpi -> common . frame_type == KEY_FRAME ) {cpi -> twopass . kf_group_bits += cpi -> rc . this_frame_target - bits_used ;cpi -> twopass . kf_group_bits -= bits_used ;cpi -> twopass . gf_group_bits -= bits_used ;cpi -> twopass . gf_group_bits = MAX ( cpi -> twopass . gf_group_bits , 0 ) ;}cpi -> twopass . kf_group_bits = MAX ( cpi -> twopass . kf_group_bits , 0 ) ;cwe id:CWE-119context: void vp9_twopass_postencode_update ( VP9_COMP * cpi ) {  # ifdef DISABLE_RC_LONG_TERM_MEM  const uint64_t bits_used = cpi -> rc . this_frame_target ; # else const uint64_t bits_used = cpi -> rc . projected_frame_size ; # endif cpi -> twopass . bits_left -= bits_used ; cpi -> twopass . bits_left = MAX ( cpi -> twopass . bits_left , 0 ) ;  if ( cpi -> common . frame_type == KEY_FRAME ) {  cpi -> twopass . kf_group_bits += cpi -> rc . this_frame_target - bits_used ; } else { cpi -> twopass . kf_group_bits -= bits_used ;  cpi -> twopass . gf_group_bits -= bits_used ;   cpi -> twopass . gf_group_bits = MAX ( cpi -> twopass . gf_group_bits , 0 ) ;   }  cpi -> twopass . kf_group_bits = MAX ( cpi -> twopass . kf_group_bits , 0 ) ; }","TWO_PASS * const twopass = & cpi -> twopass ;RATE_CONTROL * const rc = & cpi -> rc ;const int bits_used = rc -> base_frame_target ;rc -> vbr_bits_off_target += rc -> base_frame_target - rc -> projected_frame_size ;twopass -> bits_left = MAX ( twopass -> bits_left - bits_used , 0 ) ;if ( rc -> total_actual_bits ) {rc -> rate_error_estimate = ( int ) ( ( rc -> vbr_bits_off_target * 100 ) / rc -> total_actual_bits ) ;rc -> rate_error_estimate = clamp ( rc -> rate_error_estimate , - 100 , 100 ) ;rc -> rate_error_estimate = 0 ;}if ( cpi -> common . frame_type != KEY_FRAME && ! vp9_is_upper_layer_key_frame ( cpi ) ) {twopass -> kf_group_bits -= bits_used ;cpi -> twopass . gf_group_bits -= bits_used ;cpi -> twopass . gf_group_bits = MAX ( twopass -> kf_group_bits , 0 ) ;++ twopass -> gf_group . index ;if ( ( cpi -> oxcf . rc_mode != VPX_Q ) && ( cpi -> twopass . gf_zeromotion_pct < VLOW_MOTION_THRESHOLD ) && ! cpi -> rc . is_src_frame_alt_ref ) {const int maxq_adj_limit = rc -> worst_quality - twopass -> active_worst_quality ;const int minq_adj_limit = ( cpi -> oxcf . rc_mode == VPX_CQ ? MINQ_ADJ_LIMIT_CQ : MINQ_ADJ_LIMIT ) ;if ( rc -> rate_error_estimate > cpi -> oxcf . under_shoot_pct ) {-- twopass -> extend_maxq ;if ( rc -> rolling_target_bits >= rc -> rolling_actual_bits ) ++ twopass -> extend_minq ;}else if ( rc -> rate_error_estimate < - cpi -> oxcf . over_shoot_pct ) {-- twopass -> extend_minq ;if ( rc -> rolling_target_bits < rc -> rolling_actual_bits ) ++ twopass -> extend_maxq ;}else {if ( rc -> projected_frame_size > ( 2 * rc -> base_frame_target ) && rc -> projected_frame_size > ( 2 * rc -> avg_frame_bandwidth ) ) ++ twopass -> extend_maxq ;if ( rc -> rolling_target_bits < rc -> rolling_actual_bits ) -- twopass -> extend_minq ;else if ( rc -> rolling_target_bits > rc -> rolling_actual_bits ) -- twopass -> extend_maxq ;}twopass -> extend_minq = clamp ( twopass -> extend_minq , 0 , minq_adj_limit ) ;twopass -> extend_maxq = clamp ( twopass -> extend_maxq , 0 , maxq_adj_limit ) ;if ( ! frame_is_kf_gf_arf ( cpi ) && ! cpi -> rc . is_src_frame_alt_ref ) {int fast_extra_thresh = rc -> base_frame_target / HIGH_UNDERSHOOT_RATIO ;if ( rc -> projected_frame_size < fast_extra_thresh ) {rc -> vbr_bits_off_target_fast += fast_extra_thresh - rc -> projected_frame_size ;rc -> vbr_bits_off_target_fast = MIN ( rc -> vbr_bits_off_target_fast , ( 4 * rc -> avg_frame_bandwidth ) ) ;if ( rc -> avg_frame_bandwidth ) {twopass -> extend_minq_fast = ( int ) ( rc -> vbr_bits_off_target_fast * 8 / rc -> avg_frame_bandwidth ) ;}twopass -> extend_minq_fast = MIN ( twopass -> extend_minq_fast , minq_adj_limit - twopass -> extend_minq ) ;}else if ( rc -> vbr_bits_off_target_fast ) {twopass -> extend_minq_fast = MIN ( twopass -> extend_minq_fast , minq_adj_limit - twopass -> extend_minq ) ;}else {twopass -> extend_minq_fast = 0 ;}}}",172
245,"buggy line: num ++ ;curqlevel = tmpql = ( lquery_level * ) palloc0 ( ITEMSIZE * num ) ;cwe id:CWE-189context: Datum lquery_in ( PG_FUNCTION_ARGS ) { char * buf = ( char * ) PG_GETARG_POINTER ( 0 ) ; char * ptr ; int num = 0 , totallen = 0 , numOR = 0 ; int state = LQPRS_WAITLEVEL ; lquery * result ; nodeitem * lptr = NULL ; lquery_level * cur , * curqlevel , * tmpql ; lquery_variant * lrptr = NULL ; bool hasnot = false ; bool wasbad = false ; int charlen ; int pos = 0 ; ptr = buf ; while ( * ptr ) { charlen = pg_mblen ( ptr ) ; if ( charlen == 1 ) { if ( t_iseq ( ptr , '.' ) ) num ++ ; else if ( t_iseq ( ptr , '|' ) ) numOR ++ ; } ptr += charlen ; }  num ++ ;  curqlevel = tmpql = ( lquery_level * ) palloc0 ( ITEMSIZE * num ) ; ptr = buf ; while ( * ptr ) { charlen = pg_mblen ( ptr ) ; if ( state == LQPRS_WAITLEVEL ) { if ( ISALNUM ( ptr ) ) { GETVAR ( curqlevel ) = lptr = ( nodeitem * ) palloc0 ( sizeof ( nodeitem ) * ( numOR + 1 ) ) ; lptr -> start = ptr ; state = LQPRS_WAITDELIM ; curqlevel -> numvar = 1 ; } else if ( charlen == 1 && t_iseq ( ptr , '!' ) ) { GETVAR ( curqlevel ) = lptr = ( nodeitem * ) palloc0 ( sizeof ( nodeitem ) * ( numOR + 1 ) ) ; lptr -> start = ptr + 1 ; state = LQPRS_WAITDELIM ; curqlevel -> numvar = 1 ; curqlevel -> flag |= LQL_NOT ; hasnot = true ; } else if ( charlen == 1 && t_iseq ( ptr , '*' ) ) state = LQPRS_WAITOPEN ; else UNCHAR ; } else if ( state == LQPRS_WAITVAR ) { if ( ISALNUM ( ptr ) ) { lptr ++ ; lptr -> start = ptr ; state = LQPRS_WAITDELIM ; curqlevel -> numvar ++ ; } else UNCHAR ; } else if ( state == LQPRS_WAITDELIM ) { if ( charlen == 1 && t_iseq ( ptr , '@' ) ) { if ( lptr -> start == ptr ) UNCHAR ; lptr -> flag |= LVAR_INCASE ; curqlevel -> flag |= LVAR_INCASE ; } else if ( charlen == 1 && t_iseq ( ptr , '*' ) ) { if ( lptr -> start == ptr ) UNCHAR ; lptr -> flag |= LVAR_ANYEND ; curqlevel -> flag |= LVAR_ANYEND ; } else if ( charlen == 1 && t_iseq ( ptr , '%' ) ) { if ( lptr -> start == ptr ) UNCHAR ; lptr -> flag |= LVAR_SUBLEXEME ; curqlevel -> flag |= LVAR_SUBLEXEME ; } else if ( charlen == 1 && t_iseq ( ptr , '|' ) ) { lptr -> len = ptr - lptr -> start - ( ( lptr -> flag & LVAR_SUBLEXEME ) ? 1 : 0 ) - ( ( lptr -> flag & LVAR_INCASE ) ? 1 : 0 ) - ( ( lptr -> flag & LVAR_ANYEND ) ? 1 : 0 ) ; if ( lptr -> wlen > 255 ) ereport ( ERROR , ( errcode ( ERRCODE_NAME_TOO_LONG ) , errmsg ( ""name<S2SV_blank>of<S2SV_blank>level<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long"" ) , errdetail ( ""Name<S2SV_blank>length<S2SV_blank>is<S2SV_blank>%d,<S2SV_blank>must<S2SV_blank>"" ""be<S2SV_blank><<S2SV_blank>256,<S2SV_blank>in<S2SV_blank>position<S2SV_blank>%d."" , lptr -> wlen , pos ) ) ) ; state = LQPRS_WAITVAR ; } else if ( charlen == 1 && t_iseq ( ptr , '.' ) ) { lptr -> len = ptr - lptr -> start - ( ( lptr -> flag & LVAR_SUBLEXEME ) ? 1 : 0 ) - ( ( lptr -> flag & LVAR_INCASE ) ? 1 : 0 ) - ( ( lptr -> flag & LVAR_ANYEND ) ? 1 : 0 ) ; if ( lptr -> wlen > 255 ) ereport ( ERROR , ( errcode ( ERRCODE_NAME_TOO_LONG ) , errmsg ( ""name<S2SV_blank>of<S2SV_blank>level<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long"" ) , errdetail ( ""Name<S2SV_blank>length<S2SV_blank>is<S2SV_blank>%d,<S2SV_blank>must<S2SV_blank>"" ""be<S2SV_blank><<S2SV_blank>256,<S2SV_blank>in<S2SV_blank>position<S2SV_blank>%d."" , lptr -> wlen , pos ) ) ) ; state = LQPRS_WAITLEVEL ; curqlevel = NEXTLEV ( curqlevel ) ; } else if ( ISALNUM ( ptr ) ) { if ( lptr -> flag ) UNCHAR ; } else UNCHAR ; } else if ( state == LQPRS_WAITOPEN ) { if ( charlen == 1 && t_iseq ( ptr , '{' ) ) state = LQPRS_WAITFNUM ; else if ( charlen == 1 && t_iseq ( ptr , '.' ) ) { curqlevel -> low = 0 ; curqlevel -> high = 0xffff ; curqlevel = NEXTLEV ( curqlevel ) ; state = LQPRS_WAITLEVEL ; } else UNCHAR ; } else if ( state == LQPRS_WAITFNUM ) { if ( charlen == 1 && t_iseq ( ptr , ',' ) ) state = LQPRS_WAITSNUM ; else if ( t_isdigit ( ptr ) ) { curqlevel -> low = atoi ( ptr ) ; state = LQPRS_WAITND ; } else UNCHAR ; } else if ( state == LQPRS_WAITSNUM ) { if ( t_isdigit ( ptr ) ) { curqlevel -> high = atoi ( ptr ) ; state = LQPRS_WAITCLOSE ; } else if ( charlen == 1 && t_iseq ( ptr , '}' ) ) { curqlevel -> high = 0xffff ; state = LQPRS_WAITEND ; } else UNCHAR ; } else if ( state == LQPRS_WAITCLOSE ) { if ( charlen == 1 && t_iseq ( ptr , '}' ) ) state = LQPRS_WAITEND ; else if ( ! t_isdigit ( ptr ) ) UNCHAR ; } else if ( state == LQPRS_WAITND ) { if ( charlen == 1 && t_iseq ( ptr , '}' ) ) { curqlevel -> high = curqlevel -> low ; state = LQPRS_WAITEND ; } else if ( charlen == 1 && t_iseq ( ptr , ',' ) ) state = LQPRS_WAITSNUM ; else if ( ! t_isdigit ( ptr ) ) UNCHAR ; } else if ( state == LQPRS_WAITEND ) { if ( charlen == 1 && t_iseq ( ptr , '.' ) ) { state = LQPRS_WAITLEVEL ; curqlevel = NEXTLEV ( curqlevel ) ; } else UNCHAR ; } else elog ( ERROR , ""internal<S2SV_blank>error<S2SV_blank>in<S2SV_blank>parser"" ) ; ptr += charlen ; if ( state == LQPRS_WAITDELIM ) lptr -> wlen ++ ; pos ++ ; } if ( state == LQPRS_WAITDELIM ) { if ( lptr -> start == ptr ) ereport ( ERROR , ( errcode ( ERRCODE_SYNTAX_ERROR ) , errmsg ( ""syntax<S2SV_blank>error"" ) , errdetail ( ""Unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>line."" ) ) ) ; lptr -> len = ptr - lptr -> start - ( ( lptr -> flag & LVAR_SUBLEXEME ) ? 1 : 0 ) - ( ( lptr -> flag & LVAR_INCASE ) ? 1 : 0 ) - ( ( lptr -> flag & LVAR_ANYEND ) ? 1 : 0 ) ; if ( lptr -> len == 0 ) ereport ( ERROR , ( errcode ( ERRCODE_SYNTAX_ERROR ) , errmsg ( ""syntax<S2SV_blank>error"" ) , errdetail ( ""Unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>line."" ) ) ) ; if ( lptr -> wlen > 255 ) ereport ( ERROR , ( errcode ( ERRCODE_NAME_TOO_LONG ) , errmsg ( ""name<S2SV_blank>of<S2SV_blank>level<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long"" ) , errdetail ( ""Name<S2SV_blank>length<S2SV_blank>is<S2SV_blank>%d,<S2SV_blank>must<S2SV_blank>"" ""be<S2SV_blank><<S2SV_blank>256,<S2SV_blank>in<S2SV_blank>position<S2SV_blank>%d."" , lptr -> wlen , pos ) ) ) ; } else if ( state == LQPRS_WAITOPEN ) curqlevel -> high = 0xffff ; else if ( state != LQPRS_WAITEND ) ereport ( ERROR , ( errcode ( ERRCODE_SYNTAX_ERROR ) , errmsg ( ""syntax<S2SV_blank>error"" ) , errdetail ( ""Unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>line."" ) ) ) ; curqlevel = tmpql ; totallen = LQUERY_HDRSIZE ; while ( ( char * ) curqlevel - ( char * ) tmpql < num * ITEMSIZE ) { totallen += LQL_HDRSIZE ; if ( curqlevel -> numvar ) { lptr = GETVAR ( curqlevel ) ; while ( lptr - GETVAR ( curqlevel ) < curqlevel -> numvar ) { totallen += MAXALIGN ( LVAR_HDRSIZE + lptr -> len ) ; lptr ++ ; } } else if ( curqlevel -> low > curqlevel -> high ) ereport ( ERROR , ( errcode ( ERRCODE_SYNTAX_ERROR ) , errmsg ( ""syntax<S2SV_blank>error"" ) , errdetail ( ""Low<S2SV_blank>limit(%d)<S2SV_blank>is<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>upper(%d)."" , curqlevel -> low , curqlevel -> high ) ) ) ; curqlevel = NEXTLEV ( curqlevel ) ; } result = ( lquery * ) palloc0 ( totallen ) ; SET_VARSIZE ( result , totallen ) ; result -> numlevel = num ; result -> firstgood = 0 ; result -> flag = 0 ; if ( hasnot ) result -> flag |= LQUERY_HASNOT ; cur = LQUERY_FIRST ( result ) ; curqlevel = tmpql ; while ( ( char * ) curqlevel - ( char * ) tmpql < num * ITEMSIZE ) { memcpy ( cur , curqlevel , LQL_HDRSIZE ) ; cur -> totallen = LQL_HDRSIZE ; if ( curqlevel -> numvar ) { lrptr = LQL_FIRST ( cur ) ; lptr = GETVAR ( curqlevel ) ; while ( lptr - GETVAR ( curqlevel ) < curqlevel -> numvar ) { cur -> totallen += MAXALIGN ( LVAR_HDRSIZE + lptr -> len ) ; lrptr -> len = lptr -> len ; lrptr -> flag = lptr -> flag ; lrptr -> val = ltree_crc32_sz ( lptr -> start , lptr -> len ) ; memcpy ( lrptr -> name , lptr -> start , lptr -> len ) ; lptr ++ ; lrptr = LVAR_NEXT ( lrptr ) ; } pfree ( GETVAR ( curqlevel ) ) ; if ( cur -> numvar > 1 || cur -> flag != 0 ) wasbad = true ; else if ( wasbad == false ) ( result -> firstgood ) ++ ; } else wasbad = true ; curqlevel = NEXTLEV ( curqlevel ) ; cur = LQL_NEXT ( cur ) ; } pfree ( tmpql ) ; PG_RETURN_POINTER ( result ) ; }","num ++ ;if ( num > MaxAllocSize / ITEMSIZE ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>levels<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , num , ( int ) ( MaxAllocSize / ITEMSIZE ) ) ) ) ;curqlevel = tmpql = ( lquery_level * ) palloc0 ( ITEMSIZE * num ) ;",173
246,"buggy line: static struct buffer_head * ext4_xattr_cache_find ( struct inode * inode , struct ext4_xattr_header * header ,  struct mb_cache_entry * * pce )  {struct mb_cache_entry * ce ;struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ;again :   ce = mb_cache_entry_find_first ( ext4_mb_cache , inode -> i_sb -> s_bdev ,  hash ) ;if ( IS_ERR ( ce ) ) {if ( PTR_ERR ( ce ) == - EAGAIN ) goto again ;break ;}cwe id:CWE-19context: static struct buffer_head * ext4_xattr_cache_find ( struct inode * inode , struct ext4_xattr_header * header ,  struct mb_cache_entry * * pce )  { __u32 hash = le32_to_cpu ( header -> h_hash ) ;  struct mb_cache_entry * ce ;  struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ; if ( ! header -> h_hash ) return NULL ; ea_idebug ( inode , ""looking<S2SV_blank>for<S2SV_blank>cached<S2SV_blank>blocks<S2SV_blank>[%x]"" , ( int ) hash ) ;  again :   ce = mb_cache_entry_find_first ( ext4_mb_cache , inode -> i_sb -> s_bdev ,  hash ) ; while ( ce ) { struct buffer_head * bh ;  if ( IS_ERR ( ce ) ) {  if ( PTR_ERR ( ce ) == - EAGAIN ) goto again ; break ; } bh = sb_bread ( inode -> i_sb , ce -> e_block ) ; if ( ! bh ) { EXT4_ERROR_INODE ( inode , ""block<S2SV_blank>%lu<S2SV_blank>read<S2SV_blank>error"" , ( unsigned long ) ce -> e_block ) ; } else if ( le32_to_cpu ( BHDR ( bh ) -> h_refcount ) >= EXT4_XATTR_REFCOUNT_MAX ) { ea_idebug ( inode , ""block<S2SV_blank>%lu<S2SV_blank>refcount<S2SV_blank>%d>=%d"" , ( unsigned long ) ce -> e_block , le32_to_cpu ( BHDR ( bh ) -> h_refcount ) , EXT4_XATTR_REFCOUNT_MAX ) ; } else if ( ext4_xattr_cmp ( header , BHDR ( bh ) ) == 0 ) { * pce = ce ; return bh ; } brelse ( bh ) ;  ce = mb_cache_entry_find_next ( ce , inode -> i_sb -> s_bdev , hash ) ;  } return NULL ; }","static struct buffer_head * ext4_xattr_cache_find ( struct inode * inode , struct ext4_xattr_header * header , struct mb2_cache_entry * * pce ) {struct mb2_cache_entry * ce ;struct mb2_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ;ce = mb2_cache_entry_find_first ( ext4_mb_cache , inode -> i_sb -> s_bdev , hash ) ;",174
247,"buggy line: ce = mb_cache_entry_find_next ( ce , inode -> i_sb -> s_bdev , hash ) ;}cwe id:CWE-19context: static struct buffer_head * ext4_xattr_cache_find ( struct inode * inode , struct ext4_xattr_header * header ,  struct mb_cache_entry * * pce )  { __u32 hash = le32_to_cpu ( header -> h_hash ) ;  struct mb_cache_entry * ce ;  struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ; if ( ! header -> h_hash ) return NULL ; ea_idebug ( inode , ""looking<S2SV_blank>for<S2SV_blank>cached<S2SV_blank>blocks<S2SV_blank>[%x]"" , ( int ) hash ) ;  again :   ce = mb_cache_entry_find_first ( ext4_mb_cache , inode -> i_sb -> s_bdev ,  hash ) ; while ( ce ) { struct buffer_head * bh ;  if ( IS_ERR ( ce ) ) {  if ( PTR_ERR ( ce ) == - EAGAIN ) goto again ; break ; } bh = sb_bread ( inode -> i_sb , ce -> e_block ) ; if ( ! bh ) { EXT4_ERROR_INODE ( inode , ""block<S2SV_blank>%lu<S2SV_blank>read<S2SV_blank>error"" , ( unsigned long ) ce -> e_block ) ; } else if ( le32_to_cpu ( BHDR ( bh ) -> h_refcount ) >= EXT4_XATTR_REFCOUNT_MAX ) { ea_idebug ( inode , ""block<S2SV_blank>%lu<S2SV_blank>refcount<S2SV_blank>%d>=%d"" , ( unsigned long ) ce -> e_block , le32_to_cpu ( BHDR ( bh ) -> h_refcount ) , EXT4_XATTR_REFCOUNT_MAX ) ; } else if ( ext4_xattr_cmp ( header , BHDR ( bh ) ) == 0 ) { * pce = ce ; return bh ; } brelse ( bh ) ;  ce = mb_cache_entry_find_next ( ce , inode -> i_sb -> s_bdev , hash ) ;  } return NULL ; }","ce = mb2_cache_entry_find_next ( ext4_mb_cache , ce ) ;}",174
248,"buggy line: gint64 offset ;int pkt_len ;pkt_len = parse_cosine_rec_hdr ( & wth -> phdr , line , err , err_info ) ;if ( pkt_len == - 1 ) return FALSE ;return parse_cosine_hex_dump ( wth -> fh , & wth -> phdr , pkt_len ,   wth -> frame_buffer , err , err_info ) ;}cwe id:CWE-119context: static gboolean cosine_read ( wtap * wth , int * err , gchar * * err_info , gint64 * data_offset ) {  gint64 offset ;  int pkt_len ; char line [ COSINE_LINE_LENGTH ] ; offset = cosine_seek_next_packet ( wth , err , err_info , line ) ; if ( offset < 0 ) return FALSE ; * data_offset = offset ;  pkt_len = parse_cosine_rec_hdr ( & wth -> phdr , line , err , err_info ) ;  if ( pkt_len == - 1 ) return FALSE ;  return parse_cosine_hex_dump ( wth -> fh , & wth -> phdr , pkt_len ,   wth -> frame_buffer , err , err_info ) ;  }","gint64 offset ;return parse_cosine_packet ( wth -> fh , & wth -> phdr , pkt_len , wth -> frame_buffer , line , err , err_info ) ;}",175
249,"buggy line: if ( pkt == NULL )  continue ;cwe id:CWE-476context: static int add_push_report_sideband_pkt ( git_push * push , git_pkt_data * data_pkt , git_buf * data_pkt_buf ) { git_pkt * pkt ; const char * line , * line_end = NULL ; size_t line_len ; int error ; int reading_from_buf = data_pkt_buf -> size > 0 ; if ( reading_from_buf ) { git_buf_put ( data_pkt_buf , data_pkt -> data , data_pkt -> len ) ; line = data_pkt_buf -> ptr ; line_len = data_pkt_buf -> size ; } else { line = data_pkt -> data ; line_len = data_pkt -> len ; } while ( line_len > 0 ) { error = git_pkt_parse_line ( & pkt , line , & line_end , line_len ) ; if ( error == GIT_EBUFS ) { if ( ! reading_from_buf ) git_buf_put ( data_pkt_buf , line , line_len ) ; error = 0 ; goto done ; } else if ( error < 0 ) goto done ; line_len -= ( line_end - line ) ; line = line_end ;  if ( pkt == NULL )  continue ; error = add_push_report_pkt ( push , pkt ) ; git_pkt_free ( pkt ) ; if ( error < 0 && error != GIT_ITEROVER ) goto done ; } error = 0 ; done : if ( reading_from_buf ) git_buf_consume ( data_pkt_buf , line_end ) ; return error ; }","
",176
250,"buggy line: cwe id:CWE-000context: int ssl3_read_n ( SSL * s , int n , int max , int extend ) { int i , len , left ; long align = 0 ; unsigned char * pkt ; SSL3_BUFFER * rb ; if ( n <= 0 ) return n ; rb = & ( s -> s3 -> rbuf ) ; if ( rb -> buf == NULL ) if ( ! ssl3_setup_read_buffer ( s ) ) return - 1 ; left = rb -> left ; # if defined ( SSL3_ALIGN_PAYLOAD ) && SSL3_ALIGN_PAYLOAD != 0 align = ( long ) rb -> buf + SSL3_RT_HEADER_LENGTH ; align = ( - align ) & ( SSL3_ALIGN_PAYLOAD - 1 ) ; # endif if ( ! extend ) { if ( left == 0 ) rb -> offset = align ; else if ( align != 0 && left >= SSL3_RT_HEADER_LENGTH ) { pkt = rb -> buf + rb -> offset ; if ( pkt [ 0 ] == SSL3_RT_APPLICATION_DATA && ( pkt [ 3 ] << 8 | pkt [ 4 ] ) >= 128 ) { memmove ( rb -> buf + align , pkt , left ) ; rb -> offset = align ; } } s -> packet = rb -> buf + rb -> offset ; s -> packet_length = 0 ; } if ( SSL_IS_DTLS ( s ) ) {  if ( left > 0 && n > left )  n = left ; } if ( left >= n ) { s -> packet_length += n ; rb -> left = left - n ; rb -> offset += n ; return ( n ) ; } len = s -> packet_length ; pkt = rb -> buf + align ; if ( s -> packet != pkt ) { memmove ( pkt , s -> packet , len + left ) ; s -> packet = pkt ; rb -> offset = len + align ; } if ( n > ( int ) ( rb -> len - rb -> offset ) ) { SSLerr ( SSL_F_SSL3_READ_N , ERR_R_INTERNAL_ERROR ) ; return - 1 ; } if ( ! s -> read_ahead ) max = n ; else { if ( max < n ) max = n ; if ( max > ( int ) ( rb -> len - rb -> offset ) ) max = rb -> len - rb -> offset ; } while ( left < n ) { clear_sys_error ( ) ; if ( s -> rbio != NULL ) { s -> rwstate = SSL_READING ; i = BIO_read ( s -> rbio , pkt + len + left , max - left ) ; } else { SSLerr ( SSL_F_SSL3_READ_N , SSL_R_READ_BIO_NOT_SET ) ; i = - 1 ; } if ( i <= 0 ) { rb -> left = left ; if ( s -> mode & SSL_MODE_RELEASE_BUFFERS && ! SSL_IS_DTLS ( s ) ) if ( len + left == 0 ) ssl3_release_read_buffer ( s ) ; return ( i ) ; } left += i ; if ( SSL_IS_DTLS ( s ) ) { if ( n > left ) n = left ; } } rb -> offset += n ; rb -> left = left - n ; s -> packet_length += n ; s -> rwstate = SSL_NOTHING ; return ( n ) ; }",if ( left == 0 && extend ) return 0 ;,177
251,"buggy line: if ( left > 0 && n > left )  n = left ;cwe id:CWE-000context: int ssl3_read_n ( SSL * s , int n , int max , int extend ) { int i , len , left ; long align = 0 ; unsigned char * pkt ; SSL3_BUFFER * rb ; if ( n <= 0 ) return n ; rb = & ( s -> s3 -> rbuf ) ; if ( rb -> buf == NULL ) if ( ! ssl3_setup_read_buffer ( s ) ) return - 1 ; left = rb -> left ; # if defined ( SSL3_ALIGN_PAYLOAD ) && SSL3_ALIGN_PAYLOAD != 0 align = ( long ) rb -> buf + SSL3_RT_HEADER_LENGTH ; align = ( - align ) & ( SSL3_ALIGN_PAYLOAD - 1 ) ; # endif if ( ! extend ) { if ( left == 0 ) rb -> offset = align ; else if ( align != 0 && left >= SSL3_RT_HEADER_LENGTH ) { pkt = rb -> buf + rb -> offset ; if ( pkt [ 0 ] == SSL3_RT_APPLICATION_DATA && ( pkt [ 3 ] << 8 | pkt [ 4 ] ) >= 128 ) { memmove ( rb -> buf + align , pkt , left ) ; rb -> offset = align ; } } s -> packet = rb -> buf + rb -> offset ; s -> packet_length = 0 ; } if ( SSL_IS_DTLS ( s ) ) {  if ( left > 0 && n > left )  n = left ; } if ( left >= n ) { s -> packet_length += n ; rb -> left = left - n ; rb -> offset += n ; return ( n ) ; } len = s -> packet_length ; pkt = rb -> buf + align ; if ( s -> packet != pkt ) { memmove ( pkt , s -> packet , len + left ) ; s -> packet = pkt ; rb -> offset = len + align ; } if ( n > ( int ) ( rb -> len - rb -> offset ) ) { SSLerr ( SSL_F_SSL3_READ_N , ERR_R_INTERNAL_ERROR ) ; return - 1 ; } if ( ! s -> read_ahead ) max = n ; else { if ( max < n ) max = n ; if ( max > ( int ) ( rb -> len - rb -> offset ) ) max = rb -> len - rb -> offset ; } while ( left < n ) { clear_sys_error ( ) ; if ( s -> rbio != NULL ) { s -> rwstate = SSL_READING ; i = BIO_read ( s -> rbio , pkt + len + left , max - left ) ; } else { SSLerr ( SSL_F_SSL3_READ_N , SSL_R_READ_BIO_NOT_SET ) ; i = - 1 ; } if ( i <= 0 ) { rb -> left = left ; if ( s -> mode & SSL_MODE_RELEASE_BUFFERS && ! SSL_IS_DTLS ( s ) ) if ( len + left == 0 ) ssl3_release_read_buffer ( s ) ; return ( i ) ; } left += i ; if ( SSL_IS_DTLS ( s ) ) { if ( n > left ) n = left ; } } rb -> offset += n ; rb -> left = left - n ; s -> packet_length += n ; s -> rwstate = SSL_NOTHING ; return ( n ) ; }",if ( left > 0 && n > left ) n = left ;,177
252,"buggy line: # ifndef _MSC_VER   char buf [ EXT2_BLOCK_SIZE ( data ) ] ;# else char * buf = grub_malloc ( EXT2_BLOCK_SIZE ( data ) ) ;# endif struct grub_ext4_extent_header * leaf ;grub_error ( GRUB_ERR_BAD_FS , ""invalid<S2SV_blank>extent"" ) ;return - 1 ;cwe id:CWE-119context: static grub_disk_addr_t grub_ext2_read_block ( grub_fshelp_node_t node , grub_disk_addr_t fileblock ) { struct grub_ext2_data * data = node -> data ; struct grub_ext2_inode * inode = & node -> inode ; int blknr = - 1 ; unsigned int blksz = EXT2_BLOCK_SIZE ( data ) ; int log2_blksz = LOG2_EXT2_BLOCK_SIZE ( data ) ; if ( grub_le_to_cpu32 ( inode -> flags ) & EXT4_EXTENTS_FLAG ) {  # ifndef _MSC_VER   char buf [ EXT2_BLOCK_SIZE ( data ) ] ;  # else char * buf = grub_malloc ( EXT2_BLOCK_SIZE ( data ) ) ; # endif struct grub_ext4_extent_header * leaf ; struct grub_ext4_extent * ext ; int i ; leaf = grub_ext4_find_leaf ( data , buf , ( struct grub_ext4_extent_header * ) inode -> blocks . dir_blocks , fileblock ) ; if ( ! leaf ) {  grub_error ( GRUB_ERR_BAD_FS , ""invalid<S2SV_blank>extent"" ) ;  return - 1 ; } ext = ( struct grub_ext4_extent * ) ( leaf + 1 ) ; for ( i = 0 ; i < grub_le_to_cpu16 ( leaf -> entries ) ; i ++ ) { if ( fileblock < grub_le_to_cpu32 ( ext [ i ] . block ) ) break ; } if ( -- i >= 0 ) { fileblock -= grub_le_to_cpu32 ( ext [ i ] . block ) ;  if ( fileblock >= grub_le_to_cpu16 ( ext [ i ] . len ) )  return 0 ;  else  { grub_disk_addr_t start ; start = grub_le_to_cpu16 ( ext [ i ] . start_hi ) ; start = ( start << 32 ) + grub_le_to_cpu32 ( ext [ i ] . start ) ;  return fileblock + start ;  } } else { grub_error ( GRUB_ERR_BAD_FS , ""something<S2SV_blank>wrong<S2SV_blank>with<S2SV_blank>extent"" ) ;  return - 1 ;   }  } if ( fileblock < INDIRECT_BLOCKS ) { blknr = grub_le_to_cpu32 ( inode -> blocks . dir_blocks [ fileblock ] ) ; } else if ( fileblock < INDIRECT_BLOCKS + blksz / 4 ) { grub_uint32_t * indir ; indir = grub_malloc ( blksz ) ;  if ( ! indir )   return grub_errno ;  if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . indir_block ) ) << log2_blksz ,  0 , blksz , indir ) )   return grub_errno ;  blknr = grub_le_to_cpu32 ( indir [ fileblock - INDIRECT_BLOCKS ] ) ; grub_free ( indir ) ; } else if ( fileblock < ( grub_disk_addr_t ) ( INDIRECT_BLOCKS + blksz / 4 ) * ( grub_disk_addr_t ) ( blksz / 4 + 1 ) ) { unsigned int perblock = blksz / 4 ; unsigned int rblock = fileblock - ( INDIRECT_BLOCKS + blksz / 4 ) ; grub_uint32_t * indir ; indir = grub_malloc ( blksz ) ;  if ( ! indir )   return grub_errno ;  if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . double_indir_block ) ) << log2_blksz ,  0 , blksz , indir ) )   return grub_errno ;  if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( indir [ rblock / perblock ] ) ) << log2_blksz ,  0 , blksz , indir ) )   return grub_errno ;  blknr = grub_le_to_cpu32 ( indir [ rblock % perblock ] ) ; grub_free ( indir ) ; } else { grub_error ( GRUB_ERR_NOT_IMPLEMENTED_YET , ""ext2fs<S2SV_blank>doesn\'t<S2SV_blank>support<S2SV_blank>triple<S2SV_blank>indirect<S2SV_blank>blocks"" ) ; } return blknr ; }","char * buf = grub_malloc ( EXT2_BLOCK_SIZE ( data ) ] ;# else char * buf = grub_malloc ( EXT2_BLOCK_SIZE ( data ) ) ;if ( ! buf ) {return - 1 ;}struct grub_ext4_extent_header * leaf ;grub_error ( GRUB_ERR_BAD_FS , ""invalid<S2SV_blank>extent"" ) ;free ( buf ) ;return - 1 ;",178
253,"buggy line: if ( fileblock >= grub_le_to_cpu16 ( ext [ i ] . len ) )  return 0 ;else  {return fileblock + start ;}return - 1 ;}}if ( ! indir )   return grub_errno ;if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . indir_block ) ) << log2_blksz ,  0 , blksz , indir ) )   return grub_errno ;blknr = grub_le_to_cpu32 ( indir [ fileblock - INDIRECT_BLOCKS ] ) ;cwe id:CWE-119context: static grub_disk_addr_t grub_ext2_read_block ( grub_fshelp_node_t node , grub_disk_addr_t fileblock ) { struct grub_ext2_data * data = node -> data ; struct grub_ext2_inode * inode = & node -> inode ; int blknr = - 1 ; unsigned int blksz = EXT2_BLOCK_SIZE ( data ) ; int log2_blksz = LOG2_EXT2_BLOCK_SIZE ( data ) ; if ( grub_le_to_cpu32 ( inode -> flags ) & EXT4_EXTENTS_FLAG ) {  # ifndef _MSC_VER   char buf [ EXT2_BLOCK_SIZE ( data ) ] ;  # else char * buf = grub_malloc ( EXT2_BLOCK_SIZE ( data ) ) ; # endif struct grub_ext4_extent_header * leaf ; struct grub_ext4_extent * ext ; int i ; leaf = grub_ext4_find_leaf ( data , buf , ( struct grub_ext4_extent_header * ) inode -> blocks . dir_blocks , fileblock ) ; if ( ! leaf ) {  grub_error ( GRUB_ERR_BAD_FS , ""invalid<S2SV_blank>extent"" ) ;  return - 1 ; } ext = ( struct grub_ext4_extent * ) ( leaf + 1 ) ; for ( i = 0 ; i < grub_le_to_cpu16 ( leaf -> entries ) ; i ++ ) { if ( fileblock < grub_le_to_cpu32 ( ext [ i ] . block ) ) break ; } if ( -- i >= 0 ) { fileblock -= grub_le_to_cpu32 ( ext [ i ] . block ) ;  if ( fileblock >= grub_le_to_cpu16 ( ext [ i ] . len ) )  return 0 ;  else  { grub_disk_addr_t start ; start = grub_le_to_cpu16 ( ext [ i ] . start_hi ) ; start = ( start << 32 ) + grub_le_to_cpu32 ( ext [ i ] . start ) ;  return fileblock + start ;  } } else { grub_error ( GRUB_ERR_BAD_FS , ""something<S2SV_blank>wrong<S2SV_blank>with<S2SV_blank>extent"" ) ;  return - 1 ;   }  } if ( fileblock < INDIRECT_BLOCKS ) { blknr = grub_le_to_cpu32 ( inode -> blocks . dir_blocks [ fileblock ] ) ; } else if ( fileblock < INDIRECT_BLOCKS + blksz / 4 ) { grub_uint32_t * indir ; indir = grub_malloc ( blksz ) ;  if ( ! indir )   return grub_errno ;  if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . indir_block ) ) << log2_blksz ,  0 , blksz , indir ) )   return grub_errno ;  blknr = grub_le_to_cpu32 ( indir [ fileblock - INDIRECT_BLOCKS ] ) ; grub_free ( indir ) ; } else if ( fileblock < ( grub_disk_addr_t ) ( INDIRECT_BLOCKS + blksz / 4 ) * ( grub_disk_addr_t ) ( blksz / 4 + 1 ) ) { unsigned int perblock = blksz / 4 ; unsigned int rblock = fileblock - ( INDIRECT_BLOCKS + blksz / 4 ) ; grub_uint32_t * indir ; indir = grub_malloc ( blksz ) ;  if ( ! indir )   return grub_errno ;  if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . double_indir_block ) ) << log2_blksz ,  0 , blksz , indir ) )   return grub_errno ;  if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( indir [ rblock / perblock ] ) ) << log2_blksz ,  0 , blksz , indir ) )   return grub_errno ;  blknr = grub_le_to_cpu32 ( indir [ rblock % perblock ] ) ; grub_free ( indir ) ; } else { grub_error ( GRUB_ERR_NOT_IMPLEMENTED_YET , ""ext2fs<S2SV_blank>doesn\'t<S2SV_blank>support<S2SV_blank>triple<S2SV_blank>indirect<S2SV_blank>blocks"" ) ; } return blknr ; }","if ( fileblock >= grub_le_to_cpu16 ( ext [ i ] . len ) ) {free ( buf ) ;return 0 ;}else {free ( buf ) ;return fileblock + start ;}free ( buf ) ;return - 1 ;}free ( buf ) ;}if ( ! indir ) {return grub_errno ;}if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . indir_block ) ) << log2_blksz , 0 , blksz , indir ) ) {return grub_errno ;}blknr = grub_le_to_cpu32 ( indir [ fileblock - INDIRECT_BLOCKS ] ) ;",178
254,"buggy line: if ( ! indir )   return grub_errno ;if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . double_indir_block ) ) << log2_blksz ,  0 , blksz , indir ) )   return grub_errno ;if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( indir [ rblock / perblock ] ) ) << log2_blksz ,  0 , blksz , indir ) )   return grub_errno ;blknr = grub_le_to_cpu32 ( indir [ rblock % perblock ] ) ;cwe id:CWE-119context: static grub_disk_addr_t grub_ext2_read_block ( grub_fshelp_node_t node , grub_disk_addr_t fileblock ) { struct grub_ext2_data * data = node -> data ; struct grub_ext2_inode * inode = & node -> inode ; int blknr = - 1 ; unsigned int blksz = EXT2_BLOCK_SIZE ( data ) ; int log2_blksz = LOG2_EXT2_BLOCK_SIZE ( data ) ; if ( grub_le_to_cpu32 ( inode -> flags ) & EXT4_EXTENTS_FLAG ) {  # ifndef _MSC_VER   char buf [ EXT2_BLOCK_SIZE ( data ) ] ;  # else char * buf = grub_malloc ( EXT2_BLOCK_SIZE ( data ) ) ; # endif struct grub_ext4_extent_header * leaf ; struct grub_ext4_extent * ext ; int i ; leaf = grub_ext4_find_leaf ( data , buf , ( struct grub_ext4_extent_header * ) inode -> blocks . dir_blocks , fileblock ) ; if ( ! leaf ) {  grub_error ( GRUB_ERR_BAD_FS , ""invalid<S2SV_blank>extent"" ) ;  return - 1 ; } ext = ( struct grub_ext4_extent * ) ( leaf + 1 ) ; for ( i = 0 ; i < grub_le_to_cpu16 ( leaf -> entries ) ; i ++ ) { if ( fileblock < grub_le_to_cpu32 ( ext [ i ] . block ) ) break ; } if ( -- i >= 0 ) { fileblock -= grub_le_to_cpu32 ( ext [ i ] . block ) ;  if ( fileblock >= grub_le_to_cpu16 ( ext [ i ] . len ) )  return 0 ;  else  { grub_disk_addr_t start ; start = grub_le_to_cpu16 ( ext [ i ] . start_hi ) ; start = ( start << 32 ) + grub_le_to_cpu32 ( ext [ i ] . start ) ;  return fileblock + start ;  } } else { grub_error ( GRUB_ERR_BAD_FS , ""something<S2SV_blank>wrong<S2SV_blank>with<S2SV_blank>extent"" ) ;  return - 1 ;   }  } if ( fileblock < INDIRECT_BLOCKS ) { blknr = grub_le_to_cpu32 ( inode -> blocks . dir_blocks [ fileblock ] ) ; } else if ( fileblock < INDIRECT_BLOCKS + blksz / 4 ) { grub_uint32_t * indir ; indir = grub_malloc ( blksz ) ;  if ( ! indir )   return grub_errno ;  if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . indir_block ) ) << log2_blksz ,  0 , blksz , indir ) )   return grub_errno ;  blknr = grub_le_to_cpu32 ( indir [ fileblock - INDIRECT_BLOCKS ] ) ; grub_free ( indir ) ; } else if ( fileblock < ( grub_disk_addr_t ) ( INDIRECT_BLOCKS + blksz / 4 ) * ( grub_disk_addr_t ) ( blksz / 4 + 1 ) ) { unsigned int perblock = blksz / 4 ; unsigned int rblock = fileblock - ( INDIRECT_BLOCKS + blksz / 4 ) ; grub_uint32_t * indir ; indir = grub_malloc ( blksz ) ;  if ( ! indir )   return grub_errno ;  if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . double_indir_block ) ) << log2_blksz ,  0 , blksz , indir ) )   return grub_errno ;  if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( indir [ rblock / perblock ] ) ) << log2_blksz ,  0 , blksz , indir ) )   return grub_errno ;  blknr = grub_le_to_cpu32 ( indir [ rblock % perblock ] ) ; grub_free ( indir ) ; } else { grub_error ( GRUB_ERR_NOT_IMPLEMENTED_YET , ""ext2fs<S2SV_blank>doesn\'t<S2SV_blank>support<S2SV_blank>triple<S2SV_blank>indirect<S2SV_blank>blocks"" ) ; } return blknr ; }","if ( ! indir ) {return grub_errno ;}if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . double_indir_block ) ) << log2_blksz , 0 , blksz , indir ) ) {return grub_errno ;}if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( indir [ rblock / perblock ] ) ) << log2_blksz , 0 , blksz , indir ) ) {return grub_errno ;}blknr = grub_le_to_cpu32 ( indir [ rblock % perblock ] ) ;",178
255,"buggy line: UnpackRaster :  if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) {cwe id:CWE-119context: static Image * ReadWPGImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { typedef struct { size_t FileId ; MagickOffsetType DataOffset ; unsigned int ProductType ; unsigned int FileType ; unsigned char MajorVersion ; unsigned char MinorVersion ; unsigned int EncryptKey ; unsigned int Reserved ; } WPGHeader ; typedef struct { unsigned char RecType ; size_t RecordLength ; } WPGRecord ; typedef struct { unsigned char Class ; unsigned char RecType ; size_t Extension ; size_t RecordLength ; } WPG2Record ; typedef struct { unsigned HorizontalUnits ; unsigned VerticalUnits ; unsigned char PosSizePrecision ; } WPG2Start ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType1 ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned char Depth ; unsigned char Compression ; } WPG2BitmapType1 ; typedef struct { unsigned int RotAngle ; unsigned int LowLeftX ; unsigned int LowLeftY ; unsigned int UpRightX ; unsigned int UpRightY ; unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType2 ; typedef struct { unsigned int StartIndex ; unsigned int NumOfEntries ; } WPGColorMapRec ; Image * image ; unsigned int status ; WPGHeader Header ; WPGRecord Rec ; WPG2Record Rec2 ; WPG2Start StartWPG ; WPGBitmapType1 BitmapHeader1 ; WPG2BitmapType1 Bitmap2Header1 ; WPGBitmapType2 BitmapHeader2 ; WPGColorMapRec WPG_Palette ; int i , bpp , WPG2Flags ; ssize_t ldblk ; size_t one ; unsigned char * BImgBuff ; tCTM CTM ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; one = 1 ; image = AcquireImage ( image_info , exception ) ; image -> depth = 8 ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } Header . FileId = ReadBlobLSBLong ( image ) ; Header . DataOffset = ( MagickOffsetType ) ReadBlobLSBLong ( image ) ; Header . ProductType = ReadBlobLSBShort ( image ) ; Header . FileType = ReadBlobLSBShort ( image ) ; Header . MajorVersion = ReadBlobByte ( image ) ; Header . MinorVersion = ReadBlobByte ( image ) ; Header . EncryptKey = ReadBlobLSBShort ( image ) ; Header . Reserved = ReadBlobLSBShort ( image ) ; if ( Header . FileId != 0x435057FF || ( Header . ProductType >> 8 ) != 0x16 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( Header . EncryptKey != 0 ) ThrowReaderException ( CoderError , ""EncryptedWPGImageFileNotSupported"" ) ; image -> columns = 1 ; image -> rows = 1 ; image -> colors = 0 ; bpp = 0 ; BitmapHeader2 . RotAngle = 0 ; switch ( Header . FileType ) { case 1 : while ( ! EOFBlob ( image ) ) { ( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ; if ( EOFBlob ( image ) ) break ; Rec . RecType = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rd_WP_DWORD ( image , & Rec . RecordLength ) ; if ( EOFBlob ( image ) ) break ; Header . DataOffset = TellBlob ( image ) + Rec . RecordLength ; switch ( Rec . RecType ) { case 0x0B : BitmapHeader1 . Width = ReadBlobLSBShort ( image ) ; BitmapHeader1 . Height = ReadBlobLSBShort ( image ) ; if ( ( BitmapHeader1 . Width == 0 ) || ( BitmapHeader1 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; BitmapHeader1 . Depth = ReadBlobLSBShort ( image ) ; BitmapHeader1 . HorzRes = ReadBlobLSBShort ( image ) ; BitmapHeader1 . VertRes = ReadBlobLSBShort ( image ) ; if ( BitmapHeader1 . HorzRes && BitmapHeader1 . VertRes ) { image -> units = PixelsPerCentimeterResolution ; image -> resolution . x = BitmapHeader1 . HorzRes / 470.0 ; image -> resolution . y = BitmapHeader1 . VertRes / 470.0 ; } image -> columns = BitmapHeader1 . Width ; image -> rows = BitmapHeader1 . Height ; bpp = BitmapHeader1 . Depth ; goto UnpackRaster ; case 0x0E : WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ; WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ; image -> colors = WPG_Palette . NumOfEntries ; if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) goto NoMemory ; for ( i = WPG_Palette . StartIndex ; i < ( int ) WPG_Palette . NumOfEntries ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; } break ; case 0x11 : if ( Rec . RecordLength > 8 ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + 8 , ( ssize_t ) Rec . RecordLength - 8 , exception ) ; break ; case 0x14 : BitmapHeader2 . RotAngle = ReadBlobLSBShort ( image ) ; BitmapHeader2 . LowLeftX = ReadBlobLSBShort ( image ) ; BitmapHeader2 . LowLeftY = ReadBlobLSBShort ( image ) ; BitmapHeader2 . UpRightX = ReadBlobLSBShort ( image ) ; BitmapHeader2 . UpRightY = ReadBlobLSBShort ( image ) ; BitmapHeader2 . Width = ReadBlobLSBShort ( image ) ; BitmapHeader2 . Height = ReadBlobLSBShort ( image ) ; if ( ( BitmapHeader2 . Width == 0 ) || ( BitmapHeader2 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; BitmapHeader2 . Depth = ReadBlobLSBShort ( image ) ; BitmapHeader2 . HorzRes = ReadBlobLSBShort ( image ) ; BitmapHeader2 . VertRes = ReadBlobLSBShort ( image ) ; image -> units = PixelsPerCentimeterResolution ; image -> page . width = ( unsigned int ) ( ( BitmapHeader2 . LowLeftX - BitmapHeader2 . UpRightX ) / 470.0 ) ; image -> page . height = ( unsigned int ) ( ( BitmapHeader2 . LowLeftX - BitmapHeader2 . UpRightY ) / 470.0 ) ; image -> page . x = ( int ) ( BitmapHeader2 . LowLeftX / 470.0 ) ; image -> page . y = ( int ) ( BitmapHeader2 . LowLeftX / 470.0 ) ; if ( BitmapHeader2 . HorzRes && BitmapHeader2 . VertRes ) { image -> resolution . x = BitmapHeader2 . HorzRes / 470.0 ; image -> resolution . y = BitmapHeader2 . VertRes / 470.0 ; } image -> columns = BitmapHeader2 . Width ; image -> rows = BitmapHeader2 . Height ; bpp = BitmapHeader2 . Depth ;  UnpackRaster :  if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) { image -> colors = one << bpp ; if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) { NoMemory : ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } for ( i = 0 ; ( i < ( int ) image -> colors ) && ( i < 256 ) ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( WPG1_Palette [ i ] . Red ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( WPG1_Palette [ i ] . Green ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( WPG1_Palette [ i ] . Blue ) ; } } else { if ( bpp < 24 ) if ( ( image -> colors < ( one << bpp ) ) && ( bpp != 24 ) ) image -> colormap = ( PixelInfo * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ; } if ( bpp == 1 ) { if ( image -> colormap [ 0 ] . red == 0 && image -> colormap [ 0 ] . green == 0 && image -> colormap [ 0 ] . blue == 0 && image -> colormap [ 1 ] . red == 0 && image -> colormap [ 1 ] . green == 0 && image -> colormap [ 1 ] . blue == 0 ) { image -> colormap [ 1 ] . red = image -> colormap [ 1 ] . green = image -> colormap [ 1 ] . blue = QuantumRange ; } } if ( UnpackWPGRaster ( image , bpp , exception ) < 0 ) { DecompressionFailed : ThrowReaderException ( CoderError , ""UnableToDecompressImage"" ) ; } if ( Rec . RecType == 0x14 && BitmapHeader2 . RotAngle != 0 && ! image_info -> ping ) { if ( BitmapHeader2 . RotAngle & 0x8000 ) { Image * flop_image ; flop_image = FlopImage ( image , exception ) ; if ( flop_image != ( Image * ) NULL ) { DuplicateBlob ( flop_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flop_image ) ; } } if ( BitmapHeader2 . RotAngle & 0x2000 ) { Image * flip_image ; flip_image = FlipImage ( image , exception ) ; if ( flip_image != ( Image * ) NULL ) { DuplicateBlob ( flip_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flip_image ) ; } } if ( BitmapHeader2 . RotAngle & 0x0FFF ) { Image * rotate_image ; rotate_image = RotateImage ( image , ( BitmapHeader2 . RotAngle & 0x0FFF ) , exception ) ; if ( rotate_image != ( Image * ) NULL ) { DuplicateBlob ( rotate_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , rotate_image ) ; } } } AcquireNextImage ( image_info , image , exception ) ; image -> depth = 8 ; if ( image -> next == ( Image * ) NULL ) goto Finish ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 1 ; image -> colors = 0 ; break ; case 0x1B : if ( Rec . RecordLength > 0x3C ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + 0x3C , ( ssize_t ) Rec . RecordLength - 0x3C , exception ) ; break ; } } break ; case 2 : ( void ) memset ( CTM , 0 , sizeof ( CTM ) ) ; StartWPG . PosSizePrecision = 0 ; while ( ! EOFBlob ( image ) ) { ( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ; if ( EOFBlob ( image ) ) break ; Rec2 . Class = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rec2 . RecType = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rd_WP_DWORD ( image , & Rec2 . Extension ) ; Rd_WP_DWORD ( image , & Rec2 . RecordLength ) ; if ( EOFBlob ( image ) ) break ; Header . DataOffset = TellBlob ( image ) + Rec2 . RecordLength ; switch ( Rec2 . RecType ) { case 1 : StartWPG . HorizontalUnits = ReadBlobLSBShort ( image ) ; StartWPG . VerticalUnits = ReadBlobLSBShort ( image ) ; StartWPG . PosSizePrecision = ReadBlobByte ( image ) ; break ; case 0x0C : WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ; WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ; image -> colors = WPG_Palette . NumOfEntries ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = WPG_Palette . StartIndex ; i < ( int ) WPG_Palette . NumOfEntries ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; ( void ) ReadBlobByte ( image ) ; } break ; case 0x0E : Bitmap2Header1 . Width = ReadBlobLSBShort ( image ) ; Bitmap2Header1 . Height = ReadBlobLSBShort ( image ) ; if ( ( Bitmap2Header1 . Width == 0 ) || ( Bitmap2Header1 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; Bitmap2Header1 . Depth = ReadBlobByte ( image ) ; Bitmap2Header1 . Compression = ReadBlobByte ( image ) ; if ( Bitmap2Header1 . Compression > 1 ) continue ; switch ( Bitmap2Header1 . Depth ) { case 1 : bpp = 1 ; break ; case 2 : bpp = 2 ; break ; case 3 : bpp = 4 ; break ; case 4 : bpp = 8 ; break ; case 8 : bpp = 24 ; break ; default : continue ; } image -> columns = Bitmap2Header1 . Width ;  image -> rows = Bitmap2Header1 . Height ;  if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) { size_t one ; one = 1 ; image -> colors = one << bpp ; if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) goto NoMemory ; } else { if ( bpp < 24 ) if ( image -> colors < ( one << bpp ) && bpp != 24 ) image -> colormap = ( PixelInfo * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ; } switch ( Bitmap2Header1 . Compression ) { case 0 : { ldblk = ( ssize_t ) ( ( bpp * image -> columns + 7 ) / 8 ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ldblk + 1 , sizeof ( * BImgBuff ) ) ; if ( BImgBuff == ( unsigned char * ) NULL ) goto NoMemory ; for ( i = 0 ; i < ( ssize_t ) image -> rows ; i ++ ) { ( void ) ReadBlob ( image , ldblk , BImgBuff ) ; InsertRow ( image , BImgBuff , i , bpp , exception ) ; } if ( BImgBuff ) BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ; break ; } case 1 : { if ( UnpackWPG2Raster ( image , bpp , exception ) < 0 ) goto DecompressionFailed ; break ; } } if ( CTM [ 0 ] [ 0 ] < 0 && ! image_info -> ping ) { Image * flop_image ; flop_image = FlopImage ( image , exception ) ; if ( flop_image != ( Image * ) NULL ) { DuplicateBlob ( flop_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flop_image ) ; } } if ( CTM [ 1 ] [ 1 ] < 0 && ! image_info -> ping ) { Image * flip_image ; flip_image = FlipImage ( image , exception ) ; if ( flip_image != ( Image * ) NULL ) { DuplicateBlob ( flip_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flip_image ) ; } } AcquireNextImage ( image_info , image , exception ) ; image -> depth = 8 ; if ( image -> next == ( Image * ) NULL ) goto Finish ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 1 ; image -> colors = 0 ; break ; case 0x12 : i = ReadBlobLSBShort ( image ) ; if ( Rec2 . RecordLength > ( unsigned int ) i ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + i , ( ssize_t ) ( Rec2 . RecordLength - i - 2 ) , exception ) ; break ; case 0x1B : WPG2Flags = LoadWPG2Flags ( image , StartWPG . PosSizePrecision , NULL , & CTM ) ; ( void ) WPG2Flags ; break ; } } break ; default : { ThrowReaderException ( CoderError , ""DataEncodingSchemeIsNotSupported"" ) ; } }  status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;  if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; Finish : ( void ) CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = ( size_t ) scene ++ ; } if ( image == ( Image * ) NULL ) ThrowReaderException ( CorruptImageError , ""ImageFileDoesNotContainAnyImageData"" ) ; return ( image ) ; }","UnpackRaster : status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;if ( status == MagickFalse ) break ;if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) {",179
256,"buggy line: else {if ( bpp < 24 ) if ( ( image -> colors < ( one << bpp ) ) && ( bpp != 24 ) ) image -> colormap = ( PixelInfo * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ;}if ( bpp == 1 ) {if ( image -> colormap [ 0 ] . red == 0 && image -> colormap [ 0 ] . green == 0 && image -> colormap [ 0 ] . blue == 0 && image -> colormap [ 1 ] . red == 0 && image -> colormap [ 1 ] . green == 0 && image -> colormap [ 1 ] . blue == 0 ) {image -> colormap [ 1 ] . red = image -> colormap [ 1 ] . green = image -> colormap [ 1 ] . blue = QuantumRange ;}}if ( UnpackWPGRaster ( image , bpp , exception ) < 0 ) {DecompressionFailed : ThrowReaderException ( CoderError , ""UnableToDecompressImage"" ) ;}if ( Rec . RecType == 0x14 && BitmapHeader2 . RotAngle != 0 && ! image_info -> ping ) {if ( BitmapHeader2 . RotAngle & 0x8000 ) {Image * flop_image ;flop_image = FlopImage ( image , exception ) ;if ( flop_image != ( Image * ) NULL ) {DuplicateBlob ( flop_image , image ) ;( void ) RemoveLastImageFromList ( & image ) ;AppendImageToList ( & image , flop_image ) ;}}if ( BitmapHeader2 . RotAngle & 0x2000 ) {Image * flip_image ;flip_image = FlipImage ( image , exception ) ;if ( flip_image != ( Image * ) NULL ) {DuplicateBlob ( flip_image , image ) ;( void ) RemoveLastImageFromList ( & image ) ;AppendImageToList ( & image , flip_image ) ;}}if ( BitmapHeader2 . RotAngle & 0x0FFF ) {Image * rotate_image ;rotate_image = RotateImage ( image , ( BitmapHeader2 . RotAngle & 0x0FFF ) , exception ) ;if ( rotate_image != ( Image * ) NULL ) {DuplicateBlob ( rotate_image , image ) ;( void ) RemoveLastImageFromList ( & image ) ;AppendImageToList ( & image , rotate_image ) ;}}}AcquireNextImage ( image_info , image , exception ) ;image -> depth = 8 ;if ( image -> next == ( Image * ) NULL ) goto Finish ;image = SyncNextImageInList ( image ) ;image -> columns = image -> rows = 1 ;image -> colors = 0 ;break ;case 0x1B : if ( Rec . RecordLength > 0x3C ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + 0x3C , ( ssize_t ) Rec . RecordLength - 0x3C , exception ) ;break ;}}break ;case 2 : ( void ) memset ( CTM , 0 , sizeof ( CTM ) ) ;StartWPG . PosSizePrecision = 0 ;while ( ! EOFBlob ( image ) ) {( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ;if ( EOFBlob ( image ) ) break ;Rec2 . Class = ( i = ReadBlobByte ( image ) ) ;if ( i == EOF ) break ;Rec2 . RecType = ( i = ReadBlobByte ( image ) ) ;if ( i == EOF ) break ;Rd_WP_DWORD ( image , & Rec2 . Extension ) ;Rd_WP_DWORD ( image , & Rec2 . RecordLength ) ;if ( EOFBlob ( image ) ) break ;Header . DataOffset = TellBlob ( image ) + Rec2 . RecordLength ;switch ( Rec2 . RecType ) {case 1 : StartWPG . HorizontalUnits = ReadBlobLSBShort ( image ) ;StartWPG . VerticalUnits = ReadBlobLSBShort ( image ) ;StartWPG . PosSizePrecision = ReadBlobByte ( image ) ;break ;case 0x0C : WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ;WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ;image -> colors = WPG_Palette . NumOfEntries ;if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;for ( i = WPG_Palette . StartIndex ;i < ( int ) WPG_Palette . NumOfEntries ;i ++ ) {image -> colormap [ i ] . red = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ;image -> colormap [ i ] . green = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ;image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ;( void ) ReadBlobByte ( image ) ;}break ;case 0x0E : Bitmap2Header1 . Width = ReadBlobLSBShort ( image ) ;Bitmap2Header1 . Height = ReadBlobLSBShort ( image ) ;if ( ( Bitmap2Header1 . Width == 0 ) || ( Bitmap2Header1 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;Bitmap2Header1 . Depth = ReadBlobByte ( image ) ;Bitmap2Header1 . Compression = ReadBlobByte ( image ) ;if ( Bitmap2Header1 . Compression > 1 ) continue ;switch ( Bitmap2Header1 . Depth ) {case 1 : bpp = 1 ;break ;case 2 : bpp = 2 ;break ;case 3 : bpp = 4 ;break ;case 4 : bpp = 8 ;break ;case 8 : bpp = 24 ;break ;default : continue ;}image -> columns = Bitmap2Header1 . Width ;image -> rows = Bitmap2Header1 . Height ;if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) {size_t one ;one = 1 ;image -> colors = one << bpp ;if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) goto NoMemory ;}else {if ( bpp < 24 ) if ( image -> colors < ( one << bpp ) && bpp != 24 ) image -> colormap = ( PixelInfo * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ;}switch ( Bitmap2Header1 . Compression ) {case 0 : {ldblk = ( ssize_t ) ( ( bpp * image -> columns + 7 ) / 8 ) ;BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ldblk + 1 , sizeof ( * BImgBuff ) ) ;if ( BImgBuff == ( unsigned char * ) NULL ) goto NoMemory ;for ( i = 0 ;i < ( ssize_t ) image -> rows ;i ++ ) {( void ) ReadBlob ( image , ldblk , BImgBuff ) ;InsertRow ( image , BImgBuff , i , bpp , exception ) ;}if ( BImgBuff ) BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ;break ;}case 1 : {if ( UnpackWPG2Raster ( image , bpp , exception ) < 0 ) goto DecompressionFailed ;break ;}}if ( CTM [ 0 ] [ 0 ] < 0 && ! image_info -> ping ) {Image * flop_image ;flop_image = FlopImage ( image , exception ) ;if ( flop_image != ( Image * ) NULL ) {DuplicateBlob ( flop_image , image ) ;( void ) RemoveLastImageFromList ( & image ) ;AppendImageToList ( & image , flop_image ) ;}}if ( CTM [ 1 ] [ 1 ] < 0 && ! image_info -> ping ) {Image * flip_image ;flip_image = FlipImage ( image , exception ) ;if ( flip_image != ( Image * ) NULL ) {DuplicateBlob ( flip_image , image ) ;( void ) RemoveLastImageFromList ( & image ) ;AppendImageToList ( & image , flip_image ) ;}}AcquireNextImage ( image_info , image , exception ) ;image -> depth = 8 ;if ( image -> next == ( Image * ) NULL ) goto Finish ;image = SyncNextImageInList ( image ) ;image -> columns = image -> rows = 1 ;image -> colors = 0 ;break ;case 0x12 : i = ReadBlobLSBShort ( image ) ;if ( Rec2 . RecordLength > ( unsigned int ) i ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + i , ( ssize_t ) ( Rec2 . RecordLength - i - 2 ) , exception ) ;break ;case 0x1B : WPG2Flags = LoadWPG2Flags ( image , StartWPG . PosSizePrecision , NULL , & CTM ) ;( void ) WPG2Flags ;break ;}}break ;default : {ThrowReaderException ( CoderError , ""DataEncodingSchemeIsNotSupported"" ) ;}}status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;cwe id:CWE-119context: static Image * ReadWPGImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { typedef struct { size_t FileId ; MagickOffsetType DataOffset ; unsigned int ProductType ; unsigned int FileType ; unsigned char MajorVersion ; unsigned char MinorVersion ; unsigned int EncryptKey ; unsigned int Reserved ; } WPGHeader ; typedef struct { unsigned char RecType ; size_t RecordLength ; } WPGRecord ; typedef struct { unsigned char Class ; unsigned char RecType ; size_t Extension ; size_t RecordLength ; } WPG2Record ; typedef struct { unsigned HorizontalUnits ; unsigned VerticalUnits ; unsigned char PosSizePrecision ; } WPG2Start ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType1 ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned char Depth ; unsigned char Compression ; } WPG2BitmapType1 ; typedef struct { unsigned int RotAngle ; unsigned int LowLeftX ; unsigned int LowLeftY ; unsigned int UpRightX ; unsigned int UpRightY ; unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType2 ; typedef struct { unsigned int StartIndex ; unsigned int NumOfEntries ; } WPGColorMapRec ; Image * image ; unsigned int status ; WPGHeader Header ; WPGRecord Rec ; WPG2Record Rec2 ; WPG2Start StartWPG ; WPGBitmapType1 BitmapHeader1 ; WPG2BitmapType1 Bitmap2Header1 ; WPGBitmapType2 BitmapHeader2 ; WPGColorMapRec WPG_Palette ; int i , bpp , WPG2Flags ; ssize_t ldblk ; size_t one ; unsigned char * BImgBuff ; tCTM CTM ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; one = 1 ; image = AcquireImage ( image_info , exception ) ; image -> depth = 8 ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } Header . FileId = ReadBlobLSBLong ( image ) ; Header . DataOffset = ( MagickOffsetType ) ReadBlobLSBLong ( image ) ; Header . ProductType = ReadBlobLSBShort ( image ) ; Header . FileType = ReadBlobLSBShort ( image ) ; Header . MajorVersion = ReadBlobByte ( image ) ; Header . MinorVersion = ReadBlobByte ( image ) ; Header . EncryptKey = ReadBlobLSBShort ( image ) ; Header . Reserved = ReadBlobLSBShort ( image ) ; if ( Header . FileId != 0x435057FF || ( Header . ProductType >> 8 ) != 0x16 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( Header . EncryptKey != 0 ) ThrowReaderException ( CoderError , ""EncryptedWPGImageFileNotSupported"" ) ; image -> columns = 1 ; image -> rows = 1 ; image -> colors = 0 ; bpp = 0 ; BitmapHeader2 . RotAngle = 0 ; switch ( Header . FileType ) { case 1 : while ( ! EOFBlob ( image ) ) { ( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ; if ( EOFBlob ( image ) ) break ; Rec . RecType = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rd_WP_DWORD ( image , & Rec . RecordLength ) ; if ( EOFBlob ( image ) ) break ; Header . DataOffset = TellBlob ( image ) + Rec . RecordLength ; switch ( Rec . RecType ) { case 0x0B : BitmapHeader1 . Width = ReadBlobLSBShort ( image ) ; BitmapHeader1 . Height = ReadBlobLSBShort ( image ) ; if ( ( BitmapHeader1 . Width == 0 ) || ( BitmapHeader1 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; BitmapHeader1 . Depth = ReadBlobLSBShort ( image ) ; BitmapHeader1 . HorzRes = ReadBlobLSBShort ( image ) ; BitmapHeader1 . VertRes = ReadBlobLSBShort ( image ) ; if ( BitmapHeader1 . HorzRes && BitmapHeader1 . VertRes ) { image -> units = PixelsPerCentimeterResolution ; image -> resolution . x = BitmapHeader1 . HorzRes / 470.0 ; image -> resolution . y = BitmapHeader1 . VertRes / 470.0 ; } image -> columns = BitmapHeader1 . Width ; image -> rows = BitmapHeader1 . Height ; bpp = BitmapHeader1 . Depth ; goto UnpackRaster ; case 0x0E : WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ; WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ; image -> colors = WPG_Palette . NumOfEntries ; if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) goto NoMemory ; for ( i = WPG_Palette . StartIndex ; i < ( int ) WPG_Palette . NumOfEntries ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; } break ; case 0x11 : if ( Rec . RecordLength > 8 ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + 8 , ( ssize_t ) Rec . RecordLength - 8 , exception ) ; break ; case 0x14 : BitmapHeader2 . RotAngle = ReadBlobLSBShort ( image ) ; BitmapHeader2 . LowLeftX = ReadBlobLSBShort ( image ) ; BitmapHeader2 . LowLeftY = ReadBlobLSBShort ( image ) ; BitmapHeader2 . UpRightX = ReadBlobLSBShort ( image ) ; BitmapHeader2 . UpRightY = ReadBlobLSBShort ( image ) ; BitmapHeader2 . Width = ReadBlobLSBShort ( image ) ; BitmapHeader2 . Height = ReadBlobLSBShort ( image ) ; if ( ( BitmapHeader2 . Width == 0 ) || ( BitmapHeader2 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; BitmapHeader2 . Depth = ReadBlobLSBShort ( image ) ; BitmapHeader2 . HorzRes = ReadBlobLSBShort ( image ) ; BitmapHeader2 . VertRes = ReadBlobLSBShort ( image ) ; image -> units = PixelsPerCentimeterResolution ; image -> page . width = ( unsigned int ) ( ( BitmapHeader2 . LowLeftX - BitmapHeader2 . UpRightX ) / 470.0 ) ; image -> page . height = ( unsigned int ) ( ( BitmapHeader2 . LowLeftX - BitmapHeader2 . UpRightY ) / 470.0 ) ; image -> page . x = ( int ) ( BitmapHeader2 . LowLeftX / 470.0 ) ; image -> page . y = ( int ) ( BitmapHeader2 . LowLeftX / 470.0 ) ; if ( BitmapHeader2 . HorzRes && BitmapHeader2 . VertRes ) { image -> resolution . x = BitmapHeader2 . HorzRes / 470.0 ; image -> resolution . y = BitmapHeader2 . VertRes / 470.0 ; } image -> columns = BitmapHeader2 . Width ; image -> rows = BitmapHeader2 . Height ; bpp = BitmapHeader2 . Depth ;  UnpackRaster :  if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) { image -> colors = one << bpp ; if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) { NoMemory : ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } for ( i = 0 ; ( i < ( int ) image -> colors ) && ( i < 256 ) ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( WPG1_Palette [ i ] . Red ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( WPG1_Palette [ i ] . Green ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( WPG1_Palette [ i ] . Blue ) ; } } else { if ( bpp < 24 ) if ( ( image -> colors < ( one << bpp ) ) && ( bpp != 24 ) ) image -> colormap = ( PixelInfo * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ; } if ( bpp == 1 ) { if ( image -> colormap [ 0 ] . red == 0 && image -> colormap [ 0 ] . green == 0 && image -> colormap [ 0 ] . blue == 0 && image -> colormap [ 1 ] . red == 0 && image -> colormap [ 1 ] . green == 0 && image -> colormap [ 1 ] . blue == 0 ) { image -> colormap [ 1 ] . red = image -> colormap [ 1 ] . green = image -> colormap [ 1 ] . blue = QuantumRange ; } } if ( UnpackWPGRaster ( image , bpp , exception ) < 0 ) { DecompressionFailed : ThrowReaderException ( CoderError , ""UnableToDecompressImage"" ) ; } if ( Rec . RecType == 0x14 && BitmapHeader2 . RotAngle != 0 && ! image_info -> ping ) { if ( BitmapHeader2 . RotAngle & 0x8000 ) { Image * flop_image ; flop_image = FlopImage ( image , exception ) ; if ( flop_image != ( Image * ) NULL ) { DuplicateBlob ( flop_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flop_image ) ; } } if ( BitmapHeader2 . RotAngle & 0x2000 ) { Image * flip_image ; flip_image = FlipImage ( image , exception ) ; if ( flip_image != ( Image * ) NULL ) { DuplicateBlob ( flip_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flip_image ) ; } } if ( BitmapHeader2 . RotAngle & 0x0FFF ) { Image * rotate_image ; rotate_image = RotateImage ( image , ( BitmapHeader2 . RotAngle & 0x0FFF ) , exception ) ; if ( rotate_image != ( Image * ) NULL ) { DuplicateBlob ( rotate_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , rotate_image ) ; } } } AcquireNextImage ( image_info , image , exception ) ; image -> depth = 8 ; if ( image -> next == ( Image * ) NULL ) goto Finish ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 1 ; image -> colors = 0 ; break ; case 0x1B : if ( Rec . RecordLength > 0x3C ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + 0x3C , ( ssize_t ) Rec . RecordLength - 0x3C , exception ) ; break ; } } break ; case 2 : ( void ) memset ( CTM , 0 , sizeof ( CTM ) ) ; StartWPG . PosSizePrecision = 0 ; while ( ! EOFBlob ( image ) ) { ( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ; if ( EOFBlob ( image ) ) break ; Rec2 . Class = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rec2 . RecType = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rd_WP_DWORD ( image , & Rec2 . Extension ) ; Rd_WP_DWORD ( image , & Rec2 . RecordLength ) ; if ( EOFBlob ( image ) ) break ; Header . DataOffset = TellBlob ( image ) + Rec2 . RecordLength ; switch ( Rec2 . RecType ) { case 1 : StartWPG . HorizontalUnits = ReadBlobLSBShort ( image ) ; StartWPG . VerticalUnits = ReadBlobLSBShort ( image ) ; StartWPG . PosSizePrecision = ReadBlobByte ( image ) ; break ; case 0x0C : WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ; WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ; image -> colors = WPG_Palette . NumOfEntries ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = WPG_Palette . StartIndex ; i < ( int ) WPG_Palette . NumOfEntries ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; ( void ) ReadBlobByte ( image ) ; } break ; case 0x0E : Bitmap2Header1 . Width = ReadBlobLSBShort ( image ) ; Bitmap2Header1 . Height = ReadBlobLSBShort ( image ) ; if ( ( Bitmap2Header1 . Width == 0 ) || ( Bitmap2Header1 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; Bitmap2Header1 . Depth = ReadBlobByte ( image ) ; Bitmap2Header1 . Compression = ReadBlobByte ( image ) ; if ( Bitmap2Header1 . Compression > 1 ) continue ; switch ( Bitmap2Header1 . Depth ) { case 1 : bpp = 1 ; break ; case 2 : bpp = 2 ; break ; case 3 : bpp = 4 ; break ; case 4 : bpp = 8 ; break ; case 8 : bpp = 24 ; break ; default : continue ; } image -> columns = Bitmap2Header1 . Width ;  image -> rows = Bitmap2Header1 . Height ;  if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) { size_t one ; one = 1 ; image -> colors = one << bpp ; if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) goto NoMemory ; } else { if ( bpp < 24 ) if ( image -> colors < ( one << bpp ) && bpp != 24 ) image -> colormap = ( PixelInfo * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ; } switch ( Bitmap2Header1 . Compression ) { case 0 : { ldblk = ( ssize_t ) ( ( bpp * image -> columns + 7 ) / 8 ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ldblk + 1 , sizeof ( * BImgBuff ) ) ; if ( BImgBuff == ( unsigned char * ) NULL ) goto NoMemory ; for ( i = 0 ; i < ( ssize_t ) image -> rows ; i ++ ) { ( void ) ReadBlob ( image , ldblk , BImgBuff ) ; InsertRow ( image , BImgBuff , i , bpp , exception ) ; } if ( BImgBuff ) BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ; break ; } case 1 : { if ( UnpackWPG2Raster ( image , bpp , exception ) < 0 ) goto DecompressionFailed ; break ; } } if ( CTM [ 0 ] [ 0 ] < 0 && ! image_info -> ping ) { Image * flop_image ; flop_image = FlopImage ( image , exception ) ; if ( flop_image != ( Image * ) NULL ) { DuplicateBlob ( flop_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flop_image ) ; } } if ( CTM [ 1 ] [ 1 ] < 0 && ! image_info -> ping ) { Image * flip_image ; flip_image = FlipImage ( image , exception ) ; if ( flip_image != ( Image * ) NULL ) { DuplicateBlob ( flip_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flip_image ) ; } } AcquireNextImage ( image_info , image , exception ) ; image -> depth = 8 ; if ( image -> next == ( Image * ) NULL ) goto Finish ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 1 ; image -> colors = 0 ; break ; case 0x12 : i = ReadBlobLSBShort ( image ) ; if ( Rec2 . RecordLength > ( unsigned int ) i ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + i , ( ssize_t ) ( Rec2 . RecordLength - i - 2 ) , exception ) ; break ; case 0x1B : WPG2Flags = LoadWPG2Flags ( image , StartWPG . PosSizePrecision , NULL , & CTM ) ; ( void ) WPG2Flags ; break ; } } break ; default : { ThrowReaderException ( CoderError , ""DataEncodingSchemeIsNotSupported"" ) ; } }  status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;  if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; Finish : ( void ) CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = ( size_t ) scene ++ ; } if ( image == ( Image * ) NULL ) ThrowReaderException ( CorruptImageError , ""ImageFileDoesNotContainAnyImageData"" ) ; return ( image ) ; }","
",179
257,"buggy line: if ( copy_from_user ( & hdr , ( void * ) arg , sizeof ( hdr ) ) ) return - EFAULT ;if ( hdr . version != VBG_IOCTL_HDR_VERSION ) return - EINVAL ;if ( hdr . size_in < sizeof ( hdr ) || ( hdr . size_out && hdr . size_out < sizeof ( hdr ) ) ) return - EINVAL ;size = max ( hdr . size_in , hdr . size_out ) ;if ( _IOC_SIZE ( req ) && _IOC_SIZE ( req ) != size ) return - EINVAL ;if ( size > SZ_16M ) return - E2BIG ;is_vmmdev_req = ( req & ~ IOCSIZE_MASK ) == VBG_IOCTL_VMMDEV_REQUEST ( 0 ) || req == VBG_IOCTL_VMMDEV_REQUEST_BIG ;if ( is_vmmdev_req ) buf = vbg_req_alloc ( size , VBG_IOCTL_HDR_TYPE_DEFAULT ) ;else buf = kmalloc ( size , GFP_KERNEL ) ;if ( ! buf ) return - ENOMEM ;if ( copy_from_user ( buf , ( void * ) arg , hdr . size_in ) ) {ret = - EFAULT ;cwe id:CWE-362context: static long vbg_misc_device_ioctl ( struct file * filp , unsigned int req , unsigned long arg ) { struct vbg_session * session = filp -> private_data ; size_t returned_size , size ; struct vbg_ioctl_hdr hdr ; bool is_vmmdev_req ; int ret = 0 ; void * buf ; if ( copy_from_user ( & hdr , ( void * ) arg , sizeof ( hdr ) ) ) return - EFAULT ; if ( hdr . version != VBG_IOCTL_HDR_VERSION ) return - EINVAL ; if ( hdr . size_in < sizeof ( hdr ) || ( hdr . size_out && hdr . size_out < sizeof ( hdr ) ) ) return - EINVAL ; size = max ( hdr . size_in , hdr . size_out ) ; if ( _IOC_SIZE ( req ) && _IOC_SIZE ( req ) != size ) return - EINVAL ; if ( size > SZ_16M ) return - E2BIG ; is_vmmdev_req = ( req & ~ IOCSIZE_MASK ) == VBG_IOCTL_VMMDEV_REQUEST ( 0 ) || req == VBG_IOCTL_VMMDEV_REQUEST_BIG ; if ( is_vmmdev_req ) buf = vbg_req_alloc ( size , VBG_IOCTL_HDR_TYPE_DEFAULT ) ; else buf = kmalloc ( size , GFP_KERNEL ) ; if ( ! buf ) return - ENOMEM ;  if ( copy_from_user ( buf , ( void * ) arg , hdr . size_in ) ) {  ret = - EFAULT ; goto out ; } if ( hdr . size_in < size ) memset ( buf + hdr . size_in , 0 , size - hdr . size_in ) ; ret = vbg_core_ioctl ( session , req , buf ) ; if ( ret ) goto out ; returned_size = ( ( struct vbg_ioctl_hdr * ) buf ) -> size_out ; if ( returned_size > size ) { vbg_debug ( ""%s:<S2SV_blank>too<S2SV_blank>much<S2SV_blank>output<S2SV_blank>data<S2SV_blank>%zu<S2SV_blank>><S2SV_blank>%zu\\n"" , __func__ , returned_size , size ) ; returned_size = size ; } if ( copy_to_user ( ( void * ) arg , buf , returned_size ) != 0 ) ret = - EFAULT ; out : if ( is_vmmdev_req ) vbg_req_free ( buf , size ) ; else kfree ( buf ) ; return ret ; }","if ( copy_from_user ( & hdr , ( void * ) arg + sizeof ( hdr ) , hdr . size_in - sizeof ( hdr ) ) ) {ret = - EFAULT ;",180
258,"buggy line: int hstartcol ;if ( bufsize > QMFB_SPLITBUFSIZE ) {if ( ! ( buf = jas_alloc2 ( bufsize , sizeof ( jpc_fix_t ) ) ) ) {abort ( ) ;hstartcol = ( numrows + 1 - parity ) >> 1 ;m = numrows - hstartcol ;n = m ;srcptr = & a [ ( 1 - parity ) * stride ] ;cwe id:CWE-119context: void jpc_qmfb_split_colgrp ( jpc_fix_t * a , int numrows , int stride , int parity ) { int bufsize = JPC_CEILDIVPOW2 ( numrows , 1 ) ; jpc_fix_t splitbuf [ QMFB_SPLITBUFSIZE * JPC_QMFB_COLGRPSIZE ] ; jpc_fix_t * buf = splitbuf ; jpc_fix_t * srcptr ; jpc_fix_t * dstptr ; register jpc_fix_t * srcptr2 ; register jpc_fix_t * dstptr2 ; register int n ; register int i ; int m ;  int hstartcol ;  if ( bufsize > QMFB_SPLITBUFSIZE ) {  if ( ! ( buf = jas_alloc2 ( bufsize , sizeof ( jpc_fix_t ) ) ) ) {  abort ( ) ; } } if ( numrows >= 2 ) {  hstartcol = ( numrows + 1 - parity ) >> 1 ;   m = numrows - hstartcol ;  n = m ; dstptr = buf ; srcptr = & a [ ( 1 - parity ) * stride ] ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < JPC_QMFB_COLGRPSIZE ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += JPC_QMFB_COLGRPSIZE ; srcptr += stride << 1 ; } dstptr = & a [ ( 1 - parity ) * stride ] ; srcptr = & a [ ( 2 - parity ) * stride ] ; n = numrows - m - ( ! parity ) ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < JPC_QMFB_COLGRPSIZE ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += stride ; srcptr += stride << 1 ; }  dstptr = & a [ hstartcol * stride ] ;  srcptr = buf ; n = m ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < JPC_QMFB_COLGRPSIZE ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += stride ; srcptr += JPC_QMFB_COLGRPSIZE ; } } if ( buf != splitbuf ) { jas_free ( buf ) ; } }","int hstartrow ;if ( bufsize > QMFB_SPLITBUFSIZE ) {if ( ! ( buf = jas_alloc3 ( bufsize , JPC_QMFB_COLGRPSIZE , sizeof ( jpc_fix_t ) ) ) ) {abort ( ) ;hstartrow = ( numrows + 1 - parity ) >> 1 ;m = numrows - hstartrow ;n = m ;srcptr = & a [ hstartrow * stride ] ;",181
259,"buggy line: dstptr = & a [ hstartcol * stride ] ;srcptr = buf ;cwe id:CWE-119context: void jpc_qmfb_split_colgrp ( jpc_fix_t * a , int numrows , int stride , int parity ) { int bufsize = JPC_CEILDIVPOW2 ( numrows , 1 ) ; jpc_fix_t splitbuf [ QMFB_SPLITBUFSIZE * JPC_QMFB_COLGRPSIZE ] ; jpc_fix_t * buf = splitbuf ; jpc_fix_t * srcptr ; jpc_fix_t * dstptr ; register jpc_fix_t * srcptr2 ; register jpc_fix_t * dstptr2 ; register int n ; register int i ; int m ;  int hstartcol ;  if ( bufsize > QMFB_SPLITBUFSIZE ) {  if ( ! ( buf = jas_alloc2 ( bufsize , sizeof ( jpc_fix_t ) ) ) ) {  abort ( ) ; } } if ( numrows >= 2 ) {  hstartcol = ( numrows + 1 - parity ) >> 1 ;   m = numrows - hstartcol ;  n = m ; dstptr = buf ; srcptr = & a [ ( 1 - parity ) * stride ] ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < JPC_QMFB_COLGRPSIZE ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += JPC_QMFB_COLGRPSIZE ; srcptr += stride << 1 ; } dstptr = & a [ ( 1 - parity ) * stride ] ; srcptr = & a [ ( 2 - parity ) * stride ] ; n = numrows - m - ( ! parity ) ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < JPC_QMFB_COLGRPSIZE ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += stride ; srcptr += stride << 1 ; }  dstptr = & a [ hstartcol * stride ] ;  srcptr = buf ; n = m ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < JPC_QMFB_COLGRPSIZE ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += stride ; srcptr += JPC_QMFB_COLGRPSIZE ; } } if ( buf != splitbuf ) { jas_free ( buf ) ; } }",dstptr = & a [ hstartcol * stride ] ;srcptr = buf ;,181
260,"buggy line: if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;}switch ( sun_info . maptype ) {case RMT_NONE : break ;case RMT_EQUAL_RGB : {unsigned char * sun_colormap ;sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , sizeof ( * sun_colormap ) ) ;if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;count = ReadBlob ( image , image -> colors , sun_colormap ) ;if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;for ( i = 0 ;i < ( ssize_t ) image -> colors ;i ++ ) image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ;count = ReadBlob ( image , image -> colors , sun_colormap ) ;if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;for ( i = 0 ;i < ( ssize_t ) image -> colors ;i ++ ) image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ;count = ReadBlob ( image , image -> colors , sun_colormap ) ;if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;for ( i = 0 ;i < ( ssize_t ) image -> colors ;i ++ ) image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ;sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ;break ;}case RMT_RAW : {unsigned char * sun_colormap ;sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( sun_info . maplength , sizeof ( * sun_colormap ) ) ;if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;count = ReadBlob ( image , sun_info . maplength , sun_colormap ) ;if ( count != ( ssize_t ) sun_info . maplength ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ;break ;}default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ;}image -> alpha_trait = sun_info . depth == 32 ? BlendPixelTrait : UndefinedPixelTrait ;image -> columns = sun_info . width ;image -> rows = sun_info . height ;if ( image_info -> ping != MagickFalse ) {( void ) CloseBlob ( image ) ;return ( GetFirstImageInList ( image ) ) ;}status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;if ( ( sun_info . length * sizeof ( * sun_data ) ) / sizeof ( * sun_data ) != sun_info . length || ! sun_info . length )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;number_pixels = ( MagickSizeType ) image -> columns * image -> rows ;cwe id:CWE-125context: static Image * ReadSUNImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define RMT_EQUAL_RGB 1 # define RMT_NONE 0 # define RMT_RAW 2 # define RT_STANDARD 1 # define RT_ENCODED 2 # define RT_FORMAT_RGB 3 typedef struct _SUNInfo { unsigned int magic , width , height , depth , length , type , maptype , maplength ; } SUNInfo ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bytes_per_line , extent , height , length ; ssize_t count , y ; SUNInfo sun_info ; unsigned char * sun_data , * sun_pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & sun_info , 0 , sizeof ( sun_info ) ) ; sun_info . magic = ReadBlobMSBLong ( image ) ; do { if ( sun_info . magic != 0x59a66a95 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; sun_info . width = ReadBlobMSBLong ( image ) ; sun_info . height = ReadBlobMSBLong ( image ) ; sun_info . depth = ReadBlobMSBLong ( image ) ; sun_info . length = ReadBlobMSBLong ( image ) ; sun_info . type = ReadBlobMSBLong ( image ) ; sun_info . maptype = ReadBlobMSBLong ( image ) ; sun_info . maplength = ReadBlobMSBLong ( image ) ; extent = sun_info . height * sun_info . width ; if ( ( sun_info . height != 0 ) && ( sun_info . width != extent / sun_info . height ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . type != RT_STANDARD ) && ( sun_info . type != RT_ENCODED ) && ( sun_info . type != RT_FORMAT_RGB ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype == RMT_NONE ) && ( sun_info . maplength != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . depth == 0 ) || ( sun_info . depth > 32 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype != RMT_NONE ) && ( sun_info . maptype != RMT_EQUAL_RGB ) && ( sun_info . maptype != RMT_RAW ) ) ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; image -> depth = sun_info . depth <= 8 ? sun_info . depth : MAGICKCORE_QUANTUM_DEPTH ; if ( sun_info . depth < 24 ) { size_t one ; image -> colors = sun_info . maplength ; one = 1 ; if ( sun_info . maptype == RMT_NONE ) image -> colors = one << sun_info . depth ; if ( sun_info . maptype == RMT_EQUAL_RGB ) image -> colors = sun_info . maplength / 3 ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } switch ( sun_info . maptype ) { case RMT_NONE : break ; case RMT_EQUAL_RGB : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } case RMT_RAW : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( sun_info . maplength , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , sun_info . maplength , sun_colormap ) ; if ( count != ( ssize_t ) sun_info . maplength ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; } image -> alpha_trait = sun_info . depth == 32 ? BlendPixelTrait : UndefinedPixelTrait ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( ( sun_info . length * sizeof ( * sun_data ) ) / sizeof ( * sun_data ) != sun_info . length || ! sun_info . length )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;  number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; if ( ( sun_info . type != RT_ENCODED ) && ( ( number_pixels * sun_info . depth ) > ( 8 * sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; bytes_per_line = sun_info . width * sun_info . depth ; sun_data = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( sun_info . length , bytes_per_line * sun_info . width ) , sizeof ( * sun_data ) ) ; if ( sun_data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ( ssize_t ) ReadBlob ( image , sun_info . length , sun_data ) ; if ( count != ( ssize_t ) sun_info . length ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; height = sun_info . height ; if ( ( height == 0 ) || ( sun_info . width == 0 ) || ( sun_info . depth == 0 ) || ( ( bytes_per_line / sun_info . depth ) != sun_info . width ) )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;  bytes_per_line += 15 ; bytes_per_line <<= 1 ; if ( ( bytes_per_line >> 1 ) != ( sun_info . width * sun_info . depth + 15 ) )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;  bytes_per_line >>= 4 ; sun_pixels = ( unsigned char * ) AcquireQuantumMemory ( height , bytes_per_line * sizeof ( * sun_pixels ) ) ; if ( sun_pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( sun_info . type == RT_ENCODED ) ( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line *  height ) ;  sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ; p = sun_pixels ; if ( sun_info . depth == 1 ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 7 ; bit >= 0 ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 7 ; bit >= ( int ) ( 8 - ( image -> columns % 8 ) ) ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( ( ( image -> columns / 8 ) + ( image -> columns % 8 ? 1 : 0 ) ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } else if ( image -> storage_class == PseudoClass ) { if ( bytes_per_line == 0 ) bytes_per_line = image -> columns ; length = image -> rows * ( image -> columns + image -> columns % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( ( image -> columns % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { size_t bytes_per_pixel ; bytes_per_pixel = 3 ; if ( image -> alpha_trait != UndefinedPixelTrait ) bytes_per_pixel ++ ; if ( bytes_per_line == 0 ) bytes_per_line = bytes_per_pixel * image -> columns ; length = image -> rows * ( bytes_per_line + bytes_per_line % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( sun_info . type == RT_STANDARD ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } else { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } if ( image -> colors != 0 ) { SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelRed ( image , q ) ] . red ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelGreen ( image , q ) ] . green ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelBlue ( image , q ) ] . blue ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( ( ( bytes_per_pixel * image -> columns ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image , exception ) ; sun_pixels = ( unsigned char * ) RelinquishMagickMemory ( sun_pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; sun_info . magic = ReadBlobMSBLong ( image ) ; if ( sun_info . magic == 0x59a66a95 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( sun_info . magic == 0x59a66a95 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""ImproperImageHeader"" ) ;number_pixels = ( MagickSizeType ) image -> columns * image -> rows ;",182
261,"buggy line: if ( ( height == 0 ) || ( sun_info . width == 0 ) || ( sun_info . depth == 0 ) || ( ( bytes_per_line / sun_info . depth ) != sun_info . width ) )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;bytes_per_line += 15 ;if ( ( bytes_per_line >> 1 ) != ( sun_info . width * sun_info . depth + 15 ) )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;bytes_per_line >>= 4 ;if ( sun_info . type == RT_ENCODED ) ( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line *  height ) ;sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ;cwe id:CWE-125context: static Image * ReadSUNImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define RMT_EQUAL_RGB 1 # define RMT_NONE 0 # define RMT_RAW 2 # define RT_STANDARD 1 # define RT_ENCODED 2 # define RT_FORMAT_RGB 3 typedef struct _SUNInfo { unsigned int magic , width , height , depth , length , type , maptype , maplength ; } SUNInfo ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bytes_per_line , extent , height , length ; ssize_t count , y ; SUNInfo sun_info ; unsigned char * sun_data , * sun_pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & sun_info , 0 , sizeof ( sun_info ) ) ; sun_info . magic = ReadBlobMSBLong ( image ) ; do { if ( sun_info . magic != 0x59a66a95 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; sun_info . width = ReadBlobMSBLong ( image ) ; sun_info . height = ReadBlobMSBLong ( image ) ; sun_info . depth = ReadBlobMSBLong ( image ) ; sun_info . length = ReadBlobMSBLong ( image ) ; sun_info . type = ReadBlobMSBLong ( image ) ; sun_info . maptype = ReadBlobMSBLong ( image ) ; sun_info . maplength = ReadBlobMSBLong ( image ) ; extent = sun_info . height * sun_info . width ; if ( ( sun_info . height != 0 ) && ( sun_info . width != extent / sun_info . height ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . type != RT_STANDARD ) && ( sun_info . type != RT_ENCODED ) && ( sun_info . type != RT_FORMAT_RGB ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype == RMT_NONE ) && ( sun_info . maplength != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . depth == 0 ) || ( sun_info . depth > 32 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype != RMT_NONE ) && ( sun_info . maptype != RMT_EQUAL_RGB ) && ( sun_info . maptype != RMT_RAW ) ) ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; image -> depth = sun_info . depth <= 8 ? sun_info . depth : MAGICKCORE_QUANTUM_DEPTH ; if ( sun_info . depth < 24 ) { size_t one ; image -> colors = sun_info . maplength ; one = 1 ; if ( sun_info . maptype == RMT_NONE ) image -> colors = one << sun_info . depth ; if ( sun_info . maptype == RMT_EQUAL_RGB ) image -> colors = sun_info . maplength / 3 ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } switch ( sun_info . maptype ) { case RMT_NONE : break ; case RMT_EQUAL_RGB : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } case RMT_RAW : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( sun_info . maplength , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , sun_info . maplength , sun_colormap ) ; if ( count != ( ssize_t ) sun_info . maplength ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; } image -> alpha_trait = sun_info . depth == 32 ? BlendPixelTrait : UndefinedPixelTrait ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( ( sun_info . length * sizeof ( * sun_data ) ) / sizeof ( * sun_data ) != sun_info . length || ! sun_info . length )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;  number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; if ( ( sun_info . type != RT_ENCODED ) && ( ( number_pixels * sun_info . depth ) > ( 8 * sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; bytes_per_line = sun_info . width * sun_info . depth ; sun_data = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( sun_info . length , bytes_per_line * sun_info . width ) , sizeof ( * sun_data ) ) ; if ( sun_data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ( ssize_t ) ReadBlob ( image , sun_info . length , sun_data ) ; if ( count != ( ssize_t ) sun_info . length ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; height = sun_info . height ; if ( ( height == 0 ) || ( sun_info . width == 0 ) || ( sun_info . depth == 0 ) || ( ( bytes_per_line / sun_info . depth ) != sun_info . width ) )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;  bytes_per_line += 15 ; bytes_per_line <<= 1 ; if ( ( bytes_per_line >> 1 ) != ( sun_info . width * sun_info . depth + 15 ) )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;  bytes_per_line >>= 4 ; sun_pixels = ( unsigned char * ) AcquireQuantumMemory ( height , bytes_per_line * sizeof ( * sun_pixels ) ) ; if ( sun_pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( sun_info . type == RT_ENCODED ) ( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line *  height ) ;  sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ; p = sun_pixels ; if ( sun_info . depth == 1 ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 7 ; bit >= 0 ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 7 ; bit >= ( int ) ( 8 - ( image -> columns % 8 ) ) ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( ( ( image -> columns / 8 ) + ( image -> columns % 8 ? 1 : 0 ) ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } else if ( image -> storage_class == PseudoClass ) { if ( bytes_per_line == 0 ) bytes_per_line = image -> columns ; length = image -> rows * ( image -> columns + image -> columns % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( ( image -> columns % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { size_t bytes_per_pixel ; bytes_per_pixel = 3 ; if ( image -> alpha_trait != UndefinedPixelTrait ) bytes_per_pixel ++ ; if ( bytes_per_line == 0 ) bytes_per_line = bytes_per_pixel * image -> columns ; length = image -> rows * ( bytes_per_line + bytes_per_line % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( sun_info . type == RT_STANDARD ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } else { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } if ( image -> colors != 0 ) { SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelRed ( image , q ) ] . red ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelGreen ( image , q ) ] . green ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelBlue ( image , q ) ] . blue ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( ( ( bytes_per_pixel * image -> columns ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image , exception ) ; sun_pixels = ( unsigned char * ) RelinquishMagickMemory ( sun_pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; sun_info . magic = ReadBlobMSBLong ( image ) ; if ( sun_info . magic == 0x59a66a95 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( sun_info . magic == 0x59a66a95 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","if ( ( height == 0 ) || ( sun_info . width == 0 ) || ( sun_info . depth == 0 ) || ( ( bytes_per_line / sun_info . depth ) != sun_info . width ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;bytes_per_line += 15 ;if ( ( bytes_per_line >> 1 ) != ( sun_info . width * sun_info . depth + 15 ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;bytes_per_line >>= 4 ;if ( sun_info . type == RT_ENCODED ) ( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line * height ) ;else {if ( sun_info . length > ( height * bytes_per_line ) ) ThrowReaderException ( ResourceLimitError , ""ImproperImageHeader"" ) ;( void ) CopyMagickMemory ( sun_pixels , sun_data , sun_info . length ) ;}sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ;",182
262,"buggy line: # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07  char  magick [ 12 ] ;cwe id:CWE-20context: static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07  char  magick [ 12 ] ; Image * image ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; Quantum index ; register ssize_t x ; register Quantum * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , pixel_info_length ; ssize_t count , offset , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;  count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ;  if ( ( count != 2 ) || ( memcmp ( magick , ""\\122\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do {  image -> page . x = ReadBlobLSBShort ( image ) ;   image -> page . y = ReadBlobLSBShort ( image ) ;  image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlobByte ( image ) ; image -> alpha_trait = flags & 0x04 ? BlendPixelTrait : UndefinedPixelTrait ; number_planes = ( size_t ) ReadBlobByte ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; number_colormaps = ( size_t ) ReadBlobByte ( image ) ; map_length = ( unsigned char ) ReadBlobByte ( image ) ; if ( map_length >= 22 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;  one = 1 ;  map_length = one << map_length ; if ( ( number_planes == 0 ) || ( number_planes == 2 ) || ( ( flags & 0x04 ) && ( number_colormaps > 254 ) ) || ( bits_per_pixel != 8 ) || ( image -> columns == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( flags & 0x02 ) { for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) background_color [ i ] = 0 ; ( void ) ReadBlobByte ( image ) ; } else { p = background_color ; for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) * p ++ = ( unsigned char ) ReadBlobByte ( image ) ; } if ( ( number_planes & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse )  {   ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ; break ; }  colormap = ( unsigned char * ) NULL ;  if ( number_colormaps != 0 ) {  colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps ,  3 * map_length * sizeof ( * colormap ) ) ;  if ( colormap == ( unsigned char * ) NULL )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ ) * p ++ = ( unsigned char ) ScaleQuantumToChar ( ScaleShortToQuantum (  ReadBlobLSBShort ( image ) ) ) ;  } if ( ( flags & 0x08 ) != 0 ) { char * comment ; size_t length ; length = ReadBlobLSBShort ( image ) ; if ( length != 0 ) { comment = ( char * ) AcquireQuantumMemory ( length , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , length - 1 , ( unsigned char * ) comment ) ; comment [ length - 1 ] = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment , exception ) ; comment = DestroyString ( comment ) ; if ( ( length & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; } } if ( EOFBlob ( image ) != MagickFalse )  {   ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ; break ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) number_planes ++ ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows * MagickMax ( number_planes_filled , 4 ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes_filled , 4 ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; ( void ) ResetMagickMemory ( pixels , 0 , pixel_info_length ) ; if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) { ssize_t j ; p = pixels ; for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( image -> alpha_trait == UndefinedPixelTrait ) for ( j = 0 ; j < ( ssize_t ) number_planes ; j ++ ) * p ++ = background_color [ j ] ; else { for ( j = 0 ; j < ( ssize_t ) ( number_planes - 1 ) ; j ++ ) * p ++ = background_color [ j ] ; * p ++ = 0 ; } } } plane = 0 ; x = 0 ; y = 0 ; opcode = ReadBlobByte ( image ) ;  do  { switch ( opcode & 0x3f ) { case SkipLinesOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  x = 0 ; y += operand ; break ; } case SetColorOp : { operand = ReadBlobByte ( image ) ;  plane = ( unsigned char ) operand ;  if ( plane == 255 ) plane = ( unsigned char ) ( number_planes - 1 ) ; x = 0 ; break ; } case SkipPixelsOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  x += operand ; break ; } case ByteDataOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;   offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;  operand ++ ; if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } if ( operand & 0x01 ) ( void ) ReadBlobByte ( image ) ; x += operand ; break ; } case RunDataOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  pixel = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) ReadBlobByte ( image ) ;  offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;  operand ++ ; if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } x += operand ; break ; } default : break ; } opcode = ReadBlobByte ( image ) ;  } while ( ( ( opcode & 0x3f ) != EOFOp ) && ( opcode != EOF ) ) ;  if ( number_colormaps != 0 ) { MagickStatusType mask ; mask = ( MagickStatusType ) ( map_length - 1 ) ; p = pixels ; x = ( ssize_t ) number_planes ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) {  ValidateColormapValue ( image , * p & mask , & index , exception ) ;  * p = colormap [ ( ssize_t ) index ] ; p ++ ; } else if ( ( number_planes >= 3 ) && ( number_colormaps >= 3 ) ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) for ( x = 0 ; x < ( ssize_t ) number_planes ; x ++ ) {  ValidateColormapValue ( image , ( size_t ) ( x * map_length +  ( * p & mask ) ) , & index , exception ) ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } if ( ( i < ( ssize_t ) number_pixels ) || ( x < ( ssize_t ) number_planes ) ) { colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } } if ( number_planes >= 3 ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( number_colormaps == 0 ) map_length = 256 ; if ( AcquireImageColormap ( image , map_length , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; } else if ( number_colormaps > 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( * p ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( * ( p + map_length ) ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( * ( p + map_length * 2 ) ) ; p ++ ; } p = pixels ; if ( image -> alpha_trait == UndefinedPixelTrait ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) {  SetPixelIndex ( image , * p ++ , q ) ;  q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; } else { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . red ) , q ) ; ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . green ) , q ) ; ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . blue ) , q ) ; SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } image -> colormap = ( PixelInfo * ) RelinquishMagickMemory ( image -> colormap ) ; image -> storage_class = DirectClass ; image -> colors = 0 ; } } if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; ( void ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","# define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07 # define ThrowRLEException ( exception , message ) \\\\\if ( colormap != ( unsigned char * ) NULL ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ;if ( pixel_info != ( MemoryInfo * ) NULL ) pixel_info = RelinquishVirtualMemory ( pixel_info ) ;ThrowReaderException ( ( exception ) , ( message ) ) ;colormap = ( unsigned char * ) NULL ;pixel_info = ( MemoryInfo * ) NULL ;\\\\\char magick [ 12 ] ;",183
263,"buggy line: if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ;assert ( exception != ( ExceptionInfo * ) NULL ) ;assert ( exception -> signature == MagickCoreSignature ) ;image = AcquireImage ( image_info , exception ) ;status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ;if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ;if ( ( count != 2 ) || ( memcmp ( magick , ""\\\\122\\\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;do {image -> page . x = ReadBlobLSBShort ( image ) ;image -> page . y = ReadBlobLSBShort ( image ) ;image -> columns = ReadBlobLSBShort ( image ) ;image -> rows = ReadBlobLSBShort ( image ) ;flags = ( MagickStatusType ) ReadBlobByte ( image ) ;image -> alpha_trait = flags & 0x04 ? BlendPixelTrait : UndefinedPixelTrait ;number_planes = ( size_t ) ReadBlobByte ( image ) ;bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ;number_colormaps = ( size_t ) ReadBlobByte ( image ) ;map_length = ( unsigned char ) ReadBlobByte ( image ) ;if ( map_length >= 22 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;one = 1 ;map_length = one << map_length ;cwe id:CWE-20context: static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07  char  magick [ 12 ] ; Image * image ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; Quantum index ; register ssize_t x ; register Quantum * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , pixel_info_length ; ssize_t count , offset , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;  count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ;  if ( ( count != 2 ) || ( memcmp ( magick , ""\\122\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do {  image -> page . x = ReadBlobLSBShort ( image ) ;   image -> page . y = ReadBlobLSBShort ( image ) ;  image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlobByte ( image ) ; image -> alpha_trait = flags & 0x04 ? BlendPixelTrait : UndefinedPixelTrait ; number_planes = ( size_t ) ReadBlobByte ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; number_colormaps = ( size_t ) ReadBlobByte ( image ) ; map_length = ( unsigned char ) ReadBlobByte ( image ) ; if ( map_length >= 22 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;  one = 1 ;  map_length = one << map_length ; if ( ( number_planes == 0 ) || ( number_planes == 2 ) || ( ( flags & 0x04 ) && ( number_colormaps > 254 ) ) || ( bits_per_pixel != 8 ) || ( image -> columns == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( flags & 0x02 ) { for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) background_color [ i ] = 0 ; ( void ) ReadBlobByte ( image ) ; } else { p = background_color ; for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) * p ++ = ( unsigned char ) ReadBlobByte ( image ) ; } if ( ( number_planes & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse )  {   ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ; break ; }  colormap = ( unsigned char * ) NULL ;  if ( number_colormaps != 0 ) {  colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps ,  3 * map_length * sizeof ( * colormap ) ) ;  if ( colormap == ( unsigned char * ) NULL )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ ) * p ++ = ( unsigned char ) ScaleQuantumToChar ( ScaleShortToQuantum (  ReadBlobLSBShort ( image ) ) ) ;  } if ( ( flags & 0x08 ) != 0 ) { char * comment ; size_t length ; length = ReadBlobLSBShort ( image ) ; if ( length != 0 ) { comment = ( char * ) AcquireQuantumMemory ( length , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , length - 1 , ( unsigned char * ) comment ) ; comment [ length - 1 ] = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment , exception ) ; comment = DestroyString ( comment ) ; if ( ( length & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; } } if ( EOFBlob ( image ) != MagickFalse )  {   ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ; break ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) number_planes ++ ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows * MagickMax ( number_planes_filled , 4 ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes_filled , 4 ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; ( void ) ResetMagickMemory ( pixels , 0 , pixel_info_length ) ; if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) { ssize_t j ; p = pixels ; for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( image -> alpha_trait == UndefinedPixelTrait ) for ( j = 0 ; j < ( ssize_t ) number_planes ; j ++ ) * p ++ = background_color [ j ] ; else { for ( j = 0 ; j < ( ssize_t ) ( number_planes - 1 ) ; j ++ ) * p ++ = background_color [ j ] ; * p ++ = 0 ; } } } plane = 0 ; x = 0 ; y = 0 ; opcode = ReadBlobByte ( image ) ;  do  { switch ( opcode & 0x3f ) { case SkipLinesOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  x = 0 ; y += operand ; break ; } case SetColorOp : { operand = ReadBlobByte ( image ) ;  plane = ( unsigned char ) operand ;  if ( plane == 255 ) plane = ( unsigned char ) ( number_planes - 1 ) ; x = 0 ; break ; } case SkipPixelsOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  x += operand ; break ; } case ByteDataOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;   offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;  operand ++ ; if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } if ( operand & 0x01 ) ( void ) ReadBlobByte ( image ) ; x += operand ; break ; } case RunDataOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  pixel = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) ReadBlobByte ( image ) ;  offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;  operand ++ ; if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } x += operand ; break ; } default : break ; } opcode = ReadBlobByte ( image ) ;  } while ( ( ( opcode & 0x3f ) != EOFOp ) && ( opcode != EOF ) ) ;  if ( number_colormaps != 0 ) { MagickStatusType mask ; mask = ( MagickStatusType ) ( map_length - 1 ) ; p = pixels ; x = ( ssize_t ) number_planes ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) {  ValidateColormapValue ( image , * p & mask , & index , exception ) ;  * p = colormap [ ( ssize_t ) index ] ; p ++ ; } else if ( ( number_planes >= 3 ) && ( number_colormaps >= 3 ) ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) for ( x = 0 ; x < ( ssize_t ) number_planes ; x ++ ) {  ValidateColormapValue ( image , ( size_t ) ( x * map_length +  ( * p & mask ) ) , & index , exception ) ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } if ( ( i < ( ssize_t ) number_pixels ) || ( x < ( ssize_t ) number_planes ) ) { colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } } if ( number_planes >= 3 ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( number_colormaps == 0 ) map_length = 256 ; if ( AcquireImageColormap ( image , map_length , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; } else if ( number_colormaps > 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( * p ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( * ( p + map_length ) ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( * ( p + map_length * 2 ) ) ; p ++ ; } p = pixels ; if ( image -> alpha_trait == UndefinedPixelTrait ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) {  SetPixelIndex ( image , * p ++ , q ) ;  q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; } else { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . red ) , q ) ; ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . green ) , q ) ; ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . blue ) , q ) ; SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } image -> colormap = ( PixelInfo * ) RelinquishMagickMemory ( image -> colormap ) ; image -> storage_class = DirectClass ; image -> colors = 0 ; } } if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; ( void ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","if ( image_info -> debug != MagickFalse ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;one = 1 ;map_length = one << map_length ;",183
264,"buggy line: if ( EOFBlob ( image ) != MagickFalse )  {ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ;colormap = ( unsigned char * ) NULL ;if ( number_colormaps != 0 ) {colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps ,  3 * map_length * sizeof ( * colormap ) ) ;if ( colormap == ( unsigned char * ) NULL )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;x ++ ) * p ++ = ( unsigned char ) ScaleQuantumToChar ( ScaleShortToQuantum (  ReadBlobLSBShort ( image ) ) ) ;}cwe id:CWE-20context: static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07  char  magick [ 12 ] ; Image * image ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; Quantum index ; register ssize_t x ; register Quantum * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , pixel_info_length ; ssize_t count , offset , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;  count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ;  if ( ( count != 2 ) || ( memcmp ( magick , ""\\122\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do {  image -> page . x = ReadBlobLSBShort ( image ) ;   image -> page . y = ReadBlobLSBShort ( image ) ;  image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlobByte ( image ) ; image -> alpha_trait = flags & 0x04 ? BlendPixelTrait : UndefinedPixelTrait ; number_planes = ( size_t ) ReadBlobByte ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; number_colormaps = ( size_t ) ReadBlobByte ( image ) ; map_length = ( unsigned char ) ReadBlobByte ( image ) ; if ( map_length >= 22 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;  one = 1 ;  map_length = one << map_length ; if ( ( number_planes == 0 ) || ( number_planes == 2 ) || ( ( flags & 0x04 ) && ( number_colormaps > 254 ) ) || ( bits_per_pixel != 8 ) || ( image -> columns == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( flags & 0x02 ) { for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) background_color [ i ] = 0 ; ( void ) ReadBlobByte ( image ) ; } else { p = background_color ; for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) * p ++ = ( unsigned char ) ReadBlobByte ( image ) ; } if ( ( number_planes & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse )  {   ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ; break ; }  colormap = ( unsigned char * ) NULL ;  if ( number_colormaps != 0 ) {  colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps ,  3 * map_length * sizeof ( * colormap ) ) ;  if ( colormap == ( unsigned char * ) NULL )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ ) * p ++ = ( unsigned char ) ScaleQuantumToChar ( ScaleShortToQuantum (  ReadBlobLSBShort ( image ) ) ) ;  } if ( ( flags & 0x08 ) != 0 ) { char * comment ; size_t length ; length = ReadBlobLSBShort ( image ) ; if ( length != 0 ) { comment = ( char * ) AcquireQuantumMemory ( length , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , length - 1 , ( unsigned char * ) comment ) ; comment [ length - 1 ] = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment , exception ) ; comment = DestroyString ( comment ) ; if ( ( length & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; } } if ( EOFBlob ( image ) != MagickFalse )  {   ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ; break ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) number_planes ++ ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows * MagickMax ( number_planes_filled , 4 ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes_filled , 4 ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; ( void ) ResetMagickMemory ( pixels , 0 , pixel_info_length ) ; if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) { ssize_t j ; p = pixels ; for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( image -> alpha_trait == UndefinedPixelTrait ) for ( j = 0 ; j < ( ssize_t ) number_planes ; j ++ ) * p ++ = background_color [ j ] ; else { for ( j = 0 ; j < ( ssize_t ) ( number_planes - 1 ) ; j ++ ) * p ++ = background_color [ j ] ; * p ++ = 0 ; } } } plane = 0 ; x = 0 ; y = 0 ; opcode = ReadBlobByte ( image ) ;  do  { switch ( opcode & 0x3f ) { case SkipLinesOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  x = 0 ; y += operand ; break ; } case SetColorOp : { operand = ReadBlobByte ( image ) ;  plane = ( unsigned char ) operand ;  if ( plane == 255 ) plane = ( unsigned char ) ( number_planes - 1 ) ; x = 0 ; break ; } case SkipPixelsOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  x += operand ; break ; } case ByteDataOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;   offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;  operand ++ ; if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } if ( operand & 0x01 ) ( void ) ReadBlobByte ( image ) ; x += operand ; break ; } case RunDataOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  pixel = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) ReadBlobByte ( image ) ;  offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;  operand ++ ; if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } x += operand ; break ; } default : break ; } opcode = ReadBlobByte ( image ) ;  } while ( ( ( opcode & 0x3f ) != EOFOp ) && ( opcode != EOF ) ) ;  if ( number_colormaps != 0 ) { MagickStatusType mask ; mask = ( MagickStatusType ) ( map_length - 1 ) ; p = pixels ; x = ( ssize_t ) number_planes ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) {  ValidateColormapValue ( image , * p & mask , & index , exception ) ;  * p = colormap [ ( ssize_t ) index ] ; p ++ ; } else if ( ( number_planes >= 3 ) && ( number_colormaps >= 3 ) ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) for ( x = 0 ; x < ( ssize_t ) number_planes ; x ++ ) {  ValidateColormapValue ( image , ( size_t ) ( x * map_length +  ( * p & mask ) ) , & index , exception ) ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } if ( ( i < ( ssize_t ) number_pixels ) || ( x < ( ssize_t ) number_planes ) ) { colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } } if ( number_planes >= 3 ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( number_colormaps == 0 ) map_length = 256 ; if ( AcquireImageColormap ( image , map_length , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; } else if ( number_colormaps > 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( * p ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( * ( p + map_length ) ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( * ( p + map_length * 2 ) ) ; p ++ ; } p = pixels ; if ( image -> alpha_trait == UndefinedPixelTrait ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) {  SetPixelIndex ( image , * p ++ , q ) ;  q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; } else { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . red ) , q ) ; ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . green ) , q ) ; ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . blue ) , q ) ; SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } image -> colormap = ( PixelInfo * ) RelinquishMagickMemory ( image -> colormap ) ; image -> storage_class = DirectClass ; image -> colors = 0 ; } } if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; ( void ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","if ( EOFBlob ( image ) != MagickFalse ) {ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ;colormap = ( unsigned char * ) NULL ;if ( number_colormaps != 0 ) {colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps , 3 * map_length * sizeof ( * colormap ) ) ;if ( colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;x ++ ) * p ++ = ( unsigned char ) ScaleQuantumToChar ( ScaleShortToQuantum ( ReadBlobLSBShort ( image ) ) ) ;}",183
265,"buggy line: if ( EOFBlob ( image ) != MagickFalse )  {ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ;break ;}if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;if ( image -> alpha_trait != UndefinedPixelTrait ) number_planes ++ ;number_pixels = ( MagickSizeType ) image -> columns * image -> rows ;number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ;if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows * MagickMax ( number_planes_filled , 4 ) * sizeof ( * pixels ) ) ;if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes_filled , 4 ) ;pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ;( void ) ResetMagickMemory ( pixels , 0 , pixel_info_length ) ;if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) {ssize_t j ;p = pixels ;for ( i = 0 ;i < ( ssize_t ) number_pixels ;i ++ ) {if ( image -> alpha_trait == UndefinedPixelTrait ) for ( j = 0 ;j < ( ssize_t ) number_planes ;j ++ ) * p ++ = background_color [ j ] ;else {for ( j = 0 ;j < ( ssize_t ) ( number_planes - 1 ) ;j ++ ) * p ++ = background_color [ j ] ;* p ++ = 0 ;}}}plane = 0 ;x = 0 ;y = 0 ;opcode = ReadBlobByte ( image ) ;do  {switch ( opcode & 0x3f ) {case SkipLinesOp : {operand = ReadBlobByte ( image ) ;if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;x = 0 ;y += operand ;break ;}case SetColorOp : {operand = ReadBlobByte ( image ) ;plane = ( unsigned char ) operand ;if ( plane == 255 ) plane = ( unsigned char ) ( number_planes - 1 ) ;x = 0 ;break ;}case SkipPixelsOp : {operand = ReadBlobByte ( image ) ;if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;x += operand ;break ;}case ByteDataOp : {operand = ReadBlobByte ( image ) ;if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;operand ++ ;if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  {if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ;cwe id:CWE-20context: static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07  char  magick [ 12 ] ; Image * image ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; Quantum index ; register ssize_t x ; register Quantum * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , pixel_info_length ; ssize_t count , offset , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;  count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ;  if ( ( count != 2 ) || ( memcmp ( magick , ""\\122\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do {  image -> page . x = ReadBlobLSBShort ( image ) ;   image -> page . y = ReadBlobLSBShort ( image ) ;  image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlobByte ( image ) ; image -> alpha_trait = flags & 0x04 ? BlendPixelTrait : UndefinedPixelTrait ; number_planes = ( size_t ) ReadBlobByte ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; number_colormaps = ( size_t ) ReadBlobByte ( image ) ; map_length = ( unsigned char ) ReadBlobByte ( image ) ; if ( map_length >= 22 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;  one = 1 ;  map_length = one << map_length ; if ( ( number_planes == 0 ) || ( number_planes == 2 ) || ( ( flags & 0x04 ) && ( number_colormaps > 254 ) ) || ( bits_per_pixel != 8 ) || ( image -> columns == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( flags & 0x02 ) { for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) background_color [ i ] = 0 ; ( void ) ReadBlobByte ( image ) ; } else { p = background_color ; for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) * p ++ = ( unsigned char ) ReadBlobByte ( image ) ; } if ( ( number_planes & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse )  {   ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ; break ; }  colormap = ( unsigned char * ) NULL ;  if ( number_colormaps != 0 ) {  colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps ,  3 * map_length * sizeof ( * colormap ) ) ;  if ( colormap == ( unsigned char * ) NULL )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ ) * p ++ = ( unsigned char ) ScaleQuantumToChar ( ScaleShortToQuantum (  ReadBlobLSBShort ( image ) ) ) ;  } if ( ( flags & 0x08 ) != 0 ) { char * comment ; size_t length ; length = ReadBlobLSBShort ( image ) ; if ( length != 0 ) { comment = ( char * ) AcquireQuantumMemory ( length , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , length - 1 , ( unsigned char * ) comment ) ; comment [ length - 1 ] = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment , exception ) ; comment = DestroyString ( comment ) ; if ( ( length & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; } } if ( EOFBlob ( image ) != MagickFalse )  {   ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ; break ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) number_planes ++ ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows * MagickMax ( number_planes_filled , 4 ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes_filled , 4 ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; ( void ) ResetMagickMemory ( pixels , 0 , pixel_info_length ) ; if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) { ssize_t j ; p = pixels ; for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( image -> alpha_trait == UndefinedPixelTrait ) for ( j = 0 ; j < ( ssize_t ) number_planes ; j ++ ) * p ++ = background_color [ j ] ; else { for ( j = 0 ; j < ( ssize_t ) ( number_planes - 1 ) ; j ++ ) * p ++ = background_color [ j ] ; * p ++ = 0 ; } } } plane = 0 ; x = 0 ; y = 0 ; opcode = ReadBlobByte ( image ) ;  do  { switch ( opcode & 0x3f ) { case SkipLinesOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  x = 0 ; y += operand ; break ; } case SetColorOp : { operand = ReadBlobByte ( image ) ;  plane = ( unsigned char ) operand ;  if ( plane == 255 ) plane = ( unsigned char ) ( number_planes - 1 ) ; x = 0 ; break ; } case SkipPixelsOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  x += operand ; break ; } case ByteDataOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;   offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;  operand ++ ; if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } if ( operand & 0x01 ) ( void ) ReadBlobByte ( image ) ; x += operand ; break ; } case RunDataOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  pixel = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) ReadBlobByte ( image ) ;  offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;  operand ++ ; if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } x += operand ; break ; } default : break ; } opcode = ReadBlobByte ( image ) ;  } while ( ( ( opcode & 0x3f ) != EOFOp ) && ( opcode != EOF ) ) ;  if ( number_colormaps != 0 ) { MagickStatusType mask ; mask = ( MagickStatusType ) ( map_length - 1 ) ; p = pixels ; x = ( ssize_t ) number_planes ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) {  ValidateColormapValue ( image , * p & mask , & index , exception ) ;  * p = colormap [ ( ssize_t ) index ] ; p ++ ; } else if ( ( number_planes >= 3 ) && ( number_colormaps >= 3 ) ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) for ( x = 0 ; x < ( ssize_t ) number_planes ; x ++ ) {  ValidateColormapValue ( image , ( size_t ) ( x * map_length +  ( * p & mask ) ) , & index , exception ) ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } if ( ( i < ( ssize_t ) number_pixels ) || ( x < ( ssize_t ) number_planes ) ) { colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } } if ( number_planes >= 3 ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( number_colormaps == 0 ) map_length = 256 ; if ( AcquireImageColormap ( image , map_length , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; } else if ( number_colormaps > 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( * p ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( * ( p + map_length ) ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( * ( p + map_length * 2 ) ) ; p ++ ; } p = pixels ; if ( image -> alpha_trait == UndefinedPixelTrait ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) {  SetPixelIndex ( image , * p ++ , q ) ;  q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; } else { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . red ) , q ) ; ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . green ) , q ) ; ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . blue ) , q ) ; SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } image -> colormap = ( PixelInfo * ) RelinquishMagickMemory ( image -> colormap ) ; image -> storage_class = DirectClass ; image -> colors = 0 ; } } if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; ( void ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","if ( EOFBlob ( image ) != MagickFalse ) {ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ) ;if ( number_colormaps != 0 ) {colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ;",183
266,"buggy line: if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;pixel = ( unsigned char ) ReadBlobByte ( image ) ;offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;operand ++ ;if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  {cwe id:CWE-20context: static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07  char  magick [ 12 ] ; Image * image ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; Quantum index ; register ssize_t x ; register Quantum * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , pixel_info_length ; ssize_t count , offset , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;  count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ;  if ( ( count != 2 ) || ( memcmp ( magick , ""\\122\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do {  image -> page . x = ReadBlobLSBShort ( image ) ;   image -> page . y = ReadBlobLSBShort ( image ) ;  image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlobByte ( image ) ; image -> alpha_trait = flags & 0x04 ? BlendPixelTrait : UndefinedPixelTrait ; number_planes = ( size_t ) ReadBlobByte ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; number_colormaps = ( size_t ) ReadBlobByte ( image ) ; map_length = ( unsigned char ) ReadBlobByte ( image ) ; if ( map_length >= 22 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;  one = 1 ;  map_length = one << map_length ; if ( ( number_planes == 0 ) || ( number_planes == 2 ) || ( ( flags & 0x04 ) && ( number_colormaps > 254 ) ) || ( bits_per_pixel != 8 ) || ( image -> columns == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( flags & 0x02 ) { for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) background_color [ i ] = 0 ; ( void ) ReadBlobByte ( image ) ; } else { p = background_color ; for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) * p ++ = ( unsigned char ) ReadBlobByte ( image ) ; } if ( ( number_planes & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse )  {   ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ; break ; }  colormap = ( unsigned char * ) NULL ;  if ( number_colormaps != 0 ) {  colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps ,  3 * map_length * sizeof ( * colormap ) ) ;  if ( colormap == ( unsigned char * ) NULL )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ ) * p ++ = ( unsigned char ) ScaleQuantumToChar ( ScaleShortToQuantum (  ReadBlobLSBShort ( image ) ) ) ;  } if ( ( flags & 0x08 ) != 0 ) { char * comment ; size_t length ; length = ReadBlobLSBShort ( image ) ; if ( length != 0 ) { comment = ( char * ) AcquireQuantumMemory ( length , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , length - 1 , ( unsigned char * ) comment ) ; comment [ length - 1 ] = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment , exception ) ; comment = DestroyString ( comment ) ; if ( ( length & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; } } if ( EOFBlob ( image ) != MagickFalse )  {   ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ; break ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) number_planes ++ ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows * MagickMax ( number_planes_filled , 4 ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes_filled , 4 ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; ( void ) ResetMagickMemory ( pixels , 0 , pixel_info_length ) ; if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) { ssize_t j ; p = pixels ; for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( image -> alpha_trait == UndefinedPixelTrait ) for ( j = 0 ; j < ( ssize_t ) number_planes ; j ++ ) * p ++ = background_color [ j ] ; else { for ( j = 0 ; j < ( ssize_t ) ( number_planes - 1 ) ; j ++ ) * p ++ = background_color [ j ] ; * p ++ = 0 ; } } } plane = 0 ; x = 0 ; y = 0 ; opcode = ReadBlobByte ( image ) ;  do  { switch ( opcode & 0x3f ) { case SkipLinesOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  x = 0 ; y += operand ; break ; } case SetColorOp : { operand = ReadBlobByte ( image ) ;  plane = ( unsigned char ) operand ;  if ( plane == 255 ) plane = ( unsigned char ) ( number_planes - 1 ) ; x = 0 ; break ; } case SkipPixelsOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  x += operand ; break ; } case ByteDataOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;   offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;  operand ++ ; if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } if ( operand & 0x01 ) ( void ) ReadBlobByte ( image ) ; x += operand ; break ; } case RunDataOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  pixel = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) ReadBlobByte ( image ) ;  offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;  operand ++ ; if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } x += operand ; break ; } default : break ; } opcode = ReadBlobByte ( image ) ;  } while ( ( ( opcode & 0x3f ) != EOFOp ) && ( opcode != EOF ) ) ;  if ( number_colormaps != 0 ) { MagickStatusType mask ; mask = ( MagickStatusType ) ( map_length - 1 ) ; p = pixels ; x = ( ssize_t ) number_planes ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) {  ValidateColormapValue ( image , * p & mask , & index , exception ) ;  * p = colormap [ ( ssize_t ) index ] ; p ++ ; } else if ( ( number_planes >= 3 ) && ( number_colormaps >= 3 ) ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) for ( x = 0 ; x < ( ssize_t ) number_planes ; x ++ ) {  ValidateColormapValue ( image , ( size_t ) ( x * map_length +  ( * p & mask ) ) , & index , exception ) ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } if ( ( i < ( ssize_t ) number_pixels ) || ( x < ( ssize_t ) number_planes ) ) { colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } } if ( number_planes >= 3 ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( number_colormaps == 0 ) map_length = 256 ; if ( AcquireImageColormap ( image , map_length , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; } else if ( number_colormaps > 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( * p ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( * ( p + map_length ) ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( * ( p + map_length * 2 ) ) ; p ++ ; } p = pixels ; if ( image -> alpha_trait == UndefinedPixelTrait ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) {  SetPixelIndex ( image , * p ++ , q ) ;  q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; } else { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . red ) , q ) ; ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . green ) , q ) ; ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . blue ) , q ) ; SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } image -> colormap = ( PixelInfo * ) RelinquishMagickMemory ( image -> colormap ) ; image -> storage_class = DirectClass ; image -> colors = 0 ; } } if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; ( void ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }",if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ;pixel = ( unsigned char ) ReadBlobByte ( image ) ;offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * number_planes + plane ;operand ++ ;if ( ( offset < 0 ) || ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) {,183
267,"buggy line: }if ( number_colormaps != 0 ) {cwe id:CWE-20context: static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07  char  magick [ 12 ] ; Image * image ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; Quantum index ; register ssize_t x ; register Quantum * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , pixel_info_length ; ssize_t count , offset , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;  count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ;  if ( ( count != 2 ) || ( memcmp ( magick , ""\\122\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do {  image -> page . x = ReadBlobLSBShort ( image ) ;   image -> page . y = ReadBlobLSBShort ( image ) ;  image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlobByte ( image ) ; image -> alpha_trait = flags & 0x04 ? BlendPixelTrait : UndefinedPixelTrait ; number_planes = ( size_t ) ReadBlobByte ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; number_colormaps = ( size_t ) ReadBlobByte ( image ) ; map_length = ( unsigned char ) ReadBlobByte ( image ) ; if ( map_length >= 22 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;  one = 1 ;  map_length = one << map_length ; if ( ( number_planes == 0 ) || ( number_planes == 2 ) || ( ( flags & 0x04 ) && ( number_colormaps > 254 ) ) || ( bits_per_pixel != 8 ) || ( image -> columns == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( flags & 0x02 ) { for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) background_color [ i ] = 0 ; ( void ) ReadBlobByte ( image ) ; } else { p = background_color ; for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) * p ++ = ( unsigned char ) ReadBlobByte ( image ) ; } if ( ( number_planes & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse )  {   ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ; break ; }  colormap = ( unsigned char * ) NULL ;  if ( number_colormaps != 0 ) {  colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps ,  3 * map_length * sizeof ( * colormap ) ) ;  if ( colormap == ( unsigned char * ) NULL )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ ) * p ++ = ( unsigned char ) ScaleQuantumToChar ( ScaleShortToQuantum (  ReadBlobLSBShort ( image ) ) ) ;  } if ( ( flags & 0x08 ) != 0 ) { char * comment ; size_t length ; length = ReadBlobLSBShort ( image ) ; if ( length != 0 ) { comment = ( char * ) AcquireQuantumMemory ( length , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , length - 1 , ( unsigned char * ) comment ) ; comment [ length - 1 ] = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment , exception ) ; comment = DestroyString ( comment ) ; if ( ( length & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; } } if ( EOFBlob ( image ) != MagickFalse )  {   ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ; break ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) number_planes ++ ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows * MagickMax ( number_planes_filled , 4 ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes_filled , 4 ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; ( void ) ResetMagickMemory ( pixels , 0 , pixel_info_length ) ; if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) { ssize_t j ; p = pixels ; for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( image -> alpha_trait == UndefinedPixelTrait ) for ( j = 0 ; j < ( ssize_t ) number_planes ; j ++ ) * p ++ = background_color [ j ] ; else { for ( j = 0 ; j < ( ssize_t ) ( number_planes - 1 ) ; j ++ ) * p ++ = background_color [ j ] ; * p ++ = 0 ; } } } plane = 0 ; x = 0 ; y = 0 ; opcode = ReadBlobByte ( image ) ;  do  { switch ( opcode & 0x3f ) { case SkipLinesOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  x = 0 ; y += operand ; break ; } case SetColorOp : { operand = ReadBlobByte ( image ) ;  plane = ( unsigned char ) operand ;  if ( plane == 255 ) plane = ( unsigned char ) ( number_planes - 1 ) ; x = 0 ; break ; } case SkipPixelsOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  x += operand ; break ; } case ByteDataOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;   offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;  operand ++ ; if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } if ( operand & 0x01 ) ( void ) ReadBlobByte ( image ) ; x += operand ; break ; } case RunDataOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  pixel = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) ReadBlobByte ( image ) ;  offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;  operand ++ ; if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } x += operand ; break ; } default : break ; } opcode = ReadBlobByte ( image ) ;  } while ( ( ( opcode & 0x3f ) != EOFOp ) && ( opcode != EOF ) ) ;  if ( number_colormaps != 0 ) { MagickStatusType mask ; mask = ( MagickStatusType ) ( map_length - 1 ) ; p = pixels ; x = ( ssize_t ) number_planes ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) {  ValidateColormapValue ( image , * p & mask , & index , exception ) ;  * p = colormap [ ( ssize_t ) index ] ; p ++ ; } else if ( ( number_planes >= 3 ) && ( number_colormaps >= 3 ) ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) for ( x = 0 ; x < ( ssize_t ) number_planes ; x ++ ) {  ValidateColormapValue ( image , ( size_t ) ( x * map_length +  ( * p & mask ) ) , & index , exception ) ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } if ( ( i < ( ssize_t ) number_pixels ) || ( x < ( ssize_t ) number_planes ) ) { colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } } if ( number_planes >= 3 ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( number_colormaps == 0 ) map_length = 256 ; if ( AcquireImageColormap ( image , map_length , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; } else if ( number_colormaps > 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( * p ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( * ( p + map_length ) ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( * ( p + map_length * 2 ) ) ; p ++ ; } p = pixels ; if ( image -> alpha_trait == UndefinedPixelTrait ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) {  SetPixelIndex ( image , * p ++ , q ) ;  q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; } else { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . red ) , q ) ; ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . green ) , q ) ; ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . blue ) , q ) ; SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } image -> colormap = ( PixelInfo * ) RelinquishMagickMemory ( image -> colormap ) ; image -> storage_class = DirectClass ; image -> colors = 0 ; } } if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; ( void ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }",}if ( number_colormaps != 0 ) {,183
268,"buggy line: ValidateColormapValue ( image , * p & mask , & index , exception ) ;* p = colormap [ ( ssize_t ) index ] ;cwe id:CWE-20context: static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07  char  magick [ 12 ] ; Image * image ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; Quantum index ; register ssize_t x ; register Quantum * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , pixel_info_length ; ssize_t count , offset , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;  count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ;  if ( ( count != 2 ) || ( memcmp ( magick , ""\\122\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do {  image -> page . x = ReadBlobLSBShort ( image ) ;   image -> page . y = ReadBlobLSBShort ( image ) ;  image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlobByte ( image ) ; image -> alpha_trait = flags & 0x04 ? BlendPixelTrait : UndefinedPixelTrait ; number_planes = ( size_t ) ReadBlobByte ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; number_colormaps = ( size_t ) ReadBlobByte ( image ) ; map_length = ( unsigned char ) ReadBlobByte ( image ) ; if ( map_length >= 22 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;  one = 1 ;  map_length = one << map_length ; if ( ( number_planes == 0 ) || ( number_planes == 2 ) || ( ( flags & 0x04 ) && ( number_colormaps > 254 ) ) || ( bits_per_pixel != 8 ) || ( image -> columns == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( flags & 0x02 ) { for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) background_color [ i ] = 0 ; ( void ) ReadBlobByte ( image ) ; } else { p = background_color ; for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) * p ++ = ( unsigned char ) ReadBlobByte ( image ) ; } if ( ( number_planes & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse )  {   ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ; break ; }  colormap = ( unsigned char * ) NULL ;  if ( number_colormaps != 0 ) {  colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps ,  3 * map_length * sizeof ( * colormap ) ) ;  if ( colormap == ( unsigned char * ) NULL )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ ) * p ++ = ( unsigned char ) ScaleQuantumToChar ( ScaleShortToQuantum (  ReadBlobLSBShort ( image ) ) ) ;  } if ( ( flags & 0x08 ) != 0 ) { char * comment ; size_t length ; length = ReadBlobLSBShort ( image ) ; if ( length != 0 ) { comment = ( char * ) AcquireQuantumMemory ( length , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , length - 1 , ( unsigned char * ) comment ) ; comment [ length - 1 ] = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment , exception ) ; comment = DestroyString ( comment ) ; if ( ( length & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; } } if ( EOFBlob ( image ) != MagickFalse )  {   ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ; break ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) number_planes ++ ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows * MagickMax ( number_planes_filled , 4 ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes_filled , 4 ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; ( void ) ResetMagickMemory ( pixels , 0 , pixel_info_length ) ; if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) { ssize_t j ; p = pixels ; for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( image -> alpha_trait == UndefinedPixelTrait ) for ( j = 0 ; j < ( ssize_t ) number_planes ; j ++ ) * p ++ = background_color [ j ] ; else { for ( j = 0 ; j < ( ssize_t ) ( number_planes - 1 ) ; j ++ ) * p ++ = background_color [ j ] ; * p ++ = 0 ; } } } plane = 0 ; x = 0 ; y = 0 ; opcode = ReadBlobByte ( image ) ;  do  { switch ( opcode & 0x3f ) { case SkipLinesOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  x = 0 ; y += operand ; break ; } case SetColorOp : { operand = ReadBlobByte ( image ) ;  plane = ( unsigned char ) operand ;  if ( plane == 255 ) plane = ( unsigned char ) ( number_planes - 1 ) ; x = 0 ; break ; } case SkipPixelsOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  x += operand ; break ; } case ByteDataOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;   offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;  operand ++ ; if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } if ( operand & 0x01 ) ( void ) ReadBlobByte ( image ) ; x += operand ; break ; } case RunDataOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  pixel = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) ReadBlobByte ( image ) ;  offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;  operand ++ ; if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } x += operand ; break ; } default : break ; } opcode = ReadBlobByte ( image ) ;  } while ( ( ( opcode & 0x3f ) != EOFOp ) && ( opcode != EOF ) ) ;  if ( number_colormaps != 0 ) { MagickStatusType mask ; mask = ( MagickStatusType ) ( map_length - 1 ) ; p = pixels ; x = ( ssize_t ) number_planes ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) {  ValidateColormapValue ( image , * p & mask , & index , exception ) ;  * p = colormap [ ( ssize_t ) index ] ; p ++ ; } else if ( ( number_planes >= 3 ) && ( number_colormaps >= 3 ) ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) for ( x = 0 ; x < ( ssize_t ) number_planes ; x ++ ) {  ValidateColormapValue ( image , ( size_t ) ( x * map_length +  ( * p & mask ) ) , & index , exception ) ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } if ( ( i < ( ssize_t ) number_pixels ) || ( x < ( ssize_t ) number_planes ) ) { colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } } if ( number_planes >= 3 ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( number_colormaps == 0 ) map_length = 256 ; if ( AcquireImageColormap ( image , map_length , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; } else if ( number_colormaps > 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( * p ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( * ( p + map_length ) ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( * ( p + map_length * 2 ) ) ; p ++ ; } p = pixels ; if ( image -> alpha_trait == UndefinedPixelTrait ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) {  SetPixelIndex ( image , * p ++ , q ) ;  q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; } else { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . red ) , q ) ; ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . green ) , q ) ; ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . blue ) , q ) ; SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } image -> colormap = ( PixelInfo * ) RelinquishMagickMemory ( image -> colormap ) ; image -> storage_class = DirectClass ; image -> colors = 0 ; } } if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; ( void ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","ValidateColormapValue ( image , * p & mask , & index , exception ) ;* p = colormap [ ( ssize_t ) index ] ;",183
269,"buggy line: ValidateColormapValue ( image , ( size_t ) ( x * map_length +  ( * p & mask ) ) , & index , exception ) ;cwe id:CWE-20context: static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07  char  magick [ 12 ] ; Image * image ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; Quantum index ; register ssize_t x ; register Quantum * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , pixel_info_length ; ssize_t count , offset , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;  count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ;  if ( ( count != 2 ) || ( memcmp ( magick , ""\\122\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do {  image -> page . x = ReadBlobLSBShort ( image ) ;   image -> page . y = ReadBlobLSBShort ( image ) ;  image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlobByte ( image ) ; image -> alpha_trait = flags & 0x04 ? BlendPixelTrait : UndefinedPixelTrait ; number_planes = ( size_t ) ReadBlobByte ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; number_colormaps = ( size_t ) ReadBlobByte ( image ) ; map_length = ( unsigned char ) ReadBlobByte ( image ) ; if ( map_length >= 22 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;  one = 1 ;  map_length = one << map_length ; if ( ( number_planes == 0 ) || ( number_planes == 2 ) || ( ( flags & 0x04 ) && ( number_colormaps > 254 ) ) || ( bits_per_pixel != 8 ) || ( image -> columns == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( flags & 0x02 ) { for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) background_color [ i ] = 0 ; ( void ) ReadBlobByte ( image ) ; } else { p = background_color ; for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) * p ++ = ( unsigned char ) ReadBlobByte ( image ) ; } if ( ( number_planes & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse )  {   ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ; break ; }  colormap = ( unsigned char * ) NULL ;  if ( number_colormaps != 0 ) {  colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps ,  3 * map_length * sizeof ( * colormap ) ) ;  if ( colormap == ( unsigned char * ) NULL )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ ) * p ++ = ( unsigned char ) ScaleQuantumToChar ( ScaleShortToQuantum (  ReadBlobLSBShort ( image ) ) ) ;  } if ( ( flags & 0x08 ) != 0 ) { char * comment ; size_t length ; length = ReadBlobLSBShort ( image ) ; if ( length != 0 ) { comment = ( char * ) AcquireQuantumMemory ( length , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , length - 1 , ( unsigned char * ) comment ) ; comment [ length - 1 ] = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment , exception ) ; comment = DestroyString ( comment ) ; if ( ( length & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; } } if ( EOFBlob ( image ) != MagickFalse )  {   ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ; break ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) number_planes ++ ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows * MagickMax ( number_planes_filled , 4 ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes_filled , 4 ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; ( void ) ResetMagickMemory ( pixels , 0 , pixel_info_length ) ; if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) { ssize_t j ; p = pixels ; for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( image -> alpha_trait == UndefinedPixelTrait ) for ( j = 0 ; j < ( ssize_t ) number_planes ; j ++ ) * p ++ = background_color [ j ] ; else { for ( j = 0 ; j < ( ssize_t ) ( number_planes - 1 ) ; j ++ ) * p ++ = background_color [ j ] ; * p ++ = 0 ; } } } plane = 0 ; x = 0 ; y = 0 ; opcode = ReadBlobByte ( image ) ;  do  { switch ( opcode & 0x3f ) { case SkipLinesOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  x = 0 ; y += operand ; break ; } case SetColorOp : { operand = ReadBlobByte ( image ) ;  plane = ( unsigned char ) operand ;  if ( plane == 255 ) plane = ( unsigned char ) ( number_planes - 1 ) ; x = 0 ; break ; } case SkipPixelsOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  x += operand ; break ; } case ByteDataOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;   offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;  operand ++ ; if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } if ( operand & 0x01 ) ( void ) ReadBlobByte ( image ) ; x += operand ; break ; } case RunDataOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  pixel = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) ReadBlobByte ( image ) ;  offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;  operand ++ ; if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } x += operand ; break ; } default : break ; } opcode = ReadBlobByte ( image ) ;  } while ( ( ( opcode & 0x3f ) != EOFOp ) && ( opcode != EOF ) ) ;  if ( number_colormaps != 0 ) { MagickStatusType mask ; mask = ( MagickStatusType ) ( map_length - 1 ) ; p = pixels ; x = ( ssize_t ) number_planes ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) {  ValidateColormapValue ( image , * p & mask , & index , exception ) ;  * p = colormap [ ( ssize_t ) index ] ; p ++ ; } else if ( ( number_planes >= 3 ) && ( number_colormaps >= 3 ) ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) for ( x = 0 ; x < ( ssize_t ) number_planes ; x ++ ) {  ValidateColormapValue ( image , ( size_t ) ( x * map_length +  ( * p & mask ) ) , & index , exception ) ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } if ( ( i < ( ssize_t ) number_pixels ) || ( x < ( ssize_t ) number_planes ) ) { colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } } if ( number_planes >= 3 ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( number_colormaps == 0 ) map_length = 256 ; if ( AcquireImageColormap ( image , map_length , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; } else if ( number_colormaps > 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( * p ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( * ( p + map_length ) ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( * ( p + map_length * 2 ) ) ; p ++ ; } p = pixels ; if ( image -> alpha_trait == UndefinedPixelTrait ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) {  SetPixelIndex ( image , * p ++ , q ) ;  q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; } else { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . red ) , q ) ; ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . green ) , q ) ; ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . blue ) , q ) ; SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } image -> colormap = ( PixelInfo * ) RelinquishMagickMemory ( image -> colormap ) ; image -> storage_class = DirectClass ; image -> colors = 0 ; } } if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; ( void ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","ValidateColormapValue ( image , ( size_t ) ( x * map_length + ( * p & mask ) ) , & index , exception ) ;",183
270,"buggy line: SetPixelIndex ( image , * p ++ , q ) ;q += GetPixelChannels ( image ) ;cwe id:CWE-20context: static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07  char  magick [ 12 ] ; Image * image ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; Quantum index ; register ssize_t x ; register Quantum * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , pixel_info_length ; ssize_t count , offset , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;  count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ;  if ( ( count != 2 ) || ( memcmp ( magick , ""\\122\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do {  image -> page . x = ReadBlobLSBShort ( image ) ;   image -> page . y = ReadBlobLSBShort ( image ) ;  image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlobByte ( image ) ; image -> alpha_trait = flags & 0x04 ? BlendPixelTrait : UndefinedPixelTrait ; number_planes = ( size_t ) ReadBlobByte ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; number_colormaps = ( size_t ) ReadBlobByte ( image ) ; map_length = ( unsigned char ) ReadBlobByte ( image ) ; if ( map_length >= 22 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;  one = 1 ;  map_length = one << map_length ; if ( ( number_planes == 0 ) || ( number_planes == 2 ) || ( ( flags & 0x04 ) && ( number_colormaps > 254 ) ) || ( bits_per_pixel != 8 ) || ( image -> columns == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( flags & 0x02 ) { for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) background_color [ i ] = 0 ; ( void ) ReadBlobByte ( image ) ; } else { p = background_color ; for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) * p ++ = ( unsigned char ) ReadBlobByte ( image ) ; } if ( ( number_planes & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse )  {   ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ; break ; }  colormap = ( unsigned char * ) NULL ;  if ( number_colormaps != 0 ) {  colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps ,  3 * map_length * sizeof ( * colormap ) ) ;  if ( colormap == ( unsigned char * ) NULL )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ ) * p ++ = ( unsigned char ) ScaleQuantumToChar ( ScaleShortToQuantum (  ReadBlobLSBShort ( image ) ) ) ;  } if ( ( flags & 0x08 ) != 0 ) { char * comment ; size_t length ; length = ReadBlobLSBShort ( image ) ; if ( length != 0 ) { comment = ( char * ) AcquireQuantumMemory ( length , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , length - 1 , ( unsigned char * ) comment ) ; comment [ length - 1 ] = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment , exception ) ; comment = DestroyString ( comment ) ; if ( ( length & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; } } if ( EOFBlob ( image ) != MagickFalse )  {   ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ; break ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) number_planes ++ ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows * MagickMax ( number_planes_filled , 4 ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes_filled , 4 ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; ( void ) ResetMagickMemory ( pixels , 0 , pixel_info_length ) ; if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) { ssize_t j ; p = pixels ; for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( image -> alpha_trait == UndefinedPixelTrait ) for ( j = 0 ; j < ( ssize_t ) number_planes ; j ++ ) * p ++ = background_color [ j ] ; else { for ( j = 0 ; j < ( ssize_t ) ( number_planes - 1 ) ; j ++ ) * p ++ = background_color [ j ] ; * p ++ = 0 ; } } } plane = 0 ; x = 0 ; y = 0 ; opcode = ReadBlobByte ( image ) ;  do  { switch ( opcode & 0x3f ) { case SkipLinesOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  x = 0 ; y += operand ; break ; } case SetColorOp : { operand = ReadBlobByte ( image ) ;  plane = ( unsigned char ) operand ;  if ( plane == 255 ) plane = ( unsigned char ) ( number_planes - 1 ) ; x = 0 ; break ; } case SkipPixelsOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  x += operand ; break ; } case ByteDataOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;   offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;  operand ++ ; if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } if ( operand & 0x01 ) ( void ) ReadBlobByte ( image ) ; x += operand ; break ; } case RunDataOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  pixel = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) ReadBlobByte ( image ) ;  offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;  operand ++ ; if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } x += operand ; break ; } default : break ; } opcode = ReadBlobByte ( image ) ;  } while ( ( ( opcode & 0x3f ) != EOFOp ) && ( opcode != EOF ) ) ;  if ( number_colormaps != 0 ) { MagickStatusType mask ; mask = ( MagickStatusType ) ( map_length - 1 ) ; p = pixels ; x = ( ssize_t ) number_planes ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) {  ValidateColormapValue ( image , * p & mask , & index , exception ) ;  * p = colormap [ ( ssize_t ) index ] ; p ++ ; } else if ( ( number_planes >= 3 ) && ( number_colormaps >= 3 ) ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) for ( x = 0 ; x < ( ssize_t ) number_planes ; x ++ ) {  ValidateColormapValue ( image , ( size_t ) ( x * map_length +  ( * p & mask ) ) , & index , exception ) ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } if ( ( i < ( ssize_t ) number_pixels ) || ( x < ( ssize_t ) number_planes ) ) { colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } } if ( number_planes >= 3 ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( number_colormaps == 0 ) map_length = 256 ; if ( AcquireImageColormap ( image , map_length , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; } else if ( number_colormaps > 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( * p ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( * ( p + map_length ) ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( * ( p + map_length * 2 ) ) ; p ++ ; } p = pixels ; if ( image -> alpha_trait == UndefinedPixelTrait ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) {  SetPixelIndex ( image , * p ++ , q ) ;  q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; } else { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . red ) , q ) ; ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . green ) , q ) ; ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . blue ) , q ) ; SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } image -> colormap = ( PixelInfo * ) RelinquishMagickMemory ( image -> colormap ) ; image -> storage_class = DirectClass ; image -> colors = 0 ; } } if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; ( void ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","SetPixelIndex ( image , * p ++ , q ) ;q += GetPixelChannels ( image ) ;",183
271,"buggy line: if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ;pixel_info = RelinquishVirtualMemory ( pixel_info ) ;if ( EOFBlob ( image ) != MagickFalse ) {ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ;break ;if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;( void ) ReadBlobByte ( image ) ;count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ;cwe id:CWE-20context: static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07  char  magick [ 12 ] ; Image * image ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; Quantum index ; register ssize_t x ; register Quantum * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , pixel_info_length ; ssize_t count , offset , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;  count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ;  if ( ( count != 2 ) || ( memcmp ( magick , ""\\122\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do {  image -> page . x = ReadBlobLSBShort ( image ) ;   image -> page . y = ReadBlobLSBShort ( image ) ;  image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlobByte ( image ) ; image -> alpha_trait = flags & 0x04 ? BlendPixelTrait : UndefinedPixelTrait ; number_planes = ( size_t ) ReadBlobByte ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; number_colormaps = ( size_t ) ReadBlobByte ( image ) ; map_length = ( unsigned char ) ReadBlobByte ( image ) ; if ( map_length >= 22 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;  one = 1 ;  map_length = one << map_length ; if ( ( number_planes == 0 ) || ( number_planes == 2 ) || ( ( flags & 0x04 ) && ( number_colormaps > 254 ) ) || ( bits_per_pixel != 8 ) || ( image -> columns == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( flags & 0x02 ) { for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) background_color [ i ] = 0 ; ( void ) ReadBlobByte ( image ) ; } else { p = background_color ; for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) * p ++ = ( unsigned char ) ReadBlobByte ( image ) ; } if ( ( number_planes & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse )  {   ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ; break ; }  colormap = ( unsigned char * ) NULL ;  if ( number_colormaps != 0 ) {  colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps ,  3 * map_length * sizeof ( * colormap ) ) ;  if ( colormap == ( unsigned char * ) NULL )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ ) * p ++ = ( unsigned char ) ScaleQuantumToChar ( ScaleShortToQuantum (  ReadBlobLSBShort ( image ) ) ) ;  } if ( ( flags & 0x08 ) != 0 ) { char * comment ; size_t length ; length = ReadBlobLSBShort ( image ) ; if ( length != 0 ) { comment = ( char * ) AcquireQuantumMemory ( length , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , length - 1 , ( unsigned char * ) comment ) ; comment [ length - 1 ] = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment , exception ) ; comment = DestroyString ( comment ) ; if ( ( length & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; } } if ( EOFBlob ( image ) != MagickFalse )  {   ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ; break ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) number_planes ++ ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows * MagickMax ( number_planes_filled , 4 ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes_filled , 4 ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; ( void ) ResetMagickMemory ( pixels , 0 , pixel_info_length ) ; if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) { ssize_t j ; p = pixels ; for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( image -> alpha_trait == UndefinedPixelTrait ) for ( j = 0 ; j < ( ssize_t ) number_planes ; j ++ ) * p ++ = background_color [ j ] ; else { for ( j = 0 ; j < ( ssize_t ) ( number_planes - 1 ) ; j ++ ) * p ++ = background_color [ j ] ; * p ++ = 0 ; } } } plane = 0 ; x = 0 ; y = 0 ; opcode = ReadBlobByte ( image ) ;  do  { switch ( opcode & 0x3f ) { case SkipLinesOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  x = 0 ; y += operand ; break ; } case SetColorOp : { operand = ReadBlobByte ( image ) ;  plane = ( unsigned char ) operand ;  if ( plane == 255 ) plane = ( unsigned char ) ( number_planes - 1 ) ; x = 0 ; break ; } case SkipPixelsOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  x += operand ; break ; } case ByteDataOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;   offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;  operand ++ ; if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } if ( operand & 0x01 ) ( void ) ReadBlobByte ( image ) ; x += operand ; break ; } case RunDataOp : { operand = ReadBlobByte ( image ) ;  if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;  pixel = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) ReadBlobByte ( image ) ;  offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;  operand ++ ; if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } x += operand ; break ; } default : break ; } opcode = ReadBlobByte ( image ) ;  } while ( ( ( opcode & 0x3f ) != EOFOp ) && ( opcode != EOF ) ) ;  if ( number_colormaps != 0 ) { MagickStatusType mask ; mask = ( MagickStatusType ) ( map_length - 1 ) ; p = pixels ; x = ( ssize_t ) number_planes ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) {  ValidateColormapValue ( image , * p & mask , & index , exception ) ;  * p = colormap [ ( ssize_t ) index ] ; p ++ ; } else if ( ( number_planes >= 3 ) && ( number_colormaps >= 3 ) ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) for ( x = 0 ; x < ( ssize_t ) number_planes ; x ++ ) {  ValidateColormapValue ( image , ( size_t ) ( x * map_length +  ( * p & mask ) ) , & index , exception ) ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } if ( ( i < ( ssize_t ) number_pixels ) || ( x < ( ssize_t ) number_planes ) ) { colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } } if ( number_planes >= 3 ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( number_colormaps == 0 ) map_length = 256 ; if ( AcquireImageColormap ( image , map_length , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; } else if ( number_colormaps > 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( * p ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( * ( p + map_length ) ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( * ( p + map_length * 2 ) ) ; p ++ ; } p = pixels ; if ( image -> alpha_trait == UndefinedPixelTrait ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) {  SetPixelIndex ( image , * p ++ , q ) ;  q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; } else { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . red ) , q ) ; ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . green ) , q ) ; ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . blue ) , q ) ; SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } image -> colormap = ( PixelInfo * ) RelinquishMagickMemory ( image -> colormap ) ; image -> storage_class = DirectClass ; image -> colors = 0 ; } } if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; ( void ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","if ( number_colormaps != 0 ) colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps , 3 * map_length * sizeof ( * colormap ) ) ;if ( EOFBlob ( image ) != MagickFalse ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;if ( colormap == ( unsigned char * ) magick ) ;if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;}if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;}if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;",183
272,"buggy line: ext2_xattr_put_super ( sb ) ;if ( ! ( sb -> s_flags & MS_RDONLY ) ) {cwe id:CWE-19context: static void ext2_put_super ( struct super_block * sb ) { int db_count ; int i ; struct ext2_sb_info * sbi = EXT2_SB ( sb ) ; dquot_disable ( sb , - 1 , DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED ) ;  ext2_xattr_put_super ( sb ) ;  if ( ! ( sb -> s_flags & MS_RDONLY ) ) { struct ext2_super_block * es = sbi -> s_es ; spin_lock ( & sbi -> s_lock ) ; es -> s_state = cpu_to_le16 ( sbi -> s_mount_state ) ; spin_unlock ( & sbi -> s_lock ) ; ext2_sync_super ( sb , es , 1 ) ; } db_count = sbi -> s_gdb_count ; for ( i = 0 ; i < db_count ; i ++ ) if ( sbi -> s_group_desc [ i ] ) brelse ( sbi -> s_group_desc [ i ] ) ; kfree ( sbi -> s_group_desc ) ; kfree ( sbi -> s_debts ) ; percpu_counter_destroy ( & sbi -> s_freeblocks_counter ) ; percpu_counter_destroy ( & sbi -> s_freeinodes_counter ) ; percpu_counter_destroy ( & sbi -> s_dirs_counter ) ; brelse ( sbi -> s_sbh ) ; sb -> s_fs_info = NULL ; kfree ( sbi -> s_blockgroup_lock ) ; kfree ( sbi ) ; }",if ( sbi -> s_mb_cache ) {ext2_xattr_destroy_cache ( sbi -> s_mb_cache ) ;sbi -> s_mb_cache = NULL ;}if ( ! ( sb -> s_flags & MS_RDONLY ) ) {,184
273,"buggy line: endpoint = & usbinterface -> altsetting [ 0 ] . endpoint [ 0 ] . desc ;dev_dbg ( & usbinterface -> dev , ""gtco<S2SV_blank>#<S2SV_blank>interfaces:<S2SV_blank>%d\\\cwe id:CWE-000context: static int gtco_probe ( struct usb_interface * usbinterface , const struct usb_device_id * id ) { struct gtco * gtco ; struct input_dev * input_dev ; struct hid_descriptor * hid_desc ; char * report ; int result = 0 , retry ; int error ; struct usb_endpoint_descriptor * endpoint ; gtco = kzalloc ( sizeof ( struct gtco ) , GFP_KERNEL ) ; input_dev = input_allocate_device ( ) ; if ( ! gtco || ! input_dev ) { dev_err ( & usbinterface -> dev , ""No<S2SV_blank>more<S2SV_blank>memory\\n"" ) ; error = - ENOMEM ; goto err_free_devs ; } gtco -> inputdevice = input_dev ; gtco -> usbdev = interface_to_usbdev ( usbinterface ) ; gtco -> intf = usbinterface ; gtco -> buffer = usb_alloc_coherent ( gtco -> usbdev , REPORT_MAX_SIZE , GFP_KERNEL , & gtco -> buf_dma ) ; if ( ! gtco -> buffer ) { dev_err ( & usbinterface -> dev , ""No<S2SV_blank>more<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>us<S2SV_blank>buffers\\n"" ) ; error = - ENOMEM ; goto err_free_devs ; } gtco -> urbinfo = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! gtco -> urbinfo ) { dev_err ( & usbinterface -> dev , ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>URB\\n"" ) ; error = - ENOMEM ; goto err_free_buf ; }  endpoint = & usbinterface -> altsetting [ 0 ] . endpoint [ 0 ] . desc ;  dev_dbg ( & usbinterface -> dev , ""gtco<S2SV_blank>#<S2SV_blank>interfaces:<S2SV_blank>%d\\n"" , usbinterface -> num_altsetting ) ; dev_dbg ( & usbinterface -> dev , ""num<S2SV_blank>endpoints:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d\\n"" , usbinterface -> cur_altsetting -> desc . bNumEndpoints ) ; dev_dbg ( & usbinterface -> dev , ""interface<S2SV_blank>class:<S2SV_blank><S2SV_blank><S2SV_blank>%d\\n"" , usbinterface -> cur_altsetting -> desc . bInterfaceClass ) ; dev_dbg ( & usbinterface -> dev , ""endpoint:<S2SV_blank>attribute:0x%x<S2SV_blank>type:0x%x\\n"" , endpoint -> bmAttributes , endpoint -> bDescriptorType ) ; if ( usb_endpoint_xfer_int ( endpoint ) ) dev_dbg ( & usbinterface -> dev , ""endpoint:<S2SV_blank>we<S2SV_blank>have<S2SV_blank>interrupt<S2SV_blank>endpoint\\n"" ) ; dev_dbg ( & usbinterface -> dev , ""endpoint<S2SV_blank>extra<S2SV_blank>len:%d\\n"" , usbinterface -> altsetting [ 0 ] . extralen ) ; if ( usb_get_extra_descriptor ( usbinterface -> cur_altsetting , HID_DEVICE_TYPE , & hid_desc ) != 0 ) { dev_err ( & usbinterface -> dev , ""Can\'t<S2SV_blank>retrieve<S2SV_blank>exta<S2SV_blank>USB<S2SV_blank>descriptor<S2SV_blank>to<S2SV_blank>get<S2SV_blank>hid<S2SV_blank>report<S2SV_blank>descriptor<S2SV_blank>length\\n"" ) ; error = - EIO ; goto err_free_urb ; } dev_dbg ( & usbinterface -> dev , ""Extra<S2SV_blank>descriptor<S2SV_blank>success:<S2SV_blank>type:%d<S2SV_blank><S2SV_blank>len:%d\\n"" , hid_desc -> bDescriptorType , hid_desc -> wDescriptorLength ) ; report = kzalloc ( le16_to_cpu ( hid_desc -> wDescriptorLength ) , GFP_KERNEL ) ; if ( ! report ) { dev_err ( & usbinterface -> dev , ""No<S2SV_blank>more<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>report\\n"" ) ; error = - ENOMEM ; goto err_free_urb ; } for ( retry = 0 ; retry < 3 ; retry ++ ) { result = usb_control_msg ( gtco -> usbdev , usb_rcvctrlpipe ( gtco -> usbdev , 0 ) , USB_REQ_GET_DESCRIPTOR , USB_RECIP_INTERFACE | USB_DIR_IN , REPORT_DEVICE_TYPE << 8 , 0 , report , le16_to_cpu ( hid_desc -> wDescriptorLength ) , 5000 ) ; dev_dbg ( & usbinterface -> dev , ""usb_control_msg<S2SV_blank>result:<S2SV_blank>%d\\n"" , result ) ; if ( result == le16_to_cpu ( hid_desc -> wDescriptorLength ) ) { parse_hid_report_descriptor ( gtco , report , result ) ; break ; } } kfree ( report ) ; if ( result != le16_to_cpu ( hid_desc -> wDescriptorLength ) ) { dev_err ( & usbinterface -> dev , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>HID<S2SV_blank>Report<S2SV_blank>Descriptor<S2SV_blank>of<S2SV_blank>size:<S2SV_blank>%d\\n"" , hid_desc -> wDescriptorLength ) ; error = - EIO ; goto err_free_urb ; } usb_make_path ( gtco -> usbdev , gtco -> usbpath , sizeof ( gtco -> usbpath ) ) ; strlcat ( gtco -> usbpath , ""/input0"" , sizeof ( gtco -> usbpath ) ) ; input_dev -> open = gtco_input_open ; input_dev -> close = gtco_input_close ; input_dev -> name = ""GTCO_CalComp"" ; input_dev -> phys = gtco -> usbpath ; input_set_drvdata ( input_dev , gtco ) ; gtco_setup_caps ( input_dev ) ; usb_to_input_id ( gtco -> usbdev , & input_dev -> id ) ; input_dev -> dev . parent = & usbinterface -> dev ; endpoint = & usbinterface -> altsetting [ 0 ] . endpoint [ 0 ] . desc ; usb_fill_int_urb ( gtco -> urbinfo , gtco -> usbdev , usb_rcvintpipe ( gtco -> usbdev , endpoint -> bEndpointAddress ) , gtco -> buffer , REPORT_MAX_SIZE , gtco_urb_callback , gtco , endpoint -> bInterval ) ; gtco -> urbinfo -> transfer_dma = gtco -> buf_dma ; gtco -> urbinfo -> transfer_flags |= URB_NO_TRANSFER_DMA_MAP ; usb_set_intfdata ( usbinterface , gtco ) ; error = input_register_device ( input_dev ) ; if ( error ) goto err_free_urb ; return 0 ; err_free_urb : usb_free_urb ( gtco -> urbinfo ) ; err_free_buf : usb_free_coherent ( gtco -> usbdev , REPORT_MAX_SIZE , gtco -> buffer , gtco -> buf_dma ) ; err_free_devs : input_free_device ( input_dev ) ; kfree ( gtco ) ; return error ; }","if ( usbinterface -> altsetting [ 0 ] . desc . bNumEndpoints < 1 ) {dev_err ( & usbinterface -> dev , ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>endpoints\\\error = - EINVAL ;goto err_free_urb ;}endpoint = & usbinterface -> altsetting [ 0 ] . endpoint [ 0 ] . desc ;dev_dbg ( & usbinterface -> dev , ""gtco<S2SV_blank>#<S2SV_blank>interfaces:<S2SV_blank>%d\\\",185
274,"buggy line: if ( ! cfg . shell )  cfg . shell = guess_shell ( ) ;if ( ! cfg . shell ) {fprintf ( stderr , ""Error:<S2SV_blank>no<S2SV_blank>POSIX<S2SV_blank>shell<S2SV_blank>found,<S2SV_blank>please<S2SV_blank>use<S2SV_blank>--shell<S2SV_blank>command<S2SV_blank>line<S2SV_blank>option\\\exit ( 1 ) ;}arg [ 0 ] = cfg . shell ;arg [ 1 ] = ""-c"" ;cwe id:CWE-269context: void bandwidth_pid ( pid_t pid , const char * command , const char * dev , int down , int up ) { EUID_ASSERT ( ) ; EUID_ROOT ( ) ; char * comm = pid_proc_comm ( pid ) ; EUID_USER ( ) ; if ( ! comm ) { fprintf ( stderr , ""Error:<S2SV_blank>cannot<S2SV_blank>find<S2SV_blank>sandbox\\n"" ) ; exit ( 1 ) ; } if ( strcmp ( comm , ""firejail"" ) != 0 ) { fprintf ( stderr , ""Error:<S2SV_blank>cannot<S2SV_blank>find<S2SV_blank>sandbox\\n"" ) ; exit ( 1 ) ; } free ( comm ) ; char * name ; if ( asprintf ( & name , ""/run/firejail/network/%d-netmap"" , pid ) == - 1 ) errExit ( ""asprintf"" ) ; struct stat s ; if ( stat ( name , & s ) == - 1 ) { fprintf ( stderr , ""Error:<S2SV_blank>the<S2SV_blank>sandbox<S2SV_blank>doesn\'t<S2SV_blank>use<S2SV_blank>a<S2SV_blank>new<S2SV_blank>network<S2SV_blank>namespace\\n"" ) ; exit ( 1 ) ; } pid_t child ; if ( find_child ( pid , & child ) == - 1 ) { fprintf ( stderr , ""Error:<S2SV_blank>cannot<S2SV_blank>join<S2SV_blank>the<S2SV_blank>network<S2SV_blank>namespace\\n"" ) ; exit ( 1 ) ; } EUID_ROOT ( ) ; if ( join_namespace ( child , ""net"" ) ) { fprintf ( stderr , ""Error:<S2SV_blank>cannot<S2SV_blank>join<S2SV_blank>the<S2SV_blank>network<S2SV_blank>namespace\\n"" ) ; exit ( 1 ) ; } if ( strcmp ( command , ""set"" ) == 0 ) bandwidth_set ( pid , dev , down , up ) ; else if ( strcmp ( command , ""clear"" ) == 0 ) bandwidth_remove ( pid , dev ) ; char * devname = NULL ; if ( dev ) { char * fname ; if ( asprintf ( & fname , ""%s/%d-netmap"" , RUN_FIREJAIL_NETWORK_DIR , ( int ) pid ) == - 1 ) errExit ( ""asprintf"" ) ; FILE * fp = fopen ( fname , ""r"" ) ; if ( ! fp ) { fprintf ( stderr , ""Error:<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>network<S2SV_blank>map<S2SV_blank>file<S2SV_blank>%s\\n"" , fname ) ; exit ( 1 ) ; } char buf [ 1024 ] ; int len = strlen ( dev ) ; while ( fgets ( buf , 1024 , fp ) ) { char * ptr = strchr ( buf , '\\n' ) ; if ( ptr ) * ptr = '\\0' ; if ( * buf == '\\0' ) break ; if ( strncmp ( buf , dev , len ) == 0 && buf [ len ] == ':' ) { devname = strdup ( buf + len + 1 ) ; if ( ! devname ) errExit ( ""strdup"" ) ; if ( if_nametoindex ( devname ) == 0 ) { fprintf ( stderr , ""Error:<S2SV_blank>cannot<S2SV_blank>find<S2SV_blank>network<S2SV_blank>device<S2SV_blank>%s\\n"" , devname ) ; exit ( 1 ) ; } break ; } } free ( fname ) ; fclose ( fp ) ; } char * cmd = NULL ; if ( devname ) { if ( strcmp ( command , ""set"" ) == 0 ) { if ( asprintf ( & cmd , ""%s/firejail/fshaper.sh<S2SV_blank>--%s<S2SV_blank>%s<S2SV_blank>%d<S2SV_blank>%d"" , LIBDIR , command , devname , down , up ) == - 1 ) errExit ( ""asprintf"" ) ; } else { if ( asprintf ( & cmd , ""%s/firejail/fshaper.sh<S2SV_blank>--%s<S2SV_blank>%s"" , LIBDIR , command , devname ) == - 1 ) errExit ( ""asprintf"" ) ; } } else { if ( asprintf ( & cmd , ""%s/firejail/fshaper.sh<S2SV_blank>--%s"" , LIBDIR , command ) == - 1 ) errExit ( ""asprintf"" ) ; } assert ( cmd ) ; environ = NULL ; if ( setreuid ( 0 , 0 ) ) errExit ( ""setreuid"" ) ; if ( setregid ( 0 , 0 ) ) errExit ( ""setregid"" ) ;  if ( ! cfg . shell )  cfg . shell = guess_shell ( ) ; if ( ! cfg . shell ) { fprintf ( stderr , ""Error:<S2SV_blank>no<S2SV_blank>POSIX<S2SV_blank>shell<S2SV_blank>found,<S2SV_blank>please<S2SV_blank>use<S2SV_blank>--shell<S2SV_blank>command<S2SV_blank>line<S2SV_blank>option\\n"" ) ; exit ( 1 ) ; } char * arg [ 4 ] ;  arg [ 0 ] = cfg . shell ;  arg [ 1 ] = ""-c"" ; arg [ 2 ] = cmd ; arg [ 3 ] = NULL ; clearenv ( ) ; execvp ( arg [ 0 ] , arg ) ; errExit ( ""execvp"" ) ; }","arg [ 0 ] = cfg . shell ;arg [ 1 ] = ""-c"" ;",186
275,buggy line: return to_o2nm_cluster ( node -> nd_item . ci_parent -> ci_parent ) ;}cwe id:CWE-476context: static struct o2nm_cluster * to_o2nm_cluster_from_node ( struct o2nm_node * node ) {  return to_o2nm_cluster ( node -> nd_item . ci_parent -> ci_parent ) ;   } ,if ( node -> nd_item . ci_parent ) return to_o2nm_cluster ( node -> nd_item . ci_parent -> ci_parent ) ;else return NULL ;},187
276,"buggy line: static void nfs_set_open_stateid ( struct nfs4_state * state , nfs4_stateid * stateid , int open_flags )  {nfs_set_open_stateid_locked ( state , stateid , open_flags ) ;write_sequnlock ( & state -> seqlock ) ;cwe id:CWE-000context:  static void nfs_set_open_stateid ( struct nfs4_state * state , nfs4_stateid * stateid , int open_flags )  { write_seqlock ( & state -> seqlock ) ;  nfs_set_open_stateid_locked ( state , stateid , open_flags ) ;  write_sequnlock ( & state -> seqlock ) ; }","static void nfs_set_open_stateid ( struct nfs4_state * state , nfs4_stateid * stateid , fmode_t fmode ) {nfs_set_open_stateid_locked ( state , stateid , fmode ) ;write_sequnlock ( & state -> seqlock ) ;",188
277,"buggy line: cwe id:CWE-834context: static int mv_read_header ( AVFormatContext * avctx ) { MvContext * mv = avctx -> priv_data ; AVIOContext * pb = avctx -> pb ; AVStream * ast = NULL , * vst = NULL ; int version , i ; int ret ; avio_skip ( pb , 4 ) ; version = avio_rb16 ( pb ) ; if ( version == 2 ) { uint64_t timestamp ; int v ; avio_skip ( pb , 22 ) ; ast = avformat_new_stream ( avctx , NULL ) ; if ( ! ast ) return AVERROR ( ENOMEM ) ; vst = avformat_new_stream ( avctx , NULL ) ; if ( ! vst ) return AVERROR ( ENOMEM ) ; avpriv_set_pts_info ( vst , 64 , 1 , 15 ) ; vst -> codecpar -> codec_type = AVMEDIA_TYPE_VIDEO ; vst -> avg_frame_rate = av_inv_q ( vst -> time_base ) ; vst -> nb_frames = avio_rb32 ( pb ) ; v = avio_rb32 ( pb ) ; switch ( v ) { case 1 : vst -> codecpar -> codec_id = AV_CODEC_ID_MVC1 ; break ; case 2 : vst -> codecpar -> format = AV_PIX_FMT_ARGB ; vst -> codecpar -> codec_id = AV_CODEC_ID_RAWVIDEO ; break ; default : avpriv_request_sample ( avctx , ""Video<S2SV_blank>compression<S2SV_blank>%i"" , v ) ; break ; } vst -> codecpar -> codec_tag = 0 ; vst -> codecpar -> width = avio_rb32 ( pb ) ; vst -> codecpar -> height = avio_rb32 ( pb ) ; avio_skip ( pb , 12 ) ; ast -> codecpar -> codec_type = AVMEDIA_TYPE_AUDIO ; ast -> nb_frames = vst -> nb_frames ; ast -> codecpar -> sample_rate = avio_rb32 ( pb ) ; if ( ast -> codecpar -> sample_rate <= 0 ) { av_log ( avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>sample<S2SV_blank>rate<S2SV_blank>%d\\n"" , ast -> codecpar -> sample_rate ) ; return AVERROR_INVALIDDATA ; } avpriv_set_pts_info ( ast , 33 , 1 , ast -> codecpar -> sample_rate ) ; if ( set_channels ( avctx , ast , avio_rb32 ( pb ) ) < 0 ) return AVERROR_INVALIDDATA ; v = avio_rb32 ( pb ) ; if ( v == AUDIO_FORMAT_SIGNED ) { ast -> codecpar -> codec_id = AV_CODEC_ID_PCM_S16BE ; } else { avpriv_request_sample ( avctx , ""Audio<S2SV_blank>compression<S2SV_blank>(format<S2SV_blank>%i)"" , v ) ; } avio_skip ( pb , 12 ) ; var_read_metadata ( avctx , ""title"" , 0x80 ) ; var_read_metadata ( avctx , ""comment"" , 0x100 ) ; avio_skip ( pb , 0x80 ) ; timestamp = 0 ; for ( i = 0 ; i < vst -> nb_frames ; i ++ ) { uint32_t pos = avio_rb32 ( pb ) ; uint32_t asize = avio_rb32 ( pb ) ;  uint32_t vsize = avio_rb32 ( pb ) ;  avio_skip ( pb , 8 ) ; av_add_index_entry ( ast , pos , timestamp , asize , 0 , AVINDEX_KEYFRAME ) ; av_add_index_entry ( vst , pos + asize , i , vsize , 0 , AVINDEX_KEYFRAME ) ; timestamp += asize / ( ast -> codecpar -> channels * 2 ) ; } } else if ( ! version && avio_rb16 ( pb ) == 3 ) { avio_skip ( pb , 4 ) ; if ( ( ret = read_table ( avctx , NULL , parse_global_var ) ) < 0 ) return ret ; if ( mv -> nb_audio_tracks > 1 ) { avpriv_request_sample ( avctx , ""Multiple<S2SV_blank>audio<S2SV_blank>streams<S2SV_blank>support"" ) ; return AVERROR_PATCHWELCOME ; } else if ( mv -> nb_audio_tracks ) { ast = avformat_new_stream ( avctx , NULL ) ; if ( ! ast ) return AVERROR ( ENOMEM ) ; ast -> codecpar -> codec_type = AVMEDIA_TYPE_AUDIO ; if ( ( read_table ( avctx , ast , parse_audio_var ) ) < 0 ) return ret ; if ( mv -> acompression == 100 && mv -> aformat == AUDIO_FORMAT_SIGNED && ast -> codecpar -> bits_per_coded_sample == 16 ) { ast -> codecpar -> codec_id = AV_CODEC_ID_PCM_S16BE ; } else { avpriv_request_sample ( avctx , ""Audio<S2SV_blank>compression<S2SV_blank>%i<S2SV_blank>(format<S2SV_blank>%i,<S2SV_blank>sr<S2SV_blank>%i)"" , mv -> acompression , mv -> aformat , ast -> codecpar -> bits_per_coded_sample ) ; ast -> codecpar -> codec_id = AV_CODEC_ID_NONE ; } if ( ast -> codecpar -> channels <= 0 ) { av_log ( avctx , AV_LOG_ERROR , ""No<S2SV_blank>valid<S2SV_blank>channel<S2SV_blank>count<S2SV_blank>found.\\n"" ) ; return AVERROR_INVALIDDATA ; } } if ( mv -> nb_video_tracks > 1 ) { avpriv_request_sample ( avctx , ""Multiple<S2SV_blank>video<S2SV_blank>streams<S2SV_blank>support"" ) ; return AVERROR_PATCHWELCOME ; } else if ( mv -> nb_video_tracks ) { vst = avformat_new_stream ( avctx , NULL ) ; if ( ! vst ) return AVERROR ( ENOMEM ) ; vst -> codecpar -> codec_type = AVMEDIA_TYPE_VIDEO ; if ( ( ret = read_table ( avctx , vst , parse_video_var ) ) < 0 ) return ret ; } if ( mv -> nb_audio_tracks ) read_index ( pb , ast ) ; if ( mv -> nb_video_tracks ) read_index ( pb , vst ) ; } else { avpriv_request_sample ( avctx , ""Version<S2SV_blank>%i"" , version ) ; return AVERROR_PATCHWELCOME ; } return 0 ; }",if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ;,189
278,"buggy line: uint32_t vsize = avio_rb32 ( pb ) ;avio_skip ( pb , 8 ) ;cwe id:CWE-834context: static int mv_read_header ( AVFormatContext * avctx ) { MvContext * mv = avctx -> priv_data ; AVIOContext * pb = avctx -> pb ; AVStream * ast = NULL , * vst = NULL ; int version , i ; int ret ; avio_skip ( pb , 4 ) ; version = avio_rb16 ( pb ) ; if ( version == 2 ) { uint64_t timestamp ; int v ; avio_skip ( pb , 22 ) ; ast = avformat_new_stream ( avctx , NULL ) ; if ( ! ast ) return AVERROR ( ENOMEM ) ; vst = avformat_new_stream ( avctx , NULL ) ; if ( ! vst ) return AVERROR ( ENOMEM ) ; avpriv_set_pts_info ( vst , 64 , 1 , 15 ) ; vst -> codecpar -> codec_type = AVMEDIA_TYPE_VIDEO ; vst -> avg_frame_rate = av_inv_q ( vst -> time_base ) ; vst -> nb_frames = avio_rb32 ( pb ) ; v = avio_rb32 ( pb ) ; switch ( v ) { case 1 : vst -> codecpar -> codec_id = AV_CODEC_ID_MVC1 ; break ; case 2 : vst -> codecpar -> format = AV_PIX_FMT_ARGB ; vst -> codecpar -> codec_id = AV_CODEC_ID_RAWVIDEO ; break ; default : avpriv_request_sample ( avctx , ""Video<S2SV_blank>compression<S2SV_blank>%i"" , v ) ; break ; } vst -> codecpar -> codec_tag = 0 ; vst -> codecpar -> width = avio_rb32 ( pb ) ; vst -> codecpar -> height = avio_rb32 ( pb ) ; avio_skip ( pb , 12 ) ; ast -> codecpar -> codec_type = AVMEDIA_TYPE_AUDIO ; ast -> nb_frames = vst -> nb_frames ; ast -> codecpar -> sample_rate = avio_rb32 ( pb ) ; if ( ast -> codecpar -> sample_rate <= 0 ) { av_log ( avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>sample<S2SV_blank>rate<S2SV_blank>%d\\n"" , ast -> codecpar -> sample_rate ) ; return AVERROR_INVALIDDATA ; } avpriv_set_pts_info ( ast , 33 , 1 , ast -> codecpar -> sample_rate ) ; if ( set_channels ( avctx , ast , avio_rb32 ( pb ) ) < 0 ) return AVERROR_INVALIDDATA ; v = avio_rb32 ( pb ) ; if ( v == AUDIO_FORMAT_SIGNED ) { ast -> codecpar -> codec_id = AV_CODEC_ID_PCM_S16BE ; } else { avpriv_request_sample ( avctx , ""Audio<S2SV_blank>compression<S2SV_blank>(format<S2SV_blank>%i)"" , v ) ; } avio_skip ( pb , 12 ) ; var_read_metadata ( avctx , ""title"" , 0x80 ) ; var_read_metadata ( avctx , ""comment"" , 0x100 ) ; avio_skip ( pb , 0x80 ) ; timestamp = 0 ; for ( i = 0 ; i < vst -> nb_frames ; i ++ ) { uint32_t pos = avio_rb32 ( pb ) ; uint32_t asize = avio_rb32 ( pb ) ;  uint32_t vsize = avio_rb32 ( pb ) ;  avio_skip ( pb , 8 ) ; av_add_index_entry ( ast , pos , timestamp , asize , 0 , AVINDEX_KEYFRAME ) ; av_add_index_entry ( vst , pos + asize , i , vsize , 0 , AVINDEX_KEYFRAME ) ; timestamp += asize / ( ast -> codecpar -> channels * 2 ) ; } } else if ( ! version && avio_rb16 ( pb ) == 3 ) { avio_skip ( pb , 4 ) ; if ( ( ret = read_table ( avctx , NULL , parse_global_var ) ) < 0 ) return ret ; if ( mv -> nb_audio_tracks > 1 ) { avpriv_request_sample ( avctx , ""Multiple<S2SV_blank>audio<S2SV_blank>streams<S2SV_blank>support"" ) ; return AVERROR_PATCHWELCOME ; } else if ( mv -> nb_audio_tracks ) { ast = avformat_new_stream ( avctx , NULL ) ; if ( ! ast ) return AVERROR ( ENOMEM ) ; ast -> codecpar -> codec_type = AVMEDIA_TYPE_AUDIO ; if ( ( read_table ( avctx , ast , parse_audio_var ) ) < 0 ) return ret ; if ( mv -> acompression == 100 && mv -> aformat == AUDIO_FORMAT_SIGNED && ast -> codecpar -> bits_per_coded_sample == 16 ) { ast -> codecpar -> codec_id = AV_CODEC_ID_PCM_S16BE ; } else { avpriv_request_sample ( avctx , ""Audio<S2SV_blank>compression<S2SV_blank>%i<S2SV_blank>(format<S2SV_blank>%i,<S2SV_blank>sr<S2SV_blank>%i)"" , mv -> acompression , mv -> aformat , ast -> codecpar -> bits_per_coded_sample ) ; ast -> codecpar -> codec_id = AV_CODEC_ID_NONE ; } if ( ast -> codecpar -> channels <= 0 ) { av_log ( avctx , AV_LOG_ERROR , ""No<S2SV_blank>valid<S2SV_blank>channel<S2SV_blank>count<S2SV_blank>found.\\n"" ) ; return AVERROR_INVALIDDATA ; } } if ( mv -> nb_video_tracks > 1 ) { avpriv_request_sample ( avctx , ""Multiple<S2SV_blank>video<S2SV_blank>streams<S2SV_blank>support"" ) ; return AVERROR_PATCHWELCOME ; } else if ( mv -> nb_video_tracks ) { vst = avformat_new_stream ( avctx , NULL ) ; if ( ! vst ) return AVERROR ( ENOMEM ) ; vst -> codecpar -> codec_type = AVMEDIA_TYPE_VIDEO ; if ( ( ret = read_table ( avctx , vst , parse_video_var ) ) < 0 ) return ret ; } if ( mv -> nb_audio_tracks ) read_index ( pb , ast ) ; if ( mv -> nb_video_tracks ) read_index ( pb , vst ) ; } else { avpriv_request_sample ( avctx , ""Version<S2SV_blank>%i"" , version ) ; return AVERROR_PATCHWELCOME ; } return 0 ; }","uint32_t vsize = avio_rb32 ( pb ) ;avio_skip ( pb , 8 ) ;",189
279,"buggy line: if ( q > e ) {DPRINTF ( ( ""Ran<S2SV_blank>of<S2SV_blank>the<S2SV_blank>end<S2SV_blank>%p<S2SV_blank>><S2SV_blank>%p\\\cwe id:CWE-189context: int cdf_read_property_info ( const cdf_stream_t * sst , const cdf_header_t * h , uint32_t offs , cdf_property_info_t * * info , size_t * count , size_t * maxcount ) { const cdf_section_header_t * shp ; cdf_section_header_t sh ; const uint8_t * p , * q , * e ; int16_t s16 ; int32_t s32 ; uint32_t u32 ; int64_t s64 ; uint64_t u64 ; cdf_timestamp_t tp ; size_t i , o , o4 , nelements , j ; cdf_property_info_t * inp ; if ( offs > UINT32_MAX / 4 ) { errno = EFTYPE ; goto out ; } shp = CAST ( const cdf_section_header_t * , ( const void * ) ( ( const char * ) sst -> sst_tab + offs ) ) ; if ( cdf_check_stream_offset ( sst , h , shp , sizeof ( * shp ) , __LINE__ ) == - 1 ) goto out ; sh . sh_len = CDF_TOLE4 ( shp -> sh_len ) ; # define CDF_SHLEN_LIMIT ( UINT32_MAX / 8 ) if ( sh . sh_len > CDF_SHLEN_LIMIT ) { errno = EFTYPE ; goto out ; } sh . sh_properties = CDF_TOLE4 ( shp -> sh_properties ) ; # define CDF_PROP_LIMIT ( UINT32_MAX / ( 4 * sizeof ( * inp ) ) ) if ( sh . sh_properties > CDF_PROP_LIMIT ) goto out ; DPRINTF ( ( ""section<S2SV_blank>len:<S2SV_blank>%u<S2SV_blank>properties<S2SV_blank>%u\\n"" , sh . sh_len , sh . sh_properties ) ) ; if ( * maxcount ) { if ( * maxcount > CDF_PROP_LIMIT ) goto out ; * maxcount += sh . sh_properties ; inp = CAST ( cdf_property_info_t * , realloc ( * info , * maxcount * sizeof ( * inp ) ) ) ; } else { * maxcount = sh . sh_properties ; inp = CAST ( cdf_property_info_t * , malloc ( * maxcount * sizeof ( * inp ) ) ) ; } if ( inp == NULL ) goto out ; * info = inp ; inp += * count ; * count += sh . sh_properties ; p = CAST ( const uint8_t * , ( const void * ) ( ( const char * ) ( const void * ) sst -> sst_tab + offs + sizeof ( sh ) ) ) ; e = CAST ( const uint8_t * , ( const void * ) ( ( ( const char * ) ( const void * ) shp ) + sh . sh_len ) ) ; if ( cdf_check_stream_offset ( sst , h , e , 0 , __LINE__ ) == - 1 ) goto out ; for ( i = 0 ; i < sh . sh_properties ; i ++ ) { size_t ofs , tail = ( i << 1 ) + 1 ; if ( cdf_check_stream_offset ( sst , h , p , tail * sizeof ( uint32_t ) , __LINE__ ) == - 1 ) goto out ; ofs = CDF_GETUINT32 ( p , tail ) ; q = ( const uint8_t * ) ( const void * ) ( ( const char * ) ( const void * ) p + ofs - 2 * sizeof ( uint32_t ) ) ;  if ( q > e ) {  DPRINTF ( ( ""Ran<S2SV_blank>of<S2SV_blank>the<S2SV_blank>end<S2SV_blank>%p<S2SV_blank>><S2SV_blank>%p\\n"" , q , e ) ) ; goto out ; } inp [ i ] . pi_id = CDF_GETUINT32 ( p , i << 1 ) ; inp [ i ] . pi_type = CDF_GETUINT32 ( q , 0 ) ; DPRINTF ( ( ""%"" SIZE_T_FORMAT ""u)<S2SV_blank>id=%x<S2SV_blank>type=%x<S2SV_blank>offs=0x%tx,0x%x\\n"" , i , inp [ i ] . pi_id , inp [ i ] . pi_type , q - p , offs ) ) ; if ( inp [ i ] . pi_type & CDF_VECTOR ) { nelements = CDF_GETUINT32 ( q , 1 ) ; if ( nelements == 0 ) { DPRINTF ( ( ""CDF_VECTOR<S2SV_blank>with<S2SV_blank>nelements<S2SV_blank>==<S2SV_blank>0\\n"" ) ) ; goto out ; } o = 2 ; } else { nelements = 1 ; o = 1 ; } o4 = o * sizeof ( uint32_t ) ; if ( inp [ i ] . pi_type & ( CDF_ARRAY | CDF_BYREF | CDF_RESERVED ) ) goto unknown ; switch ( inp [ i ] . pi_type & CDF_TYPEMASK ) { case CDF_NULL : case CDF_EMPTY : break ; case CDF_SIGNED16 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s16 , & q [ o4 ] , sizeof ( s16 ) ) ; inp [ i ] . pi_s16 = CDF_TOLE2 ( s16 ) ; break ; case CDF_SIGNED32 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s32 , & q [ o4 ] , sizeof ( s32 ) ) ; inp [ i ] . pi_s32 = CDF_TOLE4 ( ( uint32_t ) s32 ) ; break ; case CDF_BOOL : case CDF_UNSIGNED32 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u32 , & q [ o4 ] , sizeof ( u32 ) ) ; inp [ i ] . pi_u32 = CDF_TOLE4 ( u32 ) ; break ; case CDF_SIGNED64 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s64 , & q [ o4 ] , sizeof ( s64 ) ) ; inp [ i ] . pi_s64 = CDF_TOLE8 ( ( uint64_t ) s64 ) ; break ; case CDF_UNSIGNED64 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u64 , & q [ o4 ] , sizeof ( u64 ) ) ; inp [ i ] . pi_u64 = CDF_TOLE8 ( ( uint64_t ) u64 ) ; break ; case CDF_FLOAT : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u32 , & q [ o4 ] , sizeof ( u32 ) ) ; u32 = CDF_TOLE4 ( u32 ) ; memcpy ( & inp [ i ] . pi_f , & u32 , sizeof ( inp [ i ] . pi_f ) ) ; break ; case CDF_DOUBLE : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u64 , & q [ o4 ] , sizeof ( u64 ) ) ; u64 = CDF_TOLE8 ( ( uint64_t ) u64 ) ; memcpy ( & inp [ i ] . pi_d , & u64 , sizeof ( inp [ i ] . pi_d ) ) ; break ; case CDF_LENGTH32_STRING : case CDF_LENGTH32_WSTRING : if ( nelements > 1 ) { size_t nelem = inp - * info ; if ( * maxcount > CDF_PROP_LIMIT || nelements > CDF_PROP_LIMIT ) goto out ; * maxcount += nelements ; inp = CAST ( cdf_property_info_t * , realloc ( * info , * maxcount * sizeof ( * inp ) ) ) ; if ( inp == NULL ) goto out ; * info = inp ; inp = * info + nelem ; } DPRINTF ( ( ""nelements<S2SV_blank>=<S2SV_blank>%"" SIZE_T_FORMAT ""u\\n"" , nelements ) ) ; for ( j = 0 ; j < nelements && i < sh . sh_properties ; j ++ , i ++ ) { uint32_t l = CDF_GETUINT32 ( q , o ) ; inp [ i ] . pi_str . s_len = l ; inp [ i ] . pi_str . s_buf = ( const char * ) ( const void * ) ( & q [ o4 + sizeof ( l ) ] ) ; DPRINTF ( ( ""l<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>r<S2SV_blank>=<S2SV_blank>%"" SIZE_T_FORMAT ""u,<S2SV_blank>s<S2SV_blank>=<S2SV_blank>%s\\n"" , l , CDF_ROUND ( l , sizeof ( l ) ) , inp [ i ] . pi_str . s_buf ) ) ; if ( l & 1 ) l ++ ; o += l >> 1 ; if ( q + o >= e ) goto out ; o4 = o * sizeof ( uint32_t ) ; } i -- ; break ; case CDF_FILETIME : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & tp , & q [ o4 ] , sizeof ( tp ) ) ; inp [ i ] . pi_tp = CDF_TOLE8 ( ( uint64_t ) tp ) ; break ; case CDF_CLIPBOARD : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; break ; default : unknown : DPRINTF ( ( ""Don\'t<S2SV_blank>know<S2SV_blank>how<S2SV_blank>to<S2SV_blank>deal<S2SV_blank>with<S2SV_blank>%x\\n"" , inp [ i ] . pi_type ) ) ; break ; } } return 0 ; out : free ( * info ) ; return - 1 ; }","if ( q < p || q > e ) {DPRINTF ( ( ""Ran<S2SV_blank>of<S2SV_blank>the<S2SV_blank>end<S2SV_blank>%p<S2SV_blank>><S2SV_blank>%p\\\",190
280,"buggy line: # ifdef AUTOKEY  filegen_register ( statsdir , ""cryptostats"" , & cryptostats ) ;# endif  # ifdef DEBUG_TIMING filegen_register ( statsdir , ""timingstats"" , & timingstats ) ;# endif  step_callback = & ntpd_time_stepped ;cwe id:CWE-20context: void init_util ( void ) { filegen_register ( statsdir , ""peerstats"" , & peerstats ) ; filegen_register ( statsdir , ""loopstats"" , & loopstats ) ; filegen_register ( statsdir , ""clockstats"" , & clockstats ) ; filegen_register ( statsdir , ""rawstats"" , & rawstats ) ; filegen_register ( statsdir , ""sysstats"" , & sysstats ) ; filegen_register ( statsdir , ""protostats"" , & protostats ) ;  # ifdef AUTOKEY  filegen_register ( statsdir , ""cryptostats"" , & cryptostats ) ;  # endif  # ifdef DEBUG_TIMING filegen_register ( statsdir , ""timingstats"" , & timingstats ) ;  # endif  step_callback = & ntpd_time_stepped ; # ifdef DEBUG atexit ( & uninit_util ) ; # endif }","filegen_register ( statsdir , ""cryptostats"" , & cryptostats ) ;filegen_register ( statsdir , ""timingstats"" , & timingstats ) ;# endif step_callback = & ntpd_time_stepped ;",191
281,"buggy line: char * dir = ""/etc"" ;if ( ( fd = xfmkstemp ( & tmpname , dir ) ) == NULL ) {ulckpwdf ( ) ;cwe id:CWE-264context: static FILE * pw_tmpfile ( int lockfd ) { FILE * fd ; char * tmpname = NULL ;  char * dir = ""/etc"" ;   if ( ( fd = xfmkstemp ( & tmpname , dir ) ) == NULL ) {  ulckpwdf ( ) ; err ( EXIT_FAILURE , _ ( ""can\'t<S2SV_blank>open<S2SV_blank>temporary<S2SV_blank>file"" ) ) ; } copyfile ( lockfd , fileno ( fd ) ) ; tmp_file = tmpname ; return fd ; }","if ( ( fd = xfmkstemp ( & tmpname , dir ) ) == NULL ) {ulckpwdf ( ) ;",192
282,"buggy line: attach_shadowed ( mnt , parent , shadows ) ;touch_mnt_namespace ( n ) ;cwe id:CWE-400context: static void commit_tree ( struct mount * mnt , struct mount * shadows ) { struct mount * parent = mnt -> mnt_parent ; struct mount * m ; LIST_HEAD ( head ) ; struct mnt_namespace * n = parent -> mnt_ns ; BUG_ON ( parent == mnt ) ; list_add_tail ( & head , & mnt -> mnt_list ) ; list_for_each_entry ( m , & head , mnt_list ) m -> mnt_ns = n ; list_splice ( & head , n -> list . prev ) ;  attach_shadowed ( mnt , parent , shadows ) ;  touch_mnt_namespace ( n ) ; }","n -> mounts += n -> pending_mounts ;n -> pending_mounts = 0 ;attach_shadowed ( mnt , parent , shadows ) ;touch_mnt_namespace ( n ) ;",193
283,"buggy line: savesegment ( es , prev -> es ) ;if ( unlikely ( next -> es | prev -> es ) ) loadsegment ( es , next -> es ) ;savesegment ( ds , prev -> ds ) ;if ( unlikely ( next -> ds | prev -> ds ) )  loadsegment ( ds , next -> ds ) ;savesegment ( fs , fsindex ) ;cwe id:CWE-200context: __visible __notrace_funcgraph struct task_struct * __switch_to ( struct task_struct * prev_p , struct task_struct * next_p ) { struct thread_struct * prev = & prev_p -> thread ; struct thread_struct * next = & next_p -> thread ; int cpu = smp_processor_id ( ) ; struct tss_struct * tss = & per_cpu ( init_tss , cpu ) ; unsigned fsindex , gsindex ; fpu_switch_t fpu ; fpu = switch_fpu_prepare ( prev_p , next_p , cpu ) ; load_sp0 ( tss , next ) ;  savesegment ( es , prev -> es ) ;  if ( unlikely ( next -> es | prev -> es ) ) loadsegment ( es , next -> es ) ; savesegment ( ds , prev -> ds ) ; if ( unlikely ( next -> ds | prev -> ds ) )  loadsegment ( ds , next -> ds ) ;  savesegment ( fs , fsindex ) ; savesegment ( gs , gsindex ) ; load_TLS ( next , cpu ) ; arch_end_context_switch ( next_p ) ; if ( unlikely ( fsindex | next -> fsindex | prev -> fs ) ) { loadsegment ( fs , next -> fsindex ) ; if ( fsindex ) prev -> fs = 0 ; } if ( next -> fs ) wrmsrl ( MSR_FS_BASE , next -> fs ) ; prev -> fsindex = fsindex ; if ( unlikely ( gsindex | next -> gsindex | prev -> gs ) ) { load_gs_index ( next -> gsindex ) ; if ( gsindex ) prev -> gs = 0 ; } if ( next -> gs ) wrmsrl ( MSR_KERNEL_GS_BASE , next -> gs ) ; prev -> gsindex = gsindex ; switch_fpu_finish ( next_p , fpu ) ; prev -> usersp = this_cpu_read ( old_rsp ) ; this_cpu_write ( old_rsp , next -> usersp ) ; this_cpu_write ( current_task , next_p ) ; task_thread_info ( prev_p ) -> saved_preempt_count = this_cpu_read ( __preempt_count ) ; this_cpu_write ( __preempt_count , task_thread_info ( next_p ) -> saved_preempt_count ) ; this_cpu_write ( kernel_stack , ( unsigned long ) task_stack_page ( next_p ) + THREAD_SIZE - KERNEL_STACK_OFFSET ) ; if ( unlikely ( task_thread_info ( next_p ) -> flags & _TIF_WORK_CTXSW_NEXT || task_thread_info ( prev_p ) -> flags & _TIF_WORK_CTXSW_PREV ) ) __switch_to_xtra ( prev_p , next_p , tss ) ; return prev_p ; }","savesegment ( fs , fsindex ) ;savesegment ( es , prev -> es ) ;if ( unlikely ( next -> es | prev -> es ) ) loadsegment ( es , next -> es ) ;savesegment ( ds , prev -> ds ) ;if ( unlikely ( next -> ds ) ;",194
284,"buggy line: problem_data_reload_from_dump_dir ( ) ;update_gui_state_from_problem_data ( 0 ) ;cwe id:CWE-200context: static void save_text_if_changed ( const char * name , const char * new_value ) { if ( ! g_hash_table_lookup ( g_loaded_texts , name ) ) return ; const char * old_value = g_cd ? problem_data_get_content_or_NULL ( g_cd , name ) : """" ; if ( ! old_value ) old_value = """" ; if ( strcmp ( new_value , old_value ) != 0 ) { struct dump_dir * dd = wizard_open_directory_for_writing ( g_dump_dir_name ) ; if ( dd ) dd_save_text ( dd , name , new_value ) ; dd_close ( dd ) ;  problem_data_reload_from_dump_dir ( ) ;  update_gui_state_from_problem_data ( 0 ) ; } }","
",195
285,"buggy line: cwe id:CWE-000context: IHEVCD_ERROR_T ihevcd_parse_pps ( codec_t * ps_codec ) { IHEVCD_ERROR_T ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; WORD32 value ; WORD32 pps_id ; pps_t * ps_pps ; sps_t * ps_sps ; bitstrm_t * ps_bitstrm = & ps_codec -> s_parse . s_bitstrm ; if ( 0 == ps_codec -> i4_sps_done ) return IHEVCD_INVALID_HEADER ; UEV_PARSE ( ""pic_parameter_set_id"" , value , ps_bitstrm ) ; pps_id = value ; if ( ( pps_id >= MAX_PPS_CNT ) || ( pps_id < 0 ) ) { if ( ps_codec -> i4_pps_done ) return IHEVCD_UNSUPPORTED_PPS_ID ; else pps_id = 0 ; } ps_pps = ( ps_codec -> s_parse . ps_pps_base + MAX_PPS_CNT - 1 ) ; ps_pps -> i1_pps_id = pps_id ; UEV_PARSE ( ""seq_parameter_set_id"" , value , ps_bitstrm ) ; ps_pps -> i1_sps_id = value ; ps_pps -> i1_sps_id = CLIP3 ( ps_pps -> i1_sps_id , 0 , MAX_SPS_CNT - 2 ) ; ps_sps = ( ps_codec -> s_parse . ps_sps_base + ps_pps -> i1_sps_id ) ; if ( 0 == ps_sps -> i1_sps_valid ) { return IHEVCD_INVALID_HEADER ; } BITS_PARSE ( ""dependent_slices_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_dependent_slice_enabled_flag = value ; BITS_PARSE ( ""output_flag_present_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_output_flag_present_flag = value ; BITS_PARSE ( ""num_extra_slice_header_bits"" , value , ps_bitstrm , 3 ) ; ps_pps -> i1_num_extra_slice_header_bits = value ; BITS_PARSE ( ""sign_data_hiding_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_sign_data_hiding_flag = value ; BITS_PARSE ( ""cabac_init_present_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_cabac_init_present_flag = value ; UEV_PARSE ( ""num_ref_idx_l0_default_active_minus1"" , value , ps_bitstrm ) ; ps_pps -> i1_num_ref_idx_l0_default_active = value + 1 ; UEV_PARSE ( ""num_ref_idx_l1_default_active_minus1"" , value , ps_bitstrm ) ; ps_pps -> i1_num_ref_idx_l1_default_active = value + 1 ; SEV_PARSE ( ""pic_init_qp_minus26"" , value , ps_bitstrm ) ; ps_pps -> i1_pic_init_qp = value + 26 ; BITS_PARSE ( ""constrained_intra_pred_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_constrained_intra_pred_flag = value ; BITS_PARSE ( ""transform_skip_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_transform_skip_enabled_flag = value ; BITS_PARSE ( ""cu_qp_delta_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_cu_qp_delta_enabled_flag = value ; if ( ps_pps -> i1_cu_qp_delta_enabled_flag ) { UEV_PARSE ( ""diff_cu_qp_delta_depth"" , value , ps_bitstrm ) ; ps_pps -> i1_diff_cu_qp_delta_depth = value ; } else { ps_pps -> i1_diff_cu_qp_delta_depth = 0 ; } ps_pps -> i1_log2_min_cu_qp_delta_size = ps_sps -> i1_log2_ctb_size - ps_pps -> i1_diff_cu_qp_delta_depth ; SEV_PARSE ( ""cb_qp_offset"" , value , ps_bitstrm ) ; ps_pps -> i1_pic_cb_qp_offset = value ; SEV_PARSE ( ""cr_qp_offset"" , value , ps_bitstrm ) ; ps_pps -> i1_pic_cr_qp_offset = value ; BITS_PARSE ( ""slicelevel_chroma_qp_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_pic_slice_level_chroma_qp_offsets_present_flag = value ; BITS_PARSE ( ""weighted_pred_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_weighted_pred_flag = value ; BITS_PARSE ( ""weighted_bipred_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_weighted_bipred_flag = value ; BITS_PARSE ( ""transquant_bypass_enable_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_transquant_bypass_enable_flag = value ; BITS_PARSE ( ""tiles_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_tiles_enabled_flag = value ;  BITS_PARSE ( ""entropy_coding_sync_enabled_flag"" , value , ps_bitstrm , 1 ) ;  ps_pps -> i1_entropy_coding_sync_enabled_flag = value ; ps_pps -> i1_loop_filter_across_tiles_enabled_flag = 0 ; if ( ps_pps -> i1_tiles_enabled_flag ) { WORD32 wd = ALIGN64 ( ps_codec -> i4_wd ) ; WORD32 ht = ALIGN64 ( ps_codec -> i4_ht ) ; WORD32 max_tile_cols = ( wd + MIN_TILE_WD - 1 ) / MIN_TILE_WD ; WORD32 max_tile_rows = ( ht + MIN_TILE_HT - 1 ) / MIN_TILE_HT ; UEV_PARSE ( ""num_tile_columns_minus1"" , value , ps_bitstrm ) ; ps_pps -> i1_num_tile_columns = value + 1 ; UEV_PARSE ( ""num_tile_rows_minus1"" , value , ps_bitstrm ) ; ps_pps -> i1_num_tile_rows = value + 1 ; if ( ( ps_pps -> i1_num_tile_columns < 1 ) || ( ps_pps -> i1_num_tile_columns > max_tile_cols ) || ( ps_pps -> i1_num_tile_rows < 1 ) || ( ps_pps -> i1_num_tile_rows > max_tile_rows ) ) return IHEVCD_INVALID_HEADER ; BITS_PARSE ( ""uniform_spacing_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_uniform_spacing_flag = value ; { WORD32 start ; WORD32 i , j ; start = 0 ; for ( i = 0 ; i < ps_pps -> i1_num_tile_columns ; i ++ ) { tile_t * ps_tile ; if ( ! ps_pps -> i1_uniform_spacing_flag ) { if ( i < ( ps_pps -> i1_num_tile_columns - 1 ) ) { UEV_PARSE ( ""column_width_minus1[<S2SV_blank>i<S2SV_blank>]"" , value , ps_bitstrm ) ; value += 1 ; } else { value = ps_sps -> i2_pic_wd_in_ctb - start ; } } else { value = ( ( i + 1 ) * ps_sps -> i2_pic_wd_in_ctb ) / ps_pps -> i1_num_tile_columns - ( i * ps_sps -> i2_pic_wd_in_ctb ) / ps_pps -> i1_num_tile_columns ; } for ( j = 0 ; j < ps_pps -> i1_num_tile_rows ; j ++ ) { ps_tile = ps_pps -> ps_tile + j * ps_pps -> i1_num_tile_columns + i ; ps_tile -> u1_pos_x = start ; ps_tile -> u2_wd = value ; } start += value ; if ( ( start > ps_sps -> i2_pic_wd_in_ctb ) || ( value <= 0 ) ) return IHEVCD_INVALID_HEADER ; } start = 0 ; for ( i = 0 ; i < ( ps_pps -> i1_num_tile_rows ) ; i ++ ) { tile_t * ps_tile ; if ( ! ps_pps -> i1_uniform_spacing_flag ) { if ( i < ( ps_pps -> i1_num_tile_rows - 1 ) ) { UEV_PARSE ( ""row_height_minus1[<S2SV_blank>i<S2SV_blank>]"" , value , ps_bitstrm ) ; value += 1 ; } else { value = ps_sps -> i2_pic_ht_in_ctb - start ; } } else { value = ( ( i + 1 ) * ps_sps -> i2_pic_ht_in_ctb ) / ps_pps -> i1_num_tile_rows - ( i * ps_sps -> i2_pic_ht_in_ctb ) / ps_pps -> i1_num_tile_rows ; } for ( j = 0 ; j < ps_pps -> i1_num_tile_columns ; j ++ ) { ps_tile = ps_pps -> ps_tile + i * ps_pps -> i1_num_tile_columns + j ; ps_tile -> u1_pos_y = start ; ps_tile -> u2_ht = value ; } start += value ; if ( ( start > ps_sps -> i2_pic_ht_in_ctb ) || ( value <= 0 ) ) return IHEVCD_INVALID_HEADER ; } } BITS_PARSE ( ""loop_filter_across_tiles_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_loop_filter_across_tiles_enabled_flag = value ; } else { ps_pps -> i1_num_tile_columns = 1 ; ps_pps -> i1_num_tile_rows = 1 ; ps_pps -> i1_uniform_spacing_flag = 1 ; ps_pps -> ps_tile -> u1_pos_x = 0 ; ps_pps -> ps_tile -> u1_pos_y = 0 ; ps_pps -> ps_tile -> u2_wd = ps_sps -> i2_pic_wd_in_ctb ; ps_pps -> ps_tile -> u2_ht = ps_sps -> i2_pic_ht_in_ctb ; } BITS_PARSE ( ""loop_filter_across_slices_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_loop_filter_across_slices_enabled_flag = value ; BITS_PARSE ( ""deblocking_filter_control_present_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_deblocking_filter_control_present_flag = value ; ps_pps -> i1_pic_disable_deblocking_filter_flag = 0 ; ps_pps -> i1_deblocking_filter_override_enabled_flag = 0 ; ps_pps -> i1_beta_offset_div2 = 0 ; ps_pps -> i1_tc_offset_div2 = 0 ; if ( ps_pps -> i1_deblocking_filter_control_present_flag ) { BITS_PARSE ( ""deblocking_filter_override_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_deblocking_filter_override_enabled_flag = value ; BITS_PARSE ( ""pic_disable_deblocking_filter_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_pic_disable_deblocking_filter_flag = value ; if ( ! ps_pps -> i1_pic_disable_deblocking_filter_flag ) { SEV_PARSE ( ""pps_beta_offset_div2"" , value , ps_bitstrm ) ; ps_pps -> i1_beta_offset_div2 = value ; SEV_PARSE ( ""pps_tc_offset_div2"" , value , ps_bitstrm ) ; ps_pps -> i1_tc_offset_div2 = value ; } } BITS_PARSE ( ""pps_scaling_list_data_present_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_pps_scaling_list_data_present_flag = value ; if ( ps_pps -> i1_pps_scaling_list_data_present_flag ) { COPY_DEFAULT_SCALING_LIST ( ps_pps -> pi2_scaling_mat ) ; ihevcd_scaling_list_data ( ps_codec , ps_pps -> pi2_scaling_mat ) ; } BITS_PARSE ( ""lists_modification_present_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_lists_modification_present_flag = value ; UEV_PARSE ( ""log2_parallel_merge_level_minus2"" , value , ps_bitstrm ) ; ps_pps -> i1_log2_parallel_merge_level = value + 2 ; BITS_PARSE ( ""slice_header_extension_present_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_slice_header_extension_present_flag = value ; BITS_PARSE ( ""pps_extension_flag"" , value , ps_bitstrm , 1 ) ; if ( ( UWORD8 * ) ps_bitstrm -> pu4_buf > ps_bitstrm -> pu1_buf_max ) return IHEVCD_INVALID_PARAMETER ; ps_codec -> i4_pps_done = 1 ; return ret ; }",if ( ( ps_pps -> i1_tiles_enabled_flag ) && ( ps_sps -> i1_log2_ctb_size == 4 ) && ( ( ps_sps -> i2_pic_width_in_luma_samples >= 4096 ) || ( ps_sps -> i2_pic_height_in_luma_samples >= 4096 ) ) ) {return IHEVCD_INVALID_HEADER ;},196
286,"buggy line: BITS_PARSE ( ""entropy_coding_sync_enabled_flag"" , value , ps_bitstrm , 1 ) ;ps_pps -> i1_entropy_coding_sync_enabled_flag = value ;cwe id:CWE-000context: IHEVCD_ERROR_T ihevcd_parse_pps ( codec_t * ps_codec ) { IHEVCD_ERROR_T ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; WORD32 value ; WORD32 pps_id ; pps_t * ps_pps ; sps_t * ps_sps ; bitstrm_t * ps_bitstrm = & ps_codec -> s_parse . s_bitstrm ; if ( 0 == ps_codec -> i4_sps_done ) return IHEVCD_INVALID_HEADER ; UEV_PARSE ( ""pic_parameter_set_id"" , value , ps_bitstrm ) ; pps_id = value ; if ( ( pps_id >= MAX_PPS_CNT ) || ( pps_id < 0 ) ) { if ( ps_codec -> i4_pps_done ) return IHEVCD_UNSUPPORTED_PPS_ID ; else pps_id = 0 ; } ps_pps = ( ps_codec -> s_parse . ps_pps_base + MAX_PPS_CNT - 1 ) ; ps_pps -> i1_pps_id = pps_id ; UEV_PARSE ( ""seq_parameter_set_id"" , value , ps_bitstrm ) ; ps_pps -> i1_sps_id = value ; ps_pps -> i1_sps_id = CLIP3 ( ps_pps -> i1_sps_id , 0 , MAX_SPS_CNT - 2 ) ; ps_sps = ( ps_codec -> s_parse . ps_sps_base + ps_pps -> i1_sps_id ) ; if ( 0 == ps_sps -> i1_sps_valid ) { return IHEVCD_INVALID_HEADER ; } BITS_PARSE ( ""dependent_slices_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_dependent_slice_enabled_flag = value ; BITS_PARSE ( ""output_flag_present_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_output_flag_present_flag = value ; BITS_PARSE ( ""num_extra_slice_header_bits"" , value , ps_bitstrm , 3 ) ; ps_pps -> i1_num_extra_slice_header_bits = value ; BITS_PARSE ( ""sign_data_hiding_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_sign_data_hiding_flag = value ; BITS_PARSE ( ""cabac_init_present_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_cabac_init_present_flag = value ; UEV_PARSE ( ""num_ref_idx_l0_default_active_minus1"" , value , ps_bitstrm ) ; ps_pps -> i1_num_ref_idx_l0_default_active = value + 1 ; UEV_PARSE ( ""num_ref_idx_l1_default_active_minus1"" , value , ps_bitstrm ) ; ps_pps -> i1_num_ref_idx_l1_default_active = value + 1 ; SEV_PARSE ( ""pic_init_qp_minus26"" , value , ps_bitstrm ) ; ps_pps -> i1_pic_init_qp = value + 26 ; BITS_PARSE ( ""constrained_intra_pred_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_constrained_intra_pred_flag = value ; BITS_PARSE ( ""transform_skip_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_transform_skip_enabled_flag = value ; BITS_PARSE ( ""cu_qp_delta_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_cu_qp_delta_enabled_flag = value ; if ( ps_pps -> i1_cu_qp_delta_enabled_flag ) { UEV_PARSE ( ""diff_cu_qp_delta_depth"" , value , ps_bitstrm ) ; ps_pps -> i1_diff_cu_qp_delta_depth = value ; } else { ps_pps -> i1_diff_cu_qp_delta_depth = 0 ; } ps_pps -> i1_log2_min_cu_qp_delta_size = ps_sps -> i1_log2_ctb_size - ps_pps -> i1_diff_cu_qp_delta_depth ; SEV_PARSE ( ""cb_qp_offset"" , value , ps_bitstrm ) ; ps_pps -> i1_pic_cb_qp_offset = value ; SEV_PARSE ( ""cr_qp_offset"" , value , ps_bitstrm ) ; ps_pps -> i1_pic_cr_qp_offset = value ; BITS_PARSE ( ""slicelevel_chroma_qp_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_pic_slice_level_chroma_qp_offsets_present_flag = value ; BITS_PARSE ( ""weighted_pred_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_weighted_pred_flag = value ; BITS_PARSE ( ""weighted_bipred_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_weighted_bipred_flag = value ; BITS_PARSE ( ""transquant_bypass_enable_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_transquant_bypass_enable_flag = value ; BITS_PARSE ( ""tiles_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_tiles_enabled_flag = value ;  BITS_PARSE ( ""entropy_coding_sync_enabled_flag"" , value , ps_bitstrm , 1 ) ;  ps_pps -> i1_entropy_coding_sync_enabled_flag = value ; ps_pps -> i1_loop_filter_across_tiles_enabled_flag = 0 ; if ( ps_pps -> i1_tiles_enabled_flag ) { WORD32 wd = ALIGN64 ( ps_codec -> i4_wd ) ; WORD32 ht = ALIGN64 ( ps_codec -> i4_ht ) ; WORD32 max_tile_cols = ( wd + MIN_TILE_WD - 1 ) / MIN_TILE_WD ; WORD32 max_tile_rows = ( ht + MIN_TILE_HT - 1 ) / MIN_TILE_HT ; UEV_PARSE ( ""num_tile_columns_minus1"" , value , ps_bitstrm ) ; ps_pps -> i1_num_tile_columns = value + 1 ; UEV_PARSE ( ""num_tile_rows_minus1"" , value , ps_bitstrm ) ; ps_pps -> i1_num_tile_rows = value + 1 ; if ( ( ps_pps -> i1_num_tile_columns < 1 ) || ( ps_pps -> i1_num_tile_columns > max_tile_cols ) || ( ps_pps -> i1_num_tile_rows < 1 ) || ( ps_pps -> i1_num_tile_rows > max_tile_rows ) ) return IHEVCD_INVALID_HEADER ; BITS_PARSE ( ""uniform_spacing_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_uniform_spacing_flag = value ; { WORD32 start ; WORD32 i , j ; start = 0 ; for ( i = 0 ; i < ps_pps -> i1_num_tile_columns ; i ++ ) { tile_t * ps_tile ; if ( ! ps_pps -> i1_uniform_spacing_flag ) { if ( i < ( ps_pps -> i1_num_tile_columns - 1 ) ) { UEV_PARSE ( ""column_width_minus1[<S2SV_blank>i<S2SV_blank>]"" , value , ps_bitstrm ) ; value += 1 ; } else { value = ps_sps -> i2_pic_wd_in_ctb - start ; } } else { value = ( ( i + 1 ) * ps_sps -> i2_pic_wd_in_ctb ) / ps_pps -> i1_num_tile_columns - ( i * ps_sps -> i2_pic_wd_in_ctb ) / ps_pps -> i1_num_tile_columns ; } for ( j = 0 ; j < ps_pps -> i1_num_tile_rows ; j ++ ) { ps_tile = ps_pps -> ps_tile + j * ps_pps -> i1_num_tile_columns + i ; ps_tile -> u1_pos_x = start ; ps_tile -> u2_wd = value ; } start += value ; if ( ( start > ps_sps -> i2_pic_wd_in_ctb ) || ( value <= 0 ) ) return IHEVCD_INVALID_HEADER ; } start = 0 ; for ( i = 0 ; i < ( ps_pps -> i1_num_tile_rows ) ; i ++ ) { tile_t * ps_tile ; if ( ! ps_pps -> i1_uniform_spacing_flag ) { if ( i < ( ps_pps -> i1_num_tile_rows - 1 ) ) { UEV_PARSE ( ""row_height_minus1[<S2SV_blank>i<S2SV_blank>]"" , value , ps_bitstrm ) ; value += 1 ; } else { value = ps_sps -> i2_pic_ht_in_ctb - start ; } } else { value = ( ( i + 1 ) * ps_sps -> i2_pic_ht_in_ctb ) / ps_pps -> i1_num_tile_rows - ( i * ps_sps -> i2_pic_ht_in_ctb ) / ps_pps -> i1_num_tile_rows ; } for ( j = 0 ; j < ps_pps -> i1_num_tile_columns ; j ++ ) { ps_tile = ps_pps -> ps_tile + i * ps_pps -> i1_num_tile_columns + j ; ps_tile -> u1_pos_y = start ; ps_tile -> u2_ht = value ; } start += value ; if ( ( start > ps_sps -> i2_pic_ht_in_ctb ) || ( value <= 0 ) ) return IHEVCD_INVALID_HEADER ; } } BITS_PARSE ( ""loop_filter_across_tiles_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_loop_filter_across_tiles_enabled_flag = value ; } else { ps_pps -> i1_num_tile_columns = 1 ; ps_pps -> i1_num_tile_rows = 1 ; ps_pps -> i1_uniform_spacing_flag = 1 ; ps_pps -> ps_tile -> u1_pos_x = 0 ; ps_pps -> ps_tile -> u1_pos_y = 0 ; ps_pps -> ps_tile -> u2_wd = ps_sps -> i2_pic_wd_in_ctb ; ps_pps -> ps_tile -> u2_ht = ps_sps -> i2_pic_ht_in_ctb ; } BITS_PARSE ( ""loop_filter_across_slices_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_loop_filter_across_slices_enabled_flag = value ; BITS_PARSE ( ""deblocking_filter_control_present_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_deblocking_filter_control_present_flag = value ; ps_pps -> i1_pic_disable_deblocking_filter_flag = 0 ; ps_pps -> i1_deblocking_filter_override_enabled_flag = 0 ; ps_pps -> i1_beta_offset_div2 = 0 ; ps_pps -> i1_tc_offset_div2 = 0 ; if ( ps_pps -> i1_deblocking_filter_control_present_flag ) { BITS_PARSE ( ""deblocking_filter_override_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_deblocking_filter_override_enabled_flag = value ; BITS_PARSE ( ""pic_disable_deblocking_filter_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_pic_disable_deblocking_filter_flag = value ; if ( ! ps_pps -> i1_pic_disable_deblocking_filter_flag ) { SEV_PARSE ( ""pps_beta_offset_div2"" , value , ps_bitstrm ) ; ps_pps -> i1_beta_offset_div2 = value ; SEV_PARSE ( ""pps_tc_offset_div2"" , value , ps_bitstrm ) ; ps_pps -> i1_tc_offset_div2 = value ; } } BITS_PARSE ( ""pps_scaling_list_data_present_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_pps_scaling_list_data_present_flag = value ; if ( ps_pps -> i1_pps_scaling_list_data_present_flag ) { COPY_DEFAULT_SCALING_LIST ( ps_pps -> pi2_scaling_mat ) ; ihevcd_scaling_list_data ( ps_codec , ps_pps -> pi2_scaling_mat ) ; } BITS_PARSE ( ""lists_modification_present_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_lists_modification_present_flag = value ; UEV_PARSE ( ""log2_parallel_merge_level_minus2"" , value , ps_bitstrm ) ; ps_pps -> i1_log2_parallel_merge_level = value + 2 ; BITS_PARSE ( ""slice_header_extension_present_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_slice_header_extension_present_flag = value ; BITS_PARSE ( ""pps_extension_flag"" , value , ps_bitstrm , 1 ) ; if ( ( UWORD8 * ) ps_bitstrm -> pu4_buf > ps_bitstrm -> pu1_buf_max ) return IHEVCD_INVALID_PARAMETER ; ps_codec -> i4_pps_done = 1 ; return ret ; }","BITS_PARSE ( ""entropy_coding_sync_enabled_flag"" , value , ps_bitstrm , 1 ) ;ps_pps -> i1_entropy_coding_sync_enabled_flag = value ;",196
287,"buggy line: eb = ( 1u << PF_VECTOR ) | ( 1u << UD_VECTOR ) | ( 1u << MC_VECTOR ) |  ( 1u << NM_VECTOR ) | ( 1u << DB_VECTOR ) ;if ( ( vcpu -> guest_debug & ( KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP ) ) == ( KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP ) ) eb |= 1u << BP_VECTOR ;cwe id:CWE-399context: static void update_exception_bitmap ( struct kvm_vcpu * vcpu ) { u32 eb ; eb = ( 1u << PF_VECTOR ) | ( 1u << UD_VECTOR ) | ( 1u << MC_VECTOR ) |  ( 1u << NM_VECTOR ) | ( 1u << DB_VECTOR ) ;  if ( ( vcpu -> guest_debug & ( KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP ) ) == ( KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP ) ) eb |= 1u << BP_VECTOR ; if ( to_vmx ( vcpu ) -> rmode . vm86_active ) eb = ~ 0 ; if ( enable_ept ) eb &= ~ ( 1u << PF_VECTOR ) ; if ( vcpu -> fpu_active ) eb &= ~ ( 1u << NM_VECTOR ) ; if ( is_guest_mode ( vcpu ) ) eb |= get_vmcs12 ( vcpu ) -> exception_bitmap ; vmcs_write32 ( EXCEPTION_BITMAP , eb ) ; }",eb = ( 1u << PF_VECTOR ) | ( 1u << UD_VECTOR ) | ( 1u << MC_VECTOR ) | ( 1u << NM_VECTOR ) | ( 1u << DB_VECTOR ) | ( 1u << AC_VECTOR ) ;if ( ( vcpu -> guest_debug & ( KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP ) ) == ( KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP ) ) eb |= 1u << BP_VECTOR ;,197
288,"buggy line: static char temp [ NFSX_V3FHMAX + 1 ] ;strncpy ( temp , sfsname , NFSX_V3FHMAX ) ;temp [ sizeof ( temp ) - 1 ] = \'\\\\0\' ;spacep = strchr ( temp , \'<S2SV_blank>\' ) ;cwe id:CWE-125context: static void nfs_printfh ( netdissect_options * ndo , register const uint32_t * dp , const u_int len ) { my_fsid fsid ; uint32_t ino ; const char * sfsname = NULL ; char * spacep ; if ( ndo -> ndo_uflag ) { u_int i ; char const * sep = """" ; ND_PRINT ( ( ndo , ""<S2SV_blank>fh["" ) ) ; for ( i = 0 ; i < len ; i ++ ) { ND_PRINT ( ( ndo , ""%s%x"" , sep , dp [ i ] ) ) ; sep = "":"" ; } ND_PRINT ( ( ndo , ""]"" ) ) ; return ; } Parse_fh ( ( const u_char * ) dp , len , & fsid , & ino , NULL , & sfsname , 0 ) ; if ( sfsname ) {  static char temp [ NFSX_V3FHMAX + 1 ] ;   strncpy ( temp , sfsname , NFSX_V3FHMAX ) ;   temp [ sizeof ( temp ) - 1 ] = '\\0' ;  spacep = strchr ( temp , '<S2SV_blank>' ) ; if ( spacep ) * spacep = '\\0' ; ND_PRINT ( ( ndo , ""<S2SV_blank>fh<S2SV_blank>%s/"" , temp ) ) ; } else { ND_PRINT ( ( ndo , ""<S2SV_blank>fh<S2SV_blank>%d,%d/"" , fsid . Fsid_dev . Major , fsid . Fsid_dev . Minor ) ) ; } if ( fsid . Fsid_dev . Minor == 257 ) ND_PRINT ( ( ndo , ""%s"" , fsid . Opaque_Handle ) ) ; else ND_PRINT ( ( ndo , ""%ld"" , ( long ) ino ) ) ; }","char temp [ NFSX_V3FHMAX + 1 ] ;u_int stringlen ;stringlen = len ;if ( stringlen > NFSX_V3FHMAX ) stringlen = NFSX_V3FHMAX ;strncpy ( temp , sfsname , stringlen ) ;temp [ sizeof ( temp ) - 1 ] = \'\\\\0\' ;spacep = strchr ( temp , \'<S2SV_blank>\' ) ;",198
289,"buggy line: static inline int ip6_ufo_append_data ( struct sock * sk , int getfrag ( void * from , char * to , int offset , int len , int odd , struct sk_buff * skb ) , void * from , int length , int hh_len , int fragheaderlen ,  int transhdrlen , int mtu , unsigned int flags )  {cwe id:CWE-000context: static inline int ip6_ufo_append_data ( struct sock * sk , int getfrag ( void * from , char * to , int offset , int len , int odd , struct sk_buff * skb ) , void * from , int length , int hh_len , int fragheaderlen ,  int transhdrlen , int mtu , unsigned int flags )  { struct sk_buff * skb ; int err ; if ( ( skb = skb_peek_tail ( & sk -> sk_write_queue ) ) == NULL ) { skb = sock_alloc_send_skb ( sk , hh_len + fragheaderlen + transhdrlen + 20 , ( flags & MSG_DONTWAIT ) , & err ) ; if ( skb == NULL ) return - ENOMEM ; skb_reserve ( skb , hh_len ) ; skb_put ( skb , fragheaderlen + transhdrlen ) ; skb_reset_network_header ( skb ) ; skb -> transport_header = skb -> network_header + fragheaderlen ; skb -> ip_summed = CHECKSUM_PARTIAL ; skb -> csum = 0 ; } err = skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) ; if ( ! err ) { struct frag_hdr fhdr ; skb_shinfo ( skb ) -> gso_size = ( mtu - fragheaderlen - sizeof ( struct frag_hdr ) ) & ~ 7 ; skb_shinfo ( skb ) -> gso_type = SKB_GSO_UDP ;  ipv6_select_ident ( & fhdr ) ;  skb_shinfo ( skb ) -> ip6_frag_id = fhdr . identification ; __skb_queue_tail ( & sk -> sk_write_queue , skb ) ; return 0 ; } kfree_skb ( skb ) ; return err ; }","static inline int ip6_ufo_append_data ( struct sock * sk , int getfrag ( void * from , char * to , int offset , int len , int odd , struct sk_buff * skb ) , void * from , int length , int hh_len , int fragheaderlen , int transhdrlen , int mtu , unsigned int flags , struct rt6_info * rt ) {",199
290,"buggy line: ipv6_select_ident ( & fhdr ) ;skb_shinfo ( skb ) -> ip6_frag_id = fhdr . identification ;cwe id:CWE-000context: static inline int ip6_ufo_append_data ( struct sock * sk , int getfrag ( void * from , char * to , int offset , int len , int odd , struct sk_buff * skb ) , void * from , int length , int hh_len , int fragheaderlen ,  int transhdrlen , int mtu , unsigned int flags )  { struct sk_buff * skb ; int err ; if ( ( skb = skb_peek_tail ( & sk -> sk_write_queue ) ) == NULL ) { skb = sock_alloc_send_skb ( sk , hh_len + fragheaderlen + transhdrlen + 20 , ( flags & MSG_DONTWAIT ) , & err ) ; if ( skb == NULL ) return - ENOMEM ; skb_reserve ( skb , hh_len ) ; skb_put ( skb , fragheaderlen + transhdrlen ) ; skb_reset_network_header ( skb ) ; skb -> transport_header = skb -> network_header + fragheaderlen ; skb -> ip_summed = CHECKSUM_PARTIAL ; skb -> csum = 0 ; } err = skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) ; if ( ! err ) { struct frag_hdr fhdr ; skb_shinfo ( skb ) -> gso_size = ( mtu - fragheaderlen - sizeof ( struct frag_hdr ) ) & ~ 7 ; skb_shinfo ( skb ) -> gso_type = SKB_GSO_UDP ;  ipv6_select_ident ( & fhdr ) ;  skb_shinfo ( skb ) -> ip6_frag_id = fhdr . identification ; __skb_queue_tail ( & sk -> sk_write_queue , skb ) ; return 0 ; } kfree_skb ( skb ) ; return err ; }","ipv6_select_ident ( & fhdr , rt ) ;skb_shinfo ( skb ) -> ip6_frag_id = fhdr . identification ;",199
291,"buggy line: if ( res )  return res ;res = register_netdevice ( hsr_dev ) ;cwe id:CWE-772context: int hsr_dev_finalize ( struct net_device * hsr_dev , struct net_device * slave [ 2 ] , unsigned char multicast_spec , u8 protocol_version ) { struct hsr_priv * hsr ; struct hsr_port * port ; int res ; hsr = netdev_priv ( hsr_dev ) ; INIT_LIST_HEAD ( & hsr -> ports ) ; INIT_LIST_HEAD ( & hsr -> node_db ) ; INIT_LIST_HEAD ( & hsr -> self_node_db ) ; ether_addr_copy ( hsr_dev -> dev_addr , slave [ 0 ] -> dev_addr ) ; res = hsr_create_self_node ( & hsr -> self_node_db , hsr_dev -> dev_addr , slave [ 1 ] -> dev_addr ) ; if ( res < 0 ) return res ; spin_lock_init ( & hsr -> seqnr_lock ) ; hsr -> sequence_nr = HSR_SEQNR_START ; hsr -> sup_sequence_nr = HSR_SUP_SEQNR_START ; timer_setup ( & hsr -> announce_timer , hsr_announce , 0 ) ; timer_setup ( & hsr -> prune_timer , hsr_prune_nodes , 0 ) ; ether_addr_copy ( hsr -> sup_multicast_addr , def_multicast_addr ) ; hsr -> sup_multicast_addr [ ETH_ALEN - 1 ] = multicast_spec ; hsr -> protVersion = protocol_version ; netif_carrier_off ( hsr_dev ) ; res = hsr_add_port ( hsr , hsr_dev , HSR_PT_MASTER ) ; if ( res )  return res ;  res = register_netdevice ( hsr_dev ) ; if ( res ) goto fail ; res = hsr_add_port ( hsr , slave [ 0 ] , HSR_PT_SLAVE_A ) ; if ( res ) goto fail ; res = hsr_add_port ( hsr , slave [ 1 ] , HSR_PT_SLAVE_B ) ; if ( res ) goto fail ; mod_timer ( & hsr -> prune_timer , jiffies + msecs_to_jiffies ( PRUNE_PERIOD ) ) ; return 0 ; fail : hsr_for_each_port ( hsr , port ) hsr_del_port ( port ) ;  return res ;  }",if ( res ) goto err_add_port ;res = register_netdevice ( hsr_dev ) ;,200
292,"buggy line: return res ;}cwe id:CWE-772context: int hsr_dev_finalize ( struct net_device * hsr_dev , struct net_device * slave [ 2 ] , unsigned char multicast_spec , u8 protocol_version ) { struct hsr_priv * hsr ; struct hsr_port * port ; int res ; hsr = netdev_priv ( hsr_dev ) ; INIT_LIST_HEAD ( & hsr -> ports ) ; INIT_LIST_HEAD ( & hsr -> node_db ) ; INIT_LIST_HEAD ( & hsr -> self_node_db ) ; ether_addr_copy ( hsr_dev -> dev_addr , slave [ 0 ] -> dev_addr ) ; res = hsr_create_self_node ( & hsr -> self_node_db , hsr_dev -> dev_addr , slave [ 1 ] -> dev_addr ) ; if ( res < 0 ) return res ; spin_lock_init ( & hsr -> seqnr_lock ) ; hsr -> sequence_nr = HSR_SEQNR_START ; hsr -> sup_sequence_nr = HSR_SUP_SEQNR_START ; timer_setup ( & hsr -> announce_timer , hsr_announce , 0 ) ; timer_setup ( & hsr -> prune_timer , hsr_prune_nodes , 0 ) ; ether_addr_copy ( hsr -> sup_multicast_addr , def_multicast_addr ) ; hsr -> sup_multicast_addr [ ETH_ALEN - 1 ] = multicast_spec ; hsr -> protVersion = protocol_version ; netif_carrier_off ( hsr_dev ) ; res = hsr_add_port ( hsr , hsr_dev , HSR_PT_MASTER ) ; if ( res )  return res ;  res = register_netdevice ( hsr_dev ) ; if ( res ) goto fail ; res = hsr_add_port ( hsr , slave [ 0 ] , HSR_PT_SLAVE_A ) ; if ( res ) goto fail ; res = hsr_add_port ( hsr , slave [ 1 ] , HSR_PT_SLAVE_B ) ; if ( res ) goto fail ; mod_timer ( & hsr -> prune_timer , jiffies + msecs_to_jiffies ( PRUNE_PERIOD ) ) ; return 0 ; fail : hsr_for_each_port ( hsr , port ) hsr_del_port ( port ) ;  return res ;  }",err_add_port : hsr_del_node ( & hsr -> self_node_db ) ;return res ;},200
293,"buggy line: cwe id:CWE-399context: void parser ( void ) { char * arg ; # ifndef MINIMAL char * sitearg ; # endif # ifdef WITH_RFC2640 char * narg = NULL ; # endif size_t n ; # ifdef IMPLICIT_TLS ( void ) tls_init_new_session ( ) ; data_protection_level = CPL_PRIVATE ; # endif for ( ; ; ) { xferfd = - 1 ; if ( state_needs_update != 0 ) { state_needs_update = 0 ; setprocessname ( ""pure-ftpd<S2SV_blank>(IDLE)"" ) ; # ifdef FTPWHO if ( shm_data_cur != NULL ) { ftpwho_lock ( ) ; shm_data_cur -> state = FTPWHO_STATE_IDLE ; * shm_data_cur -> filename = 0 ; ftpwho_unlock ( ) ; } # endif } doreply ( ) ; alarm ( idletime * 2 ) ; switch ( sfgets ( ) ) { case - 1 : # ifdef BORING_MODE die ( 421 , LOG_INFO , MSG_TIMEOUT ) ; # else die ( 421 , LOG_INFO , MSG_TIMEOUT_PARSER ) ; # endif case - 2 : return ; } # ifdef DEBUG if ( debug != 0 ) { addreply ( 0 , ""%s"" , cmd ) ; } # endif n = ( size_t ) 0U ; while ( ( isalpha ( ( unsigned char ) cmd [ n ] ) || cmd [ n ] == '@' ) && n < cmdsize ) { cmd [ n ] = ( char ) tolower ( ( unsigned char ) cmd [ n ] ) ; n ++ ; } if ( n >= cmdsize ) { die ( 421 , LOG_WARNING , MSG_LINE_TOO_LONG ) ; } if ( n == ( size_t ) 0U ) { nop : addreply_noformat ( 500 , ""?"" ) ; continue ; } # ifdef SKIP_COMMAND_TRAILING_SPACES while ( isspace ( ( unsigned char ) cmd [ n ] ) && n < cmdsize ) { cmd [ n ++ ] = 0 ; } arg = cmd + n ; while ( cmd [ n ] != 0 && n < cmdsize ) { n ++ ; } n -- ; while ( isspace ( ( unsigned char ) cmd [ n ] ) ) { cmd [ n -- ] = 0 ; } # else if ( cmd [ n ] == 0 ) { arg = cmd + n ; } else if ( isspace ( ( unsigned char ) cmd [ n ] ) ) { cmd [ n ] = 0 ; arg = cmd + n + 1 ; } else { goto nop ; } # endif if ( logging != 0 ) { # ifdef DEBUG logfile ( LOG_DEBUG , MSG_DEBUG_COMMAND ""<S2SV_blank>[%s]<S2SV_blank>[%s]"" , cmd , arg ) ; # else logfile ( LOG_DEBUG , MSG_DEBUG_COMMAND ""<S2SV_blank>[%s]<S2SV_blank>[%s]"" , cmd , strcmp ( cmd , ""pass"" ) ? arg : ""<*>"" ) ; # endif } # ifdef WITH_RFC2640 narg = charset_client2fs ( arg ) ; arg = narg ; # endif # ifndef MINIMAL if ( ! strcmp ( cmd , ""noop"" ) ) { antiidle ( ) ; donoop ( ) ; goto wayout ; } # endif if ( ! strcmp ( cmd , ""user"" ) ) { # ifdef WITH_TLS if ( enforce_tls_auth > 1 && tls_cnx == NULL ) { die ( 421 , LOG_WARNING , MSG_TLS_NEEDED ) ; } # endif douser ( arg ) ; } else if ( ! strcmp ( cmd , ""acct"" ) ) { addreply ( 202 , MSG_WHOAREYOU ) ; } else if ( ! strcmp ( cmd , ""pass"" ) ) { if ( guest == 0 ) { randomdelay ( ) ; } dopass ( arg ) ; } else if ( ! strcmp ( cmd , ""quit"" ) ) { addreply ( 221 , MSG_GOODBYE , ( unsigned long long ) ( ( uploaded + 1023ULL ) / 1024ULL ) , ( unsigned long long ) ( ( downloaded + 1023ULL ) / 1024ULL ) ) ; return ; } else if ( ! strcmp ( cmd , ""syst"" ) ) { antiidle ( ) ; addreply_noformat ( 215 , ""UNIX<S2SV_blank>Type:<S2SV_blank>L8"" ) ; goto wayout ; # ifdef WITH_TLS } else if ( enforce_tls_auth > 0 && ! strcmp ( cmd , ""auth"" ) && ! strcasecmp ( arg , ""tls"" ) ) { addreply_noformat ( 234 , ""AUTH<S2SV_blank>TLS<S2SV_blank>OK."" ) ; doreply ( ) ; if ( tls_cnx == NULL ) {  ( void ) tls_init_new_session ( ) ;  } goto wayout ; } else if ( ! strcmp ( cmd , ""pbsz"" ) ) { addreply_noformat ( tls_cnx == NULL ? 503 : 200 , ""PBSZ=0"" ) ; } else if ( ! strcmp ( cmd , ""prot"" ) ) { if ( tls_cnx == NULL ) { addreply_noformat ( 503 , MSG_PROT_BEFORE_PBSZ ) ; goto wayout ; } switch ( * arg ) { case 0 : addreply_noformat ( 503 , MSG_MISSING_ARG ) ; data_protection_level = CPL_NONE ; break ; case 'C' : if ( arg [ 1 ] == 0 ) { addreply ( 200 , MSG_PROT_OK , ""clear"" ) ; data_protection_level = CPL_CLEAR ; break ; } case 'S' : case 'E' : if ( arg [ 1 ] == 0 ) { addreply ( 200 , MSG_PROT_UNKNOWN_LEVEL , arg , ""private"" ) ; data_protection_level = CPL_PRIVATE ; break ; } case 'P' : if ( arg [ 1 ] == 0 ) { addreply ( 200 , MSG_PROT_OK , ""private"" ) ; data_protection_level = CPL_PRIVATE ; break ; } default : addreply_noformat ( 534 , ""Fallback<S2SV_blank>to<S2SV_blank>[C]"" ) ; data_protection_level = CPL_CLEAR ; break ; } # endif } else if ( ! strcmp ( cmd , ""auth"" ) || ! strcmp ( cmd , ""adat"" ) ) { addreply_noformat ( 500 , MSG_AUTH_UNIMPLEMENTED ) ; } else if ( ! strcmp ( cmd , ""type"" ) ) { antiidle ( ) ; dotype ( arg ) ; goto wayout ; } else if ( ! strcmp ( cmd , ""mode"" ) ) { antiidle ( ) ; domode ( arg ) ; goto wayout ; # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""feat"" ) ) { dofeat ( ) ; goto wayout ; } else if ( ! strcmp ( cmd , ""opts"" ) ) { doopts ( arg ) ; goto wayout ; # endif } else if ( ! strcmp ( cmd , ""stru"" ) ) { dostru ( arg ) ; goto wayout ; # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""help"" ) ) { goto help_site ; # endif # ifdef DEBUG } else if ( ! strcmp ( cmd , ""xdbg"" ) ) { debug ++ ; addreply ( 200 , MSG_XDBG_OK , debug ) ; goto wayout ; # endif } else if ( loggedin == 0 ) { addreply_noformat ( 530 , MSG_NOT_LOGGED_IN ) ; goto wayout ; } else { if ( ! strcmp ( cmd , ""cwd"" ) || ! strcmp ( cmd , ""xcwd"" ) ) { antiidle ( ) ; docwd ( arg ) ; goto wayout ; } else if ( ! strcmp ( cmd , ""port"" ) ) { doport ( arg ) ; # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""eprt"" ) ) { doeprt ( arg ) ; } else if ( ! strcmp ( cmd , ""esta"" ) && disallow_passive == 0 && STORAGE_FAMILY ( force_passive_ip ) == 0 ) { doesta ( ) ; } else if ( ! strcmp ( cmd , ""estp"" ) ) { doestp ( ) ; # endif } else if ( disallow_passive == 0 && ( ! strcmp ( cmd , ""pasv"" ) || ! strcmp ( cmd , ""p@sw"" ) ) ) { dopasv ( 0 ) ; } else if ( disallow_passive == 0 && ( ! strcmp ( cmd , ""epsv"" ) && ( broken_client_compat == 0 || STORAGE_FAMILY ( ctrlconn ) == AF_INET6 ) ) ) { if ( ! strcasecmp ( arg , ""all"" ) ) { epsv_all = 1 ; addreply_noformat ( 220 , MSG_ACTIVE_DISABLED ) ; } else if ( ! strcmp ( arg , ""2"" ) && ! v6ready ) { addreply_noformat ( 522 , MSG_ONLY_IPV4 ) ; } else { dopasv ( 1 ) ; } # ifndef MINIMAL } else if ( disallow_passive == 0 && ! strcmp ( cmd , ""spsv"" ) ) { dopasv ( 2 ) ; } else if ( ! strcmp ( cmd , ""allo"" ) ) { if ( * arg == 0 ) { addreply_noformat ( 501 , MSG_STAT_FAILURE ) ; } else { const off_t size = ( off_t ) strtoull ( arg , NULL , 10 ) ; if ( size < ( off_t ) 0 ) { addreply_noformat ( 501 , MSG_STAT_FAILURE ) ; } else { doallo ( size ) ; } } # endif } else if ( ! strcmp ( cmd , ""pwd"" ) || ! strcmp ( cmd , ""xpwd"" ) ) { # ifdef WITH_RFC2640 char * nwd ; # endif antiidle ( ) ; # ifdef WITH_RFC2640 nwd = charset_fs2client ( wd ) ; addreply ( 257 , ""\\""%s\\""<S2SV_blank>"" MSG_IS_YOUR_CURRENT_LOCATION , nwd ) ; free ( nwd ) ; # else addreply ( 257 , ""\\""%s\\""<S2SV_blank>"" MSG_IS_YOUR_CURRENT_LOCATION , wd ) ; # endif goto wayout ; } else if ( ! strcmp ( cmd , ""cdup"" ) || ! strcmp ( cmd , ""xcup"" ) ) { docwd ( "".."" ) ; } else if ( ! strcmp ( cmd , ""retr"" ) ) { if ( * arg != 0 ) { # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { doretr ( arg ) ; } } else { addreply_noformat ( 501 , MSG_NO_FILE_NAME ) ; } } else if ( ! strcmp ( cmd , ""rest"" ) ) { antiidle ( ) ; if ( * arg != 0 ) { dorest ( arg ) ; } else { addreply_noformat ( 501 , MSG_NO_RESTART_POINT ) ; restartat = ( off_t ) 0 ; } goto wayout ; } else if ( ! strcmp ( cmd , ""dele"" ) ) { if ( * arg != 0 ) { dodele ( arg ) ; } else { addreply_noformat ( 501 , MSG_NO_FILE_NAME ) ; } } else if ( ! strcmp ( cmd , ""stor"" ) ) { arg = revealextraspc ( arg ) ; if ( * arg != 0 ) { # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { dostor ( arg , 0 , autorename ) ; } } else { addreply_noformat ( 501 , MSG_NO_FILE_NAME ) ; } } else if ( ! strcmp ( cmd , ""appe"" ) ) { arg = revealextraspc ( arg ) ; if ( * arg != 0 ) { # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { dostor ( arg , 1 , 0 ) ; } } else { addreply_noformat ( 501 , MSG_NO_FILE_NAME ) ; } # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""stou"" ) ) { # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { dostou ( ) ; } # endif # ifndef DISABLE_MKD_RMD } else if ( ! strcmp ( cmd , ""mkd"" ) || ! strcmp ( cmd , ""xmkd"" ) ) { arg = revealextraspc ( arg ) ; if ( * arg != 0 ) { domkd ( arg ) ; } else { addreply_noformat ( 501 , MSG_NO_DIRECTORY_NAME ) ; } } else if ( ! strcmp ( cmd , ""rmd"" ) || ! strcmp ( cmd , ""xrmd"" ) ) { if ( * arg != 0 ) { dormd ( arg ) ; } else { addreply_noformat ( 550 , MSG_NO_DIRECTORY_NAME ) ; } # endif # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""stat"" ) ) { if ( * arg != 0 ) { modern_listings = 0 ; donlist ( arg , 1 , 1 , 1 , 1 ) ; } else { addreply_noformat ( 211 , ""http://www.pureftpd.org/"" ) ; } # endif } else if ( ! strcmp ( cmd , ""list"" ) ) { # ifndef MINIMAL modern_listings = 0 ; # endif # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { donlist ( arg , 0 , 1 , 0 , 1 ) ; } } else if ( ! strcmp ( cmd , ""nlst"" ) ) { # ifndef MINIMAL modern_listings = 0 ; # endif # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { donlist ( arg , 0 , 0 , 0 , broken_client_compat ) ; } # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""mlst"" ) ) { # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { domlst ( * arg != 0 ? arg : ""."" ) ; } } else if ( ! strcmp ( cmd , ""mlsd"" ) ) { modern_listings = 1 ; # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { donlist ( arg , 0 , 1 , 1 , 0 ) ; } # endif } else if ( ! strcmp ( cmd , ""abor"" ) ) { addreply_noformat ( 226 , MSG_ABOR_SUCCESS ) ; # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""site"" ) ) { if ( ( sitearg = arg ) != NULL ) { while ( * sitearg != 0 && ! isspace ( ( unsigned char ) * sitearg ) ) { sitearg ++ ; } if ( * sitearg != 0 ) { * sitearg ++ = 0 ; } } if ( ! strcasecmp ( arg , ""idle"" ) ) { if ( sitearg == NULL || * sitearg == 0 ) { addreply_noformat ( 501 , ""SITE<S2SV_blank>IDLE:<S2SV_blank>"" MSG_MISSING_ARG ) ; } else { unsigned long int i = 0 ; i = strtoul ( sitearg , & sitearg , 10 ) ; if ( sitearg && * sitearg ) addreply ( 501 , MSG_GARBAGE_FOUND ""<S2SV_blank>:<S2SV_blank>%s"" , sitearg ) ; else if ( i > MAX_SITE_IDLE ) addreply_noformat ( 501 , MSG_VALUE_TOO_LARGE ) ; else { idletime = i ; addreply ( 200 , MSG_IDLE_TIME , idletime ) ; idletime_noop = ( double ) idletime * 2.0 ; } } } else if ( ! strcasecmp ( arg , ""time"" ) ) { dositetime ( ) ; } else if ( ! strcasecmp ( arg , ""help"" ) ) { help_site : addreply_noformat ( 214 , MSG_SITE_HELP CRLF # ifdef WITH_DIRALIASES ""<S2SV_blank>ALIAS"" CRLF # endif ""<S2SV_blank>CHMOD"" CRLF ""<S2SV_blank>IDLE"" CRLF ""<S2SV_blank>UTIME"" ) ; addreply_noformat ( 214 , ""Pure-FTPd<S2SV_blank>-<S2SV_blank>http://pureftpd.org/"" ) ; } else if ( ! strcasecmp ( arg , ""chmod"" ) ) { char * sitearg2 ; mode_t mode ; parsechmod : if ( sitearg == NULL || * sitearg == 0 ) { addreply_noformat ( 501 , MSG_MISSING_ARG ) ; goto chmod_wayout ; } sitearg2 = sitearg ; while ( * sitearg2 != 0 && ! isspace ( ( unsigned char ) * sitearg2 ) ) { sitearg2 ++ ; } while ( * sitearg2 != 0 && isspace ( ( unsigned char ) * sitearg2 ) ) { sitearg2 ++ ; } if ( * sitearg2 == 0 ) { addreply_noformat ( 550 , MSG_NO_FILE_NAME ) ; goto chmod_wayout ; } mode = ( mode_t ) strtoul ( sitearg , NULL , 8 ) ; if ( mode > ( mode_t ) 07777 ) { addreply_noformat ( 501 , MSG_BAD_CHMOD ) ; goto chmod_wayout ; } dochmod ( sitearg2 , mode ) ; chmod_wayout : ( void ) 0 ; } else if ( ! strcasecmp ( arg , ""utime"" ) ) { char * sitearg2 ; if ( sitearg == NULL || * sitearg == 0 ) { addreply_noformat ( 501 , MSG_NO_FILE_NAME ) ; goto utime_wayout ; } if ( ( sitearg2 = strrchr ( sitearg , '<S2SV_blank>' ) ) == NULL || sitearg2 == sitearg ) { addreply_noformat ( 501 , MSG_MISSING_ARG ) ; goto utime_wayout ; } if ( strcasecmp ( sitearg2 , ""<S2SV_blank>UTC"" ) != 0 ) { addreply_noformat ( 500 , ""UTC<S2SV_blank>Only"" ) ; goto utime_wayout ; } * sitearg2 -- = 0 ; if ( ( sitearg2 = strrchr ( sitearg , '<S2SV_blank>' ) ) == NULL || sitearg2 == sitearg ) { utime_no_arg : addreply_noformat ( 501 , MSG_MISSING_ARG ) ; goto utime_wayout ; } * sitearg2 -- = 0 ; if ( ( sitearg2 = strrchr ( sitearg , '<S2SV_blank>' ) ) == NULL || sitearg2 == sitearg ) { goto utime_no_arg ; } * sitearg2 -- = 0 ; if ( ( sitearg2 = strrchr ( sitearg , '<S2SV_blank>' ) ) == NULL || sitearg2 == sitearg ) { goto utime_no_arg ; } * sitearg2 ++ = 0 ; if ( * sitearg2 == 0 ) { goto utime_no_arg ; } doutime ( sitearg , sitearg2 ) ; utime_wayout : ( void ) 0 ; # ifdef WITH_DIRALIASES } else if ( ! strcasecmp ( arg , ""alias"" ) ) { if ( sitearg == NULL || * sitearg == 0 ) { print_aliases ( ) ; } else { const char * alias ; if ( ( alias = lookup_alias ( sitearg ) ) != NULL ) { addreply ( 214 , MSG_ALIASES_ALIAS , sitearg , alias ) ; } else { addreply ( 502 , MSG_ALIASES_UNKNOWN , sitearg ) ; } } # endif } else if ( * arg != 0 ) { addreply ( 500 , ""SITE<S2SV_blank>%s<S2SV_blank>"" MSG_UNKNOWN_EXTENSION , arg ) ; } else { addreply_noformat ( 500 , ""SITE:<S2SV_blank>"" MSG_MISSING_ARG ) ; } # endif } else if ( ! strcmp ( cmd , ""mdtm"" ) ) { domdtm ( arg ) ; } else if ( ! strcmp ( cmd , ""size"" ) ) { dosize ( arg ) ; # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""chmod"" ) ) { sitearg = arg ; goto parsechmod ; # endif } else if ( ! strcmp ( cmd , ""rnfr"" ) ) { if ( * arg != 0 ) { dornfr ( arg ) ; } else { addreply_noformat ( 550 , MSG_NO_FILE_NAME ) ; } } else if ( ! strcmp ( cmd , ""rnto"" ) ) { arg = revealextraspc ( arg ) ; if ( * arg != 0 ) { dornto ( arg ) ; } else { addreply_noformat ( 550 , MSG_NO_FILE_NAME ) ; } } else { addreply_noformat ( 500 , MSG_UNKNOWN_COMMAND ) ; } } noopidle = ( time_t ) - 1 ; wayout : # ifdef WITH_RFC2640 free ( narg ) ; narg = NULL ; # endif # ifdef THROTTLING if ( throttling_delay != 0UL ) { usleep2 ( throttling_delay ) ; } # else ( void ) 0 ; # endif } }",flush_cmd ( ) ;,201
294,"buggy line: ( void ) tls_init_new_session ( ) ;}cwe id:CWE-399context: void parser ( void ) { char * arg ; # ifndef MINIMAL char * sitearg ; # endif # ifdef WITH_RFC2640 char * narg = NULL ; # endif size_t n ; # ifdef IMPLICIT_TLS ( void ) tls_init_new_session ( ) ; data_protection_level = CPL_PRIVATE ; # endif for ( ; ; ) { xferfd = - 1 ; if ( state_needs_update != 0 ) { state_needs_update = 0 ; setprocessname ( ""pure-ftpd<S2SV_blank>(IDLE)"" ) ; # ifdef FTPWHO if ( shm_data_cur != NULL ) { ftpwho_lock ( ) ; shm_data_cur -> state = FTPWHO_STATE_IDLE ; * shm_data_cur -> filename = 0 ; ftpwho_unlock ( ) ; } # endif } doreply ( ) ; alarm ( idletime * 2 ) ; switch ( sfgets ( ) ) { case - 1 : # ifdef BORING_MODE die ( 421 , LOG_INFO , MSG_TIMEOUT ) ; # else die ( 421 , LOG_INFO , MSG_TIMEOUT_PARSER ) ; # endif case - 2 : return ; } # ifdef DEBUG if ( debug != 0 ) { addreply ( 0 , ""%s"" , cmd ) ; } # endif n = ( size_t ) 0U ; while ( ( isalpha ( ( unsigned char ) cmd [ n ] ) || cmd [ n ] == '@' ) && n < cmdsize ) { cmd [ n ] = ( char ) tolower ( ( unsigned char ) cmd [ n ] ) ; n ++ ; } if ( n >= cmdsize ) { die ( 421 , LOG_WARNING , MSG_LINE_TOO_LONG ) ; } if ( n == ( size_t ) 0U ) { nop : addreply_noformat ( 500 , ""?"" ) ; continue ; } # ifdef SKIP_COMMAND_TRAILING_SPACES while ( isspace ( ( unsigned char ) cmd [ n ] ) && n < cmdsize ) { cmd [ n ++ ] = 0 ; } arg = cmd + n ; while ( cmd [ n ] != 0 && n < cmdsize ) { n ++ ; } n -- ; while ( isspace ( ( unsigned char ) cmd [ n ] ) ) { cmd [ n -- ] = 0 ; } # else if ( cmd [ n ] == 0 ) { arg = cmd + n ; } else if ( isspace ( ( unsigned char ) cmd [ n ] ) ) { cmd [ n ] = 0 ; arg = cmd + n + 1 ; } else { goto nop ; } # endif if ( logging != 0 ) { # ifdef DEBUG logfile ( LOG_DEBUG , MSG_DEBUG_COMMAND ""<S2SV_blank>[%s]<S2SV_blank>[%s]"" , cmd , arg ) ; # else logfile ( LOG_DEBUG , MSG_DEBUG_COMMAND ""<S2SV_blank>[%s]<S2SV_blank>[%s]"" , cmd , strcmp ( cmd , ""pass"" ) ? arg : ""<*>"" ) ; # endif } # ifdef WITH_RFC2640 narg = charset_client2fs ( arg ) ; arg = narg ; # endif # ifndef MINIMAL if ( ! strcmp ( cmd , ""noop"" ) ) { antiidle ( ) ; donoop ( ) ; goto wayout ; } # endif if ( ! strcmp ( cmd , ""user"" ) ) { # ifdef WITH_TLS if ( enforce_tls_auth > 1 && tls_cnx == NULL ) { die ( 421 , LOG_WARNING , MSG_TLS_NEEDED ) ; } # endif douser ( arg ) ; } else if ( ! strcmp ( cmd , ""acct"" ) ) { addreply ( 202 , MSG_WHOAREYOU ) ; } else if ( ! strcmp ( cmd , ""pass"" ) ) { if ( guest == 0 ) { randomdelay ( ) ; } dopass ( arg ) ; } else if ( ! strcmp ( cmd , ""quit"" ) ) { addreply ( 221 , MSG_GOODBYE , ( unsigned long long ) ( ( uploaded + 1023ULL ) / 1024ULL ) , ( unsigned long long ) ( ( downloaded + 1023ULL ) / 1024ULL ) ) ; return ; } else if ( ! strcmp ( cmd , ""syst"" ) ) { antiidle ( ) ; addreply_noformat ( 215 , ""UNIX<S2SV_blank>Type:<S2SV_blank>L8"" ) ; goto wayout ; # ifdef WITH_TLS } else if ( enforce_tls_auth > 0 && ! strcmp ( cmd , ""auth"" ) && ! strcasecmp ( arg , ""tls"" ) ) { addreply_noformat ( 234 , ""AUTH<S2SV_blank>TLS<S2SV_blank>OK."" ) ; doreply ( ) ; if ( tls_cnx == NULL ) {  ( void ) tls_init_new_session ( ) ;  } goto wayout ; } else if ( ! strcmp ( cmd , ""pbsz"" ) ) { addreply_noformat ( tls_cnx == NULL ? 503 : 200 , ""PBSZ=0"" ) ; } else if ( ! strcmp ( cmd , ""prot"" ) ) { if ( tls_cnx == NULL ) { addreply_noformat ( 503 , MSG_PROT_BEFORE_PBSZ ) ; goto wayout ; } switch ( * arg ) { case 0 : addreply_noformat ( 503 , MSG_MISSING_ARG ) ; data_protection_level = CPL_NONE ; break ; case 'C' : if ( arg [ 1 ] == 0 ) { addreply ( 200 , MSG_PROT_OK , ""clear"" ) ; data_protection_level = CPL_CLEAR ; break ; } case 'S' : case 'E' : if ( arg [ 1 ] == 0 ) { addreply ( 200 , MSG_PROT_UNKNOWN_LEVEL , arg , ""private"" ) ; data_protection_level = CPL_PRIVATE ; break ; } case 'P' : if ( arg [ 1 ] == 0 ) { addreply ( 200 , MSG_PROT_OK , ""private"" ) ; data_protection_level = CPL_PRIVATE ; break ; } default : addreply_noformat ( 534 , ""Fallback<S2SV_blank>to<S2SV_blank>[C]"" ) ; data_protection_level = CPL_CLEAR ; break ; } # endif } else if ( ! strcmp ( cmd , ""auth"" ) || ! strcmp ( cmd , ""adat"" ) ) { addreply_noformat ( 500 , MSG_AUTH_UNIMPLEMENTED ) ; } else if ( ! strcmp ( cmd , ""type"" ) ) { antiidle ( ) ; dotype ( arg ) ; goto wayout ; } else if ( ! strcmp ( cmd , ""mode"" ) ) { antiidle ( ) ; domode ( arg ) ; goto wayout ; # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""feat"" ) ) { dofeat ( ) ; goto wayout ; } else if ( ! strcmp ( cmd , ""opts"" ) ) { doopts ( arg ) ; goto wayout ; # endif } else if ( ! strcmp ( cmd , ""stru"" ) ) { dostru ( arg ) ; goto wayout ; # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""help"" ) ) { goto help_site ; # endif # ifdef DEBUG } else if ( ! strcmp ( cmd , ""xdbg"" ) ) { debug ++ ; addreply ( 200 , MSG_XDBG_OK , debug ) ; goto wayout ; # endif } else if ( loggedin == 0 ) { addreply_noformat ( 530 , MSG_NOT_LOGGED_IN ) ; goto wayout ; } else { if ( ! strcmp ( cmd , ""cwd"" ) || ! strcmp ( cmd , ""xcwd"" ) ) { antiidle ( ) ; docwd ( arg ) ; goto wayout ; } else if ( ! strcmp ( cmd , ""port"" ) ) { doport ( arg ) ; # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""eprt"" ) ) { doeprt ( arg ) ; } else if ( ! strcmp ( cmd , ""esta"" ) && disallow_passive == 0 && STORAGE_FAMILY ( force_passive_ip ) == 0 ) { doesta ( ) ; } else if ( ! strcmp ( cmd , ""estp"" ) ) { doestp ( ) ; # endif } else if ( disallow_passive == 0 && ( ! strcmp ( cmd , ""pasv"" ) || ! strcmp ( cmd , ""p@sw"" ) ) ) { dopasv ( 0 ) ; } else if ( disallow_passive == 0 && ( ! strcmp ( cmd , ""epsv"" ) && ( broken_client_compat == 0 || STORAGE_FAMILY ( ctrlconn ) == AF_INET6 ) ) ) { if ( ! strcasecmp ( arg , ""all"" ) ) { epsv_all = 1 ; addreply_noformat ( 220 , MSG_ACTIVE_DISABLED ) ; } else if ( ! strcmp ( arg , ""2"" ) && ! v6ready ) { addreply_noformat ( 522 , MSG_ONLY_IPV4 ) ; } else { dopasv ( 1 ) ; } # ifndef MINIMAL } else if ( disallow_passive == 0 && ! strcmp ( cmd , ""spsv"" ) ) { dopasv ( 2 ) ; } else if ( ! strcmp ( cmd , ""allo"" ) ) { if ( * arg == 0 ) { addreply_noformat ( 501 , MSG_STAT_FAILURE ) ; } else { const off_t size = ( off_t ) strtoull ( arg , NULL , 10 ) ; if ( size < ( off_t ) 0 ) { addreply_noformat ( 501 , MSG_STAT_FAILURE ) ; } else { doallo ( size ) ; } } # endif } else if ( ! strcmp ( cmd , ""pwd"" ) || ! strcmp ( cmd , ""xpwd"" ) ) { # ifdef WITH_RFC2640 char * nwd ; # endif antiidle ( ) ; # ifdef WITH_RFC2640 nwd = charset_fs2client ( wd ) ; addreply ( 257 , ""\\""%s\\""<S2SV_blank>"" MSG_IS_YOUR_CURRENT_LOCATION , nwd ) ; free ( nwd ) ; # else addreply ( 257 , ""\\""%s\\""<S2SV_blank>"" MSG_IS_YOUR_CURRENT_LOCATION , wd ) ; # endif goto wayout ; } else if ( ! strcmp ( cmd , ""cdup"" ) || ! strcmp ( cmd , ""xcup"" ) ) { docwd ( "".."" ) ; } else if ( ! strcmp ( cmd , ""retr"" ) ) { if ( * arg != 0 ) { # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { doretr ( arg ) ; } } else { addreply_noformat ( 501 , MSG_NO_FILE_NAME ) ; } } else if ( ! strcmp ( cmd , ""rest"" ) ) { antiidle ( ) ; if ( * arg != 0 ) { dorest ( arg ) ; } else { addreply_noformat ( 501 , MSG_NO_RESTART_POINT ) ; restartat = ( off_t ) 0 ; } goto wayout ; } else if ( ! strcmp ( cmd , ""dele"" ) ) { if ( * arg != 0 ) { dodele ( arg ) ; } else { addreply_noformat ( 501 , MSG_NO_FILE_NAME ) ; } } else if ( ! strcmp ( cmd , ""stor"" ) ) { arg = revealextraspc ( arg ) ; if ( * arg != 0 ) { # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { dostor ( arg , 0 , autorename ) ; } } else { addreply_noformat ( 501 , MSG_NO_FILE_NAME ) ; } } else if ( ! strcmp ( cmd , ""appe"" ) ) { arg = revealextraspc ( arg ) ; if ( * arg != 0 ) { # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { dostor ( arg , 1 , 0 ) ; } } else { addreply_noformat ( 501 , MSG_NO_FILE_NAME ) ; } # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""stou"" ) ) { # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { dostou ( ) ; } # endif # ifndef DISABLE_MKD_RMD } else if ( ! strcmp ( cmd , ""mkd"" ) || ! strcmp ( cmd , ""xmkd"" ) ) { arg = revealextraspc ( arg ) ; if ( * arg != 0 ) { domkd ( arg ) ; } else { addreply_noformat ( 501 , MSG_NO_DIRECTORY_NAME ) ; } } else if ( ! strcmp ( cmd , ""rmd"" ) || ! strcmp ( cmd , ""xrmd"" ) ) { if ( * arg != 0 ) { dormd ( arg ) ; } else { addreply_noformat ( 550 , MSG_NO_DIRECTORY_NAME ) ; } # endif # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""stat"" ) ) { if ( * arg != 0 ) { modern_listings = 0 ; donlist ( arg , 1 , 1 , 1 , 1 ) ; } else { addreply_noformat ( 211 , ""http://www.pureftpd.org/"" ) ; } # endif } else if ( ! strcmp ( cmd , ""list"" ) ) { # ifndef MINIMAL modern_listings = 0 ; # endif # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { donlist ( arg , 0 , 1 , 0 , 1 ) ; } } else if ( ! strcmp ( cmd , ""nlst"" ) ) { # ifndef MINIMAL modern_listings = 0 ; # endif # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { donlist ( arg , 0 , 0 , 0 , broken_client_compat ) ; } # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""mlst"" ) ) { # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { domlst ( * arg != 0 ? arg : ""."" ) ; } } else if ( ! strcmp ( cmd , ""mlsd"" ) ) { modern_listings = 1 ; # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { donlist ( arg , 0 , 1 , 1 , 0 ) ; } # endif } else if ( ! strcmp ( cmd , ""abor"" ) ) { addreply_noformat ( 226 , MSG_ABOR_SUCCESS ) ; # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""site"" ) ) { if ( ( sitearg = arg ) != NULL ) { while ( * sitearg != 0 && ! isspace ( ( unsigned char ) * sitearg ) ) { sitearg ++ ; } if ( * sitearg != 0 ) { * sitearg ++ = 0 ; } } if ( ! strcasecmp ( arg , ""idle"" ) ) { if ( sitearg == NULL || * sitearg == 0 ) { addreply_noformat ( 501 , ""SITE<S2SV_blank>IDLE:<S2SV_blank>"" MSG_MISSING_ARG ) ; } else { unsigned long int i = 0 ; i = strtoul ( sitearg , & sitearg , 10 ) ; if ( sitearg && * sitearg ) addreply ( 501 , MSG_GARBAGE_FOUND ""<S2SV_blank>:<S2SV_blank>%s"" , sitearg ) ; else if ( i > MAX_SITE_IDLE ) addreply_noformat ( 501 , MSG_VALUE_TOO_LARGE ) ; else { idletime = i ; addreply ( 200 , MSG_IDLE_TIME , idletime ) ; idletime_noop = ( double ) idletime * 2.0 ; } } } else if ( ! strcasecmp ( arg , ""time"" ) ) { dositetime ( ) ; } else if ( ! strcasecmp ( arg , ""help"" ) ) { help_site : addreply_noformat ( 214 , MSG_SITE_HELP CRLF # ifdef WITH_DIRALIASES ""<S2SV_blank>ALIAS"" CRLF # endif ""<S2SV_blank>CHMOD"" CRLF ""<S2SV_blank>IDLE"" CRLF ""<S2SV_blank>UTIME"" ) ; addreply_noformat ( 214 , ""Pure-FTPd<S2SV_blank>-<S2SV_blank>http://pureftpd.org/"" ) ; } else if ( ! strcasecmp ( arg , ""chmod"" ) ) { char * sitearg2 ; mode_t mode ; parsechmod : if ( sitearg == NULL || * sitearg == 0 ) { addreply_noformat ( 501 , MSG_MISSING_ARG ) ; goto chmod_wayout ; } sitearg2 = sitearg ; while ( * sitearg2 != 0 && ! isspace ( ( unsigned char ) * sitearg2 ) ) { sitearg2 ++ ; } while ( * sitearg2 != 0 && isspace ( ( unsigned char ) * sitearg2 ) ) { sitearg2 ++ ; } if ( * sitearg2 == 0 ) { addreply_noformat ( 550 , MSG_NO_FILE_NAME ) ; goto chmod_wayout ; } mode = ( mode_t ) strtoul ( sitearg , NULL , 8 ) ; if ( mode > ( mode_t ) 07777 ) { addreply_noformat ( 501 , MSG_BAD_CHMOD ) ; goto chmod_wayout ; } dochmod ( sitearg2 , mode ) ; chmod_wayout : ( void ) 0 ; } else if ( ! strcasecmp ( arg , ""utime"" ) ) { char * sitearg2 ; if ( sitearg == NULL || * sitearg == 0 ) { addreply_noformat ( 501 , MSG_NO_FILE_NAME ) ; goto utime_wayout ; } if ( ( sitearg2 = strrchr ( sitearg , '<S2SV_blank>' ) ) == NULL || sitearg2 == sitearg ) { addreply_noformat ( 501 , MSG_MISSING_ARG ) ; goto utime_wayout ; } if ( strcasecmp ( sitearg2 , ""<S2SV_blank>UTC"" ) != 0 ) { addreply_noformat ( 500 , ""UTC<S2SV_blank>Only"" ) ; goto utime_wayout ; } * sitearg2 -- = 0 ; if ( ( sitearg2 = strrchr ( sitearg , '<S2SV_blank>' ) ) == NULL || sitearg2 == sitearg ) { utime_no_arg : addreply_noformat ( 501 , MSG_MISSING_ARG ) ; goto utime_wayout ; } * sitearg2 -- = 0 ; if ( ( sitearg2 = strrchr ( sitearg , '<S2SV_blank>' ) ) == NULL || sitearg2 == sitearg ) { goto utime_no_arg ; } * sitearg2 -- = 0 ; if ( ( sitearg2 = strrchr ( sitearg , '<S2SV_blank>' ) ) == NULL || sitearg2 == sitearg ) { goto utime_no_arg ; } * sitearg2 ++ = 0 ; if ( * sitearg2 == 0 ) { goto utime_no_arg ; } doutime ( sitearg , sitearg2 ) ; utime_wayout : ( void ) 0 ; # ifdef WITH_DIRALIASES } else if ( ! strcasecmp ( arg , ""alias"" ) ) { if ( sitearg == NULL || * sitearg == 0 ) { print_aliases ( ) ; } else { const char * alias ; if ( ( alias = lookup_alias ( sitearg ) ) != NULL ) { addreply ( 214 , MSG_ALIASES_ALIAS , sitearg , alias ) ; } else { addreply ( 502 , MSG_ALIASES_UNKNOWN , sitearg ) ; } } # endif } else if ( * arg != 0 ) { addreply ( 500 , ""SITE<S2SV_blank>%s<S2SV_blank>"" MSG_UNKNOWN_EXTENSION , arg ) ; } else { addreply_noformat ( 500 , ""SITE:<S2SV_blank>"" MSG_MISSING_ARG ) ; } # endif } else if ( ! strcmp ( cmd , ""mdtm"" ) ) { domdtm ( arg ) ; } else if ( ! strcmp ( cmd , ""size"" ) ) { dosize ( arg ) ; # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""chmod"" ) ) { sitearg = arg ; goto parsechmod ; # endif } else if ( ! strcmp ( cmd , ""rnfr"" ) ) { if ( * arg != 0 ) { dornfr ( arg ) ; } else { addreply_noformat ( 550 , MSG_NO_FILE_NAME ) ; } } else if ( ! strcmp ( cmd , ""rnto"" ) ) { arg = revealextraspc ( arg ) ; if ( * arg != 0 ) { dornto ( arg ) ; } else { addreply_noformat ( 550 , MSG_NO_FILE_NAME ) ; } } else { addreply_noformat ( 500 , MSG_UNKNOWN_COMMAND ) ; } } noopidle = ( time_t ) - 1 ; wayout : # ifdef WITH_RFC2640 free ( narg ) ; narg = NULL ; # endif # ifdef THROTTLING if ( throttling_delay != 0UL ) { usleep2 ( throttling_delay ) ; } # else ( void ) 0 ; # endif } }",( void ) tls_init_new_session ( ) ;},201
295,"buggy line: void vp9_setup_dst_planes ( MACROBLOCKD * xd ,  const YV12_BUFFER_CONFIG * src , int mi_row , int mi_col ) {uint8_t * const buffers [ 4 ] = {src -> y_buffer , src -> u_buffer , src -> v_buffer ,  src -> alpha_buffer }const int strides [ 4 ] = {src -> y_stride , src -> uv_stride , src -> uv_stride ,  src -> alpha_stride }struct macroblockd_plane * const pd = & xd -> plane [ i ] ;setup_pred_plane ( & pd -> dst , buffers [ i ] , strides [ i ] , mi_row , mi_col , NULL , pd -> subsampling_x , pd -> subsampling_y ) ;cwe id:CWE-119context:  void vp9_setup_dst_planes ( MACROBLOCKD * xd ,  const YV12_BUFFER_CONFIG * src , int mi_row , int mi_col ) {  uint8_t * const buffers [ 4 ] = { src -> y_buffer , src -> u_buffer , src -> v_buffer ,  src -> alpha_buffer } ;  const int strides [ 4 ] = { src -> y_stride , src -> uv_stride , src -> uv_stride ,  src -> alpha_stride } ; int i ; for ( i = 0 ; i < MAX_MB_PLANE ; ++ i ) {  struct macroblockd_plane * const pd = & xd -> plane [ i ] ;  setup_pred_plane ( & pd -> dst , buffers [ i ] , strides [ i ] , mi_row , mi_col , NULL , pd -> subsampling_x , pd -> subsampling_y ) ; } }","void vp9_setup_dst_planes ( struct macroblockd_plane planes [ MAX_MB_PLANE ] , const YV12_BUFFER_CONFIG * src , int mi_row , int mi_col ) {uint8_t * const buffers [ MAX_MB_PLANE ] = {src -> y_buffer , src -> u_buffer , src -> v_buffer }const int strides [ 4 ] = {src -> y_stride , src -> uv_stride }struct macroblockd_plane * const pd = & planes [ i ] ;setup_pred_plane ( & pd -> dst , buffers [ i ] , strides [ i ] , mi_row , mi_col , NULL , pd -> subsampling_x , pd -> subsampling_y ) ;",202
296,"buggy line: len = args -> len = ntohl ( * p ++ ) ;if ( args -> count != args -> len ) return 0 ;cwe id:CWE-119context: int nfs3svc_decode_writeargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_writeargs * args ) { unsigned int len , v , hdr , dlen ; u32 max_blocksize = svc_max_payload ( rqstp ) ; struct kvec * head = rqstp -> rq_arg . head ; struct kvec * tail = rqstp -> rq_arg . tail ; p = decode_fh ( p , & args -> fh ) ; if ( ! p ) return 0 ; p = xdr_decode_hyper ( p , & args -> offset ) ; args -> count = ntohl ( * p ++ ) ; args -> stable = ntohl ( * p ++ ) ;  len = args -> len = ntohl ( * p ++ ) ;  if ( args -> count != args -> len ) return 0 ; hdr = ( void * ) p - head -> iov_base ; dlen = head -> iov_len + rqstp -> rq_arg . page_len + tail -> iov_len - hdr ; if ( dlen < XDR_QUADLEN ( len ) * 4 ) return 0 ; if ( args -> count > max_blocksize ) { args -> count = max_blocksize ; len = args -> len = max_blocksize ; } rqstp -> rq_vec [ 0 ] . iov_base = ( void * ) p ; rqstp -> rq_vec [ 0 ] . iov_len = head -> iov_len - hdr ; v = 0 ; while ( len > rqstp -> rq_vec [ v ] . iov_len ) { len -= rqstp -> rq_vec [ v ] . iov_len ; v ++ ; rqstp -> rq_vec [ v ] . iov_base = page_address ( rqstp -> rq_pages [ v ] ) ; rqstp -> rq_vec [ v ] . iov_len = PAGE_SIZE ; } rqstp -> rq_vec [ v ] . iov_len = len ; args -> vlen = v + 1 ; return 1 ; }",if ( ( void * ) p > head -> iov_base + head -> iov_len ) return 0 ;len = args -> len = ntohl ( * p ++ ) ;if ( args -> count != args -> len ) return 0 ;,203
297,"buggy line: static inline void assign_eip_near ( struct x86_emulate_ctxt * ctxt , ulong dst )  {switch ( ctxt -> op_bytes ) {case 2 : ctxt -> _eip = ( u16 ) dst ;break ;case 4 : ctxt -> _eip = ( u32 ) dst ;break ;case 8 : ctxt -> _eip = dst ;break ;default : WARN ( 1 , ""unsupported<S2SV_blank>eip<S2SV_blank>assignment<S2SV_blank>size\\\}cwe id:CWE-000context:  static inline void assign_eip_near ( struct x86_emulate_ctxt * ctxt , ulong dst )  {  switch ( ctxt -> op_bytes ) {  case 2 : ctxt -> _eip = ( u16 ) dst ; break ; case 4 : ctxt -> _eip = ( u32 ) dst ; break ; case 8 : ctxt -> _eip = dst ; break ; default : WARN ( 1 , ""unsupported<S2SV_blank>eip<S2SV_blank>assignment<S2SV_blank>size\\n"" ) ; }  } ","static inline int assign_eip_near ( struct x86_emulate_ctxt * ctxt , ulong dst ) {return assign_eip_far ( ctxt , dst , ctxt -> mode == X86EMUL_MODE_PROT64 ) ;",204
298,"buggy line: static vpx_codec_err_t ctrl_set_invert_tile_order ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {ctx -> invert_tile_order = va_arg ( args , int ) ;cwe id:CWE-119context: static vpx_codec_err_t ctrl_set_invert_tile_order ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {  ctx -> invert_tile_order = va_arg ( args , int ) ; return VPX_CODEC_OK ; }","static vpx_codec_err_t ctrl_set_invert_tile_order ( vpx_codec_alg_priv_t * ctx , va_list args ) {ctx -> invert_tile_order = va_arg ( args , int ) ;",205
299,"buggy line: remaining = tvb_captured_length_remaining ( tvb , offset ) ;if ( remaining <= 0 ) {cwe id:CWE-399context: static int dissect_spoolss_uint16uni ( tvbuff_t * tvb , int offset , packet_info * pinfo _U_ , proto_tree * tree , guint8 * drep _U_ , char * * data , int hf_name ) { gint len , remaining ; char * text ; if ( offset % 2 ) offset += 2 - ( offset % 2 ) ;  remaining = tvb_captured_length_remaining ( tvb , offset ) ;  if ( remaining <= 0 ) { if ( data ) * data = g_strdup ( """" ) ; return offset ; } text = tvb_get_string_enc ( NULL , tvb , offset , remaining , ENC_UTF_16 | ENC_LITTLE_ENDIAN ) ; len = ( int ) strlen ( text ) ; proto_tree_add_string ( tree , hf_name , tvb , offset , len * 2 , text ) ; if ( data ) * data = text ; else g_free ( text ) ; return offset + ( len + 1 ) * 2 ; }","remaining = tvb_reported_length_remaining ( tvb , offset ) ;if ( remaining <= 0 ) {",206
300,"buggy line: if ( iov_iter_rw ( iter ) == READ )  get_block = ocfs2_get_block ;else  get_block = ocfs2_dio_get_block ;return __blockdev_direct_IO ( iocb , inode , inode -> i_sb -> s_bdev , iter , get_block , ocfs2_dio_end_io , NULL , 0 ) ;cwe id:CWE-362context: static ssize_t ocfs2_direct_IO ( struct kiocb * iocb , struct iov_iter * iter ) { struct file * file = iocb -> ki_filp ; struct inode * inode = file -> f_mapping -> host ; struct ocfs2_super * osb = OCFS2_SB ( inode -> i_sb ) ; get_block_t * get_block ; if ( OCFS2_I ( inode ) -> ip_dyn_features & OCFS2_INLINE_DATA_FL ) return 0 ; if ( iocb -> ki_pos + iter -> count > i_size_read ( inode ) && ! ocfs2_supports_append_dio ( osb ) ) return 0 ; if ( iov_iter_rw ( iter ) == READ )  get_block = ocfs2_get_block ;  else  get_block = ocfs2_dio_get_block ;  return __blockdev_direct_IO ( iocb , inode , inode -> i_sb -> s_bdev , iter , get_block , ocfs2_dio_end_io , NULL , 0 ) ; }","if ( iov_iter_rw ( iter ) == READ ) get_block = ocfs2_lock_get_block ;else get_block = ocfs2_dio_get_block ;return __blockdev_direct_IO ( iocb , inode , inode -> i_sb -> s_bdev , iter , get_block , ocfs2_dio_end_io , NULL , 0 ) ;",207
301,"buggy line: msg -> msg_namelen = 0 ;copied = skb -> len ;cwe id:CWE-20context: static int rawsock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { int noblock = flags & MSG_DONTWAIT ; struct sock * sk = sock -> sk ; struct sk_buff * skb ; int copied ; int rc ; pr_debug ( ""sock=%p<S2SV_blank>sk=%p<S2SV_blank>len=%zu<S2SV_blank>flags=%d\\n"" , sock , sk , len , flags ) ; skb = skb_recv_datagram ( sk , flags , noblock , & rc ) ; if ( ! skb ) return rc ;  msg -> msg_namelen = 0 ;  copied = skb -> len ; if ( len < copied ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } rc = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; skb_free_datagram ( sk , skb ) ; return rc ? : copied ; }",copied = skb -> len ;,208
302,"buggy line: if ( fscanf ( f , ""%79s<S2SV_blank>%[^\\\cwe id:CWE-120context: void M_LoadDefaults ( void ) { int i ; int len ; FILE * f ; char def [ 80 ] ; char strparm [ 100 ] ; char * newstring ; int parm ; boolean isstring ; numdefaults = sizeof ( defaults ) / sizeof ( defaults [ 0 ] ) ; for ( i = 0 ; i < numdefaults ; i ++ ) * defaults [ i ] . location = defaults [ i ] . defaultvalue ; i = M_CheckParm ( ""-config"" ) ; if ( i && i < myargc - 1 ) { defaultfile = myargv [ i + 1 ] ; printf ( ""\tdefault<S2SV_blank>file:<S2SV_blank>%s\\n"" , defaultfile ) ; } else defaultfile = basedefault ; f = fopen ( defaultfile , ""r"" ) ; if ( f ) { while ( ! feof ( f ) ) { isstring = false ;  if ( fscanf ( f , ""%79s<S2SV_blank>%[^\\n]\\n"" , def , strparm ) == 2 )  { if ( strparm [ 0 ] == \'""\' ) { isstring = true ; len = strlen ( strparm ) ; newstring = ( char * ) malloc ( len ) ; strparm [ len - 1 ] = 0 ; strcpy ( newstring , strparm + 1 ) ; } else if ( strparm [ 0 ] == '0' && strparm [ 1 ] == 'x' ) sscanf ( strparm + 2 , ""%x"" , & parm ) ; else sscanf ( strparm , ""%i"" , & parm ) ; for ( i = 0 ; i < numdefaults ; i ++ ) if ( ! strcmp ( def , defaults [ i ] . name ) ) { if ( ! isstring ) * defaults [ i ] . location = parm ; else * defaults [ i ] . location = ( int ) newstring ; break ; } } } fclose ( f ) ; } for ( i = 0 ; i < numdefaults ; i ++ ) { if ( defaults [ i ] . scantranslate ) { parm = * defaults [ i ] . location ; defaults [ i ] . untranslated = parm ; * defaults [ i ] . location = scantokey [ parm ] ; } } }","if ( fscanf ( f , ""%79s<S2SV_blank>%99[^\\\",209
303,"buggy line: if ( cpuhw -> n_limited ) freeze_limited_counters ( cpuhw , mfspr ( SPRN_PMC5 ) , mfspr ( SPRN_PMC6 ) ) ;perf_read_regs ( regs ) ;nmi = perf_intr_is_nmi ( regs ) ;if ( nmi ) nmi_enter ( ) ;else irq_enter ( ) ;for ( i = 0 ;i < cpuhw -> n_events ;++ i ) {event = cpuhw -> event [ i ] ;if ( ! event -> hw . idx || is_limited_pmc ( event -> hw . idx ) ) continue ;val = read_pmc ( event -> hw . idx ) ;if ( ( int ) val < 0 ) {found = 1 ;record_and_restart ( event , val , regs , nmi ) ;}}if ( ! found ) {for ( i = 0 ;i < ppmu -> n_counter ;++ i ) {if ( is_limited_pmc ( i + 1 ) ) continue ;val = read_pmc ( i + 1 ) ;if ( ( int ) val < 0 )  write_pmc ( i + 1 , 0 ) ;cwe id:CWE-189context: static void perf_event_interrupt ( struct pt_regs * regs ) { int i ; struct cpu_hw_events * cpuhw = & __get_cpu_var ( cpu_hw_events ) ; struct perf_event * event ; unsigned long val ; int found = 0 ; int nmi ; if ( cpuhw -> n_limited ) freeze_limited_counters ( cpuhw , mfspr ( SPRN_PMC5 ) , mfspr ( SPRN_PMC6 ) ) ; perf_read_regs ( regs ) ; nmi = perf_intr_is_nmi ( regs ) ; if ( nmi ) nmi_enter ( ) ; else irq_enter ( ) ; for ( i = 0 ; i < cpuhw -> n_events ; ++ i ) { event = cpuhw -> event [ i ] ; if ( ! event -> hw . idx || is_limited_pmc ( event -> hw . idx ) ) continue ; val = read_pmc ( event -> hw . idx ) ; if ( ( int ) val < 0 ) { found = 1 ; record_and_restart ( event , val , regs , nmi ) ; } } if ( ! found ) { for ( i = 0 ; i < ppmu -> n_counter ; ++ i ) { if ( is_limited_pmc ( i + 1 ) ) continue ; val = read_pmc ( i + 1 ) ;  if ( ( int ) val < 0 )  write_pmc ( i + 1 , 0 ) ; } } write_mmcr0 ( cpuhw , cpuhw -> mmcr [ 0 ] ) ; if ( nmi ) nmi_exit ( ) ; else irq_exit ( ) ; }","+ i ) {+ i ) {if ( pmc_overflow ( val ) ) write_pmc ( i + 1 , 0 ) ;",210
304,"buggy line: else len = get_line_size ( * b , * avail , nl ) ;cwe id:CWE-125context: static ssize_t next_line ( struct archive_read * a , const char * * b , ssize_t * avail , ssize_t * ravail , ssize_t * nl ) { ssize_t len ; int quit ; quit = 0 ; if ( * avail == 0 ) { * nl = 0 ; len = 0 ; } else len = get_line_size ( * b , * avail , nl ) ; while ( * nl == 0 && len == * avail && ! quit ) { ssize_t diff = * ravail - * avail ; size_t nbytes_req = ( * ravail + 1023 ) & ~ 1023U ; ssize_t tested ; if ( nbytes_req < ( size_t ) * ravail + 160 ) nbytes_req <<= 1 ; * b = __archive_read_ahead ( a , nbytes_req , avail ) ; if ( * b == NULL ) { if ( * ravail >= * avail ) return ( 0 ) ; * b = __archive_read_ahead ( a , * avail , avail ) ; quit = 1 ; } * ravail = * avail ; * b += diff ; * avail -= diff ; tested = len ;  len = get_line_size ( * b , * avail , nl ) ;  if ( len >= 0 ) len += tested ; } return ( len ) ; }","else len = get_line_size ( * b + len , * avail - len , nl ) ;",211
305,"buggy line: len = get_line_size ( * b , * avail , nl ) ;if ( len >= 0 ) len += tested ;cwe id:CWE-125context: static ssize_t next_line ( struct archive_read * a , const char * * b , ssize_t * avail , ssize_t * ravail , ssize_t * nl ) { ssize_t len ; int quit ; quit = 0 ; if ( * avail == 0 ) { * nl = 0 ; len = 0 ; } else len = get_line_size ( * b , * avail , nl ) ; while ( * nl == 0 && len == * avail && ! quit ) { ssize_t diff = * ravail - * avail ; size_t nbytes_req = ( * ravail + 1023 ) & ~ 1023U ; ssize_t tested ; if ( nbytes_req < ( size_t ) * ravail + 160 ) nbytes_req <<= 1 ; * b = __archive_read_ahead ( a , nbytes_req , avail ) ; if ( * b == NULL ) { if ( * ravail >= * avail ) return ( 0 ) ; * b = __archive_read_ahead ( a , * avail , avail ) ; quit = 1 ; } * ravail = * avail ; * b += diff ; * avail -= diff ; tested = len ;  len = get_line_size ( * b , * avail , nl ) ;  if ( len >= 0 ) len += tested ; } return ( len ) ; }","len = get_line_size ( * b , * avail , nl ) ;if ( len >= 0 ) len += tested ;",211
306,"buggy line: int all_whitespace = 1 ;int kind ;void * data ;mod_ty mod ;char * str ;PyObject * o , * fstring_name ;Py_ssize_t len ;o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ;if ( o == NULL ) return NULL ;len = PyUnicode_GET_LENGTH ( o ) ;kind = PyUnicode_KIND ( o ) ;data = PyUnicode_DATA ( o ) ;for ( i = 0 ;i < len ;i ++ ) {if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) {all_whitespace = 0 ;Py_DECREF ( o ) ;if ( all_whitespace ) {if ( str == NULL )  return NULL ;str [ 0 ] = \'(\' ;fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ;mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ;PyMem_RawFree ( str ) ;if ( ! mod ) return NULL ;cwe id:CWE-125context: static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) {  int all_whitespace = 1 ;  int kind ; void * data ; PyCompilerFlags cf ;  mod_ty mod ;  char * str ;  PyObject * o , * fstring_name ;  Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ;  o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ;  if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string:<S2SV_blank>empty<S2SV_blank>expression<S2SV_blank>not<S2SV_blank>allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL )  return NULL ;  str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ;  fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ;  mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ;  PyMem_RawFree ( str ) ;  if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }","node * mod_n ;mod_ty mod ;char * str ;PyObject * o , * fstring_name ;Py_ssize_t len ;for ( s = expr_start ;s != expr_end ;s ++ ) {char c = * s ;if ( ! ( c == \'<S2SV_blank>\' || c == \'\\\\t\' || c == \'\\\if ( s == expr_end ) {if ( str == NULL ) return NULL ;str [ 0 ] = \'(\' ;mod_n = PyParser_SimpleParseStringFlagsFilename ( str , ""<fstring>"" , Py_eval_input , 0 ) ;if ( ! mod_n ) {PyMem_RawFree ( str ) ;Ta3Node_Free ( mod_n ) ;return NULL ;}str [ 0 ] = \'{\' ;str [ len + 1 ] = \'}\' ;fstring_fix_node_location ( n , mod_n , str ) ;fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ;mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ;PyMem_RawFree ( str ) ;if ( ! mod ) return NULL ;",212
307,"buggy line: void ntlm_print_message_fields ( NTLM_MESSAGE_FIELDS * fields , const char * name )  {cwe id:CWE-125context:  void ntlm_print_message_fields ( NTLM_MESSAGE_FIELDS * fields , const char * name )  { WLog_DBG ( TAG , ""%s<S2SV_blank>(Len:<S2SV_blank>%"" PRIu16 ""<S2SV_blank>MaxLen:<S2SV_blank>%"" PRIu16 ""<S2SV_blank>BufferOffset:<S2SV_blank>%"" PRIu32 "")"" , name , fields -> Len , fields -> MaxLen , fields -> BufferOffset ) ; if ( fields -> Len > 0 ) winpr_HexDump ( TAG , WLOG_DEBUG , fields -> Buffer , fields -> Len ) ; }","static void ntlm_print_message_fields ( NTLM_MESSAGE_FIELDS * fields , const char * name ) {",213
308,"buggy line: cJSON * c = object -> child ;while ( c && cJSON_strcasecmp ( c -> string , string ) ) c = c -> next ;cwe id:CWE-119context: cJSON * cJSON_GetObjectItem ( cJSON * object , const char * string ) {  cJSON * c = object -> child ;  while ( c && cJSON_strcasecmp ( c -> string , string ) ) c = c -> next ; return c ; }","cJSON * c = object ? object -> child : 0 ;while ( c && cJSON_strcasecmp ( c -> string , string ) ) c = c -> next ;",214
309,"buggy line: if ( ret == 0 )  clear_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ;up_write ( & key -> sem ) ;cwe id:CWE-20context: static inline key_ref_t __key_update ( key_ref_t key_ref , struct key_preparsed_payload * prep ) { struct key * key = key_ref_to_ptr ( key_ref ) ; int ret ; ret = key_permission ( key_ref , KEY_NEED_WRITE ) ; if ( ret < 0 ) goto error ; ret = - EEXIST ; if ( ! key -> type -> update ) goto error ; down_write ( & key -> sem ) ; ret = key -> type -> update ( key , prep ) ; if ( ret == 0 )  clear_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ;  up_write ( & key -> sem ) ; if ( ret < 0 ) goto error ; out : return key_ref ; error : key_put ( key ) ; key_ref = ERR_PTR ( ret ) ; goto out ; }","if ( ret == 0 ) mark_key_instantiated ( key , 0 ) ;up_write ( & key -> sem ) ;",215
310,"buggy line: if ( ! ( plen <= * len ) ) printf ( ""PLEN<S2SV_blank>%d<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>len<S2SV_blank>%d\\\assert ( plen <= * len ) ;* len = plen ;cwe id:CWE-20context: int net_get ( int s , void * arg , int * len ) { struct net_hdr nh ; int plen ; if ( net_read_exact ( s , & nh , sizeof ( nh ) ) == - 1 ) { return - 1 ; } plen = ntohl ( nh . nh_len ) ; if ( ! ( plen <= * len ) ) printf ( ""PLEN<S2SV_blank>%d<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>len<S2SV_blank>%d\\n"" , plen , nh . nh_type , * len ) ;  assert ( plen <= * len ) ;  * len = plen ; if ( ( * len ) && ( net_read_exact ( s , arg , * len ) == - 1 ) ) { return - 1 ; } return nh . nh_type ; }","if ( ! ( plen <= * len && plen > 0 ) ) printf ( ""PLEN<S2SV_blank>%d<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>len<S2SV_blank>%d\\\assert ( plen <= * len ) ;* len = plen ;",216
311,"buggy line: args . value = kmem_alloc ( valuelen , KM_SLEEP | KM_NOFS ) ;args . rmtblkno = be32_to_cpu ( name_rmt -> valueblk ) ;cwe id:CWE-19context: int xfs_attr3_leaf_list_int ( struct xfs_buf * bp , struct xfs_attr_list_context * context ) { struct attrlist_cursor_kern * cursor ; struct xfs_attr_leafblock * leaf ; struct xfs_attr3_icleaf_hdr ichdr ; struct xfs_attr_leaf_entry * entries ; struct xfs_attr_leaf_entry * entry ; int retval ; int i ; trace_xfs_attr_list_leaf ( context ) ; leaf = bp -> b_addr ; xfs_attr3_leaf_hdr_from_disk ( & ichdr , leaf ) ; entries = xfs_attr3_leaf_entryp ( leaf ) ; cursor = context -> cursor ; cursor -> initted = 1 ; if ( context -> resynch ) { entry = & entries [ 0 ] ; for ( i = 0 ; i < ichdr . count ; entry ++ , i ++ ) { if ( be32_to_cpu ( entry -> hashval ) == cursor -> hashval ) { if ( cursor -> offset == context -> dupcnt ) { context -> dupcnt = 0 ; break ; } context -> dupcnt ++ ; } else if ( be32_to_cpu ( entry -> hashval ) > cursor -> hashval ) { context -> dupcnt = 0 ; break ; } } if ( i == ichdr . count ) { trace_xfs_attr_list_notfound ( context ) ; return 0 ; } } else { entry = & entries [ 0 ] ; i = 0 ; } context -> resynch = 0 ; retval = 0 ; for ( ; i < ichdr . count ; entry ++ , i ++ ) { if ( be32_to_cpu ( entry -> hashval ) != cursor -> hashval ) { cursor -> hashval = be32_to_cpu ( entry -> hashval ) ; cursor -> offset = 0 ; } if ( entry -> flags & XFS_ATTR_INCOMPLETE ) continue ; if ( entry -> flags & XFS_ATTR_LOCAL ) { xfs_attr_leaf_name_local_t * name_loc = xfs_attr3_leaf_name_local ( leaf , i ) ; retval = context -> put_listent ( context , entry -> flags , name_loc -> nameval , ( int ) name_loc -> namelen , be16_to_cpu ( name_loc -> valuelen ) , & name_loc -> nameval [ name_loc -> namelen ] ) ; if ( retval ) return retval ; } else { xfs_attr_leaf_name_remote_t * name_rmt = xfs_attr3_leaf_name_remote ( leaf , i ) ; int valuelen = be32_to_cpu ( name_rmt -> valuelen ) ; if ( context -> put_value ) { xfs_da_args_t args ; memset ( ( char * ) & args , 0 , sizeof ( args ) ) ; args . dp = context -> dp ; args . whichfork = XFS_ATTR_FORK ; args . valuelen = valuelen ;  args . value = kmem_alloc ( valuelen , KM_SLEEP | KM_NOFS ) ;  args . rmtblkno = be32_to_cpu ( name_rmt -> valueblk ) ; args . rmtblkcnt = xfs_attr3_rmt_blocks ( args . dp -> i_mount , valuelen ) ; retval = xfs_attr_rmtval_get ( & args ) ; if ( retval ) return retval ; retval = context -> put_listent ( context , entry -> flags , name_rmt -> name , ( int ) name_rmt -> namelen , valuelen , args . value ) ; kmem_free ( args . value ) ; } else { retval = context -> put_listent ( context , entry -> flags , name_rmt -> name , ( int ) name_rmt -> namelen , valuelen , NULL ) ; } if ( retval ) return retval ; } if ( context -> seen_enough ) break ; cursor -> offset ++ ; } trace_xfs_attr_list_leaf_end ( context ) ; return retval ; }","args . rmtvaluelen = valuelen ;args . value = kmem_alloc ( valuelen , KM_SLEEP | KM_NOFS ) ;args . rmtblkno = be32_to_cpu ( name_rmt -> valueblk ) ;",217
312,"buggy line: if ( flags & MSG_CMSG_COMPAT ) return - EINVAL ;if ( COMPAT_USE_64BIT_TIME )  return __sys_recvmmsg ( fd , ( struct mmsghdr __user * ) mmsg , vlen , flags | MSG_CMSG_COMPAT , ( struct timespec * ) timeout ) ;if ( get_compat_timespec ( & ktspec , timeout ) )  return - EFAULT ;if ( datagrams > 0 && put_compat_timespec ( & ktspec , timeout ) )  datagrams = - EFAULT ;cwe id:CWE-20context: asmlinkage long compat_sys_recvmmsg ( int fd , struct compat_mmsghdr __user * mmsg , unsigned int vlen , unsigned int flags , struct compat_timespec __user * timeout ) { int datagrams ; struct timespec ktspec ; if ( flags & MSG_CMSG_COMPAT ) return - EINVAL ;  if ( COMPAT_USE_64BIT_TIME )  return __sys_recvmmsg ( fd , ( struct mmsghdr __user * ) mmsg , vlen , flags | MSG_CMSG_COMPAT , ( struct timespec * ) timeout ) ; if ( timeout == NULL ) return __sys_recvmmsg ( fd , ( struct mmsghdr __user * ) mmsg , vlen , flags | MSG_CMSG_COMPAT , NULL ) ;  if ( get_compat_timespec ( & ktspec , timeout ) )  return - EFAULT ; datagrams = __sys_recvmmsg ( fd , ( struct mmsghdr __user * ) mmsg , vlen , flags | MSG_CMSG_COMPAT , & ktspec ) ;  if ( datagrams > 0 && put_compat_timespec ( & ktspec , timeout ) )  datagrams = - EFAULT ; return datagrams ; }","if ( get_compat_timespec ( & ktspec , timeout ) ) return - EFAULT ;if ( compat_get_timespec ( & ktspec , timeout ) ) datagrams = - EFAULT ;",218
313,"buggy line: image -> columns = sun_info . width ;image -> rows = sun_info . height ;image -> depth = sun_info . depth <= 8 ? sun_info . depth : MAGICKCORE_QUANTUM_DEPTH ;if ( sun_info . depth < 24 ) {size_t one ;image -> storage_class = PseudoClass ;image -> colors = sun_info . maplength ;}switch ( sun_info . maptype ) {case RMT_NONE :  {if ( sun_info . depth < 24 ) {break ;}unsigned char  * sun_colormap ;if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;cwe id:CWE-119context: static Image * ReadSUNImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define RMT_EQUAL_RGB 1 # define RMT_NONE 0 # define RMT_RAW 2 # define RT_STANDARD 1 # define RT_ENCODED 2 # define RT_FORMAT_RGB 3 typedef struct _SUNInfo { unsigned int magic , width , height , depth , length , type , maptype , maplength ; } SUNInfo ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bytes_per_line , extent , length ; ssize_t count , y ; SUNInfo sun_info ; unsigned char * sun_data , * sun_pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & sun_info , 0 , sizeof ( sun_info ) ) ; sun_info . magic = ReadBlobMSBLong ( image ) ; do { if ( sun_info . magic != 0x59a66a95 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; sun_info . width = ReadBlobMSBLong ( image ) ; sun_info . height = ReadBlobMSBLong ( image ) ; sun_info . depth = ReadBlobMSBLong ( image ) ; sun_info . length = ReadBlobMSBLong ( image ) ; sun_info . type = ReadBlobMSBLong ( image ) ; sun_info . maptype = ReadBlobMSBLong ( image ) ; sun_info . maplength = ReadBlobMSBLong ( image ) ; extent = sun_info . height * sun_info . width ; if ( ( sun_info . height != 0 ) && ( sun_info . width != extent / sun_info . height ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . type != RT_STANDARD ) && ( sun_info . type != RT_ENCODED ) && ( sun_info . type != RT_FORMAT_RGB ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype == RMT_NONE ) && ( sun_info . maplength != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . depth == 0 ) || ( sun_info . depth > 32 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype != RMT_NONE ) && ( sun_info . maptype != RMT_EQUAL_RGB ) && ( sun_info . maptype != RMT_RAW ) ) ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; image -> depth = sun_info . depth <= 8 ? sun_info . depth : MAGICKCORE_QUANTUM_DEPTH ; if ( sun_info . depth < 24 ) { size_t one ;  image -> storage_class = PseudoClass ;  image -> colors = sun_info . maplength ; one = 1 ; if ( sun_info . maptype == RMT_NONE ) image -> colors = one << sun_info . depth ; if ( sun_info . maptype == RMT_EQUAL_RGB ) image -> colors = sun_info . maplength / 3 ;  }  switch ( sun_info . maptype ) {  case RMT_NONE :  { if ( sun_info . depth < 24 ) { if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } break ; } case RMT_EQUAL_RGB : { unsigned char  * sun_colormap ;  if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } case RMT_RAW : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( sun_info . maplength , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , sun_info . maplength , sun_colormap ) ; if ( count != ( ssize_t ) sun_info . maplength ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; } image -> alpha_trait = sun_info . depth == 32 ? BlendPixelTrait : UndefinedPixelTrait ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( ( sun_info . length * sizeof ( * sun_data ) ) / sizeof ( * sun_data ) != sun_info . length || ! sun_info . length ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; if ( ( sun_info . type != RT_ENCODED ) && ( sun_info . depth >= 8 ) && ( ( number_pixels * ( ( sun_info . depth + 7 ) / 8 ) ) > sun_info . length ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; bytes_per_line = sun_info . width * sun_info . depth ; sun_data = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( sun_info . length , bytes_per_line * sun_info . width ) , sizeof ( * sun_data ) ) ; if ( sun_data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ( ssize_t ) ReadBlob ( image , sun_info . length , sun_data ) ; if ( count != ( ssize_t ) sun_info . length ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; sun_pixels = sun_data ; bytes_per_line = 0 ; if ( sun_info . type == RT_ENCODED ) { size_t height ; height = sun_info . height ; if ( ( height == 0 ) || ( sun_info . width == 0 ) || ( sun_info . depth == 0 ) || ( ( bytes_per_line / sun_info . depth ) != sun_info . width ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; bytes_per_line += 15 ; bytes_per_line <<= 1 ; if ( ( bytes_per_line >> 1 ) != ( sun_info . width * sun_info . depth + 15 ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; bytes_per_line >>= 4 ; sun_pixels = ( unsigned char * ) AcquireQuantumMemory ( height , bytes_per_line * sizeof ( * sun_pixels ) ) ; if ( sun_pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line * height ) ; sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ; } p = sun_pixels ; if ( sun_info . depth == 1 ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 7 ; bit >= 0 ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 7 ; bit >= ( int ) ( 8 - ( image -> columns % 8 ) ) ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( ( ( image -> columns / 8 ) + ( image -> columns % 8 ? 1 : 0 ) ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } else if ( image -> storage_class == PseudoClass ) { if ( bytes_per_line == 0 ) bytes_per_line = image -> columns ; length = image -> rows * ( image -> columns + image -> columns % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( ( image -> columns % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { size_t bytes_per_pixel ; bytes_per_pixel = 3 ; if ( image -> alpha_trait != UndefinedPixelTrait ) bytes_per_pixel ++ ; if ( bytes_per_line == 0 ) bytes_per_line = bytes_per_pixel * image -> columns ; length = image -> rows * ( bytes_per_line + image -> columns % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( sun_info . type == RT_STANDARD ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } else { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } if ( image -> colors != 0 ) { SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelRed ( image , q ) ] . red ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelGreen ( image , q ) ] . green ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelBlue ( image , q ) ] . blue ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( ( ( bytes_per_pixel * image -> columns ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image , exception ) ; sun_pixels = ( unsigned char * ) RelinquishMagickMemory ( sun_pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; sun_info . magic = ReadBlobMSBLong ( image ) ; if ( sun_info . magic == 0x59a66a95 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( sun_info . magic == 0x59a66a95 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","image -> colors = sun_info . maplength ;switch ( sun_info . maptype ) {unsigned char * sun_colormap ;if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;",219
314,"buggy line: int ret ;assert ( skb -> queue_mapping < ndev -> ae_handle -> q_num ) ;ret = hns_nic_net_xmit_hw ( ndev , skb ,  & tx_ring_data ( priv , skb -> queue_mapping ) ) ;if ( ret == NETDEV_TX_OK ) {netif_trans_update ( ndev ) ;ndev -> stats . tx_bytes += skb -> len ;ndev -> stats . tx_packets ++ ;}return ( netdev_tx_t ) ret ;cwe id:CWE-416context: static netdev_tx_t hns_nic_net_xmit ( struct sk_buff * skb , struct net_device * ndev ) { struct hns_nic_priv * priv = netdev_priv ( ndev ) ;  int ret ;  assert ( skb -> queue_mapping < ndev -> ae_handle -> q_num ) ;  ret = hns_nic_net_xmit_hw ( ndev , skb ,  & tx_ring_data ( priv , skb -> queue_mapping ) ) ;  if ( ret == NETDEV_TX_OK ) {  netif_trans_update ( ndev ) ; ndev -> stats . tx_bytes += skb -> len ; ndev -> stats . tx_packets ++ ; } return ( netdev_tx_t ) ret ; }","assert ( skb -> queue_mapping < ndev -> ae_handle -> q_num ) ;return hns_nic_net_xmit_hw ( ndev , skb , & tx_ring_data ( priv , skb -> queue_mapping ) ) ;",220
315,"buggy line: msg -> msg_namelen = 0 ;lock_sock ( sk ) ;cwe id:CWE-20context: static int hash_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct hash_ctx * ctx = ask -> private ; unsigned ds = crypto_ahash_digestsize ( crypto_ahash_reqtfm ( & ctx -> req ) ) ; int err ; if ( len > ds ) len = ds ; else if ( len < ds ) msg -> msg_flags |= MSG_TRUNC ;  msg -> msg_namelen = 0 ;  lock_sock ( sk ) ; if ( ctx -> more ) { ctx -> more = 0 ; ahash_request_set_crypt ( & ctx -> req , NULL , ctx -> result , 0 ) ; err = af_alg_wait_for_completion ( crypto_ahash_final ( & ctx -> req ) , & ctx -> completion ) ; if ( err ) goto unlock ; } err = memcpy_toiovec ( msg -> msg_iov , ctx -> result , len ) ; unlock : release_sock ( sk ) ; return err ? : len ; }",lock_sock ( sk ) ;,221
316,"buggy line: if ( settings . num_threads > 64 ) {fprintf ( stderr , ""WARNING:<S2SV_blank>Setting<S2SV_blank>a<S2SV_blank>high<S2SV_blank>number<S2SV_blank>of<S2SV_blank>worker"" ""threads<S2SV_blank>is<S2SV_blank>not<S2SV_blank>recommended.\\\}break ;case \'D\' : if ( ! optarg || ! optarg [ 0 ] ) {fprintf ( stderr , ""No<S2SV_blank>delimiter<S2SV_blank>specified\\\return 1 ;}settings . prefix_delimiter = optarg [ 0 ] ;settings . detail_enabled = 1 ;break ;case \'L\' : if ( enable_large_pages ( ) == 0 ) {preallocate = true ;}else {fprintf ( stderr , ""Cannot<S2SV_blank>enable<S2SV_blank>large<S2SV_blank>pages<S2SV_blank>on<S2SV_blank>this<S2SV_blank>system\\\return 1 ;}break ;case \'C\' : settings . use_cas = false ;break ;case \'b\' : settings . backlog = atoi ( optarg ) ;break ;case \'B\' : protocol_specified = true ;if ( strcmp ( optarg , ""auto"" ) == 0 ) {settings . binding_protocol = negotiating_prot ;}else if ( strcmp ( optarg , ""binary"" ) == 0 ) {settings . binding_protocol = binary_prot ;}else if ( strcmp ( optarg , ""ascii"" ) == 0 ) {settings . binding_protocol = ascii_prot ;}else {fprintf ( stderr , ""Invalid<S2SV_blank>value<S2SV_blank>for<S2SV_blank>binding<S2SV_blank>protocol:<S2SV_blank>%s\\\exit ( EX_USAGE ) ;}break ;case \'I\' : buf = strdup ( optarg ) ;unit = buf [ strlen ( buf ) - 1 ] ;if ( unit == \'k\' || unit == \'m\' || unit == \'K\' || unit == \'M\' ) {buf [ strlen ( buf ) - 1 ] = \'\\\\0\' ;size_max = atoi ( buf ) ;if ( unit == \'k\' || unit == \'K\' ) size_max *= 1024 ;if ( unit == \'m\' || unit == \'M\' ) size_max *= 1024 * 1024 ;settings . item_size_max = size_max ;}else {settings . item_size_max = atoi ( buf ) ;}free ( buf ) ;break ;case \'S\' : # ifndef ENABLE_SASL fprintf ( stderr , ""This<S2SV_blank>server<S2SV_blank>is<S2SV_blank>not<S2SV_blank>built<S2SV_blank>with<S2SV_blank>SASL<S2SV_blank>support.\\\exit ( EX_USAGE ) ;# endif settings . sasl = true ;break ;case \'F\' : settings . flush_enabled = false ;break ;case \'X\' : settings . dump_enabled = false ;break ;case \'o\' : subopts_orig = subopts = strdup ( optarg ) ;while ( * subopts != \'\\\\0\' ) {switch ( getsubopt ( & subopts , subopts_tokens , & subopts_value ) ) {case MAXCONNS_FAST : settings . maxconns_fast = true ;break ;case HASHPOWER_INIT : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>numeric<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>hashpower\\\return 1 ;}settings . hashpower_init = atoi ( subopts_value ) ;if ( settings . hashpower_init < 12 ) {fprintf ( stderr , ""Initial<S2SV_blank>hashtable<S2SV_blank>multiplier<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>low\\\return 1 ;}else if ( settings . hashpower_init > 32 ) {fprintf ( stderr , ""Initial<S2SV_blank>hashtable<S2SV_blank>multiplier<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>high\\\return 1 ;}break ;case NO_HASHEXPAND : start_assoc_maint = false ;break ;case SLAB_REASSIGN : settings . slab_reassign = true ;break ;case SLAB_AUTOMOVE : if ( subopts_value == NULL ) {settings . slab_automove = 1 ;break ;}settings . slab_automove = atoi ( subopts_value ) ;if ( settings . slab_automove < 0 || settings . slab_automove > 2 ) {fprintf ( stderr , ""slab_automove<S2SV_blank>must<S2SV_blank>be<S2SV_blank>between<S2SV_blank>0<S2SV_blank>and<S2SV_blank>2\\\return 1 ;}break ;case SLAB_AUTOMOVE_RATIO : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>slab_automove_ratio<S2SV_blank>argument\\\return 1 ;}settings . slab_automove_ratio = atof ( subopts_value ) ;if ( settings . slab_automove_ratio <= 0 || settings . slab_automove_ratio > 1 ) {fprintf ( stderr , ""slab_automove_ratio<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0<S2SV_blank>and<S2SV_blank><<S2SV_blank>1\\\return 1 ;}break ;case SLAB_AUTOMOVE_WINDOW : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>slab_automove_window<S2SV_blank>argument\\\return 1 ;}settings . slab_automove_window = atoi ( subopts_value ) ;if ( settings . slab_automove_window < 3 ) {fprintf ( stderr , ""slab_automove_window<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>2\\\return 1 ;}break ;case TAIL_REPAIR_TIME : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>numeric<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>tail_repair_time\\\return 1 ;}settings . tail_repair_time = atoi ( subopts_value ) ;if ( settings . tail_repair_time < 10 ) {fprintf ( stderr , ""Cannot<S2SV_blank>set<S2SV_blank>tail_repair_time<S2SV_blank>to<S2SV_blank>less<S2SV_blank>than<S2SV_blank>10<S2SV_blank>seconds\\\return 1 ;}break ;case HASH_ALGORITHM : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>hash_algorithm<S2SV_blank>argument\\\return 1 ;};if ( strcmp ( subopts_value , ""jenkins"" ) == 0 ) {hash_type = JENKINS_HASH ;}else if ( strcmp ( subopts_value , ""murmur3"" ) == 0 ) {hash_type = MURMUR3_HASH ;}else {fprintf ( stderr , ""Unknown<S2SV_blank>hash_algorithm<S2SV_blank>option<S2SV_blank>(jenkins,<S2SV_blank>murmur3)\\\return 1 ;}break ;case LRU_CRAWLER : start_lru_crawler = true ;break ;case LRU_CRAWLER_SLEEP : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>lru_crawler_sleep<S2SV_blank>value\\\return 1 ;}settings . lru_crawler_sleep = atoi ( subopts_value ) ;if ( settings . lru_crawler_sleep > 1000000 || settings . lru_crawler_sleep < 0 ) {fprintf ( stderr , ""LRU<S2SV_blank>crawler<S2SV_blank>sleep<S2SV_blank>must<S2SV_blank>be<S2SV_blank>between<S2SV_blank>0<S2SV_blank>and<S2SV_blank>1<S2SV_blank>second\\\return 1 ;}break ;case LRU_CRAWLER_TOCRAWL : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>lru_crawler_tocrawl<S2SV_blank>value\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & tocrawl ) ) {fprintf ( stderr , ""lru_crawler_tocrawl<S2SV_blank>takes<S2SV_blank>a<S2SV_blank>numeric<S2SV_blank>32bit<S2SV_blank>value\\\return 1 ;}settings . lru_crawler_tocrawl = tocrawl ;break ;case LRU_MAINTAINER : start_lru_maintainer = true ;settings . lru_segmented = true ;break ;case HOT_LRU_PCT : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>hot_lru_pct<S2SV_blank>argument\\\return 1 ;}settings . hot_lru_pct = atoi ( subopts_value ) ;if ( settings . hot_lru_pct < 1 || settings . hot_lru_pct >= 80 ) {fprintf ( stderr , ""hot_lru_pct<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>1<S2SV_blank>and<S2SV_blank><<S2SV_blank>80\\\return 1 ;}break ;case WARM_LRU_PCT : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>warm_lru_pct<S2SV_blank>argument\\\return 1 ;}settings . warm_lru_pct = atoi ( subopts_value ) ;if ( settings . warm_lru_pct < 1 || settings . warm_lru_pct >= 80 ) {fprintf ( stderr , ""warm_lru_pct<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>1<S2SV_blank>and<S2SV_blank><<S2SV_blank>80\\\return 1 ;}break ;case HOT_MAX_FACTOR : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>hot_max_factor<S2SV_blank>argument\\\return 1 ;}settings . hot_max_factor = atof ( subopts_value ) ;if ( settings . hot_max_factor <= 0 ) {fprintf ( stderr , ""hot_max_factor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0\\\return 1 ;}break ;case WARM_MAX_FACTOR : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>warm_max_factor<S2SV_blank>argument\\\return 1 ;}settings . warm_max_factor = atof ( subopts_value ) ;if ( settings . warm_max_factor <= 0 ) {fprintf ( stderr , ""warm_max_factor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0\\\return 1 ;}break ;case TEMPORARY_TTL : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>temporary_ttl<S2SV_blank>argument\\\return 1 ;}settings . temp_lru = true ;settings . temporary_ttl = atoi ( subopts_value ) ;break ;case IDLE_TIMEOUT : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>numeric<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>idle_timeout\\\return 1 ;}settings . idle_timeout = atoi ( subopts_value ) ;break ;case WATCHER_LOGBUF_SIZE : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>watcher_logbuf_size<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & settings . logger_watcher_buf_size ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>watcher_logbuf_size\\\return 1 ;}settings . logger_watcher_buf_size *= 1024 ;break ;case WORKER_LOGBUF_SIZE : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>worker_logbuf_size<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & settings . logger_buf_size ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>worker_logbuf_size\\\return 1 ;}settings . logger_buf_size *= 1024 ;case SLAB_SIZES : slab_sizes_unparsed = subopts_value ;break ;case SLAB_CHUNK_MAX : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>slab_chunk_max<S2SV_blank>argument\\\}if ( ! safe_strtol ( subopts_value , & settings . slab_chunk_size_max ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>slab_chunk_max\\\}slab_chunk_size_changed = true ;break ;case TRACK_SIZES : item_stats_sizes_init ( ) ;break ;case NO_INLINE_ASCII_RESP : settings . inline_ascii_response = false ;break ;case INLINE_ASCII_RESP : settings . inline_ascii_response = true ;break ;case NO_CHUNKED_ITEMS : settings . slab_chunk_size_max = settings . slab_page_size ;break ;case NO_SLAB_REASSIGN : settings . slab_reassign = false ;break ;case NO_SLAB_AUTOMOVE : settings . slab_automove = 0 ;break ;case NO_MAXCONNS_FAST : settings . maxconns_fast = false ;break ;case NO_LRU_CRAWLER : settings . lru_crawler = false ;start_lru_crawler = false ;break ;case NO_LRU_MAINTAINER : start_lru_maintainer = false ;settings . lru_segmented = false ;break ;# ifdef EXTSTORE case EXT_PAGE_SIZE : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_page_size<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & ext_cf . page_size ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_page_size\\\return 1 ;}ext_cf . page_size *= 1024 * 1024 ;break ;case EXT_PAGE_COUNT : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_page_count<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & ext_cf . page_count ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_page_count\\\return 1 ;}break ;case EXT_WBUF_SIZE : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_wbuf_size<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & ext_cf . wbuf_size ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_wbuf_size\\\return 1 ;}ext_cf . wbuf_size *= 1024 * 1024 ;settings . ext_wbuf_size = ext_cf . wbuf_size ;break ;case EXT_THREADS : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_threads<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & ext_cf . io_threadcount ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_threads\\\return 1 ;}break ;case EXT_IO_DEPTH : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_io_depth<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & ext_cf . io_depth ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_io_depth\\\return 1 ;}break ;case EXT_ITEM_SIZE : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_item_size<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & settings . ext_item_size ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_item_size\\\return 1 ;}break ;case EXT_ITEM_AGE : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_item_age<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & settings . ext_item_age ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_item_age\\\return 1 ;}break ;case EXT_LOW_TTL : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_low_ttl<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & settings . ext_low_ttl ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_low_ttl\\\return 1 ;}break ;case EXT_RECACHE_RATE : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_recache_rate<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & settings . ext_recache_rate ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_recache_rate\\\return 1 ;}break ;case EXT_COMPACT_UNDER : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_compact_under<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & settings . ext_compact_under ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_compact_under\\\return 1 ;}break ;case EXT_DROP_UNDER : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_drop_under<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & settings . ext_drop_under ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_drop_under\\\return 1 ;}break ;case EXT_MAX_FRAG : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_max_frag<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtod ( subopts_value , & settings . ext_max_frag ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_max_frag\\\return 1 ;}break ;case SLAB_AUTOMOVE_FREERATIO : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>slab_automove_freeratio<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtod ( subopts_value , & settings . slab_automove_freeratio ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>slab_automove_freeratio\\\return 1 ;}break ;case EXT_DROP_UNREAD : settings . ext_drop_unread = true ;break ;case EXT_PATH : storage_file = strdup ( subopts_value ) ;break ;# endif case MODERN : break ;case NO_MODERN : if ( ! slab_chunk_size_changed ) {settings . slab_chunk_size_max = settings . slab_page_size ;}settings . slab_reassign = false ;settings . slab_automove = 0 ;settings . maxconns_fast = false ;settings . inline_ascii_response = true ;settings . lru_segmented = false ;hash_type = JENKINS_HASH ;start_lru_crawler = false ;start_lru_maintainer = false ;break ;case NO_DROP_PRIVILEGES : settings . drop_privileges = false ;break ;# ifdef MEMCACHED_DEBUG case RELAXED_PRIVILEGES : settings . relaxed_privileges = true ;break ;# endif default : printf ( ""Illegal<S2SV_blank>suboption<S2SV_blank>\\\\""%s\\\\""\\\return 1 ;}}free ( subopts_orig ) ;break ;default : fprintf ( stderr , ""Illegal<S2SV_blank>argument<S2SV_blank>\\\\""%c\\\\""\\\return 1 ;}}if ( settings . item_size_max < 1024 ) {fprintf ( stderr , ""Item<S2SV_blank>max<S2SV_blank>size<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>less<S2SV_blank>than<S2SV_blank>1024<S2SV_blank>bytes.\\\exit ( EX_USAGE ) ;}if ( settings . item_size_max > ( settings . maxbytes / 2 ) ) {fprintf ( stderr , ""Cannot<S2SV_blank>set<S2SV_blank>item<S2SV_blank>size<S2SV_blank>limit<S2SV_blank>higher<S2SV_blank>than<S2SV_blank>1/2<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>max.\\\exit ( EX_USAGE ) ;}if ( settings . item_size_max > ( 1024 * 1024 * 1024 ) ) {fprintf ( stderr , ""Cannot<S2SV_blank>set<S2SV_blank>item<S2SV_blank>size<S2SV_blank>limit<S2SV_blank>higher<S2SV_blank>than<S2SV_blank>a<S2SV_blank>gigabyte.\\\exit ( EX_USAGE ) ;}if ( settings . item_size_max > 1024 * 1024 ) {if ( ! slab_chunk_size_changed ) {settings . slab_chunk_size_max = settings . slab_page_size / 2 ;}}if ( settings . slab_chunk_size_max > settings . item_size_max ) {fprintf ( stderr , ""slab_chunk_max<S2SV_blank>(bytes:<S2SV_blank>%d)<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>-I<S2SV_blank>(item_size_max<S2SV_blank>%d)\\\exit ( EX_USAGE ) ;}if ( settings . item_size_max % settings . slab_chunk_size_max != 0 ) {fprintf ( stderr , ""-I<S2SV_blank>(item_size_max:<S2SV_blank>%d)<S2SV_blank>must<S2SV_blank>be<S2SV_blank>evenly<S2SV_blank>divisible<S2SV_blank>by<S2SV_blank>slab_chunk_max<S2SV_blank>(bytes:<S2SV_blank>%d)\\\exit ( EX_USAGE ) ;}if ( settings . slab_page_size % settings . slab_chunk_size_max != 0 ) {fprintf ( stderr , ""slab_chunk_max<S2SV_blank>(bytes:<S2SV_blank>%d)<S2SV_blank>must<S2SV_blank>divide<S2SV_blank>evenly<S2SV_blank>into<S2SV_blank>%d<S2SV_blank>(slab_page_size)\\\exit ( EX_USAGE ) ;}# ifdef EXTSTORE if ( storage_file ) {if ( settings . item_size_max > ext_cf . wbuf_size ) {fprintf ( stderr , ""-I<S2SV_blank>(item_size_max:<S2SV_blank>%d)<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>ext_wbuf_size:<S2SV_blank>%d\\\exit ( EX_USAGE ) ;}if ( settings . inline_ascii_response ) {fprintf ( stderr , ""Cannot<S2SV_blank>use<S2SV_blank>inline_ascii_response<S2SV_blank>with<S2SV_blank>extstore<S2SV_blank>enabled\\\exit ( EX_USAGE ) ;}if ( settings . udpport ) {fprintf ( stderr , ""Cannot<S2SV_blank>use<S2SV_blank>UDP<S2SV_blank>with<S2SV_blank>extstore<S2SV_blank>enabled<S2SV_blank>(-U<S2SV_blank>0<S2SV_blank>to<S2SV_blank>disable)\\\exit ( EX_USAGE ) ;}}# endif if ( slab_sizes_unparsed != NULL ) {if ( _parse_slab_sizes ( slab_sizes_unparsed , slab_sizes ) ) {use_slab_sizes = true ;}else {exit ( EX_USAGE ) ;}}if ( settings . hot_lru_pct + settings . warm_lru_pct > 80 ) {fprintf ( stderr , ""hot_lru_pct<S2SV_blank>+<S2SV_blank>warm_lru_pct<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>more<S2SV_blank>than<S2SV_blank>80%%<S2SV_blank>combined\\\exit ( EX_USAGE ) ;}if ( settings . temp_lru && ! start_lru_maintainer ) {fprintf ( stderr , ""temporary_ttl<S2SV_blank>requires<S2SV_blank>lru_maintainer<S2SV_blank>to<S2SV_blank>be<S2SV_blank>enabled\\\exit ( EX_USAGE ) ;}if ( hash_init ( hash_type ) != 0 ) {fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>hash_algorithm!\\\exit ( EX_USAGE ) ;}if ( settings . inter != NULL && strchr ( settings . inter , \',\' ) ) {settings . num_threads_per_udp = 1 ;}else {settings . num_threads_per_udp = settings . num_threads ;}if ( settings . sasl ) {if ( ! protocol_specified ) {settings . binding_protocol = binary_prot ;}else {if ( settings . binding_protocol != binary_prot ) {fprintf ( stderr , ""ERROR:<S2SV_blank>You<S2SV_blank>cannot<S2SV_blank>allow<S2SV_blank>the<S2SV_blank>ASCII<S2SV_blank>protocol<S2SV_blank>while<S2SV_blank>using<S2SV_blank>SASL.\\\exit ( EX_USAGE ) ;}}}if ( tcp_specified && settings . port != 0 && ! udp_specified ) {settings . udpport = settings . port ;}else if ( udp_specified && settings . udpport != 0 && ! tcp_specified ) {cwe id:CWE-400context: int main ( int argc , char * * argv ) { int c ; bool lock_memory = false ; bool do_daemonize = false ; bool preallocate = false ; int maxcore = 0 ; char * username = NULL ; char * pid_file = NULL ; struct passwd * pw ; struct rlimit rlim ; char * buf ; char unit = '\\0' ; int size_max = 0 ; int retval = EXIT_SUCCESS ; static int * l_socket = NULL ; static int * u_socket = NULL ; bool protocol_specified = false ; bool tcp_specified = false ; bool udp_specified = false ; bool start_lru_maintainer = true ; bool start_lru_crawler = true ; bool start_assoc_maint = true ; enum hashfunc_type hash_type = MURMUR3_HASH ; uint32_t tocrawl ; uint32_t slab_sizes [ MAX_NUMBER_OF_SLAB_CLASSES ] ; bool use_slab_sizes = false ; char * slab_sizes_unparsed = NULL ; bool slab_chunk_size_changed = false ; # ifdef EXTSTORE void * storage = NULL ; char * storage_file = NULL ; struct extstore_conf ext_cf ; # endif char * subopts , * subopts_orig ; char * subopts_value ; enum { MAXCONNS_FAST = 0 , HASHPOWER_INIT , NO_HASHEXPAND , SLAB_REASSIGN , SLAB_AUTOMOVE , SLAB_AUTOMOVE_RATIO , SLAB_AUTOMOVE_WINDOW , TAIL_REPAIR_TIME , HASH_ALGORITHM , LRU_CRAWLER , LRU_CRAWLER_SLEEP , LRU_CRAWLER_TOCRAWL , LRU_MAINTAINER , HOT_LRU_PCT , WARM_LRU_PCT , HOT_MAX_FACTOR , WARM_MAX_FACTOR , TEMPORARY_TTL , IDLE_TIMEOUT , WATCHER_LOGBUF_SIZE , WORKER_LOGBUF_SIZE , SLAB_SIZES , SLAB_CHUNK_MAX , TRACK_SIZES , NO_INLINE_ASCII_RESP , MODERN , NO_MODERN , NO_CHUNKED_ITEMS , NO_SLAB_REASSIGN , NO_SLAB_AUTOMOVE , NO_MAXCONNS_FAST , INLINE_ASCII_RESP , NO_LRU_CRAWLER , NO_LRU_MAINTAINER , NO_DROP_PRIVILEGES , # ifdef MEMCACHED_DEBUG RELAXED_PRIVILEGES , # endif # ifdef EXTSTORE EXT_PAGE_SIZE , EXT_PAGE_COUNT , EXT_WBUF_SIZE , EXT_THREADS , EXT_IO_DEPTH , EXT_PATH , EXT_ITEM_SIZE , EXT_ITEM_AGE , EXT_LOW_TTL , EXT_RECACHE_RATE , EXT_COMPACT_UNDER , EXT_DROP_UNDER , EXT_MAX_FRAG , EXT_DROP_UNREAD , SLAB_AUTOMOVE_FREERATIO , # endif } ; char * const subopts_tokens [ ] = { [ MAXCONNS_FAST ] = ""maxconns_fast"" , [ HASHPOWER_INIT ] = ""hashpower"" , [ NO_HASHEXPAND ] = ""no_hashexpand"" , [ SLAB_REASSIGN ] = ""slab_reassign"" , [ SLAB_AUTOMOVE ] = ""slab_automove"" , [ SLAB_AUTOMOVE_RATIO ] = ""slab_automove_ratio"" , [ SLAB_AUTOMOVE_WINDOW ] = ""slab_automove_window"" , [ TAIL_REPAIR_TIME ] = ""tail_repair_time"" , [ HASH_ALGORITHM ] = ""hash_algorithm"" , [ LRU_CRAWLER ] = ""lru_crawler"" , [ LRU_CRAWLER_SLEEP ] = ""lru_crawler_sleep"" , [ LRU_CRAWLER_TOCRAWL ] = ""lru_crawler_tocrawl"" , [ LRU_MAINTAINER ] = ""lru_maintainer"" , [ HOT_LRU_PCT ] = ""hot_lru_pct"" , [ WARM_LRU_PCT ] = ""warm_lru_pct"" , [ HOT_MAX_FACTOR ] = ""hot_max_factor"" , [ WARM_MAX_FACTOR ] = ""warm_max_factor"" , [ TEMPORARY_TTL ] = ""temporary_ttl"" , [ IDLE_TIMEOUT ] = ""idle_timeout"" , [ WATCHER_LOGBUF_SIZE ] = ""watcher_logbuf_size"" , [ WORKER_LOGBUF_SIZE ] = ""worker_logbuf_size"" , [ SLAB_SIZES ] = ""slab_sizes"" , [ SLAB_CHUNK_MAX ] = ""slab_chunk_max"" , [ TRACK_SIZES ] = ""track_sizes"" , [ NO_INLINE_ASCII_RESP ] = ""no_inline_ascii_resp"" , [ MODERN ] = ""modern"" , [ NO_MODERN ] = ""no_modern"" , [ NO_CHUNKED_ITEMS ] = ""no_chunked_items"" , [ NO_SLAB_REASSIGN ] = ""no_slab_reassign"" , [ NO_SLAB_AUTOMOVE ] = ""no_slab_automove"" , [ NO_MAXCONNS_FAST ] = ""no_maxconns_fast"" , [ INLINE_ASCII_RESP ] = ""inline_ascii_resp"" , [ NO_LRU_CRAWLER ] = ""no_lru_crawler"" , [ NO_LRU_MAINTAINER ] = ""no_lru_maintainer"" , [ NO_DROP_PRIVILEGES ] = ""no_drop_privileges"" , # ifdef MEMCACHED_DEBUG [ RELAXED_PRIVILEGES ] = ""relaxed_privileges"" , # endif # ifdef EXTSTORE [ EXT_PAGE_SIZE ] = ""ext_page_size"" , [ EXT_PAGE_COUNT ] = ""ext_page_count"" , [ EXT_WBUF_SIZE ] = ""ext_wbuf_size"" , [ EXT_THREADS ] = ""ext_threads"" , [ EXT_IO_DEPTH ] = ""ext_io_depth"" , [ EXT_PATH ] = ""ext_path"" , [ EXT_ITEM_SIZE ] = ""ext_item_size"" , [ EXT_ITEM_AGE ] = ""ext_item_age"" , [ EXT_LOW_TTL ] = ""ext_low_ttl"" , [ EXT_RECACHE_RATE ] = ""ext_recache_rate"" , [ EXT_COMPACT_UNDER ] = ""ext_compact_under"" , [ EXT_DROP_UNDER ] = ""ext_drop_under"" , [ EXT_MAX_FRAG ] = ""ext_max_frag"" , [ EXT_DROP_UNREAD ] = ""ext_drop_unread"" , [ SLAB_AUTOMOVE_FREERATIO ] = ""slab_automove_freeratio"" , # endif NULL } ; if ( ! sanitycheck ( ) ) { return EX_OSERR ; } signal ( SIGINT , sig_handler ) ; signal ( SIGTERM , sig_handler ) ; settings_init ( ) ; # ifdef EXTSTORE settings . ext_item_size = 512 ; settings . ext_item_age = UINT_MAX ; settings . ext_low_ttl = 0 ; settings . ext_recache_rate = 2000 ; settings . ext_max_frag = 0.8 ; settings . ext_drop_unread = false ; settings . ext_wbuf_size = 1024 * 1024 * 4 ; settings . ext_compact_under = 0 ; settings . ext_drop_under = 0 ; settings . slab_automove_freeratio = 0.01 ; ext_cf . page_size = 1024 * 1024 * 64 ; ext_cf . page_count = 64 ; ext_cf . wbuf_size = settings . ext_wbuf_size ; ext_cf . io_threadcount = 1 ; ext_cf . io_depth = 1 ; ext_cf . page_buckets = 4 ; ext_cf . wbuf_count = ext_cf . page_buckets ; # endif init_lru_maintainer ( ) ; setbuf ( stderr , NULL ) ; char * shortopts = ""a:"" ""A"" ""p:"" ""s:"" ""U:"" ""m:"" ""M"" ""c:"" ""k"" ""hiV"" ""r"" ""v"" ""d"" ""l:"" ""u:"" ""P:"" ""f:"" ""n:"" ""t:"" ""D:"" ""L"" ""R:"" ""C"" ""b:"" ""B:"" ""I:"" ""S"" ""F"" ""X"" ""o:"" ; # ifdef HAVE_GETOPT_LONG const struct option longopts [ ] = { { ""unix-mask"" , required_argument , 0 , 'a' } , { ""enable-shutdown"" , no_argument , 0 , 'A' } , { ""port"" , required_argument , 0 , 'p' } , { ""unix-socket"" , required_argument , 0 , 's' } , { ""udp-port"" , required_argument , 0 , 'U' } , { ""memory-limit"" , required_argument , 0 , 'm' } , { ""disable-evictions"" , no_argument , 0 , 'M' } , { ""conn-limit"" , required_argument , 0 , 'c' } , { ""lock-memory"" , no_argument , 0 , 'k' } , { ""help"" , no_argument , 0 , 'h' } , { ""license"" , no_argument , 0 , 'i' } , { ""version"" , no_argument , 0 , 'V' } , { ""enable-coredumps"" , no_argument , 0 , 'r' } , { ""verbose"" , optional_argument , 0 , 'v' } , { ""daemon"" , no_argument , 0 , 'd' } , { ""listen"" , required_argument , 0 , 'l' } , { ""user"" , required_argument , 0 , 'u' } , { ""pidfile"" , required_argument , 0 , 'P' } , { ""slab-growth-factor"" , required_argument , 0 , 'f' } , { ""slab-min-size"" , required_argument , 0 , 'n' } , { ""threads"" , required_argument , 0 , 't' } , { ""enable-largepages"" , no_argument , 0 , 'L' } , { ""max-reqs-per-event"" , required_argument , 0 , 'R' } , { ""disable-cas"" , no_argument , 0 , 'C' } , { ""listen-backlog"" , required_argument , 0 , 'b' } , { ""protocol"" , required_argument , 0 , 'B' } , { ""max-item-size"" , required_argument , 0 , 'I' } , { ""enable-sasl"" , no_argument , 0 , 'S' } , { ""disable-flush-all"" , no_argument , 0 , 'F' } , { ""disable-dumping"" , no_argument , 0 , 'X' } , { ""extended"" , required_argument , 0 , 'o' } , { 0 , 0 , 0 , 0 } } ; int optindex ; while ( - 1 != ( c = getopt_long ( argc , argv , shortopts , longopts , & optindex ) ) ) { # else while ( - 1 != ( c = getopt ( argc , argv , shortopts ) ) ) { # endif switch ( c ) { case 'A' : settings . shutdown_command = true ; break ; case 'a' : settings . access = strtol ( optarg , NULL , 8 ) ; break ; case 'U' : settings . udpport = atoi ( optarg ) ; udp_specified = true ; break ; case 'p' : settings . port = atoi ( optarg ) ; tcp_specified = true ; break ; case 's' : settings . socketpath = optarg ; break ; case 'm' : settings . maxbytes = ( ( size_t ) atoi ( optarg ) ) * 1024 * 1024 ; break ; case 'M' : settings . evict_to_free = 0 ; break ; case 'c' : settings . maxconns = atoi ( optarg ) ; if ( settings . maxconns <= 0 ) { fprintf ( stderr , ""Maximum<S2SV_blank>connections<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0\\n"" ) ; return 1 ; } break ; case 'h' : usage ( ) ; exit ( EXIT_SUCCESS ) ; case 'i' : usage_license ( ) ; exit ( EXIT_SUCCESS ) ; case 'V' : printf ( PACKAGE ""<S2SV_blank>"" VERSION ""\\n"" ) ; exit ( EXIT_SUCCESS ) ; case 'k' : lock_memory = true ; break ; case 'v' : settings . verbose ++ ; break ; case 'l' : if ( settings . inter != NULL ) { if ( strstr ( settings . inter , optarg ) != NULL ) { break ; } size_t len = strlen ( settings . inter ) + strlen ( optarg ) + 2 ; char * p = malloc ( len ) ; if ( p == NULL ) { fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory\\n"" ) ; return 1 ; } snprintf ( p , len , ""%s,%s"" , settings . inter , optarg ) ; free ( settings . inter ) ; settings . inter = p ; } else { settings . inter = strdup ( optarg ) ; } break ; case 'd' : do_daemonize = true ; break ; case 'r' : maxcore = 1 ; break ; case 'R' : settings . reqs_per_event = atoi ( optarg ) ; if ( settings . reqs_per_event == 0 ) { fprintf ( stderr , ""Number<S2SV_blank>of<S2SV_blank>requests<S2SV_blank>per<S2SV_blank>event<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0\\n"" ) ; return 1 ; } break ; case 'u' : username = optarg ; break ; case 'P' : pid_file = optarg ; break ; case 'f' : settings . factor = atof ( optarg ) ; if ( settings . factor <= 1.0 ) { fprintf ( stderr , ""Factor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>1\\n"" ) ; return 1 ; } break ; case 'n' : settings . chunk_size = atoi ( optarg ) ; if ( settings . chunk_size == 0 ) { fprintf ( stderr , ""Chunk<S2SV_blank>size<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0\\n"" ) ; return 1 ; } break ; case 't' : settings . num_threads = atoi ( optarg ) ; if ( settings . num_threads <= 0 ) { fprintf ( stderr , ""Number<S2SV_blank>of<S2SV_blank>threads<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0\\n"" ) ; return 1 ; } if ( settings . num_threads > 64 ) { fprintf ( stderr , ""WARNING:<S2SV_blank>Setting<S2SV_blank>a<S2SV_blank>high<S2SV_blank>number<S2SV_blank>of<S2SV_blank>worker"" ""threads<S2SV_blank>is<S2SV_blank>not<S2SV_blank>recommended.\\n"" ""<S2SV_blank>Set<S2SV_blank>this<S2SV_blank>value<S2SV_blank>to<S2SV_blank>the<S2SV_blank>number<S2SV_blank>of<S2SV_blank>cores<S2SV_blank>in"" ""<S2SV_blank>your<S2SV_blank>machine<S2SV_blank>or<S2SV_blank>less.\\n"" ) ; } break ; case 'D' : if ( ! optarg || ! optarg [ 0 ] ) { fprintf ( stderr , ""No<S2SV_blank>delimiter<S2SV_blank>specified\\n"" ) ; return 1 ; } settings . prefix_delimiter = optarg [ 0 ] ; settings . detail_enabled = 1 ; break ; case 'L' : if ( enable_large_pages ( ) == 0 ) { preallocate = true ; } else { fprintf ( stderr , ""Cannot<S2SV_blank>enable<S2SV_blank>large<S2SV_blank>pages<S2SV_blank>on<S2SV_blank>this<S2SV_blank>system\\n"" ""(There<S2SV_blank>is<S2SV_blank>no<S2SV_blank>Linux<S2SV_blank>support<S2SV_blank>as<S2SV_blank>of<S2SV_blank>this<S2SV_blank>version)\\n"" ) ; return 1 ; } break ; case 'C' : settings . use_cas = false ; break ; case 'b' : settings . backlog = atoi ( optarg ) ; break ; case 'B' : protocol_specified = true ; if ( strcmp ( optarg , ""auto"" ) == 0 ) { settings . binding_protocol = negotiating_prot ; } else if ( strcmp ( optarg , ""binary"" ) == 0 ) { settings . binding_protocol = binary_prot ; } else if ( strcmp ( optarg , ""ascii"" ) == 0 ) { settings . binding_protocol = ascii_prot ; } else { fprintf ( stderr , ""Invalid<S2SV_blank>value<S2SV_blank>for<S2SV_blank>binding<S2SV_blank>protocol:<S2SV_blank>%s\\n"" ""<S2SV_blank>--<S2SV_blank>should<S2SV_blank>be<S2SV_blank>one<S2SV_blank>of<S2SV_blank>auto,<S2SV_blank>binary,<S2SV_blank>or<S2SV_blank>ascii\\n"" , optarg ) ; exit ( EX_USAGE ) ; } break ; case 'I' : buf = strdup ( optarg ) ; unit = buf [ strlen ( buf ) - 1 ] ; if ( unit == 'k' || unit == 'm' || unit == 'K' || unit == 'M' ) { buf [ strlen ( buf ) - 1 ] = '\\0' ; size_max = atoi ( buf ) ; if ( unit == 'k' || unit == 'K' ) size_max *= 1024 ; if ( unit == 'm' || unit == 'M' ) size_max *= 1024 * 1024 ; settings . item_size_max = size_max ; } else { settings . item_size_max = atoi ( buf ) ; } free ( buf ) ; break ; case 'S' : # ifndef ENABLE_SASL fprintf ( stderr , ""This<S2SV_blank>server<S2SV_blank>is<S2SV_blank>not<S2SV_blank>built<S2SV_blank>with<S2SV_blank>SASL<S2SV_blank>support.\\n"" ) ; exit ( EX_USAGE ) ; # endif settings . sasl = true ; break ; case 'F' : settings . flush_enabled = false ; break ; case 'X' : settings . dump_enabled = false ; break ; case 'o' : subopts_orig = subopts = strdup ( optarg ) ; while ( * subopts != '\\0' ) { switch ( getsubopt ( & subopts , subopts_tokens , & subopts_value ) ) { case MAXCONNS_FAST : settings . maxconns_fast = true ; break ; case HASHPOWER_INIT : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>numeric<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>hashpower\\n"" ) ; return 1 ; } settings . hashpower_init = atoi ( subopts_value ) ; if ( settings . hashpower_init < 12 ) { fprintf ( stderr , ""Initial<S2SV_blank>hashtable<S2SV_blank>multiplier<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>low\\n"" , settings . hashpower_init ) ; return 1 ; } else if ( settings . hashpower_init > 32 ) { fprintf ( stderr , ""Initial<S2SV_blank>hashtable<S2SV_blank>multiplier<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>high\\n"" ""Choose<S2SV_blank>a<S2SV_blank>value<S2SV_blank>based<S2SV_blank>on<S2SV_blank>\\""STAT<S2SV_blank>hash_power_level\\""<S2SV_blank>from<S2SV_blank>a<S2SV_blank>running<S2SV_blank>instance\\n"" , settings . hashpower_init ) ; return 1 ; } break ; case NO_HASHEXPAND : start_assoc_maint = false ; break ; case SLAB_REASSIGN : settings . slab_reassign = true ; break ; case SLAB_AUTOMOVE : if ( subopts_value == NULL ) { settings . slab_automove = 1 ; break ; } settings . slab_automove = atoi ( subopts_value ) ; if ( settings . slab_automove < 0 || settings . slab_automove > 2 ) { fprintf ( stderr , ""slab_automove<S2SV_blank>must<S2SV_blank>be<S2SV_blank>between<S2SV_blank>0<S2SV_blank>and<S2SV_blank>2\\n"" ) ; return 1 ; } break ; case SLAB_AUTOMOVE_RATIO : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>slab_automove_ratio<S2SV_blank>argument\\n"" ) ; return 1 ; } settings . slab_automove_ratio = atof ( subopts_value ) ; if ( settings . slab_automove_ratio <= 0 || settings . slab_automove_ratio > 1 ) { fprintf ( stderr , ""slab_automove_ratio<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0<S2SV_blank>and<S2SV_blank><<S2SV_blank>1\\n"" ) ; return 1 ; } break ; case SLAB_AUTOMOVE_WINDOW : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>slab_automove_window<S2SV_blank>argument\\n"" ) ; return 1 ; } settings . slab_automove_window = atoi ( subopts_value ) ; if ( settings . slab_automove_window < 3 ) { fprintf ( stderr , ""slab_automove_window<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>2\\n"" ) ; return 1 ; } break ; case TAIL_REPAIR_TIME : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>numeric<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>tail_repair_time\\n"" ) ; return 1 ; } settings . tail_repair_time = atoi ( subopts_value ) ; if ( settings . tail_repair_time < 10 ) { fprintf ( stderr , ""Cannot<S2SV_blank>set<S2SV_blank>tail_repair_time<S2SV_blank>to<S2SV_blank>less<S2SV_blank>than<S2SV_blank>10<S2SV_blank>seconds\\n"" ) ; return 1 ; } break ; case HASH_ALGORITHM : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>hash_algorithm<S2SV_blank>argument\\n"" ) ; return 1 ; } ; if ( strcmp ( subopts_value , ""jenkins"" ) == 0 ) { hash_type = JENKINS_HASH ; } else if ( strcmp ( subopts_value , ""murmur3"" ) == 0 ) { hash_type = MURMUR3_HASH ; } else { fprintf ( stderr , ""Unknown<S2SV_blank>hash_algorithm<S2SV_blank>option<S2SV_blank>(jenkins,<S2SV_blank>murmur3)\\n"" ) ; return 1 ; } break ; case LRU_CRAWLER : start_lru_crawler = true ; break ; case LRU_CRAWLER_SLEEP : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>lru_crawler_sleep<S2SV_blank>value\\n"" ) ; return 1 ; } settings . lru_crawler_sleep = atoi ( subopts_value ) ; if ( settings . lru_crawler_sleep > 1000000 || settings . lru_crawler_sleep < 0 ) { fprintf ( stderr , ""LRU<S2SV_blank>crawler<S2SV_blank>sleep<S2SV_blank>must<S2SV_blank>be<S2SV_blank>between<S2SV_blank>0<S2SV_blank>and<S2SV_blank>1<S2SV_blank>second\\n"" ) ; return 1 ; } break ; case LRU_CRAWLER_TOCRAWL : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>lru_crawler_tocrawl<S2SV_blank>value\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & tocrawl ) ) { fprintf ( stderr , ""lru_crawler_tocrawl<S2SV_blank>takes<S2SV_blank>a<S2SV_blank>numeric<S2SV_blank>32bit<S2SV_blank>value\\n"" ) ; return 1 ; } settings . lru_crawler_tocrawl = tocrawl ; break ; case LRU_MAINTAINER : start_lru_maintainer = true ; settings . lru_segmented = true ; break ; case HOT_LRU_PCT : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>hot_lru_pct<S2SV_blank>argument\\n"" ) ; return 1 ; } settings . hot_lru_pct = atoi ( subopts_value ) ; if ( settings . hot_lru_pct < 1 || settings . hot_lru_pct >= 80 ) { fprintf ( stderr , ""hot_lru_pct<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>1<S2SV_blank>and<S2SV_blank><<S2SV_blank>80\\n"" ) ; return 1 ; } break ; case WARM_LRU_PCT : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>warm_lru_pct<S2SV_blank>argument\\n"" ) ; return 1 ; } settings . warm_lru_pct = atoi ( subopts_value ) ; if ( settings . warm_lru_pct < 1 || settings . warm_lru_pct >= 80 ) { fprintf ( stderr , ""warm_lru_pct<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>1<S2SV_blank>and<S2SV_blank><<S2SV_blank>80\\n"" ) ; return 1 ; } break ; case HOT_MAX_FACTOR : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>hot_max_factor<S2SV_blank>argument\\n"" ) ; return 1 ; } settings . hot_max_factor = atof ( subopts_value ) ; if ( settings . hot_max_factor <= 0 ) { fprintf ( stderr , ""hot_max_factor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0\\n"" ) ; return 1 ; } break ; case WARM_MAX_FACTOR : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>warm_max_factor<S2SV_blank>argument\\n"" ) ; return 1 ; } settings . warm_max_factor = atof ( subopts_value ) ; if ( settings . warm_max_factor <= 0 ) { fprintf ( stderr , ""warm_max_factor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0\\n"" ) ; return 1 ; } break ; case TEMPORARY_TTL : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>temporary_ttl<S2SV_blank>argument\\n"" ) ; return 1 ; } settings . temp_lru = true ; settings . temporary_ttl = atoi ( subopts_value ) ; break ; case IDLE_TIMEOUT : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>numeric<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>idle_timeout\\n"" ) ; return 1 ; } settings . idle_timeout = atoi ( subopts_value ) ; break ; case WATCHER_LOGBUF_SIZE : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>watcher_logbuf_size<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . logger_watcher_buf_size ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>watcher_logbuf_size\\n"" ) ; return 1 ; } settings . logger_watcher_buf_size *= 1024 ; break ; case WORKER_LOGBUF_SIZE : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>worker_logbuf_size<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . logger_buf_size ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>worker_logbuf_size\\n"" ) ; return 1 ; } settings . logger_buf_size *= 1024 ; case SLAB_SIZES : slab_sizes_unparsed = subopts_value ; break ; case SLAB_CHUNK_MAX : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>slab_chunk_max<S2SV_blank>argument\\n"" ) ; } if ( ! safe_strtol ( subopts_value , & settings . slab_chunk_size_max ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>slab_chunk_max\\n"" ) ; } slab_chunk_size_changed = true ; break ; case TRACK_SIZES : item_stats_sizes_init ( ) ; break ; case NO_INLINE_ASCII_RESP : settings . inline_ascii_response = false ; break ; case INLINE_ASCII_RESP : settings . inline_ascii_response = true ; break ; case NO_CHUNKED_ITEMS : settings . slab_chunk_size_max = settings . slab_page_size ; break ; case NO_SLAB_REASSIGN : settings . slab_reassign = false ; break ; case NO_SLAB_AUTOMOVE : settings . slab_automove = 0 ; break ; case NO_MAXCONNS_FAST : settings . maxconns_fast = false ; break ; case NO_LRU_CRAWLER : settings . lru_crawler = false ; start_lru_crawler = false ; break ; case NO_LRU_MAINTAINER : start_lru_maintainer = false ; settings . lru_segmented = false ; break ; # ifdef EXTSTORE case EXT_PAGE_SIZE : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_page_size<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & ext_cf . page_size ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_page_size\\n"" ) ; return 1 ; } ext_cf . page_size *= 1024 * 1024 ; break ; case EXT_PAGE_COUNT : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_page_count<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & ext_cf . page_count ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_page_count\\n"" ) ; return 1 ; } break ; case EXT_WBUF_SIZE : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_wbuf_size<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & ext_cf . wbuf_size ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_wbuf_size\\n"" ) ; return 1 ; } ext_cf . wbuf_size *= 1024 * 1024 ; settings . ext_wbuf_size = ext_cf . wbuf_size ; break ; case EXT_THREADS : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_threads<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & ext_cf . io_threadcount ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_threads\\n"" ) ; return 1 ; } break ; case EXT_IO_DEPTH : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_io_depth<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & ext_cf . io_depth ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_io_depth\\n"" ) ; return 1 ; } break ; case EXT_ITEM_SIZE : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_item_size<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . ext_item_size ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_item_size\\n"" ) ; return 1 ; } break ; case EXT_ITEM_AGE : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_item_age<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . ext_item_age ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_item_age\\n"" ) ; return 1 ; } break ; case EXT_LOW_TTL : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_low_ttl<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . ext_low_ttl ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_low_ttl\\n"" ) ; return 1 ; } break ; case EXT_RECACHE_RATE : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_recache_rate<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . ext_recache_rate ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_recache_rate\\n"" ) ; return 1 ; } break ; case EXT_COMPACT_UNDER : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_compact_under<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . ext_compact_under ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_compact_under\\n"" ) ; return 1 ; } break ; case EXT_DROP_UNDER : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_drop_under<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . ext_drop_under ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_drop_under\\n"" ) ; return 1 ; } break ; case EXT_MAX_FRAG : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_max_frag<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtod ( subopts_value , & settings . ext_max_frag ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_max_frag\\n"" ) ; return 1 ; } break ; case SLAB_AUTOMOVE_FREERATIO : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>slab_automove_freeratio<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtod ( subopts_value , & settings . slab_automove_freeratio ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>slab_automove_freeratio\\n"" ) ; return 1 ; } break ; case EXT_DROP_UNREAD : settings . ext_drop_unread = true ; break ; case EXT_PATH : storage_file = strdup ( subopts_value ) ; break ; # endif case MODERN : break ; case NO_MODERN : if ( ! slab_chunk_size_changed ) { settings . slab_chunk_size_max = settings . slab_page_size ; } settings . slab_reassign = false ; settings . slab_automove = 0 ; settings . maxconns_fast = false ; settings . inline_ascii_response = true ; settings . lru_segmented = false ; hash_type = JENKINS_HASH ; start_lru_crawler = false ; start_lru_maintainer = false ; break ; case NO_DROP_PRIVILEGES : settings . drop_privileges = false ; break ; # ifdef MEMCACHED_DEBUG case RELAXED_PRIVILEGES : settings . relaxed_privileges = true ; break ; # endif default : printf ( ""Illegal<S2SV_blank>suboption<S2SV_blank>\\""%s\\""\\n"" , subopts_value ) ; return 1 ; } } free ( subopts_orig ) ; break ; default : fprintf ( stderr , ""Illegal<S2SV_blank>argument<S2SV_blank>\\""%c\\""\\n"" , c ) ; return 1 ; } } if ( settings . item_size_max < 1024 ) { fprintf ( stderr , ""Item<S2SV_blank>max<S2SV_blank>size<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>less<S2SV_blank>than<S2SV_blank>1024<S2SV_blank>bytes.\\n"" ) ; exit ( EX_USAGE ) ; } if ( settings . item_size_max > ( settings . maxbytes / 2 ) ) { fprintf ( stderr , ""Cannot<S2SV_blank>set<S2SV_blank>item<S2SV_blank>size<S2SV_blank>limit<S2SV_blank>higher<S2SV_blank>than<S2SV_blank>1/2<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>max.\\n"" ) ; exit ( EX_USAGE ) ; } if ( settings . item_size_max > ( 1024 * 1024 * 1024 ) ) { fprintf ( stderr , ""Cannot<S2SV_blank>set<S2SV_blank>item<S2SV_blank>size<S2SV_blank>limit<S2SV_blank>higher<S2SV_blank>than<S2SV_blank>a<S2SV_blank>gigabyte.\\n"" ) ; exit ( EX_USAGE ) ; } if ( settings . item_size_max > 1024 * 1024 ) { if ( ! slab_chunk_size_changed ) { settings . slab_chunk_size_max = settings . slab_page_size / 2 ; } } if ( settings . slab_chunk_size_max > settings . item_size_max ) { fprintf ( stderr , ""slab_chunk_max<S2SV_blank>(bytes:<S2SV_blank>%d)<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>-I<S2SV_blank>(item_size_max<S2SV_blank>%d)\\n"" , settings . slab_chunk_size_max , settings . item_size_max ) ; exit ( EX_USAGE ) ; } if ( settings . item_size_max % settings . slab_chunk_size_max != 0 ) { fprintf ( stderr , ""-I<S2SV_blank>(item_size_max:<S2SV_blank>%d)<S2SV_blank>must<S2SV_blank>be<S2SV_blank>evenly<S2SV_blank>divisible<S2SV_blank>by<S2SV_blank>slab_chunk_max<S2SV_blank>(bytes:<S2SV_blank>%d)\\n"" , settings . item_size_max , settings . slab_chunk_size_max ) ; exit ( EX_USAGE ) ; } if ( settings . slab_page_size % settings . slab_chunk_size_max != 0 ) { fprintf ( stderr , ""slab_chunk_max<S2SV_blank>(bytes:<S2SV_blank>%d)<S2SV_blank>must<S2SV_blank>divide<S2SV_blank>evenly<S2SV_blank>into<S2SV_blank>%d<S2SV_blank>(slab_page_size)\\n"" , settings . slab_chunk_size_max , settings . slab_page_size ) ; exit ( EX_USAGE ) ; } # ifdef EXTSTORE if ( storage_file ) { if ( settings . item_size_max > ext_cf . wbuf_size ) { fprintf ( stderr , ""-I<S2SV_blank>(item_size_max:<S2SV_blank>%d)<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>ext_wbuf_size:<S2SV_blank>%d\\n"" , settings . item_size_max , ext_cf . wbuf_size ) ; exit ( EX_USAGE ) ; } if ( settings . inline_ascii_response ) { fprintf ( stderr , ""Cannot<S2SV_blank>use<S2SV_blank>inline_ascii_response<S2SV_blank>with<S2SV_blank>extstore<S2SV_blank>enabled\\n"" ) ; exit ( EX_USAGE ) ; } if ( settings . udpport ) { fprintf ( stderr , ""Cannot<S2SV_blank>use<S2SV_blank>UDP<S2SV_blank>with<S2SV_blank>extstore<S2SV_blank>enabled<S2SV_blank>(-U<S2SV_blank>0<S2SV_blank>to<S2SV_blank>disable)\\n"" ) ; exit ( EX_USAGE ) ; } } # endif if ( slab_sizes_unparsed != NULL ) { if ( _parse_slab_sizes ( slab_sizes_unparsed , slab_sizes ) ) { use_slab_sizes = true ; } else { exit ( EX_USAGE ) ; } } if ( settings . hot_lru_pct + settings . warm_lru_pct > 80 ) { fprintf ( stderr , ""hot_lru_pct<S2SV_blank>+<S2SV_blank>warm_lru_pct<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>more<S2SV_blank>than<S2SV_blank>80%%<S2SV_blank>combined\\n"" ) ; exit ( EX_USAGE ) ; } if ( settings . temp_lru && ! start_lru_maintainer ) { fprintf ( stderr , ""temporary_ttl<S2SV_blank>requires<S2SV_blank>lru_maintainer<S2SV_blank>to<S2SV_blank>be<S2SV_blank>enabled\\n"" ) ; exit ( EX_USAGE ) ; } if ( hash_init ( hash_type ) != 0 ) { fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>hash_algorithm!\\n"" ) ; exit ( EX_USAGE ) ; } if ( settings . inter != NULL && strchr ( settings . inter , ',' ) ) { settings . num_threads_per_udp = 1 ; } else { settings . num_threads_per_udp = settings . num_threads ; } if ( settings . sasl ) { if ( ! protocol_specified ) { settings . binding_protocol = binary_prot ; } else { if ( settings . binding_protocol != binary_prot ) { fprintf ( stderr , ""ERROR:<S2SV_blank>You<S2SV_blank>cannot<S2SV_blank>allow<S2SV_blank>the<S2SV_blank>ASCII<S2SV_blank>protocol<S2SV_blank>while<S2SV_blank>using<S2SV_blank>SASL.\\n"" ) ; exit ( EX_USAGE ) ; } } }  if ( tcp_specified && settings . port != 0 && ! udp_specified ) {  settings . udpport = settings . port ; } else if ( udp_specified && settings . udpport != 0 && ! tcp_specified ) { settings . port = settings . udpport ; } if ( maxcore != 0 ) { struct rlimit rlim_new ; if ( getrlimit ( RLIMIT_CORE , & rlim ) == 0 ) { rlim_new . rlim_cur = rlim_new . rlim_max = RLIM_INFINITY ; if ( setrlimit ( RLIMIT_CORE , & rlim_new ) != 0 ) { rlim_new . rlim_cur = rlim_new . rlim_max = rlim . rlim_max ; ( void ) setrlimit ( RLIMIT_CORE , & rlim_new ) ; } } if ( ( getrlimit ( RLIMIT_CORE , & rlim ) != 0 ) || rlim . rlim_cur == 0 ) { fprintf ( stderr , ""failed<S2SV_blank>to<S2SV_blank>ensure<S2SV_blank>corefile<S2SV_blank>creation\\n"" ) ; exit ( EX_OSERR ) ; } } if ( getrlimit ( RLIMIT_NOFILE , & rlim ) != 0 ) { fprintf ( stderr , ""failed<S2SV_blank>to<S2SV_blank>getrlimit<S2SV_blank>number<S2SV_blank>of<S2SV_blank>files\\n"" ) ; exit ( EX_OSERR ) ; } else { rlim . rlim_cur = settings . maxconns ; rlim . rlim_max = settings . maxconns ; if ( setrlimit ( RLIMIT_NOFILE , & rlim ) != 0 ) { fprintf ( stderr , ""failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>rlimit<S2SV_blank>for<S2SV_blank>open<S2SV_blank>files.<S2SV_blank>Try<S2SV_blank>starting<S2SV_blank>as<S2SV_blank>root<S2SV_blank>or<S2SV_blank>requesting<S2SV_blank>smaller<S2SV_blank>maxconns<S2SV_blank>value.\\n"" ) ; exit ( EX_OSERR ) ; } } if ( getuid ( ) == 0 || geteuid ( ) == 0 ) { if ( username == 0 || * username == '\\0' ) { fprintf ( stderr , ""can\'t<S2SV_blank>run<S2SV_blank>as<S2SV_blank>root<S2SV_blank>without<S2SV_blank>the<S2SV_blank>-u<S2SV_blank>switch\\n"" ) ; exit ( EX_USAGE ) ; } if ( ( pw = getpwnam ( username ) ) == 0 ) { fprintf ( stderr , ""can\'t<S2SV_blank>find<S2SV_blank>the<S2SV_blank>user<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>to\\n"" , username ) ; exit ( EX_NOUSER ) ; } if ( setgid ( pw -> pw_gid ) < 0 || setuid ( pw -> pw_uid ) < 0 ) { fprintf ( stderr , ""failed<S2SV_blank>to<S2SV_blank>assume<S2SV_blank>identity<S2SV_blank>of<S2SV_blank>user<S2SV_blank>%s\\n"" , username ) ; exit ( EX_OSERR ) ; } } if ( settings . sasl ) { init_sasl ( ) ; } if ( do_daemonize ) { if ( sigignore ( SIGHUP ) == - 1 ) { perror ( ""Failed<S2SV_blank>to<S2SV_blank>ignore<S2SV_blank>SIGHUP"" ) ; } if ( daemonize ( maxcore , settings . verbose ) == - 1 ) { fprintf ( stderr , ""failed<S2SV_blank>to<S2SV_blank>daemon()<S2SV_blank>in<S2SV_blank>order<S2SV_blank>to<S2SV_blank>daemonize\\n"" ) ; exit ( EXIT_FAILURE ) ; } } if ( lock_memory ) { # ifdef HAVE_MLOCKALL int res = mlockall ( MCL_CURRENT | MCL_FUTURE ) ; if ( res != 0 ) { fprintf ( stderr , ""warning:<S2SV_blank>-k<S2SV_blank>invalid,<S2SV_blank>mlockall()<S2SV_blank>failed:<S2SV_blank>%s\\n"" , strerror ( errno ) ) ; } # else fprintf ( stderr , ""warning:<S2SV_blank>-k<S2SV_blank>invalid,<S2SV_blank>mlockall()<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>on<S2SV_blank>this<S2SV_blank>platform.<S2SV_blank><S2SV_blank>proceeding<S2SV_blank>without.\\n"" ) ; # endif } # if defined ( LIBEVENT_VERSION_NUMBER ) && LIBEVENT_VERSION_NUMBER >= 0x02000101 struct event_config * ev_config ; ev_config = event_config_new ( ) ; event_config_set_flag ( ev_config , EVENT_BASE_FLAG_NOLOCK ) ; main_base = event_base_new_with_config ( ev_config ) ; event_config_free ( ev_config ) ; # else main_base = event_init ( ) ; # endif logger_init ( ) ; stats_init ( ) ; assoc_init ( settings . hashpower_init ) ; conn_init ( ) ; slabs_init ( settings . maxbytes , settings . factor , preallocate , use_slab_sizes ? slab_sizes : NULL ) ; # ifdef EXTSTORE if ( storage_file ) { enum extstore_res eres ; if ( settings . ext_compact_under == 0 ) { settings . ext_compact_under = ext_cf . page_count / 4 ; settings . ext_drop_under = ext_cf . page_count / 4 ; } crc32c_init ( ) ; for ( int x = 0 ; x < MAX_NUMBER_OF_SLAB_CLASSES ; x ++ ) { settings . ext_free_memchunks [ x ] = 0 ; } storage = extstore_init ( storage_file , & ext_cf , & eres ) ; if ( storage == NULL ) { fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>external<S2SV_blank>storage:<S2SV_blank>%s\\n"" , extstore_err ( eres ) ) ; if ( eres == EXTSTORE_INIT_OPEN_FAIL ) { perror ( ""extstore<S2SV_blank>open"" ) ; } exit ( EXIT_FAILURE ) ; } ext_storage = storage ; slabs_prefill_global ( ) ; } # endif if ( sigignore ( SIGPIPE ) == - 1 ) { perror ( ""failed<S2SV_blank>to<S2SV_blank>ignore<S2SV_blank>SIGPIPE;<S2SV_blank>sigaction"" ) ; exit ( EX_OSERR ) ; } # ifdef EXTSTORE slabs_set_storage ( storage ) ; memcached_thread_init ( settings . num_threads , storage ) ; init_lru_crawler ( storage ) ; # else memcached_thread_init ( settings . num_threads , NULL ) ; init_lru_crawler ( NULL ) ; # endif if ( start_assoc_maint && start_assoc_maintenance_thread ( ) == - 1 ) { exit ( EXIT_FAILURE ) ; } if ( start_lru_crawler && start_item_crawler_thread ( ) != 0 ) { fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>enable<S2SV_blank>LRU<S2SV_blank>crawler<S2SV_blank>thread\\n"" ) ; exit ( EXIT_FAILURE ) ; } # ifdef EXTSTORE if ( storage && start_storage_compact_thread ( storage ) != 0 ) { fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>start<S2SV_blank>storage<S2SV_blank>compaction<S2SV_blank>thread\\n"" ) ; exit ( EXIT_FAILURE ) ; } if ( start_lru_maintainer && start_lru_maintainer_thread ( storage ) != 0 ) { # else if ( start_lru_maintainer && start_lru_maintainer_thread ( NULL ) != 0 ) { # endif fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>enable<S2SV_blank>LRU<S2SV_blank>maintainer<S2SV_blank>thread\\n"" ) ; return 1 ; } if ( settings . slab_reassign && start_slab_maintenance_thread ( ) == - 1 ) { exit ( EXIT_FAILURE ) ; } if ( settings . idle_timeout && start_conn_timeout_thread ( ) == - 1 ) { exit ( EXIT_FAILURE ) ; } clock_handler ( 0 , 0 , 0 ) ; if ( settings . socketpath != NULL ) { errno = 0 ; if ( server_socket_unix ( settings . socketpath , settings . access ) ) { vperror ( ""failed<S2SV_blank>to<S2SV_blank>listen<S2SV_blank>on<S2SV_blank>UNIX<S2SV_blank>socket:<S2SV_blank>%s"" , settings . socketpath ) ; exit ( EX_OSERR ) ; } } if ( settings . socketpath == NULL ) { const char * portnumber_filename = getenv ( ""MEMCACHED_PORT_FILENAME"" ) ; char * temp_portnumber_filename = NULL ; size_t len ; FILE * portnumber_file = NULL ; if ( portnumber_filename != NULL ) { len = strlen ( portnumber_filename ) + 4 + 1 ; temp_portnumber_filename = malloc ( len ) ; snprintf ( temp_portnumber_filename , len , ""%s.lck"" , portnumber_filename ) ; portnumber_file = fopen ( temp_portnumber_filename , ""a"" ) ; if ( portnumber_file == NULL ) { fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>\\""%s\\"":<S2SV_blank>%s\\n"" , temp_portnumber_filename , strerror ( errno ) ) ; } } errno = 0 ; if ( settings . port && server_sockets ( settings . port , tcp_transport , portnumber_file ) ) { vperror ( ""failed<S2SV_blank>to<S2SV_blank>listen<S2SV_blank>on<S2SV_blank>TCP<S2SV_blank>port<S2SV_blank>%d"" , settings . port ) ; exit ( EX_OSERR ) ; } errno = 0 ; if ( settings . udpport && server_sockets ( settings . udpport , udp_transport , portnumber_file ) ) { vperror ( ""failed<S2SV_blank>to<S2SV_blank>listen<S2SV_blank>on<S2SV_blank>UDP<S2SV_blank>port<S2SV_blank>%d"" , settings . udpport ) ; exit ( EX_OSERR ) ; } if ( portnumber_file ) { fclose ( portnumber_file ) ; rename ( temp_portnumber_filename , portnumber_filename ) ; } if ( temp_portnumber_filename ) free ( temp_portnumber_filename ) ; } usleep ( 1000 ) ; if ( stats_state . curr_conns + stats_state . reserved_fds >= settings . maxconns - 1 ) { fprintf ( stderr , ""Maxconns<S2SV_blank>setting<S2SV_blank>is<S2SV_blank>too<S2SV_blank>low,<S2SV_blank>use<S2SV_blank>-c<S2SV_blank>to<S2SV_blank>increase.\\n"" ) ; exit ( EXIT_FAILURE ) ; } if ( pid_file != NULL ) { save_pid ( pid_file ) ; } if ( settings . drop_privileges ) { drop_privileges ( ) ; } uriencode_init ( ) ; if ( event_base_loop ( main_base , 0 ) != 0 ) { retval = EXIT_FAILURE ; } stop_assoc_maintenance_thread ( ) ; if ( do_daemonize ) remove_pidfile ( pid_file ) ; if ( settings . inter ) free ( settings . inter ) ; if ( l_socket ) free ( l_socket ) ; if ( u_socket ) free ( u_socket ) ; event_base_free ( main_base ) ; return retval ; }",if ( udp_specified && settings . udpport != 0 && ! tcp_specified ) {,222
317,"buggy line: RAnalOp next_op ;avr_op_analyze ( anal , & next_op , op -> addr + op -> size , buf + op -> size , len - op -> size , cpu ) ;cwe id:CWE-125context: INST_HANDLER ( sbrx ) { int b = buf [ 0 ] & 0x7 ; int r = ( ( buf [ 0 ] >> 4 ) & 0xf ) | ( ( buf [ 1 ] & 0x01 ) << 4 ) ;  RAnalOp next_op ;  avr_op_analyze ( anal , & next_op , op -> addr + op -> size , buf + op -> size , len - op -> size , cpu ) ; r_strbuf_fini ( & next_op . esil ) ; op -> jump = op -> addr + next_op . size + 2 ; op -> cycles = 1 ; ESIL_A ( ""%d,1,<<,r%d,&,"" , b , r ) ; ESIL_A ( ( buf [ 1 ] & 0xe ) == 0xc ? ""!,"" : ""!,!,"" ) ; ESIL_A ( ""?{,%"" PFMT64d "",pc,=,},"" , op -> jump ) ; }","RAnalOp next_op = {0 };avr_op_analyze ( anal , & next_op , op -> addr + op -> size , buf + op -> size , len - op -> size , cpu ) ;",223
318,"buggy line: px -> ft -> data = px ;px -> ft -> accept = prpl_xfer_accept ;cwe id:CWE-476context: static gboolean prplcb_xfer_new_send_cb ( gpointer data , gint fd , b_input_condition cond ) { PurpleXfer * xfer = data ; struct im_connection * ic = purple_ic_by_pa ( xfer -> account ) ; struct prpl_xfer_data * px = xfer -> ui_data ; PurpleBuddy * buddy ; const char * who ; buddy = purple_find_buddy ( xfer -> account , xfer -> who ) ; who = buddy ? purple_buddy_get_name ( buddy ) : xfer -> who ; px -> ft = imcb_file_send_start ( ic , ( char * ) who , xfer -> filename , xfer -> size ) ;  px -> ft -> data = px ;  px -> ft -> accept = prpl_xfer_accept ; px -> ft -> canceled = prpl_xfer_canceled ; px -> ft -> free = prpl_xfer_free ; px -> ft -> write_request = prpl_xfer_write_request ; return FALSE ; }",if ( ! px -> ft ) {return FALSE ;}px -> ft -> data = px ;px -> ft -> accept = prpl_xfer_accept ;,224
319,"buggy line: int ret = 0 , found = 0 ;char * repo_config = NULL ;cwe id:CWE-000context: int perf_config ( config_fn_t fn , void * data ) {  int ret = 0 , found = 0 ;  char * repo_config = NULL ; const char * home = NULL ; if ( config_exclusive_filename ) return perf_config_from_file ( fn , config_exclusive_filename , data ) ; if ( perf_config_system ( ) && ! access ( perf_etc_perfconfig ( ) , R_OK ) ) { ret += perf_config_from_file ( fn , perf_etc_perfconfig ( ) , data ) ; found += 1 ; } home = getenv ( ""HOME"" ) ; if ( perf_config_global ( ) && home ) { char * user_config = strdup ( mkpath ( ""%s/.perfconfig"" , home ) ) ; if ( ! access ( user_config , R_OK ) ) { ret += perf_config_from_file ( fn , user_config , data ) ; found += 1 ; } free ( user_config ) ; }  repo_config = perf_pathdup ( ""config"" ) ;  if ( ! access ( repo_config , R_OK ) ) { ret += perf_config_from_file ( fn , repo_config , data ) ; found += 1 ; } free ( repo_config ) ; if ( found == 0 ) return - 1 ; return ret ; }","int ret = 0 , found = 0 ;",225
320,"buggy line: repo_config = perf_pathdup ( ""config"" ) ;if ( ! access ( repo_config , R_OK ) ) {ret += perf_config_from_file ( fn , repo_config , data ) ;found += 1 ;}free ( repo_config ) ;cwe id:CWE-000context: int perf_config ( config_fn_t fn , void * data ) {  int ret = 0 , found = 0 ;  char * repo_config = NULL ; const char * home = NULL ; if ( config_exclusive_filename ) return perf_config_from_file ( fn , config_exclusive_filename , data ) ; if ( perf_config_system ( ) && ! access ( perf_etc_perfconfig ( ) , R_OK ) ) { ret += perf_config_from_file ( fn , perf_etc_perfconfig ( ) , data ) ; found += 1 ; } home = getenv ( ""HOME"" ) ; if ( perf_config_global ( ) && home ) { char * user_config = strdup ( mkpath ( ""%s/.perfconfig"" , home ) ) ; if ( ! access ( user_config , R_OK ) ) { ret += perf_config_from_file ( fn , user_config , data ) ; found += 1 ; } free ( user_config ) ; }  repo_config = perf_pathdup ( ""config"" ) ;  if ( ! access ( repo_config , R_OK ) ) { ret += perf_config_from_file ( fn , repo_config , data ) ; found += 1 ; } free ( repo_config ) ; if ( found == 0 ) return - 1 ; return ret ; }","
",225
321,"buggy line: static int  validate_event ( struct pmu_hw_events * hw_events ,  struct perf_event * event ) {struct arm_pmu * armpmu = to_arm_pmu ( event -> pmu ) ;struct hw_perf_event fake_event = event -> hw ;if ( event -> pmu != leader_pmu || event -> state < PERF_EVENT_STATE_OFF )  return 1 ;return armpmu -> get_event_idx ( hw_events , & fake_event ) >= 0 ;}cwe id:CWE-264context: static int  validate_event ( struct pmu_hw_events * hw_events ,  struct perf_event * event ) {  struct arm_pmu * armpmu = to_arm_pmu ( event -> pmu ) ;  struct hw_perf_event fake_event = event -> hw ; struct pmu * leader_pmu = event -> group_leader -> pmu ; if ( is_software_event ( event ) ) return 1 ;  if ( event -> pmu != leader_pmu || event -> state < PERF_EVENT_STATE_OFF )  return 1 ; if ( event -> state == PERF_EVENT_STATE_OFF && ! event -> attr . enable_on_exec ) return 1 ;  return armpmu -> get_event_idx ( hw_events , & fake_event ) >= 0 ;  }","static int validate_event ( struct pmu * pmu , struct pmu_hw_events * hw_events , struct perf_event * event ) {struct arm_pmu * armpmu ;struct hw_perf_event fake_event = event -> hw ;if ( event -> pmu != pmu ) return 0 ;if ( event -> pmu != leader_pmu || event -> state < PERF_EVENT_STATE_OFF ) return 1 ;armpmu = to_arm_pmu ( event -> pmu ) ;return armpmu -> get_event_idx ( hw_events , & fake_event ) >= 0 ;}",226
322,"buggy line: static bool new_idmap_permitted ( struct user_namespace * ns , int cap_setid ,  struct uid_gid_map * new_map ) {cwe id:CWE-264context:  static bool new_idmap_permitted ( struct user_namespace * ns , int cap_setid ,  struct uid_gid_map * new_map ) { if ( ( new_map -> nr_extents == 1 ) && ( new_map -> extent [ 0 ] . count == 1 ) ) { u32 id = new_map -> extent [ 0 ] . lower_first ; if ( cap_setid == CAP_SETUID ) { kuid_t uid = make_kuid ( ns -> parent , id ) ; if ( uid_eq ( uid , current_fsuid ( ) ) ) return true ; } else if ( cap_setid == CAP_SETGID ) { kgid_t gid = make_kgid ( ns -> parent , id ) ; if ( gid_eq ( gid , current_fsgid ( ) ) ) return true ; } } if ( ! cap_valid ( cap_setid ) ) return true ;  if ( ns_capable ( ns -> parent , cap_setid ) )  return true ; return false ; }","static bool new_idmap_permitted ( const struct file * file , struct user_namespace * ns , int cap_setid , struct uid_gid_map * new_map ) {",227
323,"buggy line: if ( ns_capable ( ns -> parent , cap_setid ) )  return true ;cwe id:CWE-264context:  static bool new_idmap_permitted ( struct user_namespace * ns , int cap_setid ,  struct uid_gid_map * new_map ) { if ( ( new_map -> nr_extents == 1 ) && ( new_map -> extent [ 0 ] . count == 1 ) ) { u32 id = new_map -> extent [ 0 ] . lower_first ; if ( cap_setid == CAP_SETUID ) { kuid_t uid = make_kuid ( ns -> parent , id ) ; if ( uid_eq ( uid , current_fsuid ( ) ) ) return true ; } else if ( cap_setid == CAP_SETGID ) { kgid_t gid = make_kgid ( ns -> parent , id ) ; if ( gid_eq ( gid , current_fsgid ( ) ) ) return true ; } } if ( ! cap_valid ( cap_setid ) ) return true ;  if ( ns_capable ( ns -> parent , cap_setid ) )  return true ; return false ; }","if ( ns_capable ( ns -> parent , cap_setid ) && file_ns_capable ( file , ns -> parent , cap_setid ) ) return true ;",227
324,"buggy line: j ++ )  {body [ j ] = XMALLOC ( VarLenData , 1 ) ;return body ;}cwe id:CWE-125context: static VarLenData * * get_html_data ( MAPI_Attr * a ) { VarLenData * * body = XCALLOC ( VarLenData * , a -> num_values + 1 ) ; int j ; for ( j = 0 ; j < a -> num_values ; j ++ )  {  body [ j ] = XMALLOC ( VarLenData , 1 ) ; body [ j ] -> len = a -> values [ j ] . len ; body [ j ] -> data = CHECKED_XCALLOC ( unsigned char , a -> values [ j ] . len ) ; memmove ( body [ j ] -> data , a -> values [ j ] . data . buf , body [ j ] -> len ) ; }  return body ;  }","j ++ ) {if ( a -> type == szMAPI_BINARY ) {body [ j ] = XMALLOC ( VarLenData , 1 ) ;}return body ;}",228
325,"buggy line: u8 reset ;int ret , pos = 0 ;hx = kmalloc ( sizeof ( * hx ) , GFP_KERNEL ) ;if ( ! hx ) return - ENOMEM ;reset = 1 ;if ( ( ret = usb_cypress_writemem ( udev , cypress [ type ] . cpu_cs_register , & reset , 1 ) ) != 1 )  err ( ""could<S2SV_blank>not<S2SV_blank>stop<S2SV_blank>the<S2SV_blank>USB<S2SV_blank>controller<S2SV_blank>CPU."" ) ;cwe id:CWE-119context: int usb_cypress_load_firmware ( struct usb_device * udev , const struct firmware * fw , int type ) { struct hexline * hx ;  u8 reset ;  int ret , pos = 0 ;  hx = kmalloc ( sizeof ( * hx ) , GFP_KERNEL ) ;  if ( ! hx ) return - ENOMEM ; reset = 1 ;  if ( ( ret = usb_cypress_writemem ( udev , cypress [ type ] . cpu_cs_register , & reset , 1 ) ) != 1 )  err ( ""could<S2SV_blank>not<S2SV_blank>stop<S2SV_blank>the<S2SV_blank>USB<S2SV_blank>controller<S2SV_blank>CPU."" ) ; while ( ( ret = dvb_usb_get_hexline ( fw , hx , & pos ) ) > 0 ) { deb_fw ( ""writing<S2SV_blank>to<S2SV_blank>address<S2SV_blank>0x%04x<S2SV_blank>(buffer:<S2SV_blank>0x%02x<S2SV_blank>%02x)\\n"" , hx -> addr , hx -> len , hx -> chk ) ; ret = usb_cypress_writemem ( udev , hx -> addr , hx -> data , hx -> len ) ; if ( ret != hx -> len ) { err ( ""error<S2SV_blank>while<S2SV_blank>transferring<S2SV_blank>firmware<S2SV_blank>(transferred<S2SV_blank>size:<S2SV_blank>%d,<S2SV_blank>block<S2SV_blank>size:<S2SV_blank>%d)"" , ret , hx -> len ) ; ret = - EINVAL ; break ; } } if ( ret < 0 ) { err ( ""firmware<S2SV_blank>download<S2SV_blank>failed<S2SV_blank>at<S2SV_blank>%d<S2SV_blank>with<S2SV_blank>%d"" , pos , ret ) ;  kfree ( hx ) ;  return ret ; } if ( ret == 0 ) {  reset = 0 ;   if ( ret || usb_cypress_writemem ( udev , cypress [ type ] . cpu_cs_register , & reset , 1 ) != 1 ) {  err ( ""could<S2SV_blank>not<S2SV_blank>restart<S2SV_blank>the<S2SV_blank>USB<S2SV_blank>controller<S2SV_blank>CPU."" ) ; ret = - EINVAL ; } } else ret = - EIO ;  kfree ( hx ) ;  return ret ; }","u8 * buf ;int ret , pos = 0 ;u16 cpu_cs_register = cypress [ type ] . cpu_cs_register , & reset , 1 ) ) != 1 ) err ( ""could<S2SV_blank>not<S2SV_blank>stop<S2SV_blank>the<S2SV_blank>USB<S2SV_blank>controller<S2SV_blank>CPU."" ) ;",229
326,"buggy line: kfree ( hx ) ;return ret ;reset = 0 ;if ( ret || usb_cypress_writemem ( udev , cypress [ type ] . cpu_cs_register , & reset , 1 ) != 1 ) {err ( ""could<S2SV_blank>not<S2SV_blank>restart<S2SV_blank>the<S2SV_blank>USB<S2SV_blank>controller<S2SV_blank>CPU."" ) ;kfree ( hx ) ;return ret ;cwe id:CWE-119context: int usb_cypress_load_firmware ( struct usb_device * udev , const struct firmware * fw , int type ) { struct hexline * hx ;  u8 reset ;  int ret , pos = 0 ;  hx = kmalloc ( sizeof ( * hx ) , GFP_KERNEL ) ;  if ( ! hx ) return - ENOMEM ; reset = 1 ;  if ( ( ret = usb_cypress_writemem ( udev , cypress [ type ] . cpu_cs_register , & reset , 1 ) ) != 1 )  err ( ""could<S2SV_blank>not<S2SV_blank>stop<S2SV_blank>the<S2SV_blank>USB<S2SV_blank>controller<S2SV_blank>CPU."" ) ; while ( ( ret = dvb_usb_get_hexline ( fw , hx , & pos ) ) > 0 ) { deb_fw ( ""writing<S2SV_blank>to<S2SV_blank>address<S2SV_blank>0x%04x<S2SV_blank>(buffer:<S2SV_blank>0x%02x<S2SV_blank>%02x)\\n"" , hx -> addr , hx -> len , hx -> chk ) ; ret = usb_cypress_writemem ( udev , hx -> addr , hx -> data , hx -> len ) ; if ( ret != hx -> len ) { err ( ""error<S2SV_blank>while<S2SV_blank>transferring<S2SV_blank>firmware<S2SV_blank>(transferred<S2SV_blank>size:<S2SV_blank>%d,<S2SV_blank>block<S2SV_blank>size:<S2SV_blank>%d)"" , ret , hx -> len ) ; ret = - EINVAL ; break ; } } if ( ret < 0 ) { err ( ""firmware<S2SV_blank>download<S2SV_blank>failed<S2SV_blank>at<S2SV_blank>%d<S2SV_blank>with<S2SV_blank>%d"" , pos , ret ) ;  kfree ( hx ) ;  return ret ; } if ( ret == 0 ) {  reset = 0 ;   if ( ret || usb_cypress_writemem ( udev , cypress [ type ] . cpu_cs_register , & reset , 1 ) != 1 ) {  err ( ""could<S2SV_blank>not<S2SV_blank>restart<S2SV_blank>the<S2SV_blank>USB<S2SV_blank>controller<S2SV_blank>CPU."" ) ; ret = - EINVAL ; } } else ret = - EIO ;  kfree ( hx ) ;  return ret ; }","kfree ( hx ) ;return ret ;reset = 0 ;if ( ret || usb_cypress_writemem ( udev , cypress [ type ] . cpu_cs_register ;buf = kmalloc ( sizeof ( * hx ) , GFP_KERNEL ) ;if ( ! buf ) return - ENOMEM ;hx = ( struct hexline * ) buf ;buf [ 0 ] = 1 ;if ( usb_cypress_writemem ( udev , cpu_cs_register , buf , 1 ) != 1 ) {err ( ""could<S2SV_blank>not<S2SV_blank>restart<S2SV_blank>the<S2SV_blank>USB<S2SV_blank>controller<S2SV_blank>CPU."" ) ;kfree ( buf ) ;return ret ;",229
327,"buggy line: static void  l2tp_call_errors_print ( netdissect_options * ndo , const u_char * dat )  {ptr ++ ;val_h = EXTRACT_16BITS ( ptr ) ;val_h = EXTRACT_16BITS ( ptr ) ;val_l = EXTRACT_16BITS ( ptr ) ;val_h = EXTRACT_16BITS ( ptr ) ;val_l = EXTRACT_16BITS ( ptr ) ;val_h = EXTRACT_16BITS ( ptr ) ;val_l = EXTRACT_16BITS ( ptr ) ;val_h = EXTRACT_16BITS ( ptr ) ;val_l = EXTRACT_16BITS ( ptr ) ;val_h = EXTRACT_16BITS ( ptr ) ;val_l = EXTRACT_16BITS ( ptr ) ;cwe id:CWE-125context: static void  l2tp_call_errors_print ( netdissect_options * ndo , const u_char * dat )  { const uint16_t * ptr = ( const uint16_t * ) dat ; uint16_t val_h , val_l ;  ptr ++ ;  val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; ND_PRINT ( ( ndo , ""CRCErr=%u<S2SV_blank>"" , ( val_h << 16 ) + val_l ) ) ;  val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ;  val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; ND_PRINT ( ( ndo , ""FrameErr=%u<S2SV_blank>"" , ( val_h << 16 ) + val_l ) ) ;  val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ;  val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; ND_PRINT ( ( ndo , ""HardOver=%u<S2SV_blank>"" , ( val_h << 16 ) + val_l ) ) ;  val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ;  val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; ND_PRINT ( ( ndo , ""BufOver=%u<S2SV_blank>"" , ( val_h << 16 ) + val_l ) ) ;  val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ;  val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; ND_PRINT ( ( ndo , ""Timeout=%u<S2SV_blank>"" , ( val_h << 16 ) + val_l ) ) ;  val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ;  val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; ND_PRINT ( ( ndo , ""AlignErr=%u<S2SV_blank>"" , ( val_h << 16 ) + val_l ) ) ; }","static void l2tp_call_errors_print ( netdissect_options * ndo , const u_char * dat , u_int length ) {if ( length < 2 ) {ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;return ;}ptr ++ ;length -= 2 ;if ( length < 4 ) {ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;if ( length < 4 ) {ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;return ;}val_h = EXTRACT_16BITS ( ptr ) ;length -= 2 ;length -= 2 ;if ( length < 4 ) {ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;return ;}val_h = EXTRACT_16BITS ( ptr ) ;length -= 2 ;val_l = EXTRACT_16BITS ( ptr ) ;length -= 2 ;if ( length < 4 ) {ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;return ;}val_h = EXTRACT_16BITS ( ptr ) ;length -= 2 ;val_l = EXTRACT_16BITS ( ptr ) ;length -= 2 ;if ( length < 4 ) {ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;if ( length < 4 ) {ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;return ;}return ;}val_h = EXTRACT_16BITS ( ptr ) ;length -= 2 ;val_l = EXTRACT_16BITS ( ptr ) ;length -= 2 ;val_h = EXTRACT_16BITS ( ptr ) ;val_l = EXTRACT_16BITS ( ptr ) ;val_h = EXTRACT_16BITS ( ptr ) ;val_l = EXTRACT_16BITS ( ptr ) ;",230
328,"buggy line: if ( strncmp ( handle -> params . realm , realm -> data , realm -> length ) == 0  && strncmp ( ""kadmin"" , c1 -> data , c1 -> length ) == 0 ) {if ( strncmp ( ""history"" , c2 -> data , c2 -> length ) == 0 ) goto fail_princ ;else success = 1 ;}cwe id:CWE-284context: static int check_rpcsec_auth ( struct svc_req * rqstp ) { gss_ctx_id_t ctx ; krb5_context kctx ; OM_uint32 maj_stat , min_stat ; gss_name_t name ; krb5_principal princ ; int ret , success ; krb5_data * c1 , * c2 , * realm ; gss_buffer_desc gss_str ; kadm5_server_handle_t handle ; size_t slen ; char * sdots ; success = 0 ; handle = ( kadm5_server_handle_t ) global_server_handle ; if ( rqstp -> rq_cred . oa_flavor != RPCSEC_GSS ) return 0 ; ctx = rqstp -> rq_svccred ; maj_stat = gss_inquire_context ( & min_stat , ctx , NULL , & name , NULL , NULL , NULL , NULL , NULL ) ; if ( maj_stat != GSS_S_COMPLETE ) { krb5_klog_syslog ( LOG_ERR , _ ( ""check_rpcsec_auth:<S2SV_blank>failed<S2SV_blank>"" ""inquire_context,<S2SV_blank>stat=%u"" ) , maj_stat ) ; log_badauth ( maj_stat , min_stat , rqstp -> rq_xprt , NULL ) ; goto fail_name ; } kctx = handle -> context ; ret = gss_to_krb5_name_1 ( rqstp , kctx , name , & princ , & gss_str ) ; if ( ret == 0 ) goto fail_name ; slen = gss_str . length ; trunc_name ( & slen , & sdots ) ; if ( krb5_princ_size ( kctx , princ ) != 2 ) goto fail_princ ; c1 = krb5_princ_component ( kctx , princ , 0 ) ; c2 = krb5_princ_component ( kctx , princ , 1 ) ; realm = krb5_princ_realm ( kctx , princ ) ;  if ( strncmp ( handle -> params . realm , realm -> data , realm -> length ) == 0  && strncmp ( ""kadmin"" , c1 -> data , c1 -> length ) == 0 ) { if ( strncmp ( ""history"" , c2 -> data , c2 -> length ) == 0 ) goto fail_princ ; else success = 1 ; } fail_princ : if ( ! success ) { krb5_klog_syslog ( LOG_ERR , _ ( ""bad<S2SV_blank>service<S2SV_blank>principal<S2SV_blank>%.*s%s"" ) , ( int ) slen , ( char * ) gss_str . value , sdots ) ; } gss_release_buffer ( & min_stat , & gss_str ) ; krb5_free_principal ( kctx , princ ) ; fail_name : gss_release_name ( & min_stat , & name ) ; return success ; }","success = data_eq_string ( * realm , handle -> params . realm ) && data_eq_string ( * c1 , ""kadmin"" ) && ! data_eq_string ( * c2 , ""history"" ) ;",231
329,"buggy line: if ( uniforms_offset < shader_rec_offset ||  exec_size < uniforms_offset || args -> shader_rec_count >= ( UINT_MAX / sizeof ( struct vc4_shader_state ) ) || temp_size < exec_size ) {cwe id:CWE-190context: static int vc4_get_bcl ( struct drm_device * dev , struct vc4_exec_info * exec ) { struct drm_vc4_submit_cl * args = exec -> args ; void * temp = NULL ; void * bin ; int ret = 0 ; uint32_t bin_offset = 0 ; uint32_t shader_rec_offset = roundup ( bin_offset + args -> bin_cl_size , 16 ) ; uint32_t uniforms_offset = shader_rec_offset + args -> shader_rec_size ; uint32_t exec_size = uniforms_offset + args -> uniforms_size ; uint32_t temp_size = exec_size + ( sizeof ( struct vc4_shader_state ) * args -> shader_rec_count ) ; struct vc4_bo * bo ;  if ( uniforms_offset < shader_rec_offset ||  exec_size < uniforms_offset || args -> shader_rec_count >= ( UINT_MAX / sizeof ( struct vc4_shader_state ) ) || temp_size < exec_size ) { DRM_ERROR ( ""overflow<S2SV_blank>in<S2SV_blank>exec<S2SV_blank>arguments\\n"" ) ; goto fail ; } temp = drm_malloc_ab ( temp_size , 1 ) ; if ( ! temp ) { DRM_ERROR ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>storage<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>"" ""in<S2SV_blank>bin/render<S2SV_blank>CLs.\\n"" ) ; ret = - ENOMEM ; goto fail ; } bin = temp + bin_offset ; exec -> shader_rec_u = temp + shader_rec_offset ; exec -> uniforms_u = temp + uniforms_offset ; exec -> shader_state = temp + exec_size ; exec -> shader_state_size = args -> shader_rec_count ; if ( copy_from_user ( bin , ( void __user * ) ( uintptr_t ) args -> bin_cl , args -> bin_cl_size ) ) { ret = - EFAULT ; goto fail ; } if ( copy_from_user ( exec -> shader_rec_u , ( void __user * ) ( uintptr_t ) args -> shader_rec , args -> shader_rec_size ) ) { ret = - EFAULT ; goto fail ; } if ( copy_from_user ( exec -> uniforms_u , ( void __user * ) ( uintptr_t ) args -> uniforms , args -> uniforms_size ) ) { ret = - EFAULT ; goto fail ; } bo = vc4_bo_create ( dev , exec_size , true ) ; if ( IS_ERR ( bo ) ) { DRM_ERROR ( ""Couldn\'t<S2SV_blank>allocate<S2SV_blank>BO<S2SV_blank>for<S2SV_blank>binning\\n"" ) ; ret = PTR_ERR ( bo ) ; goto fail ; } exec -> exec_bo = & bo -> base ; list_add_tail ( & to_vc4_bo ( & exec -> exec_bo -> base ) -> unref_head , & exec -> unref_list ) ; exec -> ct0ca = exec -> exec_bo -> paddr + bin_offset ; exec -> bin_u = bin ; exec -> shader_rec_v = exec -> exec_bo -> vaddr + shader_rec_offset ; exec -> shader_rec_p = exec -> exec_bo -> paddr + shader_rec_offset ; exec -> shader_rec_size = args -> shader_rec_size ; exec -> uniforms_v = exec -> exec_bo -> vaddr + uniforms_offset ; exec -> uniforms_p = exec -> exec_bo -> paddr + uniforms_offset ; exec -> uniforms_size = args -> uniforms_size ; ret = vc4_validate_bin_cl ( dev , exec -> exec_bo -> vaddr + bin_offset , bin , exec ) ; if ( ret ) goto fail ; ret = vc4_validate_shader_recs ( dev , exec ) ; if ( ret ) goto fail ; ret = vc4_wait_for_seqno ( dev , exec -> bin_dep_seqno , ~ 0ull , true ) ; fail : drm_free_large ( temp ) ; return ret ; }",if ( shader_rec_offset < args -> bin_cl_size || uniforms_offset < shader_rec_offset || exec_size < uniforms_offset || args -> shader_rec_count >= ( UINT_MAX / sizeof ( struct vc4_shader_state ) ) || temp_size < exec_size ) {,232
330,"buggy line: # endif  # if HAVA_LZMA_H && HAVE_LIBLZMA  if ( zip -> zipx_lzma_valid ) {cwe id:CWE-401context: static int archive_read_format_zip_cleanup ( struct archive_read * a ) { struct zip * zip ; struct zip_entry * zip_entry , * next_zip_entry ; zip = ( struct zip * ) ( a -> format -> data ) ; # ifdef HAVE_ZLIB_H if ( zip -> stream_valid ) inflateEnd ( & zip -> stream ) ; # endif  # if HAVA_LZMA_H && HAVE_LIBLZMA  if ( zip -> zipx_lzma_valid ) { lzma_end ( & zip -> zipx_lzma_stream ) ; } # endif # ifdef HAVE_BZLIB_H if ( zip -> bzstream_valid ) { BZ2_bzDecompressEnd ( & zip -> bzstream ) ; } # endif free ( zip -> uncompressed_buffer ) ; if ( zip -> ppmd8_valid ) __archive_ppmd8_functions . Ppmd8_Free ( & zip -> ppmd8 ) ; if ( zip -> zip_entries ) { zip_entry = zip -> zip_entries ; while ( zip_entry != NULL ) { next_zip_entry = zip_entry -> next ; archive_string_free ( & zip_entry -> rsrcname ) ; free ( zip_entry ) ; zip_entry = next_zip_entry ; } } free ( zip -> decrypted_buffer ) ; if ( zip -> cctx_valid ) archive_decrypto_aes_ctr_release ( & zip -> cctx ) ; if ( zip -> hctx_valid ) archive_hmac_sha1_cleanup ( & zip -> hctx ) ; free ( zip -> iv ) ; free ( zip -> erd ) ; free ( zip -> v_data ) ; archive_string_free ( & zip -> format_name ) ; free ( zip ) ; ( a -> format -> data ) = NULL ; return ( ARCHIVE_OK ) ; }",# endif # if HAVE_LZMA_H && HAVE_LIBLZMA if ( zip -> zipx_lzma_valid ) {,233
331,"buggy line: struct file * file = vma -> vm_file ;file_update_time ( vma -> vm_file ) ;if ( test_opt ( inode -> i_sb , DELALLOC ) && ! ext4_should_journal_data ( inode ) && ! ext4_nonda_switch ( inode -> i_sb ) ) {cwe id:CWE-362context: int ext4_page_mkwrite ( struct vm_area_struct * vma , struct vm_fault * vmf ) { struct page * page = vmf -> page ; loff_t size ; unsigned long len ; int ret ; struct file * file = vma -> vm_file ; struct inode * inode = file_inode ( file ) ; struct address_space * mapping = inode -> i_mapping ; handle_t * handle ; get_block_t * get_block ; int retries = 0 ; sb_start_pagefault ( inode -> i_sb ) ;  file_update_time ( vma -> vm_file ) ;  if ( test_opt ( inode -> i_sb , DELALLOC ) && ! ext4_should_journal_data ( inode ) && ! ext4_nonda_switch ( inode -> i_sb ) ) { do { ret = block_page_mkwrite ( vma , vmf , ext4_da_get_block_prep ) ; } while ( ret == - ENOSPC && ext4_should_retry_alloc ( inode -> i_sb , & retries ) ) ; goto out_ret ; } lock_page ( page ) ; size = i_size_read ( inode ) ; if ( page -> mapping != mapping || page_offset ( page ) > size ) { unlock_page ( page ) ; ret = VM_FAULT_NOPAGE ; goto out ; } if ( page -> index == size >> PAGE_CACHE_SHIFT ) len = size & ~ PAGE_CACHE_MASK ; else len = PAGE_CACHE_SIZE ; if ( page_has_buffers ( page ) ) { if ( ! ext4_walk_page_buffers ( NULL , page_buffers ( page ) , 0 , len , NULL , ext4_bh_unmapped ) ) { wait_for_stable_page ( page ) ; ret = VM_FAULT_LOCKED ; goto out ; } } unlock_page ( page ) ; if ( ext4_should_dioread_nolock ( inode ) ) get_block = ext4_get_block_write ; else get_block = ext4_get_block ; retry_alloc : handle = ext4_journal_start ( inode , EXT4_HT_WRITE_PAGE , ext4_writepage_trans_blocks ( inode ) ) ; if ( IS_ERR ( handle ) ) { ret = VM_FAULT_SIGBUS ; goto out ; } ret = block_page_mkwrite ( vma , vmf , get_block ) ; if ( ! ret && ext4_should_journal_data ( inode ) ) { if ( ext4_walk_page_buffers ( handle , page_buffers ( page ) , 0 , PAGE_CACHE_SIZE , NULL , do_journal_get_write_access ) ) { unlock_page ( page ) ; ret = VM_FAULT_SIGBUS ; ext4_journal_stop ( handle ) ; goto out ; } ext4_set_inode_state ( inode , EXT4_STATE_JDATA ) ; } ext4_journal_stop ( handle ) ; if ( ret == - ENOSPC && ext4_should_retry_alloc ( inode -> i_sb , & retries ) ) goto retry_alloc ; out_ret : ret = block_page_mkwrite_return ( ret ) ; out :  sb_end_pagefault ( inode -> i_sb ) ;  return ret ; }","struct file * file = vma -> vm_file ) ;down_read ( & EXT4_I ( inode ) -> i_mmap_sem ;file_update_time ( vma -> vm_file ) ;if ( test_opt ( inode -> i_sb , DELALLOC ) && ! ext4_should_journal_data ( inode ) && ! ext4_nonda_switch ( inode -> i_sb ) ) {",234
332,"buggy line: out :  sb_end_pagefault ( inode -> i_sb ) ;return ret ;cwe id:CWE-362context: int ext4_page_mkwrite ( struct vm_area_struct * vma , struct vm_fault * vmf ) { struct page * page = vmf -> page ; loff_t size ; unsigned long len ; int ret ; struct file * file = vma -> vm_file ; struct inode * inode = file_inode ( file ) ; struct address_space * mapping = inode -> i_mapping ; handle_t * handle ; get_block_t * get_block ; int retries = 0 ; sb_start_pagefault ( inode -> i_sb ) ;  file_update_time ( vma -> vm_file ) ;  if ( test_opt ( inode -> i_sb , DELALLOC ) && ! ext4_should_journal_data ( inode ) && ! ext4_nonda_switch ( inode -> i_sb ) ) { do { ret = block_page_mkwrite ( vma , vmf , ext4_da_get_block_prep ) ; } while ( ret == - ENOSPC && ext4_should_retry_alloc ( inode -> i_sb , & retries ) ) ; goto out_ret ; } lock_page ( page ) ; size = i_size_read ( inode ) ; if ( page -> mapping != mapping || page_offset ( page ) > size ) { unlock_page ( page ) ; ret = VM_FAULT_NOPAGE ; goto out ; } if ( page -> index == size >> PAGE_CACHE_SHIFT ) len = size & ~ PAGE_CACHE_MASK ; else len = PAGE_CACHE_SIZE ; if ( page_has_buffers ( page ) ) { if ( ! ext4_walk_page_buffers ( NULL , page_buffers ( page ) , 0 , len , NULL , ext4_bh_unmapped ) ) { wait_for_stable_page ( page ) ; ret = VM_FAULT_LOCKED ; goto out ; } } unlock_page ( page ) ; if ( ext4_should_dioread_nolock ( inode ) ) get_block = ext4_get_block_write ; else get_block = ext4_get_block ; retry_alloc : handle = ext4_journal_start ( inode , EXT4_HT_WRITE_PAGE , ext4_writepage_trans_blocks ( inode ) ) ; if ( IS_ERR ( handle ) ) { ret = VM_FAULT_SIGBUS ; goto out ; } ret = block_page_mkwrite ( vma , vmf , get_block ) ; if ( ! ret && ext4_should_journal_data ( inode ) ) { if ( ext4_walk_page_buffers ( handle , page_buffers ( page ) , 0 , PAGE_CACHE_SIZE , NULL , do_journal_get_write_access ) ) { unlock_page ( page ) ; ret = VM_FAULT_SIGBUS ; ext4_journal_stop ( handle ) ; goto out ; } ext4_set_inode_state ( inode , EXT4_STATE_JDATA ) ; } ext4_journal_stop ( handle ) ; if ( ret == - ENOSPC && ext4_should_retry_alloc ( inode -> i_sb , & retries ) ) goto retry_alloc ; out_ret : ret = block_page_mkwrite_return ( ret ) ; out :  sb_end_pagefault ( inode -> i_sb ) ;  return ret ; }",out : up_read ( & EXT4_I ( inode ) -> i_mmap_sem ) ;sb_end_pagefault ( inode -> i_sb ) ;return ret ;,234
333,"buggy line: ulonglong tmp ;if ( jas_iccgetuint ( in , 8 , & tmp ) ) return - 1 ;cwe id:CWE-190context: static int jas_iccgetuint64 ( jas_stream_t * in , jas_iccuint64_t * val ) {  ulonglong tmp ;  if ( jas_iccgetuint ( in , 8 , & tmp ) ) return - 1 ; * val = tmp ; return 0 ; }","jas_ulonglong tmp ;if ( jas_iccgetuint ( in , 8 , & tmp ) ) return - 1 ;",235
334,"buggy line: r_return_val_if_fail ( arg , NULL ) ;char * a = malloc ( strlen ( arg ) + 1 ) ;if ( ! a ) {return NULL ;}char * b = a ;while ( * arg ) {switch ( * arg ) {case '@' : case '`' : case '|' : case ';' :  case '\\\default :  * b ++ = * arg ;break ;cwe id:CWE-78context: static char * __filterShell ( const char * arg ) { r_return_val_if_fail ( arg , NULL ) ; char * a = malloc ( strlen ( arg ) + 1 ) ; if ( ! a ) { return NULL ; } char * b = a ; while ( * arg ) {  switch ( * arg ) {  case '@' : case '`' : case '|' : case ';' :  case '\\n' :  break ; default :  * b ++ = * arg ;  break ; } arg ++ ; } * b = 0 ; return a ; }",char ch = * arg ;switch ( ch ) {case '@' : case '`' : case '|' : case ';' : case '=' : case '\\\default : * b ++ = * arg ;break ;,236
335,"buggy line: if ( map && nmap ) {cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ,  map , nmap ) ;}else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ;cwe id:CWE-125context: static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , ""<S2SV_blank>#%d<S2SV_blank>id=%s<S2SV_blank>"" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , ""<S2SV_blank>#%d<S2SV_blank>id=%d<S2SV_blank>"" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) {  if ( map && nmap ) {   cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ,  map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }","if ( map && nmap ) cp = ikev1_attrmap_print ( ndo , cp , ep2 , map , nmap ) ;else cp = ikev1_attr_print ( ndo , cp , ep2 ) ;if ( cp == NULL ) goto trunc ;",237
336,"buggy line: static gboolean  accept_ice_connection ( GIOChannel * source , GIOCondition condition , GsmIceConnectionData * data ) {IceListenObj listener ;IceConn ice_conn ;IceAcceptStatus status ;GsmClient * client ;GsmXsmpServer * server ;listener = data -> listener ;server = data -> server ;g_debug ( ""GsmXsmpServer:<S2SV_blank>accept_ice_connection()"" ) ;ice_conn = IceAcceptConnection ( listener , & status ) ;if ( status != IceAcceptSuccess ) {g_debug ( ""GsmXsmpServer:<S2SV_blank>IceAcceptConnection<S2SV_blank>returned<S2SV_blank>%d"" , status ) ;return TRUE ;client = gsm_xsmp_client_new ( ice_conn ) ;ice_conn -> context = client ;gsm_store_add ( server -> priv -> client_store , gsm_client_peek_id ( client ) , G_OBJECT ( client ) ) ;g_object_unref ( client ) ;return TRUE ;cwe id:CWE-835context: G_DEFINE_TYPE ( GsmXsmpServer , gsm_xsmp_server , G_TYPE_OBJECT ) typedef struct { GsmXsmpServer * server ; IceListenObj listener ; } GsmIceConnectionData ;  static gboolean  accept_ice_connection ( GIOChannel * source , GIOCondition condition , GsmIceConnectionData * data ) { IceListenObj listener ; IceConn ice_conn ; IceAcceptStatus status ; GsmClient * client ; GsmXsmpServer * server ; listener = data -> listener ; server = data -> server ; g_debug ( ""GsmXsmpServer:<S2SV_blank>accept_ice_connection()"" ) ; ice_conn = IceAcceptConnection ( listener , & status ) ; if ( status != IceAcceptSuccess ) { g_debug ( ""GsmXsmpServer:<S2SV_blank>IceAcceptConnection<S2SV_blank>returned<S2SV_blank>%d"" , status ) ; return TRUE ; } client = gsm_xsmp_client_new ( ice_conn ) ;  ice_conn -> context = client ;  gsm_store_add ( server -> priv -> client_store , gsm_client_peek_id ( client ) , G_OBJECT ( client ) ) ; g_object_unref ( client ) ; return TRUE ; }","typedef struct {guint watch_id ;guint protocol_timeout ;GsmIceConnectionWatch ;static void disconnect_ice_connection ( IceConn ice_conn ) {IceSetShutdownNegotiation ( ice_conn , FALSE ) ;IceCloseConnection ( ice_conn ) ;",238
337,"buggy line: if ( ( skb_headroom ( skb ) < frag_hdr_sz ) &&  pskb_expand_head ( skb , frag_hdr_sz , 0 , GFP_ATOMIC ) ) goto out ;cwe id:CWE-399context: static struct sk_buff * udp6_ufo_fragment ( struct sk_buff * skb , u32 features ) { struct sk_buff * segs = ERR_PTR ( - EINVAL ) ; unsigned int mss ; unsigned int unfrag_ip6hlen , unfrag_len ; struct frag_hdr * fptr ; u8 * mac_start , * prevhdr ; u8 nexthdr ; u8 frag_hdr_sz = sizeof ( struct frag_hdr ) ; int offset ; __wsum csum ; mss = skb_shinfo ( skb ) -> gso_size ; if ( unlikely ( skb -> len <= mss ) ) goto out ; if ( skb_gso_ok ( skb , features | NETIF_F_GSO_ROBUST ) ) { int type = skb_shinfo ( skb ) -> gso_type ; if ( unlikely ( type & ~ ( SKB_GSO_UDP | SKB_GSO_DODGY ) || ! ( type & ( SKB_GSO_UDP ) ) ) ) goto out ; skb_shinfo ( skb ) -> gso_segs = DIV_ROUND_UP ( skb -> len , mss ) ; segs = NULL ; goto out ; } offset = skb -> csum_start - skb_headroom ( skb ) ; csum = skb_checksum ( skb , offset , skb -> len - offset , 0 ) ; offset += skb -> csum_offset ; * ( __sum16 * ) ( skb -> data + offset ) = csum_fold ( csum ) ; skb -> ip_summed = CHECKSUM_NONE ;  if ( ( skb_headroom ( skb ) < frag_hdr_sz ) &&  pskb_expand_head ( skb , frag_hdr_sz , 0 , GFP_ATOMIC ) ) goto out ; unfrag_ip6hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; nexthdr = * prevhdr ; * prevhdr = NEXTHDR_FRAGMENT ; unfrag_len = skb_network_header ( skb ) - skb_mac_header ( skb ) + unfrag_ip6hlen ; mac_start = skb_mac_header ( skb ) ; memmove ( mac_start - frag_hdr_sz , mac_start , unfrag_len ) ; skb -> mac_header -= frag_hdr_sz ; skb -> network_header -= frag_hdr_sz ; fptr = ( struct frag_hdr * ) ( skb_network_header ( skb ) + unfrag_ip6hlen ) ; fptr -> nexthdr = nexthdr ; fptr -> reserved = 0 ; ipv6_select_ident ( fptr ) ; segs = skb_segment ( skb , features ) ; out : return segs ; }","if ( ( skb_mac_header ( skb ) < skb -> head + frag_hdr_sz ) && pskb_expand_head ( skb , frag_hdr_sz , 0 , GFP_ATOMIC ) ) goto out ;",239
338,"buggy line: # ifdef GIT_WIN32  test_checkout_fails ( ""refs/heads/git_tilde1"" , "".git/foobar"" ) ;# endif  }cwe id:CWE-20context: void test_checkout_nasty__git_tilde1 ( void ) {  # ifdef GIT_WIN32  test_checkout_fails ( ""refs/heads/git_tilde1"" , "".git/foobar"" ) ;  # endif  }","test_checkout_fails ( ""refs/heads/git_tilde1"" , "".git/foobar"" ) ;test_checkout_fails ( ""refs/heads/git_tilde1"" , ""git~1/foobar"" ) ;}",240
339,"buggy line: case SO_DEBUG : v . val = sock_flag ( sk , SOCK_DBG ) ;cwe id:CWE-119context: int sock_getsockopt ( struct socket * sock , int level , int optname , char __user * optval , int __user * optlen ) { struct sock * sk = sock -> sk ; union { int val ; struct linger ling ; struct timeval tm ; } v ; int lv = sizeof ( int ) ; int len ; if ( get_user ( len , optlen ) ) return - EFAULT ; if ( len < 0 ) return - EINVAL ; memset ( & v , 0 , sizeof ( v ) ) ; switch ( optname ) { case SO_DEBUG : v . val = sock_flag ( sk , SOCK_DBG ) ; break ; case SO_DONTROUTE : v . val = sock_flag ( sk , SOCK_LOCALROUTE ) ; break ; case SO_BROADCAST : v . val = ! ! sock_flag ( sk , SOCK_BROADCAST ) ; break ; case SO_SNDBUF : v . val = sk -> sk_sndbuf ; break ; case SO_RCVBUF : v . val = sk -> sk_rcvbuf ; break ; case SO_REUSEADDR : v . val = sk -> sk_reuse ; break ; case SO_KEEPALIVE : v . val = ! ! sock_flag ( sk , SOCK_KEEPOPEN ) ; break ; case SO_TYPE : v . val = sk -> sk_type ; break ; case SO_PROTOCOL : v . val = sk -> sk_protocol ; break ; case SO_DOMAIN : v . val = sk -> sk_family ; break ; case SO_ERROR : v . val = - sock_error ( sk ) ; if ( v . val == 0 ) v . val = xchg ( & sk -> sk_err_soft , 0 ) ; break ; case SO_OOBINLINE : v . val = ! ! sock_flag ( sk , SOCK_URGINLINE ) ; break ; case SO_NO_CHECK : v . val = sk -> sk_no_check ; break ; case SO_PRIORITY : v . val = sk -> sk_priority ; break ; case SO_LINGER : lv = sizeof ( v . ling ) ; v . ling . l_onoff = ! ! sock_flag ( sk , SOCK_LINGER ) ; v . ling . l_linger = sk -> sk_lingertime / HZ ; break ; case SO_BSDCOMPAT : sock_warn_obsolete_bsdism ( ""getsockopt"" ) ; break ; case SO_TIMESTAMP : v . val = sock_flag ( sk , SOCK_RCVTSTAMP ) && ! sock_flag ( sk , SOCK_RCVTSTAMPNS ) ; break ; case SO_TIMESTAMPNS : v . val = sock_flag ( sk , SOCK_RCVTSTAMPNS ) ; break ; case SO_TIMESTAMPING : v . val = 0 ; if ( sock_flag ( sk , SOCK_TIMESTAMPING_TX_HARDWARE ) ) v . val |= SOF_TIMESTAMPING_TX_HARDWARE ; if ( sock_flag ( sk , SOCK_TIMESTAMPING_TX_SOFTWARE ) ) v . val |= SOF_TIMESTAMPING_TX_SOFTWARE ; if ( sock_flag ( sk , SOCK_TIMESTAMPING_RX_HARDWARE ) ) v . val |= SOF_TIMESTAMPING_RX_HARDWARE ; if ( sock_flag ( sk , SOCK_TIMESTAMPING_RX_SOFTWARE ) ) v . val |= SOF_TIMESTAMPING_RX_SOFTWARE ; if ( sock_flag ( sk , SOCK_TIMESTAMPING_SOFTWARE ) ) v . val |= SOF_TIMESTAMPING_SOFTWARE ; if ( sock_flag ( sk , SOCK_TIMESTAMPING_SYS_HARDWARE ) ) v . val |= SOF_TIMESTAMPING_SYS_HARDWARE ; if ( sock_flag ( sk , SOCK_TIMESTAMPING_RAW_HARDWARE ) ) v . val |= SOF_TIMESTAMPING_RAW_HARDWARE ; break ; case SO_RCVTIMEO : lv = sizeof ( struct timeval ) ; if ( sk -> sk_rcvtimeo == MAX_SCHEDULE_TIMEOUT ) { v . tm . tv_sec = 0 ; v . tm . tv_usec = 0 ; } else { v . tm . tv_sec = sk -> sk_rcvtimeo / HZ ; v . tm . tv_usec = ( ( sk -> sk_rcvtimeo % HZ ) * 1000000 ) / HZ ; } break ; case SO_SNDTIMEO : lv = sizeof ( struct timeval ) ; if ( sk -> sk_sndtimeo == MAX_SCHEDULE_TIMEOUT ) { v . tm . tv_sec = 0 ; v . tm . tv_usec = 0 ; } else { v . tm . tv_sec = sk -> sk_sndtimeo / HZ ; v . tm . tv_usec = ( ( sk -> sk_sndtimeo % HZ ) * 1000000 ) / HZ ; } break ; case SO_RCVLOWAT : v . val = sk -> sk_rcvlowat ; break ; case SO_SNDLOWAT : v . val = 1 ; break ; case SO_PASSCRED :  v . val = test_bit ( SOCK_PASSCRED , & sock -> flags ) ? 1 : 0 ;  break ; case SO_PEERCRED : { struct ucred peercred ; if ( len > sizeof ( peercred ) ) len = sizeof ( peercred ) ; cred_to_ucred ( sk -> sk_peer_pid , sk -> sk_peer_cred , & peercred ) ; if ( copy_to_user ( optval , & peercred , len ) ) return - EFAULT ; goto lenout ; } case SO_PEERNAME : { char address [ 128 ] ; if ( sock -> ops -> getname ( sock , ( struct sockaddr * ) address , & lv , 2 ) ) return - ENOTCONN ; if ( lv < len ) return - EINVAL ; if ( copy_to_user ( optval , address , len ) ) return - EFAULT ; goto lenout ; } case SO_ACCEPTCONN : v . val = sk -> sk_state == TCP_LISTEN ; break ; case SO_PASSSEC :  v . val = test_bit ( SOCK_PASSSEC , & sock -> flags ) ? 1 : 0 ;  break ; case SO_PEERSEC : return security_socket_getpeersec_stream ( sock , optval , optlen , len ) ; case SO_MARK : v . val = sk -> sk_mark ; break ; case SO_RXQ_OVFL : v . val = ! ! sock_flag ( sk , SOCK_RXQ_OVFL ) ; break ; case SO_WIFI_STATUS : v . val = ! ! sock_flag ( sk , SOCK_WIFI_STATUS ) ; break ; case SO_PEEK_OFF : if ( ! sock -> ops -> set_peek_off ) return - EOPNOTSUPP ; v . val = sk -> sk_peek_off ; break ; case SO_NOFCS : v . val = ! ! sock_flag ( sk , SOCK_NOFCS ) ; break ; default : return - ENOPROTOOPT ; } if ( len > lv ) len = lv ; if ( copy_to_user ( optval , & v , len ) ) return - EFAULT ; lenout : if ( put_user ( len , optlen ) ) return - EFAULT ; return 0 ; }","case SO_DEBUG : v . val = ! ! sock_flag ( sk , SOCK_DBG ) ;",241
340,"buggy line: case SO_PASSCRED :  v . val = test_bit ( SOCK_PASSCRED , & sock -> flags ) ? 1 : 0 ;break ;cwe id:CWE-119context: int sock_getsockopt ( struct socket * sock , int level , int optname , char __user * optval , int __user * optlen ) { struct sock * sk = sock -> sk ; union { int val ; struct linger ling ; struct timeval tm ; } v ; int lv = sizeof ( int ) ; int len ; if ( get_user ( len , optlen ) ) return - EFAULT ; if ( len < 0 ) return - EINVAL ; memset ( & v , 0 , sizeof ( v ) ) ; switch ( optname ) { case SO_DEBUG : v . val = sock_flag ( sk , SOCK_DBG ) ; break ; case SO_DONTROUTE : v . val = sock_flag ( sk , SOCK_LOCALROUTE ) ; break ; case SO_BROADCAST : v . val = ! ! sock_flag ( sk , SOCK_BROADCAST ) ; break ; case SO_SNDBUF : v . val = sk -> sk_sndbuf ; break ; case SO_RCVBUF : v . val = sk -> sk_rcvbuf ; break ; case SO_REUSEADDR : v . val = sk -> sk_reuse ; break ; case SO_KEEPALIVE : v . val = ! ! sock_flag ( sk , SOCK_KEEPOPEN ) ; break ; case SO_TYPE : v . val = sk -> sk_type ; break ; case SO_PROTOCOL : v . val = sk -> sk_protocol ; break ; case SO_DOMAIN : v . val = sk -> sk_family ; break ; case SO_ERROR : v . val = - sock_error ( sk ) ; if ( v . val == 0 ) v . val = xchg ( & sk -> sk_err_soft , 0 ) ; break ; case SO_OOBINLINE : v . val = ! ! sock_flag ( sk , SOCK_URGINLINE ) ; break ; case SO_NO_CHECK : v . val = sk -> sk_no_check ; break ; case SO_PRIORITY : v . val = sk -> sk_priority ; break ; case SO_LINGER : lv = sizeof ( v . ling ) ; v . ling . l_onoff = ! ! sock_flag ( sk , SOCK_LINGER ) ; v . ling . l_linger = sk -> sk_lingertime / HZ ; break ; case SO_BSDCOMPAT : sock_warn_obsolete_bsdism ( ""getsockopt"" ) ; break ; case SO_TIMESTAMP : v . val = sock_flag ( sk , SOCK_RCVTSTAMP ) && ! sock_flag ( sk , SOCK_RCVTSTAMPNS ) ; break ; case SO_TIMESTAMPNS : v . val = sock_flag ( sk , SOCK_RCVTSTAMPNS ) ; break ; case SO_TIMESTAMPING : v . val = 0 ; if ( sock_flag ( sk , SOCK_TIMESTAMPING_TX_HARDWARE ) ) v . val |= SOF_TIMESTAMPING_TX_HARDWARE ; if ( sock_flag ( sk , SOCK_TIMESTAMPING_TX_SOFTWARE ) ) v . val |= SOF_TIMESTAMPING_TX_SOFTWARE ; if ( sock_flag ( sk , SOCK_TIMESTAMPING_RX_HARDWARE ) ) v . val |= SOF_TIMESTAMPING_RX_HARDWARE ; if ( sock_flag ( sk , SOCK_TIMESTAMPING_RX_SOFTWARE ) ) v . val |= SOF_TIMESTAMPING_RX_SOFTWARE ; if ( sock_flag ( sk , SOCK_TIMESTAMPING_SOFTWARE ) ) v . val |= SOF_TIMESTAMPING_SOFTWARE ; if ( sock_flag ( sk , SOCK_TIMESTAMPING_SYS_HARDWARE ) ) v . val |= SOF_TIMESTAMPING_SYS_HARDWARE ; if ( sock_flag ( sk , SOCK_TIMESTAMPING_RAW_HARDWARE ) ) v . val |= SOF_TIMESTAMPING_RAW_HARDWARE ; break ; case SO_RCVTIMEO : lv = sizeof ( struct timeval ) ; if ( sk -> sk_rcvtimeo == MAX_SCHEDULE_TIMEOUT ) { v . tm . tv_sec = 0 ; v . tm . tv_usec = 0 ; } else { v . tm . tv_sec = sk -> sk_rcvtimeo / HZ ; v . tm . tv_usec = ( ( sk -> sk_rcvtimeo % HZ ) * 1000000 ) / HZ ; } break ; case SO_SNDTIMEO : lv = sizeof ( struct timeval ) ; if ( sk -> sk_sndtimeo == MAX_SCHEDULE_TIMEOUT ) { v . tm . tv_sec = 0 ; v . tm . tv_usec = 0 ; } else { v . tm . tv_sec = sk -> sk_sndtimeo / HZ ; v . tm . tv_usec = ( ( sk -> sk_sndtimeo % HZ ) * 1000000 ) / HZ ; } break ; case SO_RCVLOWAT : v . val = sk -> sk_rcvlowat ; break ; case SO_SNDLOWAT : v . val = 1 ; break ; case SO_PASSCRED :  v . val = test_bit ( SOCK_PASSCRED , & sock -> flags ) ? 1 : 0 ;  break ; case SO_PEERCRED : { struct ucred peercred ; if ( len > sizeof ( peercred ) ) len = sizeof ( peercred ) ; cred_to_ucred ( sk -> sk_peer_pid , sk -> sk_peer_cred , & peercred ) ; if ( copy_to_user ( optval , & peercred , len ) ) return - EFAULT ; goto lenout ; } case SO_PEERNAME : { char address [ 128 ] ; if ( sock -> ops -> getname ( sock , ( struct sockaddr * ) address , & lv , 2 ) ) return - ENOTCONN ; if ( lv < len ) return - EINVAL ; if ( copy_to_user ( optval , address , len ) ) return - EFAULT ; goto lenout ; } case SO_ACCEPTCONN : v . val = sk -> sk_state == TCP_LISTEN ; break ; case SO_PASSSEC :  v . val = test_bit ( SOCK_PASSSEC , & sock -> flags ) ? 1 : 0 ;  break ; case SO_PEERSEC : return security_socket_getpeersec_stream ( sock , optval , optlen , len ) ; case SO_MARK : v . val = sk -> sk_mark ; break ; case SO_RXQ_OVFL : v . val = ! ! sock_flag ( sk , SOCK_RXQ_OVFL ) ; break ; case SO_WIFI_STATUS : v . val = ! ! sock_flag ( sk , SOCK_WIFI_STATUS ) ; break ; case SO_PEEK_OFF : if ( ! sock -> ops -> set_peek_off ) return - EOPNOTSUPP ; v . val = sk -> sk_peek_off ; break ; case SO_NOFCS : v . val = ! ! sock_flag ( sk , SOCK_NOFCS ) ; break ; default : return - ENOPROTOOPT ; } if ( len > lv ) len = lv ; if ( copy_to_user ( optval , & v , len ) ) return - EFAULT ; lenout : if ( put_user ( len , optlen ) ) return - EFAULT ; return 0 ; }","case SO_PASSCRED : v . val = test_bit ( SOCK_PASSCRED , & sock -> flags ) ;break ;",241
341,"buggy line: case SO_ACCEPTCONN : v . val = sk -> sk_state == TCP_LISTEN ;case SO_PASSSEC :  v . val = test_bit ( SOCK_PASSSEC , & sock -> flags ) ? 1 : 0 ;break ;cwe id:CWE-119context: int sock_getsockopt ( struct socket * sock , int level , int optname , char __user * optval , int __user * optlen ) { struct sock * sk = sock -> sk ; union { int val ; struct linger ling ; struct timeval tm ; } v ; int lv = sizeof ( int ) ; int len ; if ( get_user ( len , optlen ) ) return - EFAULT ; if ( len < 0 ) return - EINVAL ; memset ( & v , 0 , sizeof ( v ) ) ; switch ( optname ) { case SO_DEBUG : v . val = sock_flag ( sk , SOCK_DBG ) ; break ; case SO_DONTROUTE : v . val = sock_flag ( sk , SOCK_LOCALROUTE ) ; break ; case SO_BROADCAST : v . val = ! ! sock_flag ( sk , SOCK_BROADCAST ) ; break ; case SO_SNDBUF : v . val = sk -> sk_sndbuf ; break ; case SO_RCVBUF : v . val = sk -> sk_rcvbuf ; break ; case SO_REUSEADDR : v . val = sk -> sk_reuse ; break ; case SO_KEEPALIVE : v . val = ! ! sock_flag ( sk , SOCK_KEEPOPEN ) ; break ; case SO_TYPE : v . val = sk -> sk_type ; break ; case SO_PROTOCOL : v . val = sk -> sk_protocol ; break ; case SO_DOMAIN : v . val = sk -> sk_family ; break ; case SO_ERROR : v . val = - sock_error ( sk ) ; if ( v . val == 0 ) v . val = xchg ( & sk -> sk_err_soft , 0 ) ; break ; case SO_OOBINLINE : v . val = ! ! sock_flag ( sk , SOCK_URGINLINE ) ; break ; case SO_NO_CHECK : v . val = sk -> sk_no_check ; break ; case SO_PRIORITY : v . val = sk -> sk_priority ; break ; case SO_LINGER : lv = sizeof ( v . ling ) ; v . ling . l_onoff = ! ! sock_flag ( sk , SOCK_LINGER ) ; v . ling . l_linger = sk -> sk_lingertime / HZ ; break ; case SO_BSDCOMPAT : sock_warn_obsolete_bsdism ( ""getsockopt"" ) ; break ; case SO_TIMESTAMP : v . val = sock_flag ( sk , SOCK_RCVTSTAMP ) && ! sock_flag ( sk , SOCK_RCVTSTAMPNS ) ; break ; case SO_TIMESTAMPNS : v . val = sock_flag ( sk , SOCK_RCVTSTAMPNS ) ; break ; case SO_TIMESTAMPING : v . val = 0 ; if ( sock_flag ( sk , SOCK_TIMESTAMPING_TX_HARDWARE ) ) v . val |= SOF_TIMESTAMPING_TX_HARDWARE ; if ( sock_flag ( sk , SOCK_TIMESTAMPING_TX_SOFTWARE ) ) v . val |= SOF_TIMESTAMPING_TX_SOFTWARE ; if ( sock_flag ( sk , SOCK_TIMESTAMPING_RX_HARDWARE ) ) v . val |= SOF_TIMESTAMPING_RX_HARDWARE ; if ( sock_flag ( sk , SOCK_TIMESTAMPING_RX_SOFTWARE ) ) v . val |= SOF_TIMESTAMPING_RX_SOFTWARE ; if ( sock_flag ( sk , SOCK_TIMESTAMPING_SOFTWARE ) ) v . val |= SOF_TIMESTAMPING_SOFTWARE ; if ( sock_flag ( sk , SOCK_TIMESTAMPING_SYS_HARDWARE ) ) v . val |= SOF_TIMESTAMPING_SYS_HARDWARE ; if ( sock_flag ( sk , SOCK_TIMESTAMPING_RAW_HARDWARE ) ) v . val |= SOF_TIMESTAMPING_RAW_HARDWARE ; break ; case SO_RCVTIMEO : lv = sizeof ( struct timeval ) ; if ( sk -> sk_rcvtimeo == MAX_SCHEDULE_TIMEOUT ) { v . tm . tv_sec = 0 ; v . tm . tv_usec = 0 ; } else { v . tm . tv_sec = sk -> sk_rcvtimeo / HZ ; v . tm . tv_usec = ( ( sk -> sk_rcvtimeo % HZ ) * 1000000 ) / HZ ; } break ; case SO_SNDTIMEO : lv = sizeof ( struct timeval ) ; if ( sk -> sk_sndtimeo == MAX_SCHEDULE_TIMEOUT ) { v . tm . tv_sec = 0 ; v . tm . tv_usec = 0 ; } else { v . tm . tv_sec = sk -> sk_sndtimeo / HZ ; v . tm . tv_usec = ( ( sk -> sk_sndtimeo % HZ ) * 1000000 ) / HZ ; } break ; case SO_RCVLOWAT : v . val = sk -> sk_rcvlowat ; break ; case SO_SNDLOWAT : v . val = 1 ; break ; case SO_PASSCRED :  v . val = test_bit ( SOCK_PASSCRED , & sock -> flags ) ? 1 : 0 ;  break ; case SO_PEERCRED : { struct ucred peercred ; if ( len > sizeof ( peercred ) ) len = sizeof ( peercred ) ; cred_to_ucred ( sk -> sk_peer_pid , sk -> sk_peer_cred , & peercred ) ; if ( copy_to_user ( optval , & peercred , len ) ) return - EFAULT ; goto lenout ; } case SO_PEERNAME : { char address [ 128 ] ; if ( sock -> ops -> getname ( sock , ( struct sockaddr * ) address , & lv , 2 ) ) return - ENOTCONN ; if ( lv < len ) return - EINVAL ; if ( copy_to_user ( optval , address , len ) ) return - EFAULT ; goto lenout ; } case SO_ACCEPTCONN : v . val = sk -> sk_state == TCP_LISTEN ; break ; case SO_PASSSEC :  v . val = test_bit ( SOCK_PASSSEC , & sock -> flags ) ? 1 : 0 ;  break ; case SO_PEERSEC : return security_socket_getpeersec_stream ( sock , optval , optlen , len ) ; case SO_MARK : v . val = sk -> sk_mark ; break ; case SO_RXQ_OVFL : v . val = ! ! sock_flag ( sk , SOCK_RXQ_OVFL ) ; break ; case SO_WIFI_STATUS : v . val = ! ! sock_flag ( sk , SOCK_WIFI_STATUS ) ; break ; case SO_PEEK_OFF : if ( ! sock -> ops -> set_peek_off ) return - EOPNOTSUPP ; v . val = sk -> sk_peek_off ; break ; case SO_NOFCS : v . val = ! ! sock_flag ( sk , SOCK_NOFCS ) ; break ; default : return - ENOPROTOOPT ; } if ( len > lv ) len = lv ; if ( copy_to_user ( optval , & v , len ) ) return - EFAULT ; lenout : if ( put_user ( len , optlen ) ) return - EFAULT ; return 0 ; }","case SO_ACCEPTCONN : v . val = ! ! sk -> sk_state == TCP_LISTEN ;break ;case SO_PASSSEC : v . val = test_bit ( SOCK_PASSSEC , & sock -> flags ) ;",241
342,"buggy line: if ( sk -> sk_shutdown & RCV_SHUTDOWN ) {msg -> msg_namelen = 0 ;return 0 ;}cwe id:CWE-20context: int bt_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { int noblock = flags & MSG_DONTWAIT ; struct sock * sk = sock -> sk ; struct sk_buff * skb ; size_t copied ; int err ; BT_DBG ( ""sock<S2SV_blank>%p<S2SV_blank>sk<S2SV_blank>%p<S2SV_blank>len<S2SV_blank>%zu"" , sock , sk , len ) ; if ( flags & ( MSG_OOB ) ) return - EOPNOTSUPP ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) {  if ( sk -> sk_shutdown & RCV_SHUTDOWN ) {  msg -> msg_namelen = 0 ; return 0 ; } return err ; } copied = skb -> len ; if ( len < copied ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } skb_reset_transport_header ( skb ) ; err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err == 0 ) { sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( bt_sk ( sk ) -> skb_msg_name ) bt_sk ( sk ) -> skb_msg_name ( skb , msg -> msg_name , & msg -> msg_namelen ) ;  else  msg -> msg_namelen = 0 ; } skb_free_datagram ( sk , skb ) ; return err ? : copied ; }",if ( sk -> sk_shutdown & RCV_SHUTDOWN ) return 0 ;,242
343,"buggy line: else  msg -> msg_namelen = 0 ;cwe id:CWE-20context: int bt_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { int noblock = flags & MSG_DONTWAIT ; struct sock * sk = sock -> sk ; struct sk_buff * skb ; size_t copied ; int err ; BT_DBG ( ""sock<S2SV_blank>%p<S2SV_blank>sk<S2SV_blank>%p<S2SV_blank>len<S2SV_blank>%zu"" , sock , sk , len ) ; if ( flags & ( MSG_OOB ) ) return - EOPNOTSUPP ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) {  if ( sk -> sk_shutdown & RCV_SHUTDOWN ) {  msg -> msg_namelen = 0 ; return 0 ; } return err ; } copied = skb -> len ; if ( len < copied ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } skb_reset_transport_header ( skb ) ; err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err == 0 ) { sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( bt_sk ( sk ) -> skb_msg_name ) bt_sk ( sk ) -> skb_msg_name ( skb , msg -> msg_name , & msg -> msg_namelen ) ;  else  msg -> msg_namelen = 0 ; } skb_free_datagram ( sk , skb ) ; return err ? : copied ; }","
",242
344,buggy line: return in ;}cwe id:CWE-119context: SQLWCHAR * _multi_string_alloc_and_expand ( LPCSTR in ) { SQLWCHAR * chr ; int len = 0 ; if ( ! in ) {  return in ;  } while ( in [ len ] != 0 || in [ len + 1 ] != 0 ) { len ++ ; } chr = malloc ( sizeof ( SQLWCHAR ) * ( len + 2 ) ) ; len = 0 ; while ( in [ len ] != 0 || in [ len + 1 ] != 0 ) { chr [ len ] = in [ len ] ; len ++ ; } chr [ len ++ ] = 0 ; chr [ len ++ ] = 0 ; return chr ; },return NULL ;},243
345,"buggy line: uint8_t * const buffers [ 4 ] = {src -> y_buffer , src -> u_buffer , src -> v_buffer ,  src -> alpha_buffer }const int strides [ 4 ] = {src -> y_stride , src -> uv_stride , src -> uv_stride ,  src -> alpha_stride }cwe id:CWE-119context: void vp9_setup_pre_planes ( MACROBLOCKD * xd , int idx , const YV12_BUFFER_CONFIG * src , int mi_row , int mi_col , const struct scale_factors * sf ) { if ( src != NULL ) { int i ;  uint8_t * const buffers [ 4 ] = { src -> y_buffer , src -> u_buffer , src -> v_buffer ,  src -> alpha_buffer } ;  const int strides [ 4 ] = { src -> y_stride , src -> uv_stride , src -> uv_stride ,  src -> alpha_stride } ; for ( i = 0 ; i < MAX_MB_PLANE ; ++ i ) { struct macroblockd_plane * const pd = & xd -> plane [ i ] ; setup_pred_plane ( & pd -> pre [ idx ] , buffers [ i ] , strides [ i ] , mi_row , mi_col , sf , pd -> subsampling_x , pd -> subsampling_y ) ; } } }","uint8_t * const buffers [ MAX_MB_PLANE ] = {src -> y_buffer , src -> u_buffer , src -> v_buffer }const int strides [ 4 ] = {src -> y_stride , src -> uv_stride }",244
346,"buggy line: char buf [ DN_BUF_LEN ] ;unsigned int bufsize = sizeof ( buf ) ;X509_NAME_oneline_ex ( X509_get_subject_name ( cert ) , buf , & bufsize ,  XN_FLAG_SEP_COMMA_PLUS ) ;md -> subject_dn = strdup ( buf ) ;if ( md -> subject_dn == NULL ) {ret = ENOMEM ;goto cleanup ;}X509_NAME_oneline_ex ( X509_get_issuer_name ( cert ) , buf , & bufsize ,  XN_FLAG_SEP_COMMA_PLUS ) ;md -> issuer_dn = strdup ( buf ) ;if ( md -> issuer_dn == NULL ) {ret = ENOMEM ;goto cleanup ;}cwe id:CWE-119context: static krb5_error_code get_matching_data ( krb5_context context , pkinit_plg_crypto_context plg_cryptoctx , pkinit_req_crypto_context req_cryptoctx , X509 * cert , pkinit_cert_matching_data * * md_out ) { krb5_error_code ret = ENOMEM ; pkinit_cert_matching_data * md = NULL ; krb5_principal * pkinit_sans = NULL , * upn_sans = NULL ; size_t i , j ;  char buf [ DN_BUF_LEN ] ;  unsigned int bufsize = sizeof ( buf ) ; * md_out = NULL ; md = calloc ( 1 , sizeof ( * md ) ) ; if ( md == NULL ) goto cleanup ;  X509_NAME_oneline_ex ( X509_get_subject_name ( cert ) , buf , & bufsize ,  XN_FLAG_SEP_COMMA_PLUS ) ;  md -> subject_dn = strdup ( buf ) ;  if ( md -> subject_dn == NULL ) { ret = ENOMEM ; goto cleanup ; }  X509_NAME_oneline_ex ( X509_get_issuer_name ( cert ) , buf , & bufsize ,  XN_FLAG_SEP_COMMA_PLUS ) ;  md -> issuer_dn = strdup ( buf ) ;  if ( md -> issuer_dn == NULL ) { ret = ENOMEM ; goto cleanup ; } ret = crypto_retrieve_X509_sans ( context , plg_cryptoctx , req_cryptoctx , cert , & pkinit_sans , & upn_sans , NULL ) ; if ( ret ) goto cleanup ; j = 0 ; if ( pkinit_sans != NULL ) { for ( i = 0 ; pkinit_sans [ i ] != NULL ; i ++ ) j ++ ; } if ( upn_sans != NULL ) { for ( i = 0 ; upn_sans [ i ] != NULL ; i ++ ) j ++ ; } if ( j != 0 ) { md -> sans = calloc ( ( size_t ) j + 1 , sizeof ( * md -> sans ) ) ; if ( md -> sans == NULL ) { ret = ENOMEM ; goto cleanup ; } j = 0 ; if ( pkinit_sans != NULL ) { for ( i = 0 ; pkinit_sans [ i ] != NULL ; i ++ ) md -> sans [ j ++ ] = pkinit_sans [ i ] ; free ( pkinit_sans ) ; } if ( upn_sans != NULL ) { for ( i = 0 ; upn_sans [ i ] != NULL ; i ++ ) md -> sans [ j ++ ] = upn_sans [ i ] ; free ( upn_sans ) ; } md -> sans [ j ] = NULL ; } else md -> sans = NULL ; ret = crypto_retrieve_X509_key_usage ( context , plg_cryptoctx , req_cryptoctx , cert , & md -> ku_bits , & md -> eku_bits ) ; if ( ret ) goto cleanup ; * md_out = md ; md = NULL ; cleanup : crypto_cert_free_matching_data ( context , md ) ; return ret ; }","X509_NAME_oneline_ex ( X509_get_subject_name ( cert ) , & md -> subject_dn = strdup ( buf ) ;if ( md -> subject_dn ) ;if ( ret ) goto cleanup ;ret = rfc2253_name ( X509_get_issuer_name ( cert ) , buf , & bufsize , XN_FLAG_SEP_COMMA_PLUS ) ;md -> issuer_dn ) ;if ( ret ) goto cleanup ;",245
347,"buggy line: if ( ! npages ) mem -> flags &= ~ KVM_MEM_LOG_DIRTY_PAGES ;cwe id:CWE-399context: int __kvm_set_memory_region ( struct kvm * kvm , struct kvm_userspace_memory_region * mem , int user_alloc ) { int r ; gfn_t base_gfn ; unsigned long npages ; unsigned long i ; struct kvm_memory_slot * memslot ; struct kvm_memory_slot old , new ; struct kvm_memslots * slots , * old_memslots ; r = check_memory_region_flags ( mem ) ; if ( r ) goto out ; r = - EINVAL ; if ( mem -> memory_size & ( PAGE_SIZE - 1 ) ) goto out ; if ( mem -> guest_phys_addr & ( PAGE_SIZE - 1 ) ) goto out ; if ( user_alloc && ( ( mem -> userspace_addr & ( PAGE_SIZE - 1 ) ) || ! access_ok ( VERIFY_WRITE , ( void __user * ) ( unsigned long ) mem -> userspace_addr , mem -> memory_size ) ) ) goto out ; if ( mem -> slot >= KVM_MEM_SLOTS_NUM ) goto out ; if ( mem -> guest_phys_addr + mem -> memory_size < mem -> guest_phys_addr ) goto out ; memslot = id_to_memslot ( kvm -> memslots , mem -> slot ) ; base_gfn = mem -> guest_phys_addr >> PAGE_SHIFT ; npages = mem -> memory_size >> PAGE_SHIFT ; r = - EINVAL ; if ( npages > KVM_MEM_MAX_NR_PAGES ) goto out ; if ( ! npages ) mem -> flags &= ~ KVM_MEM_LOG_DIRTY_PAGES ; new = old = * memslot ; new . id = mem -> slot ; new . base_gfn = base_gfn ; new . npages = npages ; new . flags = mem -> flags ; r = - EINVAL ; if ( npages && old . npages && npages != old . npages ) goto out_free ; r = - EEXIST ; for ( i = 0 ; i < KVM_MEMORY_SLOTS ; ++ i ) { struct kvm_memory_slot * s = & kvm -> memslots -> memslots [ i ] ; if ( s == memslot || ! s -> npages ) continue ; if ( ! ( ( base_gfn + npages <= s -> base_gfn ) || ( base_gfn >= s -> base_gfn + s -> npages ) ) ) goto out_free ; } if ( ! ( new . flags & KVM_MEM_LOG_DIRTY_PAGES ) ) new . dirty_bitmap = NULL ; r = - ENOMEM ; if ( npages && ! old . npages ) { new . user_alloc = user_alloc ; new . userspace_addr = mem -> userspace_addr ; if ( kvm_arch_create_memslot ( & new , npages ) ) goto out_free ; } if ( ( new . flags & KVM_MEM_LOG_DIRTY_PAGES ) && ! new . dirty_bitmap ) { if ( kvm_create_dirty_bitmap ( & new ) < 0 ) goto out_free ; }  if ( ! npages ) {  struct kvm_memory_slot * slot ; r = - ENOMEM ; slots = kmemdup ( kvm -> memslots , sizeof ( struct kvm_memslots ) , GFP_KERNEL ) ; if ( ! slots ) goto out_free ; slot = id_to_memslot ( slots , mem -> slot ) ; slot -> flags |= KVM_MEMSLOT_INVALID ; update_memslots ( slots , NULL ) ; old_memslots = kvm -> memslots ; rcu_assign_pointer ( kvm -> memslots , slots ) ; synchronize_srcu_expedited ( & kvm -> srcu ) ; kvm_arch_flush_shadow_memslot ( kvm , slot ) ; kfree ( old_memslots ) ; } r = kvm_arch_prepare_memory_region ( kvm , & new , old , mem , user_alloc ) ; if ( r ) goto out_free ; if ( npages ) { r = kvm_iommu_map_pages ( kvm , & new ) ; if ( r ) goto out_free ; } else kvm_iommu_unmap_pages ( kvm , & old ) ; r = - ENOMEM ; slots = kmemdup ( kvm -> memslots , sizeof ( struct kvm_memslots ) , GFP_KERNEL ) ; if ( ! slots ) goto out_free ; if ( ! npages ) { new . dirty_bitmap = NULL ; memset ( & new . arch , 0 , sizeof ( new . arch ) ) ; } update_memslots ( slots , & new ) ; old_memslots = kvm -> memslots ; rcu_assign_pointer ( kvm -> memslots , slots ) ; synchronize_srcu_expedited ( & kvm -> srcu ) ; kvm_arch_commit_memory_region ( kvm , mem , old , user_alloc ) ; if ( npages && old . base_gfn != mem -> guest_phys_addr >> PAGE_SHIFT ) kvm_arch_flush_shadow_all ( kvm ) ; kvm_free_physmem_slot ( & old , & new ) ; kfree ( old_memslots ) ; return 0 ; out_free : kvm_free_physmem_slot ( & new , & old ) ; out : return r ; }",if ( ! npages || base_gfn != old . base_gfn ) mem -> flags &= ~ KVM_MEM_LOG_DIRTY_PAGES ;,246
348,"buggy line: if ( ! npages ) {struct kvm_memory_slot * slot ;cwe id:CWE-399context: int __kvm_set_memory_region ( struct kvm * kvm , struct kvm_userspace_memory_region * mem , int user_alloc ) { int r ; gfn_t base_gfn ; unsigned long npages ; unsigned long i ; struct kvm_memory_slot * memslot ; struct kvm_memory_slot old , new ; struct kvm_memslots * slots , * old_memslots ; r = check_memory_region_flags ( mem ) ; if ( r ) goto out ; r = - EINVAL ; if ( mem -> memory_size & ( PAGE_SIZE - 1 ) ) goto out ; if ( mem -> guest_phys_addr & ( PAGE_SIZE - 1 ) ) goto out ; if ( user_alloc && ( ( mem -> userspace_addr & ( PAGE_SIZE - 1 ) ) || ! access_ok ( VERIFY_WRITE , ( void __user * ) ( unsigned long ) mem -> userspace_addr , mem -> memory_size ) ) ) goto out ; if ( mem -> slot >= KVM_MEM_SLOTS_NUM ) goto out ; if ( mem -> guest_phys_addr + mem -> memory_size < mem -> guest_phys_addr ) goto out ; memslot = id_to_memslot ( kvm -> memslots , mem -> slot ) ; base_gfn = mem -> guest_phys_addr >> PAGE_SHIFT ; npages = mem -> memory_size >> PAGE_SHIFT ; r = - EINVAL ; if ( npages > KVM_MEM_MAX_NR_PAGES ) goto out ; if ( ! npages ) mem -> flags &= ~ KVM_MEM_LOG_DIRTY_PAGES ; new = old = * memslot ; new . id = mem -> slot ; new . base_gfn = base_gfn ; new . npages = npages ; new . flags = mem -> flags ; r = - EINVAL ; if ( npages && old . npages && npages != old . npages ) goto out_free ; r = - EEXIST ; for ( i = 0 ; i < KVM_MEMORY_SLOTS ; ++ i ) { struct kvm_memory_slot * s = & kvm -> memslots -> memslots [ i ] ; if ( s == memslot || ! s -> npages ) continue ; if ( ! ( ( base_gfn + npages <= s -> base_gfn ) || ( base_gfn >= s -> base_gfn + s -> npages ) ) ) goto out_free ; } if ( ! ( new . flags & KVM_MEM_LOG_DIRTY_PAGES ) ) new . dirty_bitmap = NULL ; r = - ENOMEM ; if ( npages && ! old . npages ) { new . user_alloc = user_alloc ; new . userspace_addr = mem -> userspace_addr ; if ( kvm_arch_create_memslot ( & new , npages ) ) goto out_free ; } if ( ( new . flags & KVM_MEM_LOG_DIRTY_PAGES ) && ! new . dirty_bitmap ) { if ( kvm_create_dirty_bitmap ( & new ) < 0 ) goto out_free ; }  if ( ! npages ) {  struct kvm_memory_slot * slot ; r = - ENOMEM ; slots = kmemdup ( kvm -> memslots , sizeof ( struct kvm_memslots ) , GFP_KERNEL ) ; if ( ! slots ) goto out_free ; slot = id_to_memslot ( slots , mem -> slot ) ; slot -> flags |= KVM_MEMSLOT_INVALID ; update_memslots ( slots , NULL ) ; old_memslots = kvm -> memslots ; rcu_assign_pointer ( kvm -> memslots , slots ) ; synchronize_srcu_expedited ( & kvm -> srcu ) ; kvm_arch_flush_shadow_memslot ( kvm , slot ) ; kfree ( old_memslots ) ; } r = kvm_arch_prepare_memory_region ( kvm , & new , old , mem , user_alloc ) ; if ( r ) goto out_free ; if ( npages ) { r = kvm_iommu_map_pages ( kvm , & new ) ; if ( r ) goto out_free ; } else kvm_iommu_unmap_pages ( kvm , & old ) ; r = - ENOMEM ; slots = kmemdup ( kvm -> memslots , sizeof ( struct kvm_memslots ) , GFP_KERNEL ) ; if ( ! slots ) goto out_free ; if ( ! npages ) { new . dirty_bitmap = NULL ; memset ( & new . arch , 0 , sizeof ( new . arch ) ) ; } update_memslots ( slots , & new ) ; old_memslots = kvm -> memslots ; rcu_assign_pointer ( kvm -> memslots , slots ) ; synchronize_srcu_expedited ( & kvm -> srcu ) ; kvm_arch_commit_memory_region ( kvm , mem , old , user_alloc ) ; if ( npages && old . base_gfn != mem -> guest_phys_addr >> PAGE_SHIFT ) kvm_arch_flush_shadow_all ( kvm ) ; kvm_free_physmem_slot ( & old , & new ) ; kfree ( old_memslots ) ; return 0 ; out_free : kvm_free_physmem_slot ( & new , & old ) ; out : return r ; }",if ( ! npages ) {struct kvm_memory_slot * slot ;,246
349,"buggy line: if ( err > 0 ) {signo = SIGCHLD ;err = 0 ;}if ( ! err ) {cwe id:CWE-200context: SYSCALL_DEFINE5 ( waitid , int , which , pid_t , upid , struct siginfo __user * , infop , int , options , struct rusage __user * , ru ) { struct rusage r ; struct waitid_info info = { . status = 0 } ; long err = kernel_waitid ( which , upid , & info , options , ru ? & r : NULL ) ; int signo = 0 ; if ( err > 0 ) { signo = SIGCHLD ; err = 0 ;  }  if ( ! err ) { if ( ru && copy_to_user ( ru , & r , sizeof ( struct rusage ) ) ) return - EFAULT ; } if ( ! infop ) return err ; user_access_begin ( ) ; unsafe_put_user ( signo , & infop -> si_signo , Efault ) ; unsafe_put_user ( 0 , & infop -> si_errno , Efault ) ; unsafe_put_user ( info . cause , & infop -> si_code , Efault ) ; unsafe_put_user ( info . pid , & infop -> si_pid , Efault ) ; unsafe_put_user ( info . uid , & infop -> si_uid , Efault ) ; unsafe_put_user ( info . status , & infop -> si_status , Efault ) ; user_access_end ( ) ; return err ; Efault : user_access_end ( ) ; return - EFAULT ; }","
",247
350,"buggy line: struct skcipher_ctx * ctx = ask -> private ;unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ;struct skcipher_sg_list * sgl ;struct scatterlist * sg ;unsigned long iovlen ;struct iovec * iov ;int err = - EAGAIN ;int used ;long copied = 0 ;lock_sock ( sk ) ;msg -> msg_namelen = 0 ;cwe id:CWE-20context: static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ;  lock_sock ( sk ) ;  msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }","
",248
351,"buggy line: register u_int amt ;register u_int i ;int j ;int trunc ;if ( ndo -> ndo_snapend < dat ) return ;amt = ndo -> ndo_snapend - dat ;i = min ( length , amt ) ;if ( i < ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ) return ;i -= ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ;case RIP6_REQUEST :  j = length / sizeof ( * ni ) ;if ( j == 1  && rp -> rip6_nets -> rip6_metric == HOPCNT_INFINITY6  && IN6_IS_ADDR_UNSPECIFIED ( & rp -> rip6_nets -> rip6_dest ) ) {if ( j * sizeof ( * ni ) != length - 4 )  ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-req<S2SV_blank>%d[%u]:"" , j , length ) ) ;else  ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-req<S2SV_blank>%d:"" , j ) ) ;trunc = ( ( i / sizeof ( * ni ) ) * sizeof ( * ni ) != i ) ;for ( ni = rp -> rip6_nets ;i -= sizeof ( * ni ) , ++ ni ) {if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\\break ;case RIP6_RESPONSE :  j = length / sizeof ( * ni ) ;if ( j * sizeof ( * ni ) != length - 4 )  ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-resp<S2SV_blank>%d[%u]:"" , j , length ) ) ;trunc = ( ( i / sizeof ( * ni ) ) * sizeof ( * ni ) != i ) ;for ( ni = rp -> rip6_nets ;i >= sizeof ( * ni ) ;i -= sizeof ( * ni ) , ++ ni ) {if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\\if ( trunc )  ND_PRINT ( ( ndo , ""[|ripng]"" ) ) ;}if ( rp -> rip6_vers != RIP6_VERSION ) ND_PRINT ( ( ndo , ""<S2SV_blank>[vers<S2SV_blank>%d]"" , rp -> rip6_vers ) ) ;}cwe id:CWE-125context: void ripng_print ( netdissect_options * ndo , const u_char * dat , unsigned int length ) { register const struct rip6 * rp = ( const struct rip6 * ) dat ; register const struct netinfo6 * ni ;  register u_int amt ;  register u_int i ; int j ; int trunc ; if ( ndo -> ndo_snapend < dat ) return ; amt = ndo -> ndo_snapend - dat ; i = min ( length , amt ) ; if ( i < ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ) return ; i -= ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ; switch ( rp -> rip6_cmd ) { case RIP6_REQUEST :  j = length / sizeof ( * ni ) ;  if ( j == 1  && rp -> rip6_nets -> rip6_metric == HOPCNT_INFINITY6  && IN6_IS_ADDR_UNSPECIFIED ( & rp -> rip6_nets -> rip6_dest ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-req<S2SV_blank>dump"" ) ) ; break ; }  if ( j * sizeof ( * ni ) != length - 4 )  ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-req<S2SV_blank>%d[%u]:"" , j , length ) ) ; else  ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-req<S2SV_blank>%d:"" , j ) ) ;  trunc = ( ( i / sizeof ( * ni ) ) * sizeof ( * ni ) != i ) ;  for ( ni = rp -> rip6_nets ; i >= sizeof ( * ni ) ;   i -= sizeof ( * ni ) , ++ ni ) {  if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\n\\t"" ) ) ; else ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; rip6_entry_print ( ndo , ni , 0 ) ; }  break ;  case RIP6_RESPONSE :  j = length / sizeof ( * ni ) ;   if ( j * sizeof ( * ni ) != length - 4 )  ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-resp<S2SV_blank>%d[%u]:"" , j , length ) ) ; else ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-resp<S2SV_blank>%d:"" , j ) ) ;  trunc = ( ( i / sizeof ( * ni ) ) * sizeof ( * ni ) != i ) ;   for ( ni = rp -> rip6_nets ; i >= sizeof ( * ni ) ;   i -= sizeof ( * ni ) , ++ ni ) {  if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\n\\t"" ) ) ; else ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; rip6_entry_print ( ndo , ni , ni -> rip6_metric ) ; }  if ( trunc )  ND_PRINT ( ( ndo , ""[|ripng]"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-%d<S2SV_blank>??<S2SV_blank>%u"" , rp -> rip6_cmd , length ) ) ; break ;  }  if ( rp -> rip6_vers != RIP6_VERSION ) ND_PRINT ( ( ndo , ""<S2SV_blank>[vers<S2SV_blank>%d]"" , rp -> rip6_vers ) ) ;  } ","unsigned int length_left ;u_int j ;ND_TCHECK ( rp -> rip6_cmd ) ;case RIP6_REQUEST : j = length / sizeof ( * ni ) ;if ( j == 1 && rp -> rip6_nets -> rip6_metric == HOPCNT_INFINITY6 && IN6_IS_ADDR_UNSPECIFIED ( & rp -> rip6_nets -> rip6_dest ) ) {}if ( j * sizeof ( * ni ) != length_left ) ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-req<S2SV_blank>%u[%u]:"" , j , length ) ) ;else ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-req<S2SV_blank>%u:"" , j ) ) ;for ( ni = rp -> rip6_nets ;i -= sizeof ( * ni ) , ++ ni ) {if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\\break ;case RIP6_RESPONSE : j = length / sizeof ( * ni ) ;if ( j * sizeof ( * ni ) != length - 4 ) ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-resp<S2SV_blank>%d[%u]:"" , j , length ) ) ;trunc = ( ( i / sizeof ( * ni ) ) * sizeof ( * ni ) != i ) ;for ( ni = rp -> rip6_nets ;length_left >= sizeof ( * ni ) ;length_left -= sizeof ( * ni ) , ++ ni ) {ND_TCHECK ( * ni ) ;if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\\if ( length_left != 0 ) goto trunc ;}ND_TCHECK ( rp -> rip6_vers ) ;if ( rp -> rip6_vers != RIP6_VERSION ) ND_PRINT ( ( ndo , ""<S2SV_blank>[vers<S2SV_blank>%d]"" , rp -> rip6_vers ) ) ;return ;trunc : ND_PRINT ( ( ndo , ""[|ripng]"" ) ) ;return ;}",249
352,"buggy line: if ( ret < 0 ) {if ( ret != - EEXIST ) goto error ;cwe id:CWE-404context: long keyctl_set_reqkey_keyring ( int reqkey_defl ) { struct cred * new ; int ret , old_setting ; old_setting = current_cred_xxx ( jit_keyring ) ; if ( reqkey_defl == KEY_REQKEY_DEFL_NO_CHANGE ) return old_setting ; new = prepare_creds ( ) ; if ( ! new ) return - ENOMEM ; switch ( reqkey_defl ) { case KEY_REQKEY_DEFL_THREAD_KEYRING : ret = install_thread_keyring_to_cred ( new ) ; if ( ret < 0 ) goto error ; goto set ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : ret = install_process_keyring_to_cred ( new ) ;  if ( ret < 0 ) {  if ( ret != - EEXIST ) goto error ; ret = 0 ; } goto set ; case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_SESSION_KEYRING : case KEY_REQKEY_DEFL_USER_KEYRING : case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : goto set ; case KEY_REQKEY_DEFL_NO_CHANGE : case KEY_REQKEY_DEFL_GROUP_KEYRING : default : ret = - EINVAL ; goto error ; } set : new -> jit_keyring = reqkey_defl ; commit_creds ( new ) ; return old_setting ; error : abort_creds ( new ) ; return ret ; }",if ( ret < 0 ) {if ( ret != - EEXIST ) goto error ;,250
353,"buggy line: vpx_memcpy ( sortlist , cpi -> mb_activity_map ,  sizeof ( unsigned int ) * cpi -> common . MBs ) ;cwe id:CWE-119context: static void calc_av_activity ( VP8_COMP * cpi , int64_t activity_sum ) { # if ACT_MEDIAN { unsigned int median ; unsigned int i , j ; unsigned int * sortlist ; unsigned int tmp ; CHECK_MEM_ERROR ( sortlist , vpx_calloc ( sizeof ( unsigned int ) , cpi -> common . MBs ) ) ;  vpx_memcpy ( sortlist , cpi -> mb_activity_map ,  sizeof ( unsigned int ) * cpi -> common . MBs ) ; for ( i = 1 ; i < cpi -> common . MBs ; i ++ ) { for ( j = i ; j > 0 ; j -- ) { if ( sortlist [ j ] < sortlist [ j - 1 ] ) { tmp = sortlist [ j - 1 ] ; sortlist [ j - 1 ] = sortlist [ j ] ; sortlist [ j ] = tmp ; } else break ; } } median = ( 1 + sortlist [ cpi -> common . MBs >> 1 ] + sortlist [ ( cpi -> common . MBs >> 1 ) + 1 ] ) >> 1 ; cpi -> activity_avg = median ; vpx_free ( sortlist ) ; } # else cpi -> activity_avg = ( unsigned int ) ( activity_sum / cpi -> common . MBs ) ; # endif if ( cpi -> activity_avg < VP8_ACTIVITY_AVG_MIN ) cpi -> activity_avg = VP8_ACTIVITY_AVG_MIN ; if ( ALT_ACT_MEASURE ) cpi -> activity_avg = 100000 ; }","memcpy ( sortlist , cpi -> mb_activity_map , sizeof ( unsigned int ) * cpi -> common . MBs ) ;",251
354,"buggy line: retval = copy_strings_kernel ( 1 , & iname_addr , bprm ) ;bprm -> argc ++ ;bprm -> interp = iname ;interp_file = open_exec ( iname ) ;cwe id:CWE-200context: static int load_misc_binary ( struct linux_binprm * bprm ) { Node * fmt ; struct file * interp_file = NULL ; char iname [ BINPRM_BUF_SIZE ] ; const char * iname_addr = iname ; int retval ; int fd_binary = - 1 ; retval = - ENOEXEC ; if ( ! enabled ) goto _ret ; read_lock ( & entries_lock ) ; fmt = check_file ( bprm ) ; if ( fmt ) strlcpy ( iname , fmt -> interpreter , BINPRM_BUF_SIZE ) ; read_unlock ( & entries_lock ) ; if ( ! fmt ) goto _ret ; if ( ! ( fmt -> flags & MISC_FMT_PRESERVE_ARGV0 ) ) { retval = remove_arg_zero ( bprm ) ; if ( retval ) goto _ret ; } if ( fmt -> flags & MISC_FMT_OPEN_BINARY ) { fd_binary = get_unused_fd ( ) ; if ( fd_binary < 0 ) { retval = fd_binary ; goto _ret ; } fd_install ( fd_binary , bprm -> file ) ; would_dump ( bprm , bprm -> file ) ; allow_write_access ( bprm -> file ) ; bprm -> file = NULL ; bprm -> interp_flags |= BINPRM_FLAGS_EXECFD ; bprm -> interp_data = fd_binary ; } else { allow_write_access ( bprm -> file ) ; fput ( bprm -> file ) ; bprm -> file = NULL ; } retval = copy_strings_kernel ( 1 , & bprm -> interp , bprm ) ; if ( retval < 0 ) goto _error ; bprm -> argc ++ ; retval = copy_strings_kernel ( 1 , & iname_addr , bprm ) ; if ( retval < 0 ) goto _error ; bprm -> argc ++ ;  bprm -> interp = iname ;  interp_file = open_exec ( iname ) ; retval = PTR_ERR ( interp_file ) ; if ( IS_ERR ( interp_file ) ) goto _error ; bprm -> file = interp_file ; if ( fmt -> flags & MISC_FMT_CREDENTIALS ) { memset ( bprm -> buf , 0 , BINPRM_BUF_SIZE ) ; retval = kernel_read ( bprm -> file , 0 , bprm -> buf , BINPRM_BUF_SIZE ) ; } else retval = prepare_binprm ( bprm ) ; if ( retval < 0 ) goto _error ; retval = search_binary_handler ( bprm ) ; if ( retval < 0 ) goto _error ; _ret : return retval ; _error : if ( fd_binary > 0 ) sys_close ( fd_binary ) ; bprm -> interp_flags = 0 ; bprm -> interp_data = 0 ; goto _ret ; }","retval = bprm_change_interp ( iname , bprm ) ;interp_file = open_exec ( iname ) ;",252
355,"buggy line: int iSrc ;res -> ContribRow [ u ] . Left = iLeft ;res -> ContribRow [ u ] . Right = iRight ;cwe id:CWE-125context: static inline LineContribType * _gdContributionsCalc ( unsigned int line_size , unsigned int src_size , double scale_d , const interpolation_method pFilter ) { double width_d ; double scale_f_d = 1.0 ; const double filter_width_d = DEFAULT_BOX_RADIUS ; int windows_size ; unsigned int u ; LineContribType * res ; if ( scale_d < 1.0 ) { width_d = filter_width_d / scale_d ; scale_f_d = scale_d ; } else { width_d = filter_width_d ; } windows_size = 2 * ( int ) ceil ( width_d ) + 1 ; res = _gdContributionsAlloc ( line_size , windows_size ) ; for ( u = 0 ; u < line_size ; u ++ ) { const double dCenter = ( double ) u / scale_d ; register int iLeft = MAX ( 0 , ( int ) floor ( dCenter - width_d ) ) ; int iRight = MIN ( ( int ) ceil ( dCenter + width_d ) , ( int ) src_size - 1 ) ; double dTotalWeight = 0.0 ;  int iSrc ;  res -> ContribRow [ u ] . Left = iLeft ; res -> ContribRow [ u ] . Right = iRight ; if ( iRight - iLeft + 1 > windows_size ) { if ( iLeft < ( ( int ) src_size - 1 / 2 ) ) { iLeft ++ ; } else { iRight -- ; } }  for ( iSrc = iLeft ; iSrc <= iRight ; iSrc ++ ) {   dTotalWeight += ( res -> ContribRow [ u ] . Weights [ iSrc - iLeft ] = scale_f_d * ( * pFilter ) ( scale_f_d * ( dCenter - ( double ) iSrc ) ) ) ;  } if ( dTotalWeight < 0.0 ) { _gdContributionsFree ( res ) ; return NULL ; } if ( dTotalWeight > 0.0 ) { for ( iSrc = iLeft ; iSrc <= iRight ; iSrc ++ ) { res -> ContribRow [ u ] . Weights [ iSrc - iLeft ] /= dTotalWeight ; } } } return res ; }",int iSrc ;,253
356,"buggy line: for ( iSrc = iLeft ;dTotalWeight += ( res -> ContribRow [ u ] . Weights [ iSrc - iLeft ] = scale_f_d * ( * pFilter ) ( scale_f_d * ( dCenter - ( double ) iSrc ) ) ) ;}cwe id:CWE-125context: static inline LineContribType * _gdContributionsCalc ( unsigned int line_size , unsigned int src_size , double scale_d , const interpolation_method pFilter ) { double width_d ; double scale_f_d = 1.0 ; const double filter_width_d = DEFAULT_BOX_RADIUS ; int windows_size ; unsigned int u ; LineContribType * res ; if ( scale_d < 1.0 ) { width_d = filter_width_d / scale_d ; scale_f_d = scale_d ; } else { width_d = filter_width_d ; } windows_size = 2 * ( int ) ceil ( width_d ) + 1 ; res = _gdContributionsAlloc ( line_size , windows_size ) ; for ( u = 0 ; u < line_size ; u ++ ) { const double dCenter = ( double ) u / scale_d ; register int iLeft = MAX ( 0 , ( int ) floor ( dCenter - width_d ) ) ; int iRight = MIN ( ( int ) ceil ( dCenter + width_d ) , ( int ) src_size - 1 ) ; double dTotalWeight = 0.0 ;  int iSrc ;  res -> ContribRow [ u ] . Left = iLeft ; res -> ContribRow [ u ] . Right = iRight ; if ( iRight - iLeft + 1 > windows_size ) { if ( iLeft < ( ( int ) src_size - 1 / 2 ) ) { iLeft ++ ; } else { iRight -- ; } }  for ( iSrc = iLeft ; iSrc <= iRight ; iSrc ++ ) {   dTotalWeight += ( res -> ContribRow [ u ] . Weights [ iSrc - iLeft ] = scale_f_d * ( * pFilter ) ( scale_f_d * ( dCenter - ( double ) iSrc ) ) ) ;  } if ( dTotalWeight < 0.0 ) { _gdContributionsFree ( res ) ; return NULL ; } if ( dTotalWeight > 0.0 ) { for ( iSrc = iLeft ; iSrc <= iRight ; iSrc ++ ) { res -> ContribRow [ u ] . Weights [ iSrc - iLeft ] /= dTotalWeight ; } } } return res ; }",res -> ContribRow [ u ] . Left = iLeft ;res -> ContribRow [ u ] . Right = iRight ;for ( iSrc = iLeft ;dTotalWeight += ( res -> ContribRow [ u ] . Weights [ iSrc - iLeft ] = scale_f_d * ( * pFilter ) ( scale_f_d * ( dCenter - ( double ) iSrc ) ) ) ;},253
357,"buggy line: _ipmi_destroy_user ( user ) ;cleanup_srcu_struct ( & user -> release_barrier ) ;cwe id:CWE-416context: int ipmi_destroy_user ( struct ipmi_user * user ) {  _ipmi_destroy_user ( user ) ;  cleanup_srcu_struct ( & user -> release_barrier ) ; kref_put ( & user -> refcount , free_user ) ; return 0 ; }",_ipmi_destroy_user ( user ) ;,254
358,"buggy line: Com_Printf ( ""Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\\return ;cwe id:CWE-269context: void Com_WriteConfig_f ( void ) { char filename [ MAX_QPATH ] ; if ( Cmd_Argc ( ) != 2 ) {  Com_Printf ( ""Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\n"" ) ;  return ; } Q_strncpyz ( filename , Cmd_Argv ( 1 ) , sizeof ( filename ) ) ; COM_DefaultExtension ( filename , sizeof ( filename ) , "".cfg"" ) ; Com_Printf ( ""Writing<S2SV_blank>%s.\\n"" , filename ) ; Com_WriteConfigToFile ( filename ) ; }","Com_Printf ( ""Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\\return ;}if ( ! COM_CompareExtension ( filename , "".cfg"" ) ) {Com_Printf ( ""Com_WriteConfig_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\\\"".cfg\\\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\\return ;",255
359,"buggy line: int sl = strlen ( cursor -> ns ) + 1 ;int limit = 0 ;cwe id:CWE-190context: static int mongo_cursor_get_more ( mongo_cursor * cursor ) { int res ; if ( cursor -> limit > 0 && cursor -> seen >= cursor -> limit ) { cursor -> err = MONGO_CURSOR_EXHAUSTED ; return MONGO_ERROR ; } else if ( ! cursor -> reply ) { cursor -> err = MONGO_CURSOR_INVALID ; return MONGO_ERROR ; } else if ( ! cursor -> reply -> fields . cursorID ) { cursor -> err = MONGO_CURSOR_EXHAUSTED ; return MONGO_ERROR ; } else { char * data ;  int sl = strlen ( cursor -> ns ) + 1 ;  int limit = 0 ; mongo_message * mm ; if ( cursor -> limit > 0 ) limit = cursor -> limit - cursor -> seen ; mm = mongo_message_create ( 16 + 4 + sl + 4 + 8 , 0 , 0 , MONGO_OP_GET_MORE ) ; data = & mm -> data ; data = mongo_data_append32 ( data , & ZERO ) ; data = mongo_data_append ( data , cursor -> ns , sl ) ; data = mongo_data_append32 ( data , & limit ) ; mongo_data_append64 ( data , & cursor -> reply -> fields . cursorID ) ; bson_free ( cursor -> reply ) ; res = mongo_message_send ( cursor -> conn , mm ) ; if ( res != MONGO_OK ) { mongo_cursor_destroy ( cursor ) ; return MONGO_ERROR ; } res = mongo_read_response ( cursor -> conn , & ( cursor -> reply ) ) ; if ( res != MONGO_OK ) { mongo_cursor_destroy ( cursor ) ; return MONGO_ERROR ; } cursor -> current . data = NULL ; cursor -> seen += cursor -> reply -> fields . num ; return MONGO_OK ; } }",size_t sl = strlen ( cursor -> ns ) + 1 ;int limit = 0 ;,256
360,"buggy line: if ( mobj )   memset ( mobj_get_va ( mobj , 0 ) , 0 , size ) ;return mobj ;cwe id:CWE-189context: static struct mobj * alloc_ta_mem ( size_t size ) { # ifdef CFG_PAGED_USER_TA return mobj_paged_alloc ( size ) ; # else struct mobj * mobj = mobj_mm_alloc ( mobj_sec_ddr , size , & tee_mm_sec_ddr ) ;  if ( mobj )   memset ( mobj_get_va ( mobj , 0 ) , 0 , size ) ;  return mobj ; # endif }","if ( mobj ) {size_t granularity = BIT ( tee_mm_sec_ddr . shift ) ;memset ( mobj_get_va ( mobj , 0 ) , 0 , ROUNDUP ( size , granularity ) ) ;}return mobj ;",257
361,"buggy line: timer -> it_overrun += 1 << i ;delta -= incr ;cwe id:CWE-190context: static void bump_cpu_timer ( struct k_itimer * timer , u64 now ) { int i ; u64 delta , incr ; if ( timer -> it . cpu . incr == 0 ) return ; if ( now < timer -> it . cpu . expires ) return ; incr = timer -> it . cpu . incr ; delta = now + incr - timer -> it . cpu . expires ; for ( i = 0 ; incr < delta - incr ; i ++ ) incr = incr << 1 ; for ( ; i >= 0 ; incr >>= 1 , i -- ) { if ( delta < incr ) continue ; timer -> it . cpu . expires += incr ;  timer -> it_overrun += 1 << i ;  delta -= incr ; } }",timer -> it_overrun += 1LL << i ;delta -= incr ;,258
362,"buggy line: if ( n_fors == - 1 ) return NULL ;comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ;if ( ! comps ) return NULL ;for ( i = 0 ;i < n_fors ;i ++ ) {comprehension_ty comp ;asdl_seq * t ;expr_ty expression , first ;node * for_ch ;int is_async = 0 ;REQ ( n , comp_for ) ;if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) {is_async = 1 ;}if ( is_async && c -> c_feature_version < 6 ) {for_ch = CHILD ( n , 1 + is_async ) ;t = ast_for_exprlist ( c , for_ch , Store ) ;expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ;if ( ! expression ) return NULL ;if ( NCH ( n ) == ( 5 + is_async ) ) {int j , n_ifs ;n = CHILD ( n , 4 + is_async ) ;n_ifs = count_comp_ifs ( c , n ) ;cwe id:CWE-125context: static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ;  int is_async = 0 ;  REQ ( n , comp_for ) ;  if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) {  is_async = 1 ;  }  if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async<S2SV_blank>comprehensions<S2SV_blank>are<S2SV_blank>only<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>Python<S2SV_blank>3.6<S2SV_blank>and<S2SV_blank>greater"" ) ; return NULL ; }  for_ch = CHILD ( n , 1 + is_async ) ;  t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ;  expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ;  if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ;  if ( NCH ( n ) == ( 5 + is_async ) ) {  int j , n_ifs ; asdl_seq * ifs ;  n = CHILD ( n , 4 + is_async ) ;  n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }","if ( NCH ( n ) == 2 ) {is_async = 1 ;}if ( is_async && c -> c_feature_version < 6 ) {for_ch = CHILD ( n , 1 + is_async ) ;t = ast_for_exprlist ( c , for_ch , Store ) ;expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ;if ( ! expression ) return NULL ;if ( NCH ( n ) == ( 5 + is_async ) ) {int j , n_ifs ;n = CHILD ( n , 4 + is_async ) ;n_ifs = count_comp_ifs ( c , n ) ;",259
363,"buggy line: expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ;cwe id:CWE-125context: static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ;  int is_async = 0 ;  REQ ( n , comp_for ) ;  if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) {  is_async = 1 ;  }  if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async<S2SV_blank>comprehensions<S2SV_blank>are<S2SV_blank>only<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>Python<S2SV_blank>3.6<S2SV_blank>and<S2SV_blank>greater"" ) ; return NULL ; }  for_ch = CHILD ( n , 1 + is_async ) ;  t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ;  expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ;  if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ;  if ( NCH ( n ) == ( 5 + is_async ) ) {  int j , n_ifs ; asdl_seq * ifs ;  n = CHILD ( n , 4 + is_async ) ;  n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }","expression = ast_for_expr ( c , CHILD ( sync_n , 3 ) ) ;",259
364,"buggy line: }dst_state -> curframe = src -> curframe ;cwe id:CWE-189context: static int copy_verifier_state ( struct bpf_verifier_state * dst_state , const struct bpf_verifier_state * src ) { struct bpf_func_state * dst ; int i , err ; for ( i = src -> curframe + 1 ; i <= dst_state -> curframe ; i ++ ) { free_func_state ( dst_state -> frame [ i ] ) ; dst_state -> frame [ i ] = NULL ;  }  dst_state -> curframe = src -> curframe ; for ( i = 0 ; i <= src -> curframe ; i ++ ) { dst = dst_state -> frame [ i ] ; if ( ! dst ) { dst = kzalloc ( sizeof ( * dst ) , GFP_KERNEL ) ; if ( ! dst ) return - ENOMEM ; dst_state -> frame [ i ] = dst ; } err = copy_func_state ( dst , src -> frame [ i ] ) ; if ( err ) return err ; } return 0 ; }",}dst_state -> speculative = src -> speculative ;dst_state -> curframe = src -> curframe ;,260
365,"buggy line: static void write_mb_modes_kf ( const VP9_COMP * cpi , MODE_INFO * * mi_8x8 ,   vp9_writer * w ) {const VP9_COMMON * const cm = & cpi -> common ;const MACROBLOCKD * const xd = & cpi -> mb . e_mbd ;const MODE_INFO * const above_mi = mi_8x8 [ - xd -> mi_stride ] ;const MODE_INFO * const left_mi = xd -> left_available ? mi_8x8 [ - 1 ] : NULL ;const MB_MODE_INFO * const mbmi = & mi -> mbmi ;write_skip ( cpi , mbmi -> segment_id , mi , w ) ;if ( bsize >= BLOCK_8X8 && cm -> tx_mode == TX_MODE_SELECT )  write_selected_tx_size ( cpi , mbmi -> tx_size , bsize , w ) ;if ( bsize >= BLOCK_8X8 ) {cwe id:CWE-119context:  static void write_mb_modes_kf ( const VP9_COMP * cpi , MODE_INFO * * mi_8x8 ,   vp9_writer * w ) {  const VP9_COMMON * const cm = & cpi -> common ; const MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; const struct segmentation * const seg = & cm -> seg ; const MODE_INFO * const mi = mi_8x8 [ 0 ] ;  const MODE_INFO * const above_mi = mi_8x8 [ - xd -> mi_stride ] ;   const MODE_INFO * const left_mi = xd -> left_available ? mi_8x8 [ - 1 ] : NULL ;  const MB_MODE_INFO * const mbmi = & mi -> mbmi ; const BLOCK_SIZE bsize = mbmi -> sb_type ; if ( seg -> update_map ) write_segment_id ( w , seg , mbmi -> segment_id ) ;  write_skip ( cpi , mbmi -> segment_id , mi , w ) ;  if ( bsize >= BLOCK_8X8 && cm -> tx_mode == TX_MODE_SELECT )  write_selected_tx_size ( cpi , mbmi -> tx_size , bsize , w ) ;  if ( bsize >= BLOCK_8X8 ) { write_intra_mode ( w , mbmi -> mode , get_y_mode_probs ( mi , above_mi , left_mi , 0 ) ) ; } else { const int num_4x4_w = num_4x4_blocks_wide_lookup [ bsize ] ; const int num_4x4_h = num_4x4_blocks_high_lookup [ bsize ] ; int idx , idy ; for ( idy = 0 ; idy < 2 ; idy += num_4x4_h ) { for ( idx = 0 ; idx < 2 ; idx += num_4x4_w ) { const int block = idy * 2 + idx ; write_intra_mode ( w , mi -> bmi [ block ] . as_mode , get_y_mode_probs ( mi , above_mi , left_mi , block ) ) ; } } } write_intra_mode ( w , mbmi -> uv_mode , vp9_kf_uv_mode_prob [ mbmi -> mode ] ) ; }","static void write_mb_modes_kf ( const VP9_COMMON * cm , const MACROBLOCKD * xd , MODE_INFO * * mi_8x8 , vpx_writer * w ) {const MODE_INFO * const above_mi = mi_8x8 [ - xd -> mi_stride ] ;const MODE_INFO * const left_mi = xd -> left_mi ;const MB_MODE_INFO * const mbmi = & mi -> mbmi ;write_skip ( cm , xd , mbmi -> segment_id , mi , w ) ;if ( bsize >= BLOCK_8X8 && cm -> tx_mode == TX_MODE_SELECT ) write_selected_tx_size ( cm , xd , w ) ;if ( bsize >= BLOCK_8X8 ) {",261
366,"buggy line: saddr . sin_addr . s_addr = htonl ( INADDR_ANY ) ;saddr . sin_port = htons ( port ) ;cwe id:CWE-284context: int socket_create ( uint16_t port ) { int sfd = - 1 ; int yes = 1 ; # ifdef WIN32 WSADATA wsa_data ; if ( ! wsa_init ) { if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsa_data ) != ERROR_SUCCESS ) { fprintf ( stderr , ""WSAStartup<S2SV_blank>failed!\\n"" ) ; ExitProcess ( - 1 ) ; } wsa_init = 1 ; } # endif struct sockaddr_in saddr ; if ( 0 > ( sfd = socket ( PF_INET , SOCK_STREAM , IPPROTO_TCP ) ) ) { perror ( ""socket()"" ) ; return - 1 ; } if ( setsockopt ( sfd , SOL_SOCKET , SO_REUSEADDR , ( void * ) & yes , sizeof ( int ) ) == - 1 ) { perror ( ""setsockopt()"" ) ; socket_close ( sfd ) ; return - 1 ; } memset ( ( void * ) & saddr , 0 , sizeof ( saddr ) ) ; saddr . sin_family = AF_INET ;  saddr . sin_addr . s_addr = htonl ( INADDR_ANY ) ;  saddr . sin_port = htons ( port ) ; if ( 0 > bind ( sfd , ( struct sockaddr * ) & saddr , sizeof ( saddr ) ) ) { perror ( ""bind()"" ) ; socket_close ( sfd ) ; return - 1 ; } if ( listen ( sfd , 1 ) == - 1 ) { perror ( ""listen()"" ) ; socket_close ( sfd ) ; return - 1 ; } return sfd ; }",saddr . sin_addr . s_addr = htonl ( INADDR_LOOPBACK ) ;saddr . sin_port = htons ( port ) ;,262
367,"buggy line: SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> req . dev ) ;int n ;if ( r -> req . aiocb != NULL ) {r -> req . aiocb = NULL ;bdrv_acct_done ( s -> bs , & r -> acct ) ;}if ( ret ) {if ( scsi_handle_rw_error ( r , - ret , SCSI_REQ_STATUS_RETRY_READ ) ) {return ;}}DPRINTF ( ""Data<S2SV_blank>ready<S2SV_blank>tag=0x%x<S2SV_blank>len=%zd\\\n = r -> iov . iov_len / 512 ;r -> sector += n ;scsi_req_data ( & r -> req , r -> iov . iov_len ) ;}cwe id:CWE-119context: static void scsi_read_complete ( void * opaque , int ret ) { SCSIDiskReq * r = ( SCSIDiskReq * ) opaque ; SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> req . dev ) ; int n ; if ( r -> req . aiocb != NULL ) { r -> req . aiocb = NULL ; bdrv_acct_done ( s -> bs , & r -> acct ) ; } if ( ret ) { if ( scsi_handle_rw_error ( r , - ret , SCSI_REQ_STATUS_RETRY_READ ) ) { return ; } }  DPRINTF ( ""Data<S2SV_blank>ready<S2SV_blank>tag=0x%x<S2SV_blank>len=%zd\\n"" , r -> req . tag , r -> iov . iov_len ) ;   n = r -> iov . iov_len / 512 ;  r -> sector += n ; r -> sector_count -= n ;  scsi_req_data ( & r -> req , r -> iov . iov_len ) ;  }","SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> qiov . size ) ;n = r -> iov . iov_len / 512 ;r -> sector += n ;scsi_req_data ( & r -> req , r -> iov . iov_len ) ;}",263
368,"buggy line: if ( cs > CQSPI_MAX_CHIPSELECT ) {dev_err ( dev , ""Chip<S2SV_blank>select<S2SV_blank>%d<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range.\\\cwe id:CWE-119context: static int cqspi_setup_flash ( struct cqspi_st * cqspi , struct device_node * np ) { struct platform_device * pdev = cqspi -> pdev ; struct device * dev = & pdev -> dev ; struct cqspi_flash_pdata * f_pdata ; struct spi_nor * nor ; struct mtd_info * mtd ; unsigned int cs ; int i , ret ; for_each_available_child_of_node ( dev -> of_node , np ) { if ( of_property_read_u32 ( np , ""reg"" , & cs ) ) { dev_err ( dev , ""Couldn\'t<S2SV_blank>determine<S2SV_blank>chip<S2SV_blank>select.\\n"" ) ; goto err ; }  if ( cs > CQSPI_MAX_CHIPSELECT ) {  dev_err ( dev , ""Chip<S2SV_blank>select<S2SV_blank>%d<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range.\\n"" , cs ) ; goto err ; } f_pdata = & cqspi -> f_pdata [ cs ] ; f_pdata -> cqspi = cqspi ; f_pdata -> cs = cs ; ret = cqspi_of_get_flash_pdata ( pdev , f_pdata , np ) ; if ( ret ) goto err ; nor = & f_pdata -> nor ; mtd = & nor -> mtd ; mtd -> priv = nor ; nor -> dev = dev ; spi_nor_set_flash_node ( nor , np ) ; nor -> priv = f_pdata ; nor -> read_reg = cqspi_read_reg ; nor -> write_reg = cqspi_write_reg ; nor -> read = cqspi_read ; nor -> write = cqspi_write ; nor -> erase = cqspi_erase ; nor -> prepare = cqspi_prep ; nor -> unprepare = cqspi_unprep ; mtd -> name = devm_kasprintf ( dev , GFP_KERNEL , ""%s.%d"" , dev_name ( dev ) , cs ) ; if ( ! mtd -> name ) { ret = - ENOMEM ; goto err ; } ret = spi_nor_scan ( nor , NULL , SPI_NOR_QUAD ) ; if ( ret ) goto err ; ret = mtd_device_register ( mtd , NULL , 0 ) ; if ( ret ) goto err ; f_pdata -> registered = true ; } return 0 ; err : for ( i = 0 ; i < CQSPI_MAX_CHIPSELECT ; i ++ ) if ( cqspi -> f_pdata [ i ] . registered ) mtd_device_unregister ( & cqspi -> f_pdata [ i ] . nor . mtd ) ; return ret ; }","if ( cs >= CQSPI_MAX_CHIPSELECT ) {dev_err ( dev , ""Chip<S2SV_blank>select<S2SV_blank>%d<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range.\\\",264
369,"buggy line: if ( n > maxn ) SWF_error ( ""Action<S2SV_blank>overflow!!"" ) ;# ifdef DEBUG fprintf ( stderr , ""%d:\\\\tACTION[%3.3d]:<S2SV_blank>%s\\\# endif  switch ( actions [ n ] . SWF_ACTIONRECORD . ActionCode )  {cwe id:CWE-119context: int decompileAction ( int n , SWF_ACTION * actions , int maxn ) {  if ( n > maxn ) SWF_error ( ""Action<S2SV_blank>overflow!!"" ) ;  # ifdef DEBUG fprintf ( stderr , ""%d:\\tACTION[%3.3d]:<S2SV_blank>%s\\n"" , actions [ n ] . SWF_ACTIONRECORD . Offset , n , actionName ( actions [ n ] . SWF_ACTIONRECORD . ActionCode ) ) ; # endif  switch ( actions [ n ] . SWF_ACTIONRECORD . ActionCode )  { case SWFACTION_END : return 0 ; case SWFACTION_CONSTANTPOOL : decompileCONSTANTPOOL ( & actions [ n ] ) ; return 0 ; case SWFACTION_GOTOLABEL : return decompileGOTOFRAME ( n , actions , maxn , 1 ) ; case SWFACTION_GOTOFRAME : return decompileGOTOFRAME ( n , actions , maxn , 0 ) ; case SWFACTION_GOTOFRAME2 : return decompileGOTOFRAME2 ( n , actions , maxn ) ; case SWFACTION_WAITFORFRAME : decompileWAITFORFRAME ( & actions [ n ] ) ; return 0 ; case SWFACTION_GETURL2 : decompileGETURL2 ( & actions [ n ] ) ; return 0 ; case SWFACTION_GETURL : decompileGETURL ( & actions [ n ] ) ; return 0 ; case SWFACTION_PUSH : decompilePUSH ( & actions [ n ] ) ; return 0 ; case SWFACTION_PUSHDUP : decompilePUSHDUP ( & actions [ n ] ) ; return 0 ; case SWFACTION_STACKSWAP : decompileSTACKSWAP ( & actions [ n ] ) ; return 0 ; case SWFACTION_SETPROPERTY : decompileSETPROPERTY ( n , actions , maxn ) ; return 0 ; case SWFACTION_GETPROPERTY : decompileGETPROPERTY ( n , actions , maxn ) ; return 0 ; case SWFACTION_GETTIME : return decompileGETTIME ( n , actions , maxn ) ; case SWFACTION_TRACE : decompileTRACE ( n , actions , maxn ) ; return 0 ; case SWFACTION_CALLFRAME : decompileCALLFRAME ( n , actions , maxn ) ; return 0 ; case SWFACTION_EXTENDS : decompileEXTENDS ( n , actions , maxn ) ; return 0 ; case SWFACTION_INITOBJECT : decompileINITOBJECT ( n , actions , maxn ) ; return 0 ; case SWFACTION_NEWOBJECT : decompileNEWOBJECT ( n , actions , maxn ) ; return 0 ; case SWFACTION_NEWMETHOD : decompileNEWMETHOD ( n , actions , maxn ) ; return 0 ; case SWFACTION_GETMEMBER : decompileGETMEMBER ( n , actions , maxn ) ; return 0 ; case SWFACTION_SETMEMBER : decompileSETMEMBER ( n , actions , maxn ) ; return 0 ; case SWFACTION_GETVARIABLE : decompileGETVARIABLE ( n , actions , maxn ) ; return 0 ; case SWFACTION_SETVARIABLE : decompileSETVARIABLE ( n , actions , maxn , 0 ) ; return 0 ; case SWFACTION_DEFINELOCAL : decompileSETVARIABLE ( n , actions , maxn , 1 ) ; return 0 ; case SWFACTION_DEFINELOCAL2 : decompileDEFINELOCAL2 ( n , actions , maxn ) ; return 0 ; case SWFACTION_DECREMENT : return decompileINCR_DECR ( n , actions , maxn , 0 ) ; case SWFACTION_INCREMENT : return decompileINCR_DECR ( n , actions , maxn , 1 ) ; case SWFACTION_STOREREGISTER : decompileSTOREREGISTER ( n , actions , maxn ) ; return 0 ; case SWFACTION_JUMP : return decompileJUMP ( n , actions , maxn ) ; case SWFACTION_RETURN : decompileRETURN ( n , actions , maxn ) ; return 0 ; case SWFACTION_LOGICALNOT : return decompileLogicalNot ( n , actions , maxn ) ; case SWFACTION_IF : return decompileIF ( n , actions , maxn ) ; case SWFACTION_WITH : decompileWITH ( n , actions , maxn ) ; return 0 ; case SWFACTION_ENUMERATE : return decompileENUMERATE ( n , actions , maxn , 0 ) ; case SWFACTION_ENUMERATE2 : return decompileENUMERATE ( n , actions , maxn , 1 ) ; case SWFACTION_INITARRAY : return decompileINITARRAY ( n , actions , maxn ) ; case SWFACTION_DEFINEFUNCTION : return decompileDEFINEFUNCTION ( n , actions , maxn , 0 ) ; case SWFACTION_DEFINEFUNCTION2 : return decompileDEFINEFUNCTION ( n , actions , maxn , 1 ) ; case SWFACTION_CALLFUNCTION : return decompileCALLFUNCTION ( n , actions , maxn ) ; case SWFACTION_CALLMETHOD : return decompileCALLMETHOD ( n , actions , maxn ) ; case SWFACTION_INSTANCEOF : case SWFACTION_SHIFTLEFT : case SWFACTION_SHIFTRIGHT : case SWFACTION_SHIFTRIGHT2 : case SWFACTION_ADD : case SWFACTION_ADD2 : case SWFACTION_SUBTRACT : case SWFACTION_MULTIPLY : case SWFACTION_DIVIDE : case SWFACTION_MODULO : case SWFACTION_BITWISEAND : case SWFACTION_BITWISEOR : case SWFACTION_BITWISEXOR : case SWFACTION_EQUAL : case SWFACTION_EQUALS2 : case SWFACTION_LESS2 : case SWFACTION_LOGICALAND : case SWFACTION_LOGICALOR : case SWFACTION_GREATER : case SWFACTION_LESSTHAN : case SWFACTION_STRINGEQ : case SWFACTION_STRINGCOMPARE : case SWFACTION_STRICTEQUALS : return decompileArithmeticOp ( n , actions , maxn ) ; case SWFACTION_POP : pop ( ) ; return 0 ; case SWFACTION_STARTDRAG : return decompileSTARTDRAG ( n , actions , maxn ) ; case SWFACTION_DELETE : return decompileDELETE ( n , actions , maxn , 0 ) ; case SWFACTION_DELETE2 : return decompileDELETE ( n , actions , maxn , 1 ) ; case SWFACTION_TARGETPATH : return decompileSingleArgBuiltInFunctionCall ( n , actions , maxn , ""targetPath"" ) ; case SWFACTION_TYPEOF : return decompileSingleArgBuiltInFunctionCall ( n , actions , maxn , ""typeof"" ) ; case SWFACTION_ORD : return decompileSingleArgBuiltInFunctionCall ( n , actions , maxn , ""ord"" ) ; case SWFACTION_CHR : return decompileSingleArgBuiltInFunctionCall ( n , actions , maxn , ""chr"" ) ; case SWFACTION_INT : return decompileSingleArgBuiltInFunctionCall ( n , actions , maxn , ""int"" ) ; case SWFACTION_TOSTRING : return decompileSingleArgBuiltInFunctionCall ( n , actions , maxn , ""String"" ) ; case SWFACTION_TONUMBER : return decompileSingleArgBuiltInFunctionCall ( n , actions , maxn , ""Number"" ) ; case SWFACTION_RANDOMNUMBER : return decompileSingleArgBuiltInFunctionCall ( n , actions , maxn , ""random"" ) ; case SWFACTION_STRINGLENGTH : return decompileSingleArgBuiltInFunctionCall ( n , actions , maxn , ""length"" ) ; case SWFACTION_PLAY : return decompile_Null_ArgBuiltInFunctionCall ( n , actions , maxn , ""play"" ) ; case SWFACTION_STOP : return decompile_Null_ArgBuiltInFunctionCall ( n , actions , maxn , ""stop"" ) ; case SWFACTION_NEXTFRAME : return decompile_Null_ArgBuiltInFunctionCall ( n , actions , maxn , ""nextFrame"" ) ; case SWFACTION_PREVFRAME : return decompile_Null_ArgBuiltInFunctionCall ( n , actions , maxn , ""prevFrame"" ) ; case SWFACTION_ENDDRAG : return decompile_Null_ArgBuiltInFunctionCall ( n , actions , maxn , ""stopDrag"" ) ; case SWFACTION_STOPSOUNDS : return decompile_Null_ArgBuiltInFunctionCall ( n , actions , maxn , ""stopAllSounds"" ) ; case SWFACTION_TOGGLEQUALITY : return decompile_Null_ArgBuiltInFunctionCall ( n , actions , maxn , ""toggleHighQuality"" ) ; case SWFACTION_MBSUBSTRING : case SWFACTION_SUBSTRING : return decompileSUBSTRING ( n , actions , maxn ) ; case SWFACTION_STRINGCONCAT : return decompileSTRINGCONCAT ( n , actions , maxn ) ; case SWFACTION_REMOVECLIP : return decompileREMOVECLIP ( n , actions , maxn ) ; case SWFACTION_DUPLICATECLIP : return decompileDUPLICATECLIP ( n , actions , maxn ) ; case SWFACTION_SETTARGET : return decompileSETTARGET ( n , actions , maxn , 0 ) ; case SWFACTION_SETTARGET2 : return decompileSETTARGET ( n , actions , maxn , 1 ) ; case SWFACTION_IMPLEMENTSOP : return decompileIMPLEMENTS ( n , actions , maxn ) ; case SWFACTION_CASTOP : return decompileCAST ( n , actions , maxn ) ; case SWFACTION_THROW : return decompileTHROW ( n , actions , maxn ) ; case SWFACTION_TRY : return decompileTRY ( n , actions , maxn ) ; default : outputSWF_ACTION ( n , & actions [ n ] ) ; return 0 ; } }","# ifdef DEBUG fprintf ( stderr , ""%d:\\\\tACTION[%3.3d]:<S2SV_blank>%s\\\# endif switch ( OpCode ( actions , n , maxn ) ) {",265
370,"buggy line: memcpy ( ptr , VSB_data ( synth_body ) + o , l ) ;VFP_Extend ( bo -> vfc , l ) ;cwe id:CWE-119context: static enum fetch_step vbf_stp_error ( struct worker * wrk , struct busyobj * bo ) { ssize_t l , ll , o ; double now ; uint8_t * ptr ; struct vsb * synth_body ; CHECK_OBJ_NOTNULL ( wrk , WORKER_MAGIC ) ; CHECK_OBJ_NOTNULL ( bo , BUSYOBJ_MAGIC ) ; CHECK_OBJ_NOTNULL ( bo -> fetch_objcore , OBJCORE_MAGIC ) ; AN ( bo -> fetch_objcore -> flags & OC_F_BUSY ) ; assert ( bo -> director_state == DIR_S_NULL ) ; wrk -> stats -> fetch_failed ++ ; now = W_TIM_real ( wrk ) ; VSLb_ts_busyobj ( bo , ""Error"" , now ) ; if ( bo -> fetch_objcore -> stobj -> stevedore != NULL ) ObjFreeObj ( bo -> wrk , bo -> fetch_objcore ) ; HTTP_Setup ( bo -> beresp , bo -> ws , bo -> vsl , SLT_BerespMethod ) ; http_PutResponse ( bo -> beresp , ""HTTP/1.1"" , 503 , ""Backend<S2SV_blank>fetch<S2SV_blank>failed"" ) ; http_TimeHeader ( bo -> beresp , ""Date:<S2SV_blank>"" , now ) ; http_SetHeader ( bo -> beresp , ""Server:<S2SV_blank>Varnish"" ) ; bo -> fetch_objcore -> t_origin = now ; if ( ! VTAILQ_EMPTY ( & bo -> fetch_objcore -> objhead -> waitinglist ) ) { bo -> fetch_objcore -> ttl = 1 ; bo -> fetch_objcore -> grace = 5 ; bo -> fetch_objcore -> keep = 5 ; } else { bo -> fetch_objcore -> ttl = 0 ; bo -> fetch_objcore -> grace = 0 ; bo -> fetch_objcore -> keep = 0 ; } synth_body = VSB_new_auto ( ) ; AN ( synth_body ) ; VCL_backend_error_method ( bo -> vcl , wrk , NULL , bo , synth_body ) ; AZ ( VSB_finish ( synth_body ) ) ; if ( wrk -> handling == VCL_RET_ABANDON || wrk -> handling == VCL_RET_FAIL ) { VSB_destroy ( & synth_body ) ; return ( F_STP_FAIL ) ; } if ( wrk -> handling == VCL_RET_RETRY ) { VSB_destroy ( & synth_body ) ; if ( bo -> retries ++ < cache_param -> max_retries ) return ( F_STP_RETRY ) ; VSLb ( bo -> vsl , SLT_VCL_Error , ""Too<S2SV_blank>many<S2SV_blank>retries,<S2SV_blank>failing"" ) ; return ( F_STP_FAIL ) ; } assert ( wrk -> handling == VCL_RET_DELIVER ) ; bo -> vfc -> bo = bo ; bo -> vfc -> wrk = bo -> wrk ; bo -> vfc -> oc = bo -> fetch_objcore ; bo -> vfc -> http = bo -> beresp ; bo -> vfc -> esi_req = bo -> bereq ; if ( vbf_beresp2obj ( bo ) ) { ( void ) VFP_Error ( bo -> vfc , ""Could<S2SV_blank>not<S2SV_blank>get<S2SV_blank>storage"" ) ; VSB_destroy ( & synth_body ) ; return ( F_STP_FAIL ) ; } ll = VSB_len ( synth_body ) ; o = 0 ; while ( ll > 0 ) { l = ll ; if ( VFP_GetStorage ( bo -> vfc , & l , & ptr ) != VFP_OK ) break ;  memcpy ( ptr , VSB_data ( synth_body ) + o , l ) ;  VFP_Extend ( bo -> vfc , l ) ; ll -= l ; o += l ; } AZ ( ObjSetU64 ( wrk , bo -> fetch_objcore , OA_LEN , o ) ) ; VSB_destroy ( & synth_body ) ; HSH_Unbusy ( wrk , bo -> fetch_objcore ) ; ObjSetState ( wrk , bo -> fetch_objcore , BOS_FINISHED ) ; return ( F_STP_DONE ) ; }","if ( l > ll ) l = ll ;memcpy ( ptr , VSB_data ( synth_body ) + o , l ) ;VFP_Extend ( bo -> vfc , l ) ;",266
371,"buggy line: }}cwe id:CWE-119context: int mlx4_register_vlan ( struct mlx4_dev * dev , u8 port , u16 vlan , int * index ) { struct mlx4_vlan_table * table = & mlx4_priv ( dev ) -> port [ port ] . vlan_table ; int i , err = 0 ; int free = - 1 ; mutex_lock ( & table -> mutex ) ; for ( i = MLX4_VLAN_REGULAR ; i < MLX4_MAX_VLAN_NUM ; i ++ ) { if ( free < 0 && ( table -> refs [ i ] == 0 ) ) { free = i ; continue ; } if ( table -> refs [ i ] && ( vlan == ( MLX4_VLAN_MASK & be32_to_cpu ( table -> entries [ i ] ) ) ) ) { * index = i ; ++ table -> refs [ i ] ; goto out ;  }  } if ( table -> total == table -> max ) { err = - ENOSPC ; goto out ; } table -> refs [ free ] = 1 ; table -> entries [ free ] = cpu_to_be32 ( vlan | MLX4_VLAN_VALID ) ; err = mlx4_set_port_vlan_table ( dev , port , table -> entries ) ; if ( unlikely ( err ) ) { mlx4_warn ( dev , ""Failed<S2SV_blank>adding<S2SV_blank>vlan:<S2SV_blank>%u\\n"" , vlan ) ; table -> refs [ free ] = 0 ; table -> entries [ free ] = 0 ; goto out ; } * index = free ; ++ table -> total ; out : mutex_unlock ( & table -> mutex ) ; return err ; }",}}if ( free < 0 ) {err = - ENOMEM ;goto out ;},267
372,"buggy line: if ( len < sizeof ( * prep ) ) {return ( - 1 ) ;}n = EXTRACT_32BITS ( & prep -> pp_n ) ;cwe id:CWE-125context: static int wb_prep ( netdissect_options * ndo , const struct pkt_prep * prep , u_int len ) { int n ; const struct pgstate * ps ; const u_char * ep = ndo -> ndo_snapend ; ND_PRINT ( ( ndo , ""<S2SV_blank>wb-prep:"" ) ) ;  if ( len < sizeof ( * prep ) ) {  return ( - 1 ) ;  }  n = EXTRACT_32BITS ( & prep -> pp_n ) ; ps = ( const struct pgstate * ) ( prep + 1 ) ; while ( -- n >= 0 && ND_TTEST ( * ps ) ) { const struct id_off * io , * ie ; char c = '<' ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u/%s:%u"" , EXTRACT_32BITS ( & ps -> slot ) , ipaddr_string ( ndo , & ps -> page . p_sid ) , EXTRACT_32BITS ( & ps -> page . p_uid ) ) ) ; io = ( const struct id_off * ) ( ps + 1 ) ; for ( ie = io + ps -> nid ; io < ie && ND_TTEST ( * io ) ; ++ io ) { ND_PRINT ( ( ndo , ""%c%s:%u"" , c , ipaddr_string ( ndo , & io -> id ) , EXTRACT_32BITS ( & io -> off ) ) ) ; c = ',' ; } ND_PRINT ( ( ndo , "">"" ) ) ; ps = ( const struct pgstate * ) io ; } return ( ( const u_char * ) ps <= ep ? 0 : - 1 ) ; }",if ( len < sizeof ( * prep ) || ! ND_TTEST ( * prep ) ) return ( - 1 ) ;n = EXTRACT_32BITS ( & prep -> pp_n ) ;,268
373,"buggy line: rq -> skip_clock_update = 0 ;prev -> sched_class -> put_prev_task ( rq , prev ) ;cwe id:CWE-835context: static void put_prev_task ( struct rq * rq , struct task_struct * prev ) { if ( prev -> se . on_rq ) update_rq_clock ( rq ) ;  rq -> skip_clock_update = 0 ;  prev -> sched_class -> put_prev_task ( rq , prev ) ; }","prev -> sched_class -> put_prev_task ( rq , prev ) ;",269
374,"buggy line: uint8_t value ;dev_dbg ( & usb_dev -> dev , ""atusb:<S2SV_blank>reg<S2SV_blank>=<S2SV_blank>0x%x\\\ret = atusb_control_msg ( atusb , usb_rcvctrlpipe ( usb_dev , 0 ) , ATUSB_REG_READ , ATUSB_REQ_FROM_DEV ,  0 , reg , & value , 1 , 1000 ) ;return ret >= 0 ? value : ret ;}cwe id:CWE-119context: static int atusb_read_reg ( struct atusb * atusb , uint8_t reg ) { struct usb_device * usb_dev = atusb -> usb_dev ; int ret ;  uint8_t value ;  dev_dbg ( & usb_dev -> dev , ""atusb:<S2SV_blank>reg<S2SV_blank>=<S2SV_blank>0x%x\\n"" , reg ) ; ret = atusb_control_msg ( atusb , usb_rcvctrlpipe ( usb_dev , 0 ) , ATUSB_REG_READ , ATUSB_REQ_FROM_DEV ,  0 , reg , & value , 1 , 1000 ) ;   return ret >= 0 ? value : ret ;   } ","uint8_t * buffer ;uint8_t value ;buffer = kmalloc ( 1 , GFP_KERNEL ) ;if ( ! buffer ) return - ENOMEM ;dev_dbg ( & usb_dev -> dev , ""atusb:<S2SV_blank>reg<S2SV_blank>=<S2SV_blank>0x%x\\\ret = atusb_control_msg ( atusb , usb_rcvctrlpipe ( usb_dev , 0 ) , ATUSB_REG_READ , ATUSB_REQ_FROM_DEV , 0 , reg , buffer , 1 , 1000 ) ;return ret >= 0 ) {value = buffer [ 0 ] ;kfree ( buffer ) ;return value ;}else {kfree ( buffer ) ;return ret ;}}",270
375,"buggy line: static void addModuleArgument ( sqlite3 * db , Table * pTable , char * zArg ) {int nBytes = sizeof ( char * ) * ( 2 + pTable -> nModuleArg ) ;char * * azModuleArg ;azModuleArg = sqlite3DbRealloc ( db , pTable -> azModuleArg , nBytes ) ;cwe id:CWE-190context:  static void addModuleArgument ( sqlite3 * db , Table * pTable , char * zArg ) {   int nBytes = sizeof ( char * ) * ( 2 + pTable -> nModuleArg ) ;   char * * azModuleArg ;  azModuleArg = sqlite3DbRealloc ( db , pTable -> azModuleArg , nBytes ) ; if ( azModuleArg == 0 ) { sqlite3DbFree ( db , zArg ) ; } else { int i = pTable -> nModuleArg ++ ; azModuleArg [ i ] = zArg ; azModuleArg [ i + 1 ] = 0 ; pTable -> azModuleArg = azModuleArg ; } }","static void addModuleArgument ( Parse * pParse , Table * pTable , char * zArg ) {sqlite3_int64 nBytes = sizeof ( char * ) * ( 2 + pTable -> nModuleArg ) ;char * * azModuleArg ;sqlite3 * db = pParse -> db ;if ( pTable -> nModuleArg + 3 >= db -> aLimit [ SQLITE_LIMIT_COLUMN ] ) {sqlite3ErrorMsg ( pParse , ""too<S2SV_blank>many<S2SV_blank>columns<S2SV_blank>on<S2SV_blank>%s"" , pTable -> zName ) ;}azModuleArg = sqlite3DbRealloc ( db , pTable -> azModuleArg , nBytes ) ;",271
376,"buggy line: memcpy ( outbuffer , s -> str , XMLRPC_BUFSIZE ) ;}cwe id:CWE-119context: void xmlrpc_char_encode ( char * outbuffer , const char * s1 ) { long unsigned int i ; unsigned char c ; char buf2 [ 15 ] ; mowgli_string_t * s = mowgli_string_create ( ) ; * buf2 = '\\0' ; * outbuffer = '\\0' ; if ( ( ! ( s1 ) || ( * ( s1 ) == '\\0' ) ) ) { return ; } for ( i = 0 ; s1 [ i ] != '\\0' ; i ++ ) { c = s1 [ i ] ; if ( c > 127 ) { snprintf ( buf2 , sizeof buf2 , ""&#%d;"" , c ) ; s -> append ( s , buf2 , strlen ( buf2 ) ) ; } else if ( c == '&' ) { s -> append ( s , ""&amp;"" , 5 ) ; } else if ( c == '<' ) { s -> append ( s , ""&lt;"" , 4 ) ; } else if ( c == '>' ) { s -> append ( s , ""&gt;"" , 4 ) ; } else if ( c == \'""\' ) { s -> append ( s , ""&quot;"" , 6 ) ; } else { s -> append_char ( s , c ) ; } }  memcpy ( outbuffer , s -> str , XMLRPC_BUFSIZE ) ;  }","s -> append_char ( s , 0 ) ;strncpy ( outbuffer , s -> str , XMLRPC_BUFSIZE ) ;}",272
377,"buggy line: CurrentColorSpace = ColorSpaceOut ;}Error :  cmsPipelineFree ( Lut ) ;if ( Result != NULL ) cmsPipelineFree ( Result ) ;cwe id:CWE-000context: static cmsPipeline * DefaultICCintents ( cmsContext ContextID , cmsUInt32Number nProfiles , cmsUInt32Number TheIntents [ ] , cmsHPROFILE hProfiles [ ] , cmsBool BPC [ ] , cmsFloat64Number AdaptationStates [ ] , cmsUInt32Number dwFlags ) { cmsPipeline * Lut = NULL ; cmsPipeline * Result ; cmsHPROFILE hProfile ; cmsMAT3 m ; cmsVEC3 off ; cmsColorSpaceSignature ColorSpaceIn , ColorSpaceOut , CurrentColorSpace ; cmsProfileClassSignature ClassSig ; cmsUInt32Number i , Intent ; if ( nProfiles == 0 ) return NULL ; Result = cmsPipelineAlloc ( ContextID , 0 , 0 ) ; if ( Result == NULL ) return NULL ; CurrentColorSpace = cmsGetColorSpace ( hProfiles [ 0 ] ) ; for ( i = 0 ; i < nProfiles ; i ++ ) { cmsBool lIsDeviceLink , lIsInput ; hProfile = hProfiles [ i ] ; ClassSig = cmsGetDeviceClass ( hProfile ) ; lIsDeviceLink = ( ClassSig == cmsSigLinkClass || ClassSig == cmsSigAbstractClass ) ; if ( ( i == 0 ) && ! lIsDeviceLink ) { lIsInput = TRUE ; } else { lIsInput = ( CurrentColorSpace != cmsSigXYZData ) && ( CurrentColorSpace != cmsSigLabData ) ; } Intent = TheIntents [ i ] ; if ( lIsInput || lIsDeviceLink ) { ColorSpaceIn = cmsGetColorSpace ( hProfile ) ; ColorSpaceOut = cmsGetPCS ( hProfile ) ; } else { ColorSpaceIn = cmsGetPCS ( hProfile ) ; ColorSpaceOut = cmsGetColorSpace ( hProfile ) ; } if ( ! ColorSpaceIsCompatible ( ColorSpaceIn , CurrentColorSpace ) ) { cmsSignalError ( ContextID , cmsERROR_COLORSPACE_CHECK , ""ColorSpace<S2SV_blank>mismatch"" ) ; goto Error ; } if ( lIsDeviceLink || ( ( ClassSig == cmsSigNamedColorClass ) && ( nProfiles == 1 ) ) ) { Lut = _cmsReadDevicelinkLUT ( hProfile , Intent ) ; if ( Lut == NULL ) goto Error ; if ( ClassSig == cmsSigAbstractClass && i > 0 ) { if ( ! ComputeConversion ( i , hProfiles , Intent , BPC [ i ] , AdaptationStates [ i ] , & m , & off ) ) goto Error ; } else { _cmsMAT3identity ( & m ) ; _cmsVEC3init ( & off , 0 , 0 , 0 ) ; } if ( ! AddConversion ( Result , CurrentColorSpace , ColorSpaceIn , & m , & off ) ) goto Error ; } else { if ( lIsInput ) { Lut = _cmsReadInputLUT ( hProfile , Intent ) ; if ( Lut == NULL ) goto Error ; } else { Lut = _cmsReadOutputLUT ( hProfile , Intent ) ; if ( Lut == NULL ) goto Error ; if ( ! ComputeConversion ( i , hProfiles , Intent , BPC [ i ] , AdaptationStates [ i ] , & m , & off ) ) goto Error ; if ( ! AddConversion ( Result , CurrentColorSpace , ColorSpaceIn , & m , & off ) ) goto Error ; } } if ( ! cmsPipelineCat ( Result , Lut ) ) goto Error ; cmsPipelineFree ( Lut ) ;  CurrentColorSpace = ColorSpaceOut ;  } return Result ; Error :  cmsPipelineFree ( Lut ) ;  if ( Result != NULL ) cmsPipelineFree ( Result ) ; return NULL ; cmsUNUSED_PARAMETER ( dwFlags ) ; }",Lut = NULL ;CurrentColorSpace = ColorSpaceOut ;}Error : if ( Lut != NULL ) cmsPipelineFree ( Lut ) ;if ( Result != NULL ) cmsPipelineFree ( Result ) ;,273
378,"buggy line: for ( i = 0 ;i < sec -> size ;ut32 addr32 = r_read_le32 ( buf + i ) ;cwe id:CWE-125context: static void process_constructors ( RBinFile * bf , RList * ret , int bits ) { RList * secs = sections ( bf ) ; RListIter * iter ; RBinSection * sec ; int i , type ; r_list_foreach ( secs , iter , sec ) { type = - 1 ; if ( ! strcmp ( sec -> name , "".fini_array"" ) ) { type = R_BIN_ENTRY_TYPE_FINI ; } else if ( ! strcmp ( sec -> name , "".init_array"" ) ) { type = R_BIN_ENTRY_TYPE_INIT ; } else if ( ! strcmp ( sec -> name , "".preinit_array"" ) ) { type = R_BIN_ENTRY_TYPE_PREINIT ; } if ( type != - 1 ) { ut8 * buf = calloc ( sec -> size , 1 ) ; if ( ! buf ) { continue ; } ( void ) r_buf_read_at ( bf -> buf , sec -> paddr , buf , sec -> size ) ; if ( bits == 32 ) {  for ( i = 0 ; i < sec -> size ; i += 4 ) {  ut32 addr32 = r_read_le32 ( buf + i ) ; if ( addr32 ) { RBinAddr * ba = newEntry ( sec -> paddr + i , ( ut64 ) addr32 , type , bits ) ; r_list_append ( ret , ba ) ; } } } else {  for ( i = 0 ; i < sec -> size ; i += 8 ) {  ut64 addr64 = r_read_le64 ( buf + i ) ; if ( addr64 ) { RBinAddr * ba = newEntry ( sec -> paddr + i , addr64 , type , bits ) ; r_list_append ( ret , ba ) ; } } } free ( buf ) ; } } r_list_free ( secs ) ; }",for ( i = 0 ;( i + 3 ) < sec -> size ;ut32 addr32 = r_read_le32 ( buf + i ) ;,274
379,"buggy line: for ( i = 0 ;i < sec -> size ;ut64 addr64 = r_read_le64 ( buf + i ) ;cwe id:CWE-125context: static void process_constructors ( RBinFile * bf , RList * ret , int bits ) { RList * secs = sections ( bf ) ; RListIter * iter ; RBinSection * sec ; int i , type ; r_list_foreach ( secs , iter , sec ) { type = - 1 ; if ( ! strcmp ( sec -> name , "".fini_array"" ) ) { type = R_BIN_ENTRY_TYPE_FINI ; } else if ( ! strcmp ( sec -> name , "".init_array"" ) ) { type = R_BIN_ENTRY_TYPE_INIT ; } else if ( ! strcmp ( sec -> name , "".preinit_array"" ) ) { type = R_BIN_ENTRY_TYPE_PREINIT ; } if ( type != - 1 ) { ut8 * buf = calloc ( sec -> size , 1 ) ; if ( ! buf ) { continue ; } ( void ) r_buf_read_at ( bf -> buf , sec -> paddr , buf , sec -> size ) ; if ( bits == 32 ) {  for ( i = 0 ; i < sec -> size ; i += 4 ) {  ut32 addr32 = r_read_le32 ( buf + i ) ; if ( addr32 ) { RBinAddr * ba = newEntry ( sec -> paddr + i , ( ut64 ) addr32 , type , bits ) ; r_list_append ( ret , ba ) ; } } } else {  for ( i = 0 ; i < sec -> size ; i += 8 ) {  ut64 addr64 = r_read_le64 ( buf + i ) ; if ( addr64 ) { RBinAddr * ba = newEntry ( sec -> paddr + i , addr64 , type , bits ) ; r_list_append ( ret , ba ) ; } } } free ( buf ) ; } } r_list_free ( secs ) ; }",for ( i = 0 ;( i + 7 ) < sec -> size ;ut64 addr64 = r_read_le64 ( buf + i ) ;,274
380,"buggy line: case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS : case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS_OLD :  ND_PRINT ( ( ndo , ""%sBandwidth<S2SV_blank>Constraints<S2SV_blank>Model<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(%u)"" ,  ident , tok2str ( diffserv_te_bc_values , ""unknown"" , * tptr ) , * tptr ) ) ;ND_TCHECK2 ( * tptr , 4 ) ;bw . i = EXTRACT_32BITS ( tptr ) ;cwe id:CWE-125context: static int isis_print_is_reach_subtlv ( netdissect_options * ndo , const uint8_t * tptr , u_int subt , u_int subl , const char * ident ) { u_int te_class , priority_level , gmpls_switch_cap ; union { float f ; uint32_t i ; } bw ; ND_PRINT ( ( ndo , ""%s%s<S2SV_blank>subTLV<S2SV_blank>#%u,<S2SV_blank>length:<S2SV_blank>%u"" , ident , tok2str ( isis_ext_is_reach_subtlv_values , ""unknown"" , subt ) , subt , subl ) ) ; ND_TCHECK2 ( * tptr , subl ) ; switch ( subt ) { case ISIS_SUBTLV_EXT_IS_REACH_ADMIN_GROUP : case ISIS_SUBTLV_EXT_IS_REACH_LINK_LOCAL_REMOTE_ID : case ISIS_SUBTLV_EXT_IS_REACH_LINK_REMOTE_ID : if ( subl >= 4 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( tptr ) ) ) ; if ( subl == 8 ) ND_PRINT ( ( ndo , "",<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( tptr + 4 ) ) ) ; } break ; case ISIS_SUBTLV_EXT_IS_REACH_IPV4_INTF_ADDR : case ISIS_SUBTLV_EXT_IS_REACH_IPV4_NEIGHBOR_ADDR : if ( subl >= sizeof ( struct in_addr ) ) ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case ISIS_SUBTLV_EXT_IS_REACH_MAX_LINK_BW : case ISIS_SUBTLV_EXT_IS_REACH_RESERVABLE_BW : if ( subl >= 4 ) { bw . i = EXTRACT_32BITS ( tptr ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>%.3f<S2SV_blank>Mbps"" , bw . f * 8 / 1000000 ) ) ; } break ; case ISIS_SUBTLV_EXT_IS_REACH_UNRESERVED_BW : if ( subl >= 32 ) { for ( te_class = 0 ; te_class < 8 ; te_class ++ ) { bw . i = EXTRACT_32BITS ( tptr ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>TE-Class<S2SV_blank>%u:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , ident , te_class , bw . f * 8 / 1000000 ) ) ; tptr += 4 ; } } break ; case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS : case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS_OLD :  ND_PRINT ( ( ndo , ""%sBandwidth<S2SV_blank>Constraints<S2SV_blank>Model<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(%u)"" ,  ident , tok2str ( diffserv_te_bc_values , ""unknown"" , * tptr ) , * tptr ) ) ; tptr ++ ; for ( te_class = 0 ; te_class < ( subl - 1 ) / 4 ; te_class ++ ) {  ND_TCHECK2 ( * tptr , 4 ) ;  bw . i = EXTRACT_32BITS ( tptr ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Bandwidth<S2SV_blank>constraint<S2SV_blank>CT%u:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , ident , te_class , bw . f * 8 / 1000000 ) ) ; tptr += 4 ; } break ; case ISIS_SUBTLV_EXT_IS_REACH_TE_METRIC : if ( subl >= 3 ) ND_PRINT ( ( ndo , "",<S2SV_blank>%u"" , EXTRACT_24BITS ( tptr ) ) ) ; break ; case ISIS_SUBTLV_EXT_IS_REACH_LINK_ATTRIBUTE : if ( subl == 2 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>[<S2SV_blank>%s<S2SV_blank>]<S2SV_blank>(0x%04x)"" , bittok2str ( isis_subtlv_link_attribute_values , ""Unknown"" , EXTRACT_16BITS ( tptr ) ) , EXTRACT_16BITS ( tptr ) ) ) ; } break ; case ISIS_SUBTLV_EXT_IS_REACH_LINK_PROTECTION_TYPE : if ( subl >= 2 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>%s,<S2SV_blank>Priority<S2SV_blank>%u"" , bittok2str ( gmpls_link_prot_values , ""none"" , * tptr ) , * ( tptr + 1 ) ) ) ; } break ; case ISIS_SUBTLV_SPB_METRIC : if ( subl >= 6 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>LM:<S2SV_blank>%u"" , EXTRACT_24BITS ( tptr ) ) ) ; tptr = tptr + 3 ; ND_PRINT ( ( ndo , "",<S2SV_blank>P:<S2SV_blank>%u"" , * ( tptr ) ) ) ; tptr ++ ; ND_PRINT ( ( ndo , "",<S2SV_blank>P-ID:<S2SV_blank>%u"" , EXTRACT_16BITS ( tptr ) ) ) ; } break ; case ISIS_SUBTLV_EXT_IS_REACH_INTF_SW_CAP_DESCR : if ( subl >= 36 ) { gmpls_switch_cap = * tptr ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Interface<S2SV_blank>Switching<S2SV_blank>Capability:%s"" , ident , tok2str ( gmpls_switch_cap_values , ""Unknown"" , gmpls_switch_cap ) ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>LSP<S2SV_blank>Encoding:<S2SV_blank>%s"" , tok2str ( gmpls_encoding_values , ""Unknown"" , * ( tptr + 1 ) ) ) ) ; tptr += 4 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Max<S2SV_blank>LSP<S2SV_blank>Bandwidth:"" , ident ) ) ; for ( priority_level = 0 ; priority_level < 8 ; priority_level ++ ) { bw . i = EXTRACT_32BITS ( tptr ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>priority<S2SV_blank>level<S2SV_blank>%d:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , ident , priority_level , bw . f * 8 / 1000000 ) ) ; tptr += 4 ; } subl -= 36 ; switch ( gmpls_switch_cap ) { case GMPLS_PSC1 : case GMPLS_PSC2 : case GMPLS_PSC3 : case GMPLS_PSC4 : ND_TCHECK2 ( * tptr , 6 ) ; bw . i = EXTRACT_32BITS ( tptr ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Min<S2SV_blank>LSP<S2SV_blank>Bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , ident , bw . f * 8 / 1000000 ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Interface<S2SV_blank>MTU:<S2SV_blank>%u"" , ident , EXTRACT_16BITS ( tptr + 4 ) ) ) ; break ; case GMPLS_TSC : ND_TCHECK2 ( * tptr , 8 ) ; bw . i = EXTRACT_32BITS ( tptr ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Min<S2SV_blank>LSP<S2SV_blank>Bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , ident , bw . f * 8 / 1000000 ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Indication<S2SV_blank>%s"" , ident , tok2str ( gmpls_switch_cap_tsc_indication_values , ""Unknown<S2SV_blank>(%u)"" , * ( tptr + 4 ) ) ) ) ; break ; default : if ( subl > 0 ) { if ( ! print_unknown_data ( ndo , tptr , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , subl ) ) return ( 0 ) ; } } } break ; default : if ( ! print_unknown_data ( ndo , tptr , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , subl ) ) return ( 0 ) ; break ; } return ( 1 ) ; trunc : return ( 0 ) ; }","case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS : case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS_OLD : if ( subl == 0 ) break ;ND_PRINT ( ( ndo , ""%sBandwidth<S2SV_blank>Constraints<S2SV_blank>Model<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(%u)"" , ident , tok2str ( diffserv_te_bc_values , ""unknown"" , * tptr ) , * tptr ) ) ;ND_TCHECK2 ( * tptr , 4 ) ;bw . i = EXTRACT_32BITS ( tptr ) ;",275
381,"buggy line: if ( anal_size == 40 ) {cwe id:CWE-787context: WORD32 ixheaacd_complex_anal_filt ( ia_esbr_hbe_txposer_struct * ptr_hbe_txposer ) { WORD32 idx ; WORD32 anal_size = 2 * ptr_hbe_txposer -> synth_size ; WORD32 N = ( 10 * anal_size ) ; for ( idx = 0 ; idx < ( ptr_hbe_txposer -> no_bins >> 1 ) ; idx ++ ) { WORD32 i , j , k , l ; FLOAT32 window_output [ 640 ] ; FLOAT32 u [ 128 ] , u_in [ 256 ] , u_out [ 256 ] ; FLOAT32 accu_r , accu_i ; const FLOAT32 * inp_signal ; FLOAT32 * anal_buf ; FLOAT32 * analy_cos_sin_tab = ptr_hbe_txposer -> analy_cos_sin_tab ; const FLOAT32 * interp_window_coeff = ptr_hbe_txposer -> analy_wind_coeff ; FLOAT32 * x = ptr_hbe_txposer -> analy_buf ; memset ( ptr_hbe_txposer -> qmf_in_buf [ idx + HBE_OPER_WIN_LEN - 1 ] , 0 , TWICE_QMF_SYNTH_CHANNELS_NUM * sizeof ( FLOAT32 ) ) ; inp_signal = ptr_hbe_txposer -> ptr_input_buf + idx * 2 * ptr_hbe_txposer -> synth_size + 1 ; anal_buf = & ptr_hbe_txposer -> qmf_in_buf [ idx + HBE_OPER_WIN_LEN - 1 ] [ 4 * ptr_hbe_txposer -> k_start ] ; for ( i = N - 1 ; i >= anal_size ; i -- ) { x [ i ] = x [ i - anal_size ] ; } for ( i = anal_size - 1 ; i >= 0 ; i -- ) { x [ i ] = inp_signal [ anal_size - 1 - i ] ; } for ( i = 0 ; i < N ; i ++ ) { window_output [ i ] = x [ i ] * interp_window_coeff [ i ] ; } for ( i = 0 ; i < 2 * anal_size ; i ++ ) { accu_r = 0.0 ; for ( j = 0 ; j < 5 ; j ++ ) { accu_r = accu_r + window_output [ i + j * 2 * anal_size ] ; } u [ i ] = accu_r ; } if ( anal_size == 40 ) { for ( i = 1 ; i < anal_size ; i ++ ) { FLOAT32 temp1 = u [ i ] + u [ 2 * anal_size - i ] ; FLOAT32 temp2 = u [ i ] - u [ 2 * anal_size - i ] ; u [ i ] = temp1 ; u [ 2 * anal_size - i ] = temp2 ; } for ( k = 0 ; k < anal_size ; k ++ ) { accu_r = u [ anal_size ] ; if ( k & 1 ) accu_i = u [ 0 ] ; else accu_i = - u [ 0 ] ; for ( l = 1 ; l < anal_size ; l ++ ) { accu_r = accu_r + u [ 0 + l ] * analy_cos_sin_tab [ 2 * l + 0 ] ; accu_i = accu_i + u [ 2 * anal_size - l ] * analy_cos_sin_tab [ 2 * l + 1 ] ; } analy_cos_sin_tab += ( 2 * anal_size ) ; * anal_buf ++ = ( FLOAT32 ) accu_r ; * anal_buf ++ = ( FLOAT32 ) accu_i ; } } else { FLOAT32 * ptr_u = u_in ; FLOAT32 * ptr_v = u_out ; for ( k = 0 ; k < anal_size * 2 ; k ++ ) { * ptr_u ++ = ( ( * analy_cos_sin_tab ++ ) * u [ k ] ) ; * ptr_u ++ = ( ( * analy_cos_sin_tab ++ ) * u [ k ] ) ; }  if ( ixheaacd_cmplx_anal_fft != NULL )   ( * ixheaacd_cmplx_anal_fft ) ( u_in , u_out , anal_size * 2 ) ;  else return - 1 ; for ( k = 0 ; k < anal_size / 2 ; k ++ ) { * ( anal_buf + 1 ) = - * ptr_v ++ ; * anal_buf = * ptr_v ++ ; anal_buf += 2 ; * ( anal_buf + 1 ) = * ptr_v ++ ; * anal_buf = - * ptr_v ++ ; anal_buf += 2 ; } } } return 0 ; }",if ( ptr_hbe_txposer -> anal_size == 40 ) {,276
382,"buggy line: if ( ixheaacd_cmplx_anal_fft != NULL )   ( * ixheaacd_cmplx_anal_fft ) ( u_in , u_out , anal_size * 2 ) ;else return - 1 ;cwe id:CWE-787context: WORD32 ixheaacd_complex_anal_filt ( ia_esbr_hbe_txposer_struct * ptr_hbe_txposer ) { WORD32 idx ; WORD32 anal_size = 2 * ptr_hbe_txposer -> synth_size ; WORD32 N = ( 10 * anal_size ) ; for ( idx = 0 ; idx < ( ptr_hbe_txposer -> no_bins >> 1 ) ; idx ++ ) { WORD32 i , j , k , l ; FLOAT32 window_output [ 640 ] ; FLOAT32 u [ 128 ] , u_in [ 256 ] , u_out [ 256 ] ; FLOAT32 accu_r , accu_i ; const FLOAT32 * inp_signal ; FLOAT32 * anal_buf ; FLOAT32 * analy_cos_sin_tab = ptr_hbe_txposer -> analy_cos_sin_tab ; const FLOAT32 * interp_window_coeff = ptr_hbe_txposer -> analy_wind_coeff ; FLOAT32 * x = ptr_hbe_txposer -> analy_buf ; memset ( ptr_hbe_txposer -> qmf_in_buf [ idx + HBE_OPER_WIN_LEN - 1 ] , 0 , TWICE_QMF_SYNTH_CHANNELS_NUM * sizeof ( FLOAT32 ) ) ; inp_signal = ptr_hbe_txposer -> ptr_input_buf + idx * 2 * ptr_hbe_txposer -> synth_size + 1 ; anal_buf = & ptr_hbe_txposer -> qmf_in_buf [ idx + HBE_OPER_WIN_LEN - 1 ] [ 4 * ptr_hbe_txposer -> k_start ] ; for ( i = N - 1 ; i >= anal_size ; i -- ) { x [ i ] = x [ i - anal_size ] ; } for ( i = anal_size - 1 ; i >= 0 ; i -- ) { x [ i ] = inp_signal [ anal_size - 1 - i ] ; } for ( i = 0 ; i < N ; i ++ ) { window_output [ i ] = x [ i ] * interp_window_coeff [ i ] ; } for ( i = 0 ; i < 2 * anal_size ; i ++ ) { accu_r = 0.0 ; for ( j = 0 ; j < 5 ; j ++ ) { accu_r = accu_r + window_output [ i + j * 2 * anal_size ] ; } u [ i ] = accu_r ; } if ( anal_size == 40 ) { for ( i = 1 ; i < anal_size ; i ++ ) { FLOAT32 temp1 = u [ i ] + u [ 2 * anal_size - i ] ; FLOAT32 temp2 = u [ i ] - u [ 2 * anal_size - i ] ; u [ i ] = temp1 ; u [ 2 * anal_size - i ] = temp2 ; } for ( k = 0 ; k < anal_size ; k ++ ) { accu_r = u [ anal_size ] ; if ( k & 1 ) accu_i = u [ 0 ] ; else accu_i = - u [ 0 ] ; for ( l = 1 ; l < anal_size ; l ++ ) { accu_r = accu_r + u [ 0 + l ] * analy_cos_sin_tab [ 2 * l + 0 ] ; accu_i = accu_i + u [ 2 * anal_size - l ] * analy_cos_sin_tab [ 2 * l + 1 ] ; } analy_cos_sin_tab += ( 2 * anal_size ) ; * anal_buf ++ = ( FLOAT32 ) accu_r ; * anal_buf ++ = ( FLOAT32 ) accu_i ; } } else { FLOAT32 * ptr_u = u_in ; FLOAT32 * ptr_v = u_out ; for ( k = 0 ; k < anal_size * 2 ; k ++ ) { * ptr_u ++ = ( ( * analy_cos_sin_tab ++ ) * u [ k ] ) ; * ptr_u ++ = ( ( * analy_cos_sin_tab ++ ) * u [ k ] ) ; }  if ( ixheaacd_cmplx_anal_fft != NULL )   ( * ixheaacd_cmplx_anal_fft ) ( u_in , u_out , anal_size * 2 ) ;  else return - 1 ; for ( k = 0 ; k < anal_size / 2 ; k ++ ) { * ( anal_buf + 1 ) = - * ptr_v ++ ; * anal_buf = * ptr_v ++ ; anal_buf += 2 ; * ( anal_buf + 1 ) = * ptr_v ++ ; * anal_buf = - * ptr_v ++ ; anal_buf += 2 ; } } } return 0 ; }","if ( ixheaacd_cmplx_anal_fft != NULL ) ( * ( ptr_hbe_txposer -> ixheaacd_cmplx_anal_fft ) ) ( u_in , u_out , anal_size * 2 ) ;else return - 1 ;",276
383,"buggy line: while ( p < q ) p += enclen ( reg -> enc , p ) ;}cwe id:CWE-125context: static int forward_search_range ( regex_t * reg , const UChar * str , const UChar * end , UChar * s , UChar * range , UChar * * low , UChar * * high , UChar * * low_prev ) { UChar * p , * pprev = ( UChar * ) NULL ; # ifdef ONIG_DEBUG_SEARCH fprintf ( stderr , ""forward_search_range:<S2SV_blank>str:<S2SV_blank>%d,<S2SV_blank>end:<S2SV_blank>%d,<S2SV_blank>s:<S2SV_blank>%d,<S2SV_blank>range:<S2SV_blank>%d\\n"" , ( int ) str , ( int ) end , ( int ) s , ( int ) range ) ; # endif p = s ; if ( reg -> dmin > 0 ) { if ( ONIGENC_IS_SINGLEBYTE ( reg -> enc ) ) { p += reg -> dmin ; } else { UChar * q = p + reg -> dmin ;  while ( p < q ) p += enclen ( reg -> enc , p ) ;  } } retry : switch ( reg -> optimize ) { case ONIG_OPTIMIZE_EXACT : p = slow_search ( reg -> enc , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_IC : p = slow_search_ic ( reg -> enc , reg -> case_fold_flag , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_BM : p = bm_search ( reg , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_BM_NOT_REV : p = bm_search_notrev ( reg , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_MAP : p = map_search ( reg -> enc , reg -> map , p , range ) ; break ; } if ( p && p < range ) { if ( p - reg -> dmin < s ) { retry_gate : pprev = p ; p += enclen ( reg -> enc , p ) ; goto retry ; } if ( reg -> sub_anchor ) { UChar * prev ; switch ( reg -> sub_anchor ) { case ANCHOR_BEGIN_LINE : if ( ! ON_STR_BEGIN ( p ) ) { prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , p ) ; if ( ! ONIGENC_IS_MBC_NEWLINE ( reg -> enc , prev , end ) ) goto retry_gate ; } break ; case ANCHOR_END_LINE : if ( ON_STR_END ( p ) ) { # ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE prev = ( UChar * ) onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , p ) ; if ( prev && ONIGENC_IS_MBC_NEWLINE ( reg -> enc , prev , end ) ) goto retry_gate ; # endif } else if ( ! ONIGENC_IS_MBC_NEWLINE ( reg -> enc , p , end ) # ifdef USE_CRNL_AS_LINE_TERMINATOR && ! ONIGENC_IS_MBC_CRNL ( reg -> enc , p , end ) # endif ) goto retry_gate ; break ; } } if ( reg -> dmax == 0 ) { * low = p ; if ( low_prev ) { if ( * low > s ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , s , p ) ; else * low_prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , p ) ; } } else { if ( reg -> dmax != ONIG_INFINITE_DISTANCE ) { * low = p - reg -> dmax ; if ( * low > s ) { * low = onigenc_get_right_adjust_char_head_with_prev ( reg -> enc , s , * low , ( const UChar * * ) low_prev ) ; if ( low_prev && IS_NULL ( * low_prev ) ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : s ) , * low ) ; } else { if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , * low ) ; } } } * high = p - reg -> dmin ; # ifdef ONIG_DEBUG_SEARCH fprintf ( stderr , ""forward_search_range<S2SV_blank>success:<S2SV_blank>low:<S2SV_blank>%d,<S2SV_blank>high:<S2SV_blank>%d,<S2SV_blank>dmin:<S2SV_blank>%d,<S2SV_blank>dmax:<S2SV_blank>%d\\n"" , ( int ) ( * low - str ) , ( int ) ( * high - str ) , reg -> dmin , reg -> dmax ) ; # endif return 1 ; } return 0 ; }","if ( q >= end ) return 0 ;while ( p < q ) p += enclen ( reg -> enc , p ) ;}",277
384,"buggy line: static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq )  {struct bfq_data * bfqd = bfqq -> bfqd ;enum bfqq_expiration reason ;spin_lock_irqsave ( & bfqd -> lock , flags ) ;bfq_clear_bfqq_wait_request ( bfqq ) ;}if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ;cwe id:CWE-416context:  static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq )  {  struct bfq_data * bfqd = bfqq -> bfqd ;  enum bfqq_expiration reason ; unsigned long flags ;  spin_lock_irqsave ( & bfqd -> lock , flags ) ;  bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ;  }  if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }","static void bfq_idle_slice_timer_body ( struct bfq_data * bfqd , struct bfq_queue * bfqq ) {enum bfqq_expiration reason ;spin_lock_irqsave ( & bfqd -> lock , flags ) ;}bfq_clear_bfqq_wait_request ( bfqq ) ;if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ;",278
385,"buggy line: if ( key_is_instantiated ( key ) &&  ( size_t ) key -> payload . data [ big_key_len ] > BIG_KEY_FILE_THRESHOLD ) vfs_truncate ( path , 0 ) ;cwe id:CWE-20context: void big_key_revoke ( struct key * key ) { struct path * path = ( struct path * ) & key -> payload . data [ big_key_path ] ; key_payload_reserve ( key , 0 ) ;  if ( key_is_instantiated ( key ) &&  ( size_t ) key -> payload . data [ big_key_len ] > BIG_KEY_FILE_THRESHOLD ) vfs_truncate ( path , 0 ) ; }","if ( key_is_positive ( key ) && ( size_t ) key -> payload . data [ big_key_len ] > BIG_KEY_FILE_THRESHOLD ) vfs_truncate ( path , 0 ) ;",279
386,"buggy line: RING_FINAL_CHECK_FOR_REQUESTS ( & vif -> tx , work_to_do ) ;if ( ! work_to_do ) {cwe id:CWE-20context: static unsigned xen_netbk_tx_build_gops ( struct xen_netbk * netbk ) { struct gnttab_copy * gop = netbk -> tx_copy_ops , * request_gop ; struct sk_buff * skb ; int ret ; while ( ( ( nr_pending_reqs ( netbk ) + MAX_SKB_FRAGS ) < MAX_PENDING_REQS ) && ! list_empty ( & netbk -> net_schedule_list ) ) { struct xenvif * vif ; struct xen_netif_tx_request txreq ; struct xen_netif_tx_request txfrags [ MAX_SKB_FRAGS ] ; struct page * page ; struct xen_netif_extra_info extras [ XEN_NETIF_EXTRA_TYPE_MAX - 1 ] ; u16 pending_idx ; RING_IDX idx ; int work_to_do ; unsigned int data_len ; pending_ring_idx_t index ; vif = poll_net_schedule_list ( netbk ) ; if ( ! vif ) continue ;  RING_FINAL_CHECK_FOR_REQUESTS ( & vif -> tx , work_to_do ) ;  if ( ! work_to_do ) { xenvif_put ( vif ) ; continue ; } idx = vif -> tx . req_cons ; rmb ( ) ; memcpy ( & txreq , RING_GET_REQUEST ( & vif -> tx , idx ) , sizeof ( txreq ) ) ; if ( txreq . size > vif -> remaining_credit && tx_credit_exceeded ( vif , txreq . size ) ) { xenvif_put ( vif ) ; continue ; } vif -> remaining_credit -= txreq . size ; work_to_do -- ; vif -> tx . req_cons = ++ idx ; memset ( extras , 0 , sizeof ( extras ) ) ; if ( txreq . flags & XEN_NETTXF_extra_info ) { work_to_do = xen_netbk_get_extras ( vif , extras , work_to_do ) ; idx = vif -> tx . req_cons ;  if ( unlikely ( work_to_do < 0 ) ) {  netbk_tx_err ( vif , & txreq , idx ) ; continue ; } } ret = netbk_count_requests ( vif , & txreq , txfrags , work_to_do ) ;  if ( unlikely ( ret < 0 ) ) {  netbk_tx_err ( vif , & txreq , idx - ret ) ; continue ; } idx += ret ; if ( unlikely ( txreq . size < ETH_HLEN ) ) { netdev_dbg ( vif -> dev , ""Bad<S2SV_blank>packet<S2SV_blank>size:<S2SV_blank>%d\\n"" , txreq . size ) ; netbk_tx_err ( vif , & txreq , idx ) ; continue ; } if ( unlikely ( ( txreq . offset + txreq . size ) > PAGE_SIZE ) ) {  netdev_dbg ( vif -> dev ,  ""txreq.offset:<S2SV_blank>%x,<S2SV_blank>size:<S2SV_blank>%u,<S2SV_blank>end:<S2SV_blank>%lu\\n"" , txreq . offset , txreq . size , ( txreq . offset & ~ PAGE_MASK ) + txreq . size ) ;  netbk_tx_err ( vif , & txreq , idx ) ;  continue ; } index = pending_index ( netbk -> pending_cons ) ; pending_idx = netbk -> pending_ring [ index ] ; data_len = ( txreq . size > PKT_PROT_LEN && ret < MAX_SKB_FRAGS ) ? PKT_PROT_LEN : txreq . size ; skb = alloc_skb ( data_len + NET_SKB_PAD + NET_IP_ALIGN , GFP_ATOMIC | __GFP_NOWARN ) ; if ( unlikely ( skb == NULL ) ) { netdev_dbg ( vif -> dev , ""Can\'t<S2SV_blank>allocate<S2SV_blank>a<S2SV_blank>skb<S2SV_blank>in<S2SV_blank>start_xmit.\\n"" ) ; netbk_tx_err ( vif , & txreq , idx ) ; break ; } skb_reserve ( skb , NET_SKB_PAD + NET_IP_ALIGN ) ; if ( extras [ XEN_NETIF_EXTRA_TYPE_GSO - 1 ] . type ) { struct xen_netif_extra_info * gso ; gso = & extras [ XEN_NETIF_EXTRA_TYPE_GSO - 1 ] ; if ( netbk_set_skb_gso ( vif , skb , gso ) ) { kfree_skb ( skb ) ;  netbk_tx_err ( vif , & txreq , idx ) ;  continue ; } } page = xen_netbk_alloc_page ( netbk , skb , pending_idx ) ; if ( ! page ) { kfree_skb ( skb ) ; netbk_tx_err ( vif , & txreq , idx ) ; continue ; } gop -> source . u . ref = txreq . gref ; gop -> source . domid = vif -> domid ; gop -> source . offset = txreq . offset ; gop -> dest . u . gmfn = virt_to_mfn ( page_address ( page ) ) ; gop -> dest . domid = DOMID_SELF ; gop -> dest . offset = txreq . offset ; gop -> len = txreq . size ; gop -> flags = GNTCOPY_source_gref ; gop ++ ; memcpy ( & netbk -> pending_tx_info [ pending_idx ] . req , & txreq , sizeof ( txreq ) ) ; netbk -> pending_tx_info [ pending_idx ] . vif = vif ; * ( ( u16 * ) skb -> data ) = pending_idx ; __skb_put ( skb , data_len ) ; skb_shinfo ( skb ) -> nr_frags = ret ; if ( data_len < txreq . size ) { skb_shinfo ( skb ) -> nr_frags ++ ; frag_set_pending_idx ( & skb_shinfo ( skb ) -> frags [ 0 ] , pending_idx ) ; } else { frag_set_pending_idx ( & skb_shinfo ( skb ) -> frags [ 0 ] , INVALID_PENDING_IDX ) ; } netbk -> pending_cons ++ ; request_gop = xen_netbk_get_requests ( netbk , vif , skb , txfrags , gop ) ; if ( request_gop == NULL ) { kfree_skb ( skb ) ; netbk_tx_err ( vif , & txreq , idx ) ; continue ; } gop = request_gop ; __skb_queue_tail ( & netbk -> tx_queue , skb ) ; vif -> tx . req_cons = idx ; xen_netbk_check_rx_xenvif ( vif ) ; if ( ( gop - netbk -> tx_copy_ops ) >= ARRAY_SIZE ( netbk -> tx_copy_ops ) ) break ; } return gop - netbk -> tx_copy_ops ; }","if ( vif -> tx . sring -> req_prod - vif -> tx . req_cons > XEN_NETIF_TX_RING_SIZE ) {netdev_err ( vif -> dev , ""Impossible<S2SV_blank>number<S2SV_blank>of<S2SV_blank>requests.<S2SV_blank>"" ""req_prod<S2SV_blank>%d,<S2SV_blank>req_cons<S2SV_blank>%d,<S2SV_blank>size<S2SV_blank>%ld\\\netbk_fatal_tx_err ( vif ) ;continue ;}RING_FINAL_CHECK_FOR_REQUESTS ( & vif -> tx , work_to_do ) ;if ( ! work_to_do ) {",280
387,"buggy line: if ( unlikely ( work_to_do < 0 ) ) {netbk_tx_err ( vif , & txreq , idx ) ;continue ;}if ( unlikely ( ret < 0 ) ) {netbk_tx_err ( vif , & txreq , idx - ret ) ;continue ;}cwe id:CWE-20context: static unsigned xen_netbk_tx_build_gops ( struct xen_netbk * netbk ) { struct gnttab_copy * gop = netbk -> tx_copy_ops , * request_gop ; struct sk_buff * skb ; int ret ; while ( ( ( nr_pending_reqs ( netbk ) + MAX_SKB_FRAGS ) < MAX_PENDING_REQS ) && ! list_empty ( & netbk -> net_schedule_list ) ) { struct xenvif * vif ; struct xen_netif_tx_request txreq ; struct xen_netif_tx_request txfrags [ MAX_SKB_FRAGS ] ; struct page * page ; struct xen_netif_extra_info extras [ XEN_NETIF_EXTRA_TYPE_MAX - 1 ] ; u16 pending_idx ; RING_IDX idx ; int work_to_do ; unsigned int data_len ; pending_ring_idx_t index ; vif = poll_net_schedule_list ( netbk ) ; if ( ! vif ) continue ;  RING_FINAL_CHECK_FOR_REQUESTS ( & vif -> tx , work_to_do ) ;  if ( ! work_to_do ) { xenvif_put ( vif ) ; continue ; } idx = vif -> tx . req_cons ; rmb ( ) ; memcpy ( & txreq , RING_GET_REQUEST ( & vif -> tx , idx ) , sizeof ( txreq ) ) ; if ( txreq . size > vif -> remaining_credit && tx_credit_exceeded ( vif , txreq . size ) ) { xenvif_put ( vif ) ; continue ; } vif -> remaining_credit -= txreq . size ; work_to_do -- ; vif -> tx . req_cons = ++ idx ; memset ( extras , 0 , sizeof ( extras ) ) ; if ( txreq . flags & XEN_NETTXF_extra_info ) { work_to_do = xen_netbk_get_extras ( vif , extras , work_to_do ) ; idx = vif -> tx . req_cons ;  if ( unlikely ( work_to_do < 0 ) ) {  netbk_tx_err ( vif , & txreq , idx ) ; continue ; } } ret = netbk_count_requests ( vif , & txreq , txfrags , work_to_do ) ;  if ( unlikely ( ret < 0 ) ) {  netbk_tx_err ( vif , & txreq , idx - ret ) ; continue ; } idx += ret ; if ( unlikely ( txreq . size < ETH_HLEN ) ) { netdev_dbg ( vif -> dev , ""Bad<S2SV_blank>packet<S2SV_blank>size:<S2SV_blank>%d\\n"" , txreq . size ) ; netbk_tx_err ( vif , & txreq , idx ) ; continue ; } if ( unlikely ( ( txreq . offset + txreq . size ) > PAGE_SIZE ) ) {  netdev_dbg ( vif -> dev ,  ""txreq.offset:<S2SV_blank>%x,<S2SV_blank>size:<S2SV_blank>%u,<S2SV_blank>end:<S2SV_blank>%lu\\n"" , txreq . offset , txreq . size , ( txreq . offset & ~ PAGE_MASK ) + txreq . size ) ;  netbk_tx_err ( vif , & txreq , idx ) ;  continue ; } index = pending_index ( netbk -> pending_cons ) ; pending_idx = netbk -> pending_ring [ index ] ; data_len = ( txreq . size > PKT_PROT_LEN && ret < MAX_SKB_FRAGS ) ? PKT_PROT_LEN : txreq . size ; skb = alloc_skb ( data_len + NET_SKB_PAD + NET_IP_ALIGN , GFP_ATOMIC | __GFP_NOWARN ) ; if ( unlikely ( skb == NULL ) ) { netdev_dbg ( vif -> dev , ""Can\'t<S2SV_blank>allocate<S2SV_blank>a<S2SV_blank>skb<S2SV_blank>in<S2SV_blank>start_xmit.\\n"" ) ; netbk_tx_err ( vif , & txreq , idx ) ; break ; } skb_reserve ( skb , NET_SKB_PAD + NET_IP_ALIGN ) ; if ( extras [ XEN_NETIF_EXTRA_TYPE_GSO - 1 ] . type ) { struct xen_netif_extra_info * gso ; gso = & extras [ XEN_NETIF_EXTRA_TYPE_GSO - 1 ] ; if ( netbk_set_skb_gso ( vif , skb , gso ) ) { kfree_skb ( skb ) ;  netbk_tx_err ( vif , & txreq , idx ) ;  continue ; } } page = xen_netbk_alloc_page ( netbk , skb , pending_idx ) ; if ( ! page ) { kfree_skb ( skb ) ; netbk_tx_err ( vif , & txreq , idx ) ; continue ; } gop -> source . u . ref = txreq . gref ; gop -> source . domid = vif -> domid ; gop -> source . offset = txreq . offset ; gop -> dest . u . gmfn = virt_to_mfn ( page_address ( page ) ) ; gop -> dest . domid = DOMID_SELF ; gop -> dest . offset = txreq . offset ; gop -> len = txreq . size ; gop -> flags = GNTCOPY_source_gref ; gop ++ ; memcpy ( & netbk -> pending_tx_info [ pending_idx ] . req , & txreq , sizeof ( txreq ) ) ; netbk -> pending_tx_info [ pending_idx ] . vif = vif ; * ( ( u16 * ) skb -> data ) = pending_idx ; __skb_put ( skb , data_len ) ; skb_shinfo ( skb ) -> nr_frags = ret ; if ( data_len < txreq . size ) { skb_shinfo ( skb ) -> nr_frags ++ ; frag_set_pending_idx ( & skb_shinfo ( skb ) -> frags [ 0 ] , pending_idx ) ; } else { frag_set_pending_idx ( & skb_shinfo ( skb ) -> frags [ 0 ] , INVALID_PENDING_IDX ) ; } netbk -> pending_cons ++ ; request_gop = xen_netbk_get_requests ( netbk , vif , skb , txfrags , gop ) ; if ( request_gop == NULL ) { kfree_skb ( skb ) ; netbk_tx_err ( vif , & txreq , idx ) ; continue ; } gop = request_gop ; __skb_queue_tail ( & netbk -> tx_queue , skb ) ; vif -> tx . req_cons = idx ; xen_netbk_check_rx_xenvif ( vif ) ; if ( ( gop - netbk -> tx_copy_ops ) >= ARRAY_SIZE ( netbk -> tx_copy_ops ) ) break ; } return gop - netbk -> tx_copy_ops ; }",if ( unlikely ( work_to_do < 0 ) ) continue ;if ( unlikely ( ret < 0 ) ) continue ;,280
388,"buggy line: netdev_dbg ( vif -> dev ,  ""txreq.offset:<S2SV_blank>%x,<S2SV_blank>size:<S2SV_blank>%u,<S2SV_blank>end:<S2SV_blank>%lu\\\netbk_tx_err ( vif , & txreq , idx ) ;continue ;cwe id:CWE-20context: static unsigned xen_netbk_tx_build_gops ( struct xen_netbk * netbk ) { struct gnttab_copy * gop = netbk -> tx_copy_ops , * request_gop ; struct sk_buff * skb ; int ret ; while ( ( ( nr_pending_reqs ( netbk ) + MAX_SKB_FRAGS ) < MAX_PENDING_REQS ) && ! list_empty ( & netbk -> net_schedule_list ) ) { struct xenvif * vif ; struct xen_netif_tx_request txreq ; struct xen_netif_tx_request txfrags [ MAX_SKB_FRAGS ] ; struct page * page ; struct xen_netif_extra_info extras [ XEN_NETIF_EXTRA_TYPE_MAX - 1 ] ; u16 pending_idx ; RING_IDX idx ; int work_to_do ; unsigned int data_len ; pending_ring_idx_t index ; vif = poll_net_schedule_list ( netbk ) ; if ( ! vif ) continue ;  RING_FINAL_CHECK_FOR_REQUESTS ( & vif -> tx , work_to_do ) ;  if ( ! work_to_do ) { xenvif_put ( vif ) ; continue ; } idx = vif -> tx . req_cons ; rmb ( ) ; memcpy ( & txreq , RING_GET_REQUEST ( & vif -> tx , idx ) , sizeof ( txreq ) ) ; if ( txreq . size > vif -> remaining_credit && tx_credit_exceeded ( vif , txreq . size ) ) { xenvif_put ( vif ) ; continue ; } vif -> remaining_credit -= txreq . size ; work_to_do -- ; vif -> tx . req_cons = ++ idx ; memset ( extras , 0 , sizeof ( extras ) ) ; if ( txreq . flags & XEN_NETTXF_extra_info ) { work_to_do = xen_netbk_get_extras ( vif , extras , work_to_do ) ; idx = vif -> tx . req_cons ;  if ( unlikely ( work_to_do < 0 ) ) {  netbk_tx_err ( vif , & txreq , idx ) ; continue ; } } ret = netbk_count_requests ( vif , & txreq , txfrags , work_to_do ) ;  if ( unlikely ( ret < 0 ) ) {  netbk_tx_err ( vif , & txreq , idx - ret ) ; continue ; } idx += ret ; if ( unlikely ( txreq . size < ETH_HLEN ) ) { netdev_dbg ( vif -> dev , ""Bad<S2SV_blank>packet<S2SV_blank>size:<S2SV_blank>%d\\n"" , txreq . size ) ; netbk_tx_err ( vif , & txreq , idx ) ; continue ; } if ( unlikely ( ( txreq . offset + txreq . size ) > PAGE_SIZE ) ) {  netdev_dbg ( vif -> dev ,  ""txreq.offset:<S2SV_blank>%x,<S2SV_blank>size:<S2SV_blank>%u,<S2SV_blank>end:<S2SV_blank>%lu\\n"" , txreq . offset , txreq . size , ( txreq . offset & ~ PAGE_MASK ) + txreq . size ) ;  netbk_tx_err ( vif , & txreq , idx ) ;  continue ; } index = pending_index ( netbk -> pending_cons ) ; pending_idx = netbk -> pending_ring [ index ] ; data_len = ( txreq . size > PKT_PROT_LEN && ret < MAX_SKB_FRAGS ) ? PKT_PROT_LEN : txreq . size ; skb = alloc_skb ( data_len + NET_SKB_PAD + NET_IP_ALIGN , GFP_ATOMIC | __GFP_NOWARN ) ; if ( unlikely ( skb == NULL ) ) { netdev_dbg ( vif -> dev , ""Can\'t<S2SV_blank>allocate<S2SV_blank>a<S2SV_blank>skb<S2SV_blank>in<S2SV_blank>start_xmit.\\n"" ) ; netbk_tx_err ( vif , & txreq , idx ) ; break ; } skb_reserve ( skb , NET_SKB_PAD + NET_IP_ALIGN ) ; if ( extras [ XEN_NETIF_EXTRA_TYPE_GSO - 1 ] . type ) { struct xen_netif_extra_info * gso ; gso = & extras [ XEN_NETIF_EXTRA_TYPE_GSO - 1 ] ; if ( netbk_set_skb_gso ( vif , skb , gso ) ) { kfree_skb ( skb ) ;  netbk_tx_err ( vif , & txreq , idx ) ;  continue ; } } page = xen_netbk_alloc_page ( netbk , skb , pending_idx ) ; if ( ! page ) { kfree_skb ( skb ) ; netbk_tx_err ( vif , & txreq , idx ) ; continue ; } gop -> source . u . ref = txreq . gref ; gop -> source . domid = vif -> domid ; gop -> source . offset = txreq . offset ; gop -> dest . u . gmfn = virt_to_mfn ( page_address ( page ) ) ; gop -> dest . domid = DOMID_SELF ; gop -> dest . offset = txreq . offset ; gop -> len = txreq . size ; gop -> flags = GNTCOPY_source_gref ; gop ++ ; memcpy ( & netbk -> pending_tx_info [ pending_idx ] . req , & txreq , sizeof ( txreq ) ) ; netbk -> pending_tx_info [ pending_idx ] . vif = vif ; * ( ( u16 * ) skb -> data ) = pending_idx ; __skb_put ( skb , data_len ) ; skb_shinfo ( skb ) -> nr_frags = ret ; if ( data_len < txreq . size ) { skb_shinfo ( skb ) -> nr_frags ++ ; frag_set_pending_idx ( & skb_shinfo ( skb ) -> frags [ 0 ] , pending_idx ) ; } else { frag_set_pending_idx ( & skb_shinfo ( skb ) -> frags [ 0 ] , INVALID_PENDING_IDX ) ; } netbk -> pending_cons ++ ; request_gop = xen_netbk_get_requests ( netbk , vif , skb , txfrags , gop ) ; if ( request_gop == NULL ) { kfree_skb ( skb ) ; netbk_tx_err ( vif , & txreq , idx ) ; continue ; } gop = request_gop ; __skb_queue_tail ( & netbk -> tx_queue , skb ) ; vif -> tx . req_cons = idx ; xen_netbk_check_rx_xenvif ( vif ) ; if ( ( gop - netbk -> tx_copy_ops ) >= ARRAY_SIZE ( netbk -> tx_copy_ops ) ) break ; } return gop - netbk -> tx_copy_ops ; }","netdev_err ( vif -> dev , ""txreq.offset:<S2SV_blank>%x,<S2SV_blank>size:<S2SV_blank>%u,<S2SV_blank>end:<S2SV_blank>%lu\\\netbk_fatal_tx_err ( vif ) ;continue ;",280
389,"buggy line: netbk_tx_err ( vif , & txreq , idx ) ;continue ;cwe id:CWE-20context: static unsigned xen_netbk_tx_build_gops ( struct xen_netbk * netbk ) { struct gnttab_copy * gop = netbk -> tx_copy_ops , * request_gop ; struct sk_buff * skb ; int ret ; while ( ( ( nr_pending_reqs ( netbk ) + MAX_SKB_FRAGS ) < MAX_PENDING_REQS ) && ! list_empty ( & netbk -> net_schedule_list ) ) { struct xenvif * vif ; struct xen_netif_tx_request txreq ; struct xen_netif_tx_request txfrags [ MAX_SKB_FRAGS ] ; struct page * page ; struct xen_netif_extra_info extras [ XEN_NETIF_EXTRA_TYPE_MAX - 1 ] ; u16 pending_idx ; RING_IDX idx ; int work_to_do ; unsigned int data_len ; pending_ring_idx_t index ; vif = poll_net_schedule_list ( netbk ) ; if ( ! vif ) continue ;  RING_FINAL_CHECK_FOR_REQUESTS ( & vif -> tx , work_to_do ) ;  if ( ! work_to_do ) { xenvif_put ( vif ) ; continue ; } idx = vif -> tx . req_cons ; rmb ( ) ; memcpy ( & txreq , RING_GET_REQUEST ( & vif -> tx , idx ) , sizeof ( txreq ) ) ; if ( txreq . size > vif -> remaining_credit && tx_credit_exceeded ( vif , txreq . size ) ) { xenvif_put ( vif ) ; continue ; } vif -> remaining_credit -= txreq . size ; work_to_do -- ; vif -> tx . req_cons = ++ idx ; memset ( extras , 0 , sizeof ( extras ) ) ; if ( txreq . flags & XEN_NETTXF_extra_info ) { work_to_do = xen_netbk_get_extras ( vif , extras , work_to_do ) ; idx = vif -> tx . req_cons ;  if ( unlikely ( work_to_do < 0 ) ) {  netbk_tx_err ( vif , & txreq , idx ) ; continue ; } } ret = netbk_count_requests ( vif , & txreq , txfrags , work_to_do ) ;  if ( unlikely ( ret < 0 ) ) {  netbk_tx_err ( vif , & txreq , idx - ret ) ; continue ; } idx += ret ; if ( unlikely ( txreq . size < ETH_HLEN ) ) { netdev_dbg ( vif -> dev , ""Bad<S2SV_blank>packet<S2SV_blank>size:<S2SV_blank>%d\\n"" , txreq . size ) ; netbk_tx_err ( vif , & txreq , idx ) ; continue ; } if ( unlikely ( ( txreq . offset + txreq . size ) > PAGE_SIZE ) ) {  netdev_dbg ( vif -> dev ,  ""txreq.offset:<S2SV_blank>%x,<S2SV_blank>size:<S2SV_blank>%u,<S2SV_blank>end:<S2SV_blank>%lu\\n"" , txreq . offset , txreq . size , ( txreq . offset & ~ PAGE_MASK ) + txreq . size ) ;  netbk_tx_err ( vif , & txreq , idx ) ;  continue ; } index = pending_index ( netbk -> pending_cons ) ; pending_idx = netbk -> pending_ring [ index ] ; data_len = ( txreq . size > PKT_PROT_LEN && ret < MAX_SKB_FRAGS ) ? PKT_PROT_LEN : txreq . size ; skb = alloc_skb ( data_len + NET_SKB_PAD + NET_IP_ALIGN , GFP_ATOMIC | __GFP_NOWARN ) ; if ( unlikely ( skb == NULL ) ) { netdev_dbg ( vif -> dev , ""Can\'t<S2SV_blank>allocate<S2SV_blank>a<S2SV_blank>skb<S2SV_blank>in<S2SV_blank>start_xmit.\\n"" ) ; netbk_tx_err ( vif , & txreq , idx ) ; break ; } skb_reserve ( skb , NET_SKB_PAD + NET_IP_ALIGN ) ; if ( extras [ XEN_NETIF_EXTRA_TYPE_GSO - 1 ] . type ) { struct xen_netif_extra_info * gso ; gso = & extras [ XEN_NETIF_EXTRA_TYPE_GSO - 1 ] ; if ( netbk_set_skb_gso ( vif , skb , gso ) ) { kfree_skb ( skb ) ;  netbk_tx_err ( vif , & txreq , idx ) ;  continue ; } } page = xen_netbk_alloc_page ( netbk , skb , pending_idx ) ; if ( ! page ) { kfree_skb ( skb ) ; netbk_tx_err ( vif , & txreq , idx ) ; continue ; } gop -> source . u . ref = txreq . gref ; gop -> source . domid = vif -> domid ; gop -> source . offset = txreq . offset ; gop -> dest . u . gmfn = virt_to_mfn ( page_address ( page ) ) ; gop -> dest . domid = DOMID_SELF ; gop -> dest . offset = txreq . offset ; gop -> len = txreq . size ; gop -> flags = GNTCOPY_source_gref ; gop ++ ; memcpy ( & netbk -> pending_tx_info [ pending_idx ] . req , & txreq , sizeof ( txreq ) ) ; netbk -> pending_tx_info [ pending_idx ] . vif = vif ; * ( ( u16 * ) skb -> data ) = pending_idx ; __skb_put ( skb , data_len ) ; skb_shinfo ( skb ) -> nr_frags = ret ; if ( data_len < txreq . size ) { skb_shinfo ( skb ) -> nr_frags ++ ; frag_set_pending_idx ( & skb_shinfo ( skb ) -> frags [ 0 ] , pending_idx ) ; } else { frag_set_pending_idx ( & skb_shinfo ( skb ) -> frags [ 0 ] , INVALID_PENDING_IDX ) ; } netbk -> pending_cons ++ ; request_gop = xen_netbk_get_requests ( netbk , vif , skb , txfrags , gop ) ; if ( request_gop == NULL ) { kfree_skb ( skb ) ; netbk_tx_err ( vif , & txreq , idx ) ; continue ; } gop = request_gop ; __skb_queue_tail ( & netbk -> tx_queue , skb ) ; vif -> tx . req_cons = idx ; xen_netbk_check_rx_xenvif ( vif ) ; if ( ( gop - netbk -> tx_copy_ops ) >= ARRAY_SIZE ( netbk -> tx_copy_ops ) ) break ; } return gop - netbk -> tx_copy_ops ; }",continue ;,280
390,"buggy line: cwe id:CWE-399context: void parser ( void ) { char * arg ; # ifndef MINIMAL char * sitearg ; # endif # ifdef WITH_RFC2640 char * narg = NULL ; # endif size_t n ; # ifdef IMPLICIT_TLS ( void ) tls_init_new_session ( ) ; data_protection_level = CPL_PRIVATE ; # endif for ( ; ; ) { xferfd = - 1 ; if ( state_needs_update != 0 ) { state_needs_update = 0 ; setprocessname ( ""pure-ftpd<S2SV_blank>(IDLE)"" ) ; # ifdef FTPWHO if ( shm_data_cur != NULL ) { ftpwho_lock ( ) ; shm_data_cur -> state = FTPWHO_STATE_IDLE ; * shm_data_cur -> filename = 0 ; ftpwho_unlock ( ) ; } # endif } doreply ( ) ; alarm ( idletime * 2 ) ; switch ( sfgets ( ) ) { case - 1 : # ifdef BORING_MODE die ( 421 , LOG_INFO , MSG_TIMEOUT ) ; # else die ( 421 , LOG_INFO , MSG_TIMEOUT_PARSER ) ; # endif case - 2 : return ; } # ifdef DEBUG if ( debug != 0 ) { addreply ( 0 , ""%s"" , cmd ) ; } # endif n = ( size_t ) 0U ; while ( ( isalpha ( ( unsigned char ) cmd [ n ] ) || cmd [ n ] == '@' ) && n < cmdsize ) { cmd [ n ] = ( char ) tolower ( ( unsigned char ) cmd [ n ] ) ; n ++ ; } if ( n >= cmdsize ) { die ( 421 , LOG_WARNING , MSG_LINE_TOO_LONG ) ; } if ( n == ( size_t ) 0U ) { nop : addreply_noformat ( 500 , ""?"" ) ; continue ; } # ifdef SKIP_COMMAND_TRAILING_SPACES while ( isspace ( ( unsigned char ) cmd [ n ] ) && n < cmdsize ) { cmd [ n ++ ] = 0 ; } arg = cmd + n ; while ( cmd [ n ] != 0 && n < cmdsize ) { n ++ ; } n -- ; while ( isspace ( ( unsigned char ) cmd [ n ] ) ) { cmd [ n -- ] = 0 ; } # else if ( cmd [ n ] == 0 ) { arg = cmd + n ; } else if ( isspace ( ( unsigned char ) cmd [ n ] ) ) { cmd [ n ] = 0 ; arg = cmd + n + 1 ; } else { goto nop ; } # endif if ( logging != 0 ) { # ifdef DEBUG logfile ( LOG_DEBUG , MSG_DEBUG_COMMAND ""<S2SV_blank>[%s]<S2SV_blank>[%s]"" , cmd , arg ) ; # else logfile ( LOG_DEBUG , MSG_DEBUG_COMMAND ""<S2SV_blank>[%s]<S2SV_blank>[%s]"" , cmd , strcmp ( cmd , ""pass"" ) ? arg : ""<*>"" ) ; # endif } # ifdef WITH_RFC2640 narg = charset_client2fs ( arg ) ; arg = narg ; # endif # ifndef MINIMAL if ( ! strcmp ( cmd , ""noop"" ) ) { antiidle ( ) ; donoop ( ) ; goto wayout ; } # endif if ( ! strcmp ( cmd , ""user"" ) ) { # ifdef WITH_TLS if ( enforce_tls_auth > 1 && tls_cnx == NULL ) { die ( 421 , LOG_WARNING , MSG_TLS_NEEDED ) ; } # endif douser ( arg ) ; } else if ( ! strcmp ( cmd , ""acct"" ) ) { addreply ( 202 , MSG_WHOAREYOU ) ; } else if ( ! strcmp ( cmd , ""pass"" ) ) { if ( guest == 0 ) { randomdelay ( ) ; } dopass ( arg ) ; } else if ( ! strcmp ( cmd , ""quit"" ) ) { addreply ( 221 , MSG_GOODBYE , ( unsigned long long ) ( ( uploaded + 1023ULL ) / 1024ULL ) , ( unsigned long long ) ( ( downloaded + 1023ULL ) / 1024ULL ) ) ; return ; } else if ( ! strcmp ( cmd , ""syst"" ) ) { antiidle ( ) ; addreply_noformat ( 215 , ""UNIX<S2SV_blank>Type:<S2SV_blank>L8"" ) ; goto wayout ; # ifdef WITH_TLS } else if ( enforce_tls_auth > 0 && ! strcmp ( cmd , ""auth"" ) && ! strcasecmp ( arg , ""tls"" ) ) { addreply_noformat ( 234 , ""AUTH<S2SV_blank>TLS<S2SV_blank>OK."" ) ; doreply ( ) ; if ( tls_cnx == NULL ) {  ( void ) tls_init_new_session ( ) ;  } goto wayout ; } else if ( ! strcmp ( cmd , ""pbsz"" ) ) { addreply_noformat ( tls_cnx == NULL ? 503 : 200 , ""PBSZ=0"" ) ; } else if ( ! strcmp ( cmd , ""prot"" ) ) { if ( tls_cnx == NULL ) { addreply_noformat ( 503 , MSG_PROT_BEFORE_PBSZ ) ; goto wayout ; } switch ( * arg ) { case 0 : addreply_noformat ( 503 , MSG_MISSING_ARG ) ; data_protection_level = CPL_NONE ; break ; case 'C' : if ( arg [ 1 ] == 0 ) { addreply ( 200 , MSG_PROT_OK , ""clear"" ) ; data_protection_level = CPL_CLEAR ; break ; } case 'S' : case 'E' : if ( arg [ 1 ] == 0 ) { addreply ( 200 , MSG_PROT_UNKNOWN_LEVEL , arg , ""private"" ) ; data_protection_level = CPL_PRIVATE ; break ; } case 'P' : if ( arg [ 1 ] == 0 ) { addreply ( 200 , MSG_PROT_OK , ""private"" ) ; data_protection_level = CPL_PRIVATE ; break ; } default : addreply_noformat ( 534 , ""Fallback<S2SV_blank>to<S2SV_blank>[C]"" ) ; data_protection_level = CPL_CLEAR ; break ; } # endif } else if ( ! strcmp ( cmd , ""auth"" ) || ! strcmp ( cmd , ""adat"" ) ) { addreply_noformat ( 500 , MSG_AUTH_UNIMPLEMENTED ) ; } else if ( ! strcmp ( cmd , ""type"" ) ) { antiidle ( ) ; dotype ( arg ) ; goto wayout ; } else if ( ! strcmp ( cmd , ""mode"" ) ) { antiidle ( ) ; domode ( arg ) ; goto wayout ; # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""feat"" ) ) { dofeat ( ) ; goto wayout ; } else if ( ! strcmp ( cmd , ""opts"" ) ) { doopts ( arg ) ; goto wayout ; # endif } else if ( ! strcmp ( cmd , ""stru"" ) ) { dostru ( arg ) ; goto wayout ; # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""help"" ) ) { goto help_site ; # endif # ifdef DEBUG } else if ( ! strcmp ( cmd , ""xdbg"" ) ) { debug ++ ; addreply ( 200 , MSG_XDBG_OK , debug ) ; goto wayout ; # endif } else if ( loggedin == 0 ) { addreply_noformat ( 530 , MSG_NOT_LOGGED_IN ) ; goto wayout ; } else { if ( ! strcmp ( cmd , ""cwd"" ) || ! strcmp ( cmd , ""xcwd"" ) ) { antiidle ( ) ; docwd ( arg ) ; goto wayout ; } else if ( ! strcmp ( cmd , ""port"" ) ) { doport ( arg ) ; # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""eprt"" ) ) { doeprt ( arg ) ; } else if ( ! strcmp ( cmd , ""esta"" ) && disallow_passive == 0 && STORAGE_FAMILY ( force_passive_ip ) == 0 ) { doesta ( ) ; } else if ( ! strcmp ( cmd , ""estp"" ) ) { doestp ( ) ; # endif } else if ( disallow_passive == 0 && ( ! strcmp ( cmd , ""pasv"" ) || ! strcmp ( cmd , ""p@sw"" ) ) ) { dopasv ( 0 ) ; } else if ( disallow_passive == 0 && ( ! strcmp ( cmd , ""epsv"" ) && ( broken_client_compat == 0 || STORAGE_FAMILY ( ctrlconn ) == AF_INET6 ) ) ) { if ( ! strcasecmp ( arg , ""all"" ) ) { epsv_all = 1 ; addreply_noformat ( 220 , MSG_ACTIVE_DISABLED ) ; } else if ( ! strcmp ( arg , ""2"" ) && ! v6ready ) { addreply_noformat ( 522 , MSG_ONLY_IPV4 ) ; } else { dopasv ( 1 ) ; } # ifndef MINIMAL } else if ( disallow_passive == 0 && ! strcmp ( cmd , ""spsv"" ) ) { dopasv ( 2 ) ; } else if ( ! strcmp ( cmd , ""allo"" ) ) { if ( * arg == 0 ) { addreply_noformat ( 501 , MSG_STAT_FAILURE ) ; } else { const off_t size = ( off_t ) strtoull ( arg , NULL , 10 ) ; if ( size < ( off_t ) 0 ) { addreply_noformat ( 501 , MSG_STAT_FAILURE ) ; } else { doallo ( size ) ; } } # endif } else if ( ! strcmp ( cmd , ""pwd"" ) || ! strcmp ( cmd , ""xpwd"" ) ) { # ifdef WITH_RFC2640 char * nwd ; # endif antiidle ( ) ; # ifdef WITH_RFC2640 nwd = charset_fs2client ( wd ) ; addreply ( 257 , ""\\""%s\\""<S2SV_blank>"" MSG_IS_YOUR_CURRENT_LOCATION , nwd ) ; free ( nwd ) ; # else addreply ( 257 , ""\\""%s\\""<S2SV_blank>"" MSG_IS_YOUR_CURRENT_LOCATION , wd ) ; # endif goto wayout ; } else if ( ! strcmp ( cmd , ""cdup"" ) || ! strcmp ( cmd , ""xcup"" ) ) { docwd ( "".."" ) ; } else if ( ! strcmp ( cmd , ""retr"" ) ) { if ( * arg != 0 ) { # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { doretr ( arg ) ; } } else { addreply_noformat ( 501 , MSG_NO_FILE_NAME ) ; } } else if ( ! strcmp ( cmd , ""rest"" ) ) { antiidle ( ) ; if ( * arg != 0 ) { dorest ( arg ) ; } else { addreply_noformat ( 501 , MSG_NO_RESTART_POINT ) ; restartat = ( off_t ) 0 ; } goto wayout ; } else if ( ! strcmp ( cmd , ""dele"" ) ) { if ( * arg != 0 ) { dodele ( arg ) ; } else { addreply_noformat ( 501 , MSG_NO_FILE_NAME ) ; } } else if ( ! strcmp ( cmd , ""stor"" ) ) { arg = revealextraspc ( arg ) ; if ( * arg != 0 ) { # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { dostor ( arg , 0 , autorename ) ; } } else { addreply_noformat ( 501 , MSG_NO_FILE_NAME ) ; } } else if ( ! strcmp ( cmd , ""appe"" ) ) { arg = revealextraspc ( arg ) ; if ( * arg != 0 ) { # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { dostor ( arg , 1 , 0 ) ; } } else { addreply_noformat ( 501 , MSG_NO_FILE_NAME ) ; } # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""stou"" ) ) { # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { dostou ( ) ; } # endif # ifndef DISABLE_MKD_RMD } else if ( ! strcmp ( cmd , ""mkd"" ) || ! strcmp ( cmd , ""xmkd"" ) ) { arg = revealextraspc ( arg ) ; if ( * arg != 0 ) { domkd ( arg ) ; } else { addreply_noformat ( 501 , MSG_NO_DIRECTORY_NAME ) ; } } else if ( ! strcmp ( cmd , ""rmd"" ) || ! strcmp ( cmd , ""xrmd"" ) ) { if ( * arg != 0 ) { dormd ( arg ) ; } else { addreply_noformat ( 550 , MSG_NO_DIRECTORY_NAME ) ; } # endif # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""stat"" ) ) { if ( * arg != 0 ) { modern_listings = 0 ; donlist ( arg , 1 , 1 , 1 , 1 ) ; } else { addreply_noformat ( 211 , ""http://www.pureftpd.org/"" ) ; } # endif } else if ( ! strcmp ( cmd , ""list"" ) ) { # ifndef MINIMAL modern_listings = 0 ; # endif # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { donlist ( arg , 0 , 1 , 0 , 1 ) ; } } else if ( ! strcmp ( cmd , ""nlst"" ) ) { # ifndef MINIMAL modern_listings = 0 ; # endif # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { donlist ( arg , 0 , 0 , 0 , broken_client_compat ) ; } # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""mlst"" ) ) { # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { domlst ( * arg != 0 ? arg : ""."" ) ; } } else if ( ! strcmp ( cmd , ""mlsd"" ) ) { modern_listings = 1 ; # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { donlist ( arg , 0 , 1 , 1 , 0 ) ; } # endif } else if ( ! strcmp ( cmd , ""abor"" ) ) { addreply_noformat ( 226 , MSG_ABOR_SUCCESS ) ; # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""site"" ) ) { if ( ( sitearg = arg ) != NULL ) { while ( * sitearg != 0 && ! isspace ( ( unsigned char ) * sitearg ) ) { sitearg ++ ; } if ( * sitearg != 0 ) { * sitearg ++ = 0 ; } } if ( ! strcasecmp ( arg , ""idle"" ) ) { if ( sitearg == NULL || * sitearg == 0 ) { addreply_noformat ( 501 , ""SITE<S2SV_blank>IDLE:<S2SV_blank>"" MSG_MISSING_ARG ) ; } else { unsigned long int i = 0 ; i = strtoul ( sitearg , & sitearg , 10 ) ; if ( sitearg && * sitearg ) addreply ( 501 , MSG_GARBAGE_FOUND ""<S2SV_blank>:<S2SV_blank>%s"" , sitearg ) ; else if ( i > MAX_SITE_IDLE ) addreply_noformat ( 501 , MSG_VALUE_TOO_LARGE ) ; else { idletime = i ; addreply ( 200 , MSG_IDLE_TIME , idletime ) ; idletime_noop = ( double ) idletime * 2.0 ; } } } else if ( ! strcasecmp ( arg , ""time"" ) ) { dositetime ( ) ; } else if ( ! strcasecmp ( arg , ""help"" ) ) { help_site : addreply_noformat ( 214 , MSG_SITE_HELP CRLF # ifdef WITH_DIRALIASES ""<S2SV_blank>ALIAS"" CRLF # endif ""<S2SV_blank>CHMOD"" CRLF ""<S2SV_blank>IDLE"" CRLF ""<S2SV_blank>UTIME"" ) ; addreply_noformat ( 214 , ""Pure-FTPd<S2SV_blank>-<S2SV_blank>http://pureftpd.org/"" ) ; } else if ( ! strcasecmp ( arg , ""chmod"" ) ) { char * sitearg2 ; mode_t mode ; parsechmod : if ( sitearg == NULL || * sitearg == 0 ) { addreply_noformat ( 501 , MSG_MISSING_ARG ) ; goto chmod_wayout ; } sitearg2 = sitearg ; while ( * sitearg2 != 0 && ! isspace ( ( unsigned char ) * sitearg2 ) ) { sitearg2 ++ ; } while ( * sitearg2 != 0 && isspace ( ( unsigned char ) * sitearg2 ) ) { sitearg2 ++ ; } if ( * sitearg2 == 0 ) { addreply_noformat ( 550 , MSG_NO_FILE_NAME ) ; goto chmod_wayout ; } mode = ( mode_t ) strtoul ( sitearg , NULL , 8 ) ; if ( mode > ( mode_t ) 07777 ) { addreply_noformat ( 501 , MSG_BAD_CHMOD ) ; goto chmod_wayout ; } dochmod ( sitearg2 , mode ) ; chmod_wayout : ( void ) 0 ; } else if ( ! strcasecmp ( arg , ""utime"" ) ) { char * sitearg2 ; if ( sitearg == NULL || * sitearg == 0 ) { addreply_noformat ( 501 , MSG_NO_FILE_NAME ) ; goto utime_wayout ; } if ( ( sitearg2 = strrchr ( sitearg , '<S2SV_blank>' ) ) == NULL || sitearg2 == sitearg ) { addreply_noformat ( 501 , MSG_MISSING_ARG ) ; goto utime_wayout ; } if ( strcasecmp ( sitearg2 , ""<S2SV_blank>UTC"" ) != 0 ) { addreply_noformat ( 500 , ""UTC<S2SV_blank>Only"" ) ; goto utime_wayout ; } * sitearg2 -- = 0 ; if ( ( sitearg2 = strrchr ( sitearg , '<S2SV_blank>' ) ) == NULL || sitearg2 == sitearg ) { utime_no_arg : addreply_noformat ( 501 , MSG_MISSING_ARG ) ; goto utime_wayout ; } * sitearg2 -- = 0 ; if ( ( sitearg2 = strrchr ( sitearg , '<S2SV_blank>' ) ) == NULL || sitearg2 == sitearg ) { goto utime_no_arg ; } * sitearg2 -- = 0 ; if ( ( sitearg2 = strrchr ( sitearg , '<S2SV_blank>' ) ) == NULL || sitearg2 == sitearg ) { goto utime_no_arg ; } * sitearg2 ++ = 0 ; if ( * sitearg2 == 0 ) { goto utime_no_arg ; } doutime ( sitearg , sitearg2 ) ; utime_wayout : ( void ) 0 ; # ifdef WITH_DIRALIASES } else if ( ! strcasecmp ( arg , ""alias"" ) ) { if ( sitearg == NULL || * sitearg == 0 ) { print_aliases ( ) ; } else { const char * alias ; if ( ( alias = lookup_alias ( sitearg ) ) != NULL ) { addreply ( 214 , MSG_ALIASES_ALIAS , sitearg , alias ) ; } else { addreply ( 502 , MSG_ALIASES_UNKNOWN , sitearg ) ; } } # endif } else if ( * arg != 0 ) { addreply ( 500 , ""SITE<S2SV_blank>%s<S2SV_blank>"" MSG_UNKNOWN_EXTENSION , arg ) ; } else { addreply_noformat ( 500 , ""SITE:<S2SV_blank>"" MSG_MISSING_ARG ) ; } # endif } else if ( ! strcmp ( cmd , ""mdtm"" ) ) { domdtm ( arg ) ; } else if ( ! strcmp ( cmd , ""size"" ) ) { dosize ( arg ) ; # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""chmod"" ) ) { sitearg = arg ; goto parsechmod ; # endif } else if ( ! strcmp ( cmd , ""rnfr"" ) ) { if ( * arg != 0 ) { dornfr ( arg ) ; } else { addreply_noformat ( 550 , MSG_NO_FILE_NAME ) ; } } else if ( ! strcmp ( cmd , ""rnto"" ) ) { arg = revealextraspc ( arg ) ; if ( * arg != 0 ) { dornto ( arg ) ; } else { addreply_noformat ( 550 , MSG_NO_FILE_NAME ) ; } } else { addreply_noformat ( 500 , MSG_UNKNOWN_COMMAND ) ; } } noopidle = ( time_t ) - 1 ; wayout : # ifdef WITH_RFC2640 free ( narg ) ; narg = NULL ; # endif # ifdef THROTTLING if ( throttling_delay != 0UL ) { usleep2 ( throttling_delay ) ; } # else ( void ) 0 ; # endif } }",flush_cmd ( ) ;,281
391,"buggy line: ( void ) tls_init_new_session ( ) ;}cwe id:CWE-399context: void parser ( void ) { char * arg ; # ifndef MINIMAL char * sitearg ; # endif # ifdef WITH_RFC2640 char * narg = NULL ; # endif size_t n ; # ifdef IMPLICIT_TLS ( void ) tls_init_new_session ( ) ; data_protection_level = CPL_PRIVATE ; # endif for ( ; ; ) { xferfd = - 1 ; if ( state_needs_update != 0 ) { state_needs_update = 0 ; setprocessname ( ""pure-ftpd<S2SV_blank>(IDLE)"" ) ; # ifdef FTPWHO if ( shm_data_cur != NULL ) { ftpwho_lock ( ) ; shm_data_cur -> state = FTPWHO_STATE_IDLE ; * shm_data_cur -> filename = 0 ; ftpwho_unlock ( ) ; } # endif } doreply ( ) ; alarm ( idletime * 2 ) ; switch ( sfgets ( ) ) { case - 1 : # ifdef BORING_MODE die ( 421 , LOG_INFO , MSG_TIMEOUT ) ; # else die ( 421 , LOG_INFO , MSG_TIMEOUT_PARSER ) ; # endif case - 2 : return ; } # ifdef DEBUG if ( debug != 0 ) { addreply ( 0 , ""%s"" , cmd ) ; } # endif n = ( size_t ) 0U ; while ( ( isalpha ( ( unsigned char ) cmd [ n ] ) || cmd [ n ] == '@' ) && n < cmdsize ) { cmd [ n ] = ( char ) tolower ( ( unsigned char ) cmd [ n ] ) ; n ++ ; } if ( n >= cmdsize ) { die ( 421 , LOG_WARNING , MSG_LINE_TOO_LONG ) ; } if ( n == ( size_t ) 0U ) { nop : addreply_noformat ( 500 , ""?"" ) ; continue ; } # ifdef SKIP_COMMAND_TRAILING_SPACES while ( isspace ( ( unsigned char ) cmd [ n ] ) && n < cmdsize ) { cmd [ n ++ ] = 0 ; } arg = cmd + n ; while ( cmd [ n ] != 0 && n < cmdsize ) { n ++ ; } n -- ; while ( isspace ( ( unsigned char ) cmd [ n ] ) ) { cmd [ n -- ] = 0 ; } # else if ( cmd [ n ] == 0 ) { arg = cmd + n ; } else if ( isspace ( ( unsigned char ) cmd [ n ] ) ) { cmd [ n ] = 0 ; arg = cmd + n + 1 ; } else { goto nop ; } # endif if ( logging != 0 ) { # ifdef DEBUG logfile ( LOG_DEBUG , MSG_DEBUG_COMMAND ""<S2SV_blank>[%s]<S2SV_blank>[%s]"" , cmd , arg ) ; # else logfile ( LOG_DEBUG , MSG_DEBUG_COMMAND ""<S2SV_blank>[%s]<S2SV_blank>[%s]"" , cmd , strcmp ( cmd , ""pass"" ) ? arg : ""<*>"" ) ; # endif } # ifdef WITH_RFC2640 narg = charset_client2fs ( arg ) ; arg = narg ; # endif # ifndef MINIMAL if ( ! strcmp ( cmd , ""noop"" ) ) { antiidle ( ) ; donoop ( ) ; goto wayout ; } # endif if ( ! strcmp ( cmd , ""user"" ) ) { # ifdef WITH_TLS if ( enforce_tls_auth > 1 && tls_cnx == NULL ) { die ( 421 , LOG_WARNING , MSG_TLS_NEEDED ) ; } # endif douser ( arg ) ; } else if ( ! strcmp ( cmd , ""acct"" ) ) { addreply ( 202 , MSG_WHOAREYOU ) ; } else if ( ! strcmp ( cmd , ""pass"" ) ) { if ( guest == 0 ) { randomdelay ( ) ; } dopass ( arg ) ; } else if ( ! strcmp ( cmd , ""quit"" ) ) { addreply ( 221 , MSG_GOODBYE , ( unsigned long long ) ( ( uploaded + 1023ULL ) / 1024ULL ) , ( unsigned long long ) ( ( downloaded + 1023ULL ) / 1024ULL ) ) ; return ; } else if ( ! strcmp ( cmd , ""syst"" ) ) { antiidle ( ) ; addreply_noformat ( 215 , ""UNIX<S2SV_blank>Type:<S2SV_blank>L8"" ) ; goto wayout ; # ifdef WITH_TLS } else if ( enforce_tls_auth > 0 && ! strcmp ( cmd , ""auth"" ) && ! strcasecmp ( arg , ""tls"" ) ) { addreply_noformat ( 234 , ""AUTH<S2SV_blank>TLS<S2SV_blank>OK."" ) ; doreply ( ) ; if ( tls_cnx == NULL ) {  ( void ) tls_init_new_session ( ) ;  } goto wayout ; } else if ( ! strcmp ( cmd , ""pbsz"" ) ) { addreply_noformat ( tls_cnx == NULL ? 503 : 200 , ""PBSZ=0"" ) ; } else if ( ! strcmp ( cmd , ""prot"" ) ) { if ( tls_cnx == NULL ) { addreply_noformat ( 503 , MSG_PROT_BEFORE_PBSZ ) ; goto wayout ; } switch ( * arg ) { case 0 : addreply_noformat ( 503 , MSG_MISSING_ARG ) ; data_protection_level = CPL_NONE ; break ; case 'C' : if ( arg [ 1 ] == 0 ) { addreply ( 200 , MSG_PROT_OK , ""clear"" ) ; data_protection_level = CPL_CLEAR ; break ; } case 'S' : case 'E' : if ( arg [ 1 ] == 0 ) { addreply ( 200 , MSG_PROT_UNKNOWN_LEVEL , arg , ""private"" ) ; data_protection_level = CPL_PRIVATE ; break ; } case 'P' : if ( arg [ 1 ] == 0 ) { addreply ( 200 , MSG_PROT_OK , ""private"" ) ; data_protection_level = CPL_PRIVATE ; break ; } default : addreply_noformat ( 534 , ""Fallback<S2SV_blank>to<S2SV_blank>[C]"" ) ; data_protection_level = CPL_CLEAR ; break ; } # endif } else if ( ! strcmp ( cmd , ""auth"" ) || ! strcmp ( cmd , ""adat"" ) ) { addreply_noformat ( 500 , MSG_AUTH_UNIMPLEMENTED ) ; } else if ( ! strcmp ( cmd , ""type"" ) ) { antiidle ( ) ; dotype ( arg ) ; goto wayout ; } else if ( ! strcmp ( cmd , ""mode"" ) ) { antiidle ( ) ; domode ( arg ) ; goto wayout ; # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""feat"" ) ) { dofeat ( ) ; goto wayout ; } else if ( ! strcmp ( cmd , ""opts"" ) ) { doopts ( arg ) ; goto wayout ; # endif } else if ( ! strcmp ( cmd , ""stru"" ) ) { dostru ( arg ) ; goto wayout ; # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""help"" ) ) { goto help_site ; # endif # ifdef DEBUG } else if ( ! strcmp ( cmd , ""xdbg"" ) ) { debug ++ ; addreply ( 200 , MSG_XDBG_OK , debug ) ; goto wayout ; # endif } else if ( loggedin == 0 ) { addreply_noformat ( 530 , MSG_NOT_LOGGED_IN ) ; goto wayout ; } else { if ( ! strcmp ( cmd , ""cwd"" ) || ! strcmp ( cmd , ""xcwd"" ) ) { antiidle ( ) ; docwd ( arg ) ; goto wayout ; } else if ( ! strcmp ( cmd , ""port"" ) ) { doport ( arg ) ; # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""eprt"" ) ) { doeprt ( arg ) ; } else if ( ! strcmp ( cmd , ""esta"" ) && disallow_passive == 0 && STORAGE_FAMILY ( force_passive_ip ) == 0 ) { doesta ( ) ; } else if ( ! strcmp ( cmd , ""estp"" ) ) { doestp ( ) ; # endif } else if ( disallow_passive == 0 && ( ! strcmp ( cmd , ""pasv"" ) || ! strcmp ( cmd , ""p@sw"" ) ) ) { dopasv ( 0 ) ; } else if ( disallow_passive == 0 && ( ! strcmp ( cmd , ""epsv"" ) && ( broken_client_compat == 0 || STORAGE_FAMILY ( ctrlconn ) == AF_INET6 ) ) ) { if ( ! strcasecmp ( arg , ""all"" ) ) { epsv_all = 1 ; addreply_noformat ( 220 , MSG_ACTIVE_DISABLED ) ; } else if ( ! strcmp ( arg , ""2"" ) && ! v6ready ) { addreply_noformat ( 522 , MSG_ONLY_IPV4 ) ; } else { dopasv ( 1 ) ; } # ifndef MINIMAL } else if ( disallow_passive == 0 && ! strcmp ( cmd , ""spsv"" ) ) { dopasv ( 2 ) ; } else if ( ! strcmp ( cmd , ""allo"" ) ) { if ( * arg == 0 ) { addreply_noformat ( 501 , MSG_STAT_FAILURE ) ; } else { const off_t size = ( off_t ) strtoull ( arg , NULL , 10 ) ; if ( size < ( off_t ) 0 ) { addreply_noformat ( 501 , MSG_STAT_FAILURE ) ; } else { doallo ( size ) ; } } # endif } else if ( ! strcmp ( cmd , ""pwd"" ) || ! strcmp ( cmd , ""xpwd"" ) ) { # ifdef WITH_RFC2640 char * nwd ; # endif antiidle ( ) ; # ifdef WITH_RFC2640 nwd = charset_fs2client ( wd ) ; addreply ( 257 , ""\\""%s\\""<S2SV_blank>"" MSG_IS_YOUR_CURRENT_LOCATION , nwd ) ; free ( nwd ) ; # else addreply ( 257 , ""\\""%s\\""<S2SV_blank>"" MSG_IS_YOUR_CURRENT_LOCATION , wd ) ; # endif goto wayout ; } else if ( ! strcmp ( cmd , ""cdup"" ) || ! strcmp ( cmd , ""xcup"" ) ) { docwd ( "".."" ) ; } else if ( ! strcmp ( cmd , ""retr"" ) ) { if ( * arg != 0 ) { # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { doretr ( arg ) ; } } else { addreply_noformat ( 501 , MSG_NO_FILE_NAME ) ; } } else if ( ! strcmp ( cmd , ""rest"" ) ) { antiidle ( ) ; if ( * arg != 0 ) { dorest ( arg ) ; } else { addreply_noformat ( 501 , MSG_NO_RESTART_POINT ) ; restartat = ( off_t ) 0 ; } goto wayout ; } else if ( ! strcmp ( cmd , ""dele"" ) ) { if ( * arg != 0 ) { dodele ( arg ) ; } else { addreply_noformat ( 501 , MSG_NO_FILE_NAME ) ; } } else if ( ! strcmp ( cmd , ""stor"" ) ) { arg = revealextraspc ( arg ) ; if ( * arg != 0 ) { # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { dostor ( arg , 0 , autorename ) ; } } else { addreply_noformat ( 501 , MSG_NO_FILE_NAME ) ; } } else if ( ! strcmp ( cmd , ""appe"" ) ) { arg = revealextraspc ( arg ) ; if ( * arg != 0 ) { # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { dostor ( arg , 1 , 0 ) ; } } else { addreply_noformat ( 501 , MSG_NO_FILE_NAME ) ; } # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""stou"" ) ) { # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { dostou ( ) ; } # endif # ifndef DISABLE_MKD_RMD } else if ( ! strcmp ( cmd , ""mkd"" ) || ! strcmp ( cmd , ""xmkd"" ) ) { arg = revealextraspc ( arg ) ; if ( * arg != 0 ) { domkd ( arg ) ; } else { addreply_noformat ( 501 , MSG_NO_DIRECTORY_NAME ) ; } } else if ( ! strcmp ( cmd , ""rmd"" ) || ! strcmp ( cmd , ""xrmd"" ) ) { if ( * arg != 0 ) { dormd ( arg ) ; } else { addreply_noformat ( 550 , MSG_NO_DIRECTORY_NAME ) ; } # endif # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""stat"" ) ) { if ( * arg != 0 ) { modern_listings = 0 ; donlist ( arg , 1 , 1 , 1 , 1 ) ; } else { addreply_noformat ( 211 , ""http://www.pureftpd.org/"" ) ; } # endif } else if ( ! strcmp ( cmd , ""list"" ) ) { # ifndef MINIMAL modern_listings = 0 ; # endif # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { donlist ( arg , 0 , 1 , 0 , 1 ) ; } } else if ( ! strcmp ( cmd , ""nlst"" ) ) { # ifndef MINIMAL modern_listings = 0 ; # endif # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { donlist ( arg , 0 , 0 , 0 , broken_client_compat ) ; } # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""mlst"" ) ) { # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { domlst ( * arg != 0 ? arg : ""."" ) ; } } else if ( ! strcmp ( cmd , ""mlsd"" ) ) { modern_listings = 1 ; # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { donlist ( arg , 0 , 1 , 1 , 0 ) ; } # endif } else if ( ! strcmp ( cmd , ""abor"" ) ) { addreply_noformat ( 226 , MSG_ABOR_SUCCESS ) ; # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""site"" ) ) { if ( ( sitearg = arg ) != NULL ) { while ( * sitearg != 0 && ! isspace ( ( unsigned char ) * sitearg ) ) { sitearg ++ ; } if ( * sitearg != 0 ) { * sitearg ++ = 0 ; } } if ( ! strcasecmp ( arg , ""idle"" ) ) { if ( sitearg == NULL || * sitearg == 0 ) { addreply_noformat ( 501 , ""SITE<S2SV_blank>IDLE:<S2SV_blank>"" MSG_MISSING_ARG ) ; } else { unsigned long int i = 0 ; i = strtoul ( sitearg , & sitearg , 10 ) ; if ( sitearg && * sitearg ) addreply ( 501 , MSG_GARBAGE_FOUND ""<S2SV_blank>:<S2SV_blank>%s"" , sitearg ) ; else if ( i > MAX_SITE_IDLE ) addreply_noformat ( 501 , MSG_VALUE_TOO_LARGE ) ; else { idletime = i ; addreply ( 200 , MSG_IDLE_TIME , idletime ) ; idletime_noop = ( double ) idletime * 2.0 ; } } } else if ( ! strcasecmp ( arg , ""time"" ) ) { dositetime ( ) ; } else if ( ! strcasecmp ( arg , ""help"" ) ) { help_site : addreply_noformat ( 214 , MSG_SITE_HELP CRLF # ifdef WITH_DIRALIASES ""<S2SV_blank>ALIAS"" CRLF # endif ""<S2SV_blank>CHMOD"" CRLF ""<S2SV_blank>IDLE"" CRLF ""<S2SV_blank>UTIME"" ) ; addreply_noformat ( 214 , ""Pure-FTPd<S2SV_blank>-<S2SV_blank>http://pureftpd.org/"" ) ; } else if ( ! strcasecmp ( arg , ""chmod"" ) ) { char * sitearg2 ; mode_t mode ; parsechmod : if ( sitearg == NULL || * sitearg == 0 ) { addreply_noformat ( 501 , MSG_MISSING_ARG ) ; goto chmod_wayout ; } sitearg2 = sitearg ; while ( * sitearg2 != 0 && ! isspace ( ( unsigned char ) * sitearg2 ) ) { sitearg2 ++ ; } while ( * sitearg2 != 0 && isspace ( ( unsigned char ) * sitearg2 ) ) { sitearg2 ++ ; } if ( * sitearg2 == 0 ) { addreply_noformat ( 550 , MSG_NO_FILE_NAME ) ; goto chmod_wayout ; } mode = ( mode_t ) strtoul ( sitearg , NULL , 8 ) ; if ( mode > ( mode_t ) 07777 ) { addreply_noformat ( 501 , MSG_BAD_CHMOD ) ; goto chmod_wayout ; } dochmod ( sitearg2 , mode ) ; chmod_wayout : ( void ) 0 ; } else if ( ! strcasecmp ( arg , ""utime"" ) ) { char * sitearg2 ; if ( sitearg == NULL || * sitearg == 0 ) { addreply_noformat ( 501 , MSG_NO_FILE_NAME ) ; goto utime_wayout ; } if ( ( sitearg2 = strrchr ( sitearg , '<S2SV_blank>' ) ) == NULL || sitearg2 == sitearg ) { addreply_noformat ( 501 , MSG_MISSING_ARG ) ; goto utime_wayout ; } if ( strcasecmp ( sitearg2 , ""<S2SV_blank>UTC"" ) != 0 ) { addreply_noformat ( 500 , ""UTC<S2SV_blank>Only"" ) ; goto utime_wayout ; } * sitearg2 -- = 0 ; if ( ( sitearg2 = strrchr ( sitearg , '<S2SV_blank>' ) ) == NULL || sitearg2 == sitearg ) { utime_no_arg : addreply_noformat ( 501 , MSG_MISSING_ARG ) ; goto utime_wayout ; } * sitearg2 -- = 0 ; if ( ( sitearg2 = strrchr ( sitearg , '<S2SV_blank>' ) ) == NULL || sitearg2 == sitearg ) { goto utime_no_arg ; } * sitearg2 -- = 0 ; if ( ( sitearg2 = strrchr ( sitearg , '<S2SV_blank>' ) ) == NULL || sitearg2 == sitearg ) { goto utime_no_arg ; } * sitearg2 ++ = 0 ; if ( * sitearg2 == 0 ) { goto utime_no_arg ; } doutime ( sitearg , sitearg2 ) ; utime_wayout : ( void ) 0 ; # ifdef WITH_DIRALIASES } else if ( ! strcasecmp ( arg , ""alias"" ) ) { if ( sitearg == NULL || * sitearg == 0 ) { print_aliases ( ) ; } else { const char * alias ; if ( ( alias = lookup_alias ( sitearg ) ) != NULL ) { addreply ( 214 , MSG_ALIASES_ALIAS , sitearg , alias ) ; } else { addreply ( 502 , MSG_ALIASES_UNKNOWN , sitearg ) ; } } # endif } else if ( * arg != 0 ) { addreply ( 500 , ""SITE<S2SV_blank>%s<S2SV_blank>"" MSG_UNKNOWN_EXTENSION , arg ) ; } else { addreply_noformat ( 500 , ""SITE:<S2SV_blank>"" MSG_MISSING_ARG ) ; } # endif } else if ( ! strcmp ( cmd , ""mdtm"" ) ) { domdtm ( arg ) ; } else if ( ! strcmp ( cmd , ""size"" ) ) { dosize ( arg ) ; # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""chmod"" ) ) { sitearg = arg ; goto parsechmod ; # endif } else if ( ! strcmp ( cmd , ""rnfr"" ) ) { if ( * arg != 0 ) { dornfr ( arg ) ; } else { addreply_noformat ( 550 , MSG_NO_FILE_NAME ) ; } } else if ( ! strcmp ( cmd , ""rnto"" ) ) { arg = revealextraspc ( arg ) ; if ( * arg != 0 ) { dornto ( arg ) ; } else { addreply_noformat ( 550 , MSG_NO_FILE_NAME ) ; } } else { addreply_noformat ( 500 , MSG_UNKNOWN_COMMAND ) ; } } noopidle = ( time_t ) - 1 ; wayout : # ifdef WITH_RFC2640 free ( narg ) ; narg = NULL ; # endif # ifdef THROTTLING if ( throttling_delay != 0UL ) { usleep2 ( throttling_delay ) ; } # else ( void ) 0 ; # endif } }",( void ) tls_init_new_session ( ) ;},281
392,"buggy line: struct xfrm_policy_walk * walk = ( struct xfrm_policy_walk * ) & cb -> args [ 1 ] ;struct net * net = sock_net ( cb -> skb -> sk ) ;cwe id:CWE-416context: static int xfrm_dump_policy_done ( struct netlink_callback * cb ) {  struct xfrm_policy_walk * walk = ( struct xfrm_policy_walk * ) & cb -> args [ 1 ] ;  struct net * net = sock_net ( cb -> skb -> sk ) ; xfrm_policy_walk_done ( walk , net ) ; return 0 ; }",struct xfrm_policy_walk * walk = ( struct xfrm_policy_walk * ) cb -> args [ 1 ] ;struct net * net = sock_net ( cb -> skb -> sk ) ;,282
393,"buggy line: return ;update_idle_timeout ( conn ) ;parse_input ( conn ) ;if ( h2o_timeout_is_linked ( & conn -> _write . timeout_entry ) ) {cwe id:CWE-000context: static void on_read ( h2o_socket_t * sock , int status ) { h2o_http2_conn_t * conn = sock -> data ; if ( status != 0 ) { h2o_socket_read_stop ( conn -> sock ) ; close_connection ( conn ) ; return ; } update_idle_timeout ( conn ) ;  parse_input ( conn ) ;  if ( h2o_timeout_is_linked ( & conn -> _write . timeout_entry ) ) { h2o_timeout_unlink ( & conn -> _write . timeout_entry ) ; do_emit_writereq ( conn ) ; } }",if ( return ;update_idle_timeout ( conn ) != 0 ) return ;parse_input ( conn ) ;if ( h2o_timeout_is_linked ( & conn -> _write . timeout_entry ) ) {,283
394,"buggy line: struct pending_tx_info * pending_tx_info = netbk -> pending_tx_info ;struct xenvif * vif = pending_tx_info [ pending_idx ] . vif ;struct xen_netif_tx_request * txp ;if ( unlikely ( err ) ) {pending_ring_idx_t index ;index = pending_index ( netbk -> pending_prod ++ ) ;txp = & pending_tx_info [ pending_idx ] . req ;make_tx_response ( vif , txp , XEN_NETIF_RSP_ERROR ) ;netbk -> pending_ring [ index ] = pending_idx ;xenvif_put ( vif ) ;pending_ring_idx_t index ;pending_idx = frag_get_pending_idx ( & shinfo -> frags [ i ] ) ;if ( unlikely ( err ) )  xen_netbk_idx_release ( netbk , pending_idx ) ;continue ;txp = & netbk -> pending_tx_info [ pending_idx ] . req ;make_tx_response ( vif , txp , XEN_NETIF_RSP_ERROR ) ;index = pending_index ( netbk -> pending_prod ++ ) ;netbk -> pending_ring [ index ] = pending_idx ;xen_netbk_idx_release ( netbk , pending_idx ) ;for ( j = start ;xen_netbk_idx_release ( netbk , pending_idx ) ;}cwe id:CWE-399context: static int xen_netbk_tx_check_gop ( struct xen_netbk * netbk , struct sk_buff * skb , struct gnttab_copy * * gopp ) { struct gnttab_copy * gop = * gopp ; u16 pending_idx = * ( ( u16 * ) skb -> data ) ;  struct pending_tx_info * pending_tx_info = netbk -> pending_tx_info ;  struct xenvif * vif = pending_tx_info [ pending_idx ] . vif ; struct xen_netif_tx_request * txp ; struct skb_shared_info * shinfo = skb_shinfo ( skb ) ; int nr_frags = shinfo -> nr_frags ; int i , err , start ; err = gop -> status ;  if ( unlikely ( err ) ) {  pending_ring_idx_t index ; index = pending_index ( netbk -> pending_prod ++ ) ; txp = & pending_tx_info [ pending_idx ] . req ; make_tx_response ( vif , txp , XEN_NETIF_RSP_ERROR ) ;  netbk -> pending_ring [ index ] = pending_idx ;  xenvif_put ( vif ) ; } start = ( frag_get_pending_idx ( & shinfo -> frags [ 0 ] ) == pending_idx ) ; for ( i = start ; i < nr_frags ; i ++ ) { int j , newerr ;  pending_ring_idx_t index ;  pending_idx = frag_get_pending_idx ( & shinfo -> frags [ i ] ) ; newerr = ( ++ gop ) -> status ; if ( likely ( ! newerr ) ) { if ( unlikely ( err ) )  xen_netbk_idx_release ( netbk , pending_idx ) ;  continue ; }  txp = & netbk -> pending_tx_info [ pending_idx ] . req ;  make_tx_response ( vif , txp , XEN_NETIF_RSP_ERROR ) ;  index = pending_index ( netbk -> pending_prod ++ ) ;  netbk -> pending_ring [ index ] = pending_idx ; xenvif_put ( vif ) ; if ( err ) continue ; pending_idx = * ( ( u16 * ) skb -> data ) ;  xen_netbk_idx_release ( netbk , pending_idx ) ;  for ( j = start ; j < i ; j ++ ) { pending_idx = frag_get_pending_idx ( & shinfo -> frags [ j ] ) ;  xen_netbk_idx_release ( netbk , pending_idx ) ;  } err = newerr ; } * gopp = gop + 1 ; return err ; }","if ( unlikely ( err ) ) xen_netbk_idx_release ( netbk , pending_idx , XEN_NETIF_RSP_ERROR ) ;netbk -> pending_ring [ index ] = pending_idx ;xenvif_put ( vif ) ;pending_idx = frag_get_pending_idx ( & shinfo -> frags [ i ] ) ;if ( unlikely ( err ) ) xen_netbk_idx_release ( netbk , pending_idx , XEN_NETIF_RSP_OKAY ) ;continue ;xen_netbk_idx_release ( netbk , pending_idx , XEN_NETIF_RSP_OKAY , XEN_NETIF_RSP_ERROR ) ;index = pending_index ( netbk -> pending_prod ++ ) ;netbk -> pending_ring [ index ] = pending_idx ;xen_netbk_idx_release ( netbk , pending_idx , XEN_NETIF_RSP_OKAY ) ;for ( j = start ;xen_netbk_idx_release ( netbk , pending_idx ) ;}",284
395,"buggy line: assert ( image_info != ( const ImageInfo * ) NULL ) ;cwe id:CWE-772context: static Image * ReadYUVImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * chroma_image , * image , * resize_image ; InterlaceType interlace ; MagickBooleanType status ; register const Quantum * chroma_pixels ; register ssize_t x ; register Quantum * q ; register unsigned char * p ; ssize_t count , horizontal_factor , vertical_factor , y ; size_t length , quantum ; unsigned char * scanline ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( OptionError , ""MustSpecifyImageSize"" ) ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; quantum = ( ssize_t ) ( image -> depth <= 8 ? 1 : 2 ) ; interlace = image_info -> interlace ; horizontal_factor = 2 ; vertical_factor = 2 ; if ( image_info -> sampling_factor != ( char * ) NULL ) { GeometryInfo geometry_info ; MagickStatusType flags ; flags = ParseGeometry ( image_info -> sampling_factor , & geometry_info ) ; horizontal_factor = ( ssize_t ) geometry_info . rho ; vertical_factor = ( ssize_t ) geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) vertical_factor = horizontal_factor ; if ( ( horizontal_factor != 1 ) && ( horizontal_factor != 2 ) && ( vertical_factor != 1 ) && ( vertical_factor != 2 ) ) ThrowReaderException ( CorruptImageError , ""UnexpectedSamplingFactor"" ) ; } if ( ( interlace == UndefinedInterlace ) || ( ( interlace == NoInterlace ) && ( vertical_factor == 2 ) ) ) { interlace = NoInterlace ; if ( vertical_factor == 2 ) interlace = PlaneInterlace ; } if ( interlace != PartitionInterlace ) { status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( DiscardBlobBytes ( image , ( MagickSizeType ) image -> offset ) == MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; } if ( interlace == NoInterlace ) scanline = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( 2UL * image -> columns + 2UL ) , ( size_t ) quantum * sizeof ( * scanline ) ) ; else scanline = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , ( size_t ) quantum * sizeof ( * scanline ) ) ; if ( scanline == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; status = MagickTrue ; do { chroma_image = CloneImage ( image , ( image -> columns + horizontal_factor - 1 ) / horizontal_factor , ( image -> rows + vertical_factor - 1 ) / vertical_factor , MagickTrue , exception ) ; if ( chroma_image == ( Image * ) NULL )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;  if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break ; if ( interlace == PartitionInterlace ) { AppendImageFormat ( ""Y"" , image -> filename ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) {  image = DestroyImageList ( image ) ;  return ( ( Image * ) NULL ) ; } } for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { register Quantum * chroma_pixels ; if ( interlace == NoInterlace ) { if ( ( y > 0 ) || ( GetPreviousImageInList ( image ) == ( Image * ) NULL ) ) { length = 2 * quantum * image -> columns ; count = ReadBlob ( image , length , scanline ) ; if ( count != ( ssize_t ) length ) { status = MagickFalse ; ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } p = scanline ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; chroma_pixels = QueueAuthenticPixels ( chroma_image , 0 , y , chroma_image -> columns , 1 , exception ) ; if ( chroma_pixels == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x += 2 ) { SetPixelRed ( chroma_image , 0 , chroma_pixels ) ; if ( quantum == 1 ) SetPixelGreen ( chroma_image , ScaleCharToQuantum ( * p ++ ) , chroma_pixels ) ; else { SetPixelGreen ( chroma_image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | * ( p + 1 ) ) , chroma_pixels ) ; p += 2 ; } if ( quantum == 1 ) SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; else { SetPixelRed ( image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | * ( p + 1 ) ) , q ) ; p += 2 ; } SetPixelGreen ( image , 0 , q ) ; SetPixelBlue ( image , 0 , q ) ; q += GetPixelChannels ( image ) ; SetPixelGreen ( image , 0 , q ) ; SetPixelBlue ( image , 0 , q ) ; if ( quantum == 1 ) SetPixelBlue ( chroma_image , ScaleCharToQuantum ( * p ++ ) , chroma_pixels ) ; else { SetPixelBlue ( chroma_image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | * ( p + 1 ) ) , chroma_pixels ) ; p += 2 ; } if ( quantum == 1 ) SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; else { SetPixelRed ( image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | * ( p + 1 ) ) , q ) ; p += 2 ; } chroma_pixels += GetPixelChannels ( chroma_image ) ; q += GetPixelChannels ( image ) ; } } else { if ( ( y > 0 ) || ( GetPreviousImageInList ( image ) == ( Image * ) NULL ) ) { length = quantum * image -> columns ; count = ReadBlob ( image , length , scanline ) ; if ( count != ( ssize_t ) length ) { status = MagickFalse ; ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } p = scanline ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( quantum == 1 ) SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; else { SetPixelRed ( image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | * ( p + 1 ) ) , q ) ; p += 2 ; } SetPixelGreen ( image , 0 , q ) ; SetPixelBlue ( image , 0 , q ) ; q += GetPixelChannels ( image ) ; } } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( interlace == NoInterlace ) if ( SyncAuthenticPixels ( chroma_image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } if ( interlace == PartitionInterlace ) { ( void ) CloseBlob ( image ) ; AppendImageFormat ( ""U"" , image -> filename ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) {  image = DestroyImageList ( image ) ;  return ( ( Image * ) NULL ) ; } } if ( interlace != NoInterlace ) { for ( y = 0 ; y < ( ssize_t ) chroma_image -> rows ; y ++ ) { length = quantum * chroma_image -> columns ; count = ReadBlob ( image , length , scanline ) ; if ( count != ( ssize_t ) length ) { status = MagickFalse ; ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } p = scanline ; q = QueueAuthenticPixels ( chroma_image , 0 , y , chroma_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) chroma_image -> columns ; x ++ ) { SetPixelRed ( chroma_image , 0 , q ) ; if ( quantum == 1 ) SetPixelGreen ( chroma_image , ScaleCharToQuantum ( * p ++ ) , q ) ; else { SetPixelGreen ( chroma_image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | * ( p + 1 ) ) , q ) ; p += 2 ; } SetPixelBlue ( chroma_image , 0 , q ) ; q += GetPixelChannels ( chroma_image ) ; } if ( SyncAuthenticPixels ( chroma_image , exception ) == MagickFalse ) break ; } if ( interlace == PartitionInterlace ) { ( void ) CloseBlob ( image ) ; AppendImageFormat ( ""V"" , image -> filename ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) {  image = DestroyImageList ( image ) ;  return ( ( Image * ) NULL ) ; } } for ( y = 0 ; y < ( ssize_t ) chroma_image -> rows ; y ++ ) { length = quantum * chroma_image -> columns ; count = ReadBlob ( image , length , scanline ) ; if ( count != ( ssize_t ) length ) { status = MagickFalse ; ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } p = scanline ; q = GetAuthenticPixels ( chroma_image , 0 , y , chroma_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) chroma_image -> columns ; x ++ ) { if ( quantum == 1 ) SetPixelBlue ( chroma_image , ScaleCharToQuantum ( * p ++ ) , q ) ; else { SetPixelBlue ( chroma_image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | * ( p + 1 ) ) , q ) ; p += 2 ; } q += GetPixelChannels ( chroma_image ) ; } if ( SyncAuthenticPixels ( chroma_image , exception ) == MagickFalse ) break ; } } resize_image = ResizeImage ( chroma_image , image -> columns , image -> rows , TriangleFilter , exception ) ; chroma_image = DestroyImage ( chroma_image ) ; if ( resize_image == ( Image * ) NULL )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;  for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; chroma_pixels = GetVirtualPixels ( resize_image , 0 , y , resize_image -> columns , 1 , exception ) ; if ( ( q == ( Quantum * ) NULL ) || ( chroma_pixels == ( const Quantum * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelGreen ( image , GetPixelGreen ( resize_image , chroma_pixels ) , q ) ; SetPixelBlue ( image , GetPixelBlue ( resize_image , chroma_pixels ) , q ) ; chroma_pixels += GetPixelChannels ( resize_image ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } resize_image = DestroyImage ( resize_image ) ; if ( SetImageColorspace ( image , YCbCrColorspace , exception ) == MagickFalse ) break ; if ( interlace == PartitionInterlace ) ( void ) CopyMagickString ( image -> filename , image_info -> filename , MagickPathExtent ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( interlace == NoInterlace ) count = ReadBlob ( image , ( size_t ) ( 2 * quantum * image -> columns ) , scanline ) ; else count = ReadBlob ( image , ( size_t ) quantum * image -> columns , scanline ) ; if ( count != 0 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) {  image = DestroyImageList ( image ) ;  return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( count != 0 ) ; scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }",assert ( image_info != ( const ImageInfo * ) NULL ) {scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ;;,285
396,"buggy line: if ( chroma_image == ( Image * ) NULL )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;image = DestroyImageList ( image ) ;return ( ( Image * ) NULL ) ;cwe id:CWE-772context: static Image * ReadYUVImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * chroma_image , * image , * resize_image ; InterlaceType interlace ; MagickBooleanType status ; register const Quantum * chroma_pixels ; register ssize_t x ; register Quantum * q ; register unsigned char * p ; ssize_t count , horizontal_factor , vertical_factor , y ; size_t length , quantum ; unsigned char * scanline ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( OptionError , ""MustSpecifyImageSize"" ) ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; quantum = ( ssize_t ) ( image -> depth <= 8 ? 1 : 2 ) ; interlace = image_info -> interlace ; horizontal_factor = 2 ; vertical_factor = 2 ; if ( image_info -> sampling_factor != ( char * ) NULL ) { GeometryInfo geometry_info ; MagickStatusType flags ; flags = ParseGeometry ( image_info -> sampling_factor , & geometry_info ) ; horizontal_factor = ( ssize_t ) geometry_info . rho ; vertical_factor = ( ssize_t ) geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) vertical_factor = horizontal_factor ; if ( ( horizontal_factor != 1 ) && ( horizontal_factor != 2 ) && ( vertical_factor != 1 ) && ( vertical_factor != 2 ) ) ThrowReaderException ( CorruptImageError , ""UnexpectedSamplingFactor"" ) ; } if ( ( interlace == UndefinedInterlace ) || ( ( interlace == NoInterlace ) && ( vertical_factor == 2 ) ) ) { interlace = NoInterlace ; if ( vertical_factor == 2 ) interlace = PlaneInterlace ; } if ( interlace != PartitionInterlace ) { status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( DiscardBlobBytes ( image , ( MagickSizeType ) image -> offset ) == MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; } if ( interlace == NoInterlace ) scanline = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( 2UL * image -> columns + 2UL ) , ( size_t ) quantum * sizeof ( * scanline ) ) ; else scanline = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , ( size_t ) quantum * sizeof ( * scanline ) ) ; if ( scanline == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; status = MagickTrue ; do { chroma_image = CloneImage ( image , ( image -> columns + horizontal_factor - 1 ) / horizontal_factor , ( image -> rows + vertical_factor - 1 ) / vertical_factor , MagickTrue , exception ) ; if ( chroma_image == ( Image * ) NULL )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;  if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break ; if ( interlace == PartitionInterlace ) { AppendImageFormat ( ""Y"" , image -> filename ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) {  image = DestroyImageList ( image ) ;  return ( ( Image * ) NULL ) ; } } for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { register Quantum * chroma_pixels ; if ( interlace == NoInterlace ) { if ( ( y > 0 ) || ( GetPreviousImageInList ( image ) == ( Image * ) NULL ) ) { length = 2 * quantum * image -> columns ; count = ReadBlob ( image , length , scanline ) ; if ( count != ( ssize_t ) length ) { status = MagickFalse ; ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } p = scanline ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; chroma_pixels = QueueAuthenticPixels ( chroma_image , 0 , y , chroma_image -> columns , 1 , exception ) ; if ( chroma_pixels == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x += 2 ) { SetPixelRed ( chroma_image , 0 , chroma_pixels ) ; if ( quantum == 1 ) SetPixelGreen ( chroma_image , ScaleCharToQuantum ( * p ++ ) , chroma_pixels ) ; else { SetPixelGreen ( chroma_image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | * ( p + 1 ) ) , chroma_pixels ) ; p += 2 ; } if ( quantum == 1 ) SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; else { SetPixelRed ( image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | * ( p + 1 ) ) , q ) ; p += 2 ; } SetPixelGreen ( image , 0 , q ) ; SetPixelBlue ( image , 0 , q ) ; q += GetPixelChannels ( image ) ; SetPixelGreen ( image , 0 , q ) ; SetPixelBlue ( image , 0 , q ) ; if ( quantum == 1 ) SetPixelBlue ( chroma_image , ScaleCharToQuantum ( * p ++ ) , chroma_pixels ) ; else { SetPixelBlue ( chroma_image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | * ( p + 1 ) ) , chroma_pixels ) ; p += 2 ; } if ( quantum == 1 ) SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; else { SetPixelRed ( image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | * ( p + 1 ) ) , q ) ; p += 2 ; } chroma_pixels += GetPixelChannels ( chroma_image ) ; q += GetPixelChannels ( image ) ; } } else { if ( ( y > 0 ) || ( GetPreviousImageInList ( image ) == ( Image * ) NULL ) ) { length = quantum * image -> columns ; count = ReadBlob ( image , length , scanline ) ; if ( count != ( ssize_t ) length ) { status = MagickFalse ; ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } p = scanline ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( quantum == 1 ) SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; else { SetPixelRed ( image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | * ( p + 1 ) ) , q ) ; p += 2 ; } SetPixelGreen ( image , 0 , q ) ; SetPixelBlue ( image , 0 , q ) ; q += GetPixelChannels ( image ) ; } } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( interlace == NoInterlace ) if ( SyncAuthenticPixels ( chroma_image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } if ( interlace == PartitionInterlace ) { ( void ) CloseBlob ( image ) ; AppendImageFormat ( ""U"" , image -> filename ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) {  image = DestroyImageList ( image ) ;  return ( ( Image * ) NULL ) ; } } if ( interlace != NoInterlace ) { for ( y = 0 ; y < ( ssize_t ) chroma_image -> rows ; y ++ ) { length = quantum * chroma_image -> columns ; count = ReadBlob ( image , length , scanline ) ; if ( count != ( ssize_t ) length ) { status = MagickFalse ; ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } p = scanline ; q = QueueAuthenticPixels ( chroma_image , 0 , y , chroma_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) chroma_image -> columns ; x ++ ) { SetPixelRed ( chroma_image , 0 , q ) ; if ( quantum == 1 ) SetPixelGreen ( chroma_image , ScaleCharToQuantum ( * p ++ ) , q ) ; else { SetPixelGreen ( chroma_image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | * ( p + 1 ) ) , q ) ; p += 2 ; } SetPixelBlue ( chroma_image , 0 , q ) ; q += GetPixelChannels ( chroma_image ) ; } if ( SyncAuthenticPixels ( chroma_image , exception ) == MagickFalse ) break ; } if ( interlace == PartitionInterlace ) { ( void ) CloseBlob ( image ) ; AppendImageFormat ( ""V"" , image -> filename ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) {  image = DestroyImageList ( image ) ;  return ( ( Image * ) NULL ) ; } } for ( y = 0 ; y < ( ssize_t ) chroma_image -> rows ; y ++ ) { length = quantum * chroma_image -> columns ; count = ReadBlob ( image , length , scanline ) ; if ( count != ( ssize_t ) length ) { status = MagickFalse ; ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } p = scanline ; q = GetAuthenticPixels ( chroma_image , 0 , y , chroma_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) chroma_image -> columns ; x ++ ) { if ( quantum == 1 ) SetPixelBlue ( chroma_image , ScaleCharToQuantum ( * p ++ ) , q ) ; else { SetPixelBlue ( chroma_image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | * ( p + 1 ) ) , q ) ; p += 2 ; } q += GetPixelChannels ( chroma_image ) ; } if ( SyncAuthenticPixels ( chroma_image , exception ) == MagickFalse ) break ; } } resize_image = ResizeImage ( chroma_image , image -> columns , image -> rows , TriangleFilter , exception ) ; chroma_image = DestroyImage ( chroma_image ) ; if ( resize_image == ( Image * ) NULL )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;  for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; chroma_pixels = GetVirtualPixels ( resize_image , 0 , y , resize_image -> columns , 1 , exception ) ; if ( ( q == ( Quantum * ) NULL ) || ( chroma_pixels == ( const Quantum * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelGreen ( image , GetPixelGreen ( resize_image , chroma_pixels ) , q ) ; SetPixelBlue ( image , GetPixelBlue ( resize_image , chroma_pixels ) , q ) ; chroma_pixels += GetPixelChannels ( resize_image ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } resize_image = DestroyImage ( resize_image ) ; if ( SetImageColorspace ( image , YCbCrColorspace , exception ) == MagickFalse ) break ; if ( interlace == PartitionInterlace ) ( void ) CopyMagickString ( image -> filename , image_info -> filename , MagickPathExtent ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( interlace == NoInterlace ) count = ReadBlob ( image , ( size_t ) ( 2 * quantum * image -> columns ) , scanline ) ; else count = ReadBlob ( image , ( size_t ) quantum * image -> columns , scanline ) ; if ( count != 0 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) {  image = DestroyImageList ( image ) ;  return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( count != 0 ) ; scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }","}if ( chroma_image == ( Image * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ;image = DestroyImageList ( image ) ;return ( ( Image * ) NULL ) ;",285
397,"buggy line: image = DestroyImageList ( image ) ;return ( ( Image * ) NULL ) ;cwe id:CWE-772context: static Image * ReadYUVImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * chroma_image , * image , * resize_image ; InterlaceType interlace ; MagickBooleanType status ; register const Quantum * chroma_pixels ; register ssize_t x ; register Quantum * q ; register unsigned char * p ; ssize_t count , horizontal_factor , vertical_factor , y ; size_t length , quantum ; unsigned char * scanline ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( OptionError , ""MustSpecifyImageSize"" ) ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; quantum = ( ssize_t ) ( image -> depth <= 8 ? 1 : 2 ) ; interlace = image_info -> interlace ; horizontal_factor = 2 ; vertical_factor = 2 ; if ( image_info -> sampling_factor != ( char * ) NULL ) { GeometryInfo geometry_info ; MagickStatusType flags ; flags = ParseGeometry ( image_info -> sampling_factor , & geometry_info ) ; horizontal_factor = ( ssize_t ) geometry_info . rho ; vertical_factor = ( ssize_t ) geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) vertical_factor = horizontal_factor ; if ( ( horizontal_factor != 1 ) && ( horizontal_factor != 2 ) && ( vertical_factor != 1 ) && ( vertical_factor != 2 ) ) ThrowReaderException ( CorruptImageError , ""UnexpectedSamplingFactor"" ) ; } if ( ( interlace == UndefinedInterlace ) || ( ( interlace == NoInterlace ) && ( vertical_factor == 2 ) ) ) { interlace = NoInterlace ; if ( vertical_factor == 2 ) interlace = PlaneInterlace ; } if ( interlace != PartitionInterlace ) { status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( DiscardBlobBytes ( image , ( MagickSizeType ) image -> offset ) == MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; } if ( interlace == NoInterlace ) scanline = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( 2UL * image -> columns + 2UL ) , ( size_t ) quantum * sizeof ( * scanline ) ) ; else scanline = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , ( size_t ) quantum * sizeof ( * scanline ) ) ; if ( scanline == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; status = MagickTrue ; do { chroma_image = CloneImage ( image , ( image -> columns + horizontal_factor - 1 ) / horizontal_factor , ( image -> rows + vertical_factor - 1 ) / vertical_factor , MagickTrue , exception ) ; if ( chroma_image == ( Image * ) NULL )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;  if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break ; if ( interlace == PartitionInterlace ) { AppendImageFormat ( ""Y"" , image -> filename ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) {  image = DestroyImageList ( image ) ;  return ( ( Image * ) NULL ) ; } } for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { register Quantum * chroma_pixels ; if ( interlace == NoInterlace ) { if ( ( y > 0 ) || ( GetPreviousImageInList ( image ) == ( Image * ) NULL ) ) { length = 2 * quantum * image -> columns ; count = ReadBlob ( image , length , scanline ) ; if ( count != ( ssize_t ) length ) { status = MagickFalse ; ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } p = scanline ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; chroma_pixels = QueueAuthenticPixels ( chroma_image , 0 , y , chroma_image -> columns , 1 , exception ) ; if ( chroma_pixels == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x += 2 ) { SetPixelRed ( chroma_image , 0 , chroma_pixels ) ; if ( quantum == 1 ) SetPixelGreen ( chroma_image , ScaleCharToQuantum ( * p ++ ) , chroma_pixels ) ; else { SetPixelGreen ( chroma_image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | * ( p + 1 ) ) , chroma_pixels ) ; p += 2 ; } if ( quantum == 1 ) SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; else { SetPixelRed ( image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | * ( p + 1 ) ) , q ) ; p += 2 ; } SetPixelGreen ( image , 0 , q ) ; SetPixelBlue ( image , 0 , q ) ; q += GetPixelChannels ( image ) ; SetPixelGreen ( image , 0 , q ) ; SetPixelBlue ( image , 0 , q ) ; if ( quantum == 1 ) SetPixelBlue ( chroma_image , ScaleCharToQuantum ( * p ++ ) , chroma_pixels ) ; else { SetPixelBlue ( chroma_image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | * ( p + 1 ) ) , chroma_pixels ) ; p += 2 ; } if ( quantum == 1 ) SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; else { SetPixelRed ( image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | * ( p + 1 ) ) , q ) ; p += 2 ; } chroma_pixels += GetPixelChannels ( chroma_image ) ; q += GetPixelChannels ( image ) ; } } else { if ( ( y > 0 ) || ( GetPreviousImageInList ( image ) == ( Image * ) NULL ) ) { length = quantum * image -> columns ; count = ReadBlob ( image , length , scanline ) ; if ( count != ( ssize_t ) length ) { status = MagickFalse ; ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } p = scanline ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( quantum == 1 ) SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; else { SetPixelRed ( image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | * ( p + 1 ) ) , q ) ; p += 2 ; } SetPixelGreen ( image , 0 , q ) ; SetPixelBlue ( image , 0 , q ) ; q += GetPixelChannels ( image ) ; } } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( interlace == NoInterlace ) if ( SyncAuthenticPixels ( chroma_image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } if ( interlace == PartitionInterlace ) { ( void ) CloseBlob ( image ) ; AppendImageFormat ( ""U"" , image -> filename ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) {  image = DestroyImageList ( image ) ;  return ( ( Image * ) NULL ) ; } } if ( interlace != NoInterlace ) { for ( y = 0 ; y < ( ssize_t ) chroma_image -> rows ; y ++ ) { length = quantum * chroma_image -> columns ; count = ReadBlob ( image , length , scanline ) ; if ( count != ( ssize_t ) length ) { status = MagickFalse ; ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } p = scanline ; q = QueueAuthenticPixels ( chroma_image , 0 , y , chroma_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) chroma_image -> columns ; x ++ ) { SetPixelRed ( chroma_image , 0 , q ) ; if ( quantum == 1 ) SetPixelGreen ( chroma_image , ScaleCharToQuantum ( * p ++ ) , q ) ; else { SetPixelGreen ( chroma_image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | * ( p + 1 ) ) , q ) ; p += 2 ; } SetPixelBlue ( chroma_image , 0 , q ) ; q += GetPixelChannels ( chroma_image ) ; } if ( SyncAuthenticPixels ( chroma_image , exception ) == MagickFalse ) break ; } if ( interlace == PartitionInterlace ) { ( void ) CloseBlob ( image ) ; AppendImageFormat ( ""V"" , image -> filename ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) {  image = DestroyImageList ( image ) ;  return ( ( Image * ) NULL ) ; } } for ( y = 0 ; y < ( ssize_t ) chroma_image -> rows ; y ++ ) { length = quantum * chroma_image -> columns ; count = ReadBlob ( image , length , scanline ) ; if ( count != ( ssize_t ) length ) { status = MagickFalse ; ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } p = scanline ; q = GetAuthenticPixels ( chroma_image , 0 , y , chroma_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) chroma_image -> columns ; x ++ ) { if ( quantum == 1 ) SetPixelBlue ( chroma_image , ScaleCharToQuantum ( * p ++ ) , q ) ; else { SetPixelBlue ( chroma_image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | * ( p + 1 ) ) , q ) ; p += 2 ; } q += GetPixelChannels ( chroma_image ) ; } if ( SyncAuthenticPixels ( chroma_image , exception ) == MagickFalse ) break ; } } resize_image = ResizeImage ( chroma_image , image -> columns , image -> rows , TriangleFilter , exception ) ; chroma_image = DestroyImage ( chroma_image ) ; if ( resize_image == ( Image * ) NULL )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;  for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; chroma_pixels = GetVirtualPixels ( resize_image , 0 , y , resize_image -> columns , 1 , exception ) ; if ( ( q == ( Quantum * ) NULL ) || ( chroma_pixels == ( const Quantum * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelGreen ( image , GetPixelGreen ( resize_image , chroma_pixels ) , q ) ; SetPixelBlue ( image , GetPixelBlue ( resize_image , chroma_pixels ) , q ) ; chroma_pixels += GetPixelChannels ( resize_image ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } resize_image = DestroyImage ( resize_image ) ; if ( SetImageColorspace ( image , YCbCrColorspace , exception ) == MagickFalse ) break ; if ( interlace == PartitionInterlace ) ( void ) CopyMagickString ( image -> filename , image_info -> filename , MagickPathExtent ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( interlace == NoInterlace ) count = ReadBlob ( image , ( size_t ) ( 2 * quantum * image -> columns ) , scanline ) ; else count = ReadBlob ( image , ( size_t ) quantum * image -> columns , scanline ) ; if ( count != 0 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) {  image = DestroyImageList ( image ) ;  return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( count != 0 ) ; scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }",scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ;image = DestroyImageList ( image ) ;return ( ( Image * ) NULL ) ;,285
398,"buggy line: image = DestroyImageList ( image ) ;return ( ( Image * ) NULL ) ;cwe id:CWE-772context: static Image * ReadYUVImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * chroma_image , * image , * resize_image ; InterlaceType interlace ; MagickBooleanType status ; register const Quantum * chroma_pixels ; register ssize_t x ; register Quantum * q ; register unsigned char * p ; ssize_t count , horizontal_factor , vertical_factor , y ; size_t length , quantum ; unsigned char * scanline ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( OptionError , ""MustSpecifyImageSize"" ) ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; quantum = ( ssize_t ) ( image -> depth <= 8 ? 1 : 2 ) ; interlace = image_info -> interlace ; horizontal_factor = 2 ; vertical_factor = 2 ; if ( image_info -> sampling_factor != ( char * ) NULL ) { GeometryInfo geometry_info ; MagickStatusType flags ; flags = ParseGeometry ( image_info -> sampling_factor , & geometry_info ) ; horizontal_factor = ( ssize_t ) geometry_info . rho ; vertical_factor = ( ssize_t ) geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) vertical_factor = horizontal_factor ; if ( ( horizontal_factor != 1 ) && ( horizontal_factor != 2 ) && ( vertical_factor != 1 ) && ( vertical_factor != 2 ) ) ThrowReaderException ( CorruptImageError , ""UnexpectedSamplingFactor"" ) ; } if ( ( interlace == UndefinedInterlace ) || ( ( interlace == NoInterlace ) && ( vertical_factor == 2 ) ) ) { interlace = NoInterlace ; if ( vertical_factor == 2 ) interlace = PlaneInterlace ; } if ( interlace != PartitionInterlace ) { status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( DiscardBlobBytes ( image , ( MagickSizeType ) image -> offset ) == MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; } if ( interlace == NoInterlace ) scanline = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( 2UL * image -> columns + 2UL ) , ( size_t ) quantum * sizeof ( * scanline ) ) ; else scanline = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , ( size_t ) quantum * sizeof ( * scanline ) ) ; if ( scanline == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; status = MagickTrue ; do { chroma_image = CloneImage ( image , ( image -> columns + horizontal_factor - 1 ) / horizontal_factor , ( image -> rows + vertical_factor - 1 ) / vertical_factor , MagickTrue , exception ) ; if ( chroma_image == ( Image * ) NULL )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;  if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break ; if ( interlace == PartitionInterlace ) { AppendImageFormat ( ""Y"" , image -> filename ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) {  image = DestroyImageList ( image ) ;  return ( ( Image * ) NULL ) ; } } for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { register Quantum * chroma_pixels ; if ( interlace == NoInterlace ) { if ( ( y > 0 ) || ( GetPreviousImageInList ( image ) == ( Image * ) NULL ) ) { length = 2 * quantum * image -> columns ; count = ReadBlob ( image , length , scanline ) ; if ( count != ( ssize_t ) length ) { status = MagickFalse ; ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } p = scanline ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; chroma_pixels = QueueAuthenticPixels ( chroma_image , 0 , y , chroma_image -> columns , 1 , exception ) ; if ( chroma_pixels == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x += 2 ) { SetPixelRed ( chroma_image , 0 , chroma_pixels ) ; if ( quantum == 1 ) SetPixelGreen ( chroma_image , ScaleCharToQuantum ( * p ++ ) , chroma_pixels ) ; else { SetPixelGreen ( chroma_image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | * ( p + 1 ) ) , chroma_pixels ) ; p += 2 ; } if ( quantum == 1 ) SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; else { SetPixelRed ( image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | * ( p + 1 ) ) , q ) ; p += 2 ; } SetPixelGreen ( image , 0 , q ) ; SetPixelBlue ( image , 0 , q ) ; q += GetPixelChannels ( image ) ; SetPixelGreen ( image , 0 , q ) ; SetPixelBlue ( image , 0 , q ) ; if ( quantum == 1 ) SetPixelBlue ( chroma_image , ScaleCharToQuantum ( * p ++ ) , chroma_pixels ) ; else { SetPixelBlue ( chroma_image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | * ( p + 1 ) ) , chroma_pixels ) ; p += 2 ; } if ( quantum == 1 ) SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; else { SetPixelRed ( image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | * ( p + 1 ) ) , q ) ; p += 2 ; } chroma_pixels += GetPixelChannels ( chroma_image ) ; q += GetPixelChannels ( image ) ; } } else { if ( ( y > 0 ) || ( GetPreviousImageInList ( image ) == ( Image * ) NULL ) ) { length = quantum * image -> columns ; count = ReadBlob ( image , length , scanline ) ; if ( count != ( ssize_t ) length ) { status = MagickFalse ; ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } p = scanline ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( quantum == 1 ) SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; else { SetPixelRed ( image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | * ( p + 1 ) ) , q ) ; p += 2 ; } SetPixelGreen ( image , 0 , q ) ; SetPixelBlue ( image , 0 , q ) ; q += GetPixelChannels ( image ) ; } } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( interlace == NoInterlace ) if ( SyncAuthenticPixels ( chroma_image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } if ( interlace == PartitionInterlace ) { ( void ) CloseBlob ( image ) ; AppendImageFormat ( ""U"" , image -> filename ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) {  image = DestroyImageList ( image ) ;  return ( ( Image * ) NULL ) ; } } if ( interlace != NoInterlace ) { for ( y = 0 ; y < ( ssize_t ) chroma_image -> rows ; y ++ ) { length = quantum * chroma_image -> columns ; count = ReadBlob ( image , length , scanline ) ; if ( count != ( ssize_t ) length ) { status = MagickFalse ; ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } p = scanline ; q = QueueAuthenticPixels ( chroma_image , 0 , y , chroma_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) chroma_image -> columns ; x ++ ) { SetPixelRed ( chroma_image , 0 , q ) ; if ( quantum == 1 ) SetPixelGreen ( chroma_image , ScaleCharToQuantum ( * p ++ ) , q ) ; else { SetPixelGreen ( chroma_image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | * ( p + 1 ) ) , q ) ; p += 2 ; } SetPixelBlue ( chroma_image , 0 , q ) ; q += GetPixelChannels ( chroma_image ) ; } if ( SyncAuthenticPixels ( chroma_image , exception ) == MagickFalse ) break ; } if ( interlace == PartitionInterlace ) { ( void ) CloseBlob ( image ) ; AppendImageFormat ( ""V"" , image -> filename ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) {  image = DestroyImageList ( image ) ;  return ( ( Image * ) NULL ) ; } } for ( y = 0 ; y < ( ssize_t ) chroma_image -> rows ; y ++ ) { length = quantum * chroma_image -> columns ; count = ReadBlob ( image , length , scanline ) ; if ( count != ( ssize_t ) length ) { status = MagickFalse ; ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } p = scanline ; q = GetAuthenticPixels ( chroma_image , 0 , y , chroma_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) chroma_image -> columns ; x ++ ) { if ( quantum == 1 ) SetPixelBlue ( chroma_image , ScaleCharToQuantum ( * p ++ ) , q ) ; else { SetPixelBlue ( chroma_image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | * ( p + 1 ) ) , q ) ; p += 2 ; } q += GetPixelChannels ( chroma_image ) ; } if ( SyncAuthenticPixels ( chroma_image , exception ) == MagickFalse ) break ; } } resize_image = ResizeImage ( chroma_image , image -> columns , image -> rows , TriangleFilter , exception ) ; chroma_image = DestroyImage ( chroma_image ) ; if ( resize_image == ( Image * ) NULL )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;  for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; chroma_pixels = GetVirtualPixels ( resize_image , 0 , y , resize_image -> columns , 1 , exception ) ; if ( ( q == ( Quantum * ) NULL ) || ( chroma_pixels == ( const Quantum * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelGreen ( image , GetPixelGreen ( resize_image , chroma_pixels ) , q ) ; SetPixelBlue ( image , GetPixelBlue ( resize_image , chroma_pixels ) , q ) ; chroma_pixels += GetPixelChannels ( resize_image ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } resize_image = DestroyImage ( resize_image ) ; if ( SetImageColorspace ( image , YCbCrColorspace , exception ) == MagickFalse ) break ; if ( interlace == PartitionInterlace ) ( void ) CopyMagickString ( image -> filename , image_info -> filename , MagickPathExtent ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( interlace == NoInterlace ) count = ReadBlob ( image , ( size_t ) ( 2 * quantum * image -> columns ) , scanline ) ; else count = ReadBlob ( image , ( size_t ) quantum * image -> columns , scanline ) ; if ( count != 0 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) {  image = DestroyImageList ( image ) ;  return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( count != 0 ) ; scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }",scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ;image = DestroyImageList ( image ) ;return ( ( Image * ) NULL ) {scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ;;,285
399,"buggy line: if ( resize_image == ( Image * ) NULL )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;for ( y = 0 ;cwe id:CWE-772context: static Image * ReadYUVImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * chroma_image , * image , * resize_image ; InterlaceType interlace ; MagickBooleanType status ; register const Quantum * chroma_pixels ; register ssize_t x ; register Quantum * q ; register unsigned char * p ; ssize_t count , horizontal_factor , vertical_factor , y ; size_t length , quantum ; unsigned char * scanline ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( OptionError , ""MustSpecifyImageSize"" ) ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; quantum = ( ssize_t ) ( image -> depth <= 8 ? 1 : 2 ) ; interlace = image_info -> interlace ; horizontal_factor = 2 ; vertical_factor = 2 ; if ( image_info -> sampling_factor != ( char * ) NULL ) { GeometryInfo geometry_info ; MagickStatusType flags ; flags = ParseGeometry ( image_info -> sampling_factor , & geometry_info ) ; horizontal_factor = ( ssize_t ) geometry_info . rho ; vertical_factor = ( ssize_t ) geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) vertical_factor = horizontal_factor ; if ( ( horizontal_factor != 1 ) && ( horizontal_factor != 2 ) && ( vertical_factor != 1 ) && ( vertical_factor != 2 ) ) ThrowReaderException ( CorruptImageError , ""UnexpectedSamplingFactor"" ) ; } if ( ( interlace == UndefinedInterlace ) || ( ( interlace == NoInterlace ) && ( vertical_factor == 2 ) ) ) { interlace = NoInterlace ; if ( vertical_factor == 2 ) interlace = PlaneInterlace ; } if ( interlace != PartitionInterlace ) { status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( DiscardBlobBytes ( image , ( MagickSizeType ) image -> offset ) == MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; } if ( interlace == NoInterlace ) scanline = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( 2UL * image -> columns + 2UL ) , ( size_t ) quantum * sizeof ( * scanline ) ) ; else scanline = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , ( size_t ) quantum * sizeof ( * scanline ) ) ; if ( scanline == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; status = MagickTrue ; do { chroma_image = CloneImage ( image , ( image -> columns + horizontal_factor - 1 ) / horizontal_factor , ( image -> rows + vertical_factor - 1 ) / vertical_factor , MagickTrue , exception ) ; if ( chroma_image == ( Image * ) NULL )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;  if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break ; if ( interlace == PartitionInterlace ) { AppendImageFormat ( ""Y"" , image -> filename ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) {  image = DestroyImageList ( image ) ;  return ( ( Image * ) NULL ) ; } } for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { register Quantum * chroma_pixels ; if ( interlace == NoInterlace ) { if ( ( y > 0 ) || ( GetPreviousImageInList ( image ) == ( Image * ) NULL ) ) { length = 2 * quantum * image -> columns ; count = ReadBlob ( image , length , scanline ) ; if ( count != ( ssize_t ) length ) { status = MagickFalse ; ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } p = scanline ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; chroma_pixels = QueueAuthenticPixels ( chroma_image , 0 , y , chroma_image -> columns , 1 , exception ) ; if ( chroma_pixels == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x += 2 ) { SetPixelRed ( chroma_image , 0 , chroma_pixels ) ; if ( quantum == 1 ) SetPixelGreen ( chroma_image , ScaleCharToQuantum ( * p ++ ) , chroma_pixels ) ; else { SetPixelGreen ( chroma_image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | * ( p + 1 ) ) , chroma_pixels ) ; p += 2 ; } if ( quantum == 1 ) SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; else { SetPixelRed ( image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | * ( p + 1 ) ) , q ) ; p += 2 ; } SetPixelGreen ( image , 0 , q ) ; SetPixelBlue ( image , 0 , q ) ; q += GetPixelChannels ( image ) ; SetPixelGreen ( image , 0 , q ) ; SetPixelBlue ( image , 0 , q ) ; if ( quantum == 1 ) SetPixelBlue ( chroma_image , ScaleCharToQuantum ( * p ++ ) , chroma_pixels ) ; else { SetPixelBlue ( chroma_image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | * ( p + 1 ) ) , chroma_pixels ) ; p += 2 ; } if ( quantum == 1 ) SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; else { SetPixelRed ( image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | * ( p + 1 ) ) , q ) ; p += 2 ; } chroma_pixels += GetPixelChannels ( chroma_image ) ; q += GetPixelChannels ( image ) ; } } else { if ( ( y > 0 ) || ( GetPreviousImageInList ( image ) == ( Image * ) NULL ) ) { length = quantum * image -> columns ; count = ReadBlob ( image , length , scanline ) ; if ( count != ( ssize_t ) length ) { status = MagickFalse ; ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } p = scanline ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( quantum == 1 ) SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; else { SetPixelRed ( image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | * ( p + 1 ) ) , q ) ; p += 2 ; } SetPixelGreen ( image , 0 , q ) ; SetPixelBlue ( image , 0 , q ) ; q += GetPixelChannels ( image ) ; } } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( interlace == NoInterlace ) if ( SyncAuthenticPixels ( chroma_image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } if ( interlace == PartitionInterlace ) { ( void ) CloseBlob ( image ) ; AppendImageFormat ( ""U"" , image -> filename ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) {  image = DestroyImageList ( image ) ;  return ( ( Image * ) NULL ) ; } } if ( interlace != NoInterlace ) { for ( y = 0 ; y < ( ssize_t ) chroma_image -> rows ; y ++ ) { length = quantum * chroma_image -> columns ; count = ReadBlob ( image , length , scanline ) ; if ( count != ( ssize_t ) length ) { status = MagickFalse ; ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } p = scanline ; q = QueueAuthenticPixels ( chroma_image , 0 , y , chroma_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) chroma_image -> columns ; x ++ ) { SetPixelRed ( chroma_image , 0 , q ) ; if ( quantum == 1 ) SetPixelGreen ( chroma_image , ScaleCharToQuantum ( * p ++ ) , q ) ; else { SetPixelGreen ( chroma_image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | * ( p + 1 ) ) , q ) ; p += 2 ; } SetPixelBlue ( chroma_image , 0 , q ) ; q += GetPixelChannels ( chroma_image ) ; } if ( SyncAuthenticPixels ( chroma_image , exception ) == MagickFalse ) break ; } if ( interlace == PartitionInterlace ) { ( void ) CloseBlob ( image ) ; AppendImageFormat ( ""V"" , image -> filename ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) {  image = DestroyImageList ( image ) ;  return ( ( Image * ) NULL ) ; } } for ( y = 0 ; y < ( ssize_t ) chroma_image -> rows ; y ++ ) { length = quantum * chroma_image -> columns ; count = ReadBlob ( image , length , scanline ) ; if ( count != ( ssize_t ) length ) { status = MagickFalse ; ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } p = scanline ; q = GetAuthenticPixels ( chroma_image , 0 , y , chroma_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) chroma_image -> columns ; x ++ ) { if ( quantum == 1 ) SetPixelBlue ( chroma_image , ScaleCharToQuantum ( * p ++ ) , q ) ; else { SetPixelBlue ( chroma_image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | * ( p + 1 ) ) , q ) ; p += 2 ; } q += GetPixelChannels ( chroma_image ) ; } if ( SyncAuthenticPixels ( chroma_image , exception ) == MagickFalse ) break ; } } resize_image = ResizeImage ( chroma_image , image -> columns , image -> rows , TriangleFilter , exception ) ; chroma_image = DestroyImage ( chroma_image ) ; if ( resize_image == ( Image * ) NULL )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;  for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; chroma_pixels = GetVirtualPixels ( resize_image , 0 , y , resize_image -> columns , 1 , exception ) ; if ( ( q == ( Quantum * ) NULL ) || ( chroma_pixels == ( const Quantum * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelGreen ( image , GetPixelGreen ( resize_image , chroma_pixels ) , q ) ; SetPixelBlue ( image , GetPixelBlue ( resize_image , chroma_pixels ) , q ) ; chroma_pixels += GetPixelChannels ( resize_image ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } resize_image = DestroyImage ( resize_image ) ; if ( SetImageColorspace ( image , YCbCrColorspace , exception ) == MagickFalse ) break ; if ( interlace == PartitionInterlace ) ( void ) CopyMagickString ( image -> filename , image_info -> filename , MagickPathExtent ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( interlace == NoInterlace ) count = ReadBlob ( image , ( size_t ) ( 2 * quantum * image -> columns ) , scanline ) ; else count = ReadBlob ( image , ( size_t ) quantum * image -> columns , scanline ) ; if ( count != 0 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) {  image = DestroyImageList ( image ) ;  return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( count != 0 ) ; scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }","if ( resize_image == ( Image * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;}for ( y = 0 ;",285
400,"buggy line: image = DestroyImageList ( image ) ;return ( ( Image * ) NULL ) ;cwe id:CWE-772context: static Image * ReadYUVImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * chroma_image , * image , * resize_image ; InterlaceType interlace ; MagickBooleanType status ; register const Quantum * chroma_pixels ; register ssize_t x ; register Quantum * q ; register unsigned char * p ; ssize_t count , horizontal_factor , vertical_factor , y ; size_t length , quantum ; unsigned char * scanline ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( OptionError , ""MustSpecifyImageSize"" ) ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; quantum = ( ssize_t ) ( image -> depth <= 8 ? 1 : 2 ) ; interlace = image_info -> interlace ; horizontal_factor = 2 ; vertical_factor = 2 ; if ( image_info -> sampling_factor != ( char * ) NULL ) { GeometryInfo geometry_info ; MagickStatusType flags ; flags = ParseGeometry ( image_info -> sampling_factor , & geometry_info ) ; horizontal_factor = ( ssize_t ) geometry_info . rho ; vertical_factor = ( ssize_t ) geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) vertical_factor = horizontal_factor ; if ( ( horizontal_factor != 1 ) && ( horizontal_factor != 2 ) && ( vertical_factor != 1 ) && ( vertical_factor != 2 ) ) ThrowReaderException ( CorruptImageError , ""UnexpectedSamplingFactor"" ) ; } if ( ( interlace == UndefinedInterlace ) || ( ( interlace == NoInterlace ) && ( vertical_factor == 2 ) ) ) { interlace = NoInterlace ; if ( vertical_factor == 2 ) interlace = PlaneInterlace ; } if ( interlace != PartitionInterlace ) { status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( DiscardBlobBytes ( image , ( MagickSizeType ) image -> offset ) == MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; } if ( interlace == NoInterlace ) scanline = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( 2UL * image -> columns + 2UL ) , ( size_t ) quantum * sizeof ( * scanline ) ) ; else scanline = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , ( size_t ) quantum * sizeof ( * scanline ) ) ; if ( scanline == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; status = MagickTrue ; do { chroma_image = CloneImage ( image , ( image -> columns + horizontal_factor - 1 ) / horizontal_factor , ( image -> rows + vertical_factor - 1 ) / vertical_factor , MagickTrue , exception ) ; if ( chroma_image == ( Image * ) NULL )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;  if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break ; if ( interlace == PartitionInterlace ) { AppendImageFormat ( ""Y"" , image -> filename ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) {  image = DestroyImageList ( image ) ;  return ( ( Image * ) NULL ) ; } } for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { register Quantum * chroma_pixels ; if ( interlace == NoInterlace ) { if ( ( y > 0 ) || ( GetPreviousImageInList ( image ) == ( Image * ) NULL ) ) { length = 2 * quantum * image -> columns ; count = ReadBlob ( image , length , scanline ) ; if ( count != ( ssize_t ) length ) { status = MagickFalse ; ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } p = scanline ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; chroma_pixels = QueueAuthenticPixels ( chroma_image , 0 , y , chroma_image -> columns , 1 , exception ) ; if ( chroma_pixels == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x += 2 ) { SetPixelRed ( chroma_image , 0 , chroma_pixels ) ; if ( quantum == 1 ) SetPixelGreen ( chroma_image , ScaleCharToQuantum ( * p ++ ) , chroma_pixels ) ; else { SetPixelGreen ( chroma_image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | * ( p + 1 ) ) , chroma_pixels ) ; p += 2 ; } if ( quantum == 1 ) SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; else { SetPixelRed ( image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | * ( p + 1 ) ) , q ) ; p += 2 ; } SetPixelGreen ( image , 0 , q ) ; SetPixelBlue ( image , 0 , q ) ; q += GetPixelChannels ( image ) ; SetPixelGreen ( image , 0 , q ) ; SetPixelBlue ( image , 0 , q ) ; if ( quantum == 1 ) SetPixelBlue ( chroma_image , ScaleCharToQuantum ( * p ++ ) , chroma_pixels ) ; else { SetPixelBlue ( chroma_image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | * ( p + 1 ) ) , chroma_pixels ) ; p += 2 ; } if ( quantum == 1 ) SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; else { SetPixelRed ( image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | * ( p + 1 ) ) , q ) ; p += 2 ; } chroma_pixels += GetPixelChannels ( chroma_image ) ; q += GetPixelChannels ( image ) ; } } else { if ( ( y > 0 ) || ( GetPreviousImageInList ( image ) == ( Image * ) NULL ) ) { length = quantum * image -> columns ; count = ReadBlob ( image , length , scanline ) ; if ( count != ( ssize_t ) length ) { status = MagickFalse ; ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } p = scanline ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( quantum == 1 ) SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; else { SetPixelRed ( image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | * ( p + 1 ) ) , q ) ; p += 2 ; } SetPixelGreen ( image , 0 , q ) ; SetPixelBlue ( image , 0 , q ) ; q += GetPixelChannels ( image ) ; } } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( interlace == NoInterlace ) if ( SyncAuthenticPixels ( chroma_image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } if ( interlace == PartitionInterlace ) { ( void ) CloseBlob ( image ) ; AppendImageFormat ( ""U"" , image -> filename ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) {  image = DestroyImageList ( image ) ;  return ( ( Image * ) NULL ) ; } } if ( interlace != NoInterlace ) { for ( y = 0 ; y < ( ssize_t ) chroma_image -> rows ; y ++ ) { length = quantum * chroma_image -> columns ; count = ReadBlob ( image , length , scanline ) ; if ( count != ( ssize_t ) length ) { status = MagickFalse ; ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } p = scanline ; q = QueueAuthenticPixels ( chroma_image , 0 , y , chroma_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) chroma_image -> columns ; x ++ ) { SetPixelRed ( chroma_image , 0 , q ) ; if ( quantum == 1 ) SetPixelGreen ( chroma_image , ScaleCharToQuantum ( * p ++ ) , q ) ; else { SetPixelGreen ( chroma_image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | * ( p + 1 ) ) , q ) ; p += 2 ; } SetPixelBlue ( chroma_image , 0 , q ) ; q += GetPixelChannels ( chroma_image ) ; } if ( SyncAuthenticPixels ( chroma_image , exception ) == MagickFalse ) break ; } if ( interlace == PartitionInterlace ) { ( void ) CloseBlob ( image ) ; AppendImageFormat ( ""V"" , image -> filename ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) {  image = DestroyImageList ( image ) ;  return ( ( Image * ) NULL ) ; } } for ( y = 0 ; y < ( ssize_t ) chroma_image -> rows ; y ++ ) { length = quantum * chroma_image -> columns ; count = ReadBlob ( image , length , scanline ) ; if ( count != ( ssize_t ) length ) { status = MagickFalse ; ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } p = scanline ; q = GetAuthenticPixels ( chroma_image , 0 , y , chroma_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) chroma_image -> columns ; x ++ ) { if ( quantum == 1 ) SetPixelBlue ( chroma_image , ScaleCharToQuantum ( * p ++ ) , q ) ; else { SetPixelBlue ( chroma_image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | * ( p + 1 ) ) , q ) ; p += 2 ; } q += GetPixelChannels ( chroma_image ) ; } if ( SyncAuthenticPixels ( chroma_image , exception ) == MagickFalse ) break ; } } resize_image = ResizeImage ( chroma_image , image -> columns , image -> rows , TriangleFilter , exception ) ; chroma_image = DestroyImage ( chroma_image ) ; if ( resize_image == ( Image * ) NULL )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;  for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; chroma_pixels = GetVirtualPixels ( resize_image , 0 , y , resize_image -> columns , 1 , exception ) ; if ( ( q == ( Quantum * ) NULL ) || ( chroma_pixels == ( const Quantum * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelGreen ( image , GetPixelGreen ( resize_image , chroma_pixels ) , q ) ; SetPixelBlue ( image , GetPixelBlue ( resize_image , chroma_pixels ) , q ) ; chroma_pixels += GetPixelChannels ( resize_image ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } resize_image = DestroyImage ( resize_image ) ; if ( SetImageColorspace ( image , YCbCrColorspace , exception ) == MagickFalse ) break ; if ( interlace == PartitionInterlace ) ( void ) CopyMagickString ( image -> filename , image_info -> filename , MagickPathExtent ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( interlace == NoInterlace ) count = ReadBlob ( image , ( size_t ) ( 2 * quantum * image -> columns ) , scanline ) ; else count = ReadBlob ( image , ( size_t ) quantum * image -> columns , scanline ) ; if ( count != 0 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) {  image = DestroyImageList ( image ) ;  return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( count != 0 ) ; scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }",scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ;image = DestroyImageList ( image ) ;return ( ( Image * ) NULL ) ;,285
401,"buggy line: if ( len < 0 || addr . nl_pid ) {syslog ( LOG_ERR , ""recvfrom<S2SV_blank>failed;incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer ;incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ) ;cwe id:CWE-000context: int main ( void ) { int fd , len , sock_opt ; int error ; struct cn_msg * message ; struct pollfd pfd ; struct nlmsghdr * incoming_msg ; struct cn_msg * incoming_cn_msg ; struct hv_kvp_msg * hv_msg ; char * p ; char * key_value ; char * key_name ; int op ; int pool ; char * if_name ; struct hv_kvp_ipaddr_value * kvp_ip_val ; daemon ( 1 , 0 ) ; openlog ( ""KVP"" , 0 , LOG_USER ) ; syslog ( LOG_INFO , ""KVP<S2SV_blank>starting;<S2SV_blank>pid<S2SV_blank>is:%d"" , getpid ( ) ) ; kvp_get_os_info ( ) ; if ( kvp_file_init ( ) ) { syslog ( LOG_ERR , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>the<S2SV_blank>pools"" ) ; exit ( EXIT_FAILURE ) ; } fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ) ; if ( fd < 0 ) { syslog ( LOG_ERR , ""netlink<S2SV_blank>socket<S2SV_blank>creation<S2SV_blank>failed;<S2SV_blank>error:%d"" , fd ) ; exit ( EXIT_FAILURE ) ; } addr . nl_family = AF_NETLINK ; addr . nl_pad = 0 ; addr . nl_pid = 0 ; addr . nl_groups = CN_KVP_IDX ; error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ) ; if ( error < 0 ) { syslog ( LOG_ERR , ""bind<S2SV_blank>failed;<S2SV_blank>error:%d"" , error ) ; close ( fd ) ; exit ( EXIT_FAILURE ) ; } sock_opt = addr . nl_groups ; setsockopt ( fd , 270 , 1 , & sock_opt , sizeof ( sock_opt ) ) ; message = ( struct cn_msg * ) kvp_send_buffer ; message -> id . idx = CN_KVP_IDX ; message -> id . val = CN_KVP_VAL ; hv_msg = ( struct hv_kvp_msg * ) message -> data ; hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1 ; message -> ack = 0 ; message -> len = sizeof ( struct hv_kvp_msg ) ; len = netlink_send ( fd , message ) ; if ( len < 0 ) { syslog ( LOG_ERR , ""netlink_send<S2SV_blank>failed;<S2SV_blank>error:%d"" , len ) ; close ( fd ) ; exit ( EXIT_FAILURE ) ; } pfd . fd = fd ; while ( 1 ) { struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; socklen_t addr_l = sizeof ( addr ) ; pfd . events = POLLIN ; pfd . revents = 0 ; poll ( & pfd , 1 , - 1 ) ; len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ) ;  if ( len < 0 || addr . nl_pid ) {  syslog ( LOG_ERR , ""recvfrom<S2SV_blank>failed;<S2SV_blank>pid:%u<S2SV_blank>error:%d<S2SV_blank>%s"" , addr . nl_pid , errno , strerror ( errno ) ) ; close ( fd ) ; return - 1 ; }  incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer ;  incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ) ; hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data ; op = hv_msg -> kvp_hdr . operation ; pool = hv_msg -> kvp_hdr . pool ; hv_msg -> error = HV_S_OK ; if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) ) { in_hand_shake = 0 ; p = ( char * ) hv_msg -> body . kvp_register . version ; lic_version = malloc ( strlen ( p ) + 1 ) ; if ( lic_version ) { strcpy ( lic_version , p ) ; syslog ( LOG_INFO , ""KVP<S2SV_blank>LIC<S2SV_blank>Version:<S2SV_blank>%s"" , lic_version ) ; } else { syslog ( LOG_ERR , ""malloc<S2SV_blank>failed"" ) ; } continue ; } switch ( op ) { case KVP_OP_GET_IP_INFO : kvp_ip_val = & hv_msg -> body . kvp_ip_val ; if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ) ; if ( if_name == NULL ) { hv_msg -> error = HV_E_FAIL ; break ; } error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ) ; if ( error ) hv_msg -> error = error ; free ( if_name ) ; break ; case KVP_OP_SET_IP_INFO : kvp_ip_val = & hv_msg -> body . kvp_ip_val ; if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ) ; if ( if_name == NULL ) { hv_msg -> error = HV_GUID_NOTFOUND ; break ; } error = kvp_set_ip_info ( if_name , kvp_ip_val ) ; if ( error ) hv_msg -> error = error ; free ( if_name ) ; break ; case KVP_OP_SET : if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) ) hv_msg -> error = HV_S_CONT ; break ; case KVP_OP_GET : if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) ) hv_msg -> error = HV_S_CONT ; break ; case KVP_OP_DELETE : if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) ) hv_msg -> error = HV_S_CONT ; break ; default : break ; } if ( op != KVP_OP_ENUMERATE ) goto kvp_done ; if ( pool != KVP_POOL_AUTO ) { if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) ) hv_msg -> error = HV_S_CONT ; goto kvp_done ; } hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data ; key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key ; key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value ; switch ( hv_msg -> body . kvp_enum_data . index ) { case FullyQualifiedDomainName : kvp_get_domain_name ( key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) ; strcpy ( key_name , ""FullyQualifiedDomainName"" ) ; break ; case IntegrationServicesVersion : strcpy ( key_name , ""IntegrationServicesVersion"" ) ; strcpy ( key_value , lic_version ) ; break ; case NetworkAddressIPv4 : kvp_get_ip_info ( AF_INET , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) ; strcpy ( key_name , ""NetworkAddressIPv4"" ) ; break ; case NetworkAddressIPv6 : kvp_get_ip_info ( AF_INET6 , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) ; strcpy ( key_name , ""NetworkAddressIPv6"" ) ; break ; case OSBuildNumber : strcpy ( key_value , os_build ) ; strcpy ( key_name , ""OSBuildNumber"" ) ; break ; case OSName : strcpy ( key_value , os_name ) ; strcpy ( key_name , ""OSName"" ) ; break ; case OSMajorVersion : strcpy ( key_value , os_major ) ; strcpy ( key_name , ""OSMajorVersion"" ) ; break ; case OSMinorVersion : strcpy ( key_value , os_minor ) ; strcpy ( key_name , ""OSMinorVersion"" ) ; break ; case OSVersion : strcpy ( key_value , os_version ) ; strcpy ( key_name , ""OSVersion"" ) ; break ; case ProcessorArchitecture : strcpy ( key_value , processor_arch ) ; strcpy ( key_name , ""ProcessorArchitecture"" ) ; break ; default : hv_msg -> error = HV_S_CONT ; break ; } kvp_done : incoming_cn_msg -> id . idx = CN_KVP_IDX ; incoming_cn_msg -> id . val = CN_KVP_VAL ; incoming_cn_msg -> ack = 0 ; incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ) ; len = netlink_send ( fd , incoming_cn_msg ) ; if ( len < 0 ) { syslog ( LOG_ERR , ""net_link<S2SV_blank>send<S2SV_blank>failed;<S2SV_blank>error:%d"" , len ) ; exit ( EXIT_FAILURE ) ; } } }","if ( len < 0 || addr . nl_pid ) {syslog ( LOG_ERR , ""recvfrom<S2SV_blank>failed;if ( addr . nl_pid ) {syslog ( LOG_WARNING , ""Received<S2SV_blank>packet<S2SV_blank>from<S2SV_blank>untrusted<S2SV_blank>pid:%u"" , addr . nl_pid ) ;continue ;}incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer ;incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ) ;",286
402,"buggy line: perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 ,  regs , address ) ;cwe id:CWE-400context: int handle_unaligned_access ( insn_size_t instruction , struct pt_regs * regs , struct mem_access * ma , int expected , unsigned long address ) { u_int rm ; int ret , index ; if ( instruction_size ( instruction ) != 2 ) return - EINVAL ; index = ( instruction >> 8 ) & 15 ; rm = regs -> regs [ index ] ; if ( ! expected ) { unaligned_fixups_notify ( current , instruction , regs ) ;  perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 ,  regs , address ) ; } ret = - EFAULT ; switch ( instruction & 0xF000 ) { case 0x0000 : if ( instruction == 0x000B ) { ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) regs -> pc = regs -> pr ; } else if ( ( instruction & 0x00FF ) == 0x0023 ) { ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) regs -> pc += rm + 4 ; } else if ( ( instruction & 0x00FF ) == 0x0003 ) { ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) { regs -> pr = regs -> pc + 4 ; regs -> pc += rm + 4 ; } } else { goto simple ; } break ; case 0x1000 : goto simple ; case 0x2000 : goto simple ; case 0x4000 : if ( ( instruction & 0x00FF ) == 0x002B ) { ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) regs -> pc = rm ; } else if ( ( instruction & 0x00FF ) == 0x000B ) { ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) { regs -> pr = regs -> pc + 4 ; regs -> pc = rm ; } } else { goto simple ; } break ; case 0x5000 : goto simple ; case 0x6000 : goto simple ; case 0x8000 : switch ( instruction & 0x0F00 ) { case 0x0100 : goto simple ; case 0x0500 : goto simple ; case 0x0B00 : break ; case 0x0F00 : ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) { # if defined ( CONFIG_CPU_SH4 ) || defined ( CONFIG_SH7705_CACHE_32KB ) if ( ( regs -> sr & 0x00000001 ) != 0 ) regs -> pc += 4 ; else # endif regs -> pc += SH_PC_8BIT_OFFSET ( instruction ) ; } break ; case 0x0900 : break ; case 0x0D00 : ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) { # if defined ( CONFIG_CPU_SH4 ) || defined ( CONFIG_SH7705_CACHE_32KB ) if ( ( regs -> sr & 0x00000001 ) == 0 ) regs -> pc += 4 ; else # endif regs -> pc += SH_PC_8BIT_OFFSET ( instruction ) ; } break ; } break ; case 0xA000 : ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) regs -> pc += SH_PC_12BIT_OFFSET ( instruction ) ; break ; case 0xB000 : ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) { regs -> pr = regs -> pc + 4 ; regs -> pc += SH_PC_12BIT_OFFSET ( instruction ) ; } break ; } return ret ; simple : ret = handle_unaligned_ins ( instruction , regs , ma ) ; if ( ret == 0 ) regs -> pc += instruction_size ( instruction ) ; return ret ; }","perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , regs , address ) ;",287
403,"buggy line: if ( client -> ipc == NULL ) {crm_warn ( ""Skipping<S2SV_blank>client<S2SV_blank>with<S2SV_blank>NULL<S2SV_blank>channel"" ) ;cwe id:CWE-399context: gboolean cib_notify_client ( gpointer key , gpointer value , gpointer user_data ) { const char * type = NULL ; gboolean do_send = FALSE ; cib_client_t * client = value ; xmlNode * update_msg = user_data ; CRM_CHECK ( client != NULL , return TRUE ) ; CRM_CHECK ( update_msg != NULL , return TRUE ) ;  if ( client -> ipc == NULL ) {  crm_warn ( ""Skipping<S2SV_blank>client<S2SV_blank>with<S2SV_blank>NULL<S2SV_blank>channel"" ) ; return FALSE ; } type = crm_element_value ( update_msg , F_SUBTYPE ) ; CRM_LOG_ASSERT ( type != NULL ) ; if ( client -> diffs && safe_str_eq ( type , T_CIB_DIFF_NOTIFY ) ) { do_send = TRUE ; } else if ( client -> replace && safe_str_eq ( type , T_CIB_REPLACE_NOTIFY ) ) { do_send = TRUE ; } else if ( client -> confirmations && safe_str_eq ( type , T_CIB_UPDATE_CONFIRM ) ) { do_send = TRUE ; } else if ( client -> pre_notify && safe_str_eq ( type , T_CIB_PRE_NOTIFY ) ) { do_send = TRUE ; } else if ( client -> post_notify && safe_str_eq ( type , T_CIB_POST_NOTIFY ) ) { do_send = TRUE ; } if ( do_send ) { if ( client -> ipc ) { if ( crm_ipcs_send ( client -> ipc , 0 , update_msg , TRUE ) == FALSE ) { crm_warn ( ""Notification<S2SV_blank>of<S2SV_blank>client<S2SV_blank>%s/%s<S2SV_blank>failed"" , client -> name , client -> id ) ; } # ifdef HAVE_GNUTLS_GNUTLS_H } else if ( client -> session ) { crm_debug ( ""Sent<S2SV_blank>%s<S2SV_blank>notification<S2SV_blank>to<S2SV_blank>client<S2SV_blank>%s/%s"" , type , client -> name , client -> id ) ; crm_send_remote_msg ( client -> session , update_msg , client -> encrypted ) ; # endif } else { crm_err ( ""Unknown<S2SV_blank>transport<S2SV_blank>for<S2SV_blank>%s"" , client -> name ) ; } } return FALSE ; }","if ( client -> ipc == NULL && client -> session == NULL ) {crm_warn ( ""Skipping<S2SV_blank>client<S2SV_blank>with<S2SV_blank>NULL<S2SV_blank>channel"" ) ;",288
404,"buggy line: if ( PyTuple_GET_SIZE ( tuple ) != 3 ) {PyMem_Free ( newData ) ;PyErr_SetString ( PyExc_TypeError , ""expecting<S2SV_blank>tuple<S2SV_blank>of<S2SV_blank>size<S2SV_blank>3"" ) ;return NULL ;}x = PyLong_AsLong ( PyTuple_GET_ITEM ( tuple , 0 ) ) ;y = PyLong_AsLong ( PyTuple_GET_ITEM ( tuple , 1 ) ) ;z = PyLong_AsLong ( PyTuple_GET_ITEM ( tuple , 2 ) ) ;if ( newpos + x > newDataLength ||  diffPtr + x > diffBlock + diffBlockLength ||  extraPtr + y > extraBlock + extraBlockLength ) {memcpy ( newData + newpos , diffPtr , x ) ;diffPtr += x ;cwe id:CWE-787context: static PyObject * patch ( PyObject * self , PyObject * args ) { char * origData , * newData , * diffBlock , * extraBlock , * diffPtr , * extraPtr ; Py_ssize_t origDataLength , newDataLength , diffBlockLength , extraBlockLength ; PyObject * controlTuples , * tuple , * results ; off_t oldpos , newpos , x , y , z ; int i , j , numTuples ; if ( ! PyArg_ParseTuple ( args , ""s#nO!s#s#"" , & origData , & origDataLength , & newDataLength , & PyList_Type , & controlTuples , & diffBlock , & diffBlockLength , & extraBlock , & extraBlockLength ) ) return NULL ; newData = PyMem_Malloc ( newDataLength + 1 ) ; if ( ! newData ) return PyErr_NoMemory ( ) ; oldpos = 0 ; newpos = 0 ; diffPtr = diffBlock ; extraPtr = extraBlock ; numTuples = PyList_GET_SIZE ( controlTuples ) ; for ( i = 0 ; i < numTuples ; i ++ ) { tuple = PyList_GET_ITEM ( controlTuples , i ) ; if ( ! PyTuple_Check ( tuple ) ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_TypeError , ""expecting<S2SV_blank>tuple"" ) ; return NULL ; } if ( PyTuple_GET_SIZE ( tuple ) != 3 ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_TypeError , ""expecting<S2SV_blank>tuple<S2SV_blank>of<S2SV_blank>size<S2SV_blank>3"" ) ; return NULL ; } x = PyLong_AsLong ( PyTuple_GET_ITEM ( tuple , 0 ) ) ; y = PyLong_AsLong ( PyTuple_GET_ITEM ( tuple , 1 ) ) ; z = PyLong_AsLong ( PyTuple_GET_ITEM ( tuple , 2 ) ) ; if ( newpos + x > newDataLength ||  diffPtr + x > diffBlock + diffBlockLength ||  extraPtr + y > extraBlock + extraBlockLength ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_ValueError , ""corrupt<S2SV_blank>patch<S2SV_blank>(overflow)"" ) ; return NULL ; }  memcpy ( newData + newpos , diffPtr , x ) ;  diffPtr += x ; for ( j = 0 ; j < x ; j ++ ) if ( ( oldpos + j >= 0 ) && ( oldpos + j < origDataLength ) ) newData [ newpos + j ] += origData [ oldpos + j ] ; newpos += x ; oldpos += x ; memcpy ( newData + newpos , extraPtr , y ) ; extraPtr += y ; newpos += y ; oldpos += z ; } if ( newpos != newDataLength || diffPtr != diffBlock + diffBlockLength || extraPtr != extraBlock + extraBlockLength ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_ValueError , ""corrupt<S2SV_blank>patch<S2SV_blank>(underflow)"" ) ; return NULL ; } results = PyBytes_FromStringAndSize ( newData , newDataLength ) ; PyMem_Free ( newData ) ; return results ; }","memcpy ( newData + newpos , diffPtr , x ) ;diffPtr += x ;for ( j = 0 ;j < x ;j ++ ) if ( ( oldpos + j >= 0 ) && ( oldpos + j < origDataLength ) ) newData [ newpos + j ] += origData [ oldpos + j ] ;newpos += x ;oldpos += x ;if ( newpos + y > newDataLength || extraPtr + y > extraBlock + extraBlockLength ) {memcpy ( newData + newpos , diffPtr , x ) ;diffPtr += x ;",289
405,"buggy line: flen = udf_get_filename ( dir -> i_sb , nameptr , fname , lfi ) ;if ( flen && udf_match ( flen , fname , child -> len , child -> name ) ) goto out_ok ;cwe id:CWE-17context: static struct fileIdentDesc * udf_find_entry ( struct inode * dir , const struct qstr * child , struct udf_fileident_bh * fibh , struct fileIdentDesc * cfi ) { struct fileIdentDesc * fi = NULL ; loff_t f_pos ; int block , flen ; unsigned char * fname = NULL ; unsigned char * nameptr ; uint8_t lfi ; uint16_t liu ; loff_t size ; struct kernel_lb_addr eloc ; uint32_t elen ; sector_t offset ; struct extent_position epos = { } ; struct udf_inode_info * dinfo = UDF_I ( dir ) ; int isdotdot = child -> len == 2 && child -> name [ 0 ] == '.' && child -> name [ 1 ] == '.' ; size = udf_ext0_offset ( dir ) + dir -> i_size ; f_pos = udf_ext0_offset ( dir ) ; fibh -> sbh = fibh -> ebh = NULL ; fibh -> soffset = fibh -> eoffset = f_pos & ( dir -> i_sb -> s_blocksize - 1 ) ; if ( dinfo -> i_alloc_type != ICBTAG_FLAG_AD_IN_ICB ) { if ( inode_bmap ( dir , f_pos >> dir -> i_sb -> s_blocksize_bits , & epos , & eloc , & elen , & offset ) != ( EXT_RECORDED_ALLOCATED >> 30 ) ) goto out_err ; block = udf_get_lb_pblock ( dir -> i_sb , & eloc , offset ) ; if ( ( ++ offset << dir -> i_sb -> s_blocksize_bits ) < elen ) { if ( dinfo -> i_alloc_type == ICBTAG_FLAG_AD_SHORT ) epos . offset -= sizeof ( struct short_ad ) ; else if ( dinfo -> i_alloc_type == ICBTAG_FLAG_AD_LONG ) epos . offset -= sizeof ( struct long_ad ) ; } else offset = 0 ; fibh -> sbh = fibh -> ebh = udf_tread ( dir -> i_sb , block ) ; if ( ! fibh -> sbh ) goto out_err ; } fname = kmalloc ( UDF_NAME_LEN , GFP_NOFS ) ; if ( ! fname ) goto out_err ; while ( f_pos < size ) { fi = udf_fileident_read ( dir , & f_pos , fibh , cfi , & epos , & eloc , & elen , & offset ) ; if ( ! fi ) goto out_err ; liu = le16_to_cpu ( cfi -> lengthOfImpUse ) ; lfi = cfi -> lengthFileIdent ; if ( fibh -> sbh == fibh -> ebh ) { nameptr = fi -> fileIdent + liu ; } else { int poffset ; poffset = fibh -> soffset + sizeof ( struct fileIdentDesc ) + liu + lfi ; if ( poffset >= lfi ) nameptr = ( uint8_t * ) ( fibh -> ebh -> b_data + poffset - lfi ) ; else { nameptr = fname ; memcpy ( nameptr , fi -> fileIdent + liu , lfi - poffset ) ; memcpy ( nameptr + lfi - poffset , fibh -> ebh -> b_data , poffset ) ; } } if ( ( cfi -> fileCharacteristics & FID_FILE_CHAR_DELETED ) != 0 ) { if ( ! UDF_QUERY_FLAG ( dir -> i_sb , UDF_FLAG_UNDELETE ) ) continue ; } if ( ( cfi -> fileCharacteristics & FID_FILE_CHAR_HIDDEN ) != 0 ) { if ( ! UDF_QUERY_FLAG ( dir -> i_sb , UDF_FLAG_UNHIDE ) ) continue ; } if ( ( cfi -> fileCharacteristics & FID_FILE_CHAR_PARENT ) && isdotdot ) goto out_ok ; if ( ! lfi ) continue ;  flen = udf_get_filename ( dir -> i_sb , nameptr , fname , lfi ) ;  if ( flen && udf_match ( flen , fname , child -> len , child -> name ) ) goto out_ok ; } out_err : fi = NULL ; if ( fibh -> sbh != fibh -> ebh ) brelse ( fibh -> ebh ) ; brelse ( fibh -> sbh ) ; out_ok : brelse ( epos . bh ) ; kfree ( fname ) ; return fi ; }","flen = udf_get_filename ( dir -> i_sb , nameptr , lfi , fname , UDF_NAME_LEN ) ;if ( flen && udf_match ( flen , fname , child -> len , child -> name ) ) goto out_ok ;",290
406,"buggy line: __ip_vs_get_timeouts ( net , & t ) ;if ( copy_to_user ( user , & t , sizeof ( t ) ) != 0 ) ret = - EFAULT ;cwe id:CWE-200context: static int do_ip_vs_get_ctl ( struct sock * sk , int cmd , void __user * user , int * len ) { unsigned char arg [ 128 ] ; int ret = 0 ; unsigned int copylen ; struct net * net = sock_net ( sk ) ; struct netns_ipvs * ipvs = net_ipvs ( net ) ; BUG_ON ( ! net ) ; if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; if ( cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_GET_MAX ) return - EINVAL ; if ( * len < get_arglen [ GET_CMDID ( cmd ) ] ) { pr_err ( ""get_ctl:<S2SV_blank>len<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%u\\n"" , * len , get_arglen [ GET_CMDID ( cmd ) ] ) ; return - EINVAL ; } copylen = get_arglen [ GET_CMDID ( cmd ) ] ; if ( copylen > 128 ) return - EINVAL ; if ( copy_from_user ( arg , user , copylen ) != 0 ) return - EFAULT ; if ( cmd == IP_VS_SO_GET_DAEMON ) { struct ip_vs_daemon_user d [ 2 ] ; memset ( & d , 0 , sizeof ( d ) ) ; if ( mutex_lock_interruptible ( & ipvs -> sync_mutex ) ) return - ERESTARTSYS ; if ( ipvs -> sync_state & IP_VS_STATE_MASTER ) { d [ 0 ] . state = IP_VS_STATE_MASTER ; strlcpy ( d [ 0 ] . mcast_ifn , ipvs -> master_mcast_ifn , sizeof ( d [ 0 ] . mcast_ifn ) ) ; d [ 0 ] . syncid = ipvs -> master_syncid ; } if ( ipvs -> sync_state & IP_VS_STATE_BACKUP ) { d [ 1 ] . state = IP_VS_STATE_BACKUP ; strlcpy ( d [ 1 ] . mcast_ifn , ipvs -> backup_mcast_ifn , sizeof ( d [ 1 ] . mcast_ifn ) ) ; d [ 1 ] . syncid = ipvs -> backup_syncid ; } if ( copy_to_user ( user , & d , sizeof ( d ) ) != 0 ) ret = - EFAULT ; mutex_unlock ( & ipvs -> sync_mutex ) ; return ret ; } if ( mutex_lock_interruptible ( & __ip_vs_mutex ) ) return - ERESTARTSYS ; switch ( cmd ) { case IP_VS_SO_GET_VERSION : { char buf [ 64 ] ; sprintf ( buf , ""IP<S2SV_blank>Virtual<S2SV_blank>Server<S2SV_blank>version<S2SV_blank>%d.%d.%d<S2SV_blank>(size=%d)"" , NVERSION ( IP_VS_VERSION_CODE ) , ip_vs_conn_tab_size ) ; if ( copy_to_user ( user , buf , strlen ( buf ) + 1 ) != 0 ) { ret = - EFAULT ; goto out ; } * len = strlen ( buf ) + 1 ; } break ; case IP_VS_SO_GET_INFO : { struct ip_vs_getinfo info ; info . version = IP_VS_VERSION_CODE ; info . size = ip_vs_conn_tab_size ; info . num_services = ipvs -> num_services ; if ( copy_to_user ( user , & info , sizeof ( info ) ) != 0 ) ret = - EFAULT ; } break ; case IP_VS_SO_GET_SERVICES : { struct ip_vs_get_services * get ; int size ; get = ( struct ip_vs_get_services * ) arg ; size = sizeof ( * get ) + sizeof ( struct ip_vs_service_entry ) * get -> num_services ; if ( * len != size ) { pr_err ( ""length:<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u\\n"" , * len , size ) ; ret = - EINVAL ; goto out ; } ret = __ip_vs_get_service_entries ( net , get , user ) ; } break ; case IP_VS_SO_GET_SERVICE : { struct ip_vs_service_entry * entry ; struct ip_vs_service * svc ; union nf_inet_addr addr ; entry = ( struct ip_vs_service_entry * ) arg ; addr . ip = entry -> addr ; if ( entry -> fwmark ) svc = __ip_vs_svc_fwm_find ( net , AF_INET , entry -> fwmark ) ; else svc = __ip_vs_service_find ( net , AF_INET , entry -> protocol , & addr , entry -> port ) ; if ( svc ) { ip_vs_copy_service ( entry , svc ) ; if ( copy_to_user ( user , entry , sizeof ( * entry ) ) != 0 ) ret = - EFAULT ; } else ret = - ESRCH ; } break ; case IP_VS_SO_GET_DESTS : { struct ip_vs_get_dests * get ; int size ; get = ( struct ip_vs_get_dests * ) arg ; size = sizeof ( * get ) + sizeof ( struct ip_vs_dest_entry ) * get -> num_dests ; if ( * len != size ) { pr_err ( ""length:<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u\\n"" , * len , size ) ; ret = - EINVAL ; goto out ; } ret = __ip_vs_get_dest_entries ( net , get , user ) ; } break ; case IP_VS_SO_GET_TIMEOUT : { struct ip_vs_timeout_user t ;  __ip_vs_get_timeouts ( net , & t ) ;  if ( copy_to_user ( user , & t , sizeof ( t ) ) != 0 ) ret = - EFAULT ; } break ; default : ret = - EINVAL ; } out : mutex_unlock ( & __ip_vs_mutex ) ; return ret ; }","memset ( & t , 0 , sizeof ( t ) ) ;__ip_vs_get_timeouts ( net , & t ) ;if ( copy_to_user ( user , & t , sizeof ( t ) ) != 0 ) ret = - EFAULT ;",291
407,"buggy line: if ( ! dst && ( dst = inet6_csk_route_req ( sk , fl6 , req , IPPROTO_TCP ) ) == NULL ) goto done ;err = ip6_xmit ( sk , skb , fl6 , np -> opt , np -> tclass ) ;err = net_xmit_eval ( err ) ;cwe id:CWE-264context: static int tcp_v6_send_synack ( const struct sock * sk , struct dst_entry * dst , struct flowi * fl , struct request_sock * req , struct tcp_fastopen_cookie * foc , bool attach_req ) { struct inet_request_sock * ireq = inet_rsk ( req ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct flowi6 * fl6 = & fl -> u . ip6 ; struct sk_buff * skb ; int err = - ENOMEM ; if ( ! dst && ( dst = inet6_csk_route_req ( sk , fl6 , req , IPPROTO_TCP ) ) == NULL ) goto done ; skb = tcp_make_synack ( sk , dst , req , foc , attach_req ) ; if ( skb ) { __tcp_v6_send_check ( skb , & ireq -> ir_v6_loc_addr , & ireq -> ir_v6_rmt_addr ) ; fl6 -> daddr = ireq -> ir_v6_rmt_addr ; if ( np -> repflow && ireq -> pktopts ) fl6 -> flowlabel = ip6_flowlabel ( ipv6_hdr ( ireq -> pktopts ) ) ;  err = ip6_xmit ( sk , skb , fl6 , np -> opt , np -> tclass ) ;  err = net_xmit_eval ( err ) ; } done : return err ; }","if ( ! dst && ( dst = inet6_csk_route_req ( sk , fl6 , rcu_dereference ( req , IPPROTO_TCP ) ) == NULL ) goto done ;err = ip6_xmit ( sk , skb , fl6 , np -> opt ) , np -> tclass ) ;err = net_xmit_eval ( err ) ;",292
408,"buggy line: ssize_t result ;if ( len < sizeof ( hdr ) ) return - EINVAL ;cwe id:CWE-264context: static ssize_t ib_ucm_write ( struct file * filp , const char __user * buf , size_t len , loff_t * pos ) { struct ib_ucm_file * file = filp -> private_data ; struct ib_ucm_cmd_hdr hdr ;  ssize_t result ;  if ( len < sizeof ( hdr ) ) return - EINVAL ; if ( copy_from_user ( & hdr , buf , sizeof ( hdr ) ) ) return - EFAULT ; if ( hdr . cmd >= ARRAY_SIZE ( ucm_cmd_table ) ) return - EINVAL ; if ( hdr . in + sizeof ( hdr ) > len ) return - EINVAL ; result = ucm_cmd_table [ hdr . cmd ] ( file , buf + sizeof ( hdr ) , hdr . in , hdr . out ) ; if ( ! result ) result = len ; return result ; }",ssize_t result ;if ( WARN_ON_ONCE ( ! ib_safe_file_access ( filp ) ) ) return - EACCES ;if ( len < sizeof ( hdr ) ) return - EINVAL ;,293
409,"buggy line: char * fpath = NULL , * path1 , * cgdir = NULL , * controller ;const char * cgroup ;if ( ! fc ) return - EIO ;controller = pick_controller_from_path ( fc , path ) ;if ( ! controller ) return - EINVAL ;cgroup = find_cgroup_in_path ( path ) ;if ( ! cgroup ) return - EINVAL ;get_cgdir_and_path ( cgroup , & cgdir , & fpath ) ;if ( ! fpath ) path1 = ""/"" ;else path1 = cgdir ;if ( ! fc_may_access ( fc , controller , path1 , NULL , O_RDWR ) ) {ret = - EACCES ;goto out ;if ( ! caller_is_in_ancestor ( fc -> pid , controller , path1 , NULL ) ) {ret = - EACCES ;return ret ;}cwe id:CWE-264context: int cg_mkdir ( const char * path , mode_t mode ) { struct fuse_context * fc = fuse_get_context ( ) ;  char * fpath = NULL , * path1 , * cgdir = NULL , * controller ;  const char * cgroup ; int ret ; if ( ! fc ) return - EIO ; controller = pick_controller_from_path ( fc , path ) ; if ( ! controller ) return - EINVAL ; cgroup = find_cgroup_in_path ( path ) ; if ( ! cgroup ) return - EINVAL ; get_cgdir_and_path ( cgroup , & cgdir , & fpath ) ; if ( ! fpath ) path1 = ""/"" ; else path1 = cgdir ;  if ( ! fc_may_access ( fc , controller , path1 , NULL , O_RDWR ) ) {   ret = - EACCES ;  goto out ; }  if ( ! caller_is_in_ancestor ( fc -> pid , controller , path1 , NULL ) ) {  ret = - EACCES ; goto out ; } ret = cgfs_create ( controller , cgroup , fc -> uid , fc -> gid ) ; printf ( ""cgfs_create<S2SV_blank>returned<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>%s\\n"" , ret , controller , cgroup ) ; out : free ( cgdir ) ;  return ret ;  }","char * fpath = NULL , * path1 , * cgdir = NULL , * controller , * next = NULL ;const char * cgroup ;if ( ! caller_is_in_ancestor ( fc -> pid , controller , path1 , & next ) ) {ret = - EACCES ;goto out ;}if ( ! fc_may_access ( fc , controller , path1 , NULL , O_RDWR ) ) {ret = - EACCES ;goto out ;if ( ! caller_is_in_ancestor ( fc -> pid , controller , path1 , NULL ) ) {ret = - EACCES ;free ( next ) ;return ret ;}",294
410,"buggy line: disk -> queue = NULL ;continue ;cwe id:CWE-476context: static void pcd_init_units ( void ) { struct pcd_unit * cd ; int unit ; pcd_drive_count = 0 ; for ( unit = 0 , cd = pcd ; unit < PCD_UNITS ; unit ++ , cd ++ ) { struct gendisk * disk = alloc_disk ( 1 ) ; if ( ! disk ) continue ; disk -> queue = blk_mq_init_sq_queue ( & cd -> tag_set , & pcd_mq_ops , 1 , BLK_MQ_F_SHOULD_MERGE ) ; if ( IS_ERR ( disk -> queue ) ) {  disk -> queue = NULL ;  continue ; } INIT_LIST_HEAD ( & cd -> rq_list ) ; disk -> queue -> queuedata = cd ; blk_queue_bounce_limit ( disk -> queue , BLK_BOUNCE_HIGH ) ; cd -> disk = disk ; cd -> pi = & cd -> pia ; cd -> present = 0 ; cd -> last_sense = 0 ; cd -> changed = 1 ; cd -> drive = ( * drives [ unit ] ) [ D_SLV ] ; if ( ( * drives [ unit ] ) [ D_PRT ] ) pcd_drive_count ++ ; cd -> name = & cd -> info . name [ 0 ] ; snprintf ( cd -> name , sizeof ( cd -> info . name ) , ""%s%d"" , name , unit ) ; cd -> info . ops = & pcd_dops ; cd -> info . handle = cd ; cd -> info . speed = 0 ; cd -> info . capacity = 1 ; cd -> info . mask = 0 ; disk -> major = major ; disk -> first_minor = unit ; strcpy ( disk -> disk_name , cd -> name ) ; disk -> fops = & pcd_bdops ; disk -> flags = GENHD_FL_BLOCK_EVENTS_ON_EXCL_WRITE ; } }",put_disk ( disk ) ;disk -> queue = NULL ;continue ;,295
411,"buggy line: void ntlm_write_message_header ( wStream * s , NTLM_MESSAGE_HEADER * header )  {cwe id:CWE-125context:  void ntlm_write_message_header ( wStream * s , NTLM_MESSAGE_HEADER * header )  { Stream_Write ( s , header -> Signature , sizeof ( NTLM_SIGNATURE ) ) ; Stream_Write_UINT32 ( s , header -> MessageType ) ; }","static void ntlm_write_message_header ( wStream * s , NTLM_MESSAGE_HEADER * header ) {",296
412,"buggy line: if ( ( count != 1 ) || ( ( unsigned char ) viff_info . identifier != 0xab ) ) ThrowReaderException ( CorruptImageError , ""NotAVIFFImage"" ) ;( void ) ReadBlob ( image , sizeof ( viff_info . file_type ) , & viff_info . file_type ) ;( void ) ReadBlob ( image , sizeof ( viff_info . release ) , & viff_info . release ) ;( void ) ReadBlob ( image , sizeof ( viff_info . version ) , & viff_info . version ) ;( void ) ReadBlob ( image , sizeof ( viff_info . machine_dependency ) , & viff_info . machine_dependency ) ;( void ) ReadBlob ( image , sizeof ( viff_info . reserve ) , viff_info . reserve ) ;count = ReadBlob ( image , 512 , ( unsigned char * ) viff_info . comment ) ;viff_info . comment [ 511 ] = \'\\\\0\' ;if ( strlen ( viff_info . comment ) > 4 ) ( void ) SetImageProperty ( image , ""comment"" , viff_info . comment , exception ) ;if ( ( viff_info . machine_dependency == VFF_DEP_DECORDER ) || ( viff_info . machine_dependency == VFF_DEP_NSORDER ) ) image -> endian = LSBEndian ;else image -> endian = MSBEndian ;viff_info . rows = ReadBlobLong ( image ) ;viff_info . columns = ReadBlobLong ( image ) ;viff_info . subrows = ReadBlobLong ( image ) ;viff_info . x_offset = ReadBlobSignedLong ( image ) ;viff_info . y_offset = ReadBlobSignedLong ( image ) ;viff_info . x_bits_per_pixel = ( float ) ReadBlobLong ( image ) ;viff_info . y_bits_per_pixel = ( float ) ReadBlobLong ( image ) ;viff_info . location_type = ReadBlobLong ( image ) ;viff_info . location_dimension = ReadBlobLong ( image ) ;viff_info . number_of_images = ReadBlobLong ( image ) ;viff_info . number_data_bands = ReadBlobLong ( image ) ;viff_info . data_storage_type = ReadBlobLong ( image ) ;viff_info . data_encode_scheme = ReadBlobLong ( image ) ;viff_info . map_scheme = ReadBlobLong ( image ) ;viff_info . map_storage_type = ReadBlobLong ( image ) ;viff_info . map_rows = ReadBlobLong ( image ) ;viff_info . map_columns = ReadBlobLong ( image ) ;viff_info . map_subrows = ReadBlobLong ( image ) ;viff_info . map_enable = ReadBlobLong ( image ) ;viff_info . maps_per_cycle = ReadBlobLong ( image ) ;viff_info . color_space_model = ReadBlobLong ( image ) ;for ( i = 0 ;i < 420 ;i ++ ) ( void ) ReadBlobByte ( image ) ;if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;image -> columns = viff_info . rows ;image -> rows = viff_info . columns ;image -> depth = viff_info . x_bits_per_pixel <= 8 ? 8UL : MAGICKCORE_QUANTUM_DEPTH ;number_pixels = ( MagickSizeType ) viff_info . columns * viff_info . rows ;if ( number_pixels != ( size_t ) number_pixels ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( number_pixels == 0 ) ThrowReaderException ( CoderError , ""ImageColumnOrRowSizeIsNotSupported"" ) ;if ( ( viff_info . number_data_bands < 1 ) || ( viff_info . number_data_bands > 4 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;if ( ( viff_info . data_storage_type != VFF_TYP_BIT ) && ( viff_info . data_storage_type != VFF_TYP_1_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_2_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_4_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_FLOAT ) && ( viff_info . data_storage_type != VFF_TYP_DOUBLE ) ) ThrowReaderException ( CoderError , ""DataStorageTypeIsNotSupported"" ) ;if ( viff_info . data_encode_scheme != VFF_DES_RAW ) ThrowReaderException ( CoderError , ""DataEncodingSchemeIsNotSupported"" ) ;if ( ( viff_info . map_storage_type != VFF_MAPTYP_NONE ) && ( viff_info . map_storage_type != VFF_MAPTYP_1_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_2_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_4_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_FLOAT ) && ( viff_info . map_storage_type != VFF_MAPTYP_DOUBLE ) ) ThrowReaderException ( CoderError , ""MapStorageTypeIsNotSupported"" ) ;if ( ( viff_info . color_space_model != VFF_CM_NONE ) && ( viff_info . color_space_model != VFF_CM_ntscRGB ) && ( viff_info . color_space_model != VFF_CM_genericRGB ) ) ThrowReaderException ( CoderError , ""ColorspaceModelIsNotSupported"" ) ;if ( viff_info . location_type != VFF_LOC_IMPLICIT ) ThrowReaderException ( CoderError , ""LocationTypeIsNotSupported"" ) ;if ( viff_info . number_of_images != 1 ) ThrowReaderException ( CoderError , ""NumberOfImagesIsNotSupported"" ) ;if ( viff_info . map_rows == 0 ) viff_info . map_scheme = VFF_MS_NONE ;switch ( ( int ) viff_info . map_scheme ) {case VFF_MS_NONE : {if ( viff_info . number_data_bands < 3 ) {if ( viff_info . data_storage_type == VFF_TYP_BIT ) image -> colors = 2 ;else if ( viff_info . data_storage_type == VFF_MAPTYP_1_BYTE ) image -> colors = 256UL ;else image -> colors = image -> depth <= 8 ? 256UL : 65536UL ;status = AcquireImageColormap ( image , image -> colors , exception ) ;if ( status == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;}break ;}case VFF_MS_ONEPERBAND : case VFF_MS_SHARED : {unsigned char * viff_colormap ;switch ( ( int ) viff_info . map_storage_type ) {case VFF_MAPTYP_1_BYTE : bytes_per_pixel = 1 ;break ;case VFF_MAPTYP_2_BYTE : bytes_per_pixel = 2 ;break ;case VFF_MAPTYP_4_BYTE : bytes_per_pixel = 4 ;break ;case VFF_MAPTYP_FLOAT : bytes_per_pixel = 4 ;break ;case VFF_MAPTYP_DOUBLE : bytes_per_pixel = 8 ;break ;default : bytes_per_pixel = 1 ;break ;}image -> colors = viff_info . map_columns ;if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( viff_info . map_rows > ( viff_info . map_rows * bytes_per_pixel * sizeof ( * viff_colormap ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;viff_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , viff_info . map_rows * bytes_per_pixel * sizeof ( * viff_colormap ) ) ;if ( viff_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;count = ReadBlob ( image , bytes_per_pixel * image -> colors * viff_info . map_rows , viff_colormap ) ;lsb_first = 1 ;if ( * ( char * ) & lsb_first && ( ( viff_info . machine_dependency != VFF_DEP_DECORDER ) && ( viff_info . machine_dependency != VFF_DEP_NSORDER ) ) ) switch ( ( int ) viff_info . map_storage_type ) {case VFF_MAPTYP_2_BYTE : {MSBOrderShort ( viff_colormap , ( bytes_per_pixel * image -> colors * viff_info . map_rows ) ) ;break ;}case VFF_MAPTYP_4_BYTE : case VFF_MAPTYP_FLOAT : {MSBOrderLong ( viff_colormap , ( bytes_per_pixel * image -> colors * viff_info . map_rows ) ) ;break ;}default : break ;}for ( i = 0 ;i < ( ssize_t ) ( viff_info . map_rows * image -> colors ) ;i ++ ) {switch ( ( int ) viff_info . map_storage_type ) {case VFF_MAPTYP_2_BYTE : value = 1.0 * ( ( short * ) viff_colormap ) [ i ] ;break ;case VFF_MAPTYP_4_BYTE : value = 1.0 * ( ( int * ) viff_colormap ) [ i ] ;break ;case VFF_MAPTYP_FLOAT : value = ( ( float * ) viff_colormap ) [ i ] ;break ;case VFF_MAPTYP_DOUBLE : value = ( ( double * ) viff_colormap ) [ i ] ;break ;default : value = 1.0 * viff_colormap [ i ] ;break ;}if ( i < ( ssize_t ) image -> colors ) {image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) value ) ;image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) value ) ;image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) value ) ;}else if ( i < ( ssize_t ) ( 2 * image -> colors ) ) image -> colormap [ i % image -> colors ] . green = ScaleCharToQuantum ( ( unsigned char ) value ) ;else if ( i < ( ssize_t ) ( 3 * image -> colors ) ) image -> colormap [ i % image -> colors ] . blue = ScaleCharToQuantum ( ( unsigned char ) value ) ;}viff_colormap = ( unsigned char * ) RelinquishMagickMemory ( viff_colormap ) ;break ;}default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ;}image -> alpha_trait = viff_info . number_data_bands == 4 ? BlendPixelTrait : UndefinedPixelTrait ;image -> storage_class = ( viff_info . number_data_bands < 3 ? PseudoClass : DirectClass ) ;image -> columns = viff_info . rows ;image -> rows = viff_info . columns ;if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;switch ( ( int ) viff_info . data_storage_type ) {case VFF_TYP_2_BYTE : bytes_per_pixel = 2 ;break ;case VFF_TYP_4_BYTE : bytes_per_pixel = 4 ;break ;case VFF_TYP_FLOAT : bytes_per_pixel = 4 ;break ;case VFF_TYP_DOUBLE : bytes_per_pixel = 8 ;break ;default : bytes_per_pixel = 1 ;break ;}if ( viff_info . data_storage_type == VFF_TYP_BIT ) {if ( CheckMemoryOverflow ( ( image -> columns + 7UL ) >> 3UL , image -> rows ) != MagickFalse )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( CheckMemoryOverflow ( number_pixels , viff_info . number_data_bands ) != MagickFalse )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;cwe id:CWE-120context: static Image * ReadVIFFImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define VFF_CM_genericRGB 15 # define VFF_CM_ntscRGB 1 # define VFF_CM_NONE 0 # define VFF_DEP_DECORDER 0x4 # define VFF_DEP_NSORDER 0x8 # define VFF_DES_RAW 0 # define VFF_LOC_IMPLICIT 1 # define VFF_MAPTYP_NONE 0 # define VFF_MAPTYP_1_BYTE 1 # define VFF_MAPTYP_2_BYTE 2 # define VFF_MAPTYP_4_BYTE 4 # define VFF_MAPTYP_FLOAT 5 # define VFF_MAPTYP_DOUBLE 7 # define VFF_MS_NONE 0 # define VFF_MS_ONEPERBAND 1 # define VFF_MS_SHARED 3 # define VFF_TYP_BIT 0 # define VFF_TYP_1_BYTE 1 # define VFF_TYP_2_BYTE 2 # define VFF_TYP_4_BYTE 4 # define VFF_TYP_FLOAT 5 # define VFF_TYP_DOUBLE 9 typedef struct _ViffInfo { unsigned char identifier , file_type , release , version , machine_dependency , reserve [ 3 ] ; char comment [ 512 ] ; unsigned int rows , columns , subrows ; int x_offset , y_offset ; float x_bits_per_pixel , y_bits_per_pixel ; unsigned int location_type , location_dimension , number_of_images , number_data_bands , data_storage_type , data_encode_scheme , map_scheme , map_storage_type , map_rows , map_columns , map_subrows , map_enable , maps_per_cycle , color_space_model ; } ViffInfo ; double min_value , scale_factor , value ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register ssize_t x ; register Quantum * q ; register ssize_t i ; register unsigned char * p ; size_t bytes_per_pixel , max_packets , quantum ; ssize_t count , y ; unsigned char * pixels ; unsigned long lsb_first ; ViffInfo viff_info ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } count = ReadBlob ( image , 1 , & viff_info . identifier ) ; do { if ( ( count != 1 ) || ( ( unsigned char ) viff_info . identifier != 0xab ) ) ThrowReaderException ( CorruptImageError , ""NotAVIFFImage"" ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . file_type ) , & viff_info . file_type ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . release ) , & viff_info . release ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . version ) , & viff_info . version ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . machine_dependency ) , & viff_info . machine_dependency ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . reserve ) , viff_info . reserve ) ; count = ReadBlob ( image , 512 , ( unsigned char * ) viff_info . comment ) ; viff_info . comment [ 511 ] = '\\0' ; if ( strlen ( viff_info . comment ) > 4 ) ( void ) SetImageProperty ( image , ""comment"" , viff_info . comment , exception ) ; if ( ( viff_info . machine_dependency == VFF_DEP_DECORDER ) || ( viff_info . machine_dependency == VFF_DEP_NSORDER ) ) image -> endian = LSBEndian ; else image -> endian = MSBEndian ; viff_info . rows = ReadBlobLong ( image ) ; viff_info . columns = ReadBlobLong ( image ) ; viff_info . subrows = ReadBlobLong ( image ) ; viff_info . x_offset = ReadBlobSignedLong ( image ) ; viff_info . y_offset = ReadBlobSignedLong ( image ) ; viff_info . x_bits_per_pixel = ( float ) ReadBlobLong ( image ) ; viff_info . y_bits_per_pixel = ( float ) ReadBlobLong ( image ) ; viff_info . location_type = ReadBlobLong ( image ) ; viff_info . location_dimension = ReadBlobLong ( image ) ; viff_info . number_of_images = ReadBlobLong ( image ) ; viff_info . number_data_bands = ReadBlobLong ( image ) ; viff_info . data_storage_type = ReadBlobLong ( image ) ; viff_info . data_encode_scheme = ReadBlobLong ( image ) ; viff_info . map_scheme = ReadBlobLong ( image ) ; viff_info . map_storage_type = ReadBlobLong ( image ) ; viff_info . map_rows = ReadBlobLong ( image ) ; viff_info . map_columns = ReadBlobLong ( image ) ; viff_info . map_subrows = ReadBlobLong ( image ) ; viff_info . map_enable = ReadBlobLong ( image ) ; viff_info . maps_per_cycle = ReadBlobLong ( image ) ; viff_info . color_space_model = ReadBlobLong ( image ) ; for ( i = 0 ; i < 420 ; i ++ ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; image -> columns = viff_info . rows ; image -> rows = viff_info . columns ; image -> depth = viff_info . x_bits_per_pixel <= 8 ? 8UL : MAGICKCORE_QUANTUM_DEPTH ; number_pixels = ( MagickSizeType ) viff_info . columns * viff_info . rows ; if ( number_pixels != ( size_t ) number_pixels ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( number_pixels == 0 ) ThrowReaderException ( CoderError , ""ImageColumnOrRowSizeIsNotSupported"" ) ; if ( ( viff_info . number_data_bands < 1 ) || ( viff_info . number_data_bands > 4 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( viff_info . data_storage_type != VFF_TYP_BIT ) && ( viff_info . data_storage_type != VFF_TYP_1_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_2_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_4_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_FLOAT ) && ( viff_info . data_storage_type != VFF_TYP_DOUBLE ) ) ThrowReaderException ( CoderError , ""DataStorageTypeIsNotSupported"" ) ; if ( viff_info . data_encode_scheme != VFF_DES_RAW ) ThrowReaderException ( CoderError , ""DataEncodingSchemeIsNotSupported"" ) ; if ( ( viff_info . map_storage_type != VFF_MAPTYP_NONE ) && ( viff_info . map_storage_type != VFF_MAPTYP_1_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_2_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_4_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_FLOAT ) && ( viff_info . map_storage_type != VFF_MAPTYP_DOUBLE ) ) ThrowReaderException ( CoderError , ""MapStorageTypeIsNotSupported"" ) ; if ( ( viff_info . color_space_model != VFF_CM_NONE ) && ( viff_info . color_space_model != VFF_CM_ntscRGB ) && ( viff_info . color_space_model != VFF_CM_genericRGB ) ) ThrowReaderException ( CoderError , ""ColorspaceModelIsNotSupported"" ) ; if ( viff_info . location_type != VFF_LOC_IMPLICIT ) ThrowReaderException ( CoderError , ""LocationTypeIsNotSupported"" ) ; if ( viff_info . number_of_images != 1 ) ThrowReaderException ( CoderError , ""NumberOfImagesIsNotSupported"" ) ; if ( viff_info . map_rows == 0 ) viff_info . map_scheme = VFF_MS_NONE ; switch ( ( int ) viff_info . map_scheme ) { case VFF_MS_NONE : { if ( viff_info . number_data_bands < 3 ) { if ( viff_info . data_storage_type == VFF_TYP_BIT ) image -> colors = 2 ; else if ( viff_info . data_storage_type == VFF_MAPTYP_1_BYTE ) image -> colors = 256UL ; else image -> colors = image -> depth <= 8 ? 256UL : 65536UL ; status = AcquireImageColormap ( image , image -> colors , exception ) ; if ( status == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } break ; } case VFF_MS_ONEPERBAND : case VFF_MS_SHARED : { unsigned char * viff_colormap ; switch ( ( int ) viff_info . map_storage_type ) { case VFF_MAPTYP_1_BYTE : bytes_per_pixel = 1 ; break ; case VFF_MAPTYP_2_BYTE : bytes_per_pixel = 2 ; break ; case VFF_MAPTYP_4_BYTE : bytes_per_pixel = 4 ; break ; case VFF_MAPTYP_FLOAT : bytes_per_pixel = 4 ; break ; case VFF_MAPTYP_DOUBLE : bytes_per_pixel = 8 ; break ; default : bytes_per_pixel = 1 ; break ; } image -> colors = viff_info . map_columns ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( viff_info . map_rows > ( viff_info . map_rows * bytes_per_pixel * sizeof ( * viff_colormap ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; viff_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , viff_info . map_rows * bytes_per_pixel * sizeof ( * viff_colormap ) ) ; if ( viff_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , bytes_per_pixel * image -> colors * viff_info . map_rows , viff_colormap ) ; lsb_first = 1 ; if ( * ( char * ) & lsb_first && ( ( viff_info . machine_dependency != VFF_DEP_DECORDER ) && ( viff_info . machine_dependency != VFF_DEP_NSORDER ) ) ) switch ( ( int ) viff_info . map_storage_type ) { case VFF_MAPTYP_2_BYTE : { MSBOrderShort ( viff_colormap , ( bytes_per_pixel * image -> colors * viff_info . map_rows ) ) ; break ; } case VFF_MAPTYP_4_BYTE : case VFF_MAPTYP_FLOAT : { MSBOrderLong ( viff_colormap , ( bytes_per_pixel * image -> colors * viff_info . map_rows ) ) ; break ; } default : break ; } for ( i = 0 ; i < ( ssize_t ) ( viff_info . map_rows * image -> colors ) ; i ++ ) { switch ( ( int ) viff_info . map_storage_type ) { case VFF_MAPTYP_2_BYTE : value = 1.0 * ( ( short * ) viff_colormap ) [ i ] ; break ; case VFF_MAPTYP_4_BYTE : value = 1.0 * ( ( int * ) viff_colormap ) [ i ] ; break ; case VFF_MAPTYP_FLOAT : value = ( ( float * ) viff_colormap ) [ i ] ; break ; case VFF_MAPTYP_DOUBLE : value = ( ( double * ) viff_colormap ) [ i ] ; break ; default : value = 1.0 * viff_colormap [ i ] ; break ; } if ( i < ( ssize_t ) image -> colors ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) value ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) value ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) value ) ; } else if ( i < ( ssize_t ) ( 2 * image -> colors ) ) image -> colormap [ i % image -> colors ] . green = ScaleCharToQuantum ( ( unsigned char ) value ) ; else if ( i < ( ssize_t ) ( 3 * image -> colors ) ) image -> colormap [ i % image -> colors ] . blue = ScaleCharToQuantum ( ( unsigned char ) value ) ; } viff_colormap = ( unsigned char * ) RelinquishMagickMemory ( viff_colormap ) ; break ; } default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; } image -> alpha_trait = viff_info . number_data_bands == 4 ? BlendPixelTrait : UndefinedPixelTrait ; image -> storage_class = ( viff_info . number_data_bands < 3 ? PseudoClass : DirectClass ) ; image -> columns = viff_info . rows ; image -> rows = viff_info . columns ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : bytes_per_pixel = 2 ; break ; case VFF_TYP_4_BYTE : bytes_per_pixel = 4 ; break ; case VFF_TYP_FLOAT : bytes_per_pixel = 4 ; break ; case VFF_TYP_DOUBLE : bytes_per_pixel = 8 ; break ; default : bytes_per_pixel = 1 ; break ; } if ( viff_info . data_storage_type == VFF_TYP_BIT ) {  if ( CheckMemoryOverflow ( ( image -> columns + 7UL ) >> 3UL , image -> rows ) != MagickFalse )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; max_packets = ( ( image -> columns + 7UL ) >> 3UL ) * image -> rows ; } else {  if ( CheckMemoryOverflow ( number_pixels , viff_info . number_data_bands ) != MagickFalse )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; max_packets = ( size_t ) ( number_pixels * viff_info . number_data_bands ) ; } pixels = ( unsigned char * ) AcquireQuantumMemory ( MagickMax ( number_pixels , max_packets ) , bytes_per_pixel * sizeof ( * pixels ) ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , bytes_per_pixel * max_packets , pixels ) ; lsb_first = 1 ; if ( * ( char * ) & lsb_first && ( ( viff_info . machine_dependency != VFF_DEP_DECORDER ) && ( viff_info . machine_dependency != VFF_DEP_NSORDER ) ) ) switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : { MSBOrderShort ( pixels , bytes_per_pixel * max_packets ) ; break ; } case VFF_TYP_4_BYTE : case VFF_TYP_FLOAT : { MSBOrderLong ( pixels , bytes_per_pixel * max_packets ) ; break ; } default : break ; } min_value = 0.0 ; scale_factor = 1.0 ; if ( ( viff_info . data_storage_type != VFF_TYP_1_BYTE ) && ( viff_info . map_scheme == VFF_MS_NONE ) ) { double max_value ; switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : value = 1.0 * ( ( short * ) pixels ) [ 0 ] ; break ; case VFF_TYP_4_BYTE : value = 1.0 * ( ( int * ) pixels ) [ 0 ] ; break ; case VFF_TYP_FLOAT : value = ( ( float * ) pixels ) [ 0 ] ; break ; case VFF_TYP_DOUBLE : value = ( ( double * ) pixels ) [ 0 ] ; break ; default : value = 1.0 * pixels [ 0 ] ; break ; } max_value = value ; min_value = value ; for ( i = 0 ; i < ( ssize_t ) max_packets ; i ++ ) { switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : value = 1.0 * ( ( short * ) pixels ) [ i ] ; break ; case VFF_TYP_4_BYTE : value = 1.0 * ( ( int * ) pixels ) [ i ] ; break ; case VFF_TYP_FLOAT : value = ( ( float * ) pixels ) [ i ] ; break ; case VFF_TYP_DOUBLE : value = ( ( double * ) pixels ) [ i ] ; break ; default : value = 1.0 * pixels [ i ] ; break ; } if ( value > max_value ) max_value = value ; else if ( value < min_value ) min_value = value ; } if ( ( min_value == 0 ) && ( max_value == 0 ) ) scale_factor = 0 ; else if ( min_value == max_value ) { scale_factor = ( double ) QuantumRange / min_value ; min_value = 0 ; } else scale_factor = ( double ) QuantumRange / ( max_value - min_value ) ; } p = ( unsigned char * ) pixels ; for ( i = 0 ; i < ( ssize_t ) max_packets ; i ++ ) { switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : value = 1.0 * ( ( short * ) pixels ) [ i ] ; break ; case VFF_TYP_4_BYTE : value = 1.0 * ( ( int * ) pixels ) [ i ] ; break ; case VFF_TYP_FLOAT : value = ( ( float * ) pixels ) [ i ] ; break ; case VFF_TYP_DOUBLE : value = ( ( double * ) pixels ) [ i ] ; break ; default : value = 1.0 * pixels [ i ] ; break ; } if ( viff_info . map_scheme == VFF_MS_NONE ) { value = ( value - min_value ) * scale_factor ; if ( value > QuantumRange ) value = QuantumRange ; else if ( value < 0 ) value = 0 ; } * p = ( unsigned char ) ( ( Quantum ) value ) ; p ++ ; } p = ( unsigned char * ) pixels ; if ( viff_info . data_storage_type == VFF_TYP_BIT ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) ( image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { quantum = ( size_t ) ( ( * p ) & ( 0x01 << bit ) ? 0 : 1 ) ; SetPixelRed ( image , quantum == 0 ? 0 : QuantumRange , q ) ; SetPixelGreen ( image , quantum == 0 ? 0 : QuantumRange , q ) ; SetPixelBlue ( image , quantum == 0 ? 0 : QuantumRange , q ) ; if ( image -> storage_class == PseudoClass ) SetPixelIndex ( image , ( Quantum ) quantum , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( int ) ( image -> columns % 8 ) ; bit ++ ) { quantum = ( size_t ) ( ( * p ) & ( 0x01 << bit ) ? 0 : 1 ) ; SetPixelRed ( image , quantum == 0 ? 0 : QuantumRange , q ) ; SetPixelGreen ( image , quantum == 0 ? 0 : QuantumRange , q ) ; SetPixelBlue ( image , quantum == 0 ? 0 : QuantumRange , q ) ; if ( image -> storage_class == PseudoClass ) SetPixelIndex ( image , ( Quantum ) quantum , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else if ( image -> storage_class == PseudoClass ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } else { number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * ( p + number_pixels ) ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * ( p + 2 * number_pixels ) ) , q ) ; if ( image -> colors != 0 ) { ssize_t index ; index = ( ssize_t ) GetPixelRed ( image , q ) ; SetPixelRed ( image , image -> colormap [ ConstrainColormapIndex ( image , index , exception ) ] . red , q ) ; index = ( ssize_t ) GetPixelGreen ( image , q ) ; SetPixelGreen ( image , image -> colormap [ ConstrainColormapIndex ( image , index , exception ) ] . green , q ) ; index = ( ssize_t ) GetPixelBlue ( image , q ) ; SetPixelBlue ( image , image -> colormap [ ConstrainColormapIndex ( image , index , exception ) ] . blue , q ) ; } SetPixelAlpha ( image , image -> alpha_trait != UndefinedPixelTrait ? ScaleCharToQuantum ( * ( p + number_pixels * 3 ) ) : OpaqueAlpha , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image , exception ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; count = ReadBlob ( image , 1 , & viff_info . identifier ) ; if ( ( count != 0 ) && ( viff_info . identifier == 0xab ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( viff_info . identifier == 0xab ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","if ( HeapOverflowSanityCheck ( ( image -> columns + 7UL ) >> 3UL , image -> rows ) != MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( CheckMemoryOverflow ( number_pixels , viff_info . number_data_bands ) != MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;",297
413,"buggy line: int64_t index_pts = FFMAX ( av_rescale ( itime , i , 10000 ) - asf -> hdr . preroll , 0 ) ;if ( pos != last_pos ) {cwe id:CWE-399context: static int asf_build_simple_index ( AVFormatContext * s , int stream_index ) { ff_asf_guid g ; ASFContext * asf = s -> priv_data ; int64_t current_pos = avio_tell ( s -> pb ) ; int64_t ret ; if ( ( ret = avio_seek ( s -> pb , asf -> data_object_offset + asf -> data_object_size , SEEK_SET ) ) < 0 ) { return ret ; } if ( ( ret = ff_get_guid ( s -> pb , & g ) ) < 0 ) goto end ; while ( ff_guidcmp ( & g , & ff_asf_simple_index_header ) ) { int64_t gsize = avio_rl64 ( s -> pb ) ; if ( gsize < 24 || avio_feof ( s -> pb ) ) { goto end ; } avio_skip ( s -> pb , gsize - 24 ) ; if ( ( ret = ff_get_guid ( s -> pb , & g ) ) < 0 ) goto end ; } { int64_t itime , last_pos = - 1 ; int pct , ict ; int i ; int64_t av_unused gsize = avio_rl64 ( s -> pb ) ; if ( ( ret = ff_get_guid ( s -> pb , & g ) ) < 0 ) goto end ; itime = avio_rl64 ( s -> pb ) ; pct = avio_rl32 ( s -> pb ) ; ict = avio_rl32 ( s -> pb ) ; av_log ( s , AV_LOG_DEBUG , ""itime:0x%"" PRIx64 "",<S2SV_blank>pct:%d,<S2SV_blank>ict:%d\\n"" , itime , pct , ict ) ; for ( i = 0 ; i < ict ; i ++ ) { int pktnum = avio_rl32 ( s -> pb ) ; int pktct = avio_rl16 ( s -> pb ) ; int64_t pos = s -> internal -> data_offset + s -> packet_size * ( int64_t ) pktnum ;  int64_t index_pts = FFMAX ( av_rescale ( itime , i , 10000 ) - asf -> hdr . preroll , 0 ) ;  if ( pos != last_pos ) { av_log ( s , AV_LOG_DEBUG , ""pktnum:%d,<S2SV_blank>pktct:%d<S2SV_blank><S2SV_blank>pts:<S2SV_blank>%"" PRId64 ""\\n"" , pktnum , pktct , index_pts ) ; av_add_index_entry ( s -> streams [ stream_index ] , pos , index_pts , s -> packet_size , 0 , AVINDEX_KEYFRAME ) ; last_pos = pos ; } } asf -> index_read = ict > 1 ; } end : avio_seek ( s -> pb , current_pos , SEEK_SET ) ; return ret ; }","int64_t index_pts = FFMAX ( av_rescale ( itime , i , 10000 ) - asf -> hdr . preroll , 0 ) ;if ( avio_feof ( s -> pb ) ) {ret = AVERROR_INVALIDDATA ;goto end ;}if ( pos != last_pos ) {",298
414,"buggy line: rinfo = kmalloc ( SZ_SG_REQ_INFO * SG_MAX_QUEUE ,  GFP_KERNEL ) ;cwe id:CWE-200context: static long sg_ioctl ( struct file * filp , unsigned int cmd_in , unsigned long arg ) { void __user * p = ( void __user * ) arg ; int __user * ip = p ; int result , val , read_only ; Sg_device * sdp ; Sg_fd * sfp ; Sg_request * srp ; unsigned long iflags ; if ( ( ! ( sfp = ( Sg_fd * ) filp -> private_data ) ) || ( ! ( sdp = sfp -> parentdp ) ) ) return - ENXIO ; SCSI_LOG_TIMEOUT ( 3 , sg_printk ( KERN_INFO , sdp , ""sg_ioctl:<S2SV_blank>cmd=0x%x\\n"" , ( int ) cmd_in ) ) ; read_only = ( O_RDWR != ( filp -> f_flags & O_ACCMODE ) ) ; switch ( cmd_in ) { case SG_IO : if ( atomic_read ( & sdp -> detaching ) ) return - ENODEV ; if ( ! scsi_block_when_processing_errors ( sdp -> device ) ) return - ENXIO ; if ( ! access_ok ( VERIFY_WRITE , p , SZ_SG_IO_HDR ) ) return - EFAULT ; result = sg_new_write ( sfp , filp , p , SZ_SG_IO_HDR , 1 , read_only , 1 , & srp ) ; if ( result < 0 ) return result ; result = wait_event_interruptible ( sfp -> read_wait , ( srp_done ( sfp , srp ) || atomic_read ( & sdp -> detaching ) ) ) ; if ( atomic_read ( & sdp -> detaching ) ) return - ENODEV ; write_lock_irq ( & sfp -> rq_list_lock ) ; if ( srp -> done ) { srp -> done = 2 ; write_unlock_irq ( & sfp -> rq_list_lock ) ; result = sg_new_read ( sfp , p , SZ_SG_IO_HDR , srp ) ; return ( result < 0 ) ? result : 0 ; } srp -> orphan = 1 ; write_unlock_irq ( & sfp -> rq_list_lock ) ; return result ; case SG_SET_TIMEOUT : result = get_user ( val , ip ) ; if ( result ) return result ; if ( val < 0 ) return - EIO ; if ( val >= mult_frac ( ( s64 ) INT_MAX , USER_HZ , HZ ) ) val = min_t ( s64 , mult_frac ( ( s64 ) INT_MAX , USER_HZ , HZ ) , INT_MAX ) ; sfp -> timeout_user = val ; sfp -> timeout = mult_frac ( val , HZ , USER_HZ ) ; return 0 ; case SG_GET_TIMEOUT : return sfp -> timeout_user ; case SG_SET_FORCE_LOW_DMA : return 0 ; case SG_GET_LOW_DMA : return put_user ( ( int ) sdp -> device -> host -> unchecked_isa_dma , ip ) ; case SG_GET_SCSI_ID : if ( ! access_ok ( VERIFY_WRITE , p , sizeof ( sg_scsi_id_t ) ) ) return - EFAULT ; else { sg_scsi_id_t __user * sg_idp = p ; if ( atomic_read ( & sdp -> detaching ) ) return - ENODEV ; __put_user ( ( int ) sdp -> device -> host -> host_no , & sg_idp -> host_no ) ; __put_user ( ( int ) sdp -> device -> channel , & sg_idp -> channel ) ; __put_user ( ( int ) sdp -> device -> id , & sg_idp -> scsi_id ) ; __put_user ( ( int ) sdp -> device -> lun , & sg_idp -> lun ) ; __put_user ( ( int ) sdp -> device -> type , & sg_idp -> scsi_type ) ; __put_user ( ( short ) sdp -> device -> host -> cmd_per_lun , & sg_idp -> h_cmd_per_lun ) ; __put_user ( ( short ) sdp -> device -> queue_depth , & sg_idp -> d_queue_depth ) ; __put_user ( 0 , & sg_idp -> unused [ 0 ] ) ; __put_user ( 0 , & sg_idp -> unused [ 1 ] ) ; return 0 ; } case SG_SET_FORCE_PACK_ID : result = get_user ( val , ip ) ; if ( result ) return result ; sfp -> force_packid = val ? 1 : 0 ; return 0 ; case SG_GET_PACK_ID : if ( ! access_ok ( VERIFY_WRITE , ip , sizeof ( int ) ) ) return - EFAULT ; read_lock_irqsave ( & sfp -> rq_list_lock , iflags ) ; list_for_each_entry ( srp , & sfp -> rq_list , entry ) { if ( ( 1 == srp -> done ) && ( ! srp -> sg_io_owned ) ) { read_unlock_irqrestore ( & sfp -> rq_list_lock , iflags ) ; __put_user ( srp -> header . pack_id , ip ) ; return 0 ; } } read_unlock_irqrestore ( & sfp -> rq_list_lock , iflags ) ; __put_user ( - 1 , ip ) ; return 0 ; case SG_GET_NUM_WAITING : read_lock_irqsave ( & sfp -> rq_list_lock , iflags ) ; val = 0 ; list_for_each_entry ( srp , & sfp -> rq_list , entry ) { if ( ( 1 == srp -> done ) && ( ! srp -> sg_io_owned ) ) ++ val ; } read_unlock_irqrestore ( & sfp -> rq_list_lock , iflags ) ; return put_user ( val , ip ) ; case SG_GET_SG_TABLESIZE : return put_user ( sdp -> sg_tablesize , ip ) ; case SG_SET_RESERVED_SIZE : result = get_user ( val , ip ) ; if ( result ) return result ; if ( val < 0 ) return - EINVAL ; val = min_t ( int , val , max_sectors_bytes ( sdp -> device -> request_queue ) ) ; mutex_lock ( & sfp -> f_mutex ) ; if ( val != sfp -> reserve . bufflen ) { if ( sfp -> mmap_called || sfp -> res_in_use ) { mutex_unlock ( & sfp -> f_mutex ) ; return - EBUSY ; } sg_remove_scat ( sfp , & sfp -> reserve ) ; sg_build_reserve ( sfp , val ) ; } mutex_unlock ( & sfp -> f_mutex ) ; return 0 ; case SG_GET_RESERVED_SIZE : val = min_t ( int , sfp -> reserve . bufflen , max_sectors_bytes ( sdp -> device -> request_queue ) ) ; return put_user ( val , ip ) ; case SG_SET_COMMAND_Q : result = get_user ( val , ip ) ; if ( result ) return result ; sfp -> cmd_q = val ? 1 : 0 ; return 0 ; case SG_GET_COMMAND_Q : return put_user ( ( int ) sfp -> cmd_q , ip ) ; case SG_SET_KEEP_ORPHAN : result = get_user ( val , ip ) ; if ( result ) return result ; sfp -> keep_orphan = val ; return 0 ; case SG_GET_KEEP_ORPHAN : return put_user ( ( int ) sfp -> keep_orphan , ip ) ; case SG_NEXT_CMD_LEN : result = get_user ( val , ip ) ; if ( result ) return result ; if ( val > SG_MAX_CDB_SIZE ) return - ENOMEM ; sfp -> next_cmd_len = ( val > 0 ) ? val : 0 ; return 0 ; case SG_GET_VERSION_NUM : return put_user ( sg_version_num , ip ) ; case SG_GET_ACCESS_COUNT : val = ( sdp -> device ? 1 : 0 ) ; return put_user ( val , ip ) ; case SG_GET_REQUEST_TABLE : if ( ! access_ok ( VERIFY_WRITE , p , SZ_SG_REQ_INFO * SG_MAX_QUEUE ) ) return - EFAULT ; else { sg_req_info_t * rinfo ;  rinfo = kmalloc ( SZ_SG_REQ_INFO * SG_MAX_QUEUE ,  GFP_KERNEL ) ; if ( ! rinfo ) return - ENOMEM ; read_lock_irqsave ( & sfp -> rq_list_lock , iflags ) ; sg_fill_request_table ( sfp , rinfo ) ; read_unlock_irqrestore ( & sfp -> rq_list_lock , iflags ) ; result = __copy_to_user ( p , rinfo , SZ_SG_REQ_INFO * SG_MAX_QUEUE ) ; result = result ? - EFAULT : 0 ; kfree ( rinfo ) ; return result ; } case SG_EMULATED_HOST : if ( atomic_read ( & sdp -> detaching ) ) return - ENODEV ; return put_user ( sdp -> device -> host -> hostt -> emulated , ip ) ; case SCSI_IOCTL_SEND_COMMAND : if ( atomic_read ( & sdp -> detaching ) ) return - ENODEV ; if ( read_only ) { unsigned char opcode = WRITE_6 ; Scsi_Ioctl_Command __user * siocp = p ; if ( copy_from_user ( & opcode , siocp -> data , 1 ) ) return - EFAULT ; if ( sg_allow_access ( filp , & opcode ) ) return - EPERM ; } return sg_scsi_ioctl ( sdp -> device -> request_queue , NULL , filp -> f_mode , p ) ; case SG_SET_DEBUG : result = get_user ( val , ip ) ; if ( result ) return result ; sdp -> sgdebug = ( char ) val ; return 0 ; case BLKSECTGET : return put_user ( max_sectors_bytes ( sdp -> device -> request_queue ) , ip ) ; case BLKTRACESETUP : return blk_trace_setup ( sdp -> device -> request_queue , sdp -> disk -> disk_name , MKDEV ( SCSI_GENERIC_MAJOR , sdp -> index ) , NULL , p ) ; case BLKTRACESTART : return blk_trace_startstop ( sdp -> device -> request_queue , 1 ) ; case BLKTRACESTOP : return blk_trace_startstop ( sdp -> device -> request_queue , 0 ) ; case BLKTRACETEARDOWN : return blk_trace_remove ( sdp -> device -> request_queue ) ; case SCSI_IOCTL_GET_IDLUN : case SCSI_IOCTL_GET_BUS_NUMBER : case SCSI_IOCTL_PROBE_HOST : case SG_GET_TRANSFORM : case SG_SCSI_RESET : if ( atomic_read ( & sdp -> detaching ) ) return - ENODEV ; break ; default : if ( read_only ) return - EPERM ; break ; } result = scsi_ioctl_block_when_processing_errors ( sdp -> device , cmd_in , filp -> f_flags & O_NDELAY ) ; if ( result ) return result ; return scsi_ioctl ( sdp -> device , cmd_in , p ) ; }","rinfo = kzalloc ( SZ_SG_REQ_INFO * SG_MAX_QUEUE , GFP_KERNEL ) ;",299
415,"buggy line: # endif install_keyword_root ( ""use_pid_dir"" , & use_pid_dir_handler , global_active ) ;cwe id:CWE-200context: void init_global_keywords ( bool global_active ) { install_keyword_root ( ""linkbeat_use_polling"" , use_polling_handler , global_active ) ; # if HAVE_DECL_CLONE_NEWNET install_keyword_root ( ""net_namespace"" , & net_namespace_handler , global_active ) ; install_keyword_root ( ""namespace_with_ipsets"" , & namespace_ipsets_handler , global_active ) ; # endif install_keyword_root ( ""use_pid_dir"" , & use_pid_dir_handler , global_active ) ; install_keyword_root ( ""instance"" , & instance_handler , global_active ) ; install_keyword_root ( ""child_wait_time"" , & child_wait_handler , global_active ) ; install_keyword_root ( ""global_defs"" , NULL , global_active ) ; install_keyword ( ""router_id"" , & routerid_handler ) ; install_keyword ( ""notification_email_from"" , & emailfrom_handler ) ; install_keyword ( ""smtp_server"" , & smtpserver_handler ) ; install_keyword ( ""smtp_helo_name"" , & smtphelo_handler ) ; install_keyword ( ""smtp_connect_timeout"" , & smtpto_handler ) ; install_keyword ( ""notification_email"" , & email_handler ) ; install_keyword ( ""smtp_alert"" , & smtp_alert_handler ) ; # ifdef _WITH_VRRP_ install_keyword ( ""smtp_alert_vrrp"" , & smtp_alert_vrrp_handler ) ; # endif # ifdef _WITH_LVS_ install_keyword ( ""smtp_alert_checker"" , & smtp_alert_checker_handler ) ; # endif # ifdef _WITH_VRRP_ install_keyword ( ""dynamic_interfaces"" , & dynamic_interfaces_handler ) ; install_keyword ( ""no_email_faults"" , & no_email_faults_handler ) ; install_keyword ( ""default_interface"" , & default_interface_handler ) ; # endif # ifdef _WITH_LVS_ install_keyword ( ""lvs_timeouts"" , & lvs_timeouts ) ; install_keyword ( ""lvs_flush"" , & lvs_flush_handler ) ; # ifdef _WITH_VRRP_ install_keyword ( ""lvs_sync_daemon"" , & lvs_syncd_handler ) ; # endif # endif # ifdef _WITH_VRRP_ install_keyword ( ""vrrp_mcast_group4"" , & vrrp_mcast_group4_handler ) ; install_keyword ( ""vrrp_mcast_group6"" , & vrrp_mcast_group6_handler ) ; install_keyword ( ""vrrp_garp_master_delay"" , & vrrp_garp_delay_handler ) ; install_keyword ( ""vrrp_garp_master_repeat"" , & vrrp_garp_rep_handler ) ; install_keyword ( ""vrrp_garp_master_refresh"" , & vrrp_garp_refresh_handler ) ; install_keyword ( ""vrrp_garp_master_refresh_repeat"" , & vrrp_garp_refresh_rep_handler ) ; install_keyword ( ""vrrp_garp_lower_prio_delay"" , & vrrp_garp_lower_prio_delay_handler ) ; install_keyword ( ""vrrp_garp_lower_prio_repeat"" , & vrrp_garp_lower_prio_rep_handler ) ; install_keyword ( ""vrrp_garp_interval"" , & vrrp_garp_interval_handler ) ; install_keyword ( ""vrrp_gna_interval"" , & vrrp_gna_interval_handler ) ; install_keyword ( ""vrrp_lower_prio_no_advert"" , & vrrp_lower_prio_no_advert_handler ) ; install_keyword ( ""vrrp_higher_prio_send_advert"" , & vrrp_higher_prio_send_advert_handler ) ; install_keyword ( ""vrrp_version"" , & vrrp_version_handler ) ; install_keyword ( ""vrrp_iptables"" , & vrrp_iptables_handler ) ; # ifdef _HAVE_LIBIPSET_ install_keyword ( ""vrrp_ipsets"" , & vrrp_ipsets_handler ) ; # endif install_keyword ( ""vrrp_check_unicast_src"" , & vrrp_check_unicast_src_handler ) ; install_keyword ( ""vrrp_skip_check_adv_addr"" , & vrrp_check_adv_addr_handler ) ; install_keyword ( ""vrrp_strict"" , & vrrp_strict_handler ) ; install_keyword ( ""vrrp_priority"" , & vrrp_prio_handler ) ; install_keyword ( ""vrrp_no_swap"" , & vrrp_no_swap_handler ) ; # ifdef _HAVE_SCHED_RT_ install_keyword ( ""vrrp_rt_priority"" , & vrrp_rt_priority_handler ) ; # if HAVE_DECL_RLIMIT_RTTIME == 1 install_keyword ( ""vrrp_rlimit_rtime"" , & vrrp_rt_rlimit_handler ) ; # endif # endif # endif install_keyword ( ""notify_fifo"" , & global_notify_fifo ) ; install_keyword ( ""notify_fifo_script"" , & global_notify_fifo_script ) ; # ifdef _WITH_VRRP_ install_keyword ( ""vrrp_notify_fifo"" , & vrrp_notify_fifo ) ; install_keyword ( ""vrrp_notify_fifo_script"" , & vrrp_notify_fifo_script ) ; # endif # ifdef _WITH_LVS_ install_keyword ( ""lvs_notify_fifo"" , & lvs_notify_fifo ) ; install_keyword ( ""lvs_notify_fifo_script"" , & lvs_notify_fifo_script ) ; install_keyword ( ""checker_priority"" , & checker_prio_handler ) ; install_keyword ( ""checker_no_swap"" , & checker_no_swap_handler ) ; # ifdef _HAVE_SCHED_RT_ install_keyword ( ""checker_rt_priority"" , & checker_rt_priority_handler ) ; # if HAVE_DECL_RLIMIT_RTTIME == 1 install_keyword ( ""checker_rlimit_rtime"" , & checker_rt_rlimit_handler ) ; # endif # endif # endif # ifdef _WITH_BFD_ install_keyword ( ""bfd_priority"" , & bfd_prio_handler ) ; install_keyword ( ""bfd_no_swap"" , & bfd_no_swap_handler ) ; # ifdef _HAVE_SCHED_RT_ install_keyword ( ""bfd_rt_priority"" , & bfd_rt_priority_handler ) ; # if HAVE_DECL_RLIMIT_RTTIME == 1 install_keyword ( ""bfd_rlimit_rtime"" , & bfd_rt_rlimit_handler ) ; # endif # endif # endif # ifdef _WITH_SNMP_ install_keyword ( ""snmp_socket"" , & snmp_socket_handler ) ; install_keyword ( ""enable_traps"" , & trap_handler ) ; # ifdef _WITH_SNMP_VRRP_ install_keyword ( ""enable_snmp_vrrp"" , & snmp_vrrp_handler ) ; install_keyword ( ""enable_snmp_keepalived"" , & snmp_vrrp_handler ) ; # endif # ifdef _WITH_SNMP_RFC_ install_keyword ( ""enable_snmp_rfc"" , & snmp_rfc_handler ) ; # endif # ifdef _WITH_SNMP_RFCV2_ install_keyword ( ""enable_snmp_rfcv2"" , & snmp_rfcv2_handler ) ; # endif # ifdef _WITH_SNMP_RFCV3_ install_keyword ( ""enable_snmp_rfcv3"" , & snmp_rfcv3_handler ) ; # endif # ifdef _WITH_SNMP_CHECKER_ install_keyword ( ""enable_snmp_checker"" , & snmp_checker_handler ) ; # endif # endif # ifdef _WITH_DBUS_ install_keyword ( ""enable_dbus"" , & enable_dbus_handler ) ; install_keyword ( ""dbus_service_name"" , & dbus_service_name_handler ) ; # endif install_keyword ( ""script_user"" , & script_user_handler ) ; install_keyword ( ""enable_script_security"" , & script_security_handler ) ; # ifdef _WITH_VRRP_ install_keyword ( ""vrrp_netlink_cmd_rcv_bufs"" , & vrrp_netlink_cmd_rcv_bufs_handler ) ; install_keyword ( ""vrrp_netlink_cmd_rcv_bufs_force"" , & vrrp_netlink_cmd_rcv_bufs_force_handler ) ; install_keyword ( ""vrrp_netlink_monitor_rcv_bufs"" , & vrrp_netlink_monitor_rcv_bufs_handler ) ; install_keyword ( ""vrrp_netlink_monitor_rcv_bufs_force"" , & vrrp_netlink_monitor_rcv_bufs_force_handler ) ; # endif # ifdef _WITH_LVS_ install_keyword ( ""lvs_netlink_cmd_rcv_bufs"" , & lvs_netlink_cmd_rcv_bufs_handler ) ; install_keyword ( ""lvs_netlink_cmd_rcv_bufs_force"" , & lvs_netlink_cmd_rcv_bufs_force_handler ) ; install_keyword ( ""lvs_netlink_monitor_rcv_bufs"" , & lvs_netlink_monitor_rcv_bufs_handler ) ; install_keyword ( ""lvs_netlink_monitor_rcv_bufs_force"" , & lvs_netlink_monitor_rcv_bufs_force_handler ) ; # endif # ifdef _WITH_LVS_ install_keyword ( ""rs_init_notifies"" , & rs_init_notifies_handler ) ; install_keyword ( ""no_checker_emails"" , & no_checker_emails_handler ) ; # endif # ifdef _WITH_VRRP_ install_keyword ( ""vrrp_rx_bufs_policy"" , & vrrp_rx_bufs_policy_handler ) ; install_keyword ( ""vrrp_rx_bufs_multiplier"" , & vrrp_rx_bufs_multiplier_handler ) ; # endif  } ","# endif install_keyword ( ""umask"" , & umask_handler ) ;install_keyword_root ( ""use_pid_dir"" , & use_pid_dir_handler , global_active ) ;",300
416,"buggy line: # endif  }cwe id:CWE-200context: void init_global_keywords ( bool global_active ) { install_keyword_root ( ""linkbeat_use_polling"" , use_polling_handler , global_active ) ; # if HAVE_DECL_CLONE_NEWNET install_keyword_root ( ""net_namespace"" , & net_namespace_handler , global_active ) ; install_keyword_root ( ""namespace_with_ipsets"" , & namespace_ipsets_handler , global_active ) ; # endif install_keyword_root ( ""use_pid_dir"" , & use_pid_dir_handler , global_active ) ; install_keyword_root ( ""instance"" , & instance_handler , global_active ) ; install_keyword_root ( ""child_wait_time"" , & child_wait_handler , global_active ) ; install_keyword_root ( ""global_defs"" , NULL , global_active ) ; install_keyword ( ""router_id"" , & routerid_handler ) ; install_keyword ( ""notification_email_from"" , & emailfrom_handler ) ; install_keyword ( ""smtp_server"" , & smtpserver_handler ) ; install_keyword ( ""smtp_helo_name"" , & smtphelo_handler ) ; install_keyword ( ""smtp_connect_timeout"" , & smtpto_handler ) ; install_keyword ( ""notification_email"" , & email_handler ) ; install_keyword ( ""smtp_alert"" , & smtp_alert_handler ) ; # ifdef _WITH_VRRP_ install_keyword ( ""smtp_alert_vrrp"" , & smtp_alert_vrrp_handler ) ; # endif # ifdef _WITH_LVS_ install_keyword ( ""smtp_alert_checker"" , & smtp_alert_checker_handler ) ; # endif # ifdef _WITH_VRRP_ install_keyword ( ""dynamic_interfaces"" , & dynamic_interfaces_handler ) ; install_keyword ( ""no_email_faults"" , & no_email_faults_handler ) ; install_keyword ( ""default_interface"" , & default_interface_handler ) ; # endif # ifdef _WITH_LVS_ install_keyword ( ""lvs_timeouts"" , & lvs_timeouts ) ; install_keyword ( ""lvs_flush"" , & lvs_flush_handler ) ; # ifdef _WITH_VRRP_ install_keyword ( ""lvs_sync_daemon"" , & lvs_syncd_handler ) ; # endif # endif # ifdef _WITH_VRRP_ install_keyword ( ""vrrp_mcast_group4"" , & vrrp_mcast_group4_handler ) ; install_keyword ( ""vrrp_mcast_group6"" , & vrrp_mcast_group6_handler ) ; install_keyword ( ""vrrp_garp_master_delay"" , & vrrp_garp_delay_handler ) ; install_keyword ( ""vrrp_garp_master_repeat"" , & vrrp_garp_rep_handler ) ; install_keyword ( ""vrrp_garp_master_refresh"" , & vrrp_garp_refresh_handler ) ; install_keyword ( ""vrrp_garp_master_refresh_repeat"" , & vrrp_garp_refresh_rep_handler ) ; install_keyword ( ""vrrp_garp_lower_prio_delay"" , & vrrp_garp_lower_prio_delay_handler ) ; install_keyword ( ""vrrp_garp_lower_prio_repeat"" , & vrrp_garp_lower_prio_rep_handler ) ; install_keyword ( ""vrrp_garp_interval"" , & vrrp_garp_interval_handler ) ; install_keyword ( ""vrrp_gna_interval"" , & vrrp_gna_interval_handler ) ; install_keyword ( ""vrrp_lower_prio_no_advert"" , & vrrp_lower_prio_no_advert_handler ) ; install_keyword ( ""vrrp_higher_prio_send_advert"" , & vrrp_higher_prio_send_advert_handler ) ; install_keyword ( ""vrrp_version"" , & vrrp_version_handler ) ; install_keyword ( ""vrrp_iptables"" , & vrrp_iptables_handler ) ; # ifdef _HAVE_LIBIPSET_ install_keyword ( ""vrrp_ipsets"" , & vrrp_ipsets_handler ) ; # endif install_keyword ( ""vrrp_check_unicast_src"" , & vrrp_check_unicast_src_handler ) ; install_keyword ( ""vrrp_skip_check_adv_addr"" , & vrrp_check_adv_addr_handler ) ; install_keyword ( ""vrrp_strict"" , & vrrp_strict_handler ) ; install_keyword ( ""vrrp_priority"" , & vrrp_prio_handler ) ; install_keyword ( ""vrrp_no_swap"" , & vrrp_no_swap_handler ) ; # ifdef _HAVE_SCHED_RT_ install_keyword ( ""vrrp_rt_priority"" , & vrrp_rt_priority_handler ) ; # if HAVE_DECL_RLIMIT_RTTIME == 1 install_keyword ( ""vrrp_rlimit_rtime"" , & vrrp_rt_rlimit_handler ) ; # endif # endif # endif install_keyword ( ""notify_fifo"" , & global_notify_fifo ) ; install_keyword ( ""notify_fifo_script"" , & global_notify_fifo_script ) ; # ifdef _WITH_VRRP_ install_keyword ( ""vrrp_notify_fifo"" , & vrrp_notify_fifo ) ; install_keyword ( ""vrrp_notify_fifo_script"" , & vrrp_notify_fifo_script ) ; # endif # ifdef _WITH_LVS_ install_keyword ( ""lvs_notify_fifo"" , & lvs_notify_fifo ) ; install_keyword ( ""lvs_notify_fifo_script"" , & lvs_notify_fifo_script ) ; install_keyword ( ""checker_priority"" , & checker_prio_handler ) ; install_keyword ( ""checker_no_swap"" , & checker_no_swap_handler ) ; # ifdef _HAVE_SCHED_RT_ install_keyword ( ""checker_rt_priority"" , & checker_rt_priority_handler ) ; # if HAVE_DECL_RLIMIT_RTTIME == 1 install_keyword ( ""checker_rlimit_rtime"" , & checker_rt_rlimit_handler ) ; # endif # endif # endif # ifdef _WITH_BFD_ install_keyword ( ""bfd_priority"" , & bfd_prio_handler ) ; install_keyword ( ""bfd_no_swap"" , & bfd_no_swap_handler ) ; # ifdef _HAVE_SCHED_RT_ install_keyword ( ""bfd_rt_priority"" , & bfd_rt_priority_handler ) ; # if HAVE_DECL_RLIMIT_RTTIME == 1 install_keyword ( ""bfd_rlimit_rtime"" , & bfd_rt_rlimit_handler ) ; # endif # endif # endif # ifdef _WITH_SNMP_ install_keyword ( ""snmp_socket"" , & snmp_socket_handler ) ; install_keyword ( ""enable_traps"" , & trap_handler ) ; # ifdef _WITH_SNMP_VRRP_ install_keyword ( ""enable_snmp_vrrp"" , & snmp_vrrp_handler ) ; install_keyword ( ""enable_snmp_keepalived"" , & snmp_vrrp_handler ) ; # endif # ifdef _WITH_SNMP_RFC_ install_keyword ( ""enable_snmp_rfc"" , & snmp_rfc_handler ) ; # endif # ifdef _WITH_SNMP_RFCV2_ install_keyword ( ""enable_snmp_rfcv2"" , & snmp_rfcv2_handler ) ; # endif # ifdef _WITH_SNMP_RFCV3_ install_keyword ( ""enable_snmp_rfcv3"" , & snmp_rfcv3_handler ) ; # endif # ifdef _WITH_SNMP_CHECKER_ install_keyword ( ""enable_snmp_checker"" , & snmp_checker_handler ) ; # endif # endif # ifdef _WITH_DBUS_ install_keyword ( ""enable_dbus"" , & enable_dbus_handler ) ; install_keyword ( ""dbus_service_name"" , & dbus_service_name_handler ) ; # endif install_keyword ( ""script_user"" , & script_user_handler ) ; install_keyword ( ""enable_script_security"" , & script_security_handler ) ; # ifdef _WITH_VRRP_ install_keyword ( ""vrrp_netlink_cmd_rcv_bufs"" , & vrrp_netlink_cmd_rcv_bufs_handler ) ; install_keyword ( ""vrrp_netlink_cmd_rcv_bufs_force"" , & vrrp_netlink_cmd_rcv_bufs_force_handler ) ; install_keyword ( ""vrrp_netlink_monitor_rcv_bufs"" , & vrrp_netlink_monitor_rcv_bufs_handler ) ; install_keyword ( ""vrrp_netlink_monitor_rcv_bufs_force"" , & vrrp_netlink_monitor_rcv_bufs_force_handler ) ; # endif # ifdef _WITH_LVS_ install_keyword ( ""lvs_netlink_cmd_rcv_bufs"" , & lvs_netlink_cmd_rcv_bufs_handler ) ; install_keyword ( ""lvs_netlink_cmd_rcv_bufs_force"" , & lvs_netlink_cmd_rcv_bufs_force_handler ) ; install_keyword ( ""lvs_netlink_monitor_rcv_bufs"" , & lvs_netlink_monitor_rcv_bufs_handler ) ; install_keyword ( ""lvs_netlink_monitor_rcv_bufs_force"" , & lvs_netlink_monitor_rcv_bufs_force_handler ) ; # endif # ifdef _WITH_LVS_ install_keyword ( ""rs_init_notifies"" , & rs_init_notifies_handler ) ; install_keyword ( ""no_checker_emails"" , & no_checker_emails_handler ) ; # endif # ifdef _WITH_VRRP_ install_keyword ( ""vrrp_rx_bufs_policy"" , & vrrp_rx_bufs_policy_handler ) ; install_keyword ( ""vrrp_rx_bufs_multiplier"" , & vrrp_rx_bufs_multiplier_handler ) ; # endif  } ",# endif },300
417,"buggy line: return encoder_common_init ( ctx ) ;}cwe id:CWE-119context: static vpx_codec_err_t encoder_init ( vpx_codec_ctx_t * ctx , vpx_codec_priv_enc_mr_cfg_t * data ) {  return encoder_common_init ( ctx ) ;  }","vpx_codec_err_t res = VPX_CODEC_OK ;( void ) data ;if ( ctx -> priv == NULL ) {vpx_codec_alg_priv_t * const priv = vpx_calloc ( 1 , sizeof ( * priv ) ) ;if ( priv == NULL ) return VPX_CODEC_MEM_ERROR ;ctx -> priv = ( vpx_codec_priv_t * ) priv ;ctx -> priv -> init_flags = ctx -> init_flags ;ctx -> priv -> enc . total_encoders = 1 ;priv -> buffer_pool = ( BufferPool * ) vpx_calloc ( 1 , sizeof ( BufferPool ) ) ;if ( priv -> buffer_pool == NULL ) return VPX_CODEC_MEM_ERROR ;# if CONFIG_MULTITHREAD if ( pthread_mutex_init ( & priv -> buffer_pool -> pool_mutex , NULL ) ) {return VPX_CODEC_MEM_ERROR ;}# endif if ( ctx -> config . enc ) {priv -> cfg = * ctx -> config . enc ;ctx -> config . enc = & priv -> cfg ;}priv -> extra_cfg = default_extra_cfg ;once ( vp9_initialize_enc ) ;res = validate_config ( priv , & priv -> cfg , & priv -> extra_cfg ) ;if ( res == VPX_CODEC_OK ) {set_encoder_config ( & priv -> oxcf , & priv -> cfg , & priv -> extra_cfg ) ;# if CONFIG_VP9_HIGHBITDEPTH priv -> oxcf . use_highbitdepth = ( ctx -> init_flags & VPX_CODEC_USE_HIGHBITDEPTH ) ? 1 : 0 ;# endif priv -> cpi = vp9_create_compressor ( & priv -> oxcf , priv -> buffer_pool ) ;if ( priv -> cpi == NULL ) res = VPX_CODEC_MEM_ERROR ;else priv -> cpi -> output_pkt_list = & priv -> pkt_list . head ;}}return res ;}",301
418,"buggy line: char * tmpptr = key + strlen ( key ) ;* tmpptr = \'=\' ;cwe id:CWE-119context: int iscsi_decode_text_input ( u8 phase , u8 sender , char * textbuf , u32 length , struct iscsi_conn * conn ) { struct iscsi_param_list * param_list = conn -> param_list ; char * tmpbuf , * start = NULL , * end = NULL ; tmpbuf = kzalloc ( length + 1 , GFP_KERNEL ) ; if ( ! tmpbuf ) { pr_err ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>tmpbuf.\\n"" ) ; return - 1 ; } memcpy ( tmpbuf , textbuf , length ) ; tmpbuf [ length ] = '\\0' ; start = tmpbuf ; end = ( start + length ) ; while ( start < end ) { char * key , * value ; struct iscsi_param * param ; if ( iscsi_extract_key_value ( start , & key , & value ) < 0 ) { kfree ( tmpbuf ) ; return - 1 ; } pr_debug ( ""Got<S2SV_blank>key:<S2SV_blank>%s=%s\\n"" , key , value ) ; if ( phase & PHASE_SECURITY ) { if ( iscsi_check_for_auth_key ( key ) > 0 ) {  char * tmpptr = key + strlen ( key ) ;  * tmpptr = '=' ; kfree ( tmpbuf ) ; return 1 ; } } param = iscsi_check_key ( key , phase , sender , param_list ) ; if ( ! param ) { if ( iscsi_add_notunderstood_response ( key , value , param_list ) < 0 ) { kfree ( tmpbuf ) ; return - 1 ; } start += strlen ( key ) + strlen ( value ) + 2 ; continue ; } if ( iscsi_check_value ( param , value ) < 0 ) { kfree ( tmpbuf ) ; return - 1 ; } start += strlen ( key ) + strlen ( value ) + 2 ; if ( IS_PSTATE_PROPOSER ( param ) ) { if ( iscsi_check_proposer_state ( param , value ) < 0 ) { kfree ( tmpbuf ) ; return - 1 ; } SET_PSTATE_RESPONSE_GOT ( param ) ; } else { if ( iscsi_check_acceptor_state ( param , value , conn ) < 0 ) { kfree ( tmpbuf ) ; return - 1 ; } SET_PSTATE_ACCEPTOR ( param ) ; } } kfree ( tmpbuf ) ; return 0 ; }",char * tmpptr = key + strlen ( key ) ;* tmpptr = \'=\' ;,302
419,"buggy line: else if ( errno == ENOENT )  touch_file ( t -> stamp_path , true , USEC_INFINITY , UID_INVALID , GID_INVALID , 0 ) ;}cwe id:CWE-264context: static int timer_start ( Unit * u ) { Timer * t = TIMER ( u ) ; TimerValue * v ; assert ( t ) ; assert ( t -> state == TIMER_DEAD || t -> state == TIMER_FAILED ) ; if ( UNIT_TRIGGER ( u ) -> load_state != UNIT_LOADED ) return - ENOENT ; t -> last_trigger = DUAL_TIMESTAMP_NULL ; LIST_FOREACH ( value , v , t -> values ) if ( v -> base == TIMER_ACTIVE ) v -> disabled = false ; if ( t -> stamp_path ) { struct stat st ; if ( stat ( t -> stamp_path , & st ) >= 0 ) t -> last_trigger . realtime = timespec_load ( & st . st_atim ) ; else if ( errno == ENOENT )  touch_file ( t -> stamp_path , true , USEC_INFINITY , UID_INVALID , GID_INVALID , 0 ) ;  } t -> result = TIMER_SUCCESS ; timer_enter_waiting ( t , true ) ; return 1 ; }","else if ( errno == ENOENT ) touch_file ( t -> stamp_path , true , USEC_INFINITY , UID_INVALID , GID_INVALID , MODE_INVALID ) ;}",303
420,"buggy line: if ( ! ( box = jas_malloc ( sizeof ( jp2_box_t ) ) ) ) {goto error ;box -> ops = & jp2_boxinfo_unk . ops ;JAS_DBGLOG ( 10 , (  ""preliminary<S2SV_blank>processing<S2SV_blank>of<S2SV_blank>JP2<S2SV_blank>box:<S2SV_blank>type=%c%s%c<S2SV_blank>(0x%08x);<S2SV_blank>length=%d\\\if ( box -> len == 1 ) {if ( jp2_getuint64 ( in , & extlen ) ) {cwe id:CWE-476context: jp2_box_t * jp2_box_get ( jas_stream_t * in ) { jp2_box_t * box ; jp2_boxinfo_t * boxinfo ; jas_stream_t * tmpstream ; uint_fast32_t len ; uint_fast64_t extlen ; bool dataflag ; box = 0 ; tmpstream = 0 ;  if ( ! ( box = jas_malloc ( sizeof ( jp2_box_t ) ) ) ) {  goto error ; } box -> ops = & jp2_boxinfo_unk . ops ; if ( jp2_getuint32 ( in , & len ) || jp2_getuint32 ( in , & box -> type ) ) { goto error ; } boxinfo = jp2_boxinfolookup ( box -> type ) ; box -> info = boxinfo ; box -> len = len ; JAS_DBGLOG ( 10 , (  ""preliminary<S2SV_blank>processing<S2SV_blank>of<S2SV_blank>JP2<S2SV_blank>box:<S2SV_blank>type=%c%s%c<S2SV_blank>(0x%08x);<S2SV_blank>length=%d\\n"" ,  \'""\' , boxinfo -> name , \'""\' , box -> type , box -> len ) ) ;  if ( box -> len == 1 ) {  if ( jp2_getuint64 ( in , & extlen ) ) { goto error ; } if ( extlen > 0xffffffffUL ) { jas_eprintf ( ""warning:<S2SV_blank>cannot<S2SV_blank>handle<S2SV_blank>large<S2SV_blank>64-bit<S2SV_blank>box<S2SV_blank>length\\n"" ) ; extlen = 0xffffffffUL ; } box -> len = extlen ; box -> datalen = extlen - JP2_BOX_HDRLEN ( true ) ; } else { box -> datalen = box -> len - JP2_BOX_HDRLEN ( false ) ; } if ( box -> len != 0 && box -> len < 8 ) { goto error ; } dataflag = ! ( box -> info -> flags & ( JP2_BOX_SUPER | JP2_BOX_NODATA ) ) ; if ( dataflag ) { if ( ! ( tmpstream = jas_stream_memopen ( 0 , 0 ) ) ) { goto error ; } if ( jas_stream_copy ( tmpstream , in , box -> datalen ) ) { jas_eprintf ( ""cannot<S2SV_blank>copy<S2SV_blank>box<S2SV_blank>data\\n"" ) ; goto error ; } jas_stream_rewind ( tmpstream ) ; box -> ops = & boxinfo -> ops ; if ( box -> ops -> getdata ) { if ( ( * box -> ops -> getdata ) ( box , tmpstream ) ) { jas_eprintf ( ""cannot<S2SV_blank>parse<S2SV_blank>box<S2SV_blank>data\\n"" ) ; goto error ; } } jas_stream_close ( tmpstream ) ; } if ( jas_getdbglevel ( ) >= 1 ) { jp2_box_dump ( box , stderr ) ; } return box ; error : if ( box ) { jp2_box_destroy ( box ) ; } if ( tmpstream ) { jas_stream_close ( tmpstream ) ; } return 0 ; }","if ( ! ( box = jp2_box_create0 ( ) ) ) {goto error ;JAS_DBGLOG ( 10 , ( ""preliminary<S2SV_blank>processing<S2SV_blank>of<S2SV_blank>JP2<S2SV_blank>box:<S2SV_blank>"" ""type=%c%s%c<S2SV_blank>(0x%08x);<S2SV_blank>length=%"" PRIuFAST32 ""\\\if ( box -> len == 1 ) {JAS_DBGLOG ( 10 , ( ""big<S2SV_blank>length\\\if ( jp2_getuint64 ( in , & extlen ) ) {",304
421,"buggy line: static int  _Unpickler_ResizeMemoList ( UnpicklerObject * self , Py_ssize_t new_size )  {Py_ssize_t i ;assert ( new_size > self -> memo_size ) ;cwe id:CWE-190context: static int  _Unpickler_ResizeMemoList ( UnpicklerObject * self , Py_ssize_t new_size )  {  Py_ssize_t i ;  assert ( new_size > self -> memo_size ) ; PyObject * * memo_new = self -> memo ; PyMem_RESIZE ( memo_new , PyObject * , new_size ) ; if ( memo_new == NULL ) { PyErr_NoMemory ( ) ; return - 1 ; } self -> memo = memo_new ; for ( i = self -> memo_size ; i < new_size ; i ++ ) self -> memo [ i ] = NULL ; self -> memo_size = new_size ; return 0 ; }","static int _Unpickler_ResizeMemoList ( UnpicklerObject * self , size_t new_size ) {Py_ssize_t i ;assert ( new_size > self -> memo_size ) ;",305
422,"buggy line: int copylen ;bool zerocopy = false ;cwe id:CWE-119context: static ssize_t macvtap_get_user ( struct macvtap_queue * q , struct msghdr * m , const struct iovec * iv , unsigned long total_len , size_t count , int noblock ) { struct sk_buff * skb ; struct macvlan_dev * vlan ; unsigned long len = total_len ; int err ; struct virtio_net_hdr vnet_hdr = { 0 } ; int vnet_hdr_len = 0 ;  int copylen ;  bool zerocopy = false ; if ( q -> flags & IFF_VNET_HDR ) { vnet_hdr_len = q -> vnet_hdr_sz ; err = - EINVAL ; if ( len < vnet_hdr_len ) goto err ; len -= vnet_hdr_len ; err = memcpy_fromiovecend ( ( void * ) & vnet_hdr , iv , 0 , sizeof ( vnet_hdr ) ) ; if ( err < 0 ) goto err ; if ( ( vnet_hdr . flags & VIRTIO_NET_HDR_F_NEEDS_CSUM ) && vnet_hdr . csum_start + vnet_hdr . csum_offset + 2 > vnet_hdr . hdr_len ) vnet_hdr . hdr_len = vnet_hdr . csum_start + vnet_hdr . csum_offset + 2 ; err = - EINVAL ; if ( vnet_hdr . hdr_len > len ) goto err ; } err = - EINVAL ; if ( unlikely ( len < ETH_HLEN ) ) goto err ;  if ( m && m -> msg_control && sock_flag ( & q -> sk , SOCK_ZEROCOPY ) )  zerocopy = true ; if ( zerocopy ) {  copylen = vnet_hdr . hdr_len ;  if ( ! copylen ) copylen = GOODCOPY_LEN ; } else copylen = len ; skb = macvtap_alloc_skb ( & q -> sk , NET_IP_ALIGN , copylen , vnet_hdr . hdr_len , noblock , & err ) ; if ( ! skb ) goto err ; if ( zerocopy ) err = zerocopy_sg_from_iovec ( skb , iv , vnet_hdr_len , count ) ; else err = skb_copy_datagram_from_iovec ( skb , 0 , iv , vnet_hdr_len , len ) ; if ( err ) goto err_kfree ; skb_set_network_header ( skb , ETH_HLEN ) ; skb_reset_mac_header ( skb ) ; skb -> protocol = eth_hdr ( skb ) -> h_proto ; if ( vnet_hdr_len ) { err = macvtap_skb_from_vnet_hdr ( skb , & vnet_hdr ) ; if ( err ) goto err_kfree ; } rcu_read_lock_bh ( ) ; vlan = rcu_dereference_bh ( q -> vlan ) ; if ( zerocopy ) { skb_shinfo ( skb ) -> destructor_arg = m -> msg_control ; skb_shinfo ( skb ) -> tx_flags |= SKBTX_DEV_ZEROCOPY ; } if ( vlan ) macvlan_start_xmit ( skb , vlan -> dev ) ; else kfree_skb ( skb ) ; rcu_read_unlock_bh ( ) ; return total_len ; err_kfree : kfree_skb ( skb ) ; err : rcu_read_lock_bh ( ) ; vlan = rcu_dereference_bh ( q -> vlan ) ; if ( vlan ) vlan -> dev -> stats . tx_dropped ++ ; rcu_read_unlock_bh ( ) ; return err ; }",int copylen = 0 ;bool zerocopy = false ;err = - EMSGSIZE ;if ( unlikely ( count > UIO_MAXIOV ) ) goto err ;,306
423,"buggy line: if ( m && m -> msg_control && sock_flag ( & q -> sk , SOCK_ZEROCOPY ) )  zerocopy = true ;copylen = vnet_hdr . hdr_len ;if ( ! copylen ) copylen = GOODCOPY_LEN ;cwe id:CWE-119context: static ssize_t macvtap_get_user ( struct macvtap_queue * q , struct msghdr * m , const struct iovec * iv , unsigned long total_len , size_t count , int noblock ) { struct sk_buff * skb ; struct macvlan_dev * vlan ; unsigned long len = total_len ; int err ; struct virtio_net_hdr vnet_hdr = { 0 } ; int vnet_hdr_len = 0 ;  int copylen ;  bool zerocopy = false ; if ( q -> flags & IFF_VNET_HDR ) { vnet_hdr_len = q -> vnet_hdr_sz ; err = - EINVAL ; if ( len < vnet_hdr_len ) goto err ; len -= vnet_hdr_len ; err = memcpy_fromiovecend ( ( void * ) & vnet_hdr , iv , 0 , sizeof ( vnet_hdr ) ) ; if ( err < 0 ) goto err ; if ( ( vnet_hdr . flags & VIRTIO_NET_HDR_F_NEEDS_CSUM ) && vnet_hdr . csum_start + vnet_hdr . csum_offset + 2 > vnet_hdr . hdr_len ) vnet_hdr . hdr_len = vnet_hdr . csum_start + vnet_hdr . csum_offset + 2 ; err = - EINVAL ; if ( vnet_hdr . hdr_len > len ) goto err ; } err = - EINVAL ; if ( unlikely ( len < ETH_HLEN ) ) goto err ;  if ( m && m -> msg_control && sock_flag ( & q -> sk , SOCK_ZEROCOPY ) )  zerocopy = true ; if ( zerocopy ) {  copylen = vnet_hdr . hdr_len ;  if ( ! copylen ) copylen = GOODCOPY_LEN ; } else copylen = len ; skb = macvtap_alloc_skb ( & q -> sk , NET_IP_ALIGN , copylen , vnet_hdr . hdr_len , noblock , & err ) ; if ( ! skb ) goto err ; if ( zerocopy ) err = zerocopy_sg_from_iovec ( skb , iv , vnet_hdr_len , count ) ; else err = skb_copy_datagram_from_iovec ( skb , 0 , iv , vnet_hdr_len , len ) ; if ( err ) goto err_kfree ; skb_set_network_header ( skb , ETH_HLEN ) ; skb_reset_mac_header ( skb ) ; skb -> protocol = eth_hdr ( skb ) -> h_proto ; if ( vnet_hdr_len ) { err = macvtap_skb_from_vnet_hdr ( skb , & vnet_hdr ) ; if ( err ) goto err_kfree ; } rcu_read_lock_bh ( ) ; vlan = rcu_dereference_bh ( q -> vlan ) ; if ( zerocopy ) { skb_shinfo ( skb ) -> destructor_arg = m -> msg_control ; skb_shinfo ( skb ) -> tx_flags |= SKBTX_DEV_ZEROCOPY ; } if ( vlan ) macvlan_start_xmit ( skb , vlan -> dev ) ; else kfree_skb ( skb ) ; rcu_read_unlock_bh ( ) ; return total_len ; err_kfree : kfree_skb ( skb ) ; err : rcu_read_lock_bh ( ) ; vlan = rcu_dereference_bh ( q -> vlan ) ; if ( vlan ) vlan -> dev -> stats . tx_dropped ++ ; rcu_read_unlock_bh ( ) ; return err ; }","if ( m && m -> msg_control && sock_flag ( & q -> sk , SOCK_ZEROCOPY ) ) zerocopy = true ;if ( count > MAX_SKB_FRAGS ) {copylen = iov_length ( iv , count - MAX_SKB_FRAGS ) ;if ( copylen < vnet_hdr_len ) copylen = 0 ;else copylen -= vnet_hdr_len ;}if ( copylen < vnet_hdr . hdr_len ) copylen = vnet_hdr . hdr_len ;if ( ! copylen ) copylen = GOODCOPY_LEN ;",306
424,"buggy line: u16 offset = sizeof ( struct ipv6hdr ) ;struct ipv6_opt_hdr * exthdr = ( struct ipv6_opt_hdr * ) ( ipv6_hdr ( skb ) + 1 ) ;while ( offset + 1 <= packet_len ) {switch ( * * nexthdr ) {case NEXTHDR_HOP : break ;cwe id:CWE-125context: int ip6_find_1stfragopt ( struct sk_buff * skb , u8 * * nexthdr ) {  u16 offset = sizeof ( struct ipv6hdr ) ;  struct ipv6_opt_hdr * exthdr = ( struct ipv6_opt_hdr * ) ( ipv6_hdr ( skb ) + 1 ) ; unsigned int packet_len = skb_tail_pointer ( skb ) - skb_network_header ( skb ) ; int found_rhdr = 0 ; * nexthdr = & ipv6_hdr ( skb ) -> nexthdr ;  while ( offset + 1 <= packet_len ) {   switch ( * * nexthdr ) {  case NEXTHDR_HOP : break ; case NEXTHDR_ROUTING : found_rhdr = 1 ; break ; case NEXTHDR_DEST : # if IS_ENABLED ( CONFIG_IPV6_MIP6 ) if ( ipv6_find_tlv ( skb , offset , IPV6_TLV_HAO ) >= 0 ) break ; # endif if ( found_rhdr ) return offset ; break ; default : return offset ; }  offset += ipv6_optlen ( exthdr ) ;  * nexthdr = & exthdr -> nexthdr ;  exthdr = ( struct ipv6_opt_hdr * ) ( skb_network_header ( skb ) +  offset ) ; } return offset ; }",u16 offset = sizeof ( struct ipv6hdr ) ;while ( offset <= packet_len ) {struct ipv6_opt_hdr * exthdr ;switch ( * * nexthdr ) {case NEXTHDR_HOP : break ;,307
425,"buggy line: offset += ipv6_optlen ( exthdr ) ;* nexthdr = & exthdr -> nexthdr ;exthdr = ( struct ipv6_opt_hdr * ) ( skb_network_header ( skb ) +  offset ) ;return offset ;cwe id:CWE-125context: int ip6_find_1stfragopt ( struct sk_buff * skb , u8 * * nexthdr ) {  u16 offset = sizeof ( struct ipv6hdr ) ;  struct ipv6_opt_hdr * exthdr = ( struct ipv6_opt_hdr * ) ( ipv6_hdr ( skb ) + 1 ) ; unsigned int packet_len = skb_tail_pointer ( skb ) - skb_network_header ( skb ) ; int found_rhdr = 0 ; * nexthdr = & ipv6_hdr ( skb ) -> nexthdr ;  while ( offset + 1 <= packet_len ) {   switch ( * * nexthdr ) {  case NEXTHDR_HOP : break ; case NEXTHDR_ROUTING : found_rhdr = 1 ; break ; case NEXTHDR_DEST : # if IS_ENABLED ( CONFIG_IPV6_MIP6 ) if ( ipv6_find_tlv ( skb , offset , IPV6_TLV_HAO ) >= 0 ) break ; # endif if ( found_rhdr ) return offset ; break ; default : return offset ; }  offset += ipv6_optlen ( exthdr ) ;  * nexthdr = & exthdr -> nexthdr ;  exthdr = ( struct ipv6_opt_hdr * ) ( skb_network_header ( skb ) +  offset ) ; } return offset ; }",if ( offset + sizeof ( struct ipv6_opt_hdr ) > packet_len ) return - EINVAL ;exthdr = ( struct ipv6_opt_hdr * ) ( skb_network_header ( skb ) + offset ) ;offset += ipv6_optlen ( exthdr ) ;* nexthdr = & exthdr -> nexthdr ;return - EINVAL ;,307
426,"buggy line: static void write_delta_q ( struct vp9_write_bit_buffer * wb , int delta_q ) {if ( delta_q != 0 ) {vp9_wb_write_bit ( wb , 1 ) ;vp9_wb_write_literal ( wb , abs ( delta_q ) , 4 ) ;vp9_wb_write_bit ( wb , delta_q < 0 ) ;}vp9_wb_write_bit ( wb , 0 ) ;}cwe id:CWE-119context:  static void write_delta_q ( struct vp9_write_bit_buffer * wb , int delta_q ) {  if ( delta_q != 0 ) {  vp9_wb_write_bit ( wb , 1 ) ;   vp9_wb_write_literal ( wb , abs ( delta_q ) , 4 ) ;   vp9_wb_write_bit ( wb , delta_q < 0 ) ;  } else {  vp9_wb_write_bit ( wb , 0 ) ;  } }","static void write_delta_q ( struct vpx_write_bit_buffer * wb , int delta_q ) {if ( delta_q != 0 ) {vpx_wb_write_bit ( wb , 1 ) ;vpx_wb_write_literal ( wb , abs ( delta_q ) , 4 ) ;vpx_wb_write_bit ( wb , delta_q < 0 ) ;}vpx_wb_write_bit ( wb , 0 ) ;}",308
427,"buggy line: mv . as_mv . col = mvy [ vcnt / 2 ] ;find = 1 ;* sr = 0 ;cwe id:CWE-119context: void vp8_mv_pred ( VP8_COMP * cpi , MACROBLOCKD * xd , const MODE_INFO * here , int_mv * mvp , int refframe , int * ref_frame_sign_bias , int * sr , int near_sadidx [ ] ) { const MODE_INFO * above = here - xd -> mode_info_stride ; const MODE_INFO * left = here - 1 ; const MODE_INFO * aboveleft = above - 1 ; int_mv near_mvs [ 8 ] ; int near_ref [ 8 ] ; int_mv mv ; int vcnt = 0 ; int find = 0 ; int mb_offset ; int mvx [ 8 ] ; int mvy [ 8 ] ; int i ; mv . as_int = 0 ; if ( here -> mbmi . ref_frame != INTRA_FRAME ) { near_mvs [ 0 ] . as_int = near_mvs [ 1 ] . as_int = near_mvs [ 2 ] . as_int = near_mvs [ 3 ] . as_int = near_mvs [ 4 ] . as_int = near_mvs [ 5 ] . as_int = near_mvs [ 6 ] . as_int = near_mvs [ 7 ] . as_int = 0 ; near_ref [ 0 ] = near_ref [ 1 ] = near_ref [ 2 ] = near_ref [ 3 ] = near_ref [ 4 ] = near_ref [ 5 ] = near_ref [ 6 ] = near_ref [ 7 ] = 0 ; if ( above -> mbmi . ref_frame != INTRA_FRAME ) { near_mvs [ vcnt ] . as_int = above -> mbmi . mv . as_int ; mv_bias ( ref_frame_sign_bias [ above -> mbmi . ref_frame ] , refframe , & near_mvs [ vcnt ] , ref_frame_sign_bias ) ; near_ref [ vcnt ] = above -> mbmi . ref_frame ; } vcnt ++ ; if ( left -> mbmi . ref_frame != INTRA_FRAME ) { near_mvs [ vcnt ] . as_int = left -> mbmi . mv . as_int ; mv_bias ( ref_frame_sign_bias [ left -> mbmi . ref_frame ] , refframe , & near_mvs [ vcnt ] , ref_frame_sign_bias ) ; near_ref [ vcnt ] = left -> mbmi . ref_frame ; } vcnt ++ ; if ( aboveleft -> mbmi . ref_frame != INTRA_FRAME ) { near_mvs [ vcnt ] . as_int = aboveleft -> mbmi . mv . as_int ; mv_bias ( ref_frame_sign_bias [ aboveleft -> mbmi . ref_frame ] , refframe , & near_mvs [ vcnt ] , ref_frame_sign_bias ) ; near_ref [ vcnt ] = aboveleft -> mbmi . ref_frame ; } vcnt ++ ; if ( cpi -> common . last_frame_type != KEY_FRAME ) { mb_offset = ( - xd -> mb_to_top_edge / 128 + 1 ) * ( xd -> mode_info_stride + 1 ) + ( - xd -> mb_to_left_edge / 128 + 1 ) ; if ( cpi -> lf_ref_frame [ mb_offset ] != INTRA_FRAME ) { near_mvs [ vcnt ] . as_int = cpi -> lfmv [ mb_offset ] . as_int ; mv_bias ( cpi -> lf_ref_frame_sign_bias [ mb_offset ] , refframe , & near_mvs [ vcnt ] , ref_frame_sign_bias ) ; near_ref [ vcnt ] = cpi -> lf_ref_frame [ mb_offset ] ; } vcnt ++ ; if ( cpi -> lf_ref_frame [ mb_offset - xd -> mode_info_stride - 1 ] != INTRA_FRAME ) { near_mvs [ vcnt ] . as_int = cpi -> lfmv [ mb_offset - xd -> mode_info_stride - 1 ] . as_int ; mv_bias ( cpi -> lf_ref_frame_sign_bias [ mb_offset - xd -> mode_info_stride - 1 ] , refframe , & near_mvs [ vcnt ] , ref_frame_sign_bias ) ; near_ref [ vcnt ] = cpi -> lf_ref_frame [ mb_offset - xd -> mode_info_stride - 1 ] ; } vcnt ++ ; if ( cpi -> lf_ref_frame [ mb_offset - 1 ] != INTRA_FRAME ) { near_mvs [ vcnt ] . as_int = cpi -> lfmv [ mb_offset - 1 ] . as_int ; mv_bias ( cpi -> lf_ref_frame_sign_bias [ mb_offset - 1 ] , refframe , & near_mvs [ vcnt ] , ref_frame_sign_bias ) ; near_ref [ vcnt ] = cpi -> lf_ref_frame [ mb_offset - 1 ] ; } vcnt ++ ; if ( cpi -> lf_ref_frame [ mb_offset + 1 ] != INTRA_FRAME ) { near_mvs [ vcnt ] . as_int = cpi -> lfmv [ mb_offset + 1 ] . as_int ; mv_bias ( cpi -> lf_ref_frame_sign_bias [ mb_offset + 1 ] , refframe , & near_mvs [ vcnt ] , ref_frame_sign_bias ) ; near_ref [ vcnt ] = cpi -> lf_ref_frame [ mb_offset + 1 ] ; } vcnt ++ ; if ( cpi -> lf_ref_frame [ mb_offset + xd -> mode_info_stride + 1 ] != INTRA_FRAME ) { near_mvs [ vcnt ] . as_int = cpi -> lfmv [ mb_offset + xd -> mode_info_stride + 1 ] . as_int ; mv_bias ( cpi -> lf_ref_frame_sign_bias [ mb_offset + xd -> mode_info_stride + 1 ] , refframe , & near_mvs [ vcnt ] , ref_frame_sign_bias ) ; near_ref [ vcnt ] = cpi -> lf_ref_frame [ mb_offset + xd -> mode_info_stride + 1 ] ; } vcnt ++ ; } for ( i = 0 ; i < vcnt ; i ++ ) { if ( near_ref [ near_sadidx [ i ] ] != INTRA_FRAME ) { if ( here -> mbmi . ref_frame == near_ref [ near_sadidx [ i ] ] ) { mv . as_int = near_mvs [ near_sadidx [ i ] ] . as_int ; find = 1 ; if ( i < 3 ) * sr = 3 ; else * sr = 2 ; break ; } } } if ( ! find ) { for ( i = 0 ; i < vcnt ; i ++ ) { mvx [ i ] = near_mvs [ i ] . as_mv . row ; mvy [ i ] = near_mvs [ i ] . as_mv . col ; } insertsortmv ( mvx , vcnt ) ; insertsortmv ( mvy , vcnt ) ; mv . as_mv . row = mvx [ vcnt / 2 ] ; mv . as_mv . col = mvy [ vcnt / 2 ] ;  find = 1 ;  * sr = 0 ; } } mvp -> as_int = mv . as_int ; vp8_clamp_mv2 ( mvp , xd ) ; }",* sr = 0 ;,309
428,"buggy line: put_cmsg ( msg , SOL_PACKET , PACKET_AUXDATA , sizeof ( aux ) , & aux ) ;}cwe id:CWE-264context: static int packet_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct sk_buff * skb ; int copied , err ; struct sockaddr_ll * sll ; int vnet_hdr_len = 0 ; err = - EINVAL ; if ( flags & ~ ( MSG_PEEK | MSG_DONTWAIT | MSG_TRUNC | MSG_CMSG_COMPAT | MSG_ERRQUEUE ) ) goto out ; # if 0 if ( pkt_sk ( sk ) -> ifindex < 0 ) return - ENODEV ; # endif if ( flags & MSG_ERRQUEUE ) { err = packet_recv_error ( sk , msg , len ) ; goto out ; } skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out ; if ( pkt_sk ( sk ) -> has_vnet_hdr ) { struct virtio_net_hdr vnet_hdr = { 0 } ; err = - EINVAL ; vnet_hdr_len = sizeof ( vnet_hdr ) ; if ( len < vnet_hdr_len ) goto out_free ; len -= vnet_hdr_len ; if ( skb_is_gso ( skb ) ) { struct skb_shared_info * sinfo = skb_shinfo ( skb ) ; vnet_hdr . hdr_len = skb_headlen ( skb ) ; vnet_hdr . gso_size = sinfo -> gso_size ; if ( sinfo -> gso_type & SKB_GSO_TCPV4 ) vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_TCPV4 ; else if ( sinfo -> gso_type & SKB_GSO_TCPV6 ) vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_TCPV6 ; else if ( sinfo -> gso_type & SKB_GSO_UDP ) vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_UDP ; else if ( sinfo -> gso_type & SKB_GSO_FCOE ) goto out_free ; else BUG ( ) ; if ( sinfo -> gso_type & SKB_GSO_TCP_ECN ) vnet_hdr . gso_type |= VIRTIO_NET_HDR_GSO_ECN ; } else vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_NONE ; if ( skb -> ip_summed == CHECKSUM_PARTIAL ) { vnet_hdr . flags = VIRTIO_NET_HDR_F_NEEDS_CSUM ; vnet_hdr . csum_start = skb_checksum_start_offset ( skb ) ; vnet_hdr . csum_offset = skb -> csum_offset ; } err = memcpy_toiovec ( msg -> msg_iov , ( void * ) & vnet_hdr , vnet_hdr_len ) ; if ( err < 0 ) goto out_free ; } sll = & PACKET_SKB_CB ( skb ) -> sa . ll ; if ( sock -> type == SOCK_PACKET ) msg -> msg_namelen = sizeof ( struct sockaddr_pkt ) ; else msg -> msg_namelen = sll -> sll_halen + offsetof ( struct sockaddr_ll , sll_addr ) ; copied = skb -> len ; if ( copied > len ) { copied = len ; msg -> msg_flags |= MSG_TRUNC ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto out_free ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( msg -> msg_name ) memcpy ( msg -> msg_name , & PACKET_SKB_CB ( skb ) -> sa , msg -> msg_namelen ) ; if ( pkt_sk ( sk ) -> auxdata ) { struct tpacket_auxdata aux ; aux . tp_status = TP_STATUS_USER ; if ( skb -> ip_summed == CHECKSUM_PARTIAL ) aux . tp_status |= TP_STATUS_CSUMNOTREADY ; aux . tp_len = PACKET_SKB_CB ( skb ) -> origlen ; aux . tp_snaplen = skb -> len ; aux . tp_mac = 0 ; aux . tp_net = skb_network_offset ( skb ) ; if ( vlan_tx_tag_present ( skb ) ) { aux . tp_vlan_tci = vlan_tx_tag_get ( skb ) ; aux . tp_status |= TP_STATUS_VLAN_VALID ; } else { aux . tp_vlan_tci = 0 ; }  put_cmsg ( msg , SOL_PACKET , PACKET_AUXDATA , sizeof ( aux ) , & aux ) ;  } err = vnet_hdr_len + ( ( flags & MSG_TRUNC ) ? skb -> len : copied ) ; out_free : skb_free_datagram ( sk , skb ) ; out : return err ; }","aux . tp_padding = 0 ;put_cmsg ( msg , SOL_PACKET , PACKET_AUXDATA , sizeof ( aux ) , & aux ) ;}",310
429,"buggy line: }if ( ( dj_report -> device_index < DJ_DEVICE_INDEX_MIN ) ||  ( dj_report -> device_index > DJ_DEVICE_INDEX_MAX ) ) {dev_err ( & djrcv_hdev -> dev , ""%s:<S2SV_blank>invalid<S2SV_blank>device<S2SV_blank>index:%d\\\return ;cwe id:CWE-119context: static void logi_dj_recv_add_djhid_device ( struct dj_receiver_dev * djrcv_dev , struct dj_report * dj_report ) { struct hid_device * djrcv_hdev = djrcv_dev -> hdev ; struct usb_interface * intf = to_usb_interface ( djrcv_hdev -> dev . parent ) ; struct usb_device * usbdev = interface_to_usbdev ( intf ) ; struct hid_device * dj_hiddev ; struct dj_device * dj_dev ; unsigned char tmpstr [ 3 ] ; if ( dj_report -> report_params [ DEVICE_PAIRED_PARAM_SPFUNCTION ] & SPFUNCTION_DEVICE_LIST_EMPTY ) { dbg_hid ( ""%s:<S2SV_blank>device<S2SV_blank>list<S2SV_blank>is<S2SV_blank>empty\\n"" , __func__ ) ; djrcv_dev -> querying_devices = false ; return ; }  if ( ( dj_report -> device_index < DJ_DEVICE_INDEX_MIN ) ||  ( dj_report -> device_index > DJ_DEVICE_INDEX_MAX ) ) { dev_err ( & djrcv_hdev -> dev , ""%s:<S2SV_blank>invalid<S2SV_blank>device<S2SV_blank>index:%d\\n"" , __func__ , dj_report -> device_index ) ; return ; } if ( djrcv_dev -> paired_dj_devices [ dj_report -> device_index ] ) { dbg_hid ( ""%s:<S2SV_blank>device<S2SV_blank>is<S2SV_blank>already<S2SV_blank>known\\n"" , __func__ ) ; return ; } dj_hiddev = hid_allocate_device ( ) ; if ( IS_ERR ( dj_hiddev ) ) { dev_err ( & djrcv_hdev -> dev , ""%s:<S2SV_blank>hid_allocate_device<S2SV_blank>failed\\n"" , __func__ ) ; return ; } dj_hiddev -> ll_driver = & logi_dj_ll_driver ; dj_hiddev -> dev . parent = & djrcv_hdev -> dev ; dj_hiddev -> bus = BUS_USB ; dj_hiddev -> vendor = le16_to_cpu ( usbdev -> descriptor . idVendor ) ; dj_hiddev -> product = le16_to_cpu ( usbdev -> descriptor . idProduct ) ; snprintf ( dj_hiddev -> name , sizeof ( dj_hiddev -> name ) , ""Logitech<S2SV_blank>Unifying<S2SV_blank>Device.<S2SV_blank>Wireless<S2SV_blank>PID:%02x%02x"" , dj_report -> report_params [ DEVICE_PAIRED_PARAM_EQUAD_ID_MSB ] , dj_report -> report_params [ DEVICE_PAIRED_PARAM_EQUAD_ID_LSB ] ) ; usb_make_path ( usbdev , dj_hiddev -> phys , sizeof ( dj_hiddev -> phys ) ) ; snprintf ( tmpstr , sizeof ( tmpstr ) , "":%d"" , dj_report -> device_index ) ; strlcat ( dj_hiddev -> phys , tmpstr , sizeof ( dj_hiddev -> phys ) ) ; dj_dev = kzalloc ( sizeof ( struct dj_device ) , GFP_KERNEL ) ; if ( ! dj_dev ) { dev_err ( & djrcv_hdev -> dev , ""%s:<S2SV_blank>failed<S2SV_blank>allocating<S2SV_blank>dj_device\\n"" , __func__ ) ; goto dj_device_allocate_fail ; } dj_dev -> reports_supported = get_unaligned_le32 ( dj_report -> report_params + DEVICE_PAIRED_RF_REPORT_TYPE ) ; dj_dev -> hdev = dj_hiddev ; dj_dev -> dj_receiver_dev = djrcv_dev ; dj_dev -> device_index = dj_report -> device_index ; dj_hiddev -> driver_data = dj_dev ; djrcv_dev -> paired_dj_devices [ dj_report -> device_index ] = dj_dev ; if ( hid_add_device ( dj_hiddev ) ) { dev_err ( & djrcv_hdev -> dev , ""%s:<S2SV_blank>failed<S2SV_blank>adding<S2SV_blank>dj_device\\n"" , __func__ ) ; goto hid_add_device_fail ; } return ; hid_add_device_fail : djrcv_dev -> paired_dj_devices [ dj_report -> device_index ] = NULL ; kfree ( dj_dev ) ; dj_device_allocate_fail : hid_destroy_device ( dj_hiddev ) ; }","
",311
430,"buggy line: duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\\return - EINVAL ;}err = check_entry ( e ) ;if ( err ) return err ;for ( h = 0 ;h < NF_ARP_NUMHOOKS ;h ++ ) {if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ;if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ;if ( ( unsigned char * ) e - base == underflows [ h ] ) {if ( ! check_underflow ( e ) ) {pr_err ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>""  ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"" ""ACCEPT/DROP\\\cwe id:CWE-119context: static inline int check_entry_size_and_hooks ( struct arpt_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct arpt_entry ) != 0 || ( unsigned char * ) e + sizeof ( struct arpt_entry ) >= limit || ( unsigned char * ) e + e -> next_offset > limit ) { duprintf ( ""Bad<S2SV_blank>offset<S2SV_blank>%p\\n"" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct arpt_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\n"" , e , e -> next_offset ) ; return - EINVAL ; } err = check_entry ( e ) ; if ( err ) return err ; for ( h = 0 ; h < NF_ARP_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) {  pr_err ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>""  ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"" ""ACCEPT/DROP\\n"" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows [ h ] ; } } e -> counters = ( ( struct xt_counters ) { 0 , 0 } ) ; e -> comefrom = 0 ; return 0 ; }","pr_debug ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>"" ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"" ""ACCEPT/DROP\\\",312
431,"buggy line: int bson_check_field_name ( bson * b , const char * string ,  const int length ) {return bson_validate_string ( b , ( const unsigned char * ) string , length , 1 , 1 , 1 ) ;cwe id:CWE-190context: int bson_check_field_name ( bson * b , const char * string ,  const int length ) {  return bson_validate_string ( b , ( const unsigned char * ) string , length , 1 , 1 , 1 ) ; }","int bson_check_field_name ( bson * b , const char * string , const size_t length ) {return bson_validate_string ( b , ( const unsigned char * ) string , length , 1 , 1 , 1 ) ;",313
432,"buggy line: sctp_addiphdr_t * hdr ;union sctp_addr_param * addr_param ;int all_param_pass = 1 ;chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ;cwe id:CWE-20context: struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) {  sctp_addiphdr_t * hdr ;  union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ;  int all_param_pass = 1 ;  chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ;  while ( chunk_len > 0 ) {  err_code = sctp_process_asconf_param ( asoc , asconf ,  asconf_param ) ;  if ( SCTP_ERROR_NO_ERROR != err_code )  all_param_pass = 0 ;  if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack ,  asconf_param -> crr_id , err_code ,  asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ;  length = ntohs ( asconf_param -> param_hdr . length ) ;  asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }",sctp_addip_chunk_t * addip = ( sctp_addip_chunk_t * ) asconf -> chunk_hdr ;bool all_param_pass = true ;union sctp_params param ;sctp_addiphdr_t * hdr ;union sctp_addr_param * addr_param ;chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ;,314
433,"buggy line: while ( chunk_len > 0 ) {err_code = sctp_process_asconf_param ( asoc , asconf ,  asconf_param ) ;if ( SCTP_ERROR_NO_ERROR != err_code )  all_param_pass = 0 ;if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack ,  asconf_param -> crr_id , err_code ,  asconf_param ) ;length = ntohs ( asconf_param -> param_hdr . length ) ;asconf_param = ( void * ) asconf_param + length ;chunk_len -= length ;cwe id:CWE-20context: struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) {  sctp_addiphdr_t * hdr ;  union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ;  int all_param_pass = 1 ;  chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ;  while ( chunk_len > 0 ) {  err_code = sctp_process_asconf_param ( asoc , asconf ,  asconf_param ) ;  if ( SCTP_ERROR_NO_ERROR != err_code )  all_param_pass = 0 ;  if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack ,  asconf_param -> crr_id , err_code ,  asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ;  length = ntohs ( asconf_param -> param_hdr . length ) ;  asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }","sctp_walk_params ( param , addip , addip_hdr . params ) {if ( param . p -> type == SCTP_PARAM_IPV4_ADDRESS || param . p -> type == SCTP_PARAM_IPV6_ADDRESS ) continue ;err_code = sctp_process_asconf_param ( asoc , asconf , param . addip ) ;if ( err_code != SCTP_ERROR_NO_ERROR ) all_param_pass = 0 ;if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , param . addip -> crr_id , err_code , asconf_param ) ;",314
434,"buggy line: JAS_DBGLOG ( 101 , ( ""jas_realloc<S2SV_blank>called<S2SV_blank>with<S2SV_blank>%x,%zu\\\result = realloc ( ptr , size ) ;cwe id:CWE-190context: void * jas_realloc ( void * ptr , size_t size ) { void * result ;  JAS_DBGLOG ( 101 , ( ""jas_realloc<S2SV_blank>called<S2SV_blank>with<S2SV_blank>%x,%zu\\n"" , ptr , size ) ) ;  result = realloc ( ptr , size ) ; JAS_DBGLOG ( 100 , ( ""jas_realloc(%p,<S2SV_blank>%zu)<S2SV_blank>-><S2SV_blank>%p\\n"" , ptr , size , result ) ) ; return result ; }","JAS_DBGLOG ( 101 , ( ""jas_realloc(%x,<S2SV_blank>%zu)\\\result = realloc ( ptr , size ) ;",315
435,"buggy line: m -> msg_namelen = 0 ;timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ;cwe id:CWE-20context: static int recv_msg ( struct kiocb * iocb , struct socket * sock , struct msghdr * m , size_t buf_len , int flags ) { struct sock * sk = sock -> sk ; struct tipc_port * tport = tipc_sk_port ( sk ) ; struct sk_buff * buf ; struct tipc_msg * msg ; long timeout ; unsigned int sz ; u32 err ; int res ; if ( unlikely ( ! buf_len ) ) return - EINVAL ; lock_sock ( sk ) ; if ( unlikely ( sock -> state == SS_UNCONNECTED ) ) { res = - ENOTCONN ; goto exit ; }  m -> msg_namelen = 0 ;  timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; restart : while ( skb_queue_empty ( & sk -> sk_receive_queue ) ) { if ( sock -> state == SS_DISCONNECTING ) { res = - ENOTCONN ; goto exit ; } if ( timeout <= 0L ) { res = timeout ? timeout : - EWOULDBLOCK ; goto exit ; } release_sock ( sk ) ; timeout = wait_event_interruptible_timeout ( * sk_sleep ( sk ) , tipc_rx_ready ( sock ) , timeout ) ; lock_sock ( sk ) ; } buf = skb_peek ( & sk -> sk_receive_queue ) ; msg = buf_msg ( buf ) ; sz = msg_data_sz ( msg ) ; err = msg_errcode ( msg ) ; if ( ( ! sz ) && ( ! err ) ) { advance_rx_queue ( sk ) ; goto restart ; } set_orig_addr ( m , msg ) ; res = anc_data_recv ( m , msg , tport ) ; if ( res ) goto exit ; if ( ! err ) { if ( unlikely ( buf_len < sz ) ) { sz = buf_len ; m -> msg_flags |= MSG_TRUNC ; } res = skb_copy_datagram_iovec ( buf , msg_hdr_sz ( msg ) , m -> msg_iov , sz ) ; if ( res ) goto exit ; res = sz ; } else { if ( ( sock -> state == SS_READY ) || ( ( err == TIPC_CONN_SHUTDOWN ) || m -> msg_control ) ) res = 0 ; else res = - ECONNRESET ; } if ( likely ( ! ( flags & MSG_PEEK ) ) ) { if ( ( sock -> state != SS_READY ) && ( ++ tport -> conn_unacked >= TIPC_FLOW_CONTROL_WIN ) ) tipc_acknowledge ( tport -> ref , tport -> conn_unacked ) ; advance_rx_queue ( sk ) ; } exit : release_sock ( sk ) ; return res ; }","timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ;",316
436,"buggy line: # endif case KVM_CAP_PPC_HTM : r = cpu_has_feature ( CPU_FTR_TM_COMP ) &&  is_kvmppc_hv_enabled ( kvm ) ;break ;cwe id:CWE-476context: int kvm_vm_ioctl_check_extension ( struct kvm * kvm , long ext ) { int r ; int hv_enabled = kvmppc_hv_ops ? 1 : 0 ; if ( kvm ) { hv_enabled = is_kvmppc_hv_enabled ( kvm ) ; } switch ( ext ) { # ifdef CONFIG_BOOKE case KVM_CAP_PPC_BOOKE_SREGS : case KVM_CAP_PPC_BOOKE_WATCHDOG : case KVM_CAP_PPC_EPR : # else case KVM_CAP_PPC_SEGSTATE : case KVM_CAP_PPC_HIOR : case KVM_CAP_PPC_PAPR : # endif case KVM_CAP_PPC_UNSET_IRQ : case KVM_CAP_PPC_IRQ_LEVEL : case KVM_CAP_ENABLE_CAP : case KVM_CAP_ENABLE_CAP_VM : case KVM_CAP_ONE_REG : case KVM_CAP_IOEVENTFD : case KVM_CAP_DEVICE_CTRL : case KVM_CAP_IMMEDIATE_EXIT : r = 1 ; break ; case KVM_CAP_PPC_PAIRED_SINGLES : case KVM_CAP_PPC_OSI : case KVM_CAP_PPC_GET_PVINFO : # if defined ( CONFIG_KVM_E500V2 ) || defined ( CONFIG_KVM_E500MC ) case KVM_CAP_SW_TLB : # endif r = ! hv_enabled ; break ; # ifdef CONFIG_KVM_MPIC case KVM_CAP_IRQ_MPIC : r = 1 ; break ; # endif # ifdef CONFIG_PPC_BOOK3S_64 case KVM_CAP_SPAPR_TCE : case KVM_CAP_SPAPR_TCE_64 : case KVM_CAP_SPAPR_TCE_VFIO : case KVM_CAP_PPC_RTAS : case KVM_CAP_PPC_FIXUP_HCALL : case KVM_CAP_PPC_ENABLE_HCALL : # ifdef CONFIG_KVM_XICS case KVM_CAP_IRQ_XICS : # endif r = 1 ; break ; case KVM_CAP_PPC_ALLOC_HTAB : r = hv_enabled ; break ; # endif # ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE case KVM_CAP_PPC_SMT : r = 0 ; if ( kvm ) { if ( kvm -> arch . emul_smt_mode > 1 ) r = kvm -> arch . emul_smt_mode ; else r = kvm -> arch . smt_mode ; } else if ( hv_enabled ) { if ( cpu_has_feature ( CPU_FTR_ARCH_300 ) ) r = 1 ; else r = threads_per_subcore ; } break ; case KVM_CAP_PPC_SMT_POSSIBLE : r = 1 ; if ( hv_enabled ) { if ( ! cpu_has_feature ( CPU_FTR_ARCH_300 ) ) r = ( ( threads_per_subcore << 1 ) - 1 ) ; else r = 8 | 4 | 2 | 1 ; } break ; case KVM_CAP_PPC_RMA : r = 0 ; break ; case KVM_CAP_PPC_HWRNG : r = kvmppc_hwrng_present ( ) ; break ; case KVM_CAP_PPC_MMU_RADIX : r = ! ! ( hv_enabled && radix_enabled ( ) ) ; break ; case KVM_CAP_PPC_MMU_HASH_V3 : r = ! ! ( hv_enabled && ! radix_enabled ( ) && cpu_has_feature ( CPU_FTR_ARCH_300 ) ) ; break ; # endif case KVM_CAP_SYNC_MMU : # ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE r = hv_enabled ; # elif defined ( KVM_ARCH_WANT_MMU_NOTIFIER ) r = 1 ; # else r = 0 ; # endif break ; # ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE case KVM_CAP_PPC_HTAB_FD : r = hv_enabled ; break ; # endif case KVM_CAP_NR_VCPUS : if ( hv_enabled ) r = num_present_cpus ( ) ; else r = num_online_cpus ( ) ; break ; case KVM_CAP_NR_MEMSLOTS : r = KVM_USER_MEM_SLOTS ; break ; case KVM_CAP_MAX_VCPUS : r = KVM_MAX_VCPUS ; break ; # ifdef CONFIG_PPC_BOOK3S_64 case KVM_CAP_PPC_GET_SMMU_INFO : r = 1 ; break ; case KVM_CAP_SPAPR_MULTITCE : r = 1 ; break ; case KVM_CAP_SPAPR_RESIZE_HPT : r = ! ! hv_enabled && ! cpu_has_feature ( CPU_FTR_ARCH_300 ) ; break ; # endif # ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE case KVM_CAP_PPC_FWNMI : r = hv_enabled ; break ; # endif case KVM_CAP_PPC_HTM : r = cpu_has_feature ( CPU_FTR_TM_COMP ) &&  is_kvmppc_hv_enabled ( kvm ) ;  break ; default : r = 0 ; break ; } return r ; }",# endif case KVM_CAP_PPC_HTM : r = cpu_has_feature ( CPU_FTR_TM_COMP ) && hv_enabled ;break ;,317
437,"buggy line: pci_populate_msicap ( & msicap , msgnum , 0 ) ;return pci_emul_add_capability ( dev , ( u_char * ) & msicap , sizeof ( msicap ) ) ;cwe id:CWE-617context: int pci_emul_add_msicap ( struct pci_vdev * dev , int msgnum ) { struct msicap msicap ;  pci_populate_msicap ( & msicap , msgnum , 0 ) ;  return pci_emul_add_capability ( dev , ( u_char * ) & msicap , sizeof ( msicap ) ) ; }","return pci_populate_msicap ( & msicap , msgnum , 0 ) || pci_emul_add_capability ( dev , ( u_char * ) & msicap , sizeof ( msicap ) ) ;",318
438,"buggy line: keylen = utf8s_to_utf16s ( key_name , strlen ( key_name ) ,   ( wchar_t * ) kvp_data -> data . key ) ;kvp_data -> data . key_size = 2 * ( keylen + 1 ) ;valuelen = utf8s_to_utf16s ( value , strlen ( value ) ,   ( wchar_t * ) kvp_data -> data . value ) ;kvp_data -> data . value_size = 2 * ( valuelen + 1 ) ;cwe id:CWE-119context: static void kvp_respond_to_host ( char * key , char * value , int error ) { struct hv_kvp_msg * kvp_msg ; struct hv_kvp_msg_enumerate * kvp_data ; char * key_name ; struct icmsg_hdr * icmsghdrp ; int keylen , valuelen ; u32 buf_len ; struct vmbus_channel * channel ; u64 req_id ; if ( ! kvp_transaction . active ) { pr_warn ( ""KVP:<S2SV_blank>Transaction<S2SV_blank>not<S2SV_blank>active\\n"" ) ; return ; } buf_len = kvp_transaction . recv_len ; channel = kvp_transaction . recv_channel ; req_id = kvp_transaction . recv_req_id ; kvp_transaction . active = false ; if ( channel -> onchannel_callback == NULL ) return ; icmsghdrp = ( struct icmsg_hdr * ) & recv_buffer [ sizeof ( struct vmbuspipe_hdr ) ] ; kvp_msg = ( struct hv_kvp_msg * ) & recv_buffer [ sizeof ( struct vmbuspipe_hdr ) + sizeof ( struct icmsg_hdr ) ] ; kvp_data = & kvp_msg -> kvp_data ; key_name = key ; if ( error ) { icmsghdrp -> status = HV_E_FAIL ; goto response_done ; }  keylen = utf8s_to_utf16s ( key_name , strlen ( key_name ) ,   ( wchar_t * ) kvp_data -> data . key ) ;  kvp_data -> data . key_size = 2 * ( keylen + 1 ) ;  valuelen = utf8s_to_utf16s ( value , strlen ( value ) ,   ( wchar_t * ) kvp_data -> data . value ) ;  kvp_data -> data . value_size = 2 * ( valuelen + 1 ) ; kvp_data -> data . value_type = REG_SZ ; icmsghdrp -> status = HV_S_OK ; response_done : icmsghdrp -> icflags = ICMSGHDRFLAG_TRANSACTION | ICMSGHDRFLAG_RESPONSE ; vmbus_sendpacket ( channel , recv_buffer , buf_len , req_id , VM_PKT_DATA_INBAND , 0 ) ; }","keylen = utf8s_to_utf16s ( key_name , strlen ( key_name ) , UTF16_HOST_ENDIAN , ( wchar_t * ) kvp_data -> data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE / 2 ) ;kvp_data -> data . key_size = 2 * ( keylen + 1 ) ;valuelen = utf8s_to_utf16s ( value , strlen ( value ) , UTF16_HOST_ENDIAN , ( wchar_t * ) kvp_data -> data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE / 2 ) ;kvp_data -> data . value_size = 2 * ( valuelen + 1 ) ;",319
439,"buggy line: ctx = d -> log_ctx ;d -> log_ctx = eventfp ? eventfd_ctx_fileget ( eventfp ) : NULL ;cwe id:CWE-399context: long vhost_dev_ioctl ( struct vhost_dev * d , unsigned int ioctl , void __user * argp ) { struct file * eventfp , * filep = NULL ; struct eventfd_ctx * ctx = NULL ; u64 p ; long r ; int i , fd ; if ( ioctl == VHOST_SET_OWNER ) { r = vhost_dev_set_owner ( d ) ; goto done ; } r = vhost_dev_check_owner ( d ) ; if ( r ) goto done ; switch ( ioctl ) { case VHOST_SET_MEM_TABLE : r = vhost_set_memory ( d , argp ) ; break ; case VHOST_SET_LOG_BASE : if ( copy_from_user ( & p , argp , sizeof p ) ) { r = - EFAULT ; break ; } if ( ( u64 ) ( unsigned long ) p != p ) { r = - EFAULT ; break ; } for ( i = 0 ; i < d -> nvqs ; ++ i ) { struct vhost_virtqueue * vq ; void __user * base = ( void __user * ) ( unsigned long ) p ; vq = d -> vqs [ i ] ; mutex_lock ( & vq -> mutex ) ; if ( vq -> private_data && ! vq_log_access_ok ( vq , base ) ) r = - EFAULT ; else vq -> log_base = base ; mutex_unlock ( & vq -> mutex ) ; } break ; case VHOST_SET_LOG_FD : r = get_user ( fd , ( int __user * ) argp ) ; if ( r < 0 ) break ; eventfp = fd == - 1 ? NULL : eventfd_fget ( fd ) ; if ( IS_ERR ( eventfp ) ) { r = PTR_ERR ( eventfp ) ; break ; } if ( eventfp != d -> log_file ) { filep = d -> log_file ;  ctx = d -> log_ctx ;  d -> log_ctx = eventfp ? eventfd_ctx_fileget ( eventfp ) : NULL ; } else filep = eventfp ; for ( i = 0 ; i < d -> nvqs ; ++ i ) { mutex_lock ( & d -> vqs [ i ] -> mutex ) ; d -> vqs [ i ] -> log_ctx = d -> log_ctx ; mutex_unlock ( & d -> vqs [ i ] -> mutex ) ; } if ( ctx ) eventfd_ctx_put ( ctx ) ; if ( filep ) fput ( filep ) ; break ; default : r = - ENOIOCTLCMD ; break ; } done : return r ; }",d -> log_file = eventfp ;ctx = d -> log_ctx ;d -> log_ctx = eventfp ? eventfd_ctx_fileget ( eventfp ) : NULL ;,320
440,"buggy line: if ( ( img -> comps [ 0 ] . dx == 1 ) && ( img -> comps [ 1 ] . dx == 2 ) && ( img -> comps [ 2 ] . dx == 2 ) && ( img -> comps [ 0 ] . dy == 1 ) && ( img -> comps [ 1 ] . dy == 2 ) && ( img -> comps [ 2 ] . dy == 2 ) ) {sycc420_to_rgb ( img ) ;else if ( ( img -> comps [ 0 ] . dx == 1 ) && ( img -> comps [ 1 ] . dx == 2 ) && ( img -> comps [ 2 ] . dx == 2 ) && ( img -> comps [ 0 ] . dy == 1 ) && ( img -> comps [ 1 ] . dy == 1 ) && ( img -> comps [ 2 ] . dy == 1 ) ) {sycc422_to_rgb ( img ) ;}else if ( ( img -> comps [ 0 ] . dx == 1 ) && ( img -> comps [ 1 ] . dx == 1 ) && ( img -> comps [ 2 ] . dx == 1 ) && ( img -> comps [ 0 ] . dy == 1 ) && ( img -> comps [ 1 ] . dy == 1 ) && ( img -> comps [ 2 ] . dy == 1 ) ) {sycc444_to_rgb ( img ) ;}else {fprintf ( stderr , ""%s:%d:color_sycc_to_rgb\\\return ;}img -> color_space = OPJ_CLRSPC_SRGB ;}cwe id:CWE-125context: void color_sycc_to_rgb ( opj_image_t * img ) { if ( img -> numcomps < 3 ) { img -> color_space = OPJ_CLRSPC_GRAY ; return ; } if ( ( img -> comps [ 0 ] . dx == 1 ) && ( img -> comps [ 1 ] . dx == 2 ) && ( img -> comps [ 2 ] . dx == 2 ) && ( img -> comps [ 0 ] . dy == 1 ) && ( img -> comps [ 1 ] . dy == 2 ) && ( img -> comps [ 2 ] . dy == 2 ) ) { sycc420_to_rgb ( img ) ; } else if ( ( img -> comps [ 0 ] . dx == 1 ) && ( img -> comps [ 1 ] . dx == 2 ) && ( img -> comps [ 2 ] . dx == 2 ) && ( img -> comps [ 0 ] . dy == 1 ) && ( img -> comps [ 1 ] . dy == 1 ) && ( img -> comps [ 2 ] . dy == 1 ) ) { sycc422_to_rgb ( img ) ; } else if ( ( img -> comps [ 0 ] . dx == 1 ) && ( img -> comps [ 1 ] . dx == 1 ) && ( img -> comps [ 2 ] . dx == 1 ) && ( img -> comps [ 0 ] . dy == 1 ) && ( img -> comps [ 1 ] . dy == 1 ) && ( img -> comps [ 2 ] . dy == 1 ) ) { sycc444_to_rgb ( img ) ; } else { fprintf ( stderr , ""%s:%d:color_sycc_to_rgb\\n\\tCAN<S2SV_blank>NOT<S2SV_blank>CONVERT\\n"" , __FILE__ , __LINE__ ) ; return ; }  img -> color_space = OPJ_CLRSPC_SRGB ;  }","
",321
441,"buggy line: void * parg = NULL ;long err = - EINVAL ;int is_ext_ctrl ;size_t ctrls_size = 0 ;void __user * user_ptr = NULL ;is_ext_ctrl = ( cmd == VIDIOC_S_EXT_CTRLS || cmd == VIDIOC_G_EXT_CTRLS || cmd == VIDIOC_TRY_EXT_CTRLS ) ;switch ( _IOC_DIR ( cmd ) ) {case _IOC_NONE :  parg = NULL ;case _IOC_READ :  case _IOC_WRITE :  case ( _IOC_WRITE | _IOC_READ ) :  if ( _IOC_SIZE ( cmd ) <= sizeof ( sbuf ) ) {parg = sbuf ;cwe id:CWE-399context: long video_usercopy ( struct file * file , unsigned int cmd , unsigned long arg , v4l2_kioctl func ) { char sbuf [ 128 ] ; void * mbuf = NULL ;  void * parg = NULL ;  long err = - EINVAL ;  int is_ext_ctrl ;  size_t ctrls_size = 0 ; void __user * user_ptr = NULL ; is_ext_ctrl = ( cmd == VIDIOC_S_EXT_CTRLS || cmd == VIDIOC_G_EXT_CTRLS || cmd == VIDIOC_TRY_EXT_CTRLS ) ; switch ( _IOC_DIR ( cmd ) ) {  case _IOC_NONE :  parg = NULL ; break ; case _IOC_READ :  case _IOC_WRITE :  case ( _IOC_WRITE | _IOC_READ ) :  if ( _IOC_SIZE ( cmd ) <= sizeof ( sbuf ) ) {  parg = sbuf ; } else { mbuf = kmalloc ( _IOC_SIZE ( cmd ) , GFP_KERNEL ) ; if ( NULL == mbuf ) return - ENOMEM ; parg = mbuf ; } err = - EFAULT ; if ( _IOC_DIR ( cmd ) & _IOC_WRITE ) if ( copy_from_user ( parg , ( void __user * ) arg , _IOC_SIZE ( cmd ) ) ) goto out ; break ; } if ( is_ext_ctrl ) { struct v4l2_ext_controls * p = parg ; p -> error_idx = p -> count ; user_ptr = ( void __user * ) p -> controls ; if ( p -> count ) { ctrls_size = sizeof ( struct v4l2_ext_control ) * p -> count ; mbuf = kmalloc ( ctrls_size , GFP_KERNEL ) ; err = - ENOMEM ; if ( NULL == mbuf ) goto out_ext_ctrl ; err = - EFAULT ; if ( copy_from_user ( mbuf , user_ptr , ctrls_size ) ) goto out_ext_ctrl ; p -> controls = mbuf ; } } err = func ( file , cmd , parg ) ; if ( err == - ENOIOCTLCMD ) err = - EINVAL ; if ( is_ext_ctrl ) { struct v4l2_ext_controls * p = parg ; p -> controls = ( void * ) user_ptr ; if ( p -> count && err == 0 && copy_to_user ( user_ptr , mbuf , ctrls_size ) ) err = - EFAULT ; goto out_ext_ctrl ; } if ( err < 0 ) goto out ; out_ext_ctrl : switch ( _IOC_DIR ( cmd ) ) { case _IOC_READ : case ( _IOC_WRITE | _IOC_READ ) : if ( copy_to_user ( ( void __user * ) arg , parg , _IOC_SIZE ( cmd ) ) ) err = - EFAULT ; break ; } out : kfree ( mbuf ) ; return err ; }","void * parg = ( void * ) arg ;long err = - EINVAL ;if ( has_array_args ) {* kernel_ptr = user_ptr ;if ( copy_to_user ( user_ptr , mbuf , array_size ) ) err = - EFAULT ;goto out_array_args ;}if ( err < 0 ) goto out ;out_array_args : switch ( _IOC_DIR ( cmd ) ) {case _IOC_NONE : parg = NULL ;case _IOC_READ : case _IOC_WRITE : case ( _IOC_WRITE | _IOC_READ ) : if ( _IOC_SIZE ( cmd ) <= sizeof ( sbuf ) ) {parg = sbuf ;",322
442,"buggy line: if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) {addReplyError ( c , ""operation<S2SV_blank>not<S2SV_blank>permitted"" ) ;return REDIS_OK ;}if ( server . maxmemory ) freeMemoryIfNeeded ( ) ;if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) {addReplyError ( c , ""command<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>when<S2SV_blank>used<S2SV_blank>memory<S2SV_blank>><S2SV_blank>\\\'maxmemory\\\'"" ) ;return REDIS_OK ;}if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) {addReplyError ( c , ""only<S2SV_blank>(P)SUBSCRIBE<S2SV_blank>/<S2SV_blank>(P)UNSUBSCRIBE<S2SV_blank>/<S2SV_blank>QUIT<S2SV_blank>allowed<S2SV_blank>in<S2SV_blank>this<S2SV_blank>context"" ) ;return REDIS_OK ;}if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) {addReplyError ( c , ""link<S2SV_blank>with<S2SV_blank>MASTER<S2SV_blank>is<S2SV_blank>down<S2SV_blank>and<S2SV_blank>slave-serve-stale-data<S2SV_blank>is<S2SV_blank>set<S2SV_blank>to<S2SV_blank>no"" ) ;return REDIS_OK ;}if ( server . loading && cmd -> proc != infoCommand ) {addReply ( c , shared . loadingerr ) ;return REDIS_OK ;}if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) {queueMultiCommand ( c , cmd ) ;addReply ( c , shared . queued ) ;}else {if ( server . vm_enabled && server . vm_max_threads > 0 &&  blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ;cwe id:CWE-20context: int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown<S2SV_blank>command<S2SV_blank>\'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments<S2SV_blank>for<S2SV_blank>\'%s\'<S2SV_blank>command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation<S2SV_blank>not<S2SV_blank>permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>when<S2SV_blank>used<S2SV_blank>memory<S2SV_blank>><S2SV_blank>\'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only<S2SV_blank>(P)SUBSCRIBE<S2SV_blank>/<S2SV_blank>(P)UNSUBSCRIBE<S2SV_blank>/<S2SV_blank>QUIT<S2SV_blank>allowed<S2SV_blank>in<S2SV_blank>this<S2SV_blank>context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link<S2SV_blank>with<S2SV_blank>MASTER<S2SV_blank>is<S2SV_blank>down<S2SV_blank>and<S2SV_blank>slave-serve-stale-data<S2SV_blank>is<S2SV_blank>set<S2SV_blank>to<S2SV_blank>no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else {  if ( server . vm_enabled && server . vm_max_threads > 0 &&  blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }","if ( server . ds_enabled && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ;",323
443,"buggy line: static int set_registers ( rtl8150_t * dev , u16 indx , u16 size , void * data )  {return usb_control_msg ( dev -> udev , usb_sndctrlpipe ( dev -> udev , 0 ) ,  RTL8150_REQ_SET_REGS , RTL8150_REQT_WRITE ,  indx , 0 , data , size , 500 ) ;}cwe id:CWE-119context:  static int set_registers ( rtl8150_t * dev , u16 indx , u16 size , void * data )  {  return usb_control_msg ( dev -> udev , usb_sndctrlpipe ( dev -> udev , 0 ) ,  RTL8150_REQ_SET_REGS , RTL8150_REQT_WRITE ,  indx , 0 , data , size , 500 ) ;   } ","static int set_registers ( rtl8150_t * dev , u16 indx , u16 size , const void * data ) {void * buf ;int ret ;buf = kmemdup ( data , size , GFP_NOIO ) ;if ( ! buf ) return - ENOMEM ;ret = usb_control_msg ( dev -> udev , usb_sndctrlpipe ( dev -> udev , 0 ) , RTL8150_REQ_SET_REGS , RTL8150_REQT_WRITE , indx , 0 , buf , size , 500 ) ;kfree ( buf ) ;return ret ;}",324
444,"buggy line: endpoint = & usbinterface -> altsetting [ 0 ] . endpoint [ 0 ] . desc ;dev_dbg ( & usbinterface -> dev , ""gtco<S2SV_blank>#<S2SV_blank>interfaces:<S2SV_blank>%d\\\cwe id:CWE-000context: static int gtco_probe ( struct usb_interface * usbinterface , const struct usb_device_id * id ) { struct gtco * gtco ; struct input_dev * input_dev ; struct hid_descriptor * hid_desc ; char * report ; int result = 0 , retry ; int error ; struct usb_endpoint_descriptor * endpoint ; gtco = kzalloc ( sizeof ( struct gtco ) , GFP_KERNEL ) ; input_dev = input_allocate_device ( ) ; if ( ! gtco || ! input_dev ) { dev_err ( & usbinterface -> dev , ""No<S2SV_blank>more<S2SV_blank>memory\\n"" ) ; error = - ENOMEM ; goto err_free_devs ; } gtco -> inputdevice = input_dev ; gtco -> usbdev = interface_to_usbdev ( usbinterface ) ; gtco -> intf = usbinterface ; gtco -> buffer = usb_alloc_coherent ( gtco -> usbdev , REPORT_MAX_SIZE , GFP_KERNEL , & gtco -> buf_dma ) ; if ( ! gtco -> buffer ) { dev_err ( & usbinterface -> dev , ""No<S2SV_blank>more<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>us<S2SV_blank>buffers\\n"" ) ; error = - ENOMEM ; goto err_free_devs ; } gtco -> urbinfo = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! gtco -> urbinfo ) { dev_err ( & usbinterface -> dev , ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>URB\\n"" ) ; error = - ENOMEM ; goto err_free_buf ; }  endpoint = & usbinterface -> altsetting [ 0 ] . endpoint [ 0 ] . desc ;  dev_dbg ( & usbinterface -> dev , ""gtco<S2SV_blank>#<S2SV_blank>interfaces:<S2SV_blank>%d\\n"" , usbinterface -> num_altsetting ) ; dev_dbg ( & usbinterface -> dev , ""num<S2SV_blank>endpoints:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d\\n"" , usbinterface -> cur_altsetting -> desc . bNumEndpoints ) ; dev_dbg ( & usbinterface -> dev , ""interface<S2SV_blank>class:<S2SV_blank><S2SV_blank><S2SV_blank>%d\\n"" , usbinterface -> cur_altsetting -> desc . bInterfaceClass ) ; dev_dbg ( & usbinterface -> dev , ""endpoint:<S2SV_blank>attribute:0x%x<S2SV_blank>type:0x%x\\n"" , endpoint -> bmAttributes , endpoint -> bDescriptorType ) ; if ( usb_endpoint_xfer_int ( endpoint ) ) dev_dbg ( & usbinterface -> dev , ""endpoint:<S2SV_blank>we<S2SV_blank>have<S2SV_blank>interrupt<S2SV_blank>endpoint\\n"" ) ; dev_dbg ( & usbinterface -> dev , ""endpoint<S2SV_blank>extra<S2SV_blank>len:%d\\n"" , usbinterface -> altsetting [ 0 ] . extralen ) ; if ( usb_get_extra_descriptor ( usbinterface -> cur_altsetting , HID_DEVICE_TYPE , & hid_desc ) != 0 ) { dev_err ( & usbinterface -> dev , ""Can\'t<S2SV_blank>retrieve<S2SV_blank>exta<S2SV_blank>USB<S2SV_blank>descriptor<S2SV_blank>to<S2SV_blank>get<S2SV_blank>hid<S2SV_blank>report<S2SV_blank>descriptor<S2SV_blank>length\\n"" ) ; error = - EIO ; goto err_free_urb ; } dev_dbg ( & usbinterface -> dev , ""Extra<S2SV_blank>descriptor<S2SV_blank>success:<S2SV_blank>type:%d<S2SV_blank><S2SV_blank>len:%d\\n"" , hid_desc -> bDescriptorType , hid_desc -> wDescriptorLength ) ; report = kzalloc ( le16_to_cpu ( hid_desc -> wDescriptorLength ) , GFP_KERNEL ) ; if ( ! report ) { dev_err ( & usbinterface -> dev , ""No<S2SV_blank>more<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>report\\n"" ) ; error = - ENOMEM ; goto err_free_urb ; } for ( retry = 0 ; retry < 3 ; retry ++ ) { result = usb_control_msg ( gtco -> usbdev , usb_rcvctrlpipe ( gtco -> usbdev , 0 ) , USB_REQ_GET_DESCRIPTOR , USB_RECIP_INTERFACE | USB_DIR_IN , REPORT_DEVICE_TYPE << 8 , 0 , report , le16_to_cpu ( hid_desc -> wDescriptorLength ) , 5000 ) ; dev_dbg ( & usbinterface -> dev , ""usb_control_msg<S2SV_blank>result:<S2SV_blank>%d\\n"" , result ) ; if ( result == le16_to_cpu ( hid_desc -> wDescriptorLength ) ) { parse_hid_report_descriptor ( gtco , report , result ) ; break ; } } kfree ( report ) ; if ( result != le16_to_cpu ( hid_desc -> wDescriptorLength ) ) { dev_err ( & usbinterface -> dev , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>HID<S2SV_blank>Report<S2SV_blank>Descriptor<S2SV_blank>of<S2SV_blank>size:<S2SV_blank>%d\\n"" , hid_desc -> wDescriptorLength ) ; error = - EIO ; goto err_free_urb ; } usb_make_path ( gtco -> usbdev , gtco -> usbpath , sizeof ( gtco -> usbpath ) ) ; strlcat ( gtco -> usbpath , ""/input0"" , sizeof ( gtco -> usbpath ) ) ; input_dev -> open = gtco_input_open ; input_dev -> close = gtco_input_close ; input_dev -> name = ""GTCO_CalComp"" ; input_dev -> phys = gtco -> usbpath ; input_set_drvdata ( input_dev , gtco ) ; gtco_setup_caps ( input_dev ) ; usb_to_input_id ( gtco -> usbdev , & input_dev -> id ) ; input_dev -> dev . parent = & usbinterface -> dev ; endpoint = & usbinterface -> altsetting [ 0 ] . endpoint [ 0 ] . desc ; usb_fill_int_urb ( gtco -> urbinfo , gtco -> usbdev , usb_rcvintpipe ( gtco -> usbdev , endpoint -> bEndpointAddress ) , gtco -> buffer , REPORT_MAX_SIZE , gtco_urb_callback , gtco , endpoint -> bInterval ) ; gtco -> urbinfo -> transfer_dma = gtco -> buf_dma ; gtco -> urbinfo -> transfer_flags |= URB_NO_TRANSFER_DMA_MAP ; usb_set_intfdata ( usbinterface , gtco ) ; error = input_register_device ( input_dev ) ; if ( error ) goto err_free_urb ; return 0 ; err_free_urb : usb_free_urb ( gtco -> urbinfo ) ; err_free_buf : usb_free_coherent ( gtco -> usbdev , REPORT_MAX_SIZE , gtco -> buffer , gtco -> buf_dma ) ; err_free_devs : input_free_device ( input_dev ) ; kfree ( gtco ) ; return error ; }","if ( usbinterface -> altsetting [ 0 ] . desc . bNumEndpoints < 1 ) {dev_err ( & usbinterface -> dev , ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>endpoints\\\error = - EINVAL ;goto err_free_urb ;}endpoint = & usbinterface -> altsetting [ 0 ] . endpoint [ 0 ] . desc ;dev_dbg ( & usbinterface -> dev , ""gtco<S2SV_blank>#<S2SV_blank>interfaces:<S2SV_blank>%d\\\",325
445,"buggy line: case RESPONSE_RUN :  {nautilus_launch_desktop_file ( screen , uri , NULL , parameters -> parent_window ) ;g_free ( uri ) ;}break ;case RESPONSE_MARK_TRUSTED : {file = nautilus_file_get_location ( parameters -> file ) ;nautilus_file_mark_desktop_file_trusted ( file , parameters -> parent_window , TRUE , NULL , NULL ) ;cwe id:CWE-20context: static void untrusted_launcher_response_callback ( GtkDialog * dialog , int response_id , ActivateParametersDesktop * parameters ) { GdkScreen * screen ; char * uri ; GFile * file ; switch ( response_id ) {  case RESPONSE_RUN :  { screen = gtk_widget_get_screen ( GTK_WIDGET ( parameters -> parent_window ) ) ; uri = nautilus_file_get_uri ( parameters -> file ) ; DEBUG ( ""Launching<S2SV_blank>untrusted<S2SV_blank>launcher<S2SV_blank>%s"" , uri ) ; nautilus_launch_desktop_file ( screen , uri , NULL , parameters -> parent_window ) ; g_free ( uri ) ;  }  break ; case RESPONSE_MARK_TRUSTED : { file = nautilus_file_get_location ( parameters -> file ) ; nautilus_file_mark_desktop_file_trusted ( file , parameters -> parent_window , TRUE , NULL , NULL ) ; g_object_unref ( file ) ; } break ; default : { } break ; } gtk_widget_destroy ( GTK_WIDGET ( dialog ) ) ; activate_parameters_desktop_free ( parameters ) ; }","case GTK_RESPONSE_OK : {file = nautilus_file_get_location ( parameters -> file ) ;nautilus_file_set_metadata ( parameters -> file , NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED , NULL , ""yes"" ) ;nautilus_file_mark_desktop_file_executable ( file , parameters -> parent_window , TRUE , NULL , NULL ) ;nautilus_file_invalidate_all_attributes ( parameters -> file ) ;",326
446,"buggy line: if ( status ) {if ( edge_port -> lsr_event ) {edge_port -> lsr_event = 0 ;cwe id:CWE-191context: static void edge_bulk_in_callback ( struct urb * urb ) { struct edgeport_port * edge_port = urb -> context ; struct device * dev = & edge_port -> port -> dev ; unsigned char * data = urb -> transfer_buffer ; int retval = 0 ; int port_number ; int status = urb -> status ; switch ( status ) { case 0 : break ; case - ECONNRESET : case - ENOENT : case - ESHUTDOWN : dev_dbg ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>urb<S2SV_blank>shutting<S2SV_blank>down<S2SV_blank>with<S2SV_blank>status:<S2SV_blank>%d\\n"" , __func__ , status ) ; return ; default : dev_err ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>nonzero<S2SV_blank>read<S2SV_blank>bulk<S2SV_blank>status<S2SV_blank>received:<S2SV_blank>%d\\n"" , __func__ , status ) ; } if ( status == - EPIPE ) goto exit ; if ( status ) { dev_err ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>stopping<S2SV_blank>read!\\n"" , __func__ ) ; return ; } port_number = edge_port -> port -> port_number ;  if ( edge_port -> lsr_event ) {  edge_port -> lsr_event = 0 ; dev_dbg ( dev , ""%s<S2SV_blank>=====<S2SV_blank>Port<S2SV_blank>%u<S2SV_blank>LSR<S2SV_blank>Status<S2SV_blank>=<S2SV_blank>%02x,<S2SV_blank>Data<S2SV_blank>=<S2SV_blank>%02x<S2SV_blank>======\\n"" , __func__ , port_number , edge_port -> lsr_mask , * data ) ; handle_new_lsr ( edge_port , 1 , edge_port -> lsr_mask , * data ) ; -- urb -> actual_length ; ++ data ; } if ( urb -> actual_length ) { usb_serial_debug_data ( dev , __func__ , urb -> actual_length , data ) ; if ( edge_port -> close_pending ) dev_dbg ( dev , ""%s<S2SV_blank>-<S2SV_blank>close<S2SV_blank>pending,<S2SV_blank>dropping<S2SV_blank>data<S2SV_blank>on<S2SV_blank>the<S2SV_blank>floor\\n"" , __func__ ) ; else edge_tty_recv ( edge_port -> port , data , urb -> actual_length ) ; edge_port -> port -> icount . rx += urb -> actual_length ; } exit : spin_lock ( & edge_port -> ep_lock ) ; if ( edge_port -> ep_read_urb_state == EDGE_READ_URB_RUNNING ) retval = usb_submit_urb ( urb , GFP_ATOMIC ) ; else if ( edge_port -> ep_read_urb_state == EDGE_READ_URB_STOPPING ) edge_port -> ep_read_urb_state = EDGE_READ_URB_STOPPED ; spin_unlock ( & edge_port -> ep_lock ) ; if ( retval ) dev_err ( dev , ""%s<S2SV_blank>-<S2SV_blank>usb_submit_urb<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>result<S2SV_blank>%d\\n"" , __func__ , retval ) ; }",if ( urb -> actual_length > 0 && status ) {if ( edge_port -> lsr_event ) {edge_port -> lsr_event = 0 ;,327
447,"buggy line: static struct cifsSesInfo *  cifs_find_smb_ses ( struct TCP_Server_Info * server , char * username )  {struct list_head * tmp ;list_for_each ( tmp , & server -> smb_ses_list ) {ses = list_entry ( tmp , struct cifsSesInfo , smb_ses_list ) ;if ( strncmp ( ses -> userName , username , MAX_USERNAME_SIZE ) )   continue ;++ ses -> ses_count ;cwe id:CWE-264context: static struct cifsSesInfo *  cifs_find_smb_ses ( struct TCP_Server_Info * server , char * username )  { struct list_head * tmp ; struct cifsSesInfo * ses ; write_lock ( & cifs_tcp_ses_lock ) ;  list_for_each ( tmp , & server -> smb_ses_list ) {  ses = list_entry ( tmp , struct cifsSesInfo , smb_ses_list ) ;  if ( strncmp ( ses -> userName , username , MAX_USERNAME_SIZE ) )   continue ;  ++ ses -> ses_count ; write_unlock ( & cifs_tcp_ses_lock ) ; return ses ; } write_unlock ( & cifs_tcp_ses_lock ) ; return NULL ; }","static struct cifsSesInfo * cifs_find_smb_ses ( struct TCP_Server_Info * server , struct smb_vol * vol ) {+ ses -> ses_count ;list_for_each_entry ( ses , & server -> smb_ses_list ) {ses = list_entry ( tmp , struct cifsSesInfo , smb_ses_list ) ;if ( strncmp ( ses -> userName , vol -> username , MAX_USERNAME_SIZE ) ) continue ;if ( strlen ( vol -> username ) != 0 && strncmp ( ses -> password , vol -> password , MAX_PASSWORD_SIZE ) ) continue ;}++ ses -> ses_count ;",328
448,"buggy line: if ( ( ( cfg -> g_w != ctx -> cfg . g_w ) || ( cfg -> g_h != ctx -> cfg . g_h ) )   && ( cfg -> g_lag_in_frames > 1 || cfg -> g_pass != VPX_RC_ONE_PASS ) )   ERROR ( ""Cannot<S2SV_blank>change<S2SV_blank>width<S2SV_blank>or<S2SV_blank>height<S2SV_blank>after<S2SV_blank>initialization"" ) ;if ( ( cfg -> g_lag_in_frames > ctx -> cfg . g_lag_in_frames ) ) ERROR ( ""Cannot<S2SV_blank>increase<S2SV_blank>lag_in_frames"" ) ;cwe id:CWE-119context: static vpx_codec_err_t vp8e_set_config ( vpx_codec_alg_priv_t * ctx , const vpx_codec_enc_cfg_t * cfg ) { vpx_codec_err_t res ;  if ( ( ( cfg -> g_w != ctx -> cfg . g_w ) || ( cfg -> g_h != ctx -> cfg . g_h ) )   && ( cfg -> g_lag_in_frames > 1 || cfg -> g_pass != VPX_RC_ONE_PASS ) )   ERROR ( ""Cannot<S2SV_blank>change<S2SV_blank>width<S2SV_blank>or<S2SV_blank>height<S2SV_blank>after<S2SV_blank>initialization"" ) ;  if ( ( cfg -> g_lag_in_frames > ctx -> cfg . g_lag_in_frames ) ) ERROR ( ""Cannot<S2SV_blank>increase<S2SV_blank>lag_in_frames"" ) ; res = validate_config ( ctx , cfg , & ctx -> vp8_cfg , 0 ) ; if ( ! res ) { ctx -> cfg = * cfg ; set_vp8e_config ( & ctx -> oxcf , ctx -> cfg , ctx -> vp8_cfg , NULL ) ; vp8_change_config ( ctx -> cpi , & ctx -> oxcf ) ; } return res ; }","if ( cfg -> g_w != ctx -> cfg . g_w || cfg -> g_h != ctx -> cfg . g_h ) {if ( cfg -> g_lag_in_frames > 1 || cfg -> g_pass != VPX_RC_ONE_PASS ) ERROR ( ""Cannot<S2SV_blank>change<S2SV_blank>width<S2SV_blank>or<S2SV_blank>height<S2SV_blank>after<S2SV_blank>initialization"" ) ;if ( ( ctx -> cpi -> initial_width && ( int ) cfg -> g_w > ctx -> cpi -> initial_width ) || ( ctx -> cpi -> initial_height && ( int ) cfg -> g_h > ctx -> cpi -> initial_height ) ) ERROR ( ""Cannot<S2SV_blank>increase<S2SV_blank>width<S2SV_blank>or<S2SV_blank>height<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>their<S2SV_blank>initial<S2SV_blank>values"" ) ;}if ( ( cfg -> g_lag_in_frames > ctx -> cfg . g_lag_in_frames ) ) ERROR ( ""Cannot<S2SV_blank>increase<S2SV_blank>lag_in_frames"" ) ;",329
449,"buggy line: if ( input [ 0 ] == \'<S2SV_blank>\' )  input ++ ;ptr = strchr ( input , \'<S2SV_blank>\' ) ;cwe id:CWE-119context: static int cmd_mount ( void * data , const char * _input ) { ut64 off = 0 ; char * input , * oinput , * ptr , * ptr2 ; RList * list ; RListIter * iter ; RFSFile * file ; RFSRoot * root ; RFSPlugin * plug ; RFSPartition * part ; RCore * core = ( RCore * ) data ; if ( ! strncmp ( ""kdir"" , _input , 4 ) ) { return cmd_mkdir ( data , _input ) ; } if ( ! strncmp ( ""v"" , _input , 1 ) ) { return cmd_mv ( data , _input ) ; } input = oinput = strdup ( _input ) ; switch ( * input ) { case '<S2SV_blank>' : input ++ ; if ( input [ 0 ] == '<S2SV_blank>' )  input ++ ;  ptr = strchr ( input , '<S2SV_blank>' ) ; if ( ptr ) { * ptr = 0 ; ptr ++ ; ptr2 = strchr ( ptr , '<S2SV_blank>' ) ; if ( ptr2 ) { * ptr2 = 0 ; off = r_num_math ( core -> num , ptr2 + 1 ) ; }  if ( ! r_fs_mount ( core -> fs , ptr , input , off ) )  eprintf ( ""Cannot<S2SV_blank>mount<S2SV_blank>%s\\n"" , input ) ;  } else {   if ( ! ( ptr = r_fs_name ( core -> fs , core -> offset ) ) )  eprintf ( ""Unknown<S2SV_blank>filesystem<S2SV_blank>type\\n"" ) ;  else if ( ! r_fs_mount ( core -> fs , ptr , input , core -> offset ) )   eprintf ( ""Cannot<S2SV_blank>mount<S2SV_blank>%s\\n"" , input ) ;  free ( ptr ) ; } break ; case '-' : r_fs_umount ( core -> fs , input + 1 ) ; break ; case '*' : eprintf ( ""List<S2SV_blank>commands<S2SV_blank>in<S2SV_blank>radare<S2SV_blank>format\\n"" ) ; r_list_foreach ( core -> fs -> roots , iter , root ) { r_cons_printf ( ""m<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>0x%"" PFMT64x ""\\n"" , root -> path , root -> p -> name , root -> delta ) ; } break ; case '\\0' : r_list_foreach ( core -> fs -> roots , iter , root ) { r_cons_printf ( ""%s\\t0x%"" PFMT64x ""\\t%s\\n"" , root -> p -> name , root -> delta , root -> path ) ; } break ; case 'l' : r_list_foreach ( core -> fs -> plugins , iter , plug ) { r_cons_printf ( ""%10s<S2SV_blank><S2SV_blank>%s\\n"" , plug -> name , plug -> desc ) ; } break ; case 'd' : input ++ ; if ( input [ 0 ] == '<S2SV_blank>' ) input ++ ; list = r_fs_dir ( core -> fs , input ) ; if ( list ) { r_list_foreach ( list , iter , file ) { r_cons_printf ( ""%c<S2SV_blank>%s\\n"" , file -> type , file -> name ) ; } r_list_free ( list ) ; } else eprintf ( ""Cannot<S2SV_blank>open<S2SV_blank>\'%s\'<S2SV_blank>directory\\n"" , input ) ; break ; case 'p' : input ++ ; if ( * input == '<S2SV_blank>' ) input ++ ; ptr = strchr ( input , '<S2SV_blank>' ) ; if ( ptr ) { * ptr = 0 ; off = r_num_math ( core -> num , ptr + 1 ) ; } list = r_fs_partitions ( core -> fs , input , off ) ; if ( list ) { r_list_foreach ( list , iter , part ) { r_cons_printf ( ""%d<S2SV_blank>%02x<S2SV_blank>0x%010"" PFMT64x ""<S2SV_blank>0x%010"" PFMT64x ""\\n"" , part -> number , part -> type , part -> start , part -> start + part -> length ) ; } r_list_free ( list ) ; } else eprintf ( ""Cannot<S2SV_blank>read<S2SV_blank>partition\\n"" ) ; break ; case 'o' : input ++ ; if ( input [ 0 ] == '<S2SV_blank>' ) input ++ ; file = r_fs_open ( core -> fs , input ) ; if ( file ) { r_fs_read ( core -> fs , file , 0 , file -> size ) ; r_cons_printf ( ""f<S2SV_blank>file<S2SV_blank>%d<S2SV_blank>0x%08"" PFMT64x ""\\n"" , file -> size , file -> off ) ; r_fs_close ( core -> fs , file ) ; } else eprintf ( ""Cannot<S2SV_blank>open<S2SV_blank>file\\n"" ) ; break ; case 'g' : input ++ ; if ( * input == '<S2SV_blank>' ) input ++ ; ptr = strchr ( input , '<S2SV_blank>' ) ; if ( ptr ) * ptr ++ = 0 ; else ptr = ""./"" ; file = r_fs_open ( core -> fs , input ) ; if ( file ) { r_fs_read ( core -> fs , file , 0 , file -> size ) ; write ( 1 , file -> data , file -> size ) ; r_fs_close ( core -> fs , file ) ; write ( 1 , ""\\n"" , 1 ) ; } else if ( ! r_fs_dir_dump ( core -> fs , input , ptr ) ) eprintf ( ""Cannot<S2SV_blank>open<S2SV_blank>file\\n"" ) ; break ; case 'f' : input ++ ; switch ( * input ) { case '?' : r_cons_printf ( ""Usage:<S2SV_blank>mf[no]<S2SV_blank>[...]\\n"" ""<S2SV_blank>mfn<S2SV_blank>/foo<S2SV_blank>*.c<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>;<S2SV_blank>search<S2SV_blank>files<S2SV_blank>by<S2SV_blank>name<S2SV_blank>in<S2SV_blank>/foo<S2SV_blank>path\\n"" ""<S2SV_blank>mfo<S2SV_blank>/foo<S2SV_blank>0x5e91<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>;<S2SV_blank>search<S2SV_blank>files<S2SV_blank>by<S2SV_blank>offset<S2SV_blank>in<S2SV_blank>/foo<S2SV_blank>path\\n"" ) ; break ; case 'n' : input ++ ; if ( * input == '<S2SV_blank>' ) input ++ ; ptr = strchr ( input , '<S2SV_blank>' ) ; if ( ptr ) { * ptr ++ = 0 ; list = r_fs_find_name ( core -> fs , input , ptr ) ; r_list_foreach ( list , iter , ptr ) { r_str_chop_path ( ptr ) ; printf ( ""%s\\n"" , ptr ) ; } } else eprintf ( ""Unknown<S2SV_blank>store<S2SV_blank>path\\n"" ) ; break ; case 'o' : input ++ ; if ( * input == '<S2SV_blank>' ) input ++ ; ptr = strchr ( input , '<S2SV_blank>' ) ; if ( ptr ) { * ptr ++ = 0 ; ut64 off = r_num_math ( core -> num , ptr ) ; list = r_fs_find_off ( core -> fs , input , off ) ; r_list_foreach ( list , iter , ptr ) { r_str_chop_path ( ptr ) ; printf ( ""%s\\n"" , ptr ) ; } } else eprintf ( ""Unknown<S2SV_blank>store<S2SV_blank>path\\n"" ) ; break ; } break ; case 's' : if ( core -> http_up ) { free ( oinput ) ; return false ; } input ++ ; if ( input [ 0 ] == '<S2SV_blank>' ) input ++ ; r_fs_prompt ( core -> fs , input ) ; break ; case 'y' : eprintf ( ""TODO\\n"" ) ; break ; case '?' : { const char * help_msg [ ] = { ""Usage:"" , ""m[-?*dgy]<S2SV_blank>[...]<S2SV_blank>"" , ""Mountpoints<S2SV_blank>management"" , ""m"" , """" , ""List<S2SV_blank>all<S2SV_blank>mountpoints<S2SV_blank>in<S2SV_blank>human<S2SV_blank>readable<S2SV_blank>format"" , ""m*"" , """" , ""Same<S2SV_blank>as<S2SV_blank>above,<S2SV_blank>but<S2SV_blank>in<S2SV_blank>r2<S2SV_blank>commands"" , ""ml"" , """" , ""List<S2SV_blank>filesystem<S2SV_blank>plugins"" , ""m"" , ""<S2SV_blank>/mnt"" , ""Mount<S2SV_blank>fs<S2SV_blank>at<S2SV_blank>/mnt<S2SV_blank>with<S2SV_blank>autodetect<S2SV_blank>fs<S2SV_blank>and<S2SV_blank>current<S2SV_blank>offset"" , ""m"" , ""<S2SV_blank>/mnt<S2SV_blank>ext2<S2SV_blank>0"" , ""Mount<S2SV_blank>ext2<S2SV_blank>fs<S2SV_blank>at<S2SV_blank>/mnt<S2SV_blank>with<S2SV_blank>delta<S2SV_blank>0<S2SV_blank>on<S2SV_blank>IO"" , ""m-/"" , """" , ""Umount<S2SV_blank>given<S2SV_blank>path<S2SV_blank>(/)"" , ""my"" , """" , ""Yank<S2SV_blank>contents<S2SV_blank>of<S2SV_blank>file<S2SV_blank>into<S2SV_blank>clipboard"" , ""mo"" , ""<S2SV_blank>/foo"" , ""Get<S2SV_blank>offset<S2SV_blank>and<S2SV_blank>size<S2SV_blank>of<S2SV_blank>given<S2SV_blank>file"" , ""mg"" , ""<S2SV_blank>/foo"" , ""Get<S2SV_blank>contents<S2SV_blank>of<S2SV_blank>file/dir<S2SV_blank>dumped<S2SV_blank>to<S2SV_blank>disk<S2SV_blank>(XXX?)"" , ""mf"" , ""[?]<S2SV_blank>[o|n]"" , ""Search<S2SV_blank>files<S2SV_blank>for<S2SV_blank>given<S2SV_blank>filename<S2SV_blank>or<S2SV_blank>for<S2SV_blank>offset"" , ""md"" , ""<S2SV_blank>/"" , ""List<S2SV_blank>directory<S2SV_blank>contents<S2SV_blank>for<S2SV_blank>path"" , ""mp"" , """" , ""List<S2SV_blank>all<S2SV_blank>supported<S2SV_blank>partition<S2SV_blank>types"" , ""mp"" , ""<S2SV_blank>msdos<S2SV_blank>0"" , ""Show<S2SV_blank>partitions<S2SV_blank>in<S2SV_blank>msdos<S2SV_blank>format<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>0"" , ""ms"" , ""<S2SV_blank>/mnt"" , ""Open<S2SV_blank>filesystem<S2SV_blank>prompt<S2SV_blank>at<S2SV_blank>/mnt"" , NULL } ; r_core_cmd_help ( core , help_msg ) ; } break ; } free ( oinput ) ; return 0 ; }","if ( input [ 0 ] == \'<S2SV_blank>\' ) {input ++ ;}ptr = strchr ( input , \'<S2SV_blank>\' ) ;",330
450,"buggy line: if ( ! r_fs_mount ( core -> fs , ptr , input , off ) )  eprintf ( ""Cannot<S2SV_blank>mount<S2SV_blank>%s\\\}if ( ! ( ptr = r_fs_name ( core -> fs , core -> offset ) ) )  eprintf ( ""Unknown<S2SV_blank>filesystem<S2SV_blank>type\\\else if ( ! r_fs_mount ( core -> fs , ptr , input , core -> offset ) )   eprintf ( ""Cannot<S2SV_blank>mount<S2SV_blank>%s\\\free ( ptr ) ;cwe id:CWE-119context: static int cmd_mount ( void * data , const char * _input ) { ut64 off = 0 ; char * input , * oinput , * ptr , * ptr2 ; RList * list ; RListIter * iter ; RFSFile * file ; RFSRoot * root ; RFSPlugin * plug ; RFSPartition * part ; RCore * core = ( RCore * ) data ; if ( ! strncmp ( ""kdir"" , _input , 4 ) ) { return cmd_mkdir ( data , _input ) ; } if ( ! strncmp ( ""v"" , _input , 1 ) ) { return cmd_mv ( data , _input ) ; } input = oinput = strdup ( _input ) ; switch ( * input ) { case '<S2SV_blank>' : input ++ ; if ( input [ 0 ] == '<S2SV_blank>' )  input ++ ;  ptr = strchr ( input , '<S2SV_blank>' ) ; if ( ptr ) { * ptr = 0 ; ptr ++ ; ptr2 = strchr ( ptr , '<S2SV_blank>' ) ; if ( ptr2 ) { * ptr2 = 0 ; off = r_num_math ( core -> num , ptr2 + 1 ) ; }  if ( ! r_fs_mount ( core -> fs , ptr , input , off ) )  eprintf ( ""Cannot<S2SV_blank>mount<S2SV_blank>%s\\n"" , input ) ;  } else {   if ( ! ( ptr = r_fs_name ( core -> fs , core -> offset ) ) )  eprintf ( ""Unknown<S2SV_blank>filesystem<S2SV_blank>type\\n"" ) ;  else if ( ! r_fs_mount ( core -> fs , ptr , input , core -> offset ) )   eprintf ( ""Cannot<S2SV_blank>mount<S2SV_blank>%s\\n"" , input ) ;  free ( ptr ) ; } break ; case '-' : r_fs_umount ( core -> fs , input + 1 ) ; break ; case '*' : eprintf ( ""List<S2SV_blank>commands<S2SV_blank>in<S2SV_blank>radare<S2SV_blank>format\\n"" ) ; r_list_foreach ( core -> fs -> roots , iter , root ) { r_cons_printf ( ""m<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>0x%"" PFMT64x ""\\n"" , root -> path , root -> p -> name , root -> delta ) ; } break ; case '\\0' : r_list_foreach ( core -> fs -> roots , iter , root ) { r_cons_printf ( ""%s\\t0x%"" PFMT64x ""\\t%s\\n"" , root -> p -> name , root -> delta , root -> path ) ; } break ; case 'l' : r_list_foreach ( core -> fs -> plugins , iter , plug ) { r_cons_printf ( ""%10s<S2SV_blank><S2SV_blank>%s\\n"" , plug -> name , plug -> desc ) ; } break ; case 'd' : input ++ ; if ( input [ 0 ] == '<S2SV_blank>' ) input ++ ; list = r_fs_dir ( core -> fs , input ) ; if ( list ) { r_list_foreach ( list , iter , file ) { r_cons_printf ( ""%c<S2SV_blank>%s\\n"" , file -> type , file -> name ) ; } r_list_free ( list ) ; } else eprintf ( ""Cannot<S2SV_blank>open<S2SV_blank>\'%s\'<S2SV_blank>directory\\n"" , input ) ; break ; case 'p' : input ++ ; if ( * input == '<S2SV_blank>' ) input ++ ; ptr = strchr ( input , '<S2SV_blank>' ) ; if ( ptr ) { * ptr = 0 ; off = r_num_math ( core -> num , ptr + 1 ) ; } list = r_fs_partitions ( core -> fs , input , off ) ; if ( list ) { r_list_foreach ( list , iter , part ) { r_cons_printf ( ""%d<S2SV_blank>%02x<S2SV_blank>0x%010"" PFMT64x ""<S2SV_blank>0x%010"" PFMT64x ""\\n"" , part -> number , part -> type , part -> start , part -> start + part -> length ) ; } r_list_free ( list ) ; } else eprintf ( ""Cannot<S2SV_blank>read<S2SV_blank>partition\\n"" ) ; break ; case 'o' : input ++ ; if ( input [ 0 ] == '<S2SV_blank>' ) input ++ ; file = r_fs_open ( core -> fs , input ) ; if ( file ) { r_fs_read ( core -> fs , file , 0 , file -> size ) ; r_cons_printf ( ""f<S2SV_blank>file<S2SV_blank>%d<S2SV_blank>0x%08"" PFMT64x ""\\n"" , file -> size , file -> off ) ; r_fs_close ( core -> fs , file ) ; } else eprintf ( ""Cannot<S2SV_blank>open<S2SV_blank>file\\n"" ) ; break ; case 'g' : input ++ ; if ( * input == '<S2SV_blank>' ) input ++ ; ptr = strchr ( input , '<S2SV_blank>' ) ; if ( ptr ) * ptr ++ = 0 ; else ptr = ""./"" ; file = r_fs_open ( core -> fs , input ) ; if ( file ) { r_fs_read ( core -> fs , file , 0 , file -> size ) ; write ( 1 , file -> data , file -> size ) ; r_fs_close ( core -> fs , file ) ; write ( 1 , ""\\n"" , 1 ) ; } else if ( ! r_fs_dir_dump ( core -> fs , input , ptr ) ) eprintf ( ""Cannot<S2SV_blank>open<S2SV_blank>file\\n"" ) ; break ; case 'f' : input ++ ; switch ( * input ) { case '?' : r_cons_printf ( ""Usage:<S2SV_blank>mf[no]<S2SV_blank>[...]\\n"" ""<S2SV_blank>mfn<S2SV_blank>/foo<S2SV_blank>*.c<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>;<S2SV_blank>search<S2SV_blank>files<S2SV_blank>by<S2SV_blank>name<S2SV_blank>in<S2SV_blank>/foo<S2SV_blank>path\\n"" ""<S2SV_blank>mfo<S2SV_blank>/foo<S2SV_blank>0x5e91<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>;<S2SV_blank>search<S2SV_blank>files<S2SV_blank>by<S2SV_blank>offset<S2SV_blank>in<S2SV_blank>/foo<S2SV_blank>path\\n"" ) ; break ; case 'n' : input ++ ; if ( * input == '<S2SV_blank>' ) input ++ ; ptr = strchr ( input , '<S2SV_blank>' ) ; if ( ptr ) { * ptr ++ = 0 ; list = r_fs_find_name ( core -> fs , input , ptr ) ; r_list_foreach ( list , iter , ptr ) { r_str_chop_path ( ptr ) ; printf ( ""%s\\n"" , ptr ) ; } } else eprintf ( ""Unknown<S2SV_blank>store<S2SV_blank>path\\n"" ) ; break ; case 'o' : input ++ ; if ( * input == '<S2SV_blank>' ) input ++ ; ptr = strchr ( input , '<S2SV_blank>' ) ; if ( ptr ) { * ptr ++ = 0 ; ut64 off = r_num_math ( core -> num , ptr ) ; list = r_fs_find_off ( core -> fs , input , off ) ; r_list_foreach ( list , iter , ptr ) { r_str_chop_path ( ptr ) ; printf ( ""%s\\n"" , ptr ) ; } } else eprintf ( ""Unknown<S2SV_blank>store<S2SV_blank>path\\n"" ) ; break ; } break ; case 's' : if ( core -> http_up ) { free ( oinput ) ; return false ; } input ++ ; if ( input [ 0 ] == '<S2SV_blank>' ) input ++ ; r_fs_prompt ( core -> fs , input ) ; break ; case 'y' : eprintf ( ""TODO\\n"" ) ; break ; case '?' : { const char * help_msg [ ] = { ""Usage:"" , ""m[-?*dgy]<S2SV_blank>[...]<S2SV_blank>"" , ""Mountpoints<S2SV_blank>management"" , ""m"" , """" , ""List<S2SV_blank>all<S2SV_blank>mountpoints<S2SV_blank>in<S2SV_blank>human<S2SV_blank>readable<S2SV_blank>format"" , ""m*"" , """" , ""Same<S2SV_blank>as<S2SV_blank>above,<S2SV_blank>but<S2SV_blank>in<S2SV_blank>r2<S2SV_blank>commands"" , ""ml"" , """" , ""List<S2SV_blank>filesystem<S2SV_blank>plugins"" , ""m"" , ""<S2SV_blank>/mnt"" , ""Mount<S2SV_blank>fs<S2SV_blank>at<S2SV_blank>/mnt<S2SV_blank>with<S2SV_blank>autodetect<S2SV_blank>fs<S2SV_blank>and<S2SV_blank>current<S2SV_blank>offset"" , ""m"" , ""<S2SV_blank>/mnt<S2SV_blank>ext2<S2SV_blank>0"" , ""Mount<S2SV_blank>ext2<S2SV_blank>fs<S2SV_blank>at<S2SV_blank>/mnt<S2SV_blank>with<S2SV_blank>delta<S2SV_blank>0<S2SV_blank>on<S2SV_blank>IO"" , ""m-/"" , """" , ""Umount<S2SV_blank>given<S2SV_blank>path<S2SV_blank>(/)"" , ""my"" , """" , ""Yank<S2SV_blank>contents<S2SV_blank>of<S2SV_blank>file<S2SV_blank>into<S2SV_blank>clipboard"" , ""mo"" , ""<S2SV_blank>/foo"" , ""Get<S2SV_blank>offset<S2SV_blank>and<S2SV_blank>size<S2SV_blank>of<S2SV_blank>given<S2SV_blank>file"" , ""mg"" , ""<S2SV_blank>/foo"" , ""Get<S2SV_blank>contents<S2SV_blank>of<S2SV_blank>file/dir<S2SV_blank>dumped<S2SV_blank>to<S2SV_blank>disk<S2SV_blank>(XXX?)"" , ""mf"" , ""[?]<S2SV_blank>[o|n]"" , ""Search<S2SV_blank>files<S2SV_blank>for<S2SV_blank>given<S2SV_blank>filename<S2SV_blank>or<S2SV_blank>for<S2SV_blank>offset"" , ""md"" , ""<S2SV_blank>/"" , ""List<S2SV_blank>directory<S2SV_blank>contents<S2SV_blank>for<S2SV_blank>path"" , ""mp"" , """" , ""List<S2SV_blank>all<S2SV_blank>supported<S2SV_blank>partition<S2SV_blank>types"" , ""mp"" , ""<S2SV_blank>msdos<S2SV_blank>0"" , ""Show<S2SV_blank>partitions<S2SV_blank>in<S2SV_blank>msdos<S2SV_blank>format<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>0"" , ""ms"" , ""<S2SV_blank>/mnt"" , ""Open<S2SV_blank>filesystem<S2SV_blank>prompt<S2SV_blank>at<S2SV_blank>/mnt"" , NULL } ; r_core_cmd_help ( core , help_msg ) ; } break ; } free ( oinput ) ; return 0 ; }","if ( ! r_fs_mount ( core -> fs , ptr , input , off ) ) {eprintf ( ""Cannot<S2SV_blank>mount<S2SV_blank>%s\\\}}if ( ! ( ptr = r_fs_name ( core -> fs , core -> offset ) ) ) {eprintf ( ""Unknown<S2SV_blank>filesystem<S2SV_blank>type\\\}else if ( ! r_fs_mount ( core -> fs , ptr , input , core -> offset ) ) {eprintf ( ""Cannot<S2SV_blank>mount<S2SV_blank>%s\\\}free ( ptr ) ;",330
451,"buggy line: if ( vm_flags & VM_NORESERVE )  return 0 ;if ( ! vma || vma -> vm_flags & VM_MAYSHARE ) chg = region_chg ( & inode -> i_mapping -> private_list , from , to ) ;else {struct resv_map * resv_map = resv_map_alloc ( ) ;if ( ! resv_map ) return - ENOMEM ;chg = to - from ;set_vma_resv_map ( vma , resv_map ) ;set_vma_resv_flags ( vma , HPAGE_RESV_OWNER ) ;}if ( chg < 0 ) return chg ;if ( hugetlb_get_quota ( inode -> i_mapping , chg ) )  return - ENOSPC ;hugetlb_put_quota ( inode -> i_mapping , chg ) ;return ret ;cwe id:CWE-399context: int hugetlb_reserve_pages ( struct inode * inode , long from , long to , struct vm_area_struct * vma , vm_flags_t vm_flags ) { long ret , chg ; struct hstate * h = hstate_inode ( inode ) ;  if ( vm_flags & VM_NORESERVE )  return 0 ; if ( ! vma || vma -> vm_flags & VM_MAYSHARE ) chg = region_chg ( & inode -> i_mapping -> private_list , from , to ) ; else { struct resv_map * resv_map = resv_map_alloc ( ) ; if ( ! resv_map ) return - ENOMEM ; chg = to - from ; set_vma_resv_map ( vma , resv_map ) ; set_vma_resv_flags ( vma , HPAGE_RESV_OWNER ) ; } if ( chg < 0 ) return chg ;  if ( hugetlb_get_quota ( inode -> i_mapping , chg ) )  return - ENOSPC ; ret = hugetlb_acct_memory ( h , chg ) ; if ( ret < 0 ) {  hugetlb_put_quota ( inode -> i_mapping , chg ) ;  return ret ; } if ( ! vma || vma -> vm_flags & VM_MAYSHARE ) region_add ( & inode -> i_mapping -> private_list , from , to ) ; return 0 ; }","struct hugepage_subpool * spool = subpool_inode ( inode ) ;if ( hugepage_subpool_get_pages ( spool , chg ) ) return - ENOSPC ;hugetlb_put_quota ( inode -> i_mapping , chg ) ;return ret ;",331
452,"buggy line: struct key * keyring ;keyring = keyring_alloc ( ""_tid"" , new -> uid , new -> gid , new , KEY_POS_ALL | KEY_USR_VIEW , KEY_ALLOC_QUOTA_OVERRUN , NULL , NULL ) ;cwe id:CWE-404context: int install_thread_keyring_to_cred ( struct cred * new ) {  struct key * keyring ;  keyring = keyring_alloc ( ""_tid"" , new -> uid , new -> gid , new , KEY_POS_ALL | KEY_USR_VIEW , KEY_ALLOC_QUOTA_OVERRUN , NULL , NULL ) ; if ( IS_ERR ( keyring ) ) return PTR_ERR ( keyring ) ; new -> thread_keyring = keyring ; return 0 ; }","struct key * keyring ;if ( new -> thread_keyring ) return 0 ;keyring = keyring_alloc ( ""_tid"" , new -> uid , new -> gid , new , KEY_POS_ALL | KEY_USR_VIEW , KEY_ALLOC_QUOTA_OVERRUN , NULL , NULL ) ;",332
453,"buggy line: static size_t scanned ;static size_t readnbd ;cwe id:CWE-399context: int sfgets ( void ) { struct pollfd pfd ; int pollret ; ssize_t readnb ; signed char seen_r = 0 ;  static size_t scanned ;  static size_t readnbd ; if ( scanned > ( size_t ) 0U ) { readnbd -= scanned ; memmove ( cmd , cmd + scanned , readnbd ) ; scanned = ( size_t ) 0U ; } pfd . fd = clientfd ; # ifdef __APPLE_CC__ pfd . events = POLLIN | POLLERR | POLLHUP ; # else pfd . events = POLLIN | POLLPRI | POLLERR | POLLHUP ; # endif while ( scanned < cmdsize ) { if ( scanned >= readnbd ) { pfd . revents = 0 ; while ( ( pollret = poll ( & pfd , 1U , idletime * 1000UL ) ) < 0 && errno == EINTR ) ; if ( pollret == 0 ) { return - 1 ; } if ( pollret <= 0 || ( pfd . revents & ( POLLERR | POLLHUP | POLLNVAL ) ) != 0 ) { return - 2 ; } if ( ( pfd . revents & ( POLLIN | POLLPRI ) ) == 0 ) { continue ; } if ( readnbd >= cmdsize ) { break ; } # ifdef WITH_TLS if ( tls_cnx != NULL ) { while ( ( readnb = SSL_read ( tls_cnx , cmd + readnbd , cmdsize - readnbd ) ) < ( ssize_t ) 0 && errno == EINTR ) ; } else # endif { while ( ( readnb = read ( clientfd , cmd + readnbd , cmdsize - readnbd ) ) < ( ssize_t ) 0 && errno == EINTR ) ; } if ( readnb <= ( ssize_t ) 0 ) { return - 2 ; } readnbd += readnb ; if ( readnbd > cmdsize ) { return - 2 ; } } # ifdef RFC_CONFORMANT_LINES if ( seen_r != 0 ) { # endif if ( cmd [ scanned ] == '\\n' ) { # ifndef RFC_CONFORMANT_LINES if ( seen_r != 0 ) { # endif cmd [ scanned - 1U ] = 0 ; # ifndef RFC_CONFORMANT_LINES } else { cmd [ scanned ] = 0 ; } # endif if ( ++ scanned >= readnbd ) { scanned = readnbd = ( size_t ) 0U ; } return 0 ; } seen_r = 0 ; # ifdef RFC_CONFORMANT_LINES } # endif if ( ISCTRLCODE ( cmd [ scanned ] ) ) { if ( cmd [ scanned ] == '\\r' ) { seen_r = 1 ; } # ifdef RFC_CONFORMANT_PARSER else if ( cmd [ scanned ] == 0 ) { cmd [ scanned ] = '\\n' ; } # else cmd [ scanned ] = '_' ; # endif } scanned ++ ; } die ( 421 , LOG_WARNING , MSG_LINE_TOO_LONG ) ; return 0 ; }","
",333
454,"buggy line: fptr_copy = ( struct mrb_io * ) DATA_PTR ( copy ) ;if ( fptr_copy != NULL ) {fptr_copy = ( struct mrb_io * ) mrb_io_alloc ( mrb ) ;fptr_orig = io_get_open_fptr ( mrb , orig ) ;cwe id:CWE-416context: mrb_value mrb_io_initialize_copy ( mrb_state * mrb , mrb_value copy ) { mrb_value orig ; mrb_value buf ; struct mrb_io * fptr_copy ; struct mrb_io * fptr_orig ; mrb_bool failed = TRUE ; mrb_get_args ( mrb , ""o"" , & orig ) ;  fptr_copy = ( struct mrb_io * ) DATA_PTR ( copy ) ;  if ( fptr_copy != NULL ) { fptr_finalize ( mrb , fptr_copy , FALSE ) ; mrb_free ( mrb , fptr_copy ) ; }  fptr_copy = ( struct mrb_io * ) mrb_io_alloc ( mrb ) ;  fptr_orig = io_get_open_fptr ( mrb , orig ) ; DATA_TYPE ( copy ) = & mrb_io_type ; DATA_PTR ( copy ) = fptr_copy ; buf = mrb_iv_get ( mrb , orig , mrb_intern_cstr ( mrb , ""@buf"" ) ) ; mrb_iv_set ( mrb , copy , mrb_intern_cstr ( mrb , ""@buf"" ) , buf ) ; fptr_copy -> fd = mrb_dup ( mrb , fptr_orig -> fd , & failed ) ; if ( failed ) { mrb_sys_fail ( mrb , 0 ) ; } mrb_fd_cloexec ( mrb , fptr_copy -> fd ) ; if ( fptr_orig -> fd2 != - 1 ) { fptr_copy -> fd2 = mrb_dup ( mrb , fptr_orig -> fd2 , & failed ) ; if ( failed ) { close ( fptr_copy -> fd ) ; mrb_sys_fail ( mrb , 0 ) ; } mrb_fd_cloexec ( mrb , fptr_copy -> fd2 ) ; } fptr_copy -> pid = fptr_orig -> pid ; fptr_copy -> readable = fptr_orig -> readable ; fptr_copy -> writable = fptr_orig -> writable ; fptr_copy -> sync = fptr_orig -> sync ; fptr_copy -> is_socket = fptr_orig -> is_socket ; return copy ; }","fptr_orig = io_get_open_fptr ( mrb , orig ) ;fptr_copy = ( struct mrb_io * ) DATA_PTR ( copy ) ;if ( fptr_copy != NULL ) {fptr_copy = ( struct mrb_io * ) mrb_io_alloc ( mrb ) ;",334
455,"buggy line: . index_key . type = & key_type_request_key_auth , . index_key . description = description , . cred = current_cred ( ) ,  . match_data . cmp = user_match ,  . match_data . raw_data = description , . match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT , }cwe id:CWE-476context: struct key * key_get_instantiation_authkey ( key_serial_t target_id ) { char description [ 16 ] ; struct keyring_search_context ctx = { . index_key . type = & key_type_request_key_auth , . index_key . description = description , . cred = current_cred ( ) ,  . match_data . cmp = user_match ,  . match_data . raw_data = description , . match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT , } ; struct key * authkey ; key_ref_t authkey_ref ; sprintf ( description , ""%x"" , target_id ) ; authkey_ref = search_process_keyrings ( & ctx ) ; if ( IS_ERR ( authkey_ref ) ) { authkey = ERR_CAST ( authkey_ref ) ; if ( authkey == ERR_PTR ( - EAGAIN ) ) authkey = ERR_PTR ( - ENOKEY ) ; goto error ; } authkey = key_ref_to_ptr ( authkey_ref ) ; if ( test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) { key_put ( authkey ) ; authkey = ERR_PTR ( - EKEYREVOKED ) ; } error : return authkey ; }",". index_key . type = & key_type_request_key_auth , . index_key . description = description , . cred = current_cred ( ) , . match_data . cmp = key_default_cmp , . match_data . raw_data = description , . match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT , }",335
456,"buggy line: cpi -> zbin_mode_boost = 0 ;vp9_init_plane_quantizers ( cpi , & cpi -> mb ) ;}cwe id:CWE-119context: void vp9_frame_init_quantizer ( VP9_COMP * cpi ) {  cpi -> zbin_mode_boost = 0 ;   vp9_init_plane_quantizers ( cpi , & cpi -> mb ) ;  }","vp9_init_plane_quantizers ( cpi , & cpi -> td . mb ) ;}",336
457,"buggy line: utee_param_to_param ( param , callee_params ) ;}cwe id:CWE-119context: static TEE_Result tee_svc_copy_param ( struct tee_ta_session * sess , struct tee_ta_session * called_sess , struct utee_params * callee_params , struct tee_ta_param * param , void * tmp_buf_va [ TEE_NUM_PARAMS ] , struct mobj * * mobj_tmp ) { size_t n ; TEE_Result res ; size_t req_mem = 0 ; size_t s ; uint8_t * dst = 0 ; bool ta_private_memref [ TEE_NUM_PARAMS ] ; struct user_ta_ctx * utc = to_user_ta_ctx ( sess -> ctx ) ; void * va ; size_t dst_offs ; if ( ! callee_params ) { memset ( param , 0 , sizeof ( * param ) ) ; } else { res = tee_mmu_check_access_rights ( utc , TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER , ( uaddr_t ) callee_params , sizeof ( struct utee_params ) ) ; if ( res != TEE_SUCCESS ) return res ;  utee_param_to_param ( param , callee_params ) ;  } if ( called_sess && is_pseudo_ta_ctx ( called_sess -> ctx ) ) { return TEE_SUCCESS ; } for ( n = 0 ; n < TEE_NUM_PARAMS ; n ++ ) { ta_private_memref [ n ] = false ; switch ( TEE_PARAM_TYPE_GET ( param -> types , n ) ) { case TEE_PARAM_TYPE_MEMREF_INPUT : case TEE_PARAM_TYPE_MEMREF_OUTPUT : case TEE_PARAM_TYPE_MEMREF_INOUT : va = ( void * ) param -> u [ n ] . mem . offs ; s = param -> u [ n ] . mem . size ; if ( ! va ) { if ( s ) return TEE_ERROR_BAD_PARAMETERS ; break ; } if ( tee_mmu_is_vbuf_inside_ta_private ( utc , va , s ) ) { s = ROUNDUP ( s , sizeof ( uint32_t ) ) ; if ( ADD_OVERFLOW ( req_mem , s , & req_mem ) ) return TEE_ERROR_BAD_PARAMETERS ; ta_private_memref [ n ] = true ; break ; } res = tee_mmu_vbuf_to_mobj_offs ( utc , va , s , & param -> u [ n ] . mem . mobj , & param -> u [ n ] . mem . offs ) ; if ( res != TEE_SUCCESS ) return res ; break ; default : break ; } } if ( req_mem == 0 ) return TEE_SUCCESS ; res = alloc_temp_sec_mem ( req_mem , mobj_tmp , & dst ) ; if ( res != TEE_SUCCESS ) return res ; dst_offs = 0 ; for ( n = 0 ; n < TEE_NUM_PARAMS ; n ++ ) { if ( ! ta_private_memref [ n ] ) continue ; s = ROUNDUP ( param -> u [ n ] . mem . size , sizeof ( uint32_t ) ) ; switch ( TEE_PARAM_TYPE_GET ( param -> types , n ) ) { case TEE_PARAM_TYPE_MEMREF_INPUT : case TEE_PARAM_TYPE_MEMREF_INOUT : va = ( void * ) param -> u [ n ] . mem . offs ; if ( va ) { res = tee_svc_copy_from_user ( dst , va , param -> u [ n ] . mem . size ) ; if ( res != TEE_SUCCESS ) return res ; param -> u [ n ] . mem . offs = dst_offs ; param -> u [ n ] . mem . mobj = * mobj_tmp ; tmp_buf_va [ n ] = dst ; dst += s ; dst_offs += s ; } break ; case TEE_PARAM_TYPE_MEMREF_OUTPUT : va = ( void * ) param -> u [ n ] . mem . offs ; if ( va ) { param -> u [ n ] . mem . offs = dst_offs ; param -> u [ n ] . mem . mobj = * mobj_tmp ; tmp_buf_va [ n ] = dst ; dst += s ; dst_offs += s ; } break ; default : continue ; } } return TEE_SUCCESS ; }","res = utee_param_to_param ( utc , param , callee_params ) ;if ( res != TEE_SUCCESS ) return res ;}",337
458,"buggy line: old_cs = get_segment_selector ( ctxt , VCPU_SREG_CS ) ;old_eip = ctxt -> _eip ;if ( load_segment_descriptor ( ctxt , sel , VCPU_SREG_CS ) )  return X86EMUL_CONTINUE ;ctxt -> _eip = 0 ;memcpy ( & ctxt -> _eip , ctxt -> src . valptr , ctxt -> op_bytes ) ;if ( rc != X86EMUL_CONTINUE ) return rc ;return em_push ( ctxt ) ;cwe id:CWE-000context: static int em_call_far ( struct x86_emulate_ctxt * ctxt ) { u16 sel , old_cs ; ulong old_eip ; int rc ;  old_cs = get_segment_selector ( ctxt , VCPU_SREG_CS ) ;  old_eip = ctxt -> _eip ; memcpy ( & sel , ctxt -> src . valptr + ctxt -> op_bytes , 2 ) ;  if ( load_segment_descriptor ( ctxt , sel , VCPU_SREG_CS ) )  return X86EMUL_CONTINUE ;  ctxt -> _eip = 0 ;  memcpy ( & ctxt -> _eip , ctxt -> src . valptr , ctxt -> op_bytes ) ; ctxt -> src . val = old_cs ; rc = em_push ( ctxt ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; ctxt -> src . val = old_eip ; return em_push ( ctxt ) ; }","struct desc_struct old_desc , new_desc ;const struct x86_emulate_ops * ops = ctxt -> ops ;int cpl = ctxt -> ops -> cpl ( ctxt ) ;old_eip = ctxt -> _eip ;ops -> get_segment ( ctxt , & old_cs , & old_desc , NULL , VCPU_SREG_CS ) ;rc = __load_segment_descriptor ( ctxt , sel , VCPU_SREG_CS , cpl , false , & new_desc ) ;if ( rc != X86EMUL_CONTINUE ) return X86EMUL_CONTINUE ;rc = assign_eip_far ( ctxt , ctxt -> src . val , new_desc . l ) ;if ( rc != X86EMUL_CONTINUE ) goto fail ;if ( rc != X86EMUL_CONTINUE ) goto fail ;rc = em_push ( ctxt ) ;if ( rc != X86EMUL_CONTINUE ) goto fail ;return rc ;fail : ops -> set_segment ( ctxt , old_cs , & old_desc , 0 , VCPU_SREG_CS ) ;return rc ;",338
459,"buggy line: reslevel -> band = av_malloc_array ( reslevel -> nbands , sizeof ( * reslevel -> band ) ) ;if ( ! reslevel -> band ) return AVERROR ( ENOMEM ) ;cwe id:CWE-000context: int ff_jpeg2000_init_component ( Jpeg2000Component * comp , Jpeg2000CodingStyle * codsty , Jpeg2000QuantStyle * qntsty , int cbps , int dx , int dy , AVCodecContext * avctx ) { uint8_t log2_band_prec_width , log2_band_prec_height ; int reslevelno , bandno , gbandno = 0 , ret , i , j ; uint32_t csize ; if ( codsty -> nreslevels2decode <= 0 ) { av_log ( avctx , AV_LOG_ERROR , ""nreslevels2decode<S2SV_blank>%d<S2SV_blank>invalid<S2SV_blank>or<S2SV_blank>uninitialized\\n"" , codsty -> nreslevels2decode ) ; return AVERROR_INVALIDDATA ; } if ( ret = ff_jpeg2000_dwt_init ( & comp -> dwt , comp -> coord , codsty -> nreslevels2decode - 1 , codsty -> transform ) ) return ret ; csize = ( comp -> coord [ 0 ] [ 1 ] - comp -> coord [ 0 ] [ 0 ] ) * ( comp -> coord [ 1 ] [ 1 ] - comp -> coord [ 1 ] [ 0 ] ) ; if ( codsty -> transform == FF_DWT97 ) { comp -> i_data = NULL ; comp -> f_data = av_malloc_array ( csize , sizeof ( * comp -> f_data ) ) ; if ( ! comp -> f_data ) return AVERROR ( ENOMEM ) ; } else { comp -> f_data = NULL ; comp -> i_data = av_malloc_array ( csize , sizeof ( * comp -> i_data ) ) ; if ( ! comp -> i_data ) return AVERROR ( ENOMEM ) ; } comp -> reslevel = av_malloc_array ( codsty -> nreslevels , sizeof ( * comp -> reslevel ) ) ; if ( ! comp -> reslevel ) return AVERROR ( ENOMEM ) ; for ( reslevelno = 0 ; reslevelno < codsty -> nreslevels ; reslevelno ++ ) { int declvl = codsty -> nreslevels - reslevelno ; Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; for ( i = 0 ; i < 2 ; i ++ ) for ( j = 0 ; j < 2 ; j ++ ) reslevel -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] , declvl - 1 ) ; reslevel -> log2_prec_width = codsty -> log2_prec_widths [ reslevelno ] ; reslevel -> log2_prec_height = codsty -> log2_prec_heights [ reslevelno ] ; if ( reslevelno == 0 ) reslevel -> nbands = 1 ; else reslevel -> nbands = 3 ; if ( reslevel -> coord [ 0 ] [ 1 ] == reslevel -> coord [ 0 ] [ 0 ] ) reslevel -> num_precincts_x = 0 ; else reslevel -> num_precincts_x = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 0 ] [ 1 ] , reslevel -> log2_prec_width ) - ( reslevel -> coord [ 0 ] [ 0 ] >> reslevel -> log2_prec_width ) ; if ( reslevel -> coord [ 1 ] [ 1 ] == reslevel -> coord [ 1 ] [ 0 ] ) reslevel -> num_precincts_y = 0 ; else reslevel -> num_precincts_y = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 1 ] [ 1 ] , reslevel -> log2_prec_height ) - ( reslevel -> coord [ 1 ] [ 0 ] >> reslevel -> log2_prec_height ) ;  reslevel -> band = av_malloc_array ( reslevel -> nbands , sizeof ( * reslevel -> band ) ) ;  if ( ! reslevel -> band ) return AVERROR ( ENOMEM ) ; for ( bandno = 0 ; bandno < reslevel -> nbands ; bandno ++ , gbandno ++ ) { Jpeg2000Band * band = reslevel -> band + bandno ; int cblkno , precno ; int nb_precincts ; switch ( qntsty -> quantsty ) { uint8_t gain ; int numbps ; case JPEG2000_QSTY_NONE : band -> f_stepsize = 1 ; break ; case JPEG2000_QSTY_SI : numbps = cbps + lut_gain [ codsty -> transform == FF_DWT53 ] [ bandno + ( reslevelno > 0 ) ] ; band -> f_stepsize = SHL ( 2048 + qntsty -> mant [ gbandno ] , 2 + numbps - qntsty -> expn [ gbandno ] ) ; break ; case JPEG2000_QSTY_SE : gain = cbps ; band -> f_stepsize = pow ( 2.0 , gain - qntsty -> expn [ gbandno ] ) ; band -> f_stepsize *= qntsty -> mant [ gbandno ] / 2048.0 + 1.0 ; break ; default : band -> f_stepsize = 0 ; av_log ( avctx , AV_LOG_ERROR , ""Unknown<S2SV_blank>quantization<S2SV_blank>format\\n"" ) ; break ; } if ( ! av_codec_is_encoder ( avctx -> codec ) ) band -> f_stepsize *= 0.5 ; band -> i_stepsize = band -> f_stepsize * ( 1 << 15 ) ; if ( reslevelno == 0 ) { for ( i = 0 ; i < 2 ; i ++ ) for ( j = 0 ; j < 2 ; j ++ ) band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] , declvl - 1 ) ; log2_band_prec_width = reslevel -> log2_prec_width ; log2_band_prec_height = reslevel -> log2_prec_height ; band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width ) ; band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height ) ; } else { for ( i = 0 ; i < 2 ; i ++ ) for ( j = 0 ; j < 2 ; j ++ ) band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] - ( ( ( bandno + 1 >> i ) & 1 ) << declvl - 1 ) , declvl ) ; band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width - 1 ) ; band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height - 1 ) ; log2_band_prec_width = reslevel -> log2_prec_width - 1 ; log2_band_prec_height = reslevel -> log2_prec_height - 1 ; } for ( j = 0 ; j < 2 ; j ++ ) band -> coord [ 0 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 0 ] [ j ] , dx ) ; for ( j = 0 ; j < 2 ; j ++ ) band -> coord [ 1 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 1 ] [ j ] , dy ) ;  band -> prec = av_malloc_array ( reslevel -> num_precincts_x *  ( uint64_t ) reslevel -> num_precincts_y , sizeof ( * band -> prec ) ) ; if ( ! band -> prec ) return AVERROR ( ENOMEM ) ; nb_precincts = reslevel -> num_precincts_x * reslevel -> num_precincts_y ; for ( precno = 0 ; precno < nb_precincts ; precno ++ ) { Jpeg2000Prec * prec = band -> prec + precno ; prec -> coord [ 0 ] [ 0 ] = ( precno % reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_width ) ; prec -> coord [ 0 ] [ 0 ] = FFMAX ( prec -> coord [ 0 ] [ 0 ] , band -> coord [ 0 ] [ 0 ] ) ; prec -> coord [ 1 ] [ 0 ] = ( precno / reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_height ) ; prec -> coord [ 1 ] [ 0 ] = FFMAX ( prec -> coord [ 1 ] [ 0 ] , band -> coord [ 1 ] [ 0 ] ) ; prec -> coord [ 0 ] [ 1 ] = prec -> coord [ 0 ] [ 0 ] + ( 1 << log2_band_prec_width ) ; prec -> coord [ 0 ] [ 1 ] = FFMIN ( prec -> coord [ 0 ] [ 1 ] , band -> coord [ 0 ] [ 1 ] ) ; prec -> coord [ 1 ] [ 1 ] = prec -> coord [ 1 ] [ 0 ] + ( 1 << log2_band_prec_height ) ; prec -> coord [ 1 ] [ 1 ] = FFMIN ( prec -> coord [ 1 ] [ 1 ] , band -> coord [ 1 ] [ 1 ] ) ; prec -> nb_codeblocks_width = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 0 ] [ 1 ] - prec -> coord [ 0 ] [ 0 ] , band -> log2_cblk_width ) ; prec -> nb_codeblocks_height = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 1 ] [ 1 ] - prec -> coord [ 1 ] [ 0 ] , band -> log2_cblk_height ) ; prec -> cblkincl = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ) ; if ( ! prec -> cblkincl ) return AVERROR ( ENOMEM ) ; prec -> zerobits = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ) ; if ( ! prec -> zerobits ) return AVERROR ( ENOMEM ) ; prec -> cblk = av_mallocz_array ( prec -> nb_codeblocks_width * ( uint64_t ) prec -> nb_codeblocks_height , sizeof ( * prec -> cblk ) ) ; if ( ! prec -> cblk ) return AVERROR ( ENOMEM ) ; for ( cblkno = 0 ; cblkno < prec -> nb_codeblocks_width * prec -> nb_codeblocks_height ; cblkno ++ ) { Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; uint16_t Cx0 , Cy0 ; Cx0 = ( prec -> coord [ 0 ] [ 0 ] >> band -> log2_cblk_width ) << band -> log2_cblk_width ; Cx0 = Cx0 + ( ( cblkno % prec -> nb_codeblocks_width ) << band -> log2_cblk_width ) ; cblk -> coord [ 0 ] [ 0 ] = FFMAX ( Cx0 , prec -> coord [ 0 ] [ 0 ] ) ; Cy0 = ( prec -> coord [ 1 ] [ 0 ] >> band -> log2_cblk_height ) << band -> log2_cblk_height ; Cy0 = Cy0 + ( ( cblkno / prec -> nb_codeblocks_width ) << band -> log2_cblk_height ) ; cblk -> coord [ 1 ] [ 0 ] = FFMAX ( Cy0 , prec -> coord [ 1 ] [ 0 ] ) ; cblk -> coord [ 0 ] [ 1 ] = FFMIN ( Cx0 + ( 1 << band -> log2_cblk_width ) , prec -> coord [ 0 ] [ 1 ] ) ; cblk -> coord [ 1 ] [ 1 ] = FFMIN ( Cy0 + ( 1 << band -> log2_cblk_height ) , prec -> coord [ 1 ] [ 1 ] ) ; if ( ( bandno + ! ! reslevelno ) & 1 ) { cblk -> coord [ 0 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ] ; cblk -> coord [ 0 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ] ; } if ( ( bandno + ! ! reslevelno ) & 2 ) { cblk -> coord [ 1 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ] ; cblk -> coord [ 1 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ] ; } cblk -> zero = 0 ; cblk -> lblock = 3 ; cblk -> length = 0 ; cblk -> lengthinc = 0 ; cblk -> npasses = 0 ; } } } } return 0 ; }","reslevel -> band = av_calloc ( reslevel -> nbands , sizeof ( * reslevel -> band ) ) ;if ( ! reslevel -> band ) return AVERROR ( ENOMEM ) ;",339
460,"buggy line: band -> prec = av_malloc_array ( reslevel -> num_precincts_x *  ( uint64_t ) reslevel -> num_precincts_y , sizeof ( * band -> prec ) ) ;cwe id:CWE-000context: int ff_jpeg2000_init_component ( Jpeg2000Component * comp , Jpeg2000CodingStyle * codsty , Jpeg2000QuantStyle * qntsty , int cbps , int dx , int dy , AVCodecContext * avctx ) { uint8_t log2_band_prec_width , log2_band_prec_height ; int reslevelno , bandno , gbandno = 0 , ret , i , j ; uint32_t csize ; if ( codsty -> nreslevels2decode <= 0 ) { av_log ( avctx , AV_LOG_ERROR , ""nreslevels2decode<S2SV_blank>%d<S2SV_blank>invalid<S2SV_blank>or<S2SV_blank>uninitialized\\n"" , codsty -> nreslevels2decode ) ; return AVERROR_INVALIDDATA ; } if ( ret = ff_jpeg2000_dwt_init ( & comp -> dwt , comp -> coord , codsty -> nreslevels2decode - 1 , codsty -> transform ) ) return ret ; csize = ( comp -> coord [ 0 ] [ 1 ] - comp -> coord [ 0 ] [ 0 ] ) * ( comp -> coord [ 1 ] [ 1 ] - comp -> coord [ 1 ] [ 0 ] ) ; if ( codsty -> transform == FF_DWT97 ) { comp -> i_data = NULL ; comp -> f_data = av_malloc_array ( csize , sizeof ( * comp -> f_data ) ) ; if ( ! comp -> f_data ) return AVERROR ( ENOMEM ) ; } else { comp -> f_data = NULL ; comp -> i_data = av_malloc_array ( csize , sizeof ( * comp -> i_data ) ) ; if ( ! comp -> i_data ) return AVERROR ( ENOMEM ) ; } comp -> reslevel = av_malloc_array ( codsty -> nreslevels , sizeof ( * comp -> reslevel ) ) ; if ( ! comp -> reslevel ) return AVERROR ( ENOMEM ) ; for ( reslevelno = 0 ; reslevelno < codsty -> nreslevels ; reslevelno ++ ) { int declvl = codsty -> nreslevels - reslevelno ; Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; for ( i = 0 ; i < 2 ; i ++ ) for ( j = 0 ; j < 2 ; j ++ ) reslevel -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] , declvl - 1 ) ; reslevel -> log2_prec_width = codsty -> log2_prec_widths [ reslevelno ] ; reslevel -> log2_prec_height = codsty -> log2_prec_heights [ reslevelno ] ; if ( reslevelno == 0 ) reslevel -> nbands = 1 ; else reslevel -> nbands = 3 ; if ( reslevel -> coord [ 0 ] [ 1 ] == reslevel -> coord [ 0 ] [ 0 ] ) reslevel -> num_precincts_x = 0 ; else reslevel -> num_precincts_x = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 0 ] [ 1 ] , reslevel -> log2_prec_width ) - ( reslevel -> coord [ 0 ] [ 0 ] >> reslevel -> log2_prec_width ) ; if ( reslevel -> coord [ 1 ] [ 1 ] == reslevel -> coord [ 1 ] [ 0 ] ) reslevel -> num_precincts_y = 0 ; else reslevel -> num_precincts_y = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 1 ] [ 1 ] , reslevel -> log2_prec_height ) - ( reslevel -> coord [ 1 ] [ 0 ] >> reslevel -> log2_prec_height ) ;  reslevel -> band = av_malloc_array ( reslevel -> nbands , sizeof ( * reslevel -> band ) ) ;  if ( ! reslevel -> band ) return AVERROR ( ENOMEM ) ; for ( bandno = 0 ; bandno < reslevel -> nbands ; bandno ++ , gbandno ++ ) { Jpeg2000Band * band = reslevel -> band + bandno ; int cblkno , precno ; int nb_precincts ; switch ( qntsty -> quantsty ) { uint8_t gain ; int numbps ; case JPEG2000_QSTY_NONE : band -> f_stepsize = 1 ; break ; case JPEG2000_QSTY_SI : numbps = cbps + lut_gain [ codsty -> transform == FF_DWT53 ] [ bandno + ( reslevelno > 0 ) ] ; band -> f_stepsize = SHL ( 2048 + qntsty -> mant [ gbandno ] , 2 + numbps - qntsty -> expn [ gbandno ] ) ; break ; case JPEG2000_QSTY_SE : gain = cbps ; band -> f_stepsize = pow ( 2.0 , gain - qntsty -> expn [ gbandno ] ) ; band -> f_stepsize *= qntsty -> mant [ gbandno ] / 2048.0 + 1.0 ; break ; default : band -> f_stepsize = 0 ; av_log ( avctx , AV_LOG_ERROR , ""Unknown<S2SV_blank>quantization<S2SV_blank>format\\n"" ) ; break ; } if ( ! av_codec_is_encoder ( avctx -> codec ) ) band -> f_stepsize *= 0.5 ; band -> i_stepsize = band -> f_stepsize * ( 1 << 15 ) ; if ( reslevelno == 0 ) { for ( i = 0 ; i < 2 ; i ++ ) for ( j = 0 ; j < 2 ; j ++ ) band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] , declvl - 1 ) ; log2_band_prec_width = reslevel -> log2_prec_width ; log2_band_prec_height = reslevel -> log2_prec_height ; band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width ) ; band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height ) ; } else { for ( i = 0 ; i < 2 ; i ++ ) for ( j = 0 ; j < 2 ; j ++ ) band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] - ( ( ( bandno + 1 >> i ) & 1 ) << declvl - 1 ) , declvl ) ; band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width - 1 ) ; band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height - 1 ) ; log2_band_prec_width = reslevel -> log2_prec_width - 1 ; log2_band_prec_height = reslevel -> log2_prec_height - 1 ; } for ( j = 0 ; j < 2 ; j ++ ) band -> coord [ 0 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 0 ] [ j ] , dx ) ; for ( j = 0 ; j < 2 ; j ++ ) band -> coord [ 1 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 1 ] [ j ] , dy ) ;  band -> prec = av_malloc_array ( reslevel -> num_precincts_x *  ( uint64_t ) reslevel -> num_precincts_y , sizeof ( * band -> prec ) ) ; if ( ! band -> prec ) return AVERROR ( ENOMEM ) ; nb_precincts = reslevel -> num_precincts_x * reslevel -> num_precincts_y ; for ( precno = 0 ; precno < nb_precincts ; precno ++ ) { Jpeg2000Prec * prec = band -> prec + precno ; prec -> coord [ 0 ] [ 0 ] = ( precno % reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_width ) ; prec -> coord [ 0 ] [ 0 ] = FFMAX ( prec -> coord [ 0 ] [ 0 ] , band -> coord [ 0 ] [ 0 ] ) ; prec -> coord [ 1 ] [ 0 ] = ( precno / reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_height ) ; prec -> coord [ 1 ] [ 0 ] = FFMAX ( prec -> coord [ 1 ] [ 0 ] , band -> coord [ 1 ] [ 0 ] ) ; prec -> coord [ 0 ] [ 1 ] = prec -> coord [ 0 ] [ 0 ] + ( 1 << log2_band_prec_width ) ; prec -> coord [ 0 ] [ 1 ] = FFMIN ( prec -> coord [ 0 ] [ 1 ] , band -> coord [ 0 ] [ 1 ] ) ; prec -> coord [ 1 ] [ 1 ] = prec -> coord [ 1 ] [ 0 ] + ( 1 << log2_band_prec_height ) ; prec -> coord [ 1 ] [ 1 ] = FFMIN ( prec -> coord [ 1 ] [ 1 ] , band -> coord [ 1 ] [ 1 ] ) ; prec -> nb_codeblocks_width = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 0 ] [ 1 ] - prec -> coord [ 0 ] [ 0 ] , band -> log2_cblk_width ) ; prec -> nb_codeblocks_height = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 1 ] [ 1 ] - prec -> coord [ 1 ] [ 0 ] , band -> log2_cblk_height ) ; prec -> cblkincl = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ) ; if ( ! prec -> cblkincl ) return AVERROR ( ENOMEM ) ; prec -> zerobits = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ) ; if ( ! prec -> zerobits ) return AVERROR ( ENOMEM ) ; prec -> cblk = av_mallocz_array ( prec -> nb_codeblocks_width * ( uint64_t ) prec -> nb_codeblocks_height , sizeof ( * prec -> cblk ) ) ; if ( ! prec -> cblk ) return AVERROR ( ENOMEM ) ; for ( cblkno = 0 ; cblkno < prec -> nb_codeblocks_width * prec -> nb_codeblocks_height ; cblkno ++ ) { Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; uint16_t Cx0 , Cy0 ; Cx0 = ( prec -> coord [ 0 ] [ 0 ] >> band -> log2_cblk_width ) << band -> log2_cblk_width ; Cx0 = Cx0 + ( ( cblkno % prec -> nb_codeblocks_width ) << band -> log2_cblk_width ) ; cblk -> coord [ 0 ] [ 0 ] = FFMAX ( Cx0 , prec -> coord [ 0 ] [ 0 ] ) ; Cy0 = ( prec -> coord [ 1 ] [ 0 ] >> band -> log2_cblk_height ) << band -> log2_cblk_height ; Cy0 = Cy0 + ( ( cblkno / prec -> nb_codeblocks_width ) << band -> log2_cblk_height ) ; cblk -> coord [ 1 ] [ 0 ] = FFMAX ( Cy0 , prec -> coord [ 1 ] [ 0 ] ) ; cblk -> coord [ 0 ] [ 1 ] = FFMIN ( Cx0 + ( 1 << band -> log2_cblk_width ) , prec -> coord [ 0 ] [ 1 ] ) ; cblk -> coord [ 1 ] [ 1 ] = FFMIN ( Cy0 + ( 1 << band -> log2_cblk_height ) , prec -> coord [ 1 ] [ 1 ] ) ; if ( ( bandno + ! ! reslevelno ) & 1 ) { cblk -> coord [ 0 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ] ; cblk -> coord [ 0 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ] ; } if ( ( bandno + ! ! reslevelno ) & 2 ) { cblk -> coord [ 1 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ] ; cblk -> coord [ 1 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ] ; } cblk -> zero = 0 ; cblk -> lblock = 3 ; cblk -> length = 0 ; cblk -> lengthinc = 0 ; cblk -> npasses = 0 ; } } } } return 0 ; }","band -> prec = av_calloc ( reslevel -> num_precincts_x * ( uint64_t ) reslevel -> num_precincts_y , sizeof ( * band -> prec ) ) ;",339
461,"buggy line: COM_DefaultExtension ( filename , sizeof ( filename ) , "".txt"" ) ;f = FS_FOpenFileWrite ( filename ) ;cwe id:CWE-269context: void Con_Dump_f ( void ) { int l , x , i ; short * line ; fileHandle_t f ; int bufferlen ; char * buffer ; char filename [ MAX_QPATH ] ; if ( Cmd_Argc ( ) != 2 ) { Com_Printf ( ""usage:<S2SV_blank>condump<S2SV_blank><filename>\\n"" ) ; return ; } Q_strncpyz ( filename , Cmd_Argv ( 1 ) , sizeof ( filename ) ) ;  COM_DefaultExtension ( filename , sizeof ( filename ) , "".txt"" ) ;  f = FS_FOpenFileWrite ( filename ) ; if ( ! f ) { Com_Printf ( ""ERROR:<S2SV_blank>couldn\'t<S2SV_blank>open<S2SV_blank>%s.\\n"" , filename ) ; return ; } Com_Printf ( ""Dumped<S2SV_blank>console<S2SV_blank>text<S2SV_blank>to<S2SV_blank>%s.\\n"" , filename ) ; for ( l = con . current - con . totallines + 1 ; l <= con . current ; l ++ ) { line = con . text + ( l % con . totallines ) * con . linewidth ; for ( x = 0 ; x < con . linewidth ; x ++ ) if ( ( line [ x ] & 0xff ) != '<S2SV_blank>' ) { break ; } if ( x != con . linewidth ) { break ; } } # ifdef _WIN32 bufferlen = con . linewidth + 3 * sizeof ( char ) ; # else bufferlen = con . linewidth + 2 * sizeof ( char ) ; # endif buffer = Hunk_AllocateTempMemory ( bufferlen ) ; buffer [ bufferlen - 1 ] = 0 ; for ( ; l <= con . current ; l ++ ) { line = con . text + ( l % con . totallines ) * con . linewidth ; for ( i = 0 ; i < con . linewidth ; i ++ ) buffer [ i ] = line [ i ] & 0xff ; for ( x = con . linewidth - 1 ; x >= 0 ; x -- ) { if ( buffer [ x ] == '<S2SV_blank>' ) { buffer [ x ] = 0 ; } else { break ; } } # ifdef _WIN32 Q_strcat ( buffer , bufferlen , ""\\r\\n"" ) ; # else Q_strcat ( buffer , bufferlen , ""\\n"" ) ; # endif FS_Write ( buffer , strlen ( buffer ) , f ) ; } Hunk_FreeTempMemory ( buffer ) ; FS_FCloseFile ( f ) ; }","COM_DefaultExtension ( filename , sizeof ( filename ) , "".txt"" ) ;if ( ! COM_CompareExtension ( filename , "".txt"" ) ) {Com_Printf ( ""Con_Dump_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\\\"".txt\\\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\\return ;}f = FS_FOpenFileWrite ( filename ) ;",340
462,"buggy line: amount = n_got * sizeof ( ut32 ) ;if ( amount < n_got || amount > UT32_MAX ) {goto out_error ;}struct reloc_struct_t * got_table = calloc ( 1 , n_got * sizeof ( ut32 ) ) ;if ( got_table ) {cwe id:CWE-119context: static RList * relocs ( RBinFile * arch ) { struct r_bin_bflt_obj * obj = ( struct r_bin_bflt_obj * ) arch -> o -> bin_obj ; RList * list = r_list_newf ( ( RListFree ) free ) ; int i , len , n_got , amount ; if ( ! list || ! obj ) { r_list_free ( list ) ; return NULL ; } if ( obj -> hdr -> flags & FLAT_FLAG_GOTPIC ) { n_got = get_ngot_entries ( obj ) ; if ( n_got ) { amount = n_got * sizeof ( ut32 ) ; if ( amount < n_got || amount > UT32_MAX ) { goto out_error ; }  struct reloc_struct_t * got_table = calloc ( 1 , n_got * sizeof ( ut32 ) ) ;  if ( got_table ) { ut32 offset = 0 ; for ( i = 0 ; i < n_got ; offset += 4 , i ++ ) { ut32 got_entry ; if ( obj -> hdr -> data_start + offset + 4 > obj -> size || obj -> hdr -> data_start + offset + 4 < offset ) { break ; } len = r_buf_read_at ( obj -> b , obj -> hdr -> data_start + offset , ( ut8 * ) & got_entry , sizeof ( ut32 ) ) ; if ( ! VALID_GOT_ENTRY ( got_entry ) || len != sizeof ( ut32 ) ) { break ; } got_table [ i ] . addr_to_patch = got_entry ; got_table [ i ] . data_offset = got_entry + BFLT_HDR_SIZE ; } obj -> n_got = n_got ; obj -> got_table = got_table ; } } } if ( obj -> hdr -> reloc_count > 0 ) { int n_reloc = obj -> hdr -> reloc_count ; amount = n_reloc * sizeof ( struct reloc_struct_t ) ; if ( amount < n_reloc || amount > UT32_MAX ) { goto out_error ; } struct reloc_struct_t * reloc_table = calloc ( 1 , amount + 1 ) ; if ( ! reloc_table ) { goto out_error ; } amount = n_reloc * sizeof ( ut32 ) ; if ( amount < n_reloc || amount > UT32_MAX ) { free ( reloc_table ) ; goto out_error ; } ut32 * reloc_pointer_table = calloc ( 1 , amount + 1 ) ; if ( ! reloc_pointer_table ) { free ( reloc_table ) ; goto out_error ; } if ( obj -> hdr -> reloc_start + amount > obj -> size || obj -> hdr -> reloc_start + amount < amount ) { free ( reloc_table ) ; free ( reloc_pointer_table ) ; goto out_error ; } len = r_buf_read_at ( obj -> b , obj -> hdr -> reloc_start , ( ut8 * ) reloc_pointer_table , amount ) ; if ( len != amount ) { free ( reloc_table ) ; free ( reloc_pointer_table ) ; goto out_error ; } for ( i = 0 ; i < obj -> hdr -> reloc_count ; i ++ ) { ut32 reloc_offset = r_swap_ut32 ( reloc_pointer_table [ i ] ) + BFLT_HDR_SIZE ; if ( reloc_offset < obj -> hdr -> bss_end && reloc_offset < obj -> size ) { ut32 reloc_fixed , reloc_data_offset ; if ( reloc_offset + sizeof ( ut32 ) > obj -> size || reloc_offset + sizeof ( ut32 ) < reloc_offset ) { free ( reloc_table ) ; free ( reloc_pointer_table ) ; goto out_error ; } len = r_buf_read_at ( obj -> b , reloc_offset , ( ut8 * ) & reloc_fixed , sizeof ( ut32 ) ) ; if ( len != sizeof ( ut32 ) ) { eprintf ( ""problem<S2SV_blank>while<S2SV_blank>reading<S2SV_blank>relocation<S2SV_blank>entries\\n"" ) ; free ( reloc_table ) ; free ( reloc_pointer_table ) ; goto out_error ; } reloc_data_offset = r_swap_ut32 ( reloc_fixed ) + BFLT_HDR_SIZE ; reloc_table [ i ] . addr_to_patch = reloc_offset ; reloc_table [ i ] . data_offset = reloc_data_offset ; RBinReloc * reloc = R_NEW0 ( RBinReloc ) ; if ( reloc ) { reloc -> type = R_BIN_RELOC_32 ; reloc -> paddr = reloc_table [ i ] . addr_to_patch ; reloc -> vaddr = reloc -> paddr ; r_list_append ( list , reloc ) ; } } } free ( reloc_pointer_table ) ; obj -> reloc_table = reloc_table ; } return list ; out_error : r_list_free ( list ) ; return NULL ; }",amount = n_got * sizeof ( struct reloc_struct_t ) ) ;if ( got_table ) {,341
463,"buggy line: if ( info -> si_code >= 0 )   return - EPERM ;info -> si_signo = sig ;cwe id:CWE-000context: long do_rt_tgsigqueueinfo ( pid_t tgid , pid_t pid , int sig , siginfo_t * info ) { if ( pid <= 0 || tgid <= 0 ) return - EINVAL ;  if ( info -> si_code >= 0 )   return - EPERM ;  info -> si_signo = sig ; return do_send_specific ( tgid , pid , sig , info ) ; }",if ( info -> si_code != SI_QUEUE ) {WARN_ON_ONCE ( info -> si_code < 0 ) ;return - EPERM ;}info -> si_signo = sig ;,342
464,"buggy line: * p_tx0 = opj_int_max ( ( OPJ_INT32 ) ( p_cp -> tx0 + p * p_cp -> tdx ) , ( OPJ_INT32 ) p_image -> x0 ) ;* p_tx1 = opj_int_min ( ( OPJ_INT32 ) ( p_cp -> tx0 + ( p + 1 ) * p_cp -> tdx ) , ( OPJ_INT32 ) p_image -> x1 ) ;* p_ty0 = opj_int_max ( ( OPJ_INT32 ) ( p_cp -> ty0 + q * p_cp -> tdy ) , ( OPJ_INT32 ) p_image -> y0 ) ;* p_ty1 = opj_int_min ( ( OPJ_INT32 ) ( p_cp -> ty0 + ( q + 1 ) * p_cp -> tdy ) , ( OPJ_INT32 ) p_image -> y1 ) ;* p_max_prec = 0 ;cwe id:CWE-190context: void opj_get_all_encoding_parameters ( const opj_image_t * p_image , const opj_cp_t * p_cp , OPJ_UINT32 tileno , OPJ_INT32 * p_tx0 , OPJ_INT32 * p_tx1 , OPJ_INT32 * p_ty0 , OPJ_INT32 * p_ty1 , OPJ_UINT32 * p_dx_min , OPJ_UINT32 * p_dy_min , OPJ_UINT32 * p_max_prec , OPJ_UINT32 * p_max_res , OPJ_UINT32 * * p_resolutions ) { OPJ_UINT32 compno , resno ; const opj_tcp_t * tcp = 00 ; const opj_tccp_t * l_tccp = 00 ; const opj_image_comp_t * l_img_comp = 00 ; OPJ_UINT32 * lResolutionPtr ; OPJ_UINT32 p , q ; assert ( p_cp != 00 ) ; assert ( p_image != 00 ) ; assert ( tileno < p_cp -> tw * p_cp -> th ) ; tcp = & p_cp -> tcps [ tileno ] ; l_tccp = tcp -> tccps ; l_img_comp = p_image -> comps ; p = tileno % p_cp -> tw ; q = tileno / p_cp -> tw ;  * p_tx0 = opj_int_max ( ( OPJ_INT32 ) ( p_cp -> tx0 + p * p_cp -> tdx ) , ( OPJ_INT32 ) p_image -> x0 ) ;   * p_tx1 = opj_int_min ( ( OPJ_INT32 ) ( p_cp -> tx0 + ( p + 1 ) * p_cp -> tdx ) , ( OPJ_INT32 ) p_image -> x1 ) ;   * p_ty0 = opj_int_max ( ( OPJ_INT32 ) ( p_cp -> ty0 + q * p_cp -> tdy ) , ( OPJ_INT32 ) p_image -> y0 ) ;   * p_ty1 = opj_int_min ( ( OPJ_INT32 ) ( p_cp -> ty0 + ( q + 1 ) * p_cp -> tdy ) , ( OPJ_INT32 ) p_image -> y1 ) ;  * p_max_prec = 0 ; * p_max_res = 0 ; * p_dx_min = 0x7fffffff ; * p_dy_min = 0x7fffffff ; for ( compno = 0 ; compno < p_image -> numcomps ; ++ compno ) { OPJ_UINT32 l_level_no ; OPJ_INT32 l_rx0 , l_ry0 , l_rx1 , l_ry1 ; OPJ_INT32 l_px0 , l_py0 , l_px1 , py1 ; OPJ_UINT32 l_product ; OPJ_INT32 l_tcx0 , l_tcy0 , l_tcx1 , l_tcy1 ; OPJ_UINT32 l_pdx , l_pdy , l_pw , l_ph ; lResolutionPtr = p_resolutions [ compno ] ; l_tcx0 = opj_int_ceildiv ( * p_tx0 , ( OPJ_INT32 ) l_img_comp -> dx ) ; l_tcy0 = opj_int_ceildiv ( * p_ty0 , ( OPJ_INT32 ) l_img_comp -> dy ) ; l_tcx1 = opj_int_ceildiv ( * p_tx1 , ( OPJ_INT32 ) l_img_comp -> dx ) ; l_tcy1 = opj_int_ceildiv ( * p_ty1 , ( OPJ_INT32 ) l_img_comp -> dy ) ; if ( l_tccp -> numresolutions > * p_max_res ) { * p_max_res = l_tccp -> numresolutions ; } l_level_no = l_tccp -> numresolutions - 1 ; for ( resno = 0 ; resno < l_tccp -> numresolutions ; ++ resno ) { OPJ_UINT32 l_dx , l_dy ; l_pdx = l_tccp -> prcw [ resno ] ; l_pdy = l_tccp -> prch [ resno ] ; * lResolutionPtr ++ = l_pdx ; * lResolutionPtr ++ = l_pdy ; l_dx = l_img_comp -> dx * ( 1u << ( l_pdx + l_level_no ) ) ; l_dy = l_img_comp -> dy * ( 1u << ( l_pdy + l_level_no ) ) ; * p_dx_min = ( OPJ_UINT32 ) opj_int_min ( ( OPJ_INT32 ) * p_dx_min , ( OPJ_INT32 ) l_dx ) ; * p_dy_min = ( OPJ_UINT32 ) opj_int_min ( ( OPJ_INT32 ) * p_dy_min , ( OPJ_INT32 ) l_dy ) ; l_rx0 = opj_int_ceildivpow2 ( l_tcx0 , ( OPJ_INT32 ) l_level_no ) ; l_ry0 = opj_int_ceildivpow2 ( l_tcy0 , ( OPJ_INT32 ) l_level_no ) ; l_rx1 = opj_int_ceildivpow2 ( l_tcx1 , ( OPJ_INT32 ) l_level_no ) ; l_ry1 = opj_int_ceildivpow2 ( l_tcy1 , ( OPJ_INT32 ) l_level_no ) ; l_px0 = opj_int_floordivpow2 ( l_rx0 , ( OPJ_INT32 ) l_pdx ) << l_pdx ; l_py0 = opj_int_floordivpow2 ( l_ry0 , ( OPJ_INT32 ) l_pdy ) << l_pdy ; l_px1 = opj_int_ceildivpow2 ( l_rx1 , ( OPJ_INT32 ) l_pdx ) << l_pdx ; py1 = opj_int_ceildivpow2 ( l_ry1 , ( OPJ_INT32 ) l_pdy ) << l_pdy ; l_pw = ( l_rx0 == l_rx1 ) ? 0 : ( OPJ_UINT32 ) ( ( l_px1 - l_px0 ) >> l_pdx ) ; l_ph = ( l_ry0 == l_ry1 ) ? 0 : ( OPJ_UINT32 ) ( ( py1 - l_py0 ) >> l_pdy ) ; * lResolutionPtr ++ = l_pw ; * lResolutionPtr ++ = l_ph ; l_product = l_pw * l_ph ; if ( l_product > * p_max_prec ) { * p_max_prec = l_product ; } -- l_level_no ; } ++ l_tccp ; ++ l_img_comp ; } }","* p_tx0 = ( OPJ_INT32 ) opj_uint_max ( p_cp -> tx0 + p * p_cp -> tdx , p_image -> x0 ) ;* p_tx1 = opj_int_min ( ( OPJ_INT32 ) ( p_cp -> tx0 + ( p + 1 ) * p_cp -> tdx , p_image -> x1 ) ;* p_ty0 = opj_int_max ( ( OPJ_INT32 ) ( p_cp -> ty0 + q * p_cp -> tdy , p_image -> y0 ) ;* p_ty1 = opj_int_min ( ( OPJ_INT32 ) ( p_cp -> ty0 + ( q + 1 ) * p_cp -> tdy , p_image -> y1 ) ;* p_max_prec = 0 ;",343
465,"buggy line: static char * create_output_name ( unsigned char * fname , unsigned char * dir ,  int lower , int isunix , int utf8 ) {unsigned char * p , * name , c , * fe , sep , slash ;unsigned int x ;sep = ( isunix ) ? \'/\' : \'\\\\\\\\\' ;slash = ( isunix ) ? \'\\\\\\\\\' : \'/\' ;x = strlen ( ( char * ) fname ) ;if ( utf8 ) x *= 3 ;if ( dir ) x += strlen ( ( char * ) dir ) ;fprintf ( stderr , ""out<S2SV_blank>of<S2SV_blank>memory!\\\return NULL ;while ( * fname == sep ) fname ++ ;p = & name [ strlen ( ( char * ) name ) ] ;fe = & fname [ strlen ( ( char * ) fname ) ] ;if ( utf8 ) {do {if ( fname >= fe ) {free ( name ) ;if ( ( c >= 0xC0 ) && ( c < 0xE0 ) ) {x = ( c & 0x1F ) << 6 ;x |= * fname ++ & 0x3F ;}else if ( ( c >= 0xE0 ) && ( c < 0xF0 ) ) {x = ( c & 0xF ) << 12 ;x |= ( * fname ++ & 0x3F ) << 6 ;x |= * fname ++ & 0x3F ;}else x = \'?\' ;}if ( x == sep ) x = \'/\' ;else if ( x == slash ) x = \'\\\\\\\\\' ;else if ( lower ) x = ( unsigned int ) tolower ( ( int ) x ) ;if ( x < 0x80 ) {* p ++ = ( unsigned char ) x ;}else if ( x < 0x800 ) {* p ++ = 0xC0 | ( x >> 6 ) ;* p ++ = 0x80 | ( x & 0x3F ) ;}else {* p ++ = 0xE0 | ( x >> 12 ) ;* p ++ = 0x80 | ( ( x >> 6 ) & 0x3F ) ;* p ++ = 0x80 | ( x & 0x3F ) ;}while ( x ) ;}else {do {c = * fname ++ ;if ( c == sep ) c = \'/\' ;else if ( c == slash ) c = \'\\\\\\\\\' ;else if ( lower ) c = ( unsigned char ) tolower ( ( int ) c ) ;while ( ( * p ++ = c ) ) ;return ( char * ) name ;cwe id:CWE-22context:  static char * create_output_name ( unsigned char * fname , unsigned char * dir ,  int lower , int isunix , int utf8 ) { unsigned char * p , * name , c , * fe , sep , slash ; unsigned int x ; sep = ( isunix ) ? '/' : '\\\\' ; slash = ( isunix ) ? '\\\\' : '/' ; x = strlen ( ( char * ) fname ) ;  if ( utf8 ) x *= 3 ;  if ( dir ) x += strlen ( ( char * ) dir ) ; if ( ! ( name = ( unsigned char * ) malloc ( x + 2 ) ) ) {  fprintf ( stderr , ""out<S2SV_blank>of<S2SV_blank>memory!\\n"" ) ;  return NULL ; } * name = '\\0' ; if ( dir ) { strcpy ( ( char * ) name , ( char * ) dir ) ; strcat ( ( char * ) name , ""/"" ) ; }  while ( * fname == sep ) fname ++ ;   p = & name [ strlen ( ( char * ) name ) ] ;  fe = & fname [ strlen ( ( char * ) fname ) ] ; if ( utf8 ) { do {  if ( fname >= fe ) {  free ( name ) ; return NULL ; } if ( ( c = * fname ++ ) < 0x80 ) x = c ; else { if ( ( c >= 0xC0 ) && ( c < 0xE0 ) ) {  x = ( c & 0x1F ) << 6 ;  x |= * fname ++ & 0x3F ; } else if ( ( c >= 0xE0 ) && ( c < 0xF0 ) ) { x = ( c & 0xF ) << 12 ; x |= ( * fname ++ & 0x3F ) << 6 ; x |= * fname ++ & 0x3F ; } else x = '?' ; } if ( x == sep ) x = '/' ; else if ( x == slash ) x = '\\\\' ; else if ( lower ) x = ( unsigned int ) tolower ( ( int ) x ) ; if ( x < 0x80 ) { * p ++ = ( unsigned char ) x ; } else if ( x < 0x800 ) { * p ++ = 0xC0 | ( x >> 6 ) ; * p ++ = 0x80 | ( x & 0x3F ) ; } else { * p ++ = 0xE0 | ( x >> 12 ) ; * p ++ = 0x80 | ( ( x >> 6 ) & 0x3F ) ; * p ++ = 0x80 | ( x & 0x3F ) ; }  } while ( x ) ;  } else { do { c = * fname ++ ; if ( c == sep ) c = '/' ; else if ( c == slash ) c = '\\\\' ; else if ( lower ) c = ( unsigned char ) tolower ( ( int ) c ) ; } while ( ( * p ++ = c ) ) ; } return ( char * ) name ; }","char * create_output_name ( unsigned char * fname ) {char * out , * p ;if ( utf8 ) x *= 3 ;if ( dir ) x += strlen ( ( char * ) dir ) ;fprintf ( stderr , ""out<S2SV_blank>of<S2SV_blank>memory!\\\return NULL ;while ( * fname == \'/\' || * fname == \'\\\\\\\\\' ) fname ++ ;strcpy ( out , ( * fname ) ? fname : ""x"" ) ;for ( p = out ;* p ;p ++ ) {if ( fname >= fe ) {free ( name ) ;if ( p [ 0 ] == \'.\' && p [ 1 ] == \'.\' && ( p [ 2 ] == \'/\' || p [ 2 ] == \'\\\\\\\\\' ) ) {p [ 0 ] = p [ 1 ] = \'x\' ;return out ;",344
466,"buggy line: zval * options = NULL , * classes = NULL ;HashTable * class_hash = NULL ;cwe id:CWE-416context: PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ;  zval * options = NULL , * classes = NULL ;  HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } }  if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) {  PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; }  zval_ptr_dtor ( return_value ) ;  if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>"" ZEND_LONG_FMT ""<S2SV_blank>of<S2SV_blank>%zd<S2SV_blank>bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; }  var_push_dtor ( & var_hash , return_value ) ;  PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }","zval * options = NULL , * classes = NULL ;zval * retval ;HashTable * class_hash = NULL ;",345
467,"buggy line: if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) {PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ;zval_ptr_dtor ( return_value ) ;if ( ! EG ( exception ) ) {var_push_dtor ( & var_hash , return_value ) ;PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ;cwe id:CWE-416context: PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ;  zval * options = NULL , * classes = NULL ;  HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } }  if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) {  PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; }  zval_ptr_dtor ( return_value ) ;  if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>"" ZEND_LONG_FMT ""<S2SV_blank>of<S2SV_blank>%zd<S2SV_blank>bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; }  var_push_dtor ( & var_hash , return_value ) ;  PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }","retval = var_tmp_var ( & var_hash ) ;if ( ! php_var_unserialize_ex ( retval , & p , p + buf_len , & var_hash , class_hash ) ) {PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ;if ( ! EG ( exception ) ) {ZVAL_COPY ( return_value , retval ) ;PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ;",345
468,"buggy line: kfree ( tu -> queue ) ;tu -> queue = NULL ;cwe id:CWE-200context: static int snd_timer_user_tselect ( struct file * file , struct snd_timer_select __user * _tselect ) { struct snd_timer_user * tu ; struct snd_timer_select tselect ; char str [ 32 ] ; int err = 0 ; tu = file -> private_data ; if ( tu -> timeri ) { snd_timer_close ( tu -> timeri ) ; tu -> timeri = NULL ; } if ( copy_from_user ( & tselect , _tselect , sizeof ( tselect ) ) ) { err = - EFAULT ; goto __err ; } sprintf ( str , ""application<S2SV_blank>%i"" , current -> pid ) ; if ( tselect . id . dev_class != SNDRV_TIMER_CLASS_SLAVE ) tselect . id . dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION ; err = snd_timer_open ( & tu -> timeri , str , & tselect . id , current -> pid ) ; if ( err < 0 ) goto __err ;  kfree ( tu -> queue ) ;  tu -> queue = NULL ; kfree ( tu -> tqueue ) ; tu -> tqueue = NULL ; if ( tu -> tread ) { tu -> tqueue = kmalloc ( tu -> queue_size * sizeof ( struct snd_timer_tread ) , GFP_KERNEL ) ; if ( tu -> tqueue == NULL ) err = - ENOMEM ; } else { tu -> queue = kmalloc ( tu -> queue_size * sizeof ( struct snd_timer_read ) , GFP_KERNEL ) ; if ( tu -> queue == NULL ) err = - ENOMEM ; } if ( err < 0 ) { snd_timer_close ( tu -> timeri ) ; tu -> timeri = NULL ; } else { tu -> timeri -> flags |= SNDRV_TIMER_IFLG_FAST ; tu -> timeri -> callback = tu -> tread ? snd_timer_user_tinterrupt : snd_timer_user_interrupt ; tu -> timeri -> ccallback = snd_timer_user_ccallback ; tu -> timeri -> callback_data = ( void * ) tu ; tu -> timeri -> disconnect = snd_timer_user_disconnect ; } __err : return err ; }",tu -> qhead = tu -> qtail = tu -> qused = 0 ;kfree ( tu -> queue ) ;tu -> queue = NULL ;,346
469,"buggy line: if ( ptr -> size < 8 ) return GF_ISOM_INVALID_FILE ;tmp_strsize = ( u32 ) ptr -> size - 8 ;tmp_str = gf_malloc ( sizeof ( char ) * tmp_strsize ) ;cwe id:CWE-125context: GF_Err abst_box_read ( GF_Box * s , GF_BitStream * bs ) { GF_AdobeBootstrapInfoBox * ptr = ( GF_AdobeBootstrapInfoBox * ) s ; int i ; u32 tmp_strsize ; char * tmp_str ; GF_Err e ; ISOM_DECREASE_SIZE ( ptr , 25 ) ptr -> bootstrapinfo_version = gf_bs_read_u32 ( bs ) ; ptr -> profile = gf_bs_read_int ( bs , 2 ) ; ptr -> live = gf_bs_read_int ( bs , 1 ) ; ptr -> update = gf_bs_read_int ( bs , 1 ) ; ptr -> reserved = gf_bs_read_int ( bs , 4 ) ; ptr -> time_scale = gf_bs_read_u32 ( bs ) ; ptr -> current_media_time = gf_bs_read_u64 ( bs ) ; ptr -> smpte_time_code_offset = gf_bs_read_u64 ( bs ) ; i = 0 ; if ( ptr -> size < 8 ) return GF_ISOM_INVALID_FILE ;  tmp_strsize = ( u32 ) ptr -> size - 8 ;  tmp_str = gf_malloc ( sizeof ( char ) * tmp_strsize ) ; if ( ! tmp_str ) return GF_OUT_OF_MEM ; memset ( tmp_str , 0 , sizeof ( char ) * tmp_strsize ) ; while ( tmp_strsize ) { ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ i ] = gf_bs_read_u8 ( bs ) ; tmp_strsize -- ; if ( ! tmp_str [ i ] ) break ; i ++ ; } if ( i ) { ptr -> movie_identifier = gf_strdup ( tmp_str ) ; } ISOM_DECREASE_SIZE ( ptr , 1 ) ptr -> server_entry_count = gf_bs_read_u8 ( bs ) ; for ( i = 0 ; i < ptr -> server_entry_count ; i ++ ) { int j = 0 ; tmp_strsize = ( u32 ) ptr -> size ; while ( tmp_strsize ) { ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ j ] = gf_bs_read_u8 ( bs ) ; tmp_strsize -- ; if ( ! tmp_str [ j ] ) break ; j ++ ; } if ( j ) { gf_list_insert ( ptr -> server_entry_table , gf_strdup ( tmp_str ) , i ) ; } } ISOM_DECREASE_SIZE ( ptr , 1 ) ptr -> quality_entry_count = gf_bs_read_u8 ( bs ) ; for ( i = 0 ; i < ptr -> quality_entry_count ; i ++ ) { int j = 0 ; tmp_strsize = ( u32 ) ptr -> size ; while ( tmp_strsize ) { ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ j ] = gf_bs_read_u8 ( bs ) ; tmp_strsize -- ; if ( ! tmp_str [ j ] ) break ; j ++ ; } if ( j ) { gf_list_insert ( ptr -> quality_entry_table , gf_strdup ( tmp_str ) , i ) ; } } i = 0 ; tmp_strsize = ( u32 ) ptr -> size ; while ( tmp_strsize ) { ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ i ] = gf_bs_read_u8 ( bs ) ; tmp_strsize -- ; if ( ! tmp_str [ i ] ) break ; i ++ ; } if ( i ) { ptr -> drm_data = gf_strdup ( tmp_str ) ; } i = 0 ; tmp_strsize = ( u32 ) ptr -> size ; while ( tmp_strsize ) { ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ i ] = gf_bs_read_u8 ( bs ) ; tmp_strsize -- ; if ( ! tmp_str [ i ] ) break ; i ++ ; } if ( i ) { ptr -> meta_data = gf_strdup ( tmp_str ) ; } ISOM_DECREASE_SIZE ( ptr , 1 ) ptr -> segment_run_table_count = gf_bs_read_u8 ( bs ) ; for ( i = 0 ; i < ptr -> segment_run_table_count ; i ++ ) { GF_AdobeSegmentRunTableBox * asrt = NULL ; e = gf_isom_box_parse ( ( GF_Box * * ) & asrt , bs ) ; if ( e ) { if ( asrt ) gf_isom_box_del ( ( GF_Box * ) asrt ) ; gf_free ( tmp_str ) ; return e ; } gf_list_add ( ptr -> segment_run_table_entries , asrt ) ; } ISOM_DECREASE_SIZE ( ptr , 1 ) ptr -> fragment_run_table_count = gf_bs_read_u8 ( bs ) ; for ( i = 0 ; i < ptr -> fragment_run_table_count ; i ++ ) { GF_AdobeFragmentRunTableBox * afrt = NULL ; e = gf_isom_box_parse ( ( GF_Box * * ) & afrt , bs ) ; if ( e ) { if ( afrt ) gf_isom_box_del ( ( GF_Box * ) afrt ) ; gf_free ( tmp_str ) ; return e ; } gf_list_add ( ptr -> fragment_run_table_entries , afrt ) ; } gf_free ( tmp_str ) ; return GF_OK ; }",if ( ptr -> size ;tmp_str = gf_malloc ( sizeof ( char ) * tmp_strsize ) ;,347
470,buggy line: else  buf = ctx -> iface -> enc . get_glob_hdrs ( ctx -> priv -> alg_priv ) ;}cwe id:CWE-119context: vpx_fixed_buf_t * vpx_codec_get_global_headers ( vpx_codec_ctx_t * ctx ) { vpx_fixed_buf_t * buf = NULL ; if ( ctx ) { if ( ! ctx -> iface || ! ctx -> priv ) ctx -> err = VPX_CODEC_ERROR ; else if ( ! ( ctx -> iface -> caps & VPX_CODEC_CAP_ENCODER ) ) ctx -> err = VPX_CODEC_INCAPABLE ; else if ( ! ctx -> iface -> enc . get_glob_hdrs ) ctx -> err = VPX_CODEC_INCAPABLE ; else  buf = ctx -> iface -> enc . get_glob_hdrs ( ctx -> priv -> alg_priv ) ;  } return buf ; },else buf = ctx -> iface -> enc . get_glob_hdrs ( get_alg_priv ( ctx ) ) ;},348
471,"buggy line: if ( exim_uid == 0 ) {cwe id:CWE-404context: int main ( int argc , char * * cargv ) { uschar * * argv = USS cargv ; int arg_receive_timeout = - 1 ; int arg_smtp_receive_timeout = - 1 ; int arg_error_handling = error_handling ; int filter_sfd = - 1 ; int filter_ufd = - 1 ; int group_count ; int i , rv ; int list_queue_option = 0 ; int msg_action = 0 ; int msg_action_arg = - 1 ; int namelen = ( argv [ 0 ] == NULL ) ? 0 : Ustrlen ( argv [ 0 ] ) ; int queue_only_reason = 0 ; # ifdef EXIM_PERL int perl_start_option = 0 ; # endif int recipients_arg = argc ; int sender_address_domain = 0 ; int test_retry_arg = - 1 ; int test_rewrite_arg = - 1 ; BOOL arg_queue_only = FALSE ; BOOL bi_option = FALSE ; BOOL checking = FALSE ; BOOL count_queue = FALSE ; BOOL expansion_test = FALSE ; BOOL extract_recipients = FALSE ; BOOL flag_G = FALSE ; BOOL flag_n = FALSE ; BOOL forced_delivery = FALSE ; BOOL f_end_dot = FALSE ; BOOL deliver_give_up = FALSE ; BOOL list_queue = FALSE ; BOOL list_options = FALSE ; BOOL list_config = FALSE ; BOOL local_queue_only ; BOOL more = TRUE ; BOOL one_msg_action = FALSE ; BOOL opt_D_used = FALSE ; BOOL queue_only_set = FALSE ; BOOL receiving_message = TRUE ; BOOL sender_ident_set = FALSE ; BOOL session_local_queue_only ; BOOL unprivileged ; BOOL removed_privilege = FALSE ; BOOL usage_wanted = FALSE ; BOOL verify_address_mode = FALSE ; BOOL verify_as_sender = FALSE ; BOOL version_printed = FALSE ; uschar * alias_arg = NULL ; uschar * called_as = US """" ; uschar * cmdline_syslog_name = NULL ; uschar * start_queue_run_id = NULL ; uschar * stop_queue_run_id = NULL ; uschar * expansion_test_message = NULL ; uschar * ftest_domain = NULL ; uschar * ftest_localpart = NULL ; uschar * ftest_prefix = NULL ; uschar * ftest_suffix = NULL ; uschar * log_oneline = NULL ; uschar * malware_test_file = NULL ; uschar * real_sender_address ; uschar * originator_home = US ""/"" ; size_t sz ; void * reset_point ; struct passwd * pw ; struct stat statbuf ; pid_t passed_qr_pid = ( pid_t ) 0 ; int passed_qr_pipe = - 1 ; gid_t group_list [ NGROUPS_MAX ] ; enum commandline_info info_flag = CMDINFO_NONE ; BOOL info_stdout = FALSE ; static uschar * rsopts [ ] = { US ""f"" , US ""ff"" , US ""r"" , US ""rf"" , US ""rff"" } ; extern char * * environ ; # ifdef EXIM_USERNAME if ( route_finduser ( US EXIM_USERNAME , & pw , & exim_uid ) ) { if ( exim_uid == 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>refusing<S2SV_blank>to<S2SV_blank>run<S2SV_blank>with<S2SV_blank>uid<S2SV_blank>0<S2SV_blank>for<S2SV_blank>\\""%s\\""\\n"" , EXIM_USERNAME ) ; exit ( EXIT_FAILURE ) ; } if ( pw ) exim_gid = pw -> pw_gid ; # ifndef EXIM_GROUPNAME else { fprintf ( stderr , ""exim:<S2SV_blank>ref:name<S2SV_blank>should<S2SV_blank>specify<S2SV_blank>a<S2SV_blank>usercode,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>group.\\n"" ""exim:<S2SV_blank>can\'t<S2SV_blank>let<S2SV_blank>you<S2SV_blank>get<S2SV_blank>away<S2SV_blank>with<S2SV_blank>it<S2SV_blank>unless<S2SV_blank>you<S2SV_blank>also<S2SV_blank>specify<S2SV_blank>a<S2SV_blank>group.\\n"" ) ; exit ( EXIT_FAILURE ) ; } # endif } else { fprintf ( stderr , ""exim:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>uid<S2SV_blank>for<S2SV_blank>user<S2SV_blank>name<S2SV_blank>\\""%s\\""\\n"" , EXIM_USERNAME ) ; exit ( EXIT_FAILURE ) ; } # endif # ifdef EXIM_GROUPNAME if ( ! route_findgroup ( US EXIM_GROUPNAME , & exim_gid ) ) { fprintf ( stderr , ""exim:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>gid<S2SV_blank>for<S2SV_blank>group<S2SV_blank>name<S2SV_blank>\\""%s\\""\\n"" , EXIM_GROUPNAME ) ; exit ( EXIT_FAILURE ) ; } # endif # ifdef CONFIGURE_OWNERNAME if ( ! route_finduser ( US CONFIGURE_OWNERNAME , NULL , & config_uid ) ) { fprintf ( stderr , ""exim:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>uid<S2SV_blank>for<S2SV_blank>user<S2SV_blank>name<S2SV_blank>\\""%s\\""\\n"" , CONFIGURE_OWNERNAME ) ; exit ( EXIT_FAILURE ) ; } # endif system_filter_uid = exim_uid ; # ifdef CONFIGURE_GROUPNAME if ( ! route_findgroup ( US CONFIGURE_GROUPNAME , & config_gid ) ) { fprintf ( stderr , ""exim:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>gid<S2SV_blank>for<S2SV_blank>group<S2SV_blank>name<S2SV_blank>\\""%s\\""\\n"" , CONFIGURE_GROUPNAME ) ; exit ( EXIT_FAILURE ) ; } # endif # ifdef OS_INIT OS_INIT # endif running_in_test_harness = * running_status == '<' && Ustrcmp ( running_status , ""<<<testing>>>"" ) == 0 ; setlocale ( LC_ALL , ""C"" ) ; os_non_restarting_signal ( SIGALRM , sigalrm_handler ) ; if ( ! ( log_buffer = US malloc ( LOG_BUFFER_SIZE ) ) ) { fprintf ( stderr , ""exim:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>store<S2SV_blank>for<S2SV_blank>log<S2SV_blank>buffer\\n"" ) ; exit ( EXIT_FAILURE ) ; } bits_set ( log_selector , log_selector_size , log_default ) ; if ( fstat ( fileno ( stderr ) , & statbuf ) >= 0 ) log_stderr = stderr ; pcre_malloc = function_store_get ; pcre_free = function_dummy_free ; big_buffer = store_malloc ( big_buffer_size ) ; set_process_info ( ""initializing"" ) ; os_restarting_signal ( SIGUSR1 , usr1_handler ) ; signal ( SIGHUP , SIG_IGN ) ; signal ( SIGPIPE , SIG_IGN ) ; # ifdef SA_NOCLDWAIT { struct sigaction act ; act . sa_handler = SIG_DFL ; sigemptyset ( & ( act . sa_mask ) ) ; act . sa_flags = 0 ; sigaction ( SIGCHLD , & act , NULL ) ; } # else signal ( SIGCHLD , SIG_DFL ) ; # endif sighup_argv = argv ; version_init ( ) ; message_id_option [ 0 ] = '-' ; message_id_external = message_id_option + 1 ; message_id_external [ 0 ] = 'E' ; message_id = message_id_external + 1 ; message_id [ 0 ] = 0 ; ( void ) umask ( 0 ) ; regex_ismsgid = regex_must_compile ( US ""^(?:[^\\\\W_]{6}-){2}[^\\\\W_]{2}$"" , FALSE , TRUE ) ; regex_smtp_code = regex_must_compile ( US ""^\\\\d\\\\d\\\\d\\\\s(?:\\\\d\\\\.\\\\d\\\\d?\\\\d?\\\\.\\\\d\\\\d?\\\\d?\\\\s)?"" , FALSE , TRUE ) ; # ifdef WHITELIST_D_MACROS regex_whitelisted_macro = regex_must_compile ( US ""^[A-Za-z0-9_/.-]*$"" , FALSE , TRUE ) ; # endif for ( i = 0 ; i < REGEX_VARS ; i ++ ) regex_vars [ i ] = NULL ; if ( ( namelen == 5 && Ustrcmp ( argv [ 0 ] , ""mailq"" ) == 0 ) || ( namelen > 5 && Ustrncmp ( argv [ 0 ] + namelen - 6 , ""/mailq"" , 6 ) == 0 ) ) { list_queue = TRUE ; receiving_message = FALSE ; called_as = US ""-mailq"" ; } if ( ( namelen == 5 && Ustrcmp ( argv [ 0 ] , ""rmail"" ) == 0 ) || ( namelen > 5 && Ustrncmp ( argv [ 0 ] + namelen - 6 , ""/rmail"" , 6 ) == 0 ) ) { dot_ends = FALSE ; called_as = US ""-rmail"" ; errors_sender_rc = EXIT_SUCCESS ; } if ( ( namelen == 5 && Ustrcmp ( argv [ 0 ] , ""rsmtp"" ) == 0 ) || ( namelen > 5 && Ustrncmp ( argv [ 0 ] + namelen - 6 , ""/rsmtp"" , 6 ) == 0 ) ) { smtp_input = smtp_batched_input = TRUE ; called_as = US ""-rsmtp"" ; } if ( ( namelen == 4 && Ustrcmp ( argv [ 0 ] , ""runq"" ) == 0 ) || ( namelen > 4 && Ustrncmp ( argv [ 0 ] + namelen - 5 , ""/runq"" , 5 ) == 0 ) ) { queue_interval = 0 ; receiving_message = FALSE ; called_as = US ""-runq"" ; } if ( ( namelen == 10 && Ustrcmp ( argv [ 0 ] , ""newaliases"" ) == 0 ) || ( namelen > 10 && Ustrncmp ( argv [ 0 ] + namelen - 11 , ""/newaliases"" , 11 ) == 0 ) ) { bi_option = TRUE ; receiving_message = FALSE ; called_as = US ""-newaliases"" ; } original_euid = geteuid ( ) ; real_uid = getuid ( ) ; real_gid = getgid ( ) ; if ( real_uid == root_uid ) { rv = setgid ( real_gid ) ; if ( rv ) { fprintf ( stderr , ""exim:<S2SV_blank>setgid(%ld)<S2SV_blank>failed:<S2SV_blank>%s\\n"" , ( long int ) real_gid , strerror ( errno ) ) ; exit ( EXIT_FAILURE ) ; } rv = setuid ( real_uid ) ; if ( rv ) { fprintf ( stderr , ""exim:<S2SV_blank>setuid(%ld)<S2SV_blank>failed:<S2SV_blank>%s\\n"" , ( long int ) real_uid , strerror ( errno ) ) ; exit ( EXIT_FAILURE ) ; } } unprivileged = ( real_uid != root_uid && original_euid != root_uid ) ; for ( i = 1 ; i < argc ; i ++ ) { BOOL badarg = FALSE ; uschar * arg = argv [ i ] ; uschar * argrest ; int switchchar ; if ( arg [ 0 ] != '-' ) { recipients_arg = i ; break ; } if ( Ustrcmp ( arg , ""--"" ) == 0 ) { recipients_arg = i + 1 ; break ; } switchchar = arg [ 1 ] ; argrest = arg + 2 ; if ( Ustrncmp ( arg + 1 , ""oe"" , 2 ) == 0 || Ustrncmp ( arg + 1 , ""qR"" , 2 ) == 0 || Ustrncmp ( arg + 1 , ""qS"" , 2 ) == 0 ) { switchchar = arg [ 2 ] ; argrest ++ ; } else if ( Ustrncmp ( arg + 1 , ""qqR"" , 3 ) == 0 || Ustrncmp ( arg + 1 , ""qqS"" , 3 ) == 0 ) { switchchar = arg [ 3 ] ; argrest += 2 ; queue_2stage = TRUE ; } else if ( arg [ 1 ] == 'r' ) switchchar = 'f' ; else if ( Ustrcmp ( arg , ""-ov"" ) == 0 ) { switchchar = 'v' ; argrest ++ ; } else if ( switchchar == '-' ) { if ( Ustrcmp ( argrest , ""help"" ) == 0 ) { usage_wanted = TRUE ; break ; } else if ( Ustrcmp ( argrest , ""version"" ) == 0 ) { switchchar = 'b' ; argrest = US ""V"" ; } } switch ( switchchar ) { case 'A' : if ( * argrest == '\\0' ) { badarg = TRUE ; break ; } else { BOOL ignore = FALSE ; switch ( * argrest ) { case 'c' : case 'm' : if ( * ( argrest + 1 ) == '\\0' ) ignore = TRUE ; break ; } if ( ! ignore ) { badarg = TRUE ; break ; } } break ; case 'B' : if ( * argrest == 0 ) i ++ ; break ; case 'b' : receiving_message = FALSE ; if ( * argrest == 'd' ) { daemon_listen = TRUE ; if ( * ( ++ argrest ) == 'f' ) background_daemon = FALSE ; else if ( * argrest != 0 ) { badarg = TRUE ; break ; } } else if ( * argrest == 'e' ) { expansion_test = checking = TRUE ; if ( argrest [ 1 ] == 'm' ) { if ( ++ i >= argc ) { badarg = TRUE ; break ; } expansion_test_message = argv [ i ] ; argrest ++ ; } if ( argrest [ 1 ] != 0 ) { badarg = TRUE ; break ; } } else if ( * argrest == 'F' ) { filter_test |= checking = FTEST_SYSTEM ; if ( * ( ++ argrest ) != 0 ) { badarg = TRUE ; break ; } if ( ++ i < argc ) filter_test_sfile = argv [ i ] ; else { fprintf ( stderr , ""exim:<S2SV_blank>file<S2SV_blank>name<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>%s\\n"" , argv [ i - 1 ] ) ; exit ( EXIT_FAILURE ) ; } } else if ( * argrest == 'f' ) { if ( * ( ++ argrest ) == 0 ) { filter_test |= checking = FTEST_USER ; if ( ++ i < argc ) filter_test_ufile = argv [ i ] ; else { fprintf ( stderr , ""exim:<S2SV_blank>file<S2SV_blank>name<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>%s\\n"" , argv [ i - 1 ] ) ; exit ( EXIT_FAILURE ) ; } } else { if ( ++ i >= argc ) { fprintf ( stderr , ""exim:<S2SV_blank>string<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>%s\\n"" , arg ) ; exit ( EXIT_FAILURE ) ; } if ( Ustrcmp ( argrest , ""d"" ) == 0 ) ftest_domain = argv [ i ] ; else if ( Ustrcmp ( argrest , ""l"" ) == 0 ) ftest_localpart = argv [ i ] ; else if ( Ustrcmp ( argrest , ""p"" ) == 0 ) ftest_prefix = argv [ i ] ; else if ( Ustrcmp ( argrest , ""s"" ) == 0 ) ftest_suffix = argv [ i ] ; else { badarg = TRUE ; break ; } } } else if ( Ustrcmp ( argrest , ""h"" ) == 0 || Ustrcmp ( argrest , ""hc"" ) == 0 ) { if ( ++ i >= argc ) { badarg = TRUE ; break ; } sender_host_address = argv [ i ] ; host_checking = checking = log_testing_mode = TRUE ; host_checking_callout = argrest [ 1 ] == 'c' ; message_logs = FALSE ; } else if ( Ustrcmp ( argrest , ""i"" ) == 0 ) bi_option = TRUE ; else if ( argrest [ 0 ] == 'I' && Ustrlen ( argrest ) >= 2 && argrest [ 1 ] == ':' ) { uschar * p = & argrest [ 2 ] ; info_flag = CMDINFO_HELP ; if ( Ustrlen ( p ) ) { if ( strcmpic ( p , CUS ""sieve"" ) == 0 ) { info_flag = CMDINFO_SIEVE ; info_stdout = TRUE ; } else if ( strcmpic ( p , CUS ""dscp"" ) == 0 ) { info_flag = CMDINFO_DSCP ; info_stdout = TRUE ; } else if ( strcmpic ( p , CUS ""help"" ) == 0 ) { info_stdout = TRUE ; } } } else if ( Ustrcmp ( argrest , ""m"" ) == 0 ) receiving_message = TRUE ; else if ( Ustrcmp ( argrest , ""malware"" ) == 0 ) { if ( ++ i >= argc ) { badarg = TRUE ; break ; } checking = TRUE ; malware_test_file = argv [ i ] ; } else if ( Ustrcmp ( argrest , ""nq"" ) == 0 ) { allow_unqualified_sender = FALSE ; allow_unqualified_recipient = FALSE ; } else if ( * argrest == 'p' ) { if ( * ( ++ argrest ) == 'c' ) { count_queue = TRUE ; if ( * ( ++ argrest ) != 0 ) badarg = TRUE ; break ; } if ( * argrest == 'r' ) { list_queue_option = 8 ; argrest ++ ; } else list_queue_option = 0 ; list_queue = TRUE ; if ( * argrest == 0 ) { } else if ( Ustrcmp ( argrest , ""u"" ) == 0 ) list_queue_option += 1 ; else if ( Ustrcmp ( argrest , ""a"" ) == 0 ) list_queue_option += 2 ; else { badarg = TRUE ; break ; } } else if ( Ustrcmp ( argrest , ""P"" ) == 0 ) { if ( argv [ i + 1 ] && Ustrcmp ( argv [ i + 1 ] , ""config"" ) == 0 ) { list_config = TRUE ; readconf_save_config ( version_string ) ; } else { list_options = TRUE ; debug_selector |= D_v ; debug_file = stderr ; } } else if ( Ustrcmp ( argrest , ""rt"" ) == 0 ) { checking = TRUE ; test_retry_arg = i + 1 ; goto END_ARG ; } else if ( Ustrcmp ( argrest , ""rw"" ) == 0 ) { checking = TRUE ; test_rewrite_arg = i + 1 ; goto END_ARG ; } else if ( Ustrcmp ( argrest , ""S"" ) == 0 ) smtp_input = smtp_batched_input = receiving_message = TRUE ; else if ( Ustrcmp ( argrest , ""s"" ) == 0 ) smtp_input = receiving_message = TRUE ; else if ( Ustrcmp ( argrest , ""t"" ) == 0 ) address_test_mode = checking = log_testing_mode = TRUE ; else if ( Ustrcmp ( argrest , ""v"" ) == 0 ) verify_address_mode = checking = log_testing_mode = TRUE ; else if ( Ustrcmp ( argrest , ""vs"" ) == 0 ) { verify_address_mode = checking = log_testing_mode = TRUE ; verify_as_sender = TRUE ; } else if ( Ustrcmp ( argrest , ""V"" ) == 0 ) { printf ( ""Exim<S2SV_blank>version<S2SV_blank>%s<S2SV_blank>#%s<S2SV_blank>built<S2SV_blank>%s\\n"" , version_string , version_cnumber , version_date ) ; printf ( ""%s\\n"" , CS version_copyright ) ; version_printed = TRUE ; show_whats_supported ( stdout ) ; log_testing_mode = TRUE ; } else if ( * argrest == 'w' ) { inetd_wait_mode = TRUE ; background_daemon = FALSE ; daemon_listen = TRUE ; if ( * ( ++ argrest ) != '\\0' ) { inetd_wait_timeout = readconf_readtime ( argrest , 0 , FALSE ) ; if ( inetd_wait_timeout <= 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>bad<S2SV_blank>time<S2SV_blank>value<S2SV_blank>%s:<S2SV_blank>abandoned\\n"" , argv [ i ] ) ; exit ( EXIT_FAILURE ) ; } } } else badarg = TRUE ; break ; case 'C' : if ( * argrest == 0 ) { if ( ++ i < argc ) argrest = argv [ i ] ; else { badarg = TRUE ; break ; } } if ( Ustrcmp ( config_main_filelist , argrest ) != 0 ) { # ifdef ALT_CONFIG_PREFIX int sep = 0 ; int len = Ustrlen ( ALT_CONFIG_PREFIX ) ; const uschar * list = argrest ; uschar * filename ; while ( ( filename = string_nextinlist ( & list , & sep , big_buffer , big_buffer_size ) ) != NULL ) { if ( ( Ustrlen ( filename ) < len || Ustrncmp ( filename , ALT_CONFIG_PREFIX , len ) != 0 || Ustrstr ( filename , ""/../"" ) != NULL ) && ( Ustrcmp ( filename , ""/dev/null"" ) != 0 || real_uid != root_uid ) ) { fprintf ( stderr , ""-C<S2SV_blank>Permission<S2SV_blank>denied\\n"" ) ; exit ( EXIT_FAILURE ) ; } } # endif if ( real_uid != root_uid ) { # ifdef TRUSTED_CONFIG_LIST if ( real_uid != exim_uid # ifdef CONFIGURE_OWNER && real_uid != config_uid # endif ) trusted_config = FALSE ; else { FILE * trust_list = Ufopen ( TRUSTED_CONFIG_LIST , ""rb"" ) ; if ( trust_list ) { struct stat statbuf ; if ( fstat ( fileno ( trust_list ) , & statbuf ) != 0 || ( statbuf . st_uid != root_uid # ifdef CONFIGURE_OWNER && statbuf . st_uid != config_uid # endif ) || ( statbuf . st_gid != root_gid # ifdef CONFIGURE_GROUP && statbuf . st_gid != config_gid # endif && ( statbuf . st_mode & 020 ) != 0 ) || ( statbuf . st_mode & 2 ) != 0 ) { trusted_config = FALSE ; fclose ( trust_list ) ; } else { void * reset_point = store_get ( 0 ) ; uschar * trusted_configs [ 32 ] ; int nr_configs = 0 ; int i = 0 ; while ( Ufgets ( big_buffer , big_buffer_size , trust_list ) ) { uschar * start = big_buffer , * nl ; while ( * start && isspace ( * start ) ) start ++ ; if ( * start != '/' ) continue ; nl = Ustrchr ( start , '\\n' ) ; if ( nl ) * nl = 0 ; trusted_configs [ nr_configs ++ ] = string_copy ( start ) ; if ( nr_configs == 32 ) break ; } fclose ( trust_list ) ; if ( nr_configs ) { int sep = 0 ; const uschar * list = argrest ; uschar * filename ; while ( trusted_config && ( filename = string_nextinlist ( & list , & sep , big_buffer , big_buffer_size ) ) != NULL ) { for ( i = 0 ; i < nr_configs ; i ++ ) { if ( Ustrcmp ( filename , trusted_configs [ i ] ) == 0 ) break ; } if ( i == nr_configs ) { trusted_config = FALSE ; break ; } } store_reset ( reset_point ) ; } else { trusted_config = FALSE ; } } } else { trusted_config = FALSE ; } } # else trusted_config = FALSE ; # endif } config_main_filelist = argrest ; config_changed = TRUE ; } break ; case 'D' : # ifdef DISABLE_D_OPTION fprintf ( stderr , ""exim:<S2SV_blank>-D<S2SV_blank>is<S2SV_blank>not<S2SV_blank>available<S2SV_blank>in<S2SV_blank>this<S2SV_blank>Exim<S2SV_blank>binary\\n"" ) ; exit ( EXIT_FAILURE ) ; # else { int ptr = 0 ; macro_item * m ; uschar name [ 24 ] ; uschar * s = argrest ; opt_D_used = TRUE ; while ( isspace ( * s ) ) s ++ ; if ( * s < 'A' || * s > 'Z' ) { fprintf ( stderr , ""exim:<S2SV_blank>macro<S2SV_blank>name<S2SV_blank>set<S2SV_blank>by<S2SV_blank>-D<S2SV_blank>must<S2SV_blank>start<S2SV_blank>with<S2SV_blank>"" ""an<S2SV_blank>upper<S2SV_blank>case<S2SV_blank>letter\\n"" ) ; exit ( EXIT_FAILURE ) ; } while ( isalnum ( * s ) || * s == '_' ) { if ( ptr < sizeof ( name ) - 1 ) name [ ptr ++ ] = * s ; s ++ ; } name [ ptr ] = 0 ; if ( ptr == 0 ) { badarg = TRUE ; break ; } while ( isspace ( * s ) ) s ++ ; if ( * s != 0 ) { if ( * s ++ != '=' ) { badarg = TRUE ; break ; } while ( isspace ( * s ) ) s ++ ; } for ( m = macros ; m ; m = m -> next ) if ( Ustrcmp ( m -> name , name ) == 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>duplicated<S2SV_blank>-D<S2SV_blank>in<S2SV_blank>command<S2SV_blank>line\\n"" ) ; exit ( EXIT_FAILURE ) ; } m = macro_create ( name , s , TRUE , FALSE ) ; if ( clmacro_count >= MAX_CLMACROS ) { fprintf ( stderr , ""exim:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>-D<S2SV_blank>options<S2SV_blank>on<S2SV_blank>command<S2SV_blank>line\\n"" ) ; exit ( EXIT_FAILURE ) ; } clmacros [ clmacro_count ++ ] = string_sprintf ( ""-D%s=%s"" , m -> name , m -> replacement ) ; } # endif break ; case 'd' : if ( Ustrcmp ( argrest , ""ropcr"" ) == 0 ) { } else { unsigned int selector = D_default ; debug_selector = 0 ; debug_file = NULL ; if ( * argrest == 'd' ) { debug_daemon = TRUE ; argrest ++ ; } if ( * argrest != 0 ) decode_bits ( & selector , 1 , debug_notall , argrest , debug_options , debug_options_count , US ""debug"" , 0 ) ; debug_selector = selector ; } break ; case 'E' : local_error_message = TRUE ; if ( mac_ismsgid ( argrest ) ) message_reference = argrest ; break ; case 'e' : if ( Ustrcmp ( argrest , ""e"" ) == 0 ) { arg_error_handling = ERRORS_SENDER ; errors_sender_rc = EXIT_SUCCESS ; } else if ( Ustrcmp ( argrest , ""m"" ) == 0 ) arg_error_handling = ERRORS_SENDER ; else if ( Ustrcmp ( argrest , ""p"" ) == 0 ) arg_error_handling = ERRORS_STDERR ; else if ( Ustrcmp ( argrest , ""q"" ) == 0 ) arg_error_handling = ERRORS_STDERR ; else if ( Ustrcmp ( argrest , ""w"" ) == 0 ) arg_error_handling = ERRORS_SENDER ; else badarg = TRUE ; break ; case 'F' : if ( * argrest == 0 ) { if ( ++ i < argc ) argrest = argv [ i ] ; else { badarg = TRUE ; break ; } } originator_name = argrest ; sender_name_forced = TRUE ; break ; case 'f' : { int dummy_start , dummy_end ; uschar * errmess ; if ( * argrest == 0 ) { if ( i + 1 < argc ) argrest = argv [ ++ i ] ; else { badarg = TRUE ; break ; } } if ( * argrest == 0 ) sender_address = string_sprintf ( """" ) ; else { uschar * temp = argrest + Ustrlen ( argrest ) - 1 ; while ( temp >= argrest && isspace ( * temp ) ) temp -- ; if ( temp >= argrest && * temp == '.' ) f_end_dot = TRUE ; allow_domain_literals = TRUE ; strip_trailing_dot = TRUE ; # ifdef SUPPORT_I18N allow_utf8_domains = TRUE ; # endif sender_address = parse_extract_address ( argrest , & errmess , & dummy_start , & dummy_end , & sender_address_domain , TRUE ) ; # ifdef SUPPORT_I18N message_smtputf8 = string_is_utf8 ( sender_address ) ; allow_utf8_domains = FALSE ; # endif allow_domain_literals = FALSE ; strip_trailing_dot = FALSE ; if ( sender_address == NULL ) { fprintf ( stderr , ""exim:<S2SV_blank>bad<S2SV_blank>-f<S2SV_blank>address<S2SV_blank>\\""%s\\"":<S2SV_blank>%s\\n"" , argrest , errmess ) ; return EXIT_FAILURE ; } } sender_address_forced = TRUE ; } break ; case 'G' : flag_G = TRUE ; break ; case 'h' : if ( * argrest == 0 ) { if ( ++ i < argc ) argrest = argv [ i ] ; else { badarg = TRUE ; break ; } } if ( ! isdigit ( * argrest ) ) badarg = TRUE ; break ; case 'i' : if ( * argrest == 0 ) dot_ends = FALSE ; else badarg = TRUE ; break ; case 'L' : if ( * argrest == '\\0' ) { if ( ++ i < argc ) argrest = argv [ i ] ; else { badarg = TRUE ; break ; } } sz = Ustrlen ( argrest ) ; if ( sz > 32 ) { fprintf ( stderr , ""exim:<S2SV_blank>the<S2SV_blank>-L<S2SV_blank>syslog<S2SV_blank>name<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long:<S2SV_blank>\\""%s\\""\\n"" , argrest ) ; return EXIT_FAILURE ; } if ( sz < 1 ) { fprintf ( stderr , ""exim:<S2SV_blank>the<S2SV_blank>-L<S2SV_blank>syslog<S2SV_blank>name<S2SV_blank>is<S2SV_blank>too<S2SV_blank>short\\n"" ) ; return EXIT_FAILURE ; } cmdline_syslog_name = argrest ; break ; case 'M' : receiving_message = FALSE ; if ( Ustrcmp ( argrest , ""C"" ) == 0 ) { union sockaddr_46 interface_sock ; EXIM_SOCKLEN_T size = sizeof ( interface_sock ) ; if ( argc != i + 6 ) { fprintf ( stderr , ""exim:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>or<S2SV_blank>too<S2SV_blank>few<S2SV_blank>arguments<S2SV_blank>after<S2SV_blank>-MC\\n"" ) ; return EXIT_FAILURE ; } if ( msg_action_arg >= 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>incompatible<S2SV_blank>arguments\\n"" ) ; return EXIT_FAILURE ; } continue_transport = argv [ ++ i ] ; continue_hostname = argv [ ++ i ] ; continue_host_address = argv [ ++ i ] ; continue_sequence = Uatoi ( argv [ ++ i ] ) ; msg_action = MSG_DELIVER ; msg_action_arg = ++ i ; forced_delivery = TRUE ; queue_run_pid = passed_qr_pid ; queue_run_pipe = passed_qr_pipe ; if ( ! mac_ismsgid ( argv [ i ] ) ) { fprintf ( stderr , ""exim:<S2SV_blank>malformed<S2SV_blank>message<S2SV_blank>id<S2SV_blank>%s<S2SV_blank>after<S2SV_blank>-MC<S2SV_blank>option\\n"" , argv [ i ] ) ; return EXIT_FAILURE ; } if ( ! continue_proxy_cipher ) if ( getsockname ( fileno ( stdin ) , ( struct sockaddr * ) ( & interface_sock ) , & size ) == 0 ) sending_ip_address = host_ntoa ( - 1 , & interface_sock , NULL , & sending_port ) ; else { fprintf ( stderr , ""exim:<S2SV_blank>getsockname()<S2SV_blank>failed<S2SV_blank>after<S2SV_blank>-MC<S2SV_blank>option:<S2SV_blank>%s\\n"" , strerror ( errno ) ) ; return EXIT_FAILURE ; } if ( running_in_test_harness ) millisleep ( 500 ) ; break ; } else if ( * argrest == 'C' && argrest [ 1 ] && ! argrest [ 2 ] ) { switch ( argrest [ 1 ] ) { case 'A' : smtp_authenticated = TRUE ; break ; case 'D' : smtp_peer_options |= PEER_OFFERED_DSN ; break ; case 'G' : if ( ++ i < argc ) queue_name = string_copy ( argv [ i ] ) ; else badarg = TRUE ; break ; case 'K' : smtp_peer_options |= PEER_OFFERED_CHUNKING ; break ; case 'P' : smtp_peer_options |= PEER_OFFERED_PIPE ; break ; case 'Q' : if ( ++ i < argc ) passed_qr_pid = ( pid_t ) ( Uatol ( argv [ i ] ) ) ; else badarg = TRUE ; if ( ++ i < argc ) passed_qr_pipe = ( int ) ( Uatol ( argv [ i ] ) ) ; else badarg = TRUE ; break ; case 'S' : smtp_peer_options |= PEER_OFFERED_SIZE ; break ; # ifdef SUPPORT_TLS case 't' : if ( ++ i < argc ) sending_ip_address = argv [ i ] ; else badarg = TRUE ; if ( ++ i < argc ) sending_port = ( int ) ( Uatol ( argv [ i ] ) ) ; else badarg = TRUE ; if ( ++ i < argc ) continue_proxy_cipher = argv [ i ] ; else badarg = TRUE ; case 'T' : smtp_peer_options |= PEER_OFFERED_TLS ; break ; # endif default : badarg = TRUE ; break ; } break ; } else if ( * argrest == 0 ) { msg_action = MSG_DELIVER ; forced_delivery = deliver_force_thaw = TRUE ; } else if ( Ustrcmp ( argrest , ""ar"" ) == 0 ) { msg_action = MSG_ADD_RECIPIENT ; one_msg_action = TRUE ; } else if ( Ustrcmp ( argrest , ""c"" ) == 0 ) msg_action = MSG_DELIVER ; else if ( Ustrcmp ( argrest , ""es"" ) == 0 ) { msg_action = MSG_EDIT_SENDER ; one_msg_action = TRUE ; } else if ( Ustrcmp ( argrest , ""f"" ) == 0 ) msg_action = MSG_FREEZE ; else if ( Ustrcmp ( argrest , ""g"" ) == 0 ) { msg_action = MSG_DELIVER ; deliver_give_up = TRUE ; } else if ( Ustrcmp ( argrest , ""mad"" ) == 0 ) { msg_action = MSG_MARK_ALL_DELIVERED ; } else if ( Ustrcmp ( argrest , ""md"" ) == 0 ) { msg_action = MSG_MARK_DELIVERED ; one_msg_action = TRUE ; } else if ( Ustrcmp ( argrest , ""rm"" ) == 0 ) msg_action = MSG_REMOVE ; else if ( Ustrcmp ( argrest , ""set"" ) == 0 ) { msg_action = MSG_LOAD ; one_msg_action = TRUE ; } else if ( Ustrcmp ( argrest , ""t"" ) == 0 ) msg_action = MSG_THAW ; else if ( Ustrcmp ( argrest , ""vb"" ) == 0 ) { msg_action = MSG_SHOW_BODY ; one_msg_action = TRUE ; } else if ( Ustrcmp ( argrest , ""vc"" ) == 0 ) { msg_action = MSG_SHOW_COPY ; one_msg_action = TRUE ; } else if ( Ustrcmp ( argrest , ""vh"" ) == 0 ) { msg_action = MSG_SHOW_HEADER ; one_msg_action = TRUE ; } else if ( Ustrcmp ( argrest , ""vl"" ) == 0 ) { msg_action = MSG_SHOW_LOG ; one_msg_action = TRUE ; } else { badarg = TRUE ; break ; } msg_action_arg = i + 1 ; if ( msg_action_arg >= argc ) { fprintf ( stderr , ""exim:<S2SV_blank>no<S2SV_blank>message<S2SV_blank>ids<S2SV_blank>given<S2SV_blank>after<S2SV_blank>%s<S2SV_blank>option\\n"" , arg ) ; return EXIT_FAILURE ; } if ( ! one_msg_action ) { int j ; for ( j = msg_action_arg ; j < argc ; j ++ ) if ( ! mac_ismsgid ( argv [ j ] ) ) { fprintf ( stderr , ""exim:<S2SV_blank>malformed<S2SV_blank>message<S2SV_blank>id<S2SV_blank>%s<S2SV_blank>after<S2SV_blank>%s<S2SV_blank>option\\n"" , argv [ j ] , arg ) ; return EXIT_FAILURE ; } goto END_ARG ; } else { if ( ! mac_ismsgid ( argv [ msg_action_arg ] ) ) { fprintf ( stderr , ""exim:<S2SV_blank>malformed<S2SV_blank>message<S2SV_blank>id<S2SV_blank>%s<S2SV_blank>after<S2SV_blank>%s<S2SV_blank>option\\n"" , argv [ msg_action_arg ] , arg ) ; return EXIT_FAILURE ; } i ++ ; } break ; case 'm' : if ( * argrest != 0 ) badarg = TRUE ; break ; case 'N' : if ( * argrest == 0 ) { dont_deliver = TRUE ; debug_selector |= D_v ; debug_file = stderr ; } else badarg = TRUE ; break ; case 'n' : flag_n = TRUE ; break ; case 'O' : if ( * argrest == 0 ) { if ( ++ i >= argc ) { fprintf ( stderr , ""exim:<S2SV_blank>string<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>-O\\n"" ) ; exit ( EXIT_FAILURE ) ; } } break ; case 'o' : if ( * argrest == 'A' ) { alias_arg = argrest + 1 ; if ( alias_arg [ 0 ] == 0 ) { if ( i + 1 < argc ) alias_arg = argv [ ++ i ] ; else { fprintf ( stderr , ""exim:<S2SV_blank>string<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>-oA\\n"" ) ; exit ( EXIT_FAILURE ) ; } } } else if ( * argrest == 'B' ) { uschar * p = argrest + 1 ; if ( p [ 0 ] == 0 ) { if ( i + 1 < argc && isdigit ( ( argv [ i + 1 ] [ 0 ] ) ) ) p = argv [ ++ i ] ; else { connection_max_messages = 1 ; p = NULL ; } } if ( p != NULL ) { if ( ! isdigit ( * p ) ) { fprintf ( stderr , ""exim:<S2SV_blank>number<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>-oB\\n"" ) ; exit ( EXIT_FAILURE ) ; } connection_max_messages = Uatoi ( p ) ; } } else if ( Ustrcmp ( argrest , ""db"" ) == 0 ) { synchronous_delivery = FALSE ; arg_queue_only = FALSE ; queue_only_set = TRUE ; } else if ( Ustrcmp ( argrest , ""df"" ) == 0 || Ustrcmp ( argrest , ""di"" ) == 0 ) { synchronous_delivery = TRUE ; arg_queue_only = FALSE ; queue_only_set = TRUE ; } else if ( Ustrcmp ( argrest , ""dq"" ) == 0 ) { synchronous_delivery = FALSE ; arg_queue_only = TRUE ; queue_only_set = TRUE ; } else if ( Ustrcmp ( argrest , ""dqs"" ) == 0 ) { queue_smtp = TRUE ; arg_queue_only = FALSE ; queue_only_set = TRUE ; } else if ( Ustrcmp ( argrest , ""i"" ) == 0 || Ustrcmp ( argrest , ""itrue"" ) == 0 ) dot_ends = FALSE ; else if ( * argrest == 'M' ) { if ( i + 1 >= argc ) { fprintf ( stderr , ""exim:<S2SV_blank>data<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>-o%s\\n"" , argrest ) ; exit ( EXIT_FAILURE ) ; } if ( Ustrcmp ( argrest , ""Ma"" ) == 0 ) sender_host_address = argv [ ++ i ] ; else if ( Ustrcmp ( argrest , ""Maa"" ) == 0 ) sender_host_authenticated = argv [ ++ i ] ; else if ( Ustrcmp ( argrest , ""Mas"" ) == 0 ) authenticated_sender = argv [ ++ i ] ; else if ( Ustrcmp ( argrest , ""Mai"" ) == 0 ) authenticated_id = argv [ ++ i ] ; else if ( Ustrcmp ( argrest , ""Mi"" ) == 0 ) interface_address = argv [ ++ i ] ; else if ( Ustrcmp ( argrest , ""Mm"" ) == 0 ) { if ( ! mac_ismsgid ( argv [ i + 1 ] ) ) { fprintf ( stderr , ""-oMm<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>message<S2SV_blank>ID\\n"" ) ; exit ( EXIT_FAILURE ) ; } if ( ! trusted_config ) { fprintf ( stderr , ""-oMm<S2SV_blank>must<S2SV_blank>be<S2SV_blank>called<S2SV_blank>by<S2SV_blank>a<S2SV_blank>trusted<S2SV_blank>user/config\\n"" ) ; exit ( EXIT_FAILURE ) ; } message_reference = argv [ ++ i ] ; }  else if ( Ustrcmp ( argrest , ""Mr"" ) == 0 ) received_protocol = argv [ ++ i ] ;  else if ( Ustrcmp ( argrest , ""Ms"" ) == 0 ) sender_host_name = argv [ ++ i ] ; else if ( Ustrcmp ( argrest , ""Mt"" ) == 0 ) { sender_ident_set = TRUE ; sender_ident = argv [ ++ i ] ; } else { badarg = TRUE ; break ; } } else if ( Ustrcmp ( argrest , ""m"" ) == 0 ) { } else if ( Ustrcmp ( argrest , ""o"" ) == 0 ) { } else if ( Ustrcmp ( argrest , ""P"" ) == 0 ) override_pid_file_path = argv [ ++ i ] ; else if ( * argrest == 'r' || * argrest == 's' ) { int * tp = ( * argrest == 'r' ) ? & arg_receive_timeout : & arg_smtp_receive_timeout ; if ( argrest [ 1 ] == 0 ) { if ( i + 1 < argc ) * tp = readconf_readtime ( argv [ ++ i ] , 0 , FALSE ) ; } else * tp = readconf_readtime ( argrest + 1 , 0 , FALSE ) ; if ( * tp < 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>bad<S2SV_blank>time<S2SV_blank>value<S2SV_blank>%s:<S2SV_blank>abandoned\\n"" , argv [ i ] ) ; exit ( EXIT_FAILURE ) ; } } else if ( Ustrcmp ( argrest , ""X"" ) == 0 ) override_local_interfaces = argv [ ++ i ] ; else badarg = TRUE ; break ; case 'p' : # ifdef EXIM_PERL if ( * argrest == 's' && argrest [ 1 ] == 0 ) { perl_start_option = 1 ; break ; } if ( * argrest == 'd' && argrest [ 1 ] == 0 ) { perl_start_option = - 1 ; break ; } # endif if ( * argrest == 0 ) { if ( i + 1 < argc ) argrest = argv [ ++ i ] ; else { badarg = TRUE ; break ; } } if ( * argrest != 0 ) {  uschar * hn = Ustrchr ( argrest , ':' ) ;  if ( hn == NULL ) { received_protocol = argrest ; } else { int old_pool = store_pool ; store_pool = POOL_PERM ; received_protocol = string_copyn ( argrest , hn - argrest ) ; store_pool = old_pool ; sender_host_name = hn + 1 ; } } break ; case 'q' : receiving_message = FALSE ; if ( queue_interval >= 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>-q<S2SV_blank>specified<S2SV_blank>more<S2SV_blank>than<S2SV_blank>once\\n"" ) ; exit ( EXIT_FAILURE ) ; } if ( * argrest == 'q' ) { queue_2stage = TRUE ; argrest ++ ; } if ( * argrest == 'i' ) { queue_run_first_delivery = TRUE ; argrest ++ ; } if ( * argrest == 'f' ) { queue_run_force = TRUE ; if ( * ++ argrest == 'f' ) { deliver_force_thaw = TRUE ; argrest ++ ; } } if ( * argrest == 'l' ) { queue_run_local = TRUE ; argrest ++ ; } if ( * argrest == 'G' ) { int i ; for ( argrest ++ , i = 0 ; argrest [ i ] && argrest [ i ] != '/' ; ) i ++ ; queue_name = string_copyn ( argrest , i ) ; argrest += i ; if ( * argrest == '/' ) argrest ++ ; } if ( * argrest == 0 && ( i + 1 >= argc || argv [ i + 1 ] [ 0 ] == '-' || mac_ismsgid ( argv [ i + 1 ] ) ) ) { queue_interval = 0 ; if ( i + 1 < argc && mac_ismsgid ( argv [ i + 1 ] ) ) start_queue_run_id = argv [ ++ i ] ; if ( i + 1 < argc && mac_ismsgid ( argv [ i + 1 ] ) ) stop_queue_run_id = argv [ ++ i ] ; } else if ( ( queue_interval = readconf_readtime ( * argrest ? argrest : argv [ ++ i ] , 0 , FALSE ) ) <= 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>bad<S2SV_blank>time<S2SV_blank>value<S2SV_blank>%s:<S2SV_blank>abandoned\\n"" , argv [ i ] ) ; exit ( EXIT_FAILURE ) ; } break ; case 'R' : receiving_message = FALSE ; if ( * argrest != 0 ) { int i ; for ( i = 0 ; i < nelem ( rsopts ) ; i ++ ) if ( Ustrcmp ( argrest , rsopts [ i ] ) == 0 ) { if ( i != 2 ) queue_run_force = TRUE ; if ( i >= 2 ) deliver_selectstring_regex = TRUE ; if ( i == 1 || i == 4 ) deliver_force_thaw = TRUE ; argrest += Ustrlen ( rsopts [ i ] ) ; } } if ( * argrest ) deliver_selectstring = argrest ; else if ( i + 1 < argc ) deliver_selectstring = argv [ ++ i ] ; else { fprintf ( stderr , ""exim:<S2SV_blank>string<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>-R\\n"" ) ; exit ( EXIT_FAILURE ) ; } break ; case 'S' : receiving_message = FALSE ; if ( * argrest ) { int i ; for ( i = 0 ; i < nelem ( rsopts ) ; i ++ ) if ( Ustrcmp ( argrest , rsopts [ i ] ) == 0 ) { if ( i != 2 ) queue_run_force = TRUE ; if ( i >= 2 ) deliver_selectstring_sender_regex = TRUE ; if ( i == 1 || i == 4 ) deliver_force_thaw = TRUE ; argrest += Ustrlen ( rsopts [ i ] ) ; } } if ( * argrest ) deliver_selectstring_sender = argrest ; else if ( i + 1 < argc ) deliver_selectstring_sender = argv [ ++ i ] ; else { fprintf ( stderr , ""exim:<S2SV_blank>string<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>-S\\n"" ) ; exit ( EXIT_FAILURE ) ; } break ; case 'T' : if ( running_in_test_harness && Ustrcmp ( argrest , ""qt"" ) == 0 ) fudged_queue_times = argv [ ++ i ] ; else badarg = TRUE ; break ; case 't' : if ( * argrest == 0 ) extract_recipients = TRUE ; else if ( Ustrcmp ( argrest , ""i"" ) == 0 ) { extract_recipients = TRUE ; dot_ends = FALSE ; } # ifdef SUPPORT_TLS else if ( Ustrcmp ( argrest , ""ls-on-connect"" ) == 0 ) tls_in . on_connect = TRUE ; # endif else badarg = TRUE ; break ; case 'U' : break ; case 'v' : if ( * argrest == 0 ) { debug_selector |= D_v ; debug_file = stderr ; } else badarg = TRUE ; break ; case 'x' : if ( * argrest != 0 ) badarg = TRUE ; break ; case 'X' : if ( * argrest == '\\0' ) if ( ++ i >= argc ) { fprintf ( stderr , ""exim:<S2SV_blank>string<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>-X\\n"" ) ; exit ( EXIT_FAILURE ) ; } break ; case 'z' : if ( * argrest == '\\0' ) if ( ++ i < argc ) log_oneline = argv [ i ] ; else { fprintf ( stderr , ""exim:<S2SV_blank>file<S2SV_blank>name<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>%s\\n"" , argv [ i - 1 ] ) ; exit ( EXIT_FAILURE ) ; } break ; default : badarg = TRUE ; break ; } if ( badarg ) { fprintf ( stderr , ""exim<S2SV_blank>abandoned:<S2SV_blank>unknown,<S2SV_blank>malformed,<S2SV_blank>or<S2SV_blank>incomplete<S2SV_blank>"" ""option<S2SV_blank>%s\\n"" , arg ) ; exit ( EXIT_FAILURE ) ; } } if ( ( deliver_selectstring || deliver_selectstring_sender ) && queue_interval < 0 ) queue_interval = 0 ; END_ARG : if ( usage_wanted ) exim_usage ( called_as ) ; if ( ( ( smtp_input || extract_recipients || recipients_arg < argc ) && ( daemon_listen || queue_interval >= 0 || bi_option || test_retry_arg >= 0 || test_rewrite_arg >= 0 || filter_test != FTEST_NONE || ( msg_action_arg > 0 && ! one_msg_action ) ) ) || ( msg_action_arg > 0 && ( daemon_listen || queue_interval > 0 || list_options || ( checking && msg_action != MSG_LOAD ) || bi_option || test_retry_arg >= 0 || test_rewrite_arg >= 0 ) ) || ( ( daemon_listen || queue_interval > 0 ) && ( sender_address != NULL || list_options || list_queue || checking || bi_option ) ) || ( daemon_listen && queue_interval == 0 ) || ( inetd_wait_mode && queue_interval >= 0 ) || ( list_options && ( checking || smtp_input || extract_recipients || filter_test != FTEST_NONE || bi_option ) ) || ( verify_address_mode && ( address_test_mode || smtp_input || extract_recipients || filter_test != FTEST_NONE || bi_option ) ) || ( address_test_mode && ( smtp_input || extract_recipients || filter_test != FTEST_NONE || bi_option ) ) || ( smtp_input && ( sender_address != NULL || filter_test != FTEST_NONE || extract_recipients ) ) || ( deliver_selectstring != NULL && queue_interval < 0 ) || ( msg_action == MSG_LOAD && ( ! expansion_test || expansion_test_message != NULL ) ) ) { fprintf ( stderr , ""exim:<S2SV_blank>incompatible<S2SV_blank>command-line<S2SV_blank>options<S2SV_blank>or<S2SV_blank>arguments\\n"" ) ; exit ( EXIT_FAILURE ) ; } if ( debug_selector != 0 ) { debug_file = stderr ; debug_fd = fileno ( debug_file ) ; background_daemon = FALSE ; if ( running_in_test_harness ) millisleep ( 100 ) ; if ( debug_selector != D_v ) { debug_printf ( ""Exim<S2SV_blank>version<S2SV_blank>%s<S2SV_blank>uid=%ld<S2SV_blank>gid=%ld<S2SV_blank>pid=%d<S2SV_blank>D=%x\\n"" , version_string , ( long int ) real_uid , ( long int ) real_gid , ( int ) getpid ( ) , debug_selector ) ; if ( ! version_printed ) show_whats_supported ( stderr ) ; } } if ( unprivileged ) { DEBUG ( D_any ) debug_print_ids ( US ""Exim<S2SV_blank>has<S2SV_blank>no<S2SV_blank>root<S2SV_blank>privilege:"" ) ; } else { struct rlimit rlp ; # ifdef RLIMIT_NOFILE if ( getrlimit ( RLIMIT_NOFILE , & rlp ) < 0 ) { log_write ( 0 , LOG_MAIN | LOG_PANIC , ""getrlimit(RLIMIT_NOFILE)<S2SV_blank>failed:<S2SV_blank>%s"" , strerror ( errno ) ) ; rlp . rlim_cur = rlp . rlim_max = 0 ; } if ( rlp . rlim_cur < 1000 ) { rlp . rlim_cur = rlp . rlim_max = 1000 ; if ( setrlimit ( RLIMIT_NOFILE , & rlp ) < 0 ) { rlp . rlim_cur = rlp . rlim_max = 256 ; if ( setrlimit ( RLIMIT_NOFILE , & rlp ) < 0 ) log_write ( 0 , LOG_MAIN | LOG_PANIC , ""setrlimit(RLIMIT_NOFILE)<S2SV_blank>failed:<S2SV_blank>%s"" , strerror ( errno ) ) ; } } # endif # ifdef RLIMIT_NPROC if ( getrlimit ( RLIMIT_NPROC , & rlp ) < 0 ) { log_write ( 0 , LOG_MAIN | LOG_PANIC , ""getrlimit(RLIMIT_NPROC)<S2SV_blank>failed:<S2SV_blank>%s"" , strerror ( errno ) ) ; rlp . rlim_cur = rlp . rlim_max = 0 ; } # ifdef RLIM_INFINITY if ( rlp . rlim_cur != RLIM_INFINITY && rlp . rlim_cur < 1000 ) { rlp . rlim_cur = rlp . rlim_max = RLIM_INFINITY ; # else if ( rlp . rlim_cur < 1000 ) { rlp . rlim_cur = rlp . rlim_max = 1000 ; # endif if ( setrlimit ( RLIMIT_NPROC , & rlp ) < 0 ) log_write ( 0 , LOG_MAIN | LOG_PANIC , ""setrlimit(RLIMIT_NPROC)<S2SV_blank>failed:<S2SV_blank>%s"" , strerror ( errno ) ) ; } # endif } group_count = getgroups ( NGROUPS_MAX , group_list ) ; if ( group_count < 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>getgroups()<S2SV_blank>failed:<S2SV_blank>%s\\n"" , strerror ( errno ) ) ; exit ( EXIT_FAILURE ) ; } if ( setgroups ( 0 , NULL ) != 0 ) { if ( setgroups ( 1 , group_list ) != 0 && ! unprivileged ) { fprintf ( stderr , ""exim:<S2SV_blank>setgroups()<S2SV_blank>failed:<S2SV_blank>%s\\n"" , strerror ( errno ) ) ; exit ( EXIT_FAILURE ) ; } } if ( ( ( ! trusted_config || ! macros_trusted ( opt_D_used ) ) && real_uid != root_uid && ! running_in_test_harness ) || expansion_test || filter_test != FTEST_NONE ) { setgroups ( group_count , group_list ) ; exim_setugid ( real_uid , real_gid , FALSE , US ""-C,<S2SV_blank>-D,<S2SV_blank>-be<S2SV_blank>or<S2SV_blank>-bf<S2SV_blank>forces<S2SV_blank>real<S2SV_blank>uid"" ) ; removed_privilege = TRUE ; if ( ( log_stderr != NULL ) && ( real_uid != exim_uid ) ) really_exim = FALSE ; } else exim_setugid ( geteuid ( ) , getegid ( ) , FALSE , US ""forcing<S2SV_blank>real<S2SV_blank>=<S2SV_blank>effective"" ) ; if ( ( filter_test & FTEST_SYSTEM ) != 0 ) { filter_sfd = Uopen ( filter_test_sfile , O_RDONLY , 0 ) ; if ( filter_sfd < 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s:<S2SV_blank>%s\\n"" , filter_test_sfile , strerror ( errno ) ) ; return EXIT_FAILURE ; } } if ( ( filter_test & FTEST_USER ) != 0 ) { filter_ufd = Uopen ( filter_test_ufile , O_RDONLY , 0 ) ; if ( filter_ufd < 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s:<S2SV_blank>%s\\n"" , filter_test_ufile , strerror ( errno ) ) ; return EXIT_FAILURE ; } } init_lookup_list ( ) ; # ifdef SUPPORT_I18N if ( running_in_test_harness ) smtputf8_advertise_hosts = NULL ; # endif if ( ( initial_cwd = os_getcwd ( NULL , 0 ) ) == NULL ) { perror ( ""exim:<S2SV_blank>can\'t<S2SV_blank>get<S2SV_blank>the<S2SV_blank>current<S2SV_blank>working<S2SV_blank>directory"" ) ; exit ( EXIT_FAILURE ) ; } readconf_main ( checking || list_options ) ; if ( builtin_macros_create_trigger ) DEBUG ( D_any ) debug_printf ( ""Builtin<S2SV_blank>macros<S2SV_blank>created<S2SV_blank>(expensive)<S2SV_blank>due<S2SV_blank>to<S2SV_blank>config<S2SV_blank>line<S2SV_blank>\'%.*s\'\\n"" , Ustrlen ( builtin_macros_create_trigger ) - 1 , builtin_macros_create_trigger ) ; if ( cleanup_environment ( ) == FALSE ) log_write ( 0 , LOG_PANIC_DIE , ""Can\'t<S2SV_blank>cleanup<S2SV_blank>environment"" ) ; if ( real_uid == root_uid || real_uid == exim_uid || real_gid == exim_gid ) admin_user = TRUE ; else { int i , j ; for ( i = 0 ; i < group_count && ! admin_user ; i ++ ) if ( group_list [ i ] == exim_gid ) admin_user = TRUE ; else if ( admin_groups ) for ( j = 1 ; j <= ( int ) admin_groups [ 0 ] && ! admin_user ; j ++ ) if ( admin_groups [ j ] == group_list [ i ] ) admin_user = TRUE ; } if ( real_uid == root_uid || real_uid == exim_uid ) trusted_caller = TRUE ; else { int i , j ; if ( trusted_users ) for ( i = 1 ; i <= ( int ) trusted_users [ 0 ] && ! trusted_caller ; i ++ ) if ( trusted_users [ i ] == real_uid ) trusted_caller = TRUE ; if ( trusted_groups ) for ( i = 1 ; i <= ( int ) trusted_groups [ 0 ] && ! trusted_caller ; i ++ ) if ( trusted_groups [ i ] == real_gid ) trusted_caller = TRUE ; else for ( j = 0 ; j < group_count && ! trusted_caller ; j ++ ) if ( trusted_groups [ i ] == group_list [ j ] ) trusted_caller = TRUE ; } if ( checking && commandline_checks_require_admin && ! admin_user ) { fprintf ( stderr , ""exim:<S2SV_blank>those<S2SV_blank>command-line<S2SV_blank>flags<S2SV_blank>are<S2SV_blank>set<S2SV_blank>to<S2SV_blank>require<S2SV_blank>admin\\n"" ) ; exit ( EXIT_FAILURE ) ; } decode_bits ( log_selector , log_selector_size , log_notall , log_selector_string , log_options , log_options_count , US ""log"" , 0 ) ; DEBUG ( D_any ) { int i ; debug_printf ( ""configuration<S2SV_blank>file<S2SV_blank>is<S2SV_blank>%s\\n"" , config_main_filename ) ; debug_printf ( ""log<S2SV_blank>selectors<S2SV_blank>="" ) ; for ( i = 0 ; i < log_selector_size ; i ++ ) debug_printf ( ""<S2SV_blank>%08x"" , log_selector [ i ] ) ; debug_printf ( ""\\n"" ) ; } if ( sender_address != NULL ) { if ( sender_address [ sender_address_domain ] == '[' && ! allow_domain_literals ) { fprintf ( stderr , ""exim:<S2SV_blank>bad<S2SV_blank>-f<S2SV_blank>address<S2SV_blank>\\""%s\\"":<S2SV_blank>domain<S2SV_blank>literals<S2SV_blank>not<S2SV_blank>"" ""allowed\\n"" , sender_address ) ; return EXIT_FAILURE ; } if ( f_end_dot && ! strip_trailing_dot ) { fprintf ( stderr , ""exim:<S2SV_blank>bad<S2SV_blank>-f<S2SV_blank>address<S2SV_blank>\\""%s.\\"":<S2SV_blank>domain<S2SV_blank>is<S2SV_blank>malformed<S2SV_blank>"" ""(trailing<S2SV_blank>dot<S2SV_blank>not<S2SV_blank>allowed)\\n"" , sender_address ) ; return EXIT_FAILURE ; } } if ( cmdline_syslog_name != NULL ) { if ( admin_user ) { syslog_processname = cmdline_syslog_name ; log_file_path = string_copy ( CUS ""syslog"" ) ; } else { fprintf ( stderr , ""exim:<S2SV_blank>you<S2SV_blank>lack<S2SV_blank>sufficient<S2SV_blank>privilege<S2SV_blank>to<S2SV_blank>specify<S2SV_blank>syslog<S2SV_blank>process<S2SV_blank>name\\n"" ) ; return EXIT_FAILURE ; } } if ( Ustrlen ( log_file_path ) > 200 ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , ""log_file_path<S2SV_blank>is<S2SV_blank>longer<S2SV_blank>than<S2SV_blank>200<S2SV_blank>chars:<S2SV_blank>aborting"" ) ; if ( Ustrlen ( pid_file_path ) > 200 ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , ""pid_file_path<S2SV_blank>is<S2SV_blank>longer<S2SV_blank>than<S2SV_blank>200<S2SV_blank>chars:<S2SV_blank>aborting"" ) ; if ( Ustrlen ( spool_directory ) > 200 ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , ""spool_directory<S2SV_blank>is<S2SV_blank>longer<S2SV_blank>than<S2SV_blank>200<S2SV_blank>chars:<S2SV_blank>aborting"" ) ; if ( Ustrlen ( syslog_processname ) > 32 ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , ""syslog_processname<S2SV_blank>is<S2SV_blank>longer<S2SV_blank>than<S2SV_blank>32<S2SV_blank>chars:<S2SV_blank>aborting"" ) ; if ( log_oneline ) if ( admin_user ) { log_write ( 0 , LOG_MAIN , ""%s"" , log_oneline ) ; return EXIT_SUCCESS ; } else return EXIT_FAILURE ; # ifdef EXIM_TMPDIR { uschar * * p ; if ( environ ) for ( p = USS environ ; * p ; p ++ ) if ( Ustrncmp ( * p , ""TMPDIR="" , 7 ) == 0 && Ustrcmp ( * p + 7 , EXIM_TMPDIR ) != 0 ) { uschar * newp = store_malloc ( Ustrlen ( EXIM_TMPDIR ) + 8 ) ; sprintf ( CS newp , ""TMPDIR=%s"" , EXIM_TMPDIR ) ; * p = newp ; DEBUG ( D_any ) debug_printf ( ""reset<S2SV_blank>TMPDIR=%s<S2SV_blank>in<S2SV_blank>environment\\n"" , EXIM_TMPDIR ) ; } } # endif if ( timezone_string && strcmpic ( timezone_string , US ""UTC"" ) == 0 ) timestamps_utc = TRUE ; else { uschar * envtz = US getenv ( ""TZ"" ) ; if ( envtz ? ! timezone_string || Ustrcmp ( timezone_string , envtz ) != 0 : timezone_string != NULL ) { uschar * * p = USS environ ; uschar * * new ; uschar * * newp ; int count = 0 ; if ( environ ) while ( * p ++ ) count ++ ; if ( ! envtz ) count ++ ; newp = new = store_malloc ( sizeof ( uschar * ) * ( count + 1 ) ) ; if ( environ ) for ( p = USS environ ; * p ; p ++ ) if ( Ustrncmp ( * p , ""TZ="" , 3 ) != 0 ) * newp ++ = * p ; if ( timezone_string ) { * newp = store_malloc ( Ustrlen ( timezone_string ) + 4 ) ; sprintf ( CS * newp ++ , ""TZ=%s"" , timezone_string ) ; } * newp = NULL ; environ = CSS new ; tzset ( ) ; DEBUG ( D_any ) debug_printf ( ""Reset<S2SV_blank>TZ<S2SV_blank>to<S2SV_blank>%s:<S2SV_blank>time<S2SV_blank>is<S2SV_blank>%s\\n"" , timezone_string , tod_stamp ( tod_log ) ) ; } } if ( removed_privilege && ( ! trusted_config || opt_D_used ) && real_uid == exim_uid ) if ( deliver_drop_privilege ) really_exim = TRUE ; else log_write ( 0 , LOG_MAIN | LOG_PANIC , ""exim<S2SV_blank>user<S2SV_blank>lost<S2SV_blank>privilege<S2SV_blank>for<S2SV_blank>using<S2SV_blank>%s<S2SV_blank>option"" , trusted_config ? ""-D"" : ""-C"" ) ; # ifdef EXIM_PERL if ( perl_start_option != 0 ) opt_perl_at_start = ( perl_start_option > 0 ) ; if ( opt_perl_at_start && opt_perl_startup != NULL ) { uschar * errstr ; DEBUG ( D_any ) debug_printf ( ""Starting<S2SV_blank>Perl<S2SV_blank>interpreter\\n"" ) ; errstr = init_perl ( opt_perl_startup ) ; if ( errstr != NULL ) { fprintf ( stderr , ""exim:<S2SV_blank>error<S2SV_blank>in<S2SV_blank>perl_startup<S2SV_blank>code:<S2SV_blank>%s\\n"" , errstr ) ; return EXIT_FAILURE ; } opt_perl_started = TRUE ; } # endif if ( ( ( debug_selector & D_any ) != 0 || LOGGING ( arguments ) ) && really_exim && ! list_options && ! checking ) { int i ; uschar * p = big_buffer ; Ustrcpy ( p , ""cwd=<S2SV_blank>(failed)"" ) ; Ustrncpy ( p + 4 , initial_cwd , big_buffer_size - 5 ) ; while ( * p ) p ++ ; ( void ) string_format ( p , big_buffer_size - ( p - big_buffer ) , ""<S2SV_blank>%d<S2SV_blank>args:"" , argc ) ; while ( * p ) p ++ ; for ( i = 0 ; i < argc ; i ++ ) { int len = Ustrlen ( argv [ i ] ) ; const uschar * printing ; uschar * quote ; if ( p + len + 8 >= big_buffer + big_buffer_size ) { Ustrcpy ( p , ""<S2SV_blank>..."" ) ; log_write ( 0 , LOG_MAIN , ""%s"" , big_buffer ) ; Ustrcpy ( big_buffer , ""..."" ) ; p = big_buffer + 3 ; } printing = string_printing ( argv [ i ] ) ; if ( printing [ 0 ] == 0 ) quote = US ""\\"""" ; else { const uschar * pp = printing ; quote = US """" ; while ( * pp != 0 ) if ( isspace ( * pp ++ ) ) { quote = US ""\\"""" ; break ; } } sprintf ( CS p , ""<S2SV_blank>%s%.*s%s"" , quote , ( int ) ( big_buffer_size - ( p - big_buffer ) - 4 ) , printing , quote ) ; while ( * p ) p ++ ; } if ( LOGGING ( arguments ) ) log_write ( 0 , LOG_MAIN , ""%s"" , big_buffer ) ; else debug_printf ( ""%s\\n"" , big_buffer ) ; } if ( Uchdir ( spool_directory ) != 0 ) { int dummy ; ( void ) directory_make ( spool_directory , US """" , SPOOL_DIRECTORY_MODE , FALSE ) ; dummy = Uchdir ( spool_directory ) ; } if ( bi_option ) { ( void ) fclose ( config_file ) ; if ( bi_command != NULL ) { int i = 0 ; uschar * argv [ 3 ] ; argv [ i ++ ] = bi_command ; if ( alias_arg != NULL ) argv [ i ++ ] = alias_arg ; argv [ i ++ ] = NULL ; setgroups ( group_count , group_list ) ; exim_setugid ( real_uid , real_gid , FALSE , US ""running<S2SV_blank>bi_command"" ) ; DEBUG ( D_exec ) debug_printf ( ""exec<S2SV_blank>%.256s<S2SV_blank>%.256s\\n"" , argv [ 0 ] , ( argv [ 1 ] == NULL ) ? US """" : argv [ 1 ] ) ; execv ( CS argv [ 0 ] , ( char * const * ) argv ) ; fprintf ( stderr , ""exim:<S2SV_blank>exec<S2SV_blank>failed:<S2SV_blank>%s\\n"" , strerror ( errno ) ) ; exit ( EXIT_FAILURE ) ; } else { DEBUG ( D_any ) debug_printf ( ""-bi<S2SV_blank>used<S2SV_blank>but<S2SV_blank>bi_command<S2SV_blank>not<S2SV_blank>set;<S2SV_blank>exiting\\n"" ) ; exit ( EXIT_SUCCESS ) ; } } if ( trusted_caller ) DEBUG ( D_any ) debug_printf ( ""trusted<S2SV_blank>user\\n"" ) ; if ( admin_user ) DEBUG ( D_any ) debug_printf ( ""admin<S2SV_blank>user\\n"" ) ; if ( ! admin_user ) { BOOL debugset = ( debug_selector & ~ D_v ) != 0 ; if ( deliver_give_up || daemon_listen || malware_test_file || ( count_queue && queue_list_requires_admin ) || ( list_queue && queue_list_requires_admin ) || ( queue_interval >= 0 && prod_requires_admin ) || ( debugset && ! running_in_test_harness ) ) { fprintf ( stderr , ""exim:%s<S2SV_blank>permission<S2SV_blank>denied\\n"" , debugset ? ""<S2SV_blank>debugging"" : """" ) ; exit ( EXIT_FAILURE ) ; } } if ( real_uid != root_uid && real_uid != exim_uid && ( continue_hostname != NULL || ( dont_deliver && ( queue_interval >= 0 || daemon_listen || msg_action_arg > 0 ) ) ) && ! running_in_test_harness ) { fprintf ( stderr , ""exim:<S2SV_blank>Permission<S2SV_blank>denied\\n"" ) ; return EXIT_FAILURE ; } if ( ! trusted_caller && ! checking ) { sender_host_name = sender_host_address = interface_address = sender_ident = received_protocol = NULL ; sender_host_port = interface_port = 0 ; sender_host_authenticated = authenticated_sender = authenticated_id = NULL ; } else { if ( sender_host_address != NULL ) sender_host_port = check_port ( sender_host_address ) ; if ( interface_address != NULL ) interface_port = check_port ( interface_address ) ; } if ( flag_G ) { if ( trusted_caller ) { suppress_local_fixups = suppress_local_fixups_default = TRUE ; DEBUG ( D_acl ) debug_printf ( ""suppress_local_fixups<S2SV_blank>forced<S2SV_blank>on<S2SV_blank>by<S2SV_blank>-G\\n"" ) ; } else { fprintf ( stderr , ""exim:<S2SV_blank>permission<S2SV_blank>denied<S2SV_blank>(-G<S2SV_blank>requires<S2SV_blank>a<S2SV_blank>trusted<S2SV_blank>user)\\n"" ) ; return EXIT_FAILURE ; } } if ( smtp_input ) { union sockaddr_46 inetd_sock ; EXIM_SOCKLEN_T size = sizeof ( inetd_sock ) ; if ( getpeername ( 0 , ( struct sockaddr * ) ( & inetd_sock ) , & size ) == 0 ) { int family = ( ( struct sockaddr * ) ( & inetd_sock ) ) -> sa_family ; if ( family == AF_INET || family == AF_INET6 ) { union sockaddr_46 interface_sock ; size = sizeof ( interface_sock ) ; if ( getsockname ( 0 , ( struct sockaddr * ) ( & interface_sock ) , & size ) == 0 ) interface_address = host_ntoa ( - 1 , & interface_sock , NULL , & interface_port ) ; if ( host_is_tls_on_connect_port ( interface_port ) ) tls_in . on_connect = TRUE ; if ( real_uid == root_uid || real_uid == exim_uid || interface_port < 1024 ) { is_inetd = TRUE ; sender_host_address = host_ntoa ( - 1 , ( struct sockaddr * ) ( & inetd_sock ) , NULL , & sender_host_port ) ; if ( mua_wrapper ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , ""Input<S2SV_blank>from<S2SV_blank>"" ""inetd<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>when<S2SV_blank>mua_wrapper<S2SV_blank>is<S2SV_blank>set"" ) ; } else { fprintf ( stderr , ""exim:<S2SV_blank>Permission<S2SV_blank>denied<S2SV_blank>(unprivileged<S2SV_blank>user,<S2SV_blank>unprivileged<S2SV_blank>port)\\n"" ) ; return EXIT_FAILURE ; } } } } # ifdef LOAD_AVG_NEEDS_ROOT if ( receiving_message && ( queue_only_load >= 0 || ( is_inetd && smtp_load_reserve >= 0 ) ) ) { load_average = OS_GETLOADAVG ( ) ; } # endif if ( queue_only_set && ( queue_only_override || arg_queue_only ) ) queue_only = arg_queue_only ; if ( arg_receive_timeout >= 0 ) receive_timeout = arg_receive_timeout ; if ( arg_smtp_receive_timeout >= 0 ) smtp_receive_timeout = arg_smtp_receive_timeout ; if ( ! unprivileged && ! removed_privilege && ! daemon_listen && queue_interval <= 0 && ( deliver_drop_privilege || ( queue_interval < 0 && ( msg_action_arg < 0 || msg_action != MSG_DELIVER ) && ( ! checking || ! address_test_mode ) ) ) ) exim_setugid ( exim_uid , exim_gid , TRUE , US ""privilege<S2SV_blank>not<S2SV_blank>needed"" ) ; else { int rv ; rv = setgid ( exim_gid ) ; if ( rv == - 1 ) if ( ! ( unprivileged || removed_privilege ) ) { fprintf ( stderr , ""exim:<S2SV_blank>changing<S2SV_blank>group<S2SV_blank>failed:<S2SV_blank>%s\\n"" , strerror ( errno ) ) ; exit ( EXIT_FAILURE ) ; } else DEBUG ( D_any ) debug_printf ( ""changing<S2SV_blank>group<S2SV_blank>to<S2SV_blank>%ld<S2SV_blank>failed:<S2SV_blank>%s\\n"" , ( long int ) exim_gid , strerror ( errno ) ) ; } if ( malware_test_file ) { # ifdef WITH_CONTENT_SCAN int result ; set_process_info ( ""scanning<S2SV_blank>file<S2SV_blank>for<S2SV_blank>malware"" ) ; result = malware_in_file ( malware_test_file ) ; if ( result == FAIL ) { printf ( ""No<S2SV_blank>malware<S2SV_blank>found.\\n"" ) ; exit ( EXIT_SUCCESS ) ; } if ( result != OK ) { printf ( ""Malware<S2SV_blank>lookup<S2SV_blank>returned<S2SV_blank>non-okay/fail:<S2SV_blank>%d\\n"" , result ) ; exit ( EXIT_FAILURE ) ; } if ( malware_name ) printf ( ""Malware<S2SV_blank>found:<S2SV_blank>%s\\n"" , malware_name ) ; else printf ( ""Malware<S2SV_blank>scan<S2SV_blank>detected<S2SV_blank>malware<S2SV_blank>of<S2SV_blank>unknown<S2SV_blank>name.\\n"" ) ; # else printf ( ""Malware<S2SV_blank>scanning<S2SV_blank>not<S2SV_blank>enabled<S2SV_blank>at<S2SV_blank>compile<S2SV_blank>time.\\n"" ) ; # endif exit ( EXIT_FAILURE ) ; } if ( list_queue ) { set_process_info ( ""listing<S2SV_blank>the<S2SV_blank>queue"" ) ; queue_list ( list_queue_option , argv + recipients_arg , argc - recipients_arg ) ; exit ( EXIT_SUCCESS ) ; } if ( count_queue ) { set_process_info ( ""counting<S2SV_blank>the<S2SV_blank>queue"" ) ; queue_count ( ) ; exit ( EXIT_SUCCESS ) ; } if ( msg_action_arg > 0 && msg_action != MSG_DELIVER && msg_action != MSG_LOAD ) { int yield = EXIT_SUCCESS ; set_process_info ( ""acting<S2SV_blank>on<S2SV_blank>specified<S2SV_blank>messages"" ) ; if ( ! one_msg_action ) { for ( i = msg_action_arg ; i < argc ; i ++ ) if ( ! queue_action ( argv [ i ] , msg_action , NULL , 0 , 0 ) ) yield = EXIT_FAILURE ; } else if ( ! queue_action ( argv [ msg_action_arg ] , msg_action , argv , argc , recipients_arg ) ) yield = EXIT_FAILURE ; exit ( yield ) ; } readconf_rest ( ) ; store_pool = POOL_MAIN ; if ( test_retry_arg >= 0 ) { retry_config * yield ; int basic_errno = 0 ; int more_errno = 0 ; uschar * s1 , * s2 ; if ( test_retry_arg >= argc ) { printf ( ""-brt<S2SV_blank>needs<S2SV_blank>a<S2SV_blank>domain<S2SV_blank>or<S2SV_blank>address<S2SV_blank>argument\\n"" ) ; exim_exit ( EXIT_FAILURE ) ; } s1 = argv [ test_retry_arg ++ ] ; s2 = NULL ; if ( Ustrchr ( s1 , '@' ) == NULL && Ustrchr ( s1 , '.' ) == NULL ) { printf ( ""Warning:<S2SV_blank>\\""%s\\""<S2SV_blank>contains<S2SV_blank>no<S2SV_blank>\'@\'<S2SV_blank>and<S2SV_blank>no<S2SV_blank>\'.\'<S2SV_blank>characters.<S2SV_blank>It<S2SV_blank>is<S2SV_blank>"" ""being<S2SV_blank>\\ntreated<S2SV_blank>as<S2SV_blank>a<S2SV_blank>one-component<S2SV_blank>domain,<S2SV_blank>not<S2SV_blank>as<S2SV_blank>a<S2SV_blank>local<S2SV_blank>part.\\n\\n"" , s1 ) ; } if ( test_retry_arg < argc && Ustrchr ( argv [ test_retry_arg ] , '.' ) != NULL ) s2 = argv [ test_retry_arg ++ ] ; if ( test_retry_arg < argc ) { uschar * ss = argv [ test_retry_arg ] ; uschar * error = readconf_retry_error ( ss , ss + Ustrlen ( ss ) , & basic_errno , & more_errno ) ; if ( error != NULL ) { printf ( ""%s\\n"" , CS error ) ; return EXIT_FAILURE ; } if ( basic_errno == ERRNO_MAIL4XX || basic_errno == ERRNO_RCPT4XX || basic_errno == ERRNO_DATA4XX ) { int code = ( more_errno >> 8 ) & 255 ; if ( code == 255 ) more_errno = ( more_errno & 0xffff00ff ) | ( 21 << 8 ) ; else if ( code > 100 ) more_errno = ( more_errno & 0xffff00ff ) | ( ( code - 96 ) << 8 ) ; } } yield = retry_find_config ( s1 , s2 , basic_errno , more_errno ) ; if ( yield == NULL ) printf ( ""No<S2SV_blank>retry<S2SV_blank>information<S2SV_blank>found\\n"" ) ; else { retry_rule * r ; more_errno = yield -> more_errno ; printf ( ""Retry<S2SV_blank>rule:<S2SV_blank>%s<S2SV_blank><S2SV_blank>"" , yield -> pattern ) ; if ( yield -> basic_errno == ERRNO_EXIMQUOTA ) { printf ( ""quota%s%s<S2SV_blank><S2SV_blank>"" , ( more_errno > 0 ) ? ""_"" : """" , ( more_errno > 0 ) ? readconf_printtime ( more_errno ) : US """" ) ; } else if ( yield -> basic_errno == ECONNREFUSED ) { printf ( ""refused%s%s<S2SV_blank><S2SV_blank>"" , ( more_errno > 0 ) ? ""_"" : """" , ( more_errno == 'M' ) ? ""MX"" : ( more_errno == 'A' ) ? ""A"" : """" ) ; } else if ( yield -> basic_errno == ETIMEDOUT ) { printf ( ""timeout"" ) ; if ( ( more_errno & RTEF_CTOUT ) != 0 ) printf ( ""_connect"" ) ; more_errno &= 255 ; if ( more_errno != 0 ) printf ( ""_%s"" , ( more_errno == 'M' ) ? ""MX"" : ""A"" ) ; printf ( ""<S2SV_blank><S2SV_blank>"" ) ; } else if ( yield -> basic_errno == ERRNO_AUTHFAIL ) printf ( ""auth_failed<S2SV_blank><S2SV_blank>"" ) ; else printf ( ""*<S2SV_blank><S2SV_blank>"" ) ; for ( r = yield -> rules ; r != NULL ; r = r -> next ) { printf ( ""%c,%s"" , r -> rule , readconf_printtime ( r -> timeout ) ) ; printf ( "",%s"" , readconf_printtime ( r -> p1 ) ) ; if ( r -> rule == 'G' ) { int x = r -> p2 ; int f = x % 1000 ; int d = 100 ; printf ( "",%d."" , x / 1000 ) ; do { printf ( ""%d"" , f / d ) ; f %= d ; d /= 10 ; } while ( f != 0 ) ; } printf ( "";<S2SV_blank>"" ) ; } printf ( ""\\n"" ) ; } exim_exit ( EXIT_SUCCESS ) ; } if ( list_options ) { set_process_info ( ""listing<S2SV_blank>variables"" ) ; if ( recipients_arg >= argc ) readconf_print ( US ""all"" , NULL , flag_n ) ; else for ( i = recipients_arg ; i < argc ; i ++ ) { if ( i < argc - 1 && ( Ustrcmp ( argv [ i ] , ""router"" ) == 0 || Ustrcmp ( argv [ i ] , ""transport"" ) == 0 || Ustrcmp ( argv [ i ] , ""authenticator"" ) == 0 || Ustrcmp ( argv [ i ] , ""macro"" ) == 0 || Ustrcmp ( argv [ i ] , ""environment"" ) == 0 ) ) { readconf_print ( argv [ i + 1 ] , argv [ i ] , flag_n ) ; i ++ ; } else readconf_print ( argv [ i ] , NULL , flag_n ) ; } exim_exit ( EXIT_SUCCESS ) ; } if ( list_config ) { set_process_info ( ""listing<S2SV_blank>config"" ) ; readconf_print ( US ""config"" , NULL , flag_n ) ; exim_exit ( EXIT_SUCCESS ) ; } # ifndef DISABLE_DKIM dkim_exim_init ( ) ; # endif deliver_init ( ) ; if ( msg_action_arg > 0 && msg_action != MSG_LOAD ) { if ( prod_requires_admin && ! admin_user ) { fprintf ( stderr , ""exim:<S2SV_blank>Permission<S2SV_blank>denied\\n"" ) ; exim_exit ( EXIT_FAILURE ) ; } set_process_info ( ""delivering<S2SV_blank>specified<S2SV_blank>messages"" ) ; if ( deliver_give_up ) forced_delivery = deliver_force_thaw = TRUE ; for ( i = msg_action_arg ; i < argc ; i ++ ) { int status ; pid_t pid ; if ( i == argc - 1 ) ( void ) deliver_message ( argv [ i ] , forced_delivery , deliver_give_up ) ; else if ( ( pid = fork ( ) ) == 0 ) { ( void ) deliver_message ( argv [ i ] , forced_delivery , deliver_give_up ) ; _exit ( EXIT_SUCCESS ) ; } else if ( pid < 0 ) { fprintf ( stderr , ""failed<S2SV_blank>to<S2SV_blank>fork<S2SV_blank>delivery<S2SV_blank>process<S2SV_blank>for<S2SV_blank>%s:<S2SV_blank>%s\\n"" , argv [ i ] , strerror ( errno ) ) ; exim_exit ( EXIT_FAILURE ) ; } else wait ( & status ) ; } exim_exit ( EXIT_SUCCESS ) ; } if ( queue_interval == 0 && ! daemon_listen ) { DEBUG ( D_queue_run ) debug_printf ( ""Single<S2SV_blank>queue<S2SV_blank>run%s%s%s%s\\n"" , ( start_queue_run_id == NULL ) ? US """" : US ""<S2SV_blank>starting<S2SV_blank>at<S2SV_blank>"" , ( start_queue_run_id == NULL ) ? US """" : start_queue_run_id , ( stop_queue_run_id == NULL ) ? US """" : US ""<S2SV_blank>stopping<S2SV_blank>at<S2SV_blank>"" , ( stop_queue_run_id == NULL ) ? US """" : stop_queue_run_id ) ; if ( * queue_name ) set_process_info ( ""running<S2SV_blank>the<S2SV_blank>\'%s\'<S2SV_blank>queue<S2SV_blank>(single<S2SV_blank>queue<S2SV_blank>run)"" , queue_name ) ; else set_process_info ( ""running<S2SV_blank>the<S2SV_blank>queue<S2SV_blank>(single<S2SV_blank>queue<S2SV_blank>run)"" ) ; queue_run ( start_queue_run_id , stop_queue_run_id , FALSE ) ; exim_exit ( EXIT_SUCCESS ) ; } for ( i = 0 ; ; ) { if ( ( pw = getpwuid ( real_uid ) ) != NULL ) { originator_login = string_copy ( US pw -> pw_name ) ; originator_home = string_copy ( US pw -> pw_dir ) ; if ( originator_name == NULL ) { if ( sender_address == NULL || ( ! trusted_caller && filter_test == FTEST_NONE ) ) { uschar * name = US pw -> pw_gecos ; uschar * amp = Ustrchr ( name , '&' ) ; uschar buffer [ 256 ] ; if ( amp != NULL ) { int loffset ; string_format ( buffer , sizeof ( buffer ) , ""%.*s%n%s%s"" , amp - name , name , & loffset , originator_login , amp + 1 ) ; buffer [ loffset ] = toupper ( buffer [ loffset ] ) ; name = buffer ; } if ( gecos_pattern != NULL && gecos_name != NULL ) { const pcre * re ; re = regex_must_compile ( gecos_pattern , FALSE , TRUE ) ; if ( regex_match_and_setup ( re , name , 0 , - 1 ) ) { uschar * new_name = expand_string ( gecos_name ) ; expand_nmax = - 1 ; if ( new_name != NULL ) { DEBUG ( D_receive ) debug_printf ( ""user<S2SV_blank>name<S2SV_blank>\\""%s\\""<S2SV_blank>extracted<S2SV_blank>from<S2SV_blank>"" ""gecos<S2SV_blank>field<S2SV_blank>\\""%s\\""\\n"" , new_name , name ) ; name = new_name ; } else DEBUG ( D_receive ) debug_printf ( ""failed<S2SV_blank>to<S2SV_blank>expand<S2SV_blank>gecos_name<S2SV_blank>string<S2SV_blank>"" ""\\""%s\\"":<S2SV_blank>%s\\n"" , gecos_name , expand_string_message ) ; } else DEBUG ( D_receive ) debug_printf ( ""gecos_pattern<S2SV_blank>\\""%s\\""<S2SV_blank>did<S2SV_blank>not<S2SV_blank>match<S2SV_blank>"" ""gecos<S2SV_blank>field<S2SV_blank>\\""%s\\""\\n"" , gecos_pattern , name ) ; store_free ( ( void * ) re ) ; } originator_name = string_copy ( name ) ; } else originator_name = US """" ; } break ; } if ( ++ i > finduser_retries ) break ; sleep ( 1 ) ; } if ( originator_login == NULL || running_in_test_harness ) { if ( unknown_login != NULL ) { originator_login = expand_string ( unknown_login ) ; if ( originator_name == NULL && unknown_username != NULL ) originator_name = expand_string ( unknown_username ) ; if ( originator_name == NULL ) originator_name = US """" ; } if ( originator_login == NULL ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>user<S2SV_blank>name<S2SV_blank>for<S2SV_blank>uid<S2SV_blank>%d"" , ( int ) real_uid ) ; } originator_name = string_copy ( parse_fix_phrase ( originator_name , Ustrlen ( originator_name ) , big_buffer , big_buffer_size ) ) ; originator_uid = real_uid ; originator_gid = real_gid ; DEBUG ( D_receive ) debug_printf ( ""originator:<S2SV_blank>uid=%d<S2SV_blank>gid=%d<S2SV_blank>login=%s<S2SV_blank>name=%s\\n"" , ( int ) originator_uid , ( int ) originator_gid , originator_login , originator_name ) ; if ( daemon_listen || inetd_wait_mode || queue_interval > 0 ) { if ( mua_wrapper ) { fprintf ( stderr , ""Daemon<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>run<S2SV_blank>when<S2SV_blank>mua_wrapper<S2SV_blank>is<S2SV_blank>set\\n"" ) ; log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , ""Daemon<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>run<S2SV_blank>when<S2SV_blank>"" ""mua_wrapper<S2SV_blank>is<S2SV_blank>set"" ) ; } daemon_go ( ) ; } if ( sender_ident == NULL ) sender_ident = originator_login ; else if ( sender_ident [ 0 ] == 0 ) sender_ident = NULL ; if ( test_rewrite_arg >= 0 ) { really_exim = FALSE ; if ( test_rewrite_arg >= argc ) { printf ( ""-brw<S2SV_blank>needs<S2SV_blank>an<S2SV_blank>address<S2SV_blank>argument\\n"" ) ; exim_exit ( EXIT_FAILURE ) ; } rewrite_test ( argv [ test_rewrite_arg ] ) ; exim_exit ( EXIT_SUCCESS ) ; } if ( ( sender_address == NULL && ! smtp_input ) || ( ! trusted_caller && filter_test == FTEST_NONE ) ) { sender_local = TRUE ; if ( authenticated_sender == NULL && ! host_checking ) authenticated_sender = string_sprintf ( ""%s@%s"" , originator_login , qualify_domain_sender ) ; if ( authenticated_id == NULL && ! host_checking ) authenticated_id = originator_login ; } if ( ( ! smtp_input && sender_address == NULL ) || ! receive_check_set_sender ( sender_address ) ) { if ( sender_address == NULL || ( sender_address [ 0 ] != 0 && ! checking ) ) { sender_address = originator_login ; sender_address_forced = FALSE ; sender_address_domain = 0 ; } } sender_set_untrusted = sender_address != originator_login && ! trusted_caller ; if ( sender_address != NULL && sender_address [ 0 ] != 0 && sender_address_domain == 0 ) sender_address = string_sprintf ( ""%s@%s"" , local_part_quote ( sender_address ) , qualify_domain_sender ) ; DEBUG ( D_receive ) debug_printf ( ""sender<S2SV_blank>address<S2SV_blank>=<S2SV_blank>%s\\n"" , sender_address ) ; if ( verify_address_mode || address_test_mode ) { int exit_value = 0 ; int flags = vopt_qualify ; if ( verify_address_mode ) { if ( ! verify_as_sender ) flags |= vopt_is_recipient ; DEBUG ( D_verify ) debug_print_ids ( US ""Verifying:"" ) ; } else { flags |= vopt_is_recipient ; debug_selector |= D_v ; debug_file = stderr ; debug_fd = fileno ( debug_file ) ; DEBUG ( D_verify ) debug_print_ids ( US ""Address<S2SV_blank>testing:"" ) ; } if ( recipients_arg < argc ) { while ( recipients_arg < argc ) { uschar * s = argv [ recipients_arg ++ ] ; while ( * s != 0 ) { BOOL finished = FALSE ; uschar * ss = parse_find_address_end ( s , FALSE ) ; if ( * ss == ',' ) * ss = 0 ; else finished = TRUE ; test_address ( s , flags , & exit_value ) ; s = ss ; if ( ! finished ) while ( * ( ++ s ) != 0 && ( * s == ',' || isspace ( * s ) ) ) ; } } } else for ( ; ; ) { uschar * s = get_stdinput ( NULL , NULL ) ; if ( s == NULL ) break ; test_address ( s , flags , & exit_value ) ; } route_tidyup ( ) ; exim_exit ( exit_value ) ; } if ( expansion_test ) { dns_init ( FALSE , FALSE , FALSE ) ; if ( msg_action_arg > 0 && msg_action == MSG_LOAD ) { uschar spoolname [ 256 ] ; if ( ! admin_user ) { fprintf ( stderr , ""exim:<S2SV_blank>permission<S2SV_blank>denied\\n"" ) ; exit ( EXIT_FAILURE ) ; } message_id = argv [ msg_action_arg ] ; ( void ) string_format ( spoolname , sizeof ( spoolname ) , ""%s-H"" , message_id ) ; if ( ( deliver_datafile = spool_open_datafile ( message_id ) ) < 0 ) printf ( ""Failed<S2SV_blank>to<S2SV_blank>load<S2SV_blank>message<S2SV_blank>datafile<S2SV_blank>%s\\n"" , message_id ) ; if ( spool_read_header ( spoolname , TRUE , FALSE ) != spool_read_OK ) printf ( ""Failed<S2SV_blank>to<S2SV_blank>load<S2SV_blank>message<S2SV_blank>%s\\n"" , message_id ) ; } else if ( expansion_test_message != NULL ) { int save_stdin = dup ( 0 ) ; int fd = Uopen ( expansion_test_message , O_RDONLY , 0 ) ; if ( fd < 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s:<S2SV_blank>%s\\n"" , expansion_test_message , strerror ( errno ) ) ; return EXIT_FAILURE ; } ( void ) dup2 ( fd , 0 ) ; filter_test = FTEST_USER ; message_ended = END_NOTENDED ; read_message_body ( receive_msg ( extract_recipients ) ) ; message_linecount += body_linecount ; ( void ) dup2 ( save_stdin , 0 ) ; ( void ) close ( save_stdin ) ; clearerr ( stdin ) ; } enable_dollar_recipients = TRUE ; if ( recipients_arg < argc ) { while ( recipients_arg < argc ) { uschar * s = argv [ recipients_arg ++ ] ; uschar * ss = expand_string ( s ) ; if ( ss == NULL ) printf ( ""Failed:<S2SV_blank>%s\\n"" , expand_string_message ) ; else printf ( ""%s\\n"" , CS ss ) ; } } else { char * ( * fn_readline ) ( const char * ) = NULL ; void ( * fn_addhist ) ( const char * ) = NULL ; # ifdef USE_READLINE void * dlhandle = set_readline ( & fn_readline , & fn_addhist ) ; # endif for ( ; ; ) { uschar * ss ; uschar * source = get_stdinput ( fn_readline , fn_addhist ) ; if ( source == NULL ) break ; ss = expand_string ( source ) ; if ( ss == NULL ) printf ( ""Failed:<S2SV_blank>%s\\n"" , expand_string_message ) ; else printf ( ""%s\\n"" , CS ss ) ; } # ifdef USE_READLINE if ( dlhandle != NULL ) dlclose ( dlhandle ) ; # endif } if ( deliver_datafile >= 0 ) { ( void ) close ( deliver_datafile ) ; deliver_datafile = - 1 ; } exim_exit ( EXIT_SUCCESS ) ; } smtp_active_hostname = primary_hostname ; if ( raw_active_hostname != NULL ) { uschar * nah = expand_string ( raw_active_hostname ) ; if ( nah == NULL ) { if ( ! expand_string_forcedfail ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , ""failed<S2SV_blank>to<S2SV_blank>expand<S2SV_blank>\\""%s\\""<S2SV_blank>"" ""(smtp_active_hostname):<S2SV_blank>%s"" , raw_active_hostname , expand_string_message ) ; } else if ( nah [ 0 ] != 0 ) smtp_active_hostname = nah ; } if ( host_checking ) { int x [ 4 ] ; int size ; if ( ! sender_ident_set ) { sender_ident = NULL ; if ( running_in_test_harness && sender_host_port != 0 && interface_address != NULL && interface_port != 0 ) verify_get_ident ( 1413 ) ; } size = host_aton ( sender_host_address , x ) ; sender_host_address = store_get ( 48 ) ; ( void ) host_nmtoa ( size , x , - 1 , sender_host_address , ':' ) ; host_build_sender_fullhost ( ) ; smtp_input = TRUE ; smtp_in = stdin ; smtp_out = stdout ; sender_local = FALSE ; sender_host_notsocket = TRUE ; debug_file = stderr ; debug_fd = fileno ( debug_file ) ; fprintf ( stdout , ""\\n****<S2SV_blank>SMTP<S2SV_blank>testing<S2SV_blank>session<S2SV_blank>as<S2SV_blank>if<S2SV_blank>from<S2SV_blank>host<S2SV_blank>%s\\n"" ""****<S2SV_blank>but<S2SV_blank>without<S2SV_blank>any<S2SV_blank>ident<S2SV_blank>(RFC<S2SV_blank>1413)<S2SV_blank>callback.\\n"" ""****<S2SV_blank>This<S2SV_blank>is<S2SV_blank>not<S2SV_blank>for<S2SV_blank>real!\\n\\n"" , sender_host_address ) ; memset ( sender_host_cache , 0 , sizeof ( sender_host_cache ) ) ; if ( verify_check_host ( & hosts_connection_nolog ) == OK ) BIT_CLEAR ( log_selector , log_selector_size , Li_smtp_connection ) ; log_write ( L_smtp_connection , LOG_MAIN , ""%s"" , smtp_get_connection_info ( ) ) ; if ( smtp_start_session ( ) ) { for ( reset_point = store_get ( 0 ) ; ; store_reset ( reset_point ) ) { if ( smtp_setup_msg ( ) <= 0 ) break ; if ( ! receive_msg ( FALSE ) ) break ; return_path = sender_address = NULL ; dnslist_domain = dnslist_matched = NULL ; # ifndef DISABLE_DKIM dkim_cur_signer = NULL ; # endif acl_var_m = NULL ; deliver_localpart_orig = NULL ; deliver_domain_orig = NULL ; callout_address = sending_ip_address = NULL ; sender_rate = sender_rate_limit = sender_rate_period = NULL ; } smtp_log_no_mail ( ) ; } exim_exit ( EXIT_SUCCESS ) ; } if ( recipients_arg >= argc && ! extract_recipients && ! smtp_input ) { if ( version_printed ) { printf ( ""Configuration<S2SV_blank>file<S2SV_blank>is<S2SV_blank>%s\\n"" , config_main_filename ) ; return EXIT_SUCCESS ; } if ( info_flag != CMDINFO_NONE ) { show_exim_information ( info_flag , info_stdout ? stdout : stderr ) ; return info_stdout ? EXIT_SUCCESS : EXIT_FAILURE ; } if ( filter_test == FTEST_NONE ) exim_usage ( called_as ) ; } if ( mua_wrapper ) { synchronous_delivery = TRUE ; arg_error_handling = ERRORS_STDERR ; remote_max_parallel = 1 ; deliver_drop_privilege = TRUE ; queue_smtp = FALSE ; queue_smtp_domains = NULL ; # ifdef SUPPORT_I18N message_utf8_downconvert = - 1 ; # endif } if ( ! smtp_input ) error_handling = arg_error_handling ; else if ( is_inetd ) { ( void ) fclose ( stderr ) ; exim_nullstd ( ) ; verify_get_ident ( IDENT_PORT ) ; host_build_sender_fullhost ( ) ; set_process_info ( ""handling<S2SV_blank>incoming<S2SV_blank>connection<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>via<S2SV_blank>inetd"" , sender_fullhost ) ; } if ( sender_host_address != NULL && sender_fullhost == NULL ) { host_build_sender_fullhost ( ) ; set_process_info ( ""handling<S2SV_blank>incoming<S2SV_blank>connection<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>via<S2SV_blank>-oMa"" , sender_fullhost ) ; sender_host_notsocket = TRUE ; } else if ( ! is_inetd ) sender_host_unknown = TRUE ; if ( fstat ( 1 , & statbuf ) < 0 ) ( void ) dup2 ( 0 , 1 ) ; if ( smtp_input ) { if ( ! is_inetd ) set_process_info ( ""accepting<S2SV_blank>a<S2SV_blank>local<S2SV_blank>%sSMTP<S2SV_blank>message<S2SV_blank>from<S2SV_blank><%s>"" , smtp_batched_input ? ""batched<S2SV_blank>"" : """" , ( sender_address != NULL ) ? sender_address : originator_login ) ; } else { int old_pool = store_pool ; store_pool = POOL_PERM ; if ( ! received_protocol ) received_protocol = string_sprintf ( ""local%s"" , called_as ) ; store_pool = old_pool ; set_process_info ( ""accepting<S2SV_blank>a<S2SV_blank>local<S2SV_blank>non-SMTP<S2SV_blank>message<S2SV_blank>from<S2SV_blank><%s>"" , sender_address ) ; } queue_check_only ( ) ; session_local_queue_only = queue_only ; if ( ( ! smtp_input || smtp_batched_input ) && ! receive_check_fs ( 0 ) ) { fprintf ( stderr , ""exim:<S2SV_blank>insufficient<S2SV_blank>disk<S2SV_blank>space\\n"" ) ; return EXIT_FAILURE ; } if ( smtp_input ) { smtp_in = stdin ; smtp_out = stdout ; memset ( sender_host_cache , 0 , sizeof ( sender_host_cache ) ) ; if ( verify_check_host ( & hosts_connection_nolog ) == OK ) BIT_CLEAR ( log_selector , log_selector_size , Li_smtp_connection ) ; log_write ( L_smtp_connection , LOG_MAIN , ""%s"" , smtp_get_connection_info ( ) ) ; if ( ! smtp_start_session ( ) ) { mac_smtp_fflush ( ) ; exim_exit ( EXIT_SUCCESS ) ; } } else { thismessage_size_limit = expand_string_integer ( message_size_limit , TRUE ) ; if ( expand_string_message ) if ( thismessage_size_limit == - 1 ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , ""failed<S2SV_blank>to<S2SV_blank>expand<S2SV_blank>"" ""message_size_limit:<S2SV_blank>%s"" , expand_string_message ) ; else log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , ""invalid<S2SV_blank>value<S2SV_blank>for<S2SV_blank>"" ""message_size_limit:<S2SV_blank>%s"" , expand_string_message ) ; } if ( ! synchronous_delivery ) { # ifdef SA_NOCLDWAIT struct sigaction act ; act . sa_handler = SIG_IGN ; sigemptyset ( & ( act . sa_mask ) ) ; act . sa_flags = SA_NOCLDWAIT ; sigaction ( SIGCHLD , & act , NULL ) ; # else signal ( SIGCHLD , SIG_IGN ) ; # endif } reset_point = store_get ( 0 ) ; real_sender_address = sender_address ; while ( more ) { message_id [ 0 ] = 0 ; if ( smtp_input ) { int rc ; if ( ( rc = smtp_setup_msg ( ) ) > 0 ) { if ( real_sender_address != NULL && ! receive_check_set_sender ( sender_address ) ) { sender_address = raw_sender = real_sender_address ; sender_address_unrewritten = NULL ; } if ( smtp_batched_input && acl_not_smtp_start != NULL ) { uschar * user_msg , * log_msg ; enable_dollar_recipients = TRUE ; ( void ) acl_check ( ACL_WHERE_NOTSMTP_START , NULL , acl_not_smtp_start , & user_msg , & log_msg ) ; enable_dollar_recipients = FALSE ; } more = receive_msg ( extract_recipients ) ; if ( message_id [ 0 ] == 0 ) { cancel_cutthrough_connection ( TRUE , US ""receive<S2SV_blank>dropped"" ) ; if ( more ) goto moreloop ; smtp_log_no_mail ( ) ; exim_exit ( EXIT_FAILURE ) ; } } else { cancel_cutthrough_connection ( TRUE , US ""message<S2SV_blank>setup<S2SV_blank>dropped"" ) ; smtp_log_no_mail ( ) ; exim_exit ( ( rc == 0 ) ? EXIT_SUCCESS : EXIT_FAILURE ) ; } } else { int i ; int rcount = 0 ; int count = argc - recipients_arg ; uschar * * list = argv + recipients_arg ; active_local_sender_retain = local_sender_retain ; active_local_from_check = local_from_check ; raw_sender = string_copy ( sender_address ) ; for ( i = 0 ; i < count ; i ++ ) { int start , end , domain ; uschar * errmess ; uschar * s = list [ i ] ; while ( * s != 0 ) { BOOL finished = FALSE ; uschar * recipient ; uschar * ss = parse_find_address_end ( s , FALSE ) ; if ( * ss == ',' ) * ss = 0 ; else finished = TRUE ; if ( recipients_max > 0 && ++ rcount > recipients_max && ! extract_recipients ) if ( error_handling == ERRORS_STDERR ) { fprintf ( stderr , ""exim:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>recipients\\n"" ) ; exim_exit ( EXIT_FAILURE ) ; } else { return moan_to_sender ( ERRMESS_TOOMANYRECIP , NULL , NULL , stdin , TRUE ) ? errors_sender_rc : EXIT_FAILURE ; } # ifdef SUPPORT_I18N { BOOL b = allow_utf8_domains ; allow_utf8_domains = TRUE ; # endif recipient = parse_extract_address ( s , & errmess , & start , & end , & domain , FALSE ) ; # ifdef SUPPORT_I18N if ( string_is_utf8 ( recipient ) ) message_smtputf8 = TRUE ; else allow_utf8_domains = b ; } # endif if ( domain == 0 && ! allow_unqualified_recipient ) { recipient = NULL ; errmess = US ""unqualified<S2SV_blank>recipient<S2SV_blank>address<S2SV_blank>not<S2SV_blank>allowed"" ; } if ( recipient == NULL ) { if ( error_handling == ERRORS_STDERR ) { fprintf ( stderr , ""exim:<S2SV_blank>bad<S2SV_blank>recipient<S2SV_blank>address<S2SV_blank>\\""%s\\"":<S2SV_blank>%s\\n"" , string_printing ( list [ i ] ) , errmess ) ; exim_exit ( EXIT_FAILURE ) ; } else { error_block eblock ; eblock . next = NULL ; eblock . text1 = string_printing ( list [ i ] ) ; eblock . text2 = errmess ; return moan_to_sender ( ERRMESS_BADARGADDRESS , & eblock , NULL , stdin , TRUE ) ? errors_sender_rc : EXIT_FAILURE ; } } receive_add_recipient ( recipient , - 1 ) ; s = ss ; if ( ! finished ) while ( * ( ++ s ) != 0 && ( * s == ',' || isspace ( * s ) ) ) ; } } DEBUG ( D_receive ) { int i ; if ( sender_address != NULL ) debug_printf ( ""Sender:<S2SV_blank>%s\\n"" , sender_address ) ; if ( recipients_list != NULL ) { debug_printf ( ""Recipients:\\n"" ) ; for ( i = 0 ; i < recipients_count ; i ++ ) debug_printf ( ""<S2SV_blank><S2SV_blank>%s\\n"" , recipients_list [ i ] . address ) ; } } if ( acl_not_smtp_start ) { uschar * user_msg , * log_msg ; enable_dollar_recipients = TRUE ; ( void ) acl_check ( ACL_WHERE_NOTSMTP_START , NULL , acl_not_smtp_start , & user_msg , & log_msg ) ; enable_dollar_recipients = FALSE ; } if ( ! receive_timeout ) { struct timeval t = { 30 * 60 , 0 } ; fd_set r ; FD_ZERO ( & r ) ; FD_SET ( 0 , & r ) ; if ( select ( 1 , & r , NULL , NULL , & t ) == 0 ) mainlog_close ( ) ; } message_ended = END_NOTENDED ; more = receive_msg ( extract_recipients ) ; if ( message_id [ 0 ] == 0 ) exim_exit ( EXIT_FAILURE ) ; } if ( filter_test != FTEST_NONE ) { deliver_domain = ( ftest_domain != NULL ) ? ftest_domain : qualify_domain_recipient ; deliver_domain_orig = deliver_domain ; deliver_localpart = ( ftest_localpart != NULL ) ? ftest_localpart : originator_login ; deliver_localpart_orig = deliver_localpart ; deliver_localpart_prefix = ftest_prefix ; deliver_localpart_suffix = ftest_suffix ; deliver_home = originator_home ; if ( return_path == NULL ) { printf ( ""Return-path<S2SV_blank>copied<S2SV_blank>from<S2SV_blank>sender\\n"" ) ; return_path = string_copy ( sender_address ) ; } else printf ( ""Return-path<S2SV_blank>=<S2SV_blank>%s\\n"" , ( return_path [ 0 ] == 0 ) ? US ""<>"" : return_path ) ; printf ( ""Sender<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%s\\n"" , ( sender_address [ 0 ] == 0 ) ? US ""<>"" : sender_address ) ; receive_add_recipient ( string_sprintf ( ""%s%s%s@%s"" , ( ftest_prefix == NULL ) ? US """" : ftest_prefix , deliver_localpart , ( ftest_suffix == NULL ) ? US """" : ftest_suffix , deliver_domain ) , - 1 ) ; printf ( ""Recipient<S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%s\\n"" , recipients_list [ 0 ] . address ) ; if ( ftest_prefix != NULL ) printf ( ""Prefix<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%s\\n"" , ftest_prefix ) ; if ( ftest_suffix != NULL ) printf ( ""Suffix<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%s\\n"" , ftest_suffix ) ; if ( chdir ( ""/"" ) ) { DEBUG ( D_receive ) debug_printf ( ""chdir(\\""/\\"")<S2SV_blank>failed\\n"" ) ; exim_exit ( EXIT_FAILURE ) ; } if ( ( filter_test & FTEST_SYSTEM ) != 0 ) { if ( ! filter_runtest ( filter_sfd , filter_test_sfile , TRUE , more ) ) exim_exit ( EXIT_FAILURE ) ; } memcpy ( filter_sn , filter_n , sizeof ( filter_sn ) ) ; if ( ( filter_test & FTEST_USER ) != 0 ) { if ( ! filter_runtest ( filter_ufd , filter_test_ufile , FALSE , more ) ) exim_exit ( EXIT_FAILURE ) ; } exim_exit ( EXIT_SUCCESS ) ; } if ( ! session_local_queue_only && smtp_accept_queue_per_connection > 0 && receive_messagecount > smtp_accept_queue_per_connection ) { session_local_queue_only = TRUE ; queue_only_reason = 2 ; } local_queue_only = session_local_queue_only ; if ( ! local_queue_only && queue_only_load >= 0 ) { local_queue_only = ( load_average = OS_GETLOADAVG ( ) ) > queue_only_load ; if ( local_queue_only ) { queue_only_reason = 3 ; if ( queue_only_load_latch ) session_local_queue_only = TRUE ; } } if ( mua_wrapper ) local_queue_only = queue_only_policy = deliver_freeze = FALSE ; if ( local_queue_only ) { cancel_cutthrough_connection ( TRUE , US ""no<S2SV_blank>delivery;<S2SV_blank>queueing"" ) ; switch ( queue_only_reason ) { case 2 : log_write ( L_delay_delivery , LOG_MAIN , ""no<S2SV_blank>immediate<S2SV_blank>delivery:<S2SV_blank>more<S2SV_blank>than<S2SV_blank>%d<S2SV_blank>messages<S2SV_blank>"" ""received<S2SV_blank>in<S2SV_blank>one<S2SV_blank>connection"" , smtp_accept_queue_per_connection ) ; break ; case 3 : log_write ( L_delay_delivery , LOG_MAIN , ""no<S2SV_blank>immediate<S2SV_blank>delivery:<S2SV_blank>load<S2SV_blank>average<S2SV_blank>%.2f"" , ( double ) load_average / 1000.0 ) ; break ; } } else if ( queue_only_policy || deliver_freeze ) cancel_cutthrough_connection ( TRUE , US ""no<S2SV_blank>delivery;<S2SV_blank>queueing"" ) ; else { pid_t pid ; search_tidyup ( ) ; if ( ( pid = fork ( ) ) == 0 ) { int rc ; close_unwanted ( ) ; exim_nullstd ( ) ; if ( geteuid ( ) != root_uid && ! deliver_drop_privilege && ! unprivileged ) { delivery_re_exec ( CEE_EXEC_EXIT ) ; } rc = deliver_message ( message_id , FALSE , FALSE ) ; search_tidyup ( ) ; _exit ( ( ! mua_wrapper || rc == DELIVER_MUA_SUCCEEDED ) ? EXIT_SUCCESS : EXIT_FAILURE ) ; } if ( pid < 0 ) { cancel_cutthrough_connection ( TRUE , US ""delivery<S2SV_blank>fork<S2SV_blank>failed"" ) ; log_write ( 0 , LOG_MAIN | LOG_PANIC , ""failed<S2SV_blank>to<S2SV_blank>fork<S2SV_blank>automatic<S2SV_blank>delivery<S2SV_blank>"" ""process:<S2SV_blank>%s"" , strerror ( errno ) ) ; } else { release_cutthrough_connection ( US ""msg<S2SV_blank>passed<S2SV_blank>for<S2SV_blank>delivery"" ) ; if ( synchronous_delivery ) { int status ; while ( wait ( & status ) != pid ) ; if ( ( status & 0x00ff ) != 0 ) log_write ( 0 , LOG_MAIN | LOG_PANIC , ""process<S2SV_blank>%d<S2SV_blank>crashed<S2SV_blank>with<S2SV_blank>signal<S2SV_blank>%d<S2SV_blank>while<S2SV_blank>delivering<S2SV_blank>%s"" , ( int ) pid , status & 0x00ff , message_id ) ; if ( mua_wrapper && ( status & 0xffff ) != 0 ) exim_exit ( EXIT_FAILURE ) ; } } } # ifndef SIG_IGN_WORKS while ( waitpid ( - 1 , NULL , WNOHANG ) > 0 ) ; # endif moreloop : return_path = sender_address = NULL ; authenticated_sender = NULL ; deliver_localpart_orig = NULL ; deliver_domain_orig = NULL ; deliver_host = deliver_host_address = NULL ; dnslist_domain = dnslist_matched = NULL ; # ifdef WITH_CONTENT_SCAN malware_name = NULL ; # endif callout_address = NULL ; sending_ip_address = NULL ; acl_var_m = NULL ; { int i ; for ( i = 0 ; i < REGEX_VARS ; i ++ ) regex_vars [ i ] = NULL ; } store_reset ( reset_point ) ; } exim_exit ( EXIT_SUCCESS ) ; return 0 ; }","if ( exim_uid == 0 ) if ( received_protocol ) {fprintf ( stderr , ""received_protocol<S2SV_blank>is<S2SV_blank>set<S2SV_blank>already\\\exit ( EXIT_FAILURE ) ;}else {",349
472,"buggy line: uschar * p = & argrest [ 2 ] ;cwe id:CWE-404context: int main ( int argc , char * * cargv ) { uschar * * argv = USS cargv ; int arg_receive_timeout = - 1 ; int arg_smtp_receive_timeout = - 1 ; int arg_error_handling = error_handling ; int filter_sfd = - 1 ; int filter_ufd = - 1 ; int group_count ; int i , rv ; int list_queue_option = 0 ; int msg_action = 0 ; int msg_action_arg = - 1 ; int namelen = ( argv [ 0 ] == NULL ) ? 0 : Ustrlen ( argv [ 0 ] ) ; int queue_only_reason = 0 ; # ifdef EXIM_PERL int perl_start_option = 0 ; # endif int recipients_arg = argc ; int sender_address_domain = 0 ; int test_retry_arg = - 1 ; int test_rewrite_arg = - 1 ; BOOL arg_queue_only = FALSE ; BOOL bi_option = FALSE ; BOOL checking = FALSE ; BOOL count_queue = FALSE ; BOOL expansion_test = FALSE ; BOOL extract_recipients = FALSE ; BOOL flag_G = FALSE ; BOOL flag_n = FALSE ; BOOL forced_delivery = FALSE ; BOOL f_end_dot = FALSE ; BOOL deliver_give_up = FALSE ; BOOL list_queue = FALSE ; BOOL list_options = FALSE ; BOOL list_config = FALSE ; BOOL local_queue_only ; BOOL more = TRUE ; BOOL one_msg_action = FALSE ; BOOL opt_D_used = FALSE ; BOOL queue_only_set = FALSE ; BOOL receiving_message = TRUE ; BOOL sender_ident_set = FALSE ; BOOL session_local_queue_only ; BOOL unprivileged ; BOOL removed_privilege = FALSE ; BOOL usage_wanted = FALSE ; BOOL verify_address_mode = FALSE ; BOOL verify_as_sender = FALSE ; BOOL version_printed = FALSE ; uschar * alias_arg = NULL ; uschar * called_as = US """" ; uschar * cmdline_syslog_name = NULL ; uschar * start_queue_run_id = NULL ; uschar * stop_queue_run_id = NULL ; uschar * expansion_test_message = NULL ; uschar * ftest_domain = NULL ; uschar * ftest_localpart = NULL ; uschar * ftest_prefix = NULL ; uschar * ftest_suffix = NULL ; uschar * log_oneline = NULL ; uschar * malware_test_file = NULL ; uschar * real_sender_address ; uschar * originator_home = US ""/"" ; size_t sz ; void * reset_point ; struct passwd * pw ; struct stat statbuf ; pid_t passed_qr_pid = ( pid_t ) 0 ; int passed_qr_pipe = - 1 ; gid_t group_list [ NGROUPS_MAX ] ; enum commandline_info info_flag = CMDINFO_NONE ; BOOL info_stdout = FALSE ; static uschar * rsopts [ ] = { US ""f"" , US ""ff"" , US ""r"" , US ""rf"" , US ""rff"" } ; extern char * * environ ; # ifdef EXIM_USERNAME if ( route_finduser ( US EXIM_USERNAME , & pw , & exim_uid ) ) { if ( exim_uid == 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>refusing<S2SV_blank>to<S2SV_blank>run<S2SV_blank>with<S2SV_blank>uid<S2SV_blank>0<S2SV_blank>for<S2SV_blank>\\""%s\\""\\n"" , EXIM_USERNAME ) ; exit ( EXIT_FAILURE ) ; } if ( pw ) exim_gid = pw -> pw_gid ; # ifndef EXIM_GROUPNAME else { fprintf ( stderr , ""exim:<S2SV_blank>ref:name<S2SV_blank>should<S2SV_blank>specify<S2SV_blank>a<S2SV_blank>usercode,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>group.\\n"" ""exim:<S2SV_blank>can\'t<S2SV_blank>let<S2SV_blank>you<S2SV_blank>get<S2SV_blank>away<S2SV_blank>with<S2SV_blank>it<S2SV_blank>unless<S2SV_blank>you<S2SV_blank>also<S2SV_blank>specify<S2SV_blank>a<S2SV_blank>group.\\n"" ) ; exit ( EXIT_FAILURE ) ; } # endif } else { fprintf ( stderr , ""exim:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>uid<S2SV_blank>for<S2SV_blank>user<S2SV_blank>name<S2SV_blank>\\""%s\\""\\n"" , EXIM_USERNAME ) ; exit ( EXIT_FAILURE ) ; } # endif # ifdef EXIM_GROUPNAME if ( ! route_findgroup ( US EXIM_GROUPNAME , & exim_gid ) ) { fprintf ( stderr , ""exim:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>gid<S2SV_blank>for<S2SV_blank>group<S2SV_blank>name<S2SV_blank>\\""%s\\""\\n"" , EXIM_GROUPNAME ) ; exit ( EXIT_FAILURE ) ; } # endif # ifdef CONFIGURE_OWNERNAME if ( ! route_finduser ( US CONFIGURE_OWNERNAME , NULL , & config_uid ) ) { fprintf ( stderr , ""exim:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>uid<S2SV_blank>for<S2SV_blank>user<S2SV_blank>name<S2SV_blank>\\""%s\\""\\n"" , CONFIGURE_OWNERNAME ) ; exit ( EXIT_FAILURE ) ; } # endif system_filter_uid = exim_uid ; # ifdef CONFIGURE_GROUPNAME if ( ! route_findgroup ( US CONFIGURE_GROUPNAME , & config_gid ) ) { fprintf ( stderr , ""exim:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>gid<S2SV_blank>for<S2SV_blank>group<S2SV_blank>name<S2SV_blank>\\""%s\\""\\n"" , CONFIGURE_GROUPNAME ) ; exit ( EXIT_FAILURE ) ; } # endif # ifdef OS_INIT OS_INIT # endif running_in_test_harness = * running_status == '<' && Ustrcmp ( running_status , ""<<<testing>>>"" ) == 0 ; setlocale ( LC_ALL , ""C"" ) ; os_non_restarting_signal ( SIGALRM , sigalrm_handler ) ; if ( ! ( log_buffer = US malloc ( LOG_BUFFER_SIZE ) ) ) { fprintf ( stderr , ""exim:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>store<S2SV_blank>for<S2SV_blank>log<S2SV_blank>buffer\\n"" ) ; exit ( EXIT_FAILURE ) ; } bits_set ( log_selector , log_selector_size , log_default ) ; if ( fstat ( fileno ( stderr ) , & statbuf ) >= 0 ) log_stderr = stderr ; pcre_malloc = function_store_get ; pcre_free = function_dummy_free ; big_buffer = store_malloc ( big_buffer_size ) ; set_process_info ( ""initializing"" ) ; os_restarting_signal ( SIGUSR1 , usr1_handler ) ; signal ( SIGHUP , SIG_IGN ) ; signal ( SIGPIPE , SIG_IGN ) ; # ifdef SA_NOCLDWAIT { struct sigaction act ; act . sa_handler = SIG_DFL ; sigemptyset ( & ( act . sa_mask ) ) ; act . sa_flags = 0 ; sigaction ( SIGCHLD , & act , NULL ) ; } # else signal ( SIGCHLD , SIG_DFL ) ; # endif sighup_argv = argv ; version_init ( ) ; message_id_option [ 0 ] = '-' ; message_id_external = message_id_option + 1 ; message_id_external [ 0 ] = 'E' ; message_id = message_id_external + 1 ; message_id [ 0 ] = 0 ; ( void ) umask ( 0 ) ; regex_ismsgid = regex_must_compile ( US ""^(?:[^\\\\W_]{6}-){2}[^\\\\W_]{2}$"" , FALSE , TRUE ) ; regex_smtp_code = regex_must_compile ( US ""^\\\\d\\\\d\\\\d\\\\s(?:\\\\d\\\\.\\\\d\\\\d?\\\\d?\\\\.\\\\d\\\\d?\\\\d?\\\\s)?"" , FALSE , TRUE ) ; # ifdef WHITELIST_D_MACROS regex_whitelisted_macro = regex_must_compile ( US ""^[A-Za-z0-9_/.-]*$"" , FALSE , TRUE ) ; # endif for ( i = 0 ; i < REGEX_VARS ; i ++ ) regex_vars [ i ] = NULL ; if ( ( namelen == 5 && Ustrcmp ( argv [ 0 ] , ""mailq"" ) == 0 ) || ( namelen > 5 && Ustrncmp ( argv [ 0 ] + namelen - 6 , ""/mailq"" , 6 ) == 0 ) ) { list_queue = TRUE ; receiving_message = FALSE ; called_as = US ""-mailq"" ; } if ( ( namelen == 5 && Ustrcmp ( argv [ 0 ] , ""rmail"" ) == 0 ) || ( namelen > 5 && Ustrncmp ( argv [ 0 ] + namelen - 6 , ""/rmail"" , 6 ) == 0 ) ) { dot_ends = FALSE ; called_as = US ""-rmail"" ; errors_sender_rc = EXIT_SUCCESS ; } if ( ( namelen == 5 && Ustrcmp ( argv [ 0 ] , ""rsmtp"" ) == 0 ) || ( namelen > 5 && Ustrncmp ( argv [ 0 ] + namelen - 6 , ""/rsmtp"" , 6 ) == 0 ) ) { smtp_input = smtp_batched_input = TRUE ; called_as = US ""-rsmtp"" ; } if ( ( namelen == 4 && Ustrcmp ( argv [ 0 ] , ""runq"" ) == 0 ) || ( namelen > 4 && Ustrncmp ( argv [ 0 ] + namelen - 5 , ""/runq"" , 5 ) == 0 ) ) { queue_interval = 0 ; receiving_message = FALSE ; called_as = US ""-runq"" ; } if ( ( namelen == 10 && Ustrcmp ( argv [ 0 ] , ""newaliases"" ) == 0 ) || ( namelen > 10 && Ustrncmp ( argv [ 0 ] + namelen - 11 , ""/newaliases"" , 11 ) == 0 ) ) { bi_option = TRUE ; receiving_message = FALSE ; called_as = US ""-newaliases"" ; } original_euid = geteuid ( ) ; real_uid = getuid ( ) ; real_gid = getgid ( ) ; if ( real_uid == root_uid ) { rv = setgid ( real_gid ) ; if ( rv ) { fprintf ( stderr , ""exim:<S2SV_blank>setgid(%ld)<S2SV_blank>failed:<S2SV_blank>%s\\n"" , ( long int ) real_gid , strerror ( errno ) ) ; exit ( EXIT_FAILURE ) ; } rv = setuid ( real_uid ) ; if ( rv ) { fprintf ( stderr , ""exim:<S2SV_blank>setuid(%ld)<S2SV_blank>failed:<S2SV_blank>%s\\n"" , ( long int ) real_uid , strerror ( errno ) ) ; exit ( EXIT_FAILURE ) ; } } unprivileged = ( real_uid != root_uid && original_euid != root_uid ) ; for ( i = 1 ; i < argc ; i ++ ) { BOOL badarg = FALSE ; uschar * arg = argv [ i ] ; uschar * argrest ; int switchchar ; if ( arg [ 0 ] != '-' ) { recipients_arg = i ; break ; } if ( Ustrcmp ( arg , ""--"" ) == 0 ) { recipients_arg = i + 1 ; break ; } switchchar = arg [ 1 ] ; argrest = arg + 2 ; if ( Ustrncmp ( arg + 1 , ""oe"" , 2 ) == 0 || Ustrncmp ( arg + 1 , ""qR"" , 2 ) == 0 || Ustrncmp ( arg + 1 , ""qS"" , 2 ) == 0 ) { switchchar = arg [ 2 ] ; argrest ++ ; } else if ( Ustrncmp ( arg + 1 , ""qqR"" , 3 ) == 0 || Ustrncmp ( arg + 1 , ""qqS"" , 3 ) == 0 ) { switchchar = arg [ 3 ] ; argrest += 2 ; queue_2stage = TRUE ; } else if ( arg [ 1 ] == 'r' ) switchchar = 'f' ; else if ( Ustrcmp ( arg , ""-ov"" ) == 0 ) { switchchar = 'v' ; argrest ++ ; } else if ( switchchar == '-' ) { if ( Ustrcmp ( argrest , ""help"" ) == 0 ) { usage_wanted = TRUE ; break ; } else if ( Ustrcmp ( argrest , ""version"" ) == 0 ) { switchchar = 'b' ; argrest = US ""V"" ; } } switch ( switchchar ) { case 'A' : if ( * argrest == '\\0' ) { badarg = TRUE ; break ; } else { BOOL ignore = FALSE ; switch ( * argrest ) { case 'c' : case 'm' : if ( * ( argrest + 1 ) == '\\0' ) ignore = TRUE ; break ; } if ( ! ignore ) { badarg = TRUE ; break ; } } break ; case 'B' : if ( * argrest == 0 ) i ++ ; break ; case 'b' : receiving_message = FALSE ; if ( * argrest == 'd' ) { daemon_listen = TRUE ; if ( * ( ++ argrest ) == 'f' ) background_daemon = FALSE ; else if ( * argrest != 0 ) { badarg = TRUE ; break ; } } else if ( * argrest == 'e' ) { expansion_test = checking = TRUE ; if ( argrest [ 1 ] == 'm' ) { if ( ++ i >= argc ) { badarg = TRUE ; break ; } expansion_test_message = argv [ i ] ; argrest ++ ; } if ( argrest [ 1 ] != 0 ) { badarg = TRUE ; break ; } } else if ( * argrest == 'F' ) { filter_test |= checking = FTEST_SYSTEM ; if ( * ( ++ argrest ) != 0 ) { badarg = TRUE ; break ; } if ( ++ i < argc ) filter_test_sfile = argv [ i ] ; else { fprintf ( stderr , ""exim:<S2SV_blank>file<S2SV_blank>name<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>%s\\n"" , argv [ i - 1 ] ) ; exit ( EXIT_FAILURE ) ; } } else if ( * argrest == 'f' ) { if ( * ( ++ argrest ) == 0 ) { filter_test |= checking = FTEST_USER ; if ( ++ i < argc ) filter_test_ufile = argv [ i ] ; else { fprintf ( stderr , ""exim:<S2SV_blank>file<S2SV_blank>name<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>%s\\n"" , argv [ i - 1 ] ) ; exit ( EXIT_FAILURE ) ; } } else { if ( ++ i >= argc ) { fprintf ( stderr , ""exim:<S2SV_blank>string<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>%s\\n"" , arg ) ; exit ( EXIT_FAILURE ) ; } if ( Ustrcmp ( argrest , ""d"" ) == 0 ) ftest_domain = argv [ i ] ; else if ( Ustrcmp ( argrest , ""l"" ) == 0 ) ftest_localpart = argv [ i ] ; else if ( Ustrcmp ( argrest , ""p"" ) == 0 ) ftest_prefix = argv [ i ] ; else if ( Ustrcmp ( argrest , ""s"" ) == 0 ) ftest_suffix = argv [ i ] ; else { badarg = TRUE ; break ; } } } else if ( Ustrcmp ( argrest , ""h"" ) == 0 || Ustrcmp ( argrest , ""hc"" ) == 0 ) { if ( ++ i >= argc ) { badarg = TRUE ; break ; } sender_host_address = argv [ i ] ; host_checking = checking = log_testing_mode = TRUE ; host_checking_callout = argrest [ 1 ] == 'c' ; message_logs = FALSE ; } else if ( Ustrcmp ( argrest , ""i"" ) == 0 ) bi_option = TRUE ; else if ( argrest [ 0 ] == 'I' && Ustrlen ( argrest ) >= 2 && argrest [ 1 ] == ':' ) { uschar * p = & argrest [ 2 ] ; info_flag = CMDINFO_HELP ; if ( Ustrlen ( p ) ) { if ( strcmpic ( p , CUS ""sieve"" ) == 0 ) { info_flag = CMDINFO_SIEVE ; info_stdout = TRUE ; } else if ( strcmpic ( p , CUS ""dscp"" ) == 0 ) { info_flag = CMDINFO_DSCP ; info_stdout = TRUE ; } else if ( strcmpic ( p , CUS ""help"" ) == 0 ) { info_stdout = TRUE ; } } } else if ( Ustrcmp ( argrest , ""m"" ) == 0 ) receiving_message = TRUE ; else if ( Ustrcmp ( argrest , ""malware"" ) == 0 ) { if ( ++ i >= argc ) { badarg = TRUE ; break ; } checking = TRUE ; malware_test_file = argv [ i ] ; } else if ( Ustrcmp ( argrest , ""nq"" ) == 0 ) { allow_unqualified_sender = FALSE ; allow_unqualified_recipient = FALSE ; } else if ( * argrest == 'p' ) { if ( * ( ++ argrest ) == 'c' ) { count_queue = TRUE ; if ( * ( ++ argrest ) != 0 ) badarg = TRUE ; break ; } if ( * argrest == 'r' ) { list_queue_option = 8 ; argrest ++ ; } else list_queue_option = 0 ; list_queue = TRUE ; if ( * argrest == 0 ) { } else if ( Ustrcmp ( argrest , ""u"" ) == 0 ) list_queue_option += 1 ; else if ( Ustrcmp ( argrest , ""a"" ) == 0 ) list_queue_option += 2 ; else { badarg = TRUE ; break ; } } else if ( Ustrcmp ( argrest , ""P"" ) == 0 ) { if ( argv [ i + 1 ] && Ustrcmp ( argv [ i + 1 ] , ""config"" ) == 0 ) { list_config = TRUE ; readconf_save_config ( version_string ) ; } else { list_options = TRUE ; debug_selector |= D_v ; debug_file = stderr ; } } else if ( Ustrcmp ( argrest , ""rt"" ) == 0 ) { checking = TRUE ; test_retry_arg = i + 1 ; goto END_ARG ; } else if ( Ustrcmp ( argrest , ""rw"" ) == 0 ) { checking = TRUE ; test_rewrite_arg = i + 1 ; goto END_ARG ; } else if ( Ustrcmp ( argrest , ""S"" ) == 0 ) smtp_input = smtp_batched_input = receiving_message = TRUE ; else if ( Ustrcmp ( argrest , ""s"" ) == 0 ) smtp_input = receiving_message = TRUE ; else if ( Ustrcmp ( argrest , ""t"" ) == 0 ) address_test_mode = checking = log_testing_mode = TRUE ; else if ( Ustrcmp ( argrest , ""v"" ) == 0 ) verify_address_mode = checking = log_testing_mode = TRUE ; else if ( Ustrcmp ( argrest , ""vs"" ) == 0 ) { verify_address_mode = checking = log_testing_mode = TRUE ; verify_as_sender = TRUE ; } else if ( Ustrcmp ( argrest , ""V"" ) == 0 ) { printf ( ""Exim<S2SV_blank>version<S2SV_blank>%s<S2SV_blank>#%s<S2SV_blank>built<S2SV_blank>%s\\n"" , version_string , version_cnumber , version_date ) ; printf ( ""%s\\n"" , CS version_copyright ) ; version_printed = TRUE ; show_whats_supported ( stdout ) ; log_testing_mode = TRUE ; } else if ( * argrest == 'w' ) { inetd_wait_mode = TRUE ; background_daemon = FALSE ; daemon_listen = TRUE ; if ( * ( ++ argrest ) != '\\0' ) { inetd_wait_timeout = readconf_readtime ( argrest , 0 , FALSE ) ; if ( inetd_wait_timeout <= 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>bad<S2SV_blank>time<S2SV_blank>value<S2SV_blank>%s:<S2SV_blank>abandoned\\n"" , argv [ i ] ) ; exit ( EXIT_FAILURE ) ; } } } else badarg = TRUE ; break ; case 'C' : if ( * argrest == 0 ) { if ( ++ i < argc ) argrest = argv [ i ] ; else { badarg = TRUE ; break ; } } if ( Ustrcmp ( config_main_filelist , argrest ) != 0 ) { # ifdef ALT_CONFIG_PREFIX int sep = 0 ; int len = Ustrlen ( ALT_CONFIG_PREFIX ) ; const uschar * list = argrest ; uschar * filename ; while ( ( filename = string_nextinlist ( & list , & sep , big_buffer , big_buffer_size ) ) != NULL ) { if ( ( Ustrlen ( filename ) < len || Ustrncmp ( filename , ALT_CONFIG_PREFIX , len ) != 0 || Ustrstr ( filename , ""/../"" ) != NULL ) && ( Ustrcmp ( filename , ""/dev/null"" ) != 0 || real_uid != root_uid ) ) { fprintf ( stderr , ""-C<S2SV_blank>Permission<S2SV_blank>denied\\n"" ) ; exit ( EXIT_FAILURE ) ; } } # endif if ( real_uid != root_uid ) { # ifdef TRUSTED_CONFIG_LIST if ( real_uid != exim_uid # ifdef CONFIGURE_OWNER && real_uid != config_uid # endif ) trusted_config = FALSE ; else { FILE * trust_list = Ufopen ( TRUSTED_CONFIG_LIST , ""rb"" ) ; if ( trust_list ) { struct stat statbuf ; if ( fstat ( fileno ( trust_list ) , & statbuf ) != 0 || ( statbuf . st_uid != root_uid # ifdef CONFIGURE_OWNER && statbuf . st_uid != config_uid # endif ) || ( statbuf . st_gid != root_gid # ifdef CONFIGURE_GROUP && statbuf . st_gid != config_gid # endif && ( statbuf . st_mode & 020 ) != 0 ) || ( statbuf . st_mode & 2 ) != 0 ) { trusted_config = FALSE ; fclose ( trust_list ) ; } else { void * reset_point = store_get ( 0 ) ; uschar * trusted_configs [ 32 ] ; int nr_configs = 0 ; int i = 0 ; while ( Ufgets ( big_buffer , big_buffer_size , trust_list ) ) { uschar * start = big_buffer , * nl ; while ( * start && isspace ( * start ) ) start ++ ; if ( * start != '/' ) continue ; nl = Ustrchr ( start , '\\n' ) ; if ( nl ) * nl = 0 ; trusted_configs [ nr_configs ++ ] = string_copy ( start ) ; if ( nr_configs == 32 ) break ; } fclose ( trust_list ) ; if ( nr_configs ) { int sep = 0 ; const uschar * list = argrest ; uschar * filename ; while ( trusted_config && ( filename = string_nextinlist ( & list , & sep , big_buffer , big_buffer_size ) ) != NULL ) { for ( i = 0 ; i < nr_configs ; i ++ ) { if ( Ustrcmp ( filename , trusted_configs [ i ] ) == 0 ) break ; } if ( i == nr_configs ) { trusted_config = FALSE ; break ; } } store_reset ( reset_point ) ; } else { trusted_config = FALSE ; } } } else { trusted_config = FALSE ; } } # else trusted_config = FALSE ; # endif } config_main_filelist = argrest ; config_changed = TRUE ; } break ; case 'D' : # ifdef DISABLE_D_OPTION fprintf ( stderr , ""exim:<S2SV_blank>-D<S2SV_blank>is<S2SV_blank>not<S2SV_blank>available<S2SV_blank>in<S2SV_blank>this<S2SV_blank>Exim<S2SV_blank>binary\\n"" ) ; exit ( EXIT_FAILURE ) ; # else { int ptr = 0 ; macro_item * m ; uschar name [ 24 ] ; uschar * s = argrest ; opt_D_used = TRUE ; while ( isspace ( * s ) ) s ++ ; if ( * s < 'A' || * s > 'Z' ) { fprintf ( stderr , ""exim:<S2SV_blank>macro<S2SV_blank>name<S2SV_blank>set<S2SV_blank>by<S2SV_blank>-D<S2SV_blank>must<S2SV_blank>start<S2SV_blank>with<S2SV_blank>"" ""an<S2SV_blank>upper<S2SV_blank>case<S2SV_blank>letter\\n"" ) ; exit ( EXIT_FAILURE ) ; } while ( isalnum ( * s ) || * s == '_' ) { if ( ptr < sizeof ( name ) - 1 ) name [ ptr ++ ] = * s ; s ++ ; } name [ ptr ] = 0 ; if ( ptr == 0 ) { badarg = TRUE ; break ; } while ( isspace ( * s ) ) s ++ ; if ( * s != 0 ) { if ( * s ++ != '=' ) { badarg = TRUE ; break ; } while ( isspace ( * s ) ) s ++ ; } for ( m = macros ; m ; m = m -> next ) if ( Ustrcmp ( m -> name , name ) == 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>duplicated<S2SV_blank>-D<S2SV_blank>in<S2SV_blank>command<S2SV_blank>line\\n"" ) ; exit ( EXIT_FAILURE ) ; } m = macro_create ( name , s , TRUE , FALSE ) ; if ( clmacro_count >= MAX_CLMACROS ) { fprintf ( stderr , ""exim:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>-D<S2SV_blank>options<S2SV_blank>on<S2SV_blank>command<S2SV_blank>line\\n"" ) ; exit ( EXIT_FAILURE ) ; } clmacros [ clmacro_count ++ ] = string_sprintf ( ""-D%s=%s"" , m -> name , m -> replacement ) ; } # endif break ; case 'd' : if ( Ustrcmp ( argrest , ""ropcr"" ) == 0 ) { } else { unsigned int selector = D_default ; debug_selector = 0 ; debug_file = NULL ; if ( * argrest == 'd' ) { debug_daemon = TRUE ; argrest ++ ; } if ( * argrest != 0 ) decode_bits ( & selector , 1 , debug_notall , argrest , debug_options , debug_options_count , US ""debug"" , 0 ) ; debug_selector = selector ; } break ; case 'E' : local_error_message = TRUE ; if ( mac_ismsgid ( argrest ) ) message_reference = argrest ; break ; case 'e' : if ( Ustrcmp ( argrest , ""e"" ) == 0 ) { arg_error_handling = ERRORS_SENDER ; errors_sender_rc = EXIT_SUCCESS ; } else if ( Ustrcmp ( argrest , ""m"" ) == 0 ) arg_error_handling = ERRORS_SENDER ; else if ( Ustrcmp ( argrest , ""p"" ) == 0 ) arg_error_handling = ERRORS_STDERR ; else if ( Ustrcmp ( argrest , ""q"" ) == 0 ) arg_error_handling = ERRORS_STDERR ; else if ( Ustrcmp ( argrest , ""w"" ) == 0 ) arg_error_handling = ERRORS_SENDER ; else badarg = TRUE ; break ; case 'F' : if ( * argrest == 0 ) { if ( ++ i < argc ) argrest = argv [ i ] ; else { badarg = TRUE ; break ; } } originator_name = argrest ; sender_name_forced = TRUE ; break ; case 'f' : { int dummy_start , dummy_end ; uschar * errmess ; if ( * argrest == 0 ) { if ( i + 1 < argc ) argrest = argv [ ++ i ] ; else { badarg = TRUE ; break ; } } if ( * argrest == 0 ) sender_address = string_sprintf ( """" ) ; else { uschar * temp = argrest + Ustrlen ( argrest ) - 1 ; while ( temp >= argrest && isspace ( * temp ) ) temp -- ; if ( temp >= argrest && * temp == '.' ) f_end_dot = TRUE ; allow_domain_literals = TRUE ; strip_trailing_dot = TRUE ; # ifdef SUPPORT_I18N allow_utf8_domains = TRUE ; # endif sender_address = parse_extract_address ( argrest , & errmess , & dummy_start , & dummy_end , & sender_address_domain , TRUE ) ; # ifdef SUPPORT_I18N message_smtputf8 = string_is_utf8 ( sender_address ) ; allow_utf8_domains = FALSE ; # endif allow_domain_literals = FALSE ; strip_trailing_dot = FALSE ; if ( sender_address == NULL ) { fprintf ( stderr , ""exim:<S2SV_blank>bad<S2SV_blank>-f<S2SV_blank>address<S2SV_blank>\\""%s\\"":<S2SV_blank>%s\\n"" , argrest , errmess ) ; return EXIT_FAILURE ; } } sender_address_forced = TRUE ; } break ; case 'G' : flag_G = TRUE ; break ; case 'h' : if ( * argrest == 0 ) { if ( ++ i < argc ) argrest = argv [ i ] ; else { badarg = TRUE ; break ; } } if ( ! isdigit ( * argrest ) ) badarg = TRUE ; break ; case 'i' : if ( * argrest == 0 ) dot_ends = FALSE ; else badarg = TRUE ; break ; case 'L' : if ( * argrest == '\\0' ) { if ( ++ i < argc ) argrest = argv [ i ] ; else { badarg = TRUE ; break ; } } sz = Ustrlen ( argrest ) ; if ( sz > 32 ) { fprintf ( stderr , ""exim:<S2SV_blank>the<S2SV_blank>-L<S2SV_blank>syslog<S2SV_blank>name<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long:<S2SV_blank>\\""%s\\""\\n"" , argrest ) ; return EXIT_FAILURE ; } if ( sz < 1 ) { fprintf ( stderr , ""exim:<S2SV_blank>the<S2SV_blank>-L<S2SV_blank>syslog<S2SV_blank>name<S2SV_blank>is<S2SV_blank>too<S2SV_blank>short\\n"" ) ; return EXIT_FAILURE ; } cmdline_syslog_name = argrest ; break ; case 'M' : receiving_message = FALSE ; if ( Ustrcmp ( argrest , ""C"" ) == 0 ) { union sockaddr_46 interface_sock ; EXIM_SOCKLEN_T size = sizeof ( interface_sock ) ; if ( argc != i + 6 ) { fprintf ( stderr , ""exim:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>or<S2SV_blank>too<S2SV_blank>few<S2SV_blank>arguments<S2SV_blank>after<S2SV_blank>-MC\\n"" ) ; return EXIT_FAILURE ; } if ( msg_action_arg >= 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>incompatible<S2SV_blank>arguments\\n"" ) ; return EXIT_FAILURE ; } continue_transport = argv [ ++ i ] ; continue_hostname = argv [ ++ i ] ; continue_host_address = argv [ ++ i ] ; continue_sequence = Uatoi ( argv [ ++ i ] ) ; msg_action = MSG_DELIVER ; msg_action_arg = ++ i ; forced_delivery = TRUE ; queue_run_pid = passed_qr_pid ; queue_run_pipe = passed_qr_pipe ; if ( ! mac_ismsgid ( argv [ i ] ) ) { fprintf ( stderr , ""exim:<S2SV_blank>malformed<S2SV_blank>message<S2SV_blank>id<S2SV_blank>%s<S2SV_blank>after<S2SV_blank>-MC<S2SV_blank>option\\n"" , argv [ i ] ) ; return EXIT_FAILURE ; } if ( ! continue_proxy_cipher ) if ( getsockname ( fileno ( stdin ) , ( struct sockaddr * ) ( & interface_sock ) , & size ) == 0 ) sending_ip_address = host_ntoa ( - 1 , & interface_sock , NULL , & sending_port ) ; else { fprintf ( stderr , ""exim:<S2SV_blank>getsockname()<S2SV_blank>failed<S2SV_blank>after<S2SV_blank>-MC<S2SV_blank>option:<S2SV_blank>%s\\n"" , strerror ( errno ) ) ; return EXIT_FAILURE ; } if ( running_in_test_harness ) millisleep ( 500 ) ; break ; } else if ( * argrest == 'C' && argrest [ 1 ] && ! argrest [ 2 ] ) { switch ( argrest [ 1 ] ) { case 'A' : smtp_authenticated = TRUE ; break ; case 'D' : smtp_peer_options |= PEER_OFFERED_DSN ; break ; case 'G' : if ( ++ i < argc ) queue_name = string_copy ( argv [ i ] ) ; else badarg = TRUE ; break ; case 'K' : smtp_peer_options |= PEER_OFFERED_CHUNKING ; break ; case 'P' : smtp_peer_options |= PEER_OFFERED_PIPE ; break ; case 'Q' : if ( ++ i < argc ) passed_qr_pid = ( pid_t ) ( Uatol ( argv [ i ] ) ) ; else badarg = TRUE ; if ( ++ i < argc ) passed_qr_pipe = ( int ) ( Uatol ( argv [ i ] ) ) ; else badarg = TRUE ; break ; case 'S' : smtp_peer_options |= PEER_OFFERED_SIZE ; break ; # ifdef SUPPORT_TLS case 't' : if ( ++ i < argc ) sending_ip_address = argv [ i ] ; else badarg = TRUE ; if ( ++ i < argc ) sending_port = ( int ) ( Uatol ( argv [ i ] ) ) ; else badarg = TRUE ; if ( ++ i < argc ) continue_proxy_cipher = argv [ i ] ; else badarg = TRUE ; case 'T' : smtp_peer_options |= PEER_OFFERED_TLS ; break ; # endif default : badarg = TRUE ; break ; } break ; } else if ( * argrest == 0 ) { msg_action = MSG_DELIVER ; forced_delivery = deliver_force_thaw = TRUE ; } else if ( Ustrcmp ( argrest , ""ar"" ) == 0 ) { msg_action = MSG_ADD_RECIPIENT ; one_msg_action = TRUE ; } else if ( Ustrcmp ( argrest , ""c"" ) == 0 ) msg_action = MSG_DELIVER ; else if ( Ustrcmp ( argrest , ""es"" ) == 0 ) { msg_action = MSG_EDIT_SENDER ; one_msg_action = TRUE ; } else if ( Ustrcmp ( argrest , ""f"" ) == 0 ) msg_action = MSG_FREEZE ; else if ( Ustrcmp ( argrest , ""g"" ) == 0 ) { msg_action = MSG_DELIVER ; deliver_give_up = TRUE ; } else if ( Ustrcmp ( argrest , ""mad"" ) == 0 ) { msg_action = MSG_MARK_ALL_DELIVERED ; } else if ( Ustrcmp ( argrest , ""md"" ) == 0 ) { msg_action = MSG_MARK_DELIVERED ; one_msg_action = TRUE ; } else if ( Ustrcmp ( argrest , ""rm"" ) == 0 ) msg_action = MSG_REMOVE ; else if ( Ustrcmp ( argrest , ""set"" ) == 0 ) { msg_action = MSG_LOAD ; one_msg_action = TRUE ; } else if ( Ustrcmp ( argrest , ""t"" ) == 0 ) msg_action = MSG_THAW ; else if ( Ustrcmp ( argrest , ""vb"" ) == 0 ) { msg_action = MSG_SHOW_BODY ; one_msg_action = TRUE ; } else if ( Ustrcmp ( argrest , ""vc"" ) == 0 ) { msg_action = MSG_SHOW_COPY ; one_msg_action = TRUE ; } else if ( Ustrcmp ( argrest , ""vh"" ) == 0 ) { msg_action = MSG_SHOW_HEADER ; one_msg_action = TRUE ; } else if ( Ustrcmp ( argrest , ""vl"" ) == 0 ) { msg_action = MSG_SHOW_LOG ; one_msg_action = TRUE ; } else { badarg = TRUE ; break ; } msg_action_arg = i + 1 ; if ( msg_action_arg >= argc ) { fprintf ( stderr , ""exim:<S2SV_blank>no<S2SV_blank>message<S2SV_blank>ids<S2SV_blank>given<S2SV_blank>after<S2SV_blank>%s<S2SV_blank>option\\n"" , arg ) ; return EXIT_FAILURE ; } if ( ! one_msg_action ) { int j ; for ( j = msg_action_arg ; j < argc ; j ++ ) if ( ! mac_ismsgid ( argv [ j ] ) ) { fprintf ( stderr , ""exim:<S2SV_blank>malformed<S2SV_blank>message<S2SV_blank>id<S2SV_blank>%s<S2SV_blank>after<S2SV_blank>%s<S2SV_blank>option\\n"" , argv [ j ] , arg ) ; return EXIT_FAILURE ; } goto END_ARG ; } else { if ( ! mac_ismsgid ( argv [ msg_action_arg ] ) ) { fprintf ( stderr , ""exim:<S2SV_blank>malformed<S2SV_blank>message<S2SV_blank>id<S2SV_blank>%s<S2SV_blank>after<S2SV_blank>%s<S2SV_blank>option\\n"" , argv [ msg_action_arg ] , arg ) ; return EXIT_FAILURE ; } i ++ ; } break ; case 'm' : if ( * argrest != 0 ) badarg = TRUE ; break ; case 'N' : if ( * argrest == 0 ) { dont_deliver = TRUE ; debug_selector |= D_v ; debug_file = stderr ; } else badarg = TRUE ; break ; case 'n' : flag_n = TRUE ; break ; case 'O' : if ( * argrest == 0 ) { if ( ++ i >= argc ) { fprintf ( stderr , ""exim:<S2SV_blank>string<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>-O\\n"" ) ; exit ( EXIT_FAILURE ) ; } } break ; case 'o' : if ( * argrest == 'A' ) { alias_arg = argrest + 1 ; if ( alias_arg [ 0 ] == 0 ) { if ( i + 1 < argc ) alias_arg = argv [ ++ i ] ; else { fprintf ( stderr , ""exim:<S2SV_blank>string<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>-oA\\n"" ) ; exit ( EXIT_FAILURE ) ; } } } else if ( * argrest == 'B' ) { uschar * p = argrest + 1 ; if ( p [ 0 ] == 0 ) { if ( i + 1 < argc && isdigit ( ( argv [ i + 1 ] [ 0 ] ) ) ) p = argv [ ++ i ] ; else { connection_max_messages = 1 ; p = NULL ; } } if ( p != NULL ) { if ( ! isdigit ( * p ) ) { fprintf ( stderr , ""exim:<S2SV_blank>number<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>-oB\\n"" ) ; exit ( EXIT_FAILURE ) ; } connection_max_messages = Uatoi ( p ) ; } } else if ( Ustrcmp ( argrest , ""db"" ) == 0 ) { synchronous_delivery = FALSE ; arg_queue_only = FALSE ; queue_only_set = TRUE ; } else if ( Ustrcmp ( argrest , ""df"" ) == 0 || Ustrcmp ( argrest , ""di"" ) == 0 ) { synchronous_delivery = TRUE ; arg_queue_only = FALSE ; queue_only_set = TRUE ; } else if ( Ustrcmp ( argrest , ""dq"" ) == 0 ) { synchronous_delivery = FALSE ; arg_queue_only = TRUE ; queue_only_set = TRUE ; } else if ( Ustrcmp ( argrest , ""dqs"" ) == 0 ) { queue_smtp = TRUE ; arg_queue_only = FALSE ; queue_only_set = TRUE ; } else if ( Ustrcmp ( argrest , ""i"" ) == 0 || Ustrcmp ( argrest , ""itrue"" ) == 0 ) dot_ends = FALSE ; else if ( * argrest == 'M' ) { if ( i + 1 >= argc ) { fprintf ( stderr , ""exim:<S2SV_blank>data<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>-o%s\\n"" , argrest ) ; exit ( EXIT_FAILURE ) ; } if ( Ustrcmp ( argrest , ""Ma"" ) == 0 ) sender_host_address = argv [ ++ i ] ; else if ( Ustrcmp ( argrest , ""Maa"" ) == 0 ) sender_host_authenticated = argv [ ++ i ] ; else if ( Ustrcmp ( argrest , ""Mas"" ) == 0 ) authenticated_sender = argv [ ++ i ] ; else if ( Ustrcmp ( argrest , ""Mai"" ) == 0 ) authenticated_id = argv [ ++ i ] ; else if ( Ustrcmp ( argrest , ""Mi"" ) == 0 ) interface_address = argv [ ++ i ] ; else if ( Ustrcmp ( argrest , ""Mm"" ) == 0 ) { if ( ! mac_ismsgid ( argv [ i + 1 ] ) ) { fprintf ( stderr , ""-oMm<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>message<S2SV_blank>ID\\n"" ) ; exit ( EXIT_FAILURE ) ; } if ( ! trusted_config ) { fprintf ( stderr , ""-oMm<S2SV_blank>must<S2SV_blank>be<S2SV_blank>called<S2SV_blank>by<S2SV_blank>a<S2SV_blank>trusted<S2SV_blank>user/config\\n"" ) ; exit ( EXIT_FAILURE ) ; } message_reference = argv [ ++ i ] ; }  else if ( Ustrcmp ( argrest , ""Mr"" ) == 0 ) received_protocol = argv [ ++ i ] ;  else if ( Ustrcmp ( argrest , ""Ms"" ) == 0 ) sender_host_name = argv [ ++ i ] ; else if ( Ustrcmp ( argrest , ""Mt"" ) == 0 ) { sender_ident_set = TRUE ; sender_ident = argv [ ++ i ] ; } else { badarg = TRUE ; break ; } } else if ( Ustrcmp ( argrest , ""m"" ) == 0 ) { } else if ( Ustrcmp ( argrest , ""o"" ) == 0 ) { } else if ( Ustrcmp ( argrest , ""P"" ) == 0 ) override_pid_file_path = argv [ ++ i ] ; else if ( * argrest == 'r' || * argrest == 's' ) { int * tp = ( * argrest == 'r' ) ? & arg_receive_timeout : & arg_smtp_receive_timeout ; if ( argrest [ 1 ] == 0 ) { if ( i + 1 < argc ) * tp = readconf_readtime ( argv [ ++ i ] , 0 , FALSE ) ; } else * tp = readconf_readtime ( argrest + 1 , 0 , FALSE ) ; if ( * tp < 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>bad<S2SV_blank>time<S2SV_blank>value<S2SV_blank>%s:<S2SV_blank>abandoned\\n"" , argv [ i ] ) ; exit ( EXIT_FAILURE ) ; } } else if ( Ustrcmp ( argrest , ""X"" ) == 0 ) override_local_interfaces = argv [ ++ i ] ; else badarg = TRUE ; break ; case 'p' : # ifdef EXIM_PERL if ( * argrest == 's' && argrest [ 1 ] == 0 ) { perl_start_option = 1 ; break ; } if ( * argrest == 'd' && argrest [ 1 ] == 0 ) { perl_start_option = - 1 ; break ; } # endif if ( * argrest == 0 ) { if ( i + 1 < argc ) argrest = argv [ ++ i ] ; else { badarg = TRUE ; break ; } } if ( * argrest != 0 ) {  uschar * hn = Ustrchr ( argrest , ':' ) ;  if ( hn == NULL ) { received_protocol = argrest ; } else { int old_pool = store_pool ; store_pool = POOL_PERM ; received_protocol = string_copyn ( argrest , hn - argrest ) ; store_pool = old_pool ; sender_host_name = hn + 1 ; } } break ; case 'q' : receiving_message = FALSE ; if ( queue_interval >= 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>-q<S2SV_blank>specified<S2SV_blank>more<S2SV_blank>than<S2SV_blank>once\\n"" ) ; exit ( EXIT_FAILURE ) ; } if ( * argrest == 'q' ) { queue_2stage = TRUE ; argrest ++ ; } if ( * argrest == 'i' ) { queue_run_first_delivery = TRUE ; argrest ++ ; } if ( * argrest == 'f' ) { queue_run_force = TRUE ; if ( * ++ argrest == 'f' ) { deliver_force_thaw = TRUE ; argrest ++ ; } } if ( * argrest == 'l' ) { queue_run_local = TRUE ; argrest ++ ; } if ( * argrest == 'G' ) { int i ; for ( argrest ++ , i = 0 ; argrest [ i ] && argrest [ i ] != '/' ; ) i ++ ; queue_name = string_copyn ( argrest , i ) ; argrest += i ; if ( * argrest == '/' ) argrest ++ ; } if ( * argrest == 0 && ( i + 1 >= argc || argv [ i + 1 ] [ 0 ] == '-' || mac_ismsgid ( argv [ i + 1 ] ) ) ) { queue_interval = 0 ; if ( i + 1 < argc && mac_ismsgid ( argv [ i + 1 ] ) ) start_queue_run_id = argv [ ++ i ] ; if ( i + 1 < argc && mac_ismsgid ( argv [ i + 1 ] ) ) stop_queue_run_id = argv [ ++ i ] ; } else if ( ( queue_interval = readconf_readtime ( * argrest ? argrest : argv [ ++ i ] , 0 , FALSE ) ) <= 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>bad<S2SV_blank>time<S2SV_blank>value<S2SV_blank>%s:<S2SV_blank>abandoned\\n"" , argv [ i ] ) ; exit ( EXIT_FAILURE ) ; } break ; case 'R' : receiving_message = FALSE ; if ( * argrest != 0 ) { int i ; for ( i = 0 ; i < nelem ( rsopts ) ; i ++ ) if ( Ustrcmp ( argrest , rsopts [ i ] ) == 0 ) { if ( i != 2 ) queue_run_force = TRUE ; if ( i >= 2 ) deliver_selectstring_regex = TRUE ; if ( i == 1 || i == 4 ) deliver_force_thaw = TRUE ; argrest += Ustrlen ( rsopts [ i ] ) ; } } if ( * argrest ) deliver_selectstring = argrest ; else if ( i + 1 < argc ) deliver_selectstring = argv [ ++ i ] ; else { fprintf ( stderr , ""exim:<S2SV_blank>string<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>-R\\n"" ) ; exit ( EXIT_FAILURE ) ; } break ; case 'S' : receiving_message = FALSE ; if ( * argrest ) { int i ; for ( i = 0 ; i < nelem ( rsopts ) ; i ++ ) if ( Ustrcmp ( argrest , rsopts [ i ] ) == 0 ) { if ( i != 2 ) queue_run_force = TRUE ; if ( i >= 2 ) deliver_selectstring_sender_regex = TRUE ; if ( i == 1 || i == 4 ) deliver_force_thaw = TRUE ; argrest += Ustrlen ( rsopts [ i ] ) ; } } if ( * argrest ) deliver_selectstring_sender = argrest ; else if ( i + 1 < argc ) deliver_selectstring_sender = argv [ ++ i ] ; else { fprintf ( stderr , ""exim:<S2SV_blank>string<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>-S\\n"" ) ; exit ( EXIT_FAILURE ) ; } break ; case 'T' : if ( running_in_test_harness && Ustrcmp ( argrest , ""qt"" ) == 0 ) fudged_queue_times = argv [ ++ i ] ; else badarg = TRUE ; break ; case 't' : if ( * argrest == 0 ) extract_recipients = TRUE ; else if ( Ustrcmp ( argrest , ""i"" ) == 0 ) { extract_recipients = TRUE ; dot_ends = FALSE ; } # ifdef SUPPORT_TLS else if ( Ustrcmp ( argrest , ""ls-on-connect"" ) == 0 ) tls_in . on_connect = TRUE ; # endif else badarg = TRUE ; break ; case 'U' : break ; case 'v' : if ( * argrest == 0 ) { debug_selector |= D_v ; debug_file = stderr ; } else badarg = TRUE ; break ; case 'x' : if ( * argrest != 0 ) badarg = TRUE ; break ; case 'X' : if ( * argrest == '\\0' ) if ( ++ i >= argc ) { fprintf ( stderr , ""exim:<S2SV_blank>string<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>-X\\n"" ) ; exit ( EXIT_FAILURE ) ; } break ; case 'z' : if ( * argrest == '\\0' ) if ( ++ i < argc ) log_oneline = argv [ i ] ; else { fprintf ( stderr , ""exim:<S2SV_blank>file<S2SV_blank>name<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>%s\\n"" , argv [ i - 1 ] ) ; exit ( EXIT_FAILURE ) ; } break ; default : badarg = TRUE ; break ; } if ( badarg ) { fprintf ( stderr , ""exim<S2SV_blank>abandoned:<S2SV_blank>unknown,<S2SV_blank>malformed,<S2SV_blank>or<S2SV_blank>incomplete<S2SV_blank>"" ""option<S2SV_blank>%s\\n"" , arg ) ; exit ( EXIT_FAILURE ) ; } } if ( ( deliver_selectstring || deliver_selectstring_sender ) && queue_interval < 0 ) queue_interval = 0 ; END_ARG : if ( usage_wanted ) exim_usage ( called_as ) ; if ( ( ( smtp_input || extract_recipients || recipients_arg < argc ) && ( daemon_listen || queue_interval >= 0 || bi_option || test_retry_arg >= 0 || test_rewrite_arg >= 0 || filter_test != FTEST_NONE || ( msg_action_arg > 0 && ! one_msg_action ) ) ) || ( msg_action_arg > 0 && ( daemon_listen || queue_interval > 0 || list_options || ( checking && msg_action != MSG_LOAD ) || bi_option || test_retry_arg >= 0 || test_rewrite_arg >= 0 ) ) || ( ( daemon_listen || queue_interval > 0 ) && ( sender_address != NULL || list_options || list_queue || checking || bi_option ) ) || ( daemon_listen && queue_interval == 0 ) || ( inetd_wait_mode && queue_interval >= 0 ) || ( list_options && ( checking || smtp_input || extract_recipients || filter_test != FTEST_NONE || bi_option ) ) || ( verify_address_mode && ( address_test_mode || smtp_input || extract_recipients || filter_test != FTEST_NONE || bi_option ) ) || ( address_test_mode && ( smtp_input || extract_recipients || filter_test != FTEST_NONE || bi_option ) ) || ( smtp_input && ( sender_address != NULL || filter_test != FTEST_NONE || extract_recipients ) ) || ( deliver_selectstring != NULL && queue_interval < 0 ) || ( msg_action == MSG_LOAD && ( ! expansion_test || expansion_test_message != NULL ) ) ) { fprintf ( stderr , ""exim:<S2SV_blank>incompatible<S2SV_blank>command-line<S2SV_blank>options<S2SV_blank>or<S2SV_blank>arguments\\n"" ) ; exit ( EXIT_FAILURE ) ; } if ( debug_selector != 0 ) { debug_file = stderr ; debug_fd = fileno ( debug_file ) ; background_daemon = FALSE ; if ( running_in_test_harness ) millisleep ( 100 ) ; if ( debug_selector != D_v ) { debug_printf ( ""Exim<S2SV_blank>version<S2SV_blank>%s<S2SV_blank>uid=%ld<S2SV_blank>gid=%ld<S2SV_blank>pid=%d<S2SV_blank>D=%x\\n"" , version_string , ( long int ) real_uid , ( long int ) real_gid , ( int ) getpid ( ) , debug_selector ) ; if ( ! version_printed ) show_whats_supported ( stderr ) ; } } if ( unprivileged ) { DEBUG ( D_any ) debug_print_ids ( US ""Exim<S2SV_blank>has<S2SV_blank>no<S2SV_blank>root<S2SV_blank>privilege:"" ) ; } else { struct rlimit rlp ; # ifdef RLIMIT_NOFILE if ( getrlimit ( RLIMIT_NOFILE , & rlp ) < 0 ) { log_write ( 0 , LOG_MAIN | LOG_PANIC , ""getrlimit(RLIMIT_NOFILE)<S2SV_blank>failed:<S2SV_blank>%s"" , strerror ( errno ) ) ; rlp . rlim_cur = rlp . rlim_max = 0 ; } if ( rlp . rlim_cur < 1000 ) { rlp . rlim_cur = rlp . rlim_max = 1000 ; if ( setrlimit ( RLIMIT_NOFILE , & rlp ) < 0 ) { rlp . rlim_cur = rlp . rlim_max = 256 ; if ( setrlimit ( RLIMIT_NOFILE , & rlp ) < 0 ) log_write ( 0 , LOG_MAIN | LOG_PANIC , ""setrlimit(RLIMIT_NOFILE)<S2SV_blank>failed:<S2SV_blank>%s"" , strerror ( errno ) ) ; } } # endif # ifdef RLIMIT_NPROC if ( getrlimit ( RLIMIT_NPROC , & rlp ) < 0 ) { log_write ( 0 , LOG_MAIN | LOG_PANIC , ""getrlimit(RLIMIT_NPROC)<S2SV_blank>failed:<S2SV_blank>%s"" , strerror ( errno ) ) ; rlp . rlim_cur = rlp . rlim_max = 0 ; } # ifdef RLIM_INFINITY if ( rlp . rlim_cur != RLIM_INFINITY && rlp . rlim_cur < 1000 ) { rlp . rlim_cur = rlp . rlim_max = RLIM_INFINITY ; # else if ( rlp . rlim_cur < 1000 ) { rlp . rlim_cur = rlp . rlim_max = 1000 ; # endif if ( setrlimit ( RLIMIT_NPROC , & rlp ) < 0 ) log_write ( 0 , LOG_MAIN | LOG_PANIC , ""setrlimit(RLIMIT_NPROC)<S2SV_blank>failed:<S2SV_blank>%s"" , strerror ( errno ) ) ; } # endif } group_count = getgroups ( NGROUPS_MAX , group_list ) ; if ( group_count < 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>getgroups()<S2SV_blank>failed:<S2SV_blank>%s\\n"" , strerror ( errno ) ) ; exit ( EXIT_FAILURE ) ; } if ( setgroups ( 0 , NULL ) != 0 ) { if ( setgroups ( 1 , group_list ) != 0 && ! unprivileged ) { fprintf ( stderr , ""exim:<S2SV_blank>setgroups()<S2SV_blank>failed:<S2SV_blank>%s\\n"" , strerror ( errno ) ) ; exit ( EXIT_FAILURE ) ; } } if ( ( ( ! trusted_config || ! macros_trusted ( opt_D_used ) ) && real_uid != root_uid && ! running_in_test_harness ) || expansion_test || filter_test != FTEST_NONE ) { setgroups ( group_count , group_list ) ; exim_setugid ( real_uid , real_gid , FALSE , US ""-C,<S2SV_blank>-D,<S2SV_blank>-be<S2SV_blank>or<S2SV_blank>-bf<S2SV_blank>forces<S2SV_blank>real<S2SV_blank>uid"" ) ; removed_privilege = TRUE ; if ( ( log_stderr != NULL ) && ( real_uid != exim_uid ) ) really_exim = FALSE ; } else exim_setugid ( geteuid ( ) , getegid ( ) , FALSE , US ""forcing<S2SV_blank>real<S2SV_blank>=<S2SV_blank>effective"" ) ; if ( ( filter_test & FTEST_SYSTEM ) != 0 ) { filter_sfd = Uopen ( filter_test_sfile , O_RDONLY , 0 ) ; if ( filter_sfd < 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s:<S2SV_blank>%s\\n"" , filter_test_sfile , strerror ( errno ) ) ; return EXIT_FAILURE ; } } if ( ( filter_test & FTEST_USER ) != 0 ) { filter_ufd = Uopen ( filter_test_ufile , O_RDONLY , 0 ) ; if ( filter_ufd < 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s:<S2SV_blank>%s\\n"" , filter_test_ufile , strerror ( errno ) ) ; return EXIT_FAILURE ; } } init_lookup_list ( ) ; # ifdef SUPPORT_I18N if ( running_in_test_harness ) smtputf8_advertise_hosts = NULL ; # endif if ( ( initial_cwd = os_getcwd ( NULL , 0 ) ) == NULL ) { perror ( ""exim:<S2SV_blank>can\'t<S2SV_blank>get<S2SV_blank>the<S2SV_blank>current<S2SV_blank>working<S2SV_blank>directory"" ) ; exit ( EXIT_FAILURE ) ; } readconf_main ( checking || list_options ) ; if ( builtin_macros_create_trigger ) DEBUG ( D_any ) debug_printf ( ""Builtin<S2SV_blank>macros<S2SV_blank>created<S2SV_blank>(expensive)<S2SV_blank>due<S2SV_blank>to<S2SV_blank>config<S2SV_blank>line<S2SV_blank>\'%.*s\'\\n"" , Ustrlen ( builtin_macros_create_trigger ) - 1 , builtin_macros_create_trigger ) ; if ( cleanup_environment ( ) == FALSE ) log_write ( 0 , LOG_PANIC_DIE , ""Can\'t<S2SV_blank>cleanup<S2SV_blank>environment"" ) ; if ( real_uid == root_uid || real_uid == exim_uid || real_gid == exim_gid ) admin_user = TRUE ; else { int i , j ; for ( i = 0 ; i < group_count && ! admin_user ; i ++ ) if ( group_list [ i ] == exim_gid ) admin_user = TRUE ; else if ( admin_groups ) for ( j = 1 ; j <= ( int ) admin_groups [ 0 ] && ! admin_user ; j ++ ) if ( admin_groups [ j ] == group_list [ i ] ) admin_user = TRUE ; } if ( real_uid == root_uid || real_uid == exim_uid ) trusted_caller = TRUE ; else { int i , j ; if ( trusted_users ) for ( i = 1 ; i <= ( int ) trusted_users [ 0 ] && ! trusted_caller ; i ++ ) if ( trusted_users [ i ] == real_uid ) trusted_caller = TRUE ; if ( trusted_groups ) for ( i = 1 ; i <= ( int ) trusted_groups [ 0 ] && ! trusted_caller ; i ++ ) if ( trusted_groups [ i ] == real_gid ) trusted_caller = TRUE ; else for ( j = 0 ; j < group_count && ! trusted_caller ; j ++ ) if ( trusted_groups [ i ] == group_list [ j ] ) trusted_caller = TRUE ; } if ( checking && commandline_checks_require_admin && ! admin_user ) { fprintf ( stderr , ""exim:<S2SV_blank>those<S2SV_blank>command-line<S2SV_blank>flags<S2SV_blank>are<S2SV_blank>set<S2SV_blank>to<S2SV_blank>require<S2SV_blank>admin\\n"" ) ; exit ( EXIT_FAILURE ) ; } decode_bits ( log_selector , log_selector_size , log_notall , log_selector_string , log_options , log_options_count , US ""log"" , 0 ) ; DEBUG ( D_any ) { int i ; debug_printf ( ""configuration<S2SV_blank>file<S2SV_blank>is<S2SV_blank>%s\\n"" , config_main_filename ) ; debug_printf ( ""log<S2SV_blank>selectors<S2SV_blank>="" ) ; for ( i = 0 ; i < log_selector_size ; i ++ ) debug_printf ( ""<S2SV_blank>%08x"" , log_selector [ i ] ) ; debug_printf ( ""\\n"" ) ; } if ( sender_address != NULL ) { if ( sender_address [ sender_address_domain ] == '[' && ! allow_domain_literals ) { fprintf ( stderr , ""exim:<S2SV_blank>bad<S2SV_blank>-f<S2SV_blank>address<S2SV_blank>\\""%s\\"":<S2SV_blank>domain<S2SV_blank>literals<S2SV_blank>not<S2SV_blank>"" ""allowed\\n"" , sender_address ) ; return EXIT_FAILURE ; } if ( f_end_dot && ! strip_trailing_dot ) { fprintf ( stderr , ""exim:<S2SV_blank>bad<S2SV_blank>-f<S2SV_blank>address<S2SV_blank>\\""%s.\\"":<S2SV_blank>domain<S2SV_blank>is<S2SV_blank>malformed<S2SV_blank>"" ""(trailing<S2SV_blank>dot<S2SV_blank>not<S2SV_blank>allowed)\\n"" , sender_address ) ; return EXIT_FAILURE ; } } if ( cmdline_syslog_name != NULL ) { if ( admin_user ) { syslog_processname = cmdline_syslog_name ; log_file_path = string_copy ( CUS ""syslog"" ) ; } else { fprintf ( stderr , ""exim:<S2SV_blank>you<S2SV_blank>lack<S2SV_blank>sufficient<S2SV_blank>privilege<S2SV_blank>to<S2SV_blank>specify<S2SV_blank>syslog<S2SV_blank>process<S2SV_blank>name\\n"" ) ; return EXIT_FAILURE ; } } if ( Ustrlen ( log_file_path ) > 200 ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , ""log_file_path<S2SV_blank>is<S2SV_blank>longer<S2SV_blank>than<S2SV_blank>200<S2SV_blank>chars:<S2SV_blank>aborting"" ) ; if ( Ustrlen ( pid_file_path ) > 200 ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , ""pid_file_path<S2SV_blank>is<S2SV_blank>longer<S2SV_blank>than<S2SV_blank>200<S2SV_blank>chars:<S2SV_blank>aborting"" ) ; if ( Ustrlen ( spool_directory ) > 200 ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , ""spool_directory<S2SV_blank>is<S2SV_blank>longer<S2SV_blank>than<S2SV_blank>200<S2SV_blank>chars:<S2SV_blank>aborting"" ) ; if ( Ustrlen ( syslog_processname ) > 32 ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , ""syslog_processname<S2SV_blank>is<S2SV_blank>longer<S2SV_blank>than<S2SV_blank>32<S2SV_blank>chars:<S2SV_blank>aborting"" ) ; if ( log_oneline ) if ( admin_user ) { log_write ( 0 , LOG_MAIN , ""%s"" , log_oneline ) ; return EXIT_SUCCESS ; } else return EXIT_FAILURE ; # ifdef EXIM_TMPDIR { uschar * * p ; if ( environ ) for ( p = USS environ ; * p ; p ++ ) if ( Ustrncmp ( * p , ""TMPDIR="" , 7 ) == 0 && Ustrcmp ( * p + 7 , EXIM_TMPDIR ) != 0 ) { uschar * newp = store_malloc ( Ustrlen ( EXIM_TMPDIR ) + 8 ) ; sprintf ( CS newp , ""TMPDIR=%s"" , EXIM_TMPDIR ) ; * p = newp ; DEBUG ( D_any ) debug_printf ( ""reset<S2SV_blank>TMPDIR=%s<S2SV_blank>in<S2SV_blank>environment\\n"" , EXIM_TMPDIR ) ; } } # endif if ( timezone_string && strcmpic ( timezone_string , US ""UTC"" ) == 0 ) timestamps_utc = TRUE ; else { uschar * envtz = US getenv ( ""TZ"" ) ; if ( envtz ? ! timezone_string || Ustrcmp ( timezone_string , envtz ) != 0 : timezone_string != NULL ) { uschar * * p = USS environ ; uschar * * new ; uschar * * newp ; int count = 0 ; if ( environ ) while ( * p ++ ) count ++ ; if ( ! envtz ) count ++ ; newp = new = store_malloc ( sizeof ( uschar * ) * ( count + 1 ) ) ; if ( environ ) for ( p = USS environ ; * p ; p ++ ) if ( Ustrncmp ( * p , ""TZ="" , 3 ) != 0 ) * newp ++ = * p ; if ( timezone_string ) { * newp = store_malloc ( Ustrlen ( timezone_string ) + 4 ) ; sprintf ( CS * newp ++ , ""TZ=%s"" , timezone_string ) ; } * newp = NULL ; environ = CSS new ; tzset ( ) ; DEBUG ( D_any ) debug_printf ( ""Reset<S2SV_blank>TZ<S2SV_blank>to<S2SV_blank>%s:<S2SV_blank>time<S2SV_blank>is<S2SV_blank>%s\\n"" , timezone_string , tod_stamp ( tod_log ) ) ; } } if ( removed_privilege && ( ! trusted_config || opt_D_used ) && real_uid == exim_uid ) if ( deliver_drop_privilege ) really_exim = TRUE ; else log_write ( 0 , LOG_MAIN | LOG_PANIC , ""exim<S2SV_blank>user<S2SV_blank>lost<S2SV_blank>privilege<S2SV_blank>for<S2SV_blank>using<S2SV_blank>%s<S2SV_blank>option"" , trusted_config ? ""-D"" : ""-C"" ) ; # ifdef EXIM_PERL if ( perl_start_option != 0 ) opt_perl_at_start = ( perl_start_option > 0 ) ; if ( opt_perl_at_start && opt_perl_startup != NULL ) { uschar * errstr ; DEBUG ( D_any ) debug_printf ( ""Starting<S2SV_blank>Perl<S2SV_blank>interpreter\\n"" ) ; errstr = init_perl ( opt_perl_startup ) ; if ( errstr != NULL ) { fprintf ( stderr , ""exim:<S2SV_blank>error<S2SV_blank>in<S2SV_blank>perl_startup<S2SV_blank>code:<S2SV_blank>%s\\n"" , errstr ) ; return EXIT_FAILURE ; } opt_perl_started = TRUE ; } # endif if ( ( ( debug_selector & D_any ) != 0 || LOGGING ( arguments ) ) && really_exim && ! list_options && ! checking ) { int i ; uschar * p = big_buffer ; Ustrcpy ( p , ""cwd=<S2SV_blank>(failed)"" ) ; Ustrncpy ( p + 4 , initial_cwd , big_buffer_size - 5 ) ; while ( * p ) p ++ ; ( void ) string_format ( p , big_buffer_size - ( p - big_buffer ) , ""<S2SV_blank>%d<S2SV_blank>args:"" , argc ) ; while ( * p ) p ++ ; for ( i = 0 ; i < argc ; i ++ ) { int len = Ustrlen ( argv [ i ] ) ; const uschar * printing ; uschar * quote ; if ( p + len + 8 >= big_buffer + big_buffer_size ) { Ustrcpy ( p , ""<S2SV_blank>..."" ) ; log_write ( 0 , LOG_MAIN , ""%s"" , big_buffer ) ; Ustrcpy ( big_buffer , ""..."" ) ; p = big_buffer + 3 ; } printing = string_printing ( argv [ i ] ) ; if ( printing [ 0 ] == 0 ) quote = US ""\\"""" ; else { const uschar * pp = printing ; quote = US """" ; while ( * pp != 0 ) if ( isspace ( * pp ++ ) ) { quote = US ""\\"""" ; break ; } } sprintf ( CS p , ""<S2SV_blank>%s%.*s%s"" , quote , ( int ) ( big_buffer_size - ( p - big_buffer ) - 4 ) , printing , quote ) ; while ( * p ) p ++ ; } if ( LOGGING ( arguments ) ) log_write ( 0 , LOG_MAIN , ""%s"" , big_buffer ) ; else debug_printf ( ""%s\\n"" , big_buffer ) ; } if ( Uchdir ( spool_directory ) != 0 ) { int dummy ; ( void ) directory_make ( spool_directory , US """" , SPOOL_DIRECTORY_MODE , FALSE ) ; dummy = Uchdir ( spool_directory ) ; } if ( bi_option ) { ( void ) fclose ( config_file ) ; if ( bi_command != NULL ) { int i = 0 ; uschar * argv [ 3 ] ; argv [ i ++ ] = bi_command ; if ( alias_arg != NULL ) argv [ i ++ ] = alias_arg ; argv [ i ++ ] = NULL ; setgroups ( group_count , group_list ) ; exim_setugid ( real_uid , real_gid , FALSE , US ""running<S2SV_blank>bi_command"" ) ; DEBUG ( D_exec ) debug_printf ( ""exec<S2SV_blank>%.256s<S2SV_blank>%.256s\\n"" , argv [ 0 ] , ( argv [ 1 ] == NULL ) ? US """" : argv [ 1 ] ) ; execv ( CS argv [ 0 ] , ( char * const * ) argv ) ; fprintf ( stderr , ""exim:<S2SV_blank>exec<S2SV_blank>failed:<S2SV_blank>%s\\n"" , strerror ( errno ) ) ; exit ( EXIT_FAILURE ) ; } else { DEBUG ( D_any ) debug_printf ( ""-bi<S2SV_blank>used<S2SV_blank>but<S2SV_blank>bi_command<S2SV_blank>not<S2SV_blank>set;<S2SV_blank>exiting\\n"" ) ; exit ( EXIT_SUCCESS ) ; } } if ( trusted_caller ) DEBUG ( D_any ) debug_printf ( ""trusted<S2SV_blank>user\\n"" ) ; if ( admin_user ) DEBUG ( D_any ) debug_printf ( ""admin<S2SV_blank>user\\n"" ) ; if ( ! admin_user ) { BOOL debugset = ( debug_selector & ~ D_v ) != 0 ; if ( deliver_give_up || daemon_listen || malware_test_file || ( count_queue && queue_list_requires_admin ) || ( list_queue && queue_list_requires_admin ) || ( queue_interval >= 0 && prod_requires_admin ) || ( debugset && ! running_in_test_harness ) ) { fprintf ( stderr , ""exim:%s<S2SV_blank>permission<S2SV_blank>denied\\n"" , debugset ? ""<S2SV_blank>debugging"" : """" ) ; exit ( EXIT_FAILURE ) ; } } if ( real_uid != root_uid && real_uid != exim_uid && ( continue_hostname != NULL || ( dont_deliver && ( queue_interval >= 0 || daemon_listen || msg_action_arg > 0 ) ) ) && ! running_in_test_harness ) { fprintf ( stderr , ""exim:<S2SV_blank>Permission<S2SV_blank>denied\\n"" ) ; return EXIT_FAILURE ; } if ( ! trusted_caller && ! checking ) { sender_host_name = sender_host_address = interface_address = sender_ident = received_protocol = NULL ; sender_host_port = interface_port = 0 ; sender_host_authenticated = authenticated_sender = authenticated_id = NULL ; } else { if ( sender_host_address != NULL ) sender_host_port = check_port ( sender_host_address ) ; if ( interface_address != NULL ) interface_port = check_port ( interface_address ) ; } if ( flag_G ) { if ( trusted_caller ) { suppress_local_fixups = suppress_local_fixups_default = TRUE ; DEBUG ( D_acl ) debug_printf ( ""suppress_local_fixups<S2SV_blank>forced<S2SV_blank>on<S2SV_blank>by<S2SV_blank>-G\\n"" ) ; } else { fprintf ( stderr , ""exim:<S2SV_blank>permission<S2SV_blank>denied<S2SV_blank>(-G<S2SV_blank>requires<S2SV_blank>a<S2SV_blank>trusted<S2SV_blank>user)\\n"" ) ; return EXIT_FAILURE ; } } if ( smtp_input ) { union sockaddr_46 inetd_sock ; EXIM_SOCKLEN_T size = sizeof ( inetd_sock ) ; if ( getpeername ( 0 , ( struct sockaddr * ) ( & inetd_sock ) , & size ) == 0 ) { int family = ( ( struct sockaddr * ) ( & inetd_sock ) ) -> sa_family ; if ( family == AF_INET || family == AF_INET6 ) { union sockaddr_46 interface_sock ; size = sizeof ( interface_sock ) ; if ( getsockname ( 0 , ( struct sockaddr * ) ( & interface_sock ) , & size ) == 0 ) interface_address = host_ntoa ( - 1 , & interface_sock , NULL , & interface_port ) ; if ( host_is_tls_on_connect_port ( interface_port ) ) tls_in . on_connect = TRUE ; if ( real_uid == root_uid || real_uid == exim_uid || interface_port < 1024 ) { is_inetd = TRUE ; sender_host_address = host_ntoa ( - 1 , ( struct sockaddr * ) ( & inetd_sock ) , NULL , & sender_host_port ) ; if ( mua_wrapper ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , ""Input<S2SV_blank>from<S2SV_blank>"" ""inetd<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>when<S2SV_blank>mua_wrapper<S2SV_blank>is<S2SV_blank>set"" ) ; } else { fprintf ( stderr , ""exim:<S2SV_blank>Permission<S2SV_blank>denied<S2SV_blank>(unprivileged<S2SV_blank>user,<S2SV_blank>unprivileged<S2SV_blank>port)\\n"" ) ; return EXIT_FAILURE ; } } } } # ifdef LOAD_AVG_NEEDS_ROOT if ( receiving_message && ( queue_only_load >= 0 || ( is_inetd && smtp_load_reserve >= 0 ) ) ) { load_average = OS_GETLOADAVG ( ) ; } # endif if ( queue_only_set && ( queue_only_override || arg_queue_only ) ) queue_only = arg_queue_only ; if ( arg_receive_timeout >= 0 ) receive_timeout = arg_receive_timeout ; if ( arg_smtp_receive_timeout >= 0 ) smtp_receive_timeout = arg_smtp_receive_timeout ; if ( ! unprivileged && ! removed_privilege && ! daemon_listen && queue_interval <= 0 && ( deliver_drop_privilege || ( queue_interval < 0 && ( msg_action_arg < 0 || msg_action != MSG_DELIVER ) && ( ! checking || ! address_test_mode ) ) ) ) exim_setugid ( exim_uid , exim_gid , TRUE , US ""privilege<S2SV_blank>not<S2SV_blank>needed"" ) ; else { int rv ; rv = setgid ( exim_gid ) ; if ( rv == - 1 ) if ( ! ( unprivileged || removed_privilege ) ) { fprintf ( stderr , ""exim:<S2SV_blank>changing<S2SV_blank>group<S2SV_blank>failed:<S2SV_blank>%s\\n"" , strerror ( errno ) ) ; exit ( EXIT_FAILURE ) ; } else DEBUG ( D_any ) debug_printf ( ""changing<S2SV_blank>group<S2SV_blank>to<S2SV_blank>%ld<S2SV_blank>failed:<S2SV_blank>%s\\n"" , ( long int ) exim_gid , strerror ( errno ) ) ; } if ( malware_test_file ) { # ifdef WITH_CONTENT_SCAN int result ; set_process_info ( ""scanning<S2SV_blank>file<S2SV_blank>for<S2SV_blank>malware"" ) ; result = malware_in_file ( malware_test_file ) ; if ( result == FAIL ) { printf ( ""No<S2SV_blank>malware<S2SV_blank>found.\\n"" ) ; exit ( EXIT_SUCCESS ) ; } if ( result != OK ) { printf ( ""Malware<S2SV_blank>lookup<S2SV_blank>returned<S2SV_blank>non-okay/fail:<S2SV_blank>%d\\n"" , result ) ; exit ( EXIT_FAILURE ) ; } if ( malware_name ) printf ( ""Malware<S2SV_blank>found:<S2SV_blank>%s\\n"" , malware_name ) ; else printf ( ""Malware<S2SV_blank>scan<S2SV_blank>detected<S2SV_blank>malware<S2SV_blank>of<S2SV_blank>unknown<S2SV_blank>name.\\n"" ) ; # else printf ( ""Malware<S2SV_blank>scanning<S2SV_blank>not<S2SV_blank>enabled<S2SV_blank>at<S2SV_blank>compile<S2SV_blank>time.\\n"" ) ; # endif exit ( EXIT_FAILURE ) ; } if ( list_queue ) { set_process_info ( ""listing<S2SV_blank>the<S2SV_blank>queue"" ) ; queue_list ( list_queue_option , argv + recipients_arg , argc - recipients_arg ) ; exit ( EXIT_SUCCESS ) ; } if ( count_queue ) { set_process_info ( ""counting<S2SV_blank>the<S2SV_blank>queue"" ) ; queue_count ( ) ; exit ( EXIT_SUCCESS ) ; } if ( msg_action_arg > 0 && msg_action != MSG_DELIVER && msg_action != MSG_LOAD ) { int yield = EXIT_SUCCESS ; set_process_info ( ""acting<S2SV_blank>on<S2SV_blank>specified<S2SV_blank>messages"" ) ; if ( ! one_msg_action ) { for ( i = msg_action_arg ; i < argc ; i ++ ) if ( ! queue_action ( argv [ i ] , msg_action , NULL , 0 , 0 ) ) yield = EXIT_FAILURE ; } else if ( ! queue_action ( argv [ msg_action_arg ] , msg_action , argv , argc , recipients_arg ) ) yield = EXIT_FAILURE ; exit ( yield ) ; } readconf_rest ( ) ; store_pool = POOL_MAIN ; if ( test_retry_arg >= 0 ) { retry_config * yield ; int basic_errno = 0 ; int more_errno = 0 ; uschar * s1 , * s2 ; if ( test_retry_arg >= argc ) { printf ( ""-brt<S2SV_blank>needs<S2SV_blank>a<S2SV_blank>domain<S2SV_blank>or<S2SV_blank>address<S2SV_blank>argument\\n"" ) ; exim_exit ( EXIT_FAILURE ) ; } s1 = argv [ test_retry_arg ++ ] ; s2 = NULL ; if ( Ustrchr ( s1 , '@' ) == NULL && Ustrchr ( s1 , '.' ) == NULL ) { printf ( ""Warning:<S2SV_blank>\\""%s\\""<S2SV_blank>contains<S2SV_blank>no<S2SV_blank>\'@\'<S2SV_blank>and<S2SV_blank>no<S2SV_blank>\'.\'<S2SV_blank>characters.<S2SV_blank>It<S2SV_blank>is<S2SV_blank>"" ""being<S2SV_blank>\\ntreated<S2SV_blank>as<S2SV_blank>a<S2SV_blank>one-component<S2SV_blank>domain,<S2SV_blank>not<S2SV_blank>as<S2SV_blank>a<S2SV_blank>local<S2SV_blank>part.\\n\\n"" , s1 ) ; } if ( test_retry_arg < argc && Ustrchr ( argv [ test_retry_arg ] , '.' ) != NULL ) s2 = argv [ test_retry_arg ++ ] ; if ( test_retry_arg < argc ) { uschar * ss = argv [ test_retry_arg ] ; uschar * error = readconf_retry_error ( ss , ss + Ustrlen ( ss ) , & basic_errno , & more_errno ) ; if ( error != NULL ) { printf ( ""%s\\n"" , CS error ) ; return EXIT_FAILURE ; } if ( basic_errno == ERRNO_MAIL4XX || basic_errno == ERRNO_RCPT4XX || basic_errno == ERRNO_DATA4XX ) { int code = ( more_errno >> 8 ) & 255 ; if ( code == 255 ) more_errno = ( more_errno & 0xffff00ff ) | ( 21 << 8 ) ; else if ( code > 100 ) more_errno = ( more_errno & 0xffff00ff ) | ( ( code - 96 ) << 8 ) ; } } yield = retry_find_config ( s1 , s2 , basic_errno , more_errno ) ; if ( yield == NULL ) printf ( ""No<S2SV_blank>retry<S2SV_blank>information<S2SV_blank>found\\n"" ) ; else { retry_rule * r ; more_errno = yield -> more_errno ; printf ( ""Retry<S2SV_blank>rule:<S2SV_blank>%s<S2SV_blank><S2SV_blank>"" , yield -> pattern ) ; if ( yield -> basic_errno == ERRNO_EXIMQUOTA ) { printf ( ""quota%s%s<S2SV_blank><S2SV_blank>"" , ( more_errno > 0 ) ? ""_"" : """" , ( more_errno > 0 ) ? readconf_printtime ( more_errno ) : US """" ) ; } else if ( yield -> basic_errno == ECONNREFUSED ) { printf ( ""refused%s%s<S2SV_blank><S2SV_blank>"" , ( more_errno > 0 ) ? ""_"" : """" , ( more_errno == 'M' ) ? ""MX"" : ( more_errno == 'A' ) ? ""A"" : """" ) ; } else if ( yield -> basic_errno == ETIMEDOUT ) { printf ( ""timeout"" ) ; if ( ( more_errno & RTEF_CTOUT ) != 0 ) printf ( ""_connect"" ) ; more_errno &= 255 ; if ( more_errno != 0 ) printf ( ""_%s"" , ( more_errno == 'M' ) ? ""MX"" : ""A"" ) ; printf ( ""<S2SV_blank><S2SV_blank>"" ) ; } else if ( yield -> basic_errno == ERRNO_AUTHFAIL ) printf ( ""auth_failed<S2SV_blank><S2SV_blank>"" ) ; else printf ( ""*<S2SV_blank><S2SV_blank>"" ) ; for ( r = yield -> rules ; r != NULL ; r = r -> next ) { printf ( ""%c,%s"" , r -> rule , readconf_printtime ( r -> timeout ) ) ; printf ( "",%s"" , readconf_printtime ( r -> p1 ) ) ; if ( r -> rule == 'G' ) { int x = r -> p2 ; int f = x % 1000 ; int d = 100 ; printf ( "",%d."" , x / 1000 ) ; do { printf ( ""%d"" , f / d ) ; f %= d ; d /= 10 ; } while ( f != 0 ) ; } printf ( "";<S2SV_blank>"" ) ; } printf ( ""\\n"" ) ; } exim_exit ( EXIT_SUCCESS ) ; } if ( list_options ) { set_process_info ( ""listing<S2SV_blank>variables"" ) ; if ( recipients_arg >= argc ) readconf_print ( US ""all"" , NULL , flag_n ) ; else for ( i = recipients_arg ; i < argc ; i ++ ) { if ( i < argc - 1 && ( Ustrcmp ( argv [ i ] , ""router"" ) == 0 || Ustrcmp ( argv [ i ] , ""transport"" ) == 0 || Ustrcmp ( argv [ i ] , ""authenticator"" ) == 0 || Ustrcmp ( argv [ i ] , ""macro"" ) == 0 || Ustrcmp ( argv [ i ] , ""environment"" ) == 0 ) ) { readconf_print ( argv [ i + 1 ] , argv [ i ] , flag_n ) ; i ++ ; } else readconf_print ( argv [ i ] , NULL , flag_n ) ; } exim_exit ( EXIT_SUCCESS ) ; } if ( list_config ) { set_process_info ( ""listing<S2SV_blank>config"" ) ; readconf_print ( US ""config"" , NULL , flag_n ) ; exim_exit ( EXIT_SUCCESS ) ; } # ifndef DISABLE_DKIM dkim_exim_init ( ) ; # endif deliver_init ( ) ; if ( msg_action_arg > 0 && msg_action != MSG_LOAD ) { if ( prod_requires_admin && ! admin_user ) { fprintf ( stderr , ""exim:<S2SV_blank>Permission<S2SV_blank>denied\\n"" ) ; exim_exit ( EXIT_FAILURE ) ; } set_process_info ( ""delivering<S2SV_blank>specified<S2SV_blank>messages"" ) ; if ( deliver_give_up ) forced_delivery = deliver_force_thaw = TRUE ; for ( i = msg_action_arg ; i < argc ; i ++ ) { int status ; pid_t pid ; if ( i == argc - 1 ) ( void ) deliver_message ( argv [ i ] , forced_delivery , deliver_give_up ) ; else if ( ( pid = fork ( ) ) == 0 ) { ( void ) deliver_message ( argv [ i ] , forced_delivery , deliver_give_up ) ; _exit ( EXIT_SUCCESS ) ; } else if ( pid < 0 ) { fprintf ( stderr , ""failed<S2SV_blank>to<S2SV_blank>fork<S2SV_blank>delivery<S2SV_blank>process<S2SV_blank>for<S2SV_blank>%s:<S2SV_blank>%s\\n"" , argv [ i ] , strerror ( errno ) ) ; exim_exit ( EXIT_FAILURE ) ; } else wait ( & status ) ; } exim_exit ( EXIT_SUCCESS ) ; } if ( queue_interval == 0 && ! daemon_listen ) { DEBUG ( D_queue_run ) debug_printf ( ""Single<S2SV_blank>queue<S2SV_blank>run%s%s%s%s\\n"" , ( start_queue_run_id == NULL ) ? US """" : US ""<S2SV_blank>starting<S2SV_blank>at<S2SV_blank>"" , ( start_queue_run_id == NULL ) ? US """" : start_queue_run_id , ( stop_queue_run_id == NULL ) ? US """" : US ""<S2SV_blank>stopping<S2SV_blank>at<S2SV_blank>"" , ( stop_queue_run_id == NULL ) ? US """" : stop_queue_run_id ) ; if ( * queue_name ) set_process_info ( ""running<S2SV_blank>the<S2SV_blank>\'%s\'<S2SV_blank>queue<S2SV_blank>(single<S2SV_blank>queue<S2SV_blank>run)"" , queue_name ) ; else set_process_info ( ""running<S2SV_blank>the<S2SV_blank>queue<S2SV_blank>(single<S2SV_blank>queue<S2SV_blank>run)"" ) ; queue_run ( start_queue_run_id , stop_queue_run_id , FALSE ) ; exim_exit ( EXIT_SUCCESS ) ; } for ( i = 0 ; ; ) { if ( ( pw = getpwuid ( real_uid ) ) != NULL ) { originator_login = string_copy ( US pw -> pw_name ) ; originator_home = string_copy ( US pw -> pw_dir ) ; if ( originator_name == NULL ) { if ( sender_address == NULL || ( ! trusted_caller && filter_test == FTEST_NONE ) ) { uschar * name = US pw -> pw_gecos ; uschar * amp = Ustrchr ( name , '&' ) ; uschar buffer [ 256 ] ; if ( amp != NULL ) { int loffset ; string_format ( buffer , sizeof ( buffer ) , ""%.*s%n%s%s"" , amp - name , name , & loffset , originator_login , amp + 1 ) ; buffer [ loffset ] = toupper ( buffer [ loffset ] ) ; name = buffer ; } if ( gecos_pattern != NULL && gecos_name != NULL ) { const pcre * re ; re = regex_must_compile ( gecos_pattern , FALSE , TRUE ) ; if ( regex_match_and_setup ( re , name , 0 , - 1 ) ) { uschar * new_name = expand_string ( gecos_name ) ; expand_nmax = - 1 ; if ( new_name != NULL ) { DEBUG ( D_receive ) debug_printf ( ""user<S2SV_blank>name<S2SV_blank>\\""%s\\""<S2SV_blank>extracted<S2SV_blank>from<S2SV_blank>"" ""gecos<S2SV_blank>field<S2SV_blank>\\""%s\\""\\n"" , new_name , name ) ; name = new_name ; } else DEBUG ( D_receive ) debug_printf ( ""failed<S2SV_blank>to<S2SV_blank>expand<S2SV_blank>gecos_name<S2SV_blank>string<S2SV_blank>"" ""\\""%s\\"":<S2SV_blank>%s\\n"" , gecos_name , expand_string_message ) ; } else DEBUG ( D_receive ) debug_printf ( ""gecos_pattern<S2SV_blank>\\""%s\\""<S2SV_blank>did<S2SV_blank>not<S2SV_blank>match<S2SV_blank>"" ""gecos<S2SV_blank>field<S2SV_blank>\\""%s\\""\\n"" , gecos_pattern , name ) ; store_free ( ( void * ) re ) ; } originator_name = string_copy ( name ) ; } else originator_name = US """" ; } break ; } if ( ++ i > finduser_retries ) break ; sleep ( 1 ) ; } if ( originator_login == NULL || running_in_test_harness ) { if ( unknown_login != NULL ) { originator_login = expand_string ( unknown_login ) ; if ( originator_name == NULL && unknown_username != NULL ) originator_name = expand_string ( unknown_username ) ; if ( originator_name == NULL ) originator_name = US """" ; } if ( originator_login == NULL ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>user<S2SV_blank>name<S2SV_blank>for<S2SV_blank>uid<S2SV_blank>%d"" , ( int ) real_uid ) ; } originator_name = string_copy ( parse_fix_phrase ( originator_name , Ustrlen ( originator_name ) , big_buffer , big_buffer_size ) ) ; originator_uid = real_uid ; originator_gid = real_gid ; DEBUG ( D_receive ) debug_printf ( ""originator:<S2SV_blank>uid=%d<S2SV_blank>gid=%d<S2SV_blank>login=%s<S2SV_blank>name=%s\\n"" , ( int ) originator_uid , ( int ) originator_gid , originator_login , originator_name ) ; if ( daemon_listen || inetd_wait_mode || queue_interval > 0 ) { if ( mua_wrapper ) { fprintf ( stderr , ""Daemon<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>run<S2SV_blank>when<S2SV_blank>mua_wrapper<S2SV_blank>is<S2SV_blank>set\\n"" ) ; log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , ""Daemon<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>run<S2SV_blank>when<S2SV_blank>"" ""mua_wrapper<S2SV_blank>is<S2SV_blank>set"" ) ; } daemon_go ( ) ; } if ( sender_ident == NULL ) sender_ident = originator_login ; else if ( sender_ident [ 0 ] == 0 ) sender_ident = NULL ; if ( test_rewrite_arg >= 0 ) { really_exim = FALSE ; if ( test_rewrite_arg >= argc ) { printf ( ""-brw<S2SV_blank>needs<S2SV_blank>an<S2SV_blank>address<S2SV_blank>argument\\n"" ) ; exim_exit ( EXIT_FAILURE ) ; } rewrite_test ( argv [ test_rewrite_arg ] ) ; exim_exit ( EXIT_SUCCESS ) ; } if ( ( sender_address == NULL && ! smtp_input ) || ( ! trusted_caller && filter_test == FTEST_NONE ) ) { sender_local = TRUE ; if ( authenticated_sender == NULL && ! host_checking ) authenticated_sender = string_sprintf ( ""%s@%s"" , originator_login , qualify_domain_sender ) ; if ( authenticated_id == NULL && ! host_checking ) authenticated_id = originator_login ; } if ( ( ! smtp_input && sender_address == NULL ) || ! receive_check_set_sender ( sender_address ) ) { if ( sender_address == NULL || ( sender_address [ 0 ] != 0 && ! checking ) ) { sender_address = originator_login ; sender_address_forced = FALSE ; sender_address_domain = 0 ; } } sender_set_untrusted = sender_address != originator_login && ! trusted_caller ; if ( sender_address != NULL && sender_address [ 0 ] != 0 && sender_address_domain == 0 ) sender_address = string_sprintf ( ""%s@%s"" , local_part_quote ( sender_address ) , qualify_domain_sender ) ; DEBUG ( D_receive ) debug_printf ( ""sender<S2SV_blank>address<S2SV_blank>=<S2SV_blank>%s\\n"" , sender_address ) ; if ( verify_address_mode || address_test_mode ) { int exit_value = 0 ; int flags = vopt_qualify ; if ( verify_address_mode ) { if ( ! verify_as_sender ) flags |= vopt_is_recipient ; DEBUG ( D_verify ) debug_print_ids ( US ""Verifying:"" ) ; } else { flags |= vopt_is_recipient ; debug_selector |= D_v ; debug_file = stderr ; debug_fd = fileno ( debug_file ) ; DEBUG ( D_verify ) debug_print_ids ( US ""Address<S2SV_blank>testing:"" ) ; } if ( recipients_arg < argc ) { while ( recipients_arg < argc ) { uschar * s = argv [ recipients_arg ++ ] ; while ( * s != 0 ) { BOOL finished = FALSE ; uschar * ss = parse_find_address_end ( s , FALSE ) ; if ( * ss == ',' ) * ss = 0 ; else finished = TRUE ; test_address ( s , flags , & exit_value ) ; s = ss ; if ( ! finished ) while ( * ( ++ s ) != 0 && ( * s == ',' || isspace ( * s ) ) ) ; } } } else for ( ; ; ) { uschar * s = get_stdinput ( NULL , NULL ) ; if ( s == NULL ) break ; test_address ( s , flags , & exit_value ) ; } route_tidyup ( ) ; exim_exit ( exit_value ) ; } if ( expansion_test ) { dns_init ( FALSE , FALSE , FALSE ) ; if ( msg_action_arg > 0 && msg_action == MSG_LOAD ) { uschar spoolname [ 256 ] ; if ( ! admin_user ) { fprintf ( stderr , ""exim:<S2SV_blank>permission<S2SV_blank>denied\\n"" ) ; exit ( EXIT_FAILURE ) ; } message_id = argv [ msg_action_arg ] ; ( void ) string_format ( spoolname , sizeof ( spoolname ) , ""%s-H"" , message_id ) ; if ( ( deliver_datafile = spool_open_datafile ( message_id ) ) < 0 ) printf ( ""Failed<S2SV_blank>to<S2SV_blank>load<S2SV_blank>message<S2SV_blank>datafile<S2SV_blank>%s\\n"" , message_id ) ; if ( spool_read_header ( spoolname , TRUE , FALSE ) != spool_read_OK ) printf ( ""Failed<S2SV_blank>to<S2SV_blank>load<S2SV_blank>message<S2SV_blank>%s\\n"" , message_id ) ; } else if ( expansion_test_message != NULL ) { int save_stdin = dup ( 0 ) ; int fd = Uopen ( expansion_test_message , O_RDONLY , 0 ) ; if ( fd < 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s:<S2SV_blank>%s\\n"" , expansion_test_message , strerror ( errno ) ) ; return EXIT_FAILURE ; } ( void ) dup2 ( fd , 0 ) ; filter_test = FTEST_USER ; message_ended = END_NOTENDED ; read_message_body ( receive_msg ( extract_recipients ) ) ; message_linecount += body_linecount ; ( void ) dup2 ( save_stdin , 0 ) ; ( void ) close ( save_stdin ) ; clearerr ( stdin ) ; } enable_dollar_recipients = TRUE ; if ( recipients_arg < argc ) { while ( recipients_arg < argc ) { uschar * s = argv [ recipients_arg ++ ] ; uschar * ss = expand_string ( s ) ; if ( ss == NULL ) printf ( ""Failed:<S2SV_blank>%s\\n"" , expand_string_message ) ; else printf ( ""%s\\n"" , CS ss ) ; } } else { char * ( * fn_readline ) ( const char * ) = NULL ; void ( * fn_addhist ) ( const char * ) = NULL ; # ifdef USE_READLINE void * dlhandle = set_readline ( & fn_readline , & fn_addhist ) ; # endif for ( ; ; ) { uschar * ss ; uschar * source = get_stdinput ( fn_readline , fn_addhist ) ; if ( source == NULL ) break ; ss = expand_string ( source ) ; if ( ss == NULL ) printf ( ""Failed:<S2SV_blank>%s\\n"" , expand_string_message ) ; else printf ( ""%s\\n"" , CS ss ) ; } # ifdef USE_READLINE if ( dlhandle != NULL ) dlclose ( dlhandle ) ; # endif } if ( deliver_datafile >= 0 ) { ( void ) close ( deliver_datafile ) ; deliver_datafile = - 1 ; } exim_exit ( EXIT_SUCCESS ) ; } smtp_active_hostname = primary_hostname ; if ( raw_active_hostname != NULL ) { uschar * nah = expand_string ( raw_active_hostname ) ; if ( nah == NULL ) { if ( ! expand_string_forcedfail ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , ""failed<S2SV_blank>to<S2SV_blank>expand<S2SV_blank>\\""%s\\""<S2SV_blank>"" ""(smtp_active_hostname):<S2SV_blank>%s"" , raw_active_hostname , expand_string_message ) ; } else if ( nah [ 0 ] != 0 ) smtp_active_hostname = nah ; } if ( host_checking ) { int x [ 4 ] ; int size ; if ( ! sender_ident_set ) { sender_ident = NULL ; if ( running_in_test_harness && sender_host_port != 0 && interface_address != NULL && interface_port != 0 ) verify_get_ident ( 1413 ) ; } size = host_aton ( sender_host_address , x ) ; sender_host_address = store_get ( 48 ) ; ( void ) host_nmtoa ( size , x , - 1 , sender_host_address , ':' ) ; host_build_sender_fullhost ( ) ; smtp_input = TRUE ; smtp_in = stdin ; smtp_out = stdout ; sender_local = FALSE ; sender_host_notsocket = TRUE ; debug_file = stderr ; debug_fd = fileno ( debug_file ) ; fprintf ( stdout , ""\\n****<S2SV_blank>SMTP<S2SV_blank>testing<S2SV_blank>session<S2SV_blank>as<S2SV_blank>if<S2SV_blank>from<S2SV_blank>host<S2SV_blank>%s\\n"" ""****<S2SV_blank>but<S2SV_blank>without<S2SV_blank>any<S2SV_blank>ident<S2SV_blank>(RFC<S2SV_blank>1413)<S2SV_blank>callback.\\n"" ""****<S2SV_blank>This<S2SV_blank>is<S2SV_blank>not<S2SV_blank>for<S2SV_blank>real!\\n\\n"" , sender_host_address ) ; memset ( sender_host_cache , 0 , sizeof ( sender_host_cache ) ) ; if ( verify_check_host ( & hosts_connection_nolog ) == OK ) BIT_CLEAR ( log_selector , log_selector_size , Li_smtp_connection ) ; log_write ( L_smtp_connection , LOG_MAIN , ""%s"" , smtp_get_connection_info ( ) ) ; if ( smtp_start_session ( ) ) { for ( reset_point = store_get ( 0 ) ; ; store_reset ( reset_point ) ) { if ( smtp_setup_msg ( ) <= 0 ) break ; if ( ! receive_msg ( FALSE ) ) break ; return_path = sender_address = NULL ; dnslist_domain = dnslist_matched = NULL ; # ifndef DISABLE_DKIM dkim_cur_signer = NULL ; # endif acl_var_m = NULL ; deliver_localpart_orig = NULL ; deliver_domain_orig = NULL ; callout_address = sending_ip_address = NULL ; sender_rate = sender_rate_limit = sender_rate_period = NULL ; } smtp_log_no_mail ( ) ; } exim_exit ( EXIT_SUCCESS ) ; } if ( recipients_arg >= argc && ! extract_recipients && ! smtp_input ) { if ( version_printed ) { printf ( ""Configuration<S2SV_blank>file<S2SV_blank>is<S2SV_blank>%s\\n"" , config_main_filename ) ; return EXIT_SUCCESS ; } if ( info_flag != CMDINFO_NONE ) { show_exim_information ( info_flag , info_stdout ? stdout : stderr ) ; return info_stdout ? EXIT_SUCCESS : EXIT_FAILURE ; } if ( filter_test == FTEST_NONE ) exim_usage ( called_as ) ; } if ( mua_wrapper ) { synchronous_delivery = TRUE ; arg_error_handling = ERRORS_STDERR ; remote_max_parallel = 1 ; deliver_drop_privilege = TRUE ; queue_smtp = FALSE ; queue_smtp_domains = NULL ; # ifdef SUPPORT_I18N message_utf8_downconvert = - 1 ; # endif } if ( ! smtp_input ) error_handling = arg_error_handling ; else if ( is_inetd ) { ( void ) fclose ( stderr ) ; exim_nullstd ( ) ; verify_get_ident ( IDENT_PORT ) ; host_build_sender_fullhost ( ) ; set_process_info ( ""handling<S2SV_blank>incoming<S2SV_blank>connection<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>via<S2SV_blank>inetd"" , sender_fullhost ) ; } if ( sender_host_address != NULL && sender_fullhost == NULL ) { host_build_sender_fullhost ( ) ; set_process_info ( ""handling<S2SV_blank>incoming<S2SV_blank>connection<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>via<S2SV_blank>-oMa"" , sender_fullhost ) ; sender_host_notsocket = TRUE ; } else if ( ! is_inetd ) sender_host_unknown = TRUE ; if ( fstat ( 1 , & statbuf ) < 0 ) ( void ) dup2 ( 0 , 1 ) ; if ( smtp_input ) { if ( ! is_inetd ) set_process_info ( ""accepting<S2SV_blank>a<S2SV_blank>local<S2SV_blank>%sSMTP<S2SV_blank>message<S2SV_blank>from<S2SV_blank><%s>"" , smtp_batched_input ? ""batched<S2SV_blank>"" : """" , ( sender_address != NULL ) ? sender_address : originator_login ) ; } else { int old_pool = store_pool ; store_pool = POOL_PERM ; if ( ! received_protocol ) received_protocol = string_sprintf ( ""local%s"" , called_as ) ; store_pool = old_pool ; set_process_info ( ""accepting<S2SV_blank>a<S2SV_blank>local<S2SV_blank>non-SMTP<S2SV_blank>message<S2SV_blank>from<S2SV_blank><%s>"" , sender_address ) ; } queue_check_only ( ) ; session_local_queue_only = queue_only ; if ( ( ! smtp_input || smtp_batched_input ) && ! receive_check_fs ( 0 ) ) { fprintf ( stderr , ""exim:<S2SV_blank>insufficient<S2SV_blank>disk<S2SV_blank>space\\n"" ) ; return EXIT_FAILURE ; } if ( smtp_input ) { smtp_in = stdin ; smtp_out = stdout ; memset ( sender_host_cache , 0 , sizeof ( sender_host_cache ) ) ; if ( verify_check_host ( & hosts_connection_nolog ) == OK ) BIT_CLEAR ( log_selector , log_selector_size , Li_smtp_connection ) ; log_write ( L_smtp_connection , LOG_MAIN , ""%s"" , smtp_get_connection_info ( ) ) ; if ( ! smtp_start_session ( ) ) { mac_smtp_fflush ( ) ; exim_exit ( EXIT_SUCCESS ) ; } } else { thismessage_size_limit = expand_string_integer ( message_size_limit , TRUE ) ; if ( expand_string_message ) if ( thismessage_size_limit == - 1 ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , ""failed<S2SV_blank>to<S2SV_blank>expand<S2SV_blank>"" ""message_size_limit:<S2SV_blank>%s"" , expand_string_message ) ; else log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , ""invalid<S2SV_blank>value<S2SV_blank>for<S2SV_blank>"" ""message_size_limit:<S2SV_blank>%s"" , expand_string_message ) ; } if ( ! synchronous_delivery ) { # ifdef SA_NOCLDWAIT struct sigaction act ; act . sa_handler = SIG_IGN ; sigemptyset ( & ( act . sa_mask ) ) ; act . sa_flags = SA_NOCLDWAIT ; sigaction ( SIGCHLD , & act , NULL ) ; # else signal ( SIGCHLD , SIG_IGN ) ; # endif } reset_point = store_get ( 0 ) ; real_sender_address = sender_address ; while ( more ) { message_id [ 0 ] = 0 ; if ( smtp_input ) { int rc ; if ( ( rc = smtp_setup_msg ( ) ) > 0 ) { if ( real_sender_address != NULL && ! receive_check_set_sender ( sender_address ) ) { sender_address = raw_sender = real_sender_address ; sender_address_unrewritten = NULL ; } if ( smtp_batched_input && acl_not_smtp_start != NULL ) { uschar * user_msg , * log_msg ; enable_dollar_recipients = TRUE ; ( void ) acl_check ( ACL_WHERE_NOTSMTP_START , NULL , acl_not_smtp_start , & user_msg , & log_msg ) ; enable_dollar_recipients = FALSE ; } more = receive_msg ( extract_recipients ) ; if ( message_id [ 0 ] == 0 ) { cancel_cutthrough_connection ( TRUE , US ""receive<S2SV_blank>dropped"" ) ; if ( more ) goto moreloop ; smtp_log_no_mail ( ) ; exim_exit ( EXIT_FAILURE ) ; } } else { cancel_cutthrough_connection ( TRUE , US ""message<S2SV_blank>setup<S2SV_blank>dropped"" ) ; smtp_log_no_mail ( ) ; exim_exit ( ( rc == 0 ) ? EXIT_SUCCESS : EXIT_FAILURE ) ; } } else { int i ; int rcount = 0 ; int count = argc - recipients_arg ; uschar * * list = argv + recipients_arg ; active_local_sender_retain = local_sender_retain ; active_local_from_check = local_from_check ; raw_sender = string_copy ( sender_address ) ; for ( i = 0 ; i < count ; i ++ ) { int start , end , domain ; uschar * errmess ; uschar * s = list [ i ] ; while ( * s != 0 ) { BOOL finished = FALSE ; uschar * recipient ; uschar * ss = parse_find_address_end ( s , FALSE ) ; if ( * ss == ',' ) * ss = 0 ; else finished = TRUE ; if ( recipients_max > 0 && ++ rcount > recipients_max && ! extract_recipients ) if ( error_handling == ERRORS_STDERR ) { fprintf ( stderr , ""exim:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>recipients\\n"" ) ; exim_exit ( EXIT_FAILURE ) ; } else { return moan_to_sender ( ERRMESS_TOOMANYRECIP , NULL , NULL , stdin , TRUE ) ? errors_sender_rc : EXIT_FAILURE ; } # ifdef SUPPORT_I18N { BOOL b = allow_utf8_domains ; allow_utf8_domains = TRUE ; # endif recipient = parse_extract_address ( s , & errmess , & start , & end , & domain , FALSE ) ; # ifdef SUPPORT_I18N if ( string_is_utf8 ( recipient ) ) message_smtputf8 = TRUE ; else allow_utf8_domains = b ; } # endif if ( domain == 0 && ! allow_unqualified_recipient ) { recipient = NULL ; errmess = US ""unqualified<S2SV_blank>recipient<S2SV_blank>address<S2SV_blank>not<S2SV_blank>allowed"" ; } if ( recipient == NULL ) { if ( error_handling == ERRORS_STDERR ) { fprintf ( stderr , ""exim:<S2SV_blank>bad<S2SV_blank>recipient<S2SV_blank>address<S2SV_blank>\\""%s\\"":<S2SV_blank>%s\\n"" , string_printing ( list [ i ] ) , errmess ) ; exim_exit ( EXIT_FAILURE ) ; } else { error_block eblock ; eblock . next = NULL ; eblock . text1 = string_printing ( list [ i ] ) ; eblock . text2 = errmess ; return moan_to_sender ( ERRMESS_BADARGADDRESS , & eblock , NULL , stdin , TRUE ) ? errors_sender_rc : EXIT_FAILURE ; } } receive_add_recipient ( recipient , - 1 ) ; s = ss ; if ( ! finished ) while ( * ( ++ s ) != 0 && ( * s == ',' || isspace ( * s ) ) ) ; } } DEBUG ( D_receive ) { int i ; if ( sender_address != NULL ) debug_printf ( ""Sender:<S2SV_blank>%s\\n"" , sender_address ) ; if ( recipients_list != NULL ) { debug_printf ( ""Recipients:\\n"" ) ; for ( i = 0 ; i < recipients_count ; i ++ ) debug_printf ( ""<S2SV_blank><S2SV_blank>%s\\n"" , recipients_list [ i ] . address ) ; } } if ( acl_not_smtp_start ) { uschar * user_msg , * log_msg ; enable_dollar_recipients = TRUE ; ( void ) acl_check ( ACL_WHERE_NOTSMTP_START , NULL , acl_not_smtp_start , & user_msg , & log_msg ) ; enable_dollar_recipients = FALSE ; } if ( ! receive_timeout ) { struct timeval t = { 30 * 60 , 0 } ; fd_set r ; FD_ZERO ( & r ) ; FD_SET ( 0 , & r ) ; if ( select ( 1 , & r , NULL , NULL , & t ) == 0 ) mainlog_close ( ) ; } message_ended = END_NOTENDED ; more = receive_msg ( extract_recipients ) ; if ( message_id [ 0 ] == 0 ) exim_exit ( EXIT_FAILURE ) ; } if ( filter_test != FTEST_NONE ) { deliver_domain = ( ftest_domain != NULL ) ? ftest_domain : qualify_domain_recipient ; deliver_domain_orig = deliver_domain ; deliver_localpart = ( ftest_localpart != NULL ) ? ftest_localpart : originator_login ; deliver_localpart_orig = deliver_localpart ; deliver_localpart_prefix = ftest_prefix ; deliver_localpart_suffix = ftest_suffix ; deliver_home = originator_home ; if ( return_path == NULL ) { printf ( ""Return-path<S2SV_blank>copied<S2SV_blank>from<S2SV_blank>sender\\n"" ) ; return_path = string_copy ( sender_address ) ; } else printf ( ""Return-path<S2SV_blank>=<S2SV_blank>%s\\n"" , ( return_path [ 0 ] == 0 ) ? US ""<>"" : return_path ) ; printf ( ""Sender<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%s\\n"" , ( sender_address [ 0 ] == 0 ) ? US ""<>"" : sender_address ) ; receive_add_recipient ( string_sprintf ( ""%s%s%s@%s"" , ( ftest_prefix == NULL ) ? US """" : ftest_prefix , deliver_localpart , ( ftest_suffix == NULL ) ? US """" : ftest_suffix , deliver_domain ) , - 1 ) ; printf ( ""Recipient<S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%s\\n"" , recipients_list [ 0 ] . address ) ; if ( ftest_prefix != NULL ) printf ( ""Prefix<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%s\\n"" , ftest_prefix ) ; if ( ftest_suffix != NULL ) printf ( ""Suffix<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%s\\n"" , ftest_suffix ) ; if ( chdir ( ""/"" ) ) { DEBUG ( D_receive ) debug_printf ( ""chdir(\\""/\\"")<S2SV_blank>failed\\n"" ) ; exim_exit ( EXIT_FAILURE ) ; } if ( ( filter_test & FTEST_SYSTEM ) != 0 ) { if ( ! filter_runtest ( filter_sfd , filter_test_sfile , TRUE , more ) ) exim_exit ( EXIT_FAILURE ) ; } memcpy ( filter_sn , filter_n , sizeof ( filter_sn ) ) ; if ( ( filter_test & FTEST_USER ) != 0 ) { if ( ! filter_runtest ( filter_ufd , filter_test_ufile , FALSE , more ) ) exim_exit ( EXIT_FAILURE ) ; } exim_exit ( EXIT_SUCCESS ) ; } if ( ! session_local_queue_only && smtp_accept_queue_per_connection > 0 && receive_messagecount > smtp_accept_queue_per_connection ) { session_local_queue_only = TRUE ; queue_only_reason = 2 ; } local_queue_only = session_local_queue_only ; if ( ! local_queue_only && queue_only_load >= 0 ) { local_queue_only = ( load_average = OS_GETLOADAVG ( ) ) > queue_only_load ; if ( local_queue_only ) { queue_only_reason = 3 ; if ( queue_only_load_latch ) session_local_queue_only = TRUE ; } } if ( mua_wrapper ) local_queue_only = queue_only_policy = deliver_freeze = FALSE ; if ( local_queue_only ) { cancel_cutthrough_connection ( TRUE , US ""no<S2SV_blank>delivery;<S2SV_blank>queueing"" ) ; switch ( queue_only_reason ) { case 2 : log_write ( L_delay_delivery , LOG_MAIN , ""no<S2SV_blank>immediate<S2SV_blank>delivery:<S2SV_blank>more<S2SV_blank>than<S2SV_blank>%d<S2SV_blank>messages<S2SV_blank>"" ""received<S2SV_blank>in<S2SV_blank>one<S2SV_blank>connection"" , smtp_accept_queue_per_connection ) ; break ; case 3 : log_write ( L_delay_delivery , LOG_MAIN , ""no<S2SV_blank>immediate<S2SV_blank>delivery:<S2SV_blank>load<S2SV_blank>average<S2SV_blank>%.2f"" , ( double ) load_average / 1000.0 ) ; break ; } } else if ( queue_only_policy || deliver_freeze ) cancel_cutthrough_connection ( TRUE , US ""no<S2SV_blank>delivery;<S2SV_blank>queueing"" ) ; else { pid_t pid ; search_tidyup ( ) ; if ( ( pid = fork ( ) ) == 0 ) { int rc ; close_unwanted ( ) ; exim_nullstd ( ) ; if ( geteuid ( ) != root_uid && ! deliver_drop_privilege && ! unprivileged ) { delivery_re_exec ( CEE_EXEC_EXIT ) ; } rc = deliver_message ( message_id , FALSE , FALSE ) ; search_tidyup ( ) ; _exit ( ( ! mua_wrapper || rc == DELIVER_MUA_SUCCEEDED ) ? EXIT_SUCCESS : EXIT_FAILURE ) ; } if ( pid < 0 ) { cancel_cutthrough_connection ( TRUE , US ""delivery<S2SV_blank>fork<S2SV_blank>failed"" ) ; log_write ( 0 , LOG_MAIN | LOG_PANIC , ""failed<S2SV_blank>to<S2SV_blank>fork<S2SV_blank>automatic<S2SV_blank>delivery<S2SV_blank>"" ""process:<S2SV_blank>%s"" , strerror ( errno ) ) ; } else { release_cutthrough_connection ( US ""msg<S2SV_blank>passed<S2SV_blank>for<S2SV_blank>delivery"" ) ; if ( synchronous_delivery ) { int status ; while ( wait ( & status ) != pid ) ; if ( ( status & 0x00ff ) != 0 ) log_write ( 0 , LOG_MAIN | LOG_PANIC , ""process<S2SV_blank>%d<S2SV_blank>crashed<S2SV_blank>with<S2SV_blank>signal<S2SV_blank>%d<S2SV_blank>while<S2SV_blank>delivering<S2SV_blank>%s"" , ( int ) pid , status & 0x00ff , message_id ) ; if ( mua_wrapper && ( status & 0xffff ) != 0 ) exim_exit ( EXIT_FAILURE ) ; } } } # ifndef SIG_IGN_WORKS while ( waitpid ( - 1 , NULL , WNOHANG ) > 0 ) ; # endif moreloop : return_path = sender_address = NULL ; authenticated_sender = NULL ; deliver_localpart_orig = NULL ; deliver_domain_orig = NULL ; deliver_host = deliver_host_address = NULL ; dnslist_domain = dnslist_matched = NULL ; # ifdef WITH_CONTENT_SCAN malware_name = NULL ; # endif callout_address = NULL ; sending_ip_address = NULL ; acl_var_m = NULL ; { int i ; for ( i = 0 ; i < REGEX_VARS ; i ++ ) regex_vars [ i ] = NULL ; } store_reset ( reset_point ) ; } exim_exit ( EXIT_SUCCESS ) ; return 0 ; }","uschar * hn ;if ( received_protocol ) {fprintf ( stderr , ""received_protocol<S2SV_blank>is<S2SV_blank>set<S2SV_blank>already\\\exit ( EXIT_FAILURE ) ;}p = & argrest [ 2 ] ;",349
473,"buggy line: else if ( Ustrcmp ( argrest , ""Mr"" ) == 0 ) received_protocol = argv [ ++ i ] ;else if ( Ustrcmp ( argrest , ""Ms"" ) == 0 ) sender_host_name = argv [ ++ i ] ;cwe id:CWE-404context: int main ( int argc , char * * cargv ) { uschar * * argv = USS cargv ; int arg_receive_timeout = - 1 ; int arg_smtp_receive_timeout = - 1 ; int arg_error_handling = error_handling ; int filter_sfd = - 1 ; int filter_ufd = - 1 ; int group_count ; int i , rv ; int list_queue_option = 0 ; int msg_action = 0 ; int msg_action_arg = - 1 ; int namelen = ( argv [ 0 ] == NULL ) ? 0 : Ustrlen ( argv [ 0 ] ) ; int queue_only_reason = 0 ; # ifdef EXIM_PERL int perl_start_option = 0 ; # endif int recipients_arg = argc ; int sender_address_domain = 0 ; int test_retry_arg = - 1 ; int test_rewrite_arg = - 1 ; BOOL arg_queue_only = FALSE ; BOOL bi_option = FALSE ; BOOL checking = FALSE ; BOOL count_queue = FALSE ; BOOL expansion_test = FALSE ; BOOL extract_recipients = FALSE ; BOOL flag_G = FALSE ; BOOL flag_n = FALSE ; BOOL forced_delivery = FALSE ; BOOL f_end_dot = FALSE ; BOOL deliver_give_up = FALSE ; BOOL list_queue = FALSE ; BOOL list_options = FALSE ; BOOL list_config = FALSE ; BOOL local_queue_only ; BOOL more = TRUE ; BOOL one_msg_action = FALSE ; BOOL opt_D_used = FALSE ; BOOL queue_only_set = FALSE ; BOOL receiving_message = TRUE ; BOOL sender_ident_set = FALSE ; BOOL session_local_queue_only ; BOOL unprivileged ; BOOL removed_privilege = FALSE ; BOOL usage_wanted = FALSE ; BOOL verify_address_mode = FALSE ; BOOL verify_as_sender = FALSE ; BOOL version_printed = FALSE ; uschar * alias_arg = NULL ; uschar * called_as = US """" ; uschar * cmdline_syslog_name = NULL ; uschar * start_queue_run_id = NULL ; uschar * stop_queue_run_id = NULL ; uschar * expansion_test_message = NULL ; uschar * ftest_domain = NULL ; uschar * ftest_localpart = NULL ; uschar * ftest_prefix = NULL ; uschar * ftest_suffix = NULL ; uschar * log_oneline = NULL ; uschar * malware_test_file = NULL ; uschar * real_sender_address ; uschar * originator_home = US ""/"" ; size_t sz ; void * reset_point ; struct passwd * pw ; struct stat statbuf ; pid_t passed_qr_pid = ( pid_t ) 0 ; int passed_qr_pipe = - 1 ; gid_t group_list [ NGROUPS_MAX ] ; enum commandline_info info_flag = CMDINFO_NONE ; BOOL info_stdout = FALSE ; static uschar * rsopts [ ] = { US ""f"" , US ""ff"" , US ""r"" , US ""rf"" , US ""rff"" } ; extern char * * environ ; # ifdef EXIM_USERNAME if ( route_finduser ( US EXIM_USERNAME , & pw , & exim_uid ) ) { if ( exim_uid == 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>refusing<S2SV_blank>to<S2SV_blank>run<S2SV_blank>with<S2SV_blank>uid<S2SV_blank>0<S2SV_blank>for<S2SV_blank>\\""%s\\""\\n"" , EXIM_USERNAME ) ; exit ( EXIT_FAILURE ) ; } if ( pw ) exim_gid = pw -> pw_gid ; # ifndef EXIM_GROUPNAME else { fprintf ( stderr , ""exim:<S2SV_blank>ref:name<S2SV_blank>should<S2SV_blank>specify<S2SV_blank>a<S2SV_blank>usercode,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>group.\\n"" ""exim:<S2SV_blank>can\'t<S2SV_blank>let<S2SV_blank>you<S2SV_blank>get<S2SV_blank>away<S2SV_blank>with<S2SV_blank>it<S2SV_blank>unless<S2SV_blank>you<S2SV_blank>also<S2SV_blank>specify<S2SV_blank>a<S2SV_blank>group.\\n"" ) ; exit ( EXIT_FAILURE ) ; } # endif } else { fprintf ( stderr , ""exim:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>uid<S2SV_blank>for<S2SV_blank>user<S2SV_blank>name<S2SV_blank>\\""%s\\""\\n"" , EXIM_USERNAME ) ; exit ( EXIT_FAILURE ) ; } # endif # ifdef EXIM_GROUPNAME if ( ! route_findgroup ( US EXIM_GROUPNAME , & exim_gid ) ) { fprintf ( stderr , ""exim:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>gid<S2SV_blank>for<S2SV_blank>group<S2SV_blank>name<S2SV_blank>\\""%s\\""\\n"" , EXIM_GROUPNAME ) ; exit ( EXIT_FAILURE ) ; } # endif # ifdef CONFIGURE_OWNERNAME if ( ! route_finduser ( US CONFIGURE_OWNERNAME , NULL , & config_uid ) ) { fprintf ( stderr , ""exim:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>uid<S2SV_blank>for<S2SV_blank>user<S2SV_blank>name<S2SV_blank>\\""%s\\""\\n"" , CONFIGURE_OWNERNAME ) ; exit ( EXIT_FAILURE ) ; } # endif system_filter_uid = exim_uid ; # ifdef CONFIGURE_GROUPNAME if ( ! route_findgroup ( US CONFIGURE_GROUPNAME , & config_gid ) ) { fprintf ( stderr , ""exim:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>gid<S2SV_blank>for<S2SV_blank>group<S2SV_blank>name<S2SV_blank>\\""%s\\""\\n"" , CONFIGURE_GROUPNAME ) ; exit ( EXIT_FAILURE ) ; } # endif # ifdef OS_INIT OS_INIT # endif running_in_test_harness = * running_status == '<' && Ustrcmp ( running_status , ""<<<testing>>>"" ) == 0 ; setlocale ( LC_ALL , ""C"" ) ; os_non_restarting_signal ( SIGALRM , sigalrm_handler ) ; if ( ! ( log_buffer = US malloc ( LOG_BUFFER_SIZE ) ) ) { fprintf ( stderr , ""exim:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>store<S2SV_blank>for<S2SV_blank>log<S2SV_blank>buffer\\n"" ) ; exit ( EXIT_FAILURE ) ; } bits_set ( log_selector , log_selector_size , log_default ) ; if ( fstat ( fileno ( stderr ) , & statbuf ) >= 0 ) log_stderr = stderr ; pcre_malloc = function_store_get ; pcre_free = function_dummy_free ; big_buffer = store_malloc ( big_buffer_size ) ; set_process_info ( ""initializing"" ) ; os_restarting_signal ( SIGUSR1 , usr1_handler ) ; signal ( SIGHUP , SIG_IGN ) ; signal ( SIGPIPE , SIG_IGN ) ; # ifdef SA_NOCLDWAIT { struct sigaction act ; act . sa_handler = SIG_DFL ; sigemptyset ( & ( act . sa_mask ) ) ; act . sa_flags = 0 ; sigaction ( SIGCHLD , & act , NULL ) ; } # else signal ( SIGCHLD , SIG_DFL ) ; # endif sighup_argv = argv ; version_init ( ) ; message_id_option [ 0 ] = '-' ; message_id_external = message_id_option + 1 ; message_id_external [ 0 ] = 'E' ; message_id = message_id_external + 1 ; message_id [ 0 ] = 0 ; ( void ) umask ( 0 ) ; regex_ismsgid = regex_must_compile ( US ""^(?:[^\\\\W_]{6}-){2}[^\\\\W_]{2}$"" , FALSE , TRUE ) ; regex_smtp_code = regex_must_compile ( US ""^\\\\d\\\\d\\\\d\\\\s(?:\\\\d\\\\.\\\\d\\\\d?\\\\d?\\\\.\\\\d\\\\d?\\\\d?\\\\s)?"" , FALSE , TRUE ) ; # ifdef WHITELIST_D_MACROS regex_whitelisted_macro = regex_must_compile ( US ""^[A-Za-z0-9_/.-]*$"" , FALSE , TRUE ) ; # endif for ( i = 0 ; i < REGEX_VARS ; i ++ ) regex_vars [ i ] = NULL ; if ( ( namelen == 5 && Ustrcmp ( argv [ 0 ] , ""mailq"" ) == 0 ) || ( namelen > 5 && Ustrncmp ( argv [ 0 ] + namelen - 6 , ""/mailq"" , 6 ) == 0 ) ) { list_queue = TRUE ; receiving_message = FALSE ; called_as = US ""-mailq"" ; } if ( ( namelen == 5 && Ustrcmp ( argv [ 0 ] , ""rmail"" ) == 0 ) || ( namelen > 5 && Ustrncmp ( argv [ 0 ] + namelen - 6 , ""/rmail"" , 6 ) == 0 ) ) { dot_ends = FALSE ; called_as = US ""-rmail"" ; errors_sender_rc = EXIT_SUCCESS ; } if ( ( namelen == 5 && Ustrcmp ( argv [ 0 ] , ""rsmtp"" ) == 0 ) || ( namelen > 5 && Ustrncmp ( argv [ 0 ] + namelen - 6 , ""/rsmtp"" , 6 ) == 0 ) ) { smtp_input = smtp_batched_input = TRUE ; called_as = US ""-rsmtp"" ; } if ( ( namelen == 4 && Ustrcmp ( argv [ 0 ] , ""runq"" ) == 0 ) || ( namelen > 4 && Ustrncmp ( argv [ 0 ] + namelen - 5 , ""/runq"" , 5 ) == 0 ) ) { queue_interval = 0 ; receiving_message = FALSE ; called_as = US ""-runq"" ; } if ( ( namelen == 10 && Ustrcmp ( argv [ 0 ] , ""newaliases"" ) == 0 ) || ( namelen > 10 && Ustrncmp ( argv [ 0 ] + namelen - 11 , ""/newaliases"" , 11 ) == 0 ) ) { bi_option = TRUE ; receiving_message = FALSE ; called_as = US ""-newaliases"" ; } original_euid = geteuid ( ) ; real_uid = getuid ( ) ; real_gid = getgid ( ) ; if ( real_uid == root_uid ) { rv = setgid ( real_gid ) ; if ( rv ) { fprintf ( stderr , ""exim:<S2SV_blank>setgid(%ld)<S2SV_blank>failed:<S2SV_blank>%s\\n"" , ( long int ) real_gid , strerror ( errno ) ) ; exit ( EXIT_FAILURE ) ; } rv = setuid ( real_uid ) ; if ( rv ) { fprintf ( stderr , ""exim:<S2SV_blank>setuid(%ld)<S2SV_blank>failed:<S2SV_blank>%s\\n"" , ( long int ) real_uid , strerror ( errno ) ) ; exit ( EXIT_FAILURE ) ; } } unprivileged = ( real_uid != root_uid && original_euid != root_uid ) ; for ( i = 1 ; i < argc ; i ++ ) { BOOL badarg = FALSE ; uschar * arg = argv [ i ] ; uschar * argrest ; int switchchar ; if ( arg [ 0 ] != '-' ) { recipients_arg = i ; break ; } if ( Ustrcmp ( arg , ""--"" ) == 0 ) { recipients_arg = i + 1 ; break ; } switchchar = arg [ 1 ] ; argrest = arg + 2 ; if ( Ustrncmp ( arg + 1 , ""oe"" , 2 ) == 0 || Ustrncmp ( arg + 1 , ""qR"" , 2 ) == 0 || Ustrncmp ( arg + 1 , ""qS"" , 2 ) == 0 ) { switchchar = arg [ 2 ] ; argrest ++ ; } else if ( Ustrncmp ( arg + 1 , ""qqR"" , 3 ) == 0 || Ustrncmp ( arg + 1 , ""qqS"" , 3 ) == 0 ) { switchchar = arg [ 3 ] ; argrest += 2 ; queue_2stage = TRUE ; } else if ( arg [ 1 ] == 'r' ) switchchar = 'f' ; else if ( Ustrcmp ( arg , ""-ov"" ) == 0 ) { switchchar = 'v' ; argrest ++ ; } else if ( switchchar == '-' ) { if ( Ustrcmp ( argrest , ""help"" ) == 0 ) { usage_wanted = TRUE ; break ; } else if ( Ustrcmp ( argrest , ""version"" ) == 0 ) { switchchar = 'b' ; argrest = US ""V"" ; } } switch ( switchchar ) { case 'A' : if ( * argrest == '\\0' ) { badarg = TRUE ; break ; } else { BOOL ignore = FALSE ; switch ( * argrest ) { case 'c' : case 'm' : if ( * ( argrest + 1 ) == '\\0' ) ignore = TRUE ; break ; } if ( ! ignore ) { badarg = TRUE ; break ; } } break ; case 'B' : if ( * argrest == 0 ) i ++ ; break ; case 'b' : receiving_message = FALSE ; if ( * argrest == 'd' ) { daemon_listen = TRUE ; if ( * ( ++ argrest ) == 'f' ) background_daemon = FALSE ; else if ( * argrest != 0 ) { badarg = TRUE ; break ; } } else if ( * argrest == 'e' ) { expansion_test = checking = TRUE ; if ( argrest [ 1 ] == 'm' ) { if ( ++ i >= argc ) { badarg = TRUE ; break ; } expansion_test_message = argv [ i ] ; argrest ++ ; } if ( argrest [ 1 ] != 0 ) { badarg = TRUE ; break ; } } else if ( * argrest == 'F' ) { filter_test |= checking = FTEST_SYSTEM ; if ( * ( ++ argrest ) != 0 ) { badarg = TRUE ; break ; } if ( ++ i < argc ) filter_test_sfile = argv [ i ] ; else { fprintf ( stderr , ""exim:<S2SV_blank>file<S2SV_blank>name<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>%s\\n"" , argv [ i - 1 ] ) ; exit ( EXIT_FAILURE ) ; } } else if ( * argrest == 'f' ) { if ( * ( ++ argrest ) == 0 ) { filter_test |= checking = FTEST_USER ; if ( ++ i < argc ) filter_test_ufile = argv [ i ] ; else { fprintf ( stderr , ""exim:<S2SV_blank>file<S2SV_blank>name<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>%s\\n"" , argv [ i - 1 ] ) ; exit ( EXIT_FAILURE ) ; } } else { if ( ++ i >= argc ) { fprintf ( stderr , ""exim:<S2SV_blank>string<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>%s\\n"" , arg ) ; exit ( EXIT_FAILURE ) ; } if ( Ustrcmp ( argrest , ""d"" ) == 0 ) ftest_domain = argv [ i ] ; else if ( Ustrcmp ( argrest , ""l"" ) == 0 ) ftest_localpart = argv [ i ] ; else if ( Ustrcmp ( argrest , ""p"" ) == 0 ) ftest_prefix = argv [ i ] ; else if ( Ustrcmp ( argrest , ""s"" ) == 0 ) ftest_suffix = argv [ i ] ; else { badarg = TRUE ; break ; } } } else if ( Ustrcmp ( argrest , ""h"" ) == 0 || Ustrcmp ( argrest , ""hc"" ) == 0 ) { if ( ++ i >= argc ) { badarg = TRUE ; break ; } sender_host_address = argv [ i ] ; host_checking = checking = log_testing_mode = TRUE ; host_checking_callout = argrest [ 1 ] == 'c' ; message_logs = FALSE ; } else if ( Ustrcmp ( argrest , ""i"" ) == 0 ) bi_option = TRUE ; else if ( argrest [ 0 ] == 'I' && Ustrlen ( argrest ) >= 2 && argrest [ 1 ] == ':' ) { uschar * p = & argrest [ 2 ] ; info_flag = CMDINFO_HELP ; if ( Ustrlen ( p ) ) { if ( strcmpic ( p , CUS ""sieve"" ) == 0 ) { info_flag = CMDINFO_SIEVE ; info_stdout = TRUE ; } else if ( strcmpic ( p , CUS ""dscp"" ) == 0 ) { info_flag = CMDINFO_DSCP ; info_stdout = TRUE ; } else if ( strcmpic ( p , CUS ""help"" ) == 0 ) { info_stdout = TRUE ; } } } else if ( Ustrcmp ( argrest , ""m"" ) == 0 ) receiving_message = TRUE ; else if ( Ustrcmp ( argrest , ""malware"" ) == 0 ) { if ( ++ i >= argc ) { badarg = TRUE ; break ; } checking = TRUE ; malware_test_file = argv [ i ] ; } else if ( Ustrcmp ( argrest , ""nq"" ) == 0 ) { allow_unqualified_sender = FALSE ; allow_unqualified_recipient = FALSE ; } else if ( * argrest == 'p' ) { if ( * ( ++ argrest ) == 'c' ) { count_queue = TRUE ; if ( * ( ++ argrest ) != 0 ) badarg = TRUE ; break ; } if ( * argrest == 'r' ) { list_queue_option = 8 ; argrest ++ ; } else list_queue_option = 0 ; list_queue = TRUE ; if ( * argrest == 0 ) { } else if ( Ustrcmp ( argrest , ""u"" ) == 0 ) list_queue_option += 1 ; else if ( Ustrcmp ( argrest , ""a"" ) == 0 ) list_queue_option += 2 ; else { badarg = TRUE ; break ; } } else if ( Ustrcmp ( argrest , ""P"" ) == 0 ) { if ( argv [ i + 1 ] && Ustrcmp ( argv [ i + 1 ] , ""config"" ) == 0 ) { list_config = TRUE ; readconf_save_config ( version_string ) ; } else { list_options = TRUE ; debug_selector |= D_v ; debug_file = stderr ; } } else if ( Ustrcmp ( argrest , ""rt"" ) == 0 ) { checking = TRUE ; test_retry_arg = i + 1 ; goto END_ARG ; } else if ( Ustrcmp ( argrest , ""rw"" ) == 0 ) { checking = TRUE ; test_rewrite_arg = i + 1 ; goto END_ARG ; } else if ( Ustrcmp ( argrest , ""S"" ) == 0 ) smtp_input = smtp_batched_input = receiving_message = TRUE ; else if ( Ustrcmp ( argrest , ""s"" ) == 0 ) smtp_input = receiving_message = TRUE ; else if ( Ustrcmp ( argrest , ""t"" ) == 0 ) address_test_mode = checking = log_testing_mode = TRUE ; else if ( Ustrcmp ( argrest , ""v"" ) == 0 ) verify_address_mode = checking = log_testing_mode = TRUE ; else if ( Ustrcmp ( argrest , ""vs"" ) == 0 ) { verify_address_mode = checking = log_testing_mode = TRUE ; verify_as_sender = TRUE ; } else if ( Ustrcmp ( argrest , ""V"" ) == 0 ) { printf ( ""Exim<S2SV_blank>version<S2SV_blank>%s<S2SV_blank>#%s<S2SV_blank>built<S2SV_blank>%s\\n"" , version_string , version_cnumber , version_date ) ; printf ( ""%s\\n"" , CS version_copyright ) ; version_printed = TRUE ; show_whats_supported ( stdout ) ; log_testing_mode = TRUE ; } else if ( * argrest == 'w' ) { inetd_wait_mode = TRUE ; background_daemon = FALSE ; daemon_listen = TRUE ; if ( * ( ++ argrest ) != '\\0' ) { inetd_wait_timeout = readconf_readtime ( argrest , 0 , FALSE ) ; if ( inetd_wait_timeout <= 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>bad<S2SV_blank>time<S2SV_blank>value<S2SV_blank>%s:<S2SV_blank>abandoned\\n"" , argv [ i ] ) ; exit ( EXIT_FAILURE ) ; } } } else badarg = TRUE ; break ; case 'C' : if ( * argrest == 0 ) { if ( ++ i < argc ) argrest = argv [ i ] ; else { badarg = TRUE ; break ; } } if ( Ustrcmp ( config_main_filelist , argrest ) != 0 ) { # ifdef ALT_CONFIG_PREFIX int sep = 0 ; int len = Ustrlen ( ALT_CONFIG_PREFIX ) ; const uschar * list = argrest ; uschar * filename ; while ( ( filename = string_nextinlist ( & list , & sep , big_buffer , big_buffer_size ) ) != NULL ) { if ( ( Ustrlen ( filename ) < len || Ustrncmp ( filename , ALT_CONFIG_PREFIX , len ) != 0 || Ustrstr ( filename , ""/../"" ) != NULL ) && ( Ustrcmp ( filename , ""/dev/null"" ) != 0 || real_uid != root_uid ) ) { fprintf ( stderr , ""-C<S2SV_blank>Permission<S2SV_blank>denied\\n"" ) ; exit ( EXIT_FAILURE ) ; } } # endif if ( real_uid != root_uid ) { # ifdef TRUSTED_CONFIG_LIST if ( real_uid != exim_uid # ifdef CONFIGURE_OWNER && real_uid != config_uid # endif ) trusted_config = FALSE ; else { FILE * trust_list = Ufopen ( TRUSTED_CONFIG_LIST , ""rb"" ) ; if ( trust_list ) { struct stat statbuf ; if ( fstat ( fileno ( trust_list ) , & statbuf ) != 0 || ( statbuf . st_uid != root_uid # ifdef CONFIGURE_OWNER && statbuf . st_uid != config_uid # endif ) || ( statbuf . st_gid != root_gid # ifdef CONFIGURE_GROUP && statbuf . st_gid != config_gid # endif && ( statbuf . st_mode & 020 ) != 0 ) || ( statbuf . st_mode & 2 ) != 0 ) { trusted_config = FALSE ; fclose ( trust_list ) ; } else { void * reset_point = store_get ( 0 ) ; uschar * trusted_configs [ 32 ] ; int nr_configs = 0 ; int i = 0 ; while ( Ufgets ( big_buffer , big_buffer_size , trust_list ) ) { uschar * start = big_buffer , * nl ; while ( * start && isspace ( * start ) ) start ++ ; if ( * start != '/' ) continue ; nl = Ustrchr ( start , '\\n' ) ; if ( nl ) * nl = 0 ; trusted_configs [ nr_configs ++ ] = string_copy ( start ) ; if ( nr_configs == 32 ) break ; } fclose ( trust_list ) ; if ( nr_configs ) { int sep = 0 ; const uschar * list = argrest ; uschar * filename ; while ( trusted_config && ( filename = string_nextinlist ( & list , & sep , big_buffer , big_buffer_size ) ) != NULL ) { for ( i = 0 ; i < nr_configs ; i ++ ) { if ( Ustrcmp ( filename , trusted_configs [ i ] ) == 0 ) break ; } if ( i == nr_configs ) { trusted_config = FALSE ; break ; } } store_reset ( reset_point ) ; } else { trusted_config = FALSE ; } } } else { trusted_config = FALSE ; } } # else trusted_config = FALSE ; # endif } config_main_filelist = argrest ; config_changed = TRUE ; } break ; case 'D' : # ifdef DISABLE_D_OPTION fprintf ( stderr , ""exim:<S2SV_blank>-D<S2SV_blank>is<S2SV_blank>not<S2SV_blank>available<S2SV_blank>in<S2SV_blank>this<S2SV_blank>Exim<S2SV_blank>binary\\n"" ) ; exit ( EXIT_FAILURE ) ; # else { int ptr = 0 ; macro_item * m ; uschar name [ 24 ] ; uschar * s = argrest ; opt_D_used = TRUE ; while ( isspace ( * s ) ) s ++ ; if ( * s < 'A' || * s > 'Z' ) { fprintf ( stderr , ""exim:<S2SV_blank>macro<S2SV_blank>name<S2SV_blank>set<S2SV_blank>by<S2SV_blank>-D<S2SV_blank>must<S2SV_blank>start<S2SV_blank>with<S2SV_blank>"" ""an<S2SV_blank>upper<S2SV_blank>case<S2SV_blank>letter\\n"" ) ; exit ( EXIT_FAILURE ) ; } while ( isalnum ( * s ) || * s == '_' ) { if ( ptr < sizeof ( name ) - 1 ) name [ ptr ++ ] = * s ; s ++ ; } name [ ptr ] = 0 ; if ( ptr == 0 ) { badarg = TRUE ; break ; } while ( isspace ( * s ) ) s ++ ; if ( * s != 0 ) { if ( * s ++ != '=' ) { badarg = TRUE ; break ; } while ( isspace ( * s ) ) s ++ ; } for ( m = macros ; m ; m = m -> next ) if ( Ustrcmp ( m -> name , name ) == 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>duplicated<S2SV_blank>-D<S2SV_blank>in<S2SV_blank>command<S2SV_blank>line\\n"" ) ; exit ( EXIT_FAILURE ) ; } m = macro_create ( name , s , TRUE , FALSE ) ; if ( clmacro_count >= MAX_CLMACROS ) { fprintf ( stderr , ""exim:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>-D<S2SV_blank>options<S2SV_blank>on<S2SV_blank>command<S2SV_blank>line\\n"" ) ; exit ( EXIT_FAILURE ) ; } clmacros [ clmacro_count ++ ] = string_sprintf ( ""-D%s=%s"" , m -> name , m -> replacement ) ; } # endif break ; case 'd' : if ( Ustrcmp ( argrest , ""ropcr"" ) == 0 ) { } else { unsigned int selector = D_default ; debug_selector = 0 ; debug_file = NULL ; if ( * argrest == 'd' ) { debug_daemon = TRUE ; argrest ++ ; } if ( * argrest != 0 ) decode_bits ( & selector , 1 , debug_notall , argrest , debug_options , debug_options_count , US ""debug"" , 0 ) ; debug_selector = selector ; } break ; case 'E' : local_error_message = TRUE ; if ( mac_ismsgid ( argrest ) ) message_reference = argrest ; break ; case 'e' : if ( Ustrcmp ( argrest , ""e"" ) == 0 ) { arg_error_handling = ERRORS_SENDER ; errors_sender_rc = EXIT_SUCCESS ; } else if ( Ustrcmp ( argrest , ""m"" ) == 0 ) arg_error_handling = ERRORS_SENDER ; else if ( Ustrcmp ( argrest , ""p"" ) == 0 ) arg_error_handling = ERRORS_STDERR ; else if ( Ustrcmp ( argrest , ""q"" ) == 0 ) arg_error_handling = ERRORS_STDERR ; else if ( Ustrcmp ( argrest , ""w"" ) == 0 ) arg_error_handling = ERRORS_SENDER ; else badarg = TRUE ; break ; case 'F' : if ( * argrest == 0 ) { if ( ++ i < argc ) argrest = argv [ i ] ; else { badarg = TRUE ; break ; } } originator_name = argrest ; sender_name_forced = TRUE ; break ; case 'f' : { int dummy_start , dummy_end ; uschar * errmess ; if ( * argrest == 0 ) { if ( i + 1 < argc ) argrest = argv [ ++ i ] ; else { badarg = TRUE ; break ; } } if ( * argrest == 0 ) sender_address = string_sprintf ( """" ) ; else { uschar * temp = argrest + Ustrlen ( argrest ) - 1 ; while ( temp >= argrest && isspace ( * temp ) ) temp -- ; if ( temp >= argrest && * temp == '.' ) f_end_dot = TRUE ; allow_domain_literals = TRUE ; strip_trailing_dot = TRUE ; # ifdef SUPPORT_I18N allow_utf8_domains = TRUE ; # endif sender_address = parse_extract_address ( argrest , & errmess , & dummy_start , & dummy_end , & sender_address_domain , TRUE ) ; # ifdef SUPPORT_I18N message_smtputf8 = string_is_utf8 ( sender_address ) ; allow_utf8_domains = FALSE ; # endif allow_domain_literals = FALSE ; strip_trailing_dot = FALSE ; if ( sender_address == NULL ) { fprintf ( stderr , ""exim:<S2SV_blank>bad<S2SV_blank>-f<S2SV_blank>address<S2SV_blank>\\""%s\\"":<S2SV_blank>%s\\n"" , argrest , errmess ) ; return EXIT_FAILURE ; } } sender_address_forced = TRUE ; } break ; case 'G' : flag_G = TRUE ; break ; case 'h' : if ( * argrest == 0 ) { if ( ++ i < argc ) argrest = argv [ i ] ; else { badarg = TRUE ; break ; } } if ( ! isdigit ( * argrest ) ) badarg = TRUE ; break ; case 'i' : if ( * argrest == 0 ) dot_ends = FALSE ; else badarg = TRUE ; break ; case 'L' : if ( * argrest == '\\0' ) { if ( ++ i < argc ) argrest = argv [ i ] ; else { badarg = TRUE ; break ; } } sz = Ustrlen ( argrest ) ; if ( sz > 32 ) { fprintf ( stderr , ""exim:<S2SV_blank>the<S2SV_blank>-L<S2SV_blank>syslog<S2SV_blank>name<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long:<S2SV_blank>\\""%s\\""\\n"" , argrest ) ; return EXIT_FAILURE ; } if ( sz < 1 ) { fprintf ( stderr , ""exim:<S2SV_blank>the<S2SV_blank>-L<S2SV_blank>syslog<S2SV_blank>name<S2SV_blank>is<S2SV_blank>too<S2SV_blank>short\\n"" ) ; return EXIT_FAILURE ; } cmdline_syslog_name = argrest ; break ; case 'M' : receiving_message = FALSE ; if ( Ustrcmp ( argrest , ""C"" ) == 0 ) { union sockaddr_46 interface_sock ; EXIM_SOCKLEN_T size = sizeof ( interface_sock ) ; if ( argc != i + 6 ) { fprintf ( stderr , ""exim:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>or<S2SV_blank>too<S2SV_blank>few<S2SV_blank>arguments<S2SV_blank>after<S2SV_blank>-MC\\n"" ) ; return EXIT_FAILURE ; } if ( msg_action_arg >= 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>incompatible<S2SV_blank>arguments\\n"" ) ; return EXIT_FAILURE ; } continue_transport = argv [ ++ i ] ; continue_hostname = argv [ ++ i ] ; continue_host_address = argv [ ++ i ] ; continue_sequence = Uatoi ( argv [ ++ i ] ) ; msg_action = MSG_DELIVER ; msg_action_arg = ++ i ; forced_delivery = TRUE ; queue_run_pid = passed_qr_pid ; queue_run_pipe = passed_qr_pipe ; if ( ! mac_ismsgid ( argv [ i ] ) ) { fprintf ( stderr , ""exim:<S2SV_blank>malformed<S2SV_blank>message<S2SV_blank>id<S2SV_blank>%s<S2SV_blank>after<S2SV_blank>-MC<S2SV_blank>option\\n"" , argv [ i ] ) ; return EXIT_FAILURE ; } if ( ! continue_proxy_cipher ) if ( getsockname ( fileno ( stdin ) , ( struct sockaddr * ) ( & interface_sock ) , & size ) == 0 ) sending_ip_address = host_ntoa ( - 1 , & interface_sock , NULL , & sending_port ) ; else { fprintf ( stderr , ""exim:<S2SV_blank>getsockname()<S2SV_blank>failed<S2SV_blank>after<S2SV_blank>-MC<S2SV_blank>option:<S2SV_blank>%s\\n"" , strerror ( errno ) ) ; return EXIT_FAILURE ; } if ( running_in_test_harness ) millisleep ( 500 ) ; break ; } else if ( * argrest == 'C' && argrest [ 1 ] && ! argrest [ 2 ] ) { switch ( argrest [ 1 ] ) { case 'A' : smtp_authenticated = TRUE ; break ; case 'D' : smtp_peer_options |= PEER_OFFERED_DSN ; break ; case 'G' : if ( ++ i < argc ) queue_name = string_copy ( argv [ i ] ) ; else badarg = TRUE ; break ; case 'K' : smtp_peer_options |= PEER_OFFERED_CHUNKING ; break ; case 'P' : smtp_peer_options |= PEER_OFFERED_PIPE ; break ; case 'Q' : if ( ++ i < argc ) passed_qr_pid = ( pid_t ) ( Uatol ( argv [ i ] ) ) ; else badarg = TRUE ; if ( ++ i < argc ) passed_qr_pipe = ( int ) ( Uatol ( argv [ i ] ) ) ; else badarg = TRUE ; break ; case 'S' : smtp_peer_options |= PEER_OFFERED_SIZE ; break ; # ifdef SUPPORT_TLS case 't' : if ( ++ i < argc ) sending_ip_address = argv [ i ] ; else badarg = TRUE ; if ( ++ i < argc ) sending_port = ( int ) ( Uatol ( argv [ i ] ) ) ; else badarg = TRUE ; if ( ++ i < argc ) continue_proxy_cipher = argv [ i ] ; else badarg = TRUE ; case 'T' : smtp_peer_options |= PEER_OFFERED_TLS ; break ; # endif default : badarg = TRUE ; break ; } break ; } else if ( * argrest == 0 ) { msg_action = MSG_DELIVER ; forced_delivery = deliver_force_thaw = TRUE ; } else if ( Ustrcmp ( argrest , ""ar"" ) == 0 ) { msg_action = MSG_ADD_RECIPIENT ; one_msg_action = TRUE ; } else if ( Ustrcmp ( argrest , ""c"" ) == 0 ) msg_action = MSG_DELIVER ; else if ( Ustrcmp ( argrest , ""es"" ) == 0 ) { msg_action = MSG_EDIT_SENDER ; one_msg_action = TRUE ; } else if ( Ustrcmp ( argrest , ""f"" ) == 0 ) msg_action = MSG_FREEZE ; else if ( Ustrcmp ( argrest , ""g"" ) == 0 ) { msg_action = MSG_DELIVER ; deliver_give_up = TRUE ; } else if ( Ustrcmp ( argrest , ""mad"" ) == 0 ) { msg_action = MSG_MARK_ALL_DELIVERED ; } else if ( Ustrcmp ( argrest , ""md"" ) == 0 ) { msg_action = MSG_MARK_DELIVERED ; one_msg_action = TRUE ; } else if ( Ustrcmp ( argrest , ""rm"" ) == 0 ) msg_action = MSG_REMOVE ; else if ( Ustrcmp ( argrest , ""set"" ) == 0 ) { msg_action = MSG_LOAD ; one_msg_action = TRUE ; } else if ( Ustrcmp ( argrest , ""t"" ) == 0 ) msg_action = MSG_THAW ; else if ( Ustrcmp ( argrest , ""vb"" ) == 0 ) { msg_action = MSG_SHOW_BODY ; one_msg_action = TRUE ; } else if ( Ustrcmp ( argrest , ""vc"" ) == 0 ) { msg_action = MSG_SHOW_COPY ; one_msg_action = TRUE ; } else if ( Ustrcmp ( argrest , ""vh"" ) == 0 ) { msg_action = MSG_SHOW_HEADER ; one_msg_action = TRUE ; } else if ( Ustrcmp ( argrest , ""vl"" ) == 0 ) { msg_action = MSG_SHOW_LOG ; one_msg_action = TRUE ; } else { badarg = TRUE ; break ; } msg_action_arg = i + 1 ; if ( msg_action_arg >= argc ) { fprintf ( stderr , ""exim:<S2SV_blank>no<S2SV_blank>message<S2SV_blank>ids<S2SV_blank>given<S2SV_blank>after<S2SV_blank>%s<S2SV_blank>option\\n"" , arg ) ; return EXIT_FAILURE ; } if ( ! one_msg_action ) { int j ; for ( j = msg_action_arg ; j < argc ; j ++ ) if ( ! mac_ismsgid ( argv [ j ] ) ) { fprintf ( stderr , ""exim:<S2SV_blank>malformed<S2SV_blank>message<S2SV_blank>id<S2SV_blank>%s<S2SV_blank>after<S2SV_blank>%s<S2SV_blank>option\\n"" , argv [ j ] , arg ) ; return EXIT_FAILURE ; } goto END_ARG ; } else { if ( ! mac_ismsgid ( argv [ msg_action_arg ] ) ) { fprintf ( stderr , ""exim:<S2SV_blank>malformed<S2SV_blank>message<S2SV_blank>id<S2SV_blank>%s<S2SV_blank>after<S2SV_blank>%s<S2SV_blank>option\\n"" , argv [ msg_action_arg ] , arg ) ; return EXIT_FAILURE ; } i ++ ; } break ; case 'm' : if ( * argrest != 0 ) badarg = TRUE ; break ; case 'N' : if ( * argrest == 0 ) { dont_deliver = TRUE ; debug_selector |= D_v ; debug_file = stderr ; } else badarg = TRUE ; break ; case 'n' : flag_n = TRUE ; break ; case 'O' : if ( * argrest == 0 ) { if ( ++ i >= argc ) { fprintf ( stderr , ""exim:<S2SV_blank>string<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>-O\\n"" ) ; exit ( EXIT_FAILURE ) ; } } break ; case 'o' : if ( * argrest == 'A' ) { alias_arg = argrest + 1 ; if ( alias_arg [ 0 ] == 0 ) { if ( i + 1 < argc ) alias_arg = argv [ ++ i ] ; else { fprintf ( stderr , ""exim:<S2SV_blank>string<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>-oA\\n"" ) ; exit ( EXIT_FAILURE ) ; } } } else if ( * argrest == 'B' ) { uschar * p = argrest + 1 ; if ( p [ 0 ] == 0 ) { if ( i + 1 < argc && isdigit ( ( argv [ i + 1 ] [ 0 ] ) ) ) p = argv [ ++ i ] ; else { connection_max_messages = 1 ; p = NULL ; } } if ( p != NULL ) { if ( ! isdigit ( * p ) ) { fprintf ( stderr , ""exim:<S2SV_blank>number<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>-oB\\n"" ) ; exit ( EXIT_FAILURE ) ; } connection_max_messages = Uatoi ( p ) ; } } else if ( Ustrcmp ( argrest , ""db"" ) == 0 ) { synchronous_delivery = FALSE ; arg_queue_only = FALSE ; queue_only_set = TRUE ; } else if ( Ustrcmp ( argrest , ""df"" ) == 0 || Ustrcmp ( argrest , ""di"" ) == 0 ) { synchronous_delivery = TRUE ; arg_queue_only = FALSE ; queue_only_set = TRUE ; } else if ( Ustrcmp ( argrest , ""dq"" ) == 0 ) { synchronous_delivery = FALSE ; arg_queue_only = TRUE ; queue_only_set = TRUE ; } else if ( Ustrcmp ( argrest , ""dqs"" ) == 0 ) { queue_smtp = TRUE ; arg_queue_only = FALSE ; queue_only_set = TRUE ; } else if ( Ustrcmp ( argrest , ""i"" ) == 0 || Ustrcmp ( argrest , ""itrue"" ) == 0 ) dot_ends = FALSE ; else if ( * argrest == 'M' ) { if ( i + 1 >= argc ) { fprintf ( stderr , ""exim:<S2SV_blank>data<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>-o%s\\n"" , argrest ) ; exit ( EXIT_FAILURE ) ; } if ( Ustrcmp ( argrest , ""Ma"" ) == 0 ) sender_host_address = argv [ ++ i ] ; else if ( Ustrcmp ( argrest , ""Maa"" ) == 0 ) sender_host_authenticated = argv [ ++ i ] ; else if ( Ustrcmp ( argrest , ""Mas"" ) == 0 ) authenticated_sender = argv [ ++ i ] ; else if ( Ustrcmp ( argrest , ""Mai"" ) == 0 ) authenticated_id = argv [ ++ i ] ; else if ( Ustrcmp ( argrest , ""Mi"" ) == 0 ) interface_address = argv [ ++ i ] ; else if ( Ustrcmp ( argrest , ""Mm"" ) == 0 ) { if ( ! mac_ismsgid ( argv [ i + 1 ] ) ) { fprintf ( stderr , ""-oMm<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>message<S2SV_blank>ID\\n"" ) ; exit ( EXIT_FAILURE ) ; } if ( ! trusted_config ) { fprintf ( stderr , ""-oMm<S2SV_blank>must<S2SV_blank>be<S2SV_blank>called<S2SV_blank>by<S2SV_blank>a<S2SV_blank>trusted<S2SV_blank>user/config\\n"" ) ; exit ( EXIT_FAILURE ) ; } message_reference = argv [ ++ i ] ; }  else if ( Ustrcmp ( argrest , ""Mr"" ) == 0 ) received_protocol = argv [ ++ i ] ;  else if ( Ustrcmp ( argrest , ""Ms"" ) == 0 ) sender_host_name = argv [ ++ i ] ; else if ( Ustrcmp ( argrest , ""Mt"" ) == 0 ) { sender_ident_set = TRUE ; sender_ident = argv [ ++ i ] ; } else { badarg = TRUE ; break ; } } else if ( Ustrcmp ( argrest , ""m"" ) == 0 ) { } else if ( Ustrcmp ( argrest , ""o"" ) == 0 ) { } else if ( Ustrcmp ( argrest , ""P"" ) == 0 ) override_pid_file_path = argv [ ++ i ] ; else if ( * argrest == 'r' || * argrest == 's' ) { int * tp = ( * argrest == 'r' ) ? & arg_receive_timeout : & arg_smtp_receive_timeout ; if ( argrest [ 1 ] == 0 ) { if ( i + 1 < argc ) * tp = readconf_readtime ( argv [ ++ i ] , 0 , FALSE ) ; } else * tp = readconf_readtime ( argrest + 1 , 0 , FALSE ) ; if ( * tp < 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>bad<S2SV_blank>time<S2SV_blank>value<S2SV_blank>%s:<S2SV_blank>abandoned\\n"" , argv [ i ] ) ; exit ( EXIT_FAILURE ) ; } } else if ( Ustrcmp ( argrest , ""X"" ) == 0 ) override_local_interfaces = argv [ ++ i ] ; else badarg = TRUE ; break ; case 'p' : # ifdef EXIM_PERL if ( * argrest == 's' && argrest [ 1 ] == 0 ) { perl_start_option = 1 ; break ; } if ( * argrest == 'd' && argrest [ 1 ] == 0 ) { perl_start_option = - 1 ; break ; } # endif if ( * argrest == 0 ) { if ( i + 1 < argc ) argrest = argv [ ++ i ] ; else { badarg = TRUE ; break ; } } if ( * argrest != 0 ) {  uschar * hn = Ustrchr ( argrest , ':' ) ;  if ( hn == NULL ) { received_protocol = argrest ; } else { int old_pool = store_pool ; store_pool = POOL_PERM ; received_protocol = string_copyn ( argrest , hn - argrest ) ; store_pool = old_pool ; sender_host_name = hn + 1 ; } } break ; case 'q' : receiving_message = FALSE ; if ( queue_interval >= 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>-q<S2SV_blank>specified<S2SV_blank>more<S2SV_blank>than<S2SV_blank>once\\n"" ) ; exit ( EXIT_FAILURE ) ; } if ( * argrest == 'q' ) { queue_2stage = TRUE ; argrest ++ ; } if ( * argrest == 'i' ) { queue_run_first_delivery = TRUE ; argrest ++ ; } if ( * argrest == 'f' ) { queue_run_force = TRUE ; if ( * ++ argrest == 'f' ) { deliver_force_thaw = TRUE ; argrest ++ ; } } if ( * argrest == 'l' ) { queue_run_local = TRUE ; argrest ++ ; } if ( * argrest == 'G' ) { int i ; for ( argrest ++ , i = 0 ; argrest [ i ] && argrest [ i ] != '/' ; ) i ++ ; queue_name = string_copyn ( argrest , i ) ; argrest += i ; if ( * argrest == '/' ) argrest ++ ; } if ( * argrest == 0 && ( i + 1 >= argc || argv [ i + 1 ] [ 0 ] == '-' || mac_ismsgid ( argv [ i + 1 ] ) ) ) { queue_interval = 0 ; if ( i + 1 < argc && mac_ismsgid ( argv [ i + 1 ] ) ) start_queue_run_id = argv [ ++ i ] ; if ( i + 1 < argc && mac_ismsgid ( argv [ i + 1 ] ) ) stop_queue_run_id = argv [ ++ i ] ; } else if ( ( queue_interval = readconf_readtime ( * argrest ? argrest : argv [ ++ i ] , 0 , FALSE ) ) <= 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>bad<S2SV_blank>time<S2SV_blank>value<S2SV_blank>%s:<S2SV_blank>abandoned\\n"" , argv [ i ] ) ; exit ( EXIT_FAILURE ) ; } break ; case 'R' : receiving_message = FALSE ; if ( * argrest != 0 ) { int i ; for ( i = 0 ; i < nelem ( rsopts ) ; i ++ ) if ( Ustrcmp ( argrest , rsopts [ i ] ) == 0 ) { if ( i != 2 ) queue_run_force = TRUE ; if ( i >= 2 ) deliver_selectstring_regex = TRUE ; if ( i == 1 || i == 4 ) deliver_force_thaw = TRUE ; argrest += Ustrlen ( rsopts [ i ] ) ; } } if ( * argrest ) deliver_selectstring = argrest ; else if ( i + 1 < argc ) deliver_selectstring = argv [ ++ i ] ; else { fprintf ( stderr , ""exim:<S2SV_blank>string<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>-R\\n"" ) ; exit ( EXIT_FAILURE ) ; } break ; case 'S' : receiving_message = FALSE ; if ( * argrest ) { int i ; for ( i = 0 ; i < nelem ( rsopts ) ; i ++ ) if ( Ustrcmp ( argrest , rsopts [ i ] ) == 0 ) { if ( i != 2 ) queue_run_force = TRUE ; if ( i >= 2 ) deliver_selectstring_sender_regex = TRUE ; if ( i == 1 || i == 4 ) deliver_force_thaw = TRUE ; argrest += Ustrlen ( rsopts [ i ] ) ; } } if ( * argrest ) deliver_selectstring_sender = argrest ; else if ( i + 1 < argc ) deliver_selectstring_sender = argv [ ++ i ] ; else { fprintf ( stderr , ""exim:<S2SV_blank>string<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>-S\\n"" ) ; exit ( EXIT_FAILURE ) ; } break ; case 'T' : if ( running_in_test_harness && Ustrcmp ( argrest , ""qt"" ) == 0 ) fudged_queue_times = argv [ ++ i ] ; else badarg = TRUE ; break ; case 't' : if ( * argrest == 0 ) extract_recipients = TRUE ; else if ( Ustrcmp ( argrest , ""i"" ) == 0 ) { extract_recipients = TRUE ; dot_ends = FALSE ; } # ifdef SUPPORT_TLS else if ( Ustrcmp ( argrest , ""ls-on-connect"" ) == 0 ) tls_in . on_connect = TRUE ; # endif else badarg = TRUE ; break ; case 'U' : break ; case 'v' : if ( * argrest == 0 ) { debug_selector |= D_v ; debug_file = stderr ; } else badarg = TRUE ; break ; case 'x' : if ( * argrest != 0 ) badarg = TRUE ; break ; case 'X' : if ( * argrest == '\\0' ) if ( ++ i >= argc ) { fprintf ( stderr , ""exim:<S2SV_blank>string<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>-X\\n"" ) ; exit ( EXIT_FAILURE ) ; } break ; case 'z' : if ( * argrest == '\\0' ) if ( ++ i < argc ) log_oneline = argv [ i ] ; else { fprintf ( stderr , ""exim:<S2SV_blank>file<S2SV_blank>name<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>%s\\n"" , argv [ i - 1 ] ) ; exit ( EXIT_FAILURE ) ; } break ; default : badarg = TRUE ; break ; } if ( badarg ) { fprintf ( stderr , ""exim<S2SV_blank>abandoned:<S2SV_blank>unknown,<S2SV_blank>malformed,<S2SV_blank>or<S2SV_blank>incomplete<S2SV_blank>"" ""option<S2SV_blank>%s\\n"" , arg ) ; exit ( EXIT_FAILURE ) ; } } if ( ( deliver_selectstring || deliver_selectstring_sender ) && queue_interval < 0 ) queue_interval = 0 ; END_ARG : if ( usage_wanted ) exim_usage ( called_as ) ; if ( ( ( smtp_input || extract_recipients || recipients_arg < argc ) && ( daemon_listen || queue_interval >= 0 || bi_option || test_retry_arg >= 0 || test_rewrite_arg >= 0 || filter_test != FTEST_NONE || ( msg_action_arg > 0 && ! one_msg_action ) ) ) || ( msg_action_arg > 0 && ( daemon_listen || queue_interval > 0 || list_options || ( checking && msg_action != MSG_LOAD ) || bi_option || test_retry_arg >= 0 || test_rewrite_arg >= 0 ) ) || ( ( daemon_listen || queue_interval > 0 ) && ( sender_address != NULL || list_options || list_queue || checking || bi_option ) ) || ( daemon_listen && queue_interval == 0 ) || ( inetd_wait_mode && queue_interval >= 0 ) || ( list_options && ( checking || smtp_input || extract_recipients || filter_test != FTEST_NONE || bi_option ) ) || ( verify_address_mode && ( address_test_mode || smtp_input || extract_recipients || filter_test != FTEST_NONE || bi_option ) ) || ( address_test_mode && ( smtp_input || extract_recipients || filter_test != FTEST_NONE || bi_option ) ) || ( smtp_input && ( sender_address != NULL || filter_test != FTEST_NONE || extract_recipients ) ) || ( deliver_selectstring != NULL && queue_interval < 0 ) || ( msg_action == MSG_LOAD && ( ! expansion_test || expansion_test_message != NULL ) ) ) { fprintf ( stderr , ""exim:<S2SV_blank>incompatible<S2SV_blank>command-line<S2SV_blank>options<S2SV_blank>or<S2SV_blank>arguments\\n"" ) ; exit ( EXIT_FAILURE ) ; } if ( debug_selector != 0 ) { debug_file = stderr ; debug_fd = fileno ( debug_file ) ; background_daemon = FALSE ; if ( running_in_test_harness ) millisleep ( 100 ) ; if ( debug_selector != D_v ) { debug_printf ( ""Exim<S2SV_blank>version<S2SV_blank>%s<S2SV_blank>uid=%ld<S2SV_blank>gid=%ld<S2SV_blank>pid=%d<S2SV_blank>D=%x\\n"" , version_string , ( long int ) real_uid , ( long int ) real_gid , ( int ) getpid ( ) , debug_selector ) ; if ( ! version_printed ) show_whats_supported ( stderr ) ; } } if ( unprivileged ) { DEBUG ( D_any ) debug_print_ids ( US ""Exim<S2SV_blank>has<S2SV_blank>no<S2SV_blank>root<S2SV_blank>privilege:"" ) ; } else { struct rlimit rlp ; # ifdef RLIMIT_NOFILE if ( getrlimit ( RLIMIT_NOFILE , & rlp ) < 0 ) { log_write ( 0 , LOG_MAIN | LOG_PANIC , ""getrlimit(RLIMIT_NOFILE)<S2SV_blank>failed:<S2SV_blank>%s"" , strerror ( errno ) ) ; rlp . rlim_cur = rlp . rlim_max = 0 ; } if ( rlp . rlim_cur < 1000 ) { rlp . rlim_cur = rlp . rlim_max = 1000 ; if ( setrlimit ( RLIMIT_NOFILE , & rlp ) < 0 ) { rlp . rlim_cur = rlp . rlim_max = 256 ; if ( setrlimit ( RLIMIT_NOFILE , & rlp ) < 0 ) log_write ( 0 , LOG_MAIN | LOG_PANIC , ""setrlimit(RLIMIT_NOFILE)<S2SV_blank>failed:<S2SV_blank>%s"" , strerror ( errno ) ) ; } } # endif # ifdef RLIMIT_NPROC if ( getrlimit ( RLIMIT_NPROC , & rlp ) < 0 ) { log_write ( 0 , LOG_MAIN | LOG_PANIC , ""getrlimit(RLIMIT_NPROC)<S2SV_blank>failed:<S2SV_blank>%s"" , strerror ( errno ) ) ; rlp . rlim_cur = rlp . rlim_max = 0 ; } # ifdef RLIM_INFINITY if ( rlp . rlim_cur != RLIM_INFINITY && rlp . rlim_cur < 1000 ) { rlp . rlim_cur = rlp . rlim_max = RLIM_INFINITY ; # else if ( rlp . rlim_cur < 1000 ) { rlp . rlim_cur = rlp . rlim_max = 1000 ; # endif if ( setrlimit ( RLIMIT_NPROC , & rlp ) < 0 ) log_write ( 0 , LOG_MAIN | LOG_PANIC , ""setrlimit(RLIMIT_NPROC)<S2SV_blank>failed:<S2SV_blank>%s"" , strerror ( errno ) ) ; } # endif } group_count = getgroups ( NGROUPS_MAX , group_list ) ; if ( group_count < 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>getgroups()<S2SV_blank>failed:<S2SV_blank>%s\\n"" , strerror ( errno ) ) ; exit ( EXIT_FAILURE ) ; } if ( setgroups ( 0 , NULL ) != 0 ) { if ( setgroups ( 1 , group_list ) != 0 && ! unprivileged ) { fprintf ( stderr , ""exim:<S2SV_blank>setgroups()<S2SV_blank>failed:<S2SV_blank>%s\\n"" , strerror ( errno ) ) ; exit ( EXIT_FAILURE ) ; } } if ( ( ( ! trusted_config || ! macros_trusted ( opt_D_used ) ) && real_uid != root_uid && ! running_in_test_harness ) || expansion_test || filter_test != FTEST_NONE ) { setgroups ( group_count , group_list ) ; exim_setugid ( real_uid , real_gid , FALSE , US ""-C,<S2SV_blank>-D,<S2SV_blank>-be<S2SV_blank>or<S2SV_blank>-bf<S2SV_blank>forces<S2SV_blank>real<S2SV_blank>uid"" ) ; removed_privilege = TRUE ; if ( ( log_stderr != NULL ) && ( real_uid != exim_uid ) ) really_exim = FALSE ; } else exim_setugid ( geteuid ( ) , getegid ( ) , FALSE , US ""forcing<S2SV_blank>real<S2SV_blank>=<S2SV_blank>effective"" ) ; if ( ( filter_test & FTEST_SYSTEM ) != 0 ) { filter_sfd = Uopen ( filter_test_sfile , O_RDONLY , 0 ) ; if ( filter_sfd < 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s:<S2SV_blank>%s\\n"" , filter_test_sfile , strerror ( errno ) ) ; return EXIT_FAILURE ; } } if ( ( filter_test & FTEST_USER ) != 0 ) { filter_ufd = Uopen ( filter_test_ufile , O_RDONLY , 0 ) ; if ( filter_ufd < 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s:<S2SV_blank>%s\\n"" , filter_test_ufile , strerror ( errno ) ) ; return EXIT_FAILURE ; } } init_lookup_list ( ) ; # ifdef SUPPORT_I18N if ( running_in_test_harness ) smtputf8_advertise_hosts = NULL ; # endif if ( ( initial_cwd = os_getcwd ( NULL , 0 ) ) == NULL ) { perror ( ""exim:<S2SV_blank>can\'t<S2SV_blank>get<S2SV_blank>the<S2SV_blank>current<S2SV_blank>working<S2SV_blank>directory"" ) ; exit ( EXIT_FAILURE ) ; } readconf_main ( checking || list_options ) ; if ( builtin_macros_create_trigger ) DEBUG ( D_any ) debug_printf ( ""Builtin<S2SV_blank>macros<S2SV_blank>created<S2SV_blank>(expensive)<S2SV_blank>due<S2SV_blank>to<S2SV_blank>config<S2SV_blank>line<S2SV_blank>\'%.*s\'\\n"" , Ustrlen ( builtin_macros_create_trigger ) - 1 , builtin_macros_create_trigger ) ; if ( cleanup_environment ( ) == FALSE ) log_write ( 0 , LOG_PANIC_DIE , ""Can\'t<S2SV_blank>cleanup<S2SV_blank>environment"" ) ; if ( real_uid == root_uid || real_uid == exim_uid || real_gid == exim_gid ) admin_user = TRUE ; else { int i , j ; for ( i = 0 ; i < group_count && ! admin_user ; i ++ ) if ( group_list [ i ] == exim_gid ) admin_user = TRUE ; else if ( admin_groups ) for ( j = 1 ; j <= ( int ) admin_groups [ 0 ] && ! admin_user ; j ++ ) if ( admin_groups [ j ] == group_list [ i ] ) admin_user = TRUE ; } if ( real_uid == root_uid || real_uid == exim_uid ) trusted_caller = TRUE ; else { int i , j ; if ( trusted_users ) for ( i = 1 ; i <= ( int ) trusted_users [ 0 ] && ! trusted_caller ; i ++ ) if ( trusted_users [ i ] == real_uid ) trusted_caller = TRUE ; if ( trusted_groups ) for ( i = 1 ; i <= ( int ) trusted_groups [ 0 ] && ! trusted_caller ; i ++ ) if ( trusted_groups [ i ] == real_gid ) trusted_caller = TRUE ; else for ( j = 0 ; j < group_count && ! trusted_caller ; j ++ ) if ( trusted_groups [ i ] == group_list [ j ] ) trusted_caller = TRUE ; } if ( checking && commandline_checks_require_admin && ! admin_user ) { fprintf ( stderr , ""exim:<S2SV_blank>those<S2SV_blank>command-line<S2SV_blank>flags<S2SV_blank>are<S2SV_blank>set<S2SV_blank>to<S2SV_blank>require<S2SV_blank>admin\\n"" ) ; exit ( EXIT_FAILURE ) ; } decode_bits ( log_selector , log_selector_size , log_notall , log_selector_string , log_options , log_options_count , US ""log"" , 0 ) ; DEBUG ( D_any ) { int i ; debug_printf ( ""configuration<S2SV_blank>file<S2SV_blank>is<S2SV_blank>%s\\n"" , config_main_filename ) ; debug_printf ( ""log<S2SV_blank>selectors<S2SV_blank>="" ) ; for ( i = 0 ; i < log_selector_size ; i ++ ) debug_printf ( ""<S2SV_blank>%08x"" , log_selector [ i ] ) ; debug_printf ( ""\\n"" ) ; } if ( sender_address != NULL ) { if ( sender_address [ sender_address_domain ] == '[' && ! allow_domain_literals ) { fprintf ( stderr , ""exim:<S2SV_blank>bad<S2SV_blank>-f<S2SV_blank>address<S2SV_blank>\\""%s\\"":<S2SV_blank>domain<S2SV_blank>literals<S2SV_blank>not<S2SV_blank>"" ""allowed\\n"" , sender_address ) ; return EXIT_FAILURE ; } if ( f_end_dot && ! strip_trailing_dot ) { fprintf ( stderr , ""exim:<S2SV_blank>bad<S2SV_blank>-f<S2SV_blank>address<S2SV_blank>\\""%s.\\"":<S2SV_blank>domain<S2SV_blank>is<S2SV_blank>malformed<S2SV_blank>"" ""(trailing<S2SV_blank>dot<S2SV_blank>not<S2SV_blank>allowed)\\n"" , sender_address ) ; return EXIT_FAILURE ; } } if ( cmdline_syslog_name != NULL ) { if ( admin_user ) { syslog_processname = cmdline_syslog_name ; log_file_path = string_copy ( CUS ""syslog"" ) ; } else { fprintf ( stderr , ""exim:<S2SV_blank>you<S2SV_blank>lack<S2SV_blank>sufficient<S2SV_blank>privilege<S2SV_blank>to<S2SV_blank>specify<S2SV_blank>syslog<S2SV_blank>process<S2SV_blank>name\\n"" ) ; return EXIT_FAILURE ; } } if ( Ustrlen ( log_file_path ) > 200 ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , ""log_file_path<S2SV_blank>is<S2SV_blank>longer<S2SV_blank>than<S2SV_blank>200<S2SV_blank>chars:<S2SV_blank>aborting"" ) ; if ( Ustrlen ( pid_file_path ) > 200 ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , ""pid_file_path<S2SV_blank>is<S2SV_blank>longer<S2SV_blank>than<S2SV_blank>200<S2SV_blank>chars:<S2SV_blank>aborting"" ) ; if ( Ustrlen ( spool_directory ) > 200 ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , ""spool_directory<S2SV_blank>is<S2SV_blank>longer<S2SV_blank>than<S2SV_blank>200<S2SV_blank>chars:<S2SV_blank>aborting"" ) ; if ( Ustrlen ( syslog_processname ) > 32 ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , ""syslog_processname<S2SV_blank>is<S2SV_blank>longer<S2SV_blank>than<S2SV_blank>32<S2SV_blank>chars:<S2SV_blank>aborting"" ) ; if ( log_oneline ) if ( admin_user ) { log_write ( 0 , LOG_MAIN , ""%s"" , log_oneline ) ; return EXIT_SUCCESS ; } else return EXIT_FAILURE ; # ifdef EXIM_TMPDIR { uschar * * p ; if ( environ ) for ( p = USS environ ; * p ; p ++ ) if ( Ustrncmp ( * p , ""TMPDIR="" , 7 ) == 0 && Ustrcmp ( * p + 7 , EXIM_TMPDIR ) != 0 ) { uschar * newp = store_malloc ( Ustrlen ( EXIM_TMPDIR ) + 8 ) ; sprintf ( CS newp , ""TMPDIR=%s"" , EXIM_TMPDIR ) ; * p = newp ; DEBUG ( D_any ) debug_printf ( ""reset<S2SV_blank>TMPDIR=%s<S2SV_blank>in<S2SV_blank>environment\\n"" , EXIM_TMPDIR ) ; } } # endif if ( timezone_string && strcmpic ( timezone_string , US ""UTC"" ) == 0 ) timestamps_utc = TRUE ; else { uschar * envtz = US getenv ( ""TZ"" ) ; if ( envtz ? ! timezone_string || Ustrcmp ( timezone_string , envtz ) != 0 : timezone_string != NULL ) { uschar * * p = USS environ ; uschar * * new ; uschar * * newp ; int count = 0 ; if ( environ ) while ( * p ++ ) count ++ ; if ( ! envtz ) count ++ ; newp = new = store_malloc ( sizeof ( uschar * ) * ( count + 1 ) ) ; if ( environ ) for ( p = USS environ ; * p ; p ++ ) if ( Ustrncmp ( * p , ""TZ="" , 3 ) != 0 ) * newp ++ = * p ; if ( timezone_string ) { * newp = store_malloc ( Ustrlen ( timezone_string ) + 4 ) ; sprintf ( CS * newp ++ , ""TZ=%s"" , timezone_string ) ; } * newp = NULL ; environ = CSS new ; tzset ( ) ; DEBUG ( D_any ) debug_printf ( ""Reset<S2SV_blank>TZ<S2SV_blank>to<S2SV_blank>%s:<S2SV_blank>time<S2SV_blank>is<S2SV_blank>%s\\n"" , timezone_string , tod_stamp ( tod_log ) ) ; } } if ( removed_privilege && ( ! trusted_config || opt_D_used ) && real_uid == exim_uid ) if ( deliver_drop_privilege ) really_exim = TRUE ; else log_write ( 0 , LOG_MAIN | LOG_PANIC , ""exim<S2SV_blank>user<S2SV_blank>lost<S2SV_blank>privilege<S2SV_blank>for<S2SV_blank>using<S2SV_blank>%s<S2SV_blank>option"" , trusted_config ? ""-D"" : ""-C"" ) ; # ifdef EXIM_PERL if ( perl_start_option != 0 ) opt_perl_at_start = ( perl_start_option > 0 ) ; if ( opt_perl_at_start && opt_perl_startup != NULL ) { uschar * errstr ; DEBUG ( D_any ) debug_printf ( ""Starting<S2SV_blank>Perl<S2SV_blank>interpreter\\n"" ) ; errstr = init_perl ( opt_perl_startup ) ; if ( errstr != NULL ) { fprintf ( stderr , ""exim:<S2SV_blank>error<S2SV_blank>in<S2SV_blank>perl_startup<S2SV_blank>code:<S2SV_blank>%s\\n"" , errstr ) ; return EXIT_FAILURE ; } opt_perl_started = TRUE ; } # endif if ( ( ( debug_selector & D_any ) != 0 || LOGGING ( arguments ) ) && really_exim && ! list_options && ! checking ) { int i ; uschar * p = big_buffer ; Ustrcpy ( p , ""cwd=<S2SV_blank>(failed)"" ) ; Ustrncpy ( p + 4 , initial_cwd , big_buffer_size - 5 ) ; while ( * p ) p ++ ; ( void ) string_format ( p , big_buffer_size - ( p - big_buffer ) , ""<S2SV_blank>%d<S2SV_blank>args:"" , argc ) ; while ( * p ) p ++ ; for ( i = 0 ; i < argc ; i ++ ) { int len = Ustrlen ( argv [ i ] ) ; const uschar * printing ; uschar * quote ; if ( p + len + 8 >= big_buffer + big_buffer_size ) { Ustrcpy ( p , ""<S2SV_blank>..."" ) ; log_write ( 0 , LOG_MAIN , ""%s"" , big_buffer ) ; Ustrcpy ( big_buffer , ""..."" ) ; p = big_buffer + 3 ; } printing = string_printing ( argv [ i ] ) ; if ( printing [ 0 ] == 0 ) quote = US ""\\"""" ; else { const uschar * pp = printing ; quote = US """" ; while ( * pp != 0 ) if ( isspace ( * pp ++ ) ) { quote = US ""\\"""" ; break ; } } sprintf ( CS p , ""<S2SV_blank>%s%.*s%s"" , quote , ( int ) ( big_buffer_size - ( p - big_buffer ) - 4 ) , printing , quote ) ; while ( * p ) p ++ ; } if ( LOGGING ( arguments ) ) log_write ( 0 , LOG_MAIN , ""%s"" , big_buffer ) ; else debug_printf ( ""%s\\n"" , big_buffer ) ; } if ( Uchdir ( spool_directory ) != 0 ) { int dummy ; ( void ) directory_make ( spool_directory , US """" , SPOOL_DIRECTORY_MODE , FALSE ) ; dummy = Uchdir ( spool_directory ) ; } if ( bi_option ) { ( void ) fclose ( config_file ) ; if ( bi_command != NULL ) { int i = 0 ; uschar * argv [ 3 ] ; argv [ i ++ ] = bi_command ; if ( alias_arg != NULL ) argv [ i ++ ] = alias_arg ; argv [ i ++ ] = NULL ; setgroups ( group_count , group_list ) ; exim_setugid ( real_uid , real_gid , FALSE , US ""running<S2SV_blank>bi_command"" ) ; DEBUG ( D_exec ) debug_printf ( ""exec<S2SV_blank>%.256s<S2SV_blank>%.256s\\n"" , argv [ 0 ] , ( argv [ 1 ] == NULL ) ? US """" : argv [ 1 ] ) ; execv ( CS argv [ 0 ] , ( char * const * ) argv ) ; fprintf ( stderr , ""exim:<S2SV_blank>exec<S2SV_blank>failed:<S2SV_blank>%s\\n"" , strerror ( errno ) ) ; exit ( EXIT_FAILURE ) ; } else { DEBUG ( D_any ) debug_printf ( ""-bi<S2SV_blank>used<S2SV_blank>but<S2SV_blank>bi_command<S2SV_blank>not<S2SV_blank>set;<S2SV_blank>exiting\\n"" ) ; exit ( EXIT_SUCCESS ) ; } } if ( trusted_caller ) DEBUG ( D_any ) debug_printf ( ""trusted<S2SV_blank>user\\n"" ) ; if ( admin_user ) DEBUG ( D_any ) debug_printf ( ""admin<S2SV_blank>user\\n"" ) ; if ( ! admin_user ) { BOOL debugset = ( debug_selector & ~ D_v ) != 0 ; if ( deliver_give_up || daemon_listen || malware_test_file || ( count_queue && queue_list_requires_admin ) || ( list_queue && queue_list_requires_admin ) || ( queue_interval >= 0 && prod_requires_admin ) || ( debugset && ! running_in_test_harness ) ) { fprintf ( stderr , ""exim:%s<S2SV_blank>permission<S2SV_blank>denied\\n"" , debugset ? ""<S2SV_blank>debugging"" : """" ) ; exit ( EXIT_FAILURE ) ; } } if ( real_uid != root_uid && real_uid != exim_uid && ( continue_hostname != NULL || ( dont_deliver && ( queue_interval >= 0 || daemon_listen || msg_action_arg > 0 ) ) ) && ! running_in_test_harness ) { fprintf ( stderr , ""exim:<S2SV_blank>Permission<S2SV_blank>denied\\n"" ) ; return EXIT_FAILURE ; } if ( ! trusted_caller && ! checking ) { sender_host_name = sender_host_address = interface_address = sender_ident = received_protocol = NULL ; sender_host_port = interface_port = 0 ; sender_host_authenticated = authenticated_sender = authenticated_id = NULL ; } else { if ( sender_host_address != NULL ) sender_host_port = check_port ( sender_host_address ) ; if ( interface_address != NULL ) interface_port = check_port ( interface_address ) ; } if ( flag_G ) { if ( trusted_caller ) { suppress_local_fixups = suppress_local_fixups_default = TRUE ; DEBUG ( D_acl ) debug_printf ( ""suppress_local_fixups<S2SV_blank>forced<S2SV_blank>on<S2SV_blank>by<S2SV_blank>-G\\n"" ) ; } else { fprintf ( stderr , ""exim:<S2SV_blank>permission<S2SV_blank>denied<S2SV_blank>(-G<S2SV_blank>requires<S2SV_blank>a<S2SV_blank>trusted<S2SV_blank>user)\\n"" ) ; return EXIT_FAILURE ; } } if ( smtp_input ) { union sockaddr_46 inetd_sock ; EXIM_SOCKLEN_T size = sizeof ( inetd_sock ) ; if ( getpeername ( 0 , ( struct sockaddr * ) ( & inetd_sock ) , & size ) == 0 ) { int family = ( ( struct sockaddr * ) ( & inetd_sock ) ) -> sa_family ; if ( family == AF_INET || family == AF_INET6 ) { union sockaddr_46 interface_sock ; size = sizeof ( interface_sock ) ; if ( getsockname ( 0 , ( struct sockaddr * ) ( & interface_sock ) , & size ) == 0 ) interface_address = host_ntoa ( - 1 , & interface_sock , NULL , & interface_port ) ; if ( host_is_tls_on_connect_port ( interface_port ) ) tls_in . on_connect = TRUE ; if ( real_uid == root_uid || real_uid == exim_uid || interface_port < 1024 ) { is_inetd = TRUE ; sender_host_address = host_ntoa ( - 1 , ( struct sockaddr * ) ( & inetd_sock ) , NULL , & sender_host_port ) ; if ( mua_wrapper ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , ""Input<S2SV_blank>from<S2SV_blank>"" ""inetd<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>when<S2SV_blank>mua_wrapper<S2SV_blank>is<S2SV_blank>set"" ) ; } else { fprintf ( stderr , ""exim:<S2SV_blank>Permission<S2SV_blank>denied<S2SV_blank>(unprivileged<S2SV_blank>user,<S2SV_blank>unprivileged<S2SV_blank>port)\\n"" ) ; return EXIT_FAILURE ; } } } } # ifdef LOAD_AVG_NEEDS_ROOT if ( receiving_message && ( queue_only_load >= 0 || ( is_inetd && smtp_load_reserve >= 0 ) ) ) { load_average = OS_GETLOADAVG ( ) ; } # endif if ( queue_only_set && ( queue_only_override || arg_queue_only ) ) queue_only = arg_queue_only ; if ( arg_receive_timeout >= 0 ) receive_timeout = arg_receive_timeout ; if ( arg_smtp_receive_timeout >= 0 ) smtp_receive_timeout = arg_smtp_receive_timeout ; if ( ! unprivileged && ! removed_privilege && ! daemon_listen && queue_interval <= 0 && ( deliver_drop_privilege || ( queue_interval < 0 && ( msg_action_arg < 0 || msg_action != MSG_DELIVER ) && ( ! checking || ! address_test_mode ) ) ) ) exim_setugid ( exim_uid , exim_gid , TRUE , US ""privilege<S2SV_blank>not<S2SV_blank>needed"" ) ; else { int rv ; rv = setgid ( exim_gid ) ; if ( rv == - 1 ) if ( ! ( unprivileged || removed_privilege ) ) { fprintf ( stderr , ""exim:<S2SV_blank>changing<S2SV_blank>group<S2SV_blank>failed:<S2SV_blank>%s\\n"" , strerror ( errno ) ) ; exit ( EXIT_FAILURE ) ; } else DEBUG ( D_any ) debug_printf ( ""changing<S2SV_blank>group<S2SV_blank>to<S2SV_blank>%ld<S2SV_blank>failed:<S2SV_blank>%s\\n"" , ( long int ) exim_gid , strerror ( errno ) ) ; } if ( malware_test_file ) { # ifdef WITH_CONTENT_SCAN int result ; set_process_info ( ""scanning<S2SV_blank>file<S2SV_blank>for<S2SV_blank>malware"" ) ; result = malware_in_file ( malware_test_file ) ; if ( result == FAIL ) { printf ( ""No<S2SV_blank>malware<S2SV_blank>found.\\n"" ) ; exit ( EXIT_SUCCESS ) ; } if ( result != OK ) { printf ( ""Malware<S2SV_blank>lookup<S2SV_blank>returned<S2SV_blank>non-okay/fail:<S2SV_blank>%d\\n"" , result ) ; exit ( EXIT_FAILURE ) ; } if ( malware_name ) printf ( ""Malware<S2SV_blank>found:<S2SV_blank>%s\\n"" , malware_name ) ; else printf ( ""Malware<S2SV_blank>scan<S2SV_blank>detected<S2SV_blank>malware<S2SV_blank>of<S2SV_blank>unknown<S2SV_blank>name.\\n"" ) ; # else printf ( ""Malware<S2SV_blank>scanning<S2SV_blank>not<S2SV_blank>enabled<S2SV_blank>at<S2SV_blank>compile<S2SV_blank>time.\\n"" ) ; # endif exit ( EXIT_FAILURE ) ; } if ( list_queue ) { set_process_info ( ""listing<S2SV_blank>the<S2SV_blank>queue"" ) ; queue_list ( list_queue_option , argv + recipients_arg , argc - recipients_arg ) ; exit ( EXIT_SUCCESS ) ; } if ( count_queue ) { set_process_info ( ""counting<S2SV_blank>the<S2SV_blank>queue"" ) ; queue_count ( ) ; exit ( EXIT_SUCCESS ) ; } if ( msg_action_arg > 0 && msg_action != MSG_DELIVER && msg_action != MSG_LOAD ) { int yield = EXIT_SUCCESS ; set_process_info ( ""acting<S2SV_blank>on<S2SV_blank>specified<S2SV_blank>messages"" ) ; if ( ! one_msg_action ) { for ( i = msg_action_arg ; i < argc ; i ++ ) if ( ! queue_action ( argv [ i ] , msg_action , NULL , 0 , 0 ) ) yield = EXIT_FAILURE ; } else if ( ! queue_action ( argv [ msg_action_arg ] , msg_action , argv , argc , recipients_arg ) ) yield = EXIT_FAILURE ; exit ( yield ) ; } readconf_rest ( ) ; store_pool = POOL_MAIN ; if ( test_retry_arg >= 0 ) { retry_config * yield ; int basic_errno = 0 ; int more_errno = 0 ; uschar * s1 , * s2 ; if ( test_retry_arg >= argc ) { printf ( ""-brt<S2SV_blank>needs<S2SV_blank>a<S2SV_blank>domain<S2SV_blank>or<S2SV_blank>address<S2SV_blank>argument\\n"" ) ; exim_exit ( EXIT_FAILURE ) ; } s1 = argv [ test_retry_arg ++ ] ; s2 = NULL ; if ( Ustrchr ( s1 , '@' ) == NULL && Ustrchr ( s1 , '.' ) == NULL ) { printf ( ""Warning:<S2SV_blank>\\""%s\\""<S2SV_blank>contains<S2SV_blank>no<S2SV_blank>\'@\'<S2SV_blank>and<S2SV_blank>no<S2SV_blank>\'.\'<S2SV_blank>characters.<S2SV_blank>It<S2SV_blank>is<S2SV_blank>"" ""being<S2SV_blank>\\ntreated<S2SV_blank>as<S2SV_blank>a<S2SV_blank>one-component<S2SV_blank>domain,<S2SV_blank>not<S2SV_blank>as<S2SV_blank>a<S2SV_blank>local<S2SV_blank>part.\\n\\n"" , s1 ) ; } if ( test_retry_arg < argc && Ustrchr ( argv [ test_retry_arg ] , '.' ) != NULL ) s2 = argv [ test_retry_arg ++ ] ; if ( test_retry_arg < argc ) { uschar * ss = argv [ test_retry_arg ] ; uschar * error = readconf_retry_error ( ss , ss + Ustrlen ( ss ) , & basic_errno , & more_errno ) ; if ( error != NULL ) { printf ( ""%s\\n"" , CS error ) ; return EXIT_FAILURE ; } if ( basic_errno == ERRNO_MAIL4XX || basic_errno == ERRNO_RCPT4XX || basic_errno == ERRNO_DATA4XX ) { int code = ( more_errno >> 8 ) & 255 ; if ( code == 255 ) more_errno = ( more_errno & 0xffff00ff ) | ( 21 << 8 ) ; else if ( code > 100 ) more_errno = ( more_errno & 0xffff00ff ) | ( ( code - 96 ) << 8 ) ; } } yield = retry_find_config ( s1 , s2 , basic_errno , more_errno ) ; if ( yield == NULL ) printf ( ""No<S2SV_blank>retry<S2SV_blank>information<S2SV_blank>found\\n"" ) ; else { retry_rule * r ; more_errno = yield -> more_errno ; printf ( ""Retry<S2SV_blank>rule:<S2SV_blank>%s<S2SV_blank><S2SV_blank>"" , yield -> pattern ) ; if ( yield -> basic_errno == ERRNO_EXIMQUOTA ) { printf ( ""quota%s%s<S2SV_blank><S2SV_blank>"" , ( more_errno > 0 ) ? ""_"" : """" , ( more_errno > 0 ) ? readconf_printtime ( more_errno ) : US """" ) ; } else if ( yield -> basic_errno == ECONNREFUSED ) { printf ( ""refused%s%s<S2SV_blank><S2SV_blank>"" , ( more_errno > 0 ) ? ""_"" : """" , ( more_errno == 'M' ) ? ""MX"" : ( more_errno == 'A' ) ? ""A"" : """" ) ; } else if ( yield -> basic_errno == ETIMEDOUT ) { printf ( ""timeout"" ) ; if ( ( more_errno & RTEF_CTOUT ) != 0 ) printf ( ""_connect"" ) ; more_errno &= 255 ; if ( more_errno != 0 ) printf ( ""_%s"" , ( more_errno == 'M' ) ? ""MX"" : ""A"" ) ; printf ( ""<S2SV_blank><S2SV_blank>"" ) ; } else if ( yield -> basic_errno == ERRNO_AUTHFAIL ) printf ( ""auth_failed<S2SV_blank><S2SV_blank>"" ) ; else printf ( ""*<S2SV_blank><S2SV_blank>"" ) ; for ( r = yield -> rules ; r != NULL ; r = r -> next ) { printf ( ""%c,%s"" , r -> rule , readconf_printtime ( r -> timeout ) ) ; printf ( "",%s"" , readconf_printtime ( r -> p1 ) ) ; if ( r -> rule == 'G' ) { int x = r -> p2 ; int f = x % 1000 ; int d = 100 ; printf ( "",%d."" , x / 1000 ) ; do { printf ( ""%d"" , f / d ) ; f %= d ; d /= 10 ; } while ( f != 0 ) ; } printf ( "";<S2SV_blank>"" ) ; } printf ( ""\\n"" ) ; } exim_exit ( EXIT_SUCCESS ) ; } if ( list_options ) { set_process_info ( ""listing<S2SV_blank>variables"" ) ; if ( recipients_arg >= argc ) readconf_print ( US ""all"" , NULL , flag_n ) ; else for ( i = recipients_arg ; i < argc ; i ++ ) { if ( i < argc - 1 && ( Ustrcmp ( argv [ i ] , ""router"" ) == 0 || Ustrcmp ( argv [ i ] , ""transport"" ) == 0 || Ustrcmp ( argv [ i ] , ""authenticator"" ) == 0 || Ustrcmp ( argv [ i ] , ""macro"" ) == 0 || Ustrcmp ( argv [ i ] , ""environment"" ) == 0 ) ) { readconf_print ( argv [ i + 1 ] , argv [ i ] , flag_n ) ; i ++ ; } else readconf_print ( argv [ i ] , NULL , flag_n ) ; } exim_exit ( EXIT_SUCCESS ) ; } if ( list_config ) { set_process_info ( ""listing<S2SV_blank>config"" ) ; readconf_print ( US ""config"" , NULL , flag_n ) ; exim_exit ( EXIT_SUCCESS ) ; } # ifndef DISABLE_DKIM dkim_exim_init ( ) ; # endif deliver_init ( ) ; if ( msg_action_arg > 0 && msg_action != MSG_LOAD ) { if ( prod_requires_admin && ! admin_user ) { fprintf ( stderr , ""exim:<S2SV_blank>Permission<S2SV_blank>denied\\n"" ) ; exim_exit ( EXIT_FAILURE ) ; } set_process_info ( ""delivering<S2SV_blank>specified<S2SV_blank>messages"" ) ; if ( deliver_give_up ) forced_delivery = deliver_force_thaw = TRUE ; for ( i = msg_action_arg ; i < argc ; i ++ ) { int status ; pid_t pid ; if ( i == argc - 1 ) ( void ) deliver_message ( argv [ i ] , forced_delivery , deliver_give_up ) ; else if ( ( pid = fork ( ) ) == 0 ) { ( void ) deliver_message ( argv [ i ] , forced_delivery , deliver_give_up ) ; _exit ( EXIT_SUCCESS ) ; } else if ( pid < 0 ) { fprintf ( stderr , ""failed<S2SV_blank>to<S2SV_blank>fork<S2SV_blank>delivery<S2SV_blank>process<S2SV_blank>for<S2SV_blank>%s:<S2SV_blank>%s\\n"" , argv [ i ] , strerror ( errno ) ) ; exim_exit ( EXIT_FAILURE ) ; } else wait ( & status ) ; } exim_exit ( EXIT_SUCCESS ) ; } if ( queue_interval == 0 && ! daemon_listen ) { DEBUG ( D_queue_run ) debug_printf ( ""Single<S2SV_blank>queue<S2SV_blank>run%s%s%s%s\\n"" , ( start_queue_run_id == NULL ) ? US """" : US ""<S2SV_blank>starting<S2SV_blank>at<S2SV_blank>"" , ( start_queue_run_id == NULL ) ? US """" : start_queue_run_id , ( stop_queue_run_id == NULL ) ? US """" : US ""<S2SV_blank>stopping<S2SV_blank>at<S2SV_blank>"" , ( stop_queue_run_id == NULL ) ? US """" : stop_queue_run_id ) ; if ( * queue_name ) set_process_info ( ""running<S2SV_blank>the<S2SV_blank>\'%s\'<S2SV_blank>queue<S2SV_blank>(single<S2SV_blank>queue<S2SV_blank>run)"" , queue_name ) ; else set_process_info ( ""running<S2SV_blank>the<S2SV_blank>queue<S2SV_blank>(single<S2SV_blank>queue<S2SV_blank>run)"" ) ; queue_run ( start_queue_run_id , stop_queue_run_id , FALSE ) ; exim_exit ( EXIT_SUCCESS ) ; } for ( i = 0 ; ; ) { if ( ( pw = getpwuid ( real_uid ) ) != NULL ) { originator_login = string_copy ( US pw -> pw_name ) ; originator_home = string_copy ( US pw -> pw_dir ) ; if ( originator_name == NULL ) { if ( sender_address == NULL || ( ! trusted_caller && filter_test == FTEST_NONE ) ) { uschar * name = US pw -> pw_gecos ; uschar * amp = Ustrchr ( name , '&' ) ; uschar buffer [ 256 ] ; if ( amp != NULL ) { int loffset ; string_format ( buffer , sizeof ( buffer ) , ""%.*s%n%s%s"" , amp - name , name , & loffset , originator_login , amp + 1 ) ; buffer [ loffset ] = toupper ( buffer [ loffset ] ) ; name = buffer ; } if ( gecos_pattern != NULL && gecos_name != NULL ) { const pcre * re ; re = regex_must_compile ( gecos_pattern , FALSE , TRUE ) ; if ( regex_match_and_setup ( re , name , 0 , - 1 ) ) { uschar * new_name = expand_string ( gecos_name ) ; expand_nmax = - 1 ; if ( new_name != NULL ) { DEBUG ( D_receive ) debug_printf ( ""user<S2SV_blank>name<S2SV_blank>\\""%s\\""<S2SV_blank>extracted<S2SV_blank>from<S2SV_blank>"" ""gecos<S2SV_blank>field<S2SV_blank>\\""%s\\""\\n"" , new_name , name ) ; name = new_name ; } else DEBUG ( D_receive ) debug_printf ( ""failed<S2SV_blank>to<S2SV_blank>expand<S2SV_blank>gecos_name<S2SV_blank>string<S2SV_blank>"" ""\\""%s\\"":<S2SV_blank>%s\\n"" , gecos_name , expand_string_message ) ; } else DEBUG ( D_receive ) debug_printf ( ""gecos_pattern<S2SV_blank>\\""%s\\""<S2SV_blank>did<S2SV_blank>not<S2SV_blank>match<S2SV_blank>"" ""gecos<S2SV_blank>field<S2SV_blank>\\""%s\\""\\n"" , gecos_pattern , name ) ; store_free ( ( void * ) re ) ; } originator_name = string_copy ( name ) ; } else originator_name = US """" ; } break ; } if ( ++ i > finduser_retries ) break ; sleep ( 1 ) ; } if ( originator_login == NULL || running_in_test_harness ) { if ( unknown_login != NULL ) { originator_login = expand_string ( unknown_login ) ; if ( originator_name == NULL && unknown_username != NULL ) originator_name = expand_string ( unknown_username ) ; if ( originator_name == NULL ) originator_name = US """" ; } if ( originator_login == NULL ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>user<S2SV_blank>name<S2SV_blank>for<S2SV_blank>uid<S2SV_blank>%d"" , ( int ) real_uid ) ; } originator_name = string_copy ( parse_fix_phrase ( originator_name , Ustrlen ( originator_name ) , big_buffer , big_buffer_size ) ) ; originator_uid = real_uid ; originator_gid = real_gid ; DEBUG ( D_receive ) debug_printf ( ""originator:<S2SV_blank>uid=%d<S2SV_blank>gid=%d<S2SV_blank>login=%s<S2SV_blank>name=%s\\n"" , ( int ) originator_uid , ( int ) originator_gid , originator_login , originator_name ) ; if ( daemon_listen || inetd_wait_mode || queue_interval > 0 ) { if ( mua_wrapper ) { fprintf ( stderr , ""Daemon<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>run<S2SV_blank>when<S2SV_blank>mua_wrapper<S2SV_blank>is<S2SV_blank>set\\n"" ) ; log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , ""Daemon<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>run<S2SV_blank>when<S2SV_blank>"" ""mua_wrapper<S2SV_blank>is<S2SV_blank>set"" ) ; } daemon_go ( ) ; } if ( sender_ident == NULL ) sender_ident = originator_login ; else if ( sender_ident [ 0 ] == 0 ) sender_ident = NULL ; if ( test_rewrite_arg >= 0 ) { really_exim = FALSE ; if ( test_rewrite_arg >= argc ) { printf ( ""-brw<S2SV_blank>needs<S2SV_blank>an<S2SV_blank>address<S2SV_blank>argument\\n"" ) ; exim_exit ( EXIT_FAILURE ) ; } rewrite_test ( argv [ test_rewrite_arg ] ) ; exim_exit ( EXIT_SUCCESS ) ; } if ( ( sender_address == NULL && ! smtp_input ) || ( ! trusted_caller && filter_test == FTEST_NONE ) ) { sender_local = TRUE ; if ( authenticated_sender == NULL && ! host_checking ) authenticated_sender = string_sprintf ( ""%s@%s"" , originator_login , qualify_domain_sender ) ; if ( authenticated_id == NULL && ! host_checking ) authenticated_id = originator_login ; } if ( ( ! smtp_input && sender_address == NULL ) || ! receive_check_set_sender ( sender_address ) ) { if ( sender_address == NULL || ( sender_address [ 0 ] != 0 && ! checking ) ) { sender_address = originator_login ; sender_address_forced = FALSE ; sender_address_domain = 0 ; } } sender_set_untrusted = sender_address != originator_login && ! trusted_caller ; if ( sender_address != NULL && sender_address [ 0 ] != 0 && sender_address_domain == 0 ) sender_address = string_sprintf ( ""%s@%s"" , local_part_quote ( sender_address ) , qualify_domain_sender ) ; DEBUG ( D_receive ) debug_printf ( ""sender<S2SV_blank>address<S2SV_blank>=<S2SV_blank>%s\\n"" , sender_address ) ; if ( verify_address_mode || address_test_mode ) { int exit_value = 0 ; int flags = vopt_qualify ; if ( verify_address_mode ) { if ( ! verify_as_sender ) flags |= vopt_is_recipient ; DEBUG ( D_verify ) debug_print_ids ( US ""Verifying:"" ) ; } else { flags |= vopt_is_recipient ; debug_selector |= D_v ; debug_file = stderr ; debug_fd = fileno ( debug_file ) ; DEBUG ( D_verify ) debug_print_ids ( US ""Address<S2SV_blank>testing:"" ) ; } if ( recipients_arg < argc ) { while ( recipients_arg < argc ) { uschar * s = argv [ recipients_arg ++ ] ; while ( * s != 0 ) { BOOL finished = FALSE ; uschar * ss = parse_find_address_end ( s , FALSE ) ; if ( * ss == ',' ) * ss = 0 ; else finished = TRUE ; test_address ( s , flags , & exit_value ) ; s = ss ; if ( ! finished ) while ( * ( ++ s ) != 0 && ( * s == ',' || isspace ( * s ) ) ) ; } } } else for ( ; ; ) { uschar * s = get_stdinput ( NULL , NULL ) ; if ( s == NULL ) break ; test_address ( s , flags , & exit_value ) ; } route_tidyup ( ) ; exim_exit ( exit_value ) ; } if ( expansion_test ) { dns_init ( FALSE , FALSE , FALSE ) ; if ( msg_action_arg > 0 && msg_action == MSG_LOAD ) { uschar spoolname [ 256 ] ; if ( ! admin_user ) { fprintf ( stderr , ""exim:<S2SV_blank>permission<S2SV_blank>denied\\n"" ) ; exit ( EXIT_FAILURE ) ; } message_id = argv [ msg_action_arg ] ; ( void ) string_format ( spoolname , sizeof ( spoolname ) , ""%s-H"" , message_id ) ; if ( ( deliver_datafile = spool_open_datafile ( message_id ) ) < 0 ) printf ( ""Failed<S2SV_blank>to<S2SV_blank>load<S2SV_blank>message<S2SV_blank>datafile<S2SV_blank>%s\\n"" , message_id ) ; if ( spool_read_header ( spoolname , TRUE , FALSE ) != spool_read_OK ) printf ( ""Failed<S2SV_blank>to<S2SV_blank>load<S2SV_blank>message<S2SV_blank>%s\\n"" , message_id ) ; } else if ( expansion_test_message != NULL ) { int save_stdin = dup ( 0 ) ; int fd = Uopen ( expansion_test_message , O_RDONLY , 0 ) ; if ( fd < 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s:<S2SV_blank>%s\\n"" , expansion_test_message , strerror ( errno ) ) ; return EXIT_FAILURE ; } ( void ) dup2 ( fd , 0 ) ; filter_test = FTEST_USER ; message_ended = END_NOTENDED ; read_message_body ( receive_msg ( extract_recipients ) ) ; message_linecount += body_linecount ; ( void ) dup2 ( save_stdin , 0 ) ; ( void ) close ( save_stdin ) ; clearerr ( stdin ) ; } enable_dollar_recipients = TRUE ; if ( recipients_arg < argc ) { while ( recipients_arg < argc ) { uschar * s = argv [ recipients_arg ++ ] ; uschar * ss = expand_string ( s ) ; if ( ss == NULL ) printf ( ""Failed:<S2SV_blank>%s\\n"" , expand_string_message ) ; else printf ( ""%s\\n"" , CS ss ) ; } } else { char * ( * fn_readline ) ( const char * ) = NULL ; void ( * fn_addhist ) ( const char * ) = NULL ; # ifdef USE_READLINE void * dlhandle = set_readline ( & fn_readline , & fn_addhist ) ; # endif for ( ; ; ) { uschar * ss ; uschar * source = get_stdinput ( fn_readline , fn_addhist ) ; if ( source == NULL ) break ; ss = expand_string ( source ) ; if ( ss == NULL ) printf ( ""Failed:<S2SV_blank>%s\\n"" , expand_string_message ) ; else printf ( ""%s\\n"" , CS ss ) ; } # ifdef USE_READLINE if ( dlhandle != NULL ) dlclose ( dlhandle ) ; # endif } if ( deliver_datafile >= 0 ) { ( void ) close ( deliver_datafile ) ; deliver_datafile = - 1 ; } exim_exit ( EXIT_SUCCESS ) ; } smtp_active_hostname = primary_hostname ; if ( raw_active_hostname != NULL ) { uschar * nah = expand_string ( raw_active_hostname ) ; if ( nah == NULL ) { if ( ! expand_string_forcedfail ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , ""failed<S2SV_blank>to<S2SV_blank>expand<S2SV_blank>\\""%s\\""<S2SV_blank>"" ""(smtp_active_hostname):<S2SV_blank>%s"" , raw_active_hostname , expand_string_message ) ; } else if ( nah [ 0 ] != 0 ) smtp_active_hostname = nah ; } if ( host_checking ) { int x [ 4 ] ; int size ; if ( ! sender_ident_set ) { sender_ident = NULL ; if ( running_in_test_harness && sender_host_port != 0 && interface_address != NULL && interface_port != 0 ) verify_get_ident ( 1413 ) ; } size = host_aton ( sender_host_address , x ) ; sender_host_address = store_get ( 48 ) ; ( void ) host_nmtoa ( size , x , - 1 , sender_host_address , ':' ) ; host_build_sender_fullhost ( ) ; smtp_input = TRUE ; smtp_in = stdin ; smtp_out = stdout ; sender_local = FALSE ; sender_host_notsocket = TRUE ; debug_file = stderr ; debug_fd = fileno ( debug_file ) ; fprintf ( stdout , ""\\n****<S2SV_blank>SMTP<S2SV_blank>testing<S2SV_blank>session<S2SV_blank>as<S2SV_blank>if<S2SV_blank>from<S2SV_blank>host<S2SV_blank>%s\\n"" ""****<S2SV_blank>but<S2SV_blank>without<S2SV_blank>any<S2SV_blank>ident<S2SV_blank>(RFC<S2SV_blank>1413)<S2SV_blank>callback.\\n"" ""****<S2SV_blank>This<S2SV_blank>is<S2SV_blank>not<S2SV_blank>for<S2SV_blank>real!\\n\\n"" , sender_host_address ) ; memset ( sender_host_cache , 0 , sizeof ( sender_host_cache ) ) ; if ( verify_check_host ( & hosts_connection_nolog ) == OK ) BIT_CLEAR ( log_selector , log_selector_size , Li_smtp_connection ) ; log_write ( L_smtp_connection , LOG_MAIN , ""%s"" , smtp_get_connection_info ( ) ) ; if ( smtp_start_session ( ) ) { for ( reset_point = store_get ( 0 ) ; ; store_reset ( reset_point ) ) { if ( smtp_setup_msg ( ) <= 0 ) break ; if ( ! receive_msg ( FALSE ) ) break ; return_path = sender_address = NULL ; dnslist_domain = dnslist_matched = NULL ; # ifndef DISABLE_DKIM dkim_cur_signer = NULL ; # endif acl_var_m = NULL ; deliver_localpart_orig = NULL ; deliver_domain_orig = NULL ; callout_address = sending_ip_address = NULL ; sender_rate = sender_rate_limit = sender_rate_period = NULL ; } smtp_log_no_mail ( ) ; } exim_exit ( EXIT_SUCCESS ) ; } if ( recipients_arg >= argc && ! extract_recipients && ! smtp_input ) { if ( version_printed ) { printf ( ""Configuration<S2SV_blank>file<S2SV_blank>is<S2SV_blank>%s\\n"" , config_main_filename ) ; return EXIT_SUCCESS ; } if ( info_flag != CMDINFO_NONE ) { show_exim_information ( info_flag , info_stdout ? stdout : stderr ) ; return info_stdout ? EXIT_SUCCESS : EXIT_FAILURE ; } if ( filter_test == FTEST_NONE ) exim_usage ( called_as ) ; } if ( mua_wrapper ) { synchronous_delivery = TRUE ; arg_error_handling = ERRORS_STDERR ; remote_max_parallel = 1 ; deliver_drop_privilege = TRUE ; queue_smtp = FALSE ; queue_smtp_domains = NULL ; # ifdef SUPPORT_I18N message_utf8_downconvert = - 1 ; # endif } if ( ! smtp_input ) error_handling = arg_error_handling ; else if ( is_inetd ) { ( void ) fclose ( stderr ) ; exim_nullstd ( ) ; verify_get_ident ( IDENT_PORT ) ; host_build_sender_fullhost ( ) ; set_process_info ( ""handling<S2SV_blank>incoming<S2SV_blank>connection<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>via<S2SV_blank>inetd"" , sender_fullhost ) ; } if ( sender_host_address != NULL && sender_fullhost == NULL ) { host_build_sender_fullhost ( ) ; set_process_info ( ""handling<S2SV_blank>incoming<S2SV_blank>connection<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>via<S2SV_blank>-oMa"" , sender_fullhost ) ; sender_host_notsocket = TRUE ; } else if ( ! is_inetd ) sender_host_unknown = TRUE ; if ( fstat ( 1 , & statbuf ) < 0 ) ( void ) dup2 ( 0 , 1 ) ; if ( smtp_input ) { if ( ! is_inetd ) set_process_info ( ""accepting<S2SV_blank>a<S2SV_blank>local<S2SV_blank>%sSMTP<S2SV_blank>message<S2SV_blank>from<S2SV_blank><%s>"" , smtp_batched_input ? ""batched<S2SV_blank>"" : """" , ( sender_address != NULL ) ? sender_address : originator_login ) ; } else { int old_pool = store_pool ; store_pool = POOL_PERM ; if ( ! received_protocol ) received_protocol = string_sprintf ( ""local%s"" , called_as ) ; store_pool = old_pool ; set_process_info ( ""accepting<S2SV_blank>a<S2SV_blank>local<S2SV_blank>non-SMTP<S2SV_blank>message<S2SV_blank>from<S2SV_blank><%s>"" , sender_address ) ; } queue_check_only ( ) ; session_local_queue_only = queue_only ; if ( ( ! smtp_input || smtp_batched_input ) && ! receive_check_fs ( 0 ) ) { fprintf ( stderr , ""exim:<S2SV_blank>insufficient<S2SV_blank>disk<S2SV_blank>space\\n"" ) ; return EXIT_FAILURE ; } if ( smtp_input ) { smtp_in = stdin ; smtp_out = stdout ; memset ( sender_host_cache , 0 , sizeof ( sender_host_cache ) ) ; if ( verify_check_host ( & hosts_connection_nolog ) == OK ) BIT_CLEAR ( log_selector , log_selector_size , Li_smtp_connection ) ; log_write ( L_smtp_connection , LOG_MAIN , ""%s"" , smtp_get_connection_info ( ) ) ; if ( ! smtp_start_session ( ) ) { mac_smtp_fflush ( ) ; exim_exit ( EXIT_SUCCESS ) ; } } else { thismessage_size_limit = expand_string_integer ( message_size_limit , TRUE ) ; if ( expand_string_message ) if ( thismessage_size_limit == - 1 ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , ""failed<S2SV_blank>to<S2SV_blank>expand<S2SV_blank>"" ""message_size_limit:<S2SV_blank>%s"" , expand_string_message ) ; else log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , ""invalid<S2SV_blank>value<S2SV_blank>for<S2SV_blank>"" ""message_size_limit:<S2SV_blank>%s"" , expand_string_message ) ; } if ( ! synchronous_delivery ) { # ifdef SA_NOCLDWAIT struct sigaction act ; act . sa_handler = SIG_IGN ; sigemptyset ( & ( act . sa_mask ) ) ; act . sa_flags = SA_NOCLDWAIT ; sigaction ( SIGCHLD , & act , NULL ) ; # else signal ( SIGCHLD , SIG_IGN ) ; # endif } reset_point = store_get ( 0 ) ; real_sender_address = sender_address ; while ( more ) { message_id [ 0 ] = 0 ; if ( smtp_input ) { int rc ; if ( ( rc = smtp_setup_msg ( ) ) > 0 ) { if ( real_sender_address != NULL && ! receive_check_set_sender ( sender_address ) ) { sender_address = raw_sender = real_sender_address ; sender_address_unrewritten = NULL ; } if ( smtp_batched_input && acl_not_smtp_start != NULL ) { uschar * user_msg , * log_msg ; enable_dollar_recipients = TRUE ; ( void ) acl_check ( ACL_WHERE_NOTSMTP_START , NULL , acl_not_smtp_start , & user_msg , & log_msg ) ; enable_dollar_recipients = FALSE ; } more = receive_msg ( extract_recipients ) ; if ( message_id [ 0 ] == 0 ) { cancel_cutthrough_connection ( TRUE , US ""receive<S2SV_blank>dropped"" ) ; if ( more ) goto moreloop ; smtp_log_no_mail ( ) ; exim_exit ( EXIT_FAILURE ) ; } } else { cancel_cutthrough_connection ( TRUE , US ""message<S2SV_blank>setup<S2SV_blank>dropped"" ) ; smtp_log_no_mail ( ) ; exim_exit ( ( rc == 0 ) ? EXIT_SUCCESS : EXIT_FAILURE ) ; } } else { int i ; int rcount = 0 ; int count = argc - recipients_arg ; uschar * * list = argv + recipients_arg ; active_local_sender_retain = local_sender_retain ; active_local_from_check = local_from_check ; raw_sender = string_copy ( sender_address ) ; for ( i = 0 ; i < count ; i ++ ) { int start , end , domain ; uschar * errmess ; uschar * s = list [ i ] ; while ( * s != 0 ) { BOOL finished = FALSE ; uschar * recipient ; uschar * ss = parse_find_address_end ( s , FALSE ) ; if ( * ss == ',' ) * ss = 0 ; else finished = TRUE ; if ( recipients_max > 0 && ++ rcount > recipients_max && ! extract_recipients ) if ( error_handling == ERRORS_STDERR ) { fprintf ( stderr , ""exim:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>recipients\\n"" ) ; exim_exit ( EXIT_FAILURE ) ; } else { return moan_to_sender ( ERRMESS_TOOMANYRECIP , NULL , NULL , stdin , TRUE ) ? errors_sender_rc : EXIT_FAILURE ; } # ifdef SUPPORT_I18N { BOOL b = allow_utf8_domains ; allow_utf8_domains = TRUE ; # endif recipient = parse_extract_address ( s , & errmess , & start , & end , & domain , FALSE ) ; # ifdef SUPPORT_I18N if ( string_is_utf8 ( recipient ) ) message_smtputf8 = TRUE ; else allow_utf8_domains = b ; } # endif if ( domain == 0 && ! allow_unqualified_recipient ) { recipient = NULL ; errmess = US ""unqualified<S2SV_blank>recipient<S2SV_blank>address<S2SV_blank>not<S2SV_blank>allowed"" ; } if ( recipient == NULL ) { if ( error_handling == ERRORS_STDERR ) { fprintf ( stderr , ""exim:<S2SV_blank>bad<S2SV_blank>recipient<S2SV_blank>address<S2SV_blank>\\""%s\\"":<S2SV_blank>%s\\n"" , string_printing ( list [ i ] ) , errmess ) ; exim_exit ( EXIT_FAILURE ) ; } else { error_block eblock ; eblock . next = NULL ; eblock . text1 = string_printing ( list [ i ] ) ; eblock . text2 = errmess ; return moan_to_sender ( ERRMESS_BADARGADDRESS , & eblock , NULL , stdin , TRUE ) ? errors_sender_rc : EXIT_FAILURE ; } } receive_add_recipient ( recipient , - 1 ) ; s = ss ; if ( ! finished ) while ( * ( ++ s ) != 0 && ( * s == ',' || isspace ( * s ) ) ) ; } } DEBUG ( D_receive ) { int i ; if ( sender_address != NULL ) debug_printf ( ""Sender:<S2SV_blank>%s\\n"" , sender_address ) ; if ( recipients_list != NULL ) { debug_printf ( ""Recipients:\\n"" ) ; for ( i = 0 ; i < recipients_count ; i ++ ) debug_printf ( ""<S2SV_blank><S2SV_blank>%s\\n"" , recipients_list [ i ] . address ) ; } } if ( acl_not_smtp_start ) { uschar * user_msg , * log_msg ; enable_dollar_recipients = TRUE ; ( void ) acl_check ( ACL_WHERE_NOTSMTP_START , NULL , acl_not_smtp_start , & user_msg , & log_msg ) ; enable_dollar_recipients = FALSE ; } if ( ! receive_timeout ) { struct timeval t = { 30 * 60 , 0 } ; fd_set r ; FD_ZERO ( & r ) ; FD_SET ( 0 , & r ) ; if ( select ( 1 , & r , NULL , NULL , & t ) == 0 ) mainlog_close ( ) ; } message_ended = END_NOTENDED ; more = receive_msg ( extract_recipients ) ; if ( message_id [ 0 ] == 0 ) exim_exit ( EXIT_FAILURE ) ; } if ( filter_test != FTEST_NONE ) { deliver_domain = ( ftest_domain != NULL ) ? ftest_domain : qualify_domain_recipient ; deliver_domain_orig = deliver_domain ; deliver_localpart = ( ftest_localpart != NULL ) ? ftest_localpart : originator_login ; deliver_localpart_orig = deliver_localpart ; deliver_localpart_prefix = ftest_prefix ; deliver_localpart_suffix = ftest_suffix ; deliver_home = originator_home ; if ( return_path == NULL ) { printf ( ""Return-path<S2SV_blank>copied<S2SV_blank>from<S2SV_blank>sender\\n"" ) ; return_path = string_copy ( sender_address ) ; } else printf ( ""Return-path<S2SV_blank>=<S2SV_blank>%s\\n"" , ( return_path [ 0 ] == 0 ) ? US ""<>"" : return_path ) ; printf ( ""Sender<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%s\\n"" , ( sender_address [ 0 ] == 0 ) ? US ""<>"" : sender_address ) ; receive_add_recipient ( string_sprintf ( ""%s%s%s@%s"" , ( ftest_prefix == NULL ) ? US """" : ftest_prefix , deliver_localpart , ( ftest_suffix == NULL ) ? US """" : ftest_suffix , deliver_domain ) , - 1 ) ; printf ( ""Recipient<S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%s\\n"" , recipients_list [ 0 ] . address ) ; if ( ftest_prefix != NULL ) printf ( ""Prefix<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%s\\n"" , ftest_prefix ) ; if ( ftest_suffix != NULL ) printf ( ""Suffix<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%s\\n"" , ftest_suffix ) ; if ( chdir ( ""/"" ) ) { DEBUG ( D_receive ) debug_printf ( ""chdir(\\""/\\"")<S2SV_blank>failed\\n"" ) ; exim_exit ( EXIT_FAILURE ) ; } if ( ( filter_test & FTEST_SYSTEM ) != 0 ) { if ( ! filter_runtest ( filter_sfd , filter_test_sfile , TRUE , more ) ) exim_exit ( EXIT_FAILURE ) ; } memcpy ( filter_sn , filter_n , sizeof ( filter_sn ) ) ; if ( ( filter_test & FTEST_USER ) != 0 ) { if ( ! filter_runtest ( filter_ufd , filter_test_ufile , FALSE , more ) ) exim_exit ( EXIT_FAILURE ) ; } exim_exit ( EXIT_SUCCESS ) ; } if ( ! session_local_queue_only && smtp_accept_queue_per_connection > 0 && receive_messagecount > smtp_accept_queue_per_connection ) { session_local_queue_only = TRUE ; queue_only_reason = 2 ; } local_queue_only = session_local_queue_only ; if ( ! local_queue_only && queue_only_load >= 0 ) { local_queue_only = ( load_average = OS_GETLOADAVG ( ) ) > queue_only_load ; if ( local_queue_only ) { queue_only_reason = 3 ; if ( queue_only_load_latch ) session_local_queue_only = TRUE ; } } if ( mua_wrapper ) local_queue_only = queue_only_policy = deliver_freeze = FALSE ; if ( local_queue_only ) { cancel_cutthrough_connection ( TRUE , US ""no<S2SV_blank>delivery;<S2SV_blank>queueing"" ) ; switch ( queue_only_reason ) { case 2 : log_write ( L_delay_delivery , LOG_MAIN , ""no<S2SV_blank>immediate<S2SV_blank>delivery:<S2SV_blank>more<S2SV_blank>than<S2SV_blank>%d<S2SV_blank>messages<S2SV_blank>"" ""received<S2SV_blank>in<S2SV_blank>one<S2SV_blank>connection"" , smtp_accept_queue_per_connection ) ; break ; case 3 : log_write ( L_delay_delivery , LOG_MAIN , ""no<S2SV_blank>immediate<S2SV_blank>delivery:<S2SV_blank>load<S2SV_blank>average<S2SV_blank>%.2f"" , ( double ) load_average / 1000.0 ) ; break ; } } else if ( queue_only_policy || deliver_freeze ) cancel_cutthrough_connection ( TRUE , US ""no<S2SV_blank>delivery;<S2SV_blank>queueing"" ) ; else { pid_t pid ; search_tidyup ( ) ; if ( ( pid = fork ( ) ) == 0 ) { int rc ; close_unwanted ( ) ; exim_nullstd ( ) ; if ( geteuid ( ) != root_uid && ! deliver_drop_privilege && ! unprivileged ) { delivery_re_exec ( CEE_EXEC_EXIT ) ; } rc = deliver_message ( message_id , FALSE , FALSE ) ; search_tidyup ( ) ; _exit ( ( ! mua_wrapper || rc == DELIVER_MUA_SUCCEEDED ) ? EXIT_SUCCESS : EXIT_FAILURE ) ; } if ( pid < 0 ) { cancel_cutthrough_connection ( TRUE , US ""delivery<S2SV_blank>fork<S2SV_blank>failed"" ) ; log_write ( 0 , LOG_MAIN | LOG_PANIC , ""failed<S2SV_blank>to<S2SV_blank>fork<S2SV_blank>automatic<S2SV_blank>delivery<S2SV_blank>"" ""process:<S2SV_blank>%s"" , strerror ( errno ) ) ; } else { release_cutthrough_connection ( US ""msg<S2SV_blank>passed<S2SV_blank>for<S2SV_blank>delivery"" ) ; if ( synchronous_delivery ) { int status ; while ( wait ( & status ) != pid ) ; if ( ( status & 0x00ff ) != 0 ) log_write ( 0 , LOG_MAIN | LOG_PANIC , ""process<S2SV_blank>%d<S2SV_blank>crashed<S2SV_blank>with<S2SV_blank>signal<S2SV_blank>%d<S2SV_blank>while<S2SV_blank>delivering<S2SV_blank>%s"" , ( int ) pid , status & 0x00ff , message_id ) ; if ( mua_wrapper && ( status & 0xffff ) != 0 ) exim_exit ( EXIT_FAILURE ) ; } } } # ifndef SIG_IGN_WORKS while ( waitpid ( - 1 , NULL , WNOHANG ) > 0 ) ; # endif moreloop : return_path = sender_address = NULL ; authenticated_sender = NULL ; deliver_localpart_orig = NULL ; deliver_domain_orig = NULL ; deliver_host = deliver_host_address = NULL ; dnslist_domain = dnslist_matched = NULL ; # ifdef WITH_CONTENT_SCAN malware_name = NULL ; # endif callout_address = NULL ; sending_ip_address = NULL ; acl_var_m = NULL ; { int i ; for ( i = 0 ; i < REGEX_VARS ; i ++ ) regex_vars [ i ] = NULL ; } store_reset ( reset_point ) ; } exim_exit ( EXIT_SUCCESS ) ; return 0 ; }","else if ( Ustrcmp ( argrest , ""Mr"" ) == 0 ) received_protocol = argv [ ++ i ] ;else if ( Ustrcmp ( argrest , ""Ms"" ) == 0 ) sender_host_name = argv [ ++ i ] ;",349
474,"buggy line: uschar * hn = Ustrchr ( argrest , \':\' ) ;if ( hn == NULL ) {cwe id:CWE-404context: int main ( int argc , char * * cargv ) { uschar * * argv = USS cargv ; int arg_receive_timeout = - 1 ; int arg_smtp_receive_timeout = - 1 ; int arg_error_handling = error_handling ; int filter_sfd = - 1 ; int filter_ufd = - 1 ; int group_count ; int i , rv ; int list_queue_option = 0 ; int msg_action = 0 ; int msg_action_arg = - 1 ; int namelen = ( argv [ 0 ] == NULL ) ? 0 : Ustrlen ( argv [ 0 ] ) ; int queue_only_reason = 0 ; # ifdef EXIM_PERL int perl_start_option = 0 ; # endif int recipients_arg = argc ; int sender_address_domain = 0 ; int test_retry_arg = - 1 ; int test_rewrite_arg = - 1 ; BOOL arg_queue_only = FALSE ; BOOL bi_option = FALSE ; BOOL checking = FALSE ; BOOL count_queue = FALSE ; BOOL expansion_test = FALSE ; BOOL extract_recipients = FALSE ; BOOL flag_G = FALSE ; BOOL flag_n = FALSE ; BOOL forced_delivery = FALSE ; BOOL f_end_dot = FALSE ; BOOL deliver_give_up = FALSE ; BOOL list_queue = FALSE ; BOOL list_options = FALSE ; BOOL list_config = FALSE ; BOOL local_queue_only ; BOOL more = TRUE ; BOOL one_msg_action = FALSE ; BOOL opt_D_used = FALSE ; BOOL queue_only_set = FALSE ; BOOL receiving_message = TRUE ; BOOL sender_ident_set = FALSE ; BOOL session_local_queue_only ; BOOL unprivileged ; BOOL removed_privilege = FALSE ; BOOL usage_wanted = FALSE ; BOOL verify_address_mode = FALSE ; BOOL verify_as_sender = FALSE ; BOOL version_printed = FALSE ; uschar * alias_arg = NULL ; uschar * called_as = US """" ; uschar * cmdline_syslog_name = NULL ; uschar * start_queue_run_id = NULL ; uschar * stop_queue_run_id = NULL ; uschar * expansion_test_message = NULL ; uschar * ftest_domain = NULL ; uschar * ftest_localpart = NULL ; uschar * ftest_prefix = NULL ; uschar * ftest_suffix = NULL ; uschar * log_oneline = NULL ; uschar * malware_test_file = NULL ; uschar * real_sender_address ; uschar * originator_home = US ""/"" ; size_t sz ; void * reset_point ; struct passwd * pw ; struct stat statbuf ; pid_t passed_qr_pid = ( pid_t ) 0 ; int passed_qr_pipe = - 1 ; gid_t group_list [ NGROUPS_MAX ] ; enum commandline_info info_flag = CMDINFO_NONE ; BOOL info_stdout = FALSE ; static uschar * rsopts [ ] = { US ""f"" , US ""ff"" , US ""r"" , US ""rf"" , US ""rff"" } ; extern char * * environ ; # ifdef EXIM_USERNAME if ( route_finduser ( US EXIM_USERNAME , & pw , & exim_uid ) ) { if ( exim_uid == 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>refusing<S2SV_blank>to<S2SV_blank>run<S2SV_blank>with<S2SV_blank>uid<S2SV_blank>0<S2SV_blank>for<S2SV_blank>\\""%s\\""\\n"" , EXIM_USERNAME ) ; exit ( EXIT_FAILURE ) ; } if ( pw ) exim_gid = pw -> pw_gid ; # ifndef EXIM_GROUPNAME else { fprintf ( stderr , ""exim:<S2SV_blank>ref:name<S2SV_blank>should<S2SV_blank>specify<S2SV_blank>a<S2SV_blank>usercode,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>group.\\n"" ""exim:<S2SV_blank>can\'t<S2SV_blank>let<S2SV_blank>you<S2SV_blank>get<S2SV_blank>away<S2SV_blank>with<S2SV_blank>it<S2SV_blank>unless<S2SV_blank>you<S2SV_blank>also<S2SV_blank>specify<S2SV_blank>a<S2SV_blank>group.\\n"" ) ; exit ( EXIT_FAILURE ) ; } # endif } else { fprintf ( stderr , ""exim:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>uid<S2SV_blank>for<S2SV_blank>user<S2SV_blank>name<S2SV_blank>\\""%s\\""\\n"" , EXIM_USERNAME ) ; exit ( EXIT_FAILURE ) ; } # endif # ifdef EXIM_GROUPNAME if ( ! route_findgroup ( US EXIM_GROUPNAME , & exim_gid ) ) { fprintf ( stderr , ""exim:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>gid<S2SV_blank>for<S2SV_blank>group<S2SV_blank>name<S2SV_blank>\\""%s\\""\\n"" , EXIM_GROUPNAME ) ; exit ( EXIT_FAILURE ) ; } # endif # ifdef CONFIGURE_OWNERNAME if ( ! route_finduser ( US CONFIGURE_OWNERNAME , NULL , & config_uid ) ) { fprintf ( stderr , ""exim:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>uid<S2SV_blank>for<S2SV_blank>user<S2SV_blank>name<S2SV_blank>\\""%s\\""\\n"" , CONFIGURE_OWNERNAME ) ; exit ( EXIT_FAILURE ) ; } # endif system_filter_uid = exim_uid ; # ifdef CONFIGURE_GROUPNAME if ( ! route_findgroup ( US CONFIGURE_GROUPNAME , & config_gid ) ) { fprintf ( stderr , ""exim:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>gid<S2SV_blank>for<S2SV_blank>group<S2SV_blank>name<S2SV_blank>\\""%s\\""\\n"" , CONFIGURE_GROUPNAME ) ; exit ( EXIT_FAILURE ) ; } # endif # ifdef OS_INIT OS_INIT # endif running_in_test_harness = * running_status == '<' && Ustrcmp ( running_status , ""<<<testing>>>"" ) == 0 ; setlocale ( LC_ALL , ""C"" ) ; os_non_restarting_signal ( SIGALRM , sigalrm_handler ) ; if ( ! ( log_buffer = US malloc ( LOG_BUFFER_SIZE ) ) ) { fprintf ( stderr , ""exim:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>store<S2SV_blank>for<S2SV_blank>log<S2SV_blank>buffer\\n"" ) ; exit ( EXIT_FAILURE ) ; } bits_set ( log_selector , log_selector_size , log_default ) ; if ( fstat ( fileno ( stderr ) , & statbuf ) >= 0 ) log_stderr = stderr ; pcre_malloc = function_store_get ; pcre_free = function_dummy_free ; big_buffer = store_malloc ( big_buffer_size ) ; set_process_info ( ""initializing"" ) ; os_restarting_signal ( SIGUSR1 , usr1_handler ) ; signal ( SIGHUP , SIG_IGN ) ; signal ( SIGPIPE , SIG_IGN ) ; # ifdef SA_NOCLDWAIT { struct sigaction act ; act . sa_handler = SIG_DFL ; sigemptyset ( & ( act . sa_mask ) ) ; act . sa_flags = 0 ; sigaction ( SIGCHLD , & act , NULL ) ; } # else signal ( SIGCHLD , SIG_DFL ) ; # endif sighup_argv = argv ; version_init ( ) ; message_id_option [ 0 ] = '-' ; message_id_external = message_id_option + 1 ; message_id_external [ 0 ] = 'E' ; message_id = message_id_external + 1 ; message_id [ 0 ] = 0 ; ( void ) umask ( 0 ) ; regex_ismsgid = regex_must_compile ( US ""^(?:[^\\\\W_]{6}-){2}[^\\\\W_]{2}$"" , FALSE , TRUE ) ; regex_smtp_code = regex_must_compile ( US ""^\\\\d\\\\d\\\\d\\\\s(?:\\\\d\\\\.\\\\d\\\\d?\\\\d?\\\\.\\\\d\\\\d?\\\\d?\\\\s)?"" , FALSE , TRUE ) ; # ifdef WHITELIST_D_MACROS regex_whitelisted_macro = regex_must_compile ( US ""^[A-Za-z0-9_/.-]*$"" , FALSE , TRUE ) ; # endif for ( i = 0 ; i < REGEX_VARS ; i ++ ) regex_vars [ i ] = NULL ; if ( ( namelen == 5 && Ustrcmp ( argv [ 0 ] , ""mailq"" ) == 0 ) || ( namelen > 5 && Ustrncmp ( argv [ 0 ] + namelen - 6 , ""/mailq"" , 6 ) == 0 ) ) { list_queue = TRUE ; receiving_message = FALSE ; called_as = US ""-mailq"" ; } if ( ( namelen == 5 && Ustrcmp ( argv [ 0 ] , ""rmail"" ) == 0 ) || ( namelen > 5 && Ustrncmp ( argv [ 0 ] + namelen - 6 , ""/rmail"" , 6 ) == 0 ) ) { dot_ends = FALSE ; called_as = US ""-rmail"" ; errors_sender_rc = EXIT_SUCCESS ; } if ( ( namelen == 5 && Ustrcmp ( argv [ 0 ] , ""rsmtp"" ) == 0 ) || ( namelen > 5 && Ustrncmp ( argv [ 0 ] + namelen - 6 , ""/rsmtp"" , 6 ) == 0 ) ) { smtp_input = smtp_batched_input = TRUE ; called_as = US ""-rsmtp"" ; } if ( ( namelen == 4 && Ustrcmp ( argv [ 0 ] , ""runq"" ) == 0 ) || ( namelen > 4 && Ustrncmp ( argv [ 0 ] + namelen - 5 , ""/runq"" , 5 ) == 0 ) ) { queue_interval = 0 ; receiving_message = FALSE ; called_as = US ""-runq"" ; } if ( ( namelen == 10 && Ustrcmp ( argv [ 0 ] , ""newaliases"" ) == 0 ) || ( namelen > 10 && Ustrncmp ( argv [ 0 ] + namelen - 11 , ""/newaliases"" , 11 ) == 0 ) ) { bi_option = TRUE ; receiving_message = FALSE ; called_as = US ""-newaliases"" ; } original_euid = geteuid ( ) ; real_uid = getuid ( ) ; real_gid = getgid ( ) ; if ( real_uid == root_uid ) { rv = setgid ( real_gid ) ; if ( rv ) { fprintf ( stderr , ""exim:<S2SV_blank>setgid(%ld)<S2SV_blank>failed:<S2SV_blank>%s\\n"" , ( long int ) real_gid , strerror ( errno ) ) ; exit ( EXIT_FAILURE ) ; } rv = setuid ( real_uid ) ; if ( rv ) { fprintf ( stderr , ""exim:<S2SV_blank>setuid(%ld)<S2SV_blank>failed:<S2SV_blank>%s\\n"" , ( long int ) real_uid , strerror ( errno ) ) ; exit ( EXIT_FAILURE ) ; } } unprivileged = ( real_uid != root_uid && original_euid != root_uid ) ; for ( i = 1 ; i < argc ; i ++ ) { BOOL badarg = FALSE ; uschar * arg = argv [ i ] ; uschar * argrest ; int switchchar ; if ( arg [ 0 ] != '-' ) { recipients_arg = i ; break ; } if ( Ustrcmp ( arg , ""--"" ) == 0 ) { recipients_arg = i + 1 ; break ; } switchchar = arg [ 1 ] ; argrest = arg + 2 ; if ( Ustrncmp ( arg + 1 , ""oe"" , 2 ) == 0 || Ustrncmp ( arg + 1 , ""qR"" , 2 ) == 0 || Ustrncmp ( arg + 1 , ""qS"" , 2 ) == 0 ) { switchchar = arg [ 2 ] ; argrest ++ ; } else if ( Ustrncmp ( arg + 1 , ""qqR"" , 3 ) == 0 || Ustrncmp ( arg + 1 , ""qqS"" , 3 ) == 0 ) { switchchar = arg [ 3 ] ; argrest += 2 ; queue_2stage = TRUE ; } else if ( arg [ 1 ] == 'r' ) switchchar = 'f' ; else if ( Ustrcmp ( arg , ""-ov"" ) == 0 ) { switchchar = 'v' ; argrest ++ ; } else if ( switchchar == '-' ) { if ( Ustrcmp ( argrest , ""help"" ) == 0 ) { usage_wanted = TRUE ; break ; } else if ( Ustrcmp ( argrest , ""version"" ) == 0 ) { switchchar = 'b' ; argrest = US ""V"" ; } } switch ( switchchar ) { case 'A' : if ( * argrest == '\\0' ) { badarg = TRUE ; break ; } else { BOOL ignore = FALSE ; switch ( * argrest ) { case 'c' : case 'm' : if ( * ( argrest + 1 ) == '\\0' ) ignore = TRUE ; break ; } if ( ! ignore ) { badarg = TRUE ; break ; } } break ; case 'B' : if ( * argrest == 0 ) i ++ ; break ; case 'b' : receiving_message = FALSE ; if ( * argrest == 'd' ) { daemon_listen = TRUE ; if ( * ( ++ argrest ) == 'f' ) background_daemon = FALSE ; else if ( * argrest != 0 ) { badarg = TRUE ; break ; } } else if ( * argrest == 'e' ) { expansion_test = checking = TRUE ; if ( argrest [ 1 ] == 'm' ) { if ( ++ i >= argc ) { badarg = TRUE ; break ; } expansion_test_message = argv [ i ] ; argrest ++ ; } if ( argrest [ 1 ] != 0 ) { badarg = TRUE ; break ; } } else if ( * argrest == 'F' ) { filter_test |= checking = FTEST_SYSTEM ; if ( * ( ++ argrest ) != 0 ) { badarg = TRUE ; break ; } if ( ++ i < argc ) filter_test_sfile = argv [ i ] ; else { fprintf ( stderr , ""exim:<S2SV_blank>file<S2SV_blank>name<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>%s\\n"" , argv [ i - 1 ] ) ; exit ( EXIT_FAILURE ) ; } } else if ( * argrest == 'f' ) { if ( * ( ++ argrest ) == 0 ) { filter_test |= checking = FTEST_USER ; if ( ++ i < argc ) filter_test_ufile = argv [ i ] ; else { fprintf ( stderr , ""exim:<S2SV_blank>file<S2SV_blank>name<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>%s\\n"" , argv [ i - 1 ] ) ; exit ( EXIT_FAILURE ) ; } } else { if ( ++ i >= argc ) { fprintf ( stderr , ""exim:<S2SV_blank>string<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>%s\\n"" , arg ) ; exit ( EXIT_FAILURE ) ; } if ( Ustrcmp ( argrest , ""d"" ) == 0 ) ftest_domain = argv [ i ] ; else if ( Ustrcmp ( argrest , ""l"" ) == 0 ) ftest_localpart = argv [ i ] ; else if ( Ustrcmp ( argrest , ""p"" ) == 0 ) ftest_prefix = argv [ i ] ; else if ( Ustrcmp ( argrest , ""s"" ) == 0 ) ftest_suffix = argv [ i ] ; else { badarg = TRUE ; break ; } } } else if ( Ustrcmp ( argrest , ""h"" ) == 0 || Ustrcmp ( argrest , ""hc"" ) == 0 ) { if ( ++ i >= argc ) { badarg = TRUE ; break ; } sender_host_address = argv [ i ] ; host_checking = checking = log_testing_mode = TRUE ; host_checking_callout = argrest [ 1 ] == 'c' ; message_logs = FALSE ; } else if ( Ustrcmp ( argrest , ""i"" ) == 0 ) bi_option = TRUE ; else if ( argrest [ 0 ] == 'I' && Ustrlen ( argrest ) >= 2 && argrest [ 1 ] == ':' ) { uschar * p = & argrest [ 2 ] ; info_flag = CMDINFO_HELP ; if ( Ustrlen ( p ) ) { if ( strcmpic ( p , CUS ""sieve"" ) == 0 ) { info_flag = CMDINFO_SIEVE ; info_stdout = TRUE ; } else if ( strcmpic ( p , CUS ""dscp"" ) == 0 ) { info_flag = CMDINFO_DSCP ; info_stdout = TRUE ; } else if ( strcmpic ( p , CUS ""help"" ) == 0 ) { info_stdout = TRUE ; } } } else if ( Ustrcmp ( argrest , ""m"" ) == 0 ) receiving_message = TRUE ; else if ( Ustrcmp ( argrest , ""malware"" ) == 0 ) { if ( ++ i >= argc ) { badarg = TRUE ; break ; } checking = TRUE ; malware_test_file = argv [ i ] ; } else if ( Ustrcmp ( argrest , ""nq"" ) == 0 ) { allow_unqualified_sender = FALSE ; allow_unqualified_recipient = FALSE ; } else if ( * argrest == 'p' ) { if ( * ( ++ argrest ) == 'c' ) { count_queue = TRUE ; if ( * ( ++ argrest ) != 0 ) badarg = TRUE ; break ; } if ( * argrest == 'r' ) { list_queue_option = 8 ; argrest ++ ; } else list_queue_option = 0 ; list_queue = TRUE ; if ( * argrest == 0 ) { } else if ( Ustrcmp ( argrest , ""u"" ) == 0 ) list_queue_option += 1 ; else if ( Ustrcmp ( argrest , ""a"" ) == 0 ) list_queue_option += 2 ; else { badarg = TRUE ; break ; } } else if ( Ustrcmp ( argrest , ""P"" ) == 0 ) { if ( argv [ i + 1 ] && Ustrcmp ( argv [ i + 1 ] , ""config"" ) == 0 ) { list_config = TRUE ; readconf_save_config ( version_string ) ; } else { list_options = TRUE ; debug_selector |= D_v ; debug_file = stderr ; } } else if ( Ustrcmp ( argrest , ""rt"" ) == 0 ) { checking = TRUE ; test_retry_arg = i + 1 ; goto END_ARG ; } else if ( Ustrcmp ( argrest , ""rw"" ) == 0 ) { checking = TRUE ; test_rewrite_arg = i + 1 ; goto END_ARG ; } else if ( Ustrcmp ( argrest , ""S"" ) == 0 ) smtp_input = smtp_batched_input = receiving_message = TRUE ; else if ( Ustrcmp ( argrest , ""s"" ) == 0 ) smtp_input = receiving_message = TRUE ; else if ( Ustrcmp ( argrest , ""t"" ) == 0 ) address_test_mode = checking = log_testing_mode = TRUE ; else if ( Ustrcmp ( argrest , ""v"" ) == 0 ) verify_address_mode = checking = log_testing_mode = TRUE ; else if ( Ustrcmp ( argrest , ""vs"" ) == 0 ) { verify_address_mode = checking = log_testing_mode = TRUE ; verify_as_sender = TRUE ; } else if ( Ustrcmp ( argrest , ""V"" ) == 0 ) { printf ( ""Exim<S2SV_blank>version<S2SV_blank>%s<S2SV_blank>#%s<S2SV_blank>built<S2SV_blank>%s\\n"" , version_string , version_cnumber , version_date ) ; printf ( ""%s\\n"" , CS version_copyright ) ; version_printed = TRUE ; show_whats_supported ( stdout ) ; log_testing_mode = TRUE ; } else if ( * argrest == 'w' ) { inetd_wait_mode = TRUE ; background_daemon = FALSE ; daemon_listen = TRUE ; if ( * ( ++ argrest ) != '\\0' ) { inetd_wait_timeout = readconf_readtime ( argrest , 0 , FALSE ) ; if ( inetd_wait_timeout <= 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>bad<S2SV_blank>time<S2SV_blank>value<S2SV_blank>%s:<S2SV_blank>abandoned\\n"" , argv [ i ] ) ; exit ( EXIT_FAILURE ) ; } } } else badarg = TRUE ; break ; case 'C' : if ( * argrest == 0 ) { if ( ++ i < argc ) argrest = argv [ i ] ; else { badarg = TRUE ; break ; } } if ( Ustrcmp ( config_main_filelist , argrest ) != 0 ) { # ifdef ALT_CONFIG_PREFIX int sep = 0 ; int len = Ustrlen ( ALT_CONFIG_PREFIX ) ; const uschar * list = argrest ; uschar * filename ; while ( ( filename = string_nextinlist ( & list , & sep , big_buffer , big_buffer_size ) ) != NULL ) { if ( ( Ustrlen ( filename ) < len || Ustrncmp ( filename , ALT_CONFIG_PREFIX , len ) != 0 || Ustrstr ( filename , ""/../"" ) != NULL ) && ( Ustrcmp ( filename , ""/dev/null"" ) != 0 || real_uid != root_uid ) ) { fprintf ( stderr , ""-C<S2SV_blank>Permission<S2SV_blank>denied\\n"" ) ; exit ( EXIT_FAILURE ) ; } } # endif if ( real_uid != root_uid ) { # ifdef TRUSTED_CONFIG_LIST if ( real_uid != exim_uid # ifdef CONFIGURE_OWNER && real_uid != config_uid # endif ) trusted_config = FALSE ; else { FILE * trust_list = Ufopen ( TRUSTED_CONFIG_LIST , ""rb"" ) ; if ( trust_list ) { struct stat statbuf ; if ( fstat ( fileno ( trust_list ) , & statbuf ) != 0 || ( statbuf . st_uid != root_uid # ifdef CONFIGURE_OWNER && statbuf . st_uid != config_uid # endif ) || ( statbuf . st_gid != root_gid # ifdef CONFIGURE_GROUP && statbuf . st_gid != config_gid # endif && ( statbuf . st_mode & 020 ) != 0 ) || ( statbuf . st_mode & 2 ) != 0 ) { trusted_config = FALSE ; fclose ( trust_list ) ; } else { void * reset_point = store_get ( 0 ) ; uschar * trusted_configs [ 32 ] ; int nr_configs = 0 ; int i = 0 ; while ( Ufgets ( big_buffer , big_buffer_size , trust_list ) ) { uschar * start = big_buffer , * nl ; while ( * start && isspace ( * start ) ) start ++ ; if ( * start != '/' ) continue ; nl = Ustrchr ( start , '\\n' ) ; if ( nl ) * nl = 0 ; trusted_configs [ nr_configs ++ ] = string_copy ( start ) ; if ( nr_configs == 32 ) break ; } fclose ( trust_list ) ; if ( nr_configs ) { int sep = 0 ; const uschar * list = argrest ; uschar * filename ; while ( trusted_config && ( filename = string_nextinlist ( & list , & sep , big_buffer , big_buffer_size ) ) != NULL ) { for ( i = 0 ; i < nr_configs ; i ++ ) { if ( Ustrcmp ( filename , trusted_configs [ i ] ) == 0 ) break ; } if ( i == nr_configs ) { trusted_config = FALSE ; break ; } } store_reset ( reset_point ) ; } else { trusted_config = FALSE ; } } } else { trusted_config = FALSE ; } } # else trusted_config = FALSE ; # endif } config_main_filelist = argrest ; config_changed = TRUE ; } break ; case 'D' : # ifdef DISABLE_D_OPTION fprintf ( stderr , ""exim:<S2SV_blank>-D<S2SV_blank>is<S2SV_blank>not<S2SV_blank>available<S2SV_blank>in<S2SV_blank>this<S2SV_blank>Exim<S2SV_blank>binary\\n"" ) ; exit ( EXIT_FAILURE ) ; # else { int ptr = 0 ; macro_item * m ; uschar name [ 24 ] ; uschar * s = argrest ; opt_D_used = TRUE ; while ( isspace ( * s ) ) s ++ ; if ( * s < 'A' || * s > 'Z' ) { fprintf ( stderr , ""exim:<S2SV_blank>macro<S2SV_blank>name<S2SV_blank>set<S2SV_blank>by<S2SV_blank>-D<S2SV_blank>must<S2SV_blank>start<S2SV_blank>with<S2SV_blank>"" ""an<S2SV_blank>upper<S2SV_blank>case<S2SV_blank>letter\\n"" ) ; exit ( EXIT_FAILURE ) ; } while ( isalnum ( * s ) || * s == '_' ) { if ( ptr < sizeof ( name ) - 1 ) name [ ptr ++ ] = * s ; s ++ ; } name [ ptr ] = 0 ; if ( ptr == 0 ) { badarg = TRUE ; break ; } while ( isspace ( * s ) ) s ++ ; if ( * s != 0 ) { if ( * s ++ != '=' ) { badarg = TRUE ; break ; } while ( isspace ( * s ) ) s ++ ; } for ( m = macros ; m ; m = m -> next ) if ( Ustrcmp ( m -> name , name ) == 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>duplicated<S2SV_blank>-D<S2SV_blank>in<S2SV_blank>command<S2SV_blank>line\\n"" ) ; exit ( EXIT_FAILURE ) ; } m = macro_create ( name , s , TRUE , FALSE ) ; if ( clmacro_count >= MAX_CLMACROS ) { fprintf ( stderr , ""exim:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>-D<S2SV_blank>options<S2SV_blank>on<S2SV_blank>command<S2SV_blank>line\\n"" ) ; exit ( EXIT_FAILURE ) ; } clmacros [ clmacro_count ++ ] = string_sprintf ( ""-D%s=%s"" , m -> name , m -> replacement ) ; } # endif break ; case 'd' : if ( Ustrcmp ( argrest , ""ropcr"" ) == 0 ) { } else { unsigned int selector = D_default ; debug_selector = 0 ; debug_file = NULL ; if ( * argrest == 'd' ) { debug_daemon = TRUE ; argrest ++ ; } if ( * argrest != 0 ) decode_bits ( & selector , 1 , debug_notall , argrest , debug_options , debug_options_count , US ""debug"" , 0 ) ; debug_selector = selector ; } break ; case 'E' : local_error_message = TRUE ; if ( mac_ismsgid ( argrest ) ) message_reference = argrest ; break ; case 'e' : if ( Ustrcmp ( argrest , ""e"" ) == 0 ) { arg_error_handling = ERRORS_SENDER ; errors_sender_rc = EXIT_SUCCESS ; } else if ( Ustrcmp ( argrest , ""m"" ) == 0 ) arg_error_handling = ERRORS_SENDER ; else if ( Ustrcmp ( argrest , ""p"" ) == 0 ) arg_error_handling = ERRORS_STDERR ; else if ( Ustrcmp ( argrest , ""q"" ) == 0 ) arg_error_handling = ERRORS_STDERR ; else if ( Ustrcmp ( argrest , ""w"" ) == 0 ) arg_error_handling = ERRORS_SENDER ; else badarg = TRUE ; break ; case 'F' : if ( * argrest == 0 ) { if ( ++ i < argc ) argrest = argv [ i ] ; else { badarg = TRUE ; break ; } } originator_name = argrest ; sender_name_forced = TRUE ; break ; case 'f' : { int dummy_start , dummy_end ; uschar * errmess ; if ( * argrest == 0 ) { if ( i + 1 < argc ) argrest = argv [ ++ i ] ; else { badarg = TRUE ; break ; } } if ( * argrest == 0 ) sender_address = string_sprintf ( """" ) ; else { uschar * temp = argrest + Ustrlen ( argrest ) - 1 ; while ( temp >= argrest && isspace ( * temp ) ) temp -- ; if ( temp >= argrest && * temp == '.' ) f_end_dot = TRUE ; allow_domain_literals = TRUE ; strip_trailing_dot = TRUE ; # ifdef SUPPORT_I18N allow_utf8_domains = TRUE ; # endif sender_address = parse_extract_address ( argrest , & errmess , & dummy_start , & dummy_end , & sender_address_domain , TRUE ) ; # ifdef SUPPORT_I18N message_smtputf8 = string_is_utf8 ( sender_address ) ; allow_utf8_domains = FALSE ; # endif allow_domain_literals = FALSE ; strip_trailing_dot = FALSE ; if ( sender_address == NULL ) { fprintf ( stderr , ""exim:<S2SV_blank>bad<S2SV_blank>-f<S2SV_blank>address<S2SV_blank>\\""%s\\"":<S2SV_blank>%s\\n"" , argrest , errmess ) ; return EXIT_FAILURE ; } } sender_address_forced = TRUE ; } break ; case 'G' : flag_G = TRUE ; break ; case 'h' : if ( * argrest == 0 ) { if ( ++ i < argc ) argrest = argv [ i ] ; else { badarg = TRUE ; break ; } } if ( ! isdigit ( * argrest ) ) badarg = TRUE ; break ; case 'i' : if ( * argrest == 0 ) dot_ends = FALSE ; else badarg = TRUE ; break ; case 'L' : if ( * argrest == '\\0' ) { if ( ++ i < argc ) argrest = argv [ i ] ; else { badarg = TRUE ; break ; } } sz = Ustrlen ( argrest ) ; if ( sz > 32 ) { fprintf ( stderr , ""exim:<S2SV_blank>the<S2SV_blank>-L<S2SV_blank>syslog<S2SV_blank>name<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long:<S2SV_blank>\\""%s\\""\\n"" , argrest ) ; return EXIT_FAILURE ; } if ( sz < 1 ) { fprintf ( stderr , ""exim:<S2SV_blank>the<S2SV_blank>-L<S2SV_blank>syslog<S2SV_blank>name<S2SV_blank>is<S2SV_blank>too<S2SV_blank>short\\n"" ) ; return EXIT_FAILURE ; } cmdline_syslog_name = argrest ; break ; case 'M' : receiving_message = FALSE ; if ( Ustrcmp ( argrest , ""C"" ) == 0 ) { union sockaddr_46 interface_sock ; EXIM_SOCKLEN_T size = sizeof ( interface_sock ) ; if ( argc != i + 6 ) { fprintf ( stderr , ""exim:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>or<S2SV_blank>too<S2SV_blank>few<S2SV_blank>arguments<S2SV_blank>after<S2SV_blank>-MC\\n"" ) ; return EXIT_FAILURE ; } if ( msg_action_arg >= 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>incompatible<S2SV_blank>arguments\\n"" ) ; return EXIT_FAILURE ; } continue_transport = argv [ ++ i ] ; continue_hostname = argv [ ++ i ] ; continue_host_address = argv [ ++ i ] ; continue_sequence = Uatoi ( argv [ ++ i ] ) ; msg_action = MSG_DELIVER ; msg_action_arg = ++ i ; forced_delivery = TRUE ; queue_run_pid = passed_qr_pid ; queue_run_pipe = passed_qr_pipe ; if ( ! mac_ismsgid ( argv [ i ] ) ) { fprintf ( stderr , ""exim:<S2SV_blank>malformed<S2SV_blank>message<S2SV_blank>id<S2SV_blank>%s<S2SV_blank>after<S2SV_blank>-MC<S2SV_blank>option\\n"" , argv [ i ] ) ; return EXIT_FAILURE ; } if ( ! continue_proxy_cipher ) if ( getsockname ( fileno ( stdin ) , ( struct sockaddr * ) ( & interface_sock ) , & size ) == 0 ) sending_ip_address = host_ntoa ( - 1 , & interface_sock , NULL , & sending_port ) ; else { fprintf ( stderr , ""exim:<S2SV_blank>getsockname()<S2SV_blank>failed<S2SV_blank>after<S2SV_blank>-MC<S2SV_blank>option:<S2SV_blank>%s\\n"" , strerror ( errno ) ) ; return EXIT_FAILURE ; } if ( running_in_test_harness ) millisleep ( 500 ) ; break ; } else if ( * argrest == 'C' && argrest [ 1 ] && ! argrest [ 2 ] ) { switch ( argrest [ 1 ] ) { case 'A' : smtp_authenticated = TRUE ; break ; case 'D' : smtp_peer_options |= PEER_OFFERED_DSN ; break ; case 'G' : if ( ++ i < argc ) queue_name = string_copy ( argv [ i ] ) ; else badarg = TRUE ; break ; case 'K' : smtp_peer_options |= PEER_OFFERED_CHUNKING ; break ; case 'P' : smtp_peer_options |= PEER_OFFERED_PIPE ; break ; case 'Q' : if ( ++ i < argc ) passed_qr_pid = ( pid_t ) ( Uatol ( argv [ i ] ) ) ; else badarg = TRUE ; if ( ++ i < argc ) passed_qr_pipe = ( int ) ( Uatol ( argv [ i ] ) ) ; else badarg = TRUE ; break ; case 'S' : smtp_peer_options |= PEER_OFFERED_SIZE ; break ; # ifdef SUPPORT_TLS case 't' : if ( ++ i < argc ) sending_ip_address = argv [ i ] ; else badarg = TRUE ; if ( ++ i < argc ) sending_port = ( int ) ( Uatol ( argv [ i ] ) ) ; else badarg = TRUE ; if ( ++ i < argc ) continue_proxy_cipher = argv [ i ] ; else badarg = TRUE ; case 'T' : smtp_peer_options |= PEER_OFFERED_TLS ; break ; # endif default : badarg = TRUE ; break ; } break ; } else if ( * argrest == 0 ) { msg_action = MSG_DELIVER ; forced_delivery = deliver_force_thaw = TRUE ; } else if ( Ustrcmp ( argrest , ""ar"" ) == 0 ) { msg_action = MSG_ADD_RECIPIENT ; one_msg_action = TRUE ; } else if ( Ustrcmp ( argrest , ""c"" ) == 0 ) msg_action = MSG_DELIVER ; else if ( Ustrcmp ( argrest , ""es"" ) == 0 ) { msg_action = MSG_EDIT_SENDER ; one_msg_action = TRUE ; } else if ( Ustrcmp ( argrest , ""f"" ) == 0 ) msg_action = MSG_FREEZE ; else if ( Ustrcmp ( argrest , ""g"" ) == 0 ) { msg_action = MSG_DELIVER ; deliver_give_up = TRUE ; } else if ( Ustrcmp ( argrest , ""mad"" ) == 0 ) { msg_action = MSG_MARK_ALL_DELIVERED ; } else if ( Ustrcmp ( argrest , ""md"" ) == 0 ) { msg_action = MSG_MARK_DELIVERED ; one_msg_action = TRUE ; } else if ( Ustrcmp ( argrest , ""rm"" ) == 0 ) msg_action = MSG_REMOVE ; else if ( Ustrcmp ( argrest , ""set"" ) == 0 ) { msg_action = MSG_LOAD ; one_msg_action = TRUE ; } else if ( Ustrcmp ( argrest , ""t"" ) == 0 ) msg_action = MSG_THAW ; else if ( Ustrcmp ( argrest , ""vb"" ) == 0 ) { msg_action = MSG_SHOW_BODY ; one_msg_action = TRUE ; } else if ( Ustrcmp ( argrest , ""vc"" ) == 0 ) { msg_action = MSG_SHOW_COPY ; one_msg_action = TRUE ; } else if ( Ustrcmp ( argrest , ""vh"" ) == 0 ) { msg_action = MSG_SHOW_HEADER ; one_msg_action = TRUE ; } else if ( Ustrcmp ( argrest , ""vl"" ) == 0 ) { msg_action = MSG_SHOW_LOG ; one_msg_action = TRUE ; } else { badarg = TRUE ; break ; } msg_action_arg = i + 1 ; if ( msg_action_arg >= argc ) { fprintf ( stderr , ""exim:<S2SV_blank>no<S2SV_blank>message<S2SV_blank>ids<S2SV_blank>given<S2SV_blank>after<S2SV_blank>%s<S2SV_blank>option\\n"" , arg ) ; return EXIT_FAILURE ; } if ( ! one_msg_action ) { int j ; for ( j = msg_action_arg ; j < argc ; j ++ ) if ( ! mac_ismsgid ( argv [ j ] ) ) { fprintf ( stderr , ""exim:<S2SV_blank>malformed<S2SV_blank>message<S2SV_blank>id<S2SV_blank>%s<S2SV_blank>after<S2SV_blank>%s<S2SV_blank>option\\n"" , argv [ j ] , arg ) ; return EXIT_FAILURE ; } goto END_ARG ; } else { if ( ! mac_ismsgid ( argv [ msg_action_arg ] ) ) { fprintf ( stderr , ""exim:<S2SV_blank>malformed<S2SV_blank>message<S2SV_blank>id<S2SV_blank>%s<S2SV_blank>after<S2SV_blank>%s<S2SV_blank>option\\n"" , argv [ msg_action_arg ] , arg ) ; return EXIT_FAILURE ; } i ++ ; } break ; case 'm' : if ( * argrest != 0 ) badarg = TRUE ; break ; case 'N' : if ( * argrest == 0 ) { dont_deliver = TRUE ; debug_selector |= D_v ; debug_file = stderr ; } else badarg = TRUE ; break ; case 'n' : flag_n = TRUE ; break ; case 'O' : if ( * argrest == 0 ) { if ( ++ i >= argc ) { fprintf ( stderr , ""exim:<S2SV_blank>string<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>-O\\n"" ) ; exit ( EXIT_FAILURE ) ; } } break ; case 'o' : if ( * argrest == 'A' ) { alias_arg = argrest + 1 ; if ( alias_arg [ 0 ] == 0 ) { if ( i + 1 < argc ) alias_arg = argv [ ++ i ] ; else { fprintf ( stderr , ""exim:<S2SV_blank>string<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>-oA\\n"" ) ; exit ( EXIT_FAILURE ) ; } } } else if ( * argrest == 'B' ) { uschar * p = argrest + 1 ; if ( p [ 0 ] == 0 ) { if ( i + 1 < argc && isdigit ( ( argv [ i + 1 ] [ 0 ] ) ) ) p = argv [ ++ i ] ; else { connection_max_messages = 1 ; p = NULL ; } } if ( p != NULL ) { if ( ! isdigit ( * p ) ) { fprintf ( stderr , ""exim:<S2SV_blank>number<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>-oB\\n"" ) ; exit ( EXIT_FAILURE ) ; } connection_max_messages = Uatoi ( p ) ; } } else if ( Ustrcmp ( argrest , ""db"" ) == 0 ) { synchronous_delivery = FALSE ; arg_queue_only = FALSE ; queue_only_set = TRUE ; } else if ( Ustrcmp ( argrest , ""df"" ) == 0 || Ustrcmp ( argrest , ""di"" ) == 0 ) { synchronous_delivery = TRUE ; arg_queue_only = FALSE ; queue_only_set = TRUE ; } else if ( Ustrcmp ( argrest , ""dq"" ) == 0 ) { synchronous_delivery = FALSE ; arg_queue_only = TRUE ; queue_only_set = TRUE ; } else if ( Ustrcmp ( argrest , ""dqs"" ) == 0 ) { queue_smtp = TRUE ; arg_queue_only = FALSE ; queue_only_set = TRUE ; } else if ( Ustrcmp ( argrest , ""i"" ) == 0 || Ustrcmp ( argrest , ""itrue"" ) == 0 ) dot_ends = FALSE ; else if ( * argrest == 'M' ) { if ( i + 1 >= argc ) { fprintf ( stderr , ""exim:<S2SV_blank>data<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>-o%s\\n"" , argrest ) ; exit ( EXIT_FAILURE ) ; } if ( Ustrcmp ( argrest , ""Ma"" ) == 0 ) sender_host_address = argv [ ++ i ] ; else if ( Ustrcmp ( argrest , ""Maa"" ) == 0 ) sender_host_authenticated = argv [ ++ i ] ; else if ( Ustrcmp ( argrest , ""Mas"" ) == 0 ) authenticated_sender = argv [ ++ i ] ; else if ( Ustrcmp ( argrest , ""Mai"" ) == 0 ) authenticated_id = argv [ ++ i ] ; else if ( Ustrcmp ( argrest , ""Mi"" ) == 0 ) interface_address = argv [ ++ i ] ; else if ( Ustrcmp ( argrest , ""Mm"" ) == 0 ) { if ( ! mac_ismsgid ( argv [ i + 1 ] ) ) { fprintf ( stderr , ""-oMm<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>message<S2SV_blank>ID\\n"" ) ; exit ( EXIT_FAILURE ) ; } if ( ! trusted_config ) { fprintf ( stderr , ""-oMm<S2SV_blank>must<S2SV_blank>be<S2SV_blank>called<S2SV_blank>by<S2SV_blank>a<S2SV_blank>trusted<S2SV_blank>user/config\\n"" ) ; exit ( EXIT_FAILURE ) ; } message_reference = argv [ ++ i ] ; }  else if ( Ustrcmp ( argrest , ""Mr"" ) == 0 ) received_protocol = argv [ ++ i ] ;  else if ( Ustrcmp ( argrest , ""Ms"" ) == 0 ) sender_host_name = argv [ ++ i ] ; else if ( Ustrcmp ( argrest , ""Mt"" ) == 0 ) { sender_ident_set = TRUE ; sender_ident = argv [ ++ i ] ; } else { badarg = TRUE ; break ; } } else if ( Ustrcmp ( argrest , ""m"" ) == 0 ) { } else if ( Ustrcmp ( argrest , ""o"" ) == 0 ) { } else if ( Ustrcmp ( argrest , ""P"" ) == 0 ) override_pid_file_path = argv [ ++ i ] ; else if ( * argrest == 'r' || * argrest == 's' ) { int * tp = ( * argrest == 'r' ) ? & arg_receive_timeout : & arg_smtp_receive_timeout ; if ( argrest [ 1 ] == 0 ) { if ( i + 1 < argc ) * tp = readconf_readtime ( argv [ ++ i ] , 0 , FALSE ) ; } else * tp = readconf_readtime ( argrest + 1 , 0 , FALSE ) ; if ( * tp < 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>bad<S2SV_blank>time<S2SV_blank>value<S2SV_blank>%s:<S2SV_blank>abandoned\\n"" , argv [ i ] ) ; exit ( EXIT_FAILURE ) ; } } else if ( Ustrcmp ( argrest , ""X"" ) == 0 ) override_local_interfaces = argv [ ++ i ] ; else badarg = TRUE ; break ; case 'p' : # ifdef EXIM_PERL if ( * argrest == 's' && argrest [ 1 ] == 0 ) { perl_start_option = 1 ; break ; } if ( * argrest == 'd' && argrest [ 1 ] == 0 ) { perl_start_option = - 1 ; break ; } # endif if ( * argrest == 0 ) { if ( i + 1 < argc ) argrest = argv [ ++ i ] ; else { badarg = TRUE ; break ; } } if ( * argrest != 0 ) {  uschar * hn = Ustrchr ( argrest , ':' ) ;  if ( hn == NULL ) { received_protocol = argrest ; } else { int old_pool = store_pool ; store_pool = POOL_PERM ; received_protocol = string_copyn ( argrest , hn - argrest ) ; store_pool = old_pool ; sender_host_name = hn + 1 ; } } break ; case 'q' : receiving_message = FALSE ; if ( queue_interval >= 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>-q<S2SV_blank>specified<S2SV_blank>more<S2SV_blank>than<S2SV_blank>once\\n"" ) ; exit ( EXIT_FAILURE ) ; } if ( * argrest == 'q' ) { queue_2stage = TRUE ; argrest ++ ; } if ( * argrest == 'i' ) { queue_run_first_delivery = TRUE ; argrest ++ ; } if ( * argrest == 'f' ) { queue_run_force = TRUE ; if ( * ++ argrest == 'f' ) { deliver_force_thaw = TRUE ; argrest ++ ; } } if ( * argrest == 'l' ) { queue_run_local = TRUE ; argrest ++ ; } if ( * argrest == 'G' ) { int i ; for ( argrest ++ , i = 0 ; argrest [ i ] && argrest [ i ] != '/' ; ) i ++ ; queue_name = string_copyn ( argrest , i ) ; argrest += i ; if ( * argrest == '/' ) argrest ++ ; } if ( * argrest == 0 && ( i + 1 >= argc || argv [ i + 1 ] [ 0 ] == '-' || mac_ismsgid ( argv [ i + 1 ] ) ) ) { queue_interval = 0 ; if ( i + 1 < argc && mac_ismsgid ( argv [ i + 1 ] ) ) start_queue_run_id = argv [ ++ i ] ; if ( i + 1 < argc && mac_ismsgid ( argv [ i + 1 ] ) ) stop_queue_run_id = argv [ ++ i ] ; } else if ( ( queue_interval = readconf_readtime ( * argrest ? argrest : argv [ ++ i ] , 0 , FALSE ) ) <= 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>bad<S2SV_blank>time<S2SV_blank>value<S2SV_blank>%s:<S2SV_blank>abandoned\\n"" , argv [ i ] ) ; exit ( EXIT_FAILURE ) ; } break ; case 'R' : receiving_message = FALSE ; if ( * argrest != 0 ) { int i ; for ( i = 0 ; i < nelem ( rsopts ) ; i ++ ) if ( Ustrcmp ( argrest , rsopts [ i ] ) == 0 ) { if ( i != 2 ) queue_run_force = TRUE ; if ( i >= 2 ) deliver_selectstring_regex = TRUE ; if ( i == 1 || i == 4 ) deliver_force_thaw = TRUE ; argrest += Ustrlen ( rsopts [ i ] ) ; } } if ( * argrest ) deliver_selectstring = argrest ; else if ( i + 1 < argc ) deliver_selectstring = argv [ ++ i ] ; else { fprintf ( stderr , ""exim:<S2SV_blank>string<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>-R\\n"" ) ; exit ( EXIT_FAILURE ) ; } break ; case 'S' : receiving_message = FALSE ; if ( * argrest ) { int i ; for ( i = 0 ; i < nelem ( rsopts ) ; i ++ ) if ( Ustrcmp ( argrest , rsopts [ i ] ) == 0 ) { if ( i != 2 ) queue_run_force = TRUE ; if ( i >= 2 ) deliver_selectstring_sender_regex = TRUE ; if ( i == 1 || i == 4 ) deliver_force_thaw = TRUE ; argrest += Ustrlen ( rsopts [ i ] ) ; } } if ( * argrest ) deliver_selectstring_sender = argrest ; else if ( i + 1 < argc ) deliver_selectstring_sender = argv [ ++ i ] ; else { fprintf ( stderr , ""exim:<S2SV_blank>string<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>-S\\n"" ) ; exit ( EXIT_FAILURE ) ; } break ; case 'T' : if ( running_in_test_harness && Ustrcmp ( argrest , ""qt"" ) == 0 ) fudged_queue_times = argv [ ++ i ] ; else badarg = TRUE ; break ; case 't' : if ( * argrest == 0 ) extract_recipients = TRUE ; else if ( Ustrcmp ( argrest , ""i"" ) == 0 ) { extract_recipients = TRUE ; dot_ends = FALSE ; } # ifdef SUPPORT_TLS else if ( Ustrcmp ( argrest , ""ls-on-connect"" ) == 0 ) tls_in . on_connect = TRUE ; # endif else badarg = TRUE ; break ; case 'U' : break ; case 'v' : if ( * argrest == 0 ) { debug_selector |= D_v ; debug_file = stderr ; } else badarg = TRUE ; break ; case 'x' : if ( * argrest != 0 ) badarg = TRUE ; break ; case 'X' : if ( * argrest == '\\0' ) if ( ++ i >= argc ) { fprintf ( stderr , ""exim:<S2SV_blank>string<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>-X\\n"" ) ; exit ( EXIT_FAILURE ) ; } break ; case 'z' : if ( * argrest == '\\0' ) if ( ++ i < argc ) log_oneline = argv [ i ] ; else { fprintf ( stderr , ""exim:<S2SV_blank>file<S2SV_blank>name<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>%s\\n"" , argv [ i - 1 ] ) ; exit ( EXIT_FAILURE ) ; } break ; default : badarg = TRUE ; break ; } if ( badarg ) { fprintf ( stderr , ""exim<S2SV_blank>abandoned:<S2SV_blank>unknown,<S2SV_blank>malformed,<S2SV_blank>or<S2SV_blank>incomplete<S2SV_blank>"" ""option<S2SV_blank>%s\\n"" , arg ) ; exit ( EXIT_FAILURE ) ; } } if ( ( deliver_selectstring || deliver_selectstring_sender ) && queue_interval < 0 ) queue_interval = 0 ; END_ARG : if ( usage_wanted ) exim_usage ( called_as ) ; if ( ( ( smtp_input || extract_recipients || recipients_arg < argc ) && ( daemon_listen || queue_interval >= 0 || bi_option || test_retry_arg >= 0 || test_rewrite_arg >= 0 || filter_test != FTEST_NONE || ( msg_action_arg > 0 && ! one_msg_action ) ) ) || ( msg_action_arg > 0 && ( daemon_listen || queue_interval > 0 || list_options || ( checking && msg_action != MSG_LOAD ) || bi_option || test_retry_arg >= 0 || test_rewrite_arg >= 0 ) ) || ( ( daemon_listen || queue_interval > 0 ) && ( sender_address != NULL || list_options || list_queue || checking || bi_option ) ) || ( daemon_listen && queue_interval == 0 ) || ( inetd_wait_mode && queue_interval >= 0 ) || ( list_options && ( checking || smtp_input || extract_recipients || filter_test != FTEST_NONE || bi_option ) ) || ( verify_address_mode && ( address_test_mode || smtp_input || extract_recipients || filter_test != FTEST_NONE || bi_option ) ) || ( address_test_mode && ( smtp_input || extract_recipients || filter_test != FTEST_NONE || bi_option ) ) || ( smtp_input && ( sender_address != NULL || filter_test != FTEST_NONE || extract_recipients ) ) || ( deliver_selectstring != NULL && queue_interval < 0 ) || ( msg_action == MSG_LOAD && ( ! expansion_test || expansion_test_message != NULL ) ) ) { fprintf ( stderr , ""exim:<S2SV_blank>incompatible<S2SV_blank>command-line<S2SV_blank>options<S2SV_blank>or<S2SV_blank>arguments\\n"" ) ; exit ( EXIT_FAILURE ) ; } if ( debug_selector != 0 ) { debug_file = stderr ; debug_fd = fileno ( debug_file ) ; background_daemon = FALSE ; if ( running_in_test_harness ) millisleep ( 100 ) ; if ( debug_selector != D_v ) { debug_printf ( ""Exim<S2SV_blank>version<S2SV_blank>%s<S2SV_blank>uid=%ld<S2SV_blank>gid=%ld<S2SV_blank>pid=%d<S2SV_blank>D=%x\\n"" , version_string , ( long int ) real_uid , ( long int ) real_gid , ( int ) getpid ( ) , debug_selector ) ; if ( ! version_printed ) show_whats_supported ( stderr ) ; } } if ( unprivileged ) { DEBUG ( D_any ) debug_print_ids ( US ""Exim<S2SV_blank>has<S2SV_blank>no<S2SV_blank>root<S2SV_blank>privilege:"" ) ; } else { struct rlimit rlp ; # ifdef RLIMIT_NOFILE if ( getrlimit ( RLIMIT_NOFILE , & rlp ) < 0 ) { log_write ( 0 , LOG_MAIN | LOG_PANIC , ""getrlimit(RLIMIT_NOFILE)<S2SV_blank>failed:<S2SV_blank>%s"" , strerror ( errno ) ) ; rlp . rlim_cur = rlp . rlim_max = 0 ; } if ( rlp . rlim_cur < 1000 ) { rlp . rlim_cur = rlp . rlim_max = 1000 ; if ( setrlimit ( RLIMIT_NOFILE , & rlp ) < 0 ) { rlp . rlim_cur = rlp . rlim_max = 256 ; if ( setrlimit ( RLIMIT_NOFILE , & rlp ) < 0 ) log_write ( 0 , LOG_MAIN | LOG_PANIC , ""setrlimit(RLIMIT_NOFILE)<S2SV_blank>failed:<S2SV_blank>%s"" , strerror ( errno ) ) ; } } # endif # ifdef RLIMIT_NPROC if ( getrlimit ( RLIMIT_NPROC , & rlp ) < 0 ) { log_write ( 0 , LOG_MAIN | LOG_PANIC , ""getrlimit(RLIMIT_NPROC)<S2SV_blank>failed:<S2SV_blank>%s"" , strerror ( errno ) ) ; rlp . rlim_cur = rlp . rlim_max = 0 ; } # ifdef RLIM_INFINITY if ( rlp . rlim_cur != RLIM_INFINITY && rlp . rlim_cur < 1000 ) { rlp . rlim_cur = rlp . rlim_max = RLIM_INFINITY ; # else if ( rlp . rlim_cur < 1000 ) { rlp . rlim_cur = rlp . rlim_max = 1000 ; # endif if ( setrlimit ( RLIMIT_NPROC , & rlp ) < 0 ) log_write ( 0 , LOG_MAIN | LOG_PANIC , ""setrlimit(RLIMIT_NPROC)<S2SV_blank>failed:<S2SV_blank>%s"" , strerror ( errno ) ) ; } # endif } group_count = getgroups ( NGROUPS_MAX , group_list ) ; if ( group_count < 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>getgroups()<S2SV_blank>failed:<S2SV_blank>%s\\n"" , strerror ( errno ) ) ; exit ( EXIT_FAILURE ) ; } if ( setgroups ( 0 , NULL ) != 0 ) { if ( setgroups ( 1 , group_list ) != 0 && ! unprivileged ) { fprintf ( stderr , ""exim:<S2SV_blank>setgroups()<S2SV_blank>failed:<S2SV_blank>%s\\n"" , strerror ( errno ) ) ; exit ( EXIT_FAILURE ) ; } } if ( ( ( ! trusted_config || ! macros_trusted ( opt_D_used ) ) && real_uid != root_uid && ! running_in_test_harness ) || expansion_test || filter_test != FTEST_NONE ) { setgroups ( group_count , group_list ) ; exim_setugid ( real_uid , real_gid , FALSE , US ""-C,<S2SV_blank>-D,<S2SV_blank>-be<S2SV_blank>or<S2SV_blank>-bf<S2SV_blank>forces<S2SV_blank>real<S2SV_blank>uid"" ) ; removed_privilege = TRUE ; if ( ( log_stderr != NULL ) && ( real_uid != exim_uid ) ) really_exim = FALSE ; } else exim_setugid ( geteuid ( ) , getegid ( ) , FALSE , US ""forcing<S2SV_blank>real<S2SV_blank>=<S2SV_blank>effective"" ) ; if ( ( filter_test & FTEST_SYSTEM ) != 0 ) { filter_sfd = Uopen ( filter_test_sfile , O_RDONLY , 0 ) ; if ( filter_sfd < 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s:<S2SV_blank>%s\\n"" , filter_test_sfile , strerror ( errno ) ) ; return EXIT_FAILURE ; } } if ( ( filter_test & FTEST_USER ) != 0 ) { filter_ufd = Uopen ( filter_test_ufile , O_RDONLY , 0 ) ; if ( filter_ufd < 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s:<S2SV_blank>%s\\n"" , filter_test_ufile , strerror ( errno ) ) ; return EXIT_FAILURE ; } } init_lookup_list ( ) ; # ifdef SUPPORT_I18N if ( running_in_test_harness ) smtputf8_advertise_hosts = NULL ; # endif if ( ( initial_cwd = os_getcwd ( NULL , 0 ) ) == NULL ) { perror ( ""exim:<S2SV_blank>can\'t<S2SV_blank>get<S2SV_blank>the<S2SV_blank>current<S2SV_blank>working<S2SV_blank>directory"" ) ; exit ( EXIT_FAILURE ) ; } readconf_main ( checking || list_options ) ; if ( builtin_macros_create_trigger ) DEBUG ( D_any ) debug_printf ( ""Builtin<S2SV_blank>macros<S2SV_blank>created<S2SV_blank>(expensive)<S2SV_blank>due<S2SV_blank>to<S2SV_blank>config<S2SV_blank>line<S2SV_blank>\'%.*s\'\\n"" , Ustrlen ( builtin_macros_create_trigger ) - 1 , builtin_macros_create_trigger ) ; if ( cleanup_environment ( ) == FALSE ) log_write ( 0 , LOG_PANIC_DIE , ""Can\'t<S2SV_blank>cleanup<S2SV_blank>environment"" ) ; if ( real_uid == root_uid || real_uid == exim_uid || real_gid == exim_gid ) admin_user = TRUE ; else { int i , j ; for ( i = 0 ; i < group_count && ! admin_user ; i ++ ) if ( group_list [ i ] == exim_gid ) admin_user = TRUE ; else if ( admin_groups ) for ( j = 1 ; j <= ( int ) admin_groups [ 0 ] && ! admin_user ; j ++ ) if ( admin_groups [ j ] == group_list [ i ] ) admin_user = TRUE ; } if ( real_uid == root_uid || real_uid == exim_uid ) trusted_caller = TRUE ; else { int i , j ; if ( trusted_users ) for ( i = 1 ; i <= ( int ) trusted_users [ 0 ] && ! trusted_caller ; i ++ ) if ( trusted_users [ i ] == real_uid ) trusted_caller = TRUE ; if ( trusted_groups ) for ( i = 1 ; i <= ( int ) trusted_groups [ 0 ] && ! trusted_caller ; i ++ ) if ( trusted_groups [ i ] == real_gid ) trusted_caller = TRUE ; else for ( j = 0 ; j < group_count && ! trusted_caller ; j ++ ) if ( trusted_groups [ i ] == group_list [ j ] ) trusted_caller = TRUE ; } if ( checking && commandline_checks_require_admin && ! admin_user ) { fprintf ( stderr , ""exim:<S2SV_blank>those<S2SV_blank>command-line<S2SV_blank>flags<S2SV_blank>are<S2SV_blank>set<S2SV_blank>to<S2SV_blank>require<S2SV_blank>admin\\n"" ) ; exit ( EXIT_FAILURE ) ; } decode_bits ( log_selector , log_selector_size , log_notall , log_selector_string , log_options , log_options_count , US ""log"" , 0 ) ; DEBUG ( D_any ) { int i ; debug_printf ( ""configuration<S2SV_blank>file<S2SV_blank>is<S2SV_blank>%s\\n"" , config_main_filename ) ; debug_printf ( ""log<S2SV_blank>selectors<S2SV_blank>="" ) ; for ( i = 0 ; i < log_selector_size ; i ++ ) debug_printf ( ""<S2SV_blank>%08x"" , log_selector [ i ] ) ; debug_printf ( ""\\n"" ) ; } if ( sender_address != NULL ) { if ( sender_address [ sender_address_domain ] == '[' && ! allow_domain_literals ) { fprintf ( stderr , ""exim:<S2SV_blank>bad<S2SV_blank>-f<S2SV_blank>address<S2SV_blank>\\""%s\\"":<S2SV_blank>domain<S2SV_blank>literals<S2SV_blank>not<S2SV_blank>"" ""allowed\\n"" , sender_address ) ; return EXIT_FAILURE ; } if ( f_end_dot && ! strip_trailing_dot ) { fprintf ( stderr , ""exim:<S2SV_blank>bad<S2SV_blank>-f<S2SV_blank>address<S2SV_blank>\\""%s.\\"":<S2SV_blank>domain<S2SV_blank>is<S2SV_blank>malformed<S2SV_blank>"" ""(trailing<S2SV_blank>dot<S2SV_blank>not<S2SV_blank>allowed)\\n"" , sender_address ) ; return EXIT_FAILURE ; } } if ( cmdline_syslog_name != NULL ) { if ( admin_user ) { syslog_processname = cmdline_syslog_name ; log_file_path = string_copy ( CUS ""syslog"" ) ; } else { fprintf ( stderr , ""exim:<S2SV_blank>you<S2SV_blank>lack<S2SV_blank>sufficient<S2SV_blank>privilege<S2SV_blank>to<S2SV_blank>specify<S2SV_blank>syslog<S2SV_blank>process<S2SV_blank>name\\n"" ) ; return EXIT_FAILURE ; } } if ( Ustrlen ( log_file_path ) > 200 ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , ""log_file_path<S2SV_blank>is<S2SV_blank>longer<S2SV_blank>than<S2SV_blank>200<S2SV_blank>chars:<S2SV_blank>aborting"" ) ; if ( Ustrlen ( pid_file_path ) > 200 ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , ""pid_file_path<S2SV_blank>is<S2SV_blank>longer<S2SV_blank>than<S2SV_blank>200<S2SV_blank>chars:<S2SV_blank>aborting"" ) ; if ( Ustrlen ( spool_directory ) > 200 ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , ""spool_directory<S2SV_blank>is<S2SV_blank>longer<S2SV_blank>than<S2SV_blank>200<S2SV_blank>chars:<S2SV_blank>aborting"" ) ; if ( Ustrlen ( syslog_processname ) > 32 ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , ""syslog_processname<S2SV_blank>is<S2SV_blank>longer<S2SV_blank>than<S2SV_blank>32<S2SV_blank>chars:<S2SV_blank>aborting"" ) ; if ( log_oneline ) if ( admin_user ) { log_write ( 0 , LOG_MAIN , ""%s"" , log_oneline ) ; return EXIT_SUCCESS ; } else return EXIT_FAILURE ; # ifdef EXIM_TMPDIR { uschar * * p ; if ( environ ) for ( p = USS environ ; * p ; p ++ ) if ( Ustrncmp ( * p , ""TMPDIR="" , 7 ) == 0 && Ustrcmp ( * p + 7 , EXIM_TMPDIR ) != 0 ) { uschar * newp = store_malloc ( Ustrlen ( EXIM_TMPDIR ) + 8 ) ; sprintf ( CS newp , ""TMPDIR=%s"" , EXIM_TMPDIR ) ; * p = newp ; DEBUG ( D_any ) debug_printf ( ""reset<S2SV_blank>TMPDIR=%s<S2SV_blank>in<S2SV_blank>environment\\n"" , EXIM_TMPDIR ) ; } } # endif if ( timezone_string && strcmpic ( timezone_string , US ""UTC"" ) == 0 ) timestamps_utc = TRUE ; else { uschar * envtz = US getenv ( ""TZ"" ) ; if ( envtz ? ! timezone_string || Ustrcmp ( timezone_string , envtz ) != 0 : timezone_string != NULL ) { uschar * * p = USS environ ; uschar * * new ; uschar * * newp ; int count = 0 ; if ( environ ) while ( * p ++ ) count ++ ; if ( ! envtz ) count ++ ; newp = new = store_malloc ( sizeof ( uschar * ) * ( count + 1 ) ) ; if ( environ ) for ( p = USS environ ; * p ; p ++ ) if ( Ustrncmp ( * p , ""TZ="" , 3 ) != 0 ) * newp ++ = * p ; if ( timezone_string ) { * newp = store_malloc ( Ustrlen ( timezone_string ) + 4 ) ; sprintf ( CS * newp ++ , ""TZ=%s"" , timezone_string ) ; } * newp = NULL ; environ = CSS new ; tzset ( ) ; DEBUG ( D_any ) debug_printf ( ""Reset<S2SV_blank>TZ<S2SV_blank>to<S2SV_blank>%s:<S2SV_blank>time<S2SV_blank>is<S2SV_blank>%s\\n"" , timezone_string , tod_stamp ( tod_log ) ) ; } } if ( removed_privilege && ( ! trusted_config || opt_D_used ) && real_uid == exim_uid ) if ( deliver_drop_privilege ) really_exim = TRUE ; else log_write ( 0 , LOG_MAIN | LOG_PANIC , ""exim<S2SV_blank>user<S2SV_blank>lost<S2SV_blank>privilege<S2SV_blank>for<S2SV_blank>using<S2SV_blank>%s<S2SV_blank>option"" , trusted_config ? ""-D"" : ""-C"" ) ; # ifdef EXIM_PERL if ( perl_start_option != 0 ) opt_perl_at_start = ( perl_start_option > 0 ) ; if ( opt_perl_at_start && opt_perl_startup != NULL ) { uschar * errstr ; DEBUG ( D_any ) debug_printf ( ""Starting<S2SV_blank>Perl<S2SV_blank>interpreter\\n"" ) ; errstr = init_perl ( opt_perl_startup ) ; if ( errstr != NULL ) { fprintf ( stderr , ""exim:<S2SV_blank>error<S2SV_blank>in<S2SV_blank>perl_startup<S2SV_blank>code:<S2SV_blank>%s\\n"" , errstr ) ; return EXIT_FAILURE ; } opt_perl_started = TRUE ; } # endif if ( ( ( debug_selector & D_any ) != 0 || LOGGING ( arguments ) ) && really_exim && ! list_options && ! checking ) { int i ; uschar * p = big_buffer ; Ustrcpy ( p , ""cwd=<S2SV_blank>(failed)"" ) ; Ustrncpy ( p + 4 , initial_cwd , big_buffer_size - 5 ) ; while ( * p ) p ++ ; ( void ) string_format ( p , big_buffer_size - ( p - big_buffer ) , ""<S2SV_blank>%d<S2SV_blank>args:"" , argc ) ; while ( * p ) p ++ ; for ( i = 0 ; i < argc ; i ++ ) { int len = Ustrlen ( argv [ i ] ) ; const uschar * printing ; uschar * quote ; if ( p + len + 8 >= big_buffer + big_buffer_size ) { Ustrcpy ( p , ""<S2SV_blank>..."" ) ; log_write ( 0 , LOG_MAIN , ""%s"" , big_buffer ) ; Ustrcpy ( big_buffer , ""..."" ) ; p = big_buffer + 3 ; } printing = string_printing ( argv [ i ] ) ; if ( printing [ 0 ] == 0 ) quote = US ""\\"""" ; else { const uschar * pp = printing ; quote = US """" ; while ( * pp != 0 ) if ( isspace ( * pp ++ ) ) { quote = US ""\\"""" ; break ; } } sprintf ( CS p , ""<S2SV_blank>%s%.*s%s"" , quote , ( int ) ( big_buffer_size - ( p - big_buffer ) - 4 ) , printing , quote ) ; while ( * p ) p ++ ; } if ( LOGGING ( arguments ) ) log_write ( 0 , LOG_MAIN , ""%s"" , big_buffer ) ; else debug_printf ( ""%s\\n"" , big_buffer ) ; } if ( Uchdir ( spool_directory ) != 0 ) { int dummy ; ( void ) directory_make ( spool_directory , US """" , SPOOL_DIRECTORY_MODE , FALSE ) ; dummy = Uchdir ( spool_directory ) ; } if ( bi_option ) { ( void ) fclose ( config_file ) ; if ( bi_command != NULL ) { int i = 0 ; uschar * argv [ 3 ] ; argv [ i ++ ] = bi_command ; if ( alias_arg != NULL ) argv [ i ++ ] = alias_arg ; argv [ i ++ ] = NULL ; setgroups ( group_count , group_list ) ; exim_setugid ( real_uid , real_gid , FALSE , US ""running<S2SV_blank>bi_command"" ) ; DEBUG ( D_exec ) debug_printf ( ""exec<S2SV_blank>%.256s<S2SV_blank>%.256s\\n"" , argv [ 0 ] , ( argv [ 1 ] == NULL ) ? US """" : argv [ 1 ] ) ; execv ( CS argv [ 0 ] , ( char * const * ) argv ) ; fprintf ( stderr , ""exim:<S2SV_blank>exec<S2SV_blank>failed:<S2SV_blank>%s\\n"" , strerror ( errno ) ) ; exit ( EXIT_FAILURE ) ; } else { DEBUG ( D_any ) debug_printf ( ""-bi<S2SV_blank>used<S2SV_blank>but<S2SV_blank>bi_command<S2SV_blank>not<S2SV_blank>set;<S2SV_blank>exiting\\n"" ) ; exit ( EXIT_SUCCESS ) ; } } if ( trusted_caller ) DEBUG ( D_any ) debug_printf ( ""trusted<S2SV_blank>user\\n"" ) ; if ( admin_user ) DEBUG ( D_any ) debug_printf ( ""admin<S2SV_blank>user\\n"" ) ; if ( ! admin_user ) { BOOL debugset = ( debug_selector & ~ D_v ) != 0 ; if ( deliver_give_up || daemon_listen || malware_test_file || ( count_queue && queue_list_requires_admin ) || ( list_queue && queue_list_requires_admin ) || ( queue_interval >= 0 && prod_requires_admin ) || ( debugset && ! running_in_test_harness ) ) { fprintf ( stderr , ""exim:%s<S2SV_blank>permission<S2SV_blank>denied\\n"" , debugset ? ""<S2SV_blank>debugging"" : """" ) ; exit ( EXIT_FAILURE ) ; } } if ( real_uid != root_uid && real_uid != exim_uid && ( continue_hostname != NULL || ( dont_deliver && ( queue_interval >= 0 || daemon_listen || msg_action_arg > 0 ) ) ) && ! running_in_test_harness ) { fprintf ( stderr , ""exim:<S2SV_blank>Permission<S2SV_blank>denied\\n"" ) ; return EXIT_FAILURE ; } if ( ! trusted_caller && ! checking ) { sender_host_name = sender_host_address = interface_address = sender_ident = received_protocol = NULL ; sender_host_port = interface_port = 0 ; sender_host_authenticated = authenticated_sender = authenticated_id = NULL ; } else { if ( sender_host_address != NULL ) sender_host_port = check_port ( sender_host_address ) ; if ( interface_address != NULL ) interface_port = check_port ( interface_address ) ; } if ( flag_G ) { if ( trusted_caller ) { suppress_local_fixups = suppress_local_fixups_default = TRUE ; DEBUG ( D_acl ) debug_printf ( ""suppress_local_fixups<S2SV_blank>forced<S2SV_blank>on<S2SV_blank>by<S2SV_blank>-G\\n"" ) ; } else { fprintf ( stderr , ""exim:<S2SV_blank>permission<S2SV_blank>denied<S2SV_blank>(-G<S2SV_blank>requires<S2SV_blank>a<S2SV_blank>trusted<S2SV_blank>user)\\n"" ) ; return EXIT_FAILURE ; } } if ( smtp_input ) { union sockaddr_46 inetd_sock ; EXIM_SOCKLEN_T size = sizeof ( inetd_sock ) ; if ( getpeername ( 0 , ( struct sockaddr * ) ( & inetd_sock ) , & size ) == 0 ) { int family = ( ( struct sockaddr * ) ( & inetd_sock ) ) -> sa_family ; if ( family == AF_INET || family == AF_INET6 ) { union sockaddr_46 interface_sock ; size = sizeof ( interface_sock ) ; if ( getsockname ( 0 , ( struct sockaddr * ) ( & interface_sock ) , & size ) == 0 ) interface_address = host_ntoa ( - 1 , & interface_sock , NULL , & interface_port ) ; if ( host_is_tls_on_connect_port ( interface_port ) ) tls_in . on_connect = TRUE ; if ( real_uid == root_uid || real_uid == exim_uid || interface_port < 1024 ) { is_inetd = TRUE ; sender_host_address = host_ntoa ( - 1 , ( struct sockaddr * ) ( & inetd_sock ) , NULL , & sender_host_port ) ; if ( mua_wrapper ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , ""Input<S2SV_blank>from<S2SV_blank>"" ""inetd<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>when<S2SV_blank>mua_wrapper<S2SV_blank>is<S2SV_blank>set"" ) ; } else { fprintf ( stderr , ""exim:<S2SV_blank>Permission<S2SV_blank>denied<S2SV_blank>(unprivileged<S2SV_blank>user,<S2SV_blank>unprivileged<S2SV_blank>port)\\n"" ) ; return EXIT_FAILURE ; } } } } # ifdef LOAD_AVG_NEEDS_ROOT if ( receiving_message && ( queue_only_load >= 0 || ( is_inetd && smtp_load_reserve >= 0 ) ) ) { load_average = OS_GETLOADAVG ( ) ; } # endif if ( queue_only_set && ( queue_only_override || arg_queue_only ) ) queue_only = arg_queue_only ; if ( arg_receive_timeout >= 0 ) receive_timeout = arg_receive_timeout ; if ( arg_smtp_receive_timeout >= 0 ) smtp_receive_timeout = arg_smtp_receive_timeout ; if ( ! unprivileged && ! removed_privilege && ! daemon_listen && queue_interval <= 0 && ( deliver_drop_privilege || ( queue_interval < 0 && ( msg_action_arg < 0 || msg_action != MSG_DELIVER ) && ( ! checking || ! address_test_mode ) ) ) ) exim_setugid ( exim_uid , exim_gid , TRUE , US ""privilege<S2SV_blank>not<S2SV_blank>needed"" ) ; else { int rv ; rv = setgid ( exim_gid ) ; if ( rv == - 1 ) if ( ! ( unprivileged || removed_privilege ) ) { fprintf ( stderr , ""exim:<S2SV_blank>changing<S2SV_blank>group<S2SV_blank>failed:<S2SV_blank>%s\\n"" , strerror ( errno ) ) ; exit ( EXIT_FAILURE ) ; } else DEBUG ( D_any ) debug_printf ( ""changing<S2SV_blank>group<S2SV_blank>to<S2SV_blank>%ld<S2SV_blank>failed:<S2SV_blank>%s\\n"" , ( long int ) exim_gid , strerror ( errno ) ) ; } if ( malware_test_file ) { # ifdef WITH_CONTENT_SCAN int result ; set_process_info ( ""scanning<S2SV_blank>file<S2SV_blank>for<S2SV_blank>malware"" ) ; result = malware_in_file ( malware_test_file ) ; if ( result == FAIL ) { printf ( ""No<S2SV_blank>malware<S2SV_blank>found.\\n"" ) ; exit ( EXIT_SUCCESS ) ; } if ( result != OK ) { printf ( ""Malware<S2SV_blank>lookup<S2SV_blank>returned<S2SV_blank>non-okay/fail:<S2SV_blank>%d\\n"" , result ) ; exit ( EXIT_FAILURE ) ; } if ( malware_name ) printf ( ""Malware<S2SV_blank>found:<S2SV_blank>%s\\n"" , malware_name ) ; else printf ( ""Malware<S2SV_blank>scan<S2SV_blank>detected<S2SV_blank>malware<S2SV_blank>of<S2SV_blank>unknown<S2SV_blank>name.\\n"" ) ; # else printf ( ""Malware<S2SV_blank>scanning<S2SV_blank>not<S2SV_blank>enabled<S2SV_blank>at<S2SV_blank>compile<S2SV_blank>time.\\n"" ) ; # endif exit ( EXIT_FAILURE ) ; } if ( list_queue ) { set_process_info ( ""listing<S2SV_blank>the<S2SV_blank>queue"" ) ; queue_list ( list_queue_option , argv + recipients_arg , argc - recipients_arg ) ; exit ( EXIT_SUCCESS ) ; } if ( count_queue ) { set_process_info ( ""counting<S2SV_blank>the<S2SV_blank>queue"" ) ; queue_count ( ) ; exit ( EXIT_SUCCESS ) ; } if ( msg_action_arg > 0 && msg_action != MSG_DELIVER && msg_action != MSG_LOAD ) { int yield = EXIT_SUCCESS ; set_process_info ( ""acting<S2SV_blank>on<S2SV_blank>specified<S2SV_blank>messages"" ) ; if ( ! one_msg_action ) { for ( i = msg_action_arg ; i < argc ; i ++ ) if ( ! queue_action ( argv [ i ] , msg_action , NULL , 0 , 0 ) ) yield = EXIT_FAILURE ; } else if ( ! queue_action ( argv [ msg_action_arg ] , msg_action , argv , argc , recipients_arg ) ) yield = EXIT_FAILURE ; exit ( yield ) ; } readconf_rest ( ) ; store_pool = POOL_MAIN ; if ( test_retry_arg >= 0 ) { retry_config * yield ; int basic_errno = 0 ; int more_errno = 0 ; uschar * s1 , * s2 ; if ( test_retry_arg >= argc ) { printf ( ""-brt<S2SV_blank>needs<S2SV_blank>a<S2SV_blank>domain<S2SV_blank>or<S2SV_blank>address<S2SV_blank>argument\\n"" ) ; exim_exit ( EXIT_FAILURE ) ; } s1 = argv [ test_retry_arg ++ ] ; s2 = NULL ; if ( Ustrchr ( s1 , '@' ) == NULL && Ustrchr ( s1 , '.' ) == NULL ) { printf ( ""Warning:<S2SV_blank>\\""%s\\""<S2SV_blank>contains<S2SV_blank>no<S2SV_blank>\'@\'<S2SV_blank>and<S2SV_blank>no<S2SV_blank>\'.\'<S2SV_blank>characters.<S2SV_blank>It<S2SV_blank>is<S2SV_blank>"" ""being<S2SV_blank>\\ntreated<S2SV_blank>as<S2SV_blank>a<S2SV_blank>one-component<S2SV_blank>domain,<S2SV_blank>not<S2SV_blank>as<S2SV_blank>a<S2SV_blank>local<S2SV_blank>part.\\n\\n"" , s1 ) ; } if ( test_retry_arg < argc && Ustrchr ( argv [ test_retry_arg ] , '.' ) != NULL ) s2 = argv [ test_retry_arg ++ ] ; if ( test_retry_arg < argc ) { uschar * ss = argv [ test_retry_arg ] ; uschar * error = readconf_retry_error ( ss , ss + Ustrlen ( ss ) , & basic_errno , & more_errno ) ; if ( error != NULL ) { printf ( ""%s\\n"" , CS error ) ; return EXIT_FAILURE ; } if ( basic_errno == ERRNO_MAIL4XX || basic_errno == ERRNO_RCPT4XX || basic_errno == ERRNO_DATA4XX ) { int code = ( more_errno >> 8 ) & 255 ; if ( code == 255 ) more_errno = ( more_errno & 0xffff00ff ) | ( 21 << 8 ) ; else if ( code > 100 ) more_errno = ( more_errno & 0xffff00ff ) | ( ( code - 96 ) << 8 ) ; } } yield = retry_find_config ( s1 , s2 , basic_errno , more_errno ) ; if ( yield == NULL ) printf ( ""No<S2SV_blank>retry<S2SV_blank>information<S2SV_blank>found\\n"" ) ; else { retry_rule * r ; more_errno = yield -> more_errno ; printf ( ""Retry<S2SV_blank>rule:<S2SV_blank>%s<S2SV_blank><S2SV_blank>"" , yield -> pattern ) ; if ( yield -> basic_errno == ERRNO_EXIMQUOTA ) { printf ( ""quota%s%s<S2SV_blank><S2SV_blank>"" , ( more_errno > 0 ) ? ""_"" : """" , ( more_errno > 0 ) ? readconf_printtime ( more_errno ) : US """" ) ; } else if ( yield -> basic_errno == ECONNREFUSED ) { printf ( ""refused%s%s<S2SV_blank><S2SV_blank>"" , ( more_errno > 0 ) ? ""_"" : """" , ( more_errno == 'M' ) ? ""MX"" : ( more_errno == 'A' ) ? ""A"" : """" ) ; } else if ( yield -> basic_errno == ETIMEDOUT ) { printf ( ""timeout"" ) ; if ( ( more_errno & RTEF_CTOUT ) != 0 ) printf ( ""_connect"" ) ; more_errno &= 255 ; if ( more_errno != 0 ) printf ( ""_%s"" , ( more_errno == 'M' ) ? ""MX"" : ""A"" ) ; printf ( ""<S2SV_blank><S2SV_blank>"" ) ; } else if ( yield -> basic_errno == ERRNO_AUTHFAIL ) printf ( ""auth_failed<S2SV_blank><S2SV_blank>"" ) ; else printf ( ""*<S2SV_blank><S2SV_blank>"" ) ; for ( r = yield -> rules ; r != NULL ; r = r -> next ) { printf ( ""%c,%s"" , r -> rule , readconf_printtime ( r -> timeout ) ) ; printf ( "",%s"" , readconf_printtime ( r -> p1 ) ) ; if ( r -> rule == 'G' ) { int x = r -> p2 ; int f = x % 1000 ; int d = 100 ; printf ( "",%d."" , x / 1000 ) ; do { printf ( ""%d"" , f / d ) ; f %= d ; d /= 10 ; } while ( f != 0 ) ; } printf ( "";<S2SV_blank>"" ) ; } printf ( ""\\n"" ) ; } exim_exit ( EXIT_SUCCESS ) ; } if ( list_options ) { set_process_info ( ""listing<S2SV_blank>variables"" ) ; if ( recipients_arg >= argc ) readconf_print ( US ""all"" , NULL , flag_n ) ; else for ( i = recipients_arg ; i < argc ; i ++ ) { if ( i < argc - 1 && ( Ustrcmp ( argv [ i ] , ""router"" ) == 0 || Ustrcmp ( argv [ i ] , ""transport"" ) == 0 || Ustrcmp ( argv [ i ] , ""authenticator"" ) == 0 || Ustrcmp ( argv [ i ] , ""macro"" ) == 0 || Ustrcmp ( argv [ i ] , ""environment"" ) == 0 ) ) { readconf_print ( argv [ i + 1 ] , argv [ i ] , flag_n ) ; i ++ ; } else readconf_print ( argv [ i ] , NULL , flag_n ) ; } exim_exit ( EXIT_SUCCESS ) ; } if ( list_config ) { set_process_info ( ""listing<S2SV_blank>config"" ) ; readconf_print ( US ""config"" , NULL , flag_n ) ; exim_exit ( EXIT_SUCCESS ) ; } # ifndef DISABLE_DKIM dkim_exim_init ( ) ; # endif deliver_init ( ) ; if ( msg_action_arg > 0 && msg_action != MSG_LOAD ) { if ( prod_requires_admin && ! admin_user ) { fprintf ( stderr , ""exim:<S2SV_blank>Permission<S2SV_blank>denied\\n"" ) ; exim_exit ( EXIT_FAILURE ) ; } set_process_info ( ""delivering<S2SV_blank>specified<S2SV_blank>messages"" ) ; if ( deliver_give_up ) forced_delivery = deliver_force_thaw = TRUE ; for ( i = msg_action_arg ; i < argc ; i ++ ) { int status ; pid_t pid ; if ( i == argc - 1 ) ( void ) deliver_message ( argv [ i ] , forced_delivery , deliver_give_up ) ; else if ( ( pid = fork ( ) ) == 0 ) { ( void ) deliver_message ( argv [ i ] , forced_delivery , deliver_give_up ) ; _exit ( EXIT_SUCCESS ) ; } else if ( pid < 0 ) { fprintf ( stderr , ""failed<S2SV_blank>to<S2SV_blank>fork<S2SV_blank>delivery<S2SV_blank>process<S2SV_blank>for<S2SV_blank>%s:<S2SV_blank>%s\\n"" , argv [ i ] , strerror ( errno ) ) ; exim_exit ( EXIT_FAILURE ) ; } else wait ( & status ) ; } exim_exit ( EXIT_SUCCESS ) ; } if ( queue_interval == 0 && ! daemon_listen ) { DEBUG ( D_queue_run ) debug_printf ( ""Single<S2SV_blank>queue<S2SV_blank>run%s%s%s%s\\n"" , ( start_queue_run_id == NULL ) ? US """" : US ""<S2SV_blank>starting<S2SV_blank>at<S2SV_blank>"" , ( start_queue_run_id == NULL ) ? US """" : start_queue_run_id , ( stop_queue_run_id == NULL ) ? US """" : US ""<S2SV_blank>stopping<S2SV_blank>at<S2SV_blank>"" , ( stop_queue_run_id == NULL ) ? US """" : stop_queue_run_id ) ; if ( * queue_name ) set_process_info ( ""running<S2SV_blank>the<S2SV_blank>\'%s\'<S2SV_blank>queue<S2SV_blank>(single<S2SV_blank>queue<S2SV_blank>run)"" , queue_name ) ; else set_process_info ( ""running<S2SV_blank>the<S2SV_blank>queue<S2SV_blank>(single<S2SV_blank>queue<S2SV_blank>run)"" ) ; queue_run ( start_queue_run_id , stop_queue_run_id , FALSE ) ; exim_exit ( EXIT_SUCCESS ) ; } for ( i = 0 ; ; ) { if ( ( pw = getpwuid ( real_uid ) ) != NULL ) { originator_login = string_copy ( US pw -> pw_name ) ; originator_home = string_copy ( US pw -> pw_dir ) ; if ( originator_name == NULL ) { if ( sender_address == NULL || ( ! trusted_caller && filter_test == FTEST_NONE ) ) { uschar * name = US pw -> pw_gecos ; uschar * amp = Ustrchr ( name , '&' ) ; uschar buffer [ 256 ] ; if ( amp != NULL ) { int loffset ; string_format ( buffer , sizeof ( buffer ) , ""%.*s%n%s%s"" , amp - name , name , & loffset , originator_login , amp + 1 ) ; buffer [ loffset ] = toupper ( buffer [ loffset ] ) ; name = buffer ; } if ( gecos_pattern != NULL && gecos_name != NULL ) { const pcre * re ; re = regex_must_compile ( gecos_pattern , FALSE , TRUE ) ; if ( regex_match_and_setup ( re , name , 0 , - 1 ) ) { uschar * new_name = expand_string ( gecos_name ) ; expand_nmax = - 1 ; if ( new_name != NULL ) { DEBUG ( D_receive ) debug_printf ( ""user<S2SV_blank>name<S2SV_blank>\\""%s\\""<S2SV_blank>extracted<S2SV_blank>from<S2SV_blank>"" ""gecos<S2SV_blank>field<S2SV_blank>\\""%s\\""\\n"" , new_name , name ) ; name = new_name ; } else DEBUG ( D_receive ) debug_printf ( ""failed<S2SV_blank>to<S2SV_blank>expand<S2SV_blank>gecos_name<S2SV_blank>string<S2SV_blank>"" ""\\""%s\\"":<S2SV_blank>%s\\n"" , gecos_name , expand_string_message ) ; } else DEBUG ( D_receive ) debug_printf ( ""gecos_pattern<S2SV_blank>\\""%s\\""<S2SV_blank>did<S2SV_blank>not<S2SV_blank>match<S2SV_blank>"" ""gecos<S2SV_blank>field<S2SV_blank>\\""%s\\""\\n"" , gecos_pattern , name ) ; store_free ( ( void * ) re ) ; } originator_name = string_copy ( name ) ; } else originator_name = US """" ; } break ; } if ( ++ i > finduser_retries ) break ; sleep ( 1 ) ; } if ( originator_login == NULL || running_in_test_harness ) { if ( unknown_login != NULL ) { originator_login = expand_string ( unknown_login ) ; if ( originator_name == NULL && unknown_username != NULL ) originator_name = expand_string ( unknown_username ) ; if ( originator_name == NULL ) originator_name = US """" ; } if ( originator_login == NULL ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>user<S2SV_blank>name<S2SV_blank>for<S2SV_blank>uid<S2SV_blank>%d"" , ( int ) real_uid ) ; } originator_name = string_copy ( parse_fix_phrase ( originator_name , Ustrlen ( originator_name ) , big_buffer , big_buffer_size ) ) ; originator_uid = real_uid ; originator_gid = real_gid ; DEBUG ( D_receive ) debug_printf ( ""originator:<S2SV_blank>uid=%d<S2SV_blank>gid=%d<S2SV_blank>login=%s<S2SV_blank>name=%s\\n"" , ( int ) originator_uid , ( int ) originator_gid , originator_login , originator_name ) ; if ( daemon_listen || inetd_wait_mode || queue_interval > 0 ) { if ( mua_wrapper ) { fprintf ( stderr , ""Daemon<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>run<S2SV_blank>when<S2SV_blank>mua_wrapper<S2SV_blank>is<S2SV_blank>set\\n"" ) ; log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , ""Daemon<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>run<S2SV_blank>when<S2SV_blank>"" ""mua_wrapper<S2SV_blank>is<S2SV_blank>set"" ) ; } daemon_go ( ) ; } if ( sender_ident == NULL ) sender_ident = originator_login ; else if ( sender_ident [ 0 ] == 0 ) sender_ident = NULL ; if ( test_rewrite_arg >= 0 ) { really_exim = FALSE ; if ( test_rewrite_arg >= argc ) { printf ( ""-brw<S2SV_blank>needs<S2SV_blank>an<S2SV_blank>address<S2SV_blank>argument\\n"" ) ; exim_exit ( EXIT_FAILURE ) ; } rewrite_test ( argv [ test_rewrite_arg ] ) ; exim_exit ( EXIT_SUCCESS ) ; } if ( ( sender_address == NULL && ! smtp_input ) || ( ! trusted_caller && filter_test == FTEST_NONE ) ) { sender_local = TRUE ; if ( authenticated_sender == NULL && ! host_checking ) authenticated_sender = string_sprintf ( ""%s@%s"" , originator_login , qualify_domain_sender ) ; if ( authenticated_id == NULL && ! host_checking ) authenticated_id = originator_login ; } if ( ( ! smtp_input && sender_address == NULL ) || ! receive_check_set_sender ( sender_address ) ) { if ( sender_address == NULL || ( sender_address [ 0 ] != 0 && ! checking ) ) { sender_address = originator_login ; sender_address_forced = FALSE ; sender_address_domain = 0 ; } } sender_set_untrusted = sender_address != originator_login && ! trusted_caller ; if ( sender_address != NULL && sender_address [ 0 ] != 0 && sender_address_domain == 0 ) sender_address = string_sprintf ( ""%s@%s"" , local_part_quote ( sender_address ) , qualify_domain_sender ) ; DEBUG ( D_receive ) debug_printf ( ""sender<S2SV_blank>address<S2SV_blank>=<S2SV_blank>%s\\n"" , sender_address ) ; if ( verify_address_mode || address_test_mode ) { int exit_value = 0 ; int flags = vopt_qualify ; if ( verify_address_mode ) { if ( ! verify_as_sender ) flags |= vopt_is_recipient ; DEBUG ( D_verify ) debug_print_ids ( US ""Verifying:"" ) ; } else { flags |= vopt_is_recipient ; debug_selector |= D_v ; debug_file = stderr ; debug_fd = fileno ( debug_file ) ; DEBUG ( D_verify ) debug_print_ids ( US ""Address<S2SV_blank>testing:"" ) ; } if ( recipients_arg < argc ) { while ( recipients_arg < argc ) { uschar * s = argv [ recipients_arg ++ ] ; while ( * s != 0 ) { BOOL finished = FALSE ; uschar * ss = parse_find_address_end ( s , FALSE ) ; if ( * ss == ',' ) * ss = 0 ; else finished = TRUE ; test_address ( s , flags , & exit_value ) ; s = ss ; if ( ! finished ) while ( * ( ++ s ) != 0 && ( * s == ',' || isspace ( * s ) ) ) ; } } } else for ( ; ; ) { uschar * s = get_stdinput ( NULL , NULL ) ; if ( s == NULL ) break ; test_address ( s , flags , & exit_value ) ; } route_tidyup ( ) ; exim_exit ( exit_value ) ; } if ( expansion_test ) { dns_init ( FALSE , FALSE , FALSE ) ; if ( msg_action_arg > 0 && msg_action == MSG_LOAD ) { uschar spoolname [ 256 ] ; if ( ! admin_user ) { fprintf ( stderr , ""exim:<S2SV_blank>permission<S2SV_blank>denied\\n"" ) ; exit ( EXIT_FAILURE ) ; } message_id = argv [ msg_action_arg ] ; ( void ) string_format ( spoolname , sizeof ( spoolname ) , ""%s-H"" , message_id ) ; if ( ( deliver_datafile = spool_open_datafile ( message_id ) ) < 0 ) printf ( ""Failed<S2SV_blank>to<S2SV_blank>load<S2SV_blank>message<S2SV_blank>datafile<S2SV_blank>%s\\n"" , message_id ) ; if ( spool_read_header ( spoolname , TRUE , FALSE ) != spool_read_OK ) printf ( ""Failed<S2SV_blank>to<S2SV_blank>load<S2SV_blank>message<S2SV_blank>%s\\n"" , message_id ) ; } else if ( expansion_test_message != NULL ) { int save_stdin = dup ( 0 ) ; int fd = Uopen ( expansion_test_message , O_RDONLY , 0 ) ; if ( fd < 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s:<S2SV_blank>%s\\n"" , expansion_test_message , strerror ( errno ) ) ; return EXIT_FAILURE ; } ( void ) dup2 ( fd , 0 ) ; filter_test = FTEST_USER ; message_ended = END_NOTENDED ; read_message_body ( receive_msg ( extract_recipients ) ) ; message_linecount += body_linecount ; ( void ) dup2 ( save_stdin , 0 ) ; ( void ) close ( save_stdin ) ; clearerr ( stdin ) ; } enable_dollar_recipients = TRUE ; if ( recipients_arg < argc ) { while ( recipients_arg < argc ) { uschar * s = argv [ recipients_arg ++ ] ; uschar * ss = expand_string ( s ) ; if ( ss == NULL ) printf ( ""Failed:<S2SV_blank>%s\\n"" , expand_string_message ) ; else printf ( ""%s\\n"" , CS ss ) ; } } else { char * ( * fn_readline ) ( const char * ) = NULL ; void ( * fn_addhist ) ( const char * ) = NULL ; # ifdef USE_READLINE void * dlhandle = set_readline ( & fn_readline , & fn_addhist ) ; # endif for ( ; ; ) { uschar * ss ; uschar * source = get_stdinput ( fn_readline , fn_addhist ) ; if ( source == NULL ) break ; ss = expand_string ( source ) ; if ( ss == NULL ) printf ( ""Failed:<S2SV_blank>%s\\n"" , expand_string_message ) ; else printf ( ""%s\\n"" , CS ss ) ; } # ifdef USE_READLINE if ( dlhandle != NULL ) dlclose ( dlhandle ) ; # endif } if ( deliver_datafile >= 0 ) { ( void ) close ( deliver_datafile ) ; deliver_datafile = - 1 ; } exim_exit ( EXIT_SUCCESS ) ; } smtp_active_hostname = primary_hostname ; if ( raw_active_hostname != NULL ) { uschar * nah = expand_string ( raw_active_hostname ) ; if ( nah == NULL ) { if ( ! expand_string_forcedfail ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , ""failed<S2SV_blank>to<S2SV_blank>expand<S2SV_blank>\\""%s\\""<S2SV_blank>"" ""(smtp_active_hostname):<S2SV_blank>%s"" , raw_active_hostname , expand_string_message ) ; } else if ( nah [ 0 ] != 0 ) smtp_active_hostname = nah ; } if ( host_checking ) { int x [ 4 ] ; int size ; if ( ! sender_ident_set ) { sender_ident = NULL ; if ( running_in_test_harness && sender_host_port != 0 && interface_address != NULL && interface_port != 0 ) verify_get_ident ( 1413 ) ; } size = host_aton ( sender_host_address , x ) ; sender_host_address = store_get ( 48 ) ; ( void ) host_nmtoa ( size , x , - 1 , sender_host_address , ':' ) ; host_build_sender_fullhost ( ) ; smtp_input = TRUE ; smtp_in = stdin ; smtp_out = stdout ; sender_local = FALSE ; sender_host_notsocket = TRUE ; debug_file = stderr ; debug_fd = fileno ( debug_file ) ; fprintf ( stdout , ""\\n****<S2SV_blank>SMTP<S2SV_blank>testing<S2SV_blank>session<S2SV_blank>as<S2SV_blank>if<S2SV_blank>from<S2SV_blank>host<S2SV_blank>%s\\n"" ""****<S2SV_blank>but<S2SV_blank>without<S2SV_blank>any<S2SV_blank>ident<S2SV_blank>(RFC<S2SV_blank>1413)<S2SV_blank>callback.\\n"" ""****<S2SV_blank>This<S2SV_blank>is<S2SV_blank>not<S2SV_blank>for<S2SV_blank>real!\\n\\n"" , sender_host_address ) ; memset ( sender_host_cache , 0 , sizeof ( sender_host_cache ) ) ; if ( verify_check_host ( & hosts_connection_nolog ) == OK ) BIT_CLEAR ( log_selector , log_selector_size , Li_smtp_connection ) ; log_write ( L_smtp_connection , LOG_MAIN , ""%s"" , smtp_get_connection_info ( ) ) ; if ( smtp_start_session ( ) ) { for ( reset_point = store_get ( 0 ) ; ; store_reset ( reset_point ) ) { if ( smtp_setup_msg ( ) <= 0 ) break ; if ( ! receive_msg ( FALSE ) ) break ; return_path = sender_address = NULL ; dnslist_domain = dnslist_matched = NULL ; # ifndef DISABLE_DKIM dkim_cur_signer = NULL ; # endif acl_var_m = NULL ; deliver_localpart_orig = NULL ; deliver_domain_orig = NULL ; callout_address = sending_ip_address = NULL ; sender_rate = sender_rate_limit = sender_rate_period = NULL ; } smtp_log_no_mail ( ) ; } exim_exit ( EXIT_SUCCESS ) ; } if ( recipients_arg >= argc && ! extract_recipients && ! smtp_input ) { if ( version_printed ) { printf ( ""Configuration<S2SV_blank>file<S2SV_blank>is<S2SV_blank>%s\\n"" , config_main_filename ) ; return EXIT_SUCCESS ; } if ( info_flag != CMDINFO_NONE ) { show_exim_information ( info_flag , info_stdout ? stdout : stderr ) ; return info_stdout ? EXIT_SUCCESS : EXIT_FAILURE ; } if ( filter_test == FTEST_NONE ) exim_usage ( called_as ) ; } if ( mua_wrapper ) { synchronous_delivery = TRUE ; arg_error_handling = ERRORS_STDERR ; remote_max_parallel = 1 ; deliver_drop_privilege = TRUE ; queue_smtp = FALSE ; queue_smtp_domains = NULL ; # ifdef SUPPORT_I18N message_utf8_downconvert = - 1 ; # endif } if ( ! smtp_input ) error_handling = arg_error_handling ; else if ( is_inetd ) { ( void ) fclose ( stderr ) ; exim_nullstd ( ) ; verify_get_ident ( IDENT_PORT ) ; host_build_sender_fullhost ( ) ; set_process_info ( ""handling<S2SV_blank>incoming<S2SV_blank>connection<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>via<S2SV_blank>inetd"" , sender_fullhost ) ; } if ( sender_host_address != NULL && sender_fullhost == NULL ) { host_build_sender_fullhost ( ) ; set_process_info ( ""handling<S2SV_blank>incoming<S2SV_blank>connection<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>via<S2SV_blank>-oMa"" , sender_fullhost ) ; sender_host_notsocket = TRUE ; } else if ( ! is_inetd ) sender_host_unknown = TRUE ; if ( fstat ( 1 , & statbuf ) < 0 ) ( void ) dup2 ( 0 , 1 ) ; if ( smtp_input ) { if ( ! is_inetd ) set_process_info ( ""accepting<S2SV_blank>a<S2SV_blank>local<S2SV_blank>%sSMTP<S2SV_blank>message<S2SV_blank>from<S2SV_blank><%s>"" , smtp_batched_input ? ""batched<S2SV_blank>"" : """" , ( sender_address != NULL ) ? sender_address : originator_login ) ; } else { int old_pool = store_pool ; store_pool = POOL_PERM ; if ( ! received_protocol ) received_protocol = string_sprintf ( ""local%s"" , called_as ) ; store_pool = old_pool ; set_process_info ( ""accepting<S2SV_blank>a<S2SV_blank>local<S2SV_blank>non-SMTP<S2SV_blank>message<S2SV_blank>from<S2SV_blank><%s>"" , sender_address ) ; } queue_check_only ( ) ; session_local_queue_only = queue_only ; if ( ( ! smtp_input || smtp_batched_input ) && ! receive_check_fs ( 0 ) ) { fprintf ( stderr , ""exim:<S2SV_blank>insufficient<S2SV_blank>disk<S2SV_blank>space\\n"" ) ; return EXIT_FAILURE ; } if ( smtp_input ) { smtp_in = stdin ; smtp_out = stdout ; memset ( sender_host_cache , 0 , sizeof ( sender_host_cache ) ) ; if ( verify_check_host ( & hosts_connection_nolog ) == OK ) BIT_CLEAR ( log_selector , log_selector_size , Li_smtp_connection ) ; log_write ( L_smtp_connection , LOG_MAIN , ""%s"" , smtp_get_connection_info ( ) ) ; if ( ! smtp_start_session ( ) ) { mac_smtp_fflush ( ) ; exim_exit ( EXIT_SUCCESS ) ; } } else { thismessage_size_limit = expand_string_integer ( message_size_limit , TRUE ) ; if ( expand_string_message ) if ( thismessage_size_limit == - 1 ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , ""failed<S2SV_blank>to<S2SV_blank>expand<S2SV_blank>"" ""message_size_limit:<S2SV_blank>%s"" , expand_string_message ) ; else log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , ""invalid<S2SV_blank>value<S2SV_blank>for<S2SV_blank>"" ""message_size_limit:<S2SV_blank>%s"" , expand_string_message ) ; } if ( ! synchronous_delivery ) { # ifdef SA_NOCLDWAIT struct sigaction act ; act . sa_handler = SIG_IGN ; sigemptyset ( & ( act . sa_mask ) ) ; act . sa_flags = SA_NOCLDWAIT ; sigaction ( SIGCHLD , & act , NULL ) ; # else signal ( SIGCHLD , SIG_IGN ) ; # endif } reset_point = store_get ( 0 ) ; real_sender_address = sender_address ; while ( more ) { message_id [ 0 ] = 0 ; if ( smtp_input ) { int rc ; if ( ( rc = smtp_setup_msg ( ) ) > 0 ) { if ( real_sender_address != NULL && ! receive_check_set_sender ( sender_address ) ) { sender_address = raw_sender = real_sender_address ; sender_address_unrewritten = NULL ; } if ( smtp_batched_input && acl_not_smtp_start != NULL ) { uschar * user_msg , * log_msg ; enable_dollar_recipients = TRUE ; ( void ) acl_check ( ACL_WHERE_NOTSMTP_START , NULL , acl_not_smtp_start , & user_msg , & log_msg ) ; enable_dollar_recipients = FALSE ; } more = receive_msg ( extract_recipients ) ; if ( message_id [ 0 ] == 0 ) { cancel_cutthrough_connection ( TRUE , US ""receive<S2SV_blank>dropped"" ) ; if ( more ) goto moreloop ; smtp_log_no_mail ( ) ; exim_exit ( EXIT_FAILURE ) ; } } else { cancel_cutthrough_connection ( TRUE , US ""message<S2SV_blank>setup<S2SV_blank>dropped"" ) ; smtp_log_no_mail ( ) ; exim_exit ( ( rc == 0 ) ? EXIT_SUCCESS : EXIT_FAILURE ) ; } } else { int i ; int rcount = 0 ; int count = argc - recipients_arg ; uschar * * list = argv + recipients_arg ; active_local_sender_retain = local_sender_retain ; active_local_from_check = local_from_check ; raw_sender = string_copy ( sender_address ) ; for ( i = 0 ; i < count ; i ++ ) { int start , end , domain ; uschar * errmess ; uschar * s = list [ i ] ; while ( * s != 0 ) { BOOL finished = FALSE ; uschar * recipient ; uschar * ss = parse_find_address_end ( s , FALSE ) ; if ( * ss == ',' ) * ss = 0 ; else finished = TRUE ; if ( recipients_max > 0 && ++ rcount > recipients_max && ! extract_recipients ) if ( error_handling == ERRORS_STDERR ) { fprintf ( stderr , ""exim:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>recipients\\n"" ) ; exim_exit ( EXIT_FAILURE ) ; } else { return moan_to_sender ( ERRMESS_TOOMANYRECIP , NULL , NULL , stdin , TRUE ) ? errors_sender_rc : EXIT_FAILURE ; } # ifdef SUPPORT_I18N { BOOL b = allow_utf8_domains ; allow_utf8_domains = TRUE ; # endif recipient = parse_extract_address ( s , & errmess , & start , & end , & domain , FALSE ) ; # ifdef SUPPORT_I18N if ( string_is_utf8 ( recipient ) ) message_smtputf8 = TRUE ; else allow_utf8_domains = b ; } # endif if ( domain == 0 && ! allow_unqualified_recipient ) { recipient = NULL ; errmess = US ""unqualified<S2SV_blank>recipient<S2SV_blank>address<S2SV_blank>not<S2SV_blank>allowed"" ; } if ( recipient == NULL ) { if ( error_handling == ERRORS_STDERR ) { fprintf ( stderr , ""exim:<S2SV_blank>bad<S2SV_blank>recipient<S2SV_blank>address<S2SV_blank>\\""%s\\"":<S2SV_blank>%s\\n"" , string_printing ( list [ i ] ) , errmess ) ; exim_exit ( EXIT_FAILURE ) ; } else { error_block eblock ; eblock . next = NULL ; eblock . text1 = string_printing ( list [ i ] ) ; eblock . text2 = errmess ; return moan_to_sender ( ERRMESS_BADARGADDRESS , & eblock , NULL , stdin , TRUE ) ? errors_sender_rc : EXIT_FAILURE ; } } receive_add_recipient ( recipient , - 1 ) ; s = ss ; if ( ! finished ) while ( * ( ++ s ) != 0 && ( * s == ',' || isspace ( * s ) ) ) ; } } DEBUG ( D_receive ) { int i ; if ( sender_address != NULL ) debug_printf ( ""Sender:<S2SV_blank>%s\\n"" , sender_address ) ; if ( recipients_list != NULL ) { debug_printf ( ""Recipients:\\n"" ) ; for ( i = 0 ; i < recipients_count ; i ++ ) debug_printf ( ""<S2SV_blank><S2SV_blank>%s\\n"" , recipients_list [ i ] . address ) ; } } if ( acl_not_smtp_start ) { uschar * user_msg , * log_msg ; enable_dollar_recipients = TRUE ; ( void ) acl_check ( ACL_WHERE_NOTSMTP_START , NULL , acl_not_smtp_start , & user_msg , & log_msg ) ; enable_dollar_recipients = FALSE ; } if ( ! receive_timeout ) { struct timeval t = { 30 * 60 , 0 } ; fd_set r ; FD_ZERO ( & r ) ; FD_SET ( 0 , & r ) ; if ( select ( 1 , & r , NULL , NULL , & t ) == 0 ) mainlog_close ( ) ; } message_ended = END_NOTENDED ; more = receive_msg ( extract_recipients ) ; if ( message_id [ 0 ] == 0 ) exim_exit ( EXIT_FAILURE ) ; } if ( filter_test != FTEST_NONE ) { deliver_domain = ( ftest_domain != NULL ) ? ftest_domain : qualify_domain_recipient ; deliver_domain_orig = deliver_domain ; deliver_localpart = ( ftest_localpart != NULL ) ? ftest_localpart : originator_login ; deliver_localpart_orig = deliver_localpart ; deliver_localpart_prefix = ftest_prefix ; deliver_localpart_suffix = ftest_suffix ; deliver_home = originator_home ; if ( return_path == NULL ) { printf ( ""Return-path<S2SV_blank>copied<S2SV_blank>from<S2SV_blank>sender\\n"" ) ; return_path = string_copy ( sender_address ) ; } else printf ( ""Return-path<S2SV_blank>=<S2SV_blank>%s\\n"" , ( return_path [ 0 ] == 0 ) ? US ""<>"" : return_path ) ; printf ( ""Sender<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%s\\n"" , ( sender_address [ 0 ] == 0 ) ? US ""<>"" : sender_address ) ; receive_add_recipient ( string_sprintf ( ""%s%s%s@%s"" , ( ftest_prefix == NULL ) ? US """" : ftest_prefix , deliver_localpart , ( ftest_suffix == NULL ) ? US """" : ftest_suffix , deliver_domain ) , - 1 ) ; printf ( ""Recipient<S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%s\\n"" , recipients_list [ 0 ] . address ) ; if ( ftest_prefix != NULL ) printf ( ""Prefix<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%s\\n"" , ftest_prefix ) ; if ( ftest_suffix != NULL ) printf ( ""Suffix<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%s\\n"" , ftest_suffix ) ; if ( chdir ( ""/"" ) ) { DEBUG ( D_receive ) debug_printf ( ""chdir(\\""/\\"")<S2SV_blank>failed\\n"" ) ; exim_exit ( EXIT_FAILURE ) ; } if ( ( filter_test & FTEST_SYSTEM ) != 0 ) { if ( ! filter_runtest ( filter_sfd , filter_test_sfile , TRUE , more ) ) exim_exit ( EXIT_FAILURE ) ; } memcpy ( filter_sn , filter_n , sizeof ( filter_sn ) ) ; if ( ( filter_test & FTEST_USER ) != 0 ) { if ( ! filter_runtest ( filter_ufd , filter_test_ufile , FALSE , more ) ) exim_exit ( EXIT_FAILURE ) ; } exim_exit ( EXIT_SUCCESS ) ; } if ( ! session_local_queue_only && smtp_accept_queue_per_connection > 0 && receive_messagecount > smtp_accept_queue_per_connection ) { session_local_queue_only = TRUE ; queue_only_reason = 2 ; } local_queue_only = session_local_queue_only ; if ( ! local_queue_only && queue_only_load >= 0 ) { local_queue_only = ( load_average = OS_GETLOADAVG ( ) ) > queue_only_load ; if ( local_queue_only ) { queue_only_reason = 3 ; if ( queue_only_load_latch ) session_local_queue_only = TRUE ; } } if ( mua_wrapper ) local_queue_only = queue_only_policy = deliver_freeze = FALSE ; if ( local_queue_only ) { cancel_cutthrough_connection ( TRUE , US ""no<S2SV_blank>delivery;<S2SV_blank>queueing"" ) ; switch ( queue_only_reason ) { case 2 : log_write ( L_delay_delivery , LOG_MAIN , ""no<S2SV_blank>immediate<S2SV_blank>delivery:<S2SV_blank>more<S2SV_blank>than<S2SV_blank>%d<S2SV_blank>messages<S2SV_blank>"" ""received<S2SV_blank>in<S2SV_blank>one<S2SV_blank>connection"" , smtp_accept_queue_per_connection ) ; break ; case 3 : log_write ( L_delay_delivery , LOG_MAIN , ""no<S2SV_blank>immediate<S2SV_blank>delivery:<S2SV_blank>load<S2SV_blank>average<S2SV_blank>%.2f"" , ( double ) load_average / 1000.0 ) ; break ; } } else if ( queue_only_policy || deliver_freeze ) cancel_cutthrough_connection ( TRUE , US ""no<S2SV_blank>delivery;<S2SV_blank>queueing"" ) ; else { pid_t pid ; search_tidyup ( ) ; if ( ( pid = fork ( ) ) == 0 ) { int rc ; close_unwanted ( ) ; exim_nullstd ( ) ; if ( geteuid ( ) != root_uid && ! deliver_drop_privilege && ! unprivileged ) { delivery_re_exec ( CEE_EXEC_EXIT ) ; } rc = deliver_message ( message_id , FALSE , FALSE ) ; search_tidyup ( ) ; _exit ( ( ! mua_wrapper || rc == DELIVER_MUA_SUCCEEDED ) ? EXIT_SUCCESS : EXIT_FAILURE ) ; } if ( pid < 0 ) { cancel_cutthrough_connection ( TRUE , US ""delivery<S2SV_blank>fork<S2SV_blank>failed"" ) ; log_write ( 0 , LOG_MAIN | LOG_PANIC , ""failed<S2SV_blank>to<S2SV_blank>fork<S2SV_blank>automatic<S2SV_blank>delivery<S2SV_blank>"" ""process:<S2SV_blank>%s"" , strerror ( errno ) ) ; } else { release_cutthrough_connection ( US ""msg<S2SV_blank>passed<S2SV_blank>for<S2SV_blank>delivery"" ) ; if ( synchronous_delivery ) { int status ; while ( wait ( & status ) != pid ) ; if ( ( status & 0x00ff ) != 0 ) log_write ( 0 , LOG_MAIN | LOG_PANIC , ""process<S2SV_blank>%d<S2SV_blank>crashed<S2SV_blank>with<S2SV_blank>signal<S2SV_blank>%d<S2SV_blank>while<S2SV_blank>delivering<S2SV_blank>%s"" , ( int ) pid , status & 0x00ff , message_id ) ; if ( mua_wrapper && ( status & 0xffff ) != 0 ) exim_exit ( EXIT_FAILURE ) ; } } } # ifndef SIG_IGN_WORKS while ( waitpid ( - 1 , NULL , WNOHANG ) > 0 ) ; # endif moreloop : return_path = sender_address = NULL ; authenticated_sender = NULL ; deliver_localpart_orig = NULL ; deliver_domain_orig = NULL ; deliver_host = deliver_host_address = NULL ; dnslist_domain = dnslist_matched = NULL ; # ifdef WITH_CONTENT_SCAN malware_name = NULL ; # endif callout_address = NULL ; sending_ip_address = NULL ; acl_var_m = NULL ; { int i ; for ( i = 0 ; i < REGEX_VARS ; i ++ ) regex_vars [ i ] = NULL ; } store_reset ( reset_point ) ; } exim_exit ( EXIT_SUCCESS ) ; return 0 ; }","uschar * hn = Ustrchr ( argrest , \':\' ) ;if ( hn == NULL ) {",349
475,"buggy line: if ( info -> si_code >= 0 )   return - EPERM ;info -> si_signo = sig ;cwe id:CWE-000context: long do_rt_tgsigqueueinfo ( pid_t tgid , pid_t pid , int sig , siginfo_t * info ) { if ( pid <= 0 || tgid <= 0 ) return - EINVAL ;  if ( info -> si_code >= 0 )   return - EPERM ;  info -> si_signo = sig ; return do_send_specific ( tgid , pid , sig , info ) ; }",if ( info -> si_code != SI_QUEUE ) {WARN_ON_ONCE ( info -> si_code < 0 ) ;return - EPERM ;}info -> si_signo = sig ;,350
476,"buggy line: s -> off = strtoll ( p , NULL , 10 ) ;if ( ( slash = strchr ( p , \'/\' ) ) && strlen ( slash ) > 0 )  s -> filesize = strtoll ( slash + 1 , NULL , 10 ) ;}cwe id:CWE-119context: static void parse_content_range ( URLContext * h , const char * p ) { HTTPContext * s = h -> priv_data ; const char * slash ; if ( ! strncmp ( p , ""bytes<S2SV_blank>"" , 6 ) ) { p += 6 ;  s -> off = strtoll ( p , NULL , 10 ) ;  if ( ( slash = strchr ( p , '/' ) ) && strlen ( slash ) > 0 )  s -> filesize = strtoll ( slash + 1 , NULL , 10 ) ;  } if ( s -> seekable == - 1 && ( ! s -> is_akamai || s -> filesize != 2147483647 ) ) h -> is_streamed = 0 ; }","s -> off = strtoull ( p , NULL , 10 ) ;if ( ( slash = strchr ( p , \'/\' ) ) && strlen ( slash ) > 0 ) s -> filesize = strtoull ( slash + 1 , NULL , 10 ) ;}",351
477,"buggy line: unsigned int maxw , maxh , max ;int offset , upb ;unsigned int i , j ;upb = ( int ) img -> comps [ 0 ] . prec ;maxw = ( unsigned int ) img -> comps [ 0 ] . w ;maxh = ( unsigned int ) img -> comps [ 0 ] . h ;max = maxw * maxh ;d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ;d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ;d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ;if ( r == NULL || g == NULL || b == NULL ) goto fails ;for ( i = 0U ;++ i )  {for ( j = 0U ;j < ( maxw & ~ ( unsigned int ) 1U ) ;j += 2U )  {cwe id:CWE-125context: static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ;  unsigned int maxw , maxh , max ;  int offset , upb ;  unsigned int i , j ;  upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ;  maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ;  max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ;  d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ;   d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ;   d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ;  if ( r == NULL || g == NULL || b == NULL ) goto fails ;  for ( i = 0U ; i < maxh ; ++ i )  {  for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U )  { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; }  if ( j < maxw ) {  sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ;  # if defined ( USE_JPWL ) || defined ( USE_MJ2 )   img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ;   img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ;  # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ;  img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ;  # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ;  img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ;  return ; fails :  if ( r ) free ( r ) ;   if ( g ) free ( g ) ;   if ( b ) free ( b ) ;  }","size_t maxw , maxh , max , offx , loopmaxw ;int offset , upb ;size_t i ;upb = ( int ) img -> comps [ 0 ] . prec ;maxw = ( size_t ) img -> comps [ 0 ] . w ;maxh = ( size_t ) img -> comps [ 0 ] . h ;max = maxw * maxh ;d0 = r = ( int * ) malloc ( sizeof ( int ) * max ) ;d1 = g = ( int * ) malloc ( sizeof ( int ) * max ) ;d2 = b = ( int * ) malloc ( sizeof ( int ) * max ) ;if ( r == NULL || g == NULL || b == NULL ) goto fails ;offx = img -> x0 & 1U ;loopmaxw = maxw - offx ;for ( i = 0U ;+ i )  {++ i ) {size_t j ;if ( offx > 0U ) {sycc_to_rgb ( offset , upb , * y , 0 , 0 , r , g , b ) ;++ y ;++ r ;++ g ;++ b ;}for ( j = 0U ;j < ( loopmaxw & ~ ( unsigned int ) 1U ) ;j += 2U ) {",352
478,"buggy line: if ( j < maxw ) {sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ;cwe id:CWE-125context: static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ;  unsigned int maxw , maxh , max ;  int offset , upb ;  unsigned int i , j ;  upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ;  maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ;  max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ;  d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ;   d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ;   d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ;  if ( r == NULL || g == NULL || b == NULL ) goto fails ;  for ( i = 0U ; i < maxh ; ++ i )  {  for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U )  { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; }  if ( j < maxw ) {  sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ;  # if defined ( USE_JPWL ) || defined ( USE_MJ2 )   img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ;   img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ;  # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ;  img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ;  # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ;  img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ;  return ; fails :  if ( r ) free ( r ) ;   if ( g ) free ( g ) ;   if ( b ) free ( b ) ;  }","if ( j < loopmaxw ) {sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ;",352
479,"buggy line: # if defined ( USE_JPWL ) || defined ( USE_MJ2 )   img -> comps [ 1 ] . w = maxw ;img -> comps [ 2 ] . w = maxw ;img -> comps [ 2 ] . h = maxh ;# else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ;img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ;img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ;# endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ;img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ;img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ;img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ;return ;fails :  if ( r ) free ( r ) ;if ( g ) free ( g ) ;if ( b ) free ( b ) ;}cwe id:CWE-125context: static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ;  unsigned int maxw , maxh , max ;  int offset , upb ;  unsigned int i , j ;  upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ;  maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ;  max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ;  d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ;   d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ;   d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ;  if ( r == NULL || g == NULL || b == NULL ) goto fails ;  for ( i = 0U ; i < maxh ; ++ i )  {  for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U )  { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; }  if ( j < maxw ) {  sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ;  # if defined ( USE_JPWL ) || defined ( USE_MJ2 )   img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ;   img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ;  # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ;  img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ;  # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ;  img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ;  return ; fails :  if ( r ) free ( r ) ;   if ( g ) free ( g ) ;   if ( b ) free ( b ) ;  }",img -> comps [ 1 ] . w = maxw ;img -> comps [ 2 ] . w = img -> comps [ 2 ] . w = img -> comps [ 0 ] . w ;img -> comps [ 2 ] . h = img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ;img -> comps [ 2 ] . h = img -> comps [ 0 ] . h ;img -> comps [ 1 ] . dx = img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ;img -> comps [ 1 ] . dy = img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ;img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ;img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ;return ;fails : free ( r ) ;if ( g ) free ( g ) ;free ( b ) ;},352
480,"buggy line: void  nfs4_state_set_mode_locked ( struct nfs4_state * state , mode_t mode )  {if ( state -> state == mode )  return ;if ( ( mode & FMODE_WRITE ) != ( state -> state & FMODE_WRITE ) ) {if ( mode & FMODE_WRITE )  list_move ( & state -> open_states , & state -> owner -> so_states ) ;state -> state = mode ;}cwe id:CWE-000context: void  nfs4_state_set_mode_locked ( struct nfs4_state * state , mode_t mode )  {  if ( state -> state == mode )  return ;  if ( ( mode & FMODE_WRITE ) != ( state -> state & FMODE_WRITE ) ) {   if ( mode & FMODE_WRITE )  list_move ( & state -> open_states , & state -> owner -> so_states ) ; else list_move_tail ( & state -> open_states , & state -> owner -> so_states ) ; }  state -> state = mode ;  }","void nfs4_state_set_mode_locked ( struct nfs4_state * state , fmode_t fmode ) {if ( state -> state == fmode ) return ;if ( ( fmode & FMODE_WRITE ) != ( state -> state & FMODE_WRITE ) ) {if ( fmode & FMODE_WRITE ) list_move ( & state -> open_states , & state -> owner -> so_states ) ;state -> state = fmode ;}",353
481,"buggy line: ptr = sshpkt_ptr ( ssh , & dlen ) ;if ( ( r = sshbuf_put ( kex -> peer , ptr , dlen ) ) != 0 ) return r ;cwe id:CWE-399context: int kex_input_kexinit ( int type , u_int32_t seq , void * ctxt ) { struct ssh * ssh = ctxt ; struct kex * kex = ssh -> kex ; const u_char * ptr ; u_int i ; size_t dlen ; int r ; debug ( ""SSH2_MSG_KEXINIT<S2SV_blank>received"" ) ; if ( kex == NULL ) return SSH_ERR_INVALID_ARGUMENT ;  ptr = sshpkt_ptr ( ssh , & dlen ) ;  if ( ( r = sshbuf_put ( kex -> peer , ptr , dlen ) ) != 0 ) return r ; for ( i = 0 ; i < KEX_COOKIE_LEN ; i ++ ) if ( ( r = sshpkt_get_u8 ( ssh , NULL ) ) != 0 ) return r ; for ( i = 0 ; i < PROPOSAL_MAX ; i ++ ) if ( ( r = sshpkt_get_string ( ssh , NULL , NULL ) ) != 0 ) return r ; if ( ( r = sshpkt_get_u8 ( ssh , NULL ) ) != 0 || ( r = sshpkt_get_u32 ( ssh , NULL ) ) != 0 || ( r = sshpkt_get_end ( ssh ) ) != 0 ) return r ; if ( ! ( kex -> flags & KEX_INIT_SENT ) ) if ( ( r = kex_send_kexinit ( ssh ) ) != 0 ) return r ; if ( ( r = kex_choose_conf ( ssh ) ) != 0 ) return r ; if ( kex -> kex_type < KEX_MAX && kex -> kex [ kex -> kex_type ] != NULL ) return ( kex -> kex [ kex -> kex_type ] ) ( ssh ) ; return SSH_ERR_INTERNAL_ERROR ; }","ssh_dispatch_set ( ssh , SSH2_MSG_KEXINIT , NULL ) ;ptr = sshpkt_ptr ( ssh , & dlen ) ;if ( ( r = sshbuf_put ( kex -> peer , ptr , dlen ) ) != 0 ) return r ;",354
482,"buggy line: assert_true_rule (  ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" ,  NULL ) ;cwe id:CWE-119context: static void test_modules ( ) { assert_true_rule (  ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.one<S2SV_blank>+<S2SV_blank>1<S2SV_blank>==<S2SV_blank>tests.constants.two<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" ,  NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.foo<S2SV_blank>==<S2SV_blank>\\""foo\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.empty<S2SV_blank>==<S2SV_blank>\\""\\""<S2SV_blank><S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.empty()<S2SV_blank>==<S2SV_blank>\\""\\""<S2SV_blank><S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.struct_array[1].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>or<S2SV_blank>true<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[0]<S2SV_blank>==<S2SV_blank>0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[1]<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_array[0]<S2SV_blank>==<S2SV_blank>\\""foo\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_array[2]<S2SV_blank>==<S2SV_blank>\\""baz\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_dict[\\""foo\\""]<S2SV_blank>==<S2SV_blank>\\""foo\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_dict[\\""bar\\""]<S2SV_blank>==<S2SV_blank>\\""bar\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.isum(1,2)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.isum(1,2,3)<S2SV_blank>==<S2SV_blank>6<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,2.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,2.0,3.0)<S2SV_blank>==<S2SV_blank>6.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.foobar(1)<S2SV_blank>==<S2SV_blank>tests.foobar(1)<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.foobar(1)<S2SV_blank>!=<S2SV_blank>tests.foobar(2)<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.length(\\""dummy\\"")<S2SV_blank>==<S2SV_blank>5<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_false_rule (  ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" ,  NULL ) ; assert_false_rule (  ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.isum(1,1)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" ,  NULL ) ; assert_false_rule (  ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,1.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" ,  NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\""foo\\"")<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\""bar\\"")<S2SV_blank>==<S2SV_blank>-1\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/i,\\""FOO\\\\nBAR\\"")<S2SV_blank>==<S2SV_blank>-1\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/is,\\""FOO\\\\nBAR\\"")<S2SV_blank>==<S2SV_blank>7\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_error ( ""import<S2SV_blank>\\""\\\\x00\\"""" , ERROR_INVALID_MODULE_NAME ) ; assert_error ( ""import<S2SV_blank>\\""\\"""" , ERROR_INVALID_MODULE_NAME ) ; }","assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;",355
483,"buggy line: assert_false_rule (  ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\\\"" ,  NULL ) ;assert_false_rule (  ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>condition:<S2SV_blank>tests.isum(1,1)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\\\"" ,  NULL ) ;assert_false_rule (  ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,1.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\\\"" ,  NULL ) ;cwe id:CWE-119context: static void test_modules ( ) { assert_true_rule (  ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.one<S2SV_blank>+<S2SV_blank>1<S2SV_blank>==<S2SV_blank>tests.constants.two<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" ,  NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.foo<S2SV_blank>==<S2SV_blank>\\""foo\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.empty<S2SV_blank>==<S2SV_blank>\\""\\""<S2SV_blank><S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.empty()<S2SV_blank>==<S2SV_blank>\\""\\""<S2SV_blank><S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.struct_array[1].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>or<S2SV_blank>true<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[0]<S2SV_blank>==<S2SV_blank>0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[1]<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_array[0]<S2SV_blank>==<S2SV_blank>\\""foo\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_array[2]<S2SV_blank>==<S2SV_blank>\\""baz\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_dict[\\""foo\\""]<S2SV_blank>==<S2SV_blank>\\""foo\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_dict[\\""bar\\""]<S2SV_blank>==<S2SV_blank>\\""bar\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.isum(1,2)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.isum(1,2,3)<S2SV_blank>==<S2SV_blank>6<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,2.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,2.0,3.0)<S2SV_blank>==<S2SV_blank>6.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.foobar(1)<S2SV_blank>==<S2SV_blank>tests.foobar(1)<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.foobar(1)<S2SV_blank>!=<S2SV_blank>tests.foobar(2)<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.length(\\""dummy\\"")<S2SV_blank>==<S2SV_blank>5<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_false_rule (  ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" ,  NULL ) ; assert_false_rule (  ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.isum(1,1)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" ,  NULL ) ; assert_false_rule (  ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,1.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" ,  NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\""foo\\"")<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\""bar\\"")<S2SV_blank>==<S2SV_blank>-1\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/i,\\""FOO\\\\nBAR\\"")<S2SV_blank>==<S2SV_blank>-1\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/is,\\""FOO\\\\nBAR\\"")<S2SV_blank>==<S2SV_blank>7\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_error ( ""import<S2SV_blank>\\""\\\\x00\\"""" , ERROR_INVALID_MODULE_NAME ) ; assert_error ( ""import<S2SV_blank>\\""\\"""" , ERROR_INVALID_MODULE_NAME ) ; }","assert_false_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\\\"" , NULL ) ;assert_false_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>condition:<S2SV_blank>tests.isum(1,1)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\\\"" , NULL ) ;assert_false_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,1.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\\\""foo\\\\"")<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\\\""bar\\\\"")<S2SV_blank>==<S2SV_blank>-1\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/i,\\\\""FOO\\\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/is,\\\\""FOO\\\\\\\"" , NULL ) ;",355
484,"buggy line: ( void ) CloseBlob ( pwp_image ) ;pwp_image = DestroyImage ( pwp_image ) ;cwe id:CWE-416context: static Image * ReadPWPImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { FILE * file ; Image * image , * next_image , * pwp_image ; ImageInfo * read_info ; int c , unique_file ; MagickBooleanType status ; register Image * p ; register ssize_t i ; size_t filesize , length ; ssize_t count ; unsigned char magick [ MaxTextExtent ] ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; pwp_image = AcquireImage ( image_info ) ; image = pwp_image ; status = OpenBlob ( image_info , pwp_image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( ( Image * ) NULL ) ; count = ReadBlob ( pwp_image , 5 , magick ) ; if ( ( count != 5 ) || ( LocaleNCompare ( ( char * ) magick , ""SFW95"" , 5 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; read_info = CloneImageInfo ( image_info ) ; ( void ) SetImageInfoProgressMonitor ( read_info , ( MagickProgressMonitor ) NULL , ( void * ) NULL ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; unique_file = AcquireUniqueFileResource ( read_info -> filename ) ; for ( ; ; ) { for ( c = ReadBlobByte ( pwp_image ) ; c != EOF ; c = ReadBlobByte ( pwp_image ) ) { for ( i = 0 ; i < 17 ; i ++ ) magick [ i ] = magick [ i + 1 ] ; magick [ 17 ] = ( unsigned char ) c ; if ( LocaleNCompare ( ( char * ) ( magick + 12 ) , ""SFW94A"" , 6 ) == 0 ) break ; } if ( c == EOF ) break ; if ( LocaleNCompare ( ( char * ) ( magick + 12 ) , ""SFW94A"" , 6 ) != 0 ) { ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } file = ( FILE * ) NULL ; if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ; if ( ( unique_file == - 1 ) || ( file == ( FILE * ) NULL ) ) { ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; ThrowFileException ( exception , FileOpenError , ""UnableToWriteFile"" , image -> filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } length = fwrite ( ""SFW94A"" , 1 , 6 , file ) ; ( void ) length ; filesize = 65535UL * magick [ 2 ] + 256L * magick [ 1 ] + magick [ 0 ] ; for ( i = 0 ; i < ( ssize_t ) filesize ; i ++ ) { c = ReadBlobByte ( pwp_image ) ; ( void ) fputc ( c , file ) ; } ( void ) fclose ( file ) ; next_image = ReadImage ( read_info , exception ) ; if ( next_image == ( Image * ) NULL ) break ; ( void ) FormatLocaleString ( next_image -> filename , MaxTextExtent , ""slide_%02ld.sfw"" , ( long ) next_image -> scene ) ; if ( image == ( Image * ) NULL ) image = next_image ; else { for ( p = image ; p -> next != ( Image * ) NULL ; p = GetNextImageInList ( p ) ) ; next_image -> previous = p ; next_image -> scene = p -> scene + 1 ; p -> next = next_image ; } if ( image_info -> number_scenes != 0 ) if ( next_image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( pwp_image ) , GetBlobSize ( pwp_image ) ) ; if ( status == MagickFalse ) break ; } if ( unique_file != - 1 ) ( void ) close ( unique_file ) ; ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; read_info = DestroyImageInfo ( read_info ) ;  ( void ) CloseBlob ( pwp_image ) ;  pwp_image = DestroyImage ( pwp_image ) ; if ( EOFBlob ( image ) != MagickFalse ) { char * message ; message = GetExceptionMessage ( errno ) ; ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageError , ""UnexpectedEndOfFile"" , ""`%s\':<S2SV_blank>%s"" , image -> filename , message ) ; message = DestroyString ( message ) ; } ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","
",356
485,"buggy line: char lbase [ 256 ] ;char strbase [ 256 ] ;char ltest [ 256 ] ;char strtest [ 256 ] ;if ( parse_cmdline_cmp ( argc , argv , & inParam ) == 1 ) {cwe id:CWE-119context: int main ( int argc , char * * argv ) { test_cmp_parameters inParam ; FILE * fbase = NULL , * ftest = NULL ; int same = 0 ;  char lbase [ 256 ] ;   char strbase [ 256 ] ;   char ltest [ 256 ] ;   char strtest [ 256 ] ;  if ( parse_cmdline_cmp ( argc , argv , & inParam ) == 1 ) { compare_dump_files_help_display ( ) ; goto cleanup ; } printf ( ""******Parameters*********<S2SV_blank>\\n"" ) ; printf ( ""<S2SV_blank>base_filename<S2SV_blank>=<S2SV_blank>%s\\n"" ""<S2SV_blank>test_filename<S2SV_blank>=<S2SV_blank>%s\\n"" , inParam . base_filename , inParam . test_filename ) ; printf ( ""*************************<S2SV_blank>\\n"" ) ; printf ( ""Try<S2SV_blank>to<S2SV_blank>open:<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading<S2SV_blank>...<S2SV_blank>"" , inParam . base_filename ) ; if ( ( fbase = fopen ( inParam . base_filename , ""rb"" ) ) == NULL ) { goto cleanup ; } printf ( ""Ok.\\n"" ) ; printf ( ""Try<S2SV_blank>to<S2SV_blank>open:<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading<S2SV_blank>...<S2SV_blank>"" , inParam . test_filename ) ; if ( ( ftest = fopen ( inParam . test_filename , ""rb"" ) ) == NULL ) { goto cleanup ; } printf ( ""Ok.\\n"" ) ; while ( fgets ( lbase , sizeof ( lbase ) , fbase ) && fgets ( ltest , sizeof ( ltest ) , ftest ) ) {  int nbase = sscanf ( lbase , ""%255[^\\r\\n]"" , strbase ) ;   int ntest = sscanf ( ltest , ""%255[^\\r\\n]"" , strtest ) ;   assert ( nbase != 255 && ntest != 255 ) ;  if ( nbase != 1 || ntest != 1 ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>line<S2SV_blank>from<S2SV_blank>files\\n"" ) ; goto cleanup ; } if ( strcmp ( strbase , strtest ) != 0 ) { fprintf ( stderr , ""<%s><S2SV_blank>vs.<S2SV_blank><%s>\\n"" , strbase , strtest ) ; goto cleanup ; } } same = 1 ; printf ( ""\\n*****<S2SV_blank>TEST<S2SV_blank>SUCCEED:<S2SV_blank>Files<S2SV_blank>are<S2SV_blank>the<S2SV_blank>same.<S2SV_blank>*****\\n"" ) ; cleanup : if ( fbase ) fclose ( fbase ) ; if ( ftest ) fclose ( ftest ) ; free ( inParam . base_filename ) ; free ( inParam . test_filename ) ; return same ? EXIT_SUCCESS : EXIT_FAILURE ; }","char lbase [ 512 ] ;char strbase [ 256 ] ;char ltest [ 512 ] ;char strtest [ 256 ] ;if ( parse_cmdline_cmp ( argc , argv , & inParam ) == 1 ) {",357
486,"buggy line: while ( fgets ( lbase , sizeof ( lbase ) , fbase ) && fgets ( ltest , sizeof ( ltest ) , ftest ) ) {int nbase = sscanf ( lbase , ""%255[^\\\\r\\\int ntest = sscanf ( ltest , ""%255[^\\\\r\\\assert ( nbase != 255 && ntest != 255 ) ;if ( nbase != 1 || ntest != 1 ) {cwe id:CWE-119context: int main ( int argc , char * * argv ) { test_cmp_parameters inParam ; FILE * fbase = NULL , * ftest = NULL ; int same = 0 ;  char lbase [ 256 ] ;   char strbase [ 256 ] ;   char ltest [ 256 ] ;   char strtest [ 256 ] ;  if ( parse_cmdline_cmp ( argc , argv , & inParam ) == 1 ) { compare_dump_files_help_display ( ) ; goto cleanup ; } printf ( ""******Parameters*********<S2SV_blank>\\n"" ) ; printf ( ""<S2SV_blank>base_filename<S2SV_blank>=<S2SV_blank>%s\\n"" ""<S2SV_blank>test_filename<S2SV_blank>=<S2SV_blank>%s\\n"" , inParam . base_filename , inParam . test_filename ) ; printf ( ""*************************<S2SV_blank>\\n"" ) ; printf ( ""Try<S2SV_blank>to<S2SV_blank>open:<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading<S2SV_blank>...<S2SV_blank>"" , inParam . base_filename ) ; if ( ( fbase = fopen ( inParam . base_filename , ""rb"" ) ) == NULL ) { goto cleanup ; } printf ( ""Ok.\\n"" ) ; printf ( ""Try<S2SV_blank>to<S2SV_blank>open:<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading<S2SV_blank>...<S2SV_blank>"" , inParam . test_filename ) ; if ( ( ftest = fopen ( inParam . test_filename , ""rb"" ) ) == NULL ) { goto cleanup ; } printf ( ""Ok.\\n"" ) ; while ( fgets ( lbase , sizeof ( lbase ) , fbase ) && fgets ( ltest , sizeof ( ltest ) , ftest ) ) {  int nbase = sscanf ( lbase , ""%255[^\\r\\n]"" , strbase ) ;   int ntest = sscanf ( ltest , ""%255[^\\r\\n]"" , strtest ) ;   assert ( nbase != 255 && ntest != 255 ) ;  if ( nbase != 1 || ntest != 1 ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>line<S2SV_blank>from<S2SV_blank>files\\n"" ) ; goto cleanup ; } if ( strcmp ( strbase , strtest ) != 0 ) { fprintf ( stderr , ""<%s><S2SV_blank>vs.<S2SV_blank><%s>\\n"" , strbase , strtest ) ; goto cleanup ; } } same = 1 ; printf ( ""\\n*****<S2SV_blank>TEST<S2SV_blank>SUCCEED:<S2SV_blank>Files<S2SV_blank>are<S2SV_blank>the<S2SV_blank>same.<S2SV_blank>*****\\n"" ) ; cleanup : if ( fbase ) fclose ( fbase ) ; if ( ftest ) fclose ( ftest ) ; free ( inParam . base_filename ) ; free ( inParam . test_filename ) ; return same ? EXIT_SUCCESS : EXIT_FAILURE ; }","while ( fgets ( lbase , ""%511[^\\\\r\\\int ntest = sscanf ( ltest , ""%255[^\\\\r\\\assert ( nbase != 255 && ntest != 255 ) ;if ( nbase != 1 || ntest != 1 ) {",357
487,"buggy line: int ret ;if ( cdc_ncm_select_altsetting ( intf ) != CDC_NCM_COMM_ALTSETTING_NCM ) return - ENODEV ;ret = cdc_ncm_bind_common ( dev , intf , CDC_NCM_DATA_ALTSETTING_NCM , 0 ) ;usbnet_link_change ( dev , 0 , 0 ) ;return ret ;cwe id:CWE-000context: static int cdc_ncm_bind ( struct usbnet * dev , struct usb_interface * intf ) {  int ret ;  if ( cdc_ncm_select_altsetting ( intf ) != CDC_NCM_COMM_ALTSETTING_NCM ) return - ENODEV ;  ret = cdc_ncm_bind_common ( dev , intf , CDC_NCM_DATA_ALTSETTING_NCM , 0 ) ;   usbnet_link_change ( dev , 0 , 0 ) ;  return ret ; }","if ( cdc_ncm_select_altsetting ( intf ) != CDC_NCM_COMM_ALTSETTING_NCM ) return - ENODEV ;return cdc_ncm_bind_common ( dev , intf , CDC_NCM_DATA_ALTSETTING_NCM , 0 ) ;",358
488,"buggy line: if ( ! virtqueue_pop ( vq , & elem ) ) {return 0 ;}memcpy ( elem . in_sg [ 0 ] . iov_base , buf , len ) ;virtqueue_push ( vq , & elem , len ) ;cwe id:CWE-120context: static size_t send_control_msg ( VirtIOSerial * vser , void * buf , size_t len ) { VirtQueueElement elem ; VirtQueue * vq ; vq = vser -> c_ivq ; if ( ! virtio_queue_ready ( vq ) ) { return 0 ; } if ( ! virtqueue_pop ( vq , & elem ) ) { return 0 ; }  memcpy ( elem . in_sg [ 0 ] . iov_base , buf , len ) ;  virtqueue_push ( vq , & elem , len ) ; virtio_notify ( VIRTIO_DEVICE ( vser ) , vq ) ; return len ; }","iov_from_buf ( elem . in_sg [ 0 ] . iov_base , buf , len ) ;virtqueue_push ( vq , & elem , len ) ;",359
489,"buggy line: \\\}cwe id:CWE-000context: static int jpc_qcd_dumpparms ( jpc_ms_t * ms , FILE * out ) { jpc_qcd_t * qcd = & ms -> parms . qcd ; int i ; fprintf ( out , ""qntsty<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>numguard<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>numstepsizes<S2SV_blank>=<S2SV_blank>%d\\n"" , ( int ) qcd -> compparms . qntsty , qcd -> compparms . numguard , qcd -> compparms . numstepsizes ) ; for ( i = 0 ; i < qcd -> compparms . numstepsizes ; ++ i ) { fprintf ( out , ""expn[%d]<S2SV_blank>=<S2SV_blank>0x%04x;<S2SV_blank>mant[%d]<S2SV_blank>=<S2SV_blank>0x%04x;\\n"" ,  i , ( unsigned ) JPC_QCX_GETEXPN ( qcd -> compparms . stepsizes [ i ] ) ,   i , ( unsigned ) JPC_QCX_GETMANT ( qcd -> compparms . stepsizes [ i ] ) ) ;  } return 0 ; }",\\\},360
490,"buggy line: duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\\err = xt_check_entry_offsets ( e , e -> target_offset , e -> next_offset ) ;if ( err ) return err ;cwe id:CWE-264context: static int check_entry_size_and_hooks ( struct ip6t_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct ip6t_entry ) != 0 || ( unsigned char * ) e + sizeof ( struct ip6t_entry ) >= limit || ( unsigned char * ) e + e -> next_offset > limit ) { duprintf ( ""Bad<S2SV_blank>offset<S2SV_blank>%p\\n"" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct ip6t_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\n"" , e , e -> next_offset ) ; return - EINVAL ; } if ( ! ip6_checkentry ( & e -> ipv6 ) ) return - EINVAL ;  err = xt_check_entry_offsets ( e , e -> target_offset , e -> next_offset ) ;  if ( err ) return err ; for ( h = 0 ; h < NF_INET_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) { pr_debug ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>"" ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"" ""ACCEPT/DROP\\n"" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows [ h ] ; } } e -> counters = ( ( struct xt_counters ) { 0 , 0 } ) ; e -> comefrom = 0 ; return 0 ; }","duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\\err = xt_check_entry_offsets ( e , e -> target_offset , e -> next_offset ) ;if ( err ) return err ;",361
491,"buggy line: }else if ( encoding == 1 && ( c -> bpp == 6 || c -> bpp == 8 ) ) {if ( c -> palette_size != ( 1 << ( c -> bpp - 1 ) ) ) return AVERROR_INVALIDDATA ;cwe id:CWE-119context: static int cdxl_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * pkt ) { CDXLVideoContext * c = avctx -> priv_data ; AVFrame * const p = data ; int ret , w , h , encoding , aligned_width , buf_size = pkt -> size ; const uint8_t * buf = pkt -> data ; if ( buf_size < 32 ) return AVERROR_INVALIDDATA ; encoding = buf [ 1 ] & 7 ; c -> format = buf [ 1 ] & 0xE0 ; w = AV_RB16 ( & buf [ 14 ] ) ; h = AV_RB16 ( & buf [ 16 ] ) ; c -> bpp = buf [ 19 ] ; c -> palette_size = AV_RB16 ( & buf [ 20 ] ) ; c -> palette = buf + 32 ; c -> video = c -> palette + c -> palette_size ; c -> video_size = buf_size - c -> palette_size - 32 ; if ( c -> palette_size > 512 ) return AVERROR_INVALIDDATA ; if ( buf_size < c -> palette_size + 32 ) return AVERROR_INVALIDDATA ; if ( c -> bpp < 1 ) return AVERROR_INVALIDDATA ; if ( c -> format != BIT_PLANAR && c -> format != BIT_LINE && c -> format != CHUNKY ) { avpriv_request_sample ( avctx , ""Pixel<S2SV_blank>format<S2SV_blank>0x%0x"" , c -> format ) ; return AVERROR_PATCHWELCOME ; } if ( ( ret = ff_set_dimensions ( avctx , w , h ) ) < 0 ) return ret ; if ( c -> format == CHUNKY ) aligned_width = avctx -> width ; else aligned_width = FFALIGN ( c -> avctx -> width , 16 ) ; c -> padded_bits = aligned_width - c -> avctx -> width ; if ( c -> video_size < aligned_width * avctx -> height * ( int64_t ) c -> bpp / 8 ) return AVERROR_INVALIDDATA ; if ( ! encoding && c -> palette_size && c -> bpp <= 8 && c -> format != CHUNKY ) { avctx -> pix_fmt = AV_PIX_FMT_PAL8 ;  } else if ( encoding == 1 && ( c -> bpp == 6 || c -> bpp == 8 ) ) {  if ( c -> palette_size != ( 1 << ( c -> bpp - 1 ) ) ) return AVERROR_INVALIDDATA ; avctx -> pix_fmt = AV_PIX_FMT_BGR24 ; } else if ( ! encoding && c -> bpp == 24 && c -> format == CHUNKY && ! c -> palette_size ) { avctx -> pix_fmt = AV_PIX_FMT_RGB24 ; } else { avpriv_request_sample ( avctx , ""Encoding<S2SV_blank>%d,<S2SV_blank>bpp<S2SV_blank>%d<S2SV_blank>and<S2SV_blank>format<S2SV_blank>0x%x"" , encoding , c -> bpp , c -> format ) ; return AVERROR_PATCHWELCOME ; } if ( ( ret = ff_get_buffer ( avctx , p , 0 ) ) < 0 ) return ret ; p -> pict_type = AV_PICTURE_TYPE_I ; if ( encoding ) { av_fast_padded_malloc ( & c -> new_video , & c -> new_video_size , h * w + AV_INPUT_BUFFER_PADDING_SIZE ) ; if ( ! c -> new_video ) return AVERROR ( ENOMEM ) ; if ( c -> bpp == 8 ) cdxl_decode_ham8 ( c , p ) ; else cdxl_decode_ham6 ( c , p ) ; } else if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 ) { cdxl_decode_rgb ( c , p ) ; } else { cdxl_decode_raw ( c , p ) ; } * got_frame = 1 ; return buf_size ; }",}else if ( encoding == 1 && ( c -> bpp == 6 || c -> bpp == 8 ) && c -> format != CHUNKY ) {if ( c -> palette_size != ( 1 << ( c -> bpp - 1 ) ) ) return AVERROR_INVALIDDATA ;,362
492,"buggy line: isoclns_print ( ndo , p + 1 , length - 1 , caplen - 1 ) ;return ( 1 ) ;cwe id:CWE-125context: int ethertype_print ( netdissect_options * ndo , u_short ether_type , const u_char * p , u_int length , u_int caplen , const struct lladdr_info * src , const struct lladdr_info * dst ) { switch ( ether_type ) { case ETHERTYPE_IP : ip_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_IPV6 : ip6_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_ARP : case ETHERTYPE_REVARP : arp_print ( ndo , p , length , caplen ) ; return ( 1 ) ; case ETHERTYPE_DN : decnet_print ( ndo , p , length , caplen ) ; return ( 1 ) ; case ETHERTYPE_ATALK : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""et1<S2SV_blank>"" ) ) ; atalk_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_AARP : aarp_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_IPX : ND_PRINT ( ( ndo , ""(NOV-ETHII)<S2SV_blank>"" ) ) ; ipx_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_ISO : if ( length == 0 || caplen == 0 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[|osi]"" ) ) ; return ( 1 ) ; }  isoclns_print ( ndo , p + 1 , length - 1 , caplen - 1 ) ;  return ( 1 ) ; case ETHERTYPE_PPPOED : case ETHERTYPE_PPPOES : case ETHERTYPE_PPPOED2 : case ETHERTYPE_PPPOES2 : pppoe_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_EAPOL : eap_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_RRCP : rrcp_print ( ndo , p , length , src , dst ) ; return ( 1 ) ; case ETHERTYPE_PPP : if ( length ) { ND_PRINT ( ( ndo , "":<S2SV_blank>"" ) ) ; ppp_print ( ndo , p , length ) ; } return ( 1 ) ; case ETHERTYPE_MPCP : mpcp_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_SLOW : slow_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_CFM : case ETHERTYPE_CFM_OLD : cfm_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_LLDP : lldp_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_NSH : nsh_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_LOOPBACK : loopback_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_MPLS : case ETHERTYPE_MPLS_MULTI : mpls_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_TIPC : tipc_print ( ndo , p , length , caplen ) ; return ( 1 ) ; case ETHERTYPE_MS_NLB_HB : msnlb_print ( ndo , p ) ; return ( 1 ) ; case ETHERTYPE_GEONET_OLD : case ETHERTYPE_GEONET : geonet_print ( ndo , p , length , src ) ; return ( 1 ) ; case ETHERTYPE_CALM_FAST : calm_fast_print ( ndo , p , length , src ) ; return ( 1 ) ; case ETHERTYPE_AOE : aoe_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_MEDSA : medsa_print ( ndo , p , length , caplen , src , dst ) ; return ( 1 ) ; case ETHERTYPE_LAT : case ETHERTYPE_SCA : case ETHERTYPE_MOPRC : case ETHERTYPE_MOPDL : case ETHERTYPE_IEEE1905_1 : default : return ( 0 ) ; } }","isoclns_print ( ndo , p + 1 , length - 1 ) ;return ( 1 ) ;",363
493,buggy line: snd_seq_timer_stop ( q -> timer ) ;snd_seq_timer_close ( q ) ;snd_use_lock_sync ( & q -> use_lock ) ;cwe id:CWE-362context: static void queue_delete ( struct snd_seq_queue * q ) {  snd_seq_timer_stop ( q -> timer ) ;   snd_seq_timer_close ( q ) ;  snd_use_lock_sync ( & q -> use_lock ) ; snd_seq_prioq_delete ( & q -> tickq ) ; snd_seq_prioq_delete ( & q -> timeq ) ; snd_seq_timer_delete ( & q -> timer ) ; kfree ( q ) ; },mutex_lock ( & q -> timer_mutex ) ;snd_seq_timer_stop ( q -> timer ) ;snd_seq_timer_close ( q ) ;mutex_unlock ( & q -> timer_mutex ) ;snd_use_lock_sync ( & q -> use_lock ) ;,364
494,"buggy line: u64 start = offset >> PAGE_CACHE_SHIFT ;unsigned int start_offset = offset & ~ PAGE_CACHE_MASK ;u64 end = ( offset + len - 1 ) >> PAGE_CACHE_SHIFT ;pgoff_t curr ;struct page * page ;unsigned int end_offset = ( offset + len ) & ~ PAGE_CACHE_MASK ;unsigned int from , to ;if ( ! end_offset ) end_offset = PAGE_CACHE_SIZE ;if ( unlikely ( error ) ) goto out ;curr = start ;offset = start << PAGE_CACHE_SHIFT ;from = start_offset ;to = PAGE_CACHE_SIZE ;while ( curr <= end ) {page = grab_cache_page_write_begin ( inode -> i_mapping , curr , AOP_FLAG_NOFS ) ;if ( unlikely ( ! page ) ) {error = - ENOMEM ;if ( curr == end ) to = end_offset ;error = write_empty_blocks ( page , from , to , mode ) ;if ( ! error && offset + to > inode -> i_size &&  ! ( mode & FALLOC_FL_KEEP_SIZE ) ) {i_size_write ( inode , offset + to ) ;}cwe id:CWE-119context: static int fallocate_chunk ( struct inode * inode , loff_t offset , loff_t len , int mode ) { struct gfs2_inode * ip = GFS2_I ( inode ) ; struct buffer_head * dibh ; int error ;  u64 start = offset >> PAGE_CACHE_SHIFT ;  unsigned int start_offset = offset & ~ PAGE_CACHE_MASK ;  u64 end = ( offset + len - 1 ) >> PAGE_CACHE_SHIFT ;  pgoff_t curr ; struct page * page ; unsigned int end_offset = ( offset + len ) & ~ PAGE_CACHE_MASK ; unsigned int from , to ; if ( ! end_offset ) end_offset = PAGE_CACHE_SIZE ; error = gfs2_meta_inode_buffer ( ip , & dibh ) ; if ( unlikely ( error ) ) goto out ; gfs2_trans_add_bh ( ip -> i_gl , dibh , 1 ) ; if ( gfs2_is_stuffed ( ip ) ) { error = gfs2_unstuff_dinode ( ip , NULL ) ; if ( unlikely ( error ) ) goto out ; } curr = start ; offset = start << PAGE_CACHE_SHIFT ; from = start_offset ; to = PAGE_CACHE_SIZE ; while ( curr <= end ) { page = grab_cache_page_write_begin ( inode -> i_mapping , curr , AOP_FLAG_NOFS ) ; if ( unlikely ( ! page ) ) { error = - ENOMEM ; goto out ; } if ( curr == end ) to = end_offset ; error = write_empty_blocks ( page , from , to , mode ) ; if ( ! error && offset + to > inode -> i_size &&  ! ( mode & FALLOC_FL_KEEP_SIZE ) ) {   i_size_write ( inode , offset + to ) ;  } unlock_page ( page ) ; page_cache_release ( page ) ; if ( error ) goto out ; curr ++ ; offset += PAGE_CACHE_SIZE ; from = 0 ; }  mark_inode_dirty ( inode ) ;  brelse ( dibh ) ; out :  return error ;  }","unsigned int nr_blks ;sector_t lblock = offset >> inode -> i_blkbits ;if ( unlikely ( error ) ) return error ;while ( len ) {struct buffer_head bh_map = {. b_state = 0 , . b_blocknr = 0 };bh_map . b_size = len ;set_buffer_zeronew ( & bh_map ) ;error = gfs2_block_map ( inode , lblock , & bh_map , 1 ) ;if ( unlikely ( error ) ) goto out ;len -= bh_map . b_size ;nr_blks = bh_map . b_size >> inode -> i_blkbits ;lblock += nr_blks ;if ( ! buffer_new ( & bh_map ) ) continue ;if ( unlikely ( ! buffer_zeronew ( & bh_map ) ) ) {error = - EIO ;}if ( offset + len > inode -> i_size && ! ( mode & FALLOC_FL_KEEP_SIZE ) ) {i_size_write ( inode , offset + to ) ;}",365
495,"buggy line: mark_inode_dirty ( inode ) ;brelse ( dibh ) ;out :  return error ;}cwe id:CWE-119context: static int fallocate_chunk ( struct inode * inode , loff_t offset , loff_t len , int mode ) { struct gfs2_inode * ip = GFS2_I ( inode ) ; struct buffer_head * dibh ; int error ;  u64 start = offset >> PAGE_CACHE_SHIFT ;  unsigned int start_offset = offset & ~ PAGE_CACHE_MASK ;  u64 end = ( offset + len - 1 ) >> PAGE_CACHE_SHIFT ;  pgoff_t curr ; struct page * page ; unsigned int end_offset = ( offset + len ) & ~ PAGE_CACHE_MASK ; unsigned int from , to ; if ( ! end_offset ) end_offset = PAGE_CACHE_SIZE ; error = gfs2_meta_inode_buffer ( ip , & dibh ) ; if ( unlikely ( error ) ) goto out ; gfs2_trans_add_bh ( ip -> i_gl , dibh , 1 ) ; if ( gfs2_is_stuffed ( ip ) ) { error = gfs2_unstuff_dinode ( ip , NULL ) ; if ( unlikely ( error ) ) goto out ; } curr = start ; offset = start << PAGE_CACHE_SHIFT ; from = start_offset ; to = PAGE_CACHE_SIZE ; while ( curr <= end ) { page = grab_cache_page_write_begin ( inode -> i_mapping , curr , AOP_FLAG_NOFS ) ; if ( unlikely ( ! page ) ) { error = - ENOMEM ; goto out ; } if ( curr == end ) to = end_offset ; error = write_empty_blocks ( page , from , to , mode ) ; if ( ! error && offset + to > inode -> i_size &&  ! ( mode & FALLOC_FL_KEEP_SIZE ) ) {   i_size_write ( inode , offset + to ) ;  } unlock_page ( page ) ; page_cache_release ( page ) ; if ( error ) goto out ; curr ++ ; offset += PAGE_CACHE_SIZE ; from = 0 ; }  mark_inode_dirty ( inode ) ;  brelse ( dibh ) ; out :  return error ;  }",mark_inode_dirty ( inode ) ;brelse ( dibh ) ;out : brelse ( dibh ) ;return error ;},365
496,"buggy line: VipsForeignLoadClass * class = VIPS_FOREIGN_LOAD_GET_CLASS ( load ) ;if ( ! load -> real ) {if ( ! ( load -> real = vips_foreign_load_temp ( load ) ) ) return ( NULL ) ;# ifdef DEBUG printf ( ""vips_foreign_load_start:<S2SV_blank>triggering<S2SV_blank>->load()\\\# endif load -> real -> progress_signal = load -> out ;g_object_set_qdata ( G_OBJECT ( load -> real ) , vips__foreign_load_operation , load ) ;if ( class -> load ( load ) ||  vips_image_pio_input ( load -> real ) )  return ( NULL ) ;if ( ! vips_foreign_load_iscompat ( load -> real , out ) )  return ( NULL ) ;vips_image_pipelinev ( load -> out , load -> out -> dhint , load -> real , NULL ) ;cwe id:CWE-362context: static void * vips_foreign_load_start ( VipsImage * out , void * a , void * b ) { VipsForeignLoad * load = VIPS_FOREIGN_LOAD ( b ) ;  VipsForeignLoadClass * class = VIPS_FOREIGN_LOAD_GET_CLASS ( load ) ;  if ( ! load -> real ) { if ( ! ( load -> real = vips_foreign_load_temp ( load ) ) ) return ( NULL ) ; # ifdef DEBUG printf ( ""vips_foreign_load_start:<S2SV_blank>triggering<S2SV_blank>->load()\\n"" ) ; # endif load -> real -> progress_signal = load -> out ; g_object_set_qdata ( G_OBJECT ( load -> real ) , vips__foreign_load_operation , load ) ; if ( class -> load ( load ) ||  vips_image_pio_input ( load -> real ) )  return ( NULL ) ; if ( ! vips_foreign_load_iscompat ( load -> real , out ) )  return ( NULL ) ;  vips_image_pipelinev ( load -> out , load -> out -> dhint , load -> real , NULL ) ; } return ( vips_region_new ( load -> real ) ) ; }","VipsForeignLoadClass * class = VIPS_FOREIGN_LOAD_GET_CLASS ( load ) ;if ( load -> error ) return ( NULL ) ;if ( ! load -> real ) || vips_foreign_load_iscompat ( load -> real , out ) ) return ( NULL ) ;vips_image_pipelinev ( load -> out , load -> out -> dhint , load -> real , NULL ) ;",366
497,"buggy line: const char * name = fit_get_name ( fit , noffset , NULL ) ;if ( ! strncmp ( name , FIT_SIG_NODENAME , strlen ( FIT_SIG_NODENAME ) ) ) {cwe id:CWE-000context: static int fit_image_verify_sig ( const void * fit , int image_noffset , const char * data , size_t size , const void * sig_blob , int sig_offset ) { int noffset ; char * err_msg = """" ; int verified = 0 ; int ret ; fdt_for_each_subnode ( noffset , fit , image_noffset ) {  const char * name = fit_get_name ( fit , noffset , NULL ) ;  if ( ! strncmp ( name , FIT_SIG_NODENAME , strlen ( FIT_SIG_NODENAME ) ) ) { ret = fit_image_check_sig ( fit , noffset , data , size , - 1 , & err_msg ) ; if ( ret ) { puts ( ""-<S2SV_blank>"" ) ; } else { puts ( ""+<S2SV_blank>"" ) ; verified = 1 ; break ; } } } if ( noffset == - FDT_ERR_TRUNCATED || noffset == - FDT_ERR_BADSTRUCTURE ) { err_msg = ""Corrupted<S2SV_blank>or<S2SV_blank>truncated<S2SV_blank>tree"" ; goto error ; } return verified ? 0 : - EPERM ; error : printf ( ""<S2SV_blank>error!\\n%s<S2SV_blank>for<S2SV_blank>\'%s\'<S2SV_blank>hash<S2SV_blank>node<S2SV_blank>in<S2SV_blank>\'%s\'<S2SV_blank>image<S2SV_blank>node\\n"" , err_msg , fit_get_name ( fit , noffset , NULL ) , fit_get_name ( fit , image_noffset , NULL ) ) ; return - 1 ; }","const char * name = fit_get_name ( fit , noffset , NULL ) ;if ( strchr ( name , \'@\' ) ) {err_msg = ""Node<S2SV_blank>name<S2SV_blank>contains<S2SV_blank>@"" ;goto error ;}if ( ! strncmp ( name , FIT_SIG_NODENAME , strlen ( FIT_SIG_NODENAME ) ) ) {",367
498,"buggy line: if ( context -> resynch ) {entry = & entries [ 0 ] ;for ( i = 0 ;i < ichdr . count ;entry ++ , i ++ ) {if ( be32_to_cpu ( entry -> hashval ) == cursor -> hashval ) {if ( cursor -> offset == context -> dupcnt ) {context -> dupcnt = 0 ;break ;}context -> dupcnt ++ ;}else if ( be32_to_cpu ( entry -> hashval ) > cursor -> hashval ) {context -> dupcnt = 0 ;break ;}}if ( i == ichdr . count ) {trace_xfs_attr_list_notfound ( context ) ;return 0 ;}}else {entry = & entries [ 0 ] ;i = 0 ;}context -> resynch = 0 ;retval = 0 ;for ( ;i < ichdr . count ;entry ++ , i ++ ) {if ( be32_to_cpu ( entry -> hashval ) != cursor -> hashval ) {cursor -> hashval = be32_to_cpu ( entry -> hashval ) ;cursor -> offset = 0 ;}if ( entry -> flags & XFS_ATTR_INCOMPLETE ) continue ;if ( entry -> flags & XFS_ATTR_LOCAL ) {xfs_attr_leaf_name_local_t * name_loc = xfs_attr3_leaf_name_local ( leaf , i ) ;retval = context -> put_listent ( context , entry -> flags , name_loc -> nameval , ( int ) name_loc -> namelen , be16_to_cpu ( name_loc -> valuelen ) , & name_loc -> nameval [ name_loc -> namelen ] ) ;cwe id:CWE-400context: int xfs_attr3_leaf_list_int ( struct xfs_buf * bp , struct xfs_attr_list_context * context ) { struct attrlist_cursor_kern * cursor ; struct xfs_attr_leafblock * leaf ; struct xfs_attr3_icleaf_hdr ichdr ; struct xfs_attr_leaf_entry * entries ; struct xfs_attr_leaf_entry * entry ; int retval ; int i ; struct xfs_mount * mp = context -> dp -> i_mount ; trace_xfs_attr_list_leaf ( context ) ; leaf = bp -> b_addr ; xfs_attr3_leaf_hdr_from_disk ( mp -> m_attr_geo , & ichdr , leaf ) ; entries = xfs_attr3_leaf_entryp ( leaf ) ; cursor = context -> cursor ; cursor -> initted = 1 ; if ( context -> resynch ) { entry = & entries [ 0 ] ; for ( i = 0 ; i < ichdr . count ; entry ++ , i ++ ) { if ( be32_to_cpu ( entry -> hashval ) == cursor -> hashval ) { if ( cursor -> offset == context -> dupcnt ) { context -> dupcnt = 0 ; break ; } context -> dupcnt ++ ; } else if ( be32_to_cpu ( entry -> hashval ) > cursor -> hashval ) { context -> dupcnt = 0 ; break ; } } if ( i == ichdr . count ) { trace_xfs_attr_list_notfound ( context ) ; return 0 ; } } else { entry = & entries [ 0 ] ; i = 0 ; } context -> resynch = 0 ; retval = 0 ; for ( ; i < ichdr . count ; entry ++ , i ++ ) { if ( be32_to_cpu ( entry -> hashval ) != cursor -> hashval ) { cursor -> hashval = be32_to_cpu ( entry -> hashval ) ; cursor -> offset = 0 ; } if ( entry -> flags & XFS_ATTR_INCOMPLETE ) continue ; if ( entry -> flags & XFS_ATTR_LOCAL ) { xfs_attr_leaf_name_local_t * name_loc = xfs_attr3_leaf_name_local ( leaf , i ) ; retval = context -> put_listent ( context , entry -> flags , name_loc -> nameval , ( int ) name_loc -> namelen , be16_to_cpu ( name_loc -> valuelen ) , & name_loc -> nameval [ name_loc -> namelen ] ) ; if ( retval ) return retval ; } else { xfs_attr_leaf_name_remote_t * name_rmt = xfs_attr3_leaf_name_remote ( leaf , i ) ; int valuelen = be32_to_cpu ( name_rmt -> valuelen ) ; if ( context -> put_value ) { xfs_da_args_t args ; memset ( ( char * ) & args , 0 , sizeof ( args ) ) ; args . geo = context -> dp -> i_mount -> m_attr_geo ; args . dp = context -> dp ; args . whichfork = XFS_ATTR_FORK ; args . valuelen = valuelen ; args . rmtvaluelen = valuelen ; args . value = kmem_alloc ( valuelen , KM_SLEEP | KM_NOFS ) ; args . rmtblkno = be32_to_cpu ( name_rmt -> valueblk ) ; args . rmtblkcnt = xfs_attr3_rmt_blocks ( args . dp -> i_mount , valuelen ) ; retval = xfs_attr_rmtval_get ( & args ) ;  if ( retval )  return retval ; retval = context -> put_listent ( context , entry -> flags , name_rmt -> name , ( int ) name_rmt -> namelen , valuelen , args . value ) ; kmem_free ( args . value ) ; } else { retval = context -> put_listent ( context , entry -> flags , name_rmt -> name , ( int ) name_rmt -> namelen , valuelen , NULL ) ; } if ( retval ) return retval ; } if ( context -> seen_enough ) break ; cursor -> offset ++ ; } trace_xfs_attr_list_leaf_end ( context ) ; return retval ; }","if ( ! retval ) retval = context -> put_listent ( context , entry -> flags , name_loc -> nameval , ( int ) name_loc -> namelen , be16_to_cpu ( name_loc -> valuelen ) , & name_loc -> nameval [ name_loc -> namelen ] ) ;",368
499,"buggy line: if ( retval )  return retval ;cwe id:CWE-400context: int xfs_attr3_leaf_list_int ( struct xfs_buf * bp , struct xfs_attr_list_context * context ) { struct attrlist_cursor_kern * cursor ; struct xfs_attr_leafblock * leaf ; struct xfs_attr3_icleaf_hdr ichdr ; struct xfs_attr_leaf_entry * entries ; struct xfs_attr_leaf_entry * entry ; int retval ; int i ; struct xfs_mount * mp = context -> dp -> i_mount ; trace_xfs_attr_list_leaf ( context ) ; leaf = bp -> b_addr ; xfs_attr3_leaf_hdr_from_disk ( mp -> m_attr_geo , & ichdr , leaf ) ; entries = xfs_attr3_leaf_entryp ( leaf ) ; cursor = context -> cursor ; cursor -> initted = 1 ; if ( context -> resynch ) { entry = & entries [ 0 ] ; for ( i = 0 ; i < ichdr . count ; entry ++ , i ++ ) { if ( be32_to_cpu ( entry -> hashval ) == cursor -> hashval ) { if ( cursor -> offset == context -> dupcnt ) { context -> dupcnt = 0 ; break ; } context -> dupcnt ++ ; } else if ( be32_to_cpu ( entry -> hashval ) > cursor -> hashval ) { context -> dupcnt = 0 ; break ; } } if ( i == ichdr . count ) { trace_xfs_attr_list_notfound ( context ) ; return 0 ; } } else { entry = & entries [ 0 ] ; i = 0 ; } context -> resynch = 0 ; retval = 0 ; for ( ; i < ichdr . count ; entry ++ , i ++ ) { if ( be32_to_cpu ( entry -> hashval ) != cursor -> hashval ) { cursor -> hashval = be32_to_cpu ( entry -> hashval ) ; cursor -> offset = 0 ; } if ( entry -> flags & XFS_ATTR_INCOMPLETE ) continue ; if ( entry -> flags & XFS_ATTR_LOCAL ) { xfs_attr_leaf_name_local_t * name_loc = xfs_attr3_leaf_name_local ( leaf , i ) ; retval = context -> put_listent ( context , entry -> flags , name_loc -> nameval , ( int ) name_loc -> namelen , be16_to_cpu ( name_loc -> valuelen ) , & name_loc -> nameval [ name_loc -> namelen ] ) ; if ( retval ) return retval ; } else { xfs_attr_leaf_name_remote_t * name_rmt = xfs_attr3_leaf_name_remote ( leaf , i ) ; int valuelen = be32_to_cpu ( name_rmt -> valuelen ) ; if ( context -> put_value ) { xfs_da_args_t args ; memset ( ( char * ) & args , 0 , sizeof ( args ) ) ; args . geo = context -> dp -> i_mount -> m_attr_geo ; args . dp = context -> dp ; args . whichfork = XFS_ATTR_FORK ; args . valuelen = valuelen ; args . rmtvaluelen = valuelen ; args . value = kmem_alloc ( valuelen , KM_SLEEP | KM_NOFS ) ; args . rmtblkno = be32_to_cpu ( name_rmt -> valueblk ) ; args . rmtblkcnt = xfs_attr3_rmt_blocks ( args . dp -> i_mount , valuelen ) ; retval = xfs_attr_rmtval_get ( & args ) ;  if ( retval )  return retval ; retval = context -> put_listent ( context , entry -> flags , name_rmt -> name , ( int ) name_rmt -> namelen , valuelen , args . value ) ; kmem_free ( args . value ) ; } else { retval = context -> put_listent ( context , entry -> flags , name_rmt -> name , ( int ) name_rmt -> namelen , valuelen , NULL ) ; } if ( retval ) return retval ; } if ( context -> seen_enough ) break ; cursor -> offset ++ ; } trace_xfs_attr_list_leaf_end ( context ) ; return retval ; }",if ( retval ) return retval ;,368
500,"buggy line: if ( kfifo_alloc ( & state -> rx_kfifo , CX23888_IR_RX_KFIFO_SIZE , GFP_KERNEL ) )  return - ENOMEM ;state -> dev = dev ;sd = & state -> sd ;cwe id:CWE-401context: int cx23888_ir_probe ( struct cx23885_dev * dev ) { struct cx23888_ir_state * state ; struct v4l2_subdev * sd ; struct v4l2_subdev_ir_parameters default_params ; int ret ; state = kzalloc ( sizeof ( struct cx23888_ir_state ) , GFP_KERNEL ) ; if ( state == NULL ) return - ENOMEM ; spin_lock_init ( & state -> rx_kfifo_lock ) ;  if ( kfifo_alloc ( & state -> rx_kfifo , CX23888_IR_RX_KFIFO_SIZE , GFP_KERNEL ) )  return - ENOMEM ;  state -> dev = dev ;  sd = & state -> sd ; v4l2_subdev_init ( sd , & cx23888_ir_controller_ops ) ; v4l2_set_subdevdata ( sd , state ) ; snprintf ( sd -> name , sizeof ( sd -> name ) , ""%s/888-ir"" , dev -> name ) ; sd -> grp_id = CX23885_HW_888_IR ; ret = v4l2_device_register_subdev ( & dev -> v4l2_dev , sd ) ; if ( ret == 0 ) { cx23888_ir_write4 ( dev , CX23888_IR_IRQEN_REG , 0 ) ; mutex_init ( & state -> rx_params_lock ) ; default_params = default_rx_params ; v4l2_subdev_call ( sd , ir , rx_s_parameters , & default_params ) ; mutex_init ( & state -> tx_params_lock ) ; default_params = default_tx_params ; v4l2_subdev_call ( sd , ir , tx_s_parameters , & default_params ) ; } else { kfifo_free ( & state -> rx_kfifo ) ; } return ret ; }","if ( kfifo_alloc ( & state -> rx_kfifo , CX23888_IR_RX_KFIFO_SIZE , GFP_KERNEL ) ) {kfree ( state ) ;return - ENOMEM ;}state -> dev = dev ;sd = & state -> sd ;",369
501,"buggy line: size += service_name_tlv_length ;}size += miux_tlv_length ;rw_tlv = nfc_llcp_build_tlv ( LLCP_TLV_RW , & rw , 0 , & rw_tlv_length ) ;size += rw_tlv_length ;pr_debug ( ""SKB<S2SV_blank>size<S2SV_blank>%d<S2SV_blank>SN<S2SV_blank>length<S2SV_blank>%zu\\\cwe id:CWE-476context: int nfc_llcp_send_connect ( struct nfc_llcp_sock * sock ) { struct nfc_llcp_local * local ; struct sk_buff * skb ; u8 * service_name_tlv = NULL , service_name_tlv_length ; u8 * miux_tlv = NULL , miux_tlv_length ; u8 * rw_tlv = NULL , rw_tlv_length , rw ; int err ; u16 size = 0 ; __be16 miux ; pr_debug ( ""Sending<S2SV_blank>CONNECT\\n"" ) ; local = sock -> local ; if ( local == NULL ) return - ENODEV ; if ( sock -> service_name != NULL ) { service_name_tlv = nfc_llcp_build_tlv ( LLCP_TLV_SN , sock -> service_name , sock -> service_name_len , & service_name_tlv_length ) ;  size += service_name_tlv_length ;  } miux = be16_to_cpu ( sock -> miux ) > LLCP_MAX_MIUX ? local -> miux : sock -> miux ; rw = sock -> rw > LLCP_MAX_RW ? local -> rw : sock -> rw ; miux_tlv = nfc_llcp_build_tlv ( LLCP_TLV_MIUX , ( u8 * ) & miux , 0 , & miux_tlv_length ) ;  size += miux_tlv_length ;  rw_tlv = nfc_llcp_build_tlv ( LLCP_TLV_RW , & rw , 0 , & rw_tlv_length ) ;  size += rw_tlv_length ;  pr_debug ( ""SKB<S2SV_blank>size<S2SV_blank>%d<S2SV_blank>SN<S2SV_blank>length<S2SV_blank>%zu\\n"" , size , sock -> service_name_len ) ; skb = llcp_allocate_pdu ( sock , LLCP_PDU_CONNECT , size ) ; if ( skb == NULL ) { err = - ENOMEM ; goto error_tlv ; } llcp_add_tlv ( skb , service_name_tlv , service_name_tlv_length ) ; llcp_add_tlv ( skb , miux_tlv , miux_tlv_length ) ; llcp_add_tlv ( skb , rw_tlv , rw_tlv_length ) ; skb_queue_tail ( & local -> tx_queue , skb ) ; err = 0 ; error_tlv : if ( err ) pr_err ( ""error<S2SV_blank>%d\\n"" , err ) ; kfree ( service_name_tlv ) ; kfree ( miux_tlv ) ; kfree ( rw_tlv ) ; return err ; }","if ( ! service_name_tlv ) {err = - ENOMEM ;goto error_tlv ;}size += service_name_tlv_length ;}if ( ! miux_tlv ) {err = - ENOMEM ;goto error_tlv ;}size += miux_tlv_length ;rw_tlv = nfc_llcp_build_tlv ( LLCP_TLV_RW , & rw , 0 , & rw_tlv_length ) ;if ( ! rw_tlv ) {err = - ENOMEM ;goto error_tlv ;}size += rw_tlv_length ;pr_debug ( ""SKB<S2SV_blank>size<S2SV_blank>%d<S2SV_blank>SN<S2SV_blank>length<S2SV_blank>%zu\\\",370
502,"buggy line: struct ssh * ssh = active_state ;struct monitor * mon ;if ( options . compression ) {mon -> m_zback = mm_create ( NULL , MM_MEMSIZE ) ;mon -> m_zlib = mm_create ( mon -> m_zback , 20 * MM_MEMSIZE ) ;ssh_packet_set_compress_hooks ( ssh , mon -> m_zlib , ( ssh_packet_comp_alloc_func * ) mm_zalloc , ( ssh_packet_comp_free_func * ) mm_zfree ) ;}cwe id:CWE-119context: struct monitor * monitor_init ( void ) {  struct ssh * ssh = active_state ;  struct monitor * mon ; mon = xcalloc ( 1 , sizeof ( * mon ) ) ; monitor_openfds ( mon , 1 ) ;  if ( options . compression ) {  mon -> m_zback = mm_create ( NULL , MM_MEMSIZE ) ; mon -> m_zlib = mm_create ( mon -> m_zback , 20 * MM_MEMSIZE ) ; ssh_packet_set_compress_hooks ( ssh , mon -> m_zlib , ( ssh_packet_comp_alloc_func * ) mm_zalloc , ( ssh_packet_comp_free_func * ) mm_zfree ) ; } return mon ; }",struct monitor * mon ;,371
503,"buggy line: vpx_codec_err_t vpx_codec_dec_init_ver ( vpx_codec_ctx_t * ctx , vpx_codec_iface_t * iface ,  vpx_codec_dec_cfg_t * cfg ,  vpx_codec_flags_t flags , int ver ) {else if ( ( flags & VPX_CODEC_USE_XMA ) && ! ( iface -> caps & VPX_CODEC_CAP_XMA ) )  res = VPX_CODEC_INCAPABLE ;cwe id:CWE-119context: vpx_codec_err_t vpx_codec_dec_init_ver ( vpx_codec_ctx_t * ctx , vpx_codec_iface_t * iface ,  vpx_codec_dec_cfg_t * cfg ,  vpx_codec_flags_t flags , int ver ) { vpx_codec_err_t res ; if ( ver != VPX_DECODER_ABI_VERSION ) res = VPX_CODEC_ABI_MISMATCH ; else if ( ! ctx || ! iface ) res = VPX_CODEC_INVALID_PARAM ; else if ( iface -> abi_version != VPX_CODEC_INTERNAL_ABI_VERSION ) res = VPX_CODEC_ABI_MISMATCH ;  else if ( ( flags & VPX_CODEC_USE_XMA ) && ! ( iface -> caps & VPX_CODEC_CAP_XMA ) )  res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_POSTPROC ) && ! ( iface -> caps & VPX_CODEC_CAP_POSTPROC ) ) res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_ERROR_CONCEALMENT ) && ! ( iface -> caps & VPX_CODEC_CAP_ERROR_CONCEALMENT ) ) res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_INPUT_FRAGMENTS ) && ! ( iface -> caps & VPX_CODEC_CAP_INPUT_FRAGMENTS ) ) res = VPX_CODEC_INCAPABLE ; else if ( ! ( iface -> caps & VPX_CODEC_CAP_DECODER ) ) res = VPX_CODEC_INCAPABLE ; else { memset ( ctx , 0 , sizeof ( * ctx ) ) ; ctx -> iface = iface ; ctx -> name = iface -> name ; ctx -> priv = NULL ; ctx -> init_flags = flags ; ctx -> config . dec = cfg ;  res = VPX_CODEC_OK ;  if ( ! ( flags & VPX_CODEC_USE_XMA ) ) { res = ctx -> iface -> init ( ctx , NULL ) ; if ( res ) { ctx -> err_detail = ctx -> priv ? ctx -> priv -> err_detail : NULL ; vpx_codec_destroy ( ctx ) ; }  if ( ctx -> priv )  ctx -> priv -> iface = ctx -> iface ; } } return SAVE_STATUS ( ctx , res ) ; }","vpx_codec_err_t vpx_codec_dec_init_ver ( vpx_codec_ctx_t * ctx , vpx_codec_iface_t * iface , const vpx_codec_dec_cfg_t * cfg , vpx_codec_flags_t flags , int ver ) {",372
504,"buggy line: res = VPX_CODEC_OK ;if ( ! ( flags & VPX_CODEC_USE_XMA ) ) {}if ( ctx -> priv )  ctx -> priv -> iface = ctx -> iface ;cwe id:CWE-119context: vpx_codec_err_t vpx_codec_dec_init_ver ( vpx_codec_ctx_t * ctx , vpx_codec_iface_t * iface ,  vpx_codec_dec_cfg_t * cfg ,  vpx_codec_flags_t flags , int ver ) { vpx_codec_err_t res ; if ( ver != VPX_DECODER_ABI_VERSION ) res = VPX_CODEC_ABI_MISMATCH ; else if ( ! ctx || ! iface ) res = VPX_CODEC_INVALID_PARAM ; else if ( iface -> abi_version != VPX_CODEC_INTERNAL_ABI_VERSION ) res = VPX_CODEC_ABI_MISMATCH ;  else if ( ( flags & VPX_CODEC_USE_XMA ) && ! ( iface -> caps & VPX_CODEC_CAP_XMA ) )  res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_POSTPROC ) && ! ( iface -> caps & VPX_CODEC_CAP_POSTPROC ) ) res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_ERROR_CONCEALMENT ) && ! ( iface -> caps & VPX_CODEC_CAP_ERROR_CONCEALMENT ) ) res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_INPUT_FRAGMENTS ) && ! ( iface -> caps & VPX_CODEC_CAP_INPUT_FRAGMENTS ) ) res = VPX_CODEC_INCAPABLE ; else if ( ! ( iface -> caps & VPX_CODEC_CAP_DECODER ) ) res = VPX_CODEC_INCAPABLE ; else { memset ( ctx , 0 , sizeof ( * ctx ) ) ; ctx -> iface = iface ; ctx -> name = iface -> name ; ctx -> priv = NULL ; ctx -> init_flags = flags ; ctx -> config . dec = cfg ;  res = VPX_CODEC_OK ;  if ( ! ( flags & VPX_CODEC_USE_XMA ) ) { res = ctx -> iface -> init ( ctx , NULL ) ; if ( res ) { ctx -> err_detail = ctx -> priv ? ctx -> priv -> err_detail : NULL ; vpx_codec_destroy ( ctx ) ; }  if ( ctx -> priv )  ctx -> priv -> iface = ctx -> iface ; } } return SAVE_STATUS ( ctx , res ) ; }","
",372
505,"buggy line: unsigned int channo ;if ( jp2_getuint16 ( in , & cdef -> numchans ) ) {cwe id:CWE-476context: static int jp2_cdef_getdata ( jp2_box_t * box , jas_stream_t * in ) { jp2_cdef_t * cdef = & box -> data . cdef ; jp2_cdefchan_t * chan ;  unsigned int channo ;  if ( jp2_getuint16 ( in , & cdef -> numchans ) ) { return - 1 ; } if ( ! ( cdef -> ents = jas_alloc2 ( cdef -> numchans , sizeof ( jp2_cdefchan_t ) ) ) ) { return - 1 ; } for ( channo = 0 ; channo < cdef -> numchans ; ++ channo ) { chan = & cdef -> ents [ channo ] ; if ( jp2_getuint16 ( in , & chan -> channo ) || jp2_getuint16 ( in , & chan -> type ) || jp2_getuint16 ( in , & chan -> assoc ) ) { return - 1 ; } } return 0 ; }","unsigned int channo ;cdef -> ents = 0 ;if ( jp2_getuint16 ( in , & cdef -> numchans ) ) {",373
506,"buggy line: value |= TJA1100_EXTENDED_CTRL_CONFIG_EN ;value |= TJA1100_CONFIG1_MII_MODE_RMII_25MHZ ;tja1100WritePhyReg ( interface , TJA1100_CONFIG1 , value ) ;cwe id:CWE-20context: error_t tja1100Init ( NetInterface * interface ) { uint16_t value ; TRACE_INFO ( ""Initializing<S2SV_blank>TJA1100...\\r\\n"" ) ; if ( interface -> phyAddr >= 32 ) { interface -> phyAddr = TJA1100_PHY_ADDR ; } if ( interface -> smiDriver != NULL ) { interface -> smiDriver -> init ( ) ; } if ( interface -> extIntDriver != NULL ) { interface -> extIntDriver -> init ( ) ; } tja1100WritePhyReg ( interface , TJA1100_BASIC_CTRL , TJA1100_BASIC_CTRL_RESET ) ; while ( tja1100ReadPhyReg ( interface , TJA1100_BASIC_CTRL ) & TJA1100_BASIC_CTRL_RESET ) { } tja1100DumpPhyReg ( interface ) ; value = tja1100ReadPhyReg ( interface , TJA1100_EXTENDED_CTRL ) ; value |= TJA1100_EXTENDED_CTRL_CONFIG_EN ; tja1100WritePhyReg ( interface , TJA1100_EXTENDED_CTRL , value ) ; value = tja1100ReadPhyReg ( interface , TJA1100_CONFIG1 ) ; value &= ~ TJA1100_CONFIG1_MII_MODE ;  value |= TJA1100_CONFIG1_MII_MODE_RMII_25MHZ ;  tja1100WritePhyReg ( interface , TJA1100_CONFIG1 , value ) ; value = tja1100ReadPhyReg ( interface , TJA1100_CONFIG1 ) ; value |= TJA1100_CONFIG1_AUTO_OP ; tja1100WritePhyReg ( interface , TJA1100_CONFIG1 , value ) ; interface -> phyEvent = TRUE ; osSetEvent ( & netEvent ) ; return NO_ERROR ; }","value |= TJA1100_CONFIG1_MII_MODE_RMII_25MHZ_XTAL ;value |= TJA1100_CONFIG1_MII_MODE_RMII_25MHZ ;tja1100WritePhyReg ( interface , TJA1100_CONFIG1 , value ) ;",374
507,"buggy line: if ( ip_options_echo ( & icmp_param . replyopts , skb_in ) )  goto out_unlock ;cwe id:CWE-362context: void icmp_send ( struct sk_buff * skb_in , int type , int code , __be32 info ) { struct iphdr * iph ; int room ; struct icmp_bxm icmp_param ; struct rtable * rt = skb_rtable ( skb_in ) ; struct ipcm_cookie ipc ; __be32 saddr ; u8 tos ; struct net * net ; struct sock * sk ; if ( ! rt ) goto out ; net = dev_net ( rt -> dst . dev ) ; iph = ip_hdr ( skb_in ) ; if ( ( u8 * ) iph < skb_in -> head || ( skb_in -> network_header + sizeof ( * iph ) ) > skb_in -> tail ) goto out ; if ( skb_in -> pkt_type != PACKET_HOST ) goto out ; if ( rt -> rt_flags & ( RTCF_BROADCAST | RTCF_MULTICAST ) ) goto out ; if ( iph -> frag_off & htons ( IP_OFFSET ) ) goto out ; if ( icmp_pointers [ type ] . error ) { if ( iph -> protocol == IPPROTO_ICMP ) { u8 _inner_type , * itp ; itp = skb_header_pointer ( skb_in , skb_network_header ( skb_in ) + ( iph -> ihl << 2 ) + offsetof ( struct icmphdr , type ) - skb_in -> data , sizeof ( _inner_type ) , & _inner_type ) ; if ( itp == NULL ) goto out ; if ( * itp > NR_ICMP_TYPES || icmp_pointers [ * itp ] . error ) goto out ; } } sk = icmp_xmit_lock ( net ) ; if ( sk == NULL ) return ; saddr = iph -> daddr ; if ( ! ( rt -> rt_flags & RTCF_LOCAL ) ) { struct net_device * dev = NULL ; rcu_read_lock ( ) ; if ( rt_is_input_route ( rt ) && net -> ipv4 . sysctl_icmp_errors_use_inbound_ifaddr ) dev = dev_get_by_index_rcu ( net , rt -> rt_iif ) ; if ( dev ) saddr = inet_select_addr ( dev , 0 , RT_SCOPE_LINK ) ; else saddr = 0 ; rcu_read_unlock ( ) ; } tos = icmp_pointers [ type ] . error ? ( ( iph -> tos & IPTOS_TOS_MASK ) | IPTOS_PREC_INTERNETCONTROL ) : iph -> tos ;  if ( ip_options_echo ( & icmp_param . replyopts , skb_in ) )  goto out_unlock ; icmp_param . data . icmph . type = type ; icmp_param . data . icmph . code = code ; icmp_param . data . icmph . un . gateway = info ; icmp_param . data . icmph . checksum = 0 ; icmp_param . skb = skb_in ; icmp_param . offset = skb_network_offset ( skb_in ) ; inet_sk ( sk ) -> tos = tos ; ipc . addr = iph -> saddr ;  ipc . opt = & icmp_param . replyopts ;  ipc . tx_flags = 0 ; rt = icmp_route_lookup ( net , skb_in , iph , saddr , tos , type , code , & icmp_param ) ; if ( IS_ERR ( rt ) ) goto out_unlock ; if ( ! icmpv4_xrlim_allow ( net , rt , type , code ) ) goto ende ; room = dst_mtu ( & rt -> dst ) ; if ( room > 576 ) room = 576 ;  room -= sizeof ( struct iphdr ) + icmp_param . replyopts . optlen ;  room -= sizeof ( struct icmphdr ) ; icmp_param . data_len = skb_in -> len - icmp_param . offset ; if ( icmp_param . data_len > room ) icmp_param . data_len = room ; icmp_param . head_len = sizeof ( struct icmphdr ) ; icmp_push_reply ( & icmp_param , & ipc , & rt ) ; ende : ip_rt_put ( rt ) ; out_unlock : icmp_xmit_unlock ( sk ) ; out : ; }","if ( ip_options_echo ( & icmp_param . replyopts . opt . opt , skb_in ) ) goto out_unlock ;",375
508,"buggy line: ipc . opt = & icmp_param . replyopts ;ipc . tx_flags = 0 ;room -= sizeof ( struct iphdr ) + icmp_param . replyopts . optlen ;room -= sizeof ( struct icmphdr ) ;cwe id:CWE-362context: void icmp_send ( struct sk_buff * skb_in , int type , int code , __be32 info ) { struct iphdr * iph ; int room ; struct icmp_bxm icmp_param ; struct rtable * rt = skb_rtable ( skb_in ) ; struct ipcm_cookie ipc ; __be32 saddr ; u8 tos ; struct net * net ; struct sock * sk ; if ( ! rt ) goto out ; net = dev_net ( rt -> dst . dev ) ; iph = ip_hdr ( skb_in ) ; if ( ( u8 * ) iph < skb_in -> head || ( skb_in -> network_header + sizeof ( * iph ) ) > skb_in -> tail ) goto out ; if ( skb_in -> pkt_type != PACKET_HOST ) goto out ; if ( rt -> rt_flags & ( RTCF_BROADCAST | RTCF_MULTICAST ) ) goto out ; if ( iph -> frag_off & htons ( IP_OFFSET ) ) goto out ; if ( icmp_pointers [ type ] . error ) { if ( iph -> protocol == IPPROTO_ICMP ) { u8 _inner_type , * itp ; itp = skb_header_pointer ( skb_in , skb_network_header ( skb_in ) + ( iph -> ihl << 2 ) + offsetof ( struct icmphdr , type ) - skb_in -> data , sizeof ( _inner_type ) , & _inner_type ) ; if ( itp == NULL ) goto out ; if ( * itp > NR_ICMP_TYPES || icmp_pointers [ * itp ] . error ) goto out ; } } sk = icmp_xmit_lock ( net ) ; if ( sk == NULL ) return ; saddr = iph -> daddr ; if ( ! ( rt -> rt_flags & RTCF_LOCAL ) ) { struct net_device * dev = NULL ; rcu_read_lock ( ) ; if ( rt_is_input_route ( rt ) && net -> ipv4 . sysctl_icmp_errors_use_inbound_ifaddr ) dev = dev_get_by_index_rcu ( net , rt -> rt_iif ) ; if ( dev ) saddr = inet_select_addr ( dev , 0 , RT_SCOPE_LINK ) ; else saddr = 0 ; rcu_read_unlock ( ) ; } tos = icmp_pointers [ type ] . error ? ( ( iph -> tos & IPTOS_TOS_MASK ) | IPTOS_PREC_INTERNETCONTROL ) : iph -> tos ;  if ( ip_options_echo ( & icmp_param . replyopts , skb_in ) )  goto out_unlock ; icmp_param . data . icmph . type = type ; icmp_param . data . icmph . code = code ; icmp_param . data . icmph . un . gateway = info ; icmp_param . data . icmph . checksum = 0 ; icmp_param . skb = skb_in ; icmp_param . offset = skb_network_offset ( skb_in ) ; inet_sk ( sk ) -> tos = tos ; ipc . addr = iph -> saddr ;  ipc . opt = & icmp_param . replyopts ;  ipc . tx_flags = 0 ; rt = icmp_route_lookup ( net , skb_in , iph , saddr , tos , type , code , & icmp_param ) ; if ( IS_ERR ( rt ) ) goto out_unlock ; if ( ! icmpv4_xrlim_allow ( net , rt , type , code ) ) goto ende ; room = dst_mtu ( & rt -> dst ) ; if ( room > 576 ) room = 576 ;  room -= sizeof ( struct iphdr ) + icmp_param . replyopts . optlen ;  room -= sizeof ( struct icmphdr ) ; icmp_param . data_len = skb_in -> len - icmp_param . offset ; if ( icmp_param . data_len > room ) icmp_param . data_len = room ; icmp_param . head_len = sizeof ( struct icmphdr ) ; icmp_push_reply ( & icmp_param , & ipc , & rt ) ; ende : ip_rt_put ( rt ) ; out_unlock : icmp_xmit_unlock ( sk ) ; out : ; }",ipc . opt = & icmp_param . replyopts . opt ;ipc . tx_flags = 0 ;room -= sizeof ( struct iphdr ) + icmp_param . replyopts . opt . opt . optlen ;room -= sizeof ( struct icmphdr ) ;,375
509,"buggy line: ND_TCHECK2 ( * ( p + 2 ) , 4 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>Magic-Num<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( p + 2 ) ) ) ;cwe id:CWE-125context: static int print_bacp_config_options ( netdissect_options * ndo , const u_char * p , int length ) { int len , opt ; if ( length < 2 ) return 0 ; ND_TCHECK2 ( * p , 2 ) ; len = p [ 1 ] ; opt = p [ 0 ] ; if ( length < len ) return 0 ; if ( len < 2 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>2)"" , tok2str ( bacconfopts_values , ""Unknown"" , opt ) , opt , len ) ) ; return 0 ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( bacconfopts_values , ""Unknown"" , opt ) , opt , len ) ) ; switch ( opt ) { case BACPOPT_FPEER : if ( len != 6 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>6)"" ) ) ; return len ; }  ND_TCHECK2 ( * ( p + 2 ) , 4 ) ;  ND_PRINT ( ( ndo , "":<S2SV_blank>Magic-Num<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( p + 2 ) ) ) ; break ; default : if ( ndo -> ndo_vflag < 2 ) print_unknown_data ( ndo , & p [ 2 ] , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len - 2 ) ; break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , & p [ 2 ] , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len - 2 ) ; return len ; trunc : ND_PRINT ( ( ndo , ""[|bacp]"" ) ) ; return 0 ; }","ND_TCHECK_32BITS ( p + 2 ) , 4 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>Magic-Num<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( p + 2 ) ) ) ;",376
510,"buggy line: skb_dst_drop ( skb ) ;}cwe id:CWE-476context: void ipv4_pktinfo_prepare ( const struct sock * sk , struct sk_buff * skb ) { struct in_pktinfo * pktinfo = PKTINFO_SKB_CB ( skb ) ; bool prepare = ( inet_sk ( sk ) -> cmsg_flags & IP_CMSG_PKTINFO ) || ipv6_sk_rxinfo ( sk ) ; if ( prepare && skb_rtable ( skb ) ) { if ( pktinfo -> ipi_ifindex == LOOPBACK_IFINDEX ) pktinfo -> ipi_ifindex = inet_iif ( skb ) ; pktinfo -> ipi_spec_dst . s_addr = fib_compute_spec_dst ( skb ) ; } else { pktinfo -> ipi_ifindex = 0 ; pktinfo -> ipi_spec_dst . s_addr = 0 ; }  skb_dst_drop ( skb ) ;  }",if ( unlikely ( IPCB ( skb ) -> opt . optlen ) ) skb_dst_force ( skb ) ;else skb_dst_drop ( skb ) ;},377
511,buggy line: crypto_free_skcipher ( private ) ;}cwe id:CWE-476context: static void skcipher_release ( void * private ) {  crypto_free_skcipher ( private ) ;  },struct skcipher_tfm * tfm = private ;crypto_free_skcipher ( tfm -> skcipher ) ;kfree ( tfm ) ;},378
512,"buggy line: struct inode * inode = file_inode ( bprm -> file ) ;umode_t mode = inode -> i_mode ;bprm -> cred -> euid = current_euid ( ) ;bprm -> cred -> egid = current_egid ( ) ;cwe id:CWE-362context: int prepare_binprm ( struct linux_binprm * bprm ) {  struct inode * inode = file_inode ( bprm -> file ) ;  umode_t mode = inode -> i_mode ; int retval ;  bprm -> cred -> euid = current_euid ( ) ;  bprm -> cred -> egid = current_egid ( ) ; if ( ! ( bprm -> file -> f_path . mnt -> mnt_flags & MNT_NOSUID ) && ! task_no_new_privs ( current ) && kuid_has_mapping ( bprm -> cred -> user_ns , inode -> i_uid ) && kgid_has_mapping ( bprm -> cred -> user_ns , inode -> i_gid ) ) { if ( mode & S_ISUID ) { bprm -> per_clear |= PER_CLEAR_ON_SETID ; bprm -> cred -> euid = inode -> i_uid ; } if ( ( mode & ( S_ISGID | S_IXGRP ) ) == ( S_ISGID | S_IXGRP ) ) { bprm -> per_clear |= PER_CLEAR_ON_SETID ; bprm -> cred -> egid = inode -> i_gid ; } } retval = security_bprm_set_creds ( bprm ) ; if ( retval ) return retval ; bprm -> cred_prepared = 1 ; memset ( bprm -> buf , 0 , BINPRM_BUF_SIZE ) ; return kernel_read ( bprm -> file , 0 , bprm -> buf , BINPRM_BUF_SIZE ) ; }",bprm -> cred -> euid = current_euid ( ) ;bprm -> cred -> egid = current_egid ( ) ;,379
513,"buggy line: return headcount ;err : vhost_discard_vq_desc ( vq , headcount ) ;cwe id:CWE-20context: static int get_rx_bufs ( struct vhost_virtqueue * vq , struct vring_used_elem * heads , int datalen , unsigned * iovcount , struct vhost_log * log , unsigned * log_num , unsigned int quota ) { unsigned int out , in ; int seg = 0 ; int headcount = 0 ; unsigned d ; int r , nlogs = 0 ; while ( datalen > 0 && headcount < quota ) { if ( unlikely ( seg >= UIO_MAXIOV ) ) { r = - ENOBUFS ; goto err ; } d = vhost_get_vq_desc ( vq -> dev , vq , vq -> iov + seg , ARRAY_SIZE ( vq -> iov ) - seg , & out , & in , log , log_num ) ; if ( d == vq -> num ) { r = 0 ; goto err ; } if ( unlikely ( out || in <= 0 ) ) { vq_err ( vq , ""unexpected<S2SV_blank>descriptor<S2SV_blank>format<S2SV_blank>for<S2SV_blank>RX:<S2SV_blank>"" ""out<S2SV_blank>%d,<S2SV_blank>in<S2SV_blank>%d\\n"" , out , in ) ; r = - EINVAL ; goto err ; } if ( unlikely ( log ) ) { nlogs += * log_num ; log += * log_num ; } heads [ headcount ] . id = d ; heads [ headcount ] . len = iov_length ( vq -> iov + seg , in ) ; datalen -= heads [ headcount ] . len ; ++ headcount ; seg += in ; } heads [ headcount - 1 ] . len += datalen ; * iovcount = seg ; if ( unlikely ( log ) ) * log_num = nlogs ;  return headcount ;  err : vhost_discard_vq_desc ( vq , headcount ) ; return r ; }","if ( unlikely ( datalen > 0 ) ) {r = UIO_MAXIOV + 1 ;goto err ;}return headcount ;err : vhost_discard_vq_desc ( vq , headcount ) ;",380
514,"buggy line: for ( ;* s && dlen ;s ++ ) {if ( strchr ( quote , * s ) ) {dlen -= 2 ;if ( dlen == 0 ) break ;cwe id:CWE-191context: void imap_quote_string ( char * dest , size_t dlen , const char * src , bool quote_backtick ) { const char * quote = ""`\\""\\\\"" ; if ( ! quote_backtick ) quote ++ ; char * pt = dest ; const char * s = src ; * pt ++ = \'""\' ; dlen -= 2 ; for ( ; * s && dlen ; s ++ ) { if ( strchr ( quote , * s ) ) {  dlen -= 2 ;  if ( dlen == 0 ) break ; * pt ++ = '\\\\' ; * pt ++ = * s ; } else { * pt ++ = * s ; dlen -- ; } } * pt ++ = \'""\' ; * pt = '\\0' ; }","
",381
515,"buggy line: rq = blk_mq_tag_to_rq ( tags , off + bit ) ;fn ( rq , data , reserved ) ;cwe id:CWE-362context: static void bt_tags_for_each ( struct blk_mq_tags * tags , struct blk_mq_bitmap_tags * bt , unsigned int off , busy_tag_iter_fn * fn , void * data , bool reserved ) { struct request * rq ; int bit , i ; if ( ! tags -> rqs ) return ; for ( i = 0 ; i < bt -> map_nr ; i ++ ) { struct blk_align_bitmap * bm = & bt -> map [ i ] ; for ( bit = find_first_bit ( & bm -> word , bm -> depth ) ; bit < bm -> depth ; bit = find_next_bit ( & bm -> word , bm -> depth , bit + 1 ) ) {  rq = blk_mq_tag_to_rq ( tags , off + bit ) ;  fn ( rq , data , reserved ) ; } off += ( 1 << bt -> bits_per_word ) ; } }","rq = tags -> rqs [ off + bit ) ;fn ( rq , data , reserved ) ;",382
516,"buggy line: else if ( ( flags & VPX_CODEC_USE_XMA ) && ! ( iface -> caps & VPX_CODEC_CAP_XMA ) )  res = VPX_CODEC_INCAPABLE ;cwe id:CWE-119context: vpx_codec_err_t vpx_codec_enc_init_multi_ver ( vpx_codec_ctx_t * ctx , vpx_codec_iface_t * iface , vpx_codec_enc_cfg_t * cfg , int num_enc , vpx_codec_flags_t flags , vpx_rational_t * dsf , int ver ) { vpx_codec_err_t res = VPX_CODEC_OK ; if ( ver != VPX_ENCODER_ABI_VERSION ) res = VPX_CODEC_ABI_MISMATCH ; else if ( ! ctx || ! iface || ! cfg || ( num_enc > 16 || num_enc < 1 ) ) res = VPX_CODEC_INVALID_PARAM ; else if ( iface -> abi_version != VPX_CODEC_INTERNAL_ABI_VERSION ) res = VPX_CODEC_ABI_MISMATCH ; else if ( ! ( iface -> caps & VPX_CODEC_CAP_ENCODER ) ) res = VPX_CODEC_INCAPABLE ;  else if ( ( flags & VPX_CODEC_USE_XMA ) && ! ( iface -> caps & VPX_CODEC_CAP_XMA ) )  res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_PSNR ) && ! ( iface -> caps & VPX_CODEC_CAP_PSNR ) ) res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_OUTPUT_PARTITION ) && ! ( iface -> caps & VPX_CODEC_CAP_OUTPUT_PARTITION ) ) res = VPX_CODEC_INCAPABLE ; else { int i ; void * mem_loc = NULL ; if ( ! ( res = iface -> enc . mr_get_mem_loc ( cfg , & mem_loc ) ) ) { for ( i = 0 ; i < num_enc ; i ++ ) { vpx_codec_priv_enc_mr_cfg_t mr_cfg ; if ( dsf -> num < 1 || dsf -> num > 4096 || dsf -> den < 1 || dsf -> den > dsf -> num ) { res = VPX_CODEC_INVALID_PARAM ; break ; } mr_cfg . mr_low_res_mode_info = mem_loc ; mr_cfg . mr_total_resolutions = num_enc ; mr_cfg . mr_encoder_id = num_enc - 1 - i ; mr_cfg . mr_down_sampling_factor . num = dsf -> num ; mr_cfg . mr_down_sampling_factor . den = dsf -> den ; if ( mr_cfg . mr_encoder_id ) cfg -> kf_mode = VPX_KF_DISABLED ; ctx -> iface = iface ; ctx -> name = iface -> name ; ctx -> priv = NULL ; ctx -> init_flags = flags ; ctx -> config . enc = cfg ; res = ctx -> iface -> init ( ctx , & mr_cfg ) ; if ( res ) { const char * error_detail = ctx -> priv ? ctx -> priv -> err_detail : NULL ; ctx -> err_detail = error_detail ; vpx_codec_destroy ( ctx ) ; while ( i ) { ctx -- ; ctx -> err_detail = error_detail ; vpx_codec_destroy ( ctx ) ; i -- ; } }  if ( ctx -> priv )  ctx -> priv -> iface = ctx -> iface ; if ( res ) break ; ctx ++ ; cfg ++ ; dsf ++ ; } ctx -- ; } } return SAVE_STATUS ( ctx , res ) ; }","
",383
517,"buggy line: if ( ctx -> priv )  ctx -> priv -> iface = ctx -> iface ;cwe id:CWE-119context: vpx_codec_err_t vpx_codec_enc_init_multi_ver ( vpx_codec_ctx_t * ctx , vpx_codec_iface_t * iface , vpx_codec_enc_cfg_t * cfg , int num_enc , vpx_codec_flags_t flags , vpx_rational_t * dsf , int ver ) { vpx_codec_err_t res = VPX_CODEC_OK ; if ( ver != VPX_ENCODER_ABI_VERSION ) res = VPX_CODEC_ABI_MISMATCH ; else if ( ! ctx || ! iface || ! cfg || ( num_enc > 16 || num_enc < 1 ) ) res = VPX_CODEC_INVALID_PARAM ; else if ( iface -> abi_version != VPX_CODEC_INTERNAL_ABI_VERSION ) res = VPX_CODEC_ABI_MISMATCH ; else if ( ! ( iface -> caps & VPX_CODEC_CAP_ENCODER ) ) res = VPX_CODEC_INCAPABLE ;  else if ( ( flags & VPX_CODEC_USE_XMA ) && ! ( iface -> caps & VPX_CODEC_CAP_XMA ) )  res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_PSNR ) && ! ( iface -> caps & VPX_CODEC_CAP_PSNR ) ) res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_OUTPUT_PARTITION ) && ! ( iface -> caps & VPX_CODEC_CAP_OUTPUT_PARTITION ) ) res = VPX_CODEC_INCAPABLE ; else { int i ; void * mem_loc = NULL ; if ( ! ( res = iface -> enc . mr_get_mem_loc ( cfg , & mem_loc ) ) ) { for ( i = 0 ; i < num_enc ; i ++ ) { vpx_codec_priv_enc_mr_cfg_t mr_cfg ; if ( dsf -> num < 1 || dsf -> num > 4096 || dsf -> den < 1 || dsf -> den > dsf -> num ) { res = VPX_CODEC_INVALID_PARAM ; break ; } mr_cfg . mr_low_res_mode_info = mem_loc ; mr_cfg . mr_total_resolutions = num_enc ; mr_cfg . mr_encoder_id = num_enc - 1 - i ; mr_cfg . mr_down_sampling_factor . num = dsf -> num ; mr_cfg . mr_down_sampling_factor . den = dsf -> den ; if ( mr_cfg . mr_encoder_id ) cfg -> kf_mode = VPX_KF_DISABLED ; ctx -> iface = iface ; ctx -> name = iface -> name ; ctx -> priv = NULL ; ctx -> init_flags = flags ; ctx -> config . enc = cfg ; res = ctx -> iface -> init ( ctx , & mr_cfg ) ; if ( res ) { const char * error_detail = ctx -> priv ? ctx -> priv -> err_detail : NULL ; ctx -> err_detail = error_detail ; vpx_codec_destroy ( ctx ) ; while ( i ) { ctx -- ; ctx -> err_detail = error_detail ; vpx_codec_destroy ( ctx ) ; i -- ; } }  if ( ctx -> priv )  ctx -> priv -> iface = ctx -> iface ; if ( res ) break ; ctx ++ ; cfg ++ ; dsf ++ ; } ctx -- ; } } return SAVE_STATUS ( ctx , res ) ; }","
",383
518,"buggy line: msg -> msg_namelen = 0 ;err = 0 ;cwe id:CWE-20context: static int vmci_transport_dgram_dequeue ( struct kiocb * kiocb , struct vsock_sock * vsk , struct msghdr * msg , size_t len , int flags ) { int err ; int noblock ; struct vmci_datagram * dg ; size_t payload_len ; struct sk_buff * skb ; noblock = flags & MSG_DONTWAIT ; if ( flags & MSG_OOB || flags & MSG_ERRQUEUE ) return - EOPNOTSUPP ;  msg -> msg_namelen = 0 ;  err = 0 ; skb = skb_recv_datagram ( & vsk -> sk , flags , noblock , & err ) ; if ( err ) return err ; if ( ! skb ) return - EAGAIN ; dg = ( struct vmci_datagram * ) skb -> data ; if ( ! dg ) goto out ; payload_len = dg -> payload_size ; if ( payload_len != skb -> len - sizeof ( * dg ) ) { err = - EINVAL ; goto out ; } if ( payload_len > len ) { payload_len = len ; msg -> msg_flags |= MSG_TRUNC ; } err = skb_copy_datagram_iovec ( skb , sizeof ( * dg ) , msg -> msg_iov , payload_len ) ; if ( err ) goto out ; if ( msg -> msg_name ) { struct sockaddr_vm * vm_addr ; vm_addr = ( struct sockaddr_vm * ) msg -> msg_name ; vsock_addr_init ( vm_addr , dg -> src . context , dg -> src . resource ) ; msg -> msg_namelen = sizeof ( * vm_addr ) ; } err = payload_len ; out : skb_free_datagram ( & vsk -> sk , skb ) ; return err ; }",err = 0 ;,384
519,"buggy line: if ( skb_is_nonlinear ( skb ) )  return 0 ;cwe id:CWE-189context: static u64 __skb_get_nlattr ( u64 ctx , u64 A , u64 X , u64 r4 , u64 r5 ) { struct sk_buff * skb = ( struct sk_buff * ) ( long ) ctx ; struct nlattr * nla ;  if ( skb_is_nonlinear ( skb ) )  return 0 ; if ( A > skb -> len - sizeof ( struct nlattr ) ) return 0 ; nla = nla_find ( ( struct nlattr * ) & skb -> data [ A ] , skb -> len - A , X ) ; if ( nla ) return ( void * ) nla - ( void * ) skb -> data ; return 0 ; }",if ( skb_is_nonlinear ( skb ) ) return 0 ;if ( skb -> len < sizeof ( struct nlattr ) ) return 0 ;,385
520,"buggy line: encode_share_access ( xdr , arg -> open_flags ) ;RESERVE_SPACE ( 28 ) ;cwe id:CWE-000context: static inline void encode_openhdr ( struct xdr_stream * xdr , const struct nfs_openargs * arg ) { __be32 * p ; RESERVE_SPACE ( 8 ) ; WRITE32 ( OP_OPEN ) ; WRITE32 ( arg -> seqid -> sequence -> counter ) ;  encode_share_access ( xdr , arg -> open_flags ) ;  RESERVE_SPACE ( 28 ) ; WRITE64 ( arg -> clientid ) ; WRITE32 ( 16 ) ; WRITEMEM ( ""open<S2SV_blank>id:"" , 8 ) ; WRITE64 ( arg -> id ) ; }","encode_share_access ( xdr , arg -> fmode ) ;RESERVE_SPACE ( 28 ) ;",386
521,"buggy line: if ( ! gre_sre_print ( ndo , af , sreoff , srelen , bp , len ) ) goto trunc ;cwe id:CWE-125context: static void gre_print_0 ( netdissect_options * ndo , const u_char * bp , u_int length ) { u_int len = length ; uint16_t flags , prot ; flags = EXTRACT_16BITS ( bp ) ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s]"" , bittok2str ( gre_flag_values , ""none"" , flags ) ) ) ; len -= 2 ; bp += 2 ; ND_TCHECK2 ( * bp , 2 ) ; if ( len < 2 ) goto trunc ; prot = EXTRACT_16BITS ( bp ) ; len -= 2 ; bp += 2 ; if ( ( flags & GRE_CP ) | ( flags & GRE_RP ) ) { ND_TCHECK2 ( * bp , 2 ) ; if ( len < 2 ) goto trunc ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>sum<S2SV_blank>0x%x"" , EXTRACT_16BITS ( bp ) ) ) ; bp += 2 ; len -= 2 ; ND_TCHECK2 ( * bp , 2 ) ; if ( len < 2 ) goto trunc ; ND_PRINT ( ( ndo , "",<S2SV_blank>off<S2SV_blank>0x%x"" , EXTRACT_16BITS ( bp ) ) ) ; bp += 2 ; len -= 2 ; } if ( flags & GRE_KP ) { ND_TCHECK2 ( * bp , 4 ) ; if ( len < 4 ) goto trunc ; ND_PRINT ( ( ndo , "",<S2SV_blank>key=0x%x"" , EXTRACT_32BITS ( bp ) ) ) ; bp += 4 ; len -= 4 ; } if ( flags & GRE_SP ) { ND_TCHECK2 ( * bp , 4 ) ; if ( len < 4 ) goto trunc ; ND_PRINT ( ( ndo , "",<S2SV_blank>seq<S2SV_blank>%u"" , EXTRACT_32BITS ( bp ) ) ) ; bp += 4 ; len -= 4 ; } if ( flags & GRE_RP ) { for ( ; ; ) { uint16_t af ; uint8_t sreoff ; uint8_t srelen ; ND_TCHECK2 ( * bp , 4 ) ; if ( len < 4 ) goto trunc ; af = EXTRACT_16BITS ( bp ) ; sreoff = * ( bp + 2 ) ; srelen = * ( bp + 3 ) ; bp += 4 ; len -= 4 ; if ( af == 0 && srelen == 0 ) break ; if ( ! gre_sre_print ( ndo , af , sreoff , srelen , bp , len ) ) goto trunc ; if ( len < srelen ) goto trunc ; bp += srelen ; len -= srelen ; } } if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>proto<S2SV_blank>%s<S2SV_blank>(0x%04x)"" , tok2str ( ethertype_values , ""unknown"" , prot ) , prot ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>length<S2SV_blank>%u"" , length ) ) ; if ( ndo -> ndo_vflag < 1 ) ND_PRINT ( ( ndo , "":<S2SV_blank>"" ) ) ; else ND_PRINT ( ( ndo , ""\\n\\t"" ) ) ; switch ( prot ) { case ETHERTYPE_IP : ip_print ( ndo , bp , len ) ; break ; case ETHERTYPE_IPV6 : ip6_print ( ndo , bp , len ) ; break ; case ETHERTYPE_MPLS : mpls_print ( ndo , bp , len ) ; break ; case ETHERTYPE_IPX : ipx_print ( ndo , bp , len ) ; break ; case ETHERTYPE_ATALK : atalk_print ( ndo , bp , len ) ; break ; case ETHERTYPE_GRE_ISO :  isoclns_print ( ndo , bp , len , ndo -> ndo_snapend - bp ) ;  break ; case ETHERTYPE_TEB : ether_print ( ndo , bp , len , ndo -> ndo_snapend - bp , NULL , NULL ) ; break ; default : ND_PRINT ( ( ndo , ""gre-proto-0x%x"" , prot ) ) ; } return ; trunc : ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; }","if ( ! gre_sre_print ( ndo , af , sreoff , srelen , bp , len ) ;break ;case ETHERTYPE_TEB : ether_print ( ndo , bp , len ) ) goto trunc ;",387
522,"buggy line: case ETHERTYPE_GRE_ISO :  isoclns_print ( ndo , bp , len , ndo -> ndo_snapend - bp ) ;break ;case ETHERTYPE_TEB : ether_print ( ndo , bp , len , ndo -> ndo_snapend - bp , NULL , NULL ) ;cwe id:CWE-125context: static void gre_print_0 ( netdissect_options * ndo , const u_char * bp , u_int length ) { u_int len = length ; uint16_t flags , prot ; flags = EXTRACT_16BITS ( bp ) ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s]"" , bittok2str ( gre_flag_values , ""none"" , flags ) ) ) ; len -= 2 ; bp += 2 ; ND_TCHECK2 ( * bp , 2 ) ; if ( len < 2 ) goto trunc ; prot = EXTRACT_16BITS ( bp ) ; len -= 2 ; bp += 2 ; if ( ( flags & GRE_CP ) | ( flags & GRE_RP ) ) { ND_TCHECK2 ( * bp , 2 ) ; if ( len < 2 ) goto trunc ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>sum<S2SV_blank>0x%x"" , EXTRACT_16BITS ( bp ) ) ) ; bp += 2 ; len -= 2 ; ND_TCHECK2 ( * bp , 2 ) ; if ( len < 2 ) goto trunc ; ND_PRINT ( ( ndo , "",<S2SV_blank>off<S2SV_blank>0x%x"" , EXTRACT_16BITS ( bp ) ) ) ; bp += 2 ; len -= 2 ; } if ( flags & GRE_KP ) { ND_TCHECK2 ( * bp , 4 ) ; if ( len < 4 ) goto trunc ; ND_PRINT ( ( ndo , "",<S2SV_blank>key=0x%x"" , EXTRACT_32BITS ( bp ) ) ) ; bp += 4 ; len -= 4 ; } if ( flags & GRE_SP ) { ND_TCHECK2 ( * bp , 4 ) ; if ( len < 4 ) goto trunc ; ND_PRINT ( ( ndo , "",<S2SV_blank>seq<S2SV_blank>%u"" , EXTRACT_32BITS ( bp ) ) ) ; bp += 4 ; len -= 4 ; } if ( flags & GRE_RP ) { for ( ; ; ) { uint16_t af ; uint8_t sreoff ; uint8_t srelen ; ND_TCHECK2 ( * bp , 4 ) ; if ( len < 4 ) goto trunc ; af = EXTRACT_16BITS ( bp ) ; sreoff = * ( bp + 2 ) ; srelen = * ( bp + 3 ) ; bp += 4 ; len -= 4 ; if ( af == 0 && srelen == 0 ) break ; if ( ! gre_sre_print ( ndo , af , sreoff , srelen , bp , len ) ) goto trunc ; if ( len < srelen ) goto trunc ; bp += srelen ; len -= srelen ; } } if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>proto<S2SV_blank>%s<S2SV_blank>(0x%04x)"" , tok2str ( ethertype_values , ""unknown"" , prot ) , prot ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>length<S2SV_blank>%u"" , length ) ) ; if ( ndo -> ndo_vflag < 1 ) ND_PRINT ( ( ndo , "":<S2SV_blank>"" ) ) ; else ND_PRINT ( ( ndo , ""\\n\\t"" ) ) ; switch ( prot ) { case ETHERTYPE_IP : ip_print ( ndo , bp , len ) ; break ; case ETHERTYPE_IPV6 : ip6_print ( ndo , bp , len ) ; break ; case ETHERTYPE_MPLS : mpls_print ( ndo , bp , len ) ; break ; case ETHERTYPE_IPX : ipx_print ( ndo , bp , len ) ; break ; case ETHERTYPE_ATALK : atalk_print ( ndo , bp , len ) ; break ; case ETHERTYPE_GRE_ISO :  isoclns_print ( ndo , bp , len , ndo -> ndo_snapend - bp ) ;  break ; case ETHERTYPE_TEB : ether_print ( ndo , bp , len , ndo -> ndo_snapend - bp , NULL , NULL ) ; break ; default : ND_PRINT ( ( ndo , ""gre-proto-0x%x"" , prot ) ) ; } return ; trunc : ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; }","case ETHERTYPE_GRE_ISO : isoclns_print ( ndo , bp , len , ndo -> ndo_snapend - bp , NULL , NULL ) ;",387
523,"buggy line: tilebuf = _TIFFmalloc ( tile_buffsize ) ;if ( tilebuf == 0 )  return 0 ;dst_rowsize = ( ( imagewidth * bps * spp ) + 7 ) / 8 ;cwe id:CWE-119context: static int readContigTilesIntoBuffer ( TIFF * in , uint8 * buf , uint32 imagelength , uint32 imagewidth , uint32 tw , uint32 tl , tsample_t spp , uint16 bps ) { int status = 1 ; tsample_t sample = 0 ; tsample_t count = spp ; uint32 row , col , trow ; uint32 nrow , ncol ; uint32 dst_rowsize , shift_width ; uint32 bytes_per_sample , bytes_per_pixel ; uint32 trailing_bits , prev_trailing_bits ; uint32 tile_rowsize = TIFFTileRowSize ( in ) ; uint32 src_offset , dst_offset ; uint32 row_offset , col_offset ; uint8 * bufp = ( uint8 * ) buf ; unsigned char * src = NULL ; unsigned char * dst = NULL ; tsize_t tbytes = 0 , tile_buffsize = 0 ; tsize_t tilesize = TIFFTileSize ( in ) ; unsigned char * tilebuf = NULL ; bytes_per_sample = ( bps + 7 ) / 8 ; bytes_per_pixel = ( ( bps * spp ) + 7 ) / 8 ; if ( ( bps % 8 ) == 0 ) shift_width = 0 ; else { if ( bytes_per_pixel < ( bytes_per_sample + 1 ) ) shift_width = bytes_per_pixel ; else shift_width = bytes_per_sample + 1 ; } tile_buffsize = tilesize ; if ( tilesize == 0 || tile_rowsize == 0 ) { TIFFError ( ""readContigTilesIntoBuffer"" , ""Tile<S2SV_blank>size<S2SV_blank>or<S2SV_blank>tile<S2SV_blank>rowsize<S2SV_blank>is<S2SV_blank>zero"" ) ; exit ( - 1 ) ; } if ( tilesize < ( tsize_t ) ( tl * tile_rowsize ) ) { # ifdef DEBUG2 TIFFError ( ""readContigTilesIntoBuffer"" , ""Tilesize<S2SV_blank>%lu<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small,<S2SV_blank>using<S2SV_blank>alternate<S2SV_blank>calculation<S2SV_blank>%u"" , tilesize , tl * tile_rowsize ) ; # endif tile_buffsize = tl * tile_rowsize ; if ( tl != ( tile_buffsize / tile_rowsize ) ) { TIFFError ( ""readContigTilesIntoBuffer"" , ""Integer<S2SV_blank>overflow<S2SV_blank>when<S2SV_blank>calculating<S2SV_blank>buffer<S2SV_blank>size."" ) ; exit ( - 1 ) ; } }  tilebuf = _TIFFmalloc ( tile_buffsize ) ;  if ( tilebuf == 0 )  return 0 ;  dst_rowsize = ( ( imagewidth * bps * spp ) + 7 ) / 8 ; for ( row = 0 ; row < imagelength ; row += tl ) { nrow = ( row + tl > imagelength ) ? imagelength - row : tl ; for ( col = 0 ; col < imagewidth ; col += tw ) { tbytes = TIFFReadTile ( in , tilebuf , col , row , 0 , 0 ) ; if ( tbytes < tilesize && ! ignore ) { TIFFError ( TIFFFileName ( in ) , ""Error,<S2SV_blank>can\'t<S2SV_blank>read<S2SV_blank>tile<S2SV_blank>at<S2SV_blank>row<S2SV_blank>%lu<S2SV_blank>col<S2SV_blank>%lu,<S2SV_blank>Read<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>%lu"" , ( unsigned long ) col , ( unsigned long ) row , ( unsigned long ) tbytes , ( unsigned long ) tilesize ) ; status = 0 ; _TIFFfree ( tilebuf ) ; return status ; } row_offset = row * dst_rowsize ; col_offset = ( ( col * bps * spp ) + 7 ) / 8 ; bufp = buf + row_offset + col_offset ; if ( col + tw > imagewidth ) ncol = imagewidth - col ; else ncol = tw ; if ( ( ( bps % 8 ) == 0 ) && ( count == spp ) ) { for ( trow = 0 ; trow < nrow ; trow ++ ) { src_offset = trow * tile_rowsize ; _TIFFmemcpy ( bufp , tilebuf + src_offset , ( ncol * spp * bps ) / 8 ) ; bufp += ( imagewidth * bps * spp ) / 8 ; } } else { prev_trailing_bits = trailing_bits = 0 ; trailing_bits = ( ncol * bps * spp ) % 8 ; for ( trow = 0 ; trow < nrow ; trow ++ ) { src_offset = trow * tile_rowsize ; src = tilebuf + src_offset ; dst_offset = ( row + trow ) * dst_rowsize ; dst = buf + dst_offset + col_offset ; switch ( shift_width ) { case 0 : if ( extractContigSamplesBytes ( src , dst , ncol , sample , spp , bps , count , 0 , ncol ) ) { TIFFError ( ""readContigTilesIntoBuffer"" , ""Unable<S2SV_blank>to<S2SV_blank>extract<S2SV_blank>row<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>tile<S2SV_blank>%lu"" , row , ( unsigned long ) TIFFCurrentTile ( in ) ) ; return 1 ; } break ; case 1 : if ( bps == 1 ) { if ( extractContigSamplesShifted8bits ( src , dst , ncol , sample , spp , bps , count , 0 , ncol , prev_trailing_bits ) ) { TIFFError ( ""readContigTilesIntoBuffer"" , ""Unable<S2SV_blank>to<S2SV_blank>extract<S2SV_blank>row<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>tile<S2SV_blank>%lu"" , row , ( unsigned long ) TIFFCurrentTile ( in ) ) ; return 1 ; } break ; } else if ( extractContigSamplesShifted16bits ( src , dst , ncol , sample , spp , bps , count , 0 , ncol , prev_trailing_bits ) ) { TIFFError ( ""readContigTilesIntoBuffer"" , ""Unable<S2SV_blank>to<S2SV_blank>extract<S2SV_blank>row<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>tile<S2SV_blank>%lu"" , row , ( unsigned long ) TIFFCurrentTile ( in ) ) ; return 1 ; } break ; case 2 : if ( extractContigSamplesShifted24bits ( src , dst , ncol , sample , spp , bps , count , 0 , ncol , prev_trailing_bits ) ) { TIFFError ( ""readContigTilesIntoBuffer"" , ""Unable<S2SV_blank>to<S2SV_blank>extract<S2SV_blank>row<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>tile<S2SV_blank>%lu"" , row , ( unsigned long ) TIFFCurrentTile ( in ) ) ; return 1 ; } break ; case 3 : case 4 : case 5 : if ( extractContigSamplesShifted32bits ( src , dst , ncol , sample , spp , bps , count , 0 , ncol , prev_trailing_bits ) ) { TIFFError ( ""readContigTilesIntoBuffer"" , ""Unable<S2SV_blank>to<S2SV_blank>extract<S2SV_blank>row<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>tile<S2SV_blank>%lu"" , row , ( unsigned long ) TIFFCurrentTile ( in ) ) ; return 1 ; } break ; default : TIFFError ( ""readContigTilesIntoBuffer"" , ""Unsupported<S2SV_blank>bit<S2SV_blank>depth<S2SV_blank>%d"" , bps ) ; return 1 ; } } prev_trailing_bits += trailing_bits ; } } } _TIFFfree ( tilebuf ) ; return status ; }","if ( tile_buffsize > 0xFFFFFFFFU - 3 ) {TIFFError ( ""readContigTilesIntoBuffer"" , ""Integer<S2SV_blank>overflow<S2SV_blank>when<S2SV_blank>calculating<S2SV_blank>buffer<S2SV_blank>size."" ) ;exit ( - 1 ) ;}tilebuf = _TIFFmalloc ( tile_buffsize + 3 ) ;if ( tilebuf == 0 ) return 0 ;tilebuf [ tile_buffsize ] = 0 ;tilebuf [ tile_buffsize + 1 ] = 0 ;tilebuf [ tile_buffsize + 2 ] = 0 ;dst_rowsize = ( ( imagewidth * bps * spp ) + 7 ) / 8 ;",388
524,"buggy line: int fd = open ( optarg , O_WRONLY | O_APPEND | O_CREAT , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ;if ( fd == - 1 ) {cwe id:CWE-59context: static bool parse_cmdline ( int argc , char * * argv ) { int c ; bool reopen_log = false ; int signum ; struct utsname uname_buf ; int longindex ; int curind ; bool bad_option = false ; unsigned facility ; mode_t new_umask_val ; struct option long_options [ ] = { { ""use-file"" , required_argument , NULL , 'f' } , # if defined _WITH_VRRP_ && defined _WITH_LVS_ { ""vrrp"" , no_argument , NULL , 'P' } , { ""check"" , no_argument , NULL , 'C' } , # endif # ifdef _WITH_BFD_ { ""no_bfd"" , no_argument , NULL , 'B' } , # endif { ""all"" , no_argument , NULL , 3 } , { ""log-console"" , no_argument , NULL , 'l' } , { ""log-detail"" , no_argument , NULL , 'D' } , { ""log-facility"" , required_argument , NULL , 'S' } , { ""log-file"" , optional_argument , NULL , 'g' } , { ""flush-log-file"" , no_argument , NULL , 2 } , { ""no-syslog"" , no_argument , NULL , 'G' } , { ""umask"" , required_argument , NULL , 'u' } , # ifdef _WITH_VRRP_ { ""release-vips"" , no_argument , NULL , 'X' } , { ""dont-release-vrrp"" , no_argument , NULL , 'V' } , # endif # ifdef _WITH_LVS_ { ""dont-release-ipvs"" , no_argument , NULL , 'I' } , # endif { ""dont-respawn"" , no_argument , NULL , 'R' } , { ""dont-fork"" , no_argument , NULL , 'n' } , { ""dump-conf"" , no_argument , NULL , 'd' } , { ""pid"" , required_argument , NULL , 'p' } , # ifdef _WITH_VRRP_ { ""vrrp_pid"" , required_argument , NULL , 'r' } , # endif # ifdef _WITH_LVS_ { ""checkers_pid"" , required_argument , NULL , 'c' } , { ""address-monitoring"" , no_argument , NULL , 'a' } , # endif # ifdef _WITH_BFD_ { ""bfd_pid"" , required_argument , NULL , 'b' } , # endif # ifdef _WITH_SNMP_ { ""snmp"" , no_argument , NULL , 'x' } , { ""snmp-agent-socket"" , required_argument , NULL , 'A' } , # endif { ""core-dump"" , no_argument , NULL , 'm' } , { ""core-dump-pattern"" , optional_argument , NULL , 'M' } , # ifdef _MEM_CHECK_LOG_ { ""mem-check-log"" , no_argument , NULL , 'L' } , # endif # if HAVE_DECL_CLONE_NEWNET { ""namespace"" , required_argument , NULL , 's' } , # endif { ""config-id"" , required_argument , NULL , 'i' } , { ""signum"" , required_argument , NULL , 4 } , { ""config-test"" , optional_argument , NULL , 't' } , # ifdef _WITH_PERF_ { ""perf"" , optional_argument , NULL , 5 } , # endif # ifdef WITH_DEBUG_OPTIONS { ""debug"" , optional_argument , NULL , 6 } , # endif { ""version"" , no_argument , NULL , 'v' } , { ""help"" , no_argument , NULL , 'h' } , { NULL , 0 , NULL , 0 } } ; curind = optind ; while ( longindex = - 1 , ( c = getopt_long ( argc , argv , "":vhlndu:DRS:f:p:i:mM::g::Gt::"" # if defined _WITH_VRRP_ && defined _WITH_LVS_ ""PC"" # endif # ifdef _WITH_VRRP_ ""r:VX"" # endif # ifdef _WITH_LVS_ ""ac:I"" # endif # ifdef _WITH_BFD_ ""Bb:"" # endif # ifdef _WITH_SNMP_ ""xA:"" # endif # ifdef _MEM_CHECK_LOG_ ""L"" # endif # if HAVE_DECL_CLONE_NEWNET ""s:"" # endif , long_options , & longindex ) ) != - 1 ) { if ( longindex >= 0 && long_options [ longindex ] . has_arg == required_argument && optarg && ! optarg [ 0 ] ) { c = ':' ; optarg = NULL ; } switch ( c ) { case 'v' : fprintf ( stderr , ""%s"" , version_string ) ; # ifdef GIT_COMMIT fprintf ( stderr , "",<S2SV_blank>git<S2SV_blank>commit<S2SV_blank>%s"" , GIT_COMMIT ) ; # endif fprintf ( stderr , ""\\n\\n%s\\n\\n"" , COPYRIGHT_STRING ) ; fprintf ( stderr , ""Built<S2SV_blank>with<S2SV_blank>kernel<S2SV_blank>headers<S2SV_blank>for<S2SV_blank>Linux<S2SV_blank>%d.%d.%d\\n"" , ( LINUX_VERSION_CODE >> 16 ) & 0xff , ( LINUX_VERSION_CODE >> 8 ) & 0xff , ( LINUX_VERSION_CODE ) & 0xff ) ; uname ( & uname_buf ) ; fprintf ( stderr , ""Running<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>%s\\n\\n"" , uname_buf . sysname , uname_buf . release , uname_buf . version ) ; fprintf ( stderr , ""configure<S2SV_blank>options:<S2SV_blank>%s\\n\\n"" , KEEPALIVED_CONFIGURE_OPTIONS ) ; fprintf ( stderr , ""Config<S2SV_blank>options:<S2SV_blank>%s\\n\\n"" , CONFIGURATION_OPTIONS ) ; fprintf ( stderr , ""System<S2SV_blank>options:<S2SV_blank>%s\\n"" , SYSTEM_OPTIONS ) ; exit ( 0 ) ; break ; case 'h' : usage ( argv [ 0 ] ) ; exit ( 0 ) ; break ; case 'l' : __set_bit ( LOG_CONSOLE_BIT , & debug ) ; reopen_log = true ; break ; case 'n' : __set_bit ( DONT_FORK_BIT , & debug ) ; break ; case 'd' : __set_bit ( DUMP_CONF_BIT , & debug ) ; break ; # ifdef _WITH_VRRP_ case 'V' : __set_bit ( DONT_RELEASE_VRRP_BIT , & debug ) ; break ; # endif # ifdef _WITH_LVS_ case 'I' : __set_bit ( DONT_RELEASE_IPVS_BIT , & debug ) ; break ; # endif case 'D' : if ( __test_bit ( LOG_DETAIL_BIT , & debug ) ) __set_bit ( LOG_EXTRA_DETAIL_BIT , & debug ) ; else __set_bit ( LOG_DETAIL_BIT , & debug ) ; break ; case 'R' : __set_bit ( DONT_RESPAWN_BIT , & debug ) ; break ; # ifdef _WITH_VRRP_ case 'X' : __set_bit ( RELEASE_VIPS_BIT , & debug ) ; break ; # endif case 'S' : if ( ! read_unsigned ( optarg , & facility , 0 , LOG_FACILITY_MAX , false ) ) fprintf ( stderr , ""Invalid<S2SV_blank>log<S2SV_blank>facility<S2SV_blank>\'%s\'\\n"" , optarg ) ; else { log_facility = LOG_FACILITY [ facility ] . facility ; reopen_log = true ; } break ; case 'g' : if ( optarg && optarg [ 0 ] ) log_file_name = optarg ; else log_file_name = ""/tmp/keepalived.log"" ; open_log_file ( log_file_name , NULL , NULL , NULL ) ; break ; case 'G' : __set_bit ( NO_SYSLOG_BIT , & debug ) ; reopen_log = true ; break ; case 'u' : new_umask_val = set_umask ( optarg ) ; if ( umask_cmdline ) umask_val = new_umask_val ; break ; case 't' : __set_bit ( CONFIG_TEST_BIT , & debug ) ; __set_bit ( DONT_RESPAWN_BIT , & debug ) ; __set_bit ( DONT_FORK_BIT , & debug ) ; __set_bit ( NO_SYSLOG_BIT , & debug ) ; if ( optarg && optarg [ 0 ] ) {  int fd = open ( optarg , O_WRONLY | O_APPEND | O_CREAT , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ;  if ( fd == - 1 ) { fprintf ( stderr , ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>config-test<S2SV_blank>log<S2SV_blank>file<S2SV_blank>%s\\n"" , optarg ) ; exit ( EXIT_FAILURE ) ; } dup2 ( fd , STDERR_FILENO ) ; close ( fd ) ; } break ; case 'f' : conf_file = optarg ; break ; case 2 : set_flush_log_file ( ) ; break ; # if defined _WITH_VRRP_ && defined _WITH_LVS_ case 'P' : __clear_bit ( DAEMON_CHECKERS , & daemon_mode ) ; break ; case 'C' : __clear_bit ( DAEMON_VRRP , & daemon_mode ) ; break ; # endif # ifdef _WITH_BFD_ case 'B' : __clear_bit ( DAEMON_BFD , & daemon_mode ) ; break ; # endif case 'p' : main_pidfile = optarg ; break ; # ifdef _WITH_LVS_ case 'c' : checkers_pidfile = optarg ; break ; case 'a' : __set_bit ( LOG_ADDRESS_CHANGES , & debug ) ; break ; # endif # ifdef _WITH_VRRP_ case 'r' : vrrp_pidfile = optarg ; break ; # endif # ifdef _WITH_BFD_ case 'b' : bfd_pidfile = optarg ; break ; # endif # ifdef _WITH_SNMP_ case 'x' : snmp = 1 ; break ; case 'A' : snmp_socket = optarg ; break ; # endif case 'M' : set_core_dump_pattern = true ; if ( optarg && optarg [ 0 ] ) core_dump_pattern = optarg ; case 'm' : create_core_dump = true ; break ; # ifdef _MEM_CHECK_LOG_ case 'L' : __set_bit ( MEM_CHECK_LOG_BIT , & debug ) ; break ; # endif # if HAVE_DECL_CLONE_NEWNET case 's' : override_namespace = MALLOC ( strlen ( optarg ) + 1 ) ; strcpy ( override_namespace , optarg ) ; break ; # endif case 'i' : FREE_PTR ( config_id ) ; config_id = MALLOC ( strlen ( optarg ) + 1 ) ; strcpy ( config_id , optarg ) ; break ; case 4 : signum = get_signum ( optarg ) ; if ( signum == - 1 ) { fprintf ( stderr , ""Unknown<S2SV_blank>sigfunc<S2SV_blank>%s\\n"" , optarg ) ; exit ( 1 ) ; } printf ( ""%d\\n"" , signum ) ; exit ( 0 ) ; break ; case 3 : __set_bit ( RUN_ALL_CHILDREN , & daemon_mode ) ; # ifdef _WITH_VRRP_ __set_bit ( DAEMON_VRRP , & daemon_mode ) ; # endif # ifdef _WITH_LVS_ __set_bit ( DAEMON_CHECKERS , & daemon_mode ) ; # endif # ifdef _WITH_BFD_ __set_bit ( DAEMON_BFD , & daemon_mode ) ; # endif break ; # ifdef _WITH_PERF_ case 5 : if ( optarg && optarg [ 0 ] ) { if ( ! strcmp ( optarg , ""run"" ) ) perf_run = PERF_RUN ; else if ( ! strcmp ( optarg , ""all"" ) ) perf_run = PERF_ALL ; else if ( ! strcmp ( optarg , ""end"" ) ) perf_run = PERF_END ; else log_message ( LOG_INFO , ""Unknown<S2SV_blank>perf<S2SV_blank>start<S2SV_blank>point<S2SV_blank>%s"" , optarg ) ; } else perf_run = PERF_RUN ; break ; # endif # ifdef WITH_DEBUG_OPTIONS case 6 : set_debug_options ( optarg && optarg [ 0 ] ? optarg : NULL ) ; break ; # endif case '?' : if ( optopt && argv [ curind ] [ 1 ] != '-' ) fprintf ( stderr , ""Unknown<S2SV_blank>option<S2SV_blank>-%c\\n"" , optopt ) ; else fprintf ( stderr , ""Unknown<S2SV_blank>option<S2SV_blank>%s\\n"" , argv [ curind ] ) ; bad_option = true ; break ; case ':' : if ( optopt && argv [ curind ] [ 1 ] != '-' ) fprintf ( stderr , ""Missing<S2SV_blank>parameter<S2SV_blank>for<S2SV_blank>option<S2SV_blank>-%c\\n"" , optopt ) ; else fprintf ( stderr , ""Missing<S2SV_blank>parameter<S2SV_blank>for<S2SV_blank>option<S2SV_blank>--%s\\n"" , long_options [ longindex ] . name ) ; bad_option = true ; break ; default : exit ( 1 ) ; break ; } curind = optind ; } if ( optind < argc ) { printf ( ""Unexpected<S2SV_blank>argument(s):<S2SV_blank>"" ) ; while ( optind < argc ) printf ( ""%s<S2SV_blank>"" , argv [ optind ++ ] ) ; printf ( ""\\n"" ) ; } if ( bad_option ) exit ( 1 ) ; return reopen_log ; }","int fd = open ( optarg , O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ;if ( fd == - 1 ) {",389
525,"buggy line: static void  modify_bar_registration ( struct pci_vdev * dev , int idx , int registration ) {return ;}cwe id:CWE-617context:  static void  modify_bar_registration ( struct pci_vdev * dev , int idx , int registration ) { int error ; struct inout_port iop ; struct mem_range mr ; if ( is_pci_gvt ( dev ) ) { printf ( ""modify_bar_registration:<S2SV_blank>bypass<S2SV_blank>for<S2SV_blank>pci-gvt\\n"" ) ;  return ;  } switch ( dev -> bar [ idx ] . type ) { case PCIBAR_IO : bzero ( & iop , sizeof ( struct inout_port ) ) ; iop . name = dev -> name ; iop . port = dev -> bar [ idx ] . addr ; iop . size = dev -> bar [ idx ] . size ; if ( registration ) { iop . flags = IOPORT_F_INOUT ; iop . handler = pci_emul_io_handler ; iop . arg = dev ; error = register_inout ( & iop ) ; } else error = unregister_inout ( & iop ) ; break ; case PCIBAR_MEM32 : case PCIBAR_MEM64 : bzero ( & mr , sizeof ( struct mem_range ) ) ; mr . name = dev -> name ; mr . base = dev -> bar [ idx ] . addr ; mr . size = dev -> bar [ idx ] . size ; if ( registration ) { mr . flags = MEM_F_RW ; mr . handler = pci_emul_mem_handler ; mr . arg1 = dev ; mr . arg2 = idx ; error = register_mem ( & mr ) ; } else error = unregister_mem ( & mr ) ; break ; default : error = EINVAL ; break ; }  assert ( error == 0 ) ;  }","static int modify_bar_registration ( struct pci_vdev * dev , int idx , int registration ) {return 0 ;}",390
526,"buggy line: assert ( error == 0 ) ;}cwe id:CWE-617context:  static void  modify_bar_registration ( struct pci_vdev * dev , int idx , int registration ) { int error ; struct inout_port iop ; struct mem_range mr ; if ( is_pci_gvt ( dev ) ) { printf ( ""modify_bar_registration:<S2SV_blank>bypass<S2SV_blank>for<S2SV_blank>pci-gvt\\n"" ) ;  return ;  } switch ( dev -> bar [ idx ] . type ) { case PCIBAR_IO : bzero ( & iop , sizeof ( struct inout_port ) ) ; iop . name = dev -> name ; iop . port = dev -> bar [ idx ] . addr ; iop . size = dev -> bar [ idx ] . size ; if ( registration ) { iop . flags = IOPORT_F_INOUT ; iop . handler = pci_emul_io_handler ; iop . arg = dev ; error = register_inout ( & iop ) ; } else error = unregister_inout ( & iop ) ; break ; case PCIBAR_MEM32 : case PCIBAR_MEM64 : bzero ( & mr , sizeof ( struct mem_range ) ) ; mr . name = dev -> name ; mr . base = dev -> bar [ idx ] . addr ; mr . size = dev -> bar [ idx ] . size ; if ( registration ) { mr . flags = MEM_F_RW ; mr . handler = pci_emul_mem_handler ; mr . arg1 = dev ; mr . arg2 = idx ; error = register_mem ( & mr ) ; } else error = unregister_mem ( & mr ) ; break ; default : error = EINVAL ; break ; }  assert ( error == 0 ) ;  }",return error ;},390
527,"buggy line: struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ;unsigned long tmp ;if ( tmp && tmp == cluster -> cl_has_local &&  cluster -> cl_local_node != node -> nd_num )  return - EBUSY ;if ( tmp && ! cluster -> cl_has_local ) {ret = o2net_start_listening ( node ) ;if ( ret )  return ret ;}cwe id:CWE-476context: static ssize_t o2nm_node_local_store ( struct config_item * item , const char * page , size_t count ) { struct o2nm_node * node = to_o2nm_node ( item ) ;  struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ;  unsigned long tmp ; char * p = ( char * ) page ; ssize_t ret ; tmp = simple_strtoul ( p , & p , 0 ) ; if ( ! p || ( * p && ( * p != '\\n' ) ) ) return - EINVAL ; tmp = ! ! tmp ; if ( ! test_bit ( O2NM_NODE_ATTR_ADDRESS , & node -> nd_set_attributes ) || ! test_bit ( O2NM_NODE_ATTR_NUM , & node -> nd_set_attributes ) || ! test_bit ( O2NM_NODE_ATTR_PORT , & node -> nd_set_attributes ) ) return - EINVAL ;  if ( tmp && tmp == cluster -> cl_has_local &&  cluster -> cl_local_node != node -> nd_num )  return - EBUSY ;   if ( tmp && ! cluster -> cl_has_local ) {  ret = o2net_start_listening ( node ) ; if ( ret )  return ret ;  } if ( ! tmp && cluster -> cl_has_local && cluster -> cl_local_node == node -> nd_num ) { o2net_stop_listening ( node ) ; cluster -> cl_local_node = O2NM_INVALID_NODE_NUM ; } node -> nd_local = tmp ; if ( node -> nd_local ) { cluster -> cl_has_local = tmp ; cluster -> cl_local_node = node -> nd_num ; }  return count ;  }",struct o2nm_cluster * cluster ;unsigned long tmp ;o2nm_lock_subsystem ( ) ;cluster = to_o2nm_cluster_from_node ( node ) ;if ( ! cluster ) {ret = - EINVAL ;goto out ;}if ( tmp && tmp == cluster -> cl_has_local && cluster -> cl_local_node != node -> nd_num ) {ret = - EBUSY ;goto out ;}if ( tmp && ! cluster -> cl_has_local ) {ret = o2net_start_listening ( node ) ;if ( ret ) goto out ;},391
528,"buggy line: return count ;}cwe id:CWE-476context: static ssize_t o2nm_node_local_store ( struct config_item * item , const char * page , size_t count ) { struct o2nm_node * node = to_o2nm_node ( item ) ;  struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ;  unsigned long tmp ; char * p = ( char * ) page ; ssize_t ret ; tmp = simple_strtoul ( p , & p , 0 ) ; if ( ! p || ( * p && ( * p != '\\n' ) ) ) return - EINVAL ; tmp = ! ! tmp ; if ( ! test_bit ( O2NM_NODE_ATTR_ADDRESS , & node -> nd_set_attributes ) || ! test_bit ( O2NM_NODE_ATTR_NUM , & node -> nd_set_attributes ) || ! test_bit ( O2NM_NODE_ATTR_PORT , & node -> nd_set_attributes ) ) return - EINVAL ;  if ( tmp && tmp == cluster -> cl_has_local &&  cluster -> cl_local_node != node -> nd_num )  return - EBUSY ;   if ( tmp && ! cluster -> cl_has_local ) {  ret = o2net_start_listening ( node ) ; if ( ret )  return ret ;  } if ( ! tmp && cluster -> cl_has_local && cluster -> cl_local_node == node -> nd_num ) { o2net_stop_listening ( node ) ; cluster -> cl_local_node = O2NM_INVALID_NODE_NUM ; } node -> nd_local = tmp ; if ( node -> nd_local ) { cluster -> cl_has_local = tmp ; cluster -> cl_local_node = node -> nd_num ; }  return count ;  }",ret = count ;out : o2nm_unlock_subsystem ( ) ;return ret ;},391
529,"buggy line: if ( fscanf ( fp , ""\\\if ( version != PTA_VERSION_NUMBER ) return ( PTA * ) ERROR_PTR ( ""invalid<S2SV_blank>pta<S2SV_blank>version"" , procName , NULL ) ;if ( fscanf ( fp , ""<S2SV_blank>Number<S2SV_blank>of<S2SV_blank>pts<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>format<S2SV_blank>=<S2SV_blank>%s\\\cwe id:CWE-119context: PTA * ptaReadStream ( FILE * fp ) { char typestr [ 128 ] ; l_int32 i , n , ix , iy , type , version ; l_float32 x , y ; PTA * pta ; PROCNAME ( ""ptaReadStream"" ) ; if ( ! fp ) return ( PTA * ) ERROR_PTR ( ""stream<S2SV_blank>not<S2SV_blank>defined"" , procName , NULL ) ; if ( fscanf ( fp , ""\\n<S2SV_blank>Pta<S2SV_blank>Version<S2SV_blank>%d\\n"" , & version ) != 1 ) return ( PTA * ) ERROR_PTR ( ""not<S2SV_blank>a<S2SV_blank>pta<S2SV_blank>file"" , procName , NULL ) ; if ( version != PTA_VERSION_NUMBER ) return ( PTA * ) ERROR_PTR ( ""invalid<S2SV_blank>pta<S2SV_blank>version"" , procName , NULL ) ;  if ( fscanf ( fp , ""<S2SV_blank>Number<S2SV_blank>of<S2SV_blank>pts<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>format<S2SV_blank>=<S2SV_blank>%s\\n"" , & n , typestr ) != 2 )  return ( PTA * ) ERROR_PTR ( ""not<S2SV_blank>a<S2SV_blank>pta<S2SV_blank>file"" , procName , NULL ) ; if ( ! strcmp ( typestr , ""float"" ) ) type = 0 ; else type = 1 ; if ( ( pta = ptaCreate ( n ) ) == NULL ) return ( PTA * ) ERROR_PTR ( ""pta<S2SV_blank>not<S2SV_blank>made"" , procName , NULL ) ; for ( i = 0 ; i < n ; i ++ ) { if ( type == 0 ) { if ( fscanf ( fp , ""<S2SV_blank><S2SV_blank><S2SV_blank>(%f,<S2SV_blank>%f)\\n"" , & x , & y ) != 2 ) { ptaDestroy ( & pta ) ; return ( PTA * ) ERROR_PTR ( ""error<S2SV_blank>reading<S2SV_blank>floats"" , procName , NULL ) ; } ptaAddPt ( pta , x , y ) ; } else { if ( fscanf ( fp , ""<S2SV_blank><S2SV_blank><S2SV_blank>(%d,<S2SV_blank>%d)\\n"" , & ix , & iy ) != 2 ) { ptaDestroy ( & pta ) ; return ( PTA * ) ERROR_PTR ( ""error<S2SV_blank>reading<S2SV_blank>ints"" , procName , NULL ) ; } ptaAddPt ( pta , ix , iy ) ; } } return pta ; }","if ( fscanf ( fp , ""<S2SV_blank>Number<S2SV_blank>of<S2SV_blank>pts<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>format<S2SV_blank>=<S2SV_blank>%127s\\\",392
530,"buggy line: cwe id:CWE-125context: static int _6502_op ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * data , int len ) { char addrbuf [ 64 ] ; const int buffsize = sizeof ( addrbuf ) - 1 ; memset ( op , '\\0' , sizeof ( RAnalOp ) ) ; op -> size = snes_op_get_size ( 1 , 1 , & snes_op [ data [ 0 ] ] ) ; op -> addr = addr ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> id = data [ 0 ] ; r_strbuf_init ( & op -> esil ) ; switch ( data [ 0 ] ) { case 0x02 : case 0x03 : case 0x04 : case 0x07 : case 0x0b : case 0x0c : case 0x0f : case 0x12 : case 0x13 : case 0x14 : case 0x17 : case 0x1a : case 0x1b : case 0x1c : case 0x1f : case 0x22 : case 0x23 : case 0x27 : case 0x2b : case 0x2f : case 0x32 : case 0x33 : case 0x34 : case 0x37 : case 0x3a : case 0x3b : case 0x3c : case 0x3f : case 0x42 : case 0x43 : case 0x44 : case 0x47 : case 0x4b : case 0x4f : case 0x52 : case 0x53 : case 0x54 : case 0x57 : case 0x5a : case 0x5b : case 0x5c : case 0x5f : case 0x62 : case 0x63 : case 0x64 : case 0x67 : case 0x6b : case 0x6f : case 0x72 : case 0x73 : case 0x74 : case 0x77 : case 0x7a : case 0x7b : case 0x7c : case 0x7f : case 0x80 : case 0x82 : case 0x83 : case 0x87 : case 0x89 : case 0x8b : case 0x8f : case 0x92 : case 0x93 : case 0x97 : case 0x9b : case 0x9c : case 0x9e : case 0x9f : case 0xa3 : case 0xa7 : case 0xab : case 0xaf : case 0xb2 : case 0xb3 : case 0xb7 : case 0xbb : case 0xbf : case 0xc2 : case 0xc3 : case 0xc7 : case 0xcb : case 0xcf : case 0xd2 : case 0xd3 : case 0xd4 : case 0xd7 : case 0xda : case 0xdb : case 0xdc : case 0xdf : case 0xe2 : case 0xe3 : case 0xe7 : case 0xeb : case 0xef : case 0xf2 : case 0xf3 : case 0xf4 : case 0xf7 : case 0xfa : case 0xfb : case 0xfc : case 0xff : op -> size = 1 ; op -> type = R_ANAL_OP_TYPE_ILL ; break ; case 0x00 : op -> cycles = 7 ; op -> type = R_ANAL_OP_TYPE_SWI ; op -> size = 1 ; r_strbuf_set ( & op -> esil , "",1,I,=,0,D,=,flags,0x10,|,0x100,sp,+,=[1],pc,1,+,0xfe,sp,+,=[2],3,sp,-=,0xfffe,[2],pc,="" ) ; break ; case 0x78 : case 0x58 : case 0x38 : case 0x18 : case 0xf8 : case 0xd8 : case 0xb8 : op -> cycles = 2 ; op -> type = R_ANAL_OP_TYPE_NOP ; _6502_anal_esil_flags ( op , data [ 0 ] ) ; break ; case 0x24 : case 0x2c : op -> type = R_ANAL_OP_TYPE_MOV ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 0 ) ; r_strbuf_setf ( & op -> esil , ""a,%s,[1],&,0x80,&,!,!,N,=,a,%s,[1],&,0x40,&,!,!,V,=,a,%s,[1],&,0xff,&,!,Z,="" , addrbuf , addrbuf , addrbuf ) ; break ; case 0x69 : case 0x65 : case 0x75 : case 0x6d : case 0x7d : case 0x79 : case 0x61 : case 0x71 : op -> type = R_ANAL_OP_TYPE_ADD ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0x69 ) r_strbuf_setf ( & op -> esil , ""%s,a,+=,C,NUM,$c7,C,=,a,+=,$c7,C,|="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,+=,C,NUM,$c7,C,=,a,+=,$c7,C,|="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; r_strbuf_append ( & op -> esil , "",a,a,=,$z,Z,="" ) ; break ; case 0xe9 : case 0xe5 : case 0xf5 : case 0xed : case 0xfd : case 0xf9 : case 0xe1 : case 0xf1 : op -> type = R_ANAL_OP_TYPE_SUB ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0xe9 ) r_strbuf_setf ( & op -> esil , ""C,!,%s,+,a,-="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""C,!,%s,[1],+,a,-="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_BNZ ) ; r_strbuf_append ( & op -> esil , "",a,a,=,$z,Z,=,C,!="" ) ; break ; case 0x09 : case 0x05 : case 0x15 : case 0x0d : case 0x1d : case 0x19 : case 0x01 : case 0x11 : op -> type = R_ANAL_OP_TYPE_OR ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0x09 ) r_strbuf_setf ( & op -> esil , ""%s,a,|="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,|="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x29 : case 0x25 : case 0x35 : case 0x2d : case 0x3d : case 0x39 : case 0x21 : case 0x31 : op -> type = R_ANAL_OP_TYPE_AND ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0x29 ) r_strbuf_setf ( & op -> esil , ""%s,a,&="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,&="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x49 : case 0x45 : case 0x55 : case 0x4d : case 0x5d : case 0x59 : case 0x41 : case 0x51 : op -> type = R_ANAL_OP_TYPE_XOR ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0x49 ) r_strbuf_setf ( & op -> esil , ""%s,a,^="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,^="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x0a : case 0x06 : case 0x16 : case 0x0e : case 0x1e : op -> type = R_ANAL_OP_TYPE_SHL ; if ( data [ 0 ] == 0x0a ) { r_strbuf_set ( & op -> esil , ""1,a,<<=,$c7,C,=,a,a,="" ) ; } else { _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""1,%s,[1],<<,%s,=[1],$c7,C,="" , addrbuf , addrbuf ) ; } _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x4a : case 0x46 : case 0x56 : case 0x4e : case 0x5e : op -> type = R_ANAL_OP_TYPE_SHR ; if ( data [ 0 ] == 0x4a ) { r_strbuf_set ( & op -> esil , ""1,a,&,C,=,1,a,>>="" ) ; } else { _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""1,%s,[1],&,C,=,1,%s,[1],>>,%s,=[1]"" , addrbuf , addrbuf , addrbuf ) ; } _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x2a : case 0x26 : case 0x36 : case 0x2e : case 0x3e : op -> type = R_ANAL_OP_TYPE_ROL ; if ( data [ 0 ] == 0x2a ) { r_strbuf_set ( & op -> esil , ""1,a,<<,C,|,a,=,$c7,C,=,a,a,="" ) ; } else { _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""1,%s,[1],<<,C,|,%s,=[1],$c7,C,="" , addrbuf , addrbuf ) ; } _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x6a : case 0x66 : case 0x76 : case 0x6e : case 0x7e : op -> type = R_ANAL_OP_TYPE_ROR ; if ( data [ 0 ] == 0x6a ) { r_strbuf_set ( & op -> esil , ""C,N,=,1,a,&,C,=,1,a,>>,7,N,<<,|,a,="" ) ; } else { _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""C,N,=,1,%s,[1],&,C,=,1,%s,[1],>>,7,N,<<,|,%s,=[1]"" , addrbuf , addrbuf , addrbuf ) ; } _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xe6 : case 0xf6 : case 0xee : case 0xfe : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""%s,++=[1]"" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xc6 : case 0xd6 : case 0xce : case 0xde : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""%s,--=[1]"" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xe8 : case 0xc8 : op -> cycles = 2 ; op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_inc_reg ( op , data [ 0 ] , ""+"" ) ; break ; case 0xca : case 0x88 : op -> cycles = 2 ; op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_inc_reg ( op , data [ 0 ] , ""-"" ) ; break ; case 0xc9 : case 0xc5 : case 0xd5 : case 0xcd : case 0xdd : case 0xd9 : case 0xc1 : case 0xd1 : op -> type = R_ANAL_OP_TYPE_CMP ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0xc9 ) r_strbuf_setf ( & op -> esil , ""%s,a,=="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,=="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_BNZ ) ; r_strbuf_append ( & op -> esil , "",C,!,C,="" ) ; break ; case 0xe0 : case 0xe4 : case 0xec : op -> type = R_ANAL_OP_TYPE_CMP ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 0 ) ; if ( data [ 0 ] == 0xe0 ) r_strbuf_setf ( & op -> esil , ""%s,x,=="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],x,=="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_BNZ ) ; r_strbuf_append ( & op -> esil , "",C,!,C,="" ) ; break ; case 0xc0 : case 0xc4 : case 0xcc : op -> type = R_ANAL_OP_TYPE_CMP ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 0 ) ; if ( data [ 0 ] == 0xc0 ) r_strbuf_setf ( & op -> esil , ""%s,y,=="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],y,=="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_BNZ ) ; r_strbuf_append ( & op -> esil , "",C,!,C,="" ) ; break ; case 0x10 : case 0x30 : case 0x50 : case 0x70 : case 0x90 : case 0xb0 : case 0xd0 : case 0xf0 : op -> cycles = 2 ; op -> failcycles = 3 ; op -> type = R_ANAL_OP_TYPE_CJMP ;  if ( data [ 1 ] <= 127 )  op -> jump = addr + data [ 1 ] + op -> size ;  else op -> jump = addr - ( 256 - data [ 1 ] ) + op -> size ;   op -> fail = addr + op -> size ;  _6502_anal_esil_ccall ( op , data [ 0 ] ) ; break ; case 0x20 : op -> cycles = 6 ; op -> type = R_ANAL_OP_TYPE_CALL ; op -> jump = data [ 1 ] | data [ 2 ] << 8 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = 2 ; r_strbuf_setf ( & op -> esil , ""1,pc,-,0xff,sp,+,=[2],0x%04x,pc,=,2,sp,-="" , op -> jump ) ; break ; case 0x4c : op -> cycles = 3 ; op -> type = R_ANAL_OP_TYPE_JMP ; op -> jump = data [ 1 ] | data [ 2 ] << 8 ; r_strbuf_setf ( & op -> esil , ""0x%04x,pc,="" , op -> jump ) ; break ; case 0x6c : op -> cycles = 5 ; op -> type = R_ANAL_OP_TYPE_UJMP ; r_strbuf_setf ( & op -> esil , ""0x%04x,[2],pc,="" , data [ 1 ] | data [ 2 ] << 8 ) ; break ; case 0x60 : op -> eob = true ; op -> type = R_ANAL_OP_TYPE_RET ; op -> cycles = 6 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = - 2 ; r_strbuf_set ( & op -> esil , ""0x101,sp,+,[2],pc,=,pc,++=,2,sp,+="" ) ; break ; case 0x40 : op -> eob = true ; op -> type = R_ANAL_OP_TYPE_RET ; op -> cycles = 6 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = - 3 ; r_strbuf_set ( & op -> esil , ""0x101,sp,+,[1],flags,=,0x102,sp,+,[2],pc,=,3,sp,+="" ) ; break ; case 0xea : op -> type = R_ANAL_OP_TYPE_NOP ; op -> cycles = 2 ; break ; case 0xa9 : case 0xa5 : case 0xb5 : case 0xad : case 0xbd : case 0xb9 : case 0xa1 : case 0xb1 : op -> type = R_ANAL_OP_TYPE_LOAD ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0xa9 ) r_strbuf_setf ( & op -> esil , ""%s,a,="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xa2 : case 0xa6 : case 0xb6 : case 0xae : case 0xbe : op -> type = R_ANAL_OP_TYPE_LOAD ; _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'y' ) ; if ( data [ 0 ] == 0xa2 ) r_strbuf_setf ( & op -> esil , ""%s,x,="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],x,="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xa0 : case 0xa4 : case 0xb4 : case 0xac : case 0xbc : op -> type = R_ANAL_OP_TYPE_LOAD ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 'x' ) ; if ( data [ 0 ] == 0xa0 ) r_strbuf_setf ( & op -> esil , ""%s,y,="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],y,="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x85 : case 0x95 : case 0x8d : case 0x9d : case 0x99 : case 0x81 : case 0x91 : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; r_strbuf_setf ( & op -> esil , ""a,%s,=[1]"" , addrbuf ) ; break ; case 0x86 : case 0x96 : case 0x8e : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'y' ) ; r_strbuf_setf ( & op -> esil , ""x,%s,=[1]"" , addrbuf ) ; break ; case 0x84 : case 0x94 : case 0x8c : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""y,%s,=[1]"" , addrbuf ) ; break ; case 0x08 : case 0x48 : op -> type = R_ANAL_OP_TYPE_PUSH ; op -> cycles = 3 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = 1 ; _6502_anal_esil_push ( op , data [ 0 ] ) ; break ; case 0x28 : case 0x68 : op -> type = R_ANAL_OP_TYPE_POP ; op -> cycles = 4 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = - 1 ; _6502_anal_esil_pop ( op , data [ 0 ] ) ; break ; case 0xaa : case 0x8a : case 0xa8 : case 0x98 : op -> type = R_ANAL_OP_TYPE_MOV ; op -> cycles = 2 ; _6502_anal_esil_mov ( op , data [ 0 ] ) ; break ; case 0x9a : op -> type = R_ANAL_OP_TYPE_MOV ; op -> cycles = 2 ; op -> stackop = R_ANAL_STACK_SET ; _6502_anal_esil_mov ( op , data [ 0 ] ) ; break ; case 0xba : op -> type = R_ANAL_OP_TYPE_MOV ; op -> cycles = 2 ; op -> stackop = R_ANAL_STACK_GET ; _6502_anal_esil_mov ( op , data [ 0 ] ) ; break ; } return op -> size ; }",if ( len > 1 ) {,393
531,"buggy line: if ( data [ 1 ] <= 127 )  op -> jump = addr + data [ 1 ] + op -> size ;else op -> jump = addr - ( 256 - data [ 1 ] ) + op -> size ;op -> fail = addr + op -> size ;_6502_anal_esil_ccall ( op , data [ 0 ] ) ;cwe id:CWE-125context: static int _6502_op ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * data , int len ) { char addrbuf [ 64 ] ; const int buffsize = sizeof ( addrbuf ) - 1 ; memset ( op , '\\0' , sizeof ( RAnalOp ) ) ; op -> size = snes_op_get_size ( 1 , 1 , & snes_op [ data [ 0 ] ] ) ; op -> addr = addr ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> id = data [ 0 ] ; r_strbuf_init ( & op -> esil ) ; switch ( data [ 0 ] ) { case 0x02 : case 0x03 : case 0x04 : case 0x07 : case 0x0b : case 0x0c : case 0x0f : case 0x12 : case 0x13 : case 0x14 : case 0x17 : case 0x1a : case 0x1b : case 0x1c : case 0x1f : case 0x22 : case 0x23 : case 0x27 : case 0x2b : case 0x2f : case 0x32 : case 0x33 : case 0x34 : case 0x37 : case 0x3a : case 0x3b : case 0x3c : case 0x3f : case 0x42 : case 0x43 : case 0x44 : case 0x47 : case 0x4b : case 0x4f : case 0x52 : case 0x53 : case 0x54 : case 0x57 : case 0x5a : case 0x5b : case 0x5c : case 0x5f : case 0x62 : case 0x63 : case 0x64 : case 0x67 : case 0x6b : case 0x6f : case 0x72 : case 0x73 : case 0x74 : case 0x77 : case 0x7a : case 0x7b : case 0x7c : case 0x7f : case 0x80 : case 0x82 : case 0x83 : case 0x87 : case 0x89 : case 0x8b : case 0x8f : case 0x92 : case 0x93 : case 0x97 : case 0x9b : case 0x9c : case 0x9e : case 0x9f : case 0xa3 : case 0xa7 : case 0xab : case 0xaf : case 0xb2 : case 0xb3 : case 0xb7 : case 0xbb : case 0xbf : case 0xc2 : case 0xc3 : case 0xc7 : case 0xcb : case 0xcf : case 0xd2 : case 0xd3 : case 0xd4 : case 0xd7 : case 0xda : case 0xdb : case 0xdc : case 0xdf : case 0xe2 : case 0xe3 : case 0xe7 : case 0xeb : case 0xef : case 0xf2 : case 0xf3 : case 0xf4 : case 0xf7 : case 0xfa : case 0xfb : case 0xfc : case 0xff : op -> size = 1 ; op -> type = R_ANAL_OP_TYPE_ILL ; break ; case 0x00 : op -> cycles = 7 ; op -> type = R_ANAL_OP_TYPE_SWI ; op -> size = 1 ; r_strbuf_set ( & op -> esil , "",1,I,=,0,D,=,flags,0x10,|,0x100,sp,+,=[1],pc,1,+,0xfe,sp,+,=[2],3,sp,-=,0xfffe,[2],pc,="" ) ; break ; case 0x78 : case 0x58 : case 0x38 : case 0x18 : case 0xf8 : case 0xd8 : case 0xb8 : op -> cycles = 2 ; op -> type = R_ANAL_OP_TYPE_NOP ; _6502_anal_esil_flags ( op , data [ 0 ] ) ; break ; case 0x24 : case 0x2c : op -> type = R_ANAL_OP_TYPE_MOV ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 0 ) ; r_strbuf_setf ( & op -> esil , ""a,%s,[1],&,0x80,&,!,!,N,=,a,%s,[1],&,0x40,&,!,!,V,=,a,%s,[1],&,0xff,&,!,Z,="" , addrbuf , addrbuf , addrbuf ) ; break ; case 0x69 : case 0x65 : case 0x75 : case 0x6d : case 0x7d : case 0x79 : case 0x61 : case 0x71 : op -> type = R_ANAL_OP_TYPE_ADD ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0x69 ) r_strbuf_setf ( & op -> esil , ""%s,a,+=,C,NUM,$c7,C,=,a,+=,$c7,C,|="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,+=,C,NUM,$c7,C,=,a,+=,$c7,C,|="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; r_strbuf_append ( & op -> esil , "",a,a,=,$z,Z,="" ) ; break ; case 0xe9 : case 0xe5 : case 0xf5 : case 0xed : case 0xfd : case 0xf9 : case 0xe1 : case 0xf1 : op -> type = R_ANAL_OP_TYPE_SUB ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0xe9 ) r_strbuf_setf ( & op -> esil , ""C,!,%s,+,a,-="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""C,!,%s,[1],+,a,-="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_BNZ ) ; r_strbuf_append ( & op -> esil , "",a,a,=,$z,Z,=,C,!="" ) ; break ; case 0x09 : case 0x05 : case 0x15 : case 0x0d : case 0x1d : case 0x19 : case 0x01 : case 0x11 : op -> type = R_ANAL_OP_TYPE_OR ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0x09 ) r_strbuf_setf ( & op -> esil , ""%s,a,|="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,|="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x29 : case 0x25 : case 0x35 : case 0x2d : case 0x3d : case 0x39 : case 0x21 : case 0x31 : op -> type = R_ANAL_OP_TYPE_AND ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0x29 ) r_strbuf_setf ( & op -> esil , ""%s,a,&="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,&="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x49 : case 0x45 : case 0x55 : case 0x4d : case 0x5d : case 0x59 : case 0x41 : case 0x51 : op -> type = R_ANAL_OP_TYPE_XOR ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0x49 ) r_strbuf_setf ( & op -> esil , ""%s,a,^="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,^="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x0a : case 0x06 : case 0x16 : case 0x0e : case 0x1e : op -> type = R_ANAL_OP_TYPE_SHL ; if ( data [ 0 ] == 0x0a ) { r_strbuf_set ( & op -> esil , ""1,a,<<=,$c7,C,=,a,a,="" ) ; } else { _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""1,%s,[1],<<,%s,=[1],$c7,C,="" , addrbuf , addrbuf ) ; } _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x4a : case 0x46 : case 0x56 : case 0x4e : case 0x5e : op -> type = R_ANAL_OP_TYPE_SHR ; if ( data [ 0 ] == 0x4a ) { r_strbuf_set ( & op -> esil , ""1,a,&,C,=,1,a,>>="" ) ; } else { _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""1,%s,[1],&,C,=,1,%s,[1],>>,%s,=[1]"" , addrbuf , addrbuf , addrbuf ) ; } _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x2a : case 0x26 : case 0x36 : case 0x2e : case 0x3e : op -> type = R_ANAL_OP_TYPE_ROL ; if ( data [ 0 ] == 0x2a ) { r_strbuf_set ( & op -> esil , ""1,a,<<,C,|,a,=,$c7,C,=,a,a,="" ) ; } else { _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""1,%s,[1],<<,C,|,%s,=[1],$c7,C,="" , addrbuf , addrbuf ) ; } _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x6a : case 0x66 : case 0x76 : case 0x6e : case 0x7e : op -> type = R_ANAL_OP_TYPE_ROR ; if ( data [ 0 ] == 0x6a ) { r_strbuf_set ( & op -> esil , ""C,N,=,1,a,&,C,=,1,a,>>,7,N,<<,|,a,="" ) ; } else { _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""C,N,=,1,%s,[1],&,C,=,1,%s,[1],>>,7,N,<<,|,%s,=[1]"" , addrbuf , addrbuf , addrbuf ) ; } _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xe6 : case 0xf6 : case 0xee : case 0xfe : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""%s,++=[1]"" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xc6 : case 0xd6 : case 0xce : case 0xde : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""%s,--=[1]"" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xe8 : case 0xc8 : op -> cycles = 2 ; op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_inc_reg ( op , data [ 0 ] , ""+"" ) ; break ; case 0xca : case 0x88 : op -> cycles = 2 ; op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_inc_reg ( op , data [ 0 ] , ""-"" ) ; break ; case 0xc9 : case 0xc5 : case 0xd5 : case 0xcd : case 0xdd : case 0xd9 : case 0xc1 : case 0xd1 : op -> type = R_ANAL_OP_TYPE_CMP ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0xc9 ) r_strbuf_setf ( & op -> esil , ""%s,a,=="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,=="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_BNZ ) ; r_strbuf_append ( & op -> esil , "",C,!,C,="" ) ; break ; case 0xe0 : case 0xe4 : case 0xec : op -> type = R_ANAL_OP_TYPE_CMP ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 0 ) ; if ( data [ 0 ] == 0xe0 ) r_strbuf_setf ( & op -> esil , ""%s,x,=="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],x,=="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_BNZ ) ; r_strbuf_append ( & op -> esil , "",C,!,C,="" ) ; break ; case 0xc0 : case 0xc4 : case 0xcc : op -> type = R_ANAL_OP_TYPE_CMP ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 0 ) ; if ( data [ 0 ] == 0xc0 ) r_strbuf_setf ( & op -> esil , ""%s,y,=="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],y,=="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_BNZ ) ; r_strbuf_append ( & op -> esil , "",C,!,C,="" ) ; break ; case 0x10 : case 0x30 : case 0x50 : case 0x70 : case 0x90 : case 0xb0 : case 0xd0 : case 0xf0 : op -> cycles = 2 ; op -> failcycles = 3 ; op -> type = R_ANAL_OP_TYPE_CJMP ;  if ( data [ 1 ] <= 127 )  op -> jump = addr + data [ 1 ] + op -> size ;  else op -> jump = addr - ( 256 - data [ 1 ] ) + op -> size ;   op -> fail = addr + op -> size ;  _6502_anal_esil_ccall ( op , data [ 0 ] ) ; break ; case 0x20 : op -> cycles = 6 ; op -> type = R_ANAL_OP_TYPE_CALL ; op -> jump = data [ 1 ] | data [ 2 ] << 8 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = 2 ; r_strbuf_setf ( & op -> esil , ""1,pc,-,0xff,sp,+,=[2],0x%04x,pc,=,2,sp,-="" , op -> jump ) ; break ; case 0x4c : op -> cycles = 3 ; op -> type = R_ANAL_OP_TYPE_JMP ; op -> jump = data [ 1 ] | data [ 2 ] << 8 ; r_strbuf_setf ( & op -> esil , ""0x%04x,pc,="" , op -> jump ) ; break ; case 0x6c : op -> cycles = 5 ; op -> type = R_ANAL_OP_TYPE_UJMP ; r_strbuf_setf ( & op -> esil , ""0x%04x,[2],pc,="" , data [ 1 ] | data [ 2 ] << 8 ) ; break ; case 0x60 : op -> eob = true ; op -> type = R_ANAL_OP_TYPE_RET ; op -> cycles = 6 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = - 2 ; r_strbuf_set ( & op -> esil , ""0x101,sp,+,[2],pc,=,pc,++=,2,sp,+="" ) ; break ; case 0x40 : op -> eob = true ; op -> type = R_ANAL_OP_TYPE_RET ; op -> cycles = 6 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = - 3 ; r_strbuf_set ( & op -> esil , ""0x101,sp,+,[1],flags,=,0x102,sp,+,[2],pc,=,3,sp,+="" ) ; break ; case 0xea : op -> type = R_ANAL_OP_TYPE_NOP ; op -> cycles = 2 ; break ; case 0xa9 : case 0xa5 : case 0xb5 : case 0xad : case 0xbd : case 0xb9 : case 0xa1 : case 0xb1 : op -> type = R_ANAL_OP_TYPE_LOAD ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0xa9 ) r_strbuf_setf ( & op -> esil , ""%s,a,="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xa2 : case 0xa6 : case 0xb6 : case 0xae : case 0xbe : op -> type = R_ANAL_OP_TYPE_LOAD ; _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'y' ) ; if ( data [ 0 ] == 0xa2 ) r_strbuf_setf ( & op -> esil , ""%s,x,="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],x,="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xa0 : case 0xa4 : case 0xb4 : case 0xac : case 0xbc : op -> type = R_ANAL_OP_TYPE_LOAD ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 'x' ) ; if ( data [ 0 ] == 0xa0 ) r_strbuf_setf ( & op -> esil , ""%s,y,="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],y,="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x85 : case 0x95 : case 0x8d : case 0x9d : case 0x99 : case 0x81 : case 0x91 : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; r_strbuf_setf ( & op -> esil , ""a,%s,=[1]"" , addrbuf ) ; break ; case 0x86 : case 0x96 : case 0x8e : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'y' ) ; r_strbuf_setf ( & op -> esil , ""x,%s,=[1]"" , addrbuf ) ; break ; case 0x84 : case 0x94 : case 0x8c : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""y,%s,=[1]"" , addrbuf ) ; break ; case 0x08 : case 0x48 : op -> type = R_ANAL_OP_TYPE_PUSH ; op -> cycles = 3 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = 1 ; _6502_anal_esil_push ( op , data [ 0 ] ) ; break ; case 0x28 : case 0x68 : op -> type = R_ANAL_OP_TYPE_POP ; op -> cycles = 4 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = - 1 ; _6502_anal_esil_pop ( op , data [ 0 ] ) ; break ; case 0xaa : case 0x8a : case 0xa8 : case 0x98 : op -> type = R_ANAL_OP_TYPE_MOV ; op -> cycles = 2 ; _6502_anal_esil_mov ( op , data [ 0 ] ) ; break ; case 0x9a : op -> type = R_ANAL_OP_TYPE_MOV ; op -> cycles = 2 ; op -> stackop = R_ANAL_STACK_SET ; _6502_anal_esil_mov ( op , data [ 0 ] ) ; break ; case 0xba : op -> type = R_ANAL_OP_TYPE_MOV ; op -> cycles = 2 ; op -> stackop = R_ANAL_STACK_GET ; _6502_anal_esil_mov ( op , data [ 0 ] ) ; break ; } return op -> size ; }","if ( data [ 1 ] <= 127 ) {op -> jump = addr + data [ 1 ] + op -> size ;}else {op -> jump = addr - ( 256 - data [ 1 ] ) + op -> size ;}}else {op -> jump = addr ;}op -> fail = addr + op -> size ;_6502_anal_esil_ccall ( op , data [ 0 ] ) ;",393
532,"buggy line: struct net * net = sock_net ( asoc -> base . sk ) ;bh_lock_sock ( asoc -> base . sk ) ;if ( sock_owned_by_user ( asoc -> base . sk ) ) {pr_debug ( ""%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy\\\if ( error )  asoc -> base . sk -> sk_err = - error ;out_unlock :  bh_unlock_sock ( asoc -> base . sk ) ;sctp_transport_put ( transport ) ;cwe id:CWE-362context: void sctp_generate_t3_rtx_event ( unsigned long peer ) { int error ; struct sctp_transport * transport = ( struct sctp_transport * ) peer ; struct sctp_association * asoc = transport -> asoc ;  struct net * net = sock_net ( asoc -> base . sk ) ;   bh_lock_sock ( asoc -> base . sk ) ;   if ( sock_owned_by_user ( asoc -> base . sk ) ) {  pr_debug ( ""%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy\\n"" , __func__ ) ; if ( ! mod_timer ( & transport -> T3_rtx_timer , jiffies + ( HZ / 20 ) ) ) sctp_transport_hold ( transport ) ; goto out_unlock ; } if ( transport -> dead ) goto out_unlock ; error = sctp_do_sm ( net , SCTP_EVENT_T_TIMEOUT , SCTP_ST_TIMEOUT ( SCTP_EVENT_TIMEOUT_T3_RTX ) , asoc -> state , asoc -> ep , asoc , transport , GFP_ATOMIC ) ; if ( error )  asoc -> base . sk -> sk_err = - error ;  out_unlock :  bh_unlock_sock ( asoc -> base . sk ) ;  sctp_transport_put ( transport ) ; }","struct sock * sk = asoc -> base . sk ;struct net * net = sock_net ( sk ) ;bh_lock_sock ( asoc -> base . sk ) ;if ( sock_owned_by_user ( sk ) ) {pr_debug ( ""%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy\\\if ( error ) sk -> sk_err = - error ;out_unlock : bh_unlock_sock ( sk ) ;sctp_transport_put ( transport ) ;",394
533,"buggy line: s = strchr ( token , \'?\' ) ;if ( s != NULL ) {cwe id:CWE-20context: error_t httpParseRequestLine ( HttpConnection * connection , char_t * requestLine ) { error_t error ; char_t * token ; char_t * p ; char_t * s ; token = osStrtok_r ( requestLine , ""<S2SV_blank>\\r\\n"" , & p ) ; if ( token == NULL ) return ERROR_INVALID_REQUEST ; error = strSafeCopy ( connection -> request . method , token , HTTP_SERVER_METHOD_MAX_LEN ) ; if ( error ) return ERROR_INVALID_REQUEST ; token = osStrtok_r ( NULL , ""<S2SV_blank>\\r\\n"" , & p ) ; if ( token == NULL ) return ERROR_INVALID_REQUEST ;  s = strchr ( token , '?' ) ;  if ( s != NULL ) { * s = '\\0' ; error = httpDecodePercentEncodedString ( token , connection -> request . uri , HTTP_SERVER_URI_MAX_LEN ) ; if ( error ) return ERROR_INVALID_REQUEST ; if ( osStrlen ( s + 1 ) > HTTP_SERVER_QUERY_STRING_MAX_LEN ) return ERROR_INVALID_REQUEST ; osStrcpy ( connection -> request . queryString , s + 1 ) ; } else { error = httpDecodePercentEncodedString ( token , connection -> request . uri , HTTP_SERVER_URI_MAX_LEN ) ; if ( error ) return ERROR_INVALID_REQUEST ; connection -> request . queryString [ 0 ] = '\\0' ; } if ( ! osStrcasecmp ( connection -> request . uri , ""/"" ) ) osStrcpy ( connection -> request . uri , connection -> settings -> defaultDocument ) ; pathCanonicalize ( connection -> request . uri ) ; token = osStrtok_r ( NULL , ""<S2SV_blank>\\r\\n"" , & p ) ; if ( token == NULL ) { connection -> request . version = HTTP_VERSION_0_9 ; connection -> request . keepAlive = FALSE ; } else if ( ! osStrcasecmp ( token , ""HTTP/1.0"" ) ) { connection -> request . version = HTTP_VERSION_1_0 ; connection -> request . keepAlive = FALSE ; } else if ( ! osStrcasecmp ( token , ""HTTP/1.1"" ) ) { connection -> request . version = HTTP_VERSION_1_1 ; connection -> request . keepAlive = TRUE ; } else { return ERROR_INVALID_REQUEST ; } return NO_ERROR ; }","s = osStrchr ( token , \'?\' ) ;if ( s != NULL ) {",395
534,"buggy line: if ( fop == NULL )  return - E_NOTHANDLED ;fd = open ( EF_GBL_OPTIONS -> output_file , O_CREAT | O_RDWR | O_TRUNC | O_BINARY , 0644 ) ;cwe id:CWE-125context: int write_output ( void ) { int fd ; struct filter_op * fop ; struct filter_header fh ; size_t ninst , i ; u_char * data ; ninst = compile_tree ( & fop ) ; if ( fop == NULL )  return - E_NOTHANDLED ;  fd = open ( EF_GBL_OPTIONS -> output_file , O_CREAT | O_RDWR | O_TRUNC | O_BINARY , 0644 ) ; ON_ERROR ( fd , - 1 , ""Can\'t<S2SV_blank>create<S2SV_blank>file<S2SV_blank>%s"" , EF_GBL_OPTIONS -> output_file ) ; fprintf ( stdout , ""<S2SV_blank>Writing<S2SV_blank>output<S2SV_blank>to<S2SV_blank>\\\'%s\\\'<S2SV_blank>"" , EF_GBL_OPTIONS -> output_file ) ; fflush ( stdout ) ; fh . magic = htons ( EC_FILTER_MAGIC ) ; strncpy ( fh . version , EC_VERSION , sizeof ( fh . version ) ) ; fh . data = sizeof ( fh ) ; data = create_data_segment ( & fh , fop , ninst ) ; write ( fd , & fh , sizeof ( struct filter_header ) ) ; write ( fd , data , fh . code - fh . data ) ; for ( i = 0 ; i <= ninst ; i ++ ) { print_progress_bar ( & fop [ i ] ) ; write ( fd , & fop [ i ] , sizeof ( struct filter_op ) ) ; } close ( fd ) ; fprintf ( stdout , ""<S2SV_blank>done.\\n\\n"" ) ; fprintf ( stdout , ""<S2SV_blank>-><S2SV_blank>Script<S2SV_blank>encoded<S2SV_blank>into<S2SV_blank>%d<S2SV_blank>instructions.\\n\\n"" , ( int ) ( i - 1 ) ) ; return E_SUCCESS ; }","if ( fop == NULL ) return - E_NOTHANDLED ;if ( ninst == 0 ) return - E_INVALID ;fd = open ( EF_GBL_OPTIONS -> output_file , O_CREAT | O_RDWR | O_TRUNC | O_BINARY , 0644 ) ;",396
535,"buggy line: ND_TCHECK ( lshp -> ls_type ) ;ND_TCHECK ( lshp -> ls_seq ) ;cwe id:CWE-125context: static int ospf6_print_lshdr ( netdissect_options * ndo , register const struct lsa6_hdr * lshp , const u_char * dataend ) { if ( ( const u_char * ) ( lshp + 1 ) > dataend ) goto trunc ;  ND_TCHECK ( lshp -> ls_type ) ;  ND_TCHECK ( lshp -> ls_seq ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Advertising<S2SV_blank>Router<S2SV_blank>%s,<S2SV_blank>seq<S2SV_blank>0x%08x,<S2SV_blank>age<S2SV_blank>%us,<S2SV_blank>length<S2SV_blank>%u"" , ipaddr_string ( ndo , & lshp -> ls_router ) , EXTRACT_32BITS ( & lshp -> ls_seq ) , EXTRACT_16BITS ( & lshp -> ls_age ) , EXTRACT_16BITS ( & lshp -> ls_length ) - ( u_int ) sizeof ( struct lsa6_hdr ) ) ) ; ospf6_print_ls_type ( ndo , EXTRACT_16BITS ( & lshp -> ls_type ) , & lshp -> ls_stateid ) ; return ( 0 ) ; trunc : return ( 1 ) ; }",ND_TCHECK ( lshp -> ls_length ) ;,397
536,"buggy line: static int jas_iccputuint ( jas_stream_t * out , int n , ulonglong val )  {cwe id:CWE-190context:  static int jas_iccputuint ( jas_stream_t * out , int n , ulonglong val )  { int i ; int c ; for ( i = n ; i > 0 ; -- i ) { c = ( val >> ( 8 * ( i - 1 ) ) ) & 0xff ; if ( jas_stream_putc ( out , c ) == EOF ) return - 1 ; } return 0 ; }","static int jas_iccputuint ( jas_stream_t * out , int n , jas_ulonglong val ) {",398
537,"buggy line: case E_SSID : memcpy ( & ssid , p + offset , 2 ) ;offset += 2 ;length -= 2 ;if ( ssid . length != 0 ) {if ( ssid . length > sizeof ( ssid . ssid ) - 1 ) return 0 ;if ( ! ND_TTEST2 ( * ( p + offset ) , ssid . length ) ) return 0 ;if ( length < ssid . length ) return 0 ;memcpy ( & ssid . ssid , p + offset , ssid . length ) ;offset += ssid . length ;length -= ssid . length ;}ssid . ssid [ ssid . length ] = '\\\\0' ;if ( ! pbody -> ssid_present ) {pbody -> ssid = ssid ;pbody -> ssid_present = 1 ;}break ;case E_CHALLENGE : memcpy ( & challenge , p + offset , 2 ) ;offset += 2 ;length -= 2 ;if ( challenge . length != 0 ) {if ( challenge . length > sizeof ( challenge . text ) - 1 ) return 0 ;if ( ! ND_TTEST2 ( * ( p + offset ) , challenge . length ) ) return 0 ;if ( length < challenge . length ) return 0 ;memcpy ( & challenge . text , p + offset , challenge . length ) ;offset += challenge . length ;length -= challenge . length ;}challenge . text [ challenge . length ] = '\\\\0' ;if ( ! pbody -> challenge_present ) {pbody -> challenge = challenge ;pbody -> challenge_present = 1 ;}break ;case E_RATES : memcpy ( & rates , p + offset , 2 ) ;offset += 2 ;length -= 2 ;if ( rates . length != 0 ) {if ( rates . length > sizeof rates . rate ) return 0 ;if ( ! ND_TTEST2 ( * ( p + offset ) , rates . length ) ) return 0 ;if ( length < rates . length ) return 0 ;memcpy ( & rates . rate , p + offset , rates . length ) ;offset += rates . length ;length -= rates . length ;}if ( ! pbody -> rates_present && rates . length != 0 ) {pbody -> rates = rates ;pbody -> rates_present = 1 ;}break ;case E_DS : memcpy ( & ds , p + offset , 2 ) ;offset += 2 ;length -= 2 ;if ( ds . length != 1 ) {offset += ds . length ;length -= ds . length ;break ;}ds . channel = * ( p + offset ) ;offset += 1 ;length -= 1 ;if ( ! pbody -> ds_present ) {pbody -> ds = ds ;pbody -> ds_present = 1 ;}break ;case E_CF : memcpy ( & cf , p + offset , 2 ) ;offset += 2 ;length -= 2 ;if ( cf . length != 6 ) {offset += cf . length ;length -= cf . length ;break ;}memcpy ( & cf . count , p + offset , 6 ) ;offset += 6 ;length -= 6 ;if ( ! pbody -> cf_present ) {pbody -> cf = cf ;pbody -> cf_present = 1 ;}break ;case E_TIM : memcpy ( & tim , p + offset , 2 ) ;offset += 2 ;length -= 2 ;if ( tim . length <= 3 ) {cwe id:CWE-125context: static int parse_elements ( netdissect_options * ndo , struct mgmt_body_t * pbody , const u_char * p , int offset , u_int length ) { u_int elementlen ; struct ssid_t ssid ; struct challenge_t challenge ; struct rates_t rates ; struct ds_t ds ; struct cf_t cf ; struct tim_t tim ; pbody -> challenge_present = 0 ; pbody -> ssid_present = 0 ; pbody -> rates_present = 0 ; pbody -> ds_present = 0 ; pbody -> cf_present = 0 ; pbody -> tim_present = 0 ; while ( length != 0 ) { if ( ! ND_TTEST2 ( * ( p + offset ) , 2 ) ) return 0 ; if ( length < 2 ) return 0 ; elementlen = * ( p + offset + 1 ) ; if ( ! ND_TTEST2 ( * ( p + offset + 2 ) , elementlen ) ) return 0 ; if ( length < elementlen + 2 ) return 0 ; switch ( * ( p + offset ) ) { case E_SSID : memcpy ( & ssid , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( ssid . length != 0 ) { if ( ssid . length > sizeof ( ssid . ssid ) - 1 ) return 0 ; if ( ! ND_TTEST2 ( * ( p + offset ) , ssid . length ) ) return 0 ; if ( length < ssid . length ) return 0 ; memcpy ( & ssid . ssid , p + offset , ssid . length ) ; offset += ssid . length ; length -= ssid . length ; } ssid . ssid [ ssid . length ] = '\\0' ; if ( ! pbody -> ssid_present ) { pbody -> ssid = ssid ; pbody -> ssid_present = 1 ; } break ; case E_CHALLENGE : memcpy ( & challenge , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( challenge . length != 0 ) { if ( challenge . length > sizeof ( challenge . text ) - 1 ) return 0 ; if ( ! ND_TTEST2 ( * ( p + offset ) , challenge . length ) ) return 0 ; if ( length < challenge . length ) return 0 ; memcpy ( & challenge . text , p + offset , challenge . length ) ; offset += challenge . length ; length -= challenge . length ; } challenge . text [ challenge . length ] = '\\0' ; if ( ! pbody -> challenge_present ) { pbody -> challenge = challenge ; pbody -> challenge_present = 1 ; } break ; case E_RATES : memcpy ( & rates , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( rates . length != 0 ) { if ( rates . length > sizeof rates . rate ) return 0 ; if ( ! ND_TTEST2 ( * ( p + offset ) , rates . length ) ) return 0 ; if ( length < rates . length ) return 0 ; memcpy ( & rates . rate , p + offset , rates . length ) ; offset += rates . length ; length -= rates . length ; } if ( ! pbody -> rates_present && rates . length != 0 ) { pbody -> rates = rates ; pbody -> rates_present = 1 ; } break ; case E_DS : memcpy ( & ds , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( ds . length != 1 ) { offset += ds . length ; length -= ds . length ; break ; } ds . channel = * ( p + offset ) ; offset += 1 ; length -= 1 ; if ( ! pbody -> ds_present ) { pbody -> ds = ds ; pbody -> ds_present = 1 ; } break ; case E_CF : memcpy ( & cf , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( cf . length != 6 ) { offset += cf . length ; length -= cf . length ; break ; } memcpy ( & cf . count , p + offset , 6 ) ; offset += 6 ; length -= 6 ; if ( ! pbody -> cf_present ) { pbody -> cf = cf ; pbody -> cf_present = 1 ; } break ; case E_TIM : memcpy ( & tim , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( tim . length <= 3 ) { offset += tim . length ; length -= tim . length ; break ; } if ( tim . length - 3 > ( int ) sizeof tim . bitmap ) return 0 ; memcpy ( & tim . count , p + offset , 3 ) ; offset += 3 ; length -= 3 ;  memcpy ( tim . bitmap , p + ( tim . length - 3 ) ,   ( tim . length - 3 ) ) ;  offset += tim . length - 3 ;  length -= tim . length - 3 ;  if ( ! pbody -> tim_present ) { pbody -> tim = tim ; pbody -> tim_present = 1 ; } break ; default : # if 0 ND_PRINT ( ( ndo , ""(1)<S2SV_blank>unhandled<S2SV_blank>element_id<S2SV_blank>(%d)<S2SV_blank><S2SV_blank>"" , * ( p + offset ) ) ) ; # endif offset += 2 + elementlen ; length -= 2 + elementlen ; break ; } } return 1 ; }","case E_SSID : memcpy ( & ssid , p + offset + 3 , tim . length <= 3 ) {",399
538,"buggy line: memcpy ( tim . bitmap , p + ( tim . length - 3 ) ,   ( tim . length - 3 ) ) ;offset += tim . length - 3 ;length -= tim . length - 3 ;if ( ! pbody -> tim_present ) {cwe id:CWE-125context: static int parse_elements ( netdissect_options * ndo , struct mgmt_body_t * pbody , const u_char * p , int offset , u_int length ) { u_int elementlen ; struct ssid_t ssid ; struct challenge_t challenge ; struct rates_t rates ; struct ds_t ds ; struct cf_t cf ; struct tim_t tim ; pbody -> challenge_present = 0 ; pbody -> ssid_present = 0 ; pbody -> rates_present = 0 ; pbody -> ds_present = 0 ; pbody -> cf_present = 0 ; pbody -> tim_present = 0 ; while ( length != 0 ) { if ( ! ND_TTEST2 ( * ( p + offset ) , 2 ) ) return 0 ; if ( length < 2 ) return 0 ; elementlen = * ( p + offset + 1 ) ; if ( ! ND_TTEST2 ( * ( p + offset + 2 ) , elementlen ) ) return 0 ; if ( length < elementlen + 2 ) return 0 ; switch ( * ( p + offset ) ) { case E_SSID : memcpy ( & ssid , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( ssid . length != 0 ) { if ( ssid . length > sizeof ( ssid . ssid ) - 1 ) return 0 ; if ( ! ND_TTEST2 ( * ( p + offset ) , ssid . length ) ) return 0 ; if ( length < ssid . length ) return 0 ; memcpy ( & ssid . ssid , p + offset , ssid . length ) ; offset += ssid . length ; length -= ssid . length ; } ssid . ssid [ ssid . length ] = '\\0' ; if ( ! pbody -> ssid_present ) { pbody -> ssid = ssid ; pbody -> ssid_present = 1 ; } break ; case E_CHALLENGE : memcpy ( & challenge , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( challenge . length != 0 ) { if ( challenge . length > sizeof ( challenge . text ) - 1 ) return 0 ; if ( ! ND_TTEST2 ( * ( p + offset ) , challenge . length ) ) return 0 ; if ( length < challenge . length ) return 0 ; memcpy ( & challenge . text , p + offset , challenge . length ) ; offset += challenge . length ; length -= challenge . length ; } challenge . text [ challenge . length ] = '\\0' ; if ( ! pbody -> challenge_present ) { pbody -> challenge = challenge ; pbody -> challenge_present = 1 ; } break ; case E_RATES : memcpy ( & rates , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( rates . length != 0 ) { if ( rates . length > sizeof rates . rate ) return 0 ; if ( ! ND_TTEST2 ( * ( p + offset ) , rates . length ) ) return 0 ; if ( length < rates . length ) return 0 ; memcpy ( & rates . rate , p + offset , rates . length ) ; offset += rates . length ; length -= rates . length ; } if ( ! pbody -> rates_present && rates . length != 0 ) { pbody -> rates = rates ; pbody -> rates_present = 1 ; } break ; case E_DS : memcpy ( & ds , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( ds . length != 1 ) { offset += ds . length ; length -= ds . length ; break ; } ds . channel = * ( p + offset ) ; offset += 1 ; length -= 1 ; if ( ! pbody -> ds_present ) { pbody -> ds = ds ; pbody -> ds_present = 1 ; } break ; case E_CF : memcpy ( & cf , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( cf . length != 6 ) { offset += cf . length ; length -= cf . length ; break ; } memcpy ( & cf . count , p + offset , 6 ) ; offset += 6 ; length -= 6 ; if ( ! pbody -> cf_present ) { pbody -> cf = cf ; pbody -> cf_present = 1 ; } break ; case E_TIM : memcpy ( & tim , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( tim . length <= 3 ) { offset += tim . length ; length -= tim . length ; break ; } if ( tim . length - 3 > ( int ) sizeof tim . bitmap ) return 0 ; memcpy ( & tim . count , p + offset , 3 ) ; offset += 3 ; length -= 3 ;  memcpy ( tim . bitmap , p + ( tim . length - 3 ) ,   ( tim . length - 3 ) ) ;  offset += tim . length - 3 ;  length -= tim . length - 3 ;  if ( ! pbody -> tim_present ) { pbody -> tim = tim ; pbody -> tim_present = 1 ; } break ; default : # if 0 ND_PRINT ( ( ndo , ""(1)<S2SV_blank>unhandled<S2SV_blank>element_id<S2SV_blank>(%d)<S2SV_blank><S2SV_blank>"" , * ( p + offset ) ) ) ; # endif offset += 2 + elementlen ; length -= 2 + elementlen ; break ; } } return 1 ; }","memcpy ( tim . bitmap , p + ( tim . length - 3 ) , ( tim . length - 3 ) ) ;offset += tim . length - 3 ;length -= tim . length - 3 ;if ( ! pbody -> tim_present ) {",399
539,"buggy line: pipe_buf_get ( ipipe , ibuf ) ;* obuf = * ibuf ;cwe id:CWE-416context: static int splice_pipe_to_pipe ( struct pipe_inode_info * ipipe , struct pipe_inode_info * opipe , size_t len , unsigned int flags ) { struct pipe_buffer * ibuf , * obuf ; int ret = 0 , nbuf ; bool input_wakeup = false ; retry : ret = ipipe_prep ( ipipe , flags ) ; if ( ret ) return ret ; ret = opipe_prep ( opipe , flags ) ; if ( ret ) return ret ; pipe_double_lock ( ipipe , opipe ) ; do { if ( ! opipe -> readers ) { send_sig ( SIGPIPE , current , 0 ) ; if ( ! ret ) ret = - EPIPE ; break ; } if ( ! ipipe -> nrbufs && ! ipipe -> writers ) break ; if ( ! ipipe -> nrbufs || opipe -> nrbufs >= opipe -> buffers ) { if ( ret ) break ; if ( flags & SPLICE_F_NONBLOCK ) { ret = - EAGAIN ; break ; } pipe_unlock ( ipipe ) ; pipe_unlock ( opipe ) ; goto retry ; } ibuf = ipipe -> bufs + ipipe -> curbuf ; nbuf = ( opipe -> curbuf + opipe -> nrbufs ) & ( opipe -> buffers - 1 ) ; obuf = opipe -> bufs + nbuf ; if ( len >= ibuf -> len ) { * obuf = * ibuf ; ibuf -> ops = NULL ; opipe -> nrbufs ++ ; ipipe -> curbuf = ( ipipe -> curbuf + 1 ) & ( ipipe -> buffers - 1 ) ; ipipe -> nrbufs -- ; input_wakeup = true ; } else {  pipe_buf_get ( ipipe , ibuf ) ;  * obuf = * ibuf ; obuf -> flags &= ~ PIPE_BUF_FLAG_GIFT ; pipe_buf_mark_unmergeable ( obuf ) ; obuf -> len = len ; opipe -> nrbufs ++ ; ibuf -> offset += obuf -> len ; ibuf -> len -= obuf -> len ; } ret += obuf -> len ; len -= obuf -> len ; } while ( len ) ; pipe_unlock ( ipipe ) ; pipe_unlock ( opipe ) ; if ( ret > 0 ) wakeup_pipe_readers ( opipe ) ; if ( input_wakeup ) wakeup_pipe_writers ( ipipe ) ; return ret ; }","if ( ! pipe_buf_get ( ipipe , ibuf ) ) {if ( ret == 0 ) ret = - EFAULT ;break ;}* obuf = * ibuf ;",400
540,"buggy line: r_buf_set_bytes ( tbuf , buf , sz ) ;struct r_bin_bflt_obj * res = r_bin_bflt_new_buf ( tbuf ) ;cwe id:CWE-119context: static void * load_bytes ( RBinFile * arch , const ut8 * buf , ut64 sz , ut64 loaddr , Sdb * sdb ) { if ( ! buf || ! sz || sz == UT64_MAX ) { return NULL ; } RBuffer * tbuf = r_buf_new ( ) ;  r_buf_set_bytes ( tbuf , buf , sz ) ;  struct r_bin_bflt_obj * res = r_bin_bflt_new_buf ( tbuf ) ; r_buf_free ( tbuf ) ; return res ? res : NULL ; }","if ( ! tbuf ) {return NULL ;}r_buf_set_bytes ( tbuf , buf , sz ) ;struct r_bin_bflt_obj * res = r_bin_bflt_new_buf ( tbuf ) ;",401
541,"buggy line: mm_segment_t old_fs ;if ( ! ur ) return sys_wait4 ( pid , ustatus , options , NULL ) ;ret = sys_wait4 ( pid , ustatus , options , ( struct rusage __user * ) & r ) ;set_fs ( old_fs ) ;err |= __put_user ( r . ru_utime . tv_sec , & ur -> ru_utime . tv_sec ) ;err |= __put_user ( r . ru_utime . tv_usec , & ur -> ru_utime . tv_usec ) ;cwe id:CWE-264context: SYSCALL_DEFINE4 ( osf_wait4 , pid_t , pid , int __user * , ustatus , int , options , struct rusage32 __user * , ur ) { struct rusage r ; long ret , err ;  mm_segment_t old_fs ;  if ( ! ur ) return sys_wait4 ( pid , ustatus , options , NULL ) ; old_fs = get_fs ( ) ; set_fs ( KERNEL_DS ) ;  ret = sys_wait4 ( pid , ustatus , options , ( struct rusage __user * ) & r ) ;  set_fs ( old_fs ) ; if ( ! access_ok ( VERIFY_WRITE , ur , sizeof ( * ur ) ) ) return - EFAULT ; err = 0 ;  err |= __put_user ( r . ru_utime . tv_sec , & ur -> ru_utime . tv_sec ) ;  err |= __put_user ( r . ru_utime . tv_usec , & ur -> ru_utime . tv_usec ) ; err |= __put_user ( r . ru_stime . tv_sec , & ur -> ru_stime . tv_sec ) ; err |= __put_user ( r . ru_stime . tv_usec , & ur -> ru_stime . tv_usec ) ; err |= __put_user ( r . ru_maxrss , & ur -> ru_maxrss ) ; err |= __put_user ( r . ru_ixrss , & ur -> ru_ixrss ) ; err |= __put_user ( r . ru_idrss , & ur -> ru_idrss ) ; err |= __put_user ( r . ru_isrss , & ur -> ru_isrss ) ; err |= __put_user ( r . ru_minflt , & ur -> ru_minflt ) ; err |= __put_user ( r . ru_majflt , & ur -> ru_majflt ) ; err |= __put_user ( r . ru_nswap , & ur -> ru_nswap ) ; err |= __put_user ( r . ru_inblock , & ur -> ru_inblock ) ; err |= __put_user ( r . ru_oublock , & ur -> ru_oublock ) ; err |= __put_user ( r . ru_msgsnd , & ur -> ru_msgsnd ) ; err |= __put_user ( r . ru_msgrcv , & ur -> ru_msgrcv ) ; err |= __put_user ( r . ru_nsignals , & ur -> ru_nsignals ) ; err |= __put_user ( r . ru_nvcsw , & ur -> ru_nvcsw ) ; err |= __put_user ( r . ru_nivcsw , & ur -> ru_nivcsw ) ; return err ? err : ret ; }","unsigned int status = 0 ;mm_segment_t old_fs ;if ( ! ur ) return sys_wait4 ( pid , ( unsigned int __user * ) & status , options , NULL ) ;ret = sys_wait4 ( pid , ustatus , options , ( struct rusage __user * ) & r ) ;set_fs ( old_fs ) ;err |= put_user ( status , ustatus ) ;err |= __put_user ( r . ru_utime . tv_sec , & ur -> ru_utime . tv_sec ) ;err |= __put_user ( r . ru_utime . tv_usec , & ur -> ru_utime . tv_usec ) ;",402
542,"buggy line: ,  {LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/sys/net"" , ""%r/proc/net"" , NULL , MS_BIND , NULL },  {LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/sys"" , ""%r/proc/sys"" , NULL , MS_BIND , NULL }LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , NULL , ""%r/proc/sys"" , NULL , MS_REMOUNT | MS_BIND | MS_RDONLY , NULL },  {LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/net"" , ""%r/proc/sys/net"" , NULL , MS_MOVE , NULL },  {cwe id:CWE-59context: static int lxc_mount_auto_mounts ( struct lxc_conf * conf , int flags , struct lxc_handler * handler ) { int r ; size_t i ; static struct { int match_mask ; int match_flag ; const char * source ; const char * destination ; const char * fstype ; unsigned long flags ; const char * options ; } default_mounts [ ] = { { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""proc"" , ""%r/proc"" , ""proc"" , MS_NODEV | MS_NOEXEC | MS_NOSUID , NULL } ,  { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/sys/net"" , ""%r/proc/net"" , NULL , MS_BIND , NULL } ,  { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/sys"" , ""%r/proc/sys"" , NULL , MS_BIND , NULL } , { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , NULL , ""%r/proc/sys"" , NULL , MS_REMOUNT | MS_BIND | MS_RDONLY , NULL } ,  { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/net"" , ""%r/proc/sys/net"" , NULL , MS_MOVE , NULL } ,  { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/sysrq-trigger"" , ""%r/proc/sysrq-trigger"" , NULL , MS_BIND , NULL } , { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , NULL , ""%r/proc/sysrq-trigger"" , NULL , MS_REMOUNT | MS_BIND | MS_RDONLY , NULL } , { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_RW , ""proc"" , ""%r/proc"" , ""proc"" , MS_NODEV | MS_NOEXEC | MS_NOSUID , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_RW , ""sysfs"" , ""%r/sys"" , ""sysfs"" , 0 , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_RO , ""sysfs"" , ""%r/sys"" , ""sysfs"" , MS_RDONLY , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_MIXED , ""sysfs"" , ""%r/sys"" , ""sysfs"" , MS_NODEV | MS_NOEXEC | MS_NOSUID , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_MIXED , ""%r/sys"" , ""%r/sys"" , NULL , MS_BIND , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_MIXED , NULL , ""%r/sys"" , NULL , MS_REMOUNT | MS_BIND | MS_RDONLY , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_MIXED , ""sysfs"" , ""%r/sys/devices/virtual/net"" , ""sysfs"" , 0 , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_MIXED , ""%r/sys/devices/virtual/net/devices/virtual/net"" , ""%r/sys/devices/virtual/net"" , NULL , MS_BIND , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_MIXED , NULL , ""%r/sys/devices/virtual/net"" , NULL , MS_REMOUNT | MS_BIND | MS_NOSUID | MS_NODEV | MS_NOEXEC , NULL } , { 0 , 0 , NULL , NULL , NULL , 0 , NULL } } ; for ( i = 0 ; default_mounts [ i ] . match_mask ; i ++ ) { if ( ( flags & default_mounts [ i ] . match_mask ) == default_mounts [ i ] . match_flag ) { char * source = NULL ; char * destination = NULL ; int saved_errno ; unsigned long mflags ; if ( default_mounts [ i ] . source ) { source = lxc_string_replace ( ""%r"" , conf -> rootfs . path ? conf -> rootfs . mount : """" , default_mounts [ i ] . source ) ; if ( ! source ) { SYSERROR ( ""memory<S2SV_blank>allocation<S2SV_blank>error"" ) ; return - 1 ; } } if ( default_mounts [ i ] . destination ) { destination = lxc_string_replace ( ""%r"" , conf -> rootfs . path ? conf -> rootfs . mount : """" , default_mounts [ i ] . destination ) ; if ( ! destination ) { saved_errno = errno ; SYSERROR ( ""memory<S2SV_blank>allocation<S2SV_blank>error"" ) ; free ( source ) ; errno = saved_errno ; return - 1 ; } } mflags = add_required_remount_flags ( source , destination , default_mounts [ i ] . flags ) ;  r = mount ( source , destination , default_mounts [ i ] . fstype , mflags , default_mounts [ i ] . options ) ;  saved_errno = errno ; if ( r < 0 && errno == ENOENT ) { INFO ( ""Mount<S2SV_blank>source<S2SV_blank>or<S2SV_blank>target<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>doesn\'t<S2SV_blank>exist.<S2SV_blank>Skipping."" , source , destination ) ; r = 0 ; } else if ( r < 0 ) SYSERROR ( ""error<S2SV_blank>mounting<S2SV_blank>%s<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>flags<S2SV_blank>%lu"" , source , destination , mflags ) ; free ( source ) ; free ( destination ) ; if ( r < 0 ) { errno = saved_errno ; return - 1 ; } } } if ( flags & LXC_AUTO_CGROUP_MASK ) { int cg_flags ; cg_flags = flags & LXC_AUTO_CGROUP_MASK ; if ( cg_flags == LXC_AUTO_CGROUP_NOSPEC || cg_flags == LXC_AUTO_CGROUP_FULL_NOSPEC ) { int has_sys_admin = 0 ; if ( ! lxc_list_empty ( & conf -> keepcaps ) ) { has_sys_admin = in_caplist ( CAP_SYS_ADMIN , & conf -> keepcaps ) ; } else { has_sys_admin = ! in_caplist ( CAP_SYS_ADMIN , & conf -> caps ) ; } if ( cg_flags == LXC_AUTO_CGROUP_NOSPEC ) { cg_flags = has_sys_admin ? LXC_AUTO_CGROUP_RW : LXC_AUTO_CGROUP_MIXED ; } else { cg_flags = has_sys_admin ? LXC_AUTO_CGROUP_FULL_RW : LXC_AUTO_CGROUP_FULL_MIXED ; } } if ( ! cgroup_mount ( conf -> rootfs . path ? conf -> rootfs . mount : """" , handler , cg_flags ) ) { SYSERROR ( ""error<S2SV_blank>mounting<S2SV_blank>/sys/fs/cgroup"" ) ; return - 1 ; } } return 0 ; }","LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/sys/net"" , ""%r/proc/tty"" , NULL , MS_BIND , NULL }, {LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/tty"" , ""%r/proc/sys/net"" , NULL , MS_MOVE , NULL }, {",403
543,"buggy line: r = mount ( source , destination , default_mounts [ i ] . fstype , mflags , default_mounts [ i ] . options ) ;saved_errno = errno ;cwe id:CWE-59context: static int lxc_mount_auto_mounts ( struct lxc_conf * conf , int flags , struct lxc_handler * handler ) { int r ; size_t i ; static struct { int match_mask ; int match_flag ; const char * source ; const char * destination ; const char * fstype ; unsigned long flags ; const char * options ; } default_mounts [ ] = { { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""proc"" , ""%r/proc"" , ""proc"" , MS_NODEV | MS_NOEXEC | MS_NOSUID , NULL } ,  { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/sys/net"" , ""%r/proc/net"" , NULL , MS_BIND , NULL } ,  { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/sys"" , ""%r/proc/sys"" , NULL , MS_BIND , NULL } , { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , NULL , ""%r/proc/sys"" , NULL , MS_REMOUNT | MS_BIND | MS_RDONLY , NULL } ,  { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/net"" , ""%r/proc/sys/net"" , NULL , MS_MOVE , NULL } ,  { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/sysrq-trigger"" , ""%r/proc/sysrq-trigger"" , NULL , MS_BIND , NULL } , { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , NULL , ""%r/proc/sysrq-trigger"" , NULL , MS_REMOUNT | MS_BIND | MS_RDONLY , NULL } , { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_RW , ""proc"" , ""%r/proc"" , ""proc"" , MS_NODEV | MS_NOEXEC | MS_NOSUID , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_RW , ""sysfs"" , ""%r/sys"" , ""sysfs"" , 0 , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_RO , ""sysfs"" , ""%r/sys"" , ""sysfs"" , MS_RDONLY , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_MIXED , ""sysfs"" , ""%r/sys"" , ""sysfs"" , MS_NODEV | MS_NOEXEC | MS_NOSUID , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_MIXED , ""%r/sys"" , ""%r/sys"" , NULL , MS_BIND , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_MIXED , NULL , ""%r/sys"" , NULL , MS_REMOUNT | MS_BIND | MS_RDONLY , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_MIXED , ""sysfs"" , ""%r/sys/devices/virtual/net"" , ""sysfs"" , 0 , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_MIXED , ""%r/sys/devices/virtual/net/devices/virtual/net"" , ""%r/sys/devices/virtual/net"" , NULL , MS_BIND , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_MIXED , NULL , ""%r/sys/devices/virtual/net"" , NULL , MS_REMOUNT | MS_BIND | MS_NOSUID | MS_NODEV | MS_NOEXEC , NULL } , { 0 , 0 , NULL , NULL , NULL , 0 , NULL } } ; for ( i = 0 ; default_mounts [ i ] . match_mask ; i ++ ) { if ( ( flags & default_mounts [ i ] . match_mask ) == default_mounts [ i ] . match_flag ) { char * source = NULL ; char * destination = NULL ; int saved_errno ; unsigned long mflags ; if ( default_mounts [ i ] . source ) { source = lxc_string_replace ( ""%r"" , conf -> rootfs . path ? conf -> rootfs . mount : """" , default_mounts [ i ] . source ) ; if ( ! source ) { SYSERROR ( ""memory<S2SV_blank>allocation<S2SV_blank>error"" ) ; return - 1 ; } } if ( default_mounts [ i ] . destination ) { destination = lxc_string_replace ( ""%r"" , conf -> rootfs . path ? conf -> rootfs . mount : """" , default_mounts [ i ] . destination ) ; if ( ! destination ) { saved_errno = errno ; SYSERROR ( ""memory<S2SV_blank>allocation<S2SV_blank>error"" ) ; free ( source ) ; errno = saved_errno ; return - 1 ; } } mflags = add_required_remount_flags ( source , destination , default_mounts [ i ] . flags ) ;  r = mount ( source , destination , default_mounts [ i ] . fstype , mflags , default_mounts [ i ] . options ) ;  saved_errno = errno ; if ( r < 0 && errno == ENOENT ) { INFO ( ""Mount<S2SV_blank>source<S2SV_blank>or<S2SV_blank>target<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>doesn\'t<S2SV_blank>exist.<S2SV_blank>Skipping."" , source , destination ) ; r = 0 ; } else if ( r < 0 ) SYSERROR ( ""error<S2SV_blank>mounting<S2SV_blank>%s<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>flags<S2SV_blank>%lu"" , source , destination , mflags ) ; free ( source ) ; free ( destination ) ; if ( r < 0 ) { errno = saved_errno ; return - 1 ; } } } if ( flags & LXC_AUTO_CGROUP_MASK ) { int cg_flags ; cg_flags = flags & LXC_AUTO_CGROUP_MASK ; if ( cg_flags == LXC_AUTO_CGROUP_NOSPEC || cg_flags == LXC_AUTO_CGROUP_FULL_NOSPEC ) { int has_sys_admin = 0 ; if ( ! lxc_list_empty ( & conf -> keepcaps ) ) { has_sys_admin = in_caplist ( CAP_SYS_ADMIN , & conf -> keepcaps ) ; } else { has_sys_admin = ! in_caplist ( CAP_SYS_ADMIN , & conf -> caps ) ; } if ( cg_flags == LXC_AUTO_CGROUP_NOSPEC ) { cg_flags = has_sys_admin ? LXC_AUTO_CGROUP_RW : LXC_AUTO_CGROUP_MIXED ; } else { cg_flags = has_sys_admin ? LXC_AUTO_CGROUP_FULL_RW : LXC_AUTO_CGROUP_FULL_MIXED ; } } if ( ! cgroup_mount ( conf -> rootfs . path ? conf -> rootfs . mount : """" , handler , cg_flags ) ) { SYSERROR ( ""error<S2SV_blank>mounting<S2SV_blank>/sys/fs/cgroup"" ) ; return - 1 ; } } return 0 ; }","r = safe_mount ( source , destination , default_mounts [ i ] . fstype , mflags , default_mounts [ i ] . options , conf -> rootfs . path ? conf -> rootfs . mount : NULL ) ;saved_errno = errno ;",403
544,"buggy line: ke = & md -> chain [ ISAKMP_NEXT_v2KE ] -> payload . v2ke ;st -> st_oakley . group = lookup_group ( ke -> isak_group ) ;if ( st -> st_oakley . group == NULL ) {libreswan_log (  ""rejecting<S2SV_blank>I1<S2SV_blank>from<S2SV_blank>%s:%u,<S2SV_blank>invalid<S2SV_blank>DH<S2SV_blank>group=%u"" , fromname , md -> sender_port , ke -> isak_group ) ;return v2N_INVALID_KE_PAYLOAD ;}cwe id:CWE-20context: stf_status ikev2parent_inI1outR1 ( struct msg_digest * md ) { struct state * st = md -> st ; lset_t policy = POLICY_IKEV2_ALLOW ; struct connection * c = find_host_connection ( & md -> iface -> ip_addr , md -> iface -> port , & md -> sender , md -> sender_port , POLICY_IKEV2_ALLOW ) ; # if 0 if ( c == NULL ) { pb_stream pre_sa_pbs = sa_pd -> pbs ; policy = preparse_isakmp_sa_body ( & pre_sa_pbs ) ; c = find_host_connection ( & md -> iface -> ip_addr , pluto_port , ( ip_address * ) NULL , md -> sender_port , policy ) ; } # endif if ( c == NULL ) { { struct connection * d ; d = find_host_connection ( & md -> iface -> ip_addr , pluto_port , ( ip_address * ) NULL , md -> sender_port , policy ) ; for ( ; d != NULL ; d = d -> hp_next ) { if ( d -> kind == CK_GROUP ) { } else { if ( d -> kind == CK_TEMPLATE && ! ( d -> policy & POLICY_OPPO ) ) { c = d ; break ; } if ( addrinsubnet ( & md -> sender , & d -> spd . that . client ) && ( c == NULL || ! subnetinsubnet ( & c -> spd . that . client , & d -> spd . that . client ) ) ) c = d ; } } } if ( c == NULL ) { loglog ( RC_LOG_SERIOUS , ""initial<S2SV_blank>parent<S2SV_blank>SA<S2SV_blank>message<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s:%u"" ""<S2SV_blank>but<S2SV_blank>no<S2SV_blank>connection<S2SV_blank>has<S2SV_blank>been<S2SV_blank>authorized%s%s"" , ip_str ( & md -> iface -> ip_addr ) , ntohs ( portof ( & md -> iface -> ip_addr ) ) , ( policy != LEMPTY ) ? ""<S2SV_blank>with<S2SV_blank>policy="" : """" , ( policy != LEMPTY ) ? bitnamesof ( sa_policy_bit_names , policy ) : """" ) ; return STF_FAIL + v2N_NO_PROPOSAL_CHOSEN ; } if ( c -> kind != CK_TEMPLATE ) { loglog ( RC_LOG_SERIOUS , ""initial<S2SV_blank>parent<S2SV_blank>SA<S2SV_blank>message<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s:%u"" ""<S2SV_blank>but<S2SV_blank>\\""%s\\""<S2SV_blank>forbids<S2SV_blank>connection"" , ip_str ( & md -> iface -> ip_addr ) , pluto_port , c -> name ) ; return STF_FAIL + v2N_NO_PROPOSAL_CHOSEN ; } c = rw_instantiate ( c , & md -> sender , NULL , NULL ) ; } else { if ( ( c -> kind == CK_TEMPLATE ) && c -> spd . that . virt ) { DBG ( DBG_CONTROL , DBG_log ( ""local<S2SV_blank>endpoint<S2SV_blank>has<S2SV_blank>virt<S2SV_blank>(vnet/vhost)<S2SV_blank>set<S2SV_blank>without<S2SV_blank>wildcards<S2SV_blank>-<S2SV_blank>needs<S2SV_blank>instantiation"" ) ) ; c = rw_instantiate ( c , & md -> sender , NULL , NULL ) ; } else if ( ( c -> kind == CK_TEMPLATE ) && ( c -> policy & POLICY_IKEV2_ALLOW_NARROWING ) ) { DBG ( DBG_CONTROL , DBG_log ( ""local<S2SV_blank>endpoint<S2SV_blank>has<S2SV_blank>narrowing=yes<S2SV_blank>-<S2SV_blank>needs<S2SV_blank>instantiation"" ) ) ; c = rw_instantiate ( c , & md -> sender , NULL , NULL ) ; } } DBG_log ( ""found<S2SV_blank>connection:<S2SV_blank>%s\\n"" , c ? c -> name : ""<none>"" ) ; if ( ! st ) { st = new_state ( ) ; memcpy ( st -> st_icookie , md -> hdr . isa_icookie , COOKIE_SIZE ) ; get_cookie ( FALSE , st -> st_rcookie , COOKIE_SIZE , & md -> sender ) ; initialize_new_state ( st , c , policy , 0 , NULL_FD , pcim_stranger_crypto ) ; st -> st_ikev2 = TRUE ; change_state ( st , STATE_PARENT_R1 ) ; st -> st_msgid_lastack = INVALID_MSGID ; st -> st_msgid_nextuse = 0 ; md -> st = st ; md -> from_state = STATE_IKEv2_BASE ; } if ( force_busy == TRUE ) { u_char dcookie [ SHA1_DIGEST_SIZE ] ; chunk_t dc ; ikev2_get_dcookie ( dcookie , st -> st_ni , & md -> sender , st -> st_icookie ) ; dc . ptr = dcookie ; dc . len = SHA1_DIGEST_SIZE ; if ( md -> chain [ ISAKMP_NEXT_v2KE ] && md -> chain [ ISAKMP_NEXT_v2N ] && ( md -> chain [ ISAKMP_NEXT_v2N ] -> payload . v2n . isan_type == v2N_COOKIE ) ) { u_int8_t spisize ; const pb_stream * dc_pbs ; chunk_t blob ; DBG ( DBG_CONTROLMORE , DBG_log ( ""received<S2SV_blank>a<S2SV_blank>DOS<S2SV_blank>cookie<S2SV_blank>in<S2SV_blank>I1<S2SV_blank>verify<S2SV_blank>it"" ) ) ; spisize = md -> chain [ ISAKMP_NEXT_v2N ] -> payload . v2n . isan_spisize ; dc_pbs = & md -> chain [ ISAKMP_NEXT_v2N ] -> pbs ; blob . ptr = dc_pbs -> cur + spisize ; blob . len = pbs_left ( dc_pbs ) - spisize ; DBG ( DBG_CONTROLMORE , DBG_dump_chunk ( ""dcookie<S2SV_blank>received<S2SV_blank>in<S2SV_blank>I1<S2SV_blank>Packet"" , blob ) ; DBG_dump ( ""dcookie<S2SV_blank>computed"" , dcookie , SHA1_DIGEST_SIZE ) ) ; if ( memcmp ( blob . ptr , dcookie , SHA1_DIGEST_SIZE ) != 0 ) { libreswan_log ( ""mismatch<S2SV_blank>in<S2SV_blank>DOS<S2SV_blank>v2N_COOKIE,send<S2SV_blank>a<S2SV_blank>new<S2SV_blank>one"" ) ; SEND_NOTIFICATION_AA ( v2N_COOKIE , & dc ) ; return STF_FAIL + v2N_INVALID_IKE_SPI ; } DBG ( DBG_CONTROLMORE , DBG_log ( ""dcookie<S2SV_blank>received<S2SV_blank>match<S2SV_blank>with<S2SV_blank>computed<S2SV_blank>one"" ) ) ; } else { DBG ( DBG_CONTROLMORE , DBG_log ( ""busy<S2SV_blank>mode<S2SV_blank>on.<S2SV_blank>receieved<S2SV_blank>I1<S2SV_blank>without<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>dcookie"" ) ; DBG_log ( ""send<S2SV_blank>a<S2SV_blank>dcookie<S2SV_blank>and<S2SV_blank>forget<S2SV_blank>this<S2SV_blank>state"" ) ) ; SEND_NOTIFICATION_AA ( v2N_COOKIE , & dc ) ; return STF_FAIL ; } } else { DBG ( DBG_CONTROLMORE , DBG_log ( ""will<S2SV_blank>not<S2SV_blank>send/process<S2SV_blank>a<S2SV_blank>dcookie"" ) ) ; } { struct ikev2_ke * ke ;  ke = & md -> chain [ ISAKMP_NEXT_v2KE ] -> payload . v2ke ;  st -> st_oakley . group = lookup_group ( ke -> isak_group ) ; if ( st -> st_oakley . group == NULL ) { char fromname [ ADDRTOT_BUF ] ; addrtot ( & md -> sender , 0 , fromname , ADDRTOT_BUF ) ;  libreswan_log (  ""rejecting<S2SV_blank>I1<S2SV_blank>from<S2SV_blank>%s:%u,<S2SV_blank>invalid<S2SV_blank>DH<S2SV_blank>group=%u"" , fromname , md -> sender_port , ke -> isak_group ) ;  return v2N_INVALID_KE_PAYLOAD ;  } } { struct ke_continuation * ke = alloc_thing ( struct ke_continuation , ""ikev2_inI1outR1<S2SV_blank>KE"" ) ; stf_status e ; ke -> md = md ; set_suspended ( st , ke -> md ) ; if ( ! st -> st_sec_in_use ) { pcrc_init ( & ke -> ke_pcrc ) ; ke -> ke_pcrc . pcrc_func = ikev2_parent_inI1outR1_continue ; e = build_ke ( & ke -> ke_pcrc , st , st -> st_oakley . group , pcim_stranger_crypto ) ; if ( e != STF_SUSPEND && e != STF_INLINE ) { loglog ( RC_CRYPTOFAILED , ""system<S2SV_blank>too<S2SV_blank>busy"" ) ; delete_state ( st ) ; } } else { e = ikev2_parent_inI1outR1_tail ( ( struct pluto_crypto_req_cont * ) ke , NULL ) ; } reset_globals ( ) ; return e ; } }","libreswan_log ( ""rejecting<S2SV_blank>I1<S2SV_blank>from<S2SV_blank>%s:%u,<S2SV_blank>invalid<S2SV_blank>DH<S2SV_blank>group=%u"" , fromname , md -> sender_port , ke -> isak_group ) ;return STF_FAIL + v2N_INVALID_KE_PAYLOAD ;}",404
545,"buggy line: void nsc_encode ( NSC_CONTEXT * context , const BYTE * bmpdata , UINT32 rowstride )  {nsc_encode_argb_to_aycocg ( context , bmpdata , rowstride ) ;if ( context -> ChromaSubsamplingLevel ) {nsc_encode_subsampling ( context ) ;}cwe id:CWE-787context:  void nsc_encode ( NSC_CONTEXT * context , const BYTE * bmpdata , UINT32 rowstride )  {  nsc_encode_argb_to_aycocg ( context , bmpdata , rowstride ) ;  if ( context -> ChromaSubsamplingLevel ) {  nsc_encode_subsampling ( context ) ;  } }","BOOL nsc_encode ( NSC_CONTEXT * context , const BYTE * bmpdata , UINT32 rowstride ) {if ( ! context || ! bmpdata || ( rowstride == 0 ) ) return FALSE ;if ( ! nsc_encode_argb_to_aycocg ( context , bmpdata , rowstride ) ) return FALSE ;if ( context -> ChromaSubsamplingLevel ) {if ( ! nsc_encode_subsampling ( context ) ) return FALSE ;}return TRUE ;",405
546,"buggy line: void vp9_tree_probs_from_distribution ( vp9_tree tree ,  unsigned int branch_ct [ ] [ 2 ] , const unsigned int num_events [ ] ) {cwe id:CWE-119context:  void vp9_tree_probs_from_distribution ( vp9_tree tree ,  unsigned int branch_ct [ ] [ 2 ] , const unsigned int num_events [ ] ) { convert_distribution ( 0 , tree , branch_ct , num_events ) ; }","void vp9_tree_probs_from_distribution ( vpx_tree tree , unsigned int branch_ct [ ] [ 2 ] , const unsigned int num_events [ ] ) {",406
547,buggy line: if ( stringset == ETH_SS_STATS )  return ARRAY_SIZE ( g_xgmac_stats_string ) ;cwe id:CWE-119context: static int hns_xgmac_get_sset_count ( int stringset ) {  if ( stringset == ETH_SS_STATS )  return ARRAY_SIZE ( g_xgmac_stats_string ) ; return 0 ; },if ( stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS ) return ARRAY_SIZE ( g_xgmac_stats_string ) ;,407
548,buggy line: if ( image -> depth == 1 )  return ( ( image -> columns + 7 ) / 8 ) ;else return ( image -> columns * GetPSDPacketSize ( image ) ) ;cwe id:CWE-125context: static inline size_t GetPSDRowSize ( Image * image ) { if ( image -> depth == 1 )  return ( ( image -> columns + 7 ) / 8 ) ;  else return ( image -> columns * GetPSDPacketSize ( image ) ) ; },if ( image -> depth == 1 ) return ( ( ( image -> columns + 7 ) / 8 ) * GetPSDPacketSize ( image ) ) ;else return ( image -> columns * GetPSDPacketSize ( image ) ) ;,408
549,"buggy line: p_dev -> fd = open ( dev_path , O_RDWR | O_CLOEXEC ) ;if ( p_dev -> fd < 0 ) {cwe id:CWE-284context: void bta_hh_co_open ( UINT8 dev_handle , UINT8 sub_class , tBTA_HH_ATTR_MASK attr_mask , UINT8 app_id ) { UINT32 i ; btif_hh_device_t * p_dev = NULL ; if ( dev_handle == BTA_HH_INVALID_HANDLE ) { APPL_TRACE_WARNING ( ""%s:<S2SV_blank>Oops,<S2SV_blank>dev_handle<S2SV_blank>(%d)<S2SV_blank>is<S2SV_blank>invalid..."" , __FUNCTION__ , dev_handle ) ; return ; } for ( i = 0 ; i < BTIF_HH_MAX_HID ; i ++ ) { p_dev = & btif_hh_cb . devices [ i ] ; if ( p_dev -> dev_status != BTHH_CONN_STATE_UNKNOWN && p_dev -> dev_handle == dev_handle ) { APPL_TRACE_WARNING ( ""%s:<S2SV_blank>Found<S2SV_blank>an<S2SV_blank>existing<S2SV_blank>device<S2SV_blank>with<S2SV_blank>the<S2SV_blank>same<S2SV_blank>handle<S2SV_blank>"" ""dev_status<S2SV_blank>=<S2SV_blank>%d"" , __FUNCTION__ , p_dev -> dev_status ) ; APPL_TRACE_WARNING ( ""%s:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>bd_addr<S2SV_blank>=<S2SV_blank>[%02X:%02X:%02X:%02X:%02X:]"" , __FUNCTION__ , p_dev -> bd_addr . address [ 0 ] , p_dev -> bd_addr . address [ 1 ] , p_dev -> bd_addr . address [ 2 ] , p_dev -> bd_addr . address [ 3 ] , p_dev -> bd_addr . address [ 4 ] ) ; APPL_TRACE_WARNING ( ""%s:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>attr_mask<S2SV_blank>=<S2SV_blank>0x%04x,<S2SV_blank>sub_class<S2SV_blank>=<S2SV_blank>0x%02x,<S2SV_blank>app_id<S2SV_blank>=<S2SV_blank>%d"" , __FUNCTION__ , p_dev -> attr_mask , p_dev -> sub_class , p_dev -> app_id ) ; if ( p_dev -> fd < 0 ) {  p_dev -> fd = open ( dev_path , O_RDWR | O_CLOEXEC ) ;  if ( p_dev -> fd < 0 ) { APPL_TRACE_ERROR ( ""%s:<S2SV_blank>Error:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>uhid,<S2SV_blank>err:%s"" , __FUNCTION__ , strerror ( errno ) ) ; return ; } else APPL_TRACE_DEBUG ( ""%s:<S2SV_blank>uhid<S2SV_blank>fd<S2SV_blank>=<S2SV_blank>%d"" , __FUNCTION__ , p_dev -> fd ) ; } p_dev -> hh_keep_polling = 1 ; p_dev -> hh_poll_thread_id = create_thread ( btif_hh_poll_event_thread , p_dev ) ; break ; } p_dev = NULL ; } if ( p_dev == NULL ) { for ( i = 0 ; i < BTIF_HH_MAX_HID ; i ++ ) { if ( btif_hh_cb . devices [ i ] . dev_status == BTHH_CONN_STATE_UNKNOWN ) { p_dev = & btif_hh_cb . devices [ i ] ; p_dev -> dev_handle = dev_handle ; p_dev -> attr_mask = attr_mask ; p_dev -> sub_class = sub_class ; p_dev -> app_id = app_id ; p_dev -> local_vup = FALSE ; btif_hh_cb . device_num ++ ;  p_dev -> fd = open ( dev_path , O_RDWR | O_CLOEXEC ) ;  if ( p_dev -> fd < 0 ) { APPL_TRACE_ERROR ( ""%s:<S2SV_blank>Error:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>uhid,<S2SV_blank>err:%s"" , __FUNCTION__ , strerror ( errno ) ) ; return ; } else { APPL_TRACE_DEBUG ( ""%s:<S2SV_blank>uhid<S2SV_blank>fd<S2SV_blank>=<S2SV_blank>%d"" , __FUNCTION__ , p_dev -> fd ) ; p_dev -> hh_keep_polling = 1 ; p_dev -> hh_poll_thread_id = create_thread ( btif_hh_poll_event_thread , p_dev ) ; } break ; } } } if ( p_dev == NULL ) { APPL_TRACE_ERROR ( ""%s:<S2SV_blank>Error:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>HID<S2SV_blank>devices<S2SV_blank>are<S2SV_blank>connected"" , __FUNCTION__ ) ; return ; } p_dev -> dev_status = BTHH_CONN_STATE_CONNECTED ; APPL_TRACE_DEBUG ( ""%s:<S2SV_blank>Return<S2SV_blank>device<S2SV_blank>status<S2SV_blank>%d"" , __FUNCTION__ , p_dev -> dev_status ) ; }","p_dev -> fd = TEMP_FAILURE_RETRY ( open ( dev_path , O_RDWR | O_CLOEXEC ) ) ;if ( p_dev -> fd < 0 ) {",409
550,"buggy line: p_dev -> fd = open ( dev_path , O_RDWR | O_CLOEXEC ) ;if ( p_dev -> fd < 0 ) {cwe id:CWE-284context: void bta_hh_co_open ( UINT8 dev_handle , UINT8 sub_class , tBTA_HH_ATTR_MASK attr_mask , UINT8 app_id ) { UINT32 i ; btif_hh_device_t * p_dev = NULL ; if ( dev_handle == BTA_HH_INVALID_HANDLE ) { APPL_TRACE_WARNING ( ""%s:<S2SV_blank>Oops,<S2SV_blank>dev_handle<S2SV_blank>(%d)<S2SV_blank>is<S2SV_blank>invalid..."" , __FUNCTION__ , dev_handle ) ; return ; } for ( i = 0 ; i < BTIF_HH_MAX_HID ; i ++ ) { p_dev = & btif_hh_cb . devices [ i ] ; if ( p_dev -> dev_status != BTHH_CONN_STATE_UNKNOWN && p_dev -> dev_handle == dev_handle ) { APPL_TRACE_WARNING ( ""%s:<S2SV_blank>Found<S2SV_blank>an<S2SV_blank>existing<S2SV_blank>device<S2SV_blank>with<S2SV_blank>the<S2SV_blank>same<S2SV_blank>handle<S2SV_blank>"" ""dev_status<S2SV_blank>=<S2SV_blank>%d"" , __FUNCTION__ , p_dev -> dev_status ) ; APPL_TRACE_WARNING ( ""%s:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>bd_addr<S2SV_blank>=<S2SV_blank>[%02X:%02X:%02X:%02X:%02X:]"" , __FUNCTION__ , p_dev -> bd_addr . address [ 0 ] , p_dev -> bd_addr . address [ 1 ] , p_dev -> bd_addr . address [ 2 ] , p_dev -> bd_addr . address [ 3 ] , p_dev -> bd_addr . address [ 4 ] ) ; APPL_TRACE_WARNING ( ""%s:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>attr_mask<S2SV_blank>=<S2SV_blank>0x%04x,<S2SV_blank>sub_class<S2SV_blank>=<S2SV_blank>0x%02x,<S2SV_blank>app_id<S2SV_blank>=<S2SV_blank>%d"" , __FUNCTION__ , p_dev -> attr_mask , p_dev -> sub_class , p_dev -> app_id ) ; if ( p_dev -> fd < 0 ) {  p_dev -> fd = open ( dev_path , O_RDWR | O_CLOEXEC ) ;  if ( p_dev -> fd < 0 ) { APPL_TRACE_ERROR ( ""%s:<S2SV_blank>Error:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>uhid,<S2SV_blank>err:%s"" , __FUNCTION__ , strerror ( errno ) ) ; return ; } else APPL_TRACE_DEBUG ( ""%s:<S2SV_blank>uhid<S2SV_blank>fd<S2SV_blank>=<S2SV_blank>%d"" , __FUNCTION__ , p_dev -> fd ) ; } p_dev -> hh_keep_polling = 1 ; p_dev -> hh_poll_thread_id = create_thread ( btif_hh_poll_event_thread , p_dev ) ; break ; } p_dev = NULL ; } if ( p_dev == NULL ) { for ( i = 0 ; i < BTIF_HH_MAX_HID ; i ++ ) { if ( btif_hh_cb . devices [ i ] . dev_status == BTHH_CONN_STATE_UNKNOWN ) { p_dev = & btif_hh_cb . devices [ i ] ; p_dev -> dev_handle = dev_handle ; p_dev -> attr_mask = attr_mask ; p_dev -> sub_class = sub_class ; p_dev -> app_id = app_id ; p_dev -> local_vup = FALSE ; btif_hh_cb . device_num ++ ;  p_dev -> fd = open ( dev_path , O_RDWR | O_CLOEXEC ) ;  if ( p_dev -> fd < 0 ) { APPL_TRACE_ERROR ( ""%s:<S2SV_blank>Error:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>uhid,<S2SV_blank>err:%s"" , __FUNCTION__ , strerror ( errno ) ) ; return ; } else { APPL_TRACE_DEBUG ( ""%s:<S2SV_blank>uhid<S2SV_blank>fd<S2SV_blank>=<S2SV_blank>%d"" , __FUNCTION__ , p_dev -> fd ) ; p_dev -> hh_keep_polling = 1 ; p_dev -> hh_poll_thread_id = create_thread ( btif_hh_poll_event_thread , p_dev ) ; } break ; } } } if ( p_dev == NULL ) { APPL_TRACE_ERROR ( ""%s:<S2SV_blank>Error:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>HID<S2SV_blank>devices<S2SV_blank>are<S2SV_blank>connected"" , __FUNCTION__ ) ; return ; } p_dev -> dev_status = BTHH_CONN_STATE_CONNECTED ; APPL_TRACE_DEBUG ( ""%s:<S2SV_blank>Return<S2SV_blank>device<S2SV_blank>status<S2SV_blank>%d"" , __FUNCTION__ , p_dev -> dev_status ) ; }","p_dev -> fd = TEMP_FAILURE_RETRY ( open ( dev_path , O_RDWR | O_CLOEXEC ) ) ;if ( p_dev -> fd < 0 ) {",409
551,"buggy line: alt = pcu -> ctrl_intf -> cur_altsetting ;pcu -> ep_ctrl = & alt -> endpoint [ 0 ] . desc ;alt = pcu -> data_intf -> cur_altsetting ;if ( alt -> desc . bNumEndpoints != 2 ) {cwe id:CWE-000context: static int ims_pcu_parse_cdc_data ( struct usb_interface * intf , struct ims_pcu * pcu ) { const struct usb_cdc_union_desc * union_desc ; struct usb_host_interface * alt ; union_desc = ims_pcu_get_cdc_union_desc ( intf ) ; if ( ! union_desc ) return - EINVAL ; pcu -> ctrl_intf = usb_ifnum_to_if ( pcu -> udev , union_desc -> bMasterInterface0 ) ;  alt = pcu -> ctrl_intf -> cur_altsetting ;  pcu -> ep_ctrl = & alt -> endpoint [ 0 ] . desc ; pcu -> max_ctrl_size = usb_endpoint_maxp ( pcu -> ep_ctrl ) ; pcu -> data_intf = usb_ifnum_to_if ( pcu -> udev , union_desc -> bSlaveInterface0 ) ;  alt = pcu -> data_intf -> cur_altsetting ;  if ( alt -> desc . bNumEndpoints != 2 ) { dev_err ( pcu -> dev , ""Incorrect<S2SV_blank>number<S2SV_blank>of<S2SV_blank>endpoints<S2SV_blank>on<S2SV_blank>data<S2SV_blank>interface<S2SV_blank>(%d)\\n"" , alt -> desc . bNumEndpoints ) ; return - EINVAL ; } pcu -> ep_out = & alt -> endpoint [ 0 ] . desc ; if ( ! usb_endpoint_is_bulk_out ( pcu -> ep_out ) ) { dev_err ( pcu -> dev , ""First<S2SV_blank>endpoint<S2SV_blank>on<S2SV_blank>data<S2SV_blank>interface<S2SV_blank>is<S2SV_blank>not<S2SV_blank>BULK<S2SV_blank>OUT\\n"" ) ; return - EINVAL ; } pcu -> max_out_size = usb_endpoint_maxp ( pcu -> ep_out ) ; if ( pcu -> max_out_size < 8 ) { dev_err ( pcu -> dev , ""Max<S2SV_blank>OUT<S2SV_blank>packet<S2SV_blank>size<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>(%zd)\\n"" , pcu -> max_out_size ) ; return - EINVAL ; } pcu -> ep_in = & alt -> endpoint [ 1 ] . desc ; if ( ! usb_endpoint_is_bulk_in ( pcu -> ep_in ) ) { dev_err ( pcu -> dev , ""Second<S2SV_blank>endpoint<S2SV_blank>on<S2SV_blank>data<S2SV_blank>interface<S2SV_blank>is<S2SV_blank>not<S2SV_blank>BULK<S2SV_blank>IN\\n"" ) ; return - EINVAL ; } pcu -> max_in_size = usb_endpoint_maxp ( pcu -> ep_in ) ; if ( pcu -> max_in_size < 8 ) { dev_err ( pcu -> dev , ""Max<S2SV_blank>IN<S2SV_blank>packet<S2SV_blank>size<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>(%zd)\\n"" , pcu -> max_in_size ) ; return - EINVAL ; } return 0 ; }",if ( ! pcu -> ctrl_intf ) return - EINVAL ;alt = pcu -> ctrl_intf -> cur_altsetting ;pcu -> ep_ctrl = & alt -> endpoint [ 0 ] . desc ;if ( ! pcu -> data_intf ) return - EINVAL ;alt = pcu -> data_intf -> cur_altsetting ;if ( alt -> desc . bNumEndpoints != 2 ) {,410
552,"buggy line: const char * name = d -> name ;struct device dev = d -> udev -> dev ;dev_dbg ( & d -> udev -> dev , ""%s:<S2SV_blank>bInterfaceNumber=%d\\\dvb_usbv2_exit ( d ) ;dev_info ( & dev , ""%s:<S2SV_blank>\\\'%s\\\'<S2SV_blank>successfully<S2SV_blank>deinitialized<S2SV_blank>and<S2SV_blank>disconnected\\\}cwe id:CWE-119context: void dvb_usbv2_disconnect ( struct usb_interface * intf ) { struct dvb_usb_device * d = usb_get_intfdata ( intf ) ;  const char * name = d -> name ;   struct device dev = d -> udev -> dev ;  dev_dbg ( & d -> udev -> dev , ""%s:<S2SV_blank>bInterfaceNumber=%d\\n"" , __func__ , intf -> cur_altsetting -> desc . bInterfaceNumber ) ; if ( d -> props -> exit ) d -> props -> exit ( d ) ; dvb_usbv2_exit ( d ) ;  dev_info ( & dev , ""%s:<S2SV_blank>\'%s\'<S2SV_blank>successfully<S2SV_blank>deinitialized<S2SV_blank>and<S2SV_blank>disconnected\\n"" ,   KBUILD_MODNAME , name ) ;  }","const char * devname = kstrdup ( dev_name ( & d -> udev -> dev ) , GFP_KERNEL ) ;const char * drvname = d -> name ;dev_dbg ( & d -> udev -> dev , ""%s:<S2SV_blank>bInterfaceNumber=%d\\\pr_info ( ""%s:<S2SV_blank>\\\'%s:%s\\\'<S2SV_blank>successfully<S2SV_blank>deinitialized<S2SV_blank>and<S2SV_blank>disconnected\\\}",411
553,"buggy line: xstep = picomp -> hsamp * ( 1 <<  ( pirlvl -> prcwidthexpn + picomp -> numrlvls - rlvlno - 1 ) ) ;ystep = picomp -> vsamp * ( 1 <<  ( pirlvl -> prcheightexpn + picomp -> numrlvls - rlvlno - 1 ) ) ;cwe id:CWE-125context: static int jpc_pi_nextpcrl ( register jpc_pi_t * pi ) { int rlvlno ; jpc_pirlvl_t * pirlvl ; jpc_pchg_t * pchg ; int prchind ; int prcvind ; int * prclyrno ; int compno ; jpc_picomp_t * picomp ; int xstep ; int ystep ; uint_fast32_t trx0 ; uint_fast32_t try0 ; uint_fast32_t r ; uint_fast32_t rpx ; uint_fast32_t rpy ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { goto skip ; } else { pi -> xstep = 0 ; pi -> ystep = 0 ; for ( compno = 0 , picomp = pi -> picomps ; compno < pi -> numcomps ; ++ compno , ++ picomp ) { for ( rlvlno = 0 , pirlvl = picomp -> pirlvls ; rlvlno < picomp -> numrlvls ; ++ rlvlno , ++ pirlvl ) {  xstep = picomp -> hsamp * ( 1 <<  ( pirlvl -> prcwidthexpn + picomp -> numrlvls - rlvlno - 1 ) ) ;  ystep = picomp -> vsamp * ( 1 <<  ( pirlvl -> prcheightexpn + picomp -> numrlvls - rlvlno - 1 ) ) ; pi -> xstep = ( ! pi -> xstep ) ? xstep : JAS_MIN ( pi -> xstep , xstep ) ; pi -> ystep = ( ! pi -> ystep ) ? ystep : JAS_MIN ( pi -> ystep , ystep ) ; } } pi -> prgvolfirst = 0 ; } for ( pi -> y = pi -> ystart ; pi -> y < pi -> yend ; pi -> y += pi -> ystep - ( pi -> y % pi -> ystep ) ) { for ( pi -> x = pi -> xstart ; pi -> x < pi -> xend ; pi -> x += pi -> xstep - ( pi -> x % pi -> xstep ) ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { for ( pi -> rlvlno = pchg -> rlvlnostart , pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; pi -> rlvlno < pi -> picomp -> numrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno , ++ pi -> pirlvl ) { if ( pi -> pirlvl -> numprcs == 0 ) { continue ; } r = pi -> picomp -> numrlvls - 1 - pi -> rlvlno ; trx0 = JPC_CEILDIV ( pi -> xstart , pi -> picomp -> hsamp << r ) ; try0 = JPC_CEILDIV ( pi -> ystart , pi -> picomp -> vsamp << r ) ; rpx = r + pi -> pirlvl -> prcwidthexpn ; rpy = r + pi -> pirlvl -> prcheightexpn ;  if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( 1 << rpx ) ) ) ||  ! ( pi -> x % ( pi -> picomp -> hsamp << rpx ) ) ) &&  ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( 1 << rpy ) ) ) ||  ! ( pi -> y % ( pi -> picomp -> vsamp << rpy ) ) ) ) { prchind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> x , pi -> picomp -> hsamp << r ) , pi -> pirlvl -> prcwidthexpn ) - JPC_FLOORDIVPOW2 ( trx0 , pi -> pirlvl -> prcwidthexpn ) ; prcvind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> y , pi -> picomp -> vsamp << r ) , pi -> pirlvl -> prcheightexpn ) - JPC_FLOORDIVPOW2 ( try0 , pi -> pirlvl -> prcheightexpn ) ; pi -> prcno = prcvind * pi -> pirlvl -> numhprcs + prchind ; assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; if ( pi -> lyrno >= * prclyrno ) { ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } } } return 1 ; }","if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) {return - 1 ;}xstep = picomp -> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcwidthexpn + picomp -> numrlvls - rlvlno - 1 ) ) ;ystep = picomp -> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcheightexpn + picomp -> numrlvls - rlvlno - 1 ) ) ;",412
554,"buggy line: if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( 1 << rpx ) ) ) ||  ! ( pi -> x % ( pi -> picomp -> hsamp << rpx ) ) ) &&  ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( 1 << rpy ) ) ) ||  ! ( pi -> y % ( pi -> picomp -> vsamp << rpy ) ) ) ) {cwe id:CWE-125context: static int jpc_pi_nextpcrl ( register jpc_pi_t * pi ) { int rlvlno ; jpc_pirlvl_t * pirlvl ; jpc_pchg_t * pchg ; int prchind ; int prcvind ; int * prclyrno ; int compno ; jpc_picomp_t * picomp ; int xstep ; int ystep ; uint_fast32_t trx0 ; uint_fast32_t try0 ; uint_fast32_t r ; uint_fast32_t rpx ; uint_fast32_t rpy ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { goto skip ; } else { pi -> xstep = 0 ; pi -> ystep = 0 ; for ( compno = 0 , picomp = pi -> picomps ; compno < pi -> numcomps ; ++ compno , ++ picomp ) { for ( rlvlno = 0 , pirlvl = picomp -> pirlvls ; rlvlno < picomp -> numrlvls ; ++ rlvlno , ++ pirlvl ) {  xstep = picomp -> hsamp * ( 1 <<  ( pirlvl -> prcwidthexpn + picomp -> numrlvls - rlvlno - 1 ) ) ;  ystep = picomp -> vsamp * ( 1 <<  ( pirlvl -> prcheightexpn + picomp -> numrlvls - rlvlno - 1 ) ) ; pi -> xstep = ( ! pi -> xstep ) ? xstep : JAS_MIN ( pi -> xstep , xstep ) ; pi -> ystep = ( ! pi -> ystep ) ? ystep : JAS_MIN ( pi -> ystep , ystep ) ; } } pi -> prgvolfirst = 0 ; } for ( pi -> y = pi -> ystart ; pi -> y < pi -> yend ; pi -> y += pi -> ystep - ( pi -> y % pi -> ystep ) ) { for ( pi -> x = pi -> xstart ; pi -> x < pi -> xend ; pi -> x += pi -> xstep - ( pi -> x % pi -> xstep ) ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { for ( pi -> rlvlno = pchg -> rlvlnostart , pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; pi -> rlvlno < pi -> picomp -> numrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno , ++ pi -> pirlvl ) { if ( pi -> pirlvl -> numprcs == 0 ) { continue ; } r = pi -> picomp -> numrlvls - 1 - pi -> rlvlno ; trx0 = JPC_CEILDIV ( pi -> xstart , pi -> picomp -> hsamp << r ) ; try0 = JPC_CEILDIV ( pi -> ystart , pi -> picomp -> vsamp << r ) ; rpx = r + pi -> pirlvl -> prcwidthexpn ; rpy = r + pi -> pirlvl -> prcheightexpn ;  if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( 1 << rpx ) ) ) ||  ! ( pi -> x % ( pi -> picomp -> hsamp << rpx ) ) ) &&  ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( 1 << rpy ) ) ) ||  ! ( pi -> y % ( pi -> picomp -> vsamp << rpy ) ) ) ) { prchind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> x , pi -> picomp -> hsamp << r ) , pi -> pirlvl -> prcwidthexpn ) - JPC_FLOORDIVPOW2 ( trx0 , pi -> pirlvl -> prcwidthexpn ) ; prcvind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> y , pi -> picomp -> vsamp << r ) , pi -> pirlvl -> prcheightexpn ) - JPC_FLOORDIVPOW2 ( try0 , pi -> pirlvl -> prcheightexpn ) ; pi -> prcno = prcvind * pi -> pirlvl -> numhprcs + prchind ; assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; if ( pi -> lyrno >= * prclyrno ) { ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } } } return 1 ; }","if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( JAS_CAST ( uint_fast32_t , 1 ) << rpx ) ) ) || ! ( pi -> x % ( pi -> picomp -> hsamp << rpx ) ) ) && ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( JAS_CAST ( uint_fast32_t , 1 ) << rpy ) ) ) || ! ( pi -> y % ( pi -> picomp -> vsamp << rpy ) ) ) ) {",412
555,"buggy line: r = conv_encoding ( ci -> pattern_enc , ci -> target_enc , pattern , pattern_end ,  & cpat , & cpat_end ) ;if ( r != 0 ) return r ;cwe id:CWE-416context: extern int onig_new_deluxe ( regex_t * * reg , const UChar * pattern , const UChar * pattern_end , OnigCompileInfo * ci , OnigErrorInfo * einfo ) { int r ; UChar * cpat , * cpat_end ; if ( IS_NOT_NULL ( einfo ) ) einfo -> par = ( UChar * ) NULL ; if ( ci -> pattern_enc != ci -> target_enc ) {  r = conv_encoding ( ci -> pattern_enc , ci -> target_enc , pattern , pattern_end ,  & cpat , & cpat_end ) ; if ( r != 0 ) return r ; } else { cpat = ( UChar * ) pattern ; cpat_end = ( UChar * ) pattern_end ; } * reg = ( regex_t * ) xmalloc ( sizeof ( regex_t ) ) ; if ( IS_NULL ( * reg ) ) { r = ONIGERR_MEMORY ; goto err2 ; } r = onig_reg_init ( * reg , ci -> option , ci -> case_fold_flag , ci -> target_enc , ci -> syntax ) ; if ( r != 0 ) goto err ; r = onig_compile ( * reg , cpat , cpat_end , einfo ) ; if ( r != 0 ) { err : onig_free ( * reg ) ; * reg = NULL ; } err2 : if ( cpat != pattern ) xfree ( cpat ) ; return r ; }",return ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION ;,413
556,"buggy line: static void InsertRow ( Image * image , ssize_t depth , unsigned char * p , ssize_t y ,  ExceptionInfo * exception ) {size_t bit ;ssize_t x ;register Quantum * q ;Quantum index ;switch ( depth )  {q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;index = ( Quantum ) ( ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ) ? 0x01 : 0x00 ) ;SetPixelIndex ( image , index , q ) ;q += GetPixelChannels ( image ) ;}for ( bit = 0 ;bit ++ )  {index = ( Quantum ) ( ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ) ? 0x01 : 0x00 ) ;SetPixelIndex ( image , index , q ) ;q += GetPixelChannels ( image ) ;}( void ) SyncAuthenticPixels ( image , exception ) ;break ;q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL )  break ;index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ;SetPixelIndex ( image , index , q ) ;q += GetPixelChannels ( image ) ;index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ;SetPixelIndex ( image , index , q ) ;q += GetPixelChannels ( image ) ;index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ;cwe id:CWE-787context:  static void InsertRow ( Image * image , ssize_t depth , unsigned char * p , ssize_t y ,  ExceptionInfo * exception ) {  size_t bit ; ssize_t x ;   register Quantum * q ;  Quantum index ; index = 0 ;  switch ( depth )  { case 1 : {  q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;  if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) {  index = ( Quantum ) ( ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ) ? 0x01 : 0x00 ) ;  SetPixelIndex ( image , index , q ) ;  q += GetPixelChannels ( image ) ;  } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) {  for ( bit = 0 ; bit < ( image -> columns % 8 ) ; bit ++ )  {  index = ( Quantum ) ( ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ) ? 0x01 : 0x00 ) ;  SetPixelIndex ( image , index , q ) ;  q += GetPixelChannels ( image ) ;  } p ++ ; }  ( void ) SyncAuthenticPixels ( image , exception ) ;  break ; } case 2 : {  q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;   if ( q == ( Quantum * ) NULL )  break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) {  index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ;  SetPixelIndex ( image , index , q ) ;  q += GetPixelChannels ( image ) ;   index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ;  SetPixelIndex ( image , index , q ) ;  q += GetPixelChannels ( image ) ;  index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; } if ( ( image -> columns % 4 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; if ( ( image -> columns % 4 ) >= 1 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; if ( ( image -> columns % 4 ) >= 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } } p ++ ; } ( void ) SyncAuthenticPixels ( image , exception ) ; break ; } case 4 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0xf , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p ) & 0xf , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; } if ( ( image -> columns % 2 ) != 0 ) {  index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0xf , exception ) ;  SetPixelIndex ( image , index , q ) ;  q += GetPixelChannels ( image ) ;   p ++ ;  } ( void ) SyncAuthenticPixels ( image , exception ) ; break ; } case 8 : {  q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;   if ( q == ( Quantum * ) NULL )  break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) {  index = ConstrainColormapIndex ( image , * p , exception ) ;  SetPixelIndex ( image , index , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } ( void ) SyncAuthenticPixels ( image , exception ) ; break ; } } }","static MagickBooleanType InsertRow ( Image * image , ssize_t bpp , unsigned char * p , ssize_t y , ExceptionInfo * exception ) {int bit ;Quantum index ;register Quantum * q ;Quantum index ;switch ( bpp ) {index = ( ( * p ) & ( 0x80 >> bit ) ) != 0 ) ? 0x01 : 0x00 ) ;SetPixelIndex ( image , index , q ) ;q += GetPixelChannels ( image ) ;}for ( bit = 0 ;bit ++ ) {index = ( Quantum ) ( ( ( ( * p ) & ( 0x80 >> bit ) ? 0x01 : 0x00 ) ;SetPixelIndex ( image , index , q ) ;if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ;if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ;SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ;q += GetPixelChannels ( image ) ;}break ;q = QueueAuthenticPixels ( image , 0 , y , image -> columns - 3 ) ;x += 4 ) {index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ;SetPixelIndex ( image , index , q ) ;if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ;q += GetPixelChannels ( image ) ;if ( ( image -> columns % 4 ) > 2 ) {index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ;SetPixelIndex ( image , index , q ) ;if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ;q += GetPixelChannels ( image ) ;}}p ++ ;}break ;}case 4 : {index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ;SetPixelIndex ( image , index , q ) ;q += GetPixelChannels ( image ) ;index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ;SetPixelIndex ( image , index , q ) ;q += GetPixelChannels ( image ) ;index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ;",414
557,"buggy line: index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ;index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ;q += GetPixelChannels ( image ) ;}}( void ) SyncAuthenticPixels ( image , exception ) ;break ;}case 4 : {q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;for ( x = 0 ;x < ( ( ssize_t ) image -> columns - 1 ) ;x += 2 ) {q += GetPixelChannels ( image ) ;index = ConstrainColormapIndex ( image , ( * p ) & 0xf , exception ) ;SetPixelIndex ( image , index , q ) ;if ( ( image -> columns % 2 ) != 0 ) {index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0xf , exception ) ;SetPixelIndex ( image , index , q ) ;q += GetPixelChannels ( image ) ;p ++ ;}q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL )  break ;index = ConstrainColormapIndex ( image , * p , exception ) ;SetPixelIndex ( image , index , q ) ;( void ) SyncAuthenticPixels ( image , exception ) ;cwe id:CWE-787context:  static void InsertRow ( Image * image , ssize_t depth , unsigned char * p , ssize_t y ,  ExceptionInfo * exception ) {  size_t bit ; ssize_t x ;   register Quantum * q ;  Quantum index ; index = 0 ;  switch ( depth )  { case 1 : {  q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;  if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) {  index = ( Quantum ) ( ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ) ? 0x01 : 0x00 ) ;  SetPixelIndex ( image , index , q ) ;  q += GetPixelChannels ( image ) ;  } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) {  for ( bit = 0 ; bit < ( image -> columns % 8 ) ; bit ++ )  {  index = ( Quantum ) ( ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ) ? 0x01 : 0x00 ) ;  SetPixelIndex ( image , index , q ) ;  q += GetPixelChannels ( image ) ;  } p ++ ; }  ( void ) SyncAuthenticPixels ( image , exception ) ;  break ; } case 2 : {  q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;   if ( q == ( Quantum * ) NULL )  break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) {  index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ;  SetPixelIndex ( image , index , q ) ;  q += GetPixelChannels ( image ) ;   index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ;  SetPixelIndex ( image , index , q ) ;  q += GetPixelChannels ( image ) ;  index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; } if ( ( image -> columns % 4 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; if ( ( image -> columns % 4 ) >= 1 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; if ( ( image -> columns % 4 ) >= 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } } p ++ ; } ( void ) SyncAuthenticPixels ( image , exception ) ; break ; } case 4 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0xf , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p ) & 0xf , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; } if ( ( image -> columns % 2 ) != 0 ) {  index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0xf , exception ) ;  SetPixelIndex ( image , index , q ) ;  q += GetPixelChannels ( image ) ;   p ++ ;  } ( void ) SyncAuthenticPixels ( image , exception ) ; break ; } case 8 : {  q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;   if ( q == ( Quantum * ) NULL )  break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) {  index = ConstrainColormapIndex ( image , * p , exception ) ;  SetPixelIndex ( image , index , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } ( void ) SyncAuthenticPixels ( image , exception ) ; break ; } } }","index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x0f , exception ) ;if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ;index = ConstrainColormapIndex ( image , ( * p ) & 0x0f , exception ) ;if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ;q += GetPixelChannels ( image ) ;if ( ( image -> columns % 2 ) != 0 ) {if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ;p ++ ;q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;index = ConstrainColormapIndex ( image , * p , exception ) ;SetPixelIndex ( image , index , q ) ;",414
558,"buggy line: static int cfm_network_addr_print ( netdissect_options * ndo ,  register const u_char * tptr )  {u_int hexdump = FALSE ;network_addr_type = * tptr ;case AFNUM_INET :  ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr + 1 ) ) ) ;break ;case AFNUM_INET6 :  ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ip6addr_string ( ndo , tptr + 1 ) ) ) ;break ;cwe id:CWE-125context: static int cfm_network_addr_print ( netdissect_options * ndo ,  register const u_char * tptr )  { u_int network_addr_type ;  u_int hexdump = FALSE ;  network_addr_type = * tptr ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Network<S2SV_blank>Address<S2SV_blank>Type<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( af_values , ""Unknown"" , network_addr_type ) , network_addr_type ) ) ; switch ( network_addr_type ) { case AFNUM_INET :  ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr + 1 ) ) ) ;  break ; case AFNUM_INET6 :  ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ip6addr_string ( ndo , tptr + 1 ) ) ) ;  break ; default : hexdump = TRUE ; break ; } return hexdump ; }","static int cfm_network_addr_print ( netdissect_options * ndo , register const u_char * tptr , const u_int length ) {u_int hexdump = FALSE ;if ( length < 1 ) {ND_PRINT ( ( ndo , ""\\\return hexdump ;}network_addr_type = * tptr ;case AFNUM_INET : if ( length != 1 + 4 ) {ND_PRINT ( ( ndo , ""(invalid<S2SV_blank>IPv4<S2SV_blank>address<S2SV_blank>length<S2SV_blank>%u)"" , length - 1 ) ) ;hexdump = TRUE ;break ;}ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr + 1 ) ) ) ;break ;case AFNUM_INET6 : if ( length != 1 + 16 ) {ND_PRINT ( ( ndo , ""(invalid<S2SV_blank>IPv6<S2SV_blank>address<S2SV_blank>length<S2SV_blank>%u)"" , length - 1 ) ) ;hexdump = TRUE ;break ;}ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ip6addr_string ( ndo , tptr + 1 ) ) ) ;break ;",415
559,"buggy line: u64 msr_data ;int usermode ;cs . dpl = 3 ;ss . dpl = 3 ;cwe id:CWE-264context: static int em_sysexit ( struct x86_emulate_ctxt * ctxt ) { const struct x86_emulate_ops * ops = ctxt -> ops ; struct desc_struct cs , ss ;  u64 msr_data ;  int usermode ; u16 cs_sel = 0 , ss_sel = 0 ; if ( ctxt -> mode == X86EMUL_MODE_REAL || ctxt -> mode == X86EMUL_MODE_VM86 ) return emulate_gp ( ctxt , 0 ) ; setup_syscalls_segments ( ctxt , & cs , & ss ) ; if ( ( ctxt -> rex_prefix & 0x8 ) != 0x0 ) usermode = X86EMUL_MODE_PROT64 ; else usermode = X86EMUL_MODE_PROT32 ;  cs . dpl = 3 ;  ss . dpl = 3 ; ops -> get_msr ( ctxt , MSR_IA32_SYSENTER_CS , & msr_data ) ; switch ( usermode ) { case X86EMUL_MODE_PROT32 : cs_sel = ( u16 ) ( msr_data + 16 ) ; if ( ( msr_data & 0xfffc ) == 0x0 ) return emulate_gp ( ctxt , 0 ) ; ss_sel = ( u16 ) ( msr_data + 24 ) ; break ; case X86EMUL_MODE_PROT64 : cs_sel = ( u16 ) ( msr_data + 32 ) ; if ( msr_data == 0x0 ) return emulate_gp ( ctxt , 0 ) ; ss_sel = cs_sel + 8 ; cs . d = 0 ; cs . l = 1 ;  break ;  } cs_sel |= SELECTOR_RPL_MASK ; ss_sel |= SELECTOR_RPL_MASK ; ops -> set_segment ( ctxt , cs_sel , & cs , 0 , VCPU_SREG_CS ) ; ops -> set_segment ( ctxt , ss_sel , & ss , 0 , VCPU_SREG_SS ) ;  ctxt -> _eip = reg_read ( ctxt , VCPU_REGS_RDX ) ;   * reg_write ( ctxt , VCPU_REGS_RSP ) = reg_read ( ctxt , VCPU_REGS_RCX ) ;  return X86EMUL_CONTINUE ; }","u64 msr_data , rcx , rdx ;int usermode ;rcx = reg_read ( ctxt , VCPU_REGS_RCX ) ;rdx = reg_read ( ctxt , VCPU_REGS_RDX ) ;cs . dpl = 3 ;ss . dpl = 3 ;",416
560,"buggy line: break ;}ctxt -> _eip = reg_read ( ctxt , VCPU_REGS_RDX ) ;* reg_write ( ctxt , VCPU_REGS_RSP ) = reg_read ( ctxt , VCPU_REGS_RCX ) ;return X86EMUL_CONTINUE ;cwe id:CWE-264context: static int em_sysexit ( struct x86_emulate_ctxt * ctxt ) { const struct x86_emulate_ops * ops = ctxt -> ops ; struct desc_struct cs , ss ;  u64 msr_data ;  int usermode ; u16 cs_sel = 0 , ss_sel = 0 ; if ( ctxt -> mode == X86EMUL_MODE_REAL || ctxt -> mode == X86EMUL_MODE_VM86 ) return emulate_gp ( ctxt , 0 ) ; setup_syscalls_segments ( ctxt , & cs , & ss ) ; if ( ( ctxt -> rex_prefix & 0x8 ) != 0x0 ) usermode = X86EMUL_MODE_PROT64 ; else usermode = X86EMUL_MODE_PROT32 ;  cs . dpl = 3 ;  ss . dpl = 3 ; ops -> get_msr ( ctxt , MSR_IA32_SYSENTER_CS , & msr_data ) ; switch ( usermode ) { case X86EMUL_MODE_PROT32 : cs_sel = ( u16 ) ( msr_data + 16 ) ; if ( ( msr_data & 0xfffc ) == 0x0 ) return emulate_gp ( ctxt , 0 ) ; ss_sel = ( u16 ) ( msr_data + 24 ) ; break ; case X86EMUL_MODE_PROT64 : cs_sel = ( u16 ) ( msr_data + 32 ) ; if ( msr_data == 0x0 ) return emulate_gp ( ctxt , 0 ) ; ss_sel = cs_sel + 8 ; cs . d = 0 ; cs . l = 1 ;  break ;  } cs_sel |= SELECTOR_RPL_MASK ; ss_sel |= SELECTOR_RPL_MASK ; ops -> set_segment ( ctxt , cs_sel , & cs , 0 , VCPU_SREG_CS ) ; ops -> set_segment ( ctxt , ss_sel , & ss , 0 , VCPU_SREG_SS ) ;  ctxt -> _eip = reg_read ( ctxt , VCPU_REGS_RDX ) ;   * reg_write ( ctxt , VCPU_REGS_RSP ) = reg_read ( ctxt , VCPU_REGS_RCX ) ;  return X86EMUL_CONTINUE ; }","if ( is_noncanonical_address ( rcx ) || is_noncanonical_address ( rdx ) ) return emulate_gp ( ctxt , 0 ) ;break ;}ctxt -> _eip = rdx ;* reg_write ( ctxt , VCPU_REGS_RSP ) = reg_read ( ctxt , VCPU_REGS_RCX ) ;return X86EMUL_CONTINUE ;",416
561,"buggy line: return sprintf ( buf , ""%s\\\}cwe id:CWE-362context: static ssize_t driver_override_show ( struct device * dev , struct device_attribute * attr , char * buf ) { struct platform_device * pdev = to_platform_device ( dev ) ;  return sprintf ( buf , ""%s\\n"" , pdev -> driver_override ) ;   } ","ssize_t len ;device_lock ( dev ) ;len = sprintf ( buf , ""%s\\\device_unlock ( dev ) ;return len ;}",417
562,"buggy line: BIO * tmpout = NULL ;if ( out == NULL ) tmpout = BIO_new ( BIO_s_null ( ) ) ;else if ( flags & CMS_TEXT ) {tmpout = BIO_new ( BIO_s_mem ( ) ) ;BIO_set_mem_eof_return ( tmpout , 0 ) ;else tmpout = out ;cwe id:CWE-399context: static int cms_copy_content ( BIO * out , BIO * in , unsigned int flags ) { unsigned char buf [ 4096 ] ; int r = 0 , i ;  BIO * tmpout = NULL ;  if ( out == NULL ) tmpout = BIO_new ( BIO_s_null ( ) ) ; else if ( flags & CMS_TEXT ) {  tmpout = BIO_new ( BIO_s_mem ( ) ) ;  BIO_set_mem_eof_return ( tmpout , 0 ) ; } else tmpout = out ; if ( ! tmpout ) { CMSerr ( CMS_F_CMS_COPY_CONTENT , ERR_R_MALLOC_FAILURE ) ; goto err ; } for ( ; ; ) { i = BIO_read ( in , buf , sizeof ( buf ) ) ; if ( i <= 0 ) { if ( BIO_method_type ( in ) == BIO_TYPE_CIPHER ) { if ( ! BIO_get_cipher_status ( in ) ) goto err ; } if ( i < 0 ) goto err ; break ; } if ( tmpout && ( BIO_write ( tmpout , buf , i ) != i ) ) goto err ; } if ( flags & CMS_TEXT ) { if ( ! SMIME_text ( tmpout , out ) ) { CMSerr ( CMS_F_CMS_COPY_CONTENT , CMS_R_SMIME_TEXT_ERROR ) ; goto err ; } } r = 1 ; err : if ( tmpout && ( tmpout != out ) ) BIO_free ( tmpout ) ; return r ; }","BIO * tmpout ;tmpout = cms_get_text_bio ( out , flags ) ;if ( ! tmpout ) {CMSerr ( CMS_F_CMS_COPY_CONTENT , ERR_R_MALLOC_FAILURE ) ;goto err ;for ( ;;) {i = BIO_read ( in , buf , sizeof ( buf ) ) ;if ( i <= 0 ) {if ( BIO_method_type ( in ) == BIO_TYPE_CIPHER ) {if ( ! BIO_get_cipher_status ( in ) ) goto err ;}if ( i < 0 ) goto err ;break ;}if ( tmpout && ( BIO_write ( tmpout , buf , i ) != i ) ) goto err ;}if ( flags & CMS_TEXT ) {",418
563,"buggy line: rs . respond ( rs . arg , retval , NULL , NULL , NULL ) ;}cwe id:CWE-264context: static void on_response ( void * data , krb5_error_code retval , otp_response response ) { struct request_state rs = * ( struct request_state * ) data ; free ( data ) ; if ( retval == 0 && response != otp_response_success ) retval = KRB5_PREAUTH_FAILED ;  rs . respond ( rs . arg , retval , NULL , NULL , NULL ) ;  }","if ( retval == 0 ) rs . enc_tkt_reply -> flags |= TKT_FLG_PRE_AUTH ;rs . respond ( rs . arg , retval , NULL , NULL , NULL ) ;}",419
564,"buggy line: static void cost ( int * costs , vp9_tree tree , const vp9_prob * probs ,  int i , int c ) {const vp9_prob prob = probs [ i / 2 ] ;int b ;const vp9_tree_index ii = tree [ i + b ] ;if ( ii <= 0 ) costs [ - ii ] = cc ;cwe id:CWE-119context:  static void cost ( int * costs , vp9_tree tree , const vp9_prob * probs ,  int i , int c ) {  const vp9_prob prob = probs [ i / 2 ] ;  int b ; for ( b = 0 ; b <= 1 ; ++ b ) { const int cc = c + vp9_cost_bit ( prob , b ) ;  const vp9_tree_index ii = tree [ i + b ] ;  if ( ii <= 0 ) costs [ - ii ] = cc ; else cost ( costs , tree , probs , ii , cc ) ; } }","static void cost ( int * costs , vpx_tree tree , const vp9_prob * probs , int i , int c ) {const vpx_prob prob = probs [ i / 2 ] ;int b ;const vpx_tree_index ii = tree [ i + b ] ;if ( ii <= 0 ) costs [ - ii ] = cc ;",420
565,"buggy line: create_option_search_table ( ) ;goto open_rc ;cwe id:CWE-59context: void init_rc ( void ) { int i ; struct stat st ; FILE * f ; if ( rc_dir != NULL ) goto open_rc ; rc_dir = expandPath ( RC_DIR ) ; i = strlen ( rc_dir ) ; if ( i > 1 && rc_dir [ i - 1 ] == '/' ) rc_dir [ i - 1 ] = '\\0' ; # ifdef USE_M17N display_charset_str = wc_get_ces_list ( ) ; document_charset_str = display_charset_str ; system_charset_str = display_charset_str ; # endif if ( stat ( rc_dir , & st ) < 0 ) { if ( errno == ENOENT ) { if ( do_mkdir ( rc_dir , 0700 ) < 0 ) { goto rc_dir_err ; } else { stat ( rc_dir , & st ) ; } } else { goto rc_dir_err ; } } if ( ! S_ISDIR ( st . st_mode ) ) { goto rc_dir_err ; } if ( ! ( st . st_mode & S_IWUSR ) ) { goto rc_dir_err ; } no_rc_dir = FALSE ; tmp_dir = rc_dir ; if ( config_file == NULL ) config_file = rcFile ( CONFIG_FILE ) ; create_option_search_table ( ) ; open_rc : if ( ( f = fopen ( etcFile ( W3MCONFIG ) , ""rt"" ) ) != NULL ) { interpret_rc ( f ) ; fclose ( f ) ; } if ( ( f = fopen ( confFile ( CONFIG_FILE ) , ""rt"" ) ) != NULL ) { interpret_rc ( f ) ; fclose ( f ) ; } if ( config_file && ( f = fopen ( config_file , ""rt"" ) ) != NULL ) { interpret_rc ( f ) ; fclose ( f ) ; } return ; rc_dir_err : no_rc_dir = TRUE ; if ( ( ( tmp_dir = getenv ( ""TMPDIR"" ) ) == NULL || * tmp_dir == '\\0' ) && ( ( tmp_dir = getenv ( ""TMP"" ) ) == NULL || * tmp_dir == '\\0' ) && ( ( tmp_dir = getenv ( ""TEMP"" ) ) == NULL || * tmp_dir == '\\0' ) ) tmp_dir = ""/tmp"" ;  create_option_search_table ( ) ;  goto open_rc ; }","# ifdef HAVE_MKDTEMP tmp_dir = mkdtemp ( Strnew_m_charp ( tmp_dir , ""/w3m-XXXXXX"" , NULL ) -> ptr ) ;if ( tmp_dir == NULL ) tmp_dir = rc_dir ;# endif create_option_search_table ( ) ;goto open_rc ;",421
566,"buggy line: switch ( af ) {case AF_INET : ( void ) inet_ntop ( af , & ( ( struct sockaddr_in * ) sock_addr ) -> sin_addr , addr_text , sizeof ( addr_text ) - 1 ) ;cwe id:CWE-125context: static inline void get_conn_text ( const conn * c , const int af , char * addr , struct sockaddr * sock_addr ) { char addr_text [ MAXPATHLEN ] ; addr_text [ 0 ] = '\\0' ; const char * protoname = ""?"" ; unsigned short port = 0 ;  switch ( af ) {  case AF_INET : ( void ) inet_ntop ( af , & ( ( struct sockaddr_in * ) sock_addr ) -> sin_addr , addr_text , sizeof ( addr_text ) - 1 ) ; port = ntohs ( ( ( struct sockaddr_in * ) sock_addr ) -> sin_port ) ; protoname = IS_UDP ( c -> transport ) ? ""udp"" : ""tcp"" ; break ; case AF_INET6 : addr_text [ 0 ] = '[' ; addr_text [ 1 ] = '\\0' ; if ( inet_ntop ( af , & ( ( struct sockaddr_in6 * ) sock_addr ) -> sin6_addr , addr_text + 1 , sizeof ( addr_text ) - 2 ) ) { strcat ( addr_text , ""]"" ) ; } port = ntohs ( ( ( struct sockaddr_in6 * ) sock_addr ) -> sin6_port ) ; protoname = IS_UDP ( c -> transport ) ? ""udp6"" : ""tcp6"" ; break ; case AF_UNIX :  strncpy ( addr_text ,   ( ( struct sockaddr_un * ) sock_addr ) -> sun_path ,  sizeof ( addr_text ) - 1 ) ; addr_text [ sizeof ( addr_text ) - 1 ] = '\\0' ; protoname = ""unix"" ; break ; } if ( strlen ( addr_text ) < 2 ) { sprintf ( addr_text , ""<AF<S2SV_blank>%d>"" , af ) ; } if ( port ) { sprintf ( addr , ""%s:%s:%u"" , protoname , addr_text , port ) ; } else { sprintf ( addr , ""%s:%s"" , protoname , addr_text ) ; } }","size_t pathlen = 0 ;switch ( af ) {case AF_INET : ( void ) inet_ntop ( af , & ( ( struct sockaddr_in * ) sock_addr ) -> sin_addr , addr_text , sizeof ( addr_text ) - 1 ) ;",422
567,"buggy line: case AF_UNIX :  strncpy ( addr_text ,   ( ( struct sockaddr_un * ) sock_addr ) -> sun_path ,  sizeof ( addr_text ) - 1 ) ;addr_text [ sizeof ( addr_text ) - 1 ] = \'\\\\0\' ;cwe id:CWE-125context: static inline void get_conn_text ( const conn * c , const int af , char * addr , struct sockaddr * sock_addr ) { char addr_text [ MAXPATHLEN ] ; addr_text [ 0 ] = '\\0' ; const char * protoname = ""?"" ; unsigned short port = 0 ;  switch ( af ) {  case AF_INET : ( void ) inet_ntop ( af , & ( ( struct sockaddr_in * ) sock_addr ) -> sin_addr , addr_text , sizeof ( addr_text ) - 1 ) ; port = ntohs ( ( ( struct sockaddr_in * ) sock_addr ) -> sin_port ) ; protoname = IS_UDP ( c -> transport ) ? ""udp"" : ""tcp"" ; break ; case AF_INET6 : addr_text [ 0 ] = '[' ; addr_text [ 1 ] = '\\0' ; if ( inet_ntop ( af , & ( ( struct sockaddr_in6 * ) sock_addr ) -> sin6_addr , addr_text + 1 , sizeof ( addr_text ) - 2 ) ) { strcat ( addr_text , ""]"" ) ; } port = ntohs ( ( ( struct sockaddr_in6 * ) sock_addr ) -> sin6_port ) ; protoname = IS_UDP ( c -> transport ) ? ""udp6"" : ""tcp6"" ; break ; case AF_UNIX :  strncpy ( addr_text ,   ( ( struct sockaddr_un * ) sock_addr ) -> sun_path ,  sizeof ( addr_text ) - 1 ) ; addr_text [ sizeof ( addr_text ) - 1 ] = '\\0' ; protoname = ""unix"" ; break ; } if ( strlen ( addr_text ) < 2 ) { sprintf ( addr_text , ""<AF<S2SV_blank>%d>"" , af ) ; } if ( port ) { sprintf ( addr , ""%s:%s:%u"" , protoname , addr_text , port ) ; } else { sprintf ( addr , ""%s:%s"" , protoname , addr_text ) ; } }","case AF_UNIX : pathlen = sizeof ( ( ( struct sockaddr_un * ) sock_addr ) -> sun_path ) ;if ( MAXPATHLEN <= pathlen ) {pathlen = MAXPATHLEN - 1 ;}strncpy ( addr_text , ( ( struct sockaddr_un * ) sock_addr ) -> sun_path , pathlen ) ;addr_text [ pathlen ] = \'\\\\0\' ;",422
568,"buggy line: static INLINE void write_buffer_16x16 ( int16_t * output , __m128i * in0 ,  __m128i * in1 , int stride ) {cwe id:CWE-119context:  static INLINE void write_buffer_16x16 ( int16_t * output , __m128i * in0 ,  __m128i * in1 , int stride ) { write_buffer_8x8 ( output , in0 , stride ) ; write_buffer_8x8 ( output + 8 * stride , in0 + 8 , stride ) ; output += 8 ; write_buffer_8x8 ( output , in1 , stride ) ; write_buffer_8x8 ( output + 8 * stride , in1 + 8 , stride ) ; }","static INLINE void write_buffer_16x16 ( tran_low_t * output , __m128i * in0 , __m128i * in1 , int stride ) {",423
569,"buggy line: err = synth_devs [ dev ] -> load_patch ( dev , fmt , buf , p + 4 , c , 0 ) ;if ( err < 0 ) return err ;cwe id:CWE-189context: int sequencer_write ( int dev , struct file * file , const char __user * buf , int count ) { unsigned char event_rec [ EV_SZ ] , ev_code ; int p = 0 , c , ev_size ; int mode = translate_mode ( file ) ; dev = dev >> 4 ; DEB ( printk ( ""sequencer_write(dev=%d,<S2SV_blank>count=%d)\\n"" , dev , count ) ) ; if ( mode == OPEN_READ ) return - EIO ; c = count ; while ( c >= 4 ) { if ( copy_from_user ( ( char * ) event_rec , & ( buf ) [ p ] , 4 ) ) goto out ; ev_code = event_rec [ 0 ] ; if ( ev_code == SEQ_FULLSIZE ) { int err , fmt ; dev = * ( unsigned short * ) & event_rec [ 2 ] ; if ( dev < 0 || dev >= max_synthdev || synth_devs [ dev ] == NULL ) return - ENXIO ; if ( ! ( synth_open_mask & ( 1 << dev ) ) ) return - ENXIO ; fmt = ( * ( short * ) & event_rec [ 0 ] ) & 0xffff ;  err = synth_devs [ dev ] -> load_patch ( dev , fmt , buf , p + 4 , c , 0 ) ;  if ( err < 0 ) return err ; return err ; } if ( ev_code >= 128 ) { if ( seq_mode == SEQ_2 && ev_code == SEQ_EXTENDED ) { printk ( KERN_WARNING ""Sequencer:<S2SV_blank>Invalid<S2SV_blank>level<S2SV_blank>2<S2SV_blank>event<S2SV_blank>%x\\n"" , ev_code ) ; return - EINVAL ; } ev_size = 8 ; if ( c < ev_size ) { if ( ! seq_playing ) seq_startplay ( ) ; return count - c ; } if ( copy_from_user ( ( char * ) & event_rec [ 4 ] , & ( buf ) [ p + 4 ] , 4 ) ) goto out ; } else { if ( seq_mode == SEQ_2 ) { printk ( KERN_WARNING ""Sequencer:<S2SV_blank>4<S2SV_blank>byte<S2SV_blank>event<S2SV_blank>in<S2SV_blank>level<S2SV_blank>2<S2SV_blank>mode\\n"" ) ; return - EINVAL ; } ev_size = 4 ; if ( event_rec [ 0 ] != SEQ_MIDIPUTC ) obsolete_api_used = 1 ; } if ( event_rec [ 0 ] == SEQ_MIDIPUTC ) { if ( ! midi_opened [ event_rec [ 2 ] ] ) { int err , mode ; int dev = event_rec [ 2 ] ; if ( dev >= max_mididev || midi_devs [ dev ] == NULL ) { return - ENXIO ; } mode = translate_mode ( file ) ; if ( ( err = midi_devs [ dev ] -> open ( dev , mode , sequencer_midi_input , sequencer_midi_output ) ) < 0 ) { seq_reset ( ) ; printk ( KERN_WARNING ""Sequencer<S2SV_blank>Error:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>Midi<S2SV_blank>#%d\\n"" , dev ) ; return err ; } midi_opened [ dev ] = 1 ; } } if ( ! seq_queue ( event_rec , ( file -> f_flags & ( O_NONBLOCK ) ? 1 : 0 ) ) ) { int processed = count - c ; if ( ! seq_playing ) seq_startplay ( ) ; if ( ! processed && ( file -> f_flags & O_NONBLOCK ) ) return - EAGAIN ; else return processed ; } p += ev_size ; c -= ev_size ; } if ( ! seq_playing ) seq_startplay ( ) ; out : return count ; }","err = synth_devs [ dev ] -> load_patch ( dev , fmt , buf + p , c , 0 ) ;if ( err < 0 ) return err ;",424
570,"buggy line: struct hstate * h = hstate_vma ( vma ) ;struct page * page ;struct address_space * mapping = vma -> vm_file -> f_mapping ;struct inode * inode = mapping -> host ;if ( chg )  if ( hugetlb_get_quota ( inode -> i_mapping , chg ) )  return ERR_PTR ( - VM_FAULT_SIGBUS ) ;page = alloc_buddy_huge_page ( h , NUMA_NO_NODE ) ;if ( ! page ) {hugetlb_put_quota ( inode -> i_mapping , chg ) ;return ERR_PTR ( - VM_FAULT_SIGBUS ) ;set_page_private ( page , ( unsigned long ) mapping ) ;vma_commit_reservation ( h , vma , addr ) ;cwe id:CWE-399context: static struct page * alloc_huge_page ( struct vm_area_struct * vma , unsigned long addr , int avoid_reserve ) {  struct hstate * h = hstate_vma ( vma ) ;   struct page * page ;  struct address_space * mapping = vma -> vm_file -> f_mapping ; struct inode * inode = mapping -> host ; long chg ; chg = vma_needs_reservation ( h , vma , addr ) ; if ( chg < 0 ) return ERR_PTR ( - VM_FAULT_OOM ) ; if ( chg )  if ( hugetlb_get_quota ( inode -> i_mapping , chg ) )  return ERR_PTR ( - VM_FAULT_SIGBUS ) ; spin_lock ( & hugetlb_lock ) ; page = dequeue_huge_page_vma ( h , vma , addr , avoid_reserve ) ; spin_unlock ( & hugetlb_lock ) ; if ( ! page ) { page = alloc_buddy_huge_page ( h , NUMA_NO_NODE ) ; if ( ! page ) {  hugetlb_put_quota ( inode -> i_mapping , chg ) ;  return ERR_PTR ( - VM_FAULT_SIGBUS ) ; } }  set_page_private ( page , ( unsigned long ) mapping ) ;  vma_commit_reservation ( h , vma , addr ) ; return page ; }","struct hugepage_subpool * spool = subpool_vma ( vma ) ;struct hstate * h = hstate_vma ( vma ) ;struct page * page ;if ( chg ) if ( hugepage_subpool_get_pages ( spool , chg ) ) return ERR_PTR ( - VM_FAULT_SIGBUS ) ;hugepage_subpool_put_pages ( spool , chg ) ;return ERR_PTR ( - VM_FAULT_SIGBUS ) ;set_page_private ( page , ( unsigned long ) mapping ) ;vma_commit_reservation ( h , vma , addr ) ;",425
571,"buggy line: DPRINTF ( 4 , ( ""enabling<S2SV_blank>filegen<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>statistics<S2SV_blank>\\\'%s%s\\\'\\\cwe id:CWE-20context: static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ;  DPRINTF ( 4 , ( ""enabling<S2SV_blank>filegen<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>statistics<S2SV_blank>\'%s%s\'\\n"" ,  filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ;  filegen_flag = filegen -> flag ;  filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown<S2SV_blank>filegen<S2SV_blank>flag<S2SV_blank>token<S2SV_blank>%d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown<S2SV_blank>filegen<S2SV_blank>option<S2SV_blank>token<S2SV_blank>%d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }","if ( NULL == filegen ) {msyslog ( LOG_ERR , ""stats<S2SV_blank>%s<S2SV_blank>unrecognized"" , filegen_string ) ;continue ;}DPRINTF ( 4 , ( ""enabling<S2SV_blank>filegen<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>statistics<S2SV_blank>\\\'%s%s\\\'\\\",426
572,"buggy line: filegen_flag = filegen -> flag ;filegen_type = filegen -> type ;cwe id:CWE-20context: static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ;  DPRINTF ( 4 , ( ""enabling<S2SV_blank>filegen<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>statistics<S2SV_blank>\'%s%s\'\\n"" ,  filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ;  filegen_flag = filegen -> flag ;  filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown<S2SV_blank>filegen<S2SV_blank>flag<S2SV_blank>token<S2SV_blank>%d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown<S2SV_blank>filegen<S2SV_blank>option<S2SV_blank>token<S2SV_blank>%d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }","if ( NULL == filegen ) {msyslog ( LOG_ERR , ""filegen<S2SV_blank>category<S2SV_blank>\\\'%s\\\'<S2SV_blank>unrecognized"" , filegen_file ) ;continue ;}filegen_flag = filegen -> flag ;filegen_type = filegen -> type ;",426
573,"buggy line: if ( t -> stamp_path )  touch_file ( t -> stamp_path , true , t -> last_trigger . realtime , UID_INVALID , GID_INVALID , 0 ) ;timer_set_state ( t , TIMER_RUNNING ) ;cwe id:CWE-264context: static void timer_enter_running ( Timer * t ) { _cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL ; int r ; assert ( t ) ; if ( unit_stop_pending ( UNIT ( t ) ) ) return ; r = manager_add_job ( UNIT ( t ) -> manager , JOB_START , UNIT_TRIGGER ( UNIT ( t ) ) , JOB_REPLACE , true , & error , NULL ) ; if ( r < 0 ) goto fail ; dual_timestamp_get ( & t -> last_trigger ) ; if ( t -> stamp_path )  touch_file ( t -> stamp_path , true , t -> last_trigger . realtime , UID_INVALID , GID_INVALID , 0 ) ;  timer_set_state ( t , TIMER_RUNNING ) ; return ; fail : log_unit_warning ( UNIT ( t ) , ""Failed<S2SV_blank>to<S2SV_blank>queue<S2SV_blank>unit<S2SV_blank>startup<S2SV_blank>job:<S2SV_blank>%s"" , bus_error_message ( & error , r ) ) ; timer_enter_dead ( t , TIMER_FAILURE_RESOURCES ) ; }","if ( t -> stamp_path ) touch_file ( t -> stamp_path , true , t -> last_trigger . realtime , UID_INVALID , GID_INVALID , MODE_INVALID ) ;timer_set_state ( t , TIMER_RUNNING ) ;",427
574,"buggy line: static void fadst16 ( const int16_t * input , int16_t * output ) {int s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 , s8 , s9 , s10 , s11 , s12 , s13 , s14 , s15 ;int x0 = input [ 15 ] ;int x1 = input [ 0 ] ;int x2 = input [ 13 ] ;int x3 = input [ 2 ] ;int x4 = input [ 11 ] ;int x5 = input [ 4 ] ;int x6 = input [ 9 ] ;int x7 = input [ 6 ] ;int x8 = input [ 7 ] ;int x9 = input [ 8 ] ;int x10 = input [ 5 ] ;int x11 = input [ 10 ] ;int x12 = input [ 3 ] ;int x13 = input [ 12 ] ;int x14 = input [ 1 ] ;int x15 = input [ 14 ] ;s0 = x0 * cospi_1_64 + x1 * cospi_31_64 ;cwe id:CWE-119context:  static void fadst16 ( const int16_t * input , int16_t * output ) {   int s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 , s8 , s9 , s10 , s11 , s12 , s13 , s14 , s15 ;   int x0 = input [ 15 ] ;   int x1 = input [ 0 ] ;   int x2 = input [ 13 ] ;   int x3 = input [ 2 ] ;   int x4 = input [ 11 ] ;   int x5 = input [ 4 ] ;   int x6 = input [ 9 ] ;   int x7 = input [ 6 ] ;   int x8 = input [ 7 ] ;   int x9 = input [ 8 ] ;   int x10 = input [ 5 ] ;   int x11 = input [ 10 ] ;   int x12 = input [ 3 ] ;   int x13 = input [ 12 ] ;   int x14 = input [ 1 ] ;   int x15 = input [ 14 ] ;  s0 = x0 * cospi_1_64 + x1 * cospi_31_64 ; s1 = x0 * cospi_31_64 - x1 * cospi_1_64 ; s2 = x2 * cospi_5_64 + x3 * cospi_27_64 ; s3 = x2 * cospi_27_64 - x3 * cospi_5_64 ; s4 = x4 * cospi_9_64 + x5 * cospi_23_64 ; s5 = x4 * cospi_23_64 - x5 * cospi_9_64 ; s6 = x6 * cospi_13_64 + x7 * cospi_19_64 ; s7 = x6 * cospi_19_64 - x7 * cospi_13_64 ; s8 = x8 * cospi_17_64 + x9 * cospi_15_64 ; s9 = x8 * cospi_15_64 - x9 * cospi_17_64 ; s10 = x10 * cospi_21_64 + x11 * cospi_11_64 ; s11 = x10 * cospi_11_64 - x11 * cospi_21_64 ; s12 = x12 * cospi_25_64 + x13 * cospi_7_64 ; s13 = x12 * cospi_7_64 - x13 * cospi_25_64 ; s14 = x14 * cospi_29_64 + x15 * cospi_3_64 ; s15 = x14 * cospi_3_64 - x15 * cospi_29_64 ; x0 = fdct_round_shift ( s0 + s8 ) ; x1 = fdct_round_shift ( s1 + s9 ) ; x2 = fdct_round_shift ( s2 + s10 ) ; x3 = fdct_round_shift ( s3 + s11 ) ; x4 = fdct_round_shift ( s4 + s12 ) ; x5 = fdct_round_shift ( s5 + s13 ) ; x6 = fdct_round_shift ( s6 + s14 ) ; x7 = fdct_round_shift ( s7 + s15 ) ; x8 = fdct_round_shift ( s0 - s8 ) ; x9 = fdct_round_shift ( s1 - s9 ) ; x10 = fdct_round_shift ( s2 - s10 ) ; x11 = fdct_round_shift ( s3 - s11 ) ; x12 = fdct_round_shift ( s4 - s12 ) ; x13 = fdct_round_shift ( s5 - s13 ) ; x14 = fdct_round_shift ( s6 - s14 ) ; x15 = fdct_round_shift ( s7 - s15 ) ; s0 = x0 ; s1 = x1 ; s2 = x2 ; s3 = x3 ; s4 = x4 ; s5 = x5 ; s6 = x6 ; s7 = x7 ; s8 = x8 * cospi_4_64 + x9 * cospi_28_64 ; s9 = x8 * cospi_28_64 - x9 * cospi_4_64 ; s10 = x10 * cospi_20_64 + x11 * cospi_12_64 ; s11 = x10 * cospi_12_64 - x11 * cospi_20_64 ; s12 = - x12 * cospi_28_64 + x13 * cospi_4_64 ; s13 = x12 * cospi_4_64 + x13 * cospi_28_64 ; s14 = - x14 * cospi_12_64 + x15 * cospi_20_64 ; s15 = x14 * cospi_20_64 + x15 * cospi_12_64 ; x0 = s0 + s4 ; x1 = s1 + s5 ; x2 = s2 + s6 ; x3 = s3 + s7 ; x4 = s0 - s4 ; x5 = s1 - s5 ; x6 = s2 - s6 ; x7 = s3 - s7 ; x8 = fdct_round_shift ( s8 + s12 ) ; x9 = fdct_round_shift ( s9 + s13 ) ; x10 = fdct_round_shift ( s10 + s14 ) ; x11 = fdct_round_shift ( s11 + s15 ) ; x12 = fdct_round_shift ( s8 - s12 ) ; x13 = fdct_round_shift ( s9 - s13 ) ; x14 = fdct_round_shift ( s10 - s14 ) ; x15 = fdct_round_shift ( s11 - s15 ) ; s0 = x0 ; s1 = x1 ; s2 = x2 ; s3 = x3 ; s4 = x4 * cospi_8_64 + x5 * cospi_24_64 ; s5 = x4 * cospi_24_64 - x5 * cospi_8_64 ; s6 = - x6 * cospi_24_64 + x7 * cospi_8_64 ; s7 = x6 * cospi_8_64 + x7 * cospi_24_64 ; s8 = x8 ; s9 = x9 ; s10 = x10 ; s11 = x11 ; s12 = x12 * cospi_8_64 + x13 * cospi_24_64 ; s13 = x12 * cospi_24_64 - x13 * cospi_8_64 ; s14 = - x14 * cospi_24_64 + x15 * cospi_8_64 ; s15 = x14 * cospi_8_64 + x15 * cospi_24_64 ; x0 = s0 + s2 ; x1 = s1 + s3 ; x2 = s0 - s2 ; x3 = s1 - s3 ; x4 = fdct_round_shift ( s4 + s6 ) ; x5 = fdct_round_shift ( s5 + s7 ) ; x6 = fdct_round_shift ( s4 - s6 ) ; x7 = fdct_round_shift ( s5 - s7 ) ; x8 = s8 + s10 ; x9 = s9 + s11 ; x10 = s8 - s10 ; x11 = s9 - s11 ; x12 = fdct_round_shift ( s12 + s14 ) ; x13 = fdct_round_shift ( s13 + s15 ) ; x14 = fdct_round_shift ( s12 - s14 ) ; x15 = fdct_round_shift ( s13 - s15 ) ; s2 = ( - cospi_16_64 ) * ( x2 + x3 ) ; s3 = cospi_16_64 * ( x2 - x3 ) ; s6 = cospi_16_64 * ( x6 + x7 ) ; s7 = cospi_16_64 * ( - x6 + x7 ) ; s10 = cospi_16_64 * ( x10 + x11 ) ; s11 = cospi_16_64 * ( - x10 + x11 ) ; s14 = ( - cospi_16_64 ) * ( x14 + x15 ) ; s15 = cospi_16_64 * ( x14 - x15 ) ; x2 = fdct_round_shift ( s2 ) ; x3 = fdct_round_shift ( s3 ) ; x6 = fdct_round_shift ( s6 ) ; x7 = fdct_round_shift ( s7 ) ; x10 = fdct_round_shift ( s10 ) ; x11 = fdct_round_shift ( s11 ) ; x14 = fdct_round_shift ( s14 ) ; x15 = fdct_round_shift ( s15 ) ;  output [ 0 ] = x0 ;   output [ 1 ] = - x8 ;   output [ 2 ] = x12 ;   output [ 3 ] = - x4 ;   output [ 4 ] = x6 ;   output [ 5 ] = x14 ;   output [ 6 ] = x10 ;   output [ 7 ] = x2 ;   output [ 8 ] = x3 ;   output [ 9 ] = x11 ;   output [ 10 ] = x15 ;   output [ 11 ] = x7 ;   output [ 12 ] = x5 ;   output [ 13 ] = - x13 ;   output [ 14 ] = x9 ;   output [ 15 ] = - x1 ;  }","static void fadst16 ( const tran_low_t * input , int16_t * output ) {tran_high_t s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 , s8 ;tran_high_t s9 , s10 , s11 , s12 , s13 , s14 , s15 ;tran_high_t x0 = input [ 15 ] ;tran_high_t x1 = input [ 0 ] ;tran_high_t x2 = input [ 13 ] ;tran_high_t x3 = input [ 2 ] ;tran_high_t x4 = input [ 11 ] ;tran_high_t x5 = input [ 4 ] ;tran_high_t x6 = input [ 9 ] ;tran_high_t x7 = input [ 6 ] ;tran_high_t x8 = input [ 7 ] ;tran_high_t x9 = input [ 8 ] ;tran_high_t x10 = input [ 5 ] ;tran_high_t x11 = input [ 10 ] ;tran_high_t x12 = input [ 3 ] ;tran_high_t x13 = input [ 12 ] ;tran_high_t x14 = input [ 1 ] ;tran_high_t x15 = input [ 14 ] ;s0 = x0 * cospi_1_64 + x1 * cospi_31_64 ;",428
575,"buggy line: output [ 0 ] = x0 ;output [ 1 ] = - x8 ;output [ 2 ] = x12 ;output [ 3 ] = - x4 ;output [ 4 ] = x6 ;output [ 5 ] = x14 ;output [ 6 ] = x10 ;output [ 7 ] = x2 ;output [ 8 ] = x3 ;output [ 9 ] = x11 ;output [ 10 ] = x15 ;output [ 11 ] = x7 ;output [ 12 ] = x5 ;output [ 13 ] = - x13 ;output [ 14 ] = x9 ;output [ 15 ] = - x1 ;}cwe id:CWE-119context:  static void fadst16 ( const int16_t * input , int16_t * output ) {   int s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 , s8 , s9 , s10 , s11 , s12 , s13 , s14 , s15 ;   int x0 = input [ 15 ] ;   int x1 = input [ 0 ] ;   int x2 = input [ 13 ] ;   int x3 = input [ 2 ] ;   int x4 = input [ 11 ] ;   int x5 = input [ 4 ] ;   int x6 = input [ 9 ] ;   int x7 = input [ 6 ] ;   int x8 = input [ 7 ] ;   int x9 = input [ 8 ] ;   int x10 = input [ 5 ] ;   int x11 = input [ 10 ] ;   int x12 = input [ 3 ] ;   int x13 = input [ 12 ] ;   int x14 = input [ 1 ] ;   int x15 = input [ 14 ] ;  s0 = x0 * cospi_1_64 + x1 * cospi_31_64 ; s1 = x0 * cospi_31_64 - x1 * cospi_1_64 ; s2 = x2 * cospi_5_64 + x3 * cospi_27_64 ; s3 = x2 * cospi_27_64 - x3 * cospi_5_64 ; s4 = x4 * cospi_9_64 + x5 * cospi_23_64 ; s5 = x4 * cospi_23_64 - x5 * cospi_9_64 ; s6 = x6 * cospi_13_64 + x7 * cospi_19_64 ; s7 = x6 * cospi_19_64 - x7 * cospi_13_64 ; s8 = x8 * cospi_17_64 + x9 * cospi_15_64 ; s9 = x8 * cospi_15_64 - x9 * cospi_17_64 ; s10 = x10 * cospi_21_64 + x11 * cospi_11_64 ; s11 = x10 * cospi_11_64 - x11 * cospi_21_64 ; s12 = x12 * cospi_25_64 + x13 * cospi_7_64 ; s13 = x12 * cospi_7_64 - x13 * cospi_25_64 ; s14 = x14 * cospi_29_64 + x15 * cospi_3_64 ; s15 = x14 * cospi_3_64 - x15 * cospi_29_64 ; x0 = fdct_round_shift ( s0 + s8 ) ; x1 = fdct_round_shift ( s1 + s9 ) ; x2 = fdct_round_shift ( s2 + s10 ) ; x3 = fdct_round_shift ( s3 + s11 ) ; x4 = fdct_round_shift ( s4 + s12 ) ; x5 = fdct_round_shift ( s5 + s13 ) ; x6 = fdct_round_shift ( s6 + s14 ) ; x7 = fdct_round_shift ( s7 + s15 ) ; x8 = fdct_round_shift ( s0 - s8 ) ; x9 = fdct_round_shift ( s1 - s9 ) ; x10 = fdct_round_shift ( s2 - s10 ) ; x11 = fdct_round_shift ( s3 - s11 ) ; x12 = fdct_round_shift ( s4 - s12 ) ; x13 = fdct_round_shift ( s5 - s13 ) ; x14 = fdct_round_shift ( s6 - s14 ) ; x15 = fdct_round_shift ( s7 - s15 ) ; s0 = x0 ; s1 = x1 ; s2 = x2 ; s3 = x3 ; s4 = x4 ; s5 = x5 ; s6 = x6 ; s7 = x7 ; s8 = x8 * cospi_4_64 + x9 * cospi_28_64 ; s9 = x8 * cospi_28_64 - x9 * cospi_4_64 ; s10 = x10 * cospi_20_64 + x11 * cospi_12_64 ; s11 = x10 * cospi_12_64 - x11 * cospi_20_64 ; s12 = - x12 * cospi_28_64 + x13 * cospi_4_64 ; s13 = x12 * cospi_4_64 + x13 * cospi_28_64 ; s14 = - x14 * cospi_12_64 + x15 * cospi_20_64 ; s15 = x14 * cospi_20_64 + x15 * cospi_12_64 ; x0 = s0 + s4 ; x1 = s1 + s5 ; x2 = s2 + s6 ; x3 = s3 + s7 ; x4 = s0 - s4 ; x5 = s1 - s5 ; x6 = s2 - s6 ; x7 = s3 - s7 ; x8 = fdct_round_shift ( s8 + s12 ) ; x9 = fdct_round_shift ( s9 + s13 ) ; x10 = fdct_round_shift ( s10 + s14 ) ; x11 = fdct_round_shift ( s11 + s15 ) ; x12 = fdct_round_shift ( s8 - s12 ) ; x13 = fdct_round_shift ( s9 - s13 ) ; x14 = fdct_round_shift ( s10 - s14 ) ; x15 = fdct_round_shift ( s11 - s15 ) ; s0 = x0 ; s1 = x1 ; s2 = x2 ; s3 = x3 ; s4 = x4 * cospi_8_64 + x5 * cospi_24_64 ; s5 = x4 * cospi_24_64 - x5 * cospi_8_64 ; s6 = - x6 * cospi_24_64 + x7 * cospi_8_64 ; s7 = x6 * cospi_8_64 + x7 * cospi_24_64 ; s8 = x8 ; s9 = x9 ; s10 = x10 ; s11 = x11 ; s12 = x12 * cospi_8_64 + x13 * cospi_24_64 ; s13 = x12 * cospi_24_64 - x13 * cospi_8_64 ; s14 = - x14 * cospi_24_64 + x15 * cospi_8_64 ; s15 = x14 * cospi_8_64 + x15 * cospi_24_64 ; x0 = s0 + s2 ; x1 = s1 + s3 ; x2 = s0 - s2 ; x3 = s1 - s3 ; x4 = fdct_round_shift ( s4 + s6 ) ; x5 = fdct_round_shift ( s5 + s7 ) ; x6 = fdct_round_shift ( s4 - s6 ) ; x7 = fdct_round_shift ( s5 - s7 ) ; x8 = s8 + s10 ; x9 = s9 + s11 ; x10 = s8 - s10 ; x11 = s9 - s11 ; x12 = fdct_round_shift ( s12 + s14 ) ; x13 = fdct_round_shift ( s13 + s15 ) ; x14 = fdct_round_shift ( s12 - s14 ) ; x15 = fdct_round_shift ( s13 - s15 ) ; s2 = ( - cospi_16_64 ) * ( x2 + x3 ) ; s3 = cospi_16_64 * ( x2 - x3 ) ; s6 = cospi_16_64 * ( x6 + x7 ) ; s7 = cospi_16_64 * ( - x6 + x7 ) ; s10 = cospi_16_64 * ( x10 + x11 ) ; s11 = cospi_16_64 * ( - x10 + x11 ) ; s14 = ( - cospi_16_64 ) * ( x14 + x15 ) ; s15 = cospi_16_64 * ( x14 - x15 ) ; x2 = fdct_round_shift ( s2 ) ; x3 = fdct_round_shift ( s3 ) ; x6 = fdct_round_shift ( s6 ) ; x7 = fdct_round_shift ( s7 ) ; x10 = fdct_round_shift ( s10 ) ; x11 = fdct_round_shift ( s11 ) ; x14 = fdct_round_shift ( s14 ) ; x15 = fdct_round_shift ( s15 ) ;  output [ 0 ] = x0 ;   output [ 1 ] = - x8 ;   output [ 2 ] = x12 ;   output [ 3 ] = - x4 ;   output [ 4 ] = x6 ;   output [ 5 ] = x14 ;   output [ 6 ] = x10 ;   output [ 7 ] = x2 ;   output [ 8 ] = x3 ;   output [ 9 ] = x11 ;   output [ 10 ] = x15 ;   output [ 11 ] = x7 ;   output [ 12 ] = x5 ;   output [ 13 ] = - x13 ;   output [ 14 ] = x9 ;   output [ 15 ] = - x1 ;  }",output [ 0 ] = ( tran_low_t ) x0 ;output [ 1 ] = ( tran_low_t ) - x8 ;output [ 2 ] = ( tran_low_t ) x12 ;output [ 3 ] = ( tran_low_t ) - x4 ;output [ 4 ] = ( tran_low_t ) x6 ;output [ 5 ] = ( tran_low_t ) x14 ;output [ 6 ] = ( tran_low_t ) x10 ;output [ 7 ] = ( tran_low_t ) x2 ;output [ 8 ] = ( tran_low_t ) x3 ;output [ 9 ] = ( tran_low_t ) x11 ;output [ 10 ] = ( tran_low_t ) x15 ;output [ 11 ] = ( tran_low_t ) x7 ;output [ 12 ] = ( tran_low_t ) x5 ;output [ 13 ] = ( tran_low_t ) - x13 ;output [ 14 ] = ( tran_low_t ) x9 ;output [ 15 ] = ( tran_low_t ) - x1 ;},428
576,buggy line: # if HAVE_EDSP  flags |= HAS_EDSP ;# endif # if HAVE_MEDIA flags |= HAS_MEDIA ;# endif  # if HAVE_NEON  flags |= HAS_NEON ;cwe id:CWE-119context: int arm_cpu_caps ( void ) { int flags ; int mask ; if ( ! arm_cpu_env_flags ( & flags ) ) { return flags ; } mask = arm_cpu_env_mask ( ) ;  # if HAVE_EDSP  flags |= HAS_EDSP ; # endif # if HAVE_MEDIA flags |= HAS_MEDIA ; # endif  # if HAVE_NEON  flags |= HAS_NEON ; # endif return flags & mask ; },# if HAVE_MEDIA flags |= HAS_MEDIA ;# endif # if HAVE_NEON || HAVE_NEON_ASM flags |= HAS_NEON ;,429
577,"buggy line: MB_PREDICTION_MODE vp9_left_block_mode ( const MODE_INFO * cur_mi ,  const MODE_INFO * left_mi , int b ) {cwe id:CWE-119context:  MB_PREDICTION_MODE vp9_left_block_mode ( const MODE_INFO * cur_mi ,  const MODE_INFO * left_mi , int b ) { if ( b == 0 || b == 2 ) { if ( ! left_mi || is_inter_block ( & left_mi -> mbmi ) ) return DC_PRED ; return get_y_mode ( left_mi , b + 1 ) ; } else { assert ( b == 1 || b == 3 ) ; return cur_mi -> bmi [ b - 1 ] . as_mode ; } }","PREDICTION_MODE vp9_left_block_mode ( const MODE_INFO * cur_mi , const MODE_INFO * left_mi , int b ) {",430
578,"buggy line: static void  swabHorAcc16 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {horAcc16 ( tif , cp0 , cc ) ;}cwe id:CWE-119context:  static void  swabHorAcc16 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { uint16 * wp = ( uint16 * ) cp0 ; tmsize_t wc = cc / 2 ; TIFFSwabArrayOfShort ( wp , wc ) ;  horAcc16 ( tif , cp0 , cc ) ;  }","static int swabHorAcc16 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {return horAcc16 ( tif , cp0 , cc ) ;}",431
579,"buggy line: opt2 -> tot_len = tot_len ;p = ( char * ) ( opt2 + 1 ) ;cwe id:CWE-416context: struct ipv6_txoptions * ipv6_renew_options ( struct sock * sk , struct ipv6_txoptions * opt , int newtype , struct ipv6_opt_hdr __user * newopt , int newoptlen ) { int tot_len = 0 ; char * p ; struct ipv6_txoptions * opt2 ; int err ; if ( opt ) { if ( newtype != IPV6_HOPOPTS && opt -> hopopt ) tot_len += CMSG_ALIGN ( ipv6_optlen ( opt -> hopopt ) ) ; if ( newtype != IPV6_RTHDRDSTOPTS && opt -> dst0opt ) tot_len += CMSG_ALIGN ( ipv6_optlen ( opt -> dst0opt ) ) ; if ( newtype != IPV6_RTHDR && opt -> srcrt ) tot_len += CMSG_ALIGN ( ipv6_optlen ( opt -> srcrt ) ) ; if ( newtype != IPV6_DSTOPTS && opt -> dst1opt ) tot_len += CMSG_ALIGN ( ipv6_optlen ( opt -> dst1opt ) ) ; } if ( newopt && newoptlen ) tot_len += CMSG_ALIGN ( newoptlen ) ; if ( ! tot_len ) return NULL ; tot_len += sizeof ( * opt2 ) ; opt2 = sock_kmalloc ( sk , tot_len , GFP_ATOMIC ) ; if ( ! opt2 ) return ERR_PTR ( - ENOBUFS ) ; memset ( opt2 , 0 , tot_len ) ;  opt2 -> tot_len = tot_len ;  p = ( char * ) ( opt2 + 1 ) ; err = ipv6_renew_option ( opt ? opt -> hopopt : NULL , newopt , newoptlen , newtype != IPV6_HOPOPTS , & opt2 -> hopopt , & p ) ; if ( err ) goto out ; err = ipv6_renew_option ( opt ? opt -> dst0opt : NULL , newopt , newoptlen , newtype != IPV6_RTHDRDSTOPTS , & opt2 -> dst0opt , & p ) ; if ( err ) goto out ; err = ipv6_renew_option ( opt ? opt -> srcrt : NULL , newopt , newoptlen , newtype != IPV6_RTHDR , ( struct ipv6_opt_hdr * * ) & opt2 -> srcrt , & p ) ; if ( err ) goto out ; err = ipv6_renew_option ( opt ? opt -> dst1opt : NULL , newopt , newoptlen , newtype != IPV6_DSTOPTS , & opt2 -> dst1opt , & p ) ; if ( err ) goto out ; opt2 -> opt_nflen = ( opt2 -> hopopt ? ipv6_optlen ( opt2 -> hopopt ) : 0 ) + ( opt2 -> dst0opt ? ipv6_optlen ( opt2 -> dst0opt ) : 0 ) + ( opt2 -> srcrt ? ipv6_optlen ( opt2 -> srcrt ) : 0 ) ; opt2 -> opt_flen = ( opt2 -> dst1opt ? ipv6_optlen ( opt2 -> dst1opt ) : 0 ) ; return opt2 ; out : sock_kfree_s ( sk , opt2 , opt2 -> tot_len ) ; return ERR_PTR ( err ) ; }","atomic_set ( & opt2 -> refcnt , 1 ) ;opt2 -> tot_len = tot_len ;p = ( char * ) ( opt2 + 1 ) ;",432
580,"buggy line: for ( i = 0 ;i ++ )  av_add_index_entry ( st , avio_rl64 ( pb ) , i , 0 , 0 , AVINDEX_KEYFRAME ) ;return 0 ;}cwe id:CWE-834context: static int cine_read_header ( AVFormatContext * avctx ) { AVIOContext * pb = avctx -> pb ; AVStream * st ; unsigned int version , compression , offImageHeader , offSetup , offImageOffsets , biBitCount , length , CFA ; int vflip ; char * description ; uint64_t i ; st = avformat_new_stream ( avctx , NULL ) ; if ( ! st ) return AVERROR ( ENOMEM ) ; st -> codecpar -> codec_type = AVMEDIA_TYPE_VIDEO ; st -> codecpar -> codec_id = AV_CODEC_ID_RAWVIDEO ; st -> codecpar -> codec_tag = 0 ; avio_skip ( pb , 4 ) ; compression = avio_rl16 ( pb ) ; version = avio_rl16 ( pb ) ; if ( version != 1 ) { avpriv_request_sample ( avctx , ""unknown<S2SV_blank>version<S2SV_blank>%i"" , version ) ; return AVERROR_INVALIDDATA ; } avio_skip ( pb , 12 ) ; st -> duration = avio_rl32 ( pb ) ; offImageHeader = avio_rl32 ( pb ) ; offSetup = avio_rl32 ( pb ) ; offImageOffsets = avio_rl32 ( pb ) ; avio_skip ( pb , 8 ) ; avio_seek ( pb , offImageHeader , SEEK_SET ) ; avio_skip ( pb , 4 ) ; st -> codecpar -> width = avio_rl32 ( pb ) ; st -> codecpar -> height = avio_rl32 ( pb ) ; if ( avio_rl16 ( pb ) != 1 ) return AVERROR_INVALIDDATA ; biBitCount = avio_rl16 ( pb ) ; if ( biBitCount != 8 && biBitCount != 16 && biBitCount != 24 && biBitCount != 48 ) { avpriv_request_sample ( avctx , ""unsupported<S2SV_blank>biBitCount<S2SV_blank>%i"" , biBitCount ) ; return AVERROR_INVALIDDATA ; } switch ( avio_rl32 ( pb ) ) { case BMP_RGB : vflip = 0 ; break ; case 0x100 : st -> codecpar -> codec_tag = MKTAG ( 'B' , 'I' , 'T' , 0 ) ; vflip = 1 ; break ; default : avpriv_request_sample ( avctx , ""unknown<S2SV_blank>bitmap<S2SV_blank>compression"" ) ; return AVERROR_INVALIDDATA ; } avio_skip ( pb , 4 ) ; avio_seek ( pb , offSetup , SEEK_SET ) ; avio_skip ( pb , 140 ) ; if ( avio_rl16 ( pb ) != 0x5453 ) return AVERROR_INVALIDDATA ; length = avio_rl16 ( pb ) ; if ( length < 0x163C ) { avpriv_request_sample ( avctx , ""short<S2SV_blank>SETUP<S2SV_blank>header"" ) ; return AVERROR_INVALIDDATA ; } avio_skip ( pb , 616 ) ; if ( ! avio_rl32 ( pb ) ^ vflip ) { st -> codecpar -> extradata = av_strdup ( ""BottomUp"" ) ; st -> codecpar -> extradata_size = 9 ; } avio_skip ( pb , 4 ) ; avpriv_set_pts_info ( st , 64 , 1 , avio_rl32 ( pb ) ) ; avio_skip ( pb , 20 ) ; set_metadata_int ( & st -> metadata , ""camera_version"" , avio_rl32 ( pb ) , 0 ) ; set_metadata_int ( & st -> metadata , ""firmware_version"" , avio_rl32 ( pb ) , 0 ) ; set_metadata_int ( & st -> metadata , ""software_version"" , avio_rl32 ( pb ) , 0 ) ; set_metadata_int ( & st -> metadata , ""recording_timezone"" , avio_rl32 ( pb ) , 0 ) ; CFA = avio_rl32 ( pb ) ; set_metadata_int ( & st -> metadata , ""brightness"" , avio_rl32 ( pb ) , 1 ) ; set_metadata_int ( & st -> metadata , ""contrast"" , avio_rl32 ( pb ) , 1 ) ; set_metadata_int ( & st -> metadata , ""gamma"" , avio_rl32 ( pb ) , 1 ) ; avio_skip ( pb , 12 + 16 ) ; set_metadata_float ( & st -> metadata , ""wbgain[0].r"" , av_int2float ( avio_rl32 ( pb ) ) , 1 ) ; set_metadata_float ( & st -> metadata , ""wbgain[0].b"" , av_int2float ( avio_rl32 ( pb ) ) , 1 ) ; avio_skip ( pb , 36 ) ; st -> codecpar -> bits_per_coded_sample = avio_rl32 ( pb ) ; if ( compression == CC_RGB ) { if ( biBitCount == 8 ) { st -> codecpar -> format = AV_PIX_FMT_GRAY8 ; } else if ( biBitCount == 16 ) { st -> codecpar -> format = AV_PIX_FMT_GRAY16LE ; } else if ( biBitCount == 24 ) { st -> codecpar -> format = AV_PIX_FMT_BGR24 ; } else if ( biBitCount == 48 ) { st -> codecpar -> format = AV_PIX_FMT_BGR48LE ; } else { avpriv_request_sample ( avctx , ""unsupported<S2SV_blank>biBitCount<S2SV_blank>%i"" , biBitCount ) ; return AVERROR_INVALIDDATA ; } } else if ( compression == CC_UNINT ) { switch ( CFA & 0xFFFFFF ) { case CFA_BAYER : if ( biBitCount == 8 ) { st -> codecpar -> format = AV_PIX_FMT_BAYER_GBRG8 ; } else if ( biBitCount == 16 ) { st -> codecpar -> format = AV_PIX_FMT_BAYER_GBRG16LE ; } else { avpriv_request_sample ( avctx , ""unsupported<S2SV_blank>biBitCount<S2SV_blank>%i"" , biBitCount ) ; return AVERROR_INVALIDDATA ; } break ; case CFA_BAYERFLIP : if ( biBitCount == 8 ) { st -> codecpar -> format = AV_PIX_FMT_BAYER_RGGB8 ; } else if ( biBitCount == 16 ) { st -> codecpar -> format = AV_PIX_FMT_BAYER_RGGB16LE ; } else { avpriv_request_sample ( avctx , ""unsupported<S2SV_blank>biBitCount<S2SV_blank>%i"" , biBitCount ) ; return AVERROR_INVALIDDATA ; } break ; default : avpriv_request_sample ( avctx , ""unsupported<S2SV_blank>Color<S2SV_blank>Field<S2SV_blank>Array<S2SV_blank>(CFA)<S2SV_blank>%i"" , CFA & 0xFFFFFF ) ; return AVERROR_INVALIDDATA ; } } else { avpriv_request_sample ( avctx , ""unsupported<S2SV_blank>compression<S2SV_blank>%i"" , compression ) ; return AVERROR_INVALIDDATA ; } avio_skip ( pb , 668 ) ; set_metadata_int ( & st -> metadata , ""shutter_ns"" , avio_rl32 ( pb ) , 0 ) ; avio_skip ( pb , 24 ) ; # define DESCRIPTION_SIZE 4096 description = av_malloc ( DESCRIPTION_SIZE + 1 ) ; if ( ! description ) return AVERROR ( ENOMEM ) ; i = avio_get_str ( pb , DESCRIPTION_SIZE , description , DESCRIPTION_SIZE + 1 ) ; if ( i < DESCRIPTION_SIZE ) avio_skip ( pb , DESCRIPTION_SIZE - i ) ; if ( description [ 0 ] ) av_dict_set ( & st -> metadata , ""description"" , description , AV_DICT_DONT_STRDUP_VAL ) ; else av_free ( description ) ; avio_skip ( pb , 1176 ) ; set_metadata_int ( & st -> metadata , ""enable_crop"" , avio_rl32 ( pb ) , 1 ) ; set_metadata_int ( & st -> metadata , ""crop_left"" , avio_rl32 ( pb ) , 1 ) ; set_metadata_int ( & st -> metadata , ""crop_top"" , avio_rl32 ( pb ) , 1 ) ; set_metadata_int ( & st -> metadata , ""crop_right"" , avio_rl32 ( pb ) , 1 ) ; set_metadata_int ( & st -> metadata , ""crop_bottom"" , avio_rl32 ( pb ) , 1 ) ; avio_seek ( pb , offImageOffsets , SEEK_SET ) ;  for ( i = 0 ; i < st -> duration ; i ++ )  av_add_index_entry ( st , avio_rl64 ( pb ) , i , 0 , 0 , AVINDEX_KEYFRAME ) ;  return 0 ;  }","for ( i = 0 ;i ++ ) {if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ;av_add_index_entry ( st , avio_rl64 ( pb ) , i , 0 , 0 , AVINDEX_KEYFRAME ) ;}return 0 ;}",433
581,"buggy line: if ( ( op & ASN1_OP_MATCH__COND && flags & FLAG_MATCHED ) ||  dp == datalen ) {flags &= ~ FLAG_LAST_MATCHED ;cwe id:CWE-310context: int asn1_ber_decoder ( const struct asn1_decoder * decoder , void * context , const unsigned char * data , size_t datalen ) { const unsigned char * machine = decoder -> machine ; const asn1_action_t * actions = decoder -> actions ; size_t machlen = decoder -> machlen ; enum asn1_opcode op ; unsigned char tag = 0 , csp = 0 , jsp = 0 , optag = 0 , hdr = 0 ; const char * errmsg ; size_t pc = 0 , dp = 0 , tdp = 0 , len = 0 ; int ret ; unsigned char flags = 0 ; # define FLAG_INDEFINITE_LENGTH 0x01 # define FLAG_MATCHED 0x02 # define FLAG_LAST_MATCHED 0x04 # define FLAG_CONS 0x20 # define NR_CONS_STACK 10 unsigned short cons_dp_stack [ NR_CONS_STACK ] ; unsigned short cons_datalen_stack [ NR_CONS_STACK ] ; unsigned char cons_hdrlen_stack [ NR_CONS_STACK ] ; # define NR_JUMP_STACK 10 unsigned char jump_stack [ NR_JUMP_STACK ] ; if ( datalen > 65535 ) return - EMSGSIZE ; next_op : pr_debug ( ""next_op:<S2SV_blank>pc=\\e[32m%zu\\e[m/%zu<S2SV_blank>dp=\\e[33m%zu\\e[m/%zu<S2SV_blank>C=%d<S2SV_blank>J=%d\\n"" , pc , machlen , dp , datalen , csp , jsp ) ; if ( unlikely ( pc >= machlen ) ) goto machine_overrun_error ; op = machine [ pc ] ; if ( unlikely ( pc + asn1_op_lengths [ op ] > machlen ) ) goto machine_overrun_error ; if ( op <= ASN1_OP__MATCHES_TAG ) { unsigned char tmp ; if ( ( op & ASN1_OP_MATCH__COND && flags & FLAG_MATCHED ) ||  dp == datalen ) {  flags &= ~ FLAG_LAST_MATCHED ; pc += asn1_op_lengths [ op ] ; goto next_op ; } flags = 0 ; hdr = 2 ; if ( unlikely ( dp >= datalen - 1 ) ) goto data_overrun_error ; tag = data [ dp ++ ] ; if ( unlikely ( ( tag & 0x1f ) == ASN1_LONG_TAG ) ) goto long_tag_not_supported ; if ( op & ASN1_OP_MATCH__ANY ) { pr_debug ( ""-<S2SV_blank>any<S2SV_blank>%02x\\n"" , tag ) ; } else { optag = machine [ pc + 1 ] ; flags |= optag & FLAG_CONS ; tmp = optag ^ tag ; tmp &= ~ ( optag & ASN1_CONS_BIT ) ; pr_debug ( ""-<S2SV_blank>match?<S2SV_blank>%02x<S2SV_blank>%02x<S2SV_blank>%02x\\n"" , tag , optag , tmp ) ; if ( tmp != 0 ) { if ( op & ASN1_OP_MATCH__SKIP ) { pc += asn1_op_lengths [ op ] ; dp -- ; goto next_op ; } goto tag_mismatch ; } } flags |= FLAG_MATCHED ; len = data [ dp ++ ] ; if ( len > 0x7f ) { if ( unlikely ( len == ASN1_INDEFINITE_LENGTH ) ) { if ( unlikely ( ! ( tag & ASN1_CONS_BIT ) ) ) goto indefinite_len_primitive ; flags |= FLAG_INDEFINITE_LENGTH ; if ( unlikely ( 2 > datalen - dp ) ) goto data_overrun_error ; } else { int n = len - 0x80 ; if ( unlikely ( n > 2 ) ) goto length_too_long ; if ( unlikely ( dp >= datalen - n ) ) goto data_overrun_error ; hdr += n ; for ( len = 0 ; n > 0 ; n -- ) { len <<= 8 ; len |= data [ dp ++ ] ; } if ( unlikely ( len > datalen - dp ) ) goto data_overrun_error ; } } if ( flags & FLAG_CONS ) { if ( unlikely ( csp >= NR_CONS_STACK ) ) goto cons_stack_overflow ; cons_dp_stack [ csp ] = dp ; cons_hdrlen_stack [ csp ] = hdr ; if ( ! ( flags & FLAG_INDEFINITE_LENGTH ) ) { cons_datalen_stack [ csp ] = datalen ; datalen = dp + len ; } else { cons_datalen_stack [ csp ] = 0 ; } csp ++ ; } pr_debug ( ""-<S2SV_blank>TAG:<S2SV_blank>%02x<S2SV_blank>%zu%s\\n"" , tag , len , flags & FLAG_CONS ? ""<S2SV_blank>CONS"" : """" ) ; tdp = dp ; } switch ( op ) { case ASN1_OP_MATCH_ANY_ACT : case ASN1_OP_COND_MATCH_ANY_ACT : ret = actions [ machine [ pc + 1 ] ] ( context , hdr , tag , data + dp , len ) ; if ( ret < 0 ) return ret ; goto skip_data ; case ASN1_OP_MATCH_ACT : case ASN1_OP_MATCH_ACT_OR_SKIP : case ASN1_OP_COND_MATCH_ACT_OR_SKIP : ret = actions [ machine [ pc + 2 ] ] ( context , hdr , tag , data + dp , len ) ; if ( ret < 0 ) return ret ; goto skip_data ; case ASN1_OP_MATCH : case ASN1_OP_MATCH_OR_SKIP : case ASN1_OP_MATCH_ANY : case ASN1_OP_COND_MATCH_OR_SKIP : case ASN1_OP_COND_MATCH_ANY : skip_data : if ( ! ( flags & FLAG_CONS ) ) { if ( flags & FLAG_INDEFINITE_LENGTH ) { ret = asn1_find_indefinite_length ( data , datalen , & dp , & len , & errmsg ) ; if ( ret < 0 ) goto error ; } else { dp += len ; } pr_debug ( ""-<S2SV_blank>LEAF:<S2SV_blank>%zu\\n"" , len ) ; } pc += asn1_op_lengths [ op ] ; goto next_op ; case ASN1_OP_MATCH_JUMP : case ASN1_OP_MATCH_JUMP_OR_SKIP : case ASN1_OP_COND_MATCH_JUMP_OR_SKIP : pr_debug ( ""-<S2SV_blank>MATCH_JUMP\\n"" ) ; if ( unlikely ( jsp == NR_JUMP_STACK ) ) goto jump_stack_overflow ; jump_stack [ jsp ++ ] = pc + asn1_op_lengths [ op ] ; pc = machine [ pc + 2 ] ; goto next_op ; case ASN1_OP_COND_FAIL : if ( unlikely ( ! ( flags & FLAG_MATCHED ) ) ) goto tag_mismatch ; pc += asn1_op_lengths [ op ] ; goto next_op ; case ASN1_OP_COMPLETE : if ( unlikely ( jsp != 0 || csp != 0 ) ) { pr_err ( ""ASN.1<S2SV_blank>decoder<S2SV_blank>error:<S2SV_blank>Stacks<S2SV_blank>not<S2SV_blank>empty<S2SV_blank>at<S2SV_blank>completion<S2SV_blank>(%u,<S2SV_blank>%u)\\n"" , jsp , csp ) ; return - EBADMSG ; } return 0 ; case ASN1_OP_END_SET : case ASN1_OP_END_SET_ACT : if ( unlikely ( ! ( flags & FLAG_MATCHED ) ) ) goto tag_mismatch ; case ASN1_OP_END_SEQ : case ASN1_OP_END_SET_OF : case ASN1_OP_END_SEQ_OF : case ASN1_OP_END_SEQ_ACT : case ASN1_OP_END_SET_OF_ACT : case ASN1_OP_END_SEQ_OF_ACT : if ( unlikely ( csp <= 0 ) ) goto cons_stack_underflow ; csp -- ; tdp = cons_dp_stack [ csp ] ; hdr = cons_hdrlen_stack [ csp ] ; len = datalen ; datalen = cons_datalen_stack [ csp ] ; pr_debug ( ""-<S2SV_blank>end<S2SV_blank>cons<S2SV_blank>t=%zu<S2SV_blank>dp=%zu<S2SV_blank>l=%zu/%zu\\n"" , tdp , dp , len , datalen ) ; if ( datalen == 0 ) { datalen = len ; if ( unlikely ( datalen - dp < 2 ) ) goto data_overrun_error ; if ( data [ dp ++ ] != 0 ) { if ( op & ASN1_OP_END__OF ) { dp -- ; csp ++ ; pc = machine [ pc + 1 ] ; pr_debug ( ""-<S2SV_blank>continue\\n"" ) ; goto next_op ; } goto missing_eoc ; } if ( data [ dp ++ ] != 0 ) goto invalid_eoc ; len = dp - tdp - 2 ; } else { if ( dp < len && ( op & ASN1_OP_END__OF ) ) { datalen = len ; csp ++ ; pc = machine [ pc + 1 ] ; pr_debug ( ""-<S2SV_blank>continue\\n"" ) ; goto next_op ; } if ( dp != len ) goto cons_length_error ; len -= tdp ; pr_debug ( ""-<S2SV_blank>cons<S2SV_blank>len<S2SV_blank>l=%zu<S2SV_blank>d=%zu\\n"" , len , dp - tdp ) ; } if ( op & ASN1_OP_END__ACT ) { unsigned char act ; if ( op & ASN1_OP_END__OF ) act = machine [ pc + 2 ] ; else act = machine [ pc + 1 ] ; ret = actions [ act ] ( context , hdr , 0 , data + tdp , len ) ; } pc += asn1_op_lengths [ op ] ; goto next_op ; case ASN1_OP_MAYBE_ACT : if ( ! ( flags & FLAG_LAST_MATCHED ) ) { pc += asn1_op_lengths [ op ] ; goto next_op ; } case ASN1_OP_ACT : ret = actions [ machine [ pc + 1 ] ] ( context , hdr , tag , data + tdp , len ) ; if ( ret < 0 ) return ret ; pc += asn1_op_lengths [ op ] ; goto next_op ; case ASN1_OP_RETURN : if ( unlikely ( jsp <= 0 ) ) goto jump_stack_underflow ; pc = jump_stack [ -- jsp ] ; flags |= FLAG_MATCHED | FLAG_LAST_MATCHED ; goto next_op ; default : break ; } pr_err ( ""ASN.1<S2SV_blank>decoder<S2SV_blank>error:<S2SV_blank>Found<S2SV_blank>reserved<S2SV_blank>opcode<S2SV_blank>(%u)<S2SV_blank>pc=%zu\\n"" , op , pc ) ; return - EBADMSG ; data_overrun_error : errmsg = ""Data<S2SV_blank>overrun<S2SV_blank>error"" ; goto error ; machine_overrun_error : errmsg = ""Machine<S2SV_blank>overrun<S2SV_blank>error"" ; goto error ; jump_stack_underflow : errmsg = ""Jump<S2SV_blank>stack<S2SV_blank>underflow"" ; goto error ; jump_stack_overflow : errmsg = ""Jump<S2SV_blank>stack<S2SV_blank>overflow"" ; goto error ; cons_stack_underflow : errmsg = ""Cons<S2SV_blank>stack<S2SV_blank>underflow"" ; goto error ; cons_stack_overflow : errmsg = ""Cons<S2SV_blank>stack<S2SV_blank>overflow"" ; goto error ; cons_length_error : errmsg = ""Cons<S2SV_blank>length<S2SV_blank>error"" ; goto error ; missing_eoc : errmsg = ""Missing<S2SV_blank>EOC<S2SV_blank>in<S2SV_blank>indefinite<S2SV_blank>len<S2SV_blank>cons"" ; goto error ; invalid_eoc : errmsg = ""Invalid<S2SV_blank>length<S2SV_blank>EOC"" ; goto error ; length_too_long : errmsg = ""Unsupported<S2SV_blank>length"" ; goto error ; indefinite_len_primitive : errmsg = ""Indefinite<S2SV_blank>len<S2SV_blank>primitive<S2SV_blank>not<S2SV_blank>permitted"" ; goto error ; tag_mismatch : errmsg = ""Unexpected<S2SV_blank>tag"" ; goto error ; long_tag_not_supported : errmsg = ""Long<S2SV_blank>tag<S2SV_blank>not<S2SV_blank>supported"" ; error : pr_debug ( ""\\nASN1:<S2SV_blank>%s<S2SV_blank>[m=%zu<S2SV_blank>d=%zu<S2SV_blank>ot=%02x<S2SV_blank>t=%02x<S2SV_blank>l=%zu]\\n"" , errmsg , pc , dp , optag , tag , len ) ; return - EBADMSG ; }",if ( ( op & ASN1_OP_MATCH__COND && flags & FLAG_MATCHED ) || ( op & ASN1_OP_MATCH__SKIP && dp == datalen ) ) {flags &= ~ FLAG_LAST_MATCHED ;,434
582,"buggy line: char * fpath = NULL , * cgdir = NULL , * controller ;const char * cgroup ;cwe id:CWE-264context: static int cg_rmdir ( const char * path ) { struct fuse_context * fc = fuse_get_context ( ) ;  char * fpath = NULL , * cgdir = NULL , * controller ;  const char * cgroup ; int ret ; if ( ! fc ) return - EIO ; controller = pick_controller_from_path ( fc , path ) ; if ( ! controller ) return - EINVAL ; cgroup = find_cgroup_in_path ( path ) ; if ( ! cgroup ) return - EINVAL ; get_cgdir_and_path ( cgroup , & cgdir , & fpath ) ; if ( ! fpath ) { ret = - EINVAL ; goto out ; }  fprintf ( stderr , ""rmdir:<S2SV_blank>verifying<S2SV_blank>access<S2SV_blank>to<S2SV_blank>%s:%s<S2SV_blank>(req<S2SV_blank>path<S2SV_blank>%s)\\n"" ,  controller , cgdir , path ) ; if ( ! fc_may_access ( fc , controller , cgdir , NULL , O_WRONLY ) ) { ret = - EACCES ; goto out ; }  if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) {  ret = - EACCES ; goto out ; }  if ( ! cgfs_remove ( controller , cgroup ) ) {  ret = - EINVAL ; goto out ; } ret = 0 ; out : free ( cgdir ) ;  return ret ;  }","char * fpath = NULL , * cgdir = NULL , * controller , * next = NULL ;const char * cgroup ;",435
583,"buggy line: fprintf ( stderr , ""rmdir:<S2SV_blank>verifying<S2SV_blank>access<S2SV_blank>to<S2SV_blank>%s:%s<S2SV_blank>(req<S2SV_blank>path<S2SV_blank>%s)\\\if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) {ret = - EACCES ;if ( ! cgfs_remove ( controller , cgroup ) ) {ret = - EINVAL ;return ret ;}cwe id:CWE-264context: static int cg_rmdir ( const char * path ) { struct fuse_context * fc = fuse_get_context ( ) ;  char * fpath = NULL , * cgdir = NULL , * controller ;  const char * cgroup ; int ret ; if ( ! fc ) return - EIO ; controller = pick_controller_from_path ( fc , path ) ; if ( ! controller ) return - EINVAL ; cgroup = find_cgroup_in_path ( path ) ; if ( ! cgroup ) return - EINVAL ; get_cgdir_and_path ( cgroup , & cgdir , & fpath ) ; if ( ! fpath ) { ret = - EINVAL ; goto out ; }  fprintf ( stderr , ""rmdir:<S2SV_blank>verifying<S2SV_blank>access<S2SV_blank>to<S2SV_blank>%s:%s<S2SV_blank>(req<S2SV_blank>path<S2SV_blank>%s)\\n"" ,  controller , cgdir , path ) ; if ( ! fc_may_access ( fc , controller , cgdir , NULL , O_WRONLY ) ) { ret = - EACCES ; goto out ; }  if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) {  ret = - EACCES ; goto out ; }  if ( ! cgfs_remove ( controller , cgroup ) ) {  ret = - EINVAL ; goto out ; } ret = 0 ; out : free ( cgdir ) ;  return ret ;  }","if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , & next ) ) {if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) {ret = - EACCES ;goto out ;}if ( ! fpath || strcmp ( next , fpath ) == 0 ) ret = - EBUSY ;else ret = - ENOENT ;if ( ! fc_may_access ( fc , controller , cgdir , NULL , O_WRONLY ) ) {ret = - EACCES ;goto out ;}if ( ! cgfs_remove ( controller , cgroup ) ) {ret = - EINVAL ;free ( next ) ;return ret ;}",435
584,"buggy line: if ( ! mnt ) return ERR_PTR ( - ENOMEM ) ;if ( flag & ( CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE ) ) mnt -> mnt_group_id = 0 ;else mnt -> mnt_group_id = old -> mnt_group_id ;if ( ( flag & CL_MAKE_SHARED ) && ! mnt -> mnt_group_id ) {err = mnt_alloc_group_id ( mnt ) ;if ( err ) goto out_free ;mnt -> mnt . mnt_flags = old -> mnt . mnt_flags & ~ ( MNT_WRITE_HOLD | MNT_MARKED ) ;if ( ( flag & CL_UNPRIVILEGED ) && ( mnt -> mnt . mnt_flags & MNT_READONLY ) )  mnt -> mnt . mnt_flags |= MNT_LOCK_READONLY ;if ( ( flag & CL_UNPRIVILEGED ) && list_empty ( & old -> mnt_expire ) )  mnt -> mnt . mnt_flags |= MNT_LOCKED ;cwe id:CWE-269context: static struct mount * clone_mnt ( struct mount * old , struct dentry * root , int flag ) { struct super_block * sb = old -> mnt . mnt_sb ; struct mount * mnt ; int err ; mnt = alloc_vfsmnt ( old -> mnt_devname ) ; if ( ! mnt ) return ERR_PTR ( - ENOMEM ) ; if ( flag & ( CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE ) ) mnt -> mnt_group_id = 0 ; else mnt -> mnt_group_id = old -> mnt_group_id ; if ( ( flag & CL_MAKE_SHARED ) && ! mnt -> mnt_group_id ) { err = mnt_alloc_group_id ( mnt ) ; if ( err ) goto out_free ; } mnt -> mnt . mnt_flags = old -> mnt . mnt_flags & ~ ( MNT_WRITE_HOLD | MNT_MARKED ) ;  if ( ( flag & CL_UNPRIVILEGED ) && ( mnt -> mnt . mnt_flags & MNT_READONLY ) )  mnt -> mnt . mnt_flags |= MNT_LOCK_READONLY ;  if ( ( flag & CL_UNPRIVILEGED ) && list_empty ( & old -> mnt_expire ) )  mnt -> mnt . mnt_flags |= MNT_LOCKED ; atomic_inc ( & sb -> s_active ) ; mnt -> mnt . mnt_sb = sb ; mnt -> mnt . mnt_root = dget ( root ) ; mnt -> mnt_mountpoint = mnt -> mnt . mnt_root ; mnt -> mnt_parent = mnt ; lock_mount_hash ( ) ; list_add_tail ( & mnt -> mnt_instance , & sb -> s_mounts ) ; unlock_mount_hash ( ) ; if ( ( flag & CL_SLAVE ) || ( ( flag & CL_SHARED_TO_SLAVE ) && IS_MNT_SHARED ( old ) ) ) { list_add ( & mnt -> mnt_slave , & old -> mnt_slave_list ) ; mnt -> mnt_master = old ; CLEAR_MNT_SHARED ( mnt ) ; } else if ( ! ( flag & CL_PRIVATE ) ) { if ( ( flag & CL_MAKE_SHARED ) || IS_MNT_SHARED ( old ) ) list_add ( & mnt -> mnt_share , & old -> mnt_share ) ; if ( IS_MNT_SLAVE ( old ) ) list_add ( & mnt -> mnt_slave , & old -> mnt_slave ) ; mnt -> mnt_master = old -> mnt_master ; } if ( flag & CL_MAKE_SHARED ) set_mnt_shared ( mnt ) ; if ( flag & CL_EXPIRE ) { if ( ! list_empty ( & old -> mnt_expire ) ) list_add ( & mnt -> mnt_expire , & old -> mnt_expire ) ; } return mnt ; out_free : mnt_free_id ( mnt ) ; free_vfsmnt ( mnt ) ; return ERR_PTR ( err ) ; }",if ( flag & CL_UNPRIVILEGED ) && ( mnt -> mnt . mnt_flags & MNT_READONLY ) ) mnt -> mnt . mnt_flags |= MNT_LOCK_READONLY ;if ( mnt -> mnt . mnt_flags & MNT_NODEV ) mnt -> mnt . mnt_flags |= MNT_LOCK_NODEV ;if ( mnt -> mnt . mnt_flags & MNT_NOSUID ) mnt -> mnt . mnt_flags |= MNT_LOCK_NOSUID ;if ( mnt -> mnt . mnt_flags & MNT_NOEXEC ) mnt -> mnt . mnt_flags |= MNT_LOCK_NOEXEC ;if ( ( flag & CL_UNPRIVILEGED ) && list_empty ( & old -> mnt_expire ) ) mnt -> mnt . mnt_flags |= MNT_LOCKED ;,436
585,"buggy line: }if ( trans == NULL ) {kmem_cache_free ( rds_conn_slab , conn ) ;conn = ERR_PTR ( - ENODEV ) ;goto out ;cwe id:CWE-362context: static struct rds_connection * __rds_conn_create ( struct net * net , __be32 laddr , __be32 faddr , struct rds_transport * trans , gfp_t gfp , int is_outgoing ) { struct rds_connection * conn , * parent = NULL ; struct hlist_head * head = rds_conn_bucket ( laddr , faddr ) ; struct rds_transport * loop_trans ; unsigned long flags ; int ret ; rcu_read_lock ( ) ; conn = rds_conn_lookup ( net , head , laddr , faddr , trans ) ; if ( conn && conn -> c_loopback && conn -> c_trans != & rds_loop_transport && laddr == faddr && ! is_outgoing ) { parent = conn ; conn = parent -> c_passive ; } rcu_read_unlock ( ) ; if ( conn ) goto out ; conn = kmem_cache_zalloc ( rds_conn_slab , gfp ) ; if ( ! conn ) { conn = ERR_PTR ( - ENOMEM ) ; goto out ; } INIT_HLIST_NODE ( & conn -> c_hash_node ) ; conn -> c_laddr = laddr ; conn -> c_faddr = faddr ; spin_lock_init ( & conn -> c_lock ) ; conn -> c_next_tx_seq = 1 ; rds_conn_net_set ( conn , net ) ; init_waitqueue_head ( & conn -> c_waitq ) ; INIT_LIST_HEAD ( & conn -> c_send_queue ) ; INIT_LIST_HEAD ( & conn -> c_retrans ) ; ret = rds_cong_get_maps ( conn ) ; if ( ret ) { kmem_cache_free ( rds_conn_slab , conn ) ; conn = ERR_PTR ( ret ) ; goto out ; } loop_trans = rds_trans_get_preferred ( net , faddr ) ; if ( loop_trans ) { rds_trans_put ( loop_trans ) ; conn -> c_loopback = 1 ; if ( is_outgoing && trans -> t_prefer_loopback ) { trans = & rds_loop_transport ; }  }  if ( trans == NULL ) { kmem_cache_free ( rds_conn_slab , conn ) ; conn = ERR_PTR ( - ENODEV ) ; goto out ; } conn -> c_trans = trans ; ret = trans -> conn_alloc ( conn , gfp ) ; if ( ret ) { kmem_cache_free ( rds_conn_slab , conn ) ; conn = ERR_PTR ( ret ) ; goto out ; } atomic_set ( & conn -> c_state , RDS_CONN_DOWN ) ; conn -> c_send_gen = 0 ; conn -> c_outgoing = ( is_outgoing ? 1 : 0 ) ; conn -> c_reconnect_jiffies = 0 ; INIT_DELAYED_WORK ( & conn -> c_send_w , rds_send_worker ) ; INIT_DELAYED_WORK ( & conn -> c_recv_w , rds_recv_worker ) ; INIT_DELAYED_WORK ( & conn -> c_conn_w , rds_connect_worker ) ; INIT_WORK ( & conn -> c_down_w , rds_shutdown_worker ) ; mutex_init ( & conn -> c_cm_lock ) ; conn -> c_flags = 0 ; rdsdebug ( ""allocated<S2SV_blank>conn<S2SV_blank>%p<S2SV_blank>for<S2SV_blank>%pI4<S2SV_blank>-><S2SV_blank>%pI4<S2SV_blank>over<S2SV_blank>%s<S2SV_blank>%s\\n"" , conn , & laddr , & faddr , trans -> t_name ? trans -> t_name : ""[unknown]"" , is_outgoing ? ""(outgoing)"" : """" ) ; spin_lock_irqsave ( & rds_conn_lock , flags ) ; if ( parent ) { if ( parent -> c_passive ) { trans -> conn_free ( conn -> c_transport_data ) ; kmem_cache_free ( rds_conn_slab , conn ) ; conn = parent -> c_passive ; } else { parent -> c_passive = conn ; rds_cong_add_conn ( conn ) ; rds_conn_count ++ ; } } else { struct rds_connection * found ; found = rds_conn_lookup ( net , head , laddr , faddr , trans ) ; if ( found ) { trans -> conn_free ( conn -> c_transport_data ) ; kmem_cache_free ( rds_conn_slab , conn ) ; conn = found ; } else { hlist_add_head_rcu ( & conn -> c_hash_node , head ) ; rds_cong_add_conn ( conn ) ; rds_conn_count ++ ; } } spin_unlock_irqrestore ( & rds_conn_lock , flags ) ; out : return conn ; }","
",437
586,"buggy line: if ( * rsize >= 107 && rdesc [ 104 ] == 0x26 && rdesc [ 105 ] == 0x80 &&  rdesc [ 106 ] == 0x03 ) {cwe id:CWE-119context: static __u8 * sp_report_fixup ( struct hid_device * hdev , __u8 * rdesc , unsigned int * rsize ) {  if ( * rsize >= 107 && rdesc [ 104 ] == 0x26 && rdesc [ 105 ] == 0x80 &&  rdesc [ 106 ] == 0x03 ) { hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>Sunplus<S2SV_blank>Wireless<S2SV_blank>Desktop<S2SV_blank>report<S2SV_blank>descriptor\\n"" ) ; rdesc [ 105 ] = rdesc [ 110 ] = 0x03 ; rdesc [ 106 ] = rdesc [ 111 ] = 0x21 ; } return rdesc ; }",if ( * rsize >= 112 && rdesc [ 104 ] == 0x26 && rdesc [ 105 ] == 0x80 && rdesc [ 106 ] == 0x03 ) {,438
587,"buggy line: if ( ( tot_len - offset - 4 ) < bodyLength ) {AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""EAPOL<S2SV_blank>body<S2SV_blank>too<S2SV_blank>short"" , AIRPDCAP_DEBUG_LEVEL_3 ) ;cwe id:CWE-20context: static INT AirPDcapScanForKeys ( PAIRPDCAP_CONTEXT ctx , const guint8 * data , const guint mac_header_len , const guint tot_len , AIRPDCAP_SEC_ASSOCIATION_ID id ) { const UCHAR * addr ; guint bodyLength ; PAIRPDCAP_SEC_ASSOCIATION sta_sa ; PAIRPDCAP_SEC_ASSOCIATION sa ; guint offset = 0 ; const guint8 dot1x_header [ ] = { 0xAA , 0xAA , 0x03 , 0x00 , 0x00 , 0x00 , 0x88 , 0x8E } ; const guint8 bt_dot1x_header [ ] = { 0xAA , 0xAA , 0x03 , 0x00 , 0x19 , 0x58 , 0x00 , 0x03 } ; const guint8 tdls_header [ ] = { 0xAA , 0xAA , 0x03 , 0x00 , 0x00 , 0x00 , 0x89 , 0x0D , 0x02 , 0X0C } ; const EAPOL_RSN_KEY * pEAPKey ; # ifdef _DEBUG # define MSGBUF_LEN 255 CHAR msgbuf [ MSGBUF_LEN ] ; # endif AIRPDCAP_DEBUG_TRACE_START ( ""AirPDcapScanForKeys"" ) ; offset = mac_header_len ; if ( memcmp ( data + offset , dot1x_header , 8 ) == 0 || memcmp ( data + offset , bt_dot1x_header , 8 ) == 0 ) { AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""Authentication:<S2SV_blank>EAPOL<S2SV_blank>packet"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; offset += 8 ; if ( data [ offset + 1 ] != 3 ) { AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""Not<S2SV_blank>EAPOL-Key"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } bodyLength = pntoh16 ( data + offset + 2 ) ;  if ( ( tot_len - offset - 4 ) < bodyLength ) {  AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""EAPOL<S2SV_blank>body<S2SV_blank>too<S2SV_blank>short"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } offset += 4 ; pEAPKey = ( const EAPOL_RSN_KEY * ) ( data + offset ) ; if ( pEAPKey -> type != AIRPDCAP_RSN_WPA2_KEY_DESCRIPTOR && pEAPKey -> type != AIRPDCAP_RSN_WPA_KEY_DESCRIPTOR ) { AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""Not<S2SV_blank>valid<S2SV_blank>key<S2SV_blank>descriptor<S2SV_blank>type"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } offset += 1 ; sa = AirPDcapGetSaPtr ( ctx , & id ) ; if ( sa == NULL ) { AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""No<S2SV_blank>SA<S2SV_blank>for<S2SV_blank>BSSID<S2SV_blank>found"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_REQ_DATA ; } if ( AirPDcapRsna4WHandshake ( ctx , data , sa , offset , tot_len ) == AIRPDCAP_RET_SUCCESS_HANDSHAKE ) return AIRPDCAP_RET_SUCCESS_HANDSHAKE ; if ( mac_header_len + GROUP_KEY_PAYLOAD_LEN_MIN > tot_len ) { AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""Message<S2SV_blank>too<S2SV_blank>short<S2SV_blank>for<S2SV_blank>Group<S2SV_blank>Key"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } if ( AIRPDCAP_EAP_KEY ( data [ offset + 1 ] ) != 0 || AIRPDCAP_EAP_ACK ( data [ offset + 1 ] ) != 1 || AIRPDCAP_EAP_MIC ( data [ offset ] ) != 1 || AIRPDCAP_EAP_SEC ( data [ offset ] ) != 1 ) { AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""Key<S2SV_blank>bitfields<S2SV_blank>not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>Group<S2SV_blank>Key"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } memcpy ( id . sta , broadcast_mac , AIRPDCAP_MAC_LEN ) ; sa = AirPDcapGetSaPtr ( ctx , & id ) ; if ( sa == NULL ) { return AIRPDCAP_RET_REQ_DATA ; } if ( ( addr = AirPDcapGetStaAddress ( ( const AIRPDCAP_MAC_FRAME_ADDR4 * ) ( data ) ) ) != NULL ) { memcpy ( id . sta , addr , AIRPDCAP_MAC_LEN ) ; # ifdef _DEBUG g_snprintf ( msgbuf , MSGBUF_LEN , ""ST_MAC:<S2SV_blank>%2X.%2X.%2X.%2X.%2X.%2X\\t"" , id . sta [ 0 ] , id . sta [ 1 ] , id . sta [ 2 ] , id . sta [ 3 ] , id . sta [ 4 ] , id . sta [ 5 ] ) ; # endif AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , msgbuf , AIRPDCAP_DEBUG_LEVEL_3 ) ; } else { AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""SA<S2SV_blank>not<S2SV_blank>found"" , AIRPDCAP_DEBUG_LEVEL_5 ) ; return AIRPDCAP_RET_REQ_DATA ; } sta_sa = AirPDcapGetSaPtr ( ctx , & id ) ; if ( sta_sa == NULL ) { return AIRPDCAP_RET_REQ_DATA ; } return ( AirPDcapDecryptWPABroadcastKey ( pEAPKey , sta_sa -> wpa . ptk + 16 , sa , tot_len - offset + 1 ) ) ; } else if ( memcmp ( data + offset , tdls_header , 10 ) == 0 ) { const guint8 * initiator , * responder ; guint8 action ; guint status , offset_rsne = 0 , offset_fte = 0 , offset_link = 0 , offset_timeout = 0 ; AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""Authentication:<S2SV_blank>TDLS<S2SV_blank>Action<S2SV_blank>Frame"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; offset += 10 ; action = data [ offset ] ; if ( action != 1 && action != 2 ) { AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""Not<S2SV_blank>Response<S2SV_blank>nor<S2SV_blank>confirm"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } offset ++ ; status = pntoh16 ( data + offset ) ; if ( status != 0 ) { AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""TDLS<S2SV_blank>setup<S2SV_blank>not<S2SV_blank>successfull"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } offset += 5 ; while ( offset < ( tot_len - 2 ) ) { if ( data [ offset ] == 48 ) { offset_rsne = offset ; } else if ( data [ offset ] == 55 ) { offset_fte = offset ; } else if ( data [ offset ] == 56 ) { offset_timeout = offset ; } else if ( data [ offset ] == 101 ) { offset_link = offset ; } if ( tot_len < offset + data [ offset + 1 ] + 2 ) { return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } offset += data [ offset + 1 ] + 2 ; } if ( offset_rsne == 0 || offset_fte == 0 || offset_timeout == 0 || offset_link == 0 ) { AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""Cannot<S2SV_blank>Find<S2SV_blank>all<S2SV_blank>necessary<S2SV_blank>IEs"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""Found<S2SV_blank>RSNE/Fast<S2SV_blank>BSS/Timeout<S2SV_blank>Interval/Link<S2SV_blank>IEs"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; initiator = & data [ offset_link + 8 ] ; responder = & data [ offset_link + 14 ] ; if ( memcmp ( initiator , responder , AIRPDCAP_MAC_LEN ) < 0 ) { memcpy ( id . sta , initiator , AIRPDCAP_MAC_LEN ) ; memcpy ( id . bssid , responder , AIRPDCAP_MAC_LEN ) ; } else { memcpy ( id . sta , responder , AIRPDCAP_MAC_LEN ) ; memcpy ( id . bssid , initiator , AIRPDCAP_MAC_LEN ) ; } sa = AirPDcapGetSaPtr ( ctx , & id ) ; if ( sa == NULL ) { return AIRPDCAP_RET_REQ_DATA ; } if ( sa -> validKey ) { if ( memcmp ( sa -> wpa . nonce , data + offset_fte + 52 , AIRPDCAP_WPA_NONCE_LEN ) == 0 ) { return AIRPDCAP_RET_SUCCESS_HANDSHAKE ; } else { AIRPDCAP_SEC_ASSOCIATION * tmp_sa = g_new ( AIRPDCAP_SEC_ASSOCIATION , 1 ) ; memcpy ( tmp_sa , sa , sizeof ( AIRPDCAP_SEC_ASSOCIATION ) ) ; sa -> next = tmp_sa ; sa -> validKey = FALSE ; } } if ( AirPDcapTDLSDeriveKey ( sa , data , offset_rsne , offset_fte , offset_timeout , offset_link , action ) == AIRPDCAP_RET_SUCCESS ) { AIRPDCAP_DEBUG_TRACE_END ( ""AirPDcapScanForKeys"" ) ; return AIRPDCAP_RET_SUCCESS_HANDSHAKE ; } } else { AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""Skipping:<S2SV_blank>not<S2SV_blank>an<S2SV_blank>EAPOL<S2SV_blank>packet"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; } AIRPDCAP_DEBUG_TRACE_END ( ""AirPDcapScanForKeys"" ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; }","if ( ( ( tot_len - offset - 4 ) < bodyLength ) || ( bodyLength < sizeof ( EAPOL_RSN_KEY ) ) ) {AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""EAPOL<S2SV_blank>body<S2SV_blank>too<S2SV_blank>short"" , AIRPDCAP_DEBUG_LEVEL_3 ) ;",439
588,"buggy line: if ( likely ( port -> exists && ! filtered ) )  serio_interrupt ( serio , data , dfl ) ;cwe id:CWE-476context: static irqreturn_t i8042_interrupt ( int irq , void * dev_id ) { struct i8042_port * port ; struct serio * serio ; unsigned long flags ; unsigned char str , data ; unsigned int dfl ; unsigned int port_no ; bool filtered ; int ret = 1 ; spin_lock_irqsave ( & i8042_lock , flags ) ; str = i8042_read_status ( ) ; if ( unlikely ( ~ str & I8042_STR_OBF ) ) { spin_unlock_irqrestore ( & i8042_lock , flags ) ; if ( irq ) dbg ( ""Interrupt<S2SV_blank>%d,<S2SV_blank>without<S2SV_blank>any<S2SV_blank>data\\n"" , irq ) ; ret = 0 ; goto out ; } data = i8042_read_data ( ) ; if ( i8042_mux_present && ( str & I8042_STR_AUXDATA ) ) { static unsigned long last_transmit ; static unsigned char last_str ; dfl = 0 ; if ( str & I8042_STR_MUXERR ) { dbg ( ""MUX<S2SV_blank>error,<S2SV_blank>status<S2SV_blank>is<S2SV_blank>%02x,<S2SV_blank>data<S2SV_blank>is<S2SV_blank>%02x\\n"" , str , data ) ; switch ( data ) { default : if ( time_before ( jiffies , last_transmit + HZ / 10 ) ) { str = last_str ; break ; } case 0xfc : case 0xfd : case 0xfe : dfl = SERIO_TIMEOUT ; data = 0xfe ; break ; case 0xff : dfl = SERIO_PARITY ; data = 0xfe ; break ; } } port_no = I8042_MUX_PORT_NO + ( ( str >> 6 ) & 3 ) ; last_str = str ; last_transmit = jiffies ; } else { dfl = ( ( str & I8042_STR_PARITY ) ? SERIO_PARITY : 0 ) | ( ( str & I8042_STR_TIMEOUT && ! i8042_notimeout ) ? SERIO_TIMEOUT : 0 ) ; port_no = ( str & I8042_STR_AUXDATA ) ? I8042_AUX_PORT_NO : I8042_KBD_PORT_NO ; } port = & i8042_ports [ port_no ] ; serio = port -> exists ? port -> serio : NULL ; filter_dbg ( port -> driver_bound , data , ""<-<S2SV_blank>i8042<S2SV_blank>(interrupt,<S2SV_blank>%d,<S2SV_blank>%d%s%s)\\n"" , port_no , irq , dfl & SERIO_PARITY ? "",<S2SV_blank>bad<S2SV_blank>parity"" : """" , dfl & SERIO_TIMEOUT ? "",<S2SV_blank>timeout"" : """" ) ; filtered = i8042_filter ( data , str , serio ) ; spin_unlock_irqrestore ( & i8042_lock , flags ) ;  if ( likely ( port -> exists && ! filtered ) )  serio_interrupt ( serio , data , dfl ) ; out : return IRQ_RETVAL ( ret ) ; }","if ( likely ( serio && ! filtered ) ) serio_interrupt ( serio , data , dfl ) ;",440
589,"buggy line: if ( ! er )  ND_PRINT ( ( ndo , ""<S2SV_blank>c<S2SV_blank>%04x"" , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ;return ;cwe id:CWE-125context: static void interp_reply ( netdissect_options * ndo , const struct sunrpc_msg * rp , uint32_t proc , uint32_t vers , int length ) { register const uint32_t * dp ; register int v3 ; int er ; v3 = ( vers == NFS_VER3 ) ; if ( ! v3 && proc < NFS_NPROCS ) proc = nfsv3_procid [ proc ] ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , tok2str ( nfsproc_str , ""proc-%u"" , proc ) ) ) ; switch ( proc ) { case NFSPROC_GETATTR : dp = parserep ( ndo , rp , length ) ; if ( dp != NULL && parseattrstat ( ndo , dp , ! ndo -> ndo_qflag , v3 ) != 0 ) return ; break ; case NFSPROC_SETATTR : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) return ; if ( v3 ) { if ( parsewccres ( ndo , dp , ndo -> ndo_vflag ) ) return ; } else { if ( parseattrstat ( ndo , dp , ! ndo -> ndo_qflag , 0 ) != 0 ) return ; } break ; case NFSPROC_LOOKUP : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( ! ( dp = parsestatus ( ndo , dp , & er ) ) ) break ; if ( er ) { if ( ndo -> ndo_vflag > 1 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>post<S2SV_blank>dattr:"" ) ) ; dp = parse_post_op_attr ( ndo , dp , ndo -> ndo_vflag ) ; } } else { if ( ! ( dp = parsefh ( ndo , dp , v3 ) ) ) break ; if ( ( dp = parse_post_op_attr ( ndo , dp , ndo -> ndo_vflag ) ) && ndo -> ndo_vflag > 1 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>post<S2SV_blank>dattr:"" ) ) ; dp = parse_post_op_attr ( ndo , dp , ndo -> ndo_vflag ) ; } } if ( dp ) return ; } else { if ( parsediropres ( ndo , dp ) != 0 ) return ; } break ; case NFSPROC_ACCESS : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( ! ( dp = parsestatus ( ndo , dp , & er ) ) ) break ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""<S2SV_blank>attr:"" ) ) ; if ( ! ( dp = parse_post_op_attr ( ndo , dp , ndo -> ndo_vflag ) ) ) break ; if ( ! er )  ND_PRINT ( ( ndo , ""<S2SV_blank>c<S2SV_blank>%04x"" , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ;  return ; case NFSPROC_READLINK : dp = parserep ( ndo , rp , length ) ; if ( dp != NULL && parselinkres ( ndo , dp , v3 ) != 0 ) return ; break ; case NFSPROC_READ : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( ! ( dp = parsestatus ( ndo , dp , & er ) ) ) break ; if ( ! ( dp = parse_post_op_attr ( ndo , dp , ndo -> ndo_vflag ) ) ) break ; if ( er ) return ; if ( ndo -> ndo_vflag ) { ND_TCHECK ( dp [ 1 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>bytes"" , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; if ( EXTRACT_32BITS ( & dp [ 1 ] ) ) ND_PRINT ( ( ndo , ""<S2SV_blank>EOF"" ) ) ; } return ; } else { if ( parseattrstat ( ndo , dp , ndo -> ndo_vflag , 0 ) != 0 ) return ; } break ; case NFSPROC_WRITE : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( ! ( dp = parsestatus ( ndo , dp , & er ) ) ) break ; if ( ! ( dp = parse_wcc_data ( ndo , dp , ndo -> ndo_vflag ) ) ) break ; if ( er ) return ; if ( ndo -> ndo_vflag ) { ND_TCHECK ( dp [ 0 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>bytes"" , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; if ( ndo -> ndo_vflag > 1 ) { ND_TCHECK ( dp [ 1 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank><%s>"" , tok2str ( nfsv3_writemodes , NULL , EXTRACT_32BITS ( & dp [ 1 ] ) ) ) ) ; } return ; } } else { if ( parseattrstat ( ndo , dp , ndo -> ndo_vflag , v3 ) != 0 ) return ; } break ; case NFSPROC_CREATE : case NFSPROC_MKDIR : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( parsecreateopres ( ndo , dp , ndo -> ndo_vflag ) != NULL ) return ; } else { if ( parsediropres ( ndo , dp ) != 0 ) return ; } break ; case NFSPROC_SYMLINK : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( parsecreateopres ( ndo , dp , ndo -> ndo_vflag ) != NULL ) return ; } else { if ( parsestatus ( ndo , dp , & er ) != NULL ) return ; } break ; case NFSPROC_MKNOD : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( parsecreateopres ( ndo , dp , ndo -> ndo_vflag ) != NULL ) return ; break ; case NFSPROC_REMOVE : case NFSPROC_RMDIR : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( parsewccres ( ndo , dp , ndo -> ndo_vflag ) ) return ; } else { if ( parsestatus ( ndo , dp , & er ) != NULL ) return ; } break ; case NFSPROC_RENAME : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( ! ( dp = parsestatus ( ndo , dp , & er ) ) ) break ; if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , ""<S2SV_blank>from:"" ) ) ; if ( ! ( dp = parse_wcc_data ( ndo , dp , ndo -> ndo_vflag ) ) ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>to:"" ) ) ; if ( ! ( dp = parse_wcc_data ( ndo , dp , ndo -> ndo_vflag ) ) ) break ; } return ; } else { if ( parsestatus ( ndo , dp , & er ) != NULL ) return ; } break ; case NFSPROC_LINK : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( ! ( dp = parsestatus ( ndo , dp , & er ) ) ) break ; if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , ""<S2SV_blank>file<S2SV_blank>POST:"" ) ) ; if ( ! ( dp = parse_post_op_attr ( ndo , dp , ndo -> ndo_vflag ) ) ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>dir:"" ) ) ; if ( ! ( dp = parse_wcc_data ( ndo , dp , ndo -> ndo_vflag ) ) ) break ; return ; } } else { if ( parsestatus ( ndo , dp , & er ) != NULL ) return ; } break ; case NFSPROC_READDIR : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( parsev3rddirres ( ndo , dp , ndo -> ndo_vflag ) ) return ; } else { if ( parserddires ( ndo , dp ) != 0 ) return ; } break ; case NFSPROC_READDIRPLUS : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( parsev3rddirres ( ndo , dp , ndo -> ndo_vflag ) ) return ; break ; case NFSPROC_FSSTAT : dp = parserep ( ndo , rp , length ) ; if ( dp != NULL && parsestatfs ( ndo , dp , v3 ) != 0 ) return ; break ; case NFSPROC_FSINFO : dp = parserep ( ndo , rp , length ) ; if ( dp != NULL && parsefsinfo ( ndo , dp ) != 0 ) return ; break ; case NFSPROC_PATHCONF : dp = parserep ( ndo , rp , length ) ; if ( dp != NULL && parsepathconf ( ndo , dp ) != 0 ) return ; break ; case NFSPROC_COMMIT : dp = parserep ( ndo , rp , length ) ; if ( dp != NULL && parsewccres ( ndo , dp , ndo -> ndo_vflag ) != 0 ) return ; break ; default : return ; } trunc : if ( ! nfserr ) ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; }",if ( ! er ) {ND_TCHECK ( dp [ 0 ] ) ) ) ;return ;,441
590,"buggy line: static int udf_translate_to_linux ( uint8_t * newName , uint8_t * udfName ,   int udfLen , uint8_t * fidName ,  int fidNameLen ) {cwe id:CWE-17context:  static int udf_translate_to_linux ( uint8_t * newName , uint8_t * udfName ,   int udfLen , uint8_t * fidName ,  int fidNameLen ) { int index , newIndex = 0 , needsCRC = 0 ; int extIndex = 0 , newExtIndex = 0 , hasExt = 0 ; unsigned short valueCRC ; uint8_t curr ; if ( udfName [ 0 ] == '.' && ( udfLen == 1 || ( udfLen == 2 && udfName [ 1 ] == '.' ) ) ) { needsCRC = 1 ; newIndex = udfLen ; memcpy ( newName , udfName , udfLen ) ; } else { for ( index = 0 ; index < udfLen ; index ++ ) { curr = udfName [ index ] ; if ( curr == '/' || curr == 0 ) { needsCRC = 1 ; curr = ILLEGAL_CHAR_MARK ; while ( index + 1 < udfLen && ( udfName [ index + 1 ] == '/' || udfName [ index + 1 ] == 0 ) ) index ++ ; } if ( curr == EXT_MARK && ( udfLen - index - 1 ) <= EXT_SIZE ) { if ( udfLen == index + 1 ) hasExt = 0 ; else { hasExt = 1 ; extIndex = index ; newExtIndex = newIndex ; } }  if ( newIndex < 256 )  newName [ newIndex ++ ] = curr ; else needsCRC = 1 ; } } if ( needsCRC ) { uint8_t ext [ EXT_SIZE ] ; int localExtIndex = 0 ; if ( hasExt ) { int maxFilenameLen ; for ( index = 0 ; index < EXT_SIZE && extIndex + index + 1 < udfLen ; index ++ ) { curr = udfName [ extIndex + index + 1 ] ; if ( curr == '/' || curr == 0 ) { needsCRC = 1 ; curr = ILLEGAL_CHAR_MARK ; while ( extIndex + index + 2 < udfLen && ( index + 1 < EXT_SIZE && ( udfName [ extIndex + index + 2 ] == '/' || udfName [ extIndex + index + 2 ] == 0 ) ) ) index ++ ; } ext [ localExtIndex ++ ] = curr ; }  maxFilenameLen = 250 - localExtIndex ;  if ( newIndex > maxFilenameLen ) newIndex = maxFilenameLen ; else newIndex = newExtIndex ;  } else if ( newIndex > 250 )  newIndex = 250 ; newName [ newIndex ++ ] = CRC_MARK ; valueCRC = crc_itu_t ( 0 , fidName , fidNameLen ) ; newName [ newIndex ++ ] = hex_asc_upper_hi ( valueCRC >> 8 ) ; newName [ newIndex ++ ] = hex_asc_upper_lo ( valueCRC >> 8 ) ; newName [ newIndex ++ ] = hex_asc_upper_hi ( valueCRC ) ; newName [ newIndex ++ ] = hex_asc_upper_lo ( valueCRC ) ; if ( hasExt ) { newName [ newIndex ++ ] = EXT_MARK ; for ( index = 0 ; index < localExtIndex ; index ++ ) newName [ newIndex ++ ] = ext [ index ] ; } } return newIndex ; }","static int udf_translate_to_linux ( uint8_t * newName , int newLen , uint8_t * udfName , int udfLen , uint8_t * fidName , int fidNameLen ) {",442
591,"buggy line: if ( newIndex < 256 )  newName [ newIndex ++ ] = curr ;cwe id:CWE-17context:  static int udf_translate_to_linux ( uint8_t * newName , uint8_t * udfName ,   int udfLen , uint8_t * fidName ,  int fidNameLen ) { int index , newIndex = 0 , needsCRC = 0 ; int extIndex = 0 , newExtIndex = 0 , hasExt = 0 ; unsigned short valueCRC ; uint8_t curr ; if ( udfName [ 0 ] == '.' && ( udfLen == 1 || ( udfLen == 2 && udfName [ 1 ] == '.' ) ) ) { needsCRC = 1 ; newIndex = udfLen ; memcpy ( newName , udfName , udfLen ) ; } else { for ( index = 0 ; index < udfLen ; index ++ ) { curr = udfName [ index ] ; if ( curr == '/' || curr == 0 ) { needsCRC = 1 ; curr = ILLEGAL_CHAR_MARK ; while ( index + 1 < udfLen && ( udfName [ index + 1 ] == '/' || udfName [ index + 1 ] == 0 ) ) index ++ ; } if ( curr == EXT_MARK && ( udfLen - index - 1 ) <= EXT_SIZE ) { if ( udfLen == index + 1 ) hasExt = 0 ; else { hasExt = 1 ; extIndex = index ; newExtIndex = newIndex ; } }  if ( newIndex < 256 )  newName [ newIndex ++ ] = curr ; else needsCRC = 1 ; } } if ( needsCRC ) { uint8_t ext [ EXT_SIZE ] ; int localExtIndex = 0 ; if ( hasExt ) { int maxFilenameLen ; for ( index = 0 ; index < EXT_SIZE && extIndex + index + 1 < udfLen ; index ++ ) { curr = udfName [ extIndex + index + 1 ] ; if ( curr == '/' || curr == 0 ) { needsCRC = 1 ; curr = ILLEGAL_CHAR_MARK ; while ( extIndex + index + 2 < udfLen && ( index + 1 < EXT_SIZE && ( udfName [ extIndex + index + 2 ] == '/' || udfName [ extIndex + index + 2 ] == 0 ) ) ) index ++ ; } ext [ localExtIndex ++ ] = curr ; }  maxFilenameLen = 250 - localExtIndex ;  if ( newIndex > maxFilenameLen ) newIndex = maxFilenameLen ; else newIndex = newExtIndex ;  } else if ( newIndex > 250 )  newIndex = 250 ; newName [ newIndex ++ ] = CRC_MARK ; valueCRC = crc_itu_t ( 0 , fidName , fidNameLen ) ; newName [ newIndex ++ ] = hex_asc_upper_hi ( valueCRC >> 8 ) ; newName [ newIndex ++ ] = hex_asc_upper_lo ( valueCRC >> 8 ) ; newName [ newIndex ++ ] = hex_asc_upper_hi ( valueCRC ) ; newName [ newIndex ++ ] = hex_asc_upper_lo ( valueCRC ) ; if ( hasExt ) { newName [ newIndex ++ ] = EXT_MARK ; for ( index = 0 ; index < localExtIndex ; index ++ ) newName [ newIndex ++ ] = ext [ index ] ; } } return newIndex ; }",if ( newIndex < newLen ) newName [ newIndex ++ ] = curr ;,442
592,"buggy line: maxFilenameLen = 250 - localExtIndex ;if ( newIndex > maxFilenameLen ) newIndex = maxFilenameLen ;else newIndex = newExtIndex ;}else if ( newIndex > 250 )  newIndex = 250 ;cwe id:CWE-17context:  static int udf_translate_to_linux ( uint8_t * newName , uint8_t * udfName ,   int udfLen , uint8_t * fidName ,  int fidNameLen ) { int index , newIndex = 0 , needsCRC = 0 ; int extIndex = 0 , newExtIndex = 0 , hasExt = 0 ; unsigned short valueCRC ; uint8_t curr ; if ( udfName [ 0 ] == '.' && ( udfLen == 1 || ( udfLen == 2 && udfName [ 1 ] == '.' ) ) ) { needsCRC = 1 ; newIndex = udfLen ; memcpy ( newName , udfName , udfLen ) ; } else { for ( index = 0 ; index < udfLen ; index ++ ) { curr = udfName [ index ] ; if ( curr == '/' || curr == 0 ) { needsCRC = 1 ; curr = ILLEGAL_CHAR_MARK ; while ( index + 1 < udfLen && ( udfName [ index + 1 ] == '/' || udfName [ index + 1 ] == 0 ) ) index ++ ; } if ( curr == EXT_MARK && ( udfLen - index - 1 ) <= EXT_SIZE ) { if ( udfLen == index + 1 ) hasExt = 0 ; else { hasExt = 1 ; extIndex = index ; newExtIndex = newIndex ; } }  if ( newIndex < 256 )  newName [ newIndex ++ ] = curr ; else needsCRC = 1 ; } } if ( needsCRC ) { uint8_t ext [ EXT_SIZE ] ; int localExtIndex = 0 ; if ( hasExt ) { int maxFilenameLen ; for ( index = 0 ; index < EXT_SIZE && extIndex + index + 1 < udfLen ; index ++ ) { curr = udfName [ extIndex + index + 1 ] ; if ( curr == '/' || curr == 0 ) { needsCRC = 1 ; curr = ILLEGAL_CHAR_MARK ; while ( extIndex + index + 2 < udfLen && ( index + 1 < EXT_SIZE && ( udfName [ extIndex + index + 2 ] == '/' || udfName [ extIndex + index + 2 ] == 0 ) ) ) index ++ ; } ext [ localExtIndex ++ ] = curr ; }  maxFilenameLen = 250 - localExtIndex ;  if ( newIndex > maxFilenameLen ) newIndex = maxFilenameLen ; else newIndex = newExtIndex ;  } else if ( newIndex > 250 )  newIndex = 250 ; newName [ newIndex ++ ] = CRC_MARK ; valueCRC = crc_itu_t ( 0 , fidName , fidNameLen ) ; newName [ newIndex ++ ] = hex_asc_upper_hi ( valueCRC >> 8 ) ; newName [ newIndex ++ ] = hex_asc_upper_lo ( valueCRC >> 8 ) ; newName [ newIndex ++ ] = hex_asc_upper_hi ( valueCRC ) ; newName [ newIndex ++ ] = hex_asc_upper_lo ( valueCRC ) ; if ( hasExt ) { newName [ newIndex ++ ] = EXT_MARK ; for ( index = 0 ; index < localExtIndex ; index ++ ) newName [ newIndex ++ ] = ext [ index ] ; } } return newIndex ; }",maxFilenameLen = newLen - CRC_LEN - localExtIndex ;if ( newIndex > newLen - CRC_LEN ) newIndex = newLen - CRC_LEN ;,442
593,"buggy line: static void count_segs_sb ( VP9_COMP * cpi , const TileInfo * const tile ,   MODE_INFO * * mi_8x8 ,  int * no_pred_segcounts , int ( * temporal_predictor_count ) [ 2 ] , int * t_unpred_seg_counts , int mi_row , int mi_col , BLOCK_SIZE bsize ) {const VP9_COMMON * const cm = & cpi -> common ;const int mis = cm -> mi_stride ;const int bs = num_8x8_blocks_wide_lookup [ bsize ] , hbs = bs / 2 ;if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) return ;bw = num_8x8_blocks_wide_lookup [ mi_8x8 [ 0 ] -> mbmi . sb_type ] ;bh = num_8x8_blocks_high_lookup [ mi_8x8 [ 0 ] -> mbmi . sb_type ] ;if ( bw == bs && bh == bs ) {count_segs ( cpi , tile , mi_8x8 , no_pred_segcounts , temporal_predictor_count ,  t_unpred_seg_counts , bs , bs , mi_row , mi_col ) ;count_segs ( cpi , tile , mi_8x8 , no_pred_segcounts , temporal_predictor_count ,  t_unpred_seg_counts , bs , hbs , mi_row , mi_col ) ;count_segs ( cpi , tile , mi_8x8 + hbs * mis , no_pred_segcounts ,  temporal_predictor_count , t_unpred_seg_counts , bs , hbs , mi_row + hbs , mi_col ) ;count_segs ( cpi , tile , mi_8x8 , no_pred_segcounts , temporal_predictor_count ,  t_unpred_seg_counts , hbs , bs , mi_row , mi_col ) ;count_segs ( cpi , tile , mi_8x8 + hbs ,  no_pred_segcounts , temporal_predictor_count , t_unpred_seg_counts , hbs , bs , mi_row , mi_col + hbs ) ;cwe id:CWE-119context:  static void count_segs_sb ( VP9_COMP * cpi , const TileInfo * const tile ,   MODE_INFO * * mi_8x8 ,  int * no_pred_segcounts , int ( * temporal_predictor_count ) [ 2 ] , int * t_unpred_seg_counts , int mi_row , int mi_col , BLOCK_SIZE bsize ) {  const VP9_COMMON * const cm = & cpi -> common ;  const int mis = cm -> mi_stride ; int bw , bh ; const int bs = num_8x8_blocks_wide_lookup [ bsize ] , hbs = bs / 2 ; if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) return ;  bw = num_8x8_blocks_wide_lookup [ mi_8x8 [ 0 ] -> mbmi . sb_type ] ;   bh = num_8x8_blocks_high_lookup [ mi_8x8 [ 0 ] -> mbmi . sb_type ] ;  if ( bw == bs && bh == bs ) {  count_segs ( cpi , tile , mi_8x8 , no_pred_segcounts , temporal_predictor_count ,  t_unpred_seg_counts , bs , bs , mi_row , mi_col ) ; } else if ( bw == bs && bh < bs ) {  count_segs ( cpi , tile , mi_8x8 , no_pred_segcounts , temporal_predictor_count ,  t_unpred_seg_counts , bs , hbs , mi_row , mi_col ) ;  count_segs ( cpi , tile , mi_8x8 + hbs * mis , no_pred_segcounts ,  temporal_predictor_count , t_unpred_seg_counts , bs , hbs , mi_row + hbs , mi_col ) ; } else if ( bw < bs && bh == bs ) {  count_segs ( cpi , tile , mi_8x8 , no_pred_segcounts , temporal_predictor_count ,  t_unpred_seg_counts , hbs , bs , mi_row , mi_col ) ;  count_segs ( cpi , tile , mi_8x8 + hbs ,  no_pred_segcounts , temporal_predictor_count , t_unpred_seg_counts , hbs , bs , mi_row , mi_col + hbs ) ; } else { const BLOCK_SIZE subsize = subsize_lookup [ PARTITION_SPLIT ] [ bsize ] ; int n ; assert ( bw < bs && bh < bs ) ; for ( n = 0 ; n < 4 ; n ++ ) { const int mi_dc = hbs * ( n & 1 ) ; const int mi_dr = hbs * ( n >> 1 ) ;  count_segs_sb ( cpi , tile , & mi_8x8 [ mi_dr * mis + mi_dc ] ,  no_pred_segcounts , temporal_predictor_count , t_unpred_seg_counts , mi_row + mi_dr , mi_col + mi_dc , subsize ) ; } } }","static void count_segs_sb ( const VP9_COMMON * cm , MACROBLOCKD * xd , const TileInfo * tile , MODE_INFO * * mi_8x8 , int * no_pred_segcounts , int ( * temporal_predictor_count ) [ 2 ] , int * t_unpred_seg_counts , int mi_row , int mi_col , BLOCK_SIZE bsize ) {const int mis = cm -> mi_stride ;const int bs = num_8x8_blocks_wide_lookup [ mi [ 0 ] -> mbmi . sb_type ] ;bh = num_8x8_blocks_high_lookup [ mi_8x8 [ 0 ] -> mbmi . sb_type ] ;if ( bw == bs && bh == bs ) {count_segs ( cm , xd , tile , mi , no_pred_segcounts , temporal_predictor_count , t_unpred_seg_counts , bs , bs , mi_row , mi_col ) ;count_segs ( cm , xd , tile , mi , no_pred_segcounts , temporal_predictor_count , t_unpred_seg_counts , bs , hbs , mi_row , mi_col ) ;count_segs ( cm , xd , tile , mi + hbs * mis , no_pred_segcounts , temporal_predictor_count , t_unpred_seg_counts , bs , hbs , mi_row + hbs , mi_col ) ;count_segs ( cm , xd , tile , mi , no_pred_segcounts , temporal_predictor_count , t_unpred_seg_counts , hbs , bs , mi_row , mi_col ) ;count_segs ( cm , xd , tile , mi + hbs , no_pred_segcounts , temporal_predictor_count , t_unpred_seg_counts , hbs , bs , mi_row , mi_col + hbs ) ;",443
594,"buggy line: count_segs_sb ( cpi , tile , & mi_8x8 [ mi_dr * mis + mi_dc ] ,  no_pred_segcounts , temporal_predictor_count , t_unpred_seg_counts , mi_row + mi_dr , mi_col + mi_dc , subsize ) ;cwe id:CWE-119context:  static void count_segs_sb ( VP9_COMP * cpi , const TileInfo * const tile ,   MODE_INFO * * mi_8x8 ,  int * no_pred_segcounts , int ( * temporal_predictor_count ) [ 2 ] , int * t_unpred_seg_counts , int mi_row , int mi_col , BLOCK_SIZE bsize ) {  const VP9_COMMON * const cm = & cpi -> common ;  const int mis = cm -> mi_stride ; int bw , bh ; const int bs = num_8x8_blocks_wide_lookup [ bsize ] , hbs = bs / 2 ; if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) return ;  bw = num_8x8_blocks_wide_lookup [ mi_8x8 [ 0 ] -> mbmi . sb_type ] ;   bh = num_8x8_blocks_high_lookup [ mi_8x8 [ 0 ] -> mbmi . sb_type ] ;  if ( bw == bs && bh == bs ) {  count_segs ( cpi , tile , mi_8x8 , no_pred_segcounts , temporal_predictor_count ,  t_unpred_seg_counts , bs , bs , mi_row , mi_col ) ; } else if ( bw == bs && bh < bs ) {  count_segs ( cpi , tile , mi_8x8 , no_pred_segcounts , temporal_predictor_count ,  t_unpred_seg_counts , bs , hbs , mi_row , mi_col ) ;  count_segs ( cpi , tile , mi_8x8 + hbs * mis , no_pred_segcounts ,  temporal_predictor_count , t_unpred_seg_counts , bs , hbs , mi_row + hbs , mi_col ) ; } else if ( bw < bs && bh == bs ) {  count_segs ( cpi , tile , mi_8x8 , no_pred_segcounts , temporal_predictor_count ,  t_unpred_seg_counts , hbs , bs , mi_row , mi_col ) ;  count_segs ( cpi , tile , mi_8x8 + hbs ,  no_pred_segcounts , temporal_predictor_count , t_unpred_seg_counts , hbs , bs , mi_row , mi_col + hbs ) ; } else { const BLOCK_SIZE subsize = subsize_lookup [ PARTITION_SPLIT ] [ bsize ] ; int n ; assert ( bw < bs && bh < bs ) ; for ( n = 0 ; n < 4 ; n ++ ) { const int mi_dc = hbs * ( n & 1 ) ; const int mi_dr = hbs * ( n >> 1 ) ;  count_segs_sb ( cpi , tile , & mi_8x8 [ mi_dr * mis + mi_dc ] ,  no_pred_segcounts , temporal_predictor_count , t_unpred_seg_counts , mi_row + mi_dr , mi_col + mi_dc , subsize ) ; } } }","count_segs_sb ( cm , xd , tile , & mi [ mi_dr * mis + mi_dc ] , no_pred_segcounts , temporal_predictor_count , t_unpred_seg_counts , mi_row + mi_dr , mi_col + mi_dc , subsize ) ;",443
595,"buggy line: if ( ! ( c -> flags & CLIENT_SLAVE ) && clientsArePaused ( ) ) break ;if ( c -> flags & CLIENT_CLOSE_AFTER_REPLY ) break ;if ( ! c -> reqtype ) {cwe id:CWE-254context: void processInputBuffer ( client * c ) { server . current_client = c ; while ( sdslen ( c -> querybuf ) ) { if ( ! ( c -> flags & CLIENT_SLAVE ) && clientsArePaused ( ) ) break ; if ( c -> flags & CLIENT_BLOCKED ) break ;  if ( c -> flags & CLIENT_CLOSE_AFTER_REPLY ) break ;  if ( ! c -> reqtype ) { if ( c -> querybuf [ 0 ] == '*' ) { c -> reqtype = PROTO_REQ_MULTIBULK ; } else { c -> reqtype = PROTO_REQ_INLINE ; } } if ( c -> reqtype == PROTO_REQ_INLINE ) { if ( processInlineBuffer ( c ) != C_OK ) break ; } else if ( c -> reqtype == PROTO_REQ_MULTIBULK ) { if ( processMultibulkBuffer ( c ) != C_OK ) break ; } else { serverPanic ( ""Unknown<S2SV_blank>request<S2SV_blank>type"" ) ; } if ( c -> argc == 0 ) { resetClient ( c ) ; } else { if ( processCommand ( c ) == C_OK ) resetClient ( c ) ; if ( server . current_client == NULL ) break ; } } server . current_client = NULL ; }",if ( ! ( c -> flags & ( CLIENT_CLOSE_AFTER_REPLY | CLIENT_CLOSE_ASAP ) ) break ;if ( c -> flags & CLIENT_CLOSE_AFTER_REPLY ) break ;if ( ! c -> reqtype ) {,444
596,"buggy line: get_blocks_flags = EXT4_GET_BLOCKS_CREATE ;if ( mpd -> b_state & ( 1 << BH_Delay ) ) get_blocks_flags |= EXT4_GET_BLOCKS_DELALLOC_RESERVE ;cwe id:CWE-000context: static int mpage_da_map_blocks ( struct mpage_da_data * mpd ) { int err , blks , get_blocks_flags ; struct buffer_head new ; sector_t next = mpd -> b_blocknr ; unsigned max_blocks = mpd -> b_size >> mpd -> inode -> i_blkbits ; loff_t disksize = EXT4_I ( mpd -> inode ) -> i_disksize ; handle_t * handle = NULL ; if ( ( mpd -> b_state & ( 1 << BH_Mapped ) ) && ! ( mpd -> b_state & ( 1 << BH_Delay ) ) && ! ( mpd -> b_state & ( 1 << BH_Unwritten ) ) ) return 0 ; if ( ! mpd -> b_size ) return 0 ; handle = ext4_journal_current_handle ( ) ; BUG_ON ( ! handle ) ; new . b_state = 0 ;  get_blocks_flags = EXT4_GET_BLOCKS_CREATE ;  if ( mpd -> b_state & ( 1 << BH_Delay ) ) get_blocks_flags |= EXT4_GET_BLOCKS_DELALLOC_RESERVE ; blks = ext4_get_blocks ( handle , mpd -> inode , next , max_blocks , & new , get_blocks_flags ) ; if ( blks < 0 ) { err = blks ; if ( err == - EAGAIN ) return 0 ; if ( err == - ENOSPC && ext4_count_free_blocks ( mpd -> inode -> i_sb ) ) { mpd -> retval = err ; return 0 ; } ext4_msg ( mpd -> inode -> i_sb , KERN_CRIT , ""delayed<S2SV_blank>block<S2SV_blank>allocation<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>inode<S2SV_blank>%lu<S2SV_blank>at<S2SV_blank>"" ""logical<S2SV_blank>offset<S2SV_blank>%llu<S2SV_blank>with<S2SV_blank>max<S2SV_blank>blocks<S2SV_blank>%zd<S2SV_blank>with<S2SV_blank>"" ""error<S2SV_blank>%d\\n"" , mpd -> inode -> i_ino , ( unsigned long long ) next , mpd -> b_size >> mpd -> inode -> i_blkbits , err ) ; printk ( KERN_CRIT ""This<S2SV_blank>should<S2SV_blank>not<S2SV_blank>happen!!<S2SV_blank><S2SV_blank>"" ""Data<S2SV_blank>will<S2SV_blank>be<S2SV_blank>lost\\n"" ) ; if ( err == - ENOSPC ) { ext4_print_free_blocks ( mpd -> inode ) ; } ext4_da_block_invalidatepages ( mpd , next , mpd -> b_size >> mpd -> inode -> i_blkbits ) ; return err ; } BUG_ON ( blks == 0 ) ; new . b_size = ( blks << mpd -> inode -> i_blkbits ) ; if ( buffer_new ( & new ) ) __unmap_underlying_blocks ( mpd -> inode , & new ) ; if ( ( mpd -> b_state & ( 1 << BH_Delay ) ) || ( mpd -> b_state & ( 1 << BH_Unwritten ) ) ) mpage_put_bnr_to_bhs ( mpd , next , & new ) ; if ( ext4_should_order_data ( mpd -> inode ) ) { err = ext4_jbd2_file_inode ( handle , mpd -> inode ) ; if ( err ) return err ; } disksize = ( ( loff_t ) next + blks ) << mpd -> inode -> i_blkbits ; if ( disksize > i_size_read ( mpd -> inode ) ) disksize = i_size_read ( mpd -> inode ) ; if ( disksize > EXT4_I ( mpd -> inode ) -> i_disksize ) { ext4_update_i_disksize ( mpd -> inode , disksize ) ; return ext4_mark_inode_dirty ( handle , mpd -> inode ) ; } return 0 ; }",get_blocks_flags = EXT4_GET_BLOCKS_CREATE ;if ( ext4_should_dioread_nolock ( mpd -> inode ) ) get_blocks_flags |= EXT4_GET_BLOCKS_IO_CREATE_EXT ;if ( mpd -> b_state & ( 1 << BH_Delay ) ) get_blocks_flags |= EXT4_GET_BLOCKS_DELALLOC_RESERVE ;,445
597,"buggy line: int ret = - 1 ;s = DSA_SIG_new ( ) ;if ( d2i_DSA_SIG ( & s , & sigbuf , siglen ) == NULL ) goto err ;ret = DSA_do_verify ( dgst , dgst_len , s , dsa ) ;err :  DSA_SIG_free ( s ) ;return ( ret ) ;cwe id:CWE-310context: int DSA_verify ( int type , const unsigned char * dgst , int dgst_len , const unsigned char * sigbuf , int siglen , DSA * dsa ) { DSA_SIG * s ;  int ret = - 1 ;  s = DSA_SIG_new ( ) ; if ( s == NULL ) return ( ret ) ;  if ( d2i_DSA_SIG ( & s , & sigbuf , siglen ) == NULL ) goto err ;  ret = DSA_do_verify ( dgst , dgst_len , s , dsa ) ; err :  DSA_SIG_free ( s ) ;  return ( ret ) ; }","const unsigned char * p = sigbuf ;unsigned char * der = NULL ;int derlen = - 1 ;int ret = - 1 ;s = DSA_SIG_new ( ) ;if ( d2i_DSA_SIG ( & s , & p , siglen ) == NULL ) goto err ;derlen = i2d_DSA_SIG ( s , & der ) ;if ( derlen != siglen || memcmp ( sigbuf , der , derlen ) ) goto err ;ret = DSA_do_verify ( dgst , dgst_len , s , dsa ) ;err : if ( derlen > 0 ) {OPENSSL_cleanse ( der , derlen ) ;OPENSSL_free ( der ) ;}DSA_SIG_free ( s ) ;return ( ret ) ;",446
598,"buggy line: gdImageGifCtx ( im , out ) ;rv = gdDPExtractData ( out , size ) ;out -> gd_free ( out ) ;cwe id:CWE-415context: void * gdImageGifPtr ( gdImagePtr im , int * size ) { void * rv ; gdIOCtx * out = gdNewDynamicCtx ( 2048 , NULL ) ;  gdImageGifCtx ( im , out ) ;   rv = gdDPExtractData ( out , size ) ;  out -> gd_free ( out ) ; return rv ; }","if ( ! _gdImageGifCtx ( im , out ) ) {rv = gdDPExtractData ( out , size ) ;}else {rv = NULL ;}out -> gd_free ( out ) ;",447
599,buggy line: kfree ( bprm ) ;}cwe id:CWE-200context: void free_bprm ( struct linux_binprm * bprm ) { free_arg_pages ( bprm ) ; if ( bprm -> cred ) { mutex_unlock ( & current -> signal -> cred_guard_mutex ) ; abort_creds ( bprm -> cred ) ; }  kfree ( bprm ) ;  },if ( bprm -> interp != bprm -> filename ) kfree ( bprm -> interp ) ;kfree ( bprm ) ;},448
600,"buggy line: size_t canonnamelen = 0 ;if ( ! ( p = oe_calloc ( 1 , sizeof ( struct oe_addrinfo ) ) ) )  {if ( oe_syscall_getaddrinfo_read_ocall ( & retval , handle ,  & p -> ai_flags ,   & p -> ai_family ,   & p -> ai_socktype ,   & p -> ai_protocol ,  p -> ai_addrlen ,  & p -> ai_addrlen ,  NULL ,  canonnamelen ,  & canonnamelen , NULL ) != OE_OK ) {cwe id:CWE-552context: static int _hostresolver_getaddrinfo ( oe_resolver_t * resolver , const char * node , const char * service , const struct oe_addrinfo * hints , struct oe_addrinfo * * res ) { int ret = OE_EAI_FAIL ; uint64_t handle = 0 ; struct oe_addrinfo * head = NULL ; struct oe_addrinfo * tail = NULL ; struct oe_addrinfo * p = NULL ; OE_UNUSED ( resolver ) ; if ( res ) * res = NULL ; if ( ! res ) { ret = OE_EAI_SYSTEM ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } { int retval = OE_EAI_FAIL ; if ( oe_syscall_getaddrinfo_open_ocall ( & retval , node , service , hints , & handle ) != OE_OK ) { ret = OE_EAI_SYSTEM ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } if ( ! handle ) { ret = retval ; goto done ; } } for ( ; ; ) { int retval = 0 ;  size_t canonnamelen = 0 ;   if ( ! ( p = oe_calloc ( 1 , sizeof ( struct oe_addrinfo ) ) ) )  { ret = OE_EAI_MEMORY ; goto done ; } if ( oe_syscall_getaddrinfo_read_ocall ( & retval , handle ,  & p -> ai_flags ,   & p -> ai_family ,   & p -> ai_socktype ,   & p -> ai_protocol ,  p -> ai_addrlen ,  & p -> ai_addrlen ,  NULL ,  canonnamelen ,  & canonnamelen , NULL ) != OE_OK ) { ret = OE_EAI_SYSTEM ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } if ( retval == 1 ) break ; if ( retval != - 1 || oe_errno != OE_ENAMETOOLONG ) { ret = OE_EAI_SYSTEM ; OE_RAISE_ERRNO ( oe_errno ) ; }  if ( p -> ai_addrlen && ! ( p -> ai_addr = oe_calloc ( 1 , p -> ai_addrlen ) ) )  { ret = OE_EAI_MEMORY ; goto done ; }  if ( canonnamelen && ! ( p -> ai_canonname = oe_calloc ( 1 , canonnamelen ) ) )  { ret = OE_EAI_MEMORY ; goto done ; }  if ( oe_syscall_getaddrinfo_read_ocall (  & retval , handle , & p -> ai_flags , & p -> ai_family , & p -> ai_socktype , & p -> ai_protocol ,  p -> ai_addrlen ,  & p -> ai_addrlen , p -> ai_addr ,  canonnamelen ,  & canonnamelen , p -> ai_canonname ) != OE_OK ) { ret = OE_EAI_SYSTEM ; OE_RAISE_ERRNO ( OE_EINVAL ) ; }  if ( tail )  { tail -> ai_next = p ; tail = p ; } else { head = p ; tail = p ; } p = NULL ; } if ( handle ) { int retval = - 1 ; if ( oe_syscall_getaddrinfo_close_ocall ( & retval , handle ) != OE_OK ) { ret = OE_EAI_SYSTEM ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } handle = 0 ; if ( retval != 0 ) { ret = OE_EAI_SYSTEM ; OE_RAISE_ERRNO ( oe_errno ) ; } } if ( ! head ) { ret = OE_EAI_SYSTEM ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } * res = head ; head = NULL ; tail = NULL ; ret = 0 ; done : if ( handle ) { int retval ; oe_syscall_getaddrinfo_close_ocall ( & retval , handle ) ; } if ( head ) oe_freeaddrinfo ( head ) ; if ( p ) oe_freeaddrinfo ( p ) ; return ret ; }","size_t canonnamelen_in = 0 ;if ( ! ( p = oe_calloc ( 1 , sizeof ( struct oe_addrinfo ) ) ) ) {if ( oe_syscall_getaddrinfo_read_ocall ( & retval , handle , & p_out . ai_flags , & p -> ai_family , & p -> ai_socktype , & p -> ai_protocol , p -> ai_addrlen , & p -> ai_addrlen , NULL , canonnamelen , & canonnamelen , NULL ) != OE_OK ) {",449
601,"buggy line: if ( p -> ai_addrlen && ! ( p -> ai_addr = oe_calloc ( 1 , p -> ai_addrlen ) ) )  {if ( canonnamelen && ! ( p -> ai_canonname = oe_calloc ( 1 , canonnamelen ) ) )  {if ( oe_syscall_getaddrinfo_read_ocall (  & retval , handle , & p -> ai_flags , & p -> ai_family , & p -> ai_socktype , & p -> ai_protocol ,  p -> ai_addrlen ,  & p -> ai_addrlen , p -> ai_addr ,  canonnamelen ,  & canonnamelen , p -> ai_canonname ) != OE_OK ) {if ( tail )  {cwe id:CWE-552context: static int _hostresolver_getaddrinfo ( oe_resolver_t * resolver , const char * node , const char * service , const struct oe_addrinfo * hints , struct oe_addrinfo * * res ) { int ret = OE_EAI_FAIL ; uint64_t handle = 0 ; struct oe_addrinfo * head = NULL ; struct oe_addrinfo * tail = NULL ; struct oe_addrinfo * p = NULL ; OE_UNUSED ( resolver ) ; if ( res ) * res = NULL ; if ( ! res ) { ret = OE_EAI_SYSTEM ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } { int retval = OE_EAI_FAIL ; if ( oe_syscall_getaddrinfo_open_ocall ( & retval , node , service , hints , & handle ) != OE_OK ) { ret = OE_EAI_SYSTEM ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } if ( ! handle ) { ret = retval ; goto done ; } } for ( ; ; ) { int retval = 0 ;  size_t canonnamelen = 0 ;   if ( ! ( p = oe_calloc ( 1 , sizeof ( struct oe_addrinfo ) ) ) )  { ret = OE_EAI_MEMORY ; goto done ; } if ( oe_syscall_getaddrinfo_read_ocall ( & retval , handle ,  & p -> ai_flags ,   & p -> ai_family ,   & p -> ai_socktype ,   & p -> ai_protocol ,  p -> ai_addrlen ,  & p -> ai_addrlen ,  NULL ,  canonnamelen ,  & canonnamelen , NULL ) != OE_OK ) { ret = OE_EAI_SYSTEM ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } if ( retval == 1 ) break ; if ( retval != - 1 || oe_errno != OE_ENAMETOOLONG ) { ret = OE_EAI_SYSTEM ; OE_RAISE_ERRNO ( oe_errno ) ; }  if ( p -> ai_addrlen && ! ( p -> ai_addr = oe_calloc ( 1 , p -> ai_addrlen ) ) )  { ret = OE_EAI_MEMORY ; goto done ; }  if ( canonnamelen && ! ( p -> ai_canonname = oe_calloc ( 1 , canonnamelen ) ) )  { ret = OE_EAI_MEMORY ; goto done ; }  if ( oe_syscall_getaddrinfo_read_ocall (  & retval , handle , & p -> ai_flags , & p -> ai_family , & p -> ai_socktype , & p -> ai_protocol ,  p -> ai_addrlen ,  & p -> ai_addrlen , p -> ai_addr ,  canonnamelen ,  & canonnamelen , p -> ai_canonname ) != OE_OK ) { ret = OE_EAI_SYSTEM ; OE_RAISE_ERRNO ( OE_EINVAL ) ; }  if ( tail )  { tail -> ai_next = p ; tail = p ; } else { head = p ; tail = p ; } p = NULL ; } if ( handle ) { int retval = - 1 ; if ( oe_syscall_getaddrinfo_close_ocall ( & retval , handle ) != OE_OK ) { ret = OE_EAI_SYSTEM ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } handle = 0 ; if ( retval != 0 ) { ret = OE_EAI_SYSTEM ; OE_RAISE_ERRNO ( oe_errno ) ; } } if ( ! head ) { ret = OE_EAI_SYSTEM ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } * res = head ; head = NULL ; tail = NULL ; ret = 0 ; done : if ( handle ) { int retval ; oe_syscall_getaddrinfo_close_ocall ( & retval , handle ) ; } if ( head ) oe_freeaddrinfo ( head ) ; if ( p ) oe_freeaddrinfo ( p ) ; return ret ; }","if ( p -> ai_addrlen && ! ( p -> ai_addr = oe_calloc ( 1 , p -> ai_addrlen ) ) ) {if ( canonnamelen && ! ( p -> ai_canonname = oe_calloc ( 1 , canonnamelen ) ) ) {if ( oe_syscall_getaddrinfo_read_ocall ( & retval , handle , & p -> ai_flags , & p_out . ai_family , & p -> ai_socktype , & p_out . ai_protocol , p_out . ai_addrlen , & p -> ai_addrlen , p -> ai_addr , canonnamelen_in , & canonnamelen_out , p -> ai_canonname ) != OE_OK ) {if ( ( p -> ai_flags != p_out . ai_flags ) || ( p -> ai_family != p_out . ai_family ) || ( p -> ai_socktype != p_out . ai_socktype ) || ( p -> ai_protocol != p_out . ai_protocol ) || ( p -> ai_addrlen != p_out . ai_addrlen ) || ( canonnamelen_out != canonnamelen_in ) || ( canonnamelen_out && p -> ai_canonname [ canonnamelen_out - 1 ] != '\\\\0' ) ) {ret = OE_EAI_FAIL ;goto done ;}if ( tail ) {",449
602,"buggy line: separator = strchr ( token , \':\' ) ;if ( separator != NULL ) {cwe id:CWE-20context: void httpParseAuthorizationField ( HttpConnection * connection , char_t * value ) { char_t * p ; char_t * token ; token = osStrtok_r ( value , ""<S2SV_blank>\\t"" , & p ) ; if ( token == NULL ) { return ; } # if ( HTTP_SERVER_BASIC_AUTH_SUPPORT == ENABLED ) else if ( ! osStrcasecmp ( token , ""Basic"" ) ) { error_t error ; size_t n ; char_t * separator ; connection -> request . auth . mode = HTTP_AUTH_MODE_BASIC ; token = osStrtok_r ( NULL , ""<S2SV_blank>\\t"" , & p ) ; if ( token != NULL ) { error = base64Decode ( token , osStrlen ( token ) , token , & n ) ; if ( ! error ) { token [ n ] = '\\0' ;  separator = strchr ( token , ':' ) ;  if ( separator != NULL ) { * separator = '\\0' ; strSafeCopy ( connection -> request . auth . user , token , HTTP_SERVER_USERNAME_MAX_LEN ) ; token = separator + 1 ; connection -> request . auth . password = token ; } } } TRACE_DEBUG ( ""Authorization<S2SV_blank>header:\\r\\n"" ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>username:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . user ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>password:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . password ) ; } # endif # if ( HTTP_SERVER_DIGEST_AUTH_SUPPORT == ENABLED ) else if ( ! osStrcasecmp ( token , ""Digest"" ) ) { size_t n ; char_t * separator ; char_t * name ; connection -> request . auth . mode = HTTP_AUTH_MODE_DIGEST ; token = osStrtok_r ( NULL , "","" , & p ) ; while ( token != NULL ) {  separator = strchr ( token , '=' ) ;  if ( separator != NULL ) { * separator = '\\0' ; name = strTrimWhitespace ( token ) ; value = strTrimWhitespace ( separator + 1 ) ; n = osStrlen ( value ) ; if ( n > 0 && value [ n - 1 ] == \'\\""\' ) value [ n - 1 ] = '\\0' ; if ( value [ 0 ] == \'\\""\' ) value ++ ; if ( ! osStrcasecmp ( name , ""username"" ) ) { strSafeCopy ( connection -> request . auth . user , value , HTTP_SERVER_USERNAME_MAX_LEN ) ; } else if ( ! osStrcasecmp ( name , ""realm"" ) ) { connection -> request . auth . realm = value ; } else if ( ! osStrcasecmp ( name , ""nonce"" ) ) { connection -> request . auth . nonce = value ; } else if ( ! osStrcasecmp ( name , ""uri"" ) ) { connection -> request . auth . uri = value ; } else if ( ! osStrcasecmp ( name , ""qop"" ) ) { connection -> request . auth . qop = value ; } else if ( ! osStrcasecmp ( name , ""nc"" ) ) { connection -> request . auth . nc = value ; } else if ( ! osStrcasecmp ( name , ""cnonce"" ) ) { connection -> request . auth . cnonce = value ; } else if ( ! osStrcasecmp ( name , ""response"" ) ) { connection -> request . auth . response = value ; } else if ( ! osStrcasecmp ( name , ""opaque"" ) ) { connection -> request . auth . opaque = value ; } token = osStrtok_r ( NULL , "","" , & p ) ; } } TRACE_DEBUG ( ""Authorization<S2SV_blank>header:\\r\\n"" ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>username:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . user ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>realm:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . realm ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>nonce:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . nonce ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>uri:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . uri ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>qop:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . qop ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>nc:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . nc ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>cnonce:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . cnonce ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>response:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . response ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>opaque:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . opaque ) ; } # endif else { return ; } # if ( HTTP_SERVER_BASIC_AUTH_SUPPORT == ENABLED || HTTP_SERVER_DIGEST_AUTH_SUPPORT == ENABLED ) connection -> request . auth . found = TRUE ; if ( connection -> settings -> authCallback != NULL ) { connection -> status = connection -> settings -> authCallback ( connection , connection -> request . auth . user , connection -> request . uri ) ; } else { connection -> status = HTTP_ACCESS_ALLOWED ; } # endif }","separator = osStrchr ( token , \':\' ) ;if ( separator != NULL ) {",450
603,"buggy line: separator = strchr ( token , \'=\' ) ;if ( separator != NULL ) {cwe id:CWE-20context: void httpParseAuthorizationField ( HttpConnection * connection , char_t * value ) { char_t * p ; char_t * token ; token = osStrtok_r ( value , ""<S2SV_blank>\\t"" , & p ) ; if ( token == NULL ) { return ; } # if ( HTTP_SERVER_BASIC_AUTH_SUPPORT == ENABLED ) else if ( ! osStrcasecmp ( token , ""Basic"" ) ) { error_t error ; size_t n ; char_t * separator ; connection -> request . auth . mode = HTTP_AUTH_MODE_BASIC ; token = osStrtok_r ( NULL , ""<S2SV_blank>\\t"" , & p ) ; if ( token != NULL ) { error = base64Decode ( token , osStrlen ( token ) , token , & n ) ; if ( ! error ) { token [ n ] = '\\0' ;  separator = strchr ( token , ':' ) ;  if ( separator != NULL ) { * separator = '\\0' ; strSafeCopy ( connection -> request . auth . user , token , HTTP_SERVER_USERNAME_MAX_LEN ) ; token = separator + 1 ; connection -> request . auth . password = token ; } } } TRACE_DEBUG ( ""Authorization<S2SV_blank>header:\\r\\n"" ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>username:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . user ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>password:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . password ) ; } # endif # if ( HTTP_SERVER_DIGEST_AUTH_SUPPORT == ENABLED ) else if ( ! osStrcasecmp ( token , ""Digest"" ) ) { size_t n ; char_t * separator ; char_t * name ; connection -> request . auth . mode = HTTP_AUTH_MODE_DIGEST ; token = osStrtok_r ( NULL , "","" , & p ) ; while ( token != NULL ) {  separator = strchr ( token , '=' ) ;  if ( separator != NULL ) { * separator = '\\0' ; name = strTrimWhitespace ( token ) ; value = strTrimWhitespace ( separator + 1 ) ; n = osStrlen ( value ) ; if ( n > 0 && value [ n - 1 ] == \'\\""\' ) value [ n - 1 ] = '\\0' ; if ( value [ 0 ] == \'\\""\' ) value ++ ; if ( ! osStrcasecmp ( name , ""username"" ) ) { strSafeCopy ( connection -> request . auth . user , value , HTTP_SERVER_USERNAME_MAX_LEN ) ; } else if ( ! osStrcasecmp ( name , ""realm"" ) ) { connection -> request . auth . realm = value ; } else if ( ! osStrcasecmp ( name , ""nonce"" ) ) { connection -> request . auth . nonce = value ; } else if ( ! osStrcasecmp ( name , ""uri"" ) ) { connection -> request . auth . uri = value ; } else if ( ! osStrcasecmp ( name , ""qop"" ) ) { connection -> request . auth . qop = value ; } else if ( ! osStrcasecmp ( name , ""nc"" ) ) { connection -> request . auth . nc = value ; } else if ( ! osStrcasecmp ( name , ""cnonce"" ) ) { connection -> request . auth . cnonce = value ; } else if ( ! osStrcasecmp ( name , ""response"" ) ) { connection -> request . auth . response = value ; } else if ( ! osStrcasecmp ( name , ""opaque"" ) ) { connection -> request . auth . opaque = value ; } token = osStrtok_r ( NULL , "","" , & p ) ; } } TRACE_DEBUG ( ""Authorization<S2SV_blank>header:\\r\\n"" ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>username:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . user ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>realm:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . realm ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>nonce:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . nonce ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>uri:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . uri ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>qop:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . qop ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>nc:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . nc ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>cnonce:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . cnonce ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>response:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . response ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>opaque:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . opaque ) ; } # endif else { return ; } # if ( HTTP_SERVER_BASIC_AUTH_SUPPORT == ENABLED || HTTP_SERVER_DIGEST_AUTH_SUPPORT == ENABLED ) connection -> request . auth . found = TRUE ; if ( connection -> settings -> authCallback != NULL ) { connection -> status = connection -> settings -> authCallback ( connection , connection -> request . auth . user , connection -> request . uri ) ; } else { connection -> status = HTTP_ACCESS_ALLOWED ; } # endif }","separator = osStrchr ( token , \'=\' ) ;if ( separator != NULL ) {",450
604,"buggy line: rctx -> image_height = ( int ) iw_get_ui16le ( & rctx -> rbuf [ 6 ] ) ;rctx -> interlaced = ( int ) ( ( rctx -> rbuf [ 8 ] >> 6 ) & 0x01 ) ;cwe id:CWE-369context: static int iwgif_read_image ( struct iwgifrcontext * rctx ) { int retval = 0 ; struct lzwdeccontext d ; size_t subblocksize ; int has_local_ct ; int local_ct_size ; unsigned int root_codesize ; if ( ! iwgif_read ( rctx , rctx -> rbuf , 9 ) ) goto done ; rctx -> image_left = ( int ) iw_get_ui16le ( & rctx -> rbuf [ 0 ] ) ; rctx -> image_top = ( int ) iw_get_ui16le ( & rctx -> rbuf [ 2 ] ) ; rctx -> image_width = ( int ) iw_get_ui16le ( & rctx -> rbuf [ 4 ] ) ;  rctx -> image_height = ( int ) iw_get_ui16le ( & rctx -> rbuf [ 6 ] ) ;  rctx -> interlaced = ( int ) ( ( rctx -> rbuf [ 8 ] >> 6 ) & 0x01 ) ; has_local_ct = ( int ) ( ( rctx -> rbuf [ 8 ] >> 7 ) & 0x01 ) ; if ( has_local_ct ) { local_ct_size = ( int ) ( rctx -> rbuf [ 8 ] & 0x07 ) ; rctx -> colortable . num_entries = 1 << ( 1 + local_ct_size ) ; } if ( has_local_ct ) { if ( ! iwgif_read_color_table ( rctx , & rctx -> colortable ) ) goto done ; } if ( rctx -> has_transparency ) { rctx -> colortable . entry [ rctx -> trans_color_index ] . a = 0 ; } if ( ! iwgif_read ( rctx , rctx -> rbuf , 1 ) ) goto done ; root_codesize = ( unsigned int ) rctx -> rbuf [ 0 ] ; if ( root_codesize < 2 || root_codesize > 11 ) { iw_set_error ( rctx -> ctx , ""Invalid<S2SV_blank>LZW<S2SV_blank>minimum<S2SV_blank>code<S2SV_blank>size"" ) ; goto done ; } if ( ! iwgif_init_screen ( rctx ) ) goto done ; rctx -> total_npixels = ( size_t ) rctx -> image_width * ( size_t ) rctx -> image_height ; if ( ! iwgif_make_row_pointers ( rctx ) ) goto done ; lzw_init ( & d , root_codesize ) ; lzw_clear ( & d ) ; while ( 1 ) { if ( ! iwgif_read ( rctx , rctx -> rbuf , 1 ) ) goto done ; subblocksize = ( size_t ) rctx -> rbuf [ 0 ] ; if ( subblocksize == 0 ) break ; if ( ! iwgif_read ( rctx , rctx -> rbuf , subblocksize ) ) goto done ; if ( ! lzw_process_bytes ( rctx , & d , rctx -> rbuf , subblocksize ) ) goto done ; if ( d . eoi_flag ) break ; if ( rctx -> pixels_set >= rctx -> total_npixels ) break ; } retval = 1 ; done : return retval ; }","if ( rctx -> image_width < 1 || rctx -> image_height < 1 ) {iw_set_error ( rctx -> ctx , ""Invalid<S2SV_blank>image<S2SV_blank>dimensions"" ) ;goto done ;}rctx -> image_height = ( int ) iw_get_ui16le ( & rctx -> rbuf [ 6 ] ) ;rctx -> interlaced = ( int ) ( ( rctx -> rbuf [ 8 ] >> 6 ) & 0x01 ) ;",451
605,"buggy line: vpx_memcpy ( pc -> fc . coef_probs , default_coef_probs ,  sizeof ( default_coef_probs ) ) ;cwe id:CWE-119context: void vp8_default_coef_probs ( VP8_COMMON * pc ) {  vpx_memcpy ( pc -> fc . coef_probs , default_coef_probs ,  sizeof ( default_coef_probs ) ) ; }","memcpy ( pc -> fc . coef_probs , default_coef_probs , sizeof ( default_coef_probs ) ) ;",452
606,"buggy line: static int set_registers ( pegasus_t * pegasus , __u16 indx , __u16 size , void * data )  {int ret ;ret = usb_control_msg ( pegasus -> usb , usb_sndctrlpipe ( pegasus -> usb , 0 ) , PEGASUS_REQ_SET_REGS , PEGASUS_REQT_WRITE , 0 ,  indx , data , size , 100 ) ;if ( ret < 0 ) netif_dbg ( pegasus , drv , pegasus -> net , ""%s<S2SV_blank>returned<S2SV_blank>%d\\\return ret ;}cwe id:CWE-119context:  static int set_registers ( pegasus_t * pegasus , __u16 indx , __u16 size , void * data )  {  int ret ;  ret = usb_control_msg ( pegasus -> usb , usb_sndctrlpipe ( pegasus -> usb , 0 ) , PEGASUS_REQ_SET_REGS , PEGASUS_REQT_WRITE , 0 ,  indx , data , size , 100 ) ;  if ( ret < 0 ) netif_dbg ( pegasus , drv , pegasus -> net , ""%s<S2SV_blank>returned<S2SV_blank>%d\\n"" , __func__ , ret ) ;  return ret ;  }","static int set_registers ( pegasus_t * pegasus , __u16 indx , __u16 size , const void * data ) {u8 * buf ;int ret ;buf = kmemdup ( data , size , GFP_NOIO ) ;if ( ! buf ) return - ENOMEM ;ret = usb_control_msg ( pegasus -> usb , usb_sndctrlpipe ( pegasus -> usb , 0 ) , PEGASUS_REQ_SET_REGS , PEGASUS_REQT_WRITE , 0 , indx , buf , size , 100 ) ;if ( ret < 0 ) netif_dbg ( pegasus , drv , pegasus -> net , ""%s<S2SV_blank>returned<S2SV_blank>%d\\\kfree ( buf ) ;return ret ;}",453
607,"buggy line: mod_ty  Module ( asdl_seq * body , PyArena * arena )  {return p ;}cwe id:CWE-125context: mod_ty  Module ( asdl_seq * body , PyArena * arena )  { mod_ty p ; p = ( mod_ty ) PyArena_Malloc ( arena , sizeof ( * p ) ) ; if ( ! p ) return NULL ; p -> kind = Module_kind ; p -> v . Module . body = body ;  return p ;  }","mod_ty Module ( asdl_seq * body , asdl_seq * type_ignores , PyArena * arena ) {p -> v . Module . type_ignores = type_ignores ;return p ;}",454
608,"buggy line: sas_discover_event ( dev -> port , DISCE_DESTRUCT ) ;}cwe id:CWE-000context: void sas_unregister_dev ( struct asd_sas_port * port , struct domain_device * dev ) { if ( ! test_bit ( SAS_DEV_DESTROY , & dev -> state ) && ! list_empty ( & dev -> disco_list_node ) ) { list_del_init ( & dev -> disco_list_node ) ; sas_rphy_free ( dev -> rphy ) ; sas_unregister_common_dev ( port , dev ) ; return ; } if ( ! test_and_set_bit ( SAS_DEV_DESTROY , & dev -> state ) ) { sas_rphy_unlink ( dev -> rphy ) ; list_move_tail ( & dev -> disco_list_node , & port -> destroy_list ) ;  sas_discover_event ( dev -> port , DISCE_DESTRUCT ) ;  } }",},455
609,"buggy line: int vp9_lookahead_push ( struct lookahead_ctx * ctx , YV12_BUFFER_CONFIG * src ,  int64_t ts_start , int64_t ts_end , unsigned int flags ) {struct lookahead_entry * buf ;# endif  if ( ctx -> sz + 1 + MAX_PRE_FRAMES > ctx -> max_sz ) return 1 ;# if USE_PARTIAL_COPY   if ( ctx -> max_sz == 1 && active_map && ! flags ) {for ( row = 0 ;cwe id:CWE-119context: int vp9_lookahead_push ( struct lookahead_ctx * ctx , YV12_BUFFER_CONFIG * src ,  int64_t ts_start , int64_t ts_end , unsigned int flags ) {  struct lookahead_entry * buf ; # if USE_PARTIAL_COPY int row , col , active_end ; int mb_rows = ( src -> y_height + 15 ) >> 4 ; int mb_cols = ( src -> y_width + 15 ) >> 4 ;  # endif  if ( ctx -> sz + 1 + MAX_PRE_FRAMES > ctx -> max_sz ) return 1 ; ctx -> sz ++ ; buf = pop ( ctx , & ctx -> write_idx ) ;  # if USE_PARTIAL_COPY   if ( ctx -> max_sz == 1 && active_map && ! flags ) {  for ( row = 0 ; row < mb_rows ; ++ row ) { col = 0 ; while ( 1 ) { for ( ; col < mb_cols ; ++ col ) { if ( active_map [ col ] ) break ; } if ( col == mb_cols ) break ; active_end = col ; for ( ; active_end < mb_cols ; ++ active_end ) { if ( ! active_map [ active_end ] ) break ; } vp9_copy_and_extend_frame_with_rect ( src , & buf -> img , row << 4 , col << 4 , 16 , ( active_end - col ) << 4 ) ; col = active_end ; } active_map += mb_cols ; } } else {  vp9_copy_and_extend_frame ( src , & buf -> img ) ;   }  # else vp9_copy_and_extend_frame ( src , & buf -> img ) ; # endif buf -> ts_start = ts_start ; buf -> ts_end = ts_end ; buf -> flags = flags ; return 0 ; }","int vp9_lookahead_push ( struct lookahead_ctx * ctx , YV12_BUFFER_CONFIG * src , int64_t ts_start , int64_t ts_end , # if CONFIG_VP9_HIGHBITDEPTH int use_highbitdepth , # endif unsigned int flags ) {struct lookahead_entry * buf ;# endif int width = src -> y_crop_width ;int height = src -> y_crop_height ;int uv_width = src -> uv_crop_width ;int uv_height = src -> uv_crop_height ;int subsampling_x = src -> subsampling_x ;int subsampling_y = src -> subsampling_y ;int larger_dimensions , new_dimensions ;if ( ctx -> sz + 1 + MAX_PRE_FRAMES > ctx -> max_sz ) return 1 ;new_dimensions = width != buf -> img . y_crop_width || height != buf -> img . y_crop_height || uv_width != buf -> img . uv_crop_width || uv_height != buf -> img . uv_crop_height ;larger_dimensions = width > buf -> img . y_width || height > buf -> img . y_height || uv_width > buf -> img . uv_width || uv_height > buf -> img . uv_height ;assert ( ! larger_dimensions || new_dimensions ) ;# if USE_PARTIAL_COPY if ( ! new_dimensions && ctx -> max_sz == 1 && active_map && ! flags ) {for ( row = 0 ;",456
610,"buggy line: vp9_copy_and_extend_frame ( src , & buf -> img ) ;}# else vp9_copy_and_extend_frame ( src , & buf -> img ) ;cwe id:CWE-119context: int vp9_lookahead_push ( struct lookahead_ctx * ctx , YV12_BUFFER_CONFIG * src ,  int64_t ts_start , int64_t ts_end , unsigned int flags ) {  struct lookahead_entry * buf ; # if USE_PARTIAL_COPY int row , col , active_end ; int mb_rows = ( src -> y_height + 15 ) >> 4 ; int mb_cols = ( src -> y_width + 15 ) >> 4 ;  # endif  if ( ctx -> sz + 1 + MAX_PRE_FRAMES > ctx -> max_sz ) return 1 ; ctx -> sz ++ ; buf = pop ( ctx , & ctx -> write_idx ) ;  # if USE_PARTIAL_COPY   if ( ctx -> max_sz == 1 && active_map && ! flags ) {  for ( row = 0 ; row < mb_rows ; ++ row ) { col = 0 ; while ( 1 ) { for ( ; col < mb_cols ; ++ col ) { if ( active_map [ col ] ) break ; } if ( col == mb_cols ) break ; active_end = col ; for ( ; active_end < mb_cols ; ++ active_end ) { if ( ! active_map [ active_end ] ) break ; } vp9_copy_and_extend_frame_with_rect ( src , & buf -> img , row << 4 , col << 4 , 16 , ( active_end - col ) << 4 ) ; col = active_end ; } active_map += mb_cols ; } } else {  vp9_copy_and_extend_frame ( src , & buf -> img ) ;   }  # else vp9_copy_and_extend_frame ( src , & buf -> img ) ; # endif buf -> ts_start = ts_start ; buf -> ts_end = ts_end ; buf -> flags = flags ; return 0 ; }","# endif if ( larger_dimensions ) {YV12_BUFFER_CONFIG new_img ;memset ( & new_img , 0 , sizeof ( new_img ) ) ;if ( vpx_alloc_frame_buffer ( & new_img , width , height , subsampling_x , subsampling_y , # if CONFIG_VP9_HIGHBITDEPTH use_highbitdepth , # endif VP9_ENC_BORDER_IN_PIXELS , 0 ) ) return 1 ;vpx_free_frame_buffer ( & buf -> img ) ;# if USE_PARTIAL_COPY }",456
611,"buggy line: rc = fuse_dev_release ( inode , file ) ;return rc ;cwe id:CWE-399context: static int cuse_channel_release ( struct inode * inode , struct file * file ) { struct fuse_dev * fud = file -> private_data ; struct cuse_conn * cc = fc_to_cc ( fud -> fc ) ; int rc ; mutex_lock ( & cuse_lock ) ; list_del_init ( & cc -> list ) ; mutex_unlock ( & cuse_lock ) ; if ( cc -> dev ) device_unregister ( cc -> dev ) ; if ( cc -> cdev ) { unregister_chrdev_region ( cc -> cdev -> dev , 1 ) ; cdev_del ( cc -> cdev ) ; }  rc = fuse_dev_release ( inode , file ) ;  return rc ; }","fuse_conn_put ( & cc -> fc ) ;rc = fuse_dev_release ( inode , file ) ;return rc ;",457
612,"buggy line: if ( code )  return code ;code = verify_s4u_x509_user_checksum ( context , tgs_subkey ? tgs_subkey : tgs_session , & req_data , request -> nonce , * s4u_x509_user ) ;cwe id:CWE-617context: static krb5_error_code kdc_process_s4u_x509_user ( krb5_context context , krb5_kdc_req * request , krb5_pa_data * pa_data , krb5_keyblock * tgs_subkey , krb5_keyblock * tgs_session , krb5_pa_s4u_x509_user * * s4u_x509_user , const char * * status ) { krb5_error_code code ; krb5_data req_data ; req_data . length = pa_data -> length ; req_data . data = ( char * ) pa_data -> contents ; code = decode_krb5_pa_s4u_x509_user ( & req_data , s4u_x509_user ) ; if ( code )  return code ;  code = verify_s4u_x509_user_checksum ( context , tgs_subkey ? tgs_subkey : tgs_session , & req_data , request -> nonce , * s4u_x509_user ) ; if ( code ) { * status = ""INVALID_S4U2SELF_CHECKSUM"" ; krb5_free_pa_s4u_x509_user ( context , * s4u_x509_user ) ; * s4u_x509_user = NULL ; return code ; } if ( krb5_princ_size ( context , ( * s4u_x509_user ) -> user_id . user ) == 0 || ( * s4u_x509_user ) -> user_id . subject_cert . length != 0 ) { * status = ""INVALID_S4U2SELF_REQUEST"" ; krb5_free_pa_s4u_x509_user ( context , * s4u_x509_user ) ; * s4u_x509_user = NULL ; return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; } return 0 ; }","if ( code ) {* status = ""DECODE_PA_S4U_X509_USER"" ;return code ;}code = verify_s4u_x509_user_checksum ( context , tgs_subkey ? tgs_subkey : tgs_session , & req_data , request -> nonce , * s4u_x509_user ) ;",458
613,"buggy line: static int scsi_disk_emulate_command ( SCSIDiskReq * r , uint8_t * outbuf )  {cwe id:CWE-119context:  static int scsi_disk_emulate_command ( SCSIDiskReq * r , uint8_t * outbuf )  { SCSIRequest * req = & r -> req ; SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , req -> dev ) ; uint64_t nb_sectors ; int buflen = 0 ; switch ( req -> cmd . buf [ 0 ] ) { case TEST_UNIT_READY : if ( s -> tray_open || ! bdrv_is_inserted ( s -> bs ) ) goto not_ready ; break ; case INQUIRY : buflen = scsi_disk_emulate_inquiry ( req , outbuf ) ; if ( buflen < 0 ) goto illegal_request ; break ; case MODE_SENSE : case MODE_SENSE_10 : buflen = scsi_disk_emulate_mode_sense ( r , outbuf ) ; if ( buflen < 0 ) goto illegal_request ; break ; case READ_TOC : buflen = scsi_disk_emulate_read_toc ( req , outbuf ) ; if ( buflen < 0 ) goto illegal_request ; break ; case RESERVE : if ( req -> cmd . buf [ 1 ] & 1 ) goto illegal_request ; break ; case RESERVE_10 : if ( req -> cmd . buf [ 1 ] & 3 ) goto illegal_request ; break ; case RELEASE : if ( req -> cmd . buf [ 1 ] & 1 ) goto illegal_request ; break ; case RELEASE_10 : if ( req -> cmd . buf [ 1 ] & 3 ) goto illegal_request ; break ; case START_STOP : if ( scsi_disk_emulate_start_stop ( r ) < 0 ) { return - 1 ; } break ; case ALLOW_MEDIUM_REMOVAL : s -> tray_locked = req -> cmd . buf [ 4 ] & 1 ; bdrv_lock_medium ( s -> bs , req -> cmd . buf [ 4 ] & 1 ) ; break ; case READ_CAPACITY_10 : memset ( outbuf , 0 , 8 ) ; bdrv_get_geometry ( s -> bs , & nb_sectors ) ; if ( ! nb_sectors ) goto not_ready ; nb_sectors /= s -> cluster_size ; nb_sectors -- ; s -> max_lba = nb_sectors ; if ( nb_sectors > UINT32_MAX ) nb_sectors = UINT32_MAX ; outbuf [ 0 ] = ( nb_sectors >> 24 ) & 0xff ; outbuf [ 1 ] = ( nb_sectors >> 16 ) & 0xff ; outbuf [ 2 ] = ( nb_sectors >> 8 ) & 0xff ; outbuf [ 3 ] = nb_sectors & 0xff ; outbuf [ 4 ] = 0 ; outbuf [ 5 ] = 0 ; outbuf [ 6 ] = s -> cluster_size * 2 ; outbuf [ 7 ] = 0 ; buflen = 8 ; break ; case GET_CONFIGURATION : memset ( outbuf , 0 , 8 ) ; outbuf [ 7 ] = 8 ; buflen = 8 ; break ; case SERVICE_ACTION_IN_16 : if ( ( req -> cmd . buf [ 1 ] & 31 ) == SAI_READ_CAPACITY_16 ) { DPRINTF ( ""SAI<S2SV_blank>READ<S2SV_blank>CAPACITY(16)\\n"" ) ; memset ( outbuf , 0 , req -> cmd . xfer ) ; bdrv_get_geometry ( s -> bs , & nb_sectors ) ; if ( ! nb_sectors ) goto not_ready ; nb_sectors /= s -> cluster_size ; nb_sectors -- ; s -> max_lba = nb_sectors ; outbuf [ 0 ] = ( nb_sectors >> 56 ) & 0xff ; outbuf [ 1 ] = ( nb_sectors >> 48 ) & 0xff ; outbuf [ 2 ] = ( nb_sectors >> 40 ) & 0xff ; outbuf [ 3 ] = ( nb_sectors >> 32 ) & 0xff ; outbuf [ 4 ] = ( nb_sectors >> 24 ) & 0xff ; outbuf [ 5 ] = ( nb_sectors >> 16 ) & 0xff ; outbuf [ 6 ] = ( nb_sectors >> 8 ) & 0xff ; outbuf [ 7 ] = nb_sectors & 0xff ; outbuf [ 8 ] = 0 ; outbuf [ 9 ] = 0 ; outbuf [ 10 ] = s -> cluster_size * 2 ; outbuf [ 11 ] = 0 ; outbuf [ 12 ] = 0 ; outbuf [ 13 ] = get_physical_block_exp ( & s -> qdev . conf ) ; if ( s -> qdev . conf . discard_granularity ) { outbuf [ 14 ] = 0x80 ; } buflen = req -> cmd . xfer ; break ; } DPRINTF ( ""Unsupported<S2SV_blank>Service<S2SV_blank>Action<S2SV_blank>In\\n"" ) ; goto illegal_request ; case VERIFY_10 : break ; default : scsi_check_condition ( r , SENSE_CODE ( INVALID_OPCODE ) ) ; return - 1 ; } return buflen ; not_ready : if ( s -> tray_open || ! bdrv_is_inserted ( s -> bs ) ) { scsi_check_condition ( r , SENSE_CODE ( NO_MEDIUM ) ) ; } else { scsi_check_condition ( r , SENSE_CODE ( LUN_NOT_READY ) ) ; } return - 1 ; illegal_request : if ( r -> req . status == - 1 ) { scsi_check_condition ( r , SENSE_CODE ( INVALID_FIELD ) ) ; } return - 1 ; }","static int scsi_disk_emulate_command ( SCSIDiskReq * r ) {uint8_t * outbuf ;if ( ! r -> iov . iov_base ) {if ( req -> cmd . xfer > 65536 ) {goto illegal_request ;}r -> buflen = MAX ( 4096 , req -> cmd . xfer ) ;r -> iov . iov_base = qemu_blockalign ( s -> bs , r -> buflen ) ;}outbuf = r -> iov . iov_base ;",459
614,buggy line: if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_slice || ! s -> cur_pic . f ||  s -> cur_pic . field_picture ||  s -> avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) return 0 ;cwe id:CWE-617context: static int er_supported ( ERContext * s ) { if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_slice || ! s -> cur_pic . f ||  s -> cur_pic . field_picture ||  s -> avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) return 0 ; return 1 ; },if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_slice || ! s -> cur_pic . f || s -> cur_pic . field_picture ) return 0 ;,460
615,"buggy line: if ( rm -> m_inc . i_hdr . h_flags & RDS_FLAG_CONG_BITMAP ) {rds_cong_map_updated ( conn -> c_fcong , ~ ( u64 ) 0 ) ;return sizeof ( struct rds_header ) + RDS_CONG_MAP_BYTES ;}return sizeof ( struct rds_header ) + be32_to_cpu ( rm -> m_inc . i_hdr . h_len ) ;}cwe id:CWE-000context: static int rds_loop_xmit ( struct rds_connection * conn , struct rds_message * rm , unsigned int hdr_off , unsigned int sg , unsigned int off ) {  if ( rm -> m_inc . i_hdr . h_flags & RDS_FLAG_CONG_BITMAP ) {  rds_cong_map_updated ( conn -> c_fcong , ~ ( u64 ) 0 ) ;  return sizeof ( struct rds_header ) + RDS_CONG_MAP_BYTES ;  } BUG_ON ( hdr_off || sg || off ) ; rds_inc_init ( & rm -> m_inc , conn , conn -> c_laddr ) ; rds_message_addref ( rm ) ; rds_recv_incoming ( conn , conn -> c_laddr , conn -> c_faddr , & rm -> m_inc , GFP_KERNEL , KM_USER0 ) ; rds_send_drop_acked ( conn , be64_to_cpu ( rm -> m_inc . i_hdr . h_sequence ) , NULL ) ; rds_inc_put ( & rm -> m_inc ) ;  return sizeof ( struct rds_header ) + be32_to_cpu ( rm -> m_inc . i_hdr . h_len ) ;  }","struct scatterlist * sgp = & rm -> data . op_sg [ sg ] ;int ret = sizeof ( struct rds_header ) + be32_to_cpu ( rm -> m_inc . i_hdr . h_len ) ;if ( rm -> m_inc . i_hdr . h_flags & RDS_FLAG_CONG_BITMAP ) {rds_cong_map_updated ( conn -> c_fcong , ~ ( u64 ) 0 ) ;ret = min_t ( int , ret , sgp -> length - conn -> c_xmit_data_off ) ;goto out ;}out : return ret ;}",461
616,"buggy line: if ( grub_disk_read ( data -> disk , block << LOG2_EXT2_BLOCK_SIZE ( data ) , 0 , EXT2_BLOCK_SIZE ( data ) , buf ) )  return 0 ;ext_block = ( struct grub_ext4_extent_header * ) buf ;cwe id:CWE-119context: static struct grub_ext4_extent_header * grub_ext4_find_leaf ( struct grub_ext2_data * data , char * buf , struct grub_ext4_extent_header * ext_block , grub_uint32_t fileblock ) { struct grub_ext4_extent_idx * index ; while ( 1 ) { int i ; grub_disk_addr_t block ; index = ( struct grub_ext4_extent_idx * ) ( ext_block + 1 ) ; if ( grub_le_to_cpu16 ( ext_block -> magic ) != EXT4_EXT_MAGIC ) return 0 ; if ( ext_block -> depth == 0 ) return ext_block ; for ( i = 0 ; i < grub_le_to_cpu16 ( ext_block -> entries ) ; i ++ ) { if ( fileblock < grub_le_to_cpu32 ( index [ i ] . block ) ) break ; } if ( -- i < 0 ) return 0 ; block = grub_le_to_cpu16 ( index [ i ] . leaf_hi ) ; block = ( block << 32 ) + grub_le_to_cpu32 ( index [ i ] . leaf ) ; if ( grub_disk_read ( data -> disk , block << LOG2_EXT2_BLOCK_SIZE ( data ) , 0 , EXT2_BLOCK_SIZE ( data ) , buf ) )  return 0 ;  ext_block = ( struct grub_ext4_extent_header * ) buf ; } }","if ( grub_disk_read ( data -> disk , block << LOG2_EXT2_BLOCK_SIZE ( data ) , 0 , EXT2_BLOCK_SIZE ( data ) , buf ) ) {return 0 ;}ext_block = ( struct grub_ext4_extent_header * ) buf ;",462
617,"buggy line: if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) {ret = - ENOKEY ;goto error2 ;}cwe id:CWE-20context: long keyctl_read_key ( key_serial_t keyid , char __user * buffer , size_t buflen ) { struct key * key ; key_ref_t key_ref ; long ret ; key_ref = lookup_user_key ( keyid , 0 , 0 ) ; if ( IS_ERR ( key_ref ) ) { ret = - ENOKEY ; goto error ; } key = key_ref_to_ptr ( key_ref ) ;  if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) {  ret = - ENOKEY ; goto error2 ; } ret = key_permission ( key_ref , KEY_NEED_READ ) ; if ( ret == 0 ) goto can_read_key ; if ( ret != - EACCES ) goto error2 ; if ( ! is_key_possessed ( key_ref ) ) { ret = - EACCES ; goto error2 ; } can_read_key : ret = - EOPNOTSUPP ; if ( key -> type -> read ) { down_read ( & key -> sem ) ; ret = key_validate ( key ) ; if ( ret == 0 ) ret = key -> type -> read ( key , buffer , buflen ) ; up_read ( & key -> sem ) ; } error2 : key_put ( key ) ; error : return ret ; }",ret = key_read_state ( key ) ;if ( ret < 0 ) goto error2 ;,463
618,"buggy line: ND_TCHECK2 ( * mh , hlen + 8 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Init<S2SV_blank>Cookie=%08x:%08x"" , type == IP6M_HOME_TEST_INIT ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ;cwe id:CWE-125context: int mobility_print ( netdissect_options * ndo , const u_char * bp , const u_char * bp2 _U_ ) { const struct ip6_mobility * mh ; const u_char * ep ; unsigned mhlen , hlen ; uint8_t type ; mh = ( const struct ip6_mobility * ) bp ; ep = ndo -> ndo_snapend ; if ( ! ND_TTEST ( mh -> ip6m_len ) ) { mhlen = ep - bp ; goto trunc ; } mhlen = ( mh -> ip6m_len + 1 ) << 3 ; ND_TCHECK ( mh -> ip6m_type ) ; type = mh -> ip6m_type ; if ( type <= IP6M_MAX && mhlen < ip6m_hdrlen [ type ] ) { ND_PRINT ( ( ndo , ""(header<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>for<S2SV_blank>type<S2SV_blank>%u)"" , mhlen , type ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""mobility:<S2SV_blank>%s"" , tok2str ( ip6m_str , ""type-#%u"" , type ) ) ) ; switch ( type ) { case IP6M_BINDING_REQUEST : hlen = IP6M_MINLEN ; break ; case IP6M_HOME_TEST_INIT : case IP6M_CAREOF_TEST_INIT : hlen = IP6M_MINLEN ; if ( ndo -> ndo_vflag ) {  ND_TCHECK2 ( * mh , hlen + 8 ) ;  ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Init<S2SV_blank>Cookie=%08x:%08x"" , type == IP6M_HOME_TEST_INIT ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ; } hlen += 8 ; break ; case IP6M_HOME_TEST : case IP6M_CAREOF_TEST : ND_TCHECK ( mh -> ip6m_data16 [ 0 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>nonce<S2SV_blank>id=0x%x"" , EXTRACT_16BITS ( & mh -> ip6m_data16 [ 0 ] ) ) ) ; hlen = IP6M_MINLEN ; if ( ndo -> ndo_vflag ) {  ND_TCHECK2 ( * mh , hlen + 8 ) ;  ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Init<S2SV_blank>Cookie=%08x:%08x"" , type == IP6M_HOME_TEST ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ; } hlen += 8 ; if ( ndo -> ndo_vflag ) {  ND_TCHECK2 ( * mh , hlen + 8 ) ;  ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Keygen<S2SV_blank>Token=%08x:%08x"" , type == IP6M_HOME_TEST ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ; } hlen += 8 ; break ; case IP6M_BINDING_UPDATE : ND_TCHECK ( mh -> ip6m_data16 [ 0 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>seq#=%u"" , EXTRACT_16BITS ( & mh -> ip6m_data16 [ 0 ] ) ) ) ; hlen = IP6M_MINLEN ;  ND_TCHECK2 ( * mh , hlen + 1 ) ;   if ( bp [ hlen ] & 0xf0 )  ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; if ( bp [ hlen ] & 0x80 ) ND_PRINT ( ( ndo , ""A"" ) ) ; if ( bp [ hlen ] & 0x40 ) ND_PRINT ( ( ndo , ""H"" ) ) ; if ( bp [ hlen ] & 0x20 ) ND_PRINT ( ( ndo , ""L"" ) ) ; if ( bp [ hlen ] & 0x10 )  ND_PRINT ( ( ndo , ""K"" ) ) ;  hlen += 1 ; hlen += 1 ;  ND_TCHECK2 ( * mh , hlen + 2 ) ;  ND_PRINT ( ( ndo , ""<S2SV_blank>lifetime=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) << 2 ) ) ; hlen += 2 ; break ; case IP6M_BINDING_ACK : ND_TCHECK ( mh -> ip6m_data8 [ 0 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>status=%u"" , mh -> ip6m_data8 [ 0 ] ) ) ;  if ( mh -> ip6m_data8 [ 1 ] & 0x80 )  ND_PRINT ( ( ndo , ""<S2SV_blank>K"" ) ) ; hlen = IP6M_MINLEN ;  ND_TCHECK2 ( * mh , hlen + 2 ) ;  ND_PRINT ( ( ndo , ""<S2SV_blank>seq#=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) ) ) ; hlen += 2 ;  ND_TCHECK2 ( * mh , hlen + 2 ) ;  ND_PRINT ( ( ndo , ""<S2SV_blank>lifetime=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) << 2 ) ) ; hlen += 2 ; break ; case IP6M_BINDING_ERROR : ND_TCHECK ( mh -> ip6m_data8 [ 0 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>status=%u"" , mh -> ip6m_data8 [ 0 ] ) ) ; hlen = IP6M_MINLEN ;  ND_TCHECK2 ( * mh , hlen + 16 ) ;  ND_PRINT ( ( ndo , ""<S2SV_blank>homeaddr<S2SV_blank>%s"" , ip6addr_string ( ndo , & bp [ hlen ] ) ) ) ; hlen += 16 ; break ; default : ND_PRINT ( ( ndo , ""<S2SV_blank>len=%u"" , mh -> ip6m_len ) ) ; return ( mhlen ) ; break ; } if ( ndo -> ndo_vflag ) if ( mobility_opt_print ( ndo , & bp [ hlen ] , mhlen - hlen ) ) goto trunc ; return ( mhlen ) ; trunc : ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return ( - 1 ) ; }","ND_TCHECK_32BITS ( & bp [ hlen + 4 ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Init<S2SV_blank>Cookie=%08x:%08x"" , type == IP6M_HOME_TEST_INIT ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ;",464
619,"buggy line: ND_TCHECK2 ( * mh , hlen + 8 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Init<S2SV_blank>Cookie=%08x:%08x"" , type == IP6M_HOME_TEST ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ;ND_TCHECK2 ( * mh , hlen + 8 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Keygen<S2SV_blank>Token=%08x:%08x"" , type == IP6M_HOME_TEST ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ;ND_TCHECK2 ( * mh , hlen + 1 ) ;if ( bp [ hlen ] & 0xf0 )  ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ;if ( bp [ hlen ] & 0x10 )  ND_PRINT ( ( ndo , ""K"" ) ) ;hlen += 1 ;ND_TCHECK2 ( * mh , hlen + 2 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>lifetime=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) << 2 ) ) ;hlen += 2 ;break ;case IP6M_BINDING_ACK : ND_TCHECK ( mh -> ip6m_data8 [ 0 ] ) ;if ( mh -> ip6m_data8 [ 1 ] & 0x80 )  ND_PRINT ( ( ndo , ""<S2SV_blank>K"" ) ) ;ND_TCHECK2 ( * mh , hlen + 2 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>seq#=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) ) ) ;ND_TCHECK2 ( * mh , hlen + 2 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>lifetime=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) << 2 ) ) ;ND_TCHECK2 ( * mh , hlen + 16 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>homeaddr<S2SV_blank>%s"" , ip6addr_string ( ndo , & bp [ hlen ] ) ) ) ;cwe id:CWE-125context: int mobility_print ( netdissect_options * ndo , const u_char * bp , const u_char * bp2 _U_ ) { const struct ip6_mobility * mh ; const u_char * ep ; unsigned mhlen , hlen ; uint8_t type ; mh = ( const struct ip6_mobility * ) bp ; ep = ndo -> ndo_snapend ; if ( ! ND_TTEST ( mh -> ip6m_len ) ) { mhlen = ep - bp ; goto trunc ; } mhlen = ( mh -> ip6m_len + 1 ) << 3 ; ND_TCHECK ( mh -> ip6m_type ) ; type = mh -> ip6m_type ; if ( type <= IP6M_MAX && mhlen < ip6m_hdrlen [ type ] ) { ND_PRINT ( ( ndo , ""(header<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>for<S2SV_blank>type<S2SV_blank>%u)"" , mhlen , type ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""mobility:<S2SV_blank>%s"" , tok2str ( ip6m_str , ""type-#%u"" , type ) ) ) ; switch ( type ) { case IP6M_BINDING_REQUEST : hlen = IP6M_MINLEN ; break ; case IP6M_HOME_TEST_INIT : case IP6M_CAREOF_TEST_INIT : hlen = IP6M_MINLEN ; if ( ndo -> ndo_vflag ) {  ND_TCHECK2 ( * mh , hlen + 8 ) ;  ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Init<S2SV_blank>Cookie=%08x:%08x"" , type == IP6M_HOME_TEST_INIT ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ; } hlen += 8 ; break ; case IP6M_HOME_TEST : case IP6M_CAREOF_TEST : ND_TCHECK ( mh -> ip6m_data16 [ 0 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>nonce<S2SV_blank>id=0x%x"" , EXTRACT_16BITS ( & mh -> ip6m_data16 [ 0 ] ) ) ) ; hlen = IP6M_MINLEN ; if ( ndo -> ndo_vflag ) {  ND_TCHECK2 ( * mh , hlen + 8 ) ;  ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Init<S2SV_blank>Cookie=%08x:%08x"" , type == IP6M_HOME_TEST ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ; } hlen += 8 ; if ( ndo -> ndo_vflag ) {  ND_TCHECK2 ( * mh , hlen + 8 ) ;  ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Keygen<S2SV_blank>Token=%08x:%08x"" , type == IP6M_HOME_TEST ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ; } hlen += 8 ; break ; case IP6M_BINDING_UPDATE : ND_TCHECK ( mh -> ip6m_data16 [ 0 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>seq#=%u"" , EXTRACT_16BITS ( & mh -> ip6m_data16 [ 0 ] ) ) ) ; hlen = IP6M_MINLEN ;  ND_TCHECK2 ( * mh , hlen + 1 ) ;   if ( bp [ hlen ] & 0xf0 )  ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; if ( bp [ hlen ] & 0x80 ) ND_PRINT ( ( ndo , ""A"" ) ) ; if ( bp [ hlen ] & 0x40 ) ND_PRINT ( ( ndo , ""H"" ) ) ; if ( bp [ hlen ] & 0x20 ) ND_PRINT ( ( ndo , ""L"" ) ) ; if ( bp [ hlen ] & 0x10 )  ND_PRINT ( ( ndo , ""K"" ) ) ;  hlen += 1 ; hlen += 1 ;  ND_TCHECK2 ( * mh , hlen + 2 ) ;  ND_PRINT ( ( ndo , ""<S2SV_blank>lifetime=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) << 2 ) ) ; hlen += 2 ; break ; case IP6M_BINDING_ACK : ND_TCHECK ( mh -> ip6m_data8 [ 0 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>status=%u"" , mh -> ip6m_data8 [ 0 ] ) ) ;  if ( mh -> ip6m_data8 [ 1 ] & 0x80 )  ND_PRINT ( ( ndo , ""<S2SV_blank>K"" ) ) ; hlen = IP6M_MINLEN ;  ND_TCHECK2 ( * mh , hlen + 2 ) ;  ND_PRINT ( ( ndo , ""<S2SV_blank>seq#=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) ) ) ; hlen += 2 ;  ND_TCHECK2 ( * mh , hlen + 2 ) ;  ND_PRINT ( ( ndo , ""<S2SV_blank>lifetime=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) << 2 ) ) ; hlen += 2 ; break ; case IP6M_BINDING_ERROR : ND_TCHECK ( mh -> ip6m_data8 [ 0 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>status=%u"" , mh -> ip6m_data8 [ 0 ] ) ) ; hlen = IP6M_MINLEN ;  ND_TCHECK2 ( * mh , hlen + 16 ) ;  ND_PRINT ( ( ndo , ""<S2SV_blank>homeaddr<S2SV_blank>%s"" , ip6addr_string ( ndo , & bp [ hlen ] ) ) ) ; hlen += 16 ; break ; default : ND_PRINT ( ( ndo , ""<S2SV_blank>len=%u"" , mh -> ip6m_len ) ) ; return ( mhlen ) ; break ; } if ( ndo -> ndo_vflag ) if ( mobility_opt_print ( ndo , & bp [ hlen ] , mhlen - hlen ) ) goto trunc ; return ( mhlen ) ; trunc : ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return ( - 1 ) ; }","ND_TCHECK_32BITS ( & bp [ hlen + 4 ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Init<S2SV_blank>Cookie=%08x:%08x"" , type == IP6M_HOME_TEST ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ;ND_TCHECK_32BITS ( & bp [ hlen + 4 ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Keygen<S2SV_blank>Token=%08x:%08x"" , type == IP6M_HOME_TEST ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ;ND_TCHECK_16BITS ( & bp [ hlen ] ) ;if ( bp [ hlen ] & 0xf0 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ;}if ( bp [ hlen ] & 0x10 ) ND_PRINT ( ( ndo , ""K"" ) ) ;ND_TCHECK_16BITS ( & bp [ hlen ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>lifetime=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) << 2 ) ) ;ND_TCHECK ( mh -> ip6m_data8 [ 0 ] ) ;if ( mh -> ip6m_data8 [ 1 ] ) ;if ( mh -> ip6m_data8 [ 1 ] & 0x80 ) ND_PRINT ( ( ndo , ""<S2SV_blank>K"" ) ) ;ND_TCHECK_16BITS ( & bp [ hlen ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>seq#=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) ) ) ;ND_TCHECK_16BITS ( & bp [ hlen ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>lifetime=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) << 2 ) ) ;ND_TCHECK2 ( bp [ hlen ] , 16 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>homeaddr<S2SV_blank>%s"" , ip6addr_string ( ndo , & bp [ hlen ] ) ) ) ;",464
620,buggy line: dev -> netdev_ops = & ieee80211_dataif_ops ;dev -> destructor = free_netdev ;cwe id:CWE-000context: static void ieee80211_if_setup ( struct net_device * dev ) { ether_setup ( dev ) ;  dev -> netdev_ops = & ieee80211_dataif_ops ;  dev -> destructor = free_netdev ; },dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ;dev -> netdev_ops = & ieee80211_dataif_ops ;dev -> destructor = free_netdev ;,465
621,"buggy line: uint16_t hmi_bpm = 0 ;uint16_t hmi_division = 0 ;cwe id:CWE-125context: struct _mdi * _WM_ParseNewHmi ( uint8_t * hmi_data , uint32_t hmi_size ) { uint32_t hmi_tmp = 0 ; uint8_t * hmi_base = hmi_data ;  uint16_t hmi_bpm = 0 ;  uint16_t hmi_division = 0 ; uint32_t hmi_track_cnt = 0 ; uint32_t * hmi_track_offset = NULL ; uint32_t i = 0 ; uint32_t j = 0 ; uint8_t * hmi_addr = NULL ; uint32_t * hmi_track_header_length = NULL ; struct _mdi * hmi_mdi = NULL ; uint32_t tempo_f = 5000000.0 ; uint32_t * hmi_track_end = NULL ; uint8_t hmi_tracks_ended = 0 ; uint8_t * hmi_running_event = NULL ; uint32_t setup_ret = 0 ; uint32_t * hmi_delta = NULL ; uint32_t smallest_delta = 0 ; uint32_t subtract_delta = 0 ; uint32_t sample_count = 0 ; float sample_count_f = 0 ; float sample_remainder = 0 ; float samples_per_delta_f = 0.0 ; struct _note { uint32_t length ; uint8_t channel ;  } * note ;  UNUSED ( hmi_size ) ; if ( memcmp ( hmi_data , ""HMI-MIDISONG061595"" , 18 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , NULL , 0 ) ; return NULL ; } hmi_bpm = hmi_data [ 212 ] ; hmi_division = 60 ; hmi_track_cnt = hmi_data [ 228 ] ; hmi_mdi = _WM_initMDI ( ) ; _WM_midi_setup_divisions ( hmi_mdi , hmi_division ) ; if ( ( _WM_MixerOptions & WM_MO_ROUNDTEMPO ) ) { tempo_f = ( float ) ( 60000000 / hmi_bpm ) + 0.5f ; } else { tempo_f = ( float ) ( 60000000 / hmi_bpm ) ; } samples_per_delta_f = _WM_GetSamplesPerTick ( hmi_division , ( uint32_t ) tempo_f ) ; _WM_midi_setup_tempo ( hmi_mdi , ( uint32_t ) tempo_f ) ; hmi_track_offset = ( uint32_t * ) malloc ( sizeof ( uint32_t ) * hmi_track_cnt ) ; hmi_track_header_length = malloc ( sizeof ( uint32_t ) * hmi_track_cnt ) ; hmi_track_end = malloc ( sizeof ( uint32_t ) * hmi_track_cnt ) ; hmi_delta = malloc ( sizeof ( uint32_t ) * hmi_track_cnt ) ; note = malloc ( sizeof ( struct _note ) * 128 * hmi_track_cnt ) ; hmi_running_event = malloc ( sizeof ( uint8_t ) * 128 * hmi_track_cnt ) ; hmi_data += 370 ; smallest_delta = 0xffffffff ; if ( hmi_size < ( 370 + ( hmi_track_cnt * 17 ) ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ; goto _hmi_end ; } hmi_track_offset [ 0 ] = * hmi_data ; for ( i = 0 ; i < hmi_track_cnt ; i ++ ) { hmi_track_offset [ i ] = * hmi_data ++ ; hmi_track_offset [ i ] += ( * hmi_data ++ << 8 ) ; hmi_track_offset [ i ] += ( * hmi_data ++ << 16 ) ; hmi_track_offset [ i ] += ( * hmi_data ++ << 24 ) ; if ( hmi_size < ( hmi_track_offset [ i ] + 0x5a + 4 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ; goto _hmi_end ; } hmi_addr = hmi_base + hmi_track_offset [ i ] ; if ( memcmp ( hmi_addr , ""HMI-MIDITRACK"" , 13 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , NULL , 0 ) ; goto _hmi_end ; } hmi_track_header_length [ i ] = hmi_addr [ 0x57 ] ; hmi_track_header_length [ i ] += ( hmi_addr [ 0x58 ] << 8 ) ; hmi_track_header_length [ i ] += ( hmi_addr [ 0x59 ] << 16 ) ; hmi_track_header_length [ i ] += ( hmi_addr [ 0x5a ] << 24 ) ; hmi_addr += hmi_track_header_length [ i ] ; hmi_track_offset [ i ] += hmi_track_header_length [ i ] ; hmi_delta [ i ] = 0 ; if ( * hmi_addr > 0x7f ) { do { hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) + ( * hmi_addr & 0x7f ) ; hmi_addr ++ ; hmi_track_offset [ i ] ++ ; } while ( * hmi_addr > 0x7f ) ; } hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) + ( * hmi_addr & 0x7f ) ; hmi_track_offset [ i ] ++ ; hmi_addr ++ ; if ( hmi_delta [ i ] < smallest_delta ) { smallest_delta = hmi_delta [ i ] ; } hmi_track_end [ i ] = 0 ; hmi_running_event [ i ] = 0 ; for ( j = 0 ; j < 128 ; j ++ ) { hmi_tmp = ( 128 * i ) + j ; note [ hmi_tmp ] . length = 0 ; note [ hmi_tmp ] . channel = 0 ; } } subtract_delta = smallest_delta ; sample_count_f = ( ( ( float ) smallest_delta * samples_per_delta_f ) + sample_remainder ) ; sample_count = ( uint32_t ) sample_count_f ; sample_remainder = sample_count_f - ( float ) sample_count ; hmi_mdi -> events [ hmi_mdi -> event_count - 1 ] . samples_to_next += sample_count ; hmi_mdi -> extra_info . approx_total_samples += sample_count ; while ( hmi_tracks_ended < hmi_track_cnt ) { smallest_delta = 0 ; for ( i = 0 ; i < hmi_track_cnt ; i ++ ) { if ( hmi_track_end [ i ] ) continue ; for ( j = 0 ; j < 128 ; j ++ ) { hmi_tmp = ( 128 * i ) + j ; if ( note [ hmi_tmp ] . length ) { note [ hmi_tmp ] . length -= subtract_delta ; if ( note [ hmi_tmp ] . length ) { if ( ( ! smallest_delta ) || ( smallest_delta > note [ hmi_tmp ] . length ) ) { smallest_delta = note [ hmi_tmp ] . length ; } } else { _WM_midi_setup_noteoff ( hmi_mdi , note [ hmi_tmp ] . channel , j , 0 ) ; } } } if ( hmi_delta [ i ] ) { hmi_delta [ i ] -= subtract_delta ; if ( hmi_delta [ i ] ) { if ( ( ! smallest_delta ) || ( smallest_delta > hmi_delta [ i ] ) ) { smallest_delta = hmi_delta [ i ] ; } continue ; } } do { hmi_data = hmi_base + hmi_track_offset [ i ] ; hmi_delta [ i ] = 0 ;  if ( hmi_data [ 0 ] == 0xfe ) {  if ( hmi_data [ 1 ] == 0x10 ) { hmi_tmp = ( hmi_data [ 4 ] + 5 ) ; hmi_data += hmi_tmp ; hmi_track_offset [ i ] += hmi_tmp ;  } else if ( hmi_data [ 1 ] == 0x15 ) {  hmi_data += 4 ; hmi_track_offset [ i ] += 4 ;  }  hmi_data += 4 ; hmi_track_offset [ i ] += 4 ;  } else {   if ( ( setup_ret = _WM_SetupMidiEvent ( hmi_mdi , hmi_data , hmi_running_event [ i ] ) ) == 0 ) {  goto _hmi_end ; } if ( ( hmi_data [ 0 ] == 0xff ) && ( hmi_data [ 1 ] == 0x2f ) && ( hmi_data [ 2 ] == 0x00 ) ) { hmi_track_end [ i ] = 1 ; hmi_tracks_ended ++ ; for ( j = 0 ; j < 128 ; j ++ ) { hmi_tmp = ( 128 * i ) + j ; if ( note [ hmi_tmp ] . length ) { _WM_midi_setup_noteoff ( hmi_mdi , note [ hmi_tmp ] . channel , j , 0 ) ; note [ hmi_tmp ] . length = 0 ; } } goto _hmi_next_track ; } if ( ( * hmi_data == 0xF0 ) || ( * hmi_data == 0xF7 ) ) { hmi_running_event [ i ] = 0 ; } else if ( * hmi_data < 0xF0 ) { if ( * hmi_data >= 0x80 ) { hmi_running_event [ i ] = * hmi_data ; } } if ( ( hmi_running_event [ i ] & 0xf0 ) == 0x90 ) { if ( * hmi_data > 127 ) { hmi_tmp = hmi_data [ 1 ] ; } else { hmi_tmp = * hmi_data ; } hmi_tmp += ( i * 128 ) ; note [ hmi_tmp ] . channel = hmi_running_event [ i ] & 0xf ; hmi_data += setup_ret ; hmi_track_offset [ i ] += setup_ret ;  note [ hmi_tmp ] . length = 0 ;   if ( * hmi_data > 0x7f ) {   do {  note [ hmi_tmp ] . length = ( note [ hmi_tmp ] . length << 7 ) | ( * hmi_data & 0x7F ) ; hmi_data ++ ;  hmi_track_offset [ i ] ++ ;   } while ( * hmi_data > 0x7F ) ;  } note [ hmi_tmp ] . length = ( note [ hmi_tmp ] . length << 7 ) | ( * hmi_data & 0x7F ) ; hmi_data ++ ;  hmi_track_offset [ i ] ++ ;  if ( note [ hmi_tmp ] . length ) { if ( ( ! smallest_delta ) || ( smallest_delta > note [ hmi_tmp ] . length ) ) { smallest_delta = note [ hmi_tmp ] . length ; } } else { _WM_midi_setup_noteoff ( hmi_mdi , note [ hmi_tmp ] . channel , j , 0 ) ; } } else { hmi_data += setup_ret ; hmi_track_offset [ i ] += setup_ret ;  }  } if ( * hmi_data > 0x7f ) { do {  hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) | ( * hmi_data & 0x7F ) ;  hmi_data ++ ;  hmi_track_offset [ i ] ++ ;  } while ( * hmi_data > 0x7F ) ; }  hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) | ( * hmi_data & 0x7F ) ;   hmi_data ++ ;  hmi_track_offset [ i ] ++ ; } while ( ! hmi_delta [ i ] ) ; if ( ( ! smallest_delta ) || ( smallest_delta > hmi_delta [ i ] ) ) { smallest_delta = hmi_delta [ i ] ; } _hmi_next_track : hmi_tmp = 0 ; UNUSED ( hmi_tmp ) ; } subtract_delta = smallest_delta ; sample_count_f = ( ( ( float ) smallest_delta * samples_per_delta_f ) + sample_remainder ) ; sample_count = ( uint32_t ) sample_count_f ; sample_remainder = sample_count_f - ( float ) sample_count ; hmi_mdi -> events [ hmi_mdi -> event_count - 1 ] . samples_to_next += sample_count ; hmi_mdi -> extra_info . approx_total_samples += sample_count ; } if ( ( hmi_mdi -> reverb = _WM_init_reverb ( _WM_SampleRate , _WM_reverb_room_width , _WM_reverb_room_length , _WM_reverb_listen_posx , _WM_reverb_listen_posy ) ) == NULL ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_MEM , ""to<S2SV_blank>init<S2SV_blank>reverb"" , 0 ) ; goto _hmi_end ; } hmi_mdi -> extra_info . current_sample = 0 ; hmi_mdi -> current_event = & hmi_mdi -> events [ 0 ] ; hmi_mdi -> samples_to_mix = 0 ; hmi_mdi -> note = NULL ; _WM_ResetToStart ( hmi_mdi ) ; _hmi_end : free ( hmi_track_offset ) ; free ( hmi_track_header_length ) ; free ( hmi_track_end ) ; free ( hmi_delta ) ; free ( note ) ; free ( hmi_running_event ) ; if ( hmi_mdi -> reverb ) return ( hmi_mdi ) ; _WM_freeMDI ( hmi_mdi ) ; return 0 ; }",uint32_t data_siz ;uint16_t hmi_bpm = 0 ;uint16_t hmi_division = 0 ;,466
622,"buggy line: }UNUSED ( hmi_size ) ;cwe id:CWE-125context: struct _mdi * _WM_ParseNewHmi ( uint8_t * hmi_data , uint32_t hmi_size ) { uint32_t hmi_tmp = 0 ; uint8_t * hmi_base = hmi_data ;  uint16_t hmi_bpm = 0 ;  uint16_t hmi_division = 0 ; uint32_t hmi_track_cnt = 0 ; uint32_t * hmi_track_offset = NULL ; uint32_t i = 0 ; uint32_t j = 0 ; uint8_t * hmi_addr = NULL ; uint32_t * hmi_track_header_length = NULL ; struct _mdi * hmi_mdi = NULL ; uint32_t tempo_f = 5000000.0 ; uint32_t * hmi_track_end = NULL ; uint8_t hmi_tracks_ended = 0 ; uint8_t * hmi_running_event = NULL ; uint32_t setup_ret = 0 ; uint32_t * hmi_delta = NULL ; uint32_t smallest_delta = 0 ; uint32_t subtract_delta = 0 ; uint32_t sample_count = 0 ; float sample_count_f = 0 ; float sample_remainder = 0 ; float samples_per_delta_f = 0.0 ; struct _note { uint32_t length ; uint8_t channel ;  } * note ;  UNUSED ( hmi_size ) ; if ( memcmp ( hmi_data , ""HMI-MIDISONG061595"" , 18 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , NULL , 0 ) ; return NULL ; } hmi_bpm = hmi_data [ 212 ] ; hmi_division = 60 ; hmi_track_cnt = hmi_data [ 228 ] ; hmi_mdi = _WM_initMDI ( ) ; _WM_midi_setup_divisions ( hmi_mdi , hmi_division ) ; if ( ( _WM_MixerOptions & WM_MO_ROUNDTEMPO ) ) { tempo_f = ( float ) ( 60000000 / hmi_bpm ) + 0.5f ; } else { tempo_f = ( float ) ( 60000000 / hmi_bpm ) ; } samples_per_delta_f = _WM_GetSamplesPerTick ( hmi_division , ( uint32_t ) tempo_f ) ; _WM_midi_setup_tempo ( hmi_mdi , ( uint32_t ) tempo_f ) ; hmi_track_offset = ( uint32_t * ) malloc ( sizeof ( uint32_t ) * hmi_track_cnt ) ; hmi_track_header_length = malloc ( sizeof ( uint32_t ) * hmi_track_cnt ) ; hmi_track_end = malloc ( sizeof ( uint32_t ) * hmi_track_cnt ) ; hmi_delta = malloc ( sizeof ( uint32_t ) * hmi_track_cnt ) ; note = malloc ( sizeof ( struct _note ) * 128 * hmi_track_cnt ) ; hmi_running_event = malloc ( sizeof ( uint8_t ) * 128 * hmi_track_cnt ) ; hmi_data += 370 ; smallest_delta = 0xffffffff ; if ( hmi_size < ( 370 + ( hmi_track_cnt * 17 ) ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ; goto _hmi_end ; } hmi_track_offset [ 0 ] = * hmi_data ; for ( i = 0 ; i < hmi_track_cnt ; i ++ ) { hmi_track_offset [ i ] = * hmi_data ++ ; hmi_track_offset [ i ] += ( * hmi_data ++ << 8 ) ; hmi_track_offset [ i ] += ( * hmi_data ++ << 16 ) ; hmi_track_offset [ i ] += ( * hmi_data ++ << 24 ) ; if ( hmi_size < ( hmi_track_offset [ i ] + 0x5a + 4 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ; goto _hmi_end ; } hmi_addr = hmi_base + hmi_track_offset [ i ] ; if ( memcmp ( hmi_addr , ""HMI-MIDITRACK"" , 13 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , NULL , 0 ) ; goto _hmi_end ; } hmi_track_header_length [ i ] = hmi_addr [ 0x57 ] ; hmi_track_header_length [ i ] += ( hmi_addr [ 0x58 ] << 8 ) ; hmi_track_header_length [ i ] += ( hmi_addr [ 0x59 ] << 16 ) ; hmi_track_header_length [ i ] += ( hmi_addr [ 0x5a ] << 24 ) ; hmi_addr += hmi_track_header_length [ i ] ; hmi_track_offset [ i ] += hmi_track_header_length [ i ] ; hmi_delta [ i ] = 0 ; if ( * hmi_addr > 0x7f ) { do { hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) + ( * hmi_addr & 0x7f ) ; hmi_addr ++ ; hmi_track_offset [ i ] ++ ; } while ( * hmi_addr > 0x7f ) ; } hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) + ( * hmi_addr & 0x7f ) ; hmi_track_offset [ i ] ++ ; hmi_addr ++ ; if ( hmi_delta [ i ] < smallest_delta ) { smallest_delta = hmi_delta [ i ] ; } hmi_track_end [ i ] = 0 ; hmi_running_event [ i ] = 0 ; for ( j = 0 ; j < 128 ; j ++ ) { hmi_tmp = ( 128 * i ) + j ; note [ hmi_tmp ] . length = 0 ; note [ hmi_tmp ] . channel = 0 ; } } subtract_delta = smallest_delta ; sample_count_f = ( ( ( float ) smallest_delta * samples_per_delta_f ) + sample_remainder ) ; sample_count = ( uint32_t ) sample_count_f ; sample_remainder = sample_count_f - ( float ) sample_count ; hmi_mdi -> events [ hmi_mdi -> event_count - 1 ] . samples_to_next += sample_count ; hmi_mdi -> extra_info . approx_total_samples += sample_count ; while ( hmi_tracks_ended < hmi_track_cnt ) { smallest_delta = 0 ; for ( i = 0 ; i < hmi_track_cnt ; i ++ ) { if ( hmi_track_end [ i ] ) continue ; for ( j = 0 ; j < 128 ; j ++ ) { hmi_tmp = ( 128 * i ) + j ; if ( note [ hmi_tmp ] . length ) { note [ hmi_tmp ] . length -= subtract_delta ; if ( note [ hmi_tmp ] . length ) { if ( ( ! smallest_delta ) || ( smallest_delta > note [ hmi_tmp ] . length ) ) { smallest_delta = note [ hmi_tmp ] . length ; } } else { _WM_midi_setup_noteoff ( hmi_mdi , note [ hmi_tmp ] . channel , j , 0 ) ; } } } if ( hmi_delta [ i ] ) { hmi_delta [ i ] -= subtract_delta ; if ( hmi_delta [ i ] ) { if ( ( ! smallest_delta ) || ( smallest_delta > hmi_delta [ i ] ) ) { smallest_delta = hmi_delta [ i ] ; } continue ; } } do { hmi_data = hmi_base + hmi_track_offset [ i ] ; hmi_delta [ i ] = 0 ;  if ( hmi_data [ 0 ] == 0xfe ) {  if ( hmi_data [ 1 ] == 0x10 ) { hmi_tmp = ( hmi_data [ 4 ] + 5 ) ; hmi_data += hmi_tmp ; hmi_track_offset [ i ] += hmi_tmp ;  } else if ( hmi_data [ 1 ] == 0x15 ) {  hmi_data += 4 ; hmi_track_offset [ i ] += 4 ;  }  hmi_data += 4 ; hmi_track_offset [ i ] += 4 ;  } else {   if ( ( setup_ret = _WM_SetupMidiEvent ( hmi_mdi , hmi_data , hmi_running_event [ i ] ) ) == 0 ) {  goto _hmi_end ; } if ( ( hmi_data [ 0 ] == 0xff ) && ( hmi_data [ 1 ] == 0x2f ) && ( hmi_data [ 2 ] == 0x00 ) ) { hmi_track_end [ i ] = 1 ; hmi_tracks_ended ++ ; for ( j = 0 ; j < 128 ; j ++ ) { hmi_tmp = ( 128 * i ) + j ; if ( note [ hmi_tmp ] . length ) { _WM_midi_setup_noteoff ( hmi_mdi , note [ hmi_tmp ] . channel , j , 0 ) ; note [ hmi_tmp ] . length = 0 ; } } goto _hmi_next_track ; } if ( ( * hmi_data == 0xF0 ) || ( * hmi_data == 0xF7 ) ) { hmi_running_event [ i ] = 0 ; } else if ( * hmi_data < 0xF0 ) { if ( * hmi_data >= 0x80 ) { hmi_running_event [ i ] = * hmi_data ; } } if ( ( hmi_running_event [ i ] & 0xf0 ) == 0x90 ) { if ( * hmi_data > 127 ) { hmi_tmp = hmi_data [ 1 ] ; } else { hmi_tmp = * hmi_data ; } hmi_tmp += ( i * 128 ) ; note [ hmi_tmp ] . channel = hmi_running_event [ i ] & 0xf ; hmi_data += setup_ret ; hmi_track_offset [ i ] += setup_ret ;  note [ hmi_tmp ] . length = 0 ;   if ( * hmi_data > 0x7f ) {   do {  note [ hmi_tmp ] . length = ( note [ hmi_tmp ] . length << 7 ) | ( * hmi_data & 0x7F ) ; hmi_data ++ ;  hmi_track_offset [ i ] ++ ;   } while ( * hmi_data > 0x7F ) ;  } note [ hmi_tmp ] . length = ( note [ hmi_tmp ] . length << 7 ) | ( * hmi_data & 0x7F ) ; hmi_data ++ ;  hmi_track_offset [ i ] ++ ;  if ( note [ hmi_tmp ] . length ) { if ( ( ! smallest_delta ) || ( smallest_delta > note [ hmi_tmp ] . length ) ) { smallest_delta = note [ hmi_tmp ] . length ; } } else { _WM_midi_setup_noteoff ( hmi_mdi , note [ hmi_tmp ] . channel , j , 0 ) ; } } else { hmi_data += setup_ret ; hmi_track_offset [ i ] += setup_ret ;  }  } if ( * hmi_data > 0x7f ) { do {  hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) | ( * hmi_data & 0x7F ) ;  hmi_data ++ ;  hmi_track_offset [ i ] ++ ;  } while ( * hmi_data > 0x7F ) ; }  hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) | ( * hmi_data & 0x7F ) ;   hmi_data ++ ;  hmi_track_offset [ i ] ++ ; } while ( ! hmi_delta [ i ] ) ; if ( ( ! smallest_delta ) || ( smallest_delta > hmi_delta [ i ] ) ) { smallest_delta = hmi_delta [ i ] ; } _hmi_next_track : hmi_tmp = 0 ; UNUSED ( hmi_tmp ) ; } subtract_delta = smallest_delta ; sample_count_f = ( ( ( float ) smallest_delta * samples_per_delta_f ) + sample_remainder ) ; sample_count = ( uint32_t ) sample_count_f ; sample_remainder = sample_count_f - ( float ) sample_count ; hmi_mdi -> events [ hmi_mdi -> event_count - 1 ] . samples_to_next += sample_count ; hmi_mdi -> extra_info . approx_total_samples += sample_count ; } if ( ( hmi_mdi -> reverb = _WM_init_reverb ( _WM_SampleRate , _WM_reverb_room_width , _WM_reverb_room_length , _WM_reverb_listen_posx , _WM_reverb_listen_posy ) ) == NULL ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_MEM , ""to<S2SV_blank>init<S2SV_blank>reverb"" , 0 ) ; goto _hmi_end ; } hmi_mdi -> extra_info . current_sample = 0 ; hmi_mdi -> current_event = & hmi_mdi -> events [ 0 ] ; hmi_mdi -> samples_to_mix = 0 ; hmi_mdi -> note = NULL ; _WM_ResetToStart ( hmi_mdi ) ; _hmi_end : free ( hmi_track_offset ) ; free ( hmi_track_header_length ) ; free ( hmi_track_end ) ; free ( hmi_delta ) ; free ( note ) ; free ( hmi_running_event ) ; if ( hmi_mdi -> reverb ) return ( hmi_mdi ) ; _WM_freeMDI ( hmi_mdi ) ; return 0 ; }","}if ( hmi_track_offset [ i ] >= hmi_size ) {_WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ;goto _hmi_end ;}data_siz = hmi_size - hmi_track_offset [ i ] ;",466
623,"buggy line: if ( hmi_data [ 0 ] == 0xfe ) {if ( hmi_data [ 1 ] == 0x10 ) {hmi_track_offset [ i ] += hmi_tmp ;}else if ( hmi_data [ 1 ] == 0x15 ) {hmi_data += 4 ;}hmi_data += 4 ;}if ( ( setup_ret = _WM_SetupMidiEvent ( hmi_mdi , hmi_data , hmi_running_event [ i ] ) ) == 0 ) {goto _hmi_end ;cwe id:CWE-125context: struct _mdi * _WM_ParseNewHmi ( uint8_t * hmi_data , uint32_t hmi_size ) { uint32_t hmi_tmp = 0 ; uint8_t * hmi_base = hmi_data ;  uint16_t hmi_bpm = 0 ;  uint16_t hmi_division = 0 ; uint32_t hmi_track_cnt = 0 ; uint32_t * hmi_track_offset = NULL ; uint32_t i = 0 ; uint32_t j = 0 ; uint8_t * hmi_addr = NULL ; uint32_t * hmi_track_header_length = NULL ; struct _mdi * hmi_mdi = NULL ; uint32_t tempo_f = 5000000.0 ; uint32_t * hmi_track_end = NULL ; uint8_t hmi_tracks_ended = 0 ; uint8_t * hmi_running_event = NULL ; uint32_t setup_ret = 0 ; uint32_t * hmi_delta = NULL ; uint32_t smallest_delta = 0 ; uint32_t subtract_delta = 0 ; uint32_t sample_count = 0 ; float sample_count_f = 0 ; float sample_remainder = 0 ; float samples_per_delta_f = 0.0 ; struct _note { uint32_t length ; uint8_t channel ;  } * note ;  UNUSED ( hmi_size ) ; if ( memcmp ( hmi_data , ""HMI-MIDISONG061595"" , 18 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , NULL , 0 ) ; return NULL ; } hmi_bpm = hmi_data [ 212 ] ; hmi_division = 60 ; hmi_track_cnt = hmi_data [ 228 ] ; hmi_mdi = _WM_initMDI ( ) ; _WM_midi_setup_divisions ( hmi_mdi , hmi_division ) ; if ( ( _WM_MixerOptions & WM_MO_ROUNDTEMPO ) ) { tempo_f = ( float ) ( 60000000 / hmi_bpm ) + 0.5f ; } else { tempo_f = ( float ) ( 60000000 / hmi_bpm ) ; } samples_per_delta_f = _WM_GetSamplesPerTick ( hmi_division , ( uint32_t ) tempo_f ) ; _WM_midi_setup_tempo ( hmi_mdi , ( uint32_t ) tempo_f ) ; hmi_track_offset = ( uint32_t * ) malloc ( sizeof ( uint32_t ) * hmi_track_cnt ) ; hmi_track_header_length = malloc ( sizeof ( uint32_t ) * hmi_track_cnt ) ; hmi_track_end = malloc ( sizeof ( uint32_t ) * hmi_track_cnt ) ; hmi_delta = malloc ( sizeof ( uint32_t ) * hmi_track_cnt ) ; note = malloc ( sizeof ( struct _note ) * 128 * hmi_track_cnt ) ; hmi_running_event = malloc ( sizeof ( uint8_t ) * 128 * hmi_track_cnt ) ; hmi_data += 370 ; smallest_delta = 0xffffffff ; if ( hmi_size < ( 370 + ( hmi_track_cnt * 17 ) ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ; goto _hmi_end ; } hmi_track_offset [ 0 ] = * hmi_data ; for ( i = 0 ; i < hmi_track_cnt ; i ++ ) { hmi_track_offset [ i ] = * hmi_data ++ ; hmi_track_offset [ i ] += ( * hmi_data ++ << 8 ) ; hmi_track_offset [ i ] += ( * hmi_data ++ << 16 ) ; hmi_track_offset [ i ] += ( * hmi_data ++ << 24 ) ; if ( hmi_size < ( hmi_track_offset [ i ] + 0x5a + 4 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ; goto _hmi_end ; } hmi_addr = hmi_base + hmi_track_offset [ i ] ; if ( memcmp ( hmi_addr , ""HMI-MIDITRACK"" , 13 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , NULL , 0 ) ; goto _hmi_end ; } hmi_track_header_length [ i ] = hmi_addr [ 0x57 ] ; hmi_track_header_length [ i ] += ( hmi_addr [ 0x58 ] << 8 ) ; hmi_track_header_length [ i ] += ( hmi_addr [ 0x59 ] << 16 ) ; hmi_track_header_length [ i ] += ( hmi_addr [ 0x5a ] << 24 ) ; hmi_addr += hmi_track_header_length [ i ] ; hmi_track_offset [ i ] += hmi_track_header_length [ i ] ; hmi_delta [ i ] = 0 ; if ( * hmi_addr > 0x7f ) { do { hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) + ( * hmi_addr & 0x7f ) ; hmi_addr ++ ; hmi_track_offset [ i ] ++ ; } while ( * hmi_addr > 0x7f ) ; } hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) + ( * hmi_addr & 0x7f ) ; hmi_track_offset [ i ] ++ ; hmi_addr ++ ; if ( hmi_delta [ i ] < smallest_delta ) { smallest_delta = hmi_delta [ i ] ; } hmi_track_end [ i ] = 0 ; hmi_running_event [ i ] = 0 ; for ( j = 0 ; j < 128 ; j ++ ) { hmi_tmp = ( 128 * i ) + j ; note [ hmi_tmp ] . length = 0 ; note [ hmi_tmp ] . channel = 0 ; } } subtract_delta = smallest_delta ; sample_count_f = ( ( ( float ) smallest_delta * samples_per_delta_f ) + sample_remainder ) ; sample_count = ( uint32_t ) sample_count_f ; sample_remainder = sample_count_f - ( float ) sample_count ; hmi_mdi -> events [ hmi_mdi -> event_count - 1 ] . samples_to_next += sample_count ; hmi_mdi -> extra_info . approx_total_samples += sample_count ; while ( hmi_tracks_ended < hmi_track_cnt ) { smallest_delta = 0 ; for ( i = 0 ; i < hmi_track_cnt ; i ++ ) { if ( hmi_track_end [ i ] ) continue ; for ( j = 0 ; j < 128 ; j ++ ) { hmi_tmp = ( 128 * i ) + j ; if ( note [ hmi_tmp ] . length ) { note [ hmi_tmp ] . length -= subtract_delta ; if ( note [ hmi_tmp ] . length ) { if ( ( ! smallest_delta ) || ( smallest_delta > note [ hmi_tmp ] . length ) ) { smallest_delta = note [ hmi_tmp ] . length ; } } else { _WM_midi_setup_noteoff ( hmi_mdi , note [ hmi_tmp ] . channel , j , 0 ) ; } } } if ( hmi_delta [ i ] ) { hmi_delta [ i ] -= subtract_delta ; if ( hmi_delta [ i ] ) { if ( ( ! smallest_delta ) || ( smallest_delta > hmi_delta [ i ] ) ) { smallest_delta = hmi_delta [ i ] ; } continue ; } } do { hmi_data = hmi_base + hmi_track_offset [ i ] ; hmi_delta [ i ] = 0 ;  if ( hmi_data [ 0 ] == 0xfe ) {  if ( hmi_data [ 1 ] == 0x10 ) { hmi_tmp = ( hmi_data [ 4 ] + 5 ) ; hmi_data += hmi_tmp ; hmi_track_offset [ i ] += hmi_tmp ;  } else if ( hmi_data [ 1 ] == 0x15 ) {  hmi_data += 4 ; hmi_track_offset [ i ] += 4 ;  }  hmi_data += 4 ; hmi_track_offset [ i ] += 4 ;  } else {   if ( ( setup_ret = _WM_SetupMidiEvent ( hmi_mdi , hmi_data , hmi_running_event [ i ] ) ) == 0 ) {  goto _hmi_end ; } if ( ( hmi_data [ 0 ] == 0xff ) && ( hmi_data [ 1 ] == 0x2f ) && ( hmi_data [ 2 ] == 0x00 ) ) { hmi_track_end [ i ] = 1 ; hmi_tracks_ended ++ ; for ( j = 0 ; j < 128 ; j ++ ) { hmi_tmp = ( 128 * i ) + j ; if ( note [ hmi_tmp ] . length ) { _WM_midi_setup_noteoff ( hmi_mdi , note [ hmi_tmp ] . channel , j , 0 ) ; note [ hmi_tmp ] . length = 0 ; } } goto _hmi_next_track ; } if ( ( * hmi_data == 0xF0 ) || ( * hmi_data == 0xF7 ) ) { hmi_running_event [ i ] = 0 ; } else if ( * hmi_data < 0xF0 ) { if ( * hmi_data >= 0x80 ) { hmi_running_event [ i ] = * hmi_data ; } } if ( ( hmi_running_event [ i ] & 0xf0 ) == 0x90 ) { if ( * hmi_data > 127 ) { hmi_tmp = hmi_data [ 1 ] ; } else { hmi_tmp = * hmi_data ; } hmi_tmp += ( i * 128 ) ; note [ hmi_tmp ] . channel = hmi_running_event [ i ] & 0xf ; hmi_data += setup_ret ; hmi_track_offset [ i ] += setup_ret ;  note [ hmi_tmp ] . length = 0 ;   if ( * hmi_data > 0x7f ) {   do {  note [ hmi_tmp ] . length = ( note [ hmi_tmp ] . length << 7 ) | ( * hmi_data & 0x7F ) ; hmi_data ++ ;  hmi_track_offset [ i ] ++ ;   } while ( * hmi_data > 0x7F ) ;  } note [ hmi_tmp ] . length = ( note [ hmi_tmp ] . length << 7 ) | ( * hmi_data & 0x7F ) ; hmi_data ++ ;  hmi_track_offset [ i ] ++ ;  if ( note [ hmi_tmp ] . length ) { if ( ( ! smallest_delta ) || ( smallest_delta > note [ hmi_tmp ] . length ) ) { smallest_delta = note [ hmi_tmp ] . length ; } } else { _WM_midi_setup_noteoff ( hmi_mdi , note [ hmi_tmp ] . channel , j , 0 ) ; } } else { hmi_data += setup_ret ; hmi_track_offset [ i ] += setup_ret ;  }  } if ( * hmi_data > 0x7f ) { do {  hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) | ( * hmi_data & 0x7F ) ;  hmi_data ++ ;  hmi_track_offset [ i ] ++ ;  } while ( * hmi_data > 0x7F ) ; }  hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) | ( * hmi_data & 0x7F ) ;   hmi_data ++ ;  hmi_track_offset [ i ] ++ ; } while ( ! hmi_delta [ i ] ) ; if ( ( ! smallest_delta ) || ( smallest_delta > hmi_delta [ i ] ) ) { smallest_delta = hmi_delta [ i ] ; } _hmi_next_track : hmi_tmp = 0 ; UNUSED ( hmi_tmp ) ; } subtract_delta = smallest_delta ; sample_count_f = ( ( ( float ) smallest_delta * samples_per_delta_f ) + sample_remainder ) ; sample_count = ( uint32_t ) sample_count_f ; sample_remainder = sample_count_f - ( float ) sample_count ; hmi_mdi -> events [ hmi_mdi -> event_count - 1 ] . samples_to_next += sample_count ; hmi_mdi -> extra_info . approx_total_samples += sample_count ; } if ( ( hmi_mdi -> reverb = _WM_init_reverb ( _WM_SampleRate , _WM_reverb_room_width , _WM_reverb_room_length , _WM_reverb_listen_posx , _WM_reverb_listen_posy ) ) == NULL ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_MEM , ""to<S2SV_blank>init<S2SV_blank>reverb"" , 0 ) ; goto _hmi_end ; } hmi_mdi -> extra_info . current_sample = 0 ; hmi_mdi -> current_event = & hmi_mdi -> events [ 0 ] ; hmi_mdi -> samples_to_mix = 0 ; hmi_mdi -> note = NULL ; _WM_ResetToStart ( hmi_mdi ) ; _hmi_end : free ( hmi_track_offset ) ; free ( hmi_track_header_length ) ; free ( hmi_track_end ) ; free ( hmi_delta ) ; free ( note ) ; free ( hmi_running_event ) ; if ( hmi_mdi -> reverb ) return ( hmi_mdi ) ; _WM_freeMDI ( hmi_mdi ) ; return 0 ; }","if ( hmi_data [ 0 ] == 0xfe ) {if ( hmi_data [ 1 ] == 0x10 ) {hmi_tmp += 4 ;hmi_tmp = 8 ;}else {hmi_tmp = 4 ;}hmi_data += 4 ;if ( hmi_tmp > data_siz ) {_WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ;goto _hmi_end ;}data_siz -= hmi_tmp ;}hmi_data += 4 ;hmi_track_offset [ i ] += 4 ;}if ( ( setup_ret = _WM_SetupMidiEvent ( hmi_mdi , hmi_data , data_siz , hmi_running_event [ i ] ) ) == 0 ) {goto _hmi_end ;",466
624,"buggy line: hmi_track_offset [ i ] += setup_ret ;note [ hmi_tmp ] . length = 0 ;if ( * hmi_data > 0x7f ) {do {note [ hmi_tmp ] . length = ( note [ hmi_tmp ] . length << 7 ) | ( * hmi_data & 0x7F ) ;hmi_track_offset [ i ] ++ ;}}hmi_track_offset [ i ] ++ ;if ( note [ hmi_tmp ] . length ) {cwe id:CWE-125context: struct _mdi * _WM_ParseNewHmi ( uint8_t * hmi_data , uint32_t hmi_size ) { uint32_t hmi_tmp = 0 ; uint8_t * hmi_base = hmi_data ;  uint16_t hmi_bpm = 0 ;  uint16_t hmi_division = 0 ; uint32_t hmi_track_cnt = 0 ; uint32_t * hmi_track_offset = NULL ; uint32_t i = 0 ; uint32_t j = 0 ; uint8_t * hmi_addr = NULL ; uint32_t * hmi_track_header_length = NULL ; struct _mdi * hmi_mdi = NULL ; uint32_t tempo_f = 5000000.0 ; uint32_t * hmi_track_end = NULL ; uint8_t hmi_tracks_ended = 0 ; uint8_t * hmi_running_event = NULL ; uint32_t setup_ret = 0 ; uint32_t * hmi_delta = NULL ; uint32_t smallest_delta = 0 ; uint32_t subtract_delta = 0 ; uint32_t sample_count = 0 ; float sample_count_f = 0 ; float sample_remainder = 0 ; float samples_per_delta_f = 0.0 ; struct _note { uint32_t length ; uint8_t channel ;  } * note ;  UNUSED ( hmi_size ) ; if ( memcmp ( hmi_data , ""HMI-MIDISONG061595"" , 18 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , NULL , 0 ) ; return NULL ; } hmi_bpm = hmi_data [ 212 ] ; hmi_division = 60 ; hmi_track_cnt = hmi_data [ 228 ] ; hmi_mdi = _WM_initMDI ( ) ; _WM_midi_setup_divisions ( hmi_mdi , hmi_division ) ; if ( ( _WM_MixerOptions & WM_MO_ROUNDTEMPO ) ) { tempo_f = ( float ) ( 60000000 / hmi_bpm ) + 0.5f ; } else { tempo_f = ( float ) ( 60000000 / hmi_bpm ) ; } samples_per_delta_f = _WM_GetSamplesPerTick ( hmi_division , ( uint32_t ) tempo_f ) ; _WM_midi_setup_tempo ( hmi_mdi , ( uint32_t ) tempo_f ) ; hmi_track_offset = ( uint32_t * ) malloc ( sizeof ( uint32_t ) * hmi_track_cnt ) ; hmi_track_header_length = malloc ( sizeof ( uint32_t ) * hmi_track_cnt ) ; hmi_track_end = malloc ( sizeof ( uint32_t ) * hmi_track_cnt ) ; hmi_delta = malloc ( sizeof ( uint32_t ) * hmi_track_cnt ) ; note = malloc ( sizeof ( struct _note ) * 128 * hmi_track_cnt ) ; hmi_running_event = malloc ( sizeof ( uint8_t ) * 128 * hmi_track_cnt ) ; hmi_data += 370 ; smallest_delta = 0xffffffff ; if ( hmi_size < ( 370 + ( hmi_track_cnt * 17 ) ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ; goto _hmi_end ; } hmi_track_offset [ 0 ] = * hmi_data ; for ( i = 0 ; i < hmi_track_cnt ; i ++ ) { hmi_track_offset [ i ] = * hmi_data ++ ; hmi_track_offset [ i ] += ( * hmi_data ++ << 8 ) ; hmi_track_offset [ i ] += ( * hmi_data ++ << 16 ) ; hmi_track_offset [ i ] += ( * hmi_data ++ << 24 ) ; if ( hmi_size < ( hmi_track_offset [ i ] + 0x5a + 4 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ; goto _hmi_end ; } hmi_addr = hmi_base + hmi_track_offset [ i ] ; if ( memcmp ( hmi_addr , ""HMI-MIDITRACK"" , 13 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , NULL , 0 ) ; goto _hmi_end ; } hmi_track_header_length [ i ] = hmi_addr [ 0x57 ] ; hmi_track_header_length [ i ] += ( hmi_addr [ 0x58 ] << 8 ) ; hmi_track_header_length [ i ] += ( hmi_addr [ 0x59 ] << 16 ) ; hmi_track_header_length [ i ] += ( hmi_addr [ 0x5a ] << 24 ) ; hmi_addr += hmi_track_header_length [ i ] ; hmi_track_offset [ i ] += hmi_track_header_length [ i ] ; hmi_delta [ i ] = 0 ; if ( * hmi_addr > 0x7f ) { do { hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) + ( * hmi_addr & 0x7f ) ; hmi_addr ++ ; hmi_track_offset [ i ] ++ ; } while ( * hmi_addr > 0x7f ) ; } hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) + ( * hmi_addr & 0x7f ) ; hmi_track_offset [ i ] ++ ; hmi_addr ++ ; if ( hmi_delta [ i ] < smallest_delta ) { smallest_delta = hmi_delta [ i ] ; } hmi_track_end [ i ] = 0 ; hmi_running_event [ i ] = 0 ; for ( j = 0 ; j < 128 ; j ++ ) { hmi_tmp = ( 128 * i ) + j ; note [ hmi_tmp ] . length = 0 ; note [ hmi_tmp ] . channel = 0 ; } } subtract_delta = smallest_delta ; sample_count_f = ( ( ( float ) smallest_delta * samples_per_delta_f ) + sample_remainder ) ; sample_count = ( uint32_t ) sample_count_f ; sample_remainder = sample_count_f - ( float ) sample_count ; hmi_mdi -> events [ hmi_mdi -> event_count - 1 ] . samples_to_next += sample_count ; hmi_mdi -> extra_info . approx_total_samples += sample_count ; while ( hmi_tracks_ended < hmi_track_cnt ) { smallest_delta = 0 ; for ( i = 0 ; i < hmi_track_cnt ; i ++ ) { if ( hmi_track_end [ i ] ) continue ; for ( j = 0 ; j < 128 ; j ++ ) { hmi_tmp = ( 128 * i ) + j ; if ( note [ hmi_tmp ] . length ) { note [ hmi_tmp ] . length -= subtract_delta ; if ( note [ hmi_tmp ] . length ) { if ( ( ! smallest_delta ) || ( smallest_delta > note [ hmi_tmp ] . length ) ) { smallest_delta = note [ hmi_tmp ] . length ; } } else { _WM_midi_setup_noteoff ( hmi_mdi , note [ hmi_tmp ] . channel , j , 0 ) ; } } } if ( hmi_delta [ i ] ) { hmi_delta [ i ] -= subtract_delta ; if ( hmi_delta [ i ] ) { if ( ( ! smallest_delta ) || ( smallest_delta > hmi_delta [ i ] ) ) { smallest_delta = hmi_delta [ i ] ; } continue ; } } do { hmi_data = hmi_base + hmi_track_offset [ i ] ; hmi_delta [ i ] = 0 ;  if ( hmi_data [ 0 ] == 0xfe ) {  if ( hmi_data [ 1 ] == 0x10 ) { hmi_tmp = ( hmi_data [ 4 ] + 5 ) ; hmi_data += hmi_tmp ; hmi_track_offset [ i ] += hmi_tmp ;  } else if ( hmi_data [ 1 ] == 0x15 ) {  hmi_data += 4 ; hmi_track_offset [ i ] += 4 ;  }  hmi_data += 4 ; hmi_track_offset [ i ] += 4 ;  } else {   if ( ( setup_ret = _WM_SetupMidiEvent ( hmi_mdi , hmi_data , hmi_running_event [ i ] ) ) == 0 ) {  goto _hmi_end ; } if ( ( hmi_data [ 0 ] == 0xff ) && ( hmi_data [ 1 ] == 0x2f ) && ( hmi_data [ 2 ] == 0x00 ) ) { hmi_track_end [ i ] = 1 ; hmi_tracks_ended ++ ; for ( j = 0 ; j < 128 ; j ++ ) { hmi_tmp = ( 128 * i ) + j ; if ( note [ hmi_tmp ] . length ) { _WM_midi_setup_noteoff ( hmi_mdi , note [ hmi_tmp ] . channel , j , 0 ) ; note [ hmi_tmp ] . length = 0 ; } } goto _hmi_next_track ; } if ( ( * hmi_data == 0xF0 ) || ( * hmi_data == 0xF7 ) ) { hmi_running_event [ i ] = 0 ; } else if ( * hmi_data < 0xF0 ) { if ( * hmi_data >= 0x80 ) { hmi_running_event [ i ] = * hmi_data ; } } if ( ( hmi_running_event [ i ] & 0xf0 ) == 0x90 ) { if ( * hmi_data > 127 ) { hmi_tmp = hmi_data [ 1 ] ; } else { hmi_tmp = * hmi_data ; } hmi_tmp += ( i * 128 ) ; note [ hmi_tmp ] . channel = hmi_running_event [ i ] & 0xf ; hmi_data += setup_ret ; hmi_track_offset [ i ] += setup_ret ;  note [ hmi_tmp ] . length = 0 ;   if ( * hmi_data > 0x7f ) {   do {  note [ hmi_tmp ] . length = ( note [ hmi_tmp ] . length << 7 ) | ( * hmi_data & 0x7F ) ; hmi_data ++ ;  hmi_track_offset [ i ] ++ ;   } while ( * hmi_data > 0x7F ) ;  } note [ hmi_tmp ] . length = ( note [ hmi_tmp ] . length << 7 ) | ( * hmi_data & 0x7F ) ; hmi_data ++ ;  hmi_track_offset [ i ] ++ ;  if ( note [ hmi_tmp ] . length ) { if ( ( ! smallest_delta ) || ( smallest_delta > note [ hmi_tmp ] . length ) ) { smallest_delta = note [ hmi_tmp ] . length ; } } else { _WM_midi_setup_noteoff ( hmi_mdi , note [ hmi_tmp ] . channel , j , 0 ) ; } } else { hmi_data += setup_ret ; hmi_track_offset [ i ] += setup_ret ;  }  } if ( * hmi_data > 0x7f ) { do {  hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) | ( * hmi_data & 0x7F ) ;  hmi_data ++ ;  hmi_track_offset [ i ] ++ ;  } while ( * hmi_data > 0x7F ) ; }  hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) | ( * hmi_data & 0x7F ) ;   hmi_data ++ ;  hmi_track_offset [ i ] ++ ; } while ( ! hmi_delta [ i ] ) ; if ( ( ! smallest_delta ) || ( smallest_delta > hmi_delta [ i ] ) ) { smallest_delta = hmi_delta [ i ] ; } _hmi_next_track : hmi_tmp = 0 ; UNUSED ( hmi_tmp ) ; } subtract_delta = smallest_delta ; sample_count_f = ( ( ( float ) smallest_delta * samples_per_delta_f ) + sample_remainder ) ; sample_count = ( uint32_t ) sample_count_f ; sample_remainder = sample_count_f - ( float ) sample_count ; hmi_mdi -> events [ hmi_mdi -> event_count - 1 ] . samples_to_next += sample_count ; hmi_mdi -> extra_info . approx_total_samples += sample_count ; } if ( ( hmi_mdi -> reverb = _WM_init_reverb ( _WM_SampleRate , _WM_reverb_room_width , _WM_reverb_room_length , _WM_reverb_listen_posx , _WM_reverb_listen_posy ) ) == NULL ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_MEM , ""to<S2SV_blank>init<S2SV_blank>reverb"" , 0 ) ; goto _hmi_end ; } hmi_mdi -> extra_info . current_sample = 0 ; hmi_mdi -> current_event = & hmi_mdi -> events [ 0 ] ; hmi_mdi -> samples_to_mix = 0 ; hmi_mdi -> note = NULL ; _WM_ResetToStart ( hmi_mdi ) ; _hmi_end : free ( hmi_track_offset ) ; free ( hmi_track_header_length ) ; free ( hmi_track_end ) ; free ( hmi_delta ) ; free ( note ) ; free ( hmi_running_event ) ; if ( hmi_mdi -> reverb ) return ( hmi_mdi ) ; _WM_freeMDI ( hmi_mdi ) ; return 0 ; }","data_siz -= setup_ret ;}}if ( data_siz && * hmi_data > 0x7f ) {do {if ( ! data_siz ) break ;if ( ! data_siz ) break ;note [ hmi_tmp ] . length = ( note [ hmi_tmp ] . length << 7 ) | ( * hmi_data & 0x7F ) ;data_siz -- ;data_siz -- ;hmi_track_offset [ i ] ++ ;}}if ( ! data_siz ) {_WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ;goto _hmi_end ;}if ( ! data_siz ) {_WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ;goto _hmi_end ;}data_siz -- ;data_siz -- ;hmi_track_offset [ i ] ++ ;if ( note [ hmi_tmp ] . length ) {",466
625,"buggy line: }}hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) | ( * hmi_data & 0x7F ) ;hmi_data ++ ;hmi_track_offset [ i ] ++ ;}hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) | ( * hmi_data & 0x7F ) ;hmi_data ++ ;hmi_track_offset [ i ] ++ ;cwe id:CWE-125context: struct _mdi * _WM_ParseNewHmi ( uint8_t * hmi_data , uint32_t hmi_size ) { uint32_t hmi_tmp = 0 ; uint8_t * hmi_base = hmi_data ;  uint16_t hmi_bpm = 0 ;  uint16_t hmi_division = 0 ; uint32_t hmi_track_cnt = 0 ; uint32_t * hmi_track_offset = NULL ; uint32_t i = 0 ; uint32_t j = 0 ; uint8_t * hmi_addr = NULL ; uint32_t * hmi_track_header_length = NULL ; struct _mdi * hmi_mdi = NULL ; uint32_t tempo_f = 5000000.0 ; uint32_t * hmi_track_end = NULL ; uint8_t hmi_tracks_ended = 0 ; uint8_t * hmi_running_event = NULL ; uint32_t setup_ret = 0 ; uint32_t * hmi_delta = NULL ; uint32_t smallest_delta = 0 ; uint32_t subtract_delta = 0 ; uint32_t sample_count = 0 ; float sample_count_f = 0 ; float sample_remainder = 0 ; float samples_per_delta_f = 0.0 ; struct _note { uint32_t length ; uint8_t channel ;  } * note ;  UNUSED ( hmi_size ) ; if ( memcmp ( hmi_data , ""HMI-MIDISONG061595"" , 18 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , NULL , 0 ) ; return NULL ; } hmi_bpm = hmi_data [ 212 ] ; hmi_division = 60 ; hmi_track_cnt = hmi_data [ 228 ] ; hmi_mdi = _WM_initMDI ( ) ; _WM_midi_setup_divisions ( hmi_mdi , hmi_division ) ; if ( ( _WM_MixerOptions & WM_MO_ROUNDTEMPO ) ) { tempo_f = ( float ) ( 60000000 / hmi_bpm ) + 0.5f ; } else { tempo_f = ( float ) ( 60000000 / hmi_bpm ) ; } samples_per_delta_f = _WM_GetSamplesPerTick ( hmi_division , ( uint32_t ) tempo_f ) ; _WM_midi_setup_tempo ( hmi_mdi , ( uint32_t ) tempo_f ) ; hmi_track_offset = ( uint32_t * ) malloc ( sizeof ( uint32_t ) * hmi_track_cnt ) ; hmi_track_header_length = malloc ( sizeof ( uint32_t ) * hmi_track_cnt ) ; hmi_track_end = malloc ( sizeof ( uint32_t ) * hmi_track_cnt ) ; hmi_delta = malloc ( sizeof ( uint32_t ) * hmi_track_cnt ) ; note = malloc ( sizeof ( struct _note ) * 128 * hmi_track_cnt ) ; hmi_running_event = malloc ( sizeof ( uint8_t ) * 128 * hmi_track_cnt ) ; hmi_data += 370 ; smallest_delta = 0xffffffff ; if ( hmi_size < ( 370 + ( hmi_track_cnt * 17 ) ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ; goto _hmi_end ; } hmi_track_offset [ 0 ] = * hmi_data ; for ( i = 0 ; i < hmi_track_cnt ; i ++ ) { hmi_track_offset [ i ] = * hmi_data ++ ; hmi_track_offset [ i ] += ( * hmi_data ++ << 8 ) ; hmi_track_offset [ i ] += ( * hmi_data ++ << 16 ) ; hmi_track_offset [ i ] += ( * hmi_data ++ << 24 ) ; if ( hmi_size < ( hmi_track_offset [ i ] + 0x5a + 4 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ; goto _hmi_end ; } hmi_addr = hmi_base + hmi_track_offset [ i ] ; if ( memcmp ( hmi_addr , ""HMI-MIDITRACK"" , 13 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , NULL , 0 ) ; goto _hmi_end ; } hmi_track_header_length [ i ] = hmi_addr [ 0x57 ] ; hmi_track_header_length [ i ] += ( hmi_addr [ 0x58 ] << 8 ) ; hmi_track_header_length [ i ] += ( hmi_addr [ 0x59 ] << 16 ) ; hmi_track_header_length [ i ] += ( hmi_addr [ 0x5a ] << 24 ) ; hmi_addr += hmi_track_header_length [ i ] ; hmi_track_offset [ i ] += hmi_track_header_length [ i ] ; hmi_delta [ i ] = 0 ; if ( * hmi_addr > 0x7f ) { do { hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) + ( * hmi_addr & 0x7f ) ; hmi_addr ++ ; hmi_track_offset [ i ] ++ ; } while ( * hmi_addr > 0x7f ) ; } hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) + ( * hmi_addr & 0x7f ) ; hmi_track_offset [ i ] ++ ; hmi_addr ++ ; if ( hmi_delta [ i ] < smallest_delta ) { smallest_delta = hmi_delta [ i ] ; } hmi_track_end [ i ] = 0 ; hmi_running_event [ i ] = 0 ; for ( j = 0 ; j < 128 ; j ++ ) { hmi_tmp = ( 128 * i ) + j ; note [ hmi_tmp ] . length = 0 ; note [ hmi_tmp ] . channel = 0 ; } } subtract_delta = smallest_delta ; sample_count_f = ( ( ( float ) smallest_delta * samples_per_delta_f ) + sample_remainder ) ; sample_count = ( uint32_t ) sample_count_f ; sample_remainder = sample_count_f - ( float ) sample_count ; hmi_mdi -> events [ hmi_mdi -> event_count - 1 ] . samples_to_next += sample_count ; hmi_mdi -> extra_info . approx_total_samples += sample_count ; while ( hmi_tracks_ended < hmi_track_cnt ) { smallest_delta = 0 ; for ( i = 0 ; i < hmi_track_cnt ; i ++ ) { if ( hmi_track_end [ i ] ) continue ; for ( j = 0 ; j < 128 ; j ++ ) { hmi_tmp = ( 128 * i ) + j ; if ( note [ hmi_tmp ] . length ) { note [ hmi_tmp ] . length -= subtract_delta ; if ( note [ hmi_tmp ] . length ) { if ( ( ! smallest_delta ) || ( smallest_delta > note [ hmi_tmp ] . length ) ) { smallest_delta = note [ hmi_tmp ] . length ; } } else { _WM_midi_setup_noteoff ( hmi_mdi , note [ hmi_tmp ] . channel , j , 0 ) ; } } } if ( hmi_delta [ i ] ) { hmi_delta [ i ] -= subtract_delta ; if ( hmi_delta [ i ] ) { if ( ( ! smallest_delta ) || ( smallest_delta > hmi_delta [ i ] ) ) { smallest_delta = hmi_delta [ i ] ; } continue ; } } do { hmi_data = hmi_base + hmi_track_offset [ i ] ; hmi_delta [ i ] = 0 ;  if ( hmi_data [ 0 ] == 0xfe ) {  if ( hmi_data [ 1 ] == 0x10 ) { hmi_tmp = ( hmi_data [ 4 ] + 5 ) ; hmi_data += hmi_tmp ; hmi_track_offset [ i ] += hmi_tmp ;  } else if ( hmi_data [ 1 ] == 0x15 ) {  hmi_data += 4 ; hmi_track_offset [ i ] += 4 ;  }  hmi_data += 4 ; hmi_track_offset [ i ] += 4 ;  } else {   if ( ( setup_ret = _WM_SetupMidiEvent ( hmi_mdi , hmi_data , hmi_running_event [ i ] ) ) == 0 ) {  goto _hmi_end ; } if ( ( hmi_data [ 0 ] == 0xff ) && ( hmi_data [ 1 ] == 0x2f ) && ( hmi_data [ 2 ] == 0x00 ) ) { hmi_track_end [ i ] = 1 ; hmi_tracks_ended ++ ; for ( j = 0 ; j < 128 ; j ++ ) { hmi_tmp = ( 128 * i ) + j ; if ( note [ hmi_tmp ] . length ) { _WM_midi_setup_noteoff ( hmi_mdi , note [ hmi_tmp ] . channel , j , 0 ) ; note [ hmi_tmp ] . length = 0 ; } } goto _hmi_next_track ; } if ( ( * hmi_data == 0xF0 ) || ( * hmi_data == 0xF7 ) ) { hmi_running_event [ i ] = 0 ; } else if ( * hmi_data < 0xF0 ) { if ( * hmi_data >= 0x80 ) { hmi_running_event [ i ] = * hmi_data ; } } if ( ( hmi_running_event [ i ] & 0xf0 ) == 0x90 ) { if ( * hmi_data > 127 ) { hmi_tmp = hmi_data [ 1 ] ; } else { hmi_tmp = * hmi_data ; } hmi_tmp += ( i * 128 ) ; note [ hmi_tmp ] . channel = hmi_running_event [ i ] & 0xf ; hmi_data += setup_ret ; hmi_track_offset [ i ] += setup_ret ;  note [ hmi_tmp ] . length = 0 ;   if ( * hmi_data > 0x7f ) {   do {  note [ hmi_tmp ] . length = ( note [ hmi_tmp ] . length << 7 ) | ( * hmi_data & 0x7F ) ; hmi_data ++ ;  hmi_track_offset [ i ] ++ ;   } while ( * hmi_data > 0x7F ) ;  } note [ hmi_tmp ] . length = ( note [ hmi_tmp ] . length << 7 ) | ( * hmi_data & 0x7F ) ; hmi_data ++ ;  hmi_track_offset [ i ] ++ ;  if ( note [ hmi_tmp ] . length ) { if ( ( ! smallest_delta ) || ( smallest_delta > note [ hmi_tmp ] . length ) ) { smallest_delta = note [ hmi_tmp ] . length ; } } else { _WM_midi_setup_noteoff ( hmi_mdi , note [ hmi_tmp ] . channel , j , 0 ) ; } } else { hmi_data += setup_ret ; hmi_track_offset [ i ] += setup_ret ;  }  } if ( * hmi_data > 0x7f ) { do {  hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) | ( * hmi_data & 0x7F ) ;  hmi_data ++ ;  hmi_track_offset [ i ] ++ ;  } while ( * hmi_data > 0x7F ) ; }  hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) | ( * hmi_data & 0x7F ) ;   hmi_data ++ ;  hmi_track_offset [ i ] ++ ; } while ( ! hmi_delta [ i ] ) ; if ( ( ! smallest_delta ) || ( smallest_delta > hmi_delta [ i ] ) ) { smallest_delta = hmi_delta [ i ] ; } _hmi_next_track : hmi_tmp = 0 ; UNUSED ( hmi_tmp ) ; } subtract_delta = smallest_delta ; sample_count_f = ( ( ( float ) smallest_delta * samples_per_delta_f ) + sample_remainder ) ; sample_count = ( uint32_t ) sample_count_f ; sample_remainder = sample_count_f - ( float ) sample_count ; hmi_mdi -> events [ hmi_mdi -> event_count - 1 ] . samples_to_next += sample_count ; hmi_mdi -> extra_info . approx_total_samples += sample_count ; } if ( ( hmi_mdi -> reverb = _WM_init_reverb ( _WM_SampleRate , _WM_reverb_room_width , _WM_reverb_room_length , _WM_reverb_listen_posx , _WM_reverb_listen_posy ) ) == NULL ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_MEM , ""to<S2SV_blank>init<S2SV_blank>reverb"" , 0 ) ; goto _hmi_end ; } hmi_mdi -> extra_info . current_sample = 0 ; hmi_mdi -> current_event = & hmi_mdi -> events [ 0 ] ; hmi_mdi -> samples_to_mix = 0 ; hmi_mdi -> note = NULL ; _WM_ResetToStart ( hmi_mdi ) ; _hmi_end : free ( hmi_track_offset ) ; free ( hmi_track_header_length ) ; free ( hmi_track_end ) ; free ( hmi_delta ) ; free ( note ) ; free ( hmi_running_event ) ; if ( hmi_mdi -> reverb ) return ( hmi_mdi ) ; _WM_freeMDI ( hmi_mdi ) ; return 0 ; }",}}hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) | ( * hmi_data & 0x7F ) ;hmi_data ++ ;hmi_track_offset [ i ] ++ ;}hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) | ( * hmi_data & 0x7F ) ;hmi_data ++ ;hmi_track_offset [ i ] ++ ;,466
626,"buggy line: release_sock ( sk ) ;return 0 ;cwe id:CWE-200context: static int hci_sock_getname ( struct socket * sock , struct sockaddr * addr , int * addr_len , int peer ) { struct sockaddr_hci * haddr = ( struct sockaddr_hci * ) addr ; struct sock * sk = sock -> sk ; struct hci_dev * hdev = hci_pi ( sk ) -> hdev ; BT_DBG ( ""sock<S2SV_blank>%p<S2SV_blank>sk<S2SV_blank>%p"" , sock , sk ) ; if ( ! hdev ) return - EBADFD ; lock_sock ( sk ) ; * addr_len = sizeof ( * haddr ) ; haddr -> hci_family = AF_BLUETOOTH ; haddr -> hci_dev = hdev -> id ;  release_sock ( sk ) ;  return 0 ; }",haddr -> hci_channel = 0 ;release_sock ( sk ) ;return 0 ;,467
627,"buggy line: fh32 [ 2 ] = inode -> i_generation ;if ( parent ) {cwe id:CWE-200context: static int isofs_export_encode_fh ( struct inode * inode , __u32 * fh32 , int * max_len , struct inode * parent ) { struct iso_inode_info * ei = ISOFS_I ( inode ) ; int len = * max_len ; int type = 1 ; __u16 * fh16 = ( __u16 * ) fh32 ; if ( parent && ( len < 5 ) ) { * max_len = 5 ; return 255 ; } else if ( len < 3 ) { * max_len = 3 ; return 255 ; } len = 3 ; fh32 [ 0 ] = ei -> i_iget5_block ; fh16 [ 2 ] = ( __u16 ) ei -> i_iget5_offset ;  fh32 [ 2 ] = inode -> i_generation ;  if ( parent ) { struct iso_inode_info * eparent ; eparent = ISOFS_I ( parent ) ; fh32 [ 3 ] = eparent -> i_iget5_block ; fh16 [ 3 ] = ( __u16 ) eparent -> i_iget5_offset ; fh32 [ 4 ] = parent -> i_generation ; len = 5 ; type = 2 ; } * max_len = len ; return type ; }",fh16 [ 3 ] = 0 ;fh32 [ 2 ] = inode -> i_generation ;if ( parent ) {,468
628,"buggy line: if ( check_anon ( kdc_active_realm , request -> client , request -> server ) != 0 ) {* status = ""ANONYMOUS<S2SV_blank>NOT<S2SV_blank>ALLOWED"" ;cwe id:CWE-476context: int validate_as_request ( kdc_realm_t * kdc_active_realm , register krb5_kdc_req * request , krb5_db_entry client , krb5_db_entry server , krb5_timestamp kdc_time , const char * * status , krb5_pa_data * * * e_data ) { int errcode ; krb5_error_code ret ; if ( request -> kdc_options & AS_INVALID_OPTIONS ) { * status = ""INVALID<S2SV_blank>AS<S2SV_blank>OPTIONS"" ; return KDC_ERR_BADOPTION ; } if ( client . expiration && client . expiration < kdc_time ) { * status = ""CLIENT<S2SV_blank>EXPIRED"" ; if ( vague_errors ) return ( KRB_ERR_GENERIC ) ; else return ( KDC_ERR_NAME_EXP ) ; } if ( client . pw_expiration && client . pw_expiration < kdc_time && ! isflagset ( server . attributes , KRB5_KDB_PWCHANGE_SERVICE ) ) { * status = ""CLIENT<S2SV_blank>KEY<S2SV_blank>EXPIRED"" ; if ( vague_errors ) return ( KRB_ERR_GENERIC ) ; else return ( KDC_ERR_KEY_EXP ) ; } if ( server . expiration && server . expiration < kdc_time ) { * status = ""SERVICE<S2SV_blank>EXPIRED"" ; return ( KDC_ERR_SERVICE_EXP ) ; } if ( isflagset ( client . attributes , KRB5_KDB_REQUIRES_PWCHANGE ) && ! isflagset ( server . attributes , KRB5_KDB_PWCHANGE_SERVICE ) ) { * status = ""REQUIRED<S2SV_blank>PWCHANGE"" ; return ( KDC_ERR_KEY_EXP ) ; } if ( ( isflagset ( request -> kdc_options , KDC_OPT_ALLOW_POSTDATE ) || isflagset ( request -> kdc_options , KDC_OPT_POSTDATED ) ) && ( isflagset ( client . attributes , KRB5_KDB_DISALLOW_POSTDATED ) || isflagset ( server . attributes , KRB5_KDB_DISALLOW_POSTDATED ) ) ) { * status = ""POSTDATE<S2SV_blank>NOT<S2SV_blank>ALLOWED"" ; return ( KDC_ERR_CANNOT_POSTDATE ) ; } if ( isflagset ( request -> kdc_options , KDC_OPT_PROXIABLE ) && ( isflagset ( client . attributes , KRB5_KDB_DISALLOW_PROXIABLE ) || isflagset ( server . attributes , KRB5_KDB_DISALLOW_PROXIABLE ) ) ) { * status = ""PROXIABLE<S2SV_blank>NOT<S2SV_blank>ALLOWED"" ; return ( KDC_ERR_POLICY ) ; } if ( isflagset ( client . attributes , KRB5_KDB_DISALLOW_ALL_TIX ) ) { * status = ""CLIENT<S2SV_blank>LOCKED<S2SV_blank>OUT"" ; return ( KDC_ERR_CLIENT_REVOKED ) ; } if ( isflagset ( server . attributes , KRB5_KDB_DISALLOW_ALL_TIX ) ) { * status = ""SERVICE<S2SV_blank>LOCKED<S2SV_blank>OUT"" ; return ( KDC_ERR_S_PRINCIPAL_UNKNOWN ) ; } if ( isflagset ( server . attributes , KRB5_KDB_DISALLOW_SVR ) ) { * status = ""SERVICE<S2SV_blank>NOT<S2SV_blank>ALLOWED"" ; return ( KDC_ERR_MUST_USE_USER2USER ) ; }  if ( check_anon ( kdc_active_realm , request -> client , request -> server ) != 0 ) {  * status = ""ANONYMOUS<S2SV_blank>NOT<S2SV_blank>ALLOWED"" ; return ( KDC_ERR_POLICY ) ; } ret = krb5_db_check_policy_as ( kdc_context , request , & client , & server , kdc_time , status , e_data ) ; if ( ret && ret != KRB5_PLUGIN_OP_NOTSUPP ) return errcode_to_protocol ( ret ) ; errcode = against_local_policy_as ( request , client , server , kdc_time , status , e_data ) ; if ( errcode ) return errcode ; return 0 ; }","if ( check_anon ( kdc_active_realm , client . princ , request -> server ) != 0 ) {* status = ""ANONYMOUS<S2SV_blank>NOT<S2SV_blank>ALLOWED"" ;",469
629,"buggy line: if ( umax_val > U32_MAX || dst_reg -> umax_value > U32_MAX ) {__mark_reg_unbounded ( dst_reg ) ;__update_reg_bounds ( dst_reg ) ;break ;}dst_reg -> umin_value *= umin_val ;dst_reg -> umax_value *= umax_val ;if ( dst_reg -> umax_value > S64_MAX ) {cwe id:CWE-119context: static int adjust_scalar_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , struct bpf_reg_state * dst_reg , struct bpf_reg_state src_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; bool src_known , dst_known ; s64 smin_val , smax_val ; u64 umin_val , umax_val ; if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { coerce_reg_to_32 ( dst_reg ) ; coerce_reg_to_32 ( & src_reg ) ; } smin_val = src_reg . smin_value ; smax_val = src_reg . smax_value ; umin_val = src_reg . umin_value ; umax_val = src_reg . umax_value ; src_known = tnum_is_const ( src_reg . var_off ) ; dst_known = tnum_is_const ( dst_reg -> var_off ) ; switch ( opcode ) { case BPF_ADD : if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value += smin_val ; dst_reg -> smax_value += smax_val ; } if ( dst_reg -> umin_value + umin_val < umin_val || dst_reg -> umax_value + umax_val < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value += umin_val ; dst_reg -> umax_value += umax_val ; } dst_reg -> var_off = tnum_add ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_SUB : if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value -= smax_val ; dst_reg -> smax_value -= smin_val ; } if ( dst_reg -> umin_value < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value -= umax_val ; dst_reg -> umax_value -= umin_val ; } dst_reg -> var_off = tnum_sub ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_MUL : dst_reg -> var_off = tnum_mul ( dst_reg -> var_off , src_reg . var_off ) ; if ( smin_val < 0 || dst_reg -> smin_value < 0 ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } if ( umax_val > U32_MAX || dst_reg -> umax_value > U32_MAX ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } dst_reg -> umin_value *= umin_val ; dst_reg -> umax_value *= umax_val ; if ( dst_reg -> umax_value > S64_MAX ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } break ; case BPF_AND : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value & src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_and ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = dst_reg -> var_off . value ; dst_reg -> umax_value = min ( dst_reg -> umax_value , umax_val ) ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_OR : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value | src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_or ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = max ( dst_reg -> umin_value , umin_val ) ; dst_reg -> umax_value = dst_reg -> var_off . value | dst_reg -> var_off . mask ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_LSH : if ( umax_val > 63 ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( dst_reg -> umax_value > 1ULL << ( 63 - umax_val ) ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value <<= umin_val ; dst_reg -> umax_value <<= umax_val ; } if ( src_known ) dst_reg -> var_off = tnum_lshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_lshift ( tnum_unknown , umin_val ) ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_RSH : if ( umax_val > 63 ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; }  if ( dst_reg -> smin_value < 0 ) {  if ( umin_val ) { dst_reg -> smin_value = 0 ; } else { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ;  }  } else { dst_reg -> smin_value = ( u64 ) ( dst_reg -> smin_value ) >> umax_val ; } if ( src_known ) dst_reg -> var_off = tnum_rshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_rshift ( tnum_unknown , umin_val ) ; dst_reg -> umin_value >>= umax_val ; dst_reg -> umax_value >>= umin_val ; __update_reg_bounds ( dst_reg ) ; break ; default : mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } __reg_deduce_bounds ( dst_reg ) ; __reg_bound_offset ( dst_reg ) ; return 0 ; }","
",470
630,"buggy line: }else {dst_reg -> smin_value = dst_reg -> umin_value ;dst_reg -> smax_value = dst_reg -> umax_value ;}__update_reg_bounds ( dst_reg ) ;break ;case BPF_OR : if ( src_known && dst_known ) {cwe id:CWE-119context: static int adjust_scalar_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , struct bpf_reg_state * dst_reg , struct bpf_reg_state src_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; bool src_known , dst_known ; s64 smin_val , smax_val ; u64 umin_val , umax_val ; if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { coerce_reg_to_32 ( dst_reg ) ; coerce_reg_to_32 ( & src_reg ) ; } smin_val = src_reg . smin_value ; smax_val = src_reg . smax_value ; umin_val = src_reg . umin_value ; umax_val = src_reg . umax_value ; src_known = tnum_is_const ( src_reg . var_off ) ; dst_known = tnum_is_const ( dst_reg -> var_off ) ; switch ( opcode ) { case BPF_ADD : if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value += smin_val ; dst_reg -> smax_value += smax_val ; } if ( dst_reg -> umin_value + umin_val < umin_val || dst_reg -> umax_value + umax_val < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value += umin_val ; dst_reg -> umax_value += umax_val ; } dst_reg -> var_off = tnum_add ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_SUB : if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value -= smax_val ; dst_reg -> smax_value -= smin_val ; } if ( dst_reg -> umin_value < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value -= umax_val ; dst_reg -> umax_value -= umin_val ; } dst_reg -> var_off = tnum_sub ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_MUL : dst_reg -> var_off = tnum_mul ( dst_reg -> var_off , src_reg . var_off ) ; if ( smin_val < 0 || dst_reg -> smin_value < 0 ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } if ( umax_val > U32_MAX || dst_reg -> umax_value > U32_MAX ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } dst_reg -> umin_value *= umin_val ; dst_reg -> umax_value *= umax_val ; if ( dst_reg -> umax_value > S64_MAX ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } break ; case BPF_AND : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value & src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_and ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = dst_reg -> var_off . value ; dst_reg -> umax_value = min ( dst_reg -> umax_value , umax_val ) ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_OR : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value | src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_or ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = max ( dst_reg -> umin_value , umin_val ) ; dst_reg -> umax_value = dst_reg -> var_off . value | dst_reg -> var_off . mask ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_LSH : if ( umax_val > 63 ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( dst_reg -> umax_value > 1ULL << ( 63 - umax_val ) ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value <<= umin_val ; dst_reg -> umax_value <<= umax_val ; } if ( src_known ) dst_reg -> var_off = tnum_lshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_lshift ( tnum_unknown , umin_val ) ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_RSH : if ( umax_val > 63 ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; }  if ( dst_reg -> smin_value < 0 ) {  if ( umin_val ) { dst_reg -> smin_value = 0 ; } else { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ;  }  } else { dst_reg -> smin_value = ( u64 ) ( dst_reg -> smin_value ) >> umax_val ; } if ( src_known ) dst_reg -> var_off = tnum_rshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_rshift ( tnum_unknown , umin_val ) ; dst_reg -> umin_value >>= umax_val ; dst_reg -> umax_value >>= umin_val ; __update_reg_bounds ( dst_reg ) ; break ; default : mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } __reg_deduce_bounds ( dst_reg ) ; __reg_bound_offset ( dst_reg ) ; return 0 ; }",if ( src_known && dst_known ) {,470
631,"buggy line: if ( dst_reg -> smin_value < 0 ) {if ( umin_val ) {}}cwe id:CWE-119context: static int adjust_scalar_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , struct bpf_reg_state * dst_reg , struct bpf_reg_state src_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; bool src_known , dst_known ; s64 smin_val , smax_val ; u64 umin_val , umax_val ; if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { coerce_reg_to_32 ( dst_reg ) ; coerce_reg_to_32 ( & src_reg ) ; } smin_val = src_reg . smin_value ; smax_val = src_reg . smax_value ; umin_val = src_reg . umin_value ; umax_val = src_reg . umax_value ; src_known = tnum_is_const ( src_reg . var_off ) ; dst_known = tnum_is_const ( dst_reg -> var_off ) ; switch ( opcode ) { case BPF_ADD : if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value += smin_val ; dst_reg -> smax_value += smax_val ; } if ( dst_reg -> umin_value + umin_val < umin_val || dst_reg -> umax_value + umax_val < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value += umin_val ; dst_reg -> umax_value += umax_val ; } dst_reg -> var_off = tnum_add ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_SUB : if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value -= smax_val ; dst_reg -> smax_value -= smin_val ; } if ( dst_reg -> umin_value < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value -= umax_val ; dst_reg -> umax_value -= umin_val ; } dst_reg -> var_off = tnum_sub ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_MUL : dst_reg -> var_off = tnum_mul ( dst_reg -> var_off , src_reg . var_off ) ; if ( smin_val < 0 || dst_reg -> smin_value < 0 ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } if ( umax_val > U32_MAX || dst_reg -> umax_value > U32_MAX ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } dst_reg -> umin_value *= umin_val ; dst_reg -> umax_value *= umax_val ; if ( dst_reg -> umax_value > S64_MAX ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } break ; case BPF_AND : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value & src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_and ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = dst_reg -> var_off . value ; dst_reg -> umax_value = min ( dst_reg -> umax_value , umax_val ) ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_OR : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value | src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_or ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = max ( dst_reg -> umin_value , umin_val ) ; dst_reg -> umax_value = dst_reg -> var_off . value | dst_reg -> var_off . mask ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_LSH : if ( umax_val > 63 ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( dst_reg -> umax_value > 1ULL << ( 63 - umax_val ) ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value <<= umin_val ; dst_reg -> umax_value <<= umax_val ; } if ( src_known ) dst_reg -> var_off = tnum_lshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_lshift ( tnum_unknown , umin_val ) ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_RSH : if ( umax_val > 63 ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; }  if ( dst_reg -> smin_value < 0 ) {  if ( umin_val ) { dst_reg -> smin_value = 0 ; } else { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ;  }  } else { dst_reg -> smin_value = ( u64 ) ( dst_reg -> smin_value ) >> umax_val ; } if ( src_known ) dst_reg -> var_off = tnum_rshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_rshift ( tnum_unknown , umin_val ) ; dst_reg -> umin_value >>= umax_val ; dst_reg -> umax_value >>= umin_val ; __update_reg_bounds ( dst_reg ) ; break ; default : mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } __reg_deduce_bounds ( dst_reg ) ; __reg_bound_offset ( dst_reg ) ; return 0 ; }",if ( dst_reg -> smin_value < 0 ) {if ( umin_val ) {}},470
632,"buggy line: if ( method == LPF_PICK_FROM_Q ) {const int min_filter_level = 0 ;const int q = vp9_ac_quant ( cm -> base_qindex , 0 ) ;int filt_guess = ROUND_POWER_OF_TWO ( q * 20723 + 1015158 , 18 ) ;if ( cm -> frame_type == KEY_FRAME ) filt_guess -= 4 ;search_filter_level ( sd , cpi , method == LPF_PICK_FROM_SUBIMAGE ) ;}cwe id:CWE-119context: void vp9_pick_filter_level ( const YV12_BUFFER_CONFIG * sd , VP9_COMP * cpi , LPF_PICK_METHOD method ) { VP9_COMMON * const cm = & cpi -> common ; struct loopfilter * const lf = & cm -> lf ; lf -> sharpness_level = cm -> frame_type == KEY_FRAME ? 0 : cpi -> oxcf . sharpness ;  if ( method == LPF_PICK_FROM_Q ) {  const int min_filter_level = 0 ; const int max_filter_level = get_max_filter_level ( cpi ) ;  const int q = vp9_ac_quant ( cm -> base_qindex , 0 ) ;   int filt_guess = ROUND_POWER_OF_TWO ( q * 20723 + 1015158 , 18 ) ;  if ( cm -> frame_type == KEY_FRAME ) filt_guess -= 4 ; lf -> filter_level = clamp ( filt_guess , min_filter_level , max_filter_level ) ; } else {  search_filter_level ( sd , cpi , method == LPF_PICK_FROM_SUBIMAGE ) ;  } }","if ( method == LPF_PICK_MINIMAL_LPF && lf -> filter_level ) {lf -> filter_level = 0 ;}else if ( method >= LPF_PICK_FROM_Q ) {const int min_filter_level = 0 ;const int q = vp9_ac_quant ( cm -> base_qindex , 0 , cm -> bit_depth ) ;# if CONFIG_VP9_HIGHBITDEPTH int filt_guess ;switch ( cm -> bit_depth ) {case VPX_BITS_8 : filt_guess = ROUND_POWER_OF_TWO ( q * 20723 + 1015158 , 18 ) ;break ;case VPX_BITS_10 : filt_guess = ROUND_POWER_OF_TWO ( q * 20723 + 4060632 , 20 ) ;break ;case VPX_BITS_12 : filt_guess = ROUND_POWER_OF_TWO ( q * 20723 + 16242526 , 22 ) ;break ;default : assert ( 0 && ""bit_depth<S2SV_blank>should<S2SV_blank>be<S2SV_blank>VPX_BITS_8,<S2SV_blank>VPX_BITS_10<S2SV_blank>"" ""or<S2SV_blank>VPX_BITS_12"" ) ;return ;}# else int filt_guess = ROUND_POWER_OF_TWO ( q * 20723 + 1015158 , 18 ) ;# endif if ( cm -> frame_type == KEY_FRAME ) filt_guess -= 4 ;lf -> filter_level = search_filter_level ( sd , cpi , method == LPF_PICK_FROM_SUBIMAGE ) ;}",471
633,"buggy line: for ( i = 0 ;cwe id:CWE-284context: static void btif_dm_upstreams_evt ( UINT16 event , char * p_param ) { tBTA_DM_SEC * p_data = ( tBTA_DM_SEC * ) p_param ; tBTA_SERVICE_MASK service_mask ; uint32_t i ; bt_bdaddr_t bd_addr ; BTIF_TRACE_EVENT ( ""btif_dm_upstreams_cback<S2SV_blank><S2SV_blank>ev:<S2SV_blank>%s"" , dump_dm_event ( event ) ) ; switch ( event ) { case BTA_DM_ENABLE_EVT : { BD_NAME bdname ; bt_status_t status ; bt_property_t prop ; prop . type = BT_PROPERTY_BDNAME ; prop . len = BD_NAME_LEN ; prop . val = ( void * ) bdname ; status = btif_storage_get_adapter_property ( & prop ) ; if ( status == BT_STATUS_SUCCESS ) { BTA_DmSetDeviceName ( ( char * ) prop . val ) ; } else { BTA_DmSetDeviceName ( btif_get_default_local_name ( ) ) ; } # if ( defined ( BLE_INCLUDED ) && ( BLE_INCLUDED == TRUE ) ) BTA_DmBleConfigLocalPrivacy ( BLE_LOCAL_PRIVACY_ENABLED ) ; # endif service_mask = btif_get_enabled_services_mask ( ) ; for ( i = 0 ; i <= BTA_MAX_SERVICE_ID ; i ++ ) { if ( service_mask & ( tBTA_SERVICE_MASK ) ( BTA_SERVICE_ID_TO_SERVICE_MASK ( i ) ) ) { btif_in_execute_service_request ( i , TRUE ) ; } } memset ( & pairing_cb , 0 , sizeof ( btif_dm_pairing_cb_t ) ) ; pairing_cb . bond_type = BOND_TYPE_PERSISTENT ; btif_storage_load_bonded_devices ( ) ; btif_storage_load_autopair_device_list ( ) ; btif_enable_bluetooth_evt ( p_data -> enable . status ) ; } break ; case BTA_DM_DISABLE_EVT : service_mask = btif_get_enabled_services_mask ( ) ; for ( i = 0 ; i <= BTA_MAX_SERVICE_ID ; i ++ ) { if ( service_mask & ( tBTA_SERVICE_MASK ) ( BTA_SERVICE_ID_TO_SERVICE_MASK ( i ) ) ) { btif_in_execute_service_request ( i , FALSE ) ; } } btif_disable_bluetooth_evt ( ) ; break ; case BTA_DM_PIN_REQ_EVT : btif_dm_pin_req_evt ( & p_data -> pin_req ) ; break ; case BTA_DM_AUTH_CMPL_EVT : btif_dm_auth_cmpl_evt ( & p_data -> auth_cmpl ) ; break ; case BTA_DM_BOND_CANCEL_CMPL_EVT : if ( pairing_cb . state == BT_BOND_STATE_BONDING ) { bdcpy ( bd_addr . address , pairing_cb . bd_addr ) ; btm_set_bond_type_dev ( pairing_cb . bd_addr , BOND_TYPE_UNKNOWN ) ; bond_state_changed ( p_data -> bond_cancel_cmpl . result , & bd_addr , BT_BOND_STATE_NONE ) ; } break ; case BTA_DM_SP_CFM_REQ_EVT : btif_dm_ssp_cfm_req_evt ( & p_data -> cfm_req ) ; break ; case BTA_DM_SP_KEY_NOTIF_EVT : btif_dm_ssp_key_notif_evt ( & p_data -> key_notif ) ; break ; case BTA_DM_DEV_UNPAIRED_EVT : bdcpy ( bd_addr . address , p_data -> link_down . bd_addr ) ; btm_set_bond_type_dev ( p_data -> link_down . bd_addr , BOND_TYPE_UNKNOWN ) ; # if ( defined ( BTA_HH_INCLUDED ) && ( BTA_HH_INCLUDED == TRUE ) ) btif_hh_remove_device ( bd_addr ) ; # endif btif_storage_remove_bonded_device ( & bd_addr ) ; bond_state_changed ( BT_STATUS_SUCCESS , & bd_addr , BT_BOND_STATE_NONE ) ; break ; case BTA_DM_BUSY_LEVEL_EVT : { if ( p_data -> busy_level . level_flags & BTM_BL_INQUIRY_PAGING_MASK ) { if ( p_data -> busy_level . level_flags == BTM_BL_INQUIRY_STARTED ) { HAL_CBACK ( bt_hal_cbacks , discovery_state_changed_cb , BT_DISCOVERY_STARTED ) ; btif_dm_inquiry_in_progress = TRUE ; } else if ( p_data -> busy_level . level_flags == BTM_BL_INQUIRY_CANCELLED ) { HAL_CBACK ( bt_hal_cbacks , discovery_state_changed_cb , BT_DISCOVERY_STOPPED ) ; btif_dm_inquiry_in_progress = FALSE ; } else if ( p_data -> busy_level . level_flags == BTM_BL_INQUIRY_COMPLETE ) { btif_dm_inquiry_in_progress = FALSE ; } } } break ; case BTA_DM_LINK_UP_EVT : bdcpy ( bd_addr . address , p_data -> link_up . bd_addr ) ; BTIF_TRACE_DEBUG ( ""BTA_DM_LINK_UP_EVT.<S2SV_blank>Sending<S2SV_blank>BT_ACL_STATE_CONNECTED"" ) ; btif_update_remote_version_property ( & bd_addr ) ; HAL_CBACK ( bt_hal_cbacks , acl_state_changed_cb , BT_STATUS_SUCCESS , & bd_addr , BT_ACL_STATE_CONNECTED ) ; break ; case BTA_DM_LINK_DOWN_EVT : bdcpy ( bd_addr . address , p_data -> link_down . bd_addr ) ; btm_set_bond_type_dev ( p_data -> link_down . bd_addr , BOND_TYPE_UNKNOWN ) ; BTIF_TRACE_DEBUG ( ""BTA_DM_LINK_DOWN_EVT.<S2SV_blank>Sending<S2SV_blank>BT_ACL_STATE_DISCONNECTED"" ) ; HAL_CBACK ( bt_hal_cbacks , acl_state_changed_cb , BT_STATUS_SUCCESS , & bd_addr , BT_ACL_STATE_DISCONNECTED ) ; break ; case BTA_DM_HW_ERROR_EVT : BTIF_TRACE_ERROR ( ""Received<S2SV_blank>H/W<S2SV_blank>Error.<S2SV_blank>"" ) ; btif_config_flush ( ) ;  usleep ( 100000 ) ;  kill ( getpid ( ) , SIGKILL ) ; break ; # if ( defined ( BLE_INCLUDED ) && ( BLE_INCLUDED == TRUE ) ) case BTA_DM_BLE_KEY_EVT : BTIF_TRACE_DEBUG ( ""BTA_DM_BLE_KEY_EVT<S2SV_blank>key_type=0x%02x<S2SV_blank>"" , p_data -> ble_key . key_type ) ; if ( pairing_cb . state != BT_BOND_STATE_BONDING ) { BTIF_TRACE_DEBUG ( ""Bond<S2SV_blank>state<S2SV_blank>not<S2SV_blank>sent<S2SV_blank>to<S2SV_blank>App<S2SV_blank>so<S2SV_blank>far.Notify<S2SV_blank>the<S2SV_blank>app<S2SV_blank>now"" ) ; bond_state_changed ( BT_STATUS_SUCCESS , ( bt_bdaddr_t * ) p_data -> ble_key . bd_addr , BT_BOND_STATE_BONDING ) ; } else if ( memcmp ( pairing_cb . bd_addr , p_data -> ble_key . bd_addr , BD_ADDR_LEN ) != 0 ) { BTIF_TRACE_ERROR ( ""BD<S2SV_blank>mismatch<S2SV_blank>discard<S2SV_blank>BLE<S2SV_blank>key_type=%d<S2SV_blank>"" , p_data -> ble_key . key_type ) ; break ; } switch ( p_data -> ble_key . key_type ) { case BTA_LE_KEY_PENC : BTIF_TRACE_DEBUG ( ""Rcv<S2SV_blank>BTA_LE_KEY_PENC"" ) ; pairing_cb . ble . is_penc_key_rcvd = TRUE ; pairing_cb . ble . penc_key = p_data -> ble_key . p_key_value -> penc_key ; break ; case BTA_LE_KEY_PID : BTIF_TRACE_DEBUG ( ""Rcv<S2SV_blank>BTA_LE_KEY_PID"" ) ; pairing_cb . ble . is_pid_key_rcvd = TRUE ; pairing_cb . ble . pid_key = p_data -> ble_key . p_key_value -> pid_key ; break ; case BTA_LE_KEY_PCSRK : BTIF_TRACE_DEBUG ( ""Rcv<S2SV_blank>BTA_LE_KEY_PCSRK"" ) ; pairing_cb . ble . is_pcsrk_key_rcvd = TRUE ; pairing_cb . ble . pcsrk_key = p_data -> ble_key . p_key_value -> pcsrk_key ; break ; case BTA_LE_KEY_LENC : BTIF_TRACE_DEBUG ( ""Rcv<S2SV_blank>BTA_LE_KEY_LENC"" ) ; pairing_cb . ble . is_lenc_key_rcvd = TRUE ; pairing_cb . ble . lenc_key = p_data -> ble_key . p_key_value -> lenc_key ; break ; case BTA_LE_KEY_LCSRK : BTIF_TRACE_DEBUG ( ""Rcv<S2SV_blank>BTA_LE_KEY_LCSRK"" ) ; pairing_cb . ble . is_lcsrk_key_rcvd = TRUE ; pairing_cb . ble . lcsrk_key = p_data -> ble_key . p_key_value -> lcsrk_key ; break ; case BTA_LE_KEY_LID : BTIF_TRACE_DEBUG ( ""Rcv<S2SV_blank>BTA_LE_KEY_LID"" ) ; pairing_cb . ble . is_lidk_key_rcvd = TRUE ; break ; default : BTIF_TRACE_ERROR ( ""unknown<S2SV_blank>BLE<S2SV_blank>key<S2SV_blank>type<S2SV_blank>(0x%02x)"" , p_data -> ble_key . key_type ) ; break ; } break ; case BTA_DM_BLE_SEC_REQ_EVT : BTIF_TRACE_DEBUG ( ""BTA_DM_BLE_SEC_REQ_EVT.<S2SV_blank>"" ) ; btif_dm_ble_sec_req_evt ( & p_data -> ble_req ) ; break ; case BTA_DM_BLE_PASSKEY_NOTIF_EVT : BTIF_TRACE_DEBUG ( ""BTA_DM_BLE_PASSKEY_NOTIF_EVT.<S2SV_blank>"" ) ; btif_dm_ble_key_notif_evt ( & p_data -> key_notif ) ; break ; case BTA_DM_BLE_PASSKEY_REQ_EVT : BTIF_TRACE_DEBUG ( ""BTA_DM_BLE_PASSKEY_REQ_EVT.<S2SV_blank>"" ) ; btif_dm_ble_passkey_req_evt ( & p_data -> pin_req ) ; break ; case BTA_DM_BLE_NC_REQ_EVT : BTIF_TRACE_DEBUG ( ""BTA_DM_BLE_PASSKEY_REQ_EVT.<S2SV_blank>"" ) ; btif_dm_ble_key_nc_req_evt ( & p_data -> key_notif ) ; break ; case BTA_DM_BLE_OOB_REQ_EVT : BTIF_TRACE_DEBUG ( ""BTA_DM_BLE_OOB_REQ_EVT.<S2SV_blank>"" ) ; break ; case BTA_DM_BLE_LOCAL_IR_EVT : BTIF_TRACE_DEBUG ( ""BTA_DM_BLE_LOCAL_IR_EVT.<S2SV_blank>"" ) ; ble_local_key_cb . is_id_keys_rcvd = TRUE ; memcpy ( & ble_local_key_cb . id_keys . irk [ 0 ] , & p_data -> ble_id_keys . irk [ 0 ] , sizeof ( BT_OCTET16 ) ) ; memcpy ( & ble_local_key_cb . id_keys . ir [ 0 ] , & p_data -> ble_id_keys . ir [ 0 ] , sizeof ( BT_OCTET16 ) ) ; memcpy ( & ble_local_key_cb . id_keys . dhk [ 0 ] , & p_data -> ble_id_keys . dhk [ 0 ] , sizeof ( BT_OCTET16 ) ) ; btif_storage_add_ble_local_key ( ( char * ) & ble_local_key_cb . id_keys . irk [ 0 ] , BTIF_DM_LE_LOCAL_KEY_IRK , BT_OCTET16_LEN ) ; btif_storage_add_ble_local_key ( ( char * ) & ble_local_key_cb . id_keys . ir [ 0 ] , BTIF_DM_LE_LOCAL_KEY_IR , BT_OCTET16_LEN ) ; btif_storage_add_ble_local_key ( ( char * ) & ble_local_key_cb . id_keys . dhk [ 0 ] , BTIF_DM_LE_LOCAL_KEY_DHK , BT_OCTET16_LEN ) ; break ; case BTA_DM_BLE_LOCAL_ER_EVT : BTIF_TRACE_DEBUG ( ""BTA_DM_BLE_LOCAL_ER_EVT.<S2SV_blank>"" ) ; ble_local_key_cb . is_er_rcvd = TRUE ; memcpy ( & ble_local_key_cb . er [ 0 ] , & p_data -> ble_er [ 0 ] , sizeof ( BT_OCTET16 ) ) ; btif_storage_add_ble_local_key ( ( char * ) & ble_local_key_cb . er [ 0 ] , BTIF_DM_LE_LOCAL_KEY_ER , BT_OCTET16_LEN ) ; break ; case BTA_DM_BLE_AUTH_CMPL_EVT : BTIF_TRACE_DEBUG ( ""BTA_DM_BLE_AUTH_CMPL_EVT.<S2SV_blank>"" ) ; btif_dm_ble_auth_cmpl_evt ( & p_data -> auth_cmpl ) ; break ; case BTA_DM_LE_FEATURES_READ : { tBTM_BLE_VSC_CB cmn_vsc_cb ; bt_local_le_features_t local_le_features ; char buf [ 512 ] ; bt_property_t prop ; prop . type = BT_PROPERTY_LOCAL_LE_FEATURES ; prop . val = ( void * ) buf ; prop . len = sizeof ( buf ) ; BTM_BleGetVendorCapabilities ( & cmn_vsc_cb ) ; local_le_features . local_privacy_enabled = BTM_BleLocalPrivacyEnabled ( ) ; prop . len = sizeof ( bt_local_le_features_t ) ; if ( cmn_vsc_cb . filter_support == 1 ) local_le_features . max_adv_filter_supported = cmn_vsc_cb . max_filter ; else local_le_features . max_adv_filter_supported = 0 ; local_le_features . max_adv_instance = cmn_vsc_cb . adv_inst_max ; local_le_features . max_irk_list_size = cmn_vsc_cb . max_irk_list_sz ; local_le_features . rpa_offload_supported = cmn_vsc_cb . rpa_offloading ; local_le_features . activity_energy_info_supported = cmn_vsc_cb . energy_support ; local_le_features . scan_result_storage_size = cmn_vsc_cb . tot_scan_results_strg ; local_le_features . version_supported = cmn_vsc_cb . version_supported ; local_le_features . total_trackable_advertisers = cmn_vsc_cb . total_trackable_advertisers ; local_le_features . extended_scan_support = cmn_vsc_cb . extended_scan_support > 0 ; local_le_features . debug_logging_supported = cmn_vsc_cb . debug_logging_supported > 0 ; memcpy ( prop . val , & local_le_features , prop . len ) ; HAL_CBACK ( bt_hal_cbacks , adapter_properties_cb , BT_STATUS_SUCCESS , 1 , & prop ) ; break ; } case BTA_DM_ENER_INFO_READ : { btif_activity_energy_info_cb_t * p_ener_data = ( btif_activity_energy_info_cb_t * ) p_param ; bt_activity_energy_info energy_info ; energy_info . status = p_ener_data -> status ; energy_info . ctrl_state = p_ener_data -> ctrl_state ; energy_info . rx_time = p_ener_data -> rx_time ; energy_info . tx_time = p_ener_data -> tx_time ; energy_info . idle_time = p_ener_data -> idle_time ; energy_info . energy_used = p_ener_data -> energy_used ; HAL_CBACK ( bt_hal_cbacks , energy_info_cb , & energy_info ) ; break ; } # endif case BTA_DM_AUTHORIZE_EVT : case BTA_DM_SIG_STRENGTH_EVT : case BTA_DM_SP_RMT_OOB_EVT : case BTA_DM_SP_KEYPRESS_EVT : case BTA_DM_ROLE_CHG_EVT : default : BTIF_TRACE_WARNING ( ""btif_dm_cback<S2SV_blank>:<S2SV_blank>unhandled<S2SV_blank>event<S2SV_blank>(%d)"" , event ) ; break ; } btif_dm_data_free ( event , p_data ) ; }",TEMP_FAILURE_RETRY ( for ( i = 0 ;,472
634,"buggy line: usleep ( 100000 ) ;kill ( getpid ( ) , SIGKILL ) ;cwe id:CWE-284context: static void btif_dm_upstreams_evt ( UINT16 event , char * p_param ) { tBTA_DM_SEC * p_data = ( tBTA_DM_SEC * ) p_param ; tBTA_SERVICE_MASK service_mask ; uint32_t i ; bt_bdaddr_t bd_addr ; BTIF_TRACE_EVENT ( ""btif_dm_upstreams_cback<S2SV_blank><S2SV_blank>ev:<S2SV_blank>%s"" , dump_dm_event ( event ) ) ; switch ( event ) { case BTA_DM_ENABLE_EVT : { BD_NAME bdname ; bt_status_t status ; bt_property_t prop ; prop . type = BT_PROPERTY_BDNAME ; prop . len = BD_NAME_LEN ; prop . val = ( void * ) bdname ; status = btif_storage_get_adapter_property ( & prop ) ; if ( status == BT_STATUS_SUCCESS ) { BTA_DmSetDeviceName ( ( char * ) prop . val ) ; } else { BTA_DmSetDeviceName ( btif_get_default_local_name ( ) ) ; } # if ( defined ( BLE_INCLUDED ) && ( BLE_INCLUDED == TRUE ) ) BTA_DmBleConfigLocalPrivacy ( BLE_LOCAL_PRIVACY_ENABLED ) ; # endif service_mask = btif_get_enabled_services_mask ( ) ; for ( i = 0 ; i <= BTA_MAX_SERVICE_ID ; i ++ ) { if ( service_mask & ( tBTA_SERVICE_MASK ) ( BTA_SERVICE_ID_TO_SERVICE_MASK ( i ) ) ) { btif_in_execute_service_request ( i , TRUE ) ; } } memset ( & pairing_cb , 0 , sizeof ( btif_dm_pairing_cb_t ) ) ; pairing_cb . bond_type = BOND_TYPE_PERSISTENT ; btif_storage_load_bonded_devices ( ) ; btif_storage_load_autopair_device_list ( ) ; btif_enable_bluetooth_evt ( p_data -> enable . status ) ; } break ; case BTA_DM_DISABLE_EVT : service_mask = btif_get_enabled_services_mask ( ) ; for ( i = 0 ; i <= BTA_MAX_SERVICE_ID ; i ++ ) { if ( service_mask & ( tBTA_SERVICE_MASK ) ( BTA_SERVICE_ID_TO_SERVICE_MASK ( i ) ) ) { btif_in_execute_service_request ( i , FALSE ) ; } } btif_disable_bluetooth_evt ( ) ; break ; case BTA_DM_PIN_REQ_EVT : btif_dm_pin_req_evt ( & p_data -> pin_req ) ; break ; case BTA_DM_AUTH_CMPL_EVT : btif_dm_auth_cmpl_evt ( & p_data -> auth_cmpl ) ; break ; case BTA_DM_BOND_CANCEL_CMPL_EVT : if ( pairing_cb . state == BT_BOND_STATE_BONDING ) { bdcpy ( bd_addr . address , pairing_cb . bd_addr ) ; btm_set_bond_type_dev ( pairing_cb . bd_addr , BOND_TYPE_UNKNOWN ) ; bond_state_changed ( p_data -> bond_cancel_cmpl . result , & bd_addr , BT_BOND_STATE_NONE ) ; } break ; case BTA_DM_SP_CFM_REQ_EVT : btif_dm_ssp_cfm_req_evt ( & p_data -> cfm_req ) ; break ; case BTA_DM_SP_KEY_NOTIF_EVT : btif_dm_ssp_key_notif_evt ( & p_data -> key_notif ) ; break ; case BTA_DM_DEV_UNPAIRED_EVT : bdcpy ( bd_addr . address , p_data -> link_down . bd_addr ) ; btm_set_bond_type_dev ( p_data -> link_down . bd_addr , BOND_TYPE_UNKNOWN ) ; # if ( defined ( BTA_HH_INCLUDED ) && ( BTA_HH_INCLUDED == TRUE ) ) btif_hh_remove_device ( bd_addr ) ; # endif btif_storage_remove_bonded_device ( & bd_addr ) ; bond_state_changed ( BT_STATUS_SUCCESS , & bd_addr , BT_BOND_STATE_NONE ) ; break ; case BTA_DM_BUSY_LEVEL_EVT : { if ( p_data -> busy_level . level_flags & BTM_BL_INQUIRY_PAGING_MASK ) { if ( p_data -> busy_level . level_flags == BTM_BL_INQUIRY_STARTED ) { HAL_CBACK ( bt_hal_cbacks , discovery_state_changed_cb , BT_DISCOVERY_STARTED ) ; btif_dm_inquiry_in_progress = TRUE ; } else if ( p_data -> busy_level . level_flags == BTM_BL_INQUIRY_CANCELLED ) { HAL_CBACK ( bt_hal_cbacks , discovery_state_changed_cb , BT_DISCOVERY_STOPPED ) ; btif_dm_inquiry_in_progress = FALSE ; } else if ( p_data -> busy_level . level_flags == BTM_BL_INQUIRY_COMPLETE ) { btif_dm_inquiry_in_progress = FALSE ; } } } break ; case BTA_DM_LINK_UP_EVT : bdcpy ( bd_addr . address , p_data -> link_up . bd_addr ) ; BTIF_TRACE_DEBUG ( ""BTA_DM_LINK_UP_EVT.<S2SV_blank>Sending<S2SV_blank>BT_ACL_STATE_CONNECTED"" ) ; btif_update_remote_version_property ( & bd_addr ) ; HAL_CBACK ( bt_hal_cbacks , acl_state_changed_cb , BT_STATUS_SUCCESS , & bd_addr , BT_ACL_STATE_CONNECTED ) ; break ; case BTA_DM_LINK_DOWN_EVT : bdcpy ( bd_addr . address , p_data -> link_down . bd_addr ) ; btm_set_bond_type_dev ( p_data -> link_down . bd_addr , BOND_TYPE_UNKNOWN ) ; BTIF_TRACE_DEBUG ( ""BTA_DM_LINK_DOWN_EVT.<S2SV_blank>Sending<S2SV_blank>BT_ACL_STATE_DISCONNECTED"" ) ; HAL_CBACK ( bt_hal_cbacks , acl_state_changed_cb , BT_STATUS_SUCCESS , & bd_addr , BT_ACL_STATE_DISCONNECTED ) ; break ; case BTA_DM_HW_ERROR_EVT : BTIF_TRACE_ERROR ( ""Received<S2SV_blank>H/W<S2SV_blank>Error.<S2SV_blank>"" ) ; btif_config_flush ( ) ;  usleep ( 100000 ) ;  kill ( getpid ( ) , SIGKILL ) ; break ; # if ( defined ( BLE_INCLUDED ) && ( BLE_INCLUDED == TRUE ) ) case BTA_DM_BLE_KEY_EVT : BTIF_TRACE_DEBUG ( ""BTA_DM_BLE_KEY_EVT<S2SV_blank>key_type=0x%02x<S2SV_blank>"" , p_data -> ble_key . key_type ) ; if ( pairing_cb . state != BT_BOND_STATE_BONDING ) { BTIF_TRACE_DEBUG ( ""Bond<S2SV_blank>state<S2SV_blank>not<S2SV_blank>sent<S2SV_blank>to<S2SV_blank>App<S2SV_blank>so<S2SV_blank>far.Notify<S2SV_blank>the<S2SV_blank>app<S2SV_blank>now"" ) ; bond_state_changed ( BT_STATUS_SUCCESS , ( bt_bdaddr_t * ) p_data -> ble_key . bd_addr , BT_BOND_STATE_BONDING ) ; } else if ( memcmp ( pairing_cb . bd_addr , p_data -> ble_key . bd_addr , BD_ADDR_LEN ) != 0 ) { BTIF_TRACE_ERROR ( ""BD<S2SV_blank>mismatch<S2SV_blank>discard<S2SV_blank>BLE<S2SV_blank>key_type=%d<S2SV_blank>"" , p_data -> ble_key . key_type ) ; break ; } switch ( p_data -> ble_key . key_type ) { case BTA_LE_KEY_PENC : BTIF_TRACE_DEBUG ( ""Rcv<S2SV_blank>BTA_LE_KEY_PENC"" ) ; pairing_cb . ble . is_penc_key_rcvd = TRUE ; pairing_cb . ble . penc_key = p_data -> ble_key . p_key_value -> penc_key ; break ; case BTA_LE_KEY_PID : BTIF_TRACE_DEBUG ( ""Rcv<S2SV_blank>BTA_LE_KEY_PID"" ) ; pairing_cb . ble . is_pid_key_rcvd = TRUE ; pairing_cb . ble . pid_key = p_data -> ble_key . p_key_value -> pid_key ; break ; case BTA_LE_KEY_PCSRK : BTIF_TRACE_DEBUG ( ""Rcv<S2SV_blank>BTA_LE_KEY_PCSRK"" ) ; pairing_cb . ble . is_pcsrk_key_rcvd = TRUE ; pairing_cb . ble . pcsrk_key = p_data -> ble_key . p_key_value -> pcsrk_key ; break ; case BTA_LE_KEY_LENC : BTIF_TRACE_DEBUG ( ""Rcv<S2SV_blank>BTA_LE_KEY_LENC"" ) ; pairing_cb . ble . is_lenc_key_rcvd = TRUE ; pairing_cb . ble . lenc_key = p_data -> ble_key . p_key_value -> lenc_key ; break ; case BTA_LE_KEY_LCSRK : BTIF_TRACE_DEBUG ( ""Rcv<S2SV_blank>BTA_LE_KEY_LCSRK"" ) ; pairing_cb . ble . is_lcsrk_key_rcvd = TRUE ; pairing_cb . ble . lcsrk_key = p_data -> ble_key . p_key_value -> lcsrk_key ; break ; case BTA_LE_KEY_LID : BTIF_TRACE_DEBUG ( ""Rcv<S2SV_blank>BTA_LE_KEY_LID"" ) ; pairing_cb . ble . is_lidk_key_rcvd = TRUE ; break ; default : BTIF_TRACE_ERROR ( ""unknown<S2SV_blank>BLE<S2SV_blank>key<S2SV_blank>type<S2SV_blank>(0x%02x)"" , p_data -> ble_key . key_type ) ; break ; } break ; case BTA_DM_BLE_SEC_REQ_EVT : BTIF_TRACE_DEBUG ( ""BTA_DM_BLE_SEC_REQ_EVT.<S2SV_blank>"" ) ; btif_dm_ble_sec_req_evt ( & p_data -> ble_req ) ; break ; case BTA_DM_BLE_PASSKEY_NOTIF_EVT : BTIF_TRACE_DEBUG ( ""BTA_DM_BLE_PASSKEY_NOTIF_EVT.<S2SV_blank>"" ) ; btif_dm_ble_key_notif_evt ( & p_data -> key_notif ) ; break ; case BTA_DM_BLE_PASSKEY_REQ_EVT : BTIF_TRACE_DEBUG ( ""BTA_DM_BLE_PASSKEY_REQ_EVT.<S2SV_blank>"" ) ; btif_dm_ble_passkey_req_evt ( & p_data -> pin_req ) ; break ; case BTA_DM_BLE_NC_REQ_EVT : BTIF_TRACE_DEBUG ( ""BTA_DM_BLE_PASSKEY_REQ_EVT.<S2SV_blank>"" ) ; btif_dm_ble_key_nc_req_evt ( & p_data -> key_notif ) ; break ; case BTA_DM_BLE_OOB_REQ_EVT : BTIF_TRACE_DEBUG ( ""BTA_DM_BLE_OOB_REQ_EVT.<S2SV_blank>"" ) ; break ; case BTA_DM_BLE_LOCAL_IR_EVT : BTIF_TRACE_DEBUG ( ""BTA_DM_BLE_LOCAL_IR_EVT.<S2SV_blank>"" ) ; ble_local_key_cb . is_id_keys_rcvd = TRUE ; memcpy ( & ble_local_key_cb . id_keys . irk [ 0 ] , & p_data -> ble_id_keys . irk [ 0 ] , sizeof ( BT_OCTET16 ) ) ; memcpy ( & ble_local_key_cb . id_keys . ir [ 0 ] , & p_data -> ble_id_keys . ir [ 0 ] , sizeof ( BT_OCTET16 ) ) ; memcpy ( & ble_local_key_cb . id_keys . dhk [ 0 ] , & p_data -> ble_id_keys . dhk [ 0 ] , sizeof ( BT_OCTET16 ) ) ; btif_storage_add_ble_local_key ( ( char * ) & ble_local_key_cb . id_keys . irk [ 0 ] , BTIF_DM_LE_LOCAL_KEY_IRK , BT_OCTET16_LEN ) ; btif_storage_add_ble_local_key ( ( char * ) & ble_local_key_cb . id_keys . ir [ 0 ] , BTIF_DM_LE_LOCAL_KEY_IR , BT_OCTET16_LEN ) ; btif_storage_add_ble_local_key ( ( char * ) & ble_local_key_cb . id_keys . dhk [ 0 ] , BTIF_DM_LE_LOCAL_KEY_DHK , BT_OCTET16_LEN ) ; break ; case BTA_DM_BLE_LOCAL_ER_EVT : BTIF_TRACE_DEBUG ( ""BTA_DM_BLE_LOCAL_ER_EVT.<S2SV_blank>"" ) ; ble_local_key_cb . is_er_rcvd = TRUE ; memcpy ( & ble_local_key_cb . er [ 0 ] , & p_data -> ble_er [ 0 ] , sizeof ( BT_OCTET16 ) ) ; btif_storage_add_ble_local_key ( ( char * ) & ble_local_key_cb . er [ 0 ] , BTIF_DM_LE_LOCAL_KEY_ER , BT_OCTET16_LEN ) ; break ; case BTA_DM_BLE_AUTH_CMPL_EVT : BTIF_TRACE_DEBUG ( ""BTA_DM_BLE_AUTH_CMPL_EVT.<S2SV_blank>"" ) ; btif_dm_ble_auth_cmpl_evt ( & p_data -> auth_cmpl ) ; break ; case BTA_DM_LE_FEATURES_READ : { tBTM_BLE_VSC_CB cmn_vsc_cb ; bt_local_le_features_t local_le_features ; char buf [ 512 ] ; bt_property_t prop ; prop . type = BT_PROPERTY_LOCAL_LE_FEATURES ; prop . val = ( void * ) buf ; prop . len = sizeof ( buf ) ; BTM_BleGetVendorCapabilities ( & cmn_vsc_cb ) ; local_le_features . local_privacy_enabled = BTM_BleLocalPrivacyEnabled ( ) ; prop . len = sizeof ( bt_local_le_features_t ) ; if ( cmn_vsc_cb . filter_support == 1 ) local_le_features . max_adv_filter_supported = cmn_vsc_cb . max_filter ; else local_le_features . max_adv_filter_supported = 0 ; local_le_features . max_adv_instance = cmn_vsc_cb . adv_inst_max ; local_le_features . max_irk_list_size = cmn_vsc_cb . max_irk_list_sz ; local_le_features . rpa_offload_supported = cmn_vsc_cb . rpa_offloading ; local_le_features . activity_energy_info_supported = cmn_vsc_cb . energy_support ; local_le_features . scan_result_storage_size = cmn_vsc_cb . tot_scan_results_strg ; local_le_features . version_supported = cmn_vsc_cb . version_supported ; local_le_features . total_trackable_advertisers = cmn_vsc_cb . total_trackable_advertisers ; local_le_features . extended_scan_support = cmn_vsc_cb . extended_scan_support > 0 ; local_le_features . debug_logging_supported = cmn_vsc_cb . debug_logging_supported > 0 ; memcpy ( prop . val , & local_le_features , prop . len ) ; HAL_CBACK ( bt_hal_cbacks , adapter_properties_cb , BT_STATUS_SUCCESS , 1 , & prop ) ; break ; } case BTA_DM_ENER_INFO_READ : { btif_activity_energy_info_cb_t * p_ener_data = ( btif_activity_energy_info_cb_t * ) p_param ; bt_activity_energy_info energy_info ; energy_info . status = p_ener_data -> status ; energy_info . ctrl_state = p_ener_data -> ctrl_state ; energy_info . rx_time = p_ener_data -> rx_time ; energy_info . tx_time = p_ener_data -> tx_time ; energy_info . idle_time = p_ener_data -> idle_time ; energy_info . energy_used = p_ener_data -> energy_used ; HAL_CBACK ( bt_hal_cbacks , energy_info_cb , & energy_info ) ; break ; } # endif case BTA_DM_AUTHORIZE_EVT : case BTA_DM_SIG_STRENGTH_EVT : case BTA_DM_SP_RMT_OOB_EVT : case BTA_DM_SP_KEYPRESS_EVT : case BTA_DM_ROLE_CHG_EVT : default : BTIF_TRACE_WARNING ( ""btif_dm_cback<S2SV_blank>:<S2SV_blank>unhandled<S2SV_blank>event<S2SV_blank>(%d)"" , event ) ; break ; } btif_dm_data_free ( event , p_data ) ; }","usleep ( 100000 ) ) ;kill ( getpid ( ) , SIGKILL ) ;",472
635,"buggy line: quantum_info = DestroyQuantumInfo ( quantum_info ) ;return ( DestroyImageList ( image ) ) ;cwe id:CWE-772context: static Image * ReadYCBCRImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { const unsigned char * pixels ; Image * canvas_image , * image ; MagickBooleanType status ; MagickOffsetType scene ; QuantumInfo * quantum_info ; QuantumType quantum_type ; register const Quantum * p ; register ssize_t i , x ; register Quantum * q ; size_t length ; ssize_t count , y ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( OptionError , ""MustSpecifyImageSize"" ) ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; SetImageColorspace ( image , YCbCrColorspace , exception ) ; if ( image_info -> interlace != PartitionInterlace ) { status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( DiscardBlobBytes ( image , image -> offset ) == MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; } canvas_image = CloneImage ( image , image -> extract_info . width , 1 , MagickFalse , exception ) ; ( void ) SetImageVirtualPixelMethod ( canvas_image , BlackVirtualPixelMethod , exception ) ; quantum_info = AcquireQuantumInfo ( image_info , canvas_image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; quantum_type = RGBQuantum ; if ( LocaleCompare ( image_info -> magick , ""YCbCrA"" ) == 0 ) { quantum_type = RGBAQuantum ; image -> alpha_trait = BlendPixelTrait ; } pixels = ( const unsigned char * ) NULL ; if ( image_info -> number_scenes != 0 ) while ( image -> scene < image_info -> scene ) { image -> scene ++ ; length = GetQuantumExtent ( canvas_image , quantum_info , quantum_type ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; if ( count != ( ssize_t ) length ) break ; } } count = 0 ; length = 0 ; scene = 0 ; do { if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) {  quantum_info = DestroyQuantumInfo ( quantum_info ) ;  return ( DestroyImageList ( image ) ) ; } SetImageColorspace ( image , YCbCrColorspace , exception ) ; switch ( image_info -> interlace ) { case NoInterlace : default : { if ( scene == 0 ) { length = GetQuantumExtent ( canvas_image , quantum_info , quantum_type ) ; pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; } for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , quantum_type , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = QueueAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const Quantum * ) NULL ) || ( q == ( Quantum * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , GetPixelRed ( canvas_image , p ) , q ) ; SetPixelGreen ( image , GetPixelGreen ( canvas_image , p ) , q ) ; SetPixelBlue ( image , GetPixelBlue ( canvas_image , p ) , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , GetPixelAlpha ( canvas_image , p ) , q ) ; p += GetPixelChannels ( canvas_image ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; } break ; } case LineInterlace : { static QuantumType quantum_types [ 4 ] = { RedQuantum , GreenQuantum , BlueQuantum , OpacityQuantum } ; if ( scene == 0 ) { length = GetQuantumExtent ( canvas_image , quantum_info , RedQuantum ) ; pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; } for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { for ( i = 0 ; i < ( image -> alpha_trait != UndefinedPixelTrait ? 4 : 3 ) ; i ++ ) { if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } quantum_type = quantum_types [ i ] ; q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , quantum_type , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const Quantum * ) NULL ) || ( q == ( Quantum * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { switch ( quantum_type ) { case RedQuantum : { SetPixelRed ( image , GetPixelRed ( canvas_image , p ) , q ) ; break ; } case GreenQuantum : { SetPixelGreen ( image , GetPixelGreen ( canvas_image , p ) , q ) ; break ; } case BlueQuantum : { SetPixelBlue ( image , GetPixelBlue ( canvas_image , p ) , q ) ; break ; } case OpacityQuantum : { SetPixelAlpha ( image , GetPixelAlpha ( canvas_image , p ) , q ) ; break ; } default : break ; } p += GetPixelChannels ( canvas_image ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case PlaneInterlace : { if ( scene == 0 ) { length = GetQuantumExtent ( canvas_image , quantum_info , RedQuantum ) ; pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; } for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , RedQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const Quantum * ) NULL ) || ( q == ( Quantum * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , GetPixelRed ( canvas_image , p ) , q ) ; p += GetPixelChannels ( canvas_image ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 1 , 5 ) ; if ( status == MagickFalse ) break ; } for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , GreenQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const Quantum * ) NULL ) || ( q == ( Quantum * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelGreen ( image , GetPixelGreen ( canvas_image , p ) , q ) ; p += GetPixelChannels ( canvas_image ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 2 , 5 ) ; if ( status == MagickFalse ) break ; } for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , BlueQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const Quantum * ) NULL ) || ( q == ( Quantum * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelBlue ( image , GetPixelBlue ( canvas_image , p ) , q ) ; p += GetPixelChannels ( canvas_image ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 3 , 5 ) ; if ( status == MagickFalse ) break ; } if ( image -> alpha_trait != UndefinedPixelTrait ) { for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , AlphaQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const Quantum * ) NULL ) || ( q == ( Quantum * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelAlpha ( image , GetPixelAlpha ( canvas_image , p ) , q ) ; p += GetPixelChannels ( canvas_image ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 4 , 5 ) ; if ( status == MagickFalse ) break ; } } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 5 , 5 ) ; if ( status == MagickFalse ) break ; } break ; } case PartitionInterlace : { AppendImageFormat ( ""Y"" , image -> filename ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { canvas_image = DestroyImageList ( canvas_image ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( DiscardBlobBytes ( image , image -> offset ) == MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; length = GetQuantumExtent ( canvas_image , quantum_info , RedQuantum ) ; for ( i = 0 ; i < ( ssize_t ) scene ; i ++ ) for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , RedQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const Quantum * ) NULL ) || ( q == ( Quantum * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , GetPixelRed ( canvas_image , p ) , q ) ; p += GetPixelChannels ( canvas_image ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 1 , 5 ) ; if ( status == MagickFalse ) break ; } ( void ) CloseBlob ( image ) ; AppendImageFormat ( ""Cb"" , image -> filename ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { canvas_image = DestroyImageList ( canvas_image ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } length = GetQuantumExtent ( canvas_image , quantum_info , GreenQuantum ) ; for ( i = 0 ; i < ( ssize_t ) scene ; i ++ ) for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , GreenQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const Quantum * ) NULL ) || ( q == ( Quantum * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelGreen ( image , GetPixelGreen ( canvas_image , p ) , q ) ; p += GetPixelChannels ( canvas_image ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 2 , 5 ) ; if ( status == MagickFalse ) break ; } ( void ) CloseBlob ( image ) ; AppendImageFormat ( ""Cr"" , image -> filename ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { canvas_image = DestroyImageList ( canvas_image ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } length = GetQuantumExtent ( canvas_image , quantum_info , BlueQuantum ) ; for ( i = 0 ; i < ( ssize_t ) scene ; i ++ ) for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , BlueQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const Quantum * ) NULL ) || ( q == ( Quantum * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelBlue ( image , GetPixelBlue ( canvas_image , p ) , q ) ; p += GetPixelChannels ( canvas_image ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 3 , 5 ) ; if ( status == MagickFalse ) break ; } if ( image -> alpha_trait != UndefinedPixelTrait ) { ( void ) CloseBlob ( image ) ; AppendImageFormat ( ""A"" , image -> filename ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { canvas_image = DestroyImageList ( canvas_image ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } length = GetQuantumExtent ( canvas_image , quantum_info , AlphaQuantum ) ; for ( i = 0 ; i < ( ssize_t ) scene ; i ++ ) for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , BlueQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const Quantum * ) NULL ) || ( q == ( Quantum * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelAlpha ( image , GetPixelAlpha ( canvas_image , p ) , q ) ; p += GetPixelChannels ( canvas_image ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 4 , 5 ) ; if ( status == MagickFalse ) break ; } } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 5 , 5 ) ; if ( status == MagickFalse ) break ; } break ; } } SetQuantumImageType ( image , quantum_type ) ; if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( count == ( ssize_t ) length ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } scene ++ ; } while ( count == ( ssize_t ) length ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ; canvas_image = DestroyImage ( canvas_image ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }",quantum_info = DestroyQuantumInfo ( quantum_info ) ;canvas_image = DestroyImage ( canvas_image ) ;return ( DestroyImageList ( image ) ) ;,473
636,"buggy line: int a = getnum ( fmt , MAXALIGN ) ;if ( ! isp2 ( a ) ) luaL_error ( L , ""alignment<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>power<S2SV_blank>of<S2SV_blank>2"" , a ) ;cwe id:CWE-190context: static void controloptions ( lua_State * L , int opt , const char * * fmt , Header * h ) { switch ( opt ) { case '<S2SV_blank>' : return ; case '>' : h -> endian = BIG ; return ; case '<' : h -> endian = LITTLE ; return ; case '!' : {  int a = getnum ( fmt , MAXALIGN ) ;  if ( ! isp2 ( a ) ) luaL_error ( L , ""alignment<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>power<S2SV_blank>of<S2SV_blank>2"" , a ) ; h -> align = a ; return ; } default : { const char * msg = lua_pushfstring ( L , ""invalid<S2SV_blank>format<S2SV_blank>option<S2SV_blank>\'%c\'"" , opt ) ; luaL_argerror ( L , 1 , msg ) ; } } }","int a = getnum ( L , fmt , MAXALIGN ) ;if ( ! isp2 ( a ) ) luaL_error ( L , ""alignment<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>power<S2SV_blank>of<S2SV_blank>2"" , a ) ;",474
637,"buggy line: void usage_exit ( ) {fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank><codec><S2SV_blank><width><S2SV_blank><height><S2SV_blank><infile><S2SV_blank><outfile>\\\cwe id:CWE-119context:  void usage_exit ( ) {  fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank><codec><S2SV_blank><width><S2SV_blank><height><S2SV_blank><infile><S2SV_blank><outfile>\\n"" , exec_name ) ; exit ( EXIT_FAILURE ) ; }","void usage_exit ( void ) {fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank><codec><S2SV_blank><width><S2SV_blank><height><S2SV_blank><infile><S2SV_blank><outfile>\\\",475
638,"buggy line: if ( strlen ( l_line ) == l_line_length ) {cwe id:CWE-119context: void edge_sparse_csr_reader_double ( const char * i_csr_file_in , unsigned int * * o_row_idx , unsigned int * * o_column_idx , double * * o_values , unsigned int * o_row_count , unsigned int * o_column_count , unsigned int * o_element_count ) { FILE * l_csr_file_handle ; const unsigned int l_line_length = 512 ; char l_line [ 512 + 1 ] ; unsigned int l_header_read = 0 ; unsigned int * l_row_idx_id = NULL ; unsigned int l_i = 0 ; l_csr_file_handle = fopen ( i_csr_file_in , ""r"" ) ; if ( l_csr_file_handle == NULL ) { fprintf ( stderr , ""cannot<S2SV_blank>open<S2SV_blank>CSR<S2SV_blank>file!\\n"" ) ; return ; } while ( fgets ( l_line , l_line_length , l_csr_file_handle ) != NULL ) { if ( strlen ( l_line ) == l_line_length ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>read<S2SV_blank>file<S2SV_blank>length!\\n"" ) ; return ; } if ( l_line [ 0 ] == '%' ) { continue ; } else { if ( l_header_read == 0 ) {  if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%u"" , o_row_count , o_column_count , o_element_count ) == 3 ) {  * o_column_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_element_count ) ) ; * o_row_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_row_count + 1 ) ) ; * o_values = ( double * ) malloc ( sizeof ( double ) * ( * o_element_count ) ) ; l_row_idx_id = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_row_count ) ) ; if ( ( * o_row_idx == NULL ) || ( * o_column_idx == NULL ) || ( * o_values == NULL ) || ( l_row_idx_id == NULL ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>sp<S2SV_blank>data!\\n"" ) ; return ; } memset ( * o_row_idx , 0 , sizeof ( unsigned int ) * ( * o_row_count + 1 ) ) ; memset ( * o_column_idx , 0 , sizeof ( unsigned int ) * ( * o_element_count ) ) ; memset ( * o_values , 0 , sizeof ( double ) * ( * o_element_count ) ) ; memset ( l_row_idx_id , 0 , sizeof ( unsigned int ) * ( * o_row_count ) ) ; for ( l_i = 0 ; l_i < ( * o_row_count + 1 ) ; l_i ++ ) ( * o_row_idx ) [ l_i ] = ( * o_element_count ) ; ( * o_row_idx ) [ 0 ] = 0 ; l_i = 0 ; l_header_read = 1 ; } else { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>csr<S2SV_blank>description!\\n"" ) ; return ; } } else { unsigned int l_row , l_column ; double l_value ; if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%lf"" , & l_row , & l_column , & l_value ) != 3 ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>read<S2SV_blank>element!\\n"" ) ; return ; } l_row -- ; l_column -- ; ( * o_column_idx ) [ l_i ] = l_column ; ( * o_values ) [ l_i ] = l_value ; l_i ++ ; l_row_idx_id [ l_row ] = 1 ; ( * o_row_idx ) [ l_row + 1 ] = l_i ; } } } fclose ( l_csr_file_handle ) ; if ( l_i != ( * o_element_count ) ) { fprintf ( stderr , ""we<S2SV_blank>were<S2SV_blank>not<S2SV_blank>able<S2SV_blank>to<S2SV_blank>read<S2SV_blank>all<S2SV_blank>elements!\\n"" ) ; return ; } for ( l_i = 0 ; l_i < ( * o_row_count ) ; l_i ++ ) { if ( l_row_idx_id [ l_i ] == 0 ) { ( * o_row_idx ) [ l_i + 1 ] = ( * o_row_idx ) [ l_i ] ; } } if ( l_row_idx_id != NULL ) { free ( l_row_idx_id ) ; } }",if ( 3 == strlen ( l_line ) == l_line_length ) {,476
639,"buggy line: if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%u"" , o_row_count , o_column_count , o_element_count ) == 3 ) {* o_column_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_element_count ) ) ;cwe id:CWE-119context: void edge_sparse_csr_reader_double ( const char * i_csr_file_in , unsigned int * * o_row_idx , unsigned int * * o_column_idx , double * * o_values , unsigned int * o_row_count , unsigned int * o_column_count , unsigned int * o_element_count ) { FILE * l_csr_file_handle ; const unsigned int l_line_length = 512 ; char l_line [ 512 + 1 ] ; unsigned int l_header_read = 0 ; unsigned int * l_row_idx_id = NULL ; unsigned int l_i = 0 ; l_csr_file_handle = fopen ( i_csr_file_in , ""r"" ) ; if ( l_csr_file_handle == NULL ) { fprintf ( stderr , ""cannot<S2SV_blank>open<S2SV_blank>CSR<S2SV_blank>file!\\n"" ) ; return ; } while ( fgets ( l_line , l_line_length , l_csr_file_handle ) != NULL ) { if ( strlen ( l_line ) == l_line_length ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>read<S2SV_blank>file<S2SV_blank>length!\\n"" ) ; return ; } if ( l_line [ 0 ] == '%' ) { continue ; } else { if ( l_header_read == 0 ) {  if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%u"" , o_row_count , o_column_count , o_element_count ) == 3 ) {  * o_column_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_element_count ) ) ; * o_row_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_row_count + 1 ) ) ; * o_values = ( double * ) malloc ( sizeof ( double ) * ( * o_element_count ) ) ; l_row_idx_id = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_row_count ) ) ; if ( ( * o_row_idx == NULL ) || ( * o_column_idx == NULL ) || ( * o_values == NULL ) || ( l_row_idx_id == NULL ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>sp<S2SV_blank>data!\\n"" ) ; return ; } memset ( * o_row_idx , 0 , sizeof ( unsigned int ) * ( * o_row_count + 1 ) ) ; memset ( * o_column_idx , 0 , sizeof ( unsigned int ) * ( * o_element_count ) ) ; memset ( * o_values , 0 , sizeof ( double ) * ( * o_element_count ) ) ; memset ( l_row_idx_id , 0 , sizeof ( unsigned int ) * ( * o_row_count ) ) ; for ( l_i = 0 ; l_i < ( * o_row_count + 1 ) ; l_i ++ ) ( * o_row_idx ) [ l_i ] = ( * o_element_count ) ; ( * o_row_idx ) [ 0 ] = 0 ; l_i = 0 ; l_header_read = 1 ; } else { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>csr<S2SV_blank>description!\\n"" ) ; return ; } } else { unsigned int l_row , l_column ; double l_value ; if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%lf"" , & l_row , & l_column , & l_value ) != 3 ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>read<S2SV_blank>element!\\n"" ) ; return ; } l_row -- ; l_column -- ; ( * o_column_idx ) [ l_i ] = l_column ; ( * o_values ) [ l_i ] = l_value ; l_i ++ ; l_row_idx_id [ l_row ] = 1 ; ( * o_row_idx ) [ l_row + 1 ] = l_i ; } } } fclose ( l_csr_file_handle ) ; if ( l_i != ( * o_element_count ) ) { fprintf ( stderr , ""we<S2SV_blank>were<S2SV_blank>not<S2SV_blank>able<S2SV_blank>to<S2SV_blank>read<S2SV_blank>all<S2SV_blank>elements!\\n"" ) ; return ; } for ( l_i = 0 ; l_i < ( * o_row_count ) ; l_i ++ ) { if ( l_row_idx_id [ l_i ] == 0 ) { ( * o_row_idx ) [ l_i + 1 ] = ( * o_row_idx ) [ l_i ] ; } } if ( l_row_idx_id != NULL ) { free ( l_row_idx_id ) ; } }","if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%u"" , o_row_count , o_column_count , o_element_count ) && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) {* o_column_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_element_count ) ) ;",476
640,"buggy line: if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) )  break ;SetImageColorspace ( image , CMYKColorspace ) ;cwe id:CWE-119context: static Image * ReadCMYKImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * canvas_image , * image ; MagickBooleanType status ; MagickOffsetType scene ; QuantumInfo * quantum_info ; QuantumType quantum_type ; register ssize_t i ; size_t length ; ssize_t count , y ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( OptionError , ""MustSpecifyImageSize"" ) ; SetImageColorspace ( image , CMYKColorspace ) ; if ( image_info -> interlace != PartitionInterlace ) { status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( DiscardBlobBytes ( image , image -> offset ) == MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; } canvas_image = CloneImage ( image , image -> extract_info . width , 1 , MagickFalse , exception ) ; ( void ) SetImageVirtualPixelMethod ( canvas_image , BlackVirtualPixelMethod ) ; quantum_info = AcquireQuantumInfo ( image_info , canvas_image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixels = GetQuantumPixels ( quantum_info ) ; quantum_type = CMYKQuantum ; if ( LocaleCompare ( image_info -> magick , ""CMYKA"" ) == 0 ) { quantum_type = CMYKAQuantum ; image -> matte = MagickTrue ; } if ( image_info -> number_scenes != 0 ) while ( image -> scene < image_info -> scene ) { image -> scene ++ ; length = GetQuantumExtent ( canvas_image , quantum_info , quantum_type ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { count = ReadBlob ( image , length , pixels ) ; if ( count != ( ssize_t ) length ) break ; } } count = 0 ; length = 0 ; scene = 0 ; do { if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) )  break ;  SetImageColorspace ( image , CMYKColorspace ) ; switch ( image_info -> interlace ) { case NoInterlace : default : { if ( scene == 0 ) { length = GetQuantumExtent ( canvas_image , quantum_info , quantum_type ) ; count = ReadBlob ( image , length , pixels ) ; } for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { register const IndexPacket * restrict canvas_indexes ; register const PixelPacket * restrict p ; register IndexPacket * restrict indexes ; register PixelPacket * restrict q ; register ssize_t x ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , quantum_type , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = QueueAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const PixelPacket * ) NULL ) || ( q == ( PixelPacket * ) NULL ) ) break ; canvas_indexes = GetVirtualIndexQueue ( canvas_image ) ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , GetPixelRed ( p ) ) ; SetPixelGreen ( q , GetPixelGreen ( p ) ) ; SetPixelBlue ( q , GetPixelBlue ( p ) ) ; SetPixelBlack ( indexes + x , GetPixelBlack ( canvas_indexes + image -> extract_info . x + x ) ) ; SetPixelOpacity ( q , OpaqueOpacity ) ; if ( image -> matte != MagickFalse ) SetPixelOpacity ( q , GetPixelOpacity ( p ) ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } count = ReadBlob ( image , length , pixels ) ; } break ; } case LineInterlace : { static QuantumType quantum_types [ 5 ] = { CyanQuantum , MagentaQuantum , YellowQuantum , BlackQuantum , OpacityQuantum } ; if ( scene == 0 ) { length = GetQuantumExtent ( canvas_image , quantum_info , CyanQuantum ) ; count = ReadBlob ( image , length , pixels ) ; } for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { register const IndexPacket * restrict canvas_indexes ; register const PixelPacket * restrict p ; register IndexPacket * restrict indexes ; register PixelPacket * restrict q ; register ssize_t x ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } for ( i = 0 ; i < ( image -> matte != MagickFalse ? 5 : 4 ) ; i ++ ) { quantum_type = quantum_types [ i ] ; q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , quantum_type , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const PixelPacket * ) NULL ) || ( q == ( PixelPacket * ) NULL ) ) break ; canvas_indexes = GetVirtualIndexQueue ( canvas_image ) ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { switch ( quantum_type ) { case CyanQuantum : { SetPixelCyan ( q , GetPixelCyan ( p ) ) ; break ; } case MagentaQuantum : { SetPixelMagenta ( q , GetPixelMagenta ( p ) ) ; break ; } case YellowQuantum : { SetPixelYellow ( q , GetPixelYellow ( p ) ) ; break ; } case BlackQuantum : { SetPixelIndex ( indexes + x , GetPixelIndex ( canvas_indexes + image -> extract_info . x + x ) ) ; break ; } case OpacityQuantum : { SetPixelOpacity ( q , GetPixelOpacity ( p ) ) ; break ; } default : break ; } p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } count = ReadBlob ( image , length , pixels ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case PlaneInterlace : { if ( scene == 0 ) { length = GetQuantumExtent ( canvas_image , quantum_info , CyanQuantum ) ; count = ReadBlob ( image , length , pixels ) ; } for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { register const PixelPacket * restrict p ; register PixelPacket * restrict q ; register ssize_t x ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , CyanQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const PixelPacket * ) NULL ) || ( q == ( PixelPacket * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , GetPixelRed ( p ) ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } count = ReadBlob ( image , length , pixels ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 1 , 6 ) ; if ( status == MagickFalse ) break ; } for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { register const PixelPacket * restrict p ; register PixelPacket * restrict q ; register ssize_t x ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , MagentaQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const PixelPacket * ) NULL ) || ( q == ( PixelPacket * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelGreen ( q , GetPixelGreen ( p ) ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } count = ReadBlob ( image , length , pixels ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 2 , 6 ) ; if ( status == MagickFalse ) break ; } for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { register const PixelPacket * restrict p ; register PixelPacket * restrict q ; register ssize_t x ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , YellowQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const PixelPacket * ) NULL ) || ( q == ( PixelPacket * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelBlue ( q , GetPixelBlue ( p ) ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } count = ReadBlob ( image , length , pixels ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 3 , 6 ) ; if ( status == MagickFalse ) break ; } for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { register const IndexPacket * restrict canvas_indexes ; register const PixelPacket * restrict p ; register IndexPacket * restrict indexes ; register PixelPacket * restrict q ; register ssize_t x ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , BlackQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const PixelPacket * ) NULL ) || ( q == ( PixelPacket * ) NULL ) ) break ; canvas_indexes = GetVirtualIndexQueue ( canvas_image ) ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( indexes + x , GetPixelIndex ( canvas_indexes + image -> extract_info . x + x ) ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } count = ReadBlob ( image , length , pixels ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 4 , 6 ) ; if ( status == MagickFalse ) break ; } if ( image -> matte != MagickFalse ) { for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { register const PixelPacket * restrict p ; register PixelPacket * restrict q ; register ssize_t x ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , AlphaQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const PixelPacket * ) NULL ) || ( q == ( PixelPacket * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelOpacity ( q , GetPixelOpacity ( p ) ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } count = ReadBlob ( image , length , pixels ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 5 , 6 ) ; if ( status == MagickFalse ) break ; } } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 6 , 6 ) ; if ( status == MagickFalse ) break ; } break ; } case PartitionInterlace : { AppendImageFormat ( ""C"" , image -> filename ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { canvas_image = DestroyImageList ( canvas_image ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( DiscardBlobBytes ( image , image -> offset ) == MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; length = GetQuantumExtent ( canvas_image , quantum_info , CyanQuantum ) ; for ( i = 0 ; i < ( ssize_t ) scene ; i ++ ) for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) if ( ReadBlob ( image , length , pixels ) != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } count = ReadBlob ( image , length , pixels ) ; for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { register const PixelPacket * restrict p ; register PixelPacket * restrict q ; register ssize_t x ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , CyanQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const PixelPacket * ) NULL ) || ( q == ( PixelPacket * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , GetPixelRed ( p ) ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } count = ReadBlob ( image , length , pixels ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 1 , 5 ) ; if ( status == MagickFalse ) break ; } ( void ) CloseBlob ( image ) ; AppendImageFormat ( ""M"" , image -> filename ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { canvas_image = DestroyImageList ( canvas_image ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } length = GetQuantumExtent ( canvas_image , quantum_info , MagentaQuantum ) ; for ( i = 0 ; i < ( ssize_t ) scene ; i ++ ) for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) if ( ReadBlob ( image , length , pixels ) != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } count = ReadBlob ( image , length , pixels ) ; for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { register const PixelPacket * restrict p ; register PixelPacket * restrict q ; register ssize_t x ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , MagentaQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const PixelPacket * ) NULL ) || ( q == ( PixelPacket * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelGreen ( q , GetPixelGreen ( p ) ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } count = ReadBlob ( image , length , pixels ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 2 , 5 ) ; if ( status == MagickFalse ) break ; } ( void ) CloseBlob ( image ) ; AppendImageFormat ( ""Y"" , image -> filename ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { canvas_image = DestroyImageList ( canvas_image ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } length = GetQuantumExtent ( canvas_image , quantum_info , YellowQuantum ) ; for ( i = 0 ; i < ( ssize_t ) scene ; i ++ ) for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) if ( ReadBlob ( image , length , pixels ) != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } count = ReadBlob ( image , length , pixels ) ; for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { register const PixelPacket * restrict p ; register PixelPacket * restrict q ; register ssize_t x ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , YellowQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const PixelPacket * ) NULL ) || ( q == ( PixelPacket * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelBlue ( q , GetPixelBlue ( p ) ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } count = ReadBlob ( image , length , pixels ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 3 , 5 ) ; if ( status == MagickFalse ) break ; } ( void ) CloseBlob ( image ) ; AppendImageFormat ( ""K"" , image -> filename ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { canvas_image = DestroyImageList ( canvas_image ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } length = GetQuantumExtent ( canvas_image , quantum_info , BlackQuantum ) ; for ( i = 0 ; i < ( ssize_t ) scene ; i ++ ) for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) if ( ReadBlob ( image , length , pixels ) != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } count = ReadBlob ( image , length , pixels ) ; for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { register const IndexPacket * restrict canvas_indexes ; register const PixelPacket * restrict p ; register IndexPacket * restrict indexes ; register PixelPacket * restrict q ; register ssize_t x ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , BlackQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const PixelPacket * ) NULL ) || ( q == ( PixelPacket * ) NULL ) ) break ; canvas_indexes = GetVirtualIndexQueue ( canvas_image ) ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( indexes + x , GetPixelIndex ( canvas_indexes + image -> extract_info . x + x ) ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } count = ReadBlob ( image , length , pixels ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 3 , 5 ) ; if ( status == MagickFalse ) break ; } if ( image -> matte != MagickFalse ) { ( void ) CloseBlob ( image ) ; AppendImageFormat ( ""A"" , image -> filename ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { canvas_image = DestroyImageList ( canvas_image ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } length = GetQuantumExtent ( canvas_image , quantum_info , AlphaQuantum ) ; for ( i = 0 ; i < ( ssize_t ) scene ; i ++ ) for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) if ( ReadBlob ( image , length , pixels ) != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } count = ReadBlob ( image , length , pixels ) ; for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { register const PixelPacket * restrict p ; register PixelPacket * restrict q ; register ssize_t x ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , YellowQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const PixelPacket * ) NULL ) || ( q == ( PixelPacket * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelOpacity ( q , GetPixelOpacity ( p ) ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } count = ReadBlob ( image , length , pixels ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 4 , 5 ) ; if ( status == MagickFalse ) break ; } } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 5 , 5 ) ; if ( status == MagickFalse ) break ; } break ; } } SetQuantumImageType ( image , quantum_type ) ; if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( count == ( ssize_t ) length ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } scene ++ ; } while ( count == ( ssize_t ) length ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ; InheritException ( & image -> exception , & canvas_image -> exception ) ; canvas_image = DestroyImage ( canvas_image ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","status = SetImageExtent ( image , image -> columns , image -> rows ) ;if ( status == MagickFalse ) {InheritException ( exception , & image -> exception ) ;return ( DestroyImageList ( image ) ) ;}if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;SetImageColorspace ( image , CMYKColorspace ) ;",477
641,"buggy line: long rem ;value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & rem ) ;value -> tv_usec = rem / NSEC_PER_USEC ;cwe id:CWE-189context: static inline void jiffies_to_compat_timeval ( unsigned long jiffies , struct compat_timeval * value ) { u64 nsec = ( u64 ) jiffies * TICK_NSEC ;  long rem ;   value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & rem ) ;  value -> tv_usec = rem / NSEC_PER_USEC ; }","u32 rem ;value -> tv_sec = div_u64_rem ( nsec , NSEC_PER_SEC , & rem ) ;value -> tv_usec = rem / NSEC_PER_USEC ;",478
642,"buggy line: if ( ! ctx || ( ! data && data_sz ) )  res = VPX_CODEC_INVALID_PARAM ;res = ctx -> iface -> dec . decode ( ctx -> priv -> alg_priv , data , data_sz ,  user_priv , deadline ) ;cwe id:CWE-119context: vpx_codec_err_t vpx_codec_decode ( vpx_codec_ctx_t * ctx , const uint8_t * data , unsigned int data_sz , void * user_priv , long deadline ) { vpx_codec_err_t res ;  if ( ! ctx || ( ! data && data_sz ) )  res = VPX_CODEC_INVALID_PARAM ; else if ( ! ctx -> iface || ! ctx -> priv ) res = VPX_CODEC_ERROR ; else {  res = ctx -> iface -> dec . decode ( ctx -> priv -> alg_priv , data , data_sz ,  user_priv , deadline ) ; } return SAVE_STATUS ( ctx , res ) ; }","if ( ! ctx || ( ! data && data_sz ) || ( data && ! data_sz ) ) res = VPX_CODEC_INVALID_PARAM ;res = ctx -> iface -> dec . decode ( get_alg_priv ( ctx ) , data , data_sz , user_priv , deadline ) ;",479
643,"buggy line: if ( ! strcmp ( attr , ""packetization-mode"" ) ) {cwe id:CWE-119context: static int sdp_parse_fmtp_config_h264 ( AVFormatContext * s , AVStream * stream , PayloadContext * h264_data , const char * attr , const char * value ) { AVCodecParameters * par = stream -> codecpar ; if ( ! strcmp ( attr , ""packetization-mode"" ) ) { av_log ( s , AV_LOG_DEBUG , ""RTP<S2SV_blank>Packetization<S2SV_blank>Mode:<S2SV_blank>%d\\n"" , atoi ( value ) ) ; h264_data -> packetization_mode = atoi ( value ) ; if ( h264_data -> packetization_mode > 1 ) av_log ( s , AV_LOG_ERROR , ""Interleaved<S2SV_blank>RTP<S2SV_blank>mode<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>yet.\\n"" ) ; } else if ( ! strcmp ( attr , ""profile-level-id"" ) ) { if ( strlen ( value ) == 6 ) parse_profile_level_id ( s , h264_data , value ) ; } else if ( ! strcmp ( attr , ""sprop-parameter-sets"" ) ) { int ret ;  if ( value [ strlen ( value ) - 1 ] == ',' ) {  av_log ( s , AV_LOG_WARNING , ""Missing<S2SV_blank>PPS<S2SV_blank>in<S2SV_blank>sprop-parameter-sets,<S2SV_blank>ignoring\\n"" ) ; return 0 ; } par -> extradata_size = 0 ; av_freep ( & par -> extradata ) ; ret = ff_h264_parse_sprop_parameter_sets ( s , & par -> extradata , & par -> extradata_size , value ) ; av_log ( s , AV_LOG_DEBUG , ""Extradata<S2SV_blank>set<S2SV_blank>to<S2SV_blank>%p<S2SV_blank>(size:<S2SV_blank>%d)\\n"" , par -> extradata , par -> extradata_size ) ; return ret ; } return 0 ; }","if ( * value == 0 || ! strcmp ( attr , ""packetization-mode"" ) ) {",480
644,"buggy line: if ( value [ strlen ( value ) - 1 ] == \',\' ) {av_log ( s , AV_LOG_WARNING , ""Missing<S2SV_blank>PPS<S2SV_blank>in<S2SV_blank>sprop-parameter-sets,<S2SV_blank>ignoring\\\cwe id:CWE-119context: static int sdp_parse_fmtp_config_h264 ( AVFormatContext * s , AVStream * stream , PayloadContext * h264_data , const char * attr , const char * value ) { AVCodecParameters * par = stream -> codecpar ; if ( ! strcmp ( attr , ""packetization-mode"" ) ) { av_log ( s , AV_LOG_DEBUG , ""RTP<S2SV_blank>Packetization<S2SV_blank>Mode:<S2SV_blank>%d\\n"" , atoi ( value ) ) ; h264_data -> packetization_mode = atoi ( value ) ; if ( h264_data -> packetization_mode > 1 ) av_log ( s , AV_LOG_ERROR , ""Interleaved<S2SV_blank>RTP<S2SV_blank>mode<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>yet.\\n"" ) ; } else if ( ! strcmp ( attr , ""profile-level-id"" ) ) { if ( strlen ( value ) == 6 ) parse_profile_level_id ( s , h264_data , value ) ; } else if ( ! strcmp ( attr , ""sprop-parameter-sets"" ) ) { int ret ;  if ( value [ strlen ( value ) - 1 ] == ',' ) {  av_log ( s , AV_LOG_WARNING , ""Missing<S2SV_blank>PPS<S2SV_blank>in<S2SV_blank>sprop-parameter-sets,<S2SV_blank>ignoring\\n"" ) ; return 0 ; } par -> extradata_size = 0 ; av_freep ( & par -> extradata ) ; ret = ff_h264_parse_sprop_parameter_sets ( s , & par -> extradata , & par -> extradata_size , value ) ; av_log ( s , AV_LOG_DEBUG , ""Extradata<S2SV_blank>set<S2SV_blank>to<S2SV_blank>%p<S2SV_blank>(size:<S2SV_blank>%d)\\n"" , par -> extradata , par -> extradata_size ) ; return ret ; } return 0 ; }","if ( value [ strlen ( value ) - 1 ] == \',\' ) {av_log ( s , AV_LOG_WARNING , ""Missing<S2SV_blank>PPS<S2SV_blank>in<S2SV_blank>sprop-parameter-sets,<S2SV_blank>ignoring\\\",480
645,"buggy line: static int isofs_read_inode ( struct inode * inode )  {cwe id:CWE-20context:  static int isofs_read_inode ( struct inode * inode )  { struct super_block * sb = inode -> i_sb ; struct isofs_sb_info * sbi = ISOFS_SB ( sb ) ; unsigned long bufsize = ISOFS_BUFFER_SIZE ( inode ) ; unsigned long block ; int high_sierra = sbi -> s_high_sierra ; struct buffer_head * bh = NULL ; struct iso_directory_record * de ; struct iso_directory_record * tmpde = NULL ; unsigned int de_len ; unsigned long offset ; struct iso_inode_info * ei = ISOFS_I ( inode ) ; int ret = - EIO ; block = ei -> i_iget5_block ; bh = sb_bread ( inode -> i_sb , block ) ; if ( ! bh ) goto out_badread ; offset = ei -> i_iget5_offset ; de = ( struct iso_directory_record * ) ( bh -> b_data + offset ) ; de_len = * ( unsigned char * ) de ; if ( offset + de_len > bufsize ) { int frag1 = bufsize - offset ; tmpde = kmalloc ( de_len , GFP_KERNEL ) ; if ( tmpde == NULL ) { printk ( KERN_INFO ""%s:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory\\n"" , __func__ ) ; ret = - ENOMEM ; goto fail ; } memcpy ( tmpde , bh -> b_data + offset , frag1 ) ; brelse ( bh ) ; bh = sb_bread ( inode -> i_sb , ++ block ) ; if ( ! bh ) goto out_badread ; memcpy ( ( char * ) tmpde + frag1 , bh -> b_data , de_len - frag1 ) ; de = tmpde ; } inode -> i_ino = isofs_get_ino ( ei -> i_iget5_block , ei -> i_iget5_offset , ISOFS_BUFFER_BITS ( inode ) ) ; ei -> i_file_format = isofs_file_normal ; if ( de -> flags [ - high_sierra ] & 2 ) { if ( sbi -> s_dmode != ISOFS_INVALID_MODE ) inode -> i_mode = S_IFDIR | sbi -> s_dmode ; else inode -> i_mode = S_IFDIR | S_IRUGO | S_IXUGO ; set_nlink ( inode , 1 ) ; } else { if ( sbi -> s_fmode != ISOFS_INVALID_MODE ) { inode -> i_mode = S_IFREG | sbi -> s_fmode ; } else { inode -> i_mode = S_IFREG | S_IRUGO | S_IXUGO ; } set_nlink ( inode , 1 ) ; } inode -> i_uid = sbi -> s_uid ; inode -> i_gid = sbi -> s_gid ; inode -> i_blocks = 0 ; ei -> i_format_parm [ 0 ] = 0 ; ei -> i_format_parm [ 1 ] = 0 ; ei -> i_format_parm [ 2 ] = 0 ; ei -> i_section_size = isonum_733 ( de -> size ) ; if ( de -> flags [ - high_sierra ] & 0x80 ) { ret = isofs_read_level3_size ( inode ) ; if ( ret < 0 ) goto fail ; ret = - EIO ; } else { ei -> i_next_section_block = 0 ; ei -> i_next_section_offset = 0 ; inode -> i_size = isonum_733 ( de -> size ) ; } if ( sbi -> s_cruft ) inode -> i_size &= 0x00ffffff ; if ( de -> interleave [ 0 ] ) { printk ( KERN_DEBUG ""ISOFS:<S2SV_blank>Interleaved<S2SV_blank>files<S2SV_blank>not<S2SV_blank>(yet)<S2SV_blank>supported.\\n"" ) ; inode -> i_size = 0 ; } if ( de -> file_unit_size [ 0 ] != 0 ) { printk ( KERN_DEBUG ""ISOFS:<S2SV_blank>File<S2SV_blank>unit<S2SV_blank>size<S2SV_blank>!=<S2SV_blank>0<S2SV_blank>for<S2SV_blank>ISO<S2SV_blank>file<S2SV_blank>(%ld).\\n"" , inode -> i_ino ) ; } # ifdef DEBUG if ( ( de -> flags [ - high_sierra ] & ~ 2 ) != 0 ) { printk ( KERN_DEBUG ""ISOFS:<S2SV_blank>Unusual<S2SV_blank>flag<S2SV_blank>settings<S2SV_blank>for<S2SV_blank>ISO<S2SV_blank>file<S2SV_blank>"" ""(%ld<S2SV_blank>%x).\\n"" , inode -> i_ino , de -> flags [ - high_sierra ] ) ; } # endif inode -> i_mtime . tv_sec = inode -> i_atime . tv_sec = inode -> i_ctime . tv_sec = iso_date ( de -> date , high_sierra ) ; inode -> i_mtime . tv_nsec = inode -> i_atime . tv_nsec = inode -> i_ctime . tv_nsec = 0 ; ei -> i_first_extent = ( isonum_733 ( de -> extent ) + isonum_711 ( de -> ext_attr_length ) ) ; inode -> i_blocks = ( inode -> i_size + 511 ) >> 9 ; if ( ! high_sierra ) {  parse_rock_ridge_inode ( de , inode ) ;  if ( sbi -> s_uid_set ) inode -> i_uid = sbi -> s_uid ; if ( sbi -> s_gid_set ) inode -> i_gid = sbi -> s_gid ; } if ( S_ISDIR ( inode -> i_mode ) && sbi -> s_overriderockperm && sbi -> s_dmode != ISOFS_INVALID_MODE ) inode -> i_mode = S_IFDIR | sbi -> s_dmode ; if ( S_ISREG ( inode -> i_mode ) && sbi -> s_overriderockperm && sbi -> s_fmode != ISOFS_INVALID_MODE ) inode -> i_mode = S_IFREG | sbi -> s_fmode ; if ( S_ISREG ( inode -> i_mode ) ) { inode -> i_fop = & generic_ro_fops ; switch ( ei -> i_file_format ) { # ifdef CONFIG_ZISOFS case isofs_file_compressed : inode -> i_data . a_ops = & zisofs_aops ; break ; # endif default : inode -> i_data . a_ops = & isofs_aops ; break ; } } else if ( S_ISDIR ( inode -> i_mode ) ) { inode -> i_op = & isofs_dir_inode_operations ; inode -> i_fop = & isofs_dir_operations ; } else if ( S_ISLNK ( inode -> i_mode ) ) { inode -> i_op = & page_symlink_inode_operations ; inode -> i_data . a_ops = & isofs_symlink_aops ; } else init_special_inode ( inode , inode -> i_mode , inode -> i_rdev ) ; ret = 0 ; out : kfree ( tmpde ) ; if ( bh ) brelse ( bh ) ; return ret ; out_badread : printk ( KERN_WARNING ""ISOFS:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>i-node<S2SV_blank>block\\n"" ) ; fail : goto out ; }","static int isofs_read_inode ( struct inode * inode , int relocated ) {",481
646,"buggy line: parse_rock_ridge_inode ( de , inode ) ;if ( sbi -> s_uid_set ) inode -> i_uid = sbi -> s_uid ;cwe id:CWE-20context:  static int isofs_read_inode ( struct inode * inode )  { struct super_block * sb = inode -> i_sb ; struct isofs_sb_info * sbi = ISOFS_SB ( sb ) ; unsigned long bufsize = ISOFS_BUFFER_SIZE ( inode ) ; unsigned long block ; int high_sierra = sbi -> s_high_sierra ; struct buffer_head * bh = NULL ; struct iso_directory_record * de ; struct iso_directory_record * tmpde = NULL ; unsigned int de_len ; unsigned long offset ; struct iso_inode_info * ei = ISOFS_I ( inode ) ; int ret = - EIO ; block = ei -> i_iget5_block ; bh = sb_bread ( inode -> i_sb , block ) ; if ( ! bh ) goto out_badread ; offset = ei -> i_iget5_offset ; de = ( struct iso_directory_record * ) ( bh -> b_data + offset ) ; de_len = * ( unsigned char * ) de ; if ( offset + de_len > bufsize ) { int frag1 = bufsize - offset ; tmpde = kmalloc ( de_len , GFP_KERNEL ) ; if ( tmpde == NULL ) { printk ( KERN_INFO ""%s:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory\\n"" , __func__ ) ; ret = - ENOMEM ; goto fail ; } memcpy ( tmpde , bh -> b_data + offset , frag1 ) ; brelse ( bh ) ; bh = sb_bread ( inode -> i_sb , ++ block ) ; if ( ! bh ) goto out_badread ; memcpy ( ( char * ) tmpde + frag1 , bh -> b_data , de_len - frag1 ) ; de = tmpde ; } inode -> i_ino = isofs_get_ino ( ei -> i_iget5_block , ei -> i_iget5_offset , ISOFS_BUFFER_BITS ( inode ) ) ; ei -> i_file_format = isofs_file_normal ; if ( de -> flags [ - high_sierra ] & 2 ) { if ( sbi -> s_dmode != ISOFS_INVALID_MODE ) inode -> i_mode = S_IFDIR | sbi -> s_dmode ; else inode -> i_mode = S_IFDIR | S_IRUGO | S_IXUGO ; set_nlink ( inode , 1 ) ; } else { if ( sbi -> s_fmode != ISOFS_INVALID_MODE ) { inode -> i_mode = S_IFREG | sbi -> s_fmode ; } else { inode -> i_mode = S_IFREG | S_IRUGO | S_IXUGO ; } set_nlink ( inode , 1 ) ; } inode -> i_uid = sbi -> s_uid ; inode -> i_gid = sbi -> s_gid ; inode -> i_blocks = 0 ; ei -> i_format_parm [ 0 ] = 0 ; ei -> i_format_parm [ 1 ] = 0 ; ei -> i_format_parm [ 2 ] = 0 ; ei -> i_section_size = isonum_733 ( de -> size ) ; if ( de -> flags [ - high_sierra ] & 0x80 ) { ret = isofs_read_level3_size ( inode ) ; if ( ret < 0 ) goto fail ; ret = - EIO ; } else { ei -> i_next_section_block = 0 ; ei -> i_next_section_offset = 0 ; inode -> i_size = isonum_733 ( de -> size ) ; } if ( sbi -> s_cruft ) inode -> i_size &= 0x00ffffff ; if ( de -> interleave [ 0 ] ) { printk ( KERN_DEBUG ""ISOFS:<S2SV_blank>Interleaved<S2SV_blank>files<S2SV_blank>not<S2SV_blank>(yet)<S2SV_blank>supported.\\n"" ) ; inode -> i_size = 0 ; } if ( de -> file_unit_size [ 0 ] != 0 ) { printk ( KERN_DEBUG ""ISOFS:<S2SV_blank>File<S2SV_blank>unit<S2SV_blank>size<S2SV_blank>!=<S2SV_blank>0<S2SV_blank>for<S2SV_blank>ISO<S2SV_blank>file<S2SV_blank>(%ld).\\n"" , inode -> i_ino ) ; } # ifdef DEBUG if ( ( de -> flags [ - high_sierra ] & ~ 2 ) != 0 ) { printk ( KERN_DEBUG ""ISOFS:<S2SV_blank>Unusual<S2SV_blank>flag<S2SV_blank>settings<S2SV_blank>for<S2SV_blank>ISO<S2SV_blank>file<S2SV_blank>"" ""(%ld<S2SV_blank>%x).\\n"" , inode -> i_ino , de -> flags [ - high_sierra ] ) ; } # endif inode -> i_mtime . tv_sec = inode -> i_atime . tv_sec = inode -> i_ctime . tv_sec = iso_date ( de -> date , high_sierra ) ; inode -> i_mtime . tv_nsec = inode -> i_atime . tv_nsec = inode -> i_ctime . tv_nsec = 0 ; ei -> i_first_extent = ( isonum_733 ( de -> extent ) + isonum_711 ( de -> ext_attr_length ) ) ; inode -> i_blocks = ( inode -> i_size + 511 ) >> 9 ; if ( ! high_sierra ) {  parse_rock_ridge_inode ( de , inode ) ;  if ( sbi -> s_uid_set ) inode -> i_uid = sbi -> s_uid ; if ( sbi -> s_gid_set ) inode -> i_gid = sbi -> s_gid ; } if ( S_ISDIR ( inode -> i_mode ) && sbi -> s_overriderockperm && sbi -> s_dmode != ISOFS_INVALID_MODE ) inode -> i_mode = S_IFDIR | sbi -> s_dmode ; if ( S_ISREG ( inode -> i_mode ) && sbi -> s_overriderockperm && sbi -> s_fmode != ISOFS_INVALID_MODE ) inode -> i_mode = S_IFREG | sbi -> s_fmode ; if ( S_ISREG ( inode -> i_mode ) ) { inode -> i_fop = & generic_ro_fops ; switch ( ei -> i_file_format ) { # ifdef CONFIG_ZISOFS case isofs_file_compressed : inode -> i_data . a_ops = & zisofs_aops ; break ; # endif default : inode -> i_data . a_ops = & isofs_aops ; break ; } } else if ( S_ISDIR ( inode -> i_mode ) ) { inode -> i_op = & isofs_dir_inode_operations ; inode -> i_fop = & isofs_dir_operations ; } else if ( S_ISLNK ( inode -> i_mode ) ) { inode -> i_op = & page_symlink_inode_operations ; inode -> i_data . a_ops = & isofs_symlink_aops ; } else init_special_inode ( inode , inode -> i_mode , inode -> i_rdev ) ; ret = 0 ; out : kfree ( tmpde ) ; if ( bh ) brelse ( bh ) ; return ret ; out_badread : printk ( KERN_WARNING ""ISOFS:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>i-node<S2SV_blank>block\\n"" ) ; fail : goto out ; }","parse_rock_ridge_inode ( de , inode , relocated ) ;if ( sbi -> s_uid_set ) inode -> i_uid = sbi -> s_uid ;",481
647,"buggy line: COM_DefaultExtension ( filename , sizeof ( filename ) , "".txt"" ) ;f = FS_FOpenFileWrite ( filename ) ;cwe id:CWE-000context: void Con_Dump_f ( void ) { int l , x , i ; short * line ; fileHandle_t f ; int bufferlen ; char * buffer ; char filename [ MAX_QPATH ] ; if ( Cmd_Argc ( ) != 2 ) { Com_Printf ( ""usage:<S2SV_blank>condump<S2SV_blank><filename>\\n"" ) ; return ; } Q_strncpyz ( filename , Cmd_Argv ( 1 ) , sizeof ( filename ) ) ;  COM_DefaultExtension ( filename , sizeof ( filename ) , "".txt"" ) ;  f = FS_FOpenFileWrite ( filename ) ; if ( ! f ) { Com_Printf ( ""ERROR:<S2SV_blank>couldn\'t<S2SV_blank>open<S2SV_blank>%s.\\n"" , filename ) ; return ; } Com_Printf ( ""Dumped<S2SV_blank>console<S2SV_blank>text<S2SV_blank>to<S2SV_blank>%s.\\n"" , filename ) ; for ( l = con . current - con . totallines + 1 ; l <= con . current ; l ++ ) { line = con . text + ( l % con . totallines ) * con . linewidth ; for ( x = 0 ; x < con . linewidth ; x ++ ) if ( ( line [ x ] & 0xff ) != '<S2SV_blank>' ) { break ; } if ( x != con . linewidth ) { break ; } } # ifdef _WIN32 bufferlen = con . linewidth + 3 * sizeof ( char ) ; # else bufferlen = con . linewidth + 2 * sizeof ( char ) ; # endif buffer = Hunk_AllocateTempMemory ( bufferlen ) ; buffer [ bufferlen - 1 ] = 0 ; for ( ; l <= con . current ; l ++ ) { line = con . text + ( l % con . totallines ) * con . linewidth ; for ( i = 0 ; i < con . linewidth ; i ++ ) buffer [ i ] = line [ i ] & 0xff ; for ( x = con . linewidth - 1 ; x >= 0 ; x -- ) { if ( buffer [ x ] == '<S2SV_blank>' ) { buffer [ x ] = 0 ; } else { break ; } } # ifdef _WIN32 Q_strcat ( buffer , bufferlen , ""\\r\\n"" ) ; # else Q_strcat ( buffer , bufferlen , ""\\n"" ) ; # endif FS_Write ( buffer , strlen ( buffer ) , f ) ; } Hunk_FreeTempMemory ( buffer ) ; FS_FCloseFile ( f ) ; }","COM_DefaultExtension ( filename , sizeof ( filename ) , "".txt"" ) ;if ( ! COM_CompareExtension ( filename , "".txt"" ) ) {Com_Printf ( ""Con_Dump_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\\\"".txt\\\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\\return ;}f = FS_FOpenFileWrite ( filename ) ;",482
648,"buggy line: if ( ! ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""ES-IS"" ) ) ;if ( length <= 2 ) {ND_PRINT ( ( ndo , ndo -> ndo_qflag ? ""bad<S2SV_blank>pkt!"" : ""no<S2SV_blank>header<S2SV_blank>at<S2SV_blank>all!"" ) ) ;return ;}esis_header = ( const struct esis_header_t * ) pptr ;ND_TCHECK ( * esis_header ) ;li = esis_header -> length_indicator ;optr = pptr ;if ( esis_header -> nlpid != NLPID_ESIS ) {ND_PRINT ( ( ndo , ""<S2SV_blank>nlpid<S2SV_blank>0x%02x<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" , esis_header -> nlpid ) ) ;return ;}if ( esis_header -> version != ESIS_VERSION ) {ND_PRINT ( ( ndo , ""<S2SV_blank>version<S2SV_blank>%d<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" , esis_header -> version ) ) ;return ;}if ( li > length ) {ND_PRINT ( ( ndo , ""<S2SV_blank>length<S2SV_blank>indicator(%u)<S2SV_blank>><S2SV_blank>PDU<S2SV_blank>size<S2SV_blank>(%u)!"" , li , length ) ) ;return ;}if ( li < sizeof ( struct esis_header_t ) + 2 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>length<S2SV_blank>indicator<S2SV_blank>%u<S2SV_blank><<S2SV_blank>min<S2SV_blank>PDU<S2SV_blank>size:"" , li ) ) ;while ( pptr < ndo -> ndo_snapend ) ND_PRINT ( ( ndo , ""%02X"" , * pptr ++ ) ) ;return ;}esis_pdu_type = esis_header -> type & ESIS_PDU_TYPE_MASK ;if ( ndo -> ndo_vflag < 1 ) {ND_PRINT ( ( ndo , ""%s%s,<S2SV_blank>length<S2SV_blank>%u"" , ndo -> ndo_eflag ? """" : "",<S2SV_blank>"" , tok2str ( esis_pdu_values , ""unknown<S2SV_blank>type<S2SV_blank>(%u)"" , esis_pdu_type ) , length ) ) ;return ;}else ND_PRINT ( ( ndo , ""%slength<S2SV_blank>%u\\\ND_PRINT ( ( ndo , "",<S2SV_blank>v:<S2SV_blank>%u%s"" , esis_header -> version , esis_header -> version == ESIS_VERSION ? """" : ""unsupported"" ) ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>checksum:<S2SV_blank>0x%04x"" , EXTRACT_16BITS ( esis_header -> cksum ) ) ) ;osi_print_cksum ( ndo , pptr , EXTRACT_16BITS ( esis_header -> cksum ) , 7 , li ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>holding<S2SV_blank>time:<S2SV_blank>%us,<S2SV_blank>length<S2SV_blank>indicator:<S2SV_blank>%u"" , EXTRACT_16BITS ( esis_header -> holdtime ) , li ) ) ;if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , optr , ""\\\pptr += sizeof ( struct esis_header_t ) ;li -= sizeof ( struct esis_header_t ) ;switch ( esis_pdu_type ) {case ESIS_PDU_REDIRECT : {const uint8_t * dst , * snpa , * neta ;u_int dstl , snpal , netal ;ND_TCHECK ( * pptr ) ;if ( li < 1 ) {ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ;return ;}dstl = * pptr ;pptr ++ ;li -- ;ND_TCHECK2 ( * pptr , dstl ) ;if ( li < dstl ) {ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ;return ;}dst = pptr ;pptr += dstl ;li -= dstl ;ND_PRINT ( ( ndo , ""\\\ND_TCHECK ( * pptr ) ;if ( li < 1 ) {ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ;return ;}snpal = * pptr ;pptr ++ ;li -- ;ND_TCHECK2 ( * pptr , snpal ) ;if ( li < snpal ) {ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ;return ;}snpa = pptr ;pptr += snpal ;li -= snpal ;ND_TCHECK ( * pptr ) ;if ( li < 1 ) {ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ;return ;}netal = * pptr ;pptr ++ ;ND_TCHECK2 ( * pptr , netal ) ;if ( li < netal ) {ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ;return ;}neta = pptr ;pptr += netal ;li -= netal ;if ( netal == 0 )   ND_PRINT ( ( ndo , ""\\\else ND_PRINT ( ( ndo , ""\\\cwe id:CWE-125context: static void esis_print ( netdissect_options * ndo , const uint8_t * pptr , u_int length ) { const uint8_t * optr ; u_int li , esis_pdu_type , source_address_length , source_address_number ; const struct esis_header_t * esis_header ; if ( ! ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""ES-IS"" ) ) ; if ( length <= 2 ) { ND_PRINT ( ( ndo , ndo -> ndo_qflag ? ""bad<S2SV_blank>pkt!"" : ""no<S2SV_blank>header<S2SV_blank>at<S2SV_blank>all!"" ) ) ; return ; } esis_header = ( const struct esis_header_t * ) pptr ; ND_TCHECK ( * esis_header ) ; li = esis_header -> length_indicator ; optr = pptr ; if ( esis_header -> nlpid != NLPID_ESIS ) { ND_PRINT ( ( ndo , ""<S2SV_blank>nlpid<S2SV_blank>0x%02x<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" , esis_header -> nlpid ) ) ; return ; } if ( esis_header -> version != ESIS_VERSION ) { ND_PRINT ( ( ndo , ""<S2SV_blank>version<S2SV_blank>%d<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" , esis_header -> version ) ) ; return ; } if ( li > length ) { ND_PRINT ( ( ndo , ""<S2SV_blank>length<S2SV_blank>indicator(%u)<S2SV_blank>><S2SV_blank>PDU<S2SV_blank>size<S2SV_blank>(%u)!"" , li , length ) ) ; return ; } if ( li < sizeof ( struct esis_header_t ) + 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>length<S2SV_blank>indicator<S2SV_blank>%u<S2SV_blank><<S2SV_blank>min<S2SV_blank>PDU<S2SV_blank>size:"" , li ) ) ; while ( pptr < ndo -> ndo_snapend ) ND_PRINT ( ( ndo , ""%02X"" , * pptr ++ ) ) ; return ; } esis_pdu_type = esis_header -> type & ESIS_PDU_TYPE_MASK ; if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , ""%s%s,<S2SV_blank>length<S2SV_blank>%u"" , ndo -> ndo_eflag ? """" : "",<S2SV_blank>"" , tok2str ( esis_pdu_values , ""unknown<S2SV_blank>type<S2SV_blank>(%u)"" , esis_pdu_type ) , length ) ) ; return ; } else ND_PRINT ( ( ndo , ""%slength<S2SV_blank>%u\\n\\t%s<S2SV_blank>(%u)"" , ndo -> ndo_eflag ? """" : "",<S2SV_blank>"" , length , tok2str ( esis_pdu_values , ""unknown<S2SV_blank>type:<S2SV_blank>%u"" , esis_pdu_type ) , esis_pdu_type ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>v:<S2SV_blank>%u%s"" , esis_header -> version , esis_header -> version == ESIS_VERSION ? """" : ""unsupported"" ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>checksum:<S2SV_blank>0x%04x"" , EXTRACT_16BITS ( esis_header -> cksum ) ) ) ; osi_print_cksum ( ndo , pptr , EXTRACT_16BITS ( esis_header -> cksum ) , 7 , li ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>holding<S2SV_blank>time:<S2SV_blank>%us,<S2SV_blank>length<S2SV_blank>indicator:<S2SV_blank>%u"" , EXTRACT_16BITS ( esis_header -> holdtime ) , li ) ) ; if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , optr , ""\\n\\t"" , sizeof ( struct esis_header_t ) ) ; pptr += sizeof ( struct esis_header_t ) ; li -= sizeof ( struct esis_header_t ) ; switch ( esis_pdu_type ) { case ESIS_PDU_REDIRECT : { const uint8_t * dst , * snpa , * neta ; u_int dstl , snpal , netal ; ND_TCHECK ( * pptr ) ; if ( li < 1 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ; return ; } dstl = * pptr ; pptr ++ ; li -- ; ND_TCHECK2 ( * pptr , dstl ) ; if ( li < dstl ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ; return ; } dst = pptr ; pptr += dstl ; li -= dstl ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s"" , isonsap_string ( ndo , dst , dstl ) ) ) ; ND_TCHECK ( * pptr ) ; if ( li < 1 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ; return ; } snpal = * pptr ; pptr ++ ; li -- ; ND_TCHECK2 ( * pptr , snpal ) ; if ( li < snpal ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ; return ; } snpa = pptr ; pptr += snpal ; li -= snpal ; ND_TCHECK ( * pptr ) ; if ( li < 1 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ; return ; } netal = * pptr ; pptr ++ ; ND_TCHECK2 ( * pptr , netal ) ; if ( li < netal ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ; return ; } neta = pptr ; pptr += netal ; li -= netal ;  if ( netal == 0 )   ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s"" , etheraddr_string ( ndo , snpa ) ) ) ;  else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s"" , isonsap_string ( ndo , neta , netal ) ) ) ; break ; } case ESIS_PDU_ESH : ND_TCHECK ( * pptr ) ; if ( li < 1 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>esh/li"" ) ) ; return ; } source_address_number = * pptr ; pptr ++ ; li -- ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Number<S2SV_blank>of<S2SV_blank>Source<S2SV_blank>Addresses:<S2SV_blank>%u"" , source_address_number ) ) ; while ( source_address_number > 0 ) { ND_TCHECK ( * pptr ) ; if ( li < 1 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>esh/li"" ) ) ; return ; } source_address_length = * pptr ; pptr ++ ; li -- ; ND_TCHECK2 ( * pptr , source_address_length ) ; if ( li < source_address_length ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>esh/li"" ) ) ; return ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>NET<S2SV_blank>(length:<S2SV_blank>%u):<S2SV_blank>%s"" , source_address_length , isonsap_string ( ndo , pptr , source_address_length ) ) ) ; pptr += source_address_length ; li -= source_address_length ; source_address_number -- ; } break ; case ESIS_PDU_ISH : { ND_TCHECK ( * pptr ) ; if ( li < 1 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>ish/li"" ) ) ; return ; } source_address_length = * pptr ; pptr ++ ; li -- ; ND_TCHECK2 ( * pptr , source_address_length ) ; if ( li < source_address_length ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>ish/li"" ) ) ; return ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>NET<S2SV_blank>(length:<S2SV_blank>%u):<S2SV_blank>%s"" , source_address_length , isonsap_string ( ndo , pptr , source_address_length ) ) ) ; pptr += source_address_length ; li -= source_address_length ; break ; } default : if ( ndo -> ndo_vflag <= 1 ) { if ( pptr < ndo -> ndo_snapend ) print_unknown_data ( ndo , pptr , ""\\n\\t<S2SV_blank><S2SV_blank>"" , ndo -> ndo_snapend - pptr ) ; } return ; } while ( li != 0 ) { u_int op , opli ; const uint8_t * tptr ; if ( li < 2 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>opts/li"" ) ) ; return ; } ND_TCHECK2 ( * pptr , 2 ) ; op = * pptr ++ ; opli = * pptr ++ ; li -= 2 ; if ( opli > li ) { ND_PRINT ( ( ndo , "",<S2SV_blank>opt<S2SV_blank>(%d)<S2SV_blank>too<S2SV_blank>long"" , op ) ) ; return ; } li -= opli ; tptr = pptr ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>#%u,<S2SV_blank>length<S2SV_blank>%u,<S2SV_blank>value:<S2SV_blank>"" , tok2str ( esis_option_values , ""Unknown"" , op ) , op , opli ) ) ; switch ( op ) { case ESIS_OPTION_ES_CONF_TIME : if ( opli == 2 ) { ND_TCHECK2 ( * pptr , 2 ) ; ND_PRINT ( ( ndo , ""%us"" , EXTRACT_16BITS ( tptr ) ) ) ; } else ND_PRINT ( ( ndo , ""(bad<S2SV_blank>length)"" ) ) ; break ; case ESIS_OPTION_PROTOCOLS : while ( opli > 0 ) { ND_TCHECK ( * pptr ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank>(0x%02x)"" , tok2str ( nlpid_values , ""unknown"" , * tptr ) , * tptr ) ) ; if ( opli > 1 ) ND_PRINT ( ( ndo , "",<S2SV_blank>"" ) ) ; tptr ++ ; opli -- ; } break ; case ESIS_OPTION_QOS_MAINTENANCE : case ESIS_OPTION_SECURITY : case ESIS_OPTION_PRIORITY : case ESIS_OPTION_ADDRESS_MASK : case ESIS_OPTION_SNPA_MASK : default : print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank>"" , opli ) ; break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , pptr , ""\\n\\t<S2SV_blank><S2SV_blank>"" , opli ) ; pptr += opli ; } trunc : return ; }","if ( snpal == 6 ) ND_PRINT ( ( ndo , ""\\\else ND_PRINT ( ( ndo , ""\\\if ( netal != 0 ) ND_PRINT ( ( ndo , ""\\\else ND_PRINT ( ( ndo , ""\\\",483
649,"buggy line: outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>K"" , c , m , y , k ) ;}outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>k"" , c , m , y , k ) ;}}cwe id:CWE-20context: void SetColor ( double c , double m , double y , double k , int par ) { if ( par == STROKING ) {  outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>K"" , c , m , y , k ) ;  } else {  outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>k"" , c , m , y , k ) ;  }  } ","sprintf ( outputbuffer , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>K"" , c , m , y , k ) ;}sprintf ( outputbuffer , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>k"" , c , m , y , k ) ;}sendClean ( outputbuffer ) ;}",484
650,"buggy line: BUG ( ) ;}BUG ( ) ;}cwe id:CWE-617context: static bool access_pmu_evcntr ( struct kvm_vcpu * vcpu , struct sys_reg_params * p , const struct sys_reg_desc * r ) { u64 idx ; if ( ! kvm_arm_pmu_v3_ready ( vcpu ) ) return trap_raz_wi ( vcpu , p , r ) ; if ( r -> CRn == 9 && r -> CRm == 13 ) { if ( r -> Op2 == 2 ) { if ( pmu_access_event_counter_el0_disabled ( vcpu ) ) return false ; idx = vcpu_sys_reg ( vcpu , PMSELR_EL0 ) & ARMV8_PMU_COUNTER_MASK ; } else if ( r -> Op2 == 0 ) { if ( pmu_access_cycle_counter_el0_disabled ( vcpu ) ) return false ; idx = ARMV8_PMU_CYCLE_IDX ; } else {  BUG ( ) ;  } } else if ( r -> CRn == 14 && ( r -> CRm & 12 ) == 8 ) { if ( pmu_access_event_counter_el0_disabled ( vcpu ) ) return false ; idx = ( ( r -> CRm & 3 ) << 3 ) | ( r -> Op2 & 7 ) ; } else {  BUG ( ) ;  } if ( ! pmu_counter_idx_valid ( vcpu , idx ) ) return false ; if ( p -> is_write ) { if ( pmu_access_el0_disabled ( vcpu ) ) return false ; kvm_pmu_set_counter_value ( vcpu , idx , p -> regval ) ; } else { p -> regval = kvm_pmu_get_counter_value ( vcpu , idx ) ; } return true ; }",return false ;}}else if ( r -> CRn == 0 && r -> CRm == 9 ) {if ( pmu_access_event_counter_el0_disabled ( vcpu ) ) return false ;idx = ARMV8_PMU_CYCLE_IDX ;return false ;},485
651,"buggy line: case IS_STRING :  convert_to_double_ex ( zval_affine_elem ) ;affine [ i ] = Z_DVAL_PP ( zval_affine_elem ) ;break ;cwe id:CWE-189context: PHP_FUNCTION ( imageaffine ) { zval * IM ; gdImagePtr src ; gdImagePtr dst ; gdRect rect ; gdRectPtr pRect = NULL ; zval * z_rect = NULL ; zval * z_affine ; zval * * tmp ; double affine [ 6 ] ; int i , nelems ; zval * * zval_affine_elem = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""ra|a"" , & IM , & z_affine , & z_rect ) == FAILURE ) { return ; } ZEND_FETCH_RESOURCE ( src , gdImagePtr , & IM , - 1 , ""Image"" , le_gd ) ; if ( ( nelems = zend_hash_num_elements ( Z_ARRVAL_P ( z_affine ) ) ) != 6 ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Affine<S2SV_blank>array<S2SV_blank>must<S2SV_blank>have<S2SV_blank>six<S2SV_blank>elements"" ) ; RETURN_FALSE ; } for ( i = 0 ; i < nelems ; i ++ ) { if ( zend_hash_index_find ( Z_ARRVAL_P ( z_affine ) , i , ( void * * ) & zval_affine_elem ) == SUCCESS ) { switch ( Z_TYPE_PP ( zval_affine_elem ) ) { case IS_LONG : affine [ i ] = Z_LVAL_PP ( zval_affine_elem ) ; break ; case IS_DOUBLE : affine [ i ] = Z_DVAL_PP ( zval_affine_elem ) ; break ; case IS_STRING :  convert_to_double_ex ( zval_affine_elem ) ;   affine [ i ] = Z_DVAL_PP ( zval_affine_elem ) ;  break ; default : php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Invalid<S2SV_blank>type<S2SV_blank>for<S2SV_blank>element<S2SV_blank>%i"" , i ) ; RETURN_FALSE ; } } } if ( z_rect != NULL ) { if ( zend_hash_find ( HASH_OF ( z_rect ) , ""x"" , sizeof ( ""x"" ) , ( void * * ) & tmp ) != FAILURE ) {  convert_to_long_ex ( tmp ) ;   rect . x = Z_LVAL_PP ( tmp ) ;   } else {  php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>x<S2SV_blank>position"" ) ; RETURN_FALSE ; } if ( zend_hash_find ( HASH_OF ( z_rect ) , ""y"" , sizeof ( ""x"" ) , ( void * * ) & tmp ) != FAILURE ) {  convert_to_long_ex ( tmp ) ;   rect . y = Z_LVAL_PP ( tmp ) ;   } else {  php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>y<S2SV_blank>position"" ) ; RETURN_FALSE ; } if ( zend_hash_find ( HASH_OF ( z_rect ) , ""width"" , sizeof ( ""width"" ) , ( void * * ) & tmp ) != FAILURE ) {  convert_to_long_ex ( tmp ) ;   rect . width = Z_LVAL_PP ( tmp ) ;   } else {  php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>width"" ) ; RETURN_FALSE ; } if ( zend_hash_find ( HASH_OF ( z_rect ) , ""height"" , sizeof ( ""height"" ) , ( void * * ) & tmp ) != FAILURE ) {  convert_to_long_ex ( tmp ) ;   rect . height = Z_LVAL_PP ( tmp ) ;  } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>height"" ) ; RETURN_FALSE ; } pRect = & rect ; } else { rect . x = - 1 ; rect . y = - 1 ; rect . width = gdImageSX ( src ) ; rect . height = gdImageSY ( src ) ; pRect = NULL ; } if ( gdTransformAffineGetImage ( & dst , src , pRect , affine ) != GD_TRUE ) { RETURN_FALSE ; } if ( dst == NULL ) { RETURN_FALSE ; } else { ZEND_REGISTER_RESOURCE ( return_value , dst , le_gd ) ; } }",case IS_STRING : {zval dval ;dval = * * zval_affine_elem ;zval_copy_ctor ( & dval ) ;convert_to_double ( & dval ) ;affine [ i ] = Z_DVAL ( dval ) ;}break ;,486
652,"buggy line: convert_to_long_ex ( tmp ) ;rect . x = Z_LVAL_PP ( tmp ) ;}php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>x<S2SV_blank>position"" ) ;convert_to_long_ex ( tmp ) ;rect . y = Z_LVAL_PP ( tmp ) ;}php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>y<S2SV_blank>position"" ) ;convert_to_long_ex ( tmp ) ;rect . width = Z_LVAL_PP ( tmp ) ;}php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>width"" ) ;convert_to_long_ex ( tmp ) ;rect . height = Z_LVAL_PP ( tmp ) ;}cwe id:CWE-189context: PHP_FUNCTION ( imageaffine ) { zval * IM ; gdImagePtr src ; gdImagePtr dst ; gdRect rect ; gdRectPtr pRect = NULL ; zval * z_rect = NULL ; zval * z_affine ; zval * * tmp ; double affine [ 6 ] ; int i , nelems ; zval * * zval_affine_elem = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""ra|a"" , & IM , & z_affine , & z_rect ) == FAILURE ) { return ; } ZEND_FETCH_RESOURCE ( src , gdImagePtr , & IM , - 1 , ""Image"" , le_gd ) ; if ( ( nelems = zend_hash_num_elements ( Z_ARRVAL_P ( z_affine ) ) ) != 6 ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Affine<S2SV_blank>array<S2SV_blank>must<S2SV_blank>have<S2SV_blank>six<S2SV_blank>elements"" ) ; RETURN_FALSE ; } for ( i = 0 ; i < nelems ; i ++ ) { if ( zend_hash_index_find ( Z_ARRVAL_P ( z_affine ) , i , ( void * * ) & zval_affine_elem ) == SUCCESS ) { switch ( Z_TYPE_PP ( zval_affine_elem ) ) { case IS_LONG : affine [ i ] = Z_LVAL_PP ( zval_affine_elem ) ; break ; case IS_DOUBLE : affine [ i ] = Z_DVAL_PP ( zval_affine_elem ) ; break ; case IS_STRING :  convert_to_double_ex ( zval_affine_elem ) ;   affine [ i ] = Z_DVAL_PP ( zval_affine_elem ) ;  break ; default : php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Invalid<S2SV_blank>type<S2SV_blank>for<S2SV_blank>element<S2SV_blank>%i"" , i ) ; RETURN_FALSE ; } } } if ( z_rect != NULL ) { if ( zend_hash_find ( HASH_OF ( z_rect ) , ""x"" , sizeof ( ""x"" ) , ( void * * ) & tmp ) != FAILURE ) {  convert_to_long_ex ( tmp ) ;   rect . x = Z_LVAL_PP ( tmp ) ;   } else {  php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>x<S2SV_blank>position"" ) ; RETURN_FALSE ; } if ( zend_hash_find ( HASH_OF ( z_rect ) , ""y"" , sizeof ( ""x"" ) , ( void * * ) & tmp ) != FAILURE ) {  convert_to_long_ex ( tmp ) ;   rect . y = Z_LVAL_PP ( tmp ) ;   } else {  php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>y<S2SV_blank>position"" ) ; RETURN_FALSE ; } if ( zend_hash_find ( HASH_OF ( z_rect ) , ""width"" , sizeof ( ""width"" ) , ( void * * ) & tmp ) != FAILURE ) {  convert_to_long_ex ( tmp ) ;   rect . width = Z_LVAL_PP ( tmp ) ;   } else {  php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>width"" ) ; RETURN_FALSE ; } if ( zend_hash_find ( HASH_OF ( z_rect ) , ""height"" , sizeof ( ""height"" ) , ( void * * ) & tmp ) != FAILURE ) {  convert_to_long_ex ( tmp ) ;   rect . height = Z_LVAL_PP ( tmp ) ;  } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>height"" ) ; RETURN_FALSE ; } pRect = & rect ; } else { rect . x = - 1 ; rect . y = - 1 ; rect . width = gdImageSX ( src ) ; rect . height = gdImageSY ( src ) ; pRect = NULL ; } if ( gdTransformAffineGetImage ( & dst , src , pRect , affine ) != GD_TRUE ) { RETURN_FALSE ; } if ( dst == NULL ) { RETURN_FALSE ; } else { ZEND_REGISTER_RESOURCE ( return_value , dst , le_gd ) ; } }","if ( Z_TYPE_PP ( tmp ) != IS_LONG ) {zval lval ;lval = * * tmp ;zval_copy_ctor ( & lval ) ;convert_to_long ( & lval ) ;rect . x = Z_LVAL ( lval ) ;}}rect . x = Z_LVAL_PP ( tmp ) ;}else {php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>x<S2SV_blank>position"" ) ;if ( Z_TYPE_PP ( tmp ) != IS_LONG ) {zval lval ;lval = * * tmp ;zval_copy_ctor ( & lval ) ;convert_to_long ( & lval ) ;rect . y = Z_LVAL ( lval ) ;}}else {rect . y = Z_LVAL_PP ( tmp ) ;}php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>y<S2SV_blank>position"" ) ;if ( Z_TYPE_PP ( tmp ) != IS_LONG ) {zval lval ;lval = * * tmp ;zval_copy_ctor ( & lval ) ;convert_to_long ( & lval ) ;rect . width = Z_LVAL ( lval ) ;}}else {rect . width = Z_LVAL_PP ( tmp ) ;}php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>width"" ) ;if ( Z_TYPE_PP ( tmp ) != IS_LONG ) {zval lval ;lval = * * tmp ;zval_copy_ctor ( & lval ) ;convert_to_long ( & lval ) ;rect . height = Z_LVAL ( lval ) ;}else {rect . height = Z_LVAL_PP ( tmp ) ;}}",486
653,buggy line: static void ast_dealloc ( AST_object * self )  {Py_CLEAR ( self -> dict ) ;cwe id:CWE-125context: static void ast_dealloc ( AST_object * self )  {  Py_CLEAR ( self -> dict ) ; Py_TYPE ( self ) -> tp_free ( self ) ; },static void ast_dealloc ( AST_object * self ) {PyObject_GC_UnTrack ( self ) ;Py_CLEAR ( self -> dict ) ;,487
654,"buggy line: free ( szSepLine ) ;return 0 ;cwe id:CWE-119context: static int ExecuteSQL ( SQLHDBC hDbc , char * szSQL , char cDelimiter , int bColumnNames , int bHTMLTable ) { SQLHSTMT hStmt ; SQLTCHAR szSepLine [ 32001 ] ; SQLTCHAR szUcSQL [ 32001 ] ; SQLSMALLINT cols ; SQLINTEGER ret ; SQLLEN nRows = 0 ; szSepLine [ 0 ] = 0 ; ansi_to_unicode ( szSQL , szUcSQL ) ; if ( SQLAllocStmt ( hDbc , & hStmt ) != SQL_SUCCESS ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , 0 ) ; fprintf ( stderr , ""[ISQL]ERROR:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>SQLAllocStmt\\n"" ) ; return 0 ; } if ( buseED ) { ret = SQLExecDirect ( hStmt , szUcSQL , SQL_NTS ) ; if ( ret == SQL_NO_DATA ) { fprintf ( stderr , ""[ISQL]INFO:<S2SV_blank>SQLExecDirect<S2SV_blank>returned<S2SV_blank>SQL_NO_DATA\\n"" ) ; } else if ( ret == SQL_SUCCESS_WITH_INFO ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , hStmt ) ; fprintf ( stderr , ""[ISQL]INFO:<S2SV_blank>SQLExecDirect<S2SV_blank>returned<S2SV_blank>SQL_SUCCESS_WITH_INFO\\n"" ) ; } else if ( ret != SQL_SUCCESS ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , hStmt ) ; fprintf ( stderr , ""[ISQL]ERROR:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>SQLExecDirect\\n"" ) ; SQLFreeStmt ( hStmt , SQL_DROP ) ;  free ( szSepLine ) ;  return 0 ; } } else { if ( SQLPrepare ( hStmt , szUcSQL , SQL_NTS ) != SQL_SUCCESS ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , hStmt ) ; fprintf ( stderr , ""[ISQL]ERROR:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>SQLPrepare\\n"" ) ; SQLFreeStmt ( hStmt , SQL_DROP ) ; return 0 ; } ret = SQLExecute ( hStmt ) ; if ( ret == SQL_NO_DATA ) { fprintf ( stderr , ""[ISQL]INFO:<S2SV_blank>SQLExecute<S2SV_blank>returned<S2SV_blank>SQL_NO_DATA\\n"" ) ; } else if ( ret == SQL_SUCCESS_WITH_INFO ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , hStmt ) ; fprintf ( stderr , ""[ISQL]INFO:<S2SV_blank>SQLExecute<S2SV_blank>returned<S2SV_blank>SQL_SUCCESS_WITH_INFO\\n"" ) ; } else if ( ret != SQL_SUCCESS ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , hStmt ) ; fprintf ( stderr , ""[ISQL]ERROR:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>SQLExecute\\n"" ) ; SQLFreeStmt ( hStmt , SQL_DROP ) ; return 0 ; } } do { if ( SQLNumResultCols ( hStmt , & cols ) != SQL_SUCCESS ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , hStmt ) ; fprintf ( stderr , ""[ISQL]ERROR:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>SQLNumResultCols\\n"" ) ; SQLFreeStmt ( hStmt , SQL_DROP ) ; return 0 ; } if ( cols > 0 ) { if ( bHTMLTable ) WriteHeaderHTMLTable ( hStmt ) ; else if ( cDelimiter == 0 ) UWriteHeaderNormal ( hStmt , szSepLine ) ; else if ( cDelimiter && bColumnNames ) WriteHeaderDelimited ( hStmt , cDelimiter ) ; if ( bHTMLTable ) WriteBodyHTMLTable ( hStmt ) ; else if ( cDelimiter == 0 ) nRows = WriteBodyNormal ( hStmt ) ; else WriteBodyDelimited ( hStmt , cDelimiter ) ; } if ( bHTMLTable ) WriteFooterHTMLTable ( hStmt ) ; else if ( cDelimiter == 0 ) UWriteFooterNormal ( hStmt , szSepLine , nRows ) ; } while ( SQL_SUCCEEDED ( SQLMoreResults ( hStmt ) ) ) ; SQLFreeStmt ( hStmt , SQL_DROP ) ; return 1 ; }",return 0 ;,488
655,"buggy line: r = copy_from_user ( data , ( void __user * ) addr + offset , len ) ;if ( r ) return - EFAULT ;cwe id:CWE-20context: int kvm_read_guest_page ( struct kvm * kvm , gfn_t gfn , void * data , int offset , int len ) { int r ; unsigned long addr ; addr = gfn_to_hva ( kvm , gfn ) ; if ( kvm_is_error_hva ( addr ) ) return - EFAULT ;  r = copy_from_user ( data , ( void __user * ) addr + offset , len ) ;  if ( r ) return - EFAULT ; return 0 ; }","r = __copy_from_user ( data , ( void __user * ) addr + offset , len ) ;if ( r ) return - EFAULT ;",489
656,"buggy line: char * p , * q , * r ;Clp_Parser * clp = Clp_NewParser ( argc , ( const char * const * ) argv , sizeof ( options ) / sizeof ( options [ 0 ] ) , options ) ;cwe id:CWE-119context: int main ( int argc , char * argv [ ] ) {  char * p , * q , * r ;  Clp_Parser * clp = Clp_NewParser ( argc , ( const char * const * ) argv , sizeof ( options ) / sizeof ( options [ 0 ] ) , options ) ; program_name = Clp_ProgramName ( clp ) ; while ( 1 ) { int opt = Clp_Next ( clp ) ; switch ( opt ) { case BLOCK_LEN_OPT : blocklen = clp -> val . i ; break ; output_file : case OUTPUT_OPT : if ( ofp ) fatal_error ( ""output<S2SV_blank>file<S2SV_blank>already<S2SV_blank>specified"" ) ; if ( strcmp ( clp -> vstr , ""-"" ) == 0 ) ofp = stdout ; else if ( ! ( ofp = fopen ( clp -> vstr , ""w"" ) ) ) fatal_error ( ""%s:<S2SV_blank>%s"" , clp -> vstr , strerror ( errno ) ) ; break ; case PFB_OPT : pfb = 1 ; break ; case PFA_OPT : pfb = 0 ; break ; case HELP_OPT : usage ( ) ; exit ( 0 ) ; break ; case VERSION_OPT : printf ( ""t1asm<S2SV_blank>(LCDF<S2SV_blank>t1utils)<S2SV_blank>%s\\n"" , VERSION ) ;  printf ( ""Copyright<S2SV_blank>(C)<S2SV_blank>1992-2010<S2SV_blank>I.<S2SV_blank>Lee<S2SV_blank>Hetherington,<S2SV_blank>Eddie<S2SV_blank>Kohler<S2SV_blank>et<S2SV_blank>al.\\n\\\n<S2SV_blank>This<S2SV_blank>is<S2SV_blank>free<S2SV_blank>software;<S2SV_blank>see<S2SV_blank>the<S2SV_blank>source<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>conditions.\\n\\\n<S2SV_blank>There<S2SV_blank>is<S2SV_blank>NO<S2SV_blank>warranty,<S2SV_blank>not<S2SV_blank>even<S2SV_blank>for<S2SV_blank>merchantability<S2SV_blank>or<S2SV_blank>fitness<S2SV_blank>for<S2SV_blank>a\\n\\\n<S2SV_blank>particular<S2SV_blank>purpose.\\n"" ) ;  exit ( 0 ) ; break ; case Clp_NotOption : if ( ifp && ofp ) fatal_error ( ""too<S2SV_blank>many<S2SV_blank>arguments"" ) ; else if ( ifp ) goto output_file ; if ( strcmp ( clp -> vstr , ""-"" ) == 0 ) ifp = stdin ; else if ( ! ( ifp = fopen ( clp -> vstr , ""r"" ) ) ) fatal_error ( ""%s:<S2SV_blank>%s"" , clp -> vstr , strerror ( errno ) ) ; break ; case Clp_Done : goto done ; case Clp_BadOption : short_usage ( ) ; exit ( 1 ) ; break ; } } done : if ( ! pfb ) { if ( blocklen == - 1 ) blocklen = 64 ; else if ( blocklen < 8 ) { blocklen = 8 ; error ( ""warning:<S2SV_blank>line<S2SV_blank>length<S2SV_blank>raised<S2SV_blank>to<S2SV_blank>%d"" , blocklen ) ; } else if ( blocklen > 1024 ) { blocklen = 1024 ; error ( ""warning:<S2SV_blank>line<S2SV_blank>length<S2SV_blank>lowered<S2SV_blank>to<S2SV_blank>%d"" , blocklen ) ; } } if ( ! ifp ) ifp = stdin ; if ( ! ofp ) ofp = stdout ; if ( pfb ) init_pfb_writer ( & w , blocklen , ofp ) ; # if defined ( _MSDOS ) || defined ( _WIN32 ) if ( pfb ) _setmode ( _fileno ( ofp ) , _O_BINARY ) ; # endif while ( ! feof ( ifp ) && ! ferror ( ifp ) ) { t1utils_getline ( ) ; if ( ! ever_active ) {  if ( strncmp ( line , ""currentfile<S2SV_blank>eexec"" , 17 ) == 0 && isspace ( line [ 17 ] ) ) {   for ( p = line + 18 ; isspace ( * p ) ; p ++ )  ; eexec_start ( p ) ; continue ; } else if ( strncmp ( line , ""/lenIV"" , 6 ) == 0 ) {  lenIV = atoi ( line + 6 ) ;  } else if ( ( p = strstr ( line , ""string<S2SV_blank>currentfile"" ) )  && strstr ( line , ""readstring"" ) ) {  * p = '\\0' ; q = strrchr ( line , '/' ) ; if ( q ) { r = cs_start ; ++ q ; while ( ! isspace ( * q ) && * q != '{' ) * r ++ = * q ++ ; * r = '\\0' ; } * p = 's' ; } } if ( ! active ) {  if ( ( p = strstr ( line , ""/Subrs"" ) ) && isdigit ( p [ 7 ] ) )  ever_active = active = 1 ;  else if ( ( p = strstr ( line , ""/CharStrings"" ) ) && isdigit ( p [ 13 ] ) )  ever_active = active = 1 ; } if ( ( p = strstr ( line , ""currentfile<S2SV_blank>closefile"" ) ) ) { p += sizeof ( ""currentfile<S2SV_blank>closefile"" ) - 1 ;  for ( q = p ; isspace ( * q ) && * q != '\\n' ; q ++ )  ; if ( q == p && ! * q ) error ( ""warning:<S2SV_blank>`currentfile<S2SV_blank>closefile\'<S2SV_blank>line<S2SV_blank>too<S2SV_blank>long"" ) ; else if ( q != p ) { if ( * q != '\\n' ) error ( ""text<S2SV_blank>after<S2SV_blank>`currentfile<S2SV_blank>closefile\'<S2SV_blank>ignored"" ) ; * p ++ = '\\n' ; * p ++ = '\\0' ; } eexec_string ( line ) ; break ; } eexec_string ( line ) ; if ( start_charstring ) { if ( ! cs_start [ 0 ] ) fatal_error ( ""couldn\'t<S2SV_blank>find<S2SV_blank>charstring<S2SV_blank>start<S2SV_blank>command"" ) ; parse_charstring ( ) ; } } if ( in_eexec ) eexec_end ( ) ; while ( ! feof ( ifp ) && ! ferror ( ifp ) ) { t1utils_getline ( ) ; eexec_string ( line ) ; } if ( pfb ) pfb_writer_end ( & w ) ; if ( ! ever_active ) error ( ""warning:<S2SV_blank>no<S2SV_blank>charstrings<S2SV_blank>found<S2SV_blank>in<S2SV_blank>input<S2SV_blank>file"" ) ; fclose ( ifp ) ; fclose ( ofp ) ; return 0 ; }","char * p , * q ;Clp_Parser * clp = Clp_NewParser ( argc , ( const char * const * ) argv , sizeof ( options ) / sizeof ( options [ 0 ] ) , options ) ;",490
657,"buggy line: printf ( ""Copyright<S2SV_blank>(C)<S2SV_blank>1992-2010<S2SV_blank>I.<S2SV_blank>Lee<S2SV_blank>Hetherington,<S2SV_blank>Eddie<S2SV_blank>Kohler<S2SV_blank>et<S2SV_blank>al.\\\<S2SV_blank>see<S2SV_blank>the<S2SV_blank>source<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>conditions.\\\exit ( 0 ) ;cwe id:CWE-119context: int main ( int argc , char * argv [ ] ) {  char * p , * q , * r ;  Clp_Parser * clp = Clp_NewParser ( argc , ( const char * const * ) argv , sizeof ( options ) / sizeof ( options [ 0 ] ) , options ) ; program_name = Clp_ProgramName ( clp ) ; while ( 1 ) { int opt = Clp_Next ( clp ) ; switch ( opt ) { case BLOCK_LEN_OPT : blocklen = clp -> val . i ; break ; output_file : case OUTPUT_OPT : if ( ofp ) fatal_error ( ""output<S2SV_blank>file<S2SV_blank>already<S2SV_blank>specified"" ) ; if ( strcmp ( clp -> vstr , ""-"" ) == 0 ) ofp = stdout ; else if ( ! ( ofp = fopen ( clp -> vstr , ""w"" ) ) ) fatal_error ( ""%s:<S2SV_blank>%s"" , clp -> vstr , strerror ( errno ) ) ; break ; case PFB_OPT : pfb = 1 ; break ; case PFA_OPT : pfb = 0 ; break ; case HELP_OPT : usage ( ) ; exit ( 0 ) ; break ; case VERSION_OPT : printf ( ""t1asm<S2SV_blank>(LCDF<S2SV_blank>t1utils)<S2SV_blank>%s\\n"" , VERSION ) ;  printf ( ""Copyright<S2SV_blank>(C)<S2SV_blank>1992-2010<S2SV_blank>I.<S2SV_blank>Lee<S2SV_blank>Hetherington,<S2SV_blank>Eddie<S2SV_blank>Kohler<S2SV_blank>et<S2SV_blank>al.\\n\\\n<S2SV_blank>This<S2SV_blank>is<S2SV_blank>free<S2SV_blank>software;<S2SV_blank>see<S2SV_blank>the<S2SV_blank>source<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>conditions.\\n\\\n<S2SV_blank>There<S2SV_blank>is<S2SV_blank>NO<S2SV_blank>warranty,<S2SV_blank>not<S2SV_blank>even<S2SV_blank>for<S2SV_blank>merchantability<S2SV_blank>or<S2SV_blank>fitness<S2SV_blank>for<S2SV_blank>a\\n\\\n<S2SV_blank>particular<S2SV_blank>purpose.\\n"" ) ;  exit ( 0 ) ; break ; case Clp_NotOption : if ( ifp && ofp ) fatal_error ( ""too<S2SV_blank>many<S2SV_blank>arguments"" ) ; else if ( ifp ) goto output_file ; if ( strcmp ( clp -> vstr , ""-"" ) == 0 ) ifp = stdin ; else if ( ! ( ifp = fopen ( clp -> vstr , ""r"" ) ) ) fatal_error ( ""%s:<S2SV_blank>%s"" , clp -> vstr , strerror ( errno ) ) ; break ; case Clp_Done : goto done ; case Clp_BadOption : short_usage ( ) ; exit ( 1 ) ; break ; } } done : if ( ! pfb ) { if ( blocklen == - 1 ) blocklen = 64 ; else if ( blocklen < 8 ) { blocklen = 8 ; error ( ""warning:<S2SV_blank>line<S2SV_blank>length<S2SV_blank>raised<S2SV_blank>to<S2SV_blank>%d"" , blocklen ) ; } else if ( blocklen > 1024 ) { blocklen = 1024 ; error ( ""warning:<S2SV_blank>line<S2SV_blank>length<S2SV_blank>lowered<S2SV_blank>to<S2SV_blank>%d"" , blocklen ) ; } } if ( ! ifp ) ifp = stdin ; if ( ! ofp ) ofp = stdout ; if ( pfb ) init_pfb_writer ( & w , blocklen , ofp ) ; # if defined ( _MSDOS ) || defined ( _WIN32 ) if ( pfb ) _setmode ( _fileno ( ofp ) , _O_BINARY ) ; # endif while ( ! feof ( ifp ) && ! ferror ( ifp ) ) { t1utils_getline ( ) ; if ( ! ever_active ) {  if ( strncmp ( line , ""currentfile<S2SV_blank>eexec"" , 17 ) == 0 && isspace ( line [ 17 ] ) ) {   for ( p = line + 18 ; isspace ( * p ) ; p ++ )  ; eexec_start ( p ) ; continue ; } else if ( strncmp ( line , ""/lenIV"" , 6 ) == 0 ) {  lenIV = atoi ( line + 6 ) ;  } else if ( ( p = strstr ( line , ""string<S2SV_blank>currentfile"" ) )  && strstr ( line , ""readstring"" ) ) {  * p = '\\0' ; q = strrchr ( line , '/' ) ; if ( q ) { r = cs_start ; ++ q ; while ( ! isspace ( * q ) && * q != '{' ) * r ++ = * q ++ ; * r = '\\0' ; } * p = 's' ; } } if ( ! active ) {  if ( ( p = strstr ( line , ""/Subrs"" ) ) && isdigit ( p [ 7 ] ) )  ever_active = active = 1 ;  else if ( ( p = strstr ( line , ""/CharStrings"" ) ) && isdigit ( p [ 13 ] ) )  ever_active = active = 1 ; } if ( ( p = strstr ( line , ""currentfile<S2SV_blank>closefile"" ) ) ) { p += sizeof ( ""currentfile<S2SV_blank>closefile"" ) - 1 ;  for ( q = p ; isspace ( * q ) && * q != '\\n' ; q ++ )  ; if ( q == p && ! * q ) error ( ""warning:<S2SV_blank>`currentfile<S2SV_blank>closefile\'<S2SV_blank>line<S2SV_blank>too<S2SV_blank>long"" ) ; else if ( q != p ) { if ( * q != '\\n' ) error ( ""text<S2SV_blank>after<S2SV_blank>`currentfile<S2SV_blank>closefile\'<S2SV_blank>ignored"" ) ; * p ++ = '\\n' ; * p ++ = '\\0' ; } eexec_string ( line ) ; break ; } eexec_string ( line ) ; if ( start_charstring ) { if ( ! cs_start [ 0 ] ) fatal_error ( ""couldn\'t<S2SV_blank>find<S2SV_blank>charstring<S2SV_blank>start<S2SV_blank>command"" ) ; parse_charstring ( ) ; } } if ( in_eexec ) eexec_end ( ) ; while ( ! feof ( ifp ) && ! ferror ( ifp ) ) { t1utils_getline ( ) ; eexec_string ( line ) ; } if ( pfb ) pfb_writer_end ( & w ) ; if ( ! ever_active ) error ( ""warning:<S2SV_blank>no<S2SV_blank>charstrings<S2SV_blank>found<S2SV_blank>in<S2SV_blank>input<S2SV_blank>file"" ) ; fclose ( ifp ) ; fclose ( ofp ) ; return 0 ; }","printf ( ""Copyright<S2SV_blank>(C)<S2SV_blank>1992-2010<S2SV_blank>I.<S2SV_blank>Lee<S2SV_blank>Hetherington,<S2SV_blank>Eddie<S2SV_blank>Kohler<S2SV_blank>et<S2SV_blank>al.\\\<S2SV_blank>see<S2SV_blank>the<S2SV_blank>source<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>conditions.\\\exit ( 0 ) ;",490
658,"buggy line: if ( strncmp ( line , ""currentfile<S2SV_blank>eexec"" , 17 ) == 0 && isspace ( line [ 17 ] ) ) {for ( p = line + 18 ;isspace ( * p ) ;p ++ )  ;lenIV = atoi ( line + 6 ) ;}else if ( ( p = strstr ( line , ""string<S2SV_blank>currentfile"" ) )  && strstr ( line , ""readstring"" ) ) {* p = \'\\\\0\' ;q = strrchr ( line , \'/\' ) ;if ( q ) {r = cs_start ;++ q ;while ( ! isspace ( * q ) && * q != \'{\' ) * r ++ = * q ++ ;* r = \'\\\\0\' ;* p = \'s\' ;if ( ( p = strstr ( line , ""/Subrs"" ) ) && isdigit ( p [ 7 ] ) )  ever_active = active = 1 ;else if ( ( p = strstr ( line , ""/CharStrings"" ) ) && isdigit ( p [ 13 ] ) )  ever_active = active = 1 ;for ( q = p ;isspace ( * q ) && * q != \'\\\q ++ )  ;cwe id:CWE-119context: int main ( int argc , char * argv [ ] ) {  char * p , * q , * r ;  Clp_Parser * clp = Clp_NewParser ( argc , ( const char * const * ) argv , sizeof ( options ) / sizeof ( options [ 0 ] ) , options ) ; program_name = Clp_ProgramName ( clp ) ; while ( 1 ) { int opt = Clp_Next ( clp ) ; switch ( opt ) { case BLOCK_LEN_OPT : blocklen = clp -> val . i ; break ; output_file : case OUTPUT_OPT : if ( ofp ) fatal_error ( ""output<S2SV_blank>file<S2SV_blank>already<S2SV_blank>specified"" ) ; if ( strcmp ( clp -> vstr , ""-"" ) == 0 ) ofp = stdout ; else if ( ! ( ofp = fopen ( clp -> vstr , ""w"" ) ) ) fatal_error ( ""%s:<S2SV_blank>%s"" , clp -> vstr , strerror ( errno ) ) ; break ; case PFB_OPT : pfb = 1 ; break ; case PFA_OPT : pfb = 0 ; break ; case HELP_OPT : usage ( ) ; exit ( 0 ) ; break ; case VERSION_OPT : printf ( ""t1asm<S2SV_blank>(LCDF<S2SV_blank>t1utils)<S2SV_blank>%s\\n"" , VERSION ) ;  printf ( ""Copyright<S2SV_blank>(C)<S2SV_blank>1992-2010<S2SV_blank>I.<S2SV_blank>Lee<S2SV_blank>Hetherington,<S2SV_blank>Eddie<S2SV_blank>Kohler<S2SV_blank>et<S2SV_blank>al.\\n\\\n<S2SV_blank>This<S2SV_blank>is<S2SV_blank>free<S2SV_blank>software;<S2SV_blank>see<S2SV_blank>the<S2SV_blank>source<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>conditions.\\n\\\n<S2SV_blank>There<S2SV_blank>is<S2SV_blank>NO<S2SV_blank>warranty,<S2SV_blank>not<S2SV_blank>even<S2SV_blank>for<S2SV_blank>merchantability<S2SV_blank>or<S2SV_blank>fitness<S2SV_blank>for<S2SV_blank>a\\n\\\n<S2SV_blank>particular<S2SV_blank>purpose.\\n"" ) ;  exit ( 0 ) ; break ; case Clp_NotOption : if ( ifp && ofp ) fatal_error ( ""too<S2SV_blank>many<S2SV_blank>arguments"" ) ; else if ( ifp ) goto output_file ; if ( strcmp ( clp -> vstr , ""-"" ) == 0 ) ifp = stdin ; else if ( ! ( ifp = fopen ( clp -> vstr , ""r"" ) ) ) fatal_error ( ""%s:<S2SV_blank>%s"" , clp -> vstr , strerror ( errno ) ) ; break ; case Clp_Done : goto done ; case Clp_BadOption : short_usage ( ) ; exit ( 1 ) ; break ; } } done : if ( ! pfb ) { if ( blocklen == - 1 ) blocklen = 64 ; else if ( blocklen < 8 ) { blocklen = 8 ; error ( ""warning:<S2SV_blank>line<S2SV_blank>length<S2SV_blank>raised<S2SV_blank>to<S2SV_blank>%d"" , blocklen ) ; } else if ( blocklen > 1024 ) { blocklen = 1024 ; error ( ""warning:<S2SV_blank>line<S2SV_blank>length<S2SV_blank>lowered<S2SV_blank>to<S2SV_blank>%d"" , blocklen ) ; } } if ( ! ifp ) ifp = stdin ; if ( ! ofp ) ofp = stdout ; if ( pfb ) init_pfb_writer ( & w , blocklen , ofp ) ; # if defined ( _MSDOS ) || defined ( _WIN32 ) if ( pfb ) _setmode ( _fileno ( ofp ) , _O_BINARY ) ; # endif while ( ! feof ( ifp ) && ! ferror ( ifp ) ) { t1utils_getline ( ) ; if ( ! ever_active ) {  if ( strncmp ( line , ""currentfile<S2SV_blank>eexec"" , 17 ) == 0 && isspace ( line [ 17 ] ) ) {   for ( p = line + 18 ; isspace ( * p ) ; p ++ )  ; eexec_start ( p ) ; continue ; } else if ( strncmp ( line , ""/lenIV"" , 6 ) == 0 ) {  lenIV = atoi ( line + 6 ) ;  } else if ( ( p = strstr ( line , ""string<S2SV_blank>currentfile"" ) )  && strstr ( line , ""readstring"" ) ) {  * p = '\\0' ; q = strrchr ( line , '/' ) ; if ( q ) { r = cs_start ; ++ q ; while ( ! isspace ( * q ) && * q != '{' ) * r ++ = * q ++ ; * r = '\\0' ; } * p = 's' ; } } if ( ! active ) {  if ( ( p = strstr ( line , ""/Subrs"" ) ) && isdigit ( p [ 7 ] ) )  ever_active = active = 1 ;  else if ( ( p = strstr ( line , ""/CharStrings"" ) ) && isdigit ( p [ 13 ] ) )  ever_active = active = 1 ; } if ( ( p = strstr ( line , ""currentfile<S2SV_blank>closefile"" ) ) ) { p += sizeof ( ""currentfile<S2SV_blank>closefile"" ) - 1 ;  for ( q = p ; isspace ( * q ) && * q != '\\n' ; q ++ )  ; if ( q == p && ! * q ) error ( ""warning:<S2SV_blank>`currentfile<S2SV_blank>closefile\'<S2SV_blank>line<S2SV_blank>too<S2SV_blank>long"" ) ; else if ( q != p ) { if ( * q != '\\n' ) error ( ""text<S2SV_blank>after<S2SV_blank>`currentfile<S2SV_blank>closefile\'<S2SV_blank>ignored"" ) ; * p ++ = '\\n' ; * p ++ = '\\0' ; } eexec_string ( line ) ; break ; } eexec_string ( line ) ; if ( start_charstring ) { if ( ! cs_start [ 0 ] ) fatal_error ( ""couldn\'t<S2SV_blank>find<S2SV_blank>charstring<S2SV_blank>start<S2SV_blank>command"" ) ; parse_charstring ( ) ; } } if ( in_eexec ) eexec_end ( ) ; while ( ! feof ( ifp ) && ! ferror ( ifp ) ) { t1utils_getline ( ) ; eexec_string ( line ) ; } if ( pfb ) pfb_writer_end ( & w ) ; if ( ! ever_active ) error ( ""warning:<S2SV_blank>no<S2SV_blank>charstrings<S2SV_blank>found<S2SV_blank>in<S2SV_blank>input<S2SV_blank>file"" ) ; fclose ( ifp ) ; fclose ( ofp ) ; return 0 ; }","if ( strncmp ( line , ""currentfile<S2SV_blank>eexec"" , 17 ) == 0 && isspace ( ( unsigned char ) line [ 17 ] ) ) {for ( p = line + 18 ;isspace ( ( unsigned char ) * p ) ;p ++ ) ;+ q ;set_lenIV ( line ) ;else if ( ( p = strstr ( line , ""string<S2SV_blank>currentfile"" ) ) ) {set_cs_start ( line ) ;if ( ( p = strstr ( line , ""/Subrs"" ) ) && isdigit ( ( unsigned char ) p [ 7 ] ) ) ever_active = active = 1 ;else if ( ( p = strstr ( line , ""/CharStrings"" ) ) && isdigit ( ( unsigned char ) p [ 13 ] ) ) ever_active = active = 1 ;for ( q = p ;isspace ( ( unsigned char ) * q ) && * q != \'\\\q ++ ) ;",490
659,"buggy line: cwe id:CWE-416context: static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No<S2SV_blank>USB<S2SV_blank>device<S2SV_blank>connected<S2SV_blank>to<S2SV_blank>ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>USB<S2SV_blank>console<S2SV_blank>port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ;  usb_autopm_put_interface ( serial -> interface ) ;  error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",info -> port = NULL ;,491
660,"buggy line: usb_autopm_put_interface ( serial -> interface ) ;error_get_interface : usb_serial_put ( serial ) ;cwe id:CWE-416context: static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No<S2SV_blank>USB<S2SV_blank>device<S2SV_blank>connected<S2SV_blank>to<S2SV_blank>ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>USB<S2SV_blank>console<S2SV_blank>port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ;  usb_autopm_put_interface ( serial -> interface ) ;  error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }",usb_autopm_put_interface ( serial -> interface ) ;error_get_interface : usb_serial_put ( serial ) ;,491
661,"buggy line: lockdep_set_class ( & cpuctx -> ctx . mutex , & cpuctx_mutex ) ;lockdep_set_class ( & cpuctx -> ctx . lock , & cpuctx_lock ) ;cpuctx -> ctx . type = cpu_context ;cpuctx -> ctx . pmu = pmu ;cwe id:CWE-264context: int perf_pmu_register ( struct pmu * pmu , const char * name , int type ) { int cpu , ret ; mutex_lock ( & pmus_lock ) ; ret = - ENOMEM ; pmu -> pmu_disable_count = alloc_percpu ( int ) ; if ( ! pmu -> pmu_disable_count ) goto unlock ; pmu -> type = - 1 ; if ( ! name ) goto skip_type ; pmu -> name = name ; if ( type < 0 ) { type = idr_alloc ( & pmu_idr , pmu , PERF_TYPE_MAX , 0 , GFP_KERNEL ) ; if ( type < 0 ) { ret = type ; goto free_pdc ; } } pmu -> type = type ; if ( pmu_bus_running ) { ret = pmu_dev_alloc ( pmu ) ; if ( ret ) goto free_idr ; } skip_type : pmu -> pmu_cpu_context = find_pmu_context ( pmu -> task_ctx_nr ) ; if ( pmu -> pmu_cpu_context ) goto got_cpu_context ; ret = - ENOMEM ; pmu -> pmu_cpu_context = alloc_percpu ( struct perf_cpu_context ) ; if ( ! pmu -> pmu_cpu_context ) goto free_dev ; for_each_possible_cpu ( cpu ) { struct perf_cpu_context * cpuctx ; cpuctx = per_cpu_ptr ( pmu -> pmu_cpu_context , cpu ) ; __perf_event_init_context ( & cpuctx -> ctx ) ; lockdep_set_class ( & cpuctx -> ctx . mutex , & cpuctx_mutex ) ; lockdep_set_class ( & cpuctx -> ctx . lock , & cpuctx_lock ) ;  cpuctx -> ctx . type = cpu_context ;  cpuctx -> ctx . pmu = pmu ; __perf_cpu_hrtimer_init ( cpuctx , cpu ) ; INIT_LIST_HEAD ( & cpuctx -> rotation_list ) ; cpuctx -> unique_pmu = pmu ; } got_cpu_context : if ( ! pmu -> start_txn ) { if ( pmu -> pmu_enable ) { pmu -> start_txn = perf_pmu_start_txn ; pmu -> commit_txn = perf_pmu_commit_txn ; pmu -> cancel_txn = perf_pmu_cancel_txn ; } else { pmu -> start_txn = perf_pmu_nop_void ; pmu -> commit_txn = perf_pmu_nop_int ; pmu -> cancel_txn = perf_pmu_nop_void ; } } if ( ! pmu -> pmu_enable ) { pmu -> pmu_enable = perf_pmu_nop_void ; pmu -> pmu_disable = perf_pmu_nop_void ; } if ( ! pmu -> event_idx ) pmu -> event_idx = perf_event_idx_default ; list_add_rcu ( & pmu -> entry , & pmus ) ; ret = 0 ; unlock : mutex_unlock ( & pmus_lock ) ; return ret ; free_dev : device_del ( pmu -> dev ) ; put_device ( pmu -> dev ) ; free_idr : if ( pmu -> type >= PERF_TYPE_MAX ) idr_remove ( & pmu_idr , pmu -> type ) ; free_pdc : free_percpu ( pmu -> pmu_disable_count ) ; goto unlock ; }",lockdep_set_class ( & cpuctx -> ctx . pmu = pmu ;,492
662,"buggy line: static ssize_t aio_setup_single_vector ( struct kiocb * kiocb , int rw , char __user * buf , unsigned long * nr_segs , size_t len ,  struct iovec * iovec )  {return 0 ;}cwe id:CWE-000context: static ssize_t aio_setup_single_vector ( struct kiocb * kiocb , int rw , char __user * buf , unsigned long * nr_segs , size_t len ,  struct iovec * iovec )  { if ( unlikely ( ! access_ok ( ! rw , buf , len ) ) ) return - EFAULT ; iovec -> iov_base = buf ; iovec -> iov_len = len ; * nr_segs = 1 ;  return 0 ;  }","static ssize_t aio_setup_single_vector ( struct kiocb * kiocb , int rw , char __user * buf , unsigned long * nr_segs , size_t len , struct iovec * iovec , struct iov_iter * iter ) {if ( len > MAX_RW_COUNT ) len = MAX_RW_COUNT ;iov_iter_init ( iter , rw , iovec , * nr_segs , len ) ;return 0 ;}",493
663,"buggy line: int groups_per_flex = 0 ;size_t size ;groups_per_flex = 1 << sbi -> s_log_groups_per_flex ;if ( groups_per_flex < 2 ) {sbi -> s_log_groups_per_flex = 0 ;return 1 ;}cwe id:CWE-189context: static int ext4_fill_flex_info ( struct super_block * sb ) { struct ext4_sb_info * sbi = EXT4_SB ( sb ) ; struct ext4_group_desc * gdp = NULL ; ext4_group_t flex_group_count ; ext4_group_t flex_group ;  int groups_per_flex = 0 ;  size_t size ; int i ; sbi -> s_log_groups_per_flex = sbi -> s_es -> s_log_groups_per_flex ;  groups_per_flex = 1 << sbi -> s_log_groups_per_flex ;   if ( groups_per_flex < 2 ) {  sbi -> s_log_groups_per_flex = 0 ; return 1 ; } flex_group_count = ( ( sbi -> s_groups_count + groups_per_flex - 1 ) + ( ( le16_to_cpu ( sbi -> s_es -> s_reserved_gdt_blocks ) + 1 ) << EXT4_DESC_PER_BLOCK_BITS ( sb ) ) ) / groups_per_flex ; size = flex_group_count * sizeof ( struct flex_groups ) ; sbi -> s_flex_groups = ext4_kvzalloc ( size , GFP_KERNEL ) ; if ( sbi -> s_flex_groups == NULL ) { ext4_msg ( sb , KERN_ERR , ""not<S2SV_blank>enough<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>%u<S2SV_blank>flex<S2SV_blank>groups"" , flex_group_count ) ; goto failed ; } for ( i = 0 ; i < sbi -> s_groups_count ; i ++ ) { gdp = ext4_get_group_desc ( sb , i , NULL ) ; flex_group = ext4_flex_group ( sbi , i ) ; atomic_add ( ext4_free_inodes_count ( sb , gdp ) , & sbi -> s_flex_groups [ flex_group ] . free_inodes ) ; atomic_add ( ext4_free_group_clusters ( sb , gdp ) , & sbi -> s_flex_groups [ flex_group ] . free_clusters ) ; atomic_add ( ext4_used_dirs_count ( sb , gdp ) , & sbi -> s_flex_groups [ flex_group ] . used_dirs ) ; } return 1 ; failed : return 0 ; }",unsigned int groups_per_flex = 0 ;size_t size ;,494
664,"buggy line: if ( unlikely ( chunk_length < required_length ) )  return 0 ;cwe id:CWE-399context: static inline int sctp_chunk_length_valid ( struct sctp_chunk * chunk , __u16 required_length ) { __u16 chunk_length = ntohs ( chunk -> chunk_hdr -> length ) ;  if ( unlikely ( chunk_length < required_length ) )  return 0 ; return 1 ; }",if ( unlikely ( chunk -> pdiscard ) ) return 0 ;if ( unlikely ( chunk_length < required_length ) ) return 0 ;,495
665,"buggy line: for ( i = 0 ;++ i ) {n = cJSON_CreateString ( strings [ i ] ) ;if ( ! i )  a -> child = n ;cwe id:CWE-119context: cJSON * cJSON_CreateStringArray ( const char * * strings , int count ) { int i ; cJSON * n = 0 , * p = 0 , * a = cJSON_CreateArray ( ) ;  for ( i = 0 ; a && i < count ; ++ i ) {  n = cJSON_CreateString ( strings [ i ] ) ;  if ( ! i )  a -> child = n ; else suffix_object ( p , n ) ; p = n ; } return a ; }",for ( i = 0 ;+ i ) {i ++ ) {n = cJSON_CreateString ( strings [ i ] ) ;if ( ! n ) {cJSON_Delete ( a ) ;return 0 ;}if ( ! i ) a -> child = n ;,496
666,"buggy line: cwe id:CWE-287context: int m_authenticate ( struct Client * cptr , struct Client * sptr , int parc , char * parv [ ] ) { struct Client * acptr ; int first = 0 ; char realhost [ HOSTLEN + 3 ] ; char * hoststr = ( cli_sockhost ( cptr ) ? cli_sockhost ( cptr ) : cli_sock_ip ( cptr ) ) ; if ( ! CapActive ( cptr , CAP_SASL ) ) return 0 ; if ( parc < 2 ) return need_more_params ( cptr , ""AUTHENTICATE"" ) ; if ( strlen ( parv [ 1 ] ) > 400 ) return send_reply ( cptr , ERR_SASLTOOLONG ) ; if ( IsSASLComplete ( cptr ) ) return send_reply ( cptr , ERR_SASLALREADY ) ; if ( ! ( acptr = cli_saslagent ( cptr ) ) ) { if ( strcmp ( feature_str ( FEAT_SASL_SERVER ) , ""*"" ) ) acptr = find_match_server ( ( char * ) feature_str ( FEAT_SASL_SERVER ) ) ; else acptr = NULL ; } if ( ! acptr && strcmp ( feature_str ( FEAT_SASL_SERVER ) , ""*"" ) ) return send_reply ( cptr , ERR_SASLFAIL , "":<S2SV_blank>service<S2SV_blank>unavailable"" ) ; if ( acptr && IsMe ( acptr ) ) return 0 ; if ( ! cli_saslcookie ( cptr ) ) { do { cli_saslcookie ( cptr ) = ircrandom ( ) & 0x7fffffff ; } while ( ! cli_saslcookie ( cptr ) ) ; first = 1 ; } if ( strchr ( hoststr , ':' ) != NULL ) ircd_snprintf ( 0 , realhost , sizeof ( realhost ) , ""[%s]"" , hoststr ) ; else ircd_strncpy ( realhost , hoststr , sizeof ( realhost ) ) ; if ( acptr ) { if ( first ) {  if ( ! EmptyString ( cli_sslclifp ( cptr ) ) )  sendcmdto_one ( & me , CMD_SASL , acptr , ""%C<S2SV_blank>%C!%u.%u<S2SV_blank>S<S2SV_blank>%s<S2SV_blank>:%s"" , acptr , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] , cli_sslclifp ( cptr ) ) ; else sendcmdto_one ( & me , CMD_SASL , acptr , ""%C<S2SV_blank>%C!%u.%u<S2SV_blank>S<S2SV_blank>:%s"" , acptr , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] ) ; if ( feature_bool ( FEAT_SASL_SENDHOST ) ) sendcmdto_one ( & me , CMD_SASL , acptr , ""%C<S2SV_blank>%C!%u.%u<S2SV_blank>H<S2SV_blank>:%s@%s:%s"" , acptr , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , cli_username ( cptr ) , realhost , cli_sock_ip ( cptr ) ) ; } else { sendcmdto_one ( & me , CMD_SASL , acptr , ""%C<S2SV_blank>%C!%u.%u<S2SV_blank>C<S2SV_blank>:%s"" , acptr , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] ) ; } } else { if ( first ) {  if ( ! EmptyString ( cli_sslclifp ( cptr ) ) )  sendcmdto_serv_butone ( & me , CMD_SASL , cptr , ""*<S2SV_blank>%C!%u.%u<S2SV_blank>S<S2SV_blank>%s<S2SV_blank>:%s"" , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] , cli_sslclifp ( cptr ) ) ; else sendcmdto_serv_butone ( & me , CMD_SASL , cptr , ""*<S2SV_blank>%C!%u.%u<S2SV_blank>S<S2SV_blank>:%s"" , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] ) ; if ( feature_bool ( FEAT_SASL_SENDHOST ) ) sendcmdto_serv_butone ( & me , CMD_SASL , cptr , ""*<S2SV_blank>%C!%u.%u<S2SV_blank>H<S2SV_blank>:%s@%s:%s"" , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , cli_username ( cptr ) , realhost , cli_sock_ip ( cptr ) ) ; } else { sendcmdto_serv_butone ( & me , CMD_SASL , cptr , ""*<S2SV_blank>%C!%u.%u<S2SV_blank>C<S2SV_blank>:%s"" , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] ) ; } } if ( ! t_active ( & cli_sasltimeout ( cptr ) ) ) timer_add ( timer_init ( & cli_sasltimeout ( cptr ) ) , sasl_timeout_callback , ( void * ) cptr , TT_RELATIVE , feature_int ( FEAT_SASL_TIMEOUT ) ) ; return 0 ; }","if ( * parv [ 1 ] == \':\' || strchr ( parv [ 1 ] , \'<S2SV_blank>\' ) ) return exit_client ( cptr , sptr , sptr , ""Malformed<S2SV_blank>AUTHENTICATE"" ) ;",497
667,"buggy line: if ( ! EmptyString ( cli_sslclifp ( cptr ) ) )  sendcmdto_one ( & me , CMD_SASL , acptr , ""%C<S2SV_blank>%C!%u.%u<S2SV_blank>S<S2SV_blank>%s<S2SV_blank>:%s"" , acptr , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] , cli_sslclifp ( cptr ) ) ;cwe id:CWE-287context: int m_authenticate ( struct Client * cptr , struct Client * sptr , int parc , char * parv [ ] ) { struct Client * acptr ; int first = 0 ; char realhost [ HOSTLEN + 3 ] ; char * hoststr = ( cli_sockhost ( cptr ) ? cli_sockhost ( cptr ) : cli_sock_ip ( cptr ) ) ; if ( ! CapActive ( cptr , CAP_SASL ) ) return 0 ; if ( parc < 2 ) return need_more_params ( cptr , ""AUTHENTICATE"" ) ; if ( strlen ( parv [ 1 ] ) > 400 ) return send_reply ( cptr , ERR_SASLTOOLONG ) ; if ( IsSASLComplete ( cptr ) ) return send_reply ( cptr , ERR_SASLALREADY ) ; if ( ! ( acptr = cli_saslagent ( cptr ) ) ) { if ( strcmp ( feature_str ( FEAT_SASL_SERVER ) , ""*"" ) ) acptr = find_match_server ( ( char * ) feature_str ( FEAT_SASL_SERVER ) ) ; else acptr = NULL ; } if ( ! acptr && strcmp ( feature_str ( FEAT_SASL_SERVER ) , ""*"" ) ) return send_reply ( cptr , ERR_SASLFAIL , "":<S2SV_blank>service<S2SV_blank>unavailable"" ) ; if ( acptr && IsMe ( acptr ) ) return 0 ; if ( ! cli_saslcookie ( cptr ) ) { do { cli_saslcookie ( cptr ) = ircrandom ( ) & 0x7fffffff ; } while ( ! cli_saslcookie ( cptr ) ) ; first = 1 ; } if ( strchr ( hoststr , ':' ) != NULL ) ircd_snprintf ( 0 , realhost , sizeof ( realhost ) , ""[%s]"" , hoststr ) ; else ircd_strncpy ( realhost , hoststr , sizeof ( realhost ) ) ; if ( acptr ) { if ( first ) {  if ( ! EmptyString ( cli_sslclifp ( cptr ) ) )  sendcmdto_one ( & me , CMD_SASL , acptr , ""%C<S2SV_blank>%C!%u.%u<S2SV_blank>S<S2SV_blank>%s<S2SV_blank>:%s"" , acptr , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] , cli_sslclifp ( cptr ) ) ; else sendcmdto_one ( & me , CMD_SASL , acptr , ""%C<S2SV_blank>%C!%u.%u<S2SV_blank>S<S2SV_blank>:%s"" , acptr , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] ) ; if ( feature_bool ( FEAT_SASL_SENDHOST ) ) sendcmdto_one ( & me , CMD_SASL , acptr , ""%C<S2SV_blank>%C!%u.%u<S2SV_blank>H<S2SV_blank>:%s@%s:%s"" , acptr , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , cli_username ( cptr ) , realhost , cli_sock_ip ( cptr ) ) ; } else { sendcmdto_one ( & me , CMD_SASL , acptr , ""%C<S2SV_blank>%C!%u.%u<S2SV_blank>C<S2SV_blank>:%s"" , acptr , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] ) ; } } else { if ( first ) {  if ( ! EmptyString ( cli_sslclifp ( cptr ) ) )  sendcmdto_serv_butone ( & me , CMD_SASL , cptr , ""*<S2SV_blank>%C!%u.%u<S2SV_blank>S<S2SV_blank>%s<S2SV_blank>:%s"" , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] , cli_sslclifp ( cptr ) ) ; else sendcmdto_serv_butone ( & me , CMD_SASL , cptr , ""*<S2SV_blank>%C!%u.%u<S2SV_blank>S<S2SV_blank>:%s"" , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] ) ; if ( feature_bool ( FEAT_SASL_SENDHOST ) ) sendcmdto_serv_butone ( & me , CMD_SASL , cptr , ""*<S2SV_blank>%C!%u.%u<S2SV_blank>H<S2SV_blank>:%s@%s:%s"" , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , cli_username ( cptr ) , realhost , cli_sock_ip ( cptr ) ) ; } else { sendcmdto_serv_butone ( & me , CMD_SASL , cptr , ""*<S2SV_blank>%C!%u.%u<S2SV_blank>C<S2SV_blank>:%s"" , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] ) ; } } if ( ! t_active ( & cli_sasltimeout ( cptr ) ) ) timer_add ( timer_init ( & cli_sasltimeout ( cptr ) ) , sasl_timeout_callback , ( void * ) cptr , TT_RELATIVE , feature_int ( FEAT_SASL_TIMEOUT ) ) ; return 0 ; }","if ( * parv [ 1 ] == \':\' || strchr ( parv [ 1 ] , \'<S2SV_blank>\' ) ) return exit_client ( cptr , sptr , sptr , ""Malformed<S2SV_blank>AUTHENTICATE"" ) ;if ( ! EmptyString ( cli_sslclifp ( cptr ) ) ) sendcmdto_one ( & me , CMD_SASL , acptr , ""%C<S2SV_blank>%C!%u.%u<S2SV_blank>S<S2SV_blank>%s<S2SV_blank>:%s"" , acptr , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] , cli_sslclifp ( cptr ) ) ;",497
668,"buggy line: if ( ! EmptyString ( cli_sslclifp ( cptr ) ) )  sendcmdto_serv_butone ( & me , CMD_SASL , cptr , ""*<S2SV_blank>%C!%u.%u<S2SV_blank>S<S2SV_blank>%s<S2SV_blank>:%s"" , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] , cli_sslclifp ( cptr ) ) ;cwe id:CWE-287context: int m_authenticate ( struct Client * cptr , struct Client * sptr , int parc , char * parv [ ] ) { struct Client * acptr ; int first = 0 ; char realhost [ HOSTLEN + 3 ] ; char * hoststr = ( cli_sockhost ( cptr ) ? cli_sockhost ( cptr ) : cli_sock_ip ( cptr ) ) ; if ( ! CapActive ( cptr , CAP_SASL ) ) return 0 ; if ( parc < 2 ) return need_more_params ( cptr , ""AUTHENTICATE"" ) ; if ( strlen ( parv [ 1 ] ) > 400 ) return send_reply ( cptr , ERR_SASLTOOLONG ) ; if ( IsSASLComplete ( cptr ) ) return send_reply ( cptr , ERR_SASLALREADY ) ; if ( ! ( acptr = cli_saslagent ( cptr ) ) ) { if ( strcmp ( feature_str ( FEAT_SASL_SERVER ) , ""*"" ) ) acptr = find_match_server ( ( char * ) feature_str ( FEAT_SASL_SERVER ) ) ; else acptr = NULL ; } if ( ! acptr && strcmp ( feature_str ( FEAT_SASL_SERVER ) , ""*"" ) ) return send_reply ( cptr , ERR_SASLFAIL , "":<S2SV_blank>service<S2SV_blank>unavailable"" ) ; if ( acptr && IsMe ( acptr ) ) return 0 ; if ( ! cli_saslcookie ( cptr ) ) { do { cli_saslcookie ( cptr ) = ircrandom ( ) & 0x7fffffff ; } while ( ! cli_saslcookie ( cptr ) ) ; first = 1 ; } if ( strchr ( hoststr , ':' ) != NULL ) ircd_snprintf ( 0 , realhost , sizeof ( realhost ) , ""[%s]"" , hoststr ) ; else ircd_strncpy ( realhost , hoststr , sizeof ( realhost ) ) ; if ( acptr ) { if ( first ) {  if ( ! EmptyString ( cli_sslclifp ( cptr ) ) )  sendcmdto_one ( & me , CMD_SASL , acptr , ""%C<S2SV_blank>%C!%u.%u<S2SV_blank>S<S2SV_blank>%s<S2SV_blank>:%s"" , acptr , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] , cli_sslclifp ( cptr ) ) ; else sendcmdto_one ( & me , CMD_SASL , acptr , ""%C<S2SV_blank>%C!%u.%u<S2SV_blank>S<S2SV_blank>:%s"" , acptr , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] ) ; if ( feature_bool ( FEAT_SASL_SENDHOST ) ) sendcmdto_one ( & me , CMD_SASL , acptr , ""%C<S2SV_blank>%C!%u.%u<S2SV_blank>H<S2SV_blank>:%s@%s:%s"" , acptr , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , cli_username ( cptr ) , realhost , cli_sock_ip ( cptr ) ) ; } else { sendcmdto_one ( & me , CMD_SASL , acptr , ""%C<S2SV_blank>%C!%u.%u<S2SV_blank>C<S2SV_blank>:%s"" , acptr , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] ) ; } } else { if ( first ) {  if ( ! EmptyString ( cli_sslclifp ( cptr ) ) )  sendcmdto_serv_butone ( & me , CMD_SASL , cptr , ""*<S2SV_blank>%C!%u.%u<S2SV_blank>S<S2SV_blank>%s<S2SV_blank>:%s"" , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] , cli_sslclifp ( cptr ) ) ; else sendcmdto_serv_butone ( & me , CMD_SASL , cptr , ""*<S2SV_blank>%C!%u.%u<S2SV_blank>S<S2SV_blank>:%s"" , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] ) ; if ( feature_bool ( FEAT_SASL_SENDHOST ) ) sendcmdto_serv_butone ( & me , CMD_SASL , cptr , ""*<S2SV_blank>%C!%u.%u<S2SV_blank>H<S2SV_blank>:%s@%s:%s"" , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , cli_username ( cptr ) , realhost , cli_sock_ip ( cptr ) ) ; } else { sendcmdto_serv_butone ( & me , CMD_SASL , cptr , ""*<S2SV_blank>%C!%u.%u<S2SV_blank>C<S2SV_blank>:%s"" , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] ) ; } } if ( ! t_active ( & cli_sasltimeout ( cptr ) ) ) timer_add ( timer_init ( & cli_sasltimeout ( cptr ) ) , sasl_timeout_callback , ( void * ) cptr , TT_RELATIVE , feature_int ( FEAT_SASL_TIMEOUT ) ) ; return 0 ; }","if ( ! EmptyString ( cli_sslclifp ( cptr ) ) ) sendcmdto_serv_butone ( & me , CMD_SASL , cptr , ""*<S2SV_blank>%C!%u.%u<S2SV_blank>S<S2SV_blank>%s<S2SV_blank>:%s"" , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] , cli_sslclifp ( cptr ) ) ;",497
669,"buggy line: else # endif  for ( i = 0 ;i <= w - sizeof ( long ) ;long a = * ( long * ) ( src1 + i ) ;cwe id:CWE-189context: static void diff_bytes_c ( uint8_t * dst , const uint8_t * src1 , const uint8_t * src2 , int w ) { long i ; # if ! HAVE_FAST_UNALIGNED if ( ( long ) src2 & ( sizeof ( long ) - 1 ) ) { for ( i = 0 ; i + 7 < w ; i += 8 ) { dst [ i + 0 ] = src1 [ i + 0 ] - src2 [ i + 0 ] ; dst [ i + 1 ] = src1 [ i + 1 ] - src2 [ i + 1 ] ; dst [ i + 2 ] = src1 [ i + 2 ] - src2 [ i + 2 ] ; dst [ i + 3 ] = src1 [ i + 3 ] - src2 [ i + 3 ] ; dst [ i + 4 ] = src1 [ i + 4 ] - src2 [ i + 4 ] ; dst [ i + 5 ] = src1 [ i + 5 ] - src2 [ i + 5 ] ; dst [ i + 6 ] = src1 [ i + 6 ] - src2 [ i + 6 ] ; dst [ i + 7 ] = src1 [ i + 7 ] - src2 [ i + 7 ] ; } } else # endif  for ( i = 0 ; i <= w - sizeof ( long ) ; i += sizeof ( long ) ) {  long a = * ( long * ) ( src1 + i ) ; long b = * ( long * ) ( src2 + i ) ; * ( long * ) ( dst + i ) = ( ( a | pb_80 ) - ( b & pb_7f ) ) ^ ( ( a ^ b ^ pb_80 ) & pb_80 ) ; } for ( ; i < w ; i ++ ) dst [ i + 0 ] = src1 [ i + 0 ] - src2 [ i + 0 ] ; }",else # endif for ( i = 0 ;i <= w - ( int ) sizeof ( long ) ;long a = * ( long * ) ( src1 + i ) ;,498
670,"buggy line: match_length += callback_args -> forward_matches ;if ( callback_args -> full_word ) {cwe id:CWE-125context: int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ;  match_length += callback_args -> forward_matches ;  if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }",match_length += callback_args -> forward_matches ;assert ( match_offset + match_length <= callback_args -> data_size ) ;if ( callback_args -> full_word ) {,499
671,"buggy line: if ( ( options . allow_streamlocal_forwarding & FORWARD_LOCAL ) != 0 &&  ! no_port_forwarding_flag && ! options . disable_forwarding ) {c = channel_connect_to_path ( target , ""direct-streamlocal@openssh.com"" , ""direct-streamlocal"" ) ;cwe id:CWE-264context: static Channel * server_request_direct_streamlocal ( void ) { Channel * c = NULL ; char * target , * originator ; u_short originator_port ; target = packet_get_string ( NULL ) ; originator = packet_get_string ( NULL ) ; originator_port = packet_get_int ( ) ; packet_check_eom ( ) ; debug ( ""server_request_direct_streamlocal:<S2SV_blank>originator<S2SV_blank>%s<S2SV_blank>port<S2SV_blank>%d,<S2SV_blank>target<S2SV_blank>%s"" , originator , originator_port , target ) ; if ( ( options . allow_streamlocal_forwarding & FORWARD_LOCAL ) != 0 &&  ! no_port_forwarding_flag && ! options . disable_forwarding ) {  c = channel_connect_to_path ( target , ""direct-streamlocal@openssh.com"" , ""direct-streamlocal"" ) ; } else { logit ( ""refused<S2SV_blank>streamlocal<S2SV_blank>port<S2SV_blank>forward:<S2SV_blank>"" ""originator<S2SV_blank>%s<S2SV_blank>port<S2SV_blank>%d,<S2SV_blank>target<S2SV_blank>%s"" , originator , originator_port , target ) ; } free ( originator ) ; free ( target ) ; return c ; }","if ( ( options . allow_streamlocal_forwarding & FORWARD_LOCAL ) != 0 && ! no_port_forwarding_flag && ! options . disable_forwarding && use_privsep ) {c = channel_connect_to_path ( target , ""direct-streamlocal@openssh.com"" , ""direct-streamlocal"" ) ;",500
672,"buggy line: if ( ! bitstream_read_bit ( bc ) ) {if ( hc -> current >= 256 ) {cwe id:CWE-119context: static int smacker_decode_tree ( BitstreamContext * bc , HuffContext * hc , uint32_t prefix , int length ) {  if ( ! bitstream_read_bit ( bc ) ) {  if ( hc -> current >= 256 ) { av_log ( NULL , AV_LOG_ERROR , ""Tree<S2SV_blank>size<S2SV_blank>exceeded!\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( length ) { hc -> bits [ hc -> current ] = prefix ; hc -> lengths [ hc -> current ] = length ; } else { hc -> bits [ hc -> current ] = 0 ; hc -> lengths [ hc -> current ] = 0 ; } hc -> values [ hc -> current ] = bitstream_read ( bc , 8 ) ; hc -> current ++ ; if ( hc -> maxlength < length ) hc -> maxlength = length ; return 0 ; } else { int r ; length ++ ; r = smacker_decode_tree ( bc , hc , prefix , length ) ; if ( r ) return r ; return smacker_decode_tree ( bc , hc , prefix | ( 1 << ( length - 1 ) ) , length ) ; } }","if ( length > SMKTREE_DECODE_MAX_RECURSION ) {av_log ( NULL , AV_LOG_ERROR , ""Maximum<S2SV_blank>tree<S2SV_blank>recursion<S2SV_blank>level<S2SV_blank>exceeded.\\\return AVERROR_INVALIDDATA ;}if ( ! bitstream_read_bit ( bc ) ) {if ( hc -> current >= 256 ) {",501
673,"buggy line: m -> msg_name = address ;}cwe id:CWE-20context: int verify_iovec ( struct msghdr * m , struct iovec * iov , struct sockaddr_storage * address , int mode ) { int size , ct , err ; if ( m -> msg_namelen ) { if ( mode == VERIFY_READ ) { void __user * namep ; namep = ( void __user __force * ) m -> msg_name ; err = move_addr_to_kernel ( namep , m -> msg_namelen , address ) ; if ( err < 0 ) return err ; }  m -> msg_name = address ;  } else { m -> msg_name = NULL ; } size = m -> msg_iovlen * sizeof ( struct iovec ) ; if ( copy_from_user ( iov , ( void __user __force * ) m -> msg_iov , size ) ) return - EFAULT ; m -> msg_iov = iov ; err = 0 ; for ( ct = 0 ; ct < m -> msg_iovlen ; ct ++ ) { size_t len = iov [ ct ] . iov_len ; if ( len > INT_MAX - err ) { len = INT_MAX - err ; iov [ ct ] . iov_len = len ; } err += len ; } return err ; }",if ( m -> msg_name ) m -> msg_name = address ;},502
674,"buggy line: if ( obj == Py_None ) {* out = NULL ;return 0 ;}isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Module_type ) ;if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) {int res ;Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ;cwe id:CWE-125context: int obj2ast_mod ( PyObject * obj , mod_ty * out , PyArena * arena ) { int isinstance ; PyObject * tmp = NULL ; if ( obj == Py_None ) { * out = NULL ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Module_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; asdl_seq * type_ignores ;  if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) {  int res ; Py_ssize_t len ;  Py_ssize_t i ;  tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Module<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) {  stmt_ty value ;   res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;  if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Module<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; }  asdl_seq_SET ( body , i , value ) ;  } Py_CLEAR ( tmp ) ;  } else {  PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_type_ignores ) ) { int res ; Py_ssize_t len ;  Py_ssize_t i ;  tmp = _PyObject_GetAttrId ( obj , & PyId_type_ignores ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Module<S2SV_blank>field<S2SV_blank>\\""type_ignores\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; type_ignores = _Ta3_asdl_seq_new ( len , arena ) ; if ( type_ignores == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) {  type_ignore_ty value ;   res = obj2ast_type_ignore ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;  if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Module<S2SV_blank>field<S2SV_blank>\\""type_ignores\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; }  asdl_seq_SET ( type_ignores , i , value ) ;  } Py_CLEAR ( tmp ) ;  } else {  PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""type_ignores\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module"" ) ; return 1 ; } * out = Module ( body , type_ignores , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Interactive_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ; Py_ssize_t len ;  Py_ssize_t i ;  tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Interactive<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) {  stmt_ty value ;   res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;  if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Interactive<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; }  asdl_seq_SET ( body , i , value ) ;  } Py_CLEAR ( tmp ) ;  } else {  PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Interactive"" ) ; return 1 ; } * out = Interactive ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Expression_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty body ; if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ;  tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ;  if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & body , arena ) ; if ( res != 0 ) goto failed ;  Py_CLEAR ( tmp ) ;  } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Expression"" ) ; return 1 ; } * out = Expression ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) FunctionType_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * argtypes ; expr_ty returns ;  if ( _PyObject_HasAttrId ( obj , & PyId_argtypes ) ) {  int res ; Py_ssize_t len ;  Py_ssize_t i ;  tmp = _PyObject_GetAttrId ( obj , & PyId_argtypes ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""FunctionType<S2SV_blank>field<S2SV_blank>\\""argtypes\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; argtypes = _Ta3_asdl_seq_new ( len , arena ) ; if ( argtypes == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) {  expr_ty value ;   res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;  if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""FunctionType<S2SV_blank>field<S2SV_blank>\\""argtypes\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; }  asdl_seq_SET ( argtypes , i , value ) ;  } Py_CLEAR ( tmp ) ;  } else {   PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""argtypes\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType"" ) ;  return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_returns ) ) { int res ;  tmp = _PyObject_GetAttrId ( obj , & PyId_returns ) ;  if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & returns , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""returns\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType"" ) ; return 1 ; } * out = FunctionType ( argtypes , returns , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Suite_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ; Py_ssize_t len ;  Py_ssize_t i ;  tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Suite<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) {  stmt_ty value ;   res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;  if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Suite<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; }  asdl_seq_SET ( body , i , value ) ;  } Py_CLEAR ( tmp ) ;  } else {   PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Suite"" ) ;  return 1 ; } * out = Suite ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } PyErr_Format ( PyExc_TypeError , ""expected<S2SV_blank>some<S2SV_blank>sort<S2SV_blank>of<S2SV_blank>mod,<S2SV_blank>but<S2SV_blank>got<S2SV_blank>%R"" , obj ) ; failed : Py_XDECREF ( tmp ) ; return 1 ; }","if ( lookup_attr_id ( obj , ( PyObject * ) Module_type ) ;if ( _PyObject_HasAttrId ( obj , & PyId_body , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""body\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module"" ) ;return 1 ;}else {int res ;Py_ssize_t i ;",503
675,"buggy line: stmt_ty value ;res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( body , i , value ) ;}}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""body\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module"" ) ;if ( _PyObject_HasAttrId ( obj , & PyId_type_ignores ) ) {Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_type_ignores ) ;cwe id:CWE-125context: int obj2ast_mod ( PyObject * obj , mod_ty * out , PyArena * arena ) { int isinstance ; PyObject * tmp = NULL ; if ( obj == Py_None ) { * out = NULL ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Module_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; asdl_seq * type_ignores ;  if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) {  int res ; Py_ssize_t len ;  Py_ssize_t i ;  tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Module<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) {  stmt_ty value ;   res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;  if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Module<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; }  asdl_seq_SET ( body , i , value ) ;  } Py_CLEAR ( tmp ) ;  } else {  PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_type_ignores ) ) { int res ; Py_ssize_t len ;  Py_ssize_t i ;  tmp = _PyObject_GetAttrId ( obj , & PyId_type_ignores ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Module<S2SV_blank>field<S2SV_blank>\\""type_ignores\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; type_ignores = _Ta3_asdl_seq_new ( len , arena ) ; if ( type_ignores == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) {  type_ignore_ty value ;   res = obj2ast_type_ignore ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;  if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Module<S2SV_blank>field<S2SV_blank>\\""type_ignores\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; }  asdl_seq_SET ( type_ignores , i , value ) ;  } Py_CLEAR ( tmp ) ;  } else {  PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""type_ignores\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module"" ) ; return 1 ; } * out = Module ( body , type_ignores , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Interactive_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ; Py_ssize_t len ;  Py_ssize_t i ;  tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Interactive<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) {  stmt_ty value ;   res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;  if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Interactive<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; }  asdl_seq_SET ( body , i , value ) ;  } Py_CLEAR ( tmp ) ;  } else {  PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Interactive"" ) ; return 1 ; } * out = Interactive ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Expression_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty body ; if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ;  tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ;  if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & body , arena ) ; if ( res != 0 ) goto failed ;  Py_CLEAR ( tmp ) ;  } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Expression"" ) ; return 1 ; } * out = Expression ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) FunctionType_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * argtypes ; expr_ty returns ;  if ( _PyObject_HasAttrId ( obj , & PyId_argtypes ) ) {  int res ; Py_ssize_t len ;  Py_ssize_t i ;  tmp = _PyObject_GetAttrId ( obj , & PyId_argtypes ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""FunctionType<S2SV_blank>field<S2SV_blank>\\""argtypes\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; argtypes = _Ta3_asdl_seq_new ( len , arena ) ; if ( argtypes == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) {  expr_ty value ;   res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;  if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""FunctionType<S2SV_blank>field<S2SV_blank>\\""argtypes\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; }  asdl_seq_SET ( argtypes , i , value ) ;  } Py_CLEAR ( tmp ) ;  } else {   PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""argtypes\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType"" ) ;  return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_returns ) ) { int res ;  tmp = _PyObject_GetAttrId ( obj , & PyId_returns ) ;  if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & returns , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""returns\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType"" ) ; return 1 ; } * out = FunctionType ( argtypes , returns , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Suite_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ; Py_ssize_t len ;  Py_ssize_t i ;  tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Suite<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) {  stmt_ty value ;   res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;  if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Suite<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; }  asdl_seq_SET ( body , i , value ) ;  } Py_CLEAR ( tmp ) ;  } else {   PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Suite"" ) ;  return 1 ; } * out = Suite ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } PyErr_Format ( PyExc_TypeError , ""expected<S2SV_blank>some<S2SV_blank>sort<S2SV_blank>of<S2SV_blank>mod,<S2SV_blank>but<S2SV_blank>got<S2SV_blank>%R"" , obj ) ; failed : Py_XDECREF ( tmp ) ; return 1 ; }","stmt_ty val ;res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( body , i , val ) ;}}if ( lookup_attr_id ( obj , & PyId_type_ignores , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""type_ignores\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module"" ) ;else {Py_ssize_t i ;",503
676,"buggy line: type_ignore_ty value ;res = obj2ast_type_ignore ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( type_ignores , i , value ) ;}}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""type_ignores\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module"" ) ;return 1 ;cwe id:CWE-125context: int obj2ast_mod ( PyObject * obj , mod_ty * out , PyArena * arena ) { int isinstance ; PyObject * tmp = NULL ; if ( obj == Py_None ) { * out = NULL ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Module_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; asdl_seq * type_ignores ;  if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) {  int res ; Py_ssize_t len ;  Py_ssize_t i ;  tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Module<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) {  stmt_ty value ;   res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;  if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Module<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; }  asdl_seq_SET ( body , i , value ) ;  } Py_CLEAR ( tmp ) ;  } else {  PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_type_ignores ) ) { int res ; Py_ssize_t len ;  Py_ssize_t i ;  tmp = _PyObject_GetAttrId ( obj , & PyId_type_ignores ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Module<S2SV_blank>field<S2SV_blank>\\""type_ignores\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; type_ignores = _Ta3_asdl_seq_new ( len , arena ) ; if ( type_ignores == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) {  type_ignore_ty value ;   res = obj2ast_type_ignore ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;  if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Module<S2SV_blank>field<S2SV_blank>\\""type_ignores\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; }  asdl_seq_SET ( type_ignores , i , value ) ;  } Py_CLEAR ( tmp ) ;  } else {  PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""type_ignores\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module"" ) ; return 1 ; } * out = Module ( body , type_ignores , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Interactive_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ; Py_ssize_t len ;  Py_ssize_t i ;  tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Interactive<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) {  stmt_ty value ;   res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;  if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Interactive<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; }  asdl_seq_SET ( body , i , value ) ;  } Py_CLEAR ( tmp ) ;  } else {  PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Interactive"" ) ; return 1 ; } * out = Interactive ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Expression_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty body ; if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ;  tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ;  if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & body , arena ) ; if ( res != 0 ) goto failed ;  Py_CLEAR ( tmp ) ;  } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Expression"" ) ; return 1 ; } * out = Expression ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) FunctionType_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * argtypes ; expr_ty returns ;  if ( _PyObject_HasAttrId ( obj , & PyId_argtypes ) ) {  int res ; Py_ssize_t len ;  Py_ssize_t i ;  tmp = _PyObject_GetAttrId ( obj , & PyId_argtypes ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""FunctionType<S2SV_blank>field<S2SV_blank>\\""argtypes\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; argtypes = _Ta3_asdl_seq_new ( len , arena ) ; if ( argtypes == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) {  expr_ty value ;   res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;  if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""FunctionType<S2SV_blank>field<S2SV_blank>\\""argtypes\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; }  asdl_seq_SET ( argtypes , i , value ) ;  } Py_CLEAR ( tmp ) ;  } else {   PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""argtypes\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType"" ) ;  return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_returns ) ) { int res ;  tmp = _PyObject_GetAttrId ( obj , & PyId_returns ) ;  if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & returns , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""returns\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType"" ) ; return 1 ; } * out = FunctionType ( argtypes , returns , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Suite_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ; Py_ssize_t len ;  Py_ssize_t i ;  tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Suite<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) {  stmt_ty value ;   res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;  if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Suite<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; }  asdl_seq_SET ( body , i , value ) ;  } Py_CLEAR ( tmp ) ;  } else {   PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Suite"" ) ;  return 1 ; } * out = Suite ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } PyErr_Format ( PyExc_TypeError , ""expected<S2SV_blank>some<S2SV_blank>sort<S2SV_blank>of<S2SV_blank>mod,<S2SV_blank>but<S2SV_blank>got<S2SV_blank>%R"" , obj ) ; failed : Py_XDECREF ( tmp ) ; return 1 ; }","type_ignore_ty val ;res = obj2ast_type_ignore ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( type_ignores , i , val ) ;}",503
677,"buggy line: if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) {Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ;cwe id:CWE-125context: int obj2ast_mod ( PyObject * obj , mod_ty * out , PyArena * arena ) { int isinstance ; PyObject * tmp = NULL ; if ( obj == Py_None ) { * out = NULL ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Module_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; asdl_seq * type_ignores ;  if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) {  int res ; Py_ssize_t len ;  Py_ssize_t i ;  tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Module<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) {  stmt_ty value ;   res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;  if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Module<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; }  asdl_seq_SET ( body , i , value ) ;  } Py_CLEAR ( tmp ) ;  } else {  PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_type_ignores ) ) { int res ; Py_ssize_t len ;  Py_ssize_t i ;  tmp = _PyObject_GetAttrId ( obj , & PyId_type_ignores ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Module<S2SV_blank>field<S2SV_blank>\\""type_ignores\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; type_ignores = _Ta3_asdl_seq_new ( len , arena ) ; if ( type_ignores == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) {  type_ignore_ty value ;   res = obj2ast_type_ignore ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;  if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Module<S2SV_blank>field<S2SV_blank>\\""type_ignores\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; }  asdl_seq_SET ( type_ignores , i , value ) ;  } Py_CLEAR ( tmp ) ;  } else {  PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""type_ignores\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module"" ) ; return 1 ; } * out = Module ( body , type_ignores , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Interactive_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ; Py_ssize_t len ;  Py_ssize_t i ;  tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Interactive<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) {  stmt_ty value ;   res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;  if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Interactive<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; }  asdl_seq_SET ( body , i , value ) ;  } Py_CLEAR ( tmp ) ;  } else {  PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Interactive"" ) ; return 1 ; } * out = Interactive ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Expression_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty body ; if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ;  tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ;  if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & body , arena ) ; if ( res != 0 ) goto failed ;  Py_CLEAR ( tmp ) ;  } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Expression"" ) ; return 1 ; } * out = Expression ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) FunctionType_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * argtypes ; expr_ty returns ;  if ( _PyObject_HasAttrId ( obj , & PyId_argtypes ) ) {  int res ; Py_ssize_t len ;  Py_ssize_t i ;  tmp = _PyObject_GetAttrId ( obj , & PyId_argtypes ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""FunctionType<S2SV_blank>field<S2SV_blank>\\""argtypes\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; argtypes = _Ta3_asdl_seq_new ( len , arena ) ; if ( argtypes == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) {  expr_ty value ;   res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;  if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""FunctionType<S2SV_blank>field<S2SV_blank>\\""argtypes\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; }  asdl_seq_SET ( argtypes , i , value ) ;  } Py_CLEAR ( tmp ) ;  } else {   PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""argtypes\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType"" ) ;  return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_returns ) ) { int res ;  tmp = _PyObject_GetAttrId ( obj , & PyId_returns ) ;  if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & returns , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""returns\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType"" ) ; return 1 ; } * out = FunctionType ( argtypes , returns , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Suite_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ; Py_ssize_t len ;  Py_ssize_t i ;  tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Suite<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) {  stmt_ty value ;   res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;  if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Suite<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; }  asdl_seq_SET ( body , i , value ) ;  } Py_CLEAR ( tmp ) ;  } else {   PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Suite"" ) ;  return 1 ; } * out = Suite ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } PyErr_Format ( PyExc_TypeError , ""expected<S2SV_blank>some<S2SV_blank>sort<S2SV_blank>of<S2SV_blank>mod,<S2SV_blank>but<S2SV_blank>got<S2SV_blank>%R"" , obj ) ; failed : Py_XDECREF ( tmp ) ; return 1 ; }","if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""body\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Interactive"" ) ;return 1 ;}else {Py_ssize_t i ;",503
678,"buggy line: stmt_ty value ;res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( body , i , value ) ;}}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""body\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Interactive"" ) ;return 1 ;cwe id:CWE-125context: int obj2ast_mod ( PyObject * obj , mod_ty * out , PyArena * arena ) { int isinstance ; PyObject * tmp = NULL ; if ( obj == Py_None ) { * out = NULL ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Module_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; asdl_seq * type_ignores ;  if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) {  int res ; Py_ssize_t len ;  Py_ssize_t i ;  tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Module<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) {  stmt_ty value ;   res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;  if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Module<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; }  asdl_seq_SET ( body , i , value ) ;  } Py_CLEAR ( tmp ) ;  } else {  PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_type_ignores ) ) { int res ; Py_ssize_t len ;  Py_ssize_t i ;  tmp = _PyObject_GetAttrId ( obj , & PyId_type_ignores ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Module<S2SV_blank>field<S2SV_blank>\\""type_ignores\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; type_ignores = _Ta3_asdl_seq_new ( len , arena ) ; if ( type_ignores == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) {  type_ignore_ty value ;   res = obj2ast_type_ignore ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;  if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Module<S2SV_blank>field<S2SV_blank>\\""type_ignores\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; }  asdl_seq_SET ( type_ignores , i , value ) ;  } Py_CLEAR ( tmp ) ;  } else {  PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""type_ignores\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module"" ) ; return 1 ; } * out = Module ( body , type_ignores , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Interactive_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ; Py_ssize_t len ;  Py_ssize_t i ;  tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Interactive<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) {  stmt_ty value ;   res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;  if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Interactive<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; }  asdl_seq_SET ( body , i , value ) ;  } Py_CLEAR ( tmp ) ;  } else {  PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Interactive"" ) ; return 1 ; } * out = Interactive ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Expression_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty body ; if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ;  tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ;  if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & body , arena ) ; if ( res != 0 ) goto failed ;  Py_CLEAR ( tmp ) ;  } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Expression"" ) ; return 1 ; } * out = Expression ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) FunctionType_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * argtypes ; expr_ty returns ;  if ( _PyObject_HasAttrId ( obj , & PyId_argtypes ) ) {  int res ; Py_ssize_t len ;  Py_ssize_t i ;  tmp = _PyObject_GetAttrId ( obj , & PyId_argtypes ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""FunctionType<S2SV_blank>field<S2SV_blank>\\""argtypes\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; argtypes = _Ta3_asdl_seq_new ( len , arena ) ; if ( argtypes == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) {  expr_ty value ;   res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;  if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""FunctionType<S2SV_blank>field<S2SV_blank>\\""argtypes\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; }  asdl_seq_SET ( argtypes , i , value ) ;  } Py_CLEAR ( tmp ) ;  } else {   PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""argtypes\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType"" ) ;  return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_returns ) ) { int res ;  tmp = _PyObject_GetAttrId ( obj , & PyId_returns ) ;  if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & returns , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""returns\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType"" ) ; return 1 ; } * out = FunctionType ( argtypes , returns , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Suite_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ; Py_ssize_t len ;  Py_ssize_t i ;  tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Suite<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) {  stmt_ty value ;   res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;  if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Suite<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; }  asdl_seq_SET ( body , i , value ) ;  } Py_CLEAR ( tmp ) ;  } else {   PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Suite"" ) ;  return 1 ; } * out = Suite ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } PyErr_Format ( PyExc_TypeError , ""expected<S2SV_blank>some<S2SV_blank>sort<S2SV_blank>of<S2SV_blank>mod,<S2SV_blank>but<S2SV_blank>got<S2SV_blank>%R"" , obj ) ; failed : Py_XDECREF ( tmp ) ; return 1 ; }","stmt_ty val ;res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( body , i , val ) ;}",503
679,"buggy line: if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) {tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""body\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Expression"" ) ;return 1 ;if ( isinstance == - 1 ) {return 1 ;}if ( isinstance ) {asdl_seq * argtypes ;expr_ty returns ;if ( _PyObject_HasAttrId ( obj , & PyId_argtypes ) ) {int res ;Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_argtypes ) ;cwe id:CWE-125context: int obj2ast_mod ( PyObject * obj , mod_ty * out , PyArena * arena ) { int isinstance ; PyObject * tmp = NULL ; if ( obj == Py_None ) { * out = NULL ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Module_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; asdl_seq * type_ignores ;  if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) {  int res ; Py_ssize_t len ;  Py_ssize_t i ;  tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Module<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) {  stmt_ty value ;   res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;  if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Module<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; }  asdl_seq_SET ( body , i , value ) ;  } Py_CLEAR ( tmp ) ;  } else {  PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_type_ignores ) ) { int res ; Py_ssize_t len ;  Py_ssize_t i ;  tmp = _PyObject_GetAttrId ( obj , & PyId_type_ignores ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Module<S2SV_blank>field<S2SV_blank>\\""type_ignores\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; type_ignores = _Ta3_asdl_seq_new ( len , arena ) ; if ( type_ignores == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) {  type_ignore_ty value ;   res = obj2ast_type_ignore ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;  if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Module<S2SV_blank>field<S2SV_blank>\\""type_ignores\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; }  asdl_seq_SET ( type_ignores , i , value ) ;  } Py_CLEAR ( tmp ) ;  } else {  PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""type_ignores\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module"" ) ; return 1 ; } * out = Module ( body , type_ignores , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Interactive_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ; Py_ssize_t len ;  Py_ssize_t i ;  tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Interactive<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) {  stmt_ty value ;   res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;  if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Interactive<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; }  asdl_seq_SET ( body , i , value ) ;  } Py_CLEAR ( tmp ) ;  } else {  PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Interactive"" ) ; return 1 ; } * out = Interactive ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Expression_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty body ; if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ;  tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ;  if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & body , arena ) ; if ( res != 0 ) goto failed ;  Py_CLEAR ( tmp ) ;  } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Expression"" ) ; return 1 ; } * out = Expression ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) FunctionType_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * argtypes ; expr_ty returns ;  if ( _PyObject_HasAttrId ( obj , & PyId_argtypes ) ) {  int res ; Py_ssize_t len ;  Py_ssize_t i ;  tmp = _PyObject_GetAttrId ( obj , & PyId_argtypes ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""FunctionType<S2SV_blank>field<S2SV_blank>\\""argtypes\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; argtypes = _Ta3_asdl_seq_new ( len , arena ) ; if ( argtypes == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) {  expr_ty value ;   res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;  if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""FunctionType<S2SV_blank>field<S2SV_blank>\\""argtypes\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; }  asdl_seq_SET ( argtypes , i , value ) ;  } Py_CLEAR ( tmp ) ;  } else {   PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""argtypes\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType"" ) ;  return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_returns ) ) { int res ;  tmp = _PyObject_GetAttrId ( obj , & PyId_returns ) ;  if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & returns , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""returns\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType"" ) ; return 1 ; } * out = FunctionType ( argtypes , returns , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Suite_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ; Py_ssize_t len ;  Py_ssize_t i ;  tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Suite<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) {  stmt_ty value ;   res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;  if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Suite<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; }  asdl_seq_SET ( body , i , value ) ;  } Py_CLEAR ( tmp ) ;  } else {   PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Suite"" ) ;  return 1 ; } * out = Suite ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } PyErr_Format ( PyExc_TypeError , ""expected<S2SV_blank>some<S2SV_blank>sort<S2SV_blank>of<S2SV_blank>mod,<S2SV_blank>but<S2SV_blank>got<S2SV_blank>%R"" , obj ) ; failed : Py_XDECREF ( tmp ) ; return 1 ; }","if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""body\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Expression"" ) ;return 1 ;}else {Py_CLEAR ( tmp ) ;if ( lookup_attr_id ( obj , & PyId_argtypes ) ) {int res ;Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_argtypes ) ;",503
680,"buggy line: expr_ty value ;res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( argtypes , i , value ) ;}}PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""argtypes\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType"" ) ;return 1 ;tmp = _PyObject_GetAttrId ( obj , & PyId_returns ) ;if ( tmp == NULL ) goto failed ;cwe id:CWE-125context: int obj2ast_mod ( PyObject * obj , mod_ty * out , PyArena * arena ) { int isinstance ; PyObject * tmp = NULL ; if ( obj == Py_None ) { * out = NULL ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Module_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; asdl_seq * type_ignores ;  if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) {  int res ; Py_ssize_t len ;  Py_ssize_t i ;  tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Module<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) {  stmt_ty value ;   res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;  if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Module<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; }  asdl_seq_SET ( body , i , value ) ;  } Py_CLEAR ( tmp ) ;  } else {  PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_type_ignores ) ) { int res ; Py_ssize_t len ;  Py_ssize_t i ;  tmp = _PyObject_GetAttrId ( obj , & PyId_type_ignores ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Module<S2SV_blank>field<S2SV_blank>\\""type_ignores\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; type_ignores = _Ta3_asdl_seq_new ( len , arena ) ; if ( type_ignores == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) {  type_ignore_ty value ;   res = obj2ast_type_ignore ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;  if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Module<S2SV_blank>field<S2SV_blank>\\""type_ignores\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; }  asdl_seq_SET ( type_ignores , i , value ) ;  } Py_CLEAR ( tmp ) ;  } else {  PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""type_ignores\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module"" ) ; return 1 ; } * out = Module ( body , type_ignores , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Interactive_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ; Py_ssize_t len ;  Py_ssize_t i ;  tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Interactive<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) {  stmt_ty value ;   res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;  if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Interactive<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; }  asdl_seq_SET ( body , i , value ) ;  } Py_CLEAR ( tmp ) ;  } else {  PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Interactive"" ) ; return 1 ; } * out = Interactive ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Expression_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty body ; if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ;  tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ;  if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & body , arena ) ; if ( res != 0 ) goto failed ;  Py_CLEAR ( tmp ) ;  } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Expression"" ) ; return 1 ; } * out = Expression ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) FunctionType_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * argtypes ; expr_ty returns ;  if ( _PyObject_HasAttrId ( obj , & PyId_argtypes ) ) {  int res ; Py_ssize_t len ;  Py_ssize_t i ;  tmp = _PyObject_GetAttrId ( obj , & PyId_argtypes ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""FunctionType<S2SV_blank>field<S2SV_blank>\\""argtypes\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; argtypes = _Ta3_asdl_seq_new ( len , arena ) ; if ( argtypes == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) {  expr_ty value ;   res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;  if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""FunctionType<S2SV_blank>field<S2SV_blank>\\""argtypes\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; }  asdl_seq_SET ( argtypes , i , value ) ;  } Py_CLEAR ( tmp ) ;  } else {   PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""argtypes\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType"" ) ;  return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_returns ) ) { int res ;  tmp = _PyObject_GetAttrId ( obj , & PyId_returns ) ;  if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & returns , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""returns\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType"" ) ; return 1 ; } * out = FunctionType ( argtypes , returns , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Suite_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ; Py_ssize_t len ;  Py_ssize_t i ;  tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Suite<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) {  stmt_ty value ;   res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;  if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Suite<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; }  asdl_seq_SET ( body , i , value ) ;  } Py_CLEAR ( tmp ) ;  } else {   PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Suite"" ) ;  return 1 ; } * out = Suite ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } PyErr_Format ( PyExc_TypeError , ""expected<S2SV_blank>some<S2SV_blank>sort<S2SV_blank>of<S2SV_blank>mod,<S2SV_blank>but<S2SV_blank>got<S2SV_blank>%R"" , obj ) ; failed : Py_XDECREF ( tmp ) ; return 1 ; }","expr_ty value ;res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( argtypes , i , value ) ;}}PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""argtypes\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType"" ) ;return 1 ;tmp = _PyObject_GetAttrId ( obj , & PyId_returns ) ;if ( tmp == NULL ) goto failed ;",503
681,"buggy line: Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ;cwe id:CWE-125context: int obj2ast_mod ( PyObject * obj , mod_ty * out , PyArena * arena ) { int isinstance ; PyObject * tmp = NULL ; if ( obj == Py_None ) { * out = NULL ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Module_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; asdl_seq * type_ignores ;  if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) {  int res ; Py_ssize_t len ;  Py_ssize_t i ;  tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Module<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) {  stmt_ty value ;   res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;  if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Module<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; }  asdl_seq_SET ( body , i , value ) ;  } Py_CLEAR ( tmp ) ;  } else {  PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_type_ignores ) ) { int res ; Py_ssize_t len ;  Py_ssize_t i ;  tmp = _PyObject_GetAttrId ( obj , & PyId_type_ignores ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Module<S2SV_blank>field<S2SV_blank>\\""type_ignores\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; type_ignores = _Ta3_asdl_seq_new ( len , arena ) ; if ( type_ignores == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) {  type_ignore_ty value ;   res = obj2ast_type_ignore ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;  if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Module<S2SV_blank>field<S2SV_blank>\\""type_ignores\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; }  asdl_seq_SET ( type_ignores , i , value ) ;  } Py_CLEAR ( tmp ) ;  } else {  PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""type_ignores\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module"" ) ; return 1 ; } * out = Module ( body , type_ignores , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Interactive_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ; Py_ssize_t len ;  Py_ssize_t i ;  tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Interactive<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) {  stmt_ty value ;   res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;  if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Interactive<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; }  asdl_seq_SET ( body , i , value ) ;  } Py_CLEAR ( tmp ) ;  } else {  PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Interactive"" ) ; return 1 ; } * out = Interactive ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Expression_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty body ; if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ;  tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ;  if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & body , arena ) ; if ( res != 0 ) goto failed ;  Py_CLEAR ( tmp ) ;  } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Expression"" ) ; return 1 ; } * out = Expression ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) FunctionType_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * argtypes ; expr_ty returns ;  if ( _PyObject_HasAttrId ( obj , & PyId_argtypes ) ) {  int res ; Py_ssize_t len ;  Py_ssize_t i ;  tmp = _PyObject_GetAttrId ( obj , & PyId_argtypes ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""FunctionType<S2SV_blank>field<S2SV_blank>\\""argtypes\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; argtypes = _Ta3_asdl_seq_new ( len , arena ) ; if ( argtypes == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) {  expr_ty value ;   res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;  if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""FunctionType<S2SV_blank>field<S2SV_blank>\\""argtypes\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; }  asdl_seq_SET ( argtypes , i , value ) ;  } Py_CLEAR ( tmp ) ;  } else {   PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""argtypes\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType"" ) ;  return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_returns ) ) { int res ;  tmp = _PyObject_GetAttrId ( obj , & PyId_returns ) ;  if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & returns , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""returns\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType"" ) ; return 1 ; } * out = FunctionType ( argtypes , returns , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Suite_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ; Py_ssize_t len ;  Py_ssize_t i ;  tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Suite<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) {  stmt_ty value ;   res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;  if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Suite<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; }  asdl_seq_SET ( body , i , value ) ;  } Py_CLEAR ( tmp ) ;  } else {   PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Suite"" ) ;  return 1 ; } * out = Suite ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } PyErr_Format ( PyExc_TypeError , ""expected<S2SV_blank>some<S2SV_blank>sort<S2SV_blank>of<S2SV_blank>mod,<S2SV_blank>but<S2SV_blank>got<S2SV_blank>%R"" , obj ) ; failed : Py_XDECREF ( tmp ) ; return 1 ; }",Py_ssize_t i ;,503
682,"buggy line: stmt_ty value ;res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( body , i , value ) ;}}PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""body\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Suite"" ) ;return 1 ;cwe id:CWE-125context: int obj2ast_mod ( PyObject * obj , mod_ty * out , PyArena * arena ) { int isinstance ; PyObject * tmp = NULL ; if ( obj == Py_None ) { * out = NULL ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Module_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; asdl_seq * type_ignores ;  if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) {  int res ; Py_ssize_t len ;  Py_ssize_t i ;  tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Module<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) {  stmt_ty value ;   res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;  if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Module<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; }  asdl_seq_SET ( body , i , value ) ;  } Py_CLEAR ( tmp ) ;  } else {  PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_type_ignores ) ) { int res ; Py_ssize_t len ;  Py_ssize_t i ;  tmp = _PyObject_GetAttrId ( obj , & PyId_type_ignores ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Module<S2SV_blank>field<S2SV_blank>\\""type_ignores\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; type_ignores = _Ta3_asdl_seq_new ( len , arena ) ; if ( type_ignores == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) {  type_ignore_ty value ;   res = obj2ast_type_ignore ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;  if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Module<S2SV_blank>field<S2SV_blank>\\""type_ignores\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; }  asdl_seq_SET ( type_ignores , i , value ) ;  } Py_CLEAR ( tmp ) ;  } else {  PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""type_ignores\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module"" ) ; return 1 ; } * out = Module ( body , type_ignores , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Interactive_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ; Py_ssize_t len ;  Py_ssize_t i ;  tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Interactive<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) {  stmt_ty value ;   res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;  if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Interactive<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; }  asdl_seq_SET ( body , i , value ) ;  } Py_CLEAR ( tmp ) ;  } else {  PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Interactive"" ) ; return 1 ; } * out = Interactive ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Expression_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty body ; if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ;  tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ;  if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & body , arena ) ; if ( res != 0 ) goto failed ;  Py_CLEAR ( tmp ) ;  } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Expression"" ) ; return 1 ; } * out = Expression ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) FunctionType_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * argtypes ; expr_ty returns ;  if ( _PyObject_HasAttrId ( obj , & PyId_argtypes ) ) {  int res ; Py_ssize_t len ;  Py_ssize_t i ;  tmp = _PyObject_GetAttrId ( obj , & PyId_argtypes ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""FunctionType<S2SV_blank>field<S2SV_blank>\\""argtypes\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; argtypes = _Ta3_asdl_seq_new ( len , arena ) ; if ( argtypes == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) {  expr_ty value ;   res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;  if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""FunctionType<S2SV_blank>field<S2SV_blank>\\""argtypes\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; }  asdl_seq_SET ( argtypes , i , value ) ;  } Py_CLEAR ( tmp ) ;  } else {   PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""argtypes\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType"" ) ;  return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_returns ) ) { int res ;  tmp = _PyObject_GetAttrId ( obj , & PyId_returns ) ;  if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & returns , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""returns\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType"" ) ; return 1 ; } * out = FunctionType ( argtypes , returns , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Suite_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ; Py_ssize_t len ;  Py_ssize_t i ;  tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Suite<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) {  stmt_ty value ;   res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;  if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Suite<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; }  asdl_seq_SET ( body , i , value ) ;  } Py_CLEAR ( tmp ) ;  } else {   PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Suite"" ) ;  return 1 ; } * out = Suite ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } PyErr_Format ( PyExc_TypeError , ""expected<S2SV_blank>some<S2SV_blank>sort<S2SV_blank>of<S2SV_blank>mod,<S2SV_blank>but<S2SV_blank>got<S2SV_blank>%R"" , obj ) ; failed : Py_XDECREF ( tmp ) ; return 1 ; }","stmt_ty value ;res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( body , i , val ) ;}}if ( lookup_attr_id ( obj , & PyId_returns , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""body\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Suite"" ) ;return 1 ;}int res ;res = obj2ast_expr ( tmp , & returns , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}* out = Suite ( body , arena ) ;if ( * out == NULL ) goto failed ;return 0 ;}PyErr_Format ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""body\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Suite"" ) ;return 1 ;",503
683,"buggy line: int hstartcol ;if ( bufsize > QMFB_SPLITBUFSIZE ) {hstartcol = ( numrows + 1 - parity ) >> 1 ;m = numrows - hstartcol ;n = m ;srcptr = & a [ ( 1 - parity ) * stride ] ;cwe id:CWE-119context: void jpc_qmfb_split_col ( jpc_fix_t * a , int numrows , int stride , int parity ) { int bufsize = JPC_CEILDIVPOW2 ( numrows , 1 ) ; jpc_fix_t splitbuf [ QMFB_SPLITBUFSIZE ] ; jpc_fix_t * buf = splitbuf ; register jpc_fix_t * srcptr ; register jpc_fix_t * dstptr ; register int n ; register int m ;  int hstartcol ;  if ( bufsize > QMFB_SPLITBUFSIZE ) { if ( ! ( buf = jas_alloc2 ( bufsize , sizeof ( jpc_fix_t ) ) ) ) { abort ( ) ; } } if ( numrows >= 2 ) {  hstartcol = ( numrows + 1 - parity ) >> 1 ;   m = numrows - hstartcol ;  n = m ; dstptr = buf ; srcptr = & a [ ( 1 - parity ) * stride ] ; while ( n -- > 0 ) { * dstptr = * srcptr ; ++ dstptr ; srcptr += stride << 1 ; } dstptr = & a [ ( 1 - parity ) * stride ] ; srcptr = & a [ ( 2 - parity ) * stride ] ; n = numrows - m - ( ! parity ) ; while ( n -- > 0 ) { * dstptr = * srcptr ; dstptr += stride ; srcptr += stride << 1 ; }  dstptr = & a [ hstartcol * stride ] ;  srcptr = buf ; n = m ; while ( n -- > 0 ) { * dstptr = * srcptr ; dstptr += stride ; ++ srcptr ; } } if ( buf != splitbuf ) { jas_free ( buf ) ; } }",int hstartrow ;if ( bufsize > QMFB_SPLITBUFSIZE ) {hstartrow = ( numrows + 1 - parity ) >> 1 ;m = numrows - hstartrow ;n = m ;srcptr = & a [ hstartrow * stride ] ;,504
684,"buggy line: dstptr = & a [ hstartcol * stride ] ;srcptr = buf ;cwe id:CWE-119context: void jpc_qmfb_split_col ( jpc_fix_t * a , int numrows , int stride , int parity ) { int bufsize = JPC_CEILDIVPOW2 ( numrows , 1 ) ; jpc_fix_t splitbuf [ QMFB_SPLITBUFSIZE ] ; jpc_fix_t * buf = splitbuf ; register jpc_fix_t * srcptr ; register jpc_fix_t * dstptr ; register int n ; register int m ;  int hstartcol ;  if ( bufsize > QMFB_SPLITBUFSIZE ) { if ( ! ( buf = jas_alloc2 ( bufsize , sizeof ( jpc_fix_t ) ) ) ) { abort ( ) ; } } if ( numrows >= 2 ) {  hstartcol = ( numrows + 1 - parity ) >> 1 ;   m = numrows - hstartcol ;  n = m ; dstptr = buf ; srcptr = & a [ ( 1 - parity ) * stride ] ; while ( n -- > 0 ) { * dstptr = * srcptr ; ++ dstptr ; srcptr += stride << 1 ; } dstptr = & a [ ( 1 - parity ) * stride ] ; srcptr = & a [ ( 2 - parity ) * stride ] ; n = numrows - m - ( ! parity ) ; while ( n -- > 0 ) { * dstptr = * srcptr ; dstptr += stride ; srcptr += stride << 1 ; }  dstptr = & a [ hstartcol * stride ] ;  srcptr = buf ; n = m ; while ( n -- > 0 ) { * dstptr = * srcptr ; dstptr += stride ; ++ srcptr ; } } if ( buf != splitbuf ) { jas_free ( buf ) ; } }",dstptr = & a [ hstartcol * stride ] ;srcptr = buf ;,504
685,"buggy line: iwl_sta_ucode_activate ( priv , sta_id ) ;ret = 0 ;cwe id:CWE-119context: static int iwl_process_add_sta_resp ( struct iwl_priv * priv , struct iwl_addsta_cmd * addsta , struct iwl_rx_packet * pkt ) { u8 sta_id = addsta -> sta . sta_id ; unsigned long flags ; int ret = - EIO ; if ( pkt -> hdr . flags & IWL_CMD_FAILED_MSK ) { IWL_ERR ( priv , ""Bad<S2SV_blank>return<S2SV_blank>from<S2SV_blank>REPLY_ADD_STA<S2SV_blank>(0x%08X)\\n"" , pkt -> hdr . flags ) ; return ret ; } IWL_DEBUG_INFO ( priv , ""Processing<S2SV_blank>response<S2SV_blank>for<S2SV_blank>adding<S2SV_blank>station<S2SV_blank>%u\\n"" , sta_id ) ; spin_lock_irqsave ( & priv -> shrd -> sta_lock , flags ) ; switch ( pkt -> u . add_sta . status ) { case ADD_STA_SUCCESS_MSK : IWL_DEBUG_INFO ( priv , ""REPLY_ADD_STA<S2SV_blank>PASSED\\n"" ) ;  iwl_sta_ucode_activate ( priv , sta_id ) ;  ret = 0 ; break ; case ADD_STA_NO_ROOM_IN_TABLE : IWL_ERR ( priv , ""Adding<S2SV_blank>station<S2SV_blank>%d<S2SV_blank>failed,<S2SV_blank>no<S2SV_blank>room<S2SV_blank>in<S2SV_blank>table.\\n"" , sta_id ) ; break ; case ADD_STA_NO_BLOCK_ACK_RESOURCE : IWL_ERR ( priv , ""Adding<S2SV_blank>station<S2SV_blank>%d<S2SV_blank>failed,<S2SV_blank>no<S2SV_blank>block<S2SV_blank>ack<S2SV_blank>"" ""resource.\\n"" , sta_id ) ; break ; case ADD_STA_MODIFY_NON_EXIST_STA : IWL_ERR ( priv , ""Attempting<S2SV_blank>to<S2SV_blank>modify<S2SV_blank>non-existing<S2SV_blank>station<S2SV_blank>%d\\n"" , sta_id ) ; break ; default : IWL_DEBUG_ASSOC ( priv , ""Received<S2SV_blank>REPLY_ADD_STA:(0x%08X)\\n"" , pkt -> u . add_sta . status ) ; break ; } IWL_DEBUG_INFO ( priv , ""%s<S2SV_blank>station<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>addr<S2SV_blank>%pM\\n"" , priv -> stations [ sta_id ] . sta . mode == STA_CONTROL_MODIFY_MSK ? ""Modified"" : ""Added"" , sta_id , priv -> stations [ sta_id ] . sta . sta . addr ) ; IWL_DEBUG_INFO ( priv , ""%s<S2SV_blank>station<S2SV_blank>according<S2SV_blank>to<S2SV_blank>cmd<S2SV_blank>buffer<S2SV_blank>%pM\\n"" , priv -> stations [ sta_id ] . sta . mode == STA_CONTROL_MODIFY_MSK ? ""Modified"" : ""Added"" , addsta -> sta . addr ) ; spin_unlock_irqrestore ( & priv -> shrd -> sta_lock , flags ) ; return ret ; }","ret = iwl_sta_ucode_activate ( priv , sta_id ) ;",505
686,"buggy line: log_file = NULL ;}if ( ! name ) return ;file_name = make_file_name ( name , prog , namespace , instance ) ;log_file = fopen ( file_name , ""a"" ) ;if ( log_file ) {cwe id:CWE-59context: void open_log_file ( const char * name , const char * prog , const char * namespace , const char * instance ) { char * file_name ; if ( log_file ) { fclose ( log_file ) ; log_file = NULL ; } if ( ! name ) return ; file_name = make_file_name ( name , prog , namespace , instance ) ;  log_file = fopen ( file_name , ""a"" ) ;  if ( log_file ) { int n = fileno ( log_file ) ; fcntl ( n , F_SETFD , FD_CLOEXEC | fcntl ( n , F_GETFD ) ) ; fcntl ( n , F_SETFL , O_NONBLOCK | fcntl ( n , F_GETFL ) ) ; } FREE ( file_name ) ; }","log_file = fopen_safe ( file_name , ""a"" ) ;if ( log_file ) {",506
687,"buggy line: }cwe id:CWE-476context: void test_re ( ) { assert_true_rule ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/ssi/<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""mississippi\\tmississippi.mississippi\\nmississippi"" ) ; assert_true_rule ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/ssi(s|p)/<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""mississippi\\tmississippi.mississippi\\nmississippi"" ) ; assert_true_rule ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/ssim*/<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""mississippi\\tmississippi.mississippi\\nmississippi"" ) ; assert_true_rule ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/ssa?/<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""mississippi\\tmississippi.mississippi\\nmississippi"" ) ; assert_true_rule ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/Miss/<S2SV_blank>nocase<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""mississippi\\tmississippi.mississippi\\nmississippi"" ) ; assert_true_rule ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/(M|N)iss/<S2SV_blank>nocase<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""mississippi\\tmississippi.mississippi\\nmississippi"" ) ; assert_true_rule ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/[M-N]iss/<S2SV_blank>nocase<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""mississippi\\tmississippi.mississippi\\nmississippi"" ) ; assert_true_rule ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/(Mi|ssi)ssippi/<S2SV_blank>nocase<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""mississippi\\tmississippi.mississippi\\nmississippi"" ) ; assert_true_rule ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/ppi\\\\tmi/<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""mississippi\\tmississippi.mississippi\\nmississippi"" ) ; assert_true_rule ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/ppi\\\\.mi/<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""mississippi\\tmississippi.mississippi\\nmississippi"" ) ; assert_true_rule ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/^mississippi/<S2SV_blank>fullword<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""mississippi\\tmississippi.mississippi\\nmississippi"" ) ; assert_true_rule ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/mississippi.*mississippi$/s<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""mississippi\\tmississippi.mississippi\\nmississippi"" ) ; assert_false_rule ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/^ssi/<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""mississippi"" ) ; assert_false_rule ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/ssi$/<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""mississippi"" ) ; assert_false_rule ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/ssissi/<S2SV_blank>fullword<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""mississippi"" ) ; assert_false_rule ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/^[isp]+/<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""mississippi"" ) ; assert_regexp_syntax_error ( "")"" ) ; assert_true_regexp ( ""abc"" , ""abc"" , ""abc"" ) ; assert_false_regexp ( ""abc"" , ""xbc"" ) ; assert_false_regexp ( ""abc"" , ""axc"" ) ; assert_false_regexp ( ""abc"" , ""abx"" ) ; assert_true_regexp ( ""abc"" , ""xabcx"" , ""abc"" ) ; assert_true_regexp ( ""abc"" , ""ababc"" , ""abc"" ) ; assert_true_regexp ( ""a.c"" , ""abc"" , ""abc"" ) ; assert_false_regexp ( ""a.b"" , ""a\\nb"" ) ; assert_false_regexp ( ""a.*b"" , ""acc\\nccb"" ) ; assert_false_regexp ( ""a.{4,5}b"" , ""acc\\nccb"" ) ; assert_true_regexp ( ""a.b"" , ""a\\rb"" , ""a\\rb"" ) ; assert_true_regexp ( ""ab*c"" , ""abc"" , ""abc"" ) ; assert_true_regexp ( ""ab*c"" , ""ac"" , ""ac"" ) ; assert_true_regexp ( ""ab*bc"" , ""abc"" , ""abc"" ) ; assert_true_regexp ( ""ab*bc"" , ""abbc"" , ""abbc"" ) ; assert_true_regexp ( ""a.*bb"" , ""abbbb"" , ""abbbb"" ) ; assert_true_regexp ( ""a.*?bbb"" , ""abbbbbb"" , ""abbb"" ) ; assert_true_regexp ( ""a.*c"" , ""ac"" , ""ac"" ) ; assert_true_regexp ( ""a.*c"" , ""axyzc"" , ""axyzc"" ) ; assert_true_regexp ( ""ab+c"" , ""abbc"" , ""abbc"" ) ; assert_false_regexp ( ""ab+c"" , ""ac"" ) ; assert_true_regexp ( ""ab+"" , ""abbbb"" , ""abbbb"" ) ; assert_true_regexp ( ""ab+?"" , ""abbbb"" , ""ab"" ) ; assert_false_regexp ( ""ab+bc"" , ""abc"" ) ; assert_false_regexp ( ""ab+bc"" , ""abq"" ) ; assert_true_regexp ( ""a+b+c"" , ""aabbabc"" , ""abc"" ) ; assert_false_regexp ( ""ab?bc"" , ""abbbbc"" ) ; assert_true_regexp ( ""ab?c"" , ""abc"" , ""abc"" ) ; assert_true_regexp ( ""ab*?"" , ""abbb"" , ""a"" ) ; assert_true_regexp ( ""ab?c"" , ""abc"" , ""abc"" ) ; assert_true_regexp ( ""ab??"" , ""ab"" , ""a"" ) ; assert_true_regexp ( ""a(b|x)c"" , ""abc"" , ""abc"" ) ; assert_true_regexp ( ""a(b|x)c"" , ""axc"" , ""axc"" ) ; assert_true_regexp ( ""a(b|.)c"" , ""axc"" , ""axc"" ) ; assert_true_regexp ( ""a(b|x|y)c"" , ""ayc"" , ""ayc"" ) ; assert_true_regexp ( ""(a+|b)*"" , ""ab"" , ""ab"" ) ; assert_true_regexp ( ""a|b|c|d|e"" , ""e"" , ""e"" ) ; assert_true_regexp ( ""(a|b|c|d|e)f"" , ""ef"" , ""ef"" ) ; assert_true_regexp ( "".b{2}"" , ""abb"" , ""abb"" ) ; assert_true_regexp ( ""ab{1}c"" , ""abc"" , ""abc"" ) ; assert_true_regexp ( ""ab{1,2}c"" , ""abbc"" , ""abbc"" ) ; assert_true_regexp ( ""ab{1,}c"" , ""abbbc"" , ""abbbc"" ) ; assert_false_regexp ( ""ab{1,}b"" , ""ab"" ) ; assert_false_regexp ( ""ab{1}c"" , ""abbc"" ) ; assert_true_regexp ( ""ab{0,}c"" , ""ac"" , ""ac"" ) ; assert_true_regexp ( ""ab{0,}c"" , ""abbbc"" , ""abbbc"" ) ; assert_true_regexp ( ""ab{,3}c"" , ""abbbc"" , ""abbbc"" ) ; assert_false_regexp ( ""ab{,2}c"" , ""abbbc"" ) ; assert_false_regexp ( ""ab{4,5}bc"" , ""abbbbc"" ) ; assert_true_regexp ( ""ab{2,3}?"" , ""abbbbb"" , ""abb"" ) ; assert_true_regexp ( ""ab{.*}"" , ""ab{c}"" , ""ab{c}"" ) ; assert_true_regexp ( "".(aa){1,2}"" , ""aaaaaaaaaa"" , ""aaaaa"" ) ; assert_true_regexp ( ""a.(bc.){2}"" , ""aabcabca"" , ""aabcabca"" ) ; assert_true_regexp ( ""(ab{1,2}c){1,3}"" , ""abbcabc"" , ""abbcabc"" ) ; assert_true_regexp ( ""ab(c|cc){1,3}d"" , ""abccccccd"" , ""abccccccd"" ) ; assert_true_regexp ( ""a[bx]c"" , ""abc"" , ""abc"" ) ; assert_true_regexp ( ""a[bx]c"" , ""axc"" , ""axc"" ) ; assert_true_regexp ( ""a[0-9]*b"" , ""ab"" , ""ab"" ) ; assert_true_regexp ( ""a[0-9]*b"" , ""a0123456789b"" , ""a0123456789b"" ) ; assert_true_regexp ( ""[0-9a-f]+"" , ""0123456789abcdef"" , ""0123456789abcdef"" ) ; assert_true_regexp ( ""[0-9a-f]+"" , ""xyz0123456789xyz"" , ""0123456789"" ) ; assert_true_regexp ( ""a[\\\\s\\\\S]b"" , ""a<S2SV_blank>b"" , ""a<S2SV_blank>b"" ) ; assert_true_regexp ( ""a[\\\\d\\\\D]b"" , ""a1b"" , ""a1b"" ) ; assert_false_regexp ( ""[x-z]+"" , ""abc"" ) ; assert_true_regexp ( ""a[-]?c"" , ""ac"" , ""ac"" ) ; assert_true_regexp ( ""a[-b]"" , ""a-"" , ""a-"" ) ; assert_true_regexp ( ""a[-b]"" , ""ab"" , ""ab"" ) ; assert_true_regexp ( ""a[b-]"" , ""a-"" , ""a-"" ) ; assert_true_regexp ( ""a[b-]"" , ""ab"" , ""ab"" ) ; assert_true_regexp ( ""[a-c-e]"" , ""b"" , ""b"" ) ; assert_true_regexp ( ""[a-c-e]"" , ""-"" , ""-"" ) ; assert_false_regexp ( ""[a-c-e]"" , ""d"" ) ; assert_regexp_syntax_error ( ""[b-a]"" ) ; assert_regexp_syntax_error ( ""(abc"" ) ; assert_regexp_syntax_error ( ""abc)"" ) ; assert_regexp_syntax_error ( ""a[]b"" ) ; assert_regexp_syntax_error ( ""a\\\\"" ) ; assert_true_regexp ( ""a[\\\\-b]"" , ""a-"" , ""a-"" ) ; assert_true_regexp ( ""a[\\\\-b]"" , ""ab"" , ""ab"" ) ; assert_regexp_syntax_error ( ""a[\\\\"" ) ; assert_true_regexp ( ""a]"" , ""a]"" , ""a]"" ) ; assert_true_regexp ( ""a[]]b"" , ""a]b"" , ""a]b"" ) ; assert_true_regexp ( ""a[\\\\]]b"" , ""a]b"" , ""a]b"" ) ; assert_true_regexp ( ""a[^bc]d"" , ""aed"" , ""aed"" ) ; assert_false_regexp ( ""a[^bc]d"" , ""abd"" ) ; assert_true_regexp ( ""a[^-b]c"" , ""adc"" , ""adc"" ) ; assert_false_regexp ( ""a[^-b]c"" , ""a-c"" ) ; assert_false_regexp ( ""a[^]b]c"" , ""a]c"" ) ; assert_true_regexp ( ""a[^]b]c"" , ""adc"" , ""adc"" ) ; assert_true_regexp ( ""[^ab]*"" , ""cde"" , ""cde"" ) ; assert_regexp_syntax_error ( "")("" ) ; assert_true_regexp ( ""a\\\\sb"" , ""a<S2SV_blank>b"" , ""a<S2SV_blank>b"" ) ; assert_true_regexp ( ""a\\\\sb"" , ""a\\tb"" , ""a\\tb"" ) ; assert_true_regexp ( ""a\\\\sb"" , ""a\\rb"" , ""a\\rb"" ) ; assert_true_regexp ( ""a\\\\sb"" , ""a\\nb"" , ""a\\nb"" ) ; assert_true_regexp ( ""a\\\\sb"" , ""a\\vb"" , ""a\\vb"" ) ; assert_true_regexp ( ""a\\\\sb"" , ""a\\fb"" , ""a\\fb"" ) ; assert_false_regexp ( ""a\\\\Sb"" , ""a<S2SV_blank>b"" ) ; assert_false_regexp ( ""a\\\\Sb"" , ""a\\tb"" ) ; assert_false_regexp ( ""a\\\\Sb"" , ""a\\rb"" ) ; assert_false_regexp ( ""a\\\\Sb"" , ""a\\nb"" ) ; assert_false_regexp ( ""a\\\\Sb"" , ""a\\vb"" ) ; assert_false_regexp ( ""a\\\\Sb"" , ""a\\fb"" ) ; assert_true_regexp ( ""\\\\n\\\\r\\\\t\\\\f\\\\a"" , ""\\n\\r\\t\\f\\a"" , ""\\n\\r\\t\\f\\a"" ) ; assert_true_regexp ( ""[\\\\n][\\\\r][\\\\t][\\\\f][\\\\a]"" , ""\\n\\r\\t\\f\\a"" , ""\\n\\r\\t\\f\\a"" ) ; assert_true_regexp ( ""\\\\x01\\\\x02\\\\x03"" , ""\\x01\\x02\\x03"" , ""\\x01\\x02\\x03"" ) ; assert_true_regexp ( ""[\\\\x01-\\\\x03]+"" , ""\\x01\\x02\\x03"" , ""\\x01\\x02\\x03"" ) ; assert_false_regexp ( ""[\\\\x00-\\\\x02]+"" , ""\\x03\\x04\\x05"" ) ; assert_true_regexp ( ""[\\\\x5D]"" , ""]"" , ""]"" ) ; assert_true_regexp ( ""[\\\\0x5A-\\\\x5D]"" , ""\\x5B"" , ""\\x5B"" ) ; assert_true_regexp ( ""[\\\\x5D-\\\\x5F]"" , ""\\x5E"" , ""\\x5E"" ) ; assert_true_regexp ( ""[\\\\x5C-\\\\x5F]"" , ""\\x5E"" , ""\\x5E"" ) ; assert_true_regexp ( ""[\\\\x5D-\\\\x5F]"" , ""\\x5E"" , ""\\x5E"" ) ; assert_true_regexp ( ""a\\\\wc"" , ""abc"" , ""abc"" ) ; assert_true_regexp ( ""a\\\\wc"" , ""a_c"" , ""a_c"" ) ; assert_true_regexp ( ""a\\\\wc"" , ""a0c"" , ""a0c"" ) ; assert_false_regexp ( ""a\\\\wc"" , ""a*c"" ) ; assert_true_regexp ( ""\\\\w+"" , ""--ab_cd0123--"" , ""ab_cd0123"" ) ; assert_true_regexp ( ""[\\\\w]+"" , ""--ab_cd0123--"" , ""ab_cd0123"" ) ; assert_true_regexp ( ""\\\\D+"" , ""1234abc5678"" , ""abc"" ) ; assert_true_regexp ( ""[\\\\d]+"" , ""0123456789"" , ""0123456789"" ) ; assert_true_regexp ( ""[\\\\D]+"" , ""1234abc5678"" , ""abc"" ) ; assert_true_regexp ( ""[\\\\da-fA-F]+"" , ""123abc"" , ""123abc"" ) ; assert_false_regexp ( ""^(ab|cd)e"" , ""abcde"" ) ; assert_true_regexp ( ""(abc|)ef"" , ""abcdef"" , ""ef"" ) ; assert_true_regexp ( ""(abc|)ef"" , ""abcef"" , ""abcef"" ) ; assert_true_regexp ( ""\\\\babc"" , ""abc"" , ""abc"" ) ; assert_true_regexp ( ""abc\\\\b"" , ""abc"" , ""abc"" ) ; assert_false_regexp ( ""\\\\babc"" , ""1abc"" ) ; assert_false_regexp ( ""abc\\\\b"" , ""abc1"" ) ; assert_true_regexp ( ""abc\\\\s\\\\b"" , ""abc<S2SV_blank>x"" , ""abc<S2SV_blank>"" ) ; assert_false_regexp ( ""abc\\\\s\\\\b"" , ""abc<S2SV_blank><S2SV_blank>"" ) ; assert_true_regexp ( ""\\\\babc\\\\b"" , ""<S2SV_blank>abc<S2SV_blank>"" , ""abc"" ) ; assert_true_regexp ( ""\\\\b\\\\w\\\\w\\\\w\\\\b"" , ""<S2SV_blank>abc<S2SV_blank>"" , ""abc"" ) ; assert_true_regexp ( ""\\\\w\\\\w\\\\w\\\\b"" , ""abcd"" , ""bcd"" ) ; assert_true_regexp ( ""\\\\b\\\\w\\\\w\\\\w"" , ""abcd"" , ""abc"" ) ; assert_false_regexp ( ""\\\\b\\\\w\\\\w\\\\w\\\\b"" , ""abcd"" ) ; assert_false_regexp ( ""\\\\Babc"" , ""abc"" ) ; assert_false_regexp ( ""abc\\\\B"" , ""abc"" ) ; assert_true_regexp ( ""\\\\Babc"" , ""1abc"" , ""abc"" ) ; assert_true_regexp ( ""abc\\\\B"" , ""abc1"" , ""abc"" ) ; assert_false_regexp ( ""abc\\\\s\\\\B"" , ""abc<S2SV_blank>x"" ) ; assert_true_regexp ( ""abc\\\\s\\\\B"" , ""abc<S2SV_blank><S2SV_blank>"" , ""abc<S2SV_blank>"" ) ; assert_true_regexp ( ""\\\\w\\\\w\\\\w\\\\B"" , ""abcd"" , ""abc"" ) ; assert_true_regexp ( ""\\\\B\\\\w\\\\w\\\\w"" , ""abcd"" , ""bcd"" ) ; assert_false_regexp ( ""\\\\B\\\\w\\\\w\\\\w\\\\B"" , ""abcd"" ) ; assert_regexp_syntax_error ( ""(|abc)ef"" ) ; assert_true_regexp ( ""((a)(b)c)(d)"" , ""abcd"" , ""abcd"" ) ; assert_true_regexp ( ""(a|b)c*d"" , ""abcd"" , ""bcd"" ) ; assert_true_regexp ( ""(ab|ab*)bc"" , ""abc"" , ""abc"" ) ; assert_true_regexp ( ""a([bc]*)c*"" , ""abc"" , ""abc"" ) ; assert_true_regexp ( ""a([bc]*)c*"" , ""ac"" , ""ac"" ) ; assert_true_regexp ( ""a([bc]*)c*"" , ""a"" , ""a"" ) ; assert_true_regexp ( ""a([bc]*)(c*d)"" , ""abcd"" , ""abcd"" ) ; assert_true_regexp ( ""a([bc]+)(c*d)"" , ""abcd"" , ""abcd"" ) ; assert_true_regexp ( ""a([bc]*)(c+d)"" , ""abcd"" , ""abcd"" ) ; assert_true_regexp ( ""a[bcd]*dcdcde"" , ""adcdcde"" , ""adcdcde"" ) ; assert_false_regexp ( ""a[bcd]+dcdcde"" , ""adcdcde"" ) ; assert_true_regexp ( ""\\\\((.*),<S2SV_blank>(.*)\\\\)"" , ""(a,<S2SV_blank>b)"" , ""(a,<S2SV_blank>b)"" ) ; assert_true_regexp ( ""abc|123$"" , ""abcx"" , ""abc"" ) ; assert_false_regexp ( ""abc|123$"" , ""123x"" ) ; assert_true_regexp ( ""abc|^123"" , ""123"" , ""123"" ) ; assert_false_regexp ( ""abc|^123"" , ""x123"" ) ; assert_true_regexp ( ""^abc$"" , ""abc"" , ""abc"" ) ; assert_false_regexp ( ""^abc$"" , ""abcc"" ) ; assert_true_regexp ( ""^abc"" , ""abcc"" , ""abc"" ) ; assert_false_regexp ( ""^abc$"" , ""aabc"" ) ; assert_true_regexp ( ""abc$"" , ""aabc"" , ""abc"" ) ; assert_true_regexp ( ""^a(bc+|b[eh])g|.h$"" , ""abhg"" , ""abhg"" ) ; assert_true_regexp ( ""(bc+d$|ef*g.|h?i(j|k))"" , ""effgz"" , ""effgz"" ) ; assert_true_regexp ( ""(bc+d$|ef*g.|h?i(j|k))"" , ""ij"" , ""ij"" ) ; assert_false_regexp ( ""(bc+d$|ef*g.|h?i(j|k))"" , ""effg"" ) ; assert_false_regexp ( ""(bc+d$|ef*g.|h?i(j|k))"" , ""bcdd"" ) ; assert_true_regexp ( ""(bc+d$|ef*g.|h?i(j|k))"" , ""reffgz"" , ""effgz"" ) ; assert_true_regexp ( ""whatever|<S2SV_blank><S2SV_blank><S2SV_blank>x.<S2SV_blank><S2SV_blank><S2SV_blank>x"" , ""<S2SV_blank><S2SV_blank><S2SV_blank>xy<S2SV_blank><S2SV_blank><S2SV_blank>x"" , ""<S2SV_blank><S2SV_blank><S2SV_blank>xy<S2SV_blank><S2SV_blank><S2SV_blank>x"" ) ;  } ","assert_regexp_syntax_error ( ""\\\\\\\\x0"" ) ;assert_regexp_syntax_error ( ""\\\\\\\\x"" ) ;assert_regexp_syntax_error ( ""\\\\\\\\xxy"" ) ;}",507
688,"buggy line: if ( hashbin -> hb_type & HB_LOCK ) {spin_lock_irqsave_nested ( & hashbin -> hb_spinlock , flags , hashbin_lock_depth ++ ) ;}queue = dequeue_first ( ( irda_queue_t * * ) & hashbin -> hb_queue [ i ] ) ;while ( queue ) {if ( free_func )  ( * free_func ) ( queue ) ;queue = dequeue_first ( ( irda_queue_t * * ) & hashbin -> hb_queue [ i ] ) ;}}hashbin -> hb_current = NULL ;hashbin -> magic = ~ HB_MAGIC ;if ( hashbin -> hb_type & HB_LOCK ) {spin_unlock_irqrestore ( & hashbin -> hb_spinlock , flags ) ;# ifdef CONFIG_LOCKDEP  hashbin_lock_depth -- ;cwe id:CWE-000context: int hashbin_delete ( hashbin_t * hashbin , FREE_FUNC free_func ) { irda_queue_t * queue ; unsigned long flags = 0 ; int i ; IRDA_ASSERT ( hashbin != NULL , return - 1 ; ) ; IRDA_ASSERT ( hashbin -> magic == HB_MAGIC , return - 1 ; ) ;  if ( hashbin -> hb_type & HB_LOCK ) {  spin_lock_irqsave_nested ( & hashbin -> hb_spinlock , flags , hashbin_lock_depth ++ ) ; } for ( i = 0 ; i < HASHBIN_SIZE ; i ++ ) {  queue = dequeue_first ( ( irda_queue_t * * ) & hashbin -> hb_queue [ i ] ) ;   while ( queue ) {  if ( free_func )  ( * free_func ) ( queue ) ;  queue = dequeue_first ( ( irda_queue_t * * ) & hashbin -> hb_queue [ i ] ) ; } } hashbin -> hb_current = NULL ; hashbin -> magic = ~ HB_MAGIC ;  if ( hashbin -> hb_type & HB_LOCK ) {  spin_unlock_irqrestore ( & hashbin -> hb_spinlock , flags ) ;  # ifdef CONFIG_LOCKDEP  hashbin_lock_depth -- ; # endif } kfree ( hashbin ) ; return 0 ; }","if ( hashbin -> hb_type & HB_LOCK ) spin_lock_irqsave ( & hashbin -> hb_spinlock , flags ) ;while ( 1 ) {queue = dequeue_first ( ( irda_queue_t * * ) & hashbin -> hb_queue [ i ] ) ;if ( ! queue ) break ;if ( free_func ) {if ( hashbin -> hb_type & HB_LOCK ) spin_unlock_irqrestore ( & hashbin -> hb_spinlock , flags ) ;free_func ( queue ) ;if ( hashbin -> hb_type & HB_LOCK ) spin_unlock_irqrestore ( & hashbin -> hb_spinlock , flags ) ;# ifdef CONFIG_LOCKDEP hashbin_lock_depth -- ;",508
689,"buggy line: err = security_sb_remount ( sb , data ) ;if ( err ) return err ;cwe id:CWE-269context: static int do_remount ( struct path * path , int flags , int mnt_flags , void * data ) { int err ; struct super_block * sb = path -> mnt -> mnt_sb ; struct mount * mnt = real_mount ( path -> mnt ) ; if ( ! check_mnt ( mnt ) ) return - EINVAL ; if ( path -> dentry != path -> mnt -> mnt_root ) return - EINVAL ; if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_READONLY ) && ! ( mnt_flags & MNT_READONLY ) ) { return - EPERM ; }  err = security_sb_remount ( sb , data ) ;  if ( err ) return err ; down_write ( & sb -> s_umount ) ; if ( flags & MS_BIND ) err = change_mount_flags ( path -> mnt , flags ) ; else if ( ! capable ( CAP_SYS_ADMIN ) ) err = - EPERM ; else err = do_remount_sb ( sb , flags , data , 0 ) ; if ( ! err ) { lock_mount_hash ( ) ; mnt_flags |= mnt -> mnt . mnt_flags & ~ MNT_USER_SETTABLE_MASK ; mnt -> mnt . mnt_flags = mnt_flags ; touch_mnt_namespace ( mnt -> mnt_ns ) ; unlock_mount_hash ( ) ; } up_write ( & sb -> s_umount ) ; return err ; }","if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_NODEV ) && ! ( mnt_flags & MNT_NODEV ) ) {return - EPERM ;}if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_NOSUID ) && ! ( mnt_flags & MNT_NOSUID ) ) {return - EPERM ;}if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_NOEXEC ) && ! ( mnt_flags & MNT_NOEXEC ) ) {return - EPERM ;}if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_ATIME ) && ( ( mnt -> mnt . mnt_flags & MNT_ATIME_MASK ) != ( mnt_flags & MNT_ATIME_MASK ) ) ) {return - EPERM ;}err = security_sb_remount ( sb , data ) ;if ( err ) return err ;",509
690,"buggy line: int copied , err ;struct sockaddr_ll * sll ;cwe id:CWE-20context: static int packet_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct sk_buff * skb ;  int copied , err ;  struct sockaddr_ll * sll ; int vnet_hdr_len = 0 ; err = - EINVAL ; if ( flags & ~ ( MSG_PEEK | MSG_DONTWAIT | MSG_TRUNC | MSG_CMSG_COMPAT | MSG_ERRQUEUE ) ) goto out ; # if 0 if ( pkt_sk ( sk ) -> ifindex < 0 ) return - ENODEV ; # endif if ( flags & MSG_ERRQUEUE ) { err = sock_recv_errqueue ( sk , msg , len , SOL_PACKET , PACKET_TX_TIMESTAMP ) ; goto out ; } skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out ; if ( pkt_sk ( sk ) -> has_vnet_hdr ) { struct virtio_net_hdr vnet_hdr = { 0 } ; err = - EINVAL ; vnet_hdr_len = sizeof ( vnet_hdr ) ; if ( len < vnet_hdr_len ) goto out_free ; len -= vnet_hdr_len ; if ( skb_is_gso ( skb ) ) { struct skb_shared_info * sinfo = skb_shinfo ( skb ) ; vnet_hdr . hdr_len = skb_headlen ( skb ) ; vnet_hdr . gso_size = sinfo -> gso_size ; if ( sinfo -> gso_type & SKB_GSO_TCPV4 ) vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_TCPV4 ; else if ( sinfo -> gso_type & SKB_GSO_TCPV6 ) vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_TCPV6 ; else if ( sinfo -> gso_type & SKB_GSO_UDP ) vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_UDP ; else if ( sinfo -> gso_type & SKB_GSO_FCOE ) goto out_free ; else BUG ( ) ; if ( sinfo -> gso_type & SKB_GSO_TCP_ECN ) vnet_hdr . gso_type |= VIRTIO_NET_HDR_GSO_ECN ; } else vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_NONE ; if ( skb -> ip_summed == CHECKSUM_PARTIAL ) { vnet_hdr . flags = VIRTIO_NET_HDR_F_NEEDS_CSUM ; vnet_hdr . csum_start = skb_checksum_start_offset ( skb ) ; vnet_hdr . csum_offset = skb -> csum_offset ; } else if ( skb -> ip_summed == CHECKSUM_UNNECESSARY ) { vnet_hdr . flags = VIRTIO_NET_HDR_F_DATA_VALID ; } err = memcpy_toiovec ( msg -> msg_iov , ( void * ) & vnet_hdr , vnet_hdr_len ) ; if ( err < 0 ) goto out_free ; }  sll = & PACKET_SKB_CB ( skb ) -> sa . ll ;   if ( sock -> type == SOCK_PACKET )  msg -> msg_namelen = sizeof ( struct sockaddr_pkt ) ;  else  msg -> msg_namelen = sll -> sll_halen + offsetof ( struct sockaddr_ll , sll_addr ) ;  copied = skb -> len ;  if ( copied > len ) { copied = len ; msg -> msg_flags |= MSG_TRUNC ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto out_free ; sock_recv_ts_and_drops ( msg , sk , skb ) ;  if ( msg -> msg_name )  memcpy ( msg -> msg_name , & PACKET_SKB_CB ( skb ) -> sa ,  msg -> msg_namelen ) ;  if ( pkt_sk ( sk ) -> auxdata ) { struct tpacket_auxdata aux ; aux . tp_status = TP_STATUS_USER ; if ( skb -> ip_summed == CHECKSUM_PARTIAL ) aux . tp_status |= TP_STATUS_CSUMNOTREADY ; aux . tp_len = PACKET_SKB_CB ( skb ) -> origlen ; aux . tp_snaplen = skb -> len ; aux . tp_mac = 0 ; aux . tp_net = skb_network_offset ( skb ) ; if ( vlan_tx_tag_present ( skb ) ) { aux . tp_vlan_tci = vlan_tx_tag_get ( skb ) ; aux . tp_status |= TP_STATUS_VLAN_VALID ; } else { aux . tp_vlan_tci = 0 ; } aux . tp_padding = 0 ; put_cmsg ( msg , SOL_PACKET , PACKET_AUXDATA , sizeof ( aux ) , & aux ) ; } err = vnet_hdr_len + ( ( flags & MSG_TRUNC ) ? skb -> len : copied ) ; out_free : skb_free_datagram ( sk , skb ) ; out : return err ; }","int copied , err ;",510
691,"buggy line: sll = & PACKET_SKB_CB ( skb ) -> sa . ll ;if ( sock -> type == SOCK_PACKET )  msg -> msg_namelen = sizeof ( struct sockaddr_pkt ) ;else  msg -> msg_namelen = sll -> sll_halen + offsetof ( struct sockaddr_ll , sll_addr ) ;copied = skb -> len ;if ( copied > len ) {if ( msg -> msg_name )  memcpy ( msg -> msg_name , & PACKET_SKB_CB ( skb ) -> sa ,  msg -> msg_namelen ) ;if ( pkt_sk ( sk ) -> auxdata ) {cwe id:CWE-20context: static int packet_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct sk_buff * skb ;  int copied , err ;  struct sockaddr_ll * sll ; int vnet_hdr_len = 0 ; err = - EINVAL ; if ( flags & ~ ( MSG_PEEK | MSG_DONTWAIT | MSG_TRUNC | MSG_CMSG_COMPAT | MSG_ERRQUEUE ) ) goto out ; # if 0 if ( pkt_sk ( sk ) -> ifindex < 0 ) return - ENODEV ; # endif if ( flags & MSG_ERRQUEUE ) { err = sock_recv_errqueue ( sk , msg , len , SOL_PACKET , PACKET_TX_TIMESTAMP ) ; goto out ; } skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out ; if ( pkt_sk ( sk ) -> has_vnet_hdr ) { struct virtio_net_hdr vnet_hdr = { 0 } ; err = - EINVAL ; vnet_hdr_len = sizeof ( vnet_hdr ) ; if ( len < vnet_hdr_len ) goto out_free ; len -= vnet_hdr_len ; if ( skb_is_gso ( skb ) ) { struct skb_shared_info * sinfo = skb_shinfo ( skb ) ; vnet_hdr . hdr_len = skb_headlen ( skb ) ; vnet_hdr . gso_size = sinfo -> gso_size ; if ( sinfo -> gso_type & SKB_GSO_TCPV4 ) vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_TCPV4 ; else if ( sinfo -> gso_type & SKB_GSO_TCPV6 ) vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_TCPV6 ; else if ( sinfo -> gso_type & SKB_GSO_UDP ) vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_UDP ; else if ( sinfo -> gso_type & SKB_GSO_FCOE ) goto out_free ; else BUG ( ) ; if ( sinfo -> gso_type & SKB_GSO_TCP_ECN ) vnet_hdr . gso_type |= VIRTIO_NET_HDR_GSO_ECN ; } else vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_NONE ; if ( skb -> ip_summed == CHECKSUM_PARTIAL ) { vnet_hdr . flags = VIRTIO_NET_HDR_F_NEEDS_CSUM ; vnet_hdr . csum_start = skb_checksum_start_offset ( skb ) ; vnet_hdr . csum_offset = skb -> csum_offset ; } else if ( skb -> ip_summed == CHECKSUM_UNNECESSARY ) { vnet_hdr . flags = VIRTIO_NET_HDR_F_DATA_VALID ; } err = memcpy_toiovec ( msg -> msg_iov , ( void * ) & vnet_hdr , vnet_hdr_len ) ; if ( err < 0 ) goto out_free ; }  sll = & PACKET_SKB_CB ( skb ) -> sa . ll ;   if ( sock -> type == SOCK_PACKET )  msg -> msg_namelen = sizeof ( struct sockaddr_pkt ) ;  else  msg -> msg_namelen = sll -> sll_halen + offsetof ( struct sockaddr_ll , sll_addr ) ;  copied = skb -> len ;  if ( copied > len ) { copied = len ; msg -> msg_flags |= MSG_TRUNC ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto out_free ; sock_recv_ts_and_drops ( msg , sk , skb ) ;  if ( msg -> msg_name )  memcpy ( msg -> msg_name , & PACKET_SKB_CB ( skb ) -> sa ,  msg -> msg_namelen ) ;  if ( pkt_sk ( sk ) -> auxdata ) { struct tpacket_auxdata aux ; aux . tp_status = TP_STATUS_USER ; if ( skb -> ip_summed == CHECKSUM_PARTIAL ) aux . tp_status |= TP_STATUS_CSUMNOTREADY ; aux . tp_len = PACKET_SKB_CB ( skb ) -> origlen ; aux . tp_snaplen = skb -> len ; aux . tp_mac = 0 ; aux . tp_net = skb_network_offset ( skb ) ; if ( vlan_tx_tag_present ( skb ) ) { aux . tp_vlan_tci = vlan_tx_tag_get ( skb ) ; aux . tp_status |= TP_STATUS_VLAN_VALID ; } else { aux . tp_vlan_tci = 0 ; } aux . tp_padding = 0 ; put_cmsg ( msg , SOL_PACKET , PACKET_AUXDATA , sizeof ( aux ) , & aux ) ; } err = vnet_hdr_len + ( ( flags & MSG_TRUNC ) ? skb -> len : copied ) ; out_free : skb_free_datagram ( sk , skb ) ; out : return err ; }","copied = skb -> len ;if ( copied > len ) {if ( msg -> msg_name ) {if ( sock -> type == SOCK_PACKET ) {msg -> msg_namelen = sizeof ( struct sockaddr_pkt ) ;}else {struct sockaddr_ll * sll = & PACKET_SKB_CB ( skb ) -> sa . ll ;msg -> msg_namelen = sll -> sll_halen + offsetof ( struct sockaddr_ll , sll_addr ) ;}memcpy ( msg -> msg_name ) memcpy ( msg -> msg_name , & PACKET_SKB_CB ( skb ) -> sa , msg -> msg_namelen ) ;}if ( pkt_sk ( sk ) -> auxdata ) {",510
692,"buggy line: uchar buf [ RAS_MAGICLEN ] ;int i ;cwe id:CWE-190context: int ras_validate ( jas_stream_t * in ) {  uchar buf [ RAS_MAGICLEN ] ;  int i ; int n ; uint_fast32_t magic ; assert ( JAS_STREAM_MAXPUTBACK >= RAS_MAGICLEN ) ; if ( ( n = jas_stream_read ( in , buf , RAS_MAGICLEN ) ) < 0 ) { return - 1 ; } for ( i = n - 1 ; i >= 0 ; -- i ) { if ( jas_stream_ungetc ( in , buf [ i ] ) == EOF ) { return - 1 ; } } if ( n < RAS_MAGICLEN ) { return - 1 ; } magic = ( JAS_CAST ( uint_fast32_t , buf [ 0 ] ) << 24 ) | ( JAS_CAST ( uint_fast32_t , buf [ 1 ] ) << 16 ) | ( JAS_CAST ( uint_fast32_t , buf [ 2 ] ) << 8 ) | buf [ 3 ] ; if ( magic != RAS_MAGIC ) { return - 1 ; } return 0 ; }",jas_uchar buf [ RAS_MAGICLEN ] ;int i ;,511
693,"buggy line: if ( serial -> num_ports < 2 )  return - 1 ;cwe id:CWE-000context: static int clie_5_attach ( struct usb_serial * serial ) { struct usb_serial_port * port ; unsigned int pipe ; int j ;  if ( serial -> num_ports < 2 )  return - 1 ; port = serial -> port [ 0 ] ; port -> bulk_out_endpointAddress = serial -> port [ 1 ] -> bulk_out_endpointAddress ; pipe = usb_sndbulkpipe ( serial -> dev , port -> bulk_out_endpointAddress ) ; for ( j = 0 ; j < ARRAY_SIZE ( port -> write_urbs ) ; ++ j ) port -> write_urbs [ j ] -> pipe = pipe ; return 0 ; }",if ( serial -> num_bulk_out < 2 ) return - 1 ;,512
694,"buggy line: int do_rf64 = 0 , write_junk = 1 ;ChunkHeader ds64hdr , datahdr , fmthdr ;DS64Chunk ds64_chunk ;JunkChunk junkchunk ;cwe id:CWE-119context: int WriteRiffHeader ( FILE * outfile , WavpackContext * wpc , int64_t total_samples , int qmode ) {  int do_rf64 = 0 , write_junk = 1 ;  ChunkHeader ds64hdr , datahdr , fmthdr ; RiffChunkHeader riffhdr ;  DS64Chunk ds64_chunk ;  JunkChunk junkchunk ; WaveHeader wavhdr ; uint32_t bcount ; int64_t total_data_bytes , total_riff_bytes ; int num_channels = WavpackGetNumChannels ( wpc ) ; int32_t channel_mask = WavpackGetChannelMask ( wpc ) ; int32_t sample_rate = WavpackGetSampleRate ( wpc ) ; int bytes_per_sample = WavpackGetBytesPerSample ( wpc ) ; int bits_per_sample = WavpackGetBitsPerSample ( wpc ) ; int format = WavpackGetFloatNormExp ( wpc ) ? 3 : 1 ; int wavhdrsize = 16 ; if ( format == 3 && WavpackGetFloatNormExp ( wpc ) != 127 ) { error_line ( ""can\'t<S2SV_blank>create<S2SV_blank>valid<S2SV_blank>RIFF<S2SV_blank>wav<S2SV_blank>header<S2SV_blank>for<S2SV_blank>non-normalized<S2SV_blank>floating<S2SV_blank>data!"" ) ; return FALSE ; } if ( total_samples == - 1 ) total_samples = 0x7ffff000 / ( bytes_per_sample * num_channels ) ; total_data_bytes = total_samples * bytes_per_sample * num_channels ; if ( total_data_bytes > 0xff000000 ) { if ( debug_logging_mode ) error_line ( ""total_data_bytes<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>so<S2SV_blank>rf64"" , total_data_bytes ) ; write_junk = 0 ; do_rf64 = 1 ; } else if ( debug_logging_mode ) error_line ( ""total_data_bytes<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>so<S2SV_blank>riff"" , total_data_bytes ) ; CLEAR ( wavhdr ) ; wavhdr . FormatTag = format ; wavhdr . NumChannels = num_channels ; wavhdr . SampleRate = sample_rate ; wavhdr . BytesPerSecond = sample_rate * num_channels * bytes_per_sample ; wavhdr . BlockAlign = bytes_per_sample * num_channels ; wavhdr . BitsPerSample = bits_per_sample ; if ( num_channels > 2 || channel_mask != 0x5 - num_channels ) { wavhdrsize = sizeof ( wavhdr ) ; wavhdr . cbSize = 22 ; wavhdr . ValidBitsPerSample = bits_per_sample ; wavhdr . SubFormat = format ; wavhdr . ChannelMask = channel_mask ; wavhdr . FormatTag = 0xfffe ; wavhdr . BitsPerSample = bytes_per_sample * 8 ; wavhdr . GUID [ 4 ] = 0x10 ; wavhdr . GUID [ 6 ] = 0x80 ; wavhdr . GUID [ 9 ] = 0xaa ; wavhdr . GUID [ 11 ] = 0x38 ; wavhdr . GUID [ 12 ] = 0x9b ; wavhdr . GUID [ 13 ] = 0x71 ; } strncpy ( riffhdr . ckID , do_rf64 ? ""RF64"" : ""RIFF"" , sizeof ( riffhdr . ckID ) ) ; strncpy ( riffhdr . formType , ""WAVE"" , sizeof ( riffhdr . formType ) ) ; total_riff_bytes = sizeof ( riffhdr ) + wavhdrsize + sizeof ( datahdr ) + ( ( total_data_bytes + 1 ) & ~ ( int64_t ) 1 ) ; if ( do_rf64 ) total_riff_bytes += sizeof ( ds64hdr ) + sizeof ( ds64_chunk ) ;  if ( write_junk ) total_riff_bytes += sizeof ( junkchunk ) ;  strncpy ( fmthdr . ckID , ""fmt<S2SV_blank>"" , sizeof ( fmthdr . ckID ) ) ; strncpy ( datahdr . ckID , ""data"" , sizeof ( datahdr . ckID ) ) ; fmthdr . ckSize = wavhdrsize ; if ( write_junk ) { CLEAR ( junkchunk ) ; strncpy ( junkchunk . ckID , ""junk"" , sizeof ( junkchunk . ckID ) ) ; junkchunk . ckSize = sizeof ( junkchunk ) - 8 ; WavpackNativeToLittleEndian ( & junkchunk , ChunkHeaderFormat ) ; } if ( do_rf64 ) { strncpy ( ds64hdr . ckID , ""ds64"" , sizeof ( ds64hdr . ckID ) ) ;  ds64hdr . ckSize = sizeof ( ds64_chunk ) ;  CLEAR ( ds64_chunk ) ; ds64_chunk . riffSize64 = total_riff_bytes ; ds64_chunk . dataSize64 = total_data_bytes ;  ds64_chunk . sampleCount64 = total_samples ;  riffhdr . ckSize = ( uint32_t ) - 1 ; datahdr . ckSize = ( uint32_t ) - 1 ; WavpackNativeToLittleEndian ( & ds64hdr , ChunkHeaderFormat ) ; WavpackNativeToLittleEndian ( & ds64_chunk , DS64ChunkFormat ) ; } else { riffhdr . ckSize = ( uint32_t ) total_riff_bytes ; datahdr . ckSize = ( uint32_t ) total_data_bytes ; }  WavpackNativeToLittleEndian ( & riffhdr , ChunkHeaderFormat ) ;  WavpackNativeToLittleEndian ( & fmthdr , ChunkHeaderFormat ) ; WavpackNativeToLittleEndian ( & wavhdr , WaveHeaderFormat ) ; WavpackNativeToLittleEndian ( & datahdr , ChunkHeaderFormat ) ; if ( ! DoWriteFile ( outfile , & riffhdr , sizeof ( riffhdr ) , & bcount ) || bcount != sizeof ( riffhdr ) || ( do_rf64 && ( ! DoWriteFile ( outfile , & ds64hdr , sizeof ( ds64hdr ) , & bcount ) || bcount != sizeof ( ds64hdr ) ) ) ||  ( do_rf64 && ( ! DoWriteFile ( outfile , & ds64_chunk , sizeof ( ds64_chunk ) , & bcount ) || bcount != sizeof ( ds64_chunk ) ) ) ||  ( write_junk && ( ! DoWriteFile ( outfile , & junkchunk , sizeof ( junkchunk ) , & bcount ) || bcount != sizeof ( junkchunk ) ) ) || ! DoWriteFile ( outfile , & fmthdr , sizeof ( fmthdr ) , & bcount ) || bcount != sizeof ( fmthdr ) || ! DoWriteFile ( outfile , & wavhdr , wavhdrsize , & bcount ) || bcount != wavhdrsize || ! DoWriteFile ( outfile , & datahdr , sizeof ( datahdr ) , & bcount ) || bcount != sizeof ( datahdr ) ) { error_line ( ""can\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!"" ) ; return FALSE ; } return TRUE ; }","int do_rf64 = 0 , write_junk = 1 , table_length = 0 ;ChunkHeader ds64hdr , datahdr , fmthdr ;DS64Chunk ds64_chunk ;CS64Chunk cs64_chunk ;JunkChunk junkchunk ;",513
695,"buggy line: if ( write_junk ) total_riff_bytes += sizeof ( junkchunk ) ;strncpy ( fmthdr . ckID , ""fmt<S2SV_blank>"" , sizeof ( fmthdr . ckID ) ) ;cwe id:CWE-119context: int WriteRiffHeader ( FILE * outfile , WavpackContext * wpc , int64_t total_samples , int qmode ) {  int do_rf64 = 0 , write_junk = 1 ;  ChunkHeader ds64hdr , datahdr , fmthdr ; RiffChunkHeader riffhdr ;  DS64Chunk ds64_chunk ;  JunkChunk junkchunk ; WaveHeader wavhdr ; uint32_t bcount ; int64_t total_data_bytes , total_riff_bytes ; int num_channels = WavpackGetNumChannels ( wpc ) ; int32_t channel_mask = WavpackGetChannelMask ( wpc ) ; int32_t sample_rate = WavpackGetSampleRate ( wpc ) ; int bytes_per_sample = WavpackGetBytesPerSample ( wpc ) ; int bits_per_sample = WavpackGetBitsPerSample ( wpc ) ; int format = WavpackGetFloatNormExp ( wpc ) ? 3 : 1 ; int wavhdrsize = 16 ; if ( format == 3 && WavpackGetFloatNormExp ( wpc ) != 127 ) { error_line ( ""can\'t<S2SV_blank>create<S2SV_blank>valid<S2SV_blank>RIFF<S2SV_blank>wav<S2SV_blank>header<S2SV_blank>for<S2SV_blank>non-normalized<S2SV_blank>floating<S2SV_blank>data!"" ) ; return FALSE ; } if ( total_samples == - 1 ) total_samples = 0x7ffff000 / ( bytes_per_sample * num_channels ) ; total_data_bytes = total_samples * bytes_per_sample * num_channels ; if ( total_data_bytes > 0xff000000 ) { if ( debug_logging_mode ) error_line ( ""total_data_bytes<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>so<S2SV_blank>rf64"" , total_data_bytes ) ; write_junk = 0 ; do_rf64 = 1 ; } else if ( debug_logging_mode ) error_line ( ""total_data_bytes<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>so<S2SV_blank>riff"" , total_data_bytes ) ; CLEAR ( wavhdr ) ; wavhdr . FormatTag = format ; wavhdr . NumChannels = num_channels ; wavhdr . SampleRate = sample_rate ; wavhdr . BytesPerSecond = sample_rate * num_channels * bytes_per_sample ; wavhdr . BlockAlign = bytes_per_sample * num_channels ; wavhdr . BitsPerSample = bits_per_sample ; if ( num_channels > 2 || channel_mask != 0x5 - num_channels ) { wavhdrsize = sizeof ( wavhdr ) ; wavhdr . cbSize = 22 ; wavhdr . ValidBitsPerSample = bits_per_sample ; wavhdr . SubFormat = format ; wavhdr . ChannelMask = channel_mask ; wavhdr . FormatTag = 0xfffe ; wavhdr . BitsPerSample = bytes_per_sample * 8 ; wavhdr . GUID [ 4 ] = 0x10 ; wavhdr . GUID [ 6 ] = 0x80 ; wavhdr . GUID [ 9 ] = 0xaa ; wavhdr . GUID [ 11 ] = 0x38 ; wavhdr . GUID [ 12 ] = 0x9b ; wavhdr . GUID [ 13 ] = 0x71 ; } strncpy ( riffhdr . ckID , do_rf64 ? ""RF64"" : ""RIFF"" , sizeof ( riffhdr . ckID ) ) ; strncpy ( riffhdr . formType , ""WAVE"" , sizeof ( riffhdr . formType ) ) ; total_riff_bytes = sizeof ( riffhdr ) + wavhdrsize + sizeof ( datahdr ) + ( ( total_data_bytes + 1 ) & ~ ( int64_t ) 1 ) ; if ( do_rf64 ) total_riff_bytes += sizeof ( ds64hdr ) + sizeof ( ds64_chunk ) ;  if ( write_junk ) total_riff_bytes += sizeof ( junkchunk ) ;  strncpy ( fmthdr . ckID , ""fmt<S2SV_blank>"" , sizeof ( fmthdr . ckID ) ) ; strncpy ( datahdr . ckID , ""data"" , sizeof ( datahdr . ckID ) ) ; fmthdr . ckSize = wavhdrsize ; if ( write_junk ) { CLEAR ( junkchunk ) ; strncpy ( junkchunk . ckID , ""junk"" , sizeof ( junkchunk . ckID ) ) ; junkchunk . ckSize = sizeof ( junkchunk ) - 8 ; WavpackNativeToLittleEndian ( & junkchunk , ChunkHeaderFormat ) ; } if ( do_rf64 ) { strncpy ( ds64hdr . ckID , ""ds64"" , sizeof ( ds64hdr . ckID ) ) ;  ds64hdr . ckSize = sizeof ( ds64_chunk ) ;  CLEAR ( ds64_chunk ) ; ds64_chunk . riffSize64 = total_riff_bytes ; ds64_chunk . dataSize64 = total_data_bytes ;  ds64_chunk . sampleCount64 = total_samples ;  riffhdr . ckSize = ( uint32_t ) - 1 ; datahdr . ckSize = ( uint32_t ) - 1 ; WavpackNativeToLittleEndian ( & ds64hdr , ChunkHeaderFormat ) ; WavpackNativeToLittleEndian ( & ds64_chunk , DS64ChunkFormat ) ; } else { riffhdr . ckSize = ( uint32_t ) total_riff_bytes ; datahdr . ckSize = ( uint32_t ) total_data_bytes ; }  WavpackNativeToLittleEndian ( & riffhdr , ChunkHeaderFormat ) ;  WavpackNativeToLittleEndian ( & fmthdr , ChunkHeaderFormat ) ; WavpackNativeToLittleEndian ( & wavhdr , WaveHeaderFormat ) ; WavpackNativeToLittleEndian ( & datahdr , ChunkHeaderFormat ) ; if ( ! DoWriteFile ( outfile , & riffhdr , sizeof ( riffhdr ) , & bcount ) || bcount != sizeof ( riffhdr ) || ( do_rf64 && ( ! DoWriteFile ( outfile , & ds64hdr , sizeof ( ds64hdr ) , & bcount ) || bcount != sizeof ( ds64hdr ) ) ) ||  ( do_rf64 && ( ! DoWriteFile ( outfile , & ds64_chunk , sizeof ( ds64_chunk ) , & bcount ) || bcount != sizeof ( ds64_chunk ) ) ) ||  ( write_junk && ( ! DoWriteFile ( outfile , & junkchunk , sizeof ( junkchunk ) , & bcount ) || bcount != sizeof ( junkchunk ) ) ) || ! DoWriteFile ( outfile , & fmthdr , sizeof ( fmthdr ) , & bcount ) || bcount != sizeof ( fmthdr ) || ! DoWriteFile ( outfile , & wavhdr , wavhdrsize , & bcount ) || bcount != wavhdrsize || ! DoWriteFile ( outfile , & datahdr , sizeof ( datahdr ) , & bcount ) || bcount != sizeof ( datahdr ) ) { error_line ( ""can\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!"" ) ; return FALSE ; } return TRUE ; }","total_riff_bytes += table_length * sizeof ( CS64Chunk ) ;if ( write_junk ) total_riff_bytes += sizeof ( junkchunk ) ;strncpy ( fmthdr . ckID , ""fmt<S2SV_blank>"" , sizeof ( fmthdr . ckID ) ) ;",513
696,"buggy line: ds64hdr . ckSize = sizeof ( ds64_chunk ) ;CLEAR ( ds64_chunk ) ;ds64_chunk . sampleCount64 = total_samples ;riffhdr . ckSize = ( uint32_t ) - 1 ;cwe id:CWE-119context: int WriteRiffHeader ( FILE * outfile , WavpackContext * wpc , int64_t total_samples , int qmode ) {  int do_rf64 = 0 , write_junk = 1 ;  ChunkHeader ds64hdr , datahdr , fmthdr ; RiffChunkHeader riffhdr ;  DS64Chunk ds64_chunk ;  JunkChunk junkchunk ; WaveHeader wavhdr ; uint32_t bcount ; int64_t total_data_bytes , total_riff_bytes ; int num_channels = WavpackGetNumChannels ( wpc ) ; int32_t channel_mask = WavpackGetChannelMask ( wpc ) ; int32_t sample_rate = WavpackGetSampleRate ( wpc ) ; int bytes_per_sample = WavpackGetBytesPerSample ( wpc ) ; int bits_per_sample = WavpackGetBitsPerSample ( wpc ) ; int format = WavpackGetFloatNormExp ( wpc ) ? 3 : 1 ; int wavhdrsize = 16 ; if ( format == 3 && WavpackGetFloatNormExp ( wpc ) != 127 ) { error_line ( ""can\'t<S2SV_blank>create<S2SV_blank>valid<S2SV_blank>RIFF<S2SV_blank>wav<S2SV_blank>header<S2SV_blank>for<S2SV_blank>non-normalized<S2SV_blank>floating<S2SV_blank>data!"" ) ; return FALSE ; } if ( total_samples == - 1 ) total_samples = 0x7ffff000 / ( bytes_per_sample * num_channels ) ; total_data_bytes = total_samples * bytes_per_sample * num_channels ; if ( total_data_bytes > 0xff000000 ) { if ( debug_logging_mode ) error_line ( ""total_data_bytes<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>so<S2SV_blank>rf64"" , total_data_bytes ) ; write_junk = 0 ; do_rf64 = 1 ; } else if ( debug_logging_mode ) error_line ( ""total_data_bytes<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>so<S2SV_blank>riff"" , total_data_bytes ) ; CLEAR ( wavhdr ) ; wavhdr . FormatTag = format ; wavhdr . NumChannels = num_channels ; wavhdr . SampleRate = sample_rate ; wavhdr . BytesPerSecond = sample_rate * num_channels * bytes_per_sample ; wavhdr . BlockAlign = bytes_per_sample * num_channels ; wavhdr . BitsPerSample = bits_per_sample ; if ( num_channels > 2 || channel_mask != 0x5 - num_channels ) { wavhdrsize = sizeof ( wavhdr ) ; wavhdr . cbSize = 22 ; wavhdr . ValidBitsPerSample = bits_per_sample ; wavhdr . SubFormat = format ; wavhdr . ChannelMask = channel_mask ; wavhdr . FormatTag = 0xfffe ; wavhdr . BitsPerSample = bytes_per_sample * 8 ; wavhdr . GUID [ 4 ] = 0x10 ; wavhdr . GUID [ 6 ] = 0x80 ; wavhdr . GUID [ 9 ] = 0xaa ; wavhdr . GUID [ 11 ] = 0x38 ; wavhdr . GUID [ 12 ] = 0x9b ; wavhdr . GUID [ 13 ] = 0x71 ; } strncpy ( riffhdr . ckID , do_rf64 ? ""RF64"" : ""RIFF"" , sizeof ( riffhdr . ckID ) ) ; strncpy ( riffhdr . formType , ""WAVE"" , sizeof ( riffhdr . formType ) ) ; total_riff_bytes = sizeof ( riffhdr ) + wavhdrsize + sizeof ( datahdr ) + ( ( total_data_bytes + 1 ) & ~ ( int64_t ) 1 ) ; if ( do_rf64 ) total_riff_bytes += sizeof ( ds64hdr ) + sizeof ( ds64_chunk ) ;  if ( write_junk ) total_riff_bytes += sizeof ( junkchunk ) ;  strncpy ( fmthdr . ckID , ""fmt<S2SV_blank>"" , sizeof ( fmthdr . ckID ) ) ; strncpy ( datahdr . ckID , ""data"" , sizeof ( datahdr . ckID ) ) ; fmthdr . ckSize = wavhdrsize ; if ( write_junk ) { CLEAR ( junkchunk ) ; strncpy ( junkchunk . ckID , ""junk"" , sizeof ( junkchunk . ckID ) ) ; junkchunk . ckSize = sizeof ( junkchunk ) - 8 ; WavpackNativeToLittleEndian ( & junkchunk , ChunkHeaderFormat ) ; } if ( do_rf64 ) { strncpy ( ds64hdr . ckID , ""ds64"" , sizeof ( ds64hdr . ckID ) ) ;  ds64hdr . ckSize = sizeof ( ds64_chunk ) ;  CLEAR ( ds64_chunk ) ; ds64_chunk . riffSize64 = total_riff_bytes ; ds64_chunk . dataSize64 = total_data_bytes ;  ds64_chunk . sampleCount64 = total_samples ;  riffhdr . ckSize = ( uint32_t ) - 1 ; datahdr . ckSize = ( uint32_t ) - 1 ; WavpackNativeToLittleEndian ( & ds64hdr , ChunkHeaderFormat ) ; WavpackNativeToLittleEndian ( & ds64_chunk , DS64ChunkFormat ) ; } else { riffhdr . ckSize = ( uint32_t ) total_riff_bytes ; datahdr . ckSize = ( uint32_t ) total_data_bytes ; }  WavpackNativeToLittleEndian ( & riffhdr , ChunkHeaderFormat ) ;  WavpackNativeToLittleEndian ( & fmthdr , ChunkHeaderFormat ) ; WavpackNativeToLittleEndian ( & wavhdr , WaveHeaderFormat ) ; WavpackNativeToLittleEndian ( & datahdr , ChunkHeaderFormat ) ; if ( ! DoWriteFile ( outfile , & riffhdr , sizeof ( riffhdr ) , & bcount ) || bcount != sizeof ( riffhdr ) || ( do_rf64 && ( ! DoWriteFile ( outfile , & ds64hdr , sizeof ( ds64hdr ) , & bcount ) || bcount != sizeof ( ds64hdr ) ) ) ||  ( do_rf64 && ( ! DoWriteFile ( outfile , & ds64_chunk , sizeof ( ds64_chunk ) , & bcount ) || bcount != sizeof ( ds64_chunk ) ) ) ||  ( write_junk && ( ! DoWriteFile ( outfile , & junkchunk , sizeof ( junkchunk ) , & bcount ) || bcount != sizeof ( junkchunk ) ) ) || ! DoWriteFile ( outfile , & fmthdr , sizeof ( fmthdr ) , & bcount ) || bcount != sizeof ( fmthdr ) || ! DoWriteFile ( outfile , & wavhdr , wavhdrsize , & bcount ) || bcount != wavhdrsize || ! DoWriteFile ( outfile , & datahdr , sizeof ( datahdr ) , & bcount ) || bcount != sizeof ( datahdr ) ) { error_line ( ""can\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!"" ) ; return FALSE ; } return TRUE ; }",ds64hdr . ckSize = sizeof ( ds64_chunk ) + ( table_length * sizeof ( CS64Chunk ) ) ;CLEAR ( ds64_chunk ) ;ds64_chunk . sampleCount64 = total_samples ;ds64_chunk . tableLength = table_length ;riffhdr . ckSize = ( uint32_t ) - 1 ;,513
697,"buggy line: WavpackNativeToLittleEndian ( & riffhdr , ChunkHeaderFormat ) ;WavpackNativeToLittleEndian ( & fmthdr , ChunkHeaderFormat ) ;if ( ! DoWriteFile ( outfile , & riffhdr , sizeof ( riffhdr ) , & bcount ) || bcount != sizeof ( riffhdr ) || ( do_rf64 && ( ! DoWriteFile ( outfile , & ds64hdr , sizeof ( ds64hdr ) , & bcount ) || bcount != sizeof ( ds64hdr ) ) ) ||  ( do_rf64 && ( ! DoWriteFile ( outfile , & ds64_chunk , sizeof ( ds64_chunk ) , & bcount ) || bcount != sizeof ( ds64_chunk ) ) ) ||  ( write_junk && ( ! DoWriteFile ( outfile , & junkchunk , sizeof ( junkchunk ) , & bcount ) || bcount != sizeof ( junkchunk ) ) ) || ! DoWriteFile ( outfile , & fmthdr , sizeof ( fmthdr ) , & bcount ) || bcount != sizeof ( fmthdr ) || ! DoWriteFile ( outfile , & wavhdr , wavhdrsize , & bcount ) || bcount != wavhdrsize || ! DoWriteFile ( outfile , & datahdr , sizeof ( datahdr ) , & bcount ) || bcount != sizeof ( datahdr ) ) {cwe id:CWE-119context: int WriteRiffHeader ( FILE * outfile , WavpackContext * wpc , int64_t total_samples , int qmode ) {  int do_rf64 = 0 , write_junk = 1 ;  ChunkHeader ds64hdr , datahdr , fmthdr ; RiffChunkHeader riffhdr ;  DS64Chunk ds64_chunk ;  JunkChunk junkchunk ; WaveHeader wavhdr ; uint32_t bcount ; int64_t total_data_bytes , total_riff_bytes ; int num_channels = WavpackGetNumChannels ( wpc ) ; int32_t channel_mask = WavpackGetChannelMask ( wpc ) ; int32_t sample_rate = WavpackGetSampleRate ( wpc ) ; int bytes_per_sample = WavpackGetBytesPerSample ( wpc ) ; int bits_per_sample = WavpackGetBitsPerSample ( wpc ) ; int format = WavpackGetFloatNormExp ( wpc ) ? 3 : 1 ; int wavhdrsize = 16 ; if ( format == 3 && WavpackGetFloatNormExp ( wpc ) != 127 ) { error_line ( ""can\'t<S2SV_blank>create<S2SV_blank>valid<S2SV_blank>RIFF<S2SV_blank>wav<S2SV_blank>header<S2SV_blank>for<S2SV_blank>non-normalized<S2SV_blank>floating<S2SV_blank>data!"" ) ; return FALSE ; } if ( total_samples == - 1 ) total_samples = 0x7ffff000 / ( bytes_per_sample * num_channels ) ; total_data_bytes = total_samples * bytes_per_sample * num_channels ; if ( total_data_bytes > 0xff000000 ) { if ( debug_logging_mode ) error_line ( ""total_data_bytes<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>so<S2SV_blank>rf64"" , total_data_bytes ) ; write_junk = 0 ; do_rf64 = 1 ; } else if ( debug_logging_mode ) error_line ( ""total_data_bytes<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>so<S2SV_blank>riff"" , total_data_bytes ) ; CLEAR ( wavhdr ) ; wavhdr . FormatTag = format ; wavhdr . NumChannels = num_channels ; wavhdr . SampleRate = sample_rate ; wavhdr . BytesPerSecond = sample_rate * num_channels * bytes_per_sample ; wavhdr . BlockAlign = bytes_per_sample * num_channels ; wavhdr . BitsPerSample = bits_per_sample ; if ( num_channels > 2 || channel_mask != 0x5 - num_channels ) { wavhdrsize = sizeof ( wavhdr ) ; wavhdr . cbSize = 22 ; wavhdr . ValidBitsPerSample = bits_per_sample ; wavhdr . SubFormat = format ; wavhdr . ChannelMask = channel_mask ; wavhdr . FormatTag = 0xfffe ; wavhdr . BitsPerSample = bytes_per_sample * 8 ; wavhdr . GUID [ 4 ] = 0x10 ; wavhdr . GUID [ 6 ] = 0x80 ; wavhdr . GUID [ 9 ] = 0xaa ; wavhdr . GUID [ 11 ] = 0x38 ; wavhdr . GUID [ 12 ] = 0x9b ; wavhdr . GUID [ 13 ] = 0x71 ; } strncpy ( riffhdr . ckID , do_rf64 ? ""RF64"" : ""RIFF"" , sizeof ( riffhdr . ckID ) ) ; strncpy ( riffhdr . formType , ""WAVE"" , sizeof ( riffhdr . formType ) ) ; total_riff_bytes = sizeof ( riffhdr ) + wavhdrsize + sizeof ( datahdr ) + ( ( total_data_bytes + 1 ) & ~ ( int64_t ) 1 ) ; if ( do_rf64 ) total_riff_bytes += sizeof ( ds64hdr ) + sizeof ( ds64_chunk ) ;  if ( write_junk ) total_riff_bytes += sizeof ( junkchunk ) ;  strncpy ( fmthdr . ckID , ""fmt<S2SV_blank>"" , sizeof ( fmthdr . ckID ) ) ; strncpy ( datahdr . ckID , ""data"" , sizeof ( datahdr . ckID ) ) ; fmthdr . ckSize = wavhdrsize ; if ( write_junk ) { CLEAR ( junkchunk ) ; strncpy ( junkchunk . ckID , ""junk"" , sizeof ( junkchunk . ckID ) ) ; junkchunk . ckSize = sizeof ( junkchunk ) - 8 ; WavpackNativeToLittleEndian ( & junkchunk , ChunkHeaderFormat ) ; } if ( do_rf64 ) { strncpy ( ds64hdr . ckID , ""ds64"" , sizeof ( ds64hdr . ckID ) ) ;  ds64hdr . ckSize = sizeof ( ds64_chunk ) ;  CLEAR ( ds64_chunk ) ; ds64_chunk . riffSize64 = total_riff_bytes ; ds64_chunk . dataSize64 = total_data_bytes ;  ds64_chunk . sampleCount64 = total_samples ;  riffhdr . ckSize = ( uint32_t ) - 1 ; datahdr . ckSize = ( uint32_t ) - 1 ; WavpackNativeToLittleEndian ( & ds64hdr , ChunkHeaderFormat ) ; WavpackNativeToLittleEndian ( & ds64_chunk , DS64ChunkFormat ) ; } else { riffhdr . ckSize = ( uint32_t ) total_riff_bytes ; datahdr . ckSize = ( uint32_t ) total_data_bytes ; }  WavpackNativeToLittleEndian ( & riffhdr , ChunkHeaderFormat ) ;  WavpackNativeToLittleEndian ( & fmthdr , ChunkHeaderFormat ) ; WavpackNativeToLittleEndian ( & wavhdr , WaveHeaderFormat ) ; WavpackNativeToLittleEndian ( & datahdr , ChunkHeaderFormat ) ; if ( ! DoWriteFile ( outfile , & riffhdr , sizeof ( riffhdr ) , & bcount ) || bcount != sizeof ( riffhdr ) || ( do_rf64 && ( ! DoWriteFile ( outfile , & ds64hdr , sizeof ( ds64hdr ) , & bcount ) || bcount != sizeof ( ds64hdr ) ) ) ||  ( do_rf64 && ( ! DoWriteFile ( outfile , & ds64_chunk , sizeof ( ds64_chunk ) , & bcount ) || bcount != sizeof ( ds64_chunk ) ) ) ||  ( write_junk && ( ! DoWriteFile ( outfile , & junkchunk , sizeof ( junkchunk ) , & bcount ) || bcount != sizeof ( junkchunk ) ) ) || ! DoWriteFile ( outfile , & fmthdr , sizeof ( fmthdr ) , & bcount ) || bcount != sizeof ( fmthdr ) || ! DoWriteFile ( outfile , & wavhdr , wavhdrsize , & bcount ) || bcount != wavhdrsize || ! DoWriteFile ( outfile , & datahdr , sizeof ( datahdr ) , & bcount ) || bcount != sizeof ( datahdr ) ) { error_line ( ""can\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!"" ) ; return FALSE ; } return TRUE ; }","if ( table_length ) {strncpy ( cs64_chunk . ckID , ""dmmy"" , sizeof ( cs64_chunk . ckID ) ) ;cs64_chunk . chunkSize64 = 12345678 ;WavpackNativeToLittleEndian ( & cs64_chunk , CS64ChunkFormat ) ;}WavpackNativeToLittleEndian ( & riffhdr , ChunkHeaderFormat ) ;WavpackNativeToLittleEndian ( & fmthdr , ChunkHeaderFormat ) ;if ( ! DoWriteFile ( outfile , & riffhdr , sizeof ( riffhdr ) , & bcount ) || bcount != sizeof ( riffhdr ) || ( do_rf64 && ( ! DoWriteFile ( outfile , & ds64hdr , sizeof ( ds64hdr ) , & bcount ) || bcount != sizeof ( ds64hdr ) ) ) ) {error_line ( ""can\\\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!"" ) ;return FALSE ;}while ( table_length -- ) if ( ! DoWriteFile ( outfile , & cs64_chunk , sizeof ( cs64_chunk ) , & bcount ) || bcount != sizeof ( cs64_chunk ) ) {error_line ( ""can\\\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!"" ) ;return FALSE ;}if ( ( write_junk && ( ! DoWriteFile ( outfile , & junkchunk , sizeof ( junkchunk ) , & bcount ) || bcount != sizeof ( junkchunk ) ) ) || ! DoWriteFile ( outfile , & fmthdr , sizeof ( fmthdr ) , & bcount ) || bcount != sizeof ( fmthdr ) || ! DoWriteFile ( outfile , & wavhdr , wavhdrsize , & bcount ) || bcount != wavhdrsize || ! DoWriteFile ( outfile , & datahdr , sizeof ( datahdr ) , & bcount ) || bcount != sizeof ( datahdr ) ) {",513
698,"buggy line: if ( MSG_CMSG_COMPAT & flags ) {if ( get_compat_msghdr ( msg_sys , msg_compat ) ) return - EFAULT ;else {err = copy_msghdr_from_user ( msg_sys , msg ) ;if ( err ) return err ;}if ( msg_sys -> msg_iovlen > UIO_FASTIOV ) {err = - EMSGSIZE ;if ( msg_sys -> msg_iovlen > UIO_MAXIOV ) goto out ;err = - ENOMEM ;iov = kmalloc ( msg_sys -> msg_iovlen * sizeof ( struct iovec ) , GFP_KERNEL ) ;if ( ! iov ) goto out ;}uaddr = ( __force void __user * ) msg_sys -> msg_name ;uaddr_len = COMPAT_NAMELEN ( msg ) ;if ( MSG_CMSG_COMPAT & flags ) {err = verify_compat_iovec ( msg_sys , iov , & addr , VERIFY_WRITE ) ;}else  err = verify_iovec ( msg_sys , iov , & addr , VERIFY_WRITE ) ;msg_sys -> msg_flags = flags & ( MSG_CMSG_CLOEXEC | MSG_CMSG_COMPAT ) ;if ( sock -> file -> f_flags & O_NONBLOCK ) flags |= MSG_DONTWAIT ;cwe id:CWE-20context: static int ___sys_recvmsg ( struct socket * sock , struct msghdr __user * msg , struct msghdr * msg_sys , unsigned int flags , int nosec ) { struct compat_msghdr __user * msg_compat = ( struct compat_msghdr __user * ) msg ; struct iovec iovstack [ UIO_FASTIOV ] ; struct iovec * iov = iovstack ; unsigned long cmsg_ptr ; int err , total_len , len ; struct sockaddr_storage addr ; struct sockaddr __user * uaddr ; int __user * uaddr_len ; if ( MSG_CMSG_COMPAT & flags ) { if ( get_compat_msghdr ( msg_sys , msg_compat ) ) return - EFAULT ; } else { err = copy_msghdr_from_user ( msg_sys , msg ) ; if ( err ) return err ; } if ( msg_sys -> msg_iovlen > UIO_FASTIOV ) { err = - EMSGSIZE ; if ( msg_sys -> msg_iovlen > UIO_MAXIOV ) goto out ; err = - ENOMEM ; iov = kmalloc ( msg_sys -> msg_iovlen * sizeof ( struct iovec ) , GFP_KERNEL ) ; if ( ! iov ) goto out ; } uaddr = ( __force void __user * ) msg_sys -> msg_name ; uaddr_len = COMPAT_NAMELEN ( msg ) ;  if ( MSG_CMSG_COMPAT & flags ) {  err = verify_compat_iovec ( msg_sys , iov , & addr , VERIFY_WRITE ) ;  } else  err = verify_iovec ( msg_sys , iov , & addr , VERIFY_WRITE ) ; if ( err < 0 ) goto out_freeiov ; total_len = err ; cmsg_ptr = ( unsigned long ) msg_sys -> msg_control ;  msg_sys -> msg_flags = flags & ( MSG_CMSG_CLOEXEC | MSG_CMSG_COMPAT ) ;  if ( sock -> file -> f_flags & O_NONBLOCK ) flags |= MSG_DONTWAIT ; err = ( nosec ? sock_recvmsg_nosec : sock_recvmsg ) ( sock , msg_sys , total_len , flags ) ; if ( err < 0 ) goto out_freeiov ; len = err ; if ( uaddr != NULL ) { err = move_addr_to_user ( & addr , msg_sys -> msg_namelen , uaddr , uaddr_len ) ; if ( err < 0 ) goto out_freeiov ; } err = __put_user ( ( msg_sys -> msg_flags & ~ MSG_CMSG_COMPAT ) , COMPAT_FLAGS ( msg ) ) ; if ( err ) goto out_freeiov ; if ( MSG_CMSG_COMPAT & flags ) err = __put_user ( ( unsigned long ) msg_sys -> msg_control - cmsg_ptr , & msg_compat -> msg_controllen ) ; else err = __put_user ( ( unsigned long ) msg_sys -> msg_control - cmsg_ptr , & msg -> msg_controllen ) ; if ( err ) goto out_freeiov ; err = len ; out_freeiov : if ( iov != iovstack ) kfree ( iov ) ; out : return err ; }","if ( MSG_CMSG_COMPAT & flags ) err = verify_compat_iovec ( msg_sys , iov , & addr , VERIFY_WRITE ) ;else err = verify_iovec ( msg_sys , iov , & addr , VERIFY_WRITE ) ;msg_sys -> msg_flags = flags & ( MSG_CMSG_CLOEXEC | MSG_CMSG_COMPAT ) ;msg_sys -> msg_namelen = 0 ;if ( sock -> file -> f_flags & O_NONBLOCK ) flags |= MSG_DONTWAIT ;",514
699,"buggy line: struct buffer_head * dibh = mp -> mp_bh [ 0 ] ;u64 bn , dblock = 0 ;const unsigned end_of_metadata = height - 1 ;int eob = 0 ;cwe id:CWE-119context: static int gfs2_bmap_alloc ( struct inode * inode , const sector_t lblock , struct buffer_head * bh_map , struct metapath * mp , const unsigned int sheight , const unsigned int height , const unsigned int maxlen ) { struct gfs2_inode * ip = GFS2_I ( inode ) ; struct gfs2_sbd * sdp = GFS2_SB ( inode ) ;  struct buffer_head * dibh = mp -> mp_bh [ 0 ] ;  u64 bn , dblock = 0 ; unsigned n , i , blks , alloced = 0 , iblks = 0 , branch_start = 0 ; unsigned dblks = 0 ; unsigned ptrs_per_blk ;  const unsigned end_of_metadata = height - 1 ;  int eob = 0 ; enum alloc_state state ; __be64 * ptr ; __be64 zero_bn = 0 ; BUG_ON ( sheight < 1 ) ; BUG_ON ( dibh == NULL ) ; gfs2_trans_add_bh ( ip -> i_gl , dibh , 1 ) ; if ( height == sheight ) { struct buffer_head * bh ; ptr = metapointer ( end_of_metadata , mp ) ; bh = mp -> mp_bh [ end_of_metadata ] ; dblks = gfs2_extent_length ( bh -> b_data , bh -> b_size , ptr , maxlen , & eob ) ; BUG_ON ( dblks < 1 ) ; state = ALLOC_DATA ; } else { ptrs_per_blk = height > 1 ? sdp -> sd_inptrs : sdp -> sd_diptrs ; dblks = min ( maxlen , ptrs_per_blk - mp -> mp_list [ end_of_metadata ] ) ; if ( height == ip -> i_height ) { iblks = height - sheight ; state = ALLOC_GROW_DEPTH ; } else { state = ALLOC_GROW_HEIGHT ; iblks = height - ip -> i_height ; branch_start = metapath_branch_start ( mp ) ; iblks += ( height - branch_start ) ; } } blks = dblks + iblks ; i = sheight ; do { int error ; n = blks - alloced ; error = gfs2_alloc_block ( ip , & bn , & n ) ; if ( error ) return error ; alloced += n ; if ( state != ALLOC_DATA || gfs2_is_jdata ( ip ) ) gfs2_trans_add_unrevoke ( sdp , bn , n ) ; switch ( state ) { case ALLOC_GROW_HEIGHT : if ( i == 1 ) { ptr = ( __be64 * ) ( dibh -> b_data + sizeof ( struct gfs2_dinode ) ) ; zero_bn = * ptr ; } for ( ; i - 1 < height - ip -> i_height && n > 0 ; i ++ , n -- ) gfs2_indirect_init ( mp , ip -> i_gl , i , 0 , bn ++ ) ; if ( i - 1 == height - ip -> i_height ) { i -- ; gfs2_buffer_copy_tail ( mp -> mp_bh [ i ] , sizeof ( struct gfs2_meta_header ) , dibh , sizeof ( struct gfs2_dinode ) ) ; gfs2_buffer_clear_tail ( dibh , sizeof ( struct gfs2_dinode ) + sizeof ( __be64 ) ) ; ptr = ( __be64 * ) ( mp -> mp_bh [ i ] -> b_data + sizeof ( struct gfs2_meta_header ) ) ; * ptr = zero_bn ; state = ALLOC_GROW_DEPTH ; for ( i = branch_start ; i < height ; i ++ ) { if ( mp -> mp_bh [ i ] == NULL ) break ; brelse ( mp -> mp_bh [ i ] ) ; mp -> mp_bh [ i ] = NULL ; } i = branch_start ; } if ( n == 0 ) break ; case ALLOC_GROW_DEPTH : if ( i > 1 && i < height ) gfs2_trans_add_bh ( ip -> i_gl , mp -> mp_bh [ i - 1 ] , 1 ) ; for ( ; i < height && n > 0 ; i ++ , n -- ) gfs2_indirect_init ( mp , ip -> i_gl , i , mp -> mp_list [ i - 1 ] , bn ++ ) ; if ( i == height ) state = ALLOC_DATA ; if ( n == 0 ) break ; case ALLOC_DATA : BUG_ON ( n > dblks ) ; BUG_ON ( mp -> mp_bh [ end_of_metadata ] == NULL ) ; gfs2_trans_add_bh ( ip -> i_gl , mp -> mp_bh [ end_of_metadata ] , 1 ) ; dblks = n ; ptr = metapointer ( end_of_metadata , mp ) ; dblock = bn ; while ( n -- > 0 ) * ptr ++ = cpu_to_be64 ( bn ++ ) ;  break ;  } } while ( ( state != ALLOC_DATA ) || ! dblock ) ; ip -> i_height = height ; gfs2_add_inode_blocks ( & ip -> i_inode , alloced ) ; gfs2_dinode_out ( ip , mp -> mp_bh [ 0 ] -> b_data ) ; map_bh ( bh_map , inode -> i_sb , dblock ) ; bh_map -> b_size = dblks << inode -> i_blkbits ; set_buffer_new ( bh_map ) ; return 0 ; }","struct super_block * sb = sdp -> sd_vfs ;struct buffer_head * dibh = mp -> mp_bh [ 0 ] ;u64 bn , dblock = 0 ;const unsigned end_of_metadata = height - 1 ;int ret ;int eob = 0 ;",515
700,"buggy line: cwe id:CWE-119context: static int gfs2_bmap_alloc ( struct inode * inode , const sector_t lblock , struct buffer_head * bh_map , struct metapath * mp , const unsigned int sheight , const unsigned int height , const unsigned int maxlen ) { struct gfs2_inode * ip = GFS2_I ( inode ) ; struct gfs2_sbd * sdp = GFS2_SB ( inode ) ;  struct buffer_head * dibh = mp -> mp_bh [ 0 ] ;  u64 bn , dblock = 0 ; unsigned n , i , blks , alloced = 0 , iblks = 0 , branch_start = 0 ; unsigned dblks = 0 ; unsigned ptrs_per_blk ;  const unsigned end_of_metadata = height - 1 ;  int eob = 0 ; enum alloc_state state ; __be64 * ptr ; __be64 zero_bn = 0 ; BUG_ON ( sheight < 1 ) ; BUG_ON ( dibh == NULL ) ; gfs2_trans_add_bh ( ip -> i_gl , dibh , 1 ) ; if ( height == sheight ) { struct buffer_head * bh ; ptr = metapointer ( end_of_metadata , mp ) ; bh = mp -> mp_bh [ end_of_metadata ] ; dblks = gfs2_extent_length ( bh -> b_data , bh -> b_size , ptr , maxlen , & eob ) ; BUG_ON ( dblks < 1 ) ; state = ALLOC_DATA ; } else { ptrs_per_blk = height > 1 ? sdp -> sd_inptrs : sdp -> sd_diptrs ; dblks = min ( maxlen , ptrs_per_blk - mp -> mp_list [ end_of_metadata ] ) ; if ( height == ip -> i_height ) { iblks = height - sheight ; state = ALLOC_GROW_DEPTH ; } else { state = ALLOC_GROW_HEIGHT ; iblks = height - ip -> i_height ; branch_start = metapath_branch_start ( mp ) ; iblks += ( height - branch_start ) ; } } blks = dblks + iblks ; i = sheight ; do { int error ; n = blks - alloced ; error = gfs2_alloc_block ( ip , & bn , & n ) ; if ( error ) return error ; alloced += n ; if ( state != ALLOC_DATA || gfs2_is_jdata ( ip ) ) gfs2_trans_add_unrevoke ( sdp , bn , n ) ; switch ( state ) { case ALLOC_GROW_HEIGHT : if ( i == 1 ) { ptr = ( __be64 * ) ( dibh -> b_data + sizeof ( struct gfs2_dinode ) ) ; zero_bn = * ptr ; } for ( ; i - 1 < height - ip -> i_height && n > 0 ; i ++ , n -- ) gfs2_indirect_init ( mp , ip -> i_gl , i , 0 , bn ++ ) ; if ( i - 1 == height - ip -> i_height ) { i -- ; gfs2_buffer_copy_tail ( mp -> mp_bh [ i ] , sizeof ( struct gfs2_meta_header ) , dibh , sizeof ( struct gfs2_dinode ) ) ; gfs2_buffer_clear_tail ( dibh , sizeof ( struct gfs2_dinode ) + sizeof ( __be64 ) ) ; ptr = ( __be64 * ) ( mp -> mp_bh [ i ] -> b_data + sizeof ( struct gfs2_meta_header ) ) ; * ptr = zero_bn ; state = ALLOC_GROW_DEPTH ; for ( i = branch_start ; i < height ; i ++ ) { if ( mp -> mp_bh [ i ] == NULL ) break ; brelse ( mp -> mp_bh [ i ] ) ; mp -> mp_bh [ i ] = NULL ; } i = branch_start ; } if ( n == 0 ) break ; case ALLOC_GROW_DEPTH : if ( i > 1 && i < height ) gfs2_trans_add_bh ( ip -> i_gl , mp -> mp_bh [ i - 1 ] , 1 ) ; for ( ; i < height && n > 0 ; i ++ , n -- ) gfs2_indirect_init ( mp , ip -> i_gl , i , mp -> mp_list [ i - 1 ] , bn ++ ) ; if ( i == height ) state = ALLOC_DATA ; if ( n == 0 ) break ; case ALLOC_DATA : BUG_ON ( n > dblks ) ; BUG_ON ( mp -> mp_bh [ end_of_metadata ] == NULL ) ; gfs2_trans_add_bh ( ip -> i_gl , mp -> mp_bh [ end_of_metadata ] , 1 ) ; dblks = n ; ptr = metapointer ( end_of_metadata , mp ) ; dblock = bn ; while ( n -- > 0 ) * ptr ++ = cpu_to_be64 ( bn ++ ) ;  break ;  } } while ( ( state != ALLOC_DATA ) || ! dblock ) ; ip -> i_height = height ; gfs2_add_inode_blocks ( & ip -> i_inode , alloced ) ; gfs2_dinode_out ( ip , mp -> mp_bh [ 0 ] -> b_data ) ; map_bh ( bh_map , inode -> i_sb , dblock ) ; bh_map -> b_size = dblks << inode -> i_blkbits ; set_buffer_new ( bh_map ) ; return 0 ; }","if ( buffer_zeronew ( bh_map ) ) {ret = sb_issue_zeroout ( sb , dblock , dblks , GFP_NOFS ) ;if ( ret ) {fs_err ( sdp , ""Failed<S2SV_blank>to<S2SV_blank>zero<S2SV_blank>data<S2SV_blank>buffers\\\clear_buffer_zeronew ( bh_map ) ;}}",515
701,"buggy line: break ;}cwe id:CWE-119context: static int gfs2_bmap_alloc ( struct inode * inode , const sector_t lblock , struct buffer_head * bh_map , struct metapath * mp , const unsigned int sheight , const unsigned int height , const unsigned int maxlen ) { struct gfs2_inode * ip = GFS2_I ( inode ) ; struct gfs2_sbd * sdp = GFS2_SB ( inode ) ;  struct buffer_head * dibh = mp -> mp_bh [ 0 ] ;  u64 bn , dblock = 0 ; unsigned n , i , blks , alloced = 0 , iblks = 0 , branch_start = 0 ; unsigned dblks = 0 ; unsigned ptrs_per_blk ;  const unsigned end_of_metadata = height - 1 ;  int eob = 0 ; enum alloc_state state ; __be64 * ptr ; __be64 zero_bn = 0 ; BUG_ON ( sheight < 1 ) ; BUG_ON ( dibh == NULL ) ; gfs2_trans_add_bh ( ip -> i_gl , dibh , 1 ) ; if ( height == sheight ) { struct buffer_head * bh ; ptr = metapointer ( end_of_metadata , mp ) ; bh = mp -> mp_bh [ end_of_metadata ] ; dblks = gfs2_extent_length ( bh -> b_data , bh -> b_size , ptr , maxlen , & eob ) ; BUG_ON ( dblks < 1 ) ; state = ALLOC_DATA ; } else { ptrs_per_blk = height > 1 ? sdp -> sd_inptrs : sdp -> sd_diptrs ; dblks = min ( maxlen , ptrs_per_blk - mp -> mp_list [ end_of_metadata ] ) ; if ( height == ip -> i_height ) { iblks = height - sheight ; state = ALLOC_GROW_DEPTH ; } else { state = ALLOC_GROW_HEIGHT ; iblks = height - ip -> i_height ; branch_start = metapath_branch_start ( mp ) ; iblks += ( height - branch_start ) ; } } blks = dblks + iblks ; i = sheight ; do { int error ; n = blks - alloced ; error = gfs2_alloc_block ( ip , & bn , & n ) ; if ( error ) return error ; alloced += n ; if ( state != ALLOC_DATA || gfs2_is_jdata ( ip ) ) gfs2_trans_add_unrevoke ( sdp , bn , n ) ; switch ( state ) { case ALLOC_GROW_HEIGHT : if ( i == 1 ) { ptr = ( __be64 * ) ( dibh -> b_data + sizeof ( struct gfs2_dinode ) ) ; zero_bn = * ptr ; } for ( ; i - 1 < height - ip -> i_height && n > 0 ; i ++ , n -- ) gfs2_indirect_init ( mp , ip -> i_gl , i , 0 , bn ++ ) ; if ( i - 1 == height - ip -> i_height ) { i -- ; gfs2_buffer_copy_tail ( mp -> mp_bh [ i ] , sizeof ( struct gfs2_meta_header ) , dibh , sizeof ( struct gfs2_dinode ) ) ; gfs2_buffer_clear_tail ( dibh , sizeof ( struct gfs2_dinode ) + sizeof ( __be64 ) ) ; ptr = ( __be64 * ) ( mp -> mp_bh [ i ] -> b_data + sizeof ( struct gfs2_meta_header ) ) ; * ptr = zero_bn ; state = ALLOC_GROW_DEPTH ; for ( i = branch_start ; i < height ; i ++ ) { if ( mp -> mp_bh [ i ] == NULL ) break ; brelse ( mp -> mp_bh [ i ] ) ; mp -> mp_bh [ i ] = NULL ; } i = branch_start ; } if ( n == 0 ) break ; case ALLOC_GROW_DEPTH : if ( i > 1 && i < height ) gfs2_trans_add_bh ( ip -> i_gl , mp -> mp_bh [ i - 1 ] , 1 ) ; for ( ; i < height && n > 0 ; i ++ , n -- ) gfs2_indirect_init ( mp , ip -> i_gl , i , mp -> mp_list [ i - 1 ] , bn ++ ) ; if ( i == height ) state = ALLOC_DATA ; if ( n == 0 ) break ; case ALLOC_DATA : BUG_ON ( n > dblks ) ; BUG_ON ( mp -> mp_bh [ end_of_metadata ] == NULL ) ; gfs2_trans_add_bh ( ip -> i_gl , mp -> mp_bh [ end_of_metadata ] , 1 ) ; dblks = n ; ptr = metapointer ( end_of_metadata , mp ) ; dblock = bn ; while ( n -- > 0 ) * ptr ++ = cpu_to_be64 ( bn ++ ) ;  break ;  } } while ( ( state != ALLOC_DATA ) || ! dblock ) ; ip -> i_height = height ; gfs2_add_inode_blocks ( & ip -> i_inode , alloced ) ; gfs2_dinode_out ( ip , mp -> mp_bh [ 0 ] -> b_data ) ; map_bh ( bh_map , inode -> i_sb , dblock ) ; bh_map -> b_size = dblks << inode -> i_blkbits ; set_buffer_new ( bh_map ) ; return 0 ; }",break ;},515
702,"buggy line: fprintf ( stderr , ""Codec:<S2SV_blank>%s\\\fprintf ( stderr , ""Source<S2SV_blank>file:<S2SV_blank>%s<S2SV_blank>Format:<S2SV_blank>%s\\\}SHOW ( g_timebase . num ) ;SHOW ( g_timebase . den ) ;SHOW ( rc_resize_allowed ) ;SHOW ( rc_resize_up_thresh ) ;cwe id:CWE-119context: static void show_stream_config ( struct stream_state * stream , struct VpxEncoderConfig * global , struct VpxInputContext * input ) { # define SHOW ( field ) fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%-28s<S2SV_blank>=<S2SV_blank>%d\\n"" , # field , stream -> config . cfg . field ) if ( stream -> index == 0 ) { fprintf ( stderr , ""Codec:<S2SV_blank>%s\\n"" ,  vpx_codec_iface_name ( global -> codec -> interface ( ) ) ) ;  fprintf ( stderr , ""Source<S2SV_blank>file:<S2SV_blank>%s<S2SV_blank>Format:<S2SV_blank>%s\\n"" , input -> filename ,  input -> use_i420 ? ""I420"" : ""YV12"" ) ;  } if ( stream -> next || stream -> index ) fprintf ( stderr , ""\\nStream<S2SV_blank>Index:<S2SV_blank>%d\\n"" , stream -> index ) ; fprintf ( stderr , ""Destination<S2SV_blank>file:<S2SV_blank>%s\\n"" , stream -> config . out_fn ) ; fprintf ( stderr , ""Encoder<S2SV_blank>parameters:\\n"" ) ; SHOW ( g_usage ) ; SHOW ( g_threads ) ; SHOW ( g_profile ) ; SHOW ( g_w ) ; SHOW ( g_h ) ;  SHOW ( g_timebase . num ) ;  SHOW ( g_timebase . den ) ; SHOW ( g_error_resilient ) ; SHOW ( g_pass ) ; SHOW ( g_lag_in_frames ) ; SHOW ( rc_dropframe_thresh ) ;  SHOW ( rc_resize_allowed ) ;  SHOW ( rc_resize_up_thresh ) ; SHOW ( rc_resize_down_thresh ) ; SHOW ( rc_end_usage ) ; SHOW ( rc_target_bitrate ) ; SHOW ( rc_min_quantizer ) ; SHOW ( rc_max_quantizer ) ; SHOW ( rc_undershoot_pct ) ; SHOW ( rc_overshoot_pct ) ; SHOW ( rc_buf_sz ) ; SHOW ( rc_buf_initial_sz ) ; SHOW ( rc_buf_optimal_sz ) ; SHOW ( rc_2pass_vbr_bias_pct ) ; SHOW ( rc_2pass_vbr_minsection_pct ) ; SHOW ( rc_2pass_vbr_maxsection_pct ) ; SHOW ( kf_mode ) ; SHOW ( kf_min_dist ) ; SHOW ( kf_max_dist ) ; }","fprintf ( stderr , ""Codec:<S2SV_blank>%s\\\fprintf ( stderr , ""Source<S2SV_blank>file:<S2SV_blank>%s<S2SV_blank>File<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>Format:<S2SV_blank>%s\\\}SHOW ( g_bit_depth ) ;SHOW ( g_input_bit_depth ) ;SHOW ( g_timebase . num ) ;SHOW ( g_timebase . den ) ;SHOW ( rc_resize_allowed ) ;SHOW ( rc_scaled_width ) ;SHOW ( rc_scaled_height ) ;SHOW ( rc_resize_up_thresh ) ;",516
703,"buggy line: cwe id:CWE-787context: BOOL nsc_process_message ( NSC_CONTEXT * context , UINT16 bpp , UINT32 width , UINT32 height , const BYTE * data , UINT32 length , BYTE * pDstData , UINT32 DstFormat , UINT32 nDstStride , UINT32 nXDst , UINT32 nYDst , UINT32 nWidth , UINT32 nHeight , UINT32 flip ) { wStream * s ; BOOL ret ; s = Stream_New ( ( BYTE * ) data , length ) ; if ( ! s ) return FALSE ; if ( nDstStride == 0 ) nDstStride = nWidth * GetBytesPerPixel ( DstFormat ) ; switch ( bpp ) { case 32 : context -> format = PIXEL_FORMAT_BGRA32 ; break ; case 24 : context -> format = PIXEL_FORMAT_BGR24 ; break ; case 16 : context -> format = PIXEL_FORMAT_BGR16 ; break ; case 8 : context -> format = PIXEL_FORMAT_RGB8 ; break ; case 4 : context -> format = PIXEL_FORMAT_A4 ; break ; default : Stream_Free ( s , TRUE ) ; return FALSE ; } context -> width = width ; context -> height = height ; ret = nsc_context_initialize ( context , s ) ; Stream_Free ( s , FALSE ) ; if ( ! ret ) return FALSE ;  PROFILER_ENTER ( context -> priv -> prof_nsc_rle_decompress_data )   nsc_rle_decompress_data ( context ) ;  PROFILER_EXIT ( context -> priv -> prof_nsc_rle_decompress_data )  PROFILER_ENTER ( context -> priv -> prof_nsc_decode )   context -> decode ( context ) ;   PROFILER_EXIT ( context -> priv -> prof_nsc_decode )  if ( ! freerdp_image_copy ( pDstData , DstFormat , nDstStride , nXDst , nYDst , width , height , context -> BitmapData , PIXEL_FORMAT_BGRA32 , 0 , 0 , 0 , NULL , flip ) ) return FALSE ; return TRUE ; }",{BOOL rc ;,517
704,"buggy line: PROFILER_ENTER ( context -> priv -> prof_nsc_rle_decompress_data )   nsc_rle_decompress_data ( context ) ;PROFILER_EXIT ( context -> priv -> prof_nsc_rle_decompress_data )  PROFILER_ENTER ( context -> priv -> prof_nsc_decode )   context -> decode ( context ) ;PROFILER_EXIT ( context -> priv -> prof_nsc_decode )  if ( ! freerdp_image_copy ( pDstData , DstFormat , nDstStride , nXDst , nYDst , width , height , context -> BitmapData , PIXEL_FORMAT_BGRA32 , 0 , 0 , 0 , NULL , flip ) ) return FALSE ;cwe id:CWE-787context: BOOL nsc_process_message ( NSC_CONTEXT * context , UINT16 bpp , UINT32 width , UINT32 height , const BYTE * data , UINT32 length , BYTE * pDstData , UINT32 DstFormat , UINT32 nDstStride , UINT32 nXDst , UINT32 nYDst , UINT32 nWidth , UINT32 nHeight , UINT32 flip ) { wStream * s ; BOOL ret ; s = Stream_New ( ( BYTE * ) data , length ) ; if ( ! s ) return FALSE ; if ( nDstStride == 0 ) nDstStride = nWidth * GetBytesPerPixel ( DstFormat ) ; switch ( bpp ) { case 32 : context -> format = PIXEL_FORMAT_BGRA32 ; break ; case 24 : context -> format = PIXEL_FORMAT_BGR24 ; break ; case 16 : context -> format = PIXEL_FORMAT_BGR16 ; break ; case 8 : context -> format = PIXEL_FORMAT_RGB8 ; break ; case 4 : context -> format = PIXEL_FORMAT_A4 ; break ; default : Stream_Free ( s , TRUE ) ; return FALSE ; } context -> width = width ; context -> height = height ; ret = nsc_context_initialize ( context , s ) ; Stream_Free ( s , FALSE ) ; if ( ! ret ) return FALSE ;  PROFILER_ENTER ( context -> priv -> prof_nsc_rle_decompress_data )   nsc_rle_decompress_data ( context ) ;  PROFILER_EXIT ( context -> priv -> prof_nsc_rle_decompress_data )  PROFILER_ENTER ( context -> priv -> prof_nsc_decode )   context -> decode ( context ) ;   PROFILER_EXIT ( context -> priv -> prof_nsc_decode )  if ( ! freerdp_image_copy ( pDstData , DstFormat , nDstStride , nXDst , nYDst , width , height , context -> BitmapData , PIXEL_FORMAT_BGRA32 , 0 , 0 , 0 , NULL , flip ) ) return FALSE ; return TRUE ; }","PROFILER_ENTER ( context -> priv -> prof_nsc_rle_decompress_data ) rc = nsc_rle_decompress_data ( context ) ;PROFILER_EXIT ( context -> priv -> prof_nsc_rle_decompress_data ) if ( ! rc ) return FALSE ;}{BOOL rc ;PROFILER_ENTER ( context -> priv -> prof_nsc_decode ) rc = context -> decode ( context ) ;PROFILER_EXIT ( context -> priv -> prof_nsc_decode ) if ( ! rc ) return FALSE ;}if ( ! freerdp_image_copy ( pDstData , DstFormat , nDstStride , nXDst , nYDst , width , height , context -> BitmapData , PIXEL_FORMAT_BGRA32 , 0 , 0 , 0 , NULL , flip ) ) return FALSE ;",517
705,"buggy line: else if ( ( ctxt -> internalized ) && ( target -> doc != NULL ) &&  ( target -> doc -> dict == ctxt -> dict ) )  {cwe id:CWE-399context: xmlAttrPtr xsltAttrListTemplateProcess ( xsltTransformContextPtr ctxt , xmlNodePtr target , xmlAttrPtr attrs ) { xmlAttrPtr attr , copy , last ; xmlNodePtr oldInsert , text ; xmlNsPtr origNs = NULL , copyNs = NULL ; const xmlChar * value ; xmlChar * valueAVT ; if ( ( ctxt == NULL ) || ( target == NULL ) || ( attrs == NULL ) ) return ( NULL ) ; oldInsert = ctxt -> insert ; ctxt -> insert = target ; if ( target -> properties ) { last = target -> properties ; while ( last -> next != NULL ) last = last -> next ; } else { last = NULL ; } attr = attrs ; do { # ifdef XSLT_REFACTORED if ( attr -> psvi == xsltXSLTAttrMarker ) { goto next_attribute ; } # else if ( ( attr -> ns != NULL ) && xmlStrEqual ( attr -> ns -> href , XSLT_NAMESPACE ) ) { goto next_attribute ; } # endif if ( attr -> children != NULL ) { if ( ( attr -> children -> type != XML_TEXT_NODE ) || ( attr -> children -> next != NULL ) ) { xsltTransformError ( ctxt , NULL , attr -> parent , ""Internal<S2SV_blank>error:<S2SV_blank>The<S2SV_blank>children<S2SV_blank>of<S2SV_blank>an<S2SV_blank>attribute<S2SV_blank>node<S2SV_blank>of<S2SV_blank>a<S2SV_blank>"" ""literal<S2SV_blank>result<S2SV_blank>element<S2SV_blank>are<S2SV_blank>not<S2SV_blank>in<S2SV_blank>the<S2SV_blank>expected<S2SV_blank>form.\\n"" ) ; goto error ; } value = attr -> children -> content ; if ( value == NULL ) value = xmlDictLookup ( ctxt -> dict , BAD_CAST """" , 0 ) ; } else value = xmlDictLookup ( ctxt -> dict , BAD_CAST """" , 0 ) ; copy = xmlNewDocProp ( target -> doc , attr -> name , NULL ) ; if ( copy == NULL ) { if ( attr -> ns ) { xsltTransformError ( ctxt , NULL , attr -> parent , ""Internal<S2SV_blank>error:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>attribute<S2SV_blank>\'{%s}%s\'.\\n"" , attr -> ns -> href , attr -> name ) ; } else { xsltTransformError ( ctxt , NULL , attr -> parent , ""Internal<S2SV_blank>error:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>attribute<S2SV_blank>\'%s\'.\\n"" , attr -> name ) ; } goto error ; } copy -> parent = target ; if ( last == NULL ) { target -> properties = copy ; last = copy ; } else { last -> next = copy ; copy -> prev = last ; last = copy ; } if ( attr -> ns != origNs ) { origNs = attr -> ns ; if ( attr -> ns != NULL ) { # ifdef XSLT_REFACTORED copyNs = xsltGetSpecialNamespace ( ctxt , attr -> parent , attr -> ns -> href , attr -> ns -> prefix , target ) ; # else copyNs = xsltGetNamespace ( ctxt , attr -> parent , attr -> ns , target ) ; # endif if ( copyNs == NULL ) goto error ; } else copyNs = NULL ; } copy -> ns = copyNs ; text = xmlNewText ( NULL ) ; if ( text != NULL ) { copy -> last = copy -> children = text ; text -> parent = ( xmlNodePtr ) copy ; text -> doc = copy -> doc ; if ( attr -> psvi != NULL ) { valueAVT = xsltEvalAVT ( ctxt , attr -> psvi , attr -> parent ) ; if ( valueAVT == NULL ) { if ( attr -> ns ) { xsltTransformError ( ctxt , NULL , attr -> parent , ""Internal<S2SV_blank>error:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>evaluate<S2SV_blank>the<S2SV_blank>AVT<S2SV_blank>"" ""of<S2SV_blank>attribute<S2SV_blank>\'{%s}%s\'.\\n"" , attr -> ns -> href , attr -> name ) ; } else { xsltTransformError ( ctxt , NULL , attr -> parent , ""Internal<S2SV_blank>error:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>evaluate<S2SV_blank>the<S2SV_blank>AVT<S2SV_blank>"" ""of<S2SV_blank>attribute<S2SV_blank>\'%s\'.\\n"" , attr -> name ) ; } text -> content = xmlStrdup ( BAD_CAST """" ) ; goto error ; } else { text -> content = valueAVT ; } } else if ( ( ctxt -> internalized ) && ( target -> doc != NULL ) &&  ( target -> doc -> dict == ctxt -> dict ) )  { text -> content = ( xmlChar * ) value ; } else { text -> content = xmlStrdup ( value ) ; } if ( ( copy != NULL ) && ( text != NULL ) && ( xmlIsID ( copy -> doc , copy -> parent , copy ) ) ) xmlAddID ( NULL , copy -> doc , text -> content , copy ) ; } next_attribute : attr = attr -> next ; } while ( attr != NULL ) ; attr = attrs ; do { # ifdef XSLT_REFACTORED if ( ( attr -> psvi == xsltXSLTAttrMarker ) && xmlStrEqual ( attr -> name , ( const xmlChar * ) ""use-attribute-sets"" ) ) { xsltApplyAttributeSet ( ctxt , ctxt -> node , ( xmlNodePtr ) attr , NULL ) ; } # else if ( ( attr -> ns != NULL ) && xmlStrEqual ( attr -> name , ( const xmlChar * ) ""use-attribute-sets"" ) && xmlStrEqual ( attr -> ns -> href , XSLT_NAMESPACE ) ) { xsltApplyAttributeSet ( ctxt , ctxt -> node , ( xmlNodePtr ) attr , NULL ) ; } # endif attr = attr -> next ; } while ( attr != NULL ) ; ctxt -> insert = oldInsert ; return ( target -> properties ) ; error : ctxt -> insert = oldInsert ; return ( NULL ) ; }","else if ( ( ctxt -> internalized ) && ( target -> doc != NULL ) && ( target -> doc -> dict == ctxt -> dict ) && xmlDictOwns ( ctxt -> dict , value ) ) {",518
706,"buggy line: if ( copy_file ( ""/etc/skel/.zshrc"" , fname , u , g , 0644 ) == 0 ) {fs_logger ( ""clone<S2SV_blank>/etc/skel/.zshrc"" ) ;}else {}}free ( fname ) ;}else if ( ! arg_shell_none && strcmp ( cfg . shell , ""/bin/csh"" ) == 0 ) {if ( asprintf ( & fname , ""%s/.cshrc"" , homedir ) == - 1 ) errExit ( ""asprintf"" ) ;struct stat s ;if ( stat ( fname , & s ) == 0 ) return ;if ( stat ( ""/etc/skel/.cshrc"" , & s ) == 0 ) {if ( copy_file ( ""/etc/skel/.cshrc"" , fname , u , g , 0644 ) == 0 ) {fs_logger ( ""clone<S2SV_blank>/etc/skel/.cshrc"" ) ;}else {FILE * fp = fopen ( fname , ""w"" ) ;if ( fp ) {fprintf ( fp , ""\\\SET_PERMS_STREAM ( fp , u , g , S_IRUSR | S_IWUSR ) ;fclose ( fp ) ;}}cwe id:CWE-269context: static void skel ( const char * homedir , uid_t u , gid_t g ) { char * fname ; if ( ! arg_shell_none && ( strcmp ( cfg . shell , ""/usr/bin/zsh"" ) == 0 || strcmp ( cfg . shell , ""/bin/zsh"" ) == 0 ) ) { if ( asprintf ( & fname , ""%s/.zshrc"" , homedir ) == - 1 ) errExit ( ""asprintf"" ) ; struct stat s ; if ( stat ( fname , & s ) == 0 ) return ; if ( stat ( ""/etc/skel/.zshrc"" , & s ) == 0 ) {  if ( copy_file ( ""/etc/skel/.zshrc"" , fname , u , g , 0644 ) == 0 ) {  fs_logger ( ""clone<S2SV_blank>/etc/skel/.zshrc"" ) ; }  }  else { FILE * fp = fopen ( fname , ""w"" ) ; if ( fp ) { fprintf ( fp , ""\\n"" ) ; SET_PERMS_STREAM ( fp , u , g , S_IRUSR | S_IWUSR ) ; fclose ( fp ) ; fs_logger2 ( ""touch"" , fname ) ;  }  } free ( fname ) ; } else if ( ! arg_shell_none && strcmp ( cfg . shell , ""/bin/csh"" ) == 0 ) { if ( asprintf ( & fname , ""%s/.cshrc"" , homedir ) == - 1 ) errExit ( ""asprintf"" ) ; struct stat s ; if ( stat ( fname , & s ) == 0 ) return ; if ( stat ( ""/etc/skel/.cshrc"" , & s ) == 0 ) {  if ( copy_file ( ""/etc/skel/.cshrc"" , fname , u , g , 0644 ) == 0 ) {  fs_logger ( ""clone<S2SV_blank>/etc/skel/.cshrc"" ) ; }  }  else { FILE * fp = fopen ( fname , ""w"" ) ; if ( fp ) { fprintf ( fp , ""\\n"" ) ; SET_PERMS_STREAM ( fp , u , g , S_IRUSR | S_IWUSR ) ; fclose ( fp ) ; fs_logger2 ( ""touch"" , fname ) ;  }  } free ( fname ) ; } else { if ( asprintf ( & fname , ""%s/.bashrc"" , homedir ) == - 1 ) errExit ( ""asprintf"" ) ; struct stat s ; if ( stat ( fname , & s ) == 0 ) return ; if ( stat ( ""/etc/skel/.bashrc"" , & s ) == 0 ) {  if ( copy_file ( ""/etc/skel/.bashrc"" , fname , u , g , 0644 ) == 0 ) {  fs_logger ( ""clone<S2SV_blank>/etc/skel/.bashrc"" ) ; }  }  free ( fname ) ; } }","copy_file ( ""/etc/skel/.zshrc"" , fname , u , g , 0644 ) ;fs_logger ( ""clone<S2SV_blank>/etc/skel/.zshrc"" ) ;}else {else {touch_file_as_user ( fname , u , g , 0644 ) ;}}",519
707,"buggy line: if ( copy_file ( ""/etc/skel/.bashrc"" , fname , u , g , 0644 ) == 0 ) {fs_logger ( ""clone<S2SV_blank>/etc/skel/.bashrc"" ) ;}free ( fname ) ;cwe id:CWE-269context: static void skel ( const char * homedir , uid_t u , gid_t g ) { char * fname ; if ( ! arg_shell_none && ( strcmp ( cfg . shell , ""/usr/bin/zsh"" ) == 0 || strcmp ( cfg . shell , ""/bin/zsh"" ) == 0 ) ) { if ( asprintf ( & fname , ""%s/.zshrc"" , homedir ) == - 1 ) errExit ( ""asprintf"" ) ; struct stat s ; if ( stat ( fname , & s ) == 0 ) return ; if ( stat ( ""/etc/skel/.zshrc"" , & s ) == 0 ) {  if ( copy_file ( ""/etc/skel/.zshrc"" , fname , u , g , 0644 ) == 0 ) {  fs_logger ( ""clone<S2SV_blank>/etc/skel/.zshrc"" ) ; }  }  else { FILE * fp = fopen ( fname , ""w"" ) ; if ( fp ) { fprintf ( fp , ""\\n"" ) ; SET_PERMS_STREAM ( fp , u , g , S_IRUSR | S_IWUSR ) ; fclose ( fp ) ; fs_logger2 ( ""touch"" , fname ) ;  }  } free ( fname ) ; } else if ( ! arg_shell_none && strcmp ( cfg . shell , ""/bin/csh"" ) == 0 ) { if ( asprintf ( & fname , ""%s/.cshrc"" , homedir ) == - 1 ) errExit ( ""asprintf"" ) ; struct stat s ; if ( stat ( fname , & s ) == 0 ) return ; if ( stat ( ""/etc/skel/.cshrc"" , & s ) == 0 ) {  if ( copy_file ( ""/etc/skel/.cshrc"" , fname , u , g , 0644 ) == 0 ) {  fs_logger ( ""clone<S2SV_blank>/etc/skel/.cshrc"" ) ; }  }  else { FILE * fp = fopen ( fname , ""w"" ) ; if ( fp ) { fprintf ( fp , ""\\n"" ) ; SET_PERMS_STREAM ( fp , u , g , S_IRUSR | S_IWUSR ) ; fclose ( fp ) ; fs_logger2 ( ""touch"" , fname ) ;  }  } free ( fname ) ; } else { if ( asprintf ( & fname , ""%s/.bashrc"" , homedir ) == - 1 ) errExit ( ""asprintf"" ) ; struct stat s ; if ( stat ( fname , & s ) == 0 ) return ; if ( stat ( ""/etc/skel/.bashrc"" , & s ) == 0 ) {  if ( copy_file ( ""/etc/skel/.bashrc"" , fname , u , g , 0644 ) == 0 ) {  fs_logger ( ""clone<S2SV_blank>/etc/skel/.bashrc"" ) ; }  }  free ( fname ) ; } }","if ( copy_file ( ""/etc/skel/.bashrc"" , fname , u , g , 0644 ) == 0 ) {fs_logger ( ""clone<S2SV_blank>/etc/skel/.bashrc"" ) ;}free ( fname ) ;",519
708,"buggy line: static int decode_getacl ( struct xdr_stream * xdr , struct rpc_rqst * req ,  size_t * acl_len )  {__be32 * savep ;uint32_t attrlen , bitmap [ 3 ] = {* acl_len = 0 ;if ( ( status = decode_op_hdr ( xdr , OP_GETATTR ) ) != 0 )  goto out ;if ( ( status = decode_attr_bitmap ( xdr , bitmap ) ) != 0 ) goto out ;hdrlen = ( u8 * ) xdr -> p - ( u8 * ) iov -> iov_base ;recvd = req -> rq_rcv_buf . len - hdrlen ;dprintk ( ""NFS:<S2SV_blank>server<S2SV_blank>cheating<S2SV_blank>in<S2SV_blank>getattr""  ""<S2SV_blank>acl<S2SV_blank>reply:<S2SV_blank>attrlen<S2SV_blank>%u<S2SV_blank>><S2SV_blank>recvd<S2SV_blank>%u\\\* acl_len = attrlen ;}cwe id:CWE-189context: static int decode_getacl ( struct xdr_stream * xdr , struct rpc_rqst * req ,  size_t * acl_len )  {  __be32 * savep ;  uint32_t attrlen , bitmap [ 3 ] = { 0 } ; struct kvec * iov = req -> rq_rcv_buf . head ; int status ;  * acl_len = 0 ;  if ( ( status = decode_op_hdr ( xdr , OP_GETATTR ) ) != 0 )  goto out ;  if ( ( status = decode_attr_bitmap ( xdr , bitmap ) ) != 0 ) goto out ; if ( ( status = decode_attr_length ( xdr , & attrlen , & savep ) ) != 0 ) goto out ; if ( unlikely ( bitmap [ 0 ] & ( FATTR4_WORD0_ACL - 1U ) ) ) return - EIO ; if ( likely ( bitmap [ 0 ] & FATTR4_WORD0_ACL ) ) { size_t hdrlen ; u32 recvd ;  hdrlen = ( u8 * ) xdr -> p - ( u8 * ) iov -> iov_base ;  recvd = req -> rq_rcv_buf . len - hdrlen ; if ( attrlen > recvd ) {  dprintk ( ""NFS:<S2SV_blank>server<S2SV_blank>cheating<S2SV_blank>in<S2SV_blank>getattr""  ""<S2SV_blank>acl<S2SV_blank>reply:<S2SV_blank>attrlen<S2SV_blank>%u<S2SV_blank>><S2SV_blank>recvd<S2SV_blank>%u\\n"" , attrlen , recvd ) ; return - EINVAL ; } xdr_read_pages ( xdr , attrlen ) ;  * acl_len = attrlen ;  } else status = - EOPNOTSUPP ; out : return status ; }","static int decode_getacl ( struct xdr_stream * xdr , struct rpc_rqst * req , struct nfs_getaclres * res ) {__be32 * savep , * bm_p ;uint32_t attrlen , bitmap [ 3 ] = {res -> acl_len = 0 ;if ( ( status = decode_op_hdr ( xdr , OP_GETATTR ) ) != 0 ) goto out ;bm_p = xdr -> p ;if ( ( status = decode_attr_bitmap ( xdr , bitmap ) ) != 0 ) goto out ;xdr -> p = bm_p ;res -> acl_data_offset = be32_to_cpup ( bm_p ) + 2 ;res -> acl_data_offset <<= 2 ;hdrlen = ( u8 * ) xdr -> p - ( u8 * ) iov -> iov_base ;attrlen += res -> acl_data_offset ;recvd = req -> rq_rcv_buf . len - hdrlen ;if ( res -> acl_flags & NFS4_ACL_LEN_REQUEST ) {res -> acl_len = attrlen ;goto out ;}dprintk ( ""NFS:<S2SV_blank>acl<S2SV_blank>reply:<S2SV_blank>attrlen<S2SV_blank>%u<S2SV_blank>><S2SV_blank>recvd<S2SV_blank>%u\\\res -> acl_len = attrlen ;}",520
709,buggy line: if ( fv -> b . nextsame != NULL || fv -> b . sf -> fv != & fv -> b ) {}cwe id:CWE-119context: static int _FVMenuClose ( FontView * fv ) { int i ; SplineFont * sf = fv -> b . cidmaster ? fv -> b . cidmaster : fv -> b . sf ; if ( ! SFCloseAllInstrs ( fv -> b . sf ) ) return ( false ) ;  if ( fv -> b . nextsame != NULL || fv -> b . sf -> fv != & fv -> b ) {  } else if ( SFAnyChanged ( sf ) ) { i = AskChanged ( fv -> b . sf ) ; if ( i == 2 ) return ( false ) ; if ( i == 0 && ! _FVMenuSave ( fv ) ) return ( false ) ; else SFClearAutoSave ( sf ) ; } _FVCloseWindows ( fv ) ; if ( sf -> filename != NULL ) RecentFilesRemember ( sf -> filename ) ; else if ( sf -> origname != NULL ) RecentFilesRemember ( sf -> origname ) ; GDrawDestroyWindow ( fv -> gw ) ; return ( true ) ; },if ( fv -> b . nextsame != NULL || fv -> b . sf -> fv != & fv -> b ) {}else if ( warn_script_unsaved && fv -> script_unsaved && AskScriptChanged ( ) == 2 ) {return false ;},521
710,"buggy line: assert ( msix_tab_size % 4096 == 0 ) ;bzero ( msixcap , sizeof ( struct msixcap ) ) ;cwe id:CWE-617context: static void pci_populate_msixcap ( struct msixcap * msixcap , int msgnum , int barnum , uint32_t msix_tab_size ) {  assert ( msix_tab_size % 4096 == 0 ) ;  bzero ( msixcap , sizeof ( struct msixcap ) ) ; msixcap -> capid = PCIY_MSIX ; msixcap -> msgctrl = msgnum - 1 ; msixcap -> table_info = barnum & PCIM_MSIX_BIR_MASK ; msixcap -> pba_info = msix_tab_size | ( barnum & PCIM_MSIX_BIR_MASK ) ; }","bzero ( msixcap , sizeof ( struct msixcap ) ) ;",522
711,"buggy line: when = timespec_to_ns ( new_setting -> it_value ) ;period = timespec_to_ns ( new_setting -> it_interval ) ;if ( when == 0 ) return 0 ;now = timespec_to_ns ( n ) ;if ( when > now ) when -= now ;cwe id:CWE-189context: static int sgi_timer_set ( struct k_itimer * timr , int flags , struct itimerspec * new_setting , struct itimerspec * old_setting ) { unsigned long when , period , irqflags ; int err = 0 ; cnodeid_t nodeid ; struct mmtimer * base ; struct rb_node * n ; if ( old_setting ) sgi_timer_get ( timr , old_setting ) ; sgi_timer_del ( timr ) ;  when = timespec_to_ns ( new_setting -> it_value ) ;   period = timespec_to_ns ( new_setting -> it_interval ) ;  if ( when == 0 ) return 0 ; base = kmalloc ( sizeof ( struct mmtimer ) , GFP_KERNEL ) ; if ( base == NULL ) return - ENOMEM ; if ( flags & TIMER_ABSTIME ) { struct timespec n ; unsigned long now ; getnstimeofday ( & n ) ;  now = timespec_to_ns ( n ) ;  if ( when > now ) when -= now ; else when = 0 ; } when = ( when + sgi_clock_period - 1 ) / sgi_clock_period + rtc_time ( ) ; period = ( period + sgi_clock_period - 1 ) / sgi_clock_period ; preempt_disable ( ) ; nodeid = cpu_to_node ( smp_processor_id ( ) ) ; spin_lock_irqsave ( & timers [ nodeid ] . lock , irqflags ) ; base -> timer = timr ; base -> cpu = smp_processor_id ( ) ; timr -> it . mmtimer . clock = TIMER_SET ; timr -> it . mmtimer . node = nodeid ; timr -> it . mmtimer . incr = period ; timr -> it . mmtimer . expires = when ; n = timers [ nodeid ] . next ; mmtimer_add_list ( base ) ; if ( timers [ nodeid ] . next == n ) { spin_unlock_irqrestore ( & timers [ nodeid ] . lock , irqflags ) ; preempt_enable ( ) ; return err ; } if ( n ) mmtimer_disable_int ( cnodeid_to_nasid ( nodeid ) , COMPARATOR ) ; mmtimer_set_next_timer ( nodeid ) ; spin_unlock_irqrestore ( & timers [ nodeid ] . lock , irqflags ) ; preempt_enable ( ) ; return err ; }",when = timespec_to_ns ( & new_setting -> it_value ) ;period = timespec_to_ns ( & new_setting -> it_interval ) ;if ( when == 0 ) return 0 ;now = timespec_to_ns ( & n ) ;if ( when > now ) when -= now ;,523
712,"buggy line: if ( ! js_regexec ( re -> prog , text , & m , 0 ) )  js_pushnumber ( J , js_utfptrtoidx ( text , m . sub [ 0 ] . sp ) ) ;cwe id:CWE-674context: static void Sp_search ( js_State * J ) { js_Regexp * re ; const char * text ; Resub m ; text = checkstring ( J , 0 ) ; if ( js_isregexp ( J , 1 ) ) js_copy ( J , 1 ) ; else if ( js_isundefined ( J , 1 ) ) js_newregexp ( J , """" , 0 ) ; else js_newregexp ( J , js_tostring ( J , 1 ) , 0 ) ; re = js_toregexp ( J , - 1 ) ;  if ( ! js_regexec ( re -> prog , text , & m , 0 ) )  js_pushnumber ( J , js_utfptrtoidx ( text , m . sub [ 0 ] . sp ) ) ; else js_pushnumber ( J , - 1 ) ; }","if ( ! js_doregexec ( J , re -> prog , text , & m , 0 ) ) js_pushnumber ( J , js_utfptrtoidx ( text , m . sub [ 0 ] . sp ) ) ;",524
713,"buggy line: case OFreshOID :  if ( Int_val ( Field ( ( value ) dest , 1 ) ) >= 0 )  caml_set_oo_id ( ( value ) dest ) ;cwe id:CWE-119context: static void intern_rec ( value * dest ) { unsigned int code ; tag_t tag ; mlsize_t size , len , ofs_ind ; value v ; asize_t ofs ; header_t header ; unsigned char digest [ 16 ] ; struct custom_operations * ops ; char * codeptr ; struct intern_item * sp ; sp = intern_stack ; ReadItems ( dest , 1 ) ; while ( sp != intern_stack ) { dest = sp -> dest ; switch ( sp -> op ) { case OFreshOID :  if ( Int_val ( Field ( ( value ) dest , 1 ) ) >= 0 )  caml_set_oo_id ( ( value ) dest ) ; sp -- ; break ; case OShift : * dest += sp -> arg ; sp -- ; break ; case OReadItems : sp -> dest ++ ; if ( -- ( sp -> arg ) == 0 ) sp -- ; code = read8u ( ) ; if ( code >= PREFIX_SMALL_INT ) { if ( code >= PREFIX_SMALL_BLOCK ) { tag = code & 0xF ; size = ( code >> 4 ) & 0x7 ; read_block : if ( size == 0 ) { v = Atom ( tag ) ; } else { v = Val_hp ( intern_dest ) ; if ( intern_obj_table != NULL ) intern_obj_table [ obj_counter ++ ] = v ; * intern_dest = Make_header ( size , tag , intern_color ) ; intern_dest += 1 + size ; if ( tag == Object_tag ) { Assert ( size >= 2 ) ; ReadItems ( & Field ( v , 2 ) , size - 2 ) ; PushItem ( ) ; sp -> op = OFreshOID ; sp -> dest = ( value * ) v ; sp -> arg = 1 ; ReadItems ( & Field ( v , 0 ) , 2 ) ; } else ReadItems ( & Field ( v , 0 ) , size ) ; } } else { v = Val_int ( code & 0x3F ) ; } } else { if ( code >= PREFIX_SMALL_STRING ) { len = ( code & 0x1F ) ; read_string : size = ( len + sizeof ( value ) ) / sizeof ( value ) ; v = Val_hp ( intern_dest ) ; if ( intern_obj_table != NULL ) intern_obj_table [ obj_counter ++ ] = v ; * intern_dest = Make_header ( size , String_tag , intern_color ) ; intern_dest += 1 + size ; Field ( v , size - 1 ) = 0 ; ofs_ind = Bsize_wsize ( size ) - 1 ; Byte ( v , ofs_ind ) = ofs_ind - len ; readblock ( String_val ( v ) , len ) ; } else { switch ( code ) { case CODE_INT8 : v = Val_long ( read8s ( ) ) ; break ; case CODE_INT16 : v = Val_long ( read16s ( ) ) ; break ; case CODE_INT32 : v = Val_long ( read32s ( ) ) ; break ; case CODE_INT64 : # ifdef ARCH_SIXTYFOUR v = Val_long ( read64s ( ) ) ; break ; # else intern_cleanup ( ) ; caml_failwith ( ""input_value:<S2SV_blank>integer<S2SV_blank>too<S2SV_blank>large"" ) ; break ; # endif case CODE_SHARED8 : ofs = read8u ( ) ; read_shared : Assert ( ofs > 0 ) ; Assert ( ofs <= obj_counter ) ; Assert ( intern_obj_table != NULL ) ; v = intern_obj_table [ obj_counter - ofs ] ; break ; case CODE_SHARED16 : ofs = read16u ( ) ; goto read_shared ; case CODE_SHARED32 : ofs = read32u ( ) ; goto read_shared ; case CODE_BLOCK32 : header = ( header_t ) read32u ( ) ; tag = Tag_hd ( header ) ; size = Wosize_hd ( header ) ; goto read_block ; case CODE_BLOCK64 : # ifdef ARCH_SIXTYFOUR header = ( header_t ) read64s ( ) ; tag = Tag_hd ( header ) ; size = Wosize_hd ( header ) ; goto read_block ; # else intern_cleanup ( ) ; caml_failwith ( ""input_value:<S2SV_blank>data<S2SV_blank>block<S2SV_blank>too<S2SV_blank>large"" ) ; break ; # endif case CODE_STRING8 : len = read8u ( ) ; goto read_string ; case CODE_STRING32 : len = read32u ( ) ; goto read_string ; case CODE_DOUBLE_LITTLE : case CODE_DOUBLE_BIG : v = Val_hp ( intern_dest ) ; if ( intern_obj_table != NULL ) intern_obj_table [ obj_counter ++ ] = v ; * intern_dest = Make_header ( Double_wosize , Double_tag , intern_color ) ; intern_dest += 1 + Double_wosize ; readfloat ( ( double * ) v , code ) ; break ; case CODE_DOUBLE_ARRAY8_LITTLE : case CODE_DOUBLE_ARRAY8_BIG : len = read8u ( ) ; read_double_array : size = len * Double_wosize ; v = Val_hp ( intern_dest ) ; if ( intern_obj_table != NULL ) intern_obj_table [ obj_counter ++ ] = v ; * intern_dest = Make_header ( size , Double_array_tag , intern_color ) ; intern_dest += 1 + size ; readfloats ( ( double * ) v , len , code ) ; break ; case CODE_DOUBLE_ARRAY32_LITTLE : case CODE_DOUBLE_ARRAY32_BIG : len = read32u ( ) ; goto read_double_array ; case CODE_CODEPOINTER : ofs = read32u ( ) ; readblock ( digest , 16 ) ; codeptr = intern_resolve_code_pointer ( digest , ofs ) ; if ( codeptr != NULL ) { v = ( value ) codeptr ; } else { value * function_placeholder = caml_named_value ( ""Debugger.function_placeholder"" ) ; if ( function_placeholder != NULL ) { v = * function_placeholder ; } else { intern_cleanup ( ) ; intern_bad_code_pointer ( digest ) ; } } break ; case CODE_INFIXPOINTER : ofs = read32u ( ) ; PushItem ( ) ; sp -> dest = dest ; sp -> op = OShift ; sp -> arg = ofs ; ReadItems ( dest , 1 ) ; continue ; case CODE_CUSTOM : ops = caml_find_custom_operations ( ( char * ) intern_src ) ; if ( ops == NULL ) { intern_cleanup ( ) ; caml_failwith ( ""input_value:<S2SV_blank>unknown<S2SV_blank>custom<S2SV_blank>block<S2SV_blank>identifier"" ) ; } while ( * intern_src ++ != 0 ) ; size = ops -> deserialize ( ( void * ) ( intern_dest + 2 ) ) ; size = 1 + ( size + sizeof ( value ) - 1 ) / sizeof ( value ) ; v = Val_hp ( intern_dest ) ; if ( intern_obj_table != NULL ) intern_obj_table [ obj_counter ++ ] = v ; * intern_dest = Make_header ( size , Custom_tag , intern_color ) ; Custom_ops_val ( v ) = ops ; if ( ops -> finalize != NULL && Is_young ( v ) ) { if ( caml_finalize_table . ptr >= caml_finalize_table . limit ) { CAMLassert ( caml_finalize_table . ptr == caml_finalize_table . limit ) ; caml_realloc_ref_table ( & caml_finalize_table ) ; } * caml_finalize_table . ptr ++ = ( value * ) v ; } intern_dest += 1 + size ; break ; default : intern_cleanup ( ) ; caml_failwith ( ""input_value:<S2SV_blank>ill-formed<S2SV_blank>message"" ) ; } } } * dest = v ; break ; default : Assert ( 0 ) ; } } intern_free_stack ( ) ; }","case OFreshOID : if ( Long_val ( Field ( ( value ) dest , 1 ) ) >= 0 ) caml_set_oo_id ( ( value ) dest ) ;",525
714,"buggy line: struct range * range ;struct evbuffer * evb = NULL ;size_t content_length ;int code = 500 , fd = - 1 , i , nranges , ret ;uint32_t boundary ;if ( ( range = parse_range ( range_str , st -> st_size , & nranges ) ) == NULL ) {code = 416 ;if ( ( evb = evbuffer_new ( ) ) == NULL ) {errstr = ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>file<S2SV_blank>buffer"" ;goto abort ;}( void ) snprintf ( content_range , sizeof ( content_range ) ,  ""bytes<S2SV_blank>%lld-%lld/%lld"" , range -> start , range -> end , st -> st_size ) ;content_length = range -> end - range -> start + 1 ;if ( buffer_add_range ( fd , evb , range ) == 0 )  goto abort ;content_length = 0 ;boundary = arc4random ( ) ;-%ud\\\\r\\\content_length += i ;if ( ( i = evbuffer_add_printf ( evb , ""Content-Type:<S2SV_blank>%s/%s\\\\r\\\content_length += i ;if ( ( i = evbuffer_add_printf ( evb , ""Content-Range:<S2SV_blank>bytes<S2SV_blank>%lld-%lld/%lld\\\\r\\\range ++ ;}if ( ( i = evbuffer_add_printf ( evb , ""\\\\r\\\-%ud--\\\\r\\\content_length += i ;( void ) strlcpy ( multipart_media . media_type , ""multipart"" , sizeof ( multipart_media . media_type ) ) ;( void ) snprintf ( multipart_media . media_subtype , sizeof ( multipart_media . media_subtype ) ,  ""byteranges;<S2SV_blank>boundary=%ud"" , boundary ) ;media = & multipart_media ;-%llu--\\\\r\\\close ( fd ) ;fd = - 1 ;case 0 :  goto done ;default : break ;if ( server_bufferevent_write_buffer ( clt , evb ) == - 1 )  goto fail ;bufferevent_enable ( clt -> clt_bev , EV_READ | EV_WRITE ) ;if ( clt -> clt_persist )  clt -> clt_toread = TOREAD_HTTP_HEADER ;else clt -> clt_toread = TOREAD_HTTP_NONE ;clt -> clt_done = 0 ;done : evbuffer_free ( evb ) ;server_reset_http ( clt ) ;abort :  if ( evb != NULL )  evbuffer_free ( evb ) ;cwe id:CWE-770context: int server_partial_file_request ( struct httpd * env , struct client * clt , char * path , struct stat * st , char * range_str ) { struct server_config * srv_conf = clt -> clt_srv_conf ; struct http_descriptor * resp = clt -> clt_descresp ; struct http_descriptor * desc = clt -> clt_descreq ; struct media_type * media , multipart_media ;  struct range * range ;  struct evbuffer * evb = NULL ;  size_t content_length ;   int code = 500 , fd = - 1 , i , nranges , ret ;  uint32_t boundary ; char content_range [ 64 ] ; const char * errstr = NULL ; if ( desc -> http_method != HTTP_METHOD_GET ) return server_file_request ( env , clt , path , st ) ;  if ( ( range = parse_range ( range_str , st -> st_size , & nranges ) ) == NULL ) {  code = 416 ; ( void ) snprintf ( content_range , sizeof ( content_range ) , ""bytes<S2SV_blank>*/%lld"" , st -> st_size ) ; errstr = content_range ; goto abort ; } if ( ( fd = open ( path , O_RDONLY ) ) == - 1 ) goto abort ; media = media_find_config ( env , srv_conf , path ) ;  if ( ( evb = evbuffer_new ( ) ) == NULL ) {  errstr = ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>file<S2SV_blank>buffer"" ; goto abort ; } if ( nranges == 1 ) {  ( void ) snprintf ( content_range , sizeof ( content_range ) ,  ""bytes<S2SV_blank>%lld-%lld/%lld"" , range -> start , range -> end , st -> st_size ) ; if ( kv_add ( & resp -> http_headers , ""Content-Range"" , content_range ) == NULL ) goto abort ;  content_length = range -> end - range -> start + 1 ;   if ( buffer_add_range ( fd , evb , range ) == 0 )  goto abort ; } else {  content_length = 0 ;  boundary = arc4random ( ) ; while ( nranges -- ) { if ( ( i = evbuffer_add_printf ( evb , ""\\r\\n--%ud\\r\\n"" , boundary ) ) == - 1 ) goto abort ;  content_length += i ;  if ( ( i = evbuffer_add_printf ( evb , ""Content-Type:<S2SV_blank>%s/%s\\r\\n"" , media -> media_type , media -> media_subtype ) ) == - 1 ) goto abort ; content_length += i ; if ( ( i = evbuffer_add_printf ( evb , ""Content-Range:<S2SV_blank>bytes<S2SV_blank>%lld-%lld/%lld\\r\\n\\r\\n"" , range -> start , range -> end , st -> st_size ) ) == - 1 ) goto abort ; content_length += i ; if ( buffer_add_range ( fd , evb , range ) == 0 ) goto abort ; content_length += range -> end - range -> start + 1 ;  range ++ ;  }  if ( ( i = evbuffer_add_printf ( evb , ""\\r\\n--%ud--\\r\\n"" ,  boundary ) ) == - 1 ) goto abort ;  content_length += i ;  ( void ) strlcpy ( multipart_media . media_type , ""multipart"" , sizeof ( multipart_media . media_type ) ) ; ( void ) snprintf ( multipart_media . media_subtype , sizeof ( multipart_media . media_subtype ) ,  ""byteranges;<S2SV_blank>boundary=%ud"" , boundary ) ;  media = & multipart_media ; }  close ( fd ) ;  fd = - 1 ; ret = server_response_http ( clt , 206 , media , content_length , MINIMUM ( time ( NULL ) , st -> st_mtim . tv_sec ) ) ; switch ( ret ) { case - 1 : goto fail ; case 0 :  goto done ;  default : break ; }  if ( server_bufferevent_write_buffer ( clt , evb ) == - 1 )  goto fail ;  bufferevent_enable ( clt -> clt_bev , EV_READ | EV_WRITE ) ;   if ( clt -> clt_persist )  clt -> clt_toread = TOREAD_HTTP_HEADER ; else clt -> clt_toread = TOREAD_HTTP_NONE ; clt -> clt_done = 0 ; done : evbuffer_free ( evb ) ; server_reset_http ( clt ) ; return ( 0 ) ; fail : bufferevent_disable ( clt -> clt_bev , EV_READ | EV_WRITE ) ; bufferevent_free ( clt -> clt_bev ) ; clt -> clt_bev = NULL ; abort :  if ( evb != NULL )  evbuffer_free ( evb ) ; if ( fd != - 1 ) close ( fd ) ; if ( errstr == NULL ) errstr = strerror ( errno ) ; server_abort_http ( clt , code , errstr ) ; return ( - 1 ) ; }","struct range_data * r = & clt -> clt_ranges ;struct range * range ;size_t content_length = 0 ;int code = 500 , fd = - 1 , i , nranges , ret ;if ( ( nranges = parse_ranges ( clt , range_str , st -> st_size ) ) < 1 ) {code = 416 ;r -> range_media = media ;range = & r -> range [ 0 ] ;( void ) snprintf ( content_range , sizeof ( content_range ) , ""bytes<S2SV_blank>%lld-%lld/%lld"" , range -> start , range -> end , st -> st_size ) ;range = & r -> range [ 0 ] ;content_length += range -> end - range -> start + 1 ;content_length = 0 ;boundary = arc4random ( ) ;content_length += ret + range -> end , st -> st_size ) ) == - 1 ) goto abort ;range ++ ;}if ( ( ret = snprintf ( NULL , 0 , ""\\\\r\\\content_length += ret ;( void ) strlcpy ( multipart_media . media_type , ""multipart"" , sizeof ( multipart_media . media_type ) ) ;( void ) snprintf ( multipart_media . media_subtype , sizeof ( multipart_media . media_subtype ) , ""byteranges;<S2SV_blank>boundary=%llu"" , clt -> clt_boundary ) ;media = & multipart_media ;r -> range_toread = TOREAD_HTTP_RANGE ;case 0 : close ( fd ) ;goto done ;default : break ;}clt -> clt_fd = fd ;if ( clt -> clt_srvbev != NULL ) bufferevent_free ( clt -> clt_srvbev ) ;clt -> clt_srvbev_throttled = 0 ;clt -> clt_srvbev = bufferevent_new ( clt -> clt_fd , server_read_httprange , server_write , server_file_error , clt ) ;if ( clt -> clt_srvbev == NULL ) {errstr = ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>file<S2SV_blank>buffer<S2SV_blank>event"" ;goto fail ;bufferevent_setwatermark ( clt -> clt_srvbev , EV_READ , 0 , clt -> clt_sndbufsiz ) ;bufferevent_settimeout ( clt -> clt_srvbev , srv_conf -> timeout . tv_sec , srv_conf -> timeout . tv_sec ) ;bufferevent_enable ( clt -> clt_srvbev , EV_READ ) ;bufferevent_disable ( clt -> clt_bev , EV_READ ) ;done : server_reset_http ( clt ) ;abort : if ( evb != NULL ) evbuffer_free ( evb ) ;",526
715,"buggy line: ier = ksz8851ReadReg ( interface , KSZ8851_REG_IER ) ;ksz8851WriteReg ( interface , KSZ8851_REG_IER , 0 ) ;isr = ksz8851ReadReg ( interface , KSZ8851_REG_ISR ) ;if ( ( isr & ISR_LCIS ) != 0 ) {ier &= ~ IER_LCIE ;interface -> nicEvent = TRUE ;if ( ( isr & ISR_TXIS ) != 0 )  {ksz8851WriteReg ( interface , KSZ8851_REG_ISR , ISR_TXIS ) ;n = ksz8851ReadReg ( interface , KSZ8851_REG_TXMIR ) & TXMIR_TXMA_MASK ;if ( n >= ( ETH_MAX_FRAME_SIZE + 8 ) ) {if ( ( isr & ISR_RXIS ) != 0 )  {ier &= ~ IER_RXIE ;interface -> nicEvent = TRUE ;ksz8851WriteReg ( interface , KSZ8851_REG_IER , ier ) ;return flag ;cwe id:CWE-20context: bool_t ksz8851IrqHandler ( NetInterface * interface ) { bool_t flag ; size_t n ; uint16_t ier ; uint16_t isr ; flag = FALSE ;  ier = ksz8851ReadReg ( interface , KSZ8851_REG_IER ) ;   ksz8851WriteReg ( interface , KSZ8851_REG_IER , 0 ) ;   isr = ksz8851ReadReg ( interface , KSZ8851_REG_ISR ) ;  if ( ( isr & ISR_LCIS ) != 0 ) {  ier &= ~ IER_LCIE ;  interface -> nicEvent = TRUE ; flag |= osSetEventFromIsr ( & netEvent ) ; }  if ( ( isr & ISR_TXIS ) != 0 )  {  ksz8851WriteReg ( interface , KSZ8851_REG_ISR , ISR_TXIS ) ;   n = ksz8851ReadReg ( interface , KSZ8851_REG_TXMIR ) & TXMIR_TXMA_MASK ;  if ( n >= ( ETH_MAX_FRAME_SIZE + 8 ) ) { flag |= osSetEventFromIsr ( & interface -> nicTxEvent ) ; } }  if ( ( isr & ISR_RXIS ) != 0 )  {  ier &= ~ IER_RXIE ;  interface -> nicEvent = TRUE ; flag |= osSetEventFromIsr ( & netEvent ) ; }  ksz8851WriteReg ( interface , KSZ8851_REG_IER , ier ) ;  return flag ; }","ier = ksz8851ReadReg ( interface , KSZ8851_IER ) ;ksz8851WriteReg ( interface , KSZ8851_IER , 0 ) ;isr = ksz8851ReadReg ( interface , KSZ8851_ISR ) ;if ( ( isr & KSZ8851_ISR_LCIS ) != 0 ) {ier &= ~ KSZ8851_IER_LCIE ;interface -> nicEvent = TRUE ;if ( ( isr & KSZ8851_ISR_TXIS ) != 0 ) {ksz8851WriteReg ( interface , KSZ8851_ISR , KSZ8851_ISR_TXIS ) ;n = ksz8851ReadReg ( interface , KSZ8851_TXMIR ) & KSZ8851_TXMIR_TXMA ;if ( n >= ( ETH_MAX_FRAME_SIZE + 8 ) ) {if ( ( isr & KSZ8851_ISR_RXIS ) != 0 ) {ier &= ~ KSZ8851_IER_RXIE ;interface -> nicEvent = TRUE ;ksz8851WriteReg ( interface , KSZ8851_IER , ier ) ;return flag ;",527
716,"buggy line: static void encode_quantization ( VP9_COMMON * cm ,   struct vp9_write_bit_buffer * wb ) {vp9_wb_write_literal ( wb , cm -> base_qindex , QINDEX_BITS ) ;write_delta_q ( wb , cm -> y_dc_delta_q ) ;cwe id:CWE-119context:  static void encode_quantization ( VP9_COMMON * cm ,   struct vp9_write_bit_buffer * wb ) {   vp9_wb_write_literal ( wb , cm -> base_qindex , QINDEX_BITS ) ;  write_delta_q ( wb , cm -> y_dc_delta_q ) ; write_delta_q ( wb , cm -> uv_dc_delta_q ) ; write_delta_q ( wb , cm -> uv_ac_delta_q ) ; }","static void encode_quantization ( const VP9_COMMON * const cm , struct vp9_write_bit_buffer * wb ) {vpx_wb_write_literal ( wb , cm -> base_qindex , QINDEX_BITS ) ;write_delta_q ( wb , cm -> y_dc_delta_q ) ;",528
717,"buggy line: }else if ( encoding == 1 && ( c -> bpp == 6 || c -> bpp == 8 ) ) {if ( c -> palette_size != ( 1 << ( c -> bpp - 1 ) ) ) return AVERROR_INVALIDDATA ;cwe id:CWE-119context: static int cdxl_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * pkt ) { CDXLVideoContext * c = avctx -> priv_data ; AVFrame * const p = data ; int ret , w , h , encoding , aligned_width , buf_size = pkt -> size ; const uint8_t * buf = pkt -> data ; if ( buf_size < 32 ) return AVERROR_INVALIDDATA ; encoding = buf [ 1 ] & 7 ; c -> format = buf [ 1 ] & 0xE0 ; w = AV_RB16 ( & buf [ 14 ] ) ; h = AV_RB16 ( & buf [ 16 ] ) ; c -> bpp = buf [ 19 ] ; c -> palette_size = AV_RB16 ( & buf [ 20 ] ) ; c -> palette = buf + 32 ; c -> video = c -> palette + c -> palette_size ; c -> video_size = buf_size - c -> palette_size - 32 ; if ( c -> palette_size > 512 ) return AVERROR_INVALIDDATA ; if ( buf_size < c -> palette_size + 32 ) return AVERROR_INVALIDDATA ; if ( c -> bpp < 1 ) return AVERROR_INVALIDDATA ; if ( c -> format != BIT_PLANAR && c -> format != BIT_LINE && c -> format != CHUNKY ) { avpriv_request_sample ( avctx , ""Pixel<S2SV_blank>format<S2SV_blank>0x%0x"" , c -> format ) ; return AVERROR_PATCHWELCOME ; } if ( ( ret = ff_set_dimensions ( avctx , w , h ) ) < 0 ) return ret ; if ( c -> format == CHUNKY ) aligned_width = avctx -> width ; else aligned_width = FFALIGN ( c -> avctx -> width , 16 ) ; c -> padded_bits = aligned_width - c -> avctx -> width ; if ( c -> video_size < aligned_width * avctx -> height * ( int64_t ) c -> bpp / 8 ) return AVERROR_INVALIDDATA ; if ( ! encoding && c -> palette_size && c -> bpp <= 8 && c -> format != CHUNKY ) { avctx -> pix_fmt = AV_PIX_FMT_PAL8 ;  } else if ( encoding == 1 && ( c -> bpp == 6 || c -> bpp == 8 ) ) {  if ( c -> palette_size != ( 1 << ( c -> bpp - 1 ) ) ) return AVERROR_INVALIDDATA ; avctx -> pix_fmt = AV_PIX_FMT_BGR24 ; } else if ( ! encoding && c -> bpp == 24 && c -> format == CHUNKY && ! c -> palette_size ) { avctx -> pix_fmt = AV_PIX_FMT_RGB24 ; } else { avpriv_request_sample ( avctx , ""Encoding<S2SV_blank>%d,<S2SV_blank>bpp<S2SV_blank>%d<S2SV_blank>and<S2SV_blank>format<S2SV_blank>0x%x"" , encoding , c -> bpp , c -> format ) ; return AVERROR_PATCHWELCOME ; } if ( ( ret = ff_get_buffer ( avctx , p , 0 ) ) < 0 ) return ret ; p -> pict_type = AV_PICTURE_TYPE_I ; if ( encoding ) { av_fast_padded_malloc ( & c -> new_video , & c -> new_video_size , h * w + AV_INPUT_BUFFER_PADDING_SIZE ) ; if ( ! c -> new_video ) return AVERROR ( ENOMEM ) ; if ( c -> bpp == 8 ) cdxl_decode_ham8 ( c , p ) ; else cdxl_decode_ham6 ( c , p ) ; } else if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 ) { cdxl_decode_rgb ( c , p ) ; } else { cdxl_decode_raw ( c , p ) ; } * got_frame = 1 ; return buf_size ; }",}else if ( encoding == 1 && ( c -> bpp == 6 || c -> bpp == 8 ) && c -> format != CHUNKY ) {if ( c -> palette_size != ( 1 << ( c -> bpp - 1 ) ) ) return AVERROR_INVALIDDATA ;,529
718,"buggy line: if ( write ( uipc_main . ch [ ch_id ] . fd , p_buf , msglen ) < 0 )  {cwe id:CWE-284context: BOOLEAN UIPC_Send ( tUIPC_CH_ID ch_id , UINT16 msg_evt , UINT8 * p_buf , UINT16 msglen ) { UNUSED ( msg_evt ) ; BTIF_TRACE_DEBUG ( ""UIPC_Send<S2SV_blank>:<S2SV_blank>ch_id:%d<S2SV_blank>%d<S2SV_blank>bytes"" , ch_id , msglen ) ; UIPC_LOCK ( ) ;  if ( write ( uipc_main . ch [ ch_id ] . fd , p_buf , msglen ) < 0 )  { BTIF_TRACE_ERROR ( ""failed<S2SV_blank>to<S2SV_blank>write<S2SV_blank>(%s)"" , strerror ( errno ) ) ; } UIPC_UNLOCK ( ) ; return FALSE ; }","if ( TEMP_FAILURE_RETRY ( write ( uipc_main . ch [ ch_id ] . fd , p_buf , msglen ) ) < 0 ) {",530
719,"buggy line: return tmp ;}return tmp ;}return state -> ptr = tmp ;}cwe id:CWE-119context: static const char * parse_scheme ( struct parse_state * state ) { size_t mb ; const char * tmp = state -> ptr ; do { switch ( * state -> ptr ) { case ':' : state -> url . scheme = & state -> buffer [ 0 ] ; state -> buffer [ state -> offset ++ ] = 0 ; return ++ state -> ptr ; case '0' : case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : case '8' : case '9' : case '+' : case '-' : case '.' : if ( state -> ptr == tmp ) {  return tmp ;  } case 'A' : case 'B' : case 'C' : case 'D' : case 'E' : case 'F' : case 'G' : case 'H' : case 'I' : case 'J' : case 'K' : case 'L' : case 'M' : case 'N' : case 'O' : case 'P' : case 'Q' : case 'R' : case 'S' : case 'T' : case 'U' : case 'V' : case 'W' : case 'X' : case 'Y' : case 'Z' : case 'a' : case 'b' : case 'c' : case 'd' : case 'e' : case 'f' : case 'g' : case 'h' : case 'i' : case 'j' : case 'k' : case 'l' : case 'm' : case 'n' : case 'o' : case 'p' : case 'q' : case 'r' : case 's' : case 't' : case 'u' : case 'v' : case 'w' : case 'x' : case 'y' : case 'z' : state -> buffer [ state -> offset ++ ] = * state -> ptr ; break ; default : if ( ! ( mb = parse_mb ( state , PARSE_SCHEME , state -> ptr , state -> end , tmp , 1 ) ) ) {  return tmp ;  } state -> ptr += mb - 1 ; } } while ( ++ state -> ptr != state -> end ) ;  return state -> ptr = tmp ;  }",goto softfail ;}goto softfail ;}softfail : state -> offset = 0 ;return state -> ptr = tmp ;},531
720,"buggy line: struct fb_vblank vblank ;vblank . flags = FB_VBLANK_HAVE_COUNT | FB_VBLANK_HAVE_VCOUNT | FB_VBLANK_HAVE_VSYNC ;cwe id:CWE-200context: static int vivid_fb_ioctl ( struct fb_info * info , unsigned cmd , unsigned long arg ) { struct vivid_dev * dev = ( struct vivid_dev * ) info -> par ; switch ( cmd ) { case FBIOGET_VBLANK : {  struct fb_vblank vblank ;  vblank . flags = FB_VBLANK_HAVE_COUNT | FB_VBLANK_HAVE_VCOUNT | FB_VBLANK_HAVE_VSYNC ; vblank . count = 0 ; vblank . vcount = 0 ; vblank . hcount = 0 ; if ( copy_to_user ( ( void __user * ) arg , & vblank , sizeof ( vblank ) ) ) return - EFAULT ; return 0 ; } default : dprintk ( dev , 1 , ""Unknown<S2SV_blank>ioctl<S2SV_blank>%08x\\n"" , cmd ) ; return - EINVAL ; } return 0 ; }","struct fb_vblank vblank ;memset ( & vblank , 0 , sizeof ( vblank ) ) ;vblank . flags = FB_VBLANK_HAVE_COUNT | FB_VBLANK_HAVE_VCOUNT | FB_VBLANK_HAVE_VSYNC ;",532
721,"buggy line: static void timerfd_setup_cancel ( struct timerfd_ctx * ctx , int flags )  {if ( ( ctx -> clockid == CLOCK_REALTIME || ctx -> clockid == CLOCK_REALTIME_ALARM ) && ( flags & TFD_TIMER_ABSTIME ) && ( flags & TFD_TIMER_CANCEL_ON_SET ) ) {}else if ( ctx -> might_cancel ) {timerfd_remove_cancel ( ctx ) ;}cwe id:CWE-416context: static void timerfd_setup_cancel ( struct timerfd_ctx * ctx , int flags )  {  if ( ( ctx -> clockid == CLOCK_REALTIME || ctx -> clockid == CLOCK_REALTIME_ALARM ) && ( flags & TFD_TIMER_ABSTIME ) && ( flags & TFD_TIMER_CANCEL_ON_SET ) ) { if ( ! ctx -> might_cancel ) { ctx -> might_cancel = true ; spin_lock ( & cancel_lock ) ; list_add_rcu ( & ctx -> clist , & cancel_list ) ; spin_unlock ( & cancel_lock ) ; }  } else if ( ctx -> might_cancel ) {  timerfd_remove_cancel ( ctx ) ; }  } ","static void timerfd_setup_cancel ( struct timerfd_ctx * ctx , int flags ) {spin_lock ( & ctx -> cancel_lock ) ;if ( ( ctx -> clockid == CLOCK_REALTIME || ctx -> clockid == CLOCK_REALTIME_ALARM ) && ( flags & TFD_TIMER_ABSTIME ) && ( flags & TFD_TIMER_CANCEL_ON_SET ) ) {else {__timerfd_remove_cancel ( ctx ) ;}spin_unlock ( & ctx -> cancel_lock ) ;}",533
722,"buggy line: cwe id:CWE-000context: static Curves16Data * CurvesAlloc ( cmsContext ContextID , int nCurves , int nElements , cmsToneCurve * * G ) { int i , j ; Curves16Data * c16 ; c16 = _cmsMallocZero ( ContextID , sizeof ( Curves16Data ) ) ; if ( c16 == NULL ) return NULL ; c16 -> nCurves = nCurves ; c16 -> nElements = nElements ; c16 -> Curves = _cmsCalloc ( ContextID , nCurves , sizeof ( cmsUInt16Number * ) ) ; if ( c16 -> Curves == NULL ) return NULL ; for ( i = 0 ; i < nCurves ; i ++ ) {  c16 -> Curves [ i ] = _cmsCalloc ( ContextID , nElements , sizeof ( cmsUInt16Number ) ) ;  if ( nElements == 256 ) { for ( j = 0 ; j < nElements ; j ++ ) { c16 -> Curves [ i ] [ j ] = cmsEvalToneCurve16 ( G [ i ] , FROM_8_TO_16 ( j ) ) ; } } else { for ( j = 0 ; j < nElements ; j ++ ) { c16 -> Curves [ i ] [ j ] = cmsEvalToneCurve16 ( G [ i ] , ( cmsUInt16Number ) j ) ; } } } return c16 ; }","if ( c16 -> Curves [ i ] == NULL ) {for ( j = 0 ;j < i ;j ++ ) {_cmsFree ( ContextID , c16 -> Curves [ j ] ) ;}_cmsFree ( ContextID , c16 -> Curves ) ;_cmsFree ( ContextID , c16 ) ;return NULL ;}",534
723,"buggy line: c16 -> Curves [ i ] = _cmsCalloc ( ContextID , nElements , sizeof ( cmsUInt16Number ) ) ;if ( nElements == 256 ) {cwe id:CWE-000context: static Curves16Data * CurvesAlloc ( cmsContext ContextID , int nCurves , int nElements , cmsToneCurve * * G ) { int i , j ; Curves16Data * c16 ; c16 = _cmsMallocZero ( ContextID , sizeof ( Curves16Data ) ) ; if ( c16 == NULL ) return NULL ; c16 -> nCurves = nCurves ; c16 -> nElements = nElements ; c16 -> Curves = _cmsCalloc ( ContextID , nCurves , sizeof ( cmsUInt16Number * ) ) ; if ( c16 -> Curves == NULL ) return NULL ; for ( i = 0 ; i < nCurves ; i ++ ) {  c16 -> Curves [ i ] = _cmsCalloc ( ContextID , nElements , sizeof ( cmsUInt16Number ) ) ;  if ( nElements == 256 ) { for ( j = 0 ; j < nElements ; j ++ ) { c16 -> Curves [ i ] [ j ] = cmsEvalToneCurve16 ( G [ i ] , FROM_8_TO_16 ( j ) ) ; } } else { for ( j = 0 ; j < nElements ; j ++ ) { c16 -> Curves [ i ] [ j ] = cmsEvalToneCurve16 ( G [ i ] , ( cmsUInt16Number ) j ) ; } } } return c16 ; }","c16 -> Curves [ i ] = _cmsCalloc ( ContextID , nElements , sizeof ( cmsUInt16Number ) ) ;if ( nElements == 256 ) {",534
724,"buggy line: if ( kern_path ( dev_name , LOOKUP_FOLLOW , & path ) ) {error = - ENOENT ;cwe id:CWE-20context: static int tomoyo_mount_acl ( struct tomoyo_request_info * r , char * dev_name , struct path * dir , char * type , unsigned long flags ) { struct path path ; struct file_system_type * fstype = NULL ; const char * requested_type = NULL ; const char * requested_dir_name = NULL ; const char * requested_dev_name = NULL ; struct tomoyo_path_info rtype ; struct tomoyo_path_info rdev ; struct tomoyo_path_info rdir ; int need_dev = 0 ; int error = - ENOMEM ; requested_type = tomoyo_encode ( type ) ; if ( ! requested_type ) goto out ; rtype . name = requested_type ; tomoyo_fill_path_info ( & rtype ) ; requested_dir_name = tomoyo_realpath_from_path ( dir ) ; if ( ! requested_dir_name ) { error = - ENOMEM ; goto out ; } rdir . name = requested_dir_name ; tomoyo_fill_path_info ( & rdir ) ; if ( ! strcmp ( type , TOMOYO_MOUNT_REMOUNT_KEYWORD ) ) { } else if ( ! strcmp ( type , TOMOYO_MOUNT_MAKE_UNBINDABLE_KEYWORD ) || ! strcmp ( type , TOMOYO_MOUNT_MAKE_PRIVATE_KEYWORD ) || ! strcmp ( type , TOMOYO_MOUNT_MAKE_SLAVE_KEYWORD ) || ! strcmp ( type , TOMOYO_MOUNT_MAKE_SHARED_KEYWORD ) ) { } else if ( ! strcmp ( type , TOMOYO_MOUNT_BIND_KEYWORD ) || ! strcmp ( type , TOMOYO_MOUNT_MOVE_KEYWORD ) ) { need_dev = - 1 ; } else { fstype = get_fs_type ( type ) ; if ( ! fstype ) { error = - ENODEV ; goto out ; } if ( fstype -> fs_flags & FS_REQUIRES_DEV ) need_dev = 1 ; } if ( need_dev ) {  if ( kern_path ( dev_name , LOOKUP_FOLLOW , & path ) ) {  error = - ENOENT ; goto out ; } requested_dev_name = tomoyo_realpath_from_path ( & path ) ; path_put ( & path ) ; if ( ! requested_dev_name ) { error = - ENOENT ; goto out ; } } else { if ( ! dev_name ) dev_name = ""<NULL>"" ; requested_dev_name = tomoyo_encode ( dev_name ) ; if ( ! requested_dev_name ) { error = - ENOMEM ; goto out ; } } rdev . name = requested_dev_name ; tomoyo_fill_path_info ( & rdev ) ; r -> param_type = TOMOYO_TYPE_MOUNT_ACL ; r -> param . mount . need_dev = need_dev ; r -> param . mount . dev = & rdev ; r -> param . mount . dir = & rdir ; r -> param . mount . type = & rtype ; r -> param . mount . flags = flags ; do { tomoyo_check_acl ( r , tomoyo_check_mount_acl ) ; error = tomoyo_audit_mount_log ( r ) ; } while ( error == TOMOYO_RETRY_REQUEST ) ; out : kfree ( requested_dev_name ) ; kfree ( requested_dir_name ) ; if ( fstype ) put_filesystem ( fstype ) ; kfree ( requested_type ) ; return error ; }","if ( ! dev_name || kern_path ( dev_name , LOOKUP_FOLLOW , & path ) ) {error = - ENOENT ;",535
725,"buggy line: isoclns_print ( ndo , p + 1 , length - 1 , caplen - 1 ) ;return ( 1 ) ;cwe id:CWE-125context: int ethertype_print ( netdissect_options * ndo , u_short ether_type , const u_char * p , u_int length , u_int caplen , const struct lladdr_info * src , const struct lladdr_info * dst ) { switch ( ether_type ) { case ETHERTYPE_IP : ip_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_IPV6 : ip6_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_ARP : case ETHERTYPE_REVARP : arp_print ( ndo , p , length , caplen ) ; return ( 1 ) ; case ETHERTYPE_DN : decnet_print ( ndo , p , length , caplen ) ; return ( 1 ) ; case ETHERTYPE_ATALK : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""et1<S2SV_blank>"" ) ) ; atalk_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_AARP : aarp_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_IPX : ND_PRINT ( ( ndo , ""(NOV-ETHII)<S2SV_blank>"" ) ) ; ipx_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_ISO : if ( length == 0 || caplen == 0 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[|osi]"" ) ) ; return ( 1 ) ; }  isoclns_print ( ndo , p + 1 , length - 1 , caplen - 1 ) ;  return ( 1 ) ; case ETHERTYPE_PPPOED : case ETHERTYPE_PPPOES : case ETHERTYPE_PPPOED2 : case ETHERTYPE_PPPOES2 : pppoe_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_EAPOL : eap_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_RRCP : rrcp_print ( ndo , p , length , src , dst ) ; return ( 1 ) ; case ETHERTYPE_PPP : if ( length ) { ND_PRINT ( ( ndo , "":<S2SV_blank>"" ) ) ; ppp_print ( ndo , p , length ) ; } return ( 1 ) ; case ETHERTYPE_MPCP : mpcp_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_SLOW : slow_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_CFM : case ETHERTYPE_CFM_OLD : cfm_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_LLDP : lldp_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_NSH : nsh_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_LOOPBACK : loopback_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_MPLS : case ETHERTYPE_MPLS_MULTI : mpls_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_TIPC : tipc_print ( ndo , p , length , caplen ) ; return ( 1 ) ; case ETHERTYPE_MS_NLB_HB : msnlb_print ( ndo , p ) ; return ( 1 ) ; case ETHERTYPE_GEONET_OLD : case ETHERTYPE_GEONET : geonet_print ( ndo , p , length , src ) ; return ( 1 ) ; case ETHERTYPE_CALM_FAST : calm_fast_print ( ndo , p , length , src ) ; return ( 1 ) ; case ETHERTYPE_AOE : aoe_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_MEDSA : medsa_print ( ndo , p , length , caplen , src , dst ) ; return ( 1 ) ; case ETHERTYPE_LAT : case ETHERTYPE_SCA : case ETHERTYPE_MOPRC : case ETHERTYPE_MOPDL : case ETHERTYPE_IEEE1905_1 : default : return ( 0 ) ; } }","isoclns_print ( ndo , p + 1 , length - 1 ) ;return ( 1 ) ;",536
726,"buggy line: struct tmComResBusInfo * bus = & dev -> bus ;u32 bytes_to_read , write_distance , curr_grp , curr_gwp , new_grp , buf_size , space_rem ;struct tmComResInfo msg_tmp ;int ret = SAA_ERR_BAD_PARAMETER ;saa7164_bus_verify ( dev ) ;if ( msg == NULL ) return ret ;if ( msg -> size > dev -> bus . m_wMaxReqSize ) {printk ( KERN_ERR ""%s()<S2SV_blank>Exceeded<S2SV_blank>dev->bus.m_wMaxReqSize\\\return ret ;}if ( ( peekonly == 0 ) && ( msg -> size > 0 ) && ( buf == NULL ) ) {printk ( KERN_ERR ""%s()<S2SV_blank>Missing<S2SV_blank>msg<S2SV_blank>buf,<S2SV_blank>size<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%d<S2SV_blank>bytes\\\return ret ;}mutex_lock ( & bus -> lock ) ;curr_gwp = saa7164_readl ( bus -> m_dwGetWritePos ) ;curr_grp = saa7164_readl ( bus -> m_dwGetReadPos ) ;if ( curr_gwp == curr_grp ) {ret = SAA_ERR_EMPTY ;goto out ;}bytes_to_read = sizeof ( * msg ) ;write_distance = 0 ;if ( curr_gwp >= curr_grp ) write_distance = curr_gwp - curr_grp ;else write_distance = curr_gwp + bus -> m_dwSizeGetRing - curr_grp ;if ( bytes_to_read > write_distance ) {printk ( KERN_ERR ""%s()<S2SV_blank>No<S2SV_blank>message/response<S2SV_blank>found\\\ret = SAA_ERR_INVALID_COMMAND ;goto out ;}new_grp = curr_grp + bytes_to_read ;if ( new_grp > bus -> m_dwSizeGetRing ) {new_grp -= bus -> m_dwSizeGetRing ;space_rem = bus -> m_dwSizeGetRing - curr_grp ;memcpy_fromio ( & msg_tmp , bus -> m_pdwGetRing + curr_grp , space_rem ) ;memcpy_fromio ( ( u8 * ) & msg_tmp + space_rem , bus -> m_pdwGetRing , bytes_to_read - space_rem ) ;}else {memcpy_fromio ( & msg_tmp , bus -> m_pdwGetRing + curr_grp , bytes_to_read ) ;}msg_tmp . size = le16_to_cpu ( ( __force __le16 ) msg_tmp . size ) ;msg_tmp . command = le32_to_cpu ( ( __force __le32 ) msg_tmp . command ) ;msg_tmp . controlselector = le16_to_cpu ( ( __force __le16 ) msg_tmp . controlselector ) ;if ( peekonly ) {memcpy ( msg , & msg_tmp , sizeof ( * msg ) ) ;goto peekout ;cwe id:CWE-125context: int saa7164_bus_get ( struct saa7164_dev * dev , struct tmComResInfo * msg , void * buf , int peekonly ) { struct tmComResBusInfo * bus = & dev -> bus ; u32 bytes_to_read , write_distance , curr_grp , curr_gwp , new_grp , buf_size , space_rem ; struct tmComResInfo msg_tmp ; int ret = SAA_ERR_BAD_PARAMETER ; saa7164_bus_verify ( dev ) ; if ( msg == NULL ) return ret ; if ( msg -> size > dev -> bus . m_wMaxReqSize ) { printk ( KERN_ERR ""%s()<S2SV_blank>Exceeded<S2SV_blank>dev->bus.m_wMaxReqSize\\n"" , __func__ ) ; return ret ; } if ( ( peekonly == 0 ) && ( msg -> size > 0 ) && ( buf == NULL ) ) { printk ( KERN_ERR ""%s()<S2SV_blank>Missing<S2SV_blank>msg<S2SV_blank>buf,<S2SV_blank>size<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%d<S2SV_blank>bytes\\n"" , __func__ , msg -> size ) ; return ret ; } mutex_lock ( & bus -> lock ) ; curr_gwp = saa7164_readl ( bus -> m_dwGetWritePos ) ; curr_grp = saa7164_readl ( bus -> m_dwGetReadPos ) ; if ( curr_gwp == curr_grp ) { ret = SAA_ERR_EMPTY ; goto out ; } bytes_to_read = sizeof ( * msg ) ; write_distance = 0 ; if ( curr_gwp >= curr_grp ) write_distance = curr_gwp - curr_grp ; else write_distance = curr_gwp + bus -> m_dwSizeGetRing - curr_grp ; if ( bytes_to_read > write_distance ) { printk ( KERN_ERR ""%s()<S2SV_blank>No<S2SV_blank>message/response<S2SV_blank>found\\n"" , __func__ ) ; ret = SAA_ERR_INVALID_COMMAND ; goto out ; } new_grp = curr_grp + bytes_to_read ; if ( new_grp > bus -> m_dwSizeGetRing ) { new_grp -= bus -> m_dwSizeGetRing ; space_rem = bus -> m_dwSizeGetRing - curr_grp ; memcpy_fromio ( & msg_tmp , bus -> m_pdwGetRing + curr_grp , space_rem ) ; memcpy_fromio ( ( u8 * ) & msg_tmp + space_rem , bus -> m_pdwGetRing , bytes_to_read - space_rem ) ; } else { memcpy_fromio ( & msg_tmp , bus -> m_pdwGetRing + curr_grp , bytes_to_read ) ; } msg_tmp . size = le16_to_cpu ( ( __force __le16 ) msg_tmp . size ) ; msg_tmp . command = le32_to_cpu ( ( __force __le32 ) msg_tmp . command ) ; msg_tmp . controlselector = le16_to_cpu ( ( __force __le16 ) msg_tmp . controlselector ) ;  if ( peekonly ) {   memcpy ( msg , & msg_tmp , sizeof ( * msg ) ) ;  goto peekout ; } if ( ( msg_tmp . id != msg -> id ) || ( msg_tmp . command != msg -> command ) || ( msg_tmp . controlselector != msg -> controlselector ) || ( msg_tmp . seqno != msg -> seqno ) || ( msg_tmp . size != msg -> size ) ) { printk ( KERN_ERR ""%s()<S2SV_blank>Unexpected<S2SV_blank>msg<S2SV_blank>miss-match\\n"" , __func__ ) ; saa7164_bus_dumpmsg ( dev , msg , buf ) ; saa7164_bus_dumpmsg ( dev , & msg_tmp , NULL ) ; ret = SAA_ERR_INVALID_COMMAND ; goto out ; } buf_size = msg -> size ; bytes_to_read = sizeof ( * msg ) + msg -> size ; write_distance = 0 ; if ( curr_gwp >= curr_grp ) write_distance = curr_gwp - curr_grp ; else write_distance = curr_gwp + bus -> m_dwSizeGetRing - curr_grp ; if ( bytes_to_read > write_distance ) { printk ( KERN_ERR ""%s()<S2SV_blank>Invalid<S2SV_blank>bus<S2SV_blank>state,<S2SV_blank>missing<S2SV_blank>msg<S2SV_blank>or<S2SV_blank>mangled<S2SV_blank>ring,<S2SV_blank>faulty<S2SV_blank>H/W<S2SV_blank>/<S2SV_blank>bad<S2SV_blank>code?\\n"" , __func__ ) ; ret = SAA_ERR_INVALID_COMMAND ; goto out ; } new_grp = curr_grp + bytes_to_read ; if ( new_grp > bus -> m_dwSizeGetRing ) { new_grp -= bus -> m_dwSizeGetRing ; space_rem = bus -> m_dwSizeGetRing - curr_grp ; if ( space_rem < sizeof ( * msg ) ) {  memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , space_rem ) ;  memcpy_fromio ( ( u8 * ) msg + space_rem , bus -> m_pdwGetRing ,  sizeof ( * msg ) - space_rem ) ;  if ( buf )  memcpy_fromio ( buf , bus -> m_pdwGetRing + sizeof ( * msg ) -  space_rem , buf_size ) ;  } else if ( space_rem == sizeof ( * msg ) ) {  memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , sizeof ( * msg ) ) ; if ( buf ) memcpy_fromio ( buf , bus -> m_pdwGetRing , buf_size ) ; } else { memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , sizeof ( * msg ) ) ; if ( buf ) { memcpy_fromio ( buf , bus -> m_pdwGetRing + curr_grp + sizeof ( * msg ) , space_rem - sizeof ( * msg ) ) ; memcpy_fromio ( buf + space_rem - sizeof ( * msg ) , bus -> m_pdwGetRing , bytes_to_read - space_rem ) ; } } } else { memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , sizeof ( * msg ) ) ; if ( buf ) memcpy_fromio ( buf , bus -> m_pdwGetRing + curr_grp + sizeof ( * msg ) , buf_size ) ; } msg -> size = le16_to_cpu ( ( __force __le16 ) msg -> size ) ; msg -> command = le32_to_cpu ( ( __force __le32 ) msg -> command ) ; msg -> controlselector = le16_to_cpu ( ( __force __le16 ) msg -> controlselector ) ; saa7164_writel ( bus -> m_dwGetReadPos , new_grp ) ; peekout : ret = SAA_OK ; out : mutex_unlock ( & bus -> lock ) ; saa7164_bus_verify ( dev ) ; return ret ; }",goto peekout ;,537
727,"buggy line: memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , space_rem ) ;memcpy_fromio ( ( u8 * ) msg + space_rem , bus -> m_pdwGetRing ,  sizeof ( * msg ) - space_rem ) ;if ( buf )  memcpy_fromio ( buf , bus -> m_pdwGetRing + sizeof ( * msg ) -  space_rem , buf_size ) ;}memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , sizeof ( * msg ) ) ;cwe id:CWE-125context: int saa7164_bus_get ( struct saa7164_dev * dev , struct tmComResInfo * msg , void * buf , int peekonly ) { struct tmComResBusInfo * bus = & dev -> bus ; u32 bytes_to_read , write_distance , curr_grp , curr_gwp , new_grp , buf_size , space_rem ; struct tmComResInfo msg_tmp ; int ret = SAA_ERR_BAD_PARAMETER ; saa7164_bus_verify ( dev ) ; if ( msg == NULL ) return ret ; if ( msg -> size > dev -> bus . m_wMaxReqSize ) { printk ( KERN_ERR ""%s()<S2SV_blank>Exceeded<S2SV_blank>dev->bus.m_wMaxReqSize\\n"" , __func__ ) ; return ret ; } if ( ( peekonly == 0 ) && ( msg -> size > 0 ) && ( buf == NULL ) ) { printk ( KERN_ERR ""%s()<S2SV_blank>Missing<S2SV_blank>msg<S2SV_blank>buf,<S2SV_blank>size<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%d<S2SV_blank>bytes\\n"" , __func__ , msg -> size ) ; return ret ; } mutex_lock ( & bus -> lock ) ; curr_gwp = saa7164_readl ( bus -> m_dwGetWritePos ) ; curr_grp = saa7164_readl ( bus -> m_dwGetReadPos ) ; if ( curr_gwp == curr_grp ) { ret = SAA_ERR_EMPTY ; goto out ; } bytes_to_read = sizeof ( * msg ) ; write_distance = 0 ; if ( curr_gwp >= curr_grp ) write_distance = curr_gwp - curr_grp ; else write_distance = curr_gwp + bus -> m_dwSizeGetRing - curr_grp ; if ( bytes_to_read > write_distance ) { printk ( KERN_ERR ""%s()<S2SV_blank>No<S2SV_blank>message/response<S2SV_blank>found\\n"" , __func__ ) ; ret = SAA_ERR_INVALID_COMMAND ; goto out ; } new_grp = curr_grp + bytes_to_read ; if ( new_grp > bus -> m_dwSizeGetRing ) { new_grp -= bus -> m_dwSizeGetRing ; space_rem = bus -> m_dwSizeGetRing - curr_grp ; memcpy_fromio ( & msg_tmp , bus -> m_pdwGetRing + curr_grp , space_rem ) ; memcpy_fromio ( ( u8 * ) & msg_tmp + space_rem , bus -> m_pdwGetRing , bytes_to_read - space_rem ) ; } else { memcpy_fromio ( & msg_tmp , bus -> m_pdwGetRing + curr_grp , bytes_to_read ) ; } msg_tmp . size = le16_to_cpu ( ( __force __le16 ) msg_tmp . size ) ; msg_tmp . command = le32_to_cpu ( ( __force __le32 ) msg_tmp . command ) ; msg_tmp . controlselector = le16_to_cpu ( ( __force __le16 ) msg_tmp . controlselector ) ;  if ( peekonly ) {   memcpy ( msg , & msg_tmp , sizeof ( * msg ) ) ;  goto peekout ; } if ( ( msg_tmp . id != msg -> id ) || ( msg_tmp . command != msg -> command ) || ( msg_tmp . controlselector != msg -> controlselector ) || ( msg_tmp . seqno != msg -> seqno ) || ( msg_tmp . size != msg -> size ) ) { printk ( KERN_ERR ""%s()<S2SV_blank>Unexpected<S2SV_blank>msg<S2SV_blank>miss-match\\n"" , __func__ ) ; saa7164_bus_dumpmsg ( dev , msg , buf ) ; saa7164_bus_dumpmsg ( dev , & msg_tmp , NULL ) ; ret = SAA_ERR_INVALID_COMMAND ; goto out ; } buf_size = msg -> size ; bytes_to_read = sizeof ( * msg ) + msg -> size ; write_distance = 0 ; if ( curr_gwp >= curr_grp ) write_distance = curr_gwp - curr_grp ; else write_distance = curr_gwp + bus -> m_dwSizeGetRing - curr_grp ; if ( bytes_to_read > write_distance ) { printk ( KERN_ERR ""%s()<S2SV_blank>Invalid<S2SV_blank>bus<S2SV_blank>state,<S2SV_blank>missing<S2SV_blank>msg<S2SV_blank>or<S2SV_blank>mangled<S2SV_blank>ring,<S2SV_blank>faulty<S2SV_blank>H/W<S2SV_blank>/<S2SV_blank>bad<S2SV_blank>code?\\n"" , __func__ ) ; ret = SAA_ERR_INVALID_COMMAND ; goto out ; } new_grp = curr_grp + bytes_to_read ; if ( new_grp > bus -> m_dwSizeGetRing ) { new_grp -= bus -> m_dwSizeGetRing ; space_rem = bus -> m_dwSizeGetRing - curr_grp ; if ( space_rem < sizeof ( * msg ) ) {  memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , space_rem ) ;  memcpy_fromio ( ( u8 * ) msg + space_rem , bus -> m_pdwGetRing ,  sizeof ( * msg ) - space_rem ) ;  if ( buf )  memcpy_fromio ( buf , bus -> m_pdwGetRing + sizeof ( * msg ) -  space_rem , buf_size ) ;  } else if ( space_rem == sizeof ( * msg ) ) {  memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , sizeof ( * msg ) ) ; if ( buf ) memcpy_fromio ( buf , bus -> m_pdwGetRing , buf_size ) ; } else { memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , sizeof ( * msg ) ) ; if ( buf ) { memcpy_fromio ( buf , bus -> m_pdwGetRing + curr_grp + sizeof ( * msg ) , space_rem - sizeof ( * msg ) ) ; memcpy_fromio ( buf + space_rem - sizeof ( * msg ) , bus -> m_pdwGetRing , bytes_to_read - space_rem ) ; } } } else { memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , sizeof ( * msg ) ) ; if ( buf ) memcpy_fromio ( buf , bus -> m_pdwGetRing + curr_grp + sizeof ( * msg ) , buf_size ) ; } msg -> size = le16_to_cpu ( ( __force __le16 ) msg -> size ) ; msg -> command = le32_to_cpu ( ( __force __le32 ) msg -> command ) ; msg -> controlselector = le16_to_cpu ( ( __force __le16 ) msg -> controlselector ) ; saa7164_writel ( bus -> m_dwGetReadPos , new_grp ) ; peekout : ret = SAA_OK ; out : mutex_unlock ( & bus -> lock ) ; saa7164_bus_verify ( dev ) ; return ret ; }","memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , space_rem ) ;memcpy_fromio ( ( u8 * ) msg + space_rem , bus -> m_pdwGetRing , sizeof ( * msg ) - space_rem ) ;if ( buf ) memcpy_fromio ( buf , bus -> m_pdwGetRing + sizeof ( * msg ) - space_rem , buf_size ) ;}memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , sizeof ( * msg ) ) ;",537
728,"buggy line: memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , sizeof ( * msg ) ) ;if ( buf ) memcpy_fromio ( buf , bus -> m_pdwGetRing + curr_grp + sizeof ( * msg ) , buf_size ) ;msg -> size = le16_to_cpu ( ( __force __le16 ) msg -> size ) ;msg -> command = le32_to_cpu ( ( __force __le32 ) msg -> command ) ;msg -> controlselector = le16_to_cpu ( ( __force __le16 ) msg -> controlselector ) ;cwe id:CWE-125context: int saa7164_bus_get ( struct saa7164_dev * dev , struct tmComResInfo * msg , void * buf , int peekonly ) { struct tmComResBusInfo * bus = & dev -> bus ; u32 bytes_to_read , write_distance , curr_grp , curr_gwp , new_grp , buf_size , space_rem ; struct tmComResInfo msg_tmp ; int ret = SAA_ERR_BAD_PARAMETER ; saa7164_bus_verify ( dev ) ; if ( msg == NULL ) return ret ; if ( msg -> size > dev -> bus . m_wMaxReqSize ) { printk ( KERN_ERR ""%s()<S2SV_blank>Exceeded<S2SV_blank>dev->bus.m_wMaxReqSize\\n"" , __func__ ) ; return ret ; } if ( ( peekonly == 0 ) && ( msg -> size > 0 ) && ( buf == NULL ) ) { printk ( KERN_ERR ""%s()<S2SV_blank>Missing<S2SV_blank>msg<S2SV_blank>buf,<S2SV_blank>size<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%d<S2SV_blank>bytes\\n"" , __func__ , msg -> size ) ; return ret ; } mutex_lock ( & bus -> lock ) ; curr_gwp = saa7164_readl ( bus -> m_dwGetWritePos ) ; curr_grp = saa7164_readl ( bus -> m_dwGetReadPos ) ; if ( curr_gwp == curr_grp ) { ret = SAA_ERR_EMPTY ; goto out ; } bytes_to_read = sizeof ( * msg ) ; write_distance = 0 ; if ( curr_gwp >= curr_grp ) write_distance = curr_gwp - curr_grp ; else write_distance = curr_gwp + bus -> m_dwSizeGetRing - curr_grp ; if ( bytes_to_read > write_distance ) { printk ( KERN_ERR ""%s()<S2SV_blank>No<S2SV_blank>message/response<S2SV_blank>found\\n"" , __func__ ) ; ret = SAA_ERR_INVALID_COMMAND ; goto out ; } new_grp = curr_grp + bytes_to_read ; if ( new_grp > bus -> m_dwSizeGetRing ) { new_grp -= bus -> m_dwSizeGetRing ; space_rem = bus -> m_dwSizeGetRing - curr_grp ; memcpy_fromio ( & msg_tmp , bus -> m_pdwGetRing + curr_grp , space_rem ) ; memcpy_fromio ( ( u8 * ) & msg_tmp + space_rem , bus -> m_pdwGetRing , bytes_to_read - space_rem ) ; } else { memcpy_fromio ( & msg_tmp , bus -> m_pdwGetRing + curr_grp , bytes_to_read ) ; } msg_tmp . size = le16_to_cpu ( ( __force __le16 ) msg_tmp . size ) ; msg_tmp . command = le32_to_cpu ( ( __force __le32 ) msg_tmp . command ) ; msg_tmp . controlselector = le16_to_cpu ( ( __force __le16 ) msg_tmp . controlselector ) ;  if ( peekonly ) {   memcpy ( msg , & msg_tmp , sizeof ( * msg ) ) ;  goto peekout ; } if ( ( msg_tmp . id != msg -> id ) || ( msg_tmp . command != msg -> command ) || ( msg_tmp . controlselector != msg -> controlselector ) || ( msg_tmp . seqno != msg -> seqno ) || ( msg_tmp . size != msg -> size ) ) { printk ( KERN_ERR ""%s()<S2SV_blank>Unexpected<S2SV_blank>msg<S2SV_blank>miss-match\\n"" , __func__ ) ; saa7164_bus_dumpmsg ( dev , msg , buf ) ; saa7164_bus_dumpmsg ( dev , & msg_tmp , NULL ) ; ret = SAA_ERR_INVALID_COMMAND ; goto out ; } buf_size = msg -> size ; bytes_to_read = sizeof ( * msg ) + msg -> size ; write_distance = 0 ; if ( curr_gwp >= curr_grp ) write_distance = curr_gwp - curr_grp ; else write_distance = curr_gwp + bus -> m_dwSizeGetRing - curr_grp ; if ( bytes_to_read > write_distance ) { printk ( KERN_ERR ""%s()<S2SV_blank>Invalid<S2SV_blank>bus<S2SV_blank>state,<S2SV_blank>missing<S2SV_blank>msg<S2SV_blank>or<S2SV_blank>mangled<S2SV_blank>ring,<S2SV_blank>faulty<S2SV_blank>H/W<S2SV_blank>/<S2SV_blank>bad<S2SV_blank>code?\\n"" , __func__ ) ; ret = SAA_ERR_INVALID_COMMAND ; goto out ; } new_grp = curr_grp + bytes_to_read ; if ( new_grp > bus -> m_dwSizeGetRing ) { new_grp -= bus -> m_dwSizeGetRing ; space_rem = bus -> m_dwSizeGetRing - curr_grp ; if ( space_rem < sizeof ( * msg ) ) {  memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , space_rem ) ;  memcpy_fromio ( ( u8 * ) msg + space_rem , bus -> m_pdwGetRing ,  sizeof ( * msg ) - space_rem ) ;  if ( buf )  memcpy_fromio ( buf , bus -> m_pdwGetRing + sizeof ( * msg ) -  space_rem , buf_size ) ;  } else if ( space_rem == sizeof ( * msg ) ) {  memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , sizeof ( * msg ) ) ; if ( buf ) memcpy_fromio ( buf , bus -> m_pdwGetRing , buf_size ) ; } else { memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , sizeof ( * msg ) ) ; if ( buf ) { memcpy_fromio ( buf , bus -> m_pdwGetRing + curr_grp + sizeof ( * msg ) , space_rem - sizeof ( * msg ) ) ; memcpy_fromio ( buf + space_rem - sizeof ( * msg ) , bus -> m_pdwGetRing , bytes_to_read - space_rem ) ; } } } else { memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , sizeof ( * msg ) ) ; if ( buf ) memcpy_fromio ( buf , bus -> m_pdwGetRing + curr_grp + sizeof ( * msg ) , buf_size ) ; } msg -> size = le16_to_cpu ( ( __force __le16 ) msg -> size ) ; msg -> command = le32_to_cpu ( ( __force __le32 ) msg -> command ) ; msg -> controlselector = le16_to_cpu ( ( __force __le16 ) msg -> controlselector ) ; saa7164_writel ( bus -> m_dwGetReadPos , new_grp ) ; peekout : ret = SAA_OK ; out : mutex_unlock ( & bus -> lock ) ; saa7164_bus_verify ( dev ) ; return ret ; }","memcpy_fromio ( msg , bus -> m_pdwGetRing + sizeof ( * msg ) - space_rem , buf_size ) ;}else if ( space_rem == sizeof ( * msg ) ) {if ( buf ) memcpy_fromio ( buf , bus -> m_pdwGetRing + curr_grp + sizeof ( * msg ) , space_rem - sizeof ( * msg ) ) ;memcpy_fromio ( buf + space_rem - sizeof ( * msg ) , bus -> m_pdwGetRing , bytes_to_read - space_rem ) ;",537
729,"buggy line: RETVAL_STRINGL ( replaced , ( int ) new_len , 0 ) ;}cwe id:CWE-190context: static void php_html_entities ( INTERNAL_FUNCTION_PARAMETERS , int all ) { char * str , * hint_charset = NULL ; int str_len , hint_charset_len = 0 ; size_t new_len ; long flags = ENT_COMPAT ; char * replaced ; zend_bool double_encode = 1 ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""s|ls!b"" , & str , & str_len , & flags , & hint_charset , & hint_charset_len , & double_encode ) == FAILURE ) { return ; } replaced = php_escape_html_entities_ex ( str , str_len , & new_len , all , ( int ) flags , hint_charset , double_encode TSRMLS_CC ) ;  RETVAL_STRINGL ( replaced , ( int ) new_len , 0 ) ;  }","if ( new_len > INT_MAX ) {efree ( replaced ) ;RETURN_FALSE ;}RETVAL_STRINGL ( replaced , ( int ) new_len , 0 ) ;}",538
730,"buggy line: if ( peerkey && ! EVP_PKEY_cmp ( peerkey , localkey ) ) {log_debug ( ""%s:<S2SV_blank>public<S2SV_blank>key<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>%s"" , __func__ , file ) ;cwe id:CWE-639context: int ca_validate_pubkey ( struct iked * env , struct iked_static_id * id , void * data , size_t len , struct iked_id * out ) { BIO * rawcert = NULL ; RSA * peerrsa = NULL , * localrsa = NULL ; EC_KEY * peerec = NULL ; EVP_PKEY * peerkey = NULL , * localkey = NULL ; int ret = - 1 ; FILE * fp = NULL ; char idstr [ IKED_ID_SIZE ] ; char file [ PATH_MAX ] ; struct iked_id idp ; switch ( id -> id_type ) { case IKEV2_ID_IPV4 : case IKEV2_ID_FQDN : case IKEV2_ID_UFQDN : case IKEV2_ID_IPV6 : break ; default : log_debug ( ""%s:<S2SV_blank>unsupported<S2SV_blank>public<S2SV_blank>key<S2SV_blank>type<S2SV_blank>%s"" , __func__ , print_map ( id -> id_type , ikev2_id_map ) ) ; return ( - 1 ) ; } bzero ( & idp , sizeof ( idp ) ) ; if ( ( idp . id_buf = ibuf_new ( id -> id_data , id -> id_length ) ) == NULL ) goto done ; idp . id_type = id -> id_type ; idp . id_offset = id -> id_offset ; if ( ikev2_print_id ( & idp , idstr , sizeof ( idstr ) ) == - 1 ) goto done ; if ( len == 0 && data ) { peerkey = ( EVP_PKEY * ) data ; } if ( len > 0 ) { if ( ( rawcert = BIO_new_mem_buf ( data , len ) ) == NULL ) goto done ; if ( ( peerkey = EVP_PKEY_new ( ) ) == NULL ) goto sslerr ; if ( ( peerrsa = d2i_RSAPublicKey_bio ( rawcert , NULL ) ) ) { if ( ! EVP_PKEY_set1_RSA ( peerkey , peerrsa ) ) { goto sslerr ; } } else if ( BIO_reset ( rawcert ) == 1 && ( peerec = d2i_EC_PUBKEY_bio ( rawcert , NULL ) ) ) { if ( ! EVP_PKEY_set1_EC_KEY ( peerkey , peerec ) ) { goto sslerr ; } } else { log_debug ( ""%s:<S2SV_blank>unknown<S2SV_blank>key<S2SV_blank>type<S2SV_blank>received"" , __func__ ) ; goto sslerr ; } } lc_idtype ( idstr ) ; if ( strlcpy ( file , IKED_PUBKEY_DIR , sizeof ( file ) ) >= sizeof ( file ) || strlcat ( file , idstr , sizeof ( file ) ) >= sizeof ( file ) ) { log_debug ( ""%s:<S2SV_blank>public<S2SV_blank>key<S2SV_blank>id<S2SV_blank>too<S2SV_blank>long<S2SV_blank>%s"" , __func__ , idstr ) ; goto done ; } if ( ( fp = fopen ( file , ""r"" ) ) == NULL ) { logit ( len == 0 ? LOG_DEBUG : LOG_INFO , ""%s:<S2SV_blank>could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>public<S2SV_blank>key<S2SV_blank>%s"" , __func__ , file ) ; goto done ; } localkey = PEM_read_PUBKEY ( fp , NULL , NULL , NULL ) ; if ( localkey == NULL ) { rewind ( fp ) ; localrsa = PEM_read_RSAPublicKey ( fp , NULL , NULL , NULL ) ; fclose ( fp ) ; if ( localrsa == NULL ) goto sslerr ; if ( ( localkey = EVP_PKEY_new ( ) ) == NULL ) goto sslerr ; if ( ! EVP_PKEY_set1_RSA ( localkey , localrsa ) ) goto sslerr ; } else { fclose ( fp ) ; } if ( localkey == NULL ) goto sslerr ;  if ( peerkey && ! EVP_PKEY_cmp ( peerkey , localkey ) ) {  log_debug ( ""%s:<S2SV_blank>public<S2SV_blank>key<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>%s"" , __func__ , file ) ; goto done ; } log_debug ( ""%s:<S2SV_blank>valid<S2SV_blank>public<S2SV_blank>key<S2SV_blank>in<S2SV_blank>file<S2SV_blank>%s"" , __func__ , file ) ; if ( out && ca_pubkey_serialize ( localkey , out ) ) goto done ; ret = 0 ; sslerr : if ( ret != 0 ) ca_sslerror ( __func__ ) ; done : ibuf_release ( idp . id_buf ) ; if ( localkey != NULL ) EVP_PKEY_free ( localkey ) ; if ( peerrsa != NULL ) RSA_free ( peerrsa ) ; if ( peerec != NULL ) EC_KEY_free ( peerec ) ; if ( localrsa != NULL ) RSA_free ( localrsa ) ; if ( rawcert != NULL ) { BIO_free ( rawcert ) ; if ( peerkey != NULL ) EVP_PKEY_free ( peerkey ) ; } return ( ret ) ; }","if ( peerkey && EVP_PKEY_cmp ( peerkey , localkey ) != 1 ) {log_debug ( ""%s:<S2SV_blank>public<S2SV_blank>key<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>%s"" , __func__ , file ) ;",539
731,"buggy line: strcat ( t1_buf_array , t1_line_array ) ;strcpy ( t1_line_array , t1_buf_array ) ;cwe id:CWE-119context: static void t1_check_unusual_charstring ( void ) { char * p = strstr ( t1_line_array , charstringname ) + strlen ( charstringname ) ; int i ; if ( sscanf ( p , ""%i"" , & i ) != 1 ) { strcpy ( t1_buf_array , t1_line_array ) ; t1_getline ( ) ;  strcat ( t1_buf_array , t1_line_array ) ;  strcpy ( t1_line_array , t1_buf_array ) ; t1_line_ptr = eol ( t1_line_array ) ; } }","alloc_array ( t1_buf , strlen ( t1_line_array ) + strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ;strcat ( t1_buf_array , t1_line_array ) ;alloc_array ( t1_line , strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ;strcpy ( t1_line_array , t1_buf_array ) ;",540
732,"buggy line: static void fill_mode_info_sb ( VP9_COMMON * cm , MACROBLOCK * x , int mi_row , int mi_col ,  BLOCK_SIZE bsize , BLOCK_SIZE subsize ) {MACROBLOCKD * xd = & x -> e_mbd ;int bsl = b_width_log2 ( bsize ) , hbs = ( 1 << bsl ) / 4 ;PARTITION_TYPE partition = partition_lookup [ bsl ] [ subsize ] ;assert ( bsize >= BLOCK_8X8 ) ;case PARTITION_NONE :  set_modeinfo_offsets ( cm , xd , mi_row , mi_col ) ;* ( xd -> mi [ 0 ] ) = get_block_context ( x , subsize ) -> mic ;duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col , bsize ) ;case PARTITION_VERT :  * get_sb_index ( x , subsize ) = 0 ;set_modeinfo_offsets ( cm , xd , mi_row , mi_col ) ;* ( xd -> mi [ 0 ] ) = get_block_context ( x , subsize ) -> mic ;duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col , bsize ) ;if ( mi_col + hbs < cm -> mi_cols ) {* get_sb_index ( x , subsize ) = 1 ;set_modeinfo_offsets ( cm , xd , mi_row , mi_col + hbs ) ;* ( xd -> mi [ 0 ] ) = get_block_context ( x , subsize ) -> mic ;duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col + hbs , bsize ) ;}case PARTITION_HORZ :  * get_sb_index ( x , subsize ) = 0 ;set_modeinfo_offsets ( cm , xd , mi_row , mi_col ) ;* ( xd -> mi [ 0 ] ) = get_block_context ( x , subsize ) -> mic ;duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col , bsize ) ;if ( mi_row + hbs < cm -> mi_rows ) {* get_sb_index ( x , subsize ) = 1 ;set_modeinfo_offsets ( cm , xd , mi_row + hbs , mi_col ) ;* ( xd -> mi [ 0 ] ) = get_block_context ( x , subsize ) -> mic ;duplicate_mode_info_in_sb ( cm , xd , mi_row + hbs , mi_col , bsize ) ;}case PARTITION_SPLIT :  * get_sb_index ( x , subsize ) = 0 ;fill_mode_info_sb ( cm , x , mi_row , mi_col , subsize ,  * ( get_sb_partitioning ( x , subsize ) ) ) ;* get_sb_index ( x , subsize ) = 1 ;fill_mode_info_sb ( cm , x , mi_row , mi_col + hbs , subsize ,  * ( get_sb_partitioning ( x , subsize ) ) ) ;* get_sb_index ( x , subsize ) = 2 ;fill_mode_info_sb ( cm , x , mi_row + hbs , mi_col , subsize ,  * ( get_sb_partitioning ( x , subsize ) ) ) ;* get_sb_index ( x , subsize ) = 3 ;break ;default : break ;cwe id:CWE-119context: static void fill_mode_info_sb ( VP9_COMMON * cm , MACROBLOCK * x , int mi_row , int mi_col ,  BLOCK_SIZE bsize , BLOCK_SIZE subsize ) {  MACROBLOCKD * xd = & x -> e_mbd ;  int bsl = b_width_log2 ( bsize ) , hbs = ( 1 << bsl ) / 4 ;   PARTITION_TYPE partition = partition_lookup [ bsl ] [ subsize ] ;  assert ( bsize >= BLOCK_8X8 ) ; if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) return ; switch ( partition ) { case PARTITION_NONE :  set_modeinfo_offsets ( cm , xd , mi_row , mi_col ) ;   * ( xd -> mi [ 0 ] ) = get_block_context ( x , subsize ) -> mic ;  duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col , bsize ) ; break ; case PARTITION_VERT :  * get_sb_index ( x , subsize ) = 0 ;  set_modeinfo_offsets ( cm , xd , mi_row , mi_col ) ;  * ( xd -> mi [ 0 ] ) = get_block_context ( x , subsize ) -> mic ;   duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col , bsize ) ;  if ( mi_col + hbs < cm -> mi_cols ) {  * get_sb_index ( x , subsize ) = 1 ;  set_modeinfo_offsets ( cm , xd , mi_row , mi_col + hbs ) ; * ( xd -> mi [ 0 ] ) = get_block_context ( x , subsize ) -> mic ;  duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col + hbs , bsize ) ;  } break ; case PARTITION_HORZ :  * get_sb_index ( x , subsize ) = 0 ;  set_modeinfo_offsets ( cm , xd , mi_row , mi_col ) ;  * ( xd -> mi [ 0 ] ) = get_block_context ( x , subsize ) -> mic ;   duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col , bsize ) ;  if ( mi_row + hbs < cm -> mi_rows ) {  * get_sb_index ( x , subsize ) = 1 ;  set_modeinfo_offsets ( cm , xd , mi_row + hbs , mi_col ) ; * ( xd -> mi [ 0 ] ) = get_block_context ( x , subsize ) -> mic ;  duplicate_mode_info_in_sb ( cm , xd , mi_row + hbs , mi_col , bsize ) ;  } break ; case PARTITION_SPLIT :  * get_sb_index ( x , subsize ) = 0 ;  fill_mode_info_sb ( cm , x , mi_row , mi_col , subsize ,  * ( get_sb_partitioning ( x , subsize ) ) ) ;  * get_sb_index ( x , subsize ) = 1 ;  fill_mode_info_sb ( cm , x , mi_row , mi_col + hbs , subsize ,  * ( get_sb_partitioning ( x , subsize ) ) ) ; * get_sb_index ( x , subsize ) = 2 ;  fill_mode_info_sb ( cm , x , mi_row + hbs , mi_col , subsize ,  * ( get_sb_partitioning ( x , subsize ) ) ) ; * get_sb_index ( x , subsize ) = 3 ; fill_mode_info_sb ( cm , x , mi_row + hbs , mi_col + hbs , subsize , * ( get_sb_partitioning ( x , subsize ) ) ) ;  break ;  default : break ; } }","static void fill_mode_info_sb ( VP9_COMMON * cm , MACROBLOCK * x , int mi_row , int mi_col , BLOCK_SIZE bsize , PC_TREE * pc_tree ) {MACROBLOCKD * xd = & x -> e_mbd ;int bsl = b_width_log2_lookup [ bsize ] , hbs = ( 1 << bsl ) / 4 ;PARTITION_TYPE partition = pc_tree -> partitioning ;BLOCK_SIZE subsize = get_subsize ( bsize , partition ) ;assert ( bsize >= BLOCK_8X8 ) ;case PARTITION_NONE : set_mode_info_offsets ( cm , x , xd , mi_row , mi_col ) ;* ( xd -> mi [ 0 ] ) = pc_tree -> none . mic ;* ( x -> mbmi_ext ) = pc_tree -> none . mbmi_ext ;duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col , bsize ) ;case PARTITION_VERT : set_mode_info_offsets ( cm , x , xd , mi_row , mi_col ) ;* ( xd -> mi [ 0 ] ) = pc_tree -> vertical [ 0 ] . mic ;* ( x -> mbmi_ext ) = pc_tree -> vertical [ 0 ] . mbmi_ext ;duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col , subsize ) ;if ( mi_col + hbs < cm -> mi_cols ) {set_mode_info_offsets ( cm , x , xd , mi_row , mi_col + hbs ) ;* ( xd -> mi [ 0 ] ) = pc_tree -> vertical [ 1 ] . mic ;* ( x -> mbmi_ext ) = pc_tree -> vertical [ 1 ] . mbmi_ext ;duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col + hbs , subsize ) ;}case PARTITION_HORZ : set_mode_info_offsets ( cm , x , xd , mi_row , mi_col ) ;* ( xd -> mi [ 0 ] ) = pc_tree -> horizontal [ 0 ] . mic ;* ( x -> mbmi_ext ) = pc_tree -> horizontal [ 0 ] . mbmi_ext ;duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col , subsize ) ;if ( mi_row + hbs < cm -> mi_rows ) {set_mode_info_offsets ( cm , x , xd , mi_row + hbs , mi_col ) ;* ( xd -> mi [ 0 ] ) = pc_tree -> horizontal [ 1 ] . mic ;* ( x -> mbmi_ext ) = pc_tree -> horizontal [ 1 ] . mbmi_ext ;duplicate_mode_info_in_sb ( cm , xd , mi_row + hbs , mi_col , subsize ) ;}case PARTITION_SPLIT : {fill_mode_info_sb ( cm , x , mi_row , mi_col , subsize , * ( get_sb_partitioning ( x , subsize ) ) ) ;* get_sb_index ( x , subsize ) = 1 ;fill_mode_info_sb ( cm , x , mi_row , mi_col + hbs , subsize , pc_tree -> split [ 0 ] ) ;fill_mode_info_sb ( cm , x , mi_row , mi_col + hbs , subsize , pc_tree -> split [ 1 ] ) ;fill_mode_info_sb ( cm , x , mi_row + hbs , mi_col , subsize , pc_tree -> split [ 2 ] ) ;break ;}default : break ;",541
733,"buggy line: free ( name ) ;return 0 ;cwe id:CWE-20context: static int fsck_gitmodules_fn ( const char * var , const char * value , void * vdata ) { struct fsck_gitmodules_data * data = vdata ; const char * subsection , * key ; int subsection_len ; char * name ; if ( parse_config_key ( var , ""submodule"" , & subsection , & subsection_len , & key ) < 0 || ! subsection ) return 0 ; name = xmemdupz ( subsection , subsection_len ) ; if ( check_submodule_name ( name ) < 0 ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_NAME , ""disallowed<S2SV_blank>submodule<S2SV_blank>name:<S2SV_blank>%s"" , name ) ;  free ( name ) ;  return 0 ; }","if ( ! strcmp ( key , ""url"" ) && value && looks_like_command_line_option ( value ) ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_URL , ""disallowed<S2SV_blank>submodule<S2SV_blank>url:<S2SV_blank>%s"" , value ) ;free ( name ) ;return 0 ;",542
734,"buggy line: int pixel_ptr = 0 ;int block_ptr ;cwe id:CWE-119context: static void rpza_decode_stream ( RpzaContext * s ) { int width = s -> avctx -> width ; int stride = s -> frame . linesize [ 0 ] / 2 ; int row_inc = stride - 4 ; int stream_ptr = 0 ; int chunk_size ; unsigned char opcode ; int n_blocks ; unsigned short colorA = 0 , colorB ; unsigned short color4 [ 4 ] ; unsigned char index , idx ; unsigned short ta , tb ; unsigned short * pixels = ( unsigned short * ) s -> frame . data [ 0 ] ; int row_ptr = 0 ;  int pixel_ptr = 0 ;  int block_ptr ; int pixel_x , pixel_y ; int total_blocks ; if ( s -> buf [ stream_ptr ] != 0xe1 ) av_log ( s -> avctx , AV_LOG_ERROR , ""First<S2SV_blank>chunk<S2SV_blank>byte<S2SV_blank>is<S2SV_blank>0x%02x<S2SV_blank>instead<S2SV_blank>of<S2SV_blank>0xe1\\n"" , s -> buf [ stream_ptr ] ) ; chunk_size = AV_RB32 ( & s -> buf [ stream_ptr ] ) & 0x00FFFFFF ; stream_ptr += 4 ; if ( chunk_size != s -> size ) av_log ( s -> avctx , AV_LOG_ERROR , ""MOV<S2SV_blank>chunk<S2SV_blank>size<S2SV_blank>!=<S2SV_blank>encoded<S2SV_blank>chunk<S2SV_blank>size;<S2SV_blank>using<S2SV_blank>MOV<S2SV_blank>chunk<S2SV_blank>size\\n"" ) ; chunk_size = s -> size ; total_blocks = ( ( s -> avctx -> width + 3 ) / 4 ) * ( ( s -> avctx -> height + 3 ) / 4 ) ; while ( stream_ptr < chunk_size ) { opcode = s -> buf [ stream_ptr ++ ] ; n_blocks = ( opcode & 0x1f ) + 1 ; if ( ( opcode & 0x80 ) == 0 ) { colorA = ( opcode << 8 ) | ( s -> buf [ stream_ptr ++ ] ) ; opcode = 0 ; if ( ( s -> buf [ stream_ptr ] & 0x80 ) != 0 ) { opcode = 0x20 ; n_blocks = 1 ; } } switch ( opcode & 0xe0 ) { case 0x80 : while ( n_blocks -- ) { ADVANCE_BLOCK ( ) ; } break ; case 0xa0 : colorA = AV_RB16 ( & s -> buf [ stream_ptr ] ) ; stream_ptr += 2 ; while ( n_blocks -- ) {  block_ptr = row_ptr + pixel_ptr ;  for ( pixel_y = 0 ; pixel_y < 4 ; pixel_y ++ ) { for ( pixel_x = 0 ; pixel_x < 4 ; pixel_x ++ ) { pixels [ block_ptr ] = colorA ; block_ptr ++ ; } block_ptr += row_inc ; }  ADVANCE_BLOCK ( ) ;  } break ; case 0xc0 : colorA = AV_RB16 ( & s -> buf [ stream_ptr ] ) ; stream_ptr += 2 ; case 0x20 : colorB = AV_RB16 ( & s -> buf [ stream_ptr ] ) ; stream_ptr += 2 ; color4 [ 0 ] = colorB ; color4 [ 1 ] = 0 ; color4 [ 2 ] = 0 ; color4 [ 3 ] = colorA ; ta = ( colorA >> 10 ) & 0x1F ; tb = ( colorB >> 10 ) & 0x1F ; color4 [ 1 ] |= ( ( 11 * ta + 21 * tb ) >> 5 ) << 10 ; color4 [ 2 ] |= ( ( 21 * ta + 11 * tb ) >> 5 ) << 10 ; ta = ( colorA >> 5 ) & 0x1F ; tb = ( colorB >> 5 ) & 0x1F ; color4 [ 1 ] |= ( ( 11 * ta + 21 * tb ) >> 5 ) << 5 ; color4 [ 2 ] |= ( ( 21 * ta + 11 * tb ) >> 5 ) << 5 ; ta = colorA & 0x1F ; tb = colorB & 0x1F ; color4 [ 1 ] |= ( ( 11 * ta + 21 * tb ) >> 5 ) ; color4 [ 2 ] |= ( ( 21 * ta + 11 * tb ) >> 5 ) ; if ( s -> size - stream_ptr < n_blocks * 4 ) return ; while ( n_blocks -- ) {  block_ptr = row_ptr + pixel_ptr ;  for ( pixel_y = 0 ; pixel_y < 4 ; pixel_y ++ ) { index = s -> buf [ stream_ptr ++ ] ; for ( pixel_x = 0 ; pixel_x < 4 ; pixel_x ++ ) { idx = ( index >> ( 2 * ( 3 - pixel_x ) ) ) & 0x03 ; pixels [ block_ptr ] = color4 [ idx ] ; block_ptr ++ ; } block_ptr += row_inc ; }  ADVANCE_BLOCK ( ) ;  } break ; case 0x00 : if ( s -> size - stream_ptr < 16 ) return ;  block_ptr = row_ptr + pixel_ptr ;  for ( pixel_y = 0 ; pixel_y < 4 ; pixel_y ++ ) { for ( pixel_x = 0 ; pixel_x < 4 ; pixel_x ++ ) { if ( ( pixel_y != 0 ) || ( pixel_x != 0 ) ) { colorA = AV_RB16 ( & s -> buf [ stream_ptr ] ) ; stream_ptr += 2 ; } pixels [ block_ptr ] = colorA ; block_ptr ++ ; } block_ptr += row_inc ; }  ADVANCE_BLOCK ( ) ;  break ; default : av_log ( s -> avctx , AV_LOG_ERROR , ""Unknown<S2SV_blank>opcode<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>rpza<S2SV_blank>chunk."" ""<S2SV_blank>Skip<S2SV_blank>remaining<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>chunk<S2SV_blank>data.\\n"" , opcode , chunk_size - stream_ptr ) ; return ; } } }",int pixel_ptr = - 4 ;int block_ptr ;,543
735,"buggy line: ADVANCE_BLOCK ( ) ;block_ptr = row_ptr + pixel_ptr ;for ( pixel_y = 0 ;cwe id:CWE-119context: static void rpza_decode_stream ( RpzaContext * s ) { int width = s -> avctx -> width ; int stride = s -> frame . linesize [ 0 ] / 2 ; int row_inc = stride - 4 ; int stream_ptr = 0 ; int chunk_size ; unsigned char opcode ; int n_blocks ; unsigned short colorA = 0 , colorB ; unsigned short color4 [ 4 ] ; unsigned char index , idx ; unsigned short ta , tb ; unsigned short * pixels = ( unsigned short * ) s -> frame . data [ 0 ] ; int row_ptr = 0 ;  int pixel_ptr = 0 ;  int block_ptr ; int pixel_x , pixel_y ; int total_blocks ; if ( s -> buf [ stream_ptr ] != 0xe1 ) av_log ( s -> avctx , AV_LOG_ERROR , ""First<S2SV_blank>chunk<S2SV_blank>byte<S2SV_blank>is<S2SV_blank>0x%02x<S2SV_blank>instead<S2SV_blank>of<S2SV_blank>0xe1\\n"" , s -> buf [ stream_ptr ] ) ; chunk_size = AV_RB32 ( & s -> buf [ stream_ptr ] ) & 0x00FFFFFF ; stream_ptr += 4 ; if ( chunk_size != s -> size ) av_log ( s -> avctx , AV_LOG_ERROR , ""MOV<S2SV_blank>chunk<S2SV_blank>size<S2SV_blank>!=<S2SV_blank>encoded<S2SV_blank>chunk<S2SV_blank>size;<S2SV_blank>using<S2SV_blank>MOV<S2SV_blank>chunk<S2SV_blank>size\\n"" ) ; chunk_size = s -> size ; total_blocks = ( ( s -> avctx -> width + 3 ) / 4 ) * ( ( s -> avctx -> height + 3 ) / 4 ) ; while ( stream_ptr < chunk_size ) { opcode = s -> buf [ stream_ptr ++ ] ; n_blocks = ( opcode & 0x1f ) + 1 ; if ( ( opcode & 0x80 ) == 0 ) { colorA = ( opcode << 8 ) | ( s -> buf [ stream_ptr ++ ] ) ; opcode = 0 ; if ( ( s -> buf [ stream_ptr ] & 0x80 ) != 0 ) { opcode = 0x20 ; n_blocks = 1 ; } } switch ( opcode & 0xe0 ) { case 0x80 : while ( n_blocks -- ) { ADVANCE_BLOCK ( ) ; } break ; case 0xa0 : colorA = AV_RB16 ( & s -> buf [ stream_ptr ] ) ; stream_ptr += 2 ; while ( n_blocks -- ) {  block_ptr = row_ptr + pixel_ptr ;  for ( pixel_y = 0 ; pixel_y < 4 ; pixel_y ++ ) { for ( pixel_x = 0 ; pixel_x < 4 ; pixel_x ++ ) { pixels [ block_ptr ] = colorA ; block_ptr ++ ; } block_ptr += row_inc ; }  ADVANCE_BLOCK ( ) ;  } break ; case 0xc0 : colorA = AV_RB16 ( & s -> buf [ stream_ptr ] ) ; stream_ptr += 2 ; case 0x20 : colorB = AV_RB16 ( & s -> buf [ stream_ptr ] ) ; stream_ptr += 2 ; color4 [ 0 ] = colorB ; color4 [ 1 ] = 0 ; color4 [ 2 ] = 0 ; color4 [ 3 ] = colorA ; ta = ( colorA >> 10 ) & 0x1F ; tb = ( colorB >> 10 ) & 0x1F ; color4 [ 1 ] |= ( ( 11 * ta + 21 * tb ) >> 5 ) << 10 ; color4 [ 2 ] |= ( ( 21 * ta + 11 * tb ) >> 5 ) << 10 ; ta = ( colorA >> 5 ) & 0x1F ; tb = ( colorB >> 5 ) & 0x1F ; color4 [ 1 ] |= ( ( 11 * ta + 21 * tb ) >> 5 ) << 5 ; color4 [ 2 ] |= ( ( 21 * ta + 11 * tb ) >> 5 ) << 5 ; ta = colorA & 0x1F ; tb = colorB & 0x1F ; color4 [ 1 ] |= ( ( 11 * ta + 21 * tb ) >> 5 ) ; color4 [ 2 ] |= ( ( 21 * ta + 11 * tb ) >> 5 ) ; if ( s -> size - stream_ptr < n_blocks * 4 ) return ; while ( n_blocks -- ) {  block_ptr = row_ptr + pixel_ptr ;  for ( pixel_y = 0 ; pixel_y < 4 ; pixel_y ++ ) { index = s -> buf [ stream_ptr ++ ] ; for ( pixel_x = 0 ; pixel_x < 4 ; pixel_x ++ ) { idx = ( index >> ( 2 * ( 3 - pixel_x ) ) ) & 0x03 ; pixels [ block_ptr ] = color4 [ idx ] ; block_ptr ++ ; } block_ptr += row_inc ; }  ADVANCE_BLOCK ( ) ;  } break ; case 0x00 : if ( s -> size - stream_ptr < 16 ) return ;  block_ptr = row_ptr + pixel_ptr ;  for ( pixel_y = 0 ; pixel_y < 4 ; pixel_y ++ ) { for ( pixel_x = 0 ; pixel_x < 4 ; pixel_x ++ ) { if ( ( pixel_y != 0 ) || ( pixel_x != 0 ) ) { colorA = AV_RB16 ( & s -> buf [ stream_ptr ] ) ; stream_ptr += 2 ; } pixels [ block_ptr ] = colorA ; block_ptr ++ ; } block_ptr += row_inc ; }  ADVANCE_BLOCK ( ) ;  break ; default : av_log ( s -> avctx , AV_LOG_ERROR , ""Unknown<S2SV_blank>opcode<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>rpza<S2SV_blank>chunk."" ""<S2SV_blank>Skip<S2SV_blank>remaining<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>chunk<S2SV_blank>data.\\n"" , opcode , chunk_size - stream_ptr ) ; return ; } } }",ADVANCE_BLOCK ( ) ADVANCE_BLOCK ( ) ;block_ptr = row_ptr + pixel_ptr ;for ( pixel_y = 0 ;,543
736,"buggy line: ADVANCE_BLOCK ( ) ;}cwe id:CWE-119context: static void rpza_decode_stream ( RpzaContext * s ) { int width = s -> avctx -> width ; int stride = s -> frame . linesize [ 0 ] / 2 ; int row_inc = stride - 4 ; int stream_ptr = 0 ; int chunk_size ; unsigned char opcode ; int n_blocks ; unsigned short colorA = 0 , colorB ; unsigned short color4 [ 4 ] ; unsigned char index , idx ; unsigned short ta , tb ; unsigned short * pixels = ( unsigned short * ) s -> frame . data [ 0 ] ; int row_ptr = 0 ;  int pixel_ptr = 0 ;  int block_ptr ; int pixel_x , pixel_y ; int total_blocks ; if ( s -> buf [ stream_ptr ] != 0xe1 ) av_log ( s -> avctx , AV_LOG_ERROR , ""First<S2SV_blank>chunk<S2SV_blank>byte<S2SV_blank>is<S2SV_blank>0x%02x<S2SV_blank>instead<S2SV_blank>of<S2SV_blank>0xe1\\n"" , s -> buf [ stream_ptr ] ) ; chunk_size = AV_RB32 ( & s -> buf [ stream_ptr ] ) & 0x00FFFFFF ; stream_ptr += 4 ; if ( chunk_size != s -> size ) av_log ( s -> avctx , AV_LOG_ERROR , ""MOV<S2SV_blank>chunk<S2SV_blank>size<S2SV_blank>!=<S2SV_blank>encoded<S2SV_blank>chunk<S2SV_blank>size;<S2SV_blank>using<S2SV_blank>MOV<S2SV_blank>chunk<S2SV_blank>size\\n"" ) ; chunk_size = s -> size ; total_blocks = ( ( s -> avctx -> width + 3 ) / 4 ) * ( ( s -> avctx -> height + 3 ) / 4 ) ; while ( stream_ptr < chunk_size ) { opcode = s -> buf [ stream_ptr ++ ] ; n_blocks = ( opcode & 0x1f ) + 1 ; if ( ( opcode & 0x80 ) == 0 ) { colorA = ( opcode << 8 ) | ( s -> buf [ stream_ptr ++ ] ) ; opcode = 0 ; if ( ( s -> buf [ stream_ptr ] & 0x80 ) != 0 ) { opcode = 0x20 ; n_blocks = 1 ; } } switch ( opcode & 0xe0 ) { case 0x80 : while ( n_blocks -- ) { ADVANCE_BLOCK ( ) ; } break ; case 0xa0 : colorA = AV_RB16 ( & s -> buf [ stream_ptr ] ) ; stream_ptr += 2 ; while ( n_blocks -- ) {  block_ptr = row_ptr + pixel_ptr ;  for ( pixel_y = 0 ; pixel_y < 4 ; pixel_y ++ ) { for ( pixel_x = 0 ; pixel_x < 4 ; pixel_x ++ ) { pixels [ block_ptr ] = colorA ; block_ptr ++ ; } block_ptr += row_inc ; }  ADVANCE_BLOCK ( ) ;  } break ; case 0xc0 : colorA = AV_RB16 ( & s -> buf [ stream_ptr ] ) ; stream_ptr += 2 ; case 0x20 : colorB = AV_RB16 ( & s -> buf [ stream_ptr ] ) ; stream_ptr += 2 ; color4 [ 0 ] = colorB ; color4 [ 1 ] = 0 ; color4 [ 2 ] = 0 ; color4 [ 3 ] = colorA ; ta = ( colorA >> 10 ) & 0x1F ; tb = ( colorB >> 10 ) & 0x1F ; color4 [ 1 ] |= ( ( 11 * ta + 21 * tb ) >> 5 ) << 10 ; color4 [ 2 ] |= ( ( 21 * ta + 11 * tb ) >> 5 ) << 10 ; ta = ( colorA >> 5 ) & 0x1F ; tb = ( colorB >> 5 ) & 0x1F ; color4 [ 1 ] |= ( ( 11 * ta + 21 * tb ) >> 5 ) << 5 ; color4 [ 2 ] |= ( ( 21 * ta + 11 * tb ) >> 5 ) << 5 ; ta = colorA & 0x1F ; tb = colorB & 0x1F ; color4 [ 1 ] |= ( ( 11 * ta + 21 * tb ) >> 5 ) ; color4 [ 2 ] |= ( ( 21 * ta + 11 * tb ) >> 5 ) ; if ( s -> size - stream_ptr < n_blocks * 4 ) return ; while ( n_blocks -- ) {  block_ptr = row_ptr + pixel_ptr ;  for ( pixel_y = 0 ; pixel_y < 4 ; pixel_y ++ ) { index = s -> buf [ stream_ptr ++ ] ; for ( pixel_x = 0 ; pixel_x < 4 ; pixel_x ++ ) { idx = ( index >> ( 2 * ( 3 - pixel_x ) ) ) & 0x03 ; pixels [ block_ptr ] = color4 [ idx ] ; block_ptr ++ ; } block_ptr += row_inc ; }  ADVANCE_BLOCK ( ) ;  } break ; case 0x00 : if ( s -> size - stream_ptr < 16 ) return ;  block_ptr = row_ptr + pixel_ptr ;  for ( pixel_y = 0 ; pixel_y < 4 ; pixel_y ++ ) { for ( pixel_x = 0 ; pixel_x < 4 ; pixel_x ++ ) { if ( ( pixel_y != 0 ) || ( pixel_x != 0 ) ) { colorA = AV_RB16 ( & s -> buf [ stream_ptr ] ) ; stream_ptr += 2 ; } pixels [ block_ptr ] = colorA ; block_ptr ++ ; } block_ptr += row_inc ; }  ADVANCE_BLOCK ( ) ;  break ; default : av_log ( s -> avctx , AV_LOG_ERROR , ""Unknown<S2SV_blank>opcode<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>rpza<S2SV_blank>chunk."" ""<S2SV_blank>Skip<S2SV_blank>remaining<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>chunk<S2SV_blank>data.\\n"" , opcode , chunk_size - stream_ptr ) ; return ; } } }",},543
737,"buggy line: block_ptr = row_ptr + pixel_ptr ;for ( pixel_y = 0 ;cwe id:CWE-119context: static void rpza_decode_stream ( RpzaContext * s ) { int width = s -> avctx -> width ; int stride = s -> frame . linesize [ 0 ] / 2 ; int row_inc = stride - 4 ; int stream_ptr = 0 ; int chunk_size ; unsigned char opcode ; int n_blocks ; unsigned short colorA = 0 , colorB ; unsigned short color4 [ 4 ] ; unsigned char index , idx ; unsigned short ta , tb ; unsigned short * pixels = ( unsigned short * ) s -> frame . data [ 0 ] ; int row_ptr = 0 ;  int pixel_ptr = 0 ;  int block_ptr ; int pixel_x , pixel_y ; int total_blocks ; if ( s -> buf [ stream_ptr ] != 0xe1 ) av_log ( s -> avctx , AV_LOG_ERROR , ""First<S2SV_blank>chunk<S2SV_blank>byte<S2SV_blank>is<S2SV_blank>0x%02x<S2SV_blank>instead<S2SV_blank>of<S2SV_blank>0xe1\\n"" , s -> buf [ stream_ptr ] ) ; chunk_size = AV_RB32 ( & s -> buf [ stream_ptr ] ) & 0x00FFFFFF ; stream_ptr += 4 ; if ( chunk_size != s -> size ) av_log ( s -> avctx , AV_LOG_ERROR , ""MOV<S2SV_blank>chunk<S2SV_blank>size<S2SV_blank>!=<S2SV_blank>encoded<S2SV_blank>chunk<S2SV_blank>size;<S2SV_blank>using<S2SV_blank>MOV<S2SV_blank>chunk<S2SV_blank>size\\n"" ) ; chunk_size = s -> size ; total_blocks = ( ( s -> avctx -> width + 3 ) / 4 ) * ( ( s -> avctx -> height + 3 ) / 4 ) ; while ( stream_ptr < chunk_size ) { opcode = s -> buf [ stream_ptr ++ ] ; n_blocks = ( opcode & 0x1f ) + 1 ; if ( ( opcode & 0x80 ) == 0 ) { colorA = ( opcode << 8 ) | ( s -> buf [ stream_ptr ++ ] ) ; opcode = 0 ; if ( ( s -> buf [ stream_ptr ] & 0x80 ) != 0 ) { opcode = 0x20 ; n_blocks = 1 ; } } switch ( opcode & 0xe0 ) { case 0x80 : while ( n_blocks -- ) { ADVANCE_BLOCK ( ) ; } break ; case 0xa0 : colorA = AV_RB16 ( & s -> buf [ stream_ptr ] ) ; stream_ptr += 2 ; while ( n_blocks -- ) {  block_ptr = row_ptr + pixel_ptr ;  for ( pixel_y = 0 ; pixel_y < 4 ; pixel_y ++ ) { for ( pixel_x = 0 ; pixel_x < 4 ; pixel_x ++ ) { pixels [ block_ptr ] = colorA ; block_ptr ++ ; } block_ptr += row_inc ; }  ADVANCE_BLOCK ( ) ;  } break ; case 0xc0 : colorA = AV_RB16 ( & s -> buf [ stream_ptr ] ) ; stream_ptr += 2 ; case 0x20 : colorB = AV_RB16 ( & s -> buf [ stream_ptr ] ) ; stream_ptr += 2 ; color4 [ 0 ] = colorB ; color4 [ 1 ] = 0 ; color4 [ 2 ] = 0 ; color4 [ 3 ] = colorA ; ta = ( colorA >> 10 ) & 0x1F ; tb = ( colorB >> 10 ) & 0x1F ; color4 [ 1 ] |= ( ( 11 * ta + 21 * tb ) >> 5 ) << 10 ; color4 [ 2 ] |= ( ( 21 * ta + 11 * tb ) >> 5 ) << 10 ; ta = ( colorA >> 5 ) & 0x1F ; tb = ( colorB >> 5 ) & 0x1F ; color4 [ 1 ] |= ( ( 11 * ta + 21 * tb ) >> 5 ) << 5 ; color4 [ 2 ] |= ( ( 21 * ta + 11 * tb ) >> 5 ) << 5 ; ta = colorA & 0x1F ; tb = colorB & 0x1F ; color4 [ 1 ] |= ( ( 11 * ta + 21 * tb ) >> 5 ) ; color4 [ 2 ] |= ( ( 21 * ta + 11 * tb ) >> 5 ) ; if ( s -> size - stream_ptr < n_blocks * 4 ) return ; while ( n_blocks -- ) {  block_ptr = row_ptr + pixel_ptr ;  for ( pixel_y = 0 ; pixel_y < 4 ; pixel_y ++ ) { index = s -> buf [ stream_ptr ++ ] ; for ( pixel_x = 0 ; pixel_x < 4 ; pixel_x ++ ) { idx = ( index >> ( 2 * ( 3 - pixel_x ) ) ) & 0x03 ; pixels [ block_ptr ] = color4 [ idx ] ; block_ptr ++ ; } block_ptr += row_inc ; }  ADVANCE_BLOCK ( ) ;  } break ; case 0x00 : if ( s -> size - stream_ptr < 16 ) return ;  block_ptr = row_ptr + pixel_ptr ;  for ( pixel_y = 0 ; pixel_y < 4 ; pixel_y ++ ) { for ( pixel_x = 0 ; pixel_x < 4 ; pixel_x ++ ) { if ( ( pixel_y != 0 ) || ( pixel_x != 0 ) ) { colorA = AV_RB16 ( & s -> buf [ stream_ptr ] ) ; stream_ptr += 2 ; } pixels [ block_ptr ] = colorA ; block_ptr ++ ; } block_ptr += row_inc ; }  ADVANCE_BLOCK ( ) ;  break ; default : av_log ( s -> avctx , AV_LOG_ERROR , ""Unknown<S2SV_blank>opcode<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>rpza<S2SV_blank>chunk."" ""<S2SV_blank>Skip<S2SV_blank>remaining<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>chunk<S2SV_blank>data.\\n"" , opcode , chunk_size - stream_ptr ) ; return ; } } }",ADVANCE_BLOCK ( ) ;block_ptr = row_ptr + pixel_ptr ;for ( pixel_y = 0 ;,543
738,"buggy line: ADVANCE_BLOCK ( ) ;}block_ptr = row_ptr + pixel_ptr ;for ( pixel_y = 0 ;cwe id:CWE-119context: static void rpza_decode_stream ( RpzaContext * s ) { int width = s -> avctx -> width ; int stride = s -> frame . linesize [ 0 ] / 2 ; int row_inc = stride - 4 ; int stream_ptr = 0 ; int chunk_size ; unsigned char opcode ; int n_blocks ; unsigned short colorA = 0 , colorB ; unsigned short color4 [ 4 ] ; unsigned char index , idx ; unsigned short ta , tb ; unsigned short * pixels = ( unsigned short * ) s -> frame . data [ 0 ] ; int row_ptr = 0 ;  int pixel_ptr = 0 ;  int block_ptr ; int pixel_x , pixel_y ; int total_blocks ; if ( s -> buf [ stream_ptr ] != 0xe1 ) av_log ( s -> avctx , AV_LOG_ERROR , ""First<S2SV_blank>chunk<S2SV_blank>byte<S2SV_blank>is<S2SV_blank>0x%02x<S2SV_blank>instead<S2SV_blank>of<S2SV_blank>0xe1\\n"" , s -> buf [ stream_ptr ] ) ; chunk_size = AV_RB32 ( & s -> buf [ stream_ptr ] ) & 0x00FFFFFF ; stream_ptr += 4 ; if ( chunk_size != s -> size ) av_log ( s -> avctx , AV_LOG_ERROR , ""MOV<S2SV_blank>chunk<S2SV_blank>size<S2SV_blank>!=<S2SV_blank>encoded<S2SV_blank>chunk<S2SV_blank>size;<S2SV_blank>using<S2SV_blank>MOV<S2SV_blank>chunk<S2SV_blank>size\\n"" ) ; chunk_size = s -> size ; total_blocks = ( ( s -> avctx -> width + 3 ) / 4 ) * ( ( s -> avctx -> height + 3 ) / 4 ) ; while ( stream_ptr < chunk_size ) { opcode = s -> buf [ stream_ptr ++ ] ; n_blocks = ( opcode & 0x1f ) + 1 ; if ( ( opcode & 0x80 ) == 0 ) { colorA = ( opcode << 8 ) | ( s -> buf [ stream_ptr ++ ] ) ; opcode = 0 ; if ( ( s -> buf [ stream_ptr ] & 0x80 ) != 0 ) { opcode = 0x20 ; n_blocks = 1 ; } } switch ( opcode & 0xe0 ) { case 0x80 : while ( n_blocks -- ) { ADVANCE_BLOCK ( ) ; } break ; case 0xa0 : colorA = AV_RB16 ( & s -> buf [ stream_ptr ] ) ; stream_ptr += 2 ; while ( n_blocks -- ) {  block_ptr = row_ptr + pixel_ptr ;  for ( pixel_y = 0 ; pixel_y < 4 ; pixel_y ++ ) { for ( pixel_x = 0 ; pixel_x < 4 ; pixel_x ++ ) { pixels [ block_ptr ] = colorA ; block_ptr ++ ; } block_ptr += row_inc ; }  ADVANCE_BLOCK ( ) ;  } break ; case 0xc0 : colorA = AV_RB16 ( & s -> buf [ stream_ptr ] ) ; stream_ptr += 2 ; case 0x20 : colorB = AV_RB16 ( & s -> buf [ stream_ptr ] ) ; stream_ptr += 2 ; color4 [ 0 ] = colorB ; color4 [ 1 ] = 0 ; color4 [ 2 ] = 0 ; color4 [ 3 ] = colorA ; ta = ( colorA >> 10 ) & 0x1F ; tb = ( colorB >> 10 ) & 0x1F ; color4 [ 1 ] |= ( ( 11 * ta + 21 * tb ) >> 5 ) << 10 ; color4 [ 2 ] |= ( ( 21 * ta + 11 * tb ) >> 5 ) << 10 ; ta = ( colorA >> 5 ) & 0x1F ; tb = ( colorB >> 5 ) & 0x1F ; color4 [ 1 ] |= ( ( 11 * ta + 21 * tb ) >> 5 ) << 5 ; color4 [ 2 ] |= ( ( 21 * ta + 11 * tb ) >> 5 ) << 5 ; ta = colorA & 0x1F ; tb = colorB & 0x1F ; color4 [ 1 ] |= ( ( 11 * ta + 21 * tb ) >> 5 ) ; color4 [ 2 ] |= ( ( 21 * ta + 11 * tb ) >> 5 ) ; if ( s -> size - stream_ptr < n_blocks * 4 ) return ; while ( n_blocks -- ) {  block_ptr = row_ptr + pixel_ptr ;  for ( pixel_y = 0 ; pixel_y < 4 ; pixel_y ++ ) { index = s -> buf [ stream_ptr ++ ] ; for ( pixel_x = 0 ; pixel_x < 4 ; pixel_x ++ ) { idx = ( index >> ( 2 * ( 3 - pixel_x ) ) ) & 0x03 ; pixels [ block_ptr ] = color4 [ idx ] ; block_ptr ++ ; } block_ptr += row_inc ; }  ADVANCE_BLOCK ( ) ;  } break ; case 0x00 : if ( s -> size - stream_ptr < 16 ) return ;  block_ptr = row_ptr + pixel_ptr ;  for ( pixel_y = 0 ; pixel_y < 4 ; pixel_y ++ ) { for ( pixel_x = 0 ; pixel_x < 4 ; pixel_x ++ ) { if ( ( pixel_y != 0 ) || ( pixel_x != 0 ) ) { colorA = AV_RB16 ( & s -> buf [ stream_ptr ] ) ; stream_ptr += 2 ; } pixels [ block_ptr ] = colorA ; block_ptr ++ ; } block_ptr += row_inc ; }  ADVANCE_BLOCK ( ) ;  break ; default : av_log ( s -> avctx , AV_LOG_ERROR , ""Unknown<S2SV_blank>opcode<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>rpza<S2SV_blank>chunk."" ""<S2SV_blank>Skip<S2SV_blank>remaining<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>chunk<S2SV_blank>data.\\n"" , opcode , chunk_size - stream_ptr ) ; return ; } } }",}ADVANCE_BLOCK ( ) ;block_ptr = row_ptr + pixel_ptr ;for ( pixel_y = 0 ;,543
739,"buggy line: ADVANCE_BLOCK ( ) ;break ;cwe id:CWE-119context: static void rpza_decode_stream ( RpzaContext * s ) { int width = s -> avctx -> width ; int stride = s -> frame . linesize [ 0 ] / 2 ; int row_inc = stride - 4 ; int stream_ptr = 0 ; int chunk_size ; unsigned char opcode ; int n_blocks ; unsigned short colorA = 0 , colorB ; unsigned short color4 [ 4 ] ; unsigned char index , idx ; unsigned short ta , tb ; unsigned short * pixels = ( unsigned short * ) s -> frame . data [ 0 ] ; int row_ptr = 0 ;  int pixel_ptr = 0 ;  int block_ptr ; int pixel_x , pixel_y ; int total_blocks ; if ( s -> buf [ stream_ptr ] != 0xe1 ) av_log ( s -> avctx , AV_LOG_ERROR , ""First<S2SV_blank>chunk<S2SV_blank>byte<S2SV_blank>is<S2SV_blank>0x%02x<S2SV_blank>instead<S2SV_blank>of<S2SV_blank>0xe1\\n"" , s -> buf [ stream_ptr ] ) ; chunk_size = AV_RB32 ( & s -> buf [ stream_ptr ] ) & 0x00FFFFFF ; stream_ptr += 4 ; if ( chunk_size != s -> size ) av_log ( s -> avctx , AV_LOG_ERROR , ""MOV<S2SV_blank>chunk<S2SV_blank>size<S2SV_blank>!=<S2SV_blank>encoded<S2SV_blank>chunk<S2SV_blank>size;<S2SV_blank>using<S2SV_blank>MOV<S2SV_blank>chunk<S2SV_blank>size\\n"" ) ; chunk_size = s -> size ; total_blocks = ( ( s -> avctx -> width + 3 ) / 4 ) * ( ( s -> avctx -> height + 3 ) / 4 ) ; while ( stream_ptr < chunk_size ) { opcode = s -> buf [ stream_ptr ++ ] ; n_blocks = ( opcode & 0x1f ) + 1 ; if ( ( opcode & 0x80 ) == 0 ) { colorA = ( opcode << 8 ) | ( s -> buf [ stream_ptr ++ ] ) ; opcode = 0 ; if ( ( s -> buf [ stream_ptr ] & 0x80 ) != 0 ) { opcode = 0x20 ; n_blocks = 1 ; } } switch ( opcode & 0xe0 ) { case 0x80 : while ( n_blocks -- ) { ADVANCE_BLOCK ( ) ; } break ; case 0xa0 : colorA = AV_RB16 ( & s -> buf [ stream_ptr ] ) ; stream_ptr += 2 ; while ( n_blocks -- ) {  block_ptr = row_ptr + pixel_ptr ;  for ( pixel_y = 0 ; pixel_y < 4 ; pixel_y ++ ) { for ( pixel_x = 0 ; pixel_x < 4 ; pixel_x ++ ) { pixels [ block_ptr ] = colorA ; block_ptr ++ ; } block_ptr += row_inc ; }  ADVANCE_BLOCK ( ) ;  } break ; case 0xc0 : colorA = AV_RB16 ( & s -> buf [ stream_ptr ] ) ; stream_ptr += 2 ; case 0x20 : colorB = AV_RB16 ( & s -> buf [ stream_ptr ] ) ; stream_ptr += 2 ; color4 [ 0 ] = colorB ; color4 [ 1 ] = 0 ; color4 [ 2 ] = 0 ; color4 [ 3 ] = colorA ; ta = ( colorA >> 10 ) & 0x1F ; tb = ( colorB >> 10 ) & 0x1F ; color4 [ 1 ] |= ( ( 11 * ta + 21 * tb ) >> 5 ) << 10 ; color4 [ 2 ] |= ( ( 21 * ta + 11 * tb ) >> 5 ) << 10 ; ta = ( colorA >> 5 ) & 0x1F ; tb = ( colorB >> 5 ) & 0x1F ; color4 [ 1 ] |= ( ( 11 * ta + 21 * tb ) >> 5 ) << 5 ; color4 [ 2 ] |= ( ( 21 * ta + 11 * tb ) >> 5 ) << 5 ; ta = colorA & 0x1F ; tb = colorB & 0x1F ; color4 [ 1 ] |= ( ( 11 * ta + 21 * tb ) >> 5 ) ; color4 [ 2 ] |= ( ( 21 * ta + 11 * tb ) >> 5 ) ; if ( s -> size - stream_ptr < n_blocks * 4 ) return ; while ( n_blocks -- ) {  block_ptr = row_ptr + pixel_ptr ;  for ( pixel_y = 0 ; pixel_y < 4 ; pixel_y ++ ) { index = s -> buf [ stream_ptr ++ ] ; for ( pixel_x = 0 ; pixel_x < 4 ; pixel_x ++ ) { idx = ( index >> ( 2 * ( 3 - pixel_x ) ) ) & 0x03 ; pixels [ block_ptr ] = color4 [ idx ] ; block_ptr ++ ; } block_ptr += row_inc ; }  ADVANCE_BLOCK ( ) ;  } break ; case 0x00 : if ( s -> size - stream_ptr < 16 ) return ;  block_ptr = row_ptr + pixel_ptr ;  for ( pixel_y = 0 ; pixel_y < 4 ; pixel_y ++ ) { for ( pixel_x = 0 ; pixel_x < 4 ; pixel_x ++ ) { if ( ( pixel_y != 0 ) || ( pixel_x != 0 ) ) { colorA = AV_RB16 ( & s -> buf [ stream_ptr ] ) ; stream_ptr += 2 ; } pixels [ block_ptr ] = colorA ; block_ptr ++ ; } block_ptr += row_inc ; }  ADVANCE_BLOCK ( ) ;  break ; default : av_log ( s -> avctx , AV_LOG_ERROR , ""Unknown<S2SV_blank>opcode<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>rpza<S2SV_blank>chunk."" ""<S2SV_blank>Skip<S2SV_blank>remaining<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>chunk<S2SV_blank>data.\\n"" , opcode , chunk_size - stream_ptr ) ; return ; } } }",break ;,543
740,"buggy line: int n ;assert ( cnt >= 0 ) ;cwe id:CWE-190context: static int mem_read ( jas_stream_obj_t * obj , char * buf , int cnt ) {  int n ;  assert ( cnt >= 0 ) ; assert ( buf ) ; JAS_DBGLOG ( 100 , ( ""mem_read(%p,<S2SV_blank>%p,<S2SV_blank>%d)\\n"" , obj , buf , cnt ) ) ; jas_stream_memobj_t * m = ( jas_stream_memobj_t * ) obj ; n = m -> len_ - m -> pos_ ; cnt = JAS_MIN ( n , cnt ) ; memcpy ( buf , & m -> buf_ [ m -> pos_ ] , cnt ) ; m -> pos_ += cnt ; return cnt ; }",ssize_t n ;assert ( cnt >= 0 ) ;,544
741,"buggy line: __be16 type ;off = skb_gro_offset ( skb ) ;cwe id:CWE-400context: static struct sk_buff * * gre_gro_receive ( struct sk_buff * * head , struct sk_buff * skb ) { struct sk_buff * * pp = NULL ; struct sk_buff * p ; const struct gre_base_hdr * greh ; unsigned int hlen , grehlen ; unsigned int off ; int flush = 1 ; struct packet_offload * ptype ;  __be16 type ;  off = skb_gro_offset ( skb ) ; hlen = off + sizeof ( * greh ) ; greh = skb_gro_header_fast ( skb , off ) ; if ( skb_gro_header_hard ( skb , hlen ) ) { greh = skb_gro_header_slow ( skb , hlen , off ) ; if ( unlikely ( ! greh ) ) goto out ; } if ( ( greh -> flags & ~ ( GRE_KEY | GRE_CSUM ) ) != 0 ) goto out ; type = greh -> protocol ; rcu_read_lock ( ) ; ptype = gro_find_receive_by_type ( type ) ; if ( ! ptype ) goto out_unlock ; grehlen = GRE_HEADER_SECTION ; if ( greh -> flags & GRE_KEY ) grehlen += GRE_HEADER_SECTION ; if ( greh -> flags & GRE_CSUM ) grehlen += GRE_HEADER_SECTION ; hlen = off + grehlen ; if ( skb_gro_header_hard ( skb , hlen ) ) { greh = skb_gro_header_slow ( skb , hlen , off ) ; if ( unlikely ( ! greh ) ) goto out_unlock ; } if ( ( greh -> flags & GRE_CSUM ) && ! NAPI_GRO_CB ( skb ) -> flush ) { if ( skb_gro_checksum_simple_validate ( skb ) ) goto out_unlock ; skb_gro_checksum_try_convert ( skb , IPPROTO_GRE , 0 , null_compute_pseudo ) ; } for ( p = * head ; p ; p = p -> next ) { const struct gre_base_hdr * greh2 ; if ( ! NAPI_GRO_CB ( p ) -> same_flow ) continue ; greh2 = ( struct gre_base_hdr * ) ( p -> data + off ) ; if ( greh2 -> flags != greh -> flags || greh2 -> protocol != greh -> protocol ) { NAPI_GRO_CB ( p ) -> same_flow = 0 ; continue ; } if ( greh -> flags & GRE_KEY ) { if ( * ( __be32 * ) ( greh2 + 1 ) != * ( __be32 * ) ( greh + 1 ) ) { NAPI_GRO_CB ( p ) -> same_flow = 0 ; continue ; } } } skb_gro_pull ( skb , grehlen ) ; skb_gro_postpull_rcsum ( skb , greh , grehlen ) ; pp = ptype -> callbacks . gro_receive ( head , skb ) ; flush = 0 ; out_unlock : rcu_read_unlock ( ) ; out : NAPI_GRO_CB ( skb ) -> flush |= flush ; return pp ; }",__be16 type ;if ( NAPI_GRO_CB ( skb ) -> encap_mark ) goto out ;NAPI_GRO_CB ( skb ) -> encap_mark = 1 ;off = skb_gro_offset ( skb ) ;,545
742,"buggy line: if ( ! ( matrix = jas_malloc ( sizeof ( jas_matrix_t ) ) ) ) {return 0 ;cwe id:CWE-476context: jas_matrix_t * jas_matrix_create ( int numrows , int numcols ) { jas_matrix_t * matrix ; int i ;  if ( ! ( matrix = jas_malloc ( sizeof ( jas_matrix_t ) ) ) ) {  return 0 ; } matrix -> flags_ = 0 ; matrix -> numrows_ = numrows ; matrix -> numcols_ = numcols ; matrix -> rows_ = 0 ; matrix -> maxrows_ = numrows ; matrix -> data_ = 0 ; matrix -> datasize_ = numrows * numcols ; if ( matrix -> maxrows_ > 0 ) { if ( ! ( matrix -> rows_ = jas_alloc2 ( matrix -> maxrows_ , sizeof ( jas_seqent_t * ) ) ) ) { jas_matrix_destroy ( matrix ) ; return 0 ; } } if ( matrix -> datasize_ > 0 ) { if ( ! ( matrix -> data_ = jas_alloc2 ( matrix -> datasize_ , sizeof ( jas_seqent_t ) ) ) ) { jas_matrix_destroy ( matrix ) ; return 0 ; } } for ( i = 0 ; i < numrows ; ++ i ) { matrix -> rows_ [ i ] = & matrix -> data_ [ i * matrix -> numcols_ ] ; } for ( i = 0 ; i < matrix -> datasize_ ; ++ i ) { matrix -> data_ [ i ] = 0 ; } matrix -> xstart_ = 0 ; matrix -> ystart_ = 0 ; matrix -> xend_ = matrix -> numcols_ ; matrix -> yend_ = matrix -> numrows_ ; return matrix ; }",if ( numrows < 0 || numcols < 0 ) {return 0 ;}if ( ! ( matrix = jas_malloc ( sizeof ( jas_matrix_t ) ) ) ) {return 0 ;,546
743,"buggy line: rval = tpm_kdfa ( sapi_context , session -> authHash , & ( key . b ) , label , & ( session -> nonceNewer . b ) ,  & ( session -> nonceOlder . b ) , bytes * 8 , ( TPM2B_MAX_BUFFER * ) & ( session -> sessionKey ) ) ;cwe id:CWE-522context: static TPM_RC StartAuthSession ( TSS2_SYS_CONTEXT * sapi_context , SESSION * session ) { TPM_RC rval ; TPM2B_ENCRYPTED_SECRET key ; char label [ ] = ""ATH"" ; UINT16 bytes ; int i ; key . t . size = 0 ; if ( session -> nonceOlder . t . size == 0 ) { session -> nonceOlder . t . size = GetDigestSize ( TPM_ALG_SHA1 ) ; for ( i = 0 ; i < session -> nonceOlder . t . size ; i ++ ) session -> nonceOlder . t . buffer [ i ] = 0 ; } session -> nonceNewer . t . size = session -> nonceOlder . t . size ; rval = Tss2_Sys_StartAuthSession ( sapi_context , session -> tpmKey , session -> bind , 0 , & ( session -> nonceOlder ) , & ( session -> encryptedSalt ) , session -> sessionType , & ( session -> symmetric ) , session -> authHash , & ( session -> sessionHandle ) , & ( session -> nonceNewer ) , 0 ) ; if ( rval == TPM_RC_SUCCESS ) { if ( session -> tpmKey == TPM_RH_NULL ) session -> salt . t . size = 0 ; if ( session -> bind == TPM_RH_NULL ) session -> authValueBind . t . size = 0 ; if ( session -> tpmKey == TPM_RH_NULL && session -> bind == TPM_RH_NULL ) { session -> sessionKey . b . size = 0 ; } else { bool result = string_bytes_concat_buffer ( ( TPM2B_MAX_BUFFER * ) & key , & ( session -> authValueBind . b ) ) ; if ( ! result ) { return TSS2_SYS_RC_BAD_VALUE ; } result = string_bytes_concat_buffer ( ( TPM2B_MAX_BUFFER * ) & key , & ( session -> salt . b ) ) ; if ( ! result ) { return TSS2_SYS_RC_BAD_VALUE ; } bytes = GetDigestSize ( session -> authHash ) ; if ( key . t . size == 0 ) { session -> sessionKey . t . size = 0 ; } else {  rval = tpm_kdfa ( sapi_context , session -> authHash , & ( key . b ) , label , & ( session -> nonceNewer . b ) ,  & ( session -> nonceOlder . b ) , bytes * 8 , ( TPM2B_MAX_BUFFER * ) & ( session -> sessionKey ) ) ; } if ( rval != TPM_RC_SUCCESS ) { return ( TSS2_APP_RC_CREATE_SESSION_KEY_FAILED ) ; } } session -> nonceTpmDecrypt . b . size = 0 ; session -> nonceTpmEncrypt . b . size = 0 ; session -> nvNameChanged = 0 ; } return rval ; }","rval = tpm_kdfa ( session -> authHash , & ( key . b ) , label , & ( session -> nonceNewer . b ) , & ( session -> nonceOlder . b ) , bytes * 8 , ( TPM2B_MAX_BUFFER * ) & ( session -> sessionKey ) ) ;",547
744,"buggy line: ret = key_permission ( key_ref , KEY_NEED_READ ) ;if ( ret == 0 ) goto can_read_key ;cwe id:CWE-476context: long keyctl_read_key ( key_serial_t keyid , char __user * buffer , size_t buflen ) { struct key * key ; key_ref_t key_ref ; long ret ; key_ref = lookup_user_key ( keyid , 0 , 0 ) ; if ( IS_ERR ( key_ref ) ) { ret = - ENOKEY ; goto error ; } key = key_ref_to_ptr ( key_ref ) ;  ret = key_permission ( key_ref , KEY_NEED_READ ) ;  if ( ret == 0 ) goto can_read_key ; if ( ret != - EACCES ) goto error2 ; if ( ! is_key_possessed ( key_ref ) ) { ret = - EACCES ; goto error2 ; } can_read_key : ret = - EOPNOTSUPP ; if ( key -> type -> read ) { down_read ( & key -> sem ) ; ret = key_validate ( key ) ; if ( ret == 0 ) ret = key -> type -> read ( key , buffer , buflen ) ; up_read ( & key -> sem ) ; } error2 : key_put ( key ) ; error : return ret ; }","if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) {ret = - ENOKEY ;goto error2 ;}ret = key_permission ( key_ref , KEY_NEED_READ ) ;if ( ret == 0 ) goto can_read_key ;",548
745,"buggy line: if ( ( ret == IVD_RES_CHANGED ) || ( ret == IVD_MEM_ALLOC_FAILED ) || ( ret == ERROR_UNAVAIL_PICBUF_T )  || ( ret == ERROR_UNAVAIL_MVBUF_T ) )  {cwe id:CWE-172context: WORD32 ih264d_video_decode ( iv_obj_t * dec_hdl , void * pv_api_ip , void * pv_api_op ) { dec_struct_t * ps_dec = ( dec_struct_t * ) ( dec_hdl -> pv_codec_handle ) ; WORD32 i4_err_status = 0 ; UWORD8 * pu1_buf = NULL ; WORD32 buflen ; UWORD32 u4_max_ofst , u4_length_of_start_code = 0 ; UWORD32 bytes_consumed = 0 ; UWORD32 cur_slice_is_nonref = 0 ; UWORD32 u4_next_is_aud ; UWORD32 u4_first_start_code_found = 0 ; WORD32 ret = 0 , api_ret_value = IV_SUCCESS ; WORD32 header_data_left = 0 , frame_data_left = 0 ; UWORD8 * pu1_bitstrm_buf ; ivd_video_decode_ip_t * ps_dec_ip ; ivd_video_decode_op_t * ps_dec_op ; ithread_set_name ( ( void * ) ""Parse_thread"" ) ; ps_dec_ip = ( ivd_video_decode_ip_t * ) pv_api_ip ; ps_dec_op = ( ivd_video_decode_op_t * ) pv_api_op ; { UWORD32 u4_size ; u4_size = ps_dec_op -> u4_size ; memset ( ps_dec_op , 0 , sizeof ( ivd_video_decode_op_t ) ) ; ps_dec_op -> u4_size = u4_size ; } ps_dec -> pv_dec_out = ps_dec_op ; if ( ps_dec -> init_done != 1 ) { return IV_FAIL ; } DATA_SYNC ( ) ; if ( 0 == ps_dec -> u1_flushfrm ) { if ( ps_dec_ip -> pv_stream_buffer == NULL ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL ; return IV_FAIL ; } if ( ps_dec_ip -> u4_num_Bytes <= 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DEC_NUMBYTES_INV ; return IV_FAIL ; } } ps_dec -> u1_pic_decode_done = 0 ; ps_dec_op -> u4_num_bytes_consumed = 0 ; ps_dec -> ps_out_buffer = NULL ; if ( ps_dec_ip -> u4_size >= offsetof ( ivd_video_decode_ip_t , s_out_buffer ) ) ps_dec -> ps_out_buffer = & ps_dec_ip -> s_out_buffer ; ps_dec -> u4_fmt_conv_cur_row = 0 ; ps_dec -> u4_output_present = 0 ; ps_dec -> s_disp_op . u4_error_code = 1 ; ps_dec -> u4_fmt_conv_num_rows = FMT_CONV_NUM_ROWS ; if ( 0 == ps_dec -> u4_share_disp_buf && ps_dec -> i4_decode_header == 0 ) { UWORD32 i ; if ( ps_dec -> ps_out_buffer -> u4_num_bufs == 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS ; return IV_FAIL ; } for ( i = 0 ; i < ps_dec -> ps_out_buffer -> u4_num_bufs ; i ++ ) { if ( ps_dec -> ps_out_buffer -> pu1_bufs [ i ] == NULL ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL ; return IV_FAIL ; } if ( ps_dec -> ps_out_buffer -> u4_min_out_buf_size [ i ] == 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUF_SIZE ; return IV_FAIL ; } } } if ( ps_dec -> u4_total_frames_decoded >= NUM_FRAMES_LIMIT ) { ps_dec_op -> u4_error_code = ERROR_FRAME_LIMIT_OVER ; return IV_FAIL ; } ps_dec -> u4_ts = ps_dec_ip -> u4_ts ; ps_dec_op -> u4_error_code = 0 ; ps_dec_op -> e_pic_type = - 1 ; ps_dec_op -> u4_output_present = 0 ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec -> i4_frametype = - 1 ; ps_dec -> i4_content_type = - 1 ; { if ( ( TOP_FIELD_ONLY | BOT_FIELD_ONLY ) == ps_dec -> u1_top_bottom_decoded ) { ps_dec -> u1_top_bottom_decoded = 0 ; } } ps_dec -> u4_slice_start_code_found = 0 ; if ( ps_dec -> u1_init_dec_flag == 1 && ps_dec -> u4_share_disp_buf == 1 && ps_dec -> u1_flushfrm == 0 ) { UWORD32 i ; WORD32 disp_avail = 0 , free_id ; for ( i = 0 ; i < ps_dec -> u1_pic_bufs ; i ++ ) { if ( 0 == ps_dec -> u4_disp_buf_mapping [ i ] || 1 == ps_dec -> u4_disp_buf_to_be_freed [ i ] ) { disp_avail = 1 ; break ; } } if ( 0 == disp_avail ) { ps_dec_op -> u4_error_code = IVD_DEC_REF_BUF_NULL ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; return ( IV_FAIL ) ; } while ( 1 ) { pic_buffer_t * ps_pic_buf ; ps_pic_buf = ( pic_buffer_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , & free_id ) ; if ( ps_pic_buf == NULL ) { UWORD32 i , display_queued = 0 ; for ( i = 0 ; i < ( MAX_DISP_BUFS_NEW ) ; i ++ ) { if ( 0 != ps_dec -> u4_disp_buf_mapping [ i ] ) { display_queued = 1 ; break ; } } if ( 1 == display_queued ) { ps_dec_op -> u4_error_code = IVD_DEC_REF_BUF_NULL ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; return ( IV_FAIL ) ; } } else { if ( 1 == ps_dec -> u4_disp_buf_mapping [ free_id ] ) { ih264_buf_mgr_set_status ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , free_id , BUF_MGR_IO ) ; } else { ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , free_id , BUF_MGR_IO ) ; break ; } } } } if ( ps_dec -> u1_flushfrm && ps_dec -> u1_init_dec_flag ) { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 == ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = 0 ; ps_dec -> u4_fmt_conv_num_rows = ps_dec -> s_disp_frame_info . u4_y_ht ; ih264d_format_convert ( ps_dec , & ( ps_dec -> s_disp_op ) , ps_dec -> u4_fmt_conv_cur_row , ps_dec -> u4_fmt_conv_num_rows ) ; ps_dec -> u4_fmt_conv_cur_row += ps_dec -> u4_fmt_conv_num_rows ; ps_dec -> u4_output_present = 1 ; } ih264d_release_display_field ( ps_dec , & ( ps_dec -> s_disp_op ) ) ; ps_dec_op -> u4_pic_wd = ( UWORD32 ) ps_dec -> u2_disp_width ; ps_dec_op -> u4_pic_ht = ( UWORD32 ) ps_dec -> u2_disp_height ; ps_dec_op -> u4_new_seq = 0 ; ps_dec_op -> u4_output_present = ps_dec -> u4_output_present ; ps_dec_op -> u4_progressive_frame_flag = ps_dec -> s_disp_op . u4_progressive_frame_flag ; ps_dec_op -> e_output_format = ps_dec -> s_disp_op . e_output_format ; ps_dec_op -> s_disp_frm_buf = ps_dec -> s_disp_op . s_disp_frm_buf ; ps_dec_op -> e4_fld_type = ps_dec -> s_disp_op . e4_fld_type ; ps_dec_op -> u4_ts = ps_dec -> s_disp_op . u4_ts ; ps_dec_op -> u4_disp_buf_id = ps_dec -> s_disp_op . u4_disp_buf_id ; ps_dec_op -> u4_is_ref_flag = - 1 ; ps_dec_op -> e_pic_type = IV_NA_FRAME ; ps_dec_op -> u4_frame_decoded_flag = 0 ; if ( 0 == ps_dec -> s_disp_op . u4_error_code ) { return ( IV_SUCCESS ) ; } else return ( IV_FAIL ) ; } if ( ps_dec -> u1_res_changed == 1 ) { ih264d_init_decoder ( ps_dec ) ; } ps_dec -> u4_prev_nal_skipped = 0 ; ps_dec -> u2_cur_mb_addr = 0 ; ps_dec -> u2_total_mbs_coded = 0 ; ps_dec -> u2_cur_slice_num = 0 ; ps_dec -> cur_dec_mb_num = 0 ; ps_dec -> cur_recon_mb_num = 0 ; ps_dec -> u4_first_slice_in_pic = 2 ; ps_dec -> u1_slice_header_done = 0 ; ps_dec -> u1_dangling_field = 0 ; ps_dec -> u4_dec_thread_created = 0 ; ps_dec -> u4_bs_deblk_thread_created = 0 ; ps_dec -> u4_cur_bs_mb_num = 0 ; ps_dec -> u4_start_recon_deblk = 0 ; DEBUG_THREADS_PRINTF ( ""<S2SV_blank>Starting<S2SV_blank>process<S2SV_blank>call\\n"" ) ; ps_dec -> u4_pic_buf_got = 0 ; do { WORD32 buf_size ; pu1_buf = ( UWORD8 * ) ps_dec_ip -> pv_stream_buffer + ps_dec_op -> u4_num_bytes_consumed ; u4_max_ofst = ps_dec_ip -> u4_num_Bytes - ps_dec_op -> u4_num_bytes_consumed ; if ( ( NULL == ps_dec -> pu1_bits_buf_dynamic ) && ( ps_dec -> i4_header_decoded & 1 ) ) { WORD32 size ; void * pv_buf ; void * pv_mem_ctxt = ps_dec -> pv_mem_ctxt ; size = MAX ( 256000 , ps_dec -> u2_pic_wd * ps_dec -> u2_pic_ht * 3 / 2 ) ; pv_buf = ps_dec -> pf_aligned_alloc ( pv_mem_ctxt , 128 , size ) ; RETURN_IF ( ( NULL == pv_buf ) , IV_FAIL ) ; ps_dec -> pu1_bits_buf_dynamic = pv_buf ; ps_dec -> u4_dynamic_bits_buf_size = size ; } if ( ps_dec -> pu1_bits_buf_dynamic ) { pu1_bitstrm_buf = ps_dec -> pu1_bits_buf_dynamic ; buf_size = ps_dec -> u4_dynamic_bits_buf_size ; } else { pu1_bitstrm_buf = ps_dec -> pu1_bits_buf_static ; buf_size = ps_dec -> u4_static_bits_buf_size ; } u4_next_is_aud = 0 ; buflen = ih264d_find_start_code ( pu1_buf , 0 , u4_max_ofst , & u4_length_of_start_code , & u4_next_is_aud ) ; if ( buflen == - 1 ) buflen = 0 ; buflen = MIN ( buflen , buf_size ) ; bytes_consumed = buflen + u4_length_of_start_code ; ps_dec_op -> u4_num_bytes_consumed += bytes_consumed ; { UWORD8 u1_firstbyte , u1_nal_ref_idc ; if ( ps_dec -> i4_app_skip_mode == IVD_SKIP_B ) { u1_firstbyte = * ( pu1_buf + u4_length_of_start_code ) ; u1_nal_ref_idc = ( UWORD8 ) ( NAL_REF_IDC ( u1_firstbyte ) ) ; if ( u1_nal_ref_idc == 0 ) { cur_slice_is_nonref = 1 ; continue ; } else { if ( 1 == cur_slice_is_nonref ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; ps_dec_op -> e_pic_type = IV_B_FRAME ; ps_dec_op -> u4_error_code = IVD_DEC_FRM_SKIPPED ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec_op -> u4_size = sizeof ( ivd_video_decode_op_t ) ; ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return ( IV_FAIL ) ; } } } } if ( buflen ) { memcpy ( pu1_bitstrm_buf , pu1_buf + u4_length_of_start_code , buflen ) ; if ( ( buflen + 8 ) < buf_size ) { memset ( pu1_bitstrm_buf + buflen , 0 , 8 ) ; } u4_first_start_code_found = 1 ; } else { if ( u4_first_start_code_found == 0 ) { ps_dec -> i4_error_code = ERROR_START_CODE_NOT_FOUND ; ps_dec_op -> u4_error_code |= 1 << IVD_INSUFFICIENTDATA ; if ( ps_dec -> u4_pic_buf_got == 0 ) { ih264d_fill_output_struct_from_context ( ps_dec , ps_dec_op ) ; ps_dec_op -> u4_error_code = ps_dec -> i4_error_code ; ps_dec_op -> u4_frame_decoded_flag = 0 ; return ( IV_FAIL ) ; } else { ps_dec -> u1_pic_decode_done = 1 ; continue ; } } else { frame_data_left = 0 ; continue ; } } ps_dec -> u4_return_to_app = 0 ; ret = ih264d_parse_nal_unit ( dec_hdl , ps_dec_op , pu1_bitstrm_buf , buflen ) ; if ( ret != OK ) { UWORD32 error = ih264d_map_error ( ret ) ; ps_dec_op -> u4_error_code = error | ret ; api_ret_value = IV_FAIL ; if ( ( ret == IVD_RES_CHANGED ) || ( ret == IVD_MEM_ALLOC_FAILED ) || ( ret == ERROR_UNAVAIL_PICBUF_T )  || ( ret == ERROR_UNAVAIL_MVBUF_T ) )  { break ; } if ( ( ret == ERROR_INCOMPLETE_FRAME ) || ( ret == ERROR_DANGLING_FIELD_IN_PIC ) ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; api_ret_value = IV_FAIL ; break ; } if ( ret == ERROR_IN_LAST_SLICE_OF_PIC ) { api_ret_value = IV_FAIL ; break ; } } if ( ps_dec -> u4_return_to_app ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; ps_dec_op -> u4_error_code = IVD_DEC_FRM_SKIPPED ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec_op -> u4_size = sizeof ( ivd_video_decode_op_t ) ; ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return ( IV_FAIL ) ; } header_data_left = ( ( ps_dec -> i4_decode_header == 1 ) && ( ps_dec -> i4_header_decoded != 3 ) && ( ps_dec_op -> u4_num_bytes_consumed < ps_dec_ip -> u4_num_Bytes ) ) ; frame_data_left = ( ( ( ps_dec -> i4_decode_header == 0 ) && ( ( ps_dec -> u1_pic_decode_done == 0 ) || ( u4_next_is_aud == 1 ) ) ) && ( ps_dec_op -> u4_num_bytes_consumed < ps_dec_ip -> u4_num_Bytes ) ) ; } while ( ( header_data_left == 1 ) || ( frame_data_left == 1 ) ) ; if ( ( ps_dec -> u4_slice_start_code_found == 1 ) && ( ret != IVD_MEM_ALLOC_FAILED ) && ps_dec -> u2_total_mbs_coded < ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { WORD32 num_mb_skipped ; WORD32 prev_slice_err ; pocstruct_t temp_poc ; WORD32 ret1 ; num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; if ( ps_dec -> u4_first_slice_in_pic && ( ps_dec -> u4_pic_buf_got == 0 ) ) prev_slice_err = 1 ; else prev_slice_err = 2 ; ret1 = ih264d_mark_err_slice_skip ( ps_dec , num_mb_skipped , ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL , ps_dec -> ps_cur_slice -> u2_frame_num , & temp_poc , prev_slice_err ) ; if ( ( ret1 == ERROR_UNAVAIL_PICBUF_T ) || ( ret1 == ERROR_UNAVAIL_MVBUF_T ) ) { return IV_FAIL ; } } if ( ( ret == IVD_RES_CHANGED ) || ( ret == IVD_MEM_ALLOC_FAILED ) || ( ret == ERROR_UNAVAIL_PICBUF_T )  || ( ret == ERROR_UNAVAIL_MVBUF_T ) )  { ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } if ( ret == IVD_RES_CHANGED ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; } return IV_FAIL ; } if ( ps_dec -> u1_separate_parse ) { if ( ps_dec -> u4_num_cores == 2 ) { if ( ( ps_dec -> u4_nmb_deblk == 0 ) && ( ps_dec -> u4_start_recon_deblk == 1 ) && ( ps_dec -> ps_cur_sps -> u1_mb_aff_flag == 0 ) ) { UWORD32 u4_num_mbs , u4_max_addr ; tfr_ctxt_t s_tfr_ctxt ; tfr_ctxt_t * ps_tfr_cxt = & s_tfr_ctxt ; pad_mgr_t * ps_pad_mgr = & ps_dec -> s_pad_mgr ; u4_max_addr = ( ps_dec -> u2_frm_wd_in_mbs * ps_dec -> u2_frm_ht_in_mbs ) - 1 ; ps_dec -> u4_cur_bs_mb_num = u4_max_addr + 1 ; ih264d_init_deblk_tfr_ctxt ( ps_dec , ps_pad_mgr , ps_tfr_cxt , ps_dec -> u2_frm_wd_in_mbs , 0 ) ; u4_num_mbs = u4_max_addr - ps_dec -> u4_cur_deblk_mb_num + 1 ; DEBUG_PERF_PRINTF ( ""mbs<S2SV_blank>left<S2SV_blank>for<S2SV_blank>deblocking=<S2SV_blank>%d<S2SV_blank>\\n"" , u4_num_mbs ) ; if ( u4_num_mbs != 0 ) ih264d_check_mb_map_deblk ( ps_dec , u4_num_mbs , ps_tfr_cxt , 1 ) ; ps_dec -> u4_start_recon_deblk = 0 ; } } ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } } DATA_SYNC ( ) ; if ( ( ps_dec_op -> u4_error_code & 0xff ) != ERROR_DYNAMIC_RESOLUTION_NOT_SUPPORTED ) { ps_dec_op -> u4_pic_wd = ( UWORD32 ) ps_dec -> u2_disp_width ; ps_dec_op -> u4_pic_ht = ( UWORD32 ) ps_dec -> u2_disp_height ; } if ( ps_dec -> i4_header_decoded != 3 ) { ps_dec_op -> u4_error_code |= ( 1 << IVD_INSUFFICIENTDATA ) ; } if ( ps_dec -> i4_decode_header == 1 && ps_dec -> i4_header_decoded != 3 ) { ps_dec_op -> u4_error_code |= ( 1 << IVD_INSUFFICIENTDATA ) ; } if ( ps_dec -> u4_prev_nal_skipped ) { ps_dec_op -> u4_error_code = IVD_DEC_FRM_SKIPPED ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec_op -> u4_size = sizeof ( ivd_video_decode_op_t ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return ( IV_FAIL ) ; } if ( ( ps_dec -> u4_slice_start_code_found == 1 ) && ( ERROR_DANGLING_FIELD_IN_PIC != i4_err_status ) ) { if ( ps_dec -> ps_cur_slice -> u1_field_pic_flag ) { if ( 1 == ps_dec -> ps_cur_slice -> u1_bottom_field_flag ) { ps_dec -> u1_top_bottom_decoded |= BOT_FIELD_ONLY ; } else { ps_dec -> u1_top_bottom_decoded |= TOP_FIELD_ONLY ; } } if ( ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) == 0 ) { ret = ih264d_deblock_display ( ps_dec ) ; if ( ret != 0 ) { return IV_FAIL ; } } if ( ps_dec -> i4_header_decoded == 3 ) { ps_dec -> u2_total_mbs_coded = ps_dec -> ps_cur_sps -> u2_max_mb_addr + 1 ; } if ( ps_dec -> ps_cur_slice -> u1_nal_unit_type == IDR_SLICE_NAL ) { ps_dec -> i4_frametype = IV_IDR_FRAME ; } else if ( ps_dec -> i4_pic_type == B_SLICE ) { ps_dec -> i4_frametype = IV_B_FRAME ; } else if ( ps_dec -> i4_pic_type == P_SLICE ) { ps_dec -> i4_frametype = IV_P_FRAME ; } else if ( ps_dec -> i4_pic_type == I_SLICE ) { ps_dec -> i4_frametype = IV_I_FRAME ; } else { H264_DEC_DEBUG_PRINT ( ""Shouldn\'t<S2SV_blank>come<S2SV_blank>here\\n"" ) ; } ps_dec -> i4_content_type = ps_dec -> ps_cur_slice -> u1_field_pic_flag ; ps_dec -> u4_total_frames_decoded = ps_dec -> u4_total_frames_decoded + 2 ; ps_dec -> u4_total_frames_decoded = ps_dec -> u4_total_frames_decoded - ps_dec -> ps_cur_slice -> u1_field_pic_flag ; } if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } { if ( ( IVD_DECODE_FRAME_OUT == ps_dec -> e_frm_out_mode ) && ps_dec -> u1_init_dec_flag ) { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 == ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = 0 ; ps_dec -> u4_output_present = 1 ; } } ih264d_fill_output_struct_from_context ( ps_dec , ps_dec_op ) ; if ( ps_dec -> u4_output_present && ( ps_dec -> u4_fmt_conv_cur_row < ps_dec -> s_disp_frame_info . u4_y_ht ) ) { ps_dec -> u4_fmt_conv_num_rows = ps_dec -> s_disp_frame_info . u4_y_ht - ps_dec -> u4_fmt_conv_cur_row ; ih264d_format_convert ( ps_dec , & ( ps_dec -> s_disp_op ) , ps_dec -> u4_fmt_conv_cur_row , ps_dec -> u4_fmt_conv_num_rows ) ; ps_dec -> u4_fmt_conv_cur_row += ps_dec -> u4_fmt_conv_num_rows ; } ih264d_release_display_field ( ps_dec , & ( ps_dec -> s_disp_op ) ) ; } if ( ps_dec -> i4_decode_header == 1 && ( ps_dec -> i4_header_decoded & 1 ) == 1 ) { ps_dec_op -> u4_progressive_frame_flag = 1 ; if ( ( NULL != ps_dec -> ps_cur_sps ) && ( 1 == ( ps_dec -> ps_cur_sps -> u1_is_valid ) ) ) { if ( ( 0 == ps_dec -> ps_sps -> u1_frame_mbs_only_flag ) && ( 0 == ps_dec -> ps_sps -> u1_mb_aff_flag ) ) ps_dec_op -> u4_progressive_frame_flag = 0 ; } } DATA_SYNC ( ) ; H264_DEC_DEBUG_PRINT ( ""The<S2SV_blank>num<S2SV_blank>bytes<S2SV_blank>consumed:<S2SV_blank>%d\\n"" , ps_dec_op -> u4_num_bytes_consumed ) ; return api_ret_value ; }",if ( ( ret == IVD_RES_CHANGED ) || ( ret == IVD_MEM_ALLOC_FAILED ) || ( ret == ERROR_UNAVAIL_PICBUF_T ) || ( ret == ERROR_UNAVAIL_MVBUF_T ) || ( ret == ERROR_INV_SPS_PPS_T ) ) {ps_dec -> u4_slice_start_code_found = 0 ;,549
746,"buggy line: if ( ( ret1 == ERROR_UNAVAIL_PICBUF_T ) || ( ret1 == ERROR_UNAVAIL_MVBUF_T ) ) {if ( ( ret == IVD_RES_CHANGED ) || ( ret == IVD_MEM_ALLOC_FAILED ) || ( ret == ERROR_UNAVAIL_PICBUF_T )  || ( ret == ERROR_UNAVAIL_MVBUF_T ) )  {cwe id:CWE-172context: WORD32 ih264d_video_decode ( iv_obj_t * dec_hdl , void * pv_api_ip , void * pv_api_op ) { dec_struct_t * ps_dec = ( dec_struct_t * ) ( dec_hdl -> pv_codec_handle ) ; WORD32 i4_err_status = 0 ; UWORD8 * pu1_buf = NULL ; WORD32 buflen ; UWORD32 u4_max_ofst , u4_length_of_start_code = 0 ; UWORD32 bytes_consumed = 0 ; UWORD32 cur_slice_is_nonref = 0 ; UWORD32 u4_next_is_aud ; UWORD32 u4_first_start_code_found = 0 ; WORD32 ret = 0 , api_ret_value = IV_SUCCESS ; WORD32 header_data_left = 0 , frame_data_left = 0 ; UWORD8 * pu1_bitstrm_buf ; ivd_video_decode_ip_t * ps_dec_ip ; ivd_video_decode_op_t * ps_dec_op ; ithread_set_name ( ( void * ) ""Parse_thread"" ) ; ps_dec_ip = ( ivd_video_decode_ip_t * ) pv_api_ip ; ps_dec_op = ( ivd_video_decode_op_t * ) pv_api_op ; { UWORD32 u4_size ; u4_size = ps_dec_op -> u4_size ; memset ( ps_dec_op , 0 , sizeof ( ivd_video_decode_op_t ) ) ; ps_dec_op -> u4_size = u4_size ; } ps_dec -> pv_dec_out = ps_dec_op ; if ( ps_dec -> init_done != 1 ) { return IV_FAIL ; } DATA_SYNC ( ) ; if ( 0 == ps_dec -> u1_flushfrm ) { if ( ps_dec_ip -> pv_stream_buffer == NULL ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL ; return IV_FAIL ; } if ( ps_dec_ip -> u4_num_Bytes <= 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DEC_NUMBYTES_INV ; return IV_FAIL ; } } ps_dec -> u1_pic_decode_done = 0 ; ps_dec_op -> u4_num_bytes_consumed = 0 ; ps_dec -> ps_out_buffer = NULL ; if ( ps_dec_ip -> u4_size >= offsetof ( ivd_video_decode_ip_t , s_out_buffer ) ) ps_dec -> ps_out_buffer = & ps_dec_ip -> s_out_buffer ; ps_dec -> u4_fmt_conv_cur_row = 0 ; ps_dec -> u4_output_present = 0 ; ps_dec -> s_disp_op . u4_error_code = 1 ; ps_dec -> u4_fmt_conv_num_rows = FMT_CONV_NUM_ROWS ; if ( 0 == ps_dec -> u4_share_disp_buf && ps_dec -> i4_decode_header == 0 ) { UWORD32 i ; if ( ps_dec -> ps_out_buffer -> u4_num_bufs == 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS ; return IV_FAIL ; } for ( i = 0 ; i < ps_dec -> ps_out_buffer -> u4_num_bufs ; i ++ ) { if ( ps_dec -> ps_out_buffer -> pu1_bufs [ i ] == NULL ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL ; return IV_FAIL ; } if ( ps_dec -> ps_out_buffer -> u4_min_out_buf_size [ i ] == 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUF_SIZE ; return IV_FAIL ; } } } if ( ps_dec -> u4_total_frames_decoded >= NUM_FRAMES_LIMIT ) { ps_dec_op -> u4_error_code = ERROR_FRAME_LIMIT_OVER ; return IV_FAIL ; } ps_dec -> u4_ts = ps_dec_ip -> u4_ts ; ps_dec_op -> u4_error_code = 0 ; ps_dec_op -> e_pic_type = - 1 ; ps_dec_op -> u4_output_present = 0 ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec -> i4_frametype = - 1 ; ps_dec -> i4_content_type = - 1 ; { if ( ( TOP_FIELD_ONLY | BOT_FIELD_ONLY ) == ps_dec -> u1_top_bottom_decoded ) { ps_dec -> u1_top_bottom_decoded = 0 ; } } ps_dec -> u4_slice_start_code_found = 0 ; if ( ps_dec -> u1_init_dec_flag == 1 && ps_dec -> u4_share_disp_buf == 1 && ps_dec -> u1_flushfrm == 0 ) { UWORD32 i ; WORD32 disp_avail = 0 , free_id ; for ( i = 0 ; i < ps_dec -> u1_pic_bufs ; i ++ ) { if ( 0 == ps_dec -> u4_disp_buf_mapping [ i ] || 1 == ps_dec -> u4_disp_buf_to_be_freed [ i ] ) { disp_avail = 1 ; break ; } } if ( 0 == disp_avail ) { ps_dec_op -> u4_error_code = IVD_DEC_REF_BUF_NULL ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; return ( IV_FAIL ) ; } while ( 1 ) { pic_buffer_t * ps_pic_buf ; ps_pic_buf = ( pic_buffer_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , & free_id ) ; if ( ps_pic_buf == NULL ) { UWORD32 i , display_queued = 0 ; for ( i = 0 ; i < ( MAX_DISP_BUFS_NEW ) ; i ++ ) { if ( 0 != ps_dec -> u4_disp_buf_mapping [ i ] ) { display_queued = 1 ; break ; } } if ( 1 == display_queued ) { ps_dec_op -> u4_error_code = IVD_DEC_REF_BUF_NULL ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; return ( IV_FAIL ) ; } } else { if ( 1 == ps_dec -> u4_disp_buf_mapping [ free_id ] ) { ih264_buf_mgr_set_status ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , free_id , BUF_MGR_IO ) ; } else { ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , free_id , BUF_MGR_IO ) ; break ; } } } } if ( ps_dec -> u1_flushfrm && ps_dec -> u1_init_dec_flag ) { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 == ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = 0 ; ps_dec -> u4_fmt_conv_num_rows = ps_dec -> s_disp_frame_info . u4_y_ht ; ih264d_format_convert ( ps_dec , & ( ps_dec -> s_disp_op ) , ps_dec -> u4_fmt_conv_cur_row , ps_dec -> u4_fmt_conv_num_rows ) ; ps_dec -> u4_fmt_conv_cur_row += ps_dec -> u4_fmt_conv_num_rows ; ps_dec -> u4_output_present = 1 ; } ih264d_release_display_field ( ps_dec , & ( ps_dec -> s_disp_op ) ) ; ps_dec_op -> u4_pic_wd = ( UWORD32 ) ps_dec -> u2_disp_width ; ps_dec_op -> u4_pic_ht = ( UWORD32 ) ps_dec -> u2_disp_height ; ps_dec_op -> u4_new_seq = 0 ; ps_dec_op -> u4_output_present = ps_dec -> u4_output_present ; ps_dec_op -> u4_progressive_frame_flag = ps_dec -> s_disp_op . u4_progressive_frame_flag ; ps_dec_op -> e_output_format = ps_dec -> s_disp_op . e_output_format ; ps_dec_op -> s_disp_frm_buf = ps_dec -> s_disp_op . s_disp_frm_buf ; ps_dec_op -> e4_fld_type = ps_dec -> s_disp_op . e4_fld_type ; ps_dec_op -> u4_ts = ps_dec -> s_disp_op . u4_ts ; ps_dec_op -> u4_disp_buf_id = ps_dec -> s_disp_op . u4_disp_buf_id ; ps_dec_op -> u4_is_ref_flag = - 1 ; ps_dec_op -> e_pic_type = IV_NA_FRAME ; ps_dec_op -> u4_frame_decoded_flag = 0 ; if ( 0 == ps_dec -> s_disp_op . u4_error_code ) { return ( IV_SUCCESS ) ; } else return ( IV_FAIL ) ; } if ( ps_dec -> u1_res_changed == 1 ) { ih264d_init_decoder ( ps_dec ) ; } ps_dec -> u4_prev_nal_skipped = 0 ; ps_dec -> u2_cur_mb_addr = 0 ; ps_dec -> u2_total_mbs_coded = 0 ; ps_dec -> u2_cur_slice_num = 0 ; ps_dec -> cur_dec_mb_num = 0 ; ps_dec -> cur_recon_mb_num = 0 ; ps_dec -> u4_first_slice_in_pic = 2 ; ps_dec -> u1_slice_header_done = 0 ; ps_dec -> u1_dangling_field = 0 ; ps_dec -> u4_dec_thread_created = 0 ; ps_dec -> u4_bs_deblk_thread_created = 0 ; ps_dec -> u4_cur_bs_mb_num = 0 ; ps_dec -> u4_start_recon_deblk = 0 ; DEBUG_THREADS_PRINTF ( ""<S2SV_blank>Starting<S2SV_blank>process<S2SV_blank>call\\n"" ) ; ps_dec -> u4_pic_buf_got = 0 ; do { WORD32 buf_size ; pu1_buf = ( UWORD8 * ) ps_dec_ip -> pv_stream_buffer + ps_dec_op -> u4_num_bytes_consumed ; u4_max_ofst = ps_dec_ip -> u4_num_Bytes - ps_dec_op -> u4_num_bytes_consumed ; if ( ( NULL == ps_dec -> pu1_bits_buf_dynamic ) && ( ps_dec -> i4_header_decoded & 1 ) ) { WORD32 size ; void * pv_buf ; void * pv_mem_ctxt = ps_dec -> pv_mem_ctxt ; size = MAX ( 256000 , ps_dec -> u2_pic_wd * ps_dec -> u2_pic_ht * 3 / 2 ) ; pv_buf = ps_dec -> pf_aligned_alloc ( pv_mem_ctxt , 128 , size ) ; RETURN_IF ( ( NULL == pv_buf ) , IV_FAIL ) ; ps_dec -> pu1_bits_buf_dynamic = pv_buf ; ps_dec -> u4_dynamic_bits_buf_size = size ; } if ( ps_dec -> pu1_bits_buf_dynamic ) { pu1_bitstrm_buf = ps_dec -> pu1_bits_buf_dynamic ; buf_size = ps_dec -> u4_dynamic_bits_buf_size ; } else { pu1_bitstrm_buf = ps_dec -> pu1_bits_buf_static ; buf_size = ps_dec -> u4_static_bits_buf_size ; } u4_next_is_aud = 0 ; buflen = ih264d_find_start_code ( pu1_buf , 0 , u4_max_ofst , & u4_length_of_start_code , & u4_next_is_aud ) ; if ( buflen == - 1 ) buflen = 0 ; buflen = MIN ( buflen , buf_size ) ; bytes_consumed = buflen + u4_length_of_start_code ; ps_dec_op -> u4_num_bytes_consumed += bytes_consumed ; { UWORD8 u1_firstbyte , u1_nal_ref_idc ; if ( ps_dec -> i4_app_skip_mode == IVD_SKIP_B ) { u1_firstbyte = * ( pu1_buf + u4_length_of_start_code ) ; u1_nal_ref_idc = ( UWORD8 ) ( NAL_REF_IDC ( u1_firstbyte ) ) ; if ( u1_nal_ref_idc == 0 ) { cur_slice_is_nonref = 1 ; continue ; } else { if ( 1 == cur_slice_is_nonref ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; ps_dec_op -> e_pic_type = IV_B_FRAME ; ps_dec_op -> u4_error_code = IVD_DEC_FRM_SKIPPED ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec_op -> u4_size = sizeof ( ivd_video_decode_op_t ) ; ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return ( IV_FAIL ) ; } } } } if ( buflen ) { memcpy ( pu1_bitstrm_buf , pu1_buf + u4_length_of_start_code , buflen ) ; if ( ( buflen + 8 ) < buf_size ) { memset ( pu1_bitstrm_buf + buflen , 0 , 8 ) ; } u4_first_start_code_found = 1 ; } else { if ( u4_first_start_code_found == 0 ) { ps_dec -> i4_error_code = ERROR_START_CODE_NOT_FOUND ; ps_dec_op -> u4_error_code |= 1 << IVD_INSUFFICIENTDATA ; if ( ps_dec -> u4_pic_buf_got == 0 ) { ih264d_fill_output_struct_from_context ( ps_dec , ps_dec_op ) ; ps_dec_op -> u4_error_code = ps_dec -> i4_error_code ; ps_dec_op -> u4_frame_decoded_flag = 0 ; return ( IV_FAIL ) ; } else { ps_dec -> u1_pic_decode_done = 1 ; continue ; } } else { frame_data_left = 0 ; continue ; } } ps_dec -> u4_return_to_app = 0 ; ret = ih264d_parse_nal_unit ( dec_hdl , ps_dec_op , pu1_bitstrm_buf , buflen ) ; if ( ret != OK ) { UWORD32 error = ih264d_map_error ( ret ) ; ps_dec_op -> u4_error_code = error | ret ; api_ret_value = IV_FAIL ; if ( ( ret == IVD_RES_CHANGED ) || ( ret == IVD_MEM_ALLOC_FAILED ) || ( ret == ERROR_UNAVAIL_PICBUF_T )  || ( ret == ERROR_UNAVAIL_MVBUF_T ) )  { break ; } if ( ( ret == ERROR_INCOMPLETE_FRAME ) || ( ret == ERROR_DANGLING_FIELD_IN_PIC ) ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; api_ret_value = IV_FAIL ; break ; } if ( ret == ERROR_IN_LAST_SLICE_OF_PIC ) { api_ret_value = IV_FAIL ; break ; } } if ( ps_dec -> u4_return_to_app ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; ps_dec_op -> u4_error_code = IVD_DEC_FRM_SKIPPED ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec_op -> u4_size = sizeof ( ivd_video_decode_op_t ) ; ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return ( IV_FAIL ) ; } header_data_left = ( ( ps_dec -> i4_decode_header == 1 ) && ( ps_dec -> i4_header_decoded != 3 ) && ( ps_dec_op -> u4_num_bytes_consumed < ps_dec_ip -> u4_num_Bytes ) ) ; frame_data_left = ( ( ( ps_dec -> i4_decode_header == 0 ) && ( ( ps_dec -> u1_pic_decode_done == 0 ) || ( u4_next_is_aud == 1 ) ) ) && ( ps_dec_op -> u4_num_bytes_consumed < ps_dec_ip -> u4_num_Bytes ) ) ; } while ( ( header_data_left == 1 ) || ( frame_data_left == 1 ) ) ; if ( ( ps_dec -> u4_slice_start_code_found == 1 ) && ( ret != IVD_MEM_ALLOC_FAILED ) && ps_dec -> u2_total_mbs_coded < ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { WORD32 num_mb_skipped ; WORD32 prev_slice_err ; pocstruct_t temp_poc ; WORD32 ret1 ; num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; if ( ps_dec -> u4_first_slice_in_pic && ( ps_dec -> u4_pic_buf_got == 0 ) ) prev_slice_err = 1 ; else prev_slice_err = 2 ; ret1 = ih264d_mark_err_slice_skip ( ps_dec , num_mb_skipped , ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL , ps_dec -> ps_cur_slice -> u2_frame_num , & temp_poc , prev_slice_err ) ; if ( ( ret1 == ERROR_UNAVAIL_PICBUF_T ) || ( ret1 == ERROR_UNAVAIL_MVBUF_T ) ) { return IV_FAIL ; } } if ( ( ret == IVD_RES_CHANGED ) || ( ret == IVD_MEM_ALLOC_FAILED ) || ( ret == ERROR_UNAVAIL_PICBUF_T )  || ( ret == ERROR_UNAVAIL_MVBUF_T ) )  { ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } if ( ret == IVD_RES_CHANGED ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; } return IV_FAIL ; } if ( ps_dec -> u1_separate_parse ) { if ( ps_dec -> u4_num_cores == 2 ) { if ( ( ps_dec -> u4_nmb_deblk == 0 ) && ( ps_dec -> u4_start_recon_deblk == 1 ) && ( ps_dec -> ps_cur_sps -> u1_mb_aff_flag == 0 ) ) { UWORD32 u4_num_mbs , u4_max_addr ; tfr_ctxt_t s_tfr_ctxt ; tfr_ctxt_t * ps_tfr_cxt = & s_tfr_ctxt ; pad_mgr_t * ps_pad_mgr = & ps_dec -> s_pad_mgr ; u4_max_addr = ( ps_dec -> u2_frm_wd_in_mbs * ps_dec -> u2_frm_ht_in_mbs ) - 1 ; ps_dec -> u4_cur_bs_mb_num = u4_max_addr + 1 ; ih264d_init_deblk_tfr_ctxt ( ps_dec , ps_pad_mgr , ps_tfr_cxt , ps_dec -> u2_frm_wd_in_mbs , 0 ) ; u4_num_mbs = u4_max_addr - ps_dec -> u4_cur_deblk_mb_num + 1 ; DEBUG_PERF_PRINTF ( ""mbs<S2SV_blank>left<S2SV_blank>for<S2SV_blank>deblocking=<S2SV_blank>%d<S2SV_blank>\\n"" , u4_num_mbs ) ; if ( u4_num_mbs != 0 ) ih264d_check_mb_map_deblk ( ps_dec , u4_num_mbs , ps_tfr_cxt , 1 ) ; ps_dec -> u4_start_recon_deblk = 0 ; } } ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } } DATA_SYNC ( ) ; if ( ( ps_dec_op -> u4_error_code & 0xff ) != ERROR_DYNAMIC_RESOLUTION_NOT_SUPPORTED ) { ps_dec_op -> u4_pic_wd = ( UWORD32 ) ps_dec -> u2_disp_width ; ps_dec_op -> u4_pic_ht = ( UWORD32 ) ps_dec -> u2_disp_height ; } if ( ps_dec -> i4_header_decoded != 3 ) { ps_dec_op -> u4_error_code |= ( 1 << IVD_INSUFFICIENTDATA ) ; } if ( ps_dec -> i4_decode_header == 1 && ps_dec -> i4_header_decoded != 3 ) { ps_dec_op -> u4_error_code |= ( 1 << IVD_INSUFFICIENTDATA ) ; } if ( ps_dec -> u4_prev_nal_skipped ) { ps_dec_op -> u4_error_code = IVD_DEC_FRM_SKIPPED ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec_op -> u4_size = sizeof ( ivd_video_decode_op_t ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return ( IV_FAIL ) ; } if ( ( ps_dec -> u4_slice_start_code_found == 1 ) && ( ERROR_DANGLING_FIELD_IN_PIC != i4_err_status ) ) { if ( ps_dec -> ps_cur_slice -> u1_field_pic_flag ) { if ( 1 == ps_dec -> ps_cur_slice -> u1_bottom_field_flag ) { ps_dec -> u1_top_bottom_decoded |= BOT_FIELD_ONLY ; } else { ps_dec -> u1_top_bottom_decoded |= TOP_FIELD_ONLY ; } } if ( ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) == 0 ) { ret = ih264d_deblock_display ( ps_dec ) ; if ( ret != 0 ) { return IV_FAIL ; } } if ( ps_dec -> i4_header_decoded == 3 ) { ps_dec -> u2_total_mbs_coded = ps_dec -> ps_cur_sps -> u2_max_mb_addr + 1 ; } if ( ps_dec -> ps_cur_slice -> u1_nal_unit_type == IDR_SLICE_NAL ) { ps_dec -> i4_frametype = IV_IDR_FRAME ; } else if ( ps_dec -> i4_pic_type == B_SLICE ) { ps_dec -> i4_frametype = IV_B_FRAME ; } else if ( ps_dec -> i4_pic_type == P_SLICE ) { ps_dec -> i4_frametype = IV_P_FRAME ; } else if ( ps_dec -> i4_pic_type == I_SLICE ) { ps_dec -> i4_frametype = IV_I_FRAME ; } else { H264_DEC_DEBUG_PRINT ( ""Shouldn\'t<S2SV_blank>come<S2SV_blank>here\\n"" ) ; } ps_dec -> i4_content_type = ps_dec -> ps_cur_slice -> u1_field_pic_flag ; ps_dec -> u4_total_frames_decoded = ps_dec -> u4_total_frames_decoded + 2 ; ps_dec -> u4_total_frames_decoded = ps_dec -> u4_total_frames_decoded - ps_dec -> ps_cur_slice -> u1_field_pic_flag ; } if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } { if ( ( IVD_DECODE_FRAME_OUT == ps_dec -> e_frm_out_mode ) && ps_dec -> u1_init_dec_flag ) { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 == ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = 0 ; ps_dec -> u4_output_present = 1 ; } } ih264d_fill_output_struct_from_context ( ps_dec , ps_dec_op ) ; if ( ps_dec -> u4_output_present && ( ps_dec -> u4_fmt_conv_cur_row < ps_dec -> s_disp_frame_info . u4_y_ht ) ) { ps_dec -> u4_fmt_conv_num_rows = ps_dec -> s_disp_frame_info . u4_y_ht - ps_dec -> u4_fmt_conv_cur_row ; ih264d_format_convert ( ps_dec , & ( ps_dec -> s_disp_op ) , ps_dec -> u4_fmt_conv_cur_row , ps_dec -> u4_fmt_conv_num_rows ) ; ps_dec -> u4_fmt_conv_cur_row += ps_dec -> u4_fmt_conv_num_rows ; } ih264d_release_display_field ( ps_dec , & ( ps_dec -> s_disp_op ) ) ; } if ( ps_dec -> i4_decode_header == 1 && ( ps_dec -> i4_header_decoded & 1 ) == 1 ) { ps_dec_op -> u4_progressive_frame_flag = 1 ; if ( ( NULL != ps_dec -> ps_cur_sps ) && ( 1 == ( ps_dec -> ps_cur_sps -> u1_is_valid ) ) ) { if ( ( 0 == ps_dec -> ps_sps -> u1_frame_mbs_only_flag ) && ( 0 == ps_dec -> ps_sps -> u1_mb_aff_flag ) ) ps_dec_op -> u4_progressive_frame_flag = 0 ; } } DATA_SYNC ( ) ; H264_DEC_DEBUG_PRINT ( ""The<S2SV_blank>num<S2SV_blank>bytes<S2SV_blank>consumed:<S2SV_blank>%d\\n"" , ps_dec_op -> u4_num_bytes_consumed ) ; return api_ret_value ; }",if ( ( ret1 == ERROR_UNAVAIL_PICBUF_T ) || ( ret1 == ERROR_UNAVAIL_MVBUF_T ) || ( ret == ERROR_INV_SPS_PPS_T ) ) {if ( ( ret == IVD_RES_CHANGED ) || ( ret == IVD_MEM_ALLOC_FAILED ) || ( ret == ERROR_UNAVAIL_PICBUF_T ) || ( ret == ERROR_UNAVAIL_MVBUF_T ) ) {,549
747,"buggy line: dst_known = tnum_is_const ( dst_reg -> var_off ) ;switch ( opcode ) {cwe id:CWE-190context: static int adjust_scalar_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , struct bpf_reg_state * dst_reg , struct bpf_reg_state src_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; bool src_known , dst_known ; s64 smin_val , smax_val ; u64 umin_val , umax_val ; u64 insn_bitness = ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) ? 64 : 32 ; smin_val = src_reg . smin_value ; smax_val = src_reg . smax_value ; umin_val = src_reg . umin_value ; umax_val = src_reg . umax_value ; src_known = tnum_is_const ( src_reg . var_off ) ;  dst_known = tnum_is_const ( dst_reg -> var_off ) ;  switch ( opcode ) { case BPF_ADD : if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value += smin_val ; dst_reg -> smax_value += smax_val ; } if ( dst_reg -> umin_value + umin_val < umin_val || dst_reg -> umax_value + umax_val < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value += umin_val ; dst_reg -> umax_value += umax_val ; } dst_reg -> var_off = tnum_add ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_SUB : if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value -= smax_val ; dst_reg -> smax_value -= smin_val ; } if ( dst_reg -> umin_value < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value -= umax_val ; dst_reg -> umax_value -= umin_val ; } dst_reg -> var_off = tnum_sub ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_MUL : dst_reg -> var_off = tnum_mul ( dst_reg -> var_off , src_reg . var_off ) ; if ( smin_val < 0 || dst_reg -> smin_value < 0 ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } if ( umax_val > U32_MAX || dst_reg -> umax_value > U32_MAX ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } dst_reg -> umin_value *= umin_val ; dst_reg -> umax_value *= umax_val ; if ( dst_reg -> umax_value > S64_MAX ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } break ; case BPF_AND : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value & src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_and ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = dst_reg -> var_off . value ; dst_reg -> umax_value = min ( dst_reg -> umax_value , umax_val ) ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_OR : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value | src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_or ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = max ( dst_reg -> umin_value , umin_val ) ; dst_reg -> umax_value = dst_reg -> var_off . value | dst_reg -> var_off . mask ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_LSH : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( dst_reg -> umax_value > 1ULL << ( 63 - umax_val ) ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value <<= umin_val ; dst_reg -> umax_value <<= umax_val ; } if ( src_known ) dst_reg -> var_off = tnum_lshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_lshift ( tnum_unknown , umin_val ) ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_RSH : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( src_known ) dst_reg -> var_off = tnum_rshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_rshift ( tnum_unknown , umin_val ) ; dst_reg -> umin_value >>= umax_val ; dst_reg -> umax_value >>= umin_val ; __update_reg_bounds ( dst_reg ) ; break ; default : mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size ( & src_reg , 4 ) ; } __reg_deduce_bounds ( dst_reg ) ; __reg_bound_offset ( dst_reg ) ; return 0 ; }",if ( ! src_known && opcode != BPF_ADD && opcode != BPF_SUB && opcode != BPF_AND ) {__mark_reg_unknown ( dst_reg ) ;return 0 ;}dst_known = tnum_is_const ( dst_reg -> var_off ) ;switch ( opcode ) {,550
748,"buggy line: cwe id:CWE-264context: struct dentry * cifs_lookup ( struct inode * parent_dir_inode , struct dentry * direntry , struct nameidata * nd ) { int xid ; int rc = 0 ; __u32 oplock = enable_oplocks ? REQ_OPLOCK : 0 ; __u16 fileHandle = 0 ; bool posix_open = false ; struct cifs_sb_info * cifs_sb ; struct tcon_link * tlink ; struct cifs_tcon * pTcon ; struct cifsFileInfo * cfile ; struct inode * newInode = NULL ; char * full_path = NULL ; struct file * filp ; xid = GetXid ( ) ; cFYI ( 1 , ""parent<S2SV_blank>inode<S2SV_blank>=<S2SV_blank>0x%p<S2SV_blank>name<S2SV_blank>is:<S2SV_blank>%s<S2SV_blank>and<S2SV_blank>dentry<S2SV_blank>=<S2SV_blank>0x%p"" , parent_dir_inode , direntry -> d_name . name , direntry ) ; cifs_sb = CIFS_SB ( parent_dir_inode -> i_sb ) ; tlink = cifs_sb_tlink ( cifs_sb ) ; if ( IS_ERR ( tlink ) ) { FreeXid ( xid ) ; return ( struct dentry * ) tlink ; } pTcon = tlink_tcon ( tlink ) ; if ( ! ( cifs_sb -> mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS ) ) { int i ; for ( i = 0 ; i < direntry -> d_name . len ; i ++ ) if ( direntry -> d_name . name [ i ] == '\\\\' ) { cFYI ( 1 , ""Invalid<S2SV_blank>file<S2SV_blank>name"" ) ; rc = - EINVAL ; goto lookup_out ; } } if ( nd && ( nd -> flags & LOOKUP_EXCL ) ) { d_instantiate ( direntry , NULL ) ; rc = 0 ; goto lookup_out ; } full_path = build_path_from_dentry ( direntry ) ; if ( full_path == NULL ) { rc = - ENOMEM ; goto lookup_out ; } if ( direntry -> d_inode != NULL ) { cFYI ( 1 , ""non-NULL<S2SV_blank>inode<S2SV_blank>in<S2SV_blank>lookup"" ) ; } else { cFYI ( 1 , ""NULL<S2SV_blank>inode<S2SV_blank>in<S2SV_blank>lookup"" ) ; } cFYI ( 1 , ""Full<S2SV_blank>path:<S2SV_blank>%s<S2SV_blank>inode<S2SV_blank>=<S2SV_blank>0x%p"" , full_path , direntry -> d_inode ) ; if ( pTcon -> unix_ext ) { if ( nd && ! ( nd -> flags & LOOKUP_DIRECTORY ) && ( nd -> flags & LOOKUP_OPEN ) && ! pTcon -> broken_posix_open && ( nd -> intent . open . file -> f_flags & O_CREAT ) ) { rc = cifs_posix_open ( full_path , & newInode , parent_dir_inode -> i_sb , nd -> intent . open . create_mode , nd -> intent . open . file -> f_flags , & oplock , & fileHandle , xid ) ;  if ( ( rc == 0 ) || ( rc == - ENOENT ) )  posix_open = true ; else if ( ( rc == - EINVAL ) || ( rc != - EOPNOTSUPP ) ) pTcon -> broken_posix_open = true ; } if ( ! posix_open ) rc = cifs_get_inode_info_unix ( & newInode , full_path , parent_dir_inode -> i_sb , xid ) ; } else rc = cifs_get_inode_info ( & newInode , full_path , NULL , parent_dir_inode -> i_sb , xid , NULL ) ; if ( ( rc == 0 ) && ( newInode != NULL ) ) { d_add ( direntry , newInode ) ; if ( posix_open ) { filp = lookup_instantiate_filp ( nd , direntry , generic_file_open ) ; if ( IS_ERR ( filp ) ) { rc = PTR_ERR ( filp ) ; CIFSSMBClose ( xid , pTcon , fileHandle ) ; goto lookup_out ; } cfile = cifs_new_fileinfo ( fileHandle , filp , tlink , oplock ) ; if ( cfile == NULL ) { fput ( filp ) ; CIFSSMBClose ( xid , pTcon , fileHandle ) ; rc = - ENOMEM ; goto lookup_out ; } } renew_parental_timestamps ( direntry ) ; } else if ( rc == - ENOENT ) { rc = 0 ; direntry -> d_time = jiffies ; d_add ( direntry , NULL ) ; } else if ( rc != - EACCES ) { cERROR ( 1 , ""Unexpected<S2SV_blank>lookup<S2SV_blank>error<S2SV_blank>%d"" , rc ) ; } lookup_out : kfree ( full_path ) ; cifs_put_tlink ( tlink ) ; FreeXid ( xid ) ; return ERR_PTR ( rc ) ; }","switch ( rc ) {case 0 : if ( newInode && ! S_ISREG ( newInode -> i_mode ) ) {CIFSSMBClose ( xid , pTcon , fileHandle ) ;break ;}case - ENOENT : posix_open = true ;case - EOPNOTSUPP : break ;default : pTcon -> broken_posix_open = true ;}}if ( ! posix_open ) rc = cifs_get_inode_info_unix ( & newInode , full_path , parent_dir_inode -> i_sb , xid ) ;}else rc = cifs_get_inode_info ( & newInode , full_path , NULL , parent_dir_inode -> i_sb , xid , NULL ) ;",551
749,"buggy line: if ( ( rc == 0 ) || ( rc == - ENOENT ) )  posix_open = true ;else if ( ( rc == - EINVAL ) || ( rc != - EOPNOTSUPP ) ) pTcon -> broken_posix_open = true ;}if ( ! posix_open ) rc = cifs_get_inode_info_unix ( & newInode , full_path , parent_dir_inode -> i_sb , xid ) ;}else rc = cifs_get_inode_info ( & newInode , full_path , NULL , parent_dir_inode -> i_sb , xid , NULL ) ;cwe id:CWE-264context: struct dentry * cifs_lookup ( struct inode * parent_dir_inode , struct dentry * direntry , struct nameidata * nd ) { int xid ; int rc = 0 ; __u32 oplock = enable_oplocks ? REQ_OPLOCK : 0 ; __u16 fileHandle = 0 ; bool posix_open = false ; struct cifs_sb_info * cifs_sb ; struct tcon_link * tlink ; struct cifs_tcon * pTcon ; struct cifsFileInfo * cfile ; struct inode * newInode = NULL ; char * full_path = NULL ; struct file * filp ; xid = GetXid ( ) ; cFYI ( 1 , ""parent<S2SV_blank>inode<S2SV_blank>=<S2SV_blank>0x%p<S2SV_blank>name<S2SV_blank>is:<S2SV_blank>%s<S2SV_blank>and<S2SV_blank>dentry<S2SV_blank>=<S2SV_blank>0x%p"" , parent_dir_inode , direntry -> d_name . name , direntry ) ; cifs_sb = CIFS_SB ( parent_dir_inode -> i_sb ) ; tlink = cifs_sb_tlink ( cifs_sb ) ; if ( IS_ERR ( tlink ) ) { FreeXid ( xid ) ; return ( struct dentry * ) tlink ; } pTcon = tlink_tcon ( tlink ) ; if ( ! ( cifs_sb -> mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS ) ) { int i ; for ( i = 0 ; i < direntry -> d_name . len ; i ++ ) if ( direntry -> d_name . name [ i ] == '\\\\' ) { cFYI ( 1 , ""Invalid<S2SV_blank>file<S2SV_blank>name"" ) ; rc = - EINVAL ; goto lookup_out ; } } if ( nd && ( nd -> flags & LOOKUP_EXCL ) ) { d_instantiate ( direntry , NULL ) ; rc = 0 ; goto lookup_out ; } full_path = build_path_from_dentry ( direntry ) ; if ( full_path == NULL ) { rc = - ENOMEM ; goto lookup_out ; } if ( direntry -> d_inode != NULL ) { cFYI ( 1 , ""non-NULL<S2SV_blank>inode<S2SV_blank>in<S2SV_blank>lookup"" ) ; } else { cFYI ( 1 , ""NULL<S2SV_blank>inode<S2SV_blank>in<S2SV_blank>lookup"" ) ; } cFYI ( 1 , ""Full<S2SV_blank>path:<S2SV_blank>%s<S2SV_blank>inode<S2SV_blank>=<S2SV_blank>0x%p"" , full_path , direntry -> d_inode ) ; if ( pTcon -> unix_ext ) { if ( nd && ! ( nd -> flags & LOOKUP_DIRECTORY ) && ( nd -> flags & LOOKUP_OPEN ) && ! pTcon -> broken_posix_open && ( nd -> intent . open . file -> f_flags & O_CREAT ) ) { rc = cifs_posix_open ( full_path , & newInode , parent_dir_inode -> i_sb , nd -> intent . open . create_mode , nd -> intent . open . file -> f_flags , & oplock , & fileHandle , xid ) ;  if ( ( rc == 0 ) || ( rc == - ENOENT ) )  posix_open = true ; else if ( ( rc == - EINVAL ) || ( rc != - EOPNOTSUPP ) ) pTcon -> broken_posix_open = true ; } if ( ! posix_open ) rc = cifs_get_inode_info_unix ( & newInode , full_path , parent_dir_inode -> i_sb , xid ) ; } else rc = cifs_get_inode_info ( & newInode , full_path , NULL , parent_dir_inode -> i_sb , xid , NULL ) ; if ( ( rc == 0 ) && ( newInode != NULL ) ) { d_add ( direntry , newInode ) ; if ( posix_open ) { filp = lookup_instantiate_filp ( nd , direntry , generic_file_open ) ; if ( IS_ERR ( filp ) ) { rc = PTR_ERR ( filp ) ; CIFSSMBClose ( xid , pTcon , fileHandle ) ; goto lookup_out ; } cfile = cifs_new_fileinfo ( fileHandle , filp , tlink , oplock ) ; if ( cfile == NULL ) { fput ( filp ) ; CIFSSMBClose ( xid , pTcon , fileHandle ) ; rc = - ENOMEM ; goto lookup_out ; } } renew_parental_timestamps ( direntry ) ; } else if ( rc == - ENOENT ) { rc = 0 ; direntry -> d_time = jiffies ; d_add ( direntry , NULL ) ; } else if ( rc != - EACCES ) { cERROR ( 1 , ""Unexpected<S2SV_blank>lookup<S2SV_blank>error<S2SV_blank>%d"" , rc ) ; } lookup_out : kfree ( full_path ) ; cifs_put_tlink ( tlink ) ; FreeXid ( xid ) ; return ERR_PTR ( rc ) ; }","
",551
750,"buggy line: cwe id:CWE-264context: struct dentry * cifs_lookup ( struct inode * parent_dir_inode , struct dentry * direntry , struct nameidata * nd ) { int xid ; int rc = 0 ; __u32 oplock = enable_oplocks ? REQ_OPLOCK : 0 ; __u16 fileHandle = 0 ; bool posix_open = false ; struct cifs_sb_info * cifs_sb ; struct tcon_link * tlink ; struct cifs_tcon * pTcon ; struct cifsFileInfo * cfile ; struct inode * newInode = NULL ; char * full_path = NULL ; struct file * filp ; xid = GetXid ( ) ; cFYI ( 1 , ""parent<S2SV_blank>inode<S2SV_blank>=<S2SV_blank>0x%p<S2SV_blank>name<S2SV_blank>is:<S2SV_blank>%s<S2SV_blank>and<S2SV_blank>dentry<S2SV_blank>=<S2SV_blank>0x%p"" , parent_dir_inode , direntry -> d_name . name , direntry ) ; cifs_sb = CIFS_SB ( parent_dir_inode -> i_sb ) ; tlink = cifs_sb_tlink ( cifs_sb ) ; if ( IS_ERR ( tlink ) ) { FreeXid ( xid ) ; return ( struct dentry * ) tlink ; } pTcon = tlink_tcon ( tlink ) ; if ( ! ( cifs_sb -> mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS ) ) { int i ; for ( i = 0 ; i < direntry -> d_name . len ; i ++ ) if ( direntry -> d_name . name [ i ] == '\\\\' ) { cFYI ( 1 , ""Invalid<S2SV_blank>file<S2SV_blank>name"" ) ; rc = - EINVAL ; goto lookup_out ; } } if ( nd && ( nd -> flags & LOOKUP_EXCL ) ) { d_instantiate ( direntry , NULL ) ; rc = 0 ; goto lookup_out ; } full_path = build_path_from_dentry ( direntry ) ; if ( full_path == NULL ) { rc = - ENOMEM ; goto lookup_out ; } if ( direntry -> d_inode != NULL ) { cFYI ( 1 , ""non-NULL<S2SV_blank>inode<S2SV_blank>in<S2SV_blank>lookup"" ) ; } else { cFYI ( 1 , ""NULL<S2SV_blank>inode<S2SV_blank>in<S2SV_blank>lookup"" ) ; } cFYI ( 1 , ""Full<S2SV_blank>path:<S2SV_blank>%s<S2SV_blank>inode<S2SV_blank>=<S2SV_blank>0x%p"" , full_path , direntry -> d_inode ) ; if ( pTcon -> unix_ext ) { if ( nd && ! ( nd -> flags & LOOKUP_DIRECTORY ) && ( nd -> flags & LOOKUP_OPEN ) && ! pTcon -> broken_posix_open && ( nd -> intent . open . file -> f_flags & O_CREAT ) ) { rc = cifs_posix_open ( full_path , & newInode , parent_dir_inode -> i_sb , nd -> intent . open . create_mode , nd -> intent . open . file -> f_flags , & oplock , & fileHandle , xid ) ;  if ( ( rc == 0 ) || ( rc == - ENOENT ) )  posix_open = true ; else if ( ( rc == - EINVAL ) || ( rc != - EOPNOTSUPP ) ) pTcon -> broken_posix_open = true ; } if ( ! posix_open ) rc = cifs_get_inode_info_unix ( & newInode , full_path , parent_dir_inode -> i_sb , xid ) ; } else rc = cifs_get_inode_info ( & newInode , full_path , NULL , parent_dir_inode -> i_sb , xid , NULL ) ; if ( ( rc == 0 ) && ( newInode != NULL ) ) { d_add ( direntry , newInode ) ; if ( posix_open ) { filp = lookup_instantiate_filp ( nd , direntry , generic_file_open ) ; if ( IS_ERR ( filp ) ) { rc = PTR_ERR ( filp ) ; CIFSSMBClose ( xid , pTcon , fileHandle ) ; goto lookup_out ; } cfile = cifs_new_fileinfo ( fileHandle , filp , tlink , oplock ) ; if ( cfile == NULL ) { fput ( filp ) ; CIFSSMBClose ( xid , pTcon , fileHandle ) ; rc = - ENOMEM ; goto lookup_out ; } } renew_parental_timestamps ( direntry ) ; } else if ( rc == - ENOENT ) { rc = 0 ; direntry -> d_time = jiffies ; d_add ( direntry , NULL ) ; } else if ( rc != - EACCES ) { cERROR ( 1 , ""Unexpected<S2SV_blank>lookup<S2SV_blank>error<S2SV_blank>%d"" , rc ) ; } lookup_out : kfree ( full_path ) ; cifs_put_tlink ( tlink ) ; FreeXid ( xid ) ; return ERR_PTR ( rc ) ; }","rc = PTR_ERR ( filp ) ;CIFSSMBClose ( xid , pTcon , fileHandle ) ;goto lookup_out ;}cfile = cifs_new_fileinfo ( fileHandle , filp , tlink , oplock ) ;if ( cfile == NULL ) {fput ( filp ) ;CIFSSMBClose ( xid , pTcon , fileHandle ) ;rc = - ENOMEM ;goto lookup_out ;}}renew_parental_timestamps ( direntry ) ;}else if ( rc == - ENOENT ) {",551
751,"buggy line: info . flags = VFIO_DEVICE_FLAGS_PCI ;if ( vdev -> reset_works ) info . flags |= VFIO_DEVICE_FLAGS_RESET ;info . num_regions = VFIO_PCI_NUM_REGIONS + vdev -> num_regions ;info . num_irqs = VFIO_PCI_NUM_IRQS ;return copy_to_user ( ( void __user * ) arg , & info , minsz ) ? - EFAULT : 0 ;}else if ( cmd == VFIO_DEVICE_GET_REGION_INFO ) {struct pci_dev * pdev = vdev -> pdev ;struct vfio_region_info info ;struct vfio_info_cap caps = {. buf = NULL , . size = 0 };int i , ret ;minsz = offsetofend ( struct vfio_region_info , offset ) ;if ( copy_from_user ( & info , ( void __user * ) arg , minsz ) ) return - EFAULT ;if ( info . argsz < minsz ) return - EINVAL ;switch ( info . index ) {case VFIO_PCI_CONFIG_REGION_INDEX : info . offset = VFIO_PCI_INDEX_TO_OFFSET ( info . index ) ;info . size = pdev -> cfg_size ;info . flags = VFIO_REGION_INFO_FLAG_READ | VFIO_REGION_INFO_FLAG_WRITE ;break ;case VFIO_PCI_BAR0_REGION_INDEX ... VFIO_PCI_BAR5_REGION_INDEX : info . offset = VFIO_PCI_INDEX_TO_OFFSET ( info . index ) ;info . size = pci_resource_len ( pdev , info . index ) ;if ( ! info . size ) {info . flags = 0 ;break ;}info . flags = VFIO_REGION_INFO_FLAG_READ | VFIO_REGION_INFO_FLAG_WRITE ;if ( vdev -> bar_mmap_supported [ info . index ] ) {info . flags |= VFIO_REGION_INFO_FLAG_MMAP ;if ( info . index == vdev -> msix_bar ) {ret = msix_sparse_mmap_cap ( vdev , & caps ) ;if ( ret ) return ret ;}}case VFIO_PCI_ROM_REGION_INDEX : {void __iomem * io ;size_t size ;info . offset = VFIO_PCI_INDEX_TO_OFFSET ( info . index ) ;info . flags = 0 ;info . size = pci_resource_len ( pdev , info . index ) ;if ( ! info . size ) {if ( pdev -> resource [ PCI_ROM_RESOURCE ] . flags & IORESOURCE_ROM_SHADOW ) info . size = 0x20000 ;else break ;}io = pci_map_rom ( pdev , & size ) ;if ( ! io || ! size ) {info . size = 0 ;}pci_unmap_rom ( pdev , io ) ;info . flags = VFIO_REGION_INFO_FLAG_READ ;}case VFIO_PCI_VGA_REGION_INDEX : if ( ! vdev -> has_vga ) return - EINVAL ;info . offset = VFIO_PCI_INDEX_TO_OFFSET ( info . index ) ;info . size = 0xc0000 ;info . flags = VFIO_REGION_INFO_FLAG_READ | VFIO_REGION_INFO_FLAG_WRITE ;break ;default : if ( info . index >= VFIO_PCI_NUM_REGIONS + vdev -> num_regions ) return - EINVAL ;i = info . index - VFIO_PCI_NUM_REGIONS ;info . offset = VFIO_PCI_INDEX_TO_OFFSET ( info . index ) ;info . size = vdev -> region [ i ] . size ;info . flags = vdev -> region [ i ] . flags ;ret = region_type_cap ( vdev , & caps , vdev -> region [ i ] . type , vdev -> region [ i ] . subtype ) ;if ( ret ) return ret ;}if ( caps . size ) {info . flags |= VFIO_REGION_INFO_FLAG_CAPS ;if ( info . argsz < sizeof ( info ) + caps . size ) {info . argsz = sizeof ( info ) + caps . size ;info . cap_offset = 0 ;}else {vfio_info_cap_shift ( & caps , sizeof ( info ) ) ;if ( copy_to_user ( ( void __user * ) arg + sizeof ( info ) , caps . buf , caps . size ) ) {kfree ( caps . buf ) ;return - EFAULT ;}info . cap_offset = sizeof ( info ) ;}kfree ( caps . buf ) ;}return copy_to_user ( ( void __user * ) arg , & info , minsz ) ? - EFAULT : 0 ;}else if ( cmd == VFIO_DEVICE_GET_IRQ_INFO ) {struct vfio_irq_info info ;minsz = offsetofend ( struct vfio_irq_info , count ) ;if ( copy_from_user ( & info , ( void __user * ) arg , minsz ) ) return - EFAULT ;if ( info . argsz < minsz || info . index >= VFIO_PCI_NUM_IRQS ) return - EINVAL ;switch ( info . index ) {case VFIO_PCI_INTX_IRQ_INDEX ... VFIO_PCI_MSIX_IRQ_INDEX : case VFIO_PCI_REQ_IRQ_INDEX : break ;case VFIO_PCI_ERR_IRQ_INDEX : if ( pci_is_pcie ( vdev -> pdev ) ) break ;info . flags = VFIO_IRQ_INFO_EVENTFD ;info . count = vfio_pci_get_irq_count ( vdev , info . index ) ;if ( info . index == VFIO_PCI_INTX_IRQ_INDEX ) info . flags |= ( VFIO_IRQ_INFO_MASKABLE | VFIO_IRQ_INFO_AUTOMASKED ) ;else info . flags |= VFIO_IRQ_INFO_NORESIZE ;return copy_to_user ( ( void __user * ) arg , & info , minsz ) ? - EFAULT : 0 ;}else if ( cmd == VFIO_DEVICE_SET_IRQS ) {struct vfio_irq_set hdr ;u8 * data = NULL ;int ret = 0 ;minsz = offsetofend ( struct vfio_irq_set , count ) ;if ( copy_from_user ( & hdr , ( void __user * ) arg , minsz ) ) return - EFAULT ;if ( hdr . argsz < minsz || hdr . index >= VFIO_PCI_NUM_IRQS ||  hdr . flags & ~ ( VFIO_IRQ_SET_DATA_TYPE_MASK |  VFIO_IRQ_SET_ACTION_TYPE_MASK ) ) return - EINVAL ;if ( ! ( hdr . flags & VFIO_IRQ_SET_DATA_NONE ) ) {size_t size ;int max = vfio_pci_get_irq_count ( vdev , hdr . index ) ;if ( hdr . flags & VFIO_IRQ_SET_DATA_BOOL )  size = sizeof ( uint8_t ) ;else if ( hdr . flags & VFIO_IRQ_SET_DATA_EVENTFD ) size = sizeof ( int32_t ) ;else return - EINVAL ;if ( hdr . argsz - minsz < hdr . count * size ||  hdr . start >= max || hdr . start + hdr . count > max )  return - EINVAL ;cwe id:CWE-190context: static long vfio_pci_ioctl ( void * device_data , unsigned int cmd , unsigned long arg ) { struct vfio_pci_device * vdev = device_data ; unsigned long minsz ; if ( cmd == VFIO_DEVICE_GET_INFO ) { struct vfio_device_info info ; minsz = offsetofend ( struct vfio_device_info , num_irqs ) ; if ( copy_from_user ( & info , ( void __user * ) arg , minsz ) ) return - EFAULT ; if ( info . argsz < minsz ) return - EINVAL ; info . flags = VFIO_DEVICE_FLAGS_PCI ; if ( vdev -> reset_works ) info . flags |= VFIO_DEVICE_FLAGS_RESET ; info . num_regions = VFIO_PCI_NUM_REGIONS + vdev -> num_regions ; info . num_irqs = VFIO_PCI_NUM_IRQS ; return copy_to_user ( ( void __user * ) arg , & info , minsz ) ? - EFAULT : 0 ; } else if ( cmd == VFIO_DEVICE_GET_REGION_INFO ) { struct pci_dev * pdev = vdev -> pdev ; struct vfio_region_info info ; struct vfio_info_cap caps = { . buf = NULL , . size = 0 } ; int i , ret ; minsz = offsetofend ( struct vfio_region_info , offset ) ; if ( copy_from_user ( & info , ( void __user * ) arg , minsz ) ) return - EFAULT ; if ( info . argsz < minsz ) return - EINVAL ; switch ( info . index ) { case VFIO_PCI_CONFIG_REGION_INDEX : info . offset = VFIO_PCI_INDEX_TO_OFFSET ( info . index ) ; info . size = pdev -> cfg_size ; info . flags = VFIO_REGION_INFO_FLAG_READ | VFIO_REGION_INFO_FLAG_WRITE ; break ; case VFIO_PCI_BAR0_REGION_INDEX ... VFIO_PCI_BAR5_REGION_INDEX : info . offset = VFIO_PCI_INDEX_TO_OFFSET ( info . index ) ; info . size = pci_resource_len ( pdev , info . index ) ; if ( ! info . size ) { info . flags = 0 ; break ; } info . flags = VFIO_REGION_INFO_FLAG_READ | VFIO_REGION_INFO_FLAG_WRITE ; if ( vdev -> bar_mmap_supported [ info . index ] ) { info . flags |= VFIO_REGION_INFO_FLAG_MMAP ; if ( info . index == vdev -> msix_bar ) { ret = msix_sparse_mmap_cap ( vdev , & caps ) ; if ( ret ) return ret ; } } break ; case VFIO_PCI_ROM_REGION_INDEX : { void __iomem * io ; size_t size ; info . offset = VFIO_PCI_INDEX_TO_OFFSET ( info . index ) ; info . flags = 0 ; info . size = pci_resource_len ( pdev , info . index ) ; if ( ! info . size ) { if ( pdev -> resource [ PCI_ROM_RESOURCE ] . flags & IORESOURCE_ROM_SHADOW ) info . size = 0x20000 ; else break ; } io = pci_map_rom ( pdev , & size ) ; if ( ! io || ! size ) { info . size = 0 ; break ; } pci_unmap_rom ( pdev , io ) ; info . flags = VFIO_REGION_INFO_FLAG_READ ; break ; } case VFIO_PCI_VGA_REGION_INDEX : if ( ! vdev -> has_vga ) return - EINVAL ; info . offset = VFIO_PCI_INDEX_TO_OFFSET ( info . index ) ; info . size = 0xc0000 ; info . flags = VFIO_REGION_INFO_FLAG_READ | VFIO_REGION_INFO_FLAG_WRITE ; break ; default : if ( info . index >= VFIO_PCI_NUM_REGIONS + vdev -> num_regions ) return - EINVAL ; i = info . index - VFIO_PCI_NUM_REGIONS ; info . offset = VFIO_PCI_INDEX_TO_OFFSET ( info . index ) ; info . size = vdev -> region [ i ] . size ; info . flags = vdev -> region [ i ] . flags ; ret = region_type_cap ( vdev , & caps , vdev -> region [ i ] . type , vdev -> region [ i ] . subtype ) ; if ( ret ) return ret ; } if ( caps . size ) { info . flags |= VFIO_REGION_INFO_FLAG_CAPS ; if ( info . argsz < sizeof ( info ) + caps . size ) { info . argsz = sizeof ( info ) + caps . size ; info . cap_offset = 0 ; } else { vfio_info_cap_shift ( & caps , sizeof ( info ) ) ; if ( copy_to_user ( ( void __user * ) arg + sizeof ( info ) , caps . buf , caps . size ) ) { kfree ( caps . buf ) ; return - EFAULT ; } info . cap_offset = sizeof ( info ) ; } kfree ( caps . buf ) ; } return copy_to_user ( ( void __user * ) arg , & info , minsz ) ? - EFAULT : 0 ; } else if ( cmd == VFIO_DEVICE_GET_IRQ_INFO ) { struct vfio_irq_info info ; minsz = offsetofend ( struct vfio_irq_info , count ) ; if ( copy_from_user ( & info , ( void __user * ) arg , minsz ) ) return - EFAULT ; if ( info . argsz < minsz || info . index >= VFIO_PCI_NUM_IRQS ) return - EINVAL ; switch ( info . index ) { case VFIO_PCI_INTX_IRQ_INDEX ... VFIO_PCI_MSIX_IRQ_INDEX : case VFIO_PCI_REQ_IRQ_INDEX : break ; case VFIO_PCI_ERR_IRQ_INDEX : if ( pci_is_pcie ( vdev -> pdev ) ) break ; default : return - EINVAL ; } info . flags = VFIO_IRQ_INFO_EVENTFD ; info . count = vfio_pci_get_irq_count ( vdev , info . index ) ; if ( info . index == VFIO_PCI_INTX_IRQ_INDEX ) info . flags |= ( VFIO_IRQ_INFO_MASKABLE | VFIO_IRQ_INFO_AUTOMASKED ) ; else info . flags |= VFIO_IRQ_INFO_NORESIZE ; return copy_to_user ( ( void __user * ) arg , & info , minsz ) ? - EFAULT : 0 ; } else if ( cmd == VFIO_DEVICE_SET_IRQS ) { struct vfio_irq_set hdr ;  u8 * data = NULL ;   int ret = 0 ;  minsz = offsetofend ( struct vfio_irq_set , count ) ; if ( copy_from_user ( & hdr , ( void __user * ) arg , minsz ) ) return - EFAULT ; if ( hdr . argsz < minsz || hdr . index >= VFIO_PCI_NUM_IRQS ||  hdr . flags & ~ ( VFIO_IRQ_SET_DATA_TYPE_MASK |  VFIO_IRQ_SET_ACTION_TYPE_MASK ) ) return - EINVAL ;  if ( ! ( hdr . flags & VFIO_IRQ_SET_DATA_NONE ) ) {  size_t size ; int max = vfio_pci_get_irq_count ( vdev , hdr . index ) ;  if ( hdr . flags & VFIO_IRQ_SET_DATA_BOOL )  size = sizeof ( uint8_t ) ; else if ( hdr . flags & VFIO_IRQ_SET_DATA_EVENTFD ) size = sizeof ( int32_t ) ; else return - EINVAL ; if ( hdr . argsz - minsz < hdr . count * size ||  hdr . start >= max || hdr . start + hdr . count > max )  return - EINVAL ; data = memdup_user ( ( void __user * ) ( arg + minsz ) , hdr . count * size ) ; if ( IS_ERR ( data ) ) return PTR_ERR ( data ) ; } mutex_lock ( & vdev -> igate ) ; ret = vfio_pci_set_irqs_ioctl ( vdev , hdr . flags , hdr . index , hdr . start , hdr . count , data ) ; mutex_unlock ( & vdev -> igate ) ; kfree ( data ) ; return ret ; } else if ( cmd == VFIO_DEVICE_RESET ) { return vdev -> reset_works ? pci_try_reset_function ( vdev -> pdev ) : - EINVAL ; } else if ( cmd == VFIO_DEVICE_GET_PCI_HOT_RESET_INFO ) { struct vfio_pci_hot_reset_info hdr ; struct vfio_pci_fill_info fill = { 0 } ; struct vfio_pci_dependent_device * devices = NULL ; bool slot = false ; int ret = 0 ; minsz = offsetofend ( struct vfio_pci_hot_reset_info , count ) ; if ( copy_from_user ( & hdr , ( void __user * ) arg , minsz ) ) return - EFAULT ; if ( hdr . argsz < minsz ) return - EINVAL ; hdr . flags = 0 ; if ( ! pci_probe_reset_slot ( vdev -> pdev -> slot ) ) slot = true ; else if ( pci_probe_reset_bus ( vdev -> pdev -> bus ) ) return - ENODEV ; ret = vfio_pci_for_each_slot_or_bus ( vdev -> pdev , vfio_pci_count_devs , & fill . max , slot ) ; if ( ret ) return ret ; WARN_ON ( ! fill . max ) ; if ( hdr . argsz < sizeof ( hdr ) + ( fill . max * sizeof ( * devices ) ) ) { ret = - ENOSPC ; hdr . count = fill . max ; goto reset_info_exit ; } devices = kcalloc ( fill . max , sizeof ( * devices ) , GFP_KERNEL ) ; if ( ! devices ) return - ENOMEM ; fill . devices = devices ; ret = vfio_pci_for_each_slot_or_bus ( vdev -> pdev , vfio_pci_fill_devs , & fill , slot ) ; if ( ! ret ) hdr . count = fill . cur ; reset_info_exit : if ( copy_to_user ( ( void __user * ) arg , & hdr , minsz ) ) ret = - EFAULT ; if ( ! ret ) { if ( copy_to_user ( ( void __user * ) ( arg + minsz ) , devices , hdr . count * sizeof ( * devices ) ) ) ret = - EFAULT ; } kfree ( devices ) ; return ret ; } else if ( cmd == VFIO_DEVICE_PCI_HOT_RESET ) { struct vfio_pci_hot_reset hdr ; int32_t * group_fds ; struct vfio_pci_group_entry * groups ; struct vfio_pci_group_info info ; bool slot = false ; int i , count = 0 , ret = 0 ; minsz = offsetofend ( struct vfio_pci_hot_reset , count ) ; if ( copy_from_user ( & hdr , ( void __user * ) arg , minsz ) ) return - EFAULT ; if ( hdr . argsz < minsz || hdr . flags ) return - EINVAL ; if ( ! pci_probe_reset_slot ( vdev -> pdev -> slot ) ) slot = true ; else if ( pci_probe_reset_bus ( vdev -> pdev -> bus ) ) return - ENODEV ; ret = vfio_pci_for_each_slot_or_bus ( vdev -> pdev , vfio_pci_count_devs , & count , slot ) ; if ( ret ) return ret ; if ( ! hdr . count || hdr . count > count ) return - EINVAL ; group_fds = kcalloc ( hdr . count , sizeof ( * group_fds ) , GFP_KERNEL ) ; groups = kcalloc ( hdr . count , sizeof ( * groups ) , GFP_KERNEL ) ; if ( ! group_fds || ! groups ) { kfree ( group_fds ) ; kfree ( groups ) ; return - ENOMEM ; } if ( copy_from_user ( group_fds , ( void __user * ) ( arg + minsz ) , hdr . count * sizeof ( * group_fds ) ) ) { kfree ( group_fds ) ; kfree ( groups ) ; return - EFAULT ; } for ( i = 0 ; i < hdr . count ; i ++ ) { struct vfio_group * group ; struct fd f = fdget ( group_fds [ i ] ) ; if ( ! f . file ) { ret = - EBADF ; break ; } group = vfio_group_get_external_user ( f . file ) ; fdput ( f ) ; if ( IS_ERR ( group ) ) { ret = PTR_ERR ( group ) ; break ; } groups [ i ] . group = group ; groups [ i ] . id = vfio_external_user_iommu_id ( group ) ; } kfree ( group_fds ) ; if ( ret ) goto hot_reset_release ; info . count = hdr . count ; info . groups = groups ; ret = vfio_pci_for_each_slot_or_bus ( vdev -> pdev , vfio_pci_validate_devs , & info , slot ) ; if ( ! ret ) ret = slot ? pci_try_reset_slot ( vdev -> pdev -> slot ) : pci_try_reset_bus ( vdev -> pdev -> bus ) ; hot_reset_release : for ( i -- ; i >= 0 ; i -- ) vfio_group_put_external_user ( groups [ i ] . group ) ; kfree ( groups ) ; return ret ; } return - ENOTTY ; }","max = vfio_pci_get_irq_count ( vdev , hdr . index ) ;if ( hdr . flags & VFIO_IRQ_SET_DATA_BOOL ) size = sizeof ( uint8_t ) ;else if ( hdr . flags & VFIO_IRQ_SET_DATA_EVENTFD ) size = sizeof ( int32_t ) ;else return - EINVAL ;if ( hdr . argsz - minsz < hdr . count * size || hdr . start >= max || hdr . start + hdr . count > max ) return - EINVAL ;switch ( hdr . flags & VFIO_IRQ_SET_DATA_TYPE_MASK ) {case VFIO_IRQ_SET_DATA_NONE : size = 0 ;case VFIO_IRQ_SET_DATA_BOOL : size = sizeof ( uint8_t ) ;case VFIO_IRQ_SET_DATA_EVENTFD : size = sizeof ( int32_t ) ;if ( size ) {if ( hdr . argsz - minsz < hdr . count * size ) return - EINVAL ;",552
752,"buggy line: if ( ext4_test_inode_state ( inode , EXT4_STATE_ORDERED_MODE ) ) {ret = ext4_jbd2_file_inode ( handle , inode ) ;if ( ret ) {unlock_page ( page ) ;put_page ( page ) ;goto errout ;}}cwe id:CWE-200context: static int ext4_write_end ( struct file * file , struct address_space * mapping , loff_t pos , unsigned len , unsigned copied , struct page * page , void * fsdata ) { handle_t * handle = ext4_journal_current_handle ( ) ; struct inode * inode = mapping -> host ; loff_t old_size = inode -> i_size ; int ret = 0 , ret2 ; int i_size_changed = 0 ; trace_ext4_write_end ( inode , pos , len , copied ) ;  if ( ext4_test_inode_state ( inode , EXT4_STATE_ORDERED_MODE ) ) {  ret = ext4_jbd2_file_inode ( handle , inode ) ; if ( ret ) { unlock_page ( page ) ; put_page ( page ) ; goto errout ; } } if ( ext4_has_inline_data ( inode ) ) { ret = ext4_write_inline_data_end ( inode , pos , len , copied , page ) ; if ( ret < 0 ) goto errout ; copied = ret ; } else copied = block_write_end ( file , mapping , pos , len , copied , page , fsdata ) ; i_size_changed = ext4_update_inode_size ( inode , pos + copied ) ; unlock_page ( page ) ; put_page ( page ) ; if ( old_size < pos ) pagecache_isize_extended ( inode , old_size , pos ) ; if ( i_size_changed ) ext4_mark_inode_dirty ( handle , inode ) ; if ( pos + len > inode -> i_size && ext4_can_truncate ( inode ) ) ext4_orphan_add ( handle , inode ) ; errout : ret2 = ext4_journal_stop ( handle ) ; if ( ! ret ) ret = ret2 ; if ( pos + len > inode -> i_size ) { ext4_truncate_failed_write ( inode ) ; if ( inode -> i_nlink ) ext4_orphan_del ( NULL , inode ) ; } return ret ? ret : copied ; }","
",553
753,"buggy line: s -> filesize = - 1 ;s -> location = av_strdup ( uri ) ;cwe id:CWE-119context: static int http_open ( URLContext * h , const char * uri , int flags , AVDictionary * * options ) { HTTPContext * s = h -> priv_data ; int ret ; if ( s -> seekable == 1 ) h -> is_streamed = 0 ; else h -> is_streamed = 1 ;  s -> filesize = - 1 ;  s -> location = av_strdup ( uri ) ; if ( ! s -> location ) return AVERROR ( ENOMEM ) ; if ( options ) av_dict_copy ( & s -> chained_options , * options , 0 ) ; if ( s -> headers ) { int len = strlen ( s -> headers ) ; if ( len < 2 || strcmp ( ""\\r\\n"" , s -> headers + len - 2 ) ) { av_log ( h , AV_LOG_WARNING , ""No<S2SV_blank>trailing<S2SV_blank>CRLF<S2SV_blank>found<S2SV_blank>in<S2SV_blank>HTTP<S2SV_blank>header.\\n"" ) ; ret = av_reallocp ( & s -> headers , len + 3 ) ; if ( ret < 0 ) return ret ; s -> headers [ len ] = '\\r' ; s -> headers [ len + 1 ] = '\\n' ; s -> headers [ len + 2 ] = '\\0' ; } } if ( s -> listen ) { return http_listen ( h , uri , flags , options ) ; } ret = http_open_cnx ( h , options ) ; if ( ret < 0 ) av_dict_free ( & s -> chained_options ) ; return ret ; }",s -> filesize = UINT64_MAX ;s -> location = av_strdup ( uri ) ;,554
754,"buggy line: int opt_size = sizeof ( struct ip_options ) + opt -> optlen ;ireq -> opt = kmalloc ( opt_size , GFP_ATOMIC ) ;if ( ireq -> opt != NULL && ip_options_echo ( ireq -> opt , skb ) ) {kfree ( ireq -> opt ) ;cwe id:CWE-362context: struct sock * cookie_v4_check ( struct sock * sk , struct sk_buff * skb , struct ip_options * opt ) { struct tcp_options_received tcp_opt ; u8 * hash_location ; struct inet_request_sock * ireq ; struct tcp_request_sock * treq ; struct tcp_sock * tp = tcp_sk ( sk ) ; const struct tcphdr * th = tcp_hdr ( skb ) ; __u32 cookie = ntohl ( th -> ack_seq ) - 1 ; struct sock * ret = sk ; struct request_sock * req ; int mss ; struct rtable * rt ; __u8 rcv_wscale ; bool ecn_ok ; if ( ! sysctl_tcp_syncookies || ! th -> ack || th -> rst ) goto out ; if ( tcp_synq_no_recent_overflow ( sk ) || ( mss = cookie_check ( skb , cookie ) ) == 0 ) { NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_SYNCOOKIESFAILED ) ; goto out ; } NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_SYNCOOKIESRECV ) ; memset ( & tcp_opt , 0 , sizeof ( tcp_opt ) ) ; tcp_parse_options ( skb , & tcp_opt , & hash_location , 0 ) ; if ( ! cookie_check_timestamp ( & tcp_opt , & ecn_ok ) ) goto out ; ret = NULL ; req = inet_reqsk_alloc ( & tcp_request_sock_ops ) ; if ( ! req ) goto out ; ireq = inet_rsk ( req ) ; treq = tcp_rsk ( req ) ; treq -> rcv_isn = ntohl ( th -> seq ) - 1 ; treq -> snt_isn = cookie ; req -> mss = mss ; ireq -> loc_port = th -> dest ; ireq -> rmt_port = th -> source ; ireq -> loc_addr = ip_hdr ( skb ) -> daddr ; ireq -> rmt_addr = ip_hdr ( skb ) -> saddr ; ireq -> ecn_ok = ecn_ok ; ireq -> snd_wscale = tcp_opt . snd_wscale ; ireq -> sack_ok = tcp_opt . sack_ok ; ireq -> wscale_ok = tcp_opt . wscale_ok ; ireq -> tstamp_ok = tcp_opt . saw_tstamp ; req -> ts_recent = tcp_opt . saw_tstamp ? tcp_opt . rcv_tsval : 0 ; if ( opt && opt -> optlen ) {  int opt_size = sizeof ( struct ip_options ) + opt -> optlen ;  ireq -> opt = kmalloc ( opt_size , GFP_ATOMIC ) ;  if ( ireq -> opt != NULL && ip_options_echo ( ireq -> opt , skb ) ) {  kfree ( ireq -> opt ) ; ireq -> opt = NULL ; } } if ( security_inet_conn_request ( sk , skb , req ) ) { reqsk_free ( req ) ; goto out ; } req -> expires = 0UL ; req -> retrans = 0 ; { struct flowi4 fl4 ; flowi4_init_output ( & fl4 , 0 , sk -> sk_mark , RT_CONN_FLAGS ( sk ) , RT_SCOPE_UNIVERSE , IPPROTO_TCP , inet_sk_flowi_flags ( sk ) , ( opt && opt -> srr ) ? opt -> faddr : ireq -> rmt_addr , ireq -> loc_addr , th -> source , th -> dest ) ; security_req_classify_flow ( req , flowi4_to_flowi ( & fl4 ) ) ; rt = ip_route_output_key ( sock_net ( sk ) , & fl4 ) ; if ( IS_ERR ( rt ) ) { reqsk_free ( req ) ; goto out ; } } req -> window_clamp = tp -> window_clamp ? : dst_metric ( & rt -> dst , RTAX_WINDOW ) ; tcp_select_initial_window ( tcp_full_space ( sk ) , req -> mss , & req -> rcv_wnd , & req -> window_clamp , ireq -> wscale_ok , & rcv_wscale , dst_metric ( & rt -> dst , RTAX_INITRWND ) ) ; ireq -> rcv_wscale = rcv_wscale ; ret = get_cookie_sock ( sk , skb , req , & rt -> dst ) ; out : return ret ; }","int opt_size = sizeof ( struct ip_options_rcu ) + opt -> optlen ;ireq -> opt = kmalloc ( opt_size , GFP_ATOMIC ) ;if ( ireq -> opt != NULL && ip_options_echo ( & ireq -> opt -> opt , skb ) ) {kfree ( ireq -> opt ) ;",555
755,"buggy line: int mutt_b64_decode ( char * out , const char * in )  {cwe id:CWE-119context:  int mutt_b64_decode ( char * out , const char * in )  { int len = 0 ; unsigned char digit4 ; do { const unsigned char digit1 = in [ 0 ] ; if ( ( digit1 > 127 ) || ( base64val ( digit1 ) == BAD ) ) return - 1 ; const unsigned char digit2 = in [ 1 ] ; if ( ( digit2 > 127 ) || ( base64val ( digit2 ) == BAD ) ) return - 1 ; const unsigned char digit3 = in [ 2 ] ; if ( ( digit3 > 127 ) || ( ( digit3 != '=' ) && ( base64val ( digit3 ) == BAD ) ) ) return - 1 ; digit4 = in [ 3 ] ; if ( ( digit4 > 127 ) || ( ( digit4 != '=' ) && ( base64val ( digit4 ) == BAD ) ) ) return - 1 ; in += 4 ;  * out ++ = ( base64val ( digit1 ) << 2 ) | ( base64val ( digit2 ) >> 4 ) ;  len ++ ; if ( digit3 != '=' ) {  * out ++ = ( ( base64val ( digit2 ) << 4 ) & 0xf0 ) | ( base64val ( digit3 ) >> 2 ) ;  len ++ ; if ( digit4 != '=' ) {  * out ++ = ( ( base64val ( digit3 ) << 6 ) & 0xc0 ) | base64val ( digit4 ) ;  len ++ ; } } } while ( * in && digit4 != '=' ) ; return len ; }","int mutt_b64_decode ( char * out , const char * in , size_t olen ) {",556
756,"buggy line: * out ++ = ( base64val ( digit1 ) << 2 ) | ( base64val ( digit2 ) >> 4 ) ;len ++ ;* out ++ = ( ( base64val ( digit2 ) << 4 ) & 0xf0 ) | ( base64val ( digit3 ) >> 2 ) ;len ++ ;* out ++ = ( ( base64val ( digit3 ) << 6 ) & 0xc0 ) | base64val ( digit4 ) ;len ++ ;cwe id:CWE-119context:  int mutt_b64_decode ( char * out , const char * in )  { int len = 0 ; unsigned char digit4 ; do { const unsigned char digit1 = in [ 0 ] ; if ( ( digit1 > 127 ) || ( base64val ( digit1 ) == BAD ) ) return - 1 ; const unsigned char digit2 = in [ 1 ] ; if ( ( digit2 > 127 ) || ( base64val ( digit2 ) == BAD ) ) return - 1 ; const unsigned char digit3 = in [ 2 ] ; if ( ( digit3 > 127 ) || ( ( digit3 != '=' ) && ( base64val ( digit3 ) == BAD ) ) ) return - 1 ; digit4 = in [ 3 ] ; if ( ( digit4 > 127 ) || ( ( digit4 != '=' ) && ( base64val ( digit4 ) == BAD ) ) ) return - 1 ; in += 4 ;  * out ++ = ( base64val ( digit1 ) << 2 ) | ( base64val ( digit2 ) >> 4 ) ;  len ++ ; if ( digit3 != '=' ) {  * out ++ = ( ( base64val ( digit2 ) << 4 ) & 0xf0 ) | ( base64val ( digit3 ) >> 2 ) ;  len ++ ; if ( digit4 != '=' ) {  * out ++ = ( ( base64val ( digit3 ) << 6 ) & 0xc0 ) | base64val ( digit4 ) ;  len ++ ; } } } while ( * in && digit4 != '=' ) ; return len ; }",if ( len == olen ) return len ;* out ++ = ( base64val ( digit1 ) << 2 ) | ( base64val ( digit2 ) >> 4 ) ;len ++ ;if ( len == olen ) return len ;* out ++ = ( ( base64val ( digit2 ) << 4 ) & 0xf0 ) | ( base64val ( digit3 ) >> 2 ) ;len ++ ;if ( len == olen ) return len ;* out ++ = ( ( base64val ( digit3 ) << 6 ) & 0xc0 ) | base64val ( digit4 ) ;len ++ ;,556
757,buggy line: pinctrl_unregister ( gpio_dev -> pctrl ) ;return 0 ;cwe id:CWE-415context: static int amd_gpio_remove ( struct platform_device * pdev ) { struct amd_gpio * gpio_dev ; gpio_dev = platform_get_drvdata ( pdev ) ; gpiochip_remove ( & gpio_dev -> gc ) ;  pinctrl_unregister ( gpio_dev -> pctrl ) ;  return 0 ; },return 0 ;,557
758,"buggy line: size_t copied , len , cur_len ;ssize_t total_written = 0 ;cwe id:CWE-119context: static ssize_t cifs_iovec_write ( struct file * file , const struct iovec * iov , unsigned long nr_segs , loff_t * poffset ) { unsigned long nr_pages , i ;  size_t copied , len , cur_len ;  ssize_t total_written = 0 ; loff_t offset ; struct iov_iter it ; struct cifsFileInfo * open_file ; struct cifs_tcon * tcon ; struct cifs_sb_info * cifs_sb ; struct cifs_writedata * wdata , * tmp ; struct list_head wdata_list ; int rc ; pid_t pid ; len = iov_length ( iov , nr_segs ) ; if ( ! len ) return 0 ; rc = generic_write_checks ( file , poffset , & len , 0 ) ; if ( rc ) return rc ; INIT_LIST_HEAD ( & wdata_list ) ; cifs_sb = CIFS_SB ( file -> f_path . dentry -> d_sb ) ; open_file = file -> private_data ; tcon = tlink_tcon ( open_file -> tlink ) ; if ( ! tcon -> ses -> server -> ops -> async_writev ) return - ENOSYS ; offset = * poffset ; if ( cifs_sb -> mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD ) pid = open_file -> pid ; else pid = current -> tgid ; iov_iter_init ( & it , iov , nr_segs , len , 0 ) ; do { size_t save_len ; nr_pages = get_numpages ( cifs_sb -> wsize , len , & cur_len ) ; wdata = cifs_writedata_alloc ( nr_pages , cifs_uncached_writev_complete ) ; if ( ! wdata ) { rc = - ENOMEM ; break ; } rc = cifs_write_allocate_pages ( wdata -> pages , nr_pages ) ; if ( rc ) { kfree ( wdata ) ; break ; } save_len = cur_len ; for ( i = 0 ; i < nr_pages ; i ++ ) {  copied = min_t ( const size_t , cur_len , PAGE_SIZE ) ;  copied = iov_iter_copy_from_user ( wdata -> pages [ i ] , & it ,  0 , copied ) ;  cur_len -= copied ; iov_iter_advance ( & it , copied ) ;  }   cur_len = save_len - cur_len ;  wdata -> sync_mode = WB_SYNC_ALL ; wdata -> nr_pages = nr_pages ; wdata -> offset = ( __u64 ) offset ; wdata -> cfile = cifsFileInfo_get ( open_file ) ; wdata -> pid = pid ; wdata -> bytes = cur_len ; wdata -> pagesz = PAGE_SIZE ; wdata -> tailsz = cur_len - ( ( nr_pages - 1 ) * PAGE_SIZE ) ; rc = cifs_uncached_retry_writev ( wdata ) ; if ( rc ) { kref_put ( & wdata -> refcount , cifs_uncached_writedata_release ) ; break ; } list_add_tail ( & wdata -> list , & wdata_list ) ; offset += cur_len ; len -= cur_len ; } while ( len > 0 ) ; if ( ! list_empty ( & wdata_list ) ) rc = 0 ; restart_loop : list_for_each_entry_safe ( wdata , tmp , & wdata_list , list ) { if ( ! rc ) { rc = wait_for_completion_killable ( & wdata -> done ) ; if ( rc ) rc = - EINTR ; else if ( wdata -> result ) rc = wdata -> result ; else total_written += wdata -> bytes ; if ( rc == - EAGAIN ) { rc = cifs_uncached_retry_writev ( wdata ) ; goto restart_loop ; } } list_del_init ( & wdata -> list ) ; kref_put ( & wdata -> refcount , cifs_uncached_writedata_release ) ; } if ( total_written > 0 ) * poffset += total_written ; cifs_stats_bytes_written ( tcon , total_written ) ; return total_written ? total_written : ( ssize_t ) rc ; }","size_t bytes , copied , len , cur_len ;ssize_t total_written = 0 ;",558
759,"buggy line: copied = min_t ( const size_t , cur_len , PAGE_SIZE ) ;copied = iov_iter_copy_from_user ( wdata -> pages [ i ] , & it ,  0 , copied ) ;cur_len -= copied ;}cur_len = save_len - cur_len ;wdata -> sync_mode = WB_SYNC_ALL ;cwe id:CWE-119context: static ssize_t cifs_iovec_write ( struct file * file , const struct iovec * iov , unsigned long nr_segs , loff_t * poffset ) { unsigned long nr_pages , i ;  size_t copied , len , cur_len ;  ssize_t total_written = 0 ; loff_t offset ; struct iov_iter it ; struct cifsFileInfo * open_file ; struct cifs_tcon * tcon ; struct cifs_sb_info * cifs_sb ; struct cifs_writedata * wdata , * tmp ; struct list_head wdata_list ; int rc ; pid_t pid ; len = iov_length ( iov , nr_segs ) ; if ( ! len ) return 0 ; rc = generic_write_checks ( file , poffset , & len , 0 ) ; if ( rc ) return rc ; INIT_LIST_HEAD ( & wdata_list ) ; cifs_sb = CIFS_SB ( file -> f_path . dentry -> d_sb ) ; open_file = file -> private_data ; tcon = tlink_tcon ( open_file -> tlink ) ; if ( ! tcon -> ses -> server -> ops -> async_writev ) return - ENOSYS ; offset = * poffset ; if ( cifs_sb -> mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD ) pid = open_file -> pid ; else pid = current -> tgid ; iov_iter_init ( & it , iov , nr_segs , len , 0 ) ; do { size_t save_len ; nr_pages = get_numpages ( cifs_sb -> wsize , len , & cur_len ) ; wdata = cifs_writedata_alloc ( nr_pages , cifs_uncached_writev_complete ) ; if ( ! wdata ) { rc = - ENOMEM ; break ; } rc = cifs_write_allocate_pages ( wdata -> pages , nr_pages ) ; if ( rc ) { kfree ( wdata ) ; break ; } save_len = cur_len ; for ( i = 0 ; i < nr_pages ; i ++ ) {  copied = min_t ( const size_t , cur_len , PAGE_SIZE ) ;  copied = iov_iter_copy_from_user ( wdata -> pages [ i ] , & it ,  0 , copied ) ;  cur_len -= copied ; iov_iter_advance ( & it , copied ) ;  }   cur_len = save_len - cur_len ;  wdata -> sync_mode = WB_SYNC_ALL ; wdata -> nr_pages = nr_pages ; wdata -> offset = ( __u64 ) offset ; wdata -> cfile = cifsFileInfo_get ( open_file ) ; wdata -> pid = pid ; wdata -> bytes = cur_len ; wdata -> pagesz = PAGE_SIZE ; wdata -> tailsz = cur_len - ( ( nr_pages - 1 ) * PAGE_SIZE ) ; rc = cifs_uncached_retry_writev ( wdata ) ; if ( rc ) { kref_put ( & wdata -> refcount , cifs_uncached_writedata_release ) ; break ; } list_add_tail ( & wdata -> list , & wdata_list ) ; offset += cur_len ; len -= cur_len ; } while ( len > 0 ) ; if ( ! list_empty ( & wdata_list ) ) rc = 0 ; restart_loop : list_for_each_entry_safe ( wdata , tmp , & wdata_list , list ) { if ( ! rc ) { rc = wait_for_completion_killable ( & wdata -> done ) ; if ( rc ) rc = - EINTR ; else if ( wdata -> result ) rc = wdata -> result ; else total_written += wdata -> bytes ; if ( rc == - EAGAIN ) { rc = cifs_uncached_retry_writev ( wdata ) ; goto restart_loop ; } } list_del_init ( & wdata -> list ) ; kref_put ( & wdata -> refcount , cifs_uncached_writedata_release ) ; } if ( total_written > 0 ) * poffset += total_written ; cifs_stats_bytes_written ( tcon , total_written ) ; return total_written ? total_written : ( ssize_t ) rc ; }","bytes = min_t ( const size_t , cur_len , PAGE_SIZE ) ;copied = iov_iter_copy_from_user ( wdata -> pages [ i ] , & it , 0 , bytes ) ;cur_len -= copied ;if ( copied < bytes ) break ;}cur_len = save_len - cur_len ;if ( ! cur_len ) {for ( i = 0 ;i < nr_pages ;i ++ ) put_page ( wdata -> pages [ i ] ) ;kfree ( wdata ) ;rc = - EFAULT ;break ;}for ( ;nr_pages > i + 1 ;nr_pages -- ) put_page ( wdata -> pages [ nr_pages - 1 ] ) ;wdata -> sync_mode = WB_SYNC_ALL ;",558
760,"buggy line: if ( ! ( quirks & CP_RDESC_SWAPPED_MIN_MAX ) )  return rdesc ;cwe id:CWE-000context: static __u8 * cp_report_fixup ( struct hid_device * hdev , __u8 * rdesc , unsigned int * rsize ) { unsigned long quirks = ( unsigned long ) hid_get_drvdata ( hdev ) ; unsigned int i ;  if ( ! ( quirks & CP_RDESC_SWAPPED_MIN_MAX ) )  return rdesc ; for ( i = 0 ; i < * rsize - 4 ; i ++ ) if ( rdesc [ i ] == 0x29 && rdesc [ i + 2 ] == 0x19 ) { rdesc [ i ] = 0x19 ; rdesc [ i + 2 ] = 0x29 ; swap ( rdesc [ i + 3 ] , rdesc [ i + 1 ] ) ; } return rdesc ; }",if ( ! ( quirks & CP_RDESC_SWAPPED_MIN_MAX ) ) return rdesc ;if ( * rsize < 4 ) return rdesc ;,559
761,"buggy line: int number_of_frames , number_of_keyframes , encode_frame_count ;int i , j ;SvcInternal * const si = get_svc_internal ( svc_ctx ) ;if ( svc_ctx == NULL || si == NULL ) return NULL ;svc_log_reset ( svc_ctx ) ;encode_frame_count = si -> encode_frame_count ;if ( si -> encode_frame_count <= 0 ) return vpx_svc_get_message ( svc_ctx ) ;svc_log ( svc_ctx , SVC_LOG_INFO , ""\\\number_of_keyframes = encode_frame_count / si -> kf_dist + 1 ;for ( i = 0 ;number_of_frames = encode_frame_count ;if ( svc_ctx -> encoding_mode == ALT_INTER_LAYER_PREDICTION_IP && ( i == 1 || i == 3 ) ) {number_of_frames -= number_of_keyframes ;}cwe id:CWE-119context: const char * vpx_svc_dump_statistics ( SvcContext * svc_ctx ) {  int number_of_frames , number_of_keyframes , encode_frame_count ;  int i , j ; uint32_t bytes_total = 0 ; double scale [ COMPONENTS ] ; double psnr [ COMPONENTS ] ; double mse [ COMPONENTS ] ; double y_scale ;  SvcInternal * const si = get_svc_internal ( svc_ctx ) ;  if ( svc_ctx == NULL || si == NULL ) return NULL ; svc_log_reset ( svc_ctx ) ;  encode_frame_count = si -> encode_frame_count ;   if ( si -> encode_frame_count <= 0 ) return vpx_svc_get_message ( svc_ctx ) ;  svc_log ( svc_ctx , SVC_LOG_INFO , ""\\n"" ) ;  number_of_keyframes = encode_frame_count / si -> kf_dist + 1 ;   for ( i = 0 ; i < si -> layers ; ++ i ) {   number_of_frames = encode_frame_count ;  if ( svc_ctx -> encoding_mode == ALT_INTER_LAYER_PREDICTION_IP && ( i == 1 || i == 3 ) ) { number_of_frames -= number_of_keyframes ; } svc_log ( svc_ctx , SVC_LOG_INFO , ""Layer<S2SV_blank>%d<S2SV_blank>Average<S2SV_blank>PSNR=[%2.3f,<S2SV_blank>%2.3f,<S2SV_blank>%2.3f,<S2SV_blank>%2.3f],<S2SV_blank>Bytes=[%u]\\n"" , i , ( double ) si -> psnr_sum [ i ] [ 0 ] / number_of_frames , ( double ) si -> psnr_sum [ i ] [ 1 ] / number_of_frames , ( double ) si -> psnr_sum [ i ] [ 2 ] / number_of_frames , ( double ) si -> psnr_sum [ i ] [ 3 ] / number_of_frames , si -> bytes_sum [ i ] ) ; y_scale = si -> width * si -> height * 255.0 * 255.0 * number_of_frames ; scale [ 1 ] = y_scale ; scale [ 2 ] = scale [ 3 ] = y_scale / 4 ; scale [ 0 ] = y_scale * 1.5 ; for ( j = 0 ; j < COMPONENTS ; j ++ ) { psnr [ j ] = calc_psnr ( si -> sse_sum [ i ] [ j ] / scale [ j ] ) ; mse [ j ] = si -> sse_sum [ i ] [ j ] * 255.0 * 255.0 / scale [ j ] ; } svc_log ( svc_ctx , SVC_LOG_INFO , ""Layer<S2SV_blank>%d<S2SV_blank>Overall<S2SV_blank>PSNR=[%2.3f,<S2SV_blank>%2.3f,<S2SV_blank>%2.3f,<S2SV_blank>%2.3f]\\n"" , i , psnr [ 0 ] , psnr [ 1 ] , psnr [ 2 ] , psnr [ 3 ] ) ; svc_log ( svc_ctx , SVC_LOG_INFO , ""Layer<S2SV_blank>%d<S2SV_blank>Overall<S2SV_blank>MSE=[%2.3f,<S2SV_blank>%2.3f,<S2SV_blank>%2.3f,<S2SV_blank>%2.3f]\\n"" , i , mse [ 0 ] , mse [ 1 ] , mse [ 2 ] , mse [ 3 ] ) ; bytes_total += si -> bytes_sum [ i ] ; si -> bytes_sum [ i ] = 0 ; for ( j = 0 ; j < COMPONENTS ; ++ j ) { si -> psnr_sum [ i ] [ j ] = 0 ; si -> sse_sum [ i ] [ j ] = 0 ; } }  si -> encode_frame_count = 0 ;  svc_log ( svc_ctx , SVC_LOG_INFO , ""Total<S2SV_blank>Bytes=[%u]\\n"" , bytes_total ) ; return vpx_svc_get_message ( svc_ctx ) ; }","int number_of_frames ;int i , j ;SvcInternal_t * const si = get_svc_internal ( svc_ctx ) ;number_of_frames = si -> psnr_pkt_received ;if ( si -> encode_frame_count <= 0 ) return vpx_svc_get_message ( svc_ctx ) ;svc_log ( svc_ctx , SVC_LOG_INFO , ""\\\for ( i = 0 ;",560
762,"buggy line: si -> encode_frame_count = 0 ;svc_log ( svc_ctx , SVC_LOG_INFO , ""Total<S2SV_blank>Bytes=[%u]\\\cwe id:CWE-119context: const char * vpx_svc_dump_statistics ( SvcContext * svc_ctx ) {  int number_of_frames , number_of_keyframes , encode_frame_count ;  int i , j ; uint32_t bytes_total = 0 ; double scale [ COMPONENTS ] ; double psnr [ COMPONENTS ] ; double mse [ COMPONENTS ] ; double y_scale ;  SvcInternal * const si = get_svc_internal ( svc_ctx ) ;  if ( svc_ctx == NULL || si == NULL ) return NULL ; svc_log_reset ( svc_ctx ) ;  encode_frame_count = si -> encode_frame_count ;   if ( si -> encode_frame_count <= 0 ) return vpx_svc_get_message ( svc_ctx ) ;  svc_log ( svc_ctx , SVC_LOG_INFO , ""\\n"" ) ;  number_of_keyframes = encode_frame_count / si -> kf_dist + 1 ;   for ( i = 0 ; i < si -> layers ; ++ i ) {   number_of_frames = encode_frame_count ;  if ( svc_ctx -> encoding_mode == ALT_INTER_LAYER_PREDICTION_IP && ( i == 1 || i == 3 ) ) { number_of_frames -= number_of_keyframes ; } svc_log ( svc_ctx , SVC_LOG_INFO , ""Layer<S2SV_blank>%d<S2SV_blank>Average<S2SV_blank>PSNR=[%2.3f,<S2SV_blank>%2.3f,<S2SV_blank>%2.3f,<S2SV_blank>%2.3f],<S2SV_blank>Bytes=[%u]\\n"" , i , ( double ) si -> psnr_sum [ i ] [ 0 ] / number_of_frames , ( double ) si -> psnr_sum [ i ] [ 1 ] / number_of_frames , ( double ) si -> psnr_sum [ i ] [ 2 ] / number_of_frames , ( double ) si -> psnr_sum [ i ] [ 3 ] / number_of_frames , si -> bytes_sum [ i ] ) ; y_scale = si -> width * si -> height * 255.0 * 255.0 * number_of_frames ; scale [ 1 ] = y_scale ; scale [ 2 ] = scale [ 3 ] = y_scale / 4 ; scale [ 0 ] = y_scale * 1.5 ; for ( j = 0 ; j < COMPONENTS ; j ++ ) { psnr [ j ] = calc_psnr ( si -> sse_sum [ i ] [ j ] / scale [ j ] ) ; mse [ j ] = si -> sse_sum [ i ] [ j ] * 255.0 * 255.0 / scale [ j ] ; } svc_log ( svc_ctx , SVC_LOG_INFO , ""Layer<S2SV_blank>%d<S2SV_blank>Overall<S2SV_blank>PSNR=[%2.3f,<S2SV_blank>%2.3f,<S2SV_blank>%2.3f,<S2SV_blank>%2.3f]\\n"" , i , psnr [ 0 ] , psnr [ 1 ] , psnr [ 2 ] , psnr [ 3 ] ) ; svc_log ( svc_ctx , SVC_LOG_INFO , ""Layer<S2SV_blank>%d<S2SV_blank>Overall<S2SV_blank>MSE=[%2.3f,<S2SV_blank>%2.3f,<S2SV_blank>%2.3f,<S2SV_blank>%2.3f]\\n"" , i , mse [ 0 ] , mse [ 1 ] , mse [ 2 ] , mse [ 3 ] ) ; bytes_total += si -> bytes_sum [ i ] ; si -> bytes_sum [ i ] = 0 ; for ( j = 0 ; j < COMPONENTS ; ++ j ) { si -> psnr_sum [ i ] [ j ] = 0 ; si -> sse_sum [ i ] [ j ] = 0 ; } }  si -> encode_frame_count = 0 ;  svc_log ( svc_ctx , SVC_LOG_INFO , ""Total<S2SV_blank>Bytes=[%u]\\n"" , bytes_total ) ; return vpx_svc_get_message ( svc_ctx ) ; }","si -> psnr_pkt_received = 0 ;svc_log ( svc_ctx , SVC_LOG_INFO , ""Total<S2SV_blank>Bytes=[%u]\\\",560
763,"buggy line: static void nsc_rle_decode ( BYTE * in , BYTE * out , UINT32 originalSize )  {cwe id:CWE-787context:  static void nsc_rle_decode ( BYTE * in , BYTE * out , UINT32 originalSize )  { UINT32 len ; UINT32 left ; BYTE value ; left = originalSize ; while ( left > 4 ) { value = * in ++ ; if ( left == 5 ) {  * out ++ = value ;  left -- ; } else if ( value == * in ) { in ++ ; if ( * in < 0xFF ) { len = ( UINT32 ) * in ++ ; len += 2 ; } else { in ++ ; len = * ( ( UINT32 * ) in ) ; in += 4 ; }  FillMemory ( out , len , value ) ;  out += len ; left -= len ; } else {  * out ++ = value ;  left -- ; } } * ( ( UINT32 * ) out ) = * ( ( UINT32 * ) in ) ; }","static BOOL nsc_rle_decode ( BYTE * in , BYTE * out , UINT32 outSize , UINT32 originalSize ) {",561
764,"buggy line: * out ++ = value ;left -- ;cwe id:CWE-787context:  static void nsc_rle_decode ( BYTE * in , BYTE * out , UINT32 originalSize )  { UINT32 len ; UINT32 left ; BYTE value ; left = originalSize ; while ( left > 4 ) { value = * in ++ ; if ( left == 5 ) {  * out ++ = value ;  left -- ; } else if ( value == * in ) { in ++ ; if ( * in < 0xFF ) { len = ( UINT32 ) * in ++ ; len += 2 ; } else { in ++ ; len = * ( ( UINT32 * ) in ) ; in += 4 ; }  FillMemory ( out , len , value ) ;  out += len ; left -= len ; } else {  * out ++ = value ;  left -- ; } } * ( ( UINT32 * ) out ) = * ( ( UINT32 * ) in ) ; }",if ( outSize < 1 ) return FALSE ;outSize -- ;* out ++ = value ;left -- ;,561
765,"buggy line: FillMemory ( out , len , value ) ;out += len ;* out ++ = value ;left -- ;* ( ( UINT32 * ) out ) = * ( ( UINT32 * ) in ) ;cwe id:CWE-787context:  static void nsc_rle_decode ( BYTE * in , BYTE * out , UINT32 originalSize )  { UINT32 len ; UINT32 left ; BYTE value ; left = originalSize ; while ( left > 4 ) { value = * in ++ ; if ( left == 5 ) {  * out ++ = value ;  left -- ; } else if ( value == * in ) { in ++ ; if ( * in < 0xFF ) { len = ( UINT32 ) * in ++ ; len += 2 ; } else { in ++ ; len = * ( ( UINT32 * ) in ) ; in += 4 ; }  FillMemory ( out , len , value ) ;  out += len ; left -= len ; } else {  * out ++ = value ;  left -- ; } } * ( ( UINT32 * ) out ) = * ( ( UINT32 * ) in ) ; }","if ( outSize < len ) return FALSE ;outSize -= len ;FillMemory ( out , len , value ) ;out += len ;if ( outSize < 1 ) return FALSE ;outSize -- ;* out ++ = value ;left -- ;if ( ( outSize < 4 ) || ( left < 4 ) ) return FALSE ;memcpy ( out , in , 4 ) ;return TRUE ;",561
766,"buggy line: if ( screen -> sb_buffer )  vterm_allocator_free ( screen -> vt , screen -> sb_buffer ) ;cwe id:CWE-476context: static int resize ( int new_rows , int new_cols , VTermPos * delta , void * user ) { VTermScreen * screen = user ; int is_altscreen = ( screen -> buffers [ 1 ] && screen -> buffer == screen -> buffers [ 1 ] ) ; int old_rows = screen -> rows ; int old_cols = screen -> cols ; int first_blank_row ; if ( ! is_altscreen && new_rows < old_rows ) { VTermPos pos = { 0 , 0 } ; VTermPos cursor = screen -> state -> pos ; for ( pos . row = old_rows - 1 ; pos . row >= new_rows ; pos . row -- ) if ( ! vterm_screen_is_eol ( screen , pos ) || cursor . row == pos . row ) break ; first_blank_row = pos . row + 1 ; if ( first_blank_row > new_rows ) { VTermRect rect = { 0 , 0 , 0 , 0 } ; rect . end_row = old_rows ; rect . end_col = old_cols ; scrollrect ( rect , first_blank_row - new_rows , 0 , user ) ; vterm_screen_flush_damage ( screen ) ; delta -> row -= first_blank_row - new_rows ; } } screen -> buffers [ 0 ] = realloc_buffer ( screen , screen -> buffers [ 0 ] , new_rows , new_cols ) ; if ( screen -> buffers [ 1 ] ) screen -> buffers [ 1 ] = realloc_buffer ( screen , screen -> buffers [ 1 ] , new_rows , new_cols ) ; screen -> buffer = is_altscreen ? screen -> buffers [ 1 ] : screen -> buffers [ 0 ] ; screen -> rows = new_rows ; screen -> cols = new_cols ;  if ( screen -> sb_buffer )  vterm_allocator_free ( screen -> vt , screen -> sb_buffer ) ; screen -> sb_buffer = vterm_allocator_malloc ( screen -> vt , sizeof ( VTermScreenCell ) * new_cols ) ; if ( new_cols > old_cols ) { VTermRect rect ; rect . start_row = 0 ; rect . end_row = old_rows ; rect . start_col = old_cols ; rect . end_col = new_cols ; damagerect ( screen , rect ) ; } if ( new_rows > old_rows ) { if ( ! is_altscreen && screen -> callbacks && screen -> callbacks -> sb_popline ) { int rows = new_rows - old_rows ; while ( rows ) { VTermRect rect = { 0 , 0 , 0 , 0 } ; VTermPos pos = { 0 , 0 } ; if ( ! ( screen -> callbacks -> sb_popline ( screen -> cols , screen -> sb_buffer , screen -> cbdata ) ) ) break ; rect . end_row = screen -> rows ; rect . end_col = screen -> cols ; scrollrect ( rect , - 1 , 0 , user ) ; for ( pos . col = 0 ; pos . col < screen -> cols ; pos . col += screen -> sb_buffer [ pos . col ] . width ) vterm_screen_set_cell ( screen , pos , screen -> sb_buffer + pos . col ) ; rect . end_row = 1 ; damagerect ( screen , rect ) ; vterm_screen_flush_damage ( screen ) ; rows -- ; delta -> row ++ ; } } { VTermRect rect ; rect . start_row = old_rows ; rect . end_row = new_rows ; rect . start_col = 0 ; rect . end_col = new_cols ; damagerect ( screen , rect ) ; } } if ( screen -> callbacks && screen -> callbacks -> resize ) return ( * screen -> callbacks -> resize ) ( new_rows , new_cols , screen -> cbdata ) ; return 1 ; }","vterm_allocator_free ( screen -> vt , screen -> sb_buffer ) ;",562
767,"buggy line: static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) {const char * literal_start = * str ;const char * literal_end ;int in_named_escape = 0 ;for ( ;char ch = * * str ;if ( ! in_named_escape && ch == \'{\' && ( * str ) - literal_start >= 2 &&  * ( * str - 2 ) == \'\\\\\\\\\' && * ( * str - 1 ) == \'N\' ) {in_named_escape = 0 ;}if ( * str + 1 < end && * ( * str + 1 ) == ch ) {literal_end = * str + 1 ;ast_error ( c , n , ""f-string:<S2SV_blank>single<S2SV_blank>\\\'}return - 1 ;break ;}literal_end = * str ;assert ( * str <= end ) ;assert ( * str == end || * * str == \'{done :  if ( literal_start != literal_end ) {if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start ,  literal_end - literal_start ,  NULL , NULL ) ;else * literal = decode_unicode_with_escapes ( c , n , literal_start ,  literal_end - literal_start ) ;if ( ! * literal ) return - 1 ;cwe id:CWE-125context: static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) {  const char * literal_start = * str ;  const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ;  for ( ; * str < end ; ( * str ) ++ ) {  char ch = * * str ;  if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 &&  * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) {  in_named_escape = 0 ;  } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) {  if ( * str + 1 < end && * ( * str + 1 ) == ch ) {  literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) {  ast_error ( c , n , ""f-string:<S2SV_blank>single<S2SV_blank>\'}\'<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed"" ) ;  return - 1 ; } }  break ;  } }  literal_end = * str ;   assert ( * str <= end ) ;   assert ( * str == end || * * str == '{' || * * str == '}' ) ;  done :  if ( literal_start != literal_end ) {  if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start ,  literal_end - literal_start ,  NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start ,  literal_end - literal_start ) ;  if ( ! * literal ) return - 1 ; } return result ; }","static int fstring_find_literal ( const char * s = * str ;const char * literal_start = s ;for ( ;char ch = * * str ;if ( ! in_named_escape && ch == \'{\' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == \'\\\\\\\\\' && * ( * str - 1 ) == \'N\' ) {in_named_escape = 0 ;}if ( * str + 1 < end && * ( * str + 1 ) == ch ) {literal_end = * str + 1 ;ast_error ( c , n , ""f-string:<S2SV_blank>single<S2SV_blank>\\\'}return - 1 ;}break ;literal_end = * str ;assert ( * str <= end ) ;assert ( * str == end || * * str == \'{done : if ( literal_start != literal_end ) {if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ;while ( s < end ) {char ch = * s ++ ;if ( ! * literal ) return - 1 ;",563
768,"buggy line: static int mem_resize ( jas_stream_memobj_t * m , int bufsize )  {assert ( bufsize >= 0 ) ;JAS_DBGLOG ( 100 , ( ""mem_resize(%p,<S2SV_blank>%d)\\\if ( ! ( buf = jas_realloc2 ( m -> buf_ , bufsize , sizeof ( unsigned char ) ) ) && bufsize ) {cwe id:CWE-190context:  static int mem_resize ( jas_stream_memobj_t * m , int bufsize )  { unsigned char * buf ;  assert ( bufsize >= 0 ) ;   JAS_DBGLOG ( 100 , ( ""mem_resize(%p,<S2SV_blank>%d)\\n"" , m , bufsize ) ) ;  if ( ! ( buf = jas_realloc2 ( m -> buf_ , bufsize , sizeof ( unsigned char ) ) ) && bufsize ) { JAS_DBGLOG ( 100 , ( ""mem_resize<S2SV_blank>realloc<S2SV_blank>failed\\n"" ) ) ; return - 1 ; } JAS_DBGLOG ( 100 , ( ""mem_resize<S2SV_blank>realloc<S2SV_blank>succeeded\\n"" ) ) ; m -> buf_ = buf ; m -> bufsize_ = bufsize ; return 0 ; }","static int mem_resize ( jas_stream_memobj_t * m , size_t bufsize ) {JAS_DBGLOG ( 100 , ( ""mem_resize(%p,<S2SV_blank>%d)\\\if ( ! ( buf = jas_realloc2 ( m -> buf_ , bufsize , sizeof ( unsigned char ) ) ) && bufsize ) {if ( ! bufsize ) {jas_eprintf ( ""mem_resize<S2SV_blank>was<S2SV_blank>not<S2SV_blank>really<S2SV_blank>designed<S2SV_blank>to<S2SV_blank>handle<S2SV_blank>a<S2SV_blank>buffer<S2SV_blank>of<S2SV_blank>size<S2SV_blank>0\\\}",564
769,"buggy line: struct dump_dir * dd = create_dump_dir_from_problem_data ( pd , g_settings_dump_location ) ;char * problem_id = NULL ;cwe id:CWE-200context: char * problem_data_save ( problem_data_t * pd ) { load_abrt_conf ( ) ;  struct dump_dir * dd = create_dump_dir_from_problem_data ( pd , g_settings_dump_location ) ;  char * problem_id = NULL ; if ( dd ) { problem_id = xstrdup ( dd -> dd_dirname ) ; dd_close ( dd ) ; } log_info ( ""problem<S2SV_blank>id:<S2SV_blank>\'%s\'"" , problem_id ) ; return problem_id ; }","struct dump_dir * dd = NULL ;if ( g_settings_privatereports ) dd = create_dump_dir_from_problem_data_ext ( pd , g_settings_dump_location , 0 ) ;else dd = create_dump_dir_from_problem_data ( pd , g_settings_dump_location ) ;char * problem_id = NULL ;",565
770,"buggy line: if ( ! LookupString ( symInterpretMatchMaskNames , pred_txt , pred_rtrn ) ) {log_err ( info -> ctx , ""Illegal<S2SV_blank>modifier<S2SV_blank>predicate<S2SV_blank>\\\\""%s\\\\"";cwe id:CWE-476context: static bool ResolveStateAndPredicate ( ExprDef * expr , enum xkb_match_operation * pred_rtrn , xkb_mod_mask_t * mods_rtrn , CompatInfo * info ) { if ( expr == NULL ) { * pred_rtrn = MATCH_ANY_OR_NONE ; * mods_rtrn = MOD_REAL_MASK_ALL ; return true ; } * pred_rtrn = MATCH_EXACTLY ; if ( expr -> expr . op == EXPR_ACTION_DECL ) { const char * pred_txt = xkb_atom_text ( info -> ctx , expr -> action . name ) ;  if ( ! LookupString ( symInterpretMatchMaskNames , pred_txt , pred_rtrn ) ) {  log_err ( info -> ctx , ""Illegal<S2SV_blank>modifier<S2SV_blank>predicate<S2SV_blank>\\""%s\\"";<S2SV_blank>Ignored\\n"" , pred_txt ) ; return false ; } expr = expr -> action . args ; } else if ( expr -> expr . op == EXPR_IDENT ) { const char * pred_txt = xkb_atom_text ( info -> ctx , expr -> ident . ident ) ; if ( pred_txt && istreq ( pred_txt , ""any"" ) ) { * pred_rtrn = MATCH_ANY ; * mods_rtrn = MOD_REAL_MASK_ALL ; return true ; } } return ExprResolveModMask ( info -> ctx , expr , MOD_REAL , & info -> mods , mods_rtrn ) ; }","if ( ! LookupString ( symInterpretMatchMaskNames , pred_txt , pred_rtrn ) || ! expr -> action . args ) {log_err ( info -> ctx , ""Illegal<S2SV_blank>modifier<S2SV_blank>predicate<S2SV_blank>\\\\""%s\\\\"";",566
771,buggy line: static void pcrypt_free ( struct crypto_instance * inst )  {struct pcrypt_instance_ctx * ctx = crypto_instance_ctx ( inst ) ;crypto_drop_aead ( & ctx -> spawn ) ;cwe id:CWE-763context:  static void pcrypt_free ( struct crypto_instance * inst )  {  struct pcrypt_instance_ctx * ctx = crypto_instance_ctx ( inst ) ;  crypto_drop_aead ( & ctx -> spawn ) ; kfree ( inst ) ; },static void pcrypt_free ( struct aead_instance * inst ) {struct pcrypt_instance_ctx * ctx = aead_instance_ctx ( inst ) ;crypto_drop_aead ( & ctx -> spawn ) ;,567
772,"buggy line: z ++ )  pixel_value += ( srcptr2 [ z ] << ( 8 * z ) ) ;break ;cwe id:CWE-190context: void rfbScaledScreenUpdateRect ( rfbScreenInfoPtr screen , rfbScreenInfoPtr ptr , int x0 , int y0 , int w0 , int h0 ) { int x , y , w , v , z ; int x1 , y1 , w1 , h1 ; int bitsPerPixel , bytesPerPixel , bytesPerLine , areaX , areaY , area2 ; unsigned char * srcptr , * dstptr ; if ( screen == ptr ) return ; x1 = x0 ; y1 = y0 ; w1 = w0 ; h1 = h0 ; rfbScaledCorrection ( screen , ptr , & x1 , & y1 , & w1 , & h1 , ""rfbScaledScreenUpdateRect"" ) ; x0 = ScaleX ( ptr , screen , x1 ) ; y0 = ScaleY ( ptr , screen , y1 ) ; w0 = ScaleX ( ptr , screen , w1 ) ; h0 = ScaleY ( ptr , screen , h1 ) ; bitsPerPixel = screen -> bitsPerPixel ; bytesPerPixel = bitsPerPixel / 8 ; bytesPerLine = w1 * bytesPerPixel ; srcptr = ( unsigned char * ) ( screen -> frameBuffer + ( y0 * screen -> paddedWidthInBytes + x0 * bytesPerPixel ) ) ; dstptr = ( unsigned char * ) ( ptr -> frameBuffer + ( y1 * ptr -> paddedWidthInBytes + x1 * bytesPerPixel ) ) ; areaX = ScaleX ( ptr , screen , 1 ) ; areaY = ScaleY ( ptr , screen , 1 ) ; area2 = areaX * areaY ; if ( ( x1 + w1 ) > ( ptr -> width ) ) { if ( x1 == 0 ) w1 = ptr -> width ; else x1 = ptr -> width - w1 ; } if ( ( y1 + h1 ) > ( ptr -> height ) ) { if ( y1 == 0 ) h1 = ptr -> height ; else y1 = ptr -> height - h1 ; } if ( screen -> serverFormat . trueColour ) { unsigned char * srcptr2 ; unsigned long pixel_value , red , green , blue ; unsigned int redShift = screen -> serverFormat . redShift ; unsigned int greenShift = screen -> serverFormat . greenShift ; unsigned int blueShift = screen -> serverFormat . blueShift ; unsigned long redMax = screen -> serverFormat . redMax ; unsigned long greenMax = screen -> serverFormat . greenMax ; unsigned long blueMax = screen -> serverFormat . blueMax ; for ( y = 0 ; y < h1 ; y ++ ) { for ( x = 0 ; x < w1 ; x ++ ) { red = green = blue = 0 ; for ( w = 0 ; w < areaX ; w ++ ) { for ( v = 0 ; v < areaY ; v ++ ) { srcptr2 = & srcptr [ ( ( ( x * areaX ) + w ) * bytesPerPixel ) + ( v * screen -> paddedWidthInBytes ) ] ; pixel_value = 0 ; switch ( bytesPerPixel ) { case 4 : pixel_value = * ( ( unsigned int * ) srcptr2 ) ; break ; case 2 : pixel_value = * ( ( unsigned short * ) srcptr2 ) ; break ; case 1 : pixel_value = * ( ( unsigned char * ) srcptr2 ) ; break ; default : for ( z = 0 ; z < bytesPerPixel ; z ++ )  pixel_value += ( srcptr2 [ z ] << ( 8 * z ) ) ;  break ; } red += ( ( pixel_value >> redShift ) & redMax ) ; green += ( ( pixel_value >> greenShift ) & greenMax ) ; blue += ( ( pixel_value >> blueShift ) & blueMax ) ; } } red /= area2 ; green /= area2 ; blue /= area2 ; pixel_value = ( ( red & redMax ) << redShift ) | ( ( green & greenMax ) << greenShift ) | ( ( blue & blueMax ) << blueShift ) ; switch ( bytesPerPixel ) { case 4 : * ( ( unsigned int * ) dstptr ) = ( unsigned int ) pixel_value ; break ; case 2 : * ( ( unsigned short * ) dstptr ) = ( unsigned short ) pixel_value ; break ; case 1 : * ( ( unsigned char * ) dstptr ) = ( unsigned char ) pixel_value ; break ; default : for ( z = 0 ; z < bytesPerPixel ; z ++ ) dstptr [ z ] = ( pixel_value >> ( 8 * z ) ) & 0xff ; break ; } dstptr += bytesPerPixel ; } srcptr += ( screen -> paddedWidthInBytes * areaY ) ; dstptr += ( ptr -> paddedWidthInBytes - bytesPerLine ) ; } } else { for ( y = y1 ; y < ( y1 + h1 ) ; y ++ ) { for ( x = x1 ; x < ( x1 + w1 ) ; x ++ ) memcpy ( & ptr -> frameBuffer [ ( y * ptr -> paddedWidthInBytes ) + ( x * bytesPerPixel ) ] , & screen -> frameBuffer [ ( y * areaY * screen -> paddedWidthInBytes ) + ( x * areaX * bytesPerPixel ) ] , bytesPerPixel ) ; } } }",z ++ ) pixel_value += ( ( unsigned long ) srcptr2 [ z ] << ( 8 * z ) ) ;break ;,568
773,"buggy line: if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) )  if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;cwe id:CWE-125context: static Image * ReadSGIImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; SGIInfo iris_info ; size_t bytes_per_pixel , quantum ; ssize_t count , y , z ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } iris_info . magic = ReadBlobMSBShort ( image ) ; do { if ( iris_info . magic != 0x01DA ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; iris_info . storage = ( unsigned char ) ReadBlobByte ( image ) ; switch ( iris_info . storage ) { case 0x00 : image -> compression = NoCompression ; break ; case 0x01 : image -> compression = RLECompression ; break ; default : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } iris_info . bytes_per_pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( iris_info . bytes_per_pixel == 0 ) || ( iris_info . bytes_per_pixel > 2 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; iris_info . dimension = ReadBlobMSBShort ( image ) ; iris_info . columns = ReadBlobMSBShort ( image ) ; iris_info . rows = ReadBlobMSBShort ( image ) ; iris_info . depth = ReadBlobMSBShort ( image ) ; if ( ( iris_info . depth == 0 ) || ( iris_info . depth > 4 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; iris_info . minimum_value = ReadBlobMSBLong ( image ) ; iris_info . maximum_value = ReadBlobMSBLong ( image ) ; iris_info . sans = ReadBlobMSBLong ( image ) ; ( void ) ReadBlob ( image , sizeof ( iris_info . name ) , ( unsigned char * ) iris_info . name ) ; iris_info . name [ sizeof ( iris_info . name ) - 1 ] = '\\0' ; if ( * iris_info . name != '\\0' ) ( void ) SetImageProperty ( image , ""label"" , iris_info . name , exception ) ; iris_info . pixel_format = ReadBlobMSBLong ( image ) ; if ( iris_info . pixel_format != 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; count = ReadBlob ( image , sizeof ( iris_info . filler ) , iris_info . filler ) ; ( void ) count ; image -> columns = iris_info . columns ; image -> rows = iris_info . rows ; image -> depth = ( size_t ) MagickMin ( iris_info . depth , MAGICKCORE_QUANTUM_DEPTH ) ; if ( iris_info . pixel_format == 0 ) image -> depth = ( size_t ) MagickMin ( ( size_t ) 8 * iris_info . bytes_per_pixel , MAGICKCORE_QUANTUM_DEPTH ) ; if ( iris_info . depth < 3 ) { image -> storage_class = PseudoClass ; image -> colors = iris_info . bytes_per_pixel > 1 ? 65535 : 256 ; }  if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) )  if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; bytes_per_pixel = ( size_t ) iris_info . bytes_per_pixel ; number_pixels = ( MagickSizeType ) iris_info . columns * iris_info . rows ; if ( ( 4 * bytes_per_pixel * number_pixels ) != ( ( MagickSizeType ) ( size_t ) ( 4 * bytes_per_pixel * number_pixels ) ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( iris_info . columns , iris_info . rows * 4 * bytes_per_pixel * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; if ( ( int ) iris_info . storage != 0x01 ) { unsigned char * scanline ; scanline = ( unsigned char * ) AcquireQuantumMemory ( iris_info . columns , bytes_per_pixel * sizeof ( * scanline ) ) ; if ( scanline == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( z = 0 ; z < ( ssize_t ) iris_info . depth ; z ++ ) { p = pixels + bytes_per_pixel * z ; for ( y = 0 ; y < ( ssize_t ) iris_info . rows ; y ++ ) { count = ReadBlob ( image , bytes_per_pixel * iris_info . columns , scanline ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; if ( bytes_per_pixel == 2 ) for ( x = 0 ; x < ( ssize_t ) iris_info . columns ; x ++ ) { * p = scanline [ 2 * x ] ; * ( p + 1 ) = scanline [ 2 * x + 1 ] ; p += 8 ; } else for ( x = 0 ; x < ( ssize_t ) iris_info . columns ; x ++ ) { * p = scanline [ x ] ; p += 4 ; } } } scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; } else { MemoryInfo * packet_info ; size_t * runlength ; ssize_t offset , * offsets ; unsigned char * packets ; unsigned int data_order ; offsets = ( ssize_t * ) AcquireQuantumMemory ( ( size_t ) iris_info . rows , iris_info . depth * sizeof ( * offsets ) ) ; runlength = ( size_t * ) AcquireQuantumMemory ( iris_info . rows , iris_info . depth * sizeof ( * runlength ) ) ; packet_info = AcquireVirtualMemory ( ( size_t ) iris_info . columns + 10UL , 4UL * sizeof ( * packets ) ) ; if ( ( offsets == ( ssize_t * ) NULL ) || ( runlength == ( size_t * ) NULL ) || ( packet_info == ( MemoryInfo * ) NULL ) ) { if ( offsets == ( ssize_t * ) NULL ) offsets = ( ssize_t * ) RelinquishMagickMemory ( offsets ) ; if ( runlength == ( size_t * ) NULL ) runlength = ( size_t * ) RelinquishMagickMemory ( runlength ) ; if ( packet_info == ( MemoryInfo * ) NULL ) packet_info = RelinquishVirtualMemory ( packet_info ) ; ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } packets = ( unsigned char * ) GetVirtualMemoryBlob ( packet_info ) ; for ( i = 0 ; i < ( ssize_t ) ( iris_info . rows * iris_info . depth ) ; i ++ ) offsets [ i ] = ReadBlobMSBSignedLong ( image ) ; for ( i = 0 ; i < ( ssize_t ) ( iris_info . rows * iris_info . depth ) ; i ++ ) { runlength [ i ] = ReadBlobMSBLong ( image ) ; if ( runlength [ i ] > ( 4 * ( size_t ) iris_info . columns + 10 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } offset = 0 ; data_order = 0 ; for ( y = 0 ; ( ( y < ( ssize_t ) iris_info . rows ) && ( data_order == 0 ) ) ; y ++ ) for ( z = 0 ; ( ( z < ( ssize_t ) iris_info . depth ) && ( data_order == 0 ) ) ; z ++ ) { if ( offsets [ y + z * iris_info . rows ] < offset ) data_order = 1 ; offset = offsets [ y + z * iris_info . rows ] ; } offset = ( ssize_t ) TellBlob ( image ) ; if ( data_order == 1 ) { for ( z = 0 ; z < ( ssize_t ) iris_info . depth ; z ++ ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) iris_info . rows ; y ++ ) { if ( offset != offsets [ y + z * iris_info . rows ] ) { offset = offsets [ y + z * iris_info . rows ] ; offset = ( ssize_t ) SeekBlob ( image , ( ssize_t ) offset , SEEK_SET ) ; } count = ReadBlob ( image , ( size_t ) runlength [ y + z * iris_info . rows ] , packets ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; offset += ( ssize_t ) runlength [ y + z * iris_info . rows ] ; status = SGIDecode ( bytes_per_pixel , ( ssize_t ) ( runlength [ y + z * iris_info . rows ] / bytes_per_pixel ) , packets , 1L * iris_info . columns , p + bytes_per_pixel * z ) ; if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; p += ( iris_info . columns * 4 * bytes_per_pixel ) ; } } } else { MagickOffsetType position ; position = TellBlob ( image ) ; p = pixels ; for ( y = 0 ; y < ( ssize_t ) iris_info . rows ; y ++ ) { for ( z = 0 ; z < ( ssize_t ) iris_info . depth ; z ++ ) { if ( offset != offsets [ y + z * iris_info . rows ] ) { offset = offsets [ y + z * iris_info . rows ] ; offset = ( ssize_t ) SeekBlob ( image , ( ssize_t ) offset , SEEK_SET ) ; } count = ReadBlob ( image , ( size_t ) runlength [ y + z * iris_info . rows ] , packets ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; offset += ( ssize_t ) runlength [ y + z * iris_info . rows ] ; status = SGIDecode ( bytes_per_pixel , ( ssize_t ) ( runlength [ y + z * iris_info . rows ] / bytes_per_pixel ) , packets , 1L * iris_info . columns , p + bytes_per_pixel * z ) ; if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } p += ( iris_info . columns * 4 * bytes_per_pixel ) ; } offset = ( ssize_t ) SeekBlob ( image , position , SEEK_SET ) ; } packet_info = RelinquishVirtualMemory ( packet_info ) ; runlength = ( size_t * ) RelinquishMagickMemory ( runlength ) ; offsets = ( ssize_t * ) RelinquishMagickMemory ( offsets ) ; } image -> alpha_trait = iris_info . depth == 4 ? BlendPixelTrait : UndefinedPixelTrait ; image -> columns = iris_info . columns ; image -> rows = iris_info . rows ; if ( image -> storage_class == DirectClass ) { if ( bytes_per_pixel == 2 ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 8 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 0 ) << 8 ) | ( * ( p + 1 ) ) ) ) , q ) ; SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 2 ) << 8 ) | ( * ( p + 3 ) ) ) ) , q ) ; SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 4 ) << 8 ) | ( * ( p + 5 ) ) ) ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 6 ) << 8 ) | ( * ( p + 7 ) ) ) ) , q ) ; p += 8 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 4 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * ( p + 1 ) ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * ( p + 2 ) ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * ( p + 3 ) ) , q ) ; p += 4 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( bytes_per_pixel == 2 ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 8 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { quantum = ( * p << 8 ) ; quantum |= ( * ( p + 1 ) ) ; SetPixelIndex ( image , ( Quantum ) quantum , q ) ; p += 8 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 4 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p , q ) ; p += 4 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; } pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; iris_info . magic = ReadBlobMSBShort ( image ) ; if ( iris_info . magic == 0x01DA ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( iris_info . magic == 0x01DA ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;",569
774,"buggy line: in6_dev -> cnf . hop_limit = ra_msg -> icmph . icmp6_hop_limit ;if ( rt ) dst_metric_set ( & rt -> dst , RTAX_HOPLIMIT , ra_msg -> icmph . icmp6_hop_limit ) ;}skip_defrtr : if ( in6_dev -> nd_parms ) {unsigned long rtime = ntohl ( ra_msg -> retrans_timer ) ;if ( rtime && rtime / 1000 < MAX_SCHEDULE_TIMEOUT / HZ ) {rtime = ( rtime * HZ ) / 1000 ;if ( rtime < HZ / 10 ) rtime = HZ / 10 ;NEIGH_VAR_SET ( in6_dev -> nd_parms , RETRANS_TIME , rtime ) ;in6_dev -> tstamp = jiffies ;inet6_ifinfo_notify ( RTM_NEWLINK , in6_dev ) ;}rtime = ntohl ( ra_msg -> reachable_time ) ;if ( rtime && rtime / 1000 < MAX_SCHEDULE_TIMEOUT / ( 3 * HZ ) ) {rtime = ( rtime * HZ ) / 1000 ;if ( rtime < HZ / 10 ) rtime = HZ / 10 ;if ( rtime != NEIGH_VAR ( in6_dev -> nd_parms , BASE_REACHABLE_TIME ) ) {NEIGH_VAR_SET ( in6_dev -> nd_parms , BASE_REACHABLE_TIME , rtime ) ;NEIGH_VAR_SET ( in6_dev -> nd_parms , GC_STALETIME , 3 * rtime ) ;in6_dev -> nd_parms -> reachable_time = neigh_rand_reach_time ( rtime ) ;in6_dev -> tstamp = jiffies ;inet6_ifinfo_notify ( RTM_NEWLINK , in6_dev ) ;}}}skip_linkparms : if ( ! neigh ) neigh = __neigh_lookup ( & nd_tbl , & ipv6_hdr ( skb ) -> saddr , skb -> dev , 1 ) ;if ( neigh ) {u8 * lladdr = NULL ;if ( ndopts . nd_opts_src_lladdr ) {lladdr = ndisc_opt_addr_data ( ndopts . nd_opts_src_lladdr , skb -> dev ) ;if ( ! lladdr ) {ND_PRINTK ( 2 , warn , ""RA:<S2SV_blank>invalid<S2SV_blank>link-layer<S2SV_blank>address<S2SV_blank>length\\\goto out ;}}neigh_update ( neigh , lladdr , NUD_STALE , NEIGH_UPDATE_F_WEAK_OVERRIDE | NEIGH_UPDATE_F_OVERRIDE | NEIGH_UPDATE_F_OVERRIDE_ISROUTER | NEIGH_UPDATE_F_ISROUTER ) ;if ( ! ipv6_accept_ra ( in6_dev ) ) {ND_PRINTK ( 2 , info , ""RA:<S2SV_blank>%s,<S2SV_blank>accept_ra<S2SV_blank>is<S2SV_blank>false<S2SV_blank>for<S2SV_blank>dev:<S2SV_blank>%s\\\goto out ;}# ifdef CONFIG_IPV6_ROUTE_INFO if ( ! in6_dev -> cnf . accept_ra_from_local && ipv6_chk_addr ( dev_net ( in6_dev -> dev ) , & ipv6_hdr ( skb ) -> saddr , NULL , 0 ) ) {ND_PRINTK ( 2 , info , ""RA<S2SV_blank>from<S2SV_blank>local<S2SV_blank>address<S2SV_blank>detected<S2SV_blank>on<S2SV_blank>dev:<S2SV_blank>%s:<S2SV_blank>router<S2SV_blank>info<S2SV_blank>ignored.\\\goto skip_routeinfo ;}if ( in6_dev -> cnf . accept_ra_rtr_pref && ndopts . nd_opts_ri ) {struct nd_opt_hdr * p ;for ( p = ndopts . nd_opts_ri ;p ;p = ndisc_next_option ( p , ndopts . nd_opts_ri_end ) ) {struct route_info * ri = ( struct route_info * ) p ;# ifdef CONFIG_IPV6_NDISC_NODETYPE if ( skb -> ndisc_nodetype == NDISC_NODETYPE_NODEFAULT && ri -> prefix_len == 0 ) continue ;# endif if ( ri -> prefix_len == 0 && ! in6_dev -> cnf . accept_ra_defrtr ) continue ;if ( ri -> prefix_len > in6_dev -> cnf . accept_ra_rt_info_max_plen ) continue ;rt6_route_rcv ( skb -> dev , ( u8 * ) p , ( p -> nd_opt_len ) << 3 , & ipv6_hdr ( skb ) -> saddr ) ;}}skip_routeinfo : # endif # ifdef CONFIG_IPV6_NDISC_NODETYPE if ( skb -> ndisc_nodetype == NDISC_NODETYPE_NODEFAULT ) {ND_PRINTK ( 2 , info , ""RA:<S2SV_blank>%s,<S2SV_blank>nodetype<S2SV_blank>is<S2SV_blank>NODEFAULT<S2SV_blank>(interior<S2SV_blank>routes),<S2SV_blank>dev:<S2SV_blank>%s\\\goto out ;}# endif if ( in6_dev -> cnf . accept_ra_pinfo && ndopts . nd_opts_pi ) {struct nd_opt_hdr * p ;for ( p = ndopts . nd_opts_pi ;p ;p = ndisc_next_option ( p , ndopts . nd_opts_pi_end ) ) {addrconf_prefix_rcv ( skb -> dev , ( u8 * ) p , ( p -> nd_opt_len ) << 3 , ndopts . nd_opts_src_lladdr != NULL ) ;}}if ( ndopts . nd_opts_mtu && in6_dev -> cnf . accept_ra_mtu ) {__be32 n ;u32 mtu ;memcpy ( & n , ( ( u8 * ) ( ndopts . nd_opts_mtu + 1 ) ) + 2 , sizeof ( mtu ) ) ;mtu = ntohl ( n ) ;if ( mtu < IPV6_MIN_MTU || mtu > skb -> dev -> mtu ) {ND_PRINTK ( 2 , warn , ""RA:<S2SV_blank>invalid<S2SV_blank>mtu:<S2SV_blank>%d\\\else if ( in6_dev -> cnf . mtu6 != mtu ) {in6_dev -> cnf . mtu6 = mtu ;cwe id:CWE-17context: static void ndisc_router_discovery ( struct sk_buff * skb ) { struct ra_msg * ra_msg = ( struct ra_msg * ) skb_transport_header ( skb ) ; struct neighbour * neigh = NULL ; struct inet6_dev * in6_dev ; struct rt6_info * rt = NULL ; int lifetime ; struct ndisc_options ndopts ; int optlen ; unsigned int pref = 0 ; __u8 * opt = ( __u8 * ) ( ra_msg + 1 ) ; optlen = ( skb_tail_pointer ( skb ) - skb_transport_header ( skb ) ) - sizeof ( struct ra_msg ) ; ND_PRINTK ( 2 , info , ""RA:<S2SV_blank>%s,<S2SV_blank>dev:<S2SV_blank>%s\\n"" , __func__ , skb -> dev -> name ) ; if ( ! ( ipv6_addr_type ( & ipv6_hdr ( skb ) -> saddr ) & IPV6_ADDR_LINKLOCAL ) ) { ND_PRINTK ( 2 , warn , ""RA:<S2SV_blank>source<S2SV_blank>address<S2SV_blank>is<S2SV_blank>not<S2SV_blank>link-local\\n"" ) ; return ; } if ( optlen < 0 ) { ND_PRINTK ( 2 , warn , ""RA:<S2SV_blank>packet<S2SV_blank>too<S2SV_blank>short\\n"" ) ; return ; } # ifdef CONFIG_IPV6_NDISC_NODETYPE if ( skb -> ndisc_nodetype == NDISC_NODETYPE_HOST ) { ND_PRINTK ( 2 , warn , ""RA:<S2SV_blank>from<S2SV_blank>host<S2SV_blank>or<S2SV_blank>unauthorized<S2SV_blank>router\\n"" ) ; return ; } # endif in6_dev = __in6_dev_get ( skb -> dev ) ; if ( in6_dev == NULL ) { ND_PRINTK ( 0 , err , ""RA:<S2SV_blank>can\'t<S2SV_blank>find<S2SV_blank>inet6<S2SV_blank>device<S2SV_blank>for<S2SV_blank>%s\\n"" , skb -> dev -> name ) ; return ; } if ( ! ndisc_parse_options ( opt , optlen , & ndopts ) ) { ND_PRINTK ( 2 , warn , ""RA:<S2SV_blank>invalid<S2SV_blank>ND<S2SV_blank>options\\n"" ) ; return ; } if ( ! ipv6_accept_ra ( in6_dev ) ) { ND_PRINTK ( 2 , info , ""RA:<S2SV_blank>%s,<S2SV_blank>did<S2SV_blank>not<S2SV_blank>accept<S2SV_blank>ra<S2SV_blank>for<S2SV_blank>dev:<S2SV_blank>%s\\n"" , __func__ , skb -> dev -> name ) ; goto skip_linkparms ; } # ifdef CONFIG_IPV6_NDISC_NODETYPE if ( skb -> ndisc_nodetype == NDISC_NODETYPE_NODEFAULT ) { ND_PRINTK ( 2 , info , ""RA:<S2SV_blank>%s,<S2SV_blank>nodetype<S2SV_blank>is<S2SV_blank>NODEFAULT,<S2SV_blank>dev:<S2SV_blank>%s\\n"" , __func__ , skb -> dev -> name ) ; goto skip_linkparms ; } # endif if ( in6_dev -> if_flags & IF_RS_SENT ) { in6_dev -> if_flags |= IF_RA_RCVD ; } in6_dev -> if_flags = ( in6_dev -> if_flags & ~ ( IF_RA_MANAGED | IF_RA_OTHERCONF ) ) | ( ra_msg -> icmph . icmp6_addrconf_managed ? IF_RA_MANAGED : 0 ) | ( ra_msg -> icmph . icmp6_addrconf_other ? IF_RA_OTHERCONF : 0 ) ; if ( ! in6_dev -> cnf . accept_ra_defrtr ) { ND_PRINTK ( 2 , info , ""RA:<S2SV_blank>%s,<S2SV_blank>defrtr<S2SV_blank>is<S2SV_blank>false<S2SV_blank>for<S2SV_blank>dev:<S2SV_blank>%s\\n"" , __func__ , skb -> dev -> name ) ; goto skip_defrtr ; } if ( ! in6_dev -> cnf . accept_ra_from_local && ipv6_chk_addr ( dev_net ( in6_dev -> dev ) , & ipv6_hdr ( skb ) -> saddr , NULL , 0 ) ) { ND_PRINTK ( 2 , info , ""RA<S2SV_blank>from<S2SV_blank>local<S2SV_blank>address<S2SV_blank>detected<S2SV_blank>on<S2SV_blank>dev:<S2SV_blank>%s:<S2SV_blank>default<S2SV_blank>router<S2SV_blank>ignored\\n"" , skb -> dev -> name ) ; goto skip_defrtr ; } lifetime = ntohs ( ra_msg -> icmph . icmp6_rt_lifetime ) ; # ifdef CONFIG_IPV6_ROUTER_PREF pref = ra_msg -> icmph . icmp6_router_pref ; if ( pref == ICMPV6_ROUTER_PREF_INVALID || ! in6_dev -> cnf . accept_ra_rtr_pref ) pref = ICMPV6_ROUTER_PREF_MEDIUM ; # endif rt = rt6_get_dflt_router ( & ipv6_hdr ( skb ) -> saddr , skb -> dev ) ; if ( rt ) { neigh = dst_neigh_lookup ( & rt -> dst , & ipv6_hdr ( skb ) -> saddr ) ; if ( ! neigh ) { ND_PRINTK ( 0 , err , ""RA:<S2SV_blank>%s<S2SV_blank>got<S2SV_blank>default<S2SV_blank>router<S2SV_blank>without<S2SV_blank>neighbour\\n"" , __func__ ) ; ip6_rt_put ( rt ) ; return ; } } if ( rt && lifetime == 0 ) { ip6_del_rt ( rt ) ; rt = NULL ; } ND_PRINTK ( 3 , info , ""RA:<S2SV_blank>rt:<S2SV_blank>%p<S2SV_blank><S2SV_blank>lifetime:<S2SV_blank>%d,<S2SV_blank>for<S2SV_blank>dev:<S2SV_blank>%s\\n"" , rt , lifetime , skb -> dev -> name ) ; if ( rt == NULL && lifetime ) { ND_PRINTK ( 3 , info , ""RA:<S2SV_blank>adding<S2SV_blank>default<S2SV_blank>router\\n"" ) ; rt = rt6_add_dflt_router ( & ipv6_hdr ( skb ) -> saddr , skb -> dev , pref ) ; if ( rt == NULL ) { ND_PRINTK ( 0 , err , ""RA:<S2SV_blank>%s<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>add<S2SV_blank>default<S2SV_blank>route\\n"" , __func__ ) ; return ; } neigh = dst_neigh_lookup ( & rt -> dst , & ipv6_hdr ( skb ) -> saddr ) ; if ( neigh == NULL ) { ND_PRINTK ( 0 , err , ""RA:<S2SV_blank>%s<S2SV_blank>got<S2SV_blank>default<S2SV_blank>router<S2SV_blank>without<S2SV_blank>neighbour\\n"" , __func__ ) ; ip6_rt_put ( rt ) ; return ; } neigh -> flags |= NTF_ROUTER ; } else if ( rt ) { rt -> rt6i_flags = ( rt -> rt6i_flags & ~ RTF_PREF_MASK ) | RTF_PREF ( pref ) ; } if ( rt ) rt6_set_expires ( rt , jiffies + ( HZ * lifetime ) ) ; if ( ra_msg -> icmph . icmp6_hop_limit ) {  in6_dev -> cnf . hop_limit = ra_msg -> icmph . icmp6_hop_limit ;  if ( rt ) dst_metric_set ( & rt -> dst , RTAX_HOPLIMIT , ra_msg -> icmph . icmp6_hop_limit ) ; } skip_defrtr : if ( in6_dev -> nd_parms ) { unsigned long rtime = ntohl ( ra_msg -> retrans_timer ) ; if ( rtime && rtime / 1000 < MAX_SCHEDULE_TIMEOUT / HZ ) { rtime = ( rtime * HZ ) / 1000 ; if ( rtime < HZ / 10 ) rtime = HZ / 10 ; NEIGH_VAR_SET ( in6_dev -> nd_parms , RETRANS_TIME , rtime ) ; in6_dev -> tstamp = jiffies ; inet6_ifinfo_notify ( RTM_NEWLINK , in6_dev ) ; } rtime = ntohl ( ra_msg -> reachable_time ) ; if ( rtime && rtime / 1000 < MAX_SCHEDULE_TIMEOUT / ( 3 * HZ ) ) { rtime = ( rtime * HZ ) / 1000 ; if ( rtime < HZ / 10 ) rtime = HZ / 10 ; if ( rtime != NEIGH_VAR ( in6_dev -> nd_parms , BASE_REACHABLE_TIME ) ) { NEIGH_VAR_SET ( in6_dev -> nd_parms , BASE_REACHABLE_TIME , rtime ) ; NEIGH_VAR_SET ( in6_dev -> nd_parms , GC_STALETIME , 3 * rtime ) ; in6_dev -> nd_parms -> reachable_time = neigh_rand_reach_time ( rtime ) ; in6_dev -> tstamp = jiffies ; inet6_ifinfo_notify ( RTM_NEWLINK , in6_dev ) ; } } } skip_linkparms : if ( ! neigh ) neigh = __neigh_lookup ( & nd_tbl , & ipv6_hdr ( skb ) -> saddr , skb -> dev , 1 ) ; if ( neigh ) { u8 * lladdr = NULL ; if ( ndopts . nd_opts_src_lladdr ) { lladdr = ndisc_opt_addr_data ( ndopts . nd_opts_src_lladdr , skb -> dev ) ; if ( ! lladdr ) { ND_PRINTK ( 2 , warn , ""RA:<S2SV_blank>invalid<S2SV_blank>link-layer<S2SV_blank>address<S2SV_blank>length\\n"" ) ; goto out ; } } neigh_update ( neigh , lladdr , NUD_STALE , NEIGH_UPDATE_F_WEAK_OVERRIDE | NEIGH_UPDATE_F_OVERRIDE | NEIGH_UPDATE_F_OVERRIDE_ISROUTER | NEIGH_UPDATE_F_ISROUTER ) ; } if ( ! ipv6_accept_ra ( in6_dev ) ) { ND_PRINTK ( 2 , info , ""RA:<S2SV_blank>%s,<S2SV_blank>accept_ra<S2SV_blank>is<S2SV_blank>false<S2SV_blank>for<S2SV_blank>dev:<S2SV_blank>%s\\n"" , __func__ , skb -> dev -> name ) ; goto out ; } # ifdef CONFIG_IPV6_ROUTE_INFO if ( ! in6_dev -> cnf . accept_ra_from_local && ipv6_chk_addr ( dev_net ( in6_dev -> dev ) , & ipv6_hdr ( skb ) -> saddr , NULL , 0 ) ) { ND_PRINTK ( 2 , info , ""RA<S2SV_blank>from<S2SV_blank>local<S2SV_blank>address<S2SV_blank>detected<S2SV_blank>on<S2SV_blank>dev:<S2SV_blank>%s:<S2SV_blank>router<S2SV_blank>info<S2SV_blank>ignored.\\n"" , skb -> dev -> name ) ; goto skip_routeinfo ; } if ( in6_dev -> cnf . accept_ra_rtr_pref && ndopts . nd_opts_ri ) { struct nd_opt_hdr * p ; for ( p = ndopts . nd_opts_ri ; p ; p = ndisc_next_option ( p , ndopts . nd_opts_ri_end ) ) { struct route_info * ri = ( struct route_info * ) p ; # ifdef CONFIG_IPV6_NDISC_NODETYPE if ( skb -> ndisc_nodetype == NDISC_NODETYPE_NODEFAULT && ri -> prefix_len == 0 ) continue ; # endif if ( ri -> prefix_len == 0 && ! in6_dev -> cnf . accept_ra_defrtr ) continue ; if ( ri -> prefix_len > in6_dev -> cnf . accept_ra_rt_info_max_plen ) continue ; rt6_route_rcv ( skb -> dev , ( u8 * ) p , ( p -> nd_opt_len ) << 3 , & ipv6_hdr ( skb ) -> saddr ) ; } } skip_routeinfo : # endif # ifdef CONFIG_IPV6_NDISC_NODETYPE if ( skb -> ndisc_nodetype == NDISC_NODETYPE_NODEFAULT ) { ND_PRINTK ( 2 , info , ""RA:<S2SV_blank>%s,<S2SV_blank>nodetype<S2SV_blank>is<S2SV_blank>NODEFAULT<S2SV_blank>(interior<S2SV_blank>routes),<S2SV_blank>dev:<S2SV_blank>%s\\n"" , __func__ , skb -> dev -> name ) ; goto out ; } # endif if ( in6_dev -> cnf . accept_ra_pinfo && ndopts . nd_opts_pi ) { struct nd_opt_hdr * p ; for ( p = ndopts . nd_opts_pi ; p ; p = ndisc_next_option ( p , ndopts . nd_opts_pi_end ) ) { addrconf_prefix_rcv ( skb -> dev , ( u8 * ) p , ( p -> nd_opt_len ) << 3 , ndopts . nd_opts_src_lladdr != NULL ) ; } } if ( ndopts . nd_opts_mtu && in6_dev -> cnf . accept_ra_mtu ) { __be32 n ; u32 mtu ; memcpy ( & n , ( ( u8 * ) ( ndopts . nd_opts_mtu + 1 ) ) + 2 , sizeof ( mtu ) ) ; mtu = ntohl ( n ) ; if ( mtu < IPV6_MIN_MTU || mtu > skb -> dev -> mtu ) { ND_PRINTK ( 2 , warn , ""RA:<S2SV_blank>invalid<S2SV_blank>mtu:<S2SV_blank>%d\\n"" , mtu ) ; } else if ( in6_dev -> cnf . mtu6 != mtu ) { in6_dev -> cnf . mtu6 = mtu ; if ( rt ) dst_metric_set ( & rt -> dst , RTAX_MTU , mtu ) ; rt6_mtu_change ( skb -> dev , mtu ) ; } } if ( ndopts . nd_useropts ) { struct nd_opt_hdr * p ; for ( p = ndopts . nd_useropts ; p ; p = ndisc_next_useropt ( p , ndopts . nd_useropts_end ) ) { ndisc_ra_useropt ( skb , p ) ; } } if ( ndopts . nd_opts_tgt_lladdr || ndopts . nd_opts_rh ) { ND_PRINTK ( 2 , warn , ""RA:<S2SV_blank>invalid<S2SV_blank>RA<S2SV_blank>options\\n"" ) ; } out : ip6_rt_put ( rt ) ; if ( neigh ) neigh_release ( neigh ) ; }","if ( in6_dev -> cnf . hop_limit < ra_msg -> icmph . icmp6_hop_limit ;if ( rt ) dst_metric_set ( & rt -> dst , RTAX_HOPLIMIT , ra_msg -> icmph . icmp6_hop_limit ) {in6_dev -> cnf . hop_limit = ra_msg -> icmph . icmp6_hop_limit ;else {ND_PRINTK ( 2 , warn , ""RA:<S2SV_blank>Got<S2SV_blank>route<S2SV_blank>advertisement<S2SV_blank>with<S2SV_blank>lower<S2SV_blank>hop_limit<S2SV_blank>than<S2SV_blank>current\\\",570
775,"buggy line: static void  l2tp_proxy_auth_id_print ( netdissect_options * ndo , const u_char * dat )  {const uint16_t * ptr = ( const uint16_t * ) dat ;ND_PRINT ( ( ndo , ""%u"" , EXTRACT_16BITS ( ptr ) & L2TP_PROXY_AUTH_ID_MASK ) ) ;cwe id:CWE-125context: static void  l2tp_proxy_auth_id_print ( netdissect_options * ndo , const u_char * dat )  {  const uint16_t * ptr = ( const uint16_t * ) dat ;  ND_PRINT ( ( ndo , ""%u"" , EXTRACT_16BITS ( ptr ) & L2TP_PROXY_AUTH_ID_MASK ) ) ; }","static void l2tp_proxy_auth_id_print ( netdissect_options * ndo , const u_char * dat , u_int length ) {const uint16_t * ptr = ( const uint16_t * ) dat ;if ( length < 2 ) {ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;return ;}ND_PRINT ( ( ndo , ""%u"" , EXTRACT_16BITS ( ptr ) & L2TP_PROXY_AUTH_ID_MASK ) ) ;",571
776,"buggy line: if ( ! replay_esn || ! rp )  return 0 ;if ( xfrm_replay_state_esn_len ( replay_esn ) !=   xfrm_replay_state_esn_len ( up ) )  return - EINVAL ;cwe id:CWE-200context: static inline int xfrm_replay_verify_len ( struct xfrm_replay_state_esn * replay_esn , struct nlattr * rp ) { struct xfrm_replay_state_esn * up ;  if ( ! replay_esn || ! rp )  return 0 ; up = nla_data ( rp ) ;  if ( xfrm_replay_state_esn_len ( replay_esn ) !=   xfrm_replay_state_esn_len ( up ) )  return - EINVAL ; return 0 ; }",int ulen ;if ( ! replay_esn || ! rp ) return 0 ;ulen = xfrm_replay_state_esn_len ( up ) ;if ( nla_len ( rp ) < ulen || xfrm_replay_state_esn_len ( replay_esn ) != ulen ) return - EINVAL ;,572
777,"buggy line: int ret = proc_dointvec ( table , write , buffer , lenp , ppos ) ;if ( ret || ! write ) return ret ;cwe id:CWE-190context: int perf_cpu_time_max_percent_handler ( struct ctl_table * table , int write , void __user * buffer , size_t * lenp , loff_t * ppos ) {  int ret = proc_dointvec ( table , write , buffer , lenp , ppos ) ;  if ( ret || ! write ) return ret ; if ( sysctl_perf_cpu_time_max_percent == 100 || sysctl_perf_cpu_time_max_percent == 0 ) { printk ( KERN_WARNING ""perf:<S2SV_blank>Dynamic<S2SV_blank>interrupt<S2SV_blank>throttling<S2SV_blank>disabled,<S2SV_blank>can<S2SV_blank>hang<S2SV_blank>your<S2SV_blank>system!\\n"" ) ; WRITE_ONCE ( perf_sample_allowed_ns , 0 ) ; } else { update_perf_cpu_limits ( ) ; } return 0 ; }","int ret = proc_dointvec_minmax ( table , write , buffer , lenp , ppos ) ;if ( ret || ! write ) return ret ;",573
778,"buggy line: bestsad = fn_ptr -> sdf ( what , what_stride , bestaddress ,  in_what_stride , UINT_MAX )  + mvsad_err_cost ( best_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ;cwe id:CWE-119context: int vp8_full_search_sadx3 ( MACROBLOCK * x , BLOCK * b , BLOCKD * d , int_mv * ref_mv , int sad_per_bit , int distance , vp8_variance_fn_ptr_t * fn_ptr , int * mvcost [ 2 ] , int_mv * center_mv ) { unsigned char * what = ( * ( b -> base_src ) + b -> src ) ; int what_stride = b -> src_stride ; unsigned char * in_what ; int pre_stride = x -> e_mbd . pre . y_stride ; unsigned char * base_pre = x -> e_mbd . pre . y_buffer ; int in_what_stride = pre_stride ; int mv_stride = pre_stride ; unsigned char * bestaddress ; int_mv * best_mv = & d -> bmi . mv ; int_mv this_mv ; unsigned int bestsad ; unsigned int thissad ; int r , c ; unsigned char * check_here ; int ref_row = ref_mv -> as_mv . row ; int ref_col = ref_mv -> as_mv . col ; int row_min = ref_row - distance ; int row_max = ref_row + distance ; int col_min = ref_col - distance ; int col_max = ref_col + distance ; unsigned int sad_array [ 3 ] ; int * mvsadcost [ 2 ] ; int_mv fcenter_mv ; mvsadcost [ 0 ] = x -> mvsadcost [ 0 ] ; mvsadcost [ 1 ] = x -> mvsadcost [ 1 ] ; fcenter_mv . as_mv . row = center_mv -> as_mv . row >> 3 ; fcenter_mv . as_mv . col = center_mv -> as_mv . col >> 3 ; in_what = base_pre + d -> offset ; bestaddress = in_what + ( ref_row * pre_stride ) + ref_col ; best_mv -> as_mv . row = ref_row ; best_mv -> as_mv . col = ref_col ; bestsad = fn_ptr -> sdf ( what , what_stride , bestaddress ,  in_what_stride , UINT_MAX )  + mvsad_err_cost ( best_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ; if ( col_min < x -> mv_col_min ) col_min = x -> mv_col_min ; if ( col_max > x -> mv_col_max ) col_max = x -> mv_col_max ; if ( row_min < x -> mv_row_min ) row_min = x -> mv_row_min ; if ( row_max > x -> mv_row_max ) row_max = x -> mv_row_max ; for ( r = row_min ; r < row_max ; r ++ ) { this_mv . as_mv . row = r ; check_here = r * mv_stride + in_what + col_min ; c = col_min ; while ( ( c + 2 ) < col_max ) { int i ; fn_ptr -> sdx3f ( what , what_stride , check_here , in_what_stride , sad_array ) ; for ( i = 0 ; i < 3 ; i ++ ) { thissad = sad_array [ i ] ; if ( thissad < bestsad ) { this_mv . as_mv . col = c ; thissad += mvsad_err_cost ( & this_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ; if ( thissad < bestsad ) { bestsad = thissad ; best_mv -> as_mv . row = r ; best_mv -> as_mv . col = c ; bestaddress = check_here ; } } check_here ++ ; c ++ ; } } while ( c < col_max ) {  thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ;  if ( thissad < bestsad ) { this_mv . as_mv . col = c ; thissad += mvsad_err_cost ( & this_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ; if ( thissad < bestsad ) { bestsad = thissad ; best_mv -> as_mv . row = r ; best_mv -> as_mv . col = c ; bestaddress = check_here ; } } check_here ++ ; c ++ ; } } this_mv . as_mv . row = best_mv -> as_mv . row << 3 ; this_mv . as_mv . col = best_mv -> as_mv . col << 3 ; return fn_ptr -> vf ( what , what_stride , bestaddress , in_what_stride , & thissad ) + mv_err_cost ( & this_mv , center_mv , mvcost , x -> errorperbit ) ; }","bestsad = fn_ptr -> sdf ( what , what_stride , bestaddress , in_what_stride ) + mvsad_err_cost ( best_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ;",574
779,"buggy line: fn_ptr -> sdx3f ( what , what_stride , check_here , in_what_stride , sad_array ) ;for ( i = 0 ;i < 3 ;i ++ ) {thissad = sad_array [ i ] ;if ( thissad < bestsad ) {this_mv . as_mv . col = c ;thissad += mvsad_err_cost ( & this_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ;cwe id:CWE-119context: int vp8_full_search_sadx3 ( MACROBLOCK * x , BLOCK * b , BLOCKD * d , int_mv * ref_mv , int sad_per_bit , int distance , vp8_variance_fn_ptr_t * fn_ptr , int * mvcost [ 2 ] , int_mv * center_mv ) { unsigned char * what = ( * ( b -> base_src ) + b -> src ) ; int what_stride = b -> src_stride ; unsigned char * in_what ; int pre_stride = x -> e_mbd . pre . y_stride ; unsigned char * base_pre = x -> e_mbd . pre . y_buffer ; int in_what_stride = pre_stride ; int mv_stride = pre_stride ; unsigned char * bestaddress ; int_mv * best_mv = & d -> bmi . mv ; int_mv this_mv ; unsigned int bestsad ; unsigned int thissad ; int r , c ; unsigned char * check_here ; int ref_row = ref_mv -> as_mv . row ; int ref_col = ref_mv -> as_mv . col ; int row_min = ref_row - distance ; int row_max = ref_row + distance ; int col_min = ref_col - distance ; int col_max = ref_col + distance ; unsigned int sad_array [ 3 ] ; int * mvsadcost [ 2 ] ; int_mv fcenter_mv ; mvsadcost [ 0 ] = x -> mvsadcost [ 0 ] ; mvsadcost [ 1 ] = x -> mvsadcost [ 1 ] ; fcenter_mv . as_mv . row = center_mv -> as_mv . row >> 3 ; fcenter_mv . as_mv . col = center_mv -> as_mv . col >> 3 ; in_what = base_pre + d -> offset ; bestaddress = in_what + ( ref_row * pre_stride ) + ref_col ; best_mv -> as_mv . row = ref_row ; best_mv -> as_mv . col = ref_col ; bestsad = fn_ptr -> sdf ( what , what_stride , bestaddress ,  in_what_stride , UINT_MAX )  + mvsad_err_cost ( best_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ; if ( col_min < x -> mv_col_min ) col_min = x -> mv_col_min ; if ( col_max > x -> mv_col_max ) col_max = x -> mv_col_max ; if ( row_min < x -> mv_row_min ) row_min = x -> mv_row_min ; if ( row_max > x -> mv_row_max ) row_max = x -> mv_row_max ; for ( r = row_min ; r < row_max ; r ++ ) { this_mv . as_mv . row = r ; check_here = r * mv_stride + in_what + col_min ; c = col_min ; while ( ( c + 2 ) < col_max ) { int i ; fn_ptr -> sdx3f ( what , what_stride , check_here , in_what_stride , sad_array ) ; for ( i = 0 ; i < 3 ; i ++ ) { thissad = sad_array [ i ] ; if ( thissad < bestsad ) { this_mv . as_mv . col = c ; thissad += mvsad_err_cost ( & this_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ; if ( thissad < bestsad ) { bestsad = thissad ; best_mv -> as_mv . row = r ; best_mv -> as_mv . col = c ; bestaddress = check_here ; } } check_here ++ ; c ++ ; } } while ( c < col_max ) {  thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ;  if ( thissad < bestsad ) { this_mv . as_mv . col = c ; thissad += mvsad_err_cost ( & this_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ; if ( thissad < bestsad ) { bestsad = thissad ; best_mv -> as_mv . row = r ; best_mv -> as_mv . col = c ; bestaddress = check_here ; } } check_here ++ ; c ++ ; } } this_mv . as_mv . row = best_mv -> as_mv . row << 3 ; this_mv . as_mv . col = best_mv -> as_mv . col << 3 ; return fn_ptr -> vf ( what , what_stride , bestaddress , in_what_stride , & thissad ) + mv_err_cost ( & this_mv , center_mv , mvcost , x -> errorperbit ) ; }","fn_ptr -> sdx3f ( what , what_stride , check_here , in_what_stride ) ;",574
780,"buggy line: thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ;if ( thissad < bestsad ) {cwe id:CWE-119context: int vp8_full_search_sadx3 ( MACROBLOCK * x , BLOCK * b , BLOCKD * d , int_mv * ref_mv , int sad_per_bit , int distance , vp8_variance_fn_ptr_t * fn_ptr , int * mvcost [ 2 ] , int_mv * center_mv ) { unsigned char * what = ( * ( b -> base_src ) + b -> src ) ; int what_stride = b -> src_stride ; unsigned char * in_what ; int pre_stride = x -> e_mbd . pre . y_stride ; unsigned char * base_pre = x -> e_mbd . pre . y_buffer ; int in_what_stride = pre_stride ; int mv_stride = pre_stride ; unsigned char * bestaddress ; int_mv * best_mv = & d -> bmi . mv ; int_mv this_mv ; unsigned int bestsad ; unsigned int thissad ; int r , c ; unsigned char * check_here ; int ref_row = ref_mv -> as_mv . row ; int ref_col = ref_mv -> as_mv . col ; int row_min = ref_row - distance ; int row_max = ref_row + distance ; int col_min = ref_col - distance ; int col_max = ref_col + distance ; unsigned int sad_array [ 3 ] ; int * mvsadcost [ 2 ] ; int_mv fcenter_mv ; mvsadcost [ 0 ] = x -> mvsadcost [ 0 ] ; mvsadcost [ 1 ] = x -> mvsadcost [ 1 ] ; fcenter_mv . as_mv . row = center_mv -> as_mv . row >> 3 ; fcenter_mv . as_mv . col = center_mv -> as_mv . col >> 3 ; in_what = base_pre + d -> offset ; bestaddress = in_what + ( ref_row * pre_stride ) + ref_col ; best_mv -> as_mv . row = ref_row ; best_mv -> as_mv . col = ref_col ; bestsad = fn_ptr -> sdf ( what , what_stride , bestaddress ,  in_what_stride , UINT_MAX )  + mvsad_err_cost ( best_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ; if ( col_min < x -> mv_col_min ) col_min = x -> mv_col_min ; if ( col_max > x -> mv_col_max ) col_max = x -> mv_col_max ; if ( row_min < x -> mv_row_min ) row_min = x -> mv_row_min ; if ( row_max > x -> mv_row_max ) row_max = x -> mv_row_max ; for ( r = row_min ; r < row_max ; r ++ ) { this_mv . as_mv . row = r ; check_here = r * mv_stride + in_what + col_min ; c = col_min ; while ( ( c + 2 ) < col_max ) { int i ; fn_ptr -> sdx3f ( what , what_stride , check_here , in_what_stride , sad_array ) ; for ( i = 0 ; i < 3 ; i ++ ) { thissad = sad_array [ i ] ; if ( thissad < bestsad ) { this_mv . as_mv . col = c ; thissad += mvsad_err_cost ( & this_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ; if ( thissad < bestsad ) { bestsad = thissad ; best_mv -> as_mv . row = r ; best_mv -> as_mv . col = c ; bestaddress = check_here ; } } check_here ++ ; c ++ ; } } while ( c < col_max ) {  thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ;  if ( thissad < bestsad ) { this_mv . as_mv . col = c ; thissad += mvsad_err_cost ( & this_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ; if ( thissad < bestsad ) { bestsad = thissad ; best_mv -> as_mv . row = r ; best_mv -> as_mv . col = c ; bestaddress = check_here ; } } check_here ++ ; c ++ ; } } this_mv . as_mv . row = best_mv -> as_mv . row << 3 ; this_mv . as_mv . col = best_mv -> as_mv . col << 3 ; return fn_ptr -> vf ( what , what_stride , bestaddress , in_what_stride , & thissad ) + mv_err_cost ( & this_mv , center_mv , mvcost , x -> errorperbit ) ; }","thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ;if ( thissad < bestsad ) {",574
781,"buggy line: l_current_pi -> include = ( OPJ_INT16 * ) opj_calloc ( ( l_tcp -> numlayers + 1 ) * l_step_l , sizeof ( OPJ_INT16 ) ) ;if  ( ! l_current_pi -> include ) {cwe id:CWE-125context: opj_pi_iterator_t * opj_pi_create_decode ( opj_image_t * p_image , opj_cp_t * p_cp , OPJ_UINT32 p_tile_no ) { OPJ_UINT32 pino ; OPJ_UINT32 compno , resno ; OPJ_UINT32 * l_tmp_data ; OPJ_UINT32 * * l_tmp_ptr ; OPJ_UINT32 l_max_res ; OPJ_UINT32 l_max_prec ; OPJ_INT32 l_tx0 , l_tx1 , l_ty0 , l_ty1 ; OPJ_UINT32 l_dx_min , l_dy_min ; OPJ_UINT32 l_bound ; OPJ_UINT32 l_step_p , l_step_c , l_step_r , l_step_l ; OPJ_UINT32 l_data_stride ; opj_pi_iterator_t * l_pi = 00 ; opj_tcp_t * l_tcp = 00 ; const opj_tccp_t * l_tccp = 00 ; opj_pi_comp_t * l_current_comp = 00 ; opj_image_comp_t * l_img_comp = 00 ; opj_pi_iterator_t * l_current_pi = 00 ; OPJ_UINT32 * l_encoding_value_ptr = 00 ; assert ( p_cp != 00 ) ; assert ( p_image != 00 ) ; assert ( p_tile_no < p_cp -> tw * p_cp -> th ) ; l_tcp = & p_cp -> tcps [ p_tile_no ] ; l_bound = l_tcp -> numpocs + 1 ; l_data_stride = 4 * OPJ_J2K_MAXRLVLS ; l_tmp_data = ( OPJ_UINT32 * ) opj_malloc ( l_data_stride * p_image -> numcomps * sizeof ( OPJ_UINT32 ) ) ; if ( ! l_tmp_data ) { return 00 ; } l_tmp_ptr = ( OPJ_UINT32 * * ) opj_malloc ( p_image -> numcomps * sizeof ( OPJ_UINT32 * ) ) ; if ( ! l_tmp_ptr ) { opj_free ( l_tmp_data ) ; return 00 ; } l_pi = opj_pi_create ( p_image , p_cp , p_tile_no ) ; if ( ! l_pi ) { opj_free ( l_tmp_data ) ; opj_free ( l_tmp_ptr ) ; return 00 ; } l_encoding_value_ptr = l_tmp_data ; for ( compno = 0 ; compno < p_image -> numcomps ; ++ compno ) { l_tmp_ptr [ compno ] = l_encoding_value_ptr ; l_encoding_value_ptr += l_data_stride ; } opj_get_all_encoding_parameters ( p_image , p_cp , p_tile_no , & l_tx0 , & l_tx1 , & l_ty0 , & l_ty1 , & l_dx_min , & l_dy_min , & l_max_prec , & l_max_res , l_tmp_ptr ) ; l_step_p = 1 ; l_step_c = l_max_prec * l_step_p ; l_step_r = p_image -> numcomps * l_step_c ; l_step_l = l_max_res * l_step_r ; l_current_pi = l_pi ;  l_current_pi -> include = ( OPJ_INT16 * ) opj_calloc ( ( l_tcp -> numlayers + 1 ) * l_step_l , sizeof ( OPJ_INT16 ) ) ;   if  ( ! l_current_pi -> include ) { opj_free ( l_tmp_data ) ; opj_free ( l_tmp_ptr ) ; opj_pi_destroy ( l_pi , l_bound ) ; return 00 ; } l_current_comp = l_current_pi -> comps ; l_img_comp = p_image -> comps ; l_tccp = l_tcp -> tccps ; l_current_pi -> tx0 = l_tx0 ; l_current_pi -> ty0 = l_ty0 ; l_current_pi -> tx1 = l_tx1 ; l_current_pi -> ty1 = l_ty1 ; l_current_pi -> step_p = l_step_p ; l_current_pi -> step_c = l_step_c ; l_current_pi -> step_r = l_step_r ; l_current_pi -> step_l = l_step_l ; for ( compno = 0 ; compno < l_current_pi -> numcomps ; ++ compno ) { opj_pi_resolution_t * l_res = l_current_comp -> resolutions ; l_encoding_value_ptr = l_tmp_ptr [ compno ] ; l_current_comp -> dx = l_img_comp -> dx ; l_current_comp -> dy = l_img_comp -> dy ; for ( resno = 0 ; resno < l_current_comp -> numresolutions ; resno ++ ) { l_res -> pdx = * ( l_encoding_value_ptr ++ ) ; l_res -> pdy = * ( l_encoding_value_ptr ++ ) ; l_res -> pw = * ( l_encoding_value_ptr ++ ) ; l_res -> ph = * ( l_encoding_value_ptr ++ ) ; ++ l_res ; } ++ l_current_comp ; ++ l_img_comp ; ++ l_tccp ; } ++ l_current_pi ; for ( pino = 1 ; pino < l_bound ; ++ pino ) { l_current_comp = l_current_pi -> comps ; l_img_comp = p_image -> comps ; l_tccp = l_tcp -> tccps ; l_current_pi -> tx0 = l_tx0 ; l_current_pi -> ty0 = l_ty0 ; l_current_pi -> tx1 = l_tx1 ; l_current_pi -> ty1 = l_ty1 ; l_current_pi -> step_p = l_step_p ; l_current_pi -> step_c = l_step_c ; l_current_pi -> step_r = l_step_r ; l_current_pi -> step_l = l_step_l ; for ( compno = 0 ; compno < l_current_pi -> numcomps ; ++ compno ) { opj_pi_resolution_t * l_res = l_current_comp -> resolutions ; l_encoding_value_ptr = l_tmp_ptr [ compno ] ; l_current_comp -> dx = l_img_comp -> dx ; l_current_comp -> dy = l_img_comp -> dy ; for ( resno = 0 ; resno < l_current_comp -> numresolutions ; resno ++ ) { l_res -> pdx = * ( l_encoding_value_ptr ++ ) ; l_res -> pdy = * ( l_encoding_value_ptr ++ ) ; l_res -> pw = * ( l_encoding_value_ptr ++ ) ; l_res -> ph = * ( l_encoding_value_ptr ++ ) ; ++ l_res ; } ++ l_current_comp ; ++ l_img_comp ; ++ l_tccp ; } l_current_pi -> include = ( l_current_pi - 1 ) -> include ; ++ l_current_pi ; } opj_free ( l_tmp_data ) ; l_tmp_data = 00 ; opj_free ( l_tmp_ptr ) ; l_tmp_ptr = 00 ; if ( l_tcp -> POC ) { opj_pi_update_decode_poc ( l_pi , l_tcp , l_max_prec , l_max_res ) ; } else { opj_pi_update_decode_not_poc ( l_pi , l_tcp , l_max_prec , l_max_res ) ; } return l_pi ; }","l_current_pi -> include = 00 ;if ( l_step_l <= ( SIZE_MAX / ( l_tcp -> numlayers + 1U ) ) ) {l_current_pi -> include = ( OPJ_INT16 * ) opj_calloc ( ( l_tcp -> numlayers + 1 ) * l_step_l , sizeof ( OPJ_INT16 ) ) ;}if ( ! l_current_pi -> include ) {",575
782,"buggy line: return try_then_request_module ( __crypto_lookup_template ( name ) , ""%s"" ,  name ) ;cwe id:CWE-269context: struct crypto_template * crypto_lookup_template ( const char * name ) {  return try_then_request_module ( __crypto_lookup_template ( name ) , ""%s"" ,  name ) ; }","return try_then_request_module ( __crypto_lookup_template ( name ) , ""crypto-%s"" , name ) ;",576
783,"buggy line: int start = 0 ;u32 prev_legacy , cur_legacy ;kvm_pit_load_count ( kvm , 0 , kvm -> arch . vpit -> pit_state . channels [ 0 ] . count , start ) ;mutex_unlock ( & kvm -> arch . vpit -> pit_state . lock ) ;cwe id:CWE-000context: static int kvm_vm_ioctl_set_pit2 ( struct kvm * kvm , struct kvm_pit_state2 * ps ) {  int start = 0 ;  u32 prev_legacy , cur_legacy ; mutex_lock ( & kvm -> arch . vpit -> pit_state . lock ) ; prev_legacy = kvm -> arch . vpit -> pit_state . flags & KVM_PIT_FLAGS_HPET_LEGACY ; cur_legacy = ps -> flags & KVM_PIT_FLAGS_HPET_LEGACY ; if ( ! prev_legacy && cur_legacy ) start = 1 ; memcpy ( & kvm -> arch . vpit -> pit_state . channels , & ps -> channels , sizeof ( kvm -> arch . vpit -> pit_state . channels ) ) ; kvm -> arch . vpit -> pit_state . flags = ps -> flags ;  kvm_pit_load_count ( kvm , 0 , kvm -> arch . vpit -> pit_state . channels [ 0 ] . count , start ) ;  mutex_unlock ( & kvm -> arch . vpit -> pit_state . lock ) ; return 0 ; }","int start = 0 ;int i ;u32 prev_legacy , cur_legacy ;for ( i = 0 ;i < 3 ;i ++ ) kvm_pit_load_count ( kvm , i , kvm -> arch . vpit -> pit_state . channels [ i ] . count , start ) ;mutex_unlock ( & kvm -> arch . vpit -> pit_state . lock ) ;",577
784,"buggy line: static void encode_nonrd_sb_row ( VP9_COMP * cpi , const TileInfo * const tile ,  int mi_row , TOKENEXTRA * * tp ) {VP9_COMMON * cm = & cpi -> common ;MACROBLOCKD * xd = & cpi -> mb . e_mbd ;vpx_memset ( & xd -> left_context , 0 , sizeof ( xd -> left_context ) ) ;vpx_memset ( xd -> left_seg_context , 0 , sizeof ( xd -> left_seg_context ) ) ;for ( mi_col = tile -> mi_col_start ;mi_col += MI_BLOCK_SIZE ) {int dummy_rate = 0 ;int64_t dummy_dist = 0 ;MODE_INFO * * mi_8x8 = cm -> mi_grid_visible + idx_str ;MODE_INFO * * prev_mi_8x8 = cm -> prev_mi_grid_visible + idx_str ;BLOCK_SIZE bsize ;cpi -> mb . source_variance = UINT_MAX ;vp9_zero ( cpi -> mb . pred_mv ) ;switch ( cpi -> sf . partition_search_type ) {case VAR_BASED_PARTITION :  choose_partitioning ( cpi , tile , mi_row , mi_col ) ;nonrd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , BLOCK_64X64 ,   1 , & dummy_rate , & dummy_dist ) ;break ;case SOURCE_VAR_BASED_PARTITION :  set_offsets ( cpi , tile , mi_row , mi_col , BLOCK_64X64 ) ;set_source_var_based_partition ( cpi , tile , mi_8x8 , mi_row , mi_col ) ;nonrd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , BLOCK_64X64 ,   1 , & dummy_rate , & dummy_dist ) ;break ;case VAR_BASED_FIXED_PARTITION :  case FIXED_PARTITION :  bsize = cpi -> sf . partition_search_type == FIXED_PARTITION ?  cpi -> sf . always_this_block_size : get_nonrd_var_based_fixed_partition ( cpi , mi_row , mi_col ) ;set_fixed_partitioning ( cpi , tile , mi_8x8 , mi_row , mi_col , bsize ) ;nonrd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , BLOCK_64X64 ,   1 , & dummy_rate , & dummy_dist ) ;break ;case REFERENCE_PARTITION :  if ( cpi -> sf . partition_check || sb_has_motion ( cm , prev_mi_8x8 ) ) {nonrd_pick_partition ( cpi , tile , tp , mi_row , mi_col , BLOCK_64X64 ,   & dummy_rate , & dummy_dist , 1 , INT64_MAX ) ;}else {copy_partitioning ( cm , mi_8x8 , prev_mi_8x8 ) ;nonrd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col ,   BLOCK_64X64 , 1 , & dummy_rate , & dummy_dist ) ;}}}cwe id:CWE-119context:  static void encode_nonrd_sb_row ( VP9_COMP * cpi , const TileInfo * const tile ,  int mi_row , TOKENEXTRA * * tp ) { VP9_COMMON * cm = & cpi -> common ; MACROBLOCKD * xd = & cpi -> mb . e_mbd ; int mi_col ;  vpx_memset ( & xd -> left_context , 0 , sizeof ( xd -> left_context ) ) ;  vpx_memset ( xd -> left_seg_context , 0 , sizeof ( xd -> left_seg_context ) ) ;  for ( mi_col = tile -> mi_col_start ; mi_col < tile -> mi_col_end ;  mi_col += MI_BLOCK_SIZE ) {  int dummy_rate = 0 ;  int64_t dummy_dist = 0 ; const int idx_str = cm -> mi_stride * mi_row + mi_col ;  MODE_INFO * * mi_8x8 = cm -> mi_grid_visible + idx_str ;   MODE_INFO * * prev_mi_8x8 = cm -> prev_mi_grid_visible + idx_str ;   BLOCK_SIZE bsize ;  cpi -> mb . source_variance = UINT_MAX ;  vp9_zero ( cpi -> mb . pred_mv ) ;   switch ( cpi -> sf . partition_search_type ) {  case VAR_BASED_PARTITION :  choose_partitioning ( cpi , tile , mi_row , mi_col ) ;   nonrd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , BLOCK_64X64 ,   1 , & dummy_rate , & dummy_dist ) ;  break ; case SOURCE_VAR_BASED_PARTITION :  set_offsets ( cpi , tile , mi_row , mi_col , BLOCK_64X64 ) ;   set_source_var_based_partition ( cpi , tile , mi_8x8 , mi_row , mi_col ) ;   nonrd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , BLOCK_64X64 ,   1 , & dummy_rate , & dummy_dist ) ;  break ;  case VAR_BASED_FIXED_PARTITION :  case FIXED_PARTITION :  bsize = cpi -> sf . partition_search_type == FIXED_PARTITION ?  cpi -> sf . always_this_block_size : get_nonrd_var_based_fixed_partition ( cpi , mi_row , mi_col ) ;  set_fixed_partitioning ( cpi , tile , mi_8x8 , mi_row , mi_col , bsize ) ;   nonrd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , BLOCK_64X64 ,   1 , & dummy_rate , & dummy_dist ) ;  break ; case REFERENCE_PARTITION :  if ( cpi -> sf . partition_check || sb_has_motion ( cm , prev_mi_8x8 ) ) {   nonrd_pick_partition ( cpi , tile , tp , mi_row , mi_col , BLOCK_64X64 ,   & dummy_rate , & dummy_dist , 1 , INT64_MAX ) ;  } else {  copy_partitioning ( cm , mi_8x8 , prev_mi_8x8 ) ;   nonrd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col ,   BLOCK_64X64 , 1 , & dummy_rate , & dummy_dist ) ;  } break ; default : assert ( 0 ) ;  }  } }","static void encode_nonrd_sb_row ( VP9_COMP * cpi , ThreadData * td , TileDataEnc * tile_data , int mi_row , TOKENEXTRA * * tp ) {SPEED_FEATURES * const sf = & cpi -> sf ;VP9_COMMON * const cm = & cpi -> common ;TileInfo * const tile_info = & tile_data -> tile_info ;MACROBLOCK * const x = & td -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;memset ( & xd -> left_context ) ) ;memset ( xd -> left_seg_context ) ) ;vpx_memset ( xd -> left_seg_context , 0 , sizeof ( xd -> left_seg_context ) ) ;for ( mi_col = tile_info -> mi_col_start ;mi_col += MI_BLOCK_SIZE ) {const struct segmentation * const seg = & cm -> seg ;RD_COST dummy_rdc ;MODE_INFO * * mi = cm -> mi_grid_visible + idx_str ;PARTITION_SEARCH_TYPE partition_search_type = sf -> partition_search_type ;BLOCK_SIZE bsize ;cpi -> mb . source_variance = UINT_MAX ;vp9_zero ( x -> pred_mv ) ;switch ( cpi -> sf . partition_search_type ) {case VAR_BASED_PARTITION : choose_partitioning ( cpi , tile_info , x , mi_row , mi_col ) ;nonrd_use_partition ( cpi , td , tile_data , mi , tp , mi_row , mi_col , BLOCK_64X64 , 1 , & dummy_rate , & dummy_dist ) ;break ;case SOURCE_VAR_BASED_PARTITION : set_offsets ( cpi , tile , mi_row , mi_col , BLOCK_64X64 ) ;set_source_var_based_partition ( cpi , tile , mi_8x8 , mi_row , mi_col ) ;nonrd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , BLOCK_64X64 , 1 , & dummy_rdc , td -> pc_root ) ;break ;case VAR_BASED_FIXED_PARTITION : case FIXED_PARTITION : bsize = cpi -> sf . partition_search_type == FIXED_PARTITION ? cpi -> sf . always_this_block_size : get_nonrd_var_based_fixed_partition ( cpi , tile_info , x , mi , mi_row , mi_col , bsize ) ;nonrd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , BLOCK_64X64 , 1 , & dummy_rate , & dummy_dist ) ;break ;case REFERENCE_PARTITION : if ( cpi -> sf . partition_check || sb_has_motion ( cm , prev_mi_8x8 ) ) {nonrd_pick_partition ( cpi , td , tile_data , mi , tp , mi_row , mi_col , BLOCK_64X64 , 1 , & dummy_rate , & dummy_dist ) ;}break ;}}",578
785,"buggy line: pipe_buf_get ( ipipe , ibuf ) ;obuf = opipe -> bufs + nbuf ;cwe id:CWE-416context: static int link_pipe ( struct pipe_inode_info * ipipe , struct pipe_inode_info * opipe , size_t len , unsigned int flags ) { struct pipe_buffer * ibuf , * obuf ; int ret = 0 , i = 0 , nbuf ; pipe_double_lock ( ipipe , opipe ) ; do { if ( ! opipe -> readers ) { send_sig ( SIGPIPE , current , 0 ) ; if ( ! ret ) ret = - EPIPE ; break ; } if ( i >= ipipe -> nrbufs || opipe -> nrbufs >= opipe -> buffers ) break ; ibuf = ipipe -> bufs + ( ( ipipe -> curbuf + i ) & ( ipipe -> buffers - 1 ) ) ; nbuf = ( opipe -> curbuf + opipe -> nrbufs ) & ( opipe -> buffers - 1 ) ;  pipe_buf_get ( ipipe , ibuf ) ;  obuf = opipe -> bufs + nbuf ; * obuf = * ibuf ; obuf -> flags &= ~ PIPE_BUF_FLAG_GIFT ; if ( obuf -> len > len ) obuf -> len = len ; opipe -> nrbufs ++ ; ret += obuf -> len ; len -= obuf -> len ; i ++ ; } while ( len ) ; if ( ! ret && ipipe -> waiting_writers && ( flags & SPLICE_F_NONBLOCK ) ) ret = - EAGAIN ; pipe_unlock ( ipipe ) ; pipe_unlock ( opipe ) ; if ( ret > 0 ) wakeup_pipe_readers ( opipe ) ; return ret ; }","if ( ! pipe_buf_get ( ipipe , ibuf ) ) {if ( ret == 0 ) ret = - EFAULT ;break ;}obuf = opipe -> bufs + nbuf ;",579
786,"buggy line: dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ;BUG_ON ( dh == NULL ) ;cwe id:CWE-20context: static bool dccp_new ( struct nf_conn * ct , const struct sk_buff * skb , unsigned int dataoff , unsigned int * timeouts ) { struct net * net = nf_ct_net ( ct ) ; struct dccp_net * dn ; struct dccp_hdr _dh , * dh ; const char * msg ; u_int8_t state ;  dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ;  BUG_ON ( dh == NULL ) ; state = dccp_state_table [ CT_DCCP_ROLE_CLIENT ] [ dh -> dccph_type ] [ CT_DCCP_NONE ] ; switch ( state ) { default : dn = dccp_pernet ( net ) ; if ( dn -> dccp_loose == 0 ) { msg = ""nf_ct_dccp:<S2SV_blank>not<S2SV_blank>picking<S2SV_blank>up<S2SV_blank>existing<S2SV_blank>connection<S2SV_blank>"" ; goto out_invalid ; } case CT_DCCP_REQUEST : break ; case CT_DCCP_INVALID : msg = ""nf_ct_dccp:<S2SV_blank>invalid<S2SV_blank>state<S2SV_blank>transition<S2SV_blank>"" ; goto out_invalid ; } ct -> proto . dccp . role [ IP_CT_DIR_ORIGINAL ] = CT_DCCP_ROLE_CLIENT ; ct -> proto . dccp . role [ IP_CT_DIR_REPLY ] = CT_DCCP_ROLE_SERVER ; ct -> proto . dccp . state = CT_DCCP_NONE ; ct -> proto . dccp . last_pkt = DCCP_PKT_REQUEST ; ct -> proto . dccp . last_dir = IP_CT_DIR_ORIGINAL ; ct -> proto . dccp . handshake_seq = 0 ; return true ; out_invalid : if ( LOG_INVALID ( net , IPPROTO_DCCP ) ) nf_log_packet ( net , nf_ct_l3num ( ct ) , 0 , skb , NULL , NULL , NULL , ""%s"" , msg ) ; return false ; }","dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & _dh ) ;BUG_ON ( dh == NULL ) ;",580
787,"buggy line: Fp = fopen ( filename , ""wb"" ) ;if ( Fp == NULL )  return HTTP_UNAUTHORIZED ;}cwe id:CWE-284context: static int http_RecvPostMessage ( http_parser_t * parser , SOCKINFO * info , char * filename , struct SendInstruction * Instr ) { size_t Data_Buf_Size = 1024 ; char Buf [ 1024 ] ; int Timeout = - 1 ; FILE * Fp ; parse_status_t status = PARSE_OK ; int ok_on_close = FALSE ; size_t entity_offset = 0 ; int num_read = 0 ; int ret_code = HTTP_OK ; if ( Instr && Instr -> IsVirtualFile ) { Fp = ( virtualDirCallback . open ) ( filename , UPNP_WRITE ) ; if ( Fp == NULL ) return HTTP_INTERNAL_SERVER_ERROR ; } else {  Fp = fopen ( filename , ""wb"" ) ;  if ( Fp == NULL )  return HTTP_UNAUTHORIZED ;  } parser -> position = POS_ENTITY ; do { if ( parser -> position != POS_COMPLETE ) status = parser_parse_entity ( parser ) ; if ( status == PARSE_INCOMPLETE_ENTITY ) { ok_on_close = TRUE ; } else if ( ( status != PARSE_SUCCESS ) && ( status != PARSE_CONTINUE_1 ) && ( status != PARSE_INCOMPLETE ) ) { ret_code = HTTP_BAD_REQUEST ; goto ExitFunction ; } while ( entity_offset + Data_Buf_Size > parser -> msg . entity . length && parser -> position != POS_COMPLETE ) { num_read = sock_read ( info , Buf , sizeof ( Buf ) , & Timeout ) ; if ( num_read > 0 ) { if ( membuffer_append ( & parser -> msg . msg , Buf , ( size_t ) num_read ) != 0 ) { parser -> http_error_code = HTTP_INTERNAL_SERVER_ERROR ; ret_code = HTTP_INTERNAL_SERVER_ERROR ; goto ExitFunction ; } status = parser_parse_entity ( parser ) ; if ( status == PARSE_INCOMPLETE_ENTITY ) { ok_on_close = TRUE ; } else if ( ( status != PARSE_SUCCESS ) && ( status != PARSE_CONTINUE_1 ) && ( status != PARSE_INCOMPLETE ) ) { ret_code = HTTP_BAD_REQUEST ; goto ExitFunction ; } } else if ( num_read == 0 ) { if ( ok_on_close ) { UpnpPrintf ( UPNP_INFO , HTTP , __FILE__ , __LINE__ , ""<<<<S2SV_blank>(RECVD)<S2SV_blank><<<\\n%s\\n-----------------\\n"" , parser -> msg . msg . buf ) ; print_http_headers ( & parser -> msg ) ; parser -> position = POS_COMPLETE ; } else { parser -> http_error_code = HTTP_BAD_REQUEST ; ret_code = HTTP_BAD_REQUEST ; goto ExitFunction ; } } else { ret_code = HTTP_SERVICE_UNAVAILABLE ; goto ExitFunction ; } } if ( ( entity_offset + Data_Buf_Size ) > parser -> msg . entity . length ) { Data_Buf_Size = parser -> msg . entity . length - entity_offset ; } memcpy ( Buf , & parser -> msg . msg . buf [ parser -> entity_start_position + entity_offset ] , Data_Buf_Size ) ; entity_offset += Data_Buf_Size ; if ( Instr && Instr -> IsVirtualFile ) { int n = virtualDirCallback . write ( Fp , Buf , Data_Buf_Size ) ; if ( n < 0 ) { ret_code = HTTP_INTERNAL_SERVER_ERROR ; goto ExitFunction ; } } else { size_t n = fwrite ( Buf , 1 , Data_Buf_Size , Fp ) ; if ( n != Data_Buf_Size ) { ret_code = HTTP_INTERNAL_SERVER_ERROR ; goto ExitFunction ; } } } while ( parser -> position != POS_COMPLETE || entity_offset != parser -> msg . entity . length ) ; ExitFunction : if ( Instr && Instr -> IsVirtualFile ) { virtualDirCallback . close ( Fp ) ; } else { fclose ( Fp ) ; } return ret_code ; }","# ifdef UPNP_ENABLE_POST_WRITE Fp = fopen ( filename , ""wb"" ) ;if ( Fp == NULL ) return HTTP_UNAUTHORIZED ;# else return HTTP_NOT_FOUND ;# endif }",581
788,"buggy line: char * dir = ""/etc"" ;if ( ( fd = xfmkstemp ( & tmpname , dir ) ) == NULL ) {ulckpwdf ( ) ;cwe id:CWE-000context: static FILE * pw_tmpfile ( int lockfd ) { FILE * fd ; char * tmpname = NULL ;  char * dir = ""/etc"" ;   if ( ( fd = xfmkstemp ( & tmpname , dir ) ) == NULL ) {  ulckpwdf ( ) ; err ( EXIT_FAILURE , _ ( ""can\'t<S2SV_blank>open<S2SV_blank>temporary<S2SV_blank>file"" ) ) ; } copyfile ( lockfd , fileno ( fd ) ) ; tmp_file = tmpname ; return fd ; }","if ( ( fd = xfmkstemp ( & tmpname , dir ) ) == NULL ) {ulckpwdf ( ) ;",582
789,"buggy line: if ( IS_ERR ( blkg ) ) {blkg_free ( new_blkg ) ;return PTR_ERR ( blkg ) ;}q -> root_blkg = blkg ;cwe id:CWE-415context: int blkcg_init_queue ( struct request_queue * q ) { struct blkcg_gq * new_blkg , * blkg ; bool preloaded ; int ret ; new_blkg = blkg_alloc ( & blkcg_root , q , GFP_KERNEL ) ; if ( ! new_blkg ) return - ENOMEM ; preloaded = ! radix_tree_preload ( GFP_KERNEL ) ; rcu_read_lock ( ) ; spin_lock_irq ( q -> queue_lock ) ; blkg = blkg_create ( & blkcg_root , q , new_blkg ) ; spin_unlock_irq ( q -> queue_lock ) ; rcu_read_unlock ( ) ; if ( preloaded ) radix_tree_preload_end ( ) ;  if ( IS_ERR ( blkg ) ) {  blkg_free ( new_blkg ) ; return PTR_ERR ( blkg ) ;  }  q -> root_blkg = blkg ; q -> root_rl . blkg = blkg ; ret = blk_throtl_init ( q ) ; if ( ret ) { spin_lock_irq ( q -> queue_lock ) ; blkg_destroy_all ( q ) ; spin_unlock_irq ( q -> queue_lock ) ; } return ret ; }",if ( IS_ERR ( blkg ) ) return PTR_ERR ( blkg ) ;}q -> root_blkg = blkg ;,583
790,"buggy line: if ( buf_size < XWD_HEADER_SIZE ) return AVERROR_INVALIDDATA ;cwe id:CWE-119context: static int xwd_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) { AVFrame * p = data ; const uint8_t * buf = avpkt -> data ; int i , ret , buf_size = avpkt -> size ; uint32_t version , header_size , vclass , ncolors ; uint32_t xoffset , be , bpp , lsize , rsize ; uint32_t pixformat , pixdepth , bunit , bitorder , bpad ; uint32_t rgb [ 3 ] ; uint8_t * ptr ; GetByteContext gb ; if ( buf_size < XWD_HEADER_SIZE ) return AVERROR_INVALIDDATA ; bytestream2_init ( & gb , buf , buf_size ) ; header_size = bytestream2_get_be32u ( & gb ) ; version = bytestream2_get_be32u ( & gb ) ; if ( version != XWD_VERSION ) { av_log ( avctx , AV_LOG_ERROR , ""unsupported<S2SV_blank>version\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( buf_size < header_size || header_size < XWD_HEADER_SIZE ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>header<S2SV_blank>size\\n"" ) ; return AVERROR_INVALIDDATA ; } pixformat = bytestream2_get_be32u ( & gb ) ; pixdepth = bytestream2_get_be32u ( & gb ) ; avctx -> width = bytestream2_get_be32u ( & gb ) ; avctx -> height = bytestream2_get_be32u ( & gb ) ; xoffset = bytestream2_get_be32u ( & gb ) ; be = bytestream2_get_be32u ( & gb ) ; bunit = bytestream2_get_be32u ( & gb ) ; bitorder = bytestream2_get_be32u ( & gb ) ; bpad = bytestream2_get_be32u ( & gb ) ; bpp = bytestream2_get_be32u ( & gb ) ; lsize = bytestream2_get_be32u ( & gb ) ; vclass = bytestream2_get_be32u ( & gb ) ; rgb [ 0 ] = bytestream2_get_be32u ( & gb ) ; rgb [ 1 ] = bytestream2_get_be32u ( & gb ) ; rgb [ 2 ] = bytestream2_get_be32u ( & gb ) ; bytestream2_skipu ( & gb , 8 ) ; ncolors = bytestream2_get_be32u ( & gb ) ; bytestream2_skipu ( & gb , header_size - ( XWD_HEADER_SIZE - 20 ) ) ; av_log ( avctx , AV_LOG_DEBUG , ""pixformat<S2SV_blank>%"" PRIu32 "",<S2SV_blank>pixdepth<S2SV_blank>%"" PRIu32 "",<S2SV_blank>bunit<S2SV_blank>%"" PRIu32 "",<S2SV_blank>bitorder<S2SV_blank>%"" PRIu32 "",<S2SV_blank>bpad<S2SV_blank>%"" PRIu32 ""\\n"" , pixformat , pixdepth , bunit , bitorder , bpad ) ; av_log ( avctx , AV_LOG_DEBUG , ""vclass<S2SV_blank>%"" PRIu32 "",<S2SV_blank>ncolors<S2SV_blank>%"" PRIu32 "",<S2SV_blank>bpp<S2SV_blank>%"" PRIu32 "",<S2SV_blank>be<S2SV_blank>%"" PRIu32 "",<S2SV_blank>lsize<S2SV_blank>%"" PRIu32 "",<S2SV_blank>xoffset<S2SV_blank>%"" PRIu32 ""\\n"" , vclass , ncolors , bpp , be , lsize , xoffset ) ; av_log ( avctx , AV_LOG_DEBUG , ""red<S2SV_blank>%0"" PRIx32 "",<S2SV_blank>green<S2SV_blank>%0"" PRIx32 "",<S2SV_blank>blue<S2SV_blank>%0"" PRIx32 ""\\n"" , rgb [ 0 ] , rgb [ 1 ] , rgb [ 2 ] ) ; if ( pixformat > XWD_Z_PIXMAP ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>pixmap<S2SV_blank>format\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( pixdepth == 0 || pixdepth > 32 ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>pixmap<S2SV_blank>depth\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( xoffset ) { avpriv_request_sample ( avctx , ""xoffset<S2SV_blank>%"" PRIu32 """" , xoffset ) ; return AVERROR_PATCHWELCOME ; } if ( be > 1 ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>byte<S2SV_blank>order\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( bitorder > 1 ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>bitmap<S2SV_blank>bit<S2SV_blank>order\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( bunit != 8 && bunit != 16 && bunit != 32 ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>bitmap<S2SV_blank>unit\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( bpad != 8 && bpad != 16 && bpad != 32 ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>bitmap<S2SV_blank>scan-line<S2SV_blank>pad\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( bpp == 0 || bpp > 32 ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>bits<S2SV_blank>per<S2SV_blank>pixel\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( ncolors > 256 ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>entries<S2SV_blank>in<S2SV_blank>colormap\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( ( ret = av_image_check_size ( avctx -> width , avctx -> height , 0 , NULL ) ) < 0 ) return ret ; rsize = FFALIGN ( avctx -> width * bpp , bpad ) / 8 ; if ( lsize < rsize ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>scan-line\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( bytestream2_get_bytes_left ( & gb ) < ncolors * XWD_CMAP_SIZE + ( uint64_t ) avctx -> height * lsize ) { av_log ( avctx , AV_LOG_ERROR , ""input<S2SV_blank>buffer<S2SV_blank>too<S2SV_blank>small\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( pixformat != XWD_Z_PIXMAP ) { avpriv_report_missing_feature ( avctx , ""Pixmap<S2SV_blank>format<S2SV_blank>%"" PRIu32 , pixformat ) ; return AVERROR_PATCHWELCOME ; } avctx -> pix_fmt = AV_PIX_FMT_NONE ; switch ( vclass ) { case XWD_STATIC_GRAY : case XWD_GRAY_SCALE : if ( bpp != 1 && bpp != 8 ) return AVERROR_INVALIDDATA ;  if ( pixdepth == 1 ) {  avctx -> pix_fmt = AV_PIX_FMT_MONOWHITE ;  } else if ( pixdepth == 8 ) {  avctx -> pix_fmt = AV_PIX_FMT_GRAY8 ; } break ; case XWD_STATIC_COLOR : case XWD_PSEUDO_COLOR : if ( bpp == 8 ) avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; break ; case XWD_TRUE_COLOR : case XWD_DIRECT_COLOR : if ( bpp != 16 && bpp != 24 && bpp != 32 ) return AVERROR_INVALIDDATA ; if ( bpp == 16 && pixdepth == 15 ) { if ( rgb [ 0 ] == 0x7C00 && rgb [ 1 ] == 0x3E0 && rgb [ 2 ] == 0x1F ) avctx -> pix_fmt = be ? AV_PIX_FMT_RGB555BE : AV_PIX_FMT_RGB555LE ; else if ( rgb [ 0 ] == 0x1F && rgb [ 1 ] == 0x3E0 && rgb [ 2 ] == 0x7C00 ) avctx -> pix_fmt = be ? AV_PIX_FMT_BGR555BE : AV_PIX_FMT_BGR555LE ; } else if ( bpp == 16 && pixdepth == 16 ) { if ( rgb [ 0 ] == 0xF800 && rgb [ 1 ] == 0x7E0 && rgb [ 2 ] == 0x1F ) avctx -> pix_fmt = be ? AV_PIX_FMT_RGB565BE : AV_PIX_FMT_RGB565LE ; else if ( rgb [ 0 ] == 0x1F && rgb [ 1 ] == 0x7E0 && rgb [ 2 ] == 0xF800 ) avctx -> pix_fmt = be ? AV_PIX_FMT_BGR565BE : AV_PIX_FMT_BGR565LE ; } else if ( bpp == 24 ) { if ( rgb [ 0 ] == 0xFF0000 && rgb [ 1 ] == 0xFF00 && rgb [ 2 ] == 0xFF ) avctx -> pix_fmt = be ? AV_PIX_FMT_RGB24 : AV_PIX_FMT_BGR24 ; else if ( rgb [ 0 ] == 0xFF && rgb [ 1 ] == 0xFF00 && rgb [ 2 ] == 0xFF0000 ) avctx -> pix_fmt = be ? AV_PIX_FMT_BGR24 : AV_PIX_FMT_RGB24 ; } else if ( bpp == 32 ) { if ( rgb [ 0 ] == 0xFF0000 && rgb [ 1 ] == 0xFF00 && rgb [ 2 ] == 0xFF ) avctx -> pix_fmt = be ? AV_PIX_FMT_ARGB : AV_PIX_FMT_BGRA ; else if ( rgb [ 0 ] == 0xFF && rgb [ 1 ] == 0xFF00 && rgb [ 2 ] == 0xFF0000 ) avctx -> pix_fmt = be ? AV_PIX_FMT_ABGR : AV_PIX_FMT_RGBA ; } bytestream2_skipu ( & gb , ncolors * XWD_CMAP_SIZE ) ; break ; default : av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>visual<S2SV_blank>class\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( avctx -> pix_fmt == AV_PIX_FMT_NONE ) { avpriv_request_sample ( avctx , ""Unknown<S2SV_blank>file:<S2SV_blank>bpp<S2SV_blank>%"" PRIu32 "",<S2SV_blank>pixdepth<S2SV_blank>%"" PRIu32 "",<S2SV_blank>vclass<S2SV_blank>%"" PRIu32 """" , bpp , pixdepth , vclass ) ; return AVERROR_PATCHWELCOME ; } if ( ( ret = ff_get_buffer ( avctx , p , 0 ) ) < 0 ) return ret ; p -> key_frame = 1 ; p -> pict_type = AV_PICTURE_TYPE_I ; if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 ) { uint32_t * dst = ( uint32_t * ) p -> data [ 1 ] ; uint8_t red , green , blue ; for ( i = 0 ; i < ncolors ; i ++ ) { bytestream2_skipu ( & gb , 4 ) ; red = bytestream2_get_byteu ( & gb ) ; bytestream2_skipu ( & gb , 1 ) ; green = bytestream2_get_byteu ( & gb ) ; bytestream2_skipu ( & gb , 1 ) ; blue = bytestream2_get_byteu ( & gb ) ; bytestream2_skipu ( & gb , 3 ) ; dst [ i ] = red << 16 | green << 8 | blue ; } } ptr = p -> data [ 0 ] ; for ( i = 0 ; i < avctx -> height ; i ++ ) { bytestream2_get_bufferu ( & gb , ptr , rsize ) ; bytestream2_skipu ( & gb , lsize - rsize ) ; ptr += p -> linesize [ 0 ] ; } * got_frame = 1 ; return buf_size ; }",if ( bpp == 1 && buf_size < XWD_HEADER_SIZE ) return AVERROR_INVALIDDATA ;,584
791,"buggy line: if ( pixdepth == 1 ) {avctx -> pix_fmt = AV_PIX_FMT_MONOWHITE ;}else if ( pixdepth == 8 ) {avctx -> pix_fmt = AV_PIX_FMT_GRAY8 ;cwe id:CWE-119context: static int xwd_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) { AVFrame * p = data ; const uint8_t * buf = avpkt -> data ; int i , ret , buf_size = avpkt -> size ; uint32_t version , header_size , vclass , ncolors ; uint32_t xoffset , be , bpp , lsize , rsize ; uint32_t pixformat , pixdepth , bunit , bitorder , bpad ; uint32_t rgb [ 3 ] ; uint8_t * ptr ; GetByteContext gb ; if ( buf_size < XWD_HEADER_SIZE ) return AVERROR_INVALIDDATA ; bytestream2_init ( & gb , buf , buf_size ) ; header_size = bytestream2_get_be32u ( & gb ) ; version = bytestream2_get_be32u ( & gb ) ; if ( version != XWD_VERSION ) { av_log ( avctx , AV_LOG_ERROR , ""unsupported<S2SV_blank>version\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( buf_size < header_size || header_size < XWD_HEADER_SIZE ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>header<S2SV_blank>size\\n"" ) ; return AVERROR_INVALIDDATA ; } pixformat = bytestream2_get_be32u ( & gb ) ; pixdepth = bytestream2_get_be32u ( & gb ) ; avctx -> width = bytestream2_get_be32u ( & gb ) ; avctx -> height = bytestream2_get_be32u ( & gb ) ; xoffset = bytestream2_get_be32u ( & gb ) ; be = bytestream2_get_be32u ( & gb ) ; bunit = bytestream2_get_be32u ( & gb ) ; bitorder = bytestream2_get_be32u ( & gb ) ; bpad = bytestream2_get_be32u ( & gb ) ; bpp = bytestream2_get_be32u ( & gb ) ; lsize = bytestream2_get_be32u ( & gb ) ; vclass = bytestream2_get_be32u ( & gb ) ; rgb [ 0 ] = bytestream2_get_be32u ( & gb ) ; rgb [ 1 ] = bytestream2_get_be32u ( & gb ) ; rgb [ 2 ] = bytestream2_get_be32u ( & gb ) ; bytestream2_skipu ( & gb , 8 ) ; ncolors = bytestream2_get_be32u ( & gb ) ; bytestream2_skipu ( & gb , header_size - ( XWD_HEADER_SIZE - 20 ) ) ; av_log ( avctx , AV_LOG_DEBUG , ""pixformat<S2SV_blank>%"" PRIu32 "",<S2SV_blank>pixdepth<S2SV_blank>%"" PRIu32 "",<S2SV_blank>bunit<S2SV_blank>%"" PRIu32 "",<S2SV_blank>bitorder<S2SV_blank>%"" PRIu32 "",<S2SV_blank>bpad<S2SV_blank>%"" PRIu32 ""\\n"" , pixformat , pixdepth , bunit , bitorder , bpad ) ; av_log ( avctx , AV_LOG_DEBUG , ""vclass<S2SV_blank>%"" PRIu32 "",<S2SV_blank>ncolors<S2SV_blank>%"" PRIu32 "",<S2SV_blank>bpp<S2SV_blank>%"" PRIu32 "",<S2SV_blank>be<S2SV_blank>%"" PRIu32 "",<S2SV_blank>lsize<S2SV_blank>%"" PRIu32 "",<S2SV_blank>xoffset<S2SV_blank>%"" PRIu32 ""\\n"" , vclass , ncolors , bpp , be , lsize , xoffset ) ; av_log ( avctx , AV_LOG_DEBUG , ""red<S2SV_blank>%0"" PRIx32 "",<S2SV_blank>green<S2SV_blank>%0"" PRIx32 "",<S2SV_blank>blue<S2SV_blank>%0"" PRIx32 ""\\n"" , rgb [ 0 ] , rgb [ 1 ] , rgb [ 2 ] ) ; if ( pixformat > XWD_Z_PIXMAP ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>pixmap<S2SV_blank>format\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( pixdepth == 0 || pixdepth > 32 ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>pixmap<S2SV_blank>depth\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( xoffset ) { avpriv_request_sample ( avctx , ""xoffset<S2SV_blank>%"" PRIu32 """" , xoffset ) ; return AVERROR_PATCHWELCOME ; } if ( be > 1 ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>byte<S2SV_blank>order\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( bitorder > 1 ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>bitmap<S2SV_blank>bit<S2SV_blank>order\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( bunit != 8 && bunit != 16 && bunit != 32 ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>bitmap<S2SV_blank>unit\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( bpad != 8 && bpad != 16 && bpad != 32 ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>bitmap<S2SV_blank>scan-line<S2SV_blank>pad\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( bpp == 0 || bpp > 32 ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>bits<S2SV_blank>per<S2SV_blank>pixel\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( ncolors > 256 ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>entries<S2SV_blank>in<S2SV_blank>colormap\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( ( ret = av_image_check_size ( avctx -> width , avctx -> height , 0 , NULL ) ) < 0 ) return ret ; rsize = FFALIGN ( avctx -> width * bpp , bpad ) / 8 ; if ( lsize < rsize ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>scan-line\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( bytestream2_get_bytes_left ( & gb ) < ncolors * XWD_CMAP_SIZE + ( uint64_t ) avctx -> height * lsize ) { av_log ( avctx , AV_LOG_ERROR , ""input<S2SV_blank>buffer<S2SV_blank>too<S2SV_blank>small\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( pixformat != XWD_Z_PIXMAP ) { avpriv_report_missing_feature ( avctx , ""Pixmap<S2SV_blank>format<S2SV_blank>%"" PRIu32 , pixformat ) ; return AVERROR_PATCHWELCOME ; } avctx -> pix_fmt = AV_PIX_FMT_NONE ; switch ( vclass ) { case XWD_STATIC_GRAY : case XWD_GRAY_SCALE : if ( bpp != 1 && bpp != 8 ) return AVERROR_INVALIDDATA ;  if ( pixdepth == 1 ) {  avctx -> pix_fmt = AV_PIX_FMT_MONOWHITE ;  } else if ( pixdepth == 8 ) {  avctx -> pix_fmt = AV_PIX_FMT_GRAY8 ; } break ; case XWD_STATIC_COLOR : case XWD_PSEUDO_COLOR : if ( bpp == 8 ) avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; break ; case XWD_TRUE_COLOR : case XWD_DIRECT_COLOR : if ( bpp != 16 && bpp != 24 && bpp != 32 ) return AVERROR_INVALIDDATA ; if ( bpp == 16 && pixdepth == 15 ) { if ( rgb [ 0 ] == 0x7C00 && rgb [ 1 ] == 0x3E0 && rgb [ 2 ] == 0x1F ) avctx -> pix_fmt = be ? AV_PIX_FMT_RGB555BE : AV_PIX_FMT_RGB555LE ; else if ( rgb [ 0 ] == 0x1F && rgb [ 1 ] == 0x3E0 && rgb [ 2 ] == 0x7C00 ) avctx -> pix_fmt = be ? AV_PIX_FMT_BGR555BE : AV_PIX_FMT_BGR555LE ; } else if ( bpp == 16 && pixdepth == 16 ) { if ( rgb [ 0 ] == 0xF800 && rgb [ 1 ] == 0x7E0 && rgb [ 2 ] == 0x1F ) avctx -> pix_fmt = be ? AV_PIX_FMT_RGB565BE : AV_PIX_FMT_RGB565LE ; else if ( rgb [ 0 ] == 0x1F && rgb [ 1 ] == 0x7E0 && rgb [ 2 ] == 0xF800 ) avctx -> pix_fmt = be ? AV_PIX_FMT_BGR565BE : AV_PIX_FMT_BGR565LE ; } else if ( bpp == 24 ) { if ( rgb [ 0 ] == 0xFF0000 && rgb [ 1 ] == 0xFF00 && rgb [ 2 ] == 0xFF ) avctx -> pix_fmt = be ? AV_PIX_FMT_RGB24 : AV_PIX_FMT_BGR24 ; else if ( rgb [ 0 ] == 0xFF && rgb [ 1 ] == 0xFF00 && rgb [ 2 ] == 0xFF0000 ) avctx -> pix_fmt = be ? AV_PIX_FMT_BGR24 : AV_PIX_FMT_RGB24 ; } else if ( bpp == 32 ) { if ( rgb [ 0 ] == 0xFF0000 && rgb [ 1 ] == 0xFF00 && rgb [ 2 ] == 0xFF ) avctx -> pix_fmt = be ? AV_PIX_FMT_ARGB : AV_PIX_FMT_BGRA ; else if ( rgb [ 0 ] == 0xFF && rgb [ 1 ] == 0xFF00 && rgb [ 2 ] == 0xFF0000 ) avctx -> pix_fmt = be ? AV_PIX_FMT_ABGR : AV_PIX_FMT_RGBA ; } bytestream2_skipu ( & gb , ncolors * XWD_CMAP_SIZE ) ; break ; default : av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>visual<S2SV_blank>class\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( avctx -> pix_fmt == AV_PIX_FMT_NONE ) { avpriv_request_sample ( avctx , ""Unknown<S2SV_blank>file:<S2SV_blank>bpp<S2SV_blank>%"" PRIu32 "",<S2SV_blank>pixdepth<S2SV_blank>%"" PRIu32 "",<S2SV_blank>vclass<S2SV_blank>%"" PRIu32 """" , bpp , pixdepth , vclass ) ; return AVERROR_PATCHWELCOME ; } if ( ( ret = ff_get_buffer ( avctx , p , 0 ) ) < 0 ) return ret ; p -> key_frame = 1 ; p -> pict_type = AV_PICTURE_TYPE_I ; if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 ) { uint32_t * dst = ( uint32_t * ) p -> data [ 1 ] ; uint8_t red , green , blue ; for ( i = 0 ; i < ncolors ; i ++ ) { bytestream2_skipu ( & gb , 4 ) ; red = bytestream2_get_byteu ( & gb ) ; bytestream2_skipu ( & gb , 1 ) ; green = bytestream2_get_byteu ( & gb ) ; bytestream2_skipu ( & gb , 1 ) ; blue = bytestream2_get_byteu ( & gb ) ; bytestream2_skipu ( & gb , 3 ) ; dst [ i ] = red << 16 | green << 8 | blue ; } } ptr = p -> data [ 0 ] ; for ( i = 0 ; i < avctx -> height ; i ++ ) { bytestream2_get_bufferu ( & gb , ptr , rsize ) ; bytestream2_skipu ( & gb , lsize - rsize ) ; ptr += p -> linesize [ 0 ] ; } * got_frame = 1 ; return buf_size ; }",if ( pixdepth == 1 ) {avctx -> pix_fmt = AV_PIX_FMT_MONOWHITE ;}else if ( bpp == 8 && pixdepth == 8 ) {avctx -> pix_fmt = AV_PIX_FMT_GRAY8 ;,584
792,"buggy line: krb5_data rspac ;const char * our_realm = krb5_principal_get_comp_string ( context , krbtgt -> entry . principal , 1 ) ;cwe id:CWE-295context: static krb5_error_code tgs_build_reply ( krb5_context context , krb5_kdc_configuration * config , KDC_REQ * req , KDC_REQ_BODY * b , hdb_entry_ex * krbtgt , krb5_enctype krbtgt_etype , const krb5_keyblock * replykey , int rk_is_subkey , krb5_ticket * ticket , krb5_data * reply , const char * from , const char * * e_text , AuthorizationData * * auth_data , const struct sockaddr * from_addr ) { krb5_error_code ret ; krb5_principal cp = NULL , sp = NULL , rsp = NULL , tp = NULL , dp = NULL ; krb5_principal krbtgt_out_principal = NULL ; char * spn = NULL , * cpn = NULL , * tpn = NULL , * dpn = NULL , * krbtgt_out_n = NULL ; hdb_entry_ex * server = NULL , * client = NULL , * s4u2self_impersonated_client = NULL ; HDB * clientdb , * s4u2self_impersonated_clientdb ; krb5_realm ref_realm = NULL ; EncTicketPart * tgt = & ticket -> ticket ; krb5_principals spp = NULL ; const EncryptionKey * ekey ; krb5_keyblock sessionkey ; krb5_kvno kvno ;  krb5_data rspac ;  const char * our_realm = krb5_principal_get_comp_string ( context , krbtgt -> entry . principal , 1 ) ; char * * capath = NULL ; size_t num_capath = 0 ; hdb_entry_ex * krbtgt_out = NULL ; METHOD_DATA enc_pa_data ; PrincipalName * s ; Realm r ; EncTicketPart adtkt ; char opt_str [ 128 ] ; int signedpath = 0 ; Key * tkey_check ; Key * tkey_sign ; int flags = HDB_F_FOR_TGS_REQ ; memset ( & sessionkey , 0 , sizeof ( sessionkey ) ) ; memset ( & adtkt , 0 , sizeof ( adtkt ) ) ; krb5_data_zero ( & rspac ) ; memset ( & enc_pa_data , 0 , sizeof ( enc_pa_data ) ) ; s = b -> sname ; r = b -> realm ; flags |= HDB_F_CANON ; if ( b -> kdc_options . enc_tkt_in_skey ) { Ticket * t ; hdb_entry_ex * uu ; krb5_principal p ; Key * uukey ; krb5uint32 second_kvno = 0 ; krb5uint32 * kvno_ptr = NULL ; if ( b -> additional_tickets == NULL || b -> additional_tickets -> len == 0 ) { ret = KRB5KDC_ERR_BADOPTION ; kdc_log ( context , config , 0 , ""No<S2SV_blank>second<S2SV_blank>ticket<S2SV_blank>present<S2SV_blank>in<S2SV_blank>request"" ) ; goto out ; } t = & b -> additional_tickets -> val [ 0 ] ; if ( ! get_krbtgt_realm ( & t -> sname ) ) { kdc_log ( context , config , 0 , ""Additional<S2SV_blank>ticket<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>ticket-granting<S2SV_blank>ticket"" ) ; ret = KRB5KDC_ERR_POLICY ; goto out ; } _krb5_principalname2krb5_principal ( context , & p , t -> sname , t -> realm ) ; if ( t -> enc_part . kvno ) { second_kvno = * t -> enc_part . kvno ; kvno_ptr = & second_kvno ; } ret = _kdc_db_fetch ( context , config , p , HDB_F_GET_KRBTGT , kvno_ptr , NULL , & uu ) ; krb5_free_principal ( context , p ) ; if ( ret ) { if ( ret == HDB_ERR_NOENTRY ) ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN ; goto out ; } ret = hdb_enctype2key ( context , & uu -> entry , NULL , t -> enc_part . etype , & uukey ) ; if ( ret ) { _kdc_free_ent ( context , uu ) ; ret = KRB5KDC_ERR_ETYPE_NOSUPP ; goto out ; } ret = krb5_decrypt_ticket ( context , t , & uukey -> key , & adtkt , 0 ) ; _kdc_free_ent ( context , uu ) ; if ( ret ) goto out ; ret = verify_flags ( context , config , & adtkt , spn ) ; if ( ret ) goto out ; s = & adtkt . cname ; r = adtkt . crealm ; } _krb5_principalname2krb5_principal ( context , & sp , * s , r ) ; ret = krb5_unparse_name ( context , sp , & spn ) ; if ( ret ) goto out ; _krb5_principalname2krb5_principal ( context , & cp , tgt -> cname , tgt -> crealm ) ; ret = krb5_unparse_name ( context , cp , & cpn ) ; if ( ret ) goto out ; unparse_flags ( KDCOptions2int ( b -> kdc_options ) , asn1_KDCOptions_units ( ) , opt_str , sizeof ( opt_str ) ) ; if ( * opt_str ) kdc_log ( context , config , 0 , ""TGS-REQ<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>[%s]"" , cpn , from , spn , opt_str ) ; else kdc_log ( context , config , 0 , ""TGS-REQ<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>%s"" , cpn , from , spn ) ; server_lookup : ret = _kdc_db_fetch ( context , config , sp , HDB_F_GET_SERVER | flags , NULL , NULL , & server ) ; if ( ret == HDB_ERR_NOT_FOUND_HERE ) { kdc_log ( context , config , 5 , ""target<S2SV_blank>%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>secrets<S2SV_blank>at<S2SV_blank>this<S2SV_blank>KDC,<S2SV_blank>need<S2SV_blank>to<S2SV_blank>proxy"" , sp ) ; goto out ; } else if ( ret == HDB_ERR_WRONG_REALM ) { free ( ref_realm ) ; ref_realm = strdup ( server -> entry . principal -> realm ) ; if ( ref_realm == NULL ) { ret = krb5_enomem ( context ) ; goto out ; } kdc_log ( context , config , 5 , ""Returning<S2SV_blank>a<S2SV_blank>referral<S2SV_blank>to<S2SV_blank>realm<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>"" ""server<S2SV_blank>%s."" , ref_realm , spn ) ; krb5_free_principal ( context , sp ) ; sp = NULL ; ret = krb5_make_principal ( context , & sp , r , KRB5_TGS_NAME , ref_realm , NULL ) ; if ( ret ) goto out ; free ( spn ) ; spn = NULL ; ret = krb5_unparse_name ( context , sp , & spn ) ; if ( ret ) goto out ; goto server_lookup ; } else if ( ret ) { const char * new_rlm , * msg ; Realm req_rlm ; krb5_realm * realms ; if ( ( req_rlm = get_krbtgt_realm ( & sp -> name ) ) != NULL ) { if ( capath == NULL ) { ret = _krb5_find_capath ( context , tgt -> crealm , our_realm , req_rlm , TRUE , & capath , & num_capath ) ; if ( ret ) goto out ; } new_rlm = num_capath > 0 ? capath [ -- num_capath ] : NULL ; if ( new_rlm ) { kdc_log ( context , config , 5 , ""krbtgt<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>via<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>"" ""realm<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>found,<S2SV_blank>trying<S2SV_blank>%s"" , tgt -> crealm , our_realm , req_rlm , new_rlm ) ; free ( ref_realm ) ; ref_realm = strdup ( new_rlm ) ; if ( ref_realm == NULL ) { ret = krb5_enomem ( context ) ; goto out ; } krb5_free_principal ( context , sp ) ; sp = NULL ; krb5_make_principal ( context , & sp , r , KRB5_TGS_NAME , ref_realm , NULL ) ; free ( spn ) ; spn = NULL ; ret = krb5_unparse_name ( context , sp , & spn ) ; if ( ret ) goto out ; goto server_lookup ; } } else if ( need_referral ( context , config , & b -> kdc_options , sp , & realms ) ) { if ( strcmp ( realms [ 0 ] , sp -> realm ) != 0 ) { kdc_log ( context , config , 5 , ""Returning<S2SV_blank>a<S2SV_blank>referral<S2SV_blank>to<S2SV_blank>realm<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>"" ""server<S2SV_blank>%s<S2SV_blank>that<S2SV_blank>was<S2SV_blank>not<S2SV_blank>found"" , realms [ 0 ] , spn ) ; krb5_free_principal ( context , sp ) ; sp = NULL ; krb5_make_principal ( context , & sp , r , KRB5_TGS_NAME , realms [ 0 ] , NULL ) ; free ( spn ) ; spn = NULL ; ret = krb5_unparse_name ( context , sp , & spn ) ; if ( ret ) { krb5_free_host_realm ( context , realms ) ; goto out ; } free ( ref_realm ) ; ref_realm = strdup ( realms [ 0 ] ) ; krb5_free_host_realm ( context , realms ) ; goto server_lookup ; } krb5_free_host_realm ( context , realms ) ; } msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 0 , ""Server<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>database:<S2SV_blank>%s:<S2SV_blank>%s"" , spn , msg ) ; krb5_free_error_message ( context , msg ) ; if ( ret == HDB_ERR_NOENTRY ) ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN ; goto out ; } if ( b -> kdc_options . canonicalize ) rsp = server -> entry . principal ; else rsp = sp ; { krb5_enctype etype ; if ( b -> kdc_options . enc_tkt_in_skey ) { size_t i ; ekey = & adtkt . key ; for ( i = 0 ; i < b -> etype . len ; i ++ ) if ( b -> etype . val [ i ] == adtkt . key . keytype ) break ; if ( i == b -> etype . len ) { kdc_log ( context , config , 0 , ""Addition<S2SV_blank>ticket<S2SV_blank>have<S2SV_blank>not<S2SV_blank>matching<S2SV_blank>etypes"" ) ; krb5_clear_error_message ( context ) ; ret = KRB5KDC_ERR_ETYPE_NOSUPP ; goto out ; } etype = b -> etype . val [ i ] ; kvno = 0 ; } else { Key * skey ; ret = _kdc_find_etype ( context , krb5_principal_is_krbtgt ( context , sp ) ? config -> tgt_use_strongest_session_key : config -> svc_use_strongest_session_key , FALSE , server , b -> etype . val , b -> etype . len , & etype , NULL ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Server<S2SV_blank>(%s)<S2SV_blank>has<S2SV_blank>no<S2SV_blank>support<S2SV_blank>for<S2SV_blank>etypes"" , spn ) ; goto out ; } ret = _kdc_get_preferred_key ( context , config , server , spn , NULL , & skey ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Server<S2SV_blank>(%s)<S2SV_blank>has<S2SV_blank>no<S2SV_blank>supported<S2SV_blank>etypes"" , spn ) ; goto out ; } ekey = & skey -> key ; kvno = server -> entry . kvno ; } ret = krb5_generate_random_keyblock ( context , etype , & sessionkey ) ; if ( ret ) goto out ; } ret = hdb_enctype2key ( context , & krbtgt -> entry , NULL , krbtgt_etype , & tkey_check ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>key<S2SV_blank>for<S2SV_blank>krbtgt<S2SV_blank>PAC<S2SV_blank>check"" ) ; goto out ; } ret = krb5_make_principal ( context , & krbtgt_out_principal , our_realm , KRB5_TGS_NAME , our_realm , NULL ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Failed<S2SV_blank>to<S2SV_blank>make<S2SV_blank>krbtgt<S2SV_blank>principal<S2SV_blank>name<S2SV_blank>object<S2SV_blank>for<S2SV_blank>"" ""authz-data<S2SV_blank>signatures"" ) ; goto out ; } ret = krb5_unparse_name ( context , krbtgt_out_principal , & krbtgt_out_n ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Failed<S2SV_blank>to<S2SV_blank>make<S2SV_blank>krbtgt<S2SV_blank>principal<S2SV_blank>name<S2SV_blank>object<S2SV_blank>for<S2SV_blank>"" ""authz-data<S2SV_blank>signatures"" ) ; goto out ; } ret = _kdc_db_fetch ( context , config , krbtgt_out_principal , HDB_F_GET_KRBTGT , NULL , NULL , & krbtgt_out ) ; if ( ret ) { char * ktpn = NULL ; ret = krb5_unparse_name ( context , krbtgt -> entry . principal , & ktpn ) ; kdc_log ( context , config , 0 , ""No<S2SV_blank>such<S2SV_blank>principal<S2SV_blank>%s<S2SV_blank>(needed<S2SV_blank>for<S2SV_blank>authz-data<S2SV_blank>signature<S2SV_blank>keys)<S2SV_blank>"" ""while<S2SV_blank>processing<S2SV_blank>TGS-REQ<S2SV_blank>for<S2SV_blank>service<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>krbtg<S2SV_blank>%s"" , krbtgt_out_n , spn , ( ret == 0 ) ? ktpn : ""<unknown>"" ) ; free ( ktpn ) ; ret = KRB5KRB_AP_ERR_NOT_US ; goto out ; } if ( strcmp ( krb5_principal_get_realm ( context , server -> entry . principal ) , krb5_principal_get_realm ( context , krbtgt_out -> entry . principal ) ) != 0 ) { char * ktpn ; ret = krb5_unparse_name ( context , krbtgt_out -> entry . principal , & ktpn ) ; kdc_log ( context , config , 0 , ""Request<S2SV_blank>with<S2SV_blank>wrong<S2SV_blank>krbtgt:<S2SV_blank>%s"" , ( ret == 0 ) ? ktpn : ""<unknown>"" ) ; if ( ret == 0 ) free ( ktpn ) ; ret = KRB5KRB_AP_ERR_NOT_US ; goto out ; } ret = _kdc_get_preferred_key ( context , config , krbtgt_out , krbtgt_out_n , NULL , & tkey_sign ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>key<S2SV_blank>for<S2SV_blank>krbtgt<S2SV_blank>PAC<S2SV_blank>signature"" ) ; goto out ; } ret = hdb_enctype2key ( context , & krbtgt_out -> entry , NULL , tkey_sign -> key . keytype , & tkey_sign ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>key<S2SV_blank>for<S2SV_blank>krbtgt<S2SV_blank>PAC<S2SV_blank>signature"" ) ; goto out ; } ret = _kdc_db_fetch ( context , config , cp , HDB_F_GET_CLIENT | flags , NULL , & clientdb , & client ) ; if ( ret == HDB_ERR_NOT_FOUND_HERE ) { } else if ( ret ) { const char * krbtgt_realm , * msg ; krbtgt_realm = krb5_principal_get_realm ( context , krbtgt_out -> entry . principal ) ; if ( strcmp ( krb5_principal_get_realm ( context , cp ) , krbtgt_realm ) == 0 ) { if ( ret == HDB_ERR_NOENTRY ) ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; kdc_log ( context , config , 1 , ""Client<S2SV_blank>no<S2SV_blank>longer<S2SV_blank>in<S2SV_blank>database:<S2SV_blank>%s"" , cpn ) ; goto out ; } msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 1 , ""Client<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>database:<S2SV_blank>%s"" , msg ) ; krb5_free_error_message ( context , msg ) ; } ret = check_PAC ( context , config , cp , NULL , client , server , krbtgt , & tkey_check -> key , ekey , & tkey_sign -> key , tgt , & rspac , & signedpath ) ; if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 0 , ""Verify<S2SV_blank>PAC<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>%s"" , spn , cpn , from , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } ret = check_KRB5SignedPath ( context , config , krbtgt , cp , tgt , & spp , & signedpath ) ; if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 0 , ""KRB5SignedPath<S2SV_blank>check<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>%s"" , spn , cpn , from , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } tp = cp ; tpn = cpn ; if ( client ) { const PA_DATA * sdata ; int i = 0 ; sdata = _kdc_find_padata ( req , & i , KRB5_PADATA_FOR_USER ) ; if ( sdata ) { krb5_crypto crypto ; krb5_data datack ; PA_S4U2Self self ; const char * str ; ret = decode_PA_S4U2Self ( sdata -> padata_value . data , sdata -> padata_value . length , & self , NULL ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>PA-S4U2Self"" ) ; goto out ; } ret = _krb5_s4u2self_to_checksumdata ( context , & self , & datack ) ; if ( ret ) goto out ; ret = krb5_crypto_init ( context , & tgt -> key , 0 , & crypto ) ; if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; free_PA_S4U2Self ( & self ) ; krb5_data_free ( & datack ) ; kdc_log ( context , config , 0 , ""krb5_crypto_init<S2SV_blank>failed:<S2SV_blank>%s"" , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } ret = krb5_verify_checksum ( context , crypto , KRB5_KU_OTHER_CKSUM , datack . data , datack . length , & self . cksum ) ; krb5_data_free ( & datack ) ; krb5_crypto_destroy ( context , crypto ) ; if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; free_PA_S4U2Self ( & self ) ; kdc_log ( context , config , 0 , ""krb5_verify_checksum<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>S4U2Self:<S2SV_blank>%s"" , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } ret = _krb5_principalname2krb5_principal ( context , & tp , self . name , self . realm ) ; free_PA_S4U2Self ( & self ) ; if ( ret ) goto out ; ret = krb5_unparse_name ( context , tp , & tpn ) ; if ( ret ) goto out ; if ( rspac . data ) { krb5_pac p = NULL ; krb5_data_free ( & rspac ) ; ret = _kdc_db_fetch ( context , config , tp , HDB_F_GET_CLIENT | flags , NULL , & s4u2self_impersonated_clientdb , & s4u2self_impersonated_client ) ; if ( ret ) { const char * msg ; if ( ret == HDB_ERR_NOENTRY ) ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 1 , ""S2U4Self<S2SV_blank>principal<S2SV_blank>to<S2SV_blank>impersonate<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>database:<S2SV_blank>%s"" , tpn , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } ret = _kdc_pac_generate ( context , s4u2self_impersonated_client , & p ) ; if ( ret ) { kdc_log ( context , config , 0 , ""PAC<S2SV_blank>generation<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>--<S2SV_blank>%s"" , tpn ) ; goto out ; } if ( p != NULL ) { ret = _krb5_pac_sign ( context , p , ticket -> ticket . authtime , s4u2self_impersonated_client -> entry . principal , ekey , & tkey_sign -> key , & rspac ) ; krb5_pac_free ( context , p ) ; if ( ret ) { kdc_log ( context , config , 0 , ""PAC<S2SV_blank>signing<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>--<S2SV_blank>%s"" , tpn ) ; goto out ; } } } ret = check_s4u2self ( context , config , clientdb , client , sp ) ; if ( ret ) { kdc_log ( context , config , 0 , ""S4U2Self:<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>"" ""to<S2SV_blank>impersonate<S2SV_blank>to<S2SV_blank>service<S2SV_blank>"" ""(tried<S2SV_blank>for<S2SV_blank>user<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>service<S2SV_blank>%s)"" , cpn , tpn , spn ) ; goto out ; } if ( client -> entry . flags . trusted_for_delegation ) { str = ""[forwardable]"" ; } else { b -> kdc_options . forwardable = 0 ; str = """" ; } kdc_log ( context , config , 0 , ""s4u2self<S2SV_blank>%s<S2SV_blank>impersonating<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>"" ""service<S2SV_blank>%s<S2SV_blank>%s"" , cpn , tpn , spn , str ) ; } } if ( client != NULL && b -> additional_tickets != NULL && b -> additional_tickets -> len != 0 && b -> kdc_options . enc_tkt_in_skey == 0 ) { int ad_signedpath = 0 ; Key * clientkey ; Ticket * t ; if ( ! signedpath ) { ret = KRB5KDC_ERR_BADOPTION ; kdc_log ( context , config , 0 , ""Constrained<S2SV_blank>delegation<S2SV_blank>done<S2SV_blank>on<S2SV_blank>service<S2SV_blank>ticket<S2SV_blank>%s/%s"" , cpn , spn ) ; goto out ; } t = & b -> additional_tickets -> val [ 0 ] ; ret = hdb_enctype2key ( context , & client -> entry , hdb_kvno2keys ( context , & client -> entry , t -> enc_part . kvno ? * t -> enc_part . kvno : 0 ) , t -> enc_part . etype , & clientkey ) ; if ( ret ) { ret = KRB5KDC_ERR_ETYPE_NOSUPP ; goto out ; } ret = krb5_decrypt_ticket ( context , t , & clientkey -> key , & adtkt , 0 ) ; if ( ret ) { kdc_log ( context , config , 0 , ""failed<S2SV_blank>to<S2SV_blank>decrypt<S2SV_blank>ticket<S2SV_blank>for<S2SV_blank>"" ""constrained<S2SV_blank>delegation<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>"" , cpn , spn ) ; goto out ; } ret = _krb5_principalname2krb5_principal ( context , & tp , adtkt . cname , adtkt . crealm ) ; if ( ret ) goto out ; ret = krb5_unparse_name ( context , tp , & tpn ) ; if ( ret ) goto out ; ret = _krb5_principalname2krb5_principal ( context , & dp , t -> sname , t -> realm ) ; if ( ret ) goto out ; ret = krb5_unparse_name ( context , dp , & dpn ) ; if ( ret ) goto out ; if ( adtkt . flags . forwardable == 0 ) { kdc_log ( context , config , 0 , ""Missing<S2SV_blank>forwardable<S2SV_blank>flag<S2SV_blank>on<S2SV_blank>ticket<S2SV_blank>for<S2SV_blank>"" ""constrained<S2SV_blank>delegation<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>as<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>"" , cpn , dpn , tpn , spn ) ; ret = KRB5KDC_ERR_BADOPTION ; goto out ; } ret = check_constrained_delegation ( context , config , clientdb , client , server , sp ) ; if ( ret ) { kdc_log ( context , config , 0 , ""constrained<S2SV_blank>delegation<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>as<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>allowed"" , cpn , dpn , tpn , spn ) ; goto out ; } ret = verify_flags ( context , config , & adtkt , tpn ) ; if ( ret ) { goto out ; } krb5_data_free ( & rspac ) ; ret = check_PAC ( context , config , tp , dp , client , server , krbtgt , & clientkey -> key , ekey , & tkey_sign -> key , & adtkt , & rspac , & ad_signedpath ) ; if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 0 , ""Verify<S2SV_blank>delegated<S2SV_blank>PAC<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>client"" ""%s<S2SV_blank>(%s)<S2SV_blank>as<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>%s"" , spn , cpn , dpn , tpn , from , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } ret = check_KRB5SignedPath ( context , config , krbtgt , cp , & adtkt , NULL , & ad_signedpath ) ; if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 0 , ""KRB5SignedPath<S2SV_blank>check<S2SV_blank>from<S2SV_blank>service<S2SV_blank>%s<S2SV_blank>failed<S2SV_blank>"" ""for<S2SV_blank>delegation<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s<S2SV_blank>(%s)"" ""from<S2SV_blank>%s<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>%s"" , spn , tpn , dpn , cpn , from , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } if ( ! ad_signedpath ) { ret = KRB5KDC_ERR_BADOPTION ; kdc_log ( context , config , 0 , ""Ticket<S2SV_blank>not<S2SV_blank>signed<S2SV_blank>with<S2SV_blank>PAC<S2SV_blank>nor<S2SV_blank>SignedPath<S2SV_blank>service<S2SV_blank>%s<S2SV_blank>failed<S2SV_blank>"" ""for<S2SV_blank>delegation<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s<S2SV_blank>(%s)"" ""from<S2SV_blank>%s"" , spn , tpn , dpn , cpn , from ) ; goto out ; } kdc_log ( context , config , 0 , ""constrained<S2SV_blank>delegation<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>"" ""from<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>%s"" , tpn , cpn , dpn , spn ) ; } ret = kdc_check_flags ( context , config , client , cpn , server , spn , FALSE ) ; if ( ret ) goto out ; if ( ( b -> kdc_options . validate || b -> kdc_options . renew ) && ! krb5_principal_compare ( context , krbtgt -> entry . principal , server -> entry . principal ) ) { kdc_log ( context , config , 0 , ""Inconsistent<S2SV_blank>request."" ) ; ret = KRB5KDC_ERR_SERVER_NOMATCH ; goto out ; } if ( ! _kdc_check_addresses ( context , config , tgt -> caddr , from_addr ) ) { ret = KRB5KRB_AP_ERR_BADADDR ; kdc_log ( context , config , 0 , ""Request<S2SV_blank>from<S2SV_blank>wrong<S2SV_blank>address"" ) ; goto out ; } if ( ref_realm ) { PA_DATA pa ; krb5_crypto crypto ; kdc_log ( context , config , 0 , ""Adding<S2SV_blank>server<S2SV_blank>referral<S2SV_blank>to<S2SV_blank>%s"" , ref_realm ) ; ret = krb5_crypto_init ( context , & sessionkey , 0 , & crypto ) ; if ( ret ) goto out ; ret = build_server_referral ( context , config , crypto , ref_realm , NULL , s , & pa . padata_value ) ; krb5_crypto_destroy ( context , crypto ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Failed<S2SV_blank>building<S2SV_blank>server<S2SV_blank>referral"" ) ; goto out ; } pa . padata_type = KRB5_PADATA_SERVER_REFERRAL ; ret = add_METHOD_DATA ( & enc_pa_data , & pa ) ; krb5_data_free ( & pa . padata_value ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Add<S2SV_blank>server<S2SV_blank>referral<S2SV_blank>METHOD-DATA<S2SV_blank>failed"" ) ; goto out ; } } ret = tgs_make_reply ( context , config , b , tp , tgt , replykey , rk_is_subkey , ekey , & sessionkey , kvno , * auth_data , server , rsp , spn , client , cp ,  krbtgt_out ,  tkey_sign -> key . keytype , spp , & rspac , & enc_pa_data , e_text , reply ) ; out : if ( tpn != cpn ) free ( tpn ) ; free ( spn ) ; free ( cpn ) ; free ( dpn ) ; free ( krbtgt_out_n ) ; _krb5_free_capath ( context , capath ) ; krb5_data_free ( & rspac ) ; krb5_free_keyblock_contents ( context , & sessionkey ) ; if ( krbtgt_out ) _kdc_free_ent ( context , krbtgt_out ) ; if ( server ) _kdc_free_ent ( context , server ) ; if ( client ) _kdc_free_ent ( context , client ) ; if ( s4u2self_impersonated_client ) _kdc_free_ent ( context , s4u2self_impersonated_client ) ; if ( tp && tp != cp ) krb5_free_principal ( context , tp ) ; krb5_free_principal ( context , cp ) ; krb5_free_principal ( context , dp ) ; krb5_free_principal ( context , sp ) ; krb5_free_principal ( context , krbtgt_out_principal ) ; free ( ref_realm ) ; free_METHOD_DATA ( & enc_pa_data ) ; free_EncTicketPart ( & adtkt ) ; return ret ; }","krb5_data rspac ;const char * tgt_realm = krb5_principal_get_realm ( context , krbtgt -> entry . principal ) ;const char * our_realm = krb5_principal_get_comp_string ( context , krbtgt -> entry . principal , 1 ) ;",585
793,"buggy line: ret = krb5_unparse_name ( context , cp , & cpn ) ;cwe id:CWE-295context: static krb5_error_code tgs_build_reply ( krb5_context context , krb5_kdc_configuration * config , KDC_REQ * req , KDC_REQ_BODY * b , hdb_entry_ex * krbtgt , krb5_enctype krbtgt_etype , const krb5_keyblock * replykey , int rk_is_subkey , krb5_ticket * ticket , krb5_data * reply , const char * from , const char * * e_text , AuthorizationData * * auth_data , const struct sockaddr * from_addr ) { krb5_error_code ret ; krb5_principal cp = NULL , sp = NULL , rsp = NULL , tp = NULL , dp = NULL ; krb5_principal krbtgt_out_principal = NULL ; char * spn = NULL , * cpn = NULL , * tpn = NULL , * dpn = NULL , * krbtgt_out_n = NULL ; hdb_entry_ex * server = NULL , * client = NULL , * s4u2self_impersonated_client = NULL ; HDB * clientdb , * s4u2self_impersonated_clientdb ; krb5_realm ref_realm = NULL ; EncTicketPart * tgt = & ticket -> ticket ; krb5_principals spp = NULL ; const EncryptionKey * ekey ; krb5_keyblock sessionkey ; krb5_kvno kvno ;  krb5_data rspac ;  const char * our_realm = krb5_principal_get_comp_string ( context , krbtgt -> entry . principal , 1 ) ; char * * capath = NULL ; size_t num_capath = 0 ; hdb_entry_ex * krbtgt_out = NULL ; METHOD_DATA enc_pa_data ; PrincipalName * s ; Realm r ; EncTicketPart adtkt ; char opt_str [ 128 ] ; int signedpath = 0 ; Key * tkey_check ; Key * tkey_sign ; int flags = HDB_F_FOR_TGS_REQ ; memset ( & sessionkey , 0 , sizeof ( sessionkey ) ) ; memset ( & adtkt , 0 , sizeof ( adtkt ) ) ; krb5_data_zero ( & rspac ) ; memset ( & enc_pa_data , 0 , sizeof ( enc_pa_data ) ) ; s = b -> sname ; r = b -> realm ; flags |= HDB_F_CANON ; if ( b -> kdc_options . enc_tkt_in_skey ) { Ticket * t ; hdb_entry_ex * uu ; krb5_principal p ; Key * uukey ; krb5uint32 second_kvno = 0 ; krb5uint32 * kvno_ptr = NULL ; if ( b -> additional_tickets == NULL || b -> additional_tickets -> len == 0 ) { ret = KRB5KDC_ERR_BADOPTION ; kdc_log ( context , config , 0 , ""No<S2SV_blank>second<S2SV_blank>ticket<S2SV_blank>present<S2SV_blank>in<S2SV_blank>request"" ) ; goto out ; } t = & b -> additional_tickets -> val [ 0 ] ; if ( ! get_krbtgt_realm ( & t -> sname ) ) { kdc_log ( context , config , 0 , ""Additional<S2SV_blank>ticket<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>ticket-granting<S2SV_blank>ticket"" ) ; ret = KRB5KDC_ERR_POLICY ; goto out ; } _krb5_principalname2krb5_principal ( context , & p , t -> sname , t -> realm ) ; if ( t -> enc_part . kvno ) { second_kvno = * t -> enc_part . kvno ; kvno_ptr = & second_kvno ; } ret = _kdc_db_fetch ( context , config , p , HDB_F_GET_KRBTGT , kvno_ptr , NULL , & uu ) ; krb5_free_principal ( context , p ) ; if ( ret ) { if ( ret == HDB_ERR_NOENTRY ) ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN ; goto out ; } ret = hdb_enctype2key ( context , & uu -> entry , NULL , t -> enc_part . etype , & uukey ) ; if ( ret ) { _kdc_free_ent ( context , uu ) ; ret = KRB5KDC_ERR_ETYPE_NOSUPP ; goto out ; } ret = krb5_decrypt_ticket ( context , t , & uukey -> key , & adtkt , 0 ) ; _kdc_free_ent ( context , uu ) ; if ( ret ) goto out ; ret = verify_flags ( context , config , & adtkt , spn ) ; if ( ret ) goto out ; s = & adtkt . cname ; r = adtkt . crealm ; } _krb5_principalname2krb5_principal ( context , & sp , * s , r ) ; ret = krb5_unparse_name ( context , sp , & spn ) ; if ( ret ) goto out ; _krb5_principalname2krb5_principal ( context , & cp , tgt -> cname , tgt -> crealm ) ; ret = krb5_unparse_name ( context , cp , & cpn ) ; if ( ret ) goto out ; unparse_flags ( KDCOptions2int ( b -> kdc_options ) , asn1_KDCOptions_units ( ) , opt_str , sizeof ( opt_str ) ) ; if ( * opt_str ) kdc_log ( context , config , 0 , ""TGS-REQ<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>[%s]"" , cpn , from , spn , opt_str ) ; else kdc_log ( context , config , 0 , ""TGS-REQ<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>%s"" , cpn , from , spn ) ; server_lookup : ret = _kdc_db_fetch ( context , config , sp , HDB_F_GET_SERVER | flags , NULL , NULL , & server ) ; if ( ret == HDB_ERR_NOT_FOUND_HERE ) { kdc_log ( context , config , 5 , ""target<S2SV_blank>%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>secrets<S2SV_blank>at<S2SV_blank>this<S2SV_blank>KDC,<S2SV_blank>need<S2SV_blank>to<S2SV_blank>proxy"" , sp ) ; goto out ; } else if ( ret == HDB_ERR_WRONG_REALM ) { free ( ref_realm ) ; ref_realm = strdup ( server -> entry . principal -> realm ) ; if ( ref_realm == NULL ) { ret = krb5_enomem ( context ) ; goto out ; } kdc_log ( context , config , 5 , ""Returning<S2SV_blank>a<S2SV_blank>referral<S2SV_blank>to<S2SV_blank>realm<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>"" ""server<S2SV_blank>%s."" , ref_realm , spn ) ; krb5_free_principal ( context , sp ) ; sp = NULL ; ret = krb5_make_principal ( context , & sp , r , KRB5_TGS_NAME , ref_realm , NULL ) ; if ( ret ) goto out ; free ( spn ) ; spn = NULL ; ret = krb5_unparse_name ( context , sp , & spn ) ; if ( ret ) goto out ; goto server_lookup ; } else if ( ret ) { const char * new_rlm , * msg ; Realm req_rlm ; krb5_realm * realms ; if ( ( req_rlm = get_krbtgt_realm ( & sp -> name ) ) != NULL ) { if ( capath == NULL ) { ret = _krb5_find_capath ( context , tgt -> crealm , our_realm , req_rlm , TRUE , & capath , & num_capath ) ; if ( ret ) goto out ; } new_rlm = num_capath > 0 ? capath [ -- num_capath ] : NULL ; if ( new_rlm ) { kdc_log ( context , config , 5 , ""krbtgt<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>via<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>"" ""realm<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>found,<S2SV_blank>trying<S2SV_blank>%s"" , tgt -> crealm , our_realm , req_rlm , new_rlm ) ; free ( ref_realm ) ; ref_realm = strdup ( new_rlm ) ; if ( ref_realm == NULL ) { ret = krb5_enomem ( context ) ; goto out ; } krb5_free_principal ( context , sp ) ; sp = NULL ; krb5_make_principal ( context , & sp , r , KRB5_TGS_NAME , ref_realm , NULL ) ; free ( spn ) ; spn = NULL ; ret = krb5_unparse_name ( context , sp , & spn ) ; if ( ret ) goto out ; goto server_lookup ; } } else if ( need_referral ( context , config , & b -> kdc_options , sp , & realms ) ) { if ( strcmp ( realms [ 0 ] , sp -> realm ) != 0 ) { kdc_log ( context , config , 5 , ""Returning<S2SV_blank>a<S2SV_blank>referral<S2SV_blank>to<S2SV_blank>realm<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>"" ""server<S2SV_blank>%s<S2SV_blank>that<S2SV_blank>was<S2SV_blank>not<S2SV_blank>found"" , realms [ 0 ] , spn ) ; krb5_free_principal ( context , sp ) ; sp = NULL ; krb5_make_principal ( context , & sp , r , KRB5_TGS_NAME , realms [ 0 ] , NULL ) ; free ( spn ) ; spn = NULL ; ret = krb5_unparse_name ( context , sp , & spn ) ; if ( ret ) { krb5_free_host_realm ( context , realms ) ; goto out ; } free ( ref_realm ) ; ref_realm = strdup ( realms [ 0 ] ) ; krb5_free_host_realm ( context , realms ) ; goto server_lookup ; } krb5_free_host_realm ( context , realms ) ; } msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 0 , ""Server<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>database:<S2SV_blank>%s:<S2SV_blank>%s"" , spn , msg ) ; krb5_free_error_message ( context , msg ) ; if ( ret == HDB_ERR_NOENTRY ) ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN ; goto out ; } if ( b -> kdc_options . canonicalize ) rsp = server -> entry . principal ; else rsp = sp ; { krb5_enctype etype ; if ( b -> kdc_options . enc_tkt_in_skey ) { size_t i ; ekey = & adtkt . key ; for ( i = 0 ; i < b -> etype . len ; i ++ ) if ( b -> etype . val [ i ] == adtkt . key . keytype ) break ; if ( i == b -> etype . len ) { kdc_log ( context , config , 0 , ""Addition<S2SV_blank>ticket<S2SV_blank>have<S2SV_blank>not<S2SV_blank>matching<S2SV_blank>etypes"" ) ; krb5_clear_error_message ( context ) ; ret = KRB5KDC_ERR_ETYPE_NOSUPP ; goto out ; } etype = b -> etype . val [ i ] ; kvno = 0 ; } else { Key * skey ; ret = _kdc_find_etype ( context , krb5_principal_is_krbtgt ( context , sp ) ? config -> tgt_use_strongest_session_key : config -> svc_use_strongest_session_key , FALSE , server , b -> etype . val , b -> etype . len , & etype , NULL ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Server<S2SV_blank>(%s)<S2SV_blank>has<S2SV_blank>no<S2SV_blank>support<S2SV_blank>for<S2SV_blank>etypes"" , spn ) ; goto out ; } ret = _kdc_get_preferred_key ( context , config , server , spn , NULL , & skey ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Server<S2SV_blank>(%s)<S2SV_blank>has<S2SV_blank>no<S2SV_blank>supported<S2SV_blank>etypes"" , spn ) ; goto out ; } ekey = & skey -> key ; kvno = server -> entry . kvno ; } ret = krb5_generate_random_keyblock ( context , etype , & sessionkey ) ; if ( ret ) goto out ; } ret = hdb_enctype2key ( context , & krbtgt -> entry , NULL , krbtgt_etype , & tkey_check ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>key<S2SV_blank>for<S2SV_blank>krbtgt<S2SV_blank>PAC<S2SV_blank>check"" ) ; goto out ; } ret = krb5_make_principal ( context , & krbtgt_out_principal , our_realm , KRB5_TGS_NAME , our_realm , NULL ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Failed<S2SV_blank>to<S2SV_blank>make<S2SV_blank>krbtgt<S2SV_blank>principal<S2SV_blank>name<S2SV_blank>object<S2SV_blank>for<S2SV_blank>"" ""authz-data<S2SV_blank>signatures"" ) ; goto out ; } ret = krb5_unparse_name ( context , krbtgt_out_principal , & krbtgt_out_n ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Failed<S2SV_blank>to<S2SV_blank>make<S2SV_blank>krbtgt<S2SV_blank>principal<S2SV_blank>name<S2SV_blank>object<S2SV_blank>for<S2SV_blank>"" ""authz-data<S2SV_blank>signatures"" ) ; goto out ; } ret = _kdc_db_fetch ( context , config , krbtgt_out_principal , HDB_F_GET_KRBTGT , NULL , NULL , & krbtgt_out ) ; if ( ret ) { char * ktpn = NULL ; ret = krb5_unparse_name ( context , krbtgt -> entry . principal , & ktpn ) ; kdc_log ( context , config , 0 , ""No<S2SV_blank>such<S2SV_blank>principal<S2SV_blank>%s<S2SV_blank>(needed<S2SV_blank>for<S2SV_blank>authz-data<S2SV_blank>signature<S2SV_blank>keys)<S2SV_blank>"" ""while<S2SV_blank>processing<S2SV_blank>TGS-REQ<S2SV_blank>for<S2SV_blank>service<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>krbtg<S2SV_blank>%s"" , krbtgt_out_n , spn , ( ret == 0 ) ? ktpn : ""<unknown>"" ) ; free ( ktpn ) ; ret = KRB5KRB_AP_ERR_NOT_US ; goto out ; } if ( strcmp ( krb5_principal_get_realm ( context , server -> entry . principal ) , krb5_principal_get_realm ( context , krbtgt_out -> entry . principal ) ) != 0 ) { char * ktpn ; ret = krb5_unparse_name ( context , krbtgt_out -> entry . principal , & ktpn ) ; kdc_log ( context , config , 0 , ""Request<S2SV_blank>with<S2SV_blank>wrong<S2SV_blank>krbtgt:<S2SV_blank>%s"" , ( ret == 0 ) ? ktpn : ""<unknown>"" ) ; if ( ret == 0 ) free ( ktpn ) ; ret = KRB5KRB_AP_ERR_NOT_US ; goto out ; } ret = _kdc_get_preferred_key ( context , config , krbtgt_out , krbtgt_out_n , NULL , & tkey_sign ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>key<S2SV_blank>for<S2SV_blank>krbtgt<S2SV_blank>PAC<S2SV_blank>signature"" ) ; goto out ; } ret = hdb_enctype2key ( context , & krbtgt_out -> entry , NULL , tkey_sign -> key . keytype , & tkey_sign ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>key<S2SV_blank>for<S2SV_blank>krbtgt<S2SV_blank>PAC<S2SV_blank>signature"" ) ; goto out ; } ret = _kdc_db_fetch ( context , config , cp , HDB_F_GET_CLIENT | flags , NULL , & clientdb , & client ) ; if ( ret == HDB_ERR_NOT_FOUND_HERE ) { } else if ( ret ) { const char * krbtgt_realm , * msg ; krbtgt_realm = krb5_principal_get_realm ( context , krbtgt_out -> entry . principal ) ; if ( strcmp ( krb5_principal_get_realm ( context , cp ) , krbtgt_realm ) == 0 ) { if ( ret == HDB_ERR_NOENTRY ) ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; kdc_log ( context , config , 1 , ""Client<S2SV_blank>no<S2SV_blank>longer<S2SV_blank>in<S2SV_blank>database:<S2SV_blank>%s"" , cpn ) ; goto out ; } msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 1 , ""Client<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>database:<S2SV_blank>%s"" , msg ) ; krb5_free_error_message ( context , msg ) ; } ret = check_PAC ( context , config , cp , NULL , client , server , krbtgt , & tkey_check -> key , ekey , & tkey_sign -> key , tgt , & rspac , & signedpath ) ; if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 0 , ""Verify<S2SV_blank>PAC<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>%s"" , spn , cpn , from , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } ret = check_KRB5SignedPath ( context , config , krbtgt , cp , tgt , & spp , & signedpath ) ; if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 0 , ""KRB5SignedPath<S2SV_blank>check<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>%s"" , spn , cpn , from , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } tp = cp ; tpn = cpn ; if ( client ) { const PA_DATA * sdata ; int i = 0 ; sdata = _kdc_find_padata ( req , & i , KRB5_PADATA_FOR_USER ) ; if ( sdata ) { krb5_crypto crypto ; krb5_data datack ; PA_S4U2Self self ; const char * str ; ret = decode_PA_S4U2Self ( sdata -> padata_value . data , sdata -> padata_value . length , & self , NULL ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>PA-S4U2Self"" ) ; goto out ; } ret = _krb5_s4u2self_to_checksumdata ( context , & self , & datack ) ; if ( ret ) goto out ; ret = krb5_crypto_init ( context , & tgt -> key , 0 , & crypto ) ; if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; free_PA_S4U2Self ( & self ) ; krb5_data_free ( & datack ) ; kdc_log ( context , config , 0 , ""krb5_crypto_init<S2SV_blank>failed:<S2SV_blank>%s"" , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } ret = krb5_verify_checksum ( context , crypto , KRB5_KU_OTHER_CKSUM , datack . data , datack . length , & self . cksum ) ; krb5_data_free ( & datack ) ; krb5_crypto_destroy ( context , crypto ) ; if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; free_PA_S4U2Self ( & self ) ; kdc_log ( context , config , 0 , ""krb5_verify_checksum<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>S4U2Self:<S2SV_blank>%s"" , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } ret = _krb5_principalname2krb5_principal ( context , & tp , self . name , self . realm ) ; free_PA_S4U2Self ( & self ) ; if ( ret ) goto out ; ret = krb5_unparse_name ( context , tp , & tpn ) ; if ( ret ) goto out ; if ( rspac . data ) { krb5_pac p = NULL ; krb5_data_free ( & rspac ) ; ret = _kdc_db_fetch ( context , config , tp , HDB_F_GET_CLIENT | flags , NULL , & s4u2self_impersonated_clientdb , & s4u2self_impersonated_client ) ; if ( ret ) { const char * msg ; if ( ret == HDB_ERR_NOENTRY ) ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 1 , ""S2U4Self<S2SV_blank>principal<S2SV_blank>to<S2SV_blank>impersonate<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>database:<S2SV_blank>%s"" , tpn , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } ret = _kdc_pac_generate ( context , s4u2self_impersonated_client , & p ) ; if ( ret ) { kdc_log ( context , config , 0 , ""PAC<S2SV_blank>generation<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>--<S2SV_blank>%s"" , tpn ) ; goto out ; } if ( p != NULL ) { ret = _krb5_pac_sign ( context , p , ticket -> ticket . authtime , s4u2self_impersonated_client -> entry . principal , ekey , & tkey_sign -> key , & rspac ) ; krb5_pac_free ( context , p ) ; if ( ret ) { kdc_log ( context , config , 0 , ""PAC<S2SV_blank>signing<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>--<S2SV_blank>%s"" , tpn ) ; goto out ; } } } ret = check_s4u2self ( context , config , clientdb , client , sp ) ; if ( ret ) { kdc_log ( context , config , 0 , ""S4U2Self:<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>"" ""to<S2SV_blank>impersonate<S2SV_blank>to<S2SV_blank>service<S2SV_blank>"" ""(tried<S2SV_blank>for<S2SV_blank>user<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>service<S2SV_blank>%s)"" , cpn , tpn , spn ) ; goto out ; } if ( client -> entry . flags . trusted_for_delegation ) { str = ""[forwardable]"" ; } else { b -> kdc_options . forwardable = 0 ; str = """" ; } kdc_log ( context , config , 0 , ""s4u2self<S2SV_blank>%s<S2SV_blank>impersonating<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>"" ""service<S2SV_blank>%s<S2SV_blank>%s"" , cpn , tpn , spn , str ) ; } } if ( client != NULL && b -> additional_tickets != NULL && b -> additional_tickets -> len != 0 && b -> kdc_options . enc_tkt_in_skey == 0 ) { int ad_signedpath = 0 ; Key * clientkey ; Ticket * t ; if ( ! signedpath ) { ret = KRB5KDC_ERR_BADOPTION ; kdc_log ( context , config , 0 , ""Constrained<S2SV_blank>delegation<S2SV_blank>done<S2SV_blank>on<S2SV_blank>service<S2SV_blank>ticket<S2SV_blank>%s/%s"" , cpn , spn ) ; goto out ; } t = & b -> additional_tickets -> val [ 0 ] ; ret = hdb_enctype2key ( context , & client -> entry , hdb_kvno2keys ( context , & client -> entry , t -> enc_part . kvno ? * t -> enc_part . kvno : 0 ) , t -> enc_part . etype , & clientkey ) ; if ( ret ) { ret = KRB5KDC_ERR_ETYPE_NOSUPP ; goto out ; } ret = krb5_decrypt_ticket ( context , t , & clientkey -> key , & adtkt , 0 ) ; if ( ret ) { kdc_log ( context , config , 0 , ""failed<S2SV_blank>to<S2SV_blank>decrypt<S2SV_blank>ticket<S2SV_blank>for<S2SV_blank>"" ""constrained<S2SV_blank>delegation<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>"" , cpn , spn ) ; goto out ; } ret = _krb5_principalname2krb5_principal ( context , & tp , adtkt . cname , adtkt . crealm ) ; if ( ret ) goto out ; ret = krb5_unparse_name ( context , tp , & tpn ) ; if ( ret ) goto out ; ret = _krb5_principalname2krb5_principal ( context , & dp , t -> sname , t -> realm ) ; if ( ret ) goto out ; ret = krb5_unparse_name ( context , dp , & dpn ) ; if ( ret ) goto out ; if ( adtkt . flags . forwardable == 0 ) { kdc_log ( context , config , 0 , ""Missing<S2SV_blank>forwardable<S2SV_blank>flag<S2SV_blank>on<S2SV_blank>ticket<S2SV_blank>for<S2SV_blank>"" ""constrained<S2SV_blank>delegation<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>as<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>"" , cpn , dpn , tpn , spn ) ; ret = KRB5KDC_ERR_BADOPTION ; goto out ; } ret = check_constrained_delegation ( context , config , clientdb , client , server , sp ) ; if ( ret ) { kdc_log ( context , config , 0 , ""constrained<S2SV_blank>delegation<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>as<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>allowed"" , cpn , dpn , tpn , spn ) ; goto out ; } ret = verify_flags ( context , config , & adtkt , tpn ) ; if ( ret ) { goto out ; } krb5_data_free ( & rspac ) ; ret = check_PAC ( context , config , tp , dp , client , server , krbtgt , & clientkey -> key , ekey , & tkey_sign -> key , & adtkt , & rspac , & ad_signedpath ) ; if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 0 , ""Verify<S2SV_blank>delegated<S2SV_blank>PAC<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>client"" ""%s<S2SV_blank>(%s)<S2SV_blank>as<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>%s"" , spn , cpn , dpn , tpn , from , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } ret = check_KRB5SignedPath ( context , config , krbtgt , cp , & adtkt , NULL , & ad_signedpath ) ; if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 0 , ""KRB5SignedPath<S2SV_blank>check<S2SV_blank>from<S2SV_blank>service<S2SV_blank>%s<S2SV_blank>failed<S2SV_blank>"" ""for<S2SV_blank>delegation<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s<S2SV_blank>(%s)"" ""from<S2SV_blank>%s<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>%s"" , spn , tpn , dpn , cpn , from , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } if ( ! ad_signedpath ) { ret = KRB5KDC_ERR_BADOPTION ; kdc_log ( context , config , 0 , ""Ticket<S2SV_blank>not<S2SV_blank>signed<S2SV_blank>with<S2SV_blank>PAC<S2SV_blank>nor<S2SV_blank>SignedPath<S2SV_blank>service<S2SV_blank>%s<S2SV_blank>failed<S2SV_blank>"" ""for<S2SV_blank>delegation<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s<S2SV_blank>(%s)"" ""from<S2SV_blank>%s"" , spn , tpn , dpn , cpn , from ) ; goto out ; } kdc_log ( context , config , 0 , ""constrained<S2SV_blank>delegation<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>"" ""from<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>%s"" , tpn , cpn , dpn , spn ) ; } ret = kdc_check_flags ( context , config , client , cpn , server , spn , FALSE ) ; if ( ret ) goto out ; if ( ( b -> kdc_options . validate || b -> kdc_options . renew ) && ! krb5_principal_compare ( context , krbtgt -> entry . principal , server -> entry . principal ) ) { kdc_log ( context , config , 0 , ""Inconsistent<S2SV_blank>request."" ) ; ret = KRB5KDC_ERR_SERVER_NOMATCH ; goto out ; } if ( ! _kdc_check_addresses ( context , config , tgt -> caddr , from_addr ) ) { ret = KRB5KRB_AP_ERR_BADADDR ; kdc_log ( context , config , 0 , ""Request<S2SV_blank>from<S2SV_blank>wrong<S2SV_blank>address"" ) ; goto out ; } if ( ref_realm ) { PA_DATA pa ; krb5_crypto crypto ; kdc_log ( context , config , 0 , ""Adding<S2SV_blank>server<S2SV_blank>referral<S2SV_blank>to<S2SV_blank>%s"" , ref_realm ) ; ret = krb5_crypto_init ( context , & sessionkey , 0 , & crypto ) ; if ( ret ) goto out ; ret = build_server_referral ( context , config , crypto , ref_realm , NULL , s , & pa . padata_value ) ; krb5_crypto_destroy ( context , crypto ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Failed<S2SV_blank>building<S2SV_blank>server<S2SV_blank>referral"" ) ; goto out ; } pa . padata_type = KRB5_PADATA_SERVER_REFERRAL ; ret = add_METHOD_DATA ( & enc_pa_data , & pa ) ; krb5_data_free ( & pa . padata_value ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Add<S2SV_blank>server<S2SV_blank>referral<S2SV_blank>METHOD-DATA<S2SV_blank>failed"" ) ; goto out ; } } ret = tgs_make_reply ( context , config , b , tp , tgt , replykey , rk_is_subkey , ekey , & sessionkey , kvno , * auth_data , server , rsp , spn , client , cp ,  krbtgt_out ,  tkey_sign -> key . keytype , spp , & rspac , & enc_pa_data , e_text , reply ) ; out : if ( tpn != cpn ) free ( tpn ) ; free ( spn ) ; free ( cpn ) ; free ( dpn ) ; free ( krbtgt_out_n ) ; _krb5_free_capath ( context , capath ) ; krb5_data_free ( & rspac ) ; krb5_free_keyblock_contents ( context , & sessionkey ) ; if ( krbtgt_out ) _kdc_free_ent ( context , krbtgt_out ) ; if ( server ) _kdc_free_ent ( context , server ) ; if ( client ) _kdc_free_ent ( context , client ) ; if ( s4u2self_impersonated_client ) _kdc_free_ent ( context , s4u2self_impersonated_client ) ; if ( tp && tp != cp ) krb5_free_principal ( context , tp ) ; krb5_free_principal ( context , cp ) ; krb5_free_principal ( context , dp ) ; krb5_free_principal ( context , sp ) ; krb5_free_principal ( context , krbtgt_out_principal ) ; free ( ref_realm ) ; free_METHOD_DATA ( & enc_pa_data ) ; free_EncTicketPart ( & adtkt ) ; return ret ; }","ret = krb5_unparse_name ( context , cp , tgt_realm , & cpn ) ;",585
794,"buggy line: ret = tgs_make_reply ( context , config , b , tp , tgt , replykey , rk_is_subkey , ekey , & sessionkey , kvno , * auth_data , server , rsp , spn , client , cp ,  krbtgt_out ,  tkey_sign -> key . keytype , spp , & rspac , & enc_pa_data , e_text , reply ) ;cwe id:CWE-295context: static krb5_error_code tgs_build_reply ( krb5_context context , krb5_kdc_configuration * config , KDC_REQ * req , KDC_REQ_BODY * b , hdb_entry_ex * krbtgt , krb5_enctype krbtgt_etype , const krb5_keyblock * replykey , int rk_is_subkey , krb5_ticket * ticket , krb5_data * reply , const char * from , const char * * e_text , AuthorizationData * * auth_data , const struct sockaddr * from_addr ) { krb5_error_code ret ; krb5_principal cp = NULL , sp = NULL , rsp = NULL , tp = NULL , dp = NULL ; krb5_principal krbtgt_out_principal = NULL ; char * spn = NULL , * cpn = NULL , * tpn = NULL , * dpn = NULL , * krbtgt_out_n = NULL ; hdb_entry_ex * server = NULL , * client = NULL , * s4u2self_impersonated_client = NULL ; HDB * clientdb , * s4u2self_impersonated_clientdb ; krb5_realm ref_realm = NULL ; EncTicketPart * tgt = & ticket -> ticket ; krb5_principals spp = NULL ; const EncryptionKey * ekey ; krb5_keyblock sessionkey ; krb5_kvno kvno ;  krb5_data rspac ;  const char * our_realm = krb5_principal_get_comp_string ( context , krbtgt -> entry . principal , 1 ) ; char * * capath = NULL ; size_t num_capath = 0 ; hdb_entry_ex * krbtgt_out = NULL ; METHOD_DATA enc_pa_data ; PrincipalName * s ; Realm r ; EncTicketPart adtkt ; char opt_str [ 128 ] ; int signedpath = 0 ; Key * tkey_check ; Key * tkey_sign ; int flags = HDB_F_FOR_TGS_REQ ; memset ( & sessionkey , 0 , sizeof ( sessionkey ) ) ; memset ( & adtkt , 0 , sizeof ( adtkt ) ) ; krb5_data_zero ( & rspac ) ; memset ( & enc_pa_data , 0 , sizeof ( enc_pa_data ) ) ; s = b -> sname ; r = b -> realm ; flags |= HDB_F_CANON ; if ( b -> kdc_options . enc_tkt_in_skey ) { Ticket * t ; hdb_entry_ex * uu ; krb5_principal p ; Key * uukey ; krb5uint32 second_kvno = 0 ; krb5uint32 * kvno_ptr = NULL ; if ( b -> additional_tickets == NULL || b -> additional_tickets -> len == 0 ) { ret = KRB5KDC_ERR_BADOPTION ; kdc_log ( context , config , 0 , ""No<S2SV_blank>second<S2SV_blank>ticket<S2SV_blank>present<S2SV_blank>in<S2SV_blank>request"" ) ; goto out ; } t = & b -> additional_tickets -> val [ 0 ] ; if ( ! get_krbtgt_realm ( & t -> sname ) ) { kdc_log ( context , config , 0 , ""Additional<S2SV_blank>ticket<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>ticket-granting<S2SV_blank>ticket"" ) ; ret = KRB5KDC_ERR_POLICY ; goto out ; } _krb5_principalname2krb5_principal ( context , & p , t -> sname , t -> realm ) ; if ( t -> enc_part . kvno ) { second_kvno = * t -> enc_part . kvno ; kvno_ptr = & second_kvno ; } ret = _kdc_db_fetch ( context , config , p , HDB_F_GET_KRBTGT , kvno_ptr , NULL , & uu ) ; krb5_free_principal ( context , p ) ; if ( ret ) { if ( ret == HDB_ERR_NOENTRY ) ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN ; goto out ; } ret = hdb_enctype2key ( context , & uu -> entry , NULL , t -> enc_part . etype , & uukey ) ; if ( ret ) { _kdc_free_ent ( context , uu ) ; ret = KRB5KDC_ERR_ETYPE_NOSUPP ; goto out ; } ret = krb5_decrypt_ticket ( context , t , & uukey -> key , & adtkt , 0 ) ; _kdc_free_ent ( context , uu ) ; if ( ret ) goto out ; ret = verify_flags ( context , config , & adtkt , spn ) ; if ( ret ) goto out ; s = & adtkt . cname ; r = adtkt . crealm ; } _krb5_principalname2krb5_principal ( context , & sp , * s , r ) ; ret = krb5_unparse_name ( context , sp , & spn ) ; if ( ret ) goto out ; _krb5_principalname2krb5_principal ( context , & cp , tgt -> cname , tgt -> crealm ) ; ret = krb5_unparse_name ( context , cp , & cpn ) ; if ( ret ) goto out ; unparse_flags ( KDCOptions2int ( b -> kdc_options ) , asn1_KDCOptions_units ( ) , opt_str , sizeof ( opt_str ) ) ; if ( * opt_str ) kdc_log ( context , config , 0 , ""TGS-REQ<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>[%s]"" , cpn , from , spn , opt_str ) ; else kdc_log ( context , config , 0 , ""TGS-REQ<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>%s"" , cpn , from , spn ) ; server_lookup : ret = _kdc_db_fetch ( context , config , sp , HDB_F_GET_SERVER | flags , NULL , NULL , & server ) ; if ( ret == HDB_ERR_NOT_FOUND_HERE ) { kdc_log ( context , config , 5 , ""target<S2SV_blank>%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>secrets<S2SV_blank>at<S2SV_blank>this<S2SV_blank>KDC,<S2SV_blank>need<S2SV_blank>to<S2SV_blank>proxy"" , sp ) ; goto out ; } else if ( ret == HDB_ERR_WRONG_REALM ) { free ( ref_realm ) ; ref_realm = strdup ( server -> entry . principal -> realm ) ; if ( ref_realm == NULL ) { ret = krb5_enomem ( context ) ; goto out ; } kdc_log ( context , config , 5 , ""Returning<S2SV_blank>a<S2SV_blank>referral<S2SV_blank>to<S2SV_blank>realm<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>"" ""server<S2SV_blank>%s."" , ref_realm , spn ) ; krb5_free_principal ( context , sp ) ; sp = NULL ; ret = krb5_make_principal ( context , & sp , r , KRB5_TGS_NAME , ref_realm , NULL ) ; if ( ret ) goto out ; free ( spn ) ; spn = NULL ; ret = krb5_unparse_name ( context , sp , & spn ) ; if ( ret ) goto out ; goto server_lookup ; } else if ( ret ) { const char * new_rlm , * msg ; Realm req_rlm ; krb5_realm * realms ; if ( ( req_rlm = get_krbtgt_realm ( & sp -> name ) ) != NULL ) { if ( capath == NULL ) { ret = _krb5_find_capath ( context , tgt -> crealm , our_realm , req_rlm , TRUE , & capath , & num_capath ) ; if ( ret ) goto out ; } new_rlm = num_capath > 0 ? capath [ -- num_capath ] : NULL ; if ( new_rlm ) { kdc_log ( context , config , 5 , ""krbtgt<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>via<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>"" ""realm<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>found,<S2SV_blank>trying<S2SV_blank>%s"" , tgt -> crealm , our_realm , req_rlm , new_rlm ) ; free ( ref_realm ) ; ref_realm = strdup ( new_rlm ) ; if ( ref_realm == NULL ) { ret = krb5_enomem ( context ) ; goto out ; } krb5_free_principal ( context , sp ) ; sp = NULL ; krb5_make_principal ( context , & sp , r , KRB5_TGS_NAME , ref_realm , NULL ) ; free ( spn ) ; spn = NULL ; ret = krb5_unparse_name ( context , sp , & spn ) ; if ( ret ) goto out ; goto server_lookup ; } } else if ( need_referral ( context , config , & b -> kdc_options , sp , & realms ) ) { if ( strcmp ( realms [ 0 ] , sp -> realm ) != 0 ) { kdc_log ( context , config , 5 , ""Returning<S2SV_blank>a<S2SV_blank>referral<S2SV_blank>to<S2SV_blank>realm<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>"" ""server<S2SV_blank>%s<S2SV_blank>that<S2SV_blank>was<S2SV_blank>not<S2SV_blank>found"" , realms [ 0 ] , spn ) ; krb5_free_principal ( context , sp ) ; sp = NULL ; krb5_make_principal ( context , & sp , r , KRB5_TGS_NAME , realms [ 0 ] , NULL ) ; free ( spn ) ; spn = NULL ; ret = krb5_unparse_name ( context , sp , & spn ) ; if ( ret ) { krb5_free_host_realm ( context , realms ) ; goto out ; } free ( ref_realm ) ; ref_realm = strdup ( realms [ 0 ] ) ; krb5_free_host_realm ( context , realms ) ; goto server_lookup ; } krb5_free_host_realm ( context , realms ) ; } msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 0 , ""Server<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>database:<S2SV_blank>%s:<S2SV_blank>%s"" , spn , msg ) ; krb5_free_error_message ( context , msg ) ; if ( ret == HDB_ERR_NOENTRY ) ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN ; goto out ; } if ( b -> kdc_options . canonicalize ) rsp = server -> entry . principal ; else rsp = sp ; { krb5_enctype etype ; if ( b -> kdc_options . enc_tkt_in_skey ) { size_t i ; ekey = & adtkt . key ; for ( i = 0 ; i < b -> etype . len ; i ++ ) if ( b -> etype . val [ i ] == adtkt . key . keytype ) break ; if ( i == b -> etype . len ) { kdc_log ( context , config , 0 , ""Addition<S2SV_blank>ticket<S2SV_blank>have<S2SV_blank>not<S2SV_blank>matching<S2SV_blank>etypes"" ) ; krb5_clear_error_message ( context ) ; ret = KRB5KDC_ERR_ETYPE_NOSUPP ; goto out ; } etype = b -> etype . val [ i ] ; kvno = 0 ; } else { Key * skey ; ret = _kdc_find_etype ( context , krb5_principal_is_krbtgt ( context , sp ) ? config -> tgt_use_strongest_session_key : config -> svc_use_strongest_session_key , FALSE , server , b -> etype . val , b -> etype . len , & etype , NULL ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Server<S2SV_blank>(%s)<S2SV_blank>has<S2SV_blank>no<S2SV_blank>support<S2SV_blank>for<S2SV_blank>etypes"" , spn ) ; goto out ; } ret = _kdc_get_preferred_key ( context , config , server , spn , NULL , & skey ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Server<S2SV_blank>(%s)<S2SV_blank>has<S2SV_blank>no<S2SV_blank>supported<S2SV_blank>etypes"" , spn ) ; goto out ; } ekey = & skey -> key ; kvno = server -> entry . kvno ; } ret = krb5_generate_random_keyblock ( context , etype , & sessionkey ) ; if ( ret ) goto out ; } ret = hdb_enctype2key ( context , & krbtgt -> entry , NULL , krbtgt_etype , & tkey_check ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>key<S2SV_blank>for<S2SV_blank>krbtgt<S2SV_blank>PAC<S2SV_blank>check"" ) ; goto out ; } ret = krb5_make_principal ( context , & krbtgt_out_principal , our_realm , KRB5_TGS_NAME , our_realm , NULL ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Failed<S2SV_blank>to<S2SV_blank>make<S2SV_blank>krbtgt<S2SV_blank>principal<S2SV_blank>name<S2SV_blank>object<S2SV_blank>for<S2SV_blank>"" ""authz-data<S2SV_blank>signatures"" ) ; goto out ; } ret = krb5_unparse_name ( context , krbtgt_out_principal , & krbtgt_out_n ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Failed<S2SV_blank>to<S2SV_blank>make<S2SV_blank>krbtgt<S2SV_blank>principal<S2SV_blank>name<S2SV_blank>object<S2SV_blank>for<S2SV_blank>"" ""authz-data<S2SV_blank>signatures"" ) ; goto out ; } ret = _kdc_db_fetch ( context , config , krbtgt_out_principal , HDB_F_GET_KRBTGT , NULL , NULL , & krbtgt_out ) ; if ( ret ) { char * ktpn = NULL ; ret = krb5_unparse_name ( context , krbtgt -> entry . principal , & ktpn ) ; kdc_log ( context , config , 0 , ""No<S2SV_blank>such<S2SV_blank>principal<S2SV_blank>%s<S2SV_blank>(needed<S2SV_blank>for<S2SV_blank>authz-data<S2SV_blank>signature<S2SV_blank>keys)<S2SV_blank>"" ""while<S2SV_blank>processing<S2SV_blank>TGS-REQ<S2SV_blank>for<S2SV_blank>service<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>krbtg<S2SV_blank>%s"" , krbtgt_out_n , spn , ( ret == 0 ) ? ktpn : ""<unknown>"" ) ; free ( ktpn ) ; ret = KRB5KRB_AP_ERR_NOT_US ; goto out ; } if ( strcmp ( krb5_principal_get_realm ( context , server -> entry . principal ) , krb5_principal_get_realm ( context , krbtgt_out -> entry . principal ) ) != 0 ) { char * ktpn ; ret = krb5_unparse_name ( context , krbtgt_out -> entry . principal , & ktpn ) ; kdc_log ( context , config , 0 , ""Request<S2SV_blank>with<S2SV_blank>wrong<S2SV_blank>krbtgt:<S2SV_blank>%s"" , ( ret == 0 ) ? ktpn : ""<unknown>"" ) ; if ( ret == 0 ) free ( ktpn ) ; ret = KRB5KRB_AP_ERR_NOT_US ; goto out ; } ret = _kdc_get_preferred_key ( context , config , krbtgt_out , krbtgt_out_n , NULL , & tkey_sign ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>key<S2SV_blank>for<S2SV_blank>krbtgt<S2SV_blank>PAC<S2SV_blank>signature"" ) ; goto out ; } ret = hdb_enctype2key ( context , & krbtgt_out -> entry , NULL , tkey_sign -> key . keytype , & tkey_sign ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>key<S2SV_blank>for<S2SV_blank>krbtgt<S2SV_blank>PAC<S2SV_blank>signature"" ) ; goto out ; } ret = _kdc_db_fetch ( context , config , cp , HDB_F_GET_CLIENT | flags , NULL , & clientdb , & client ) ; if ( ret == HDB_ERR_NOT_FOUND_HERE ) { } else if ( ret ) { const char * krbtgt_realm , * msg ; krbtgt_realm = krb5_principal_get_realm ( context , krbtgt_out -> entry . principal ) ; if ( strcmp ( krb5_principal_get_realm ( context , cp ) , krbtgt_realm ) == 0 ) { if ( ret == HDB_ERR_NOENTRY ) ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; kdc_log ( context , config , 1 , ""Client<S2SV_blank>no<S2SV_blank>longer<S2SV_blank>in<S2SV_blank>database:<S2SV_blank>%s"" , cpn ) ; goto out ; } msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 1 , ""Client<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>database:<S2SV_blank>%s"" , msg ) ; krb5_free_error_message ( context , msg ) ; } ret = check_PAC ( context , config , cp , NULL , client , server , krbtgt , & tkey_check -> key , ekey , & tkey_sign -> key , tgt , & rspac , & signedpath ) ; if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 0 , ""Verify<S2SV_blank>PAC<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>%s"" , spn , cpn , from , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } ret = check_KRB5SignedPath ( context , config , krbtgt , cp , tgt , & spp , & signedpath ) ; if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 0 , ""KRB5SignedPath<S2SV_blank>check<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>%s"" , spn , cpn , from , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } tp = cp ; tpn = cpn ; if ( client ) { const PA_DATA * sdata ; int i = 0 ; sdata = _kdc_find_padata ( req , & i , KRB5_PADATA_FOR_USER ) ; if ( sdata ) { krb5_crypto crypto ; krb5_data datack ; PA_S4U2Self self ; const char * str ; ret = decode_PA_S4U2Self ( sdata -> padata_value . data , sdata -> padata_value . length , & self , NULL ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>PA-S4U2Self"" ) ; goto out ; } ret = _krb5_s4u2self_to_checksumdata ( context , & self , & datack ) ; if ( ret ) goto out ; ret = krb5_crypto_init ( context , & tgt -> key , 0 , & crypto ) ; if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; free_PA_S4U2Self ( & self ) ; krb5_data_free ( & datack ) ; kdc_log ( context , config , 0 , ""krb5_crypto_init<S2SV_blank>failed:<S2SV_blank>%s"" , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } ret = krb5_verify_checksum ( context , crypto , KRB5_KU_OTHER_CKSUM , datack . data , datack . length , & self . cksum ) ; krb5_data_free ( & datack ) ; krb5_crypto_destroy ( context , crypto ) ; if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; free_PA_S4U2Self ( & self ) ; kdc_log ( context , config , 0 , ""krb5_verify_checksum<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>S4U2Self:<S2SV_blank>%s"" , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } ret = _krb5_principalname2krb5_principal ( context , & tp , self . name , self . realm ) ; free_PA_S4U2Self ( & self ) ; if ( ret ) goto out ; ret = krb5_unparse_name ( context , tp , & tpn ) ; if ( ret ) goto out ; if ( rspac . data ) { krb5_pac p = NULL ; krb5_data_free ( & rspac ) ; ret = _kdc_db_fetch ( context , config , tp , HDB_F_GET_CLIENT | flags , NULL , & s4u2self_impersonated_clientdb , & s4u2self_impersonated_client ) ; if ( ret ) { const char * msg ; if ( ret == HDB_ERR_NOENTRY ) ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 1 , ""S2U4Self<S2SV_blank>principal<S2SV_blank>to<S2SV_blank>impersonate<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>database:<S2SV_blank>%s"" , tpn , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } ret = _kdc_pac_generate ( context , s4u2self_impersonated_client , & p ) ; if ( ret ) { kdc_log ( context , config , 0 , ""PAC<S2SV_blank>generation<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>--<S2SV_blank>%s"" , tpn ) ; goto out ; } if ( p != NULL ) { ret = _krb5_pac_sign ( context , p , ticket -> ticket . authtime , s4u2self_impersonated_client -> entry . principal , ekey , & tkey_sign -> key , & rspac ) ; krb5_pac_free ( context , p ) ; if ( ret ) { kdc_log ( context , config , 0 , ""PAC<S2SV_blank>signing<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>--<S2SV_blank>%s"" , tpn ) ; goto out ; } } } ret = check_s4u2self ( context , config , clientdb , client , sp ) ; if ( ret ) { kdc_log ( context , config , 0 , ""S4U2Self:<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>"" ""to<S2SV_blank>impersonate<S2SV_blank>to<S2SV_blank>service<S2SV_blank>"" ""(tried<S2SV_blank>for<S2SV_blank>user<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>service<S2SV_blank>%s)"" , cpn , tpn , spn ) ; goto out ; } if ( client -> entry . flags . trusted_for_delegation ) { str = ""[forwardable]"" ; } else { b -> kdc_options . forwardable = 0 ; str = """" ; } kdc_log ( context , config , 0 , ""s4u2self<S2SV_blank>%s<S2SV_blank>impersonating<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>"" ""service<S2SV_blank>%s<S2SV_blank>%s"" , cpn , tpn , spn , str ) ; } } if ( client != NULL && b -> additional_tickets != NULL && b -> additional_tickets -> len != 0 && b -> kdc_options . enc_tkt_in_skey == 0 ) { int ad_signedpath = 0 ; Key * clientkey ; Ticket * t ; if ( ! signedpath ) { ret = KRB5KDC_ERR_BADOPTION ; kdc_log ( context , config , 0 , ""Constrained<S2SV_blank>delegation<S2SV_blank>done<S2SV_blank>on<S2SV_blank>service<S2SV_blank>ticket<S2SV_blank>%s/%s"" , cpn , spn ) ; goto out ; } t = & b -> additional_tickets -> val [ 0 ] ; ret = hdb_enctype2key ( context , & client -> entry , hdb_kvno2keys ( context , & client -> entry , t -> enc_part . kvno ? * t -> enc_part . kvno : 0 ) , t -> enc_part . etype , & clientkey ) ; if ( ret ) { ret = KRB5KDC_ERR_ETYPE_NOSUPP ; goto out ; } ret = krb5_decrypt_ticket ( context , t , & clientkey -> key , & adtkt , 0 ) ; if ( ret ) { kdc_log ( context , config , 0 , ""failed<S2SV_blank>to<S2SV_blank>decrypt<S2SV_blank>ticket<S2SV_blank>for<S2SV_blank>"" ""constrained<S2SV_blank>delegation<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>"" , cpn , spn ) ; goto out ; } ret = _krb5_principalname2krb5_principal ( context , & tp , adtkt . cname , adtkt . crealm ) ; if ( ret ) goto out ; ret = krb5_unparse_name ( context , tp , & tpn ) ; if ( ret ) goto out ; ret = _krb5_principalname2krb5_principal ( context , & dp , t -> sname , t -> realm ) ; if ( ret ) goto out ; ret = krb5_unparse_name ( context , dp , & dpn ) ; if ( ret ) goto out ; if ( adtkt . flags . forwardable == 0 ) { kdc_log ( context , config , 0 , ""Missing<S2SV_blank>forwardable<S2SV_blank>flag<S2SV_blank>on<S2SV_blank>ticket<S2SV_blank>for<S2SV_blank>"" ""constrained<S2SV_blank>delegation<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>as<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>"" , cpn , dpn , tpn , spn ) ; ret = KRB5KDC_ERR_BADOPTION ; goto out ; } ret = check_constrained_delegation ( context , config , clientdb , client , server , sp ) ; if ( ret ) { kdc_log ( context , config , 0 , ""constrained<S2SV_blank>delegation<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>as<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>allowed"" , cpn , dpn , tpn , spn ) ; goto out ; } ret = verify_flags ( context , config , & adtkt , tpn ) ; if ( ret ) { goto out ; } krb5_data_free ( & rspac ) ; ret = check_PAC ( context , config , tp , dp , client , server , krbtgt , & clientkey -> key , ekey , & tkey_sign -> key , & adtkt , & rspac , & ad_signedpath ) ; if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 0 , ""Verify<S2SV_blank>delegated<S2SV_blank>PAC<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>client"" ""%s<S2SV_blank>(%s)<S2SV_blank>as<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>%s"" , spn , cpn , dpn , tpn , from , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } ret = check_KRB5SignedPath ( context , config , krbtgt , cp , & adtkt , NULL , & ad_signedpath ) ; if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 0 , ""KRB5SignedPath<S2SV_blank>check<S2SV_blank>from<S2SV_blank>service<S2SV_blank>%s<S2SV_blank>failed<S2SV_blank>"" ""for<S2SV_blank>delegation<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s<S2SV_blank>(%s)"" ""from<S2SV_blank>%s<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>%s"" , spn , tpn , dpn , cpn , from , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } if ( ! ad_signedpath ) { ret = KRB5KDC_ERR_BADOPTION ; kdc_log ( context , config , 0 , ""Ticket<S2SV_blank>not<S2SV_blank>signed<S2SV_blank>with<S2SV_blank>PAC<S2SV_blank>nor<S2SV_blank>SignedPath<S2SV_blank>service<S2SV_blank>%s<S2SV_blank>failed<S2SV_blank>"" ""for<S2SV_blank>delegation<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s<S2SV_blank>(%s)"" ""from<S2SV_blank>%s"" , spn , tpn , dpn , cpn , from ) ; goto out ; } kdc_log ( context , config , 0 , ""constrained<S2SV_blank>delegation<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>"" ""from<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>%s"" , tpn , cpn , dpn , spn ) ; } ret = kdc_check_flags ( context , config , client , cpn , server , spn , FALSE ) ; if ( ret ) goto out ; if ( ( b -> kdc_options . validate || b -> kdc_options . renew ) && ! krb5_principal_compare ( context , krbtgt -> entry . principal , server -> entry . principal ) ) { kdc_log ( context , config , 0 , ""Inconsistent<S2SV_blank>request."" ) ; ret = KRB5KDC_ERR_SERVER_NOMATCH ; goto out ; } if ( ! _kdc_check_addresses ( context , config , tgt -> caddr , from_addr ) ) { ret = KRB5KRB_AP_ERR_BADADDR ; kdc_log ( context , config , 0 , ""Request<S2SV_blank>from<S2SV_blank>wrong<S2SV_blank>address"" ) ; goto out ; } if ( ref_realm ) { PA_DATA pa ; krb5_crypto crypto ; kdc_log ( context , config , 0 , ""Adding<S2SV_blank>server<S2SV_blank>referral<S2SV_blank>to<S2SV_blank>%s"" , ref_realm ) ; ret = krb5_crypto_init ( context , & sessionkey , 0 , & crypto ) ; if ( ret ) goto out ; ret = build_server_referral ( context , config , crypto , ref_realm , NULL , s , & pa . padata_value ) ; krb5_crypto_destroy ( context , crypto ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Failed<S2SV_blank>building<S2SV_blank>server<S2SV_blank>referral"" ) ; goto out ; } pa . padata_type = KRB5_PADATA_SERVER_REFERRAL ; ret = add_METHOD_DATA ( & enc_pa_data , & pa ) ; krb5_data_free ( & pa . padata_value ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Add<S2SV_blank>server<S2SV_blank>referral<S2SV_blank>METHOD-DATA<S2SV_blank>failed"" ) ; goto out ; } } ret = tgs_make_reply ( context , config , b , tp , tgt , replykey , rk_is_subkey , ekey , & sessionkey , kvno , * auth_data , server , rsp , spn , client , cp ,  krbtgt_out ,  tkey_sign -> key . keytype , spp , & rspac , & enc_pa_data , e_text , reply ) ; out : if ( tpn != cpn ) free ( tpn ) ; free ( spn ) ; free ( cpn ) ; free ( dpn ) ; free ( krbtgt_out_n ) ; _krb5_free_capath ( context , capath ) ; krb5_data_free ( & rspac ) ; krb5_free_keyblock_contents ( context , & sessionkey ) ; if ( krbtgt_out ) _kdc_free_ent ( context , krbtgt_out ) ; if ( server ) _kdc_free_ent ( context , server ) ; if ( client ) _kdc_free_ent ( context , client ) ; if ( s4u2self_impersonated_client ) _kdc_free_ent ( context , s4u2self_impersonated_client ) ; if ( tp && tp != cp ) krb5_free_principal ( context , tp ) ; krb5_free_principal ( context , cp ) ; krb5_free_principal ( context , dp ) ; krb5_free_principal ( context , sp ) ; krb5_free_principal ( context , krbtgt_out_principal ) ; free ( ref_realm ) ; free_METHOD_DATA ( & enc_pa_data ) ; free_EncTicketPart ( & adtkt ) ; return ret ; }","ret = tgs_make_reply ( context , config , b , tp , tgt , replykey , rk_is_subkey , ekey , & sessionkey , kvno , * auth_data , server , rsp , spn , client , cp , krbtgt_out , tkey_sign -> key . keytype , spp , & rspac , & enc_pa_data , e_text , reply ) ;",585
795,"buggy line: cookie = dentry -> d_inode -> i_op -> follow_link ( dentry , nd ) ;error = PTR_ERR ( cookie ) ;cwe id:CWE-20context: static __always_inline int __do_follow_link ( struct path * path , struct nameidata * nd ) { int error ; void * cookie ; struct dentry * dentry = path -> dentry ; touch_atime ( path -> mnt , dentry ) ; nd_set_link ( nd , NULL ) ; if ( path -> mnt != nd -> path . mnt ) { path_to_nameidata ( path , nd ) ; dget ( dentry ) ; } mntget ( path -> mnt ) ;  cookie = dentry -> d_inode -> i_op -> follow_link ( dentry , nd ) ;  error = PTR_ERR ( cookie ) ; if ( ! IS_ERR ( cookie ) ) { char * s = nd_get_link ( nd ) ; error = 0 ; if ( s ) error = __vfs_follow_link ( nd , s ) ; else if ( nd -> last_type == LAST_BIND ) { error = force_reval_path ( & nd -> path , nd ) ; if ( error ) path_put ( & nd -> path ) ; } if ( dentry -> d_inode -> i_op -> put_link ) dentry -> d_inode -> i_op -> put_link ( dentry , nd , cookie ) ; } return error ; }","nd -> last_type = LAST_BIND ;cookie = dentry -> d_inode -> i_op -> follow_link ( dentry , nd ) ;error = PTR_ERR ( cookie ) ;",586
796,"buggy line: struct usbdevfs_connectinfo ci = {. devnum = ps -> dev -> devnum ,  . slow = ps -> dev -> speed == USB_SPEED_LOW  };if ( copy_to_user ( arg , & ci , sizeof ( ci ) ) ) return - EFAULT ;cwe id:CWE-200context: static int proc_connectinfo ( struct usb_dev_state * ps , void __user * arg ) {  struct usbdevfs_connectinfo ci = {   . devnum = ps -> dev -> devnum ,  . slow = ps -> dev -> speed == USB_SPEED_LOW  } ;  if ( copy_to_user ( arg , & ci , sizeof ( ci ) ) ) return - EFAULT ; return 0 ; }","struct usbdevfs_connectinfo ci ;memset ( & ci , 0 , sizeof ( ci ) ) ;ci . devnum = ps -> dev -> devnum ;ci . slow = ps -> dev -> speed == USB_SPEED_LOW ;if ( copy_to_user ( arg , & ci , sizeof ( ci ) ) ) return - EFAULT ;",587
797,"buggy line: static int ip_options_get_finish ( struct net * net , struct ip_options * * optp ,   struct ip_options * opt , int optlen )  {while ( optlen & 3 )  opt -> __data [ optlen ++ ] = IPOPT_END ;opt -> optlen = optlen ;if ( optlen && ip_options_compile ( net , opt , NULL ) ) {kfree ( opt ) ;cwe id:CWE-362context:  static int ip_options_get_finish ( struct net * net , struct ip_options * * optp ,   struct ip_options * opt , int optlen )  { while ( optlen & 3 )  opt -> __data [ optlen ++ ] = IPOPT_END ;   opt -> optlen = optlen ;   if ( optlen && ip_options_compile ( net , opt , NULL ) ) {  kfree ( opt ) ; return - EINVAL ; } kfree ( * optp ) ; * optp = opt ; return 0 ; }","static int ip_options_get_finish ( struct net * net , struct ip_options_rcu * * optp , struct ip_options * opt , int optlen ) {while ( optlen & 3 ) opt -> opt . __data [ optlen ++ ] = IPOPT_END ;opt -> opt . optlen = optlen ;if ( optlen && ip_options_compile ( net , & opt -> opt , NULL ) ) {kfree ( opt ) ;",588
798,"buggy line: }retval = xfs_attr3_leaf_add ( bp , args ) ;cwe id:CWE-19context: STATIC int xfs_attr_leaf_addname ( xfs_da_args_t * args ) { xfs_inode_t * dp ; struct xfs_buf * bp ; int retval , error , committed , forkoff ; trace_xfs_attr_leaf_addname ( args ) ; dp = args -> dp ; args -> blkno = 0 ; error = xfs_attr3_leaf_read ( args -> trans , args -> dp , args -> blkno , - 1 , & bp ) ; if ( error ) return error ; retval = xfs_attr3_leaf_lookup_int ( bp , args ) ; if ( ( args -> flags & ATTR_REPLACE ) && ( retval == ENOATTR ) ) { xfs_trans_brelse ( args -> trans , bp ) ; return retval ; } else if ( retval == EEXIST ) { if ( args -> flags & ATTR_CREATE ) { xfs_trans_brelse ( args -> trans , bp ) ; return retval ; } trace_xfs_attr_leaf_replace ( args ) ; args -> op_flags |= XFS_DA_OP_RENAME ; args -> blkno2 = args -> blkno ; args -> index2 = args -> index ; args -> rmtblkno2 = args -> rmtblkno ; args -> rmtblkcnt2 = args -> rmtblkcnt ;  }  retval = xfs_attr3_leaf_add ( bp , args ) ; if ( retval == ENOSPC ) { xfs_bmap_init ( args -> flist , args -> firstblock ) ; error = xfs_attr3_leaf_to_node ( args ) ; if ( ! error ) { error = xfs_bmap_finish ( & args -> trans , args -> flist , & committed ) ; } if ( error ) { ASSERT ( committed ) ; args -> trans = NULL ; xfs_bmap_cancel ( args -> flist ) ; return ( error ) ; } if ( committed ) xfs_trans_ijoin ( args -> trans , dp , 0 ) ; error = xfs_trans_roll ( & args -> trans , dp ) ; if ( error ) return ( error ) ; error = xfs_attr_node_addname ( args ) ; return ( error ) ; } error = xfs_trans_roll ( & args -> trans , dp ) ; if ( error ) return ( error ) ; if ( args -> rmtblkno > 0 ) { error = xfs_attr_rmtval_set ( args ) ; if ( error ) return ( error ) ; } if ( args -> op_flags & XFS_DA_OP_RENAME ) { error = xfs_attr3_leaf_flipflags ( args ) ; if ( error ) return ( error ) ; args -> index = args -> index2 ; args -> blkno = args -> blkno2 ; args -> rmtblkno = args -> rmtblkno2 ; args -> rmtblkcnt = args -> rmtblkcnt2 ;  if ( args -> rmtblkno ) {  error = xfs_attr_rmtval_remove ( args ) ; if ( error ) return ( error ) ; } error = xfs_attr3_leaf_read ( args -> trans , args -> dp , args -> blkno , - 1 , & bp ) ; if ( error ) return error ; xfs_attr3_leaf_remove ( bp , args ) ; if ( ( forkoff = xfs_attr_shortform_allfit ( bp , dp ) ) ) { xfs_bmap_init ( args -> flist , args -> firstblock ) ; error = xfs_attr3_leaf_to_shortform ( bp , args , forkoff ) ; if ( ! error ) { error = xfs_bmap_finish ( & args -> trans , args -> flist , & committed ) ; } if ( error ) { ASSERT ( committed ) ; args -> trans = NULL ; xfs_bmap_cancel ( args -> flist ) ; return ( error ) ; } if ( committed ) xfs_trans_ijoin ( args -> trans , dp , 0 ) ; } error = xfs_trans_roll ( & args -> trans , dp ) ; } else if ( args -> rmtblkno > 0 ) { error = xfs_attr3_leaf_clearflag ( args ) ; } return error ; }","args -> rmtvaluelen2 = args -> rmtvaluelen ;args -> rmtblkno = 0 ;args -> rmtblkcnt = 0 ;args -> rmtvaluelen = 0 ;}retval = xfs_attr3_leaf_add ( bp , args ) ;",589
799,"buggy line: if ( args -> rmtblkno ) {error = xfs_attr_rmtval_remove ( args ) ;cwe id:CWE-19context: STATIC int xfs_attr_leaf_addname ( xfs_da_args_t * args ) { xfs_inode_t * dp ; struct xfs_buf * bp ; int retval , error , committed , forkoff ; trace_xfs_attr_leaf_addname ( args ) ; dp = args -> dp ; args -> blkno = 0 ; error = xfs_attr3_leaf_read ( args -> trans , args -> dp , args -> blkno , - 1 , & bp ) ; if ( error ) return error ; retval = xfs_attr3_leaf_lookup_int ( bp , args ) ; if ( ( args -> flags & ATTR_REPLACE ) && ( retval == ENOATTR ) ) { xfs_trans_brelse ( args -> trans , bp ) ; return retval ; } else if ( retval == EEXIST ) { if ( args -> flags & ATTR_CREATE ) { xfs_trans_brelse ( args -> trans , bp ) ; return retval ; } trace_xfs_attr_leaf_replace ( args ) ; args -> op_flags |= XFS_DA_OP_RENAME ; args -> blkno2 = args -> blkno ; args -> index2 = args -> index ; args -> rmtblkno2 = args -> rmtblkno ; args -> rmtblkcnt2 = args -> rmtblkcnt ;  }  retval = xfs_attr3_leaf_add ( bp , args ) ; if ( retval == ENOSPC ) { xfs_bmap_init ( args -> flist , args -> firstblock ) ; error = xfs_attr3_leaf_to_node ( args ) ; if ( ! error ) { error = xfs_bmap_finish ( & args -> trans , args -> flist , & committed ) ; } if ( error ) { ASSERT ( committed ) ; args -> trans = NULL ; xfs_bmap_cancel ( args -> flist ) ; return ( error ) ; } if ( committed ) xfs_trans_ijoin ( args -> trans , dp , 0 ) ; error = xfs_trans_roll ( & args -> trans , dp ) ; if ( error ) return ( error ) ; error = xfs_attr_node_addname ( args ) ; return ( error ) ; } error = xfs_trans_roll ( & args -> trans , dp ) ; if ( error ) return ( error ) ; if ( args -> rmtblkno > 0 ) { error = xfs_attr_rmtval_set ( args ) ; if ( error ) return ( error ) ; } if ( args -> op_flags & XFS_DA_OP_RENAME ) { error = xfs_attr3_leaf_flipflags ( args ) ; if ( error ) return ( error ) ; args -> index = args -> index2 ; args -> blkno = args -> blkno2 ; args -> rmtblkno = args -> rmtblkno2 ; args -> rmtblkcnt = args -> rmtblkcnt2 ;  if ( args -> rmtblkno ) {  error = xfs_attr_rmtval_remove ( args ) ; if ( error ) return ( error ) ; } error = xfs_attr3_leaf_read ( args -> trans , args -> dp , args -> blkno , - 1 , & bp ) ; if ( error ) return error ; xfs_attr3_leaf_remove ( bp , args ) ; if ( ( forkoff = xfs_attr_shortform_allfit ( bp , dp ) ) ) { xfs_bmap_init ( args -> flist , args -> firstblock ) ; error = xfs_attr3_leaf_to_shortform ( bp , args , forkoff ) ; if ( ! error ) { error = xfs_bmap_finish ( & args -> trans , args -> flist , & committed ) ; } if ( error ) { ASSERT ( committed ) ; args -> trans = NULL ; xfs_bmap_cancel ( args -> flist ) ; return ( error ) ; } if ( committed ) xfs_trans_ijoin ( args -> trans , dp , 0 ) ; } error = xfs_trans_roll ( & args -> trans , dp ) ; } else if ( args -> rmtblkno > 0 ) { error = xfs_attr3_leaf_clearflag ( args ) ; } return error ; }",args -> rmtvaluelen = args -> rmtvaluelen2 ;if ( args -> rmtblkno ) {error = xfs_attr_rmtval_remove ( args ) ;,589
800,"buggy line: ACCESS_MASK access = FILE_READ_ATTRIBUTES ;cwe id:CWE-119context: NTSTATUS ProcessMainDeviceControlIrp ( PDEVICE_OBJECT DeviceObject , PEXTENSION Extension , PIRP Irp ) { PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation ( Irp ) ; NTSTATUS ntStatus ; switch ( irpSp -> Parameters . DeviceIoControl . IoControlCode ) { case TC_IOCTL_GET_DRIVER_VERSION : case TC_IOCTL_LEGACY_GET_DRIVER_VERSION : if ( ValidateIOBufferSize ( Irp , sizeof ( LONG ) , ValidateOutput ) ) { LONG tmp = VERSION_NUM ; memcpy ( Irp -> AssociatedIrp . SystemBuffer , & tmp , 4 ) ; Irp -> IoStatus . Information = sizeof ( LONG ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_GET_DEVICE_REFCOUNT : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { * ( int * ) Irp -> AssociatedIrp . SystemBuffer = DeviceObject -> ReferenceCount ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_IS_DRIVER_UNLOAD_DISABLED : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { LONG deviceObjectCount = 0 ; * ( int * ) Irp -> AssociatedIrp . SystemBuffer = DriverUnloadDisabled ; if ( IoEnumerateDeviceObjectList ( TCDriverObject , NULL , 0 , & deviceObjectCount ) == STATUS_BUFFER_TOO_SMALL && deviceObjectCount > 1 ) * ( int * ) Irp -> AssociatedIrp . SystemBuffer = TRUE ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_IS_ANY_VOLUME_MOUNTED : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { int drive ; * ( int * ) Irp -> AssociatedIrp . SystemBuffer = 0 ; for ( drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER ; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER ; ++ drive ) { if ( GetVirtualVolumeDeviceObject ( drive ) ) { * ( int * ) Irp -> AssociatedIrp . SystemBuffer = 1 ; break ; } } if ( IsBootDriveMounted ( ) ) * ( int * ) Irp -> AssociatedIrp . SystemBuffer = 1 ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_OPEN_TEST : { OPEN_TEST_STRUCT * opentest = ( OPEN_TEST_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; OBJECT_ATTRIBUTES ObjectAttributes ; HANDLE NtFileHandle ; UNICODE_STRING FullFileName ; IO_STATUS_BLOCK IoStatus ; LARGE_INTEGER offset ; ACCESS_MASK access = FILE_READ_ATTRIBUTES ; if ( ! ValidateIOBufferSize ( Irp , sizeof ( OPEN_TEST_STRUCT ) , ValidateInputOutput ) ) break ; EnsureNullTerminatedString ( opentest -> wszFileName , sizeof ( opentest -> wszFileName ) ) ; RtlInitUnicodeString ( & FullFileName , opentest -> wszFileName ) ; InitializeObjectAttributes ( & ObjectAttributes , & FullFileName , OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE , NULL , NULL ) ; if ( opentest -> bDetectTCBootLoader || opentest -> DetectFilesystem || opentest -> bComputeVolumeIDs ) access |= FILE_READ_DATA ; ntStatus = ZwCreateFile ( & NtFileHandle , SYNCHRONIZE | access , & ObjectAttributes , & IoStatus , NULL , 0 , FILE_SHARE_READ | FILE_SHARE_WRITE , FILE_OPEN , FILE_SYNCHRONOUS_IO_NONALERT , NULL , 0 ) ; if ( NT_SUCCESS ( ntStatus ) ) { opentest -> TCBootLoaderDetected = FALSE ; opentest -> FilesystemDetected = FALSE ; memset ( opentest -> VolumeIDComputed , 0 , sizeof ( opentest -> VolumeIDComputed ) ) ; memset ( opentest -> volumeIDs , 0 , sizeof ( opentest -> volumeIDs ) ) ; if ( opentest -> bDetectTCBootLoader || opentest -> DetectFilesystem || opentest -> bComputeVolumeIDs ) { byte * readBuffer = TCalloc ( TC_MAX_VOLUME_SECTOR_SIZE ) ; if ( ! readBuffer ) { ntStatus = STATUS_INSUFFICIENT_RESOURCES ; } else { if ( opentest -> bDetectTCBootLoader || opentest -> DetectFilesystem ) { offset . QuadPart = 0 ; ntStatus = ZwReadFile ( NtFileHandle , NULL , NULL , NULL , & IoStatus , readBuffer , TC_MAX_VOLUME_SECTOR_SIZE , & offset , NULL ) ; if ( NT_SUCCESS ( ntStatus ) ) { size_t i ; if ( opentest -> bDetectTCBootLoader && IoStatus . Information >= TC_SECTOR_SIZE_BIOS ) { for ( i = 0 ; i < TC_SECTOR_SIZE_BIOS - strlen ( TC_APP_NAME ) ; ++ i ) { if ( memcmp ( readBuffer + i , TC_APP_NAME , strlen ( TC_APP_NAME ) ) == 0 ) { opentest -> TCBootLoaderDetected = TRUE ; break ; } } } if ( opentest -> DetectFilesystem && IoStatus . Information >= sizeof ( int64 ) ) { switch ( BE64 ( * ( uint64 * ) readBuffer ) ) { case 0xEB52904E54465320ULL : case 0xEB3C904D53444F53ULL : case 0xEB58904D53444F53ULL : case 0xEB76904558464154ULL : case 0x0000005265465300ULL : case 0xEB58906D6B66732EULL : case 0xEB58906D6B646F73ULL : case 0xEB3C906D6B66732EULL : case 0xEB3C906D6B646F73ULL : opentest -> FilesystemDetected = TRUE ; break ; case 0x0000000000000000ULL : if ( IsAllZeroes ( readBuffer + 8 , TC_VOLUME_HEADER_EFFECTIVE_SIZE - 8 ) ) opentest -> FilesystemDetected = TRUE ; break ; } } } } if ( opentest -> bComputeVolumeIDs && ( ! opentest -> DetectFilesystem || ! opentest -> FilesystemDetected ) ) { int volumeType ; for ( volumeType = TC_VOLUME_TYPE_NORMAL ; volumeType < TC_VOLUME_TYPE_COUNT ; volumeType ++ ) { switch ( volumeType ) { case TC_VOLUME_TYPE_NORMAL : offset . QuadPart = TC_VOLUME_HEADER_OFFSET ; break ; case TC_VOLUME_TYPE_HIDDEN : offset . QuadPart = TC_HIDDEN_VOLUME_HEADER_OFFSET ; break ; } ntStatus = ZwReadFile ( NtFileHandle , NULL , NULL , NULL , & IoStatus , readBuffer , TC_MAX_VOLUME_SECTOR_SIZE , & offset , NULL ) ; if ( NT_SUCCESS ( ntStatus ) ) { sha256 ( opentest -> volumeIDs [ volumeType ] , readBuffer , TC_VOLUME_HEADER_EFFECTIVE_SIZE ) ; opentest -> VolumeIDComputed [ volumeType ] = TRUE ; } } } TCfree ( readBuffer ) ; } } ZwClose ( NtFileHandle ) ; Dump ( ""Open<S2SV_blank>test<S2SV_blank>on<S2SV_blank>file<S2SV_blank>%ls<S2SV_blank>success.\\n"" , opentest -> wszFileName ) ; } else { # if 0 Dump ( ""Open<S2SV_blank>test<S2SV_blank>on<S2SV_blank>file<S2SV_blank>%ls<S2SV_blank>failed<S2SV_blank>NTSTATUS<S2SV_blank>0x%08x\\n"" , opentest -> wszFileName , ntStatus ) ; # endif } Irp -> IoStatus . Information = NT_SUCCESS ( ntStatus ) ? sizeof ( OPEN_TEST_STRUCT ) : 0 ; Irp -> IoStatus . Status = ntStatus ; } break ; case TC_IOCTL_GET_SYSTEM_DRIVE_CONFIG : { GetSystemDriveConfigurationRequest * request = ( GetSystemDriveConfigurationRequest * ) Irp -> AssociatedIrp . SystemBuffer ; OBJECT_ATTRIBUTES ObjectAttributes ; HANDLE NtFileHandle ; UNICODE_STRING FullFileName ; IO_STATUS_BLOCK IoStatus ; LARGE_INTEGER offset ;  byte readBuffer [ TC_SECTOR_SIZE_BIOS ] ;  if ( ! ValidateIOBufferSize ( Irp , sizeof ( GetSystemDriveConfigurationRequest ) , ValidateInputOutput ) )  break ;  EnsureNullTerminatedString ( request -> DevicePath , sizeof ( request -> DevicePath ) ) ; RtlInitUnicodeString ( & FullFileName , request -> DevicePath ) ; InitializeObjectAttributes ( & ObjectAttributes , & FullFileName , OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE , NULL , NULL ) ; ntStatus = ZwCreateFile ( & NtFileHandle , SYNCHRONIZE | GENERIC_READ , & ObjectAttributes , & IoStatus , NULL , FILE_ATTRIBUTE_NORMAL , FILE_SHARE_READ | FILE_SHARE_WRITE , FILE_OPEN , FILE_SYNCHRONOUS_IO_NONALERT | FILE_RANDOM_ACCESS , NULL , 0 ) ; if ( NT_SUCCESS ( ntStatus ) ) {  offset . QuadPart = 0 ;  ntStatus = ZwReadFile ( NtFileHandle , NULL , NULL , NULL , & IoStatus , readBuffer ,  sizeof ( readBuffer ) ,  & offset , NULL ) ;  if ( NT_SUCCESS ( ntStatus ) )  { size_t i ; request -> DriveIsDynamic = FALSE ; if ( readBuffer [ 510 ] == 0x55 && readBuffer [ 511 ] == 0xaa ) { int i ; for ( i = 0 ; i < 4 ; ++ i ) { if ( readBuffer [ 446 + i * 16 + 4 ] == PARTITION_LDM ) { request -> DriveIsDynamic = TRUE ; break ; } } } request -> BootLoaderVersion = 0 ; request -> Configuration = 0 ; request -> UserConfiguration = 0 ; request -> CustomUserMessage [ 0 ] = 0 ; for ( i = 0 ; i < sizeof ( readBuffer ) - strlen ( TC_APP_NAME ) ; ++ i ) { if ( memcmp ( readBuffer + i , TC_APP_NAME , strlen ( TC_APP_NAME ) ) == 0 ) { request -> BootLoaderVersion = BE16 ( * ( uint16 * ) ( readBuffer + TC_BOOT_SECTOR_VERSION_OFFSET ) ) ; request -> Configuration = readBuffer [ TC_BOOT_SECTOR_CONFIG_OFFSET ] ; if ( request -> BootLoaderVersion != 0 && request -> BootLoaderVersion <= VERSION_NUM ) { request -> UserConfiguration = readBuffer [ TC_BOOT_SECTOR_USER_CONFIG_OFFSET ] ; memcpy ( request -> CustomUserMessage , readBuffer + TC_BOOT_SECTOR_USER_MESSAGE_OFFSET , TC_BOOT_SECTOR_USER_MESSAGE_MAX_LENGTH ) ; } break ; } } Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = sizeof ( * request ) ; } else {  Irp -> IoStatus . Status = ntStatus ;   Irp -> IoStatus . Information = 0 ;  } ZwClose ( NtFileHandle ) ; } else { Irp -> IoStatus . Status = ntStatus ; Irp -> IoStatus . Information = 0 ; } } break ; case TC_IOCTL_WIPE_PASSWORD_CACHE : WipeCache ( ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_PASSWORD_CACHE_STATUS : Irp -> IoStatus . Status = cacheEmpty ? STATUS_PIPE_EMPTY : STATUS_SUCCESS ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_SET_PORTABLE_MODE_STATUS : if ( ! UserCanAccessDriveDevice ( ) ) { Irp -> IoStatus . Status = STATUS_ACCESS_DENIED ; Irp -> IoStatus . Information = 0 ; } else { PortableMode = TRUE ; Dump ( ""Setting<S2SV_blank>portable<S2SV_blank>mode\\n"" ) ; } break ; case TC_IOCTL_GET_PORTABLE_MODE_STATUS : Irp -> IoStatus . Status = PortableMode ? STATUS_SUCCESS : STATUS_PIPE_EMPTY ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_MOUNTED_VOLUMES : if ( ValidateIOBufferSize ( Irp , sizeof ( MOUNT_LIST_STRUCT ) , ValidateOutput ) ) { MOUNT_LIST_STRUCT * list = ( MOUNT_LIST_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; PDEVICE_OBJECT ListDevice ; int drive ; list -> ulMountedDrives = 0 ; for ( drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER ; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER ; ++ drive ) { PEXTENSION ListExtension ; ListDevice = GetVirtualVolumeDeviceObject ( drive ) ; if ( ! ListDevice ) continue ; ListExtension = ( PEXTENSION ) ListDevice -> DeviceExtension ; if ( IsVolumeAccessibleByCurrentUser ( ListExtension ) ) { list -> ulMountedDrives |= ( 1 << ListExtension -> nDosDriveNo ) ; RtlStringCbCopyW ( list -> wszVolume [ ListExtension -> nDosDriveNo ] , sizeof ( list -> wszVolume [ ListExtension -> nDosDriveNo ] ) , ListExtension -> wszVolume ) ; RtlStringCbCopyW ( list -> wszLabel [ ListExtension -> nDosDriveNo ] , sizeof ( list -> wszLabel [ ListExtension -> nDosDriveNo ] ) , ListExtension -> wszLabel ) ; memcpy ( list -> volumeID [ ListExtension -> nDosDriveNo ] , ListExtension -> volumeID , VOLUME_ID_SIZE ) ; list -> diskLength [ ListExtension -> nDosDriveNo ] = ListExtension -> DiskLength ; list -> ea [ ListExtension -> nDosDriveNo ] = ListExtension -> cryptoInfo -> ea ; if ( ListExtension -> cryptoInfo -> hiddenVolume ) list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_HIDDEN ; else if ( ListExtension -> cryptoInfo -> bHiddenVolProtectionAction ) list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_OUTER_VOL_WRITE_PREVENTED ; else if ( ListExtension -> cryptoInfo -> bProtectHiddenVolume ) list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_OUTER ; else list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_NORMAL ; list -> truecryptMode [ ListExtension -> nDosDriveNo ] = ListExtension -> cryptoInfo -> bTrueCryptMode ; } } Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = sizeof ( MOUNT_LIST_STRUCT ) ; } break ; case TC_IOCTL_LEGACY_GET_MOUNTED_VOLUMES : if ( ValidateIOBufferSize ( Irp , sizeof ( uint32 ) , ValidateOutput ) ) { memset ( Irp -> AssociatedIrp . SystemBuffer , 0 , irpSp -> Parameters . DeviceIoControl . OutputBufferLength ) ; * ( uint32 * ) Irp -> AssociatedIrp . SystemBuffer = 0xffffFFFF ; Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = irpSp -> Parameters . DeviceIoControl . OutputBufferLength ; } break ; case TC_IOCTL_GET_VOLUME_PROPERTIES : if ( ValidateIOBufferSize ( Irp , sizeof ( VOLUME_PROPERTIES_STRUCT ) , ValidateInputOutput ) ) { VOLUME_PROPERTIES_STRUCT * prop = ( VOLUME_PROPERTIES_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; PDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject ( prop -> driveNo ) ; Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; if ( ListDevice ) { PEXTENSION ListExtension = ( PEXTENSION ) ListDevice -> DeviceExtension ; if ( IsVolumeAccessibleByCurrentUser ( ListExtension ) ) { prop -> uniqueId = ListExtension -> UniqueVolumeId ; RtlStringCbCopyW ( prop -> wszVolume , sizeof ( prop -> wszVolume ) , ListExtension -> wszVolume ) ; RtlStringCbCopyW ( prop -> wszLabel , sizeof ( prop -> wszLabel ) , ListExtension -> wszLabel ) ; memcpy ( prop -> volumeID , ListExtension -> volumeID , VOLUME_ID_SIZE ) ; prop -> bDriverSetLabel = ListExtension -> bDriverSetLabel ; prop -> diskLength = ListExtension -> DiskLength ; prop -> ea = ListExtension -> cryptoInfo -> ea ; prop -> mode = ListExtension -> cryptoInfo -> mode ; prop -> pkcs5 = ListExtension -> cryptoInfo -> pkcs5 ; prop -> pkcs5Iterations = ListExtension -> cryptoInfo -> noIterations ; prop -> volumePim = ListExtension -> cryptoInfo -> volumePim ; # if 0 prop -> volumeCreationTime = ListExtension -> cryptoInfo -> volume_creation_time ; prop -> headerCreationTime = ListExtension -> cryptoInfo -> header_creation_time ; # endif prop -> volumeHeaderFlags = ListExtension -> cryptoInfo -> HeaderFlags ; prop -> readOnly = ListExtension -> bReadOnly ; prop -> removable = ListExtension -> bRemovable ; prop -> partitionInInactiveSysEncScope = ListExtension -> PartitionInInactiveSysEncScope ; prop -> hiddenVolume = ListExtension -> cryptoInfo -> hiddenVolume ; if ( ListExtension -> cryptoInfo -> bProtectHiddenVolume ) prop -> hiddenVolProtection = ListExtension -> cryptoInfo -> bHiddenVolProtectionAction ? HIDVOL_PROT_STATUS_ACTION_TAKEN : HIDVOL_PROT_STATUS_ACTIVE ; else prop -> hiddenVolProtection = HIDVOL_PROT_STATUS_NONE ; prop -> totalBytesRead = ListExtension -> Queue . TotalBytesRead ; prop -> totalBytesWritten = ListExtension -> Queue . TotalBytesWritten ; prop -> volFormatVersion = ListExtension -> cryptoInfo -> LegacyVolume ? TC_VOLUME_FORMAT_VERSION_PRE_6_0 : TC_VOLUME_FORMAT_VERSION ; Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = sizeof ( VOLUME_PROPERTIES_STRUCT ) ; } } } break ; case TC_IOCTL_GET_RESOLVED_SYMLINK : if ( ValidateIOBufferSize ( Irp , sizeof ( RESOLVE_SYMLINK_STRUCT ) , ValidateInputOutput ) ) { RESOLVE_SYMLINK_STRUCT * resolve = ( RESOLVE_SYMLINK_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; { NTSTATUS ntStatus ; EnsureNullTerminatedString ( resolve -> symLinkName , sizeof ( resolve -> symLinkName ) ) ; ntStatus = SymbolicLinkToTarget ( resolve -> symLinkName , resolve -> targetName , sizeof ( resolve -> targetName ) ) ; Irp -> IoStatus . Information = sizeof ( RESOLVE_SYMLINK_STRUCT ) ; Irp -> IoStatus . Status = ntStatus ; } } break ; case TC_IOCTL_GET_DRIVE_PARTITION_INFO : if ( ValidateIOBufferSize ( Irp , sizeof ( DISK_PARTITION_INFO_STRUCT ) , ValidateInputOutput ) ) { DISK_PARTITION_INFO_STRUCT * info = ( DISK_PARTITION_INFO_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; { PARTITION_INFORMATION_EX pi ; NTSTATUS ntStatus ; EnsureNullTerminatedString ( info -> deviceName , sizeof ( info -> deviceName ) ) ; ntStatus = TCDeviceIoControl ( info -> deviceName , IOCTL_DISK_GET_PARTITION_INFO_EX , NULL , 0 , & pi , sizeof ( pi ) ) ; if ( NT_SUCCESS ( ntStatus ) ) { memset ( & info -> partInfo , 0 , sizeof ( info -> partInfo ) ) ; info -> partInfo . PartitionLength = pi . PartitionLength ; info -> partInfo . PartitionNumber = pi . PartitionNumber ; info -> partInfo . StartingOffset = pi . StartingOffset ; if ( pi . PartitionStyle == PARTITION_STYLE_MBR ) { info -> partInfo . PartitionType = pi . Mbr . PartitionType ; info -> partInfo . BootIndicator = pi . Mbr . BootIndicator ; } info -> IsGPT = pi . PartitionStyle == PARTITION_STYLE_GPT ; } else { ntStatus = TCDeviceIoControl ( info -> deviceName , IOCTL_DISK_GET_PARTITION_INFO , NULL , 0 , & info -> partInfo , sizeof ( info -> partInfo ) ) ; info -> IsGPT = FALSE ; } if ( ! NT_SUCCESS ( ntStatus ) ) { GET_LENGTH_INFORMATION lengthInfo ; ntStatus = TCDeviceIoControl ( info -> deviceName , IOCTL_DISK_GET_LENGTH_INFO , NULL , 0 , & lengthInfo , sizeof ( lengthInfo ) ) ; if ( NT_SUCCESS ( ntStatus ) ) { memset ( & info -> partInfo , 0 , sizeof ( info -> partInfo ) ) ; info -> partInfo . PartitionLength = lengthInfo . Length ; } } info -> IsDynamic = FALSE ; if ( NT_SUCCESS ( ntStatus ) && OsMajorVersion >= 6 ) { # define IOCTL_VOLUME_IS_DYNAMIC CTL_CODE ( IOCTL_VOLUME_BASE , 18 , METHOD_BUFFERED , FILE_ANY_ACCESS ) if ( ! NT_SUCCESS ( TCDeviceIoControl ( info -> deviceName , IOCTL_VOLUME_IS_DYNAMIC , NULL , 0 , & info -> IsDynamic , sizeof ( info -> IsDynamic ) ) ) ) info -> IsDynamic = FALSE ; } Irp -> IoStatus . Information = sizeof ( DISK_PARTITION_INFO_STRUCT ) ; Irp -> IoStatus . Status = ntStatus ; } } break ; case TC_IOCTL_GET_DRIVE_GEOMETRY : if ( ValidateIOBufferSize ( Irp , sizeof ( DISK_GEOMETRY_STRUCT ) , ValidateInputOutput ) ) { DISK_GEOMETRY_STRUCT * g = ( DISK_GEOMETRY_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; { NTSTATUS ntStatus ; EnsureNullTerminatedString ( g -> deviceName , sizeof ( g -> deviceName ) ) ; Dump ( ""Calling<S2SV_blank>IOCTL_DISK_GET_DRIVE_GEOMETRY<S2SV_blank>on<S2SV_blank>%ls\\n"" , g -> deviceName ) ; ntStatus = TCDeviceIoControl ( g -> deviceName , IOCTL_DISK_GET_DRIVE_GEOMETRY , NULL , 0 , & g -> diskGeometry , sizeof ( g -> diskGeometry ) ) ; Irp -> IoStatus . Information = sizeof ( DISK_GEOMETRY_STRUCT ) ; Irp -> IoStatus . Status = ntStatus ; } } break ; case VC_IOCTL_GET_DRIVE_GEOMETRY_EX : if ( ValidateIOBufferSize ( Irp , sizeof ( DISK_GEOMETRY_EX_STRUCT ) , ValidateInputOutput ) ) { DISK_GEOMETRY_EX_STRUCT * g = ( DISK_GEOMETRY_EX_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; { NTSTATUS ntStatus ; PVOID buffer = TCalloc ( 256 ) ; if ( buffer ) { EnsureNullTerminatedString ( g -> deviceName , sizeof ( g -> deviceName ) ) ; Dump ( ""Calling<S2SV_blank>IOCTL_DISK_GET_DRIVE_GEOMETRY_EX<S2SV_blank>on<S2SV_blank>%ls\\n"" , g -> deviceName ) ; ntStatus = TCDeviceIoControl ( g -> deviceName , IOCTL_DISK_GET_DRIVE_GEOMETRY_EX , NULL , 0 , buffer , 256 ) ; if ( NT_SUCCESS ( ntStatus ) ) { PDISK_GEOMETRY_EX pGeo = ( PDISK_GEOMETRY_EX ) buffer ; memcpy ( & g -> diskGeometry , & pGeo -> Geometry , sizeof ( DISK_GEOMETRY ) ) ; g -> DiskSize . QuadPart = pGeo -> DiskSize . QuadPart ; } else { DISK_GEOMETRY dg = { 0 } ; Dump ( ""Failed.<S2SV_blank>Calling<S2SV_blank>IOCTL_DISK_GET_DRIVE_GEOMETRY<S2SV_blank>on<S2SV_blank>%ls\\n"" , g -> deviceName ) ; ntStatus = TCDeviceIoControl ( g -> deviceName , IOCTL_DISK_GET_DRIVE_GEOMETRY , NULL , 0 , & dg , sizeof ( dg ) ) ; if ( NT_SUCCESS ( ntStatus ) ) { memcpy ( & g -> diskGeometry , & dg , sizeof ( DISK_GEOMETRY ) ) ; g -> DiskSize . QuadPart = dg . Cylinders . QuadPart * dg . SectorsPerTrack * dg . TracksPerCylinder * dg . BytesPerSector ; if ( OsMajorVersion >= 6 ) { STORAGE_READ_CAPACITY storage = { 0 } ; NTSTATUS lStatus ; storage . Version = sizeof ( STORAGE_READ_CAPACITY ) ; Dump ( ""Calling<S2SV_blank>IOCTL_STORAGE_READ_CAPACITY<S2SV_blank>on<S2SV_blank>%ls\\n"" , g -> deviceName ) ; lStatus = TCDeviceIoControl ( g -> deviceName , IOCTL_STORAGE_READ_CAPACITY , NULL , 0 , & storage , sizeof ( STORAGE_READ_CAPACITY ) ) ; if ( NT_SUCCESS ( lStatus ) && ( storage . Size == sizeof ( STORAGE_READ_CAPACITY ) ) ) { g -> DiskSize . QuadPart = storage . DiskLength . QuadPart ; } } } } TCfree ( buffer ) ; Irp -> IoStatus . Information = sizeof ( DISK_GEOMETRY_EX_STRUCT ) ; Irp -> IoStatus . Status = ntStatus ; } else { Irp -> IoStatus . Status = STATUS_INSUFFICIENT_RESOURCES ; Irp -> IoStatus . Information = 0 ; } } } break ; case TC_IOCTL_PROBE_REAL_DRIVE_SIZE : if ( ValidateIOBufferSize ( Irp , sizeof ( ProbeRealDriveSizeRequest ) , ValidateInputOutput ) ) { ProbeRealDriveSizeRequest * request = ( ProbeRealDriveSizeRequest * ) Irp -> AssociatedIrp . SystemBuffer ; NTSTATUS status ; UNICODE_STRING name ; PFILE_OBJECT fileObject ; PDEVICE_OBJECT deviceObject ; EnsureNullTerminatedString ( request -> DeviceName , sizeof ( request -> DeviceName ) ) ; RtlInitUnicodeString ( & name , request -> DeviceName ) ; status = IoGetDeviceObjectPointer ( & name , FILE_READ_ATTRIBUTES , & fileObject , & deviceObject ) ; if ( ! NT_SUCCESS ( status ) ) { Irp -> IoStatus . Information = 0 ; Irp -> IoStatus . Status = status ; break ; } status = ProbeRealDriveSize ( deviceObject , & request -> RealDriveSize ) ; ObDereferenceObject ( fileObject ) ; if ( status == STATUS_TIMEOUT ) { request -> TimeOut = TRUE ; Irp -> IoStatus . Information = sizeof ( ProbeRealDriveSizeRequest ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } else if ( ! NT_SUCCESS ( status ) ) { Irp -> IoStatus . Information = 0 ; Irp -> IoStatus . Status = status ; } else { request -> TimeOut = FALSE ; Irp -> IoStatus . Information = sizeof ( ProbeRealDriveSizeRequest ) ; Irp -> IoStatus . Status = status ; } } break ; case TC_IOCTL_MOUNT_VOLUME : if ( ValidateIOBufferSize ( Irp , sizeof ( MOUNT_STRUCT ) , ValidateInputOutput ) ) { MOUNT_STRUCT * mount = ( MOUNT_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; if ( mount -> VolumePassword . Length > MAX_PASSWORD || mount -> ProtectedHidVolPassword . Length > MAX_PASSWORD || mount -> pkcs5_prf < 0 || mount -> pkcs5_prf > LAST_PRF_ID || mount -> VolumePim < - 1 || mount -> VolumePim == INT_MAX || mount -> ProtectedHidVolPkcs5Prf < 0 || mount -> ProtectedHidVolPkcs5Prf > LAST_PRF_ID || ( mount -> bTrueCryptMode != FALSE && mount -> bTrueCryptMode != TRUE ) ) { Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; break ; } EnsureNullTerminatedString ( mount -> wszVolume , sizeof ( mount -> wszVolume ) ) ; EnsureNullTerminatedString ( mount -> wszLabel , sizeof ( mount -> wszLabel ) ) ; Irp -> IoStatus . Information = sizeof ( MOUNT_STRUCT ) ; Irp -> IoStatus . Status = MountDevice ( DeviceObject , mount ) ; burn ( & mount -> VolumePassword , sizeof ( mount -> VolumePassword ) ) ; burn ( & mount -> ProtectedHidVolPassword , sizeof ( mount -> ProtectedHidVolPassword ) ) ; burn ( & mount -> pkcs5_prf , sizeof ( mount -> pkcs5_prf ) ) ; burn ( & mount -> VolumePim , sizeof ( mount -> VolumePim ) ) ; burn ( & mount -> bTrueCryptMode , sizeof ( mount -> bTrueCryptMode ) ) ; burn ( & mount -> ProtectedHidVolPkcs5Prf , sizeof ( mount -> ProtectedHidVolPkcs5Prf ) ) ; burn ( & mount -> ProtectedHidVolPim , sizeof ( mount -> ProtectedHidVolPim ) ) ; } break ; case TC_IOCTL_DISMOUNT_VOLUME : if ( ValidateIOBufferSize ( Irp , sizeof ( UNMOUNT_STRUCT ) , ValidateInputOutput ) ) { UNMOUNT_STRUCT * unmount = ( UNMOUNT_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; PDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject ( unmount -> nDosDriveNo ) ; unmount -> nReturnCode = ERR_DRIVE_NOT_FOUND ; if ( ListDevice ) { PEXTENSION ListExtension = ( PEXTENSION ) ListDevice -> DeviceExtension ; if ( IsVolumeAccessibleByCurrentUser ( ListExtension ) ) unmount -> nReturnCode = UnmountDevice ( unmount , ListDevice , unmount -> ignoreOpenFiles ) ; } Irp -> IoStatus . Information = sizeof ( UNMOUNT_STRUCT ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_DISMOUNT_ALL_VOLUMES : if ( ValidateIOBufferSize ( Irp , sizeof ( UNMOUNT_STRUCT ) , ValidateInputOutput ) ) { UNMOUNT_STRUCT * unmount = ( UNMOUNT_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; unmount -> nReturnCode = UnmountAllDevices ( unmount , unmount -> ignoreOpenFiles ) ; Irp -> IoStatus . Information = sizeof ( UNMOUNT_STRUCT ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_BOOT_ENCRYPTION_SETUP : Irp -> IoStatus . Status = StartBootEncryptionSetup ( DeviceObject , Irp , irpSp ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_ABORT_BOOT_ENCRYPTION_SETUP : Irp -> IoStatus . Status = AbortBootEncryptionSetup ( ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS : GetBootEncryptionStatus ( Irp , irpSp ) ; break ; case TC_IOCTL_GET_BOOT_ENCRYPTION_SETUP_RESULT : Irp -> IoStatus . Information = 0 ; Irp -> IoStatus . Status = GetSetupResult ( ) ; break ; case TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES : GetBootDriveVolumeProperties ( Irp , irpSp ) ; break ; case TC_IOCTL_GET_BOOT_LOADER_VERSION : GetBootLoaderVersion ( Irp , irpSp ) ; break ; case TC_IOCTL_REOPEN_BOOT_VOLUME_HEADER : ReopenBootVolumeHeader ( Irp , irpSp ) ; break ; case VC_IOCTL_GET_BOOT_LOADER_FINGERPRINT : GetBootLoaderFingerprint ( Irp , irpSp ) ; break ; case TC_IOCTL_GET_BOOT_ENCRYPTION_ALGORITHM_NAME : GetBootEncryptionAlgorithmName ( Irp , irpSp ) ; break ; case TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { * ( int * ) Irp -> AssociatedIrp . SystemBuffer = IsHiddenSystemRunning ( ) ? 1 : 0 ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_START_DECOY_SYSTEM_WIPE : Irp -> IoStatus . Status = StartDecoySystemWipe ( DeviceObject , Irp , irpSp ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_ABORT_DECOY_SYSTEM_WIPE : Irp -> IoStatus . Status = AbortDecoySystemWipe ( ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_DECOY_SYSTEM_WIPE_RESULT : Irp -> IoStatus . Status = GetDecoySystemWipeResult ( ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_DECOY_SYSTEM_WIPE_STATUS : GetDecoySystemWipeStatus ( Irp , irpSp ) ; break ; case TC_IOCTL_WRITE_BOOT_DRIVE_SECTOR : Irp -> IoStatus . Status = WriteBootDriveSector ( Irp , irpSp ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_WARNING_FLAGS : if ( ValidateIOBufferSize ( Irp , sizeof ( GetWarningFlagsRequest ) , ValidateOutput ) ) { GetWarningFlagsRequest * flags = ( GetWarningFlagsRequest * ) Irp -> AssociatedIrp . SystemBuffer ; flags -> PagingFileCreationPrevented = PagingFileCreationPrevented ; PagingFileCreationPrevented = FALSE ; flags -> SystemFavoriteVolumeDirty = SystemFavoriteVolumeDirty ; SystemFavoriteVolumeDirty = FALSE ; Irp -> IoStatus . Information = sizeof ( GetWarningFlagsRequest ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_SET_SYSTEM_FAVORITE_VOLUME_DIRTY : if ( UserCanAccessDriveDevice ( ) ) { SystemFavoriteVolumeDirty = TRUE ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } else Irp -> IoStatus . Status = STATUS_ACCESS_DENIED ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_REREAD_DRIVER_CONFIG : Irp -> IoStatus . Status = ReadRegistryConfigFlags ( FALSE ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_SYSTEM_DRIVE_DUMP_CONFIG : if ( ( ValidateIOBufferSize ( Irp , sizeof ( GetSystemDriveDumpConfigRequest ) , ValidateOutput ) ) && ( Irp -> RequestorMode == KernelMode ) ) { GetSystemDriveDumpConfigRequest * request = ( GetSystemDriveDumpConfigRequest * ) Irp -> AssociatedIrp . SystemBuffer ; request -> BootDriveFilterExtension = GetBootDriveFilterExtension ( ) ; if ( IsBootDriveMounted ( ) && request -> BootDriveFilterExtension ) { request -> HwEncryptionEnabled = IsHwEncryptionEnabled ( ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = sizeof ( * request ) ; } else { Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; } } break ; default : return TCCompleteIrp ( Irp , STATUS_INVALID_DEVICE_REQUEST , 0 ) ; } # if defined ( DEBUG ) || defined ( DEBUG_TRACE ) if ( ! NT_SUCCESS ( Irp -> IoStatus . Status ) ) { switch ( irpSp -> Parameters . DeviceIoControl . IoControlCode ) { case TC_IOCTL_GET_MOUNTED_VOLUMES : case TC_IOCTL_GET_PASSWORD_CACHE_STATUS : case TC_IOCTL_GET_PORTABLE_MODE_STATUS : case TC_IOCTL_SET_PORTABLE_MODE_STATUS : case TC_IOCTL_OPEN_TEST : case TC_IOCTL_GET_RESOLVED_SYMLINK : case TC_IOCTL_GET_DRIVE_PARTITION_INFO : case TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES : case TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS : case TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING : break ; default : Dump ( ""IOCTL<S2SV_blank>error<S2SV_blank>0x%08x\\n"" , Irp -> IoStatus . Status ) ; } } # endif return TCCompleteIrp ( Irp , Irp -> IoStatus . Status , Irp -> IoStatus . Information ) ; }","size_t devicePathLen = 0 ;if ( ! NT_SUCCESS ( RtlUnalignedStringCchLengthW ( request -> DevicePath , TC_MAX_PATH , & devicePathLen ) ) || ( devicePathLen < 28 ) || ( devicePathLen > 30 ) || ( memcmp ( request -> DevicePath , L""\\\\\\\\Device\\\\\\\\Harddisk"" , 16 * sizeof ( WCHAR ) ) ) || ( memcmp ( & request -> DevicePath [ devicePathLen - 11 ] , L""\\\\\\\\Partition0"" , 11 * sizeof ( WCHAR ) ) ) ) {byte * readBuffer = TCalloc ( TC_MAX_VOLUME_SECTOR_SIZE ) ;if ( ! readBuffer ) {Irp -> IoStatus . Status = STATUS_INSUFFICIENT_RESOURCES ;Irp -> IoStatus . Information = 0 ;}else {Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ;Irp -> IoStatus . Information = 0 ;break ;}",590
801,"buggy line: cwe id:CWE-119context: NTSTATUS ProcessMainDeviceControlIrp ( PDEVICE_OBJECT DeviceObject , PEXTENSION Extension , PIRP Irp ) { PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation ( Irp ) ; NTSTATUS ntStatus ; switch ( irpSp -> Parameters . DeviceIoControl . IoControlCode ) { case TC_IOCTL_GET_DRIVER_VERSION : case TC_IOCTL_LEGACY_GET_DRIVER_VERSION : if ( ValidateIOBufferSize ( Irp , sizeof ( LONG ) , ValidateOutput ) ) { LONG tmp = VERSION_NUM ; memcpy ( Irp -> AssociatedIrp . SystemBuffer , & tmp , 4 ) ; Irp -> IoStatus . Information = sizeof ( LONG ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_GET_DEVICE_REFCOUNT : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { * ( int * ) Irp -> AssociatedIrp . SystemBuffer = DeviceObject -> ReferenceCount ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_IS_DRIVER_UNLOAD_DISABLED : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { LONG deviceObjectCount = 0 ; * ( int * ) Irp -> AssociatedIrp . SystemBuffer = DriverUnloadDisabled ; if ( IoEnumerateDeviceObjectList ( TCDriverObject , NULL , 0 , & deviceObjectCount ) == STATUS_BUFFER_TOO_SMALL && deviceObjectCount > 1 ) * ( int * ) Irp -> AssociatedIrp . SystemBuffer = TRUE ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_IS_ANY_VOLUME_MOUNTED : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { int drive ; * ( int * ) Irp -> AssociatedIrp . SystemBuffer = 0 ; for ( drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER ; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER ; ++ drive ) { if ( GetVirtualVolumeDeviceObject ( drive ) ) { * ( int * ) Irp -> AssociatedIrp . SystemBuffer = 1 ; break ; } } if ( IsBootDriveMounted ( ) ) * ( int * ) Irp -> AssociatedIrp . SystemBuffer = 1 ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_OPEN_TEST : { OPEN_TEST_STRUCT * opentest = ( OPEN_TEST_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; OBJECT_ATTRIBUTES ObjectAttributes ; HANDLE NtFileHandle ; UNICODE_STRING FullFileName ; IO_STATUS_BLOCK IoStatus ; LARGE_INTEGER offset ; ACCESS_MASK access = FILE_READ_ATTRIBUTES ; if ( ! ValidateIOBufferSize ( Irp , sizeof ( OPEN_TEST_STRUCT ) , ValidateInputOutput ) ) break ; EnsureNullTerminatedString ( opentest -> wszFileName , sizeof ( opentest -> wszFileName ) ) ; RtlInitUnicodeString ( & FullFileName , opentest -> wszFileName ) ; InitializeObjectAttributes ( & ObjectAttributes , & FullFileName , OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE , NULL , NULL ) ; if ( opentest -> bDetectTCBootLoader || opentest -> DetectFilesystem || opentest -> bComputeVolumeIDs ) access |= FILE_READ_DATA ; ntStatus = ZwCreateFile ( & NtFileHandle , SYNCHRONIZE | access , & ObjectAttributes , & IoStatus , NULL , 0 , FILE_SHARE_READ | FILE_SHARE_WRITE , FILE_OPEN , FILE_SYNCHRONOUS_IO_NONALERT , NULL , 0 ) ; if ( NT_SUCCESS ( ntStatus ) ) { opentest -> TCBootLoaderDetected = FALSE ; opentest -> FilesystemDetected = FALSE ; memset ( opentest -> VolumeIDComputed , 0 , sizeof ( opentest -> VolumeIDComputed ) ) ; memset ( opentest -> volumeIDs , 0 , sizeof ( opentest -> volumeIDs ) ) ; if ( opentest -> bDetectTCBootLoader || opentest -> DetectFilesystem || opentest -> bComputeVolumeIDs ) { byte * readBuffer = TCalloc ( TC_MAX_VOLUME_SECTOR_SIZE ) ; if ( ! readBuffer ) { ntStatus = STATUS_INSUFFICIENT_RESOURCES ; } else { if ( opentest -> bDetectTCBootLoader || opentest -> DetectFilesystem ) { offset . QuadPart = 0 ; ntStatus = ZwReadFile ( NtFileHandle , NULL , NULL , NULL , & IoStatus , readBuffer , TC_MAX_VOLUME_SECTOR_SIZE , & offset , NULL ) ; if ( NT_SUCCESS ( ntStatus ) ) { size_t i ; if ( opentest -> bDetectTCBootLoader && IoStatus . Information >= TC_SECTOR_SIZE_BIOS ) { for ( i = 0 ; i < TC_SECTOR_SIZE_BIOS - strlen ( TC_APP_NAME ) ; ++ i ) { if ( memcmp ( readBuffer + i , TC_APP_NAME , strlen ( TC_APP_NAME ) ) == 0 ) { opentest -> TCBootLoaderDetected = TRUE ; break ; } } } if ( opentest -> DetectFilesystem && IoStatus . Information >= sizeof ( int64 ) ) { switch ( BE64 ( * ( uint64 * ) readBuffer ) ) { case 0xEB52904E54465320ULL : case 0xEB3C904D53444F53ULL : case 0xEB58904D53444F53ULL : case 0xEB76904558464154ULL : case 0x0000005265465300ULL : case 0xEB58906D6B66732EULL : case 0xEB58906D6B646F73ULL : case 0xEB3C906D6B66732EULL : case 0xEB3C906D6B646F73ULL : opentest -> FilesystemDetected = TRUE ; break ; case 0x0000000000000000ULL : if ( IsAllZeroes ( readBuffer + 8 , TC_VOLUME_HEADER_EFFECTIVE_SIZE - 8 ) ) opentest -> FilesystemDetected = TRUE ; break ; } } } } if ( opentest -> bComputeVolumeIDs && ( ! opentest -> DetectFilesystem || ! opentest -> FilesystemDetected ) ) { int volumeType ; for ( volumeType = TC_VOLUME_TYPE_NORMAL ; volumeType < TC_VOLUME_TYPE_COUNT ; volumeType ++ ) { switch ( volumeType ) { case TC_VOLUME_TYPE_NORMAL : offset . QuadPart = TC_VOLUME_HEADER_OFFSET ; break ; case TC_VOLUME_TYPE_HIDDEN : offset . QuadPart = TC_HIDDEN_VOLUME_HEADER_OFFSET ; break ; } ntStatus = ZwReadFile ( NtFileHandle , NULL , NULL , NULL , & IoStatus , readBuffer , TC_MAX_VOLUME_SECTOR_SIZE , & offset , NULL ) ; if ( NT_SUCCESS ( ntStatus ) ) { sha256 ( opentest -> volumeIDs [ volumeType ] , readBuffer , TC_VOLUME_HEADER_EFFECTIVE_SIZE ) ; opentest -> VolumeIDComputed [ volumeType ] = TRUE ; } } } TCfree ( readBuffer ) ; } } ZwClose ( NtFileHandle ) ; Dump ( ""Open<S2SV_blank>test<S2SV_blank>on<S2SV_blank>file<S2SV_blank>%ls<S2SV_blank>success.\\n"" , opentest -> wszFileName ) ; } else { # if 0 Dump ( ""Open<S2SV_blank>test<S2SV_blank>on<S2SV_blank>file<S2SV_blank>%ls<S2SV_blank>failed<S2SV_blank>NTSTATUS<S2SV_blank>0x%08x\\n"" , opentest -> wszFileName , ntStatus ) ; # endif } Irp -> IoStatus . Information = NT_SUCCESS ( ntStatus ) ? sizeof ( OPEN_TEST_STRUCT ) : 0 ; Irp -> IoStatus . Status = ntStatus ; } break ; case TC_IOCTL_GET_SYSTEM_DRIVE_CONFIG : { GetSystemDriveConfigurationRequest * request = ( GetSystemDriveConfigurationRequest * ) Irp -> AssociatedIrp . SystemBuffer ; OBJECT_ATTRIBUTES ObjectAttributes ; HANDLE NtFileHandle ; UNICODE_STRING FullFileName ; IO_STATUS_BLOCK IoStatus ; LARGE_INTEGER offset ;  byte readBuffer [ TC_SECTOR_SIZE_BIOS ] ;  if ( ! ValidateIOBufferSize ( Irp , sizeof ( GetSystemDriveConfigurationRequest ) , ValidateInputOutput ) )  break ;  EnsureNullTerminatedString ( request -> DevicePath , sizeof ( request -> DevicePath ) ) ; RtlInitUnicodeString ( & FullFileName , request -> DevicePath ) ; InitializeObjectAttributes ( & ObjectAttributes , & FullFileName , OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE , NULL , NULL ) ; ntStatus = ZwCreateFile ( & NtFileHandle , SYNCHRONIZE | GENERIC_READ , & ObjectAttributes , & IoStatus , NULL , FILE_ATTRIBUTE_NORMAL , FILE_SHARE_READ | FILE_SHARE_WRITE , FILE_OPEN , FILE_SYNCHRONOUS_IO_NONALERT | FILE_RANDOM_ACCESS , NULL , 0 ) ; if ( NT_SUCCESS ( ntStatus ) ) {  offset . QuadPart = 0 ;  ntStatus = ZwReadFile ( NtFileHandle , NULL , NULL , NULL , & IoStatus , readBuffer ,  sizeof ( readBuffer ) ,  & offset , NULL ) ;  if ( NT_SUCCESS ( ntStatus ) )  { size_t i ; request -> DriveIsDynamic = FALSE ; if ( readBuffer [ 510 ] == 0x55 && readBuffer [ 511 ] == 0xaa ) { int i ; for ( i = 0 ; i < 4 ; ++ i ) { if ( readBuffer [ 446 + i * 16 + 4 ] == PARTITION_LDM ) { request -> DriveIsDynamic = TRUE ; break ; } } } request -> BootLoaderVersion = 0 ; request -> Configuration = 0 ; request -> UserConfiguration = 0 ; request -> CustomUserMessage [ 0 ] = 0 ; for ( i = 0 ; i < sizeof ( readBuffer ) - strlen ( TC_APP_NAME ) ; ++ i ) { if ( memcmp ( readBuffer + i , TC_APP_NAME , strlen ( TC_APP_NAME ) ) == 0 ) { request -> BootLoaderVersion = BE16 ( * ( uint16 * ) ( readBuffer + TC_BOOT_SECTOR_VERSION_OFFSET ) ) ; request -> Configuration = readBuffer [ TC_BOOT_SECTOR_CONFIG_OFFSET ] ; if ( request -> BootLoaderVersion != 0 && request -> BootLoaderVersion <= VERSION_NUM ) { request -> UserConfiguration = readBuffer [ TC_BOOT_SECTOR_USER_CONFIG_OFFSET ] ; memcpy ( request -> CustomUserMessage , readBuffer + TC_BOOT_SECTOR_USER_MESSAGE_OFFSET , TC_BOOT_SECTOR_USER_MESSAGE_MAX_LENGTH ) ; } break ; } } Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = sizeof ( * request ) ; } else {  Irp -> IoStatus . Status = ntStatus ;   Irp -> IoStatus . Information = 0 ;  } ZwClose ( NtFileHandle ) ; } else { Irp -> IoStatus . Status = ntStatus ; Irp -> IoStatus . Information = 0 ; } } break ; case TC_IOCTL_WIPE_PASSWORD_CACHE : WipeCache ( ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_PASSWORD_CACHE_STATUS : Irp -> IoStatus . Status = cacheEmpty ? STATUS_PIPE_EMPTY : STATUS_SUCCESS ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_SET_PORTABLE_MODE_STATUS : if ( ! UserCanAccessDriveDevice ( ) ) { Irp -> IoStatus . Status = STATUS_ACCESS_DENIED ; Irp -> IoStatus . Information = 0 ; } else { PortableMode = TRUE ; Dump ( ""Setting<S2SV_blank>portable<S2SV_blank>mode\\n"" ) ; } break ; case TC_IOCTL_GET_PORTABLE_MODE_STATUS : Irp -> IoStatus . Status = PortableMode ? STATUS_SUCCESS : STATUS_PIPE_EMPTY ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_MOUNTED_VOLUMES : if ( ValidateIOBufferSize ( Irp , sizeof ( MOUNT_LIST_STRUCT ) , ValidateOutput ) ) { MOUNT_LIST_STRUCT * list = ( MOUNT_LIST_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; PDEVICE_OBJECT ListDevice ; int drive ; list -> ulMountedDrives = 0 ; for ( drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER ; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER ; ++ drive ) { PEXTENSION ListExtension ; ListDevice = GetVirtualVolumeDeviceObject ( drive ) ; if ( ! ListDevice ) continue ; ListExtension = ( PEXTENSION ) ListDevice -> DeviceExtension ; if ( IsVolumeAccessibleByCurrentUser ( ListExtension ) ) { list -> ulMountedDrives |= ( 1 << ListExtension -> nDosDriveNo ) ; RtlStringCbCopyW ( list -> wszVolume [ ListExtension -> nDosDriveNo ] , sizeof ( list -> wszVolume [ ListExtension -> nDosDriveNo ] ) , ListExtension -> wszVolume ) ; RtlStringCbCopyW ( list -> wszLabel [ ListExtension -> nDosDriveNo ] , sizeof ( list -> wszLabel [ ListExtension -> nDosDriveNo ] ) , ListExtension -> wszLabel ) ; memcpy ( list -> volumeID [ ListExtension -> nDosDriveNo ] , ListExtension -> volumeID , VOLUME_ID_SIZE ) ; list -> diskLength [ ListExtension -> nDosDriveNo ] = ListExtension -> DiskLength ; list -> ea [ ListExtension -> nDosDriveNo ] = ListExtension -> cryptoInfo -> ea ; if ( ListExtension -> cryptoInfo -> hiddenVolume ) list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_HIDDEN ; else if ( ListExtension -> cryptoInfo -> bHiddenVolProtectionAction ) list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_OUTER_VOL_WRITE_PREVENTED ; else if ( ListExtension -> cryptoInfo -> bProtectHiddenVolume ) list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_OUTER ; else list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_NORMAL ; list -> truecryptMode [ ListExtension -> nDosDriveNo ] = ListExtension -> cryptoInfo -> bTrueCryptMode ; } } Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = sizeof ( MOUNT_LIST_STRUCT ) ; } break ; case TC_IOCTL_LEGACY_GET_MOUNTED_VOLUMES : if ( ValidateIOBufferSize ( Irp , sizeof ( uint32 ) , ValidateOutput ) ) { memset ( Irp -> AssociatedIrp . SystemBuffer , 0 , irpSp -> Parameters . DeviceIoControl . OutputBufferLength ) ; * ( uint32 * ) Irp -> AssociatedIrp . SystemBuffer = 0xffffFFFF ; Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = irpSp -> Parameters . DeviceIoControl . OutputBufferLength ; } break ; case TC_IOCTL_GET_VOLUME_PROPERTIES : if ( ValidateIOBufferSize ( Irp , sizeof ( VOLUME_PROPERTIES_STRUCT ) , ValidateInputOutput ) ) { VOLUME_PROPERTIES_STRUCT * prop = ( VOLUME_PROPERTIES_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; PDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject ( prop -> driveNo ) ; Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; if ( ListDevice ) { PEXTENSION ListExtension = ( PEXTENSION ) ListDevice -> DeviceExtension ; if ( IsVolumeAccessibleByCurrentUser ( ListExtension ) ) { prop -> uniqueId = ListExtension -> UniqueVolumeId ; RtlStringCbCopyW ( prop -> wszVolume , sizeof ( prop -> wszVolume ) , ListExtension -> wszVolume ) ; RtlStringCbCopyW ( prop -> wszLabel , sizeof ( prop -> wszLabel ) , ListExtension -> wszLabel ) ; memcpy ( prop -> volumeID , ListExtension -> volumeID , VOLUME_ID_SIZE ) ; prop -> bDriverSetLabel = ListExtension -> bDriverSetLabel ; prop -> diskLength = ListExtension -> DiskLength ; prop -> ea = ListExtension -> cryptoInfo -> ea ; prop -> mode = ListExtension -> cryptoInfo -> mode ; prop -> pkcs5 = ListExtension -> cryptoInfo -> pkcs5 ; prop -> pkcs5Iterations = ListExtension -> cryptoInfo -> noIterations ; prop -> volumePim = ListExtension -> cryptoInfo -> volumePim ; # if 0 prop -> volumeCreationTime = ListExtension -> cryptoInfo -> volume_creation_time ; prop -> headerCreationTime = ListExtension -> cryptoInfo -> header_creation_time ; # endif prop -> volumeHeaderFlags = ListExtension -> cryptoInfo -> HeaderFlags ; prop -> readOnly = ListExtension -> bReadOnly ; prop -> removable = ListExtension -> bRemovable ; prop -> partitionInInactiveSysEncScope = ListExtension -> PartitionInInactiveSysEncScope ; prop -> hiddenVolume = ListExtension -> cryptoInfo -> hiddenVolume ; if ( ListExtension -> cryptoInfo -> bProtectHiddenVolume ) prop -> hiddenVolProtection = ListExtension -> cryptoInfo -> bHiddenVolProtectionAction ? HIDVOL_PROT_STATUS_ACTION_TAKEN : HIDVOL_PROT_STATUS_ACTIVE ; else prop -> hiddenVolProtection = HIDVOL_PROT_STATUS_NONE ; prop -> totalBytesRead = ListExtension -> Queue . TotalBytesRead ; prop -> totalBytesWritten = ListExtension -> Queue . TotalBytesWritten ; prop -> volFormatVersion = ListExtension -> cryptoInfo -> LegacyVolume ? TC_VOLUME_FORMAT_VERSION_PRE_6_0 : TC_VOLUME_FORMAT_VERSION ; Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = sizeof ( VOLUME_PROPERTIES_STRUCT ) ; } } } break ; case TC_IOCTL_GET_RESOLVED_SYMLINK : if ( ValidateIOBufferSize ( Irp , sizeof ( RESOLVE_SYMLINK_STRUCT ) , ValidateInputOutput ) ) { RESOLVE_SYMLINK_STRUCT * resolve = ( RESOLVE_SYMLINK_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; { NTSTATUS ntStatus ; EnsureNullTerminatedString ( resolve -> symLinkName , sizeof ( resolve -> symLinkName ) ) ; ntStatus = SymbolicLinkToTarget ( resolve -> symLinkName , resolve -> targetName , sizeof ( resolve -> targetName ) ) ; Irp -> IoStatus . Information = sizeof ( RESOLVE_SYMLINK_STRUCT ) ; Irp -> IoStatus . Status = ntStatus ; } } break ; case TC_IOCTL_GET_DRIVE_PARTITION_INFO : if ( ValidateIOBufferSize ( Irp , sizeof ( DISK_PARTITION_INFO_STRUCT ) , ValidateInputOutput ) ) { DISK_PARTITION_INFO_STRUCT * info = ( DISK_PARTITION_INFO_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; { PARTITION_INFORMATION_EX pi ; NTSTATUS ntStatus ; EnsureNullTerminatedString ( info -> deviceName , sizeof ( info -> deviceName ) ) ; ntStatus = TCDeviceIoControl ( info -> deviceName , IOCTL_DISK_GET_PARTITION_INFO_EX , NULL , 0 , & pi , sizeof ( pi ) ) ; if ( NT_SUCCESS ( ntStatus ) ) { memset ( & info -> partInfo , 0 , sizeof ( info -> partInfo ) ) ; info -> partInfo . PartitionLength = pi . PartitionLength ; info -> partInfo . PartitionNumber = pi . PartitionNumber ; info -> partInfo . StartingOffset = pi . StartingOffset ; if ( pi . PartitionStyle == PARTITION_STYLE_MBR ) { info -> partInfo . PartitionType = pi . Mbr . PartitionType ; info -> partInfo . BootIndicator = pi . Mbr . BootIndicator ; } info -> IsGPT = pi . PartitionStyle == PARTITION_STYLE_GPT ; } else { ntStatus = TCDeviceIoControl ( info -> deviceName , IOCTL_DISK_GET_PARTITION_INFO , NULL , 0 , & info -> partInfo , sizeof ( info -> partInfo ) ) ; info -> IsGPT = FALSE ; } if ( ! NT_SUCCESS ( ntStatus ) ) { GET_LENGTH_INFORMATION lengthInfo ; ntStatus = TCDeviceIoControl ( info -> deviceName , IOCTL_DISK_GET_LENGTH_INFO , NULL , 0 , & lengthInfo , sizeof ( lengthInfo ) ) ; if ( NT_SUCCESS ( ntStatus ) ) { memset ( & info -> partInfo , 0 , sizeof ( info -> partInfo ) ) ; info -> partInfo . PartitionLength = lengthInfo . Length ; } } info -> IsDynamic = FALSE ; if ( NT_SUCCESS ( ntStatus ) && OsMajorVersion >= 6 ) { # define IOCTL_VOLUME_IS_DYNAMIC CTL_CODE ( IOCTL_VOLUME_BASE , 18 , METHOD_BUFFERED , FILE_ANY_ACCESS ) if ( ! NT_SUCCESS ( TCDeviceIoControl ( info -> deviceName , IOCTL_VOLUME_IS_DYNAMIC , NULL , 0 , & info -> IsDynamic , sizeof ( info -> IsDynamic ) ) ) ) info -> IsDynamic = FALSE ; } Irp -> IoStatus . Information = sizeof ( DISK_PARTITION_INFO_STRUCT ) ; Irp -> IoStatus . Status = ntStatus ; } } break ; case TC_IOCTL_GET_DRIVE_GEOMETRY : if ( ValidateIOBufferSize ( Irp , sizeof ( DISK_GEOMETRY_STRUCT ) , ValidateInputOutput ) ) { DISK_GEOMETRY_STRUCT * g = ( DISK_GEOMETRY_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; { NTSTATUS ntStatus ; EnsureNullTerminatedString ( g -> deviceName , sizeof ( g -> deviceName ) ) ; Dump ( ""Calling<S2SV_blank>IOCTL_DISK_GET_DRIVE_GEOMETRY<S2SV_blank>on<S2SV_blank>%ls\\n"" , g -> deviceName ) ; ntStatus = TCDeviceIoControl ( g -> deviceName , IOCTL_DISK_GET_DRIVE_GEOMETRY , NULL , 0 , & g -> diskGeometry , sizeof ( g -> diskGeometry ) ) ; Irp -> IoStatus . Information = sizeof ( DISK_GEOMETRY_STRUCT ) ; Irp -> IoStatus . Status = ntStatus ; } } break ; case VC_IOCTL_GET_DRIVE_GEOMETRY_EX : if ( ValidateIOBufferSize ( Irp , sizeof ( DISK_GEOMETRY_EX_STRUCT ) , ValidateInputOutput ) ) { DISK_GEOMETRY_EX_STRUCT * g = ( DISK_GEOMETRY_EX_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; { NTSTATUS ntStatus ; PVOID buffer = TCalloc ( 256 ) ; if ( buffer ) { EnsureNullTerminatedString ( g -> deviceName , sizeof ( g -> deviceName ) ) ; Dump ( ""Calling<S2SV_blank>IOCTL_DISK_GET_DRIVE_GEOMETRY_EX<S2SV_blank>on<S2SV_blank>%ls\\n"" , g -> deviceName ) ; ntStatus = TCDeviceIoControl ( g -> deviceName , IOCTL_DISK_GET_DRIVE_GEOMETRY_EX , NULL , 0 , buffer , 256 ) ; if ( NT_SUCCESS ( ntStatus ) ) { PDISK_GEOMETRY_EX pGeo = ( PDISK_GEOMETRY_EX ) buffer ; memcpy ( & g -> diskGeometry , & pGeo -> Geometry , sizeof ( DISK_GEOMETRY ) ) ; g -> DiskSize . QuadPart = pGeo -> DiskSize . QuadPart ; } else { DISK_GEOMETRY dg = { 0 } ; Dump ( ""Failed.<S2SV_blank>Calling<S2SV_blank>IOCTL_DISK_GET_DRIVE_GEOMETRY<S2SV_blank>on<S2SV_blank>%ls\\n"" , g -> deviceName ) ; ntStatus = TCDeviceIoControl ( g -> deviceName , IOCTL_DISK_GET_DRIVE_GEOMETRY , NULL , 0 , & dg , sizeof ( dg ) ) ; if ( NT_SUCCESS ( ntStatus ) ) { memcpy ( & g -> diskGeometry , & dg , sizeof ( DISK_GEOMETRY ) ) ; g -> DiskSize . QuadPart = dg . Cylinders . QuadPart * dg . SectorsPerTrack * dg . TracksPerCylinder * dg . BytesPerSector ; if ( OsMajorVersion >= 6 ) { STORAGE_READ_CAPACITY storage = { 0 } ; NTSTATUS lStatus ; storage . Version = sizeof ( STORAGE_READ_CAPACITY ) ; Dump ( ""Calling<S2SV_blank>IOCTL_STORAGE_READ_CAPACITY<S2SV_blank>on<S2SV_blank>%ls\\n"" , g -> deviceName ) ; lStatus = TCDeviceIoControl ( g -> deviceName , IOCTL_STORAGE_READ_CAPACITY , NULL , 0 , & storage , sizeof ( STORAGE_READ_CAPACITY ) ) ; if ( NT_SUCCESS ( lStatus ) && ( storage . Size == sizeof ( STORAGE_READ_CAPACITY ) ) ) { g -> DiskSize . QuadPart = storage . DiskLength . QuadPart ; } } } } TCfree ( buffer ) ; Irp -> IoStatus . Information = sizeof ( DISK_GEOMETRY_EX_STRUCT ) ; Irp -> IoStatus . Status = ntStatus ; } else { Irp -> IoStatus . Status = STATUS_INSUFFICIENT_RESOURCES ; Irp -> IoStatus . Information = 0 ; } } } break ; case TC_IOCTL_PROBE_REAL_DRIVE_SIZE : if ( ValidateIOBufferSize ( Irp , sizeof ( ProbeRealDriveSizeRequest ) , ValidateInputOutput ) ) { ProbeRealDriveSizeRequest * request = ( ProbeRealDriveSizeRequest * ) Irp -> AssociatedIrp . SystemBuffer ; NTSTATUS status ; UNICODE_STRING name ; PFILE_OBJECT fileObject ; PDEVICE_OBJECT deviceObject ; EnsureNullTerminatedString ( request -> DeviceName , sizeof ( request -> DeviceName ) ) ; RtlInitUnicodeString ( & name , request -> DeviceName ) ; status = IoGetDeviceObjectPointer ( & name , FILE_READ_ATTRIBUTES , & fileObject , & deviceObject ) ; if ( ! NT_SUCCESS ( status ) ) { Irp -> IoStatus . Information = 0 ; Irp -> IoStatus . Status = status ; break ; } status = ProbeRealDriveSize ( deviceObject , & request -> RealDriveSize ) ; ObDereferenceObject ( fileObject ) ; if ( status == STATUS_TIMEOUT ) { request -> TimeOut = TRUE ; Irp -> IoStatus . Information = sizeof ( ProbeRealDriveSizeRequest ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } else if ( ! NT_SUCCESS ( status ) ) { Irp -> IoStatus . Information = 0 ; Irp -> IoStatus . Status = status ; } else { request -> TimeOut = FALSE ; Irp -> IoStatus . Information = sizeof ( ProbeRealDriveSizeRequest ) ; Irp -> IoStatus . Status = status ; } } break ; case TC_IOCTL_MOUNT_VOLUME : if ( ValidateIOBufferSize ( Irp , sizeof ( MOUNT_STRUCT ) , ValidateInputOutput ) ) { MOUNT_STRUCT * mount = ( MOUNT_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; if ( mount -> VolumePassword . Length > MAX_PASSWORD || mount -> ProtectedHidVolPassword . Length > MAX_PASSWORD || mount -> pkcs5_prf < 0 || mount -> pkcs5_prf > LAST_PRF_ID || mount -> VolumePim < - 1 || mount -> VolumePim == INT_MAX || mount -> ProtectedHidVolPkcs5Prf < 0 || mount -> ProtectedHidVolPkcs5Prf > LAST_PRF_ID || ( mount -> bTrueCryptMode != FALSE && mount -> bTrueCryptMode != TRUE ) ) { Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; break ; } EnsureNullTerminatedString ( mount -> wszVolume , sizeof ( mount -> wszVolume ) ) ; EnsureNullTerminatedString ( mount -> wszLabel , sizeof ( mount -> wszLabel ) ) ; Irp -> IoStatus . Information = sizeof ( MOUNT_STRUCT ) ; Irp -> IoStatus . Status = MountDevice ( DeviceObject , mount ) ; burn ( & mount -> VolumePassword , sizeof ( mount -> VolumePassword ) ) ; burn ( & mount -> ProtectedHidVolPassword , sizeof ( mount -> ProtectedHidVolPassword ) ) ; burn ( & mount -> pkcs5_prf , sizeof ( mount -> pkcs5_prf ) ) ; burn ( & mount -> VolumePim , sizeof ( mount -> VolumePim ) ) ; burn ( & mount -> bTrueCryptMode , sizeof ( mount -> bTrueCryptMode ) ) ; burn ( & mount -> ProtectedHidVolPkcs5Prf , sizeof ( mount -> ProtectedHidVolPkcs5Prf ) ) ; burn ( & mount -> ProtectedHidVolPim , sizeof ( mount -> ProtectedHidVolPim ) ) ; } break ; case TC_IOCTL_DISMOUNT_VOLUME : if ( ValidateIOBufferSize ( Irp , sizeof ( UNMOUNT_STRUCT ) , ValidateInputOutput ) ) { UNMOUNT_STRUCT * unmount = ( UNMOUNT_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; PDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject ( unmount -> nDosDriveNo ) ; unmount -> nReturnCode = ERR_DRIVE_NOT_FOUND ; if ( ListDevice ) { PEXTENSION ListExtension = ( PEXTENSION ) ListDevice -> DeviceExtension ; if ( IsVolumeAccessibleByCurrentUser ( ListExtension ) ) unmount -> nReturnCode = UnmountDevice ( unmount , ListDevice , unmount -> ignoreOpenFiles ) ; } Irp -> IoStatus . Information = sizeof ( UNMOUNT_STRUCT ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_DISMOUNT_ALL_VOLUMES : if ( ValidateIOBufferSize ( Irp , sizeof ( UNMOUNT_STRUCT ) , ValidateInputOutput ) ) { UNMOUNT_STRUCT * unmount = ( UNMOUNT_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; unmount -> nReturnCode = UnmountAllDevices ( unmount , unmount -> ignoreOpenFiles ) ; Irp -> IoStatus . Information = sizeof ( UNMOUNT_STRUCT ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_BOOT_ENCRYPTION_SETUP : Irp -> IoStatus . Status = StartBootEncryptionSetup ( DeviceObject , Irp , irpSp ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_ABORT_BOOT_ENCRYPTION_SETUP : Irp -> IoStatus . Status = AbortBootEncryptionSetup ( ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS : GetBootEncryptionStatus ( Irp , irpSp ) ; break ; case TC_IOCTL_GET_BOOT_ENCRYPTION_SETUP_RESULT : Irp -> IoStatus . Information = 0 ; Irp -> IoStatus . Status = GetSetupResult ( ) ; break ; case TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES : GetBootDriveVolumeProperties ( Irp , irpSp ) ; break ; case TC_IOCTL_GET_BOOT_LOADER_VERSION : GetBootLoaderVersion ( Irp , irpSp ) ; break ; case TC_IOCTL_REOPEN_BOOT_VOLUME_HEADER : ReopenBootVolumeHeader ( Irp , irpSp ) ; break ; case VC_IOCTL_GET_BOOT_LOADER_FINGERPRINT : GetBootLoaderFingerprint ( Irp , irpSp ) ; break ; case TC_IOCTL_GET_BOOT_ENCRYPTION_ALGORITHM_NAME : GetBootEncryptionAlgorithmName ( Irp , irpSp ) ; break ; case TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { * ( int * ) Irp -> AssociatedIrp . SystemBuffer = IsHiddenSystemRunning ( ) ? 1 : 0 ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_START_DECOY_SYSTEM_WIPE : Irp -> IoStatus . Status = StartDecoySystemWipe ( DeviceObject , Irp , irpSp ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_ABORT_DECOY_SYSTEM_WIPE : Irp -> IoStatus . Status = AbortDecoySystemWipe ( ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_DECOY_SYSTEM_WIPE_RESULT : Irp -> IoStatus . Status = GetDecoySystemWipeResult ( ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_DECOY_SYSTEM_WIPE_STATUS : GetDecoySystemWipeStatus ( Irp , irpSp ) ; break ; case TC_IOCTL_WRITE_BOOT_DRIVE_SECTOR : Irp -> IoStatus . Status = WriteBootDriveSector ( Irp , irpSp ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_WARNING_FLAGS : if ( ValidateIOBufferSize ( Irp , sizeof ( GetWarningFlagsRequest ) , ValidateOutput ) ) { GetWarningFlagsRequest * flags = ( GetWarningFlagsRequest * ) Irp -> AssociatedIrp . SystemBuffer ; flags -> PagingFileCreationPrevented = PagingFileCreationPrevented ; PagingFileCreationPrevented = FALSE ; flags -> SystemFavoriteVolumeDirty = SystemFavoriteVolumeDirty ; SystemFavoriteVolumeDirty = FALSE ; Irp -> IoStatus . Information = sizeof ( GetWarningFlagsRequest ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_SET_SYSTEM_FAVORITE_VOLUME_DIRTY : if ( UserCanAccessDriveDevice ( ) ) { SystemFavoriteVolumeDirty = TRUE ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } else Irp -> IoStatus . Status = STATUS_ACCESS_DENIED ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_REREAD_DRIVER_CONFIG : Irp -> IoStatus . Status = ReadRegistryConfigFlags ( FALSE ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_SYSTEM_DRIVE_DUMP_CONFIG : if ( ( ValidateIOBufferSize ( Irp , sizeof ( GetSystemDriveDumpConfigRequest ) , ValidateOutput ) ) && ( Irp -> RequestorMode == KernelMode ) ) { GetSystemDriveDumpConfigRequest * request = ( GetSystemDriveDumpConfigRequest * ) Irp -> AssociatedIrp . SystemBuffer ; request -> BootDriveFilterExtension = GetBootDriveFilterExtension ( ) ; if ( IsBootDriveMounted ( ) && request -> BootDriveFilterExtension ) { request -> HwEncryptionEnabled = IsHwEncryptionEnabled ( ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = sizeof ( * request ) ; } else { Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; } } break ; default : return TCCompleteIrp ( Irp , STATUS_INVALID_DEVICE_REQUEST , 0 ) ; } # if defined ( DEBUG ) || defined ( DEBUG_TRACE ) if ( ! NT_SUCCESS ( Irp -> IoStatus . Status ) ) { switch ( irpSp -> Parameters . DeviceIoControl . IoControlCode ) { case TC_IOCTL_GET_MOUNTED_VOLUMES : case TC_IOCTL_GET_PASSWORD_CACHE_STATUS : case TC_IOCTL_GET_PORTABLE_MODE_STATUS : case TC_IOCTL_SET_PORTABLE_MODE_STATUS : case TC_IOCTL_OPEN_TEST : case TC_IOCTL_GET_RESOLVED_SYMLINK : case TC_IOCTL_GET_DRIVE_PARTITION_INFO : case TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES : case TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS : case TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING : break ; default : Dump ( ""IOCTL<S2SV_blank>error<S2SV_blank>0x%08x\\n"" , Irp -> IoStatus . Status ) ; } } # endif return TCCompleteIrp ( Irp , Irp -> IoStatus . Status , Irp -> IoStatus . Information ) ; }",if ( IoStatus . Information >= TC_SECTOR_SIZE_BIOS ) {,590
802,"buggy line: cwe id:CWE-119context: NTSTATUS ProcessMainDeviceControlIrp ( PDEVICE_OBJECT DeviceObject , PEXTENSION Extension , PIRP Irp ) { PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation ( Irp ) ; NTSTATUS ntStatus ; switch ( irpSp -> Parameters . DeviceIoControl . IoControlCode ) { case TC_IOCTL_GET_DRIVER_VERSION : case TC_IOCTL_LEGACY_GET_DRIVER_VERSION : if ( ValidateIOBufferSize ( Irp , sizeof ( LONG ) , ValidateOutput ) ) { LONG tmp = VERSION_NUM ; memcpy ( Irp -> AssociatedIrp . SystemBuffer , & tmp , 4 ) ; Irp -> IoStatus . Information = sizeof ( LONG ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_GET_DEVICE_REFCOUNT : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { * ( int * ) Irp -> AssociatedIrp . SystemBuffer = DeviceObject -> ReferenceCount ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_IS_DRIVER_UNLOAD_DISABLED : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { LONG deviceObjectCount = 0 ; * ( int * ) Irp -> AssociatedIrp . SystemBuffer = DriverUnloadDisabled ; if ( IoEnumerateDeviceObjectList ( TCDriverObject , NULL , 0 , & deviceObjectCount ) == STATUS_BUFFER_TOO_SMALL && deviceObjectCount > 1 ) * ( int * ) Irp -> AssociatedIrp . SystemBuffer = TRUE ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_IS_ANY_VOLUME_MOUNTED : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { int drive ; * ( int * ) Irp -> AssociatedIrp . SystemBuffer = 0 ; for ( drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER ; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER ; ++ drive ) { if ( GetVirtualVolumeDeviceObject ( drive ) ) { * ( int * ) Irp -> AssociatedIrp . SystemBuffer = 1 ; break ; } } if ( IsBootDriveMounted ( ) ) * ( int * ) Irp -> AssociatedIrp . SystemBuffer = 1 ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_OPEN_TEST : { OPEN_TEST_STRUCT * opentest = ( OPEN_TEST_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; OBJECT_ATTRIBUTES ObjectAttributes ; HANDLE NtFileHandle ; UNICODE_STRING FullFileName ; IO_STATUS_BLOCK IoStatus ; LARGE_INTEGER offset ; ACCESS_MASK access = FILE_READ_ATTRIBUTES ; if ( ! ValidateIOBufferSize ( Irp , sizeof ( OPEN_TEST_STRUCT ) , ValidateInputOutput ) ) break ; EnsureNullTerminatedString ( opentest -> wszFileName , sizeof ( opentest -> wszFileName ) ) ; RtlInitUnicodeString ( & FullFileName , opentest -> wszFileName ) ; InitializeObjectAttributes ( & ObjectAttributes , & FullFileName , OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE , NULL , NULL ) ; if ( opentest -> bDetectTCBootLoader || opentest -> DetectFilesystem || opentest -> bComputeVolumeIDs ) access |= FILE_READ_DATA ; ntStatus = ZwCreateFile ( & NtFileHandle , SYNCHRONIZE | access , & ObjectAttributes , & IoStatus , NULL , 0 , FILE_SHARE_READ | FILE_SHARE_WRITE , FILE_OPEN , FILE_SYNCHRONOUS_IO_NONALERT , NULL , 0 ) ; if ( NT_SUCCESS ( ntStatus ) ) { opentest -> TCBootLoaderDetected = FALSE ; opentest -> FilesystemDetected = FALSE ; memset ( opentest -> VolumeIDComputed , 0 , sizeof ( opentest -> VolumeIDComputed ) ) ; memset ( opentest -> volumeIDs , 0 , sizeof ( opentest -> volumeIDs ) ) ; if ( opentest -> bDetectTCBootLoader || opentest -> DetectFilesystem || opentest -> bComputeVolumeIDs ) { byte * readBuffer = TCalloc ( TC_MAX_VOLUME_SECTOR_SIZE ) ; if ( ! readBuffer ) { ntStatus = STATUS_INSUFFICIENT_RESOURCES ; } else { if ( opentest -> bDetectTCBootLoader || opentest -> DetectFilesystem ) { offset . QuadPart = 0 ; ntStatus = ZwReadFile ( NtFileHandle , NULL , NULL , NULL , & IoStatus , readBuffer , TC_MAX_VOLUME_SECTOR_SIZE , & offset , NULL ) ; if ( NT_SUCCESS ( ntStatus ) ) { size_t i ; if ( opentest -> bDetectTCBootLoader && IoStatus . Information >= TC_SECTOR_SIZE_BIOS ) { for ( i = 0 ; i < TC_SECTOR_SIZE_BIOS - strlen ( TC_APP_NAME ) ; ++ i ) { if ( memcmp ( readBuffer + i , TC_APP_NAME , strlen ( TC_APP_NAME ) ) == 0 ) { opentest -> TCBootLoaderDetected = TRUE ; break ; } } } if ( opentest -> DetectFilesystem && IoStatus . Information >= sizeof ( int64 ) ) { switch ( BE64 ( * ( uint64 * ) readBuffer ) ) { case 0xEB52904E54465320ULL : case 0xEB3C904D53444F53ULL : case 0xEB58904D53444F53ULL : case 0xEB76904558464154ULL : case 0x0000005265465300ULL : case 0xEB58906D6B66732EULL : case 0xEB58906D6B646F73ULL : case 0xEB3C906D6B66732EULL : case 0xEB3C906D6B646F73ULL : opentest -> FilesystemDetected = TRUE ; break ; case 0x0000000000000000ULL : if ( IsAllZeroes ( readBuffer + 8 , TC_VOLUME_HEADER_EFFECTIVE_SIZE - 8 ) ) opentest -> FilesystemDetected = TRUE ; break ; } } } } if ( opentest -> bComputeVolumeIDs && ( ! opentest -> DetectFilesystem || ! opentest -> FilesystemDetected ) ) { int volumeType ; for ( volumeType = TC_VOLUME_TYPE_NORMAL ; volumeType < TC_VOLUME_TYPE_COUNT ; volumeType ++ ) { switch ( volumeType ) { case TC_VOLUME_TYPE_NORMAL : offset . QuadPart = TC_VOLUME_HEADER_OFFSET ; break ; case TC_VOLUME_TYPE_HIDDEN : offset . QuadPart = TC_HIDDEN_VOLUME_HEADER_OFFSET ; break ; } ntStatus = ZwReadFile ( NtFileHandle , NULL , NULL , NULL , & IoStatus , readBuffer , TC_MAX_VOLUME_SECTOR_SIZE , & offset , NULL ) ; if ( NT_SUCCESS ( ntStatus ) ) { sha256 ( opentest -> volumeIDs [ volumeType ] , readBuffer , TC_VOLUME_HEADER_EFFECTIVE_SIZE ) ; opentest -> VolumeIDComputed [ volumeType ] = TRUE ; } } } TCfree ( readBuffer ) ; } } ZwClose ( NtFileHandle ) ; Dump ( ""Open<S2SV_blank>test<S2SV_blank>on<S2SV_blank>file<S2SV_blank>%ls<S2SV_blank>success.\\n"" , opentest -> wszFileName ) ; } else { # if 0 Dump ( ""Open<S2SV_blank>test<S2SV_blank>on<S2SV_blank>file<S2SV_blank>%ls<S2SV_blank>failed<S2SV_blank>NTSTATUS<S2SV_blank>0x%08x\\n"" , opentest -> wszFileName , ntStatus ) ; # endif } Irp -> IoStatus . Information = NT_SUCCESS ( ntStatus ) ? sizeof ( OPEN_TEST_STRUCT ) : 0 ; Irp -> IoStatus . Status = ntStatus ; } break ; case TC_IOCTL_GET_SYSTEM_DRIVE_CONFIG : { GetSystemDriveConfigurationRequest * request = ( GetSystemDriveConfigurationRequest * ) Irp -> AssociatedIrp . SystemBuffer ; OBJECT_ATTRIBUTES ObjectAttributes ; HANDLE NtFileHandle ; UNICODE_STRING FullFileName ; IO_STATUS_BLOCK IoStatus ; LARGE_INTEGER offset ;  byte readBuffer [ TC_SECTOR_SIZE_BIOS ] ;  if ( ! ValidateIOBufferSize ( Irp , sizeof ( GetSystemDriveConfigurationRequest ) , ValidateInputOutput ) )  break ;  EnsureNullTerminatedString ( request -> DevicePath , sizeof ( request -> DevicePath ) ) ; RtlInitUnicodeString ( & FullFileName , request -> DevicePath ) ; InitializeObjectAttributes ( & ObjectAttributes , & FullFileName , OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE , NULL , NULL ) ; ntStatus = ZwCreateFile ( & NtFileHandle , SYNCHRONIZE | GENERIC_READ , & ObjectAttributes , & IoStatus , NULL , FILE_ATTRIBUTE_NORMAL , FILE_SHARE_READ | FILE_SHARE_WRITE , FILE_OPEN , FILE_SYNCHRONOUS_IO_NONALERT | FILE_RANDOM_ACCESS , NULL , 0 ) ; if ( NT_SUCCESS ( ntStatus ) ) {  offset . QuadPart = 0 ;  ntStatus = ZwReadFile ( NtFileHandle , NULL , NULL , NULL , & IoStatus , readBuffer ,  sizeof ( readBuffer ) ,  & offset , NULL ) ;  if ( NT_SUCCESS ( ntStatus ) )  { size_t i ; request -> DriveIsDynamic = FALSE ; if ( readBuffer [ 510 ] == 0x55 && readBuffer [ 511 ] == 0xaa ) { int i ; for ( i = 0 ; i < 4 ; ++ i ) { if ( readBuffer [ 446 + i * 16 + 4 ] == PARTITION_LDM ) { request -> DriveIsDynamic = TRUE ; break ; } } } request -> BootLoaderVersion = 0 ; request -> Configuration = 0 ; request -> UserConfiguration = 0 ; request -> CustomUserMessage [ 0 ] = 0 ; for ( i = 0 ; i < sizeof ( readBuffer ) - strlen ( TC_APP_NAME ) ; ++ i ) { if ( memcmp ( readBuffer + i , TC_APP_NAME , strlen ( TC_APP_NAME ) ) == 0 ) { request -> BootLoaderVersion = BE16 ( * ( uint16 * ) ( readBuffer + TC_BOOT_SECTOR_VERSION_OFFSET ) ) ; request -> Configuration = readBuffer [ TC_BOOT_SECTOR_CONFIG_OFFSET ] ; if ( request -> BootLoaderVersion != 0 && request -> BootLoaderVersion <= VERSION_NUM ) { request -> UserConfiguration = readBuffer [ TC_BOOT_SECTOR_USER_CONFIG_OFFSET ] ; memcpy ( request -> CustomUserMessage , readBuffer + TC_BOOT_SECTOR_USER_MESSAGE_OFFSET , TC_BOOT_SECTOR_USER_MESSAGE_MAX_LENGTH ) ; } break ; } } Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = sizeof ( * request ) ; } else {  Irp -> IoStatus . Status = ntStatus ;   Irp -> IoStatus . Information = 0 ;  } ZwClose ( NtFileHandle ) ; } else { Irp -> IoStatus . Status = ntStatus ; Irp -> IoStatus . Information = 0 ; } } break ; case TC_IOCTL_WIPE_PASSWORD_CACHE : WipeCache ( ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_PASSWORD_CACHE_STATUS : Irp -> IoStatus . Status = cacheEmpty ? STATUS_PIPE_EMPTY : STATUS_SUCCESS ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_SET_PORTABLE_MODE_STATUS : if ( ! UserCanAccessDriveDevice ( ) ) { Irp -> IoStatus . Status = STATUS_ACCESS_DENIED ; Irp -> IoStatus . Information = 0 ; } else { PortableMode = TRUE ; Dump ( ""Setting<S2SV_blank>portable<S2SV_blank>mode\\n"" ) ; } break ; case TC_IOCTL_GET_PORTABLE_MODE_STATUS : Irp -> IoStatus . Status = PortableMode ? STATUS_SUCCESS : STATUS_PIPE_EMPTY ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_MOUNTED_VOLUMES : if ( ValidateIOBufferSize ( Irp , sizeof ( MOUNT_LIST_STRUCT ) , ValidateOutput ) ) { MOUNT_LIST_STRUCT * list = ( MOUNT_LIST_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; PDEVICE_OBJECT ListDevice ; int drive ; list -> ulMountedDrives = 0 ; for ( drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER ; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER ; ++ drive ) { PEXTENSION ListExtension ; ListDevice = GetVirtualVolumeDeviceObject ( drive ) ; if ( ! ListDevice ) continue ; ListExtension = ( PEXTENSION ) ListDevice -> DeviceExtension ; if ( IsVolumeAccessibleByCurrentUser ( ListExtension ) ) { list -> ulMountedDrives |= ( 1 << ListExtension -> nDosDriveNo ) ; RtlStringCbCopyW ( list -> wszVolume [ ListExtension -> nDosDriveNo ] , sizeof ( list -> wszVolume [ ListExtension -> nDosDriveNo ] ) , ListExtension -> wszVolume ) ; RtlStringCbCopyW ( list -> wszLabel [ ListExtension -> nDosDriveNo ] , sizeof ( list -> wszLabel [ ListExtension -> nDosDriveNo ] ) , ListExtension -> wszLabel ) ; memcpy ( list -> volumeID [ ListExtension -> nDosDriveNo ] , ListExtension -> volumeID , VOLUME_ID_SIZE ) ; list -> diskLength [ ListExtension -> nDosDriveNo ] = ListExtension -> DiskLength ; list -> ea [ ListExtension -> nDosDriveNo ] = ListExtension -> cryptoInfo -> ea ; if ( ListExtension -> cryptoInfo -> hiddenVolume ) list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_HIDDEN ; else if ( ListExtension -> cryptoInfo -> bHiddenVolProtectionAction ) list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_OUTER_VOL_WRITE_PREVENTED ; else if ( ListExtension -> cryptoInfo -> bProtectHiddenVolume ) list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_OUTER ; else list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_NORMAL ; list -> truecryptMode [ ListExtension -> nDosDriveNo ] = ListExtension -> cryptoInfo -> bTrueCryptMode ; } } Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = sizeof ( MOUNT_LIST_STRUCT ) ; } break ; case TC_IOCTL_LEGACY_GET_MOUNTED_VOLUMES : if ( ValidateIOBufferSize ( Irp , sizeof ( uint32 ) , ValidateOutput ) ) { memset ( Irp -> AssociatedIrp . SystemBuffer , 0 , irpSp -> Parameters . DeviceIoControl . OutputBufferLength ) ; * ( uint32 * ) Irp -> AssociatedIrp . SystemBuffer = 0xffffFFFF ; Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = irpSp -> Parameters . DeviceIoControl . OutputBufferLength ; } break ; case TC_IOCTL_GET_VOLUME_PROPERTIES : if ( ValidateIOBufferSize ( Irp , sizeof ( VOLUME_PROPERTIES_STRUCT ) , ValidateInputOutput ) ) { VOLUME_PROPERTIES_STRUCT * prop = ( VOLUME_PROPERTIES_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; PDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject ( prop -> driveNo ) ; Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; if ( ListDevice ) { PEXTENSION ListExtension = ( PEXTENSION ) ListDevice -> DeviceExtension ; if ( IsVolumeAccessibleByCurrentUser ( ListExtension ) ) { prop -> uniqueId = ListExtension -> UniqueVolumeId ; RtlStringCbCopyW ( prop -> wszVolume , sizeof ( prop -> wszVolume ) , ListExtension -> wszVolume ) ; RtlStringCbCopyW ( prop -> wszLabel , sizeof ( prop -> wszLabel ) , ListExtension -> wszLabel ) ; memcpy ( prop -> volumeID , ListExtension -> volumeID , VOLUME_ID_SIZE ) ; prop -> bDriverSetLabel = ListExtension -> bDriverSetLabel ; prop -> diskLength = ListExtension -> DiskLength ; prop -> ea = ListExtension -> cryptoInfo -> ea ; prop -> mode = ListExtension -> cryptoInfo -> mode ; prop -> pkcs5 = ListExtension -> cryptoInfo -> pkcs5 ; prop -> pkcs5Iterations = ListExtension -> cryptoInfo -> noIterations ; prop -> volumePim = ListExtension -> cryptoInfo -> volumePim ; # if 0 prop -> volumeCreationTime = ListExtension -> cryptoInfo -> volume_creation_time ; prop -> headerCreationTime = ListExtension -> cryptoInfo -> header_creation_time ; # endif prop -> volumeHeaderFlags = ListExtension -> cryptoInfo -> HeaderFlags ; prop -> readOnly = ListExtension -> bReadOnly ; prop -> removable = ListExtension -> bRemovable ; prop -> partitionInInactiveSysEncScope = ListExtension -> PartitionInInactiveSysEncScope ; prop -> hiddenVolume = ListExtension -> cryptoInfo -> hiddenVolume ; if ( ListExtension -> cryptoInfo -> bProtectHiddenVolume ) prop -> hiddenVolProtection = ListExtension -> cryptoInfo -> bHiddenVolProtectionAction ? HIDVOL_PROT_STATUS_ACTION_TAKEN : HIDVOL_PROT_STATUS_ACTIVE ; else prop -> hiddenVolProtection = HIDVOL_PROT_STATUS_NONE ; prop -> totalBytesRead = ListExtension -> Queue . TotalBytesRead ; prop -> totalBytesWritten = ListExtension -> Queue . TotalBytesWritten ; prop -> volFormatVersion = ListExtension -> cryptoInfo -> LegacyVolume ? TC_VOLUME_FORMAT_VERSION_PRE_6_0 : TC_VOLUME_FORMAT_VERSION ; Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = sizeof ( VOLUME_PROPERTIES_STRUCT ) ; } } } break ; case TC_IOCTL_GET_RESOLVED_SYMLINK : if ( ValidateIOBufferSize ( Irp , sizeof ( RESOLVE_SYMLINK_STRUCT ) , ValidateInputOutput ) ) { RESOLVE_SYMLINK_STRUCT * resolve = ( RESOLVE_SYMLINK_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; { NTSTATUS ntStatus ; EnsureNullTerminatedString ( resolve -> symLinkName , sizeof ( resolve -> symLinkName ) ) ; ntStatus = SymbolicLinkToTarget ( resolve -> symLinkName , resolve -> targetName , sizeof ( resolve -> targetName ) ) ; Irp -> IoStatus . Information = sizeof ( RESOLVE_SYMLINK_STRUCT ) ; Irp -> IoStatus . Status = ntStatus ; } } break ; case TC_IOCTL_GET_DRIVE_PARTITION_INFO : if ( ValidateIOBufferSize ( Irp , sizeof ( DISK_PARTITION_INFO_STRUCT ) , ValidateInputOutput ) ) { DISK_PARTITION_INFO_STRUCT * info = ( DISK_PARTITION_INFO_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; { PARTITION_INFORMATION_EX pi ; NTSTATUS ntStatus ; EnsureNullTerminatedString ( info -> deviceName , sizeof ( info -> deviceName ) ) ; ntStatus = TCDeviceIoControl ( info -> deviceName , IOCTL_DISK_GET_PARTITION_INFO_EX , NULL , 0 , & pi , sizeof ( pi ) ) ; if ( NT_SUCCESS ( ntStatus ) ) { memset ( & info -> partInfo , 0 , sizeof ( info -> partInfo ) ) ; info -> partInfo . PartitionLength = pi . PartitionLength ; info -> partInfo . PartitionNumber = pi . PartitionNumber ; info -> partInfo . StartingOffset = pi . StartingOffset ; if ( pi . PartitionStyle == PARTITION_STYLE_MBR ) { info -> partInfo . PartitionType = pi . Mbr . PartitionType ; info -> partInfo . BootIndicator = pi . Mbr . BootIndicator ; } info -> IsGPT = pi . PartitionStyle == PARTITION_STYLE_GPT ; } else { ntStatus = TCDeviceIoControl ( info -> deviceName , IOCTL_DISK_GET_PARTITION_INFO , NULL , 0 , & info -> partInfo , sizeof ( info -> partInfo ) ) ; info -> IsGPT = FALSE ; } if ( ! NT_SUCCESS ( ntStatus ) ) { GET_LENGTH_INFORMATION lengthInfo ; ntStatus = TCDeviceIoControl ( info -> deviceName , IOCTL_DISK_GET_LENGTH_INFO , NULL , 0 , & lengthInfo , sizeof ( lengthInfo ) ) ; if ( NT_SUCCESS ( ntStatus ) ) { memset ( & info -> partInfo , 0 , sizeof ( info -> partInfo ) ) ; info -> partInfo . PartitionLength = lengthInfo . Length ; } } info -> IsDynamic = FALSE ; if ( NT_SUCCESS ( ntStatus ) && OsMajorVersion >= 6 ) { # define IOCTL_VOLUME_IS_DYNAMIC CTL_CODE ( IOCTL_VOLUME_BASE , 18 , METHOD_BUFFERED , FILE_ANY_ACCESS ) if ( ! NT_SUCCESS ( TCDeviceIoControl ( info -> deviceName , IOCTL_VOLUME_IS_DYNAMIC , NULL , 0 , & info -> IsDynamic , sizeof ( info -> IsDynamic ) ) ) ) info -> IsDynamic = FALSE ; } Irp -> IoStatus . Information = sizeof ( DISK_PARTITION_INFO_STRUCT ) ; Irp -> IoStatus . Status = ntStatus ; } } break ; case TC_IOCTL_GET_DRIVE_GEOMETRY : if ( ValidateIOBufferSize ( Irp , sizeof ( DISK_GEOMETRY_STRUCT ) , ValidateInputOutput ) ) { DISK_GEOMETRY_STRUCT * g = ( DISK_GEOMETRY_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; { NTSTATUS ntStatus ; EnsureNullTerminatedString ( g -> deviceName , sizeof ( g -> deviceName ) ) ; Dump ( ""Calling<S2SV_blank>IOCTL_DISK_GET_DRIVE_GEOMETRY<S2SV_blank>on<S2SV_blank>%ls\\n"" , g -> deviceName ) ; ntStatus = TCDeviceIoControl ( g -> deviceName , IOCTL_DISK_GET_DRIVE_GEOMETRY , NULL , 0 , & g -> diskGeometry , sizeof ( g -> diskGeometry ) ) ; Irp -> IoStatus . Information = sizeof ( DISK_GEOMETRY_STRUCT ) ; Irp -> IoStatus . Status = ntStatus ; } } break ; case VC_IOCTL_GET_DRIVE_GEOMETRY_EX : if ( ValidateIOBufferSize ( Irp , sizeof ( DISK_GEOMETRY_EX_STRUCT ) , ValidateInputOutput ) ) { DISK_GEOMETRY_EX_STRUCT * g = ( DISK_GEOMETRY_EX_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; { NTSTATUS ntStatus ; PVOID buffer = TCalloc ( 256 ) ; if ( buffer ) { EnsureNullTerminatedString ( g -> deviceName , sizeof ( g -> deviceName ) ) ; Dump ( ""Calling<S2SV_blank>IOCTL_DISK_GET_DRIVE_GEOMETRY_EX<S2SV_blank>on<S2SV_blank>%ls\\n"" , g -> deviceName ) ; ntStatus = TCDeviceIoControl ( g -> deviceName , IOCTL_DISK_GET_DRIVE_GEOMETRY_EX , NULL , 0 , buffer , 256 ) ; if ( NT_SUCCESS ( ntStatus ) ) { PDISK_GEOMETRY_EX pGeo = ( PDISK_GEOMETRY_EX ) buffer ; memcpy ( & g -> diskGeometry , & pGeo -> Geometry , sizeof ( DISK_GEOMETRY ) ) ; g -> DiskSize . QuadPart = pGeo -> DiskSize . QuadPart ; } else { DISK_GEOMETRY dg = { 0 } ; Dump ( ""Failed.<S2SV_blank>Calling<S2SV_blank>IOCTL_DISK_GET_DRIVE_GEOMETRY<S2SV_blank>on<S2SV_blank>%ls\\n"" , g -> deviceName ) ; ntStatus = TCDeviceIoControl ( g -> deviceName , IOCTL_DISK_GET_DRIVE_GEOMETRY , NULL , 0 , & dg , sizeof ( dg ) ) ; if ( NT_SUCCESS ( ntStatus ) ) { memcpy ( & g -> diskGeometry , & dg , sizeof ( DISK_GEOMETRY ) ) ; g -> DiskSize . QuadPart = dg . Cylinders . QuadPart * dg . SectorsPerTrack * dg . TracksPerCylinder * dg . BytesPerSector ; if ( OsMajorVersion >= 6 ) { STORAGE_READ_CAPACITY storage = { 0 } ; NTSTATUS lStatus ; storage . Version = sizeof ( STORAGE_READ_CAPACITY ) ; Dump ( ""Calling<S2SV_blank>IOCTL_STORAGE_READ_CAPACITY<S2SV_blank>on<S2SV_blank>%ls\\n"" , g -> deviceName ) ; lStatus = TCDeviceIoControl ( g -> deviceName , IOCTL_STORAGE_READ_CAPACITY , NULL , 0 , & storage , sizeof ( STORAGE_READ_CAPACITY ) ) ; if ( NT_SUCCESS ( lStatus ) && ( storage . Size == sizeof ( STORAGE_READ_CAPACITY ) ) ) { g -> DiskSize . QuadPart = storage . DiskLength . QuadPart ; } } } } TCfree ( buffer ) ; Irp -> IoStatus . Information = sizeof ( DISK_GEOMETRY_EX_STRUCT ) ; Irp -> IoStatus . Status = ntStatus ; } else { Irp -> IoStatus . Status = STATUS_INSUFFICIENT_RESOURCES ; Irp -> IoStatus . Information = 0 ; } } } break ; case TC_IOCTL_PROBE_REAL_DRIVE_SIZE : if ( ValidateIOBufferSize ( Irp , sizeof ( ProbeRealDriveSizeRequest ) , ValidateInputOutput ) ) { ProbeRealDriveSizeRequest * request = ( ProbeRealDriveSizeRequest * ) Irp -> AssociatedIrp . SystemBuffer ; NTSTATUS status ; UNICODE_STRING name ; PFILE_OBJECT fileObject ; PDEVICE_OBJECT deviceObject ; EnsureNullTerminatedString ( request -> DeviceName , sizeof ( request -> DeviceName ) ) ; RtlInitUnicodeString ( & name , request -> DeviceName ) ; status = IoGetDeviceObjectPointer ( & name , FILE_READ_ATTRIBUTES , & fileObject , & deviceObject ) ; if ( ! NT_SUCCESS ( status ) ) { Irp -> IoStatus . Information = 0 ; Irp -> IoStatus . Status = status ; break ; } status = ProbeRealDriveSize ( deviceObject , & request -> RealDriveSize ) ; ObDereferenceObject ( fileObject ) ; if ( status == STATUS_TIMEOUT ) { request -> TimeOut = TRUE ; Irp -> IoStatus . Information = sizeof ( ProbeRealDriveSizeRequest ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } else if ( ! NT_SUCCESS ( status ) ) { Irp -> IoStatus . Information = 0 ; Irp -> IoStatus . Status = status ; } else { request -> TimeOut = FALSE ; Irp -> IoStatus . Information = sizeof ( ProbeRealDriveSizeRequest ) ; Irp -> IoStatus . Status = status ; } } break ; case TC_IOCTL_MOUNT_VOLUME : if ( ValidateIOBufferSize ( Irp , sizeof ( MOUNT_STRUCT ) , ValidateInputOutput ) ) { MOUNT_STRUCT * mount = ( MOUNT_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; if ( mount -> VolumePassword . Length > MAX_PASSWORD || mount -> ProtectedHidVolPassword . Length > MAX_PASSWORD || mount -> pkcs5_prf < 0 || mount -> pkcs5_prf > LAST_PRF_ID || mount -> VolumePim < - 1 || mount -> VolumePim == INT_MAX || mount -> ProtectedHidVolPkcs5Prf < 0 || mount -> ProtectedHidVolPkcs5Prf > LAST_PRF_ID || ( mount -> bTrueCryptMode != FALSE && mount -> bTrueCryptMode != TRUE ) ) { Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; break ; } EnsureNullTerminatedString ( mount -> wszVolume , sizeof ( mount -> wszVolume ) ) ; EnsureNullTerminatedString ( mount -> wszLabel , sizeof ( mount -> wszLabel ) ) ; Irp -> IoStatus . Information = sizeof ( MOUNT_STRUCT ) ; Irp -> IoStatus . Status = MountDevice ( DeviceObject , mount ) ; burn ( & mount -> VolumePassword , sizeof ( mount -> VolumePassword ) ) ; burn ( & mount -> ProtectedHidVolPassword , sizeof ( mount -> ProtectedHidVolPassword ) ) ; burn ( & mount -> pkcs5_prf , sizeof ( mount -> pkcs5_prf ) ) ; burn ( & mount -> VolumePim , sizeof ( mount -> VolumePim ) ) ; burn ( & mount -> bTrueCryptMode , sizeof ( mount -> bTrueCryptMode ) ) ; burn ( & mount -> ProtectedHidVolPkcs5Prf , sizeof ( mount -> ProtectedHidVolPkcs5Prf ) ) ; burn ( & mount -> ProtectedHidVolPim , sizeof ( mount -> ProtectedHidVolPim ) ) ; } break ; case TC_IOCTL_DISMOUNT_VOLUME : if ( ValidateIOBufferSize ( Irp , sizeof ( UNMOUNT_STRUCT ) , ValidateInputOutput ) ) { UNMOUNT_STRUCT * unmount = ( UNMOUNT_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; PDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject ( unmount -> nDosDriveNo ) ; unmount -> nReturnCode = ERR_DRIVE_NOT_FOUND ; if ( ListDevice ) { PEXTENSION ListExtension = ( PEXTENSION ) ListDevice -> DeviceExtension ; if ( IsVolumeAccessibleByCurrentUser ( ListExtension ) ) unmount -> nReturnCode = UnmountDevice ( unmount , ListDevice , unmount -> ignoreOpenFiles ) ; } Irp -> IoStatus . Information = sizeof ( UNMOUNT_STRUCT ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_DISMOUNT_ALL_VOLUMES : if ( ValidateIOBufferSize ( Irp , sizeof ( UNMOUNT_STRUCT ) , ValidateInputOutput ) ) { UNMOUNT_STRUCT * unmount = ( UNMOUNT_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; unmount -> nReturnCode = UnmountAllDevices ( unmount , unmount -> ignoreOpenFiles ) ; Irp -> IoStatus . Information = sizeof ( UNMOUNT_STRUCT ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_BOOT_ENCRYPTION_SETUP : Irp -> IoStatus . Status = StartBootEncryptionSetup ( DeviceObject , Irp , irpSp ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_ABORT_BOOT_ENCRYPTION_SETUP : Irp -> IoStatus . Status = AbortBootEncryptionSetup ( ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS : GetBootEncryptionStatus ( Irp , irpSp ) ; break ; case TC_IOCTL_GET_BOOT_ENCRYPTION_SETUP_RESULT : Irp -> IoStatus . Information = 0 ; Irp -> IoStatus . Status = GetSetupResult ( ) ; break ; case TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES : GetBootDriveVolumeProperties ( Irp , irpSp ) ; break ; case TC_IOCTL_GET_BOOT_LOADER_VERSION : GetBootLoaderVersion ( Irp , irpSp ) ; break ; case TC_IOCTL_REOPEN_BOOT_VOLUME_HEADER : ReopenBootVolumeHeader ( Irp , irpSp ) ; break ; case VC_IOCTL_GET_BOOT_LOADER_FINGERPRINT : GetBootLoaderFingerprint ( Irp , irpSp ) ; break ; case TC_IOCTL_GET_BOOT_ENCRYPTION_ALGORITHM_NAME : GetBootEncryptionAlgorithmName ( Irp , irpSp ) ; break ; case TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { * ( int * ) Irp -> AssociatedIrp . SystemBuffer = IsHiddenSystemRunning ( ) ? 1 : 0 ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_START_DECOY_SYSTEM_WIPE : Irp -> IoStatus . Status = StartDecoySystemWipe ( DeviceObject , Irp , irpSp ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_ABORT_DECOY_SYSTEM_WIPE : Irp -> IoStatus . Status = AbortDecoySystemWipe ( ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_DECOY_SYSTEM_WIPE_RESULT : Irp -> IoStatus . Status = GetDecoySystemWipeResult ( ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_DECOY_SYSTEM_WIPE_STATUS : GetDecoySystemWipeStatus ( Irp , irpSp ) ; break ; case TC_IOCTL_WRITE_BOOT_DRIVE_SECTOR : Irp -> IoStatus . Status = WriteBootDriveSector ( Irp , irpSp ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_WARNING_FLAGS : if ( ValidateIOBufferSize ( Irp , sizeof ( GetWarningFlagsRequest ) , ValidateOutput ) ) { GetWarningFlagsRequest * flags = ( GetWarningFlagsRequest * ) Irp -> AssociatedIrp . SystemBuffer ; flags -> PagingFileCreationPrevented = PagingFileCreationPrevented ; PagingFileCreationPrevented = FALSE ; flags -> SystemFavoriteVolumeDirty = SystemFavoriteVolumeDirty ; SystemFavoriteVolumeDirty = FALSE ; Irp -> IoStatus . Information = sizeof ( GetWarningFlagsRequest ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_SET_SYSTEM_FAVORITE_VOLUME_DIRTY : if ( UserCanAccessDriveDevice ( ) ) { SystemFavoriteVolumeDirty = TRUE ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } else Irp -> IoStatus . Status = STATUS_ACCESS_DENIED ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_REREAD_DRIVER_CONFIG : Irp -> IoStatus . Status = ReadRegistryConfigFlags ( FALSE ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_SYSTEM_DRIVE_DUMP_CONFIG : if ( ( ValidateIOBufferSize ( Irp , sizeof ( GetSystemDriveDumpConfigRequest ) , ValidateOutput ) ) && ( Irp -> RequestorMode == KernelMode ) ) { GetSystemDriveDumpConfigRequest * request = ( GetSystemDriveDumpConfigRequest * ) Irp -> AssociatedIrp . SystemBuffer ; request -> BootDriveFilterExtension = GetBootDriveFilterExtension ( ) ; if ( IsBootDriveMounted ( ) && request -> BootDriveFilterExtension ) { request -> HwEncryptionEnabled = IsHwEncryptionEnabled ( ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = sizeof ( * request ) ; } else { Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; } } break ; default : return TCCompleteIrp ( Irp , STATUS_INVALID_DEVICE_REQUEST , 0 ) ; } # if defined ( DEBUG ) || defined ( DEBUG_TRACE ) if ( ! NT_SUCCESS ( Irp -> IoStatus . Status ) ) { switch ( irpSp -> Parameters . DeviceIoControl . IoControlCode ) { case TC_IOCTL_GET_MOUNTED_VOLUMES : case TC_IOCTL_GET_PASSWORD_CACHE_STATUS : case TC_IOCTL_GET_PORTABLE_MODE_STATUS : case TC_IOCTL_SET_PORTABLE_MODE_STATUS : case TC_IOCTL_OPEN_TEST : case TC_IOCTL_GET_RESOLVED_SYMLINK : case TC_IOCTL_GET_DRIVE_PARTITION_INFO : case TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES : case TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS : case TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING : break ; default : Dump ( ""IOCTL<S2SV_blank>error<S2SV_blank>0x%08x\\n"" , Irp -> IoStatus . Status ) ; } } # endif return TCCompleteIrp ( Irp , Irp -> IoStatus . Status , Irp -> IoStatus . Information ) ; }",Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ;Irp -> IoStatus . Information = 0 ;}TCfree ( readBuffer ) ;}}else {,590
803,"buggy line: byte readBuffer [ TC_SECTOR_SIZE_BIOS ] ;if ( ! ValidateIOBufferSize ( Irp , sizeof ( GetSystemDriveConfigurationRequest ) , ValidateInputOutput ) )  break ;EnsureNullTerminatedString ( request -> DevicePath , sizeof ( request -> DevicePath ) ) ;offset . QuadPart = 0 ;ntStatus = ZwReadFile ( NtFileHandle , NULL , NULL , NULL , & IoStatus , readBuffer ,  sizeof ( readBuffer ) ,  & offset , NULL ) ;if ( NT_SUCCESS ( ntStatus ) )  {cwe id:CWE-119context: NTSTATUS ProcessMainDeviceControlIrp ( PDEVICE_OBJECT DeviceObject , PEXTENSION Extension , PIRP Irp ) { PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation ( Irp ) ; NTSTATUS ntStatus ; switch ( irpSp -> Parameters . DeviceIoControl . IoControlCode ) { case TC_IOCTL_GET_DRIVER_VERSION : case TC_IOCTL_LEGACY_GET_DRIVER_VERSION : if ( ValidateIOBufferSize ( Irp , sizeof ( LONG ) , ValidateOutput ) ) { LONG tmp = VERSION_NUM ; memcpy ( Irp -> AssociatedIrp . SystemBuffer , & tmp , 4 ) ; Irp -> IoStatus . Information = sizeof ( LONG ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_GET_DEVICE_REFCOUNT : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { * ( int * ) Irp -> AssociatedIrp . SystemBuffer = DeviceObject -> ReferenceCount ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_IS_DRIVER_UNLOAD_DISABLED : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { LONG deviceObjectCount = 0 ; * ( int * ) Irp -> AssociatedIrp . SystemBuffer = DriverUnloadDisabled ; if ( IoEnumerateDeviceObjectList ( TCDriverObject , NULL , 0 , & deviceObjectCount ) == STATUS_BUFFER_TOO_SMALL && deviceObjectCount > 1 ) * ( int * ) Irp -> AssociatedIrp . SystemBuffer = TRUE ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_IS_ANY_VOLUME_MOUNTED : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { int drive ; * ( int * ) Irp -> AssociatedIrp . SystemBuffer = 0 ; for ( drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER ; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER ; ++ drive ) { if ( GetVirtualVolumeDeviceObject ( drive ) ) { * ( int * ) Irp -> AssociatedIrp . SystemBuffer = 1 ; break ; } } if ( IsBootDriveMounted ( ) ) * ( int * ) Irp -> AssociatedIrp . SystemBuffer = 1 ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_OPEN_TEST : { OPEN_TEST_STRUCT * opentest = ( OPEN_TEST_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; OBJECT_ATTRIBUTES ObjectAttributes ; HANDLE NtFileHandle ; UNICODE_STRING FullFileName ; IO_STATUS_BLOCK IoStatus ; LARGE_INTEGER offset ; ACCESS_MASK access = FILE_READ_ATTRIBUTES ; if ( ! ValidateIOBufferSize ( Irp , sizeof ( OPEN_TEST_STRUCT ) , ValidateInputOutput ) ) break ; EnsureNullTerminatedString ( opentest -> wszFileName , sizeof ( opentest -> wszFileName ) ) ; RtlInitUnicodeString ( & FullFileName , opentest -> wszFileName ) ; InitializeObjectAttributes ( & ObjectAttributes , & FullFileName , OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE , NULL , NULL ) ; if ( opentest -> bDetectTCBootLoader || opentest -> DetectFilesystem || opentest -> bComputeVolumeIDs ) access |= FILE_READ_DATA ; ntStatus = ZwCreateFile ( & NtFileHandle , SYNCHRONIZE | access , & ObjectAttributes , & IoStatus , NULL , 0 , FILE_SHARE_READ | FILE_SHARE_WRITE , FILE_OPEN , FILE_SYNCHRONOUS_IO_NONALERT , NULL , 0 ) ; if ( NT_SUCCESS ( ntStatus ) ) { opentest -> TCBootLoaderDetected = FALSE ; opentest -> FilesystemDetected = FALSE ; memset ( opentest -> VolumeIDComputed , 0 , sizeof ( opentest -> VolumeIDComputed ) ) ; memset ( opentest -> volumeIDs , 0 , sizeof ( opentest -> volumeIDs ) ) ; if ( opentest -> bDetectTCBootLoader || opentest -> DetectFilesystem || opentest -> bComputeVolumeIDs ) { byte * readBuffer = TCalloc ( TC_MAX_VOLUME_SECTOR_SIZE ) ; if ( ! readBuffer ) { ntStatus = STATUS_INSUFFICIENT_RESOURCES ; } else { if ( opentest -> bDetectTCBootLoader || opentest -> DetectFilesystem ) { offset . QuadPart = 0 ; ntStatus = ZwReadFile ( NtFileHandle , NULL , NULL , NULL , & IoStatus , readBuffer , TC_MAX_VOLUME_SECTOR_SIZE , & offset , NULL ) ; if ( NT_SUCCESS ( ntStatus ) ) { size_t i ; if ( opentest -> bDetectTCBootLoader && IoStatus . Information >= TC_SECTOR_SIZE_BIOS ) { for ( i = 0 ; i < TC_SECTOR_SIZE_BIOS - strlen ( TC_APP_NAME ) ; ++ i ) { if ( memcmp ( readBuffer + i , TC_APP_NAME , strlen ( TC_APP_NAME ) ) == 0 ) { opentest -> TCBootLoaderDetected = TRUE ; break ; } } } if ( opentest -> DetectFilesystem && IoStatus . Information >= sizeof ( int64 ) ) { switch ( BE64 ( * ( uint64 * ) readBuffer ) ) { case 0xEB52904E54465320ULL : case 0xEB3C904D53444F53ULL : case 0xEB58904D53444F53ULL : case 0xEB76904558464154ULL : case 0x0000005265465300ULL : case 0xEB58906D6B66732EULL : case 0xEB58906D6B646F73ULL : case 0xEB3C906D6B66732EULL : case 0xEB3C906D6B646F73ULL : opentest -> FilesystemDetected = TRUE ; break ; case 0x0000000000000000ULL : if ( IsAllZeroes ( readBuffer + 8 , TC_VOLUME_HEADER_EFFECTIVE_SIZE - 8 ) ) opentest -> FilesystemDetected = TRUE ; break ; } } } } if ( opentest -> bComputeVolumeIDs && ( ! opentest -> DetectFilesystem || ! opentest -> FilesystemDetected ) ) { int volumeType ; for ( volumeType = TC_VOLUME_TYPE_NORMAL ; volumeType < TC_VOLUME_TYPE_COUNT ; volumeType ++ ) { switch ( volumeType ) { case TC_VOLUME_TYPE_NORMAL : offset . QuadPart = TC_VOLUME_HEADER_OFFSET ; break ; case TC_VOLUME_TYPE_HIDDEN : offset . QuadPart = TC_HIDDEN_VOLUME_HEADER_OFFSET ; break ; } ntStatus = ZwReadFile ( NtFileHandle , NULL , NULL , NULL , & IoStatus , readBuffer , TC_MAX_VOLUME_SECTOR_SIZE , & offset , NULL ) ; if ( NT_SUCCESS ( ntStatus ) ) { sha256 ( opentest -> volumeIDs [ volumeType ] , readBuffer , TC_VOLUME_HEADER_EFFECTIVE_SIZE ) ; opentest -> VolumeIDComputed [ volumeType ] = TRUE ; } } } TCfree ( readBuffer ) ; } } ZwClose ( NtFileHandle ) ; Dump ( ""Open<S2SV_blank>test<S2SV_blank>on<S2SV_blank>file<S2SV_blank>%ls<S2SV_blank>success.\\n"" , opentest -> wszFileName ) ; } else { # if 0 Dump ( ""Open<S2SV_blank>test<S2SV_blank>on<S2SV_blank>file<S2SV_blank>%ls<S2SV_blank>failed<S2SV_blank>NTSTATUS<S2SV_blank>0x%08x\\n"" , opentest -> wszFileName , ntStatus ) ; # endif } Irp -> IoStatus . Information = NT_SUCCESS ( ntStatus ) ? sizeof ( OPEN_TEST_STRUCT ) : 0 ; Irp -> IoStatus . Status = ntStatus ; } break ; case TC_IOCTL_GET_SYSTEM_DRIVE_CONFIG : { GetSystemDriveConfigurationRequest * request = ( GetSystemDriveConfigurationRequest * ) Irp -> AssociatedIrp . SystemBuffer ; OBJECT_ATTRIBUTES ObjectAttributes ; HANDLE NtFileHandle ; UNICODE_STRING FullFileName ; IO_STATUS_BLOCK IoStatus ; LARGE_INTEGER offset ;  byte readBuffer [ TC_SECTOR_SIZE_BIOS ] ;  if ( ! ValidateIOBufferSize ( Irp , sizeof ( GetSystemDriveConfigurationRequest ) , ValidateInputOutput ) )  break ;  EnsureNullTerminatedString ( request -> DevicePath , sizeof ( request -> DevicePath ) ) ; RtlInitUnicodeString ( & FullFileName , request -> DevicePath ) ; InitializeObjectAttributes ( & ObjectAttributes , & FullFileName , OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE , NULL , NULL ) ; ntStatus = ZwCreateFile ( & NtFileHandle , SYNCHRONIZE | GENERIC_READ , & ObjectAttributes , & IoStatus , NULL , FILE_ATTRIBUTE_NORMAL , FILE_SHARE_READ | FILE_SHARE_WRITE , FILE_OPEN , FILE_SYNCHRONOUS_IO_NONALERT | FILE_RANDOM_ACCESS , NULL , 0 ) ; if ( NT_SUCCESS ( ntStatus ) ) {  offset . QuadPart = 0 ;  ntStatus = ZwReadFile ( NtFileHandle , NULL , NULL , NULL , & IoStatus , readBuffer ,  sizeof ( readBuffer ) ,  & offset , NULL ) ;  if ( NT_SUCCESS ( ntStatus ) )  { size_t i ; request -> DriveIsDynamic = FALSE ; if ( readBuffer [ 510 ] == 0x55 && readBuffer [ 511 ] == 0xaa ) { int i ; for ( i = 0 ; i < 4 ; ++ i ) { if ( readBuffer [ 446 + i * 16 + 4 ] == PARTITION_LDM ) { request -> DriveIsDynamic = TRUE ; break ; } } } request -> BootLoaderVersion = 0 ; request -> Configuration = 0 ; request -> UserConfiguration = 0 ; request -> CustomUserMessage [ 0 ] = 0 ; for ( i = 0 ; i < sizeof ( readBuffer ) - strlen ( TC_APP_NAME ) ; ++ i ) { if ( memcmp ( readBuffer + i , TC_APP_NAME , strlen ( TC_APP_NAME ) ) == 0 ) { request -> BootLoaderVersion = BE16 ( * ( uint16 * ) ( readBuffer + TC_BOOT_SECTOR_VERSION_OFFSET ) ) ; request -> Configuration = readBuffer [ TC_BOOT_SECTOR_CONFIG_OFFSET ] ; if ( request -> BootLoaderVersion != 0 && request -> BootLoaderVersion <= VERSION_NUM ) { request -> UserConfiguration = readBuffer [ TC_BOOT_SECTOR_USER_CONFIG_OFFSET ] ; memcpy ( request -> CustomUserMessage , readBuffer + TC_BOOT_SECTOR_USER_MESSAGE_OFFSET , TC_BOOT_SECTOR_USER_MESSAGE_MAX_LENGTH ) ; } break ; } } Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = sizeof ( * request ) ; } else {  Irp -> IoStatus . Status = ntStatus ;   Irp -> IoStatus . Information = 0 ;  } ZwClose ( NtFileHandle ) ; } else { Irp -> IoStatus . Status = ntStatus ; Irp -> IoStatus . Information = 0 ; } } break ; case TC_IOCTL_WIPE_PASSWORD_CACHE : WipeCache ( ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_PASSWORD_CACHE_STATUS : Irp -> IoStatus . Status = cacheEmpty ? STATUS_PIPE_EMPTY : STATUS_SUCCESS ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_SET_PORTABLE_MODE_STATUS : if ( ! UserCanAccessDriveDevice ( ) ) { Irp -> IoStatus . Status = STATUS_ACCESS_DENIED ; Irp -> IoStatus . Information = 0 ; } else { PortableMode = TRUE ; Dump ( ""Setting<S2SV_blank>portable<S2SV_blank>mode\\n"" ) ; } break ; case TC_IOCTL_GET_PORTABLE_MODE_STATUS : Irp -> IoStatus . Status = PortableMode ? STATUS_SUCCESS : STATUS_PIPE_EMPTY ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_MOUNTED_VOLUMES : if ( ValidateIOBufferSize ( Irp , sizeof ( MOUNT_LIST_STRUCT ) , ValidateOutput ) ) { MOUNT_LIST_STRUCT * list = ( MOUNT_LIST_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; PDEVICE_OBJECT ListDevice ; int drive ; list -> ulMountedDrives = 0 ; for ( drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER ; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER ; ++ drive ) { PEXTENSION ListExtension ; ListDevice = GetVirtualVolumeDeviceObject ( drive ) ; if ( ! ListDevice ) continue ; ListExtension = ( PEXTENSION ) ListDevice -> DeviceExtension ; if ( IsVolumeAccessibleByCurrentUser ( ListExtension ) ) { list -> ulMountedDrives |= ( 1 << ListExtension -> nDosDriveNo ) ; RtlStringCbCopyW ( list -> wszVolume [ ListExtension -> nDosDriveNo ] , sizeof ( list -> wszVolume [ ListExtension -> nDosDriveNo ] ) , ListExtension -> wszVolume ) ; RtlStringCbCopyW ( list -> wszLabel [ ListExtension -> nDosDriveNo ] , sizeof ( list -> wszLabel [ ListExtension -> nDosDriveNo ] ) , ListExtension -> wszLabel ) ; memcpy ( list -> volumeID [ ListExtension -> nDosDriveNo ] , ListExtension -> volumeID , VOLUME_ID_SIZE ) ; list -> diskLength [ ListExtension -> nDosDriveNo ] = ListExtension -> DiskLength ; list -> ea [ ListExtension -> nDosDriveNo ] = ListExtension -> cryptoInfo -> ea ; if ( ListExtension -> cryptoInfo -> hiddenVolume ) list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_HIDDEN ; else if ( ListExtension -> cryptoInfo -> bHiddenVolProtectionAction ) list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_OUTER_VOL_WRITE_PREVENTED ; else if ( ListExtension -> cryptoInfo -> bProtectHiddenVolume ) list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_OUTER ; else list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_NORMAL ; list -> truecryptMode [ ListExtension -> nDosDriveNo ] = ListExtension -> cryptoInfo -> bTrueCryptMode ; } } Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = sizeof ( MOUNT_LIST_STRUCT ) ; } break ; case TC_IOCTL_LEGACY_GET_MOUNTED_VOLUMES : if ( ValidateIOBufferSize ( Irp , sizeof ( uint32 ) , ValidateOutput ) ) { memset ( Irp -> AssociatedIrp . SystemBuffer , 0 , irpSp -> Parameters . DeviceIoControl . OutputBufferLength ) ; * ( uint32 * ) Irp -> AssociatedIrp . SystemBuffer = 0xffffFFFF ; Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = irpSp -> Parameters . DeviceIoControl . OutputBufferLength ; } break ; case TC_IOCTL_GET_VOLUME_PROPERTIES : if ( ValidateIOBufferSize ( Irp , sizeof ( VOLUME_PROPERTIES_STRUCT ) , ValidateInputOutput ) ) { VOLUME_PROPERTIES_STRUCT * prop = ( VOLUME_PROPERTIES_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; PDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject ( prop -> driveNo ) ; Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; if ( ListDevice ) { PEXTENSION ListExtension = ( PEXTENSION ) ListDevice -> DeviceExtension ; if ( IsVolumeAccessibleByCurrentUser ( ListExtension ) ) { prop -> uniqueId = ListExtension -> UniqueVolumeId ; RtlStringCbCopyW ( prop -> wszVolume , sizeof ( prop -> wszVolume ) , ListExtension -> wszVolume ) ; RtlStringCbCopyW ( prop -> wszLabel , sizeof ( prop -> wszLabel ) , ListExtension -> wszLabel ) ; memcpy ( prop -> volumeID , ListExtension -> volumeID , VOLUME_ID_SIZE ) ; prop -> bDriverSetLabel = ListExtension -> bDriverSetLabel ; prop -> diskLength = ListExtension -> DiskLength ; prop -> ea = ListExtension -> cryptoInfo -> ea ; prop -> mode = ListExtension -> cryptoInfo -> mode ; prop -> pkcs5 = ListExtension -> cryptoInfo -> pkcs5 ; prop -> pkcs5Iterations = ListExtension -> cryptoInfo -> noIterations ; prop -> volumePim = ListExtension -> cryptoInfo -> volumePim ; # if 0 prop -> volumeCreationTime = ListExtension -> cryptoInfo -> volume_creation_time ; prop -> headerCreationTime = ListExtension -> cryptoInfo -> header_creation_time ; # endif prop -> volumeHeaderFlags = ListExtension -> cryptoInfo -> HeaderFlags ; prop -> readOnly = ListExtension -> bReadOnly ; prop -> removable = ListExtension -> bRemovable ; prop -> partitionInInactiveSysEncScope = ListExtension -> PartitionInInactiveSysEncScope ; prop -> hiddenVolume = ListExtension -> cryptoInfo -> hiddenVolume ; if ( ListExtension -> cryptoInfo -> bProtectHiddenVolume ) prop -> hiddenVolProtection = ListExtension -> cryptoInfo -> bHiddenVolProtectionAction ? HIDVOL_PROT_STATUS_ACTION_TAKEN : HIDVOL_PROT_STATUS_ACTIVE ; else prop -> hiddenVolProtection = HIDVOL_PROT_STATUS_NONE ; prop -> totalBytesRead = ListExtension -> Queue . TotalBytesRead ; prop -> totalBytesWritten = ListExtension -> Queue . TotalBytesWritten ; prop -> volFormatVersion = ListExtension -> cryptoInfo -> LegacyVolume ? TC_VOLUME_FORMAT_VERSION_PRE_6_0 : TC_VOLUME_FORMAT_VERSION ; Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = sizeof ( VOLUME_PROPERTIES_STRUCT ) ; } } } break ; case TC_IOCTL_GET_RESOLVED_SYMLINK : if ( ValidateIOBufferSize ( Irp , sizeof ( RESOLVE_SYMLINK_STRUCT ) , ValidateInputOutput ) ) { RESOLVE_SYMLINK_STRUCT * resolve = ( RESOLVE_SYMLINK_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; { NTSTATUS ntStatus ; EnsureNullTerminatedString ( resolve -> symLinkName , sizeof ( resolve -> symLinkName ) ) ; ntStatus = SymbolicLinkToTarget ( resolve -> symLinkName , resolve -> targetName , sizeof ( resolve -> targetName ) ) ; Irp -> IoStatus . Information = sizeof ( RESOLVE_SYMLINK_STRUCT ) ; Irp -> IoStatus . Status = ntStatus ; } } break ; case TC_IOCTL_GET_DRIVE_PARTITION_INFO : if ( ValidateIOBufferSize ( Irp , sizeof ( DISK_PARTITION_INFO_STRUCT ) , ValidateInputOutput ) ) { DISK_PARTITION_INFO_STRUCT * info = ( DISK_PARTITION_INFO_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; { PARTITION_INFORMATION_EX pi ; NTSTATUS ntStatus ; EnsureNullTerminatedString ( info -> deviceName , sizeof ( info -> deviceName ) ) ; ntStatus = TCDeviceIoControl ( info -> deviceName , IOCTL_DISK_GET_PARTITION_INFO_EX , NULL , 0 , & pi , sizeof ( pi ) ) ; if ( NT_SUCCESS ( ntStatus ) ) { memset ( & info -> partInfo , 0 , sizeof ( info -> partInfo ) ) ; info -> partInfo . PartitionLength = pi . PartitionLength ; info -> partInfo . PartitionNumber = pi . PartitionNumber ; info -> partInfo . StartingOffset = pi . StartingOffset ; if ( pi . PartitionStyle == PARTITION_STYLE_MBR ) { info -> partInfo . PartitionType = pi . Mbr . PartitionType ; info -> partInfo . BootIndicator = pi . Mbr . BootIndicator ; } info -> IsGPT = pi . PartitionStyle == PARTITION_STYLE_GPT ; } else { ntStatus = TCDeviceIoControl ( info -> deviceName , IOCTL_DISK_GET_PARTITION_INFO , NULL , 0 , & info -> partInfo , sizeof ( info -> partInfo ) ) ; info -> IsGPT = FALSE ; } if ( ! NT_SUCCESS ( ntStatus ) ) { GET_LENGTH_INFORMATION lengthInfo ; ntStatus = TCDeviceIoControl ( info -> deviceName , IOCTL_DISK_GET_LENGTH_INFO , NULL , 0 , & lengthInfo , sizeof ( lengthInfo ) ) ; if ( NT_SUCCESS ( ntStatus ) ) { memset ( & info -> partInfo , 0 , sizeof ( info -> partInfo ) ) ; info -> partInfo . PartitionLength = lengthInfo . Length ; } } info -> IsDynamic = FALSE ; if ( NT_SUCCESS ( ntStatus ) && OsMajorVersion >= 6 ) { # define IOCTL_VOLUME_IS_DYNAMIC CTL_CODE ( IOCTL_VOLUME_BASE , 18 , METHOD_BUFFERED , FILE_ANY_ACCESS ) if ( ! NT_SUCCESS ( TCDeviceIoControl ( info -> deviceName , IOCTL_VOLUME_IS_DYNAMIC , NULL , 0 , & info -> IsDynamic , sizeof ( info -> IsDynamic ) ) ) ) info -> IsDynamic = FALSE ; } Irp -> IoStatus . Information = sizeof ( DISK_PARTITION_INFO_STRUCT ) ; Irp -> IoStatus . Status = ntStatus ; } } break ; case TC_IOCTL_GET_DRIVE_GEOMETRY : if ( ValidateIOBufferSize ( Irp , sizeof ( DISK_GEOMETRY_STRUCT ) , ValidateInputOutput ) ) { DISK_GEOMETRY_STRUCT * g = ( DISK_GEOMETRY_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; { NTSTATUS ntStatus ; EnsureNullTerminatedString ( g -> deviceName , sizeof ( g -> deviceName ) ) ; Dump ( ""Calling<S2SV_blank>IOCTL_DISK_GET_DRIVE_GEOMETRY<S2SV_blank>on<S2SV_blank>%ls\\n"" , g -> deviceName ) ; ntStatus = TCDeviceIoControl ( g -> deviceName , IOCTL_DISK_GET_DRIVE_GEOMETRY , NULL , 0 , & g -> diskGeometry , sizeof ( g -> diskGeometry ) ) ; Irp -> IoStatus . Information = sizeof ( DISK_GEOMETRY_STRUCT ) ; Irp -> IoStatus . Status = ntStatus ; } } break ; case VC_IOCTL_GET_DRIVE_GEOMETRY_EX : if ( ValidateIOBufferSize ( Irp , sizeof ( DISK_GEOMETRY_EX_STRUCT ) , ValidateInputOutput ) ) { DISK_GEOMETRY_EX_STRUCT * g = ( DISK_GEOMETRY_EX_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; { NTSTATUS ntStatus ; PVOID buffer = TCalloc ( 256 ) ; if ( buffer ) { EnsureNullTerminatedString ( g -> deviceName , sizeof ( g -> deviceName ) ) ; Dump ( ""Calling<S2SV_blank>IOCTL_DISK_GET_DRIVE_GEOMETRY_EX<S2SV_blank>on<S2SV_blank>%ls\\n"" , g -> deviceName ) ; ntStatus = TCDeviceIoControl ( g -> deviceName , IOCTL_DISK_GET_DRIVE_GEOMETRY_EX , NULL , 0 , buffer , 256 ) ; if ( NT_SUCCESS ( ntStatus ) ) { PDISK_GEOMETRY_EX pGeo = ( PDISK_GEOMETRY_EX ) buffer ; memcpy ( & g -> diskGeometry , & pGeo -> Geometry , sizeof ( DISK_GEOMETRY ) ) ; g -> DiskSize . QuadPart = pGeo -> DiskSize . QuadPart ; } else { DISK_GEOMETRY dg = { 0 } ; Dump ( ""Failed.<S2SV_blank>Calling<S2SV_blank>IOCTL_DISK_GET_DRIVE_GEOMETRY<S2SV_blank>on<S2SV_blank>%ls\\n"" , g -> deviceName ) ; ntStatus = TCDeviceIoControl ( g -> deviceName , IOCTL_DISK_GET_DRIVE_GEOMETRY , NULL , 0 , & dg , sizeof ( dg ) ) ; if ( NT_SUCCESS ( ntStatus ) ) { memcpy ( & g -> diskGeometry , & dg , sizeof ( DISK_GEOMETRY ) ) ; g -> DiskSize . QuadPart = dg . Cylinders . QuadPart * dg . SectorsPerTrack * dg . TracksPerCylinder * dg . BytesPerSector ; if ( OsMajorVersion >= 6 ) { STORAGE_READ_CAPACITY storage = { 0 } ; NTSTATUS lStatus ; storage . Version = sizeof ( STORAGE_READ_CAPACITY ) ; Dump ( ""Calling<S2SV_blank>IOCTL_STORAGE_READ_CAPACITY<S2SV_blank>on<S2SV_blank>%ls\\n"" , g -> deviceName ) ; lStatus = TCDeviceIoControl ( g -> deviceName , IOCTL_STORAGE_READ_CAPACITY , NULL , 0 , & storage , sizeof ( STORAGE_READ_CAPACITY ) ) ; if ( NT_SUCCESS ( lStatus ) && ( storage . Size == sizeof ( STORAGE_READ_CAPACITY ) ) ) { g -> DiskSize . QuadPart = storage . DiskLength . QuadPart ; } } } } TCfree ( buffer ) ; Irp -> IoStatus . Information = sizeof ( DISK_GEOMETRY_EX_STRUCT ) ; Irp -> IoStatus . Status = ntStatus ; } else { Irp -> IoStatus . Status = STATUS_INSUFFICIENT_RESOURCES ; Irp -> IoStatus . Information = 0 ; } } } break ; case TC_IOCTL_PROBE_REAL_DRIVE_SIZE : if ( ValidateIOBufferSize ( Irp , sizeof ( ProbeRealDriveSizeRequest ) , ValidateInputOutput ) ) { ProbeRealDriveSizeRequest * request = ( ProbeRealDriveSizeRequest * ) Irp -> AssociatedIrp . SystemBuffer ; NTSTATUS status ; UNICODE_STRING name ; PFILE_OBJECT fileObject ; PDEVICE_OBJECT deviceObject ; EnsureNullTerminatedString ( request -> DeviceName , sizeof ( request -> DeviceName ) ) ; RtlInitUnicodeString ( & name , request -> DeviceName ) ; status = IoGetDeviceObjectPointer ( & name , FILE_READ_ATTRIBUTES , & fileObject , & deviceObject ) ; if ( ! NT_SUCCESS ( status ) ) { Irp -> IoStatus . Information = 0 ; Irp -> IoStatus . Status = status ; break ; } status = ProbeRealDriveSize ( deviceObject , & request -> RealDriveSize ) ; ObDereferenceObject ( fileObject ) ; if ( status == STATUS_TIMEOUT ) { request -> TimeOut = TRUE ; Irp -> IoStatus . Information = sizeof ( ProbeRealDriveSizeRequest ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } else if ( ! NT_SUCCESS ( status ) ) { Irp -> IoStatus . Information = 0 ; Irp -> IoStatus . Status = status ; } else { request -> TimeOut = FALSE ; Irp -> IoStatus . Information = sizeof ( ProbeRealDriveSizeRequest ) ; Irp -> IoStatus . Status = status ; } } break ; case TC_IOCTL_MOUNT_VOLUME : if ( ValidateIOBufferSize ( Irp , sizeof ( MOUNT_STRUCT ) , ValidateInputOutput ) ) { MOUNT_STRUCT * mount = ( MOUNT_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; if ( mount -> VolumePassword . Length > MAX_PASSWORD || mount -> ProtectedHidVolPassword . Length > MAX_PASSWORD || mount -> pkcs5_prf < 0 || mount -> pkcs5_prf > LAST_PRF_ID || mount -> VolumePim < - 1 || mount -> VolumePim == INT_MAX || mount -> ProtectedHidVolPkcs5Prf < 0 || mount -> ProtectedHidVolPkcs5Prf > LAST_PRF_ID || ( mount -> bTrueCryptMode != FALSE && mount -> bTrueCryptMode != TRUE ) ) { Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; break ; } EnsureNullTerminatedString ( mount -> wszVolume , sizeof ( mount -> wszVolume ) ) ; EnsureNullTerminatedString ( mount -> wszLabel , sizeof ( mount -> wszLabel ) ) ; Irp -> IoStatus . Information = sizeof ( MOUNT_STRUCT ) ; Irp -> IoStatus . Status = MountDevice ( DeviceObject , mount ) ; burn ( & mount -> VolumePassword , sizeof ( mount -> VolumePassword ) ) ; burn ( & mount -> ProtectedHidVolPassword , sizeof ( mount -> ProtectedHidVolPassword ) ) ; burn ( & mount -> pkcs5_prf , sizeof ( mount -> pkcs5_prf ) ) ; burn ( & mount -> VolumePim , sizeof ( mount -> VolumePim ) ) ; burn ( & mount -> bTrueCryptMode , sizeof ( mount -> bTrueCryptMode ) ) ; burn ( & mount -> ProtectedHidVolPkcs5Prf , sizeof ( mount -> ProtectedHidVolPkcs5Prf ) ) ; burn ( & mount -> ProtectedHidVolPim , sizeof ( mount -> ProtectedHidVolPim ) ) ; } break ; case TC_IOCTL_DISMOUNT_VOLUME : if ( ValidateIOBufferSize ( Irp , sizeof ( UNMOUNT_STRUCT ) , ValidateInputOutput ) ) { UNMOUNT_STRUCT * unmount = ( UNMOUNT_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; PDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject ( unmount -> nDosDriveNo ) ; unmount -> nReturnCode = ERR_DRIVE_NOT_FOUND ; if ( ListDevice ) { PEXTENSION ListExtension = ( PEXTENSION ) ListDevice -> DeviceExtension ; if ( IsVolumeAccessibleByCurrentUser ( ListExtension ) ) unmount -> nReturnCode = UnmountDevice ( unmount , ListDevice , unmount -> ignoreOpenFiles ) ; } Irp -> IoStatus . Information = sizeof ( UNMOUNT_STRUCT ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_DISMOUNT_ALL_VOLUMES : if ( ValidateIOBufferSize ( Irp , sizeof ( UNMOUNT_STRUCT ) , ValidateInputOutput ) ) { UNMOUNT_STRUCT * unmount = ( UNMOUNT_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; unmount -> nReturnCode = UnmountAllDevices ( unmount , unmount -> ignoreOpenFiles ) ; Irp -> IoStatus . Information = sizeof ( UNMOUNT_STRUCT ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_BOOT_ENCRYPTION_SETUP : Irp -> IoStatus . Status = StartBootEncryptionSetup ( DeviceObject , Irp , irpSp ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_ABORT_BOOT_ENCRYPTION_SETUP : Irp -> IoStatus . Status = AbortBootEncryptionSetup ( ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS : GetBootEncryptionStatus ( Irp , irpSp ) ; break ; case TC_IOCTL_GET_BOOT_ENCRYPTION_SETUP_RESULT : Irp -> IoStatus . Information = 0 ; Irp -> IoStatus . Status = GetSetupResult ( ) ; break ; case TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES : GetBootDriveVolumeProperties ( Irp , irpSp ) ; break ; case TC_IOCTL_GET_BOOT_LOADER_VERSION : GetBootLoaderVersion ( Irp , irpSp ) ; break ; case TC_IOCTL_REOPEN_BOOT_VOLUME_HEADER : ReopenBootVolumeHeader ( Irp , irpSp ) ; break ; case VC_IOCTL_GET_BOOT_LOADER_FINGERPRINT : GetBootLoaderFingerprint ( Irp , irpSp ) ; break ; case TC_IOCTL_GET_BOOT_ENCRYPTION_ALGORITHM_NAME : GetBootEncryptionAlgorithmName ( Irp , irpSp ) ; break ; case TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { * ( int * ) Irp -> AssociatedIrp . SystemBuffer = IsHiddenSystemRunning ( ) ? 1 : 0 ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_START_DECOY_SYSTEM_WIPE : Irp -> IoStatus . Status = StartDecoySystemWipe ( DeviceObject , Irp , irpSp ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_ABORT_DECOY_SYSTEM_WIPE : Irp -> IoStatus . Status = AbortDecoySystemWipe ( ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_DECOY_SYSTEM_WIPE_RESULT : Irp -> IoStatus . Status = GetDecoySystemWipeResult ( ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_DECOY_SYSTEM_WIPE_STATUS : GetDecoySystemWipeStatus ( Irp , irpSp ) ; break ; case TC_IOCTL_WRITE_BOOT_DRIVE_SECTOR : Irp -> IoStatus . Status = WriteBootDriveSector ( Irp , irpSp ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_WARNING_FLAGS : if ( ValidateIOBufferSize ( Irp , sizeof ( GetWarningFlagsRequest ) , ValidateOutput ) ) { GetWarningFlagsRequest * flags = ( GetWarningFlagsRequest * ) Irp -> AssociatedIrp . SystemBuffer ; flags -> PagingFileCreationPrevented = PagingFileCreationPrevented ; PagingFileCreationPrevented = FALSE ; flags -> SystemFavoriteVolumeDirty = SystemFavoriteVolumeDirty ; SystemFavoriteVolumeDirty = FALSE ; Irp -> IoStatus . Information = sizeof ( GetWarningFlagsRequest ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_SET_SYSTEM_FAVORITE_VOLUME_DIRTY : if ( UserCanAccessDriveDevice ( ) ) { SystemFavoriteVolumeDirty = TRUE ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } else Irp -> IoStatus . Status = STATUS_ACCESS_DENIED ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_REREAD_DRIVER_CONFIG : Irp -> IoStatus . Status = ReadRegistryConfigFlags ( FALSE ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_SYSTEM_DRIVE_DUMP_CONFIG : if ( ( ValidateIOBufferSize ( Irp , sizeof ( GetSystemDriveDumpConfigRequest ) , ValidateOutput ) ) && ( Irp -> RequestorMode == KernelMode ) ) { GetSystemDriveDumpConfigRequest * request = ( GetSystemDriveDumpConfigRequest * ) Irp -> AssociatedIrp . SystemBuffer ; request -> BootDriveFilterExtension = GetBootDriveFilterExtension ( ) ; if ( IsBootDriveMounted ( ) && request -> BootDriveFilterExtension ) { request -> HwEncryptionEnabled = IsHwEncryptionEnabled ( ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = sizeof ( * request ) ; } else { Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; } } break ; default : return TCCompleteIrp ( Irp , STATUS_INVALID_DEVICE_REQUEST , 0 ) ; } # if defined ( DEBUG ) || defined ( DEBUG_TRACE ) if ( ! NT_SUCCESS ( Irp -> IoStatus . Status ) ) { switch ( irpSp -> Parameters . DeviceIoControl . IoControlCode ) { case TC_IOCTL_GET_MOUNTED_VOLUMES : case TC_IOCTL_GET_PASSWORD_CACHE_STATUS : case TC_IOCTL_GET_PORTABLE_MODE_STATUS : case TC_IOCTL_SET_PORTABLE_MODE_STATUS : case TC_IOCTL_OPEN_TEST : case TC_IOCTL_GET_RESOLVED_SYMLINK : case TC_IOCTL_GET_DRIVE_PARTITION_INFO : case TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES : case TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS : case TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING : break ; default : Dump ( ""IOCTL<S2SV_blank>error<S2SV_blank>0x%08x\\n"" , Irp -> IoStatus . Status ) ; } } # endif return TCCompleteIrp ( Irp , Irp -> IoStatus . Status , Irp -> IoStatus . Information ) ; }","byte readBuffer [ TC_SECTOR_SIZE_BIOS ] ;if ( ! ValidateIOBufferSize ( Irp , sizeof ( GetSystemDriveConfigurationRequest ) , ValidateInputOutput ) ) break ;EnsureNullTerminatedString ( request -> DevicePath , sizeof ( request -> DevicePath ) ) ;offset . QuadPart = 0 ;ntStatus = ZwReadFile ( NtFileHandle , NULL , NULL , NULL , & IoStatus , readBuffer , sizeof ( readBuffer ) , & offset , NULL ) ;if ( NT_SUCCESS ( ntStatus ) ) {",590
804,"buggy line: Irp -> IoStatus . Status = ntStatus ;Irp -> IoStatus . Information = 0 ;}cwe id:CWE-119context: NTSTATUS ProcessMainDeviceControlIrp ( PDEVICE_OBJECT DeviceObject , PEXTENSION Extension , PIRP Irp ) { PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation ( Irp ) ; NTSTATUS ntStatus ; switch ( irpSp -> Parameters . DeviceIoControl . IoControlCode ) { case TC_IOCTL_GET_DRIVER_VERSION : case TC_IOCTL_LEGACY_GET_DRIVER_VERSION : if ( ValidateIOBufferSize ( Irp , sizeof ( LONG ) , ValidateOutput ) ) { LONG tmp = VERSION_NUM ; memcpy ( Irp -> AssociatedIrp . SystemBuffer , & tmp , 4 ) ; Irp -> IoStatus . Information = sizeof ( LONG ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_GET_DEVICE_REFCOUNT : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { * ( int * ) Irp -> AssociatedIrp . SystemBuffer = DeviceObject -> ReferenceCount ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_IS_DRIVER_UNLOAD_DISABLED : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { LONG deviceObjectCount = 0 ; * ( int * ) Irp -> AssociatedIrp . SystemBuffer = DriverUnloadDisabled ; if ( IoEnumerateDeviceObjectList ( TCDriverObject , NULL , 0 , & deviceObjectCount ) == STATUS_BUFFER_TOO_SMALL && deviceObjectCount > 1 ) * ( int * ) Irp -> AssociatedIrp . SystemBuffer = TRUE ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_IS_ANY_VOLUME_MOUNTED : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { int drive ; * ( int * ) Irp -> AssociatedIrp . SystemBuffer = 0 ; for ( drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER ; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER ; ++ drive ) { if ( GetVirtualVolumeDeviceObject ( drive ) ) { * ( int * ) Irp -> AssociatedIrp . SystemBuffer = 1 ; break ; } } if ( IsBootDriveMounted ( ) ) * ( int * ) Irp -> AssociatedIrp . SystemBuffer = 1 ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_OPEN_TEST : { OPEN_TEST_STRUCT * opentest = ( OPEN_TEST_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; OBJECT_ATTRIBUTES ObjectAttributes ; HANDLE NtFileHandle ; UNICODE_STRING FullFileName ; IO_STATUS_BLOCK IoStatus ; LARGE_INTEGER offset ; ACCESS_MASK access = FILE_READ_ATTRIBUTES ; if ( ! ValidateIOBufferSize ( Irp , sizeof ( OPEN_TEST_STRUCT ) , ValidateInputOutput ) ) break ; EnsureNullTerminatedString ( opentest -> wszFileName , sizeof ( opentest -> wszFileName ) ) ; RtlInitUnicodeString ( & FullFileName , opentest -> wszFileName ) ; InitializeObjectAttributes ( & ObjectAttributes , & FullFileName , OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE , NULL , NULL ) ; if ( opentest -> bDetectTCBootLoader || opentest -> DetectFilesystem || opentest -> bComputeVolumeIDs ) access |= FILE_READ_DATA ; ntStatus = ZwCreateFile ( & NtFileHandle , SYNCHRONIZE | access , & ObjectAttributes , & IoStatus , NULL , 0 , FILE_SHARE_READ | FILE_SHARE_WRITE , FILE_OPEN , FILE_SYNCHRONOUS_IO_NONALERT , NULL , 0 ) ; if ( NT_SUCCESS ( ntStatus ) ) { opentest -> TCBootLoaderDetected = FALSE ; opentest -> FilesystemDetected = FALSE ; memset ( opentest -> VolumeIDComputed , 0 , sizeof ( opentest -> VolumeIDComputed ) ) ; memset ( opentest -> volumeIDs , 0 , sizeof ( opentest -> volumeIDs ) ) ; if ( opentest -> bDetectTCBootLoader || opentest -> DetectFilesystem || opentest -> bComputeVolumeIDs ) { byte * readBuffer = TCalloc ( TC_MAX_VOLUME_SECTOR_SIZE ) ; if ( ! readBuffer ) { ntStatus = STATUS_INSUFFICIENT_RESOURCES ; } else { if ( opentest -> bDetectTCBootLoader || opentest -> DetectFilesystem ) { offset . QuadPart = 0 ; ntStatus = ZwReadFile ( NtFileHandle , NULL , NULL , NULL , & IoStatus , readBuffer , TC_MAX_VOLUME_SECTOR_SIZE , & offset , NULL ) ; if ( NT_SUCCESS ( ntStatus ) ) { size_t i ; if ( opentest -> bDetectTCBootLoader && IoStatus . Information >= TC_SECTOR_SIZE_BIOS ) { for ( i = 0 ; i < TC_SECTOR_SIZE_BIOS - strlen ( TC_APP_NAME ) ; ++ i ) { if ( memcmp ( readBuffer + i , TC_APP_NAME , strlen ( TC_APP_NAME ) ) == 0 ) { opentest -> TCBootLoaderDetected = TRUE ; break ; } } } if ( opentest -> DetectFilesystem && IoStatus . Information >= sizeof ( int64 ) ) { switch ( BE64 ( * ( uint64 * ) readBuffer ) ) { case 0xEB52904E54465320ULL : case 0xEB3C904D53444F53ULL : case 0xEB58904D53444F53ULL : case 0xEB76904558464154ULL : case 0x0000005265465300ULL : case 0xEB58906D6B66732EULL : case 0xEB58906D6B646F73ULL : case 0xEB3C906D6B66732EULL : case 0xEB3C906D6B646F73ULL : opentest -> FilesystemDetected = TRUE ; break ; case 0x0000000000000000ULL : if ( IsAllZeroes ( readBuffer + 8 , TC_VOLUME_HEADER_EFFECTIVE_SIZE - 8 ) ) opentest -> FilesystemDetected = TRUE ; break ; } } } } if ( opentest -> bComputeVolumeIDs && ( ! opentest -> DetectFilesystem || ! opentest -> FilesystemDetected ) ) { int volumeType ; for ( volumeType = TC_VOLUME_TYPE_NORMAL ; volumeType < TC_VOLUME_TYPE_COUNT ; volumeType ++ ) { switch ( volumeType ) { case TC_VOLUME_TYPE_NORMAL : offset . QuadPart = TC_VOLUME_HEADER_OFFSET ; break ; case TC_VOLUME_TYPE_HIDDEN : offset . QuadPart = TC_HIDDEN_VOLUME_HEADER_OFFSET ; break ; } ntStatus = ZwReadFile ( NtFileHandle , NULL , NULL , NULL , & IoStatus , readBuffer , TC_MAX_VOLUME_SECTOR_SIZE , & offset , NULL ) ; if ( NT_SUCCESS ( ntStatus ) ) { sha256 ( opentest -> volumeIDs [ volumeType ] , readBuffer , TC_VOLUME_HEADER_EFFECTIVE_SIZE ) ; opentest -> VolumeIDComputed [ volumeType ] = TRUE ; } } } TCfree ( readBuffer ) ; } } ZwClose ( NtFileHandle ) ; Dump ( ""Open<S2SV_blank>test<S2SV_blank>on<S2SV_blank>file<S2SV_blank>%ls<S2SV_blank>success.\\n"" , opentest -> wszFileName ) ; } else { # if 0 Dump ( ""Open<S2SV_blank>test<S2SV_blank>on<S2SV_blank>file<S2SV_blank>%ls<S2SV_blank>failed<S2SV_blank>NTSTATUS<S2SV_blank>0x%08x\\n"" , opentest -> wszFileName , ntStatus ) ; # endif } Irp -> IoStatus . Information = NT_SUCCESS ( ntStatus ) ? sizeof ( OPEN_TEST_STRUCT ) : 0 ; Irp -> IoStatus . Status = ntStatus ; } break ; case TC_IOCTL_GET_SYSTEM_DRIVE_CONFIG : { GetSystemDriveConfigurationRequest * request = ( GetSystemDriveConfigurationRequest * ) Irp -> AssociatedIrp . SystemBuffer ; OBJECT_ATTRIBUTES ObjectAttributes ; HANDLE NtFileHandle ; UNICODE_STRING FullFileName ; IO_STATUS_BLOCK IoStatus ; LARGE_INTEGER offset ;  byte readBuffer [ TC_SECTOR_SIZE_BIOS ] ;  if ( ! ValidateIOBufferSize ( Irp , sizeof ( GetSystemDriveConfigurationRequest ) , ValidateInputOutput ) )  break ;  EnsureNullTerminatedString ( request -> DevicePath , sizeof ( request -> DevicePath ) ) ; RtlInitUnicodeString ( & FullFileName , request -> DevicePath ) ; InitializeObjectAttributes ( & ObjectAttributes , & FullFileName , OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE , NULL , NULL ) ; ntStatus = ZwCreateFile ( & NtFileHandle , SYNCHRONIZE | GENERIC_READ , & ObjectAttributes , & IoStatus , NULL , FILE_ATTRIBUTE_NORMAL , FILE_SHARE_READ | FILE_SHARE_WRITE , FILE_OPEN , FILE_SYNCHRONOUS_IO_NONALERT | FILE_RANDOM_ACCESS , NULL , 0 ) ; if ( NT_SUCCESS ( ntStatus ) ) {  offset . QuadPart = 0 ;  ntStatus = ZwReadFile ( NtFileHandle , NULL , NULL , NULL , & IoStatus , readBuffer ,  sizeof ( readBuffer ) ,  & offset , NULL ) ;  if ( NT_SUCCESS ( ntStatus ) )  { size_t i ; request -> DriveIsDynamic = FALSE ; if ( readBuffer [ 510 ] == 0x55 && readBuffer [ 511 ] == 0xaa ) { int i ; for ( i = 0 ; i < 4 ; ++ i ) { if ( readBuffer [ 446 + i * 16 + 4 ] == PARTITION_LDM ) { request -> DriveIsDynamic = TRUE ; break ; } } } request -> BootLoaderVersion = 0 ; request -> Configuration = 0 ; request -> UserConfiguration = 0 ; request -> CustomUserMessage [ 0 ] = 0 ; for ( i = 0 ; i < sizeof ( readBuffer ) - strlen ( TC_APP_NAME ) ; ++ i ) { if ( memcmp ( readBuffer + i , TC_APP_NAME , strlen ( TC_APP_NAME ) ) == 0 ) { request -> BootLoaderVersion = BE16 ( * ( uint16 * ) ( readBuffer + TC_BOOT_SECTOR_VERSION_OFFSET ) ) ; request -> Configuration = readBuffer [ TC_BOOT_SECTOR_CONFIG_OFFSET ] ; if ( request -> BootLoaderVersion != 0 && request -> BootLoaderVersion <= VERSION_NUM ) { request -> UserConfiguration = readBuffer [ TC_BOOT_SECTOR_USER_CONFIG_OFFSET ] ; memcpy ( request -> CustomUserMessage , readBuffer + TC_BOOT_SECTOR_USER_MESSAGE_OFFSET , TC_BOOT_SECTOR_USER_MESSAGE_MAX_LENGTH ) ; } break ; } } Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = sizeof ( * request ) ; } else {  Irp -> IoStatus . Status = ntStatus ;   Irp -> IoStatus . Information = 0 ;  } ZwClose ( NtFileHandle ) ; } else { Irp -> IoStatus . Status = ntStatus ; Irp -> IoStatus . Information = 0 ; } } break ; case TC_IOCTL_WIPE_PASSWORD_CACHE : WipeCache ( ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_PASSWORD_CACHE_STATUS : Irp -> IoStatus . Status = cacheEmpty ? STATUS_PIPE_EMPTY : STATUS_SUCCESS ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_SET_PORTABLE_MODE_STATUS : if ( ! UserCanAccessDriveDevice ( ) ) { Irp -> IoStatus . Status = STATUS_ACCESS_DENIED ; Irp -> IoStatus . Information = 0 ; } else { PortableMode = TRUE ; Dump ( ""Setting<S2SV_blank>portable<S2SV_blank>mode\\n"" ) ; } break ; case TC_IOCTL_GET_PORTABLE_MODE_STATUS : Irp -> IoStatus . Status = PortableMode ? STATUS_SUCCESS : STATUS_PIPE_EMPTY ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_MOUNTED_VOLUMES : if ( ValidateIOBufferSize ( Irp , sizeof ( MOUNT_LIST_STRUCT ) , ValidateOutput ) ) { MOUNT_LIST_STRUCT * list = ( MOUNT_LIST_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; PDEVICE_OBJECT ListDevice ; int drive ; list -> ulMountedDrives = 0 ; for ( drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER ; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER ; ++ drive ) { PEXTENSION ListExtension ; ListDevice = GetVirtualVolumeDeviceObject ( drive ) ; if ( ! ListDevice ) continue ; ListExtension = ( PEXTENSION ) ListDevice -> DeviceExtension ; if ( IsVolumeAccessibleByCurrentUser ( ListExtension ) ) { list -> ulMountedDrives |= ( 1 << ListExtension -> nDosDriveNo ) ; RtlStringCbCopyW ( list -> wszVolume [ ListExtension -> nDosDriveNo ] , sizeof ( list -> wszVolume [ ListExtension -> nDosDriveNo ] ) , ListExtension -> wszVolume ) ; RtlStringCbCopyW ( list -> wszLabel [ ListExtension -> nDosDriveNo ] , sizeof ( list -> wszLabel [ ListExtension -> nDosDriveNo ] ) , ListExtension -> wszLabel ) ; memcpy ( list -> volumeID [ ListExtension -> nDosDriveNo ] , ListExtension -> volumeID , VOLUME_ID_SIZE ) ; list -> diskLength [ ListExtension -> nDosDriveNo ] = ListExtension -> DiskLength ; list -> ea [ ListExtension -> nDosDriveNo ] = ListExtension -> cryptoInfo -> ea ; if ( ListExtension -> cryptoInfo -> hiddenVolume ) list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_HIDDEN ; else if ( ListExtension -> cryptoInfo -> bHiddenVolProtectionAction ) list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_OUTER_VOL_WRITE_PREVENTED ; else if ( ListExtension -> cryptoInfo -> bProtectHiddenVolume ) list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_OUTER ; else list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_NORMAL ; list -> truecryptMode [ ListExtension -> nDosDriveNo ] = ListExtension -> cryptoInfo -> bTrueCryptMode ; } } Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = sizeof ( MOUNT_LIST_STRUCT ) ; } break ; case TC_IOCTL_LEGACY_GET_MOUNTED_VOLUMES : if ( ValidateIOBufferSize ( Irp , sizeof ( uint32 ) , ValidateOutput ) ) { memset ( Irp -> AssociatedIrp . SystemBuffer , 0 , irpSp -> Parameters . DeviceIoControl . OutputBufferLength ) ; * ( uint32 * ) Irp -> AssociatedIrp . SystemBuffer = 0xffffFFFF ; Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = irpSp -> Parameters . DeviceIoControl . OutputBufferLength ; } break ; case TC_IOCTL_GET_VOLUME_PROPERTIES : if ( ValidateIOBufferSize ( Irp , sizeof ( VOLUME_PROPERTIES_STRUCT ) , ValidateInputOutput ) ) { VOLUME_PROPERTIES_STRUCT * prop = ( VOLUME_PROPERTIES_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; PDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject ( prop -> driveNo ) ; Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; if ( ListDevice ) { PEXTENSION ListExtension = ( PEXTENSION ) ListDevice -> DeviceExtension ; if ( IsVolumeAccessibleByCurrentUser ( ListExtension ) ) { prop -> uniqueId = ListExtension -> UniqueVolumeId ; RtlStringCbCopyW ( prop -> wszVolume , sizeof ( prop -> wszVolume ) , ListExtension -> wszVolume ) ; RtlStringCbCopyW ( prop -> wszLabel , sizeof ( prop -> wszLabel ) , ListExtension -> wszLabel ) ; memcpy ( prop -> volumeID , ListExtension -> volumeID , VOLUME_ID_SIZE ) ; prop -> bDriverSetLabel = ListExtension -> bDriverSetLabel ; prop -> diskLength = ListExtension -> DiskLength ; prop -> ea = ListExtension -> cryptoInfo -> ea ; prop -> mode = ListExtension -> cryptoInfo -> mode ; prop -> pkcs5 = ListExtension -> cryptoInfo -> pkcs5 ; prop -> pkcs5Iterations = ListExtension -> cryptoInfo -> noIterations ; prop -> volumePim = ListExtension -> cryptoInfo -> volumePim ; # if 0 prop -> volumeCreationTime = ListExtension -> cryptoInfo -> volume_creation_time ; prop -> headerCreationTime = ListExtension -> cryptoInfo -> header_creation_time ; # endif prop -> volumeHeaderFlags = ListExtension -> cryptoInfo -> HeaderFlags ; prop -> readOnly = ListExtension -> bReadOnly ; prop -> removable = ListExtension -> bRemovable ; prop -> partitionInInactiveSysEncScope = ListExtension -> PartitionInInactiveSysEncScope ; prop -> hiddenVolume = ListExtension -> cryptoInfo -> hiddenVolume ; if ( ListExtension -> cryptoInfo -> bProtectHiddenVolume ) prop -> hiddenVolProtection = ListExtension -> cryptoInfo -> bHiddenVolProtectionAction ? HIDVOL_PROT_STATUS_ACTION_TAKEN : HIDVOL_PROT_STATUS_ACTIVE ; else prop -> hiddenVolProtection = HIDVOL_PROT_STATUS_NONE ; prop -> totalBytesRead = ListExtension -> Queue . TotalBytesRead ; prop -> totalBytesWritten = ListExtension -> Queue . TotalBytesWritten ; prop -> volFormatVersion = ListExtension -> cryptoInfo -> LegacyVolume ? TC_VOLUME_FORMAT_VERSION_PRE_6_0 : TC_VOLUME_FORMAT_VERSION ; Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = sizeof ( VOLUME_PROPERTIES_STRUCT ) ; } } } break ; case TC_IOCTL_GET_RESOLVED_SYMLINK : if ( ValidateIOBufferSize ( Irp , sizeof ( RESOLVE_SYMLINK_STRUCT ) , ValidateInputOutput ) ) { RESOLVE_SYMLINK_STRUCT * resolve = ( RESOLVE_SYMLINK_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; { NTSTATUS ntStatus ; EnsureNullTerminatedString ( resolve -> symLinkName , sizeof ( resolve -> symLinkName ) ) ; ntStatus = SymbolicLinkToTarget ( resolve -> symLinkName , resolve -> targetName , sizeof ( resolve -> targetName ) ) ; Irp -> IoStatus . Information = sizeof ( RESOLVE_SYMLINK_STRUCT ) ; Irp -> IoStatus . Status = ntStatus ; } } break ; case TC_IOCTL_GET_DRIVE_PARTITION_INFO : if ( ValidateIOBufferSize ( Irp , sizeof ( DISK_PARTITION_INFO_STRUCT ) , ValidateInputOutput ) ) { DISK_PARTITION_INFO_STRUCT * info = ( DISK_PARTITION_INFO_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; { PARTITION_INFORMATION_EX pi ; NTSTATUS ntStatus ; EnsureNullTerminatedString ( info -> deviceName , sizeof ( info -> deviceName ) ) ; ntStatus = TCDeviceIoControl ( info -> deviceName , IOCTL_DISK_GET_PARTITION_INFO_EX , NULL , 0 , & pi , sizeof ( pi ) ) ; if ( NT_SUCCESS ( ntStatus ) ) { memset ( & info -> partInfo , 0 , sizeof ( info -> partInfo ) ) ; info -> partInfo . PartitionLength = pi . PartitionLength ; info -> partInfo . PartitionNumber = pi . PartitionNumber ; info -> partInfo . StartingOffset = pi . StartingOffset ; if ( pi . PartitionStyle == PARTITION_STYLE_MBR ) { info -> partInfo . PartitionType = pi . Mbr . PartitionType ; info -> partInfo . BootIndicator = pi . Mbr . BootIndicator ; } info -> IsGPT = pi . PartitionStyle == PARTITION_STYLE_GPT ; } else { ntStatus = TCDeviceIoControl ( info -> deviceName , IOCTL_DISK_GET_PARTITION_INFO , NULL , 0 , & info -> partInfo , sizeof ( info -> partInfo ) ) ; info -> IsGPT = FALSE ; } if ( ! NT_SUCCESS ( ntStatus ) ) { GET_LENGTH_INFORMATION lengthInfo ; ntStatus = TCDeviceIoControl ( info -> deviceName , IOCTL_DISK_GET_LENGTH_INFO , NULL , 0 , & lengthInfo , sizeof ( lengthInfo ) ) ; if ( NT_SUCCESS ( ntStatus ) ) { memset ( & info -> partInfo , 0 , sizeof ( info -> partInfo ) ) ; info -> partInfo . PartitionLength = lengthInfo . Length ; } } info -> IsDynamic = FALSE ; if ( NT_SUCCESS ( ntStatus ) && OsMajorVersion >= 6 ) { # define IOCTL_VOLUME_IS_DYNAMIC CTL_CODE ( IOCTL_VOLUME_BASE , 18 , METHOD_BUFFERED , FILE_ANY_ACCESS ) if ( ! NT_SUCCESS ( TCDeviceIoControl ( info -> deviceName , IOCTL_VOLUME_IS_DYNAMIC , NULL , 0 , & info -> IsDynamic , sizeof ( info -> IsDynamic ) ) ) ) info -> IsDynamic = FALSE ; } Irp -> IoStatus . Information = sizeof ( DISK_PARTITION_INFO_STRUCT ) ; Irp -> IoStatus . Status = ntStatus ; } } break ; case TC_IOCTL_GET_DRIVE_GEOMETRY : if ( ValidateIOBufferSize ( Irp , sizeof ( DISK_GEOMETRY_STRUCT ) , ValidateInputOutput ) ) { DISK_GEOMETRY_STRUCT * g = ( DISK_GEOMETRY_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; { NTSTATUS ntStatus ; EnsureNullTerminatedString ( g -> deviceName , sizeof ( g -> deviceName ) ) ; Dump ( ""Calling<S2SV_blank>IOCTL_DISK_GET_DRIVE_GEOMETRY<S2SV_blank>on<S2SV_blank>%ls\\n"" , g -> deviceName ) ; ntStatus = TCDeviceIoControl ( g -> deviceName , IOCTL_DISK_GET_DRIVE_GEOMETRY , NULL , 0 , & g -> diskGeometry , sizeof ( g -> diskGeometry ) ) ; Irp -> IoStatus . Information = sizeof ( DISK_GEOMETRY_STRUCT ) ; Irp -> IoStatus . Status = ntStatus ; } } break ; case VC_IOCTL_GET_DRIVE_GEOMETRY_EX : if ( ValidateIOBufferSize ( Irp , sizeof ( DISK_GEOMETRY_EX_STRUCT ) , ValidateInputOutput ) ) { DISK_GEOMETRY_EX_STRUCT * g = ( DISK_GEOMETRY_EX_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; { NTSTATUS ntStatus ; PVOID buffer = TCalloc ( 256 ) ; if ( buffer ) { EnsureNullTerminatedString ( g -> deviceName , sizeof ( g -> deviceName ) ) ; Dump ( ""Calling<S2SV_blank>IOCTL_DISK_GET_DRIVE_GEOMETRY_EX<S2SV_blank>on<S2SV_blank>%ls\\n"" , g -> deviceName ) ; ntStatus = TCDeviceIoControl ( g -> deviceName , IOCTL_DISK_GET_DRIVE_GEOMETRY_EX , NULL , 0 , buffer , 256 ) ; if ( NT_SUCCESS ( ntStatus ) ) { PDISK_GEOMETRY_EX pGeo = ( PDISK_GEOMETRY_EX ) buffer ; memcpy ( & g -> diskGeometry , & pGeo -> Geometry , sizeof ( DISK_GEOMETRY ) ) ; g -> DiskSize . QuadPart = pGeo -> DiskSize . QuadPart ; } else { DISK_GEOMETRY dg = { 0 } ; Dump ( ""Failed.<S2SV_blank>Calling<S2SV_blank>IOCTL_DISK_GET_DRIVE_GEOMETRY<S2SV_blank>on<S2SV_blank>%ls\\n"" , g -> deviceName ) ; ntStatus = TCDeviceIoControl ( g -> deviceName , IOCTL_DISK_GET_DRIVE_GEOMETRY , NULL , 0 , & dg , sizeof ( dg ) ) ; if ( NT_SUCCESS ( ntStatus ) ) { memcpy ( & g -> diskGeometry , & dg , sizeof ( DISK_GEOMETRY ) ) ; g -> DiskSize . QuadPart = dg . Cylinders . QuadPart * dg . SectorsPerTrack * dg . TracksPerCylinder * dg . BytesPerSector ; if ( OsMajorVersion >= 6 ) { STORAGE_READ_CAPACITY storage = { 0 } ; NTSTATUS lStatus ; storage . Version = sizeof ( STORAGE_READ_CAPACITY ) ; Dump ( ""Calling<S2SV_blank>IOCTL_STORAGE_READ_CAPACITY<S2SV_blank>on<S2SV_blank>%ls\\n"" , g -> deviceName ) ; lStatus = TCDeviceIoControl ( g -> deviceName , IOCTL_STORAGE_READ_CAPACITY , NULL , 0 , & storage , sizeof ( STORAGE_READ_CAPACITY ) ) ; if ( NT_SUCCESS ( lStatus ) && ( storage . Size == sizeof ( STORAGE_READ_CAPACITY ) ) ) { g -> DiskSize . QuadPart = storage . DiskLength . QuadPart ; } } } } TCfree ( buffer ) ; Irp -> IoStatus . Information = sizeof ( DISK_GEOMETRY_EX_STRUCT ) ; Irp -> IoStatus . Status = ntStatus ; } else { Irp -> IoStatus . Status = STATUS_INSUFFICIENT_RESOURCES ; Irp -> IoStatus . Information = 0 ; } } } break ; case TC_IOCTL_PROBE_REAL_DRIVE_SIZE : if ( ValidateIOBufferSize ( Irp , sizeof ( ProbeRealDriveSizeRequest ) , ValidateInputOutput ) ) { ProbeRealDriveSizeRequest * request = ( ProbeRealDriveSizeRequest * ) Irp -> AssociatedIrp . SystemBuffer ; NTSTATUS status ; UNICODE_STRING name ; PFILE_OBJECT fileObject ; PDEVICE_OBJECT deviceObject ; EnsureNullTerminatedString ( request -> DeviceName , sizeof ( request -> DeviceName ) ) ; RtlInitUnicodeString ( & name , request -> DeviceName ) ; status = IoGetDeviceObjectPointer ( & name , FILE_READ_ATTRIBUTES , & fileObject , & deviceObject ) ; if ( ! NT_SUCCESS ( status ) ) { Irp -> IoStatus . Information = 0 ; Irp -> IoStatus . Status = status ; break ; } status = ProbeRealDriveSize ( deviceObject , & request -> RealDriveSize ) ; ObDereferenceObject ( fileObject ) ; if ( status == STATUS_TIMEOUT ) { request -> TimeOut = TRUE ; Irp -> IoStatus . Information = sizeof ( ProbeRealDriveSizeRequest ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } else if ( ! NT_SUCCESS ( status ) ) { Irp -> IoStatus . Information = 0 ; Irp -> IoStatus . Status = status ; } else { request -> TimeOut = FALSE ; Irp -> IoStatus . Information = sizeof ( ProbeRealDriveSizeRequest ) ; Irp -> IoStatus . Status = status ; } } break ; case TC_IOCTL_MOUNT_VOLUME : if ( ValidateIOBufferSize ( Irp , sizeof ( MOUNT_STRUCT ) , ValidateInputOutput ) ) { MOUNT_STRUCT * mount = ( MOUNT_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; if ( mount -> VolumePassword . Length > MAX_PASSWORD || mount -> ProtectedHidVolPassword . Length > MAX_PASSWORD || mount -> pkcs5_prf < 0 || mount -> pkcs5_prf > LAST_PRF_ID || mount -> VolumePim < - 1 || mount -> VolumePim == INT_MAX || mount -> ProtectedHidVolPkcs5Prf < 0 || mount -> ProtectedHidVolPkcs5Prf > LAST_PRF_ID || ( mount -> bTrueCryptMode != FALSE && mount -> bTrueCryptMode != TRUE ) ) { Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; break ; } EnsureNullTerminatedString ( mount -> wszVolume , sizeof ( mount -> wszVolume ) ) ; EnsureNullTerminatedString ( mount -> wszLabel , sizeof ( mount -> wszLabel ) ) ; Irp -> IoStatus . Information = sizeof ( MOUNT_STRUCT ) ; Irp -> IoStatus . Status = MountDevice ( DeviceObject , mount ) ; burn ( & mount -> VolumePassword , sizeof ( mount -> VolumePassword ) ) ; burn ( & mount -> ProtectedHidVolPassword , sizeof ( mount -> ProtectedHidVolPassword ) ) ; burn ( & mount -> pkcs5_prf , sizeof ( mount -> pkcs5_prf ) ) ; burn ( & mount -> VolumePim , sizeof ( mount -> VolumePim ) ) ; burn ( & mount -> bTrueCryptMode , sizeof ( mount -> bTrueCryptMode ) ) ; burn ( & mount -> ProtectedHidVolPkcs5Prf , sizeof ( mount -> ProtectedHidVolPkcs5Prf ) ) ; burn ( & mount -> ProtectedHidVolPim , sizeof ( mount -> ProtectedHidVolPim ) ) ; } break ; case TC_IOCTL_DISMOUNT_VOLUME : if ( ValidateIOBufferSize ( Irp , sizeof ( UNMOUNT_STRUCT ) , ValidateInputOutput ) ) { UNMOUNT_STRUCT * unmount = ( UNMOUNT_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; PDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject ( unmount -> nDosDriveNo ) ; unmount -> nReturnCode = ERR_DRIVE_NOT_FOUND ; if ( ListDevice ) { PEXTENSION ListExtension = ( PEXTENSION ) ListDevice -> DeviceExtension ; if ( IsVolumeAccessibleByCurrentUser ( ListExtension ) ) unmount -> nReturnCode = UnmountDevice ( unmount , ListDevice , unmount -> ignoreOpenFiles ) ; } Irp -> IoStatus . Information = sizeof ( UNMOUNT_STRUCT ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_DISMOUNT_ALL_VOLUMES : if ( ValidateIOBufferSize ( Irp , sizeof ( UNMOUNT_STRUCT ) , ValidateInputOutput ) ) { UNMOUNT_STRUCT * unmount = ( UNMOUNT_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; unmount -> nReturnCode = UnmountAllDevices ( unmount , unmount -> ignoreOpenFiles ) ; Irp -> IoStatus . Information = sizeof ( UNMOUNT_STRUCT ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_BOOT_ENCRYPTION_SETUP : Irp -> IoStatus . Status = StartBootEncryptionSetup ( DeviceObject , Irp , irpSp ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_ABORT_BOOT_ENCRYPTION_SETUP : Irp -> IoStatus . Status = AbortBootEncryptionSetup ( ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS : GetBootEncryptionStatus ( Irp , irpSp ) ; break ; case TC_IOCTL_GET_BOOT_ENCRYPTION_SETUP_RESULT : Irp -> IoStatus . Information = 0 ; Irp -> IoStatus . Status = GetSetupResult ( ) ; break ; case TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES : GetBootDriveVolumeProperties ( Irp , irpSp ) ; break ; case TC_IOCTL_GET_BOOT_LOADER_VERSION : GetBootLoaderVersion ( Irp , irpSp ) ; break ; case TC_IOCTL_REOPEN_BOOT_VOLUME_HEADER : ReopenBootVolumeHeader ( Irp , irpSp ) ; break ; case VC_IOCTL_GET_BOOT_LOADER_FINGERPRINT : GetBootLoaderFingerprint ( Irp , irpSp ) ; break ; case TC_IOCTL_GET_BOOT_ENCRYPTION_ALGORITHM_NAME : GetBootEncryptionAlgorithmName ( Irp , irpSp ) ; break ; case TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { * ( int * ) Irp -> AssociatedIrp . SystemBuffer = IsHiddenSystemRunning ( ) ? 1 : 0 ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_START_DECOY_SYSTEM_WIPE : Irp -> IoStatus . Status = StartDecoySystemWipe ( DeviceObject , Irp , irpSp ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_ABORT_DECOY_SYSTEM_WIPE : Irp -> IoStatus . Status = AbortDecoySystemWipe ( ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_DECOY_SYSTEM_WIPE_RESULT : Irp -> IoStatus . Status = GetDecoySystemWipeResult ( ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_DECOY_SYSTEM_WIPE_STATUS : GetDecoySystemWipeStatus ( Irp , irpSp ) ; break ; case TC_IOCTL_WRITE_BOOT_DRIVE_SECTOR : Irp -> IoStatus . Status = WriteBootDriveSector ( Irp , irpSp ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_WARNING_FLAGS : if ( ValidateIOBufferSize ( Irp , sizeof ( GetWarningFlagsRequest ) , ValidateOutput ) ) { GetWarningFlagsRequest * flags = ( GetWarningFlagsRequest * ) Irp -> AssociatedIrp . SystemBuffer ; flags -> PagingFileCreationPrevented = PagingFileCreationPrevented ; PagingFileCreationPrevented = FALSE ; flags -> SystemFavoriteVolumeDirty = SystemFavoriteVolumeDirty ; SystemFavoriteVolumeDirty = FALSE ; Irp -> IoStatus . Information = sizeof ( GetWarningFlagsRequest ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_SET_SYSTEM_FAVORITE_VOLUME_DIRTY : if ( UserCanAccessDriveDevice ( ) ) { SystemFavoriteVolumeDirty = TRUE ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } else Irp -> IoStatus . Status = STATUS_ACCESS_DENIED ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_REREAD_DRIVER_CONFIG : Irp -> IoStatus . Status = ReadRegistryConfigFlags ( FALSE ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_SYSTEM_DRIVE_DUMP_CONFIG : if ( ( ValidateIOBufferSize ( Irp , sizeof ( GetSystemDriveDumpConfigRequest ) , ValidateOutput ) ) && ( Irp -> RequestorMode == KernelMode ) ) { GetSystemDriveDumpConfigRequest * request = ( GetSystemDriveDumpConfigRequest * ) Irp -> AssociatedIrp . SystemBuffer ; request -> BootDriveFilterExtension = GetBootDriveFilterExtension ( ) ; if ( IsBootDriveMounted ( ) && request -> BootDriveFilterExtension ) { request -> HwEncryptionEnabled = IsHwEncryptionEnabled ( ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = sizeof ( * request ) ; } else { Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; } } break ; default : return TCCompleteIrp ( Irp , STATUS_INVALID_DEVICE_REQUEST , 0 ) ; } # if defined ( DEBUG ) || defined ( DEBUG_TRACE ) if ( ! NT_SUCCESS ( Irp -> IoStatus . Status ) ) { switch ( irpSp -> Parameters . DeviceIoControl . IoControlCode ) { case TC_IOCTL_GET_MOUNTED_VOLUMES : case TC_IOCTL_GET_PASSWORD_CACHE_STATUS : case TC_IOCTL_GET_PORTABLE_MODE_STATUS : case TC_IOCTL_SET_PORTABLE_MODE_STATUS : case TC_IOCTL_OPEN_TEST : case TC_IOCTL_GET_RESOLVED_SYMLINK : case TC_IOCTL_GET_DRIVE_PARTITION_INFO : case TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES : case TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS : case TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING : break ; default : Dump ( ""IOCTL<S2SV_blank>error<S2SV_blank>0x%08x\\n"" , Irp -> IoStatus . Status ) ; } } # endif return TCCompleteIrp ( Irp , Irp -> IoStatus . Status , Irp -> IoStatus . Information ) ; }",Irp -> IoStatus . Status = ntStatus ;Irp -> IoStatus . Information = 0 ;},590
805,"buggy line: if ( connection == NULL )  goto error ;cwe id:CWE-190context: static int on_http_message_complete ( http_parser * parser ) { struct clt_info * info = parser -> data ; ws_svr * svr = ws_svr_from_ses ( info -> ses ) ; info -> request -> version_major = parser -> http_major ; info -> request -> version_minor = parser -> http_minor ; info -> request -> method = parser -> method ; dict_entry * entry ; dict_iterator * iter = dict_get_iterator ( info -> request -> headers ) ; while ( ( entry = dict_next ( iter ) ) != NULL ) { log_trace ( ""Header:<S2SV_blank>%s:<S2SV_blank>%s"" , ( char * ) entry -> key , ( char * ) entry -> val ) ; } dict_release_iterator ( iter ) ; if ( info -> request -> method != HTTP_GET ) goto error ; if ( http_request_get_header ( info -> request , ""Host"" ) == NULL ) goto error ; double version = info -> request -> version_major + info -> request -> version_minor * 0.1 ; if ( version < 1.1 ) goto error ; const char * upgrade = http_request_get_header ( info -> request , ""Upgrade"" ) ; if ( upgrade == NULL || strcasecmp ( upgrade , ""websocket"" ) != 0 ) goto error ; const char * connection = http_request_get_header ( info -> request , ""Connection"" ) ;  if ( connection == NULL )  goto error ; else { bool found_upgrade = false ; int count ; sds * tokens = sdssplitlen ( connection , strlen ( connection ) , "","" , 1 , & count ) ; if ( tokens == NULL ) goto error ; for ( int i = 0 ; i < count ; i ++ ) { sds token = tokens [ i ] ; sdstrim ( token , ""<S2SV_blank>"" ) ; if ( strcasecmp ( token , ""Upgrade"" ) == 0 ) { found_upgrade = true ; break ; } } sdsfreesplitres ( tokens , count ) ; if ( ! found_upgrade ) goto error ; } const char * ws_version = http_request_get_header ( info -> request , ""Sec-WebSocket-Version"" ) ; if ( ws_version == NULL || strcmp ( ws_version , ""13"" ) != 0 ) goto error ; const char * ws_key = http_request_get_header ( info -> request , ""Sec-WebSocket-Key"" ) ; if ( ws_key == NULL ) goto error ; const char * protocol_list = http_request_get_header ( info -> request , ""Sec-WebSocket-Protocol"" ) ; if ( protocol_list && ! is_good_protocol ( protocol_list , svr -> protocol ) ) goto error ; if ( strlen ( svr -> origin ) > 0 ) { const char * origin = http_request_get_header ( info -> request , ""Origin"" ) ; if ( origin == NULL || ! is_good_origin ( origin , svr -> origin ) ) goto error ; } if ( svr -> type . on_privdata_alloc ) { info -> privdata = svr -> type . on_privdata_alloc ( svr ) ; if ( info -> privdata == NULL ) goto error ; } info -> upgrade = true ; info -> remote = sdsnew ( http_get_remote_ip ( info -> ses , info -> request ) ) ; info -> url = sdsnew ( info -> request -> url ) ; if ( svr -> type . on_upgrade ) { svr -> type . on_upgrade ( info -> ses , info -> remote ) ; } if ( protocol_list ) { send_hand_shake_reply ( info -> ses , svr -> protocol , ws_key ) ; } else { send_hand_shake_reply ( info -> ses , NULL , ws_key ) ; } return 0 ; error : ws_svr_close_clt ( ws_svr_from_ses ( info -> ses ) , info -> ses ) ; return - 1 ; }",if ( connection == NULL || strlen ( connection ) > UT_WS_SVR_MAX_HEADER_SIZE ) goto error ;,591
806,"buggy line: uint16 nif = 0 ;if ( rpcapd_discard ( pars -> sockctrl , plen ) == - 1 ) {cwe id:CWE-20context: static int daemon_msg_findallif_req ( uint8 ver , struct daemon_slpars * pars , uint32 plen ) { char errbuf [ PCAP_ERRBUF_SIZE ] ; char errmsgbuf [ PCAP_ERRBUF_SIZE ] ; char sendbuf [ RPCAP_NETBUF_SIZE ] ; int sendbufidx = 0 ; pcap_if_t * alldevs = NULL ; pcap_if_t * d ; struct pcap_addr * address ; struct rpcap_findalldevs_if * findalldevs_if ;  uint16 nif = 0 ;  if ( rpcapd_discard ( pars -> sockctrl , plen ) == - 1 ) { return - 1 ; } if ( pcap_findalldevs ( & alldevs , errmsgbuf ) == - 1 ) goto error ; if ( alldevs == NULL ) { if ( rpcap_senderror ( pars -> sockctrl , ver , PCAP_ERR_NOREMOTEIF , ""No<S2SV_blank>interfaces<S2SV_blank>found!<S2SV_blank>Make<S2SV_blank>sure<S2SV_blank>libpcap/WinPcap<S2SV_blank>is<S2SV_blank>properly<S2SV_blank>installed"" ""<S2SV_blank>and<S2SV_blank>you<S2SV_blank>have<S2SV_blank>the<S2SV_blank>right<S2SV_blank>to<S2SV_blank>access<S2SV_blank>to<S2SV_blank>the<S2SV_blank>remote<S2SV_blank>device."" , errbuf ) == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , ""Send<S2SV_blank>to<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s"" , errbuf ) ; return - 1 ; } return 0 ; }  for ( d = alldevs ; d != NULL ; d = d -> next )  { nif ++ ; if ( d -> description )  plen += strlen ( d -> description ) ;  if ( d -> name )  plen += strlen ( d -> name ) ;   plen += sizeof ( struct rpcap_findalldevs_if ) ;  for ( address = d -> addresses ; address != NULL ; address = address -> next ) { switch ( address -> addr -> sa_family ) { case AF_INET : # ifdef AF_INET6 case AF_INET6 : # endif  plen += ( sizeof ( struct rpcap_sockaddr ) * 4 ) ;  break ; default : break ; } } } if ( sock_bufferize ( NULL , sizeof ( struct rpcap_header ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; rpcap_createhdr ( ( struct rpcap_header * ) sendbuf , ver ,  RPCAP_MSG_FINDALLIF_REPLY , nif , plen ) ;  for ( d = alldevs ; d != NULL ; d = d -> next ) { uint16 lname , ldescr ; findalldevs_if = ( struct rpcap_findalldevs_if * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_findalldevs_if ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; memset ( findalldevs_if , 0 , sizeof ( struct rpcap_findalldevs_if ) ) ; if ( d -> description ) ldescr = ( short ) strlen ( d -> description ) ; else ldescr = 0 ; if ( d -> name ) lname = ( short ) strlen ( d -> name ) ; else lname = 0 ; findalldevs_if -> desclen = htons ( ldescr ) ; findalldevs_if -> namelen = htons ( lname ) ; findalldevs_if -> flags = htonl ( d -> flags ) ; for ( address = d -> addresses ; address != NULL ; address = address -> next ) { switch ( address -> addr -> sa_family ) { case AF_INET : # ifdef AF_INET6 case AF_INET6 : # endif findalldevs_if -> naddr ++ ; break ; default : break ; } } findalldevs_if -> naddr = htons ( findalldevs_if -> naddr ) ; if ( sock_bufferize ( d -> name , lname , sendbuf , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_BUFFERIZE , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; if ( sock_bufferize ( d -> description , ldescr , sendbuf , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_BUFFERIZE , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; for ( address = d -> addresses ; address != NULL ; address = address -> next ) { struct rpcap_sockaddr * sockaddr ; switch ( address -> addr -> sa_family ) { case AF_INET : # ifdef AF_INET6 case AF_INET6 : # endif sockaddr = ( struct rpcap_sockaddr * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_sockaddr ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; daemon_seraddr ( ( struct sockaddr_storage * ) address -> addr , sockaddr ) ; sockaddr = ( struct rpcap_sockaddr * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_sockaddr ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; daemon_seraddr ( ( struct sockaddr_storage * ) address -> netmask , sockaddr ) ; sockaddr = ( struct rpcap_sockaddr * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_sockaddr ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; daemon_seraddr ( ( struct sockaddr_storage * ) address -> broadaddr , sockaddr ) ; sockaddr = ( struct rpcap_sockaddr * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_sockaddr ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; daemon_seraddr ( ( struct sockaddr_storage * ) address -> dstaddr , sockaddr ) ; break ; default : break ; } } } pcap_freealldevs ( alldevs ) ; if ( sock_send ( pars -> sockctrl , sendbuf , sendbufidx , errbuf , PCAP_ERRBUF_SIZE ) == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , ""Send<S2SV_blank>to<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s"" , errbuf ) ; return - 1 ; } return 0 ; error : if ( alldevs ) pcap_freealldevs ( alldevs ) ; if ( rpcap_senderror ( pars -> sockctrl , ver , PCAP_ERR_FINDALLIF , errmsgbuf , errbuf ) == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , ""Send<S2SV_blank>to<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s"" , errbuf ) ; return - 1 ; } return 0 ; }","uint32 replylen ;uint16 nif = 0 ;if ( rpcapd_discard ( pars -> sockctrl , plen ) == - 1 ) {",592
807,"buggy line: for ( d = alldevs ;d = d -> next )  {if ( d -> description )  plen += strlen ( d -> description ) ;if ( d -> name )  plen += strlen ( d -> name ) ;plen += sizeof ( struct rpcap_findalldevs_if ) ;for ( address = d -> addresses ;case AF_INET : # ifdef AF_INET6 case AF_INET6 : # endif  plen += ( sizeof ( struct rpcap_sockaddr ) * 4 ) ;break ;rpcap_createhdr ( ( struct rpcap_header * ) sendbuf , ver ,  RPCAP_MSG_FINDALLIF_REPLY , nif , plen ) ;for ( d = alldevs ;cwe id:CWE-20context: static int daemon_msg_findallif_req ( uint8 ver , struct daemon_slpars * pars , uint32 plen ) { char errbuf [ PCAP_ERRBUF_SIZE ] ; char errmsgbuf [ PCAP_ERRBUF_SIZE ] ; char sendbuf [ RPCAP_NETBUF_SIZE ] ; int sendbufidx = 0 ; pcap_if_t * alldevs = NULL ; pcap_if_t * d ; struct pcap_addr * address ; struct rpcap_findalldevs_if * findalldevs_if ;  uint16 nif = 0 ;  if ( rpcapd_discard ( pars -> sockctrl , plen ) == - 1 ) { return - 1 ; } if ( pcap_findalldevs ( & alldevs , errmsgbuf ) == - 1 ) goto error ; if ( alldevs == NULL ) { if ( rpcap_senderror ( pars -> sockctrl , ver , PCAP_ERR_NOREMOTEIF , ""No<S2SV_blank>interfaces<S2SV_blank>found!<S2SV_blank>Make<S2SV_blank>sure<S2SV_blank>libpcap/WinPcap<S2SV_blank>is<S2SV_blank>properly<S2SV_blank>installed"" ""<S2SV_blank>and<S2SV_blank>you<S2SV_blank>have<S2SV_blank>the<S2SV_blank>right<S2SV_blank>to<S2SV_blank>access<S2SV_blank>to<S2SV_blank>the<S2SV_blank>remote<S2SV_blank>device."" , errbuf ) == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , ""Send<S2SV_blank>to<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s"" , errbuf ) ; return - 1 ; } return 0 ; }  for ( d = alldevs ; d != NULL ; d = d -> next )  { nif ++ ; if ( d -> description )  plen += strlen ( d -> description ) ;  if ( d -> name )  plen += strlen ( d -> name ) ;   plen += sizeof ( struct rpcap_findalldevs_if ) ;  for ( address = d -> addresses ; address != NULL ; address = address -> next ) { switch ( address -> addr -> sa_family ) { case AF_INET : # ifdef AF_INET6 case AF_INET6 : # endif  plen += ( sizeof ( struct rpcap_sockaddr ) * 4 ) ;  break ; default : break ; } } } if ( sock_bufferize ( NULL , sizeof ( struct rpcap_header ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; rpcap_createhdr ( ( struct rpcap_header * ) sendbuf , ver ,  RPCAP_MSG_FINDALLIF_REPLY , nif , plen ) ;  for ( d = alldevs ; d != NULL ; d = d -> next ) { uint16 lname , ldescr ; findalldevs_if = ( struct rpcap_findalldevs_if * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_findalldevs_if ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; memset ( findalldevs_if , 0 , sizeof ( struct rpcap_findalldevs_if ) ) ; if ( d -> description ) ldescr = ( short ) strlen ( d -> description ) ; else ldescr = 0 ; if ( d -> name ) lname = ( short ) strlen ( d -> name ) ; else lname = 0 ; findalldevs_if -> desclen = htons ( ldescr ) ; findalldevs_if -> namelen = htons ( lname ) ; findalldevs_if -> flags = htonl ( d -> flags ) ; for ( address = d -> addresses ; address != NULL ; address = address -> next ) { switch ( address -> addr -> sa_family ) { case AF_INET : # ifdef AF_INET6 case AF_INET6 : # endif findalldevs_if -> naddr ++ ; break ; default : break ; } } findalldevs_if -> naddr = htons ( findalldevs_if -> naddr ) ; if ( sock_bufferize ( d -> name , lname , sendbuf , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_BUFFERIZE , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; if ( sock_bufferize ( d -> description , ldescr , sendbuf , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_BUFFERIZE , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; for ( address = d -> addresses ; address != NULL ; address = address -> next ) { struct rpcap_sockaddr * sockaddr ; switch ( address -> addr -> sa_family ) { case AF_INET : # ifdef AF_INET6 case AF_INET6 : # endif sockaddr = ( struct rpcap_sockaddr * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_sockaddr ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; daemon_seraddr ( ( struct sockaddr_storage * ) address -> addr , sockaddr ) ; sockaddr = ( struct rpcap_sockaddr * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_sockaddr ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; daemon_seraddr ( ( struct sockaddr_storage * ) address -> netmask , sockaddr ) ; sockaddr = ( struct rpcap_sockaddr * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_sockaddr ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; daemon_seraddr ( ( struct sockaddr_storage * ) address -> broadaddr , sockaddr ) ; sockaddr = ( struct rpcap_sockaddr * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_sockaddr ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; daemon_seraddr ( ( struct sockaddr_storage * ) address -> dstaddr , sockaddr ) ; break ; default : break ; } } } pcap_freealldevs ( alldevs ) ; if ( sock_send ( pars -> sockctrl , sendbuf , sendbufidx , errbuf , PCAP_ERRBUF_SIZE ) == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , ""Send<S2SV_blank>to<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s"" , errbuf ) ; return - 1 ; } return 0 ; error : if ( alldevs ) pcap_freealldevs ( alldevs ) ; if ( rpcap_senderror ( pars -> sockctrl , ver , PCAP_ERR_FINDALLIF , errmsgbuf , errbuf ) == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , ""Send<S2SV_blank>to<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s"" , errbuf ) ; return - 1 ; } return 0 ; }","replylen = 0 ;for ( d = alldevs ;d = d -> next ) {if ( d -> description ) replylen += strlen ( d -> description ) ;if ( d -> name ) replylen += strlen ( d -> name ) ;replylen += sizeof ( struct rpcap_findalldevs_if ) ;for ( address = d -> addresses ;case AF_INET : # ifdef AF_INET6 case AF_INET6 : # endif replylen += ( sizeof ( struct rpcap_sockaddr ) * 4 ) ;break ;rpcap_createhdr ( ( struct rpcap_header * ) sendbuf , ver , RPCAP_MSG_FINDALLIF_REPLY , nif , replylen ) ;for ( d = alldevs ;",592
808,"buggy line: struct dump_dir * dd = dd_create ( path , client_uid , DEFAULT_DUMP_DIR_MODE ) ;if ( ! dd ) {cwe id:CWE-200context: static int create_problem_dir ( GHashTable * problem_info , unsigned pid ) { if ( g_settings_nMaxCrashReportsSize > 0 ) { if ( low_free_space ( g_settings_nMaxCrashReportsSize , g_settings_dump_location ) ) exit ( 1 ) ; } gchar * dir_basename = g_hash_table_lookup ( problem_info , ""basename"" ) ; if ( ! dir_basename ) dir_basename = g_hash_table_lookup ( problem_info , FILENAME_TYPE ) ; char * path = xasprintf ( ""%s/%s-%s-%u.new"" , g_settings_dump_location , dir_basename , iso_date_string ( NULL ) , pid ) ; g_hash_table_remove ( problem_info , ""basename"" ) ;  struct dump_dir * dd = dd_create ( path , client_uid , DEFAULT_DUMP_DIR_MODE ) ;  if ( ! dd ) { error_msg_and_die ( ""Error<S2SV_blank>creating<S2SV_blank>problem<S2SV_blank>directory<S2SV_blank>\'%s\'"" , path ) ; } dd_create_basic_files ( dd , client_uid , NULL ) ; dd_save_text ( dd , FILENAME_ABRT_VERSION , VERSION ) ; gpointer gpkey = g_hash_table_lookup ( problem_info , FILENAME_CMDLINE ) ; if ( ! gpkey ) { char * cmdline = get_cmdline ( pid ) ; if ( cmdline ) { dd_save_text ( dd , FILENAME_CMDLINE , cmdline ) ; free ( cmdline ) ; } } char uid_str [ sizeof ( long ) * 3 + 2 ] ; sprintf ( uid_str , ""%lu"" , ( long ) client_uid ) ; dd_save_text ( dd , FILENAME_UID , uid_str ) ; GHashTableIter iter ; gpointer gpvalue ; g_hash_table_iter_init ( & iter , problem_info ) ; while ( g_hash_table_iter_next ( & iter , & gpkey , & gpvalue ) ) { dd_save_text ( dd , ( gchar * ) gpkey , ( gchar * ) gpvalue ) ; } dd_close ( dd ) ; g_hash_table_destroy ( problem_info ) ; char * newpath = xstrndup ( path , strlen ( path ) - strlen ( "".new"" ) ) ; if ( rename ( path , newpath ) == 0 ) strcpy ( path , newpath ) ; free ( newpath ) ; log_notice ( ""Saved<S2SV_blank>problem<S2SV_blank>directory<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>%u<S2SV_blank>to<S2SV_blank>\'%s\'"" , pid , path ) ; printf ( ""HTTP/1.1<S2SV_blank>201<S2SV_blank>Created\\r\\n\\r\\n"" ) ; fflush ( NULL ) ; close ( STDOUT_FILENO ) ; xdup2 ( STDERR_FILENO , STDOUT_FILENO ) ; if ( g_settings_nMaxCrashReportsSize > 0 ) { trim_problem_dirs ( g_settings_dump_location , g_settings_nMaxCrashReportsSize * ( double ) ( 1024 * 1024 ) , path ) ; } run_post_create ( path ) ; exit ( 0 ) ; }","struct dump_dir * dd = dd_create ( path , g_settings_privatereports ? 0 : client_uid , DEFAULT_DUMP_DIR_MODE ) ;if ( ! dd ) {",593
809,"buggy line: x += 8 ) {for ( bit = 0 ;bit < 8 ;bit ++ ) {cwe id:CWE-787context: static void InsertRow ( unsigned char * p , ssize_t y , Image * image , int bpp ) { ExceptionInfo * exception ; int bit ; ssize_t x ; register PixelPacket * q ; IndexPacket index ; register IndexPacket * indexes ; exception = ( & image -> exception ) ; switch ( bpp ) { case 1 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { index = ( ( * p ) & ( 0x80 >> bit ) ? 0x01 : 0x00 ) ; SetPixelIndex ( indexes + x + bit , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( ssize_t ) ( image -> columns % 8 ) ; bit ++ ) { index = ( ( * p ) & ( 0x80 >> bit ) ? 0x01 : 0x00 ) ; SetPixelIndex ( indexes + x + bit , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; } p ++ ; } if ( ! SyncAuthenticPixels ( image , exception ) ) break ; break ; } case 2 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ;  for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 )  { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; index = ConstrainColormapIndex ( image , ( * p ) & 0x3 ) ; SetPixelIndex ( indexes + x + 1 , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; p ++ ; q ++ ; } if ( ( image -> columns % 4 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; if ( ( image -> columns % 4 ) >= 1 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; if ( ( image -> columns % 4 ) >= 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; } } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; break ; } case 4 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x0f ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; index = ConstrainColormapIndex ( image , ( * p ) & 0x0f ) ; SetPixelIndex ( indexes + x + 1 , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; p ++ ; q ++ ; } if ( ( image -> columns % 2 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x0f ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; break ; } case 8 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { index = ConstrainColormapIndex ( image , * p ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } break ; case 24 : q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( ! SyncAuthenticPixels ( image , exception ) ) break ; break ; } }",x += 4 ) {,594
810,"buggy line: for ( x = 0 ;x += 2 )  {cwe id:CWE-787context: static void InsertRow ( unsigned char * p , ssize_t y , Image * image , int bpp ) { ExceptionInfo * exception ; int bit ; ssize_t x ; register PixelPacket * q ; IndexPacket index ; register IndexPacket * indexes ; exception = ( & image -> exception ) ; switch ( bpp ) { case 1 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { index = ( ( * p ) & ( 0x80 >> bit ) ? 0x01 : 0x00 ) ; SetPixelIndex ( indexes + x + bit , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( ssize_t ) ( image -> columns % 8 ) ; bit ++ ) { index = ( ( * p ) & ( 0x80 >> bit ) ? 0x01 : 0x00 ) ; SetPixelIndex ( indexes + x + bit , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; } p ++ ; } if ( ! SyncAuthenticPixels ( image , exception ) ) break ; break ; } case 2 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ;  for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 )  { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; index = ConstrainColormapIndex ( image , ( * p ) & 0x3 ) ; SetPixelIndex ( indexes + x + 1 , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; p ++ ; q ++ ; } if ( ( image -> columns % 4 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; if ( ( image -> columns % 4 ) >= 1 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; if ( ( image -> columns % 4 ) >= 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; } } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; break ; } case 4 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x0f ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; index = ConstrainColormapIndex ( image , ( * p ) & 0x0f ) ; SetPixelIndex ( indexes + x + 1 , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; p ++ ; q ++ ; } if ( ( image -> columns % 2 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x0f ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; break ; } case 8 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { index = ConstrainColormapIndex ( image , * p ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } break ; case 24 : q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( ! SyncAuthenticPixels ( image , exception ) ) break ; break ; } }",for ( x = 0 ;x += 2 ) {,594
811,"buggy line: BN_ULONG t1 , t2 ;BN_ULONG c1 , c2 , c3 ;cwe id:CWE-310context: void bn_sqr_comba8 ( BN_ULONG * r , const BN_ULONG * a ) {  BN_ULONG t1 , t2 ;  BN_ULONG c1 , c2 , c3 ; c1 = 0 ; c2 = 0 ; c3 = 0 ; sqr_add_c ( a , 0 , c1 , c2 , c3 ) ; r [ 0 ] = c1 ; c1 = 0 ; sqr_add_c2 ( a , 1 , 0 , c2 , c3 , c1 ) ; r [ 1 ] = c2 ; c2 = 0 ; sqr_add_c ( a , 1 , c3 , c1 , c2 ) ; sqr_add_c2 ( a , 2 , 0 , c3 , c1 , c2 ) ; r [ 2 ] = c3 ; c3 = 0 ; sqr_add_c2 ( a , 3 , 0 , c1 , c2 , c3 ) ; sqr_add_c2 ( a , 2 , 1 , c1 , c2 , c3 ) ; r [ 3 ] = c1 ; c1 = 0 ; sqr_add_c ( a , 2 , c2 , c3 , c1 ) ; sqr_add_c2 ( a , 3 , 1 , c2 , c3 , c1 ) ; sqr_add_c2 ( a , 4 , 0 , c2 , c3 , c1 ) ; r [ 4 ] = c2 ; c2 = 0 ; sqr_add_c2 ( a , 5 , 0 , c3 , c1 , c2 ) ; sqr_add_c2 ( a , 4 , 1 , c3 , c1 , c2 ) ; sqr_add_c2 ( a , 3 , 2 , c3 , c1 , c2 ) ; r [ 5 ] = c3 ; c3 = 0 ; sqr_add_c ( a , 3 , c1 , c2 , c3 ) ; sqr_add_c2 ( a , 4 , 2 , c1 , c2 , c3 ) ; sqr_add_c2 ( a , 5 , 1 , c1 , c2 , c3 ) ; sqr_add_c2 ( a , 6 , 0 , c1 , c2 , c3 ) ; r [ 6 ] = c1 ; c1 = 0 ; sqr_add_c2 ( a , 7 , 0 , c2 , c3 , c1 ) ; sqr_add_c2 ( a , 6 , 1 , c2 , c3 , c1 ) ; sqr_add_c2 ( a , 5 , 2 , c2 , c3 , c1 ) ; sqr_add_c2 ( a , 4 , 3 , c2 , c3 , c1 ) ; r [ 7 ] = c2 ; c2 = 0 ; sqr_add_c ( a , 4 , c3 , c1 , c2 ) ; sqr_add_c2 ( a , 5 , 3 , c3 , c1 , c2 ) ; sqr_add_c2 ( a , 6 , 2 , c3 , c1 , c2 ) ; sqr_add_c2 ( a , 7 , 1 , c3 , c1 , c2 ) ; r [ 8 ] = c3 ; c3 = 0 ; sqr_add_c2 ( a , 7 , 2 , c1 , c2 , c3 ) ; sqr_add_c2 ( a , 6 , 3 , c1 , c2 , c3 ) ; sqr_add_c2 ( a , 5 , 4 , c1 , c2 , c3 ) ; r [ 9 ] = c1 ; c1 = 0 ; sqr_add_c ( a , 5 , c2 , c3 , c1 ) ; sqr_add_c2 ( a , 6 , 4 , c2 , c3 , c1 ) ; sqr_add_c2 ( a , 7 , 3 , c2 , c3 , c1 ) ; r [ 10 ] = c2 ; c2 = 0 ; sqr_add_c2 ( a , 7 , 4 , c3 , c1 , c2 ) ; sqr_add_c2 ( a , 6 , 5 , c3 , c1 , c2 ) ; r [ 11 ] = c3 ; c3 = 0 ; sqr_add_c ( a , 6 , c1 , c2 , c3 ) ; sqr_add_c2 ( a , 7 , 5 , c1 , c2 , c3 ) ; r [ 12 ] = c1 ; c1 = 0 ; sqr_add_c2 ( a , 7 , 6 , c2 , c3 , c1 ) ; r [ 13 ] = c2 ; c2 = 0 ; sqr_add_c ( a , 7 , c3 , c1 , c2 ) ; r [ 14 ] = c3 ; r [ 15 ] = c1 ; }","BN_ULONG c1 , c2 , c3 ;",595
812,"buggy line: static void __skb_complete_tx_timestamp ( struct sk_buff * skb , struct sock * sk ,  int tstype )  {int err ;serr = SKB_EXT_ERR ( skb ) ;serr -> ee . ee_info = tstype ;if ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_ID ) {cwe id:CWE-125context: static void __skb_complete_tx_timestamp ( struct sk_buff * skb , struct sock * sk ,  int tstype )  { struct sock_exterr_skb * serr ;  int err ;  serr = SKB_EXT_ERR ( skb ) ; memset ( serr , 0 , sizeof ( * serr ) ) ; serr -> ee . ee_errno = ENOMSG ; serr -> ee . ee_origin = SO_EE_ORIGIN_TIMESTAMPING ;  serr -> ee . ee_info = tstype ;  if ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_ID ) { serr -> ee . ee_data = skb_shinfo ( skb ) -> tskey ; if ( sk -> sk_protocol == IPPROTO_TCP && sk -> sk_type == SOCK_STREAM ) serr -> ee . ee_data -= sk -> sk_tskey ; } err = sock_queue_err_skb ( sk , skb ) ; if ( err ) kfree_skb ( skb ) ; }","static void __skb_complete_tx_timestamp ( struct sk_buff * skb , struct sock * sk , int tstype , bool opt_stats ) {int err ;BUILD_BUG_ON ( sizeof ( struct sock_exterr_skb ) > sizeof ( skb -> cb ) ) ;serr = SKB_EXT_ERR ( skb ) ;serr -> ee . ee_info = tstype ;serr -> opt_stats = opt_stats ;if ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_ID ) {",596
813,"buggy line: cwe id:CWE-119context: static Image * ReadDDSImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status , cubemap = MagickFalse , volume = MagickFalse , matte ; CompressionType compression ; DDSInfo dds_info ; DDSDecoder * decoder ; size_t n , num_images ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( ReadDDSInfo ( image , & dds_info ) != MagickTrue ) { ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP ) cubemap = MagickTrue ; if ( dds_info . ddscaps2 & DDSCAPS2_VOLUME && dds_info . depth > 0 ) volume = MagickTrue ; ( void ) SeekBlob ( image , 128 , SEEK_SET ) ; if ( dds_info . pixelformat . flags & DDPF_RGB ) { compression = NoCompression ; if ( dds_info . pixelformat . flags & DDPF_ALPHAPIXELS ) { matte = MagickTrue ; decoder = ReadUncompressedRGBA ; } else { matte = MagickTrue ; decoder = ReadUncompressedRGB ; } } else if ( dds_info . pixelformat . flags & DDPF_LUMINANCE ) { compression = NoCompression ; if ( dds_info . pixelformat . flags & DDPF_ALPHAPIXELS ) { ThrowReaderException ( CorruptImageError , ""ImageTypeNotSupported"" ) ; } else { matte = MagickFalse ; decoder = ReadUncompressedRGB ; } } else if ( dds_info . pixelformat . flags & DDPF_FOURCC ) { switch ( dds_info . pixelformat . fourcc ) { case FOURCC_DXT1 : { matte = MagickFalse ; compression = DXT1Compression ; decoder = ReadDXT1 ; break ; } case FOURCC_DXT3 : { matte = MagickTrue ; compression = DXT3Compression ; decoder = ReadDXT3 ; break ; } case FOURCC_DXT5 : { matte = MagickTrue ; compression = DXT5Compression ; decoder = ReadDXT5 ; break ; } default : { ThrowReaderException ( CorruptImageError , ""ImageTypeNotSupported"" ) ; } } } else { ThrowReaderException ( CorruptImageError , ""ImageTypeNotSupported"" ) ; } num_images = 1 ; if ( cubemap ) { num_images = 0 ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEX ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEX ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEY ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEY ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEZ ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ ) num_images ++ ; } if ( volume ) num_images = dds_info . depth ; for ( n = 0 ; n < num_images ; n ++ ) { if ( n != 0 ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) return ( DestroyImageList ( image ) ) ; image = SyncNextImageInList ( image ) ; } image -> matte = matte ; image -> compression = compression ; image -> columns = dds_info . width ; image -> rows = dds_info . height ; image -> storage_class = DirectClass ; image -> endian = LSBEndian ; image -> depth = 8 ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }  if ( ( decoder ) ( image , & dds_info , exception ) != MagickTrue )  { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } } if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","status = SetImageExtent ( image , image -> columns , image -> rows ) ;if ( status == MagickFalse ) {InheritException ( exception , & image -> exception ) ;return ( DestroyImageList ( image ) ) ;}",597
814,"buggy line: if ( ( decoder ) ( image , & dds_info , exception ) != MagickTrue )  {cwe id:CWE-119context: static Image * ReadDDSImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status , cubemap = MagickFalse , volume = MagickFalse , matte ; CompressionType compression ; DDSInfo dds_info ; DDSDecoder * decoder ; size_t n , num_images ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( ReadDDSInfo ( image , & dds_info ) != MagickTrue ) { ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP ) cubemap = MagickTrue ; if ( dds_info . ddscaps2 & DDSCAPS2_VOLUME && dds_info . depth > 0 ) volume = MagickTrue ; ( void ) SeekBlob ( image , 128 , SEEK_SET ) ; if ( dds_info . pixelformat . flags & DDPF_RGB ) { compression = NoCompression ; if ( dds_info . pixelformat . flags & DDPF_ALPHAPIXELS ) { matte = MagickTrue ; decoder = ReadUncompressedRGBA ; } else { matte = MagickTrue ; decoder = ReadUncompressedRGB ; } } else if ( dds_info . pixelformat . flags & DDPF_LUMINANCE ) { compression = NoCompression ; if ( dds_info . pixelformat . flags & DDPF_ALPHAPIXELS ) { ThrowReaderException ( CorruptImageError , ""ImageTypeNotSupported"" ) ; } else { matte = MagickFalse ; decoder = ReadUncompressedRGB ; } } else if ( dds_info . pixelformat . flags & DDPF_FOURCC ) { switch ( dds_info . pixelformat . fourcc ) { case FOURCC_DXT1 : { matte = MagickFalse ; compression = DXT1Compression ; decoder = ReadDXT1 ; break ; } case FOURCC_DXT3 : { matte = MagickTrue ; compression = DXT3Compression ; decoder = ReadDXT3 ; break ; } case FOURCC_DXT5 : { matte = MagickTrue ; compression = DXT5Compression ; decoder = ReadDXT5 ; break ; } default : { ThrowReaderException ( CorruptImageError , ""ImageTypeNotSupported"" ) ; } } } else { ThrowReaderException ( CorruptImageError , ""ImageTypeNotSupported"" ) ; } num_images = 1 ; if ( cubemap ) { num_images = 0 ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEX ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEX ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEY ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEY ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEZ ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ ) num_images ++ ; } if ( volume ) num_images = dds_info . depth ; for ( n = 0 ; n < num_images ; n ++ ) { if ( n != 0 ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) return ( DestroyImageList ( image ) ) ; image = SyncNextImageInList ( image ) ; } image -> matte = matte ; image -> compression = compression ; image -> columns = dds_info . width ; image -> rows = dds_info . height ; image -> storage_class = DirectClass ; image -> endian = LSBEndian ; image -> depth = 8 ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }  if ( ( decoder ) ( image , & dds_info , exception ) != MagickTrue )  { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } } if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","if ( ( decoder ) ( image , & dds_info , exception ) != MagickTrue ) {",597
815,"buggy line: if ( in_cksum ( vec , 1 ) )  ND_PRINT ( ( ndo , "",<S2SV_blank>(bad<S2SV_blank>vrrp<S2SV_blank>cksum<S2SV_blank>%x)"" ,  EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ;}cwe id:CWE-125context: void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown<S2SV_blank>type<S2SV_blank>(%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u,<S2SV_blank>%s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "",<S2SV_blank>(ttl<S2SV_blank>%u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>vrid<S2SV_blank>%u,<S2SV_blank>prio<S2SV_blank>%u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "",<S2SV_blank>authtype<S2SV_blank>%s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>intvl<S2SV_blank>%us,<S2SV_blank>length<S2SV_blank>%u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "",<S2SV_blank>intvl<S2SV_blank>%ucs,<S2SV_blank>length<S2SV_blank>%u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ;  if ( in_cksum ( vec , 1 ) )  ND_PRINT ( ( ndo , "",<S2SV_blank>(bad<S2SV_blank>vrrp<S2SV_blank>cksum<S2SV_blank>%x)"" ,  EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ;  } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "",<S2SV_blank>(bad<S2SV_blank>vrrp<S2SV_blank>cksum<S2SV_blank>%x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "",<S2SV_blank>addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = '<S2SV_blank>' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>auth<S2SV_blank>\\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }","if ( in_cksum ( vec , 1 ) ) {ND_TCHECK_16BITS ( & bp [ 6 ] ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>(bad<S2SV_blank>vrrp<S2SV_blank>cksum<S2SV_blank>%x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ;}}",598
816,"buggy line: cwe id:CWE-190context: static void test_burl_normalize ( void ) { buffer * psrc = buffer_init ( ) ; buffer * ptmp = buffer_init ( ) ; int flags ; flags = HTTP_PARSEOPT_URL_NORMALIZE_UNRESERVED ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""no-slash"" ) , CONST_STR_LEN ( ""no-slash"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/"" ) , CONST_STR_LEN ( ""/"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc"" ) , CONST_STR_LEN ( ""/abc"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc/"" ) , CONST_STR_LEN ( ""/abc/"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc/def"" ) , CONST_STR_LEN ( ""/abc/def"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?"" ) , CONST_STR_LEN ( ""/abc?"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d"" ) , CONST_STR_LEN ( ""/abc?d"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d="" ) , CONST_STR_LEN ( ""/abc?d="" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d=e"" ) , CONST_STR_LEN ( ""/abc?d=e"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d=e&"" ) , CONST_STR_LEN ( ""/abc?d=e&"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d=e&f"" ) , CONST_STR_LEN ( ""/abc?d=e&f"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d=e&f=g"" ) , CONST_STR_LEN ( ""/abc?d=e&f=g"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d=e&f=g#"" ) , CONST_STR_LEN ( ""/abc?d=e&f=g"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d=e&f=g#any"" ) , CONST_STR_LEN ( ""/abc?d=e&f=g"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%2F"" ) , CONST_STR_LEN ( ""/%2F"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%2f"" ) , CONST_STR_LEN ( ""/%2F"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%20"" ) , CONST_STR_LEN ( ""/%20"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%2b"" ) , CONST_STR_LEN ( ""/%2B"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%2B"" ) , CONST_STR_LEN ( ""/%2B"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%3a"" ) , CONST_STR_LEN ( ""/%3A"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%3A"" ) , CONST_STR_LEN ( ""/%3A"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/~test%20_"" ) , CONST_STR_LEN ( ""/~test%20%C3%A4_"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/\\375"" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/\\376"" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/\\377"" ) , """" , ( size_t ) - 2 ) ; flags = HTTP_PARSEOPT_URL_NORMALIZE_REQUIRED ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/"" ) , CONST_STR_LEN ( ""/"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc"" ) , CONST_STR_LEN ( ""/abc"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc/"" ) , CONST_STR_LEN ( ""/abc/"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc/def"" ) , CONST_STR_LEN ( ""/abc/def"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?"" ) , CONST_STR_LEN ( ""/abc?"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d"" ) , CONST_STR_LEN ( ""/abc?d"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d="" ) , CONST_STR_LEN ( ""/abc?d="" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d=e"" ) , CONST_STR_LEN ( ""/abc?d=e"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d=e&"" ) , CONST_STR_LEN ( ""/abc?d=e&"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d=e&f"" ) , CONST_STR_LEN ( ""/abc?d=e&f"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d=e&f=g"" ) , CONST_STR_LEN ( ""/abc?d=e&f=g"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d=e&f=g#"" ) , CONST_STR_LEN ( ""/abc?d=e&f=g"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d=e&f=g#any"" ) , CONST_STR_LEN ( ""/abc?d=e&f=g"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%2F"" ) , CONST_STR_LEN ( ""/%2F"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%2f"" ) , CONST_STR_LEN ( ""/%2F"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%20"" ) , CONST_STR_LEN ( ""/%20"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%2b"" ) , CONST_STR_LEN ( ""/+"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%2B"" ) , CONST_STR_LEN ( ""/+"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%3a"" ) , CONST_STR_LEN ( ""/:"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%3A"" ) , CONST_STR_LEN ( ""/:"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/~test%20_"" ) , CONST_STR_LEN ( ""/~test%20%C3%A4_"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/\\375"" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/\\376"" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/\\377"" ) , """" , ( size_t ) - 2 ) ; flags |= HTTP_PARSEOPT_URL_NORMALIZE_CTRLS_REJECT ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/\\a"" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/\\t"" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/\\r"" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/\\177"" ) , """" , ( size_t ) - 2 ) ; # if defined ( __WIN32 ) || defined ( __CYGWIN__ ) flags |= HTTP_PARSEOPT_URL_NORMALIZE_PATH_BACKSLASH_TRANS ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a\\\\b"" ) , CONST_STR_LEN ( ""/a/b"" ) ) ; # endif flags |= HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_DECODE ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/b?c=/"" ) , CONST_STR_LEN ( ""/a/b?c=/"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/b?c=%2f"" ) , CONST_STR_LEN ( ""/a/b?c=/"" ) ) ;  run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a%2fb"" ) , CONST_STR_LEN ( ""/a/b"" ) ) ;  run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a%2Fb"" ) , CONST_STR_LEN ( ""/a/b"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a%2fb?c=/"" ) , CONST_STR_LEN ( ""/a/b?c=/"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a%2fb?c=%2f"" ) , CONST_STR_LEN ( ""/a/b?c=/"" ) ) ; flags &= ~ HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_DECODE ; flags |= HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_REJECT ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a%2fb"" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a%2Fb"" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/b?c=%2f"" ) , CONST_STR_LEN ( ""/a/b?c=/"" ) ) ; flags &= ~ HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_REJECT ; flags |= HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REMOVE ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""./a/b"" ) , CONST_STR_LEN ( ""/a/b"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""../a/b"" ) , CONST_STR_LEN ( ""/a/b"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/./b"" ) , CONST_STR_LEN ( ""/a/b"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/../b"" ) , CONST_STR_LEN ( ""/b"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/b/."" ) , CONST_STR_LEN ( ""/a/b/"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/b/.."" ) , CONST_STR_LEN ( ""/a/"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/../b/.."" ) , CONST_STR_LEN ( ""/"" ) ) ; flags &= ~ HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REMOVE ; flags |= HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REJECT ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""./a/b"" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""../a/b"" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/./b"" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/../b"" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/b/."" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/b/.."" ) , """" , ( size_t ) - 2 ) ; flags &= ~ HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REJECT ; flags |= HTTP_PARSEOPT_URL_NORMALIZE_QUERY_20_PLUS ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/b?c=d+e"" ) , CONST_STR_LEN ( ""/a/b?c=d+e"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/b?c=d%20e"" ) , CONST_STR_LEN ( ""/a/b?c=d+e"" ) ) ; flags &= ~ HTTP_PARSEOPT_URL_NORMALIZE_QUERY_20_PLUS ; buffer_free ( psrc ) ; buffer_free ( ptmp ) ; }","run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""%2f?"" ) , CONST_STR_LEN ( ""/?"" ) ) ;run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%2f?"" ) , CONST_STR_LEN ( ""//?"" ) ) ;",599
817,"buggy line: run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a%2fb"" ) , CONST_STR_LEN ( ""/a/b"" ) ) ;run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a%2Fb"" ) , CONST_STR_LEN ( ""/a/b"" ) ) ;cwe id:CWE-190context: static void test_burl_normalize ( void ) { buffer * psrc = buffer_init ( ) ; buffer * ptmp = buffer_init ( ) ; int flags ; flags = HTTP_PARSEOPT_URL_NORMALIZE_UNRESERVED ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""no-slash"" ) , CONST_STR_LEN ( ""no-slash"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/"" ) , CONST_STR_LEN ( ""/"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc"" ) , CONST_STR_LEN ( ""/abc"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc/"" ) , CONST_STR_LEN ( ""/abc/"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc/def"" ) , CONST_STR_LEN ( ""/abc/def"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?"" ) , CONST_STR_LEN ( ""/abc?"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d"" ) , CONST_STR_LEN ( ""/abc?d"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d="" ) , CONST_STR_LEN ( ""/abc?d="" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d=e"" ) , CONST_STR_LEN ( ""/abc?d=e"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d=e&"" ) , CONST_STR_LEN ( ""/abc?d=e&"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d=e&f"" ) , CONST_STR_LEN ( ""/abc?d=e&f"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d=e&f=g"" ) , CONST_STR_LEN ( ""/abc?d=e&f=g"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d=e&f=g#"" ) , CONST_STR_LEN ( ""/abc?d=e&f=g"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d=e&f=g#any"" ) , CONST_STR_LEN ( ""/abc?d=e&f=g"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%2F"" ) , CONST_STR_LEN ( ""/%2F"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%2f"" ) , CONST_STR_LEN ( ""/%2F"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%20"" ) , CONST_STR_LEN ( ""/%20"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%2b"" ) , CONST_STR_LEN ( ""/%2B"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%2B"" ) , CONST_STR_LEN ( ""/%2B"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%3a"" ) , CONST_STR_LEN ( ""/%3A"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%3A"" ) , CONST_STR_LEN ( ""/%3A"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/~test%20_"" ) , CONST_STR_LEN ( ""/~test%20%C3%A4_"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/\\375"" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/\\376"" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/\\377"" ) , """" , ( size_t ) - 2 ) ; flags = HTTP_PARSEOPT_URL_NORMALIZE_REQUIRED ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/"" ) , CONST_STR_LEN ( ""/"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc"" ) , CONST_STR_LEN ( ""/abc"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc/"" ) , CONST_STR_LEN ( ""/abc/"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc/def"" ) , CONST_STR_LEN ( ""/abc/def"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?"" ) , CONST_STR_LEN ( ""/abc?"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d"" ) , CONST_STR_LEN ( ""/abc?d"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d="" ) , CONST_STR_LEN ( ""/abc?d="" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d=e"" ) , CONST_STR_LEN ( ""/abc?d=e"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d=e&"" ) , CONST_STR_LEN ( ""/abc?d=e&"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d=e&f"" ) , CONST_STR_LEN ( ""/abc?d=e&f"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d=e&f=g"" ) , CONST_STR_LEN ( ""/abc?d=e&f=g"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d=e&f=g#"" ) , CONST_STR_LEN ( ""/abc?d=e&f=g"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d=e&f=g#any"" ) , CONST_STR_LEN ( ""/abc?d=e&f=g"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%2F"" ) , CONST_STR_LEN ( ""/%2F"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%2f"" ) , CONST_STR_LEN ( ""/%2F"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%20"" ) , CONST_STR_LEN ( ""/%20"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%2b"" ) , CONST_STR_LEN ( ""/+"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%2B"" ) , CONST_STR_LEN ( ""/+"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%3a"" ) , CONST_STR_LEN ( ""/:"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%3A"" ) , CONST_STR_LEN ( ""/:"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/~test%20_"" ) , CONST_STR_LEN ( ""/~test%20%C3%A4_"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/\\375"" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/\\376"" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/\\377"" ) , """" , ( size_t ) - 2 ) ; flags |= HTTP_PARSEOPT_URL_NORMALIZE_CTRLS_REJECT ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/\\a"" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/\\t"" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/\\r"" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/\\177"" ) , """" , ( size_t ) - 2 ) ; # if defined ( __WIN32 ) || defined ( __CYGWIN__ ) flags |= HTTP_PARSEOPT_URL_NORMALIZE_PATH_BACKSLASH_TRANS ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a\\\\b"" ) , CONST_STR_LEN ( ""/a/b"" ) ) ; # endif flags |= HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_DECODE ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/b?c=/"" ) , CONST_STR_LEN ( ""/a/b?c=/"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/b?c=%2f"" ) , CONST_STR_LEN ( ""/a/b?c=/"" ) ) ;  run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a%2fb"" ) , CONST_STR_LEN ( ""/a/b"" ) ) ;  run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a%2Fb"" ) , CONST_STR_LEN ( ""/a/b"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a%2fb?c=/"" ) , CONST_STR_LEN ( ""/a/b?c=/"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a%2fb?c=%2f"" ) , CONST_STR_LEN ( ""/a/b?c=/"" ) ) ; flags &= ~ HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_DECODE ; flags |= HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_REJECT ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a%2fb"" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a%2Fb"" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/b?c=%2f"" ) , CONST_STR_LEN ( ""/a/b?c=/"" ) ) ; flags &= ~ HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_REJECT ; flags |= HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REMOVE ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""./a/b"" ) , CONST_STR_LEN ( ""/a/b"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""../a/b"" ) , CONST_STR_LEN ( ""/a/b"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/./b"" ) , CONST_STR_LEN ( ""/a/b"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/../b"" ) , CONST_STR_LEN ( ""/b"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/b/."" ) , CONST_STR_LEN ( ""/a/b/"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/b/.."" ) , CONST_STR_LEN ( ""/a/"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/../b/.."" ) , CONST_STR_LEN ( ""/"" ) ) ; flags &= ~ HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REMOVE ; flags |= HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REJECT ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""./a/b"" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""../a/b"" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/./b"" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/../b"" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/b/."" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/b/.."" ) , """" , ( size_t ) - 2 ) ; flags &= ~ HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REJECT ; flags |= HTTP_PARSEOPT_URL_NORMALIZE_QUERY_20_PLUS ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/b?c=d+e"" ) , CONST_STR_LEN ( ""/a/b?c=d+e"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/b?c=d%20e"" ) , CONST_STR_LEN ( ""/a/b?c=d+e"" ) ) ; flags &= ~ HTTP_PARSEOPT_URL_NORMALIZE_QUERY_20_PLUS ; buffer_free ( psrc ) ; buffer_free ( ptmp ) ; }","run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a%2fb"" ) , CONST_STR_LEN ( ""/a/b"" ) ) ;run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a%2Fb"" ) , CONST_STR_LEN ( ""/a/b"" ) ) ;",599
818,"buggy line: if ( same_thread_group ( task , current ) ) return 0 ;rcu_read_lock ( ) ;tcred = __task_cred ( task ) ;if ( uid_eq ( cred -> uid , tcred -> euid ) && uid_eq ( cred -> uid , tcred -> suid ) && uid_eq ( cred -> uid , tcred -> uid ) && gid_eq ( cred -> gid , tcred -> egid ) && gid_eq ( cred -> gid , tcred -> sgid ) && gid_eq ( cred -> gid , tcred -> gid ) ) goto ok ;if ( ptrace_has_cap ( tcred -> user_ns , mode ) ) goto ok ;ok : rcu_read_unlock ( ) ;smp_rmb ( ) ;if ( task -> mm ) dumpable = get_dumpable ( task -> mm ) ;rcu_read_lock ( ) ;if ( ! dumpable && ! ptrace_has_cap ( __task_cred ( task ) -> user_ns , mode ) ) {rcu_read_unlock ( ) ;return - EPERM ;cwe id:CWE-264context: static int __ptrace_may_access ( struct task_struct * task , unsigned int mode ) { const struct cred * cred = current_cred ( ) , * tcred ; int dumpable = 0 ; if ( same_thread_group ( task , current ) ) return 0 ; rcu_read_lock ( ) ; tcred = __task_cred ( task ) ; if ( uid_eq ( cred -> uid , tcred -> euid ) && uid_eq ( cred -> uid , tcred -> suid ) && uid_eq ( cred -> uid , tcred -> uid ) && gid_eq ( cred -> gid , tcred -> egid ) && gid_eq ( cred -> gid , tcred -> sgid ) && gid_eq ( cred -> gid , tcred -> gid ) ) goto ok ; if ( ptrace_has_cap ( tcred -> user_ns , mode ) ) goto ok ; rcu_read_unlock ( ) ; return - EPERM ; ok : rcu_read_unlock ( ) ; smp_rmb ( ) ; if ( task -> mm ) dumpable = get_dumpable ( task -> mm ) ; rcu_read_lock ( ) ;  if ( ! dumpable && ! ptrace_has_cap ( __task_cred ( task ) -> user_ns , mode ) ) {  rcu_read_unlock ( ) ; return - EPERM ; } rcu_read_unlock ( ) ; return security_ptrace_access_check ( task , mode ) ; }","if ( dumpable != SUID_DUMP_USER && ! ptrace_has_cap ( __task_cred ( task ) -> user_ns , mode ) ) {",600
819,"buggy line: for ( i = 0 ;i <= w - sizeof ( long ) ;long a = * ( long * ) ( src1 + i ) ;cwe id:CWE-189context: static void add_bytes_l2_c ( uint8_t * dst , uint8_t * src1 , uint8_t * src2 , int w ) { long i ;  for ( i = 0 ; i <= w - sizeof ( long ) ; i += sizeof ( long ) ) {  long a = * ( long * ) ( src1 + i ) ; long b = * ( long * ) ( src2 + i ) ; * ( long * ) ( dst + i ) = ( ( a & pb_7f ) + ( b & pb_7f ) ) ^ ( ( a ^ b ) & pb_80 ) ; } for ( ; i < w ; i ++ ) dst [ i ] = src1 [ i ] + src2 [ i ] ; }",for ( i = 0 ;i <= w - ( int ) sizeof ( long ) ;long a = * ( long * ) ( src1 + i ) ;,601
820,"buggy line: if ( flags & __GFP_ZERO )  memset ( addr , 0 , size ) ;cwe id:CWE-200context: static void * __dma_alloc_coherent ( struct device * dev , size_t size , dma_addr_t * dma_handle , gfp_t flags , struct dma_attrs * attrs ) { if ( dev == NULL ) { WARN_ONCE ( 1 , ""Use<S2SV_blank>an<S2SV_blank>actual<S2SV_blank>device<S2SV_blank>structure<S2SV_blank>for<S2SV_blank>DMA<S2SV_blank>allocation\\n"" ) ; return NULL ; } if ( IS_ENABLED ( CONFIG_ZONE_DMA ) && dev -> coherent_dma_mask <= DMA_BIT_MASK ( 32 ) ) flags |= GFP_DMA ; if ( IS_ENABLED ( CONFIG_DMA_CMA ) && ( flags & __GFP_WAIT ) ) { struct page * page ; void * addr ; size = PAGE_ALIGN ( size ) ; page = dma_alloc_from_contiguous ( dev , size >> PAGE_SHIFT , get_order ( size ) ) ; if ( ! page ) return NULL ; * dma_handle = phys_to_dma ( dev , page_to_phys ( page ) ) ; addr = page_address ( page ) ;  if ( flags & __GFP_ZERO )  memset ( addr , 0 , size ) ; return addr ; } else { return swiotlb_alloc_coherent ( dev , size , dma_handle , flags ) ; } }","memset ( addr , 0 , size ) ;",602
821,"buggy line: int i ;int j ;int rowstep ;if ( jas_matrix_numrows ( matrix ) > 0 && jas_matrix_numcols ( matrix ) > 0 ) {cwe id:CWE-190context: void jas_matrix_clip ( jas_matrix_t * matrix , jas_seqent_t minval , jas_seqent_t maxval ) {  int i ;  int j ; jas_seqent_t v ; jas_seqent_t * rowstart ; jas_seqent_t * data ;  int rowstep ;  if ( jas_matrix_numrows ( matrix ) > 0 && jas_matrix_numcols ( matrix ) > 0 ) { assert ( matrix -> rows_ ) ; rowstep = jas_matrix_rowstep ( matrix ) ; for ( i = matrix -> numrows_ , rowstart = matrix -> rows_ [ 0 ] ; i > 0 ; -- i , rowstart += rowstep ) { data = rowstart ; for ( j = matrix -> numcols_ , data = rowstart ; j > 0 ; -- j , ++ data ) { v = * data ; if ( v < minval ) { * data = minval ; } else if ( v > maxval ) { * data = maxval ; } } } } }",jas_matind_t i ;jas_matind_t j ;jas_matind_t rowstep ;if ( jas_matrix_numrows ( matrix ) > 0 && jas_matrix_numcols ( matrix ) > 0 ) {,603
822,"buggy line: cwe id:CWE-190context: void ihevcd_parse_sei_payload ( codec_t * ps_codec , UWORD32 u4_payload_type , UWORD32 u4_payload_size , WORD8 i1_nal_type ) { parse_ctxt_t * ps_parse = & ps_codec -> s_parse ; bitstrm_t * ps_bitstrm = & ps_parse -> s_bitstrm ; WORD32 payload_bits_remaining = 0 ; sps_t * ps_sps ; UWORD32 i ; for ( i = 0 ; i < MAX_SPS_CNT ; i ++ ) { ps_sps = ps_codec -> ps_sps_base + i ; if ( ps_sps -> i1_sps_valid ) { break ; } } if ( NULL == ps_sps ) { return ; } if ( NAL_PREFIX_SEI == i1_nal_type ) { switch ( u4_payload_type ) { case SEI_BUFFERING_PERIOD : ps_parse -> s_sei_params . i1_sei_parameters_present_flag = 1 ; ihevcd_parse_buffering_period_sei ( ps_codec , ps_sps ) ; break ; case SEI_PICTURE_TIMING : ps_parse -> s_sei_params . i1_sei_parameters_present_flag = 1 ; ihevcd_parse_pic_timing_sei ( ps_codec , ps_sps ) ; break ; case SEI_TIME_CODE : ps_parse -> s_sei_params . i1_sei_parameters_present_flag = 1 ; ihevcd_parse_time_code_sei ( ps_codec ) ; break ; case SEI_MASTERING_DISPLAY_COLOUR_VOLUME : ps_parse -> s_sei_params . i4_sei_mastering_disp_colour_vol_params_present_flags = 1 ; ihevcd_parse_mastering_disp_params_sei ( ps_codec ) ; break ; case SEI_USER_DATA_REGISTERED_ITU_T_T35 : ps_parse -> s_sei_params . i1_sei_parameters_present_flag = 1 ;  ihevcd_parse_user_data_registered_itu_t_t35 ( ps_codec ,   u4_payload_size ) ;  break ; default : for ( i = 0 ; i < u4_payload_size ; i ++ ) { ihevcd_bits_flush ( ps_bitstrm , 8 ) ; } break ; } } else { switch ( u4_payload_type ) { case SEI_USER_DATA_REGISTERED_ITU_T_T35 : ps_parse -> s_sei_params . i1_sei_parameters_present_flag = 1 ;  ihevcd_parse_user_data_registered_itu_t_t35 ( ps_codec ,   u4_payload_size ) ;  break ; default : for ( i = 0 ; i < u4_payload_size ; i ++ ) { ihevcd_bits_flush ( ps_bitstrm , 8 ) ; } break ; } } payload_bits_remaining = ihevcd_bits_num_bits_remaining ( ps_bitstrm ) ; if ( payload_bits_remaining ) { WORD32 final_bits ; WORD32 final_payload_bits = 0 ; WORD32 mask = 0xFF ; UWORD32 u4_dummy ; UWORD32 u4_reserved_payload_extension_data ; UNUSED ( u4_dummy ) ; UNUSED ( u4_reserved_payload_extension_data ) ; while ( payload_bits_remaining > 9 ) { BITS_PARSE ( ""reserved_payload_extension_data"" , u4_reserved_payload_extension_data , ps_bitstrm , 1 ) ; payload_bits_remaining -- ; } final_bits = ihevcd_bits_nxt ( ps_bitstrm , payload_bits_remaining ) ; while ( final_bits & ( mask >> final_payload_bits ) ) { final_payload_bits ++ ; continue ; } while ( payload_bits_remaining > ( 9 - final_payload_bits ) ) { BITS_PARSE ( ""reserved_payload_extension_data"" , u4_reserved_payload_extension_data , ps_bitstrm , 1 ) ; payload_bits_remaining -- ; } BITS_PARSE ( ""payload_bit_equal_to_one"" , u4_dummy , ps_bitstrm , 1 ) ; payload_bits_remaining -- ; while ( payload_bits_remaining ) { BITS_PARSE ( ""payload_bit_equal_to_zero"" , u4_dummy , ps_bitstrm , 1 ) ; payload_bits_remaining -- ; } } return ; }","if ( ps_parse -> s_sei_params . i4_sei_user_data_cnt >= USER_DATA_MAX ) {for ( i = 0 ;i < u4_payload_size / 4 ;i ++ ) {ihevcd_bits_flush ( ps_bitstrm , 4 * 8 ) ;}ihevcd_bits_flush ( ps_bitstrm , ( u4_payload_size - i * 4 ) * 8 ) ;}else {",604
823,"buggy line: ihevcd_parse_user_data_registered_itu_t_t35 ( ps_codec ,   u4_payload_size ) ;break ;cwe id:CWE-190context: void ihevcd_parse_sei_payload ( codec_t * ps_codec , UWORD32 u4_payload_type , UWORD32 u4_payload_size , WORD8 i1_nal_type ) { parse_ctxt_t * ps_parse = & ps_codec -> s_parse ; bitstrm_t * ps_bitstrm = & ps_parse -> s_bitstrm ; WORD32 payload_bits_remaining = 0 ; sps_t * ps_sps ; UWORD32 i ; for ( i = 0 ; i < MAX_SPS_CNT ; i ++ ) { ps_sps = ps_codec -> ps_sps_base + i ; if ( ps_sps -> i1_sps_valid ) { break ; } } if ( NULL == ps_sps ) { return ; } if ( NAL_PREFIX_SEI == i1_nal_type ) { switch ( u4_payload_type ) { case SEI_BUFFERING_PERIOD : ps_parse -> s_sei_params . i1_sei_parameters_present_flag = 1 ; ihevcd_parse_buffering_period_sei ( ps_codec , ps_sps ) ; break ; case SEI_PICTURE_TIMING : ps_parse -> s_sei_params . i1_sei_parameters_present_flag = 1 ; ihevcd_parse_pic_timing_sei ( ps_codec , ps_sps ) ; break ; case SEI_TIME_CODE : ps_parse -> s_sei_params . i1_sei_parameters_present_flag = 1 ; ihevcd_parse_time_code_sei ( ps_codec ) ; break ; case SEI_MASTERING_DISPLAY_COLOUR_VOLUME : ps_parse -> s_sei_params . i4_sei_mastering_disp_colour_vol_params_present_flags = 1 ; ihevcd_parse_mastering_disp_params_sei ( ps_codec ) ; break ; case SEI_USER_DATA_REGISTERED_ITU_T_T35 : ps_parse -> s_sei_params . i1_sei_parameters_present_flag = 1 ;  ihevcd_parse_user_data_registered_itu_t_t35 ( ps_codec ,   u4_payload_size ) ;  break ; default : for ( i = 0 ; i < u4_payload_size ; i ++ ) { ihevcd_bits_flush ( ps_bitstrm , 8 ) ; } break ; } } else { switch ( u4_payload_type ) { case SEI_USER_DATA_REGISTERED_ITU_T_T35 : ps_parse -> s_sei_params . i1_sei_parameters_present_flag = 1 ;  ihevcd_parse_user_data_registered_itu_t_t35 ( ps_codec ,   u4_payload_size ) ;  break ; default : for ( i = 0 ; i < u4_payload_size ; i ++ ) { ihevcd_bits_flush ( ps_bitstrm , 8 ) ; } break ; } } payload_bits_remaining = ihevcd_bits_num_bits_remaining ( ps_bitstrm ) ; if ( payload_bits_remaining ) { WORD32 final_bits ; WORD32 final_payload_bits = 0 ; WORD32 mask = 0xFF ; UWORD32 u4_dummy ; UWORD32 u4_reserved_payload_extension_data ; UNUSED ( u4_dummy ) ; UNUSED ( u4_reserved_payload_extension_data ) ; while ( payload_bits_remaining > 9 ) { BITS_PARSE ( ""reserved_payload_extension_data"" , u4_reserved_payload_extension_data , ps_bitstrm , 1 ) ; payload_bits_remaining -- ; } final_bits = ihevcd_bits_nxt ( ps_bitstrm , payload_bits_remaining ) ; while ( final_bits & ( mask >> final_payload_bits ) ) { final_payload_bits ++ ; continue ; } while ( payload_bits_remaining > ( 9 - final_payload_bits ) ) { BITS_PARSE ( ""reserved_payload_extension_data"" , u4_reserved_payload_extension_data , ps_bitstrm , 1 ) ; payload_bits_remaining -- ; } BITS_PARSE ( ""payload_bit_equal_to_one"" , u4_dummy , ps_bitstrm , 1 ) ; payload_bits_remaining -- ; while ( payload_bits_remaining ) { BITS_PARSE ( ""payload_bit_equal_to_zero"" , u4_dummy , ps_bitstrm , 1 ) ; payload_bits_remaining -- ; } } return ; }","ihevcd_parse_user_data_registered_itu_t_t35 ( ps_codec , u4_payload_size ) ;}break ;",604
824,"buggy line: ihevcd_parse_user_data_registered_itu_t_t35 ( ps_codec ,   u4_payload_size ) ;break ;cwe id:CWE-190context: void ihevcd_parse_sei_payload ( codec_t * ps_codec , UWORD32 u4_payload_type , UWORD32 u4_payload_size , WORD8 i1_nal_type ) { parse_ctxt_t * ps_parse = & ps_codec -> s_parse ; bitstrm_t * ps_bitstrm = & ps_parse -> s_bitstrm ; WORD32 payload_bits_remaining = 0 ; sps_t * ps_sps ; UWORD32 i ; for ( i = 0 ; i < MAX_SPS_CNT ; i ++ ) { ps_sps = ps_codec -> ps_sps_base + i ; if ( ps_sps -> i1_sps_valid ) { break ; } } if ( NULL == ps_sps ) { return ; } if ( NAL_PREFIX_SEI == i1_nal_type ) { switch ( u4_payload_type ) { case SEI_BUFFERING_PERIOD : ps_parse -> s_sei_params . i1_sei_parameters_present_flag = 1 ; ihevcd_parse_buffering_period_sei ( ps_codec , ps_sps ) ; break ; case SEI_PICTURE_TIMING : ps_parse -> s_sei_params . i1_sei_parameters_present_flag = 1 ; ihevcd_parse_pic_timing_sei ( ps_codec , ps_sps ) ; break ; case SEI_TIME_CODE : ps_parse -> s_sei_params . i1_sei_parameters_present_flag = 1 ; ihevcd_parse_time_code_sei ( ps_codec ) ; break ; case SEI_MASTERING_DISPLAY_COLOUR_VOLUME : ps_parse -> s_sei_params . i4_sei_mastering_disp_colour_vol_params_present_flags = 1 ; ihevcd_parse_mastering_disp_params_sei ( ps_codec ) ; break ; case SEI_USER_DATA_REGISTERED_ITU_T_T35 : ps_parse -> s_sei_params . i1_sei_parameters_present_flag = 1 ;  ihevcd_parse_user_data_registered_itu_t_t35 ( ps_codec ,   u4_payload_size ) ;  break ; default : for ( i = 0 ; i < u4_payload_size ; i ++ ) { ihevcd_bits_flush ( ps_bitstrm , 8 ) ; } break ; } } else { switch ( u4_payload_type ) { case SEI_USER_DATA_REGISTERED_ITU_T_T35 : ps_parse -> s_sei_params . i1_sei_parameters_present_flag = 1 ;  ihevcd_parse_user_data_registered_itu_t_t35 ( ps_codec ,   u4_payload_size ) ;  break ; default : for ( i = 0 ; i < u4_payload_size ; i ++ ) { ihevcd_bits_flush ( ps_bitstrm , 8 ) ; } break ; } } payload_bits_remaining = ihevcd_bits_num_bits_remaining ( ps_bitstrm ) ; if ( payload_bits_remaining ) { WORD32 final_bits ; WORD32 final_payload_bits = 0 ; WORD32 mask = 0xFF ; UWORD32 u4_dummy ; UWORD32 u4_reserved_payload_extension_data ; UNUSED ( u4_dummy ) ; UNUSED ( u4_reserved_payload_extension_data ) ; while ( payload_bits_remaining > 9 ) { BITS_PARSE ( ""reserved_payload_extension_data"" , u4_reserved_payload_extension_data , ps_bitstrm , 1 ) ; payload_bits_remaining -- ; } final_bits = ihevcd_bits_nxt ( ps_bitstrm , payload_bits_remaining ) ; while ( final_bits & ( mask >> final_payload_bits ) ) { final_payload_bits ++ ; continue ; } while ( payload_bits_remaining > ( 9 - final_payload_bits ) ) { BITS_PARSE ( ""reserved_payload_extension_data"" , u4_reserved_payload_extension_data , ps_bitstrm , 1 ) ; payload_bits_remaining -- ; } BITS_PARSE ( ""payload_bit_equal_to_one"" , u4_dummy , ps_bitstrm , 1 ) ; payload_bits_remaining -- ; while ( payload_bits_remaining ) { BITS_PARSE ( ""payload_bit_equal_to_zero"" , u4_dummy , ps_bitstrm , 1 ) ; payload_bits_remaining -- ; } } return ; }","if ( ps_parse -> s_sei_params . i4_sei_user_data_cnt >= USER_DATA_MAX ) {for ( i = 0 ;i < u4_payload_size / 4 ;i ++ ) {ihevcd_bits_flush ( ps_bitstrm , 4 * 8 ) ;}ihevcd_bits_flush ( ps_bitstrm , ( u4_payload_size - i * 4 ) * 8 ) ;}else {ihevcd_parse_user_data_registered_itu_t_t35 ( ps_codec , u4_payload_size ) ;}break ;",604
825,"buggy line: priv = kzalloc ( sizeof ( struct cypress_private ) , GFP_KERNEL ) ;if ( ! priv ) return - ENOMEM ;cwe id:CWE-000context: static int cypress_generic_port_probe ( struct usb_serial_port * port ) { struct usb_serial * serial = port -> serial ; struct cypress_private * priv ;  priv = kzalloc ( sizeof ( struct cypress_private ) , GFP_KERNEL ) ;  if ( ! priv ) return - ENOMEM ; priv -> comm_is_ok = ! 0 ; spin_lock_init ( & priv -> lock ) ; if ( kfifo_alloc ( & priv -> write_fifo , CYPRESS_BUF_SIZE , GFP_KERNEL ) ) { kfree ( priv ) ; return - ENOMEM ; } if ( ! is_frwd ( serial -> dev ) ) usb_reset_configuration ( serial -> dev ) ; priv -> cmd_ctrl = 0 ; priv -> line_control = 0 ; priv -> termios_initialized = 0 ; priv -> rx_flags = 0 ; if ( port -> interrupt_out_size > 9 ) priv -> pkt_fmt = packet_format_1 ; else priv -> pkt_fmt = packet_format_2 ; if ( interval > 0 ) { priv -> write_urb_interval = interval ; priv -> read_urb_interval = interval ; dev_dbg ( & port -> dev , ""%s<S2SV_blank>-<S2SV_blank>read<S2SV_blank>&<S2SV_blank>write<S2SV_blank>intervals<S2SV_blank>forced<S2SV_blank>to<S2SV_blank>%d\\n"" , __func__ , interval ) ; } else { priv -> write_urb_interval = port -> interrupt_out_urb -> interval ; priv -> read_urb_interval = port -> interrupt_in_urb -> interval ; dev_dbg ( & port -> dev , ""%s<S2SV_blank>-<S2SV_blank>intervals:<S2SV_blank>read=%d<S2SV_blank>write=%d\\n"" , __func__ , priv -> read_urb_interval , priv -> write_urb_interval ) ; } usb_set_serial_port_data ( port , priv ) ; port -> port . drain_delay = 256 ; return 0 ; }","if ( ! port -> interrupt_out_urb || ! port -> interrupt_in_urb ) {dev_err ( & port -> dev , ""required<S2SV_blank>endpoint<S2SV_blank>is<S2SV_blank>missing\\\return - ENODEV ;}priv = kzalloc ( sizeof ( struct cypress_private ) , GFP_KERNEL ) ;if ( ! priv ) return - ENOMEM ;",605
826,"buggy line: if ( ret < 0 ) goto bail ;if ( ret < 0 )  goto bail ;dd -> sdma_rht = tmp_sdma_rht ;dd_dev_info ( dd , ""SDMA<S2SV_blank>num_sdma:<S2SV_blank>%u\\\cwe id:CWE-401context: int sdma_init ( struct hfi1_devdata * dd , u8 port ) { unsigned this_idx ; struct sdma_engine * sde ; struct rhashtable * tmp_sdma_rht ; u16 descq_cnt ; void * curr_head ; struct hfi1_pportdata * ppd = dd -> pport + port ; u32 per_sdma_credits ; uint idle_cnt = sdma_idle_cnt ; size_t num_engines = chip_sdma_engines ( dd ) ; int ret = - ENOMEM ; if ( ! HFI1_CAP_IS_KSET ( SDMA ) ) { HFI1_CAP_CLEAR ( SDMA_AHG ) ; return 0 ; } if ( mod_num_sdma && mod_num_sdma <= chip_sdma_engines ( dd ) && mod_num_sdma >= num_vls ) num_engines = mod_num_sdma ; dd_dev_info ( dd , ""SDMA<S2SV_blank>mod_num_sdma:<S2SV_blank>%u\\n"" , mod_num_sdma ) ; dd_dev_info ( dd , ""SDMA<S2SV_blank>chip_sdma_engines:<S2SV_blank>%u\\n"" , chip_sdma_engines ( dd ) ) ; dd_dev_info ( dd , ""SDMA<S2SV_blank>chip_sdma_mem_size:<S2SV_blank>%u\\n"" , chip_sdma_mem_size ( dd ) ) ; per_sdma_credits = chip_sdma_mem_size ( dd ) / ( num_engines * SDMA_BLOCK_SIZE ) ; init_waitqueue_head ( & dd -> sdma_unfreeze_wq ) ; atomic_set ( & dd -> sdma_unfreeze_count , 0 ) ; descq_cnt = sdma_get_descq_cnt ( ) ; dd_dev_info ( dd , ""SDMA<S2SV_blank>engines<S2SV_blank>%zu<S2SV_blank>descq_cnt<S2SV_blank>%u\\n"" , num_engines , descq_cnt ) ; dd -> per_sdma = kcalloc_node ( num_engines , sizeof ( * dd -> per_sdma ) , GFP_KERNEL , dd -> node ) ; if ( ! dd -> per_sdma ) return ret ; idle_cnt = ns_to_cclock ( dd , idle_cnt ) ; if ( idle_cnt ) dd -> default_desc1 = SDMA_DESC1_HEAD_TO_HOST_FLAG ; else dd -> default_desc1 = SDMA_DESC1_INT_REQ_FLAG ; if ( ! sdma_desct_intr ) sdma_desct_intr = SDMA_DESC_INTR ; for ( this_idx = 0 ; this_idx < num_engines ; ++ this_idx ) { sde = & dd -> per_sdma [ this_idx ] ; sde -> dd = dd ; sde -> ppd = ppd ; sde -> this_idx = this_idx ; sde -> descq_cnt = descq_cnt ; sde -> desc_avail = sdma_descq_freecnt ( sde ) ; sde -> sdma_shift = ilog2 ( descq_cnt ) ; sde -> sdma_mask = ( 1 << sde -> sdma_shift ) - 1 ; sde -> int_mask = ( u64 ) 1 << ( 0 * TXE_NUM_SDMA_ENGINES + this_idx ) ; sde -> progress_mask = ( u64 ) 1 << ( 1 * TXE_NUM_SDMA_ENGINES + this_idx ) ; sde -> idle_mask = ( u64 ) 1 << ( 2 * TXE_NUM_SDMA_ENGINES + this_idx ) ; sde -> imask = sde -> int_mask | sde -> progress_mask | sde -> idle_mask ; spin_lock_init ( & sde -> tail_lock ) ; seqlock_init ( & sde -> head_lock ) ; spin_lock_init ( & sde -> senddmactrl_lock ) ; spin_lock_init ( & sde -> flushlist_lock ) ; seqlock_init ( & sde -> waitlock ) ; sde -> ahg_bits = 0xfffffffe00000000ULL ; sdma_set_state ( sde , sdma_state_s00_hw_down ) ; kref_init ( & sde -> state . kref ) ; init_completion ( & sde -> state . comp ) ; INIT_LIST_HEAD ( & sde -> flushlist ) ; INIT_LIST_HEAD ( & sde -> dmawait ) ; sde -> tail_csr = get_kctxt_csr_addr ( dd , this_idx , SD ( TAIL ) ) ; tasklet_init ( & sde -> sdma_hw_clean_up_task , sdma_hw_clean_up_task , ( unsigned long ) sde ) ; tasklet_init ( & sde -> sdma_sw_clean_up_task , sdma_sw_clean_up_task , ( unsigned long ) sde ) ; INIT_WORK ( & sde -> err_halt_worker , sdma_err_halt_wait ) ; INIT_WORK ( & sde -> flush_worker , sdma_field_flush ) ; sde -> progress_check_head = 0 ; timer_setup ( & sde -> err_progress_check_timer , sdma_err_progress_check , 0 ) ; sde -> descq = dma_alloc_coherent ( & dd -> pcidev -> dev , descq_cnt * sizeof ( u64 [ 2 ] ) , & sde -> descq_phys , GFP_KERNEL ) ; if ( ! sde -> descq ) goto bail ; sde -> tx_ring = kvzalloc_node ( array_size ( descq_cnt , sizeof ( struct sdma_txreq * ) ) , GFP_KERNEL , dd -> node ) ; if ( ! sde -> tx_ring ) goto bail ; } dd -> sdma_heads_size = L1_CACHE_BYTES * num_engines ; dd -> sdma_heads_dma = dma_alloc_coherent ( & dd -> pcidev -> dev , dd -> sdma_heads_size , & dd -> sdma_heads_phys , GFP_KERNEL ) ; if ( ! dd -> sdma_heads_dma ) { dd_dev_err ( dd , ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>SendDMA<S2SV_blank>head<S2SV_blank>memory\\n"" ) ; goto bail ; } dd -> sdma_pad_dma = dma_alloc_coherent ( & dd -> pcidev -> dev , sizeof ( u32 ) , & dd -> sdma_pad_phys , GFP_KERNEL ) ; if ( ! dd -> sdma_pad_dma ) { dd_dev_err ( dd , ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>SendDMA<S2SV_blank>pad<S2SV_blank>memory\\n"" ) ; goto bail ; } curr_head = ( void * ) dd -> sdma_heads_dma ; for ( this_idx = 0 ; this_idx < num_engines ; ++ this_idx ) { unsigned long phys_offset ; sde = & dd -> per_sdma [ this_idx ] ; sde -> head_dma = curr_head ; curr_head += L1_CACHE_BYTES ; phys_offset = ( unsigned long ) sde -> head_dma - ( unsigned long ) dd -> sdma_heads_dma ; sde -> head_phys = dd -> sdma_heads_phys + phys_offset ; init_sdma_regs ( sde , per_sdma_credits , idle_cnt ) ; } dd -> flags |= HFI1_HAS_SEND_DMA ; dd -> flags |= idle_cnt ? HFI1_HAS_SDMA_TIMEOUT : 0 ; dd -> num_sdma = num_engines ; ret = sdma_map_init ( dd , port , ppd -> vls_operational , NULL ) ; if ( ret < 0 ) goto bail ; tmp_sdma_rht = kzalloc ( sizeof ( * tmp_sdma_rht ) , GFP_KERNEL ) ; if ( ! tmp_sdma_rht ) { ret = - ENOMEM ; goto bail ; } ret = rhashtable_init ( tmp_sdma_rht , & sdma_rht_params ) ;  if ( ret < 0 )  goto bail ;  dd -> sdma_rht = tmp_sdma_rht ;  dd_dev_info ( dd , ""SDMA<S2SV_blank>num_sdma:<S2SV_blank>%u\\n"" , dd -> num_sdma ) ; return 0 ; bail : sdma_clean ( dd , num_engines ) ; return ret ; }","if ( ret < 0 ) {kfree ( tmp_sdma_rht ) ;goto bail ;}if ( ret < 0 ) goto bail ;dd -> sdma_rht = tmp_sdma_rht ;dd_dev_info ( dd , ""SDMA<S2SV_blank>num_sdma:<S2SV_blank>%u\\\",606
827,buggy line: put_device ( & dev -> dev ) ;return 0 ;cwe id:CWE-416context: static int snd_seq_device_dev_free ( struct snd_device * device ) { struct snd_seq_device * dev = device -> device_data ;  put_device ( & dev -> dev ) ;  return 0 ; },cancel_autoload_drivers ( ) ;put_device ( & dev -> dev ) ;return 0 ;,607
828,"buggy line: int mi_repair_parallel ( MI_CHECK * param , register MI_INFO * info ,  const char * name , int rep_quick )  {cwe id:CWE-362context: int mi_repair_parallel ( MI_CHECK * param , register MI_INFO * info ,  const char * name , int rep_quick )  { int got_error ; uint i , key , total_key_length , istep ; ulong rec_length ; ha_rows start_records ; my_off_t new_header_length , del ; File new_file ; MI_SORT_PARAM * sort_param = 0 ; MYISAM_SHARE * share = info -> s ; ulong * rec_per_key_part ; HA_KEYSEG * keyseg ; char llbuff [ 22 ] ; IO_CACHE new_data_cache ; IO_CACHE_SHARE io_share ; SORT_INFO sort_info ; ulonglong UNINIT_VAR ( key_map ) ; pthread_attr_t thr_attr ; ulong max_pack_reclength ; int error ; DBUG_ENTER ( ""mi_repair_parallel"" ) ; start_records = info -> state -> records ; got_error = 1 ; new_file = - 1 ; new_header_length = ( param -> testflag & T_UNPACK ) ? 0 : share -> pack . header_length ; if ( ! ( param -> testflag & T_SILENT ) ) { printf ( ""-<S2SV_blank>parallel<S2SV_blank>recovering<S2SV_blank>(with<S2SV_blank>sort)<S2SV_blank>MyISAM-table<S2SV_blank>\'%s\'\\n"" , name ) ; printf ( ""Data<S2SV_blank>records:<S2SV_blank>%s\\n"" , llstr ( start_records , llbuff ) ) ; } param -> testflag |= T_REP ; if ( info -> s -> options & ( HA_OPTION_CHECKSUM | HA_OPTION_COMPRESS_RECORD ) ) param -> testflag |= T_CALC_CHECKSUM ; DBUG_PRINT ( ""info"" , ( ""is<S2SV_blank>quick<S2SV_blank>repair:<S2SV_blank>%d"" , rep_quick ) ) ; bzero ( ( char * ) & sort_info , sizeof ( sort_info ) ) ; mysql_mutex_init ( mi_key_mutex_MI_SORT_INFO_mutex , & sort_info . mutex , MY_MUTEX_INIT_FAST ) ; mysql_cond_init ( mi_key_cond_MI_SORT_INFO_cond , & sort_info . cond , 0 ) ; mysql_mutex_init ( mi_key_mutex_MI_CHECK_print_msg , & param -> print_msg_mutex , MY_MUTEX_INIT_FAST ) ; param -> need_print_msg_lock = 1 ; if ( ! ( sort_info . key_block = alloc_key_blocks ( param , ( uint ) param -> sort_key_blocks , share -> base . max_key_block_length ) ) || init_io_cache ( & param -> read_cache , info -> dfile , ( uint ) param -> read_buffer_length , READ_CACHE , share -> pack . header_length , 1 , MYF ( MY_WME ) ) || ( ! rep_quick && ( init_io_cache ( & info -> rec_cache , info -> dfile , ( uint ) param -> write_buffer_length , WRITE_CACHE , new_header_length , 1 , MYF ( MY_WME | MY_WAIT_IF_FULL ) & param -> myf_rw ) || init_io_cache ( & new_data_cache , - 1 , ( uint ) param -> write_buffer_length , READ_CACHE , new_header_length , 1 , MYF ( MY_WME | MY_DONT_CHECK_FILESIZE ) ) ) ) ) goto err ; sort_info . key_block_end = sort_info . key_block + param -> sort_key_blocks ; info -> opt_flag |= WRITE_CACHE_USED ; info -> rec_cache . file = info -> dfile ; if ( ! rep_quick ) { if ( ( new_file = mysql_file_create ( mi_key_file_datatmp , fn_format ( param -> temp_filename , share -> data_file_name , """" , DATA_TMP_EXT , 2 + 4 ) , 0 , param -> tmpfile_createflag , MYF ( 0 ) ) ) < 0 ) { mi_check_print_error ( param , ""Can\'t<S2SV_blank>create<S2SV_blank>new<S2SV_blank>tempfile:<S2SV_blank>\'%s\'"" , param -> temp_filename ) ; goto err ; } if ( new_header_length && filecopy ( param , new_file , info -> dfile , 0L , new_header_length , ""datafile-header"" ) ) goto err ; if ( param -> testflag & T_UNPACK ) { share -> options &= ~ HA_OPTION_COMPRESS_RECORD ; mi_int2store ( share -> state . header . options , share -> options ) ; } share -> state . dellink = HA_OFFSET_ERROR ; info -> rec_cache . file = new_file ; } info -> update = ( short ) ( HA_STATE_CHANGED | HA_STATE_ROW_CHANGED ) ; mi_drop_all_indexes ( param , info , FALSE ) ; key_map = share -> state . key_map ; if ( param -> testflag & T_CREATE_MISSING_KEYS ) { key_map = ~ key_map ; } sort_info . info = info ; sort_info . param = param ; set_data_file_type ( & sort_info , share ) ; sort_info . dupp = 0 ; sort_info . buff = 0 ; param -> read_cache . end_of_file = sort_info . filelength = mysql_file_seek ( param -> read_cache . file , 0L , MY_SEEK_END , MYF ( 0 ) ) ; if ( share -> data_file_type == DYNAMIC_RECORD ) rec_length = max ( share -> base . min_pack_length + 1 , share -> base . min_block_length ) ; else if ( share -> data_file_type == COMPRESSED_RECORD ) rec_length = share -> base . min_block_length ; else rec_length = share -> base . pack_reclength ; sort_info . max_records = ( ( param -> testflag & T_CREATE_MISSING_KEYS ) ? info -> state -> records + 1 : ( ha_rows ) ( sort_info . filelength / rec_length + 1 ) ) ; del = info -> state -> del ; param -> glob_crc = 0 ; max_pack_reclength = share -> base . pack_reclength ; if ( share -> options & HA_OPTION_COMPRESS_RECORD ) set_if_bigger ( max_pack_reclength , share -> max_pack_length ) ; if ( ! ( sort_param = ( MI_SORT_PARAM * ) my_malloc ( ( uint ) share -> base . keys * ( sizeof ( MI_SORT_PARAM ) + max_pack_reclength ) , MYF ( MY_ZEROFILL ) ) ) ) { mi_check_print_error ( param , ""Not<S2SV_blank>enough<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>key!"" ) ; goto err ; } total_key_length = 0 ; rec_per_key_part = param -> rec_per_key_part ; info -> state -> records = info -> state -> del = share -> state . split = 0 ; info -> state -> empty = 0 ; for ( i = key = 0 , istep = 1 ; key < share -> base . keys ; rec_per_key_part += sort_param [ i ] . keyinfo -> keysegs , i += istep , key ++ ) { sort_param [ i ] . key = key ; sort_param [ i ] . keyinfo = share -> keyinfo + key ; sort_param [ i ] . seg = sort_param [ i ] . keyinfo -> seg ; if ( ! mi_is_key_active ( key_map , key ) ) { memcpy ( ( char * ) rec_per_key_part , ( char * ) ( share -> state . rec_per_key_part + ( uint ) ( rec_per_key_part - param -> rec_per_key_part ) ) , sort_param [ i ] . keyinfo -> keysegs * sizeof ( * rec_per_key_part ) ) ; istep = 0 ; continue ; } istep = 1 ; if ( ( ! ( param -> testflag & T_SILENT ) ) ) printf ( ""-<S2SV_blank>Fixing<S2SV_blank>index<S2SV_blank>%d\\n"" , key + 1 ) ; if ( sort_param [ i ] . keyinfo -> flag & HA_FULLTEXT ) { sort_param [ i ] . key_read = sort_ft_key_read ; sort_param [ i ] . key_write = sort_ft_key_write ; } else { sort_param [ i ] . key_read = sort_key_read ; sort_param [ i ] . key_write = sort_key_write ; } sort_param [ i ] . key_cmp = sort_key_cmp ; sort_param [ i ] . lock_in_memory = lock_memory ; sort_param [ i ] . tmpdir = param -> tmpdir ; sort_param [ i ] . sort_info = & sort_info ; sort_param [ i ] . master = 0 ; sort_param [ i ] . fix_datafile = 0 ; sort_param [ i ] . calc_checksum = 0 ; sort_param [ i ] . filepos = new_header_length ; sort_param [ i ] . max_pos = sort_param [ i ] . pos = share -> pack . header_length ; sort_param [ i ] . record = ( ( ( uchar * ) ( sort_param + share -> base . keys ) ) + ( max_pack_reclength * i ) ) ; if ( ! mi_alloc_rec_buff ( info , - 1 , & sort_param [ i ] . rec_buff ) ) { mi_check_print_error ( param , ""Not<S2SV_blank>enough<S2SV_blank>memory!"" ) ; goto err ; } sort_param [ i ] . key_length = share -> rec_reflength ; for ( keyseg = sort_param [ i ] . seg ; keyseg -> type != HA_KEYTYPE_END ; keyseg ++ ) { sort_param [ i ] . key_length += keyseg -> length ; if ( keyseg -> flag & HA_SPACE_PACK ) sort_param [ i ] . key_length += get_pack_length ( keyseg -> length ) ; if ( keyseg -> flag & ( HA_BLOB_PART | HA_VAR_LENGTH_PART ) ) sort_param [ i ] . key_length += 2 + test ( keyseg -> length >= 127 ) ; if ( keyseg -> flag & HA_NULL_PART ) sort_param [ i ] . key_length ++ ; } total_key_length += sort_param [ i ] . key_length ; if ( sort_param [ i ] . keyinfo -> flag & HA_FULLTEXT ) { uint ft_max_word_len_for_sort = FT_MAX_WORD_LEN_FOR_SORT * sort_param [ i ] . keyinfo -> seg -> charset -> mbmaxlen ; sort_param [ i ] . key_length += ft_max_word_len_for_sort - HA_FT_MAXBYTELEN ; init_alloc_root ( & sort_param [ i ] . wordroot , FTPARSER_MEMROOT_ALLOC_SIZE , 0 ) ; } } sort_info . total_keys = i ; sort_param [ 0 ] . master = 1 ; sort_param [ 0 ] . fix_datafile = ( my_bool ) ( ! rep_quick ) ; sort_param [ 0 ] . calc_checksum = test ( param -> testflag & T_CALC_CHECKSUM ) ; if ( ! ftparser_alloc_param ( info ) ) goto err ; sort_info . got_error = 0 ; mysql_mutex_lock ( & sort_info . mutex ) ; if ( i > 1 ) { if ( rep_quick ) init_io_cache_share ( & param -> read_cache , & io_share , NULL , i ) ; else init_io_cache_share ( & new_data_cache , & io_share , & info -> rec_cache , i ) ; } else io_share . total_threads = 0 ; ( void ) pthread_attr_init ( & thr_attr ) ; ( void ) pthread_attr_setdetachstate ( & thr_attr , PTHREAD_CREATE_DETACHED ) ; for ( i = 0 ; i < sort_info . total_keys ; i ++ ) { sort_param [ i ] . read_cache = ( ( rep_quick || ! i ) ? param -> read_cache : new_data_cache ) ; DBUG_PRINT ( ""io_cache_share"" , ( ""thread:<S2SV_blank>%u<S2SV_blank><S2SV_blank>read_cache:<S2SV_blank>0x%lx"" , i , ( long ) & sort_param [ i ] . read_cache ) ) ; sort_param [ i ] . sortbuff_size = # ifndef USING_SECOND_APPROACH param -> sort_buffer_length / sort_info . total_keys ; # else param -> sort_buffer_length * sort_param [ i ] . key_length / total_key_length ; # endif if ( ( error = mysql_thread_create ( mi_key_thread_find_all_keys , & sort_param [ i ] . thr , & thr_attr , thr_find_all_keys , ( void * ) ( sort_param + i ) ) ) ) { mi_check_print_error ( param , ""Cannot<S2SV_blank>start<S2SV_blank>a<S2SV_blank>repair<S2SV_blank>thread<S2SV_blank>(errno=<S2SV_blank>%d)"" , error ) ; if ( io_share . total_threads ) remove_io_thread ( & sort_param [ i ] . read_cache ) ; DBUG_PRINT ( ""error"" , ( ""Cannot<S2SV_blank>start<S2SV_blank>a<S2SV_blank>repair<S2SV_blank>thread"" ) ) ; sort_info . got_error = 1 ; } else sort_info . threads_running ++ ; } ( void ) pthread_attr_destroy ( & thr_attr ) ; while ( sort_info . threads_running ) mysql_cond_wait ( & sort_info . cond , & sort_info . mutex ) ; mysql_mutex_unlock ( & sort_info . mutex ) ; if ( ( got_error = thr_write_keys ( sort_param ) ) ) { param -> retry_repair = 1 ; goto err ; } got_error = 1 ; if ( sort_param [ 0 ] . fix_datafile ) { if ( write_data_suffix ( & sort_info , 1 ) || end_io_cache ( & info -> rec_cache ) ) goto err ; if ( param -> testflag & T_SAFE_REPAIR ) { if ( info -> state -> records + 1 < start_records ) { info -> state -> records = start_records ; goto err ; } } share -> state . state . data_file_length = info -> state -> data_file_length = sort_param -> filepos ; share -> state . version = ( ulong ) time ( ( time_t * ) 0 ) ; mysql_file_close ( info -> dfile , MYF ( 0 ) ) ; info -> dfile = new_file ; share -> data_file_type = sort_info . new_data_file_type ; share -> pack . header_length = ( ulong ) new_header_length ; } else info -> state -> data_file_length = sort_param -> max_pos ; if ( rep_quick && del + sort_info . dupp != info -> state -> del ) { mi_check_print_error ( param , ""Couldn\'t<S2SV_blank>fix<S2SV_blank>table<S2SV_blank>with<S2SV_blank>quick<S2SV_blank>recovery:<S2SV_blank>Found<S2SV_blank>wrong<S2SV_blank>number<S2SV_blank>of<S2SV_blank>deleted<S2SV_blank>records"" ) ; mi_check_print_error ( param , ""Run<S2SV_blank>recovery<S2SV_blank>again<S2SV_blank>without<S2SV_blank>-q"" ) ; param -> retry_repair = 1 ; param -> testflag |= T_RETRY_WITHOUT_QUICK ; goto err ; } if ( rep_quick & T_FORCE_UNIQUENESS ) { my_off_t skr = info -> state -> data_file_length + ( share -> options & HA_OPTION_COMPRESS_RECORD ? MEMMAP_EXTRA_MARGIN : 0 ) ; # ifdef USE_RELOC if ( share -> data_file_type == STATIC_RECORD && skr < share -> base . reloc * share -> base . min_pack_length ) skr = share -> base . reloc * share -> base . min_pack_length ; # endif if ( skr != sort_info . filelength ) if ( mysql_file_chsize ( info -> dfile , skr , 0 , MYF ( 0 ) ) ) mi_check_print_warning ( param , ""Can\'t<S2SV_blank>change<S2SV_blank>size<S2SV_blank>of<S2SV_blank>datafile,<S2SV_blank><S2SV_blank>error:<S2SV_blank>%d"" , my_errno ) ; } if ( param -> testflag & T_CALC_CHECKSUM ) info -> state -> checksum = param -> glob_crc ; if ( mysql_file_chsize ( share -> kfile , info -> state -> key_file_length , 0 , MYF ( 0 ) ) ) mi_check_print_warning ( param , ""Can\'t<S2SV_blank>change<S2SV_blank>size<S2SV_blank>of<S2SV_blank>indexfile,<S2SV_blank>error:<S2SV_blank>%d"" , my_errno ) ; if ( ! ( param -> testflag & T_SILENT ) ) { if ( start_records != info -> state -> records ) printf ( ""Data<S2SV_blank>records:<S2SV_blank>%s\\n"" , llstr ( info -> state -> records , llbuff ) ) ; if ( sort_info . dupp ) mi_check_print_warning ( param , ""%s<S2SV_blank>records<S2SV_blank>have<S2SV_blank>been<S2SV_blank>removed"" , llstr ( sort_info . dupp , llbuff ) ) ; } got_error = 0 ; if ( & share -> state . state != info -> state ) memcpy ( & share -> state . state , info -> state , sizeof ( * info -> state ) ) ; err : got_error |= flush_blocks ( param , share -> key_cache , share -> kfile ) ; ( void ) end_io_cache ( & info -> rec_cache ) ; if ( ! rep_quick ) ( void ) end_io_cache ( & new_data_cache ) ; if ( ! got_error ) { if ( new_file >= 0 ) {  mysql_file_close ( new_file , MYF ( 0 ) ) ;  info -> dfile = new_file = - 1 ; if ( change_to_newfile ( share -> data_file_name , MI_NAME_DEXT , DATA_TMP_EXT ,  ( param -> testflag & T_BACKUP_DATA ?  MYF ( MY_REDEL_MAKE_BACKUP ) : MYF ( 0 ) ) ) || mi_open_datafile ( info , share , name , - 1 ) ) got_error = 1 ; } } if ( got_error ) { if ( ! param -> error_printed ) mi_check_print_error ( param , ""%d<S2SV_blank>when<S2SV_blank>fixing<S2SV_blank>table"" , my_errno ) ; if ( new_file >= 0 ) { ( void ) mysql_file_close ( new_file , MYF ( 0 ) ) ; ( void ) mysql_file_delete ( mi_key_file_datatmp , param -> temp_filename , MYF ( MY_WME ) ) ; if ( info -> dfile == new_file ) if ( unlikely ( mi_open_datafile ( info , share , name , - 1 ) ) ) param -> retry_repair = 0 ; } mi_mark_crashed_on_repair ( info ) ; } else if ( key_map == share -> state . key_map ) share -> state . changed &= ~ STATE_NOT_OPTIMIZED_KEYS ; share -> state . changed |= STATE_NOT_SORTED_PAGES ; mysql_cond_destroy ( & sort_info . cond ) ; mysql_mutex_destroy ( & sort_info . mutex ) ; mysql_mutex_destroy ( & param -> print_msg_mutex ) ; param -> need_print_msg_lock = 0 ; my_free ( sort_info . ft_buf ) ; my_free ( sort_info . key_block ) ; my_free ( sort_param ) ; my_free ( sort_info . buff ) ; ( void ) end_io_cache ( & param -> read_cache ) ; info -> opt_flag &= ~ ( READ_CACHE_USED | WRITE_CACHE_USED ) ; if ( ! got_error && ( param -> testflag & T_UNPACK ) ) { share -> state . header . options [ 0 ] &= ( uchar ) ~ HA_OPTION_COMPRESS_RECORD ; share -> pack . header_length = 0 ; } DBUG_RETURN ( got_error ) ; }","int mi_repair_parallel ( MI_CHECK * param , register MI_INFO * info , const char * name , int rep_quick , my_bool no_copy_stat ) {",608
829,"buggy line: if ( ( new_file = mysql_file_create ( mi_key_file_datatmp , fn_format ( param -> temp_filename , share -> data_file_name , """" , DATA_TMP_EXT , 2 + 4 ) , 0 , param -> tmpfile_createflag , MYF ( 0 ) ) ) < 0 ) {mi_check_print_error ( param , ""Can\\\'t<S2SV_blank>create<S2SV_blank>new<S2SV_blank>tempfile:<S2SV_blank>\\\'%s\\\'"" , param -> temp_filename ) ;goto err ;}if ( new_header_length && filecopy ( param , new_file , info -> dfile , 0L , new_header_length , ""datafile-header"" ) ) goto err ;if ( param -> testflag & T_UNPACK ) {share -> options &= ~ HA_OPTION_COMPRESS_RECORD ;mi_int2store ( share -> state . header . options , share -> options ) ;}share -> state . dellink = HA_OFFSET_ERROR ;info -> rec_cache . file = new_file ;}info -> update = ( short ) ( HA_STATE_CHANGED | HA_STATE_ROW_CHANGED ) ;mi_drop_all_indexes ( param , info , FALSE ) ;key_map = share -> state . key_map ;if ( param -> testflag & T_CREATE_MISSING_KEYS ) {key_map = ~ key_map ;}sort_info . info = info ;sort_info . param = param ;set_data_file_type ( & sort_info , share ) ;sort_info . dupp = 0 ;sort_info . buff = 0 ;param -> read_cache . end_of_file = sort_info . filelength = mysql_file_seek ( param -> read_cache . file , 0L , MY_SEEK_END , MYF ( 0 ) ) ;if ( share -> data_file_type == DYNAMIC_RECORD ) rec_length = max ( share -> base . min_pack_length + 1 , share -> base . min_block_length ) ;else if ( share -> data_file_type == COMPRESSED_RECORD ) rec_length = share -> base . min_block_length ;else rec_length = share -> base . pack_reclength ;sort_info . max_records = ( ( param -> testflag & T_CREATE_MISSING_KEYS ) ? info -> state -> records + 1 : ( ha_rows ) ( sort_info . filelength / rec_length + 1 ) ) ;del = info -> state -> del ;param -> glob_crc = 0 ;max_pack_reclength = share -> base . pack_reclength ;if ( share -> options & HA_OPTION_COMPRESS_RECORD ) set_if_bigger ( max_pack_reclength , share -> max_pack_length ) ;if ( ! ( sort_param = ( MI_SORT_PARAM * ) my_malloc ( ( uint ) share -> base . keys * ( sizeof ( MI_SORT_PARAM ) + max_pack_reclength ) , MYF ( MY_ZEROFILL ) ) ) ) {mi_check_print_error ( param , ""Not<S2SV_blank>enough<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>key!"" ) ;goto err ;}total_key_length = 0 ;rec_per_key_part = param -> rec_per_key_part ;info -> state -> records = info -> state -> del = share -> state . split = 0 ;info -> state -> empty = 0 ;for ( i = key = 0 , istep = 1 ;key < share -> base . keys ;rec_per_key_part += sort_param [ i ] . keyinfo -> keysegs , i += istep , key ++ ) {sort_param [ i ] . key = key ;sort_param [ i ] . keyinfo = share -> keyinfo + key ;sort_param [ i ] . seg = sort_param [ i ] . keyinfo -> seg ;if ( ! mi_is_key_active ( key_map , key ) ) {memcpy ( ( char * ) rec_per_key_part , ( char * ) ( share -> state . rec_per_key_part + ( uint ) ( rec_per_key_part - param -> rec_per_key_part ) ) , sort_param [ i ] . keyinfo -> keysegs * sizeof ( * rec_per_key_part ) ) ;istep = 0 ;continue ;}istep = 1 ;if ( ( ! ( param -> testflag & T_SILENT ) ) ) printf ( ""-<S2SV_blank>Fixing<S2SV_blank>index<S2SV_blank>%d\\\if ( sort_param [ i ] . keyinfo -> flag & HA_FULLTEXT ) {sort_param [ i ] . key_read = sort_ft_key_read ;sort_param [ i ] . key_write = sort_ft_key_write ;}else {sort_param [ i ] . key_read = sort_key_read ;sort_param [ i ] . key_write = sort_key_write ;}sort_param [ i ] . key_cmp = sort_key_cmp ;sort_param [ i ] . lock_in_memory = lock_memory ;sort_param [ i ] . tmpdir = param -> tmpdir ;sort_param [ i ] . sort_info = & sort_info ;sort_param [ i ] . master = 0 ;sort_param [ i ] . fix_datafile = 0 ;sort_param [ i ] . calc_checksum = 0 ;sort_param [ i ] . filepos = new_header_length ;sort_param [ i ] . max_pos = sort_param [ i ] . pos = share -> pack . header_length ;sort_param [ i ] . record = ( ( ( uchar * ) ( sort_param + share -> base . keys ) ) + ( max_pack_reclength * i ) ) ;if ( ! mi_alloc_rec_buff ( info , - 1 , & sort_param [ i ] . rec_buff ) ) {mi_check_print_error ( param , ""Not<S2SV_blank>enough<S2SV_blank>memory!"" ) ;goto err ;}sort_param [ i ] . key_length = share -> rec_reflength ;for ( keyseg = sort_param [ i ] . seg ;keyseg -> type != HA_KEYTYPE_END ;keyseg ++ ) {sort_param [ i ] . key_length += keyseg -> length ;if ( keyseg -> flag & HA_SPACE_PACK ) sort_param [ i ] . key_length += get_pack_length ( keyseg -> length ) ;if ( keyseg -> flag & ( HA_BLOB_PART | HA_VAR_LENGTH_PART ) ) sort_param [ i ] . key_length += 2 + test ( keyseg -> length >= 127 ) ;if ( keyseg -> flag & HA_NULL_PART ) sort_param [ i ] . key_length ++ ;}total_key_length += sort_param [ i ] . key_length ;if ( sort_param [ i ] . keyinfo -> flag & HA_FULLTEXT ) {uint ft_max_word_len_for_sort = FT_MAX_WORD_LEN_FOR_SORT * sort_param [ i ] . keyinfo -> seg -> charset -> mbmaxlen ;sort_param [ i ] . key_length += ft_max_word_len_for_sort - HA_FT_MAXBYTELEN ;init_alloc_root ( & sort_param [ i ] . wordroot , FTPARSER_MEMROOT_ALLOC_SIZE , 0 ) ;}}sort_info . total_keys = i ;sort_param [ 0 ] . master = 1 ;sort_param [ 0 ] . fix_datafile = ( my_bool ) ( ! rep_quick ) ;sort_param [ 0 ] . calc_checksum = test ( param -> testflag & T_CALC_CHECKSUM ) ;if ( ! ftparser_alloc_param ( info ) ) goto err ;sort_info . got_error = 0 ;mysql_mutex_lock ( & sort_info . mutex ) ;if ( i > 1 ) {if ( rep_quick ) init_io_cache_share ( & param -> read_cache , & io_share , NULL , i ) ;else init_io_cache_share ( & new_data_cache , & io_share , & info -> rec_cache , i ) ;}else io_share . total_threads = 0 ;( void ) pthread_attr_init ( & thr_attr ) ;( void ) pthread_attr_setdetachstate ( & thr_attr , PTHREAD_CREATE_DETACHED ) ;for ( i = 0 ;i < sort_info . total_keys ;i ++ ) {sort_param [ i ] . read_cache = ( ( rep_quick || ! i ) ? param -> read_cache : new_data_cache ) ;DBUG_PRINT ( ""io_cache_share"" , ( ""thread:<S2SV_blank>%u<S2SV_blank><S2SV_blank>read_cache:<S2SV_blank>0x%lx"" , i , ( long ) & sort_param [ i ] . read_cache ) ) ;sort_param [ i ] . sortbuff_size = # ifndef USING_SECOND_APPROACH param -> sort_buffer_length / sort_info . total_keys ;# else param -> sort_buffer_length * sort_param [ i ] . key_length / total_key_length ;# endif if ( ( error = mysql_thread_create ( mi_key_thread_find_all_keys , & sort_param [ i ] . thr , & thr_attr , thr_find_all_keys , ( void * ) ( sort_param + i ) ) ) ) {mi_check_print_error ( param , ""Cannot<S2SV_blank>start<S2SV_blank>a<S2SV_blank>repair<S2SV_blank>thread<S2SV_blank>(errno=<S2SV_blank>%d)"" , error ) ;if ( io_share . total_threads ) remove_io_thread ( & sort_param [ i ] . read_cache ) ;DBUG_PRINT ( ""error"" , ( ""Cannot<S2SV_blank>start<S2SV_blank>a<S2SV_blank>repair<S2SV_blank>thread"" ) ) ;sort_info . got_error = 1 ;}else sort_info . threads_running ++ ;}( void ) pthread_attr_destroy ( & thr_attr ) ;while ( sort_info . threads_running ) mysql_cond_wait ( & sort_info . cond , & sort_info . mutex ) ;mysql_mutex_unlock ( & sort_info . mutex ) ;if ( ( got_error = thr_write_keys ( sort_param ) ) ) {param -> retry_repair = 1 ;goto err ;}got_error = 1 ;if ( sort_param [ 0 ] . fix_datafile ) {if ( write_data_suffix ( & sort_info , 1 ) || end_io_cache ( & info -> rec_cache ) ) goto err ;if ( param -> testflag & T_SAFE_REPAIR ) {if ( info -> state -> records + 1 < start_records ) {info -> state -> records = start_records ;goto err ;}}share -> state . state . data_file_length = info -> state -> data_file_length = sort_param -> filepos ;share -> state . version = ( ulong ) time ( ( time_t * ) 0 ) ;mysql_file_close ( info -> dfile , MYF ( 0 ) ) ;info -> dfile = new_file ;share -> data_file_type = sort_info . new_data_file_type ;share -> pack . header_length = ( ulong ) new_header_length ;}else info -> state -> data_file_length = sort_param -> max_pos ;if ( rep_quick && del + sort_info . dupp != info -> state -> del ) {mi_check_print_error ( param , ""Couldn\\\'t<S2SV_blank>fix<S2SV_blank>table<S2SV_blank>with<S2SV_blank>quick<S2SV_blank>recovery:<S2SV_blank>Found<S2SV_blank>wrong<S2SV_blank>number<S2SV_blank>of<S2SV_blank>deleted<S2SV_blank>records"" ) ;mi_check_print_error ( param , ""Run<S2SV_blank>recovery<S2SV_blank>again<S2SV_blank>without<S2SV_blank>-q"" ) ;param -> retry_repair = 1 ;param -> testflag |= T_RETRY_WITHOUT_QUICK ;goto err ;}if ( rep_quick & T_FORCE_UNIQUENESS ) {my_off_t skr = info -> state -> data_file_length + ( share -> options & HA_OPTION_COMPRESS_RECORD ? MEMMAP_EXTRA_MARGIN : 0 ) ;# ifdef USE_RELOC if ( share -> data_file_type == STATIC_RECORD && skr < share -> base . reloc * share -> base . min_pack_length ) skr = share -> base . reloc * share -> base . min_pack_length ;# endif if ( skr != sort_info . filelength ) if ( mysql_file_chsize ( info -> dfile , skr , 0 , MYF ( 0 ) ) ) mi_check_print_warning ( param , ""Can\\\'t<S2SV_blank>change<S2SV_blank>size<S2SV_blank>of<S2SV_blank>datafile,<S2SV_blank><S2SV_blank>error:<S2SV_blank>%d"" , my_errno ) ;}if ( param -> testflag & T_CALC_CHECKSUM ) info -> state -> checksum = param -> glob_crc ;if ( mysql_file_chsize ( share -> kfile , info -> state -> key_file_length , 0 , MYF ( 0 ) ) ) mi_check_print_warning ( param , ""Can\\\'t<S2SV_blank>change<S2SV_blank>size<S2SV_blank>of<S2SV_blank>indexfile,<S2SV_blank>error:<S2SV_blank>%d"" , my_errno ) ;if ( ! ( param -> testflag & T_SILENT ) ) {if ( start_records != info -> state -> records ) printf ( ""Data<S2SV_blank>records:<S2SV_blank>%s\\\if ( sort_info . dupp ) mi_check_print_warning ( param , ""%s<S2SV_blank>records<S2SV_blank>have<S2SV_blank>been<S2SV_blank>removed"" , llstr ( sort_info . dupp , llbuff ) ) ;}got_error = 0 ;if ( & share -> state . state != info -> state ) memcpy ( & share -> state . state , info -> state , sizeof ( * info -> state ) ) ;err : got_error |= flush_blocks ( param , share -> key_cache , share -> kfile ) ;( void ) end_io_cache ( & info -> rec_cache ) ;if ( ! rep_quick ) ( void ) end_io_cache ( & new_data_cache ) ;if ( ! got_error ) {if ( new_file >= 0 ) {mysql_file_close ( new_file , MYF ( 0 ) ) ;info -> dfile = new_file = - 1 ;if ( change_to_newfile ( share -> data_file_name , MI_NAME_DEXT , DATA_TMP_EXT ,  ( param -> testflag & T_BACKUP_DATA ?  MYF ( MY_REDEL_MAKE_BACKUP ) : MYF ( 0 ) ) ) || mi_open_datafile ( info , share , name , - 1 ) ) got_error = 1 ;cwe id:CWE-362context: int mi_repair_parallel ( MI_CHECK * param , register MI_INFO * info ,  const char * name , int rep_quick )  { int got_error ; uint i , key , total_key_length , istep ; ulong rec_length ; ha_rows start_records ; my_off_t new_header_length , del ; File new_file ; MI_SORT_PARAM * sort_param = 0 ; MYISAM_SHARE * share = info -> s ; ulong * rec_per_key_part ; HA_KEYSEG * keyseg ; char llbuff [ 22 ] ; IO_CACHE new_data_cache ; IO_CACHE_SHARE io_share ; SORT_INFO sort_info ; ulonglong UNINIT_VAR ( key_map ) ; pthread_attr_t thr_attr ; ulong max_pack_reclength ; int error ; DBUG_ENTER ( ""mi_repair_parallel"" ) ; start_records = info -> state -> records ; got_error = 1 ; new_file = - 1 ; new_header_length = ( param -> testflag & T_UNPACK ) ? 0 : share -> pack . header_length ; if ( ! ( param -> testflag & T_SILENT ) ) { printf ( ""-<S2SV_blank>parallel<S2SV_blank>recovering<S2SV_blank>(with<S2SV_blank>sort)<S2SV_blank>MyISAM-table<S2SV_blank>\'%s\'\\n"" , name ) ; printf ( ""Data<S2SV_blank>records:<S2SV_blank>%s\\n"" , llstr ( start_records , llbuff ) ) ; } param -> testflag |= T_REP ; if ( info -> s -> options & ( HA_OPTION_CHECKSUM | HA_OPTION_COMPRESS_RECORD ) ) param -> testflag |= T_CALC_CHECKSUM ; DBUG_PRINT ( ""info"" , ( ""is<S2SV_blank>quick<S2SV_blank>repair:<S2SV_blank>%d"" , rep_quick ) ) ; bzero ( ( char * ) & sort_info , sizeof ( sort_info ) ) ; mysql_mutex_init ( mi_key_mutex_MI_SORT_INFO_mutex , & sort_info . mutex , MY_MUTEX_INIT_FAST ) ; mysql_cond_init ( mi_key_cond_MI_SORT_INFO_cond , & sort_info . cond , 0 ) ; mysql_mutex_init ( mi_key_mutex_MI_CHECK_print_msg , & param -> print_msg_mutex , MY_MUTEX_INIT_FAST ) ; param -> need_print_msg_lock = 1 ; if ( ! ( sort_info . key_block = alloc_key_blocks ( param , ( uint ) param -> sort_key_blocks , share -> base . max_key_block_length ) ) || init_io_cache ( & param -> read_cache , info -> dfile , ( uint ) param -> read_buffer_length , READ_CACHE , share -> pack . header_length , 1 , MYF ( MY_WME ) ) || ( ! rep_quick && ( init_io_cache ( & info -> rec_cache , info -> dfile , ( uint ) param -> write_buffer_length , WRITE_CACHE , new_header_length , 1 , MYF ( MY_WME | MY_WAIT_IF_FULL ) & param -> myf_rw ) || init_io_cache ( & new_data_cache , - 1 , ( uint ) param -> write_buffer_length , READ_CACHE , new_header_length , 1 , MYF ( MY_WME | MY_DONT_CHECK_FILESIZE ) ) ) ) ) goto err ; sort_info . key_block_end = sort_info . key_block + param -> sort_key_blocks ; info -> opt_flag |= WRITE_CACHE_USED ; info -> rec_cache . file = info -> dfile ; if ( ! rep_quick ) { if ( ( new_file = mysql_file_create ( mi_key_file_datatmp , fn_format ( param -> temp_filename , share -> data_file_name , """" , DATA_TMP_EXT , 2 + 4 ) , 0 , param -> tmpfile_createflag , MYF ( 0 ) ) ) < 0 ) { mi_check_print_error ( param , ""Can\'t<S2SV_blank>create<S2SV_blank>new<S2SV_blank>tempfile:<S2SV_blank>\'%s\'"" , param -> temp_filename ) ; goto err ; } if ( new_header_length && filecopy ( param , new_file , info -> dfile , 0L , new_header_length , ""datafile-header"" ) ) goto err ; if ( param -> testflag & T_UNPACK ) { share -> options &= ~ HA_OPTION_COMPRESS_RECORD ; mi_int2store ( share -> state . header . options , share -> options ) ; } share -> state . dellink = HA_OFFSET_ERROR ; info -> rec_cache . file = new_file ; } info -> update = ( short ) ( HA_STATE_CHANGED | HA_STATE_ROW_CHANGED ) ; mi_drop_all_indexes ( param , info , FALSE ) ; key_map = share -> state . key_map ; if ( param -> testflag & T_CREATE_MISSING_KEYS ) { key_map = ~ key_map ; } sort_info . info = info ; sort_info . param = param ; set_data_file_type ( & sort_info , share ) ; sort_info . dupp = 0 ; sort_info . buff = 0 ; param -> read_cache . end_of_file = sort_info . filelength = mysql_file_seek ( param -> read_cache . file , 0L , MY_SEEK_END , MYF ( 0 ) ) ; if ( share -> data_file_type == DYNAMIC_RECORD ) rec_length = max ( share -> base . min_pack_length + 1 , share -> base . min_block_length ) ; else if ( share -> data_file_type == COMPRESSED_RECORD ) rec_length = share -> base . min_block_length ; else rec_length = share -> base . pack_reclength ; sort_info . max_records = ( ( param -> testflag & T_CREATE_MISSING_KEYS ) ? info -> state -> records + 1 : ( ha_rows ) ( sort_info . filelength / rec_length + 1 ) ) ; del = info -> state -> del ; param -> glob_crc = 0 ; max_pack_reclength = share -> base . pack_reclength ; if ( share -> options & HA_OPTION_COMPRESS_RECORD ) set_if_bigger ( max_pack_reclength , share -> max_pack_length ) ; if ( ! ( sort_param = ( MI_SORT_PARAM * ) my_malloc ( ( uint ) share -> base . keys * ( sizeof ( MI_SORT_PARAM ) + max_pack_reclength ) , MYF ( MY_ZEROFILL ) ) ) ) { mi_check_print_error ( param , ""Not<S2SV_blank>enough<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>key!"" ) ; goto err ; } total_key_length = 0 ; rec_per_key_part = param -> rec_per_key_part ; info -> state -> records = info -> state -> del = share -> state . split = 0 ; info -> state -> empty = 0 ; for ( i = key = 0 , istep = 1 ; key < share -> base . keys ; rec_per_key_part += sort_param [ i ] . keyinfo -> keysegs , i += istep , key ++ ) { sort_param [ i ] . key = key ; sort_param [ i ] . keyinfo = share -> keyinfo + key ; sort_param [ i ] . seg = sort_param [ i ] . keyinfo -> seg ; if ( ! mi_is_key_active ( key_map , key ) ) { memcpy ( ( char * ) rec_per_key_part , ( char * ) ( share -> state . rec_per_key_part + ( uint ) ( rec_per_key_part - param -> rec_per_key_part ) ) , sort_param [ i ] . keyinfo -> keysegs * sizeof ( * rec_per_key_part ) ) ; istep = 0 ; continue ; } istep = 1 ; if ( ( ! ( param -> testflag & T_SILENT ) ) ) printf ( ""-<S2SV_blank>Fixing<S2SV_blank>index<S2SV_blank>%d\\n"" , key + 1 ) ; if ( sort_param [ i ] . keyinfo -> flag & HA_FULLTEXT ) { sort_param [ i ] . key_read = sort_ft_key_read ; sort_param [ i ] . key_write = sort_ft_key_write ; } else { sort_param [ i ] . key_read = sort_key_read ; sort_param [ i ] . key_write = sort_key_write ; } sort_param [ i ] . key_cmp = sort_key_cmp ; sort_param [ i ] . lock_in_memory = lock_memory ; sort_param [ i ] . tmpdir = param -> tmpdir ; sort_param [ i ] . sort_info = & sort_info ; sort_param [ i ] . master = 0 ; sort_param [ i ] . fix_datafile = 0 ; sort_param [ i ] . calc_checksum = 0 ; sort_param [ i ] . filepos = new_header_length ; sort_param [ i ] . max_pos = sort_param [ i ] . pos = share -> pack . header_length ; sort_param [ i ] . record = ( ( ( uchar * ) ( sort_param + share -> base . keys ) ) + ( max_pack_reclength * i ) ) ; if ( ! mi_alloc_rec_buff ( info , - 1 , & sort_param [ i ] . rec_buff ) ) { mi_check_print_error ( param , ""Not<S2SV_blank>enough<S2SV_blank>memory!"" ) ; goto err ; } sort_param [ i ] . key_length = share -> rec_reflength ; for ( keyseg = sort_param [ i ] . seg ; keyseg -> type != HA_KEYTYPE_END ; keyseg ++ ) { sort_param [ i ] . key_length += keyseg -> length ; if ( keyseg -> flag & HA_SPACE_PACK ) sort_param [ i ] . key_length += get_pack_length ( keyseg -> length ) ; if ( keyseg -> flag & ( HA_BLOB_PART | HA_VAR_LENGTH_PART ) ) sort_param [ i ] . key_length += 2 + test ( keyseg -> length >= 127 ) ; if ( keyseg -> flag & HA_NULL_PART ) sort_param [ i ] . key_length ++ ; } total_key_length += sort_param [ i ] . key_length ; if ( sort_param [ i ] . keyinfo -> flag & HA_FULLTEXT ) { uint ft_max_word_len_for_sort = FT_MAX_WORD_LEN_FOR_SORT * sort_param [ i ] . keyinfo -> seg -> charset -> mbmaxlen ; sort_param [ i ] . key_length += ft_max_word_len_for_sort - HA_FT_MAXBYTELEN ; init_alloc_root ( & sort_param [ i ] . wordroot , FTPARSER_MEMROOT_ALLOC_SIZE , 0 ) ; } } sort_info . total_keys = i ; sort_param [ 0 ] . master = 1 ; sort_param [ 0 ] . fix_datafile = ( my_bool ) ( ! rep_quick ) ; sort_param [ 0 ] . calc_checksum = test ( param -> testflag & T_CALC_CHECKSUM ) ; if ( ! ftparser_alloc_param ( info ) ) goto err ; sort_info . got_error = 0 ; mysql_mutex_lock ( & sort_info . mutex ) ; if ( i > 1 ) { if ( rep_quick ) init_io_cache_share ( & param -> read_cache , & io_share , NULL , i ) ; else init_io_cache_share ( & new_data_cache , & io_share , & info -> rec_cache , i ) ; } else io_share . total_threads = 0 ; ( void ) pthread_attr_init ( & thr_attr ) ; ( void ) pthread_attr_setdetachstate ( & thr_attr , PTHREAD_CREATE_DETACHED ) ; for ( i = 0 ; i < sort_info . total_keys ; i ++ ) { sort_param [ i ] . read_cache = ( ( rep_quick || ! i ) ? param -> read_cache : new_data_cache ) ; DBUG_PRINT ( ""io_cache_share"" , ( ""thread:<S2SV_blank>%u<S2SV_blank><S2SV_blank>read_cache:<S2SV_blank>0x%lx"" , i , ( long ) & sort_param [ i ] . read_cache ) ) ; sort_param [ i ] . sortbuff_size = # ifndef USING_SECOND_APPROACH param -> sort_buffer_length / sort_info . total_keys ; # else param -> sort_buffer_length * sort_param [ i ] . key_length / total_key_length ; # endif if ( ( error = mysql_thread_create ( mi_key_thread_find_all_keys , & sort_param [ i ] . thr , & thr_attr , thr_find_all_keys , ( void * ) ( sort_param + i ) ) ) ) { mi_check_print_error ( param , ""Cannot<S2SV_blank>start<S2SV_blank>a<S2SV_blank>repair<S2SV_blank>thread<S2SV_blank>(errno=<S2SV_blank>%d)"" , error ) ; if ( io_share . total_threads ) remove_io_thread ( & sort_param [ i ] . read_cache ) ; DBUG_PRINT ( ""error"" , ( ""Cannot<S2SV_blank>start<S2SV_blank>a<S2SV_blank>repair<S2SV_blank>thread"" ) ) ; sort_info . got_error = 1 ; } else sort_info . threads_running ++ ; } ( void ) pthread_attr_destroy ( & thr_attr ) ; while ( sort_info . threads_running ) mysql_cond_wait ( & sort_info . cond , & sort_info . mutex ) ; mysql_mutex_unlock ( & sort_info . mutex ) ; if ( ( got_error = thr_write_keys ( sort_param ) ) ) { param -> retry_repair = 1 ; goto err ; } got_error = 1 ; if ( sort_param [ 0 ] . fix_datafile ) { if ( write_data_suffix ( & sort_info , 1 ) || end_io_cache ( & info -> rec_cache ) ) goto err ; if ( param -> testflag & T_SAFE_REPAIR ) { if ( info -> state -> records + 1 < start_records ) { info -> state -> records = start_records ; goto err ; } } share -> state . state . data_file_length = info -> state -> data_file_length = sort_param -> filepos ; share -> state . version = ( ulong ) time ( ( time_t * ) 0 ) ; mysql_file_close ( info -> dfile , MYF ( 0 ) ) ; info -> dfile = new_file ; share -> data_file_type = sort_info . new_data_file_type ; share -> pack . header_length = ( ulong ) new_header_length ; } else info -> state -> data_file_length = sort_param -> max_pos ; if ( rep_quick && del + sort_info . dupp != info -> state -> del ) { mi_check_print_error ( param , ""Couldn\'t<S2SV_blank>fix<S2SV_blank>table<S2SV_blank>with<S2SV_blank>quick<S2SV_blank>recovery:<S2SV_blank>Found<S2SV_blank>wrong<S2SV_blank>number<S2SV_blank>of<S2SV_blank>deleted<S2SV_blank>records"" ) ; mi_check_print_error ( param , ""Run<S2SV_blank>recovery<S2SV_blank>again<S2SV_blank>without<S2SV_blank>-q"" ) ; param -> retry_repair = 1 ; param -> testflag |= T_RETRY_WITHOUT_QUICK ; goto err ; } if ( rep_quick & T_FORCE_UNIQUENESS ) { my_off_t skr = info -> state -> data_file_length + ( share -> options & HA_OPTION_COMPRESS_RECORD ? MEMMAP_EXTRA_MARGIN : 0 ) ; # ifdef USE_RELOC if ( share -> data_file_type == STATIC_RECORD && skr < share -> base . reloc * share -> base . min_pack_length ) skr = share -> base . reloc * share -> base . min_pack_length ; # endif if ( skr != sort_info . filelength ) if ( mysql_file_chsize ( info -> dfile , skr , 0 , MYF ( 0 ) ) ) mi_check_print_warning ( param , ""Can\'t<S2SV_blank>change<S2SV_blank>size<S2SV_blank>of<S2SV_blank>datafile,<S2SV_blank><S2SV_blank>error:<S2SV_blank>%d"" , my_errno ) ; } if ( param -> testflag & T_CALC_CHECKSUM ) info -> state -> checksum = param -> glob_crc ; if ( mysql_file_chsize ( share -> kfile , info -> state -> key_file_length , 0 , MYF ( 0 ) ) ) mi_check_print_warning ( param , ""Can\'t<S2SV_blank>change<S2SV_blank>size<S2SV_blank>of<S2SV_blank>indexfile,<S2SV_blank>error:<S2SV_blank>%d"" , my_errno ) ; if ( ! ( param -> testflag & T_SILENT ) ) { if ( start_records != info -> state -> records ) printf ( ""Data<S2SV_blank>records:<S2SV_blank>%s\\n"" , llstr ( info -> state -> records , llbuff ) ) ; if ( sort_info . dupp ) mi_check_print_warning ( param , ""%s<S2SV_blank>records<S2SV_blank>have<S2SV_blank>been<S2SV_blank>removed"" , llstr ( sort_info . dupp , llbuff ) ) ; } got_error = 0 ; if ( & share -> state . state != info -> state ) memcpy ( & share -> state . state , info -> state , sizeof ( * info -> state ) ) ; err : got_error |= flush_blocks ( param , share -> key_cache , share -> kfile ) ; ( void ) end_io_cache ( & info -> rec_cache ) ; if ( ! rep_quick ) ( void ) end_io_cache ( & new_data_cache ) ; if ( ! got_error ) { if ( new_file >= 0 ) {  mysql_file_close ( new_file , MYF ( 0 ) ) ;  info -> dfile = new_file = - 1 ; if ( change_to_newfile ( share -> data_file_name , MI_NAME_DEXT , DATA_TMP_EXT ,  ( param -> testflag & T_BACKUP_DATA ?  MYF ( MY_REDEL_MAKE_BACKUP ) : MYF ( 0 ) ) ) || mi_open_datafile ( info , share , name , - 1 ) ) got_error = 1 ; } } if ( got_error ) { if ( ! param -> error_printed ) mi_check_print_error ( param , ""%d<S2SV_blank>when<S2SV_blank>fixing<S2SV_blank>table"" , my_errno ) ; if ( new_file >= 0 ) { ( void ) mysql_file_close ( new_file , MYF ( 0 ) ) ; ( void ) mysql_file_delete ( mi_key_file_datatmp , param -> temp_filename , MYF ( MY_WME ) ) ; if ( info -> dfile == new_file ) if ( unlikely ( mi_open_datafile ( info , share , name , - 1 ) ) ) param -> retry_repair = 0 ; } mi_mark_crashed_on_repair ( info ) ; } else if ( key_map == share -> state . key_map ) share -> state . changed &= ~ STATE_NOT_OPTIMIZED_KEYS ; share -> state . changed |= STATE_NOT_SORTED_PAGES ; mysql_cond_destroy ( & sort_info . cond ) ; mysql_mutex_destroy ( & sort_info . mutex ) ; mysql_mutex_destroy ( & param -> print_msg_mutex ) ; param -> need_print_msg_lock = 0 ; my_free ( sort_info . ft_buf ) ; my_free ( sort_info . key_block ) ; my_free ( sort_param ) ; my_free ( sort_info . buff ) ; ( void ) end_io_cache ( & param -> read_cache ) ; info -> opt_flag &= ~ ( READ_CACHE_USED | WRITE_CACHE_USED ) ; if ( ! got_error && ( param -> testflag & T_UNPACK ) ) { share -> state . header . options [ 0 ] &= ( uchar ) ~ HA_OPTION_COMPRESS_RECORD ; share -> pack . header_length = 0 ; } DBUG_RETURN ( got_error ) ; }","if ( ( new_file = mysql_file_create ( mi_key_file_datatmp , fn_format ( param -> temp_filename , share -> data_file_name , """" , DATA_TMP_EXT , flags ) || mi_open_datafile ( info , share , name , - 1 ) ) got_error = 1 ;",608
830,"buggy line: if ( p == q || size < 16 || size > 256 )  return ( ( Image * ) NULL ) ;cwe id:CWE-000context: Image * AutoResizeImage ( const Image * image , const char * option , MagickOffsetType * count , ExceptionInfo * exception ) { # define MAX_SIZES 16 char * q ; const char * p ; Image * resized , * images ; register ssize_t i ; size_t sizes [ MAX_SIZES ] = { 256 , 192 , 128 , 96 , 64 , 48 , 40 , 32 , 24 , 16 } ; images = NULL ; * count = 0 ; i = 0 ; p = option ; while ( * p != '\\0' && i < MAX_SIZES ) { size_t size ; while ( ( isspace ( ( int ) ( ( unsigned char ) * p ) ) != 0 ) ) p ++ ; size = ( size_t ) strtol ( p , & q , 10 ) ;  if ( p == q || size < 16 || size > 256 )  return ( ( Image * ) NULL ) ; p = q ; sizes [ i ++ ] = size ; while ( ( isspace ( ( int ) ( ( unsigned char ) * p ) ) != 0 ) || ( * p == ',' ) ) p ++ ; } if ( i == 0 ) i = 10 ; * count = i ; for ( i = 0 ; i < * count ; i ++ ) { resized = ResizeImage ( image , sizes [ i ] , sizes [ i ] , image -> filter , exception ) ; if ( resized == ( Image * ) NULL ) return ( DestroyImageList ( images ) ) ; if ( images == ( Image * ) NULL ) images = resized ; else AppendImageToList ( & images , resized ) ; } return ( images ) ; }",if ( ( p == q ) || ( size < 16 || size > 256 ) ) return ( ( Image * ) NULL ) ;,609
831,"buggy line: uint dblocks = XFS_B_TO_FSB ( mp , valuelen ) ;nblks += dblocks ;cwe id:CWE-19context: STATIC int xfs_attr_calc_size ( struct xfs_inode * ip , int namelen , int valuelen , int * local ) { struct xfs_mount * mp = ip -> i_mount ; int size ; int nblks ; size = xfs_attr_leaf_newentsize ( namelen , valuelen , mp -> m_sb . sb_blocksize , local ) ; nblks = XFS_DAENTER_SPACE_RES ( mp , XFS_ATTR_FORK ) ; if ( * local ) { if ( size > ( mp -> m_sb . sb_blocksize >> 1 ) ) { nblks *= 2 ; } } else {  uint dblocks = XFS_B_TO_FSB ( mp , valuelen ) ;  nblks += dblocks ; nblks += XFS_NEXTENTADD_SPACE_RES ( mp , dblocks , XFS_ATTR_FORK ) ; } return nblks ; }","uint dblocks = xfs_attr3_rmt_blocks ( mp , valuelen ) ;nblks += dblocks ;",610
832,"buggy line: pairs = palloc ( pcount * sizeof ( Pairs ) ) ;for ( i = 0 ;cwe id:CWE-189context: Datum hstore_recv ( PG_FUNCTION_ARGS ) { int32 buflen ; HStore * out ; Pairs * pairs ; int32 i ; int32 pcount ; StringInfo buf = ( StringInfo ) PG_GETARG_POINTER ( 0 ) ; pcount = pq_getmsgint ( buf , 4 ) ; if ( pcount == 0 ) { out = hstorePairs ( NULL , 0 , 0 ) ; PG_RETURN_POINTER ( out ) ; }  pairs = palloc ( pcount * sizeof ( Pairs ) ) ;  for ( i = 0 ; i < pcount ; ++ i ) { int rawlen = pq_getmsgint ( buf , 4 ) ; int len ; if ( rawlen < 0 ) ereport ( ERROR , ( errcode ( ERRCODE_NULL_VALUE_NOT_ALLOWED ) , errmsg ( ""null<S2SV_blank>value<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>for<S2SV_blank>hstore<S2SV_blank>key"" ) ) ) ; pairs [ i ] . key = pq_getmsgtext ( buf , rawlen , & len ) ; pairs [ i ] . keylen = hstoreCheckKeyLen ( len ) ; pairs [ i ] . needfree = true ; rawlen = pq_getmsgint ( buf , 4 ) ; if ( rawlen < 0 ) { pairs [ i ] . val = NULL ; pairs [ i ] . vallen = 0 ; pairs [ i ] . isnull = true ; } else { pairs [ i ] . val = pq_getmsgtext ( buf , rawlen , & len ) ; pairs [ i ] . vallen = hstoreCheckValLen ( len ) ; pairs [ i ] . isnull = false ; } } pcount = hstoreUniquePairs ( pairs , pcount , & buflen ) ; out = hstorePairs ( pairs , pcount , buflen ) ; PG_RETURN_POINTER ( out ) ; }","if ( pcount < 0 || pcount > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , pcount , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) ) ;pairs = palloc ( pcount * sizeof ( Pairs ) ) ;for ( i = 0 ;",611
833,"buggy line: ruleaddvar ( r , var , val ) ;if ( strcmp ( var , ""command"" ) == 0 ) hascommand = true ;cwe id:CWE-476context: static void parserule ( struct scanner * s , struct environment * env ) { struct rule * r ; char * var ; struct evalstring * val ; bool hascommand = false , hasrspfile = false , hasrspcontent = false ; r = mkrule ( scanname ( s ) ) ; scannewline ( s ) ; while ( scanindent ( s ) ) { var = scanname ( s ) ; parselet ( s , & val ) ;  ruleaddvar ( r , var , val ) ;  if ( strcmp ( var , ""command"" ) == 0 ) hascommand = true ; else if ( strcmp ( var , ""rspfile"" ) == 0 ) hasrspfile = true ; else if ( strcmp ( var , ""rspfile_content"" ) == 0 ) hasrspcontent = true ; } if ( ! hascommand ) fatal ( ""rule<S2SV_blank>\'%s\'<S2SV_blank>has<S2SV_blank>no<S2SV_blank>command"" , r -> name ) ; if ( hasrspfile != hasrspcontent ) fatal ( ""rule<S2SV_blank>\'%s\'<S2SV_blank>has<S2SV_blank>rspfile<S2SV_blank>and<S2SV_blank>no<S2SV_blank>rspfile_content<S2SV_blank>or<S2SV_blank>vice<S2SV_blank>versa"" , r -> name ) ; envaddrule ( env , r ) ; }","ruleaddvar ( r , var , val ) ;if ( ! val ) continue ;if ( strcmp ( var , ""command"" ) == 0 ) hascommand = true ;",612
834,"buggy line: if ( text [ 1 ] == EOF )  return 0 ;if ( text [ 1 ] == 'x' ) {text [ 2 ] = RE_YY_INPUT ( yyscanner ) ;if ( text [ 2 ] == EOF )  return 0 ;if ( text [ 3 ] == EOF )  return 0 ;cwe id:CWE-476context: int read_escaped_char ( yyscan_t yyscanner , uint8_t * escaped_char ) { char text [ 4 ] = { 0 , 0 , 0 , 0 } ; text [ 0 ] = '\\\\' ; text [ 1 ] = RE_YY_INPUT ( yyscanner ) ;  if ( text [ 1 ] == EOF )  return 0 ; if ( text [ 1 ] == 'x' ) { text [ 2 ] = RE_YY_INPUT ( yyscanner ) ;  if ( text [ 2 ] == EOF )  return 0 ; text [ 3 ] = RE_YY_INPUT ( yyscanner ) ;  if ( text [ 3 ] == EOF )  return 0 ; } * escaped_char = escaped_char_value ( text ) ; return 1 ; }",if ( text [ 1 ] == EOF || text [ 1 ] == 0 ) return 0 ;if ( ! isxdigit ( text [ 1 ] == 'x' ) {text [ 2 ] ) ) return 0 ;if ( ! isxdigit ( text [ 3 ] ) ) return 0 ;,613
835,"buggy line: cwe id:CWE-444context: static HeadReturn con_header_read ( agooCon c , size_t * mlenp ) { char * hend = strstr ( c -> buf , ""\\r\\n\\r\\n"" ) ; agooMethod method ; struct _agooSeg path ; char * query = NULL ; char * qend ; char * b ; size_t clen = 0 ; long mlen ; agooHook hook = NULL ; agooPage p ; struct _agooErr err = AGOO_ERR_INIT ; if ( NULL == hend ) { if ( sizeof ( c -> buf ) - 1 <= c -> bcnt ) { return bad_request ( c , 431 , __LINE__ ) ; } return HEAD_AGAIN ; } if ( agoo_req_cat . on ) { * hend = '\\0' ; agoo_log_cat ( & agoo_req_cat , ""%s<S2SV_blank>%llu:<S2SV_blank>%s"" , agoo_con_kind_str ( c -> bind -> kind ) , ( unsigned long long ) c -> id , c -> buf ) ; * hend = '\\r' ; } for ( b = c -> buf ; '<S2SV_blank>' != * b ; b ++ ) { if ( '\\0' == * b ) { return bad_request ( c , 400 , __LINE__ ) ; } } switch ( toupper ( * c -> buf ) ) { case 'G' : if ( 3 != b - c -> buf || 0 != strncmp ( ""GET"" , c -> buf , 3 ) ) { return bad_request ( c , 400 , __LINE__ ) ; } method = AGOO_GET ; break ; case 'P' : { const char * v ; int vlen = 0 ; char * vend ; if ( 3 == b - c -> buf && 0 == strncmp ( ""PUT"" , c -> buf , 3 ) ) { method = AGOO_PUT ; } else if ( 4 == b - c -> buf && 0 == strncmp ( ""POST"" , c -> buf , 4 ) ) { method = AGOO_POST ; } else { return bad_request ( c , 400 , __LINE__ ) ; } if ( NULL == ( v = agoo_con_header_value ( c -> buf , ( int ) ( hend - c -> buf ) , ""Content-Length"" , & vlen ) ) ) { return bad_request ( c , 411 , __LINE__ ) ; } clen = ( size_t ) strtoul ( v , & vend , 10 ) ; if ( vend != v + vlen ) { return bad_request ( c , 411 , __LINE__ ) ; } break ; } case 'D' : if ( 6 != b - c -> buf || 0 != strncmp ( ""DELETE"" , c -> buf , 6 ) ) { return bad_request ( c , 400 , __LINE__ ) ; } method = AGOO_DELETE ; break ; case 'H' : if ( 4 != b - c -> buf || 0 != strncmp ( ""HEAD"" , c -> buf , 4 ) ) { return bad_request ( c , 400 , __LINE__ ) ; } method = AGOO_HEAD ; break ; case 'O' : if ( 7 != b - c -> buf || 0 != strncmp ( ""OPTIONS"" , c -> buf , 7 ) ) { return bad_request ( c , 400 , __LINE__ ) ; } method = AGOO_OPTIONS ; break ; case 'C' : if ( 7 != b - c -> buf || 0 != strncmp ( ""CONNECT"" , c -> buf , 7 ) ) { return bad_request ( c , 400 , __LINE__ ) ; } method = AGOO_CONNECT ; break ; default : return bad_request ( c , 400 , __LINE__ ) ; } for ( ; '<S2SV_blank>' == * b ; b ++ ) { if ( '\\0' == * b ) { return bad_request ( c , 400 , __LINE__ ) ; } } path . start = b ; for ( ; '<S2SV_blank>' != * b ; b ++ ) { switch ( * b ) { case '?' : path . end = b ; query = b + 1 ; break ; case '\\0' : return bad_request ( c , 400 , __LINE__ ) ; default : break ; } } if ( NULL == query ) { path . end = b ; query = b ; qend = b ; } else { qend = b ; } mlen = hend - c -> buf + 4 + clen ; * mlenp = mlen ; if ( AGOO_GET == method ) { char root_buf [ 20148 ] ; const char * root = NULL ; if ( NULL != ( p = agoo_group_get ( & err , path . start , ( int ) ( path . end - path . start ) ) ) ) { if ( page_response ( c , p , hend ) ) { return bad_request ( c , 500 , __LINE__ ) ; } return HEAD_HANDLED ; } if ( agoo_domain_use ( ) ) { const char * host ; int vlen = 0 ; if ( NULL == ( host = agoo_con_header_value ( c -> buf , ( int ) ( hend - c -> buf ) , ""Host"" , & vlen ) ) ) { return bad_request ( c , 411 , __LINE__ ) ; } ( ( char * ) host ) [ vlen ] = '\\0' ; root = agoo_domain_resolve ( host , root_buf , sizeof ( root_buf ) ) ; ( ( char * ) host ) [ vlen ] = '\\r' ; } if ( agoo_server . root_first && NULL != ( p = agoo_page_get ( & err , path . start , ( int ) ( path . end - path . start ) , root ) ) ) { if ( page_response ( c , p , hend ) ) { return bad_request ( c , 500 , __LINE__ ) ; } return HEAD_HANDLED ; } if ( NULL == ( hook = agoo_hook_find ( agoo_server . hooks , method , & path ) ) ) { if ( NULL != ( p = agoo_page_get ( & err , path . start , ( int ) ( path . end - path . start ) , root ) ) ) { if ( page_response ( c , p , hend ) ) { return bad_request ( c , 500 , __LINE__ ) ; } return HEAD_HANDLED ; } if ( NULL == agoo_server . hook404 ) { return bad_request ( c , 404 , __LINE__ ) ; } hook = agoo_server . hook404 ; } } else if ( NULL == ( hook = agoo_hook_find ( agoo_server . hooks , method , & path ) ) ) { return bad_request ( c , 404 , __LINE__ ) ; } if ( NULL == ( c -> req = agoo_req_create ( mlen ) ) ) { return bad_request ( c , 413 , __LINE__ ) ; } if ( ( long ) c -> bcnt <= mlen ) { memcpy ( c -> req -> msg , c -> buf , c -> bcnt ) ; if ( ( long ) c -> bcnt < mlen ) { memset ( c -> req -> msg + c -> bcnt , 0 , mlen - c -> bcnt ) ; } } else { memcpy ( c -> req -> msg , c -> buf , mlen ) ; } c -> req -> msg [ mlen ] = '\\0' ; c -> req -> method = method ; c -> req -> upgrade = AGOO_UP_NONE ; c -> req -> up = NULL ;  c -> req -> path . start = c -> req -> msg + ( path . start - c -> buf ) ;  c -> req -> path . len = ( int ) ( path . end - path . start ) ; c -> req -> query . start = c -> req -> msg + ( query - c -> buf ) ; c -> req -> query . len = ( int ) ( qend - query ) ; c -> req -> query . start [ c -> req -> query . len ] = '\\0' ; c -> req -> body . start = c -> req -> msg + ( hend - c -> buf + 4 ) ; c -> req -> body . len = ( unsigned int ) clen ; b = strstr ( b , ""\\r\\n"" ) ; c -> req -> header . start = c -> req -> msg + ( b + 2 - c -> buf ) ; if ( b < hend ) { c -> req -> header . len = ( unsigned int ) ( hend - b - 2 ) ; } else { c -> req -> header . len = 0 ; } c -> req -> res = NULL ; c -> req -> hook = hook ; return HEAD_OK ; }","memcpy ( c -> req -> remote , c -> remote , sizeof ( c -> remote ) ) ;",614
836,"buggy line: c -> req -> path . start = c -> req -> msg + ( path . start - c -> buf ) ;c -> req -> path . len = ( int ) ( path . end - path . start ) ;cwe id:CWE-444context: static HeadReturn con_header_read ( agooCon c , size_t * mlenp ) { char * hend = strstr ( c -> buf , ""\\r\\n\\r\\n"" ) ; agooMethod method ; struct _agooSeg path ; char * query = NULL ; char * qend ; char * b ; size_t clen = 0 ; long mlen ; agooHook hook = NULL ; agooPage p ; struct _agooErr err = AGOO_ERR_INIT ; if ( NULL == hend ) { if ( sizeof ( c -> buf ) - 1 <= c -> bcnt ) { return bad_request ( c , 431 , __LINE__ ) ; } return HEAD_AGAIN ; } if ( agoo_req_cat . on ) { * hend = '\\0' ; agoo_log_cat ( & agoo_req_cat , ""%s<S2SV_blank>%llu:<S2SV_blank>%s"" , agoo_con_kind_str ( c -> bind -> kind ) , ( unsigned long long ) c -> id , c -> buf ) ; * hend = '\\r' ; } for ( b = c -> buf ; '<S2SV_blank>' != * b ; b ++ ) { if ( '\\0' == * b ) { return bad_request ( c , 400 , __LINE__ ) ; } } switch ( toupper ( * c -> buf ) ) { case 'G' : if ( 3 != b - c -> buf || 0 != strncmp ( ""GET"" , c -> buf , 3 ) ) { return bad_request ( c , 400 , __LINE__ ) ; } method = AGOO_GET ; break ; case 'P' : { const char * v ; int vlen = 0 ; char * vend ; if ( 3 == b - c -> buf && 0 == strncmp ( ""PUT"" , c -> buf , 3 ) ) { method = AGOO_PUT ; } else if ( 4 == b - c -> buf && 0 == strncmp ( ""POST"" , c -> buf , 4 ) ) { method = AGOO_POST ; } else { return bad_request ( c , 400 , __LINE__ ) ; } if ( NULL == ( v = agoo_con_header_value ( c -> buf , ( int ) ( hend - c -> buf ) , ""Content-Length"" , & vlen ) ) ) { return bad_request ( c , 411 , __LINE__ ) ; } clen = ( size_t ) strtoul ( v , & vend , 10 ) ; if ( vend != v + vlen ) { return bad_request ( c , 411 , __LINE__ ) ; } break ; } case 'D' : if ( 6 != b - c -> buf || 0 != strncmp ( ""DELETE"" , c -> buf , 6 ) ) { return bad_request ( c , 400 , __LINE__ ) ; } method = AGOO_DELETE ; break ; case 'H' : if ( 4 != b - c -> buf || 0 != strncmp ( ""HEAD"" , c -> buf , 4 ) ) { return bad_request ( c , 400 , __LINE__ ) ; } method = AGOO_HEAD ; break ; case 'O' : if ( 7 != b - c -> buf || 0 != strncmp ( ""OPTIONS"" , c -> buf , 7 ) ) { return bad_request ( c , 400 , __LINE__ ) ; } method = AGOO_OPTIONS ; break ; case 'C' : if ( 7 != b - c -> buf || 0 != strncmp ( ""CONNECT"" , c -> buf , 7 ) ) { return bad_request ( c , 400 , __LINE__ ) ; } method = AGOO_CONNECT ; break ; default : return bad_request ( c , 400 , __LINE__ ) ; } for ( ; '<S2SV_blank>' == * b ; b ++ ) { if ( '\\0' == * b ) { return bad_request ( c , 400 , __LINE__ ) ; } } path . start = b ; for ( ; '<S2SV_blank>' != * b ; b ++ ) { switch ( * b ) { case '?' : path . end = b ; query = b + 1 ; break ; case '\\0' : return bad_request ( c , 400 , __LINE__ ) ; default : break ; } } if ( NULL == query ) { path . end = b ; query = b ; qend = b ; } else { qend = b ; } mlen = hend - c -> buf + 4 + clen ; * mlenp = mlen ; if ( AGOO_GET == method ) { char root_buf [ 20148 ] ; const char * root = NULL ; if ( NULL != ( p = agoo_group_get ( & err , path . start , ( int ) ( path . end - path . start ) ) ) ) { if ( page_response ( c , p , hend ) ) { return bad_request ( c , 500 , __LINE__ ) ; } return HEAD_HANDLED ; } if ( agoo_domain_use ( ) ) { const char * host ; int vlen = 0 ; if ( NULL == ( host = agoo_con_header_value ( c -> buf , ( int ) ( hend - c -> buf ) , ""Host"" , & vlen ) ) ) { return bad_request ( c , 411 , __LINE__ ) ; } ( ( char * ) host ) [ vlen ] = '\\0' ; root = agoo_domain_resolve ( host , root_buf , sizeof ( root_buf ) ) ; ( ( char * ) host ) [ vlen ] = '\\r' ; } if ( agoo_server . root_first && NULL != ( p = agoo_page_get ( & err , path . start , ( int ) ( path . end - path . start ) , root ) ) ) { if ( page_response ( c , p , hend ) ) { return bad_request ( c , 500 , __LINE__ ) ; } return HEAD_HANDLED ; } if ( NULL == ( hook = agoo_hook_find ( agoo_server . hooks , method , & path ) ) ) { if ( NULL != ( p = agoo_page_get ( & err , path . start , ( int ) ( path . end - path . start ) , root ) ) ) { if ( page_response ( c , p , hend ) ) { return bad_request ( c , 500 , __LINE__ ) ; } return HEAD_HANDLED ; } if ( NULL == agoo_server . hook404 ) { return bad_request ( c , 404 , __LINE__ ) ; } hook = agoo_server . hook404 ; } } else if ( NULL == ( hook = agoo_hook_find ( agoo_server . hooks , method , & path ) ) ) { return bad_request ( c , 404 , __LINE__ ) ; } if ( NULL == ( c -> req = agoo_req_create ( mlen ) ) ) { return bad_request ( c , 413 , __LINE__ ) ; } if ( ( long ) c -> bcnt <= mlen ) { memcpy ( c -> req -> msg , c -> buf , c -> bcnt ) ; if ( ( long ) c -> bcnt < mlen ) { memset ( c -> req -> msg + c -> bcnt , 0 , mlen - c -> bcnt ) ; } } else { memcpy ( c -> req -> msg , c -> buf , mlen ) ; } c -> req -> msg [ mlen ] = '\\0' ; c -> req -> method = method ; c -> req -> upgrade = AGOO_UP_NONE ; c -> req -> up = NULL ;  c -> req -> path . start = c -> req -> msg + ( path . start - c -> buf ) ;  c -> req -> path . len = ( int ) ( path . end - path . start ) ; c -> req -> query . start = c -> req -> msg + ( query - c -> buf ) ; c -> req -> query . len = ( int ) ( qend - query ) ; c -> req -> query . start [ c -> req -> query . len ] = '\\0' ; c -> req -> body . start = c -> req -> msg + ( hend - c -> buf + 4 ) ; c -> req -> body . len = ( unsigned int ) clen ; b = strstr ( b , ""\\r\\n"" ) ; c -> req -> header . start = c -> req -> msg + ( b + 2 - c -> buf ) ; if ( b < hend ) { c -> req -> header . len = ( unsigned int ) ( hend - b - 2 ) ; } else { c -> req -> header . len = 0 ; } c -> req -> res = NULL ; c -> req -> hook = hook ; return HEAD_OK ; }",c -> req -> path . start = c -> req -> msg + ( path . start - c -> buf ) ;c -> req -> path . len = ( int ) ( path . end - path . start ) ;,614
837,"buggy line: void vp9_fht16x16_c ( const int16_t * input , int16_t * output ,  int stride , int tx_type ) {vp9_fdct16x16_c ( input , output , stride ) ;}int16_t out [ 256 ] ;int16_t * outptr = & out [ 0 ] ;int i , j ;int16_t temp_in [ 16 ] , temp_out [ 16 ] ;const transform_2d ht = FHT_16 [ tx_type ] ;++ j ) temp_in [ j ] = input [ j * stride + i ] * 4 ;++ j )  outptr [ j * 16 + i ] = ( temp_out [ j ] + 1 + ( temp_out [ j ] < 0 ) ) >> 2 ;}cwe id:CWE-119context:  void vp9_fht16x16_c ( const int16_t * input , int16_t * output ,  int stride , int tx_type ) { if ( tx_type == DCT_DCT ) {  vp9_fdct16x16_c ( input , output , stride ) ;  } else {  int16_t out [ 256 ] ;   int16_t * outptr = & out [ 0 ] ;  int i , j ;  int16_t temp_in [ 16 ] , temp_out [ 16 ] ;  const transform_2d ht = FHT_16 [ tx_type ] ; for ( i = 0 ; i < 16 ; ++ i ) { for ( j = 0 ; j < 16 ; ++ j ) temp_in [ j ] = input [ j * stride + i ] * 4 ; ht . cols ( temp_in , temp_out ) ; for ( j = 0 ; j < 16 ; ++ j )  outptr [ j * 16 + i ] = ( temp_out [ j ] + 1 + ( temp_out [ j ] < 0 ) ) >> 2 ;  } for ( i = 0 ; i < 16 ; ++ i ) { for ( j = 0 ; j < 16 ; ++ j ) temp_in [ j ] = out [ j + i * 16 ] ; ht . rows ( temp_in , temp_out ) ; for ( j = 0 ; j < 16 ; ++ j ) output [ j + i * 16 ] = temp_out [ j ] ; } } }","void vp9_fht16x16_c ( const int16_t * input , tran_low_t * output , int stride , int tx_type ) {vpx_fdct16x16_c ( input , output , stride ) ;}tran_low_t out [ 256 ] ;int16_t * outptr = & out [ 0 ] ;int i , j ;tran_low_t temp_in [ 16 ] , temp_out [ 16 ] ;const transform_2d ht = FHT_16 [ tx_type ] ;+ j ) temp_in [ j ] = input [ j * stride + i ] * 4 ;++ j ) out [ j * stride + i ] * 4 ;+ j )  outptr [ j * 16 + i ] = ( temp_out [ j ] + 1 + ( temp_out [ j ] < 0 ) ) >> 2 ;++ j ) outptr [ j * 16 + i ] = ( temp_out [ j ] + 1 + ( temp_out [ j ] < 0 ) ) >> 2 ;}",615
838,"buggy line: else if ( g_str_has_prefix ( arg , ""@@"" ) )  g_print ( _ ( ""Skipping<S2SV_blank>invalid<S2SV_blank>Exec<S2SV_blank>argument<S2SV_blank>%s\\\else g_string_append_printf ( new_exec , ""<S2SV_blank>%s"" , arg ) ;cwe id:CWE-74context: static gboolean export_desktop_file ( const char * app , const char * branch , const char * arch , GKeyFile * metadata , const char * const * previous_ids , int parent_fd , const char * name , struct stat * stat_buf , char * * target , GCancellable * cancellable , GError * * error ) { gboolean ret = FALSE ; glnx_autofd int desktop_fd = - 1 ; g_autofree char * tmpfile_name = g_strdup_printf ( ""export-desktop-XXXXXX"" ) ; g_autoptr ( GOutputStream ) out_stream = NULL ; g_autofree gchar * data = NULL ; gsize data_len ; g_autofree gchar * new_data = NULL ; gsize new_data_len ; g_autoptr ( GKeyFile ) keyfile = NULL ; g_autofree gchar * old_exec = NULL ; gint old_argc ; g_auto ( GStrv ) old_argv = NULL ; g_auto ( GStrv ) groups = NULL ; GString * new_exec = NULL ; g_autofree char * escaped_app = maybe_quote ( app ) ; g_autofree char * escaped_branch = maybe_quote ( branch ) ; g_autofree char * escaped_arch = maybe_quote ( arch ) ; int i ; if ( ! flatpak_openat_noatime ( parent_fd , name , & desktop_fd , cancellable , error ) ) goto out ; if ( ! read_fd ( desktop_fd , stat_buf , & data , & data_len , error ) ) goto out ; keyfile = g_key_file_new ( ) ; if ( ! g_key_file_load_from_data ( keyfile , data , data_len , G_KEY_FILE_KEEP_TRANSLATIONS , error ) ) goto out ; if ( g_str_has_suffix ( name , "".service"" ) ) { g_autofree gchar * dbus_name = NULL ; g_autofree gchar * expected_dbus_name = g_strndup ( name , strlen ( name ) - strlen ( "".service"" ) ) ; dbus_name = g_key_file_get_string ( keyfile , ""D-BUS<S2SV_blank>Service"" , ""Name"" , NULL ) ; if ( dbus_name == NULL || strcmp ( dbus_name , expected_dbus_name ) != 0 ) { return flatpak_fail_error ( error , FLATPAK_ERROR_EXPORT_FAILED , _ ( ""D-Bus<S2SV_blank>service<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>has<S2SV_blank>wrong<S2SV_blank>name"" ) , name ) ; } } if ( g_str_has_suffix ( name , "".desktop"" ) ) { gsize length ; g_auto ( GStrv ) tags = g_key_file_get_string_list ( metadata , ""Application"" , ""tags"" , & length , NULL ) ; if ( tags != NULL ) { g_key_file_set_string_list ( keyfile , G_KEY_FILE_DESKTOP_GROUP , ""X-Flatpak-Tags"" , ( const char * const * ) tags , length ) ; } g_key_file_set_string ( keyfile , G_KEY_FILE_DESKTOP_GROUP , ""X-Flatpak"" , app ) ; if ( previous_ids != NULL ) { const char * X_FLATPAK_RENAMED_FROM = ""X-Flatpak-RenamedFrom"" ; g_auto ( GStrv ) renamed_from = g_key_file_get_string_list ( keyfile , G_KEY_FILE_DESKTOP_GROUP , X_FLATPAK_RENAMED_FROM , NULL , NULL ) ; g_autoptr ( GPtrArray ) merged = g_ptr_array_new_with_free_func ( g_free ) ; g_autoptr ( GHashTable ) seen = g_hash_table_new ( g_str_hash , g_str_equal ) ; const char * new_suffix ; for ( i = 0 ; renamed_from != NULL && renamed_from [ i ] != NULL ; i ++ ) { if ( ! g_hash_table_contains ( seen , renamed_from [ i ] ) ) { gchar * copy = g_strdup ( renamed_from [ i ] ) ; g_hash_table_insert ( seen , copy , copy ) ; g_ptr_array_add ( merged , g_steal_pointer ( & copy ) ) ; } } g_assert ( g_str_has_prefix ( name , app ) ) ; new_suffix = name + strlen ( app ) ; for ( i = 0 ; previous_ids [ i ] != NULL ; i ++ ) { g_autofree gchar * previous_desktop = g_strconcat ( previous_ids [ i ] , new_suffix , NULL ) ; if ( ! g_hash_table_contains ( seen , previous_desktop ) ) { g_hash_table_insert ( seen , previous_desktop , previous_desktop ) ; g_ptr_array_add ( merged , g_steal_pointer ( & previous_desktop ) ) ; } } if ( merged -> len > 0 ) { g_ptr_array_add ( merged , NULL ) ; g_key_file_set_string_list ( keyfile , G_KEY_FILE_DESKTOP_GROUP , X_FLATPAK_RENAMED_FROM , ( const char * const * ) merged -> pdata , merged -> len - 1 ) ; } } } groups = g_key_file_get_groups ( keyfile , NULL ) ; for ( i = 0 ; groups [ i ] != NULL ; i ++ ) { g_auto ( GStrv ) flatpak_run_opts = g_key_file_get_string_list ( keyfile , groups [ i ] , ""X-Flatpak-RunOptions"" , NULL , NULL ) ; g_autofree char * flatpak_run_args = format_flatpak_run_args_from_run_opts ( flatpak_run_opts ) ; g_key_file_remove_key ( keyfile , groups [ i ] , ""X-Flatpak-RunOptions"" , NULL ) ; g_key_file_remove_key ( keyfile , groups [ i ] , ""TryExec"" , NULL ) ; g_key_file_remove_key ( keyfile , groups [ i ] , ""X-GNOME-Bugzilla-ExtraInfoScript"" , NULL ) ; new_exec = g_string_new ( """" ) ; g_string_append_printf ( new_exec , FLATPAK_BINDIR ""/flatpak<S2SV_blank>run<S2SV_blank>--branch=%s<S2SV_blank>--arch=%s"" , escaped_branch , escaped_arch ) ; if ( flatpak_run_args != NULL ) g_string_append_printf ( new_exec , ""%s"" , flatpak_run_args ) ; old_exec = g_key_file_get_string ( keyfile , groups [ i ] , ""Exec"" , NULL ) ; if ( old_exec && g_shell_parse_argv ( old_exec , & old_argc , & old_argv , NULL ) && old_argc >= 1 ) { int j ; g_autofree char * command = maybe_quote ( old_argv [ 0 ] ) ; g_string_append_printf ( new_exec , ""<S2SV_blank>--command=%s"" , command ) ; for ( j = 1 ; j < old_argc ; j ++ ) { if ( strcasecmp ( old_argv [ j ] , ""%f"" ) == 0 || strcasecmp ( old_argv [ j ] , ""%u"" ) == 0 ) { g_string_append ( new_exec , ""<S2SV_blank>--file-forwarding"" ) ; break ; } } g_string_append ( new_exec , ""<S2SV_blank>"" ) ; g_string_append ( new_exec , escaped_app ) ; for ( j = 1 ; j < old_argc ; j ++ ) { g_autofree char * arg = maybe_quote ( old_argv [ j ] ) ; if ( strcasecmp ( arg , ""%f"" ) == 0 ) g_string_append_printf ( new_exec , ""<S2SV_blank>@@<S2SV_blank>%s<S2SV_blank>@@"" , arg ) ; else if ( strcasecmp ( arg , ""%u"" ) == 0 ) g_string_append_printf ( new_exec , ""<S2SV_blank>@@u<S2SV_blank>%s<S2SV_blank>@@"" , arg ) ; else if ( g_str_has_prefix ( arg , ""@@"" ) )  g_print ( _ ( ""Skipping<S2SV_blank>invalid<S2SV_blank>Exec<S2SV_blank>argument<S2SV_blank>%s\\n"" ) , arg ) ;  else g_string_append_printf ( new_exec , ""<S2SV_blank>%s"" , arg ) ; } } else { g_string_append ( new_exec , ""<S2SV_blank>"" ) ; g_string_append ( new_exec , escaped_app ) ; } g_key_file_set_string ( keyfile , groups [ i ] , G_KEY_FILE_DESKTOP_KEY_EXEC , new_exec -> str ) ; } new_data = g_key_file_to_data ( keyfile , & new_data_len , error ) ; if ( new_data == NULL ) goto out ; if ( ! flatpak_open_in_tmpdir_at ( parent_fd , 0755 , tmpfile_name , & out_stream , cancellable , error ) ) goto out ; if ( ! g_output_stream_write_all ( out_stream , new_data , new_data_len , NULL , cancellable , error ) ) goto out ; if ( ! g_output_stream_close ( out_stream , cancellable , error ) ) goto out ; if ( target ) * target = g_steal_pointer ( & tmpfile_name ) ; ret = TRUE ; out : if ( new_exec != NULL ) g_string_free ( new_exec , TRUE ) ; return ret ; }","else if ( g_str_has_prefix ( arg , ""@@"" ) ) {flatpak_fail_error ( error , FLATPAK_ERROR_EXPORT_FAILED , _ ( ""Invalid<S2SV_blank>Exec<S2SV_blank>argument<S2SV_blank>%s"" ) , arg ) ;goto out ;}else g_string_append_printf ( new_exec , ""<S2SV_blank>%s"" , arg ) ;",616
839,"buggy line: if ( ! IS_POSIXACL ( inode ) || ! inode -> i_op -> set_acl ) {error = - EOPNOTSUPP ;goto out_errno ;}error = fh_want_write ( fh ) ;if ( error )  goto out_errno ;error = inode -> i_op -> set_acl ( inode , argp -> acl_access , ACL_TYPE_ACCESS ) ;if ( error ) goto out_drop_write ;error = inode -> i_op -> set_acl ( inode , argp -> acl_default ,  ACL_TYPE_DEFAULT ) ;cwe id:CWE-284context: static __be32 nfsd3_proc_setacl ( struct svc_rqst * rqstp , struct nfsd3_setaclargs * argp , struct nfsd3_attrstat * resp ) { struct inode * inode ; svc_fh * fh ; __be32 nfserr = 0 ; int error ; fh = fh_copy ( & resp -> fh , & argp -> fh ) ; nfserr = fh_verify ( rqstp , & resp -> fh , 0 , NFSD_MAY_SATTR ) ; if ( nfserr ) goto out ; inode = d_inode ( fh -> fh_dentry ) ;  if ( ! IS_POSIXACL ( inode ) || ! inode -> i_op -> set_acl ) {  error = - EOPNOTSUPP ; goto out_errno ;  }  error = fh_want_write ( fh ) ; if ( error )  goto out_errno ;  error = inode -> i_op -> set_acl ( inode , argp -> acl_access , ACL_TYPE_ACCESS ) ; if ( error ) goto out_drop_write ;  error = inode -> i_op -> set_acl ( inode , argp -> acl_default ,  ACL_TYPE_DEFAULT ) ; out_drop_write : fh_drop_write ( fh ) ; out_errno : nfserr = nfserrno ( error ) ; out : posix_acl_release ( argp -> acl_access ) ; posix_acl_release ( argp -> acl_default ) ; RETURN_STATUS ( nfserr ) ; }","error = fh_want_write ( fh ) ;if ( error ) goto out_errno ;}error = fh_want_write ( fh ) ;if ( error ) goto out_errno ;fh_lock ( fh ) ;error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access ) ;if ( error ) goto out_drop_lock ;error = set_posix_acl ( inode , ACL_TYPE_DEFAULT , argp -> acl_default , ACL_TYPE_DEFAULT ) ;",617
840,"buggy line: BUG_IF ( tree_root == NULL ) ;fprintf ( stdout , ""<S2SV_blank>Unfolding<S2SV_blank>the<S2SV_blank>meta-tree<S2SV_blank>"" ) ;cwe id:CWE-125context: size_t compile_tree ( struct filter_op * * fop ) { int i = 1 ; struct filter_op * array = NULL ; struct unfold_elm * ue ;  BUG_IF ( tree_root == NULL ) ;  fprintf ( stdout , ""<S2SV_blank>Unfolding<S2SV_blank>the<S2SV_blank>meta-tree<S2SV_blank>"" ) ; fflush ( stdout ) ; unfold_blk ( & tree_root ) ; fprintf ( stdout , ""<S2SV_blank>done.\\n\\n"" ) ; labels_to_offsets ( ) ; TAILQ_FOREACH ( ue , & unfolded_tree , next ) { if ( ue -> label == 0 ) { SAFE_REALLOC ( array , i * sizeof ( struct filter_op ) ) ; memcpy ( & array [ i - 1 ] , & ue -> fop , sizeof ( struct filter_op ) ) ; i ++ ; } } SAFE_REALLOC ( array , i * sizeof ( struct filter_op ) ) ; array [ i - 1 ] . opcode = FOP_EXIT ; * fop = array ; return ( i ) ; }","if ( tree_root == NULL ) return 0 ;fprintf ( stdout , ""<S2SV_blank>Unfolding<S2SV_blank>the<S2SV_blank>meta-tree<S2SV_blank>"" ) ;",618
841,"buggy line: char * temp_filename = osi_calloc ( strlen ( filename ) + 5 ) ;if ( ! temp_filename ) {LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>filename."" , __func__ ) ;return false ;strcpy ( temp_filename , filename ) ;strcat ( temp_filename , "".new"" ) ;FILE * fp = fopen ( temp_filename , ""wt"" ) ;cwe id:CWE-284context: bool config_save ( const config_t * config , const char * filename ) { assert ( config != NULL ) ; assert ( filename != NULL ) ; assert ( * filename != '\\0' ) ;  char * temp_filename = osi_calloc ( strlen ( filename ) + 5 ) ;   if ( ! temp_filename ) {  LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>filename."" , __func__ ) ; return false ; } strcpy ( temp_filename , filename ) ; strcat ( temp_filename , "".new"" ) ; FILE * fp = fopen ( temp_filename , ""wt"" ) ; if ( ! fp ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>file<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , temp_filename , strerror ( errno ) ) ; goto error ; } for ( const list_node_t * node = list_begin ( config -> sections ) ; node != list_end ( config -> sections ) ; node = list_next ( node ) ) { const section_t * section = ( const section_t * ) list_node ( node ) ;  fprintf ( fp , ""[%s]\\n"" , section -> name ) ;  for ( const list_node_t * enode = list_begin ( section -> entries ) ; enode != list_end ( section -> entries ) ; enode = list_next ( enode ) ) { const entry_t * entry = ( const entry_t * ) list_node ( enode ) ;  fprintf ( fp , ""%s<S2SV_blank>=<S2SV_blank>%s\\n"" , entry -> key , entry -> value ) ;  } if ( list_next ( node ) != list_end ( config -> sections ) )  fputc ( '\\n' , fp ) ;  } fflush ( fp ) ;  fclose ( fp ) ;  if ( chmod ( temp_filename , S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP ) == - 1 ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>change<S2SV_blank>file<S2SV_blank>permissions<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , filename , strerror ( errno ) ) ; goto error ; } if ( rename ( temp_filename , filename ) == - 1 ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>commit<S2SV_blank>file<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , filename , strerror ( errno ) ) ; goto error ; }  osi_free ( temp_filename ) ;  return true ;  error : ;  unlink ( temp_filename ) ;  osi_free ( temp_filename ) ;  return false ; }","int dir_fd = - 1 ;FILE * fp = NULL ;static const char * temp_file_ext = "".new"" ;const int filename_len = strlen ( filename ) ;const int temp_filename_len = filename_len + strlen ( temp_file_ext ) + 1 ;char * temp_filename = osi_calloc ( temp_filename_len ) ;snprintf ( temp_filename , temp_filename_len , ""%s%s"" , filename , temp_file_ext ) ;char * temp_dirname = osi_strdup ( filename ) ;const char * directoryname = dirname ( temp_dirname ) ;if ( ! directoryname ) {LOG_ERROR ( ""%s<S2SV_blank>error<S2SV_blank>extracting<S2SV_blank>directory<S2SV_blank>from<S2SV_blank>\\\'%s\\\':<S2SV_blank>%s"" , __func__ , filename , strerror ( errno ) ) ;goto error ;dir_fd = TEMP_FAILURE_RETRY ( open ( directoryname , O_RDONLY ) ) ;if ( dir_fd < 0 ) {LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>dir<S2SV_blank>\\\'%s\\\':<S2SV_blank>%s"" , __func__ , directoryname , strerror ( errno ) ) ;goto error ;}fp = fopen ( temp_filename , ""wt"" ) ;",619
842,"buggy line: fprintf ( fp , ""[%s]\\\for ( const list_node_t * enode = list_begin ( section -> entries ) ;fprintf ( fp , ""%s<S2SV_blank>=<S2SV_blank>%s\\\}if ( list_next ( node ) != list_end ( config -> sections ) )  fputc ( \'\\\}fflush ( fp ) ;fclose ( fp ) ;if ( chmod ( temp_filename , S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP ) == - 1 ) {cwe id:CWE-284context: bool config_save ( const config_t * config , const char * filename ) { assert ( config != NULL ) ; assert ( filename != NULL ) ; assert ( * filename != '\\0' ) ;  char * temp_filename = osi_calloc ( strlen ( filename ) + 5 ) ;   if ( ! temp_filename ) {  LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>filename."" , __func__ ) ; return false ; } strcpy ( temp_filename , filename ) ; strcat ( temp_filename , "".new"" ) ; FILE * fp = fopen ( temp_filename , ""wt"" ) ; if ( ! fp ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>file<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , temp_filename , strerror ( errno ) ) ; goto error ; } for ( const list_node_t * node = list_begin ( config -> sections ) ; node != list_end ( config -> sections ) ; node = list_next ( node ) ) { const section_t * section = ( const section_t * ) list_node ( node ) ;  fprintf ( fp , ""[%s]\\n"" , section -> name ) ;  for ( const list_node_t * enode = list_begin ( section -> entries ) ; enode != list_end ( section -> entries ) ; enode = list_next ( enode ) ) { const entry_t * entry = ( const entry_t * ) list_node ( enode ) ;  fprintf ( fp , ""%s<S2SV_blank>=<S2SV_blank>%s\\n"" , entry -> key , entry -> value ) ;  } if ( list_next ( node ) != list_end ( config -> sections ) )  fputc ( '\\n' , fp ) ;  } fflush ( fp ) ;  fclose ( fp ) ;  if ( chmod ( temp_filename , S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP ) == - 1 ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>change<S2SV_blank>file<S2SV_blank>permissions<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , filename , strerror ( errno ) ) ; goto error ; } if ( rename ( temp_filename , filename ) == - 1 ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>commit<S2SV_blank>file<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , filename , strerror ( errno ) ) ; goto error ; }  osi_free ( temp_filename ) ;  return true ;  error : ;  unlink ( temp_filename ) ;  osi_free ( temp_filename ) ;  return false ; }","if ( fprintf ( fp , ""[%s]\\\LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>to<S2SV_blank>file<S2SV_blank>\\\'%s\\\':<S2SV_blank>%s"" , __func__ , temp_filename , strerror ( errno ) ) ;goto error ;}for ( const list_node_t * enode = list_begin ( section -> entries ) ;if ( fprintf ( fp , ""%s<S2SV_blank>=<S2SV_blank>%s\\\LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>to<S2SV_blank>file<S2SV_blank>\\\'%s\\\':<S2SV_blank>%s"" , __func__ , temp_filename , strerror ( errno ) ) ;goto error ;}}if ( list_next ( node ) != list_end ( config -> sections ) ) {if ( fputc ( \'\\\LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>to<S2SV_blank>file<S2SV_blank>\\\'%s\\\':<S2SV_blank>%s"" , __func__ , temp_filename , strerror ( errno ) ) ;goto error ;}}}if ( fsync ( fileno ( fp ) == EOF ) {LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>close<S2SV_blank>file<S2SV_blank>\\\'%s\\\':<S2SV_blank>%s"" , __func__ , temp_filename , strerror ( errno ) ) ;goto error ;}if ( fsync ( dir_fd ) < 0 ) {LOG_WARN ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>fsync<S2SV_blank>dir<S2SV_blank>\\\'%s\\\':<S2SV_blank>%s"" , __func__ , directoryname , strerror ( errno ) ) ;}if ( close ( dir_fd ) < 0 ) {LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>close<S2SV_blank>dir<S2SV_blank>\\\'%s\\\':<S2SV_blank>%s"" , __func__ , directoryname , strerror ( errno ) ) ;goto error ;}fp = NULL ) < 0 ) {LOG_WARN ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>fsync<S2SV_blank>file<S2SV_blank>\\\'%s\\\':<S2SV_blank>%s"" , __func__ , temp_filename , strerror ( errno ) ) ;}if ( fclose ( fp ) ;if ( chmod ( temp_filename , S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP ) == - 1 ) {",619
843,"buggy line: osi_free ( temp_filename ) ;return true ;error : ;unlink ( temp_filename ) ;osi_free ( temp_filename ) ;return false ;cwe id:CWE-284context: bool config_save ( const config_t * config , const char * filename ) { assert ( config != NULL ) ; assert ( filename != NULL ) ; assert ( * filename != '\\0' ) ;  char * temp_filename = osi_calloc ( strlen ( filename ) + 5 ) ;   if ( ! temp_filename ) {  LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>filename."" , __func__ ) ; return false ; } strcpy ( temp_filename , filename ) ; strcat ( temp_filename , "".new"" ) ; FILE * fp = fopen ( temp_filename , ""wt"" ) ; if ( ! fp ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>file<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , temp_filename , strerror ( errno ) ) ; goto error ; } for ( const list_node_t * node = list_begin ( config -> sections ) ; node != list_end ( config -> sections ) ; node = list_next ( node ) ) { const section_t * section = ( const section_t * ) list_node ( node ) ;  fprintf ( fp , ""[%s]\\n"" , section -> name ) ;  for ( const list_node_t * enode = list_begin ( section -> entries ) ; enode != list_end ( section -> entries ) ; enode = list_next ( enode ) ) { const entry_t * entry = ( const entry_t * ) list_node ( enode ) ;  fprintf ( fp , ""%s<S2SV_blank>=<S2SV_blank>%s\\n"" , entry -> key , entry -> value ) ;  } if ( list_next ( node ) != list_end ( config -> sections ) )  fputc ( '\\n' , fp ) ;  } fflush ( fp ) ;  fclose ( fp ) ;  if ( chmod ( temp_filename , S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP ) == - 1 ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>change<S2SV_blank>file<S2SV_blank>permissions<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , filename , strerror ( errno ) ) ; goto error ; } if ( rename ( temp_filename , filename ) == - 1 ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>commit<S2SV_blank>file<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , filename , strerror ( errno ) ) ; goto error ; }  osi_free ( temp_filename ) ;  return true ;  error : ;  unlink ( temp_filename ) ;  osi_free ( temp_filename ) ;  return false ; }",osi_free ( temp_filename ) ;osi_free ( temp_dirname ) ;return true ;error : unlink ( temp_filename ) ;if ( fp ) fclose ( fp ) ;if ( dir_fd != - 1 ) close ( dir_fd ) ;osi_free ( temp_filename ) ;osi_free ( temp_dirname ) ;return false ;,619
844,"buggy line: switch ( pc -> componentType ) {case 1 : if ( pc -> lengthComponentIdent > 0 )  break ;case 2 : if ( tolen == 0 ) return - ENAMETOOLONG ;p = to ;* p ++ = \'/\' ;tolen -- ;break ;case 3 : if ( tolen < 3 ) return - ENAMETOOLONG ;memcpy ( p , ""../"" , 3 ) ;p += 3 ;tolen -= 3 ;break ;case 4 : if ( tolen < 2 ) return - ENAMETOOLONG ;memcpy ( p , ""./"" , 2 ) ;p += 2 ;tolen -= 2 ;break ;case 5 :  comp_len = udf_get_filename ( sb , pc -> componentIdent , pc -> lengthComponentIdent , p , tolen ) ;p += comp_len ;tolen -= comp_len ;if ( tolen == 0 ) return - ENAMETOOLONG ;* p ++ = \'/\' ;tolen -- ;elen += sizeof ( struct pathComponent ) + pc -> lengthComponentIdent ;}cwe id:CWE-000context: static int udf_pc_to_char ( struct super_block * sb , unsigned char * from , int fromlen , unsigned char * to , int tolen ) { struct pathComponent * pc ; int elen = 0 ; int comp_len ; unsigned char * p = to ; tolen -- ; while ( elen < fromlen ) { pc = ( struct pathComponent * ) ( from + elen ) ;  switch ( pc -> componentType ) {  case 1 : if ( pc -> lengthComponentIdent > 0 )  break ;  case 2 : if ( tolen == 0 ) return - ENAMETOOLONG ; p = to ; * p ++ = '/' ; tolen -- ; break ; case 3 : if ( tolen < 3 ) return - ENAMETOOLONG ; memcpy ( p , ""../"" , 3 ) ; p += 3 ; tolen -= 3 ; break ; case 4 : if ( tolen < 2 ) return - ENAMETOOLONG ; memcpy ( p , ""./"" , 2 ) ; p += 2 ; tolen -= 2 ; break ;  case 5 :  comp_len = udf_get_filename ( sb , pc -> componentIdent , pc -> lengthComponentIdent , p , tolen ) ; p += comp_len ; tolen -= comp_len ; if ( tolen == 0 ) return - ENAMETOOLONG ; * p ++ = '/' ; tolen -- ; break ; }  elen += sizeof ( struct pathComponent ) + pc -> lengthComponentIdent ;  } if ( p > to + 1 ) p [ - 1 ] = '\\0' ; else p [ 0 ] = '\\0' ; return 0 ; }",elen += sizeof ( struct pathComponent ) ;switch ( pc -> componentType ) {case 1 : if ( pc -> lengthComponentIdent > 0 ) {elen += pc -> lengthComponentIdent ;},620
845,"buggy line: ND_TCHECK ( dp [ 0 ] ) ;cwe id:CWE-125context: void nfsreq_print_noaddr ( netdissect_options * ndo , register const u_char * bp , u_int length , register const u_char * bp2 ) { register const struct sunrpc_msg * rp ; register const uint32_t * dp ; nfs_type type ; int v3 ; uint32_t proc ; uint32_t access_flags ; struct nfsv3_sattr sa3 ; ND_PRINT ( ( ndo , ""%d"" , length ) ) ; nfserr = 0 ; rp = ( const struct sunrpc_msg * ) bp ; if ( ! xid_map_enter ( ndo , rp , bp2 ) ) goto trunc ; v3 = ( EXTRACT_32BITS ( & rp -> rm_call . cb_vers ) == NFS_VER3 ) ; proc = EXTRACT_32BITS ( & rp -> rm_call . cb_proc ) ; if ( ! v3 && proc < NFS_NPROCS ) proc = nfsv3_procid [ proc ] ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , tok2str ( nfsproc_str , ""proc-%u"" , proc ) ) ) ; switch ( proc ) { case NFSPROC_GETATTR : case NFSPROC_SETATTR : case NFSPROC_READLINK : case NFSPROC_FSSTAT : case NFSPROC_FSINFO : case NFSPROC_PATHCONF : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && parsefh ( ndo , dp , v3 ) != NULL ) return ; break ; case NFSPROC_LOOKUP : case NFSPROC_CREATE : case NFSPROC_MKDIR : case NFSPROC_REMOVE : case NFSPROC_RMDIR : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && parsefhn ( ndo , dp , v3 ) != NULL ) return ; break ; case NFSPROC_ACCESS : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefh ( ndo , dp , v3 ) ) != NULL ) { ND_TCHECK ( dp [ 0 ] ) ; access_flags = EXTRACT_32BITS ( & dp [ 0 ] ) ; if ( access_flags & ~ NFSV3ACCESS_FULL ) { ND_PRINT ( ( ndo , ""<S2SV_blank>%04x"" , access_flags ) ) ; } else if ( ( access_flags & NFSV3ACCESS_FULL ) == NFSV3ACCESS_FULL ) { ND_PRINT ( ( ndo , ""<S2SV_blank>NFS_ACCESS_FULL"" ) ) ; } else { char separator = '<S2SV_blank>' ; if ( access_flags & NFSV3ACCESS_READ ) { ND_PRINT ( ( ndo , ""<S2SV_blank>NFS_ACCESS_READ"" ) ) ; separator = '|' ; } if ( access_flags & NFSV3ACCESS_LOOKUP ) { ND_PRINT ( ( ndo , ""%cNFS_ACCESS_LOOKUP"" , separator ) ) ; separator = '|' ; } if ( access_flags & NFSV3ACCESS_MODIFY ) { ND_PRINT ( ( ndo , ""%cNFS_ACCESS_MODIFY"" , separator ) ) ; separator = '|' ; } if ( access_flags & NFSV3ACCESS_EXTEND ) { ND_PRINT ( ( ndo , ""%cNFS_ACCESS_EXTEND"" , separator ) ) ; separator = '|' ; } if ( access_flags & NFSV3ACCESS_DELETE ) { ND_PRINT ( ( ndo , ""%cNFS_ACCESS_DELETE"" , separator ) ) ; separator = '|' ; } if ( access_flags & NFSV3ACCESS_EXECUTE ) ND_PRINT ( ( ndo , ""%cNFS_ACCESS_EXECUTE"" , separator ) ) ; } return ; } break ; case NFSPROC_READ : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefh ( ndo , dp , v3 ) ) != NULL ) { if ( v3 ) { ND_TCHECK ( dp [ 2 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%"" PRIu64 , EXTRACT_32BITS ( & dp [ 2 ] ) , EXTRACT_64BITS ( & dp [ 0 ] ) ) ) ; } else { ND_TCHECK ( dp [ 1 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%u"" , EXTRACT_32BITS ( & dp [ 1 ] ) , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; } return ; } break ; case NFSPROC_WRITE : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefh ( ndo , dp , v3 ) ) != NULL ) { if ( v3 ) {  ND_TCHECK ( dp [ 2 ] ) ;  ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>(%u)<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%"" PRIu64 , EXTRACT_32BITS ( & dp [ 4 ] ) , EXTRACT_32BITS ( & dp [ 2 ] ) , EXTRACT_64BITS ( & dp [ 0 ] ) ) ) ; if ( ndo -> ndo_vflag ) {  dp += 3 ;  ND_TCHECK ( dp [ 0 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank><%s>"" , tok2str ( nfsv3_writemodes , NULL , EXTRACT_32BITS ( dp ) ) ) ) ; } } else { ND_TCHECK ( dp [ 3 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>(%u)<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%u<S2SV_blank>(%u)"" , EXTRACT_32BITS ( & dp [ 3 ] ) , EXTRACT_32BITS ( & dp [ 2 ] ) , EXTRACT_32BITS ( & dp [ 1 ] ) , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; } return ; } break ; case NFSPROC_SYMLINK : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefhn ( ndo , dp , v3 ) ) != NULL ) { ND_PRINT ( ( ndo , ""<S2SV_blank>->"" ) ) ; if ( v3 && ( dp = parse_sattr3 ( ndo , dp , & sa3 ) ) == NULL ) break ; if ( parsefn ( ndo , dp ) == NULL ) break ; if ( v3 && ndo -> ndo_vflag ) print_sattr3 ( ndo , & sa3 , ndo -> ndo_vflag ) ; return ; } break ; case NFSPROC_MKNOD : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefhn ( ndo , dp , v3 ) ) != NULL ) { ND_TCHECK ( * dp ) ; type = ( nfs_type ) EXTRACT_32BITS ( dp ) ; dp ++ ; if ( ( dp = parse_sattr3 ( ndo , dp , & sa3 ) ) == NULL ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , tok2str ( type2str , ""unk-ft<S2SV_blank>%d"" , type ) ) ) ; if ( ndo -> ndo_vflag && ( type == NFCHR || type == NFBLK ) ) { ND_TCHECK ( dp [ 1 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u/%u"" , EXTRACT_32BITS ( & dp [ 0 ] ) , EXTRACT_32BITS ( & dp [ 1 ] ) ) ) ; dp += 2 ; } if ( ndo -> ndo_vflag ) print_sattr3 ( ndo , & sa3 , ndo -> ndo_vflag ) ; return ; } break ; case NFSPROC_RENAME : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefhn ( ndo , dp , v3 ) ) != NULL ) { ND_PRINT ( ( ndo , ""<S2SV_blank>->"" ) ) ; if ( parsefhn ( ndo , dp , v3 ) != NULL ) return ; } break ; case NFSPROC_LINK : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefh ( ndo , dp , v3 ) ) != NULL ) { ND_PRINT ( ( ndo , ""<S2SV_blank>->"" ) ) ; if ( parsefhn ( ndo , dp , v3 ) != NULL ) return ; } break ; case NFSPROC_READDIR : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefh ( ndo , dp , v3 ) ) != NULL ) { if ( v3 ) { ND_TCHECK ( dp [ 4 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%"" PRId64 , EXTRACT_32BITS ( & dp [ 4 ] ) , EXTRACT_64BITS ( & dp [ 0 ] ) ) ) ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""<S2SV_blank>verf<S2SV_blank>%08x%08x"" , dp [ 2 ] , dp [ 3 ] ) ) ; } else { ND_TCHECK ( dp [ 1 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%d"" , EXTRACT_32BITS ( & dp [ 1 ] ) , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; } return ; } break ; case NFSPROC_READDIRPLUS : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefh ( ndo , dp , v3 ) ) != NULL ) { ND_TCHECK ( dp [ 4 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%"" PRId64 , EXTRACT_32BITS ( & dp [ 4 ] ) , EXTRACT_64BITS ( & dp [ 0 ] ) ) ) ; if ( ndo -> ndo_vflag ) { ND_TCHECK ( dp [ 5 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>max<S2SV_blank>%u<S2SV_blank>verf<S2SV_blank>%08x%08x"" , EXTRACT_32BITS ( & dp [ 5 ] ) , dp [ 2 ] , dp [ 3 ] ) ) ; } return ; } break ; case NFSPROC_COMMIT : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefh ( ndo , dp , v3 ) ) != NULL ) { ND_TCHECK ( dp [ 2 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%"" PRIu64 , EXTRACT_32BITS ( & dp [ 2 ] ) , EXTRACT_64BITS ( & dp [ 0 ] ) ) ) ; return ; } break ; default : return ; } trunc : if ( ! nfserr ) ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; }",ND_TCHECK ( dp [ 4 ] ) ;,621
846,"buggy line: ND_TCHECK ( dp [ 2 ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>(%u)<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%"" PRIu64 , EXTRACT_32BITS ( & dp [ 4 ] ) , EXTRACT_32BITS ( & dp [ 2 ] ) , EXTRACT_64BITS ( & dp [ 0 ] ) ) ) ;dp += 3 ;ND_TCHECK ( dp [ 0 ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank><%s>"" , tok2str ( nfsv3_writemodes , NULL , EXTRACT_32BITS ( dp ) ) ) ) ;cwe id:CWE-125context: void nfsreq_print_noaddr ( netdissect_options * ndo , register const u_char * bp , u_int length , register const u_char * bp2 ) { register const struct sunrpc_msg * rp ; register const uint32_t * dp ; nfs_type type ; int v3 ; uint32_t proc ; uint32_t access_flags ; struct nfsv3_sattr sa3 ; ND_PRINT ( ( ndo , ""%d"" , length ) ) ; nfserr = 0 ; rp = ( const struct sunrpc_msg * ) bp ; if ( ! xid_map_enter ( ndo , rp , bp2 ) ) goto trunc ; v3 = ( EXTRACT_32BITS ( & rp -> rm_call . cb_vers ) == NFS_VER3 ) ; proc = EXTRACT_32BITS ( & rp -> rm_call . cb_proc ) ; if ( ! v3 && proc < NFS_NPROCS ) proc = nfsv3_procid [ proc ] ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , tok2str ( nfsproc_str , ""proc-%u"" , proc ) ) ) ; switch ( proc ) { case NFSPROC_GETATTR : case NFSPROC_SETATTR : case NFSPROC_READLINK : case NFSPROC_FSSTAT : case NFSPROC_FSINFO : case NFSPROC_PATHCONF : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && parsefh ( ndo , dp , v3 ) != NULL ) return ; break ; case NFSPROC_LOOKUP : case NFSPROC_CREATE : case NFSPROC_MKDIR : case NFSPROC_REMOVE : case NFSPROC_RMDIR : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && parsefhn ( ndo , dp , v3 ) != NULL ) return ; break ; case NFSPROC_ACCESS : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefh ( ndo , dp , v3 ) ) != NULL ) { ND_TCHECK ( dp [ 0 ] ) ; access_flags = EXTRACT_32BITS ( & dp [ 0 ] ) ; if ( access_flags & ~ NFSV3ACCESS_FULL ) { ND_PRINT ( ( ndo , ""<S2SV_blank>%04x"" , access_flags ) ) ; } else if ( ( access_flags & NFSV3ACCESS_FULL ) == NFSV3ACCESS_FULL ) { ND_PRINT ( ( ndo , ""<S2SV_blank>NFS_ACCESS_FULL"" ) ) ; } else { char separator = '<S2SV_blank>' ; if ( access_flags & NFSV3ACCESS_READ ) { ND_PRINT ( ( ndo , ""<S2SV_blank>NFS_ACCESS_READ"" ) ) ; separator = '|' ; } if ( access_flags & NFSV3ACCESS_LOOKUP ) { ND_PRINT ( ( ndo , ""%cNFS_ACCESS_LOOKUP"" , separator ) ) ; separator = '|' ; } if ( access_flags & NFSV3ACCESS_MODIFY ) { ND_PRINT ( ( ndo , ""%cNFS_ACCESS_MODIFY"" , separator ) ) ; separator = '|' ; } if ( access_flags & NFSV3ACCESS_EXTEND ) { ND_PRINT ( ( ndo , ""%cNFS_ACCESS_EXTEND"" , separator ) ) ; separator = '|' ; } if ( access_flags & NFSV3ACCESS_DELETE ) { ND_PRINT ( ( ndo , ""%cNFS_ACCESS_DELETE"" , separator ) ) ; separator = '|' ; } if ( access_flags & NFSV3ACCESS_EXECUTE ) ND_PRINT ( ( ndo , ""%cNFS_ACCESS_EXECUTE"" , separator ) ) ; } return ; } break ; case NFSPROC_READ : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefh ( ndo , dp , v3 ) ) != NULL ) { if ( v3 ) { ND_TCHECK ( dp [ 2 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%"" PRIu64 , EXTRACT_32BITS ( & dp [ 2 ] ) , EXTRACT_64BITS ( & dp [ 0 ] ) ) ) ; } else { ND_TCHECK ( dp [ 1 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%u"" , EXTRACT_32BITS ( & dp [ 1 ] ) , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; } return ; } break ; case NFSPROC_WRITE : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefh ( ndo , dp , v3 ) ) != NULL ) { if ( v3 ) {  ND_TCHECK ( dp [ 2 ] ) ;  ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>(%u)<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%"" PRIu64 , EXTRACT_32BITS ( & dp [ 4 ] ) , EXTRACT_32BITS ( & dp [ 2 ] ) , EXTRACT_64BITS ( & dp [ 0 ] ) ) ) ; if ( ndo -> ndo_vflag ) {  dp += 3 ;  ND_TCHECK ( dp [ 0 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank><%s>"" , tok2str ( nfsv3_writemodes , NULL , EXTRACT_32BITS ( dp ) ) ) ) ; } } else { ND_TCHECK ( dp [ 3 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>(%u)<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%u<S2SV_blank>(%u)"" , EXTRACT_32BITS ( & dp [ 3 ] ) , EXTRACT_32BITS ( & dp [ 2 ] ) , EXTRACT_32BITS ( & dp [ 1 ] ) , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; } return ; } break ; case NFSPROC_SYMLINK : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefhn ( ndo , dp , v3 ) ) != NULL ) { ND_PRINT ( ( ndo , ""<S2SV_blank>->"" ) ) ; if ( v3 && ( dp = parse_sattr3 ( ndo , dp , & sa3 ) ) == NULL ) break ; if ( parsefn ( ndo , dp ) == NULL ) break ; if ( v3 && ndo -> ndo_vflag ) print_sattr3 ( ndo , & sa3 , ndo -> ndo_vflag ) ; return ; } break ; case NFSPROC_MKNOD : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefhn ( ndo , dp , v3 ) ) != NULL ) { ND_TCHECK ( * dp ) ; type = ( nfs_type ) EXTRACT_32BITS ( dp ) ; dp ++ ; if ( ( dp = parse_sattr3 ( ndo , dp , & sa3 ) ) == NULL ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , tok2str ( type2str , ""unk-ft<S2SV_blank>%d"" , type ) ) ) ; if ( ndo -> ndo_vflag && ( type == NFCHR || type == NFBLK ) ) { ND_TCHECK ( dp [ 1 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u/%u"" , EXTRACT_32BITS ( & dp [ 0 ] ) , EXTRACT_32BITS ( & dp [ 1 ] ) ) ) ; dp += 2 ; } if ( ndo -> ndo_vflag ) print_sattr3 ( ndo , & sa3 , ndo -> ndo_vflag ) ; return ; } break ; case NFSPROC_RENAME : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefhn ( ndo , dp , v3 ) ) != NULL ) { ND_PRINT ( ( ndo , ""<S2SV_blank>->"" ) ) ; if ( parsefhn ( ndo , dp , v3 ) != NULL ) return ; } break ; case NFSPROC_LINK : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefh ( ndo , dp , v3 ) ) != NULL ) { ND_PRINT ( ( ndo , ""<S2SV_blank>->"" ) ) ; if ( parsefhn ( ndo , dp , v3 ) != NULL ) return ; } break ; case NFSPROC_READDIR : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefh ( ndo , dp , v3 ) ) != NULL ) { if ( v3 ) { ND_TCHECK ( dp [ 4 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%"" PRId64 , EXTRACT_32BITS ( & dp [ 4 ] ) , EXTRACT_64BITS ( & dp [ 0 ] ) ) ) ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""<S2SV_blank>verf<S2SV_blank>%08x%08x"" , dp [ 2 ] , dp [ 3 ] ) ) ; } else { ND_TCHECK ( dp [ 1 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%d"" , EXTRACT_32BITS ( & dp [ 1 ] ) , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; } return ; } break ; case NFSPROC_READDIRPLUS : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefh ( ndo , dp , v3 ) ) != NULL ) { ND_TCHECK ( dp [ 4 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%"" PRId64 , EXTRACT_32BITS ( & dp [ 4 ] ) , EXTRACT_64BITS ( & dp [ 0 ] ) ) ) ; if ( ndo -> ndo_vflag ) { ND_TCHECK ( dp [ 5 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>max<S2SV_blank>%u<S2SV_blank>verf<S2SV_blank>%08x%08x"" , EXTRACT_32BITS ( & dp [ 5 ] ) , dp [ 2 ] , dp [ 3 ] ) ) ; } return ; } break ; case NFSPROC_COMMIT : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefh ( ndo , dp , v3 ) ) != NULL ) { ND_TCHECK ( dp [ 2 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%"" PRIu64 , EXTRACT_32BITS ( & dp [ 2 ] ) , EXTRACT_64BITS ( & dp [ 0 ] ) ) ) ; return ; } break ; default : return ; } trunc : if ( ! nfserr ) ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; }","ND_TCHECK ( dp [ 2 ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>(%u)<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%"" PRIu64 , EXTRACT_32BITS ( & dp [ 4 ] ) , EXTRACT_32BITS ( & dp [ 2 ] ) , EXTRACT_64BITS ( & dp [ 0 ] ) ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank><%s>"" , tok2str ( nfsv3_writemodes , NULL , EXTRACT_32BITS ( & dp [ 3 ] ) ) ) ) ;",621
847,"buggy line: if ( ndo -> ndo_vflag < 1 ) {ND_PRINT ( ( ndo , ""\\\mgmtd_len = * ( tptr + 3 ) ;if ( mgmtd_len < 1 || mgmtd_len > 32 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>[invalid<S2SV_blank>MgmtD<S2SV_blank>Len<S2SV_blank>%d]"" , mgmtd_len ) ) ;return ;}fn_printzp ( ndo , tptr + 4 , mgmtd_len , NULL ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>%s:<S2SV_blank>%u"" , tok2str ( vtp_header_values , ""Unknown"" , type ) , * ( tptr + 2 ) ) ) ;tptr += VTP_HEADER_LEN ;switch ( type ) {case VTP_SUMMARY_ADV : ND_TCHECK2 ( * tptr , 8 ) ;ND_PRINT ( ( ndo , ""\\\tptr += 8 ;ND_TCHECK2 ( * tptr , VTP_UPDATE_TIMESTAMP_LEN ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>Timestamp<S2SV_blank>0x%08x<S2SV_blank>0x%08x<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) ) ) ;tptr += VTP_UPDATE_TIMESTAMP_LEN ;ND_TCHECK2 ( * tptr , VTP_MD5_DIGEST_LEN ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>MD5<S2SV_blank>digest:<S2SV_blank>%08x%08x%08x%08x"" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) , EXTRACT_32BITS ( tptr + 12 ) ) ) ;tptr += VTP_MD5_DIGEST_LEN ;break ;case VTP_SUBSET_ADV : ND_TCHECK_32BITS ( tptr ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>Config<S2SV_blank>Rev<S2SV_blank>%x"" , EXTRACT_32BITS ( tptr ) ) ) ;tptr += 4 ;while ( tptr < ( pptr + length ) ) {ND_TCHECK_8BITS ( tptr ) ;len = * tptr ;if ( len == 0 ) break ;ND_TCHECK2 ( * tptr , len ) ;vtp_vlan = ( const struct vtp_vlan_ * ) tptr ;ND_TCHECK ( * vtp_vlan ) ;ND_PRINT ( ( ndo , ""\\\fn_printzp ( ndo , tptr + VTP_VLAN_INFO_OFFSET , vtp_vlan -> name_len , NULL ) ;len -= VTP_VLAN_INFO_OFFSET + 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ;tptr += VTP_VLAN_INFO_OFFSET + 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ;while ( len > 0 ) {type = * tptr ;tlv_len = * ( tptr + 1 ) ;if ( type == 0 || tlv_len == 0 ) {return ;ND_TCHECK2 ( * tptr , tlv_len * 2 + 2 ) ;tlv_value = EXTRACT_16BITS ( tptr + 2 ) ;cwe id:CWE-125context: void vtp_print ( netdissect_options * ndo , const u_char * pptr , u_int length ) { int type , len , tlv_len , tlv_value , mgmtd_len ; const u_char * tptr ; const struct vtp_vlan_ * vtp_vlan ; if ( length < VTP_HEADER_LEN ) goto trunc ; tptr = pptr ; ND_TCHECK2 ( * tptr , VTP_HEADER_LEN ) ; type = * ( tptr + 1 ) ; ND_PRINT ( ( ndo , ""VTPv%u,<S2SV_blank>Message<S2SV_blank>%s<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u"" , * tptr , tok2str ( vtp_message_type_values , ""Unknown<S2SV_blank>message<S2SV_blank>type"" , type ) , type , length ) ) ; if ( ndo -> ndo_vflag < 1 ) { return ; } ND_PRINT ( ( ndo , ""\\n\\tDomain<S2SV_blank>name:<S2SV_blank>"" ) ) ; mgmtd_len = * ( tptr + 3 ) ; if ( mgmtd_len < 1 || mgmtd_len > 32 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[invalid<S2SV_blank>MgmtD<S2SV_blank>Len<S2SV_blank>%d]"" , mgmtd_len ) ) ; return ; } fn_printzp ( ndo , tptr + 4 , mgmtd_len , NULL ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>%s:<S2SV_blank>%u"" , tok2str ( vtp_header_values , ""Unknown"" , type ) , * ( tptr + 2 ) ) ) ; tptr += VTP_HEADER_LEN ; switch ( type ) { case VTP_SUMMARY_ADV : ND_TCHECK2 ( * tptr , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Config<S2SV_blank>Rev<S2SV_blank>%x,<S2SV_blank>Updater<S2SV_blank>%s"" , EXTRACT_32BITS ( tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; tptr += 8 ; ND_TCHECK2 ( * tptr , VTP_UPDATE_TIMESTAMP_LEN ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>Timestamp<S2SV_blank>0x%08x<S2SV_blank>0x%08x<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) ) ) ; tptr += VTP_UPDATE_TIMESTAMP_LEN ; ND_TCHECK2 ( * tptr , VTP_MD5_DIGEST_LEN ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>MD5<S2SV_blank>digest:<S2SV_blank>%08x%08x%08x%08x"" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) , EXTRACT_32BITS ( tptr + 12 ) ) ) ; tptr += VTP_MD5_DIGEST_LEN ; break ; case VTP_SUBSET_ADV : ND_TCHECK_32BITS ( tptr ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>Config<S2SV_blank>Rev<S2SV_blank>%x"" , EXTRACT_32BITS ( tptr ) ) ) ; tptr += 4 ; while ( tptr < ( pptr + length ) ) { ND_TCHECK_8BITS ( tptr ) ; len = * tptr ; if ( len == 0 ) break ; ND_TCHECK2 ( * tptr , len ) ; vtp_vlan = ( const struct vtp_vlan_ * ) tptr ;  ND_TCHECK ( * vtp_vlan ) ;  ND_PRINT ( ( ndo , ""\\n\\tVLAN<S2SV_blank>info<S2SV_blank>status<S2SV_blank>%s,<S2SV_blank>type<S2SV_blank>%s,<S2SV_blank>VLAN-id<S2SV_blank>%u,<S2SV_blank>MTU<S2SV_blank>%u,<S2SV_blank>SAID<S2SV_blank>0x%08x,<S2SV_blank>Name<S2SV_blank>"" , tok2str ( vtp_vlan_status , ""Unknown"" , vtp_vlan -> status ) , tok2str ( vtp_vlan_type_values , ""Unknown"" , vtp_vlan -> type ) , EXTRACT_16BITS ( & vtp_vlan -> vlanid ) , EXTRACT_16BITS ( & vtp_vlan -> mtu ) , EXTRACT_32BITS ( & vtp_vlan -> index ) ) ) ;  fn_printzp ( ndo , tptr + VTP_VLAN_INFO_OFFSET , vtp_vlan -> name_len , NULL ) ;   len -= VTP_VLAN_INFO_OFFSET + 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ;   tptr += VTP_VLAN_INFO_OFFSET + 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ;  while ( len > 0 ) {  type = * tptr ;  tlv_len = * ( tptr + 1 ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t%s<S2SV_blank>(0x%04x)<S2SV_blank>TLV"" , tok2str ( vtp_vlan_tlv_values , ""Unknown"" , type ) , type ) ) ;  if ( type == 0 || tlv_len == 0 ) {  return ; }  ND_TCHECK2 ( * tptr , tlv_len * 2 + 2 ) ;  tlv_value = EXTRACT_16BITS ( tptr + 2 ) ; switch ( type ) { case VTP_VLAN_STE_HOP_COUNT : ND_PRINT ( ( ndo , "",<S2SV_blank>%u"" , tlv_value ) ) ; break ; case VTP_VLAN_PRUNING : ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>(%u)"" , tlv_value == 1 ? ""Enabled"" : ""Disabled"" , tlv_value ) ) ; break ; case VTP_VLAN_STP_TYPE : ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( vtp_stp_type_values , ""Unknown"" , tlv_value ) , tlv_value ) ) ; break ; case VTP_VLAN_BRIDGE_TYPE : ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>(%u)"" , tlv_value == 1 ? ""SRB"" : ""SRT"" , tlv_value ) ) ; break ; case VTP_VLAN_BACKUP_CRF_MODE : ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>(%u)"" , tlv_value == 1 ? ""Backup"" : ""Not<S2SV_blank>backup"" , tlv_value ) ) ; break ; case VTP_VLAN_SOURCE_ROUTING_RING_NUMBER : case VTP_VLAN_SOURCE_ROUTING_BRIDGE_NUMBER : case VTP_VLAN_PARENT_VLAN : case VTP_VLAN_TRANS_BRIDGED_VLAN : case VTP_VLAN_ARP_HOP_COUNT : default : print_unknown_data ( ndo , tptr , ""\\n\\t\\t<S2SV_blank><S2SV_blank>"" , 2 + tlv_len * 2 ) ; break ; }  len -= 2 + tlv_len * 2 ;  tptr += 2 + tlv_len * 2 ; } } break ; case VTP_ADV_REQUEST : ND_TCHECK2 ( * tptr , 4 ) ; ND_PRINT ( ( ndo , ""\\n\\tStart<S2SV_blank>value:<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr ) ) ) ; break ; case VTP_JOIN_MESSAGE : break ; default : break ; } return ; trunc : ND_PRINT ( ( ndo , ""[|vtp]"" ) ) ; }","len -= VTP_VLAN_INFO_FIXED_PART_LEN ;tptr += VTP_VLAN_INFO_FIXED_PART_LEN ;if ( len < 4 * ( ( vtp_vlan -> name_len , NULL ) ;len -= 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ;tptr += 4 * ( ( vtp_vlan -> name_len , NULL ) ;len -= VTP_VLAN_INFO_OFFSET + 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ;tptr += VTP_VLAN_INFO_OFFSET + 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ;while ( len > 0 ) {if ( len < 2 ) goto trunc ;ND_TCHECK2 ( * tptr , 2 ) ;if ( tlv_len != 1 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(invalid<S2SV_blank>TLV<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>1)"" , tlv_len ) ) ;else {type = * tptr ;tlv_len = * ( tptr + 1 ) ;if ( type == 0 || tlv_len == 0 ) {return ;ND_TCHECK2 ( * tptr , tlv_len * 2 + 2 ) ;tlv_value = EXTRACT_16BITS ( tptr + 2 ) ;",622
